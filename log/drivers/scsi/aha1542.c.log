commit 09c434b8a0047c69e48499de0107de312901e798
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Sun May 19 13:08:20 2019 +0100

    treewide: Add SPDX license identifier for more missed files
    
    Add SPDX license identifiers to all files which:
    
     - Have no license information of any form
    
     - Have MODULE_LICENCE("GPL*") inside which was used in the initial
       scan/conversion to ignore the file
    
    These files fall under the project license, GPL v2 only. The resulting SPDX
    license identifier is:
    
      GPL-2.0-only
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/scsi/aha1542.c b/drivers/scsi/aha1542.c
index ba7a5725be04..dc5667afeb27 100644
--- a/drivers/scsi/aha1542.c
+++ b/drivers/scsi/aha1542.c
@@ -1,3 +1,4 @@
+// SPDX-License-Identifier: GPL-2.0-only
 /*
  *  Driver for Adaptec AHA-1542 SCSI host adapters
  *

commit 2a3d4eb8e228061c09d5ca8bf39e7f00c2091213
Author: Christoph Hellwig <hch@lst.de>
Date:   Thu Dec 13 16:17:02 2018 +0100

    scsi: flip the default on use_clustering
    
    Most SCSI drivers want to enable "clustering", that is merging of
    segments so that they might span more than a single page.  Remove the
    ENABLE_CLUSTERING define, and require drivers to explicitly set
    DISABLE_CLUSTERING to disable this feature.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/aha1542.c b/drivers/scsi/aha1542.c
index afb693d7b44f..ba7a5725be04 100644
--- a/drivers/scsi/aha1542.c
+++ b/drivers/scsi/aha1542.c
@@ -1011,7 +1011,6 @@ static struct scsi_host_template driver_template = {
 	.this_id		= 7,
 	.sg_tablesize		= 16,
 	.unchecked_isa_dma	= 1, 
-	.use_clustering		= ENABLE_CLUSTERING,
 };
 
 static int aha1542_isa_match(struct device *pdev, unsigned int ndev)

commit 492ca4da6f0798cf20ecaf330abc8d79e540a43a
Author: James Bottomley <James.Bottomley@HansenPartnership.com>
Date:   Tue Nov 27 21:41:24 2018 -0800

    scsi: aha1542: Fix zeroday __udivdi3 warning
    
    dma_addr_t can be u64 on pae systems but isa_virt_to_bus only ever
    returns unsigned long (because an ISA physical address can only be 24
    bits). Cast to unsigned long to avoid division.
    
    Fixes: 1794ef2b150d ("scsi: aha1542: convert to DMA mapping API")
    Signed-off-by: James Bottomley <James.Bottomley@HansenPartnership.com>
    Reviewed-by: Randy Dunlap <rdunlap@infradead.org>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/aha1542.c b/drivers/scsi/aha1542.c
index a9c29757172f..afb693d7b44f 100644
--- a/drivers/scsi/aha1542.c
+++ b/drivers/scsi/aha1542.c
@@ -325,7 +325,7 @@ static irqreturn_t aha1542_interrupt(int irq, void *dev_id)
 			return IRQ_HANDLED;
 		};
 
-		mbo = (scsi2int(mb[mbi].ccbptr) - aha1542->ccb_handle) / sizeof(struct ccb);
+		mbo = (scsi2int(mb[mbi].ccbptr) - (unsigned long)aha1542->ccb_handle) / sizeof(struct ccb);
 		mbistatus = mb[mbi].status;
 		mb[mbi].status = 0;
 		aha1542->aha1542_last_mbi_used = mbi;

commit 1794ef2b150dd502bc31cb50ad36c901337b4d0e
Author: Christoph Hellwig <hch@lst.de>
Date:   Sat Nov 10 09:28:22 2018 +0100

    scsi: aha1542: convert to DMA mapping API
    
    aha1542 is one of the last users of the legacy isa_*_to_bus APIs, which
    also isn't portable enough.  Convert it to the proper DMA mapping API.
    
    Thanks to Ondrej Zary for testing and finding and fixing a crucial bug.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/aha1542.c b/drivers/scsi/aha1542.c
index 41add33e3f1f..a9c29757172f 100644
--- a/drivers/scsi/aha1542.c
+++ b/drivers/scsi/aha1542.c
@@ -58,8 +58,15 @@ struct aha1542_hostdata {
 	int aha1542_last_mbi_used;
 	int aha1542_last_mbo_used;
 	struct scsi_cmnd *int_cmds[AHA1542_MAILBOXES];
-	struct mailbox mb[2 * AHA1542_MAILBOXES];
-	struct ccb ccb[AHA1542_MAILBOXES];
+	struct mailbox *mb;
+	dma_addr_t mb_handle;
+	struct ccb *ccb;
+	dma_addr_t ccb_handle;
+};
+
+struct aha1542_cmd {
+	struct chain *chain;
+	dma_addr_t chain_handle;
 };
 
 static inline void aha1542_intr_reset(u16 base)
@@ -233,6 +240,21 @@ static int aha1542_test_port(struct Scsi_Host *sh)
 	return 1;
 }
 
+static void aha1542_free_cmd(struct scsi_cmnd *cmd)
+{
+	struct aha1542_cmd *acmd = scsi_cmd_priv(cmd);
+	struct device *dev = cmd->device->host->dma_dev;
+	size_t len = scsi_sg_count(cmd) * sizeof(struct chain);
+
+	if (acmd->chain) {
+		dma_unmap_single(dev, acmd->chain_handle, len, DMA_TO_DEVICE);
+		kfree(acmd->chain);
+	}
+
+	acmd->chain = NULL;
+	scsi_dma_unmap(cmd);
+}
+
 static irqreturn_t aha1542_interrupt(int irq, void *dev_id)
 {
 	struct Scsi_Host *sh = dev_id;
@@ -303,7 +325,7 @@ static irqreturn_t aha1542_interrupt(int irq, void *dev_id)
 			return IRQ_HANDLED;
 		};
 
-		mbo = (scsi2int(mb[mbi].ccbptr) - (isa_virt_to_bus(&ccb[0]))) / sizeof(struct ccb);
+		mbo = (scsi2int(mb[mbi].ccbptr) - aha1542->ccb_handle) / sizeof(struct ccb);
 		mbistatus = mb[mbi].status;
 		mb[mbi].status = 0;
 		aha1542->aha1542_last_mbi_used = mbi;
@@ -331,8 +353,7 @@ static irqreturn_t aha1542_interrupt(int irq, void *dev_id)
 			return IRQ_HANDLED;
 		}
 		my_done = tmp_cmd->scsi_done;
-		kfree(tmp_cmd->host_scribble);
-		tmp_cmd->host_scribble = NULL;
+		aha1542_free_cmd(tmp_cmd);
 		/* Fetch the sense data, and tuck it away, in the required slot.  The
 		   Adaptec automatically fetches it, and there is no guarantee that
 		   we will still have it in the cdb when we come back */
@@ -369,6 +390,7 @@ static irqreturn_t aha1542_interrupt(int irq, void *dev_id)
 
 static int aha1542_queuecommand(struct Scsi_Host *sh, struct scsi_cmnd *cmd)
 {
+	struct aha1542_cmd *acmd = scsi_cmd_priv(cmd);
 	struct aha1542_hostdata *aha1542 = shost_priv(sh);
 	u8 direction;
 	u8 target = cmd->device->id;
@@ -378,7 +400,6 @@ static int aha1542_queuecommand(struct Scsi_Host *sh, struct scsi_cmnd *cmd)
 	int mbo, sg_count;
 	struct mailbox *mb = aha1542->mb;
 	struct ccb *ccb = aha1542->ccb;
-	struct chain *cptr;
 
 	if (*cmd->cmnd == REQUEST_SENSE) {
 		/* Don't do the command - we have the sense data already */
@@ -398,15 +419,17 @@ static int aha1542_queuecommand(struct Scsi_Host *sh, struct scsi_cmnd *cmd)
 		print_hex_dump_bytes("command: ", DUMP_PREFIX_NONE, cmd->cmnd, cmd->cmd_len);
 	}
 #endif
-	if (bufflen) {	/* allocate memory before taking host_lock */
-		sg_count = scsi_sg_count(cmd);
-		cptr = kmalloc_array(sg_count, sizeof(*cptr),
-				     GFP_KERNEL | GFP_DMA);
-		if (!cptr)
-			return SCSI_MLQUEUE_HOST_BUSY;
-	} else {
-		sg_count = 0;
-		cptr = NULL;
+	sg_count = scsi_dma_map(cmd);
+	if (sg_count) {
+		size_t len = sg_count * sizeof(struct chain);
+
+		acmd->chain = kmalloc(len, GFP_DMA);
+		if (!acmd->chain)
+			goto out_unmap;
+		acmd->chain_handle = dma_map_single(sh->dma_dev, acmd->chain,
+				len, DMA_TO_DEVICE);
+		if (dma_mapping_error(sh->dma_dev, acmd->chain_handle))
+			goto out_free_chain;
 	}
 
 	/* Use the outgoing mailboxes in a round-robin fashion, because this
@@ -437,7 +460,8 @@ static int aha1542_queuecommand(struct Scsi_Host *sh, struct scsi_cmnd *cmd)
 	shost_printk(KERN_DEBUG, sh, "Sending command (%d %p)...", mbo, cmd->scsi_done);
 #endif
 
-	any2scsi(mb[mbo].ccbptr, isa_virt_to_bus(&ccb[mbo]));	/* This gets trashed for some reason */
+	/* This gets trashed for some reason */
+	any2scsi(mb[mbo].ccbptr, aha1542->ccb_handle + mbo * sizeof(*ccb));
 
 	memset(&ccb[mbo], 0, sizeof(struct ccb));
 
@@ -456,21 +480,18 @@ static int aha1542_queuecommand(struct Scsi_Host *sh, struct scsi_cmnd *cmd)
 		int i;
 
 		ccb[mbo].op = 2;	/* SCSI Initiator Command  w/scatter-gather */
-		cmd->host_scribble = (void *)cptr;
 		scsi_for_each_sg(cmd, sg, sg_count, i) {
-			any2scsi(cptr[i].dataptr, isa_page_to_bus(sg_page(sg))
-								+ sg->offset);
-			any2scsi(cptr[i].datalen, sg->length);
+			any2scsi(acmd->chain[i].dataptr, sg_dma_address(sg));
+			any2scsi(acmd->chain[i].datalen, sg_dma_len(sg));
 		};
 		any2scsi(ccb[mbo].datalen, sg_count * sizeof(struct chain));
-		any2scsi(ccb[mbo].dataptr, isa_virt_to_bus(cptr));
+		any2scsi(ccb[mbo].dataptr, acmd->chain_handle);
 #ifdef DEBUG
-		shost_printk(KERN_DEBUG, sh, "cptr %p: ", cptr);
-		print_hex_dump_bytes("cptr: ", DUMP_PREFIX_NONE, cptr, 18);
+		shost_printk(KERN_DEBUG, sh, "cptr %p: ", acmd->chain);
+		print_hex_dump_bytes("cptr: ", DUMP_PREFIX_NONE, acmd->chain, 18);
 #endif
 	} else {
 		ccb[mbo].op = 0;	/* SCSI Initiator Command */
-		cmd->host_scribble = NULL;
 		any2scsi(ccb[mbo].datalen, 0);
 		any2scsi(ccb[mbo].dataptr, 0);
 	};
@@ -488,24 +509,29 @@ static int aha1542_queuecommand(struct Scsi_Host *sh, struct scsi_cmnd *cmd)
 	spin_unlock_irqrestore(sh->host_lock, flags);
 
 	return 0;
+out_free_chain:
+	kfree(acmd->chain);
+	acmd->chain = NULL;
+out_unmap:
+	scsi_dma_unmap(cmd);
+	return SCSI_MLQUEUE_HOST_BUSY;
 }
 
 /* Initialize mailboxes */
 static void setup_mailboxes(struct Scsi_Host *sh)
 {
 	struct aha1542_hostdata *aha1542 = shost_priv(sh);
-	int i;
-	struct mailbox *mb = aha1542->mb;
-	struct ccb *ccb = aha1542->ccb;
-
 	u8 mb_cmd[5] = { CMD_MBINIT, AHA1542_MAILBOXES, 0, 0, 0};
+	int i;
 
 	for (i = 0; i < AHA1542_MAILBOXES; i++) {
-		mb[i].status = mb[AHA1542_MAILBOXES + i].status = 0;
-		any2scsi(mb[i].ccbptr, isa_virt_to_bus(&ccb[i]));
+		aha1542->mb[i].status = 0;
+		any2scsi(aha1542->mb[i].ccbptr,
+			 aha1542->ccb_handle + i * sizeof(struct ccb));
+		aha1542->mb[AHA1542_MAILBOXES + i].status = 0;
 	};
 	aha1542_intr_reset(sh->io_port);	/* reset interrupts, so they don't block */
-	any2scsi((mb_cmd + 2), isa_virt_to_bus(mb));
+	any2scsi(mb_cmd + 2, aha1542->mb_handle);
 	if (aha1542_out(sh->io_port, mb_cmd, 5))
 		shost_printk(KERN_ERR, sh, "failed setting up mailboxes\n");
 	aha1542_intr_reset(sh->io_port);
@@ -739,11 +765,26 @@ static struct Scsi_Host *aha1542_hw_init(struct scsi_host_template *tpnt, struct
 	if (aha1542->bios_translation == BIOS_TRANSLATION_25563)
 		shost_printk(KERN_INFO, sh, "Using extended bios translation\n");
 
+	if (dma_set_mask_and_coherent(pdev, DMA_BIT_MASK(24)) < 0)
+		goto unregister;
+
+	aha1542->mb = dma_alloc_coherent(pdev,
+			AHA1542_MAILBOXES * 2 * sizeof(struct mailbox),
+			&aha1542->mb_handle, GFP_KERNEL);
+	if (!aha1542->mb)
+		goto unregister;
+
+	aha1542->ccb = dma_alloc_coherent(pdev,
+			AHA1542_MAILBOXES * sizeof(struct ccb),
+			&aha1542->ccb_handle, GFP_KERNEL);
+	if (!aha1542->ccb)
+		goto free_mb;
+
 	setup_mailboxes(sh);
 
 	if (request_irq(sh->irq, aha1542_interrupt, 0, "aha1542", sh)) {
 		shost_printk(KERN_ERR, sh, "Unable to allocate IRQ.\n");
-		goto unregister;
+		goto free_ccb;
 	}
 	if (sh->dma_channel != 0xFF) {
 		if (request_dma(sh->dma_channel, "aha1542")) {
@@ -762,11 +803,18 @@ static struct Scsi_Host *aha1542_hw_init(struct scsi_host_template *tpnt, struct
 	scsi_scan_host(sh);
 
 	return sh;
+
 free_dma:
 	if (sh->dma_channel != 0xff)
 		free_dma(sh->dma_channel);
 free_irq:
 	free_irq(sh->irq, sh);
+free_ccb:
+	dma_free_coherent(pdev, AHA1542_MAILBOXES * sizeof(struct ccb),
+			  aha1542->ccb, aha1542->ccb_handle);
+free_mb:
+	dma_free_coherent(pdev, AHA1542_MAILBOXES * 2 * sizeof(struct mailbox),
+			  aha1542->mb, aha1542->mb_handle);
 unregister:
 	scsi_host_put(sh);
 release:
@@ -777,9 +825,16 @@ static struct Scsi_Host *aha1542_hw_init(struct scsi_host_template *tpnt, struct
 
 static int aha1542_release(struct Scsi_Host *sh)
 {
+	struct aha1542_hostdata *aha1542 = shost_priv(sh);
+	struct device *dev = sh->dma_dev;
+
 	scsi_remove_host(sh);
 	if (sh->dma_channel != 0xff)
 		free_dma(sh->dma_channel);
+	dma_free_coherent(dev, AHA1542_MAILBOXES * sizeof(struct ccb),
+			  aha1542->ccb, aha1542->ccb_handle);
+	dma_free_coherent(dev, AHA1542_MAILBOXES * 2 * sizeof(struct mailbox),
+			  aha1542->mb, aha1542->mb_handle);
 	if (sh->irq)
 		free_irq(sh->irq, sh);
 	if (sh->io_port && sh->n_io_port)
@@ -826,7 +881,8 @@ static int aha1542_dev_reset(struct scsi_cmnd *cmd)
 
 	aha1542->aha1542_last_mbo_used = mbo;
 
-	any2scsi(mb[mbo].ccbptr, isa_virt_to_bus(&ccb[mbo]));	/* This gets trashed for some reason */
+	/* This gets trashed for some reason */
+	any2scsi(mb[mbo].ccbptr, aha1542->ccb_handle + mbo * sizeof(*ccb));
 
 	memset(&ccb[mbo], 0, sizeof(struct ccb));
 
@@ -901,8 +957,7 @@ static int aha1542_reset(struct scsi_cmnd *cmd, u8 reset_cmd)
 				 */
 				continue;
 			}
-			kfree(tmp_cmd->host_scribble);
-			tmp_cmd->host_scribble = NULL;
+			aha1542_free_cmd(tmp_cmd);
 			aha1542->int_cmds[i] = NULL;
 			aha1542->mb[i].status = 0;
 		}
@@ -946,6 +1001,7 @@ static struct scsi_host_template driver_template = {
 	.module			= THIS_MODULE,
 	.proc_name		= "aha1542",
 	.name			= "Adaptec 1542",
+	.cmd_size		= sizeof(struct aha1542_cmd),
 	.queuecommand		= aha1542_queuecommand,
 	.eh_device_reset_handler= aha1542_dev_reset,
 	.eh_bus_reset_handler	= aha1542_bus_reset,

commit 6da2ec56059c3c7a7e5f729e6349e74ace1e5c57
Author: Kees Cook <keescook@chromium.org>
Date:   Tue Jun 12 13:55:00 2018 -0700

    treewide: kmalloc() -> kmalloc_array()
    
    The kmalloc() function has a 2-factor argument form, kmalloc_array(). This
    patch replaces cases of:
    
            kmalloc(a * b, gfp)
    
    with:
            kmalloc_array(a * b, gfp)
    
    as well as handling cases of:
    
            kmalloc(a * b * c, gfp)
    
    with:
    
            kmalloc(array3_size(a, b, c), gfp)
    
    as it's slightly less ugly than:
    
            kmalloc_array(array_size(a, b), c, gfp)
    
    This does, however, attempt to ignore constant size factors like:
    
            kmalloc(4 * 1024, gfp)
    
    though any constants defined via macros get caught up in the conversion.
    
    Any factors with a sizeof() of "unsigned char", "char", and "u8" were
    dropped, since they're redundant.
    
    The tools/ directory was manually excluded, since it has its own
    implementation of kmalloc().
    
    The Coccinelle script used for this was:
    
    // Fix redundant parens around sizeof().
    @@
    type TYPE;
    expression THING, E;
    @@
    
    (
      kmalloc(
    -       (sizeof(TYPE)) * E
    +       sizeof(TYPE) * E
      , ...)
    |
      kmalloc(
    -       (sizeof(THING)) * E
    +       sizeof(THING) * E
      , ...)
    )
    
    // Drop single-byte sizes and redundant parens.
    @@
    expression COUNT;
    typedef u8;
    typedef __u8;
    @@
    
    (
      kmalloc(
    -       sizeof(u8) * (COUNT)
    +       COUNT
      , ...)
    |
      kmalloc(
    -       sizeof(__u8) * (COUNT)
    +       COUNT
      , ...)
    |
      kmalloc(
    -       sizeof(char) * (COUNT)
    +       COUNT
      , ...)
    |
      kmalloc(
    -       sizeof(unsigned char) * (COUNT)
    +       COUNT
      , ...)
    |
      kmalloc(
    -       sizeof(u8) * COUNT
    +       COUNT
      , ...)
    |
      kmalloc(
    -       sizeof(__u8) * COUNT
    +       COUNT
      , ...)
    |
      kmalloc(
    -       sizeof(char) * COUNT
    +       COUNT
      , ...)
    |
      kmalloc(
    -       sizeof(unsigned char) * COUNT
    +       COUNT
      , ...)
    )
    
    // 2-factor product with sizeof(type/expression) and identifier or constant.
    @@
    type TYPE;
    expression THING;
    identifier COUNT_ID;
    constant COUNT_CONST;
    @@
    
    (
    - kmalloc
    + kmalloc_array
      (
    -       sizeof(TYPE) * (COUNT_ID)
    +       COUNT_ID, sizeof(TYPE)
      , ...)
    |
    - kmalloc
    + kmalloc_array
      (
    -       sizeof(TYPE) * COUNT_ID
    +       COUNT_ID, sizeof(TYPE)
      , ...)
    |
    - kmalloc
    + kmalloc_array
      (
    -       sizeof(TYPE) * (COUNT_CONST)
    +       COUNT_CONST, sizeof(TYPE)
      , ...)
    |
    - kmalloc
    + kmalloc_array
      (
    -       sizeof(TYPE) * COUNT_CONST
    +       COUNT_CONST, sizeof(TYPE)
      , ...)
    |
    - kmalloc
    + kmalloc_array
      (
    -       sizeof(THING) * (COUNT_ID)
    +       COUNT_ID, sizeof(THING)
      , ...)
    |
    - kmalloc
    + kmalloc_array
      (
    -       sizeof(THING) * COUNT_ID
    +       COUNT_ID, sizeof(THING)
      , ...)
    |
    - kmalloc
    + kmalloc_array
      (
    -       sizeof(THING) * (COUNT_CONST)
    +       COUNT_CONST, sizeof(THING)
      , ...)
    |
    - kmalloc
    + kmalloc_array
      (
    -       sizeof(THING) * COUNT_CONST
    +       COUNT_CONST, sizeof(THING)
      , ...)
    )
    
    // 2-factor product, only identifiers.
    @@
    identifier SIZE, COUNT;
    @@
    
    - kmalloc
    + kmalloc_array
      (
    -       SIZE * COUNT
    +       COUNT, SIZE
      , ...)
    
    // 3-factor product with 1 sizeof(type) or sizeof(expression), with
    // redundant parens removed.
    @@
    expression THING;
    identifier STRIDE, COUNT;
    type TYPE;
    @@
    
    (
      kmalloc(
    -       sizeof(TYPE) * (COUNT) * (STRIDE)
    +       array3_size(COUNT, STRIDE, sizeof(TYPE))
      , ...)
    |
      kmalloc(
    -       sizeof(TYPE) * (COUNT) * STRIDE
    +       array3_size(COUNT, STRIDE, sizeof(TYPE))
      , ...)
    |
      kmalloc(
    -       sizeof(TYPE) * COUNT * (STRIDE)
    +       array3_size(COUNT, STRIDE, sizeof(TYPE))
      , ...)
    |
      kmalloc(
    -       sizeof(TYPE) * COUNT * STRIDE
    +       array3_size(COUNT, STRIDE, sizeof(TYPE))
      , ...)
    |
      kmalloc(
    -       sizeof(THING) * (COUNT) * (STRIDE)
    +       array3_size(COUNT, STRIDE, sizeof(THING))
      , ...)
    |
      kmalloc(
    -       sizeof(THING) * (COUNT) * STRIDE
    +       array3_size(COUNT, STRIDE, sizeof(THING))
      , ...)
    |
      kmalloc(
    -       sizeof(THING) * COUNT * (STRIDE)
    +       array3_size(COUNT, STRIDE, sizeof(THING))
      , ...)
    |
      kmalloc(
    -       sizeof(THING) * COUNT * STRIDE
    +       array3_size(COUNT, STRIDE, sizeof(THING))
      , ...)
    )
    
    // 3-factor product with 2 sizeof(variable), with redundant parens removed.
    @@
    expression THING1, THING2;
    identifier COUNT;
    type TYPE1, TYPE2;
    @@
    
    (
      kmalloc(
    -       sizeof(TYPE1) * sizeof(TYPE2) * COUNT
    +       array3_size(COUNT, sizeof(TYPE1), sizeof(TYPE2))
      , ...)
    |
      kmalloc(
    -       sizeof(TYPE1) * sizeof(THING2) * (COUNT)
    +       array3_size(COUNT, sizeof(TYPE1), sizeof(TYPE2))
      , ...)
    |
      kmalloc(
    -       sizeof(THING1) * sizeof(THING2) * COUNT
    +       array3_size(COUNT, sizeof(THING1), sizeof(THING2))
      , ...)
    |
      kmalloc(
    -       sizeof(THING1) * sizeof(THING2) * (COUNT)
    +       array3_size(COUNT, sizeof(THING1), sizeof(THING2))
      , ...)
    |
      kmalloc(
    -       sizeof(TYPE1) * sizeof(THING2) * COUNT
    +       array3_size(COUNT, sizeof(TYPE1), sizeof(THING2))
      , ...)
    |
      kmalloc(
    -       sizeof(TYPE1) * sizeof(THING2) * (COUNT)
    +       array3_size(COUNT, sizeof(TYPE1), sizeof(THING2))
      , ...)
    )
    
    // 3-factor product, only identifiers, with redundant parens removed.
    @@
    identifier STRIDE, SIZE, COUNT;
    @@
    
    (
      kmalloc(
    -       (COUNT) * STRIDE * SIZE
    +       array3_size(COUNT, STRIDE, SIZE)
      , ...)
    |
      kmalloc(
    -       COUNT * (STRIDE) * SIZE
    +       array3_size(COUNT, STRIDE, SIZE)
      , ...)
    |
      kmalloc(
    -       COUNT * STRIDE * (SIZE)
    +       array3_size(COUNT, STRIDE, SIZE)
      , ...)
    |
      kmalloc(
    -       (COUNT) * (STRIDE) * SIZE
    +       array3_size(COUNT, STRIDE, SIZE)
      , ...)
    |
      kmalloc(
    -       COUNT * (STRIDE) * (SIZE)
    +       array3_size(COUNT, STRIDE, SIZE)
      , ...)
    |
      kmalloc(
    -       (COUNT) * STRIDE * (SIZE)
    +       array3_size(COUNT, STRIDE, SIZE)
      , ...)
    |
      kmalloc(
    -       (COUNT) * (STRIDE) * (SIZE)
    +       array3_size(COUNT, STRIDE, SIZE)
      , ...)
    |
      kmalloc(
    -       COUNT * STRIDE * SIZE
    +       array3_size(COUNT, STRIDE, SIZE)
      , ...)
    )
    
    // Any remaining multi-factor products, first at least 3-factor products,
    // when they're not all constants...
    @@
    expression E1, E2, E3;
    constant C1, C2, C3;
    @@
    
    (
      kmalloc(C1 * C2 * C3, ...)
    |
      kmalloc(
    -       (E1) * E2 * E3
    +       array3_size(E1, E2, E3)
      , ...)
    |
      kmalloc(
    -       (E1) * (E2) * E3
    +       array3_size(E1, E2, E3)
      , ...)
    |
      kmalloc(
    -       (E1) * (E2) * (E3)
    +       array3_size(E1, E2, E3)
      , ...)
    |
      kmalloc(
    -       E1 * E2 * E3
    +       array3_size(E1, E2, E3)
      , ...)
    )
    
    // And then all remaining 2 factors products when they're not all constants,
    // keeping sizeof() as the second factor argument.
    @@
    expression THING, E1, E2;
    type TYPE;
    constant C1, C2, C3;
    @@
    
    (
      kmalloc(sizeof(THING) * C2, ...)
    |
      kmalloc(sizeof(TYPE) * C2, ...)
    |
      kmalloc(C1 * C2 * C3, ...)
    |
      kmalloc(C1 * C2, ...)
    |
    - kmalloc
    + kmalloc_array
      (
    -       sizeof(TYPE) * (E2)
    +       E2, sizeof(TYPE)
      , ...)
    |
    - kmalloc
    + kmalloc_array
      (
    -       sizeof(TYPE) * E2
    +       E2, sizeof(TYPE)
      , ...)
    |
    - kmalloc
    + kmalloc_array
      (
    -       sizeof(THING) * (E2)
    +       E2, sizeof(THING)
      , ...)
    |
    - kmalloc
    + kmalloc_array
      (
    -       sizeof(THING) * E2
    +       E2, sizeof(THING)
      , ...)
    |
    - kmalloc
    + kmalloc_array
      (
    -       (E1) * E2
    +       E1, E2
      , ...)
    |
    - kmalloc
    + kmalloc_array
      (
    -       (E1) * (E2)
    +       E1, E2
      , ...)
    |
    - kmalloc
    + kmalloc_array
      (
    -       E1 * E2
    +       E1, E2
      , ...)
    )
    
    Signed-off-by: Kees Cook <keescook@chromium.org>

diff --git a/drivers/scsi/aha1542.c b/drivers/scsi/aha1542.c
index 124217927c4a..41add33e3f1f 100644
--- a/drivers/scsi/aha1542.c
+++ b/drivers/scsi/aha1542.c
@@ -400,7 +400,8 @@ static int aha1542_queuecommand(struct Scsi_Host *sh, struct scsi_cmnd *cmd)
 #endif
 	if (bufflen) {	/* allocate memory before taking host_lock */
 		sg_count = scsi_sg_count(cmd);
-		cptr = kmalloc(sizeof(*cptr) * sg_count, GFP_KERNEL | GFP_DMA);
+		cptr = kmalloc_array(sg_count, sizeof(*cptr),
+				     GFP_KERNEL | GFP_DMA);
 		if (!cptr)
 			return SCSI_MLQUEUE_HOST_BUSY;
 	} else {

commit 78453a31d5136cfd8722c111935f6800fa0db0b4
Author: Arvind Yadav <arvind.yadav.cs@gmail.com>
Date:   Wed Aug 16 10:29:24 2017 +0530

    scsi: aha1542: constify pnp_device_id
    
    pnp_device_id are not supposed to change at runtime. All functions
    working with pnp_device_id provided by <linux/pnp.h> work with const
    pnp_device_id. So mark the non-const structs as const.
    
    Signed-off-by: Arvind Yadav <arvind.yadav.cs@gmail.com>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/aha1542.c b/drivers/scsi/aha1542.c
index a23cc9ac5acd..124217927c4a 100644
--- a/drivers/scsi/aha1542.c
+++ b/drivers/scsi/aha1542.c
@@ -986,7 +986,7 @@ static struct isa_driver aha1542_isa_driver = {
 static int isa_registered;
 
 #ifdef CONFIG_PNP
-static struct pnp_device_id aha1542_pnp_ids[] = {
+static const struct pnp_device_id aha1542_pnp_ids[] = {
 	{ .id = "ADP1542" },
 	{ .id = "" }
 };

commit 88f06b76e462119cb694c3ff13d7d343c49d2569
Author: David Howells <dhowells@redhat.com>
Date:   Tue Apr 4 16:54:27 2017 +0100

    Annotate hardware config module parameters in drivers/scsi/
    
    When the kernel is running in secure boot mode, we lock down the kernel to
    prevent userspace from modifying the running kernel image.  Whilst this
    includes prohibiting access to things like /dev/mem, it must also prevent
    access by means of configuring driver modules in such a way as to cause a
    device to access or modify the kernel image.
    
    To this end, annotate module_param* statements that refer to hardware
    configuration and indicate for future reference what type of parameter they
    specify.  The parameter parser in the core sees this information and can
    skip such parameters with an error message if the kernel is locked down.
    The module initialisation then runs as normal, but just sees whatever the
    default values for those parameters is.
    
    Note that we do still need to do the module initialisation because some
    drivers have viable defaults set in case parameters aren't specified and
    some drivers support automatic configuration (e.g. PNP or PCI) in addition
    to manually coded parameters.
    
    This patch annotates drivers in drivers/scsi/.
    
    Suggested-by: Alan Cox <gnomes@lxorguk.ukuu.org.uk>
    Signed-off-by: David Howells <dhowells@redhat.com>
    cc: "Juergen E. Fischer" <fischer@norbit.de>
    cc: "James E.J. Bottomley" <jejb@linux.vnet.ibm.com>
    cc: "Martin K. Petersen" <martin.petersen@oracle.com>
    cc: Dario Ballabio <ballabio_dario@emc.com>
    cc: Finn Thain <fthain@telegraphics.com.au>
    cc: Michael Schmitz <schmitzmic@gmail.com>
    cc: Achim Leubner <achim_leubner@adaptec.com>
    cc: linux-scsi@vger.kernel.org

diff --git a/drivers/scsi/aha1542.c b/drivers/scsi/aha1542.c
index 7db448ec8beb..a23cc9ac5acd 100644
--- a/drivers/scsi/aha1542.c
+++ b/drivers/scsi/aha1542.c
@@ -31,7 +31,7 @@ module_param(isapnp, bool, 0);
 MODULE_PARM_DESC(isapnp, "enable PnP support (default=1)");
 
 static int io[MAXBOARDS] = { 0x330, 0x334, 0, 0 };
-module_param_array(io, int, NULL, 0);
+module_param_hw_array(io, int, ioport, NULL, 0);
 MODULE_PARM_DESC(io, "base IO address of controller (0x130,0x134,0x230,0x234,0x330,0x334, default=0x330,0x334)");
 
 /* time AHA spends on the AT-bus during data transfer */

commit ec54adfb2422855e3e69592ca95cd28dca9a3f01
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Wed Jan 27 16:57:22 2016 +0100

    scsi: aha1542: avoid uninitialized variable warnings
    
    Gcc incorrectly detects that two variables in aha1542_queuecommand might
    be used without an initialization:
    
    scsi/aha1542.c: In function 'aha1542_queuecommand':
    scsi/aha1542.c:382:16: error: 'cptr' may be used uninitialized in this function [-Werror=maybe-uninitialized]
    scsi/aha1542.c:379:11: error: 'sg_count' may be used uninitialized in this function [-Werror=maybe-uninitialized]
    
    The only user of these is doing the same check that the assigment has,
    so it is actually guaranteed to work. Adding an "else" clause with a
    fake initialization shuts up the warning.
    
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/aha1542.c b/drivers/scsi/aha1542.c
index 5b8b2937a3fe..7db448ec8beb 100644
--- a/drivers/scsi/aha1542.c
+++ b/drivers/scsi/aha1542.c
@@ -403,6 +403,9 @@ static int aha1542_queuecommand(struct Scsi_Host *sh, struct scsi_cmnd *cmd)
 		cptr = kmalloc(sizeof(*cptr) * sg_count, GFP_KERNEL | GFP_DMA);
 		if (!cptr)
 			return SCSI_MLQUEUE_HOST_BUSY;
+	} else {
+		sg_count = 0;
+		cptr = NULL;
 	}
 
 	/* Use the outgoing mailboxes in a round-robin fashion, because this

commit b84b1d522f979fb53ad347605e24b2940fa2ad99
Author: Hannes Reinecke <hare@suse.de>
Date:   Wed Apr 29 08:57:34 2015 +0200

    scsi: Do not set cmd_per_lun to 1 in the host template
    
    '0' is now used as the default cmd_per_lun value,
    so there's no need to explicitly set it to '1' in the
    host template.
    
    Signed-off-by: Hannes Reinecke <hare@suse.de>
    Reviewed-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: James Bottomley <JBottomley@Odin.com>

diff --git a/drivers/scsi/aha1542.c b/drivers/scsi/aha1542.c
index b95d2779f467..5b8b2937a3fe 100644
--- a/drivers/scsi/aha1542.c
+++ b/drivers/scsi/aha1542.c
@@ -950,7 +950,6 @@ static struct scsi_host_template driver_template = {
 	.can_queue		= AHA1542_MAILBOXES, 
 	.this_id		= 7,
 	.sg_tablesize		= 16,
-	.cmd_per_lun		= 1,
 	.unchecked_isa_dma	= 1, 
 	.use_clustering		= ENABLE_CLUSTERING,
 };

commit 8c08a6215a432a8f3629da0e8ccfd534ffa480f5
Author: Ondrej Zary <linux@rainbow-software.org>
Date:   Tue Apr 21 23:27:50 2015 +0200

    aha1542: Allocate memory before taking a lock
    
    The driver currently calls kmalloc with GFP_KERNEL while holding a lock.
    Fix it by doing the allocation earlier, before taking the lock.
    
    Tested on AHA-1542B.
    
    Signed-off-by: Ondrej Zary <linux@rainbow-software.org>
    Signed-off-by: James Bottomley <JBottomley@Odin.com>

diff --git a/drivers/scsi/aha1542.c b/drivers/scsi/aha1542.c
index ec432763a29a..b95d2779f467 100644
--- a/drivers/scsi/aha1542.c
+++ b/drivers/scsi/aha1542.c
@@ -375,9 +375,10 @@ static int aha1542_queuecommand(struct Scsi_Host *sh, struct scsi_cmnd *cmd)
 	u8 lun = cmd->device->lun;
 	unsigned long flags;
 	int bufflen = scsi_bufflen(cmd);
-	int mbo;
+	int mbo, sg_count;
 	struct mailbox *mb = aha1542->mb;
 	struct ccb *ccb = aha1542->ccb;
+	struct chain *cptr;
 
 	if (*cmd->cmnd == REQUEST_SENSE) {
 		/* Don't do the command - we have the sense data already */
@@ -397,6 +398,13 @@ static int aha1542_queuecommand(struct Scsi_Host *sh, struct scsi_cmnd *cmd)
 		print_hex_dump_bytes("command: ", DUMP_PREFIX_NONE, cmd->cmnd, cmd->cmd_len);
 	}
 #endif
+	if (bufflen) {	/* allocate memory before taking host_lock */
+		sg_count = scsi_sg_count(cmd);
+		cptr = kmalloc(sizeof(*cptr) * sg_count, GFP_KERNEL | GFP_DMA);
+		if (!cptr)
+			return SCSI_MLQUEUE_HOST_BUSY;
+	}
+
 	/* Use the outgoing mailboxes in a round-robin fashion, because this
 	   is how the host adapter will scan for them */
 
@@ -441,19 +449,10 @@ static int aha1542_queuecommand(struct Scsi_Host *sh, struct scsi_cmnd *cmd)
 
 	if (bufflen) {
 		struct scatterlist *sg;
-		struct chain *cptr;
-		int i, sg_count = scsi_sg_count(cmd);
+		int i;
 
 		ccb[mbo].op = 2;	/* SCSI Initiator Command  w/scatter-gather */
-		cmd->host_scribble = kmalloc(sizeof(*cptr)*sg_count,
-		                                         GFP_KERNEL | GFP_DMA);
-		cptr = (struct chain *) cmd->host_scribble;
-		if (cptr == NULL) {
-			/* free the claimed mailbox slot */
-			aha1542->int_cmds[mbo] = NULL;
-			spin_unlock_irqrestore(sh->host_lock, flags);
-			return SCSI_MLQUEUE_HOST_BUSY;
-		}
+		cmd->host_scribble = (void *)cptr;
 		scsi_for_each_sg(cmd, sg, sg_count, i) {
 			any2scsi(cptr[i].dataptr, isa_page_to_bus(sg_page(sg))
 								+ sg->offset);

commit eef77801b56b098cd7e1daf8a03854dd203a051c
Author: Ondrej Zary <linux@rainbow-software.org>
Date:   Fri Feb 6 23:11:57 2015 +0100

    aha1542: remove loop from aha1542_outb
    
    The loop in aha1542_outb with double-check is no longer needed, remove it.
    
    Signed-off-by: Ondrej Zary <linux@rainbow-software.org>
    Reviewed-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: James Bottomley <JBottomley@Odin.com>

diff --git a/drivers/scsi/aha1542.c b/drivers/scsi/aha1542.c
index af821f340a85..ec432763a29a 100644
--- a/drivers/scsi/aha1542.c
+++ b/drivers/scsi/aha1542.c
@@ -91,14 +91,11 @@ static inline bool wait_mask(u16 port, u8 mask, u8 allof, u8 noneof, int timeout
 
 static int aha1542_outb(unsigned int base, u8 val)
 {
-	while (1) {
-		if (!wait_mask(STATUS(base), CDF, 0, CDF, 0))
-			return 1;
-		if (inb(STATUS(base)) & CDF)
-			continue;
-		outb(val, DATA(base));
-		return 0;
-	}
+	if (!wait_mask(STATUS(base), CDF, 0, CDF, 0))
+		return 1;
+	outb(val, DATA(base));
+
+	return 0;
 }
 
 static int aha1542_out(unsigned int base, u8 *buf, int len)

commit 7061dec40c07265f819ae0a6842846f74f889aa9
Author: Ondrej Zary <linux@rainbow-software.org>
Date:   Fri Feb 6 23:11:56 2015 +0100

    aha1542: Fix bus reset
    
    Bus reset always fails because aha1542_reset waits for the controller to assert
    the INIT bit (Mailbox Initialization Required) which it never does. This bit is
    asserted only after host reset.
    
    Remove the requirement for INIT bit (we really need only the IDLE bit).
    
    Signed-off-by: Ondrej Zary <linux@rainbow-software.org>
    Reviewed-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: James Bottomley <JBottomley@Odin.com>

diff --git a/drivers/scsi/aha1542.c b/drivers/scsi/aha1542.c
index 7b5d396deaa5..af821f340a85 100644
--- a/drivers/scsi/aha1542.c
+++ b/drivers/scsi/aha1542.c
@@ -867,7 +867,7 @@ static int aha1542_reset(struct scsi_cmnd *cmd, u8 reset_cmd)
 	outb(reset_cmd, CONTROL(cmd->device->host->io_port));
 
 	if (!wait_mask(STATUS(cmd->device->host->io_port),
-	     STATMASK, INIT | IDLE, STST | DIAGF | INVDCMD | DF | CDF, 0)) {
+	     STATMASK, IDLE, STST | DIAGF | INVDCMD | DF | CDF, 0)) {
 		spin_unlock_irqrestore(sh->host_lock, flags);
 		return FAILED;
 	}

commit 1b0224b0ec6003c06cc369188510642a5fb3b864
Author: Ondrej Zary <linux@rainbow-software.org>
Date:   Fri Feb 6 23:11:55 2015 +0100

    aha1542: rework locking
    
    Remove aha1542_lock and use host_lock instead.
    Remove interrupt and queuecommand function wrappers.
    Remove locking from lowlevel _out and _in functions, they now can
    onle be called (at runtime) with host_lock being held.
    Remove ssleep(4) in aha1542_reset as we can't sleep while holding a spinlock.
    It's useless anyway as wait_mask will wait until the controller is idle and
    kernel waits for 10 seconds (HOST_RESET_SETTLE_TIME) after that.
    
    Signed-off-by: Ondrej Zary <linux@rainbow-software.org>
    Reviewed-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: James Bottomley <JBottomley@Odin.com>

diff --git a/drivers/scsi/aha1542.c b/drivers/scsi/aha1542.c
index a19fcb02ff20..7b5d396deaa5 100644
--- a/drivers/scsi/aha1542.c
+++ b/drivers/scsi/aha1542.c
@@ -62,8 +62,6 @@ struct aha1542_hostdata {
 	struct ccb ccb[AHA1542_MAILBOXES];
 };
 
-static DEFINE_SPINLOCK(aha1542_lock);
-
 static inline void aha1542_intr_reset(u16 base)
 {
 	outb(IRST, CONTROL(base));
@@ -91,41 +89,25 @@ static inline bool wait_mask(u16 port, u8 mask, u8 allof, u8 noneof, int timeout
 	return true;
 }
 
-/* This is a bit complicated, but we need to make sure that an interrupt
-   routine does not send something out while we are in the middle of this.
-   Fortunately, it is only at boot time that multi-byte messages
-   are ever sent. */
 static int aha1542_outb(unsigned int base, u8 val)
 {
-	unsigned long flags;
-
 	while (1) {
 		if (!wait_mask(STATUS(base), CDF, 0, CDF, 0))
 			return 1;
-		spin_lock_irqsave(&aha1542_lock, flags);
-		if (inb(STATUS(base)) & CDF) {
-			spin_unlock_irqrestore(&aha1542_lock, flags);
+		if (inb(STATUS(base)) & CDF)
 			continue;
-		}
 		outb(val, DATA(base));
-		spin_unlock_irqrestore(&aha1542_lock, flags);
 		return 0;
 	}
 }
 
 static int aha1542_out(unsigned int base, u8 *buf, int len)
 {
-	unsigned long flags;
-
-	spin_lock_irqsave(&aha1542_lock, flags);
 	while (len--) {
-		if (!wait_mask(STATUS(base), CDF, 0, CDF, 0)) {
-			spin_unlock_irqrestore(&aha1542_lock, flags);
+		if (!wait_mask(STATUS(base), CDF, 0, CDF, 0))
 			return 1;
-		}
 		outb(*buf++, DATA(base));
 	}
-	spin_unlock_irqrestore(&aha1542_lock, flags);
 	if (!wait_mask(INTRFLAGS(base), INTRMASK, HACC, 0, 0))
 		return 1;
 
@@ -137,17 +119,11 @@ static int aha1542_out(unsigned int base, u8 *buf, int len)
 
 static int aha1542_in(unsigned int base, u8 *buf, int len, int timeout)
 {
-	unsigned long flags;
-
-	spin_lock_irqsave(&aha1542_lock, flags);
 	while (len--) {
-		if (!wait_mask(STATUS(base), DF, DF, 0, timeout)) {
-			spin_unlock_irqrestore(&aha1542_lock, flags);
+		if (!wait_mask(STATUS(base), DF, DF, 0, timeout))
 			return 1;
-		}
 		*buf++ = inb(DATA(base));
 	}
-	spin_unlock_irqrestore(&aha1542_lock, flags);
 	return 0;
 }
 
@@ -260,9 +236,9 @@ static int aha1542_test_port(struct Scsi_Host *sh)
 	return 1;
 }
 
-/* A "high" level interrupt handler */
-static void aha1542_intr_handle(struct Scsi_Host *sh)
+static irqreturn_t aha1542_interrupt(int irq, void *dev_id)
 {
+	struct Scsi_Host *sh = dev_id;
 	struct aha1542_hostdata *aha1542 = shost_priv(sh);
 	void (*my_done)(struct scsi_cmnd *) = NULL;
 	int errstatus, mbi, mbo, mbistatus;
@@ -292,7 +268,8 @@ static void aha1542_intr_handle(struct Scsi_Host *sh)
 #endif
 	number_serviced = 0;
 
-	while (1 == 1) {
+	spin_lock_irqsave(sh->host_lock, flags);
+	while (1) {
 		flag = inb(INTRFLAGS(sh->io_port));
 
 		/* Check for unusual interrupts.  If any of these happen, we should
@@ -309,7 +286,6 @@ static void aha1542_intr_handle(struct Scsi_Host *sh)
 		}
 		aha1542_intr_reset(sh->io_port);
 
-		spin_lock_irqsave(&aha1542_lock, flags);
 		mbi = aha1542->aha1542_last_mbi_used + 1;
 		if (mbi >= 2 * AHA1542_MAILBOXES)
 			mbi = AHA1542_MAILBOXES;
@@ -323,18 +299,17 @@ static void aha1542_intr_handle(struct Scsi_Host *sh)
 		} while (mbi != aha1542->aha1542_last_mbi_used);
 
 		if (mb[mbi].status == 0) {
-			spin_unlock_irqrestore(&aha1542_lock, flags);
+			spin_unlock_irqrestore(sh->host_lock, flags);
 			/* Hmm, no mail.  Must have read it the last time around */
 			if (!number_serviced)
 				shost_printk(KERN_WARNING, sh, "interrupt received, but no mail.\n");
-			return;
+			return IRQ_HANDLED;
 		};
 
 		mbo = (scsi2int(mb[mbi].ccbptr) - (isa_virt_to_bus(&ccb[0]))) / sizeof(struct ccb);
 		mbistatus = mb[mbi].status;
 		mb[mbi].status = 0;
 		aha1542->aha1542_last_mbi_used = mbi;
-		spin_unlock_irqrestore(&aha1542_lock, flags);
 
 #ifdef DEBUG
 		if (ccb[mbo].tarstat | ccb[mbo].hastat)
@@ -352,10 +327,11 @@ static void aha1542_intr_handle(struct Scsi_Host *sh)
 		tmp_cmd = aha1542->int_cmds[mbo];
 
 		if (!tmp_cmd || !tmp_cmd->scsi_done) {
+			spin_unlock_irqrestore(sh->host_lock, flags);
 			shost_printk(KERN_WARNING, sh, "Unexpected interrupt\n");
 			shost_printk(KERN_WARNING, sh, "tarstat=%x, hastat=%x idlun=%x ccb#=%d\n", ccb[mbo].tarstat,
 			       ccb[mbo].hastat, ccb[mbo].idlun, mbo);
-			return;
+			return IRQ_HANDLED;
 		}
 		my_done = tmp_cmd->scsi_done;
 		kfree(tmp_cmd->host_scribble);
@@ -394,21 +370,8 @@ static void aha1542_intr_handle(struct Scsi_Host *sh)
 	};
 }
 
-/* A quick wrapper for do_aha1542_intr_handle to grab the spin lock */
-static irqreturn_t do_aha1542_intr_handle(int dummy, void *dev_id)
+static int aha1542_queuecommand(struct Scsi_Host *sh, struct scsi_cmnd *cmd)
 {
-	unsigned long flags;
-	struct Scsi_Host *sh = dev_id;
-
-	spin_lock_irqsave(sh->host_lock, flags);
-	aha1542_intr_handle(sh);
-	spin_unlock_irqrestore(sh->host_lock, flags);
-	return IRQ_HANDLED;
-}
-
-static int aha1542_queuecommand_lck(struct scsi_cmnd *cmd, void (*done) (struct scsi_cmnd *))
-{
-	struct Scsi_Host *sh = cmd->device->host;
 	struct aha1542_hostdata *aha1542 = shost_priv(sh);
 	u8 direction;
 	u8 target = cmd->device->id;
@@ -422,7 +385,7 @@ static int aha1542_queuecommand_lck(struct scsi_cmnd *cmd, void (*done) (struct
 	if (*cmd->cmnd == REQUEST_SENSE) {
 		/* Don't do the command - we have the sense data already */
 		cmd->result = 0;
-		done(cmd);
+		cmd->scsi_done(cmd);
 		return 0;
 	}
 #ifdef DEBUG
@@ -440,7 +403,7 @@ static int aha1542_queuecommand_lck(struct scsi_cmnd *cmd, void (*done) (struct
 	/* Use the outgoing mailboxes in a round-robin fashion, because this
 	   is how the host adapter will scan for them */
 
-	spin_lock_irqsave(&aha1542_lock, flags);
+	spin_lock_irqsave(sh->host_lock, flags);
 	mbo = aha1542->aha1542_last_mbo_used + 1;
 	if (mbo >= AHA1542_MAILBOXES)
 		mbo = 0;
@@ -460,10 +423,9 @@ static int aha1542_queuecommand_lck(struct scsi_cmnd *cmd, void (*done) (struct
 					   screwing with this cdb. */
 
 	aha1542->aha1542_last_mbo_used = mbo;
-	spin_unlock_irqrestore(&aha1542_lock, flags);
 
 #ifdef DEBUG
-	shost_printk(KERN_DEBUG, sh, "Sending command (%d %p)...", mbo, done);
+	shost_printk(KERN_DEBUG, sh, "Sending command (%d %p)...", mbo, cmd->scsi_done);
 #endif
 
 	any2scsi(mb[mbo].ccbptr, isa_virt_to_bus(&ccb[mbo]));	/* This gets trashed for some reason */
@@ -492,6 +454,7 @@ static int aha1542_queuecommand_lck(struct scsi_cmnd *cmd, void (*done) (struct
 		if (cptr == NULL) {
 			/* free the claimed mailbox slot */
 			aha1542->int_cmds[mbo] = NULL;
+			spin_unlock_irqrestore(sh->host_lock, flags);
 			return SCSI_MLQUEUE_HOST_BUSY;
 		}
 		scsi_for_each_sg(cmd, sg, sg_count, i) {
@@ -518,23 +481,15 @@ static int aha1542_queuecommand_lck(struct scsi_cmnd *cmd, void (*done) (struct
 
 #ifdef DEBUG
 	print_hex_dump_bytes("sending: ", DUMP_PREFIX_NONE, &ccb[mbo], sizeof(ccb[mbo]) - 10);
+	printk("aha1542_queuecommand: now waiting for interrupt ");
 #endif
-
-	if (done) {
-#ifdef DEBUG
-		printk("aha1542_queuecommand: now waiting for interrupt ");
-#endif
-		cmd->scsi_done = done;
-		mb[mbo].status = 1;
-		aha1542_outb(cmd->device->host->io_port, CMD_START_SCSI);
-	} else
-		printk("aha1542_queuecommand: done can't be NULL\n");
+	mb[mbo].status = 1;
+	aha1542_outb(cmd->device->host->io_port, CMD_START_SCSI);
+	spin_unlock_irqrestore(sh->host_lock, flags);
 
 	return 0;
 }
 
-static DEF_SCSI_QCMD(aha1542_queuecommand)
-
 /* Initialize mailboxes */
 static void setup_mailboxes(struct Scsi_Host *sh)
 {
@@ -786,8 +741,7 @@ static struct Scsi_Host *aha1542_hw_init(struct scsi_host_template *tpnt, struct
 
 	setup_mailboxes(sh);
 
-	if (request_irq(sh->irq, do_aha1542_intr_handle, 0,
-					"aha1542", sh)) {
+	if (request_irq(sh->irq, aha1542_interrupt, 0, "aha1542", sh)) {
 		shost_printk(KERN_ERR, sh, "Unable to allocate IRQ.\n");
 		goto unregister;
 	}
@@ -841,7 +795,8 @@ static int aha1542_release(struct Scsi_Host *sh)
  */
 static int aha1542_dev_reset(struct scsi_cmnd *cmd)
 {
-	struct aha1542_hostdata *aha1542 = shost_priv(cmd->device->host);
+	struct Scsi_Host *sh = cmd->device->host;
+	struct aha1542_hostdata *aha1542 = shost_priv(sh);
 	unsigned long flags;
 	struct mailbox *mb = aha1542->mb;
 	u8 target = cmd->device->id;
@@ -849,7 +804,7 @@ static int aha1542_dev_reset(struct scsi_cmnd *cmd)
 	int mbo;
 	struct ccb *ccb = aha1542->ccb;
 
-	spin_lock_irqsave(&aha1542_lock, flags);
+	spin_lock_irqsave(sh->host_lock, flags);
 	mbo = aha1542->aha1542_last_mbo_used + 1;
 	if (mbo >= AHA1542_MAILBOXES)
 		mbo = 0;
@@ -870,7 +825,6 @@ static int aha1542_dev_reset(struct scsi_cmnd *cmd)
 					   screwing with this cdb. */
 
 	aha1542->aha1542_last_mbo_used = mbo;
-	spin_unlock_irqrestore(&aha1542_lock, flags);
 
 	any2scsi(mb[mbo].ccbptr, isa_virt_to_bus(&ccb[mbo]));	/* This gets trashed for some reason */
 
@@ -887,7 +841,8 @@ static int aha1542_dev_reset(struct scsi_cmnd *cmd)
 	 * Now tell the 1542 to flush all pending commands for this 
 	 * target 
 	 */
-	aha1542_outb(cmd->device->host->io_port, CMD_START_SCSI);
+	aha1542_outb(sh->io_port, CMD_START_SCSI);
+	spin_unlock_irqrestore(sh->host_lock, flags);
 
 	scmd_printk(KERN_WARNING, cmd,
 		"Trying device reset for target\n");
@@ -897,9 +852,12 @@ static int aha1542_dev_reset(struct scsi_cmnd *cmd)
 
 static int aha1542_reset(struct scsi_cmnd *cmd, u8 reset_cmd)
 {
-	struct aha1542_hostdata *aha1542 = shost_priv(cmd->device->host);
+	struct Scsi_Host *sh = cmd->device->host;
+	struct aha1542_hostdata *aha1542 = shost_priv(sh);
+	unsigned long flags;
 	int i;
 
+	spin_lock_irqsave(sh->host_lock, flags);
 	/* 
 	 * This does a scsi reset for all devices on the bus.
 	 * In principle, we could also reset the 1542 - should
@@ -908,27 +866,19 @@ static int aha1542_reset(struct scsi_cmnd *cmd, u8 reset_cmd)
 	 */
 	outb(reset_cmd, CONTROL(cmd->device->host->io_port));
 
-	/*
-	 * Wait for the thing to settle down a bit.  Unfortunately
-	 * this is going to basically lock up the machine while we
-	 * wait for this to complete.  To be 100% correct, we need to
-	 * check for timeout, and if we are doing something like this
-	 * we are pretty desperate anyways.
-	 */
-	ssleep(4);
-	spin_lock_irq(cmd->device->host->host_lock);
-
 	if (!wait_mask(STATUS(cmd->device->host->io_port),
 	     STATMASK, INIT | IDLE, STST | DIAGF | INVDCMD | DF | CDF, 0)) {
-		spin_unlock_irq(cmd->device->host->host_lock);
+		spin_unlock_irqrestore(sh->host_lock, flags);
 		return FAILED;
 	}
+
 	/*
 	 * We need to do this too before the 1542 can interact with
 	 * us again after host reset.
 	 */
 	if (reset_cmd & HRST)
 		setup_mailboxes(cmd->device->host);
+
 	/*
 	 * Now try to pick up the pieces.  For all pending commands,
 	 * free any internal data structures, and basically clear things
@@ -958,7 +908,7 @@ static int aha1542_reset(struct scsi_cmnd *cmd, u8 reset_cmd)
 		}
 	}
 
-	spin_unlock_irq(cmd->device->host->host_lock);
+	spin_unlock_irqrestore(sh->host_lock, flags);
 	return SUCCESS;
 }
 

commit 764a0c7e840085828afbc16fb9b47be5712f5531
Author: Ondrej Zary <linux@rainbow-software.org>
Date:   Fri Feb 6 23:11:54 2015 +0100

    aha1542: Don't reduce functionality with DEBUG enabled
    
    Enabling DEBUG disables write commands and devices with ID > 1.
    Remove this "feature" to allow real debugging.
    
    Signed-off-by: Ondrej Zary <linux@rainbow-software.org>
    Reviewed-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: James Bottomley <JBottomley@Odin.com>

diff --git a/drivers/scsi/aha1542.c b/drivers/scsi/aha1542.c
index 87017fbdbc84..a19fcb02ff20 100644
--- a/drivers/scsi/aha1542.c
+++ b/drivers/scsi/aha1542.c
@@ -418,15 +418,7 @@ static int aha1542_queuecommand_lck(struct scsi_cmnd *cmd, void (*done) (struct
 	int mbo;
 	struct mailbox *mb = aha1542->mb;
 	struct ccb *ccb = aha1542->ccb;
-#ifdef DEBUG
-	int i;
 
-	if (target > 1) {
-		cmd->result = DID_TIME_OUT << 16;
-		done(cmd);
-		return 0;
-	}
-#endif
 	if (*cmd->cmnd == REQUEST_SENSE) {
 		/* Don't do the command - we have the sense data already */
 		cmd->result = 0;
@@ -434,19 +426,16 @@ static int aha1542_queuecommand_lck(struct scsi_cmnd *cmd, void (*done) (struct
 		return 0;
 	}
 #ifdef DEBUG
-	if (*cmd->cmnd == READ_10 || *cmd->cmnd == WRITE_10)
-		i = xscsi2int(cmd->cmnd + 2);
-	else if (*cmd->cmnd == READ_6 || *cmd->cmnd == WRITE_6)
-		i = scsi2int(cmd->cmnd + 2);
-	else
-		i = -1;
-	if (done)
-		shost_printk(KERN_DEBUG, sh, "aha1542_queuecommand: dev %d cmd %02x pos %d len %d ", target, *cmd->cmnd, i, bufflen);
-	else
-		shost_printk(KERN_DEBUG, sh, "aha1542_command: dev %d cmd %02x pos %d len %d ", target, *cmd->cmnd, i, bufflen);
-	print_hex_dump_bytes("command: ", DUMP_PREFIX_NONE, cmd->cmnd, cmd->cmd_len);
-	if (*cmd->cmnd == WRITE_10 || *cmd->cmnd == WRITE_6)
-		return 0;	/* we are still testing, so *don't* write */
+	{
+		int i = -1;
+		if (*cmd->cmnd == READ_10 || *cmd->cmnd == WRITE_10)
+			i = xscsi2int(cmd->cmnd + 2);
+		else if (*cmd->cmnd == READ_6 || *cmd->cmnd == WRITE_6)
+			i = scsi2int(cmd->cmnd + 2);
+		shost_printk(KERN_DEBUG, sh, "aha1542_queuecommand: dev %d cmd %02x pos %d len %d",
+						target, *cmd->cmnd, i, bufflen);
+		print_hex_dump_bytes("command: ", DUMP_PREFIX_NONE, cmd->cmnd, cmd->cmd_len);
+	}
 #endif
 	/* Use the outgoing mailboxes in a round-robin fashion, because this
 	   is how the host adapter will scan for them */

commit 6ddc8cf40a2011af0c1a5dd300cc75d727c3c3a8
Author: Ondrej Zary <linux@rainbow-software.org>
Date:   Fri Feb 6 23:11:53 2015 +0100

    aha1542: Use print_hex_dump_bytes in debug code
    
    Signed-off-by: Ondrej Zary <linux@rainbow-software.org>
    Reviewed-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: James Bottomley <JBottomley@Odin.com>

diff --git a/drivers/scsi/aha1542.c b/drivers/scsi/aha1542.c
index 6d4532c5185e..87017fbdbc84 100644
--- a/drivers/scsi/aha1542.c
+++ b/drivers/scsi/aha1542.c
@@ -381,14 +381,8 @@ static void aha1542_intr_handle(struct Scsi_Host *sh)
 		if (errstatus)
 			shost_printk(KERN_DEBUG, sh, "(aha1542 error:%x %x %x) ", errstatus,
 			       ccb[mbo].hastat, ccb[mbo].tarstat);
-		if (ccb[mbo].tarstat == 2) {
-			int i;
-
-			printk("aha1542_intr_handle: sense:");
-			for (i = 0; i < 12; i++)
-				printk("%02x ", ccb[mbo].cdb[ccb[mbo].cdblen + i]);
-			printk("\n");
-		}
+		if (ccb[mbo].tarstat == 2)
+			print_hex_dump_bytes("sense: ", DUMP_PREFIX_NONE, &ccb[mbo].cdb[ccb[mbo].cdblen], 12);
 		if (errstatus)
 			printk("aha1542_intr_handle: returning %6x\n", errstatus);
 #endif
@@ -450,10 +444,7 @@ static int aha1542_queuecommand_lck(struct scsi_cmnd *cmd, void (*done) (struct
 		shost_printk(KERN_DEBUG, sh, "aha1542_queuecommand: dev %d cmd %02x pos %d len %d ", target, *cmd->cmnd, i, bufflen);
 	else
 		shost_printk(KERN_DEBUG, sh, "aha1542_command: dev %d cmd %02x pos %d len %d ", target, *cmd->cmnd, i, bufflen);
-	shost_printk(KERN_DEBUG, sh, "aha1542_queuecommand: dumping scsi cmd:");
-	for (i = 0; i < cmd->cmd_len; i++)
-		printk("%02x ", cmd->cmnd[i]);
-	printk("\n");
+	print_hex_dump_bytes("command: ", DUMP_PREFIX_NONE, cmd->cmnd, cmd->cmd_len);
 	if (*cmd->cmnd == WRITE_10 || *cmd->cmnd == WRITE_6)
 		return 0;	/* we are still testing, so *don't* write */
 #endif
@@ -483,7 +474,7 @@ static int aha1542_queuecommand_lck(struct scsi_cmnd *cmd, void (*done) (struct
 	spin_unlock_irqrestore(&aha1542_lock, flags);
 
 #ifdef DEBUG
-	shost_printk(KERN_DEBUG, sh, "Sending command (%d %x)...", mbo, done);
+	shost_printk(KERN_DEBUG, sh, "Sending command (%d %p)...", mbo, done);
 #endif
 
 	any2scsi(mb[mbo].ccbptr, isa_virt_to_bus(&ccb[mbo]));	/* This gets trashed for some reason */
@@ -503,10 +494,8 @@ static int aha1542_queuecommand_lck(struct scsi_cmnd *cmd, void (*done) (struct
 	if (bufflen) {
 		struct scatterlist *sg;
 		struct chain *cptr;
-#ifdef DEBUG
-		unsigned char *ptr;
-#endif
 		int i, sg_count = scsi_sg_count(cmd);
+
 		ccb[mbo].op = 2;	/* SCSI Initiator Command  w/scatter-gather */
 		cmd->host_scribble = kmalloc(sizeof(*cptr)*sg_count,
 		                                         GFP_KERNEL | GFP_DMA);
@@ -524,10 +513,8 @@ static int aha1542_queuecommand_lck(struct scsi_cmnd *cmd, void (*done) (struct
 		any2scsi(ccb[mbo].datalen, sg_count * sizeof(struct chain));
 		any2scsi(ccb[mbo].dataptr, isa_virt_to_bus(cptr));
 #ifdef DEBUG
-		printk("cptr %x: ", cptr);
-		ptr = (unsigned char *) cptr;
-		for (i = 0; i < 18; i++)
-			printk("%02x ", ptr[i]);
+		shost_printk(KERN_DEBUG, sh, "cptr %p: ", cptr);
+		print_hex_dump_bytes("cptr: ", DUMP_PREFIX_NONE, cptr, 18);
 #endif
 	} else {
 		ccb[mbo].op = 0;	/* SCSI Initiator Command */
@@ -541,12 +528,7 @@ static int aha1542_queuecommand_lck(struct scsi_cmnd *cmd, void (*done) (struct
 	ccb[mbo].commlinkid = 0;
 
 #ifdef DEBUG
-	{
-		int i;
-		shost_printk(KERN_DEBUG, sh, "aha1542_command: sending.. ");
-		for (i = 0; i < sizeof(ccb[mbo]) - 10; i++)
-			printk("%02x ", ((u8 *) &ccb[mbo])[i]);
-	};
+	print_hex_dump_bytes("sending: ", DUMP_PREFIX_NONE, &ccb[mbo], sizeof(ccb[mbo]) - 10);
 #endif
 
 	if (done) {

commit fde1fb8a4a74607c82a47389be9ee3a134c854cb
Author: Ondrej Zary <linux@rainbow-software.org>
Date:   Fri Feb 6 23:11:52 2015 +0100

    aha1542: remove DEB macro and simplify debug code
    
    Remove DEB macro and join ifdef DEBUG blocks
    
    Signed-off-by: Ondrej Zary <linux@rainbow-software.org>
    Reviewed-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: James Bottomley <JBottomley@Odin.com>

diff --git a/drivers/scsi/aha1542.c b/drivers/scsi/aha1542.c
index d607f59f922a..6d4532c5185e 100644
--- a/drivers/scsi/aha1542.c
+++ b/drivers/scsi/aha1542.c
@@ -24,11 +24,6 @@
 #include <scsi/scsi_host.h>
 #include "aha1542.h"
 
-#ifdef DEBUG
-#define DEB(x) x
-#else
-#define DEB(x)
-#endif
 #define MAXBOARDS 4
 
 static bool isapnp = 1;
@@ -195,7 +190,9 @@ static int makecode(unsigned hosterr, unsigned scsierr)
 	case 0x1a:		/* Invalid CCB or Segment List Parameter-A segment list with a zero
 				   length segment or invalid segment list boundaries was received.
 				   A CCB parameter was invalid. */
-		DEB(printk("Aha1542: %x %x\n", hosterr, scsierr));
+#ifdef DEBUG
+		printk("Aha1542: %x %x\n", hosterr, scsierr);
+#endif
 		hosterr = DID_ERROR;	/* Couldn't find any better */
 		break;
 
@@ -340,11 +337,9 @@ static void aha1542_intr_handle(struct Scsi_Host *sh)
 		spin_unlock_irqrestore(&aha1542_lock, flags);
 
 #ifdef DEBUG
-		{
-			if (ccb[mbo].tarstat | ccb[mbo].hastat)
-				shost_printk(KERN_DEBUG, sh, "aha1542_command: returning %x (status %d)\n",
-				       ccb[mbo].tarstat + ((int) ccb[mbo].hastat << 16), mb[mbi].status);
-		};
+		if (ccb[mbo].tarstat | ccb[mbo].hastat)
+			shost_printk(KERN_DEBUG, sh, "aha1542_command: returning %x (status %d)\n",
+			       ccb[mbo].tarstat + ((int) ccb[mbo].hastat << 16), mb[mbi].status);
 #endif
 
 		if (mbistatus == 3)
@@ -386,26 +381,17 @@ static void aha1542_intr_handle(struct Scsi_Host *sh)
 		if (errstatus)
 			shost_printk(KERN_DEBUG, sh, "(aha1542 error:%x %x %x) ", errstatus,
 			       ccb[mbo].hastat, ccb[mbo].tarstat);
-#endif
-
 		if (ccb[mbo].tarstat == 2) {
-#ifdef DEBUG
 			int i;
-#endif
-			DEB(printk("aha1542_intr_handle: sense:"));
-#ifdef DEBUG
+
+			printk("aha1542_intr_handle: sense:");
 			for (i = 0; i < 12; i++)
 				printk("%02x ", ccb[mbo].cdb[ccb[mbo].cdblen + i]);
 			printk("\n");
-#endif
-			/*
-			   DEB(printk("aha1542_intr_handle: buf:"));
-			   for (i = 0; i < bufflen; i++)
-			   printk("%02x ", ((unchar *)buff)[i]);
-			   printk("\n");
-			 */
 		}
-		DEB(if (errstatus) printk("aha1542_intr_handle: returning %6x\n", errstatus));
+		if (errstatus)
+			printk("aha1542_intr_handle: returning %6x\n", errstatus);
+#endif
 		tmp_cmd->result = errstatus;
 		aha1542->int_cmds[mbo] = NULL;	/* This effectively frees up the mailbox slot, as
 						   far as queuecommand is concerned */
@@ -438,15 +424,15 @@ static int aha1542_queuecommand_lck(struct scsi_cmnd *cmd, void (*done) (struct
 	int mbo;
 	struct mailbox *mb = aha1542->mb;
 	struct ccb *ccb = aha1542->ccb;
+#ifdef DEBUG
+	int i;
 
-	DEB(int i);
-
-	DEB(if (target > 1) {
-	    cmd->result = DID_TIME_OUT << 16;
-	    done(cmd); return 0;
-	    }
-	);
-
+	if (target > 1) {
+		cmd->result = DID_TIME_OUT << 16;
+		done(cmd);
+		return 0;
+	}
+#endif
 	if (*cmd->cmnd == REQUEST_SENSE) {
 		/* Don't do the command - we have the sense data already */
 		cmd->result = 0;
@@ -564,7 +550,9 @@ static int aha1542_queuecommand_lck(struct scsi_cmnd *cmd, void (*done) (struct
 #endif
 
 	if (done) {
-		DEB(printk("aha1542_queuecommand: now waiting for interrupt "));
+#ifdef DEBUG
+		printk("aha1542_queuecommand: now waiting for interrupt ");
+#endif
 		cmd->scsi_done = done;
 		mb[mbo].status = 1;
 		aha1542_outb(cmd->device->host->io_port, CMD_START_SCSI);

commit 2906b3ceb1bfc4a1abd59dd7a5f09268b8d585a6
Author: Ondrej Zary <linux@rainbow-software.org>
Date:   Fri Feb 6 23:11:51 2015 +0100

    aha1542: Use shost_printk instead of printk
    
    Signed-off-by: Ondrej Zary <linux@rainbow-software.org>
    Reviewed-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: James Bottomley <JBottomley@Odin.com>

diff --git a/drivers/scsi/aha1542.c b/drivers/scsi/aha1542.c
index 6e44a7fb67ca..d607f59f922a 100644
--- a/drivers/scsi/aha1542.c
+++ b/drivers/scsi/aha1542.c
@@ -105,10 +105,8 @@ static int aha1542_outb(unsigned int base, u8 val)
 	unsigned long flags;
 
 	while (1) {
-		if (!wait_mask(STATUS(base), CDF, 0, CDF, 0)) {
-			printk(KERN_ERR "aha1542_outb failed");
+		if (!wait_mask(STATUS(base), CDF, 0, CDF, 0))
 			return 1;
-		}
 		spin_lock_irqsave(&aha1542_lock, flags);
 		if (inb(STATUS(base)) & CDF) {
 			spin_unlock_irqrestore(&aha1542_lock, flags);
@@ -128,7 +126,6 @@ static int aha1542_out(unsigned int base, u8 *buf, int len)
 	while (len--) {
 		if (!wait_mask(STATUS(base), CDF, 0, CDF, 0)) {
 			spin_unlock_irqrestore(&aha1542_lock, flags);
-			printk(KERN_ERR "aha1542_out failed(%d): ", len + 1);
 			return 1;
 		}
 		outb(*buf++, DATA(base));
@@ -151,8 +148,6 @@ static int aha1542_in(unsigned int base, u8 *buf, int len, int timeout)
 	while (len--) {
 		if (!wait_mask(STATUS(base), DF, DF, 0, timeout)) {
 			spin_unlock_irqrestore(&aha1542_lock, flags);
-			if (timeout == 0)
-				printk(KERN_ERR "aha1542_in failed(%d): ", len + 1);
 			return 1;
 		}
 		*buf++ = inb(DATA(base));
@@ -284,7 +279,7 @@ static void aha1542_intr_handle(struct Scsi_Host *sh)
 #ifdef DEBUG
 	{
 		flag = inb(INTRFLAGS(sh->io_port));
-		printk(KERN_DEBUG "aha1542_intr_handle: ");
+		shost_printk(KERN_DEBUG, sh, "aha1542_intr_handle: ");
 		if (!(flag & ANYINTR))
 			printk("no interrupt?");
 		if (flag & MBIF)
@@ -334,7 +329,7 @@ static void aha1542_intr_handle(struct Scsi_Host *sh)
 			spin_unlock_irqrestore(&aha1542_lock, flags);
 			/* Hmm, no mail.  Must have read it the last time around */
 			if (!number_serviced)
-				printk(KERN_WARNING "aha1542.c: interrupt received, but no mail.\n");
+				shost_printk(KERN_WARNING, sh, "interrupt received, but no mail.\n");
 			return;
 		};
 
@@ -347,7 +342,7 @@ static void aha1542_intr_handle(struct Scsi_Host *sh)
 #ifdef DEBUG
 		{
 			if (ccb[mbo].tarstat | ccb[mbo].hastat)
-				printk(KERN_DEBUG "aha1542_command: returning %x (status %d)\n",
+				shost_printk(KERN_DEBUG, sh, "aha1542_command: returning %x (status %d)\n",
 				       ccb[mbo].tarstat + ((int) ccb[mbo].hastat << 16), mb[mbi].status);
 		};
 #endif
@@ -356,14 +351,14 @@ static void aha1542_intr_handle(struct Scsi_Host *sh)
 			continue;	/* Aborted command not found */
 
 #ifdef DEBUG
-		printk(KERN_DEBUG "...done %d %d\n", mbo, mbi);
+		shost_printk(KERN_DEBUG, sh, "...done %d %d\n", mbo, mbi);
 #endif
 
 		tmp_cmd = aha1542->int_cmds[mbo];
 
 		if (!tmp_cmd || !tmp_cmd->scsi_done) {
-			printk(KERN_WARNING "aha1542_intr_handle: Unexpected interrupt\n");
-			printk(KERN_WARNING "tarstat=%x, hastat=%x idlun=%x ccb#=%d \n", ccb[mbo].tarstat,
+			shost_printk(KERN_WARNING, sh, "Unexpected interrupt\n");
+			shost_printk(KERN_WARNING, sh, "tarstat=%x, hastat=%x idlun=%x ccb#=%d\n", ccb[mbo].tarstat,
 			       ccb[mbo].hastat, ccb[mbo].idlun, mbo);
 			return;
 		}
@@ -389,7 +384,7 @@ static void aha1542_intr_handle(struct Scsi_Host *sh)
 
 #ifdef DEBUG
 		if (errstatus)
-			printk(KERN_DEBUG "(aha1542 error:%x %x %x) ", errstatus,
+			shost_printk(KERN_DEBUG, sh, "(aha1542 error:%x %x %x) ", errstatus,
 			       ccb[mbo].hastat, ccb[mbo].tarstat);
 #endif
 
@@ -433,7 +428,8 @@ static irqreturn_t do_aha1542_intr_handle(int dummy, void *dev_id)
 
 static int aha1542_queuecommand_lck(struct scsi_cmnd *cmd, void (*done) (struct scsi_cmnd *))
 {
-	struct aha1542_hostdata *aha1542 = shost_priv(cmd->device->host);
+	struct Scsi_Host *sh = cmd->device->host;
+	struct aha1542_hostdata *aha1542 = shost_priv(sh);
 	u8 direction;
 	u8 target = cmd->device->id;
 	u8 lun = cmd->device->lun;
@@ -465,10 +461,10 @@ static int aha1542_queuecommand_lck(struct scsi_cmnd *cmd, void (*done) (struct
 	else
 		i = -1;
 	if (done)
-		printk(KERN_DEBUG "aha1542_queuecommand: dev %d cmd %02x pos %d len %d ", target, *cmd->cmnd, i, bufflen);
+		shost_printk(KERN_DEBUG, sh, "aha1542_queuecommand: dev %d cmd %02x pos %d len %d ", target, *cmd->cmnd, i, bufflen);
 	else
-		printk(KERN_DEBUG "aha1542_command: dev %d cmd %02x pos %d len %d ", target, *cmd->cmnd, i, bufflen);
-	printk(KERN_DEBUG "aha1542_queuecommand: dumping scsi cmd:");
+		shost_printk(KERN_DEBUG, sh, "aha1542_command: dev %d cmd %02x pos %d len %d ", target, *cmd->cmnd, i, bufflen);
+	shost_printk(KERN_DEBUG, sh, "aha1542_queuecommand: dumping scsi cmd:");
 	for (i = 0; i < cmd->cmd_len; i++)
 		printk("%02x ", cmd->cmnd[i]);
 	printk("\n");
@@ -501,7 +497,7 @@ static int aha1542_queuecommand_lck(struct scsi_cmnd *cmd, void (*done) (struct
 	spin_unlock_irqrestore(&aha1542_lock, flags);
 
 #ifdef DEBUG
-	printk(KERN_DEBUG "Sending command (%d %x)...", mbo, done);
+	shost_printk(KERN_DEBUG, sh, "Sending command (%d %x)...", mbo, done);
 #endif
 
 	any2scsi(mb[mbo].ccbptr, isa_virt_to_bus(&ccb[mbo]));	/* This gets trashed for some reason */
@@ -561,7 +557,7 @@ static int aha1542_queuecommand_lck(struct scsi_cmnd *cmd, void (*done) (struct
 #ifdef DEBUG
 	{
 		int i;
-		printk(KERN_DEBUG "aha1542_command: sending.. ");
+		shost_printk(KERN_DEBUG, sh, "aha1542_command: sending.. ");
 		for (i = 0; i < sizeof(ccb[mbo]) - 10; i++)
 			printk("%02x ", ((u8 *) &ccb[mbo])[i]);
 	};
@@ -597,7 +593,7 @@ static void setup_mailboxes(struct Scsi_Host *sh)
 	aha1542_intr_reset(sh->io_port);	/* reset interrupts, so they don't block */
 	any2scsi((mb_cmd + 2), isa_virt_to_bus(mb));
 	if (aha1542_out(sh->io_port, mb_cmd, 5))
-		printk(KERN_ERR "aha1542_detect: failed setting up mailboxes\n");
+		shost_printk(KERN_ERR, sh, "failed setting up mailboxes\n");
 	aha1542_intr_reset(sh->io_port);
 }
 
@@ -612,7 +608,7 @@ static int aha1542_getconfig(struct Scsi_Host *sh)
 	aha1542_outb(sh->io_port, CMD_RETCONF);
 	aha1542_in(sh->io_port, inquiry_result, 3, 0);
 	if (!wait_mask(INTRFLAGS(sh->io_port), INTRMASK, HACC, 0, 0))
-		printk(KERN_ERR "aha1542_detect: query board settings\n");
+		shost_printk(KERN_ERR, sh, "error querying board settings\n");
 	aha1542_intr_reset(sh->io_port);
 	switch (inquiry_result[0]) {
 	case 0x80:
@@ -633,7 +629,7 @@ static int aha1542_getconfig(struct Scsi_Host *sh)
 		sh->dma_channel = 0xFF;
 		break;
 	default:
-		printk(KERN_ERR "Unable to determine Adaptec DMA priority.  Disabling board\n");
+		shost_printk(KERN_ERR, sh, "Unable to determine DMA channel.\n");
 		return -1;
 	};
 	switch (inquiry_result[1]) {
@@ -656,7 +652,7 @@ static int aha1542_getconfig(struct Scsi_Host *sh)
 		sh->irq = 9;
 		break;
 	default:
-		printk(KERN_ERR "Unable to determine Adaptec IRQ level.  Disabling board\n");
+		shost_printk(KERN_ERR, sh, "Unable to determine IRQ level.\n");
 		return -1;
 	};
 	sh->this_id = inquiry_result[2] & 7;
@@ -694,7 +690,7 @@ static int aha1542_mbenable(struct Scsi_Host *sh)
 	};
 	while (0) {
 fail:
-		printk(KERN_ERR "aha1542_mbenable: Mailbox init failed\n");
+		shost_printk(KERN_ERR, sh, "Mailbox init failed\n");
 	}
 	aha1542_intr_reset(sh->io_port);
 	return retval;
@@ -713,7 +709,7 @@ static int aha1542_query(struct Scsi_Host *sh)
 	aha1542_outb(sh->io_port, CMD_INQUIRY);
 	aha1542_in(sh->io_port, inquiry_result, 4, 0);
 	if (!wait_mask(INTRFLAGS(sh->io_port), INTRMASK, HACC, 0, 0))
-		printk(KERN_ERR "aha1542_detect: query card type\n");
+		shost_printk(KERN_ERR, sh, "error querying card type\n");
 	aha1542_intr_reset(sh->io_port);
 
 	aha1542->bios_translation = BIOS_TRANSLATION_6432;	/* Default case */
@@ -725,7 +721,7 @@ static int aha1542_query(struct Scsi_Host *sh)
 	 */
 
 	if (inquiry_result[0] == 0x43) {
-		printk(KERN_INFO "aha1542.c: Emulation mode not supported for AHA 174N hardware.\n");
+		shost_printk(KERN_INFO, sh, "Emulation mode not supported for AHA-1740 hardware, use aha1740 driver instead.\n");
 		return 1;
 	};
 
@@ -784,7 +780,7 @@ static void aha1542_set_bus_times(struct Scsi_Host *sh, int bus_on, int bus_off,
 	aha1542_intr_reset(sh->io_port);
 	return;
 fail:
-	printk(KERN_ERR "setting bus on/off-time failed\n");
+	shost_printk(KERN_ERR, sh, "setting bus on/off-time failed\n");
 	aha1542_intr_reset(sh->io_port);
 }
 
@@ -794,6 +790,7 @@ static struct Scsi_Host *aha1542_hw_init(struct scsi_host_template *tpnt, struct
 	unsigned int base_io = io[indx];
 	struct Scsi_Host *sh;
 	struct aha1542_hostdata *aha1542;
+	char dma_info[] = "no DMA";
 
 	if (base_io == 0)
 		return NULL;
@@ -821,23 +818,23 @@ static struct Scsi_Host *aha1542_hw_init(struct scsi_host_template *tpnt, struct
 	if (aha1542_getconfig(sh) == -1)
 		goto unregister;
 
-	printk(KERN_INFO "Adaptec AHA-1542 (SCSI-ID %d) at IO 0x%x, IRQ %d", sh->this_id, base_io, sh->irq);
 	if (sh->dma_channel != 0xFF)
-		printk(", DMA %d", sh->dma_channel);
-	printk("\n");
+		snprintf(dma_info, sizeof(dma_info), "DMA %d", sh->dma_channel);
+	shost_printk(KERN_INFO, sh, "Adaptec AHA-1542 (SCSI-ID %d) at IO 0x%x, IRQ %d, %s\n",
+				sh->this_id, base_io, sh->irq, dma_info);
 	if (aha1542->bios_translation == BIOS_TRANSLATION_25563)
-		printk(KERN_INFO "aha1542.c: Using extended bios translation\n");
+		shost_printk(KERN_INFO, sh, "Using extended bios translation\n");
 
 	setup_mailboxes(sh);
 
 	if (request_irq(sh->irq, do_aha1542_intr_handle, 0,
 					"aha1542", sh)) {
-		printk(KERN_ERR "Unable to allocate IRQ for adaptec controller.\n");
+		shost_printk(KERN_ERR, sh, "Unable to allocate IRQ.\n");
 		goto unregister;
 	}
 	if (sh->dma_channel != 0xFF) {
 		if (request_dma(sh->dma_channel, "aha1542")) {
-			printk(KERN_ERR "Unable to allocate DMA channel for Adaptec.\n");
+			shost_printk(KERN_ERR, sh, "Unable to allocate DMA channel.\n");
 			goto free_irq;
 		}
 		if (sh->dma_channel == 0 || sh->dma_channel >= 5) {
@@ -979,7 +976,7 @@ static int aha1542_reset(struct scsi_cmnd *cmd, u8 reset_cmd)
 	 * out.  We do not try and restart any commands or anything - 
 	 * the strategy handler takes care of that crap.
 	 */
-	printk(KERN_WARNING "Sent BUS RESET to scsi host %d\n", cmd->device->host->host_no);
+	shost_printk(KERN_WARNING, cmd->device->host, "Sent BUS RESET to scsi host %d\n", cmd->device->host->host_no);
 
 	for (i = 0; i < AHA1542_MAILBOXES; i++) {
 		if (aha1542->int_cmds[i] != NULL) {
@@ -1105,7 +1102,7 @@ static int aha1542_pnp_probe(struct pnp_dev *pdev, const struct pnp_device_id *i
 		/* The card can be queried for its DMA, we have
 		   the DMA set up that is enough */
 
-		printk(KERN_INFO "ISAPnP found an AHA1535 at I/O 0x%03X\n", io[indx]);
+		dev_info(&pdev->dev, "ISAPnP found an AHA1535 at I/O 0x%03X", io[indx]);
 	}
 
 	sh = aha1542_hw_init(&driver_template, &pdev->dev, indx);

commit 37d607bd7944ce8d9d7b3baecc4f0ca725240fb8
Author: Ondrej Zary <linux@rainbow-software.org>
Date:   Fri Feb 6 23:11:50 2015 +0100

    aha1542: Change aha1542_set_bus_times parameters
    
    Pass struct Scsi_Host *sh and dma parameters instead of index to
    aha1542_set_bus_times.
    This is required for printk conversion.
    
    Signed-off-by: Ondrej Zary <linux@rainbow-software.org>
    Reviewed-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: James Bottomley <JBottomley@Odin.com>

diff --git a/drivers/scsi/aha1542.c b/drivers/scsi/aha1542.c
index 12b90a2325c8..6e44a7fb67ca 100644
--- a/drivers/scsi/aha1542.c
+++ b/drivers/scsi/aha1542.c
@@ -756,38 +756,36 @@ static u8 dma_speed_hw(int dma_speed)
 }
 
 /* Set the Bus on/off-times as not to ruin floppy performance */
-static void aha1542_set_bus_times(int indx)
+static void aha1542_set_bus_times(struct Scsi_Host *sh, int bus_on, int bus_off, int dma_speed)
 {
-	unsigned int base_io = io[indx];
-
-	if (bus_on[indx] > 0) {
-		u8 oncmd[] = { CMD_BUSON_TIME, clamp(bus_on[indx], 2, 15) };
+	if (bus_on > 0) {
+		u8 oncmd[] = { CMD_BUSON_TIME, clamp(bus_on, 2, 15) };
 
-		aha1542_intr_reset(base_io);
-		if (aha1542_out(base_io, oncmd, 2))
+		aha1542_intr_reset(sh->io_port);
+		if (aha1542_out(sh->io_port, oncmd, 2))
 			goto fail;
 	}
 
-	if (bus_off[indx] > 0) {
-		u8 offcmd[] = { CMD_BUSOFF_TIME, clamp(bus_off[indx], 1, 64) };
+	if (bus_off > 0) {
+		u8 offcmd[] = { CMD_BUSOFF_TIME, clamp(bus_off, 1, 64) };
 
-		aha1542_intr_reset(base_io);
-		if (aha1542_out(base_io, offcmd, 2))
+		aha1542_intr_reset(sh->io_port);
+		if (aha1542_out(sh->io_port, offcmd, 2))
 			goto fail;
 	}
 
-	if (dma_speed_hw(dma_speed[indx]) != 0xff) {
-		u8 dmacmd[] = { CMD_DMASPEED, dma_speed_hw(dma_speed[indx]) };
+	if (dma_speed_hw(dma_speed) != 0xff) {
+		u8 dmacmd[] = { CMD_DMASPEED, dma_speed_hw(dma_speed) };
 
-		aha1542_intr_reset(base_io);
-		if (aha1542_out(base_io, dmacmd, 2))
+		aha1542_intr_reset(sh->io_port);
+		if (aha1542_out(sh->io_port, dmacmd, 2))
 			goto fail;
 	}
-	aha1542_intr_reset(base_io);
+	aha1542_intr_reset(sh->io_port);
 	return;
 fail:
 	printk(KERN_ERR "setting bus on/off-time failed\n");
-	aha1542_intr_reset(base_io);
+	aha1542_intr_reset(sh->io_port);
 }
 
 /* return non-zero on detection */
@@ -817,7 +815,7 @@ static struct Scsi_Host *aha1542_hw_init(struct scsi_host_template *tpnt, struct
 	if (!aha1542_test_port(sh))
 		goto unregister;
 
-	aha1542_set_bus_times(indx);
+	aha1542_set_bus_times(sh, bus_on[indx], bus_off[indx], dma_speed[indx]);
 	if (aha1542_query(sh))
 		goto unregister;
 	if (aha1542_getconfig(sh) == -1)

commit 68ea9de3a6256195ab4d92fa7d0edf6ed657a500
Author: Ondrej Zary <linux@rainbow-software.org>
Date:   Fri Feb 6 23:11:49 2015 +0100

    aha1542: Pass struct Scsi_Host * to functions
    
    Pass struct Scsi_Host * to functions instead of base address.
    This reduces the number of parameters and is also required for printk
    conversion.
    
    Signed-off-by: Ondrej Zary <linux@rainbow-software.org>
    Reviewed-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: James Bottomley <JBottomley@Odin.com>

diff --git a/drivers/scsi/aha1542.c b/drivers/scsi/aha1542.c
index 16cb6f9d8307..12b90a2325c8 100644
--- a/drivers/scsi/aha1542.c
+++ b/drivers/scsi/aha1542.c
@@ -217,53 +217,53 @@ static int makecode(unsigned hosterr, unsigned scsierr)
 	return scsierr | (hosterr << 16);
 }
 
-static int aha1542_test_port(int bse, struct Scsi_Host *sh)
+static int aha1542_test_port(struct Scsi_Host *sh)
 {
 	u8 inquiry_result[4];
 	int i;
 
 	/* Quick and dirty test for presence of the card. */
-	if (inb(STATUS(bse)) == 0xff)
+	if (inb(STATUS(sh->io_port)) == 0xff)
 		return 0;
 
 	/* Reset the adapter. I ought to make a hard reset, but it's not really necessary */
 
 	/* In case some other card was probing here, reset interrupts */
-	aha1542_intr_reset(bse);	/* reset interrupts, so they don't block */
+	aha1542_intr_reset(sh->io_port);	/* reset interrupts, so they don't block */
 
-	outb(SRST | IRST /*|SCRST */ , CONTROL(bse));
+	outb(SRST | IRST /*|SCRST */ , CONTROL(sh->io_port));
 
 	mdelay(20);		/* Wait a little bit for things to settle down. */
 
 	/* Expect INIT and IDLE, any of the others are bad */
-	if (!wait_mask(STATUS(bse), STATMASK, INIT | IDLE, STST | DIAGF | INVDCMD | DF | CDF, 0))
+	if (!wait_mask(STATUS(sh->io_port), STATMASK, INIT | IDLE, STST | DIAGF | INVDCMD | DF | CDF, 0))
 		return 0;
 
 	/* Shouldn't have generated any interrupts during reset */
-	if (inb(INTRFLAGS(bse)) & INTRMASK)
+	if (inb(INTRFLAGS(sh->io_port)) & INTRMASK)
 		return 0;
 
 	/* Perform a host adapter inquiry instead so we do not need to set
 	   up the mailboxes ahead of time */
 
-	aha1542_outb(bse, CMD_INQUIRY);
+	aha1542_outb(sh->io_port, CMD_INQUIRY);
 
 	for (i = 0; i < 4; i++) {
-		if (!wait_mask(STATUS(bse), DF, DF, 0, 0))
+		if (!wait_mask(STATUS(sh->io_port), DF, DF, 0, 0))
 			return 0;
-		inquiry_result[i] = inb(DATA(bse));
+		inquiry_result[i] = inb(DATA(sh->io_port));
 	}
 
 	/* Reading port should reset DF */
-	if (inb(STATUS(bse)) & DF)
+	if (inb(STATUS(sh->io_port)) & DF)
 		return 0;
 
 	/* When HACC, command is completed, and we're though testing */
-	if (!wait_mask(INTRFLAGS(bse), HACC, HACC, 0, 0))
+	if (!wait_mask(INTRFLAGS(sh->io_port), HACC, HACC, 0, 0))
 		return 0;
 
 	/* Clear interrupts */
-	outb(IRST, CONTROL(bse));
+	outb(IRST, CONTROL(sh->io_port));
 
 	return 1;
 }
@@ -581,7 +581,7 @@ static int aha1542_queuecommand_lck(struct scsi_cmnd *cmd, void (*done) (struct
 static DEF_SCSI_QCMD(aha1542_queuecommand)
 
 /* Initialize mailboxes */
-static void setup_mailboxes(int bse, struct Scsi_Host *sh)
+static void setup_mailboxes(struct Scsi_Host *sh)
 {
 	struct aha1542_hostdata *aha1542 = shost_priv(sh);
 	int i;
@@ -594,43 +594,43 @@ static void setup_mailboxes(int bse, struct Scsi_Host *sh)
 		mb[i].status = mb[AHA1542_MAILBOXES + i].status = 0;
 		any2scsi(mb[i].ccbptr, isa_virt_to_bus(&ccb[i]));
 	};
-	aha1542_intr_reset(bse);	/* reset interrupts, so they don't block */
+	aha1542_intr_reset(sh->io_port);	/* reset interrupts, so they don't block */
 	any2scsi((mb_cmd + 2), isa_virt_to_bus(mb));
-	if (aha1542_out(bse, mb_cmd, 5))
+	if (aha1542_out(sh->io_port, mb_cmd, 5))
 		printk(KERN_ERR "aha1542_detect: failed setting up mailboxes\n");
-	aha1542_intr_reset(bse);
+	aha1542_intr_reset(sh->io_port);
 }
 
-static int aha1542_getconfig(int base_io, unsigned int *irq_level, unsigned char *dma_chan, unsigned int *scsi_id)
+static int aha1542_getconfig(struct Scsi_Host *sh)
 {
 	u8 inquiry_result[3];
 	int i;
-	i = inb(STATUS(base_io));
+	i = inb(STATUS(sh->io_port));
 	if (i & DF) {
-		i = inb(DATA(base_io));
+		i = inb(DATA(sh->io_port));
 	};
-	aha1542_outb(base_io, CMD_RETCONF);
-	aha1542_in(base_io, inquiry_result, 3, 0);
-	if (!wait_mask(INTRFLAGS(base_io), INTRMASK, HACC, 0, 0))
+	aha1542_outb(sh->io_port, CMD_RETCONF);
+	aha1542_in(sh->io_port, inquiry_result, 3, 0);
+	if (!wait_mask(INTRFLAGS(sh->io_port), INTRMASK, HACC, 0, 0))
 		printk(KERN_ERR "aha1542_detect: query board settings\n");
-	aha1542_intr_reset(base_io);
+	aha1542_intr_reset(sh->io_port);
 	switch (inquiry_result[0]) {
 	case 0x80:
-		*dma_chan = 7;
+		sh->dma_channel = 7;
 		break;
 	case 0x40:
-		*dma_chan = 6;
+		sh->dma_channel = 6;
 		break;
 	case 0x20:
-		*dma_chan = 5;
+		sh->dma_channel = 5;
 		break;
 	case 0x01:
-		*dma_chan = 0;
+		sh->dma_channel = 0;
 		break;
 	case 0:
 		/* This means that the adapter, although Adaptec 1542 compatible, doesn't use a DMA channel.
 		   Currently only aware of the BusLogic BT-445S VL-Bus adapter which needs this. */
-		*dma_chan = 0xFF;
+		sh->dma_channel = 0xFF;
 		break;
 	default:
 		printk(KERN_ERR "Unable to determine Adaptec DMA priority.  Disabling board\n");
@@ -638,35 +638,35 @@ static int aha1542_getconfig(int base_io, unsigned int *irq_level, unsigned char
 	};
 	switch (inquiry_result[1]) {
 	case 0x40:
-		*irq_level = 15;
+		sh->irq = 15;
 		break;
 	case 0x20:
-		*irq_level = 14;
+		sh->irq = 14;
 		break;
 	case 0x8:
-		*irq_level = 12;
+		sh->irq = 12;
 		break;
 	case 0x4:
-		*irq_level = 11;
+		sh->irq = 11;
 		break;
 	case 0x2:
-		*irq_level = 10;
+		sh->irq = 10;
 		break;
 	case 0x1:
-		*irq_level = 9;
+		sh->irq = 9;
 		break;
 	default:
 		printk(KERN_ERR "Unable to determine Adaptec IRQ level.  Disabling board\n");
 		return -1;
 	};
-	*scsi_id = inquiry_result[2] & 7;
+	sh->this_id = inquiry_result[2] & 7;
 	return 0;
 }
 
 /* This function should only be called for 1542C boards - we can detect
    the special firmware settings and unlock the board */
 
-static int aha1542_mbenable(int base)
+static int aha1542_mbenable(struct Scsi_Host *sh)
 {
 	static u8 mbenable_cmd[3];
 	static u8 mbenable_result[2];
@@ -674,12 +674,12 @@ static int aha1542_mbenable(int base)
 
 	retval = BIOS_TRANSLATION_6432;
 
-	aha1542_outb(base, CMD_EXTBIOS);
-	if (aha1542_in(base, mbenable_result, 2, 100))
+	aha1542_outb(sh->io_port, CMD_EXTBIOS);
+	if (aha1542_in(sh->io_port, mbenable_result, 2, 100))
 		return retval;
-	if (!wait_mask(INTRFLAGS(base), INTRMASK, HACC, 0, 100))
+	if (!wait_mask(INTRFLAGS(sh->io_port), INTRMASK, HACC, 0, 100))
 		goto fail;
-	aha1542_intr_reset(base);
+	aha1542_intr_reset(sh->io_port);
 
 	if ((mbenable_result[0] & 0x08) || mbenable_result[1]) {
 		mbenable_cmd[0] = CMD_MBENABLE;
@@ -689,33 +689,34 @@ static int aha1542_mbenable(int base)
 		if ((mbenable_result[0] & 0x08) && (mbenable_result[1] & 0x03))
 			retval = BIOS_TRANSLATION_25563;
 
-		if (aha1542_out(base, mbenable_cmd, 3))
+		if (aha1542_out(sh->io_port, mbenable_cmd, 3))
 			goto fail;
 	};
 	while (0) {
 fail:
 		printk(KERN_ERR "aha1542_mbenable: Mailbox init failed\n");
 	}
-	aha1542_intr_reset(base);
+	aha1542_intr_reset(sh->io_port);
 	return retval;
 }
 
 /* Query the board to find out if it is a 1542 or a 1740, or whatever. */
-static int aha1542_query(int base_io, int *transl)
+static int aha1542_query(struct Scsi_Host *sh)
 {
+	struct aha1542_hostdata *aha1542 = shost_priv(sh);
 	u8 inquiry_result[4];
 	int i;
-	i = inb(STATUS(base_io));
+	i = inb(STATUS(sh->io_port));
 	if (i & DF) {
-		i = inb(DATA(base_io));
+		i = inb(DATA(sh->io_port));
 	};
-	aha1542_outb(base_io, CMD_INQUIRY);
-	aha1542_in(base_io, inquiry_result, 4, 0);
-	if (!wait_mask(INTRFLAGS(base_io), INTRMASK, HACC, 0, 0))
+	aha1542_outb(sh->io_port, CMD_INQUIRY);
+	aha1542_in(sh->io_port, inquiry_result, 4, 0);
+	if (!wait_mask(INTRFLAGS(sh->io_port), INTRMASK, HACC, 0, 0))
 		printk(KERN_ERR "aha1542_detect: query card type\n");
-	aha1542_intr_reset(base_io);
+	aha1542_intr_reset(sh->io_port);
 
-	*transl = BIOS_TRANSLATION_6432;	/* Default case */
+	aha1542->bios_translation = BIOS_TRANSLATION_6432;	/* Default case */
 
 	/* For an AHA1740 series board, we ignore the board since there is a
 	   hardware bug which can lead to wrong blocks being returned if the board
@@ -731,7 +732,7 @@ static int aha1542_query(int base_io, int *transl)
 	/* Always call this - boards that do not support extended bios translation
 	   will ignore the command, and we will set the proper default */
 
-	*transl = aha1542_mbenable(base_io);
+	aha1542->bios_translation = aha1542_mbenable(sh);
 
 	return 0;
 }
@@ -807,13 +808,19 @@ static struct Scsi_Host *aha1542_hw_init(struct scsi_host_template *tpnt, struct
 		goto release;
 	aha1542 = shost_priv(sh);
 
-	if (!aha1542_test_port(base_io, sh))
+	sh->unique_id = base_io;
+	sh->io_port = base_io;
+	sh->n_io_port = AHA1542_REGION_SIZE;
+	aha1542->aha1542_last_mbi_used = 2 * AHA1542_MAILBOXES - 1;
+	aha1542->aha1542_last_mbo_used = AHA1542_MAILBOXES - 1;
+
+	if (!aha1542_test_port(sh))
 		goto unregister;
 
 	aha1542_set_bus_times(indx);
-	if (aha1542_query(base_io, &aha1542->bios_translation))
+	if (aha1542_query(sh))
 		goto unregister;
-	if (aha1542_getconfig(base_io, &sh->irq, &sh->dma_channel, &sh->this_id) == -1)
+	if (aha1542_getconfig(sh) == -1)
 		goto unregister;
 
 	printk(KERN_INFO "Adaptec AHA-1542 (SCSI-ID %d) at IO 0x%x, IRQ %d", sh->this_id, base_io, sh->irq);
@@ -823,7 +830,7 @@ static struct Scsi_Host *aha1542_hw_init(struct scsi_host_template *tpnt, struct
 	if (aha1542->bios_translation == BIOS_TRANSLATION_25563)
 		printk(KERN_INFO "aha1542.c: Using extended bios translation\n");
 
-	setup_mailboxes(base_io, sh);
+	setup_mailboxes(sh);
 
 	if (request_irq(sh->irq, do_aha1542_intr_handle, 0,
 					"aha1542", sh)) {
@@ -841,12 +848,6 @@ static struct Scsi_Host *aha1542_hw_init(struct scsi_host_template *tpnt, struct
 		}
 	}
 
-	sh->unique_id = base_io;
-	sh->io_port = base_io;
-	sh->n_io_port = AHA1542_REGION_SIZE;
-	aha1542->aha1542_last_mbi_used = 2 * AHA1542_MAILBOXES - 1;
-	aha1542->aha1542_last_mbo_used = AHA1542_MAILBOXES - 1;
-
 	if (scsi_add_host(sh, pdev))
 		goto free_dma;
 
@@ -973,7 +974,7 @@ static int aha1542_reset(struct scsi_cmnd *cmd, u8 reset_cmd)
 	 * us again after host reset.
 	 */
 	if (reset_cmd & HRST)
-		setup_mailboxes(cmd->device->host->io_port, cmd->device->host);
+		setup_mailboxes(cmd->device->host);
 	/*
 	 * Now try to pick up the pieces.  For all pending commands,
 	 * free any internal data structures, and basically clear things

commit 954a9fd79b165c14e136e8f90e822ba3d186f6b1
Author: Ondrej Zary <linux@rainbow-software.org>
Date:   Fri Feb 6 23:11:48 2015 +0100

    aha1542: cleanup includes
    
    Signed-off-by: Ondrej Zary <linux@rainbow-software.org>
    Reviewed-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: James Bottomley <JBottomley@Odin.com>

diff --git a/drivers/scsi/aha1542.c b/drivers/scsi/aha1542.c
index 214b9f488869..16cb6f9d8307 100644
--- a/drivers/scsi/aha1542.c
+++ b/drivers/scsi/aha1542.c
@@ -11,23 +11,18 @@
 #include <linux/kernel.h>
 #include <linux/types.h>
 #include <linux/string.h>
-#include <linux/ioport.h>
 #include <linux/delay.h>
-#include <linux/proc_fs.h>
 #include <linux/init.h>
 #include <linux/spinlock.h>
 #include <linux/isa.h>
 #include <linux/pnp.h>
-#include <linux/blkdev.h>
 #include <linux/slab.h>
-
+#include <linux/io.h>
 #include <asm/dma.h>
-#include <asm/io.h>
-
-#include "scsi.h"
+#include <scsi/scsi_cmnd.h>
+#include <scsi/scsi_device.h>
 #include <scsi/scsi_host.h>
 #include "aha1542.h"
-#include <linux/stat.h>
 
 #ifdef DEBUG
 #define DEB(x) x

commit 1d084d200d2a57219ec2c912c700ddff09f0676c
Author: Ondrej Zary <linux@rainbow-software.org>
Date:   Fri Feb 6 23:11:47 2015 +0100

    aha1542: remove useless changelog
    
    Signed-off-by: Ondrej Zary <linux@rainbow-software.org>
    Reviewed-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: James Bottomley <JBottomley@Odin.com>

diff --git a/drivers/scsi/aha1542.c b/drivers/scsi/aha1542.c
index 7b066984ebbf..214b9f488869 100644
--- a/drivers/scsi/aha1542.c
+++ b/drivers/scsi/aha1542.c
@@ -1,28 +1,9 @@
-/* $Id: aha1542.c,v 1.1 1992/07/24 06:27:38 root Exp root $
- *  linux/kernel/aha1542.c
+/*
+ *  Driver for Adaptec AHA-1542 SCSI host adapters
  *
  *  Copyright (C) 1992  Tommy Thorn
  *  Copyright (C) 1993, 1994, 1995 Eric Youngdale
- *
- *  Modified by Eric Youngdale
- *        Use request_irq and request_dma to help prevent unexpected conflicts
- *        Set up on-board DMA controller, such that we do not have to
- *        have the bios enabled to use the aha1542.
- *  Modified by David Gentzel
- *        Don't call request_dma if dma mask is 0 (for BusLogic BT-445S VL-Bus
- *        controller).
- *  Modified by Matti Aarnio
- *        Accept parameters from LILO cmd-line. -- 1-Oct-94
- *  Modified by Mike McLagan <mike.mclagan@linux.org>
- *        Recognise extended mode on AHA1542CP, different bit than 1542CF
- *        1-Jan-97
- *  Modified by Bjorn L. Thordarson and Einar Thor Einarsson
- *        Recognize that DMA0 is valid DMA channel -- 13-Jul-98
- *  Modified by Chris Faulhaber <jedgar@fxp.org>
- *        Added module command-line options
- *        19-Jul-99
- *  Modified by Adam Fritzler
- *        Added proper detection of the AHA-1640 (MCA, now deleted)
+ *  Copyright (C) 2015 Ondrej Zary
  */
 
 #include <linux/module.h>

commit c2532f68266d3b10fe71e0b3e63f4c29d73e6ee5
Author: Ondrej Zary <linux@rainbow-software.org>
Date:   Fri Feb 6 23:11:45 2015 +0100

    aha1542: Always name Scsi_Host variables sh
    
    Make Scsi_Host variable names consistent - use sh everywhere.
    
    Signed-off-by: Ondrej Zary <linux@rainbow-software.org>
    Reviewed-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: James Bottomley <JBottomley@Odin.com>

diff --git a/drivers/scsi/aha1542.c b/drivers/scsi/aha1542.c
index dcc493de68e7..7b066984ebbf 100644
--- a/drivers/scsi/aha1542.c
+++ b/drivers/scsi/aha1542.c
@@ -241,7 +241,7 @@ static int makecode(unsigned hosterr, unsigned scsierr)
 	return scsierr | (hosterr << 16);
 }
 
-static int aha1542_test_port(int bse, struct Scsi_Host *shpnt)
+static int aha1542_test_port(int bse, struct Scsi_Host *sh)
 {
 	u8 inquiry_result[4];
 	int i;
@@ -293,9 +293,9 @@ static int aha1542_test_port(int bse, struct Scsi_Host *shpnt)
 }
 
 /* A "high" level interrupt handler */
-static void aha1542_intr_handle(struct Scsi_Host *shost)
+static void aha1542_intr_handle(struct Scsi_Host *sh)
 {
-	struct aha1542_hostdata *aha1542 = shost_priv(shost);
+	struct aha1542_hostdata *aha1542 = shost_priv(sh);
 	void (*my_done)(struct scsi_cmnd *) = NULL;
 	int errstatus, mbi, mbo, mbistatus;
 	int number_serviced;
@@ -307,7 +307,7 @@ static void aha1542_intr_handle(struct Scsi_Host *shost)
 
 #ifdef DEBUG
 	{
-		flag = inb(INTRFLAGS(shost->io_port));
+		flag = inb(INTRFLAGS(sh->io_port));
 		printk(KERN_DEBUG "aha1542_intr_handle: ");
 		if (!(flag & ANYINTR))
 			printk("no interrupt?");
@@ -319,13 +319,13 @@ static void aha1542_intr_handle(struct Scsi_Host *shost)
 			printk("HACC ");
 		if (flag & SCRD)
 			printk("SCRD ");
-		printk("status %02x\n", inb(STATUS(shost->io_port)));
+		printk("status %02x\n", inb(STATUS(sh->io_port)));
 	};
 #endif
 	number_serviced = 0;
 
 	while (1 == 1) {
-		flag = inb(INTRFLAGS(shost->io_port));
+		flag = inb(INTRFLAGS(sh->io_port));
 
 		/* Check for unusual interrupts.  If any of these happen, we should
 		   probably do something special, but for now just printing a message
@@ -339,7 +339,7 @@ static void aha1542_intr_handle(struct Scsi_Host *shost)
 			if (flag & SCRD)
 				printk("SCRD ");
 		}
-		aha1542_intr_reset(shost->io_port);
+		aha1542_intr_reset(sh->io_port);
 
 		spin_lock_irqsave(&aha1542_lock, flags);
 		mbi = aha1542->aha1542_last_mbi_used + 1;
@@ -447,11 +447,11 @@ static void aha1542_intr_handle(struct Scsi_Host *shost)
 static irqreturn_t do_aha1542_intr_handle(int dummy, void *dev_id)
 {
 	unsigned long flags;
-	struct Scsi_Host *shost = dev_id;
+	struct Scsi_Host *sh = dev_id;
 
-	spin_lock_irqsave(shost->host_lock, flags);
-	aha1542_intr_handle(shost);
-	spin_unlock_irqrestore(shost->host_lock, flags);
+	spin_lock_irqsave(sh->host_lock, flags);
+	aha1542_intr_handle(sh);
+	spin_unlock_irqrestore(sh->host_lock, flags);
 	return IRQ_HANDLED;
 }
 
@@ -605,9 +605,9 @@ static int aha1542_queuecommand_lck(struct scsi_cmnd *cmd, void (*done) (struct
 static DEF_SCSI_QCMD(aha1542_queuecommand)
 
 /* Initialize mailboxes */
-static void setup_mailboxes(int bse, struct Scsi_Host *shpnt)
+static void setup_mailboxes(int bse, struct Scsi_Host *sh)
 {
-	struct aha1542_hostdata *aha1542 = shost_priv(shpnt);
+	struct aha1542_hostdata *aha1542 = shost_priv(sh);
 	int i;
 	struct mailbox *mb = aha1542->mb;
 	struct ccb *ccb = aha1542->ccb;
@@ -817,7 +817,7 @@ static void aha1542_set_bus_times(int indx)
 static struct Scsi_Host *aha1542_hw_init(struct scsi_host_template *tpnt, struct device *pdev, int indx)
 {
 	unsigned int base_io = io[indx];
-	struct Scsi_Host *shpnt;
+	struct Scsi_Host *sh;
 	struct aha1542_hostdata *aha1542;
 
 	if (base_io == 0)
@@ -826,80 +826,80 @@ static struct Scsi_Host *aha1542_hw_init(struct scsi_host_template *tpnt, struct
 	if (!request_region(base_io, AHA1542_REGION_SIZE, "aha1542"))
 		return NULL;
 
-	shpnt = scsi_host_alloc(tpnt, sizeof(struct aha1542_hostdata));
-	if (!shpnt)
+	sh = scsi_host_alloc(tpnt, sizeof(struct aha1542_hostdata));
+	if (!sh)
 		goto release;
-	aha1542 = shost_priv(shpnt);
+	aha1542 = shost_priv(sh);
 
-	if (!aha1542_test_port(base_io, shpnt))
+	if (!aha1542_test_port(base_io, sh))
 		goto unregister;
 
 	aha1542_set_bus_times(indx);
 	if (aha1542_query(base_io, &aha1542->bios_translation))
 		goto unregister;
-	if (aha1542_getconfig(base_io, &shpnt->irq, &shpnt->dma_channel, &shpnt->this_id) == -1)
+	if (aha1542_getconfig(base_io, &sh->irq, &sh->dma_channel, &sh->this_id) == -1)
 		goto unregister;
 
-	printk(KERN_INFO "Adaptec AHA-1542 (SCSI-ID %d) at IO 0x%x, IRQ %d", shpnt->this_id, base_io, shpnt->irq);
-	if (shpnt->dma_channel != 0xFF)
-		printk(", DMA %d", shpnt->dma_channel);
+	printk(KERN_INFO "Adaptec AHA-1542 (SCSI-ID %d) at IO 0x%x, IRQ %d", sh->this_id, base_io, sh->irq);
+	if (sh->dma_channel != 0xFF)
+		printk(", DMA %d", sh->dma_channel);
 	printk("\n");
 	if (aha1542->bios_translation == BIOS_TRANSLATION_25563)
 		printk(KERN_INFO "aha1542.c: Using extended bios translation\n");
 
-	setup_mailboxes(base_io, shpnt);
+	setup_mailboxes(base_io, sh);
 
-	if (request_irq(shpnt->irq, do_aha1542_intr_handle, 0,
-					"aha1542", shpnt)) {
+	if (request_irq(sh->irq, do_aha1542_intr_handle, 0,
+					"aha1542", sh)) {
 		printk(KERN_ERR "Unable to allocate IRQ for adaptec controller.\n");
 		goto unregister;
 	}
-	if (shpnt->dma_channel != 0xFF) {
-		if (request_dma(shpnt->dma_channel, "aha1542")) {
+	if (sh->dma_channel != 0xFF) {
+		if (request_dma(sh->dma_channel, "aha1542")) {
 			printk(KERN_ERR "Unable to allocate DMA channel for Adaptec.\n");
 			goto free_irq;
 		}
-		if (shpnt->dma_channel == 0 || shpnt->dma_channel >= 5) {
-			set_dma_mode(shpnt->dma_channel, DMA_MODE_CASCADE);
-			enable_dma(shpnt->dma_channel);
+		if (sh->dma_channel == 0 || sh->dma_channel >= 5) {
+			set_dma_mode(sh->dma_channel, DMA_MODE_CASCADE);
+			enable_dma(sh->dma_channel);
 		}
 	}
 
-	shpnt->unique_id = base_io;
-	shpnt->io_port = base_io;
-	shpnt->n_io_port = AHA1542_REGION_SIZE;
+	sh->unique_id = base_io;
+	sh->io_port = base_io;
+	sh->n_io_port = AHA1542_REGION_SIZE;
 	aha1542->aha1542_last_mbi_used = 2 * AHA1542_MAILBOXES - 1;
 	aha1542->aha1542_last_mbo_used = AHA1542_MAILBOXES - 1;
 
-	if (scsi_add_host(shpnt, pdev))
+	if (scsi_add_host(sh, pdev))
 		goto free_dma;
 
-	scsi_scan_host(shpnt);
+	scsi_scan_host(sh);
 
-	return shpnt;
+	return sh;
 free_dma:
-	if (shpnt->dma_channel != 0xff)
-		free_dma(shpnt->dma_channel);
+	if (sh->dma_channel != 0xff)
+		free_dma(sh->dma_channel);
 free_irq:
-	free_irq(shpnt->irq, shpnt);
+	free_irq(sh->irq, sh);
 unregister:
-	scsi_host_put(shpnt);
+	scsi_host_put(sh);
 release:
 	release_region(base_io, AHA1542_REGION_SIZE);
 
 	return NULL;
 }
 
-static int aha1542_release(struct Scsi_Host *shost)
+static int aha1542_release(struct Scsi_Host *sh)
 {
-	scsi_remove_host(shost);
-	if (shost->dma_channel != 0xff)
-		free_dma(shost->dma_channel);
-	if (shost->irq)
-		free_irq(shost->irq, shost);
-	if (shost->io_port && shost->n_io_port)
-		release_region(shost->io_port, shost->n_io_port);
-	scsi_host_put(shost);
+	scsi_remove_host(sh);
+	if (sh->dma_channel != 0xff)
+		free_dma(sh->dma_channel);
+	if (sh->irq)
+		free_irq(sh->irq, sh);
+	if (sh->io_port && sh->n_io_port)
+		release_region(sh->io_port, sh->n_io_port);
+	scsi_host_put(sh);
 	return 0;
 }
 

commit 55b28f9fc033f9af090a58ea97063ca51552a2a6
Author: Ondrej Zary <linux@rainbow-software.org>
Date:   Fri Feb 6 23:11:44 2015 +0100

    aha1524: Use struct scsi_cmnd
    
    Use struct scsi_cmnd instead of Scsi_Cmnd and also rename the variables
    to get rid of SC prefix
    
    Signed-off-by: Ondrej Zary <linux@rainbow-software.org>
    Reviewed-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: James Bottomley <JBottomley@Odin.com>

diff --git a/drivers/scsi/aha1542.c b/drivers/scsi/aha1542.c
index dbe46591a5e2..dcc493de68e7 100644
--- a/drivers/scsi/aha1542.c
+++ b/drivers/scsi/aha1542.c
@@ -86,7 +86,7 @@ struct aha1542_hostdata {
 	int bios_translation;	/* Mapping bios uses - for compatibility */
 	int aha1542_last_mbi_used;
 	int aha1542_last_mbo_used;
-	Scsi_Cmnd *SCint[AHA1542_MAILBOXES];
+	struct scsi_cmnd *int_cmds[AHA1542_MAILBOXES];
 	struct mailbox mb[2 * AHA1542_MAILBOXES];
 	struct ccb ccb[AHA1542_MAILBOXES];
 };
@@ -296,11 +296,11 @@ static int aha1542_test_port(int bse, struct Scsi_Host *shpnt)
 static void aha1542_intr_handle(struct Scsi_Host *shost)
 {
 	struct aha1542_hostdata *aha1542 = shost_priv(shost);
-	void (*my_done) (Scsi_Cmnd *) = NULL;
+	void (*my_done)(struct scsi_cmnd *) = NULL;
 	int errstatus, mbi, mbo, mbistatus;
 	int number_serviced;
 	unsigned long flags;
-	Scsi_Cmnd *SCtmp;
+	struct scsi_cmnd *tmp_cmd;
 	int flag;
 	struct mailbox *mb = aha1542->mb;
 	struct ccb *ccb = aha1542->ccb;
@@ -383,22 +383,22 @@ static void aha1542_intr_handle(struct Scsi_Host *shost)
 		printk(KERN_DEBUG "...done %d %d\n", mbo, mbi);
 #endif
 
-		SCtmp = aha1542->SCint[mbo];
+		tmp_cmd = aha1542->int_cmds[mbo];
 
-		if (!SCtmp || !SCtmp->scsi_done) {
+		if (!tmp_cmd || !tmp_cmd->scsi_done) {
 			printk(KERN_WARNING "aha1542_intr_handle: Unexpected interrupt\n");
 			printk(KERN_WARNING "tarstat=%x, hastat=%x idlun=%x ccb#=%d \n", ccb[mbo].tarstat,
 			       ccb[mbo].hastat, ccb[mbo].idlun, mbo);
 			return;
 		}
-		my_done = SCtmp->scsi_done;
-		kfree(SCtmp->host_scribble);
-		SCtmp->host_scribble = NULL;
+		my_done = tmp_cmd->scsi_done;
+		kfree(tmp_cmd->host_scribble);
+		tmp_cmd->host_scribble = NULL;
 		/* Fetch the sense data, and tuck it away, in the required slot.  The
 		   Adaptec automatically fetches it, and there is no guarantee that
 		   we will still have it in the cdb when we come back */
 		if (ccb[mbo].tarstat == 2)
-			memcpy(SCtmp->sense_buffer, &ccb[mbo].cdb[ccb[mbo].cdblen],
+			memcpy(tmp_cmd->sense_buffer, &ccb[mbo].cdb[ccb[mbo].cdblen],
 			       SCSI_SENSE_BUFFERSIZE);
 
 
@@ -435,10 +435,10 @@ static void aha1542_intr_handle(struct Scsi_Host *shost)
 			 */
 		}
 		DEB(if (errstatus) printk("aha1542_intr_handle: returning %6x\n", errstatus));
-		SCtmp->result = errstatus;
-		aha1542->SCint[mbo] = NULL;	/* This effectively frees up the mailbox slot, as
+		tmp_cmd->result = errstatus;
+		aha1542->int_cmds[mbo] = NULL;	/* This effectively frees up the mailbox slot, as
 						   far as queuecommand is concerned */
-		my_done(SCtmp);
+		my_done(tmp_cmd);
 		number_serviced++;
 	};
 }
@@ -455,14 +455,14 @@ static irqreturn_t do_aha1542_intr_handle(int dummy, void *dev_id)
 	return IRQ_HANDLED;
 }
 
-static int aha1542_queuecommand_lck(Scsi_Cmnd * SCpnt, void (*done) (Scsi_Cmnd *))
+static int aha1542_queuecommand_lck(struct scsi_cmnd *cmd, void (*done) (struct scsi_cmnd *))
 {
-	struct aha1542_hostdata *aha1542 = shost_priv(SCpnt->device->host);
+	struct aha1542_hostdata *aha1542 = shost_priv(cmd->device->host);
 	u8 direction;
-	u8 target = SCpnt->device->id;
-	u8 lun = SCpnt->device->lun;
+	u8 target = cmd->device->id;
+	u8 lun = cmd->device->lun;
 	unsigned long flags;
-	int bufflen = scsi_bufflen(SCpnt);
+	int bufflen = scsi_bufflen(cmd);
 	int mbo;
 	struct mailbox *mb = aha1542->mb;
 	struct ccb *ccb = aha1542->ccb;
@@ -470,33 +470,33 @@ static int aha1542_queuecommand_lck(Scsi_Cmnd * SCpnt, void (*done) (Scsi_Cmnd *
 	DEB(int i);
 
 	DEB(if (target > 1) {
-	    SCpnt->result = DID_TIME_OUT << 16;
-	    done(SCpnt); return 0;
+	    cmd->result = DID_TIME_OUT << 16;
+	    done(cmd); return 0;
 	    }
 	);
 
-	if (*SCpnt->cmnd == REQUEST_SENSE) {
+	if (*cmd->cmnd == REQUEST_SENSE) {
 		/* Don't do the command - we have the sense data already */
-		SCpnt->result = 0;
-		done(SCpnt);
+		cmd->result = 0;
+		done(cmd);
 		return 0;
 	}
 #ifdef DEBUG
-	if (*SCpnt->cmnd == READ_10 || *SCpnt->cmnd == WRITE_10)
-		i = xscsi2int(SCpnt->cmnd + 2);
-	else if (*SCpnt->cmnd == READ_6 || *SCpnt->cmnd == WRITE_6)
-		i = scsi2int(SCpnt->cmnd + 2);
+	if (*cmd->cmnd == READ_10 || *cmd->cmnd == WRITE_10)
+		i = xscsi2int(cmd->cmnd + 2);
+	else if (*cmd->cmnd == READ_6 || *cmd->cmnd == WRITE_6)
+		i = scsi2int(cmd->cmnd + 2);
 	else
 		i = -1;
 	if (done)
-		printk(KERN_DEBUG "aha1542_queuecommand: dev %d cmd %02x pos %d len %d ", target, *SCpnt->cmnd, i, bufflen);
+		printk(KERN_DEBUG "aha1542_queuecommand: dev %d cmd %02x pos %d len %d ", target, *cmd->cmnd, i, bufflen);
 	else
-		printk(KERN_DEBUG "aha1542_command: dev %d cmd %02x pos %d len %d ", target, *SCpnt->cmnd, i, bufflen);
+		printk(KERN_DEBUG "aha1542_command: dev %d cmd %02x pos %d len %d ", target, *cmd->cmnd, i, bufflen);
 	printk(KERN_DEBUG "aha1542_queuecommand: dumping scsi cmd:");
-	for (i = 0; i < SCpnt->cmd_len; i++)
-		printk("%02x ", SCpnt->cmnd[i]);
+	for (i = 0; i < cmd->cmd_len; i++)
+		printk("%02x ", cmd->cmnd[i]);
 	printk("\n");
-	if (*SCpnt->cmnd == WRITE_10 || *SCpnt->cmnd == WRITE_6)
+	if (*cmd->cmnd == WRITE_10 || *cmd->cmnd == WRITE_6)
 		return 0;	/* we are still testing, so *don't* write */
 #endif
 	/* Use the outgoing mailboxes in a round-robin fashion, because this
@@ -508,17 +508,17 @@ static int aha1542_queuecommand_lck(Scsi_Cmnd * SCpnt, void (*done) (Scsi_Cmnd *
 		mbo = 0;
 
 	do {
-		if (mb[mbo].status == 0 && aha1542->SCint[mbo] == NULL)
+		if (mb[mbo].status == 0 && aha1542->int_cmds[mbo] == NULL)
 			break;
 		mbo++;
 		if (mbo >= AHA1542_MAILBOXES)
 			mbo = 0;
 	} while (mbo != aha1542->aha1542_last_mbo_used);
 
-	if (mb[mbo].status || aha1542->SCint[mbo])
+	if (mb[mbo].status || aha1542->int_cmds[mbo])
 		panic("Unable to find empty mailbox for aha1542.\n");
 
-	aha1542->SCint[mbo] = SCpnt;	/* This will effectively prevent someone else from
+	aha1542->int_cmds[mbo] = cmd;	/* This will effectively prevent someone else from
 					   screwing with this cdb. */
 
 	aha1542->aha1542_last_mbo_used = mbo;
@@ -532,15 +532,15 @@ static int aha1542_queuecommand_lck(Scsi_Cmnd * SCpnt, void (*done) (Scsi_Cmnd *
 
 	memset(&ccb[mbo], 0, sizeof(struct ccb));
 
-	ccb[mbo].cdblen = SCpnt->cmd_len;
+	ccb[mbo].cdblen = cmd->cmd_len;
 
 	direction = 0;
-	if (*SCpnt->cmnd == READ_10 || *SCpnt->cmnd == READ_6)
+	if (*cmd->cmnd == READ_10 || *cmd->cmnd == READ_6)
 		direction = 8;
-	else if (*SCpnt->cmnd == WRITE_10 || *SCpnt->cmnd == WRITE_6)
+	else if (*cmd->cmnd == WRITE_10 || *cmd->cmnd == WRITE_6)
 		direction = 16;
 
-	memcpy(ccb[mbo].cdb, SCpnt->cmnd, ccb[mbo].cdblen);
+	memcpy(ccb[mbo].cdb, cmd->cmnd, ccb[mbo].cdblen);
 
 	if (bufflen) {
 		struct scatterlist *sg;
@@ -548,17 +548,17 @@ static int aha1542_queuecommand_lck(Scsi_Cmnd * SCpnt, void (*done) (Scsi_Cmnd *
 #ifdef DEBUG
 		unsigned char *ptr;
 #endif
-		int i, sg_count = scsi_sg_count(SCpnt);
+		int i, sg_count = scsi_sg_count(cmd);
 		ccb[mbo].op = 2;	/* SCSI Initiator Command  w/scatter-gather */
-		SCpnt->host_scribble = kmalloc(sizeof(*cptr)*sg_count,
+		cmd->host_scribble = kmalloc(sizeof(*cptr)*sg_count,
 		                                         GFP_KERNEL | GFP_DMA);
-		cptr = (struct chain *) SCpnt->host_scribble;
+		cptr = (struct chain *) cmd->host_scribble;
 		if (cptr == NULL) {
 			/* free the claimed mailbox slot */
-			aha1542->SCint[mbo] = NULL;
+			aha1542->int_cmds[mbo] = NULL;
 			return SCSI_MLQUEUE_HOST_BUSY;
 		}
-		scsi_for_each_sg(SCpnt, sg, sg_count, i) {
+		scsi_for_each_sg(cmd, sg, sg_count, i) {
 			any2scsi(cptr[i].dataptr, isa_page_to_bus(sg_page(sg))
 								+ sg->offset);
 			any2scsi(cptr[i].datalen, sg->length);
@@ -573,7 +573,7 @@ static int aha1542_queuecommand_lck(Scsi_Cmnd * SCpnt, void (*done) (Scsi_Cmnd *
 #endif
 	} else {
 		ccb[mbo].op = 0;	/* SCSI Initiator Command */
-		SCpnt->host_scribble = NULL;
+		cmd->host_scribble = NULL;
 		any2scsi(ccb[mbo].datalen, 0);
 		any2scsi(ccb[mbo].dataptr, 0);
 	};
@@ -593,9 +593,9 @@ static int aha1542_queuecommand_lck(Scsi_Cmnd * SCpnt, void (*done) (Scsi_Cmnd *
 
 	if (done) {
 		DEB(printk("aha1542_queuecommand: now waiting for interrupt "));
-		SCpnt->scsi_done = done;
+		cmd->scsi_done = done;
 		mb[mbo].status = 1;
-		aha1542_outb(SCpnt->device->host->io_port, CMD_START_SCSI);
+		aha1542_outb(cmd->device->host->io_port, CMD_START_SCSI);
 	} else
 		printk("aha1542_queuecommand: done can't be NULL\n");
 
@@ -908,13 +908,13 @@ static int aha1542_release(struct Scsi_Host *shost)
  * This is a device reset.  This is handled by sending a special command
  * to the device.
  */
-static int aha1542_dev_reset(Scsi_Cmnd * SCpnt)
+static int aha1542_dev_reset(struct scsi_cmnd *cmd)
 {
-	struct aha1542_hostdata *aha1542 = shost_priv(SCpnt->device->host);
+	struct aha1542_hostdata *aha1542 = shost_priv(cmd->device->host);
 	unsigned long flags;
 	struct mailbox *mb = aha1542->mb;
-	u8 target = SCpnt->device->id;
-	u8 lun = SCpnt->device->lun;
+	u8 target = cmd->device->id;
+	u8 lun = cmd->device->lun;
 	int mbo;
 	struct ccb *ccb = aha1542->ccb;
 
@@ -924,17 +924,17 @@ static int aha1542_dev_reset(Scsi_Cmnd * SCpnt)
 		mbo = 0;
 
 	do {
-		if (mb[mbo].status == 0 && aha1542->SCint[mbo] == NULL)
+		if (mb[mbo].status == 0 && aha1542->int_cmds[mbo] == NULL)
 			break;
 		mbo++;
 		if (mbo >= AHA1542_MAILBOXES)
 			mbo = 0;
 	} while (mbo != aha1542->aha1542_last_mbo_used);
 
-	if (mb[mbo].status || aha1542->SCint[mbo])
+	if (mb[mbo].status || aha1542->int_cmds[mbo])
 		panic("Unable to find empty mailbox for aha1542.\n");
 
-	aha1542->SCint[mbo] = SCpnt;	/* This will effectively
+	aha1542->int_cmds[mbo] = cmd;	/* This will effectively
 					   prevent someone else from
 					   screwing with this cdb. */
 
@@ -956,17 +956,17 @@ static int aha1542_dev_reset(Scsi_Cmnd * SCpnt)
 	 * Now tell the 1542 to flush all pending commands for this 
 	 * target 
 	 */
-	aha1542_outb(SCpnt->device->host->io_port, CMD_START_SCSI);
+	aha1542_outb(cmd->device->host->io_port, CMD_START_SCSI);
 
-	scmd_printk(KERN_WARNING, SCpnt,
+	scmd_printk(KERN_WARNING, cmd,
 		"Trying device reset for target\n");
 
 	return SUCCESS;
 }
 
-static int aha1542_reset(Scsi_Cmnd *SCpnt, u8 reset_cmd)
+static int aha1542_reset(struct scsi_cmnd *cmd, u8 reset_cmd)
 {
-	struct aha1542_hostdata *aha1542 = shost_priv(SCpnt->device->host);
+	struct aha1542_hostdata *aha1542 = shost_priv(cmd->device->host);
 	int i;
 
 	/* 
@@ -975,7 +975,7 @@ static int aha1542_reset(Scsi_Cmnd *SCpnt, u8 reset_cmd)
 	 * we do this?  Try this first, and we can add that later
 	 * if it turns out to be useful.
 	 */
-	outb(reset_cmd, CONTROL(SCpnt->device->host->io_port));
+	outb(reset_cmd, CONTROL(cmd->device->host->io_port));
 
 	/*
 	 * Wait for the thing to settle down a bit.  Unfortunately
@@ -985,11 +985,11 @@ static int aha1542_reset(Scsi_Cmnd *SCpnt, u8 reset_cmd)
 	 * we are pretty desperate anyways.
 	 */
 	ssleep(4);
-	spin_lock_irq(SCpnt->device->host->host_lock);
+	spin_lock_irq(cmd->device->host->host_lock);
 
-	if (!wait_mask(STATUS(SCpnt->device->host->io_port),
+	if (!wait_mask(STATUS(cmd->device->host->io_port),
 	     STATMASK, INIT | IDLE, STST | DIAGF | INVDCMD | DF | CDF, 0)) {
-		spin_unlock_irq(SCpnt->device->host->host_lock);
+		spin_unlock_irq(cmd->device->host->host_lock);
 		return FAILED;
 	}
 	/*
@@ -997,21 +997,21 @@ static int aha1542_reset(Scsi_Cmnd *SCpnt, u8 reset_cmd)
 	 * us again after host reset.
 	 */
 	if (reset_cmd & HRST)
-		setup_mailboxes(SCpnt->device->host->io_port, SCpnt->device->host);
+		setup_mailboxes(cmd->device->host->io_port, cmd->device->host);
 	/*
 	 * Now try to pick up the pieces.  For all pending commands,
 	 * free any internal data structures, and basically clear things
 	 * out.  We do not try and restart any commands or anything - 
 	 * the strategy handler takes care of that crap.
 	 */
-	printk(KERN_WARNING "Sent BUS RESET to scsi host %d\n", SCpnt->device->host->host_no);
+	printk(KERN_WARNING "Sent BUS RESET to scsi host %d\n", cmd->device->host->host_no);
 
 	for (i = 0; i < AHA1542_MAILBOXES; i++) {
-		if (aha1542->SCint[i] != NULL) {
-			Scsi_Cmnd *SCtmp;
-			SCtmp = aha1542->SCint[i];
+		if (aha1542->int_cmds[i] != NULL) {
+			struct scsi_cmnd *tmp_cmd;
+			tmp_cmd = aha1542->int_cmds[i];
 
-			if (SCtmp->device->soft_reset) {
+			if (tmp_cmd->device->soft_reset) {
 				/*
 				 * If this device implements the soft reset option,
 				 * then it is still holding onto the command, and
@@ -1020,25 +1020,25 @@ static int aha1542_reset(Scsi_Cmnd *SCpnt, u8 reset_cmd)
 				 */
 				continue;
 			}
-			kfree(SCtmp->host_scribble);
-			SCtmp->host_scribble = NULL;
-			aha1542->SCint[i] = NULL;
+			kfree(tmp_cmd->host_scribble);
+			tmp_cmd->host_scribble = NULL;
+			aha1542->int_cmds[i] = NULL;
 			aha1542->mb[i].status = 0;
 		}
 	}
 
-	spin_unlock_irq(SCpnt->device->host->host_lock);
+	spin_unlock_irq(cmd->device->host->host_lock);
 	return SUCCESS;
 }
 
-static int aha1542_bus_reset(Scsi_Cmnd *SCpnt)
+static int aha1542_bus_reset(struct scsi_cmnd *cmd)
 {
-	return aha1542_reset(SCpnt, SCRST);
+	return aha1542_reset(cmd, SCRST);
 }
 
-static int aha1542_host_reset(Scsi_Cmnd *SCpnt)
+static int aha1542_host_reset(struct scsi_cmnd *cmd)
 {
-	return aha1542_reset(SCpnt, HRST | SCRST);
+	return aha1542_reset(cmd, HRST | SCRST);
 }
 
 static int aha1542_biosparam(struct scsi_device *sdev,

commit cad2fc72cfc092ed3448a0235f59fe003f4f85c3
Author: Ondrej Zary <linux@rainbow-software.org>
Date:   Fri Feb 6 23:11:43 2015 +0100

    aha1542: clean up cmd variables
    
    Make sure that there's no variable named cmd
    
    Signed-off-by: Ondrej Zary <linux@rainbow-software.org>
    Reviewed-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: James Bottomley <JBottomley@Odin.com>

diff --git a/drivers/scsi/aha1542.c b/drivers/scsi/aha1542.c
index 161586545804..dbe46591a5e2 100644
--- a/drivers/scsi/aha1542.c
+++ b/drivers/scsi/aha1542.c
@@ -124,7 +124,7 @@ static inline bool wait_mask(u16 port, u8 mask, u8 allof, u8 noneof, int timeout
    routine does not send something out while we are in the middle of this.
    Fortunately, it is only at boot time that multi-byte messages
    are ever sent. */
-static int aha1542_outb(unsigned int base, u8 cmd)
+static int aha1542_outb(unsigned int base, u8 val)
 {
 	unsigned long flags;
 
@@ -138,13 +138,13 @@ static int aha1542_outb(unsigned int base, u8 cmd)
 			spin_unlock_irqrestore(&aha1542_lock, flags);
 			continue;
 		}
-		outb(cmd, DATA(base));
+		outb(val, DATA(base));
 		spin_unlock_irqrestore(&aha1542_lock, flags);
 		return 0;
 	}
 }
 
-static int aha1542_out(unsigned int base, u8 *cmdp, int len)
+static int aha1542_out(unsigned int base, u8 *buf, int len)
 {
 	unsigned long flags;
 
@@ -155,7 +155,7 @@ static int aha1542_out(unsigned int base, u8 *cmdp, int len)
 			printk(KERN_ERR "aha1542_out failed(%d): ", len + 1);
 			return 1;
 		}
-		outb(*cmdp++, DATA(base));
+		outb(*buf++, DATA(base));
 	}
 	spin_unlock_irqrestore(&aha1542_lock, flags);
 	if (!wait_mask(INTRFLAGS(base), INTRMASK, HACC, 0, 0))
@@ -167,7 +167,7 @@ static int aha1542_out(unsigned int base, u8 *cmdp, int len)
 /* Only used at boot time, so we do not need to worry about latency as much
    here */
 
-static int aha1542_in(unsigned int base, u8 *cmdp, int len, int timeout)
+static int aha1542_in(unsigned int base, u8 *buf, int len, int timeout)
 {
 	unsigned long flags;
 
@@ -179,7 +179,7 @@ static int aha1542_in(unsigned int base, u8 *cmdp, int len, int timeout)
 				printk(KERN_ERR "aha1542_in failed(%d): ", len + 1);
 			return 1;
 		}
-		*cmdp++ = inb(DATA(base));
+		*buf++ = inb(DATA(base));
 	}
 	spin_unlock_irqrestore(&aha1542_lock, flags);
 	return 0;
@@ -244,8 +244,7 @@ static int makecode(unsigned hosterr, unsigned scsierr)
 static int aha1542_test_port(int bse, struct Scsi_Host *shpnt)
 {
 	u8 inquiry_result[4];
-	u8 *cmdp;
-	int len;
+	int i;
 
 	/* Quick and dirty test for presence of the card. */
 	if (inb(STATUS(bse)) == 0xff)
@@ -273,13 +272,10 @@ static int aha1542_test_port(int bse, struct Scsi_Host *shpnt)
 
 	aha1542_outb(bse, CMD_INQUIRY);
 
-	len = 4;
-	cmdp = &inquiry_result[0];
-
-	while (len--) {
+	for (i = 0; i < 4; i++) {
 		if (!wait_mask(STATUS(bse), DF, DF, 0, 0))
 			return 0;
-		*cmdp++ = inb(DATA(bse));
+		inquiry_result[i] = inb(DATA(bse));
 	}
 
 	/* Reading port should reset DF */
@@ -463,7 +459,6 @@ static int aha1542_queuecommand_lck(Scsi_Cmnd * SCpnt, void (*done) (Scsi_Cmnd *
 {
 	struct aha1542_hostdata *aha1542 = shost_priv(SCpnt->device->host);
 	u8 direction;
-	u8 *cmd = (u8 *) SCpnt->cmnd;
 	u8 target = SCpnt->device->id;
 	u8 lun = SCpnt->device->lun;
 	unsigned long flags;
@@ -480,28 +475,28 @@ static int aha1542_queuecommand_lck(Scsi_Cmnd * SCpnt, void (*done) (Scsi_Cmnd *
 	    }
 	);
 
-	if (*cmd == REQUEST_SENSE) {
+	if (*SCpnt->cmnd == REQUEST_SENSE) {
 		/* Don't do the command - we have the sense data already */
 		SCpnt->result = 0;
 		done(SCpnt);
 		return 0;
 	}
 #ifdef DEBUG
-	if (*cmd == READ_10 || *cmd == WRITE_10)
-		i = xscsi2int(cmd + 2);
-	else if (*cmd == READ_6 || *cmd == WRITE_6)
-		i = scsi2int(cmd + 2);
+	if (*SCpnt->cmnd == READ_10 || *SCpnt->cmnd == WRITE_10)
+		i = xscsi2int(SCpnt->cmnd + 2);
+	else if (*SCpnt->cmnd == READ_6 || *SCpnt->cmnd == WRITE_6)
+		i = scsi2int(SCpnt->cmnd + 2);
 	else
 		i = -1;
 	if (done)
-		printk(KERN_DEBUG "aha1542_queuecommand: dev %d cmd %02x pos %d len %d ", target, *cmd, i, bufflen);
+		printk(KERN_DEBUG "aha1542_queuecommand: dev %d cmd %02x pos %d len %d ", target, *SCpnt->cmnd, i, bufflen);
 	else
-		printk(KERN_DEBUG "aha1542_command: dev %d cmd %02x pos %d len %d ", target, *cmd, i, bufflen);
+		printk(KERN_DEBUG "aha1542_command: dev %d cmd %02x pos %d len %d ", target, *SCpnt->cmnd, i, bufflen);
 	printk(KERN_DEBUG "aha1542_queuecommand: dumping scsi cmd:");
 	for (i = 0; i < SCpnt->cmd_len; i++)
-		printk("%02x ", cmd[i]);
+		printk("%02x ", SCpnt->cmnd[i]);
 	printk("\n");
-	if (*cmd == WRITE_10 || *cmd == WRITE_6)
+	if (*SCpnt->cmnd == WRITE_10 || *SCpnt->cmnd == WRITE_6)
 		return 0;	/* we are still testing, so *don't* write */
 #endif
 	/* Use the outgoing mailboxes in a round-robin fashion, because this
@@ -540,12 +535,12 @@ static int aha1542_queuecommand_lck(Scsi_Cmnd * SCpnt, void (*done) (Scsi_Cmnd *
 	ccb[mbo].cdblen = SCpnt->cmd_len;
 
 	direction = 0;
-	if (*cmd == READ_10 || *cmd == READ_6)
+	if (*SCpnt->cmnd == READ_10 || *SCpnt->cmnd == READ_6)
 		direction = 8;
-	else if (*cmd == WRITE_10 || *cmd == WRITE_6)
+	else if (*SCpnt->cmnd == WRITE_10 || *SCpnt->cmnd == WRITE_6)
 		direction = 16;
 
-	memcpy(ccb[mbo].cdb, cmd, ccb[mbo].cdblen);
+	memcpy(ccb[mbo].cdb, SCpnt->cmnd, ccb[mbo].cdblen);
 
 	if (bufflen) {
 		struct scatterlist *sg;
@@ -617,15 +612,15 @@ static void setup_mailboxes(int bse, struct Scsi_Host *shpnt)
 	struct mailbox *mb = aha1542->mb;
 	struct ccb *ccb = aha1542->ccb;
 
-	u8 cmd[5] = { CMD_MBINIT, AHA1542_MAILBOXES, 0, 0, 0};
+	u8 mb_cmd[5] = { CMD_MBINIT, AHA1542_MAILBOXES, 0, 0, 0};
 
 	for (i = 0; i < AHA1542_MAILBOXES; i++) {
 		mb[i].status = mb[AHA1542_MAILBOXES + i].status = 0;
 		any2scsi(mb[i].ccbptr, isa_virt_to_bus(&ccb[i]));
 	};
 	aha1542_intr_reset(bse);	/* reset interrupts, so they don't block */
-	any2scsi((cmd + 2), isa_virt_to_bus(mb));
-	if (aha1542_out(bse, cmd, 5))
+	any2scsi((mb_cmd + 2), isa_virt_to_bus(mb));
+	if (aha1542_out(bse, mb_cmd, 5))
 		printk(KERN_ERR "aha1542_detect: failed setting up mailboxes\n");
 	aha1542_intr_reset(bse);
 }

commit 17787a09fdfcb07ccc361758737af0dfa1ea4214
Author: Ondrej Zary <linux@rainbow-software.org>
Date:   Fri Feb 6 23:11:42 2015 +0100

    aha1542: Simplify aha1542_biosparam
    
    Simplify aha1542_biosparam, use sector_div, remove unused BIOS_TRANSLATION_1632.
    
    Signed-off-by: Ondrej Zary <linux@rainbow-software.org>
    Reviewed-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: James Bottomley <JBottomley@Odin.com>

diff --git a/drivers/scsi/aha1542.c b/drivers/scsi/aha1542.c
index d15191324b06..161586545804 100644
--- a/drivers/scsi/aha1542.c
+++ b/drivers/scsi/aha1542.c
@@ -78,7 +78,6 @@ static int dma_speed[MAXBOARDS] = { -1, -1, -1, -1 };
 module_param_array(dma_speed, int, NULL, 0);
 MODULE_PARM_DESC(dma_speed, "DMA speed [MB/s] (5,6,7,8,10, default=-1 [by jumper])");
 
-#define BIOS_TRANSLATION_1632 0	/* Used by some old 1542A boards */
 #define BIOS_TRANSLATION_6432 1	/* Default case these days */
 #define BIOS_TRANSLATION_25563 2	/* Big disk case */
 
@@ -1048,24 +1047,20 @@ static int aha1542_host_reset(Scsi_Cmnd *SCpnt)
 }
 
 static int aha1542_biosparam(struct scsi_device *sdev,
-		struct block_device *bdev, sector_t capacity, int *ip)
+		struct block_device *bdev, sector_t capacity, int geom[])
 {
 	struct aha1542_hostdata *aha1542 = shost_priv(sdev->host);
-	int translation_algorithm;
-	int size = capacity;
 
-	translation_algorithm = aha1542->bios_translation;
-
-	if ((size >> 11) > 1024 && translation_algorithm == BIOS_TRANSLATION_25563) {
+	if (capacity >= 0x200000 &&
+			aha1542->bios_translation == BIOS_TRANSLATION_25563) {
 		/* Please verify that this is the same as what DOS returns */
-		ip[0] = 255;
-		ip[1] = 63;
-		ip[2] = size / 255 / 63;
+		geom[0] = 255;	/* heads */
+		geom[1] = 63;	/* sectors */
 	} else {
-		ip[0] = 64;
-		ip[1] = 32;
-		ip[2] = size >> 11;
+		geom[0] = 64;	/* heads */
+		geom[1] = 32;	/* sectors */
 	}
+	geom[2] = sector_div(capacity, geom[0] * geom[1]);	/* cylinders */
 
 	return 0;
 }

commit f71429ab535d90806a35bc346adcdebfc8996008
Author: Ondrej Zary <linux@rainbow-software.org>
Date:   Fri Feb 6 23:11:41 2015 +0100

    aha1542: rework configuration parameters
    
    Remove __setup and introduce separate io, bus_on, bus_off and dma_speed
    module parameters.
    
    Signed-off-by: Ondrej Zary <linux@rainbow-software.org>
    Reviewed-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: James Bottomley <JBottomley@Odin.com>

diff --git a/drivers/scsi/aha1542.c b/drivers/scsi/aha1542.c
index 8c915d721ce0..d15191324b06 100644
--- a/drivers/scsi/aha1542.c
+++ b/drivers/scsi/aha1542.c
@@ -53,56 +53,30 @@
 #else
 #define DEB(x)
 #endif
+#define MAXBOARDS 4
 
-/*
-   static const char RCSid[] = "$Header: /usr/src/linux/kernel/blk_drv/scsi/RCS/aha1542.c,v 1.1 1992/07/24 06:27:38 root Exp root $";
- */
-
-/* The adaptec can be configured for quite a number of addresses, but
-   I generally do not want the card poking around at random.  We allow
-   two addresses - this allows people to use the Adaptec with a Midi
-   card, which also used 0x330 -- can be overridden with LILO! */
-
-#define MAXBOARDS 4		/* Increase this and the sizes of the
-				   arrays below, if you need more.. */
-
-/* Boards 3,4 slots are reserved for ISAPnP scans */
-
-static unsigned int bases[MAXBOARDS] = {0x330, 0x334, 0, 0};
+static bool isapnp = 1;
+module_param(isapnp, bool, 0);
+MODULE_PARM_DESC(isapnp, "enable PnP support (default=1)");
 
-/* set by aha1542_setup according to the command line; they also may
-   be marked __initdata, but require zero initializers then */
+static int io[MAXBOARDS] = { 0x330, 0x334, 0, 0 };
+module_param_array(io, int, NULL, 0);
+MODULE_PARM_DESC(io, "base IO address of controller (0x130,0x134,0x230,0x234,0x330,0x334, default=0x330,0x334)");
 
-static int setup_called[MAXBOARDS];
-static int setup_buson[MAXBOARDS];
-static int setup_busoff[MAXBOARDS];
-static int setup_dmaspeed[MAXBOARDS] = { -1, -1, -1, -1 };
+/* time AHA spends on the AT-bus during data transfer */
+static int bus_on[MAXBOARDS] = { -1, -1, -1, -1 }; /* power-on default: 11us */
+module_param_array(bus_on, int, NULL, 0);
+MODULE_PARM_DESC(bus_on, "bus on time [us] (2-15, default=-1 [HW default: 11])");
 
-/*
- * LILO/Module params:  aha1542=<PORTBASE>[,<BUSON>,<BUSOFF>[,<DMASPEED>]]
- *
- * Where:  <PORTBASE> is any of the valid AHA addresses:
- *                      0x130, 0x134, 0x230, 0x234, 0x330, 0x334
- *         <BUSON>  is the time (in microsecs) that AHA spends on the AT-bus
- *                  when transferring data.  1542A power-on default is 11us,
- *                  valid values are in range: 2..15 (decimal)
- *         <BUSOFF> is the time that AHA spends OFF THE BUS after while
- *                  it is transferring data (not to monopolize the bus).
- *                  Power-on default is 4us, valid range: 1..64 microseconds.
- *         <DMASPEED> Default is jumper selected (1542A: on the J1),
- *                  but experimenter can alter it with this.
- *                  Valid values: 5, 6, 7, 8, 10 (MB/s)
- *                  Factory default is 5 MB/s.
- */
+/* time AHA spends off the bus (not to monopolize it) during data transfer  */
+static int bus_off[MAXBOARDS] = { -1, -1, -1, -1 }; /* power-on default: 4us */
+module_param_array(bus_off, int, NULL, 0);
+MODULE_PARM_DESC(bus_off, "bus off time [us] (1-64, default=-1 [HW default: 4])");
 
-#if defined(MODULE)
-static bool isapnp = 0;
-static int aha1542[] = {0x330, 11, 4, -1};
-module_param_array(aha1542, int, NULL, 0);
-module_param(isapnp, bool, 0);
-#else
-static int isapnp = 1;
-#endif
+/* default is jumper selected (J1 on 1542A), factory default = 5 MB/s */
+static int dma_speed[MAXBOARDS] = { -1, -1, -1, -1 };
+module_param_array(dma_speed, int, NULL, 0);
+MODULE_PARM_DESC(dma_speed, "DMA speed [MB/s] (5,6,7,8,10, default=-1 [by jumper])");
 
 #define BIOS_TRANSLATION_1632 0	/* Used by some old 1542A boards */
 #define BIOS_TRANSLATION_6432 1	/* Default case these days */
@@ -792,101 +766,48 @@ static int aha1542_query(int base_io, int *transl)
 	return 0;
 }
 
-#ifndef MODULE
-static char *setup_str[MAXBOARDS] __initdata;
-static int setup_idx = 0;
-
-static void __init aha1542_setup(char *str, int *ints)
+static u8 dma_speed_hw(int dma_speed)
 {
-	const char *ahausage = "aha1542: usage: aha1542=<PORTBASE>[,<BUSON>,<BUSOFF>[,<DMASPEED>]]\n";
-	int setup_portbase;
-
-	if (setup_idx >= MAXBOARDS) {
-		printk(KERN_ERR "aha1542: aha1542_setup called too many times! Bad LILO params ?\n");
-		printk(KERN_ERR "   Entryline 1: %s\n", setup_str[0]);
-		printk(KERN_ERR "   Entryline 2: %s\n", setup_str[1]);
-		printk(KERN_ERR "   This line:   %s\n", str);
-		return;
-	}
-	if (ints[0] < 1 || ints[0] > 4) {
-		printk(KERN_ERR "aha1542: %s\n", str);
-		printk(ahausage);
-		printk(KERN_ERR "aha1542: Wrong parameters may cause system malfunction.. We try anyway..\n");
-	}
-	setup_called[setup_idx] = ints[0];
-	setup_str[setup_idx] = str;
-
-	setup_portbase = ints[0] >= 1 ? ints[1] : 0;	/* Preserve the default value.. */
-	setup_buson[setup_idx] = ints[0] >= 2 ? ints[2] : 7;
-	setup_busoff[setup_idx] = ints[0] >= 3 ? ints[3] : 5;
-	if (ints[0] >= 4) 
-	{
-		int atbt = -1;
-		switch (ints[4]) {
-		case 5:
-			atbt = 0x00;
-			break;
-		case 6:
-			atbt = 0x04;
-			break;
-		case 7:
-			atbt = 0x01;
-			break;
-		case 8:
-			atbt = 0x02;
-			break;
-		case 10:
-			atbt = 0x03;
-			break;
-		default:
-			printk(KERN_ERR "aha1542: %s\n", str);
-			printk(ahausage);
-			printk(KERN_ERR "aha1542: Valid values for DMASPEED are 5-8, 10 MB/s.  Using jumper defaults.\n");
-			break;
-		}
-		setup_dmaspeed[setup_idx] = atbt;
+	switch (dma_speed) {
+	case 5:
+		return 0x00;
+	case 6:
+		return 0x04;
+	case 7:
+		return 0x01;
+	case 8:
+		return 0x02;
+	case 10:
+		return 0x03;
 	}
-	if (setup_portbase != 0)
-		bases[setup_idx] = setup_portbase;
 
-	++setup_idx;
+	return 0xff;	/* invalid */
 }
 
-static int __init do_setup(char *str)
+/* Set the Bus on/off-times as not to ruin floppy performance */
+static void aha1542_set_bus_times(int indx)
 {
-	int ints[5];
+	unsigned int base_io = io[indx];
 
-	int count=setup_idx;
+	if (bus_on[indx] > 0) {
+		u8 oncmd[] = { CMD_BUSON_TIME, clamp(bus_on[indx], 2, 15) };
 
-	get_options(str, ARRAY_SIZE(ints), ints);
-	aha1542_setup(str,ints);
+		aha1542_intr_reset(base_io);
+		if (aha1542_out(base_io, oncmd, 2))
+			goto fail;
+	}
 
-	return count<setup_idx;
-}
+	if (bus_off[indx] > 0) {
+		u8 offcmd[] = { CMD_BUSOFF_TIME, clamp(bus_off[indx], 1, 64) };
 
-__setup("aha1542=",do_setup);
-#endif
+		aha1542_intr_reset(base_io);
+		if (aha1542_out(base_io, offcmd, 2))
+			goto fail;
+	}
 
-/* Set the Bus on/off-times as not to ruin floppy performance */
-static void aha1542_set_bus_times(int indx)
-{
-	unsigned int base_io = bases[indx];
-	u8 oncmd[] = {CMD_BUSON_TIME, 7};
-	u8 offcmd[] = {CMD_BUSOFF_TIME, 5};
+	if (dma_speed_hw(dma_speed[indx]) != 0xff) {
+		u8 dmacmd[] = { CMD_DMASPEED, dma_speed_hw(dma_speed[indx]) };
 
-	if (setup_called[indx]) {
-		oncmd[1] = setup_buson[indx];
-		offcmd[1] = setup_busoff[indx];
-	}
-	aha1542_intr_reset(base_io);
-	if (aha1542_out(base_io, oncmd, 2))
-		goto fail;
-	aha1542_intr_reset(base_io);
-	if (aha1542_out(base_io, offcmd, 2))
-		goto fail;
-	if (setup_dmaspeed[indx] >= 0) {
-		u8 dmacmd[] = {CMD_DMASPEED, 0};
-		dmacmd[1] = setup_dmaspeed[indx];
 		aha1542_intr_reset(base_io);
 		if (aha1542_out(base_io, dmacmd, 2))
 			goto fail;
@@ -901,7 +822,7 @@ static void aha1542_set_bus_times(int indx)
 /* return non-zero on detection */
 static struct Scsi_Host *aha1542_hw_init(struct scsi_host_template *tpnt, struct device *pdev, int indx)
 {
-	unsigned int base_io = bases[indx];
+	unsigned int base_io = io[indx];
 	struct Scsi_Host *shpnt;
 	struct aha1542_hostdata *aha1542;
 
@@ -1207,19 +1128,19 @@ static int aha1542_pnp_probe(struct pnp_dev *pdev, const struct pnp_device_id *i
 	int indx;
 	struct Scsi_Host *sh;
 
-	for (indx = 0; indx < ARRAY_SIZE(bases); indx++) {
-		if (bases[indx])
+	for (indx = 0; indx < ARRAY_SIZE(io); indx++) {
+		if (io[indx])
 			continue;
 
 		if (pnp_activate_dev(pdev) < 0)
 			continue;
 
-		bases[indx] = pnp_port_start(pdev, 0);
+		io[indx] = pnp_port_start(pdev, 0);
 
 		/* The card can be queried for its DMA, we have
 		   the DMA set up that is enough */
 
-		printk(KERN_INFO "ISAPnP found an AHA1535 at I/O 0x%03X\n", bases[indx]);
+		printk(KERN_INFO "ISAPnP found an AHA1535 at I/O 0x%03X\n", io[indx]);
 	}
 
 	sh = aha1542_hw_init(&driver_template, &pdev->dev, indx);
@@ -1248,32 +1169,6 @@ static int pnp_registered;
 static int __init aha1542_init(void)
 {
 	int ret = 0;
-#ifdef MODULE
-	int atbt = -1;
-
-	bases[0] = aha1542[0];
-	setup_buson[0] = aha1542[1];
-	setup_busoff[0] = aha1542[2];
-
-	switch (aha1542[3]) {
-	case 5:
-		atbt = 0x00;
-		break;
-	case 6:
-		atbt = 0x04;
-		break;
-	case 7:
-		atbt = 0x01;
-		break;
-	case 8:
-		atbt = 0x02;
-		break;
-	case 10:
-		atbt = 0x03;
-		break;
-	};
-	setup_dmaspeed[0] = atbt;
-#endif
 
 #ifdef CONFIG_PNP
 	if (isapnp) {

commit 3a70c006edbe6071bd78e1e0c8004791cd4b531c
Author: Ondrej Zary <linux@rainbow-software.org>
Date:   Fri Feb 6 23:11:40 2015 +0100

    aha1542: rework hw_init
    
    Cleanup hw_init, use goto for error handling.
    
    Signed-off-by: Ondrej Zary <linux@rainbow-software.org>
    Reviewed-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: James Bottomley <JBottomley@Odin.com>

diff --git a/drivers/scsi/aha1542.c b/drivers/scsi/aha1542.c
index 4849d02661d8..8c915d721ce0 100644
--- a/drivers/scsi/aha1542.c
+++ b/drivers/scsi/aha1542.c
@@ -657,7 +657,7 @@ static void setup_mailboxes(int bse, struct Scsi_Host *shpnt)
 	aha1542_intr_reset(bse);
 }
 
-static int aha1542_getconfig(int base_io, unsigned char *irq_level, unsigned char *dma_chan, unsigned char *scsi_id)
+static int aha1542_getconfig(int base_io, unsigned int *irq_level, unsigned char *dma_chan, unsigned int *scsi_id)
 {
 	u8 inquiry_result[3];
 	int i;
@@ -901,99 +901,76 @@ static void aha1542_set_bus_times(int indx)
 /* return non-zero on detection */
 static struct Scsi_Host *aha1542_hw_init(struct scsi_host_template *tpnt, struct device *pdev, int indx)
 {
-	unsigned char dma_chan;
-	unsigned char irq_level;
-	unsigned char scsi_id;
-	unsigned long flags;
-	unsigned int base_io;
-	int trans;
-	struct Scsi_Host *shpnt = NULL;
+	unsigned int base_io = bases[indx];
+	struct Scsi_Host *shpnt;
 	struct aha1542_hostdata *aha1542;
 
-	DEB(printk("aha1542_detect: \n"));
-
-	tpnt->proc_name = "aha1542";
-
-		if (bases[indx] != 0 && request_region(bases[indx], 4, "aha1542")) {
-			shpnt = scsi_host_alloc(tpnt,
-					sizeof(struct aha1542_hostdata));
-
-			if(shpnt==NULL) {
-				release_region(bases[indx], 4);
-				return NULL;
-			}
-			aha1542 = shost_priv(shpnt);
-			if (!aha1542_test_port(bases[indx], shpnt))
-				goto unregister;
+	if (base_io == 0)
+		return NULL;
 
-			base_io = bases[indx];
+	if (!request_region(base_io, AHA1542_REGION_SIZE, "aha1542"))
+		return NULL;
 
-			aha1542_set_bus_times(indx);
+	shpnt = scsi_host_alloc(tpnt, sizeof(struct aha1542_hostdata));
+	if (!shpnt)
+		goto release;
+	aha1542 = shost_priv(shpnt);
 
-			if (aha1542_query(base_io, &trans))
-				goto unregister;
+	if (!aha1542_test_port(base_io, shpnt))
+		goto unregister;
 
-			if (aha1542_getconfig(base_io, &irq_level, &dma_chan, &scsi_id) == -1)
-				goto unregister;
+	aha1542_set_bus_times(indx);
+	if (aha1542_query(base_io, &aha1542->bios_translation))
+		goto unregister;
+	if (aha1542_getconfig(base_io, &shpnt->irq, &shpnt->dma_channel, &shpnt->this_id) == -1)
+		goto unregister;
 
-			printk(KERN_INFO "Configuring Adaptec (SCSI-ID %d) at IO:%x, IRQ %d", scsi_id, base_io, irq_level);
-			if (dma_chan != 0xFF)
-				printk(", DMA priority %d", dma_chan);
-			printk("\n");
+	printk(KERN_INFO "Adaptec AHA-1542 (SCSI-ID %d) at IO 0x%x, IRQ %d", shpnt->this_id, base_io, shpnt->irq);
+	if (shpnt->dma_channel != 0xFF)
+		printk(", DMA %d", shpnt->dma_channel);
+	printk("\n");
+	if (aha1542->bios_translation == BIOS_TRANSLATION_25563)
+		printk(KERN_INFO "aha1542.c: Using extended bios translation\n");
 
-			setup_mailboxes(base_io, shpnt);
+	setup_mailboxes(base_io, shpnt);
 
-			DEB(printk("aha1542_detect: enable interrupt channel %d\n", irq_level));
-			spin_lock_irqsave(&aha1542_lock, flags);
-			if (request_irq(irq_level, do_aha1542_intr_handle, 0,
+	if (request_irq(shpnt->irq, do_aha1542_intr_handle, 0,
 					"aha1542", shpnt)) {
-				printk(KERN_ERR "Unable to allocate IRQ for adaptec controller.\n");
-				spin_unlock_irqrestore(&aha1542_lock, flags);
-				goto unregister;
-			}
-			if (dma_chan != 0xFF) {
-				if (request_dma(dma_chan, "aha1542")) {
-					printk(KERN_ERR "Unable to allocate DMA channel for Adaptec.\n");
-					free_irq(irq_level, shpnt);
-					spin_unlock_irqrestore(&aha1542_lock, flags);
-					goto unregister;
-				}
-				if (dma_chan == 0 || dma_chan >= 5) {
-					set_dma_mode(dma_chan, DMA_MODE_CASCADE);
-					enable_dma(dma_chan);
-				}
-			}
+		printk(KERN_ERR "Unable to allocate IRQ for adaptec controller.\n");
+		goto unregister;
+	}
+	if (shpnt->dma_channel != 0xFF) {
+		if (request_dma(shpnt->dma_channel, "aha1542")) {
+			printk(KERN_ERR "Unable to allocate DMA channel for Adaptec.\n");
+			goto free_irq;
+		}
+		if (shpnt->dma_channel == 0 || shpnt->dma_channel >= 5) {
+			set_dma_mode(shpnt->dma_channel, DMA_MODE_CASCADE);
+			enable_dma(shpnt->dma_channel);
+		}
+	}
 
-			shpnt->this_id = scsi_id;
-			shpnt->unique_id = base_io;
-			shpnt->io_port = base_io;
-			shpnt->n_io_port = 4;	/* Number of bytes of I/O space used */
-			shpnt->dma_channel = dma_chan;
-			shpnt->irq = irq_level;
-			aha1542->bios_translation = trans;
-			if (trans == BIOS_TRANSLATION_25563)
-				printk(KERN_INFO "aha1542.c: Using extended bios translation\n");
-			aha1542->aha1542_last_mbi_used = (2 * AHA1542_MAILBOXES - 1);
-			aha1542->aha1542_last_mbo_used = (AHA1542_MAILBOXES - 1);
-			memset(aha1542->SCint, 0, sizeof(aha1542->SCint));
-			spin_unlock_irqrestore(&aha1542_lock, flags);
+	shpnt->unique_id = base_io;
+	shpnt->io_port = base_io;
+	shpnt->n_io_port = AHA1542_REGION_SIZE;
+	aha1542->aha1542_last_mbi_used = 2 * AHA1542_MAILBOXES - 1;
+	aha1542->aha1542_last_mbo_used = AHA1542_MAILBOXES - 1;
 
-			if (scsi_add_host(shpnt, pdev)) {
-				if (shpnt->dma_channel != 0xff)
-					free_dma(shpnt->dma_channel);
-				free_irq(irq_level, shpnt);
-				goto unregister;
-			}
+	if (scsi_add_host(shpnt, pdev))
+		goto free_dma;
 
-			scsi_scan_host(shpnt);
+	scsi_scan_host(shpnt);
 
-			return shpnt;
+	return shpnt;
+free_dma:
+	if (shpnt->dma_channel != 0xff)
+		free_dma(shpnt->dma_channel);
+free_irq:
+	free_irq(shpnt->irq, shpnt);
 unregister:
-			release_region(bases[indx], 4);
-			scsi_host_put(shpnt);
-			return NULL;
-
-		};
+	scsi_host_put(shpnt);
+release:
+	release_region(base_io, AHA1542_REGION_SIZE);
 
 	return NULL;
 }
@@ -1001,10 +978,10 @@ static struct Scsi_Host *aha1542_hw_init(struct scsi_host_template *tpnt, struct
 static int aha1542_release(struct Scsi_Host *shost)
 {
 	scsi_remove_host(shost);
-	if (shost->irq)
-		free_irq(shost->irq, shost);
 	if (shost->dma_channel != 0xff)
 		free_dma(shost->dma_channel);
+	if (shost->irq)
+		free_irq(shost->irq, shost);
 	if (shost->io_port && shost->n_io_port)
 		release_region(shost->io_port, shost->n_io_port);
 	scsi_host_put(shost);

commit 23e6940a9ecfc6477fb1216cad062e2fa12ea98f
Author: Ondrej Zary <linux@rainbow-software.org>
Date:   Fri Feb 6 23:11:39 2015 +0100

    aha1542: Call wait_mask from aha1542_out
    
    aha1542_out call is always followed by wait_mask.
    Move the call into aha1542_out to simplify code.
    
    Signed-off-by: Ondrej Zary <linux@rainbow-software.org>
    Reviewed-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: James Bottomley <JBottomley@Odin.com>

diff --git a/drivers/scsi/aha1542.c b/drivers/scsi/aha1542.c
index b8e495243cf6..4849d02661d8 100644
--- a/drivers/scsi/aha1542.c
+++ b/drivers/scsi/aha1542.c
@@ -185,6 +185,8 @@ static int aha1542_out(unsigned int base, u8 *cmdp, int len)
 		outb(*cmdp++, DATA(base));
 	}
 	spin_unlock_irqrestore(&aha1542_lock, flags);
+	if (!wait_mask(INTRFLAGS(base), INTRMASK, HACC, 0, 0))
+		return 1;
 
 	return 0;
 }
@@ -650,8 +652,7 @@ static void setup_mailboxes(int bse, struct Scsi_Host *shpnt)
 	};
 	aha1542_intr_reset(bse);	/* reset interrupts, so they don't block */
 	any2scsi((cmd + 2), isa_virt_to_bus(mb));
-	aha1542_out(bse, cmd, 5);
-	if (!wait_mask(INTRFLAGS(bse), INTRMASK, HACC, 0, 0))
+	if (aha1542_out(bse, cmd, 5))
 		printk(KERN_ERR "aha1542_detect: failed setting up mailboxes\n");
 	aha1542_intr_reset(bse);
 }
@@ -744,8 +745,7 @@ static int aha1542_mbenable(int base)
 		if ((mbenable_result[0] & 0x08) && (mbenable_result[1] & 0x03))
 			retval = BIOS_TRANSLATION_25563;
 
-		aha1542_out(base, mbenable_cmd, 3);
-		if (!wait_mask(INTRFLAGS(base), INTRMASK, HACC, 0, 0))
+		if (aha1542_out(base, mbenable_cmd, 3))
 			goto fail;
 	};
 	while (0) {
@@ -879,19 +879,16 @@ static void aha1542_set_bus_times(int indx)
 		offcmd[1] = setup_busoff[indx];
 	}
 	aha1542_intr_reset(base_io);
-	aha1542_out(base_io, oncmd, 2);
-	if (!wait_mask(INTRFLAGS(base_io), INTRMASK, HACC, 0, 0))
+	if (aha1542_out(base_io, oncmd, 2))
 		goto fail;
 	aha1542_intr_reset(base_io);
-	aha1542_out(base_io, offcmd, 2);
-	if (!wait_mask(INTRFLAGS(base_io), INTRMASK, HACC, 0, 0))
+	if (aha1542_out(base_io, offcmd, 2))
 		goto fail;
 	if (setup_dmaspeed[indx] >= 0) {
 		u8 dmacmd[] = {CMD_DMASPEED, 0};
 		dmacmd[1] = setup_dmaspeed[indx];
 		aha1542_intr_reset(base_io);
-		aha1542_out(base_io, dmacmd, 2);
-		if (!wait_mask(INTRFLAGS(base_io), INTRMASK, HACC, 0, 0))
+		if (aha1542_out(base_io, dmacmd, 2))
 			goto fail;
 	}
 	aha1542_intr_reset(base_io);

commit b847fd0d85060fa213a14fa78b46e0ca5b09c5df
Author: Ondrej Zary <linux@rainbow-software.org>
Date:   Fri Feb 6 23:11:38 2015 +0100

    aha1542: split out code from aha1542_hw_init
    
    Split out bus times related block of aha1542_hw_init into separate function
    aha1542_set_bus_times.
    
    Signed-off-by: Ondrej Zary <linux@rainbow-software.org>
    Reviewed-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: James Bottomley <JBottomley@Odin.com>

diff --git a/drivers/scsi/aha1542.c b/drivers/scsi/aha1542.c
index 4bfba454a032..b8e495243cf6 100644
--- a/drivers/scsi/aha1542.c
+++ b/drivers/scsi/aha1542.c
@@ -867,6 +867,40 @@ static int __init do_setup(char *str)
 __setup("aha1542=",do_setup);
 #endif
 
+/* Set the Bus on/off-times as not to ruin floppy performance */
+static void aha1542_set_bus_times(int indx)
+{
+	unsigned int base_io = bases[indx];
+	u8 oncmd[] = {CMD_BUSON_TIME, 7};
+	u8 offcmd[] = {CMD_BUSOFF_TIME, 5};
+
+	if (setup_called[indx]) {
+		oncmd[1] = setup_buson[indx];
+		offcmd[1] = setup_busoff[indx];
+	}
+	aha1542_intr_reset(base_io);
+	aha1542_out(base_io, oncmd, 2);
+	if (!wait_mask(INTRFLAGS(base_io), INTRMASK, HACC, 0, 0))
+		goto fail;
+	aha1542_intr_reset(base_io);
+	aha1542_out(base_io, offcmd, 2);
+	if (!wait_mask(INTRFLAGS(base_io), INTRMASK, HACC, 0, 0))
+		goto fail;
+	if (setup_dmaspeed[indx] >= 0) {
+		u8 dmacmd[] = {CMD_DMASPEED, 0};
+		dmacmd[1] = setup_dmaspeed[indx];
+		aha1542_intr_reset(base_io);
+		aha1542_out(base_io, dmacmd, 2);
+		if (!wait_mask(INTRFLAGS(base_io), INTRMASK, HACC, 0, 0))
+			goto fail;
+	}
+	aha1542_intr_reset(base_io);
+	return;
+fail:
+	printk(KERN_ERR "setting bus on/off-time failed\n");
+	aha1542_intr_reset(base_io);
+}
+
 /* return non-zero on detection */
 static struct Scsi_Host *aha1542_hw_init(struct scsi_host_template *tpnt, struct device *pdev, int indx)
 {
@@ -897,37 +931,8 @@ static struct Scsi_Host *aha1542_hw_init(struct scsi_host_template *tpnt, struct
 
 			base_io = bases[indx];
 
-			/* Set the Bus on/off-times as not to ruin floppy performance */
-			{
-				u8 oncmd[] = {CMD_BUSON_TIME, 7};
-				u8 offcmd[] = {CMD_BUSOFF_TIME, 5};
+			aha1542_set_bus_times(indx);
 
-				if (setup_called[indx]) {
-					oncmd[1] = setup_buson[indx];
-					offcmd[1] = setup_busoff[indx];
-				}
-				aha1542_intr_reset(base_io);
-				aha1542_out(base_io, oncmd, 2);
-				if (!wait_mask(INTRFLAGS(base_io), INTRMASK, HACC, 0, 0))
-					goto fail;
-				aha1542_intr_reset(base_io);
-				aha1542_out(base_io, offcmd, 2);
-				if (!wait_mask(INTRFLAGS(base_io), INTRMASK, HACC, 0, 0))
-					goto fail;
-				if (setup_dmaspeed[indx] >= 0) {
-					u8 dmacmd[] = {CMD_DMASPEED, 0};
-					dmacmd[1] = setup_dmaspeed[indx];
-					aha1542_intr_reset(base_io);
-					aha1542_out(base_io, dmacmd, 2);
-					if (!wait_mask(INTRFLAGS(base_io), INTRMASK, HACC, 0, 0))
-						goto fail;
-				}
-				while (0) {
-fail:
-					printk(KERN_ERR "aha1542_detect: setting bus on/off-time failed\n");
-				}
-				aha1542_intr_reset(base_io);
-			}
 			if (aha1542_query(base_io, &trans))
 				goto unregister;
 

commit 8537cba8b6e14ff86f088dd71592090606c97050
Author: Ondrej Zary <linux@rainbow-software.org>
Date:   Fri Feb 6 23:11:37 2015 +0100

    aha1542: Merge aha1542_host_reset and aha1542_bus_reset
    
    aha1542_host_reset and aha1542_bus_reset are almost same, merge them
    into aha1542_reset
    
    Signed-off-by: Ondrej Zary <linux@rainbow-software.org>
    Reviewed-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: James Bottomley <JBottomley@Odin.com>

diff --git a/drivers/scsi/aha1542.c b/drivers/scsi/aha1542.c
index 67fdd2fad9a7..4bfba454a032 100644
--- a/drivers/scsi/aha1542.c
+++ b/drivers/scsi/aha1542.c
@@ -1070,7 +1070,7 @@ static int aha1542_dev_reset(Scsi_Cmnd * SCpnt)
 	return SUCCESS;
 }
 
-static int aha1542_bus_reset(Scsi_Cmnd * SCpnt)
+static int aha1542_reset(Scsi_Cmnd *SCpnt, u8 reset_cmd)
 {
 	struct aha1542_hostdata *aha1542 = shost_priv(SCpnt->device->host);
 	int i;
@@ -1081,7 +1081,7 @@ static int aha1542_bus_reset(Scsi_Cmnd * SCpnt)
 	 * we do this?  Try this first, and we can add that later
 	 * if it turns out to be useful.
 	 */
-	outb(SCRST, CONTROL(SCpnt->device->host->io_port));
+	outb(reset_cmd, CONTROL(SCpnt->device->host->io_port));
 
 	/*
 	 * Wait for the thing to settle down a bit.  Unfortunately
@@ -1091,7 +1091,6 @@ static int aha1542_bus_reset(Scsi_Cmnd * SCpnt)
 	 * we are pretty desperate anyways.
 	 */
 	ssleep(4);
-
 	spin_lock_irq(SCpnt->device->host->host_lock);
 
 	if (!wait_mask(STATUS(SCpnt->device->host->io_port),
@@ -1099,7 +1098,12 @@ static int aha1542_bus_reset(Scsi_Cmnd * SCpnt)
 		spin_unlock_irq(SCpnt->device->host->host_lock);
 		return FAILED;
 	}
-
+	/*
+	 * We need to do this too before the 1542 can interact with
+	 * us again after host reset.
+	 */
+	if (reset_cmd & HRST)
+		setup_mailboxes(SCpnt->device->host->io_port, SCpnt->device->host);
 	/*
 	 * Now try to pick up the pieces.  For all pending commands,
 	 * free any internal data structures, and basically clear things
@@ -1113,7 +1117,6 @@ static int aha1542_bus_reset(Scsi_Cmnd * SCpnt)
 			Scsi_Cmnd *SCtmp;
 			SCtmp = aha1542->SCint[i];
 
-
 			if (SCtmp->device->soft_reset) {
 				/*
 				 * If this device implements the soft reset option,
@@ -1134,71 +1137,14 @@ static int aha1542_bus_reset(Scsi_Cmnd * SCpnt)
 	return SUCCESS;
 }
 
-static int aha1542_host_reset(Scsi_Cmnd * SCpnt)
+static int aha1542_bus_reset(Scsi_Cmnd *SCpnt)
 {
-	struct aha1542_hostdata *aha1542 = shost_priv(SCpnt->device->host);
-	int i;
-
-	/* 
-	 * This does a scsi reset for all devices on the bus.
-	 * In principle, we could also reset the 1542 - should
-	 * we do this?  Try this first, and we can add that later
-	 * if it turns out to be useful.
-	 */
-	outb(HRST | SCRST, CONTROL(SCpnt->device->host->io_port));
-
-	/*
-	 * Wait for the thing to settle down a bit.  Unfortunately
-	 * this is going to basically lock up the machine while we
-	 * wait for this to complete.  To be 100% correct, we need to
-	 * check for timeout, and if we are doing something like this
-	 * we are pretty desperate anyways.
-	 */
-	ssleep(4);
-	spin_lock_irq(SCpnt->device->host->host_lock);
-
-	if (!wait_mask(STATUS(SCpnt->device->host->io_port),
-	     STATMASK, INIT | IDLE, STST | DIAGF | INVDCMD | DF | CDF, 0)) {
-		spin_unlock_irq(SCpnt->device->host->host_lock);
-		return FAILED;
-	}
-	/*
-	 * We need to do this too before the 1542 can interact with
-	 * us again.
-	 */
-	setup_mailboxes(SCpnt->device->host->io_port, SCpnt->device->host);
-
-	/*
-	 * Now try to pick up the pieces.  For all pending commands,
-	 * free any internal data structures, and basically clear things
-	 * out.  We do not try and restart any commands or anything - 
-	 * the strategy handler takes care of that crap.
-	 */
-	printk(KERN_WARNING "Sent BUS RESET to scsi host %d\n", SCpnt->device->host->host_no);
-
-	for (i = 0; i < AHA1542_MAILBOXES; i++) {
-		if (aha1542->SCint[i] != NULL) {
-			Scsi_Cmnd *SCtmp;
-			SCtmp = aha1542->SCint[i];
-
-			if (SCtmp->device->soft_reset) {
-				/*
-				 * If this device implements the soft reset option,
-				 * then it is still holding onto the command, and
-				 * may yet complete it.  In this case, we don't
-				 * flush the data.
-				 */
-				continue;
-			}
-			kfree(SCtmp->host_scribble);
-			SCtmp->host_scribble = NULL;
-			aha1542->SCint[i] = NULL;
-			aha1542->mb[i].status = 0;
-		}
-	}
+	return aha1542_reset(SCpnt, SCRST);
+}
 
-	spin_unlock_irq(SCpnt->device->host->host_lock);
-	return SUCCESS;
+static int aha1542_host_reset(Scsi_Cmnd *SCpnt)
+{
+	return aha1542_reset(SCpnt, HRST | SCRST);
 }
 
 static int aha1542_biosparam(struct scsi_device *sdev,

commit dfd7c991f31261fb4fb14adf0479206b178d270d
Author: Ondrej Zary <linux@rainbow-software.org>
Date:   Fri Feb 6 23:11:36 2015 +0100

    aha1542: Remove aha1542_restart
    
    aha1542_restart does nothing (except useless printk), remove it
    
    Signed-off-by: Ondrej Zary <linux@rainbow-software.org>
    Reviewed-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: James Bottomley <JBottomley@Odin.com>

diff --git a/drivers/scsi/aha1542.c b/drivers/scsi/aha1542.c
index 29ddcc993423..67fdd2fad9a7 100644
--- a/drivers/scsi/aha1542.c
+++ b/drivers/scsi/aha1542.c
@@ -321,22 +321,6 @@ static int aha1542_test_port(int bse, struct Scsi_Host *shpnt)
 	return 1;
 }
 
-static int aha1542_restart(struct Scsi_Host *shost)
-{
-	struct aha1542_hostdata *aha1542 = shost_priv(shost);
-	int i;
-	int count = 0;
-
-	for (i = 0; i < AHA1542_MAILBOXES; i++)
-		if (aha1542->SCint[i] &&
-		    !(aha1542->SCint[i]->device->soft_reset)) {
-			count++;
-		}
-	printk(KERN_DEBUG "Potential to restart %d stalled commands...\n", count);
-
-	return 0;
-}
-
 /* A "high" level interrupt handler */
 static void aha1542_intr_handle(struct Scsi_Host *shost)
 {
@@ -347,7 +331,6 @@ static void aha1542_intr_handle(struct Scsi_Host *shost)
 	unsigned long flags;
 	Scsi_Cmnd *SCtmp;
 	int flag;
-	int needs_restart;
 	struct mailbox *mb = aha1542->mb;
 	struct ccb *ccb = aha1542->ccb;
 
@@ -369,7 +352,6 @@ static void aha1542_intr_handle(struct Scsi_Host *shost)
 	};
 #endif
 	number_serviced = 0;
-	needs_restart = 0;
 
 	while (1 == 1) {
 		flag = inb(INTRFLAGS(shost->io_port));
@@ -383,10 +365,8 @@ static void aha1542_intr_handle(struct Scsi_Host *shost)
 				printk("MBOF ");
 			if (flag & HACC)
 				printk("HACC ");
-			if (flag & SCRD) {
-				needs_restart = 1;
+			if (flag & SCRD)
 				printk("SCRD ");
-			}
 		}
 		aha1542_intr_reset(shost->io_port);
 
@@ -406,12 +386,8 @@ static void aha1542_intr_handle(struct Scsi_Host *shost)
 		if (mb[mbi].status == 0) {
 			spin_unlock_irqrestore(&aha1542_lock, flags);
 			/* Hmm, no mail.  Must have read it the last time around */
-			if (!number_serviced && !needs_restart)
+			if (!number_serviced)
 				printk(KERN_WARNING "aha1542.c: interrupt received, but no mail.\n");
-			/* We detected a reset.  Restart all pending commands for
-			   devices that use the hard reset option */
-			if (needs_restart)
-				aha1542_restart(shost);
 			return;
 		};
 

commit bdebe2241eb49bf2308571b6158fa5635b9e708e
Author: Ondrej Zary <linux@rainbow-software.org>
Date:   Fri Feb 6 23:11:35 2015 +0100

    aha1542: remove useless code from aha1542_test_port
    
    Signed-off-by: Ondrej Zary <linux@rainbow-software.org>
    Reviewed-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: James Bottomley <JBottomley@Odin.com>

diff --git a/drivers/scsi/aha1542.c b/drivers/scsi/aha1542.c
index af2c69e1a697..29ddcc993423 100644
--- a/drivers/scsi/aha1542.c
+++ b/drivers/scsi/aha1542.c
@@ -271,7 +271,6 @@ static int aha1542_test_port(int bse, struct Scsi_Host *shpnt)
 	u8 inquiry_result[4];
 	u8 *cmdp;
 	int len;
-	volatile int debug = 0;
 
 	/* Quick and dirty test for presence of the card. */
 	if (inb(STATUS(bse)) == 0xff)
@@ -279,8 +278,6 @@ static int aha1542_test_port(int bse, struct Scsi_Host *shpnt)
 
 	/* Reset the adapter. I ought to make a hard reset, but it's not really necessary */
 
-	/*  DEB(printk("aha1542_test_port called \n")); */
-
 	/* In case some other card was probing here, reset interrupts */
 	aha1542_intr_reset(bse);	/* reset interrupts, so they don't block */
 
@@ -288,23 +285,19 @@ static int aha1542_test_port(int bse, struct Scsi_Host *shpnt)
 
 	mdelay(20);		/* Wait a little bit for things to settle down. */
 
-	debug = 1;
 	/* Expect INIT and IDLE, any of the others are bad */
 	if (!wait_mask(STATUS(bse), STATMASK, INIT | IDLE, STST | DIAGF | INVDCMD | DF | CDF, 0))
 		return 0;
 
-	debug = 2;
 	/* Shouldn't have generated any interrupts during reset */
 	if (inb(INTRFLAGS(bse)) & INTRMASK)
 		return 0;
 
-
 	/* Perform a host adapter inquiry instead so we do not need to set
 	   up the mailboxes ahead of time */
 
 	aha1542_outb(bse, CMD_INQUIRY);
 
-	debug = 3;
 	len = 4;
 	cmdp = &inquiry_result[0];
 
@@ -314,24 +307,18 @@ static int aha1542_test_port(int bse, struct Scsi_Host *shpnt)
 		*cmdp++ = inb(DATA(bse));
 	}
 
-	debug = 8;
 	/* Reading port should reset DF */
 	if (inb(STATUS(bse)) & DF)
 		return 0;
 
-	debug = 9;
 	/* When HACC, command is completed, and we're though testing */
 	if (!wait_mask(INTRFLAGS(bse), HACC, HACC, 0, 0))
 		return 0;
-	/* now initialize adapter */
 
-	debug = 10;
 	/* Clear interrupts */
 	outb(IRST, CONTROL(bse));
 
-	debug = 11;
-
-	return debug;		/* 1 = ok */
+	return 1;
 }
 
 static int aha1542_restart(struct Scsi_Host *shost)

commit a13b3722a352dffa838994eb713573e2e189d928
Author: Ondrej Zary <linux@rainbow-software.org>
Date:   Fri Feb 6 23:11:34 2015 +0100

    aha1542: Remove unneeded gotos
    
    Remove gotos that are no longer needed.
    
    Signed-off-by: Ondrej Zary <linux@rainbow-software.org>
    Reviewed-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: James Bottomley <JBottomley@Odin.com>

diff --git a/drivers/scsi/aha1542.c b/drivers/scsi/aha1542.c
index 7bf4604ede47..af2c69e1a697 100644
--- a/drivers/scsi/aha1542.c
+++ b/drivers/scsi/aha1542.c
@@ -198,17 +198,16 @@ static int aha1542_in(unsigned int base, u8 *cmdp, int len, int timeout)
 
 	spin_lock_irqsave(&aha1542_lock, flags);
 	while (len--) {
-		if (!wait_mask(STATUS(base), DF, DF, 0, timeout))
-			goto fail;
+		if (!wait_mask(STATUS(base), DF, DF, 0, timeout)) {
+			spin_unlock_irqrestore(&aha1542_lock, flags);
+			if (timeout == 0)
+				printk(KERN_ERR "aha1542_in failed(%d): ", len + 1);
+			return 1;
+		}
 		*cmdp++ = inb(DATA(base));
 	}
 	spin_unlock_irqrestore(&aha1542_lock, flags);
 	return 0;
-fail:
-	spin_unlock_irqrestore(&aha1542_lock, flags);
-	if (timeout == 0)
-		printk(KERN_ERR "aha1542_in failed(%d): ", len + 1);
-	return 1;
 }
 
 static int makecode(unsigned hosterr, unsigned scsierr)
@@ -292,12 +291,12 @@ static int aha1542_test_port(int bse, struct Scsi_Host *shpnt)
 	debug = 1;
 	/* Expect INIT and IDLE, any of the others are bad */
 	if (!wait_mask(STATUS(bse), STATMASK, INIT | IDLE, STST | DIAGF | INVDCMD | DF | CDF, 0))
-		goto fail;
+		return 0;
 
 	debug = 2;
 	/* Shouldn't have generated any interrupts during reset */
 	if (inb(INTRFLAGS(bse)) & INTRMASK)
-		goto fail;
+		return 0;
 
 
 	/* Perform a host adapter inquiry instead so we do not need to set
@@ -311,19 +310,19 @@ static int aha1542_test_port(int bse, struct Scsi_Host *shpnt)
 
 	while (len--) {
 		if (!wait_mask(STATUS(bse), DF, DF, 0, 0))
-			goto fail;
+			return 0;
 		*cmdp++ = inb(DATA(bse));
 	}
 
 	debug = 8;
 	/* Reading port should reset DF */
 	if (inb(STATUS(bse)) & DF)
-		goto fail;
+		return 0;
 
 	debug = 9;
 	/* When HACC, command is completed, and we're though testing */
 	if (!wait_mask(INTRFLAGS(bse), HACC, HACC, 0, 0))
-		goto fail;
+		return 0;
 	/* now initialize adapter */
 
 	debug = 10;
@@ -333,8 +332,6 @@ static int aha1542_test_port(int bse, struct Scsi_Host *shpnt)
 	debug = 11;
 
 	return debug;		/* 1 = ok */
-fail:
-	return 0;		/* 0 = not ok */
 }
 
 static int aha1542_restart(struct Scsi_Host *shost)
@@ -692,11 +689,7 @@ static void setup_mailboxes(int bse, struct Scsi_Host *shpnt)
 	any2scsi((cmd + 2), isa_virt_to_bus(mb));
 	aha1542_out(bse, cmd, 5);
 	if (!wait_mask(INTRFLAGS(bse), INTRMASK, HACC, 0, 0))
-		goto fail;
-	while (0) {
-fail:
 		printk(KERN_ERR "aha1542_detect: failed setting up mailboxes\n");
-	}
 	aha1542_intr_reset(bse);
 }
 
@@ -711,11 +704,7 @@ static int aha1542_getconfig(int base_io, unsigned char *irq_level, unsigned cha
 	aha1542_outb(base_io, CMD_RETCONF);
 	aha1542_in(base_io, inquiry_result, 3, 0);
 	if (!wait_mask(INTRFLAGS(base_io), INTRMASK, HACC, 0, 0))
-		goto fail;
-	while (0) {
-fail:
 		printk(KERN_ERR "aha1542_detect: query board settings\n");
-	}
 	aha1542_intr_reset(base_io);
 	switch (inquiry_result[0]) {
 	case 0x80:
@@ -816,11 +805,7 @@ static int aha1542_query(int base_io, int *transl)
 	aha1542_outb(base_io, CMD_INQUIRY);
 	aha1542_in(base_io, inquiry_result, 4, 0);
 	if (!wait_mask(INTRFLAGS(base_io), INTRMASK, HACC, 0, 0))
-		goto fail;
-	while (0) {
-fail:
 		printk(KERN_ERR "aha1542_detect: query card type\n");
-	}
 	aha1542_intr_reset(base_io);
 
 	*transl = BIOS_TRANSLATION_6432;	/* Default case */
@@ -1147,8 +1132,10 @@ static int aha1542_bus_reset(Scsi_Cmnd * SCpnt)
 	spin_lock_irq(SCpnt->device->host->host_lock);
 
 	if (!wait_mask(STATUS(SCpnt->device->host->io_port),
-	     STATMASK, INIT | IDLE, STST | DIAGF | INVDCMD | DF | CDF, 0))
-		goto fail;
+	     STATMASK, INIT | IDLE, STST | DIAGF | INVDCMD | DF | CDF, 0)) {
+		spin_unlock_irq(SCpnt->device->host->host_lock);
+		return FAILED;
+	}
 
 	/*
 	 * Now try to pick up the pieces.  For all pending commands,
@@ -1182,10 +1169,6 @@ static int aha1542_bus_reset(Scsi_Cmnd * SCpnt)
 
 	spin_unlock_irq(SCpnt->device->host->host_lock);
 	return SUCCESS;
-
-fail:
-	spin_unlock_irq(SCpnt->device->host->host_lock);
-	return FAILED;
 }
 
 static int aha1542_host_reset(Scsi_Cmnd * SCpnt)
@@ -1212,9 +1195,10 @@ static int aha1542_host_reset(Scsi_Cmnd * SCpnt)
 	spin_lock_irq(SCpnt->device->host->host_lock);
 
 	if (!wait_mask(STATUS(SCpnt->device->host->io_port),
-	     STATMASK, INIT | IDLE, STST | DIAGF | INVDCMD | DF | CDF, 0))
-		goto fail;
-
+	     STATMASK, INIT | IDLE, STST | DIAGF | INVDCMD | DF | CDF, 0)) {
+		spin_unlock_irq(SCpnt->device->host->host_lock);
+		return FAILED;
+	}
 	/*
 	 * We need to do this too before the 1542 can interact with
 	 * us again.
@@ -1252,10 +1236,6 @@ static int aha1542_host_reset(Scsi_Cmnd * SCpnt)
 
 	spin_unlock_irq(SCpnt->device->host->host_lock);
 	return SUCCESS;
-
-fail:
-	spin_unlock_irq(SCpnt->device->host->host_lock);
-	return FAILED;
 }
 
 static int aha1542_biosparam(struct scsi_device *sdev,

commit 0c2b64819105986c12d7412a1cb5b91e3d80c15c
Author: Ondrej Zary <linux@rainbow-software.org>
Date:   Fri Feb 6 23:11:33 2015 +0100

    aha1542: Split aha1542_out
    
    aha1542_out are in fact two separate functions.
    Split them into aha1542_out and aha1542_outb to simplify the code.
    
    Signed-off-by: Ondrej Zary <linux@rainbow-software.org>
    Reviewed-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: James Bottomley <JBottomley@Odin.com>

diff --git a/drivers/scsi/aha1542.c b/drivers/scsi/aha1542.c
index b4ada244bcb2..7bf4604ede47 100644
--- a/drivers/scsi/aha1542.c
+++ b/drivers/scsi/aha1542.c
@@ -151,41 +151,42 @@ static inline bool wait_mask(u16 port, u8 mask, u8 allof, u8 noneof, int timeout
    routine does not send something out while we are in the middle of this.
    Fortunately, it is only at boot time that multi-byte messages
    are ever sent. */
-static int aha1542_out(unsigned int base, u8 *cmdp, int len)
+static int aha1542_outb(unsigned int base, u8 cmd)
 {
-	unsigned long flags = 0;
-	int got_lock;
-
-	if (len == 1) {
-		got_lock = 0;
-		while (1 == 1) {
-			if (!wait_mask(STATUS(base), CDF, 0, CDF, 0))
-				goto fail;
-			spin_lock_irqsave(&aha1542_lock, flags);
-			if (inb(STATUS(base)) & CDF) {
-				spin_unlock_irqrestore(&aha1542_lock, flags);
-				continue;
-			}
-			outb(*cmdp, DATA(base));
-			spin_unlock_irqrestore(&aha1542_lock, flags);
-			return 0;
+	unsigned long flags;
+
+	while (1) {
+		if (!wait_mask(STATUS(base), CDF, 0, CDF, 0)) {
+			printk(KERN_ERR "aha1542_outb failed");
+			return 1;
 		}
-	} else {
 		spin_lock_irqsave(&aha1542_lock, flags);
-		got_lock = 1;
-		while (len--) {
-			if (!wait_mask(STATUS(base), CDF, 0, CDF, 0))
-				goto fail;
-			outb(*cmdp++, DATA(base));
+		if (inb(STATUS(base)) & CDF) {
+			spin_unlock_irqrestore(&aha1542_lock, flags);
+			continue;
 		}
+		outb(cmd, DATA(base));
 		spin_unlock_irqrestore(&aha1542_lock, flags);
+		return 0;
 	}
+}
+
+static int aha1542_out(unsigned int base, u8 *cmdp, int len)
+{
+	unsigned long flags;
+
+	spin_lock_irqsave(&aha1542_lock, flags);
+	while (len--) {
+		if (!wait_mask(STATUS(base), CDF, 0, CDF, 0)) {
+			spin_unlock_irqrestore(&aha1542_lock, flags);
+			printk(KERN_ERR "aha1542_out failed(%d): ", len + 1);
+			return 1;
+		}
+		outb(*cmdp++, DATA(base));
+	}
+	spin_unlock_irqrestore(&aha1542_lock, flags);
+
 	return 0;
-fail:
-	if (got_lock)
-		spin_unlock_irqrestore(&aha1542_lock, flags);
-	printk(KERN_ERR "aha1542_out failed(%d): ", len + 1);
-	return 1;
 }
 
 /* Only used at boot time, so we do not need to worry about latency as much
@@ -268,7 +269,6 @@ static int makecode(unsigned hosterr, unsigned scsierr)
 
 static int aha1542_test_port(int bse, struct Scsi_Host *shpnt)
 {
-	u8 inquiry_cmd[] = {CMD_INQUIRY};
 	u8 inquiry_result[4];
 	u8 *cmdp;
 	int len;
@@ -303,7 +303,7 @@ static int aha1542_test_port(int bse, struct Scsi_Host *shpnt)
 	/* Perform a host adapter inquiry instead so we do not need to set
 	   up the mailboxes ahead of time */
 
-	aha1542_out(bse, inquiry_cmd, 1);
+	aha1542_outb(bse, CMD_INQUIRY);
 
 	debug = 3;
 	len = 4;
@@ -527,7 +527,6 @@ static irqreturn_t do_aha1542_intr_handle(int dummy, void *dev_id)
 static int aha1542_queuecommand_lck(Scsi_Cmnd * SCpnt, void (*done) (Scsi_Cmnd *))
 {
 	struct aha1542_hostdata *aha1542 = shost_priv(SCpnt->device->host);
-	u8 ahacmd = CMD_START_SCSI;
 	u8 direction;
 	u8 *cmd = (u8 *) SCpnt->cmnd;
 	u8 target = SCpnt->device->id;
@@ -666,7 +665,7 @@ static int aha1542_queuecommand_lck(Scsi_Cmnd * SCpnt, void (*done) (Scsi_Cmnd *
 		DEB(printk("aha1542_queuecommand: now waiting for interrupt "));
 		SCpnt->scsi_done = done;
 		mb[mbo].status = 1;
-		aha1542_out(SCpnt->device->host->io_port, &ahacmd, 1);	/* start scsi command */
+		aha1542_outb(SCpnt->device->host->io_port, CMD_START_SCSI);
 	} else
 		printk("aha1542_queuecommand: done can't be NULL\n");
 
@@ -703,14 +702,13 @@ static void setup_mailboxes(int bse, struct Scsi_Host *shpnt)
 
 static int aha1542_getconfig(int base_io, unsigned char *irq_level, unsigned char *dma_chan, unsigned char *scsi_id)
 {
-	u8 inquiry_cmd[] = {CMD_RETCONF};
 	u8 inquiry_result[3];
 	int i;
 	i = inb(STATUS(base_io));
 	if (i & DF) {
 		i = inb(DATA(base_io));
 	};
-	aha1542_out(base_io, inquiry_cmd, 1);
+	aha1542_outb(base_io, CMD_RETCONF);
 	aha1542_in(base_io, inquiry_result, 3, 0);
 	if (!wait_mask(INTRFLAGS(base_io), INTRMASK, HACC, 0, 0))
 		goto fail;
@@ -779,8 +777,7 @@ static int aha1542_mbenable(int base)
 
 	retval = BIOS_TRANSLATION_6432;
 
-	mbenable_cmd[0] = CMD_EXTBIOS;
-	aha1542_out(base, mbenable_cmd, 1);
+	aha1542_outb(base, CMD_EXTBIOS);
 	if (aha1542_in(base, mbenable_result, 2, 100))
 		return retval;
 	if (!wait_mask(INTRFLAGS(base), INTRMASK, HACC, 0, 100))
@@ -810,14 +807,13 @@ static int aha1542_mbenable(int base)
 /* Query the board to find out if it is a 1542 or a 1740, or whatever. */
 static int aha1542_query(int base_io, int *transl)
 {
-	u8 inquiry_cmd[] = {CMD_INQUIRY};
 	u8 inquiry_result[4];
 	int i;
 	i = inb(STATUS(base_io));
 	if (i & DF) {
 		i = inb(DATA(base_io));
 	};
-	aha1542_out(base_io, inquiry_cmd, 1);
+	aha1542_outb(base_io, CMD_INQUIRY);
 	aha1542_in(base_io, inquiry_result, 4, 0);
 	if (!wait_mask(INTRFLAGS(base_io), INTRMASK, HACC, 0, 0))
 		goto fail;
@@ -1079,7 +1075,6 @@ static int aha1542_dev_reset(Scsi_Cmnd * SCpnt)
 	u8 lun = SCpnt->device->lun;
 	int mbo;
 	struct ccb *ccb = aha1542->ccb;
-	u8 ahacmd = CMD_START_SCSI;
 
 	spin_lock_irqsave(&aha1542_lock, flags);
 	mbo = aha1542->aha1542_last_mbo_used + 1;
@@ -1119,7 +1114,7 @@ static int aha1542_dev_reset(Scsi_Cmnd * SCpnt)
 	 * Now tell the 1542 to flush all pending commands for this 
 	 * target 
 	 */
-	aha1542_out(SCpnt->device->host->io_port, &ahacmd, 1);
+	aha1542_outb(SCpnt->device->host->io_port, CMD_START_SCSI);
 
 	scmd_printk(KERN_WARNING, SCpnt,
 		"Trying device reset for target\n");

commit f8846be334443b432f5daf22099e9f4bdd02ba9f
Author: Ondrej Zary <linux@rainbow-software.org>
Date:   Fri Feb 6 23:11:32 2015 +0100

    aha1542: Unify aha1542_in and aha1542_in1
    
    Unify aha1542_in and aha1542_in1 functions, they differ only in timeout
    and printk.
    
    Signed-off-by: Ondrej Zary <linux@rainbow-software.org>
    Reviewed-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: James Bottomley <JBottomley@Odin.com>

diff --git a/drivers/scsi/aha1542.c b/drivers/scsi/aha1542.c
index 0e58cef3e8e0..b4ada244bcb2 100644
--- a/drivers/scsi/aha1542.c
+++ b/drivers/scsi/aha1542.c
@@ -191,34 +191,13 @@ static int aha1542_out(unsigned int base, u8 *cmdp, int len)
 /* Only used at boot time, so we do not need to worry about latency as much
    here */
 
-static int aha1542_in(unsigned int base, u8 *cmdp, int len)
+static int aha1542_in(unsigned int base, u8 *cmdp, int len, int timeout)
 {
 	unsigned long flags;
 
 	spin_lock_irqsave(&aha1542_lock, flags);
 	while (len--) {
-		if (!wait_mask(STATUS(base), DF, DF, 0, 0))
-			goto fail;
-		*cmdp++ = inb(DATA(base));
-	}
-	spin_unlock_irqrestore(&aha1542_lock, flags);
-	return 0;
-fail:
-	spin_unlock_irqrestore(&aha1542_lock, flags);
-	printk(KERN_ERR "aha1542_in failed(%d): ", len + 1);
-	return 1;
-}
-
-/* Similar to aha1542_in, except that we wait a very short period of time.
-   We use this if we know the board is alive and awake, but we are not sure
-   if the board will respond to the command we are about to send or not */
-static int aha1542_in1(unsigned int base, u8 *cmdp, int len)
-{
-	unsigned long flags;
-
-	spin_lock_irqsave(&aha1542_lock, flags);
-	while (len--) {
-		if (!wait_mask(STATUS(base), DF, DF, 0, 100))
+		if (!wait_mask(STATUS(base), DF, DF, 0, timeout))
 			goto fail;
 		*cmdp++ = inb(DATA(base));
 	}
@@ -226,6 +205,8 @@ static int aha1542_in1(unsigned int base, u8 *cmdp, int len)
 	return 0;
 fail:
 	spin_unlock_irqrestore(&aha1542_lock, flags);
+	if (timeout == 0)
+		printk(KERN_ERR "aha1542_in failed(%d): ", len + 1);
 	return 1;
 }
 
@@ -730,7 +711,7 @@ static int aha1542_getconfig(int base_io, unsigned char *irq_level, unsigned cha
 		i = inb(DATA(base_io));
 	};
 	aha1542_out(base_io, inquiry_cmd, 1);
-	aha1542_in(base_io, inquiry_result, 3);
+	aha1542_in(base_io, inquiry_result, 3, 0);
 	if (!wait_mask(INTRFLAGS(base_io), INTRMASK, HACC, 0, 0))
 		goto fail;
 	while (0) {
@@ -800,7 +781,7 @@ static int aha1542_mbenable(int base)
 
 	mbenable_cmd[0] = CMD_EXTBIOS;
 	aha1542_out(base, mbenable_cmd, 1);
-	if (aha1542_in1(base, mbenable_result, 2))
+	if (aha1542_in(base, mbenable_result, 2, 100))
 		return retval;
 	if (!wait_mask(INTRFLAGS(base), INTRMASK, HACC, 0, 100))
 		goto fail;
@@ -837,7 +818,7 @@ static int aha1542_query(int base_io, int *transl)
 		i = inb(DATA(base_io));
 	};
 	aha1542_out(base_io, inquiry_cmd, 1);
-	aha1542_in(base_io, inquiry_result, 4);
+	aha1542_in(base_io, inquiry_result, 4, 0);
 	if (!wait_mask(INTRFLAGS(base_io), INTRMASK, HACC, 0, 0))
 		goto fail;
 	while (0) {

commit 2093bfa1364472759d4711d034c634594d35188a
Author: Ondrej Zary <linux@rainbow-software.org>
Date:   Fri Feb 6 23:11:31 2015 +0100

    aha1542: Remove WAIT and WAITd macros
    
    Convert the ugly WAIT and WAITd macros into wait_mask function.
    
    Signed-off-by: Ondrej Zary <linux@rainbow-software.org>
    Reviewed-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: James Bottomley <JBottomley@Odin.com>

diff --git a/drivers/scsi/aha1542.c b/drivers/scsi/aha1542.c
index ebc5476e9709..0e58cef3e8e0 100644
--- a/drivers/scsi/aha1542.c
+++ b/drivers/scsi/aha1542.c
@@ -120,39 +120,32 @@ struct aha1542_hostdata {
 
 static DEFINE_SPINLOCK(aha1542_lock);
 
-
-
-#define WAITnexttimeout 3000000
-
 static inline void aha1542_intr_reset(u16 base)
 {
 	outb(IRST, CONTROL(base));
 }
 
-#define WAIT(port, mask, allof, noneof)					\
- { register int WAITbits;						\
-   register int WAITtimeout = WAITnexttimeout;				\
-   while (1) {								\
-     WAITbits = inb(port) & (mask);					\
-     if ((WAITbits & (allof)) == (allof) && ((WAITbits & (noneof)) == 0)) \
-       break;                                                         	\
-     if (--WAITtimeout == 0) goto fail;					\
-   }									\
- }
-
-/* Similar to WAIT, except we use the udelay call to regulate the
-   amount of time we wait.  */
-#define WAITd(port, mask, allof, noneof, timeout)			\
- { register int WAITbits;						\
-   register int WAITtimeout = timeout;					\
-   while (1) {								\
-     WAITbits = inb(port) & (mask);					\
-     if ((WAITbits & (allof)) == (allof) && ((WAITbits & (noneof)) == 0)) \
-       break;                                                         	\
-     mdelay(1);							\
-     if (--WAITtimeout == 0) goto fail;					\
-   }									\
- }
+static inline bool wait_mask(u16 port, u8 mask, u8 allof, u8 noneof, int timeout)
+{
+	bool delayed = true;
+
+	if (timeout == 0) {
+		timeout = 3000000;
+		delayed = false;
+	}
+
+	while (1) {
+		u8 bits = inb(port) & mask;
+		if ((bits & allof) == allof && ((bits & noneof) == 0))
+			break;
+		if (delayed)
+			mdelay(1);
+		if (--timeout == 0)
+			return false;
+	}
+
+	return true;
+}
 
 /* This is a bit complicated, but we need to make sure that an interrupt
    routine does not send something out while we are in the middle of this.
@@ -166,7 +159,8 @@ static int aha1542_out(unsigned int base, u8 *cmdp, int len)
 	if (len == 1) {
 		got_lock = 0;
 		while (1 == 1) {
-			WAIT(STATUS(base), CDF, 0, CDF);
+			if (!wait_mask(STATUS(base), CDF, 0, CDF, 0))
+				goto fail;
 			spin_lock_irqsave(&aha1542_lock, flags);
 			if (inb(STATUS(base)) & CDF) {
 				spin_unlock_irqrestore(&aha1542_lock, flags);
@@ -180,7 +174,8 @@ static int aha1542_out(unsigned int base, u8 *cmdp, int len)
 		spin_lock_irqsave(&aha1542_lock, flags);
 		got_lock = 1;
 		while (len--) {
-			WAIT(STATUS(base), CDF, 0, CDF);
+			if (!wait_mask(STATUS(base), CDF, 0, CDF, 0))
+				goto fail;
 			outb(*cmdp++, DATA(base));
 		}
 		spin_unlock_irqrestore(&aha1542_lock, flags);
@@ -202,7 +197,8 @@ static int aha1542_in(unsigned int base, u8 *cmdp, int len)
 
 	spin_lock_irqsave(&aha1542_lock, flags);
 	while (len--) {
-		WAIT(STATUS(base), DF, DF, 0);
+		if (!wait_mask(STATUS(base), DF, DF, 0, 0))
+			goto fail;
 		*cmdp++ = inb(DATA(base));
 	}
 	spin_unlock_irqrestore(&aha1542_lock, flags);
@@ -222,7 +218,8 @@ static int aha1542_in1(unsigned int base, u8 *cmdp, int len)
 
 	spin_lock_irqsave(&aha1542_lock, flags);
 	while (len--) {
-		WAITd(STATUS(base), DF, DF, 0, 100);
+		if (!wait_mask(STATUS(base), DF, DF, 0, 100))
+			goto fail;
 		*cmdp++ = inb(DATA(base));
 	}
 	spin_unlock_irqrestore(&aha1542_lock, flags);
@@ -313,7 +310,8 @@ static int aha1542_test_port(int bse, struct Scsi_Host *shpnt)
 
 	debug = 1;
 	/* Expect INIT and IDLE, any of the others are bad */
-	WAIT(STATUS(bse), STATMASK, INIT | IDLE, STST | DIAGF | INVDCMD | DF | CDF);
+	if (!wait_mask(STATUS(bse), STATMASK, INIT | IDLE, STST | DIAGF | INVDCMD | DF | CDF, 0))
+		goto fail;
 
 	debug = 2;
 	/* Shouldn't have generated any interrupts during reset */
@@ -331,7 +329,8 @@ static int aha1542_test_port(int bse, struct Scsi_Host *shpnt)
 	cmdp = &inquiry_result[0];
 
 	while (len--) {
-		WAIT(STATUS(bse), DF, DF, 0);
+		if (!wait_mask(STATUS(bse), DF, DF, 0, 0))
+			goto fail;
 		*cmdp++ = inb(DATA(bse));
 	}
 
@@ -342,7 +341,8 @@ static int aha1542_test_port(int bse, struct Scsi_Host *shpnt)
 
 	debug = 9;
 	/* When HACC, command is completed, and we're though testing */
-	WAIT(INTRFLAGS(bse), HACC, HACC, 0);
+	if (!wait_mask(INTRFLAGS(bse), HACC, HACC, 0, 0))
+		goto fail;
 	/* now initialize adapter */
 
 	debug = 10;
@@ -711,7 +711,8 @@ static void setup_mailboxes(int bse, struct Scsi_Host *shpnt)
 	aha1542_intr_reset(bse);	/* reset interrupts, so they don't block */
 	any2scsi((cmd + 2), isa_virt_to_bus(mb));
 	aha1542_out(bse, cmd, 5);
-	WAIT(INTRFLAGS(bse), INTRMASK, HACC, 0);
+	if (!wait_mask(INTRFLAGS(bse), INTRMASK, HACC, 0, 0))
+		goto fail;
 	while (0) {
 fail:
 		printk(KERN_ERR "aha1542_detect: failed setting up mailboxes\n");
@@ -730,7 +731,8 @@ static int aha1542_getconfig(int base_io, unsigned char *irq_level, unsigned cha
 	};
 	aha1542_out(base_io, inquiry_cmd, 1);
 	aha1542_in(base_io, inquiry_result, 3);
-	WAIT(INTRFLAGS(base_io), INTRMASK, HACC, 0);
+	if (!wait_mask(INTRFLAGS(base_io), INTRMASK, HACC, 0, 0))
+		goto fail;
 	while (0) {
 fail:
 		printk(KERN_ERR "aha1542_detect: query board settings\n");
@@ -800,7 +802,8 @@ static int aha1542_mbenable(int base)
 	aha1542_out(base, mbenable_cmd, 1);
 	if (aha1542_in1(base, mbenable_result, 2))
 		return retval;
-	WAITd(INTRFLAGS(base), INTRMASK, HACC, 0, 100);
+	if (!wait_mask(INTRFLAGS(base), INTRMASK, HACC, 0, 100))
+		goto fail;
 	aha1542_intr_reset(base);
 
 	if ((mbenable_result[0] & 0x08) || mbenable_result[1]) {
@@ -812,7 +815,8 @@ static int aha1542_mbenable(int base)
 			retval = BIOS_TRANSLATION_25563;
 
 		aha1542_out(base, mbenable_cmd, 3);
-		WAIT(INTRFLAGS(base), INTRMASK, HACC, 0);
+		if (!wait_mask(INTRFLAGS(base), INTRMASK, HACC, 0, 0))
+			goto fail;
 	};
 	while (0) {
 fail:
@@ -834,7 +838,8 @@ static int aha1542_query(int base_io, int *transl)
 	};
 	aha1542_out(base_io, inquiry_cmd, 1);
 	aha1542_in(base_io, inquiry_result, 4);
-	WAIT(INTRFLAGS(base_io), INTRMASK, HACC, 0);
+	if (!wait_mask(INTRFLAGS(base_io), INTRMASK, HACC, 0, 0))
+		goto fail;
 	while (0) {
 fail:
 		printk(KERN_ERR "aha1542_detect: query card type\n");
@@ -978,16 +983,19 @@ static struct Scsi_Host *aha1542_hw_init(struct scsi_host_template *tpnt, struct
 				}
 				aha1542_intr_reset(base_io);
 				aha1542_out(base_io, oncmd, 2);
-				WAIT(INTRFLAGS(base_io), INTRMASK, HACC, 0);
+				if (!wait_mask(INTRFLAGS(base_io), INTRMASK, HACC, 0, 0))
+					goto fail;
 				aha1542_intr_reset(base_io);
 				aha1542_out(base_io, offcmd, 2);
-				WAIT(INTRFLAGS(base_io), INTRMASK, HACC, 0);
+				if (!wait_mask(INTRFLAGS(base_io), INTRMASK, HACC, 0, 0))
+					goto fail;
 				if (setup_dmaspeed[indx] >= 0) {
 					u8 dmacmd[] = {CMD_DMASPEED, 0};
 					dmacmd[1] = setup_dmaspeed[indx];
 					aha1542_intr_reset(base_io);
 					aha1542_out(base_io, dmacmd, 2);
-					WAIT(INTRFLAGS(base_io), INTRMASK, HACC, 0);
+					if (!wait_mask(INTRFLAGS(base_io), INTRMASK, HACC, 0, 0))
+						goto fail;
 				}
 				while (0) {
 fail:
@@ -1162,8 +1170,9 @@ static int aha1542_bus_reset(Scsi_Cmnd * SCpnt)
 
 	spin_lock_irq(SCpnt->device->host->host_lock);
 
-	WAIT(STATUS(SCpnt->device->host->io_port),
-	     STATMASK, INIT | IDLE, STST | DIAGF | INVDCMD | DF | CDF);
+	if (!wait_mask(STATUS(SCpnt->device->host->io_port),
+	     STATMASK, INIT | IDLE, STST | DIAGF | INVDCMD | DF | CDF, 0))
+		goto fail;
 
 	/*
 	 * Now try to pick up the pieces.  For all pending commands,
@@ -1226,8 +1235,9 @@ static int aha1542_host_reset(Scsi_Cmnd * SCpnt)
 	ssleep(4);
 	spin_lock_irq(SCpnt->device->host->host_lock);
 
-	WAIT(STATUS(SCpnt->device->host->io_port),
-	     STATMASK, INIT | IDLE, STST | DIAGF | INVDCMD | DF | CDF);
+	if (!wait_mask(STATUS(SCpnt->device->host->io_port),
+	     STATMASK, INIT | IDLE, STST | DIAGF | INVDCMD | DF | CDF, 0))
+		goto fail;
 
 	/*
 	 * We need to do this too before the 1542 can interact with

commit f232d538017ec0da1df66cf22dc5a5842077b0e6
Author: Ondrej Zary <linux@rainbow-software.org>
Date:   Fri Feb 6 23:11:29 2015 +0100

    aha1542: remove empty aha1542_stat
    
    Signed-off-by: Ondrej Zary <linux@rainbow-software.org>
    Reviewed-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: James Bottomley <JBottomley@Odin.com>

diff --git a/drivers/scsi/aha1542.c b/drivers/scsi/aha1542.c
index af1e8fa41413..ebc5476e9709 100644
--- a/drivers/scsi/aha1542.c
+++ b/drivers/scsi/aha1542.c
@@ -154,12 +154,6 @@ static inline void aha1542_intr_reset(u16 base)
    }									\
  }
 
-static void aha1542_stat(void)
-{
-/*	int s = inb(STATUS), i = inb(INTRFLAGS);
-	printk("status=%x intrflags=%x\n", s, i, WAITnexttimeout-WAITtimeout); */
-}
-
 /* This is a bit complicated, but we need to make sure that an interrupt
    routine does not send something out while we are in the middle of this.
    Fortunately, it is only at boot time that multi-byte messages
@@ -196,7 +190,6 @@ static int aha1542_out(unsigned int base, u8 *cmdp, int len)
 	if (got_lock)
 		spin_unlock_irqrestore(&aha1542_lock, flags);
 	printk(KERN_ERR "aha1542_out failed(%d): ", len + 1);
-	aha1542_stat();
 	return 1;
 }
 
@@ -217,7 +210,6 @@ static int aha1542_in(unsigned int base, u8 *cmdp, int len)
 fail:
 	spin_unlock_irqrestore(&aha1542_lock, flags);
 	printk(KERN_ERR "aha1542_in failed(%d): ", len + 1);
-	aha1542_stat();
 	return 1;
 }
 
@@ -590,7 +582,6 @@ static int aha1542_queuecommand_lck(Scsi_Cmnd * SCpnt, void (*done) (Scsi_Cmnd *
 		printk(KERN_DEBUG "aha1542_queuecommand: dev %d cmd %02x pos %d len %d ", target, *cmd, i, bufflen);
 	else
 		printk(KERN_DEBUG "aha1542_command: dev %d cmd %02x pos %d len %d ", target, *cmd, i, bufflen);
-	aha1542_stat();
 	printk(KERN_DEBUG "aha1542_queuecommand: dumping scsi cmd:");
 	for (i = 0; i < SCpnt->cmd_len; i++)
 		printk("%02x ", cmd[i]);
@@ -691,12 +682,10 @@ static int aha1542_queuecommand_lck(Scsi_Cmnd * SCpnt, void (*done) (Scsi_Cmnd *
 #endif
 
 	if (done) {
-		DEB(printk("aha1542_queuecommand: now waiting for interrupt ");
-		    aha1542_stat());
+		DEB(printk("aha1542_queuecommand: now waiting for interrupt "));
 		SCpnt->scsi_done = done;
 		mb[mbo].status = 1;
 		aha1542_out(SCpnt->device->host->io_port, &ahacmd, 1);	/* start scsi command */
-		DEB(aha1542_stat());
 	} else
 		printk("aha1542_queuecommand: done can't be NULL\n");
 
@@ -1017,11 +1006,8 @@ static struct Scsi_Host *aha1542_hw_init(struct scsi_host_template *tpnt, struct
 				printk(", DMA priority %d", dma_chan);
 			printk("\n");
 
-			DEB(aha1542_stat());
 			setup_mailboxes(base_io, shpnt);
 
-			DEB(aha1542_stat());
-
 			DEB(printk("aha1542_detect: enable interrupt channel %d\n", irq_level));
 			spin_lock_irqsave(&aha1542_lock, flags);
 			if (request_irq(irq_level, do_aha1542_intr_handle, 0,

commit 09a44833887dfc856facff0a9b21f3def0367f0c
Author: Ondrej Zary <linux@rainbow-software.org>
Date:   Fri Feb 6 23:11:28 2015 +0100

    aha1542: Reorder functions to remove forward declarations
    
    Signed-off-by: Ondrej Zary <linux@rainbow-software.org>
    Reviewed-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: James Bottomley <JBottomley@Odin.com>

diff --git a/drivers/scsi/aha1542.c b/drivers/scsi/aha1542.c
index 8851719d8d0e..af1e8fa41413 100644
--- a/drivers/scsi/aha1542.c
+++ b/drivers/scsi/aha1542.c
@@ -124,10 +124,6 @@ static DEFINE_SPINLOCK(aha1542_lock);
 
 #define WAITnexttimeout 3000000
 
-static void setup_mailboxes(int base_io, struct Scsi_Host *shpnt);
-static int aha1542_restart(struct Scsi_Host *shost);
-static void aha1542_intr_handle(struct Scsi_Host *shost);
-
 static inline void aha1542_intr_reset(u16 base)
 {
 	outb(IRST, CONTROL(base));
@@ -368,16 +364,20 @@ static int aha1542_test_port(int bse, struct Scsi_Host *shpnt)
 	return 0;		/* 0 = not ok */
 }
 
-/* A quick wrapper for do_aha1542_intr_handle to grab the spin lock */
-static irqreturn_t do_aha1542_intr_handle(int dummy, void *dev_id)
+static int aha1542_restart(struct Scsi_Host *shost)
 {
-	unsigned long flags;
-	struct Scsi_Host *shost = dev_id;
+	struct aha1542_hostdata *aha1542 = shost_priv(shost);
+	int i;
+	int count = 0;
 
-	spin_lock_irqsave(shost->host_lock, flags);
-	aha1542_intr_handle(shost);
-	spin_unlock_irqrestore(shost->host_lock, flags);
-	return IRQ_HANDLED;
+	for (i = 0; i < AHA1542_MAILBOXES; i++)
+		if (aha1542->SCint[i] &&
+		    !(aha1542->SCint[i]->device->soft_reset)) {
+			count++;
+		}
+	printk(KERN_DEBUG "Potential to restart %d stalled commands...\n", count);
+
+	return 0;
 }
 
 /* A "high" level interrupt handler */
@@ -539,6 +539,18 @@ static void aha1542_intr_handle(struct Scsi_Host *shost)
 	};
 }
 
+/* A quick wrapper for do_aha1542_intr_handle to grab the spin lock */
+static irqreturn_t do_aha1542_intr_handle(int dummy, void *dev_id)
+{
+	unsigned long flags;
+	struct Scsi_Host *shost = dev_id;
+
+	spin_lock_irqsave(shost->host_lock, flags);
+	aha1542_intr_handle(shost);
+	spin_unlock_irqrestore(shost->host_lock, flags);
+	return IRQ_HANDLED;
+}
+
 static int aha1542_queuecommand_lck(Scsi_Cmnd * SCpnt, void (*done) (Scsi_Cmnd *))
 {
 	struct aha1542_hostdata *aha1542 = shost_priv(SCpnt->device->host);
@@ -1078,21 +1090,6 @@ static int aha1542_release(struct Scsi_Host *shost)
 	return 0;
 }
 
-static int aha1542_restart(struct Scsi_Host *shost)
-{
-	struct aha1542_hostdata *aha1542 = shost_priv(shost);
-	int i;
-	int count = 0;
-
-	for (i = 0; i < AHA1542_MAILBOXES; i++)
-		if (aha1542->SCint[i] &&
-		    !(aha1542->SCint[i]->device->soft_reset)) {
-			count++;
-		}
-	printk(KERN_DEBUG "Potential to restart %d stalled commands...\n", count);
-
-	return 0;
-}
 
 /*
  * This is a device reset.  This is handled by sending a special command

commit cb5b570ce3cc7e91f47339e60efba75a4bbc347c
Author: Ondrej Zary <linux@rainbow-software.org>
Date:   Fri Feb 6 23:11:27 2015 +0100

    aha1542: Use u8 instead of unchar
    
    Signed-off-by: Ondrej Zary <linux@rainbow-software.org>
    Reviewed-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: James Bottomley <JBottomley@Odin.com>

diff --git a/drivers/scsi/aha1542.c b/drivers/scsi/aha1542.c
index 2a6308f28d9f..8851719d8d0e 100644
--- a/drivers/scsi/aha1542.c
+++ b/drivers/scsi/aha1542.c
@@ -168,7 +168,7 @@ static void aha1542_stat(void)
    routine does not send something out while we are in the middle of this.
    Fortunately, it is only at boot time that multi-byte messages
    are ever sent. */
-static int aha1542_out(unsigned int base, unchar * cmdp, int len)
+static int aha1542_out(unsigned int base, u8 *cmdp, int len)
 {
 	unsigned long flags = 0;
 	int got_lock;
@@ -207,7 +207,7 @@ static int aha1542_out(unsigned int base, unchar * cmdp, int len)
 /* Only used at boot time, so we do not need to worry about latency as much
    here */
 
-static int aha1542_in(unsigned int base, unchar *cmdp, int len)
+static int aha1542_in(unsigned int base, u8 *cmdp, int len)
 {
 	unsigned long flags;
 
@@ -228,7 +228,7 @@ static int aha1542_in(unsigned int base, unchar *cmdp, int len)
 /* Similar to aha1542_in, except that we wait a very short period of time.
    We use this if we know the board is alive and awake, but we are not sure
    if the board will respond to the command we are about to send or not */
-static int aha1542_in1(unsigned int base, unchar *cmdp, int len)
+static int aha1542_in1(unsigned int base, u8 *cmdp, int len)
 {
 	unsigned long flags;
 
@@ -302,9 +302,9 @@ static int makecode(unsigned hosterr, unsigned scsierr)
 
 static int aha1542_test_port(int bse, struct Scsi_Host *shpnt)
 {
-	unchar inquiry_cmd[] = {CMD_INQUIRY};
-	unchar inquiry_result[4];
-	unchar *cmdp;
+	u8 inquiry_cmd[] = {CMD_INQUIRY};
+	u8 inquiry_result[4];
+	u8 *cmdp;
 	int len;
 	volatile int debug = 0;
 
@@ -542,11 +542,11 @@ static void aha1542_intr_handle(struct Scsi_Host *shost)
 static int aha1542_queuecommand_lck(Scsi_Cmnd * SCpnt, void (*done) (Scsi_Cmnd *))
 {
 	struct aha1542_hostdata *aha1542 = shost_priv(SCpnt->device->host);
-	unchar ahacmd = CMD_START_SCSI;
-	unchar direction;
-	unchar *cmd = (unchar *) SCpnt->cmnd;
-	unchar target = SCpnt->device->id;
-	unchar lun = SCpnt->device->lun;
+	u8 ahacmd = CMD_START_SCSI;
+	u8 direction;
+	u8 *cmd = (u8 *) SCpnt->cmnd;
+	u8 target = SCpnt->device->id;
+	u8 lun = SCpnt->device->lun;
 	unsigned long flags;
 	int bufflen = scsi_bufflen(SCpnt);
 	int mbo;
@@ -674,7 +674,7 @@ static int aha1542_queuecommand_lck(Scsi_Cmnd * SCpnt, void (*done) (Scsi_Cmnd *
 		int i;
 		printk(KERN_DEBUG "aha1542_command: sending.. ");
 		for (i = 0; i < sizeof(ccb[mbo]) - 10; i++)
-			printk("%02x ", ((unchar *) & ccb[mbo])[i]);
+			printk("%02x ", ((u8 *) &ccb[mbo])[i]);
 	};
 #endif
 
@@ -701,7 +701,7 @@ static void setup_mailboxes(int bse, struct Scsi_Host *shpnt)
 	struct mailbox *mb = aha1542->mb;
 	struct ccb *ccb = aha1542->ccb;
 
-	unchar cmd[5] = { CMD_MBINIT, AHA1542_MAILBOXES, 0, 0, 0};
+	u8 cmd[5] = { CMD_MBINIT, AHA1542_MAILBOXES, 0, 0, 0};
 
 	for (i = 0; i < AHA1542_MAILBOXES; i++) {
 		mb[i].status = mb[AHA1542_MAILBOXES + i].status = 0;
@@ -720,8 +720,8 @@ static void setup_mailboxes(int bse, struct Scsi_Host *shpnt)
 
 static int aha1542_getconfig(int base_io, unsigned char *irq_level, unsigned char *dma_chan, unsigned char *scsi_id)
 {
-	unchar inquiry_cmd[] = {CMD_RETCONF};
-	unchar inquiry_result[3];
+	u8 inquiry_cmd[] = {CMD_RETCONF};
+	u8 inquiry_result[3];
 	int i;
 	i = inb(STATUS(base_io));
 	if (i & DF) {
@@ -789,8 +789,8 @@ static int aha1542_getconfig(int base_io, unsigned char *irq_level, unsigned cha
 
 static int aha1542_mbenable(int base)
 {
-	static unchar mbenable_cmd[3];
-	static unchar mbenable_result[2];
+	static u8 mbenable_cmd[3];
+	static u8 mbenable_result[2];
 	int retval;
 
 	retval = BIOS_TRANSLATION_6432;
@@ -824,8 +824,8 @@ static int aha1542_mbenable(int base)
 /* Query the board to find out if it is a 1542 or a 1740, or whatever. */
 static int aha1542_query(int base_io, int *transl)
 {
-	unchar inquiry_cmd[] = {CMD_INQUIRY};
-	unchar inquiry_result[4];
+	u8 inquiry_cmd[] = {CMD_INQUIRY};
+	u8 inquiry_result[4];
 	int i;
 	i = inb(STATUS(base_io));
 	if (i & DF) {
@@ -968,8 +968,8 @@ static struct Scsi_Host *aha1542_hw_init(struct scsi_host_template *tpnt, struct
 
 			/* Set the Bus on/off-times as not to ruin floppy performance */
 			{
-				unchar oncmd[] = {CMD_BUSON_TIME, 7};
-				unchar offcmd[] = {CMD_BUSOFF_TIME, 5};
+				u8 oncmd[] = {CMD_BUSON_TIME, 7};
+				u8 offcmd[] = {CMD_BUSOFF_TIME, 5};
 
 				if (setup_called[indx]) {
 					oncmd[1] = setup_buson[indx];
@@ -982,7 +982,7 @@ static struct Scsi_Host *aha1542_hw_init(struct scsi_host_template *tpnt, struct
 				aha1542_out(base_io, offcmd, 2);
 				WAIT(INTRFLAGS(base_io), INTRMASK, HACC, 0);
 				if (setup_dmaspeed[indx] >= 0) {
-					unchar dmacmd[] = {CMD_DMASPEED, 0};
+					u8 dmacmd[] = {CMD_DMASPEED, 0};
 					dmacmd[1] = setup_dmaspeed[indx];
 					aha1542_intr_reset(base_io);
 					aha1542_out(base_io, dmacmd, 2);
@@ -1103,11 +1103,11 @@ static int aha1542_dev_reset(Scsi_Cmnd * SCpnt)
 	struct aha1542_hostdata *aha1542 = shost_priv(SCpnt->device->host);
 	unsigned long flags;
 	struct mailbox *mb = aha1542->mb;
-	unchar target = SCpnt->device->id;
-	unchar lun = SCpnt->device->lun;
+	u8 target = SCpnt->device->id;
+	u8 lun = SCpnt->device->lun;
 	int mbo;
 	struct ccb *ccb = aha1542->ccb;
-	unchar ahacmd = CMD_START_SCSI;
+	u8 ahacmd = CMD_START_SCSI;
 
 	spin_lock_irqsave(&aha1542_lock, flags);
 	mbo = aha1542->aha1542_last_mbo_used + 1;

commit f1bbef63442f36f5a0fc91f73da104aa8a39a873
Author: Ondrej Zary <linux@rainbow-software.org>
Date:   Fri Feb 6 23:11:26 2015 +0100

    aha1542: Convert aha1542_intr_reset to function
    
    Convert aha1542_intr_reset macro to inline function
    
    Signed-off-by: Ondrej Zary <linux@rainbow-software.org>
    Reviewed-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: James Bottomley <JBottomley@Odin.com>

diff --git a/drivers/scsi/aha1542.c b/drivers/scsi/aha1542.c
index ebf54b5c3f2b..2a6308f28d9f 100644
--- a/drivers/scsi/aha1542.c
+++ b/drivers/scsi/aha1542.c
@@ -128,7 +128,10 @@ static void setup_mailboxes(int base_io, struct Scsi_Host *shpnt);
 static int aha1542_restart(struct Scsi_Host *shost);
 static void aha1542_intr_handle(struct Scsi_Host *shost);
 
-#define aha1542_intr_reset(base)  outb(IRST, CONTROL(base))
+static inline void aha1542_intr_reset(u16 base)
+{
+	outb(IRST, CONTROL(base));
+}
 
 #define WAIT(port, mask, allof, noneof)					\
  { register int WAITbits;						\

commit e98878f737293d8c43e5e5982f3cd4317c423ba5
Author: Ondrej Zary <linux@rainbow-software.org>
Date:   Fri Feb 6 23:11:25 2015 +0100

    aha1542: Remove HOSTDATA macro
    
    Remove HOSTDATA macro and use shost_priv instead
    
    Signed-off-by: Ondrej Zary <linux@rainbow-software.org>
    Reviewed-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: James Bottomley <JBottomley@Odin.com>

diff --git a/drivers/scsi/aha1542.c b/drivers/scsi/aha1542.c
index 197480de2152..ebf54b5c3f2b 100644
--- a/drivers/scsi/aha1542.c
+++ b/drivers/scsi/aha1542.c
@@ -118,8 +118,6 @@ struct aha1542_hostdata {
 	struct ccb ccb[AHA1542_MAILBOXES];
 };
 
-#define HOSTDATA(host) ((struct aha1542_hostdata *) &host->hostdata)
-
 static DEFINE_SPINLOCK(aha1542_lock);
 
 
@@ -382,6 +380,7 @@ static irqreturn_t do_aha1542_intr_handle(int dummy, void *dev_id)
 /* A "high" level interrupt handler */
 static void aha1542_intr_handle(struct Scsi_Host *shost)
 {
+	struct aha1542_hostdata *aha1542 = shost_priv(shost);
 	void (*my_done) (Scsi_Cmnd *) = NULL;
 	int errstatus, mbi, mbo, mbistatus;
 	int number_serviced;
@@ -389,11 +388,8 @@ static void aha1542_intr_handle(struct Scsi_Host *shost)
 	Scsi_Cmnd *SCtmp;
 	int flag;
 	int needs_restart;
-	struct mailbox *mb;
-	struct ccb *ccb;
-
-	mb = HOSTDATA(shost)->mb;
-	ccb = HOSTDATA(shost)->ccb;
+	struct mailbox *mb = aha1542->mb;
+	struct ccb *ccb = aha1542->ccb;
 
 #ifdef DEBUG
 	{
@@ -435,7 +431,7 @@ static void aha1542_intr_handle(struct Scsi_Host *shost)
 		aha1542_intr_reset(shost->io_port);
 
 		spin_lock_irqsave(&aha1542_lock, flags);
-		mbi = HOSTDATA(shost)->aha1542_last_mbi_used + 1;
+		mbi = aha1542->aha1542_last_mbi_used + 1;
 		if (mbi >= 2 * AHA1542_MAILBOXES)
 			mbi = AHA1542_MAILBOXES;
 
@@ -445,7 +441,7 @@ static void aha1542_intr_handle(struct Scsi_Host *shost)
 			mbi++;
 			if (mbi >= 2 * AHA1542_MAILBOXES)
 				mbi = AHA1542_MAILBOXES;
-		} while (mbi != HOSTDATA(shost)->aha1542_last_mbi_used);
+		} while (mbi != aha1542->aha1542_last_mbi_used);
 
 		if (mb[mbi].status == 0) {
 			spin_unlock_irqrestore(&aha1542_lock, flags);
@@ -462,7 +458,7 @@ static void aha1542_intr_handle(struct Scsi_Host *shost)
 		mbo = (scsi2int(mb[mbi].ccbptr) - (isa_virt_to_bus(&ccb[0]))) / sizeof(struct ccb);
 		mbistatus = mb[mbi].status;
 		mb[mbi].status = 0;
-		HOSTDATA(shost)->aha1542_last_mbi_used = mbi;
+		aha1542->aha1542_last_mbi_used = mbi;
 		spin_unlock_irqrestore(&aha1542_lock, flags);
 
 #ifdef DEBUG
@@ -480,7 +476,7 @@ static void aha1542_intr_handle(struct Scsi_Host *shost)
 		printk(KERN_DEBUG "...done %d %d\n", mbo, mbi);
 #endif
 
-		SCtmp = HOSTDATA(shost)->SCint[mbo];
+		SCtmp = aha1542->SCint[mbo];
 
 		if (!SCtmp || !SCtmp->scsi_done) {
 			printk(KERN_WARNING "aha1542_intr_handle: Unexpected interrupt\n");
@@ -533,8 +529,8 @@ static void aha1542_intr_handle(struct Scsi_Host *shost)
 		}
 		DEB(if (errstatus) printk("aha1542_intr_handle: returning %6x\n", errstatus));
 		SCtmp->result = errstatus;
-		HOSTDATA(shost)->SCint[mbo] = NULL;	/* This effectively frees up the mailbox slot, as
-							   far as queuecommand is concerned */
+		aha1542->SCint[mbo] = NULL;	/* This effectively frees up the mailbox slot, as
+						   far as queuecommand is concerned */
 		my_done(SCtmp);
 		number_serviced++;
 	};
@@ -542,6 +538,7 @@ static void aha1542_intr_handle(struct Scsi_Host *shost)
 
 static int aha1542_queuecommand_lck(Scsi_Cmnd * SCpnt, void (*done) (Scsi_Cmnd *))
 {
+	struct aha1542_hostdata *aha1542 = shost_priv(SCpnt->device->host);
 	unchar ahacmd = CMD_START_SCSI;
 	unchar direction;
 	unchar *cmd = (unchar *) SCpnt->cmnd;
@@ -550,14 +547,11 @@ static int aha1542_queuecommand_lck(Scsi_Cmnd * SCpnt, void (*done) (Scsi_Cmnd *
 	unsigned long flags;
 	int bufflen = scsi_bufflen(SCpnt);
 	int mbo;
-	struct mailbox *mb;
-	struct ccb *ccb;
+	struct mailbox *mb = aha1542->mb;
+	struct ccb *ccb = aha1542->ccb;
 
 	DEB(int i);
 
-	mb = HOSTDATA(SCpnt->device->host)->mb;
-	ccb = HOSTDATA(SCpnt->device->host)->ccb;
-
 	DEB(if (target > 1) {
 	    SCpnt->result = DID_TIME_OUT << 16;
 	    done(SCpnt); return 0;
@@ -593,25 +587,25 @@ static int aha1542_queuecommand_lck(Scsi_Cmnd * SCpnt, void (*done) (Scsi_Cmnd *
 	   is how the host adapter will scan for them */
 
 	spin_lock_irqsave(&aha1542_lock, flags);
-	mbo = HOSTDATA(SCpnt->device->host)->aha1542_last_mbo_used + 1;
+	mbo = aha1542->aha1542_last_mbo_used + 1;
 	if (mbo >= AHA1542_MAILBOXES)
 		mbo = 0;
 
 	do {
-		if (mb[mbo].status == 0 && HOSTDATA(SCpnt->device->host)->SCint[mbo] == NULL)
+		if (mb[mbo].status == 0 && aha1542->SCint[mbo] == NULL)
 			break;
 		mbo++;
 		if (mbo >= AHA1542_MAILBOXES)
 			mbo = 0;
-	} while (mbo != HOSTDATA(SCpnt->device->host)->aha1542_last_mbo_used);
+	} while (mbo != aha1542->aha1542_last_mbo_used);
 
-	if (mb[mbo].status || HOSTDATA(SCpnt->device->host)->SCint[mbo])
+	if (mb[mbo].status || aha1542->SCint[mbo])
 		panic("Unable to find empty mailbox for aha1542.\n");
 
-	HOSTDATA(SCpnt->device->host)->SCint[mbo] = SCpnt;	/* This will effectively prevent someone else from
-							   screwing with this cdb. */
+	aha1542->SCint[mbo] = SCpnt;	/* This will effectively prevent someone else from
+					   screwing with this cdb. */
 
-	HOSTDATA(SCpnt->device->host)->aha1542_last_mbo_used = mbo;
+	aha1542->aha1542_last_mbo_used = mbo;
 	spin_unlock_irqrestore(&aha1542_lock, flags);
 
 #ifdef DEBUG
@@ -645,7 +639,7 @@ static int aha1542_queuecommand_lck(Scsi_Cmnd * SCpnt, void (*done) (Scsi_Cmnd *
 		cptr = (struct chain *) SCpnt->host_scribble;
 		if (cptr == NULL) {
 			/* free the claimed mailbox slot */
-			HOSTDATA(SCpnt->device->host)->SCint[mbo] = NULL;
+			aha1542->SCint[mbo] = NULL;
 			return SCSI_MLQUEUE_HOST_BUSY;
 		}
 		scsi_for_each_sg(SCpnt, sg, sg_count, i) {
@@ -699,15 +693,13 @@ static DEF_SCSI_QCMD(aha1542_queuecommand)
 /* Initialize mailboxes */
 static void setup_mailboxes(int bse, struct Scsi_Host *shpnt)
 {
+	struct aha1542_hostdata *aha1542 = shost_priv(shpnt);
 	int i;
-	struct mailbox *mb;
-	struct ccb *ccb;
+	struct mailbox *mb = aha1542->mb;
+	struct ccb *ccb = aha1542->ccb;
 
 	unchar cmd[5] = { CMD_MBINIT, AHA1542_MAILBOXES, 0, 0, 0};
 
-	mb = HOSTDATA(shpnt)->mb;
-	ccb = HOSTDATA(shpnt)->ccb;
-
 	for (i = 0; i < AHA1542_MAILBOXES; i++) {
 		mb[i].status = mb[AHA1542_MAILBOXES + i].status = 0;
 		any2scsi(mb[i].ccbptr, isa_virt_to_bus(&ccb[i]));
@@ -951,6 +943,7 @@ static struct Scsi_Host *aha1542_hw_init(struct scsi_host_template *tpnt, struct
 	unsigned int base_io;
 	int trans;
 	struct Scsi_Host *shpnt = NULL;
+	struct aha1542_hostdata *aha1542;
 
 	DEB(printk("aha1542_detect: \n"));
 
@@ -964,6 +957,7 @@ static struct Scsi_Host *aha1542_hw_init(struct scsi_host_template *tpnt, struct
 				release_region(bases[indx], 4);
 				return NULL;
 			}
+			aha1542 = shost_priv(shpnt);
 			if (!aha1542_test_port(bases[indx], shpnt))
 				goto unregister;
 
@@ -1040,12 +1034,12 @@ static struct Scsi_Host *aha1542_hw_init(struct scsi_host_template *tpnt, struct
 			shpnt->n_io_port = 4;	/* Number of bytes of I/O space used */
 			shpnt->dma_channel = dma_chan;
 			shpnt->irq = irq_level;
-			HOSTDATA(shpnt)->bios_translation = trans;
+			aha1542->bios_translation = trans;
 			if (trans == BIOS_TRANSLATION_25563)
 				printk(KERN_INFO "aha1542.c: Using extended bios translation\n");
-			HOSTDATA(shpnt)->aha1542_last_mbi_used = (2 * AHA1542_MAILBOXES - 1);
-			HOSTDATA(shpnt)->aha1542_last_mbo_used = (AHA1542_MAILBOXES - 1);
-			memset(HOSTDATA(shpnt)->SCint, 0, sizeof(HOSTDATA(shpnt)->SCint));
+			aha1542->aha1542_last_mbi_used = (2 * AHA1542_MAILBOXES - 1);
+			aha1542->aha1542_last_mbo_used = (AHA1542_MAILBOXES - 1);
+			memset(aha1542->SCint, 0, sizeof(aha1542->SCint));
 			spin_unlock_irqrestore(&aha1542_lock, flags);
 
 			if (scsi_add_host(shpnt, pdev)) {
@@ -1083,12 +1077,13 @@ static int aha1542_release(struct Scsi_Host *shost)
 
 static int aha1542_restart(struct Scsi_Host *shost)
 {
+	struct aha1542_hostdata *aha1542 = shost_priv(shost);
 	int i;
 	int count = 0;
 
 	for (i = 0; i < AHA1542_MAILBOXES; i++)
-		if (HOSTDATA(shost)->SCint[i] &&
-		    !(HOSTDATA(shost)->SCint[i]->device->soft_reset)) {
+		if (aha1542->SCint[i] &&
+		    !(aha1542->SCint[i]->device->soft_reset)) {
 			count++;
 		}
 	printk(KERN_DEBUG "Potential to restart %d stalled commands...\n", count);
@@ -1102,38 +1097,36 @@ static int aha1542_restart(struct Scsi_Host *shost)
  */
 static int aha1542_dev_reset(Scsi_Cmnd * SCpnt)
 {
+	struct aha1542_hostdata *aha1542 = shost_priv(SCpnt->device->host);
 	unsigned long flags;
-	struct mailbox *mb;
+	struct mailbox *mb = aha1542->mb;
 	unchar target = SCpnt->device->id;
 	unchar lun = SCpnt->device->lun;
 	int mbo;
-	struct ccb *ccb;
+	struct ccb *ccb = aha1542->ccb;
 	unchar ahacmd = CMD_START_SCSI;
 
-	ccb = HOSTDATA(SCpnt->device->host)->ccb;
-	mb = HOSTDATA(SCpnt->device->host)->mb;
-
 	spin_lock_irqsave(&aha1542_lock, flags);
-	mbo = HOSTDATA(SCpnt->device->host)->aha1542_last_mbo_used + 1;
+	mbo = aha1542->aha1542_last_mbo_used + 1;
 	if (mbo >= AHA1542_MAILBOXES)
 		mbo = 0;
 
 	do {
-		if (mb[mbo].status == 0 && HOSTDATA(SCpnt->device->host)->SCint[mbo] == NULL)
+		if (mb[mbo].status == 0 && aha1542->SCint[mbo] == NULL)
 			break;
 		mbo++;
 		if (mbo >= AHA1542_MAILBOXES)
 			mbo = 0;
-	} while (mbo != HOSTDATA(SCpnt->device->host)->aha1542_last_mbo_used);
+	} while (mbo != aha1542->aha1542_last_mbo_used);
 
-	if (mb[mbo].status || HOSTDATA(SCpnt->device->host)->SCint[mbo])
+	if (mb[mbo].status || aha1542->SCint[mbo])
 		panic("Unable to find empty mailbox for aha1542.\n");
 
-	HOSTDATA(SCpnt->device->host)->SCint[mbo] = SCpnt;	/* This will effectively
-							   prevent someone else from
-							   screwing with this cdb. */
+	aha1542->SCint[mbo] = SCpnt;	/* This will effectively
+					   prevent someone else from
+					   screwing with this cdb. */
 
-	HOSTDATA(SCpnt->device->host)->aha1542_last_mbo_used = mbo;
+	aha1542->aha1542_last_mbo_used = mbo;
 	spin_unlock_irqrestore(&aha1542_lock, flags);
 
 	any2scsi(mb[mbo].ccbptr, isa_virt_to_bus(&ccb[mbo]));	/* This gets trashed for some reason */
@@ -1161,6 +1154,7 @@ static int aha1542_dev_reset(Scsi_Cmnd * SCpnt)
 
 static int aha1542_bus_reset(Scsi_Cmnd * SCpnt)
 {
+	struct aha1542_hostdata *aha1542 = shost_priv(SCpnt->device->host);
 	int i;
 
 	/* 
@@ -1194,9 +1188,9 @@ static int aha1542_bus_reset(Scsi_Cmnd * SCpnt)
 	printk(KERN_WARNING "Sent BUS RESET to scsi host %d\n", SCpnt->device->host->host_no);
 
 	for (i = 0; i < AHA1542_MAILBOXES; i++) {
-		if (HOSTDATA(SCpnt->device->host)->SCint[i] != NULL) {
+		if (aha1542->SCint[i] != NULL) {
 			Scsi_Cmnd *SCtmp;
-			SCtmp = HOSTDATA(SCpnt->device->host)->SCint[i];
+			SCtmp = aha1542->SCint[i];
 
 
 			if (SCtmp->device->soft_reset) {
@@ -1210,8 +1204,8 @@ static int aha1542_bus_reset(Scsi_Cmnd * SCpnt)
 			}
 			kfree(SCtmp->host_scribble);
 			SCtmp->host_scribble = NULL;
-			HOSTDATA(SCpnt->device->host)->SCint[i] = NULL;
-			HOSTDATA(SCpnt->device->host)->mb[i].status = 0;
+			aha1542->SCint[i] = NULL;
+			aha1542->mb[i].status = 0;
 		}
 	}
 
@@ -1225,6 +1219,7 @@ static int aha1542_bus_reset(Scsi_Cmnd * SCpnt)
 
 static int aha1542_host_reset(Scsi_Cmnd * SCpnt)
 {
+	struct aha1542_hostdata *aha1542 = shost_priv(SCpnt->device->host);
 	int i;
 
 	/* 
@@ -1263,9 +1258,9 @@ static int aha1542_host_reset(Scsi_Cmnd * SCpnt)
 	printk(KERN_WARNING "Sent BUS RESET to scsi host %d\n", SCpnt->device->host->host_no);
 
 	for (i = 0; i < AHA1542_MAILBOXES; i++) {
-		if (HOSTDATA(SCpnt->device->host)->SCint[i] != NULL) {
+		if (aha1542->SCint[i] != NULL) {
 			Scsi_Cmnd *SCtmp;
-			SCtmp = HOSTDATA(SCpnt->device->host)->SCint[i];
+			SCtmp = aha1542->SCint[i];
 
 			if (SCtmp->device->soft_reset) {
 				/*
@@ -1278,8 +1273,8 @@ static int aha1542_host_reset(Scsi_Cmnd * SCpnt)
 			}
 			kfree(SCtmp->host_scribble);
 			SCtmp->host_scribble = NULL;
-			HOSTDATA(SCpnt->device->host)->SCint[i] = NULL;
-			HOSTDATA(SCpnt->device->host)->mb[i].status = 0;
+			aha1542->SCint[i] = NULL;
+			aha1542->mb[i].status = 0;
 		}
 	}
 
@@ -1294,10 +1289,11 @@ static int aha1542_host_reset(Scsi_Cmnd * SCpnt)
 static int aha1542_biosparam(struct scsi_device *sdev,
 		struct block_device *bdev, sector_t capacity, int *ip)
 {
+	struct aha1542_hostdata *aha1542 = shost_priv(sdev->host);
 	int translation_algorithm;
 	int size = capacity;
 
-	translation_algorithm = HOSTDATA(sdev->host)->bios_translation;
+	translation_algorithm = aha1542->bios_translation;
 
 	if ((size >> 11) > 1024 && translation_algorithm == BIOS_TRANSLATION_25563) {
 		/* Please verify that this is the same as what DOS returns */

commit 10be62506f5dd8013bf76f168c89ed4f7608c4d4
Author: Ondrej Zary <linux@rainbow-software.org>
Date:   Fri Feb 6 23:11:24 2015 +0100

    aha1542: Remove SCSI_BUF_PA, SCSI_SG_PA, AHA1542_SCATTER and AHA1542_CMDLUN
    
    Signed-off-by: Ondrej Zary <linux@rainbow-software.org>
    Reviewed-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: James Bottomley <JBottomley@Odin.com>

diff --git a/drivers/scsi/aha1542.c b/drivers/scsi/aha1542.c
index 506e33e9440f..197480de2152 100644
--- a/drivers/scsi/aha1542.c
+++ b/drivers/scsi/aha1542.c
@@ -46,10 +46,6 @@
 #include "scsi.h"
 #include <scsi/scsi_host.h>
 #include "aha1542.h"
-
-#define SCSI_BUF_PA(address)	isa_virt_to_bus(address)
-#define SCSI_SG_PA(sgent)	(isa_page_to_bus(sg_page((sgent))) + (sgent)->offset)
-
 #include <linux/stat.h>
 
 #ifdef DEBUG
@@ -463,7 +459,7 @@ static void aha1542_intr_handle(struct Scsi_Host *shost)
 			return;
 		};
 
-		mbo = (scsi2int(mb[mbi].ccbptr) - (SCSI_BUF_PA(&ccb[0]))) / sizeof(struct ccb);
+		mbo = (scsi2int(mb[mbi].ccbptr) - (isa_virt_to_bus(&ccb[0]))) / sizeof(struct ccb);
 		mbistatus = mb[mbi].status;
 		mb[mbi].status = 0;
 		HOSTDATA(shost)->aha1542_last_mbi_used = mbi;
@@ -622,7 +618,7 @@ static int aha1542_queuecommand_lck(Scsi_Cmnd * SCpnt, void (*done) (Scsi_Cmnd *
 	printk(KERN_DEBUG "Sending command (%d %x)...", mbo, done);
 #endif
 
-	any2scsi(mb[mbo].ccbptr, SCSI_BUF_PA(&ccb[mbo]));	/* This gets trashed for some reason */
+	any2scsi(mb[mbo].ccbptr, isa_virt_to_bus(&ccb[mbo]));	/* This gets trashed for some reason */
 
 	memset(&ccb[mbo], 0, sizeof(struct ccb));
 
@@ -653,11 +649,12 @@ static int aha1542_queuecommand_lck(Scsi_Cmnd * SCpnt, void (*done) (Scsi_Cmnd *
 			return SCSI_MLQUEUE_HOST_BUSY;
 		}
 		scsi_for_each_sg(SCpnt, sg, sg_count, i) {
-			any2scsi(cptr[i].dataptr, SCSI_SG_PA(sg));
+			any2scsi(cptr[i].dataptr, isa_page_to_bus(sg_page(sg))
+								+ sg->offset);
 			any2scsi(cptr[i].datalen, sg->length);
 		};
 		any2scsi(ccb[mbo].datalen, sg_count * sizeof(struct chain));
-		any2scsi(ccb[mbo].dataptr, SCSI_BUF_PA(cptr));
+		any2scsi(ccb[mbo].dataptr, isa_virt_to_bus(cptr));
 #ifdef DEBUG
 		printk("cptr %x: ", cptr);
 		ptr = (unsigned char *) cptr;
@@ -713,10 +710,10 @@ static void setup_mailboxes(int bse, struct Scsi_Host *shpnt)
 
 	for (i = 0; i < AHA1542_MAILBOXES; i++) {
 		mb[i].status = mb[AHA1542_MAILBOXES + i].status = 0;
-		any2scsi(mb[i].ccbptr, SCSI_BUF_PA(&ccb[i]));
+		any2scsi(mb[i].ccbptr, isa_virt_to_bus(&ccb[i]));
 	};
 	aha1542_intr_reset(bse);	/* reset interrupts, so they don't block */
-	any2scsi((cmd + 2), SCSI_BUF_PA(mb));
+	any2scsi((cmd + 2), isa_virt_to_bus(mb));
 	aha1542_out(bse, cmd, 5);
 	WAIT(INTRFLAGS(bse), INTRMASK, HACC, 0);
 	while (0) {
@@ -1139,7 +1136,7 @@ static int aha1542_dev_reset(Scsi_Cmnd * SCpnt)
 	HOSTDATA(SCpnt->device->host)->aha1542_last_mbo_used = mbo;
 	spin_unlock_irqrestore(&aha1542_lock, flags);
 
-	any2scsi(mb[mbo].ccbptr, SCSI_BUF_PA(&ccb[mbo]));	/* This gets trashed for some reason */
+	any2scsi(mb[mbo].ccbptr, isa_virt_to_bus(&ccb[mbo]));	/* This gets trashed for some reason */
 
 	memset(&ccb[mbo], 0, sizeof(struct ccb));
 
@@ -1328,8 +1325,8 @@ static struct scsi_host_template driver_template = {
 	.bios_param		= aha1542_biosparam,
 	.can_queue		= AHA1542_MAILBOXES, 
 	.this_id		= 7,
-	.sg_tablesize		= AHA1542_SCATTER,
-	.cmd_per_lun		= AHA1542_CMDLUN,
+	.sg_tablesize		= 16,
+	.cmd_per_lun		= 1,
 	.unchecked_isa_dma	= 1, 
 	.use_clustering		= ENABLE_CLUSTERING,
 };

commit 6f82fbf3868712576f137ebdf0b9a72aa99b5935
Author: Ondrej Zary <linux@rainbow-software.org>
Date:   Fri Feb 6 23:11:23 2015 +0100

    aha1542: remove dead code
    
    Signed-off-by: Ondrej Zary <linux@rainbow-software.org>
    Reviewed-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: James Bottomley <JBottomley@Odin.com>

diff --git a/drivers/scsi/aha1542.c b/drivers/scsi/aha1542.c
index b7a62daff063..506e33e9440f 100644
--- a/drivers/scsi/aha1542.c
+++ b/drivers/scsi/aha1542.c
@@ -570,13 +570,6 @@ static int aha1542_queuecommand_lck(Scsi_Cmnd * SCpnt, void (*done) (Scsi_Cmnd *
 
 	if (*cmd == REQUEST_SENSE) {
 		/* Don't do the command - we have the sense data already */
-#if 0
-		/* scsi_request_sense() provides a buffer of size 256,
-		   so there is no reason to expect equality */
-		if (bufflen != SCSI_SENSE_BUFFERSIZE)
-			printk(KERN_CRIT "aha1542: Wrong buffer length supplied "
-			       "for request sense (%d)\n", bufflen);
-#endif
 		SCpnt->result = 0;
 		done(SCpnt);
 		return 0;
@@ -1095,24 +1088,14 @@ static int aha1542_restart(struct Scsi_Host *shost)
 {
 	int i;
 	int count = 0;
-#if 0
-	unchar ahacmd = CMD_START_SCSI;
-#endif
 
 	for (i = 0; i < AHA1542_MAILBOXES; i++)
 		if (HOSTDATA(shost)->SCint[i] &&
 		    !(HOSTDATA(shost)->SCint[i]->device->soft_reset)) {
-#if 0
-			HOSTDATA(shost)->mb[i].status = 1;	/* Indicate ready to restart... */
-#endif
 			count++;
 		}
 	printk(KERN_DEBUG "Potential to restart %d stalled commands...\n", count);
-#if 0
-	/* start scsi command */
-	if (count)
-		aha1542_out(shost->io_port, &ahacmd, 1);
-#endif
+
 	return 0;
 }
 
@@ -1177,39 +1160,6 @@ static int aha1542_dev_reset(Scsi_Cmnd * SCpnt)
 		"Trying device reset for target\n");
 
 	return SUCCESS;
-
-
-#ifdef ERIC_neverdef
-	/* 
-	 * With the 1542 we apparently never get an interrupt to
-	 * acknowledge a device reset being sent.  Then again, Leonard
-	 * says we are doing this wrong in the first place...
-	 *
-	 * Take a wait and see attitude.  If we get spurious interrupts,
-	 * then the device reset is doing something sane and useful, and
-	 * we will wait for the interrupt to post completion.
-	 */
-	printk(KERN_WARNING "Sent BUS DEVICE RESET to target %d\n", SCpnt->target);
-
-	/*
-	 * Free the command block for all commands running on this 
-	 * target... 
-	 */
-	for (i = 0; i < AHA1542_MAILBOXES; i++) {
-		if (HOSTDATA(SCpnt->host)->SCint[i] &&
-		    HOSTDATA(SCpnt->host)->SCint[i]->target == SCpnt->target) {
-			Scsi_Cmnd *SCtmp;
-			SCtmp = HOSTDATA(SCpnt->host)->SCint[i];
-			kfree(SCtmp->host_scribble);
-			SCtmp->host_scribble = NULL;
-			HOSTDATA(SCpnt->host)->SCint[i] = NULL;
-			HOSTDATA(SCpnt->host)->mb[i].status = 0;
-		}
-	}
-	return SUCCESS;
-
-	return FAILED;
-#endif				/* ERIC_neverdef */
 }
 
 static int aha1542_bus_reset(Scsi_Cmnd * SCpnt)
@@ -1344,197 +1294,6 @@ static int aha1542_host_reset(Scsi_Cmnd * SCpnt)
 	return FAILED;
 }
 
-#if 0
-/*
- * These are the old error handling routines.  They are only temporarily
- * here while we play with the new error handling code.
- */
-static int aha1542_old_abort(Scsi_Cmnd * SCpnt)
-{
-#if 0
-	unchar ahacmd = CMD_START_SCSI;
-	unsigned long flags;
-	struct mailbox *mb;
-	int mbi, mbo, i;
-
-	printk(KERN_DEBUG "In aha1542_abort: %x %x\n",
-	       inb(STATUS(SCpnt->host->io_port)),
-	       inb(INTRFLAGS(SCpnt->host->io_port)));
-
-	spin_lock_irqsave(&aha1542_lock, flags);
-	mb = HOSTDATA(SCpnt->host)->mb;
-	mbi = HOSTDATA(SCpnt->host)->aha1542_last_mbi_used + 1;
-	if (mbi >= 2 * AHA1542_MAILBOXES)
-		mbi = AHA1542_MAILBOXES;
-
-	do {
-		if (mb[mbi].status != 0)
-			break;
-		mbi++;
-		if (mbi >= 2 * AHA1542_MAILBOXES)
-			mbi = AHA1542_MAILBOXES;
-	} while (mbi != HOSTDATA(SCpnt->host)->aha1542_last_mbi_used);
-	spin_unlock_irqrestore(&aha1542_lock, flags);
-
-	if (mb[mbi].status) {
-		printk(KERN_ERR "Lost interrupt discovered on irq %d - attempting to recover\n",
-		       SCpnt->host->irq);
-		aha1542_intr_handle(SCpnt->host, NULL);
-		return 0;
-	}
-	/* OK, no lost interrupt.  Try looking to see how many pending commands
-	   we think we have. */
-
-	for (i = 0; i < AHA1542_MAILBOXES; i++)
-		if (HOSTDATA(SCpnt->host)->SCint[i]) {
-			if (HOSTDATA(SCpnt->host)->SCint[i] == SCpnt) {
-				printk(KERN_ERR "Timed out command pending for %s\n",
-				       SCpnt->request->rq_disk ?
-				       SCpnt->request->rq_disk->disk_name : "?"
-				       );
-				if (HOSTDATA(SCpnt->host)->mb[i].status) {
-					printk(KERN_ERR "OGMB still full - restarting\n");
-					aha1542_out(SCpnt->host->io_port, &ahacmd, 1);
-				};
-			} else
-				printk(KERN_ERR "Other pending command %s\n",
-				       SCpnt->request->rq_disk ?
-				       SCpnt->request->rq_disk->disk_name : "?"
-				       );
-		}
-#endif
-
-	DEB(printk("aha1542_abort\n"));
-#if 0
-	spin_lock_irqsave(&aha1542_lock, flags);
-	for (mbo = 0; mbo < AHA1542_MAILBOXES; mbo++) {
-		if (SCpnt == HOSTDATA(SCpnt->host)->SCint[mbo]) {
-			mb[mbo].status = 2;	/* Abort command */
-			aha1542_out(SCpnt->host->io_port, &ahacmd, 1);	/* start scsi command */
-			spin_unlock_irqrestore(&aha1542_lock, flags);
-			break;
-		}
-	}
-	if (AHA1542_MAILBOXES == mbo)
-		spin_unlock_irqrestore(&aha1542_lock, flags);
-#endif
-	return SCSI_ABORT_SNOOZE;
-}
-
-/* We do not implement a reset function here, but the upper level code
-   assumes that it will get some kind of response for the command in
-   SCpnt.  We must oblige, or the command will hang the scsi system.
-   For a first go, we assume that the 1542 notifies us with all of the
-   pending commands (it does implement soft reset, after all). */
-
-static int aha1542_old_reset(Scsi_Cmnd * SCpnt, unsigned int reset_flags)
-{
-	unchar ahacmd = CMD_START_SCSI;
-	int i;
-
-	/*
-	 * See if a bus reset was suggested.
-	 */
-	if (reset_flags & SCSI_RESET_SUGGEST_BUS_RESET) {
-		/* 
-		 * This does a scsi reset for all devices on the bus.
-		 * In principle, we could also reset the 1542 - should
-		 * we do this?  Try this first, and we can add that later
-		 * if it turns out to be useful.
-		 */
-		outb(HRST | SCRST, CONTROL(SCpnt->host->io_port));
-
-		/*
-		 * Wait for the thing to settle down a bit.  Unfortunately
-		 * this is going to basically lock up the machine while we
-		 * wait for this to complete.  To be 100% correct, we need to
-		 * check for timeout, and if we are doing something like this
-		 * we are pretty desperate anyways.
-		 */
-		WAIT(STATUS(SCpnt->host->io_port),
-		STATMASK, INIT | IDLE, STST | DIAGF | INVDCMD | DF | CDF);
-
-		/*
-		 * We need to do this too before the 1542 can interact with
-		 * us again.
-		 */
-		setup_mailboxes(SCpnt->host->io_port, SCpnt->host);
-
-		/*
-		 * Now try to pick up the pieces.  Restart all commands
-		 * that are currently active on the bus, and reset all of
-		 * the datastructures.  We have some time to kill while
-		 * things settle down, so print a nice message.
-		 */
-		printk(KERN_WARNING "Sent BUS RESET to scsi host %d\n", SCpnt->host->host_no);
-
-		for (i = 0; i < AHA1542_MAILBOXES; i++)
-			if (HOSTDATA(SCpnt->host)->SCint[i] != NULL) {
-				Scsi_Cmnd *SCtmp;
-				SCtmp = HOSTDATA(SCpnt->host)->SCint[i];
-				SCtmp->result = DID_RESET << 16;
-				kfree(SCtmp->host_scribble);
-				SCtmp->host_scribble = NULL;
-				printk(KERN_WARNING "Sending DID_RESET for target %d\n", SCpnt->target);
-				SCtmp->scsi_done(SCpnt);
-
-				HOSTDATA(SCpnt->host)->SCint[i] = NULL;
-				HOSTDATA(SCpnt->host)->mb[i].status = 0;
-			}
-		/*
-		 * Now tell the mid-level code what we did here.  Since
-		 * we have restarted all of the outstanding commands,
-		 * then report SUCCESS.
-		 */
-		return (SCSI_RESET_SUCCESS | SCSI_RESET_BUS_RESET);
-fail:
-		printk(KERN_CRIT "aha1542.c: Unable to perform hard reset.\n");
-		printk(KERN_CRIT "Power cycle machine to reset\n");
-		return (SCSI_RESET_ERROR | SCSI_RESET_BUS_RESET);
-
-
-	} else {
-		/* This does a selective reset of just the one device */
-		/* First locate the ccb for this command */
-		for (i = 0; i < AHA1542_MAILBOXES; i++)
-			if (HOSTDATA(SCpnt->host)->SCint[i] == SCpnt) {
-				HOSTDATA(SCpnt->host)->ccb[i].op = 0x81;	/* BUS DEVICE RESET */
-				/* Now tell the 1542 to flush all pending commands for this target */
-				aha1542_out(SCpnt->host->io_port, &ahacmd, 1);
-
-				/* Here is the tricky part.  What to do next.  Do we get an interrupt
-				   for the commands that we aborted with the specified target, or
-				   do we generate this on our own?  Try it without first and see
-				   what happens */
-				printk(KERN_WARNING "Sent BUS DEVICE RESET to target %d\n", SCpnt->target);
-
-				/* If the first does not work, then try the second.  I think the
-				   first option is more likely to be correct. Free the command
-				   block for all commands running on this target... */
-				for (i = 0; i < AHA1542_MAILBOXES; i++)
-					if (HOSTDATA(SCpnt->host)->SCint[i] &&
-					    HOSTDATA(SCpnt->host)->SCint[i]->target == SCpnt->target) {
-						Scsi_Cmnd *SCtmp;
-						SCtmp = HOSTDATA(SCpnt->host)->SCint[i];
-						SCtmp->result = DID_RESET << 16;
-						kfree(SCtmp->host_scribble);
-						SCtmp->host_scribble = NULL;
-						printk(KERN_WARNING "Sending DID_RESET for target %d\n", SCpnt->target);
-						SCtmp->scsi_done(SCpnt);
-
-						HOSTDATA(SCpnt->host)->SCint[i] = NULL;
-						HOSTDATA(SCpnt->host)->mb[i].status = 0;
-					}
-				return SCSI_RESET_SUCCESS;
-			}
-	}
-	/* No active command at this time, so this means that each time we got
-	   some kind of response the last time through.  Tell the mid-level code
-	   to request sense information in order to decide what to do next. */
-	return SCSI_RESET_PUNT;
-}
-#endif    /* end of big comment block around old_abort + old_reset */
-
 static int aha1542_biosparam(struct scsi_device *sdev,
 		struct block_device *bdev, sector_t capacity, int *ip)
 {

commit 643a7c43f11ee776701e06410d7b3f9a41e5d284
Author: Ondrej Zary <linux@rainbow-software.org>
Date:   Fri Feb 6 23:11:22 2015 +0100

    aha1542: Stop using scsi_module.c
    
    Convert aha1542 to use scsi_add_host instead of scsi_module.c
    Use pnp_driver and isa_driver to manage cards.
    
    Signed-off-by: Ondrej Zary <linux@rainbow-software.org>
    Reviewed-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: James Bottomley <JBottomley@Odin.com>

diff --git a/drivers/scsi/aha1542.c b/drivers/scsi/aha1542.c
index 770c48ddbe5e..b7a62daff063 100644
--- a/drivers/scsi/aha1542.c
+++ b/drivers/scsi/aha1542.c
@@ -35,7 +35,8 @@
 #include <linux/proc_fs.h>
 #include <linux/init.h>
 #include <linux/spinlock.h>
-#include <linux/isapnp.h>
+#include <linux/isa.h>
+#include <linux/pnp.h>
 #include <linux/blkdev.h>
 #include <linux/slab.h>
 
@@ -71,7 +72,7 @@
 
 /* Boards 3,4 slots are reserved for ISAPnP scans */
 
-static unsigned int bases[MAXBOARDS] __initdata = {0x330, 0x334, 0, 0};
+static unsigned int bases[MAXBOARDS] = {0x330, 0x334, 0, 0};
 
 /* set by aha1542_setup according to the command line; they also may
    be marked __initdata, but require zero initializers then */
@@ -79,7 +80,7 @@ static unsigned int bases[MAXBOARDS] __initdata = {0x330, 0x334, 0, 0};
 static int setup_called[MAXBOARDS];
 static int setup_buson[MAXBOARDS];
 static int setup_busoff[MAXBOARDS];
-static int setup_dmaspeed[MAXBOARDS] __initdata = { -1, -1, -1, -1 };
+static int setup_dmaspeed[MAXBOARDS] = { -1, -1, -1, -1 };
 
 /*
  * LILO/Module params:  aha1542=<PORTBASE>[,<BUSON>,<BUSOFF>[,<DMASPEED>]]
@@ -103,18 +104,6 @@ static bool isapnp = 0;
 static int aha1542[] = {0x330, 11, 4, -1};
 module_param_array(aha1542, int, NULL, 0);
 module_param(isapnp, bool, 0);
-
-static struct isapnp_device_id id_table[] __initdata = {
-	{
-		ISAPNP_ANY_ID, ISAPNP_ANY_ID,
-		ISAPNP_VENDOR('A', 'D', 'P'), ISAPNP_FUNCTION(0x1542),
-		0
-	},
-	{0}
-};
-
-MODULE_DEVICE_TABLE(isapnp, id_table);
-
 #else
 static int isapnp = 1;
 #endif
@@ -221,7 +210,7 @@ static int aha1542_out(unsigned int base, unchar * cmdp, int len)
 /* Only used at boot time, so we do not need to worry about latency as much
    here */
 
-static int __init aha1542_in(unsigned int base, unchar * cmdp, int len)
+static int aha1542_in(unsigned int base, unchar *cmdp, int len)
 {
 	unsigned long flags;
 
@@ -242,7 +231,7 @@ static int __init aha1542_in(unsigned int base, unchar * cmdp, int len)
 /* Similar to aha1542_in, except that we wait a very short period of time.
    We use this if we know the board is alive and awake, but we are not sure
    if the board will respond to the command we are about to send or not */
-static int __init aha1542_in1(unsigned int base, unchar * cmdp, int len)
+static int aha1542_in1(unsigned int base, unchar *cmdp, int len)
 {
 	unsigned long flags;
 
@@ -314,7 +303,7 @@ static int makecode(unsigned hosterr, unsigned scsierr)
 	return scsierr | (hosterr << 16);
 }
 
-static int __init aha1542_test_port(int bse, struct Scsi_Host *shpnt)
+static int aha1542_test_port(int bse, struct Scsi_Host *shpnt)
 {
 	unchar inquiry_cmd[] = {CMD_INQUIRY};
 	unchar inquiry_result[4];
@@ -744,7 +733,7 @@ static void setup_mailboxes(int bse, struct Scsi_Host *shpnt)
 	aha1542_intr_reset(bse);
 }
 
-static int __init aha1542_getconfig(int base_io, unsigned char *irq_level, unsigned char *dma_chan, unsigned char *scsi_id)
+static int aha1542_getconfig(int base_io, unsigned char *irq_level, unsigned char *dma_chan, unsigned char *scsi_id)
 {
 	unchar inquiry_cmd[] = {CMD_RETCONF};
 	unchar inquiry_result[3];
@@ -813,7 +802,7 @@ static int __init aha1542_getconfig(int base_io, unsigned char *irq_level, unsig
 /* This function should only be called for 1542C boards - we can detect
    the special firmware settings and unlock the board */
 
-static int __init aha1542_mbenable(int base)
+static int aha1542_mbenable(int base)
 {
 	static unchar mbenable_cmd[3];
 	static unchar mbenable_result[2];
@@ -848,7 +837,7 @@ static int __init aha1542_mbenable(int base)
 }
 
 /* Query the board to find out if it is a 1542 or a 1740, or whatever. */
-static int __init aha1542_query(int base_io, int *transl)
+static int aha1542_query(int base_io, int *transl)
 {
 	unchar inquiry_cmd[] = {CMD_INQUIRY};
 	unchar inquiry_result[4];
@@ -963,7 +952,7 @@ __setup("aha1542=",do_setup);
 #endif
 
 /* return non-zero on detection */
-static int __init aha1542_detect(struct scsi_host_template * tpnt)
+static struct Scsi_Host *aha1542_hw_init(struct scsi_host_template *tpnt, struct device *pdev, int indx)
 {
 	unsigned char dma_chan;
 	unsigned char irq_level;
@@ -972,87 +961,18 @@ static int __init aha1542_detect(struct scsi_host_template * tpnt)
 	unsigned int base_io;
 	int trans;
 	struct Scsi_Host *shpnt = NULL;
-	int count = 0;
-	int indx;
 
 	DEB(printk("aha1542_detect: \n"));
 
 	tpnt->proc_name = "aha1542";
 
-#ifdef MODULE
-	bases[0] = aha1542[0];
-	setup_buson[0] = aha1542[1];
-	setup_busoff[0] = aha1542[2];
-	{
-		int atbt = -1;
-		switch (aha1542[3]) {
-		case 5:
-			atbt = 0x00;
-			break;
-		case 6:
-			atbt = 0x04;
-			break;
-		case 7:
-			atbt = 0x01;
-			break;
-		case 8:
-			atbt = 0x02;
-			break;
-		case 10:
-			atbt = 0x03;
-			break;
-		};
-		setup_dmaspeed[0] = atbt;
-	}
-#endif
-
-	/*
-	 *	Hunt for ISA Plug'n'Pray Adaptecs (AHA1535)
-	 */
-
-	if(isapnp)
-	{
-		struct pnp_dev *pdev = NULL;
-		for(indx = 0; indx < ARRAY_SIZE(bases); indx++) {
-			if(bases[indx])
-				continue;
-			pdev = pnp_find_dev(NULL, ISAPNP_VENDOR('A', 'D', 'P'), 
-				ISAPNP_FUNCTION(0x1542), pdev);
-			if(pdev==NULL)
-				break;
-			/*
-			 *	Activate the PnP card
-			 */
-
-			if(pnp_device_attach(pdev)<0)
-				continue;
-
-			if(pnp_activate_dev(pdev)<0) {
-				pnp_device_detach(pdev);
-				continue;
-			}
-
-			if(!pnp_port_valid(pdev, 0)) {
-				pnp_device_detach(pdev);
-				continue;
-			}
-
-			bases[indx] = pnp_port_start(pdev, 0);
-
-			/* The card can be queried for its DMA, we have 
-			   the DMA set up that is enough */
-
-			printk(KERN_INFO "ISAPnP found an AHA1535 at I/O 0x%03X\n", bases[indx]);
-		}
-	}
-	for (indx = 0; indx < ARRAY_SIZE(bases); indx++)
 		if (bases[indx] != 0 && request_region(bases[indx], 4, "aha1542")) {
-			shpnt = scsi_register(tpnt,
+			shpnt = scsi_host_alloc(tpnt,
 					sizeof(struct aha1542_hostdata));
 
 			if(shpnt==NULL) {
 				release_region(bases[indx], 4);
-				continue;
+				return NULL;
 			}
 			if (!aha1542_test_port(bases[indx], shpnt))
 				goto unregister;
@@ -1137,60 +1057,37 @@ static int __init aha1542_detect(struct scsi_host_template * tpnt)
 			HOSTDATA(shpnt)->aha1542_last_mbo_used = (AHA1542_MAILBOXES - 1);
 			memset(HOSTDATA(shpnt)->SCint, 0, sizeof(HOSTDATA(shpnt)->SCint));
 			spin_unlock_irqrestore(&aha1542_lock, flags);
-#if 0
-			DEB(printk(" *** READ CAPACITY ***\n"));
 
-			{
-				unchar buf[8];
-				static unchar cmd[] = { READ_CAPACITY, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
-				int i;
-
-				for (i = 0; i < sizeof(buf); ++i)
-					buf[i] = 0x87;
-				for (i = 0; i < 2; ++i)
-					if (!aha1542_command(i, cmd, buf, sizeof(buf))) {
-						printk(KERN_DEBUG "aha_detect: LU %d sector_size %d device_size %d\n",
-						       i, xscsi2int(buf + 4), xscsi2int(buf));
-					}
+			if (scsi_add_host(shpnt, pdev)) {
+				if (shpnt->dma_channel != 0xff)
+					free_dma(shpnt->dma_channel);
+				free_irq(irq_level, shpnt);
+				goto unregister;
 			}
 
-			DEB(printk(" *** NOW RUNNING MY OWN TEST *** \n"));
+			scsi_scan_host(shpnt);
 
-			for (i = 0; i < 4; ++i) {
-				unsigned char cmd[10];
-				static buffer[512];
-
-				cmd[0] = READ_10;
-				cmd[1] = 0;
-				xany2scsi(cmd + 2, i);
-				cmd[6] = 0;
-				cmd[7] = 0;
-				cmd[8] = 1;
-				cmd[9] = 0;
-				aha1542_command(0, cmd, buffer, 512);
-			}
-#endif
-			count++;
-			continue;
+			return shpnt;
 unregister:
 			release_region(bases[indx], 4);
-			scsi_unregister(shpnt);
-			continue;
+			scsi_host_put(shpnt);
+			return NULL;
 
 		};
 
-	return count;
+	return NULL;
 }
 
 static int aha1542_release(struct Scsi_Host *shost)
 {
+	scsi_remove_host(shost);
 	if (shost->irq)
 		free_irq(shost->irq, shost);
 	if (shost->dma_channel != 0xff)
 		free_dma(shost->dma_channel);
 	if (shost->io_port && shost->n_io_port)
 		release_region(shost->io_port, shost->n_io_port);
-	scsi_unregister(shost);
+	scsi_host_put(shost);
 	return 0;
 }
 
@@ -1661,12 +1558,10 @@ static int aha1542_biosparam(struct scsi_device *sdev,
 }
 MODULE_LICENSE("GPL");
 
-
 static struct scsi_host_template driver_template = {
+	.module			= THIS_MODULE,
 	.proc_name		= "aha1542",
 	.name			= "Adaptec 1542",
-	.detect			= aha1542_detect,
-	.release		= aha1542_release,
 	.queuecommand		= aha1542_queuecommand,
 	.eh_device_reset_handler= aha1542_dev_reset,
 	.eh_bus_reset_handler	= aha1542_bus_reset,
@@ -1679,4 +1574,145 @@ static struct scsi_host_template driver_template = {
 	.unchecked_isa_dma	= 1, 
 	.use_clustering		= ENABLE_CLUSTERING,
 };
-#include "scsi_module.c"
+
+static int aha1542_isa_match(struct device *pdev, unsigned int ndev)
+{
+	struct Scsi_Host *sh = aha1542_hw_init(&driver_template, pdev, ndev);
+
+	if (!sh)
+		return 0;
+
+	dev_set_drvdata(pdev, sh);
+	return 1;
+}
+
+static int aha1542_isa_remove(struct device *pdev,
+				    unsigned int ndev)
+{
+	aha1542_release(dev_get_drvdata(pdev));
+	dev_set_drvdata(pdev, NULL);
+	return 0;
+}
+
+static struct isa_driver aha1542_isa_driver = {
+	.match		= aha1542_isa_match,
+	.remove		= aha1542_isa_remove,
+	.driver		= {
+		.name	= "aha1542"
+	},
+};
+static int isa_registered;
+
+#ifdef CONFIG_PNP
+static struct pnp_device_id aha1542_pnp_ids[] = {
+	{ .id = "ADP1542" },
+	{ .id = "" }
+};
+MODULE_DEVICE_TABLE(pnp, aha1542_pnp_ids);
+
+static int aha1542_pnp_probe(struct pnp_dev *pdev, const struct pnp_device_id *id)
+{
+	int indx;
+	struct Scsi_Host *sh;
+
+	for (indx = 0; indx < ARRAY_SIZE(bases); indx++) {
+		if (bases[indx])
+			continue;
+
+		if (pnp_activate_dev(pdev) < 0)
+			continue;
+
+		bases[indx] = pnp_port_start(pdev, 0);
+
+		/* The card can be queried for its DMA, we have
+		   the DMA set up that is enough */
+
+		printk(KERN_INFO "ISAPnP found an AHA1535 at I/O 0x%03X\n", bases[indx]);
+	}
+
+	sh = aha1542_hw_init(&driver_template, &pdev->dev, indx);
+	if (!sh)
+		return -ENODEV;
+
+	pnp_set_drvdata(pdev, sh);
+	return 0;
+}
+
+static void aha1542_pnp_remove(struct pnp_dev *pdev)
+{
+	aha1542_release(pnp_get_drvdata(pdev));
+	pnp_set_drvdata(pdev, NULL);
+}
+
+static struct pnp_driver aha1542_pnp_driver = {
+	.name		= "aha1542",
+	.id_table	= aha1542_pnp_ids,
+	.probe		= aha1542_pnp_probe,
+	.remove		= aha1542_pnp_remove,
+};
+static int pnp_registered;
+#endif /* CONFIG_PNP */
+
+static int __init aha1542_init(void)
+{
+	int ret = 0;
+#ifdef MODULE
+	int atbt = -1;
+
+	bases[0] = aha1542[0];
+	setup_buson[0] = aha1542[1];
+	setup_busoff[0] = aha1542[2];
+
+	switch (aha1542[3]) {
+	case 5:
+		atbt = 0x00;
+		break;
+	case 6:
+		atbt = 0x04;
+		break;
+	case 7:
+		atbt = 0x01;
+		break;
+	case 8:
+		atbt = 0x02;
+		break;
+	case 10:
+		atbt = 0x03;
+		break;
+	};
+	setup_dmaspeed[0] = atbt;
+#endif
+
+#ifdef CONFIG_PNP
+	if (isapnp) {
+		ret = pnp_register_driver(&aha1542_pnp_driver);
+		if (!ret)
+			pnp_registered = 1;
+	}
+#endif
+	ret = isa_register_driver(&aha1542_isa_driver, MAXBOARDS);
+	if (!ret)
+		isa_registered = 1;
+
+#ifdef CONFIG_PNP
+	if (pnp_registered)
+		ret = 0;
+#endif
+	if (isa_registered)
+		ret = 0;
+
+	return ret;
+}
+
+static void __exit aha1542_exit(void)
+{
+#ifdef CONFIG_PNP
+	if (pnp_registered)
+		pnp_unregister_driver(&aha1542_pnp_driver);
+#endif
+	if (isa_registered)
+		isa_unregister_driver(&aha1542_isa_driver);
+}
+
+module_init(aha1542_init);
+module_exit(aha1542_exit);

commit 6ac7d11527a31d01b566a5c45369180e326ff4f1
Author: Paul Bolle <pebolle@tiscali.nl>
Date:   Wed Jun 6 14:17:46 2012 +0200

    treewide: Put a space between #include and FILE
    
    Signed-off-by: Paul Bolle <pebolle@tiscali.nl>
    Signed-off-by: Jiri Kosina <jkosina@suse.cz>

diff --git a/drivers/scsi/aha1542.c b/drivers/scsi/aha1542.c
index f79c8f9e33a4..770c48ddbe5e 100644
--- a/drivers/scsi/aha1542.c
+++ b/drivers/scsi/aha1542.c
@@ -49,7 +49,7 @@
 #define SCSI_BUF_PA(address)	isa_virt_to_bus(address)
 #define SCSI_SG_PA(sgent)	(isa_page_to_bus(sg_page((sgent))) + (sgent)->offset)
 
-#include<linux/stat.h>
+#include <linux/stat.h>
 
 #ifdef DEBUG
 #define DEB(x) x

commit a88dc06cd515b3bb9dfa18606e88d0be9a5b6ddd
Author: Paul Gortmaker <paul.gortmaker@windriver.com>
Date:   Wed May 16 20:33:52 2012 -0400

    scsi: delete the MCA specific drivers and driver code
    
    The support for CONFIG_MCA is being removed, since the 20
    year old hardware simply isn't capable of meeting today's
    software demands on CPU and memory resources.
    
    This commit removes the MCA specific SCSI drivers, and the
    MCA specific portions of code in dual role ISA/MCA drivers.
    Also, the MCA specific SCSI documentation is removed.
    
    Cc: James Bottomley <JBottomley@parallels.com>
    Cc: linux-scsi@vger.kernel.org
    Signed-off-by: Paul Gortmaker <paul.gortmaker@windriver.com>

diff --git a/drivers/scsi/aha1542.c b/drivers/scsi/aha1542.c
index ede91f378000..f79c8f9e33a4 100644
--- a/drivers/scsi/aha1542.c
+++ b/drivers/scsi/aha1542.c
@@ -22,7 +22,7 @@
  *        Added module command-line options
  *        19-Jul-99
  *  Modified by Adam Fritzler
- *        Added proper detection of the AHA-1640 (MCA version of AHA-1540)
+ *        Added proper detection of the AHA-1640 (MCA, now deleted)
  */
 
 #include <linux/module.h>
@@ -37,8 +37,6 @@
 #include <linux/spinlock.h>
 #include <linux/isapnp.h>
 #include <linux/blkdev.h>
-#include <linux/mca.h>
-#include <linux/mca-legacy.h>
 #include <linux/slab.h>
 
 #include <asm/dma.h>
@@ -71,7 +69,7 @@
 #define MAXBOARDS 4		/* Increase this and the sizes of the
 				   arrays below, if you need more.. */
 
-/* Boards 3,4 slots are reserved for ISAPnP/MCA scans */
+/* Boards 3,4 slots are reserved for ISAPnP scans */
 
 static unsigned int bases[MAXBOARDS] __initdata = {0x330, 0x334, 0, 0};
 
@@ -1008,66 +1006,6 @@ static int __init aha1542_detect(struct scsi_host_template * tpnt)
 	}
 #endif
 
-	/*
-	 *	Find MicroChannel cards (AHA1640)
-	 */
-#ifdef CONFIG_MCA_LEGACY
-	if(MCA_bus) {
-		int slot = 0;
-		int pos = 0;
-
-		for (indx = 0; (slot != MCA_NOTFOUND) && (indx < ARRAY_SIZE(bases)); indx++) {
-
-			if (bases[indx])
-				continue;
-
-			/* Detect only AHA-1640 cards -- MCA ID 0F1F */
-			slot = mca_find_unused_adapter(0x0f1f, slot);
-			if (slot == MCA_NOTFOUND)
-				break;
-
-			/* Found one */
-			pos = mca_read_stored_pos(slot, 3);
-
-			/* Decode address */
-			if (pos & 0x80) {
-				if (pos & 0x02) {
-					if (pos & 0x01)
-						bases[indx] = 0x334;
-					else
-						bases[indx] = 0x234;
-				} else {
-					if (pos & 0x01)
-						bases[indx] = 0x134;
-				}
-			} else {
-				if (pos & 0x02) {
-					if (pos & 0x01)
-						bases[indx] = 0x330;
-					else
-						bases[indx] = 0x230;
-				} else {
-					if (pos & 0x01)
-						bases[indx] = 0x130;
-				}
-			}
-
-			/* No need to decode IRQ and Arb level -- those are
-			 * read off the card later.
-			 */
-			printk(KERN_INFO "Found an AHA-1640 in MCA slot %d, I/O 0x%04x\n", slot, bases[indx]);
-
-			mca_set_adapter_name(slot, "Adapter AHA-1640");
-			mca_set_adapter_procfn(slot, NULL, NULL);
-			mca_mark_as_used(slot);
-
-			/* Go on */
-			slot++;
-		}
-
-	}
-#endif
-
 	/*
 	 *	Hunt for ISA Plug'n'Pray Adaptecs (AHA1535)
 	 */

commit 9ffc93f203c18a70623f21950f1dd473c9ec48cd
Author: David Howells <dhowells@redhat.com>
Date:   Wed Mar 28 18:30:03 2012 +0100

    Remove all #inclusions of asm/system.h
    
    Remove all #inclusions of asm/system.h preparatory to splitting and killing
    it.  Performed with the following command:
    
    perl -p -i -e 's!^#\s*include\s*<asm/system[.]h>.*\n!!' `grep -Irl '^#\s*include\s*<asm/system[.]h>' *`
    
    Signed-off-by: David Howells <dhowells@redhat.com>

diff --git a/drivers/scsi/aha1542.c b/drivers/scsi/aha1542.c
index ed119cedaae0..ede91f378000 100644
--- a/drivers/scsi/aha1542.c
+++ b/drivers/scsi/aha1542.c
@@ -42,7 +42,6 @@
 #include <linux/slab.h>
 
 #include <asm/dma.h>
-#include <asm/system.h>
 #include <asm/io.h>
 
 #include "scsi.h"

commit 90ab5ee94171b3e28de6bb42ee30b527014e0be7
Author: Rusty Russell <rusty@rustcorp.com.au>
Date:   Fri Jan 13 09:32:20 2012 +1030

    module_param: make bool parameters really bool (drivers & misc)
    
    module_param(bool) used to counter-intuitively take an int.  In
    fddd5201 (mid-2009) we allowed bool or int/unsigned int using a messy
    trick.
    
    It's time to remove the int/unsigned int option.  For this version
    it'll simply give a warning, but it'll break next kernel version.
    
    Acked-by: Mauro Carvalho Chehab <mchehab@redhat.com>
    Signed-off-by: Rusty Russell <rusty@rustcorp.com.au>

diff --git a/drivers/scsi/aha1542.c b/drivers/scsi/aha1542.c
index 195823a51aab..ed119cedaae0 100644
--- a/drivers/scsi/aha1542.c
+++ b/drivers/scsi/aha1542.c
@@ -102,7 +102,7 @@ static int setup_dmaspeed[MAXBOARDS] __initdata = { -1, -1, -1, -1 };
  */
 
 #if defined(MODULE)
-static int isapnp = 0;
+static bool isapnp = 0;
 static int aha1542[] = {0x330, 11, 4, -1};
 module_param_array(aha1542, int, NULL, 0);
 module_param(isapnp, bool, 0);

commit f281233d3eba15fb225d21ae2e228fd4553d824a
Author: Jeff Garzik <jeff@garzik.org>
Date:   Tue Nov 16 02:10:29 2010 -0500

    SCSI host lock push-down
    
    Move the mid-layer's ->queuecommand() invocation from being locked
    with the host lock to being unlocked to facilitate speeding up the
    critical path for drivers who don't need this lock taken anyway.
    
    The patch below presents a simple SCSI host lock push-down as an
    equivalent transformation.  No locking or other behavior should change
    with this patch.  All existing bugs and locking orders are preserved.
    
    Additionally, add one parameter to queuecommand,
            struct Scsi_Host *
    and remove one parameter from queuecommand,
            void (*done)(struct scsi_cmnd *)
    
    Scsi_Host* is a convenient pointer that most host drivers need anyway,
    and 'done' is redundant to struct scsi_cmnd->scsi_done.
    
    Minimal code disturbance was attempted with this change.  Most drivers
    needed only two one-line modifications for their host lock push-down.
    
    Signed-off-by: Jeff Garzik <jgarzik@redhat.com>
    Acked-by: James Bottomley <James.Bottomley@suse.de>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/scsi/aha1542.c b/drivers/scsi/aha1542.c
index 4f785f254c1f..195823a51aab 100644
--- a/drivers/scsi/aha1542.c
+++ b/drivers/scsi/aha1542.c
@@ -558,7 +558,7 @@ static void aha1542_intr_handle(struct Scsi_Host *shost)
 	};
 }
 
-static int aha1542_queuecommand(Scsi_Cmnd * SCpnt, void (*done) (Scsi_Cmnd *))
+static int aha1542_queuecommand_lck(Scsi_Cmnd * SCpnt, void (*done) (Scsi_Cmnd *))
 {
 	unchar ahacmd = CMD_START_SCSI;
 	unchar direction;
@@ -718,6 +718,8 @@ static int aha1542_queuecommand(Scsi_Cmnd * SCpnt, void (*done) (Scsi_Cmnd *))
 	return 0;
 }
 
+static DEF_SCSI_QCMD(aha1542_queuecommand)
+
 /* Initialize mailboxes */
 static void setup_mailboxes(int bse, struct Scsi_Host *shpnt)
 {

commit b375a612ad931264b71cf162d692b4420f2578a9
Author: FUJITA Tomonori <fujita.tomonori@lab.ntt.co.jp>
Date:   Thu Jun 17 14:58:21 2010 +0200

    aha1532: remove ISA_DMA_THRESHOLD usage
    
    We can safely remove ISA_DMA_THRESHOLD usage in aha1542. aha1542 uses
    ISA_DMA_THRESHOLD to see if:
    
    - the buffers in scatter/list are below 16MB.
    - scsi_host is below 16MB.
    
    Both checkings were added in the ancient times but aren't necessary
    nowadays since we properly bounce the buffers and allocate scsi_host
    below 16MB with non-zero unchecked_isa_dma.
    
    Signed-off-by: FUJITA Tomonori <fujita.tomonori@lab.ntt.co.jp>
    Acked-by: James Bottomley <James.Bottomley@suse.de>
    Signed-off-by: Jens Axboe <jaxboe@fusionio.com>

diff --git a/drivers/scsi/aha1542.c b/drivers/scsi/aha1542.c
index 2a8cf137f609..4f785f254c1f 100644
--- a/drivers/scsi/aha1542.c
+++ b/drivers/scsi/aha1542.c
@@ -52,22 +52,6 @@
 #define SCSI_BUF_PA(address)	isa_virt_to_bus(address)
 #define SCSI_SG_PA(sgent)	(isa_page_to_bus(sg_page((sgent))) + (sgent)->offset)
 
-static void BAD_SG_DMA(Scsi_Cmnd * SCpnt,
-		       struct scatterlist *sgp,
-		       int nseg,
-		       int badseg)
-{
-	printk(KERN_CRIT "sgpnt[%d:%d] page %p/0x%llx length %u\n",
-	       badseg, nseg, sg_virt(sgp),
-	       (unsigned long long)SCSI_SG_PA(sgp),
-	       sgp->length);
-
-	/*
-	 * Not safe to continue.
-	 */
-	panic("Buffer at physical address > 16Mb used for aha1542");
-}
-
 #include<linux/stat.h>
 
 #ifdef DEBUG
@@ -691,8 +675,6 @@ static int aha1542_queuecommand(Scsi_Cmnd * SCpnt, void (*done) (Scsi_Cmnd *))
 		}
 		scsi_for_each_sg(SCpnt, sg, sg_count, i) {
 			any2scsi(cptr[i].dataptr, SCSI_SG_PA(sg));
-			if (SCSI_SG_PA(sg) + sg->length - 1 > ISA_DMA_THRESHOLD)
-				BAD_SG_DMA(SCpnt, scsi_sglist(SCpnt), sg_count, i);
 			any2scsi(cptr[i].datalen, sg->length);
 		};
 		any2scsi(ccb[mbo].datalen, sg_count * sizeof(struct chain));
@@ -1133,16 +1115,9 @@ static int __init aha1542_detect(struct scsi_host_template * tpnt)
 				release_region(bases[indx], 4);
 				continue;
 			}
-			/* For now we do this - until kmalloc is more intelligent
-			   we are resigned to stupid hacks like this */
-			if (SCSI_BUF_PA(shpnt) >= ISA_DMA_THRESHOLD) {
-				printk(KERN_ERR "Invalid address for shpnt with 1542.\n");
-				goto unregister;
-			}
 			if (!aha1542_test_port(bases[indx], shpnt))
 				goto unregister;
 
-
 			base_io = bases[indx];
 
 			/* Set the Bus on/off-times as not to ruin floppy performance */

commit 5a0e3ad6af8660be21ca98a971cd00f331318c05
Author: Tejun Heo <tj@kernel.org>
Date:   Wed Mar 24 17:04:11 2010 +0900

    include cleanup: Update gfp.h and slab.h includes to prepare for breaking implicit slab.h inclusion from percpu.h
    
    percpu.h is included by sched.h and module.h and thus ends up being
    included when building most .c files.  percpu.h includes slab.h which
    in turn includes gfp.h making everything defined by the two files
    universally available and complicating inclusion dependencies.
    
    percpu.h -> slab.h dependency is about to be removed.  Prepare for
    this change by updating users of gfp and slab facilities include those
    headers directly instead of assuming availability.  As this conversion
    needs to touch large number of source files, the following script is
    used as the basis of conversion.
    
      http://userweb.kernel.org/~tj/misc/slabh-sweep.py
    
    The script does the followings.
    
    * Scan files for gfp and slab usages and update includes such that
      only the necessary includes are there.  ie. if only gfp is used,
      gfp.h, if slab is used, slab.h.
    
    * When the script inserts a new include, it looks at the include
      blocks and try to put the new include such that its order conforms
      to its surrounding.  It's put in the include block which contains
      core kernel includes, in the same order that the rest are ordered -
      alphabetical, Christmas tree, rev-Xmas-tree or at the end if there
      doesn't seem to be any matching order.
    
    * If the script can't find a place to put a new include (mostly
      because the file doesn't have fitting include block), it prints out
      an error message indicating which .h file needs to be added to the
      file.
    
    The conversion was done in the following steps.
    
    1. The initial automatic conversion of all .c files updated slightly
       over 4000 files, deleting around 700 includes and adding ~480 gfp.h
       and ~3000 slab.h inclusions.  The script emitted errors for ~400
       files.
    
    2. Each error was manually checked.  Some didn't need the inclusion,
       some needed manual addition while adding it to implementation .h or
       embedding .c file was more appropriate for others.  This step added
       inclusions to around 150 files.
    
    3. The script was run again and the output was compared to the edits
       from #2 to make sure no file was left behind.
    
    4. Several build tests were done and a couple of problems were fixed.
       e.g. lib/decompress_*.c used malloc/free() wrappers around slab
       APIs requiring slab.h to be added manually.
    
    5. The script was run on all .h files but without automatically
       editing them as sprinkling gfp.h and slab.h inclusions around .h
       files could easily lead to inclusion dependency hell.  Most gfp.h
       inclusion directives were ignored as stuff from gfp.h was usually
       wildly available and often used in preprocessor macros.  Each
       slab.h inclusion directive was examined and added manually as
       necessary.
    
    6. percpu.h was updated not to include slab.h.
    
    7. Build test were done on the following configurations and failures
       were fixed.  CONFIG_GCOV_KERNEL was turned off for all tests (as my
       distributed build env didn't work with gcov compiles) and a few
       more options had to be turned off depending on archs to make things
       build (like ipr on powerpc/64 which failed due to missing writeq).
    
       * x86 and x86_64 UP and SMP allmodconfig and a custom test config.
       * powerpc and powerpc64 SMP allmodconfig
       * sparc and sparc64 SMP allmodconfig
       * ia64 SMP allmodconfig
       * s390 SMP allmodconfig
       * alpha SMP allmodconfig
       * um on x86_64 SMP allmodconfig
    
    8. percpu.h modifications were reverted so that it could be applied as
       a separate patch and serve as bisection point.
    
    Given the fact that I had only a couple of failures from tests on step
    6, I'm fairly confident about the coverage of this conversion patch.
    If there is a breakage, it's likely to be something in one of the arch
    headers which should be easily discoverable easily on most builds of
    the specific arch.
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Guess-its-ok-by: Christoph Lameter <cl@linux-foundation.org>
    Cc: Ingo Molnar <mingo@redhat.com>
    Cc: Lee Schermerhorn <Lee.Schermerhorn@hp.com>

diff --git a/drivers/scsi/aha1542.c b/drivers/scsi/aha1542.c
index 80594947c6f6..2a8cf137f609 100644
--- a/drivers/scsi/aha1542.c
+++ b/drivers/scsi/aha1542.c
@@ -39,6 +39,7 @@
 #include <linux/blkdev.h>
 #include <linux/mca.h>
 #include <linux/mca-legacy.h>
+#include <linux/slab.h>
 
 #include <asm/dma.h>
 #include <asm/system.h>

commit 87c4d7bc2aaa9b782aac6ab0a74cf16f87398bbc
Author: Jeff Garzik <jeff@garzik.org>
Date:   Thu Apr 24 19:45:32 2008 -0400

    [SCSI] aha1542: minor irq handler cleanups
    
    - where the 'irq' function argument is known never to be used, rename
      it to 'dummy' to make this more obvious
    
    - replace per-irq lookup functions and tables with a direct reference
      to data object obtained via 'dev_id' function argument, passed from
      request_irq()
    
    Signed-off-by: Jeff Garzik <jgarzik@redhat.com>
    Signed-off-by: James Bottomley <James.Bottomley@HansenPartnership.com>

diff --git a/drivers/scsi/aha1542.c b/drivers/scsi/aha1542.c
index 5a1471c370fa..80594947c6f6 100644
--- a/drivers/scsi/aha1542.c
+++ b/drivers/scsi/aha1542.c
@@ -153,8 +153,6 @@ struct aha1542_hostdata {
 
 #define HOSTDATA(host) ((struct aha1542_hostdata *) &host->hostdata)
 
-static struct Scsi_Host *aha_host[7];	/* One for each IRQ level (9-15) */
-
 static DEFINE_SPINLOCK(aha1542_lock);
 
 
@@ -163,8 +161,7 @@ static DEFINE_SPINLOCK(aha1542_lock);
 
 static void setup_mailboxes(int base_io, struct Scsi_Host *shpnt);
 static int aha1542_restart(struct Scsi_Host *shost);
-static void aha1542_intr_handle(struct Scsi_Host *shost, void *dev_id);
-static irqreturn_t do_aha1542_intr_handle(int irq, void *dev_id);
+static void aha1542_intr_handle(struct Scsi_Host *shost);
 
 #define aha1542_intr_reset(base)  outb(IRST, CONTROL(base))
 
@@ -404,23 +401,19 @@ static int __init aha1542_test_port(int bse, struct Scsi_Host *shpnt)
 }
 
 /* A quick wrapper for do_aha1542_intr_handle to grab the spin lock */
-static irqreturn_t do_aha1542_intr_handle(int irq, void *dev_id)
+static irqreturn_t do_aha1542_intr_handle(int dummy, void *dev_id)
 {
 	unsigned long flags;
-	struct Scsi_Host *shost;
-
-	shost = aha_host[irq - 9];
-	if (!shost)
-		panic("Splunge!");
+	struct Scsi_Host *shost = dev_id;
 
 	spin_lock_irqsave(shost->host_lock, flags);
-	aha1542_intr_handle(shost, dev_id);
+	aha1542_intr_handle(shost);
 	spin_unlock_irqrestore(shost->host_lock, flags);
 	return IRQ_HANDLED;
 }
 
 /* A "high" level interrupt handler */
-static void aha1542_intr_handle(struct Scsi_Host *shost, void *dev_id)
+static void aha1542_intr_handle(struct Scsi_Host *shost)
 {
 	void (*my_done) (Scsi_Cmnd *) = NULL;
 	int errstatus, mbi, mbo, mbistatus;
@@ -1197,7 +1190,8 @@ static int __init aha1542_detect(struct scsi_host_template * tpnt)
 
 			DEB(printk("aha1542_detect: enable interrupt channel %d\n", irq_level));
 			spin_lock_irqsave(&aha1542_lock, flags);
-			if (request_irq(irq_level, do_aha1542_intr_handle, 0, "aha1542", NULL)) {
+			if (request_irq(irq_level, do_aha1542_intr_handle, 0,
+					"aha1542", shpnt)) {
 				printk(KERN_ERR "Unable to allocate IRQ for adaptec controller.\n");
 				spin_unlock_irqrestore(&aha1542_lock, flags);
 				goto unregister;
@@ -1205,7 +1199,7 @@ static int __init aha1542_detect(struct scsi_host_template * tpnt)
 			if (dma_chan != 0xFF) {
 				if (request_dma(dma_chan, "aha1542")) {
 					printk(KERN_ERR "Unable to allocate DMA channel for Adaptec.\n");
-					free_irq(irq_level, NULL);
+					free_irq(irq_level, shpnt);
 					spin_unlock_irqrestore(&aha1542_lock, flags);
 					goto unregister;
 				}
@@ -1214,7 +1208,7 @@ static int __init aha1542_detect(struct scsi_host_template * tpnt)
 					enable_dma(dma_chan);
 				}
 			}
-			aha_host[irq_level - 9] = shpnt;
+
 			shpnt->this_id = scsi_id;
 			shpnt->unique_id = base_io;
 			shpnt->io_port = base_io;
@@ -1276,7 +1270,7 @@ static int __init aha1542_detect(struct scsi_host_template * tpnt)
 static int aha1542_release(struct Scsi_Host *shost)
 {
 	if (shost->irq)
-		free_irq(shost->irq, NULL);
+		free_irq(shost->irq, shost);
 	if (shost->dma_channel != 0xff)
 		free_dma(shost->dma_channel);
 	if (shost->io_port && shost->n_io_port)

commit 726a645913694619876dd20645f88aad25cfbcd5
Author: Joe Perches <joe@perches.com>
Date:   Sun Feb 3 16:36:24 2008 +0200

    MAINTAINERS: remove Adam Fritzler, remove his email address in other sources
    
    Signed-off-by: Joe Perches <joe@perches.com>
    Signed-off-by: Adrian Bunk <bunk@kernel.org>

diff --git a/drivers/scsi/aha1542.c b/drivers/scsi/aha1542.c
index 190568ebea3c..5a1471c370fa 100644
--- a/drivers/scsi/aha1542.c
+++ b/drivers/scsi/aha1542.c
@@ -21,7 +21,7 @@
  *  Modified by Chris Faulhaber <jedgar@fxp.org>
  *        Added module command-line options
  *        19-Jul-99
- *  Modified by Adam Fritzler <mid@auk.cx>
+ *  Modified by Adam Fritzler
  *        Added proper detection of the AHA-1640 (MCA version of AHA-1540)
  */
 

commit b80ca4f7ee36c26d300c5a8f429e73372d153379
Author: FUJITA Tomonori <tomof@acm.org>
Date:   Sun Jan 13 15:46:13 2008 +0900

    [SCSI] replace sizeof sense_buffer with SCSI_SENSE_BUFFERSIZE
    
    This replaces sizeof sense_buffer with SCSI_SENSE_BUFFERSIZE in
    several LLDs. It's a preparation for the future changes to remove
    sense_buffer array in scsi_cmnd structure.
    
    Signed-off-by: FUJITA Tomonori <fujita.tomonori@lab.ntt.co.jp>
    Signed-off-by: James Bottomley <James.Bottomley@HansenPartnership.com>

diff --git a/drivers/scsi/aha1542.c b/drivers/scsi/aha1542.c
index 5b69a88d0e4c..190568ebea3c 100644
--- a/drivers/scsi/aha1542.c
+++ b/drivers/scsi/aha1542.c
@@ -536,7 +536,7 @@ static void aha1542_intr_handle(struct Scsi_Host *shost, void *dev_id)
 		   we will still have it in the cdb when we come back */
 		if (ccb[mbo].tarstat == 2)
 			memcpy(SCtmp->sense_buffer, &ccb[mbo].cdb[ccb[mbo].cdblen],
-			       sizeof(SCtmp->sense_buffer));
+			       SCSI_SENSE_BUFFERSIZE);
 
 
 		/* is there mail :-) */
@@ -609,7 +609,7 @@ static int aha1542_queuecommand(Scsi_Cmnd * SCpnt, void (*done) (Scsi_Cmnd *))
 #if 0
 		/* scsi_request_sense() provides a buffer of size 256,
 		   so there is no reason to expect equality */
-		if (bufflen != sizeof(SCpnt->sense_buffer))
+		if (bufflen != SCSI_SENSE_BUFFERSIZE)
 			printk(KERN_CRIT "aha1542: Wrong buffer length supplied "
 			       "for request sense (%d)\n", bufflen);
 #endif

commit fc3fdfcc8bb0e069a2d172e745664fa2c1f1b0ca
Author: Boaz Harrosh <bharrosh@panasas.com>
Date:   Sun Sep 9 21:02:45 2007 +0300

    [SCSI] aha1542: convert to accessors and !use_sg cleanup
    
     - convert to accessors and !use_sg cleanup
    
    Signed-off-by: Boaz Harrosh <bharrosh@panasas.com>
    Signed-off-by: James Bottomley <James.Bottomley@HansenPartnership.com>

diff --git a/drivers/scsi/aha1542.c b/drivers/scsi/aha1542.c
index bbcc2c52d79f..5b69a88d0e4c 100644
--- a/drivers/scsi/aha1542.c
+++ b/drivers/scsi/aha1542.c
@@ -51,15 +51,6 @@
 #define SCSI_BUF_PA(address)	isa_virt_to_bus(address)
 #define SCSI_SG_PA(sgent)	(isa_page_to_bus(sg_page((sgent))) + (sgent)->offset)
 
-static void BAD_DMA(void *address, unsigned int length)
-{
-	printk(KERN_CRIT "buf vaddress %p paddress 0x%lx length %d\n",
-	       address,
-	       SCSI_BUF_PA(address),
-	       length);
-	panic("Buffer at physical address > 16Mb used for aha1542");
-}
-
 static void BAD_SG_DMA(Scsi_Cmnd * SCpnt,
 		       struct scatterlist *sgp,
 		       int nseg,
@@ -597,8 +588,7 @@ static int aha1542_queuecommand(Scsi_Cmnd * SCpnt, void (*done) (Scsi_Cmnd *))
 	unchar target = SCpnt->device->id;
 	unchar lun = SCpnt->device->lun;
 	unsigned long flags;
-	void *buff = SCpnt->request_buffer;
-	int bufflen = SCpnt->request_bufflen;
+	int bufflen = scsi_bufflen(SCpnt);
 	int mbo;
 	struct mailbox *mb;
 	struct ccb *ccb;
@@ -689,42 +679,29 @@ static int aha1542_queuecommand(Scsi_Cmnd * SCpnt, void (*done) (Scsi_Cmnd *))
 
 	memcpy(ccb[mbo].cdb, cmd, ccb[mbo].cdblen);
 
-	if (SCpnt->use_sg) {
+	if (bufflen) {
 		struct scatterlist *sg;
 		struct chain *cptr;
 #ifdef DEBUG
 		unsigned char *ptr;
 #endif
-		int i;
+		int i, sg_count = scsi_sg_count(SCpnt);
 		ccb[mbo].op = 2;	/* SCSI Initiator Command  w/scatter-gather */
-		SCpnt->host_scribble = kmalloc(512, GFP_KERNEL | GFP_DMA);
+		SCpnt->host_scribble = kmalloc(sizeof(*cptr)*sg_count,
+		                                         GFP_KERNEL | GFP_DMA);
 		cptr = (struct chain *) SCpnt->host_scribble;
 		if (cptr == NULL) {
 			/* free the claimed mailbox slot */
 			HOSTDATA(SCpnt->device->host)->SCint[mbo] = NULL;
 			return SCSI_MLQUEUE_HOST_BUSY;
 		}
-		scsi_for_each_sg(SCpnt, sg, SCpnt->use_sg, i) {
-			if (sg->length == 0 || SCpnt->use_sg > 16 ||
-			    (((int) sg->offset) & 1) || (sg->length & 1)) {
-				unsigned char *ptr;
-				printk(KERN_CRIT "Bad segment list supplied to aha1542.c (%d, %d)\n", SCpnt->use_sg, i);
-				scsi_for_each_sg(SCpnt, sg, SCpnt->use_sg, i) {
-					printk(KERN_CRIT "%d: %p %d\n", i,
-					       sg_virt(sg), sg->length);
-				};
-				printk(KERN_CRIT "cptr %x: ", (unsigned int) cptr);
-				ptr = (unsigned char *) &cptr[i];
-				for (i = 0; i < 18; i++)
-					printk("%02x ", ptr[i]);
-				panic("Foooooooood fight!");
-			};
+		scsi_for_each_sg(SCpnt, sg, sg_count, i) {
 			any2scsi(cptr[i].dataptr, SCSI_SG_PA(sg));
 			if (SCSI_SG_PA(sg) + sg->length - 1 > ISA_DMA_THRESHOLD)
-				BAD_SG_DMA(SCpnt, sg, SCpnt->use_sg, i);
+				BAD_SG_DMA(SCpnt, scsi_sglist(SCpnt), sg_count, i);
 			any2scsi(cptr[i].datalen, sg->length);
 		};
-		any2scsi(ccb[mbo].datalen, SCpnt->use_sg * sizeof(struct chain));
+		any2scsi(ccb[mbo].datalen, sg_count * sizeof(struct chain));
 		any2scsi(ccb[mbo].dataptr, SCSI_BUF_PA(cptr));
 #ifdef DEBUG
 		printk("cptr %x: ", cptr);
@@ -735,10 +712,8 @@ static int aha1542_queuecommand(Scsi_Cmnd * SCpnt, void (*done) (Scsi_Cmnd *))
 	} else {
 		ccb[mbo].op = 0;	/* SCSI Initiator Command */
 		SCpnt->host_scribble = NULL;
-		any2scsi(ccb[mbo].datalen, bufflen);
-		if (buff && SCSI_BUF_PA(buff + bufflen - 1) > ISA_DMA_THRESHOLD)
-			BAD_DMA(buff, bufflen);
-		any2scsi(ccb[mbo].dataptr, SCSI_BUF_PA(buff));
+		any2scsi(ccb[mbo].datalen, 0);
+		any2scsi(ccb[mbo].dataptr, 0);
 	};
 	ccb[mbo].idlun = (target & 7) << 5 | direction | (lun & 7);	/*SCSI Target Id */
 	ccb[mbo].rsalen = 16;

commit 45711f1af6eff1a6d010703b4862e0d2b9afd056
Author: Jens Axboe <jens.axboe@oracle.com>
Date:   Mon Oct 22 21:19:53 2007 +0200

    [SG] Update drivers to use sg helpers
    
    Signed-off-by: Jens Axboe <jens.axboe@oracle.com>

diff --git a/drivers/scsi/aha1542.c b/drivers/scsi/aha1542.c
index 961a1882cb7e..bbcc2c52d79f 100644
--- a/drivers/scsi/aha1542.c
+++ b/drivers/scsi/aha1542.c
@@ -49,7 +49,7 @@
 #include "aha1542.h"
 
 #define SCSI_BUF_PA(address)	isa_virt_to_bus(address)
-#define SCSI_SG_PA(sgent)	(isa_page_to_bus((sgent)->page) + (sgent)->offset)
+#define SCSI_SG_PA(sgent)	(isa_page_to_bus(sg_page((sgent))) + (sgent)->offset)
 
 static void BAD_DMA(void *address, unsigned int length)
 {
@@ -66,8 +66,7 @@ static void BAD_SG_DMA(Scsi_Cmnd * SCpnt,
 		       int badseg)
 {
 	printk(KERN_CRIT "sgpnt[%d:%d] page %p/0x%llx length %u\n",
-	       badseg, nseg,
-	       page_address(sgp->page) + sgp->offset,
+	       badseg, nseg, sg_virt(sgp),
 	       (unsigned long long)SCSI_SG_PA(sgp),
 	       sgp->length);
 
@@ -712,8 +711,7 @@ static int aha1542_queuecommand(Scsi_Cmnd * SCpnt, void (*done) (Scsi_Cmnd *))
 				printk(KERN_CRIT "Bad segment list supplied to aha1542.c (%d, %d)\n", SCpnt->use_sg, i);
 				scsi_for_each_sg(SCpnt, sg, SCpnt->use_sg, i) {
 					printk(KERN_CRIT "%d: %p %d\n", i,
-					       (page_address(sg->page) +
-						sg->offset), sg->length);
+					       sg_virt(sg), sg->length);
 				};
 				printk(KERN_CRIT "cptr %x: ", (unsigned int) cptr);
 				ptr = (unsigned char *) &cptr[i];

commit 51cf22495ae2fe60ba28123e04059cff4ddd9461
Author: Jens Axboe <jens.axboe@oracle.com>
Date:   Mon Jul 16 10:00:31 2007 +0200

    aha1542: convert to use the data buffer accessors
    
    Signed-off-by: Jens Axboe <jens.axboe@oracle.com>

diff --git a/drivers/scsi/aha1542.c b/drivers/scsi/aha1542.c
index cbbfbc9f3e0f..961a1882cb7e 100644
--- a/drivers/scsi/aha1542.c
+++ b/drivers/scsi/aha1542.c
@@ -61,15 +61,15 @@ static void BAD_DMA(void *address, unsigned int length)
 }
 
 static void BAD_SG_DMA(Scsi_Cmnd * SCpnt,
-		       struct scatterlist *sgpnt,
+		       struct scatterlist *sgp,
 		       int nseg,
 		       int badseg)
 {
 	printk(KERN_CRIT "sgpnt[%d:%d] page %p/0x%llx length %u\n",
 	       badseg, nseg,
-	       page_address(sgpnt[badseg].page) + sgpnt[badseg].offset,
-	       (unsigned long long)SCSI_SG_PA(&sgpnt[badseg]),
-	       sgpnt[badseg].length);
+	       page_address(sgp->page) + sgp->offset,
+	       (unsigned long long)SCSI_SG_PA(sgp),
+	       sgp->length);
 
 	/*
 	 * Not safe to continue.
@@ -691,7 +691,7 @@ static int aha1542_queuecommand(Scsi_Cmnd * SCpnt, void (*done) (Scsi_Cmnd *))
 	memcpy(ccb[mbo].cdb, cmd, ccb[mbo].cdblen);
 
 	if (SCpnt->use_sg) {
-		struct scatterlist *sgpnt;
+		struct scatterlist *sg;
 		struct chain *cptr;
 #ifdef DEBUG
 		unsigned char *ptr;
@@ -699,23 +699,21 @@ static int aha1542_queuecommand(Scsi_Cmnd * SCpnt, void (*done) (Scsi_Cmnd *))
 		int i;
 		ccb[mbo].op = 2;	/* SCSI Initiator Command  w/scatter-gather */
 		SCpnt->host_scribble = kmalloc(512, GFP_KERNEL | GFP_DMA);
-		sgpnt = (struct scatterlist *) SCpnt->request_buffer;
 		cptr = (struct chain *) SCpnt->host_scribble;
 		if (cptr == NULL) {
 			/* free the claimed mailbox slot */
 			HOSTDATA(SCpnt->device->host)->SCint[mbo] = NULL;
 			return SCSI_MLQUEUE_HOST_BUSY;
 		}
-		for (i = 0; i < SCpnt->use_sg; i++) {
-			if (sgpnt[i].length == 0 || SCpnt->use_sg > 16 ||
-			    (((int) sgpnt[i].offset) & 1) || (sgpnt[i].length & 1)) {
+		scsi_for_each_sg(SCpnt, sg, SCpnt->use_sg, i) {
+			if (sg->length == 0 || SCpnt->use_sg > 16 ||
+			    (((int) sg->offset) & 1) || (sg->length & 1)) {
 				unsigned char *ptr;
 				printk(KERN_CRIT "Bad segment list supplied to aha1542.c (%d, %d)\n", SCpnt->use_sg, i);
-				for (i = 0; i < SCpnt->use_sg; i++) {
+				scsi_for_each_sg(SCpnt, sg, SCpnt->use_sg, i) {
 					printk(KERN_CRIT "%d: %p %d\n", i,
-					       (page_address(sgpnt[i].page) +
-						sgpnt[i].offset),
-					       sgpnt[i].length);
+					       (page_address(sg->page) +
+						sg->offset), sg->length);
 				};
 				printk(KERN_CRIT "cptr %x: ", (unsigned int) cptr);
 				ptr = (unsigned char *) &cptr[i];
@@ -723,10 +721,10 @@ static int aha1542_queuecommand(Scsi_Cmnd * SCpnt, void (*done) (Scsi_Cmnd *))
 					printk("%02x ", ptr[i]);
 				panic("Foooooooood fight!");
 			};
-			any2scsi(cptr[i].dataptr, SCSI_SG_PA(&sgpnt[i]));
-			if (SCSI_SG_PA(&sgpnt[i]) + sgpnt[i].length - 1 > ISA_DMA_THRESHOLD)
-				BAD_SG_DMA(SCpnt, sgpnt, SCpnt->use_sg, i);
-			any2scsi(cptr[i].datalen, sgpnt[i].length);
+			any2scsi(cptr[i].dataptr, SCSI_SG_PA(sg));
+			if (SCSI_SG_PA(sg) + sg->length - 1 > ISA_DMA_THRESHOLD)
+				BAD_SG_DMA(SCpnt, sg, SCpnt->use_sg, i);
+			any2scsi(cptr[i].datalen, sg->length);
 		};
 		any2scsi(ccb[mbo].datalen, SCpnt->use_sg * sizeof(struct chain));
 		any2scsi(ccb[mbo].dataptr, SCSI_BUF_PA(cptr));

commit 6473d160b4aba8023bcf38519a5989694dfd51a7
Author: Jean Delvare <khali@linux-fr.org>
Date:   Tue Mar 6 02:45:12 2007 -0800

    PCI: Cleanup the includes of <linux/pci.h>
    
    I noticed that many source files include <linux/pci.h> while they do
    not appear to need it. Here is an attempt to clean it all up.
    
    In order to find all possibly affected files, I searched for all
    files including <linux/pci.h> but without any other occurence of "pci"
    or "PCI". I removed the include statement from all of these, then I
    compiled an allmodconfig kernel on both i386 and x86_64 and fixed the
    false positives manually.
    
    My tests covered 66% of the affected files, so there could be false
    positives remaining. Untested files are:
    
    arch/alpha/kernel/err_common.c
    arch/alpha/kernel/err_ev6.c
    arch/alpha/kernel/err_ev7.c
    arch/ia64/sn/kernel/huberror.c
    arch/ia64/sn/kernel/xpnet.c
    arch/m68knommu/kernel/dma.c
    arch/mips/lib/iomap.c
    arch/powerpc/platforms/pseries/ras.c
    arch/ppc/8260_io/enet.c
    arch/ppc/8260_io/fcc_enet.c
    arch/ppc/8xx_io/enet.c
    arch/ppc/syslib/ppc4xx_sgdma.c
    arch/sh64/mach-cayman/iomap.c
    arch/xtensa/kernel/xtensa_ksyms.c
    arch/xtensa/platform-iss/setup.c
    drivers/i2c/busses/i2c-at91.c
    drivers/i2c/busses/i2c-mpc.c
    drivers/media/video/saa711x.c
    drivers/misc/hdpuftrs/hdpu_cpustate.c
    drivers/misc/hdpuftrs/hdpu_nexus.c
    drivers/net/au1000_eth.c
    drivers/net/fec_8xx/fec_main.c
    drivers/net/fec_8xx/fec_mii.c
    drivers/net/fs_enet/fs_enet-main.c
    drivers/net/fs_enet/mac-fcc.c
    drivers/net/fs_enet/mac-fec.c
    drivers/net/fs_enet/mac-scc.c
    drivers/net/fs_enet/mii-bitbang.c
    drivers/net/fs_enet/mii-fec.c
    drivers/net/ibm_emac/ibm_emac_core.c
    drivers/net/lasi_82596.c
    drivers/parisc/hppb.c
    drivers/sbus/sbus.c
    drivers/video/g364fb.c
    drivers/video/platinumfb.c
    drivers/video/stifb.c
    drivers/video/valkyriefb.c
    include/asm-arm/arch-ixp4xx/dma.h
    sound/oss/au1550_ac97.c
    
    I would welcome test reports for these files. I am fine with removing
    the untested files from the patch if the general opinion is that these
    changes aren't safe. The tested part would still be nice to have.
    
    Note that this patch depends on another header fixup patch I submitted
    to LKML yesterday:
      [PATCH] scatterlist.h needs types.h
      http://lkml.org/lkml/2007/3/01/141
    
    Signed-off-by: Jean Delvare <khali@linux-fr.org>
    Cc: Badari Pulavarty <pbadari@us.ibm.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/scsi/aha1542.c b/drivers/scsi/aha1542.c
index 1d239f6c0103..cbbfbc9f3e0f 100644
--- a/drivers/scsi/aha1542.c
+++ b/drivers/scsi/aha1542.c
@@ -35,7 +35,6 @@
 #include <linux/proc_fs.h>
 #include <linux/init.h>
 #include <linux/spinlock.h>
-#include <linux/pci.h>
 #include <linux/isapnp.h>
 #include <linux/blkdev.h>
 #include <linux/mca.h>

commit 5cbded585d129d0226cb48ac4202b253c781be26
Author: Robert P. J. Day <rpjday@mindspring.com>
Date:   Wed Dec 13 00:35:56 2006 -0800

    [PATCH] getting rid of all casts of k[cmz]alloc() calls
    
    Run this:
    
            #!/bin/sh
            for f in $(grep -Erl "\([^\)]*\) *k[cmz]alloc" *) ; do
              echo "De-casting $f..."
              perl -pi -e "s/ ?= ?\([^\)]*\) *(k[cmz]alloc) *\(/ = \1\(/" $f
            done
    
    And then go through and reinstate those cases where code is casting pointers
    to non-pointers.
    
    And then drop a few hunks which conflicted with outstanding work.
    
    Cc: Russell King <rmk@arm.linux.org.uk>, Ian Molton <spyro@f2s.com>
    Cc: Mikael Starvik <starvik@axis.com>
    Cc: Yoshinori Sato <ysato@users.sourceforge.jp>
    Cc: Roman Zippel <zippel@linux-m68k.org>
    Cc: Geert Uytterhoeven <geert@linux-m68k.org>
    Cc: Ralf Baechle <ralf@linux-mips.org>
    Cc: Paul Mackerras <paulus@samba.org>
    Cc: Kyle McMartin <kyle@mcmartin.ca>
    Cc: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Cc: Martin Schwidefsky <schwidefsky@de.ibm.com>
    Cc: "David S. Miller" <davem@davemloft.net>
    Cc: Jeff Dike <jdike@addtoit.com>
    Cc: Greg KH <greg@kroah.com>
    Cc: Jens Axboe <jens.axboe@oracle.com>
    Cc: Paul Fulghum <paulkf@microgate.com>
    Cc: Alan Cox <alan@lxorguk.ukuu.org.uk>
    Cc: Karsten Keil <kkeil@suse.de>
    Cc: Mauro Carvalho Chehab <mchehab@infradead.org>
    Cc: Jeff Garzik <jeff@garzik.org>
    Cc: James Bottomley <James.Bottomley@steeleye.com>
    Cc: Ian Kent <raven@themaw.net>
    Cc: Steven French <sfrench@us.ibm.com>
    Cc: David Woodhouse <dwmw2@infradead.org>
    Cc: Neil Brown <neilb@cse.unsw.edu.au>
    Cc: Jaroslav Kysela <perex@suse.cz>
    Cc: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/drivers/scsi/aha1542.c b/drivers/scsi/aha1542.c
index d7a61a6bdaae..1d239f6c0103 100644
--- a/drivers/scsi/aha1542.c
+++ b/drivers/scsi/aha1542.c
@@ -699,7 +699,7 @@ static int aha1542_queuecommand(Scsi_Cmnd * SCpnt, void (*done) (Scsi_Cmnd *))
 #endif
 		int i;
 		ccb[mbo].op = 2;	/* SCSI Initiator Command  w/scatter-gather */
-		SCpnt->host_scribble = (unsigned char *) kmalloc(512, GFP_KERNEL | GFP_DMA);
+		SCpnt->host_scribble = kmalloc(512, GFP_KERNEL | GFP_DMA);
 		sgpnt = (struct scatterlist *) SCpnt->request_buffer;
 		cptr = (struct chain *) SCpnt->host_scribble;
 		if (cptr == NULL) {

commit 7d12e780e003f93433d49ce78cfedf4b4c52adc5
Author: David Howells <dhowells@redhat.com>
Date:   Thu Oct 5 14:55:46 2006 +0100

    IRQ: Maintain regs pointer globally rather than passing to IRQ handlers
    
    Maintain a per-CPU global "struct pt_regs *" variable which can be used instead
    of passing regs around manually through all ~1800 interrupt handlers in the
    Linux kernel.
    
    The regs pointer is used in few places, but it potentially costs both stack
    space and code to pass it around.  On the FRV arch, removing the regs parameter
    from all the genirq function results in a 20% speed up of the IRQ exit path
    (ie: from leaving timer_interrupt() to leaving do_IRQ()).
    
    Where appropriate, an arch may override the generic storage facility and do
    something different with the variable.  On FRV, for instance, the address is
    maintained in GR28 at all times inside the kernel as part of general exception
    handling.
    
    Having looked over the code, it appears that the parameter may be handed down
    through up to twenty or so layers of functions.  Consider a USB character
    device attached to a USB hub, attached to a USB controller that posts its
    interrupts through a cascaded auxiliary interrupt controller.  A character
    device driver may want to pass regs to the sysrq handler through the input
    layer which adds another few layers of parameter passing.
    
    I've build this code with allyesconfig for x86_64 and i386.  I've runtested the
    main part of the code on FRV and i386, though I can't test most of the drivers.
    I've also done partial conversion for powerpc and MIPS - these at least compile
    with minimal configurations.
    
    This will affect all archs.  Mostly the changes should be relatively easy.
    Take do_IRQ(), store the regs pointer at the beginning, saving the old one:
    
            struct pt_regs *old_regs = set_irq_regs(regs);
    
    And put the old one back at the end:
    
            set_irq_regs(old_regs);
    
    Don't pass regs through to generic_handle_irq() or __do_IRQ().
    
    In timer_interrupt(), this sort of change will be necessary:
    
            -       update_process_times(user_mode(regs));
            -       profile_tick(CPU_PROFILING, regs);
            +       update_process_times(user_mode(get_irq_regs()));
            +       profile_tick(CPU_PROFILING);
    
    I'd like to move update_process_times()'s use of get_irq_regs() into itself,
    except that i386, alone of the archs, uses something other than user_mode().
    
    Some notes on the interrupt handling in the drivers:
    
     (*) input_dev() is now gone entirely.  The regs pointer is no longer stored in
         the input_dev struct.
    
     (*) finish_unlinks() in drivers/usb/host/ohci-q.c needs checking.  It does
         something different depending on whether it's been supplied with a regs
         pointer or not.
    
     (*) Various IRQ handler function pointers have been moved to type
         irq_handler_t.
    
    Signed-Off-By: David Howells <dhowells@redhat.com>
    (cherry picked from 1b16e7ac850969f38b375e511e3fa2f474a33867 commit)

diff --git a/drivers/scsi/aha1542.c b/drivers/scsi/aha1542.c
index 24f0f5461792..d7a61a6bdaae 100644
--- a/drivers/scsi/aha1542.c
+++ b/drivers/scsi/aha1542.c
@@ -174,9 +174,8 @@ static DEFINE_SPINLOCK(aha1542_lock);
 
 static void setup_mailboxes(int base_io, struct Scsi_Host *shpnt);
 static int aha1542_restart(struct Scsi_Host *shost);
-static void aha1542_intr_handle(struct Scsi_Host *shost, void *dev_id, struct pt_regs *regs);
-static irqreturn_t do_aha1542_intr_handle(int irq, void *dev_id,
-					struct pt_regs *regs);
+static void aha1542_intr_handle(struct Scsi_Host *shost, void *dev_id);
+static irqreturn_t do_aha1542_intr_handle(int irq, void *dev_id);
 
 #define aha1542_intr_reset(base)  outb(IRST, CONTROL(base))
 
@@ -416,8 +415,7 @@ static int __init aha1542_test_port(int bse, struct Scsi_Host *shpnt)
 }
 
 /* A quick wrapper for do_aha1542_intr_handle to grab the spin lock */
-static irqreturn_t do_aha1542_intr_handle(int irq, void *dev_id,
-					struct pt_regs *regs)
+static irqreturn_t do_aha1542_intr_handle(int irq, void *dev_id)
 {
 	unsigned long flags;
 	struct Scsi_Host *shost;
@@ -427,13 +425,13 @@ static irqreturn_t do_aha1542_intr_handle(int irq, void *dev_id,
 		panic("Splunge!");
 
 	spin_lock_irqsave(shost->host_lock, flags);
-	aha1542_intr_handle(shost, dev_id, regs);
+	aha1542_intr_handle(shost, dev_id);
 	spin_unlock_irqrestore(shost->host_lock, flags);
 	return IRQ_HANDLED;
 }
 
 /* A "high" level interrupt handler */
-static void aha1542_intr_handle(struct Scsi_Host *shost, void *dev_id, struct pt_regs *regs)
+static void aha1542_intr_handle(struct Scsi_Host *shost, void *dev_id)
 {
 	void (*my_done) (Scsi_Cmnd *) = NULL;
 	int errstatus, mbi, mbo, mbistatus;

commit 6ab3d5624e172c553004ecc862bfeac16d9d68b7
Author: Jörn Engel <joern@wohnheim.fh-wedel.de>
Date:   Fri Jun 30 19:25:36 2006 +0200

    Remove obsolete #include <linux/config.h>
    
    Signed-off-by: Jörn Engel <joern@wohnheim.fh-wedel.de>
    Signed-off-by: Adrian Bunk <bunk@stusta.de>

diff --git a/drivers/scsi/aha1542.c b/drivers/scsi/aha1542.c
index 86c6bd234591..24f0f5461792 100644
--- a/drivers/scsi/aha1542.c
+++ b/drivers/scsi/aha1542.c
@@ -25,7 +25,6 @@
  *        Added proper detection of the AHA-1640 (MCA version of AHA-1540)
  */
 
-#include <linux/config.h>
 #include <linux/module.h>
 #include <linux/interrupt.h>
 #include <linux/kernel.h>

commit 6391a11375de5e2bb1eb8481e54619761dc65d9f
Author: Tobias Klauser <tklauser@nuerscht.ch>
Date:   Thu Jun 8 22:23:48 2006 -0700

    [SCSI] drivers/scsi: Use ARRAY_SIZE macro
    
    Use ARRAY_SIZE macro instead of sizeof(x)/sizeof(x[0]) and remove
    duplicates of the macro.
    
    Signed-off-by: Tobias Klauser <tklauser@nuerscht.ch>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>

diff --git a/drivers/scsi/aha1542.c b/drivers/scsi/aha1542.c
index 51bad7a1e773..86c6bd234591 100644
--- a/drivers/scsi/aha1542.c
+++ b/drivers/scsi/aha1542.c
@@ -1011,7 +1011,7 @@ static int __init do_setup(char *str)
 
 	int count=setup_idx;
 
-	get_options(str, sizeof(ints)/sizeof(int), ints);
+	get_options(str, ARRAY_SIZE(ints), ints);
 	aha1542_setup(str,ints);
 
 	return count<setup_idx;
@@ -1072,8 +1072,7 @@ static int __init aha1542_detect(struct scsi_host_template * tpnt)
 		int slot = 0;
 		int pos = 0;
 
-		for (indx = 0; (slot !=  MCA_NOTFOUND) && 
-			     (indx < sizeof(bases)/sizeof(bases[0])); indx++) {
+		for (indx = 0; (slot != MCA_NOTFOUND) && (indx < ARRAY_SIZE(bases)); indx++) {
 
 			if (bases[indx])
 				continue;
@@ -1083,10 +1082,9 @@ static int __init aha1542_detect(struct scsi_host_template * tpnt)
 			if (slot == MCA_NOTFOUND)
 				break;
 
-			
 			/* Found one */
 			pos = mca_read_stored_pos(slot, 3);
-			
+
 			/* Decode address */
 			if (pos & 0x80) {
 				if (pos & 0x02) {
@@ -1118,23 +1116,22 @@ static int __init aha1542_detect(struct scsi_host_template * tpnt)
 			mca_set_adapter_name(slot, "Adapter AHA-1640");
 			mca_set_adapter_procfn(slot, NULL, NULL);
 			mca_mark_as_used(slot);
-			
+
 			/* Go on */
 			slot++;
 		}
-		
+
 	}
 #endif
 
 	/*
 	 *	Hunt for ISA Plug'n'Pray Adaptecs (AHA1535)
 	 */
-	 
+
 	if(isapnp)
 	{
 		struct pnp_dev *pdev = NULL;
-		for(indx = 0; indx <sizeof(bases)/sizeof(bases[0]);indx++)
-		{
+		for(indx = 0; indx < ARRAY_SIZE(bases); indx++) {
 			if(bases[indx])
 				continue;
 			pdev = pnp_find_dev(NULL, ISAPNP_VENDOR('A', 'D', 'P'), 
@@ -1144,29 +1141,29 @@ static int __init aha1542_detect(struct scsi_host_template * tpnt)
 			/*
 			 *	Activate the PnP card
 			 */
-			 
+
 			if(pnp_device_attach(pdev)<0)
 				continue;
-			
+
 			if(pnp_activate_dev(pdev)<0) {
 				pnp_device_detach(pdev);
 				continue;
 			}
-			
+
 			if(!pnp_port_valid(pdev, 0)) {
 				pnp_device_detach(pdev);
 				continue;
 			}
-				
+
 			bases[indx] = pnp_port_start(pdev, 0);
-			
+
 			/* The card can be queried for its DMA, we have 
 			   the DMA set up that is enough */
-			   
+
 			printk(KERN_INFO "ISAPnP found an AHA1535 at I/O 0x%03X\n", bases[indx]);
 		}
 	}
-	for (indx = 0; indx < sizeof(bases) / sizeof(bases[0]); indx++)
+	for (indx = 0; indx < ARRAY_SIZE(bases); indx++)
 		if (bases[indx] != 0 && request_region(bases[indx], 4, "aha1542")) {
 			shpnt = scsi_register(tpnt,
 					sizeof(struct aha1542_hostdata));

commit d0be4a7d29ad0bd3ce2209dd9e46d410b632db59
Author: Christoph Hellwig <hch@lst.de>
Date:   Mon Oct 31 18:31:40 2005 +0100

    [SCSI] remove Scsi_Host_Template typedef
    
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>

diff --git a/drivers/scsi/aha1542.c b/drivers/scsi/aha1542.c
index 1b1adfb384cb..51bad7a1e773 100644
--- a/drivers/scsi/aha1542.c
+++ b/drivers/scsi/aha1542.c
@@ -1021,7 +1021,7 @@ __setup("aha1542=",do_setup);
 #endif
 
 /* return non-zero on detection */
-static int __init aha1542_detect(Scsi_Host_Template * tpnt)
+static int __init aha1542_detect(struct scsi_host_template * tpnt)
 {
 	unsigned char dma_chan;
 	unsigned char irq_level;
@@ -1789,7 +1789,7 @@ static int aha1542_biosparam(struct scsi_device *sdev,
 MODULE_LICENSE("GPL");
 
 
-static Scsi_Host_Template driver_template = {
+static struct scsi_host_template driver_template = {
 	.proc_name		= "aha1542",
 	.name			= "Adaptec 1542",
 	.detect			= aha1542_detect,

commit c9475cb0c358ff0dd473544280d92482df491913
Author: Jesper Juhl <jesper.juhl@gmail.com>
Date:   Mon Nov 7 01:01:26 2005 -0800

    [PATCH] kfree cleanup: drivers/scsi
    
    This is the drivers/scsi/ part of the big kfree cleanup patch.
    
    Remove pointless checks for NULL prior to calling kfree() in drivers/scsi/.
    
    Signed-off-by: Jesper Juhl <jesper.juhl@gmail.com>
    Cc: James Bottomley <James.Bottomley@steeleye.com>
    Acked-by: Kai Makisara <kai.makisara@kolumbus.fi>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/drivers/scsi/aha1542.c b/drivers/scsi/aha1542.c
index adda750412f2..1b1adfb384cb 100644
--- a/drivers/scsi/aha1542.c
+++ b/drivers/scsi/aha1542.c
@@ -543,10 +543,8 @@ static void aha1542_intr_handle(struct Scsi_Host *shost, void *dev_id, struct pt
 			return;
 		}
 		my_done = SCtmp->scsi_done;
-		if (SCtmp->host_scribble) {
-			kfree(SCtmp->host_scribble);
-			SCtmp->host_scribble = NULL;
-		}
+		kfree(SCtmp->host_scribble);
+		SCtmp->host_scribble = NULL;
 		/* Fetch the sense data, and tuck it away, in the required slot.  The
 		   Adaptec automatically fetches it, and there is no guarantee that
 		   we will still have it in the cdb when we come back */
@@ -1432,10 +1430,8 @@ static int aha1542_dev_reset(Scsi_Cmnd * SCpnt)
 		    HOSTDATA(SCpnt->host)->SCint[i]->target == SCpnt->target) {
 			Scsi_Cmnd *SCtmp;
 			SCtmp = HOSTDATA(SCpnt->host)->SCint[i];
-			if (SCtmp->host_scribble) {
-				kfree(SCtmp->host_scribble);
-				SCtmp->host_scribble = NULL;
-			}
+			kfree(SCtmp->host_scribble);
+			SCtmp->host_scribble = NULL;
 			HOSTDATA(SCpnt->host)->SCint[i] = NULL;
 			HOSTDATA(SCpnt->host)->mb[i].status = 0;
 		}
@@ -1495,10 +1491,8 @@ static int aha1542_bus_reset(Scsi_Cmnd * SCpnt)
 				 */
 				continue;
 			}
-			if (SCtmp->host_scribble) {
-				kfree(SCtmp->host_scribble);
-				SCtmp->host_scribble = NULL;
-			}
+			kfree(SCtmp->host_scribble);
+			SCtmp->host_scribble = NULL;
 			HOSTDATA(SCpnt->device->host)->SCint[i] = NULL;
 			HOSTDATA(SCpnt->device->host)->mb[i].status = 0;
 		}
@@ -1565,10 +1559,8 @@ static int aha1542_host_reset(Scsi_Cmnd * SCpnt)
 				 */
 				continue;
 			}
-			if (SCtmp->host_scribble) {
-				kfree(SCtmp->host_scribble);
-				SCtmp->host_scribble = NULL;
-			}
+			kfree(SCtmp->host_scribble);
+			SCtmp->host_scribble = NULL;
 			HOSTDATA(SCpnt->device->host)->SCint[i] = NULL;
 			HOSTDATA(SCpnt->device->host)->mb[i].status = 0;
 		}
@@ -1711,10 +1703,8 @@ static int aha1542_old_reset(Scsi_Cmnd * SCpnt, unsigned int reset_flags)
 				Scsi_Cmnd *SCtmp;
 				SCtmp = HOSTDATA(SCpnt->host)->SCint[i];
 				SCtmp->result = DID_RESET << 16;
-				if (SCtmp->host_scribble) {
-					kfree(SCtmp->host_scribble);
-					SCtmp->host_scribble = NULL;
-				}
+				kfree(SCtmp->host_scribble);
+				SCtmp->host_scribble = NULL;
 				printk(KERN_WARNING "Sending DID_RESET for target %d\n", SCpnt->target);
 				SCtmp->scsi_done(SCpnt);
 
@@ -1757,10 +1747,8 @@ static int aha1542_old_reset(Scsi_Cmnd * SCpnt, unsigned int reset_flags)
 						Scsi_Cmnd *SCtmp;
 						SCtmp = HOSTDATA(SCpnt->host)->SCint[i];
 						SCtmp->result = DID_RESET << 16;
-						if (SCtmp->host_scribble) {
-							kfree(SCtmp->host_scribble);
-							SCtmp->host_scribble = NULL;
-						}
+						kfree(SCtmp->host_scribble);
+						SCtmp->host_scribble = NULL;
 						printk(KERN_WARNING "Sending DID_RESET for target %d\n", SCpnt->target);
 						SCtmp->scsi_done(SCpnt);
 

commit 017560fca496f72ed9dd734ffde63ce39dfe0411
Author: Jeff Garzik <jgarzik@pobox.com>
Date:   Mon Oct 24 18:04:36 2005 -0400

    [SCSI] use sfoo_printk() in drivers
    
    Rejections fixed up and
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>

diff --git a/drivers/scsi/aha1542.c b/drivers/scsi/aha1542.c
index 9ec4641a6348..adda750412f2 100644
--- a/drivers/scsi/aha1542.c
+++ b/drivers/scsi/aha1542.c
@@ -1405,7 +1405,8 @@ static int aha1542_dev_reset(Scsi_Cmnd * SCpnt)
 	 */
 	aha1542_out(SCpnt->device->host->io_port, &ahacmd, 1);
 
-	printk(KERN_WARNING "aha1542.c: Trying device reset for target %d\n", SCpnt->device->id);
+	scmd_printk(KERN_WARNING, SCpnt,
+		"Trying device reset for target\n");
 
 	return SUCCESS;
 

commit df0ae2497ddefd72a87f3a3b34ff32455d7d4ae0
Author: Jeff Garzik <jgarzik@pobox.com>
Date:   Sat May 28 07:57:14 2005 -0400

    [SCSI] allow sleeping in ->eh_host_reset_handler()
    
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>

diff --git a/drivers/scsi/aha1542.c b/drivers/scsi/aha1542.c
index f911b51e3042..9ec4641a6348 100644
--- a/drivers/scsi/aha1542.c
+++ b/drivers/scsi/aha1542.c
@@ -1530,7 +1530,6 @@ static int aha1542_host_reset(Scsi_Cmnd * SCpnt)
 	 * check for timeout, and if we are doing something like this
 	 * we are pretty desperate anyways.
 	 */
-	spin_unlock_irq(SCpnt->device->host->host_lock);
 	ssleep(4);
 	spin_lock_irq(SCpnt->device->host->host_lock);
 
@@ -1574,9 +1573,11 @@ static int aha1542_host_reset(Scsi_Cmnd * SCpnt)
 		}
 	}
 
+	spin_unlock_irq(SCpnt->device->host->host_lock);
 	return SUCCESS;
 
 fail:
+	spin_unlock_irq(SCpnt->device->host->host_lock);
 	return FAILED;
 }
 

commit 68b3aa7c9805aee9005a8ca53c5e99177961fbb9
Author: Jeff Garzik <jgarzik@pobox.com>
Date:   Sat May 28 07:56:31 2005 -0400

    [SCSI] allow sleeping in ->eh_bus_reset_handler()
    
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>

diff --git a/drivers/scsi/aha1542.c b/drivers/scsi/aha1542.c
index eb8bc6822cc1..f911b51e3042 100644
--- a/drivers/scsi/aha1542.c
+++ b/drivers/scsi/aha1542.c
@@ -1464,8 +1464,8 @@ static int aha1542_bus_reset(Scsi_Cmnd * SCpnt)
 	 * check for timeout, and if we are doing something like this
 	 * we are pretty desperate anyways.
 	 */
-	spin_unlock_irq(SCpnt->device->host->host_lock);
 	ssleep(4);
+
 	spin_lock_irq(SCpnt->device->host->host_lock);
 
 	WAIT(STATUS(SCpnt->device->host->io_port),
@@ -1503,9 +1503,11 @@ static int aha1542_bus_reset(Scsi_Cmnd * SCpnt)
 		}
 	}
 
+	spin_unlock_irq(SCpnt->device->host->host_lock);
 	return SUCCESS;
 
 fail:
+	spin_unlock_irq(SCpnt->device->host->host_lock);
 	return FAILED;
 }
 

commit 3471c288036bf0835a82d0b1bbce2002f6e68390
Author: Jeff Garzik <jgarzik@pobox.com>
Date:   Sat May 28 07:52:51 2005 -0400

    [SCSI] Remove no-op implementations of SCSI EH hooks
    
    Drivers need not implement a hook that returns FAILED, and does nothing
    else, since the SCSI midlayer code will do that for us.
    
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>

diff --git a/drivers/scsi/aha1542.c b/drivers/scsi/aha1542.c
index e9920a009593..eb8bc6822cc1 100644
--- a/drivers/scsi/aha1542.c
+++ b/drivers/scsi/aha1542.c
@@ -1348,20 +1348,6 @@ static int aha1542_restart(struct Scsi_Host *shost)
 	return 0;
 }
 
-static int aha1542_abort(Scsi_Cmnd * SCpnt)
-{
-
-	/*
-	 * The abort command does not leave the device in a clean state where
-	 *  it is available to be used again.  Until this gets worked out, we
-	 * will leave it commented out.  
-	 */
-
-	printk(KERN_ERR "aha1542.c: Unable to abort command for target %d\n",
-	       SCpnt->device->id);
-	return FAILED;
-}
-
 /*
  * This is a device reset.  This is handled by sending a special command
  * to the device.
@@ -1817,7 +1803,6 @@ static Scsi_Host_Template driver_template = {
 	.detect			= aha1542_detect,
 	.release		= aha1542_release,
 	.queuecommand		= aha1542_queuecommand,
-	.eh_abort_handler	= aha1542_abort,
 	.eh_device_reset_handler= aha1542_dev_reset,
 	.eh_bus_reset_handler	= aha1542_bus_reset,
 	.eh_host_reset_handler	= aha1542_host_reset,

commit 1da177e4c3f41524e886b7f1b8a0c1fc7321cac2
Author: Linus Torvalds <torvalds@ppc970.osdl.org>
Date:   Sat Apr 16 15:20:36 2005 -0700

    Linux-2.6.12-rc2
    
    Initial git repository build. I'm not bothering with the full history,
    even though we have it. We can create a separate "historical" git
    archive of that later if we want to, and in the meantime it's about
    3.2GB when imported into git - space that would just make the early
    git days unnecessarily complicated, when we don't have a lot of good
    infrastructure for it.
    
    Let it rip!

diff --git a/drivers/scsi/aha1542.c b/drivers/scsi/aha1542.c
new file mode 100644
index 000000000000..e9920a009593
--- /dev/null
+++ b/drivers/scsi/aha1542.c
@@ -0,0 +1,1832 @@
+/* $Id: aha1542.c,v 1.1 1992/07/24 06:27:38 root Exp root $
+ *  linux/kernel/aha1542.c
+ *
+ *  Copyright (C) 1992  Tommy Thorn
+ *  Copyright (C) 1993, 1994, 1995 Eric Youngdale
+ *
+ *  Modified by Eric Youngdale
+ *        Use request_irq and request_dma to help prevent unexpected conflicts
+ *        Set up on-board DMA controller, such that we do not have to
+ *        have the bios enabled to use the aha1542.
+ *  Modified by David Gentzel
+ *        Don't call request_dma if dma mask is 0 (for BusLogic BT-445S VL-Bus
+ *        controller).
+ *  Modified by Matti Aarnio
+ *        Accept parameters from LILO cmd-line. -- 1-Oct-94
+ *  Modified by Mike McLagan <mike.mclagan@linux.org>
+ *        Recognise extended mode on AHA1542CP, different bit than 1542CF
+ *        1-Jan-97
+ *  Modified by Bjorn L. Thordarson and Einar Thor Einarsson
+ *        Recognize that DMA0 is valid DMA channel -- 13-Jul-98
+ *  Modified by Chris Faulhaber <jedgar@fxp.org>
+ *        Added module command-line options
+ *        19-Jul-99
+ *  Modified by Adam Fritzler <mid@auk.cx>
+ *        Added proper detection of the AHA-1640 (MCA version of AHA-1540)
+ */
+
+#include <linux/config.h>
+#include <linux/module.h>
+#include <linux/interrupt.h>
+#include <linux/kernel.h>
+#include <linux/types.h>
+#include <linux/string.h>
+#include <linux/ioport.h>
+#include <linux/delay.h>
+#include <linux/proc_fs.h>
+#include <linux/init.h>
+#include <linux/spinlock.h>
+#include <linux/pci.h>
+#include <linux/isapnp.h>
+#include <linux/blkdev.h>
+#include <linux/mca.h>
+#include <linux/mca-legacy.h>
+
+#include <asm/dma.h>
+#include <asm/system.h>
+#include <asm/io.h>
+
+#include "scsi.h"
+#include <scsi/scsi_host.h>
+#include "aha1542.h"
+
+#define SCSI_BUF_PA(address)	isa_virt_to_bus(address)
+#define SCSI_SG_PA(sgent)	(isa_page_to_bus((sgent)->page) + (sgent)->offset)
+
+static void BAD_DMA(void *address, unsigned int length)
+{
+	printk(KERN_CRIT "buf vaddress %p paddress 0x%lx length %d\n",
+	       address,
+	       SCSI_BUF_PA(address),
+	       length);
+	panic("Buffer at physical address > 16Mb used for aha1542");
+}
+
+static void BAD_SG_DMA(Scsi_Cmnd * SCpnt,
+		       struct scatterlist *sgpnt,
+		       int nseg,
+		       int badseg)
+{
+	printk(KERN_CRIT "sgpnt[%d:%d] page %p/0x%llx length %u\n",
+	       badseg, nseg,
+	       page_address(sgpnt[badseg].page) + sgpnt[badseg].offset,
+	       (unsigned long long)SCSI_SG_PA(&sgpnt[badseg]),
+	       sgpnt[badseg].length);
+
+	/*
+	 * Not safe to continue.
+	 */
+	panic("Buffer at physical address > 16Mb used for aha1542");
+}
+
+#include<linux/stat.h>
+
+#ifdef DEBUG
+#define DEB(x) x
+#else
+#define DEB(x)
+#endif
+
+/*
+   static const char RCSid[] = "$Header: /usr/src/linux/kernel/blk_drv/scsi/RCS/aha1542.c,v 1.1 1992/07/24 06:27:38 root Exp root $";
+ */
+
+/* The adaptec can be configured for quite a number of addresses, but
+   I generally do not want the card poking around at random.  We allow
+   two addresses - this allows people to use the Adaptec with a Midi
+   card, which also used 0x330 -- can be overridden with LILO! */
+
+#define MAXBOARDS 4		/* Increase this and the sizes of the
+				   arrays below, if you need more.. */
+
+/* Boards 3,4 slots are reserved for ISAPnP/MCA scans */
+
+static unsigned int bases[MAXBOARDS] __initdata = {0x330, 0x334, 0, 0};
+
+/* set by aha1542_setup according to the command line; they also may
+   be marked __initdata, but require zero initializers then */
+
+static int setup_called[MAXBOARDS];
+static int setup_buson[MAXBOARDS];
+static int setup_busoff[MAXBOARDS];
+static int setup_dmaspeed[MAXBOARDS] __initdata = { -1, -1, -1, -1 };
+
+/*
+ * LILO/Module params:  aha1542=<PORTBASE>[,<BUSON>,<BUSOFF>[,<DMASPEED>]]
+ *
+ * Where:  <PORTBASE> is any of the valid AHA addresses:
+ *                      0x130, 0x134, 0x230, 0x234, 0x330, 0x334
+ *         <BUSON>  is the time (in microsecs) that AHA spends on the AT-bus
+ *                  when transferring data.  1542A power-on default is 11us,
+ *                  valid values are in range: 2..15 (decimal)
+ *         <BUSOFF> is the time that AHA spends OFF THE BUS after while
+ *                  it is transferring data (not to monopolize the bus).
+ *                  Power-on default is 4us, valid range: 1..64 microseconds.
+ *         <DMASPEED> Default is jumper selected (1542A: on the J1),
+ *                  but experimenter can alter it with this.
+ *                  Valid values: 5, 6, 7, 8, 10 (MB/s)
+ *                  Factory default is 5 MB/s.
+ */
+
+#if defined(MODULE)
+static int isapnp = 0;
+static int aha1542[] = {0x330, 11, 4, -1};
+module_param_array(aha1542, int, NULL, 0);
+module_param(isapnp, bool, 0);
+
+static struct isapnp_device_id id_table[] __initdata = {
+	{
+		ISAPNP_ANY_ID, ISAPNP_ANY_ID,
+		ISAPNP_VENDOR('A', 'D', 'P'), ISAPNP_FUNCTION(0x1542),
+		0
+	},
+	{0}
+};
+
+MODULE_DEVICE_TABLE(isapnp, id_table);
+
+#else
+static int isapnp = 1;
+#endif
+
+#define BIOS_TRANSLATION_1632 0	/* Used by some old 1542A boards */
+#define BIOS_TRANSLATION_6432 1	/* Default case these days */
+#define BIOS_TRANSLATION_25563 2	/* Big disk case */
+
+struct aha1542_hostdata {
+	/* This will effectively start both of them at the first mailbox */
+	int bios_translation;	/* Mapping bios uses - for compatibility */
+	int aha1542_last_mbi_used;
+	int aha1542_last_mbo_used;
+	Scsi_Cmnd *SCint[AHA1542_MAILBOXES];
+	struct mailbox mb[2 * AHA1542_MAILBOXES];
+	struct ccb ccb[AHA1542_MAILBOXES];
+};
+
+#define HOSTDATA(host) ((struct aha1542_hostdata *) &host->hostdata)
+
+static struct Scsi_Host *aha_host[7];	/* One for each IRQ level (9-15) */
+
+static DEFINE_SPINLOCK(aha1542_lock);
+
+
+
+#define WAITnexttimeout 3000000
+
+static void setup_mailboxes(int base_io, struct Scsi_Host *shpnt);
+static int aha1542_restart(struct Scsi_Host *shost);
+static void aha1542_intr_handle(struct Scsi_Host *shost, void *dev_id, struct pt_regs *regs);
+static irqreturn_t do_aha1542_intr_handle(int irq, void *dev_id,
+					struct pt_regs *regs);
+
+#define aha1542_intr_reset(base)  outb(IRST, CONTROL(base))
+
+#define WAIT(port, mask, allof, noneof)					\
+ { register int WAITbits;						\
+   register int WAITtimeout = WAITnexttimeout;				\
+   while (1) {								\
+     WAITbits = inb(port) & (mask);					\
+     if ((WAITbits & (allof)) == (allof) && ((WAITbits & (noneof)) == 0)) \
+       break;                                                         	\
+     if (--WAITtimeout == 0) goto fail;					\
+   }									\
+ }
+
+/* Similar to WAIT, except we use the udelay call to regulate the
+   amount of time we wait.  */
+#define WAITd(port, mask, allof, noneof, timeout)			\
+ { register int WAITbits;						\
+   register int WAITtimeout = timeout;					\
+   while (1) {								\
+     WAITbits = inb(port) & (mask);					\
+     if ((WAITbits & (allof)) == (allof) && ((WAITbits & (noneof)) == 0)) \
+       break;                                                         	\
+     mdelay(1);							\
+     if (--WAITtimeout == 0) goto fail;					\
+   }									\
+ }
+
+static void aha1542_stat(void)
+{
+/*	int s = inb(STATUS), i = inb(INTRFLAGS);
+	printk("status=%x intrflags=%x\n", s, i, WAITnexttimeout-WAITtimeout); */
+}
+
+/* This is a bit complicated, but we need to make sure that an interrupt
+   routine does not send something out while we are in the middle of this.
+   Fortunately, it is only at boot time that multi-byte messages
+   are ever sent. */
+static int aha1542_out(unsigned int base, unchar * cmdp, int len)
+{
+	unsigned long flags = 0;
+	int got_lock;
+
+	if (len == 1) {
+		got_lock = 0;
+		while (1 == 1) {
+			WAIT(STATUS(base), CDF, 0, CDF);
+			spin_lock_irqsave(&aha1542_lock, flags);
+			if (inb(STATUS(base)) & CDF) {
+				spin_unlock_irqrestore(&aha1542_lock, flags);
+				continue;
+			}
+			outb(*cmdp, DATA(base));
+			spin_unlock_irqrestore(&aha1542_lock, flags);
+			return 0;
+		}
+	} else {
+		spin_lock_irqsave(&aha1542_lock, flags);
+		got_lock = 1;
+		while (len--) {
+			WAIT(STATUS(base), CDF, 0, CDF);
+			outb(*cmdp++, DATA(base));
+		}
+		spin_unlock_irqrestore(&aha1542_lock, flags);
+	}
+	return 0;
+fail:
+	if (got_lock)
+		spin_unlock_irqrestore(&aha1542_lock, flags);
+	printk(KERN_ERR "aha1542_out failed(%d): ", len + 1);
+	aha1542_stat();
+	return 1;
+}
+
+/* Only used at boot time, so we do not need to worry about latency as much
+   here */
+
+static int __init aha1542_in(unsigned int base, unchar * cmdp, int len)
+{
+	unsigned long flags;
+
+	spin_lock_irqsave(&aha1542_lock, flags);
+	while (len--) {
+		WAIT(STATUS(base), DF, DF, 0);
+		*cmdp++ = inb(DATA(base));
+	}
+	spin_unlock_irqrestore(&aha1542_lock, flags);
+	return 0;
+fail:
+	spin_unlock_irqrestore(&aha1542_lock, flags);
+	printk(KERN_ERR "aha1542_in failed(%d): ", len + 1);
+	aha1542_stat();
+	return 1;
+}
+
+/* Similar to aha1542_in, except that we wait a very short period of time.
+   We use this if we know the board is alive and awake, but we are not sure
+   if the board will respond to the command we are about to send or not */
+static int __init aha1542_in1(unsigned int base, unchar * cmdp, int len)
+{
+	unsigned long flags;
+
+	spin_lock_irqsave(&aha1542_lock, flags);
+	while (len--) {
+		WAITd(STATUS(base), DF, DF, 0, 100);
+		*cmdp++ = inb(DATA(base));
+	}
+	spin_unlock_irqrestore(&aha1542_lock, flags);
+	return 0;
+fail:
+	spin_unlock_irqrestore(&aha1542_lock, flags);
+	return 1;
+}
+
+static int makecode(unsigned hosterr, unsigned scsierr)
+{
+	switch (hosterr) {
+	case 0x0:
+	case 0xa:		/* Linked command complete without error and linked normally */
+	case 0xb:		/* Linked command complete without error, interrupt generated */
+		hosterr = 0;
+		break;
+
+	case 0x11:		/* Selection time out-The initiator selection or target
+				   reselection was not complete within the SCSI Time out period */
+		hosterr = DID_TIME_OUT;
+		break;
+
+	case 0x12:		/* Data overrun/underrun-The target attempted to transfer more data
+				   than was allocated by the Data Length field or the sum of the
+				   Scatter / Gather Data Length fields. */
+
+	case 0x13:		/* Unexpected bus free-The target dropped the SCSI BSY at an unexpected time. */
+
+	case 0x15:		/* MBO command was not 00, 01 or 02-The first byte of the CB was
+				   invalid. This usually indicates a software failure. */
+
+	case 0x16:		/* Invalid CCB Operation Code-The first byte of the CCB was invalid.
+				   This usually indicates a software failure. */
+
+	case 0x17:		/* Linked CCB does not have the same LUN-A subsequent CCB of a set
+				   of linked CCB's does not specify the same logical unit number as
+				   the first. */
+	case 0x18:		/* Invalid Target Direction received from Host-The direction of a
+				   Target Mode CCB was invalid. */
+
+	case 0x19:		/* Duplicate CCB Received in Target Mode-More than once CCB was
+				   received to service data transfer between the same target LUN
+				   and initiator SCSI ID in the same direction. */
+
+	case 0x1a:		/* Invalid CCB or Segment List Parameter-A segment list with a zero
+				   length segment or invalid segment list boundaries was received.
+				   A CCB parameter was invalid. */
+		DEB(printk("Aha1542: %x %x\n", hosterr, scsierr));
+		hosterr = DID_ERROR;	/* Couldn't find any better */
+		break;
+
+	case 0x14:		/* Target bus phase sequence failure-An invalid bus phase or bus
+				   phase sequence was requested by the target. The host adapter
+				   will generate a SCSI Reset Condition, notifying the host with
+				   a SCRD interrupt */
+		hosterr = DID_RESET;
+		break;
+	default:
+		printk(KERN_ERR "aha1542: makecode: unknown hoststatus %x\n", hosterr);
+		break;
+	}
+	return scsierr | (hosterr << 16);
+}
+
+static int __init aha1542_test_port(int bse, struct Scsi_Host *shpnt)
+{
+	unchar inquiry_cmd[] = {CMD_INQUIRY};
+	unchar inquiry_result[4];
+	unchar *cmdp;
+	int len;
+	volatile int debug = 0;
+
+	/* Quick and dirty test for presence of the card. */
+	if (inb(STATUS(bse)) == 0xff)
+		return 0;
+
+	/* Reset the adapter. I ought to make a hard reset, but it's not really necessary */
+
+	/*  DEB(printk("aha1542_test_port called \n")); */
+
+	/* In case some other card was probing here, reset interrupts */
+	aha1542_intr_reset(bse);	/* reset interrupts, so they don't block */
+
+	outb(SRST | IRST /*|SCRST */ , CONTROL(bse));
+
+	mdelay(20);		/* Wait a little bit for things to settle down. */
+
+	debug = 1;
+	/* Expect INIT and IDLE, any of the others are bad */
+	WAIT(STATUS(bse), STATMASK, INIT | IDLE, STST | DIAGF | INVDCMD | DF | CDF);
+
+	debug = 2;
+	/* Shouldn't have generated any interrupts during reset */
+	if (inb(INTRFLAGS(bse)) & INTRMASK)
+		goto fail;
+
+
+	/* Perform a host adapter inquiry instead so we do not need to set
+	   up the mailboxes ahead of time */
+
+	aha1542_out(bse, inquiry_cmd, 1);
+
+	debug = 3;
+	len = 4;
+	cmdp = &inquiry_result[0];
+
+	while (len--) {
+		WAIT(STATUS(bse), DF, DF, 0);
+		*cmdp++ = inb(DATA(bse));
+	}
+
+	debug = 8;
+	/* Reading port should reset DF */
+	if (inb(STATUS(bse)) & DF)
+		goto fail;
+
+	debug = 9;
+	/* When HACC, command is completed, and we're though testing */
+	WAIT(INTRFLAGS(bse), HACC, HACC, 0);
+	/* now initialize adapter */
+
+	debug = 10;
+	/* Clear interrupts */
+	outb(IRST, CONTROL(bse));
+
+	debug = 11;
+
+	return debug;		/* 1 = ok */
+fail:
+	return 0;		/* 0 = not ok */
+}
+
+/* A quick wrapper for do_aha1542_intr_handle to grab the spin lock */
+static irqreturn_t do_aha1542_intr_handle(int irq, void *dev_id,
+					struct pt_regs *regs)
+{
+	unsigned long flags;
+	struct Scsi_Host *shost;
+
+	shost = aha_host[irq - 9];
+	if (!shost)
+		panic("Splunge!");
+
+	spin_lock_irqsave(shost->host_lock, flags);
+	aha1542_intr_handle(shost, dev_id, regs);
+	spin_unlock_irqrestore(shost->host_lock, flags);
+	return IRQ_HANDLED;
+}
+
+/* A "high" level interrupt handler */
+static void aha1542_intr_handle(struct Scsi_Host *shost, void *dev_id, struct pt_regs *regs)
+{
+	void (*my_done) (Scsi_Cmnd *) = NULL;
+	int errstatus, mbi, mbo, mbistatus;
+	int number_serviced;
+	unsigned long flags;
+	Scsi_Cmnd *SCtmp;
+	int flag;
+	int needs_restart;
+	struct mailbox *mb;
+	struct ccb *ccb;
+
+	mb = HOSTDATA(shost)->mb;
+	ccb = HOSTDATA(shost)->ccb;
+
+#ifdef DEBUG
+	{
+		flag = inb(INTRFLAGS(shost->io_port));
+		printk(KERN_DEBUG "aha1542_intr_handle: ");
+		if (!(flag & ANYINTR))
+			printk("no interrupt?");
+		if (flag & MBIF)
+			printk("MBIF ");
+		if (flag & MBOA)
+			printk("MBOF ");
+		if (flag & HACC)
+			printk("HACC ");
+		if (flag & SCRD)
+			printk("SCRD ");
+		printk("status %02x\n", inb(STATUS(shost->io_port)));
+	};
+#endif
+	number_serviced = 0;
+	needs_restart = 0;
+
+	while (1 == 1) {
+		flag = inb(INTRFLAGS(shost->io_port));
+
+		/* Check for unusual interrupts.  If any of these happen, we should
+		   probably do something special, but for now just printing a message
+		   is sufficient.  A SCSI reset detected is something that we really
+		   need to deal with in some way. */
+		if (flag & ~MBIF) {
+			if (flag & MBOA)
+				printk("MBOF ");
+			if (flag & HACC)
+				printk("HACC ");
+			if (flag & SCRD) {
+				needs_restart = 1;
+				printk("SCRD ");
+			}
+		}
+		aha1542_intr_reset(shost->io_port);
+
+		spin_lock_irqsave(&aha1542_lock, flags);
+		mbi = HOSTDATA(shost)->aha1542_last_mbi_used + 1;
+		if (mbi >= 2 * AHA1542_MAILBOXES)
+			mbi = AHA1542_MAILBOXES;
+
+		do {
+			if (mb[mbi].status != 0)
+				break;
+			mbi++;
+			if (mbi >= 2 * AHA1542_MAILBOXES)
+				mbi = AHA1542_MAILBOXES;
+		} while (mbi != HOSTDATA(shost)->aha1542_last_mbi_used);
+
+		if (mb[mbi].status == 0) {
+			spin_unlock_irqrestore(&aha1542_lock, flags);
+			/* Hmm, no mail.  Must have read it the last time around */
+			if (!number_serviced && !needs_restart)
+				printk(KERN_WARNING "aha1542.c: interrupt received, but no mail.\n");
+			/* We detected a reset.  Restart all pending commands for
+			   devices that use the hard reset option */
+			if (needs_restart)
+				aha1542_restart(shost);
+			return;
+		};
+
+		mbo = (scsi2int(mb[mbi].ccbptr) - (SCSI_BUF_PA(&ccb[0]))) / sizeof(struct ccb);
+		mbistatus = mb[mbi].status;
+		mb[mbi].status = 0;
+		HOSTDATA(shost)->aha1542_last_mbi_used = mbi;
+		spin_unlock_irqrestore(&aha1542_lock, flags);
+
+#ifdef DEBUG
+		{
+			if (ccb[mbo].tarstat | ccb[mbo].hastat)
+				printk(KERN_DEBUG "aha1542_command: returning %x (status %d)\n",
+				       ccb[mbo].tarstat + ((int) ccb[mbo].hastat << 16), mb[mbi].status);
+		};
+#endif
+
+		if (mbistatus == 3)
+			continue;	/* Aborted command not found */
+
+#ifdef DEBUG
+		printk(KERN_DEBUG "...done %d %d\n", mbo, mbi);
+#endif
+
+		SCtmp = HOSTDATA(shost)->SCint[mbo];
+
+		if (!SCtmp || !SCtmp->scsi_done) {
+			printk(KERN_WARNING "aha1542_intr_handle: Unexpected interrupt\n");
+			printk(KERN_WARNING "tarstat=%x, hastat=%x idlun=%x ccb#=%d \n", ccb[mbo].tarstat,
+			       ccb[mbo].hastat, ccb[mbo].idlun, mbo);
+			return;
+		}
+		my_done = SCtmp->scsi_done;
+		if (SCtmp->host_scribble) {
+			kfree(SCtmp->host_scribble);
+			SCtmp->host_scribble = NULL;
+		}
+		/* Fetch the sense data, and tuck it away, in the required slot.  The
+		   Adaptec automatically fetches it, and there is no guarantee that
+		   we will still have it in the cdb when we come back */
+		if (ccb[mbo].tarstat == 2)
+			memcpy(SCtmp->sense_buffer, &ccb[mbo].cdb[ccb[mbo].cdblen],
+			       sizeof(SCtmp->sense_buffer));
+
+
+		/* is there mail :-) */
+
+		/* more error checking left out here */
+		if (mbistatus != 1)
+			/* This is surely wrong, but I don't know what's right */
+			errstatus = makecode(ccb[mbo].hastat, ccb[mbo].tarstat);
+		else
+			errstatus = 0;
+
+#ifdef DEBUG
+		if (errstatus)
+			printk(KERN_DEBUG "(aha1542 error:%x %x %x) ", errstatus,
+			       ccb[mbo].hastat, ccb[mbo].tarstat);
+#endif
+
+		if (ccb[mbo].tarstat == 2) {
+#ifdef DEBUG
+			int i;
+#endif
+			DEB(printk("aha1542_intr_handle: sense:"));
+#ifdef DEBUG
+			for (i = 0; i < 12; i++)
+				printk("%02x ", ccb[mbo].cdb[ccb[mbo].cdblen + i]);
+			printk("\n");
+#endif
+			/*
+			   DEB(printk("aha1542_intr_handle: buf:"));
+			   for (i = 0; i < bufflen; i++)
+			   printk("%02x ", ((unchar *)buff)[i]);
+			   printk("\n");
+			 */
+		}
+		DEB(if (errstatus) printk("aha1542_intr_handle: returning %6x\n", errstatus));
+		SCtmp->result = errstatus;
+		HOSTDATA(shost)->SCint[mbo] = NULL;	/* This effectively frees up the mailbox slot, as
+							   far as queuecommand is concerned */
+		my_done(SCtmp);
+		number_serviced++;
+	};
+}
+
+static int aha1542_queuecommand(Scsi_Cmnd * SCpnt, void (*done) (Scsi_Cmnd *))
+{
+	unchar ahacmd = CMD_START_SCSI;
+	unchar direction;
+	unchar *cmd = (unchar *) SCpnt->cmnd;
+	unchar target = SCpnt->device->id;
+	unchar lun = SCpnt->device->lun;
+	unsigned long flags;
+	void *buff = SCpnt->request_buffer;
+	int bufflen = SCpnt->request_bufflen;
+	int mbo;
+	struct mailbox *mb;
+	struct ccb *ccb;
+
+	DEB(int i);
+
+	mb = HOSTDATA(SCpnt->device->host)->mb;
+	ccb = HOSTDATA(SCpnt->device->host)->ccb;
+
+	DEB(if (target > 1) {
+	    SCpnt->result = DID_TIME_OUT << 16;
+	    done(SCpnt); return 0;
+	    }
+	);
+
+	if (*cmd == REQUEST_SENSE) {
+		/* Don't do the command - we have the sense data already */
+#if 0
+		/* scsi_request_sense() provides a buffer of size 256,
+		   so there is no reason to expect equality */
+		if (bufflen != sizeof(SCpnt->sense_buffer))
+			printk(KERN_CRIT "aha1542: Wrong buffer length supplied "
+			       "for request sense (%d)\n", bufflen);
+#endif
+		SCpnt->result = 0;
+		done(SCpnt);
+		return 0;
+	}
+#ifdef DEBUG
+	if (*cmd == READ_10 || *cmd == WRITE_10)
+		i = xscsi2int(cmd + 2);
+	else if (*cmd == READ_6 || *cmd == WRITE_6)
+		i = scsi2int(cmd + 2);
+	else
+		i = -1;
+	if (done)
+		printk(KERN_DEBUG "aha1542_queuecommand: dev %d cmd %02x pos %d len %d ", target, *cmd, i, bufflen);
+	else
+		printk(KERN_DEBUG "aha1542_command: dev %d cmd %02x pos %d len %d ", target, *cmd, i, bufflen);
+	aha1542_stat();
+	printk(KERN_DEBUG "aha1542_queuecommand: dumping scsi cmd:");
+	for (i = 0; i < SCpnt->cmd_len; i++)
+		printk("%02x ", cmd[i]);
+	printk("\n");
+	if (*cmd == WRITE_10 || *cmd == WRITE_6)
+		return 0;	/* we are still testing, so *don't* write */
+#endif
+	/* Use the outgoing mailboxes in a round-robin fashion, because this
+	   is how the host adapter will scan for them */
+
+	spin_lock_irqsave(&aha1542_lock, flags);
+	mbo = HOSTDATA(SCpnt->device->host)->aha1542_last_mbo_used + 1;
+	if (mbo >= AHA1542_MAILBOXES)
+		mbo = 0;
+
+	do {
+		if (mb[mbo].status == 0 && HOSTDATA(SCpnt->device->host)->SCint[mbo] == NULL)
+			break;
+		mbo++;
+		if (mbo >= AHA1542_MAILBOXES)
+			mbo = 0;
+	} while (mbo != HOSTDATA(SCpnt->device->host)->aha1542_last_mbo_used);
+
+	if (mb[mbo].status || HOSTDATA(SCpnt->device->host)->SCint[mbo])
+		panic("Unable to find empty mailbox for aha1542.\n");
+
+	HOSTDATA(SCpnt->device->host)->SCint[mbo] = SCpnt;	/* This will effectively prevent someone else from
+							   screwing with this cdb. */
+
+	HOSTDATA(SCpnt->device->host)->aha1542_last_mbo_used = mbo;
+	spin_unlock_irqrestore(&aha1542_lock, flags);
+
+#ifdef DEBUG
+	printk(KERN_DEBUG "Sending command (%d %x)...", mbo, done);
+#endif
+
+	any2scsi(mb[mbo].ccbptr, SCSI_BUF_PA(&ccb[mbo]));	/* This gets trashed for some reason */
+
+	memset(&ccb[mbo], 0, sizeof(struct ccb));
+
+	ccb[mbo].cdblen = SCpnt->cmd_len;
+
+	direction = 0;
+	if (*cmd == READ_10 || *cmd == READ_6)
+		direction = 8;
+	else if (*cmd == WRITE_10 || *cmd == WRITE_6)
+		direction = 16;
+
+	memcpy(ccb[mbo].cdb, cmd, ccb[mbo].cdblen);
+
+	if (SCpnt->use_sg) {
+		struct scatterlist *sgpnt;
+		struct chain *cptr;
+#ifdef DEBUG
+		unsigned char *ptr;
+#endif
+		int i;
+		ccb[mbo].op = 2;	/* SCSI Initiator Command  w/scatter-gather */
+		SCpnt->host_scribble = (unsigned char *) kmalloc(512, GFP_KERNEL | GFP_DMA);
+		sgpnt = (struct scatterlist *) SCpnt->request_buffer;
+		cptr = (struct chain *) SCpnt->host_scribble;
+		if (cptr == NULL) {
+			/* free the claimed mailbox slot */
+			HOSTDATA(SCpnt->device->host)->SCint[mbo] = NULL;
+			return SCSI_MLQUEUE_HOST_BUSY;
+		}
+		for (i = 0; i < SCpnt->use_sg; i++) {
+			if (sgpnt[i].length == 0 || SCpnt->use_sg > 16 ||
+			    (((int) sgpnt[i].offset) & 1) || (sgpnt[i].length & 1)) {
+				unsigned char *ptr;
+				printk(KERN_CRIT "Bad segment list supplied to aha1542.c (%d, %d)\n", SCpnt->use_sg, i);
+				for (i = 0; i < SCpnt->use_sg; i++) {
+					printk(KERN_CRIT "%d: %p %d\n", i,
+					       (page_address(sgpnt[i].page) +
+						sgpnt[i].offset),
+					       sgpnt[i].length);
+				};
+				printk(KERN_CRIT "cptr %x: ", (unsigned int) cptr);
+				ptr = (unsigned char *) &cptr[i];
+				for (i = 0; i < 18; i++)
+					printk("%02x ", ptr[i]);
+				panic("Foooooooood fight!");
+			};
+			any2scsi(cptr[i].dataptr, SCSI_SG_PA(&sgpnt[i]));
+			if (SCSI_SG_PA(&sgpnt[i]) + sgpnt[i].length - 1 > ISA_DMA_THRESHOLD)
+				BAD_SG_DMA(SCpnt, sgpnt, SCpnt->use_sg, i);
+			any2scsi(cptr[i].datalen, sgpnt[i].length);
+		};
+		any2scsi(ccb[mbo].datalen, SCpnt->use_sg * sizeof(struct chain));
+		any2scsi(ccb[mbo].dataptr, SCSI_BUF_PA(cptr));
+#ifdef DEBUG
+		printk("cptr %x: ", cptr);
+		ptr = (unsigned char *) cptr;
+		for (i = 0; i < 18; i++)
+			printk("%02x ", ptr[i]);
+#endif
+	} else {
+		ccb[mbo].op = 0;	/* SCSI Initiator Command */
+		SCpnt->host_scribble = NULL;
+		any2scsi(ccb[mbo].datalen, bufflen);
+		if (buff && SCSI_BUF_PA(buff + bufflen - 1) > ISA_DMA_THRESHOLD)
+			BAD_DMA(buff, bufflen);
+		any2scsi(ccb[mbo].dataptr, SCSI_BUF_PA(buff));
+	};
+	ccb[mbo].idlun = (target & 7) << 5 | direction | (lun & 7);	/*SCSI Target Id */
+	ccb[mbo].rsalen = 16;
+	ccb[mbo].linkptr[0] = ccb[mbo].linkptr[1] = ccb[mbo].linkptr[2] = 0;
+	ccb[mbo].commlinkid = 0;
+
+#ifdef DEBUG
+	{
+		int i;
+		printk(KERN_DEBUG "aha1542_command: sending.. ");
+		for (i = 0; i < sizeof(ccb[mbo]) - 10; i++)
+			printk("%02x ", ((unchar *) & ccb[mbo])[i]);
+	};
+#endif
+
+	if (done) {
+		DEB(printk("aha1542_queuecommand: now waiting for interrupt ");
+		    aha1542_stat());
+		SCpnt->scsi_done = done;
+		mb[mbo].status = 1;
+		aha1542_out(SCpnt->device->host->io_port, &ahacmd, 1);	/* start scsi command */
+		DEB(aha1542_stat());
+	} else
+		printk("aha1542_queuecommand: done can't be NULL\n");
+
+	return 0;
+}
+
+/* Initialize mailboxes */
+static void setup_mailboxes(int bse, struct Scsi_Host *shpnt)
+{
+	int i;
+	struct mailbox *mb;
+	struct ccb *ccb;
+
+	unchar cmd[5] = { CMD_MBINIT, AHA1542_MAILBOXES, 0, 0, 0};
+
+	mb = HOSTDATA(shpnt)->mb;
+	ccb = HOSTDATA(shpnt)->ccb;
+
+	for (i = 0; i < AHA1542_MAILBOXES; i++) {
+		mb[i].status = mb[AHA1542_MAILBOXES + i].status = 0;
+		any2scsi(mb[i].ccbptr, SCSI_BUF_PA(&ccb[i]));
+	};
+	aha1542_intr_reset(bse);	/* reset interrupts, so they don't block */
+	any2scsi((cmd + 2), SCSI_BUF_PA(mb));
+	aha1542_out(bse, cmd, 5);
+	WAIT(INTRFLAGS(bse), INTRMASK, HACC, 0);
+	while (0) {
+fail:
+		printk(KERN_ERR "aha1542_detect: failed setting up mailboxes\n");
+	}
+	aha1542_intr_reset(bse);
+}
+
+static int __init aha1542_getconfig(int base_io, unsigned char *irq_level, unsigned char *dma_chan, unsigned char *scsi_id)
+{
+	unchar inquiry_cmd[] = {CMD_RETCONF};
+	unchar inquiry_result[3];
+	int i;
+	i = inb(STATUS(base_io));
+	if (i & DF) {
+		i = inb(DATA(base_io));
+	};
+	aha1542_out(base_io, inquiry_cmd, 1);
+	aha1542_in(base_io, inquiry_result, 3);
+	WAIT(INTRFLAGS(base_io), INTRMASK, HACC, 0);
+	while (0) {
+fail:
+		printk(KERN_ERR "aha1542_detect: query board settings\n");
+	}
+	aha1542_intr_reset(base_io);
+	switch (inquiry_result[0]) {
+	case 0x80:
+		*dma_chan = 7;
+		break;
+	case 0x40:
+		*dma_chan = 6;
+		break;
+	case 0x20:
+		*dma_chan = 5;
+		break;
+	case 0x01:
+		*dma_chan = 0;
+		break;
+	case 0:
+		/* This means that the adapter, although Adaptec 1542 compatible, doesn't use a DMA channel.
+		   Currently only aware of the BusLogic BT-445S VL-Bus adapter which needs this. */
+		*dma_chan = 0xFF;
+		break;
+	default:
+		printk(KERN_ERR "Unable to determine Adaptec DMA priority.  Disabling board\n");
+		return -1;
+	};
+	switch (inquiry_result[1]) {
+	case 0x40:
+		*irq_level = 15;
+		break;
+	case 0x20:
+		*irq_level = 14;
+		break;
+	case 0x8:
+		*irq_level = 12;
+		break;
+	case 0x4:
+		*irq_level = 11;
+		break;
+	case 0x2:
+		*irq_level = 10;
+		break;
+	case 0x1:
+		*irq_level = 9;
+		break;
+	default:
+		printk(KERN_ERR "Unable to determine Adaptec IRQ level.  Disabling board\n");
+		return -1;
+	};
+	*scsi_id = inquiry_result[2] & 7;
+	return 0;
+}
+
+/* This function should only be called for 1542C boards - we can detect
+   the special firmware settings and unlock the board */
+
+static int __init aha1542_mbenable(int base)
+{
+	static unchar mbenable_cmd[3];
+	static unchar mbenable_result[2];
+	int retval;
+
+	retval = BIOS_TRANSLATION_6432;
+
+	mbenable_cmd[0] = CMD_EXTBIOS;
+	aha1542_out(base, mbenable_cmd, 1);
+	if (aha1542_in1(base, mbenable_result, 2))
+		return retval;
+	WAITd(INTRFLAGS(base), INTRMASK, HACC, 0, 100);
+	aha1542_intr_reset(base);
+
+	if ((mbenable_result[0] & 0x08) || mbenable_result[1]) {
+		mbenable_cmd[0] = CMD_MBENABLE;
+		mbenable_cmd[1] = 0;
+		mbenable_cmd[2] = mbenable_result[1];
+
+		if ((mbenable_result[0] & 0x08) && (mbenable_result[1] & 0x03))
+			retval = BIOS_TRANSLATION_25563;
+
+		aha1542_out(base, mbenable_cmd, 3);
+		WAIT(INTRFLAGS(base), INTRMASK, HACC, 0);
+	};
+	while (0) {
+fail:
+		printk(KERN_ERR "aha1542_mbenable: Mailbox init failed\n");
+	}
+	aha1542_intr_reset(base);
+	return retval;
+}
+
+/* Query the board to find out if it is a 1542 or a 1740, or whatever. */
+static int __init aha1542_query(int base_io, int *transl)
+{
+	unchar inquiry_cmd[] = {CMD_INQUIRY};
+	unchar inquiry_result[4];
+	int i;
+	i = inb(STATUS(base_io));
+	if (i & DF) {
+		i = inb(DATA(base_io));
+	};
+	aha1542_out(base_io, inquiry_cmd, 1);
+	aha1542_in(base_io, inquiry_result, 4);
+	WAIT(INTRFLAGS(base_io), INTRMASK, HACC, 0);
+	while (0) {
+fail:
+		printk(KERN_ERR "aha1542_detect: query card type\n");
+	}
+	aha1542_intr_reset(base_io);
+
+	*transl = BIOS_TRANSLATION_6432;	/* Default case */
+
+	/* For an AHA1740 series board, we ignore the board since there is a
+	   hardware bug which can lead to wrong blocks being returned if the board
+	   is operating in the 1542 emulation mode.  Since there is an extended mode
+	   driver, we simply ignore the board and let the 1740 driver pick it up.
+	 */
+
+	if (inquiry_result[0] == 0x43) {
+		printk(KERN_INFO "aha1542.c: Emulation mode not supported for AHA 174N hardware.\n");
+		return 1;
+	};
+
+	/* Always call this - boards that do not support extended bios translation
+	   will ignore the command, and we will set the proper default */
+
+	*transl = aha1542_mbenable(base_io);
+
+	return 0;
+}
+
+#ifndef MODULE
+static char *setup_str[MAXBOARDS] __initdata;
+static int setup_idx = 0;
+
+static void __init aha1542_setup(char *str, int *ints)
+{
+	const char *ahausage = "aha1542: usage: aha1542=<PORTBASE>[,<BUSON>,<BUSOFF>[,<DMASPEED>]]\n";
+	int setup_portbase;
+
+	if (setup_idx >= MAXBOARDS) {
+		printk(KERN_ERR "aha1542: aha1542_setup called too many times! Bad LILO params ?\n");
+		printk(KERN_ERR "   Entryline 1: %s\n", setup_str[0]);
+		printk(KERN_ERR "   Entryline 2: %s\n", setup_str[1]);
+		printk(KERN_ERR "   This line:   %s\n", str);
+		return;
+	}
+	if (ints[0] < 1 || ints[0] > 4) {
+		printk(KERN_ERR "aha1542: %s\n", str);
+		printk(ahausage);
+		printk(KERN_ERR "aha1542: Wrong parameters may cause system malfunction.. We try anyway..\n");
+	}
+	setup_called[setup_idx] = ints[0];
+	setup_str[setup_idx] = str;
+
+	setup_portbase = ints[0] >= 1 ? ints[1] : 0;	/* Preserve the default value.. */
+	setup_buson[setup_idx] = ints[0] >= 2 ? ints[2] : 7;
+	setup_busoff[setup_idx] = ints[0] >= 3 ? ints[3] : 5;
+	if (ints[0] >= 4) 
+	{
+		int atbt = -1;
+		switch (ints[4]) {
+		case 5:
+			atbt = 0x00;
+			break;
+		case 6:
+			atbt = 0x04;
+			break;
+		case 7:
+			atbt = 0x01;
+			break;
+		case 8:
+			atbt = 0x02;
+			break;
+		case 10:
+			atbt = 0x03;
+			break;
+		default:
+			printk(KERN_ERR "aha1542: %s\n", str);
+			printk(ahausage);
+			printk(KERN_ERR "aha1542: Valid values for DMASPEED are 5-8, 10 MB/s.  Using jumper defaults.\n");
+			break;
+		}
+		setup_dmaspeed[setup_idx] = atbt;
+	}
+	if (setup_portbase != 0)
+		bases[setup_idx] = setup_portbase;
+
+	++setup_idx;
+}
+
+static int __init do_setup(char *str)
+{
+	int ints[5];
+
+	int count=setup_idx;
+
+	get_options(str, sizeof(ints)/sizeof(int), ints);
+	aha1542_setup(str,ints);
+
+	return count<setup_idx;
+}
+
+__setup("aha1542=",do_setup);
+#endif
+
+/* return non-zero on detection */
+static int __init aha1542_detect(Scsi_Host_Template * tpnt)
+{
+	unsigned char dma_chan;
+	unsigned char irq_level;
+	unsigned char scsi_id;
+	unsigned long flags;
+	unsigned int base_io;
+	int trans;
+	struct Scsi_Host *shpnt = NULL;
+	int count = 0;
+	int indx;
+
+	DEB(printk("aha1542_detect: \n"));
+
+	tpnt->proc_name = "aha1542";
+
+#ifdef MODULE
+	bases[0] = aha1542[0];
+	setup_buson[0] = aha1542[1];
+	setup_busoff[0] = aha1542[2];
+	{
+		int atbt = -1;
+		switch (aha1542[3]) {
+		case 5:
+			atbt = 0x00;
+			break;
+		case 6:
+			atbt = 0x04;
+			break;
+		case 7:
+			atbt = 0x01;
+			break;
+		case 8:
+			atbt = 0x02;
+			break;
+		case 10:
+			atbt = 0x03;
+			break;
+		};
+		setup_dmaspeed[0] = atbt;
+	}
+#endif
+
+	/*
+	 *	Find MicroChannel cards (AHA1640)
+	 */
+#ifdef CONFIG_MCA_LEGACY
+	if(MCA_bus) {
+		int slot = 0;
+		int pos = 0;
+
+		for (indx = 0; (slot !=  MCA_NOTFOUND) && 
+			     (indx < sizeof(bases)/sizeof(bases[0])); indx++) {
+
+			if (bases[indx])
+				continue;
+
+			/* Detect only AHA-1640 cards -- MCA ID 0F1F */
+			slot = mca_find_unused_adapter(0x0f1f, slot);
+			if (slot == MCA_NOTFOUND)
+				break;
+
+			
+			/* Found one */
+			pos = mca_read_stored_pos(slot, 3);
+			
+			/* Decode address */
+			if (pos & 0x80) {
+				if (pos & 0x02) {
+					if (pos & 0x01)
+						bases[indx] = 0x334;
+					else
+						bases[indx] = 0x234;
+				} else {
+					if (pos & 0x01)
+						bases[indx] = 0x134;
+				}
+			} else {
+				if (pos & 0x02) {
+					if (pos & 0x01)
+						bases[indx] = 0x330;
+					else
+						bases[indx] = 0x230;
+				} else {
+					if (pos & 0x01)
+						bases[indx] = 0x130;
+				}
+			}
+
+			/* No need to decode IRQ and Arb level -- those are
+			 * read off the card later.
+			 */
+			printk(KERN_INFO "Found an AHA-1640 in MCA slot %d, I/O 0x%04x\n", slot, bases[indx]);
+
+			mca_set_adapter_name(slot, "Adapter AHA-1640");
+			mca_set_adapter_procfn(slot, NULL, NULL);
+			mca_mark_as_used(slot);
+			
+			/* Go on */
+			slot++;
+		}
+		
+	}
+#endif
+
+	/*
+	 *	Hunt for ISA Plug'n'Pray Adaptecs (AHA1535)
+	 */
+	 
+	if(isapnp)
+	{
+		struct pnp_dev *pdev = NULL;
+		for(indx = 0; indx <sizeof(bases)/sizeof(bases[0]);indx++)
+		{
+			if(bases[indx])
+				continue;
+			pdev = pnp_find_dev(NULL, ISAPNP_VENDOR('A', 'D', 'P'), 
+				ISAPNP_FUNCTION(0x1542), pdev);
+			if(pdev==NULL)
+				break;
+			/*
+			 *	Activate the PnP card
+			 */
+			 
+			if(pnp_device_attach(pdev)<0)
+				continue;
+			
+			if(pnp_activate_dev(pdev)<0) {
+				pnp_device_detach(pdev);
+				continue;
+			}
+			
+			if(!pnp_port_valid(pdev, 0)) {
+				pnp_device_detach(pdev);
+				continue;
+			}
+				
+			bases[indx] = pnp_port_start(pdev, 0);
+			
+			/* The card can be queried for its DMA, we have 
+			   the DMA set up that is enough */
+			   
+			printk(KERN_INFO "ISAPnP found an AHA1535 at I/O 0x%03X\n", bases[indx]);
+		}
+	}
+	for (indx = 0; indx < sizeof(bases) / sizeof(bases[0]); indx++)
+		if (bases[indx] != 0 && request_region(bases[indx], 4, "aha1542")) {
+			shpnt = scsi_register(tpnt,
+					sizeof(struct aha1542_hostdata));
+
+			if(shpnt==NULL) {
+				release_region(bases[indx], 4);
+				continue;
+			}
+			/* For now we do this - until kmalloc is more intelligent
+			   we are resigned to stupid hacks like this */
+			if (SCSI_BUF_PA(shpnt) >= ISA_DMA_THRESHOLD) {
+				printk(KERN_ERR "Invalid address for shpnt with 1542.\n");
+				goto unregister;
+			}
+			if (!aha1542_test_port(bases[indx], shpnt))
+				goto unregister;
+
+
+			base_io = bases[indx];
+
+			/* Set the Bus on/off-times as not to ruin floppy performance */
+			{
+				unchar oncmd[] = {CMD_BUSON_TIME, 7};
+				unchar offcmd[] = {CMD_BUSOFF_TIME, 5};
+
+				if (setup_called[indx]) {
+					oncmd[1] = setup_buson[indx];
+					offcmd[1] = setup_busoff[indx];
+				}
+				aha1542_intr_reset(base_io);
+				aha1542_out(base_io, oncmd, 2);
+				WAIT(INTRFLAGS(base_io), INTRMASK, HACC, 0);
+				aha1542_intr_reset(base_io);
+				aha1542_out(base_io, offcmd, 2);
+				WAIT(INTRFLAGS(base_io), INTRMASK, HACC, 0);
+				if (setup_dmaspeed[indx] >= 0) {
+					unchar dmacmd[] = {CMD_DMASPEED, 0};
+					dmacmd[1] = setup_dmaspeed[indx];
+					aha1542_intr_reset(base_io);
+					aha1542_out(base_io, dmacmd, 2);
+					WAIT(INTRFLAGS(base_io), INTRMASK, HACC, 0);
+				}
+				while (0) {
+fail:
+					printk(KERN_ERR "aha1542_detect: setting bus on/off-time failed\n");
+				}
+				aha1542_intr_reset(base_io);
+			}
+			if (aha1542_query(base_io, &trans))
+				goto unregister;
+
+			if (aha1542_getconfig(base_io, &irq_level, &dma_chan, &scsi_id) == -1)
+				goto unregister;
+
+			printk(KERN_INFO "Configuring Adaptec (SCSI-ID %d) at IO:%x, IRQ %d", scsi_id, base_io, irq_level);
+			if (dma_chan != 0xFF)
+				printk(", DMA priority %d", dma_chan);
+			printk("\n");
+
+			DEB(aha1542_stat());
+			setup_mailboxes(base_io, shpnt);
+
+			DEB(aha1542_stat());
+
+			DEB(printk("aha1542_detect: enable interrupt channel %d\n", irq_level));
+			spin_lock_irqsave(&aha1542_lock, flags);
+			if (request_irq(irq_level, do_aha1542_intr_handle, 0, "aha1542", NULL)) {
+				printk(KERN_ERR "Unable to allocate IRQ for adaptec controller.\n");
+				spin_unlock_irqrestore(&aha1542_lock, flags);
+				goto unregister;
+			}
+			if (dma_chan != 0xFF) {
+				if (request_dma(dma_chan, "aha1542")) {
+					printk(KERN_ERR "Unable to allocate DMA channel for Adaptec.\n");
+					free_irq(irq_level, NULL);
+					spin_unlock_irqrestore(&aha1542_lock, flags);
+					goto unregister;
+				}
+				if (dma_chan == 0 || dma_chan >= 5) {
+					set_dma_mode(dma_chan, DMA_MODE_CASCADE);
+					enable_dma(dma_chan);
+				}
+			}
+			aha_host[irq_level - 9] = shpnt;
+			shpnt->this_id = scsi_id;
+			shpnt->unique_id = base_io;
+			shpnt->io_port = base_io;
+			shpnt->n_io_port = 4;	/* Number of bytes of I/O space used */
+			shpnt->dma_channel = dma_chan;
+			shpnt->irq = irq_level;
+			HOSTDATA(shpnt)->bios_translation = trans;
+			if (trans == BIOS_TRANSLATION_25563)
+				printk(KERN_INFO "aha1542.c: Using extended bios translation\n");
+			HOSTDATA(shpnt)->aha1542_last_mbi_used = (2 * AHA1542_MAILBOXES - 1);
+			HOSTDATA(shpnt)->aha1542_last_mbo_used = (AHA1542_MAILBOXES - 1);
+			memset(HOSTDATA(shpnt)->SCint, 0, sizeof(HOSTDATA(shpnt)->SCint));
+			spin_unlock_irqrestore(&aha1542_lock, flags);
+#if 0
+			DEB(printk(" *** READ CAPACITY ***\n"));
+
+			{
+				unchar buf[8];
+				static unchar cmd[] = { READ_CAPACITY, 0, 0, 0, 0, 0, 0, 0, 0, 0 };
+				int i;
+
+				for (i = 0; i < sizeof(buf); ++i)
+					buf[i] = 0x87;
+				for (i = 0; i < 2; ++i)
+					if (!aha1542_command(i, cmd, buf, sizeof(buf))) {
+						printk(KERN_DEBUG "aha_detect: LU %d sector_size %d device_size %d\n",
+						       i, xscsi2int(buf + 4), xscsi2int(buf));
+					}
+			}
+
+			DEB(printk(" *** NOW RUNNING MY OWN TEST *** \n"));
+
+			for (i = 0; i < 4; ++i) {
+				unsigned char cmd[10];
+				static buffer[512];
+
+				cmd[0] = READ_10;
+				cmd[1] = 0;
+				xany2scsi(cmd + 2, i);
+				cmd[6] = 0;
+				cmd[7] = 0;
+				cmd[8] = 1;
+				cmd[9] = 0;
+				aha1542_command(0, cmd, buffer, 512);
+			}
+#endif
+			count++;
+			continue;
+unregister:
+			release_region(bases[indx], 4);
+			scsi_unregister(shpnt);
+			continue;
+
+		};
+
+	return count;
+}
+
+static int aha1542_release(struct Scsi_Host *shost)
+{
+	if (shost->irq)
+		free_irq(shost->irq, NULL);
+	if (shost->dma_channel != 0xff)
+		free_dma(shost->dma_channel);
+	if (shost->io_port && shost->n_io_port)
+		release_region(shost->io_port, shost->n_io_port);
+	scsi_unregister(shost);
+	return 0;
+}
+
+static int aha1542_restart(struct Scsi_Host *shost)
+{
+	int i;
+	int count = 0;
+#if 0
+	unchar ahacmd = CMD_START_SCSI;
+#endif
+
+	for (i = 0; i < AHA1542_MAILBOXES; i++)
+		if (HOSTDATA(shost)->SCint[i] &&
+		    !(HOSTDATA(shost)->SCint[i]->device->soft_reset)) {
+#if 0
+			HOSTDATA(shost)->mb[i].status = 1;	/* Indicate ready to restart... */
+#endif
+			count++;
+		}
+	printk(KERN_DEBUG "Potential to restart %d stalled commands...\n", count);
+#if 0
+	/* start scsi command */
+	if (count)
+		aha1542_out(shost->io_port, &ahacmd, 1);
+#endif
+	return 0;
+}
+
+static int aha1542_abort(Scsi_Cmnd * SCpnt)
+{
+
+	/*
+	 * The abort command does not leave the device in a clean state where
+	 *  it is available to be used again.  Until this gets worked out, we
+	 * will leave it commented out.  
+	 */
+
+	printk(KERN_ERR "aha1542.c: Unable to abort command for target %d\n",
+	       SCpnt->device->id);
+	return FAILED;
+}
+
+/*
+ * This is a device reset.  This is handled by sending a special command
+ * to the device.
+ */
+static int aha1542_dev_reset(Scsi_Cmnd * SCpnt)
+{
+	unsigned long flags;
+	struct mailbox *mb;
+	unchar target = SCpnt->device->id;
+	unchar lun = SCpnt->device->lun;
+	int mbo;
+	struct ccb *ccb;
+	unchar ahacmd = CMD_START_SCSI;
+
+	ccb = HOSTDATA(SCpnt->device->host)->ccb;
+	mb = HOSTDATA(SCpnt->device->host)->mb;
+
+	spin_lock_irqsave(&aha1542_lock, flags);
+	mbo = HOSTDATA(SCpnt->device->host)->aha1542_last_mbo_used + 1;
+	if (mbo >= AHA1542_MAILBOXES)
+		mbo = 0;
+
+	do {
+		if (mb[mbo].status == 0 && HOSTDATA(SCpnt->device->host)->SCint[mbo] == NULL)
+			break;
+		mbo++;
+		if (mbo >= AHA1542_MAILBOXES)
+			mbo = 0;
+	} while (mbo != HOSTDATA(SCpnt->device->host)->aha1542_last_mbo_used);
+
+	if (mb[mbo].status || HOSTDATA(SCpnt->device->host)->SCint[mbo])
+		panic("Unable to find empty mailbox for aha1542.\n");
+
+	HOSTDATA(SCpnt->device->host)->SCint[mbo] = SCpnt;	/* This will effectively
+							   prevent someone else from
+							   screwing with this cdb. */
+
+	HOSTDATA(SCpnt->device->host)->aha1542_last_mbo_used = mbo;
+	spin_unlock_irqrestore(&aha1542_lock, flags);
+
+	any2scsi(mb[mbo].ccbptr, SCSI_BUF_PA(&ccb[mbo]));	/* This gets trashed for some reason */
+
+	memset(&ccb[mbo], 0, sizeof(struct ccb));
+
+	ccb[mbo].op = 0x81;	/* BUS DEVICE RESET */
+
+	ccb[mbo].idlun = (target & 7) << 5 | (lun & 7);		/*SCSI Target Id */
+
+	ccb[mbo].linkptr[0] = ccb[mbo].linkptr[1] = ccb[mbo].linkptr[2] = 0;
+	ccb[mbo].commlinkid = 0;
+
+	/* 
+	 * Now tell the 1542 to flush all pending commands for this 
+	 * target 
+	 */
+	aha1542_out(SCpnt->device->host->io_port, &ahacmd, 1);
+
+	printk(KERN_WARNING "aha1542.c: Trying device reset for target %d\n", SCpnt->device->id);
+
+	return SUCCESS;
+
+
+#ifdef ERIC_neverdef
+	/* 
+	 * With the 1542 we apparently never get an interrupt to
+	 * acknowledge a device reset being sent.  Then again, Leonard
+	 * says we are doing this wrong in the first place...
+	 *
+	 * Take a wait and see attitude.  If we get spurious interrupts,
+	 * then the device reset is doing something sane and useful, and
+	 * we will wait for the interrupt to post completion.
+	 */
+	printk(KERN_WARNING "Sent BUS DEVICE RESET to target %d\n", SCpnt->target);
+
+	/*
+	 * Free the command block for all commands running on this 
+	 * target... 
+	 */
+	for (i = 0; i < AHA1542_MAILBOXES; i++) {
+		if (HOSTDATA(SCpnt->host)->SCint[i] &&
+		    HOSTDATA(SCpnt->host)->SCint[i]->target == SCpnt->target) {
+			Scsi_Cmnd *SCtmp;
+			SCtmp = HOSTDATA(SCpnt->host)->SCint[i];
+			if (SCtmp->host_scribble) {
+				kfree(SCtmp->host_scribble);
+				SCtmp->host_scribble = NULL;
+			}
+			HOSTDATA(SCpnt->host)->SCint[i] = NULL;
+			HOSTDATA(SCpnt->host)->mb[i].status = 0;
+		}
+	}
+	return SUCCESS;
+
+	return FAILED;
+#endif				/* ERIC_neverdef */
+}
+
+static int aha1542_bus_reset(Scsi_Cmnd * SCpnt)
+{
+	int i;
+
+	/* 
+	 * This does a scsi reset for all devices on the bus.
+	 * In principle, we could also reset the 1542 - should
+	 * we do this?  Try this first, and we can add that later
+	 * if it turns out to be useful.
+	 */
+	outb(SCRST, CONTROL(SCpnt->device->host->io_port));
+
+	/*
+	 * Wait for the thing to settle down a bit.  Unfortunately
+	 * this is going to basically lock up the machine while we
+	 * wait for this to complete.  To be 100% correct, we need to
+	 * check for timeout, and if we are doing something like this
+	 * we are pretty desperate anyways.
+	 */
+	spin_unlock_irq(SCpnt->device->host->host_lock);
+	ssleep(4);
+	spin_lock_irq(SCpnt->device->host->host_lock);
+
+	WAIT(STATUS(SCpnt->device->host->io_port),
+	     STATMASK, INIT | IDLE, STST | DIAGF | INVDCMD | DF | CDF);
+
+	/*
+	 * Now try to pick up the pieces.  For all pending commands,
+	 * free any internal data structures, and basically clear things
+	 * out.  We do not try and restart any commands or anything - 
+	 * the strategy handler takes care of that crap.
+	 */
+	printk(KERN_WARNING "Sent BUS RESET to scsi host %d\n", SCpnt->device->host->host_no);
+
+	for (i = 0; i < AHA1542_MAILBOXES; i++) {
+		if (HOSTDATA(SCpnt->device->host)->SCint[i] != NULL) {
+			Scsi_Cmnd *SCtmp;
+			SCtmp = HOSTDATA(SCpnt->device->host)->SCint[i];
+
+
+			if (SCtmp->device->soft_reset) {
+				/*
+				 * If this device implements the soft reset option,
+				 * then it is still holding onto the command, and
+				 * may yet complete it.  In this case, we don't
+				 * flush the data.
+				 */
+				continue;
+			}
+			if (SCtmp->host_scribble) {
+				kfree(SCtmp->host_scribble);
+				SCtmp->host_scribble = NULL;
+			}
+			HOSTDATA(SCpnt->device->host)->SCint[i] = NULL;
+			HOSTDATA(SCpnt->device->host)->mb[i].status = 0;
+		}
+	}
+
+	return SUCCESS;
+
+fail:
+	return FAILED;
+}
+
+static int aha1542_host_reset(Scsi_Cmnd * SCpnt)
+{
+	int i;
+
+	/* 
+	 * This does a scsi reset for all devices on the bus.
+	 * In principle, we could also reset the 1542 - should
+	 * we do this?  Try this first, and we can add that later
+	 * if it turns out to be useful.
+	 */
+	outb(HRST | SCRST, CONTROL(SCpnt->device->host->io_port));
+
+	/*
+	 * Wait for the thing to settle down a bit.  Unfortunately
+	 * this is going to basically lock up the machine while we
+	 * wait for this to complete.  To be 100% correct, we need to
+	 * check for timeout, and if we are doing something like this
+	 * we are pretty desperate anyways.
+	 */
+	spin_unlock_irq(SCpnt->device->host->host_lock);
+	ssleep(4);
+	spin_lock_irq(SCpnt->device->host->host_lock);
+
+	WAIT(STATUS(SCpnt->device->host->io_port),
+	     STATMASK, INIT | IDLE, STST | DIAGF | INVDCMD | DF | CDF);
+
+	/*
+	 * We need to do this too before the 1542 can interact with
+	 * us again.
+	 */
+	setup_mailboxes(SCpnt->device->host->io_port, SCpnt->device->host);
+
+	/*
+	 * Now try to pick up the pieces.  For all pending commands,
+	 * free any internal data structures, and basically clear things
+	 * out.  We do not try and restart any commands or anything - 
+	 * the strategy handler takes care of that crap.
+	 */
+	printk(KERN_WARNING "Sent BUS RESET to scsi host %d\n", SCpnt->device->host->host_no);
+
+	for (i = 0; i < AHA1542_MAILBOXES; i++) {
+		if (HOSTDATA(SCpnt->device->host)->SCint[i] != NULL) {
+			Scsi_Cmnd *SCtmp;
+			SCtmp = HOSTDATA(SCpnt->device->host)->SCint[i];
+
+			if (SCtmp->device->soft_reset) {
+				/*
+				 * If this device implements the soft reset option,
+				 * then it is still holding onto the command, and
+				 * may yet complete it.  In this case, we don't
+				 * flush the data.
+				 */
+				continue;
+			}
+			if (SCtmp->host_scribble) {
+				kfree(SCtmp->host_scribble);
+				SCtmp->host_scribble = NULL;
+			}
+			HOSTDATA(SCpnt->device->host)->SCint[i] = NULL;
+			HOSTDATA(SCpnt->device->host)->mb[i].status = 0;
+		}
+	}
+
+	return SUCCESS;
+
+fail:
+	return FAILED;
+}
+
+#if 0
+/*
+ * These are the old error handling routines.  They are only temporarily
+ * here while we play with the new error handling code.
+ */
+static int aha1542_old_abort(Scsi_Cmnd * SCpnt)
+{
+#if 0
+	unchar ahacmd = CMD_START_SCSI;
+	unsigned long flags;
+	struct mailbox *mb;
+	int mbi, mbo, i;
+
+	printk(KERN_DEBUG "In aha1542_abort: %x %x\n",
+	       inb(STATUS(SCpnt->host->io_port)),
+	       inb(INTRFLAGS(SCpnt->host->io_port)));
+
+	spin_lock_irqsave(&aha1542_lock, flags);
+	mb = HOSTDATA(SCpnt->host)->mb;
+	mbi = HOSTDATA(SCpnt->host)->aha1542_last_mbi_used + 1;
+	if (mbi >= 2 * AHA1542_MAILBOXES)
+		mbi = AHA1542_MAILBOXES;
+
+	do {
+		if (mb[mbi].status != 0)
+			break;
+		mbi++;
+		if (mbi >= 2 * AHA1542_MAILBOXES)
+			mbi = AHA1542_MAILBOXES;
+	} while (mbi != HOSTDATA(SCpnt->host)->aha1542_last_mbi_used);
+	spin_unlock_irqrestore(&aha1542_lock, flags);
+
+	if (mb[mbi].status) {
+		printk(KERN_ERR "Lost interrupt discovered on irq %d - attempting to recover\n",
+		       SCpnt->host->irq);
+		aha1542_intr_handle(SCpnt->host, NULL);
+		return 0;
+	}
+	/* OK, no lost interrupt.  Try looking to see how many pending commands
+	   we think we have. */
+
+	for (i = 0; i < AHA1542_MAILBOXES; i++)
+		if (HOSTDATA(SCpnt->host)->SCint[i]) {
+			if (HOSTDATA(SCpnt->host)->SCint[i] == SCpnt) {
+				printk(KERN_ERR "Timed out command pending for %s\n",
+				       SCpnt->request->rq_disk ?
+				       SCpnt->request->rq_disk->disk_name : "?"
+				       );
+				if (HOSTDATA(SCpnt->host)->mb[i].status) {
+					printk(KERN_ERR "OGMB still full - restarting\n");
+					aha1542_out(SCpnt->host->io_port, &ahacmd, 1);
+				};
+			} else
+				printk(KERN_ERR "Other pending command %s\n",
+				       SCpnt->request->rq_disk ?
+				       SCpnt->request->rq_disk->disk_name : "?"
+				       );
+		}
+#endif
+
+	DEB(printk("aha1542_abort\n"));
+#if 0
+	spin_lock_irqsave(&aha1542_lock, flags);
+	for (mbo = 0; mbo < AHA1542_MAILBOXES; mbo++) {
+		if (SCpnt == HOSTDATA(SCpnt->host)->SCint[mbo]) {
+			mb[mbo].status = 2;	/* Abort command */
+			aha1542_out(SCpnt->host->io_port, &ahacmd, 1);	/* start scsi command */
+			spin_unlock_irqrestore(&aha1542_lock, flags);
+			break;
+		}
+	}
+	if (AHA1542_MAILBOXES == mbo)
+		spin_unlock_irqrestore(&aha1542_lock, flags);
+#endif
+	return SCSI_ABORT_SNOOZE;
+}
+
+/* We do not implement a reset function here, but the upper level code
+   assumes that it will get some kind of response for the command in
+   SCpnt.  We must oblige, or the command will hang the scsi system.
+   For a first go, we assume that the 1542 notifies us with all of the
+   pending commands (it does implement soft reset, after all). */
+
+static int aha1542_old_reset(Scsi_Cmnd * SCpnt, unsigned int reset_flags)
+{
+	unchar ahacmd = CMD_START_SCSI;
+	int i;
+
+	/*
+	 * See if a bus reset was suggested.
+	 */
+	if (reset_flags & SCSI_RESET_SUGGEST_BUS_RESET) {
+		/* 
+		 * This does a scsi reset for all devices on the bus.
+		 * In principle, we could also reset the 1542 - should
+		 * we do this?  Try this first, and we can add that later
+		 * if it turns out to be useful.
+		 */
+		outb(HRST | SCRST, CONTROL(SCpnt->host->io_port));
+
+		/*
+		 * Wait for the thing to settle down a bit.  Unfortunately
+		 * this is going to basically lock up the machine while we
+		 * wait for this to complete.  To be 100% correct, we need to
+		 * check for timeout, and if we are doing something like this
+		 * we are pretty desperate anyways.
+		 */
+		WAIT(STATUS(SCpnt->host->io_port),
+		STATMASK, INIT | IDLE, STST | DIAGF | INVDCMD | DF | CDF);
+
+		/*
+		 * We need to do this too before the 1542 can interact with
+		 * us again.
+		 */
+		setup_mailboxes(SCpnt->host->io_port, SCpnt->host);
+
+		/*
+		 * Now try to pick up the pieces.  Restart all commands
+		 * that are currently active on the bus, and reset all of
+		 * the datastructures.  We have some time to kill while
+		 * things settle down, so print a nice message.
+		 */
+		printk(KERN_WARNING "Sent BUS RESET to scsi host %d\n", SCpnt->host->host_no);
+
+		for (i = 0; i < AHA1542_MAILBOXES; i++)
+			if (HOSTDATA(SCpnt->host)->SCint[i] != NULL) {
+				Scsi_Cmnd *SCtmp;
+				SCtmp = HOSTDATA(SCpnt->host)->SCint[i];
+				SCtmp->result = DID_RESET << 16;
+				if (SCtmp->host_scribble) {
+					kfree(SCtmp->host_scribble);
+					SCtmp->host_scribble = NULL;
+				}
+				printk(KERN_WARNING "Sending DID_RESET for target %d\n", SCpnt->target);
+				SCtmp->scsi_done(SCpnt);
+
+				HOSTDATA(SCpnt->host)->SCint[i] = NULL;
+				HOSTDATA(SCpnt->host)->mb[i].status = 0;
+			}
+		/*
+		 * Now tell the mid-level code what we did here.  Since
+		 * we have restarted all of the outstanding commands,
+		 * then report SUCCESS.
+		 */
+		return (SCSI_RESET_SUCCESS | SCSI_RESET_BUS_RESET);
+fail:
+		printk(KERN_CRIT "aha1542.c: Unable to perform hard reset.\n");
+		printk(KERN_CRIT "Power cycle machine to reset\n");
+		return (SCSI_RESET_ERROR | SCSI_RESET_BUS_RESET);
+
+
+	} else {
+		/* This does a selective reset of just the one device */
+		/* First locate the ccb for this command */
+		for (i = 0; i < AHA1542_MAILBOXES; i++)
+			if (HOSTDATA(SCpnt->host)->SCint[i] == SCpnt) {
+				HOSTDATA(SCpnt->host)->ccb[i].op = 0x81;	/* BUS DEVICE RESET */
+				/* Now tell the 1542 to flush all pending commands for this target */
+				aha1542_out(SCpnt->host->io_port, &ahacmd, 1);
+
+				/* Here is the tricky part.  What to do next.  Do we get an interrupt
+				   for the commands that we aborted with the specified target, or
+				   do we generate this on our own?  Try it without first and see
+				   what happens */
+				printk(KERN_WARNING "Sent BUS DEVICE RESET to target %d\n", SCpnt->target);
+
+				/* If the first does not work, then try the second.  I think the
+				   first option is more likely to be correct. Free the command
+				   block for all commands running on this target... */
+				for (i = 0; i < AHA1542_MAILBOXES; i++)
+					if (HOSTDATA(SCpnt->host)->SCint[i] &&
+					    HOSTDATA(SCpnt->host)->SCint[i]->target == SCpnt->target) {
+						Scsi_Cmnd *SCtmp;
+						SCtmp = HOSTDATA(SCpnt->host)->SCint[i];
+						SCtmp->result = DID_RESET << 16;
+						if (SCtmp->host_scribble) {
+							kfree(SCtmp->host_scribble);
+							SCtmp->host_scribble = NULL;
+						}
+						printk(KERN_WARNING "Sending DID_RESET for target %d\n", SCpnt->target);
+						SCtmp->scsi_done(SCpnt);
+
+						HOSTDATA(SCpnt->host)->SCint[i] = NULL;
+						HOSTDATA(SCpnt->host)->mb[i].status = 0;
+					}
+				return SCSI_RESET_SUCCESS;
+			}
+	}
+	/* No active command at this time, so this means that each time we got
+	   some kind of response the last time through.  Tell the mid-level code
+	   to request sense information in order to decide what to do next. */
+	return SCSI_RESET_PUNT;
+}
+#endif    /* end of big comment block around old_abort + old_reset */
+
+static int aha1542_biosparam(struct scsi_device *sdev,
+		struct block_device *bdev, sector_t capacity, int *ip)
+{
+	int translation_algorithm;
+	int size = capacity;
+
+	translation_algorithm = HOSTDATA(sdev->host)->bios_translation;
+
+	if ((size >> 11) > 1024 && translation_algorithm == BIOS_TRANSLATION_25563) {
+		/* Please verify that this is the same as what DOS returns */
+		ip[0] = 255;
+		ip[1] = 63;
+		ip[2] = size / 255 / 63;
+	} else {
+		ip[0] = 64;
+		ip[1] = 32;
+		ip[2] = size >> 11;
+	}
+
+	return 0;
+}
+MODULE_LICENSE("GPL");
+
+
+static Scsi_Host_Template driver_template = {
+	.proc_name		= "aha1542",
+	.name			= "Adaptec 1542",
+	.detect			= aha1542_detect,
+	.release		= aha1542_release,
+	.queuecommand		= aha1542_queuecommand,
+	.eh_abort_handler	= aha1542_abort,
+	.eh_device_reset_handler= aha1542_dev_reset,
+	.eh_bus_reset_handler	= aha1542_bus_reset,
+	.eh_host_reset_handler	= aha1542_host_reset,
+	.bios_param		= aha1542_biosparam,
+	.can_queue		= AHA1542_MAILBOXES, 
+	.this_id		= 7,
+	.sg_tablesize		= AHA1542_SCATTER,
+	.cmd_per_lun		= AHA1542_CMDLUN,
+	.unchecked_isa_dma	= 1, 
+	.use_clustering		= ENABLE_CLUSTERING,
+};
+#include "scsi_module.c"
