commit 82ea3e0e129e2ab913dd6684bab7a6e5e9896dee
Author: John Garry <john.garry@huawei.com>
Date:   Wed Nov 20 17:39:15 2019 +0800

    scsi: scsi_transport_sas: Fix memory leak when removing devices
    
    Removing a non-host rphy causes a memory leak:
    
    root@(none)$ echo 0 > /sys/devices/platform/HISI0162:01/host0/port-0:0/expander-0:0/port-0:0:10/phy-0:0:10/sas_phy/phy-0:0:10/enable
    [   79.857888] hisi_sas_v2_hw HISI0162:01: dev[7:1] is gone
    root@(none)$ echo scan > /sys/kernel/debug/kmemleak
    [  131.656603] kmemleak: 3 new suspected memory leaks (see /sys/kernel/debug/kmemleak)
    root@(none)$ more /sys/kernel/debug/kmemleak
    unreferenced object 0xffff041da5c66000 (size 256):
      comm "kworker/u128:1", pid 549, jiffies 4294898543 (age 113.728s)
      hex dump (first 32 bytes):
        00 5e c6 a5 1d 04 ff ff 01 00 00 00 00 00 00 00  .^..............
        00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................
      backtrace:
        [<(____ptrval____)>] kmem_cache_alloc+0x188/0x260
        [<(____ptrval____)>] bsg_setup_queue+0x48/0x1a8
        [<(____ptrval____)>] sas_rphy_add+0x108/0x2d0
        [<(____ptrval____)>] sas_probe_devices+0x168/0x208
        [<(____ptrval____)>] sas_discover_domain+0x660/0x9c8
        [<(____ptrval____)>] process_one_work+0x3f8/0x690
        [<(____ptrval____)>] worker_thread+0x70/0x6a0
        [<(____ptrval____)>] kthread+0x1b8/0x1c0
        [<(____ptrval____)>] ret_from_fork+0x10/0x18
    unreferenced object 0xffff041d8c075400 (size 128):
      comm "kworker/u128:1", pid 549, jiffies 4294898543 (age 113.728s)
      hex dump (first 32 bytes):
        00 40 25 97 1d 00 ff ff 00 00 00 00 00 00 00 00  .@%.............
        00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................
      backtrace:
        [<(____ptrval____)>] __kmalloc_node+0x1a8/0x2c8
        [<(____ptrval____)>] blk_mq_realloc_tag_set_tags.part.70+0x48/0xd8
        [<(____ptrval____)>] blk_mq_alloc_tag_set+0x1dc/0x530
        [<(____ptrval____)>] bsg_setup_queue+0xe8/0x1a8
        [<(____ptrval____)>] sas_rphy_add+0x108/0x2d0
        [<(____ptrval____)>] sas_probe_devices+0x168/0x208
        [<(____ptrval____)>] sas_discover_domain+0x660/0x9c8
        [<(____ptrval____)>] process_one_work+0x3f8/0x690
        [<(____ptrval____)>] worker_thread+0x70/0x6a0
        [<(____ptrval____)>] kthread+0x1b8/0x1c0
        [<(____ptrval____)>] ret_from_fork+0x10/0x18
    unreferenced object 0xffff041da5c65e00 (size 256):
      comm "kworker/u128:1", pid 549, jiffies 4294898543 (age 113.728s)
      hex dump (first 32 bytes):
        00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................
        00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................
      backtrace:
        [<(____ptrval____)>] __kmalloc_node+0x1a8/0x2c8
        [<(____ptrval____)>] blk_mq_alloc_tag_set+0x254/0x530
        [<(____ptrval____)>] bsg_setup_queue+0xe8/0x1a8
        [<(____ptrval____)>] sas_rphy_add+0x108/0x2d0
        [<(____ptrval____)>] sas_probe_devices+0x168/0x208
        [<(____ptrval____)>] sas_discover_domain+0x660/0x9c8
        [<(____ptrval____)>] process_one_work+0x3f8/0x690
        [<(____ptrval____)>] worker_thread+0x70/0x6a0
        [<(____ptrval____)>] kthread+0x1b8/0x1c0
        [<(____ptrval____)>] ret_from_fork+0x10/0x18
    root@(none)$
    
    It turns out that we don't clean up the request queue fully for bsg
    devices, as the blk mq tags for the request queue are not freed.
    
    Fix by doing the queue removal in one place - in sas_rphy_remove() -
    instead of unregistering the queue in sas_rphy_remove() and finally
    cleaning up the queue in calling blk_cleanup_queue() from
    sas_end_device_release() or sas_expander_release().
    
    Function bsg_remove_queue() can handle a NULL pointer q, so remove the
    precheck in sas_rphy_remove().
    
    Fixes: 651a013649943 ("scsi: scsi_transport_sas: switch to bsg-lib for SMP passthrough")
    Link: https://lore.kernel.org/r/1574242755-94156-1-git-send-email-john.garry@huawei.com
    Signed-off-by: John Garry <john.garry@huawei.com>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/scsi_transport_sas.c b/drivers/scsi/scsi_transport_sas.c
index ef138c57e2a6..182fd25c7c43 100644
--- a/drivers/scsi/scsi_transport_sas.c
+++ b/drivers/scsi/scsi_transport_sas.c
@@ -1391,9 +1391,6 @@ static void sas_expander_release(struct device *dev)
 	struct sas_rphy *rphy = dev_to_rphy(dev);
 	struct sas_expander_device *edev = rphy_to_expander_device(rphy);
 
-	if (rphy->q)
-		blk_cleanup_queue(rphy->q);
-
 	put_device(dev->parent);
 	kfree(edev);
 }
@@ -1403,9 +1400,6 @@ static void sas_end_device_release(struct device *dev)
 	struct sas_rphy *rphy = dev_to_rphy(dev);
 	struct sas_end_device *edev = rphy_to_end_device(rphy);
 
-	if (rphy->q)
-		blk_cleanup_queue(rphy->q);
-
 	put_device(dev->parent);
 	kfree(edev);
 }
@@ -1634,8 +1628,7 @@ sas_rphy_remove(struct sas_rphy *rphy)
 	}
 
 	sas_rphy_unlink(rphy);
-	if (rphy->q)
-		bsg_unregister_queue(rphy->q);
+	bsg_remove_queue(rphy->q);
 	transport_remove_device(dev);
 	device_del(dev);
 }

commit 59bd9ded4d7803d9f1f4d947064693513d18e724
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Tue May 28 10:10:12 2019 -0700

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 209
    
    Based on 1 normalized pattern(s):
    
      released under gpl v2
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-only
    
    has been chosen to replace the boilerplate/reference in 15 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Steve Winslow <swinslow@gmail.com>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Reviewed-by: Alexios Zavras <alexios.zavras@intel.com>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190528171438.895196075@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/scsi/scsi_transport_sas.c b/drivers/scsi/scsi_transport_sas.c
index 60f1a81d2034..ef138c57e2a6 100644
--- a/drivers/scsi/scsi_transport_sas.c
+++ b/drivers/scsi/scsi_transport_sas.c
@@ -1,6 +1,6 @@
+// SPDX-License-Identifier: GPL-2.0-only
 /*
  * Copyright (C) 2005-2006 Dell Inc.
- *	Released under GPL v2.
  *
  * Serial Attached SCSI (SAS) transport class.
  *

commit 972248e9111ee6fe9fb56c24ecfd7434f3d713ac
Author: Christoph Hellwig <hch@lst.de>
Date:   Tue Jan 29 09:32:03 2019 +0100

    scsi: bsg-lib: handle bidi requests without block layer help
    
    We can just stash away the second request in struct bsg_job instead of
    using the block layer req->next_rq field, allowing for the eventual removal
    of the latter.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Acked-by: Jens Axboe <axboe@kernel.dk>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/scsi_transport_sas.c b/drivers/scsi/scsi_transport_sas.c
index 692b46937e52..60f1a81d2034 100644
--- a/drivers/scsi/scsi_transport_sas.c
+++ b/drivers/scsi/scsi_transport_sas.c
@@ -213,7 +213,6 @@ static int sas_bsg_initialize(struct Scsi_Host *shost, struct sas_rphy *rphy)
 		to_sas_host_attrs(shost)->q = q;
 	}
 
-	blk_queue_flag_set(QUEUE_FLAG_BIDI, q);
 	return 0;
 }
 

commit 5e28b8d8a1b03ce86f33d38a64a4983d2b5c7679
Author: Jens Axboe <axboe@kernel.dk>
Date:   Fri Oct 26 11:27:02 2018 -0600

    bsg: provide bsg_remove_queue() helper
    
    All drivers do unregister + cleanup, provide a helper for that.
    
    Cc: linux-scsi@vger.kernel.org
    Reviewed-by: Hannes Reinecke <hare@suse.com>
    Reviewed-by: Johannes Thumshirn <jthumshirn@suse.de>
    Reviewed-by: Christoph Hellwig <hch@lst.de>
    Tested-by: Benjamin Block <bblock@linux.vnet.ibm.com>
    Tested-by: Ming Lei <ming.lei@redhat.com>
    Reviewed-by: Omar Sandoval <osandov@fb.com>
    Signed-off-by: Jens Axboe <axboe@kernel.dk>

diff --git a/drivers/scsi/scsi_transport_sas.c b/drivers/scsi/scsi_transport_sas.c
index cf6d47891d77..692b46937e52 100644
--- a/drivers/scsi/scsi_transport_sas.c
+++ b/drivers/scsi/scsi_transport_sas.c
@@ -246,11 +246,7 @@ static int sas_host_remove(struct transport_container *tc, struct device *dev,
 	struct Scsi_Host *shost = dev_to_shost(dev);
 	struct request_queue *q = to_sas_host_attrs(shost)->q;
 
-	if (q) {
-		bsg_unregister_queue(q);
-		blk_cleanup_queue(q);
-	}
-
+	bsg_remove_queue(q);
 	return 0;
 }
 

commit aae3b069d5ce865ca5ef2902c2a22cef7ab4f3a2
Author: Jens Axboe <axboe@kernel.dk>
Date:   Fri Oct 26 11:26:25 2018 -0600

    bsg: pass in desired timeout handler
    
    This will ease in the conversion to blk-mq, where we can't set
    a timeout handler after queue init.
    
    Cc: Johannes Thumshirn <jthumshirn@suse.de>
    Cc: linux-scsi@vger.kernel.org
    Reviewed-by: Hannes Reinecke <hare@suse.com>
    Tested-by: Benjamin Block <bblock@linux.vnet.ibm.com>
    Tested-by: Ming Lei <ming.lei@redhat.com>
    Reviewed-by: Omar Sandoval <osandov@fb.com>
    Signed-off-by: Jens Axboe <axboe@kernel.dk>

diff --git a/drivers/scsi/scsi_transport_sas.c b/drivers/scsi/scsi_transport_sas.c
index 0a165b2b3e81..cf6d47891d77 100644
--- a/drivers/scsi/scsi_transport_sas.c
+++ b/drivers/scsi/scsi_transport_sas.c
@@ -198,7 +198,7 @@ static int sas_bsg_initialize(struct Scsi_Host *shost, struct sas_rphy *rphy)
 
 	if (rphy) {
 		q = bsg_setup_queue(&rphy->dev, dev_name(&rphy->dev),
-				sas_smp_dispatch, 0);
+				sas_smp_dispatch, NULL, 0);
 		if (IS_ERR(q))
 			return PTR_ERR(q);
 		rphy->q = q;
@@ -207,7 +207,7 @@ static int sas_bsg_initialize(struct Scsi_Host *shost, struct sas_rphy *rphy)
 
 		snprintf(name, sizeof(name), "sas_host%d", shost->host_no);
 		q = bsg_setup_queue(&shost->shost_gendev, name,
-				sas_smp_dispatch, 0);
+				sas_smp_dispatch, NULL, 0);
 		if (IS_ERR(q))
 			return PTR_ERR(q);
 		to_sas_host_attrs(shost)->q = q;

commit 986d7dbc4169a8afefe7f4081253a75b60b791a6
Author: Jason Yan <yanaijie@huawei.com>
Date:   Tue Sep 25 10:56:50 2018 +0800

    scsi: libsas: delete dead code in scsi_transport_sas.c
    
    This code is dead and no clue implies that it will be back again.
    
    Signed-off-by: Jason Yan <yanaijie@huawei.com>
    CC: John Garry <john.garry@huawei.com>
    CC: Johannes Thumshirn <jthumshirn@suse.de>
    CC: Ewan Milne <emilne@redhat.com>
    CC: Christoph Hellwig <hch@lst.de>
    CC: Tomas Henzl <thenzl@redhat.com>
    CC: Dan Williams <dan.j.williams@intel.com>
    CC: Hannes Reinecke <hare@suse.com>
    Reviewed-by: Johannes Thumshirn <jthumshirn@suse.de>
    Reviewed-by: John Garry <john.garry@huawei.com>
    Reviewed-by: Hannes Reinecke <hare@suse.com>
    Reviewed-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/scsi_transport_sas.c b/drivers/scsi/scsi_transport_sas.c
index 0cd16e80b019..0a165b2b3e81 100644
--- a/drivers/scsi/scsi_transport_sas.c
+++ b/drivers/scsi/scsi_transport_sas.c
@@ -612,7 +612,6 @@ sas_phy_protocol_attr(identify.target_port_protocols,
 sas_phy_simple_attr(identify.sas_address, sas_address, "0x%016llx\n",
 		unsigned long long);
 sas_phy_simple_attr(identify.phy_identifier, phy_identifier, "%d\n", u8);
-//sas_phy_simple_attr(port_identifier, port_identifier, "%d\n", int);
 sas_phy_linkspeed_attr(negotiated_linkrate);
 sas_phy_linkspeed_attr(minimum_linkrate_hw);
 sas_phy_linkspeed_rw_attr(minimum_linkrate);
@@ -1802,7 +1801,6 @@ sas_attach_transport(struct sas_function_template *ft)
 	SETUP_PHY_ATTRIBUTE(device_type);
 	SETUP_PHY_ATTRIBUTE(sas_address);
 	SETUP_PHY_ATTRIBUTE(phy_identifier);
-	//SETUP_PHY_ATTRIBUTE(port_identifier);
 	SETUP_PHY_ATTRIBUTE(negotiated_linkrate);
 	SETUP_PHY_ATTRIBUTE(minimum_linkrate_hw);
 	SETUP_PHY_ATTRIBUTE_RW(minimum_linkrate);

commit 5f85942c2ea2ed59d8f19c954bbb0f5c1a2ebdd1
Merge: 0c14e43a42e4 1b5c2cb19668
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sun Jun 10 13:01:12 2018 -0700

    Merge tag 'scsi-misc' of git://git.kernel.org/pub/scm/linux/kernel/git/jejb/scsi
    
    Pull SCSI updates from James Bottomley:
     "This is mostly updates to the usual drivers: ufs, qedf, mpt3sas, lpfc,
      xfcp, hisi_sas, cxlflash, qla2xxx.
    
      In the absence of Nic, we're also taking target updates which are
      mostly minor except for the tcmu refactor.
    
      The only real core change to worry about is the removal of high page
      bouncing (in sas, storvsc and iscsi). This has been well tested and no
      problems have shown up so far"
    
    * tag 'scsi-misc' of git://git.kernel.org/pub/scm/linux/kernel/git/jejb/scsi: (268 commits)
      scsi: lpfc: update driver version to 12.0.0.4
      scsi: lpfc: Fix port initialization failure.
      scsi: lpfc: Fix 16gb hbas failing cq create.
      scsi: lpfc: Fix crash in blk_mq layer when executing modprobe -r lpfc
      scsi: lpfc: correct oversubscription of nvme io requests for an adapter
      scsi: lpfc: Fix MDS diagnostics failure (Rx < Tx)
      scsi: hisi_sas: Mark PHY as in reset for nexus reset
      scsi: hisi_sas: Fix return value when get_free_slot() failed
      scsi: hisi_sas: Terminate STP reject quickly for v2 hw
      scsi: hisi_sas: Add v2 hw force PHY function for internal ATA command
      scsi: hisi_sas: Include TMF elements in struct hisi_sas_slot
      scsi: hisi_sas: Try wait commands before before controller reset
      scsi: hisi_sas: Init disks after controller reset
      scsi: hisi_sas: Create a scsi_host_template per HW module
      scsi: hisi_sas: Reset disks when discovered
      scsi: hisi_sas: Add LED feature for v3 hw
      scsi: hisi_sas: Change common allocation mode of device id
      scsi: hisi_sas: change slot index allocation mode
      scsi: hisi_sas: Introduce hisi_sas_phy_set_linkrate()
      scsi: hisi_sas: fix a typo in hisi_sas_task_prep()
      ...

commit 5de815a7eedfacf593817ef34634eaa9b75a1482
Author: Christoph Hellwig <hch@lst.de>
Date:   Tue May 29 08:40:23 2018 +0200

    block: remove parent device reference from struct bsg_class_device
    
    Bsg holding a reference to the parent device may result in a crash if a
    bsg file handle is closed after the parent device driver has unloaded.
    
    Holding a reference is not really needed: the parent device must exist
    between bsg_register_queue and bsg_unregister_queue.  Before the device
    goes away the caller does blk_cleanup_queue so that all in-flight
    requests to the device are gone and all new requests cannot pass beyond
    the queue.  The queue itself is a refcounted object and it will stay
    alive with a bsg file.
    
    Based on analysis, previous patch and changelog from Anatoliy Glagolev.
    
    Reported-by: Anatoliy Glagolev <glagolig@gmail.com>
    Reviewed-by: James E.J. Bottomley <jejb@linux.vnet.ibm.com>
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Jens Axboe <axboe@kernel.dk>

diff --git a/drivers/scsi/scsi_transport_sas.c b/drivers/scsi/scsi_transport_sas.c
index 08acbabfae07..e2953b416746 100644
--- a/drivers/scsi/scsi_transport_sas.c
+++ b/drivers/scsi/scsi_transport_sas.c
@@ -187,16 +187,6 @@ static int sas_smp_dispatch(struct bsg_job *job)
 	return 0;
 }
 
-static void sas_host_release(struct device *dev)
-{
-	struct Scsi_Host *shost = dev_to_shost(dev);
-	struct sas_host_attrs *sas_host = to_sas_host_attrs(shost);
-	struct request_queue *q = sas_host->q;
-
-	if (q)
-		blk_cleanup_queue(q);
-}
-
 static int sas_bsg_initialize(struct Scsi_Host *shost, struct sas_rphy *rphy)
 {
 	struct request_queue *q;
@@ -208,7 +198,7 @@ static int sas_bsg_initialize(struct Scsi_Host *shost, struct sas_rphy *rphy)
 
 	if (rphy) {
 		q = bsg_setup_queue(&rphy->dev, dev_name(&rphy->dev),
-				sas_smp_dispatch, 0, NULL);
+				sas_smp_dispatch, 0);
 		if (IS_ERR(q))
 			return PTR_ERR(q);
 		rphy->q = q;
@@ -217,7 +207,7 @@ static int sas_bsg_initialize(struct Scsi_Host *shost, struct sas_rphy *rphy)
 
 		snprintf(name, sizeof(name), "sas_host%d", shost->host_no);
 		q = bsg_setup_queue(&shost->shost_gendev, name,
-				sas_smp_dispatch, 0, sas_host_release);
+				sas_smp_dispatch, 0);
 		if (IS_ERR(q))
 			return PTR_ERR(q);
 		to_sas_host_attrs(shost)->q = q;
@@ -260,8 +250,11 @@ static int sas_host_remove(struct transport_container *tc, struct device *dev,
 	struct Scsi_Host *shost = dev_to_shost(dev);
 	struct request_queue *q = to_sas_host_attrs(shost)->q;
 
-	if (q)
+	if (q) {
 		bsg_unregister_queue(q);
+		blk_cleanup_queue(q);
+	}
+
 	return 0;
 }
 

commit 63aed100e2416256c8830285174a08a0cfb47aad
Author: Christoph Hellwig <hch@lst.de>
Date:   Sun Apr 15 16:52:37 2018 +0200

    scsi: scsi_transport_sas: don't bounce highmem pages for the smp handler
    
    All three instance of ->smp_handler deal with highmem backed requests
    just fine.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Reviewed-by: Johannes Thumshirn <jthumshirn@suse.de>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/scsi_transport_sas.c b/drivers/scsi/scsi_transport_sas.c
index 08acbabfae07..a22baf206071 100644
--- a/drivers/scsi/scsi_transport_sas.c
+++ b/drivers/scsi/scsi_transport_sas.c
@@ -223,10 +223,6 @@ static int sas_bsg_initialize(struct Scsi_Host *shost, struct sas_rphy *rphy)
 		to_sas_host_attrs(shost)->q = q;
 	}
 
-	/*
-	 * by default assume old behaviour and bounce for any highmem page
-	 */
-	blk_queue_bounce_limit(q, BLK_BOUNCE_HIGH);
 	blk_queue_flag_set(QUEUE_FLAG_BIDI, q);
 	return 0;
 }

commit 17cb960f29c29ee07bf6848ada3265f4be55972e
Author: Christoph Hellwig <hch@lst.de>
Date:   Tue Mar 13 17:28:41 2018 +0100

    bsg: split handling of SCSI CDBs vs transport requeues
    
    The current BSG design tries to shoe-horn the transport-specific
    passthrough commands into the overall framework for SCSI passthrough
    requests.  This has a couple problems:
    
     - each passthrough queue has to set the QUEUE_FLAG_SCSI_PASSTHROUGH flag
       despite not dealing with SCSI commands at all.  Because of that these
       queues could also incorrectly accept SCSI commands from in-kernel
       users or through the legacy SCSI_IOCTL_SEND_COMMAND ioctl.
     - the real SCSI bsg queues also incorrectly accept bsg requests of the
       BSG_SUB_PROTOCOL_SCSI_TRANSPORT type
     - the bsg transport code is almost unredable because it tries to reuse
       different SCSI concepts for its own purpose.
    
    This patch instead adds a new bsg_ops structure to handle the two cases
    differently, and thus solves all of the above problems.  Another side
    effect is that the bsg-lib queues also don't need to embedd a
    struct scsi_request anymore.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Reviewed-by: Hannes Reinecke <hare@suse.com>
    Reviewed-by: Johannes Thumshirn <jthumshirn@suse.de>
    Signed-off-by: Jens Axboe <axboe@kernel.dk>

diff --git a/drivers/scsi/scsi_transport_sas.c b/drivers/scsi/scsi_transport_sas.c
index 7c0987616684..08acbabfae07 100644
--- a/drivers/scsi/scsi_transport_sas.c
+++ b/drivers/scsi/scsi_transport_sas.c
@@ -228,7 +228,6 @@ static int sas_bsg_initialize(struct Scsi_Host *shost, struct sas_rphy *rphy)
 	 */
 	blk_queue_bounce_limit(q, BLK_BOUNCE_HIGH);
 	blk_queue_flag_set(QUEUE_FLAG_BIDI, q);
-	blk_queue_flag_set(QUEUE_FLAG_SCSI_PASSTHROUGH, q);
 	return 0;
 }
 

commit 8b904b5b6b58b9a29dcf3f82d936d9e7fd69fda6
Author: Bart Van Assche <bart.vanassche@wdc.com>
Date:   Wed Mar 7 17:10:10 2018 -0800

    block: Use blk_queue_flag_*() in drivers instead of queue_flag_*()
    
    This patch has been generated as follows:
    
    for verb in set_unlocked clear_unlocked set clear; do
      replace-in-files queue_flag_${verb} blk_queue_flag_${verb%_unlocked} \
        $(git grep -lw queue_flag_${verb} drivers block/bsg*)
    done
    
    Except for protecting all queue flag changes with the queue lock
    this patch does not change any functionality.
    
    Cc: Mike Snitzer <snitzer@redhat.com>
    Cc: Shaohua Li <shli@fb.com>
    Cc: Christoph Hellwig <hch@lst.de>
    Cc: Hannes Reinecke <hare@suse.de>
    Cc: Ming Lei <ming.lei@redhat.com>
    Signed-off-by: Bart Van Assche <bart.vanassche@wdc.com>
    Reviewed-by: Martin K. Petersen <martin.petersen@oracle.com>
    Reviewed-by: Johannes Thumshirn <jthumshirn@suse.de>
    Acked-by: Martin K. Petersen <martin.petersen@oracle.com>
    Signed-off-by: Jens Axboe <axboe@kernel.dk>

diff --git a/drivers/scsi/scsi_transport_sas.c b/drivers/scsi/scsi_transport_sas.c
index 736a1f4f9676..7c0987616684 100644
--- a/drivers/scsi/scsi_transport_sas.c
+++ b/drivers/scsi/scsi_transport_sas.c
@@ -227,8 +227,8 @@ static int sas_bsg_initialize(struct Scsi_Host *shost, struct sas_rphy *rphy)
 	 * by default assume old behaviour and bounce for any highmem page
 	 */
 	blk_queue_bounce_limit(q, BLK_BOUNCE_HIGH);
-	queue_flag_set_unlocked(QUEUE_FLAG_BIDI, q);
-	queue_flag_set_unlocked(QUEUE_FLAG_SCSI_PASSTHROUGH, q);
+	blk_queue_flag_set(QUEUE_FLAG_BIDI, q);
+	blk_queue_flag_set(QUEUE_FLAG_SCSI_PASSTHROUGH, q);
 	return 0;
 }
 

commit 07f5d563c6e52068cbfcd97ed79f5bb1b1d33067
Author: Christoph Hellwig <hch@lst.de>
Date:   Tue Oct 3 12:48:41 2017 +0200

    scsi: scsi_transport_sas: check reply payload length instead of bidi request
    
    As a user of bsg-lib the SAS transport should not poke into request
    internals but use the bsg_job fields instead.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Reviewed-by: Hannes Reinecke <hare@suse.com>
    Reviewed-by: Johannes Thumshirn <jthumshirn@suse.de>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/scsi_transport_sas.c b/drivers/scsi/scsi_transport_sas.c
index 319dff970237..736a1f4f9676 100644
--- a/drivers/scsi/scsi_transport_sas.c
+++ b/drivers/scsi/scsi_transport_sas.c
@@ -177,7 +177,7 @@ static int sas_smp_dispatch(struct bsg_job *job)
 	if (!scsi_is_host_device(job->dev))
 		rphy = dev_to_rphy(job->dev);
 
-	if (!job->req->next_rq) {
+	if (!job->reply_payload.payload_len) {
 		dev_warn(job->dev, "space for a smp response is missing\n");
 		bsg_job_done(job, -EINVAL, 0);
 		return 0;

commit 651a013649943710a900551ec6e03d2084e1a65a
Author: Christoph Hellwig <hch@lst.de>
Date:   Fri Aug 25 17:37:41 2017 +0200

    scsi: scsi_transport_sas: switch to bsg-lib for SMP passthrough
    
    Simplify the SMP passthrough code by switching it to the generic bsg-lib
    helpers that abstract away the details of the request code, and gets
    drivers out of seeing struct scsi_request.
    
    For the libsas host SMP code there is a small behavior difference in
    that we now always clear the residual len for successful commands,
    similar to the three other SMP handler implementations.  Given that
    there is no partial command handling in the host SMP handler this should
    not matter in practice.
    
    [mkp: typos and checkpatch fixes]
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Reviewed-by: Johannes Thumshirn <jthumshirn@suse.de>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/scsi_transport_sas.c b/drivers/scsi/scsi_transport_sas.c
index e2e948f1ce28..319dff970237 100644
--- a/drivers/scsi/scsi_transport_sas.c
+++ b/drivers/scsi/scsi_transport_sas.c
@@ -169,39 +169,22 @@ static struct sas_end_device *sas_sdev_to_rdev(struct scsi_device *sdev)
 	return rdev;
 }
 
-static void sas_smp_request(struct request_queue *q, struct Scsi_Host *shost,
-			    struct sas_rphy *rphy)
+static int sas_smp_dispatch(struct bsg_job *job)
 {
-	struct request *req;
-	blk_status_t ret;
-	int (*handler)(struct Scsi_Host *, struct sas_rphy *, struct request *);
+	struct Scsi_Host *shost = dev_to_shost(job->dev);
+	struct sas_rphy *rphy = NULL;
 
-	while ((req = blk_fetch_request(q)) != NULL) {
-		spin_unlock_irq(q->queue_lock);
+	if (!scsi_is_host_device(job->dev))
+		rphy = dev_to_rphy(job->dev);
 
-		scsi_req(req)->resid_len = blk_rq_bytes(req);
-		if (req->next_rq)
-			scsi_req(req->next_rq)->resid_len =
-				blk_rq_bytes(req->next_rq);
-		handler = to_sas_internal(shost->transportt)->f->smp_handler;
-		ret = handler(shost, rphy, req);
-		scsi_req(req)->result = ret;
-
-		blk_end_request_all(req, 0);
-
-		spin_lock_irq(q->queue_lock);
+	if (!job->req->next_rq) {
+		dev_warn(job->dev, "space for a smp response is missing\n");
+		bsg_job_done(job, -EINVAL, 0);
+		return 0;
 	}
-}
 
-static void sas_host_smp_request(struct request_queue *q)
-{
-	sas_smp_request(q, (struct Scsi_Host *)q->queuedata, NULL);
-}
-
-static void sas_non_host_smp_request(struct request_queue *q)
-{
-	struct sas_rphy *rphy = q->queuedata;
-	sas_smp_request(q, rphy_to_shost(rphy), rphy);
+	to_sas_internal(shost->transportt)->f->smp_handler(job, shost, rphy);
+	return 0;
 }
 
 static void sas_host_release(struct device *dev)
@@ -217,81 +200,36 @@ static void sas_host_release(struct device *dev)
 static int sas_bsg_initialize(struct Scsi_Host *shost, struct sas_rphy *rphy)
 {
 	struct request_queue *q;
-	int error;
-	struct device *dev;
-	char namebuf[20];
-	const char *name;
-	void (*release)(struct device *);
 
 	if (!to_sas_internal(shost->transportt)->f->smp_handler) {
 		printk("%s can't handle SMP requests\n", shost->hostt->name);
 		return 0;
 	}
 
-	q = blk_alloc_queue(GFP_KERNEL);
-	if (!q)
-		return -ENOMEM;
-	q->initialize_rq_fn = scsi_initialize_rq;
-	q->cmd_size = sizeof(struct scsi_request);
-
 	if (rphy) {
-		q->request_fn = sas_non_host_smp_request;
-		dev = &rphy->dev;
-		name = dev_name(dev);
-		release = NULL;
+		q = bsg_setup_queue(&rphy->dev, dev_name(&rphy->dev),
+				sas_smp_dispatch, 0, NULL);
+		if (IS_ERR(q))
+			return PTR_ERR(q);
+		rphy->q = q;
 	} else {
-		q->request_fn = sas_host_smp_request;
-		dev = &shost->shost_gendev;
-		snprintf(namebuf, sizeof(namebuf),
-			 "sas_host%d", shost->host_no);
-		name = namebuf;
-		release = sas_host_release;
+		char name[20];
+
+		snprintf(name, sizeof(name), "sas_host%d", shost->host_no);
+		q = bsg_setup_queue(&shost->shost_gendev, name,
+				sas_smp_dispatch, 0, sas_host_release);
+		if (IS_ERR(q))
+			return PTR_ERR(q);
+		to_sas_host_attrs(shost)->q = q;
 	}
-	error = blk_init_allocated_queue(q);
-	if (error)
-		goto out_cleanup_queue;
 
 	/*
 	 * by default assume old behaviour and bounce for any highmem page
 	 */
 	blk_queue_bounce_limit(q, BLK_BOUNCE_HIGH);
-
-	error = bsg_register_queue(q, dev, name, release);
-	if (error)
-		goto out_cleanup_queue;
-
-	if (rphy)
-		rphy->q = q;
-	else
-		to_sas_host_attrs(shost)->q = q;
-
-	if (rphy)
-		q->queuedata = rphy;
-	else
-		q->queuedata = shost;
-
 	queue_flag_set_unlocked(QUEUE_FLAG_BIDI, q);
 	queue_flag_set_unlocked(QUEUE_FLAG_SCSI_PASSTHROUGH, q);
 	return 0;
-
-out_cleanup_queue:
-	blk_cleanup_queue(q);
-	return error;
-}
-
-static void sas_bsg_remove(struct Scsi_Host *shost, struct sas_rphy *rphy)
-{
-	struct request_queue *q;
-
-	if (rphy)
-		q = rphy->q;
-	else
-		q = to_sas_host_attrs(shost)->q;
-
-	if (!q)
-		return;
-
-	bsg_unregister_queue(q);
 }
 
 /*
@@ -321,9 +259,10 @@ static int sas_host_remove(struct transport_container *tc, struct device *dev,
 			   struct device *cdev)
 {
 	struct Scsi_Host *shost = dev_to_shost(dev);
+	struct request_queue *q = to_sas_host_attrs(shost)->q;
 
-	sas_bsg_remove(shost, NULL);
-
+	if (q)
+		bsg_unregister_queue(q);
 	return 0;
 }
 
@@ -1713,7 +1652,8 @@ sas_rphy_remove(struct sas_rphy *rphy)
 	}
 
 	sas_rphy_unlink(rphy);
-	sas_bsg_remove(NULL, rphy);
+	if (rphy->q)
+		bsg_unregister_queue(rphy->q);
 	transport_remove_device(dev);
 	device_del(dev);
 }

commit e1779b4ff5412fcb7f943f6b49cac5e70fc724e2
Author: Bart Van Assche <bart.vanassche@wdc.com>
Date:   Fri Aug 25 13:46:40 2017 -0700

    scsi: scsi_transport_sas: Check kzalloc() return value
    
    Check whether memory allocation succeeded before dereferencing
    the pointer to the allocated memory.
    
    Signed-off-by: Bart Van Assche <bart.vanassche@wdc.com>
    Reviewed-by: Christoph Hellwig <hch@lst.de>
    Reviewed-by: Hannes Reinecke <hare@suse.com>
    Cc: Johannes Thumshirn <jthumshirn@suse.de>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/scsi_transport_sas.c b/drivers/scsi/scsi_transport_sas.c
index 5006a656e16a..e2e948f1ce28 100644
--- a/drivers/scsi/scsi_transport_sas.c
+++ b/drivers/scsi/scsi_transport_sas.c
@@ -421,6 +421,9 @@ sas_tlr_supported(struct scsi_device *sdev)
 	char *buffer = kzalloc(vpd_len, GFP_KERNEL);
 	int ret = 0;
 
+	if (!buffer)
+		goto out;
+
 	if (scsi_get_vpd_page(sdev, 0x90, buffer, vpd_len))
 		goto out;
 

commit 0bf6595ec81d896451f0066c95f8cd34c74313dc
Author: Christoph Hellwig <hch@lst.de>
Date:   Mon Jun 19 09:26:25 2017 +0200

    block: don't set bounce limit in blk_init_allocated_queue
    
    And just move it into scsi_transport_sas which needs it due to low-level
    drivers directly derferencing bio_data, and into blk_init_queue_node,
    which will need a further push into the callers.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Jens Axboe <axboe@kernel.dk>

diff --git a/drivers/scsi/scsi_transport_sas.c b/drivers/scsi/scsi_transport_sas.c
index a190c052cd93..5006a656e16a 100644
--- a/drivers/scsi/scsi_transport_sas.c
+++ b/drivers/scsi/scsi_transport_sas.c
@@ -251,6 +251,11 @@ static int sas_bsg_initialize(struct Scsi_Host *shost, struct sas_rphy *rphy)
 	if (error)
 		goto out_cleanup_queue;
 
+	/*
+	 * by default assume old behaviour and bounce for any highmem page
+	 */
+	blk_queue_bounce_limit(q, BLK_BOUNCE_HIGH);
+
 	error = bsg_register_queue(q, dev, name, release);
 	if (error)
 		goto out_cleanup_queue;

commit ca18d6f769d22e931d3ba1e8d1ae81953547a417
Author: Bart Van Assche <bart.vanassche@sandisk.com>
Date:   Tue Jun 20 11:15:41 2017 -0700

    block: Make most scsi_req_init() calls implicit
    
    Instead of explicitly calling scsi_req_init() after blk_get_request(),
    call that function from inside blk_get_request(). Add an
    .initialize_rq_fn() callback function to the block drivers that need
    it. Merge the IDE .init_rq_fn() function into .initialize_rq_fn()
    because it is too small to keep it as a separate function. Keep the
    scsi_req_init() call in ide_prep_sense() because it follows a
    blk_rq_init() call.
    
    References: commit 82ed4db499b8 ("block: split scsi_request out of struct request")
    Signed-off-by: Bart Van Assche <bart.vanassche@sandisk.com>
    Cc: Christoph Hellwig <hch@lst.de>
    Cc: Hannes Reinecke <hare@suse.com>
    Cc: Omar Sandoval <osandov@fb.com>
    Cc: Nicholas Bellinger <nab@linux-iscsi.org>
    Signed-off-by: Jens Axboe <axboe@kernel.dk>

diff --git a/drivers/scsi/scsi_transport_sas.c b/drivers/scsi/scsi_transport_sas.c
index cc970c811bcb..a190c052cd93 100644
--- a/drivers/scsi/scsi_transport_sas.c
+++ b/drivers/scsi/scsi_transport_sas.c
@@ -33,6 +33,7 @@
 #include <linux/bsg.h>
 
 #include <scsi/scsi.h>
+#include <scsi/scsi_cmnd.h>
 #include <scsi/scsi_request.h>
 #include <scsi/scsi_device.h>
 #include <scsi/scsi_host.h>
@@ -230,6 +231,7 @@ static int sas_bsg_initialize(struct Scsi_Host *shost, struct sas_rphy *rphy)
 	q = blk_alloc_queue(GFP_KERNEL);
 	if (!q)
 		return -ENOMEM;
+	q->initialize_rq_fn = scsi_initialize_rq;
 	q->cmd_size = sizeof(struct scsi_request);
 
 	if (rphy) {

commit 2a842acab109f40f0d7d10b38e9ca88390628996
Author: Christoph Hellwig <hch@lst.de>
Date:   Sat Jun 3 09:38:04 2017 +0200

    block: introduce new block status code type
    
    Currently we use nornal Linux errno values in the block layer, and while
    we accept any error a few have overloaded magic meanings.  This patch
    instead introduces a new  blk_status_t value that holds block layer specific
    status codes and explicitly explains their meaning.  Helpers to convert from
    and to the previous special meanings are provided for now, but I suspect
    we want to get rid of them in the long run - those drivers that have a
    errno input (e.g. networking) usually get errnos that don't know about
    the special block layer overloads, and similarly returning them to userspace
    will usually return somethings that strictly speaking isn't correct
    for file system operations, but that's left as an exercise for later.
    
    For now the set of errors is a very limited set that closely corresponds
    to the previous overloaded errno values, but there is some low hanging
    fruite to improve it.
    
    blk_status_t (ab)uses the sparse __bitwise annotations to allow for sparse
    typechecking, so that we can easily catch places passing the wrong values.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Jens Axboe <axboe@fb.com>

diff --git a/drivers/scsi/scsi_transport_sas.c b/drivers/scsi/scsi_transport_sas.c
index d16414bfe2ef..cc970c811bcb 100644
--- a/drivers/scsi/scsi_transport_sas.c
+++ b/drivers/scsi/scsi_transport_sas.c
@@ -172,7 +172,7 @@ static void sas_smp_request(struct request_queue *q, struct Scsi_Host *shost,
 			    struct sas_rphy *rphy)
 {
 	struct request *req;
-	int ret;
+	blk_status_t ret;
 	int (*handler)(struct Scsi_Host *, struct sas_rphy *, struct request *);
 
 	while ((req = blk_fetch_request(q)) != NULL) {

commit 9efc160f4bbd69b17b48edec53067537d04e62b7
Author: Bart Van Assche <bart.vanassche@sandisk.com>
Date:   Wed May 31 14:43:46 2017 -0700

    block: Introduce queue flag QUEUE_FLAG_SCSI_PASSTHROUGH
    
    From the context where a SCSI command is submitted it is not always
    possible to figure out whether or not the queue the command is
    submitted to has struct scsi_request as the first member of its
    private data. Hence introduce the flag QUEUE_FLAG_SCSI_PASSTHROUGH.
    
    Signed-off-by: Bart Van Assche <bart.vanassche@sandisk.com>
    Reviewed-by: Hannes Reinecke <hare@suse.com>
    Reviewed-by: Christoph Hellwig <hch@lst.de>
    Reviewed-by: Martin K. Petersen <martin.petersen@oracle.com>
    Cc: Omar Sandoval <osandov@fb.com>
    Cc: Don Brace <don.brace@microsemi.com>
    Signed-off-by: Jens Axboe <axboe@fb.com>

diff --git a/drivers/scsi/scsi_transport_sas.c b/drivers/scsi/scsi_transport_sas.c
index 0ebe2f1bb908..d16414bfe2ef 100644
--- a/drivers/scsi/scsi_transport_sas.c
+++ b/drivers/scsi/scsi_transport_sas.c
@@ -264,6 +264,7 @@ static int sas_bsg_initialize(struct Scsi_Host *shost, struct sas_rphy *rphy)
 		q->queuedata = shost;
 
 	queue_flag_set_unlocked(QUEUE_FLAG_BIDI, q);
+	queue_flag_set_unlocked(QUEUE_FLAG_SCSI_PASSTHROUGH, q);
 	return 0;
 
 out_cleanup_queue:

commit 8d5e72dfdf0fa29a21143fd72746c6f43295ce9f
Merge: 2bd804017435 e7731da36f10
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Thu May 4 12:19:44 2017 -0700

    Merge tag 'scsi-misc' of git://git.kernel.org/pub/scm/linux/kernel/git/jejb/scsi
    
    Pull SCSI updates from James Bottomley:
     "This update includes the usual round of major driver updates
      (hisi_sas, ufs, fnic, cxlflash, be2iscsi, ipr, stex). There's also the
      usual amount of cosmetic and spelling stuff"
    
    * tag 'scsi-misc' of git://git.kernel.org/pub/scm/linux/kernel/git/jejb/scsi: (155 commits)
      scsi: qla4xxx: fix spelling mistake: "Tempalate" -> "Template"
      scsi: stex: make S6flag static
      scsi: mac_esp: fix to pass correct device identity to free_irq()
      scsi: aacraid: pci_alloc_consistent() failures on ARM64
      scsi: ufs: make ufshcd_get_lists_status() register operation obvious
      scsi: ufs: use MASK_EE_STATUS
      scsi: mac_esp: Replace bogus memory barrier with spinlock
      scsi: fcoe: make fcoe_e_d_tov and fcoe_r_a_tov static
      scsi: sd_zbc: Do not write lock zones for reset
      scsi: sd_zbc: Remove superfluous assignments
      scsi: sd: sd_zbc: Rename sd_zbc_setup_write_cmnd
      scsi: Improve scsi_get_sense_info_fld
      scsi: sd: Cleanup sd_done sense data handling
      scsi: sd: Improve sd_completed_bytes
      scsi: sd: Fix function descriptions
      scsi: mpt3sas: remove redundant wmb
      scsi: mpt: Move scsi_remove_host() out of mptscsih_remove_host()
      scsi: sg: reset 'res_in_use' after unlinking reserved array
      scsi: mvumi: remove code handling zero scsi_sg_count(scmd) case
      scsi: fusion: fix spelling mistake: "Persistancy" -> "Persistency"
      ...

commit d188b90c48e418e102a1f42872b13dfe386ab6a7
Author: Christoph Hellwig <hch@lst.de>
Date:   Wed Apr 26 09:34:20 2017 +0200

    scsi_transport_sas: always pass 0 error to blk_end_request_all
    
    The SAS transport queues are only used by bsg, and bsg always looks at
    the scsi_request results and never add the error passed in the end_io
    callback.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Jens Axboe <axboe@fb.com>

diff --git a/drivers/scsi/scsi_transport_sas.c b/drivers/scsi/scsi_transport_sas.c
index a2b279737a4b..9fdbd50c31b4 100644
--- a/drivers/scsi/scsi_transport_sas.c
+++ b/drivers/scsi/scsi_transport_sas.c
@@ -186,7 +186,7 @@ static void sas_smp_request(struct request_queue *q, struct Scsi_Host *shost,
 		ret = handler(shost, rphy, req);
 		scsi_req(req)->result = ret;
 
-		blk_end_request_all(req, ret);
+		blk_end_request_all(req, 0);
 
 		spin_lock_irq(q->queue_lock);
 	}

commit c5ce0abeb62845352d7428d6b82e5b52e8728f12
Author: Johannes Thumshirn <jthumshirn@suse.de>
Date:   Fri Apr 21 14:11:41 2017 +0200

    scsi: sas: move scsi_remove_host call into sas_remove_host
    
    Move scsi_remove_host call into sas_remove_host and remove it from SAS
    HBA drivers, so we don't mess up the ordering. This solves an issue with
    double deleting sysfs entries that was introduced by the change of sysfs
    behaviour from commit bcdde7e221a8 ("sysfs: make __sysfs_remove_dir()
    recursive").
    
    [mkp: addressed checkpatch complaints]
    
    Signed-off-by: Johannes Thumshirn <jthumshirn@suse.de>
    Suggested-by: Christoph Hellwig <hch@lst.de>
    Cc: Hannes Reinecke <hare@suse.de>
    Cc: James Bottomley <jejb@linux.vnet.ibm.com>
    Cc: Jinpu Wang <jinpu.wang@profitbricks.com>
    Cc: John Garry <john.garry@huawei.com>
    Reviewed-by: Christoph Hellwig <hch@lst.de>
    Reviewed-by: Jinpu Wang <jinpu.wang@profitbricks.com>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/scsi_transport_sas.c b/drivers/scsi/scsi_transport_sas.c
index cdbb293aca08..ca0e5a9a17f8 100644
--- a/drivers/scsi/scsi_transport_sas.c
+++ b/drivers/scsi/scsi_transport_sas.c
@@ -370,12 +370,16 @@ EXPORT_SYMBOL(sas_remove_children);
  * sas_remove_host  -  tear down a Scsi_Host's SAS data structures
  * @shost:	Scsi Host that is torn down
  *
- * Removes all SAS PHYs and remote PHYs for a given Scsi_Host.
- * Must be called just before scsi_remove_host for SAS HBAs.
+ * Removes all SAS PHYs and remote PHYs for a given Scsi_Host and remove the
+ * Scsi_Host as well.
+ *
+ * Note: Do not call scsi_remove_host() on the Scsi_Host any more, as it is
+ * already removed.
  */
 void sas_remove_host(struct Scsi_Host *shost)
 {
 	sas_remove_children(&shost->shost_gendev);
+	scsi_remove_host(shost);
 }
 EXPORT_SYMBOL(sas_remove_host);
 

commit 17d5363b83f8c73ef9109f75a4a9b578f31d842f
Author: Christoph Hellwig <hch@lst.de>
Date:   Thu Apr 20 16:03:01 2017 +0200

    scsi: introduce a result field in struct scsi_request
    
    This passes on the scsi_cmnd result field to users of passthrough
    requests.  Currently we abuse req->errors for this purpose, but that
    field will go away in its current form.
    
    Note that the old IDE code abuses the errors field in very creative
    ways and stores all kinds of different values in it.  I didn't dare
    to touch this magic, so the abuses are brought forward 1:1.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Reviewed-by: Martin K. Petersen <martin.petersen@oracle.com>
    Reviewed-by: Bart Van Assche <Bart.VanAssche@sandisk.com>
    Signed-off-by: Jens Axboe <axboe@fb.com>

diff --git a/drivers/scsi/scsi_transport_sas.c b/drivers/scsi/scsi_transport_sas.c
index cdbb293aca08..a2b279737a4b 100644
--- a/drivers/scsi/scsi_transport_sas.c
+++ b/drivers/scsi/scsi_transport_sas.c
@@ -184,7 +184,7 @@ static void sas_smp_request(struct request_queue *q, struct Scsi_Host *shost,
 				blk_rq_bytes(req->next_rq);
 		handler = to_sas_internal(shost->transportt)->f->smp_handler;
 		ret = handler(shost, rphy, req);
-		req->errors = ret;
+		scsi_req(req)->result = ret;
 
 		blk_end_request_all(req, ret);
 

commit 183b8021fc0a5fadecdf9c0ccac1f48b5c326278
Author: Masahiro Yamada <yamada.masahiro@socionext.com>
Date:   Mon Feb 27 14:29:20 2017 -0800

    scripts/spelling.txt: add "intialization" pattern and fix typo instances
    
    Fix typos and add the following to the scripts/spelling.txt:
    
      intialization||initialization
    
    The "inintialization" in drivers/acpi/spcr.c is a different pattern but
    I fixed it as well in this commit.
    
    Link: http://lkml.kernel.org/r/1481573103-11329-16-git-send-email-yamada.masahiro@socionext.com
    Signed-off-by: Masahiro Yamada <yamada.masahiro@socionext.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/scsi/scsi_transport_sas.c b/drivers/scsi/scsi_transport_sas.c
index f94535130a34..cdbb293aca08 100644
--- a/drivers/scsi/scsi_transport_sas.c
+++ b/drivers/scsi/scsi_transport_sas.c
@@ -1475,7 +1475,7 @@ static void sas_end_device_release(struct device *dev)
 }
 
 /**
- * sas_rphy_initialize - common rphy intialization
+ * sas_rphy_initialize - common rphy initialization
  * @rphy:	rphy to initialise
  *
  * Used by both sas_end_device_alloc() and sas_expander_alloc() to

commit bd1599d931ca735c1081f11aa4d49006350709f1
Author: Omar Sandoval <osandov@fb.com>
Date:   Tue Feb 21 10:03:50 2017 -0800

    scsi_transport_sas: fix BSG ioctl memory corruption
    
    The end_device and sas_host devices support BSG ioctls, but the
    request_queue allocated for them isn't set up to allocate the struct
    scsi_request payload. This leads to memory corruption in the call to
    scsi_req_init() in bsg_map_hdr(), since it will memset past the end of
    the allocated request. Fix it by setting ->cmd_size on the allocated
    request_queue.
    
    Fixes: 82ed4db499b8 ("block: split scsi_request out of struct request")
    Signed-off-by: Omar Sandoval <osandov@fb.com>
    Acked-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Jens Axboe <axboe@fb.com>

diff --git a/drivers/scsi/scsi_transport_sas.c b/drivers/scsi/scsi_transport_sas.c
index 126a5ee00987..f94535130a34 100644
--- a/drivers/scsi/scsi_transport_sas.c
+++ b/drivers/scsi/scsi_transport_sas.c
@@ -227,27 +227,31 @@ static int sas_bsg_initialize(struct Scsi_Host *shost, struct sas_rphy *rphy)
 		return 0;
 	}
 
+	q = blk_alloc_queue(GFP_KERNEL);
+	if (!q)
+		return -ENOMEM;
+	q->cmd_size = sizeof(struct scsi_request);
+
 	if (rphy) {
-		q = blk_init_queue(sas_non_host_smp_request, NULL);
+		q->request_fn = sas_non_host_smp_request;
 		dev = &rphy->dev;
 		name = dev_name(dev);
 		release = NULL;
 	} else {
-		q = blk_init_queue(sas_host_smp_request, NULL);
+		q->request_fn = sas_host_smp_request;
 		dev = &shost->shost_gendev;
 		snprintf(namebuf, sizeof(namebuf),
 			 "sas_host%d", shost->host_no);
 		name = namebuf;
 		release = sas_host_release;
 	}
-	if (!q)
-		return -ENOMEM;
+	error = blk_init_allocated_queue(q);
+	if (error)
+		goto out_cleanup_queue;
 
 	error = bsg_register_queue(q, dev, name, release);
-	if (error) {
-		blk_cleanup_queue(q);
-		return -ENOMEM;
-	}
+	if (error)
+		goto out_cleanup_queue;
 
 	if (rphy)
 		rphy->q = q;
@@ -261,6 +265,10 @@ static int sas_bsg_initialize(struct Scsi_Host *shost, struct sas_rphy *rphy)
 
 	queue_flag_set_unlocked(QUEUE_FLAG_BIDI, q);
 	return 0;
+
+out_cleanup_queue:
+	blk_cleanup_queue(q);
+	return error;
 }
 
 static void sas_bsg_remove(struct Scsi_Host *shost, struct sas_rphy *rphy)

commit 82ed4db499b8598f16f8871261bff088d6b0597f
Author: Christoph Hellwig <hch@lst.de>
Date:   Fri Jan 27 09:46:29 2017 +0100

    block: split scsi_request out of struct request
    
    And require all drivers that want to support BLOCK_PC to allocate it
    as the first thing of their private data.  To support this the legacy
    IDE and BSG code is switched to set cmd_size on their queues to let
    the block layer allocate the additional space.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Jens Axboe <axboe@fb.com>

diff --git a/drivers/scsi/scsi_transport_sas.c b/drivers/scsi/scsi_transport_sas.c
index 60b651bfaa01..126a5ee00987 100644
--- a/drivers/scsi/scsi_transport_sas.c
+++ b/drivers/scsi/scsi_transport_sas.c
@@ -33,6 +33,7 @@
 #include <linux/bsg.h>
 
 #include <scsi/scsi.h>
+#include <scsi/scsi_request.h>
 #include <scsi/scsi_device.h>
 #include <scsi/scsi_host.h>
 #include <scsi/scsi_transport.h>
@@ -177,6 +178,10 @@ static void sas_smp_request(struct request_queue *q, struct Scsi_Host *shost,
 	while ((req = blk_fetch_request(q)) != NULL) {
 		spin_unlock_irq(q->queue_lock);
 
+		scsi_req(req)->resid_len = blk_rq_bytes(req);
+		if (req->next_rq)
+			scsi_req(req->next_rq)->resid_len =
+				blk_rq_bytes(req->next_rq);
 		handler = to_sas_internal(shost->transportt)->f->smp_handler;
 		ret = handler(shost, rphy, req);
 		req->errors = ret;

commit a0f81dbeef13aa0aeaa8b955b38735dbf09de392
Author: Johannes Thumshirn <jthumshirn@suse.de>
Date:   Wed Aug 17 11:46:18 2016 +0200

    scsi: sas: remove is_sas_attached()
    
    As there are no more users of is_sas_attached() left, remove it.
    
    Signed-off-by: Johannes Thumshirn <jthumshirn@suse.de>
    Reviewed-by: James E.J. Bottomley <jejb@linux.vnet.ibm.com>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/scsi_transport_sas.c b/drivers/scsi/scsi_transport_sas.c
index 3f0ff072184b..60b651bfaa01 100644
--- a/drivers/scsi/scsi_transport_sas.c
+++ b/drivers/scsi/scsi_transport_sas.c
@@ -340,22 +340,6 @@ static int do_sas_phy_delete(struct device *dev, void *data)
 	return 0;
 }
 
-/**
- * is_sas_attached - check if device is SAS attached
- * @sdev: scsi device to check
- *
- * returns true if the device is SAS attached
- */
-int is_sas_attached(struct scsi_device *sdev)
-{
-	struct Scsi_Host *shost = sdev->host;
-
-	return shost->transportt->host_attrs.ac.class ==
-		&sas_host_class.class;
-}
-EXPORT_SYMBOL(is_sas_attached);
-
-
 /**
  * sas_remove_children  -  tear down a devices SAS data structures
  * @dev:	device belonging to the sas object

commit 1d64508810d8d15867251c75a68d7250278ce2bd
Author: Hannes Reinecke <hare@suse.de>
Date:   Thu Mar 17 08:39:45 2016 +0100

    scsi: disable automatic target scan
    
    On larger installations it is useful to disable automatic LUN scanning,
    and only add the required LUNs via udev rules.  This can speed up bootup
    dramatically.
    
    This patch introduces a new scan module parameter value 'manual', which
    works like 'none', but can be overridden by setting the 'rescan' value
    from scsi_scan_target to 'SCSI_SCAN_MANUAL'.  And it updates all
    relevant callers to set the 'rescan' value to 'SCSI_SCAN_MANUAL' if
    invoked via the 'scan' option in sysfs.
    
    Signed-off-by: Hannes Reinecke <hare@suse.de>
    Reviewed-by: Ewan D. Milne <emilne@redhat.com>
    Tested-by: Laurence Oberman <loberman@redhat.com>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/scsi_transport_sas.c b/drivers/scsi/scsi_transport_sas.c
index b6f958193dad..3f0ff072184b 100644
--- a/drivers/scsi/scsi_transport_sas.c
+++ b/drivers/scsi/scsi_transport_sas.c
@@ -1614,7 +1614,8 @@ int sas_rphy_add(struct sas_rphy *rphy)
 		else
 			lun = 0;
 
-		scsi_scan_target(&rphy->dev, 0, rphy->scsi_target_id, lun, 0);
+		scsi_scan_target(&rphy->dev, 0, rphy->scsi_target_id, lun,
+				 SCSI_SCAN_INITIAL);
 	}
 
 	return 0;
@@ -1739,8 +1740,8 @@ static int sas_user_scan(struct Scsi_Host *shost, uint channel,
 
 		if ((channel == SCAN_WILD_CARD || channel == 0) &&
 		    (id == SCAN_WILD_CARD || id == rphy->scsi_target_id)) {
-			scsi_scan_target(&rphy->dev, 0,
-					 rphy->scsi_target_id, lun, 1);
+			scsi_scan_target(&rphy->dev, 0, rphy->scsi_target_id,
+					 lun, SCSI_SCAN_MANUAL);
 		}
 	}
 	mutex_unlock(&sas_host->lock);

commit cdc43ae34c25693fa8de30c9a95243cd45548023
Author: Hannes Reinecke <hare@suse.de>
Date:   Mon Mar 14 10:43:08 2016 +0100

    scsi_transport_sas: add 'scsi_target_id' sysfs attribute
    
    There is no way to detect the scsi_target_id for any given SAS remote
    port, so add a new sysfs attribute 'scsi_target_id'.
    
    Signed-off-by: Hannes Reinecke <hare@suse.com>
    Reviewed-by: Johannes Thumshirn <jthumshirn@suse.de>
    Reviewed-by: Manoj Kumar <manoj@linux.vnet.ibm.com>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/scsi_transport_sas.c b/drivers/scsi/scsi_transport_sas.c
index 80520e2f0fa2..b6f958193dad 100644
--- a/drivers/scsi/scsi_transport_sas.c
+++ b/drivers/scsi/scsi_transport_sas.c
@@ -1286,6 +1286,7 @@ sas_rphy_protocol_attr(identify.target_port_protocols, target_port_protocols);
 sas_rphy_simple_attr(identify.sas_address, sas_address, "0x%016llx\n",
 		unsigned long long);
 sas_rphy_simple_attr(identify.phy_identifier, phy_identifier, "%d\n", u8);
+sas_rphy_simple_attr(scsi_target_id, scsi_target_id, "%d\n", u32);
 
 /* only need 8 bytes of data plus header (4 or 8) */
 #define BUF_SIZE 64
@@ -1886,6 +1887,7 @@ sas_attach_transport(struct sas_function_template *ft)
 	SETUP_RPORT_ATTRIBUTE(rphy_device_type);
 	SETUP_RPORT_ATTRIBUTE(rphy_sas_address);
 	SETUP_RPORT_ATTRIBUTE(rphy_phy_identifier);
+	SETUP_RPORT_ATTRIBUTE(rphy_scsi_target_id);
 	SETUP_OPTIONAL_RPORT_ATTRIBUTE(rphy_enclosure_identifier,
 				       get_enclosure_identifier);
 	SETUP_OPTIONAL_RPORT_ATTRIBUTE(rphy_bay_identifier,

commit bcf508c13385e74972f5cc06d8471d5c100395b0
Author: James Bottomley <James.Bottomley@HansenPartnership.com>
Date:   Wed Dec 9 11:13:35 2015 -0800

    scsi_transport_sas: add function to get SAS endpoint address
    
    For a device known to be SAS connected, this will return the endpoint
    address.  This is useful for getting the SAS address of SATA devices.
    
    Reviewed-by: Hannes Reinecke <hare@suse.com>
    Signed-off-by: James Bottomley <James.Bottomley@HansenPartnership.com>

diff --git a/drivers/scsi/scsi_transport_sas.c b/drivers/scsi/scsi_transport_sas.c
index b17f763a73b2..80520e2f0fa2 100644
--- a/drivers/scsi/scsi_transport_sas.c
+++ b/drivers/scsi/scsi_transport_sas.c
@@ -382,6 +382,20 @@ void sas_remove_host(struct Scsi_Host *shost)
 }
 EXPORT_SYMBOL(sas_remove_host);
 
+/**
+ * sas_get_address - return the SAS address of the device
+ * @sdev: scsi device
+ *
+ * Returns the SAS address of the scsi device
+ */
+u64 sas_get_address(struct scsi_device *sdev)
+{
+	struct sas_end_device *rdev = sas_sdev_to_rdev(sdev);
+
+	return rdev->rphy.identify.sas_address;
+}
+EXPORT_SYMBOL(sas_get_address);
+
 /**
  * sas_tlr_supported - checking TLR bit in vpd 0x90
  * @sdev: scsi device struct

commit 3b91d09c1ca69a69c470efe5fbf346e3e90181d5
Author: James Bottomley <James.Bottomley@HansenPartnership.com>
Date:   Wed Dec 9 11:12:03 2015 -0800

    scsi_transport_sas: add is_sas_attached() function
    
    Adds a function designed to be callable any time (regardless of
    whether the transport attributes are configured or not) which returns
    true if the device is attached over a SAS transport.  The design of
    this function is that transport specific functions can be embedded
    within a
    
    if (is_sas_attached(sdev)) {
            ...
    }
    
    which would be compiled out (and thus eliminate the symbols) if SAS is
    not configured.
    
    Reviewed-by: Hannes Reinecke <hare@suse.com>
    Signed-off-by: James Bottomley <James.Bottomley@HansenPartnership.com>

diff --git a/drivers/scsi/scsi_transport_sas.c b/drivers/scsi/scsi_transport_sas.c
index 30d26e345dcc..b17f763a73b2 100644
--- a/drivers/scsi/scsi_transport_sas.c
+++ b/drivers/scsi/scsi_transport_sas.c
@@ -340,6 +340,22 @@ static int do_sas_phy_delete(struct device *dev, void *data)
 	return 0;
 }
 
+/**
+ * is_sas_attached - check if device is SAS attached
+ * @sdev: scsi device to check
+ *
+ * returns true if the device is SAS attached
+ */
+int is_sas_attached(struct scsi_device *sdev)
+{
+	struct Scsi_Host *shost = sdev->host;
+
+	return shost->transportt->host_attrs.ac.class ==
+		&sas_host_class.class;
+}
+EXPORT_SYMBOL(is_sas_attached);
+
+
 /**
  * sas_remove_children  -  tear down a devices SAS data structures
  * @dev:	device belonging to the sas object

commit 0c416b54f29151a31999868d59c64ace11589d1b
Author: Jordan Hargrave <jharg93@gmail.com>
Date:   Mon Jul 13 09:27:33 2015 -0500

    scsi_transport_sas: Remove check for SAS expander when querying bay/enclosure IDs.
    
    Dell Server backplanes can report bay/enclosure IDs without an
    expander present.  This patch allows the bay/enclosure IDs to be
    propagaged to sysfs.we
    
    Signed-off-by: Jordan Hargrave <jordan_hargrave@dell.com>
    Reviewed-by: Hannes Reinecke <hare@suse.com>
    Signed-off-by: James Bottomley <JBottomley@Odin.com>

diff --git a/drivers/scsi/scsi_transport_sas.c b/drivers/scsi/scsi_transport_sas.c
index 9a058194b9bd..30d26e345dcc 100644
--- a/drivers/scsi/scsi_transport_sas.c
+++ b/drivers/scsi/scsi_transport_sas.c
@@ -1222,13 +1222,6 @@ show_sas_rphy_enclosure_identifier(struct device *dev,
 	u64 identifier;
 	int error;
 
-	/*
-	 * Only devices behind an expander are supported, because the
-	 * enclosure identifier is a SMP feature.
-	 */
-	if (scsi_is_sas_phy_local(phy))
-		return -EINVAL;
-
 	error = i->f->get_enclosure_identifier(rphy, &identifier);
 	if (error)
 		return error;
@@ -1248,9 +1241,6 @@ show_sas_rphy_bay_identifier(struct device *dev,
 	struct sas_internal *i = to_sas_internal(shost->transportt);
 	int val;
 
-	if (scsi_is_sas_phy_local(phy))
-		return -EINVAL;
-
 	val = i->f->get_bay_identifier(rphy);
 	if (val < 0)
 		return val;

commit 9cb78c16f5dadefd8dc5ba0ae5a2f26cd59419b3
Author: Hannes Reinecke <hare@suse.de>
Date:   Wed Jun 25 15:27:36 2014 +0200

    scsi: use 64-bit LUNs
    
    The SCSI standard defines 64-bit values for LUNs, and large arrays
    employing large or hierarchical LUN numbers become more and more
    common.
    
    So update the linux SCSI stack to use 64-bit LUN numbers.
    
    Signed-off-by: Hannes Reinecke <hare@suse.de>
    Reviewed-by: Christoph Hellwig <hch@infradead.org>
    Reviewed-by: Ewan Milne <emilne@redhat.com>
    Signed-off-by: Christoph Hellwig <hch@lst.de>

diff --git a/drivers/scsi/scsi_transport_sas.c b/drivers/scsi/scsi_transport_sas.c
index c341f855fadc..9a058194b9bd 100644
--- a/drivers/scsi/scsi_transport_sas.c
+++ b/drivers/scsi/scsi_transport_sas.c
@@ -1705,7 +1705,7 @@ EXPORT_SYMBOL(scsi_is_sas_rphy);
  */
 
 static int sas_user_scan(struct Scsi_Host *shost, uint channel,
-		uint id, uint lun)
+		uint id, u64 lun)
 {
 	struct sas_host_attrs *sas_host = to_sas_host_attrs(shost);
 	struct sas_rphy *rphy;

commit 6aa6caff30f5dcb9e55b03b9710c30b83750cae5
Author: Joe Lawrence <joe.lawrence@stratus.com>
Date:   Thu May 22 17:30:54 2014 -0400

    [SCSI] scsi_transport_sas: move bsg destructor into sas_rphy_remove
    
    The recent change in sysfs, bcdde7e221a8750f9b62b6d0bd31b72ea4ad9309
    "sysfs: make __sysfs_remove_dir() recursive" revealed an asymmetric
    rphy device creation/deletion sequence in scsi_transport_sas:
    
      modprobe mpt2sas
        sas_rphy_add
          device_add A               rphy->dev
          device_add B               sas_device transport class
          device_add C               sas_end_device transport class
          device_add D               bsg class
    
      rmmod mpt2sas
        sas_rphy_delete
          sas_rphy_remove
            device_del B
            device_del C
            device_del A
              sysfs_remove_group     recursive sysfs dir removal
          sas_rphy_free
            device_del D             warning
    
      where device A is the parent of B, C, and D.
    
    When sas_rphy_free tries to unregister the bsg request queue (device D
    above), the ensuing sysfs cleanup discovers that its sysfs group has
    already been removed and emits a warning, "sysfs group... not found for
    kobject 'end_device-X:0'".
    
    Since bsg creation is a side effect of sas_rphy_add, move its
    complementary removal call into sas_rphy_remove. This imposes the
    following tear-down order for the devices above: D, B, C, A.
    
    Note the sas_device and sas_end_device transport class devices (B and C
    above) are created and destroyed both via the list match traversal in
    attribute_container_device_trigger, so the order in which they are
    handled is fixed. This is fine as long as they are deleted before their
    parent device.
    
    Signed-off-by: Joe Lawrence <joe.lawrence@stratus.com>
    Acked-by: Dan Williams <dan.j.williams@intel.com>
    Signed-off-by: James Bottomley <JBottomley@Parallels.com>

diff --git a/drivers/scsi/scsi_transport_sas.c b/drivers/scsi/scsi_transport_sas.c
index 1b681427dde0..c341f855fadc 100644
--- a/drivers/scsi/scsi_transport_sas.c
+++ b/drivers/scsi/scsi_transport_sas.c
@@ -1621,8 +1621,6 @@ void sas_rphy_free(struct sas_rphy *rphy)
 	list_del(&rphy->list);
 	mutex_unlock(&sas_host->lock);
 
-	sas_bsg_remove(shost, rphy);
-
 	transport_destroy_device(dev);
 
 	put_device(dev);
@@ -1681,6 +1679,7 @@ sas_rphy_remove(struct sas_rphy *rphy)
 	}
 
 	sas_rphy_unlink(rphy);
+	sas_bsg_remove(NULL, rphy);
 	transport_remove_device(dev);
 	device_del(dev);
 }

commit d84fd392bd61524c4d81367969424e6c17086c8c
Author: Sreekanth Reddy <Sreekanth.Reddy@lsi.com>
Date:   Fri Nov 30 07:43:11 2012 +0530

    [SCSI] scsi_transport_sas: add 12GB definitions for mpt3sas
    
    [jejb: split this core change into a separate patch]
    Signed-off-by: Sreekanth Reddy <Sreekanth.Reddy@lsi.com>
    Reviewed-by: Nagalakshmi Nandigama <Nagalakshmi.Nandigama@lsi.com>
    Signed-off-by: James Bottomley <JBottomley@Parallels.com>

diff --git a/drivers/scsi/scsi_transport_sas.c b/drivers/scsi/scsi_transport_sas.c
index f7565fc4f0e3..1b681427dde0 100644
--- a/drivers/scsi/scsi_transport_sas.c
+++ b/drivers/scsi/scsi_transport_sas.c
@@ -151,6 +151,7 @@ static struct {
 	{ SAS_LINK_RATE_1_5_GBPS,	"1.5 Gbit" },
 	{ SAS_LINK_RATE_3_0_GBPS,	"3.0 Gbit" },
 	{ SAS_LINK_RATE_6_0_GBPS,	"6.0 Gbit" },
+	{ SAS_LINK_RATE_12_0_GBPS,	"12.0 Gbit" },
 };
 sas_bitfield_name_search(linkspeed, sas_linkspeed_names)
 sas_bitfield_name_set(linkspeed, sas_linkspeed_names)

commit 16d3db1b298529e6aec4a4cf0f56225d9e0bc641
Author: Dan Williams <dan.j.williams@intel.com>
Date:   Mon Jan 30 22:53:51 2012 -0800

    [SCSI] scsi_transport_sas: 'enable' phys on reset
    
    If userspace requests a phy reset, treat that as a request for the phy
    to be enabled since that is the effect on hardware.
    
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>
    Signed-off-by: James Bottomley <JBottomley@Parallels.com>

diff --git a/drivers/scsi/scsi_transport_sas.c b/drivers/scsi/scsi_transport_sas.c
index 7d69a25d2004..f7565fc4f0e3 100644
--- a/drivers/scsi/scsi_transport_sas.c
+++ b/drivers/scsi/scsi_transport_sas.c
@@ -615,6 +615,7 @@ do_sas_phy_reset(struct device *dev, size_t count, int hard_reset)
 	error = i->f->phy_reset(phy, hard_reset);
 	if (error)
 		return error;
+	phy->enabled = 1;
 	return count;
 };
 

commit f41a0c441c3fe43e79ebeb75584dbb5bfa83e5cd
Author: Dan Williams <dan.j.williams@intel.com>
Date:   Wed Dec 21 21:33:17 2011 -0800

    [SCSI] libsas: fix sas_find_local_phy(), take phy references
    
    In the direct-attached case this routine returns the phy on which this
    device was first discovered.  Which is broken if we want to support
    wide-targets, as this phy reference can become stale even though the
    port is still active.
    
    In the expander-attached case this routine tries to lookup the phy by
    scanning the attached sas addresses of the parent expander, and BUG_ONs
    if it can't find it.  However since eh and the libsas workqueue run
    independently we can still be attempting device recovery via eh after
    libsas has recorded the device as detached.  This is even easier to hit
    now that eh is blocked while device domain rediscovery takes place, and
    that libata is fed more timed out commands increasing the chances that
    it will try to recover the ata device.
    
    Arrange for dev->phy to always point to a last known good phy, it may be
    stale after the port is torn down, but it will catch up for wide port
    reconfigurations, and never be NULL.
    
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>
    Signed-off-by: James Bottomley <JBottomley@Parallels.com>

diff --git a/drivers/scsi/scsi_transport_sas.c b/drivers/scsi/scsi_transport_sas.c
index ab3bd0b5ffd9..7d69a25d2004 100644
--- a/drivers/scsi/scsi_transport_sas.c
+++ b/drivers/scsi/scsi_transport_sas.c
@@ -1059,6 +1059,29 @@ int scsi_is_sas_port(const struct device *dev)
 }
 EXPORT_SYMBOL(scsi_is_sas_port);
 
+/**
+ * sas_port_get_phy - try to take a reference on a port member
+ * @port: port to check
+ */
+struct sas_phy *sas_port_get_phy(struct sas_port *port)
+{
+	struct sas_phy *phy;
+
+	mutex_lock(&port->phy_list_mutex);
+	if (list_empty(&port->phy_list))
+		phy = NULL;
+	else {
+		struct list_head *ent = port->phy_list.next;
+
+		phy = list_entry(ent, typeof(*phy), port_siblings);
+		get_device(&phy->dev);
+	}
+	mutex_unlock(&port->phy_list_mutex);
+
+	return phy;
+}
+EXPORT_SYMBOL(sas_port_get_phy);
+
 /**
  * sas_port_add_phy - add another phy to a port to form a wide port
  * @port:	port to add the phy to

commit 0b3e09da1350397f3f8b6fd839ab455b0b587451
Author: Dan Williams <dan.j.williams@intel.com>
Date:   Tue Dec 20 01:03:48 2011 -0800

    [SCSI] libsas: perform sas-transport resets in shost->workq context
    
    Extend the sas transport class to allow transport users to attach extra
    data to a sas_phy (->hostdata).  Use this area in libsas to move resets
    to workq context in preparation for scheduling ata device resets through
    libata-eh.
    
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>
    Signed-off-by: James Bottomley <JBottomley@Parallels.com>

diff --git a/drivers/scsi/scsi_transport_sas.c b/drivers/scsi/scsi_transport_sas.c
index 9421bae8af1a..ab3bd0b5ffd9 100644
--- a/drivers/scsi/scsi_transport_sas.c
+++ b/drivers/scsi/scsi_transport_sas.c
@@ -652,9 +652,21 @@ sas_phy_linkerror_attr(running_disparity_error_count);
 sas_phy_linkerror_attr(loss_of_dword_sync_count);
 sas_phy_linkerror_attr(phy_reset_problem_count);
 
+static int sas_phy_setup(struct transport_container *tc, struct device *dev,
+			 struct device *cdev)
+{
+	struct sas_phy *phy = dev_to_phy(dev);
+	struct Scsi_Host *shost = dev_to_shost(phy->dev.parent);
+	struct sas_internal *i = to_sas_internal(shost->transportt);
+
+	if (i->f->phy_setup)
+		i->f->phy_setup(phy);
+
+	return 0;
+}
 
 static DECLARE_TRANSPORT_CLASS(sas_phy_class,
-		"sas_phy", NULL, NULL, NULL);
+		"sas_phy", sas_phy_setup, NULL, NULL);
 
 static int sas_phy_match(struct attribute_container *cont, struct device *dev)
 {
@@ -678,7 +690,11 @@ static int sas_phy_match(struct attribute_container *cont, struct device *dev)
 static void sas_phy_release(struct device *dev)
 {
 	struct sas_phy *phy = dev_to_phy(dev);
+	struct Scsi_Host *shost = dev_to_shost(phy->dev.parent);
+	struct sas_internal *i = to_sas_internal(shost->transportt);
 
+	if (i->f->phy_release)
+		i->f->phy_release(phy);
 	put_device(dev->parent);
 	kfree(phy);
 }

commit 87c8331fcf72e501c3a3c0cdc5c9391ec72f7cf2
Author: Dan Williams <dan.j.williams@intel.com>
Date:   Thu Nov 17 17:59:51 2011 -0800

    [SCSI] libsas: prevent domain rediscovery competing with ata error handling
    
    libata error handling provides for a timeout for link recovery.  libsas
    must not rescan for previously known devices in this interval otherwise
    it may remove a device that is simply waiting for its link to recover.
    Let libata-eh make the determination of when the link is stable and
    prevent libsas (host workqueue) from taking action while this
    determination is pending.
    
    Using a mutex (ha->disco_mutex) to flush and disable revalidation while
    eh is running requires any discovery action that may block on eh be
    moved to its own context outside the lock.  Probing ATA devices
    explicitly waits on ata-eh and the cache-flush-io issued during device
    removal may also pend awaiting eh completion.  Essentially any rphy
    add/remove activity needs to run outside the lock.
    
    This adds two new cleanup states for sas_unregister_domain_devices()
    'allocated-but-not-probed', and 'flagged-for-destruction'.  In the
    'allocated-but-not-probed' state  dev->rphy points to a rphy that is
    known to have not been through a sas_rphy_add() event.  At domain
    teardown check if this device is still pending probe and cleanup
    accordingly.  Similarly if a device has already been queued for removal
    then sas_unregister_domain_devices has nothing to do.
    
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>
    Signed-off-by: James Bottomley <JBottomley@Parallels.com>

diff --git a/drivers/scsi/scsi_transport_sas.c b/drivers/scsi/scsi_transport_sas.c
index 9d9330ae4213..9421bae8af1a 100644
--- a/drivers/scsi/scsi_transport_sas.c
+++ b/drivers/scsi/scsi_transport_sas.c
@@ -1602,6 +1602,20 @@ sas_rphy_delete(struct sas_rphy *rphy)
 }
 EXPORT_SYMBOL(sas_rphy_delete);
 
+/**
+ * sas_rphy_unlink  -  unlink SAS remote PHY
+ * @rphy:	SAS remote phy to unlink from its parent port
+ *
+ * Removes port reference to an rphy
+ */
+void sas_rphy_unlink(struct sas_rphy *rphy)
+{
+	struct sas_port *parent = dev_to_sas_port(rphy->dev.parent);
+
+	parent->rphy = NULL;
+}
+EXPORT_SYMBOL(sas_rphy_unlink);
+
 /**
  * sas_rphy_remove  -  remove SAS remote PHY
  * @rphy:	SAS remote phy to remove
@@ -1612,7 +1626,6 @@ void
 sas_rphy_remove(struct sas_rphy *rphy)
 {
 	struct device *dev = &rphy->dev;
-	struct sas_port *parent = dev_to_sas_port(dev->parent);
 
 	switch (rphy->identify.device_type) {
 	case SAS_END_DEVICE:
@@ -1626,10 +1639,9 @@ sas_rphy_remove(struct sas_rphy *rphy)
 		break;
 	}
 
+	sas_rphy_unlink(rphy);
 	transport_remove_device(dev);
 	device_del(dev);
-
-	parent->rphy = NULL;
 }
 EXPORT_SYMBOL(sas_rphy_remove);
 

commit 2fc62e2ac350b8f574e0a09170b350a8f2fa4a02
Author: Dan Williams <dan.j.williams@intel.com>
Date:   Tue Sep 20 15:10:19 2011 -0700

    [SCSI] libsas: disable scanning lun > 0 on ata devices
    
    Currently mvsas and pm8001 have custom ->slave_alloc implementations to
    achieve this.  Uplevel it for all libsas drivers as isci encounters problems
    with atapi devices when scanning past lun0.
    
    Just do what Darrick suggested [1], and limit the scan for ata devices.
    
    [1] http://marc.info/?l=linux-scsi&m=116604101119861&w=2
    
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>
    Signed-off-by: James Bottomley <JBottomley@Parallels.com>

diff --git a/drivers/scsi/scsi_transport_sas.c b/drivers/scsi/scsi_transport_sas.c
index c6fcf76cade5..9d9330ae4213 100644
--- a/drivers/scsi/scsi_transport_sas.c
+++ b/drivers/scsi/scsi_transport_sas.c
@@ -1545,8 +1545,14 @@ int sas_rphy_add(struct sas_rphy *rphy)
 
 	if (identify->device_type == SAS_END_DEVICE &&
 	    rphy->scsi_target_id != -1) {
-		scsi_scan_target(&rphy->dev, 0,
-				rphy->scsi_target_id, SCAN_WILD_CARD, 0);
+		int lun;
+
+		if (identify->target_port_protocols & SAS_PROTOCOL_SSP)
+			lun = SCAN_WILD_CARD;
+		else
+			lun = 0;
+
+		scsi_scan_target(&rphy->dev, 0, rphy->scsi_target_id, lun, 0);
 	}
 
 	return 0;

commit 7eaceaccab5f40bbfda044629a6298616aeaed50
Author: Jens Axboe <jaxboe@fusionio.com>
Date:   Thu Mar 10 08:52:07 2011 +0100

    block: remove per-queue plugging
    
    Code has been converted over to the new explicit on-stack plugging,
    and delay users have been converted to use the new API for that.
    So lets kill off the old plugging along with aops->sync_page().
    
    Signed-off-by: Jens Axboe <jaxboe@fusionio.com>

diff --git a/drivers/scsi/scsi_transport_sas.c b/drivers/scsi/scsi_transport_sas.c
index 927e99cb7225..c6fcf76cade5 100644
--- a/drivers/scsi/scsi_transport_sas.c
+++ b/drivers/scsi/scsi_transport_sas.c
@@ -173,11 +173,7 @@ static void sas_smp_request(struct request_queue *q, struct Scsi_Host *shost,
 	int ret;
 	int (*handler)(struct Scsi_Host *, struct sas_rphy *, struct request *);
 
-	while (!blk_queue_plugged(q)) {
-		req = blk_fetch_request(q);
-		if (!req)
-			break;
-
+	while ((req = blk_fetch_request(q)) != NULL) {
 		spin_unlock_irq(q->queue_lock);
 
 		handler = to_sas_internal(shost->transportt)->f->smp_handler;

commit 0f88009d5cfae890bd3466126d1622ad4f16b798
Author: James Bottomley <James.Bottomley@suse.de>
Date:   Mon Jan 18 10:14:51 2010 -0600

    [SCSI] scsi_transport_sas: add support for transport layer retries (TLR)
    
    The mpt2sas driver wants to use transport layer retries (TLR) so the
    simplest thing to do seems to be to add the enabling flags and checks
    to the SAS transport class, since they're a SAS specific protocol
    feature.
    
    Signed-off-by: James Bottomley <James.Bottomley@suse.de>

diff --git a/drivers/scsi/scsi_transport_sas.c b/drivers/scsi/scsi_transport_sas.c
index f27e52d963d3..927e99cb7225 100644
--- a/drivers/scsi/scsi_transport_sas.c
+++ b/drivers/scsi/scsi_transport_sas.c
@@ -155,6 +155,17 @@ static struct {
 sas_bitfield_name_search(linkspeed, sas_linkspeed_names)
 sas_bitfield_name_set(linkspeed, sas_linkspeed_names)
 
+static struct sas_end_device *sas_sdev_to_rdev(struct scsi_device *sdev)
+{
+	struct sas_rphy *rphy = target_to_rphy(sdev->sdev_target);
+	struct sas_end_device *rdev;
+
+	BUG_ON(rphy->identify.device_type != SAS_END_DEVICE);
+
+	rdev = rphy_to_end_device(rphy);
+	return rdev;
+}
+
 static void sas_smp_request(struct request_queue *q, struct Scsi_Host *shost,
 			    struct sas_rphy *rphy)
 {
@@ -358,6 +369,85 @@ void sas_remove_host(struct Scsi_Host *shost)
 }
 EXPORT_SYMBOL(sas_remove_host);
 
+/**
+ * sas_tlr_supported - checking TLR bit in vpd 0x90
+ * @sdev: scsi device struct
+ *
+ * Check Transport Layer Retries are supported or not.
+ * If vpd page 0x90 is present, TRL is supported.
+ *
+ */
+unsigned int
+sas_tlr_supported(struct scsi_device *sdev)
+{
+	const int vpd_len = 32;
+	struct sas_end_device *rdev = sas_sdev_to_rdev(sdev);
+	char *buffer = kzalloc(vpd_len, GFP_KERNEL);
+	int ret = 0;
+
+	if (scsi_get_vpd_page(sdev, 0x90, buffer, vpd_len))
+		goto out;
+
+	/*
+	 * Magic numbers: the VPD Protocol page (0x90)
+	 * has a 4 byte header and then one entry per device port
+	 * the TLR bit is at offset 8 on each port entry
+	 * if we take the first port, that's at total offset 12
+	 */
+	ret = buffer[12] & 0x01;
+
+ out:
+	kfree(buffer);
+	rdev->tlr_supported = ret;
+	return ret;
+
+}
+EXPORT_SYMBOL_GPL(sas_tlr_supported);
+
+/**
+ * sas_disable_tlr - setting TLR flags
+ * @sdev: scsi device struct
+ *
+ * Seting tlr_enabled flag to 0.
+ *
+ */
+void
+sas_disable_tlr(struct scsi_device *sdev)
+{
+	struct sas_end_device *rdev = sas_sdev_to_rdev(sdev);
+
+	rdev->tlr_enabled = 0;
+}
+EXPORT_SYMBOL_GPL(sas_disable_tlr);
+
+/**
+ * sas_enable_tlr - setting TLR flags
+ * @sdev: scsi device struct
+ *
+ * Seting tlr_enabled flag 1.
+ *
+ */
+void sas_enable_tlr(struct scsi_device *sdev)
+{
+	unsigned int tlr_supported = 0;
+	tlr_supported  = sas_tlr_supported(sdev);
+
+	if (tlr_supported) {
+		struct sas_end_device *rdev = sas_sdev_to_rdev(sdev);
+
+		rdev->tlr_enabled = 1;
+	}
+
+	return;
+}
+EXPORT_SYMBOL_GPL(sas_enable_tlr);
+
+unsigned int sas_is_tlr_enabled(struct scsi_device *sdev)
+{
+	struct sas_end_device *rdev = sas_sdev_to_rdev(sdev);
+	return rdev->tlr_enabled;
+}
+EXPORT_SYMBOL_GPL(sas_is_tlr_enabled);
 
 /*
  * SAS Phy attributes
@@ -1146,15 +1236,10 @@ sas_rphy_simple_attr(identify.phy_identifier, phy_identifier, "%d\n", u8);
 int sas_read_port_mode_page(struct scsi_device *sdev)
 {
 	char *buffer = kzalloc(BUF_SIZE, GFP_KERNEL), *msdata;
-	struct sas_rphy *rphy = target_to_rphy(sdev->sdev_target);
-	struct sas_end_device *rdev;
+	struct sas_end_device *rdev = sas_sdev_to_rdev(sdev);
 	struct scsi_mode_data mode_data;
 	int res, error;
 
-	BUG_ON(rphy->identify.device_type != SAS_END_DEVICE);
-
-	rdev = rphy_to_end_device(rphy);
-
 	if (!buffer)
 		return -ENOMEM;
 
@@ -1207,6 +1292,10 @@ sas_end_dev_simple_attr(I_T_nexus_loss_timeout, I_T_nexus_loss_timeout,
 			"%d\n", int);
 sas_end_dev_simple_attr(initiator_response_timeout, initiator_response_timeout,
 			"%d\n", int);
+sas_end_dev_simple_attr(tlr_supported, tlr_supported,
+			"%d\n", int);
+sas_end_dev_simple_attr(tlr_enabled, tlr_enabled,
+			"%d\n", int);
 
 static DECLARE_TRANSPORT_CLASS(sas_expander_class,
 			       "sas_expander", NULL, NULL, NULL);
@@ -1733,6 +1822,8 @@ sas_attach_transport(struct sas_function_template *ft)
 	SETUP_END_DEV_ATTRIBUTE(end_dev_ready_led_meaning);
 	SETUP_END_DEV_ATTRIBUTE(end_dev_I_T_nexus_loss_timeout);
 	SETUP_END_DEV_ATTRIBUTE(end_dev_initiator_response_timeout);
+	SETUP_END_DEV_ATTRIBUTE(end_dev_tlr_supported);
+	SETUP_END_DEV_ATTRIBUTE(end_dev_tlr_enabled);
 	i->end_dev_attrs[count] = NULL;
 
 	count = 0;

commit af901ca181d92aac3a7dc265144a9081a86d8f39
Author: André Goddard Rosa <andre.goddard@gmail.com>
Date:   Sat Nov 14 13:09:05 2009 -0200

    tree-wide: fix assorted typos all over the place
    
    That is "success", "unknown", "through", "performance", "[re|un]mapping"
    , "access", "default", "reasonable", "[con]currently", "temperature"
    , "channel", "[un]used", "application", "example","hierarchy", "therefore"
    , "[over|under]flow", "contiguous", "threshold", "enough" and others.
    
    Signed-off-by: André Goddard Rosa <andre.goddard@gmail.com>
    Signed-off-by: Jiri Kosina <jkosina@suse.cz>

diff --git a/drivers/scsi/scsi_transport_sas.c b/drivers/scsi/scsi_transport_sas.c
index fd47cb1bee1b..f27e52d963d3 100644
--- a/drivers/scsi/scsi_transport_sas.c
+++ b/drivers/scsi/scsi_transport_sas.c
@@ -666,7 +666,7 @@ EXPORT_SYMBOL(sas_phy_add);
  *
  * Note:
  *   This function must only be called on a PHY that has not
- *   sucessfully been added using sas_phy_add().
+ *   successfully been added using sas_phy_add().
  */
 void sas_phy_free(struct sas_phy *phy)
 {
@@ -896,7 +896,7 @@ EXPORT_SYMBOL(sas_port_add);
  *
  * Note:
  *   This function must only be called on a PORT that has not
- *   sucessfully been added using sas_port_add().
+ *   successfully been added using sas_port_add().
  */
 void sas_port_free(struct sas_port *port)
 {
@@ -1476,7 +1476,7 @@ EXPORT_SYMBOL(sas_rphy_add);
  *
  * Note:
  *   This function must only be called on a remote
- *   PHY that has not sucessfully been added using
+ *   PHY that has not successfully been added using
  *   sas_rphy_add() (or has been sas_rphy_remove()'d)
  */
 void sas_rphy_free(struct sas_rphy *rphy)

commit a4a8b064dd06d30d007e46445d17575e2875c340
Author: James Bottomley <James.Bottomley@HansenPartnership.com>
Date:   Tue Jul 28 16:39:05 2009 +0000

    [SCSI] scsi_transport_sas: fix incorrect duplicate setup of max_phys
    
    There are two setup places for max_phys in scsi_transport_sas.c; one
    incorrectly places a NULL into host_attrs instead of port_attrs.  Remove it.
    
    Reported-by: Roel Kluin <roel.kluin@gmail.com>
    Signed-off-by: James Bottomley <James.Bottomley@HansenPartnership.com>
    Signed-off-by: James Bottomley <James.Bottomley@suse.de>

diff --git a/drivers/scsi/scsi_transport_sas.c b/drivers/scsi/scsi_transport_sas.c
index 0895d3c71b03..fd47cb1bee1b 100644
--- a/drivers/scsi/scsi_transport_sas.c
+++ b/drivers/scsi/scsi_transport_sas.c
@@ -1691,10 +1691,6 @@ sas_attach_transport(struct sas_function_template *ft)
 
 	i->f = ft;
 
-	count = 0;
-	SETUP_PORT_ATTRIBUTE(num_phys);
-	i->host_attrs[count] = NULL;
-
 	count = 0;
 	SETUP_PHY_ATTRIBUTE(initiator_port_protocols);
 	SETUP_PHY_ATTRIBUTE(target_port_protocols);

commit 93bdcba5a7e55307e27671594c3cd8b4669b9e7a
Author: FUJITA Tomonori <fujita.tomonori@lab.ntt.co.jp>
Date:   Wed Jun 17 15:10:10 2009 +0900

    scsi_transport_sas: needs to call blk_end_request_all for SMP requests
    
    We need to call blk_end_request_all to complete SMP requests properly.
    
    Signed-off-by: FUJITA Tomonori <fujita.tomonori@lab.ntt.co.jp>
    Signed-off-by: James Bottomley <James.Bottomley@HansenPartnership.com>

diff --git a/drivers/scsi/scsi_transport_sas.c b/drivers/scsi/scsi_transport_sas.c
index d606452297cf..0895d3c71b03 100644
--- a/drivers/scsi/scsi_transport_sas.c
+++ b/drivers/scsi/scsi_transport_sas.c
@@ -173,9 +173,9 @@ static void sas_smp_request(struct request_queue *q, struct Scsi_Host *shost,
 		ret = handler(shost, rphy, req);
 		req->errors = ret;
 
-		spin_lock_irq(q->queue_lock);
+		blk_end_request_all(req, ret);
 
-		req->end_io(req, ret);
+		spin_lock_irq(q->queue_lock);
 	}
 }
 

commit 9934c8c04561413609d2bc38c6b9f268cba774a4
Author: Tejun Heo <tj@kernel.org>
Date:   Fri May 8 11:54:16 2009 +0900

    block: implement and enforce request peek/start/fetch
    
    Till now block layer allowed two separate modes of request execution.
    A request is always acquired from the request queue via
    elv_next_request().  After that, drivers are free to either dequeue it
    or process it without dequeueing.  Dequeue allows elv_next_request()
    to return the next request so that multiple requests can be in flight.
    
    Executing requests without dequeueing has its merits mostly in
    allowing drivers for simpler devices which can't do sg to deal with
    segments only without considering request boundary.  However, the
    benefit this brings is dubious and declining while the cost of the API
    ambiguity is increasing.  Segment based drivers are usually for very
    old or limited devices and as converting to dequeueing model isn't
    difficult, it doesn't justify the API overhead it puts on block layer
    and its more modern users.
    
    Previous patches converted all block low level drivers to dequeueing
    model.  This patch completes the API transition by...
    
    * renaming elv_next_request() to blk_peek_request()
    
    * renaming blkdev_dequeue_request() to blk_start_request()
    
    * adding blk_fetch_request() which is combination of peek and start
    
    * disallowing completion of queued (not started) requests
    
    * applying new API to all LLDs
    
    Renamings are for consistency and to break out of tree code so that
    it's apparent that out of tree drivers need updating.
    
    [ Impact: block request issue API cleanup, no functional change ]
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Cc: Rusty Russell <rusty@rustcorp.com.au>
    Cc: James Bottomley <James.Bottomley@HansenPartnership.com>
    Cc: Mike Miller <mike.miller@hp.com>
    Cc: unsik Kim <donari75@gmail.com>
    Cc: Paul Clements <paul.clements@steeleye.com>
    Cc: Tim Waugh <tim@cyberelk.net>
    Cc: Geert Uytterhoeven <Geert.Uytterhoeven@sonycom.com>
    Cc: David S. Miller <davem@davemloft.net>
    Cc: Laurent Vivier <Laurent@lvivier.info>
    Cc: Jeff Garzik <jgarzik@pobox.com>
    Cc: Jeremy Fitzhardinge <jeremy@xensource.com>
    Cc: Grant Likely <grant.likely@secretlab.ca>
    Cc: Adrian McMenamin <adrian@mcmen.demon.co.uk>
    Cc: Stephen Rothwell <sfr@canb.auug.org.au>
    Cc: Bartlomiej Zolnierkiewicz <bzolnier@gmail.com>
    Cc: Borislav Petkov <petkovbb@googlemail.com>
    Cc: Sergei Shtylyov <sshtylyov@ru.mvista.com>
    Cc: Alex Dubov <oakad@yahoo.com>
    Cc: Pierre Ossman <drzeus@drzeus.cx>
    Cc: David Woodhouse <dwmw2@infradead.org>
    Cc: Markus Lidel <Markus.Lidel@shadowconnect.com>
    Cc: Stefan Weinhuber <wein@de.ibm.com>
    Cc: Martin Schwidefsky <schwidefsky@de.ibm.com>
    Cc: Pete Zaitcev <zaitcev@redhat.com>
    Cc: FUJITA Tomonori <fujita.tomonori@lab.ntt.co.jp>
    Signed-off-by: Jens Axboe <jens.axboe@oracle.com>

diff --git a/drivers/scsi/scsi_transport_sas.c b/drivers/scsi/scsi_transport_sas.c
index 50988cbf7b2d..d606452297cf 100644
--- a/drivers/scsi/scsi_transport_sas.c
+++ b/drivers/scsi/scsi_transport_sas.c
@@ -163,12 +163,10 @@ static void sas_smp_request(struct request_queue *q, struct Scsi_Host *shost,
 	int (*handler)(struct Scsi_Host *, struct sas_rphy *, struct request *);
 
 	while (!blk_queue_plugged(q)) {
-		req = elv_next_request(q);
+		req = blk_fetch_request(q);
 		if (!req)
 			break;
 
-		blkdev_dequeue_request(req);
-
 		spin_unlock_irq(q->queue_lock);
 
 		handler = to_sas_internal(shost->transportt)->f->smp_handler;

commit 71610f55fa4db63dbf5385929a47c9fb2451f332
Author: Kay Sievers <kay.sievers@vrfy.org>
Date:   Wed Dec 3 22:41:36 2008 +0100

    [SCSI] struct device - replace bus_id with dev_name(), dev_set_name()
    
    [jejb: limit ioctl to returning 20 characters to avoid overrun
           on long device names and add a few more conversions]
    Signed-off-by: Kay Sievers <kay.sievers@vrfy.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>
    Signed-off-by: James Bottomley <James.Bottomley@HansenPartnership.com>

diff --git a/drivers/scsi/scsi_transport_sas.c b/drivers/scsi/scsi_transport_sas.c
index 366609386be1..50988cbf7b2d 100644
--- a/drivers/scsi/scsi_transport_sas.c
+++ b/drivers/scsi/scsi_transport_sas.c
@@ -207,7 +207,7 @@ static int sas_bsg_initialize(struct Scsi_Host *shost, struct sas_rphy *rphy)
 	struct request_queue *q;
 	int error;
 	struct device *dev;
-	char namebuf[BUS_ID_SIZE];
+	char namebuf[20];
 	const char *name;
 	void (*release)(struct device *);
 
@@ -219,7 +219,7 @@ static int sas_bsg_initialize(struct Scsi_Host *shost, struct sas_rphy *rphy)
 	if (rphy) {
 		q = blk_init_queue(sas_non_host_smp_request, NULL);
 		dev = &rphy->dev;
-		name = dev->bus_id;
+		name = dev_name(dev);
 		release = NULL;
 	} else {
 		q = blk_init_queue(sas_host_smp_request, NULL);
@@ -629,10 +629,10 @@ struct sas_phy *sas_phy_alloc(struct device *parent, int number)
 	INIT_LIST_HEAD(&phy->port_siblings);
 	if (scsi_is_sas_expander_device(parent)) {
 		struct sas_rphy *rphy = dev_to_rphy(parent);
-		sprintf(phy->dev.bus_id, "phy-%d:%d:%d", shost->host_no,
+		dev_set_name(&phy->dev, "phy-%d:%d:%d", shost->host_no,
 			rphy->scsi_target_id, number);
 	} else
-		sprintf(phy->dev.bus_id, "phy-%d:%d", shost->host_no, number);
+		dev_set_name(&phy->dev, "phy-%d:%d", shost->host_no, number);
 
 	transport_setup_device(&phy->dev);
 
@@ -770,7 +770,7 @@ static void sas_port_create_link(struct sas_port *port,
 	int res;
 
 	res = sysfs_create_link(&port->dev.kobj, &phy->dev.kobj,
-				phy->dev.bus_id);
+				dev_name(&phy->dev));
 	if (res)
 		goto err;
 	res = sysfs_create_link(&phy->dev.kobj, &port->dev.kobj, "port");
@@ -785,7 +785,7 @@ static void sas_port_create_link(struct sas_port *port,
 static void sas_port_delete_link(struct sas_port *port,
 				 struct sas_phy *phy)
 {
-	sysfs_remove_link(&port->dev.kobj, phy->dev.bus_id);
+	sysfs_remove_link(&port->dev.kobj, dev_name(&phy->dev));
 	sysfs_remove_link(&phy->dev.kobj, "port");
 }
 
@@ -821,11 +821,11 @@ struct sas_port *sas_port_alloc(struct device *parent, int port_id)
 
 	if (scsi_is_sas_expander_device(parent)) {
 		struct sas_rphy *rphy = dev_to_rphy(parent);
-		sprintf(port->dev.bus_id, "port-%d:%d:%d", shost->host_no,
-			rphy->scsi_target_id, port->port_identifier);
+		dev_set_name(&port->dev, "port-%d:%d:%d", shost->host_no,
+			     rphy->scsi_target_id, port->port_identifier);
 	} else
-		sprintf(port->dev.bus_id, "port-%d:%d", shost->host_no,
-			port->port_identifier);
+		dev_set_name(&port->dev, "port-%d:%d", shost->host_no,
+			     port->port_identifier);
 
 	transport_setup_device(&port->dev);
 
@@ -935,7 +935,7 @@ void sas_port_delete(struct sas_port *port)
 	if (port->is_backlink) {
 		struct device *parent = port->dev.parent;
 
-		sysfs_remove_link(&port->dev.kobj, parent->bus_id);
+		sysfs_remove_link(&port->dev.kobj, dev_name(parent));
 		port->is_backlink = 0;
 	}
 
@@ -984,7 +984,8 @@ void sas_port_add_phy(struct sas_port *port, struct sas_phy *phy)
 		/* If this trips, you added a phy that was already
 		 * part of a different port */
 		if (unlikely(tmp != phy)) {
-			dev_printk(KERN_ERR, &port->dev, "trying to add phy %s fails: it's already part of another port\n", phy->dev.bus_id);
+			dev_printk(KERN_ERR, &port->dev, "trying to add phy %s fails: it's already part of another port\n",
+				   dev_name(&phy->dev));
 			BUG();
 		}
 	} else {
@@ -1023,7 +1024,7 @@ void sas_port_mark_backlink(struct sas_port *port)
 		return;
 	port->is_backlink = 1;
 	res = sysfs_create_link(&port->dev.kobj, &parent->kobj,
-				parent->bus_id);
+				dev_name(parent));
 	if (res)
 		goto err;
 	return;
@@ -1367,11 +1368,12 @@ struct sas_rphy *sas_end_device_alloc(struct sas_port *parent)
 	rdev->rphy.dev.release = sas_end_device_release;
 	if (scsi_is_sas_expander_device(parent->dev.parent)) {
 		struct sas_rphy *rphy = dev_to_rphy(parent->dev.parent);
-		sprintf(rdev->rphy.dev.bus_id, "end_device-%d:%d:%d",
-			shost->host_no, rphy->scsi_target_id, parent->port_identifier);
+		dev_set_name(&rdev->rphy.dev, "end_device-%d:%d:%d",
+			     shost->host_no, rphy->scsi_target_id,
+			     parent->port_identifier);
 	} else
-		sprintf(rdev->rphy.dev.bus_id, "end_device-%d:%d",
-			shost->host_no, parent->port_identifier);
+		dev_set_name(&rdev->rphy.dev, "end_device-%d:%d",
+			     shost->host_no, parent->port_identifier);
 	rdev->rphy.identify.device_type = SAS_END_DEVICE;
 	sas_rphy_initialize(&rdev->rphy);
 	transport_setup_device(&rdev->rphy.dev);
@@ -1411,8 +1413,8 @@ struct sas_rphy *sas_expander_alloc(struct sas_port *parent,
 	mutex_lock(&sas_host->lock);
 	rdev->rphy.scsi_target_id = sas_host->next_expander_id++;
 	mutex_unlock(&sas_host->lock);
-	sprintf(rdev->rphy.dev.bus_id, "expander-%d:%d",
-		shost->host_no, rdev->rphy.scsi_target_id);
+	dev_set_name(&rdev->rphy.dev, "expander-%d:%d",
+		     shost->host_no, rdev->rphy.scsi_target_id);
 	rdev->rphy.identify.device_type = type;
 	sas_rphy_initialize(&rdev->rphy);
 	transport_setup_device(&rdev->rphy.dev);
@@ -1445,7 +1447,7 @@ int sas_rphy_add(struct sas_rphy *rphy)
 	transport_add_device(&rphy->dev);
 	transport_configure_device(&rphy->dev);
 	if (sas_bsg_initialize(shost, rphy))
-		printk("fail to a bsg device %s\n", rphy->dev.bus_id);
+		printk("fail to a bsg device %s\n", dev_name(&rphy->dev));
 
 
 	mutex_lock(&sas_host->lock);

commit cadbd4a5e36dde7e6c49b587b2c419103c0b7218
Author: Harvey Harrison <harvey.harrison@gmail.com>
Date:   Thu Jul 3 23:47:27 2008 -0700

    [SCSI] replace __FUNCTION__ with __func__
    
    [jejb: fixed up a ton of missed conversions.
    
     All of you are on notice this has happened, driver trees will now
     need to be rebased]
    
    Signed-off-by: Harvey Harrison <harvey.harrison@gmail.com>
    Cc: SCSI List <linux-scsi@vger.kernel.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: James Bottomley <James.Bottomley@HansenPartnership.com>

diff --git a/drivers/scsi/scsi_transport_sas.c b/drivers/scsi/scsi_transport_sas.c
index f4461d35ffb9..366609386be1 100644
--- a/drivers/scsi/scsi_transport_sas.c
+++ b/drivers/scsi/scsi_transport_sas.c
@@ -779,7 +779,7 @@ static void sas_port_create_link(struct sas_port *port,
 	return;
 err:
 	printk(KERN_ERR "%s: Cannot create port links, err=%d\n",
-	       __FUNCTION__, res);
+	       __func__, res);
 }
 
 static void sas_port_delete_link(struct sas_port *port,
@@ -1029,7 +1029,7 @@ void sas_port_mark_backlink(struct sas_port *port)
 	return;
 err:
 	printk(KERN_ERR "%s: Cannot create port backlink, err=%d\n",
-	       __FUNCTION__, res);
+	       __func__, res);
 
 }
 EXPORT_SYMBOL(sas_port_mark_backlink);

commit 75ad23bc0fcb4f992a5d06982bf0857ab1738e9e
Author: Nick Piggin <npiggin@suse.de>
Date:   Tue Apr 29 14:48:33 2008 +0200

    block: make queue flags non-atomic
    
    We can save some atomic ops in the IO path, if we clearly define
    the rules of how to modify the queue flags.
    
    Signed-off-by: Jens Axboe <jens.axboe@oracle.com>

diff --git a/drivers/scsi/scsi_transport_sas.c b/drivers/scsi/scsi_transport_sas.c
index 7899e3dda9bf..f4461d35ffb9 100644
--- a/drivers/scsi/scsi_transport_sas.c
+++ b/drivers/scsi/scsi_transport_sas.c
@@ -248,8 +248,7 @@ static int sas_bsg_initialize(struct Scsi_Host *shost, struct sas_rphy *rphy)
 	else
 		q->queuedata = shost;
 
-	set_bit(QUEUE_FLAG_BIDI, &q->queue_flags);
-
+	queue_flag_set_unlocked(QUEUE_FLAG_BIDI, q);
 	return 0;
 }
 

commit 93c20a59af4624aedf53f8320606b355aa951bc1
Author: FUJITA Tomonori <fujita.tomonori@lab.ntt.co.jp>
Date:   Sat Apr 19 00:43:15 2008 +0900

    [SCSI] scsi_transport_sas: fix the lifetime of sas bsg objects
    
    scsi_transport_sas calls blk_cleanup_queue too early for bsg
    queues. If a user holds a sas_host, end_device, or expander device
    open, remove the device, then send a request to it, we get a kernel
    crash. We need to call blk_cleanup_queue in the release callback as we
    do with scsi devices.
    
    This patch moves blk_cleanup_queue to sas_expander_release and
    sas_end_device_release from sas_bsg_remove. sas_host can't use the
    release callback in struct device so use bsg's release callback.
    
    Signed-off-by: FUJITA Tomonori <fujita.tomonori@lab.ntt.co.jp>
    Signed-off-by: James Bottomley <James.Bottomley@HansenPartnership.com>

diff --git a/drivers/scsi/scsi_transport_sas.c b/drivers/scsi/scsi_transport_sas.c
index 94ff29f7c34b..7899e3dda9bf 100644
--- a/drivers/scsi/scsi_transport_sas.c
+++ b/drivers/scsi/scsi_transport_sas.c
@@ -192,6 +192,16 @@ static void sas_non_host_smp_request(struct request_queue *q)
 	sas_smp_request(q, rphy_to_shost(rphy), rphy);
 }
 
+static void sas_host_release(struct device *dev)
+{
+	struct Scsi_Host *shost = dev_to_shost(dev);
+	struct sas_host_attrs *sas_host = to_sas_host_attrs(shost);
+	struct request_queue *q = sas_host->q;
+
+	if (q)
+		blk_cleanup_queue(q);
+}
+
 static int sas_bsg_initialize(struct Scsi_Host *shost, struct sas_rphy *rphy)
 {
 	struct request_queue *q;
@@ -199,6 +209,7 @@ static int sas_bsg_initialize(struct Scsi_Host *shost, struct sas_rphy *rphy)
 	struct device *dev;
 	char namebuf[BUS_ID_SIZE];
 	const char *name;
+	void (*release)(struct device *);
 
 	if (!to_sas_internal(shost->transportt)->f->smp_handler) {
 		printk("%s can't handle SMP requests\n", shost->hostt->name);
@@ -209,17 +220,19 @@ static int sas_bsg_initialize(struct Scsi_Host *shost, struct sas_rphy *rphy)
 		q = blk_init_queue(sas_non_host_smp_request, NULL);
 		dev = &rphy->dev;
 		name = dev->bus_id;
+		release = NULL;
 	} else {
 		q = blk_init_queue(sas_host_smp_request, NULL);
 		dev = &shost->shost_gendev;
 		snprintf(namebuf, sizeof(namebuf),
 			 "sas_host%d", shost->host_no);
 		name = namebuf;
+		release = sas_host_release;
 	}
 	if (!q)
 		return -ENOMEM;
 
-	error = bsg_register_queue(q, dev, name, NULL);
+	error = bsg_register_queue(q, dev, name, release);
 	if (error) {
 		blk_cleanup_queue(q);
 		return -ENOMEM;
@@ -253,7 +266,6 @@ static void sas_bsg_remove(struct Scsi_Host *shost, struct sas_rphy *rphy)
 		return;
 
 	bsg_unregister_queue(q);
-	blk_cleanup_queue(q);
 }
 
 /*
@@ -1301,6 +1313,9 @@ static void sas_expander_release(struct device *dev)
 	struct sas_rphy *rphy = dev_to_rphy(dev);
 	struct sas_expander_device *edev = rphy_to_expander_device(rphy);
 
+	if (rphy->q)
+		blk_cleanup_queue(rphy->q);
+
 	put_device(dev->parent);
 	kfree(edev);
 }
@@ -1310,6 +1325,9 @@ static void sas_end_device_release(struct device *dev)
 	struct sas_rphy *rphy = dev_to_rphy(dev);
 	struct sas_end_device *edev = rphy_to_end_device(rphy);
 
+	if (rphy->q)
+		blk_cleanup_queue(rphy->q);
+
 	put_device(dev->parent);
 	kfree(edev);
 }

commit 97f46ae45c70857e459b7f8df1fc2807e7bd90a9
Author: FUJITA Tomonori <fujita.tomonori@lab.ntt.co.jp>
Date:   Sat Apr 19 00:43:14 2008 +0900

    [SCSI] bsg: add release callback support
    
    This patch adds release callback support, which is called when a bsg
    device goes away. bsg_register_queue() takes a pointer to a callback
    function. This feature is useful for stuff like sas_host that can't
    use the release callback in struct device.
    
    If a caller doesn't need bsg's release callback, it can call
    bsg_register_queue() with NULL pointer (e.g. scsi devices can use
    release callback in struct device so they don't need bsg's callback).
    
    With this patch, bsg uses kref for refcounts on bsg devices instead of
    get/put_device in fops->open/release. bsg calls put_device and the
    caller's release callback (if it was registered) in kref_put's
    release.
    
    Signed-off-by: FUJITA Tomonori <fujita.tomonori@lab.ntt.co.jp>
    Signed-off-by: James Bottomley <James.Bottomley@HansenPartnership.com>

diff --git a/drivers/scsi/scsi_transport_sas.c b/drivers/scsi/scsi_transport_sas.c
index 27ec625ab771..94ff29f7c34b 100644
--- a/drivers/scsi/scsi_transport_sas.c
+++ b/drivers/scsi/scsi_transport_sas.c
@@ -219,7 +219,7 @@ static int sas_bsg_initialize(struct Scsi_Host *shost, struct sas_rphy *rphy)
 	if (!q)
 		return -ENOMEM;
 
-	error = bsg_register_queue(q, dev, name);
+	error = bsg_register_queue(q, dev, name, NULL);
 	if (error) {
 		blk_cleanup_queue(q);
 		return -ENOMEM;

commit ee959b00c335d7780136c5abda37809191fe52c3
Author: Tony Jones <tonyj@suse.de>
Date:   Fri Feb 22 00:13:36 2008 +0100

    SCSI: convert struct class_device to struct device
    
    It's big, but there doesn't seem to be a way to split it up smaller...
    
    Signed-off-by: Tony Jones <tonyj@suse.de>
    Signed-off-by: Kay Sievers <kay.sievers@vrfy.org>
    Cc: Roland Dreier <rolandd@cisco.com>
    Cc: Sean Hefty <sean.hefty@intel.com>
    Cc: Hal Rosenstock <hal.rosenstock@gmail.com>
    Cc: James Bottomley <James.Bottomley@HansenPartnership.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/scsi/scsi_transport_sas.c b/drivers/scsi/scsi_transport_sas.c
index 43a964d635b4..27ec625ab771 100644
--- a/drivers/scsi/scsi_transport_sas.c
+++ b/drivers/scsi/scsi_transport_sas.c
@@ -53,8 +53,8 @@ struct sas_host_attrs {
 /*
  * Hack to allow attributes of the same name in different objects.
  */
-#define SAS_CLASS_DEVICE_ATTR(_prefix,_name,_mode,_show,_store) \
-	struct class_device_attribute class_device_attr_##_prefix##_##_name = \
+#define SAS_DEVICE_ATTR(_prefix,_name,_mode,_show,_store) \
+	struct device_attribute dev_attr_##_prefix##_##_name = \
 	__ATTR(_name,_mode,_show,_store)
 
 
@@ -261,7 +261,7 @@ static void sas_bsg_remove(struct Scsi_Host *shost, struct sas_rphy *rphy)
  */
 
 static int sas_host_setup(struct transport_container *tc, struct device *dev,
-			  struct class_device *cdev)
+			  struct device *cdev)
 {
 	struct Scsi_Host *shost = dev_to_shost(dev);
 	struct sas_host_attrs *sas_host = to_sas_host_attrs(shost);
@@ -280,7 +280,7 @@ static int sas_host_setup(struct transport_container *tc, struct device *dev,
 }
 
 static int sas_host_remove(struct transport_container *tc, struct device *dev,
-			   struct class_device *cdev)
+			   struct device *cdev)
 {
 	struct Scsi_Host *shost = dev_to_shost(dev);
 
@@ -356,22 +356,24 @@ EXPORT_SYMBOL(sas_remove_host);
 
 #define sas_phy_show_simple(field, name, format_string, cast)		\
 static ssize_t								\
-show_sas_phy_##name(struct class_device *cdev, char *buf)		\
+show_sas_phy_##name(struct device *dev, 				\
+		    struct device_attribute *attr, char *buf)		\
 {									\
-	struct sas_phy *phy = transport_class_to_phy(cdev);		\
+	struct sas_phy *phy = transport_class_to_phy(dev);		\
 									\
 	return snprintf(buf, 20, format_string, cast phy->field);	\
 }
 
 #define sas_phy_simple_attr(field, name, format_string, type)		\
 	sas_phy_show_simple(field, name, format_string, (type))	\
-static CLASS_DEVICE_ATTR(name, S_IRUGO, show_sas_phy_##name, NULL)
+static DEVICE_ATTR(name, S_IRUGO, show_sas_phy_##name, NULL)
 
 #define sas_phy_show_protocol(field, name)				\
 static ssize_t								\
-show_sas_phy_##name(struct class_device *cdev, char *buf)		\
+show_sas_phy_##name(struct device *dev, 				\
+		    struct device_attribute *attr, char *buf)		\
 {									\
-	struct sas_phy *phy = transport_class_to_phy(cdev);		\
+	struct sas_phy *phy = transport_class_to_phy(dev);		\
 									\
 	if (!phy->field)						\
 		return snprintf(buf, 20, "none\n");			\
@@ -380,13 +382,14 @@ show_sas_phy_##name(struct class_device *cdev, char *buf)		\
 
 #define sas_phy_protocol_attr(field, name)				\
 	sas_phy_show_protocol(field, name)				\
-static CLASS_DEVICE_ATTR(name, S_IRUGO, show_sas_phy_##name, NULL)
+static DEVICE_ATTR(name, S_IRUGO, show_sas_phy_##name, NULL)
 
 #define sas_phy_show_linkspeed(field)					\
 static ssize_t								\
-show_sas_phy_##field(struct class_device *cdev, char *buf)		\
+show_sas_phy_##field(struct device *dev, 				\
+		     struct device_attribute *attr, char *buf)		\
 {									\
-	struct sas_phy *phy = transport_class_to_phy(cdev);		\
+	struct sas_phy *phy = transport_class_to_phy(dev);		\
 									\
 	return get_sas_linkspeed_names(phy->field, buf);		\
 }
@@ -394,10 +397,11 @@ show_sas_phy_##field(struct class_device *cdev, char *buf)		\
 /* Fudge to tell if we're minimum or maximum */
 #define sas_phy_store_linkspeed(field)					\
 static ssize_t								\
-store_sas_phy_##field(struct class_device *cdev, const char *buf,	\
-		      size_t count)					\
+store_sas_phy_##field(struct device *dev, 				\
+		      struct device_attribute *attr, 			\
+		      const char *buf,	size_t count)			\
 {									\
-	struct sas_phy *phy = transport_class_to_phy(cdev);		\
+	struct sas_phy *phy = transport_class_to_phy(dev);		\
 	struct Scsi_Host *shost = dev_to_shost(phy->dev.parent);	\
 	struct sas_internal *i = to_sas_internal(shost->transportt);	\
 	u32 value;							\
@@ -416,19 +420,20 @@ store_sas_phy_##field(struct class_device *cdev, const char *buf,	\
 #define sas_phy_linkspeed_rw_attr(field)				\
 	sas_phy_show_linkspeed(field)					\
 	sas_phy_store_linkspeed(field)					\
-static CLASS_DEVICE_ATTR(field, S_IRUGO, show_sas_phy_##field,		\
+static DEVICE_ATTR(field, S_IRUGO, show_sas_phy_##field,		\
 	store_sas_phy_##field)
 
 #define sas_phy_linkspeed_attr(field)					\
 	sas_phy_show_linkspeed(field)					\
-static CLASS_DEVICE_ATTR(field, S_IRUGO, show_sas_phy_##field, NULL)
+static DEVICE_ATTR(field, S_IRUGO, show_sas_phy_##field, NULL)
 
 
 #define sas_phy_show_linkerror(field)					\
 static ssize_t								\
-show_sas_phy_##field(struct class_device *cdev, char *buf)		\
+show_sas_phy_##field(struct device *dev, 				\
+		     struct device_attribute *attr, char *buf)		\
 {									\
-	struct sas_phy *phy = transport_class_to_phy(cdev);		\
+	struct sas_phy *phy = transport_class_to_phy(dev);		\
 	struct Scsi_Host *shost = dev_to_shost(phy->dev.parent);	\
 	struct sas_internal *i = to_sas_internal(shost->transportt);	\
 	int error;							\
@@ -441,24 +446,25 @@ show_sas_phy_##field(struct class_device *cdev, char *buf)		\
 
 #define sas_phy_linkerror_attr(field)					\
 	sas_phy_show_linkerror(field)					\
-static CLASS_DEVICE_ATTR(field, S_IRUGO, show_sas_phy_##field, NULL)
+static DEVICE_ATTR(field, S_IRUGO, show_sas_phy_##field, NULL)
 
 
 static ssize_t
-show_sas_device_type(struct class_device *cdev, char *buf)
+show_sas_device_type(struct device *dev,
+		     struct device_attribute *attr, char *buf)
 {
-	struct sas_phy *phy = transport_class_to_phy(cdev);
+	struct sas_phy *phy = transport_class_to_phy(dev);
 
 	if (!phy->identify.device_type)
 		return snprintf(buf, 20, "none\n");
 	return get_sas_device_type_names(phy->identify.device_type, buf);
 }
-static CLASS_DEVICE_ATTR(device_type, S_IRUGO, show_sas_device_type, NULL);
+static DEVICE_ATTR(device_type, S_IRUGO, show_sas_device_type, NULL);
 
-static ssize_t do_sas_phy_enable(struct class_device *cdev,
+static ssize_t do_sas_phy_enable(struct device *dev,
 		size_t count, int enable)
 {
-	struct sas_phy *phy = transport_class_to_phy(cdev);
+	struct sas_phy *phy = transport_class_to_phy(dev);
 	struct Scsi_Host *shost = dev_to_shost(phy->dev.parent);
 	struct sas_internal *i = to_sas_internal(shost->transportt);
 	int error;
@@ -470,18 +476,19 @@ static ssize_t do_sas_phy_enable(struct class_device *cdev,
 	return count;
 };
 
-static ssize_t store_sas_phy_enable(struct class_device *cdev,
-		const char *buf, size_t count)
+static ssize_t
+store_sas_phy_enable(struct device *dev, struct device_attribute *attr,
+		     const char *buf, size_t count)
 {
 	if (count < 1)
 		return -EINVAL;
 
 	switch (buf[0]) {
 	case '0':
-		do_sas_phy_enable(cdev, count, 0);
+		do_sas_phy_enable(dev, count, 0);
 		break;
 	case '1':
-		do_sas_phy_enable(cdev, count, 1);
+		do_sas_phy_enable(dev, count, 1);
 		break;
 	default:
 		return -EINVAL;
@@ -490,20 +497,22 @@ static ssize_t store_sas_phy_enable(struct class_device *cdev,
 	return count;
 }
 
-static ssize_t show_sas_phy_enable(struct class_device *cdev, char *buf)
+static ssize_t
+show_sas_phy_enable(struct device *dev, struct device_attribute *attr,
+		    char *buf)
 {
-	struct sas_phy *phy = transport_class_to_phy(cdev);
+	struct sas_phy *phy = transport_class_to_phy(dev);
 
 	return snprintf(buf, 20, "%d", phy->enabled);
 }
 
-static CLASS_DEVICE_ATTR(enable, S_IRUGO | S_IWUSR, show_sas_phy_enable,
+static DEVICE_ATTR(enable, S_IRUGO | S_IWUSR, show_sas_phy_enable,
 			 store_sas_phy_enable);
 
-static ssize_t do_sas_phy_reset(struct class_device *cdev,
-		size_t count, int hard_reset)
+static ssize_t
+do_sas_phy_reset(struct device *dev, size_t count, int hard_reset)
 {
-	struct sas_phy *phy = transport_class_to_phy(cdev);
+	struct sas_phy *phy = transport_class_to_phy(dev);
 	struct Scsi_Host *shost = dev_to_shost(phy->dev.parent);
 	struct sas_internal *i = to_sas_internal(shost->transportt);
 	int error;
@@ -514,19 +523,21 @@ static ssize_t do_sas_phy_reset(struct class_device *cdev,
 	return count;
 };
 
-static ssize_t store_sas_link_reset(struct class_device *cdev,
-		const char *buf, size_t count)
+static ssize_t
+store_sas_link_reset(struct device *dev, struct device_attribute *attr,
+		     const char *buf, size_t count)
 {
-	return do_sas_phy_reset(cdev, count, 0);
+	return do_sas_phy_reset(dev, count, 0);
 }
-static CLASS_DEVICE_ATTR(link_reset, S_IWUSR, NULL, store_sas_link_reset);
+static DEVICE_ATTR(link_reset, S_IWUSR, NULL, store_sas_link_reset);
 
-static ssize_t store_sas_hard_reset(struct class_device *cdev,
-		const char *buf, size_t count)
+static ssize_t
+store_sas_hard_reset(struct device *dev, struct device_attribute *attr,
+		     const char *buf, size_t count)
 {
-	return do_sas_phy_reset(cdev, count, 1);
+	return do_sas_phy_reset(dev, count, 1);
 }
-static CLASS_DEVICE_ATTR(hard_reset, S_IWUSR, NULL, store_sas_hard_reset);
+static DEVICE_ATTR(hard_reset, S_IWUSR, NULL, store_sas_hard_reset);
 
 sas_phy_protocol_attr(identify.initiator_port_protocols,
 		initiator_port_protocols);
@@ -695,16 +706,17 @@ EXPORT_SYMBOL(scsi_is_sas_phy);
  */
 #define sas_port_show_simple(field, name, format_string, cast)		\
 static ssize_t								\
-show_sas_port_##name(struct class_device *cdev, char *buf)		\
+show_sas_port_##name(struct device *dev, 				\
+		     struct device_attribute *attr, char *buf)		\
 {									\
-	struct sas_port *port = transport_class_to_sas_port(cdev);	\
+	struct sas_port *port = transport_class_to_sas_port(dev);	\
 									\
 	return snprintf(buf, 20, format_string, cast port->field);	\
 }
 
 #define sas_port_simple_attr(field, name, format_string, type)		\
 	sas_port_show_simple(field, name, format_string, (type))	\
-static CLASS_DEVICE_ATTR(name, S_IRUGO, show_sas_port_##name, NULL)
+static DEVICE_ATTR(name, S_IRUGO, show_sas_port_##name, NULL)
 
 sas_port_simple_attr(num_phys, num_phys, "%d\n", int);
 
@@ -1017,23 +1029,25 @@ EXPORT_SYMBOL(sas_port_mark_backlink);
 
 #define sas_rphy_show_simple(field, name, format_string, cast)		\
 static ssize_t								\
-show_sas_rphy_##name(struct class_device *cdev, char *buf)		\
+show_sas_rphy_##name(struct device *dev, 				\
+		     struct device_attribute *attr, char *buf)		\
 {									\
-	struct sas_rphy *rphy = transport_class_to_rphy(cdev);	\
+	struct sas_rphy *rphy = transport_class_to_rphy(dev);		\
 									\
 	return snprintf(buf, 20, format_string, cast rphy->field);	\
 }
 
 #define sas_rphy_simple_attr(field, name, format_string, type)		\
 	sas_rphy_show_simple(field, name, format_string, (type))	\
-static SAS_CLASS_DEVICE_ATTR(rphy, name, S_IRUGO, 			\
+static SAS_DEVICE_ATTR(rphy, name, S_IRUGO, 			\
 		show_sas_rphy_##name, NULL)
 
 #define sas_rphy_show_protocol(field, name)				\
 static ssize_t								\
-show_sas_rphy_##name(struct class_device *cdev, char *buf)		\
+show_sas_rphy_##name(struct device *dev, 				\
+		     struct device_attribute *attr, char *buf)		\
 {									\
-	struct sas_rphy *rphy = transport_class_to_rphy(cdev);	\
+	struct sas_rphy *rphy = transport_class_to_rphy(dev);		\
 									\
 	if (!rphy->field)					\
 		return snprintf(buf, 20, "none\n");			\
@@ -1042,13 +1056,14 @@ show_sas_rphy_##name(struct class_device *cdev, char *buf)		\
 
 #define sas_rphy_protocol_attr(field, name)				\
 	sas_rphy_show_protocol(field, name)				\
-static SAS_CLASS_DEVICE_ATTR(rphy, name, S_IRUGO,			\
+static SAS_DEVICE_ATTR(rphy, name, S_IRUGO,			\
 		show_sas_rphy_##name, NULL)
 
 static ssize_t
-show_sas_rphy_device_type(struct class_device *cdev, char *buf)
+show_sas_rphy_device_type(struct device *dev,
+			  struct device_attribute *attr, char *buf)
 {
-	struct sas_rphy *rphy = transport_class_to_rphy(cdev);
+	struct sas_rphy *rphy = transport_class_to_rphy(dev);
 
 	if (!rphy->identify.device_type)
 		return snprintf(buf, 20, "none\n");
@@ -1056,13 +1071,14 @@ show_sas_rphy_device_type(struct class_device *cdev, char *buf)
 			rphy->identify.device_type, buf);
 }
 
-static SAS_CLASS_DEVICE_ATTR(rphy, device_type, S_IRUGO,
+static SAS_DEVICE_ATTR(rphy, device_type, S_IRUGO,
 		show_sas_rphy_device_type, NULL);
 
 static ssize_t
-show_sas_rphy_enclosure_identifier(struct class_device *cdev, char *buf)
+show_sas_rphy_enclosure_identifier(struct device *dev,
+				   struct device_attribute *attr, char *buf)
 {
-	struct sas_rphy *rphy = transport_class_to_rphy(cdev);
+	struct sas_rphy *rphy = transport_class_to_rphy(dev);
 	struct sas_phy *phy = dev_to_phy(rphy->dev.parent);
 	struct Scsi_Host *shost = dev_to_shost(phy->dev.parent);
 	struct sas_internal *i = to_sas_internal(shost->transportt);
@@ -1082,13 +1098,14 @@ show_sas_rphy_enclosure_identifier(struct class_device *cdev, char *buf)
 	return sprintf(buf, "0x%llx\n", (unsigned long long)identifier);
 }
 
-static SAS_CLASS_DEVICE_ATTR(rphy, enclosure_identifier, S_IRUGO,
+static SAS_DEVICE_ATTR(rphy, enclosure_identifier, S_IRUGO,
 		show_sas_rphy_enclosure_identifier, NULL);
 
 static ssize_t
-show_sas_rphy_bay_identifier(struct class_device *cdev, char *buf)
+show_sas_rphy_bay_identifier(struct device *dev,
+			     struct device_attribute *attr, char *buf)
 {
-	struct sas_rphy *rphy = transport_class_to_rphy(cdev);
+	struct sas_rphy *rphy = transport_class_to_rphy(dev);
 	struct sas_phy *phy = dev_to_phy(rphy->dev.parent);
 	struct Scsi_Host *shost = dev_to_shost(phy->dev.parent);
 	struct sas_internal *i = to_sas_internal(shost->transportt);
@@ -1103,7 +1120,7 @@ show_sas_rphy_bay_identifier(struct class_device *cdev, char *buf)
 	return sprintf(buf, "%d\n", val);
 }
 
-static SAS_CLASS_DEVICE_ATTR(rphy, bay_identifier, S_IRUGO,
+static SAS_DEVICE_ATTR(rphy, bay_identifier, S_IRUGO,
 		show_sas_rphy_bay_identifier, NULL);
 
 sas_rphy_protocol_attr(identify.initiator_port_protocols,
@@ -1161,9 +1178,10 @@ static DECLARE_TRANSPORT_CLASS(sas_end_dev_class,
 
 #define sas_end_dev_show_simple(field, name, format_string, cast)	\
 static ssize_t								\
-show_sas_end_dev_##name(struct class_device *cdev, char *buf)		\
+show_sas_end_dev_##name(struct device *dev, 				\
+			struct device_attribute *attr, char *buf)	\
 {									\
-	struct sas_rphy *rphy = transport_class_to_rphy(cdev);		\
+	struct sas_rphy *rphy = transport_class_to_rphy(dev);		\
 	struct sas_end_device *rdev = rphy_to_end_device(rphy);		\
 									\
 	return snprintf(buf, 20, format_string, cast rdev->field);	\
@@ -1171,7 +1189,7 @@ show_sas_end_dev_##name(struct class_device *cdev, char *buf)		\
 
 #define sas_end_dev_simple_attr(field, name, format_string, type)	\
 	sas_end_dev_show_simple(field, name, format_string, (type))	\
-static SAS_CLASS_DEVICE_ATTR(end_dev, name, S_IRUGO, 			\
+static SAS_DEVICE_ATTR(end_dev, name, S_IRUGO, 			\
 		show_sas_end_dev_##name, NULL)
 
 sas_end_dev_simple_attr(ready_led_meaning, ready_led_meaning, "%d\n", int);
@@ -1185,9 +1203,10 @@ static DECLARE_TRANSPORT_CLASS(sas_expander_class,
 
 #define sas_expander_show_simple(field, name, format_string, cast)	\
 static ssize_t								\
-show_sas_expander_##name(struct class_device *cdev, char *buf)		\
+show_sas_expander_##name(struct device *dev, 				\
+			 struct device_attribute *attr, char *buf)	\
 {									\
-	struct sas_rphy *rphy = transport_class_to_rphy(cdev);		\
+	struct sas_rphy *rphy = transport_class_to_rphy(dev);		\
 	struct sas_expander_device *edev = rphy_to_expander_device(rphy); \
 									\
 	return snprintf(buf, 20, format_string, cast edev->field);	\
@@ -1195,7 +1214,7 @@ show_sas_expander_##name(struct class_device *cdev, char *buf)		\
 
 #define sas_expander_simple_attr(field, name, format_string, type)	\
 	sas_expander_show_simple(field, name, format_string, (type))	\
-static SAS_CLASS_DEVICE_ATTR(expander, name, S_IRUGO, 			\
+static SAS_DEVICE_ATTR(expander, name, S_IRUGO, 			\
 		show_sas_expander_##name, NULL)
 
 sas_expander_simple_attr(vendor_id, vendor_id, "%s\n", char *);
@@ -1554,14 +1573,14 @@ static int sas_user_scan(struct Scsi_Host *shost, uint channel,
  */
 
 #define SETUP_TEMPLATE(attrb, field, perm, test)			\
-	i->private_##attrb[count] = class_device_attr_##field;		\
+	i->private_##attrb[count] = dev_attr_##field;		\
 	i->private_##attrb[count].attr.mode = perm;			\
 	i->attrb[count] = &i->private_##attrb[count];			\
 	if (test)							\
 		count++
 
 #define SETUP_TEMPLATE_RW(attrb, field, perm, test, ro_test, ro_perm)	\
-	i->private_##attrb[count] = class_device_attr_##field;		\
+	i->private_##attrb[count] = dev_attr_##field;		\
 	i->private_##attrb[count].attr.mode = perm;			\
 	if (ro_test) {							\
 		i->private_##attrb[count].attr.mode = ro_perm;		\

commit b1c118121ae37285ddc0a7a908999196bb35fb0b
Author: Joe Perches <joe@perches.com>
Date:   Sun Feb 3 17:28:22 2008 +0200

    drivers/scsi/: Spelling fixes
    
    Signed-off-by: Joe Perches <joe@perches.com>
    Acked-by: Andrew Vasquez <andrew.vasquez@qlogic.com>
    Acked-by: James Smart <james.smart@emulex.com>
    Acked-by: Darrick J. Wong <djwong@us.ibm.com>
    Acked-by: David Somayajulu <david.somayajulu@qlogic.com>
    Acked-by: Mark Salyzyn <mark_salyzyn@adaptec.com>
    Signed-off-by: Adrian Bunk <bunk@kernel.org>

diff --git a/drivers/scsi/scsi_transport_sas.c b/drivers/scsi/scsi_transport_sas.c
index f2149d0bb999..43a964d635b4 100644
--- a/drivers/scsi/scsi_transport_sas.c
+++ b/drivers/scsi/scsi_transport_sas.c
@@ -6,7 +6,7 @@
  *
  * The SAS transport class contains common code to deal with SAS HBAs,
  * an aproximated representation of SAS topologies in the driver model,
- * and various sysfs attributes to expose these topologies and managment
+ * and various sysfs attributes to expose these topologies and management
  * interfaces to userspace.
  *
  * In addition to the basic SCSI core objects this transport class

commit 2d507a01dac338831266b44ccbb01c69e84606ed
Author: James Bottomley <James.Bottomley@HansenPartnership.com>
Date:   Sat Dec 29 10:59:53 2007 -0600

    [SCSI] libsas, bsg: pass errors through correctly
    
    Currently in BSG, errors returned in req->errors aren't passed back to
    the calling programme (either via SG_IO or via read/write).  Fix this,
    while preserving the SCSI convention of returning status in
    req->errors.
    
    Now update libsas to return errors correctly instead of to ignore
    them.
    
    Acked-by: FUJITA Tomonori <fujita.tomonori@lab.ntt.co.jp>
    Signed-off-by: James Bottomley <James.Bottomley@HansenPartnership.com>

diff --git a/drivers/scsi/scsi_transport_sas.c b/drivers/scsi/scsi_transport_sas.c
index 87e786daa713..f2149d0bb999 100644
--- a/drivers/scsi/scsi_transport_sas.c
+++ b/drivers/scsi/scsi_transport_sas.c
@@ -173,6 +173,7 @@ static void sas_smp_request(struct request_queue *q, struct Scsi_Host *shost,
 
 		handler = to_sas_internal(shost->transportt)->f->smp_handler;
 		ret = handler(shost, rphy, req);
+		req->errors = ret;
 
 		spin_lock_irq(q->queue_lock);
 

commit eb44820c28bc9a042e1157b41c677018a8fdfc74
Author: Rob Landley <rob@landley.net>
Date:   Sat Nov 3 13:30:39 2007 -0500

    [SCSI] Add Documentation and integrate into docbook build
    
    Add Documentation/DocBook/scsi_midlayer.tmpl, add to Makefile, and update
    lots of kerneldoc comments in drivers/scsi/*.
    
    Updated with comments from Stefan Richter, Stephen M. Cameron,
     James Bottomley and Randy Dunlap.
    
    Signed-off-by: Rob Landley <rob@landley.net>
    Signed-off-by: James Bottomley <James.Bottomley@HansenPartnership.com>

diff --git a/drivers/scsi/scsi_transport_sas.c b/drivers/scsi/scsi_transport_sas.c
index 3120f4b3a11a..87e786daa713 100644
--- a/drivers/scsi/scsi_transport_sas.c
+++ b/drivers/scsi/scsi_transport_sas.c
@@ -323,7 +323,7 @@ static int do_sas_phy_delete(struct device *dev, void *data)
 }
 
 /**
- * sas_remove_children  --  tear down a devices SAS data structures
+ * sas_remove_children  -  tear down a devices SAS data structures
  * @dev:	device belonging to the sas object
  *
  * Removes all SAS PHYs and remote PHYs for a given object
@@ -336,7 +336,7 @@ void sas_remove_children(struct device *dev)
 EXPORT_SYMBOL(sas_remove_children);
 
 /**
- * sas_remove_host  --  tear down a Scsi_Host's SAS data structures
+ * sas_remove_host  -  tear down a Scsi_Host's SAS data structures
  * @shost:	Scsi Host that is torn down
  *
  * Removes all SAS PHYs and remote PHYs for a given Scsi_Host.
@@ -577,7 +577,7 @@ static void sas_phy_release(struct device *dev)
 }
 
 /**
- * sas_phy_alloc  --  allocates and initialize a SAS PHY structure
+ * sas_phy_alloc  -  allocates and initialize a SAS PHY structure
  * @parent:	Parent device
  * @number:	Phy index
  *
@@ -618,7 +618,7 @@ struct sas_phy *sas_phy_alloc(struct device *parent, int number)
 EXPORT_SYMBOL(sas_phy_alloc);
 
 /**
- * sas_phy_add  --  add a SAS PHY to the device hierarchy
+ * sas_phy_add  -  add a SAS PHY to the device hierarchy
  * @phy:	The PHY to be added
  *
  * Publishes a SAS PHY to the rest of the system.
@@ -638,7 +638,7 @@ int sas_phy_add(struct sas_phy *phy)
 EXPORT_SYMBOL(sas_phy_add);
 
 /**
- * sas_phy_free  --  free a SAS PHY
+ * sas_phy_free  -  free a SAS PHY
  * @phy:	SAS PHY to free
  *
  * Frees the specified SAS PHY.
@@ -655,7 +655,7 @@ void sas_phy_free(struct sas_phy *phy)
 EXPORT_SYMBOL(sas_phy_free);
 
 /**
- * sas_phy_delete  --  remove SAS PHY
+ * sas_phy_delete  -  remove SAS PHY
  * @phy:	SAS PHY to remove
  *
  * Removes the specified SAS PHY.  If the SAS PHY has an
@@ -677,7 +677,7 @@ sas_phy_delete(struct sas_phy *phy)
 EXPORT_SYMBOL(sas_phy_delete);
 
 /**
- * scsi_is_sas_phy  --  check if a struct device represents a SAS PHY
+ * scsi_is_sas_phy  -  check if a struct device represents a SAS PHY
  * @dev:	device to check
  *
  * Returns:
@@ -843,7 +843,6 @@ EXPORT_SYMBOL(sas_port_alloc_num);
 
 /**
  * sas_port_add - add a SAS port to the device hierarchy
- *
  * @port:	port to be added
  *
  * publishes a port to the rest of the system
@@ -868,7 +867,7 @@ int sas_port_add(struct sas_port *port)
 EXPORT_SYMBOL(sas_port_add);
 
 /**
- * sas_port_free  --  free a SAS PORT
+ * sas_port_free  -  free a SAS PORT
  * @port:	SAS PORT to free
  *
  * Frees the specified SAS PORT.
@@ -885,7 +884,7 @@ void sas_port_free(struct sas_port *port)
 EXPORT_SYMBOL(sas_port_free);
 
 /**
- * sas_port_delete  --  remove SAS PORT
+ * sas_port_delete  -  remove SAS PORT
  * @port:	SAS PORT to remove
  *
  * Removes the specified SAS PORT.  If the SAS PORT has an
@@ -924,7 +923,7 @@ void sas_port_delete(struct sas_port *port)
 EXPORT_SYMBOL(sas_port_delete);
 
 /**
- * scsi_is_sas_port --  check if a struct device represents a SAS port
+ * scsi_is_sas_port -  check if a struct device represents a SAS port
  * @dev:	device to check
  *
  * Returns:
@@ -1309,6 +1308,7 @@ static void sas_rphy_initialize(struct sas_rphy *rphy)
 
 /**
  * sas_end_device_alloc - allocate an rphy for an end device
+ * @parent: which port
  *
  * Allocates an SAS remote PHY structure, connected to @parent.
  *
@@ -1345,6 +1345,8 @@ EXPORT_SYMBOL(sas_end_device_alloc);
 
 /**
  * sas_expander_alloc - allocate an rphy for an end device
+ * @parent: which port
+ * @type: SAS_EDGE_EXPANDER_DEVICE or SAS_FANOUT_EXPANDER_DEVICE
  *
  * Allocates an SAS remote PHY structure, connected to @parent.
  *
@@ -1383,7 +1385,7 @@ struct sas_rphy *sas_expander_alloc(struct sas_port *parent,
 EXPORT_SYMBOL(sas_expander_alloc);
 
 /**
- * sas_rphy_add  --  add a SAS remote PHY to the device hierarchy
+ * sas_rphy_add  -  add a SAS remote PHY to the device hierarchy
  * @rphy:	The remote PHY to be added
  *
  * Publishes a SAS remote PHY to the rest of the system.
@@ -1430,8 +1432,8 @@ int sas_rphy_add(struct sas_rphy *rphy)
 EXPORT_SYMBOL(sas_rphy_add);
 
 /**
- * sas_rphy_free  --  free a SAS remote PHY
- * @rphy	SAS remote PHY to free
+ * sas_rphy_free  -  free a SAS remote PHY
+ * @rphy: SAS remote PHY to free
  *
  * Frees the specified SAS remote PHY.
  *
@@ -1459,7 +1461,7 @@ void sas_rphy_free(struct sas_rphy *rphy)
 EXPORT_SYMBOL(sas_rphy_free);
 
 /**
- * sas_rphy_delete  --  remove and free SAS remote PHY
+ * sas_rphy_delete  -  remove and free SAS remote PHY
  * @rphy:	SAS remote PHY to remove and free
  *
  * Removes the specified SAS remote PHY and frees it.
@@ -1473,7 +1475,7 @@ sas_rphy_delete(struct sas_rphy *rphy)
 EXPORT_SYMBOL(sas_rphy_delete);
 
 /**
- * sas_rphy_remove  --  remove SAS remote PHY
+ * sas_rphy_remove  -  remove SAS remote PHY
  * @rphy:	SAS remote phy to remove
  *
  * Removes the specified SAS remote PHY.
@@ -1504,7 +1506,7 @@ sas_rphy_remove(struct sas_rphy *rphy)
 EXPORT_SYMBOL(sas_rphy_remove);
 
 /**
- * scsi_is_sas_rphy  --  check if a struct device represents a SAS remote PHY
+ * scsi_is_sas_rphy  -  check if a struct device represents a SAS remote PHY
  * @dev:	device to check
  *
  * Returns:
@@ -1604,7 +1606,7 @@ static int sas_user_scan(struct Scsi_Host *shost, uint channel,
 	SETUP_TEMPLATE(expander_attrs, expander_##field, S_IRUGO, 1)
 
 /**
- * sas_attach_transport  --  instantiate SAS transport template
+ * sas_attach_transport  -  instantiate SAS transport template
  * @ft:		SAS transport class function template
  */
 struct scsi_transport_template *
@@ -1715,7 +1717,7 @@ sas_attach_transport(struct sas_function_template *ft)
 EXPORT_SYMBOL(sas_attach_transport);
 
 /**
- * sas_release_transport  --  release SAS transport template instance
+ * sas_release_transport  -  release SAS transport template instance
  * @t:		transport template instance
  */
 void sas_release_transport(struct scsi_transport_template *t)

commit 39dca558a5b52b63e49bc234a7e887be092aa690
Author: James Bottomley <James.Bottomley@steeleye.com>
Date:   Fri Jul 20 18:22:17 2007 -0500

    [SCSI] bsg: make class backlinks
    
    Currently, bsg doesn't make class backlinks (a process whereby you'd get
    a link to bsg in the device directory in the same way you get one for
    sg).  This is because the bsg device is uninitialised, so the class
    device has nothing it can attach to.  The fix is to make the bsg device
    point to the cdevice of the entity creating the bsg, necessitating
    changing the bsg_register_queue() prototype into a form that takes the
    generic device.
    
    Acked-by: FUJITA Tomonori <tomof@acm.org>
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>

diff --git a/drivers/scsi/scsi_transport_sas.c b/drivers/scsi/scsi_transport_sas.c
index 573f588154d0..3120f4b3a11a 100644
--- a/drivers/scsi/scsi_transport_sas.c
+++ b/drivers/scsi/scsi_transport_sas.c
@@ -191,25 +191,34 @@ static void sas_non_host_smp_request(struct request_queue *q)
 	sas_smp_request(q, rphy_to_shost(rphy), rphy);
 }
 
-static int sas_bsg_initialize(struct Scsi_Host *shost, struct sas_rphy *rphy,
-			      char *name)
+static int sas_bsg_initialize(struct Scsi_Host *shost, struct sas_rphy *rphy)
 {
 	struct request_queue *q;
 	int error;
+	struct device *dev;
+	char namebuf[BUS_ID_SIZE];
+	const char *name;
 
 	if (!to_sas_internal(shost->transportt)->f->smp_handler) {
 		printk("%s can't handle SMP requests\n", shost->hostt->name);
 		return 0;
 	}
 
-	if (rphy)
+	if (rphy) {
 		q = blk_init_queue(sas_non_host_smp_request, NULL);
-	else
+		dev = &rphy->dev;
+		name = dev->bus_id;
+	} else {
 		q = blk_init_queue(sas_host_smp_request, NULL);
+		dev = &shost->shost_gendev;
+		snprintf(namebuf, sizeof(namebuf),
+			 "sas_host%d", shost->host_no);
+		name = namebuf;
+	}
 	if (!q)
 		return -ENOMEM;
 
-	error = bsg_register_queue(q, name);
+	error = bsg_register_queue(q, dev, name);
 	if (error) {
 		blk_cleanup_queue(q);
 		return -ENOMEM;
@@ -255,7 +264,6 @@ static int sas_host_setup(struct transport_container *tc, struct device *dev,
 {
 	struct Scsi_Host *shost = dev_to_shost(dev);
 	struct sas_host_attrs *sas_host = to_sas_host_attrs(shost);
-	char name[BUS_ID_SIZE];
 
 	INIT_LIST_HEAD(&sas_host->rphy_list);
 	mutex_init(&sas_host->lock);
@@ -263,8 +271,7 @@ static int sas_host_setup(struct transport_container *tc, struct device *dev,
 	sas_host->next_expander_id = 0;
 	sas_host->next_port_id = 0;
 
-	snprintf(name, sizeof(name), "sas_host%d", shost->host_no);
-	if (sas_bsg_initialize(shost, NULL, name))
+	if (sas_bsg_initialize(shost, NULL))
 		dev_printk(KERN_ERR, dev, "fail to a bsg device %d\n",
 			   shost->host_no);
 
@@ -1332,9 +1339,6 @@ struct sas_rphy *sas_end_device_alloc(struct sas_port *parent)
 	sas_rphy_initialize(&rdev->rphy);
 	transport_setup_device(&rdev->rphy.dev);
 
-	if (sas_bsg_initialize(shost, &rdev->rphy, rdev->rphy.dev.bus_id))
-		printk("fail to a bsg device %s\n", rdev->rphy.dev.bus_id);
-
 	return &rdev->rphy;
 }
 EXPORT_SYMBOL(sas_end_device_alloc);
@@ -1374,9 +1378,6 @@ struct sas_rphy *sas_expander_alloc(struct sas_port *parent,
 	sas_rphy_initialize(&rdev->rphy);
 	transport_setup_device(&rdev->rphy.dev);
 
-	if (sas_bsg_initialize(shost, &rdev->rphy, rdev->rphy.dev.bus_id))
-		printk("fail to a bsg device %s\n", rdev->rphy.dev.bus_id);
-
 	return &rdev->rphy;
 }
 EXPORT_SYMBOL(sas_expander_alloc);
@@ -1404,6 +1405,9 @@ int sas_rphy_add(struct sas_rphy *rphy)
 		return error;
 	transport_add_device(&rphy->dev);
 	transport_configure_device(&rphy->dev);
+	if (sas_bsg_initialize(shost, rphy))
+		printk("fail to a bsg device %s\n", rphy->dev.bus_id);
+
 
 	mutex_lock(&sas_host->lock);
 	list_add_tail(&rphy->list, &sas_host->rphy_list);

commit b6aff66953a29e40e0683be9b39c369ade143a5b
Author: James Bottomley <James.Bottomley@steeleye.com>
Date:   Fri Jul 20 11:10:05 2007 -0500

    [SCSI] scsi_transport_sas: add destructor for bsg
    
    There's currently no destructor for the bsg components.  If you insert
    and remove the module, you see the bsg devices building up and up.  This
    patch adds the destructor in the correct place in the transport class so
    that the bsg and request queue are removed just before the device
    destruction.
    
    Acked-by: FUJITA Tomonori <tomof@acm.org>
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>

diff --git a/drivers/scsi/scsi_transport_sas.c b/drivers/scsi/scsi_transport_sas.c
index 2871fd05fcf7..573f588154d0 100644
--- a/drivers/scsi/scsi_transport_sas.c
+++ b/drivers/scsi/scsi_transport_sas.c
@@ -42,6 +42,7 @@
 struct sas_host_attrs {
 	struct list_head rphy_list;
 	struct mutex lock;
+	struct request_queue *q;
 	u32 next_target_id;
 	u32 next_expander_id;
 	int next_port_id;
@@ -214,6 +215,11 @@ static int sas_bsg_initialize(struct Scsi_Host *shost, struct sas_rphy *rphy,
 		return -ENOMEM;
 	}
 
+	if (rphy)
+		rphy->q = q;
+	else
+		to_sas_host_attrs(shost)->q = q;
+
 	if (rphy)
 		q->queuedata = rphy;
 	else
@@ -224,6 +230,22 @@ static int sas_bsg_initialize(struct Scsi_Host *shost, struct sas_rphy *rphy,
 	return 0;
 }
 
+static void sas_bsg_remove(struct Scsi_Host *shost, struct sas_rphy *rphy)
+{
+	struct request_queue *q;
+
+	if (rphy)
+		q = rphy->q;
+	else
+		q = to_sas_host_attrs(shost)->q;
+
+	if (!q)
+		return;
+
+	bsg_unregister_queue(q);
+	blk_cleanup_queue(q);
+}
+
 /*
  * SAS host attributes
  */
@@ -249,8 +271,18 @@ static int sas_host_setup(struct transport_container *tc, struct device *dev,
 	return 0;
 }
 
+static int sas_host_remove(struct transport_container *tc, struct device *dev,
+			   struct class_device *cdev)
+{
+	struct Scsi_Host *shost = dev_to_shost(dev);
+
+	sas_bsg_remove(shost, NULL);
+
+	return 0;
+}
+
 static DECLARE_TRANSPORT_CLASS(sas_host_class,
-		"sas_host", sas_host_setup, NULL, NULL);
+		"sas_host", sas_host_setup, sas_host_remove, NULL);
 
 static int sas_host_match(struct attribute_container *cont,
 			    struct device *dev)
@@ -1414,6 +1446,8 @@ void sas_rphy_free(struct sas_rphy *rphy)
 	list_del(&rphy->list);
 	mutex_unlock(&sas_host->lock);
 
+	sas_bsg_remove(shost, rphy);
+
 	transport_destroy_device(dev);
 
 	put_device(dev);

commit 7aa68e80bd481faae1234bc2a7e4bcc9348f98b4
Author: FUJITA Tomonori <fujita.tomonori@lab.ntt.co.jp>
Date:   Mon Jul 9 12:52:06 2007 +0900

    [SCSI] transport_sas: add SAS management protocol support
    
    The sas transport class attaches one bsg device to every SAS object
    (host, device, expander, etc). LLDs can define a function to handle
    SMP requests via sas_function_template::smp_handler.
    
    Signed-off-by: FUJITA Tomonori <fujita.tomonori@lab.ntt.co.jp>
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>

diff --git a/drivers/scsi/scsi_transport_sas.c b/drivers/scsi/scsi_transport_sas.c
index b2ef71a86292..2871fd05fcf7 100644
--- a/drivers/scsi/scsi_transport_sas.c
+++ b/drivers/scsi/scsi_transport_sas.c
@@ -29,6 +29,8 @@
 #include <linux/err.h>
 #include <linux/slab.h>
 #include <linux/string.h>
+#include <linux/blkdev.h>
+#include <linux/bsg.h>
 
 #include <scsi/scsi.h>
 #include <scsi/scsi_device.h>
@@ -152,6 +154,76 @@ static struct {
 sas_bitfield_name_search(linkspeed, sas_linkspeed_names)
 sas_bitfield_name_set(linkspeed, sas_linkspeed_names)
 
+static void sas_smp_request(struct request_queue *q, struct Scsi_Host *shost,
+			    struct sas_rphy *rphy)
+{
+	struct request *req;
+	int ret;
+	int (*handler)(struct Scsi_Host *, struct sas_rphy *, struct request *);
+
+	while (!blk_queue_plugged(q)) {
+		req = elv_next_request(q);
+		if (!req)
+			break;
+
+		blkdev_dequeue_request(req);
+
+		spin_unlock_irq(q->queue_lock);
+
+		handler = to_sas_internal(shost->transportt)->f->smp_handler;
+		ret = handler(shost, rphy, req);
+
+		spin_lock_irq(q->queue_lock);
+
+		req->end_io(req, ret);
+	}
+}
+
+static void sas_host_smp_request(struct request_queue *q)
+{
+	sas_smp_request(q, (struct Scsi_Host *)q->queuedata, NULL);
+}
+
+static void sas_non_host_smp_request(struct request_queue *q)
+{
+	struct sas_rphy *rphy = q->queuedata;
+	sas_smp_request(q, rphy_to_shost(rphy), rphy);
+}
+
+static int sas_bsg_initialize(struct Scsi_Host *shost, struct sas_rphy *rphy,
+			      char *name)
+{
+	struct request_queue *q;
+	int error;
+
+	if (!to_sas_internal(shost->transportt)->f->smp_handler) {
+		printk("%s can't handle SMP requests\n", shost->hostt->name);
+		return 0;
+	}
+
+	if (rphy)
+		q = blk_init_queue(sas_non_host_smp_request, NULL);
+	else
+		q = blk_init_queue(sas_host_smp_request, NULL);
+	if (!q)
+		return -ENOMEM;
+
+	error = bsg_register_queue(q, name);
+	if (error) {
+		blk_cleanup_queue(q);
+		return -ENOMEM;
+	}
+
+	if (rphy)
+		q->queuedata = rphy;
+	else
+		q->queuedata = shost;
+
+	set_bit(QUEUE_FLAG_BIDI, &q->queue_flags);
+
+	return 0;
+}
+
 /*
  * SAS host attributes
  */
@@ -161,12 +233,19 @@ static int sas_host_setup(struct transport_container *tc, struct device *dev,
 {
 	struct Scsi_Host *shost = dev_to_shost(dev);
 	struct sas_host_attrs *sas_host = to_sas_host_attrs(shost);
+	char name[BUS_ID_SIZE];
 
 	INIT_LIST_HEAD(&sas_host->rphy_list);
 	mutex_init(&sas_host->lock);
 	sas_host->next_target_id = 0;
 	sas_host->next_expander_id = 0;
 	sas_host->next_port_id = 0;
+
+	snprintf(name, sizeof(name), "sas_host%d", shost->host_no);
+	if (sas_bsg_initialize(shost, NULL, name))
+		dev_printk(KERN_ERR, dev, "fail to a bsg device %d\n",
+			   shost->host_no);
+
 	return 0;
 }
 
@@ -1221,6 +1300,9 @@ struct sas_rphy *sas_end_device_alloc(struct sas_port *parent)
 	sas_rphy_initialize(&rdev->rphy);
 	transport_setup_device(&rdev->rphy.dev);
 
+	if (sas_bsg_initialize(shost, &rdev->rphy, rdev->rphy.dev.bus_id))
+		printk("fail to a bsg device %s\n", rdev->rphy.dev.bus_id);
+
 	return &rdev->rphy;
 }
 EXPORT_SYMBOL(sas_end_device_alloc);
@@ -1260,6 +1342,9 @@ struct sas_rphy *sas_expander_alloc(struct sas_port *parent,
 	sas_rphy_initialize(&rdev->rphy);
 	transport_setup_device(&rdev->rphy.dev);
 
+	if (sas_bsg_initialize(shost, &rdev->rphy, rdev->rphy.dev.bus_id))
+		printk("fail to a bsg device %s\n", rdev->rphy.dev.bus_id);
+
 	return &rdev->rphy;
 }
 EXPORT_SYMBOL(sas_expander_alloc);

commit 1b3c3714cb4767d00f507cc6854d3339d82c5b9d
Author: Uwe Kleine-König <zeisberg@informatik.uni-freiburg.de>
Date:   Sat Feb 17 19:23:03 2007 +0100

    Fix typos concerning hierarchy
    
            heirarchical, hierachical -> hierarchical
            heirarchy, hierachy -> hierarchy
    
    Signed-off-by: Uwe Kleine-König <zeisberg@informatik.uni-freiburg.de>
    Signed-off-by: Adrian Bunk <bunk@stusta.de>

diff --git a/drivers/scsi/scsi_transport_sas.c b/drivers/scsi/scsi_transport_sas.c
index 6d39150e205b..b2ef71a86292 100644
--- a/drivers/scsi/scsi_transport_sas.c
+++ b/drivers/scsi/scsi_transport_sas.c
@@ -500,7 +500,7 @@ struct sas_phy *sas_phy_alloc(struct device *parent, int number)
 EXPORT_SYMBOL(sas_phy_alloc);
 
 /**
- * sas_phy_add  --  add a SAS PHY to the device hierachy
+ * sas_phy_add  --  add a SAS PHY to the device hierarchy
  * @phy:	The PHY to be added
  *
  * Publishes a SAS PHY to the rest of the system.
@@ -1265,7 +1265,7 @@ struct sas_rphy *sas_expander_alloc(struct sas_port *parent,
 EXPORT_SYMBOL(sas_expander_alloc);
 
 /**
- * sas_rphy_add  --  add a SAS remote PHY to the device hierachy
+ * sas_rphy_add  --  add a SAS remote PHY to the device hierarchy
  * @rphy:	The remote PHY to be added
  *
  * Publishes a SAS remote PHY to the rest of the system.

commit 21434966462d57145c861b43f6206d945ac57630
Author: Darrick J. Wong <djwong@us.ibm.com>
Date:   Fri Jan 26 14:08:46 2007 -0800

    [SCSI] libsas: Check return values of sysfs_create_link
    
    Get rid of: "warning: ignoring return value of sysfs_create_link..."
    
    Signed-off-by: Darrick J. Wong <djwong@us.ibm.com>
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>

diff --git a/drivers/scsi/scsi_transport_sas.c b/drivers/scsi/scsi_transport_sas.c
index 010845fd2b85..6d39150e205b 100644
--- a/drivers/scsi/scsi_transport_sas.c
+++ b/drivers/scsi/scsi_transport_sas.c
@@ -625,8 +625,19 @@ static void sas_port_release(struct device *dev)
 static void sas_port_create_link(struct sas_port *port,
 				 struct sas_phy *phy)
 {
-	sysfs_create_link(&port->dev.kobj, &phy->dev.kobj, phy->dev.bus_id);
-	sysfs_create_link(&phy->dev.kobj, &port->dev.kobj, "port");
+	int res;
+
+	res = sysfs_create_link(&port->dev.kobj, &phy->dev.kobj,
+				phy->dev.bus_id);
+	if (res)
+		goto err;
+	res = sysfs_create_link(&phy->dev.kobj, &port->dev.kobj, "port");
+	if (res)
+		goto err;
+	return;
+err:
+	printk(KERN_ERR "%s: Cannot create port links, err=%d\n",
+	       __FUNCTION__, res);
 }
 
 static void sas_port_delete_link(struct sas_port *port,
@@ -864,13 +875,20 @@ EXPORT_SYMBOL(sas_port_delete_phy);
 
 void sas_port_mark_backlink(struct sas_port *port)
 {
+	int res;
 	struct device *parent = port->dev.parent->parent->parent;
 
 	if (port->is_backlink)
 		return;
 	port->is_backlink = 1;
-	sysfs_create_link(&port->dev.kobj, &parent->kobj,
-			  parent->bus_id);
+	res = sysfs_create_link(&port->dev.kobj, &parent->kobj,
+				parent->bus_id);
+	if (res)
+		goto err;
+	return;
+err:
+	printk(KERN_ERR "%s: Cannot create port backlink, err=%d\n",
+	       __FUNCTION__, res);
 
 }
 EXPORT_SYMBOL(sas_port_mark_backlink);

commit 6f63caae2172e97e528b58319480217b0b36542e
Author: Darrick J. Wong <djwong@us.ibm.com>
Date:   Fri Jan 26 14:08:43 2007 -0800

    [SCSI] libsas: Clean up discovery failure handler code
    
    sas_rphy_delete does two things: it removes the sas_rphy from the transport
    layer and frees the sas_rphy.  This can be broken down into two functions,
    sas_rphy_remove and sas_rphy_free; sas_rphy_remove is of interest to
    sas_discover_root_expander because it calls functions that require
    sas_rphy_add as a prerequisite and can fail (namely sas_discover_expander).
    In that case, sas_discover_root_expander needs to be able to undo the effects
    of sas_rphy_add yet leave the job of freeing the sas_rphy to the caller of
    sas_discover_root_expander.
    
    This patch also removes some unnecessary code from sas_discover_end_dev
    to eliminate an unnecessary cycle of sas_notify_lldd_gone/found for SAS
    devices, thus eliminating a sas_rphy_remove call (and fixing a race condition
    where a SCSI target scan can come in between the gone and found call).
    It also moves the sas_rphy_free calls into sas_discover_domain and
    sas_ex_discover_end_dev to complement the sas_rphy_allocation via
    sas_get_port_device.
    
    This patch does not change the semantics of sas_rphy_delete.
    
    Signed-off-by: Darrick J. Wong <djwong@us.ibm.com>
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>

diff --git a/drivers/scsi/scsi_transport_sas.c b/drivers/scsi/scsi_transport_sas.c
index ce232803f433..010845fd2b85 100644
--- a/drivers/scsi/scsi_transport_sas.c
+++ b/drivers/scsi/scsi_transport_sas.c
@@ -1299,7 +1299,7 @@ EXPORT_SYMBOL(sas_rphy_add);
  * Note:
  *   This function must only be called on a remote
  *   PHY that has not sucessfully been added using
- *   sas_rphy_add().
+ *   sas_rphy_add() (or has been sas_rphy_remove()'d)
  */
 void sas_rphy_free(struct sas_rphy *rphy)
 {
@@ -1318,18 +1318,30 @@ void sas_rphy_free(struct sas_rphy *rphy)
 EXPORT_SYMBOL(sas_rphy_free);
 
 /**
- * sas_rphy_delete  --  remove SAS remote PHY
- * @rphy:	SAS remote PHY to remove
+ * sas_rphy_delete  --  remove and free SAS remote PHY
+ * @rphy:	SAS remote PHY to remove and free
  *
- * Removes the specified SAS remote PHY.
+ * Removes the specified SAS remote PHY and frees it.
  */
 void
 sas_rphy_delete(struct sas_rphy *rphy)
+{
+	sas_rphy_remove(rphy);
+	sas_rphy_free(rphy);
+}
+EXPORT_SYMBOL(sas_rphy_delete);
+
+/**
+ * sas_rphy_remove  --  remove SAS remote PHY
+ * @rphy:	SAS remote phy to remove
+ *
+ * Removes the specified SAS remote PHY.
+ */
+void
+sas_rphy_remove(struct sas_rphy *rphy)
 {
 	struct device *dev = &rphy->dev;
 	struct sas_port *parent = dev_to_sas_port(dev->parent);
-	struct Scsi_Host *shost = dev_to_shost(parent->dev.parent);
-	struct sas_host_attrs *sas_host = to_sas_host_attrs(shost);
 
 	switch (rphy->identify.device_type) {
 	case SAS_END_DEVICE:
@@ -1345,17 +1357,10 @@ sas_rphy_delete(struct sas_rphy *rphy)
 
 	transport_remove_device(dev);
 	device_del(dev);
-	transport_destroy_device(dev);
-
-	mutex_lock(&sas_host->lock);
-	list_del(&rphy->list);
-	mutex_unlock(&sas_host->lock);
 
 	parent->rphy = NULL;
-
-	put_device(dev);
 }
-EXPORT_SYMBOL(sas_rphy_delete);
+EXPORT_SYMBOL(sas_rphy_remove);
 
 /**
  * scsi_is_sas_rphy  --  check if a struct device represents a SAS remote PHY

commit 86b9c4c16a1589d05959af2d96d52a4352c6306e
Author: Alexis Bruemmer <alexisb@us.ibm.com>
Date:   Tue Jan 16 15:36:12 2007 -0800

    [SCSI] aic94xx: fix typos and update verison number
    
    fix typos and bump version number
    
    Signed-off-by: Darrick J. Wong <djwong@us.ibm.com>
    Acked-by: Alexis Bruemmer <alexisb@us.ibm.com>
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>

diff --git a/drivers/scsi/scsi_transport_sas.c b/drivers/scsi/scsi_transport_sas.c
index bfbcf5fa72b9..ce232803f433 100644
--- a/drivers/scsi/scsi_transport_sas.c
+++ b/drivers/scsi/scsi_transport_sas.c
@@ -1638,7 +1638,7 @@ static void __exit sas_transport_exit(void)
 }
 
 MODULE_AUTHOR("Christoph Hellwig");
-MODULE_DESCRIPTION("SAS Transphy Attributes");
+MODULE_DESCRIPTION("SAS Transport Attributes");
 MODULE_LICENSE("GPL");
 
 module_init(sas_transport_init);

commit fe3b5bfe73ace420709f0cfb198b0ffc704bd38b
Author: Darrick J. Wong <djwong@us.ibm.com>
Date:   Thu Jan 11 14:15:35 2007 -0800

    [SCSI] libsas: sysfs phy control attributes should not be S_IWUGO
    
    Allowing the phy reset controls to be world-triggerable does not seem like
    a terribly good idea because SAS devices can be disrupted (and ATA devices
    are really disrupted) by a phy reset.  By default only root should be able
    to do things like that.
    
    Signed-off-by: Darrick J. Wong <djwong@us.ibm.com>
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>

diff --git a/drivers/scsi/scsi_transport_sas.c b/drivers/scsi/scsi_transport_sas.c
index e57b02e8afa5..bfbcf5fa72b9 100644
--- a/drivers/scsi/scsi_transport_sas.c
+++ b/drivers/scsi/scsi_transport_sas.c
@@ -1446,10 +1446,10 @@ static int sas_user_scan(struct Scsi_Host *shost, uint channel,
 	SETUP_TEMPLATE(phy_attrs, field, S_IRUGO, i->f->func)
 
 #define SETUP_PHY_ATTRIBUTE_WRONLY(field)				\
-	SETUP_TEMPLATE(phy_attrs, field, S_IWUGO, 1)
+	SETUP_TEMPLATE(phy_attrs, field, S_IWUSR, 1)
 
 #define SETUP_OPTIONAL_PHY_ATTRIBUTE_WRONLY(field, func)		\
-	SETUP_TEMPLATE(phy_attrs, field, S_IWUGO, i->f->func)
+	SETUP_TEMPLATE(phy_attrs, field, S_IWUSR, i->f->func)
 
 #define SETUP_END_DEV_ATTRIBUTE(field)					\
 	SETUP_TEMPLATE(end_dev_attrs, field, S_IRUGO, 1)

commit c8490f3a77805d04321d9e44486a679801a035b8
Author: Darrick J. Wong <djwong@us.ibm.com>
Date:   Thu Jan 11 14:15:09 2007 -0800

    [SCSI] libsas: Use SCAN_WILD_CARD instead of ~0
    
    Magic number cleanup.
    
    Signed-off-by: Darrick J. Wong <djwong@us.ibm.com>
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>

diff --git a/drivers/scsi/scsi_transport_sas.c b/drivers/scsi/scsi_transport_sas.c
index 9e38c1894bb2..e57b02e8afa5 100644
--- a/drivers/scsi/scsi_transport_sas.c
+++ b/drivers/scsi/scsi_transport_sas.c
@@ -1283,7 +1283,7 @@ int sas_rphy_add(struct sas_rphy *rphy)
 	if (identify->device_type == SAS_END_DEVICE &&
 	    rphy->scsi_target_id != -1) {
 		scsi_scan_target(&rphy->dev, 0,
-				rphy->scsi_target_id, ~0, 0);
+				rphy->scsi_target_id, SCAN_WILD_CARD, 0);
 	}
 
 	return 0;

commit acbf167d4ad8c27f9743a4b539d51ae9535bf21c
Author: Darrick J. Wong <djwong@us.ibm.com>
Date:   Thu Jan 11 14:14:57 2007 -0800

    [SCSI] libsas: Add a sysfs knob to enable/disable a phy
    
    This patch lets a user arbitrarily enable or disable a phy via sysfs.
    Potential applications include shutting down a phy to replace one
    lane of wide port, and (more importantly) providing a method for the
    libata SATL to control the phy.
    
    Signed-off-by: Darrick J. Wong <djwong@us.ibm.com>
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>

diff --git a/drivers/scsi/scsi_transport_sas.c b/drivers/scsi/scsi_transport_sas.c
index 5c0b75bbfa10..9e38c1894bb2 100644
--- a/drivers/scsi/scsi_transport_sas.c
+++ b/drivers/scsi/scsi_transport_sas.c
@@ -336,6 +336,51 @@ show_sas_device_type(struct class_device *cdev, char *buf)
 }
 static CLASS_DEVICE_ATTR(device_type, S_IRUGO, show_sas_device_type, NULL);
 
+static ssize_t do_sas_phy_enable(struct class_device *cdev,
+		size_t count, int enable)
+{
+	struct sas_phy *phy = transport_class_to_phy(cdev);
+	struct Scsi_Host *shost = dev_to_shost(phy->dev.parent);
+	struct sas_internal *i = to_sas_internal(shost->transportt);
+	int error;
+
+	error = i->f->phy_enable(phy, enable);
+	if (error)
+		return error;
+	phy->enabled = enable;
+	return count;
+};
+
+static ssize_t store_sas_phy_enable(struct class_device *cdev,
+		const char *buf, size_t count)
+{
+	if (count < 1)
+		return -EINVAL;
+
+	switch (buf[0]) {
+	case '0':
+		do_sas_phy_enable(cdev, count, 0);
+		break;
+	case '1':
+		do_sas_phy_enable(cdev, count, 1);
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	return count;
+}
+
+static ssize_t show_sas_phy_enable(struct class_device *cdev, char *buf)
+{
+	struct sas_phy *phy = transport_class_to_phy(cdev);
+
+	return snprintf(buf, 20, "%d", phy->enabled);
+}
+
+static CLASS_DEVICE_ATTR(enable, S_IRUGO | S_IWUSR, show_sas_phy_enable,
+			 store_sas_phy_enable);
+
 static ssize_t do_sas_phy_reset(struct class_device *cdev,
 		size_t count, int hard_reset)
 {
@@ -435,6 +480,7 @@ struct sas_phy *sas_phy_alloc(struct device *parent, int number)
 		return NULL;
 
 	phy->number = number;
+	phy->enabled = 1;
 
 	device_initialize(&phy->dev);
 	phy->dev.parent = get_device(parent);
@@ -1389,6 +1435,10 @@ static int sas_user_scan(struct Scsi_Host *shost, uint channel,
 	SETUP_TEMPLATE_RW(phy_attrs, field, S_IRUGO | S_IWUSR, 1,	\
 			!i->f->set_phy_speed, S_IRUGO)
 
+#define SETUP_OPTIONAL_PHY_ATTRIBUTE_RW(field, func)			\
+	SETUP_TEMPLATE_RW(phy_attrs, field, S_IRUGO | S_IWUSR, 1,	\
+			  !i->f->func, S_IRUGO)
+
 #define SETUP_PORT_ATTRIBUTE(field)					\
 	SETUP_TEMPLATE(port_attrs, field, S_IRUGO, 1)
 
@@ -1479,6 +1529,7 @@ sas_attach_transport(struct sas_function_template *ft)
 	SETUP_PHY_ATTRIBUTE(phy_reset_problem_count);
 	SETUP_OPTIONAL_PHY_ATTRIBUTE_WRONLY(link_reset, phy_reset);
 	SETUP_OPTIONAL_PHY_ATTRIBUTE_WRONLY(hard_reset, phy_reset);
+	SETUP_OPTIONAL_PHY_ATTRIBUTE_RW(enable, phy_enable);
 	i->phy_attrs[count] = NULL;
 
 	count = 0;

commit f6a570333e554b48ad589e7137c77c57809eee81
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Wed Oct 18 01:47:25 2006 -0400

    [PATCH] severing module.h->sched.h
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/drivers/scsi/scsi_transport_sas.c b/drivers/scsi/scsi_transport_sas.c
index b5b0c2cba96b..5c0b75bbfa10 100644
--- a/drivers/scsi/scsi_transport_sas.c
+++ b/drivers/scsi/scsi_transport_sas.c
@@ -25,6 +25,7 @@
 
 #include <linux/init.h>
 #include <linux/module.h>
+#include <linux/jiffies.h>
 #include <linux/err.h>
 #include <linux/slab.h>
 #include <linux/string.h>

commit d24e1eeb3a16e4944288c2f3bf082e1513f4b425
Author: James Bottomley <James.Bottomley@steeleye.com>
Date:   Wed Sep 6 19:25:22 2006 -0500

    [SCSI] scsi_transport_sas: make minimum and maximum linkrate settable quantities
    
    According to SPEC, the minimum_linkrate and maximum_linkrate should be
    settable by the user.  This patch introduces a callback that allows the
    sas class to pass these settings on to the driver.
    
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>

diff --git a/drivers/scsi/scsi_transport_sas.c b/drivers/scsi/scsi_transport_sas.c
index d518c1207fb4..b5b0c2cba96b 100644
--- a/drivers/scsi/scsi_transport_sas.c
+++ b/drivers/scsi/scsi_transport_sas.c
@@ -77,6 +77,24 @@ get_sas_##title##_names(u32 table_key, char *buf)		\
 	return len;						\
 }
 
+#define sas_bitfield_name_set(title, table)			\
+static ssize_t							\
+set_sas_##title##_names(u32 *table_key, const char *buf)	\
+{								\
+	ssize_t len = 0;					\
+	int i;							\
+								\
+	for (i = 0; i < ARRAY_SIZE(table); i++) {		\
+		len = strlen(table[i].name);			\
+		if (strncmp(buf, table[i].name, len) == 0 &&	\
+		    (buf[len] == '\n' || buf[len] == '\0')) {	\
+			*table_key = table[i].value;		\
+			return 0;				\
+		}						\
+	}							\
+	return -EINVAL;						\
+}
+
 #define sas_bitfield_name_search(title, table)			\
 static ssize_t							\
 get_sas_##title##_names(u32 table_key, char *buf)		\
@@ -131,7 +149,7 @@ static struct {
 	{ SAS_LINK_RATE_6_0_GBPS,	"6.0 Gbit" },
 };
 sas_bitfield_name_search(linkspeed, sas_linkspeed_names)
-
+sas_bitfield_name_set(linkspeed, sas_linkspeed_names)
 
 /*
  * SAS host attributes
@@ -253,10 +271,39 @@ show_sas_phy_##field(struct class_device *cdev, char *buf)		\
 	return get_sas_linkspeed_names(phy->field, buf);		\
 }
 
+/* Fudge to tell if we're minimum or maximum */
+#define sas_phy_store_linkspeed(field)					\
+static ssize_t								\
+store_sas_phy_##field(struct class_device *cdev, const char *buf,	\
+		      size_t count)					\
+{									\
+	struct sas_phy *phy = transport_class_to_phy(cdev);		\
+	struct Scsi_Host *shost = dev_to_shost(phy->dev.parent);	\
+	struct sas_internal *i = to_sas_internal(shost->transportt);	\
+	u32 value;							\
+	struct sas_phy_linkrates rates = {0};				\
+	int error;							\
+									\
+	error = set_sas_linkspeed_names(&value, buf);			\
+	if (error)							\
+		return error;						\
+	rates.field = value;						\
+	error = i->f->set_phy_speed(phy, &rates);			\
+									\
+	return error ? error : count;					\
+}
+
+#define sas_phy_linkspeed_rw_attr(field)				\
+	sas_phy_show_linkspeed(field)					\
+	sas_phy_store_linkspeed(field)					\
+static CLASS_DEVICE_ATTR(field, S_IRUGO, show_sas_phy_##field,		\
+	store_sas_phy_##field)
+
 #define sas_phy_linkspeed_attr(field)					\
 	sas_phy_show_linkspeed(field)					\
 static CLASS_DEVICE_ATTR(field, S_IRUGO, show_sas_phy_##field, NULL)
 
+
 #define sas_phy_show_linkerror(field)					\
 static ssize_t								\
 show_sas_phy_##field(struct class_device *cdev, char *buf)		\
@@ -326,9 +373,9 @@ sas_phy_simple_attr(identify.phy_identifier, phy_identifier, "%d\n", u8);
 //sas_phy_simple_attr(port_identifier, port_identifier, "%d\n", int);
 sas_phy_linkspeed_attr(negotiated_linkrate);
 sas_phy_linkspeed_attr(minimum_linkrate_hw);
-sas_phy_linkspeed_attr(minimum_linkrate);
+sas_phy_linkspeed_rw_attr(minimum_linkrate);
 sas_phy_linkspeed_attr(maximum_linkrate_hw);
-sas_phy_linkspeed_attr(maximum_linkrate);
+sas_phy_linkspeed_rw_attr(maximum_linkrate);
 sas_phy_linkerror_attr(invalid_dword_count);
 sas_phy_linkerror_attr(running_disparity_error_count);
 sas_phy_linkerror_attr(loss_of_dword_sync_count);
@@ -1310,13 +1357,23 @@ static int sas_user_scan(struct Scsi_Host *shost, uint channel,
  * Setup / Teardown code
  */
 
-#define SETUP_TEMPLATE(attrb, field, perm, test)				\
+#define SETUP_TEMPLATE(attrb, field, perm, test)			\
 	i->private_##attrb[count] = class_device_attr_##field;		\
 	i->private_##attrb[count].attr.mode = perm;			\
 	i->attrb[count] = &i->private_##attrb[count];			\
 	if (test)							\
 		count++
 
+#define SETUP_TEMPLATE_RW(attrb, field, perm, test, ro_test, ro_perm)	\
+	i->private_##attrb[count] = class_device_attr_##field;		\
+	i->private_##attrb[count].attr.mode = perm;			\
+	if (ro_test) {							\
+		i->private_##attrb[count].attr.mode = ro_perm;		\
+		i->private_##attrb[count].store = NULL;			\
+	}								\
+	i->attrb[count] = &i->private_##attrb[count];			\
+	if (test)							\
+		count++
 
 #define SETUP_RPORT_ATTRIBUTE(field) 					\
 	SETUP_TEMPLATE(rphy_attrs, field, S_IRUGO, 1)
@@ -1327,6 +1384,10 @@ static int sas_user_scan(struct Scsi_Host *shost, uint channel,
 #define SETUP_PHY_ATTRIBUTE(field)					\
 	SETUP_TEMPLATE(phy_attrs, field, S_IRUGO, 1)
 
+#define SETUP_PHY_ATTRIBUTE_RW(field)					\
+	SETUP_TEMPLATE_RW(phy_attrs, field, S_IRUGO | S_IWUSR, 1,	\
+			!i->f->set_phy_speed, S_IRUGO)
+
 #define SETUP_PORT_ATTRIBUTE(field)					\
 	SETUP_TEMPLATE(port_attrs, field, S_IRUGO, 1)
 
@@ -1407,9 +1468,9 @@ sas_attach_transport(struct sas_function_template *ft)
 	//SETUP_PHY_ATTRIBUTE(port_identifier);
 	SETUP_PHY_ATTRIBUTE(negotiated_linkrate);
 	SETUP_PHY_ATTRIBUTE(minimum_linkrate_hw);
-	SETUP_PHY_ATTRIBUTE(minimum_linkrate);
+	SETUP_PHY_ATTRIBUTE_RW(minimum_linkrate);
 	SETUP_PHY_ATTRIBUTE(maximum_linkrate_hw);
-	SETUP_PHY_ATTRIBUTE(maximum_linkrate);
+	SETUP_PHY_ATTRIBUTE_RW(maximum_linkrate);
 
 	SETUP_PHY_ATTRIBUTE(invalid_dword_count);
 	SETUP_PHY_ATTRIBUTE(running_disparity_error_count);

commit f4ad7b5807385ad1fed0347d966e51a797cd1013
Author: James Bottomley <James.Bottomley@steeleye.com>
Date:   Fri Aug 25 13:48:18 2006 -0500

    [SCSI] scsi_transport_sas: remove local_attached flag
    
    This flag denotes local attachment of the phy.  There are two problems
    with it:
    
    1) It's actually redundant ... you can get the same information simply
    by seeing whether a host is the phys parent
    2) we condition a lot of phy parameters on it on the false assumption
    that we can only control local phys.  I'm wiring up phy resets in the
    aic94xx now, and it will be able to reset non-local phys as well.
    
    I fixed 2) by moving the local check into the reset and stats function
    of the mptsas, since that seems to be the only HBA that can't
    (currently) control non-local phys.
    
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>

diff --git a/drivers/scsi/scsi_transport_sas.c b/drivers/scsi/scsi_transport_sas.c
index 5a625c3fddae..d518c1207fb4 100644
--- a/drivers/scsi/scsi_transport_sas.c
+++ b/drivers/scsi/scsi_transport_sas.c
@@ -266,9 +266,6 @@ show_sas_phy_##field(struct class_device *cdev, char *buf)		\
 	struct sas_internal *i = to_sas_internal(shost->transportt);	\
 	int error;							\
 									\
-	if (!phy->local_attached)					\
-		return -EINVAL;						\
-									\
 	error = i->f->get_linkerrors ? i->f->get_linkerrors(phy) : 0;	\
 	if (error)							\
 		return error;						\
@@ -299,9 +296,6 @@ static ssize_t do_sas_phy_reset(struct class_device *cdev,
 	struct sas_internal *i = to_sas_internal(shost->transportt);
 	int error;
 
-	if (!phy->local_attached)
-		return -EINVAL;
-
 	error = i->f->phy_reset(phy, hard_reset);
 	if (error)
 		return error;
@@ -849,7 +843,7 @@ show_sas_rphy_enclosure_identifier(struct class_device *cdev, char *buf)
 	 * Only devices behind an expander are supported, because the
 	 * enclosure identifier is a SMP feature.
 	 */
-	if (phy->local_attached)
+	if (scsi_is_sas_phy_local(phy))
 		return -EINVAL;
 
 	error = i->f->get_enclosure_identifier(rphy, &identifier);
@@ -870,7 +864,7 @@ show_sas_rphy_bay_identifier(struct class_device *cdev, char *buf)
 	struct sas_internal *i = to_sas_internal(shost->transportt);
 	int val;
 
-	if (phy->local_attached)
+	if (scsi_is_sas_phy_local(phy))
 		return -EINVAL;
 
 	val = i->f->get_bay_identifier(rphy);

commit e8bf39417b578a11e2ee2cd16e794a5b2d40757b
Author: James Bottomley <James.Bottomley@steeleye.com>
Date:   Tue Jul 11 17:49:34 2006 -0400

    [SCSI] scsi_transport_sas: kill the use of channel
    
    Using the port_id for the channel is completely unnecessary since the
    host_id/target_id are constructed to be globally unique.  Also move
    the mptsas driver on to virtual channel 1 for its raid devices.
    
    Acked-by: "Moore, Eric" <Eric.Moore@lsil.com>
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>

diff --git a/drivers/scsi/scsi_transport_sas.c b/drivers/scsi/scsi_transport_sas.c
index 7871bc25fafb..5a625c3fddae 100644
--- a/drivers/scsi/scsi_transport_sas.c
+++ b/drivers/scsi/scsi_transport_sas.c
@@ -1194,7 +1194,7 @@ int sas_rphy_add(struct sas_rphy *rphy)
 
 	if (identify->device_type == SAS_END_DEVICE &&
 	    rphy->scsi_target_id != -1) {
-		scsi_scan_target(&rphy->dev, parent->port_identifier,
+		scsi_scan_target(&rphy->dev, 0,
 				rphy->scsi_target_id, ~0, 0);
 	}
 
@@ -1296,15 +1296,13 @@ static int sas_user_scan(struct Scsi_Host *shost, uint channel,
 
 	mutex_lock(&sas_host->lock);
 	list_for_each_entry(rphy, &sas_host->rphy_list, list) {
-		struct sas_port *parent = dev_to_sas_port(rphy->dev.parent);
-
 		if (rphy->identify.device_type != SAS_END_DEVICE ||
 		    rphy->scsi_target_id == -1)
 			continue;
 
-		if ((channel == SCAN_WILD_CARD || channel == parent->port_identifier) &&
+		if ((channel == SCAN_WILD_CARD || channel == 0) &&
 		    (id == SCAN_WILD_CARD || id == rphy->scsi_target_id)) {
-			scsi_scan_target(&rphy->dev, parent->port_identifier,
+			scsi_scan_target(&rphy->dev, 0,
 					 rphy->scsi_target_id, lun, 1);
 		}
 	}

commit a0e1b6ef3b851fe6f1dcc259432e83de79ce5e7f
Author: James Bottomley <James.Bottomley@steeleye.com>
Date:   Sun Jul 9 12:38:19 2006 -0500

    [SCSI] scsi_transport_sas: add expander backlink
    
    This patch adds the ability to add a backlink to a particular port.  The
    idea is to represent properly ports on expanders that are used
    specifically for linking to the parent device in the topology.
    
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>

diff --git a/drivers/scsi/scsi_transport_sas.c b/drivers/scsi/scsi_transport_sas.c
index 9bb4e37a1a61..7871bc25fafb 100644
--- a/drivers/scsi/scsi_transport_sas.c
+++ b/drivers/scsi/scsi_transport_sas.c
@@ -692,6 +692,13 @@ void sas_port_delete(struct sas_port *port)
 	}
 	mutex_unlock(&port->phy_list_mutex);
 
+	if (port->is_backlink) {
+		struct device *parent = port->dev.parent;
+
+		sysfs_remove_link(&port->dev.kobj, parent->bus_id);
+		port->is_backlink = 0;
+	}
+
 	transport_remove_device(dev);
 	device_del(dev);
 	transport_destroy_device(dev);
@@ -767,6 +774,19 @@ void sas_port_delete_phy(struct sas_port *port, struct sas_phy *phy)
 }
 EXPORT_SYMBOL(sas_port_delete_phy);
 
+void sas_port_mark_backlink(struct sas_port *port)
+{
+	struct device *parent = port->dev.parent->parent->parent;
+
+	if (port->is_backlink)
+		return;
+	port->is_backlink = 1;
+	sysfs_create_link(&port->dev.kobj, &parent->kobj,
+			  parent->bus_id);
+
+}
+EXPORT_SYMBOL(sas_port_mark_backlink);
+
 /*
  * SAS remote PHY attributes.
  */

commit c9fefeb26457b87f4a767faefcf77321bb90db52
Author: James Bottomley <James.Bottomley@steeleye.com>
Date:   Sun Jul 2 11:10:18 2006 -0500

    [SCSI] scsi_transport_sas: add unindexed ports
    
    Some SAS HBAs don't want to go to the trouble of tracking port numbers,
    so they'd simply like to say "add this port and give it a number".
    This is especially beneficial from the hotplug point of view, since
    tracking ports and the available number space can be a real pain.
    
    The current implementation uses an incrementing number per expander to
    add the port on.  However, since there can never be more ports than
    there are phys, a later implementation will try to be more intelligent
    about this.
    
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>

diff --git a/drivers/scsi/scsi_transport_sas.c b/drivers/scsi/scsi_transport_sas.c
index dd075627e605..9bb4e37a1a61 100644
--- a/drivers/scsi/scsi_transport_sas.c
+++ b/drivers/scsi/scsi_transport_sas.c
@@ -41,6 +41,7 @@ struct sas_host_attrs {
 	struct mutex lock;
 	u32 next_target_id;
 	u32 next_expander_id;
+	int next_port_id;
 };
 #define to_sas_host_attrs(host)	((struct sas_host_attrs *)(host)->shost_data)
 
@@ -146,6 +147,7 @@ static int sas_host_setup(struct transport_container *tc, struct device *dev,
 	mutex_init(&sas_host->lock);
 	sas_host->next_target_id = 0;
 	sas_host->next_expander_id = 0;
+	sas_host->next_port_id = 0;
 	return 0;
 }
 
@@ -327,7 +329,7 @@ sas_phy_protocol_attr(identify.target_port_protocols,
 sas_phy_simple_attr(identify.sas_address, sas_address, "0x%016llx\n",
 		unsigned long long);
 sas_phy_simple_attr(identify.phy_identifier, phy_identifier, "%d\n", u8);
-//sas_phy_simple_attr(port_identifier, port_identifier, "%d\n", u8);
+//sas_phy_simple_attr(port_identifier, port_identifier, "%d\n", int);
 sas_phy_linkspeed_attr(negotiated_linkrate);
 sas_phy_linkspeed_attr(minimum_linkrate_hw);
 sas_phy_linkspeed_attr(minimum_linkrate);
@@ -590,6 +592,38 @@ struct sas_port *sas_port_alloc(struct device *parent, int port_id)
 }
 EXPORT_SYMBOL(sas_port_alloc);
 
+/** sas_port_alloc_num - allocate and initialize a SAS port structure
+ *
+ * @parent:	parent device
+ *
+ * Allocates a SAS port structure and a number to go with it.  This
+ * interface is really for adapters where the port number has no
+ * meansing, so the sas class should manage them.  It will be added to
+ * the device tree below the device specified by @parent which must be
+ * either a Scsi_Host or a sas_expander_device.
+ *
+ * Returns %NULL on error
+ */
+struct sas_port *sas_port_alloc_num(struct device *parent)
+{
+	int index;
+	struct Scsi_Host *shost = dev_to_shost(parent);
+	struct sas_host_attrs *sas_host = to_sas_host_attrs(shost);
+
+	/* FIXME: use idr for this eventually */
+	mutex_lock(&sas_host->lock);
+	if (scsi_is_sas_expander_device(parent)) {
+		struct sas_rphy *rphy = dev_to_rphy(parent);
+		struct sas_expander_device *exp = rphy_to_expander_device(rphy);
+
+		index = exp->next_port_id++;
+	} else
+		index = sas_host->next_port_id++;
+	mutex_unlock(&sas_host->lock);
+	return sas_port_alloc(parent, index);
+}
+EXPORT_SYMBOL(sas_port_alloc_num);
+
 /**
  * sas_port_add - add a SAS port to the device hierarchy
  *

commit 65c92b09acf0218b64f1c7ba4fdabeb8b732c876
Author: James Bottomley <James.Bottomley@steeleye.com>
Date:   Wed Jun 28 12:22:50 2006 -0400

    [SCSI] scsi_transport_sas: introduce a sas_port entity
    
    this patch introduces a port object, separates out ports and phys,
    with ports becoming the primary objects of the tree.
    
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>

diff --git a/drivers/scsi/scsi_transport_sas.c b/drivers/scsi/scsi_transport_sas.c
index 1fe6b2d01853..dd075627e605 100644
--- a/drivers/scsi/scsi_transport_sas.c
+++ b/drivers/scsi/scsi_transport_sas.c
@@ -174,11 +174,28 @@ static int sas_host_match(struct attribute_container *cont,
 
 static int do_sas_phy_delete(struct device *dev, void *data)
 {
-	if (scsi_is_sas_phy(dev))
+	int pass = (int)(unsigned long)data;
+
+	if (pass == 0 && scsi_is_sas_port(dev))
+		sas_port_delete(dev_to_sas_port(dev));
+	else if (pass == 1 && scsi_is_sas_phy(dev))
 		sas_phy_delete(dev_to_phy(dev));
 	return 0;
 }
 
+/**
+ * sas_remove_children  --  tear down a devices SAS data structures
+ * @dev:	device belonging to the sas object
+ *
+ * Removes all SAS PHYs and remote PHYs for a given object
+ */
+void sas_remove_children(struct device *dev)
+{
+	device_for_each_child(dev, (void *)0, do_sas_phy_delete);
+	device_for_each_child(dev, (void *)1, do_sas_phy_delete);
+}
+EXPORT_SYMBOL(sas_remove_children);
+
 /**
  * sas_remove_host  --  tear down a Scsi_Host's SAS data structures
  * @shost:	Scsi Host that is torn down
@@ -188,13 +205,13 @@ static int do_sas_phy_delete(struct device *dev, void *data)
  */
 void sas_remove_host(struct Scsi_Host *shost)
 {
-	device_for_each_child(&shost->shost_gendev, NULL, do_sas_phy_delete);
+	sas_remove_children(&shost->shost_gendev);
 }
 EXPORT_SYMBOL(sas_remove_host);
 
 
 /*
- * SAS Port attributes
+ * SAS Phy attributes
  */
 
 #define sas_phy_show_simple(field, name, format_string, cast)		\
@@ -310,7 +327,7 @@ sas_phy_protocol_attr(identify.target_port_protocols,
 sas_phy_simple_attr(identify.sas_address, sas_address, "0x%016llx\n",
 		unsigned long long);
 sas_phy_simple_attr(identify.phy_identifier, phy_identifier, "%d\n", u8);
-sas_phy_simple_attr(port_identifier, port_identifier, "%d\n", u8);
+//sas_phy_simple_attr(port_identifier, port_identifier, "%d\n", u8);
 sas_phy_linkspeed_attr(negotiated_linkrate);
 sas_phy_linkspeed_attr(minimum_linkrate_hw);
 sas_phy_linkspeed_attr(minimum_linkrate);
@@ -378,9 +395,10 @@ struct sas_phy *sas_phy_alloc(struct device *parent, int number)
 	device_initialize(&phy->dev);
 	phy->dev.parent = get_device(parent);
 	phy->dev.release = sas_phy_release;
+	INIT_LIST_HEAD(&phy->port_siblings);
 	if (scsi_is_sas_expander_device(parent)) {
 		struct sas_rphy *rphy = dev_to_rphy(parent);
-		sprintf(phy->dev.bus_id, "phy-%d-%d:%d", shost->host_no,
+		sprintf(phy->dev.bus_id, "phy-%d:%d:%d", shost->host_no,
 			rphy->scsi_target_id, number);
 	} else
 		sprintf(phy->dev.bus_id, "phy-%d:%d", shost->host_no, number);
@@ -440,8 +458,8 @@ sas_phy_delete(struct sas_phy *phy)
 {
 	struct device *dev = &phy->dev;
 
-	if (phy->rphy)
-		sas_rphy_delete(phy->rphy);
+	/* this happens if the phy is still part of a port when deleted */
+	BUG_ON(!list_empty(&phy->port_siblings));
 
 	transport_remove_device(dev);
 	device_del(dev);
@@ -463,6 +481,258 @@ int scsi_is_sas_phy(const struct device *dev)
 }
 EXPORT_SYMBOL(scsi_is_sas_phy);
 
+/*
+ * SAS Port attributes
+ */
+#define sas_port_show_simple(field, name, format_string, cast)		\
+static ssize_t								\
+show_sas_port_##name(struct class_device *cdev, char *buf)		\
+{									\
+	struct sas_port *port = transport_class_to_sas_port(cdev);	\
+									\
+	return snprintf(buf, 20, format_string, cast port->field);	\
+}
+
+#define sas_port_simple_attr(field, name, format_string, type)		\
+	sas_port_show_simple(field, name, format_string, (type))	\
+static CLASS_DEVICE_ATTR(name, S_IRUGO, show_sas_port_##name, NULL)
+
+sas_port_simple_attr(num_phys, num_phys, "%d\n", int);
+
+static DECLARE_TRANSPORT_CLASS(sas_port_class,
+			       "sas_port", NULL, NULL, NULL);
+
+static int sas_port_match(struct attribute_container *cont, struct device *dev)
+{
+	struct Scsi_Host *shost;
+	struct sas_internal *i;
+
+	if (!scsi_is_sas_port(dev))
+		return 0;
+	shost = dev_to_shost(dev->parent);
+
+	if (!shost->transportt)
+		return 0;
+	if (shost->transportt->host_attrs.ac.class !=
+			&sas_host_class.class)
+		return 0;
+
+	i = to_sas_internal(shost->transportt);
+	return &i->port_attr_cont.ac == cont;
+}
+
+
+static void sas_port_release(struct device *dev)
+{
+	struct sas_port *port = dev_to_sas_port(dev);
+
+	BUG_ON(!list_empty(&port->phy_list));
+
+	put_device(dev->parent);
+	kfree(port);
+}
+
+static void sas_port_create_link(struct sas_port *port,
+				 struct sas_phy *phy)
+{
+	sysfs_create_link(&port->dev.kobj, &phy->dev.kobj, phy->dev.bus_id);
+	sysfs_create_link(&phy->dev.kobj, &port->dev.kobj, "port");
+}
+
+static void sas_port_delete_link(struct sas_port *port,
+				 struct sas_phy *phy)
+{
+	sysfs_remove_link(&port->dev.kobj, phy->dev.bus_id);
+	sysfs_remove_link(&phy->dev.kobj, "port");
+}
+
+/** sas_port_alloc - allocate and initialize a SAS port structure
+ *
+ * @parent:	parent device
+ * @port_id:	port number
+ *
+ * Allocates a SAS port structure.  It will be added to the device tree
+ * below the device specified by @parent which must be either a Scsi_Host
+ * or a sas_expander_device.
+ *
+ * Returns %NULL on error
+ */
+struct sas_port *sas_port_alloc(struct device *parent, int port_id)
+{
+	struct Scsi_Host *shost = dev_to_shost(parent);
+	struct sas_port *port;
+
+	port = kzalloc(sizeof(*port), GFP_KERNEL);
+	if (!port)
+		return NULL;
+
+	port->port_identifier = port_id;
+
+	device_initialize(&port->dev);
+
+	port->dev.parent = get_device(parent);
+	port->dev.release = sas_port_release;
+
+	mutex_init(&port->phy_list_mutex);
+	INIT_LIST_HEAD(&port->phy_list);
+
+	if (scsi_is_sas_expander_device(parent)) {
+		struct sas_rphy *rphy = dev_to_rphy(parent);
+		sprintf(port->dev.bus_id, "port-%d:%d:%d", shost->host_no,
+			rphy->scsi_target_id, port->port_identifier);
+	} else
+		sprintf(port->dev.bus_id, "port-%d:%d", shost->host_no,
+			port->port_identifier);
+
+	transport_setup_device(&port->dev);
+
+	return port;
+}
+EXPORT_SYMBOL(sas_port_alloc);
+
+/**
+ * sas_port_add - add a SAS port to the device hierarchy
+ *
+ * @port:	port to be added
+ *
+ * publishes a port to the rest of the system
+ */
+int sas_port_add(struct sas_port *port)
+{
+	int error;
+
+	/* No phys should be added until this is made visible */
+	BUG_ON(!list_empty(&port->phy_list));
+
+	error = device_add(&port->dev);
+
+	if (error)
+		return error;
+
+	transport_add_device(&port->dev);
+	transport_configure_device(&port->dev);
+
+	return 0;
+}
+EXPORT_SYMBOL(sas_port_add);
+
+/**
+ * sas_port_free  --  free a SAS PORT
+ * @port:	SAS PORT to free
+ *
+ * Frees the specified SAS PORT.
+ *
+ * Note:
+ *   This function must only be called on a PORT that has not
+ *   sucessfully been added using sas_port_add().
+ */
+void sas_port_free(struct sas_port *port)
+{
+	transport_destroy_device(&port->dev);
+	put_device(&port->dev);
+}
+EXPORT_SYMBOL(sas_port_free);
+
+/**
+ * sas_port_delete  --  remove SAS PORT
+ * @port:	SAS PORT to remove
+ *
+ * Removes the specified SAS PORT.  If the SAS PORT has an
+ * associated phys, unlink them from the port as well.
+ */
+void sas_port_delete(struct sas_port *port)
+{
+	struct device *dev = &port->dev;
+	struct sas_phy *phy, *tmp_phy;
+
+	if (port->rphy) {
+		sas_rphy_delete(port->rphy);
+		port->rphy = NULL;
+	}
+
+	mutex_lock(&port->phy_list_mutex);
+	list_for_each_entry_safe(phy, tmp_phy, &port->phy_list,
+				 port_siblings) {
+		sas_port_delete_link(port, phy);
+		list_del_init(&phy->port_siblings);
+	}
+	mutex_unlock(&port->phy_list_mutex);
+
+	transport_remove_device(dev);
+	device_del(dev);
+	transport_destroy_device(dev);
+	put_device(dev);
+}
+EXPORT_SYMBOL(sas_port_delete);
+
+/**
+ * scsi_is_sas_port --  check if a struct device represents a SAS port
+ * @dev:	device to check
+ *
+ * Returns:
+ *	%1 if the device represents a SAS Port, %0 else
+ */
+int scsi_is_sas_port(const struct device *dev)
+{
+	return dev->release == sas_port_release;
+}
+EXPORT_SYMBOL(scsi_is_sas_port);
+
+/**
+ * sas_port_add_phy - add another phy to a port to form a wide port
+ * @port:	port to add the phy to
+ * @phy:	phy to add
+ *
+ * When a port is initially created, it is empty (has no phys).  All
+ * ports must have at least one phy to operated, and all wide ports
+ * must have at least two.  The current code makes no difference
+ * between ports and wide ports, but the only object that can be
+ * connected to a remote device is a port, so ports must be formed on
+ * all devices with phys if they're connected to anything.
+ */
+void sas_port_add_phy(struct sas_port *port, struct sas_phy *phy)
+{
+	mutex_lock(&port->phy_list_mutex);
+	if (unlikely(!list_empty(&phy->port_siblings))) {
+		/* make sure we're already on this port */
+		struct sas_phy *tmp;
+
+		list_for_each_entry(tmp, &port->phy_list, port_siblings)
+			if (tmp == phy)
+				break;
+		/* If this trips, you added a phy that was already
+		 * part of a different port */
+		if (unlikely(tmp != phy)) {
+			dev_printk(KERN_ERR, &port->dev, "trying to add phy %s fails: it's already part of another port\n", phy->dev.bus_id);
+			BUG();
+		}
+	} else {
+		sas_port_create_link(port, phy);
+		list_add_tail(&phy->port_siblings, &port->phy_list);
+		port->num_phys++;
+	}
+	mutex_unlock(&port->phy_list_mutex);
+}
+EXPORT_SYMBOL(sas_port_add_phy);
+
+/**
+ * sas_port_delete_phy - remove a phy from a port or wide port
+ * @port:	port to remove the phy from
+ * @phy:	phy to remove
+ *
+ * This operation is used for tearing down ports again.  It must be
+ * done to every port or wide port before calling sas_port_delete.
+ */
+void sas_port_delete_phy(struct sas_port *port, struct sas_phy *phy)
+{
+	mutex_lock(&port->phy_list_mutex);
+	sas_port_delete_link(port, phy);
+	list_del_init(&phy->port_siblings);
+	port->num_phys--;
+	mutex_unlock(&port->phy_list_mutex);
+}
+EXPORT_SYMBOL(sas_port_delete_phy);
+
 /*
  * SAS remote PHY attributes.
  */
@@ -767,7 +1037,7 @@ static void sas_rphy_initialize(struct sas_rphy *rphy)
  * Returns:
  *	SAS PHY allocated or %NULL if the allocation failed.
  */
-struct sas_rphy *sas_end_device_alloc(struct sas_phy *parent)
+struct sas_rphy *sas_end_device_alloc(struct sas_port *parent)
 {
 	struct Scsi_Host *shost = dev_to_shost(&parent->dev);
 	struct sas_end_device *rdev;
@@ -780,8 +1050,13 @@ struct sas_rphy *sas_end_device_alloc(struct sas_phy *parent)
 	device_initialize(&rdev->rphy.dev);
 	rdev->rphy.dev.parent = get_device(&parent->dev);
 	rdev->rphy.dev.release = sas_end_device_release;
-	sprintf(rdev->rphy.dev.bus_id, "end_device-%d:%d-%d",
-		shost->host_no, parent->port_identifier, parent->number);
+	if (scsi_is_sas_expander_device(parent->dev.parent)) {
+		struct sas_rphy *rphy = dev_to_rphy(parent->dev.parent);
+		sprintf(rdev->rphy.dev.bus_id, "end_device-%d:%d:%d",
+			shost->host_no, rphy->scsi_target_id, parent->port_identifier);
+	} else
+		sprintf(rdev->rphy.dev.bus_id, "end_device-%d:%d",
+			shost->host_no, parent->port_identifier);
 	rdev->rphy.identify.device_type = SAS_END_DEVICE;
 	sas_rphy_initialize(&rdev->rphy);
 	transport_setup_device(&rdev->rphy.dev);
@@ -798,7 +1073,7 @@ EXPORT_SYMBOL(sas_end_device_alloc);
  * Returns:
  *	SAS PHY allocated or %NULL if the allocation failed.
  */
-struct sas_rphy *sas_expander_alloc(struct sas_phy *parent,
+struct sas_rphy *sas_expander_alloc(struct sas_port *parent,
 				    enum sas_device_type type)
 {
 	struct Scsi_Host *shost = dev_to_shost(&parent->dev);
@@ -837,7 +1112,7 @@ EXPORT_SYMBOL(sas_expander_alloc);
  */
 int sas_rphy_add(struct sas_rphy *rphy)
 {
-	struct sas_phy *parent = dev_to_phy(rphy->dev.parent);
+	struct sas_port *parent = dev_to_sas_port(rphy->dev.parent);
 	struct Scsi_Host *shost = dev_to_shost(parent->dev.parent);
 	struct sas_host_attrs *sas_host = to_sas_host_attrs(shost);
 	struct sas_identify *identify = &rphy->identify;
@@ -910,7 +1185,7 @@ void
 sas_rphy_delete(struct sas_rphy *rphy)
 {
 	struct device *dev = &rphy->dev;
-	struct sas_phy *parent = dev_to_phy(dev->parent);
+	struct sas_port *parent = dev_to_sas_port(dev->parent);
 	struct Scsi_Host *shost = dev_to_shost(parent->dev.parent);
 	struct sas_host_attrs *sas_host = to_sas_host_attrs(shost);
 
@@ -920,7 +1195,7 @@ sas_rphy_delete(struct sas_rphy *rphy)
 		break;
 	case SAS_EDGE_EXPANDER_DEVICE:
 	case SAS_FANOUT_EXPANDER_DEVICE:
-		device_for_each_child(dev, NULL, do_sas_phy_delete);
+		sas_remove_children(dev);
 		break;
 	default:
 		break;
@@ -967,7 +1242,7 @@ static int sas_user_scan(struct Scsi_Host *shost, uint channel,
 
 	mutex_lock(&sas_host->lock);
 	list_for_each_entry(rphy, &sas_host->rphy_list, list) {
-		struct sas_phy *parent = dev_to_phy(rphy->dev.parent);
+		struct sas_port *parent = dev_to_sas_port(rphy->dev.parent);
 
 		if (rphy->identify.device_type != SAS_END_DEVICE ||
 		    rphy->scsi_target_id == -1)
@@ -1003,16 +1278,19 @@ static int sas_user_scan(struct Scsi_Host *shost, uint channel,
 #define SETUP_OPTIONAL_RPORT_ATTRIBUTE(field, func)			\
 	SETUP_TEMPLATE(rphy_attrs, field, S_IRUGO, i->f->func)
 
-#define SETUP_PORT_ATTRIBUTE(field)					\
+#define SETUP_PHY_ATTRIBUTE(field)					\
 	SETUP_TEMPLATE(phy_attrs, field, S_IRUGO, 1)
 
-#define SETUP_OPTIONAL_PORT_ATTRIBUTE(field, func)			\
+#define SETUP_PORT_ATTRIBUTE(field)					\
+	SETUP_TEMPLATE(port_attrs, field, S_IRUGO, 1)
+
+#define SETUP_OPTIONAL_PHY_ATTRIBUTE(field, func)			\
 	SETUP_TEMPLATE(phy_attrs, field, S_IRUGO, i->f->func)
 
-#define SETUP_PORT_ATTRIBUTE_WRONLY(field)				\
+#define SETUP_PHY_ATTRIBUTE_WRONLY(field)				\
 	SETUP_TEMPLATE(phy_attrs, field, S_IWUGO, 1)
 
-#define SETUP_OPTIONAL_PORT_ATTRIBUTE_WRONLY(field, func)		\
+#define SETUP_OPTIONAL_PHY_ATTRIBUTE_WRONLY(field, func)		\
 	SETUP_TEMPLATE(phy_attrs, field, S_IWUGO, i->f->func)
 
 #define SETUP_END_DEV_ATTRIBUTE(field)					\
@@ -1048,6 +1326,11 @@ sas_attach_transport(struct sas_function_template *ft)
 	i->phy_attr_cont.ac.match = sas_phy_match;
 	transport_container_register(&i->phy_attr_cont);
 
+	i->port_attr_cont.ac.class = &sas_port_class.class;
+	i->port_attr_cont.ac.attrs = &i->port_attrs[0];
+	i->port_attr_cont.ac.match = sas_port_match;
+	transport_container_register(&i->port_attr_cont);
+
 	i->rphy_attr_cont.ac.class = &sas_rphy_class.class;
 	i->rphy_attr_cont.ac.attrs = &i->rphy_attrs[0];
 	i->rphy_attr_cont.ac.match = sas_rphy_match;
@@ -1066,29 +1349,34 @@ sas_attach_transport(struct sas_function_template *ft)
 	i->f = ft;
 
 	count = 0;
+	SETUP_PORT_ATTRIBUTE(num_phys);
 	i->host_attrs[count] = NULL;
 
 	count = 0;
-	SETUP_PORT_ATTRIBUTE(initiator_port_protocols);
-	SETUP_PORT_ATTRIBUTE(target_port_protocols);
-	SETUP_PORT_ATTRIBUTE(device_type);
-	SETUP_PORT_ATTRIBUTE(sas_address);
-	SETUP_PORT_ATTRIBUTE(phy_identifier);
-	SETUP_PORT_ATTRIBUTE(port_identifier);
-	SETUP_PORT_ATTRIBUTE(negotiated_linkrate);
-	SETUP_PORT_ATTRIBUTE(minimum_linkrate_hw);
-	SETUP_PORT_ATTRIBUTE(minimum_linkrate);
-	SETUP_PORT_ATTRIBUTE(maximum_linkrate_hw);
-	SETUP_PORT_ATTRIBUTE(maximum_linkrate);
-
-	SETUP_PORT_ATTRIBUTE(invalid_dword_count);
-	SETUP_PORT_ATTRIBUTE(running_disparity_error_count);
-	SETUP_PORT_ATTRIBUTE(loss_of_dword_sync_count);
-	SETUP_PORT_ATTRIBUTE(phy_reset_problem_count);
-	SETUP_OPTIONAL_PORT_ATTRIBUTE_WRONLY(link_reset, phy_reset);
-	SETUP_OPTIONAL_PORT_ATTRIBUTE_WRONLY(hard_reset, phy_reset);
+	SETUP_PHY_ATTRIBUTE(initiator_port_protocols);
+	SETUP_PHY_ATTRIBUTE(target_port_protocols);
+	SETUP_PHY_ATTRIBUTE(device_type);
+	SETUP_PHY_ATTRIBUTE(sas_address);
+	SETUP_PHY_ATTRIBUTE(phy_identifier);
+	//SETUP_PHY_ATTRIBUTE(port_identifier);
+	SETUP_PHY_ATTRIBUTE(negotiated_linkrate);
+	SETUP_PHY_ATTRIBUTE(minimum_linkrate_hw);
+	SETUP_PHY_ATTRIBUTE(minimum_linkrate);
+	SETUP_PHY_ATTRIBUTE(maximum_linkrate_hw);
+	SETUP_PHY_ATTRIBUTE(maximum_linkrate);
+
+	SETUP_PHY_ATTRIBUTE(invalid_dword_count);
+	SETUP_PHY_ATTRIBUTE(running_disparity_error_count);
+	SETUP_PHY_ATTRIBUTE(loss_of_dword_sync_count);
+	SETUP_PHY_ATTRIBUTE(phy_reset_problem_count);
+	SETUP_OPTIONAL_PHY_ATTRIBUTE_WRONLY(link_reset, phy_reset);
+	SETUP_OPTIONAL_PHY_ATTRIBUTE_WRONLY(hard_reset, phy_reset);
 	i->phy_attrs[count] = NULL;
 
+	count = 0;
+	SETUP_PORT_ATTRIBUTE(num_phys);
+	i->port_attrs[count] = NULL;
+
 	count = 0;
 	SETUP_RPORT_ATTRIBUTE(rphy_initiator_port_protocols);
 	SETUP_RPORT_ATTRIBUTE(rphy_target_port_protocols);
@@ -1131,6 +1419,7 @@ void sas_release_transport(struct scsi_transport_template *t)
 
 	transport_container_unregister(&i->t.host_attrs);
 	transport_container_unregister(&i->phy_attr_cont);
+	transport_container_unregister(&i->port_attr_cont);
 	transport_container_unregister(&i->rphy_attr_cont);
 	transport_container_unregister(&i->end_dev_attr_cont);
 	transport_container_unregister(&i->expander_attr_cont);
@@ -1149,9 +1438,12 @@ static __init int sas_transport_init(void)
 	error = transport_class_register(&sas_phy_class);
 	if (error)
 		goto out_unregister_transport;
-	error = transport_class_register(&sas_rphy_class);
+	error = transport_class_register(&sas_port_class);
 	if (error)
 		goto out_unregister_phy;
+	error = transport_class_register(&sas_rphy_class);
+	if (error)
+		goto out_unregister_port;
 	error = transport_class_register(&sas_end_dev_class);
 	if (error)
 		goto out_unregister_rphy;
@@ -1165,6 +1457,8 @@ static __init int sas_transport_init(void)
 	transport_class_unregister(&sas_end_dev_class);
  out_unregister_rphy:
 	transport_class_unregister(&sas_rphy_class);
+ out_unregister_port:
+	transport_class_unregister(&sas_port_class);
  out_unregister_phy:
 	transport_class_unregister(&sas_phy_class);
  out_unregister_transport:
@@ -1178,6 +1472,7 @@ static void __exit sas_transport_exit(void)
 {
 	transport_class_unregister(&sas_host_class);
 	transport_class_unregister(&sas_phy_class);
+	transport_class_unregister(&sas_port_class);
 	transport_class_unregister(&sas_rphy_class);
 	transport_class_unregister(&sas_end_dev_class);
 	transport_class_unregister(&sas_expander_class);

commit c5943d36aebb79589ac3983eec418bbeca897573
Author: James Bottomley <James.Bottomley@steeleye.com>
Date:   Mon Jun 12 09:09:18 2006 -0500

    [SCSI] scsi_transport_sas: fix panic in sas_free_rphy
    
    This is a hold over from the end device/expander conversion.  Apparently
    the rphy list pointer is never initialised, so list_del() on the
    uninitialised pointer can panic the system
    
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>

diff --git a/drivers/scsi/scsi_transport_sas.c b/drivers/scsi/scsi_transport_sas.c
index 6da6721eb0db..1fe6b2d01853 100644
--- a/drivers/scsi/scsi_transport_sas.c
+++ b/drivers/scsi/scsi_transport_sas.c
@@ -747,6 +747,18 @@ static void sas_end_device_release(struct device *dev)
 	kfree(edev);
 }
 
+/**
+ * sas_rphy_initialize - common rphy intialization
+ * @rphy:	rphy to initialise
+ *
+ * Used by both sas_end_device_alloc() and sas_expander_alloc() to
+ * initialise the common rphy component of each.
+ */
+static void sas_rphy_initialize(struct sas_rphy *rphy)
+{
+	INIT_LIST_HEAD(&rphy->list);
+}
+
 /**
  * sas_end_device_alloc - allocate an rphy for an end device
  *
@@ -771,6 +783,7 @@ struct sas_rphy *sas_end_device_alloc(struct sas_phy *parent)
 	sprintf(rdev->rphy.dev.bus_id, "end_device-%d:%d-%d",
 		shost->host_no, parent->port_identifier, parent->number);
 	rdev->rphy.identify.device_type = SAS_END_DEVICE;
+	sas_rphy_initialize(&rdev->rphy);
 	transport_setup_device(&rdev->rphy.dev);
 
 	return &rdev->rphy;
@@ -809,6 +822,7 @@ struct sas_rphy *sas_expander_alloc(struct sas_phy *parent,
 	sprintf(rdev->rphy.dev.bus_id, "expander-%d:%d",
 		shost->host_no, rdev->rphy.scsi_target_id);
 	rdev->rphy.identify.device_type = type;
+	sas_rphy_initialize(&rdev->rphy);
 	transport_setup_device(&rdev->rphy.dev);
 
 	return &rdev->rphy;

commit f0cd91a68acdc9b49d7f6738b514a426da627649
Merge: 60eef25701d2 128e6ced247c
Author: James Bottomley <jejb@mulgrave.il.steeleye.com>
Date:   Sat Jun 10 13:47:26 2006 -0500

    Merge ../linux-2.6

commit 6391a11375de5e2bb1eb8481e54619761dc65d9f
Author: Tobias Klauser <tklauser@nuerscht.ch>
Date:   Thu Jun 8 22:23:48 2006 -0700

    [SCSI] drivers/scsi: Use ARRAY_SIZE macro
    
    Use ARRAY_SIZE macro instead of sizeof(x)/sizeof(x[0]) and remove
    duplicates of the macro.
    
    Signed-off-by: Tobias Klauser <tklauser@nuerscht.ch>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>

diff --git a/drivers/scsi/scsi_transport_sas.c b/drivers/scsi/scsi_transport_sas.c
index 8b6d65e21bae..ce4f806bd8ec 100644
--- a/drivers/scsi/scsi_transport_sas.c
+++ b/drivers/scsi/scsi_transport_sas.c
@@ -65,7 +65,7 @@ get_sas_##title##_names(u32 table_key, char *buf)		\
 	ssize_t len = 0;					\
 	int i;							\
 								\
-	for (i = 0; i < sizeof(table)/sizeof(table[0]); i++) {	\
+	for (i = 0; i < ARRAY_SIZE(table); i++) {		\
 		if (table[i].value & table_key) {		\
 			len += sprintf(buf + len, "%s%s",	\
 				prefix, table[i].name);		\
@@ -83,7 +83,7 @@ get_sas_##title##_names(u32 table_key, char *buf)		\
 	ssize_t len = 0;					\
 	int i;							\
 								\
-	for (i = 0; i < sizeof(table)/sizeof(table[0]); i++) {	\
+	for (i = 0; i < ARRAY_SIZE(table); i++) {		\
 		if (table[i].value == table_key) {		\
 			len += sprintf(buf + len, "%s",		\
 				table[i].name);			\

commit 9f434d4f84a235f6b61aec6e691d6b07bc46fc24
Author: Eric Moore <eric.moore@lsil.com>
Date:   Wed May 17 18:19:43 2006 -0600

    [SCSI] scsi_transport_sas: make write attrs writeable
    
    A couple write attributes in sas transport layer have a small
    bug that prevents them from being written to.  Those
    attributes are the link_reset and write_reset.  This is due
    the store field being set to NULL.
    
    Signed-off-by: Eric Moore <Eric.Moore@lsil.com>
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>

diff --git a/drivers/scsi/scsi_transport_sas.c b/drivers/scsi/scsi_transport_sas.c
index 8126c395de16..f3b16066387c 100644
--- a/drivers/scsi/scsi_transport_sas.c
+++ b/drivers/scsi/scsi_transport_sas.c
@@ -978,7 +978,6 @@ static int sas_user_scan(struct Scsi_Host *shost, uint channel,
 #define SETUP_TEMPLATE(attrb, field, perm, test)				\
 	i->private_##attrb[count] = class_device_attr_##field;		\
 	i->private_##attrb[count].attr.mode = perm;			\
-	i->private_##attrb[count].store = NULL;				\
 	i->attrb[count] = &i->private_##attrb[count];			\
 	if (test)							\
 		count++

commit 6d99a3f372181160a56d7b1ee3259dbe03663f0d
Author: James Bottomley <James.Bottomley@steeleye.com>
Date:   Fri May 19 10:49:37 2006 -0500

    [SCSI] scsi_transport_sas; fix user_scan
    
    the user_scan() callback currently has the potential to identify the
    wrong device in the presence of expanders.  This is because it finds
    the first device with a matching target_id, which might be an
    expander.  Fix this by making it look specifically for end devices.
    
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>

diff --git a/drivers/scsi/scsi_transport_sas.c b/drivers/scsi/scsi_transport_sas.c
index 8b6d65e21bae..8126c395de16 100644
--- a/drivers/scsi/scsi_transport_sas.c
+++ b/drivers/scsi/scsi_transport_sas.c
@@ -955,7 +955,8 @@ static int sas_user_scan(struct Scsi_Host *shost, uint channel,
 	list_for_each_entry(rphy, &sas_host->rphy_list, list) {
 		struct sas_phy *parent = dev_to_phy(rphy->dev.parent);
 
-		if (rphy->scsi_target_id == -1)
+		if (rphy->identify.device_type != SAS_END_DEVICE ||
+		    rphy->scsi_target_id == -1)
 			continue;
 
 		if ((channel == SCAN_WILD_CARD || channel == parent->port_identifier) &&

commit 7676f83aeb774e7a3abe6af06ec92b29488b5b79
Author: James Bottomley <James.Bottomley@steeleye.com>
Date:   Fri Apr 14 09:47:59 2006 -0500

    [SCSI] scsi_transport_sas: don't scan a non-existent end device
    
    Any end device that can't support any of the scanning protocols
    shouldn't be scanned, so set its id to -1 to prevent
    scsi_scan_target() being called for it.
    
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>

diff --git a/drivers/scsi/scsi_transport_sas.c b/drivers/scsi/scsi_transport_sas.c
index 2c96fc5683ff..8b6d65e21bae 100644
--- a/drivers/scsi/scsi_transport_sas.c
+++ b/drivers/scsi/scsi_transport_sas.c
@@ -845,6 +845,8 @@ int sas_rphy_add(struct sas_rphy *rphy)
 	    (identify->target_port_protocols &
 	     (SAS_PROTOCOL_SSP|SAS_PROTOCOL_STP|SAS_PROTOCOL_SATA)))
 		rphy->scsi_target_id = sas_host->next_target_id++;
+	else if (identify->device_type == SAS_END_DEVICE)
+		rphy->scsi_target_id = -1;
 	mutex_unlock(&sas_host->lock);
 
 	if (identify->device_type == SAS_END_DEVICE &&

commit d6159c17c2c76963a8067d1e1ac3c4c36c05e674
Author: James Bottomley <James.Bottomley@steeleye.com>
Date:   Mon Mar 27 16:45:34 2006 -0600

    [SCSI] expose sas internal class for the domain transport
    
    necessary to make the domain class use the internal structures
    
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>

diff --git a/drivers/scsi/scsi_transport_sas.c b/drivers/scsi/scsi_transport_sas.c
index f6f7fecc0ad1..2c96fc5683ff 100644
--- a/drivers/scsi/scsi_transport_sas.c
+++ b/drivers/scsi/scsi_transport_sas.c
@@ -35,40 +35,7 @@
 #include <scsi/scsi_transport.h>
 #include <scsi/scsi_transport_sas.h>
 
-
-#define SAS_HOST_ATTRS		0
-#define SAS_PORT_ATTRS		17
-#define SAS_RPORT_ATTRS		7
-#define SAS_END_DEV_ATTRS	3
-#define SAS_EXPANDER_ATTRS	7
-
-struct sas_internal {
-	struct scsi_transport_template t;
-	struct sas_function_template *f;
-
-	struct class_device_attribute private_host_attrs[SAS_HOST_ATTRS];
-	struct class_device_attribute private_phy_attrs[SAS_PORT_ATTRS];
-	struct class_device_attribute private_rphy_attrs[SAS_RPORT_ATTRS];
-	struct class_device_attribute private_end_dev_attrs[SAS_END_DEV_ATTRS];
-	struct class_device_attribute private_expander_attrs[SAS_EXPANDER_ATTRS];
-
-	struct transport_container phy_attr_cont;
-	struct transport_container rphy_attr_cont;
-	struct transport_container end_dev_attr_cont;
-	struct transport_container expander_attr_cont;
-
-	/*
-	 * The array of null terminated pointers to attributes
-	 * needed by scsi_sysfs.c
-	 */
-	struct class_device_attribute *host_attrs[SAS_HOST_ATTRS + 1];
-	struct class_device_attribute *phy_attrs[SAS_PORT_ATTRS + 1];
-	struct class_device_attribute *rphy_attrs[SAS_RPORT_ATTRS + 1];
-	struct class_device_attribute *end_dev_attrs[SAS_END_DEV_ATTRS + 1];
-	struct class_device_attribute *expander_attrs[SAS_EXPANDER_ATTRS + 1];
-};
-#define to_sas_internal(tmpl)	container_of(tmpl, struct sas_internal, t)
-
+#include "scsi_sas_internal.h"
 struct sas_host_attrs {
 	struct list_head rphy_list;
 	struct mutex lock;

commit 92aab6464be735139f9ea38fd039c3b84c722630
Author: Mike Anderson <andmike@us.ibm.com>
Date:   Mon Mar 27 09:37:28 2006 -0800

    [SCSI] sas transport: ref count update
    
    Fix puts so that release functions will be called.
    
    Signed-off-by: Mike Anderson <andmike@us.ibm.com>
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>

diff --git a/drivers/scsi/scsi_transport_sas.c b/drivers/scsi/scsi_transport_sas.c
index 134c44c8538a..f6f7fecc0ad1 100644
--- a/drivers/scsi/scsi_transport_sas.c
+++ b/drivers/scsi/scsi_transport_sas.c
@@ -406,8 +406,6 @@ struct sas_phy *sas_phy_alloc(struct device *parent, int number)
 	if (!phy)
 		return NULL;
 
-	get_device(parent);
-
 	phy->number = number;
 
 	device_initialize(&phy->dev);
@@ -459,10 +457,7 @@ EXPORT_SYMBOL(sas_phy_add);
 void sas_phy_free(struct sas_phy *phy)
 {
 	transport_destroy_device(&phy->dev);
-	put_device(phy->dev.parent);
-	put_device(phy->dev.parent);
-	put_device(phy->dev.parent);
-	kfree(phy);
+	put_device(&phy->dev);
 }
 EXPORT_SYMBOL(sas_phy_free);
 
@@ -484,7 +479,7 @@ sas_phy_delete(struct sas_phy *phy)
 	transport_remove_device(dev);
 	device_del(dev);
 	transport_destroy_device(dev);
-	put_device(dev->parent);
+	put_device(dev);
 }
 EXPORT_SYMBOL(sas_phy_delete);
 
@@ -800,7 +795,6 @@ struct sas_rphy *sas_end_device_alloc(struct sas_phy *parent)
 
 	rdev = kzalloc(sizeof(*rdev), GFP_KERNEL);
 	if (!rdev) {
-		put_device(&parent->dev);
 		return NULL;
 	}
 
@@ -836,7 +830,6 @@ struct sas_rphy *sas_expander_alloc(struct sas_phy *parent,
 
 	rdev = kzalloc(sizeof(*rdev), GFP_KERNEL);
 	if (!rdev) {
-		put_device(&parent->dev);
 		return NULL;
 	}
 
@@ -910,6 +903,7 @@ EXPORT_SYMBOL(sas_rphy_add);
  */
 void sas_rphy_free(struct sas_rphy *rphy)
 {
+	struct device *dev = &rphy->dev;
 	struct Scsi_Host *shost = dev_to_shost(rphy->dev.parent->parent);
 	struct sas_host_attrs *sas_host = to_sas_host_attrs(shost);
 
@@ -917,21 +911,9 @@ void sas_rphy_free(struct sas_rphy *rphy)
 	list_del(&rphy->list);
 	mutex_unlock(&sas_host->lock);
 
-	transport_destroy_device(&rphy->dev);
-	put_device(rphy->dev.parent);
-	put_device(rphy->dev.parent);
-	put_device(rphy->dev.parent);
-	if (rphy->identify.device_type == SAS_END_DEVICE) {
-		struct sas_end_device *edev = rphy_to_end_device(rphy);
-
-		kfree(edev);
-	} else {
-		/* must be expander */
-		struct sas_expander_device *edev =
-			rphy_to_expander_device(rphy);
+	transport_destroy_device(dev);
 
-		kfree(edev);
-	}
+	put_device(dev);
 }
 EXPORT_SYMBOL(sas_rphy_free);
 
@@ -971,7 +953,7 @@ sas_rphy_delete(struct sas_rphy *rphy)
 
 	parent->rphy = NULL;
 
-	put_device(&parent->dev);
+	put_device(dev);
 }
 EXPORT_SYMBOL(sas_rphy_delete);
 

commit 2f8600dff2b140096a7df781884e918a16aa90e0
Author: James Bottomley <James.Bottomley@steeleye.com>
Date:   Sat Mar 18 15:00:50 2006 -0600

    [SCSI] eliminate rphy allocation in favour of expander/end device allocation
    
    This allows the removal of the contained flag and also does a bit of
    class renaming (sas_rphy->sas_device).
    
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>

diff --git a/drivers/scsi/scsi_transport_sas.c b/drivers/scsi/scsi_transport_sas.c
index 5a70d04352cc..134c44c8538a 100644
--- a/drivers/scsi/scsi_transport_sas.c
+++ b/drivers/scsi/scsi_transport_sas.c
@@ -699,7 +699,7 @@ sas_expander_simple_attr(component_revision_id, component_revision_id, "%u\n",
 sas_expander_simple_attr(level, level, "%d\n", int);
 
 static DECLARE_TRANSPORT_CLASS(sas_rphy_class,
-		"sas_rphy", NULL, NULL, NULL);
+		"sas_device", NULL, NULL, NULL);
 
 static int sas_rphy_match(struct attribute_container *cont, struct device *dev)
 {
@@ -740,9 +740,7 @@ static int sas_end_dev_match(struct attribute_container *cont,
 
 	i = to_sas_internal(shost->transportt);
 	return &i->end_dev_attr_cont.ac == cont &&
-		rphy->identify.device_type == SAS_END_DEVICE &&
-		/* FIXME: remove contained eventually */
-		rphy->contained;
+		rphy->identify.device_type == SAS_END_DEVICE;
 }
 
 static int sas_expander_match(struct attribute_container *cont,
@@ -766,49 +764,26 @@ static int sas_expander_match(struct attribute_container *cont,
 	i = to_sas_internal(shost->transportt);
 	return &i->expander_attr_cont.ac == cont &&
 		(rphy->identify.device_type == SAS_EDGE_EXPANDER_DEVICE ||
-		 rphy->identify.device_type == SAS_FANOUT_EXPANDER_DEVICE) &&
-		/* FIXME: remove contained eventually */
-		rphy->contained;
+		 rphy->identify.device_type == SAS_FANOUT_EXPANDER_DEVICE);
 }
 
-static void sas_rphy_release(struct device *dev)
+static void sas_expander_release(struct device *dev)
 {
 	struct sas_rphy *rphy = dev_to_rphy(dev);
+	struct sas_expander_device *edev = rphy_to_expander_device(rphy);
 
 	put_device(dev->parent);
-	kfree(rphy);
+	kfree(edev);
 }
 
-/**
- * sas_rphy_alloc  --  allocates and initialize a SAS remote PHY structure
- * @parent:		SAS PHY this remote PHY is conneted to
- *
- * Allocates an SAS remote PHY structure, connected to @parent.
- *
- * Returns:
- *	SAS PHY allocated or %NULL if the allocation failed.
- */
-struct sas_rphy *sas_rphy_alloc(struct sas_phy *parent)
+static void sas_end_device_release(struct device *dev)
 {
-	struct Scsi_Host *shost = dev_to_shost(&parent->dev);
-	struct sas_rphy *rphy;
-
-	rphy = kzalloc(sizeof(*rphy), GFP_KERNEL);
-	if (!rphy) {
-		put_device(&parent->dev);
-		return NULL;
-	}
-
-	device_initialize(&rphy->dev);
-	rphy->dev.parent = get_device(&parent->dev);
-	rphy->dev.release = sas_rphy_release;
-	sprintf(rphy->dev.bus_id, "rphy-%d:%d-%d",
-		shost->host_no, parent->port_identifier, parent->number);
-	transport_setup_device(&rphy->dev);
+	struct sas_rphy *rphy = dev_to_rphy(dev);
+	struct sas_end_device *edev = rphy_to_end_device(rphy);
 
-	return rphy;
+	put_device(dev->parent);
+	kfree(edev);
 }
-EXPORT_SYMBOL(sas_rphy_alloc);
 
 /**
  * sas_end_device_alloc - allocate an rphy for an end device
@@ -831,12 +806,10 @@ struct sas_rphy *sas_end_device_alloc(struct sas_phy *parent)
 
 	device_initialize(&rdev->rphy.dev);
 	rdev->rphy.dev.parent = get_device(&parent->dev);
-	rdev->rphy.dev.release = sas_rphy_release;
-	sprintf(rdev->rphy.dev.bus_id, "rphy-%d:%d-%d",
+	rdev->rphy.dev.release = sas_end_device_release;
+	sprintf(rdev->rphy.dev.bus_id, "end_device-%d:%d-%d",
 		shost->host_no, parent->port_identifier, parent->number);
 	rdev->rphy.identify.device_type = SAS_END_DEVICE;
-	/* FIXME: mark the rphy as being contained in a larger structure */
-	rdev->rphy.contained = 1;
 	transport_setup_device(&rdev->rphy.dev);
 
 	return &rdev->rphy;
@@ -869,15 +842,13 @@ struct sas_rphy *sas_expander_alloc(struct sas_phy *parent,
 
 	device_initialize(&rdev->rphy.dev);
 	rdev->rphy.dev.parent = get_device(&parent->dev);
-	rdev->rphy.dev.release = sas_rphy_release;
+	rdev->rphy.dev.release = sas_expander_release;
 	mutex_lock(&sas_host->lock);
 	rdev->rphy.scsi_target_id = sas_host->next_expander_id++;
 	mutex_unlock(&sas_host->lock);
 	sprintf(rdev->rphy.dev.bus_id, "expander-%d:%d",
 		shost->host_no, rdev->rphy.scsi_target_id);
 	rdev->rphy.identify.device_type = type;
-	/* FIXME: mark the rphy as being contained in a larger structure */
-	rdev->rphy.contained = 1;
 	transport_setup_device(&rdev->rphy.dev);
 
 	return &rdev->rphy;
@@ -950,7 +921,17 @@ void sas_rphy_free(struct sas_rphy *rphy)
 	put_device(rphy->dev.parent);
 	put_device(rphy->dev.parent);
 	put_device(rphy->dev.parent);
-	kfree(rphy);
+	if (rphy->identify.device_type == SAS_END_DEVICE) {
+		struct sas_end_device *edev = rphy_to_end_device(rphy);
+
+		kfree(edev);
+	} else {
+		/* must be expander */
+		struct sas_expander_device *edev =
+			rphy_to_expander_device(rphy);
+
+		kfree(edev);
+	}
 }
 EXPORT_SYMBOL(sas_rphy_free);
 
@@ -1003,7 +984,8 @@ EXPORT_SYMBOL(sas_rphy_delete);
  */
 int scsi_is_sas_rphy(const struct device *dev)
 {
-	return dev->release == sas_rphy_release;
+	return dev->release == sas_end_device_release ||
+		dev->release == sas_expander_release;
 }
 EXPORT_SYMBOL(scsi_is_sas_rphy);
 

commit 79cb1819e231f811211133a09a5382cb89d7ec67
Author: James Bottomley <James.Bottomley@steeleye.com>
Date:   Mon Mar 13 13:50:04 2006 -0600

    [SCSI] add preliminary expander support to the sas transport class
    
    This patch makes expanders appear as labelled objects with properties in
    the SAS tree.
    
    I've also modified the phy code to make expander phys appear labelled by
    host number, expander number and phy index.
    
    So, for my current config, you see something like this in sysfs:
    
    /sys/class/scsi_host/host1/device/phy-1:4/expander-1:0/phy-1-0:12/rphy-1:0-12/target1:0:1
    
    And the expander properties are:
    
    jejb@sparkweed> cd /sys/class/sas_expander/expander-1\:0/
    jejb@sparkweed> for f in *; do echo -n $f ": "; cat $f; done
    component_id : 29024
    component_revision_id : 4
    component_vendor_id : VITESSE
    device : cat: device: Is a directory
    level : 0
    product_id : VSC7160 Eval Brd
    product_rev : 4
    uevent : cat: uevent: Permission denied
    vendor_id : VITESSE
    
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>

diff --git a/drivers/scsi/scsi_transport_sas.c b/drivers/scsi/scsi_transport_sas.c
index 3eb11a175904..5a70d04352cc 100644
--- a/drivers/scsi/scsi_transport_sas.c
+++ b/drivers/scsi/scsi_transport_sas.c
@@ -40,6 +40,7 @@
 #define SAS_PORT_ATTRS		17
 #define SAS_RPORT_ATTRS		7
 #define SAS_END_DEV_ATTRS	3
+#define SAS_EXPANDER_ATTRS	7
 
 struct sas_internal {
 	struct scsi_transport_template t;
@@ -49,10 +50,12 @@ struct sas_internal {
 	struct class_device_attribute private_phy_attrs[SAS_PORT_ATTRS];
 	struct class_device_attribute private_rphy_attrs[SAS_RPORT_ATTRS];
 	struct class_device_attribute private_end_dev_attrs[SAS_END_DEV_ATTRS];
+	struct class_device_attribute private_expander_attrs[SAS_EXPANDER_ATTRS];
 
 	struct transport_container phy_attr_cont;
 	struct transport_container rphy_attr_cont;
 	struct transport_container end_dev_attr_cont;
+	struct transport_container expander_attr_cont;
 
 	/*
 	 * The array of null terminated pointers to attributes
@@ -62,6 +65,7 @@ struct sas_internal {
 	struct class_device_attribute *phy_attrs[SAS_PORT_ATTRS + 1];
 	struct class_device_attribute *rphy_attrs[SAS_RPORT_ATTRS + 1];
 	struct class_device_attribute *end_dev_attrs[SAS_END_DEV_ATTRS + 1];
+	struct class_device_attribute *expander_attrs[SAS_EXPANDER_ATTRS + 1];
 };
 #define to_sas_internal(tmpl)	container_of(tmpl, struct sas_internal, t)
 
@@ -69,6 +73,7 @@ struct sas_host_attrs {
 	struct list_head rphy_list;
 	struct mutex lock;
 	u32 next_target_id;
+	u32 next_expander_id;
 };
 #define to_sas_host_attrs(host)	((struct sas_host_attrs *)(host)->shost_data)
 
@@ -173,6 +178,7 @@ static int sas_host_setup(struct transport_container *tc, struct device *dev,
 	INIT_LIST_HEAD(&sas_host->rphy_list);
 	mutex_init(&sas_host->lock);
 	sas_host->next_target_id = 0;
+	sas_host->next_expander_id = 0;
 	return 0;
 }
 
@@ -407,7 +413,12 @@ struct sas_phy *sas_phy_alloc(struct device *parent, int number)
 	device_initialize(&phy->dev);
 	phy->dev.parent = get_device(parent);
 	phy->dev.release = sas_phy_release;
-	sprintf(phy->dev.bus_id, "phy-%d:%d", shost->host_no, number);
+	if (scsi_is_sas_expander_device(parent)) {
+		struct sas_rphy *rphy = dev_to_rphy(parent);
+		sprintf(phy->dev.bus_id, "phy-%d-%d:%d", shost->host_no,
+			rphy->scsi_target_id, number);
+	} else
+		sprintf(phy->dev.bus_id, "phy-%d:%d", shost->host_no, number);
 
 	transport_setup_device(&phy->dev);
 
@@ -635,6 +646,9 @@ int sas_read_port_mode_page(struct scsi_device *sdev)
 }
 EXPORT_SYMBOL(sas_read_port_mode_page);
 
+static DECLARE_TRANSPORT_CLASS(sas_end_dev_class,
+			       "sas_end_device", NULL, NULL, NULL);
+
 #define sas_end_dev_show_simple(field, name, format_string, cast)	\
 static ssize_t								\
 show_sas_end_dev_##name(struct class_device *cdev, char *buf)		\
@@ -656,8 +670,33 @@ sas_end_dev_simple_attr(I_T_nexus_loss_timeout, I_T_nexus_loss_timeout,
 sas_end_dev_simple_attr(initiator_response_timeout, initiator_response_timeout,
 			"%d\n", int);
 
-static DECLARE_TRANSPORT_CLASS(sas_end_dev_class,
-			       "sas_end_device", NULL, NULL, NULL);
+static DECLARE_TRANSPORT_CLASS(sas_expander_class,
+			       "sas_expander", NULL, NULL, NULL);
+
+#define sas_expander_show_simple(field, name, format_string, cast)	\
+static ssize_t								\
+show_sas_expander_##name(struct class_device *cdev, char *buf)		\
+{									\
+	struct sas_rphy *rphy = transport_class_to_rphy(cdev);		\
+	struct sas_expander_device *edev = rphy_to_expander_device(rphy); \
+									\
+	return snprintf(buf, 20, format_string, cast edev->field);	\
+}
+
+#define sas_expander_simple_attr(field, name, format_string, type)	\
+	sas_expander_show_simple(field, name, format_string, (type))	\
+static SAS_CLASS_DEVICE_ATTR(expander, name, S_IRUGO, 			\
+		show_sas_expander_##name, NULL)
+
+sas_expander_simple_attr(vendor_id, vendor_id, "%s\n", char *);
+sas_expander_simple_attr(product_id, product_id, "%s\n", char *);
+sas_expander_simple_attr(product_rev, product_rev, "%s\n", char *);
+sas_expander_simple_attr(component_vendor_id, component_vendor_id,
+			 "%s\n", char *);
+sas_expander_simple_attr(component_id, component_id, "%u\n", unsigned int);
+sas_expander_simple_attr(component_revision_id, component_revision_id, "%u\n",
+			 unsigned int);
+sas_expander_simple_attr(level, level, "%d\n", int);
 
 static DECLARE_TRANSPORT_CLASS(sas_rphy_class,
 		"sas_rphy", NULL, NULL, NULL);
@@ -706,6 +745,32 @@ static int sas_end_dev_match(struct attribute_container *cont,
 		rphy->contained;
 }
 
+static int sas_expander_match(struct attribute_container *cont,
+			      struct device *dev)
+{
+	struct Scsi_Host *shost;
+	struct sas_internal *i;
+	struct sas_rphy *rphy;
+
+	if (!scsi_is_sas_rphy(dev))
+		return 0;
+	shost = dev_to_shost(dev->parent->parent);
+	rphy = dev_to_rphy(dev);
+
+	if (!shost->transportt)
+		return 0;
+	if (shost->transportt->host_attrs.ac.class !=
+			&sas_host_class.class)
+		return 0;
+
+	i = to_sas_internal(shost->transportt);
+	return &i->expander_attr_cont.ac == cont &&
+		(rphy->identify.device_type == SAS_EDGE_EXPANDER_DEVICE ||
+		 rphy->identify.device_type == SAS_FANOUT_EXPANDER_DEVICE) &&
+		/* FIXME: remove contained eventually */
+		rphy->contained;
+}
+
 static void sas_rphy_release(struct device *dev)
 {
 	struct sas_rphy *rphy = dev_to_rphy(dev);
@@ -778,6 +843,46 @@ struct sas_rphy *sas_end_device_alloc(struct sas_phy *parent)
 }
 EXPORT_SYMBOL(sas_end_device_alloc);
 
+/**
+ * sas_expander_alloc - allocate an rphy for an end device
+ *
+ * Allocates an SAS remote PHY structure, connected to @parent.
+ *
+ * Returns:
+ *	SAS PHY allocated or %NULL if the allocation failed.
+ */
+struct sas_rphy *sas_expander_alloc(struct sas_phy *parent,
+				    enum sas_device_type type)
+{
+	struct Scsi_Host *shost = dev_to_shost(&parent->dev);
+	struct sas_expander_device *rdev;
+	struct sas_host_attrs *sas_host = to_sas_host_attrs(shost);
+
+	BUG_ON(type != SAS_EDGE_EXPANDER_DEVICE &&
+	       type != SAS_FANOUT_EXPANDER_DEVICE);
+
+	rdev = kzalloc(sizeof(*rdev), GFP_KERNEL);
+	if (!rdev) {
+		put_device(&parent->dev);
+		return NULL;
+	}
+
+	device_initialize(&rdev->rphy.dev);
+	rdev->rphy.dev.parent = get_device(&parent->dev);
+	rdev->rphy.dev.release = sas_rphy_release;
+	mutex_lock(&sas_host->lock);
+	rdev->rphy.scsi_target_id = sas_host->next_expander_id++;
+	mutex_unlock(&sas_host->lock);
+	sprintf(rdev->rphy.dev.bus_id, "expander-%d:%d",
+		shost->host_no, rdev->rphy.scsi_target_id);
+	rdev->rphy.identify.device_type = type;
+	/* FIXME: mark the rphy as being contained in a larger structure */
+	rdev->rphy.contained = 1;
+	transport_setup_device(&rdev->rphy.dev);
+
+	return &rdev->rphy;
+}
+EXPORT_SYMBOL(sas_expander_alloc);
 
 /**
  * sas_rphy_add  --  add a SAS remote PHY to the device hierachy
@@ -809,11 +914,10 @@ int sas_rphy_add(struct sas_rphy *rphy)
 	    (identify->target_port_protocols &
 	     (SAS_PROTOCOL_SSP|SAS_PROTOCOL_STP|SAS_PROTOCOL_SATA)))
 		rphy->scsi_target_id = sas_host->next_target_id++;
-	else
-		rphy->scsi_target_id = -1;
 	mutex_unlock(&sas_host->lock);
 
-	if (rphy->scsi_target_id != -1) {
+	if (identify->device_type == SAS_END_DEVICE &&
+	    rphy->scsi_target_id != -1) {
 		scsi_scan_target(&rphy->dev, parent->port_identifier,
 				rphy->scsi_target_id, ~0, 0);
 	}
@@ -967,6 +1071,9 @@ static int sas_user_scan(struct Scsi_Host *shost, uint channel,
 #define SETUP_END_DEV_ATTRIBUTE(field)					\
 	SETUP_TEMPLATE(end_dev_attrs, field, S_IRUGO, 1)
 
+#define SETUP_EXPANDER_ATTRIBUTE(field)					\
+	SETUP_TEMPLATE(expander_attrs, expander_##field, S_IRUGO, 1)
+
 /**
  * sas_attach_transport  --  instantiate SAS transport template
  * @ft:		SAS transport class function template
@@ -1004,6 +1111,11 @@ sas_attach_transport(struct sas_function_template *ft)
 	i->end_dev_attr_cont.ac.match = sas_end_dev_match;
 	transport_container_register(&i->end_dev_attr_cont);
 
+	i->expander_attr_cont.ac.class = &sas_expander_class.class;
+	i->expander_attr_cont.ac.attrs = &i->expander_attrs[0];
+	i->expander_attr_cont.ac.match = sas_expander_match;
+	transport_container_register(&i->expander_attr_cont);
+
 	i->f = ft;
 
 	count = 0;
@@ -1048,6 +1160,16 @@ sas_attach_transport(struct sas_function_template *ft)
 	SETUP_END_DEV_ATTRIBUTE(end_dev_initiator_response_timeout);
 	i->end_dev_attrs[count] = NULL;
 
+	count = 0;
+	SETUP_EXPANDER_ATTRIBUTE(vendor_id);
+	SETUP_EXPANDER_ATTRIBUTE(product_id);
+	SETUP_EXPANDER_ATTRIBUTE(product_rev);
+	SETUP_EXPANDER_ATTRIBUTE(component_vendor_id);
+	SETUP_EXPANDER_ATTRIBUTE(component_id);
+	SETUP_EXPANDER_ATTRIBUTE(component_revision_id);
+	SETUP_EXPANDER_ATTRIBUTE(level);
+	i->expander_attrs[count] = NULL;
+
 	return &i->t;
 }
 EXPORT_SYMBOL(sas_attach_transport);
@@ -1064,6 +1186,7 @@ void sas_release_transport(struct scsi_transport_template *t)
 	transport_container_unregister(&i->phy_attr_cont);
 	transport_container_unregister(&i->rphy_attr_cont);
 	transport_container_unregister(&i->end_dev_attr_cont);
+	transport_container_unregister(&i->expander_attr_cont);
 
 	kfree(i);
 }
@@ -1085,9 +1208,14 @@ static __init int sas_transport_init(void)
 	error = transport_class_register(&sas_end_dev_class);
 	if (error)
 		goto out_unregister_rphy;
+	error = transport_class_register(&sas_expander_class);
+	if (error)
+		goto out_unregister_end_dev;
 
 	return 0;
 
+ out_unregister_end_dev:
+	transport_class_unregister(&sas_end_dev_class);
  out_unregister_rphy:
 	transport_class_unregister(&sas_rphy_class);
  out_unregister_phy:
@@ -1105,6 +1233,7 @@ static void __exit sas_transport_exit(void)
 	transport_class_unregister(&sas_phy_class);
 	transport_class_unregister(&sas_rphy_class);
 	transport_class_unregister(&sas_end_dev_class);
+	transport_class_unregister(&sas_expander_class);
 }
 
 MODULE_AUTHOR("Christoph Hellwig");

commit db82f8410ed7546792358964aa5f8dafff1c70a2
Author: James Bottomley <jejb@mulgrave.il.steeleye.com>
Date:   Thu Mar 9 22:06:36 2006 -0500

    [SCSI] add missing transport_container_unregister in sas class
    
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>

diff --git a/drivers/scsi/scsi_transport_sas.c b/drivers/scsi/scsi_transport_sas.c
index 5de29b941c6b..3eb11a175904 100644
--- a/drivers/scsi/scsi_transport_sas.c
+++ b/drivers/scsi/scsi_transport_sas.c
@@ -1063,6 +1063,7 @@ void sas_release_transport(struct scsi_transport_template *t)
 	transport_container_unregister(&i->t.host_attrs);
 	transport_container_unregister(&i->phy_attr_cont);
 	transport_container_unregister(&i->rphy_attr_cont);
+	transport_container_unregister(&i->end_dev_attr_cont);
 
 	kfree(i);
 }

commit 42ab03609cca4ef5079e248296f015650c626899
Author: James Bottomley <James.Bottomley@steeleye.com>
Date:   Sat Mar 4 09:10:18 2006 -0600

    [PATCH] convert aic94xx over to using the sas transport end device
    
    Begin introducing the concept of sas remote devices that have an rphy
    embedded.  The first one (this) is a simple end device.  All that an
    end device really does is have port mode page parameters contained.
    The next and more complex piece will be expander remote devices.
    
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>

diff --git a/drivers/scsi/scsi_transport_sas.c b/drivers/scsi/scsi_transport_sas.c
index 434f3954aa87..5de29b941c6b 100644
--- a/drivers/scsi/scsi_transport_sas.c
+++ b/drivers/scsi/scsi_transport_sas.c
@@ -39,6 +39,7 @@
 #define SAS_HOST_ATTRS		0
 #define SAS_PORT_ATTRS		17
 #define SAS_RPORT_ATTRS		7
+#define SAS_END_DEV_ATTRS	3
 
 struct sas_internal {
 	struct scsi_transport_template t;
@@ -47,9 +48,11 @@ struct sas_internal {
 	struct class_device_attribute private_host_attrs[SAS_HOST_ATTRS];
 	struct class_device_attribute private_phy_attrs[SAS_PORT_ATTRS];
 	struct class_device_attribute private_rphy_attrs[SAS_RPORT_ATTRS];
+	struct class_device_attribute private_end_dev_attrs[SAS_END_DEV_ATTRS];
 
 	struct transport_container phy_attr_cont;
 	struct transport_container rphy_attr_cont;
+	struct transport_container end_dev_attr_cont;
 
 	/*
 	 * The array of null terminated pointers to attributes
@@ -58,6 +61,7 @@ struct sas_internal {
 	struct class_device_attribute *host_attrs[SAS_HOST_ATTRS + 1];
 	struct class_device_attribute *phy_attrs[SAS_PORT_ATTRS + 1];
 	struct class_device_attribute *rphy_attrs[SAS_RPORT_ATTRS + 1];
+	struct class_device_attribute *end_dev_attrs[SAS_END_DEV_ATTRS + 1];
 };
 #define to_sas_internal(tmpl)	container_of(tmpl, struct sas_internal, t)
 
@@ -588,6 +592,73 @@ sas_rphy_simple_attr(identify.sas_address, sas_address, "0x%016llx\n",
 		unsigned long long);
 sas_rphy_simple_attr(identify.phy_identifier, phy_identifier, "%d\n", u8);
 
+/* only need 8 bytes of data plus header (4 or 8) */
+#define BUF_SIZE 64
+
+int sas_read_port_mode_page(struct scsi_device *sdev)
+{
+	char *buffer = kzalloc(BUF_SIZE, GFP_KERNEL), *msdata;
+	struct sas_rphy *rphy = target_to_rphy(sdev->sdev_target);
+	struct sas_end_device *rdev;
+	struct scsi_mode_data mode_data;
+	int res, error;
+
+	BUG_ON(rphy->identify.device_type != SAS_END_DEVICE);
+
+	rdev = rphy_to_end_device(rphy);
+
+	if (!buffer)
+		return -ENOMEM;
+
+	res = scsi_mode_sense(sdev, 1, 0x19, buffer, BUF_SIZE, 30*HZ, 3,
+			      &mode_data, NULL);
+
+	error = -EINVAL;
+	if (!scsi_status_is_good(res))
+		goto out;
+
+	msdata = buffer +  mode_data.header_length +
+		mode_data.block_descriptor_length;
+
+	if (msdata - buffer > BUF_SIZE - 8)
+		goto out;
+
+	error = 0;
+
+	rdev->ready_led_meaning = msdata[2] & 0x10 ? 1 : 0;
+	rdev->I_T_nexus_loss_timeout = (msdata[4] << 8) + msdata[5];
+	rdev->initiator_response_timeout = (msdata[6] << 8) + msdata[7];
+
+ out:
+	kfree(buffer);
+	return error;
+}
+EXPORT_SYMBOL(sas_read_port_mode_page);
+
+#define sas_end_dev_show_simple(field, name, format_string, cast)	\
+static ssize_t								\
+show_sas_end_dev_##name(struct class_device *cdev, char *buf)		\
+{									\
+	struct sas_rphy *rphy = transport_class_to_rphy(cdev);		\
+	struct sas_end_device *rdev = rphy_to_end_device(rphy);		\
+									\
+	return snprintf(buf, 20, format_string, cast rdev->field);	\
+}
+
+#define sas_end_dev_simple_attr(field, name, format_string, type)	\
+	sas_end_dev_show_simple(field, name, format_string, (type))	\
+static SAS_CLASS_DEVICE_ATTR(end_dev, name, S_IRUGO, 			\
+		show_sas_end_dev_##name, NULL)
+
+sas_end_dev_simple_attr(ready_led_meaning, ready_led_meaning, "%d\n", int);
+sas_end_dev_simple_attr(I_T_nexus_loss_timeout, I_T_nexus_loss_timeout,
+			"%d\n", int);
+sas_end_dev_simple_attr(initiator_response_timeout, initiator_response_timeout,
+			"%d\n", int);
+
+static DECLARE_TRANSPORT_CLASS(sas_end_dev_class,
+			       "sas_end_device", NULL, NULL, NULL);
+
 static DECLARE_TRANSPORT_CLASS(sas_rphy_class,
 		"sas_rphy", NULL, NULL, NULL);
 
@@ -610,6 +681,31 @@ static int sas_rphy_match(struct attribute_container *cont, struct device *dev)
 	return &i->rphy_attr_cont.ac == cont;
 }
 
+static int sas_end_dev_match(struct attribute_container *cont,
+			     struct device *dev)
+{
+	struct Scsi_Host *shost;
+	struct sas_internal *i;
+	struct sas_rphy *rphy;
+
+	if (!scsi_is_sas_rphy(dev))
+		return 0;
+	shost = dev_to_shost(dev->parent->parent);
+	rphy = dev_to_rphy(dev);
+
+	if (!shost->transportt)
+		return 0;
+	if (shost->transportt->host_attrs.ac.class !=
+			&sas_host_class.class)
+		return 0;
+
+	i = to_sas_internal(shost->transportt);
+	return &i->end_dev_attr_cont.ac == cont &&
+		rphy->identify.device_type == SAS_END_DEVICE &&
+		/* FIXME: remove contained eventually */
+		rphy->contained;
+}
+
 static void sas_rphy_release(struct device *dev)
 {
 	struct sas_rphy *rphy = dev_to_rphy(dev);
@@ -649,6 +745,40 @@ struct sas_rphy *sas_rphy_alloc(struct sas_phy *parent)
 }
 EXPORT_SYMBOL(sas_rphy_alloc);
 
+/**
+ * sas_end_device_alloc - allocate an rphy for an end device
+ *
+ * Allocates an SAS remote PHY structure, connected to @parent.
+ *
+ * Returns:
+ *	SAS PHY allocated or %NULL if the allocation failed.
+ */
+struct sas_rphy *sas_end_device_alloc(struct sas_phy *parent)
+{
+	struct Scsi_Host *shost = dev_to_shost(&parent->dev);
+	struct sas_end_device *rdev;
+
+	rdev = kzalloc(sizeof(*rdev), GFP_KERNEL);
+	if (!rdev) {
+		put_device(&parent->dev);
+		return NULL;
+	}
+
+	device_initialize(&rdev->rphy.dev);
+	rdev->rphy.dev.parent = get_device(&parent->dev);
+	rdev->rphy.dev.release = sas_rphy_release;
+	sprintf(rdev->rphy.dev.bus_id, "rphy-%d:%d-%d",
+		shost->host_no, parent->port_identifier, parent->number);
+	rdev->rphy.identify.device_type = SAS_END_DEVICE;
+	/* FIXME: mark the rphy as being contained in a larger structure */
+	rdev->rphy.contained = 1;
+	transport_setup_device(&rdev->rphy.dev);
+
+	return &rdev->rphy;
+}
+EXPORT_SYMBOL(sas_end_device_alloc);
+
+
 /**
  * sas_rphy_add  --  add a SAS remote PHY to the device hierachy
  * @rphy:	The remote PHY to be added
@@ -807,51 +937,35 @@ static int sas_user_scan(struct Scsi_Host *shost, uint channel,
  * Setup / Teardown code
  */
 
-#define SETUP_RPORT_ATTRIBUTE(field)					\
-	i->private_rphy_attrs[count] = class_device_attr_##field;	\
-	i->private_rphy_attrs[count].attr.mode = S_IRUGO;		\
-	i->private_rphy_attrs[count].store = NULL;			\
-	i->rphy_attrs[count] = &i->private_rphy_attrs[count];	\
-	count++
+#define SETUP_TEMPLATE(attrb, field, perm, test)				\
+	i->private_##attrb[count] = class_device_attr_##field;		\
+	i->private_##attrb[count].attr.mode = perm;			\
+	i->private_##attrb[count].store = NULL;				\
+	i->attrb[count] = &i->private_##attrb[count];			\
+	if (test)							\
+		count++
+
+
+#define SETUP_RPORT_ATTRIBUTE(field) 					\
+	SETUP_TEMPLATE(rphy_attrs, field, S_IRUGO, 1)
 
 #define SETUP_OPTIONAL_RPORT_ATTRIBUTE(field, func)			\
-	i->private_rphy_attrs[count] = class_device_attr_##field;	\
-	i->private_rphy_attrs[count].attr.mode = S_IRUGO;		\
-	i->private_rphy_attrs[count].store = NULL;			\
-	i->rphy_attrs[count] = &i->private_rphy_attrs[count];		\
-	if (i->f->func)							\
-		count++
+	SETUP_TEMPLATE(rphy_attrs, field, S_IRUGO, i->f->func)
 
 #define SETUP_PORT_ATTRIBUTE(field)					\
-	i->private_phy_attrs[count] = class_device_attr_##field;	\
-        i->private_phy_attrs[count].attr.mode = S_IRUGO;		\
-        i->private_phy_attrs[count].store = NULL;			\
-        i->phy_attrs[count] = &i->private_phy_attrs[count];		\
-	count++
+	SETUP_TEMPLATE(phy_attrs, field, S_IRUGO, 1)
 
 #define SETUP_OPTIONAL_PORT_ATTRIBUTE(field, func)			\
-	i->private_phy_attrs[count] = class_device_attr_##field;	\
-        i->private_phy_attrs[count].attr.mode = S_IRUGO;		\
-        i->private_phy_attrs[count].store = NULL;			\
-        i->phy_attrs[count] = &i->private_phy_attrs[count];		\
-	if (i->f->func)							\
-		count++
+	SETUP_TEMPLATE(phy_attrs, field, S_IRUGO, i->f->func)
 
 #define SETUP_PORT_ATTRIBUTE_WRONLY(field)				\
-	i->private_phy_attrs[count] = class_device_attr_##field;	\
-	i->private_phy_attrs[count].attr.mode = S_IWUGO;		\
-	i->private_phy_attrs[count].show = NULL;			\
-	i->phy_attrs[count] = &i->private_phy_attrs[count];		\
-	count++
+	SETUP_TEMPLATE(phy_attrs, field, S_IWUGO, 1)
 
 #define SETUP_OPTIONAL_PORT_ATTRIBUTE_WRONLY(field, func)		\
-	i->private_phy_attrs[count] = class_device_attr_##field;	\
-	i->private_phy_attrs[count].attr.mode = S_IWUGO;		\
-	i->private_phy_attrs[count].show = NULL;			\
-	i->phy_attrs[count] = &i->private_phy_attrs[count];		\
-	if (i->f->func)							\
-		count++
+	SETUP_TEMPLATE(phy_attrs, field, S_IWUGO, i->f->func)
 
+#define SETUP_END_DEV_ATTRIBUTE(field)					\
+	SETUP_TEMPLATE(end_dev_attrs, field, S_IRUGO, 1)
 
 /**
  * sas_attach_transport  --  instantiate SAS transport template
@@ -885,6 +999,11 @@ sas_attach_transport(struct sas_function_template *ft)
 	i->rphy_attr_cont.ac.match = sas_rphy_match;
 	transport_container_register(&i->rphy_attr_cont);
 
+	i->end_dev_attr_cont.ac.class = &sas_end_dev_class.class;
+	i->end_dev_attr_cont.ac.attrs = &i->end_dev_attrs[0];
+	i->end_dev_attr_cont.ac.match = sas_end_dev_match;
+	transport_container_register(&i->end_dev_attr_cont);
+
 	i->f = ft;
 
 	count = 0;
@@ -923,6 +1042,12 @@ sas_attach_transport(struct sas_function_template *ft)
 				       get_bay_identifier);
 	i->rphy_attrs[count] = NULL;
 
+	count = 0;
+	SETUP_END_DEV_ATTRIBUTE(end_dev_ready_led_meaning);
+	SETUP_END_DEV_ATTRIBUTE(end_dev_I_T_nexus_loss_timeout);
+	SETUP_END_DEV_ATTRIBUTE(end_dev_initiator_response_timeout);
+	i->end_dev_attrs[count] = NULL;
+
 	return &i->t;
 }
 EXPORT_SYMBOL(sas_attach_transport);
@@ -956,9 +1081,14 @@ static __init int sas_transport_init(void)
 	error = transport_class_register(&sas_rphy_class);
 	if (error)
 		goto out_unregister_phy;
+	error = transport_class_register(&sas_end_dev_class);
+	if (error)
+		goto out_unregister_rphy;
 
 	return 0;
 
+ out_unregister_rphy:
+	transport_class_unregister(&sas_rphy_class);
  out_unregister_phy:
 	transport_class_unregister(&sas_phy_class);
  out_unregister_transport:
@@ -973,6 +1103,7 @@ static void __exit sas_transport_exit(void)
 	transport_class_unregister(&sas_host_class);
 	transport_class_unregister(&sas_phy_class);
 	transport_class_unregister(&sas_rphy_class);
+	transport_class_unregister(&sas_end_dev_class);
 }
 
 MODULE_AUTHOR("Christoph Hellwig");

commit dd9fbb52134693f1394a928c05d5f3cd3fdaf6e0
Author: James Bottomley <James.Bottomley@steeleye.com>
Date:   Thu Mar 2 16:01:31 2006 -0600

    [SCSI] make some sas class properties optional
    
    aic94xx doesn't have a use for the bay or enclosure identifiers.
    Also, I think it's not going to need a get_linkerrors(), so wire up
    all of these exported properties as conditional on the underlying
    function support.
    
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>

diff --git a/drivers/scsi/scsi_transport_sas.c b/drivers/scsi/scsi_transport_sas.c
index fed39abeff86..434f3954aa87 100644
--- a/drivers/scsi/scsi_transport_sas.c
+++ b/drivers/scsi/scsi_transport_sas.c
@@ -273,7 +273,7 @@ show_sas_phy_##field(struct class_device *cdev, char *buf)		\
 	if (!phy->local_attached)					\
 		return -EINVAL;						\
 									\
-	error = i->f->get_linkerrors(phy);				\
+	error = i->f->get_linkerrors ? i->f->get_linkerrors(phy) : 0;	\
 	if (error)							\
 		return error;						\
 	return snprintf(buf, 20, "%u\n", phy->field);			\
@@ -814,6 +814,14 @@ static int sas_user_scan(struct Scsi_Host *shost, uint channel,
 	i->rphy_attrs[count] = &i->private_rphy_attrs[count];	\
 	count++
 
+#define SETUP_OPTIONAL_RPORT_ATTRIBUTE(field, func)			\
+	i->private_rphy_attrs[count] = class_device_attr_##field;	\
+	i->private_rphy_attrs[count].attr.mode = S_IRUGO;		\
+	i->private_rphy_attrs[count].store = NULL;			\
+	i->rphy_attrs[count] = &i->private_rphy_attrs[count];		\
+	if (i->f->func)							\
+		count++
+
 #define SETUP_PORT_ATTRIBUTE(field)					\
 	i->private_phy_attrs[count] = class_device_attr_##field;	\
         i->private_phy_attrs[count].attr.mode = S_IRUGO;		\
@@ -821,6 +829,14 @@ static int sas_user_scan(struct Scsi_Host *shost, uint channel,
         i->phy_attrs[count] = &i->private_phy_attrs[count];		\
 	count++
 
+#define SETUP_OPTIONAL_PORT_ATTRIBUTE(field, func)			\
+	i->private_phy_attrs[count] = class_device_attr_##field;	\
+        i->private_phy_attrs[count].attr.mode = S_IRUGO;		\
+        i->private_phy_attrs[count].store = NULL;			\
+        i->phy_attrs[count] = &i->private_phy_attrs[count];		\
+	if (i->f->func)							\
+		count++
+
 #define SETUP_PORT_ATTRIBUTE_WRONLY(field)				\
 	i->private_phy_attrs[count] = class_device_attr_##field;	\
 	i->private_phy_attrs[count].attr.mode = S_IWUGO;		\
@@ -828,6 +844,14 @@ static int sas_user_scan(struct Scsi_Host *shost, uint channel,
 	i->phy_attrs[count] = &i->private_phy_attrs[count];		\
 	count++
 
+#define SETUP_OPTIONAL_PORT_ATTRIBUTE_WRONLY(field, func)		\
+	i->private_phy_attrs[count] = class_device_attr_##field;	\
+	i->private_phy_attrs[count].attr.mode = S_IWUGO;		\
+	i->private_phy_attrs[count].show = NULL;			\
+	i->phy_attrs[count] = &i->private_phy_attrs[count];		\
+	if (i->f->func)							\
+		count++
+
 
 /**
  * sas_attach_transport  --  instantiate SAS transport template
@@ -883,8 +907,8 @@ sas_attach_transport(struct sas_function_template *ft)
 	SETUP_PORT_ATTRIBUTE(running_disparity_error_count);
 	SETUP_PORT_ATTRIBUTE(loss_of_dword_sync_count);
 	SETUP_PORT_ATTRIBUTE(phy_reset_problem_count);
-	SETUP_PORT_ATTRIBUTE_WRONLY(link_reset);
-	SETUP_PORT_ATTRIBUTE_WRONLY(hard_reset);
+	SETUP_OPTIONAL_PORT_ATTRIBUTE_WRONLY(link_reset, phy_reset);
+	SETUP_OPTIONAL_PORT_ATTRIBUTE_WRONLY(hard_reset, phy_reset);
 	i->phy_attrs[count] = NULL;
 
 	count = 0;
@@ -893,8 +917,10 @@ sas_attach_transport(struct sas_function_template *ft)
 	SETUP_RPORT_ATTRIBUTE(rphy_device_type);
 	SETUP_RPORT_ATTRIBUTE(rphy_sas_address);
 	SETUP_RPORT_ATTRIBUTE(rphy_phy_identifier);
-	SETUP_RPORT_ATTRIBUTE(rphy_enclosure_identifier);
-	SETUP_RPORT_ATTRIBUTE(rphy_bay_identifier);
+	SETUP_OPTIONAL_RPORT_ATTRIBUTE(rphy_enclosure_identifier,
+				       get_enclosure_identifier);
+	SETUP_OPTIONAL_RPORT_ATTRIBUTE(rphy_bay_identifier,
+				       get_bay_identifier);
 	i->rphy_attrs[count] = NULL;
 
 	return &i->t;

commit 7e6dff62dad539cbd608bb3b8b833193d13f00ac
Author: James Bottomley <James.Bottomley@steeleye.com>
Date:   Thu Mar 2 14:12:56 2006 -0600

    [SCSI] add 6.0 Gbit phy definitions to the sas transport class
    
    I don't think these exist in silicon yet, but the aic94xx driver has a
    register setting for them.
    
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>

diff --git a/drivers/scsi/scsi_transport_sas.c b/drivers/scsi/scsi_transport_sas.c
index eab5c7c6f3c7..fed39abeff86 100644
--- a/drivers/scsi/scsi_transport_sas.c
+++ b/drivers/scsi/scsi_transport_sas.c
@@ -151,6 +151,7 @@ static struct {
 	{ SAS_SATA_SPINUP_HOLD,		"Spin-up hold" },
 	{ SAS_LINK_RATE_1_5_GBPS,	"1.5 Gbit" },
 	{ SAS_LINK_RATE_3_0_GBPS,	"3.0 Gbit" },
+	{ SAS_LINK_RATE_6_0_GBPS,	"6.0 Gbit" },
 };
 sas_bitfield_name_search(linkspeed, sas_linkspeed_names)
 

commit a012564136a665f8d63443c057ba368572b483df
Author: Christoph Hellwig <hch@lst.de>
Date:   Thu Feb 16 13:31:47 2006 +0100

    [SCSI] sas: add support for enclosure and bad ID rphy attributes
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>

diff --git a/drivers/scsi/scsi_transport_sas.c b/drivers/scsi/scsi_transport_sas.c
index 205542988e29..eab5c7c6f3c7 100644
--- a/drivers/scsi/scsi_transport_sas.c
+++ b/drivers/scsi/scsi_transport_sas.c
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2005 Dell Inc.
+ * Copyright (C) 2005-2006 Dell Inc.
  *	Released under GPL v2.
  *
  * Serial Attached SCSI (SAS) transport class.
@@ -38,7 +38,7 @@
 
 #define SAS_HOST_ATTRS		0
 #define SAS_PORT_ATTRS		17
-#define SAS_RPORT_ATTRS		5
+#define SAS_RPORT_ATTRS		7
 
 struct sas_internal {
 	struct scsi_transport_template t;
@@ -533,6 +533,53 @@ show_sas_rphy_device_type(struct class_device *cdev, char *buf)
 static SAS_CLASS_DEVICE_ATTR(rphy, device_type, S_IRUGO,
 		show_sas_rphy_device_type, NULL);
 
+static ssize_t
+show_sas_rphy_enclosure_identifier(struct class_device *cdev, char *buf)
+{
+	struct sas_rphy *rphy = transport_class_to_rphy(cdev);
+	struct sas_phy *phy = dev_to_phy(rphy->dev.parent);
+	struct Scsi_Host *shost = dev_to_shost(phy->dev.parent);
+	struct sas_internal *i = to_sas_internal(shost->transportt);
+	u64 identifier;
+	int error;
+
+	/*
+	 * Only devices behind an expander are supported, because the
+	 * enclosure identifier is a SMP feature.
+	 */
+	if (phy->local_attached)
+		return -EINVAL;
+
+	error = i->f->get_enclosure_identifier(rphy, &identifier);
+	if (error)
+		return error;
+	return sprintf(buf, "0x%llx\n", (unsigned long long)identifier);
+}
+
+static SAS_CLASS_DEVICE_ATTR(rphy, enclosure_identifier, S_IRUGO,
+		show_sas_rphy_enclosure_identifier, NULL);
+
+static ssize_t
+show_sas_rphy_bay_identifier(struct class_device *cdev, char *buf)
+{
+	struct sas_rphy *rphy = transport_class_to_rphy(cdev);
+	struct sas_phy *phy = dev_to_phy(rphy->dev.parent);
+	struct Scsi_Host *shost = dev_to_shost(phy->dev.parent);
+	struct sas_internal *i = to_sas_internal(shost->transportt);
+	int val;
+
+	if (phy->local_attached)
+		return -EINVAL;
+
+	val = i->f->get_bay_identifier(rphy);
+	if (val < 0)
+		return val;
+	return sprintf(buf, "%d\n", val);
+}
+
+static SAS_CLASS_DEVICE_ATTR(rphy, bay_identifier, S_IRUGO,
+		show_sas_rphy_bay_identifier, NULL);
+
 sas_rphy_protocol_attr(identify.initiator_port_protocols,
 		initiator_port_protocols);
 sas_rphy_protocol_attr(identify.target_port_protocols, target_port_protocols);
@@ -845,6 +892,8 @@ sas_attach_transport(struct sas_function_template *ft)
 	SETUP_RPORT_ATTRIBUTE(rphy_device_type);
 	SETUP_RPORT_ATTRIBUTE(rphy_sas_address);
 	SETUP_RPORT_ATTRIBUTE(rphy_phy_identifier);
+	SETUP_RPORT_ATTRIBUTE(rphy_enclosure_identifier);
+	SETUP_RPORT_ATTRIBUTE(rphy_bay_identifier);
 	i->rphy_attrs[count] = NULL;
 
 	return &i->t;

commit 24669f75a3231fa37444977c92d1f4838bec1233
Author: Jes Sorensen <jes@sgi.com>
Date:   Mon Jan 16 10:31:18 2006 -0500

    [SCSI] SCSI core kmalloc2kzalloc
    
    Change the core SCSI code to use kzalloc rather than kmalloc+memset
    where possible.
    
    Signed-off-by: Jes Sorensen <jes@sgi.com>
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>

diff --git a/drivers/scsi/scsi_transport_sas.c b/drivers/scsi/scsi_transport_sas.c
index 210dab5879fa..205542988e29 100644
--- a/drivers/scsi/scsi_transport_sas.c
+++ b/drivers/scsi/scsi_transport_sas.c
@@ -391,10 +391,9 @@ struct sas_phy *sas_phy_alloc(struct device *parent, int number)
 	struct Scsi_Host *shost = dev_to_shost(parent);
 	struct sas_phy *phy;
 
-	phy = kmalloc(sizeof(*phy), GFP_KERNEL);
+	phy = kzalloc(sizeof(*phy), GFP_KERNEL);
 	if (!phy)
 		return NULL;
-	memset(phy, 0, sizeof(*phy));
 
 	get_device(parent);
 
@@ -585,12 +584,11 @@ struct sas_rphy *sas_rphy_alloc(struct sas_phy *parent)
 	struct Scsi_Host *shost = dev_to_shost(&parent->dev);
 	struct sas_rphy *rphy;
 
-	rphy = kmalloc(sizeof(*rphy), GFP_KERNEL);
+	rphy = kzalloc(sizeof(*rphy), GFP_KERNEL);
 	if (!rphy) {
 		put_device(&parent->dev);
 		return NULL;
 	}
-	memset(rphy, 0, sizeof(*rphy));
 
 	device_initialize(&rphy->dev);
 	rphy->dev.parent = get_device(&parent->dev);
@@ -793,10 +791,9 @@ sas_attach_transport(struct sas_function_template *ft)
 	struct sas_internal *i;
 	int count;
 
-	i = kmalloc(sizeof(struct sas_internal), GFP_KERNEL);
+	i = kzalloc(sizeof(struct sas_internal), GFP_KERNEL);
 	if (!i)
 		return NULL;
-	memset(i, 0, sizeof(struct sas_internal));
 
 	i->t.user_scan = sas_user_scan;
 

commit d99ca4180fe44ae7f409fc73f1a09f270b8d458a
Author: Moore, Eric <Eric.Moore@lsil.com>
Date:   Thu Jan 26 16:20:02 2006 -0700

    [SCSI] scsi_transport_sas.c: display port identifier
    
    This patch displays the port identifier on
    the folder attribute; located in the middle digit.
    
    /sys/class/sas_rphy/rphy-%x:%x:%x
    
    The port identifier is basically the unique identifier
    for each sas domain.
    
    Signed-off-by: Eric Moore <Eric.Moore@lsil.com>
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>

diff --git a/drivers/scsi/scsi_transport_sas.c b/drivers/scsi/scsi_transport_sas.c
index a3e0b7bc2d7b..210dab5879fa 100644
--- a/drivers/scsi/scsi_transport_sas.c
+++ b/drivers/scsi/scsi_transport_sas.c
@@ -377,7 +377,7 @@ static void sas_phy_release(struct device *dev)
 /**
  * sas_phy_alloc  --  allocates and initialize a SAS PHY structure
  * @parent:	Parent device
- * @number:	Port number
+ * @number:	Phy index
  *
  * Allocates an SAS PHY structure.  It will be added in the device tree
  * below the device specified by @parent, which has to be either a Scsi_Host
@@ -595,8 +595,8 @@ struct sas_rphy *sas_rphy_alloc(struct sas_phy *parent)
 	device_initialize(&rphy->dev);
 	rphy->dev.parent = get_device(&parent->dev);
 	rphy->dev.release = sas_rphy_release;
-	sprintf(rphy->dev.bus_id, "rphy-%d:%d",
-		shost->host_no, parent->number);
+	sprintf(rphy->dev.bus_id, "rphy-%d:%d-%d",
+		shost->host_no, parent->port_identifier, parent->number);
 	transport_setup_device(&rphy->dev);
 
 	return rphy;

commit e6bc863cf25f30ed8e2a4d41b76d5688f8efaee9
Author: Moore, Eric <Eric.Moore@lsil.com>
Date:   Fri Jan 13 16:33:59 2006 -0700

    [SCSI] scsi_transport_sas: mapping the rphy channel equal to the port identifier
    
    We will be mapping the RAID volumes in mptsas to a reserved
    channel that
    is one larger than the anticapated number of ports on the direct
    attached host
    adapter.
    
    Signed-off-by: Eric Moore <Eric.Moore@lsil.com>
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>

diff --git a/drivers/scsi/scsi_transport_sas.c b/drivers/scsi/scsi_transport_sas.c
index fb6641b42dfa..a3e0b7bc2d7b 100644
--- a/drivers/scsi/scsi_transport_sas.c
+++ b/drivers/scsi/scsi_transport_sas.c
@@ -638,7 +638,7 @@ int sas_rphy_add(struct sas_rphy *rphy)
 	mutex_unlock(&sas_host->lock);
 
 	if (rphy->scsi_target_id != -1) {
-		scsi_scan_target(&rphy->dev, parent->number,
+		scsi_scan_target(&rphy->dev, parent->port_identifier,
 				rphy->scsi_target_id, ~0, 0);
 	}
 
@@ -745,9 +745,9 @@ static int sas_user_scan(struct Scsi_Host *shost, uint channel,
 		if (rphy->scsi_target_id == -1)
 			continue;
 
-		if ((channel == SCAN_WILD_CARD || channel == parent->number) &&
+		if ((channel == SCAN_WILD_CARD || channel == parent->port_identifier) &&
 		    (id == SCAN_WILD_CARD || id == rphy->scsi_target_id)) {
-			scsi_scan_target(&rphy->dev, parent->number,
+			scsi_scan_target(&rphy->dev, parent->port_identifier,
 					 rphy->scsi_target_id, lun, 1);
 		}
 	}

commit e02f3f59225d8c3b2a0ad0dc941a09865e27da61
Author: Christoph Hellwig <hch@lst.de>
Date:   Fri Jan 13 19:04:00 2006 +0100

    [SCSI] remove target parent limitiation
    
    When James Smart fixed the issue of the userspace scan atributes
    crashing the system with the FC transport class he added a patch to
    let the transport class check if the parent is valid for a given
    transport class.
    
    When adding support for the integrated raid of fusion sas devices
    we ran into a problem with that, as it didn't allow adding virtual
    raid volumes without the transport class knowing about it.
    
    So this patch adds a user_scan attribute instead, that takes over from
    scsi_scan_host_selected if the transport class sets it and thus lets
    the transport class control the user-initiated scanning.  As this
    plugs the hole about user-initiated scanning the target_parent hook
    goes away and we rely on callers of the scanning routines to do
    something sensible.
    
    For SAS this meant I had to switch from a spinlock to a mutex to
    synchronize the topology linked lists, in FC they were completely
    unsynchronized which seems wrong.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>

diff --git a/drivers/scsi/scsi_transport_sas.c b/drivers/scsi/scsi_transport_sas.c
index e950435a11d8..fb6641b42dfa 100644
--- a/drivers/scsi/scsi_transport_sas.c
+++ b/drivers/scsi/scsi_transport_sas.c
@@ -29,6 +29,7 @@
 #include <linux/slab.h>
 #include <linux/string.h>
 
+#include <scsi/scsi.h>
 #include <scsi/scsi_device.h>
 #include <scsi/scsi_host.h>
 #include <scsi/scsi_transport.h>
@@ -62,7 +63,7 @@ struct sas_internal {
 
 struct sas_host_attrs {
 	struct list_head rphy_list;
-	spinlock_t lock;
+	struct mutex lock;
 	u32 next_target_id;
 };
 #define to_sas_host_attrs(host)	((struct sas_host_attrs *)(host)->shost_data)
@@ -165,7 +166,7 @@ static int sas_host_setup(struct transport_container *tc, struct device *dev,
 	struct sas_host_attrs *sas_host = to_sas_host_attrs(shost);
 
 	INIT_LIST_HEAD(&sas_host->rphy_list);
-	spin_lock_init(&sas_host->lock);
+	mutex_init(&sas_host->lock);
 	sas_host->next_target_id = 0;
 	return 0;
 }
@@ -626,7 +627,7 @@ int sas_rphy_add(struct sas_rphy *rphy)
 	transport_add_device(&rphy->dev);
 	transport_configure_device(&rphy->dev);
 
-	spin_lock(&sas_host->lock);
+	mutex_lock(&sas_host->lock);
 	list_add_tail(&rphy->list, &sas_host->rphy_list);
 	if (identify->device_type == SAS_END_DEVICE &&
 	    (identify->target_port_protocols &
@@ -634,7 +635,7 @@ int sas_rphy_add(struct sas_rphy *rphy)
 		rphy->scsi_target_id = sas_host->next_target_id++;
 	else
 		rphy->scsi_target_id = -1;
-	spin_unlock(&sas_host->lock);
+	mutex_unlock(&sas_host->lock);
 
 	if (rphy->scsi_target_id != -1) {
 		scsi_scan_target(&rphy->dev, parent->number,
@@ -661,9 +662,9 @@ void sas_rphy_free(struct sas_rphy *rphy)
 	struct Scsi_Host *shost = dev_to_shost(rphy->dev.parent->parent);
 	struct sas_host_attrs *sas_host = to_sas_host_attrs(shost);
 
-	spin_lock(&sas_host->lock);
+	mutex_lock(&sas_host->lock);
 	list_del(&rphy->list);
-	spin_unlock(&sas_host->lock);
+	mutex_unlock(&sas_host->lock);
 
 	transport_destroy_device(&rphy->dev);
 	put_device(rphy->dev.parent);
@@ -703,9 +704,9 @@ sas_rphy_delete(struct sas_rphy *rphy)
 	device_del(dev);
 	transport_destroy_device(dev);
 
-	spin_lock(&sas_host->lock);
+	mutex_lock(&sas_host->lock);
 	list_del(&rphy->list);
-	spin_unlock(&sas_host->lock);
+	mutex_unlock(&sas_host->lock);
 
 	parent->rphy = NULL;
 
@@ -731,23 +732,28 @@ EXPORT_SYMBOL(scsi_is_sas_rphy);
  * SCSI scan helper
  */
 
-static struct device *sas_target_parent(struct Scsi_Host *shost,
-					int channel, uint id)
+static int sas_user_scan(struct Scsi_Host *shost, uint channel,
+		uint id, uint lun)
 {
 	struct sas_host_attrs *sas_host = to_sas_host_attrs(shost);
 	struct sas_rphy *rphy;
-	struct device *dev = NULL;
 
-	spin_lock(&sas_host->lock);
+	mutex_lock(&sas_host->lock);
 	list_for_each_entry(rphy, &sas_host->rphy_list, list) {
 		struct sas_phy *parent = dev_to_phy(rphy->dev.parent);
-		if (parent->number == channel &&
-		    rphy->scsi_target_id == id)
-			dev = &rphy->dev;
+
+		if (rphy->scsi_target_id == -1)
+			continue;
+
+		if ((channel == SCAN_WILD_CARD || channel == parent->number) &&
+		    (id == SCAN_WILD_CARD || id == rphy->scsi_target_id)) {
+			scsi_scan_target(&rphy->dev, parent->number,
+					 rphy->scsi_target_id, lun, 1);
+		}
 	}
-	spin_unlock(&sas_host->lock);
+	mutex_unlock(&sas_host->lock);
 
-	return dev;
+	return 0;
 }
 
 
@@ -792,7 +798,7 @@ sas_attach_transport(struct sas_function_template *ft)
 		return NULL;
 	memset(i, 0, sizeof(struct sas_internal));
 
-	i->t.target_parent = sas_target_parent;
+	i->t.user_scan = sas_user_scan;
 
 	i->t.host_attrs.ac.attrs = &i->host_attrs[0];
 	i->t.host_attrs.ac.class = &sas_host_class.class;

commit d4054239929479907f20b9d68c905589125ad343
Author: Christoph Hellwig <hch@lst.de>
Date:   Wed Jan 4 13:45:20 2006 +0100

    [SCSI] sas: fix removal of devices behind expanders
    
    We need to iterate over all children when removing and expander, else
    stale objects will be around after host removal.  This fixes the oops
    Eric Moore saw when removing and reloading mptsas.
    
    Also don't try the scsi_remove_target call unless operating on an end
    device.  The current unconditional call is harmless but confusing.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>

diff --git a/drivers/scsi/scsi_transport_sas.c b/drivers/scsi/scsi_transport_sas.c
index 357b52f5f996..e950435a11d8 100644
--- a/drivers/scsi/scsi_transport_sas.c
+++ b/drivers/scsi/scsi_transport_sas.c
@@ -687,7 +687,17 @@ sas_rphy_delete(struct sas_rphy *rphy)
 	struct Scsi_Host *shost = dev_to_shost(parent->dev.parent);
 	struct sas_host_attrs *sas_host = to_sas_host_attrs(shost);
 
-	scsi_remove_target(dev);
+	switch (rphy->identify.device_type) {
+	case SAS_END_DEVICE:
+		scsi_remove_target(dev);
+		break;
+	case SAS_EDGE_EXPANDER_DEVICE:
+	case SAS_FANOUT_EXPANDER_DEVICE:
+		device_for_each_child(dev, NULL, do_sas_phy_delete);
+		break;
+	default:
+		break;
+	}
 
 	transport_remove_device(dev);
 	device_del(dev);

commit 33b114e935a2202206e224dd2c695cee5a5986bf
Author: Christoph Hellwig <hch@lst.de>
Date:   Wed Jan 11 14:20:43 2006 +0100

    [SCSI] sas: clear parent->rphy in sas_rphy_delete
    
    We need to clear the backpointer on rphy removal, else we'll run into
    problems with host removal after a device has been hot unplugged.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>

diff --git a/drivers/scsi/scsi_transport_sas.c b/drivers/scsi/scsi_transport_sas.c
index edabbd05d258..357b52f5f996 100644
--- a/drivers/scsi/scsi_transport_sas.c
+++ b/drivers/scsi/scsi_transport_sas.c
@@ -697,6 +697,8 @@ sas_rphy_delete(struct sas_rphy *rphy)
 	list_del(&rphy->list);
 	spin_unlock(&sas_host->lock);
 
+	parent->rphy = NULL;
+
 	put_device(&parent->dev);
 }
 EXPORT_SYMBOL(sas_rphy_delete);

commit 8c65b4a60450590e79a28e9717ceffa9e4debb3f
Author: Tim Schmielau <tim@physik3.uni-rostock.de>
Date:   Mon Nov 7 00:59:43 2005 -0800

    [PATCH] fix remaining missing includes
    
    Fix more include file problems that surfaced since I submitted the previous
    fix-missing-includes.patch.  This should now allow not to include sched.h
    from module.h, which is done by a followup patch.
    
    Signed-off-by: Tim Schmielau <tim@physik3.uni-rostock.de>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/drivers/scsi/scsi_transport_sas.c b/drivers/scsi/scsi_transport_sas.c
index 0cc766a9aa65..edabbd05d258 100644
--- a/drivers/scsi/scsi_transport_sas.c
+++ b/drivers/scsi/scsi_transport_sas.c
@@ -26,6 +26,8 @@
 #include <linux/init.h>
 #include <linux/module.h>
 #include <linux/err.h>
+#include <linux/slab.h>
+#include <linux/string.h>
 
 #include <scsi/scsi_device.h>
 #include <scsi/scsi_host.h>

commit 07ba3a954714da10cbd3f6249d93ac2c1df72c4f
Author: Christoph Hellwig <hch@lst.de>
Date:   Wed Oct 19 20:01:31 2005 +0200

    [SCSI] sas: add support for PHY resets
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>

diff --git a/drivers/scsi/scsi_transport_sas.c b/drivers/scsi/scsi_transport_sas.c
index f5618c1116f4..0cc766a9aa65 100644
--- a/drivers/scsi/scsi_transport_sas.c
+++ b/drivers/scsi/scsi_transport_sas.c
@@ -34,7 +34,7 @@
 
 
 #define SAS_HOST_ATTRS		0
-#define SAS_PORT_ATTRS		15
+#define SAS_PORT_ATTRS		17
 #define SAS_RPORT_ATTRS		5
 
 struct sas_internal {
@@ -289,9 +289,39 @@ show_sas_device_type(struct class_device *cdev, char *buf)
 		return snprintf(buf, 20, "none\n");
 	return get_sas_device_type_names(phy->identify.device_type, buf);
 }
-
 static CLASS_DEVICE_ATTR(device_type, S_IRUGO, show_sas_device_type, NULL);
 
+static ssize_t do_sas_phy_reset(struct class_device *cdev,
+		size_t count, int hard_reset)
+{
+	struct sas_phy *phy = transport_class_to_phy(cdev);
+	struct Scsi_Host *shost = dev_to_shost(phy->dev.parent);
+	struct sas_internal *i = to_sas_internal(shost->transportt);
+	int error;
+
+	if (!phy->local_attached)
+		return -EINVAL;
+
+	error = i->f->phy_reset(phy, hard_reset);
+	if (error)
+		return error;
+	return count;
+};
+
+static ssize_t store_sas_link_reset(struct class_device *cdev,
+		const char *buf, size_t count)
+{
+	return do_sas_phy_reset(cdev, count, 0);
+}
+static CLASS_DEVICE_ATTR(link_reset, S_IWUSR, NULL, store_sas_link_reset);
+
+static ssize_t store_sas_hard_reset(struct class_device *cdev,
+		const char *buf, size_t count)
+{
+	return do_sas_phy_reset(cdev, count, 1);
+}
+static CLASS_DEVICE_ATTR(hard_reset, S_IWUSR, NULL, store_sas_hard_reset);
+
 sas_phy_protocol_attr(identify.initiator_port_protocols,
 		initiator_port_protocols);
 sas_phy_protocol_attr(identify.target_port_protocols,
@@ -725,6 +755,13 @@ static struct device *sas_target_parent(struct Scsi_Host *shost,
         i->phy_attrs[count] = &i->private_phy_attrs[count];		\
 	count++
 
+#define SETUP_PORT_ATTRIBUTE_WRONLY(field)				\
+	i->private_phy_attrs[count] = class_device_attr_##field;	\
+	i->private_phy_attrs[count].attr.mode = S_IWUGO;		\
+	i->private_phy_attrs[count].show = NULL;			\
+	i->phy_attrs[count] = &i->private_phy_attrs[count];		\
+	count++
+
 
 /**
  * sas_attach_transport  --  instantiate SAS transport template
@@ -781,6 +818,8 @@ sas_attach_transport(struct sas_function_template *ft)
 	SETUP_PORT_ATTRIBUTE(running_disparity_error_count);
 	SETUP_PORT_ATTRIBUTE(loss_of_dword_sync_count);
 	SETUP_PORT_ATTRIBUTE(phy_reset_problem_count);
+	SETUP_PORT_ATTRIBUTE_WRONLY(link_reset);
+	SETUP_PORT_ATTRIBUTE_WRONLY(hard_reset);
 	i->phy_attrs[count] = NULL;
 
 	count = 0;

commit ac01bbbd3b7ebfca64357aed12cf476b16abe3ce
Author: Christoph Hellwig <hch@lst.de>
Date:   Wed Oct 19 20:01:17 2005 +0200

    [SCSI] sas: add flag for locally attached PHYs
    
    Add a flag to mark a PHY as attached to the HBA as opposed to beeing on
    an expander.  This is needed because various features are only supported
    on those.  This is a crude hack, the proper fix would be to use
    different classes for host-attached vs expander phys.  I'm looking into
    that.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>

diff --git a/drivers/scsi/scsi_transport_sas.c b/drivers/scsi/scsi_transport_sas.c
index 63445f90097e..f5618c1116f4 100644
--- a/drivers/scsi/scsi_transport_sas.c
+++ b/drivers/scsi/scsi_transport_sas.c
@@ -266,6 +266,9 @@ show_sas_phy_##field(struct class_device *cdev, char *buf)		\
 	struct sas_internal *i = to_sas_internal(shost->transportt);	\
 	int error;							\
 									\
+	if (!phy->local_attached)					\
+		return -EINVAL;						\
+									\
 	error = i->f->get_linkerrors(phy);				\
 	if (error)							\
 		return error;						\

commit c3ee74c4e91017169c7f1fa74a57ba8502ec49c3
Author: Christoph Hellwig <hch@lst.de>
Date:   Mon Sep 19 21:59:42 2005 +0200

    [SCSI] scsi_transport_sas: support link error attributes
    
    For now supporting the ->get_linkerrors method is mandatory.  I'll
    probably be beaten to implement the .show_foo variables and different
    types of attributes soon..
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>

diff --git a/drivers/scsi/scsi_transport_sas.c b/drivers/scsi/scsi_transport_sas.c
index 1d145d2f9a38..63445f90097e 100644
--- a/drivers/scsi/scsi_transport_sas.c
+++ b/drivers/scsi/scsi_transport_sas.c
@@ -34,7 +34,7 @@
 
 
 #define SAS_HOST_ATTRS		0
-#define SAS_PORT_ATTRS		11
+#define SAS_PORT_ATTRS		15
 #define SAS_RPORT_ATTRS		5
 
 struct sas_internal {
@@ -257,6 +257,26 @@ show_sas_phy_##field(struct class_device *cdev, char *buf)		\
 	sas_phy_show_linkspeed(field)					\
 static CLASS_DEVICE_ATTR(field, S_IRUGO, show_sas_phy_##field, NULL)
 
+#define sas_phy_show_linkerror(field)					\
+static ssize_t								\
+show_sas_phy_##field(struct class_device *cdev, char *buf)		\
+{									\
+	struct sas_phy *phy = transport_class_to_phy(cdev);		\
+	struct Scsi_Host *shost = dev_to_shost(phy->dev.parent);	\
+	struct sas_internal *i = to_sas_internal(shost->transportt);	\
+	int error;							\
+									\
+	error = i->f->get_linkerrors(phy);				\
+	if (error)							\
+		return error;						\
+	return snprintf(buf, 20, "%u\n", phy->field);			\
+}
+
+#define sas_phy_linkerror_attr(field)					\
+	sas_phy_show_linkerror(field)					\
+static CLASS_DEVICE_ATTR(field, S_IRUGO, show_sas_phy_##field, NULL)
+
+
 static ssize_t
 show_sas_device_type(struct class_device *cdev, char *buf)
 {
@@ -282,6 +302,10 @@ sas_phy_linkspeed_attr(minimum_linkrate_hw);
 sas_phy_linkspeed_attr(minimum_linkrate);
 sas_phy_linkspeed_attr(maximum_linkrate_hw);
 sas_phy_linkspeed_attr(maximum_linkrate);
+sas_phy_linkerror_attr(invalid_dword_count);
+sas_phy_linkerror_attr(running_disparity_error_count);
+sas_phy_linkerror_attr(loss_of_dword_sync_count);
+sas_phy_linkerror_attr(phy_reset_problem_count);
 
 
 static DECLARE_TRANSPORT_CLASS(sas_phy_class,
@@ -749,6 +773,11 @@ sas_attach_transport(struct sas_function_template *ft)
 	SETUP_PORT_ATTRIBUTE(minimum_linkrate);
 	SETUP_PORT_ATTRIBUTE(maximum_linkrate_hw);
 	SETUP_PORT_ATTRIBUTE(maximum_linkrate);
+
+	SETUP_PORT_ATTRIBUTE(invalid_dword_count);
+	SETUP_PORT_ATTRIBUTE(running_disparity_error_count);
+	SETUP_PORT_ATTRIBUTE(loss_of_dword_sync_count);
+	SETUP_PORT_ATTRIBUTE(phy_reset_problem_count);
 	i->phy_attrs[count] = NULL;
 
 	count = 0;

commit fe8b2304e54552cea113318e2f66c45628130fdc
Author: Christoph Hellwig <hch@lst.de>
Date:   Sun Sep 25 23:10:33 2005 +0200

    [SCSI] sas: fix remote phy removal
    
    Brown paperbag bug:  sas_rphy_delete was ordered completely
    wrong.  Fix it up to be the same order as sas_phy_delete or
    fc_rport_terminate and fix rphy objects that leaked after module
    removal.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>

diff --git a/drivers/scsi/scsi_transport_sas.c b/drivers/scsi/scsi_transport_sas.c
index ff724bbe6611..1d145d2f9a38 100644
--- a/drivers/scsi/scsi_transport_sas.c
+++ b/drivers/scsi/scsi_transport_sas.c
@@ -628,17 +628,16 @@ sas_rphy_delete(struct sas_rphy *rphy)
 	struct Scsi_Host *shost = dev_to_shost(parent->dev.parent);
 	struct sas_host_attrs *sas_host = to_sas_host_attrs(shost);
 
-	transport_destroy_device(&rphy->dev);
+	scsi_remove_target(dev);
 
-	scsi_remove_target(&rphy->dev);
+	transport_remove_device(dev);
+	device_del(dev);
+	transport_destroy_device(dev);
 
 	spin_lock(&sas_host->lock);
 	list_del(&rphy->list);
 	spin_unlock(&sas_host->lock);
 
-	transport_remove_device(dev);
-	device_del(dev);
-	transport_destroy_device(dev);
 	put_device(&parent->dev);
 }
 EXPORT_SYMBOL(sas_rphy_delete);

commit 37be6eeb4990c05fc7dd683ceaf1501d46ebe9a4
Author: James Bottomley <James.Bottomley@steeleye.com>
Date:   Fri Sep 9 18:38:27 2005 -0500

    [SCSI] SAS transport class: fixup prototype of sas_host_setup
    
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>

diff --git a/drivers/scsi/scsi_transport_sas.c b/drivers/scsi/scsi_transport_sas.c
index ac4a53a019c0..ff724bbe6611 100644
--- a/drivers/scsi/scsi_transport_sas.c
+++ b/drivers/scsi/scsi_transport_sas.c
@@ -156,7 +156,8 @@ sas_bitfield_name_search(linkspeed, sas_linkspeed_names)
  * SAS host attributes
  */
 
-static int sas_host_setup(struct device *dev)
+static int sas_host_setup(struct transport_container *tc, struct device *dev,
+			  struct class_device *cdev)
 {
 	struct Scsi_Host *shost = dev_to_shost(dev);
 	struct sas_host_attrs *sas_host = to_sas_host_attrs(shost);

commit c7ebbbce366c02e5657ac6b6059933fe0353b175
Author: Christoph Hellwig <hch@lst.de>
Date:   Fri Sep 9 16:22:50 2005 +0200

    [SCSI] SAS transport class
    
    The SAS transport class contains common code to deal with SAS HBAs, an
    aproximated representation of SAS topologies in the driver model,
    and various sysfs attributes to expose these topologies and managment
    interfaces to userspace.
    
    In addition to the basic SCSI core objects this transport class introduces
    two additional intermediate objects:  The SAS PHY as represented by struct
    sas_phy defines an "outgoing" PHY on a SAS HBA or Expander, and the SAS
    remote PHY represented by struct sas_rphy defines an "incoming" PHY on a
    SAS Expander or end device.  Note that this is purely a software concept, the
    underlying hardware for a PHY and a remote PHY is the exactly the same.
    
    There is no concept of a SAS port in this code, users can see what PHYs
    form a wide port based on the port_identifier attribute, which is the same
    for all PHYs in a port.
    
    This submission doesn't handle hot-plug addition or removal of SAS devices
    and thus doesn't do scanning in a workqueue yet, that will be added in
    phase2 after this submission.  In a third phase I will add additional
    managment infrastructure.
    
    I think this submission is ready for 2.6.14, but additional comments are
    of course very welcome.
    
    I'd like to thanks James Smart a lot for his very useful input on the
    design.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>

diff --git a/drivers/scsi/scsi_transport_sas.c b/drivers/scsi/scsi_transport_sas.c
new file mode 100644
index 000000000000..ac4a53a019c0
--- /dev/null
+++ b/drivers/scsi/scsi_transport_sas.c
@@ -0,0 +1,819 @@
+/*
+ * Copyright (C) 2005 Dell Inc.
+ *	Released under GPL v2.
+ *
+ * Serial Attached SCSI (SAS) transport class.
+ *
+ * The SAS transport class contains common code to deal with SAS HBAs,
+ * an aproximated representation of SAS topologies in the driver model,
+ * and various sysfs attributes to expose these topologies and managment
+ * interfaces to userspace.
+ *
+ * In addition to the basic SCSI core objects this transport class
+ * introduces two additional intermediate objects:  The SAS PHY
+ * as represented by struct sas_phy defines an "outgoing" PHY on
+ * a SAS HBA or Expander, and the SAS remote PHY represented by
+ * struct sas_rphy defines an "incoming" PHY on a SAS Expander or
+ * end device.  Note that this is purely a software concept, the
+ * underlying hardware for a PHY and a remote PHY is the exactly
+ * the same.
+ *
+ * There is no concept of a SAS port in this code, users can see
+ * what PHYs form a wide port based on the port_identifier attribute,
+ * which is the same for all PHYs in a port.
+ */
+
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/err.h>
+
+#include <scsi/scsi_device.h>
+#include <scsi/scsi_host.h>
+#include <scsi/scsi_transport.h>
+#include <scsi/scsi_transport_sas.h>
+
+
+#define SAS_HOST_ATTRS		0
+#define SAS_PORT_ATTRS		11
+#define SAS_RPORT_ATTRS		5
+
+struct sas_internal {
+	struct scsi_transport_template t;
+	struct sas_function_template *f;
+
+	struct class_device_attribute private_host_attrs[SAS_HOST_ATTRS];
+	struct class_device_attribute private_phy_attrs[SAS_PORT_ATTRS];
+	struct class_device_attribute private_rphy_attrs[SAS_RPORT_ATTRS];
+
+	struct transport_container phy_attr_cont;
+	struct transport_container rphy_attr_cont;
+
+	/*
+	 * The array of null terminated pointers to attributes
+	 * needed by scsi_sysfs.c
+	 */
+	struct class_device_attribute *host_attrs[SAS_HOST_ATTRS + 1];
+	struct class_device_attribute *phy_attrs[SAS_PORT_ATTRS + 1];
+	struct class_device_attribute *rphy_attrs[SAS_RPORT_ATTRS + 1];
+};
+#define to_sas_internal(tmpl)	container_of(tmpl, struct sas_internal, t)
+
+struct sas_host_attrs {
+	struct list_head rphy_list;
+	spinlock_t lock;
+	u32 next_target_id;
+};
+#define to_sas_host_attrs(host)	((struct sas_host_attrs *)(host)->shost_data)
+
+
+/*
+ * Hack to allow attributes of the same name in different objects.
+ */
+#define SAS_CLASS_DEVICE_ATTR(_prefix,_name,_mode,_show,_store) \
+	struct class_device_attribute class_device_attr_##_prefix##_##_name = \
+	__ATTR(_name,_mode,_show,_store)
+
+
+/*
+ * Pretty printing helpers
+ */
+
+#define sas_bitfield_name_match(title, table)			\
+static ssize_t							\
+get_sas_##title##_names(u32 table_key, char *buf)		\
+{								\
+	char *prefix = "";					\
+	ssize_t len = 0;					\
+	int i;							\
+								\
+	for (i = 0; i < sizeof(table)/sizeof(table[0]); i++) {	\
+		if (table[i].value & table_key) {		\
+			len += sprintf(buf + len, "%s%s",	\
+				prefix, table[i].name);		\
+			prefix = ", ";				\
+		}						\
+	}							\
+	len += sprintf(buf + len, "\n");			\
+	return len;						\
+}
+
+#define sas_bitfield_name_search(title, table)			\
+static ssize_t							\
+get_sas_##title##_names(u32 table_key, char *buf)		\
+{								\
+	ssize_t len = 0;					\
+	int i;							\
+								\
+	for (i = 0; i < sizeof(table)/sizeof(table[0]); i++) {	\
+		if (table[i].value == table_key) {		\
+			len += sprintf(buf + len, "%s",		\
+				table[i].name);			\
+			break;					\
+		}						\
+	}							\
+	len += sprintf(buf + len, "\n");			\
+	return len;						\
+}
+
+static struct {
+	u32		value;
+	char		*name;
+} sas_device_type_names[] = {
+	{ SAS_PHY_UNUSED,		"unused" },
+	{ SAS_END_DEVICE,		"end device" },
+	{ SAS_EDGE_EXPANDER_DEVICE,	"edge expander" },
+	{ SAS_FANOUT_EXPANDER_DEVICE,	"fanout expander" },
+};
+sas_bitfield_name_search(device_type, sas_device_type_names)
+
+
+static struct {
+	u32		value;
+	char		*name;
+} sas_protocol_names[] = {
+	{ SAS_PROTOCOL_SATA,		"sata" },
+	{ SAS_PROTOCOL_SMP,		"smp" },
+	{ SAS_PROTOCOL_STP,		"stp" },
+	{ SAS_PROTOCOL_SSP,		"ssp" },
+};
+sas_bitfield_name_match(protocol, sas_protocol_names)
+
+static struct {
+	u32		value;
+	char		*name;
+} sas_linkspeed_names[] = {
+	{ SAS_LINK_RATE_UNKNOWN,	"Unknown" },
+	{ SAS_PHY_DISABLED,		"Phy disabled" },
+	{ SAS_LINK_RATE_FAILED,		"Link Rate failed" },
+	{ SAS_SATA_SPINUP_HOLD,		"Spin-up hold" },
+	{ SAS_LINK_RATE_1_5_GBPS,	"1.5 Gbit" },
+	{ SAS_LINK_RATE_3_0_GBPS,	"3.0 Gbit" },
+};
+sas_bitfield_name_search(linkspeed, sas_linkspeed_names)
+
+
+/*
+ * SAS host attributes
+ */
+
+static int sas_host_setup(struct device *dev)
+{
+	struct Scsi_Host *shost = dev_to_shost(dev);
+	struct sas_host_attrs *sas_host = to_sas_host_attrs(shost);
+
+	INIT_LIST_HEAD(&sas_host->rphy_list);
+	spin_lock_init(&sas_host->lock);
+	sas_host->next_target_id = 0;
+	return 0;
+}
+
+static DECLARE_TRANSPORT_CLASS(sas_host_class,
+		"sas_host", sas_host_setup, NULL, NULL);
+
+static int sas_host_match(struct attribute_container *cont,
+			    struct device *dev)
+{
+	struct Scsi_Host *shost;
+	struct sas_internal *i;
+
+	if (!scsi_is_host_device(dev))
+		return 0;
+	shost = dev_to_shost(dev);
+
+	if (!shost->transportt)
+		return 0;
+	if (shost->transportt->host_attrs.ac.class !=
+			&sas_host_class.class)
+		return 0;
+
+	i = to_sas_internal(shost->transportt);
+	return &i->t.host_attrs.ac == cont;
+}
+
+static int do_sas_phy_delete(struct device *dev, void *data)
+{
+	if (scsi_is_sas_phy(dev))
+		sas_phy_delete(dev_to_phy(dev));
+	return 0;
+}
+
+/**
+ * sas_remove_host  --  tear down a Scsi_Host's SAS data structures
+ * @shost:	Scsi Host that is torn down
+ *
+ * Removes all SAS PHYs and remote PHYs for a given Scsi_Host.
+ * Must be called just before scsi_remove_host for SAS HBAs.
+ */
+void sas_remove_host(struct Scsi_Host *shost)
+{
+	device_for_each_child(&shost->shost_gendev, NULL, do_sas_phy_delete);
+}
+EXPORT_SYMBOL(sas_remove_host);
+
+
+/*
+ * SAS Port attributes
+ */
+
+#define sas_phy_show_simple(field, name, format_string, cast)		\
+static ssize_t								\
+show_sas_phy_##name(struct class_device *cdev, char *buf)		\
+{									\
+	struct sas_phy *phy = transport_class_to_phy(cdev);		\
+									\
+	return snprintf(buf, 20, format_string, cast phy->field);	\
+}
+
+#define sas_phy_simple_attr(field, name, format_string, type)		\
+	sas_phy_show_simple(field, name, format_string, (type))	\
+static CLASS_DEVICE_ATTR(name, S_IRUGO, show_sas_phy_##name, NULL)
+
+#define sas_phy_show_protocol(field, name)				\
+static ssize_t								\
+show_sas_phy_##name(struct class_device *cdev, char *buf)		\
+{									\
+	struct sas_phy *phy = transport_class_to_phy(cdev);		\
+									\
+	if (!phy->field)						\
+		return snprintf(buf, 20, "none\n");			\
+	return get_sas_protocol_names(phy->field, buf);		\
+}
+
+#define sas_phy_protocol_attr(field, name)				\
+	sas_phy_show_protocol(field, name)				\
+static CLASS_DEVICE_ATTR(name, S_IRUGO, show_sas_phy_##name, NULL)
+
+#define sas_phy_show_linkspeed(field)					\
+static ssize_t								\
+show_sas_phy_##field(struct class_device *cdev, char *buf)		\
+{									\
+	struct sas_phy *phy = transport_class_to_phy(cdev);		\
+									\
+	return get_sas_linkspeed_names(phy->field, buf);		\
+}
+
+#define sas_phy_linkspeed_attr(field)					\
+	sas_phy_show_linkspeed(field)					\
+static CLASS_DEVICE_ATTR(field, S_IRUGO, show_sas_phy_##field, NULL)
+
+static ssize_t
+show_sas_device_type(struct class_device *cdev, char *buf)
+{
+	struct sas_phy *phy = transport_class_to_phy(cdev);
+
+	if (!phy->identify.device_type)
+		return snprintf(buf, 20, "none\n");
+	return get_sas_device_type_names(phy->identify.device_type, buf);
+}
+
+static CLASS_DEVICE_ATTR(device_type, S_IRUGO, show_sas_device_type, NULL);
+
+sas_phy_protocol_attr(identify.initiator_port_protocols,
+		initiator_port_protocols);
+sas_phy_protocol_attr(identify.target_port_protocols,
+		target_port_protocols);
+sas_phy_simple_attr(identify.sas_address, sas_address, "0x%016llx\n",
+		unsigned long long);
+sas_phy_simple_attr(identify.phy_identifier, phy_identifier, "%d\n", u8);
+sas_phy_simple_attr(port_identifier, port_identifier, "%d\n", u8);
+sas_phy_linkspeed_attr(negotiated_linkrate);
+sas_phy_linkspeed_attr(minimum_linkrate_hw);
+sas_phy_linkspeed_attr(minimum_linkrate);
+sas_phy_linkspeed_attr(maximum_linkrate_hw);
+sas_phy_linkspeed_attr(maximum_linkrate);
+
+
+static DECLARE_TRANSPORT_CLASS(sas_phy_class,
+		"sas_phy", NULL, NULL, NULL);
+
+static int sas_phy_match(struct attribute_container *cont, struct device *dev)
+{
+	struct Scsi_Host *shost;
+	struct sas_internal *i;
+
+	if (!scsi_is_sas_phy(dev))
+		return 0;
+	shost = dev_to_shost(dev->parent);
+
+	if (!shost->transportt)
+		return 0;
+	if (shost->transportt->host_attrs.ac.class !=
+			&sas_host_class.class)
+		return 0;
+
+	i = to_sas_internal(shost->transportt);
+	return &i->phy_attr_cont.ac == cont;
+}
+
+static void sas_phy_release(struct device *dev)
+{
+	struct sas_phy *phy = dev_to_phy(dev);
+
+	put_device(dev->parent);
+	kfree(phy);
+}
+
+/**
+ * sas_phy_alloc  --  allocates and initialize a SAS PHY structure
+ * @parent:	Parent device
+ * @number:	Port number
+ *
+ * Allocates an SAS PHY structure.  It will be added in the device tree
+ * below the device specified by @parent, which has to be either a Scsi_Host
+ * or sas_rphy.
+ *
+ * Returns:
+ *	SAS PHY allocated or %NULL if the allocation failed.
+ */
+struct sas_phy *sas_phy_alloc(struct device *parent, int number)
+{
+	struct Scsi_Host *shost = dev_to_shost(parent);
+	struct sas_phy *phy;
+
+	phy = kmalloc(sizeof(*phy), GFP_KERNEL);
+	if (!phy)
+		return NULL;
+	memset(phy, 0, sizeof(*phy));
+
+	get_device(parent);
+
+	phy->number = number;
+
+	device_initialize(&phy->dev);
+	phy->dev.parent = get_device(parent);
+	phy->dev.release = sas_phy_release;
+	sprintf(phy->dev.bus_id, "phy-%d:%d", shost->host_no, number);
+
+	transport_setup_device(&phy->dev);
+
+	return phy;
+}
+EXPORT_SYMBOL(sas_phy_alloc);
+
+/**
+ * sas_phy_add  --  add a SAS PHY to the device hierachy
+ * @phy:	The PHY to be added
+ *
+ * Publishes a SAS PHY to the rest of the system.
+ */
+int sas_phy_add(struct sas_phy *phy)
+{
+	int error;
+
+	error = device_add(&phy->dev);
+	if (!error) {
+		transport_add_device(&phy->dev);
+		transport_configure_device(&phy->dev);
+	}
+
+	return error;
+}
+EXPORT_SYMBOL(sas_phy_add);
+
+/**
+ * sas_phy_free  --  free a SAS PHY
+ * @phy:	SAS PHY to free
+ *
+ * Frees the specified SAS PHY.
+ *
+ * Note:
+ *   This function must only be called on a PHY that has not
+ *   sucessfully been added using sas_phy_add().
+ */
+void sas_phy_free(struct sas_phy *phy)
+{
+	transport_destroy_device(&phy->dev);
+	put_device(phy->dev.parent);
+	put_device(phy->dev.parent);
+	put_device(phy->dev.parent);
+	kfree(phy);
+}
+EXPORT_SYMBOL(sas_phy_free);
+
+/**
+ * sas_phy_delete  --  remove SAS PHY
+ * @phy:	SAS PHY to remove
+ *
+ * Removes the specified SAS PHY.  If the SAS PHY has an
+ * associated remote PHY it is removed before.
+ */
+void
+sas_phy_delete(struct sas_phy *phy)
+{
+	struct device *dev = &phy->dev;
+
+	if (phy->rphy)
+		sas_rphy_delete(phy->rphy);
+
+	transport_remove_device(dev);
+	device_del(dev);
+	transport_destroy_device(dev);
+	put_device(dev->parent);
+}
+EXPORT_SYMBOL(sas_phy_delete);
+
+/**
+ * scsi_is_sas_phy  --  check if a struct device represents a SAS PHY
+ * @dev:	device to check
+ *
+ * Returns:
+ *	%1 if the device represents a SAS PHY, %0 else
+ */
+int scsi_is_sas_phy(const struct device *dev)
+{
+	return dev->release == sas_phy_release;
+}
+EXPORT_SYMBOL(scsi_is_sas_phy);
+
+/*
+ * SAS remote PHY attributes.
+ */
+
+#define sas_rphy_show_simple(field, name, format_string, cast)		\
+static ssize_t								\
+show_sas_rphy_##name(struct class_device *cdev, char *buf)		\
+{									\
+	struct sas_rphy *rphy = transport_class_to_rphy(cdev);	\
+									\
+	return snprintf(buf, 20, format_string, cast rphy->field);	\
+}
+
+#define sas_rphy_simple_attr(field, name, format_string, type)		\
+	sas_rphy_show_simple(field, name, format_string, (type))	\
+static SAS_CLASS_DEVICE_ATTR(rphy, name, S_IRUGO, 			\
+		show_sas_rphy_##name, NULL)
+
+#define sas_rphy_show_protocol(field, name)				\
+static ssize_t								\
+show_sas_rphy_##name(struct class_device *cdev, char *buf)		\
+{									\
+	struct sas_rphy *rphy = transport_class_to_rphy(cdev);	\
+									\
+	if (!rphy->field)					\
+		return snprintf(buf, 20, "none\n");			\
+	return get_sas_protocol_names(rphy->field, buf);	\
+}
+
+#define sas_rphy_protocol_attr(field, name)				\
+	sas_rphy_show_protocol(field, name)				\
+static SAS_CLASS_DEVICE_ATTR(rphy, name, S_IRUGO,			\
+		show_sas_rphy_##name, NULL)
+
+static ssize_t
+show_sas_rphy_device_type(struct class_device *cdev, char *buf)
+{
+	struct sas_rphy *rphy = transport_class_to_rphy(cdev);
+
+	if (!rphy->identify.device_type)
+		return snprintf(buf, 20, "none\n");
+	return get_sas_device_type_names(
+			rphy->identify.device_type, buf);
+}
+
+static SAS_CLASS_DEVICE_ATTR(rphy, device_type, S_IRUGO,
+		show_sas_rphy_device_type, NULL);
+
+sas_rphy_protocol_attr(identify.initiator_port_protocols,
+		initiator_port_protocols);
+sas_rphy_protocol_attr(identify.target_port_protocols, target_port_protocols);
+sas_rphy_simple_attr(identify.sas_address, sas_address, "0x%016llx\n",
+		unsigned long long);
+sas_rphy_simple_attr(identify.phy_identifier, phy_identifier, "%d\n", u8);
+
+static DECLARE_TRANSPORT_CLASS(sas_rphy_class,
+		"sas_rphy", NULL, NULL, NULL);
+
+static int sas_rphy_match(struct attribute_container *cont, struct device *dev)
+{
+	struct Scsi_Host *shost;
+	struct sas_internal *i;
+
+	if (!scsi_is_sas_rphy(dev))
+		return 0;
+	shost = dev_to_shost(dev->parent->parent);
+
+	if (!shost->transportt)
+		return 0;
+	if (shost->transportt->host_attrs.ac.class !=
+			&sas_host_class.class)
+		return 0;
+
+	i = to_sas_internal(shost->transportt);
+	return &i->rphy_attr_cont.ac == cont;
+}
+
+static void sas_rphy_release(struct device *dev)
+{
+	struct sas_rphy *rphy = dev_to_rphy(dev);
+
+	put_device(dev->parent);
+	kfree(rphy);
+}
+
+/**
+ * sas_rphy_alloc  --  allocates and initialize a SAS remote PHY structure
+ * @parent:		SAS PHY this remote PHY is conneted to
+ *
+ * Allocates an SAS remote PHY structure, connected to @parent.
+ *
+ * Returns:
+ *	SAS PHY allocated or %NULL if the allocation failed.
+ */
+struct sas_rphy *sas_rphy_alloc(struct sas_phy *parent)
+{
+	struct Scsi_Host *shost = dev_to_shost(&parent->dev);
+	struct sas_rphy *rphy;
+
+	rphy = kmalloc(sizeof(*rphy), GFP_KERNEL);
+	if (!rphy) {
+		put_device(&parent->dev);
+		return NULL;
+	}
+	memset(rphy, 0, sizeof(*rphy));
+
+	device_initialize(&rphy->dev);
+	rphy->dev.parent = get_device(&parent->dev);
+	rphy->dev.release = sas_rphy_release;
+	sprintf(rphy->dev.bus_id, "rphy-%d:%d",
+		shost->host_no, parent->number);
+	transport_setup_device(&rphy->dev);
+
+	return rphy;
+}
+EXPORT_SYMBOL(sas_rphy_alloc);
+
+/**
+ * sas_rphy_add  --  add a SAS remote PHY to the device hierachy
+ * @rphy:	The remote PHY to be added
+ *
+ * Publishes a SAS remote PHY to the rest of the system.
+ */
+int sas_rphy_add(struct sas_rphy *rphy)
+{
+	struct sas_phy *parent = dev_to_phy(rphy->dev.parent);
+	struct Scsi_Host *shost = dev_to_shost(parent->dev.parent);
+	struct sas_host_attrs *sas_host = to_sas_host_attrs(shost);
+	struct sas_identify *identify = &rphy->identify;
+	int error;
+
+	if (parent->rphy)
+		return -ENXIO;
+	parent->rphy = rphy;
+
+	error = device_add(&rphy->dev);
+	if (error)
+		return error;
+	transport_add_device(&rphy->dev);
+	transport_configure_device(&rphy->dev);
+
+	spin_lock(&sas_host->lock);
+	list_add_tail(&rphy->list, &sas_host->rphy_list);
+	if (identify->device_type == SAS_END_DEVICE &&
+	    (identify->target_port_protocols &
+	     (SAS_PROTOCOL_SSP|SAS_PROTOCOL_STP|SAS_PROTOCOL_SATA)))
+		rphy->scsi_target_id = sas_host->next_target_id++;
+	else
+		rphy->scsi_target_id = -1;
+	spin_unlock(&sas_host->lock);
+
+	if (rphy->scsi_target_id != -1) {
+		scsi_scan_target(&rphy->dev, parent->number,
+				rphy->scsi_target_id, ~0, 0);
+	}
+
+	return 0;
+}
+EXPORT_SYMBOL(sas_rphy_add);
+
+/**
+ * sas_rphy_free  --  free a SAS remote PHY
+ * @rphy	SAS remote PHY to free
+ *
+ * Frees the specified SAS remote PHY.
+ *
+ * Note:
+ *   This function must only be called on a remote
+ *   PHY that has not sucessfully been added using
+ *   sas_rphy_add().
+ */
+void sas_rphy_free(struct sas_rphy *rphy)
+{
+	struct Scsi_Host *shost = dev_to_shost(rphy->dev.parent->parent);
+	struct sas_host_attrs *sas_host = to_sas_host_attrs(shost);
+
+	spin_lock(&sas_host->lock);
+	list_del(&rphy->list);
+	spin_unlock(&sas_host->lock);
+
+	transport_destroy_device(&rphy->dev);
+	put_device(rphy->dev.parent);
+	put_device(rphy->dev.parent);
+	put_device(rphy->dev.parent);
+	kfree(rphy);
+}
+EXPORT_SYMBOL(sas_rphy_free);
+
+/**
+ * sas_rphy_delete  --  remove SAS remote PHY
+ * @rphy:	SAS remote PHY to remove
+ *
+ * Removes the specified SAS remote PHY.
+ */
+void
+sas_rphy_delete(struct sas_rphy *rphy)
+{
+	struct device *dev = &rphy->dev;
+	struct sas_phy *parent = dev_to_phy(dev->parent);
+	struct Scsi_Host *shost = dev_to_shost(parent->dev.parent);
+	struct sas_host_attrs *sas_host = to_sas_host_attrs(shost);
+
+	transport_destroy_device(&rphy->dev);
+
+	scsi_remove_target(&rphy->dev);
+
+	spin_lock(&sas_host->lock);
+	list_del(&rphy->list);
+	spin_unlock(&sas_host->lock);
+
+	transport_remove_device(dev);
+	device_del(dev);
+	transport_destroy_device(dev);
+	put_device(&parent->dev);
+}
+EXPORT_SYMBOL(sas_rphy_delete);
+
+/**
+ * scsi_is_sas_rphy  --  check if a struct device represents a SAS remote PHY
+ * @dev:	device to check
+ *
+ * Returns:
+ *	%1 if the device represents a SAS remote PHY, %0 else
+ */
+int scsi_is_sas_rphy(const struct device *dev)
+{
+	return dev->release == sas_rphy_release;
+}
+EXPORT_SYMBOL(scsi_is_sas_rphy);
+
+
+/*
+ * SCSI scan helper
+ */
+
+static struct device *sas_target_parent(struct Scsi_Host *shost,
+					int channel, uint id)
+{
+	struct sas_host_attrs *sas_host = to_sas_host_attrs(shost);
+	struct sas_rphy *rphy;
+	struct device *dev = NULL;
+
+	spin_lock(&sas_host->lock);
+	list_for_each_entry(rphy, &sas_host->rphy_list, list) {
+		struct sas_phy *parent = dev_to_phy(rphy->dev.parent);
+		if (parent->number == channel &&
+		    rphy->scsi_target_id == id)
+			dev = &rphy->dev;
+	}
+	spin_unlock(&sas_host->lock);
+
+	return dev;
+}
+
+
+/*
+ * Setup / Teardown code
+ */
+
+#define SETUP_RPORT_ATTRIBUTE(field)					\
+	i->private_rphy_attrs[count] = class_device_attr_##field;	\
+	i->private_rphy_attrs[count].attr.mode = S_IRUGO;		\
+	i->private_rphy_attrs[count].store = NULL;			\
+	i->rphy_attrs[count] = &i->private_rphy_attrs[count];	\
+	count++
+
+#define SETUP_PORT_ATTRIBUTE(field)					\
+	i->private_phy_attrs[count] = class_device_attr_##field;	\
+        i->private_phy_attrs[count].attr.mode = S_IRUGO;		\
+        i->private_phy_attrs[count].store = NULL;			\
+        i->phy_attrs[count] = &i->private_phy_attrs[count];		\
+	count++
+
+
+/**
+ * sas_attach_transport  --  instantiate SAS transport template
+ * @ft:		SAS transport class function template
+ */
+struct scsi_transport_template *
+sas_attach_transport(struct sas_function_template *ft)
+{
+	struct sas_internal *i;
+	int count;
+
+	i = kmalloc(sizeof(struct sas_internal), GFP_KERNEL);
+	if (!i)
+		return NULL;
+	memset(i, 0, sizeof(struct sas_internal));
+
+	i->t.target_parent = sas_target_parent;
+
+	i->t.host_attrs.ac.attrs = &i->host_attrs[0];
+	i->t.host_attrs.ac.class = &sas_host_class.class;
+	i->t.host_attrs.ac.match = sas_host_match;
+	transport_container_register(&i->t.host_attrs);
+	i->t.host_size = sizeof(struct sas_host_attrs);
+
+	i->phy_attr_cont.ac.class = &sas_phy_class.class;
+	i->phy_attr_cont.ac.attrs = &i->phy_attrs[0];
+	i->phy_attr_cont.ac.match = sas_phy_match;
+	transport_container_register(&i->phy_attr_cont);
+
+	i->rphy_attr_cont.ac.class = &sas_rphy_class.class;
+	i->rphy_attr_cont.ac.attrs = &i->rphy_attrs[0];
+	i->rphy_attr_cont.ac.match = sas_rphy_match;
+	transport_container_register(&i->rphy_attr_cont);
+
+	i->f = ft;
+
+	count = 0;
+	i->host_attrs[count] = NULL;
+
+	count = 0;
+	SETUP_PORT_ATTRIBUTE(initiator_port_protocols);
+	SETUP_PORT_ATTRIBUTE(target_port_protocols);
+	SETUP_PORT_ATTRIBUTE(device_type);
+	SETUP_PORT_ATTRIBUTE(sas_address);
+	SETUP_PORT_ATTRIBUTE(phy_identifier);
+	SETUP_PORT_ATTRIBUTE(port_identifier);
+	SETUP_PORT_ATTRIBUTE(negotiated_linkrate);
+	SETUP_PORT_ATTRIBUTE(minimum_linkrate_hw);
+	SETUP_PORT_ATTRIBUTE(minimum_linkrate);
+	SETUP_PORT_ATTRIBUTE(maximum_linkrate_hw);
+	SETUP_PORT_ATTRIBUTE(maximum_linkrate);
+	i->phy_attrs[count] = NULL;
+
+	count = 0;
+	SETUP_RPORT_ATTRIBUTE(rphy_initiator_port_protocols);
+	SETUP_RPORT_ATTRIBUTE(rphy_target_port_protocols);
+	SETUP_RPORT_ATTRIBUTE(rphy_device_type);
+	SETUP_RPORT_ATTRIBUTE(rphy_sas_address);
+	SETUP_RPORT_ATTRIBUTE(rphy_phy_identifier);
+	i->rphy_attrs[count] = NULL;
+
+	return &i->t;
+}
+EXPORT_SYMBOL(sas_attach_transport);
+
+/**
+ * sas_release_transport  --  release SAS transport template instance
+ * @t:		transport template instance
+ */
+void sas_release_transport(struct scsi_transport_template *t)
+{
+	struct sas_internal *i = to_sas_internal(t);
+
+	transport_container_unregister(&i->t.host_attrs);
+	transport_container_unregister(&i->phy_attr_cont);
+	transport_container_unregister(&i->rphy_attr_cont);
+
+	kfree(i);
+}
+EXPORT_SYMBOL(sas_release_transport);
+
+static __init int sas_transport_init(void)
+{
+	int error;
+
+	error = transport_class_register(&sas_host_class);
+	if (error)
+		goto out;
+	error = transport_class_register(&sas_phy_class);
+	if (error)
+		goto out_unregister_transport;
+	error = transport_class_register(&sas_rphy_class);
+	if (error)
+		goto out_unregister_phy;
+
+	return 0;
+
+ out_unregister_phy:
+	transport_class_unregister(&sas_phy_class);
+ out_unregister_transport:
+	transport_class_unregister(&sas_host_class);
+ out:
+	return error;
+
+}
+
+static void __exit sas_transport_exit(void)
+{
+	transport_class_unregister(&sas_host_class);
+	transport_class_unregister(&sas_phy_class);
+	transport_class_unregister(&sas_rphy_class);
+}
+
+MODULE_AUTHOR("Christoph Hellwig");
+MODULE_DESCRIPTION("SAS Transphy Attributes");
+MODULE_LICENSE("GPL");
+
+module_init(sas_transport_init);
+module_exit(sas_transport_exit);
