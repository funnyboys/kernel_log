commit 58751759a6f278209bed375908129f14dd0a4915
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Fri May 31 01:09:46 2019 -0700

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 388
    
    Based on 1 normalized pattern(s):
    
      this program is free software you may redistribute and or modify it
      under the terms of the gnu general public license version 2 as
      published by the free software foundation this program is
      distributed in the hope that it will be useful but without any
      warranty without even the implied warranty of merchantability or
      fitness for a particular purpose see the gnu general public license
      for complete details
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-only
    
    has been chosen to replace the boilerplate/reference in 2 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Kate Stewart <kstewart@linuxfoundation.org>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Reviewed-by: Richard Fontana <rfontana@redhat.com>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190531081037.747331493@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/scsi/BusLogic.h b/drivers/scsi/BusLogic.h
index 8d47e2c88d24..6182cc8a0344 100644
--- a/drivers/scsi/BusLogic.h
+++ b/drivers/scsi/BusLogic.h
@@ -1,17 +1,10 @@
+/* SPDX-License-Identifier: GPL-2.0-only */
 /*
 
   Linux Driver for BusLogic MultiMaster and FlashPoint SCSI Host Adapters
 
   Copyright 1995-1998 by Leonard N. Zubkoff <lnz@dandelion.com>
 
-  This program is free software; you may redistribute and/or modify it under
-  the terms of the GNU General Public License Version 2 as published by the
-  Free Software Foundation.
-
-  This program is distributed in the hope that it will be useful, but
-  WITHOUT ANY WARRANTY, without even the implied warranty of MERCHANTABILITY
-  or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
-  for complete details.
 
   The author respectfully requests that any modifications to this software be
   sent directly to him for evaluation and testing.

commit 20961065a88a7ac8f7d7c8f256028304b55fa0b7
Author: Colin Ian King <colin.king@canonical.com>
Date:   Tue Feb 21 16:27:11 2017 +0000

    scsi: BusLogic: fix incorrect spelling of adatper_reset_req
    
    Trivial fix to spelling mistake, adatper_reset_req should be
    adapter_reset_req.  Also break up very long seq_printf statement into
    multiple lines.
    
    Signed-off-by: Colin Ian King <colin.king@canonical.com>
    Acked-by: Khalid Aziz <khalid@gonehiking.org>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/BusLogic.h b/drivers/scsi/BusLogic.h
index b53ec2f1e8cd..8d47e2c88d24 100644
--- a/drivers/scsi/BusLogic.h
+++ b/drivers/scsi/BusLogic.h
@@ -935,7 +935,7 @@ struct blogic_tgt_stats {
 	unsigned short bdr_request;
 	unsigned short bdr_tried;
 	unsigned short bdr_done;
-	unsigned short adatper_reset_req;
+	unsigned short adapter_reset_req;
 	unsigned short adapter_reset_attempt;
 	unsigned short adapter_reset_done;
 };

commit 391e2f25601e34a7d7e5dc155e487bc58dffd8c6
Author: Khalid Aziz <khalid.aziz@oracle.com>
Date:   Thu May 16 19:44:14 2013 -0600

    [SCSI] BusLogic: Port driver to 64-bit.
    
    [jejb: fix up pointer to int cast warning]
    Signed-off-by: Khalid Aziz <khalid.aziz@oracle.com>
    Signed-off-by: James Bottomley <JBottomley@Parallels.com>

diff --git a/drivers/scsi/BusLogic.h b/drivers/scsi/BusLogic.h
index 8349c0f1438a..b53ec2f1e8cd 100644
--- a/drivers/scsi/BusLogic.h
+++ b/drivers/scsi/BusLogic.h
@@ -821,7 +821,7 @@ struct blogic_ccb {
 	unsigned char cdblen;				/* Byte 2 */
 	unsigned char sense_datalen;			/* Byte 3 */
 	u32 datalen;					/* Bytes 4-7 */
-	u32 data;					/* Bytes 8-11 */
+	void *data;					/* Bytes 8-11 */
 	unsigned char:8;				/* Byte 12 */
 	unsigned char:8;				/* Byte 13 */
 	enum blogic_adapter_status adapter_status;	/* Byte 14 */
@@ -833,7 +833,7 @@ struct blogic_ccb {
 	unsigned char cdb[BLOGIC_CDB_MAXLEN];		/* Bytes 18-29 */
 	unsigned char:8;				/* Byte 30 */
 	unsigned char:8;				/* Byte 31 */
-	unsigned int:32;				/* Bytes 32-35 */
+	u32 rsvd_int;					/* Bytes 32-35 */
 	u32 sensedata;					/* Bytes 36-39 */
 	/*
 	   FlashPoint SCCB Manager Defined Portion.
@@ -843,8 +843,11 @@ struct blogic_ccb {
 	enum blogic_cmplt_code comp_code;		/* Byte 48 */
 #ifdef CONFIG_SCSI_FLASHPOINT
 	unsigned char:8;				/* Byte 49 */
-	unsigned short os_flags;			/* Bytes 50-51 */
-	unsigned char private[48];			/* Bytes 52-99 */
+	u16 os_flags;					/* Bytes 50-51 */
+	unsigned char private[24];			/* Bytes 52-99 */
+	void *rsvd1;
+	void *rsvd2;
+	unsigned char private2[16];
 #endif
 	/*
 	   BusLogic Linux Driver Defined Portion.
@@ -867,7 +870,7 @@ struct blogic_ccb {
 
 struct blogic_outbox {
 	u32 ccb;			/* Bytes 0-3 */
-	unsigned int:24;		/* Bytes 4-6 */
+	u32:24;				/* Bytes 4-6 */
 	enum blogic_action action;	/* Byte 7 */
 };
 
@@ -876,11 +879,11 @@ struct blogic_outbox {
 */
 
 struct blogic_inbox {
-	u32 ccb;		/* Bytes 0-3 */
+	u32 ccb;					/* Bytes 0-3 */
 	enum blogic_adapter_status adapter_status;	/* Byte 4 */
-	enum blogic_tgt_status tgt_status;	/* Byte 5 */
-	unsigned char:8;	/* Byte 6 */
-	enum blogic_cmplt_code comp_code;	/* Byte 7 */
+	enum blogic_tgt_status tgt_status;		/* Byte 5 */
+	unsigned char:8;				/* Byte 6 */
+	enum blogic_cmplt_code comp_code;		/* Byte 7 */
 };
 
 
@@ -941,7 +944,7 @@ struct blogic_tgt_stats {
   Define the FlashPoint Card Handle data type.
 */
 
-#define FPOINT_BADCARD_HANDLE		0xFFFFFFFF
+#define FPOINT_BADCARD_HANDLE		0xFFFFFFFFL
 
 
 /*
@@ -955,12 +958,12 @@ struct fpoint_info {
 	unsigned char irq_ch;			/* Byte 5 */
 	unsigned char scsi_id;			/* Byte 6 */
 	unsigned char scsi_lun;			/* Byte 7 */
-	unsigned short fw_rev;			/* Bytes 8-9 */
-	unsigned short sync_ok;			/* Bytes 10-11 */
-	unsigned short fast_ok;			/* Bytes 12-13 */
-	unsigned short ultra_ok;		/* Bytes 14-15 */
-	unsigned short discon_ok;		/* Bytes 16-17 */
-	unsigned short wide_ok;			/* Bytes 18-19 */
+	u16 fw_rev;				/* Bytes 8-9 */
+	u16 sync_ok;				/* Bytes 10-11 */
+	u16 fast_ok;				/* Bytes 12-13 */
+	u16 ultra_ok;				/* Bytes 14-15 */
+	u16 discon_ok;				/* Bytes 16-17 */
+	u16 wide_ok;				/* Bytes 18-19 */
 	bool parity:1;				/* Byte 20 Bit 0 */
 	bool wide:1;				/* Byte 20 Bit 1 */
 	bool softreset:1;			/* Byte 20 Bit 2 */
@@ -976,10 +979,10 @@ struct fpoint_info {
 	unsigned char model[3];			/* Bytes 24-26 */
 	unsigned char relative_cardnum;		/* Byte 27 */
 	unsigned char rsvd[4];			/* Bytes 28-31 */
-	unsigned int os_rsvd;			/* Bytes 32-35 */
+	u32 os_rsvd;				/* Bytes 32-35 */
 	unsigned char translation_info[4];	/* Bytes 36-39 */
-	unsigned int rsvd2[5];			/* Bytes 40-59 */
-	unsigned int sec_range;			/* Bytes 60-63 */
+	u32 rsvd2[5];				/* Bytes 40-59 */
+	u32 sec_range;				/* Bytes 60-63 */
 };
 
 /*
@@ -1052,7 +1055,7 @@ struct blogic_adapter {
 	u32 bios_addr;
 	struct blogic_drvr_options *drvr_opts;
 	struct fpoint_info fpinfo;
-	unsigned int cardhandle;
+	void *cardhandle;
 	struct list_head host_list;
 	struct blogic_ccb *all_ccbs;
 	struct blogic_ccb *free_ccbs;

commit 839cb99e8f748391059d10388c8aea48a88c142c
Author: Khalid Aziz <khalid.aziz@oracle.com>
Date:   Thu May 16 19:44:13 2013 -0600

    [SCSI] BusLogic: Fix style issues
    
    Fix CamelCase and extra long lines in the buslogic driver.
    
    Signed-off-by: Khalid Aziz <khalid.aziz@oracle.com>
    Signed-off-by: James Bottomley <JBottomley@Parallels.com>

diff --git a/drivers/scsi/BusLogic.h b/drivers/scsi/BusLogic.h
index 6c6c13c3be1b..8349c0f1438a 100644
--- a/drivers/scsi/BusLogic.h
+++ b/drivers/scsi/BusLogic.h
@@ -37,14 +37,14 @@
   Define the maximum number of BusLogic Host Adapters supported by this driver.
 */
 
-#define BusLogic_MaxHostAdapters		16
+#define BLOGIC_MAX_ADAPTERS		16
 
 
 /*
   Define the maximum number of Target Devices supported by this driver.
 */
 
-#define BusLogic_MaxTargetDevices		16
+#define BLOGIC_MAXDEV			16
 
 
 /*
@@ -53,7 +53,7 @@
   large as the largest single request generated by the I/O Subsystem.
 */
 
-#define BusLogic_ScatterGatherLimit		128
+#define BLOGIC_SG_LIMIT		128
 
 
 /*
@@ -62,12 +62,12 @@
   Tagged Queuing and whether or not ISA Bounce Buffers are required.
 */
 
-#define BusLogic_MaxTaggedQueueDepth		64
-#define BusLogic_MaxAutomaticTaggedQueueDepth	28
-#define BusLogic_MinAutomaticTaggedQueueDepth	7
-#define BusLogic_TaggedQueueDepthBB		3
-#define BusLogic_UntaggedQueueDepth		3
-#define BusLogic_UntaggedQueueDepthBB		2
+#define BLOGIC_MAX_TAG_DEPTH		64
+#define BLOGIC_MAX_AUTO_TAG_DEPTH	28
+#define BLOGIC_MIN_AUTO_TAG_DEPTH	7
+#define BLOGIC_TAG_DEPTH_BB		3
+#define BLOGIC_UNTAG_DEPTH		3
+#define BLOGIC_UNTAG_DEPTH_BB		2
 
 
 /*
@@ -77,7 +77,7 @@
   a SCSI Bus Reset.
 */
 
-#define BusLogic_DefaultBusSettleTime		2
+#define BLOGIC_BUS_SETTLE_TIME		2
 
 
 /*
@@ -87,7 +87,7 @@
   does not cross an allocation block size boundary.
 */
 
-#define BusLogic_MaxMailboxes			211
+#define BLOGIC_MAX_MAILBOX		211
 
 
 /*
@@ -95,50 +95,50 @@
   Kernel memory allocation.
 */
 
-#define BusLogic_CCB_AllocationGroupSize	7
+#define BLOGIC_CCB_GRP_ALLOCSIZE	7
 
 
 /*
   Define the Host Adapter Line and Message Buffer Sizes.
 */
 
-#define BusLogic_LineBufferSize			100
-#define BusLogic_MessageBufferSize		9700
+#define BLOGIC_LINEBUF_SIZE		100
+#define BLOGIC_MSGBUF_SIZE		9700
 
 
 /*
   Define the Driver Message Levels.
 */
 
-enum BusLogic_MessageLevel {
-	BusLogic_AnnounceLevel = 0,
-	BusLogic_InfoLevel = 1,
-	BusLogic_NoticeLevel = 2,
-	BusLogic_WarningLevel = 3,
-	BusLogic_ErrorLevel = 4
+enum blogic_msglevel {
+	BLOGIC_ANNOUNCE_LEVEL = 0,
+	BLOGIC_INFO_LEVEL = 1,
+	BLOGIC_NOTICE_LEVEL = 2,
+	BLOGIC_WARN_LEVEL = 3,
+	BLOGIC_ERR_LEVEL = 4
 };
 
-static char *BusLogic_MessageLevelMap[] = { KERN_NOTICE, KERN_NOTICE, KERN_NOTICE, KERN_WARNING, KERN_ERR };
+static char *blogic_msglevelmap[] = { KERN_NOTICE, KERN_NOTICE, KERN_NOTICE, KERN_WARNING, KERN_ERR };
 
 
 /*
   Define Driver Message macros.
 */
 
-#define BusLogic_Announce(Format, Arguments...) \
-  BusLogic_Message(BusLogic_AnnounceLevel, Format, ##Arguments)
+#define blogic_announce(format, args...) \
+	blogic_msg(BLOGIC_ANNOUNCE_LEVEL, format, ##args)
 
-#define BusLogic_Info(Format, Arguments...) \
-  BusLogic_Message(BusLogic_InfoLevel, Format, ##Arguments)
+#define blogic_info(format, args...) \
+	blogic_msg(BLOGIC_INFO_LEVEL, format, ##args)
 
-#define BusLogic_Notice(Format, Arguments...) \
-  BusLogic_Message(BusLogic_NoticeLevel, Format, ##Arguments)
+#define blogic_notice(format, args...) \
+	blogic_msg(BLOGIC_NOTICE_LEVEL, format, ##args)
 
-#define BusLogic_Warning(Format, Arguments...) \
-  BusLogic_Message(BusLogic_WarningLevel, Format, ##Arguments)
+#define blogic_warn(format, args...) \
+	blogic_msg(BLOGIC_WARN_LEVEL, format, ##args)
 
-#define BusLogic_Error(Format, Arguments...) \
-  BusLogic_Message(BusLogic_ErrorLevel, Format, ##Arguments)
+#define blogic_err(format, args...) \
+	blogic_msg(BLOGIC_ERR_LEVEL, format, ##args)
 
 
 /*
@@ -146,15 +146,15 @@ static char *BusLogic_MessageLevelMap[] = { KERN_NOTICE, KERN_NOTICE, KERN_NOTIC
   of I/O Addresses required by each type.
 */
 
-enum BusLogic_HostAdapterType {
-	BusLogic_MultiMaster = 1,
-	BusLogic_FlashPoint = 2
+enum blogic_adapter_type {
+	BLOGIC_MULTIMASTER = 1,
+	BLOGIC_FLASHPOINT = 2
 } PACKED;
 
-#define BusLogic_MultiMasterAddressCount	4
-#define BusLogic_FlashPointAddressCount		256
+#define BLOGIC_MULTIMASTER_ADDR_COUNT	4
+#define BLOGIC_FLASHPOINT_ADDR_COUNT	256
 
-static int BusLogic_HostAdapterAddressCount[3] = { 0, BusLogic_MultiMasterAddressCount, BusLogic_FlashPointAddressCount };
+static int blogic_adapter_addr_count[3] = { 0, BLOGIC_MULTIMASTER_ADDR_COUNT, BLOGIC_FLASHPOINT_ADDR_COUNT };
 
 
 /*
@@ -163,19 +163,16 @@ static int BusLogic_HostAdapterAddressCount[3] = { 0, BusLogic_MultiMasterAddres
 
 #ifdef CONFIG_SCSI_FLASHPOINT
 
-#define BusLogic_MultiMasterHostAdapterP(HostAdapter) \
-  (HostAdapter->HostAdapterType == BusLogic_MultiMaster)
+#define blogic_multimaster_type(adapter) \
+	(adapter->adapter_type == BLOGIC_MULTIMASTER)
 
-#define BusLogic_FlashPointHostAdapterP(HostAdapter) \
-  (HostAdapter->HostAdapterType == BusLogic_FlashPoint)
+#define blogic_flashpoint_type(adapter) \
+	(adapter->adapter_type == BLOGIC_FLASHPOINT)
 
 #else
 
-#define BusLogic_MultiMasterHostAdapterP(HostAdapter) \
-  (true)
-
-#define BusLogic_FlashPointHostAdapterP(HostAdapter) \
-  (false)
+#define blogic_multimaster_type(adapter)	(true)
+#define blogic_flashpoint_type(adapter)		(false)
 
 #endif
 
@@ -184,35 +181,35 @@ static int BusLogic_HostAdapterAddressCount[3] = { 0, BusLogic_MultiMasterAddres
   Define the possible Host Adapter Bus Types.
 */
 
-enum BusLogic_HostAdapterBusType {
-	BusLogic_Unknown_Bus = 0,
-	BusLogic_ISA_Bus = 1,
-	BusLogic_EISA_Bus = 2,
-	BusLogic_PCI_Bus = 3,
-	BusLogic_VESA_Bus = 4,
-	BusLogic_MCA_Bus = 5
+enum blogic_adapter_bus_type {
+	BLOGIC_UNKNOWN_BUS = 0,
+	BLOGIC_ISA_BUS = 1,
+	BLOGIC_EISA_BUS = 2,
+	BLOGIC_PCI_BUS = 3,
+	BLOGIC_VESA_BUS = 4,
+	BLOGIC_MCA_BUS = 5
 } PACKED;
 
-static char *BusLogic_HostAdapterBusNames[] = { "Unknown", "ISA", "EISA", "PCI", "VESA", "MCA" };
+static char *blogic_adapter_busnames[] = { "Unknown", "ISA", "EISA", "PCI", "VESA", "MCA" };
 
-static enum BusLogic_HostAdapterBusType BusLogic_HostAdapterBusTypes[] = {
-	BusLogic_VESA_Bus,	/* BT-4xx */
-	BusLogic_ISA_Bus,	/* BT-5xx */
-	BusLogic_MCA_Bus,	/* BT-6xx */
-	BusLogic_EISA_Bus,	/* BT-7xx */
-	BusLogic_Unknown_Bus,	/* BT-8xx */
-	BusLogic_PCI_Bus	/* BT-9xx */
+static enum blogic_adapter_bus_type blogic_adater_bus_types[] = {
+	BLOGIC_VESA_BUS,	/* BT-4xx */
+	BLOGIC_ISA_BUS,		/* BT-5xx */
+	BLOGIC_MCA_BUS,		/* BT-6xx */
+	BLOGIC_EISA_BUS,	/* BT-7xx */
+	BLOGIC_UNKNOWN_BUS,	/* BT-8xx */
+	BLOGIC_PCI_BUS		/* BT-9xx */
 };
 
 /*
   Define the possible Host Adapter BIOS Disk Geometry Translations.
 */
 
-enum BusLogic_BIOS_DiskGeometryTranslation {
-	BusLogic_BIOS_Disk_Not_Installed = 0,
-	BusLogic_BIOS_Disk_Installed_64x32 = 1,
-	BusLogic_BIOS_Disk_Installed_128x32 = 2,
-	BusLogic_BIOS_Disk_Installed_255x63 = 3
+enum blogic_bios_diskgeometry {
+	BLOGIC_BIOS_NODISK = 0,
+	BLOGIC_BIOS_DISK64x32 = 1,
+	BLOGIC_BIOS_DISK128x32 = 2,
+	BLOGIC_BIOS_DISK255x63 = 3
 } PACKED;
 
 
@@ -220,9 +217,9 @@ enum BusLogic_BIOS_DiskGeometryTranslation {
   Define a 10^18 Statistics Byte Counter data type.
 */
 
-struct BusLogic_ByteCounter {
-	unsigned int Units;
-	unsigned int Billions;
+struct blogic_byte_count {
+	unsigned int units;
+	unsigned int billions;
 };
 
 
@@ -230,79 +227,71 @@ struct BusLogic_ByteCounter {
   Define the structure for I/O Address and Bus Probing Information.
 */
 
-struct BusLogic_ProbeInfo {
-	enum BusLogic_HostAdapterType HostAdapterType;
-	enum BusLogic_HostAdapterBusType HostAdapterBusType;
-	unsigned long IO_Address;
-	unsigned long PCI_Address;
-	struct pci_dev *PCI_Device;
-	unsigned char Bus;
-	unsigned char Device;
-	unsigned char IRQ_Channel;
+struct blogic_probeinfo {
+	enum blogic_adapter_type adapter_type;
+	enum blogic_adapter_bus_type adapter_bus_type;
+	unsigned long io_addr;
+	unsigned long pci_addr;
+	struct pci_dev *pci_device;
+	unsigned char bus;
+	unsigned char dev;
+	unsigned char irq_ch;
 };
 
 /*
   Define the Probe Options.
 */
 
-struct BusLogic_ProbeOptions {
-	bool NoProbe:1;		/* Bit 0 */
-	bool NoProbeISA:1;	/* Bit 1 */
-	bool NoProbePCI:1;	/* Bit 2 */
-	bool NoSortPCI:1;	/* Bit 3 */
-	bool MultiMasterFirst:1;/* Bit 4 */
-	bool FlashPointFirst:1;	/* Bit 5 */
-	bool LimitedProbeISA:1;	/* Bit 6 */
-	bool Probe330:1;	/* Bit 7 */
-	bool Probe334:1;	/* Bit 8 */
-	bool Probe230:1;	/* Bit 9 */
-	bool Probe234:1;	/* Bit 10 */
-	bool Probe130:1;	/* Bit 11 */
-	bool Probe134:1;	/* Bit 12 */
+struct blogic_probe_options {
+	bool noprobe:1;			/* Bit 0 */
+	bool noprobe_isa:1;		/* Bit 1 */
+	bool noprobe_pci:1;		/* Bit 2 */
+	bool nosort_pci:1;		/* Bit 3 */
+	bool multimaster_first:1;	/* Bit 4 */
+	bool flashpoint_first:1;	/* Bit 5 */
+	bool limited_isa:1;		/* Bit 6 */
+	bool probe330:1;		/* Bit 7 */
+	bool probe334:1;		/* Bit 8 */
+	bool probe230:1;		/* Bit 9 */
+	bool probe234:1;		/* Bit 10 */
+	bool probe130:1;		/* Bit 11 */
+	bool probe134:1;		/* Bit 12 */
 };
 
 /*
   Define the Global Options.
 */
 
-struct BusLogic_GlobalOptions {
-	bool TraceProbe:1;	/* Bit 0 */
-	bool TraceHardwareReset:1;	/* Bit 1 */
-	bool TraceConfiguration:1;	/* Bit 2 */
-	bool TraceErrors:1;	/* Bit 3 */
-};
-
-/*
-  Define the Local Options.
-*/
-
-struct BusLogic_LocalOptions {
-	bool InhibitTargetInquiry:1;	/* Bit 0 */
+struct blogic_global_options {
+	bool trace_probe:1;	/* Bit 0 */
+	bool trace_hw_reset:1;	/* Bit 1 */
+	bool trace_config:1;	/* Bit 2 */
+	bool trace_err:1;	/* Bit 3 */
 };
 
 /*
   Define the BusLogic SCSI Host Adapter I/O Register Offsets.
 */
 
-#define BusLogic_ControlRegisterOffset		0	/* WO register */
-#define BusLogic_StatusRegisterOffset		0	/* RO register */
-#define BusLogic_CommandParameterRegisterOffset	1	/* WO register */
-#define BusLogic_DataInRegisterOffset		1	/* RO register */
-#define BusLogic_InterruptRegisterOffset	2	/* RO register */
-#define BusLogic_GeometryRegisterOffset		3	/* RO register */
+#define BLOGIC_CNTRL_REG	0	/* WO register */
+#define BLOGIC_STATUS_REG	0	/* RO register */
+#define BLOGIC_CMD_PARM_REG	1	/* WO register */
+#define BLOGIC_DATAIN_REG	1	/* RO register */
+#define BLOGIC_INT_REG		2	/* RO register */
+#define BLOGIC_GEOMETRY_REG	3	/* RO register */
 
 /*
   Define the structure of the write-only Control Register.
 */
 
-union BusLogic_ControlRegister {
-	unsigned char All;
+union blogic_cntrl_reg {
+	unsigned char all;
 	struct {
 		unsigned char:4;	/* Bits 0-3 */
-		bool SCSIBusReset:1;	/* Bit 4 */
-		bool InterruptReset:1;	/* Bit 5 */
-		bool SoftReset:1;	/* Bit 6 */
-		bool HardReset:1;	/* Bit 7 */
+		bool bus_reset:1;	/* Bit 4 */
+		bool int_reset:1;	/* Bit 5 */
+		bool soft_reset:1;	/* Bit 6 */
+		bool hard_reset:1;	/* Bit 7 */
 	} cr;
 };
 
@@ -310,17 +299,17 @@ union BusLogic_ControlRegister {
   Define the structure of the read-only Status Register.
 */
 
-union BusLogic_StatusRegister {
-	unsigned char All;
+union blogic_stat_reg {
+	unsigned char all;
 	struct {
-		bool CommandInvalid:1;		/* Bit 0 */
-		bool Reserved:1;		/* Bit 1 */
-		bool DataInRegisterReady:1;	/* Bit 2 */
-		bool CommandParameterRegisterBusy:1;	/* Bit 3 */
-		bool HostAdapterReady:1;	/* Bit 4 */
-		bool InitializationRequired:1;	/* Bit 5 */
-		bool DiagnosticFailure:1;	/* Bit 6 */
-		bool DiagnosticActive:1;	/* Bit 7 */
+		bool cmd_invalid:1;	/* Bit 0 */
+		bool rsvd:1;		/* Bit 1 */
+		bool datain_ready:1;	/* Bit 2 */
+		bool cmd_param_busy:1;	/* Bit 3 */
+		bool adapter_ready:1;	/* Bit 4 */
+		bool init_reqd:1;	/* Bit 5 */
+		bool diag_failed:1;	/* Bit 6 */
+		bool diag_active:1;	/* Bit 7 */
 	} sr;
 };
 
@@ -328,15 +317,15 @@ union BusLogic_StatusRegister {
   Define the structure of the read-only Interrupt Register.
 */
 
-union BusLogic_InterruptRegister {
-	unsigned char All;
+union blogic_int_reg {
+	unsigned char all;
 	struct {
-		bool IncomingMailboxLoaded:1;	/* Bit 0 */
-		bool OutgoingMailboxAvailable:1;/* Bit 1 */
-		bool CommandComplete:1;		/* Bit 2 */
-		bool ExternalBusReset:1;	/* Bit 3 */
-		unsigned char Reserved:3;	/* Bits 4-6 */
-		bool InterruptValid:1;		/* Bit 7 */
+		bool mailin_loaded:1;	/* Bit 0 */
+		bool mailout_avail:1;	/* Bit 1 */
+		bool cmd_complete:1;	/* Bit 2 */
+		bool ext_busreset:1;	/* Bit 3 */
+		unsigned char rsvd:3;	/* Bits 4-6 */
+		bool int_valid:1;	/* Bit 7 */
 	} ir;
 };
 
@@ -344,13 +333,13 @@ union BusLogic_InterruptRegister {
   Define the structure of the read-only Geometry Register.
 */
 
-union BusLogic_GeometryRegister {
-	unsigned char All;
+union blogic_geo_reg {
+	unsigned char all;
 	struct {
-		enum BusLogic_BIOS_DiskGeometryTranslation Drive0Geometry:2;	/* Bits 0-1 */
-		enum BusLogic_BIOS_DiskGeometryTranslation Drive1Geometry:2;	/* Bits 2-3 */
+		enum blogic_bios_diskgeometry d0_geo:2;	/* Bits 0-1 */
+		enum blogic_bios_diskgeometry d1_geo:2;	/* Bits 2-3 */
 		unsigned char:3;	/* Bits 4-6 */
-		bool ExtendedTranslationEnabled:1;	/* Bit 7 */
+		bool ext_trans_enable:1;	/* Bit 7 */
 	} gr;
 };
 
@@ -358,82 +347,82 @@ union BusLogic_GeometryRegister {
   Define the BusLogic SCSI Host Adapter Command Register Operation Codes.
 */
 
-enum BusLogic_OperationCode {
-	BusLogic_TestCommandCompleteInterrupt = 0x00,
-	BusLogic_InitializeMailbox = 0x01,
-	BusLogic_ExecuteMailboxCommand = 0x02,
-	BusLogic_ExecuteBIOSCommand = 0x03,
-	BusLogic_InquireBoardID = 0x04,
-	BusLogic_EnableOutgoingMailboxAvailableInt = 0x05,
-	BusLogic_SetSCSISelectionTimeout = 0x06,
-	BusLogic_SetPreemptTimeOnBus = 0x07,
-	BusLogic_SetTimeOffBus = 0x08,
-	BusLogic_SetBusTransferRate = 0x09,
-	BusLogic_InquireInstalledDevicesID0to7 = 0x0A,
-	BusLogic_InquireConfiguration = 0x0B,
-	BusLogic_EnableTargetMode = 0x0C,
-	BusLogic_InquireSetupInformation = 0x0D,
-	BusLogic_WriteAdapterLocalRAM = 0x1A,
-	BusLogic_ReadAdapterLocalRAM = 0x1B,
-	BusLogic_WriteBusMasterChipFIFO = 0x1C,
-	BusLogic_ReadBusMasterChipFIFO = 0x1D,
-	BusLogic_EchoCommandData = 0x1F,
-	BusLogic_HostAdapterDiagnostic = 0x20,
-	BusLogic_SetAdapterOptions = 0x21,
-	BusLogic_InquireInstalledDevicesID8to15 = 0x23,
-	BusLogic_InquireTargetDevices = 0x24,
-	BusLogic_DisableHostAdapterInterrupt = 0x25,
-	BusLogic_InitializeExtendedMailbox = 0x81,
-	BusLogic_ExecuteSCSICommand = 0x83,
-	BusLogic_InquireFirmwareVersion3rdDigit = 0x84,
-	BusLogic_InquireFirmwareVersionLetter = 0x85,
-	BusLogic_InquirePCIHostAdapterInformation = 0x86,
-	BusLogic_InquireHostAdapterModelNumber = 0x8B,
-	BusLogic_InquireSynchronousPeriod = 0x8C,
-	BusLogic_InquireExtendedSetupInformation = 0x8D,
-	BusLogic_EnableStrictRoundRobinMode = 0x8F,
-	BusLogic_StoreHostAdapterLocalRAM = 0x90,
-	BusLogic_FetchHostAdapterLocalRAM = 0x91,
-	BusLogic_StoreLocalDataInEEPROM = 0x92,
-	BusLogic_UploadAutoSCSICode = 0x94,
-	BusLogic_ModifyIOAddress = 0x95,
-	BusLogic_SetCCBFormat = 0x96,
-	BusLogic_WriteInquiryBuffer = 0x9A,
-	BusLogic_ReadInquiryBuffer = 0x9B,
-	BusLogic_FlashROMUploadDownload = 0xA7,
-	BusLogic_ReadSCAMData = 0xA8,
-	BusLogic_WriteSCAMData = 0xA9
+enum blogic_opcode {
+	BLOGIC_TEST_CMP_COMPLETE = 0x00,
+	BLOGIC_INIT_MBOX = 0x01,
+	BLOGIC_EXEC_MBOX_CMD = 0x02,
+	BLOGIC_EXEC_BIOS_CMD = 0x03,
+	BLOGIC_GET_BOARD_ID = 0x04,
+	BLOGIC_ENABLE_OUTBOX_AVAIL_INT = 0x05,
+	BLOGIC_SET_SELECT_TIMEOUT = 0x06,
+	BLOGIC_SET_PREEMPT_TIME = 0x07,
+	BLOGIC_SET_TIMEOFF_BUS = 0x08,
+	BLOGIC_SET_TXRATE = 0x09,
+	BLOGIC_INQ_DEV0TO7 = 0x0A,
+	BLOGIC_INQ_CONFIG = 0x0B,
+	BLOGIC_TGT_MODE = 0x0C,
+	BLOGIC_INQ_SETUPINFO = 0x0D,
+	BLOGIC_WRITE_LOCALRAM = 0x1A,
+	BLOGIC_READ_LOCALRAM = 0x1B,
+	BLOGIC_WRITE_BUSMASTER_FIFO = 0x1C,
+	BLOGIC_READ_BUSMASTER_FIFO = 0x1D,
+	BLOGIC_ECHO_CMDDATA = 0x1F,
+	BLOGIC_ADAPTER_DIAG = 0x20,
+	BLOGIC_SET_OPTIONS = 0x21,
+	BLOGIC_INQ_DEV8TO15 = 0x23,
+	BLOGIC_INQ_DEV = 0x24,
+	BLOGIC_DISABLE_INT = 0x25,
+	BLOGIC_INIT_EXT_MBOX = 0x81,
+	BLOGIC_EXEC_SCS_CMD = 0x83,
+	BLOGIC_INQ_FWVER_D3 = 0x84,
+	BLOGIC_INQ_FWVER_LETTER = 0x85,
+	BLOGIC_INQ_PCI_INFO = 0x86,
+	BLOGIC_INQ_MODELNO = 0x8B,
+	BLOGIC_INQ_SYNC_PERIOD = 0x8C,
+	BLOGIC_INQ_EXTSETUP = 0x8D,
+	BLOGIC_STRICT_RR = 0x8F,
+	BLOGIC_STORE_LOCALRAM = 0x90,
+	BLOGIC_FETCH_LOCALRAM = 0x91,
+	BLOGIC_STORE_TO_EEPROM = 0x92,
+	BLOGIC_LOAD_AUTOSCSICODE = 0x94,
+	BLOGIC_MOD_IOADDR = 0x95,
+	BLOGIC_SETCCB_FMT = 0x96,
+	BLOGIC_WRITE_INQBUF = 0x9A,
+	BLOGIC_READ_INQBUF = 0x9B,
+	BLOGIC_FLASH_LOAD = 0xA7,
+	BLOGIC_READ_SCAMDATA = 0xA8,
+	BLOGIC_WRITE_SCAMDATA = 0xA9
 };
 
 /*
   Define the Inquire Board ID reply structure.
 */
 
-struct BusLogic_BoardID {
-	unsigned char BoardType;	/* Byte 0 */
-	unsigned char CustomFeatures;	/* Byte 1 */
-	unsigned char FirmwareVersion1stDigit;	/* Byte 2 */
-	unsigned char FirmwareVersion2ndDigit;	/* Byte 3 */
+struct blogic_board_id {
+	unsigned char type;		/* Byte 0 */
+	unsigned char custom_features;	/* Byte 1 */
+	unsigned char fw_ver_digit1;	/* Byte 2 */
+	unsigned char fw_ver_digit2;	/* Byte 3 */
 };
 
 /*
   Define the Inquire Configuration reply structure.
 */
 
-struct BusLogic_Configuration {
+struct blogic_config {
 	unsigned char:5;	/* Byte 0 Bits 0-4 */
-	bool DMA_Channel5:1;	/* Byte 0 Bit 5 */
-	bool DMA_Channel6:1;	/* Byte 0 Bit 6 */
-	bool DMA_Channel7:1;	/* Byte 0 Bit 7 */
-	bool IRQ_Channel9:1;	/* Byte 1 Bit 0 */
-	bool IRQ_Channel10:1;	/* Byte 1 Bit 1 */
-	bool IRQ_Channel11:1;	/* Byte 1 Bit 2 */
-	bool IRQ_Channel12:1;	/* Byte 1 Bit 3 */
+	bool dma_ch5:1;		/* Byte 0 Bit 5 */
+	bool dma_ch6:1;		/* Byte 0 Bit 6 */
+	bool dma_ch7:1;		/* Byte 0 Bit 7 */
+	bool irq_ch9:1;		/* Byte 1 Bit 0 */
+	bool irq_ch10:1;	/* Byte 1 Bit 1 */
+	bool irq_ch11:1;	/* Byte 1 Bit 2 */
+	bool irq_ch12:1;	/* Byte 1 Bit 3 */
 	unsigned char:1;	/* Byte 1 Bit 4 */
-	bool IRQ_Channel14:1;	/* Byte 1 Bit 5 */
-	bool IRQ_Channel15:1;	/* Byte 1 Bit 6 */
+	bool irq_ch14:1;	/* Byte 1 Bit 5 */
+	bool irq_ch15:1;	/* Byte 1 Bit 6 */
 	unsigned char:1;	/* Byte 1 Bit 7 */
-	unsigned char HostAdapterID:4;	/* Byte 2 Bits 0-3 */
+	unsigned char id:4;	/* Byte 2 Bits 0-3 */
 	unsigned char:4;	/* Byte 2 Bits 4-7 */
 };
 
@@ -441,42 +430,42 @@ struct BusLogic_Configuration {
   Define the Inquire Setup Information reply structure.
 */
 
-struct BusLogic_SynchronousValue {
-	unsigned char Offset:4;	/* Bits 0-3 */
-	unsigned char TransferPeriod:3;	/* Bits 4-6 */
-	bool Synchronous:1;	/* Bit 7 */
+struct blogic_syncval {
+	unsigned char offset:4;		/* Bits 0-3 */
+	unsigned char tx_period:3;	/* Bits 4-6 */
+	bool sync:1;			/* Bit 7 */
 };
 
-struct BusLogic_SetupInformation {
-	bool SynchronousInitiationEnabled:1;	/* Byte 0 Bit 0 */
-	bool ParityCheckingEnabled:1;		/* Byte 0 Bit 1 */
-	unsigned char:6;	/* Byte 0 Bits 2-7 */
-	unsigned char BusTransferRate;	/* Byte 1 */
-	unsigned char PreemptTimeOnBus;	/* Byte 2 */
-	unsigned char TimeOffBus;	/* Byte 3 */
-	unsigned char MailboxCount;	/* Byte 4 */
-	unsigned char MailboxAddress[3];	/* Bytes 5-7 */
-	struct BusLogic_SynchronousValue SynchronousValuesID0to7[8];	/* Bytes 8-15 */
-	unsigned char DisconnectPermittedID0to7;	/* Byte 16 */
-	unsigned char Signature;	/* Byte 17 */
-	unsigned char CharacterD;	/* Byte 18 */
-	unsigned char HostBusType;	/* Byte 19 */
-	unsigned char WideTransfersPermittedID0to7;	/* Byte 20 */
-	unsigned char WideTransfersActiveID0to7;	/* Byte 21 */
-	struct BusLogic_SynchronousValue SynchronousValuesID8to15[8];	/* Bytes 22-29 */
-	unsigned char DisconnectPermittedID8to15;	/* Byte 30 */
-	unsigned char:8;	/* Byte 31 */
-	unsigned char WideTransfersPermittedID8to15;	/* Byte 32 */
-	unsigned char WideTransfersActiveID8to15;	/* Byte 33 */
+struct blogic_setup_info {
+	bool sync:1;				/* Byte 0 Bit 0 */
+	bool parity:1;				/* Byte 0 Bit 1 */
+	unsigned char:6;			/* Byte 0 Bits 2-7 */
+	unsigned char tx_rate;			/* Byte 1 */
+	unsigned char preempt_time;		/* Byte 2 */
+	unsigned char timeoff_bus;		/* Byte 3 */
+	unsigned char mbox_count;		/* Byte 4 */
+	unsigned char mbox_addr[3];		/* Bytes 5-7 */
+	struct blogic_syncval sync0to7[8];	/* Bytes 8-15 */
+	unsigned char disconnect_ok0to7;	/* Byte 16 */
+	unsigned char sig;			/* Byte 17 */
+	unsigned char char_d;			/* Byte 18 */
+	unsigned char bus_type;			/* Byte 19 */
+	unsigned char wide_tx_ok0to7;		/* Byte 20 */
+	unsigned char wide_tx_active0to7;	/* Byte 21 */
+	struct blogic_syncval sync8to15[8];	/* Bytes 22-29 */
+	unsigned char disconnect_ok8to15;	/* Byte 30 */
+	unsigned char:8;			/* Byte 31 */
+	unsigned char wide_tx_ok8to15;		/* Byte 32 */
+	unsigned char wide_tx_active8to15;	/* Byte 33 */
 };
 
 /*
   Define the Initialize Extended Mailbox request structure.
 */
 
-struct BusLogic_ExtendedMailboxRequest {
-	unsigned char MailboxCount;	/* Byte 0 */
-	u32 BaseMailboxAddress;	/* Bytes 1-4 */
+struct blogic_extmbox_req {
+	unsigned char mbox_count;	/* Byte 0 */
+	u32 base_mbox_addr;		/* Bytes 1-4 */
 } PACKED;
 
 
@@ -486,63 +475,63 @@ struct BusLogic_ExtendedMailboxRequest {
   the Modify I/O Address command.
 */
 
-enum BusLogic_ISACompatibleIOPort {
-	BusLogic_IO_330 = 0,
-	BusLogic_IO_334 = 1,
-	BusLogic_IO_230 = 2,
-	BusLogic_IO_234 = 3,
-	BusLogic_IO_130 = 4,
-	BusLogic_IO_134 = 5,
-	BusLogic_IO_Disable = 6,
-	BusLogic_IO_Disable2 = 7
+enum blogic_isa_ioport {
+	BLOGIC_IO_330 = 0,
+	BLOGIC_IO_334 = 1,
+	BLOGIC_IO_230 = 2,
+	BLOGIC_IO_234 = 3,
+	BLOGIC_IO_130 = 4,
+	BLOGIC_IO_134 = 5,
+	BLOGIC_IO_DISABLE = 6,
+	BLOGIC_IO_DISABLE2 = 7
 } PACKED;
 
-struct BusLogic_PCIHostAdapterInformation {
-	enum BusLogic_ISACompatibleIOPort ISACompatibleIOPort;	/* Byte 0 */
-	unsigned char PCIAssignedIRQChannel;	/* Byte 1 */
-	bool LowByteTerminated:1;	/* Byte 2 Bit 0 */
-	bool HighByteTerminated:1;	/* Byte 2 Bit 1 */
-	unsigned char:2;	/* Byte 2 Bits 2-3 */
-	bool JP1:1;		/* Byte 2 Bit 4 */
-	bool JP2:1;		/* Byte 2 Bit 5 */
-	bool JP3:1;		/* Byte 2 Bit 6 */
-	bool GenericInfoValid:1;/* Byte 2 Bit 7 */
-	unsigned char:8;	/* Byte 3 */
+struct blogic_adapter_info {
+	enum blogic_isa_ioport isa_port;	/* Byte 0 */
+	unsigned char irq_ch;		/* Byte 1 */
+	bool low_term:1;		/* Byte 2 Bit 0 */
+	bool high_term:1;		/* Byte 2 Bit 1 */
+	unsigned char:2;		/* Byte 2 Bits 2-3 */
+	bool JP1:1;			/* Byte 2 Bit 4 */
+	bool JP2:1;			/* Byte 2 Bit 5 */
+	bool JP3:1;			/* Byte 2 Bit 6 */
+	bool genericinfo_valid:1;	/* Byte 2 Bit 7 */
+	unsigned char:8;		/* Byte 3 */
 };
 
 /*
   Define the Inquire Extended Setup Information reply structure.
 */
 
-struct BusLogic_ExtendedSetupInformation {
-	unsigned char BusType;	/* Byte 0 */
-	unsigned char BIOS_Address;	/* Byte 1 */
-	unsigned short ScatterGatherLimit;	/* Bytes 2-3 */
-	unsigned char MailboxCount;	/* Byte 4 */
-	u32 BaseMailboxAddress;	/* Bytes 5-8 */
+struct blogic_ext_setup {
+	unsigned char bus_type;		/* Byte 0 */
+	unsigned char bios_addr;	/* Byte 1 */
+	unsigned short sg_limit;	/* Bytes 2-3 */
+	unsigned char mbox_count;	/* Byte 4 */
+	u32 base_mbox_addr;		/* Bytes 5-8 */
 	struct {
 		unsigned char:2;	/* Byte 9 Bits 0-1 */
-		bool FastOnEISA:1;	/* Byte 9 Bit 2 */
+		bool fast_on_eisa:1;	/* Byte 9 Bit 2 */
 		unsigned char:3;	/* Byte 9 Bits 3-5 */
-		bool LevelSensitiveInterrupt:1;	/* Byte 9 Bit 6 */
+		bool level_int:1;	/* Byte 9 Bit 6 */
 		unsigned char:1;	/* Byte 9 Bit 7 */
-	} Misc;
-	unsigned char FirmwareRevision[3];	/* Bytes 10-12 */
-	bool HostWideSCSI:1;		/* Byte 13 Bit 0 */
-	bool HostDifferentialSCSI:1;	/* Byte 13 Bit 1 */
-	bool HostSupportsSCAM:1;	/* Byte 13 Bit 2 */
-	bool HostUltraSCSI:1;		/* Byte 13 Bit 3 */
-	bool HostSmartTermination:1;	/* Byte 13 Bit 4 */
-	unsigned char:3;	/* Byte 13 Bits 5-7 */
+	} misc;
+	unsigned char fw_rev[3];	/* Bytes 10-12 */
+	bool wide:1;			/* Byte 13 Bit 0 */
+	bool differential:1;		/* Byte 13 Bit 1 */
+	bool scam:1;			/* Byte 13 Bit 2 */
+	bool ultra:1;			/* Byte 13 Bit 3 */
+	bool smart_term:1;		/* Byte 13 Bit 4 */
+	unsigned char:3;		/* Byte 13 Bits 5-7 */
 } PACKED;
 
 /*
   Define the Enable Strict Round Robin Mode request type.
 */
 
-enum BusLogic_RoundRobinModeRequest {
-	BusLogic_AggressiveRoundRobinMode = 0,
-	BusLogic_StrictRoundRobinMode = 1
+enum blogic_rr_req {
+	BLOGIC_AGGRESSIVE_RR = 0,
+	BLOGIC_STRICT_RR_MODE = 1
 } PACKED;
 
 
@@ -550,95 +539,95 @@ enum BusLogic_RoundRobinModeRequest {
   Define the Fetch Host Adapter Local RAM request type.
 */
 
-#define BusLogic_BIOS_BaseOffset		0
-#define BusLogic_AutoSCSI_BaseOffset		64
+#define BLOGIC_BIOS_BASE		0
+#define BLOGIC_AUTOSCSI_BASE		64
 
-struct BusLogic_FetchHostAdapterLocalRAMRequest {
-	unsigned char ByteOffset;	/* Byte 0 */
-	unsigned char ByteCount;	/* Byte 1 */
+struct blogic_fetch_localram {
+	unsigned char offset;	/* Byte 0 */
+	unsigned char count;	/* Byte 1 */
 };
 
 /*
   Define the Host Adapter Local RAM AutoSCSI structure.
 */
 
-struct BusLogic_AutoSCSIData {
-	unsigned char InternalFactorySignature[2];	/* Bytes 0-1 */
-	unsigned char InformationByteCount;	/* Byte 2 */
-	unsigned char HostAdapterType[6];	/* Bytes 3-8 */
-	unsigned char:8;	/* Byte 9 */
-	bool FloppyEnabled:1;		/* Byte 10 Bit 0 */
-	bool FloppySecondary:1;		/* Byte 10 Bit 1 */
-	bool LevelSensitiveInterrupt:1;	/* Byte 10 Bit 2 */
-	unsigned char:2;	/* Byte 10 Bits 3-4 */
-	unsigned char SystemRAMAreaForBIOS:3;	/* Byte 10 Bits 5-7 */
-	unsigned char DMA_Channel:7;	/* Byte 11 Bits 0-6 */
-	bool DMA_AutoConfiguration:1;	/* Byte 11 Bit 7 */
-	unsigned char IRQ_Channel:7;	/* Byte 12 Bits 0-6 */
-	bool IRQ_AutoConfiguration:1;	/* Byte 12 Bit 7 */
-	unsigned char DMA_TransferRate;	/* Byte 13 */
-	unsigned char SCSI_ID;	/* Byte 14 */
-	bool LowByteTerminated:1;	/* Byte 15 Bit 0 */
-	bool ParityCheckingEnabled:1;	/* Byte 15 Bit 1 */
-	bool HighByteTerminated:1;	/* Byte 15 Bit 2 */
-	bool NoisyCablingEnvironment:1;	/* Byte 15 Bit 3 */
-	bool FastSynchronousNegotiation:1;	/* Byte 15 Bit 4 */
-	bool BusResetEnabled:1;		/* Byte 15 Bit 5 */
-	 bool:1;		/* Byte 15 Bit 6 */
-	bool ActiveNegationEnabled:1;	/* Byte 15 Bit 7 */
-	unsigned char BusOnDelay;	/* Byte 16 */
-	unsigned char BusOffDelay;	/* Byte 17 */
-	bool HostAdapterBIOSEnabled:1;		/* Byte 18 Bit 0 */
-	bool BIOSRedirectionOfINT19Enabled:1;	/* Byte 18 Bit 1 */
-	bool ExtendedTranslationEnabled:1;	/* Byte 18 Bit 2 */
-	bool MapRemovableAsFixedEnabled:1;	/* Byte 18 Bit 3 */
-	 bool:1;		/* Byte 18 Bit 4 */
-	bool BIOSSupportsMoreThan2DrivesEnabled:1;	/* Byte 18 Bit 5 */
-	bool BIOSInterruptModeEnabled:1;	/* Byte 18 Bit 6 */
-	bool FlopticalSupportEnabled:1;		/* Byte 19 Bit 7 */
-	unsigned short DeviceEnabled;	/* Bytes 19-20 */
-	unsigned short WidePermitted;	/* Bytes 21-22 */
-	unsigned short FastPermitted;	/* Bytes 23-24 */
-	unsigned short SynchronousPermitted;	/* Bytes 25-26 */
-	unsigned short DisconnectPermitted;	/* Bytes 27-28 */
-	unsigned short SendStartUnitCommand;	/* Bytes 29-30 */
-	unsigned short IgnoreInBIOSScan;	/* Bytes 31-32 */
-	unsigned char PCIInterruptPin:2;	/* Byte 33 Bits 0-1 */
-	unsigned char HostAdapterIOPortAddress:2;	/* Byte 33 Bits 2-3 */
-	bool StrictRoundRobinModeEnabled:1;	/* Byte 33 Bit 4 */
-	bool VESABusSpeedGreaterThan33MHz:1;	/* Byte 33 Bit 5 */
-	bool VESABurstWriteEnabled:1;	/* Byte 33 Bit 6 */
-	bool VESABurstReadEnabled:1;	/* Byte 33 Bit 7 */
-	unsigned short UltraPermitted;	/* Bytes 34-35 */
-	unsigned int:32;	/* Bytes 36-39 */
-	unsigned char:8;	/* Byte 40 */
-	unsigned char AutoSCSIMaximumLUN;	/* Byte 41 */
-	 bool:1;		/* Byte 42 Bit 0 */
-	bool SCAM_Dominant:1;	/* Byte 42 Bit 1 */
-	bool SCAM_Enabled:1;	/* Byte 42 Bit 2 */
-	bool SCAM_Level2:1;	/* Byte 42 Bit 3 */
-	unsigned char:4;	/* Byte 42 Bits 4-7 */
-	bool INT13ExtensionEnabled:1;	/* Byte 43 Bit 0 */
-	 bool:1;		/* Byte 43 Bit 1 */
-	bool CDROMBootEnabled:1;	/* Byte 43 Bit 2 */
-	unsigned char:5;	/* Byte 43 Bits 3-7 */
-	unsigned char BootTargetID:4;	/* Byte 44 Bits 0-3 */
-	unsigned char BootChannel:4;	/* Byte 44 Bits 4-7 */
-	unsigned char ForceBusDeviceScanningOrder:1;	/* Byte 45 Bit 0 */
-	unsigned char:7;	/* Byte 45 Bits 1-7 */
-	unsigned short NonTaggedToAlternateLUNPermitted;	/* Bytes 46-47 */
-	unsigned short RenegotiateSyncAfterCheckCondition;	/* Bytes 48-49 */
-	unsigned char Reserved[10];	/* Bytes 50-59 */
-	unsigned char ManufacturingDiagnostic[2];	/* Bytes 60-61 */
-	unsigned short Checksum;	/* Bytes 62-63 */
+struct blogic_autoscsi {
+	unsigned char factory_sig[2];		/* Bytes 0-1 */
+	unsigned char info_bytes;		/* Byte 2 */
+	unsigned char adapter_type[6];		/* Bytes 3-8 */
+	unsigned char:8;			/* Byte 9 */
+	bool floppy:1;				/* Byte 10 Bit 0 */
+	bool floppy_sec:1;			/* Byte 10 Bit 1 */
+	bool level_int:1;			/* Byte 10 Bit 2 */
+	unsigned char:2;			/* Byte 10 Bits 3-4 */
+	unsigned char systemram_bios:3;		/* Byte 10 Bits 5-7 */
+	unsigned char dma_ch:7;			/* Byte 11 Bits 0-6 */
+	bool dma_autoconf:1;			/* Byte 11 Bit 7 */
+	unsigned char irq_ch:7;			/* Byte 12 Bits 0-6 */
+	bool irq_autoconf:1;			/* Byte 12 Bit 7 */
+	unsigned char dma_tx_rate;		/* Byte 13 */
+	unsigned char scsi_id;			/* Byte 14 */
+	bool low_term:1;			/* Byte 15 Bit 0 */
+	bool parity:1;				/* Byte 15 Bit 1 */
+	bool high_term:1;			/* Byte 15 Bit 2 */
+	bool noisy_cable:1;			/* Byte 15 Bit 3 */
+	bool fast_sync_neg:1;			/* Byte 15 Bit 4 */
+	bool reset_enabled:1;			/* Byte 15 Bit 5 */
+	bool:1;					/* Byte 15 Bit 6 */
+	bool active_negation:1;			/* Byte 15 Bit 7 */
+	unsigned char bus_on_delay;		/* Byte 16 */
+	unsigned char bus_off_delay;		/* Byte 17 */
+	bool bios_enabled:1;			/* Byte 18 Bit 0 */
+	bool int19_redir_enabled:1;		/* Byte 18 Bit 1 */
+	bool ext_trans_enable:1;		/* Byte 18 Bit 2 */
+	bool removable_as_fixed:1;		/* Byte 18 Bit 3 */
+	bool:1;					/* Byte 18 Bit 4 */
+	bool morethan2_drives:1;		/* Byte 18 Bit 5 */
+	bool bios_int:1;			/* Byte 18 Bit 6 */
+	bool floptical:1;			/* Byte 19 Bit 7 */
+	unsigned short dev_enabled;		/* Bytes 19-20 */
+	unsigned short wide_ok;			/* Bytes 21-22 */
+	unsigned short fast_ok;			/* Bytes 23-24 */
+	unsigned short sync_ok;			/* Bytes 25-26 */
+	unsigned short discon_ok;		/* Bytes 27-28 */
+	unsigned short send_start_unit;		/* Bytes 29-30 */
+	unsigned short ignore_bios_scan;	/* Bytes 31-32 */
+	unsigned char pci_int_pin:2;		/* Byte 33 Bits 0-1 */
+	unsigned char adapter_ioport:2;		/* Byte 33 Bits 2-3 */
+	bool strict_rr_enabled:1;		/* Byte 33 Bit 4 */
+	bool vesabus_33mhzplus:1;		/* Byte 33 Bit 5 */
+	bool vesa_burst_write:1;		/* Byte 33 Bit 6 */
+	bool vesa_burst_read:1;			/* Byte 33 Bit 7 */
+	unsigned short ultra_ok;		/* Bytes 34-35 */
+	unsigned int:32;			/* Bytes 36-39 */
+	unsigned char:8;			/* Byte 40 */
+	unsigned char autoscsi_maxlun;		/* Byte 41 */
+	bool:1;					/* Byte 42 Bit 0 */
+	bool scam_dominant:1;			/* Byte 42 Bit 1 */
+	bool scam_enabled:1;			/* Byte 42 Bit 2 */
+	bool scam_lev2:1;			/* Byte 42 Bit 3 */
+	unsigned char:4;			/* Byte 42 Bits 4-7 */
+	bool int13_exten:1;			/* Byte 43 Bit 0 */
+	bool:1;					/* Byte 43 Bit 1 */
+	bool cd_boot:1;				/* Byte 43 Bit 2 */
+	unsigned char:5;			/* Byte 43 Bits 3-7 */
+	unsigned char boot_id:4;		/* Byte 44 Bits 0-3 */
+	unsigned char boot_ch:4;		/* Byte 44 Bits 4-7 */
+	unsigned char force_scan_order:1;	/* Byte 45 Bit 0 */
+	unsigned char:7;			/* Byte 45 Bits 1-7 */
+	unsigned short nontagged_to_alt_ok;	/* Bytes 46-47 */
+	unsigned short reneg_sync_on_check;	/* Bytes 48-49 */
+	unsigned char rsvd[10];			/* Bytes 50-59 */
+	unsigned char manuf_diag[2];		/* Bytes 60-61 */
+	unsigned short cksum;			/* Bytes 62-63 */
 } PACKED;
 
 /*
   Define the Host Adapter Local RAM Auto SCSI Byte 45 structure.
 */
 
-struct BusLogic_AutoSCSIByte45 {
-	unsigned char ForceBusDeviceScanningOrder:1;	/* Bit 0 */
+struct blogic_autoscsi_byte45 {
+	unsigned char force_scan_order:1;	/* Bit 0 */
 	unsigned char:7;	/* Bits 1-7 */
 };
 
@@ -646,13 +635,13 @@ struct BusLogic_AutoSCSIByte45 {
   Define the Host Adapter Local RAM BIOS Drive Map Byte structure.
 */
 
-#define BusLogic_BIOS_DriveMapOffset		17
+#define BLOGIC_BIOS_DRVMAP		17
 
-struct BusLogic_BIOSDriveMapByte {
-	unsigned char TargetIDBit3:1;	/* Bit 0 */
-	unsigned char:2;	/* Bits 1-2 */
-	enum BusLogic_BIOS_DiskGeometryTranslation DiskGeometry:2;	/* Bits 3-4 */
-	unsigned char TargetID:3;	/* Bits 5-7 */
+struct blogic_bios_drvmap {
+	unsigned char tgt_idbit3:1;			/* Bit 0 */
+	unsigned char:2;				/* Bits 1-2 */
+	enum blogic_bios_diskgeometry diskgeom:2;	/* Bits 3-4 */
+	unsigned char tgt_id:3;				/* Bits 5-7 */
 };
 
 /*
@@ -660,19 +649,19 @@ struct BusLogic_BIOSDriveMapByte {
   necessary to support more than 8 Logical Units per Target Device.
 */
 
-enum BusLogic_SetCCBFormatRequest {
-	BusLogic_LegacyLUNFormatCCB = 0,
-	BusLogic_ExtendedLUNFormatCCB = 1
+enum blogic_setccb_fmt {
+	BLOGIC_LEGACY_LUN_CCB = 0,
+	BLOGIC_EXT_LUN_CCB = 1
 } PACKED;
 
 /*
   Define the Outgoing Mailbox Action Codes.
 */
 
-enum BusLogic_ActionCode {
-	BusLogic_OutgoingMailboxFree = 0x00,
-	BusLogic_MailboxStartCommand = 0x01,
-	BusLogic_MailboxAbortCommand = 0x02
+enum blogic_action {
+	BLOGIC_OUTBOX_FREE = 0x00,
+	BLOGIC_MBOX_START = 0x01,
+	BLOGIC_MBOX_ABORT = 0x02
 } PACKED;
 
 
@@ -682,26 +671,26 @@ enum BusLogic_ActionCode {
   completion codes are stored in the CCB; it only uses codes 1, 2, 4, and 5.
 */
 
-enum BusLogic_CompletionCode {
-	BusLogic_IncomingMailboxFree = 0x00,
-	BusLogic_CommandCompletedWithoutError = 0x01,
-	BusLogic_CommandAbortedAtHostRequest = 0x02,
-	BusLogic_AbortedCommandNotFound = 0x03,
-	BusLogic_CommandCompletedWithError = 0x04,
-	BusLogic_InvalidCCB = 0x05
+enum blogic_cmplt_code {
+	BLOGIC_INBOX_FREE = 0x00,
+	BLOGIC_CMD_COMPLETE_GOOD = 0x01,
+	BLOGIC_CMD_ABORT_BY_HOST = 0x02,
+	BLOGIC_CMD_NOTFOUND = 0x03,
+	BLOGIC_CMD_COMPLETE_ERROR = 0x04,
+	BLOGIC_INVALID_CCB = 0x05
 } PACKED;
 
 /*
   Define the Command Control Block (CCB) Opcodes.
 */
 
-enum BusLogic_CCB_Opcode {
-	BusLogic_InitiatorCCB = 0x00,
-	BusLogic_TargetCCB = 0x01,
-	BusLogic_InitiatorCCB_ScatterGather = 0x02,
-	BusLogic_InitiatorCCB_ResidualDataLength = 0x03,
-	BusLogic_InitiatorCCB_ScatterGatherResidual = 0x04,
-	BusLogic_BusDeviceReset = 0x81
+enum blogic_ccb_opcode {
+	BLOGIC_INITIATOR_CCB = 0x00,
+	BLOGIC_TGT_CCB = 0x01,
+	BLOGIC_INITIATOR_CCB_SG = 0x02,
+	BLOGIC_INITIATOR_CCBB_RESIDUAL = 0x03,
+	BLOGIC_INITIATOR_CCB_SG_RESIDUAL = 0x04,
+	BLOGIC_BDR = 0x81
 } PACKED;
 
 
@@ -709,11 +698,11 @@ enum BusLogic_CCB_Opcode {
   Define the CCB Data Direction Codes.
 */
 
-enum BusLogic_DataDirection {
-	BusLogic_UncheckedDataTransfer = 0,
-	BusLogic_DataInLengthChecked = 1,
-	BusLogic_DataOutLengthChecked = 2,
-	BusLogic_NoDataTransfer = 3
+enum blogic_datadir {
+	BLOGIC_UNCHECKED_TX = 0,
+	BLOGIC_DATAIN_CHECKED = 1,
+	BLOGIC_DATAOUT_CHECKED = 2,
+	BLOGIC_NOTX = 3
 };
 
 
@@ -722,32 +711,32 @@ enum BusLogic_DataDirection {
   return status code 0x0C; it uses 0x12 for both overruns and underruns.
 */
 
-enum BusLogic_HostAdapterStatus {
-	BusLogic_CommandCompletedNormally = 0x00,
-	BusLogic_LinkedCommandCompleted = 0x0A,
-	BusLogic_LinkedCommandCompletedWithFlag = 0x0B,
-	BusLogic_DataUnderRun = 0x0C,
-	BusLogic_SCSISelectionTimeout = 0x11,
-	BusLogic_DataOverRun = 0x12,
-	BusLogic_UnexpectedBusFree = 0x13,
-	BusLogic_InvalidBusPhaseRequested = 0x14,
-	BusLogic_InvalidOutgoingMailboxActionCode = 0x15,
-	BusLogic_InvalidCommandOperationCode = 0x16,
-	BusLogic_LinkedCCBhasInvalidLUN = 0x17,
-	BusLogic_InvalidCommandParameter = 0x1A,
-	BusLogic_AutoRequestSenseFailed = 0x1B,
-	BusLogic_TaggedQueuingMessageRejected = 0x1C,
-	BusLogic_UnsupportedMessageReceived = 0x1D,
-	BusLogic_HostAdapterHardwareFailed = 0x20,
-	BusLogic_TargetFailedResponseToATN = 0x21,
-	BusLogic_HostAdapterAssertedRST = 0x22,
-	BusLogic_OtherDeviceAssertedRST = 0x23,
-	BusLogic_TargetDeviceReconnectedImproperly = 0x24,
-	BusLogic_HostAdapterAssertedBusDeviceReset = 0x25,
-	BusLogic_AbortQueueGenerated = 0x26,
-	BusLogic_HostAdapterSoftwareError = 0x27,
-	BusLogic_HostAdapterHardwareTimeoutError = 0x30,
-	BusLogic_SCSIParityErrorDetected = 0x34
+enum blogic_adapter_status {
+	BLOGIC_CMD_CMPLT_NORMAL = 0x00,
+	BLOGIC_LINK_CMD_CMPLT = 0x0A,
+	BLOGIC_LINK_CMD_CMPLT_FLAG = 0x0B,
+	BLOGIC_DATA_UNDERRUN = 0x0C,
+	BLOGIC_SELECT_TIMEOUT = 0x11,
+	BLOGIC_DATA_OVERRUN = 0x12,
+	BLOGIC_NOEXPECT_BUSFREE = 0x13,
+	BLOGIC_INVALID_BUSPHASE = 0x14,
+	BLOGIC_INVALID_OUTBOX_CODE = 0x15,
+	BLOGIC_INVALID_CMD_CODE = 0x16,
+	BLOGIC_LINKCCB_BADLUN = 0x17,
+	BLOGIC_BAD_CMD_PARAM = 0x1A,
+	BLOGIC_AUTOREQSENSE_FAIL = 0x1B,
+	BLOGIC_TAGQUEUE_REJECT = 0x1C,
+	BLOGIC_BAD_MSG_RCVD = 0x1D,
+	BLOGIC_HW_FAIL = 0x20,
+	BLOGIC_NORESPONSE_TO_ATN = 0x21,
+	BLOGIC_HW_RESET = 0x22,
+	BLOGIC_RST_FROM_OTHERDEV = 0x23,
+	BLOGIC_BAD_RECONNECT = 0x24,
+	BLOGIC_HW_BDR = 0x25,
+	BLOGIC_ABRT_QUEUE = 0x26,
+	BLOGIC_ADAPTER_SW_ERROR = 0x27,
+	BLOGIC_HW_TIMEOUT = 0x30,
+	BLOGIC_PARITY_ERR = 0x34
 } PACKED;
 
 
@@ -755,30 +744,28 @@ enum BusLogic_HostAdapterStatus {
   Define the SCSI Target Device Status Codes.
 */
 
-enum BusLogic_TargetDeviceStatus {
-	BusLogic_OperationGood = 0x00,
-	BusLogic_CheckCondition = 0x02,
-	BusLogic_DeviceBusy = 0x08
+enum blogic_tgt_status {
+	BLOGIC_OP_GOOD = 0x00,
+	BLOGIC_CHECKCONDITION = 0x02,
+	BLOGIC_DEVBUSY = 0x08
 } PACKED;
 
 /*
   Define the Queue Tag Codes.
 */
 
-enum BusLogic_QueueTag {
-	BusLogic_SimpleQueueTag = 0,
-	BusLogic_HeadOfQueueTag = 1,
-	BusLogic_OrderedQueueTag = 2,
-	BusLogic_ReservedQT = 3
+enum blogic_queuetag {
+	BLOGIC_SIMPLETAG = 0,
+	BLOGIC_HEADTAG = 1,
+	BLOGIC_ORDEREDTAG = 2,
+	BLOGIC_RSVDTAG = 3
 };
 
 /*
   Define the SCSI Command Descriptor Block (CDB).
 */
 
-#define BusLogic_CDB_MaxLength			12
-
-typedef unsigned char SCSI_CDB_T[BusLogic_CDB_MaxLength];
+#define BLOGIC_CDB_MAXLEN			12
 
 
 /*
@@ -786,20 +773,20 @@ typedef unsigned char SCSI_CDB_T[BusLogic_CDB_MaxLength];
   Firmware Interface and the FlashPoint SCCB Manager.
 */
 
-struct BusLogic_ScatterGatherSegment {
-	u32 SegmentByteCount;	/* Bytes 0-3 */
-	u32 SegmentDataPointer;	/* Bytes 4-7 */
+struct blogic_sg_seg {
+	u32 segbytes;	/* Bytes 0-3 */
+	u32 segdata;	/* Bytes 4-7 */
 };
 
 /*
   Define the Driver CCB Status Codes.
 */
 
-enum BusLogic_CCB_Status {
-	BusLogic_CCB_Free = 0,
-	BusLogic_CCB_Active = 1,
-	BusLogic_CCB_Completed = 2,
-	BusLogic_CCB_Reset = 3
+enum blogic_ccb_status {
+	BLOGIC_CCB_FREE = 0,
+	BLOGIC_CCB_ACTIVE = 1,
+	BLOGIC_CCB_COMPLETE = 2,
+	BLOGIC_CCB_RESET = 3
 } PACKED;
 
 
@@ -822,79 +809,78 @@ enum BusLogic_CCB_Status {
   32 Logical Units per Target Device.
 */
 
-struct BusLogic_CCB {
+struct blogic_ccb {
 	/*
 	   MultiMaster Firmware and FlashPoint SCCB Manager Common Portion.
 	 */
-	enum BusLogic_CCB_Opcode Opcode;	/* Byte 0 */
-	unsigned char:3;	/* Byte 1 Bits 0-2 */
-	enum BusLogic_DataDirection DataDirection:2;	/* Byte 1 Bits 3-4 */
-	bool TagEnable:1;	/* Byte 1 Bit 5 */
-	enum BusLogic_QueueTag QueueTag:2;	/* Byte 1 Bits 6-7 */
-	unsigned char CDB_Length;	/* Byte 2 */
-	unsigned char SenseDataLength;	/* Byte 3 */
-	u32 DataLength;		/* Bytes 4-7 */
-	u32 DataPointer;	/* Bytes 8-11 */
-	unsigned char:8;	/* Byte 12 */
-	unsigned char:8;	/* Byte 13 */
-	enum BusLogic_HostAdapterStatus HostAdapterStatus;	/* Byte 14 */
-	enum BusLogic_TargetDeviceStatus TargetDeviceStatus;	/* Byte 15 */
-	unsigned char TargetID;	/* Byte 16 */
-	unsigned char LogicalUnit:5;	/* Byte 17 Bits 0-4 */
-	bool LegacyTagEnable:1;	/* Byte 17 Bit 5 */
-	enum BusLogic_QueueTag LegacyQueueTag:2;	/* Byte 17 Bits 6-7 */
-	SCSI_CDB_T CDB;		/* Bytes 18-29 */
-	unsigned char:8;	/* Byte 30 */
-	unsigned char:8;	/* Byte 31 */
-	unsigned int:32;	/* Bytes 32-35 */
-	u32 SenseDataPointer;	/* Bytes 36-39 */
+	enum blogic_ccb_opcode opcode;			/* Byte 0 */
+	unsigned char:3;				/* Byte 1 Bits 0-2 */
+	enum blogic_datadir datadir:2;			/* Byte 1 Bits 3-4 */
+	bool tag_enable:1;				/* Byte 1 Bit 5 */
+	enum blogic_queuetag queuetag:2;		/* Byte 1 Bits 6-7 */
+	unsigned char cdblen;				/* Byte 2 */
+	unsigned char sense_datalen;			/* Byte 3 */
+	u32 datalen;					/* Bytes 4-7 */
+	u32 data;					/* Bytes 8-11 */
+	unsigned char:8;				/* Byte 12 */
+	unsigned char:8;				/* Byte 13 */
+	enum blogic_adapter_status adapter_status;	/* Byte 14 */
+	enum blogic_tgt_status tgt_status;		/* Byte 15 */
+	unsigned char tgt_id;				/* Byte 16 */
+	unsigned char lun:5;				/* Byte 17 Bits 0-4 */
+	bool legacytag_enable:1;			/* Byte 17 Bit 5 */
+	enum blogic_queuetag legacy_tag:2;		/* Byte 17 Bits 6-7 */
+	unsigned char cdb[BLOGIC_CDB_MAXLEN];		/* Bytes 18-29 */
+	unsigned char:8;				/* Byte 30 */
+	unsigned char:8;				/* Byte 31 */
+	unsigned int:32;				/* Bytes 32-35 */
+	u32 sensedata;					/* Bytes 36-39 */
 	/*
 	   FlashPoint SCCB Manager Defined Portion.
 	 */
-	void (*CallbackFunction) (struct BusLogic_CCB *);	/* Bytes 40-43 */
-	u32 BaseAddress;	/* Bytes 44-47 */
-	enum BusLogic_CompletionCode CompletionCode;	/* Byte 48 */
+	void (*callback) (struct blogic_ccb *);		/* Bytes 40-43 */
+	u32 base_addr;					/* Bytes 44-47 */
+	enum blogic_cmplt_code comp_code;		/* Byte 48 */
 #ifdef CONFIG_SCSI_FLASHPOINT
-	unsigned char:8;	/* Byte 49 */
-	unsigned short OS_Flags;	/* Bytes 50-51 */
-	unsigned char Private[48];	/* Bytes 52-99 */
+	unsigned char:8;				/* Byte 49 */
+	unsigned short os_flags;			/* Bytes 50-51 */
+	unsigned char private[48];			/* Bytes 52-99 */
 #endif
 	/*
 	   BusLogic Linux Driver Defined Portion.
 	 */
-	dma_addr_t AllocationGroupHead;
-	unsigned int AllocationGroupSize;
-	u32 DMA_Handle;
-	enum BusLogic_CCB_Status Status;
-	unsigned long SerialNumber;
-	struct scsi_cmnd *Command;
-	struct BusLogic_HostAdapter *HostAdapter;
-	struct BusLogic_CCB *Next;
-	struct BusLogic_CCB *NextAll;
-	struct BusLogic_ScatterGatherSegment
-	 ScatterGatherList[BusLogic_ScatterGatherLimit];
+	dma_addr_t allocgrp_head;
+	unsigned int allocgrp_size;
+	u32 dma_handle;
+	enum blogic_ccb_status status;
+	unsigned long serial;
+	struct scsi_cmnd *command;
+	struct blogic_adapter *adapter;
+	struct blogic_ccb *next;
+	struct blogic_ccb *next_all;
+	struct blogic_sg_seg sglist[BLOGIC_SG_LIMIT];
 };
 
 /*
   Define the 32 Bit Mode Outgoing Mailbox structure.
 */
 
-struct BusLogic_OutgoingMailbox {
-	u32 CCB;		/* Bytes 0-3 */
-	unsigned int:24;	/* Bytes 4-6 */
-	enum BusLogic_ActionCode ActionCode;	/* Byte 7 */
+struct blogic_outbox {
+	u32 ccb;			/* Bytes 0-3 */
+	unsigned int:24;		/* Bytes 4-6 */
+	enum blogic_action action;	/* Byte 7 */
 };
 
 /*
   Define the 32 Bit Mode Incoming Mailbox structure.
 */
 
-struct BusLogic_IncomingMailbox {
-	u32 CCB;		/* Bytes 0-3 */
-	enum BusLogic_HostAdapterStatus HostAdapterStatus;	/* Byte 4 */
-	enum BusLogic_TargetDeviceStatus TargetDeviceStatus;	/* Byte 5 */
+struct blogic_inbox {
+	u32 ccb;		/* Bytes 0-3 */
+	enum blogic_adapter_status adapter_status;	/* Byte 4 */
+	enum blogic_tgt_status tgt_status;	/* Byte 5 */
 	unsigned char:8;	/* Byte 6 */
-	enum BusLogic_CompletionCode CompletionCode;	/* Byte 7 */
+	enum blogic_cmplt_code comp_code;	/* Byte 7 */
 };
 
 
@@ -902,64 +888,60 @@ struct BusLogic_IncomingMailbox {
   Define the BusLogic Driver Options structure.
 */
 
-struct BusLogic_DriverOptions {
-	unsigned short TaggedQueuingPermitted;
-	unsigned short TaggedQueuingPermittedMask;
-	unsigned short BusSettleTime;
-	struct BusLogic_LocalOptions LocalOptions;
-	unsigned char CommonQueueDepth;
-	unsigned char QueueDepth[BusLogic_MaxTargetDevices];
+struct blogic_drvr_options {
+	unsigned short tagq_ok;
+	unsigned short tagq_ok_mask;
+	unsigned short bus_settle_time;
+	unsigned short stop_tgt_inquiry;
+	unsigned char common_qdepth;
+	unsigned char qdepth[BLOGIC_MAXDEV];
 };
 
 /*
   Define the Host Adapter Target Flags structure.
 */
 
-struct BusLogic_TargetFlags {
-	bool TargetExists:1;
-	bool TaggedQueuingSupported:1;
-	bool WideTransfersSupported:1;
-	bool TaggedQueuingActive:1;
-	bool WideTransfersActive:1;
-	bool CommandSuccessfulFlag:1;
-	bool TargetInfoReported:1;
+struct blogic_tgt_flags {
+	bool tgt_exists:1;
+	bool tagq_ok:1;
+	bool wide_ok:1;
+	bool tagq_active:1;
+	bool wide_active:1;
+	bool cmd_good:1;
+	bool tgt_info_in:1;
 };
 
 /*
   Define the Host Adapter Target Statistics structure.
 */
 
-#define BusLogic_SizeBuckets			10
-
-typedef unsigned int BusLogic_CommandSizeBuckets_T[BusLogic_SizeBuckets];
-
-struct BusLogic_TargetStatistics {
-	unsigned int CommandsAttempted;
-	unsigned int CommandsCompleted;
-	unsigned int ReadCommands;
-	unsigned int WriteCommands;
-	struct BusLogic_ByteCounter TotalBytesRead;
-	struct BusLogic_ByteCounter TotalBytesWritten;
-	BusLogic_CommandSizeBuckets_T ReadCommandSizeBuckets;
-	BusLogic_CommandSizeBuckets_T WriteCommandSizeBuckets;
-	unsigned short CommandAbortsRequested;
-	unsigned short CommandAbortsAttempted;
-	unsigned short CommandAbortsCompleted;
-	unsigned short BusDeviceResetsRequested;
-	unsigned short BusDeviceResetsAttempted;
-	unsigned short BusDeviceResetsCompleted;
-	unsigned short HostAdapterResetsRequested;
-	unsigned short HostAdapterResetsAttempted;
-	unsigned short HostAdapterResetsCompleted;
+#define BLOGIC_SZ_BUCKETS			10
+
+struct blogic_tgt_stats {
+	unsigned int cmds_tried;
+	unsigned int cmds_complete;
+	unsigned int read_cmds;
+	unsigned int write_cmds;
+	struct blogic_byte_count bytesread;
+	struct blogic_byte_count byteswritten;
+	unsigned int read_sz_buckets[BLOGIC_SZ_BUCKETS];
+	unsigned int write_sz_buckets[BLOGIC_SZ_BUCKETS];
+	unsigned short aborts_request;
+	unsigned short aborts_tried;
+	unsigned short aborts_done;
+	unsigned short bdr_request;
+	unsigned short bdr_tried;
+	unsigned short bdr_done;
+	unsigned short adatper_reset_req;
+	unsigned short adapter_reset_attempt;
+	unsigned short adapter_reset_done;
 };
 
 /*
   Define the FlashPoint Card Handle data type.
 */
 
-#define FlashPoint_BadCardHandle		0xFFFFFFFF
-
-typedef unsigned int FlashPoint_CardHandle_T;
+#define FPOINT_BADCARD_HANDLE		0xFFFFFFFF
 
 
 /*
@@ -967,179 +949,179 @@ typedef unsigned int FlashPoint_CardHandle_T;
   by the FlashPoint SCCB Manager.
 */
 
-struct FlashPoint_Info {
-	u32 BaseAddress;	/* Bytes 0-3 */
-	bool Present;		/* Byte 4 */
-	unsigned char IRQ_Channel;	/* Byte 5 */
-	unsigned char SCSI_ID;	/* Byte 6 */
-	unsigned char SCSI_LUN;	/* Byte 7 */
-	unsigned short FirmwareRevision;	/* Bytes 8-9 */
-	unsigned short SynchronousPermitted;	/* Bytes 10-11 */
-	unsigned short FastPermitted;	/* Bytes 12-13 */
-	unsigned short UltraPermitted;	/* Bytes 14-15 */
-	unsigned short DisconnectPermitted;	/* Bytes 16-17 */
-	unsigned short WidePermitted;	/* Bytes 18-19 */
-	bool ParityCheckingEnabled:1;	/* Byte 20 Bit 0 */
-	bool HostWideSCSI:1;		/* Byte 20 Bit 1 */
-	bool HostSoftReset:1;		/* Byte 20 Bit 2 */
-	bool ExtendedTranslationEnabled:1;	/* Byte 20 Bit 3 */
-	bool LowByteTerminated:1;	/* Byte 20 Bit 4 */
-	bool HighByteTerminated:1;	/* Byte 20 Bit 5 */
-	bool ReportDataUnderrun:1;	/* Byte 20 Bit 6 */
-	bool SCAM_Enabled:1;	/* Byte 20 Bit 7 */
-	bool SCAM_Level2:1;	/* Byte 21 Bit 0 */
-	unsigned char:7;	/* Byte 21 Bits 1-7 */
-	unsigned char Family;	/* Byte 22 */
-	unsigned char BusType;	/* Byte 23 */
-	unsigned char ModelNumber[3];	/* Bytes 24-26 */
-	unsigned char RelativeCardNumber;	/* Byte 27 */
-	unsigned char Reserved[4];	/* Bytes 28-31 */
-	unsigned int OS_Reserved;	/* Bytes 32-35 */
-	unsigned char TranslationInfo[4];	/* Bytes 36-39 */
-	unsigned int Reserved2[5];	/* Bytes 40-59 */
-	unsigned int SecondaryRange;	/* Bytes 60-63 */
+struct fpoint_info {
+	u32 base_addr;				/* Bytes 0-3 */
+	bool present;				/* Byte 4 */
+	unsigned char irq_ch;			/* Byte 5 */
+	unsigned char scsi_id;			/* Byte 6 */
+	unsigned char scsi_lun;			/* Byte 7 */
+	unsigned short fw_rev;			/* Bytes 8-9 */
+	unsigned short sync_ok;			/* Bytes 10-11 */
+	unsigned short fast_ok;			/* Bytes 12-13 */
+	unsigned short ultra_ok;		/* Bytes 14-15 */
+	unsigned short discon_ok;		/* Bytes 16-17 */
+	unsigned short wide_ok;			/* Bytes 18-19 */
+	bool parity:1;				/* Byte 20 Bit 0 */
+	bool wide:1;				/* Byte 20 Bit 1 */
+	bool softreset:1;			/* Byte 20 Bit 2 */
+	bool ext_trans_enable:1;		/* Byte 20 Bit 3 */
+	bool low_term:1;			/* Byte 20 Bit 4 */
+	bool high_term:1;			/* Byte 20 Bit 5 */
+	bool report_underrun:1;			/* Byte 20 Bit 6 */
+	bool scam_enabled:1;			/* Byte 20 Bit 7 */
+	bool scam_lev2:1;			/* Byte 21 Bit 0 */
+	unsigned char:7;			/* Byte 21 Bits 1-7 */
+	unsigned char family;			/* Byte 22 */
+	unsigned char bus_type;			/* Byte 23 */
+	unsigned char model[3];			/* Bytes 24-26 */
+	unsigned char relative_cardnum;		/* Byte 27 */
+	unsigned char rsvd[4];			/* Bytes 28-31 */
+	unsigned int os_rsvd;			/* Bytes 32-35 */
+	unsigned char translation_info[4];	/* Bytes 36-39 */
+	unsigned int rsvd2[5];			/* Bytes 40-59 */
+	unsigned int sec_range;			/* Bytes 60-63 */
 };
 
 /*
   Define the BusLogic Driver Host Adapter structure.
 */
 
-struct BusLogic_HostAdapter {
-	struct Scsi_Host *SCSI_Host;
-	struct pci_dev *PCI_Device;
-	enum BusLogic_HostAdapterType HostAdapterType;
-	enum BusLogic_HostAdapterBusType HostAdapterBusType;
-	unsigned long IO_Address;
-	unsigned long PCI_Address;
-	unsigned short AddressCount;
-	unsigned char HostNumber;
-	unsigned char ModelName[9];
-	unsigned char FirmwareVersion[6];
-	unsigned char FullModelName[18];
-	unsigned char Bus;
-	unsigned char Device;
-	unsigned char IRQ_Channel;
-	unsigned char DMA_Channel;
-	unsigned char SCSI_ID;
-	bool IRQ_ChannelAcquired:1;
-	bool DMA_ChannelAcquired:1;
-	bool ExtendedTranslationEnabled:1;
-	bool ParityCheckingEnabled:1;
-	bool BusResetEnabled:1;
-	bool LevelSensitiveInterrupt:1;
-	bool HostWideSCSI:1;
-	bool HostDifferentialSCSI:1;
-	bool HostSupportsSCAM:1;
-	bool HostUltraSCSI:1;
-	bool ExtendedLUNSupport:1;
-	bool TerminationInfoValid:1;
-	bool LowByteTerminated:1;
-	bool HighByteTerminated:1;
-	bool BounceBuffersRequired:1;
-	bool StrictRoundRobinModeSupport:1;
-	bool SCAM_Enabled:1;
-	bool SCAM_Level2:1;
-	bool HostAdapterInitialized:1;
-	bool HostAdapterExternalReset:1;
-	bool HostAdapterInternalError:1;
-	bool ProcessCompletedCCBsActive;
-	volatile bool HostAdapterCommandCompleted;
-	unsigned short HostAdapterScatterGatherLimit;
-	unsigned short DriverScatterGatherLimit;
-	unsigned short MaxTargetDevices;
-	unsigned short MaxLogicalUnits;
-	unsigned short MailboxCount;
-	unsigned short InitialCCBs;
-	unsigned short IncrementalCCBs;
-	unsigned short AllocatedCCBs;
-	unsigned short DriverQueueDepth;
-	unsigned short HostAdapterQueueDepth;
-	unsigned short UntaggedQueueDepth;
-	unsigned short CommonQueueDepth;
-	unsigned short BusSettleTime;
-	unsigned short SynchronousPermitted;
-	unsigned short FastPermitted;
-	unsigned short UltraPermitted;
-	unsigned short WidePermitted;
-	unsigned short DisconnectPermitted;
-	unsigned short TaggedQueuingPermitted;
-	unsigned short ExternalHostAdapterResets;
-	unsigned short HostAdapterInternalErrors;
-	unsigned short TargetDeviceCount;
-	unsigned short MessageBufferLength;
-	u32 BIOS_Address;
-	struct BusLogic_DriverOptions *DriverOptions;
-	struct FlashPoint_Info FlashPointInfo;
-	FlashPoint_CardHandle_T CardHandle;
+struct blogic_adapter {
+	struct Scsi_Host *scsi_host;
+	struct pci_dev *pci_device;
+	enum blogic_adapter_type adapter_type;
+	enum blogic_adapter_bus_type adapter_bus_type;
+	unsigned long io_addr;
+	unsigned long pci_addr;
+	unsigned short addr_count;
+	unsigned char host_no;
+	unsigned char model[9];
+	unsigned char fw_ver[6];
+	unsigned char full_model[18];
+	unsigned char bus;
+	unsigned char dev;
+	unsigned char irq_ch;
+	unsigned char dma_ch;
+	unsigned char scsi_id;
+	bool irq_acquired:1;
+	bool dma_chan_acquired:1;
+	bool ext_trans_enable:1;
+	bool parity:1;
+	bool reset_enabled:1;
+	bool level_int:1;
+	bool wide:1;
+	bool differential:1;
+	bool scam:1;
+	bool ultra:1;
+	bool ext_lun:1;
+	bool terminfo_valid:1;
+	bool low_term:1;
+	bool high_term:1;
+	bool need_bouncebuf:1;
+	bool strict_rr:1;
+	bool scam_enabled:1;
+	bool scam_lev2:1;
+	bool adapter_initd:1;
+	bool adapter_extreset:1;
+	bool adapter_intern_err:1;
+	bool processing_ccbs;
+	volatile bool adapter_cmd_complete;
+	unsigned short adapter_sglimit;
+	unsigned short drvr_sglimit;
+	unsigned short maxdev;
+	unsigned short maxlun;
+	unsigned short mbox_count;
+	unsigned short initccbs;
+	unsigned short inc_ccbs;
+	unsigned short alloc_ccbs;
+	unsigned short drvr_qdepth;
+	unsigned short adapter_qdepth;
+	unsigned short untag_qdepth;
+	unsigned short common_qdepth;
+	unsigned short bus_settle_time;
+	unsigned short sync_ok;
+	unsigned short fast_ok;
+	unsigned short ultra_ok;
+	unsigned short wide_ok;
+	unsigned short discon_ok;
+	unsigned short tagq_ok;
+	unsigned short ext_resets;
+	unsigned short adapter_intern_errors;
+	unsigned short tgt_count;
+	unsigned short msgbuflen;
+	u32 bios_addr;
+	struct blogic_drvr_options *drvr_opts;
+	struct fpoint_info fpinfo;
+	unsigned int cardhandle;
 	struct list_head host_list;
-	struct BusLogic_CCB *All_CCBs;
-	struct BusLogic_CCB *Free_CCBs;
-	struct BusLogic_CCB *FirstCompletedCCB;
-	struct BusLogic_CCB *LastCompletedCCB;
-	struct BusLogic_CCB *BusDeviceResetPendingCCB[BusLogic_MaxTargetDevices];
-	struct BusLogic_TargetFlags TargetFlags[BusLogic_MaxTargetDevices];
-	unsigned char QueueDepth[BusLogic_MaxTargetDevices];
-	unsigned char SynchronousPeriod[BusLogic_MaxTargetDevices];
-	unsigned char SynchronousOffset[BusLogic_MaxTargetDevices];
-	unsigned char ActiveCommands[BusLogic_MaxTargetDevices];
-	unsigned int CommandsSinceReset[BusLogic_MaxTargetDevices];
-	unsigned long LastSequencePoint[BusLogic_MaxTargetDevices];
-	unsigned long LastResetAttempted[BusLogic_MaxTargetDevices];
-	unsigned long LastResetCompleted[BusLogic_MaxTargetDevices];
-	struct BusLogic_OutgoingMailbox *FirstOutgoingMailbox;
-	struct BusLogic_OutgoingMailbox *LastOutgoingMailbox;
-	struct BusLogic_OutgoingMailbox *NextOutgoingMailbox;
-	struct BusLogic_IncomingMailbox *FirstIncomingMailbox;
-	struct BusLogic_IncomingMailbox *LastIncomingMailbox;
-	struct BusLogic_IncomingMailbox *NextIncomingMailbox;
-	struct BusLogic_TargetStatistics TargetStatistics[BusLogic_MaxTargetDevices];
-	unsigned char *MailboxSpace;
-	dma_addr_t MailboxSpaceHandle;
-	unsigned int MailboxSize;
-	unsigned long CCB_Offset;
-	char MessageBuffer[BusLogic_MessageBufferSize];
+	struct blogic_ccb *all_ccbs;
+	struct blogic_ccb *free_ccbs;
+	struct blogic_ccb *firstccb;
+	struct blogic_ccb *lastccb;
+	struct blogic_ccb *bdr_pend[BLOGIC_MAXDEV];
+	struct blogic_tgt_flags tgt_flags[BLOGIC_MAXDEV];
+	unsigned char qdepth[BLOGIC_MAXDEV];
+	unsigned char sync_period[BLOGIC_MAXDEV];
+	unsigned char sync_offset[BLOGIC_MAXDEV];
+	unsigned char active_cmds[BLOGIC_MAXDEV];
+	unsigned int cmds_since_rst[BLOGIC_MAXDEV];
+	unsigned long last_seqpoint[BLOGIC_MAXDEV];
+	unsigned long last_resettried[BLOGIC_MAXDEV];
+	unsigned long last_resetdone[BLOGIC_MAXDEV];
+	struct blogic_outbox *first_outbox;
+	struct blogic_outbox *last_outbox;
+	struct blogic_outbox *next_outbox;
+	struct blogic_inbox *first_inbox;
+	struct blogic_inbox *last_inbox;
+	struct blogic_inbox *next_inbox;
+	struct blogic_tgt_stats tgt_stats[BLOGIC_MAXDEV];
+	unsigned char *mbox_space;
+	dma_addr_t mbox_space_handle;
+	unsigned int mbox_sz;
+	unsigned long ccb_offset;
+	char msgbuf[BLOGIC_MSGBUF_SIZE];
 };
 
 /*
   Define a structure for the BIOS Disk Parameters.
 */
 
-struct BIOS_DiskParameters {
-	int Heads;
-	int Sectors;
-	int Cylinders;
+struct bios_diskparam {
+	int heads;
+	int sectors;
+	int cylinders;
 };
 
 /*
   Define a structure for the SCSI Inquiry command results.
 */
 
-struct SCSI_Inquiry {
-	unsigned char PeripheralDeviceType:5;	/* Byte 0 Bits 0-4 */
-	unsigned char PeripheralQualifier:3;	/* Byte 0 Bits 5-7 */
-	unsigned char DeviceTypeModifier:7;	/* Byte 1 Bits 0-6 */
-	bool RMB:1;		/* Byte 1 Bit 7 */
-	unsigned char ANSI_ApprovedVersion:3;	/* Byte 2 Bits 0-2 */
-	unsigned char ECMA_Version:3;	/* Byte 2 Bits 3-5 */
-	unsigned char ISO_Version:2;	/* Byte 2 Bits 6-7 */
-	unsigned char ResponseDataFormat:4;	/* Byte 3 Bits 0-3 */
-	unsigned char:2;	/* Byte 3 Bits 4-5 */
-	bool TrmIOP:1;		/* Byte 3 Bit 6 */
-	bool AENC:1;		/* Byte 3 Bit 7 */
-	unsigned char AdditionalLength;	/* Byte 4 */
-	unsigned char:8;	/* Byte 5 */
-	unsigned char:8;	/* Byte 6 */
-	bool SftRe:1;		/* Byte 7 Bit 0 */
-	bool CmdQue:1;		/* Byte 7 Bit 1 */
-	 bool:1;		/* Byte 7 Bit 2 */
-	bool Linked:1;		/* Byte 7 Bit 3 */
-	bool Sync:1;		/* Byte 7 Bit 4 */
-	bool WBus16:1;		/* Byte 7 Bit 5 */
-	bool WBus32:1;		/* Byte 7 Bit 6 */
-	bool RelAdr:1;		/* Byte 7 Bit 7 */
-	unsigned char VendorIdentification[8];	/* Bytes 8-15 */
-	unsigned char ProductIdentification[16];	/* Bytes 16-31 */
-	unsigned char ProductRevisionLevel[4];	/* Bytes 32-35 */
+struct scsi_inquiry {
+	unsigned char devtype:5;	/* Byte 0 Bits 0-4 */
+	unsigned char dev_qual:3;	/* Byte 0 Bits 5-7 */
+	unsigned char dev_modifier:7;	/* Byte 1 Bits 0-6 */
+	bool rmb:1;			/* Byte 1 Bit 7 */
+	unsigned char ansi_ver:3;	/* Byte 2 Bits 0-2 */
+	unsigned char ecma_ver:3;	/* Byte 2 Bits 3-5 */
+	unsigned char iso_ver:2;	/* Byte 2 Bits 6-7 */
+	unsigned char resp_fmt:4;	/* Byte 3 Bits 0-3 */
+	unsigned char:2;		/* Byte 3 Bits 4-5 */
+	bool TrmIOP:1;			/* Byte 3 Bit 6 */
+	bool AENC:1;			/* Byte 3 Bit 7 */
+	unsigned char addl_len;		/* Byte 4 */
+	unsigned char:8;		/* Byte 5 */
+	unsigned char:8;		/* Byte 6 */
+	bool SftRe:1;			/* Byte 7 Bit 0 */
+	bool CmdQue:1;			/* Byte 7 Bit 1 */
+	bool:1;				/* Byte 7 Bit 2 */
+	bool linked:1;			/* Byte 7 Bit 3 */
+	bool sync:1;			/* Byte 7 Bit 4 */
+	bool WBus16:1;			/* Byte 7 Bit 5 */
+	bool WBus32:1;			/* Byte 7 Bit 6 */
+	bool RelAdr:1;			/* Byte 7 Bit 7 */
+	unsigned char vendor[8];	/* Bytes 8-15 */
+	unsigned char product[16];	/* Bytes 16-31 */
+	unsigned char product_rev[4];	/* Bytes 32-35 */
 };
 
 
@@ -1148,184 +1130,170 @@ struct SCSI_Inquiry {
   Host Adapter I/O Registers.
 */
 
-static inline void BusLogic_SCSIBusReset(struct BusLogic_HostAdapter *HostAdapter)
+static inline void blogic_busreset(struct blogic_adapter *adapter)
 {
-	union BusLogic_ControlRegister ControlRegister;
-	ControlRegister.All = 0;
-	ControlRegister.cr.SCSIBusReset = true;
-	outb(ControlRegister.All, HostAdapter->IO_Address + BusLogic_ControlRegisterOffset);
+	union blogic_cntrl_reg cr;
+	cr.all = 0;
+	cr.cr.bus_reset = true;
+	outb(cr.all, adapter->io_addr + BLOGIC_CNTRL_REG);
 }
 
-static inline void BusLogic_InterruptReset(struct BusLogic_HostAdapter *HostAdapter)
+static inline void blogic_intreset(struct blogic_adapter *adapter)
 {
-	union BusLogic_ControlRegister ControlRegister;
-	ControlRegister.All = 0;
-	ControlRegister.cr.InterruptReset = true;
-	outb(ControlRegister.All, HostAdapter->IO_Address + BusLogic_ControlRegisterOffset);
+	union blogic_cntrl_reg cr;
+	cr.all = 0;
+	cr.cr.int_reset = true;
+	outb(cr.all, adapter->io_addr + BLOGIC_CNTRL_REG);
 }
 
-static inline void BusLogic_SoftReset(struct BusLogic_HostAdapter *HostAdapter)
+static inline void blogic_softreset(struct blogic_adapter *adapter)
 {
-	union BusLogic_ControlRegister ControlRegister;
-	ControlRegister.All = 0;
-	ControlRegister.cr.SoftReset = true;
-	outb(ControlRegister.All, HostAdapter->IO_Address + BusLogic_ControlRegisterOffset);
+	union blogic_cntrl_reg cr;
+	cr.all = 0;
+	cr.cr.soft_reset = true;
+	outb(cr.all, adapter->io_addr + BLOGIC_CNTRL_REG);
 }
 
-static inline void BusLogic_HardReset(struct BusLogic_HostAdapter *HostAdapter)
+static inline void blogic_hardreset(struct blogic_adapter *adapter)
 {
-	union BusLogic_ControlRegister ControlRegister;
-	ControlRegister.All = 0;
-	ControlRegister.cr.HardReset = true;
-	outb(ControlRegister.All, HostAdapter->IO_Address + BusLogic_ControlRegisterOffset);
+	union blogic_cntrl_reg cr;
+	cr.all = 0;
+	cr.cr.hard_reset = true;
+	outb(cr.all, adapter->io_addr + BLOGIC_CNTRL_REG);
 }
 
-static inline unsigned char BusLogic_ReadStatusRegister(struct BusLogic_HostAdapter *HostAdapter)
+static inline unsigned char blogic_rdstatus(struct blogic_adapter *adapter)
 {
-	return inb(HostAdapter->IO_Address + BusLogic_StatusRegisterOffset);
+	return inb(adapter->io_addr + BLOGIC_STATUS_REG);
 }
 
-static inline void BusLogic_WriteCommandParameterRegister(struct BusLogic_HostAdapter
-							  *HostAdapter, unsigned char Value)
+static inline void blogic_setcmdparam(struct blogic_adapter *adapter,
+					unsigned char value)
 {
-	outb(Value, HostAdapter->IO_Address + BusLogic_CommandParameterRegisterOffset);
+	outb(value, adapter->io_addr + BLOGIC_CMD_PARM_REG);
 }
 
-static inline unsigned char BusLogic_ReadDataInRegister(struct BusLogic_HostAdapter *HostAdapter)
+static inline unsigned char blogic_rddatain(struct blogic_adapter *adapter)
 {
-	return inb(HostAdapter->IO_Address + BusLogic_DataInRegisterOffset);
+	return inb(adapter->io_addr + BLOGIC_DATAIN_REG);
 }
 
-static inline unsigned char BusLogic_ReadInterruptRegister(struct BusLogic_HostAdapter *HostAdapter)
+static inline unsigned char blogic_rdint(struct blogic_adapter *adapter)
 {
-	return inb(HostAdapter->IO_Address + BusLogic_InterruptRegisterOffset);
+	return inb(adapter->io_addr + BLOGIC_INT_REG);
 }
 
-static inline unsigned char BusLogic_ReadGeometryRegister(struct BusLogic_HostAdapter *HostAdapter)
+static inline unsigned char blogic_rdgeom(struct blogic_adapter *adapter)
 {
-	return inb(HostAdapter->IO_Address + BusLogic_GeometryRegisterOffset);
+	return inb(adapter->io_addr + BLOGIC_GEOMETRY_REG);
 }
 
 /*
-  BusLogic_StartMailboxCommand issues an Execute Mailbox Command, which
+  blogic_execmbox issues an Execute Mailbox Command, which
   notifies the Host Adapter that an entry has been made in an Outgoing
   Mailbox.
 */
 
-static inline void BusLogic_StartMailboxCommand(struct BusLogic_HostAdapter *HostAdapter)
+static inline void blogic_execmbox(struct blogic_adapter *adapter)
 {
-	BusLogic_WriteCommandParameterRegister(HostAdapter, BusLogic_ExecuteMailboxCommand);
+	blogic_setcmdparam(adapter, BLOGIC_EXEC_MBOX_CMD);
 }
 
 /*
-  BusLogic_Delay waits for Seconds to elapse.
+  blogic_delay waits for Seconds to elapse.
 */
 
-static inline void BusLogic_Delay(int Seconds)
-{
-	mdelay(1000 * Seconds);
-}
-
-/*
-  Virtual_to_Bus and Bus_to_Virtual map between Kernel Virtual Addresses
-  and PCI/VLB/EISA/ISA Bus Addresses.
-*/
-
-static inline u32 Virtual_to_Bus(void *VirtualAddress)
-{
-	return (u32) virt_to_bus(VirtualAddress);
-}
-
-static inline void *Bus_to_Virtual(u32 BusAddress)
+static inline void blogic_delay(int seconds)
 {
-	return (void *) bus_to_virt(BusAddress);
+	mdelay(1000 * seconds);
 }
 
 /*
-  Virtual_to_32Bit_Virtual maps between Kernel Virtual Addresses and
+  virt_to_32bit_virt maps between Kernel Virtual Addresses and
   32 bit Kernel Virtual Addresses.  This avoids compilation warnings
   on 64 bit architectures.
 */
 
-static inline u32 Virtual_to_32Bit_Virtual(void *VirtualAddress)
+static inline u32 virt_to_32bit_virt(void *virt_addr)
 {
-	return (u32) (unsigned long) VirtualAddress;
+	return (u32) (unsigned long) virt_addr;
 }
 
 /*
-  BusLogic_IncrementErrorCounter increments Error Counter by 1, stopping at
+  blogic_inc_count increments counter by 1, stopping at
   65535 rather than wrapping around to 0.
 */
 
-static inline void BusLogic_IncrementErrorCounter(unsigned short *ErrorCounter)
+static inline void blogic_inc_count(unsigned short *count)
 {
-	if (*ErrorCounter < 65535)
-		(*ErrorCounter)++;
+	if (*count < 65535)
+		(*count)++;
 }
 
 /*
-  BusLogic_IncrementByteCounter increments Byte Counter by Amount.
+  blogic_addcount increments Byte Counter by Amount.
 */
 
-static inline void BusLogic_IncrementByteCounter(struct BusLogic_ByteCounter
-						 *ByteCounter, unsigned int Amount)
+static inline void blogic_addcount(struct blogic_byte_count *bytecount,
+					unsigned int amount)
 {
-	ByteCounter->Units += Amount;
-	if (ByteCounter->Units > 999999999) {
-		ByteCounter->Units -= 1000000000;
-		ByteCounter->Billions++;
+	bytecount->units += amount;
+	if (bytecount->units > 999999999) {
+		bytecount->units -= 1000000000;
+		bytecount->billions++;
 	}
 }
 
 /*
-  BusLogic_IncrementSizeBucket increments the Bucket for Amount.
+  blogic_incszbucket increments the Bucket for Amount.
 */
 
-static inline void BusLogic_IncrementSizeBucket(BusLogic_CommandSizeBuckets_T CommandSizeBuckets, unsigned int Amount)
+static inline void blogic_incszbucket(unsigned int *cmdsz_buckets,
+					unsigned int amount)
 {
-	int Index = 0;
-	if (Amount < 8 * 1024) {
-		if (Amount < 2 * 1024)
-			Index = (Amount < 1 * 1024 ? 0 : 1);
+	int index = 0;
+	if (amount < 8 * 1024) {
+		if (amount < 2 * 1024)
+			index = (amount < 1 * 1024 ? 0 : 1);
 		else
-			Index = (Amount < 4 * 1024 ? 2 : 3);
-	} else if (Amount < 128 * 1024) {
-		if (Amount < 32 * 1024)
-			Index = (Amount < 16 * 1024 ? 4 : 5);
+			index = (amount < 4 * 1024 ? 2 : 3);
+	} else if (amount < 128 * 1024) {
+		if (amount < 32 * 1024)
+			index = (amount < 16 * 1024 ? 4 : 5);
 		else
-			Index = (Amount < 64 * 1024 ? 6 : 7);
+			index = (amount < 64 * 1024 ? 6 : 7);
 	} else
-		Index = (Amount < 256 * 1024 ? 8 : 9);
-	CommandSizeBuckets[Index]++;
+		index = (amount < 256 * 1024 ? 8 : 9);
+	cmdsz_buckets[index]++;
 }
 
 /*
   Define the version number of the FlashPoint Firmware (SCCB Manager).
 */
 
-#define FlashPoint_FirmwareVersion		"5.02"
+#define FLASHPOINT_FW_VER		"5.02"
 
 /*
   Define the possible return values from FlashPoint_HandleInterrupt.
 */
 
-#define FlashPoint_NormalInterrupt		0x00
-#define FlashPoint_InternalError		0xFE
-#define FlashPoint_ExternalBusReset		0xFF
+#define FPOINT_NORMAL_INT		0x00
+#define FPOINT_INTERN_ERR		0xFE
+#define FPOINT_EXT_RESET		0xFF
 
 /*
   Define prototypes for the forward referenced BusLogic Driver
   Internal Functions.
 */
 
-static const char *BusLogic_DriverInfo(struct Scsi_Host *);
-static int BusLogic_QueueCommand(struct Scsi_Host *h, struct scsi_cmnd *);
-static int BusLogic_BIOSDiskParameters(struct scsi_device *, struct block_device *, sector_t, int *);
-static int BusLogic_SlaveConfigure(struct scsi_device *);
-static void BusLogic_QueueCompletedCCB(struct BusLogic_CCB *);
-static irqreturn_t BusLogic_InterruptHandler(int, void *);
-static int BusLogic_ResetHostAdapter(struct BusLogic_HostAdapter *, bool HardReset);
-static void BusLogic_Message(enum BusLogic_MessageLevel, char *, struct BusLogic_HostAdapter *, ...);
-static int __init BusLogic_Setup(char *);
+static const char *blogic_drvr_info(struct Scsi_Host *);
+static int blogic_qcmd(struct Scsi_Host *h, struct scsi_cmnd *);
+static int blogic_diskparam(struct scsi_device *, struct block_device *, sector_t, int *);
+static int blogic_slaveconfig(struct scsi_device *);
+static void blogic_qcompleted_ccb(struct blogic_ccb *);
+static irqreturn_t blogic_inthandler(int, void *);
+static int blogic_resetadapter(struct blogic_adapter *, bool hard_reset);
+static void blogic_msg(enum blogic_msglevel, char *, struct blogic_adapter *, ...);
+static int __init blogic_setup(char *);
 
 #endif				/* _BUSLOGIC_H */

commit 25daa96f2bf72901c3abe664e5b461f29bbf3282
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Sun Mar 31 01:52:13 2013 -0400

    BusLogic: switch to ->show_info()
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/drivers/scsi/BusLogic.h b/drivers/scsi/BusLogic.h
index 649fcb31f26d..6c6c13c3be1b 100644
--- a/drivers/scsi/BusLogic.h
+++ b/drivers/scsi/BusLogic.h
@@ -1321,7 +1321,6 @@ static inline void BusLogic_IncrementSizeBucket(BusLogic_CommandSizeBuckets_T Co
 static const char *BusLogic_DriverInfo(struct Scsi_Host *);
 static int BusLogic_QueueCommand(struct Scsi_Host *h, struct scsi_cmnd *);
 static int BusLogic_BIOSDiskParameters(struct scsi_device *, struct block_device *, sector_t, int *);
-static int BusLogic_ProcDirectoryInfo(struct Scsi_Host *, char *, char **, off_t, int, int);
 static int BusLogic_SlaveConfigure(struct scsi_device *);
 static void BusLogic_QueueCompletedCCB(struct BusLogic_CCB *);
 static irqreturn_t BusLogic_InterruptHandler(int, void *);

commit f281233d3eba15fb225d21ae2e228fd4553d824a
Author: Jeff Garzik <jeff@garzik.org>
Date:   Tue Nov 16 02:10:29 2010 -0500

    SCSI host lock push-down
    
    Move the mid-layer's ->queuecommand() invocation from being locked
    with the host lock to being unlocked to facilitate speeding up the
    critical path for drivers who don't need this lock taken anyway.
    
    The patch below presents a simple SCSI host lock push-down as an
    equivalent transformation.  No locking or other behavior should change
    with this patch.  All existing bugs and locking orders are preserved.
    
    Additionally, add one parameter to queuecommand,
            struct Scsi_Host *
    and remove one parameter from queuecommand,
            void (*done)(struct scsi_cmnd *)
    
    Scsi_Host* is a convenient pointer that most host drivers need anyway,
    and 'done' is redundant to struct scsi_cmnd->scsi_done.
    
    Minimal code disturbance was attempted with this change.  Most drivers
    needed only two one-line modifications for their host lock push-down.
    
    Signed-off-by: Jeff Garzik <jgarzik@redhat.com>
    Acked-by: James Bottomley <James.Bottomley@suse.de>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/scsi/BusLogic.h b/drivers/scsi/BusLogic.h
index 73f237a1ed94..649fcb31f26d 100644
--- a/drivers/scsi/BusLogic.h
+++ b/drivers/scsi/BusLogic.h
@@ -1319,7 +1319,7 @@ static inline void BusLogic_IncrementSizeBucket(BusLogic_CommandSizeBuckets_T Co
 */
 
 static const char *BusLogic_DriverInfo(struct Scsi_Host *);
-static int BusLogic_QueueCommand(struct scsi_cmnd *, void (*CompletionRoutine) (struct scsi_cmnd *));
+static int BusLogic_QueueCommand(struct Scsi_Host *h, struct scsi_cmnd *);
 static int BusLogic_BIOSDiskParameters(struct scsi_device *, struct block_device *, sector_t, int *);
 static int BusLogic_ProcDirectoryInfo(struct Scsi_Host *, char *, char **, off_t, int, int);
 static int BusLogic_SlaveConfigure(struct scsi_device *);

commit 78b4b05db57b04b3ed17dc71259bf1402c04abfa
Author: Matthew Wilcox <matthew@wil.cx>
Date:   Thu Mar 13 06:55:08 2008 -0600

    [SCSI] BusLogic: make FlashPoint support x86-32 only
    
    We've verified that there are 64 bit and endianness problems in the
    flashpoint driver.  Reverse the logic of CONFIG_OMIT_FLASHPOINT (make
    it CONFIG_SCSI_FLASHPOINT) and make it depend on X86_32 so it can't
    appear for any other architectures.  Long term, if someone chooses,
    they could make FlashPoint 64 bit compliant (it looks like its a
    question of fixing up the sizes in some of the packed descriptors)
    
    Signed-off-by: James Bottomley <James.Bottomley@HansenPartnership.com>

diff --git a/drivers/scsi/BusLogic.h b/drivers/scsi/BusLogic.h
index bfbfb5c3a8f6..73f237a1ed94 100644
--- a/drivers/scsi/BusLogic.h
+++ b/drivers/scsi/BusLogic.h
@@ -33,23 +33,6 @@
 #define PACKED __attribute__((packed))
 #endif
 
-/*
-  FlashPoint support is only available for the Intel x86 Architecture with
-  CONFIG_PCI set.
-*/
-
-#ifndef __i386__
-#undef CONFIG_SCSI_OMIT_FLASHPOINT
-#define CONFIG_SCSI_OMIT_FLASHPOINT
-#endif
-
-#ifndef CONFIG_PCI
-#undef CONFIG_SCSI_OMIT_FLASHPOINT
-#define CONFIG_SCSI_OMIT_FLASHPOINT
-#define BusLogic_InitializeProbeInfoListISA BusLogic_InitializeProbeInfoList
-#endif
-
-
 /*
   Define the maximum number of BusLogic Host Adapters supported by this driver.
 */
@@ -178,7 +161,7 @@ static int BusLogic_HostAdapterAddressCount[3] = { 0, BusLogic_MultiMasterAddres
   Define macros for testing the Host Adapter Type.
 */
 
-#ifndef CONFIG_SCSI_OMIT_FLASHPOINT
+#ifdef CONFIG_SCSI_FLASHPOINT
 
 #define BusLogic_MultiMasterHostAdapterP(HostAdapter) \
   (HostAdapter->HostAdapterType == BusLogic_MultiMaster)
@@ -871,7 +854,7 @@ struct BusLogic_CCB {
 	void (*CallbackFunction) (struct BusLogic_CCB *);	/* Bytes 40-43 */
 	u32 BaseAddress;	/* Bytes 44-47 */
 	enum BusLogic_CompletionCode CompletionCode;	/* Byte 48 */
-#ifndef CONFIG_SCSI_OMIT_FLASHPOINT
+#ifdef CONFIG_SCSI_FLASHPOINT
 	unsigned char:8;	/* Byte 49 */
 	unsigned short OS_Flags;	/* Bytes 50-51 */
 	unsigned char Private[48];	/* Bytes 52-99 */

commit 2065e310cc116e4b2b0f42faaf27f0c9baaca9cd
Author: Richard Knutsson <ricknu-0@student.ltu.se>
Date:   Mon Feb 5 16:39:01 2007 -0800

    [SCSI] BusLogic: Replace 'boolean' by 'bool'
    
    Signed-off-by: Richard Knutsson <ricknu-0@student.ltu.se>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>

diff --git a/drivers/scsi/BusLogic.h b/drivers/scsi/BusLogic.h
index cca6d45eee4d..bfbfb5c3a8f6 100644
--- a/drivers/scsi/BusLogic.h
+++ b/drivers/scsi/BusLogic.h
@@ -233,12 +233,6 @@ enum BusLogic_BIOS_DiskGeometryTranslation {
 } PACKED;
 
 
-/*
-  Define a Boolean data type.
-*/
-
-typedef bool boolean;
-
 /*
   Define a 10^18 Statistics Byte Counter data type.
 */
@@ -269,19 +263,19 @@ struct BusLogic_ProbeInfo {
 */
 
 struct BusLogic_ProbeOptions {
-	boolean NoProbe:1;	/* Bit 0 */
-	boolean NoProbeISA:1;	/* Bit 1 */
-	boolean NoProbePCI:1;	/* Bit 2 */
-	boolean NoSortPCI:1;	/* Bit 3 */
-	boolean MultiMasterFirst:1;	/* Bit 4 */
-	boolean FlashPointFirst:1;	/* Bit 5 */
-	boolean LimitedProbeISA:1;	/* Bit 6 */
-	boolean Probe330:1;	/* Bit 7 */
-	boolean Probe334:1;	/* Bit 8 */
-	boolean Probe230:1;	/* Bit 9 */
-	boolean Probe234:1;	/* Bit 10 */
-	boolean Probe130:1;	/* Bit 11 */
-	boolean Probe134:1;	/* Bit 12 */
+	bool NoProbe:1;		/* Bit 0 */
+	bool NoProbeISA:1;	/* Bit 1 */
+	bool NoProbePCI:1;	/* Bit 2 */
+	bool NoSortPCI:1;	/* Bit 3 */
+	bool MultiMasterFirst:1;/* Bit 4 */
+	bool FlashPointFirst:1;	/* Bit 5 */
+	bool LimitedProbeISA:1;	/* Bit 6 */
+	bool Probe330:1;	/* Bit 7 */
+	bool Probe334:1;	/* Bit 8 */
+	bool Probe230:1;	/* Bit 9 */
+	bool Probe234:1;	/* Bit 10 */
+	bool Probe130:1;	/* Bit 11 */
+	bool Probe134:1;	/* Bit 12 */
 };
 
 /*
@@ -289,10 +283,10 @@ struct BusLogic_ProbeOptions {
 */
 
 struct BusLogic_GlobalOptions {
-	boolean TraceProbe:1;	/* Bit 0 */
-	boolean TraceHardwareReset:1;	/* Bit 1 */
-	boolean TraceConfiguration:1;	/* Bit 2 */
-	boolean TraceErrors:1;	/* Bit 3 */
+	bool TraceProbe:1;	/* Bit 0 */
+	bool TraceHardwareReset:1;	/* Bit 1 */
+	bool TraceConfiguration:1;	/* Bit 2 */
+	bool TraceErrors:1;	/* Bit 3 */
 };
 
 /*
@@ -300,7 +294,7 @@ struct BusLogic_GlobalOptions {
 */
 
 struct BusLogic_LocalOptions {
-	boolean InhibitTargetInquiry:1;	/* Bit 0 */
+	bool InhibitTargetInquiry:1;	/* Bit 0 */
 };
 
 /*
@@ -322,10 +316,10 @@ union BusLogic_ControlRegister {
 	unsigned char All;
 	struct {
 		unsigned char:4;	/* Bits 0-3 */
-		boolean SCSIBusReset:1;	/* Bit 4 */
-		boolean InterruptReset:1;	/* Bit 5 */
-		boolean SoftReset:1;	/* Bit 6 */
-		boolean HardReset:1;	/* Bit 7 */
+		bool SCSIBusReset:1;	/* Bit 4 */
+		bool InterruptReset:1;	/* Bit 5 */
+		bool SoftReset:1;	/* Bit 6 */
+		bool HardReset:1;	/* Bit 7 */
 	} cr;
 };
 
@@ -336,14 +330,14 @@ union BusLogic_ControlRegister {
 union BusLogic_StatusRegister {
 	unsigned char All;
 	struct {
-		boolean CommandInvalid:1;	/* Bit 0 */
-		boolean Reserved:1;	/* Bit 1 */
-		boolean DataInRegisterReady:1;	/* Bit 2 */
-		boolean CommandParameterRegisterBusy:1;	/* Bit 3 */
-		boolean HostAdapterReady:1;	/* Bit 4 */
-		boolean InitializationRequired:1;	/* Bit 5 */
-		boolean DiagnosticFailure:1;	/* Bit 6 */
-		boolean DiagnosticActive:1;	/* Bit 7 */
+		bool CommandInvalid:1;		/* Bit 0 */
+		bool Reserved:1;		/* Bit 1 */
+		bool DataInRegisterReady:1;	/* Bit 2 */
+		bool CommandParameterRegisterBusy:1;	/* Bit 3 */
+		bool HostAdapterReady:1;	/* Bit 4 */
+		bool InitializationRequired:1;	/* Bit 5 */
+		bool DiagnosticFailure:1;	/* Bit 6 */
+		bool DiagnosticActive:1;	/* Bit 7 */
 	} sr;
 };
 
@@ -354,12 +348,12 @@ union BusLogic_StatusRegister {
 union BusLogic_InterruptRegister {
 	unsigned char All;
 	struct {
-		boolean IncomingMailboxLoaded:1;	/* Bit 0 */
-		boolean OutgoingMailboxAvailable:1;	/* Bit 1 */
-		boolean CommandComplete:1;	/* Bit 2 */
-		boolean ExternalBusReset:1;	/* Bit 3 */
+		bool IncomingMailboxLoaded:1;	/* Bit 0 */
+		bool OutgoingMailboxAvailable:1;/* Bit 1 */
+		bool CommandComplete:1;		/* Bit 2 */
+		bool ExternalBusReset:1;	/* Bit 3 */
 		unsigned char Reserved:3;	/* Bits 4-6 */
-		boolean InterruptValid:1;	/* Bit 7 */
+		bool InterruptValid:1;		/* Bit 7 */
 	} ir;
 };
 
@@ -373,7 +367,7 @@ union BusLogic_GeometryRegister {
 		enum BusLogic_BIOS_DiskGeometryTranslation Drive0Geometry:2;	/* Bits 0-1 */
 		enum BusLogic_BIOS_DiskGeometryTranslation Drive1Geometry:2;	/* Bits 2-3 */
 		unsigned char:3;	/* Bits 4-6 */
-		boolean ExtendedTranslationEnabled:1;	/* Bit 7 */
+		bool ExtendedTranslationEnabled:1;	/* Bit 7 */
 	} gr;
 };
 
@@ -445,16 +439,16 @@ struct BusLogic_BoardID {
 
 struct BusLogic_Configuration {
 	unsigned char:5;	/* Byte 0 Bits 0-4 */
-	boolean DMA_Channel5:1;	/* Byte 0 Bit 5 */
-	boolean DMA_Channel6:1;	/* Byte 0 Bit 6 */
-	boolean DMA_Channel7:1;	/* Byte 0 Bit 7 */
-	boolean IRQ_Channel9:1;	/* Byte 1 Bit 0 */
-	boolean IRQ_Channel10:1;	/* Byte 1 Bit 1 */
-	boolean IRQ_Channel11:1;	/* Byte 1 Bit 2 */
-	boolean IRQ_Channel12:1;	/* Byte 1 Bit 3 */
+	bool DMA_Channel5:1;	/* Byte 0 Bit 5 */
+	bool DMA_Channel6:1;	/* Byte 0 Bit 6 */
+	bool DMA_Channel7:1;	/* Byte 0 Bit 7 */
+	bool IRQ_Channel9:1;	/* Byte 1 Bit 0 */
+	bool IRQ_Channel10:1;	/* Byte 1 Bit 1 */
+	bool IRQ_Channel11:1;	/* Byte 1 Bit 2 */
+	bool IRQ_Channel12:1;	/* Byte 1 Bit 3 */
 	unsigned char:1;	/* Byte 1 Bit 4 */
-	boolean IRQ_Channel14:1;	/* Byte 1 Bit 5 */
-	boolean IRQ_Channel15:1;	/* Byte 1 Bit 6 */
+	bool IRQ_Channel14:1;	/* Byte 1 Bit 5 */
+	bool IRQ_Channel15:1;	/* Byte 1 Bit 6 */
 	unsigned char:1;	/* Byte 1 Bit 7 */
 	unsigned char HostAdapterID:4;	/* Byte 2 Bits 0-3 */
 	unsigned char:4;	/* Byte 2 Bits 4-7 */
@@ -467,12 +461,12 @@ struct BusLogic_Configuration {
 struct BusLogic_SynchronousValue {
 	unsigned char Offset:4;	/* Bits 0-3 */
 	unsigned char TransferPeriod:3;	/* Bits 4-6 */
-	boolean Synchronous:1;	/* Bit 7 */
+	bool Synchronous:1;	/* Bit 7 */
 };
 
 struct BusLogic_SetupInformation {
-	boolean SynchronousInitiationEnabled:1;	/* Byte 0 Bit 0 */
-	boolean ParityCheckingEnabled:1;	/* Byte 0 Bit 1 */
+	bool SynchronousInitiationEnabled:1;	/* Byte 0 Bit 0 */
+	bool ParityCheckingEnabled:1;		/* Byte 0 Bit 1 */
 	unsigned char:6;	/* Byte 0 Bits 2-7 */
 	unsigned char BusTransferRate;	/* Byte 1 */
 	unsigned char PreemptTimeOnBus;	/* Byte 2 */
@@ -523,13 +517,13 @@ enum BusLogic_ISACompatibleIOPort {
 struct BusLogic_PCIHostAdapterInformation {
 	enum BusLogic_ISACompatibleIOPort ISACompatibleIOPort;	/* Byte 0 */
 	unsigned char PCIAssignedIRQChannel;	/* Byte 1 */
-	boolean LowByteTerminated:1;	/* Byte 2 Bit 0 */
-	boolean HighByteTerminated:1;	/* Byte 2 Bit 1 */
+	bool LowByteTerminated:1;	/* Byte 2 Bit 0 */
+	bool HighByteTerminated:1;	/* Byte 2 Bit 1 */
 	unsigned char:2;	/* Byte 2 Bits 2-3 */
-	boolean JP1:1;		/* Byte 2 Bit 4 */
-	boolean JP2:1;		/* Byte 2 Bit 5 */
-	boolean JP3:1;		/* Byte 2 Bit 6 */
-	boolean GenericInfoValid:1;	/* Byte 2 Bit 7 */
+	bool JP1:1;		/* Byte 2 Bit 4 */
+	bool JP2:1;		/* Byte 2 Bit 5 */
+	bool JP3:1;		/* Byte 2 Bit 6 */
+	bool GenericInfoValid:1;/* Byte 2 Bit 7 */
 	unsigned char:8;	/* Byte 3 */
 };
 
@@ -545,17 +539,17 @@ struct BusLogic_ExtendedSetupInformation {
 	u32 BaseMailboxAddress;	/* Bytes 5-8 */
 	struct {
 		unsigned char:2;	/* Byte 9 Bits 0-1 */
-		boolean FastOnEISA:1;	/* Byte 9 Bit 2 */
+		bool FastOnEISA:1;	/* Byte 9 Bit 2 */
 		unsigned char:3;	/* Byte 9 Bits 3-5 */
-		boolean LevelSensitiveInterrupt:1;	/* Byte 9 Bit 6 */
+		bool LevelSensitiveInterrupt:1;	/* Byte 9 Bit 6 */
 		unsigned char:1;	/* Byte 9 Bit 7 */
 	} Misc;
 	unsigned char FirmwareRevision[3];	/* Bytes 10-12 */
-	boolean HostWideSCSI:1;	/* Byte 13 Bit 0 */
-	boolean HostDifferentialSCSI:1;	/* Byte 13 Bit 1 */
-	boolean HostSupportsSCAM:1;	/* Byte 13 Bit 2 */
-	boolean HostUltraSCSI:1;	/* Byte 13 Bit 3 */
-	boolean HostSmartTermination:1;	/* Byte 13 Bit 4 */
+	bool HostWideSCSI:1;		/* Byte 13 Bit 0 */
+	bool HostDifferentialSCSI:1;	/* Byte 13 Bit 1 */
+	bool HostSupportsSCAM:1;	/* Byte 13 Bit 2 */
+	bool HostUltraSCSI:1;		/* Byte 13 Bit 3 */
+	bool HostSmartTermination:1;	/* Byte 13 Bit 4 */
 	unsigned char:3;	/* Byte 13 Bits 5-7 */
 } PACKED;
 
@@ -590,35 +584,35 @@ struct BusLogic_AutoSCSIData {
 	unsigned char InformationByteCount;	/* Byte 2 */
 	unsigned char HostAdapterType[6];	/* Bytes 3-8 */
 	unsigned char:8;	/* Byte 9 */
-	boolean FloppyEnabled:1;	/* Byte 10 Bit 0 */
-	boolean FloppySecondary:1;	/* Byte 10 Bit 1 */
-	boolean LevelSensitiveInterrupt:1;	/* Byte 10 Bit 2 */
+	bool FloppyEnabled:1;		/* Byte 10 Bit 0 */
+	bool FloppySecondary:1;		/* Byte 10 Bit 1 */
+	bool LevelSensitiveInterrupt:1;	/* Byte 10 Bit 2 */
 	unsigned char:2;	/* Byte 10 Bits 3-4 */
 	unsigned char SystemRAMAreaForBIOS:3;	/* Byte 10 Bits 5-7 */
 	unsigned char DMA_Channel:7;	/* Byte 11 Bits 0-6 */
-	boolean DMA_AutoConfiguration:1;	/* Byte 11 Bit 7 */
+	bool DMA_AutoConfiguration:1;	/* Byte 11 Bit 7 */
 	unsigned char IRQ_Channel:7;	/* Byte 12 Bits 0-6 */
-	boolean IRQ_AutoConfiguration:1;	/* Byte 12 Bit 7 */
+	bool IRQ_AutoConfiguration:1;	/* Byte 12 Bit 7 */
 	unsigned char DMA_TransferRate;	/* Byte 13 */
 	unsigned char SCSI_ID;	/* Byte 14 */
-	boolean LowByteTerminated:1;	/* Byte 15 Bit 0 */
-	boolean ParityCheckingEnabled:1;	/* Byte 15 Bit 1 */
-	boolean HighByteTerminated:1;	/* Byte 15 Bit 2 */
-	boolean NoisyCablingEnvironment:1;	/* Byte 15 Bit 3 */
-	boolean FastSynchronousNegotiation:1;	/* Byte 15 Bit 4 */
-	boolean BusResetEnabled:1;	/* Byte 15 Bit 5 */
-	 boolean:1;		/* Byte 15 Bit 6 */
-	boolean ActiveNegationEnabled:1;	/* Byte 15 Bit 7 */
+	bool LowByteTerminated:1;	/* Byte 15 Bit 0 */
+	bool ParityCheckingEnabled:1;	/* Byte 15 Bit 1 */
+	bool HighByteTerminated:1;	/* Byte 15 Bit 2 */
+	bool NoisyCablingEnvironment:1;	/* Byte 15 Bit 3 */
+	bool FastSynchronousNegotiation:1;	/* Byte 15 Bit 4 */
+	bool BusResetEnabled:1;		/* Byte 15 Bit 5 */
+	 bool:1;		/* Byte 15 Bit 6 */
+	bool ActiveNegationEnabled:1;	/* Byte 15 Bit 7 */
 	unsigned char BusOnDelay;	/* Byte 16 */
 	unsigned char BusOffDelay;	/* Byte 17 */
-	boolean HostAdapterBIOSEnabled:1;	/* Byte 18 Bit 0 */
-	boolean BIOSRedirectionOfINT19Enabled:1;	/* Byte 18 Bit 1 */
-	boolean ExtendedTranslationEnabled:1;	/* Byte 18 Bit 2 */
-	boolean MapRemovableAsFixedEnabled:1;	/* Byte 18 Bit 3 */
-	 boolean:1;		/* Byte 18 Bit 4 */
-	boolean BIOSSupportsMoreThan2DrivesEnabled:1;	/* Byte 18 Bit 5 */
-	boolean BIOSInterruptModeEnabled:1;	/* Byte 18 Bit 6 */
-	boolean FlopticalSupportEnabled:1;	/* Byte 19 Bit 7 */
+	bool HostAdapterBIOSEnabled:1;		/* Byte 18 Bit 0 */
+	bool BIOSRedirectionOfINT19Enabled:1;	/* Byte 18 Bit 1 */
+	bool ExtendedTranslationEnabled:1;	/* Byte 18 Bit 2 */
+	bool MapRemovableAsFixedEnabled:1;	/* Byte 18 Bit 3 */
+	 bool:1;		/* Byte 18 Bit 4 */
+	bool BIOSSupportsMoreThan2DrivesEnabled:1;	/* Byte 18 Bit 5 */
+	bool BIOSInterruptModeEnabled:1;	/* Byte 18 Bit 6 */
+	bool FlopticalSupportEnabled:1;		/* Byte 19 Bit 7 */
 	unsigned short DeviceEnabled;	/* Bytes 19-20 */
 	unsigned short WidePermitted;	/* Bytes 21-22 */
 	unsigned short FastPermitted;	/* Bytes 23-24 */
@@ -628,22 +622,22 @@ struct BusLogic_AutoSCSIData {
 	unsigned short IgnoreInBIOSScan;	/* Bytes 31-32 */
 	unsigned char PCIInterruptPin:2;	/* Byte 33 Bits 0-1 */
 	unsigned char HostAdapterIOPortAddress:2;	/* Byte 33 Bits 2-3 */
-	boolean StrictRoundRobinModeEnabled:1;	/* Byte 33 Bit 4 */
-	boolean VESABusSpeedGreaterThan33MHz:1;	/* Byte 33 Bit 5 */
-	boolean VESABurstWriteEnabled:1;	/* Byte 33 Bit 6 */
-	boolean VESABurstReadEnabled:1;	/* Byte 33 Bit 7 */
+	bool StrictRoundRobinModeEnabled:1;	/* Byte 33 Bit 4 */
+	bool VESABusSpeedGreaterThan33MHz:1;	/* Byte 33 Bit 5 */
+	bool VESABurstWriteEnabled:1;	/* Byte 33 Bit 6 */
+	bool VESABurstReadEnabled:1;	/* Byte 33 Bit 7 */
 	unsigned short UltraPermitted;	/* Bytes 34-35 */
 	unsigned int:32;	/* Bytes 36-39 */
 	unsigned char:8;	/* Byte 40 */
 	unsigned char AutoSCSIMaximumLUN;	/* Byte 41 */
-	 boolean:1;		/* Byte 42 Bit 0 */
-	boolean SCAM_Dominant:1;	/* Byte 42 Bit 1 */
-	boolean SCAM_Enabled:1;	/* Byte 42 Bit 2 */
-	boolean SCAM_Level2:1;	/* Byte 42 Bit 3 */
+	 bool:1;		/* Byte 42 Bit 0 */
+	bool SCAM_Dominant:1;	/* Byte 42 Bit 1 */
+	bool SCAM_Enabled:1;	/* Byte 42 Bit 2 */
+	bool SCAM_Level2:1;	/* Byte 42 Bit 3 */
 	unsigned char:4;	/* Byte 42 Bits 4-7 */
-	boolean INT13ExtensionEnabled:1;	/* Byte 43 Bit 0 */
-	 boolean:1;		/* Byte 43 Bit 1 */
-	boolean CDROMBootEnabled:1;	/* Byte 43 Bit 2 */
+	bool INT13ExtensionEnabled:1;	/* Byte 43 Bit 0 */
+	 bool:1;		/* Byte 43 Bit 1 */
+	bool CDROMBootEnabled:1;	/* Byte 43 Bit 2 */
 	unsigned char:5;	/* Byte 43 Bits 3-7 */
 	unsigned char BootTargetID:4;	/* Byte 44 Bits 0-3 */
 	unsigned char BootChannel:4;	/* Byte 44 Bits 4-7 */
@@ -852,7 +846,7 @@ struct BusLogic_CCB {
 	enum BusLogic_CCB_Opcode Opcode;	/* Byte 0 */
 	unsigned char:3;	/* Byte 1 Bits 0-2 */
 	enum BusLogic_DataDirection DataDirection:2;	/* Byte 1 Bits 3-4 */
-	boolean TagEnable:1;	/* Byte 1 Bit 5 */
+	bool TagEnable:1;	/* Byte 1 Bit 5 */
 	enum BusLogic_QueueTag QueueTag:2;	/* Byte 1 Bits 6-7 */
 	unsigned char CDB_Length;	/* Byte 2 */
 	unsigned char SenseDataLength;	/* Byte 3 */
@@ -864,7 +858,7 @@ struct BusLogic_CCB {
 	enum BusLogic_TargetDeviceStatus TargetDeviceStatus;	/* Byte 15 */
 	unsigned char TargetID;	/* Byte 16 */
 	unsigned char LogicalUnit:5;	/* Byte 17 Bits 0-4 */
-	boolean LegacyTagEnable:1;	/* Byte 17 Bit 5 */
+	bool LegacyTagEnable:1;	/* Byte 17 Bit 5 */
 	enum BusLogic_QueueTag LegacyQueueTag:2;	/* Byte 17 Bits 6-7 */
 	SCSI_CDB_T CDB;		/* Bytes 18-29 */
 	unsigned char:8;	/* Byte 30 */
@@ -939,13 +933,13 @@ struct BusLogic_DriverOptions {
 */
 
 struct BusLogic_TargetFlags {
-	boolean TargetExists:1;
-	boolean TaggedQueuingSupported:1;
-	boolean WideTransfersSupported:1;
-	boolean TaggedQueuingActive:1;
-	boolean WideTransfersActive:1;
-	boolean CommandSuccessfulFlag:1;
-	boolean TargetInfoReported:1;
+	bool TargetExists:1;
+	bool TaggedQueuingSupported:1;
+	bool WideTransfersSupported:1;
+	bool TaggedQueuingActive:1;
+	bool WideTransfersActive:1;
+	bool CommandSuccessfulFlag:1;
+	bool TargetInfoReported:1;
 };
 
 /*
@@ -992,7 +986,7 @@ typedef unsigned int FlashPoint_CardHandle_T;
 
 struct FlashPoint_Info {
 	u32 BaseAddress;	/* Bytes 0-3 */
-	boolean Present;	/* Byte 4 */
+	bool Present;		/* Byte 4 */
 	unsigned char IRQ_Channel;	/* Byte 5 */
 	unsigned char SCSI_ID;	/* Byte 6 */
 	unsigned char SCSI_LUN;	/* Byte 7 */
@@ -1002,15 +996,15 @@ struct FlashPoint_Info {
 	unsigned short UltraPermitted;	/* Bytes 14-15 */
 	unsigned short DisconnectPermitted;	/* Bytes 16-17 */
 	unsigned short WidePermitted;	/* Bytes 18-19 */
-	boolean ParityCheckingEnabled:1;	/* Byte 20 Bit 0 */
-	boolean HostWideSCSI:1;	/* Byte 20 Bit 1 */
-	boolean HostSoftReset:1;	/* Byte 20 Bit 2 */
-	boolean ExtendedTranslationEnabled:1;	/* Byte 20 Bit 3 */
-	boolean LowByteTerminated:1;	/* Byte 20 Bit 4 */
-	boolean HighByteTerminated:1;	/* Byte 20 Bit 5 */
-	boolean ReportDataUnderrun:1;	/* Byte 20 Bit 6 */
-	boolean SCAM_Enabled:1;	/* Byte 20 Bit 7 */
-	boolean SCAM_Level2:1;	/* Byte 21 Bit 0 */
+	bool ParityCheckingEnabled:1;	/* Byte 20 Bit 0 */
+	bool HostWideSCSI:1;		/* Byte 20 Bit 1 */
+	bool HostSoftReset:1;		/* Byte 20 Bit 2 */
+	bool ExtendedTranslationEnabled:1;	/* Byte 20 Bit 3 */
+	bool LowByteTerminated:1;	/* Byte 20 Bit 4 */
+	bool HighByteTerminated:1;	/* Byte 20 Bit 5 */
+	bool ReportDataUnderrun:1;	/* Byte 20 Bit 6 */
+	bool SCAM_Enabled:1;	/* Byte 20 Bit 7 */
+	bool SCAM_Level2:1;	/* Byte 21 Bit 0 */
 	unsigned char:7;	/* Byte 21 Bits 1-7 */
 	unsigned char Family;	/* Byte 22 */
 	unsigned char BusType;	/* Byte 23 */
@@ -1044,29 +1038,29 @@ struct BusLogic_HostAdapter {
 	unsigned char IRQ_Channel;
 	unsigned char DMA_Channel;
 	unsigned char SCSI_ID;
-	boolean IRQ_ChannelAcquired:1;
-	boolean DMA_ChannelAcquired:1;
-	boolean ExtendedTranslationEnabled:1;
-	boolean ParityCheckingEnabled:1;
-	boolean BusResetEnabled:1;
-	boolean LevelSensitiveInterrupt:1;
-	boolean HostWideSCSI:1;
-	boolean HostDifferentialSCSI:1;
-	boolean HostSupportsSCAM:1;
-	boolean HostUltraSCSI:1;
-	boolean ExtendedLUNSupport:1;
-	boolean TerminationInfoValid:1;
-	boolean LowByteTerminated:1;
-	boolean HighByteTerminated:1;
-	boolean BounceBuffersRequired:1;
-	boolean StrictRoundRobinModeSupport:1;
-	boolean SCAM_Enabled:1;
-	boolean SCAM_Level2:1;
-	boolean HostAdapterInitialized:1;
-	boolean HostAdapterExternalReset:1;
-	boolean HostAdapterInternalError:1;
-	boolean ProcessCompletedCCBsActive;
-	volatile boolean HostAdapterCommandCompleted;
+	bool IRQ_ChannelAcquired:1;
+	bool DMA_ChannelAcquired:1;
+	bool ExtendedTranslationEnabled:1;
+	bool ParityCheckingEnabled:1;
+	bool BusResetEnabled:1;
+	bool LevelSensitiveInterrupt:1;
+	bool HostWideSCSI:1;
+	bool HostDifferentialSCSI:1;
+	bool HostSupportsSCAM:1;
+	bool HostUltraSCSI:1;
+	bool ExtendedLUNSupport:1;
+	bool TerminationInfoValid:1;
+	bool LowByteTerminated:1;
+	bool HighByteTerminated:1;
+	bool BounceBuffersRequired:1;
+	bool StrictRoundRobinModeSupport:1;
+	bool SCAM_Enabled:1;
+	bool SCAM_Level2:1;
+	bool HostAdapterInitialized:1;
+	bool HostAdapterExternalReset:1;
+	bool HostAdapterInternalError:1;
+	bool ProcessCompletedCCBsActive;
+	volatile bool HostAdapterCommandCompleted;
 	unsigned short HostAdapterScatterGatherLimit;
 	unsigned short DriverScatterGatherLimit;
 	unsigned short MaxTargetDevices;
@@ -1141,25 +1135,25 @@ struct SCSI_Inquiry {
 	unsigned char PeripheralDeviceType:5;	/* Byte 0 Bits 0-4 */
 	unsigned char PeripheralQualifier:3;	/* Byte 0 Bits 5-7 */
 	unsigned char DeviceTypeModifier:7;	/* Byte 1 Bits 0-6 */
-	boolean RMB:1;		/* Byte 1 Bit 7 */
+	bool RMB:1;		/* Byte 1 Bit 7 */
 	unsigned char ANSI_ApprovedVersion:3;	/* Byte 2 Bits 0-2 */
 	unsigned char ECMA_Version:3;	/* Byte 2 Bits 3-5 */
 	unsigned char ISO_Version:2;	/* Byte 2 Bits 6-7 */
 	unsigned char ResponseDataFormat:4;	/* Byte 3 Bits 0-3 */
 	unsigned char:2;	/* Byte 3 Bits 4-5 */
-	boolean TrmIOP:1;	/* Byte 3 Bit 6 */
-	boolean AENC:1;		/* Byte 3 Bit 7 */
+	bool TrmIOP:1;		/* Byte 3 Bit 6 */
+	bool AENC:1;		/* Byte 3 Bit 7 */
 	unsigned char AdditionalLength;	/* Byte 4 */
 	unsigned char:8;	/* Byte 5 */
 	unsigned char:8;	/* Byte 6 */
-	boolean SftRe:1;	/* Byte 7 Bit 0 */
-	boolean CmdQue:1;	/* Byte 7 Bit 1 */
-	 boolean:1;		/* Byte 7 Bit 2 */
-	boolean Linked:1;	/* Byte 7 Bit 3 */
-	boolean Sync:1;		/* Byte 7 Bit 4 */
-	boolean WBus16:1;	/* Byte 7 Bit 5 */
-	boolean WBus32:1;	/* Byte 7 Bit 6 */
-	boolean RelAdr:1;	/* Byte 7 Bit 7 */
+	bool SftRe:1;		/* Byte 7 Bit 0 */
+	bool CmdQue:1;		/* Byte 7 Bit 1 */
+	 bool:1;		/* Byte 7 Bit 2 */
+	bool Linked:1;		/* Byte 7 Bit 3 */
+	bool Sync:1;		/* Byte 7 Bit 4 */
+	bool WBus16:1;		/* Byte 7 Bit 5 */
+	bool WBus32:1;		/* Byte 7 Bit 6 */
+	bool RelAdr:1;		/* Byte 7 Bit 7 */
 	unsigned char VendorIdentification[8];	/* Bytes 8-15 */
 	unsigned char ProductIdentification[16];	/* Bytes 16-31 */
 	unsigned char ProductRevisionLevel[4];	/* Bytes 32-35 */
@@ -1348,7 +1342,7 @@ static int BusLogic_ProcDirectoryInfo(struct Scsi_Host *, char *, char **, off_t
 static int BusLogic_SlaveConfigure(struct scsi_device *);
 static void BusLogic_QueueCompletedCCB(struct BusLogic_CCB *);
 static irqreturn_t BusLogic_InterruptHandler(int, void *);
-static int BusLogic_ResetHostAdapter(struct BusLogic_HostAdapter *, boolean HardReset);
+static int BusLogic_ResetHostAdapter(struct BusLogic_HostAdapter *, bool HardReset);
 static void BusLogic_Message(enum BusLogic_MessageLevel, char *, struct BusLogic_HostAdapter *, ...);
 static int __init BusLogic_Setup(char *);
 

commit 7d12e780e003f93433d49ce78cfedf4b4c52adc5
Author: David Howells <dhowells@redhat.com>
Date:   Thu Oct 5 14:55:46 2006 +0100

    IRQ: Maintain regs pointer globally rather than passing to IRQ handlers
    
    Maintain a per-CPU global "struct pt_regs *" variable which can be used instead
    of passing regs around manually through all ~1800 interrupt handlers in the
    Linux kernel.
    
    The regs pointer is used in few places, but it potentially costs both stack
    space and code to pass it around.  On the FRV arch, removing the regs parameter
    from all the genirq function results in a 20% speed up of the IRQ exit path
    (ie: from leaving timer_interrupt() to leaving do_IRQ()).
    
    Where appropriate, an arch may override the generic storage facility and do
    something different with the variable.  On FRV, for instance, the address is
    maintained in GR28 at all times inside the kernel as part of general exception
    handling.
    
    Having looked over the code, it appears that the parameter may be handed down
    through up to twenty or so layers of functions.  Consider a USB character
    device attached to a USB hub, attached to a USB controller that posts its
    interrupts through a cascaded auxiliary interrupt controller.  A character
    device driver may want to pass regs to the sysrq handler through the input
    layer which adds another few layers of parameter passing.
    
    I've build this code with allyesconfig for x86_64 and i386.  I've runtested the
    main part of the code on FRV and i386, though I can't test most of the drivers.
    I've also done partial conversion for powerpc and MIPS - these at least compile
    with minimal configurations.
    
    This will affect all archs.  Mostly the changes should be relatively easy.
    Take do_IRQ(), store the regs pointer at the beginning, saving the old one:
    
            struct pt_regs *old_regs = set_irq_regs(regs);
    
    And put the old one back at the end:
    
            set_irq_regs(old_regs);
    
    Don't pass regs through to generic_handle_irq() or __do_IRQ().
    
    In timer_interrupt(), this sort of change will be necessary:
    
            -       update_process_times(user_mode(regs));
            -       profile_tick(CPU_PROFILING, regs);
            +       update_process_times(user_mode(get_irq_regs()));
            +       profile_tick(CPU_PROFILING);
    
    I'd like to move update_process_times()'s use of get_irq_regs() into itself,
    except that i386, alone of the archs, uses something other than user_mode().
    
    Some notes on the interrupt handling in the drivers:
    
     (*) input_dev() is now gone entirely.  The regs pointer is no longer stored in
         the input_dev struct.
    
     (*) finish_unlinks() in drivers/usb/host/ohci-q.c needs checking.  It does
         something different depending on whether it's been supplied with a regs
         pointer or not.
    
     (*) Various IRQ handler function pointers have been moved to type
         irq_handler_t.
    
    Signed-Off-By: David Howells <dhowells@redhat.com>
    (cherry picked from 1b16e7ac850969f38b375e511e3fa2f474a33867 commit)

diff --git a/drivers/scsi/BusLogic.h b/drivers/scsi/BusLogic.h
index d6d1d5613c8a..cca6d45eee4d 100644
--- a/drivers/scsi/BusLogic.h
+++ b/drivers/scsi/BusLogic.h
@@ -1347,7 +1347,7 @@ static int BusLogic_BIOSDiskParameters(struct scsi_device *, struct block_device
 static int BusLogic_ProcDirectoryInfo(struct Scsi_Host *, char *, char **, off_t, int, int);
 static int BusLogic_SlaveConfigure(struct scsi_device *);
 static void BusLogic_QueueCompletedCCB(struct BusLogic_CCB *);
-static irqreturn_t BusLogic_InterruptHandler(int, void *, struct pt_regs *);
+static irqreturn_t BusLogic_InterruptHandler(int, void *);
 static int BusLogic_ResetHostAdapter(struct BusLogic_HostAdapter *, boolean HardReset);
 static void BusLogic_Message(enum BusLogic_MessageLevel, char *, struct BusLogic_HostAdapter *, ...);
 static int __init BusLogic_Setup(char *);

commit 6e21828743247270d09a86756a0c11702500dbfb
Author: Richard Knutsson <ricknu-0@student.ltu.se>
Date:   Sat Sep 30 23:27:11 2006 -0700

    [PATCH] Generic boolean
    
    This patch defines:
    * a generic boolean-type, named 'bool'
    * aliases to 0 and 1, named 'false' and 'true'
    
    Removing colliding definitions of 'bool', 'false' and 'true'.
    
    Signed-off-by: Richard Knutsson <ricknu-0@student.ltu.se>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/drivers/scsi/BusLogic.h b/drivers/scsi/BusLogic.h
index 9792e5af5252..d6d1d5613c8a 100644
--- a/drivers/scsi/BusLogic.h
+++ b/drivers/scsi/BusLogic.h
@@ -237,10 +237,7 @@ enum BusLogic_BIOS_DiskGeometryTranslation {
   Define a Boolean data type.
 */
 
-typedef enum {
-	false,
-	true
-} PACKED boolean;
+typedef bool boolean;
 
 /*
   Define a 10^18 Statistics Byte Counter data type.

commit 6ab3d5624e172c553004ecc862bfeac16d9d68b7
Author: Jrn Engel <joern@wohnheim.fh-wedel.de>
Date:   Fri Jun 30 19:25:36 2006 +0200

    Remove obsolete #include <linux/config.h>
    
    Signed-off-by: Jrn Engel <joern@wohnheim.fh-wedel.de>
    Signed-off-by: Adrian Bunk <bunk@stusta.de>

diff --git a/drivers/scsi/BusLogic.h b/drivers/scsi/BusLogic.h
index 1aaa6569edac..9792e5af5252 100644
--- a/drivers/scsi/BusLogic.h
+++ b/drivers/scsi/BusLogic.h
@@ -28,7 +28,6 @@
 #ifndef _BUSLOGIC_H
 #define _BUSLOGIC_H
 
-#include <linux/config.h>
 
 #ifndef PACKED
 #define PACKED __attribute__((packed))

commit 1da177e4c3f41524e886b7f1b8a0c1fc7321cac2
Author: Linus Torvalds <torvalds@ppc970.osdl.org>
Date:   Sat Apr 16 15:20:36 2005 -0700

    Linux-2.6.12-rc2
    
    Initial git repository build. I'm not bothering with the full history,
    even though we have it. We can create a separate "historical" git
    archive of that later if we want to, and in the meantime it's about
    3.2GB when imported into git - space that would just make the early
    git days unnecessarily complicated, when we don't have a lot of good
    infrastructure for it.
    
    Let it rip!

diff --git a/drivers/scsi/BusLogic.h b/drivers/scsi/BusLogic.h
new file mode 100644
index 000000000000..1aaa6569edac
--- /dev/null
+++ b/drivers/scsi/BusLogic.h
@@ -0,0 +1,1359 @@
+/*
+
+  Linux Driver for BusLogic MultiMaster and FlashPoint SCSI Host Adapters
+
+  Copyright 1995-1998 by Leonard N. Zubkoff <lnz@dandelion.com>
+
+  This program is free software; you may redistribute and/or modify it under
+  the terms of the GNU General Public License Version 2 as published by the
+  Free Software Foundation.
+
+  This program is distributed in the hope that it will be useful, but
+  WITHOUT ANY WARRANTY, without even the implied warranty of MERCHANTABILITY
+  or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+  for complete details.
+
+  The author respectfully requests that any modifications to this software be
+  sent directly to him for evaluation and testing.
+
+  Special thanks to Wayne Yen, Jin-Lon Hon, and Alex Win of BusLogic, whose
+  advice has been invaluable, to David Gentzel, for writing the original Linux
+  BusLogic driver, and to Paul Gortmaker, for being such a dedicated test site.
+
+  Finally, special thanks to Mylex/BusLogic for making the FlashPoint SCCB
+  Manager available as freely redistributable source code.
+
+*/
+
+#ifndef _BUSLOGIC_H
+#define _BUSLOGIC_H
+
+#include <linux/config.h>
+
+#ifndef PACKED
+#define PACKED __attribute__((packed))
+#endif
+
+/*
+  FlashPoint support is only available for the Intel x86 Architecture with
+  CONFIG_PCI set.
+*/
+
+#ifndef __i386__
+#undef CONFIG_SCSI_OMIT_FLASHPOINT
+#define CONFIG_SCSI_OMIT_FLASHPOINT
+#endif
+
+#ifndef CONFIG_PCI
+#undef CONFIG_SCSI_OMIT_FLASHPOINT
+#define CONFIG_SCSI_OMIT_FLASHPOINT
+#define BusLogic_InitializeProbeInfoListISA BusLogic_InitializeProbeInfoList
+#endif
+
+
+/*
+  Define the maximum number of BusLogic Host Adapters supported by this driver.
+*/
+
+#define BusLogic_MaxHostAdapters		16
+
+
+/*
+  Define the maximum number of Target Devices supported by this driver.
+*/
+
+#define BusLogic_MaxTargetDevices		16
+
+
+/*
+  Define the maximum number of Scatter/Gather Segments used by this driver.
+  For optimal performance, it is important that this limit be at least as
+  large as the largest single request generated by the I/O Subsystem.
+*/
+
+#define BusLogic_ScatterGatherLimit		128
+
+
+/*
+  Define the maximum, maximum automatic, minimum automatic, and default Queue
+  Depth to allow for Target Devices depending on whether or not they support
+  Tagged Queuing and whether or not ISA Bounce Buffers are required.
+*/
+
+#define BusLogic_MaxTaggedQueueDepth		64
+#define BusLogic_MaxAutomaticTaggedQueueDepth	28
+#define BusLogic_MinAutomaticTaggedQueueDepth	7
+#define BusLogic_TaggedQueueDepthBB		3
+#define BusLogic_UntaggedQueueDepth		3
+#define BusLogic_UntaggedQueueDepthBB		2
+
+
+/*
+  Define the default amount of time in seconds to wait between a Host Adapter
+  Hard Reset which initiates a SCSI Bus Reset and issuing any SCSI commands.
+  Some SCSI devices get confused if they receive SCSI commands too soon after
+  a SCSI Bus Reset.
+*/
+
+#define BusLogic_DefaultBusSettleTime		2
+
+
+/*
+  Define the maximum number of Mailboxes that should be used for MultiMaster
+  Host Adapters.  This number is chosen to be larger than the maximum Host
+  Adapter Queue Depth and small enough so that the Host Adapter structure
+  does not cross an allocation block size boundary.
+*/
+
+#define BusLogic_MaxMailboxes			211
+
+
+/*
+  Define the number of CCBs that should be allocated as a group to optimize
+  Kernel memory allocation.
+*/
+
+#define BusLogic_CCB_AllocationGroupSize	7
+
+
+/*
+  Define the Host Adapter Line and Message Buffer Sizes.
+*/
+
+#define BusLogic_LineBufferSize			100
+#define BusLogic_MessageBufferSize		9700
+
+
+/*
+  Define the Driver Message Levels.
+*/
+
+enum BusLogic_MessageLevel {
+	BusLogic_AnnounceLevel = 0,
+	BusLogic_InfoLevel = 1,
+	BusLogic_NoticeLevel = 2,
+	BusLogic_WarningLevel = 3,
+	BusLogic_ErrorLevel = 4
+};
+
+static char *BusLogic_MessageLevelMap[] = { KERN_NOTICE, KERN_NOTICE, KERN_NOTICE, KERN_WARNING, KERN_ERR };
+
+
+/*
+  Define Driver Message macros.
+*/
+
+#define BusLogic_Announce(Format, Arguments...) \
+  BusLogic_Message(BusLogic_AnnounceLevel, Format, ##Arguments)
+
+#define BusLogic_Info(Format, Arguments...) \
+  BusLogic_Message(BusLogic_InfoLevel, Format, ##Arguments)
+
+#define BusLogic_Notice(Format, Arguments...) \
+  BusLogic_Message(BusLogic_NoticeLevel, Format, ##Arguments)
+
+#define BusLogic_Warning(Format, Arguments...) \
+  BusLogic_Message(BusLogic_WarningLevel, Format, ##Arguments)
+
+#define BusLogic_Error(Format, Arguments...) \
+  BusLogic_Message(BusLogic_ErrorLevel, Format, ##Arguments)
+
+
+/*
+  Define the types of BusLogic Host Adapters that are supported and the number
+  of I/O Addresses required by each type.
+*/
+
+enum BusLogic_HostAdapterType {
+	BusLogic_MultiMaster = 1,
+	BusLogic_FlashPoint = 2
+} PACKED;
+
+#define BusLogic_MultiMasterAddressCount	4
+#define BusLogic_FlashPointAddressCount		256
+
+static int BusLogic_HostAdapterAddressCount[3] = { 0, BusLogic_MultiMasterAddressCount, BusLogic_FlashPointAddressCount };
+
+
+/*
+  Define macros for testing the Host Adapter Type.
+*/
+
+#ifndef CONFIG_SCSI_OMIT_FLASHPOINT
+
+#define BusLogic_MultiMasterHostAdapterP(HostAdapter) \
+  (HostAdapter->HostAdapterType == BusLogic_MultiMaster)
+
+#define BusLogic_FlashPointHostAdapterP(HostAdapter) \
+  (HostAdapter->HostAdapterType == BusLogic_FlashPoint)
+
+#else
+
+#define BusLogic_MultiMasterHostAdapterP(HostAdapter) \
+  (true)
+
+#define BusLogic_FlashPointHostAdapterP(HostAdapter) \
+  (false)
+
+#endif
+
+
+/*
+  Define the possible Host Adapter Bus Types.
+*/
+
+enum BusLogic_HostAdapterBusType {
+	BusLogic_Unknown_Bus = 0,
+	BusLogic_ISA_Bus = 1,
+	BusLogic_EISA_Bus = 2,
+	BusLogic_PCI_Bus = 3,
+	BusLogic_VESA_Bus = 4,
+	BusLogic_MCA_Bus = 5
+} PACKED;
+
+static char *BusLogic_HostAdapterBusNames[] = { "Unknown", "ISA", "EISA", "PCI", "VESA", "MCA" };
+
+static enum BusLogic_HostAdapterBusType BusLogic_HostAdapterBusTypes[] = {
+	BusLogic_VESA_Bus,	/* BT-4xx */
+	BusLogic_ISA_Bus,	/* BT-5xx */
+	BusLogic_MCA_Bus,	/* BT-6xx */
+	BusLogic_EISA_Bus,	/* BT-7xx */
+	BusLogic_Unknown_Bus,	/* BT-8xx */
+	BusLogic_PCI_Bus	/* BT-9xx */
+};
+
+/*
+  Define the possible Host Adapter BIOS Disk Geometry Translations.
+*/
+
+enum BusLogic_BIOS_DiskGeometryTranslation {
+	BusLogic_BIOS_Disk_Not_Installed = 0,
+	BusLogic_BIOS_Disk_Installed_64x32 = 1,
+	BusLogic_BIOS_Disk_Installed_128x32 = 2,
+	BusLogic_BIOS_Disk_Installed_255x63 = 3
+} PACKED;
+
+
+/*
+  Define a Boolean data type.
+*/
+
+typedef enum {
+	false,
+	true
+} PACKED boolean;
+
+/*
+  Define a 10^18 Statistics Byte Counter data type.
+*/
+
+struct BusLogic_ByteCounter {
+	unsigned int Units;
+	unsigned int Billions;
+};
+
+
+/*
+  Define the structure for I/O Address and Bus Probing Information.
+*/
+
+struct BusLogic_ProbeInfo {
+	enum BusLogic_HostAdapterType HostAdapterType;
+	enum BusLogic_HostAdapterBusType HostAdapterBusType;
+	unsigned long IO_Address;
+	unsigned long PCI_Address;
+	struct pci_dev *PCI_Device;
+	unsigned char Bus;
+	unsigned char Device;
+	unsigned char IRQ_Channel;
+};
+
+/*
+  Define the Probe Options.
+*/
+
+struct BusLogic_ProbeOptions {
+	boolean NoProbe:1;	/* Bit 0 */
+	boolean NoProbeISA:1;	/* Bit 1 */
+	boolean NoProbePCI:1;	/* Bit 2 */
+	boolean NoSortPCI:1;	/* Bit 3 */
+	boolean MultiMasterFirst:1;	/* Bit 4 */
+	boolean FlashPointFirst:1;	/* Bit 5 */
+	boolean LimitedProbeISA:1;	/* Bit 6 */
+	boolean Probe330:1;	/* Bit 7 */
+	boolean Probe334:1;	/* Bit 8 */
+	boolean Probe230:1;	/* Bit 9 */
+	boolean Probe234:1;	/* Bit 10 */
+	boolean Probe130:1;	/* Bit 11 */
+	boolean Probe134:1;	/* Bit 12 */
+};
+
+/*
+  Define the Global Options.
+*/
+
+struct BusLogic_GlobalOptions {
+	boolean TraceProbe:1;	/* Bit 0 */
+	boolean TraceHardwareReset:1;	/* Bit 1 */
+	boolean TraceConfiguration:1;	/* Bit 2 */
+	boolean TraceErrors:1;	/* Bit 3 */
+};
+
+/*
+  Define the Local Options.
+*/
+
+struct BusLogic_LocalOptions {
+	boolean InhibitTargetInquiry:1;	/* Bit 0 */
+};
+
+/*
+  Define the BusLogic SCSI Host Adapter I/O Register Offsets.
+*/
+
+#define BusLogic_ControlRegisterOffset		0	/* WO register */
+#define BusLogic_StatusRegisterOffset		0	/* RO register */
+#define BusLogic_CommandParameterRegisterOffset	1	/* WO register */
+#define BusLogic_DataInRegisterOffset		1	/* RO register */
+#define BusLogic_InterruptRegisterOffset	2	/* RO register */
+#define BusLogic_GeometryRegisterOffset		3	/* RO register */
+
+/*
+  Define the structure of the write-only Control Register.
+*/
+
+union BusLogic_ControlRegister {
+	unsigned char All;
+	struct {
+		unsigned char:4;	/* Bits 0-3 */
+		boolean SCSIBusReset:1;	/* Bit 4 */
+		boolean InterruptReset:1;	/* Bit 5 */
+		boolean SoftReset:1;	/* Bit 6 */
+		boolean HardReset:1;	/* Bit 7 */
+	} cr;
+};
+
+/*
+  Define the structure of the read-only Status Register.
+*/
+
+union BusLogic_StatusRegister {
+	unsigned char All;
+	struct {
+		boolean CommandInvalid:1;	/* Bit 0 */
+		boolean Reserved:1;	/* Bit 1 */
+		boolean DataInRegisterReady:1;	/* Bit 2 */
+		boolean CommandParameterRegisterBusy:1;	/* Bit 3 */
+		boolean HostAdapterReady:1;	/* Bit 4 */
+		boolean InitializationRequired:1;	/* Bit 5 */
+		boolean DiagnosticFailure:1;	/* Bit 6 */
+		boolean DiagnosticActive:1;	/* Bit 7 */
+	} sr;
+};
+
+/*
+  Define the structure of the read-only Interrupt Register.
+*/
+
+union BusLogic_InterruptRegister {
+	unsigned char All;
+	struct {
+		boolean IncomingMailboxLoaded:1;	/* Bit 0 */
+		boolean OutgoingMailboxAvailable:1;	/* Bit 1 */
+		boolean CommandComplete:1;	/* Bit 2 */
+		boolean ExternalBusReset:1;	/* Bit 3 */
+		unsigned char Reserved:3;	/* Bits 4-6 */
+		boolean InterruptValid:1;	/* Bit 7 */
+	} ir;
+};
+
+/*
+  Define the structure of the read-only Geometry Register.
+*/
+
+union BusLogic_GeometryRegister {
+	unsigned char All;
+	struct {
+		enum BusLogic_BIOS_DiskGeometryTranslation Drive0Geometry:2;	/* Bits 0-1 */
+		enum BusLogic_BIOS_DiskGeometryTranslation Drive1Geometry:2;	/* Bits 2-3 */
+		unsigned char:3;	/* Bits 4-6 */
+		boolean ExtendedTranslationEnabled:1;	/* Bit 7 */
+	} gr;
+};
+
+/*
+  Define the BusLogic SCSI Host Adapter Command Register Operation Codes.
+*/
+
+enum BusLogic_OperationCode {
+	BusLogic_TestCommandCompleteInterrupt = 0x00,
+	BusLogic_InitializeMailbox = 0x01,
+	BusLogic_ExecuteMailboxCommand = 0x02,
+	BusLogic_ExecuteBIOSCommand = 0x03,
+	BusLogic_InquireBoardID = 0x04,
+	BusLogic_EnableOutgoingMailboxAvailableInt = 0x05,
+	BusLogic_SetSCSISelectionTimeout = 0x06,
+	BusLogic_SetPreemptTimeOnBus = 0x07,
+	BusLogic_SetTimeOffBus = 0x08,
+	BusLogic_SetBusTransferRate = 0x09,
+	BusLogic_InquireInstalledDevicesID0to7 = 0x0A,
+	BusLogic_InquireConfiguration = 0x0B,
+	BusLogic_EnableTargetMode = 0x0C,
+	BusLogic_InquireSetupInformation = 0x0D,
+	BusLogic_WriteAdapterLocalRAM = 0x1A,
+	BusLogic_ReadAdapterLocalRAM = 0x1B,
+	BusLogic_WriteBusMasterChipFIFO = 0x1C,
+	BusLogic_ReadBusMasterChipFIFO = 0x1D,
+	BusLogic_EchoCommandData = 0x1F,
+	BusLogic_HostAdapterDiagnostic = 0x20,
+	BusLogic_SetAdapterOptions = 0x21,
+	BusLogic_InquireInstalledDevicesID8to15 = 0x23,
+	BusLogic_InquireTargetDevices = 0x24,
+	BusLogic_DisableHostAdapterInterrupt = 0x25,
+	BusLogic_InitializeExtendedMailbox = 0x81,
+	BusLogic_ExecuteSCSICommand = 0x83,
+	BusLogic_InquireFirmwareVersion3rdDigit = 0x84,
+	BusLogic_InquireFirmwareVersionLetter = 0x85,
+	BusLogic_InquirePCIHostAdapterInformation = 0x86,
+	BusLogic_InquireHostAdapterModelNumber = 0x8B,
+	BusLogic_InquireSynchronousPeriod = 0x8C,
+	BusLogic_InquireExtendedSetupInformation = 0x8D,
+	BusLogic_EnableStrictRoundRobinMode = 0x8F,
+	BusLogic_StoreHostAdapterLocalRAM = 0x90,
+	BusLogic_FetchHostAdapterLocalRAM = 0x91,
+	BusLogic_StoreLocalDataInEEPROM = 0x92,
+	BusLogic_UploadAutoSCSICode = 0x94,
+	BusLogic_ModifyIOAddress = 0x95,
+	BusLogic_SetCCBFormat = 0x96,
+	BusLogic_WriteInquiryBuffer = 0x9A,
+	BusLogic_ReadInquiryBuffer = 0x9B,
+	BusLogic_FlashROMUploadDownload = 0xA7,
+	BusLogic_ReadSCAMData = 0xA8,
+	BusLogic_WriteSCAMData = 0xA9
+};
+
+/*
+  Define the Inquire Board ID reply structure.
+*/
+
+struct BusLogic_BoardID {
+	unsigned char BoardType;	/* Byte 0 */
+	unsigned char CustomFeatures;	/* Byte 1 */
+	unsigned char FirmwareVersion1stDigit;	/* Byte 2 */
+	unsigned char FirmwareVersion2ndDigit;	/* Byte 3 */
+};
+
+/*
+  Define the Inquire Configuration reply structure.
+*/
+
+struct BusLogic_Configuration {
+	unsigned char:5;	/* Byte 0 Bits 0-4 */
+	boolean DMA_Channel5:1;	/* Byte 0 Bit 5 */
+	boolean DMA_Channel6:1;	/* Byte 0 Bit 6 */
+	boolean DMA_Channel7:1;	/* Byte 0 Bit 7 */
+	boolean IRQ_Channel9:1;	/* Byte 1 Bit 0 */
+	boolean IRQ_Channel10:1;	/* Byte 1 Bit 1 */
+	boolean IRQ_Channel11:1;	/* Byte 1 Bit 2 */
+	boolean IRQ_Channel12:1;	/* Byte 1 Bit 3 */
+	unsigned char:1;	/* Byte 1 Bit 4 */
+	boolean IRQ_Channel14:1;	/* Byte 1 Bit 5 */
+	boolean IRQ_Channel15:1;	/* Byte 1 Bit 6 */
+	unsigned char:1;	/* Byte 1 Bit 7 */
+	unsigned char HostAdapterID:4;	/* Byte 2 Bits 0-3 */
+	unsigned char:4;	/* Byte 2 Bits 4-7 */
+};
+
+/*
+  Define the Inquire Setup Information reply structure.
+*/
+
+struct BusLogic_SynchronousValue {
+	unsigned char Offset:4;	/* Bits 0-3 */
+	unsigned char TransferPeriod:3;	/* Bits 4-6 */
+	boolean Synchronous:1;	/* Bit 7 */
+};
+
+struct BusLogic_SetupInformation {
+	boolean SynchronousInitiationEnabled:1;	/* Byte 0 Bit 0 */
+	boolean ParityCheckingEnabled:1;	/* Byte 0 Bit 1 */
+	unsigned char:6;	/* Byte 0 Bits 2-7 */
+	unsigned char BusTransferRate;	/* Byte 1 */
+	unsigned char PreemptTimeOnBus;	/* Byte 2 */
+	unsigned char TimeOffBus;	/* Byte 3 */
+	unsigned char MailboxCount;	/* Byte 4 */
+	unsigned char MailboxAddress[3];	/* Bytes 5-7 */
+	struct BusLogic_SynchronousValue SynchronousValuesID0to7[8];	/* Bytes 8-15 */
+	unsigned char DisconnectPermittedID0to7;	/* Byte 16 */
+	unsigned char Signature;	/* Byte 17 */
+	unsigned char CharacterD;	/* Byte 18 */
+	unsigned char HostBusType;	/* Byte 19 */
+	unsigned char WideTransfersPermittedID0to7;	/* Byte 20 */
+	unsigned char WideTransfersActiveID0to7;	/* Byte 21 */
+	struct BusLogic_SynchronousValue SynchronousValuesID8to15[8];	/* Bytes 22-29 */
+	unsigned char DisconnectPermittedID8to15;	/* Byte 30 */
+	unsigned char:8;	/* Byte 31 */
+	unsigned char WideTransfersPermittedID8to15;	/* Byte 32 */
+	unsigned char WideTransfersActiveID8to15;	/* Byte 33 */
+};
+
+/*
+  Define the Initialize Extended Mailbox request structure.
+*/
+
+struct BusLogic_ExtendedMailboxRequest {
+	unsigned char MailboxCount;	/* Byte 0 */
+	u32 BaseMailboxAddress;	/* Bytes 1-4 */
+} PACKED;
+
+
+/*
+  Define the Inquire PCI Host Adapter Information reply type.  The ISA
+  Compatible I/O Port values are defined here and are also used with
+  the Modify I/O Address command.
+*/
+
+enum BusLogic_ISACompatibleIOPort {
+	BusLogic_IO_330 = 0,
+	BusLogic_IO_334 = 1,
+	BusLogic_IO_230 = 2,
+	BusLogic_IO_234 = 3,
+	BusLogic_IO_130 = 4,
+	BusLogic_IO_134 = 5,
+	BusLogic_IO_Disable = 6,
+	BusLogic_IO_Disable2 = 7
+} PACKED;
+
+struct BusLogic_PCIHostAdapterInformation {
+	enum BusLogic_ISACompatibleIOPort ISACompatibleIOPort;	/* Byte 0 */
+	unsigned char PCIAssignedIRQChannel;	/* Byte 1 */
+	boolean LowByteTerminated:1;	/* Byte 2 Bit 0 */
+	boolean HighByteTerminated:1;	/* Byte 2 Bit 1 */
+	unsigned char:2;	/* Byte 2 Bits 2-3 */
+	boolean JP1:1;		/* Byte 2 Bit 4 */
+	boolean JP2:1;		/* Byte 2 Bit 5 */
+	boolean JP3:1;		/* Byte 2 Bit 6 */
+	boolean GenericInfoValid:1;	/* Byte 2 Bit 7 */
+	unsigned char:8;	/* Byte 3 */
+};
+
+/*
+  Define the Inquire Extended Setup Information reply structure.
+*/
+
+struct BusLogic_ExtendedSetupInformation {
+	unsigned char BusType;	/* Byte 0 */
+	unsigned char BIOS_Address;	/* Byte 1 */
+	unsigned short ScatterGatherLimit;	/* Bytes 2-3 */
+	unsigned char MailboxCount;	/* Byte 4 */
+	u32 BaseMailboxAddress;	/* Bytes 5-8 */
+	struct {
+		unsigned char:2;	/* Byte 9 Bits 0-1 */
+		boolean FastOnEISA:1;	/* Byte 9 Bit 2 */
+		unsigned char:3;	/* Byte 9 Bits 3-5 */
+		boolean LevelSensitiveInterrupt:1;	/* Byte 9 Bit 6 */
+		unsigned char:1;	/* Byte 9 Bit 7 */
+	} Misc;
+	unsigned char FirmwareRevision[3];	/* Bytes 10-12 */
+	boolean HostWideSCSI:1;	/* Byte 13 Bit 0 */
+	boolean HostDifferentialSCSI:1;	/* Byte 13 Bit 1 */
+	boolean HostSupportsSCAM:1;	/* Byte 13 Bit 2 */
+	boolean HostUltraSCSI:1;	/* Byte 13 Bit 3 */
+	boolean HostSmartTermination:1;	/* Byte 13 Bit 4 */
+	unsigned char:3;	/* Byte 13 Bits 5-7 */
+} PACKED;
+
+/*
+  Define the Enable Strict Round Robin Mode request type.
+*/
+
+enum BusLogic_RoundRobinModeRequest {
+	BusLogic_AggressiveRoundRobinMode = 0,
+	BusLogic_StrictRoundRobinMode = 1
+} PACKED;
+
+
+/*
+  Define the Fetch Host Adapter Local RAM request type.
+*/
+
+#define BusLogic_BIOS_BaseOffset		0
+#define BusLogic_AutoSCSI_BaseOffset		64
+
+struct BusLogic_FetchHostAdapterLocalRAMRequest {
+	unsigned char ByteOffset;	/* Byte 0 */
+	unsigned char ByteCount;	/* Byte 1 */
+};
+
+/*
+  Define the Host Adapter Local RAM AutoSCSI structure.
+*/
+
+struct BusLogic_AutoSCSIData {
+	unsigned char InternalFactorySignature[2];	/* Bytes 0-1 */
+	unsigned char InformationByteCount;	/* Byte 2 */
+	unsigned char HostAdapterType[6];	/* Bytes 3-8 */
+	unsigned char:8;	/* Byte 9 */
+	boolean FloppyEnabled:1;	/* Byte 10 Bit 0 */
+	boolean FloppySecondary:1;	/* Byte 10 Bit 1 */
+	boolean LevelSensitiveInterrupt:1;	/* Byte 10 Bit 2 */
+	unsigned char:2;	/* Byte 10 Bits 3-4 */
+	unsigned char SystemRAMAreaForBIOS:3;	/* Byte 10 Bits 5-7 */
+	unsigned char DMA_Channel:7;	/* Byte 11 Bits 0-6 */
+	boolean DMA_AutoConfiguration:1;	/* Byte 11 Bit 7 */
+	unsigned char IRQ_Channel:7;	/* Byte 12 Bits 0-6 */
+	boolean IRQ_AutoConfiguration:1;	/* Byte 12 Bit 7 */
+	unsigned char DMA_TransferRate;	/* Byte 13 */
+	unsigned char SCSI_ID;	/* Byte 14 */
+	boolean LowByteTerminated:1;	/* Byte 15 Bit 0 */
+	boolean ParityCheckingEnabled:1;	/* Byte 15 Bit 1 */
+	boolean HighByteTerminated:1;	/* Byte 15 Bit 2 */
+	boolean NoisyCablingEnvironment:1;	/* Byte 15 Bit 3 */
+	boolean FastSynchronousNegotiation:1;	/* Byte 15 Bit 4 */
+	boolean BusResetEnabled:1;	/* Byte 15 Bit 5 */
+	 boolean:1;		/* Byte 15 Bit 6 */
+	boolean ActiveNegationEnabled:1;	/* Byte 15 Bit 7 */
+	unsigned char BusOnDelay;	/* Byte 16 */
+	unsigned char BusOffDelay;	/* Byte 17 */
+	boolean HostAdapterBIOSEnabled:1;	/* Byte 18 Bit 0 */
+	boolean BIOSRedirectionOfINT19Enabled:1;	/* Byte 18 Bit 1 */
+	boolean ExtendedTranslationEnabled:1;	/* Byte 18 Bit 2 */
+	boolean MapRemovableAsFixedEnabled:1;	/* Byte 18 Bit 3 */
+	 boolean:1;		/* Byte 18 Bit 4 */
+	boolean BIOSSupportsMoreThan2DrivesEnabled:1;	/* Byte 18 Bit 5 */
+	boolean BIOSInterruptModeEnabled:1;	/* Byte 18 Bit 6 */
+	boolean FlopticalSupportEnabled:1;	/* Byte 19 Bit 7 */
+	unsigned short DeviceEnabled;	/* Bytes 19-20 */
+	unsigned short WidePermitted;	/* Bytes 21-22 */
+	unsigned short FastPermitted;	/* Bytes 23-24 */
+	unsigned short SynchronousPermitted;	/* Bytes 25-26 */
+	unsigned short DisconnectPermitted;	/* Bytes 27-28 */
+	unsigned short SendStartUnitCommand;	/* Bytes 29-30 */
+	unsigned short IgnoreInBIOSScan;	/* Bytes 31-32 */
+	unsigned char PCIInterruptPin:2;	/* Byte 33 Bits 0-1 */
+	unsigned char HostAdapterIOPortAddress:2;	/* Byte 33 Bits 2-3 */
+	boolean StrictRoundRobinModeEnabled:1;	/* Byte 33 Bit 4 */
+	boolean VESABusSpeedGreaterThan33MHz:1;	/* Byte 33 Bit 5 */
+	boolean VESABurstWriteEnabled:1;	/* Byte 33 Bit 6 */
+	boolean VESABurstReadEnabled:1;	/* Byte 33 Bit 7 */
+	unsigned short UltraPermitted;	/* Bytes 34-35 */
+	unsigned int:32;	/* Bytes 36-39 */
+	unsigned char:8;	/* Byte 40 */
+	unsigned char AutoSCSIMaximumLUN;	/* Byte 41 */
+	 boolean:1;		/* Byte 42 Bit 0 */
+	boolean SCAM_Dominant:1;	/* Byte 42 Bit 1 */
+	boolean SCAM_Enabled:1;	/* Byte 42 Bit 2 */
+	boolean SCAM_Level2:1;	/* Byte 42 Bit 3 */
+	unsigned char:4;	/* Byte 42 Bits 4-7 */
+	boolean INT13ExtensionEnabled:1;	/* Byte 43 Bit 0 */
+	 boolean:1;		/* Byte 43 Bit 1 */
+	boolean CDROMBootEnabled:1;	/* Byte 43 Bit 2 */
+	unsigned char:5;	/* Byte 43 Bits 3-7 */
+	unsigned char BootTargetID:4;	/* Byte 44 Bits 0-3 */
+	unsigned char BootChannel:4;	/* Byte 44 Bits 4-7 */
+	unsigned char ForceBusDeviceScanningOrder:1;	/* Byte 45 Bit 0 */
+	unsigned char:7;	/* Byte 45 Bits 1-7 */
+	unsigned short NonTaggedToAlternateLUNPermitted;	/* Bytes 46-47 */
+	unsigned short RenegotiateSyncAfterCheckCondition;	/* Bytes 48-49 */
+	unsigned char Reserved[10];	/* Bytes 50-59 */
+	unsigned char ManufacturingDiagnostic[2];	/* Bytes 60-61 */
+	unsigned short Checksum;	/* Bytes 62-63 */
+} PACKED;
+
+/*
+  Define the Host Adapter Local RAM Auto SCSI Byte 45 structure.
+*/
+
+struct BusLogic_AutoSCSIByte45 {
+	unsigned char ForceBusDeviceScanningOrder:1;	/* Bit 0 */
+	unsigned char:7;	/* Bits 1-7 */
+};
+
+/*
+  Define the Host Adapter Local RAM BIOS Drive Map Byte structure.
+*/
+
+#define BusLogic_BIOS_DriveMapOffset		17
+
+struct BusLogic_BIOSDriveMapByte {
+	unsigned char TargetIDBit3:1;	/* Bit 0 */
+	unsigned char:2;	/* Bits 1-2 */
+	enum BusLogic_BIOS_DiskGeometryTranslation DiskGeometry:2;	/* Bits 3-4 */
+	unsigned char TargetID:3;	/* Bits 5-7 */
+};
+
+/*
+  Define the Set CCB Format request type.  Extended LUN Format CCBs are
+  necessary to support more than 8 Logical Units per Target Device.
+*/
+
+enum BusLogic_SetCCBFormatRequest {
+	BusLogic_LegacyLUNFormatCCB = 0,
+	BusLogic_ExtendedLUNFormatCCB = 1
+} PACKED;
+
+/*
+  Define the Outgoing Mailbox Action Codes.
+*/
+
+enum BusLogic_ActionCode {
+	BusLogic_OutgoingMailboxFree = 0x00,
+	BusLogic_MailboxStartCommand = 0x01,
+	BusLogic_MailboxAbortCommand = 0x02
+} PACKED;
+
+
+/*
+  Define the Incoming Mailbox Completion Codes.  The MultiMaster Firmware
+  only uses codes 0 - 4.  The FlashPoint SCCB Manager has no mailboxes, so
+  completion codes are stored in the CCB; it only uses codes 1, 2, 4, and 5.
+*/
+
+enum BusLogic_CompletionCode {
+	BusLogic_IncomingMailboxFree = 0x00,
+	BusLogic_CommandCompletedWithoutError = 0x01,
+	BusLogic_CommandAbortedAtHostRequest = 0x02,
+	BusLogic_AbortedCommandNotFound = 0x03,
+	BusLogic_CommandCompletedWithError = 0x04,
+	BusLogic_InvalidCCB = 0x05
+} PACKED;
+
+/*
+  Define the Command Control Block (CCB) Opcodes.
+*/
+
+enum BusLogic_CCB_Opcode {
+	BusLogic_InitiatorCCB = 0x00,
+	BusLogic_TargetCCB = 0x01,
+	BusLogic_InitiatorCCB_ScatterGather = 0x02,
+	BusLogic_InitiatorCCB_ResidualDataLength = 0x03,
+	BusLogic_InitiatorCCB_ScatterGatherResidual = 0x04,
+	BusLogic_BusDeviceReset = 0x81
+} PACKED;
+
+
+/*
+  Define the CCB Data Direction Codes.
+*/
+
+enum BusLogic_DataDirection {
+	BusLogic_UncheckedDataTransfer = 0,
+	BusLogic_DataInLengthChecked = 1,
+	BusLogic_DataOutLengthChecked = 2,
+	BusLogic_NoDataTransfer = 3
+};
+
+
+/*
+  Define the Host Adapter Status Codes.  The MultiMaster Firmware does not
+  return status code 0x0C; it uses 0x12 for both overruns and underruns.
+*/
+
+enum BusLogic_HostAdapterStatus {
+	BusLogic_CommandCompletedNormally = 0x00,
+	BusLogic_LinkedCommandCompleted = 0x0A,
+	BusLogic_LinkedCommandCompletedWithFlag = 0x0B,
+	BusLogic_DataUnderRun = 0x0C,
+	BusLogic_SCSISelectionTimeout = 0x11,
+	BusLogic_DataOverRun = 0x12,
+	BusLogic_UnexpectedBusFree = 0x13,
+	BusLogic_InvalidBusPhaseRequested = 0x14,
+	BusLogic_InvalidOutgoingMailboxActionCode = 0x15,
+	BusLogic_InvalidCommandOperationCode = 0x16,
+	BusLogic_LinkedCCBhasInvalidLUN = 0x17,
+	BusLogic_InvalidCommandParameter = 0x1A,
+	BusLogic_AutoRequestSenseFailed = 0x1B,
+	BusLogic_TaggedQueuingMessageRejected = 0x1C,
+	BusLogic_UnsupportedMessageReceived = 0x1D,
+	BusLogic_HostAdapterHardwareFailed = 0x20,
+	BusLogic_TargetFailedResponseToATN = 0x21,
+	BusLogic_HostAdapterAssertedRST = 0x22,
+	BusLogic_OtherDeviceAssertedRST = 0x23,
+	BusLogic_TargetDeviceReconnectedImproperly = 0x24,
+	BusLogic_HostAdapterAssertedBusDeviceReset = 0x25,
+	BusLogic_AbortQueueGenerated = 0x26,
+	BusLogic_HostAdapterSoftwareError = 0x27,
+	BusLogic_HostAdapterHardwareTimeoutError = 0x30,
+	BusLogic_SCSIParityErrorDetected = 0x34
+} PACKED;
+
+
+/*
+  Define the SCSI Target Device Status Codes.
+*/
+
+enum BusLogic_TargetDeviceStatus {
+	BusLogic_OperationGood = 0x00,
+	BusLogic_CheckCondition = 0x02,
+	BusLogic_DeviceBusy = 0x08
+} PACKED;
+
+/*
+  Define the Queue Tag Codes.
+*/
+
+enum BusLogic_QueueTag {
+	BusLogic_SimpleQueueTag = 0,
+	BusLogic_HeadOfQueueTag = 1,
+	BusLogic_OrderedQueueTag = 2,
+	BusLogic_ReservedQT = 3
+};
+
+/*
+  Define the SCSI Command Descriptor Block (CDB).
+*/
+
+#define BusLogic_CDB_MaxLength			12
+
+typedef unsigned char SCSI_CDB_T[BusLogic_CDB_MaxLength];
+
+
+/*
+  Define the Scatter/Gather Segment structure required by the MultiMaster
+  Firmware Interface and the FlashPoint SCCB Manager.
+*/
+
+struct BusLogic_ScatterGatherSegment {
+	u32 SegmentByteCount;	/* Bytes 0-3 */
+	u32 SegmentDataPointer;	/* Bytes 4-7 */
+};
+
+/*
+  Define the Driver CCB Status Codes.
+*/
+
+enum BusLogic_CCB_Status {
+	BusLogic_CCB_Free = 0,
+	BusLogic_CCB_Active = 1,
+	BusLogic_CCB_Completed = 2,
+	BusLogic_CCB_Reset = 3
+} PACKED;
+
+
+/*
+  Define the 32 Bit Mode Command Control Block (CCB) structure.  The first 40
+  bytes are defined by and common to both the MultiMaster Firmware and the
+  FlashPoint SCCB Manager.  The next 60 bytes are defined by the FlashPoint
+  SCCB Manager.  The remaining components are defined by the Linux BusLogic
+  Driver.  Extended LUN Format CCBs differ from Legacy LUN Format 32 Bit Mode
+  CCBs only in having the TagEnable and QueueTag fields moved from byte 17 to
+  byte 1, and the Logical Unit field in byte 17 expanded to 6 bits.  In theory,
+  Extended LUN Format CCBs can support up to 64 Logical Units, but in practice
+  many devices will respond improperly to Logical Units between 32 and 63, and
+  the SCSI-2 specification defines Bit 5 as LUNTAR.  Extended LUN Format CCBs
+  are used by recent versions of the MultiMaster Firmware, as well as by the
+  FlashPoint SCCB Manager; the FlashPoint SCCB Manager only supports 32 Logical
+  Units.  Since 64 Logical Units are unlikely to be needed in practice, and
+  since they are problematic for the above reasons, and since limiting them to
+  5 bits simplifies the CCB structure definition, this driver only supports
+  32 Logical Units per Target Device.
+*/
+
+struct BusLogic_CCB {
+	/*
+	   MultiMaster Firmware and FlashPoint SCCB Manager Common Portion.
+	 */
+	enum BusLogic_CCB_Opcode Opcode;	/* Byte 0 */
+	unsigned char:3;	/* Byte 1 Bits 0-2 */
+	enum BusLogic_DataDirection DataDirection:2;	/* Byte 1 Bits 3-4 */
+	boolean TagEnable:1;	/* Byte 1 Bit 5 */
+	enum BusLogic_QueueTag QueueTag:2;	/* Byte 1 Bits 6-7 */
+	unsigned char CDB_Length;	/* Byte 2 */
+	unsigned char SenseDataLength;	/* Byte 3 */
+	u32 DataLength;		/* Bytes 4-7 */
+	u32 DataPointer;	/* Bytes 8-11 */
+	unsigned char:8;	/* Byte 12 */
+	unsigned char:8;	/* Byte 13 */
+	enum BusLogic_HostAdapterStatus HostAdapterStatus;	/* Byte 14 */
+	enum BusLogic_TargetDeviceStatus TargetDeviceStatus;	/* Byte 15 */
+	unsigned char TargetID;	/* Byte 16 */
+	unsigned char LogicalUnit:5;	/* Byte 17 Bits 0-4 */
+	boolean LegacyTagEnable:1;	/* Byte 17 Bit 5 */
+	enum BusLogic_QueueTag LegacyQueueTag:2;	/* Byte 17 Bits 6-7 */
+	SCSI_CDB_T CDB;		/* Bytes 18-29 */
+	unsigned char:8;	/* Byte 30 */
+	unsigned char:8;	/* Byte 31 */
+	unsigned int:32;	/* Bytes 32-35 */
+	u32 SenseDataPointer;	/* Bytes 36-39 */
+	/*
+	   FlashPoint SCCB Manager Defined Portion.
+	 */
+	void (*CallbackFunction) (struct BusLogic_CCB *);	/* Bytes 40-43 */
+	u32 BaseAddress;	/* Bytes 44-47 */
+	enum BusLogic_CompletionCode CompletionCode;	/* Byte 48 */
+#ifndef CONFIG_SCSI_OMIT_FLASHPOINT
+	unsigned char:8;	/* Byte 49 */
+	unsigned short OS_Flags;	/* Bytes 50-51 */
+	unsigned char Private[48];	/* Bytes 52-99 */
+#endif
+	/*
+	   BusLogic Linux Driver Defined Portion.
+	 */
+	dma_addr_t AllocationGroupHead;
+	unsigned int AllocationGroupSize;
+	u32 DMA_Handle;
+	enum BusLogic_CCB_Status Status;
+	unsigned long SerialNumber;
+	struct scsi_cmnd *Command;
+	struct BusLogic_HostAdapter *HostAdapter;
+	struct BusLogic_CCB *Next;
+	struct BusLogic_CCB *NextAll;
+	struct BusLogic_ScatterGatherSegment
+	 ScatterGatherList[BusLogic_ScatterGatherLimit];
+};
+
+/*
+  Define the 32 Bit Mode Outgoing Mailbox structure.
+*/
+
+struct BusLogic_OutgoingMailbox {
+	u32 CCB;		/* Bytes 0-3 */
+	unsigned int:24;	/* Bytes 4-6 */
+	enum BusLogic_ActionCode ActionCode;	/* Byte 7 */
+};
+
+/*
+  Define the 32 Bit Mode Incoming Mailbox structure.
+*/
+
+struct BusLogic_IncomingMailbox {
+	u32 CCB;		/* Bytes 0-3 */
+	enum BusLogic_HostAdapterStatus HostAdapterStatus;	/* Byte 4 */
+	enum BusLogic_TargetDeviceStatus TargetDeviceStatus;	/* Byte 5 */
+	unsigned char:8;	/* Byte 6 */
+	enum BusLogic_CompletionCode CompletionCode;	/* Byte 7 */
+};
+
+
+/*
+  Define the BusLogic Driver Options structure.
+*/
+
+struct BusLogic_DriverOptions {
+	unsigned short TaggedQueuingPermitted;
+	unsigned short TaggedQueuingPermittedMask;
+	unsigned short BusSettleTime;
+	struct BusLogic_LocalOptions LocalOptions;
+	unsigned char CommonQueueDepth;
+	unsigned char QueueDepth[BusLogic_MaxTargetDevices];
+};
+
+/*
+  Define the Host Adapter Target Flags structure.
+*/
+
+struct BusLogic_TargetFlags {
+	boolean TargetExists:1;
+	boolean TaggedQueuingSupported:1;
+	boolean WideTransfersSupported:1;
+	boolean TaggedQueuingActive:1;
+	boolean WideTransfersActive:1;
+	boolean CommandSuccessfulFlag:1;
+	boolean TargetInfoReported:1;
+};
+
+/*
+  Define the Host Adapter Target Statistics structure.
+*/
+
+#define BusLogic_SizeBuckets			10
+
+typedef unsigned int BusLogic_CommandSizeBuckets_T[BusLogic_SizeBuckets];
+
+struct BusLogic_TargetStatistics {
+	unsigned int CommandsAttempted;
+	unsigned int CommandsCompleted;
+	unsigned int ReadCommands;
+	unsigned int WriteCommands;
+	struct BusLogic_ByteCounter TotalBytesRead;
+	struct BusLogic_ByteCounter TotalBytesWritten;
+	BusLogic_CommandSizeBuckets_T ReadCommandSizeBuckets;
+	BusLogic_CommandSizeBuckets_T WriteCommandSizeBuckets;
+	unsigned short CommandAbortsRequested;
+	unsigned short CommandAbortsAttempted;
+	unsigned short CommandAbortsCompleted;
+	unsigned short BusDeviceResetsRequested;
+	unsigned short BusDeviceResetsAttempted;
+	unsigned short BusDeviceResetsCompleted;
+	unsigned short HostAdapterResetsRequested;
+	unsigned short HostAdapterResetsAttempted;
+	unsigned short HostAdapterResetsCompleted;
+};
+
+/*
+  Define the FlashPoint Card Handle data type.
+*/
+
+#define FlashPoint_BadCardHandle		0xFFFFFFFF
+
+typedef unsigned int FlashPoint_CardHandle_T;
+
+
+/*
+  Define the FlashPoint Information structure.  This structure is defined
+  by the FlashPoint SCCB Manager.
+*/
+
+struct FlashPoint_Info {
+	u32 BaseAddress;	/* Bytes 0-3 */
+	boolean Present;	/* Byte 4 */
+	unsigned char IRQ_Channel;	/* Byte 5 */
+	unsigned char SCSI_ID;	/* Byte 6 */
+	unsigned char SCSI_LUN;	/* Byte 7 */
+	unsigned short FirmwareRevision;	/* Bytes 8-9 */
+	unsigned short SynchronousPermitted;	/* Bytes 10-11 */
+	unsigned short FastPermitted;	/* Bytes 12-13 */
+	unsigned short UltraPermitted;	/* Bytes 14-15 */
+	unsigned short DisconnectPermitted;	/* Bytes 16-17 */
+	unsigned short WidePermitted;	/* Bytes 18-19 */
+	boolean ParityCheckingEnabled:1;	/* Byte 20 Bit 0 */
+	boolean HostWideSCSI:1;	/* Byte 20 Bit 1 */
+	boolean HostSoftReset:1;	/* Byte 20 Bit 2 */
+	boolean ExtendedTranslationEnabled:1;	/* Byte 20 Bit 3 */
+	boolean LowByteTerminated:1;	/* Byte 20 Bit 4 */
+	boolean HighByteTerminated:1;	/* Byte 20 Bit 5 */
+	boolean ReportDataUnderrun:1;	/* Byte 20 Bit 6 */
+	boolean SCAM_Enabled:1;	/* Byte 20 Bit 7 */
+	boolean SCAM_Level2:1;	/* Byte 21 Bit 0 */
+	unsigned char:7;	/* Byte 21 Bits 1-7 */
+	unsigned char Family;	/* Byte 22 */
+	unsigned char BusType;	/* Byte 23 */
+	unsigned char ModelNumber[3];	/* Bytes 24-26 */
+	unsigned char RelativeCardNumber;	/* Byte 27 */
+	unsigned char Reserved[4];	/* Bytes 28-31 */
+	unsigned int OS_Reserved;	/* Bytes 32-35 */
+	unsigned char TranslationInfo[4];	/* Bytes 36-39 */
+	unsigned int Reserved2[5];	/* Bytes 40-59 */
+	unsigned int SecondaryRange;	/* Bytes 60-63 */
+};
+
+/*
+  Define the BusLogic Driver Host Adapter structure.
+*/
+
+struct BusLogic_HostAdapter {
+	struct Scsi_Host *SCSI_Host;
+	struct pci_dev *PCI_Device;
+	enum BusLogic_HostAdapterType HostAdapterType;
+	enum BusLogic_HostAdapterBusType HostAdapterBusType;
+	unsigned long IO_Address;
+	unsigned long PCI_Address;
+	unsigned short AddressCount;
+	unsigned char HostNumber;
+	unsigned char ModelName[9];
+	unsigned char FirmwareVersion[6];
+	unsigned char FullModelName[18];
+	unsigned char Bus;
+	unsigned char Device;
+	unsigned char IRQ_Channel;
+	unsigned char DMA_Channel;
+	unsigned char SCSI_ID;
+	boolean IRQ_ChannelAcquired:1;
+	boolean DMA_ChannelAcquired:1;
+	boolean ExtendedTranslationEnabled:1;
+	boolean ParityCheckingEnabled:1;
+	boolean BusResetEnabled:1;
+	boolean LevelSensitiveInterrupt:1;
+	boolean HostWideSCSI:1;
+	boolean HostDifferentialSCSI:1;
+	boolean HostSupportsSCAM:1;
+	boolean HostUltraSCSI:1;
+	boolean ExtendedLUNSupport:1;
+	boolean TerminationInfoValid:1;
+	boolean LowByteTerminated:1;
+	boolean HighByteTerminated:1;
+	boolean BounceBuffersRequired:1;
+	boolean StrictRoundRobinModeSupport:1;
+	boolean SCAM_Enabled:1;
+	boolean SCAM_Level2:1;
+	boolean HostAdapterInitialized:1;
+	boolean HostAdapterExternalReset:1;
+	boolean HostAdapterInternalError:1;
+	boolean ProcessCompletedCCBsActive;
+	volatile boolean HostAdapterCommandCompleted;
+	unsigned short HostAdapterScatterGatherLimit;
+	unsigned short DriverScatterGatherLimit;
+	unsigned short MaxTargetDevices;
+	unsigned short MaxLogicalUnits;
+	unsigned short MailboxCount;
+	unsigned short InitialCCBs;
+	unsigned short IncrementalCCBs;
+	unsigned short AllocatedCCBs;
+	unsigned short DriverQueueDepth;
+	unsigned short HostAdapterQueueDepth;
+	unsigned short UntaggedQueueDepth;
+	unsigned short CommonQueueDepth;
+	unsigned short BusSettleTime;
+	unsigned short SynchronousPermitted;
+	unsigned short FastPermitted;
+	unsigned short UltraPermitted;
+	unsigned short WidePermitted;
+	unsigned short DisconnectPermitted;
+	unsigned short TaggedQueuingPermitted;
+	unsigned short ExternalHostAdapterResets;
+	unsigned short HostAdapterInternalErrors;
+	unsigned short TargetDeviceCount;
+	unsigned short MessageBufferLength;
+	u32 BIOS_Address;
+	struct BusLogic_DriverOptions *DriverOptions;
+	struct FlashPoint_Info FlashPointInfo;
+	FlashPoint_CardHandle_T CardHandle;
+	struct list_head host_list;
+	struct BusLogic_CCB *All_CCBs;
+	struct BusLogic_CCB *Free_CCBs;
+	struct BusLogic_CCB *FirstCompletedCCB;
+	struct BusLogic_CCB *LastCompletedCCB;
+	struct BusLogic_CCB *BusDeviceResetPendingCCB[BusLogic_MaxTargetDevices];
+	struct BusLogic_TargetFlags TargetFlags[BusLogic_MaxTargetDevices];
+	unsigned char QueueDepth[BusLogic_MaxTargetDevices];
+	unsigned char SynchronousPeriod[BusLogic_MaxTargetDevices];
+	unsigned char SynchronousOffset[BusLogic_MaxTargetDevices];
+	unsigned char ActiveCommands[BusLogic_MaxTargetDevices];
+	unsigned int CommandsSinceReset[BusLogic_MaxTargetDevices];
+	unsigned long LastSequencePoint[BusLogic_MaxTargetDevices];
+	unsigned long LastResetAttempted[BusLogic_MaxTargetDevices];
+	unsigned long LastResetCompleted[BusLogic_MaxTargetDevices];
+	struct BusLogic_OutgoingMailbox *FirstOutgoingMailbox;
+	struct BusLogic_OutgoingMailbox *LastOutgoingMailbox;
+	struct BusLogic_OutgoingMailbox *NextOutgoingMailbox;
+	struct BusLogic_IncomingMailbox *FirstIncomingMailbox;
+	struct BusLogic_IncomingMailbox *LastIncomingMailbox;
+	struct BusLogic_IncomingMailbox *NextIncomingMailbox;
+	struct BusLogic_TargetStatistics TargetStatistics[BusLogic_MaxTargetDevices];
+	unsigned char *MailboxSpace;
+	dma_addr_t MailboxSpaceHandle;
+	unsigned int MailboxSize;
+	unsigned long CCB_Offset;
+	char MessageBuffer[BusLogic_MessageBufferSize];
+};
+
+/*
+  Define a structure for the BIOS Disk Parameters.
+*/
+
+struct BIOS_DiskParameters {
+	int Heads;
+	int Sectors;
+	int Cylinders;
+};
+
+/*
+  Define a structure for the SCSI Inquiry command results.
+*/
+
+struct SCSI_Inquiry {
+	unsigned char PeripheralDeviceType:5;	/* Byte 0 Bits 0-4 */
+	unsigned char PeripheralQualifier:3;	/* Byte 0 Bits 5-7 */
+	unsigned char DeviceTypeModifier:7;	/* Byte 1 Bits 0-6 */
+	boolean RMB:1;		/* Byte 1 Bit 7 */
+	unsigned char ANSI_ApprovedVersion:3;	/* Byte 2 Bits 0-2 */
+	unsigned char ECMA_Version:3;	/* Byte 2 Bits 3-5 */
+	unsigned char ISO_Version:2;	/* Byte 2 Bits 6-7 */
+	unsigned char ResponseDataFormat:4;	/* Byte 3 Bits 0-3 */
+	unsigned char:2;	/* Byte 3 Bits 4-5 */
+	boolean TrmIOP:1;	/* Byte 3 Bit 6 */
+	boolean AENC:1;		/* Byte 3 Bit 7 */
+	unsigned char AdditionalLength;	/* Byte 4 */
+	unsigned char:8;	/* Byte 5 */
+	unsigned char:8;	/* Byte 6 */
+	boolean SftRe:1;	/* Byte 7 Bit 0 */
+	boolean CmdQue:1;	/* Byte 7 Bit 1 */
+	 boolean:1;		/* Byte 7 Bit 2 */
+	boolean Linked:1;	/* Byte 7 Bit 3 */
+	boolean Sync:1;		/* Byte 7 Bit 4 */
+	boolean WBus16:1;	/* Byte 7 Bit 5 */
+	boolean WBus32:1;	/* Byte 7 Bit 6 */
+	boolean RelAdr:1;	/* Byte 7 Bit 7 */
+	unsigned char VendorIdentification[8];	/* Bytes 8-15 */
+	unsigned char ProductIdentification[16];	/* Bytes 16-31 */
+	unsigned char ProductRevisionLevel[4];	/* Bytes 32-35 */
+};
+
+
+/*
+  Define functions to provide an abstraction for reading and writing the
+  Host Adapter I/O Registers.
+*/
+
+static inline void BusLogic_SCSIBusReset(struct BusLogic_HostAdapter *HostAdapter)
+{
+	union BusLogic_ControlRegister ControlRegister;
+	ControlRegister.All = 0;
+	ControlRegister.cr.SCSIBusReset = true;
+	outb(ControlRegister.All, HostAdapter->IO_Address + BusLogic_ControlRegisterOffset);
+}
+
+static inline void BusLogic_InterruptReset(struct BusLogic_HostAdapter *HostAdapter)
+{
+	union BusLogic_ControlRegister ControlRegister;
+	ControlRegister.All = 0;
+	ControlRegister.cr.InterruptReset = true;
+	outb(ControlRegister.All, HostAdapter->IO_Address + BusLogic_ControlRegisterOffset);
+}
+
+static inline void BusLogic_SoftReset(struct BusLogic_HostAdapter *HostAdapter)
+{
+	union BusLogic_ControlRegister ControlRegister;
+	ControlRegister.All = 0;
+	ControlRegister.cr.SoftReset = true;
+	outb(ControlRegister.All, HostAdapter->IO_Address + BusLogic_ControlRegisterOffset);
+}
+
+static inline void BusLogic_HardReset(struct BusLogic_HostAdapter *HostAdapter)
+{
+	union BusLogic_ControlRegister ControlRegister;
+	ControlRegister.All = 0;
+	ControlRegister.cr.HardReset = true;
+	outb(ControlRegister.All, HostAdapter->IO_Address + BusLogic_ControlRegisterOffset);
+}
+
+static inline unsigned char BusLogic_ReadStatusRegister(struct BusLogic_HostAdapter *HostAdapter)
+{
+	return inb(HostAdapter->IO_Address + BusLogic_StatusRegisterOffset);
+}
+
+static inline void BusLogic_WriteCommandParameterRegister(struct BusLogic_HostAdapter
+							  *HostAdapter, unsigned char Value)
+{
+	outb(Value, HostAdapter->IO_Address + BusLogic_CommandParameterRegisterOffset);
+}
+
+static inline unsigned char BusLogic_ReadDataInRegister(struct BusLogic_HostAdapter *HostAdapter)
+{
+	return inb(HostAdapter->IO_Address + BusLogic_DataInRegisterOffset);
+}
+
+static inline unsigned char BusLogic_ReadInterruptRegister(struct BusLogic_HostAdapter *HostAdapter)
+{
+	return inb(HostAdapter->IO_Address + BusLogic_InterruptRegisterOffset);
+}
+
+static inline unsigned char BusLogic_ReadGeometryRegister(struct BusLogic_HostAdapter *HostAdapter)
+{
+	return inb(HostAdapter->IO_Address + BusLogic_GeometryRegisterOffset);
+}
+
+/*
+  BusLogic_StartMailboxCommand issues an Execute Mailbox Command, which
+  notifies the Host Adapter that an entry has been made in an Outgoing
+  Mailbox.
+*/
+
+static inline void BusLogic_StartMailboxCommand(struct BusLogic_HostAdapter *HostAdapter)
+{
+	BusLogic_WriteCommandParameterRegister(HostAdapter, BusLogic_ExecuteMailboxCommand);
+}
+
+/*
+  BusLogic_Delay waits for Seconds to elapse.
+*/
+
+static inline void BusLogic_Delay(int Seconds)
+{
+	mdelay(1000 * Seconds);
+}
+
+/*
+  Virtual_to_Bus and Bus_to_Virtual map between Kernel Virtual Addresses
+  and PCI/VLB/EISA/ISA Bus Addresses.
+*/
+
+static inline u32 Virtual_to_Bus(void *VirtualAddress)
+{
+	return (u32) virt_to_bus(VirtualAddress);
+}
+
+static inline void *Bus_to_Virtual(u32 BusAddress)
+{
+	return (void *) bus_to_virt(BusAddress);
+}
+
+/*
+  Virtual_to_32Bit_Virtual maps between Kernel Virtual Addresses and
+  32 bit Kernel Virtual Addresses.  This avoids compilation warnings
+  on 64 bit architectures.
+*/
+
+static inline u32 Virtual_to_32Bit_Virtual(void *VirtualAddress)
+{
+	return (u32) (unsigned long) VirtualAddress;
+}
+
+/*
+  BusLogic_IncrementErrorCounter increments Error Counter by 1, stopping at
+  65535 rather than wrapping around to 0.
+*/
+
+static inline void BusLogic_IncrementErrorCounter(unsigned short *ErrorCounter)
+{
+	if (*ErrorCounter < 65535)
+		(*ErrorCounter)++;
+}
+
+/*
+  BusLogic_IncrementByteCounter increments Byte Counter by Amount.
+*/
+
+static inline void BusLogic_IncrementByteCounter(struct BusLogic_ByteCounter
+						 *ByteCounter, unsigned int Amount)
+{
+	ByteCounter->Units += Amount;
+	if (ByteCounter->Units > 999999999) {
+		ByteCounter->Units -= 1000000000;
+		ByteCounter->Billions++;
+	}
+}
+
+/*
+  BusLogic_IncrementSizeBucket increments the Bucket for Amount.
+*/
+
+static inline void BusLogic_IncrementSizeBucket(BusLogic_CommandSizeBuckets_T CommandSizeBuckets, unsigned int Amount)
+{
+	int Index = 0;
+	if (Amount < 8 * 1024) {
+		if (Amount < 2 * 1024)
+			Index = (Amount < 1 * 1024 ? 0 : 1);
+		else
+			Index = (Amount < 4 * 1024 ? 2 : 3);
+	} else if (Amount < 128 * 1024) {
+		if (Amount < 32 * 1024)
+			Index = (Amount < 16 * 1024 ? 4 : 5);
+		else
+			Index = (Amount < 64 * 1024 ? 6 : 7);
+	} else
+		Index = (Amount < 256 * 1024 ? 8 : 9);
+	CommandSizeBuckets[Index]++;
+}
+
+/*
+  Define the version number of the FlashPoint Firmware (SCCB Manager).
+*/
+
+#define FlashPoint_FirmwareVersion		"5.02"
+
+/*
+  Define the possible return values from FlashPoint_HandleInterrupt.
+*/
+
+#define FlashPoint_NormalInterrupt		0x00
+#define FlashPoint_InternalError		0xFE
+#define FlashPoint_ExternalBusReset		0xFF
+
+/*
+  Define prototypes for the forward referenced BusLogic Driver
+  Internal Functions.
+*/
+
+static const char *BusLogic_DriverInfo(struct Scsi_Host *);
+static int BusLogic_QueueCommand(struct scsi_cmnd *, void (*CompletionRoutine) (struct scsi_cmnd *));
+static int BusLogic_BIOSDiskParameters(struct scsi_device *, struct block_device *, sector_t, int *);
+static int BusLogic_ProcDirectoryInfo(struct Scsi_Host *, char *, char **, off_t, int, int);
+static int BusLogic_SlaveConfigure(struct scsi_device *);
+static void BusLogic_QueueCompletedCCB(struct BusLogic_CCB *);
+static irqreturn_t BusLogic_InterruptHandler(int, void *, struct pt_regs *);
+static int BusLogic_ResetHostAdapter(struct BusLogic_HostAdapter *, boolean HardReset);
+static void BusLogic_Message(enum BusLogic_MessageLevel, char *, struct BusLogic_HostAdapter *, ...);
+static int __init BusLogic_Setup(char *);
+
+#endif				/* _BUSLOGIC_H */
