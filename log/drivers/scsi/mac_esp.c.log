commit 09c434b8a0047c69e48499de0107de312901e798
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Sun May 19 13:08:20 2019 +0100

    treewide: Add SPDX license identifier for more missed files
    
    Add SPDX license identifiers to all files which:
    
     - Have no license information of any form
    
     - Have MODULE_LICENCE("GPL*") inside which was used in the initial
       scan/conversion to ignore the file
    
    These files fall under the project license, GPL v2 only. The resulting SPDX
    license identifier is:
    
      GPL-2.0-only
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/scsi/mac_esp.c b/drivers/scsi/mac_esp.c
index ee741207fd4e..1c78bc10c790 100644
--- a/drivers/scsi/mac_esp.c
+++ b/drivers/scsi/mac_esp.c
@@ -1,3 +1,4 @@
+// SPDX-License-Identifier: GPL-2.0-only
 /* mac_esp.c: ESP front-end for Macintosh Quadra systems.
  *
  * Adapted from jazz_esp.c and the old mac_esp.c.

commit 4af14d113bcf95c12d1462ba623b7e7117bd3fb3
Author: Christoph Hellwig <hch@lst.de>
Date:   Thu Dec 13 16:17:09 2018 +0100

    scsi: remove the use_clustering flag
    
    The same effects can be achieved by setting the dma_boundary to
    PAGE_SIZE - 1 and the max_segment_size to PAGE_SIZE, so shift those
    settings into the drivers.  Note that in many cases the setting might
    be bogus, but this keeps the status quo.
    
    [mkp: fix myrs and myrb]
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/mac_esp.c b/drivers/scsi/mac_esp.c
index 764d320bb2ca..ee741207fd4e 100644
--- a/drivers/scsi/mac_esp.c
+++ b/drivers/scsi/mac_esp.c
@@ -307,7 +307,7 @@ static int esp_mac_probe(struct platform_device *dev)
 		goto fail;
 
 	host->max_id = 8;
-	host->use_clustering = DISABLE_CLUSTERING;
+	host->dma_boundary = PAGE_SIZE - 1;
 	esp = shost_priv(host);
 
 	esp->host = host;

commit 53dce332db507a2bd9797adc938fa293d1f1acc6
Author: Finn Thain <fthain@telegraphics.com.au>
Date:   Tue Oct 16 16:31:25 2018 +1100

    scsi: esp_scsi: De-duplicate PIO routines
    
    As a temporary measure, the code to implement PIO transfers was
    duplicated in zorro_esp and mac_esp. Now that it has stabilized move the
    common code into the core driver but don't build it unless needed.
    
    This replaces the inline assembler with more portable writesb() calls.
    Optimizing the m68k writesb() implementation is a separate patch.
    
    [mkp: applied by hand]
    
    Signed-off-by: Finn Thain <fthain@telegraphics.com.au>
    Tested-by: Stan Johnson <userm57@yahoo.com>
    Tested-by: Michael Schmitz <schmitzmic@gmail.com>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/mac_esp.c b/drivers/scsi/mac_esp.c
index c92b6c1e02ee..764d320bb2ca 100644
--- a/drivers/scsi/mac_esp.c
+++ b/drivers/scsi/mac_esp.c
@@ -52,7 +52,6 @@ struct mac_esp_priv {
 	struct esp *esp;
 	void __iomem *pdma_regs;
 	void __iomem *pdma_io;
-	int error;
 };
 static struct esp *esp_chips[2];
 static DEFINE_SPINLOCK(esp_chips_lock);
@@ -87,12 +86,11 @@ static void mac_esp_dma_invalidate(struct esp *esp)
 
 static int mac_esp_dma_error(struct esp *esp)
 {
-	return MAC_ESP_GET_PRIV(esp)->error;
+	return esp->send_cmd_error;
 }
 
 static inline int mac_esp_wait_for_empty_fifo(struct esp *esp)
 {
-	struct mac_esp_priv *mep = MAC_ESP_GET_PRIV(esp);
 	int i = 500000;
 
 	do {
@@ -107,7 +105,7 @@ static inline int mac_esp_wait_for_empty_fifo(struct esp *esp)
 
 	printk(KERN_ERR PFX "FIFO is not empty (sreg %02x)\n",
 	       esp_read8(ESP_STATUS));
-	mep->error = 1;
+	esp->send_cmd_error = 1;
 	return 1;
 }
 
@@ -133,7 +131,7 @@ static inline int mac_esp_wait_for_dreq(struct esp *esp)
 
 	printk(KERN_ERR PFX "PDMA timeout (sreg %02x)\n",
 	       esp_read8(ESP_STATUS));
-	mep->error = 1;
+	esp->send_cmd_error = 1;
 	return 1;
 }
 
@@ -200,7 +198,7 @@ static void mac_esp_send_pdma_cmd(struct esp *esp, u32 addr, u32 esp_count,
 {
 	struct mac_esp_priv *mep = MAC_ESP_GET_PRIV(esp);
 
-	mep->error = 0;
+	esp->send_cmd_error = 0;
 
 	if (!write)
 		scsi_esp_cmd(esp, ESP_CMD_FLUSH);
@@ -238,166 +236,6 @@ static void mac_esp_send_pdma_cmd(struct esp *esp, u32 addr, u32 esp_count,
 	} while (esp_count);
 }
 
-/*
- * Programmed IO routines follow.
- */
-
-static inline unsigned int mac_esp_wait_for_fifo(struct esp *esp)
-{
-	int i = 500000;
-
-	do {
-		unsigned int fbytes = esp_read8(ESP_FFLAGS) & ESP_FF_FBYTES;
-
-		if (fbytes)
-			return fbytes;
-
-		udelay(2);
-	} while (--i);
-
-	printk(KERN_ERR PFX "FIFO is empty (sreg %02x)\n",
-	       esp_read8(ESP_STATUS));
-	return 0;
-}
-
-static inline int mac_esp_wait_for_intr(struct esp *esp)
-{
-	struct mac_esp_priv *mep = MAC_ESP_GET_PRIV(esp);
-	int i = 500000;
-
-	do {
-		esp->sreg = esp_read8(ESP_STATUS);
-		if (esp->sreg & ESP_STAT_INTR)
-			return 0;
-
-		udelay(2);
-	} while (--i);
-
-	printk(KERN_ERR PFX "IRQ timeout (sreg %02x)\n", esp->sreg);
-	mep->error = 1;
-	return 1;
-}
-
-#define MAC_ESP_PIO_LOOP(operands, reg1) \
-	asm volatile ( \
-	     "1:     moveb " operands " \n" \
-	     "       subqw #1,%1        \n" \
-	     "       jbne 1b            \n" \
-	     : "+a" (addr), "+r" (reg1) \
-	     : "a" (fifo))
-
-#define MAC_ESP_PIO_FILL(operands, reg1) \
-	asm volatile ( \
-	     "       moveb " operands " \n" \
-	     "       moveb " operands " \n" \
-	     "       moveb " operands " \n" \
-	     "       moveb " operands " \n" \
-	     "       moveb " operands " \n" \
-	     "       moveb " operands " \n" \
-	     "       moveb " operands " \n" \
-	     "       moveb " operands " \n" \
-	     "       moveb " operands " \n" \
-	     "       moveb " operands " \n" \
-	     "       moveb " operands " \n" \
-	     "       moveb " operands " \n" \
-	     "       moveb " operands " \n" \
-	     "       moveb " operands " \n" \
-	     "       moveb " operands " \n" \
-	     "       moveb " operands " \n" \
-	     "       subqw #8,%1        \n" \
-	     "       subqw #8,%1        \n" \
-	     : "+a" (addr), "+r" (reg1) \
-	     : "a" (fifo))
-
-#define MAC_ESP_FIFO_SIZE 16
-
-static void mac_esp_send_pio_cmd(struct esp *esp, u32 addr, u32 esp_count,
-				 u32 dma_count, int write, u8 cmd)
-{
-	struct mac_esp_priv *mep = MAC_ESP_GET_PRIV(esp);
-	u8 __iomem *fifo = esp->regs + ESP_FDATA * 16;
-	u8 phase = esp->sreg & ESP_STAT_PMASK;
-
-	cmd &= ~ESP_CMD_DMA;
-	mep->error = 0;
-
-	if (write) {
-		u8 *dst = (u8 *)addr;
-		u8 mask = ~(phase == ESP_MIP ? ESP_INTR_FDONE : ESP_INTR_BSERV);
-
-		scsi_esp_cmd(esp, cmd);
-
-		while (1) {
-			if (!mac_esp_wait_for_fifo(esp))
-				break;
-
-			*dst++ = esp_read8(ESP_FDATA);
-			--esp_count;
-
-			if (!esp_count)
-				break;
-
-			if (mac_esp_wait_for_intr(esp))
-				break;
-
-			if ((esp->sreg & ESP_STAT_PMASK) != phase)
-				break;
-
-			esp->ireg = esp_read8(ESP_INTRPT);
-			if (esp->ireg & mask) {
-				mep->error = 1;
-				break;
-			}
-
-			if (phase == ESP_MIP)
-				scsi_esp_cmd(esp, ESP_CMD_MOK);
-
-			scsi_esp_cmd(esp, ESP_CMD_TI);
-		}
-	} else {
-		scsi_esp_cmd(esp, ESP_CMD_FLUSH);
-
-		if (esp_count >= MAC_ESP_FIFO_SIZE)
-			MAC_ESP_PIO_FILL("%0@+,%2@", esp_count);
-		else
-			MAC_ESP_PIO_LOOP("%0@+,%2@", esp_count);
-
-		scsi_esp_cmd(esp, cmd);
-
-		while (esp_count) {
-			unsigned int n;
-
-			if (mac_esp_wait_for_intr(esp))
-				break;
-
-			if ((esp->sreg & ESP_STAT_PMASK) != phase)
-				break;
-
-			esp->ireg = esp_read8(ESP_INTRPT);
-			if (esp->ireg & ~ESP_INTR_BSERV) {
-				mep->error = 1;
-				break;
-			}
-
-			n = MAC_ESP_FIFO_SIZE -
-			    (esp_read8(ESP_FFLAGS) & ESP_FF_FBYTES);
-			if (n > esp_count)
-				n = esp_count;
-
-			if (n == MAC_ESP_FIFO_SIZE) {
-				MAC_ESP_PIO_FILL("%0@+,%2@", esp_count);
-			} else {
-				esp_count -= n;
-				MAC_ESP_PIO_LOOP("%0@+,%2@", n);
-			}
-
-			scsi_esp_cmd(esp, ESP_CMD_TI);
-		}
-	}
-
-	esp->send_cmd_residual = esp_count;
-}
-
 static int mac_esp_irq_pending(struct esp *esp)
 {
 	if (esp_read8(ESP_STATUS) & ESP_STAT_INTR)
@@ -516,6 +354,7 @@ static int esp_mac_probe(struct platform_device *dev)
 		mep->pdma_regs = NULL;
 		break;
 	}
+	esp->fifo_reg = esp->regs + ESP_FDATA * 16;
 
 	esp->ops = &mac_esp_ops;
 	esp->flags = ESP_FLAG_NO_DMA_MAP;
@@ -524,7 +363,7 @@ static int esp_mac_probe(struct platform_device *dev)
 		esp_write8(0, ESP_TCLOW);
 		esp_write8(0, ESP_TCMED);
 		esp->flags |= ESP_FLAG_DISABLE_SYNC;
-		mac_esp_ops.send_dma_cmd = mac_esp_send_pio_cmd;
+		mac_esp_ops.send_dma_cmd = esp_send_pio_cmd;
 	} else {
 		printk(KERN_INFO PFX "using PDMA for controller %d\n", dev->id);
 	}

commit fd47d919d0c336e7c22862b51ee94927ffea227a
Author: Finn Thain <fthain@telegraphics.com.au>
Date:   Tue Oct 16 16:31:25 2018 +1100

    scsi: esp_scsi: Track residual for PIO transfers
    
    If a target disconnects during a PIO data transfer the command may fail
    when the target reconnects:
    
    scsi host1: DMA length is zero!
    scsi host1: cur adr[04380000] len[00000000]
    
    The scsi bus is then reset. This happens because the residual reached
    zero before the transfer was completed.
    
    The usual residual calculation relies on the Transfer Count registers.
    That works for DMA transfers but not for PIO transfers. Fix the problem
    by storing the PIO transfer residual and using that to correctly
    calculate bytes_sent.
    
    Fixes: 6fe07aaffbf0 ("[SCSI] m68k: new mac_esp scsi driver")
    Tested-by: Stan Johnson <userm57@yahoo.com>
    Signed-off-by: Finn Thain <fthain@telegraphics.com.au>
    Tested-by: Michael Schmitz <schmitzmic@gmail.com>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/mac_esp.c b/drivers/scsi/mac_esp.c
index 2769df5acc07..c92b6c1e02ee 100644
--- a/drivers/scsi/mac_esp.c
+++ b/drivers/scsi/mac_esp.c
@@ -394,6 +394,8 @@ static void mac_esp_send_pio_cmd(struct esp *esp, u32 addr, u32 esp_count,
 			scsi_esp_cmd(esp, ESP_CMD_TI);
 		}
 	}
+
+	esp->send_cmd_residual = esp_count;
 }
 
 static int mac_esp_irq_pending(struct esp *esp)

commit 3f9295b65ea44194252d60376036a3618d822152
Author: Christoph Hellwig <hch@lst.de>
Date:   Sat Oct 13 09:26:27 2018 +0200

    scsi: esp_scsi: move dma mapping into the core code
    
    Except for the mac_esp driver, which uses PIO or pseudo DMA, all drivers
    share the same dma mapping calls.  Move the dma mapping into the core
    code using the scsi_dma_map / scsi_dma_unmap helpers, with a special
    identify mapping variant triggered off a new ESP_FLAG_NO_DMA_MAP flag
    for mac_esp.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Tested-by: Finn Thain <fthain@telegraphics.com.au>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/mac_esp.c b/drivers/scsi/mac_esp.c
index 9299ff929f7f..2769df5acc07 100644
--- a/drivers/scsi/mac_esp.c
+++ b/drivers/scsi/mac_esp.c
@@ -70,38 +70,6 @@ static inline u8 mac_esp_read8(struct esp *esp, unsigned long reg)
 	return nubus_readb(esp->regs + reg * 16);
 }
 
-/* For pseudo DMA and PIO we need the virtual address
- * so this address mapping is the identity mapping.
- */
-
-static dma_addr_t mac_esp_map_single(struct esp *esp, void *buf,
-				     size_t sz, int dir)
-{
-	return (dma_addr_t)buf;
-}
-
-static int mac_esp_map_sg(struct esp *esp, struct scatterlist *sg,
-			  int num_sg, int dir)
-{
-	int i;
-
-	for (i = 0; i < num_sg; i++)
-		sg[i].dma_address = (u32)sg_virt(&sg[i]);
-	return num_sg;
-}
-
-static void mac_esp_unmap_single(struct esp *esp, dma_addr_t addr,
-				 size_t sz, int dir)
-{
-	/* Nothing to do. */
-}
-
-static void mac_esp_unmap_sg(struct esp *esp, struct scatterlist *sg,
-			     int num_sg, int dir)
-{
-	/* Nothing to do. */
-}
-
 static void mac_esp_reset_dma(struct esp *esp)
 {
 	/* Nothing to do. */
@@ -469,10 +437,6 @@ static irqreturn_t mac_scsi_esp_intr(int irq, void *dev_id)
 static struct esp_driver_ops mac_esp_ops = {
 	.esp_write8       = mac_esp_write8,
 	.esp_read8        = mac_esp_read8,
-	.map_single       = mac_esp_map_single,
-	.map_sg           = mac_esp_map_sg,
-	.unmap_single     = mac_esp_unmap_single,
-	.unmap_sg         = mac_esp_unmap_sg,
 	.irq_pending      = mac_esp_irq_pending,
 	.dma_length_limit = mac_esp_dma_length_limit,
 	.reset_dma        = mac_esp_reset_dma,
@@ -552,11 +516,12 @@ static int esp_mac_probe(struct platform_device *dev)
 	}
 
 	esp->ops = &mac_esp_ops;
+	esp->flags = ESP_FLAG_NO_DMA_MAP;
 	if (mep->pdma_io == NULL) {
 		printk(KERN_INFO PFX "using PIO for controller %d\n", dev->id);
 		esp_write8(0, ESP_TCLOW);
 		esp_write8(0, ESP_TCMED);
-		esp->flags = ESP_FLAG_DISABLE_SYNC;
+		esp->flags |= ESP_FLAG_DISABLE_SYNC;
 		mac_esp_ops.send_dma_cmd = mac_esp_send_pio_cmd;
 	} else {
 		printk(KERN_INFO PFX "using PDMA for controller %d\n", dev->id);

commit 44b1b4d24b2d65134efeccb3cc2341c61227f0f9
Author: Christoph Hellwig <hch@lst.de>
Date:   Sat Oct 13 09:26:26 2018 +0200

    scsi: esp_scsi: remove the dev argument to scsi_esp_register
    
    We can simplify use esp->dev now.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Tested-by: Finn Thain <fthain@telegraphics.com.au>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/mac_esp.c b/drivers/scsi/mac_esp.c
index 85d067889a9b..9299ff929f7f 100644
--- a/drivers/scsi/mac_esp.c
+++ b/drivers/scsi/mac_esp.c
@@ -576,7 +576,7 @@ static int esp_mac_probe(struct platform_device *dev)
 	esp_chips[dev->id] = esp;
 	spin_unlock(&esp_chips_lock);
 
-	err = scsi_esp_register(esp, &dev->dev);
+	err = scsi_esp_register(esp);
 	if (err)
 		goto fail_free_irq;
 

commit 98cda6a2e0d46507c084bf1488f5627b9e487a2a
Author: Christoph Hellwig <hch@lst.de>
Date:   Sat Oct 13 09:26:25 2018 +0200

    scsi: esp_scsi: use strong typing for the dev field
    
    esp->dev is a void pointer that points either to a struct device, or a
    struct platform_device.  As we can easily get from the device to the
    platform_device if needed change it to always point to a struct device
    and properly type the pointer to avoid errors.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Tested-by: Finn Thain <fthain@telegraphics.com.au>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/mac_esp.c b/drivers/scsi/mac_esp.c
index eb551f3cc471..85d067889a9b 100644
--- a/drivers/scsi/mac_esp.c
+++ b/drivers/scsi/mac_esp.c
@@ -58,8 +58,7 @@ static struct esp *esp_chips[2];
 static DEFINE_SPINLOCK(esp_chips_lock);
 
 #define MAC_ESP_GET_PRIV(esp) ((struct mac_esp_priv *) \
-			       platform_get_drvdata((struct platform_device *) \
-						    (esp->dev)))
+			       dev_get_drvdata((esp)->dev))
 
 static inline void mac_esp_write8(struct esp *esp, u8 val, unsigned long reg)
 {
@@ -508,7 +507,7 @@ static int esp_mac_probe(struct platform_device *dev)
 	esp = shost_priv(host);
 
 	esp->host = host;
-	esp->dev = dev;
+	esp->dev = &dev->dev;
 
 	esp->command_block = kzalloc(16, GFP_KERNEL);
 	if (!esp->command_block)

commit 7640d91d285893a5cf1e62b2cd00f0884c401d93
Author: Finn Thain <fthain@telegraphics.com.au>
Date:   Fri Aug 4 01:43:19 2017 -0400

    scsi: mac_esp: Fix PIO transfers for MESSAGE IN phase
    
    When in MESSAGE IN phase, the ESP device does not automatically
    acknowledge each byte that is transferred by PIO. The mac_esp driver
    neglects to explicitly ack them, which causes a timeout during messages
    larger than one byte (e.g. tag bytes during reconnect). Fix this with an
    ESP_CMD_MOK command after each byte.
    
    The MESSAGE IN phase is also different in that each byte transferred
    raises ESP_INTR_FDONE. So don't exit the transfer loop for this interrupt,
    for this phase.
    
    That resolves the "Reconnect IRQ2 timeout" error on those Macs which use
    PIO transfers instead of PDMA. This patch also improves on the weak tests
    for unexpected interrupts and phase changes during PIO transfers.
    
    Tested-by: Stan Johnson <userm57@yahoo.com>
    Fixes: 02507a80b35e ("[PATCH] [SCSI] mac_esp: fix PIO mode, take 2")
    Signed-off-by: Finn Thain <fthain@telegraphics.com.au>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/mac_esp.c b/drivers/scsi/mac_esp.c
index 253142f3cf6f..eb551f3cc471 100644
--- a/drivers/scsi/mac_esp.c
+++ b/drivers/scsi/mac_esp.c
@@ -349,25 +349,23 @@ static void mac_esp_send_pio_cmd(struct esp *esp, u32 addr, u32 esp_count,
 {
 	struct mac_esp_priv *mep = MAC_ESP_GET_PRIV(esp);
 	u8 __iomem *fifo = esp->regs + ESP_FDATA * 16;
+	u8 phase = esp->sreg & ESP_STAT_PMASK;
 
 	cmd &= ~ESP_CMD_DMA;
 	mep->error = 0;
 
 	if (write) {
+		u8 *dst = (u8 *)addr;
+		u8 mask = ~(phase == ESP_MIP ? ESP_INTR_FDONE : ESP_INTR_BSERV);
+
 		scsi_esp_cmd(esp, cmd);
 
 		while (1) {
-			unsigned int n;
-
-			n = mac_esp_wait_for_fifo(esp);
-			if (!n)
+			if (!mac_esp_wait_for_fifo(esp))
 				break;
 
-			if (n > esp_count)
-				n = esp_count;
-			esp_count -= n;
-
-			MAC_ESP_PIO_LOOP("%2@,%0@+", n);
+			*dst++ = esp_read8(ESP_FDATA);
+			--esp_count;
 
 			if (!esp_count)
 				break;
@@ -375,14 +373,17 @@ static void mac_esp_send_pio_cmd(struct esp *esp, u32 addr, u32 esp_count,
 			if (mac_esp_wait_for_intr(esp))
 				break;
 
-			if (((esp->sreg & ESP_STAT_PMASK) != ESP_DIP) &&
-			    ((esp->sreg & ESP_STAT_PMASK) != ESP_MIP))
+			if ((esp->sreg & ESP_STAT_PMASK) != phase)
 				break;
 
 			esp->ireg = esp_read8(ESP_INTRPT);
-			if ((esp->ireg & (ESP_INTR_DC | ESP_INTR_BSERV)) !=
-			    ESP_INTR_BSERV)
+			if (esp->ireg & mask) {
+				mep->error = 1;
 				break;
+			}
+
+			if (phase == ESP_MIP)
+				scsi_esp_cmd(esp, ESP_CMD_MOK);
 
 			scsi_esp_cmd(esp, ESP_CMD_TI);
 		}
@@ -402,14 +403,14 @@ static void mac_esp_send_pio_cmd(struct esp *esp, u32 addr, u32 esp_count,
 			if (mac_esp_wait_for_intr(esp))
 				break;
 
-			if (((esp->sreg & ESP_STAT_PMASK) != ESP_DOP) &&
-			    ((esp->sreg & ESP_STAT_PMASK) != ESP_MOP))
+			if ((esp->sreg & ESP_STAT_PMASK) != phase)
 				break;
 
 			esp->ireg = esp_read8(ESP_INTRPT);
-			if ((esp->ireg & (ESP_INTR_DC | ESP_INTR_BSERV)) !=
-			    ESP_INTR_BSERV)
+			if (esp->ireg & ~ESP_INTR_BSERV) {
+				mep->error = 1;
 				break;
+			}
 
 			n = MAC_ESP_FIFO_SIZE -
 			    (esp_read8(ESP_FFLAGS) & ESP_FF_FBYTES);

commit b36c7db977e794230aa337651f510b62ea328afd
Author: Finn Thain <fthain@telegraphics.com.au>
Date:   Fri Aug 4 01:43:19 2017 -0400

    scsi: mac_esp: Avoid type warning from sparse
    
    Avoid the following warning from "make C=1":
    
      CHECK   drivers/scsi/mac_esp.c
    drivers/scsi/mac_esp.c:357:30: warning: incorrect type in initializer (different address spaces)
    drivers/scsi/mac_esp.c:357:30:    expected unsigned char [usertype] *fifo
    drivers/scsi/mac_esp.c:357:30:    got void [noderef] <asn:2>*
    
    Tested-by: Stan Johnson <userm57@yahoo.com>
    Signed-off-by: Finn Thain <fthain@telegraphics.com.au>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/mac_esp.c b/drivers/scsi/mac_esp.c
index cdb61eaa2d1f..253142f3cf6f 100644
--- a/drivers/scsi/mac_esp.c
+++ b/drivers/scsi/mac_esp.c
@@ -348,7 +348,7 @@ static void mac_esp_send_pio_cmd(struct esp *esp, u32 addr, u32 esp_count,
 				 u32 dma_count, int write, u8 cmd)
 {
 	struct mac_esp_priv *mep = MAC_ESP_GET_PRIV(esp);
-	u8 *fifo = esp->regs + ESP_FDATA * 16;
+	u8 __iomem *fifo = esp->regs + ESP_FDATA * 16;
 
 	cmd &= ~ESP_CMD_DMA;
 	mep->error = 0;

commit 8d5e72dfdf0fa29a21143fd72746c6f43295ce9f
Merge: 2bd804017435 e7731da36f10
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Thu May 4 12:19:44 2017 -0700

    Merge tag 'scsi-misc' of git://git.kernel.org/pub/scm/linux/kernel/git/jejb/scsi
    
    Pull SCSI updates from James Bottomley:
     "This update includes the usual round of major driver updates
      (hisi_sas, ufs, fnic, cxlflash, be2iscsi, ipr, stex). There's also the
      usual amount of cosmetic and spelling stuff"
    
    * tag 'scsi-misc' of git://git.kernel.org/pub/scm/linux/kernel/git/jejb/scsi: (155 commits)
      scsi: qla4xxx: fix spelling mistake: "Tempalate" -> "Template"
      scsi: stex: make S6flag static
      scsi: mac_esp: fix to pass correct device identity to free_irq()
      scsi: aacraid: pci_alloc_consistent() failures on ARM64
      scsi: ufs: make ufshcd_get_lists_status() register operation obvious
      scsi: ufs: use MASK_EE_STATUS
      scsi: mac_esp: Replace bogus memory barrier with spinlock
      scsi: fcoe: make fcoe_e_d_tov and fcoe_r_a_tov static
      scsi: sd_zbc: Do not write lock zones for reset
      scsi: sd_zbc: Remove superfluous assignments
      scsi: sd: sd_zbc: Rename sd_zbc_setup_write_cmnd
      scsi: Improve scsi_get_sense_info_fld
      scsi: sd: Cleanup sd_done sense data handling
      scsi: sd: Improve sd_completed_bytes
      scsi: sd: Fix function descriptions
      scsi: mpt3sas: remove redundant wmb
      scsi: mpt: Move scsi_remove_host() out of mptscsih_remove_host()
      scsi: sg: reset 'res_in_use' after unlinking reserved array
      scsi: mvumi: remove code handling zero scsi_sg_count(scmd) case
      scsi: fusion: fix spelling mistake: "Persistancy" -> "Persistency"
      ...

commit c0e3a6acdebc5b98c65a379460df1b4b2fe6c0d3
Author: Wei Yongjun <weiyongjun1@huawei.com>
Date:   Wed Apr 26 15:43:59 2017 +1000

    scsi: mac_esp: fix to pass correct device identity to free_irq()
    
    free_irq() expects the same device identity that was passed to
    corresponding request_irq(), otherwise the IRQ is not freed.
    
    Signed-off-by: Wei Yongjun <weiyongjun1@huawei.com>
    Signed-off-by: Finn Thain <fthain@telegraphics.com.au>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/mac_esp.c b/drivers/scsi/mac_esp.c
index 26c67c42985c..999699d45e14 100644
--- a/drivers/scsi/mac_esp.c
+++ b/drivers/scsi/mac_esp.c
@@ -587,7 +587,7 @@ static int esp_mac_probe(struct platform_device *dev)
 	esp_chips[dev->id] = NULL;
 	if (esp_chips[!dev->id] == NULL) {
 		spin_unlock(&esp_chips_lock);
-		free_irq(host->irq, esp);
+		free_irq(host->irq, NULL);
 	} else
 		spin_unlock(&esp_chips_lock);
 fail_free_priv:

commit 4da2b1eb230ba4ad19b58984dc52e05b1073df5f
Author: Finn Thain <fthain@telegraphics.com.au>
Date:   Sun Apr 2 17:08:05 2017 +1000

    scsi: mac_esp: Replace bogus memory barrier with spinlock
    
    Commit da244654c66e ("[SCSI] mac_esp: fix for quadras with two esp
    chips") added mac_scsi_esp_intr() to handle the IRQ lines from a pair of
    on-board ESP chips (a normal shared IRQ did not work).
    
    Proper mutual exclusion was missing from that patch. This patch fixes
    race conditions between comparison and assignment of esp_chips[]
    pointers.
    
    Signed-off-by: Finn Thain <fthain@telegraphics.com.au>
    Reviewed-by: Michael Schmitz <schmitzmic@gmail.com>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/mac_esp.c b/drivers/scsi/mac_esp.c
index 14c0334f41e4..26c67c42985c 100644
--- a/drivers/scsi/mac_esp.c
+++ b/drivers/scsi/mac_esp.c
@@ -55,6 +55,7 @@ struct mac_esp_priv {
 	int error;
 };
 static struct esp *esp_chips[2];
+static DEFINE_SPINLOCK(esp_chips_lock);
 
 #define MAC_ESP_GET_PRIV(esp) ((struct mac_esp_priv *) \
 			       platform_get_drvdata((struct platform_device *) \
@@ -562,15 +563,18 @@ static int esp_mac_probe(struct platform_device *dev)
 	}
 
 	host->irq = IRQ_MAC_SCSI;
-	esp_chips[dev->id] = esp;
-	mb();
-	if (esp_chips[!dev->id] == NULL) {
-		err = request_irq(host->irq, mac_scsi_esp_intr, 0, "ESP", NULL);
-		if (err < 0) {
-			esp_chips[dev->id] = NULL;
-			goto fail_free_priv;
-		}
+
+	/* The request_irq() call is intended to succeed for the first device
+	 * and fail for the second device.
+	 */
+	err = request_irq(host->irq, mac_scsi_esp_intr, 0, "ESP", NULL);
+	spin_lock(&esp_chips_lock);
+	if (err < 0 && esp_chips[!dev->id] == NULL) {
+		spin_unlock(&esp_chips_lock);
+		goto fail_free_priv;
 	}
+	esp_chips[dev->id] = esp;
+	spin_unlock(&esp_chips_lock);
 
 	err = scsi_esp_register(esp, &dev->dev);
 	if (err)
@@ -579,8 +583,13 @@ static int esp_mac_probe(struct platform_device *dev)
 	return 0;
 
 fail_free_irq:
-	if (esp_chips[!dev->id] == NULL)
+	spin_lock(&esp_chips_lock);
+	esp_chips[dev->id] = NULL;
+	if (esp_chips[!dev->id] == NULL) {
+		spin_unlock(&esp_chips_lock);
 		free_irq(host->irq, esp);
+	} else
+		spin_unlock(&esp_chips_lock);
 fail_free_priv:
 	kfree(mep);
 fail_free_command_block:
@@ -599,9 +608,13 @@ static int esp_mac_remove(struct platform_device *dev)
 
 	scsi_esp_unregister(esp);
 
+	spin_lock(&esp_chips_lock);
 	esp_chips[dev->id] = NULL;
-	if (!(esp_chips[0] || esp_chips[1]))
+	if (esp_chips[!dev->id] == NULL) {
+		spin_unlock(&esp_chips_lock);
 		free_irq(irq, NULL);
+	} else
+		spin_unlock(&esp_chips_lock);
 
 	kfree(mep);
 

commit d0c2c269a3ccf0bba4db6fbcfb56827d482b2755
Author: Finn Thain <fthain@telegraphics.com.au>
Date:   Mon Mar 20 11:53:09 2017 +1100

    drivers: Clean up duplicated email address
    
    My email address may be found in the git commit logs and in MAINTAINERS.
    Remove duplicate addresses so they won't have to be kept up-to-date.
    
    Signed-off-by: Finn Thain <fthain@telegraphics.com.au>
    Signed-off-by: Jiri Kosina <jkosina@suse.cz>

diff --git a/drivers/scsi/mac_esp.c b/drivers/scsi/mac_esp.c
index 14c0334f41e4..bb567d3b0693 100644
--- a/drivers/scsi/mac_esp.c
+++ b/drivers/scsi/mac_esp.c
@@ -631,7 +631,7 @@ static void __exit mac_esp_exit(void)
 }
 
 MODULE_DESCRIPTION("Mac ESP SCSI driver");
-MODULE_AUTHOR("Finn Thain <fthain@telegraphics.com.au>");
+MODULE_AUTHOR("Finn Thain");
 MODULE_LICENSE("GPL v2");
 MODULE_VERSION(DRV_VERSION);
 MODULE_ALIAS("platform:" DRV_MODULE_NAME);

commit b36069c833d9440774d5daab143ec15ea026f34a
Author: Wolfram Sang <wsa@the-dreams.de>
Date:   Mon Oct 20 16:21:33 2014 +0200

    scsi: drop owner assignment from platform_drivers
    
    A platform_driver does not need to set an owner, it will be populated by the
    driver core.
    
    Signed-off-by: Wolfram Sang <wsa@the-dreams.de>

diff --git a/drivers/scsi/mac_esp.c b/drivers/scsi/mac_esp.c
index 994fc5caf036..14c0334f41e4 100644
--- a/drivers/scsi/mac_esp.c
+++ b/drivers/scsi/mac_esp.c
@@ -617,7 +617,6 @@ static struct platform_driver esp_mac_driver = {
 	.remove   = esp_mac_remove,
 	.driver   = {
 		.name	= DRV_MODULE_NAME,
-		.owner	= THIS_MODULE,
 	},
 };
 

commit 6f039790510fd630ff348efe8c4802dbaa041fba
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Fri Dec 21 13:08:55 2012 -0800

    Drivers: scsi: remove __dev* attributes.
    
    CONFIG_HOTPLUG is going away as an option.  As a result, the __dev*
    markings need to be removed.
    
    This change removes the use of __devinit, __devexit_p, __devinitdata,
    __devinitconst, and __devexit from these drivers.
    
    Based on patches originally written by Bill Pemberton, but redone by me
    in order to handle some of the coding style issues better, by hand.
    
    Cc: Bill Pemberton <wfp5p@virginia.edu>
    Cc: Adam Radford <linuxraid@lsi.com>
    Cc: "James E.J. Bottomley" <JBottomley@parallels.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/scsi/mac_esp.c b/drivers/scsi/mac_esp.c
index 70eb1f79b1ba..994fc5caf036 100644
--- a/drivers/scsi/mac_esp.c
+++ b/drivers/scsi/mac_esp.c
@@ -481,7 +481,7 @@ static struct esp_driver_ops mac_esp_ops = {
 	.dma_error        = mac_esp_dma_error,
 };
 
-static int __devinit esp_mac_probe(struct platform_device *dev)
+static int esp_mac_probe(struct platform_device *dev)
 {
 	struct scsi_host_template *tpnt = &scsi_esp_template;
 	struct Scsi_Host *host;
@@ -591,7 +591,7 @@ static int __devinit esp_mac_probe(struct platform_device *dev)
 	return err;
 }
 
-static int __devexit esp_mac_remove(struct platform_device *dev)
+static int esp_mac_remove(struct platform_device *dev)
 {
 	struct mac_esp_priv *mep = platform_get_drvdata(dev);
 	struct esp *esp = mep->esp;
@@ -614,7 +614,7 @@ static int __devexit esp_mac_remove(struct platform_device *dev)
 
 static struct platform_driver esp_mac_driver = {
 	.probe    = esp_mac_probe,
-	.remove   = __devexit_p(esp_mac_remove),
+	.remove   = esp_mac_remove,
 	.driver   = {
 		.name	= DRV_MODULE_NAME,
 		.owner	= THIS_MODULE,

commit c808d3d839ab70c87a6c9356c50569c87661378e
Author: Finn Thain <fthain@telegraphics.com.au>
Date:   Mon Oct 24 01:11:24 2011 +1100

    mac_esp: rename irq
    
    Rename the "Mac ESP" irq as "ESP" to be consistent with all the other Mac
    drivers and ESP drivers.
    
    Signed-off-by: Finn Thain <fthain@telegraphics.com.au>
    Signed-off-by: Geert Uytterhoeven <geert@linux-m68k.org>

diff --git a/drivers/scsi/mac_esp.c b/drivers/scsi/mac_esp.c
index 4ceeace80453..70eb1f79b1ba 100644
--- a/drivers/scsi/mac_esp.c
+++ b/drivers/scsi/mac_esp.c
@@ -565,8 +565,7 @@ static int __devinit esp_mac_probe(struct platform_device *dev)
 	esp_chips[dev->id] = esp;
 	mb();
 	if (esp_chips[!dev->id] == NULL) {
-		err = request_irq(host->irq, mac_scsi_esp_intr, 0,
-		                  "Mac ESP", NULL);
+		err = request_irq(host->irq, mac_scsi_esp_intr, 0, "ESP", NULL);
 		if (err < 0) {
 			esp_chips[dev->id] = NULL;
 			goto fail_free_priv;

commit 30c0527d15ce4edcde64581e9d062ba9fb08fe16
Author: Finn Thain <fthain@telegraphics.com.au>
Date:   Mon Oct 24 01:11:14 2011 +1100

    m68k/mac: cleanup mac_irq_pending
    
    mac_irq_pending() has only one caller (mac_esp.c). Nothing tests for Baboon, PSC or OSS pending interrupts. Until that need arises, let's keep it simple and remove all the unused abstraction. Replace it with a routine to check for SCSI DRQ.
    
    Signed-off-by: Finn Thain <fthain@telegraphics.com.au>
    Signed-off-by: Geert Uytterhoeven <geert@linux-m68k.org>

diff --git a/drivers/scsi/mac_esp.c b/drivers/scsi/mac_esp.c
index 590ce1ef2016..4ceeace80453 100644
--- a/drivers/scsi/mac_esp.c
+++ b/drivers/scsi/mac_esp.c
@@ -25,6 +25,7 @@
 #include <asm/dma.h>
 #include <asm/macints.h>
 #include <asm/macintosh.h>
+#include <asm/mac_via.h>
 
 #include <scsi/scsi_host.h>
 
@@ -149,7 +150,7 @@ static inline int mac_esp_wait_for_dreq(struct esp *esp)
 
 	do {
 		if (mep->pdma_regs == NULL) {
-			if (mac_irq_pending(IRQ_MAC_SCSIDRQ))
+			if (via2_scsi_drq_pending())
 				return 0;
 		} else {
 			if (nubus_readl(mep->pdma_regs) & 0x200)

commit e544d704f9bea6892808e453e219aa305bc0269a
Author: Finn Thain <fthain@telegraphics.com.au>
Date:   Sun Sep 11 19:57:51 2011 +1000

    [SCSI] mac_esp: remove redundant mutual exclusion
    
    Mutual exclusion is redundant here because all the paths in the call graph
    leading to esp_driver_ops.send_dma_cmd() happen under spin_lock_irqsave/
    spin_lock_irqrestore. Remove it.
    
    Tested on a Mac Quadra 660av and a Mac LC 630.
    
    Signed-off-by: Finn Thain <fthain@telegraphics.com.au>
    Signed-off-by: James Bottomley <JBottomley@Parallels.com>

diff --git a/drivers/scsi/mac_esp.c b/drivers/scsi/mac_esp.c
index 3893337e3dd3..590ce1ef2016 100644
--- a/drivers/scsi/mac_esp.c
+++ b/drivers/scsi/mac_esp.c
@@ -230,9 +230,6 @@ static void mac_esp_send_pdma_cmd(struct esp *esp, u32 addr, u32 esp_count,
 				  u32 dma_count, int write, u8 cmd)
 {
 	struct mac_esp_priv *mep = MAC_ESP_GET_PRIV(esp);
-	unsigned long flags;
-
-	local_irq_save(flags);
 
 	mep->error = 0;
 
@@ -270,8 +267,6 @@ static void mac_esp_send_pdma_cmd(struct esp *esp, u32 addr, u32 esp_count,
 			esp_count = n;
 		}
 	} while (esp_count);
-
-	local_irq_restore(flags);
 }
 
 /*
@@ -353,8 +348,6 @@ static void mac_esp_send_pio_cmd(struct esp *esp, u32 addr, u32 esp_count,
 	struct mac_esp_priv *mep = MAC_ESP_GET_PRIV(esp);
 	u8 *fifo = esp->regs + ESP_FDATA * 16;
 
-	disable_irq(esp->host->irq);
-
 	cmd &= ~ESP_CMD_DMA;
 	mep->error = 0;
 
@@ -431,8 +424,6 @@ static void mac_esp_send_pio_cmd(struct esp *esp, u32 addr, u32 esp_count,
 			scsi_esp_cmd(esp, ESP_CMD_TI);
 		}
 	}
-
-	enable_irq(esp->host->irq);
 }
 
 static int mac_esp_irq_pending(struct esp *esp)

commit 5a0e3ad6af8660be21ca98a971cd00f331318c05
Author: Tejun Heo <tj@kernel.org>
Date:   Wed Mar 24 17:04:11 2010 +0900

    include cleanup: Update gfp.h and slab.h includes to prepare for breaking implicit slab.h inclusion from percpu.h
    
    percpu.h is included by sched.h and module.h and thus ends up being
    included when building most .c files.  percpu.h includes slab.h which
    in turn includes gfp.h making everything defined by the two files
    universally available and complicating inclusion dependencies.
    
    percpu.h -> slab.h dependency is about to be removed.  Prepare for
    this change by updating users of gfp and slab facilities include those
    headers directly instead of assuming availability.  As this conversion
    needs to touch large number of source files, the following script is
    used as the basis of conversion.
    
      http://userweb.kernel.org/~tj/misc/slabh-sweep.py
    
    The script does the followings.
    
    * Scan files for gfp and slab usages and update includes such that
      only the necessary includes are there.  ie. if only gfp is used,
      gfp.h, if slab is used, slab.h.
    
    * When the script inserts a new include, it looks at the include
      blocks and try to put the new include such that its order conforms
      to its surrounding.  It's put in the include block which contains
      core kernel includes, in the same order that the rest are ordered -
      alphabetical, Christmas tree, rev-Xmas-tree or at the end if there
      doesn't seem to be any matching order.
    
    * If the script can't find a place to put a new include (mostly
      because the file doesn't have fitting include block), it prints out
      an error message indicating which .h file needs to be added to the
      file.
    
    The conversion was done in the following steps.
    
    1. The initial automatic conversion of all .c files updated slightly
       over 4000 files, deleting around 700 includes and adding ~480 gfp.h
       and ~3000 slab.h inclusions.  The script emitted errors for ~400
       files.
    
    2. Each error was manually checked.  Some didn't need the inclusion,
       some needed manual addition while adding it to implementation .h or
       embedding .c file was more appropriate for others.  This step added
       inclusions to around 150 files.
    
    3. The script was run again and the output was compared to the edits
       from #2 to make sure no file was left behind.
    
    4. Several build tests were done and a couple of problems were fixed.
       e.g. lib/decompress_*.c used malloc/free() wrappers around slab
       APIs requiring slab.h to be added manually.
    
    5. The script was run on all .h files but without automatically
       editing them as sprinkling gfp.h and slab.h inclusions around .h
       files could easily lead to inclusion dependency hell.  Most gfp.h
       inclusion directives were ignored as stuff from gfp.h was usually
       wildly available and often used in preprocessor macros.  Each
       slab.h inclusion directive was examined and added manually as
       necessary.
    
    6. percpu.h was updated not to include slab.h.
    
    7. Build test were done on the following configurations and failures
       were fixed.  CONFIG_GCOV_KERNEL was turned off for all tests (as my
       distributed build env didn't work with gcov compiles) and a few
       more options had to be turned off depending on archs to make things
       build (like ipr on powerpc/64 which failed due to missing writeq).
    
       * x86 and x86_64 UP and SMP allmodconfig and a custom test config.
       * powerpc and powerpc64 SMP allmodconfig
       * sparc and sparc64 SMP allmodconfig
       * ia64 SMP allmodconfig
       * s390 SMP allmodconfig
       * alpha SMP allmodconfig
       * um on x86_64 SMP allmodconfig
    
    8. percpu.h modifications were reverted so that it could be applied as
       a separate patch and serve as bisection point.
    
    Given the fact that I had only a couple of failures from tests on step
    6, I'm fairly confident about the coverage of this conversion patch.
    If there is a breakage, it's likely to be something in one of the arch
    headers which should be easily discoverable easily on most builds of
    the specific arch.
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Guess-its-ok-by: Christoph Lameter <cl@linux-foundation.org>
    Cc: Ingo Molnar <mingo@redhat.com>
    Cc: Lee Schermerhorn <Lee.Schermerhorn@hp.com>

diff --git a/drivers/scsi/mac_esp.c b/drivers/scsi/mac_esp.c
index 4a90eaf7cb63..3893337e3dd3 100644
--- a/drivers/scsi/mac_esp.c
+++ b/drivers/scsi/mac_esp.c
@@ -19,6 +19,7 @@
 #include <linux/delay.h>
 #include <linux/io.h>
 #include <linux/nubus.h>
+#include <linux/slab.h>
 
 #include <asm/irq.h>
 #include <asm/dma.h>

commit cff75f1fb1f28eba3facb7dbe9b40a892912578a
Author: Finn Thain <fthain@telegraphics.com.au>
Date:   Wed Nov 4 00:41:35 2009 +1100

    mac68k: move mac_esp platform device
    
    Move platform device code from the driver to the platform init function.
    
    Signed-off-by: Finn Thain <fthain@telegraphics.com.au>
    Signed-off-by: Geert Uytterhoeven <geert@linux-m68k.org>

diff --git a/drivers/scsi/mac_esp.c b/drivers/scsi/mac_esp.c
index dd808ae942a1..4a90eaf7cb63 100644
--- a/drivers/scsi/mac_esp.c
+++ b/drivers/scsi/mac_esp.c
@@ -52,7 +52,6 @@ struct mac_esp_priv {
 	void __iomem *pdma_io;
 	int error;
 };
-static struct platform_device *internal_pdev, *external_pdev;
 static struct esp *esp_chips[2];
 
 #define MAC_ESP_GET_PRIV(esp) ((struct mac_esp_priv *) \
@@ -495,29 +494,12 @@ static int __devinit esp_mac_probe(struct platform_device *dev)
 	struct Scsi_Host *host;
 	struct esp *esp;
 	int err;
-	int chips_present;
 	struct mac_esp_priv *mep;
 
 	if (!MACH_IS_MAC)
 		return -ENODEV;
 
-	switch (macintosh_config->scsi_type) {
-	case MAC_SCSI_QUADRA:
-	case MAC_SCSI_QUADRA3:
-		chips_present = 1;
-		break;
-	case MAC_SCSI_QUADRA2:
-		if ((macintosh_config->ident == MAC_MODEL_Q900) ||
-		    (macintosh_config->ident == MAC_MODEL_Q950))
-			chips_present = 2;
-		else
-			chips_present = 1;
-		break;
-	default:
-		chips_present = 0;
-	}
-
-	if (dev->id + 1 > chips_present)
+	if (dev->id > 1)
 		return -ENODEV;
 
 	host = scsi_host_alloc(tpnt, sizeof(struct esp));
@@ -642,55 +624,26 @@ static struct platform_driver esp_mac_driver = {
 	.probe    = esp_mac_probe,
 	.remove   = __devexit_p(esp_mac_remove),
 	.driver   = {
-		.name     = DRV_MODULE_NAME,
+		.name	= DRV_MODULE_NAME,
+		.owner	= THIS_MODULE,
 	},
 };
 
 static int __init mac_esp_init(void)
 {
-	int err;
-
-	err = platform_driver_register(&esp_mac_driver);
-	if (err)
-		return err;
-
-	internal_pdev = platform_device_alloc(DRV_MODULE_NAME, 0);
-	if (internal_pdev && platform_device_add(internal_pdev)) {
-		platform_device_put(internal_pdev);
-		internal_pdev = NULL;
-	}
-	external_pdev = platform_device_alloc(DRV_MODULE_NAME, 1);
-	if (external_pdev && platform_device_add(external_pdev)) {
-		platform_device_put(external_pdev);
-		external_pdev = NULL;
-	}
-
-	if (internal_pdev || external_pdev) {
-		return 0;
-	} else {
-		platform_driver_unregister(&esp_mac_driver);
-		return -ENOMEM;
-	}
+	return platform_driver_register(&esp_mac_driver);
 }
 
 static void __exit mac_esp_exit(void)
 {
 	platform_driver_unregister(&esp_mac_driver);
-
-	if (internal_pdev) {
-		platform_device_unregister(internal_pdev);
-		internal_pdev = NULL;
-	}
-	if (external_pdev) {
-		platform_device_unregister(external_pdev);
-		external_pdev = NULL;
-	}
 }
 
 MODULE_DESCRIPTION("Mac ESP SCSI driver");
 MODULE_AUTHOR("Finn Thain <fthain@telegraphics.com.au>");
 MODULE_LICENSE("GPL v2");
 MODULE_VERSION(DRV_VERSION);
+MODULE_ALIAS("platform:" DRV_MODULE_NAME);
 
 module_init(mac_esp_init);
 module_exit(mac_esp_exit);

commit 02507a80b35edd720480540d917e9f92cc371009
Author: Finn Thain <fthain@telegraphics.com.au>
Date:   Sat Dec 5 12:30:42 2009 +1100

    [SCSI] mac_esp: fix PIO mode, take 2
    
    The mac_esp PIO algorithm no longer works in 2.6.31 and crashes my Centris
    660av. So here's a better one.
    
    Also, force async with esp_set_offset() rather than esp_slave_configure().
    
    One of the SCSI drives I tested still doesn't like the PIO mode and fails
    with "esp: esp0: Reconnect IRQ2 timeout" (the same drive works fine in
    PDMA mode).
    
    This failure happens when esp_reconnect_with_tag() tries to read in two
    tag bytes but the chip only provides one (0x20). I don't know what causes
    this. I decided not to waste any more time trying to fix it because the
    best solution is to rip out the PIO mode altogether and use the DMA
    engine.
    
    Signed-off-by: Finn Thain <fthain@telegraphics.com.au>
    Signed-off-by: James Bottomley <James.Bottomley@suse.de>

diff --git a/drivers/scsi/mac_esp.c b/drivers/scsi/mac_esp.c
index c24e86f07804..dd808ae942a1 100644
--- a/drivers/scsi/mac_esp.c
+++ b/drivers/scsi/mac_esp.c
@@ -22,7 +22,6 @@
 
 #include <asm/irq.h>
 #include <asm/dma.h>
-
 #include <asm/macints.h>
 #include <asm/macintosh.h>
 
@@ -279,24 +278,27 @@ static void mac_esp_send_pdma_cmd(struct esp *esp, u32 addr, u32 esp_count,
  * Programmed IO routines follow.
  */
 
-static inline int mac_esp_wait_for_fifo(struct esp *esp)
+static inline unsigned int mac_esp_wait_for_fifo(struct esp *esp)
 {
 	int i = 500000;
 
 	do {
-		if (esp_read8(ESP_FFLAGS) & ESP_FF_FBYTES)
-			return 0;
+		unsigned int fbytes = esp_read8(ESP_FFLAGS) & ESP_FF_FBYTES;
+
+		if (fbytes)
+			return fbytes;
 
 		udelay(2);
 	} while (--i);
 
 	printk(KERN_ERR PFX "FIFO is empty (sreg %02x)\n",
 	       esp_read8(ESP_STATUS));
-	return 1;
+	return 0;
 }
 
 static inline int mac_esp_wait_for_intr(struct esp *esp)
 {
+	struct mac_esp_priv *mep = MAC_ESP_GET_PRIV(esp);
 	int i = 500000;
 
 	do {
@@ -308,6 +310,7 @@ static inline int mac_esp_wait_for_intr(struct esp *esp)
 	} while (--i);
 
 	printk(KERN_ERR PFX "IRQ timeout (sreg %02x)\n", esp->sreg);
+	mep->error = 1;
 	return 1;
 }
 
@@ -347,11 +350,10 @@ static inline int mac_esp_wait_for_intr(struct esp *esp)
 static void mac_esp_send_pio_cmd(struct esp *esp, u32 addr, u32 esp_count,
 				 u32 dma_count, int write, u8 cmd)
 {
-	unsigned long flags;
 	struct mac_esp_priv *mep = MAC_ESP_GET_PRIV(esp);
 	u8 *fifo = esp->regs + ESP_FDATA * 16;
 
-	local_irq_save(flags);
+	disable_irq(esp->host->irq);
 
 	cmd &= ~ESP_CMD_DMA;
 	mep->error = 0;
@@ -359,11 +361,35 @@ static void mac_esp_send_pio_cmd(struct esp *esp, u32 addr, u32 esp_count,
 	if (write) {
 		scsi_esp_cmd(esp, cmd);
 
-		if (!mac_esp_wait_for_intr(esp)) {
-			if (mac_esp_wait_for_fifo(esp))
-				esp_count = 0;
-		} else {
-			esp_count = 0;
+		while (1) {
+			unsigned int n;
+
+			n = mac_esp_wait_for_fifo(esp);
+			if (!n)
+				break;
+
+			if (n > esp_count)
+				n = esp_count;
+			esp_count -= n;
+
+			MAC_ESP_PIO_LOOP("%2@,%0@+", n);
+
+			if (!esp_count)
+				break;
+
+			if (mac_esp_wait_for_intr(esp))
+				break;
+
+			if (((esp->sreg & ESP_STAT_PMASK) != ESP_DIP) &&
+			    ((esp->sreg & ESP_STAT_PMASK) != ESP_MIP))
+				break;
+
+			esp->ireg = esp_read8(ESP_INTRPT);
+			if ((esp->ireg & (ESP_INTR_DC | ESP_INTR_BSERV)) !=
+			    ESP_INTR_BSERV)
+				break;
+
+			scsi_esp_cmd(esp, ESP_CMD_TI);
 		}
 	} else {
 		scsi_esp_cmd(esp, ESP_CMD_FLUSH);
@@ -374,47 +400,24 @@ static void mac_esp_send_pio_cmd(struct esp *esp, u32 addr, u32 esp_count,
 			MAC_ESP_PIO_LOOP("%0@+,%2@", esp_count);
 
 		scsi_esp_cmd(esp, cmd);
-	}
-
-	while (esp_count) {
-		unsigned int n;
-
-		if (mac_esp_wait_for_intr(esp)) {
-			mep->error = 1;
-			break;
-		}
-
-		if (esp->sreg & ESP_STAT_SPAM) {
-			printk(KERN_ERR PFX "gross error\n");
-			mep->error = 1;
-			break;
-		}
 
-		n = esp_read8(ESP_FFLAGS) & ESP_FF_FBYTES;
-
-		if (write) {
-			if (n > esp_count)
-				n = esp_count;
-			esp_count -= n;
-
-			MAC_ESP_PIO_LOOP("%2@,%0@+", n);
+		while (esp_count) {
+			unsigned int n;
 
-			if ((esp->sreg & ESP_STAT_PMASK) == ESP_STATP)
+			if (mac_esp_wait_for_intr(esp))
 				break;
 
-			if (esp_count) {
-				esp->ireg = esp_read8(ESP_INTRPT);
-				if (esp->ireg & ESP_INTR_DC)
-					break;
+			if (((esp->sreg & ESP_STAT_PMASK) != ESP_DOP) &&
+			    ((esp->sreg & ESP_STAT_PMASK) != ESP_MOP))
+				break;
 
-				scsi_esp_cmd(esp, ESP_CMD_TI);
-			}
-		} else {
 			esp->ireg = esp_read8(ESP_INTRPT);
-			if (esp->ireg & ESP_INTR_DC)
+			if ((esp->ireg & (ESP_INTR_DC | ESP_INTR_BSERV)) !=
+			    ESP_INTR_BSERV)
 				break;
 
-			n = MAC_ESP_FIFO_SIZE - n;
+			n = MAC_ESP_FIFO_SIZE -
+			    (esp_read8(ESP_FFLAGS) & ESP_FF_FBYTES);
 			if (n > esp_count)
 				n = esp_count;
 
@@ -429,7 +432,7 @@ static void mac_esp_send_pio_cmd(struct esp *esp, u32 addr, u32 esp_count,
 		}
 	}
 
-	local_irq_restore(flags);
+	enable_irq(esp->host->irq);
 }
 
 static int mac_esp_irq_pending(struct esp *esp)

commit da244654c66e78e03668863974ec74c981934c38
Author: Finn Thain <fthain@telegraphics.com.au>
Date:   Mon Nov 17 21:37:45 2008 +0100

    [SCSI] mac_esp: fix for quadras with two esp chips
    
    On the Quadra 900 and 950 there are two ESP chips sharing one IRQ. Because
    the shared IRQ is edge-triggered, we must make sure that an IRQ transition
    from one chip doesn't go unnoticed when the shared IRQ is already active
    due to the other. This patch prevents interrupts getting lost so that both
    SCSI busses may be used simultaneously.
    
    Signed-off-by: Finn Thain <fthain@telegraphics.com.au>
    Signed-off-by: Geert Uytterhoeven <geert@linux-m68k.org>
    Signed-off-by: James Bottomley <James.Bottomley@HansenPartnership.com>

diff --git a/drivers/scsi/mac_esp.c b/drivers/scsi/mac_esp.c
index a99f9ce6be55..c24e86f07804 100644
--- a/drivers/scsi/mac_esp.c
+++ b/drivers/scsi/mac_esp.c
@@ -53,7 +53,8 @@ struct mac_esp_priv {
 	void __iomem *pdma_io;
 	int error;
 };
-static struct platform_device *internal_esp, *external_esp;
+static struct platform_device *internal_pdev, *external_pdev;
+static struct esp *esp_chips[2];
 
 #define MAC_ESP_GET_PRIV(esp) ((struct mac_esp_priv *) \
 			       platform_get_drvdata((struct platform_device *) \
@@ -443,6 +444,32 @@ static u32 mac_esp_dma_length_limit(struct esp *esp, u32 dma_addr, u32 dma_len)
 	return dma_len > 0xFFFF ? 0xFFFF : dma_len;
 }
 
+static irqreturn_t mac_scsi_esp_intr(int irq, void *dev_id)
+{
+	int got_intr;
+
+	/*
+	 * This is an edge triggered IRQ, so we have to be careful to
+	 * avoid missing a transition when it is shared by two ESP devices.
+	 */
+
+	do {
+		got_intr = 0;
+		if (esp_chips[0] &&
+		    (mac_esp_read8(esp_chips[0], ESP_STATUS) & ESP_STAT_INTR)) {
+			(void)scsi_esp_intr(irq, esp_chips[0]);
+			got_intr = 1;
+		}
+		if (esp_chips[1] &&
+		    (mac_esp_read8(esp_chips[1], ESP_STATUS) & ESP_STAT_INTR)) {
+			(void)scsi_esp_intr(irq, esp_chips[1]);
+			got_intr = 1;
+		}
+	} while (got_intr);
+
+	return IRQ_HANDLED;
+}
+
 static struct esp_driver_ops mac_esp_ops = {
 	.esp_write8       = mac_esp_write8,
 	.esp_read8        = mac_esp_read8,
@@ -557,10 +584,16 @@ static int __devinit esp_mac_probe(struct platform_device *dev)
 	}
 
 	host->irq = IRQ_MAC_SCSI;
-	err = request_irq(host->irq, scsi_esp_intr, IRQF_SHARED, "Mac ESP",
-			  esp);
-	if (err < 0)
-		goto fail_free_priv;
+	esp_chips[dev->id] = esp;
+	mb();
+	if (esp_chips[!dev->id] == NULL) {
+		err = request_irq(host->irq, mac_scsi_esp_intr, 0,
+		                  "Mac ESP", NULL);
+		if (err < 0) {
+			esp_chips[dev->id] = NULL;
+			goto fail_free_priv;
+		}
+	}
 
 	err = scsi_esp_register(esp, &dev->dev);
 	if (err)
@@ -569,7 +602,8 @@ static int __devinit esp_mac_probe(struct platform_device *dev)
 	return 0;
 
 fail_free_irq:
-	free_irq(host->irq, esp);
+	if (esp_chips[!dev->id] == NULL)
+		free_irq(host->irq, esp);
 fail_free_priv:
 	kfree(mep);
 fail_free_command_block:
@@ -588,7 +622,9 @@ static int __devexit esp_mac_remove(struct platform_device *dev)
 
 	scsi_esp_unregister(esp);
 
-	free_irq(irq, esp);
+	esp_chips[dev->id] = NULL;
+	if (!(esp_chips[0] || esp_chips[1]))
+		free_irq(irq, NULL);
 
 	kfree(mep);
 
@@ -615,19 +651,18 @@ static int __init mac_esp_init(void)
 	if (err)
 		return err;
 
-	internal_esp = platform_device_alloc(DRV_MODULE_NAME, 0);
-	if (internal_esp && platform_device_add(internal_esp)) {
-		platform_device_put(internal_esp);
-		internal_esp = NULL;
+	internal_pdev = platform_device_alloc(DRV_MODULE_NAME, 0);
+	if (internal_pdev && platform_device_add(internal_pdev)) {
+		platform_device_put(internal_pdev);
+		internal_pdev = NULL;
 	}
-
-	external_esp = platform_device_alloc(DRV_MODULE_NAME, 1);
-	if (external_esp && platform_device_add(external_esp)) {
-		platform_device_put(external_esp);
-		external_esp = NULL;
+	external_pdev = platform_device_alloc(DRV_MODULE_NAME, 1);
+	if (external_pdev && platform_device_add(external_pdev)) {
+		platform_device_put(external_pdev);
+		external_pdev = NULL;
 	}
 
-	if (internal_esp || external_esp) {
+	if (internal_pdev || external_pdev) {
 		return 0;
 	} else {
 		platform_driver_unregister(&esp_mac_driver);
@@ -639,13 +674,13 @@ static void __exit mac_esp_exit(void)
 {
 	platform_driver_unregister(&esp_mac_driver);
 
-	if (internal_esp) {
-		platform_device_unregister(internal_esp);
-		internal_esp = NULL;
+	if (internal_pdev) {
+		platform_device_unregister(internal_pdev);
+		internal_pdev = NULL;
 	}
-	if (external_esp) {
-		platform_device_unregister(external_esp);
-		external_esp = NULL;
+	if (external_pdev) {
+		platform_device_unregister(external_pdev);
+		external_pdev = NULL;
 	}
 }
 

commit 09e13e91670b69736b5da0a869a076a55a326394
Author: Finn Thain <fthain@telegraphics.com.au>
Date:   Mon Nov 17 21:37:07 2008 +0100

    [SCSI] m68k: mac_esp asm fix
    
    Fix asm constraints and arguments so as not to transfer an odd byte when
    there may be more words to transfer. The bug would probably also cause
    exceptions sometimes by transferring one too many bytes.
    
    Signed-off-by: Finn Thain <fthain@telegraphics.com.au>
    Signed-off-by: Geert Uytterhoeven <geert@linux-m68k.org>
    Signed-off-by: James Bottomley <James.Bottomley@HansenPartnership.com>

diff --git a/drivers/scsi/mac_esp.c b/drivers/scsi/mac_esp.c
index 887682a24e36..a99f9ce6be55 100644
--- a/drivers/scsi/mac_esp.c
+++ b/drivers/scsi/mac_esp.c
@@ -170,7 +170,7 @@ static inline int mac_esp_wait_for_dreq(struct esp *esp)
 
 #define MAC_ESP_PDMA_LOOP(operands) \
 	asm volatile ( \
-	     "       tstw %2                   \n" \
+	     "       tstw %1                   \n" \
 	     "       jbeq 20f                  \n" \
 	     "1:     movew " operands "        \n" \
 	     "2:     movew " operands "        \n" \
@@ -188,14 +188,14 @@ static inline int mac_esp_wait_for_dreq(struct esp *esp)
 	     "14:    movew " operands "        \n" \
 	     "15:    movew " operands "        \n" \
 	     "16:    movew " operands "        \n" \
-	     "       subqw #1,%2               \n" \
+	     "       subqw #1,%1               \n" \
 	     "       jbne 1b                   \n" \
-	     "20:    tstw %3                   \n" \
+	     "20:    tstw %2                   \n" \
 	     "       jbeq 30f                  \n" \
 	     "21:    movew " operands "        \n" \
-	     "       subqw #1,%3               \n" \
+	     "       subqw #1,%2               \n" \
 	     "       jbne 21b                  \n" \
-	     "30:    tstw %4                   \n" \
+	     "30:    tstw %3                   \n" \
 	     "       jbeq 40f                  \n" \
 	     "31:    moveb " operands "        \n" \
 	     "32:    nop                       \n" \
@@ -223,8 +223,8 @@ static inline int mac_esp_wait_for_dreq(struct esp *esp)
 	     "       .long  31b,40b            \n" \
 	     "       .long  32b,40b            \n" \
 	     "       .previous                 \n" \
-	     : "+a" (addr) \
-	     : "a" (mep->pdma_io), "r" (count32), "r" (count2), "g" (esp_count))
+	     : "+a" (addr), "+r" (count32), "+r" (count2) \
+	     : "g" (count1), "a" (mep->pdma_io))
 
 static void mac_esp_send_pdma_cmd(struct esp *esp, u32 addr, u32 esp_count,
 				  u32 dma_count, int write, u8 cmd)
@@ -247,19 +247,20 @@ static void mac_esp_send_pdma_cmd(struct esp *esp, u32 addr, u32 esp_count,
 	do {
 		unsigned int count32 = esp_count >> 5;
 		unsigned int count2 = (esp_count & 0x1F) >> 1;
+		unsigned int count1 = esp_count & 1;
 		unsigned int start_addr = addr;
 
 		if (mac_esp_wait_for_dreq(esp))
 			break;
 
 		if (write) {
-			MAC_ESP_PDMA_LOOP("%1@,%0@+");
+			MAC_ESP_PDMA_LOOP("%4@,%0@+");
 
 			esp_count -= addr - start_addr;
 		} else {
 			unsigned int n;
 
-			MAC_ESP_PDMA_LOOP("%0@+,%1@");
+			MAC_ESP_PDMA_LOOP("%0@+,%4@");
 
 			if (mac_esp_wait_for_empty_fifo(esp))
 				break;

commit 839cd31050096c88d929cc7c790c80cae87e2d85
Author: Al Viro <viro@ftp.linux.org.uk>
Date:   Wed May 21 06:32:11 2008 +0100

    MODULE_LICENSE expects "GPL v2", not "GPLv2"
    
    ... and we have few enough places using the latter to make it
    simpler to do search and replace...
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/scsi/mac_esp.c b/drivers/scsi/mac_esp.c
index cd37bd69a115..887682a24e36 100644
--- a/drivers/scsi/mac_esp.c
+++ b/drivers/scsi/mac_esp.c
@@ -650,7 +650,7 @@ static void __exit mac_esp_exit(void)
 
 MODULE_DESCRIPTION("Mac ESP SCSI driver");
 MODULE_AUTHOR("Finn Thain <fthain@telegraphics.com.au>");
-MODULE_LICENSE("GPLv2");
+MODULE_LICENSE("GPL v2");
 MODULE_VERSION(DRV_VERSION);
 
 module_init(mac_esp_init);

commit 6fe07aaffbf086a0ce9134ef27ce4a8921ff5947
Author: Finn Thain <fthain@telegraphics.com.au>
Date:   Fri Apr 25 10:06:05 2008 -0500

    [SCSI] m68k: new mac_esp scsi driver
    
    Replace the mac_esp driver with a new one based on the esp_scsi core.
    
    For esp_scsi: add support for sync transfers for the PIO mode, add a new
    esp_driver_ops method to get the maximum dma transfer size (like the old
    NCR53C9x driver), and some cleanups.
    
    Signed-off-by: Finn Thain <fthain@telegraphics.com.au>
    Acked-by: David S. Miller <davem@davemloft.net>
    Signed-off-by: Geert Uytterhoeven <geert@linux-m68k.org>
    Signed-off-by: James Bottomley <James.Bottomley@HansenPartnership.com>

diff --git a/drivers/scsi/mac_esp.c b/drivers/scsi/mac_esp.c
new file mode 100644
index 000000000000..cd37bd69a115
--- /dev/null
+++ b/drivers/scsi/mac_esp.c
@@ -0,0 +1,657 @@
+/* mac_esp.c: ESP front-end for Macintosh Quadra systems.
+ *
+ * Adapted from jazz_esp.c and the old mac_esp.c.
+ *
+ * The pseudo DMA algorithm is based on the one used in NetBSD.
+ * See sys/arch/mac68k/obio/esp.c for some background information.
+ *
+ * Copyright (C) 2007-2008 Finn Thain
+ */
+
+#include <linux/kernel.h>
+#include <linux/types.h>
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/interrupt.h>
+#include <linux/platform_device.h>
+#include <linux/dma-mapping.h>
+#include <linux/scatterlist.h>
+#include <linux/delay.h>
+#include <linux/io.h>
+#include <linux/nubus.h>
+
+#include <asm/irq.h>
+#include <asm/dma.h>
+
+#include <asm/macints.h>
+#include <asm/macintosh.h>
+
+#include <scsi/scsi_host.h>
+
+#include "esp_scsi.h"
+
+#define DRV_MODULE_NAME     "mac_esp"
+#define PFX                 DRV_MODULE_NAME ": "
+#define DRV_VERSION         "1.000"
+#define DRV_MODULE_RELDATE  "Sept 15, 2007"
+
+#define MAC_ESP_IO_BASE          0x50F00000
+#define MAC_ESP_REGS_QUADRA      (MAC_ESP_IO_BASE + 0x10000)
+#define MAC_ESP_REGS_QUADRA2     (MAC_ESP_IO_BASE + 0xF000)
+#define MAC_ESP_REGS_QUADRA3     (MAC_ESP_IO_BASE + 0x18000)
+#define MAC_ESP_REGS_SPACING     0x402
+#define MAC_ESP_PDMA_REG         0xF9800024
+#define MAC_ESP_PDMA_REG_SPACING 0x4
+#define MAC_ESP_PDMA_IO_OFFSET   0x100
+
+#define esp_read8(REG)		mac_esp_read8(esp, REG)
+#define esp_write8(VAL, REG)	mac_esp_write8(esp, VAL, REG)
+
+struct mac_esp_priv {
+	struct esp *esp;
+	void __iomem *pdma_regs;
+	void __iomem *pdma_io;
+	int error;
+};
+static struct platform_device *internal_esp, *external_esp;
+
+#define MAC_ESP_GET_PRIV(esp) ((struct mac_esp_priv *) \
+			       platform_get_drvdata((struct platform_device *) \
+						    (esp->dev)))
+
+static inline void mac_esp_write8(struct esp *esp, u8 val, unsigned long reg)
+{
+	nubus_writeb(val, esp->regs + reg * 16);
+}
+
+static inline u8 mac_esp_read8(struct esp *esp, unsigned long reg)
+{
+	return nubus_readb(esp->regs + reg * 16);
+}
+
+/* For pseudo DMA and PIO we need the virtual address
+ * so this address mapping is the identity mapping.
+ */
+
+static dma_addr_t mac_esp_map_single(struct esp *esp, void *buf,
+				     size_t sz, int dir)
+{
+	return (dma_addr_t)buf;
+}
+
+static int mac_esp_map_sg(struct esp *esp, struct scatterlist *sg,
+			  int num_sg, int dir)
+{
+	int i;
+
+	for (i = 0; i < num_sg; i++)
+		sg[i].dma_address = (u32)sg_virt(&sg[i]);
+	return num_sg;
+}
+
+static void mac_esp_unmap_single(struct esp *esp, dma_addr_t addr,
+				 size_t sz, int dir)
+{
+	/* Nothing to do. */
+}
+
+static void mac_esp_unmap_sg(struct esp *esp, struct scatterlist *sg,
+			     int num_sg, int dir)
+{
+	/* Nothing to do. */
+}
+
+static void mac_esp_reset_dma(struct esp *esp)
+{
+	/* Nothing to do. */
+}
+
+static void mac_esp_dma_drain(struct esp *esp)
+{
+	/* Nothing to do. */
+}
+
+static void mac_esp_dma_invalidate(struct esp *esp)
+{
+	/* Nothing to do. */
+}
+
+static int mac_esp_dma_error(struct esp *esp)
+{
+	return MAC_ESP_GET_PRIV(esp)->error;
+}
+
+static inline int mac_esp_wait_for_empty_fifo(struct esp *esp)
+{
+	struct mac_esp_priv *mep = MAC_ESP_GET_PRIV(esp);
+	int i = 500000;
+
+	do {
+		if (!(esp_read8(ESP_FFLAGS) & ESP_FF_FBYTES))
+			return 0;
+
+		if (esp_read8(ESP_STATUS) & ESP_STAT_INTR)
+			return 1;
+
+		udelay(2);
+	} while (--i);
+
+	printk(KERN_ERR PFX "FIFO is not empty (sreg %02x)\n",
+	       esp_read8(ESP_STATUS));
+	mep->error = 1;
+	return 1;
+}
+
+static inline int mac_esp_wait_for_dreq(struct esp *esp)
+{
+	struct mac_esp_priv *mep = MAC_ESP_GET_PRIV(esp);
+	int i = 500000;
+
+	do {
+		if (mep->pdma_regs == NULL) {
+			if (mac_irq_pending(IRQ_MAC_SCSIDRQ))
+				return 0;
+		} else {
+			if (nubus_readl(mep->pdma_regs) & 0x200)
+				return 0;
+		}
+
+		if (esp_read8(ESP_STATUS) & ESP_STAT_INTR)
+			return 1;
+
+		udelay(2);
+	} while (--i);
+
+	printk(KERN_ERR PFX "PDMA timeout (sreg %02x)\n",
+	       esp_read8(ESP_STATUS));
+	mep->error = 1;
+	return 1;
+}
+
+#define MAC_ESP_PDMA_LOOP(operands) \
+	asm volatile ( \
+	     "       tstw %2                   \n" \
+	     "       jbeq 20f                  \n" \
+	     "1:     movew " operands "        \n" \
+	     "2:     movew " operands "        \n" \
+	     "3:     movew " operands "        \n" \
+	     "4:     movew " operands "        \n" \
+	     "5:     movew " operands "        \n" \
+	     "6:     movew " operands "        \n" \
+	     "7:     movew " operands "        \n" \
+	     "8:     movew " operands "        \n" \
+	     "9:     movew " operands "        \n" \
+	     "10:    movew " operands "        \n" \
+	     "11:    movew " operands "        \n" \
+	     "12:    movew " operands "        \n" \
+	     "13:    movew " operands "        \n" \
+	     "14:    movew " operands "        \n" \
+	     "15:    movew " operands "        \n" \
+	     "16:    movew " operands "        \n" \
+	     "       subqw #1,%2               \n" \
+	     "       jbne 1b                   \n" \
+	     "20:    tstw %3                   \n" \
+	     "       jbeq 30f                  \n" \
+	     "21:    movew " operands "        \n" \
+	     "       subqw #1,%3               \n" \
+	     "       jbne 21b                  \n" \
+	     "30:    tstw %4                   \n" \
+	     "       jbeq 40f                  \n" \
+	     "31:    moveb " operands "        \n" \
+	     "32:    nop                       \n" \
+	     "40:                              \n" \
+	     "                                 \n" \
+	     "       .section __ex_table,\"a\" \n" \
+	     "       .align  4                 \n" \
+	     "       .long   1b,40b            \n" \
+	     "       .long   2b,40b            \n" \
+	     "       .long   3b,40b            \n" \
+	     "       .long   4b,40b            \n" \
+	     "       .long   5b,40b            \n" \
+	     "       .long   6b,40b            \n" \
+	     "       .long   7b,40b            \n" \
+	     "       .long   8b,40b            \n" \
+	     "       .long   9b,40b            \n" \
+	     "       .long  10b,40b            \n" \
+	     "       .long  11b,40b            \n" \
+	     "       .long  12b,40b            \n" \
+	     "       .long  13b,40b            \n" \
+	     "       .long  14b,40b            \n" \
+	     "       .long  15b,40b            \n" \
+	     "       .long  16b,40b            \n" \
+	     "       .long  21b,40b            \n" \
+	     "       .long  31b,40b            \n" \
+	     "       .long  32b,40b            \n" \
+	     "       .previous                 \n" \
+	     : "+a" (addr) \
+	     : "a" (mep->pdma_io), "r" (count32), "r" (count2), "g" (esp_count))
+
+static void mac_esp_send_pdma_cmd(struct esp *esp, u32 addr, u32 esp_count,
+				  u32 dma_count, int write, u8 cmd)
+{
+	struct mac_esp_priv *mep = MAC_ESP_GET_PRIV(esp);
+	unsigned long flags;
+
+	local_irq_save(flags);
+
+	mep->error = 0;
+
+	if (!write)
+		scsi_esp_cmd(esp, ESP_CMD_FLUSH);
+
+	esp_write8((esp_count >> 0) & 0xFF, ESP_TCLOW);
+	esp_write8((esp_count >> 8) & 0xFF, ESP_TCMED);
+
+	scsi_esp_cmd(esp, cmd);
+
+	do {
+		unsigned int count32 = esp_count >> 5;
+		unsigned int count2 = (esp_count & 0x1F) >> 1;
+		unsigned int start_addr = addr;
+
+		if (mac_esp_wait_for_dreq(esp))
+			break;
+
+		if (write) {
+			MAC_ESP_PDMA_LOOP("%1@,%0@+");
+
+			esp_count -= addr - start_addr;
+		} else {
+			unsigned int n;
+
+			MAC_ESP_PDMA_LOOP("%0@+,%1@");
+
+			if (mac_esp_wait_for_empty_fifo(esp))
+				break;
+
+			n = (esp_read8(ESP_TCMED) << 8) + esp_read8(ESP_TCLOW);
+			addr = start_addr + esp_count - n;
+			esp_count = n;
+		}
+	} while (esp_count);
+
+	local_irq_restore(flags);
+}
+
+/*
+ * Programmed IO routines follow.
+ */
+
+static inline int mac_esp_wait_for_fifo(struct esp *esp)
+{
+	int i = 500000;
+
+	do {
+		if (esp_read8(ESP_FFLAGS) & ESP_FF_FBYTES)
+			return 0;
+
+		udelay(2);
+	} while (--i);
+
+	printk(KERN_ERR PFX "FIFO is empty (sreg %02x)\n",
+	       esp_read8(ESP_STATUS));
+	return 1;
+}
+
+static inline int mac_esp_wait_for_intr(struct esp *esp)
+{
+	int i = 500000;
+
+	do {
+		esp->sreg = esp_read8(ESP_STATUS);
+		if (esp->sreg & ESP_STAT_INTR)
+			return 0;
+
+		udelay(2);
+	} while (--i);
+
+	printk(KERN_ERR PFX "IRQ timeout (sreg %02x)\n", esp->sreg);
+	return 1;
+}
+
+#define MAC_ESP_PIO_LOOP(operands, reg1) \
+	asm volatile ( \
+	     "1:     moveb " operands " \n" \
+	     "       subqw #1,%1        \n" \
+	     "       jbne 1b            \n" \
+	     : "+a" (addr), "+r" (reg1) \
+	     : "a" (fifo))
+
+#define MAC_ESP_PIO_FILL(operands, reg1) \
+	asm volatile ( \
+	     "       moveb " operands " \n" \
+	     "       moveb " operands " \n" \
+	     "       moveb " operands " \n" \
+	     "       moveb " operands " \n" \
+	     "       moveb " operands " \n" \
+	     "       moveb " operands " \n" \
+	     "       moveb " operands " \n" \
+	     "       moveb " operands " \n" \
+	     "       moveb " operands " \n" \
+	     "       moveb " operands " \n" \
+	     "       moveb " operands " \n" \
+	     "       moveb " operands " \n" \
+	     "       moveb " operands " \n" \
+	     "       moveb " operands " \n" \
+	     "       moveb " operands " \n" \
+	     "       moveb " operands " \n" \
+	     "       subqw #8,%1        \n" \
+	     "       subqw #8,%1        \n" \
+	     : "+a" (addr), "+r" (reg1) \
+	     : "a" (fifo))
+
+#define MAC_ESP_FIFO_SIZE 16
+
+static void mac_esp_send_pio_cmd(struct esp *esp, u32 addr, u32 esp_count,
+				 u32 dma_count, int write, u8 cmd)
+{
+	unsigned long flags;
+	struct mac_esp_priv *mep = MAC_ESP_GET_PRIV(esp);
+	u8 *fifo = esp->regs + ESP_FDATA * 16;
+
+	local_irq_save(flags);
+
+	cmd &= ~ESP_CMD_DMA;
+	mep->error = 0;
+
+	if (write) {
+		scsi_esp_cmd(esp, cmd);
+
+		if (!mac_esp_wait_for_intr(esp)) {
+			if (mac_esp_wait_for_fifo(esp))
+				esp_count = 0;
+		} else {
+			esp_count = 0;
+		}
+	} else {
+		scsi_esp_cmd(esp, ESP_CMD_FLUSH);
+
+		if (esp_count >= MAC_ESP_FIFO_SIZE)
+			MAC_ESP_PIO_FILL("%0@+,%2@", esp_count);
+		else
+			MAC_ESP_PIO_LOOP("%0@+,%2@", esp_count);
+
+		scsi_esp_cmd(esp, cmd);
+	}
+
+	while (esp_count) {
+		unsigned int n;
+
+		if (mac_esp_wait_for_intr(esp)) {
+			mep->error = 1;
+			break;
+		}
+
+		if (esp->sreg & ESP_STAT_SPAM) {
+			printk(KERN_ERR PFX "gross error\n");
+			mep->error = 1;
+			break;
+		}
+
+		n = esp_read8(ESP_FFLAGS) & ESP_FF_FBYTES;
+
+		if (write) {
+			if (n > esp_count)
+				n = esp_count;
+			esp_count -= n;
+
+			MAC_ESP_PIO_LOOP("%2@,%0@+", n);
+
+			if ((esp->sreg & ESP_STAT_PMASK) == ESP_STATP)
+				break;
+
+			if (esp_count) {
+				esp->ireg = esp_read8(ESP_INTRPT);
+				if (esp->ireg & ESP_INTR_DC)
+					break;
+
+				scsi_esp_cmd(esp, ESP_CMD_TI);
+			}
+		} else {
+			esp->ireg = esp_read8(ESP_INTRPT);
+			if (esp->ireg & ESP_INTR_DC)
+				break;
+
+			n = MAC_ESP_FIFO_SIZE - n;
+			if (n > esp_count)
+				n = esp_count;
+
+			if (n == MAC_ESP_FIFO_SIZE) {
+				MAC_ESP_PIO_FILL("%0@+,%2@", esp_count);
+			} else {
+				esp_count -= n;
+				MAC_ESP_PIO_LOOP("%0@+,%2@", n);
+			}
+
+			scsi_esp_cmd(esp, ESP_CMD_TI);
+		}
+	}
+
+	local_irq_restore(flags);
+}
+
+static int mac_esp_irq_pending(struct esp *esp)
+{
+	if (esp_read8(ESP_STATUS) & ESP_STAT_INTR)
+		return 1;
+	return 0;
+}
+
+static u32 mac_esp_dma_length_limit(struct esp *esp, u32 dma_addr, u32 dma_len)
+{
+	return dma_len > 0xFFFF ? 0xFFFF : dma_len;
+}
+
+static struct esp_driver_ops mac_esp_ops = {
+	.esp_write8       = mac_esp_write8,
+	.esp_read8        = mac_esp_read8,
+	.map_single       = mac_esp_map_single,
+	.map_sg           = mac_esp_map_sg,
+	.unmap_single     = mac_esp_unmap_single,
+	.unmap_sg         = mac_esp_unmap_sg,
+	.irq_pending      = mac_esp_irq_pending,
+	.dma_length_limit = mac_esp_dma_length_limit,
+	.reset_dma        = mac_esp_reset_dma,
+	.dma_drain        = mac_esp_dma_drain,
+	.dma_invalidate   = mac_esp_dma_invalidate,
+	.send_dma_cmd     = mac_esp_send_pdma_cmd,
+	.dma_error        = mac_esp_dma_error,
+};
+
+static int __devinit esp_mac_probe(struct platform_device *dev)
+{
+	struct scsi_host_template *tpnt = &scsi_esp_template;
+	struct Scsi_Host *host;
+	struct esp *esp;
+	int err;
+	int chips_present;
+	struct mac_esp_priv *mep;
+
+	if (!MACH_IS_MAC)
+		return -ENODEV;
+
+	switch (macintosh_config->scsi_type) {
+	case MAC_SCSI_QUADRA:
+	case MAC_SCSI_QUADRA3:
+		chips_present = 1;
+		break;
+	case MAC_SCSI_QUADRA2:
+		if ((macintosh_config->ident == MAC_MODEL_Q900) ||
+		    (macintosh_config->ident == MAC_MODEL_Q950))
+			chips_present = 2;
+		else
+			chips_present = 1;
+		break;
+	default:
+		chips_present = 0;
+	}
+
+	if (dev->id + 1 > chips_present)
+		return -ENODEV;
+
+	host = scsi_host_alloc(tpnt, sizeof(struct esp));
+
+	err = -ENOMEM;
+	if (!host)
+		goto fail;
+
+	host->max_id = 8;
+	host->use_clustering = DISABLE_CLUSTERING;
+	esp = shost_priv(host);
+
+	esp->host = host;
+	esp->dev = dev;
+
+	esp->command_block = kzalloc(16, GFP_KERNEL);
+	if (!esp->command_block)
+		goto fail_unlink;
+	esp->command_block_dma = (dma_addr_t)esp->command_block;
+
+	esp->scsi_id = 7;
+	host->this_id = esp->scsi_id;
+	esp->scsi_id_mask = 1 << esp->scsi_id;
+
+	mep = kzalloc(sizeof(struct mac_esp_priv), GFP_KERNEL);
+	if (!mep)
+		goto fail_free_command_block;
+	mep->esp = esp;
+	platform_set_drvdata(dev, mep);
+
+	switch (macintosh_config->scsi_type) {
+	case MAC_SCSI_QUADRA:
+		esp->cfreq     = 16500000;
+		esp->regs      = (void __iomem *)MAC_ESP_REGS_QUADRA;
+		mep->pdma_io   = esp->regs + MAC_ESP_PDMA_IO_OFFSET;
+		mep->pdma_regs = NULL;
+		break;
+	case MAC_SCSI_QUADRA2:
+		esp->cfreq     = 25000000;
+		esp->regs      = (void __iomem *)(MAC_ESP_REGS_QUADRA2 +
+				 dev->id * MAC_ESP_REGS_SPACING);
+		mep->pdma_io   = esp->regs + MAC_ESP_PDMA_IO_OFFSET;
+		mep->pdma_regs = (void __iomem *)(MAC_ESP_PDMA_REG +
+				 dev->id * MAC_ESP_PDMA_REG_SPACING);
+		nubus_writel(0x1d1, mep->pdma_regs);
+		break;
+	case MAC_SCSI_QUADRA3:
+		/* These quadras have a real DMA controller (the PSC) but we
+		 * don't know how to drive it so we must use PIO instead.
+		 */
+		esp->cfreq     = 25000000;
+		esp->regs      = (void __iomem *)MAC_ESP_REGS_QUADRA3;
+		mep->pdma_io   = NULL;
+		mep->pdma_regs = NULL;
+		break;
+	}
+
+	esp->ops = &mac_esp_ops;
+	if (mep->pdma_io == NULL) {
+		printk(KERN_INFO PFX "using PIO for controller %d\n", dev->id);
+		esp_write8(0, ESP_TCLOW);
+		esp_write8(0, ESP_TCMED);
+		esp->flags = ESP_FLAG_DISABLE_SYNC;
+		mac_esp_ops.send_dma_cmd = mac_esp_send_pio_cmd;
+	} else {
+		printk(KERN_INFO PFX "using PDMA for controller %d\n", dev->id);
+	}
+
+	host->irq = IRQ_MAC_SCSI;
+	err = request_irq(host->irq, scsi_esp_intr, IRQF_SHARED, "Mac ESP",
+			  esp);
+	if (err < 0)
+		goto fail_free_priv;
+
+	err = scsi_esp_register(esp, &dev->dev);
+	if (err)
+		goto fail_free_irq;
+
+	return 0;
+
+fail_free_irq:
+	free_irq(host->irq, esp);
+fail_free_priv:
+	kfree(mep);
+fail_free_command_block:
+	kfree(esp->command_block);
+fail_unlink:
+	scsi_host_put(host);
+fail:
+	return err;
+}
+
+static int __devexit esp_mac_remove(struct platform_device *dev)
+{
+	struct mac_esp_priv *mep = platform_get_drvdata(dev);
+	struct esp *esp = mep->esp;
+	unsigned int irq = esp->host->irq;
+
+	scsi_esp_unregister(esp);
+
+	free_irq(irq, esp);
+
+	kfree(mep);
+
+	kfree(esp->command_block);
+
+	scsi_host_put(esp->host);
+
+	return 0;
+}
+
+static struct platform_driver esp_mac_driver = {
+	.probe    = esp_mac_probe,
+	.remove   = __devexit_p(esp_mac_remove),
+	.driver   = {
+		.name     = DRV_MODULE_NAME,
+	},
+};
+
+static int __init mac_esp_init(void)
+{
+	int err;
+
+	err = platform_driver_register(&esp_mac_driver);
+	if (err)
+		return err;
+
+	internal_esp = platform_device_alloc(DRV_MODULE_NAME, 0);
+	if (internal_esp && platform_device_add(internal_esp)) {
+		platform_device_put(internal_esp);
+		internal_esp = NULL;
+	}
+
+	external_esp = platform_device_alloc(DRV_MODULE_NAME, 1);
+	if (external_esp && platform_device_add(external_esp)) {
+		platform_device_put(external_esp);
+		external_esp = NULL;
+	}
+
+	if (internal_esp || external_esp) {
+		return 0;
+	} else {
+		platform_driver_unregister(&esp_mac_driver);
+		return -ENOMEM;
+	}
+}
+
+static void __exit mac_esp_exit(void)
+{
+	platform_driver_unregister(&esp_mac_driver);
+
+	if (internal_esp) {
+		platform_device_unregister(internal_esp);
+		internal_esp = NULL;
+	}
+	if (external_esp) {
+		platform_device_unregister(external_esp);
+		external_esp = NULL;
+	}
+}
+
+MODULE_DESCRIPTION("Mac ESP SCSI driver");
+MODULE_AUTHOR("Finn Thain <fthain@telegraphics.com.au>");
+MODULE_LICENSE("GPLv2");
+MODULE_VERSION(DRV_VERSION);
+
+module_init(mac_esp_init);
+module_exit(mac_esp_exit);

commit 642978beb48331db1bafde0262eee33f658cfc39
Author: James Bottomley <James.Bottomley@HansenPartnership.com>
Date:   Thu Jan 3 12:27:16 2008 -0600

    [SCSI] remove m68k NCR53C9x based drivers
    
    These drivers depend on the deprecated NCR53C9X core and need to be converted
    to the esp_scsi core.
    
    Acked-by: Boaz Harrosh <bharrosh@panasas.com>
    Cc: Linux/m68k <linux-m68k@vger.kernel.org>
    Signed-off-by: James Bottomley <James.Bottomley@HansenPartnership.com>

diff --git a/drivers/scsi/mac_esp.c b/drivers/scsi/mac_esp.c
deleted file mode 100644
index bcb49021b7e2..000000000000
--- a/drivers/scsi/mac_esp.c
+++ /dev/null
@@ -1,751 +0,0 @@
-/*
- * 68k mac 53c9[46] scsi driver
- *
- * copyright (c) 1998, David Weis weisd3458@uni.edu
- *
- * debugging on Quadra 800 and 660AV Michael Schmitz, Dave Kilzer 7/98
- *
- * based loosely on cyber_esp.c
- */
-
-/* these are unused for now */
-#define myreadl(addr) (*(volatile unsigned int *) (addr))
-#define mywritel(b, addr) ((*(volatile unsigned int *) (addr)) = (b))
-
-
-#include <linux/kernel.h>
-#include <linux/delay.h>
-#include <linux/types.h>
-#include <linux/ctype.h>
-#include <linux/string.h>
-#include <linux/slab.h>
-#include <linux/blkdev.h>
-#include <linux/proc_fs.h>
-#include <linux/stat.h>
-#include <linux/init.h>
-#include <linux/interrupt.h>
-
-#include "scsi.h"
-#include <scsi/scsi_host.h>
-#include "NCR53C9x.h"
-
-#include <asm/io.h>
-
-#include <asm/setup.h>
-#include <asm/irq.h>
-#include <asm/macints.h>
-#include <asm/machw.h>
-#include <asm/mac_via.h>
-
-#include <asm/pgtable.h>
-
-#include <asm/macintosh.h>
-
-/* #define DEBUG_MAC_ESP */
-
-extern void esp_handle(struct NCR_ESP *esp);
-extern void mac_esp_intr(int irq, void *dev_id);
-
-static int  dma_bytes_sent(struct NCR_ESP * esp, int fifo_count);
-static int  dma_can_transfer(struct NCR_ESP * esp, Scsi_Cmnd *sp);
-static void dma_dump_state(struct NCR_ESP * esp);
-static void dma_init_read(struct NCR_ESP * esp, char * vaddress, int length);
-static void dma_init_write(struct NCR_ESP * esp, char * vaddress, int length);
-static void dma_ints_off(struct NCR_ESP * esp);
-static void dma_ints_on(struct NCR_ESP * esp);
-static int  dma_irq_p(struct NCR_ESP * esp);
-static int  dma_irq_p_quick(struct NCR_ESP * esp);
-static void dma_led_off(struct NCR_ESP * esp);
-static void dma_led_on(struct NCR_ESP *esp);
-static int  dma_ports_p(struct NCR_ESP *esp);
-static void dma_setup(struct NCR_ESP * esp, __u32 addr, int count, int write);
-static void dma_setup_quick(struct NCR_ESP * esp, __u32 addr, int count, int write);
-
-static int esp_dafb_dma_irq_p(struct NCR_ESP * espdev);
-static int esp_iosb_dma_irq_p(struct NCR_ESP * espdev);
-
-static volatile unsigned char cmd_buffer[16];
-				/* This is where all commands are put
-				 * before they are transferred to the ESP chip
-				 * via PIO.
-				 */
-
-static int esp_initialized = 0;
-
-static int setup_num_esps = -1;
-static int setup_disconnect = -1;
-static int setup_nosync = -1;
-static int setup_can_queue = -1;
-static int setup_cmd_per_lun = -1;
-static int setup_sg_tablesize = -1;
-#ifdef SUPPORT_TAGS
-static int setup_use_tagged_queuing = -1;
-#endif
-static int setup_hostid = -1;
-
-/*
- * Experimental ESP inthandler; check macints.c to make sure dev_id is 
- * set up properly!
- */
-
-void mac_esp_intr(int irq, void *dev_id)
-{
-	struct NCR_ESP *esp = (struct NCR_ESP *) dev_id;
-	int irq_p = 0;
-
-	/* Handle the one ESP interrupt showing at this IRQ level. */
-	if(((esp)->irq & 0xff) == irq) {
-	/*
-	 * Debug ..
-	 */
-		irq_p = esp->dma_irq_p(esp);
-	 	printk("mac_esp: irq_p %x current %p disconnected %p\n",
-	 		irq_p, esp->current_SC, esp->disconnected_SC);
-	 		
-		/*
-		 * Mac: if we're here, it's an ESP interrupt for sure!
-		 */
-		if((esp->current_SC || esp->disconnected_SC)) {
-			esp->dma_ints_off(esp);
-
-			ESPIRQ(("I%d(", esp->esp_id));
-			esp_handle(esp);
-			ESPIRQ((")"));
-
-			esp->dma_ints_on(esp);
-		}
-	}
-}
-
-/*
- * Debug hooks; use for playing with the interrupt flag testing and interrupt
- * acknowledge on the various machines
- */
-
-void scsi_esp_polled(int irq, void *dev_id)
-{
-	if (esp_initialized == 0)
-		return;
-
-	mac_esp_intr(irq, dev_id);
-}
-
-void fake_intr(int irq, void *dev_id)
-{
-#ifdef DEBUG_MAC_ESP
-	printk("mac_esp: got irq\n");
-#endif
-
-	mac_esp_intr(irq, dev_id);
-}
-
-irqreturn_t fake_drq(int irq, void *dev_id)
-{
-	printk("mac_esp: got drq\n");
-	return IRQ_HANDLED;
-}
-
-#define DRIVER_SETUP
-
-/*
- * Function : mac_esp_setup(char *str)
- *
- * Purpose : booter command line initialization of the overrides array,
- *
- * Inputs : str - parameters, separated by commas.
- *
- * Currently unused in the new driver; need to add settable parameters to the 
- * detect function.
- *
- */
-
-static int __init mac_esp_setup(char *str) {
-#ifdef DRIVER_SETUP
-	/* Format of mac53c9x parameter is:
-	 *   mac53c9x=<num_esps>,<disconnect>,<nosync>,<can_queue>,<cmd_per_lun>,<sg_tablesize>,<hostid>,<use_tags>
-	 * Negative values mean don't change.
-	 */
-	
-	char *this_opt;
-	long opt;
-
-	this_opt = strsep (&str, ",");
-	if(this_opt) {
-		opt = simple_strtol( this_opt, NULL, 0 );
-
-		if (opt >= 0 && opt <= 2)
-			setup_num_esps = opt;
-		else if (opt > 2)
-			printk( "mac_esp_setup: invalid number of hosts %ld !\n", opt );
-
-		this_opt = strsep (&str, ",");
-	}
-	if(this_opt) {
-		opt = simple_strtol( this_opt, NULL, 0 );
-	
-		if (opt > 0)
-			setup_disconnect = opt;
-
-		this_opt = strsep (&str, ",");
-	}
-	if(this_opt) {
-		opt = simple_strtol( this_opt, NULL, 0 );
-
-		if (opt >= 0)
-			setup_nosync = opt;
-
-		this_opt = strsep (&str, ",");
-	}
-	if(this_opt) {
-		opt = simple_strtol( this_opt, NULL, 0 );
-
-		if (opt > 0)
-			setup_can_queue = opt;
-
-		this_opt = strsep (&str, ",");
-	}
-	if(this_opt) {
-		opt = simple_strtol( this_opt, NULL, 0 );
-
-		if (opt > 0)
-			setup_cmd_per_lun = opt;
-
-		this_opt = strsep (&str, ",");
-	}
-	if(this_opt) {
-		opt = simple_strtol( this_opt, NULL, 0 );
-
-		if (opt >= 0) {
-			setup_sg_tablesize = opt;
-			/* Must be <= SG_ALL (255) */
-			if (setup_sg_tablesize > SG_ALL)
-				setup_sg_tablesize = SG_ALL;
-		}
-
-		this_opt = strsep (&str, ",");
-	}
-	if(this_opt) {
-		opt = simple_strtol( this_opt, NULL, 0 );
-
-		/* Must be between 0 and 7 */
-		if (opt >= 0 && opt <= 7)
-			setup_hostid = opt;
-		else if (opt > 7)
-			printk( "mac_esp_setup: invalid host ID %ld !\n", opt);
-
-		this_opt = strsep (&str, ",");
-	}
-#ifdef SUPPORT_TAGS
-	if(this_opt) {
-		opt = simple_strtol( this_opt, NULL, 0 );
-		if (opt >= 0)
-			setup_use_tagged_queuing = !!opt;
-	}
-#endif
-#endif
-	return 1; 
-}
-
-__setup("mac53c9x=", mac_esp_setup);
-
-
-/*
- * ESP address 'detection'
- */
-
-unsigned long get_base(int chip_num)
-{
-	/*
-	 * using the chip_num and mac model, figure out where the
-	 * chips are mapped
-	 */
-
-	unsigned long io_base = 0x50f00000;
-	unsigned int second_offset = 0x402;
-	unsigned long scsi_loc = 0;
-
-	switch (macintosh_config->scsi_type) {
-
-	/* 950, 900, 700 */
-	case MAC_SCSI_QUADRA2:
-		scsi_loc =  io_base + 0xf000 + ((chip_num == 0) ? 0 : second_offset);
-		break;
-
-	/* av's */
-	case MAC_SCSI_QUADRA3:
-		scsi_loc = io_base + 0x18000 + ((chip_num == 0) ? 0 : second_offset);
-		break;
-
-	/* most quadra/centris models are like this */	
-	case MAC_SCSI_QUADRA:
-		scsi_loc = io_base + 0x10000;
-		break;
-
-	default:
-		printk("mac_esp: get_base: hit default!\n");
-		scsi_loc = io_base + 0x10000;
-		break;
-
-	} /* switch */
-
-	printk("mac_esp: io base at 0x%lx\n", scsi_loc);
-
-	return scsi_loc;
-}
-
-/*
- * Model dependent ESP setup
- */
-
-int mac_esp_detect(struct scsi_host_template * tpnt)
-{
-	int quick = 0;
-	int chipnum, chipspresent = 0;
-#if 0
-	unsigned long timeout;
-#endif
-
-	if (esp_initialized > 0)
-		return -ENODEV;
-
-	/* what do we have in this machine... */
-	if (MACHW_PRESENT(MAC_SCSI_96)) {
-		chipspresent ++;
-	}
-
-	if (MACHW_PRESENT(MAC_SCSI_96_2)) {
-		chipspresent ++;
-	}
-
-	/* number of ESPs present ? */
-	if (setup_num_esps >= 0) {
-	  if (chipspresent >= setup_num_esps)
-	    chipspresent = setup_num_esps;
-	  else
-	    printk("mac_esp_detect: num_hosts detected %d setup %d \n",
-		   chipspresent, setup_num_esps);
-	}
-
-	/* TODO: add disconnect / nosync flags */
-
-	/* setup variables */
-	tpnt->can_queue =
-	  (setup_can_queue > 0) ? setup_can_queue : 7;
-	tpnt->cmd_per_lun =
-	  (setup_cmd_per_lun > 0) ? setup_cmd_per_lun : 1;
-	tpnt->sg_tablesize = 
-	  (setup_sg_tablesize >= 0) ? setup_sg_tablesize : SG_ALL;
-
-	if (setup_hostid >= 0)
-	  tpnt->this_id = setup_hostid;
-	else {
-	  /* use 7 as default */
-	  tpnt->this_id = 7;
-	}
-
-#ifdef SUPPORT_TAGS
-	if (setup_use_tagged_queuing < 0)
-		setup_use_tagged_queuing = DEFAULT_USE_TAGGED_QUEUING;
-#endif
-
-	for (chipnum = 0; chipnum < chipspresent; chipnum ++) {
-		struct NCR_ESP * esp;
-
-		esp = esp_allocate(tpnt, NULL, 0);
-		esp->eregs = (struct ESP_regs *) get_base(chipnum);
-
-		esp->dma_irq_p = &esp_dafb_dma_irq_p;
-		if (chipnum == 0) {
-
-			if (macintosh_config->scsi_type == MAC_SCSI_QUADRA) {
-				/* most machines except those below :-) */
-				quick = 1;
-				esp->dma_irq_p = &esp_iosb_dma_irq_p;
-			} else if (macintosh_config->scsi_type == MAC_SCSI_QUADRA3) {
-				/* mostly av's */
-				quick = 0;
-			} else {
-				/* q950, 900, 700 */
-				quick = 1;
-				out_be32(0xf9800024, 0x1d1);
-				esp->dregs = (void *) 0xf9800024;
-			}
-
-		} else { /* chipnum */
-
-			quick = 1;
-			out_be32(0xf9800028, 0x1d1);
-			esp->dregs = (void *) 0xf9800028;
-
-		} /* chipnum == 0 */
-
-		/* use pio for command bytes; pio for message/data: TBI */
-		esp->do_pio_cmds = 1;
-
-		/* Set the command buffer */
-		esp->esp_command = (volatile unsigned char*) cmd_buffer;
-		esp->esp_command_dvma = (__u32) cmd_buffer;
-
-		/* various functions */
-		esp->dma_bytes_sent = &dma_bytes_sent;
-		esp->dma_can_transfer = &dma_can_transfer;
-		esp->dma_dump_state = &dma_dump_state;
-		esp->dma_init_read = NULL;
-		esp->dma_init_write = NULL;
-		esp->dma_ints_off = &dma_ints_off;
-		esp->dma_ints_on = &dma_ints_on;
-
-		esp->dma_ports_p = &dma_ports_p;
-
-
-		/* Optional functions */
-		esp->dma_barrier = NULL;
-		esp->dma_drain = NULL;
-		esp->dma_invalidate = NULL;
-		esp->dma_irq_entry = NULL;
-		esp->dma_irq_exit = NULL;
-		esp->dma_led_on = NULL;
-		esp->dma_led_off = NULL;
-		esp->dma_poll = NULL;
-		esp->dma_reset = NULL;
-
-		/* SCSI chip speed */
-		/* below esp->cfreq = 40000000; */
-
-
-		if (quick) {
-			/* 'quick' means there's handshake glue logic like in the 5380 case */
-			esp->dma_setup = &dma_setup_quick;
-		} else {
-			esp->dma_setup = &dma_setup;
-		}
-
-		if (chipnum == 0) {
-
-			esp->irq = IRQ_MAC_SCSI;
-
-			request_irq(IRQ_MAC_SCSI, esp_intr, 0, "Mac ESP SCSI", esp->ehost);
-#if 0	/* conflicts with IOP ADB */
-			request_irq(IRQ_MAC_SCSIDRQ, fake_drq, 0, "Mac ESP DRQ", esp->ehost);
-#endif
-
-			if (macintosh_config->scsi_type == MAC_SCSI_QUADRA) {
-				esp->cfreq = 16500000;
-			} else {
-				esp->cfreq = 25000000;
-			}
-
-
-		} else { /* chipnum == 1 */
-
-			esp->irq = IRQ_MAC_SCSIDRQ;
-#if 0	/* conflicts with IOP ADB */
-			request_irq(IRQ_MAC_SCSIDRQ, esp_intr, 0, "Mac ESP SCSI 2", esp->ehost);
-#endif
-
-			esp->cfreq = 25000000;
-
-		}
-
-		if (quick) {
-			printk("esp: using quick version\n");
-		}
-
-		printk("esp: addr at 0x%p\n", esp->eregs);
-
-		esp->scsi_id = 7;
-		esp->diff = 0;
-
-		esp_initialize(esp);
-
-	} /* for chipnum */
-
-	if (chipspresent)
-		printk("\nmac_esp: %d esp controllers found\n", chipspresent);
-
-	esp_initialized = chipspresent;
-
-	return chipspresent;
-}
-
-static int mac_esp_release(struct Scsi_Host *shost)
-{
-	if (shost->irq)
-		free_irq(shost->irq, NULL);
-	if (shost->io_port && shost->n_io_port)
-		release_region(shost->io_port, shost->n_io_port);
-	scsi_unregister(shost);
-	return 0;
-}
-
-/*
- * I've been wondering what this is supposed to do, for some time. Talking 
- * to Allen Briggs: These machines have an extra register someplace where the
- * DRQ pin of the ESP can be monitored. That isn't useful for determining 
- * anything else (such as reselect interrupt or other magic) though. 
- * Maybe make the semantics should be changed like 
- * if (esp->current_SC)
- *	... check DRQ flag ...
- * else 
- *	... disconnected, check pending VIA interrupt ...
- *
- * There's a problem with using the dabf flag or mac_irq_pending() here: both
- * seem to return 1 even though no interrupt is currently pending, resulting
- * in esp_exec_cmd() holding off the next command, and possibly infinite loops
- * in esp_intr(). 
- * Short term fix: just use esp_status & ESP_STAT_INTR here, as long as we
- * use simple PIO. The DRQ status will be important when implementing pseudo
- * DMA mode (set up ESP transfer count, return, do a batch of bytes in PIO or 
- * 'hardware handshake' mode upon DRQ).
- * If you plan on changing this (i.e. to save the esp_status register access in 
- * favor of a VIA register access or a shadow register for the IFR), make sure
- * to try a debug version of this first to monitor what registers would be a good
- * indicator of the ESP interrupt.
- */
-
-static int esp_dafb_dma_irq_p(struct NCR_ESP * esp)
-{
-	unsigned int ret;
-	int sreg = esp_read(esp->eregs->esp_status);
-
-#ifdef DEBUG_MAC_ESP
-	printk("mac_esp: esp_dafb_dma_irq_p dafb %d irq %d\n", 
-		readl(esp->dregs), mac_irq_pending(IRQ_MAC_SCSI));
-#endif
-
-	sreg &= ESP_STAT_INTR;
-
-	/*
-	 * maybe working; this is essentially what's used for iosb_dma_irq_p
-	 */
-	if (sreg)
-		return 1;
-	else
-		return 0;
-
-	/*
-	 * didn't work ...
-	 */
-#if 0
-	if (esp->current_SC)
-		ret = readl(esp->dregs) & 0x200;
-	else if (esp->disconnected_SC)
-		ret = 1; /* sreg ?? */
-	else
-		ret = mac_irq_pending(IRQ_MAC_SCSI);
-
-	return(ret);
-#endif
-
-}
-
-/*
- * See above: testing mac_irq_pending always returned 8 (SCSI IRQ) regardless 
- * of the actual ESP status.
- */
-
-static int esp_iosb_dma_irq_p(struct NCR_ESP * esp)
-{
-	int ret  = mac_irq_pending(IRQ_MAC_SCSI) || mac_irq_pending(IRQ_MAC_SCSIDRQ);
-	int sreg = esp_read(esp->eregs->esp_status);
-
-#ifdef DEBUG_MAC_ESP
-	printk("mac_esp: dma_irq_p drq %d irq %d sreg %x curr %p disc %p\n", 
-		mac_irq_pending(IRQ_MAC_SCSIDRQ), mac_irq_pending(IRQ_MAC_SCSI), 
-		sreg, esp->current_SC, esp->disconnected_SC);
-#endif
-
-	sreg &= ESP_STAT_INTR;
-
-	if (sreg)
-		return (sreg);
-	else
-		return 0;
-}
-
-/*
- * This seems to be OK for PIO at least ... usually 0 after PIO.
- */
-
-static int dma_bytes_sent(struct NCR_ESP * esp, int fifo_count)
-{
-
-#ifdef DEBUG_MAC_ESP
-	printk("mac_esp: dma bytes sent = %x\n", fifo_count);
-#endif
-
-	return fifo_count;
-}
-
-/*
- * dma_can_transfer is used to switch between DMA and PIO, if DMA (pseudo)
- * is ever implemented. Returning 0 here will use PIO.
- */
-
-static int dma_can_transfer(struct NCR_ESP * esp, Scsi_Cmnd * sp)
-{
-	unsigned long sz = sp->SCp.this_residual;
-#if 0	/* no DMA yet; make conditional */
-	if (sz > 0x10000000) {
-		sz = 0x10000000;
-	}
-	printk("mac_esp: dma can transfer = 0lx%x\n", sz);
-#else
-
-#ifdef DEBUG_MAC_ESP
-	printk("mac_esp: pio to transfer = %ld\n", sz);
-#endif
-
-	sz = 0;
-#endif
-	return sz;
-}
-
-/*
- * Not yet ...
- */
-
-static void dma_dump_state(struct NCR_ESP * esp)
-{
-#ifdef DEBUG_MAC_ESP
-	printk("mac_esp: dma_dump_state: called\n");
-#endif
-#if 0
-	ESPLOG(("esp%d: dma -- cond_reg<%02x>\n",
-		esp->esp_id, ((struct mac_dma_registers *)
-		(esp->dregs))->cond_reg));
-#endif
-}
-
-/*
- * DMA setup: should be used to set up the ESP transfer count for pseudo
- * DMA transfers; need a DRQ transfer function to do the actual transfer
- */
-
-static void dma_init_read(struct NCR_ESP * esp, char * vaddress, int length)
-{
-	printk("mac_esp: dma_init_read\n");
-}
-
-
-static void dma_init_write(struct NCR_ESP * esp, char * vaddress, int length)
-{
-	printk("mac_esp: dma_init_write\n");
-}
-
-
-static void dma_ints_off(struct NCR_ESP * esp)
-{
-	disable_irq(esp->irq);
-}
-
-
-static void dma_ints_on(struct NCR_ESP * esp)
-{
-	enable_irq(esp->irq);
-}
-
-/*
- * generic dma_irq_p(), unused
- */
-
-static int dma_irq_p(struct NCR_ESP * esp)
-{
-	int i = esp_read(esp->eregs->esp_status);
-
-#ifdef DEBUG_MAC_ESP
-	printk("mac_esp: dma_irq_p status %d\n", i);
-#endif
-
-	return (i & ESP_STAT_INTR);
-}
-
-static int dma_irq_p_quick(struct NCR_ESP * esp)
-{
-	/*
-	 * Copied from iosb_dma_irq_p()
-	 */
-	int ret  = mac_irq_pending(IRQ_MAC_SCSI) || mac_irq_pending(IRQ_MAC_SCSIDRQ);
-	int sreg = esp_read(esp->eregs->esp_status);
-
-#ifdef DEBUG_MAC_ESP
-	printk("mac_esp: dma_irq_p drq %d irq %d sreg %x curr %p disc %p\n", 
-		mac_irq_pending(IRQ_MAC_SCSIDRQ), mac_irq_pending(IRQ_MAC_SCSI), 
-		sreg, esp->current_SC, esp->disconnected_SC);
-#endif
-
-	sreg &= ESP_STAT_INTR;
-
-	if (sreg)
-		return (sreg);
-	else
-		return 0;
-
-}
-
-static void dma_led_off(struct NCR_ESP * esp)
-{
-#ifdef DEBUG_MAC_ESP
-	printk("mac_esp: dma_led_off: called\n");
-#endif
-}
-
-
-static void dma_led_on(struct NCR_ESP * esp)
-{
-#ifdef DEBUG_MAC_ESP
-	printk("mac_esp: dma_led_on: called\n");
-#endif
-}
-
-
-static int dma_ports_p(struct NCR_ESP * esp)
-{
-	return 0;
-}
-
-
-static void dma_setup(struct NCR_ESP * esp, __u32 addr, int count, int write)
-{
-
-#ifdef DEBUG_MAC_ESP
-	printk("mac_esp: dma_setup\n");
-#endif
-
-	if (write) {
-		dma_init_read(esp, (char *) addr, count);
-	} else {
-		dma_init_write(esp, (char *) addr, count);
-	}
-}
-
-
-static void dma_setup_quick(struct NCR_ESP * esp, __u32 addr, int count, int write)
-{
-#ifdef DEBUG_MAC_ESP
-	printk("mac_esp: dma_setup_quick\n");
-#endif
-}
-
-static struct scsi_host_template driver_template = {
-	.proc_name		= "mac_esp",
-	.name			= "Mac 53C9x SCSI",
-	.detect			= mac_esp_detect,
-	.slave_alloc		= esp_slave_alloc,
-	.slave_destroy		= esp_slave_destroy,
-	.release		= mac_esp_release,
-	.info			= esp_info,
-	.queuecommand		= esp_queue,
-	.eh_abort_handler	= esp_abort,
-	.eh_bus_reset_handler	= esp_reset,
-	.can_queue		= 7,
-	.this_id		= 7,
-	.sg_tablesize		= SG_ALL,
-	.cmd_per_lun		= 1,
-	.use_clustering		= DISABLE_CLUSTERING
-};
-
-
-#include "scsi_module.c"
-
-MODULE_LICENSE("GPL");

commit 4df4db5c6c6daeb10a8693d09ce872bce8cd84e6
Author: Maciej W. Rozycki <macro@linux-mips.org>
Date:   Mon Feb 5 16:28:29 2007 -0800

    [TC] dec_esp: Driver model for the PMAZ-A
    
    This is a set of changes that converts the PMAZ-A support to the driver model.
    
    The use of the driver model required switching to the hotplug SCSI
    initialization model, which in turn required a change to the core NCR53C9x
    driver.  I decided not to break all the frontend drivers and introduced an
    additional parameter for esp_allocate() to select between the old and the new
    model.  I hope this is OK, but I would be fine with converting NCR53C9x to the
    new model unconditionally as long as I do not have to fix all the other
    frontends (OK, perhaps I could do some of them ;-) ).
    
    Signed-off-by: Maciej W. Rozycki <macro@linux-mips.org>
    Cc: James Bottomley <James.Bottomley@steeleye.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/drivers/scsi/mac_esp.c b/drivers/scsi/mac_esp.c
index 3586fac9be9a..bcb49021b7e2 100644
--- a/drivers/scsi/mac_esp.c
+++ b/drivers/scsi/mac_esp.c
@@ -351,7 +351,7 @@ int mac_esp_detect(struct scsi_host_template * tpnt)
 	for (chipnum = 0; chipnum < chipspresent; chipnum ++) {
 		struct NCR_ESP * esp;
 
-		esp = esp_allocate(tpnt, (void *) NULL);
+		esp = esp_allocate(tpnt, NULL, 0);
 		esp->eregs = (struct ESP_regs *) get_base(chipnum);
 
 		esp->dma_irq_p = &esp_dafb_dma_irq_p;

commit 7d12e780e003f93433d49ce78cfedf4b4c52adc5
Author: David Howells <dhowells@redhat.com>
Date:   Thu Oct 5 14:55:46 2006 +0100

    IRQ: Maintain regs pointer globally rather than passing to IRQ handlers
    
    Maintain a per-CPU global "struct pt_regs *" variable which can be used instead
    of passing regs around manually through all ~1800 interrupt handlers in the
    Linux kernel.
    
    The regs pointer is used in few places, but it potentially costs both stack
    space and code to pass it around.  On the FRV arch, removing the regs parameter
    from all the genirq function results in a 20% speed up of the IRQ exit path
    (ie: from leaving timer_interrupt() to leaving do_IRQ()).
    
    Where appropriate, an arch may override the generic storage facility and do
    something different with the variable.  On FRV, for instance, the address is
    maintained in GR28 at all times inside the kernel as part of general exception
    handling.
    
    Having looked over the code, it appears that the parameter may be handed down
    through up to twenty or so layers of functions.  Consider a USB character
    device attached to a USB hub, attached to a USB controller that posts its
    interrupts through a cascaded auxiliary interrupt controller.  A character
    device driver may want to pass regs to the sysrq handler through the input
    layer which adds another few layers of parameter passing.
    
    I've build this code with allyesconfig for x86_64 and i386.  I've runtested the
    main part of the code on FRV and i386, though I can't test most of the drivers.
    I've also done partial conversion for powerpc and MIPS - these at least compile
    with minimal configurations.
    
    This will affect all archs.  Mostly the changes should be relatively easy.
    Take do_IRQ(), store the regs pointer at the beginning, saving the old one:
    
            struct pt_regs *old_regs = set_irq_regs(regs);
    
    And put the old one back at the end:
    
            set_irq_regs(old_regs);
    
    Don't pass regs through to generic_handle_irq() or __do_IRQ().
    
    In timer_interrupt(), this sort of change will be necessary:
    
            -       update_process_times(user_mode(regs));
            -       profile_tick(CPU_PROFILING, regs);
            +       update_process_times(user_mode(get_irq_regs()));
            +       profile_tick(CPU_PROFILING);
    
    I'd like to move update_process_times()'s use of get_irq_regs() into itself,
    except that i386, alone of the archs, uses something other than user_mode().
    
    Some notes on the interrupt handling in the drivers:
    
     (*) input_dev() is now gone entirely.  The regs pointer is no longer stored in
         the input_dev struct.
    
     (*) finish_unlinks() in drivers/usb/host/ohci-q.c needs checking.  It does
         something different depending on whether it's been supplied with a regs
         pointer or not.
    
     (*) Various IRQ handler function pointers have been moved to type
         irq_handler_t.
    
    Signed-Off-By: David Howells <dhowells@redhat.com>
    (cherry picked from 1b16e7ac850969f38b375e511e3fa2f474a33867 commit)

diff --git a/drivers/scsi/mac_esp.c b/drivers/scsi/mac_esp.c
index 118206d68c6c..3586fac9be9a 100644
--- a/drivers/scsi/mac_esp.c
+++ b/drivers/scsi/mac_esp.c
@@ -44,7 +44,7 @@
 /* #define DEBUG_MAC_ESP */
 
 extern void esp_handle(struct NCR_ESP *esp);
-extern void mac_esp_intr(int irq, void *dev_id, struct pt_regs *pregs);
+extern void mac_esp_intr(int irq, void *dev_id);
 
 static int  dma_bytes_sent(struct NCR_ESP * esp, int fifo_count);
 static int  dma_can_transfer(struct NCR_ESP * esp, Scsi_Cmnd *sp);
@@ -88,7 +88,7 @@ static int setup_hostid = -1;
  * set up properly!
  */
 
-void mac_esp_intr(int irq, void *dev_id, struct pt_regs *pregs)
+void mac_esp_intr(int irq, void *dev_id)
 {
 	struct NCR_ESP *esp = (struct NCR_ESP *) dev_id;
 	int irq_p = 0;
@@ -122,24 +122,24 @@ void mac_esp_intr(int irq, void *dev_id, struct pt_regs *pregs)
  * acknowledge on the various machines
  */
 
-void scsi_esp_polled(int irq, void *dev_id, struct pt_regs *pregs)
+void scsi_esp_polled(int irq, void *dev_id)
 {
 	if (esp_initialized == 0)
 		return;
 
-	mac_esp_intr(irq, dev_id, pregs);
+	mac_esp_intr(irq, dev_id);
 }
 
-void fake_intr(int irq, void *dev_id, struct pt_regs *pregs)
+void fake_intr(int irq, void *dev_id)
 {
 #ifdef DEBUG_MAC_ESP
 	printk("mac_esp: got irq\n");
 #endif
 
-	mac_esp_intr(irq, dev_id, pregs);
+	mac_esp_intr(irq, dev_id);
 }
 
-irqreturn_t fake_drq(int irq, void *dev_id, struct pt_regs *pregs)
+irqreturn_t fake_drq(int irq, void *dev_id)
 {
 	printk("mac_esp: got drq\n");
 	return IRQ_HANDLED;

commit 9c5f4afdfbe72d5d1c814ad7286a4524d00c7b96
Author: Roman Zippel <zippel@linux-m68k.org>
Date:   Sun Jun 25 05:47:04 2006 -0700

    [PATCH] m68k: convert mac irq code
    
    Signed-off-by: Roman Zippel <zippel@linux-m68k.org>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/drivers/scsi/mac_esp.c b/drivers/scsi/mac_esp.c
index e31fadd61904..118206d68c6c 100644
--- a/drivers/scsi/mac_esp.c
+++ b/drivers/scsi/mac_esp.c
@@ -43,9 +43,6 @@
 
 /* #define DEBUG_MAC_ESP */
 
-#define mac_turnon_irq(x)	mac_enable_irq(x)
-#define mac_turnoff_irq(x)	mac_disable_irq(x)
-
 extern void esp_handle(struct NCR_ESP *esp);
 extern void mac_esp_intr(int irq, void *dev_id, struct pt_regs *pregs);
 
@@ -639,13 +636,13 @@ static void dma_init_write(struct NCR_ESP * esp, char * vaddress, int length)
 
 static void dma_ints_off(struct NCR_ESP * esp)
 {
-	mac_turnoff_irq(esp->irq);
+	disable_irq(esp->irq);
 }
 
 
 static void dma_ints_on(struct NCR_ESP * esp)
 {
-	mac_turnon_irq(esp->irq);
+	enable_irq(esp->irq);
 }
 
 /*

commit d0be4a7d29ad0bd3ce2209dd9e46d410b632db59
Author: Christoph Hellwig <hch@lst.de>
Date:   Mon Oct 31 18:31:40 2005 +0100

    [SCSI] remove Scsi_Host_Template typedef
    
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>

diff --git a/drivers/scsi/mac_esp.c b/drivers/scsi/mac_esp.c
index c94c8db84651..e31fadd61904 100644
--- a/drivers/scsi/mac_esp.c
+++ b/drivers/scsi/mac_esp.c
@@ -300,7 +300,7 @@ unsigned long get_base(int chip_num)
  * Model dependent ESP setup
  */
 
-int mac_esp_detect(Scsi_Host_Template * tpnt)
+int mac_esp_detect(struct scsi_host_template * tpnt)
 {
 	int quick = 0;
 	int chipnum, chipspresent = 0;
@@ -730,7 +730,7 @@ static void dma_setup_quick(struct NCR_ESP * esp, __u32 addr, int count, int wri
 #endif
 }
 
-static Scsi_Host_Template driver_template = {
+static struct scsi_host_template driver_template = {
 	.proc_name		= "mac_esp",
 	.name			= "Mac 53C9x SCSI",
 	.detect			= mac_esp_detect,

commit 1da177e4c3f41524e886b7f1b8a0c1fc7321cac2
Author: Linus Torvalds <torvalds@ppc970.osdl.org>
Date:   Sat Apr 16 15:20:36 2005 -0700

    Linux-2.6.12-rc2
    
    Initial git repository build. I'm not bothering with the full history,
    even though we have it. We can create a separate "historical" git
    archive of that later if we want to, and in the meantime it's about
    3.2GB when imported into git - space that would just make the early
    git days unnecessarily complicated, when we don't have a lot of good
    infrastructure for it.
    
    Let it rip!

diff --git a/drivers/scsi/mac_esp.c b/drivers/scsi/mac_esp.c
new file mode 100644
index 000000000000..c94c8db84651
--- /dev/null
+++ b/drivers/scsi/mac_esp.c
@@ -0,0 +1,754 @@
+/*
+ * 68k mac 53c9[46] scsi driver
+ *
+ * copyright (c) 1998, David Weis weisd3458@uni.edu
+ *
+ * debugging on Quadra 800 and 660AV Michael Schmitz, Dave Kilzer 7/98
+ *
+ * based loosely on cyber_esp.c
+ */
+
+/* these are unused for now */
+#define myreadl(addr) (*(volatile unsigned int *) (addr))
+#define mywritel(b, addr) ((*(volatile unsigned int *) (addr)) = (b))
+
+
+#include <linux/kernel.h>
+#include <linux/delay.h>
+#include <linux/types.h>
+#include <linux/ctype.h>
+#include <linux/string.h>
+#include <linux/slab.h>
+#include <linux/blkdev.h>
+#include <linux/proc_fs.h>
+#include <linux/stat.h>
+#include <linux/init.h>
+#include <linux/interrupt.h>
+
+#include "scsi.h"
+#include <scsi/scsi_host.h>
+#include "NCR53C9x.h"
+
+#include <asm/io.h>
+
+#include <asm/setup.h>
+#include <asm/irq.h>
+#include <asm/macints.h>
+#include <asm/machw.h>
+#include <asm/mac_via.h>
+
+#include <asm/pgtable.h>
+
+#include <asm/macintosh.h>
+
+/* #define DEBUG_MAC_ESP */
+
+#define mac_turnon_irq(x)	mac_enable_irq(x)
+#define mac_turnoff_irq(x)	mac_disable_irq(x)
+
+extern void esp_handle(struct NCR_ESP *esp);
+extern void mac_esp_intr(int irq, void *dev_id, struct pt_regs *pregs);
+
+static int  dma_bytes_sent(struct NCR_ESP * esp, int fifo_count);
+static int  dma_can_transfer(struct NCR_ESP * esp, Scsi_Cmnd *sp);
+static void dma_dump_state(struct NCR_ESP * esp);
+static void dma_init_read(struct NCR_ESP * esp, char * vaddress, int length);
+static void dma_init_write(struct NCR_ESP * esp, char * vaddress, int length);
+static void dma_ints_off(struct NCR_ESP * esp);
+static void dma_ints_on(struct NCR_ESP * esp);
+static int  dma_irq_p(struct NCR_ESP * esp);
+static int  dma_irq_p_quick(struct NCR_ESP * esp);
+static void dma_led_off(struct NCR_ESP * esp);
+static void dma_led_on(struct NCR_ESP *esp);
+static int  dma_ports_p(struct NCR_ESP *esp);
+static void dma_setup(struct NCR_ESP * esp, __u32 addr, int count, int write);
+static void dma_setup_quick(struct NCR_ESP * esp, __u32 addr, int count, int write);
+
+static int esp_dafb_dma_irq_p(struct NCR_ESP * espdev);
+static int esp_iosb_dma_irq_p(struct NCR_ESP * espdev);
+
+static volatile unsigned char cmd_buffer[16];
+				/* This is where all commands are put
+				 * before they are transferred to the ESP chip
+				 * via PIO.
+				 */
+
+static int esp_initialized = 0;
+
+static int setup_num_esps = -1;
+static int setup_disconnect = -1;
+static int setup_nosync = -1;
+static int setup_can_queue = -1;
+static int setup_cmd_per_lun = -1;
+static int setup_sg_tablesize = -1;
+#ifdef SUPPORT_TAGS
+static int setup_use_tagged_queuing = -1;
+#endif
+static int setup_hostid = -1;
+
+/*
+ * Experimental ESP inthandler; check macints.c to make sure dev_id is 
+ * set up properly!
+ */
+
+void mac_esp_intr(int irq, void *dev_id, struct pt_regs *pregs)
+{
+	struct NCR_ESP *esp = (struct NCR_ESP *) dev_id;
+	int irq_p = 0;
+
+	/* Handle the one ESP interrupt showing at this IRQ level. */
+	if(((esp)->irq & 0xff) == irq) {
+	/*
+	 * Debug ..
+	 */
+		irq_p = esp->dma_irq_p(esp);
+	 	printk("mac_esp: irq_p %x current %p disconnected %p\n",
+	 		irq_p, esp->current_SC, esp->disconnected_SC);
+	 		
+		/*
+		 * Mac: if we're here, it's an ESP interrupt for sure!
+		 */
+		if((esp->current_SC || esp->disconnected_SC)) {
+			esp->dma_ints_off(esp);
+
+			ESPIRQ(("I%d(", esp->esp_id));
+			esp_handle(esp);
+			ESPIRQ((")"));
+
+			esp->dma_ints_on(esp);
+		}
+	}
+}
+
+/*
+ * Debug hooks; use for playing with the interrupt flag testing and interrupt
+ * acknowledge on the various machines
+ */
+
+void scsi_esp_polled(int irq, void *dev_id, struct pt_regs *pregs)
+{
+	if (esp_initialized == 0)
+		return;
+
+	mac_esp_intr(irq, dev_id, pregs);
+}
+
+void fake_intr(int irq, void *dev_id, struct pt_regs *pregs)
+{
+#ifdef DEBUG_MAC_ESP
+	printk("mac_esp: got irq\n");
+#endif
+
+	mac_esp_intr(irq, dev_id, pregs);
+}
+
+irqreturn_t fake_drq(int irq, void *dev_id, struct pt_regs *pregs)
+{
+	printk("mac_esp: got drq\n");
+	return IRQ_HANDLED;
+}
+
+#define DRIVER_SETUP
+
+/*
+ * Function : mac_esp_setup(char *str)
+ *
+ * Purpose : booter command line initialization of the overrides array,
+ *
+ * Inputs : str - parameters, separated by commas.
+ *
+ * Currently unused in the new driver; need to add settable parameters to the 
+ * detect function.
+ *
+ */
+
+static int __init mac_esp_setup(char *str) {
+#ifdef DRIVER_SETUP
+	/* Format of mac53c9x parameter is:
+	 *   mac53c9x=<num_esps>,<disconnect>,<nosync>,<can_queue>,<cmd_per_lun>,<sg_tablesize>,<hostid>,<use_tags>
+	 * Negative values mean don't change.
+	 */
+	
+	char *this_opt;
+	long opt;
+
+	this_opt = strsep (&str, ",");
+	if(this_opt) {
+		opt = simple_strtol( this_opt, NULL, 0 );
+
+		if (opt >= 0 && opt <= 2)
+			setup_num_esps = opt;
+		else if (opt > 2)
+			printk( "mac_esp_setup: invalid number of hosts %ld !\n", opt );
+
+		this_opt = strsep (&str, ",");
+	}
+	if(this_opt) {
+		opt = simple_strtol( this_opt, NULL, 0 );
+	
+		if (opt > 0)
+			setup_disconnect = opt;
+
+		this_opt = strsep (&str, ",");
+	}
+	if(this_opt) {
+		opt = simple_strtol( this_opt, NULL, 0 );
+
+		if (opt >= 0)
+			setup_nosync = opt;
+
+		this_opt = strsep (&str, ",");
+	}
+	if(this_opt) {
+		opt = simple_strtol( this_opt, NULL, 0 );
+
+		if (opt > 0)
+			setup_can_queue = opt;
+
+		this_opt = strsep (&str, ",");
+	}
+	if(this_opt) {
+		opt = simple_strtol( this_opt, NULL, 0 );
+
+		if (opt > 0)
+			setup_cmd_per_lun = opt;
+
+		this_opt = strsep (&str, ",");
+	}
+	if(this_opt) {
+		opt = simple_strtol( this_opt, NULL, 0 );
+
+		if (opt >= 0) {
+			setup_sg_tablesize = opt;
+			/* Must be <= SG_ALL (255) */
+			if (setup_sg_tablesize > SG_ALL)
+				setup_sg_tablesize = SG_ALL;
+		}
+
+		this_opt = strsep (&str, ",");
+	}
+	if(this_opt) {
+		opt = simple_strtol( this_opt, NULL, 0 );
+
+		/* Must be between 0 and 7 */
+		if (opt >= 0 && opt <= 7)
+			setup_hostid = opt;
+		else if (opt > 7)
+			printk( "mac_esp_setup: invalid host ID %ld !\n", opt);
+
+		this_opt = strsep (&str, ",");
+	}
+#ifdef SUPPORT_TAGS
+	if(this_opt) {
+		opt = simple_strtol( this_opt, NULL, 0 );
+		if (opt >= 0)
+			setup_use_tagged_queuing = !!opt;
+	}
+#endif
+#endif
+	return 1; 
+}
+
+__setup("mac53c9x=", mac_esp_setup);
+
+
+/*
+ * ESP address 'detection'
+ */
+
+unsigned long get_base(int chip_num)
+{
+	/*
+	 * using the chip_num and mac model, figure out where the
+	 * chips are mapped
+	 */
+
+	unsigned long io_base = 0x50f00000;
+	unsigned int second_offset = 0x402;
+	unsigned long scsi_loc = 0;
+
+	switch (macintosh_config->scsi_type) {
+
+	/* 950, 900, 700 */
+	case MAC_SCSI_QUADRA2:
+		scsi_loc =  io_base + 0xf000 + ((chip_num == 0) ? 0 : second_offset);
+		break;
+
+	/* av's */
+	case MAC_SCSI_QUADRA3:
+		scsi_loc = io_base + 0x18000 + ((chip_num == 0) ? 0 : second_offset);
+		break;
+
+	/* most quadra/centris models are like this */	
+	case MAC_SCSI_QUADRA:
+		scsi_loc = io_base + 0x10000;
+		break;
+
+	default:
+		printk("mac_esp: get_base: hit default!\n");
+		scsi_loc = io_base + 0x10000;
+		break;
+
+	} /* switch */
+
+	printk("mac_esp: io base at 0x%lx\n", scsi_loc);
+
+	return scsi_loc;
+}
+
+/*
+ * Model dependent ESP setup
+ */
+
+int mac_esp_detect(Scsi_Host_Template * tpnt)
+{
+	int quick = 0;
+	int chipnum, chipspresent = 0;
+#if 0
+	unsigned long timeout;
+#endif
+
+	if (esp_initialized > 0)
+		return -ENODEV;
+
+	/* what do we have in this machine... */
+	if (MACHW_PRESENT(MAC_SCSI_96)) {
+		chipspresent ++;
+	}
+
+	if (MACHW_PRESENT(MAC_SCSI_96_2)) {
+		chipspresent ++;
+	}
+
+	/* number of ESPs present ? */
+	if (setup_num_esps >= 0) {
+	  if (chipspresent >= setup_num_esps)
+	    chipspresent = setup_num_esps;
+	  else
+	    printk("mac_esp_detect: num_hosts detected %d setup %d \n",
+		   chipspresent, setup_num_esps);
+	}
+
+	/* TODO: add disconnect / nosync flags */
+
+	/* setup variables */
+	tpnt->can_queue =
+	  (setup_can_queue > 0) ? setup_can_queue : 7;
+	tpnt->cmd_per_lun =
+	  (setup_cmd_per_lun > 0) ? setup_cmd_per_lun : 1;
+	tpnt->sg_tablesize = 
+	  (setup_sg_tablesize >= 0) ? setup_sg_tablesize : SG_ALL;
+
+	if (setup_hostid >= 0)
+	  tpnt->this_id = setup_hostid;
+	else {
+	  /* use 7 as default */
+	  tpnt->this_id = 7;
+	}
+
+#ifdef SUPPORT_TAGS
+	if (setup_use_tagged_queuing < 0)
+		setup_use_tagged_queuing = DEFAULT_USE_TAGGED_QUEUING;
+#endif
+
+	for (chipnum = 0; chipnum < chipspresent; chipnum ++) {
+		struct NCR_ESP * esp;
+
+		esp = esp_allocate(tpnt, (void *) NULL);
+		esp->eregs = (struct ESP_regs *) get_base(chipnum);
+
+		esp->dma_irq_p = &esp_dafb_dma_irq_p;
+		if (chipnum == 0) {
+
+			if (macintosh_config->scsi_type == MAC_SCSI_QUADRA) {
+				/* most machines except those below :-) */
+				quick = 1;
+				esp->dma_irq_p = &esp_iosb_dma_irq_p;
+			} else if (macintosh_config->scsi_type == MAC_SCSI_QUADRA3) {
+				/* mostly av's */
+				quick = 0;
+			} else {
+				/* q950, 900, 700 */
+				quick = 1;
+				out_be32(0xf9800024, 0x1d1);
+				esp->dregs = (void *) 0xf9800024;
+			}
+
+		} else { /* chipnum */
+
+			quick = 1;
+			out_be32(0xf9800028, 0x1d1);
+			esp->dregs = (void *) 0xf9800028;
+
+		} /* chipnum == 0 */
+
+		/* use pio for command bytes; pio for message/data: TBI */
+		esp->do_pio_cmds = 1;
+
+		/* Set the command buffer */
+		esp->esp_command = (volatile unsigned char*) cmd_buffer;
+		esp->esp_command_dvma = (__u32) cmd_buffer;
+
+		/* various functions */
+		esp->dma_bytes_sent = &dma_bytes_sent;
+		esp->dma_can_transfer = &dma_can_transfer;
+		esp->dma_dump_state = &dma_dump_state;
+		esp->dma_init_read = NULL;
+		esp->dma_init_write = NULL;
+		esp->dma_ints_off = &dma_ints_off;
+		esp->dma_ints_on = &dma_ints_on;
+
+		esp->dma_ports_p = &dma_ports_p;
+
+
+		/* Optional functions */
+		esp->dma_barrier = NULL;
+		esp->dma_drain = NULL;
+		esp->dma_invalidate = NULL;
+		esp->dma_irq_entry = NULL;
+		esp->dma_irq_exit = NULL;
+		esp->dma_led_on = NULL;
+		esp->dma_led_off = NULL;
+		esp->dma_poll = NULL;
+		esp->dma_reset = NULL;
+
+		/* SCSI chip speed */
+		/* below esp->cfreq = 40000000; */
+
+
+		if (quick) {
+			/* 'quick' means there's handshake glue logic like in the 5380 case */
+			esp->dma_setup = &dma_setup_quick;
+		} else {
+			esp->dma_setup = &dma_setup;
+		}
+
+		if (chipnum == 0) {
+
+			esp->irq = IRQ_MAC_SCSI;
+
+			request_irq(IRQ_MAC_SCSI, esp_intr, 0, "Mac ESP SCSI", esp->ehost);
+#if 0	/* conflicts with IOP ADB */
+			request_irq(IRQ_MAC_SCSIDRQ, fake_drq, 0, "Mac ESP DRQ", esp->ehost);
+#endif
+
+			if (macintosh_config->scsi_type == MAC_SCSI_QUADRA) {
+				esp->cfreq = 16500000;
+			} else {
+				esp->cfreq = 25000000;
+			}
+
+
+		} else { /* chipnum == 1 */
+
+			esp->irq = IRQ_MAC_SCSIDRQ;
+#if 0	/* conflicts with IOP ADB */
+			request_irq(IRQ_MAC_SCSIDRQ, esp_intr, 0, "Mac ESP SCSI 2", esp->ehost);
+#endif
+
+			esp->cfreq = 25000000;
+
+		}
+
+		if (quick) {
+			printk("esp: using quick version\n");
+		}
+
+		printk("esp: addr at 0x%p\n", esp->eregs);
+
+		esp->scsi_id = 7;
+		esp->diff = 0;
+
+		esp_initialize(esp);
+
+	} /* for chipnum */
+
+	if (chipspresent)
+		printk("\nmac_esp: %d esp controllers found\n", chipspresent);
+
+	esp_initialized = chipspresent;
+
+	return chipspresent;
+}
+
+static int mac_esp_release(struct Scsi_Host *shost)
+{
+	if (shost->irq)
+		free_irq(shost->irq, NULL);
+	if (shost->io_port && shost->n_io_port)
+		release_region(shost->io_port, shost->n_io_port);
+	scsi_unregister(shost);
+	return 0;
+}
+
+/*
+ * I've been wondering what this is supposed to do, for some time. Talking 
+ * to Allen Briggs: These machines have an extra register someplace where the
+ * DRQ pin of the ESP can be monitored. That isn't useful for determining 
+ * anything else (such as reselect interrupt or other magic) though. 
+ * Maybe make the semantics should be changed like 
+ * if (esp->current_SC)
+ *	... check DRQ flag ...
+ * else 
+ *	... disconnected, check pending VIA interrupt ...
+ *
+ * There's a problem with using the dabf flag or mac_irq_pending() here: both
+ * seem to return 1 even though no interrupt is currently pending, resulting
+ * in esp_exec_cmd() holding off the next command, and possibly infinite loops
+ * in esp_intr(). 
+ * Short term fix: just use esp_status & ESP_STAT_INTR here, as long as we
+ * use simple PIO. The DRQ status will be important when implementing pseudo
+ * DMA mode (set up ESP transfer count, return, do a batch of bytes in PIO or 
+ * 'hardware handshake' mode upon DRQ).
+ * If you plan on changing this (i.e. to save the esp_status register access in 
+ * favor of a VIA register access or a shadow register for the IFR), make sure
+ * to try a debug version of this first to monitor what registers would be a good
+ * indicator of the ESP interrupt.
+ */
+
+static int esp_dafb_dma_irq_p(struct NCR_ESP * esp)
+{
+	unsigned int ret;
+	int sreg = esp_read(esp->eregs->esp_status);
+
+#ifdef DEBUG_MAC_ESP
+	printk("mac_esp: esp_dafb_dma_irq_p dafb %d irq %d\n", 
+		readl(esp->dregs), mac_irq_pending(IRQ_MAC_SCSI));
+#endif
+
+	sreg &= ESP_STAT_INTR;
+
+	/*
+	 * maybe working; this is essentially what's used for iosb_dma_irq_p
+	 */
+	if (sreg)
+		return 1;
+	else
+		return 0;
+
+	/*
+	 * didn't work ...
+	 */
+#if 0
+	if (esp->current_SC)
+		ret = readl(esp->dregs) & 0x200;
+	else if (esp->disconnected_SC)
+		ret = 1; /* sreg ?? */
+	else
+		ret = mac_irq_pending(IRQ_MAC_SCSI);
+
+	return(ret);
+#endif
+
+}
+
+/*
+ * See above: testing mac_irq_pending always returned 8 (SCSI IRQ) regardless 
+ * of the actual ESP status.
+ */
+
+static int esp_iosb_dma_irq_p(struct NCR_ESP * esp)
+{
+	int ret  = mac_irq_pending(IRQ_MAC_SCSI) || mac_irq_pending(IRQ_MAC_SCSIDRQ);
+	int sreg = esp_read(esp->eregs->esp_status);
+
+#ifdef DEBUG_MAC_ESP
+	printk("mac_esp: dma_irq_p drq %d irq %d sreg %x curr %p disc %p\n", 
+		mac_irq_pending(IRQ_MAC_SCSIDRQ), mac_irq_pending(IRQ_MAC_SCSI), 
+		sreg, esp->current_SC, esp->disconnected_SC);
+#endif
+
+	sreg &= ESP_STAT_INTR;
+
+	if (sreg)
+		return (sreg);
+	else
+		return 0;
+}
+
+/*
+ * This seems to be OK for PIO at least ... usually 0 after PIO.
+ */
+
+static int dma_bytes_sent(struct NCR_ESP * esp, int fifo_count)
+{
+
+#ifdef DEBUG_MAC_ESP
+	printk("mac_esp: dma bytes sent = %x\n", fifo_count);
+#endif
+
+	return fifo_count;
+}
+
+/*
+ * dma_can_transfer is used to switch between DMA and PIO, if DMA (pseudo)
+ * is ever implemented. Returning 0 here will use PIO.
+ */
+
+static int dma_can_transfer(struct NCR_ESP * esp, Scsi_Cmnd * sp)
+{
+	unsigned long sz = sp->SCp.this_residual;
+#if 0	/* no DMA yet; make conditional */
+	if (sz > 0x10000000) {
+		sz = 0x10000000;
+	}
+	printk("mac_esp: dma can transfer = 0lx%x\n", sz);
+#else
+
+#ifdef DEBUG_MAC_ESP
+	printk("mac_esp: pio to transfer = %ld\n", sz);
+#endif
+
+	sz = 0;
+#endif
+	return sz;
+}
+
+/*
+ * Not yet ...
+ */
+
+static void dma_dump_state(struct NCR_ESP * esp)
+{
+#ifdef DEBUG_MAC_ESP
+	printk("mac_esp: dma_dump_state: called\n");
+#endif
+#if 0
+	ESPLOG(("esp%d: dma -- cond_reg<%02x>\n",
+		esp->esp_id, ((struct mac_dma_registers *)
+		(esp->dregs))->cond_reg));
+#endif
+}
+
+/*
+ * DMA setup: should be used to set up the ESP transfer count for pseudo
+ * DMA transfers; need a DRQ transfer function to do the actual transfer
+ */
+
+static void dma_init_read(struct NCR_ESP * esp, char * vaddress, int length)
+{
+	printk("mac_esp: dma_init_read\n");
+}
+
+
+static void dma_init_write(struct NCR_ESP * esp, char * vaddress, int length)
+{
+	printk("mac_esp: dma_init_write\n");
+}
+
+
+static void dma_ints_off(struct NCR_ESP * esp)
+{
+	mac_turnoff_irq(esp->irq);
+}
+
+
+static void dma_ints_on(struct NCR_ESP * esp)
+{
+	mac_turnon_irq(esp->irq);
+}
+
+/*
+ * generic dma_irq_p(), unused
+ */
+
+static int dma_irq_p(struct NCR_ESP * esp)
+{
+	int i = esp_read(esp->eregs->esp_status);
+
+#ifdef DEBUG_MAC_ESP
+	printk("mac_esp: dma_irq_p status %d\n", i);
+#endif
+
+	return (i & ESP_STAT_INTR);
+}
+
+static int dma_irq_p_quick(struct NCR_ESP * esp)
+{
+	/*
+	 * Copied from iosb_dma_irq_p()
+	 */
+	int ret  = mac_irq_pending(IRQ_MAC_SCSI) || mac_irq_pending(IRQ_MAC_SCSIDRQ);
+	int sreg = esp_read(esp->eregs->esp_status);
+
+#ifdef DEBUG_MAC_ESP
+	printk("mac_esp: dma_irq_p drq %d irq %d sreg %x curr %p disc %p\n", 
+		mac_irq_pending(IRQ_MAC_SCSIDRQ), mac_irq_pending(IRQ_MAC_SCSI), 
+		sreg, esp->current_SC, esp->disconnected_SC);
+#endif
+
+	sreg &= ESP_STAT_INTR;
+
+	if (sreg)
+		return (sreg);
+	else
+		return 0;
+
+}
+
+static void dma_led_off(struct NCR_ESP * esp)
+{
+#ifdef DEBUG_MAC_ESP
+	printk("mac_esp: dma_led_off: called\n");
+#endif
+}
+
+
+static void dma_led_on(struct NCR_ESP * esp)
+{
+#ifdef DEBUG_MAC_ESP
+	printk("mac_esp: dma_led_on: called\n");
+#endif
+}
+
+
+static int dma_ports_p(struct NCR_ESP * esp)
+{
+	return 0;
+}
+
+
+static void dma_setup(struct NCR_ESP * esp, __u32 addr, int count, int write)
+{
+
+#ifdef DEBUG_MAC_ESP
+	printk("mac_esp: dma_setup\n");
+#endif
+
+	if (write) {
+		dma_init_read(esp, (char *) addr, count);
+	} else {
+		dma_init_write(esp, (char *) addr, count);
+	}
+}
+
+
+static void dma_setup_quick(struct NCR_ESP * esp, __u32 addr, int count, int write)
+{
+#ifdef DEBUG_MAC_ESP
+	printk("mac_esp: dma_setup_quick\n");
+#endif
+}
+
+static Scsi_Host_Template driver_template = {
+	.proc_name		= "mac_esp",
+	.name			= "Mac 53C9x SCSI",
+	.detect			= mac_esp_detect,
+	.slave_alloc		= esp_slave_alloc,
+	.slave_destroy		= esp_slave_destroy,
+	.release		= mac_esp_release,
+	.info			= esp_info,
+	.queuecommand		= esp_queue,
+	.eh_abort_handler	= esp_abort,
+	.eh_bus_reset_handler	= esp_reset,
+	.can_queue		= 7,
+	.this_id		= 7,
+	.sg_tablesize		= SG_ALL,
+	.cmd_per_lun		= 1,
+	.use_clustering		= DISABLE_CLUSTERING
+};
+
+
+#include "scsi_module.c"
+
+MODULE_LICENSE("GPL");
