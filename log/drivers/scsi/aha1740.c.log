commit 0f3d679159f4cfb015abbb39e6031e79ccf64b05
Author: Christophe JAILLET <christophe.jaillet@wanadoo.fr>
Date:   Fri Feb 28 22:59:48 2020 +0100

    scsi: aha1740: Fix an errro handling path in aha1740_probe()
    
    If 'dma_map_single()' fails, the ref counted 'shpnt' will be decremented
    twice because 'scsi_host_put()' is called in the if block, and in the error
    handling path.
    
    Axe one of these calls.
    
    Link: https://lore.kernel.org/r/20200228215948.7473-1-christophe.jaillet@wanadoo.fr
    Fixes: 1dc09e120c83 ("scsi: aha1740: stop using scsi_unregister")
    Signed-off-by: Christophe JAILLET <christophe.jaillet@wanadoo.fr>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/aha1740.c b/drivers/scsi/aha1740.c
index da4150c17781..5a227c03895f 100644
--- a/drivers/scsi/aha1740.c
+++ b/drivers/scsi/aha1740.c
@@ -592,7 +592,6 @@ static int aha1740_probe (struct device *dev)
 					     DMA_BIDIRECTIONAL);
 	if (!host->ecb_dma_addr) {
 		printk (KERN_ERR "aha1740_probe: Couldn't map ECB, giving up\n");
-		scsi_host_put (shpnt);
 		goto err_host_put;
 	}
 	

commit 2a3d4eb8e228061c09d5ca8bf39e7f00c2091213
Author: Christoph Hellwig <hch@lst.de>
Date:   Thu Dec 13 16:17:02 2018 +0100

    scsi: flip the default on use_clustering
    
    Most SCSI drivers want to enable "clustering", that is merging of
    segments so that they might span more than a single page.  Remove the
    ENABLE_CLUSTERING define, and require drivers to explicitly set
    DISABLE_CLUSTERING to disable this feature.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/aha1740.c b/drivers/scsi/aha1740.c
index 786bf7f32c64..da4150c17781 100644
--- a/drivers/scsi/aha1740.c
+++ b/drivers/scsi/aha1740.c
@@ -545,7 +545,6 @@ static struct scsi_host_template aha1740_template = {
 	.can_queue        = AHA1740_ECBS,
 	.this_id          = 7,
 	.sg_tablesize     = AHA1740_SCATTER,
-	.use_clustering   = ENABLE_CLUSTERING,
 	.eh_abort_handler = aha1740_eh_abort_handler,
 };
 

commit 91ebc1facd7797d799a4c9208cb7fdc8d86e0bb4
Author: Johannes Thumshirn <jthumshirn@suse.de>
Date:   Wed Jun 13 09:53:47 2018 +0200

    scsi: core: remove Scsi_Cmnd typedef
    
    This will make subsequent refactoring easier to handle.
    
    Note: this patch is nowhere checkpatch clean.
    
    Signed-off-by: Johannes Thumshirn <jthumshirn@suse.de>
    Reviewed-by: Bart Van Assche <bart.vanassche@wdc.com>
    Reviewed-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/aha1740.c b/drivers/scsi/aha1740.c
index b48d5436f094..786bf7f32c64 100644
--- a/drivers/scsi/aha1740.c
+++ b/drivers/scsi/aha1740.c
@@ -207,11 +207,11 @@ static int aha1740_test_port(unsigned int base)
 static irqreturn_t aha1740_intr_handle(int irq, void *dev_id)
 {
 	struct Scsi_Host *host = (struct Scsi_Host *) dev_id;
-        void (*my_done)(Scsi_Cmnd *);
+        void (*my_done)(struct scsi_cmnd *);
 	int errstatus, adapstat;
 	int number_serviced;
 	struct ecb *ecbptr;
-	Scsi_Cmnd *SCtmp;
+	struct scsi_cmnd *SCtmp;
 	unsigned int base;
 	unsigned long flags;
 	int handled = 0;
@@ -311,7 +311,8 @@ static irqreturn_t aha1740_intr_handle(int irq, void *dev_id)
 	return IRQ_RETVAL(handled);
 }
 
-static int aha1740_queuecommand_lck(Scsi_Cmnd * SCpnt, void (*done)(Scsi_Cmnd *))
+static int aha1740_queuecommand_lck(struct scsi_cmnd * SCpnt,
+				    void (*done)(struct scsi_cmnd *))
 {
 	unchar direction;
 	unchar *cmd = (unchar *) SCpnt->cmnd;
@@ -520,7 +521,7 @@ static int aha1740_biosparam(struct scsi_device *sdev,
 	return 0;
 }
 
-static int aha1740_eh_abort_handler (Scsi_Cmnd *dummy)
+static int aha1740_eh_abort_handler (struct scsi_cmnd *dummy)
 {
 /*
  * From Alan Cox :

commit 1dc09e120c83143bdccf2e445f604666e7eebc11
Author: Christoph Hellwig <hch@lst.de>
Date:   Wed Mar 14 12:48:25 2018 +0100

    scsi: aha1740: stop using scsi_unregister
    
    aha1740 doesn't use scsi_register, so it should not use scsi_unregister
    either.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/aha1740.c b/drivers/scsi/aha1740.c
index bad35ffc015d..b48d5436f094 100644
--- a/drivers/scsi/aha1740.c
+++ b/drivers/scsi/aha1740.c
@@ -592,7 +592,7 @@ static int aha1740_probe (struct device *dev)
 					     DMA_BIDIRECTIONAL);
 	if (!host->ecb_dma_addr) {
 		printk (KERN_ERR "aha1740_probe: Couldn't map ECB, giving up\n");
-		scsi_unregister (shpnt);
+		scsi_host_put (shpnt);
 		goto err_host_put;
 	}
 	

commit b84b1d522f979fb53ad347605e24b2940fa2ad99
Author: Hannes Reinecke <hare@suse.de>
Date:   Wed Apr 29 08:57:34 2015 +0200

    scsi: Do not set cmd_per_lun to 1 in the host template
    
    '0' is now used as the default cmd_per_lun value,
    so there's no need to explicitly set it to '1' in the
    host template.
    
    Signed-off-by: Hannes Reinecke <hare@suse.de>
    Reviewed-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: James Bottomley <JBottomley@Odin.com>

diff --git a/drivers/scsi/aha1740.c b/drivers/scsi/aha1740.c
index 31ace4bef8fe..bad35ffc015d 100644
--- a/drivers/scsi/aha1740.c
+++ b/drivers/scsi/aha1740.c
@@ -544,7 +544,6 @@ static struct scsi_host_template aha1740_template = {
 	.can_queue        = AHA1740_ECBS,
 	.this_id          = 7,
 	.sg_tablesize     = AHA1740_SCATTER,
-	.cmd_per_lun      = AHA1740_CMDLUN,
 	.use_clustering   = ENABLE_CLUSTERING,
 	.eh_abort_handler = aha1740_eh_abort_handler,
 };

commit b6c92b7e0af575e2b8b05bdf33633cf9e1661cbf
Author: Hannes Reinecke <hare@suse.de>
Date:   Thu Oct 30 09:44:36 2014 +0100

    scsi: correct return values for .eh_abort_handler implementations
    
    The .eh_abort_handler needs to return SUCCESS, FAILED, or
    FAST_IO_FAIL. So fixup all callers to adhere to this requirement.
    
    Reviewed-by: Robert Elliott <elliott@hp.com>
    Cc: <stable@vger.kernel.org>
    Signed-off-by: Hannes Reinecke <hare@suse.de>
    Signed-off-by: Christoph Hellwig <hch@lst.de>

diff --git a/drivers/scsi/aha1740.c b/drivers/scsi/aha1740.c
index 5f3101797c93..31ace4bef8fe 100644
--- a/drivers/scsi/aha1740.c
+++ b/drivers/scsi/aha1740.c
@@ -531,7 +531,7 @@ static int aha1740_eh_abort_handler (Scsi_Cmnd *dummy)
  * quiet as possible...
  */
 
-	return 0;
+	return SUCCESS;
 }
 
 static struct scsi_host_template aha1740_template = {

commit e633c1e55731cd3e85285aa0c792dafb54ae7225
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Sun Mar 31 03:15:00 2013 -0400

    aha1740: switch to ->show_info()
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/drivers/scsi/aha1740.c b/drivers/scsi/aha1740.c
index df775e6ba579..5f3101797c93 100644
--- a/drivers/scsi/aha1740.c
+++ b/drivers/scsi/aha1740.c
@@ -106,33 +106,14 @@ static inline dma_addr_t ecb_cpu_to_dma (struct Scsi_Host *host, void *cpu)
 	return hdata->ecb_dma_addr + offset;
 }
 
-static int aha1740_proc_info(struct Scsi_Host *shpnt, char *buffer,
-			     char **start, off_t offset,
-			     int length, int inout)
+static int aha1740_show_info(struct seq_file *m, struct Scsi_Host *shpnt)
 {
-	int len;
-	struct aha1740_hostdata *host;
-
-	if (inout)
-		return-ENOSYS;
-
-	host = HOSTDATA(shpnt);
-
-	len = sprintf(buffer, "aha174x at IO:%lx, IRQ %d, SLOT %d.\n"
+	struct aha1740_hostdata *host = HOSTDATA(shpnt);
+	seq_printf(m, "aha174x at IO:%lx, IRQ %d, SLOT %d.\n"
 		      "Extended translation %sabled.\n",
 		      shpnt->io_port, shpnt->irq, host->edev->slot,
 		      host->translation ? "en" : "dis");
-
-	if (offset > len) {
-		*start = buffer;
-		return 0;
-	}
-
-	*start = buffer + offset;
-	len -= offset;
-	if (len > length)
-		len = length;
-	return len;
+	return 0;
 }
 
 static int aha1740_makecode(unchar *sense, unchar *status)
@@ -556,7 +537,7 @@ static int aha1740_eh_abort_handler (Scsi_Cmnd *dummy)
 static struct scsi_host_template aha1740_template = {
 	.module           = THIS_MODULE,
 	.proc_name        = "aha1740",
-	.proc_info        = aha1740_proc_info,
+	.show_info        = aha1740_show_info,
 	.name             = "Adaptec 174x (EISA)",
 	.queuecommand     = aha1740_queuecommand,
 	.bios_param       = aha1740_biosparam,

commit 6f039790510fd630ff348efe8c4802dbaa041fba
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Fri Dec 21 13:08:55 2012 -0800

    Drivers: scsi: remove __dev* attributes.
    
    CONFIG_HOTPLUG is going away as an option.  As a result, the __dev*
    markings need to be removed.
    
    This change removes the use of __devinit, __devexit_p, __devinitdata,
    __devinitconst, and __devexit from these drivers.
    
    Based on patches originally written by Bill Pemberton, but redone by me
    in order to handle some of the coding style issues better, by hand.
    
    Cc: Bill Pemberton <wfp5p@virginia.edu>
    Cc: Adam Radford <linuxraid@lsi.com>
    Cc: "James E.J. Bottomley" <JBottomley@parallels.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/scsi/aha1740.c b/drivers/scsi/aha1740.c
index a3e6ed353917..df775e6ba579 100644
--- a/drivers/scsi/aha1740.c
+++ b/drivers/scsi/aha1740.c
@@ -646,7 +646,7 @@ static int aha1740_probe (struct device *dev)
 	return -ENODEV;
 }
 
-static __devexit int aha1740_remove (struct device *dev)
+static int aha1740_remove (struct device *dev)
 {
 	struct Scsi_Host *shpnt = dev_get_drvdata(dev);
 	struct aha1740_hostdata *host = HOSTDATA (shpnt);
@@ -677,7 +677,7 @@ static struct eisa_driver aha1740_driver = {
 	.driver   = {
 		.name    = "aha1740",
 		.probe   = aha1740_probe,
-		.remove  = __devexit_p (aha1740_remove),
+		.remove  = aha1740_remove,
 	},
 };
 

commit 9ffc93f203c18a70623f21950f1dd473c9ec48cd
Author: David Howells <dhowells@redhat.com>
Date:   Wed Mar 28 18:30:03 2012 +0100

    Remove all #inclusions of asm/system.h
    
    Remove all #inclusions of asm/system.h preparatory to splitting and killing
    it.  Performed with the following command:
    
    perl -p -i -e 's!^#\s*include\s*<asm/system[.]h>.*\n!!' `grep -Irl '^#\s*include\s*<asm/system[.]h>' *`
    
    Signed-off-by: David Howells <dhowells@redhat.com>

diff --git a/drivers/scsi/aha1740.c b/drivers/scsi/aha1740.c
index 1c10b796c1a2..a3e6ed353917 100644
--- a/drivers/scsi/aha1740.c
+++ b/drivers/scsi/aha1740.c
@@ -53,7 +53,6 @@
 #include <linux/gfp.h>
 
 #include <asm/dma.h>
-#include <asm/system.h>
 #include <asm/io.h>
 
 #include "scsi.h"

commit 25985edcedea6396277003854657b5f3cb31a628
Author: Lucas De Marchi <lucas.demarchi@profusion.mobi>
Date:   Wed Mar 30 22:57:33 2011 -0300

    Fix common misspellings
    
    Fixes generated by 'codespell' and manually reviewed.
    
    Signed-off-by: Lucas De Marchi <lucas.demarchi@profusion.mobi>

diff --git a/drivers/scsi/aha1740.c b/drivers/scsi/aha1740.c
index d058f1ab82b5..1c10b796c1a2 100644
--- a/drivers/scsi/aha1740.c
+++ b/drivers/scsi/aha1740.c
@@ -461,7 +461,7 @@ static int aha1740_queuecommand_lck(Scsi_Cmnd * SCpnt, void (*done)(Scsi_Cmnd *)
 	/* The Adaptec Spec says the card is so fast that the loops
            will only be executed once in the code below. Even if this
            was true with the fastest processors when the spec was
-           written, it doesn't seem to be true with todays fast
+           written, it doesn't seem to be true with today's fast
            processors. We print a warning if the code is executed more
            often than LOOPCNT_WARN. If this happens, it should be
            investigated. If the count reaches LOOPCNT_MAX, we assume

commit f281233d3eba15fb225d21ae2e228fd4553d824a
Author: Jeff Garzik <jeff@garzik.org>
Date:   Tue Nov 16 02:10:29 2010 -0500

    SCSI host lock push-down
    
    Move the mid-layer's ->queuecommand() invocation from being locked
    with the host lock to being unlocked to facilitate speeding up the
    critical path for drivers who don't need this lock taken anyway.
    
    The patch below presents a simple SCSI host lock push-down as an
    equivalent transformation.  No locking or other behavior should change
    with this patch.  All existing bugs and locking orders are preserved.
    
    Additionally, add one parameter to queuecommand,
            struct Scsi_Host *
    and remove one parameter from queuecommand,
            void (*done)(struct scsi_cmnd *)
    
    Scsi_Host* is a convenient pointer that most host drivers need anyway,
    and 'done' is redundant to struct scsi_cmnd->scsi_done.
    
    Minimal code disturbance was attempted with this change.  Most drivers
    needed only two one-line modifications for their host lock push-down.
    
    Signed-off-by: Jeff Garzik <jgarzik@redhat.com>
    Acked-by: James Bottomley <James.Bottomley@suse.de>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/scsi/aha1740.c b/drivers/scsi/aha1740.c
index 0107a4cc3331..d058f1ab82b5 100644
--- a/drivers/scsi/aha1740.c
+++ b/drivers/scsi/aha1740.c
@@ -331,7 +331,7 @@ static irqreturn_t aha1740_intr_handle(int irq, void *dev_id)
 	return IRQ_RETVAL(handled);
 }
 
-static int aha1740_queuecommand(Scsi_Cmnd * SCpnt, void (*done)(Scsi_Cmnd *))
+static int aha1740_queuecommand_lck(Scsi_Cmnd * SCpnt, void (*done)(Scsi_Cmnd *))
 {
 	unchar direction;
 	unchar *cmd = (unchar *) SCpnt->cmnd;
@@ -503,6 +503,8 @@ static int aha1740_queuecommand(Scsi_Cmnd * SCpnt, void (*done)(Scsi_Cmnd *))
 	return 0;
 }
 
+static DEF_SCSI_QCMD(aha1740_queuecommand)
+
 /* Query the board for its irq_level and irq_type.  Nothing else matters
    in enhanced mode on an EISA bus. */
 

commit 5a0e3ad6af8660be21ca98a971cd00f331318c05
Author: Tejun Heo <tj@kernel.org>
Date:   Wed Mar 24 17:04:11 2010 +0900

    include cleanup: Update gfp.h and slab.h includes to prepare for breaking implicit slab.h inclusion from percpu.h
    
    percpu.h is included by sched.h and module.h and thus ends up being
    included when building most .c files.  percpu.h includes slab.h which
    in turn includes gfp.h making everything defined by the two files
    universally available and complicating inclusion dependencies.
    
    percpu.h -> slab.h dependency is about to be removed.  Prepare for
    this change by updating users of gfp and slab facilities include those
    headers directly instead of assuming availability.  As this conversion
    needs to touch large number of source files, the following script is
    used as the basis of conversion.
    
      http://userweb.kernel.org/~tj/misc/slabh-sweep.py
    
    The script does the followings.
    
    * Scan files for gfp and slab usages and update includes such that
      only the necessary includes are there.  ie. if only gfp is used,
      gfp.h, if slab is used, slab.h.
    
    * When the script inserts a new include, it looks at the include
      blocks and try to put the new include such that its order conforms
      to its surrounding.  It's put in the include block which contains
      core kernel includes, in the same order that the rest are ordered -
      alphabetical, Christmas tree, rev-Xmas-tree or at the end if there
      doesn't seem to be any matching order.
    
    * If the script can't find a place to put a new include (mostly
      because the file doesn't have fitting include block), it prints out
      an error message indicating which .h file needs to be added to the
      file.
    
    The conversion was done in the following steps.
    
    1. The initial automatic conversion of all .c files updated slightly
       over 4000 files, deleting around 700 includes and adding ~480 gfp.h
       and ~3000 slab.h inclusions.  The script emitted errors for ~400
       files.
    
    2. Each error was manually checked.  Some didn't need the inclusion,
       some needed manual addition while adding it to implementation .h or
       embedding .c file was more appropriate for others.  This step added
       inclusions to around 150 files.
    
    3. The script was run again and the output was compared to the edits
       from #2 to make sure no file was left behind.
    
    4. Several build tests were done and a couple of problems were fixed.
       e.g. lib/decompress_*.c used malloc/free() wrappers around slab
       APIs requiring slab.h to be added manually.
    
    5. The script was run on all .h files but without automatically
       editing them as sprinkling gfp.h and slab.h inclusions around .h
       files could easily lead to inclusion dependency hell.  Most gfp.h
       inclusion directives were ignored as stuff from gfp.h was usually
       wildly available and often used in preprocessor macros.  Each
       slab.h inclusion directive was examined and added manually as
       necessary.
    
    6. percpu.h was updated not to include slab.h.
    
    7. Build test were done on the following configurations and failures
       were fixed.  CONFIG_GCOV_KERNEL was turned off for all tests (as my
       distributed build env didn't work with gcov compiles) and a few
       more options had to be turned off depending on archs to make things
       build (like ipr on powerpc/64 which failed due to missing writeq).
    
       * x86 and x86_64 UP and SMP allmodconfig and a custom test config.
       * powerpc and powerpc64 SMP allmodconfig
       * sparc and sparc64 SMP allmodconfig
       * ia64 SMP allmodconfig
       * s390 SMP allmodconfig
       * alpha SMP allmodconfig
       * um on x86_64 SMP allmodconfig
    
    8. percpu.h modifications were reverted so that it could be applied as
       a separate patch and serve as bisection point.
    
    Given the fact that I had only a couple of failures from tests on step
    6, I'm fairly confident about the coverage of this conversion patch.
    If there is a breakage, it's likely to be something in one of the arch
    headers which should be easily discoverable easily on most builds of
    the specific arch.
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Guess-its-ok-by: Christoph Lameter <cl@linux-foundation.org>
    Cc: Ingo Molnar <mingo@redhat.com>
    Cc: Lee Schermerhorn <Lee.Schermerhorn@hp.com>

diff --git a/drivers/scsi/aha1740.c b/drivers/scsi/aha1740.c
index 538135783aab..0107a4cc3331 100644
--- a/drivers/scsi/aha1740.c
+++ b/drivers/scsi/aha1740.c
@@ -50,6 +50,7 @@
 #include <linux/device.h>
 #include <linux/eisa.h>
 #include <linux/dma-mapping.h>
+#include <linux/gfp.h>
 
 #include <asm/dma.h>
 #include <asm/system.h>

commit 78c55d76b84628862079351f77aa0f4aa3b65f58
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Thu Apr 30 14:43:31 2009 -0700

    scsi: remove driver_data direct access of struct device
    
    In the near future, the driver core is going to not allow direct access
    to the driver_data pointer in struct device.  Instead, the functions
    dev_get_drvdata() and dev_set_drvdata() should be used.  These functions
    have been around since the beginning, so are backwards compatible with
    all older kernel versions.
    
    Cc: linux-scsi@vger.kernel.org
    Cc: James Bottomley <James.Bottomley@HansenPartnership.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/scsi/aha1740.c b/drivers/scsi/aha1740.c
index ed0e3e55652a..538135783aab 100644
--- a/drivers/scsi/aha1740.c
+++ b/drivers/scsi/aha1740.c
@@ -646,7 +646,7 @@ static int aha1740_probe (struct device *dev)
 
 static __devexit int aha1740_remove (struct device *dev)
 {
-	struct Scsi_Host *shpnt = dev->driver_data;
+	struct Scsi_Host *shpnt = dev_get_drvdata(dev);
 	struct aha1740_hostdata *host = HOSTDATA (shpnt);
 
 	scsi_remove_host(shpnt);

commit fa195afe4ad3f6d85a9b7cc236ae85c05ca8db03
Author: Alan Cox <alan@lxorguk.ukuu.org.uk>
Date:   Mon Oct 27 15:16:36 2008 +0000

    [SCSI] Clean up my email address and use a single standard address for everything
    
    Signed-off-by: Alan Cox <alan@redhat.com>
    Signed-off-by: James Bottomley <James.Bottomley@HansenPartnership.com>

diff --git a/drivers/scsi/aha1740.c b/drivers/scsi/aha1740.c
index 7c45d88a205b..ed0e3e55652a 100644
--- a/drivers/scsi/aha1740.c
+++ b/drivers/scsi/aha1740.c
@@ -22,7 +22,7 @@
  * aha1740_makecode may still need even more work
  * if it doesn't work for your devices, take a look.
  *
- * Reworked for new_eh and new locking by Alan Cox <alan@redhat.com>
+ * Reworked for new_eh and new locking by Alan Cox <alan@lxorguk.ukuu.org.uk>
  *
  * Converted to EISA and generic DMA APIs by Marc Zyngier
  * <maz@wild-wind.fr.eu.org>, 4/2003.

commit d3f46f39b7092594b498abc12f0c73b0b9913bde
Author: James Bottomley <James.Bottomley@HansenPartnership.com>
Date:   Tue Jan 15 11:11:46 2008 -0600

    [SCSI] remove use_sg_chaining
    
    With the sg table code, every SCSI driver is now either chain capable
    or broken (or has sg_tablesize set so chaining is never activated), so
    there's no need to have a check in the host template.
    
    Also tidy up the code by moving the scatterlist size defines into the
    SCSI includes and permit the last entry of the scatterlist pools not
    to be a power of two.
    Signed-off-by: James Bottomley <James.Bottomley@HansenPartnership.com>

diff --git a/drivers/scsi/aha1740.c b/drivers/scsi/aha1740.c
index be58a0b097c7..7c45d88a205b 100644
--- a/drivers/scsi/aha1740.c
+++ b/drivers/scsi/aha1740.c
@@ -563,7 +563,6 @@ static struct scsi_host_template aha1740_template = {
 	.sg_tablesize     = AHA1740_SCATTER,
 	.cmd_per_lun      = AHA1740_CMDLUN,
 	.use_clustering   = ENABLE_CLUSTERING,
-	.use_sg_chaining  = ENABLE_SG_CHAINING,
 	.eh_abort_handler = aha1740_eh_abort_handler,
 };
 

commit b80ca4f7ee36c26d300c5a8f429e73372d153379
Author: FUJITA Tomonori <tomof@acm.org>
Date:   Sun Jan 13 15:46:13 2008 +0900

    [SCSI] replace sizeof sense_buffer with SCSI_SENSE_BUFFERSIZE
    
    This replaces sizeof sense_buffer with SCSI_SENSE_BUFFERSIZE in
    several LLDs. It's a preparation for the future changes to remove
    sense_buffer array in scsi_cmnd structure.
    
    Signed-off-by: FUJITA Tomonori <fujita.tomonori@lab.ntt.co.jp>
    Signed-off-by: James Bottomley <James.Bottomley@HansenPartnership.com>

diff --git a/drivers/scsi/aha1740.c b/drivers/scsi/aha1740.c
index f6722fd46008..be58a0b097c7 100644
--- a/drivers/scsi/aha1740.c
+++ b/drivers/scsi/aha1740.c
@@ -286,7 +286,7 @@ static irqreturn_t aha1740_intr_handle(int irq, void *dev_id)
 			   cdb when we come back */
 			if ( (adapstat & G2INTST_MASK) == G2INTST_CCBERROR ) {
 				memcpy(SCtmp->sense_buffer, ecbptr->sense, 
-				       sizeof(SCtmp->sense_buffer));
+				       SCSI_SENSE_BUFFERSIZE);
 				errstatus = aha1740_makecode(ecbptr->sense,ecbptr->status);
 			} else
 				errstatus = 0;

commit 9cb83c7529d929c00f37d821daed1942a1b20602
Author: FUJITA Tomonori <tomof@acm.org>
Date:   Tue Oct 16 11:24:32 2007 +0200

    [SCSI] add use_sg_chaining option to scsi_host_template
    
    This option is true if a low-level driver can support sg
    chaining. This will be removed eventually when all the drivers are
    converted to support sg chaining. q->max_phys_segments is set to
    SCSI_MAX_SG_SEGMENTS if false.
    
    Signed-off-by: FUJITA Tomonori <fujita.tomonori@lab.ntt.co.jp>
    Signed-off-by: Jens Axboe <jens.axboe@oracle.com>

diff --git a/drivers/scsi/aha1740.c b/drivers/scsi/aha1740.c
index e4a4f3a965d9..f6722fd46008 100644
--- a/drivers/scsi/aha1740.c
+++ b/drivers/scsi/aha1740.c
@@ -563,6 +563,7 @@ static struct scsi_host_template aha1740_template = {
 	.sg_tablesize     = AHA1740_SCATTER,
 	.cmd_per_lun      = AHA1740_CMDLUN,
 	.use_clustering   = ENABLE_CLUSTERING,
+	.use_sg_chaining  = ENABLE_SG_CHAINING,
 	.eh_abort_handler = aha1740_eh_abort_handler,
 };
 

commit c66cc13c16377d177d8887f15a3cc42ab3866f57
Author: FUJITA Tomonori <fujita.tomonori@lab.ntt.co.jp>
Date:   Mon May 14 20:26:06 2007 +0900

    [SCSI] aha1740: convert to use the data buffer accessors
    
    - remove the unnecessary map_single path.
    
    - convert to use the new accessors for the sg lists and the
    parameters.
    
    Jens Axboe <jens.axboe@oracle.com> did the for_each_sg cleanup.
    
    Signed-off-by: FUJITA Tomonori <fujita.tomonori@lab.ntt.co.jp>
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>

diff --git a/drivers/scsi/aha1740.c b/drivers/scsi/aha1740.c
index d7af9c63a04d..e4a4f3a965d9 100644
--- a/drivers/scsi/aha1740.c
+++ b/drivers/scsi/aha1740.c
@@ -271,20 +271,8 @@ static irqreturn_t aha1740_intr_handle(int irq, void *dev_id)
 				continue;
 			}
 			sgptr = (struct aha1740_sg *) SCtmp->host_scribble;
-			if (SCtmp->use_sg) {
-				/* We used scatter-gather.
-				   Do the unmapping dance. */
-				dma_unmap_sg (&edev->dev,
-					      (struct scatterlist *) SCtmp->request_buffer,
-					      SCtmp->use_sg,
-					      SCtmp->sc_data_direction);
-			} else {
-				dma_unmap_single (&edev->dev,
-						  sgptr->buf_dma_addr,
-						  SCtmp->request_bufflen,
-						  DMA_BIDIRECTIONAL);
-			}
-	    
+			scsi_dma_unmap(SCtmp);
+
 			/* Free the sg block */
 			dma_free_coherent (&edev->dev,
 					   sizeof (struct aha1740_sg),
@@ -349,11 +337,9 @@ static int aha1740_queuecommand(Scsi_Cmnd * SCpnt, void (*done)(Scsi_Cmnd *))
 	unchar target = scmd_id(SCpnt);
 	struct aha1740_hostdata *host = HOSTDATA(SCpnt->device->host);
 	unsigned long flags;
-	void *buff = SCpnt->request_buffer;
-	int bufflen = SCpnt->request_bufflen;
 	dma_addr_t sg_dma;
 	struct aha1740_sg *sgptr;
-	int ecbno;
+	int ecbno, nseg;
 	DEB(int i);
 
 	if(*cmd == REQUEST_SENSE) {
@@ -423,24 +409,23 @@ static int aha1740_queuecommand(Scsi_Cmnd * SCpnt, void (*done)(Scsi_Cmnd *))
 	}
 	sgptr = (struct aha1740_sg *) SCpnt->host_scribble;
 	sgptr->sg_dma_addr = sg_dma;
-    
-	if (SCpnt->use_sg) {
-		struct scatterlist * sgpnt;
+
+	nseg = scsi_dma_map(SCpnt);
+	BUG_ON(nseg < 0);
+	if (nseg) {
+		struct scatterlist *sg;
 		struct aha1740_chain * cptr;
-		int i, count;
+		int i;
 		DEB(unsigned char * ptr);
 
 		host->ecb[ecbno].sg = 1;  /* SCSI Initiator Command
 					   * w/scatter-gather*/
-		sgpnt = (struct scatterlist *) SCpnt->request_buffer;
 		cptr = sgptr->sg_chain;
-		count = dma_map_sg (&host->edev->dev, sgpnt, SCpnt->use_sg,
-				    SCpnt->sc_data_direction);
-		for(i=0; i < count; i++) {
-			cptr[i].datalen = sg_dma_len (sgpnt + i);
-			cptr[i].dataptr = sg_dma_address (sgpnt + i);
+		scsi_for_each_sg(SCpnt, sg, nseg, i) {
+			cptr[i].datalen = sg_dma_len (sg);
+			cptr[i].dataptr = sg_dma_address (sg);
 		}
-		host->ecb[ecbno].datalen = count*sizeof(struct aha1740_chain);
+		host->ecb[ecbno].datalen = nseg * sizeof(struct aha1740_chain);
 		host->ecb[ecbno].dataptr = sg_dma;
 #ifdef DEBUG
 		printk("cptr %x: ",cptr);
@@ -448,11 +433,8 @@ static int aha1740_queuecommand(Scsi_Cmnd * SCpnt, void (*done)(Scsi_Cmnd *))
 		for(i=0;i<24;i++) printk("%02x ", ptr[i]);
 #endif
 	} else {
-		host->ecb[ecbno].datalen = bufflen;
-		sgptr->buf_dma_addr =  dma_map_single (&host->edev->dev,
-						       buff, bufflen,
-						       DMA_BIDIRECTIONAL);
-		host->ecb[ecbno].dataptr = sgptr->buf_dma_addr;
+		host->ecb[ecbno].datalen = 0;
+		host->ecb[ecbno].dataptr = 0;
 	}
 	host->ecb[ecbno].lun = SCpnt->device->lun;
 	host->ecb[ecbno].ses = 1; /* Suppress underrun errors */

commit 08157cd0787004e2ebf9ee8cc92257244da53848
Author: Jeff Garzik <jeff@garzik.org>
Date:   Wed Nov 8 19:56:19 2006 -0800

    [SCSI] SCSI/aha1740: handle SCSI API errors
    
    Signed-off-by: Jeff Garzik <jeff@garzik.org>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>

diff --git a/drivers/scsi/aha1740.c b/drivers/scsi/aha1740.c
index c3c38a7e8d32..d7af9c63a04d 100644
--- a/drivers/scsi/aha1740.c
+++ b/drivers/scsi/aha1740.c
@@ -586,7 +586,7 @@ static struct scsi_host_template aha1740_template = {
 
 static int aha1740_probe (struct device *dev)
 {
-	int slotbase;
+	int slotbase, rc;
 	unsigned int irq_level, irq_type, translation;
 	struct Scsi_Host *shpnt;
 	struct aha1740_hostdata *host;
@@ -641,10 +641,16 @@ static int aha1740_probe (struct device *dev)
 	}
 
 	eisa_set_drvdata (edev, shpnt);
-	scsi_add_host (shpnt, dev); /* XXX handle failure */
+
+	rc = scsi_add_host (shpnt, dev);
+	if (rc)
+		goto err_irq;
+
 	scsi_scan_host (shpnt);
 	return 0;
 
+ err_irq:
+ 	free_irq(irq_level, shpnt);
  err_unmap:
 	dma_unmap_single (&edev->dev, host->ecb_dma_addr,
 			  sizeof (host->ecb), DMA_BIDIRECTIONAL);

commit 7d12e780e003f93433d49ce78cfedf4b4c52adc5
Author: David Howells <dhowells@redhat.com>
Date:   Thu Oct 5 14:55:46 2006 +0100

    IRQ: Maintain regs pointer globally rather than passing to IRQ handlers
    
    Maintain a per-CPU global "struct pt_regs *" variable which can be used instead
    of passing regs around manually through all ~1800 interrupt handlers in the
    Linux kernel.
    
    The regs pointer is used in few places, but it potentially costs both stack
    space and code to pass it around.  On the FRV arch, removing the regs parameter
    from all the genirq function results in a 20% speed up of the IRQ exit path
    (ie: from leaving timer_interrupt() to leaving do_IRQ()).
    
    Where appropriate, an arch may override the generic storage facility and do
    something different with the variable.  On FRV, for instance, the address is
    maintained in GR28 at all times inside the kernel as part of general exception
    handling.
    
    Having looked over the code, it appears that the parameter may be handed down
    through up to twenty or so layers of functions.  Consider a USB character
    device attached to a USB hub, attached to a USB controller that posts its
    interrupts through a cascaded auxiliary interrupt controller.  A character
    device driver may want to pass regs to the sysrq handler through the input
    layer which adds another few layers of parameter passing.
    
    I've build this code with allyesconfig for x86_64 and i386.  I've runtested the
    main part of the code on FRV and i386, though I can't test most of the drivers.
    I've also done partial conversion for powerpc and MIPS - these at least compile
    with minimal configurations.
    
    This will affect all archs.  Mostly the changes should be relatively easy.
    Take do_IRQ(), store the regs pointer at the beginning, saving the old one:
    
            struct pt_regs *old_regs = set_irq_regs(regs);
    
    And put the old one back at the end:
    
            set_irq_regs(old_regs);
    
    Don't pass regs through to generic_handle_irq() or __do_IRQ().
    
    In timer_interrupt(), this sort of change will be necessary:
    
            -       update_process_times(user_mode(regs));
            -       profile_tick(CPU_PROFILING, regs);
            +       update_process_times(user_mode(get_irq_regs()));
            +       profile_tick(CPU_PROFILING);
    
    I'd like to move update_process_times()'s use of get_irq_regs() into itself,
    except that i386, alone of the archs, uses something other than user_mode().
    
    Some notes on the interrupt handling in the drivers:
    
     (*) input_dev() is now gone entirely.  The regs pointer is no longer stored in
         the input_dev struct.
    
     (*) finish_unlinks() in drivers/usb/host/ohci-q.c needs checking.  It does
         something different depending on whether it's been supplied with a regs
         pointer or not.
    
     (*) Various IRQ handler function pointers have been moved to type
         irq_handler_t.
    
    Signed-Off-By: David Howells <dhowells@redhat.com>
    (cherry picked from 1b16e7ac850969f38b375e511e3fa2f474a33867 commit)

diff --git a/drivers/scsi/aha1740.c b/drivers/scsi/aha1740.c
index 6b35ed8301e0..c3c38a7e8d32 100644
--- a/drivers/scsi/aha1740.c
+++ b/drivers/scsi/aha1740.c
@@ -223,8 +223,7 @@ static int aha1740_test_port(unsigned int base)
 }
 
 /* A "high" level interrupt handler */
-static irqreturn_t aha1740_intr_handle(int irq, void *dev_id,
-				       struct pt_regs *regs)
+static irqreturn_t aha1740_intr_handle(int irq, void *dev_id)
 {
 	struct Scsi_Host *host = (struct Scsi_Host *) dev_id;
         void (*my_done)(Scsi_Cmnd *);

commit 07563c711fbc25389e58ab9c9f0b9de2fce56760
Author: Michael Tokarev <mjt@tls.mks.ru>
Date:   Wed Sep 27 01:50:56 2006 -0700

    [PATCH] EISA bus MODALIAS attributes support
    
    Add modalias attribute support for the almost forgotten now EISA bus and
    (at least some) EISA-aware modules.
    
    The modalias entry looks like (for an 3c509 NIC):
    
     eisa:sTCM5093
    
    and the in-module alias like:
    
     eisa:sTCM5093*
    
    The patch moves struct eisa_device_id declaration from include/linux/eisa.h
    to include/linux/mod_devicetable.h (so that the former now #includes the
    latter), adds proper MODULE_DEVICE_TABLE(eisa, ...) statements for all
    drivers with EISA IDs I found (some drivers already have that DEVICE_TABLE
    declared), and adds recognision of __mod_eisa_device_table to
    scripts/mod/file2alias.c so that proper modules.alias will be generated.
    
    There's no support for /lib/modules/$kver/modules.eisamap, as it's not used
    by any existing tools, and because with in-kernel modalias mechanism those
    maps are obsolete anyway.
    
    The rationale for this patch is:
    
     a) to make EISA bus to act as other busses with modalias
        support, to unify driver loading
    
     b) to foget about EISA finally - with this patch, kernel
        (who still supports EISA) will be the only one who knows
        how to choose the necessary drivers for this bus ;)
    
    [akpm@osdl.org: fix the kbuild bit]
    Signed-off-by: Michael Tokarev <mjt@tls.msk.ru>
    Cc: Rusty Russell <rusty@rustcorp.com.au>
    Cc: Randy Dunlap <rdunlap@xenotime.net>
    Acked-the-net-bits-by: Jeff Garzik <jeff@garzik.org>
    Acked-the-tulip-bit-by: Valerie Henson <val_henson@linux.intel.com>
    Cc: James Bottomley <James.Bottomley@steeleye.com>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/drivers/scsi/aha1740.c b/drivers/scsi/aha1740.c
index 0e4a7ebe300a..6b35ed8301e0 100644
--- a/drivers/scsi/aha1740.c
+++ b/drivers/scsi/aha1740.c
@@ -681,6 +681,7 @@ static struct eisa_device_id aha1740_ids[] = {
 	{ "ADP0400" },		/* 1744  */
 	{ "" }
 };
+MODULE_DEVICE_TABLE(eisa, aha1740_ids);
 
 static struct eisa_driver aha1740_driver = {
 	.id_table = aha1740_ids,

commit 1d6f359a2e06296418481239f8054a878f36e819
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Sat Jul 1 19:29:42 2006 -0700

    [PATCH] irq-flags: scsi: Use the new IRQF_ constants
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: Ingo Molnar <mingo@elte.hu>
    Cc: "David S. Miller" <davem@davemloft.net>
    Cc: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Cc: James Bottomley <James.Bottomley@steeleye.com>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/drivers/scsi/aha1740.c b/drivers/scsi/aha1740.c
index 4b8c6a543925..0e4a7ebe300a 100644
--- a/drivers/scsi/aha1740.c
+++ b/drivers/scsi/aha1740.c
@@ -634,7 +634,7 @@ static int aha1740_probe (struct device *dev)
 	}
 	
 	DEB(printk("aha1740_probe: enable interrupt channel %d\n",irq_level));
-	if (request_irq(irq_level,aha1740_intr_handle,irq_type ? 0 : SA_SHIRQ,
+	if (request_irq(irq_level,aha1740_intr_handle,irq_type ? 0 : IRQF_SHARED,
 			"aha1740",shpnt)) {
 		printk(KERN_ERR "aha1740_probe: Unable to allocate IRQ %d.\n",
 		       irq_level);

commit d0be4a7d29ad0bd3ce2209dd9e46d410b632db59
Author: Christoph Hellwig <hch@lst.de>
Date:   Mon Oct 31 18:31:40 2005 +0100

    [SCSI] remove Scsi_Host_Template typedef
    
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>

diff --git a/drivers/scsi/aha1740.c b/drivers/scsi/aha1740.c
index 8f85dcc0e7fa..4b8c6a543925 100644
--- a/drivers/scsi/aha1740.c
+++ b/drivers/scsi/aha1740.c
@@ -570,7 +570,7 @@ static int aha1740_eh_abort_handler (Scsi_Cmnd *dummy)
 	return 0;
 }
 
-static Scsi_Host_Template aha1740_template = {
+static struct scsi_host_template aha1740_template = {
 	.module           = THIS_MODULE,
 	.proc_name        = "aha1740",
 	.proc_info        = aha1740_proc_info,

commit 422c0d61d591cbfb70f029e13505fb437e169d68
Author: Jeff Garzik <jgarzik@pobox.com>
Date:   Mon Oct 24 18:05:09 2005 -0400

    [SCSI] use scmd_id(), scmd_channel() throughout code
    
    Wrap a highly common idiom.  Makes the code easier to read, helps pave
    the way for sdev->{id,channel} removal, and adds a token that can easily
    by grepped-for in the future.
    
    There are a couple sdev_id() and scmd_printk() updates thrown in as well.
    
    Rejections fixed up and
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>

diff --git a/drivers/scsi/aha1740.c b/drivers/scsi/aha1740.c
index 73f33e716a0c..8f85dcc0e7fa 100644
--- a/drivers/scsi/aha1740.c
+++ b/drivers/scsi/aha1740.c
@@ -347,7 +347,7 @@ static int aha1740_queuecommand(Scsi_Cmnd * SCpnt, void (*done)(Scsi_Cmnd *))
 {
 	unchar direction;
 	unchar *cmd = (unchar *) SCpnt->cmnd;
-	unchar target = SCpnt->device->id;
+	unchar target = scmd_id(SCpnt);
 	struct aha1740_hostdata *host = HOSTDATA(SCpnt->device->host);
 	unsigned long flags;
 	void *buff = SCpnt->request_buffer;

commit 1da177e4c3f41524e886b7f1b8a0c1fc7321cac2
Author: Linus Torvalds <torvalds@ppc970.osdl.org>
Date:   Sat Apr 16 15:20:36 2005 -0700

    Linux-2.6.12-rc2
    
    Initial git repository build. I'm not bothering with the full history,
    even though we have it. We can create a separate "historical" git
    archive of that later if we want to, and in the meantime it's about
    3.2GB when imported into git - space that would just make the early
    git days unnecessarily complicated, when we don't have a lot of good
    infrastructure for it.
    
    Let it rip!

diff --git a/drivers/scsi/aha1740.c b/drivers/scsi/aha1740.c
new file mode 100644
index 000000000000..73f33e716a0c
--- /dev/null
+++ b/drivers/scsi/aha1740.c
@@ -0,0 +1,707 @@
+/*  $Id$
+ *  1993/03/31
+ *  linux/kernel/aha1740.c
+ *
+ *  Based loosely on aha1542.c which is
+ *  Copyright (C) 1992  Tommy Thorn and
+ *  Modified by Eric Youngdale
+ *
+ *  This file is aha1740.c, written and
+ *  Copyright (C) 1992,1993  Brad McLean
+ *  brad@saturn.gaylord.com or brad@bradpc.gaylord.com.
+ *  
+ *  Modifications to makecode and queuecommand
+ *  for proper handling of multiple devices courteously
+ *  provided by Michael Weller, March, 1993
+ *
+ *  Multiple adapter support, extended translation detection,
+ *  update to current scsi subsystem changes, proc fs support,
+ *  working (!) module support based on patches from Andreas Arens,
+ *  by Andreas Degert <ad@papyrus.hamburg.com>, 2/1997
+ *
+ * aha1740_makecode may still need even more work
+ * if it doesn't work for your devices, take a look.
+ *
+ * Reworked for new_eh and new locking by Alan Cox <alan@redhat.com>
+ *
+ * Converted to EISA and generic DMA APIs by Marc Zyngier
+ * <maz@wild-wind.fr.eu.org>, 4/2003.
+ *
+ * Shared interrupt support added by Rask Ingemann Lambertsen
+ * <rask@sygehus.dk>, 10/2003
+ *
+ * For the avoidance of doubt the "preferred form" of this code is one which
+ * is in an open non patent encumbered format. Where cryptographic key signing
+ * forms part of the process of creating an executable the information
+ * including keys needed to generate an equivalently functional executable
+ * are deemed to be part of the source code.
+ */
+
+#include <linux/blkdev.h>
+#include <linux/interrupt.h>
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/types.h>
+#include <linux/string.h>
+#include <linux/ioport.h>
+#include <linux/proc_fs.h>
+#include <linux/stat.h>
+#include <linux/init.h>
+#include <linux/device.h>
+#include <linux/eisa.h>
+#include <linux/dma-mapping.h>
+
+#include <asm/dma.h>
+#include <asm/system.h>
+#include <asm/io.h>
+
+#include "scsi.h"
+#include <scsi/scsi_host.h>
+#include "aha1740.h"
+
+/* IF YOU ARE HAVING PROBLEMS WITH THIS DRIVER, AND WANT TO WATCH
+   IT WORK, THEN:
+#define DEBUG
+*/
+#ifdef DEBUG
+#define DEB(x) x
+#else
+#define DEB(x)
+#endif
+
+struct aha1740_hostdata {
+	struct eisa_device *edev;
+	unsigned int translation;
+	unsigned int last_ecb_used;
+	dma_addr_t ecb_dma_addr;
+	struct ecb ecb[AHA1740_ECBS];
+};
+
+struct aha1740_sg {
+	struct aha1740_chain sg_chain[AHA1740_SCATTER];
+	dma_addr_t sg_dma_addr;
+	dma_addr_t buf_dma_addr;
+};
+
+#define HOSTDATA(host) ((struct aha1740_hostdata *) &host->hostdata)
+
+static inline struct ecb *ecb_dma_to_cpu (struct Scsi_Host *host,
+					  dma_addr_t dma)
+{
+	struct aha1740_hostdata *hdata = HOSTDATA (host);
+	dma_addr_t offset;
+
+	offset = dma - hdata->ecb_dma_addr;
+
+	return (struct ecb *)(((char *) hdata->ecb) + (unsigned int) offset);
+}
+
+static inline dma_addr_t ecb_cpu_to_dma (struct Scsi_Host *host, void *cpu)
+{
+	struct aha1740_hostdata *hdata = HOSTDATA (host);
+	dma_addr_t offset;
+    
+	offset = (char *) cpu - (char *) hdata->ecb;
+
+	return hdata->ecb_dma_addr + offset;
+}
+
+static int aha1740_proc_info(struct Scsi_Host *shpnt, char *buffer,
+			     char **start, off_t offset,
+			     int length, int inout)
+{
+	int len;
+	struct aha1740_hostdata *host;
+
+	if (inout)
+		return-ENOSYS;
+
+	host = HOSTDATA(shpnt);
+
+	len = sprintf(buffer, "aha174x at IO:%lx, IRQ %d, SLOT %d.\n"
+		      "Extended translation %sabled.\n",
+		      shpnt->io_port, shpnt->irq, host->edev->slot,
+		      host->translation ? "en" : "dis");
+
+	if (offset > len) {
+		*start = buffer;
+		return 0;
+	}
+
+	*start = buffer + offset;
+	len -= offset;
+	if (len > length)
+		len = length;
+	return len;
+}
+
+static int aha1740_makecode(unchar *sense, unchar *status)
+{
+	struct statusword
+	{
+		ushort	don:1,	/* Command Done - No Error */
+			du:1,	/* Data underrun */
+		    :1,	qf:1,	/* Queue full */
+		        sc:1,	/* Specification Check */
+		        dor:1,	/* Data overrun */
+		        ch:1,	/* Chaining Halted */
+		        intr:1,	/* Interrupt issued */
+		        asa:1,	/* Additional Status Available */
+		        sns:1,	/* Sense information Stored */
+		    :1,	ini:1,	/* Initialization Required */
+			me:1,	/* Major error or exception */
+		    :1,	eca:1,  /* Extended Contingent alliance */
+		    :1;
+	} status_word;
+	int retval = DID_OK;
+
+	status_word = * (struct statusword *) status;
+#ifdef DEBUG
+	printk("makecode from %x,%x,%x,%x %x,%x,%x,%x",
+	       status[0], status[1], status[2], status[3],
+	       sense[0], sense[1], sense[2], sense[3]);
+#endif
+	if (!status_word.don) { /* Anything abnormal was detected */
+		if ( (status[1]&0x18) || status_word.sc ) {
+			/*Additional info available*/
+			/* Use the supplied info for further diagnostics */
+			switch ( status[2] ) {
+			case 0x12:
+				if ( status_word.dor )
+					retval=DID_ERROR; /* It's an Overrun */
+				/* If not overrun, assume underrun and
+				 * ignore it! */
+			case 0x00: /* No info, assume no error, should
+				    * not occur */
+				break;
+			case 0x11:
+			case 0x21:
+				retval=DID_TIME_OUT;
+				break;
+			case 0x0a:
+				retval=DID_BAD_TARGET;
+				break;
+			case 0x04:
+			case 0x05:
+				retval=DID_ABORT;
+				/* Either by this driver or the
+				 * AHA1740 itself */
+				break;
+			default:
+				retval=DID_ERROR; /* No further
+						   * diagnostics
+						   * possible */
+			}
+		} else {
+			/* Michael suggests, and Brad concurs: */
+			if ( status_word.qf ) {
+				retval = DID_TIME_OUT; /* forces a redo */
+				/* I think this specific one should
+				 * not happen -Brad */
+				printk("aha1740.c: WARNING: AHA1740 queue overflow!\n");
+			} else
+				if ( status[0]&0x60 ) {
+					 /* Didn't find a better error */
+					retval = DID_ERROR;
+				}
+			/* In any other case return DID_OK so for example
+			   CONDITION_CHECKS make it through to the appropriate
+			   device driver */
+		}
+	}
+	/* Under all circumstances supply the target status -Michael */
+	return status[3] | retval << 16;
+}
+
+static int aha1740_test_port(unsigned int base)
+{
+	if ( inb(PORTADR(base)) & PORTADDR_ENH )
+		return 1;   /* Okay, we're all set */
+	
+	printk("aha174x: Board detected, but not in enhanced mode, so disabled it.\n");
+	return 0;
+}
+
+/* A "high" level interrupt handler */
+static irqreturn_t aha1740_intr_handle(int irq, void *dev_id,
+				       struct pt_regs *regs)
+{
+	struct Scsi_Host *host = (struct Scsi_Host *) dev_id;
+        void (*my_done)(Scsi_Cmnd *);
+	int errstatus, adapstat;
+	int number_serviced;
+	struct ecb *ecbptr;
+	Scsi_Cmnd *SCtmp;
+	unsigned int base;
+	unsigned long flags;
+	int handled = 0;
+	struct aha1740_sg *sgptr;
+	struct eisa_device *edev;
+	
+	if (!host)
+		panic("aha1740.c: Irq from unknown host!\n");
+	spin_lock_irqsave(host->host_lock, flags);
+	base = host->io_port;
+	number_serviced = 0;
+	edev = HOSTDATA(host)->edev;
+
+	while(inb(G2STAT(base)) & G2STAT_INTPEND) {
+		handled = 1;
+		DEB(printk("aha1740_intr top of loop.\n"));
+		adapstat = inb(G2INTST(base));
+		ecbptr = ecb_dma_to_cpu (host, inl(MBOXIN0(base)));
+		outb(G2CNTRL_IRST,G2CNTRL(base)); /* interrupt reset */
+      
+		switch ( adapstat & G2INTST_MASK ) {
+		case	G2INTST_CCBRETRY:
+		case	G2INTST_CCBERROR:
+		case	G2INTST_CCBGOOD:
+			/* Host Ready -> Mailbox in complete */
+			outb(G2CNTRL_HRDY,G2CNTRL(base));
+			if (!ecbptr) {
+				printk("Aha1740 null ecbptr in interrupt (%x,%x,%x,%d)\n",
+				       inb(G2STAT(base)),adapstat,
+				       inb(G2INTST(base)), number_serviced++);
+				continue;
+			}
+			SCtmp = ecbptr->SCpnt;
+			if (!SCtmp) {
+				printk("Aha1740 null SCtmp in interrupt (%x,%x,%x,%d)\n",
+				       inb(G2STAT(base)),adapstat,
+				       inb(G2INTST(base)), number_serviced++);
+				continue;
+			}
+			sgptr = (struct aha1740_sg *) SCtmp->host_scribble;
+			if (SCtmp->use_sg) {
+				/* We used scatter-gather.
+				   Do the unmapping dance. */
+				dma_unmap_sg (&edev->dev,
+					      (struct scatterlist *) SCtmp->request_buffer,
+					      SCtmp->use_sg,
+					      SCtmp->sc_data_direction);
+			} else {
+				dma_unmap_single (&edev->dev,
+						  sgptr->buf_dma_addr,
+						  SCtmp->request_bufflen,
+						  DMA_BIDIRECTIONAL);
+			}
+	    
+			/* Free the sg block */
+			dma_free_coherent (&edev->dev,
+					   sizeof (struct aha1740_sg),
+					   SCtmp->host_scribble,
+					   sgptr->sg_dma_addr);
+	    
+			/* Fetch the sense data, and tuck it away, in
+			   the required slot.  The Adaptec
+			   automatically fetches it, and there is no
+			   guarantee that we will still have it in the
+			   cdb when we come back */
+			if ( (adapstat & G2INTST_MASK) == G2INTST_CCBERROR ) {
+				memcpy(SCtmp->sense_buffer, ecbptr->sense, 
+				       sizeof(SCtmp->sense_buffer));
+				errstatus = aha1740_makecode(ecbptr->sense,ecbptr->status);
+			} else
+				errstatus = 0;
+			DEB(if (errstatus)
+			    printk("aha1740_intr_handle: returning %6x\n",
+				   errstatus));
+			SCtmp->result = errstatus;
+			my_done = ecbptr->done;
+			memset(ecbptr,0,sizeof(struct ecb)); 
+			if ( my_done )
+				my_done(SCtmp);
+			break;
+			
+		case	G2INTST_HARDFAIL:
+			printk(KERN_ALERT "aha1740 hardware failure!\n");
+			panic("aha1740.c");	/* Goodbye */
+			
+		case	G2INTST_ASNEVENT:
+			printk("aha1740 asynchronous event: %02x %02x %02x %02x %02x\n",
+			       adapstat,
+			       inb(MBOXIN0(base)),
+			       inb(MBOXIN1(base)),
+			       inb(MBOXIN2(base)),
+			       inb(MBOXIN3(base))); /* Say What? */
+			/* Host Ready -> Mailbox in complete */
+			outb(G2CNTRL_HRDY,G2CNTRL(base));
+			break;
+			
+		case	G2INTST_CMDGOOD:
+			/* set immediate command success flag here: */
+			break;
+			
+		case	G2INTST_CMDERROR:
+			/* Set immediate command failure flag here: */
+			break;
+		}
+		number_serviced++;
+	}
+
+	spin_unlock_irqrestore(host->host_lock, flags);
+	return IRQ_RETVAL(handled);
+}
+
+static int aha1740_queuecommand(Scsi_Cmnd * SCpnt, void (*done)(Scsi_Cmnd *))
+{
+	unchar direction;
+	unchar *cmd = (unchar *) SCpnt->cmnd;
+	unchar target = SCpnt->device->id;
+	struct aha1740_hostdata *host = HOSTDATA(SCpnt->device->host);
+	unsigned long flags;
+	void *buff = SCpnt->request_buffer;
+	int bufflen = SCpnt->request_bufflen;
+	dma_addr_t sg_dma;
+	struct aha1740_sg *sgptr;
+	int ecbno;
+	DEB(int i);
+
+	if(*cmd == REQUEST_SENSE) {
+		SCpnt->result = 0;
+		done(SCpnt); 
+		return 0;
+	}
+
+#ifdef DEBUG
+	if (*cmd == READ_10 || *cmd == WRITE_10)
+		i = xscsi2int(cmd+2);
+	else if (*cmd == READ_6 || *cmd == WRITE_6)
+		i = scsi2int(cmd+2);
+	else
+		i = -1;
+	printk("aha1740_queuecommand: dev %d cmd %02x pos %d len %d ",
+	       target, *cmd, i, bufflen);
+	printk("scsi cmd:");
+	for (i = 0; i < SCpnt->cmd_len; i++) printk("%02x ", cmd[i]);
+	printk("\n");
+#endif
+
+	/* locate an available ecb */
+	spin_lock_irqsave(SCpnt->device->host->host_lock, flags);
+	ecbno = host->last_ecb_used + 1; /* An optimization */
+	if (ecbno >= AHA1740_ECBS)
+		ecbno = 0;
+	do {
+		if (!host->ecb[ecbno].cmdw)
+			break;
+		ecbno++;
+		if (ecbno >= AHA1740_ECBS)
+			ecbno = 0;
+	} while (ecbno != host->last_ecb_used);
+
+	if (host->ecb[ecbno].cmdw)
+		panic("Unable to find empty ecb for aha1740.\n");
+
+	host->ecb[ecbno].cmdw = AHA1740CMD_INIT; /* SCSI Initiator Command
+						    doubles as reserved flag */
+
+	host->last_ecb_used = ecbno;    
+	spin_unlock_irqrestore(SCpnt->device->host->host_lock, flags);
+
+#ifdef DEBUG
+	printk("Sending command (%d %x)...", ecbno, done);
+#endif
+
+	host->ecb[ecbno].cdblen = SCpnt->cmd_len; /* SCSI Command
+						   * Descriptor Block
+						   * Length */
+
+	direction = 0;
+	if (*cmd == READ_10 || *cmd == READ_6)
+		direction = 1;
+	else if (*cmd == WRITE_10 || *cmd == WRITE_6)
+		direction = 0;
+
+	memcpy(host->ecb[ecbno].cdb, cmd, SCpnt->cmd_len);
+
+	SCpnt->host_scribble = dma_alloc_coherent (&host->edev->dev,
+						   sizeof (struct aha1740_sg),
+						   &sg_dma, GFP_ATOMIC);
+	if(SCpnt->host_scribble == NULL) {
+		printk(KERN_WARNING "aha1740: out of memory in queuecommand!\n");
+		return 1;
+	}
+	sgptr = (struct aha1740_sg *) SCpnt->host_scribble;
+	sgptr->sg_dma_addr = sg_dma;
+    
+	if (SCpnt->use_sg) {
+		struct scatterlist * sgpnt;
+		struct aha1740_chain * cptr;
+		int i, count;
+		DEB(unsigned char * ptr);
+
+		host->ecb[ecbno].sg = 1;  /* SCSI Initiator Command
+					   * w/scatter-gather*/
+		sgpnt = (struct scatterlist *) SCpnt->request_buffer;
+		cptr = sgptr->sg_chain;
+		count = dma_map_sg (&host->edev->dev, sgpnt, SCpnt->use_sg,
+				    SCpnt->sc_data_direction);
+		for(i=0; i < count; i++) {
+			cptr[i].datalen = sg_dma_len (sgpnt + i);
+			cptr[i].dataptr = sg_dma_address (sgpnt + i);
+		}
+		host->ecb[ecbno].datalen = count*sizeof(struct aha1740_chain);
+		host->ecb[ecbno].dataptr = sg_dma;
+#ifdef DEBUG
+		printk("cptr %x: ",cptr);
+		ptr = (unsigned char *) cptr;
+		for(i=0;i<24;i++) printk("%02x ", ptr[i]);
+#endif
+	} else {
+		host->ecb[ecbno].datalen = bufflen;
+		sgptr->buf_dma_addr =  dma_map_single (&host->edev->dev,
+						       buff, bufflen,
+						       DMA_BIDIRECTIONAL);
+		host->ecb[ecbno].dataptr = sgptr->buf_dma_addr;
+	}
+	host->ecb[ecbno].lun = SCpnt->device->lun;
+	host->ecb[ecbno].ses = 1; /* Suppress underrun errors */
+	host->ecb[ecbno].dir = direction;
+	host->ecb[ecbno].ars = 1; /* Yes, get the sense on an error */
+	host->ecb[ecbno].senselen = 12;
+	host->ecb[ecbno].senseptr = ecb_cpu_to_dma (SCpnt->device->host,
+						    host->ecb[ecbno].sense);
+	host->ecb[ecbno].statusptr = ecb_cpu_to_dma (SCpnt->device->host,
+						     host->ecb[ecbno].status);
+	host->ecb[ecbno].done = done;
+	host->ecb[ecbno].SCpnt = SCpnt;
+#ifdef DEBUG
+	{
+		int i;
+		printk("aha1740_command: sending.. ");
+		for (i = 0; i < sizeof(host->ecb[ecbno]) - 10; i++)
+			printk("%02x ", ((unchar *)&host->ecb[ecbno])[i]);
+	}
+	printk("\n");
+#endif
+	if (done) {
+	/* The Adaptec Spec says the card is so fast that the loops
+           will only be executed once in the code below. Even if this
+           was true with the fastest processors when the spec was
+           written, it doesn't seem to be true with todays fast
+           processors. We print a warning if the code is executed more
+           often than LOOPCNT_WARN. If this happens, it should be
+           investigated. If the count reaches LOOPCNT_MAX, we assume
+           something is broken; since there is no way to return an
+           error (the return value is ignored by the mid-level scsi
+           layer) we have to panic (and maybe that's the best thing we
+           can do then anyhow). */
+
+#define LOOPCNT_WARN 10		/* excessive mbxout wait -> syslog-msg */
+#define LOOPCNT_MAX 1000000	/* mbxout deadlock -> panic() after ~ 2 sec. */
+		int loopcnt;
+		unsigned int base = SCpnt->device->host->io_port;
+		DEB(printk("aha1740[%d] critical section\n",ecbno));
+
+		spin_lock_irqsave(SCpnt->device->host->host_lock, flags);
+		for (loopcnt = 0; ; loopcnt++) {
+			if (inb(G2STAT(base)) & G2STAT_MBXOUT) break;
+			if (loopcnt == LOOPCNT_WARN) {
+				printk("aha1740[%d]_mbxout wait!\n",ecbno);
+			}
+			if (loopcnt == LOOPCNT_MAX)
+				panic("aha1740.c: mbxout busy!\n");
+		}
+		outl (ecb_cpu_to_dma (SCpnt->device->host, host->ecb + ecbno),
+		      MBOXOUT0(base));
+		for (loopcnt = 0; ; loopcnt++) {
+			if (! (inb(G2STAT(base)) & G2STAT_BUSY)) break;
+			if (loopcnt == LOOPCNT_WARN) {
+				printk("aha1740[%d]_attn wait!\n",ecbno);
+			}
+			if (loopcnt == LOOPCNT_MAX)
+				panic("aha1740.c: attn wait failed!\n");
+		}
+		outb(ATTN_START | (target & 7), ATTN(base)); /* Start it up */
+		spin_unlock_irqrestore(SCpnt->device->host->host_lock, flags);
+		DEB(printk("aha1740[%d] request queued.\n",ecbno));
+	} else
+		printk(KERN_ALERT "aha1740_queuecommand: done can't be NULL\n");
+	return 0;
+}
+
+/* Query the board for its irq_level and irq_type.  Nothing else matters
+   in enhanced mode on an EISA bus. */
+
+static void aha1740_getconfig(unsigned int base, unsigned int *irq_level,
+			      unsigned int *irq_type,
+			      unsigned int *translation)
+{
+	static int intab[] = { 9, 10, 11, 12, 0, 14, 15, 0 };
+
+	*irq_level = intab[inb(INTDEF(base)) & 0x7];
+	*irq_type  = (inb(INTDEF(base)) & 0x8) >> 3;
+	*translation = inb(RESV1(base)) & 0x1;
+	outb(inb(INTDEF(base)) | 0x10, INTDEF(base));
+}
+
+static int aha1740_biosparam(struct scsi_device *sdev,
+			     struct block_device *dev,
+			     sector_t capacity, int* ip)
+{
+	int size = capacity;
+	int extended = HOSTDATA(sdev->host)->translation;
+
+	DEB(printk("aha1740_biosparam\n"));
+	if (extended && (ip[2] > 1024))	{
+		ip[0] = 255;
+		ip[1] = 63;
+		ip[2] = size / (255 * 63);
+	} else {
+		ip[0] = 64;
+		ip[1] = 32;
+		ip[2] = size >> 11;
+	}
+	return 0;
+}
+
+static int aha1740_eh_abort_handler (Scsi_Cmnd *dummy)
+{
+/*
+ * From Alan Cox :
+ * The AHA1740 has firmware handled abort/reset handling. The "head in
+ * sand" kernel code is correct for once 8)
+ *
+ * So we define a dummy handler just to keep the kernel SCSI code as
+ * quiet as possible...
+ */
+
+	return 0;
+}
+
+static Scsi_Host_Template aha1740_template = {
+	.module           = THIS_MODULE,
+	.proc_name        = "aha1740",
+	.proc_info        = aha1740_proc_info,
+	.name             = "Adaptec 174x (EISA)",
+	.queuecommand     = aha1740_queuecommand,
+	.bios_param       = aha1740_biosparam,
+	.can_queue        = AHA1740_ECBS,
+	.this_id          = 7,
+	.sg_tablesize     = AHA1740_SCATTER,
+	.cmd_per_lun      = AHA1740_CMDLUN,
+	.use_clustering   = ENABLE_CLUSTERING,
+	.eh_abort_handler = aha1740_eh_abort_handler,
+};
+
+static int aha1740_probe (struct device *dev)
+{
+	int slotbase;
+	unsigned int irq_level, irq_type, translation;
+	struct Scsi_Host *shpnt;
+	struct aha1740_hostdata *host;
+	struct eisa_device *edev = to_eisa_device (dev);
+
+	DEB(printk("aha1740_probe: \n"));
+	
+	slotbase = edev->base_addr + EISA_VENDOR_ID_OFFSET;
+	if (!request_region(slotbase, SLOTSIZE, "aha1740")) /* See if in use */
+		return -EBUSY;
+	if (!aha1740_test_port(slotbase))
+		goto err_release_region;
+	aha1740_getconfig(slotbase,&irq_level,&irq_type,&translation);
+	if ((inb(G2STAT(slotbase)) &
+	     (G2STAT_MBXOUT|G2STAT_BUSY)) != G2STAT_MBXOUT) {
+		/* If the card isn't ready, hard reset it */
+		outb(G2CNTRL_HRST, G2CNTRL(slotbase));
+		outb(0, G2CNTRL(slotbase));
+	}
+	printk(KERN_INFO "Configuring slot %d at IO:%x, IRQ %u (%s)\n",
+	       edev->slot, slotbase, irq_level, irq_type ? "edge" : "level");
+	printk(KERN_INFO "aha174x: Extended translation %sabled.\n",
+	       translation ? "en" : "dis");
+	shpnt = scsi_host_alloc(&aha1740_template,
+			      sizeof(struct aha1740_hostdata));
+	if(shpnt == NULL)
+		goto err_release_region;
+
+	shpnt->base = 0;
+	shpnt->io_port = slotbase;
+	shpnt->n_io_port = SLOTSIZE;
+	shpnt->irq = irq_level;
+	shpnt->dma_channel = 0xff;
+	host = HOSTDATA(shpnt);
+	host->edev = edev;
+	host->translation = translation;
+	host->ecb_dma_addr = dma_map_single (&edev->dev, host->ecb,
+					     sizeof (host->ecb),
+					     DMA_BIDIRECTIONAL);
+	if (!host->ecb_dma_addr) {
+		printk (KERN_ERR "aha1740_probe: Couldn't map ECB, giving up\n");
+		scsi_unregister (shpnt);
+		goto err_host_put;
+	}
+	
+	DEB(printk("aha1740_probe: enable interrupt channel %d\n",irq_level));
+	if (request_irq(irq_level,aha1740_intr_handle,irq_type ? 0 : SA_SHIRQ,
+			"aha1740",shpnt)) {
+		printk(KERN_ERR "aha1740_probe: Unable to allocate IRQ %d.\n",
+		       irq_level);
+		goto err_unmap;
+	}
+
+	eisa_set_drvdata (edev, shpnt);
+	scsi_add_host (shpnt, dev); /* XXX handle failure */
+	scsi_scan_host (shpnt);
+	return 0;
+
+ err_unmap:
+	dma_unmap_single (&edev->dev, host->ecb_dma_addr,
+			  sizeof (host->ecb), DMA_BIDIRECTIONAL);
+ err_host_put:
+	scsi_host_put (shpnt);
+ err_release_region:
+	release_region(slotbase, SLOTSIZE);
+
+	return -ENODEV;
+}
+
+static __devexit int aha1740_remove (struct device *dev)
+{
+	struct Scsi_Host *shpnt = dev->driver_data;
+	struct aha1740_hostdata *host = HOSTDATA (shpnt);
+
+	scsi_remove_host(shpnt);
+	
+	free_irq (shpnt->irq, shpnt);
+	dma_unmap_single (dev, host->ecb_dma_addr,
+			  sizeof (host->ecb), DMA_BIDIRECTIONAL);
+	release_region (shpnt->io_port, SLOTSIZE);
+
+	scsi_host_put (shpnt);
+	
+	return 0;
+}
+
+static struct eisa_device_id aha1740_ids[] = {
+	{ "ADP0000" },		/* 1740  */
+	{ "ADP0001" },		/* 1740A */
+	{ "ADP0002" },		/* 1742A */
+	{ "ADP0400" },		/* 1744  */
+	{ "" }
+};
+
+static struct eisa_driver aha1740_driver = {
+	.id_table = aha1740_ids,
+	.driver   = {
+		.name    = "aha1740",
+		.probe   = aha1740_probe,
+		.remove  = __devexit_p (aha1740_remove),
+	},
+};
+
+static __init int aha1740_init (void)
+{
+	return eisa_driver_register (&aha1740_driver);
+}
+
+static __exit void aha1740_exit (void)
+{
+	eisa_driver_unregister (&aha1740_driver);
+}
+
+module_init (aha1740_init);
+module_exit (aha1740_exit);
+
+MODULE_LICENSE("GPL");
