commit 4bdc0d676a643140bdf17dbf7eafedee3d496a3c
Author: Christoph Hellwig <hch@lst.de>
Date:   Mon Jan 6 09:43:50 2020 +0100

    remove ioremap_nocache and devm_ioremap_nocache
    
    ioremap has provided non-cached semantics by default since the Linux 2.6
    days, so remove the additional ioremap_nocache interface.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Acked-by: Arnd Bergmann <arnd@arndb.de>

diff --git a/drivers/scsi/sun3x_esp.c b/drivers/scsi/sun3x_esp.c
index 440a73eae647..f37df79e37e1 100644
--- a/drivers/scsi/sun3x_esp.c
+++ b/drivers/scsi/sun3x_esp.c
@@ -190,7 +190,7 @@ static int esp_sun3x_probe(struct platform_device *dev)
 	if (!res || !res->start)
 		goto fail_unlink;
 
-	esp->regs = ioremap_nocache(res->start, 0x20);
+	esp->regs = ioremap(res->start, 0x20);
 	if (!esp->regs)
 		goto fail_unmap_regs;
 
@@ -198,7 +198,7 @@ static int esp_sun3x_probe(struct platform_device *dev)
 	if (!res || !res->start)
 		goto fail_unmap_regs;
 
-	esp->dma_regs = ioremap_nocache(res->start, 0x10);
+	esp->dma_regs = ioremap(res->start, 0x10);
 
 	esp->command_block = dma_alloc_coherent(esp->dev, 16,
 						&esp->command_block_dma,

commit 09c434b8a0047c69e48499de0107de312901e798
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Sun May 19 13:08:20 2019 +0100

    treewide: Add SPDX license identifier for more missed files
    
    Add SPDX license identifiers to all files which:
    
     - Have no license information of any form
    
     - Have MODULE_LICENCE("GPL*") inside which was used in the initial
       scan/conversion to ignore the file
    
    These files fall under the project license, GPL v2 only. The resulting SPDX
    license identifier is:
    
      GPL-2.0-only
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/scsi/sun3x_esp.c b/drivers/scsi/sun3x_esp.c
index c9a55d0f076d..440a73eae647 100644
--- a/drivers/scsi/sun3x_esp.c
+++ b/drivers/scsi/sun3x_esp.c
@@ -1,3 +1,4 @@
+// SPDX-License-Identifier: GPL-2.0-only
 /* sun3x_esp.c: ESP front-end for Sun3x systems.
  *
  * Copyright (C) 2007,2008 Thomas Bogendoerfer (tsbogend@alpha.franken.de)

commit 3f9295b65ea44194252d60376036a3618d822152
Author: Christoph Hellwig <hch@lst.de>
Date:   Sat Oct 13 09:26:27 2018 +0200

    scsi: esp_scsi: move dma mapping into the core code
    
    Except for the mac_esp driver, which uses PIO or pseudo DMA, all drivers
    share the same dma mapping calls.  Move the dma mapping into the core
    code using the scsi_dma_map / scsi_dma_unmap helpers, with a special
    identify mapping variant triggered off a new ESP_FLAG_NO_DMA_MAP flag
    for mac_esp.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Tested-by: Finn Thain <fthain@telegraphics.com.au>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/sun3x_esp.c b/drivers/scsi/sun3x_esp.c
index e80c0a15fd8a..c9a55d0f076d 100644
--- a/drivers/scsi/sun3x_esp.c
+++ b/drivers/scsi/sun3x_esp.c
@@ -60,30 +60,6 @@ static u8 sun3x_esp_read8(struct esp *esp, unsigned long reg)
 	return readb(esp->regs + (reg * 4UL));
 }
 
-static dma_addr_t sun3x_esp_map_single(struct esp *esp, void *buf,
-				      size_t sz, int dir)
-{
-	return dma_map_single(esp->dev, buf, sz, dir);
-}
-
-static int sun3x_esp_map_sg(struct esp *esp, struct scatterlist *sg,
-				  int num_sg, int dir)
-{
-	return dma_map_sg(esp->dev, sg, num_sg, dir);
-}
-
-static void sun3x_esp_unmap_single(struct esp *esp, dma_addr_t addr,
-				  size_t sz, int dir)
-{
-	dma_unmap_single(esp->dev, addr, sz, dir);
-}
-
-static void sun3x_esp_unmap_sg(struct esp *esp, struct scatterlist *sg,
-			      int num_sg, int dir)
-{
-	dma_unmap_sg(esp->dev, sg, num_sg, dir);
-}
-
 static int sun3x_esp_irq_pending(struct esp *esp)
 {
 	if (dma_read32(DMA_CSR) & (DMA_HNDL_INTR | DMA_HNDL_ERROR))
@@ -182,10 +158,6 @@ static int sun3x_esp_dma_error(struct esp *esp)
 static const struct esp_driver_ops sun3x_esp_ops = {
 	.esp_write8	=	sun3x_esp_write8,
 	.esp_read8	=	sun3x_esp_read8,
-	.map_single	=	sun3x_esp_map_single,
-	.map_sg		=	sun3x_esp_map_sg,
-	.unmap_single	=	sun3x_esp_unmap_single,
-	.unmap_sg	=	sun3x_esp_unmap_sg,
 	.irq_pending	=	sun3x_esp_irq_pending,
 	.reset_dma	=	sun3x_esp_reset_dma,
 	.dma_drain	=	sun3x_esp_dma_drain,

commit 44b1b4d24b2d65134efeccb3cc2341c61227f0f9
Author: Christoph Hellwig <hch@lst.de>
Date:   Sat Oct 13 09:26:26 2018 +0200

    scsi: esp_scsi: remove the dev argument to scsi_esp_register
    
    We can simplify use esp->dev now.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Tested-by: Finn Thain <fthain@telegraphics.com.au>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/sun3x_esp.c b/drivers/scsi/sun3x_esp.c
index 0b1421cdf8a0..e80c0a15fd8a 100644
--- a/drivers/scsi/sun3x_esp.c
+++ b/drivers/scsi/sun3x_esp.c
@@ -246,7 +246,7 @@ static int esp_sun3x_probe(struct platform_device *dev)
 
 	dev_set_drvdata(&dev->dev, esp);
 
-	err = scsi_esp_register(esp, &dev->dev);
+	err = scsi_esp_register(esp);
 	if (err)
 		goto fail_free_irq;
 

commit e32ec6579f5b3134cb27cc063c17da0bb8cd29c7
Author: Finn Thain <fthain@telegraphics.com.au>
Date:   Wed Mar 7 17:56:41 2018 +1100

    scsi: jazz_esp, sun3x_esp: Pass struct device pointer in dma calls
    
    In jazz_esp and sun3x_esp, the esp_driver_ops methods pass esp->dev in
    dma api calls as if it was a pointer to a struct device. But it actually
    points to a struct platform_device. Fix this.
    
    Cc: Thomas Bogendoerfer <tsbogend@alpha.franken.de>
    Signed-off-by: Finn Thain <fthain@telegraphics.com.au>
    Reviewed-by: Thomas Bogendoerfer <tsbogend@alpha.franken.de>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/sun3x_esp.c b/drivers/scsi/sun3x_esp.c
index d50c5ed8f428..0b1421cdf8a0 100644
--- a/drivers/scsi/sun3x_esp.c
+++ b/drivers/scsi/sun3x_esp.c
@@ -210,7 +210,7 @@ static int esp_sun3x_probe(struct platform_device *dev)
 	esp = shost_priv(host);
 
 	esp->host = host;
-	esp->dev = dev;
+	esp->dev = &dev->dev;
 	esp->ops = &sun3x_esp_ops;
 
 	res = platform_get_resource(dev, IORESOURCE_MEM, 0);

commit 2584cf83578c26db144730ef498f4070f82ee3ea
Author: Dan Williams <dan.j.williams@intel.com>
Date:   Mon Aug 10 23:07:05 2015 -0400

    arch, drivers: don't include <asm/io.h> directly, use <linux/io.h> instead
    
    Preparation for uniform definition of ioremap, ioremap_wc, ioremap_wt,
    and ioremap_cache, tree-wide.
    
    Acked-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/drivers/scsi/sun3x_esp.c b/drivers/scsi/sun3x_esp.c
index e26e81de7c45..d50c5ed8f428 100644
--- a/drivers/scsi/sun3x_esp.c
+++ b/drivers/scsi/sun3x_esp.c
@@ -12,9 +12,9 @@
 #include <linux/platform_device.h>
 #include <linux/dma-mapping.h>
 #include <linux/interrupt.h>
+#include <linux/io.h>
 
 #include <asm/sun3x.h>
-#include <asm/io.h>
 #include <asm/dma.h>
 #include <asm/dvma.h>
 

commit b36069c833d9440774d5daab143ec15ea026f34a
Author: Wolfram Sang <wsa@the-dreams.de>
Date:   Mon Oct 20 16:21:33 2014 +0200

    scsi: drop owner assignment from platform_drivers
    
    A platform_driver does not need to set an owner, it will be populated by the
    driver core.
    
    Signed-off-by: Wolfram Sang <wsa@the-dreams.de>

diff --git a/drivers/scsi/sun3x_esp.c b/drivers/scsi/sun3x_esp.c
index 534eb96fc3a7..e26e81de7c45 100644
--- a/drivers/scsi/sun3x_esp.c
+++ b/drivers/scsi/sun3x_esp.c
@@ -295,7 +295,6 @@ static struct platform_driver esp_sun3x_driver = {
 	.remove         = esp_sun3x_remove,
 	.driver = {
 		.name   = "sun3x_esp",
-		.owner	= THIS_MODULE,
 	},
 };
 

commit 6f039790510fd630ff348efe8c4802dbaa041fba
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Fri Dec 21 13:08:55 2012 -0800

    Drivers: scsi: remove __dev* attributes.
    
    CONFIG_HOTPLUG is going away as an option.  As a result, the __dev*
    markings need to be removed.
    
    This change removes the use of __devinit, __devexit_p, __devinitdata,
    __devinitconst, and __devexit from these drivers.
    
    Based on patches originally written by Bill Pemberton, but redone by me
    in order to handle some of the coding style issues better, by hand.
    
    Cc: Bill Pemberton <wfp5p@virginia.edu>
    Cc: Adam Radford <linuxraid@lsi.com>
    Cc: "James E.J. Bottomley" <JBottomley@parallels.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/scsi/sun3x_esp.c b/drivers/scsi/sun3x_esp.c
index 0621037f0271..534eb96fc3a7 100644
--- a/drivers/scsi/sun3x_esp.c
+++ b/drivers/scsi/sun3x_esp.c
@@ -194,7 +194,7 @@ static const struct esp_driver_ops sun3x_esp_ops = {
 	.dma_error	=	sun3x_esp_dma_error,
 };
 
-static int __devinit esp_sun3x_probe(struct platform_device *dev)
+static int esp_sun3x_probe(struct platform_device *dev)
 {
 	struct scsi_host_template *tpnt = &scsi_esp_template;
 	struct Scsi_Host *host;
@@ -268,7 +268,7 @@ static int __devinit esp_sun3x_probe(struct platform_device *dev)
 	return err;
 }
 
-static int __devexit esp_sun3x_remove(struct platform_device *dev)
+static int esp_sun3x_remove(struct platform_device *dev)
 {
 	struct esp *esp = dev_get_drvdata(&dev->dev);
 	unsigned int irq = esp->host->irq;
@@ -292,7 +292,7 @@ static int __devexit esp_sun3x_remove(struct platform_device *dev)
 
 static struct platform_driver esp_sun3x_driver = {
 	.probe          = esp_sun3x_probe,
-	.remove         = __devexit_p(esp_sun3x_remove),
+	.remove         = esp_sun3x_remove,
 	.driver = {
 		.name   = "sun3x_esp",
 		.owner	= THIS_MODULE,

commit 5a0e3ad6af8660be21ca98a971cd00f331318c05
Author: Tejun Heo <tj@kernel.org>
Date:   Wed Mar 24 17:04:11 2010 +0900

    include cleanup: Update gfp.h and slab.h includes to prepare for breaking implicit slab.h inclusion from percpu.h
    
    percpu.h is included by sched.h and module.h and thus ends up being
    included when building most .c files.  percpu.h includes slab.h which
    in turn includes gfp.h making everything defined by the two files
    universally available and complicating inclusion dependencies.
    
    percpu.h -> slab.h dependency is about to be removed.  Prepare for
    this change by updating users of gfp and slab facilities include those
    headers directly instead of assuming availability.  As this conversion
    needs to touch large number of source files, the following script is
    used as the basis of conversion.
    
      http://userweb.kernel.org/~tj/misc/slabh-sweep.py
    
    The script does the followings.
    
    * Scan files for gfp and slab usages and update includes such that
      only the necessary includes are there.  ie. if only gfp is used,
      gfp.h, if slab is used, slab.h.
    
    * When the script inserts a new include, it looks at the include
      blocks and try to put the new include such that its order conforms
      to its surrounding.  It's put in the include block which contains
      core kernel includes, in the same order that the rest are ordered -
      alphabetical, Christmas tree, rev-Xmas-tree or at the end if there
      doesn't seem to be any matching order.
    
    * If the script can't find a place to put a new include (mostly
      because the file doesn't have fitting include block), it prints out
      an error message indicating which .h file needs to be added to the
      file.
    
    The conversion was done in the following steps.
    
    1. The initial automatic conversion of all .c files updated slightly
       over 4000 files, deleting around 700 includes and adding ~480 gfp.h
       and ~3000 slab.h inclusions.  The script emitted errors for ~400
       files.
    
    2. Each error was manually checked.  Some didn't need the inclusion,
       some needed manual addition while adding it to implementation .h or
       embedding .c file was more appropriate for others.  This step added
       inclusions to around 150 files.
    
    3. The script was run again and the output was compared to the edits
       from #2 to make sure no file was left behind.
    
    4. Several build tests were done and a couple of problems were fixed.
       e.g. lib/decompress_*.c used malloc/free() wrappers around slab
       APIs requiring slab.h to be added manually.
    
    5. The script was run on all .h files but without automatically
       editing them as sprinkling gfp.h and slab.h inclusions around .h
       files could easily lead to inclusion dependency hell.  Most gfp.h
       inclusion directives were ignored as stuff from gfp.h was usually
       wildly available and often used in preprocessor macros.  Each
       slab.h inclusion directive was examined and added manually as
       necessary.
    
    6. percpu.h was updated not to include slab.h.
    
    7. Build test were done on the following configurations and failures
       were fixed.  CONFIG_GCOV_KERNEL was turned off for all tests (as my
       distributed build env didn't work with gcov compiles) and a few
       more options had to be turned off depending on archs to make things
       build (like ipr on powerpc/64 which failed due to missing writeq).
    
       * x86 and x86_64 UP and SMP allmodconfig and a custom test config.
       * powerpc and powerpc64 SMP allmodconfig
       * sparc and sparc64 SMP allmodconfig
       * ia64 SMP allmodconfig
       * s390 SMP allmodconfig
       * alpha SMP allmodconfig
       * um on x86_64 SMP allmodconfig
    
    8. percpu.h modifications were reverted so that it could be applied as
       a separate patch and serve as bisection point.
    
    Given the fact that I had only a couple of failures from tests on step
    6, I'm fairly confident about the coverage of this conversion patch.
    If there is a breakage, it's likely to be something in one of the arch
    headers which should be easily discoverable easily on most builds of
    the specific arch.
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Guess-its-ok-by: Christoph Lameter <cl@linux-foundation.org>
    Cc: Ingo Molnar <mingo@redhat.com>
    Cc: Lee Schermerhorn <Lee.Schermerhorn@hp.com>

diff --git a/drivers/scsi/sun3x_esp.c b/drivers/scsi/sun3x_esp.c
index 34a99620e5bd..0621037f0271 100644
--- a/drivers/scsi/sun3x_esp.c
+++ b/drivers/scsi/sun3x_esp.c
@@ -4,6 +4,7 @@
  */
 
 #include <linux/kernel.h>
+#include <linux/gfp.h>
 #include <linux/types.h>
 #include <linux/delay.h>
 #include <linux/module.h>

commit 3fe68cc152fc7cc6a763c692544a0ab71926c800
Author: Julia Lawall <julia@diku.dk>
Date:   Tue Oct 14 18:00:19 2008 +0200

    [SCSI] sun3x_esp: Convert && to ||
    
    The pattern !E && !E->fld is nonsensical.  The patch below updates this
    according to the assumption that && should be ||.  But perhaps another
    solution was intended.
    
    The semantic patch that makes this change is as follows:
    (http://www.emn.fr/x-info/coccinelle/)
    
    // <smpl>
    @disable and_comm@
    expression E;
    identifier fld;
    @@
    
    - !E && !E->fld
    + !E || !E->fld
    // </smpl>
    
    Signed-off-by: Julia Lawall <julia@diku.dk>
    Acked-By: Thomas Bogendoerfer <tsbogend@alpha.franken.de>
    Signed-off-by: James Bottomley <James.Bottomley@HansenPartnership.com>

diff --git a/drivers/scsi/sun3x_esp.c b/drivers/scsi/sun3x_esp.c
index 7514b3a0390e..34a99620e5bd 100644
--- a/drivers/scsi/sun3x_esp.c
+++ b/drivers/scsi/sun3x_esp.c
@@ -213,7 +213,7 @@ static int __devinit esp_sun3x_probe(struct platform_device *dev)
 	esp->ops = &sun3x_esp_ops;
 
 	res = platform_get_resource(dev, IORESOURCE_MEM, 0);
-	if (!res && !res->start)
+	if (!res || !res->start)
 		goto fail_unlink;
 
 	esp->regs = ioremap_nocache(res->start, 0x20);
@@ -221,7 +221,7 @@ static int __devinit esp_sun3x_probe(struct platform_device *dev)
 		goto fail_unmap_regs;
 
 	res = platform_get_resource(dev, IORESOURCE_MEM, 1);
-	if (!res && !res->start)
+	if (!res || !res->start)
 		goto fail_unmap_regs;
 
 	esp->dma_regs = ioremap_nocache(res->start, 0x10);

commit ecc1241e80a0bdc854b1602a44be3ad106753d4f
Author: Kay Sievers <kay.sievers@vrfy.org>
Date:   Fri Apr 18 13:57:19 2008 -0700

    [SCSI] jazz_esp, sgiwd93, sni_53c710, sun3x_esp: fix platform driver hotplug/coldplug
    
    Since
    
    commit 43cc71eed1250755986da4c0f9898f9a635cb3bf
    Author: Kay Sievers <kay.sievers@vrfy.org>
    Date:   Sat Aug 18 04:40:39 2007 +0200
    
        platform: prefix MODALIAS with "platform:"
    
    the platform modalias is prefixed with "platform:". Add MODULE_ALIAS()
    to the hotpluggable SCSI platform drivers, to re-enable auto loading.
    
    [dbrownell@users.sourceforge.net: more drivers, registration fixes]
    [akpm@linux-foundation.org: fix sgiwd93.c]
    Signed-off-by: Kay Sievers <kay.sievers@vrfy.org>
    Signed-off-by: David Brownell <dbrownell@users.sourceforge.net>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: James Bottomley <James.Bottomley@HansenPartnership.com>

diff --git a/drivers/scsi/sun3x_esp.c b/drivers/scsi/sun3x_esp.c
index 06152c7fa689..7514b3a0390e 100644
--- a/drivers/scsi/sun3x_esp.c
+++ b/drivers/scsi/sun3x_esp.c
@@ -294,6 +294,7 @@ static struct platform_driver esp_sun3x_driver = {
 	.remove         = __devexit_p(esp_sun3x_remove),
 	.driver = {
 		.name   = "sun3x_esp",
+		.owner	= THIS_MODULE,
 	},
 };
 
@@ -314,3 +315,4 @@ MODULE_VERSION(DRV_VERSION);
 
 module_init(sun3x_esp_init);
 module_exit(sun3x_esp_exit);
+MODULE_ALIAS("platform:sun3x_esp");

commit 0bb67f181834044db6e9b15c7d5cc3cce0489bfd
Author: Thomas Bogendoerfer <tsbogend@alpha.franken.de>
Date:   Fri Feb 1 00:13:34 2008 +0100

    [SCSI] sun3x_esp: convert to esp_scsi
    
    Converted sun3x_esp driver to use esp_scsi.c
    
    Signed-off-by: Thomas Bogendoerfer <tsbogend@alpha.franken.de>
    Signed-off-by: James Bottomley <James.Bottomley@HansenPartnership.com>

diff --git a/drivers/scsi/sun3x_esp.c b/drivers/scsi/sun3x_esp.c
index 1bc41907a038..06152c7fa689 100644
--- a/drivers/scsi/sun3x_esp.c
+++ b/drivers/scsi/sun3x_esp.c
@@ -1,392 +1,316 @@
-/* sun3x_esp.c:  EnhancedScsiProcessor Sun3x SCSI driver code.
+/* sun3x_esp.c: ESP front-end for Sun3x systems.
  *
- * (C) 1999 Thomas Bogendoerfer (tsbogend@alpha.franken.de)
- *
- * Based on David S. Miller's esp driver
+ * Copyright (C) 2007,2008 Thomas Bogendoerfer (tsbogend@alpha.franken.de)
  */
 
 #include <linux/kernel.h>
 #include <linux/types.h>
-#include <linux/string.h>
-#include <linux/slab.h>
-#include <linux/blkdev.h>
-#include <linux/proc_fs.h>
-#include <linux/stat.h>
 #include <linux/delay.h>
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/platform_device.h>
+#include <linux/dma-mapping.h>
 #include <linux/interrupt.h>
 
-#include "scsi.h"
-#include <scsi/scsi_host.h>
-#include "NCR53C9x.h"
-
 #include <asm/sun3x.h>
+#include <asm/io.h>
+#include <asm/dma.h>
 #include <asm/dvma.h>
-#include <asm/irq.h>
-
-static void dma_barrier(struct NCR_ESP *esp);
-static int  dma_bytes_sent(struct NCR_ESP *esp, int fifo_count);
-static int  dma_can_transfer(struct NCR_ESP *esp, Scsi_Cmnd *sp);
-static void dma_drain(struct NCR_ESP *esp);
-static void dma_invalidate(struct NCR_ESP *esp);
-static void dma_dump_state(struct NCR_ESP *esp);
-static void dma_init_read(struct NCR_ESP *esp, __u32 vaddress, int length);
-static void dma_init_write(struct NCR_ESP *esp, __u32 vaddress, int length);
-static void dma_ints_off(struct NCR_ESP *esp);
-static void dma_ints_on(struct NCR_ESP *esp);
-static int  dma_irq_p(struct NCR_ESP *esp);
-static void dma_poll(struct NCR_ESP *esp, unsigned char *vaddr);
-static int  dma_ports_p(struct NCR_ESP *esp);
-static void dma_reset(struct NCR_ESP *esp);
-static void dma_setup(struct NCR_ESP *esp, __u32 addr, int count, int write);
-static void dma_mmu_get_scsi_one (struct NCR_ESP *esp, Scsi_Cmnd *sp);
-static void dma_mmu_get_scsi_sgl (struct NCR_ESP *esp, Scsi_Cmnd *sp);
-static void dma_mmu_release_scsi_one (struct NCR_ESP *esp, Scsi_Cmnd *sp);
-static void dma_mmu_release_scsi_sgl (struct NCR_ESP *esp, Scsi_Cmnd *sp);
-static void dma_advance_sg (Scsi_Cmnd *sp);
-
-/* Detecting ESP chips on the machine.  This is the simple and easy
- * version.
- */
-int sun3x_esp_detect(struct scsi_host_template *tpnt)
-{
-	struct NCR_ESP *esp;
-	struct ConfigDev *esp_dev;
-
-	esp_dev = 0;
-	esp = esp_allocate(tpnt, esp_dev, 0);
-
-	/* Do command transfer with DMA */
-	esp->do_pio_cmds = 0;
-
-	/* Required functions */
-	esp->dma_bytes_sent = &dma_bytes_sent;
-	esp->dma_can_transfer = &dma_can_transfer;
-	esp->dma_dump_state = &dma_dump_state;
-	esp->dma_init_read = &dma_init_read;
-	esp->dma_init_write = &dma_init_write;
-	esp->dma_ints_off = &dma_ints_off;
-	esp->dma_ints_on = &dma_ints_on;
-	esp->dma_irq_p = &dma_irq_p;
-	esp->dma_ports_p = &dma_ports_p;
-	esp->dma_setup = &dma_setup;
-
-	/* Optional functions */
-	esp->dma_barrier = &dma_barrier;
-	esp->dma_invalidate = &dma_invalidate;
-	esp->dma_drain = &dma_drain;
-	esp->dma_irq_entry = 0;
-	esp->dma_irq_exit = 0;
-	esp->dma_led_on = 0;
-	esp->dma_led_off = 0;
-	esp->dma_poll = &dma_poll;
-	esp->dma_reset = &dma_reset;
-
-        /* virtual DMA functions */
-        esp->dma_mmu_get_scsi_one = &dma_mmu_get_scsi_one;
-        esp->dma_mmu_get_scsi_sgl = &dma_mmu_get_scsi_sgl;
-        esp->dma_mmu_release_scsi_one = &dma_mmu_release_scsi_one;
-        esp->dma_mmu_release_scsi_sgl = &dma_mmu_release_scsi_sgl;
-        esp->dma_advance_sg = &dma_advance_sg;
-	    
-	/* SCSI chip speed */
-	esp->cfreq = 20000000;
-	esp->eregs = (struct ESP_regs *)(SUN3X_ESP_BASE);
-	esp->dregs = (void *)SUN3X_ESP_DMA;
 
-	esp->esp_command = (volatile unsigned char *)dvma_malloc(DVMA_PAGE_SIZE);
-	esp->esp_command_dvma = dvma_vtob((unsigned long)esp->esp_command);
-
-	esp->irq = 2;
-	if (request_irq(esp->irq, esp_intr, IRQF_DISABLED,
-			"SUN3X SCSI", esp->ehost)) {
-		esp_deallocate(esp);
-		return 0;
-	}
+/* DMA controller reg offsets */
+#define DMA_CSR		0x00UL	/* rw  DMA control/status register    0x00   */
+#define DMA_ADDR        0x04UL	/* rw  DMA transfer address register  0x04   */
+#define DMA_COUNT       0x08UL	/* rw  DMA transfer count register    0x08   */
+#define DMA_TEST        0x0cUL	/* rw  DMA test/debug register        0x0c   */
 
-	esp->scsi_id = 7;
-	esp->diff = 0;
+#include <scsi/scsi_host.h>
 
-	esp_initialize(esp);
+#include "esp_scsi.h"
 
- 	/* for reasons beyond my knowledge (and which should likely be fixed)
- 	   sync mode doesn't work on a 3/80 at 5mhz.  but it does at 4. */
- 	esp->sync_defp = 0x3f;
+#define DRV_MODULE_NAME		"sun3x_esp"
+#define PFX DRV_MODULE_NAME	": "
+#define DRV_VERSION		"1.000"
+#define DRV_MODULE_RELDATE	"Nov 1, 2007"
 
-	printk("ESP: Total of %d ESP hosts found, %d actually in use.\n", nesps,
-	       esps_in_use);
-	esps_running = esps_in_use;
-	return esps_in_use;
+/*
+ * m68k always assumes readl/writel operate on little endian
+ * mmio space; this is wrong at least for Sun3x, so we
+ * need to workaround this until a proper way is found
+ */
+#if 0
+#define dma_read32(REG) \
+	readl(esp->dma_regs + (REG))
+#define dma_write32(VAL, REG) \
+	writel((VAL), esp->dma_regs + (REG))
+#else
+#define dma_read32(REG) \
+	*(volatile u32 *)(esp->dma_regs + (REG))
+#define dma_write32(VAL, REG) \
+	do { *(volatile u32 *)(esp->dma_regs + (REG)) = (VAL); } while (0)
+#endif
+
+static void sun3x_esp_write8(struct esp *esp, u8 val, unsigned long reg)
+{
+	writeb(val, esp->regs + (reg * 4UL));
 }
 
-static void dma_do_drain(struct NCR_ESP *esp)
+static u8 sun3x_esp_read8(struct esp *esp, unsigned long reg)
 {
- 	struct sparc_dma_registers *dregs =
- 		(struct sparc_dma_registers *) esp->dregs;
- 	
- 	int count = 500000;
- 
- 	while((dregs->cond_reg & DMA_PEND_READ) && (--count > 0)) 
- 		udelay(1);
- 
- 	if(!count) {
- 		printk("%s:%d timeout CSR %08lx\n", __FILE__, __LINE__, dregs->cond_reg);
- 	}
- 
- 	dregs->cond_reg |= DMA_FIFO_STDRAIN;
- 	
- 	count = 500000;
- 
- 	while((dregs->cond_reg & DMA_FIFO_ISDRAIN) && (--count > 0)) 
- 		udelay(1);
- 
- 	if(!count) {
- 		printk("%s:%d timeout CSR %08lx\n", __FILE__, __LINE__, dregs->cond_reg);
- 	}
- 
+	return readb(esp->regs + (reg * 4UL));
 }
- 
-static void dma_barrier(struct NCR_ESP *esp)
+
+static dma_addr_t sun3x_esp_map_single(struct esp *esp, void *buf,
+				      size_t sz, int dir)
 {
-  	struct sparc_dma_registers *dregs =
-  		(struct sparc_dma_registers *) esp->dregs;
- 	int count = 500000;
-  
- 	while((dregs->cond_reg & DMA_PEND_READ) && (--count > 0))
-  		udelay(1);
- 
- 	if(!count) {
- 		printk("%s:%d timeout CSR %08lx\n", __FILE__, __LINE__, dregs->cond_reg);
- 	}
- 
-  	dregs->cond_reg &= ~(DMA_ENABLE);
+	return dma_map_single(esp->dev, buf, sz, dir);
 }
 
-/* This uses various DMA csr fields and the fifo flags count value to
- * determine how many bytes were successfully sent/received by the ESP.
- */
-static int dma_bytes_sent(struct NCR_ESP *esp, int fifo_count)
+static int sun3x_esp_map_sg(struct esp *esp, struct scatterlist *sg,
+				  int num_sg, int dir)
 {
-	struct sparc_dma_registers *dregs = 
-		(struct sparc_dma_registers *) esp->dregs;
-
-	int rval = dregs->st_addr - esp->esp_command_dvma;
-
-	return rval - fifo_count;
+	return dma_map_sg(esp->dev, sg, num_sg, dir);
 }
 
-static int dma_can_transfer(struct NCR_ESP *esp, Scsi_Cmnd *sp)
+static void sun3x_esp_unmap_single(struct esp *esp, dma_addr_t addr,
+				  size_t sz, int dir)
 {
-	return sp->SCp.this_residual;
+	dma_unmap_single(esp->dev, addr, sz, dir);
 }
 
-static void dma_drain(struct NCR_ESP *esp)
+static void sun3x_esp_unmap_sg(struct esp *esp, struct scatterlist *sg,
+			      int num_sg, int dir)
 {
-	struct sparc_dma_registers *dregs =
-		(struct sparc_dma_registers *) esp->dregs;
-	int count = 500000;
-
-	if(dregs->cond_reg & DMA_FIFO_ISDRAIN) {
-		dregs->cond_reg |= DMA_FIFO_STDRAIN;
-		while((dregs->cond_reg & DMA_FIFO_ISDRAIN) && (--count > 0))
-			udelay(1);
-		if(!count) {
-			printk("%s:%d timeout CSR %08lx\n", __FILE__, __LINE__, dregs->cond_reg);
-		}
-
-	}
+	dma_unmap_sg(esp->dev, sg, num_sg, dir);
 }
 
-static void dma_invalidate(struct NCR_ESP *esp)
+static int sun3x_esp_irq_pending(struct esp *esp)
 {
-	struct sparc_dma_registers *dregs =
-		(struct sparc_dma_registers *) esp->dregs;
-
-	__u32 tmp;
-	int count = 500000;
-
-	while(((tmp = dregs->cond_reg) & DMA_PEND_READ) && (--count > 0)) 
-		udelay(1);
+	if (dma_read32(DMA_CSR) & (DMA_HNDL_INTR | DMA_HNDL_ERROR))
+		return 1;
+	return 0;
+}
 
-	if(!count) {
-		printk("%s:%d timeout CSR %08lx\n", __FILE__, __LINE__, dregs->cond_reg);
-	}
+static void sun3x_esp_reset_dma(struct esp *esp)
+{
+	u32 val;
 
-	dregs->cond_reg = tmp | DMA_FIFO_INV;
-	dregs->cond_reg &= ~DMA_FIFO_INV;
+	val = dma_read32(DMA_CSR);
+	dma_write32(val | DMA_RST_SCSI, DMA_CSR);
+	dma_write32(val & ~DMA_RST_SCSI, DMA_CSR);
 
+	/* Enable interrupts.  */
+	val = dma_read32(DMA_CSR);
+	dma_write32(val | DMA_INT_ENAB, DMA_CSR);
 }
 
-static void dma_dump_state(struct NCR_ESP *esp)
+static void sun3x_esp_dma_drain(struct esp *esp)
 {
-	struct sparc_dma_registers *dregs =
-		(struct sparc_dma_registers *) esp->dregs;
+	u32 csr;
+	int lim;
 
-	ESPLOG(("esp%d: dma -- cond_reg<%08lx> addr<%08lx>\n",
-		esp->esp_id, dregs->cond_reg, dregs->st_addr));
-}
+	csr = dma_read32(DMA_CSR);
+	if (!(csr & DMA_FIFO_ISDRAIN))
+		return;
 
-static void dma_init_read(struct NCR_ESP *esp, __u32 vaddress, int length)
-{
-	struct sparc_dma_registers *dregs = 
-		(struct sparc_dma_registers *) esp->dregs;
+	dma_write32(csr | DMA_FIFO_STDRAIN, DMA_CSR);
 
-	dregs->st_addr = vaddress;
-	dregs->cond_reg |= (DMA_ST_WRITE | DMA_ENABLE);
+	lim = 1000;
+	while (dma_read32(DMA_CSR) & DMA_FIFO_ISDRAIN) {
+		if (--lim == 0) {
+			printk(KERN_ALERT PFX "esp%d: DMA will not drain!\n",
+			       esp->host->unique_id);
+			break;
+		}
+		udelay(1);
+	}
 }
 
-static void dma_init_write(struct NCR_ESP *esp, __u32 vaddress, int length)
+static void sun3x_esp_dma_invalidate(struct esp *esp)
 {
-	struct sparc_dma_registers *dregs = 
-		(struct sparc_dma_registers *) esp->dregs;
-
-	/* Set up the DMA counters */
+	u32 val;
+	int lim;
+
+	lim = 1000;
+	while ((val = dma_read32(DMA_CSR)) & DMA_PEND_READ) {
+		if (--lim == 0) {
+			printk(KERN_ALERT PFX "esp%d: DMA will not "
+			       "invalidate!\n", esp->host->unique_id);
+			break;
+		}
+		udelay(1);
+	}
 
-	dregs->st_addr = vaddress;
-	dregs->cond_reg = ((dregs->cond_reg & ~(DMA_ST_WRITE)) | DMA_ENABLE);
+	val &= ~(DMA_ENABLE | DMA_ST_WRITE | DMA_BCNT_ENAB);
+	val |= DMA_FIFO_INV;
+	dma_write32(val, DMA_CSR);
+	val &= ~DMA_FIFO_INV;
+	dma_write32(val, DMA_CSR);
 }
 
-static void dma_ints_off(struct NCR_ESP *esp)
+static void sun3x_esp_send_dma_cmd(struct esp *esp, u32 addr, u32 esp_count,
+				  u32 dma_count, int write, u8 cmd)
 {
-	DMA_INTSOFF((struct sparc_dma_registers *) esp->dregs);
+	u32 csr;
+
+	BUG_ON(!(cmd & ESP_CMD_DMA));
+
+	sun3x_esp_write8(esp, (esp_count >> 0) & 0xff, ESP_TCLOW);
+	sun3x_esp_write8(esp, (esp_count >> 8) & 0xff, ESP_TCMED);
+	csr = dma_read32(DMA_CSR);
+	csr |= DMA_ENABLE;
+	if (write)
+		csr |= DMA_ST_WRITE;
+	else
+		csr &= ~DMA_ST_WRITE;
+	dma_write32(csr, DMA_CSR);
+	dma_write32(addr, DMA_ADDR);
+
+	scsi_esp_cmd(esp, cmd);
 }
 
-static void dma_ints_on(struct NCR_ESP *esp)
+static int sun3x_esp_dma_error(struct esp *esp)
 {
-	DMA_INTSON((struct sparc_dma_registers *) esp->dregs);
-}
+	u32 csr = dma_read32(DMA_CSR);
 
-static int dma_irq_p(struct NCR_ESP *esp)
-{
-	return DMA_IRQ_P((struct sparc_dma_registers *) esp->dregs);
+	if (csr & DMA_HNDL_ERROR)
+		return 1;
+
+	return 0;
 }
 
-static void dma_poll(struct NCR_ESP *esp, unsigned char *vaddr)
+static const struct esp_driver_ops sun3x_esp_ops = {
+	.esp_write8	=	sun3x_esp_write8,
+	.esp_read8	=	sun3x_esp_read8,
+	.map_single	=	sun3x_esp_map_single,
+	.map_sg		=	sun3x_esp_map_sg,
+	.unmap_single	=	sun3x_esp_unmap_single,
+	.unmap_sg	=	sun3x_esp_unmap_sg,
+	.irq_pending	=	sun3x_esp_irq_pending,
+	.reset_dma	=	sun3x_esp_reset_dma,
+	.dma_drain	=	sun3x_esp_dma_drain,
+	.dma_invalidate	=	sun3x_esp_dma_invalidate,
+	.send_dma_cmd	=	sun3x_esp_send_dma_cmd,
+	.dma_error	=	sun3x_esp_dma_error,
+};
+
+static int __devinit esp_sun3x_probe(struct platform_device *dev)
 {
-	int count = 50;
-	dma_do_drain(esp);
+	struct scsi_host_template *tpnt = &scsi_esp_template;
+	struct Scsi_Host *host;
+	struct esp *esp;
+	struct resource *res;
+	int err = -ENOMEM;
 
-	/* Wait till the first bits settle. */
-	while((*(volatile unsigned char *)vaddr == 0xff) && (--count > 0))
-		udelay(1);
+	host = scsi_host_alloc(tpnt, sizeof(struct esp));
+	if (!host)
+		goto fail;
 
-	if(!count) {
-//		printk("%s:%d timeout expire (data %02x)\n", __FILE__, __LINE__,
-//		       esp_read(esp->eregs->esp_fdata));
-		//mach_halt();
-		vaddr[0] = esp_read(esp->eregs->esp_fdata);
-		vaddr[1] = esp_read(esp->eregs->esp_fdata);
-	}
+	host->max_id = 8;
+	esp = shost_priv(host);
 
-}	
+	esp->host = host;
+	esp->dev = dev;
+	esp->ops = &sun3x_esp_ops;
 
-static int dma_ports_p(struct NCR_ESP *esp)
-{
-	return (((struct sparc_dma_registers *) esp->dregs)->cond_reg 
-			& DMA_INT_ENAB);
-}
+	res = platform_get_resource(dev, IORESOURCE_MEM, 0);
+	if (!res && !res->start)
+		goto fail_unlink;
 
-/* Resetting various pieces of the ESP scsi driver chipset/buses. */
-static void dma_reset(struct NCR_ESP *esp)
-{
-	struct sparc_dma_registers *dregs =
-		(struct sparc_dma_registers *)esp->dregs;
+	esp->regs = ioremap_nocache(res->start, 0x20);
+	if (!esp->regs)
+		goto fail_unmap_regs;
 
-	/* Punt the DVMA into a known state. */
-	dregs->cond_reg |= DMA_RST_SCSI;
-	dregs->cond_reg &= ~(DMA_RST_SCSI);
-	DMA_INTSON(dregs);
-}
+	res = platform_get_resource(dev, IORESOURCE_MEM, 1);
+	if (!res && !res->start)
+		goto fail_unmap_regs;
 
-static void dma_setup(struct NCR_ESP *esp, __u32 addr, int count, int write)
-{
-	struct sparc_dma_registers *dregs = 
-		(struct sparc_dma_registers *) esp->dregs;
-	unsigned long nreg = dregs->cond_reg;
+	esp->dma_regs = ioremap_nocache(res->start, 0x10);
 
-//	printk("dma_setup %c addr %08x cnt %08x\n",
-//	       write ? 'W' : 'R', addr, count);
+	esp->command_block = dma_alloc_coherent(esp->dev, 16,
+						&esp->command_block_dma,
+						GFP_KERNEL);
+	if (!esp->command_block)
+		goto fail_unmap_regs_dma;
 
-	dma_do_drain(esp);
+	host->irq = platform_get_irq(dev, 0);
+	err = request_irq(host->irq, scsi_esp_intr, IRQF_SHARED,
+			  "SUN3X ESP", esp);
+	if (err < 0)
+		goto fail_unmap_command_block;
 
-	if(write)
-		nreg |= DMA_ST_WRITE;
-	else {
-		nreg &= ~(DMA_ST_WRITE);
-	}
-		
-	nreg |= DMA_ENABLE;
-	dregs->cond_reg = nreg;
-	dregs->st_addr = addr;
-}
+	esp->scsi_id = 7;
+	esp->host->this_id = esp->scsi_id;
+	esp->scsi_id_mask = (1 << esp->scsi_id);
+	esp->cfreq = 20000000;
 
-static void dma_mmu_get_scsi_one (struct NCR_ESP *esp, Scsi_Cmnd *sp)
-{
-    sp->SCp.have_data_in = dvma_map((unsigned long)sp->SCp.buffer,
-				       sp->SCp.this_residual);
-    sp->SCp.ptr = (char *)((unsigned long)sp->SCp.have_data_in);
+	dev_set_drvdata(&dev->dev, esp);
+
+	err = scsi_esp_register(esp, &dev->dev);
+	if (err)
+		goto fail_free_irq;
+
+	return 0;
+
+fail_free_irq:
+	free_irq(host->irq, esp);
+fail_unmap_command_block:
+	dma_free_coherent(esp->dev, 16,
+			  esp->command_block,
+			  esp->command_block_dma);
+fail_unmap_regs_dma:
+	iounmap(esp->dma_regs);
+fail_unmap_regs:
+	iounmap(esp->regs);
+fail_unlink:
+	scsi_host_put(host);
+fail:
+	return err;
 }
 
-static void dma_mmu_get_scsi_sgl (struct NCR_ESP *esp, Scsi_Cmnd *sp)
+static int __devexit esp_sun3x_remove(struct platform_device *dev)
 {
-    int sz = sp->SCp.buffers_residual;
-    struct scatterlist *sg = sp->SCp.buffer;
-
-    while (sz >= 0) {
-	    sg[sz].dma_address = dvma_map((unsigned long)sg_virt(&sg[sz]),
-					  sg[sz].length);
-	    sz--;
-    }
-    sp->SCp.ptr=(char *)((unsigned long)sp->SCp.buffer->dma_address);
-}
+	struct esp *esp = dev_get_drvdata(&dev->dev);
+	unsigned int irq = esp->host->irq;
+	u32 val;
 
-static void dma_mmu_release_scsi_one (struct NCR_ESP *esp, Scsi_Cmnd *sp)
-{
-    dvma_unmap((char *)sp->SCp.have_data_in);
-}
+	scsi_esp_unregister(esp);
 
-static void dma_mmu_release_scsi_sgl (struct NCR_ESP *esp, Scsi_Cmnd *sp)
-{
-    int sz = sp->use_sg - 1;
-    struct scatterlist *sg = (struct scatterlist *)sp->request_buffer;
-                        
-    while(sz >= 0) {
-        dvma_unmap((char *)sg[sz].dma_address);
-        sz--;
-    }
-}
+	/* Disable interrupts.  */
+	val = dma_read32(DMA_CSR);
+	dma_write32(val & ~DMA_INT_ENAB, DMA_CSR);
 
-static void dma_advance_sg (Scsi_Cmnd *sp)
-{
-    sp->SCp.ptr = (char *)((unsigned long)sp->SCp.buffer->dma_address);
-}
+	free_irq(irq, esp);
+	dma_free_coherent(esp->dev, 16,
+			  esp->command_block,
+			  esp->command_block_dma);
 
-static int sun3x_esp_release(struct Scsi_Host *instance)
-{
-	/* this code does not support being compiled as a module */	 
-	return 1;
+	scsi_host_put(esp->host);
 
+	return 0;
 }
 
-static struct scsi_host_template driver_template = {
-	.proc_name		= "sun3x_esp",
-	.proc_info		= &esp_proc_info,
-	.name			= "Sun ESP 100/100a/200",
-	.detect			= sun3x_esp_detect,
-	.release                = sun3x_esp_release,
-	.slave_alloc		= esp_slave_alloc,
-	.slave_destroy		= esp_slave_destroy,
-	.info			= esp_info,
-	.queuecommand		= esp_queue,
-	.eh_abort_handler	= esp_abort,
-	.eh_bus_reset_handler	= esp_reset,
-	.can_queue		= 7,
-	.this_id		= 7,
-	.sg_tablesize		= SG_ALL,
-	.cmd_per_lun		= 1,
-	.use_clustering		= DISABLE_CLUSTERING,
+static struct platform_driver esp_sun3x_driver = {
+	.probe          = esp_sun3x_probe,
+	.remove         = __devexit_p(esp_sun3x_remove),
+	.driver = {
+		.name   = "sun3x_esp",
+	},
 };
 
+static int __init sun3x_esp_init(void)
+{
+	return platform_driver_register(&esp_sun3x_driver);
+}
 
-#include "scsi_module.c"
+static void __exit sun3x_esp_exit(void)
+{
+	platform_driver_unregister(&esp_sun3x_driver);
+}
 
+MODULE_DESCRIPTION("Sun3x ESP SCSI driver");
+MODULE_AUTHOR("Thomas Bogendoerfer (tsbogend@alpha.franken.de)");
 MODULE_LICENSE("GPL");
+MODULE_VERSION(DRV_VERSION);
+
+module_init(sun3x_esp_init);
+module_exit(sun3x_esp_exit);

commit 5a1cb47ff4c3fbc8ebdb53c3e4f2a1dec466b339
Author: Geert Uytterhoeven <geert@linux-m68k.org>
Date:   Wed Oct 24 08:55:40 2007 +0200

    m68k: sg fallout
    
    Signed-off-by: Geert Uytterhoeven <geert@linux-m68k.org>
    Signed-off-by: Jens Axboe <axboe@carl.home.kernel.dk>

diff --git a/drivers/scsi/sun3x_esp.c b/drivers/scsi/sun3x_esp.c
index 80fb3f88af2e..1bc41907a038 100644
--- a/drivers/scsi/sun3x_esp.c
+++ b/drivers/scsi/sun3x_esp.c
@@ -332,8 +332,8 @@ static void dma_mmu_get_scsi_sgl (struct NCR_ESP *esp, Scsi_Cmnd *sp)
     struct scatterlist *sg = sp->SCp.buffer;
 
     while (sz >= 0) {
-	    sg[sz].dma_address = dvma_map((unsigned long)page_address(sg[sz].page) +
-					   sg[sz].offset, sg[sz].length);
+	    sg[sz].dma_address = dvma_map((unsigned long)sg_virt(&sg[sz]),
+					  sg[sz].length);
 	    sz--;
     }
     sp->SCp.ptr=(char *)((unsigned long)sp->SCp.buffer->dma_address);

commit 4df4db5c6c6daeb10a8693d09ce872bce8cd84e6
Author: Maciej W. Rozycki <macro@linux-mips.org>
Date:   Mon Feb 5 16:28:29 2007 -0800

    [TC] dec_esp: Driver model for the PMAZ-A
    
    This is a set of changes that converts the PMAZ-A support to the driver model.
    
    The use of the driver model required switching to the hotplug SCSI
    initialization model, which in turn required a change to the core NCR53C9x
    driver.  I decided not to break all the frontend drivers and introduced an
    additional parameter for esp_allocate() to select between the old and the new
    model.  I hope this is OK, but I would be fine with converting NCR53C9x to the
    new model unconditionally as long as I do not have to fix all the other
    frontends (OK, perhaps I could do some of them ;-) ).
    
    Signed-off-by: Maciej W. Rozycki <macro@linux-mips.org>
    Cc: James Bottomley <James.Bottomley@steeleye.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/drivers/scsi/sun3x_esp.c b/drivers/scsi/sun3x_esp.c
index 6b60536ac92b..80fb3f88af2e 100644
--- a/drivers/scsi/sun3x_esp.c
+++ b/drivers/scsi/sun3x_esp.c
@@ -53,7 +53,7 @@ int sun3x_esp_detect(struct scsi_host_template *tpnt)
 	struct ConfigDev *esp_dev;
 
 	esp_dev = 0;
-	esp = esp_allocate(tpnt, (void *) esp_dev);
+	esp = esp_allocate(tpnt, esp_dev, 0);
 
 	/* Do command transfer with DMA */
 	esp->do_pio_cmds = 0;

commit 79bd3f8563a275d1d068bbb9189a746dc6e96f3e
Author: Christoph Hellwig <hch@lst.de>
Date:   Fri Jul 14 10:29:34 2006 +0200

    [SCSI] More buffer->request_buffer changes
    
    Seem like quite a few splipped through the cracks.  Here's a patch to
    update all references I could find:
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>

diff --git a/drivers/scsi/sun3x_esp.c b/drivers/scsi/sun3x_esp.c
index 1f328cae5c05..6b60536ac92b 100644
--- a/drivers/scsi/sun3x_esp.c
+++ b/drivers/scsi/sun3x_esp.c
@@ -347,7 +347,7 @@ static void dma_mmu_release_scsi_one (struct NCR_ESP *esp, Scsi_Cmnd *sp)
 static void dma_mmu_release_scsi_sgl (struct NCR_ESP *esp, Scsi_Cmnd *sp)
 {
     int sz = sp->use_sg - 1;
-    struct scatterlist *sg = (struct scatterlist *)sp->buffer;
+    struct scatterlist *sg = (struct scatterlist *)sp->request_buffer;
                         
     while(sz >= 0) {
         dvma_unmap((char *)sg[sz].dma_address);

commit 1d6f359a2e06296418481239f8054a878f36e819
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Sat Jul 1 19:29:42 2006 -0700

    [PATCH] irq-flags: scsi: Use the new IRQF_ constants
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: Ingo Molnar <mingo@elte.hu>
    Cc: "David S. Miller" <davem@davemloft.net>
    Cc: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Cc: James Bottomley <James.Bottomley@steeleye.com>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/drivers/scsi/sun3x_esp.c b/drivers/scsi/sun3x_esp.c
index 2e2c1eb15636..1f328cae5c05 100644
--- a/drivers/scsi/sun3x_esp.c
+++ b/drivers/scsi/sun3x_esp.c
@@ -97,7 +97,7 @@ int sun3x_esp_detect(struct scsi_host_template *tpnt)
 	esp->esp_command_dvma = dvma_vtob((unsigned long)esp->esp_command);
 
 	esp->irq = 2;
-	if (request_irq(esp->irq, esp_intr, SA_INTERRUPT, 
+	if (request_irq(esp->irq, esp_intr, IRQF_DISABLED,
 			"SUN3X SCSI", esp->ehost)) {
 		esp_deallocate(esp);
 		return 0;

commit b035c96b2da7258bb2bba31812b5f9dda3499f00
Author: Roman Zippel <zippel@linux-m68k.org>
Date:   Sun Jun 25 05:46:56 2006 -0700

    [PATCH] m68k: Add the generic dma API functions
    
    Signed-off-by: Roman Zippel <zippel@linux-m68k.org>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/drivers/scsi/sun3x_esp.c b/drivers/scsi/sun3x_esp.c
index cc990bed9683..2e2c1eb15636 100644
--- a/drivers/scsi/sun3x_esp.c
+++ b/drivers/scsi/sun3x_esp.c
@@ -332,11 +332,11 @@ static void dma_mmu_get_scsi_sgl (struct NCR_ESP *esp, Scsi_Cmnd *sp)
     struct scatterlist *sg = sp->SCp.buffer;
 
     while (sz >= 0) {
-	    sg[sz].dvma_address = dvma_map((unsigned long)page_address(sg[sz].page) +
+	    sg[sz].dma_address = dvma_map((unsigned long)page_address(sg[sz].page) +
 					   sg[sz].offset, sg[sz].length);
 	    sz--;
     }
-    sp->SCp.ptr=(char *)((unsigned long)sp->SCp.buffer->dvma_address);
+    sp->SCp.ptr=(char *)((unsigned long)sp->SCp.buffer->dma_address);
 }
 
 static void dma_mmu_release_scsi_one (struct NCR_ESP *esp, Scsi_Cmnd *sp)
@@ -350,14 +350,14 @@ static void dma_mmu_release_scsi_sgl (struct NCR_ESP *esp, Scsi_Cmnd *sp)
     struct scatterlist *sg = (struct scatterlist *)sp->buffer;
                         
     while(sz >= 0) {
-        dvma_unmap((char *)sg[sz].dvma_address);
+        dvma_unmap((char *)sg[sz].dma_address);
         sz--;
     }
 }
 
 static void dma_advance_sg (Scsi_Cmnd *sp)
 {
-    sp->SCp.ptr = (char *)((unsigned long)sp->SCp.buffer->dvma_address);
+    sp->SCp.ptr = (char *)((unsigned long)sp->SCp.buffer->dma_address);
 }
 
 static int sun3x_esp_release(struct Scsi_Host *instance)

commit d0be4a7d29ad0bd3ce2209dd9e46d410b632db59
Author: Christoph Hellwig <hch@lst.de>
Date:   Mon Oct 31 18:31:40 2005 +0100

    [SCSI] remove Scsi_Host_Template typedef
    
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>

diff --git a/drivers/scsi/sun3x_esp.c b/drivers/scsi/sun3x_esp.c
index 09d7639079b4..cc990bed9683 100644
--- a/drivers/scsi/sun3x_esp.c
+++ b/drivers/scsi/sun3x_esp.c
@@ -47,7 +47,7 @@ static void dma_advance_sg (Scsi_Cmnd *sp);
 /* Detecting ESP chips on the machine.  This is the simple and easy
  * version.
  */
-int sun3x_esp_detect(Scsi_Host_Template *tpnt)
+int sun3x_esp_detect(struct scsi_host_template *tpnt)
 {
 	struct NCR_ESP *esp;
 	struct ConfigDev *esp_dev;
@@ -367,7 +367,7 @@ static int sun3x_esp_release(struct Scsi_Host *instance)
 
 }
 
-static Scsi_Host_Template driver_template = {
+static struct scsi_host_template driver_template = {
 	.proc_name		= "sun3x_esp",
 	.proc_info		= &esp_proc_info,
 	.name			= "Sun ESP 100/100a/200",

commit 7dfaa5f40da87e85b3883b102bbf1bf3f3b42534
Author: Adrian Bunk <bunk@stusta.de>
Date:   Sun Apr 24 02:34:29 2005 -0500

    [SCSI] drivers/scsi/NCR53C9x.c: make a struct static
    
    This patch makes a needlessly global struct static.
    
    Signed-off-by: Adrian Bunk <bunk@stusta.de>
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>

diff --git a/drivers/scsi/sun3x_esp.c b/drivers/scsi/sun3x_esp.c
index 5d1dc0e8ba21..09d7639079b4 100644
--- a/drivers/scsi/sun3x_esp.c
+++ b/drivers/scsi/sun3x_esp.c
@@ -23,8 +23,6 @@
 #include <asm/dvma.h>
 #include <asm/irq.h>
 
-extern struct NCR_ESP *espchain;
-
 static void dma_barrier(struct NCR_ESP *esp);
 static int  dma_bytes_sent(struct NCR_ESP *esp, int fifo_count);
 static int  dma_can_transfer(struct NCR_ESP *esp, Scsi_Cmnd *sp);

commit 1da177e4c3f41524e886b7f1b8a0c1fc7321cac2
Author: Linus Torvalds <torvalds@ppc970.osdl.org>
Date:   Sat Apr 16 15:20:36 2005 -0700

    Linux-2.6.12-rc2
    
    Initial git repository build. I'm not bothering with the full history,
    even though we have it. We can create a separate "historical" git
    archive of that later if we want to, and in the meantime it's about
    3.2GB when imported into git - space that would just make the early
    git days unnecessarily complicated, when we don't have a lot of good
    infrastructure for it.
    
    Let it rip!

diff --git a/drivers/scsi/sun3x_esp.c b/drivers/scsi/sun3x_esp.c
new file mode 100644
index 000000000000..5d1dc0e8ba21
--- /dev/null
+++ b/drivers/scsi/sun3x_esp.c
@@ -0,0 +1,394 @@
+/* sun3x_esp.c:  EnhancedScsiProcessor Sun3x SCSI driver code.
+ *
+ * (C) 1999 Thomas Bogendoerfer (tsbogend@alpha.franken.de)
+ *
+ * Based on David S. Miller's esp driver
+ */
+
+#include <linux/kernel.h>
+#include <linux/types.h>
+#include <linux/string.h>
+#include <linux/slab.h>
+#include <linux/blkdev.h>
+#include <linux/proc_fs.h>
+#include <linux/stat.h>
+#include <linux/delay.h>
+#include <linux/interrupt.h>
+
+#include "scsi.h"
+#include <scsi/scsi_host.h>
+#include "NCR53C9x.h"
+
+#include <asm/sun3x.h>
+#include <asm/dvma.h>
+#include <asm/irq.h>
+
+extern struct NCR_ESP *espchain;
+
+static void dma_barrier(struct NCR_ESP *esp);
+static int  dma_bytes_sent(struct NCR_ESP *esp, int fifo_count);
+static int  dma_can_transfer(struct NCR_ESP *esp, Scsi_Cmnd *sp);
+static void dma_drain(struct NCR_ESP *esp);
+static void dma_invalidate(struct NCR_ESP *esp);
+static void dma_dump_state(struct NCR_ESP *esp);
+static void dma_init_read(struct NCR_ESP *esp, __u32 vaddress, int length);
+static void dma_init_write(struct NCR_ESP *esp, __u32 vaddress, int length);
+static void dma_ints_off(struct NCR_ESP *esp);
+static void dma_ints_on(struct NCR_ESP *esp);
+static int  dma_irq_p(struct NCR_ESP *esp);
+static void dma_poll(struct NCR_ESP *esp, unsigned char *vaddr);
+static int  dma_ports_p(struct NCR_ESP *esp);
+static void dma_reset(struct NCR_ESP *esp);
+static void dma_setup(struct NCR_ESP *esp, __u32 addr, int count, int write);
+static void dma_mmu_get_scsi_one (struct NCR_ESP *esp, Scsi_Cmnd *sp);
+static void dma_mmu_get_scsi_sgl (struct NCR_ESP *esp, Scsi_Cmnd *sp);
+static void dma_mmu_release_scsi_one (struct NCR_ESP *esp, Scsi_Cmnd *sp);
+static void dma_mmu_release_scsi_sgl (struct NCR_ESP *esp, Scsi_Cmnd *sp);
+static void dma_advance_sg (Scsi_Cmnd *sp);
+
+/* Detecting ESP chips on the machine.  This is the simple and easy
+ * version.
+ */
+int sun3x_esp_detect(Scsi_Host_Template *tpnt)
+{
+	struct NCR_ESP *esp;
+	struct ConfigDev *esp_dev;
+
+	esp_dev = 0;
+	esp = esp_allocate(tpnt, (void *) esp_dev);
+
+	/* Do command transfer with DMA */
+	esp->do_pio_cmds = 0;
+
+	/* Required functions */
+	esp->dma_bytes_sent = &dma_bytes_sent;
+	esp->dma_can_transfer = &dma_can_transfer;
+	esp->dma_dump_state = &dma_dump_state;
+	esp->dma_init_read = &dma_init_read;
+	esp->dma_init_write = &dma_init_write;
+	esp->dma_ints_off = &dma_ints_off;
+	esp->dma_ints_on = &dma_ints_on;
+	esp->dma_irq_p = &dma_irq_p;
+	esp->dma_ports_p = &dma_ports_p;
+	esp->dma_setup = &dma_setup;
+
+	/* Optional functions */
+	esp->dma_barrier = &dma_barrier;
+	esp->dma_invalidate = &dma_invalidate;
+	esp->dma_drain = &dma_drain;
+	esp->dma_irq_entry = 0;
+	esp->dma_irq_exit = 0;
+	esp->dma_led_on = 0;
+	esp->dma_led_off = 0;
+	esp->dma_poll = &dma_poll;
+	esp->dma_reset = &dma_reset;
+
+        /* virtual DMA functions */
+        esp->dma_mmu_get_scsi_one = &dma_mmu_get_scsi_one;
+        esp->dma_mmu_get_scsi_sgl = &dma_mmu_get_scsi_sgl;
+        esp->dma_mmu_release_scsi_one = &dma_mmu_release_scsi_one;
+        esp->dma_mmu_release_scsi_sgl = &dma_mmu_release_scsi_sgl;
+        esp->dma_advance_sg = &dma_advance_sg;
+	    
+	/* SCSI chip speed */
+	esp->cfreq = 20000000;
+	esp->eregs = (struct ESP_regs *)(SUN3X_ESP_BASE);
+	esp->dregs = (void *)SUN3X_ESP_DMA;
+
+	esp->esp_command = (volatile unsigned char *)dvma_malloc(DVMA_PAGE_SIZE);
+	esp->esp_command_dvma = dvma_vtob((unsigned long)esp->esp_command);
+
+	esp->irq = 2;
+	if (request_irq(esp->irq, esp_intr, SA_INTERRUPT, 
+			"SUN3X SCSI", esp->ehost)) {
+		esp_deallocate(esp);
+		return 0;
+	}
+
+	esp->scsi_id = 7;
+	esp->diff = 0;
+
+	esp_initialize(esp);
+
+ 	/* for reasons beyond my knowledge (and which should likely be fixed)
+ 	   sync mode doesn't work on a 3/80 at 5mhz.  but it does at 4. */
+ 	esp->sync_defp = 0x3f;
+
+	printk("ESP: Total of %d ESP hosts found, %d actually in use.\n", nesps,
+	       esps_in_use);
+	esps_running = esps_in_use;
+	return esps_in_use;
+}
+
+static void dma_do_drain(struct NCR_ESP *esp)
+{
+ 	struct sparc_dma_registers *dregs =
+ 		(struct sparc_dma_registers *) esp->dregs;
+ 	
+ 	int count = 500000;
+ 
+ 	while((dregs->cond_reg & DMA_PEND_READ) && (--count > 0)) 
+ 		udelay(1);
+ 
+ 	if(!count) {
+ 		printk("%s:%d timeout CSR %08lx\n", __FILE__, __LINE__, dregs->cond_reg);
+ 	}
+ 
+ 	dregs->cond_reg |= DMA_FIFO_STDRAIN;
+ 	
+ 	count = 500000;
+ 
+ 	while((dregs->cond_reg & DMA_FIFO_ISDRAIN) && (--count > 0)) 
+ 		udelay(1);
+ 
+ 	if(!count) {
+ 		printk("%s:%d timeout CSR %08lx\n", __FILE__, __LINE__, dregs->cond_reg);
+ 	}
+ 
+}
+ 
+static void dma_barrier(struct NCR_ESP *esp)
+{
+  	struct sparc_dma_registers *dregs =
+  		(struct sparc_dma_registers *) esp->dregs;
+ 	int count = 500000;
+  
+ 	while((dregs->cond_reg & DMA_PEND_READ) && (--count > 0))
+  		udelay(1);
+ 
+ 	if(!count) {
+ 		printk("%s:%d timeout CSR %08lx\n", __FILE__, __LINE__, dregs->cond_reg);
+ 	}
+ 
+  	dregs->cond_reg &= ~(DMA_ENABLE);
+}
+
+/* This uses various DMA csr fields and the fifo flags count value to
+ * determine how many bytes were successfully sent/received by the ESP.
+ */
+static int dma_bytes_sent(struct NCR_ESP *esp, int fifo_count)
+{
+	struct sparc_dma_registers *dregs = 
+		(struct sparc_dma_registers *) esp->dregs;
+
+	int rval = dregs->st_addr - esp->esp_command_dvma;
+
+	return rval - fifo_count;
+}
+
+static int dma_can_transfer(struct NCR_ESP *esp, Scsi_Cmnd *sp)
+{
+	return sp->SCp.this_residual;
+}
+
+static void dma_drain(struct NCR_ESP *esp)
+{
+	struct sparc_dma_registers *dregs =
+		(struct sparc_dma_registers *) esp->dregs;
+	int count = 500000;
+
+	if(dregs->cond_reg & DMA_FIFO_ISDRAIN) {
+		dregs->cond_reg |= DMA_FIFO_STDRAIN;
+		while((dregs->cond_reg & DMA_FIFO_ISDRAIN) && (--count > 0))
+			udelay(1);
+		if(!count) {
+			printk("%s:%d timeout CSR %08lx\n", __FILE__, __LINE__, dregs->cond_reg);
+		}
+
+	}
+}
+
+static void dma_invalidate(struct NCR_ESP *esp)
+{
+	struct sparc_dma_registers *dregs =
+		(struct sparc_dma_registers *) esp->dregs;
+
+	__u32 tmp;
+	int count = 500000;
+
+	while(((tmp = dregs->cond_reg) & DMA_PEND_READ) && (--count > 0)) 
+		udelay(1);
+
+	if(!count) {
+		printk("%s:%d timeout CSR %08lx\n", __FILE__, __LINE__, dregs->cond_reg);
+	}
+
+	dregs->cond_reg = tmp | DMA_FIFO_INV;
+	dregs->cond_reg &= ~DMA_FIFO_INV;
+
+}
+
+static void dma_dump_state(struct NCR_ESP *esp)
+{
+	struct sparc_dma_registers *dregs =
+		(struct sparc_dma_registers *) esp->dregs;
+
+	ESPLOG(("esp%d: dma -- cond_reg<%08lx> addr<%08lx>\n",
+		esp->esp_id, dregs->cond_reg, dregs->st_addr));
+}
+
+static void dma_init_read(struct NCR_ESP *esp, __u32 vaddress, int length)
+{
+	struct sparc_dma_registers *dregs = 
+		(struct sparc_dma_registers *) esp->dregs;
+
+	dregs->st_addr = vaddress;
+	dregs->cond_reg |= (DMA_ST_WRITE | DMA_ENABLE);
+}
+
+static void dma_init_write(struct NCR_ESP *esp, __u32 vaddress, int length)
+{
+	struct sparc_dma_registers *dregs = 
+		(struct sparc_dma_registers *) esp->dregs;
+
+	/* Set up the DMA counters */
+
+	dregs->st_addr = vaddress;
+	dregs->cond_reg = ((dregs->cond_reg & ~(DMA_ST_WRITE)) | DMA_ENABLE);
+}
+
+static void dma_ints_off(struct NCR_ESP *esp)
+{
+	DMA_INTSOFF((struct sparc_dma_registers *) esp->dregs);
+}
+
+static void dma_ints_on(struct NCR_ESP *esp)
+{
+	DMA_INTSON((struct sparc_dma_registers *) esp->dregs);
+}
+
+static int dma_irq_p(struct NCR_ESP *esp)
+{
+	return DMA_IRQ_P((struct sparc_dma_registers *) esp->dregs);
+}
+
+static void dma_poll(struct NCR_ESP *esp, unsigned char *vaddr)
+{
+	int count = 50;
+	dma_do_drain(esp);
+
+	/* Wait till the first bits settle. */
+	while((*(volatile unsigned char *)vaddr == 0xff) && (--count > 0))
+		udelay(1);
+
+	if(!count) {
+//		printk("%s:%d timeout expire (data %02x)\n", __FILE__, __LINE__,
+//		       esp_read(esp->eregs->esp_fdata));
+		//mach_halt();
+		vaddr[0] = esp_read(esp->eregs->esp_fdata);
+		vaddr[1] = esp_read(esp->eregs->esp_fdata);
+	}
+
+}	
+
+static int dma_ports_p(struct NCR_ESP *esp)
+{
+	return (((struct sparc_dma_registers *) esp->dregs)->cond_reg 
+			& DMA_INT_ENAB);
+}
+
+/* Resetting various pieces of the ESP scsi driver chipset/buses. */
+static void dma_reset(struct NCR_ESP *esp)
+{
+	struct sparc_dma_registers *dregs =
+		(struct sparc_dma_registers *)esp->dregs;
+
+	/* Punt the DVMA into a known state. */
+	dregs->cond_reg |= DMA_RST_SCSI;
+	dregs->cond_reg &= ~(DMA_RST_SCSI);
+	DMA_INTSON(dregs);
+}
+
+static void dma_setup(struct NCR_ESP *esp, __u32 addr, int count, int write)
+{
+	struct sparc_dma_registers *dregs = 
+		(struct sparc_dma_registers *) esp->dregs;
+	unsigned long nreg = dregs->cond_reg;
+
+//	printk("dma_setup %c addr %08x cnt %08x\n",
+//	       write ? 'W' : 'R', addr, count);
+
+	dma_do_drain(esp);
+
+	if(write)
+		nreg |= DMA_ST_WRITE;
+	else {
+		nreg &= ~(DMA_ST_WRITE);
+	}
+		
+	nreg |= DMA_ENABLE;
+	dregs->cond_reg = nreg;
+	dregs->st_addr = addr;
+}
+
+static void dma_mmu_get_scsi_one (struct NCR_ESP *esp, Scsi_Cmnd *sp)
+{
+    sp->SCp.have_data_in = dvma_map((unsigned long)sp->SCp.buffer,
+				       sp->SCp.this_residual);
+    sp->SCp.ptr = (char *)((unsigned long)sp->SCp.have_data_in);
+}
+
+static void dma_mmu_get_scsi_sgl (struct NCR_ESP *esp, Scsi_Cmnd *sp)
+{
+    int sz = sp->SCp.buffers_residual;
+    struct scatterlist *sg = sp->SCp.buffer;
+
+    while (sz >= 0) {
+	    sg[sz].dvma_address = dvma_map((unsigned long)page_address(sg[sz].page) +
+					   sg[sz].offset, sg[sz].length);
+	    sz--;
+    }
+    sp->SCp.ptr=(char *)((unsigned long)sp->SCp.buffer->dvma_address);
+}
+
+static void dma_mmu_release_scsi_one (struct NCR_ESP *esp, Scsi_Cmnd *sp)
+{
+    dvma_unmap((char *)sp->SCp.have_data_in);
+}
+
+static void dma_mmu_release_scsi_sgl (struct NCR_ESP *esp, Scsi_Cmnd *sp)
+{
+    int sz = sp->use_sg - 1;
+    struct scatterlist *sg = (struct scatterlist *)sp->buffer;
+                        
+    while(sz >= 0) {
+        dvma_unmap((char *)sg[sz].dvma_address);
+        sz--;
+    }
+}
+
+static void dma_advance_sg (Scsi_Cmnd *sp)
+{
+    sp->SCp.ptr = (char *)((unsigned long)sp->SCp.buffer->dvma_address);
+}
+
+static int sun3x_esp_release(struct Scsi_Host *instance)
+{
+	/* this code does not support being compiled as a module */	 
+	return 1;
+
+}
+
+static Scsi_Host_Template driver_template = {
+	.proc_name		= "sun3x_esp",
+	.proc_info		= &esp_proc_info,
+	.name			= "Sun ESP 100/100a/200",
+	.detect			= sun3x_esp_detect,
+	.release                = sun3x_esp_release,
+	.slave_alloc		= esp_slave_alloc,
+	.slave_destroy		= esp_slave_destroy,
+	.info			= esp_info,
+	.queuecommand		= esp_queue,
+	.eh_abort_handler	= esp_abort,
+	.eh_bus_reset_handler	= esp_reset,
+	.can_queue		= 7,
+	.this_id		= 7,
+	.sg_tablesize		= SG_ALL,
+	.cmd_per_lun		= 1,
+	.use_clustering		= DISABLE_CLUSTERING,
+};
+
+
+#include "scsi_module.c"
+
+MODULE_LICENSE("GPL");
