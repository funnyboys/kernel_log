commit 3c1e681bcdd86b86c676044330ec945d9abc4533
Author: Mauro Carvalho Chehab <mchehab+huawei@kernel.org>
Date:   Mon Mar 2 09:15:49 2020 +0100

    scsi: docs: convert g_NCR5380.txt to ReST
    
    Link: https://lore.kernel.org/r/a66e9ea704be6a7aa81b9864ad66a32b75ab808d.1583136624.git.mchehab+huawei@kernel.org
    Acked-by: Finn Thain <fthain@telegraphics.com.au>
    Signed-off-by: Mauro Carvalho Chehab <mchehab+huawei@kernel.org>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/g_NCR5380.c b/drivers/scsi/g_NCR5380.c
index 2ab774e62e40..2cc676e3df6a 100644
--- a/drivers/scsi/g_NCR5380.c
+++ b/drivers/scsi/g_NCR5380.c
@@ -20,7 +20,7 @@
  * Added ISAPNP support for DTC436 adapters,
  * Thomas Sailer, sailer@ife.ee.ethz.ch
  *
- * See Documentation/scsi/g_NCR5380.txt for more info.
+ * See Documentation/scsi/g_NCR5380.rst for more info.
  */
 
 #include <asm/io.h>

commit 09c434b8a0047c69e48499de0107de312901e798
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Sun May 19 13:08:20 2019 +0100

    treewide: Add SPDX license identifier for more missed files
    
    Add SPDX license identifiers to all files which:
    
     - Have no license information of any form
    
     - Have MODULE_LICENCE("GPL*") inside which was used in the initial
       scan/conversion to ignore the file
    
    These files fall under the project license, GPL v2 only. The resulting SPDX
    license identifier is:
    
      GPL-2.0-only
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/scsi/g_NCR5380.c b/drivers/scsi/g_NCR5380.c
index 9cdca0625498..2ab774e62e40 100644
--- a/drivers/scsi/g_NCR5380.c
+++ b/drivers/scsi/g_NCR5380.c
@@ -1,3 +1,4 @@
+// SPDX-License-Identifier: GPL-2.0-only
 /*
  * Generic Generic NCR5380 driver
  *

commit 4af14d113bcf95c12d1462ba623b7e7117bd3fb3
Author: Christoph Hellwig <hch@lst.de>
Date:   Thu Dec 13 16:17:09 2018 +0100

    scsi: remove the use_clustering flag
    
    The same effects can be achieved by setting the dma_boundary to
    PAGE_SIZE - 1 and the max_segment_size to PAGE_SIZE, so shift those
    settings into the drivers.  Note that in many cases the setting might
    be bogus, but this keeps the status quo.
    
    [mkp: fix myrs and myrb]
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/g_NCR5380.c b/drivers/scsi/g_NCR5380.c
index fc538181f8df..9cdca0625498 100644
--- a/drivers/scsi/g_NCR5380.c
+++ b/drivers/scsi/g_NCR5380.c
@@ -700,7 +700,7 @@ static struct scsi_host_template driver_template = {
 	.this_id		= 7,
 	.sg_tablesize		= SG_ALL,
 	.cmd_per_lun		= 2,
-	.use_clustering		= DISABLE_CLUSTERING,
+	.dma_boundary		= PAGE_SIZE - 1,
 	.cmd_size		= NCR5380_CMD_SIZE,
 	.max_sectors		= 128,
 };

commit 12e5fc665a2d8380c1551291a0d7684fc181b02d
Author: Hannes Reinecke <hare@suse.de>
Date:   Fri Aug 25 13:57:10 2017 +0200

    scsi: NCR5380: Move bus reset to host reset
    
    The bus reset handler really is a host reset, so move it to
    eh_bus_reset_handler.
    
    Signed-off-by: Hannes Reinecke <hare@suse.com>
    Acked-by: Finn Thain <fthain@telegraphics.com.au>
    Reviewed-by: Christoph Hellwig <hch@lst.de>
    Reviewed-by: Johannes Thumshirn <jthumshirn@suse.de>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/g_NCR5380.c b/drivers/scsi/g_NCR5380.c
index edf990b64714..fc538181f8df 100644
--- a/drivers/scsi/g_NCR5380.c
+++ b/drivers/scsi/g_NCR5380.c
@@ -56,7 +56,7 @@
 #define NCR5380_intr                    generic_NCR5380_intr
 #define NCR5380_queue_command           generic_NCR5380_queue_command
 #define NCR5380_abort                   generic_NCR5380_abort
-#define NCR5380_bus_reset               generic_NCR5380_bus_reset
+#define NCR5380_host_reset              generic_NCR5380_host_reset
 #define NCR5380_info                    generic_NCR5380_info
 
 #define NCR5380_io_delay(x)             udelay(x)
@@ -695,7 +695,7 @@ static struct scsi_host_template driver_template = {
 	.info			= generic_NCR5380_info,
 	.queuecommand		= generic_NCR5380_queue_command,
 	.eh_abort_handler	= generic_NCR5380_abort,
-	.eh_bus_reset_handler	= generic_NCR5380_bus_reset,
+	.eh_host_reset_handler	= generic_NCR5380_host_reset,
 	.can_queue		= 16,
 	.this_id		= 7,
 	.sg_tablesize		= SG_ALL,

commit 60747936bd5c0f7de2179f7076fe89ad93675680
Author: Arvind Yadav <arvind.yadav.cs@gmail.com>
Date:   Wed Aug 16 10:28:40 2017 +0530

    scsi: ncr5380: constify pnp_device_id
    
    pnp_device_id are not supposed to change at runtime. All functions
    working with pnp_device_id provided by <linux/pnp.h> work with const
    pnp_device_id. So mark the non-const structs as const.
    
    Signed-off-by: Arvind Yadav <arvind.yadav.cs@gmail.com>
    Acked-by: Finn Thain <fthain@telegraphics.com.au>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/g_NCR5380.c b/drivers/scsi/g_NCR5380.c
index b4da4811b7a1..edf990b64714 100644
--- a/drivers/scsi/g_NCR5380.c
+++ b/drivers/scsi/g_NCR5380.c
@@ -736,7 +736,7 @@ static struct isa_driver generic_NCR5380_isa_driver = {
 };
 
 #ifdef CONFIG_PNP
-static struct pnp_device_id generic_NCR5380_pnp_ids[] = {
+static const struct pnp_device_id generic_NCR5380_pnp_ids[] = {
 	{ .id = "DTC436e", .driver_data = BOARD_DTC3181E },
 	{ .id = "" }
 };

commit facfc963ae92f8f47f79905927da024ae779a2c1
Author: Ondrej Zary <linux@rainbow-software.org>
Date:   Mon Jul 3 03:59:06 2017 -0400

    scsi: g_NCR5380: Two DTC436 PDMA workarounds
    
    Limit PDMA send to 512 B to avoid data corruption on DTC3181E. The
    corruption is always the same: one byte missing at the beginning of a
    128 B block. It happens only with slow Quantum LPS 240 drive, not with
    faster IBM DORS-32160. It's not clear what causes this. Documentation
    for the DTC436 chip has not been made available.
    
    Signed-off-by: Finn Thain <fthain@telegraphics.com.au>
    Tested-by: Ondrej Zary <linux@rainbow-software.org>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/g_NCR5380.c b/drivers/scsi/g_NCR5380.c
index 7d1d75d60029..b4da4811b7a1 100644
--- a/drivers/scsi/g_NCR5380.c
+++ b/drivers/scsi/g_NCR5380.c
@@ -45,7 +45,8 @@
 	int c400_blk_cnt; \
 	int c400_host_buf; \
 	int io_width; \
-	int pdma_residual
+	int pdma_residual; \
+	int board
 
 #define NCR5380_dma_xfer_len            generic_NCR5380_dma_xfer_len
 #define NCR5380_dma_recv_setup          generic_NCR5380_precv
@@ -316,6 +317,7 @@ static int generic_NCR5380_init_one(struct scsi_host_template *tpnt,
 	}
 	hostdata = shost_priv(instance);
 
+	hostdata->board = board;
 	hostdata->io = iomem;
 	hostdata->region_size = region_size;
 
@@ -492,6 +494,8 @@ static void wait_for_53c80_access(struct NCR5380_hostdata *hostdata)
 	int count = 10000;
 
 	do {
+		if (hostdata->board == BOARD_DTC3181E)
+			udelay(4); /* DTC436 chip hangs without this */
 		if (NCR5380_read(hostdata->c400_ctl_status) & CSR_53C80_REG)
 			return;
 	} while (--count > 0);
@@ -665,7 +669,12 @@ static int generic_NCR5380_dma_xfer_len(struct NCR5380_hostdata *hostdata,
 
 	/* 53C400 datasheet: non-modulo-128-byte transfers should use PIO */
 	if (transfersize % 128)
-		transfersize = 0;
+		return 0;
+
+	/* Limit PDMA send to 512 B to avoid random corruption on DTC3181E */
+	if (hostdata->board == BOARD_DTC3181E &&
+	    cmd->sc_data_direction == DMA_TO_DEVICE)
+		transfersize = min(cmd->SCp.this_residual, 512);
 
 	return min(transfersize, DMA_MAX_SIZE);
 }

commit 99a974e6b8b0734fd2f5d8185e640aba0d6da06f
Author: Ondrej Zary <linux@rainbow-software.org>
Date:   Mon Jul 3 03:59:06 2017 -0400

    scsi: g_NCR5380: Re-work PDMA loops
    
    The polling loops in pread() and pwrite() can easily become infinite
    loops and hang the machine.
    
    Merge the IRQ check into host buffer wait loop and add polling limit.
    
    Also place a limit on polling for 53C80 registers accessibility.
    
    [Use NCR5380_poll_politely2() for register polling. Rely on polling for
    gated IRQ rather than polling for phase error, like the algorithm in the
    53c400 datasheet. Move DTC436 workarounds into a separate patch.
    Factor-out common code as wait_for_53c80_access(). Rework the residual
    calculations. -- F.T.]
    
    Signed-off-by: Ondrej Zary <linux@rainbow-software.org>
    Signed-off-by: Finn Thain <fthain@telegraphics.com.au>
    Tested-by: Ondrej Zary <linux@rainbow-software.org>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/g_NCR5380.c b/drivers/scsi/g_NCR5380.c
index 3cae34632cf8..7d1d75d60029 100644
--- a/drivers/scsi/g_NCR5380.c
+++ b/drivers/scsi/g_NCR5380.c
@@ -480,6 +480,28 @@ static void generic_NCR5380_release_resources(struct Scsi_Host *instance)
 		release_mem_region(base, region_size);
 }
 
+/* wait_for_53c80_access - wait for 53C80 registers to become accessible
+ * @hostdata: scsi host private data
+ *
+ * The registers within the 53C80 logic block are inaccessible until
+ * bit 7 in the 53C400 control status register gets asserted.
+ */
+
+static void wait_for_53c80_access(struct NCR5380_hostdata *hostdata)
+{
+	int count = 10000;
+
+	do {
+		if (NCR5380_read(hostdata->c400_ctl_status) & CSR_53C80_REG)
+			return;
+	} while (--count > 0);
+
+	scmd_printk(KERN_ERR, hostdata->connected,
+	            "53c80 registers not accessible, device will be reset\n");
+	NCR5380_write(hostdata->c400_ctl_status, CSR_RESET);
+	NCR5380_write(hostdata->c400_ctl_status, CSR_BASE);
+}
+
 /**
  * generic_NCR5380_precv - pseudo DMA receive
  * @hostdata: scsi host private data
@@ -492,18 +514,27 @@ static void generic_NCR5380_release_resources(struct Scsi_Host *instance)
 static inline int generic_NCR5380_precv(struct NCR5380_hostdata *hostdata,
                                         unsigned char *dst, int len)
 {
-	int blocks = len / 128;
+	int residual;
 	int start = 0;
 
 	NCR5380_write(hostdata->c400_ctl_status, CSR_BASE | CSR_TRANS_DIR);
-	NCR5380_write(hostdata->c400_blk_cnt, blocks);
-	while (1) {
-		if (NCR5380_read(hostdata->c400_blk_cnt) == 0)
-			break;
-		if (NCR5380_read(hostdata->c400_ctl_status) & CSR_GATED_53C80_IRQ)
-			goto out_wait;
-		while (NCR5380_read(hostdata->c400_ctl_status) & CSR_HOST_BUF_NOT_RDY)
-			; /* FIXME - no timeout */
+	NCR5380_write(hostdata->c400_blk_cnt, len / 128);
+
+	do {
+		if (start == len - 128) {
+			/* Ignore End of DMA interrupt for the final buffer */
+			if (NCR5380_poll_politely(hostdata, hostdata->c400_ctl_status,
+			                          CSR_HOST_BUF_NOT_RDY, 0, HZ / 64) < 0)
+				break;
+		} else {
+			if (NCR5380_poll_politely2(hostdata, hostdata->c400_ctl_status,
+			                           CSR_HOST_BUF_NOT_RDY, 0,
+			                           hostdata->c400_ctl_status,
+			                           CSR_GATED_53C80_IRQ,
+			                           CSR_GATED_53C80_IRQ, HZ / 64) < 0 ||
+			    NCR5380_read(hostdata->c400_ctl_status) & CSR_HOST_BUF_NOT_RDY)
+				break;
+		}
 
 		if (hostdata->io_port && hostdata->io_width == 2)
 			insw(hostdata->io_port + hostdata->c400_host_buf,
@@ -514,44 +545,26 @@ static inline int generic_NCR5380_precv(struct NCR5380_hostdata *hostdata,
 		else
 			memcpy_fromio(dst + start,
 				hostdata->io + NCR53C400_host_buffer, 128);
-
 		start += 128;
-		blocks--;
-	}
+	} while (start < len);
 
-	if (blocks) {
-		while (NCR5380_read(hostdata->c400_ctl_status) & CSR_HOST_BUF_NOT_RDY)
-			; /* FIXME - no timeout */
-
-		if (hostdata->io_port && hostdata->io_width == 2)
-			insw(hostdata->io_port + hostdata->c400_host_buf,
-							dst + start, 64);
-		else if (hostdata->io_port)
-			insb(hostdata->io_port + hostdata->c400_host_buf,
-							dst + start, 128);
-		else
-			memcpy_fromio(dst + start,
-				hostdata->io + NCR53C400_host_buffer, 128);
+	residual = len - start;
 
-		start += 128;
-		blocks--;
+	if (residual != 0) {
+		/* 53c80 interrupt or transfer timeout. Reset 53c400 logic. */
+		NCR5380_write(hostdata->c400_ctl_status, CSR_RESET);
+		NCR5380_write(hostdata->c400_ctl_status, CSR_BASE);
 	}
+	wait_for_53c80_access(hostdata);
 
-	if (!(NCR5380_read(hostdata->c400_ctl_status) & CSR_GATED_53C80_IRQ))
-		printk("53C400r: no 53C80 gated irq after transfer");
-
-out_wait:
-	hostdata->pdma_residual = len - start;
+	if (residual == 0 && NCR5380_poll_politely(hostdata, BUS_AND_STATUS_REG,
+	                                           BASR_END_DMA_TRANSFER,
+	                                           BASR_END_DMA_TRANSFER,
+	                                           HZ / 64) < 0)
+		scmd_printk(KERN_ERR, hostdata->connected, "%s: End of DMA timeout\n",
+		            __func__);
 
-	/* wait for 53C80 registers to be available */
-	while (!(NCR5380_read(hostdata->c400_ctl_status) & CSR_53C80_REG))
-		;
-
-	if (NCR5380_poll_politely(hostdata, BUS_AND_STATUS_REG,
-	                          BASR_END_DMA_TRANSFER, BASR_END_DMA_TRANSFER,
-	                          HZ / 64) < 0)
-		scmd_printk(KERN_ERR, hostdata->connected, "%s: End of DMA timeout (%d)\n",
-		            __func__, hostdata->pdma_residual);
+	hostdata->pdma_residual = residual;
 
 	return 0;
 }
@@ -568,36 +581,39 @@ static inline int generic_NCR5380_precv(struct NCR5380_hostdata *hostdata,
 static inline int generic_NCR5380_psend(struct NCR5380_hostdata *hostdata,
                                         unsigned char *src, int len)
 {
-	int blocks = len / 128;
+	int residual;
 	int start = 0;
 
 	NCR5380_write(hostdata->c400_ctl_status, CSR_BASE);
-	NCR5380_write(hostdata->c400_blk_cnt, blocks);
-	while (1) {
-		if (NCR5380_read(hostdata->c400_ctl_status) & CSR_GATED_53C80_IRQ)
-			goto out_wait;
+	NCR5380_write(hostdata->c400_blk_cnt, len / 128);
+
+	do {
+		if (NCR5380_poll_politely2(hostdata, hostdata->c400_ctl_status,
+		                           CSR_HOST_BUF_NOT_RDY, 0,
+		                           hostdata->c400_ctl_status,
+		                           CSR_GATED_53C80_IRQ,
+		                           CSR_GATED_53C80_IRQ, HZ / 64) < 0 ||
+		    NCR5380_read(hostdata->c400_ctl_status) & CSR_HOST_BUF_NOT_RDY) {
+			/* Both 128 B buffers are in use */
+			if (start >= 128)
+				start -= 128;
+			if (start >= 128)
+				start -= 128;
+			break;
+		}
 
-		if (NCR5380_read(hostdata->c400_blk_cnt) == 0)
+		if (start >= len && NCR5380_read(hostdata->c400_blk_cnt) == 0)
 			break;
-		while (NCR5380_read(hostdata->c400_ctl_status) & CSR_HOST_BUF_NOT_RDY)
-			; // FIXME - timeout
 
-		if (hostdata->io_port && hostdata->io_width == 2)
-			outsw(hostdata->io_port + hostdata->c400_host_buf,
-							src + start, 64);
-		else if (hostdata->io_port)
-			outsb(hostdata->io_port + hostdata->c400_host_buf,
-							src + start, 128);
-		else
-			memcpy_toio(hostdata->io + NCR53C400_host_buffer,
-			            src + start, 128);
+		if (NCR5380_read(hostdata->c400_ctl_status) & CSR_GATED_53C80_IRQ) {
+			/* Host buffer is empty, other one is in use */
+			if (start >= 128)
+				start -= 128;
+			break;
+		}
 
-		start += 128;
-		blocks--;
-	}
-	if (blocks) {
-		while (NCR5380_read(hostdata->c400_ctl_status) & CSR_HOST_BUF_NOT_RDY)
-			; // FIXME - no timeout
+		if (start >= len)
+			continue;
 
 		if (hostdata->io_port && hostdata->io_width == 2)
 			outsw(hostdata->io_port + hostdata->c400_host_buf,
@@ -608,28 +624,33 @@ static inline int generic_NCR5380_psend(struct NCR5380_hostdata *hostdata,
 		else
 			memcpy_toio(hostdata->io + NCR53C400_host_buffer,
 			            src + start, 128);
-
 		start += 128;
-		blocks--;
-	}
+	} while (1);
 
-out_wait:
-	hostdata->pdma_residual = len - start;
+	residual = len - start;
 
-	/* wait for 53C80 registers to be available */
-	while (!(NCR5380_read(hostdata->c400_ctl_status) & CSR_53C80_REG)) {
-		udelay(4); /* DTC436 chip hangs without this */
-		/* FIXME - no timeout */
+	if (residual != 0) {
+		/* 53c80 interrupt or transfer timeout. Reset 53c400 logic. */
+		NCR5380_write(hostdata->c400_ctl_status, CSR_RESET);
+		NCR5380_write(hostdata->c400_ctl_status, CSR_BASE);
+	}
+	wait_for_53c80_access(hostdata);
+
+	if (residual == 0) {
+		if (NCR5380_poll_politely(hostdata, TARGET_COMMAND_REG,
+		                          TCR_LAST_BYTE_SENT, TCR_LAST_BYTE_SENT,
+		                          HZ / 64) < 0)
+			scmd_printk(KERN_ERR, hostdata->connected,
+			            "%s: Last Byte Sent timeout\n", __func__);
+
+		if (NCR5380_poll_politely(hostdata, BUS_AND_STATUS_REG,
+		                          BASR_END_DMA_TRANSFER, BASR_END_DMA_TRANSFER,
+		                          HZ / 64) < 0)
+			scmd_printk(KERN_ERR, hostdata->connected, "%s: End of DMA timeout\n",
+			            __func__);
 	}
 
-	while (!(NCR5380_read(TARGET_COMMAND_REG) & TCR_LAST_BYTE_SENT))
-		; 	// TIMEOUT
-
-	if (NCR5380_poll_politely(hostdata, BUS_AND_STATUS_REG,
-	                          BASR_END_DMA_TRANSFER, BASR_END_DMA_TRANSFER,
-	                          HZ / 64) < 0)
-		scmd_printk(KERN_ERR, hostdata->connected, "%s: End of DMA timeout (%d)\n",
-		            __func__, hostdata->pdma_residual);
+	hostdata->pdma_residual = residual;
 
 	return 0;
 }

commit ab2ace2df9b20f0c1111560b275ad38ed36703fc
Author: Finn Thain <fthain@telegraphics.com.au>
Date:   Mon Jul 3 03:59:06 2017 -0400

    scsi: g_NCR5380: Use unambiguous terminology for PDMA send and receive
    
    The word "read" may be used to mean "DMA read operation" or "SCSI READ
    command", though a READ command implies writing to memory.
    
    Signed-off-by: Finn Thain <fthain@telegraphics.com.au>
    Tested-by: Ondrej Zary <linux@rainbow-software.org>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/g_NCR5380.c b/drivers/scsi/g_NCR5380.c
index 97e80375c5d9..3cae34632cf8 100644
--- a/drivers/scsi/g_NCR5380.c
+++ b/drivers/scsi/g_NCR5380.c
@@ -48,8 +48,8 @@
 	int pdma_residual
 
 #define NCR5380_dma_xfer_len            generic_NCR5380_dma_xfer_len
-#define NCR5380_dma_recv_setup          generic_NCR5380_pread
-#define NCR5380_dma_send_setup          generic_NCR5380_pwrite
+#define NCR5380_dma_recv_setup          generic_NCR5380_precv
+#define NCR5380_dma_send_setup          generic_NCR5380_psend
 #define NCR5380_dma_residual            generic_NCR5380_dma_residual
 
 #define NCR5380_intr                    generic_NCR5380_intr
@@ -481,7 +481,7 @@ static void generic_NCR5380_release_resources(struct Scsi_Host *instance)
 }
 
 /**
- * generic_NCR5380_pread - pseudo DMA read
+ * generic_NCR5380_precv - pseudo DMA receive
  * @hostdata: scsi host private data
  * @dst: buffer to write into
  * @len: transfer size
@@ -489,7 +489,7 @@ static void generic_NCR5380_release_resources(struct Scsi_Host *instance)
  * Perform a pseudo DMA mode receive from a 53C400 or equivalent device.
  */
 
-static inline int generic_NCR5380_pread(struct NCR5380_hostdata *hostdata,
+static inline int generic_NCR5380_precv(struct NCR5380_hostdata *hostdata,
                                         unsigned char *dst, int len)
 {
 	int blocks = len / 128;
@@ -557,7 +557,7 @@ static inline int generic_NCR5380_pread(struct NCR5380_hostdata *hostdata,
 }
 
 /**
- * generic_NCR5380_pwrite - pseudo DMA write
+ * generic_NCR5380_psend - pseudo DMA send
  * @hostdata: scsi host private data
  * @src: buffer to read from
  * @len: transfer size
@@ -565,8 +565,8 @@ static inline int generic_NCR5380_pread(struct NCR5380_hostdata *hostdata,
  * Perform a pseudo DMA mode send to a 53C400 or equivalent device.
  */
 
-static inline int generic_NCR5380_pwrite(struct NCR5380_hostdata *hostdata,
-                                         unsigned char *src, int len)
+static inline int generic_NCR5380_psend(struct NCR5380_hostdata *hostdata,
+                                        unsigned char *src, int len)
 {
 	int blocks = len / 128;
 	int start = 0;

commit 24c43341a0445307a7d17fd681d10bd7bd789fc8
Author: Finn Thain <fthain@telegraphics.com.au>
Date:   Mon Jul 3 03:59:06 2017 -0400

    scsi: g_NCR5380: Cleanup comments and whitespace
    
    Signed-off-by: Finn Thain <fthain@telegraphics.com.au>
    Tested-by: Ondrej Zary <linux@rainbow-software.org>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/g_NCR5380.c b/drivers/scsi/g_NCR5380.c
index f209b12280cc..97e80375c5d9 100644
--- a/drivers/scsi/g_NCR5380.c
+++ b/drivers/scsi/g_NCR5380.c
@@ -1,17 +1,17 @@
 /*
  * Generic Generic NCR5380 driver
- *	
+ *
  * Copyright 1993, Drew Eckhardt
- *	Visionary Computing
- *	(Unix and Linux consulting and custom programming)
- *	drew@colorado.edu
- *      +1 (303) 440-4894
+ * Visionary Computing
+ * (Unix and Linux consulting and custom programming)
+ * drew@colorado.edu
+ * +1 (303) 440-4894
  *
  * NCR53C400 extensions (c) 1994,1995,1996, Kevin Lentin
- *    K.Lentin@cs.monash.edu.au
+ * K.Lentin@cs.monash.edu.au
  *
  * NCR53C400A extensions (c) 1996, Ingmar Baumgart
- *    ingmar@gonzo.schwaben.de
+ * ingmar@gonzo.schwaben.de
  *
  * DTC3181E extensions (c) 1997, Ronald van Cuijlenborg
  * ronald.van.cuijlenborg@tip.nl or nutty@dds.nl
@@ -481,15 +481,14 @@ static void generic_NCR5380_release_resources(struct Scsi_Host *instance)
 }
 
 /**
- *	generic_NCR5380_pread - pseudo DMA read
- *	@hostdata: scsi host private data
- *	@dst: buffer to read into
- *	@len: buffer length
+ * generic_NCR5380_pread - pseudo DMA read
+ * @hostdata: scsi host private data
+ * @dst: buffer to write into
+ * @len: transfer size
  *
- *	Perform a pseudo DMA mode read from an NCR53C400 or equivalent
- *	controller
+ * Perform a pseudo DMA mode receive from a 53C400 or equivalent device.
  */
- 
+
 static inline int generic_NCR5380_pread(struct NCR5380_hostdata *hostdata,
                                         unsigned char *dst, int len)
 {
@@ -508,10 +507,10 @@ static inline int generic_NCR5380_pread(struct NCR5380_hostdata *hostdata,
 
 		if (hostdata->io_port && hostdata->io_width == 2)
 			insw(hostdata->io_port + hostdata->c400_host_buf,
-							dst + start, 64);
+			     dst + start, 64);
 		else if (hostdata->io_port)
 			insb(hostdata->io_port + hostdata->c400_host_buf,
-							dst + start, 128);
+			     dst + start, 128);
 		else
 			memcpy_fromio(dst + start,
 				hostdata->io + NCR53C400_host_buffer, 128);
@@ -558,13 +557,12 @@ static inline int generic_NCR5380_pread(struct NCR5380_hostdata *hostdata,
 }
 
 /**
- *	generic_NCR5380_pwrite - pseudo DMA write
- *	@hostdata: scsi host private data
- *	@dst: buffer to read into
- *	@len: buffer length
+ * generic_NCR5380_pwrite - pseudo DMA write
+ * @hostdata: scsi host private data
+ * @src: buffer to read from
+ * @len: transfer size
  *
- *	Perform a pseudo DMA mode read from an NCR53C400 or equivalent
- *	controller
+ * Perform a pseudo DMA mode send to a 53C400 or equivalent device.
  */
 
 static inline int generic_NCR5380_pwrite(struct NCR5380_hostdata *hostdata,
@@ -603,10 +601,10 @@ static inline int generic_NCR5380_pwrite(struct NCR5380_hostdata *hostdata,
 
 		if (hostdata->io_port && hostdata->io_width == 2)
 			outsw(hostdata->io_port + hostdata->c400_host_buf,
-							src + start, 64);
+			      src + start, 64);
 		else if (hostdata->io_port)
 			outsb(hostdata->io_port + hostdata->c400_host_buf,
-							src + start, 128);
+			      src + start, 128);
 		else
 			memcpy_toio(hostdata->io + NCR53C400_host_buffer,
 			            src + start, 128);
@@ -656,10 +654,8 @@ static int generic_NCR5380_dma_residual(struct NCR5380_hostdata *hostdata)
 	return hostdata->pdma_residual;
 }
 
-/*
- *	Include the NCR5380 core code that we build our driver around	
- */
- 
+/* Include the core driver code. */
+
 #include "NCR5380.c"
 
 static struct scsi_host_template driver_template = {
@@ -679,11 +675,10 @@ static struct scsi_host_template driver_template = {
 	.max_sectors		= 128,
 };
 
-
 static int generic_NCR5380_isa_match(struct device *pdev, unsigned int ndev)
 {
 	int ret = generic_NCR5380_init_one(&driver_template, pdev, base[ndev],
-					  irq[ndev], card[ndev]);
+	                                   irq[ndev], card[ndev]);
 	if (ret) {
 		if (base[ndev])
 			printk(KERN_WARNING "Card not found at address 0x%03x\n",
@@ -695,7 +690,7 @@ static int generic_NCR5380_isa_match(struct device *pdev, unsigned int ndev)
 }
 
 static int generic_NCR5380_isa_remove(struct device *pdev,
-				   unsigned int ndev)
+                                      unsigned int ndev)
 {
 	generic_NCR5380_release_resources(dev_get_drvdata(pdev));
 	dev_set_drvdata(pdev, NULL);
@@ -718,7 +713,7 @@ static struct pnp_device_id generic_NCR5380_pnp_ids[] = {
 MODULE_DEVICE_TABLE(pnp, generic_NCR5380_pnp_ids);
 
 static int generic_NCR5380_pnp_probe(struct pnp_dev *pdev,
-			       const struct pnp_device_id *id)
+                                     const struct pnp_device_id *id)
 {
 	int base, irq;
 
@@ -729,7 +724,7 @@ static int generic_NCR5380_pnp_probe(struct pnp_dev *pdev,
 	irq = pnp_irq(pdev, 0);
 
 	return generic_NCR5380_init_one(&driver_template, &pdev->dev, base, irq,
-				       id->driver_data);
+	                                id->driver_data);
 }
 
 static void generic_NCR5380_pnp_remove(struct pnp_dev *pdev)

commit e9dbadf7881375ebb234ff579838f85df2abe4cf
Author: Ondrej Zary <linux@rainbow-software.org>
Date:   Mon Jul 3 03:59:05 2017 -0400

    scsi: g_NCR5380: End PDMA transfer correctly on target disconnection
    
    When an IRQ arrives during PDMA transfer, pread() and pwrite() return
    without waiting for the 53C80 registers to be ready and this ends up
    messing up the chip state. This was observed with SONY CDU-55S which is
    slow enough to disconnect during 4096-byte reads.
    
    IRQ during PDMA is not an error so don't return -1. Instead, store the
    remaining byte count for use by NCR5380_dma_residual().
    
    [Poll for the BASR_END_DMA_TRANSFER condition rather than remove the
    error message -- F.T.]
    
    Signed-off-by: Ondrej Zary <linux@rainbow-software.org>
    Signed-off-by: Finn Thain <fthain@telegraphics.com.au>
    Tested-by: Ondrej Zary <linux@rainbow-software.org>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/g_NCR5380.c b/drivers/scsi/g_NCR5380.c
index fbb28ed0fce8..f209b12280cc 100644
--- a/drivers/scsi/g_NCR5380.c
+++ b/drivers/scsi/g_NCR5380.c
@@ -44,12 +44,13 @@
 	int c400_ctl_status; \
 	int c400_blk_cnt; \
 	int c400_host_buf; \
-	int io_width
+	int io_width; \
+	int pdma_residual
 
 #define NCR5380_dma_xfer_len            generic_NCR5380_dma_xfer_len
 #define NCR5380_dma_recv_setup          generic_NCR5380_pread
 #define NCR5380_dma_send_setup          generic_NCR5380_pwrite
-#define NCR5380_dma_residual            NCR5380_dma_residual_none
+#define NCR5380_dma_residual            generic_NCR5380_dma_residual
 
 #define NCR5380_intr                    generic_NCR5380_intr
 #define NCR5380_queue_command           generic_NCR5380_queue_command
@@ -500,10 +501,8 @@ static inline int generic_NCR5380_pread(struct NCR5380_hostdata *hostdata,
 	while (1) {
 		if (NCR5380_read(hostdata->c400_blk_cnt) == 0)
 			break;
-		if (NCR5380_read(hostdata->c400_ctl_status) & CSR_GATED_53C80_IRQ) {
-			printk(KERN_ERR "53C400r: Got 53C80_IRQ start=%d, blocks=%d\n", start, blocks);
-			return -1;
-		}
+		if (NCR5380_read(hostdata->c400_ctl_status) & CSR_GATED_53C80_IRQ)
+			goto out_wait;
 		while (NCR5380_read(hostdata->c400_ctl_status) & CSR_HOST_BUF_NOT_RDY)
 			; /* FIXME - no timeout */
 
@@ -542,13 +541,19 @@ static inline int generic_NCR5380_pread(struct NCR5380_hostdata *hostdata,
 	if (!(NCR5380_read(hostdata->c400_ctl_status) & CSR_GATED_53C80_IRQ))
 		printk("53C400r: no 53C80 gated irq after transfer");
 
+out_wait:
+	hostdata->pdma_residual = len - start;
+
 	/* wait for 53C80 registers to be available */
 	while (!(NCR5380_read(hostdata->c400_ctl_status) & CSR_53C80_REG))
 		;
 
-	if (!(NCR5380_read(BUS_AND_STATUS_REG) & BASR_END_DMA_TRANSFER))
-		printk(KERN_ERR "53C400r: no end dma signal\n");
-		
+	if (NCR5380_poll_politely(hostdata, BUS_AND_STATUS_REG,
+	                          BASR_END_DMA_TRANSFER, BASR_END_DMA_TRANSFER,
+	                          HZ / 64) < 0)
+		scmd_printk(KERN_ERR, hostdata->connected, "%s: End of DMA timeout (%d)\n",
+		            __func__, hostdata->pdma_residual);
+
 	return 0;
 }
 
@@ -571,10 +576,8 @@ static inline int generic_NCR5380_pwrite(struct NCR5380_hostdata *hostdata,
 	NCR5380_write(hostdata->c400_ctl_status, CSR_BASE);
 	NCR5380_write(hostdata->c400_blk_cnt, blocks);
 	while (1) {
-		if (NCR5380_read(hostdata->c400_ctl_status) & CSR_GATED_53C80_IRQ) {
-			printk(KERN_ERR "53C400w: Got 53C80_IRQ start=%d, blocks=%d\n", start, blocks);
-			return -1;
-		}
+		if (NCR5380_read(hostdata->c400_ctl_status) & CSR_GATED_53C80_IRQ)
+			goto out_wait;
 
 		if (NCR5380_read(hostdata->c400_blk_cnt) == 0)
 			break;
@@ -612,18 +615,24 @@ static inline int generic_NCR5380_pwrite(struct NCR5380_hostdata *hostdata,
 		blocks--;
 	}
 
+out_wait:
+	hostdata->pdma_residual = len - start;
+
 	/* wait for 53C80 registers to be available */
 	while (!(NCR5380_read(hostdata->c400_ctl_status) & CSR_53C80_REG)) {
 		udelay(4); /* DTC436 chip hangs without this */
 		/* FIXME - no timeout */
 	}
 
-	if (!(NCR5380_read(BUS_AND_STATUS_REG) & BASR_END_DMA_TRANSFER)) {
-		printk(KERN_ERR "53C400w: no end dma signal\n");
-	}
-
 	while (!(NCR5380_read(TARGET_COMMAND_REG) & TCR_LAST_BYTE_SENT))
 		; 	// TIMEOUT
+
+	if (NCR5380_poll_politely(hostdata, BUS_AND_STATUS_REG,
+	                          BASR_END_DMA_TRANSFER, BASR_END_DMA_TRANSFER,
+	                          HZ / 64) < 0)
+		scmd_printk(KERN_ERR, hostdata->connected, "%s: End of DMA timeout (%d)\n",
+		            __func__, hostdata->pdma_residual);
+
 	return 0;
 }
 
@@ -642,6 +651,11 @@ static int generic_NCR5380_dma_xfer_len(struct NCR5380_hostdata *hostdata,
 	return min(transfersize, DMA_MAX_SIZE);
 }
 
+static int generic_NCR5380_dma_residual(struct NCR5380_hostdata *hostdata)
+{
+	return hostdata->pdma_residual;
+}
+
 /*
  *	Include the NCR5380 core code that we build our driver around	
  */

commit 12b859b70661c5b7d0c37c33f03736b768552e35
Author: Ondrej Zary <linux@rainbow-software.org>
Date:   Mon Jul 3 03:59:05 2017 -0400

    scsi: g_NCR5380: Fix PDMA transfer size
    
    generic_NCR5380_dma_xfer_len() incorrectly uses cmd->transfersize which
    causes rescan-scsi-bus and CD-ROM access to hang the system.  Use
    cmd->SCp.this_residual instead, like other NCR5380 drivers.
    
    Signed-off-by: Ondrej Zary <linux@rainbow-software.org>
    Signed-off-by: Finn Thain <fthain@telegraphics.com.au>
    Tested-by: Ondrej Zary <linux@rainbow-software.org>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/g_NCR5380.c b/drivers/scsi/g_NCR5380.c
index c34fc91ba486..fbb28ed0fce8 100644
--- a/drivers/scsi/g_NCR5380.c
+++ b/drivers/scsi/g_NCR5380.c
@@ -76,6 +76,7 @@
 #define IRQ_AUTO 254
 
 #define MAX_CARDS 8
+#define DMA_MAX_SIZE 32768
 
 /* old-style parameters for compatibility */
 static int ncr_irq = -1;
@@ -629,23 +630,16 @@ static inline int generic_NCR5380_pwrite(struct NCR5380_hostdata *hostdata,
 static int generic_NCR5380_dma_xfer_len(struct NCR5380_hostdata *hostdata,
                                         struct scsi_cmnd *cmd)
 {
-	int transfersize = cmd->transfersize;
+	int transfersize = cmd->SCp.this_residual;
 
 	if (hostdata->flags & FLAG_NO_PSEUDO_DMA)
 		return 0;
 
-	/* Limit transfers to 32K, for xx400 & xx406
-	 * pseudoDMA that transfers in 128 bytes blocks.
-	 */
-	if (transfersize > 32 * 1024 && cmd->SCp.this_residual &&
-	    !(cmd->SCp.this_residual % transfersize))
-		transfersize = 32 * 1024;
-
 	/* 53C400 datasheet: non-modulo-128-byte transfers should use PIO */
 	if (transfersize % 128)
 		transfersize = 0;
 
-	return transfersize;
+	return min(transfersize, DMA_MAX_SIZE);
 }
 
 /*

commit 88f06b76e462119cb694c3ff13d7d343c49d2569
Author: David Howells <dhowells@redhat.com>
Date:   Tue Apr 4 16:54:27 2017 +0100

    Annotate hardware config module parameters in drivers/scsi/
    
    When the kernel is running in secure boot mode, we lock down the kernel to
    prevent userspace from modifying the running kernel image.  Whilst this
    includes prohibiting access to things like /dev/mem, it must also prevent
    access by means of configuring driver modules in such a way as to cause a
    device to access or modify the kernel image.
    
    To this end, annotate module_param* statements that refer to hardware
    configuration and indicate for future reference what type of parameter they
    specify.  The parameter parser in the core sees this information and can
    skip such parameters with an error message if the kernel is locked down.
    The module initialisation then runs as normal, but just sees whatever the
    default values for those parameters is.
    
    Note that we do still need to do the module initialisation because some
    drivers have viable defaults set in case parameters aren't specified and
    some drivers support automatic configuration (e.g. PNP or PCI) in addition
    to manually coded parameters.
    
    This patch annotates drivers in drivers/scsi/.
    
    Suggested-by: Alan Cox <gnomes@lxorguk.ukuu.org.uk>
    Signed-off-by: David Howells <dhowells@redhat.com>
    cc: "Juergen E. Fischer" <fischer@norbit.de>
    cc: "James E.J. Bottomley" <jejb@linux.vnet.ibm.com>
    cc: "Martin K. Petersen" <martin.petersen@oracle.com>
    cc: Dario Ballabio <ballabio_dario@emc.com>
    cc: Finn Thain <fthain@telegraphics.com.au>
    cc: Michael Schmitz <schmitzmic@gmail.com>
    cc: Achim Leubner <achim_leubner@adaptec.com>
    cc: linux-scsi@vger.kernel.org

diff --git a/drivers/scsi/g_NCR5380.c b/drivers/scsi/g_NCR5380.c
index 67c8dac321ad..c34fc91ba486 100644
--- a/drivers/scsi/g_NCR5380.c
+++ b/drivers/scsi/g_NCR5380.c
@@ -85,8 +85,8 @@ static int ncr_53c400;
 static int ncr_53c400a;
 static int dtc_3181e;
 static int hp_c2502;
-module_param(ncr_irq, int, 0);
-module_param(ncr_addr, int, 0);
+module_param_hw(ncr_irq, int, irq, 0);
+module_param_hw(ncr_addr, int, ioport, 0);
 module_param(ncr_5380, int, 0);
 module_param(ncr_53c400, int, 0);
 module_param(ncr_53c400a, int, 0);
@@ -94,11 +94,11 @@ module_param(dtc_3181e, int, 0);
 module_param(hp_c2502, int, 0);
 
 static int irq[] = { -1, -1, -1, -1, -1, -1, -1, -1 };
-module_param_array(irq, int, NULL, 0);
+module_param_hw_array(irq, int, irq, NULL, 0);
 MODULE_PARM_DESC(irq, "IRQ number(s) (0=none, 254=auto [default])");
 
 static int base[] = { 0, 0, 0, 0, 0, 0, 0, 0 };
-module_param_array(base, int, NULL, 0);
+module_param_hw_array(base, int, ioport, NULL, 0);
 MODULE_PARM_DESC(base, "base address(es)");
 
 static int card[] = { -1, -1, -1, -1, -1, -1, -1, -1 };

commit 14d739f640d894b4b5db1ab3e1df17b865825a42
Author: Finn Thain <fthain@telegraphics.com.au>
Date:   Sun Jan 15 18:50:57 2017 -0500

    scsi: ncr5380: Reduce #include files
    
    The NCR5380 wrapper drivers don't export symbols or declarations and
    don't actually need separate header files. Most of these header files
    were removed already; only sun3_scsi.h and g_NCR5380.h remain.
    
    Move the remaining definitions to the corresponding .c files to improve
    readability and proximity. The #defines which influence the #included
    core driver are no longer mixed up with unrelated #defines and #includes.
    
    Signed-off-by: Finn Thain <fthain@telegraphics.com.au>
    Tested-by: Ondrej Zary <linux@rainbow-software.org>
    Tested-by: Michael Schmitz <schmitzmic@gmail.com>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/g_NCR5380.c b/drivers/scsi/g_NCR5380.c
index 6f9665d50d84..67c8dac321ad 100644
--- a/drivers/scsi/g_NCR5380.c
+++ b/drivers/scsi/g_NCR5380.c
@@ -26,14 +26,55 @@
 #include <linux/blkdev.h>
 #include <linux/module.h>
 #include <scsi/scsi_host.h>
-#include "g_NCR5380.h"
-#include "NCR5380.h"
 #include <linux/init.h>
 #include <linux/ioport.h>
 #include <linux/isa.h>
 #include <linux/pnp.h>
 #include <linux/interrupt.h>
 
+/* Definitions for the core NCR5380 driver. */
+
+#define NCR5380_read(reg) \
+	ioread8(hostdata->io + hostdata->offset + (reg))
+#define NCR5380_write(reg, value) \
+	iowrite8(value, hostdata->io + hostdata->offset + (reg))
+
+#define NCR5380_implementation_fields \
+	int offset; \
+	int c400_ctl_status; \
+	int c400_blk_cnt; \
+	int c400_host_buf; \
+	int io_width
+
+#define NCR5380_dma_xfer_len            generic_NCR5380_dma_xfer_len
+#define NCR5380_dma_recv_setup          generic_NCR5380_pread
+#define NCR5380_dma_send_setup          generic_NCR5380_pwrite
+#define NCR5380_dma_residual            NCR5380_dma_residual_none
+
+#define NCR5380_intr                    generic_NCR5380_intr
+#define NCR5380_queue_command           generic_NCR5380_queue_command
+#define NCR5380_abort                   generic_NCR5380_abort
+#define NCR5380_bus_reset               generic_NCR5380_bus_reset
+#define NCR5380_info                    generic_NCR5380_info
+
+#define NCR5380_io_delay(x)             udelay(x)
+
+#include "NCR5380.h"
+
+#define DRV_MODULE_NAME "g_NCR5380"
+
+#define NCR53C400_mem_base 0x3880
+#define NCR53C400_host_buffer 0x3900
+#define NCR53C400_region_size 0x3a00
+
+#define BOARD_NCR5380 0
+#define BOARD_NCR53C400 1
+#define BOARD_NCR53C400A 2
+#define BOARD_DTC3181E 3
+#define BOARD_HP_C2502 4
+
+#define IRQ_AUTO 254
+
 #define MAX_CARDS 8
 
 /* old-style parameters for compatibility */

commit 70439e93345ec5605f1cb3fa7a8f70bc968e6cb2
Author: Finn Thain <fthain@telegraphics.com.au>
Date:   Mon Dec 5 01:07:20 2016 -0500

    scsi: g_NCR5380: Autoprobe board IRQ by default
    
    Automatically probe the board irq when no irq parameter is provided, to
    simulate PnP. The old default behaviour was to disable the irq.
    
    Update driver documentation accordingly and add some printk messages to
    make this behaviour visible.
    
    Signed-off-by: Finn Thain <fthain@telegraphics.com.au>
    Tested-by: Ondrej Zary <linux@rainbow-software.org>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/g_NCR5380.c b/drivers/scsi/g_NCR5380.c
index 58a0b826eb51..6f9665d50d84 100644
--- a/drivers/scsi/g_NCR5380.c
+++ b/drivers/scsi/g_NCR5380.c
@@ -37,7 +37,7 @@
 #define MAX_CARDS 8
 
 /* old-style parameters for compatibility */
-static int ncr_irq;
+static int ncr_irq = -1;
 static int ncr_addr;
 static int ncr_5380;
 static int ncr_53c400;
@@ -52,9 +52,9 @@ module_param(ncr_53c400a, int, 0);
 module_param(dtc_3181e, int, 0);
 module_param(hp_c2502, int, 0);
 
-static int irq[] = { 0, 0, 0, 0, 0, 0, 0, 0 };
+static int irq[] = { -1, -1, -1, -1, -1, -1, -1, -1 };
 module_param_array(irq, int, NULL, 0);
-MODULE_PARM_DESC(irq, "IRQ number(s)");
+MODULE_PARM_DESC(irq, "IRQ number(s) (0=none, 254=auto [default])");
 
 static int base[] = { 0, 0, 0, 0, 0, 0, 0, 0 };
 module_param_array(base, int, NULL, 0);
@@ -344,6 +344,8 @@ static int generic_NCR5380_init_one(struct scsi_host_template *tpnt,
 	/* Compatibility with documented NCR5380 kernel parameters */
 	if (irq == 255 || irq == 0)
 		irq = NO_IRQ;
+	else if (irq == -1)
+		irq = IRQ_AUTO;
 
 	if (board == BOARD_HP_C2502) {
 		int *irq_table = hp_c2502_irqs;
@@ -370,24 +372,28 @@ static int generic_NCR5380_init_one(struct scsi_host_template *tpnt,
 		magic_configure(port_idx, board_irq, magic);
 	}
 
-	if (irq == IRQ_AUTO)
+	if (irq == IRQ_AUTO) {
 		instance->irq = g_NCR5380_probe_irq(instance);
-	else
+		if (instance->irq == NO_IRQ)
+			shost_printk(KERN_INFO, instance, "no irq detected\n");
+	} else {
 		instance->irq = irq;
+		if (instance->irq == NO_IRQ)
+			shost_printk(KERN_INFO, instance, "no irq provided\n");
+	}
 
 	if (instance->irq != NO_IRQ) {
 		if (request_irq(instance->irq, generic_NCR5380_intr,
 				0, "NCR5380", instance)) {
-			printk(KERN_WARNING "scsi%d : IRQ%d not free, interrupts disabled\n", instance->host_no, instance->irq);
 			instance->irq = NO_IRQ;
+			shost_printk(KERN_INFO, instance,
+			             "irq %d denied\n", instance->irq);
+		} else {
+			shost_printk(KERN_INFO, instance,
+			             "irq %d acquired\n", instance->irq);
 		}
 	}
 
-	if (instance->irq == NO_IRQ) {
-		printk(KERN_INFO "scsi%d : interrupts not enabled. for better interactive performance,\n", instance->host_no);
-		printk(KERN_INFO "scsi%d : please jumper the board for a free IRQ.\n", instance->host_no);
-	}
-
 	ret = scsi_add_host(instance, pdev);
 	if (ret)
 		goto out_free_irq;
@@ -698,7 +704,7 @@ static int __init generic_NCR5380_init(void)
 	int ret = 0;
 
 	/* compatibility with old-style parameters */
-	if (irq[0] == 0 && base[0] == 0 && card[0] == -1) {
+	if (irq[0] == -1 && base[0] == 0 && card[0] == -1) {
 		irq[0] = ncr_irq;
 		base[0] = ncr_addr;
 		if (ncr_5380)

commit 145c3ae4c1933d0dceb11d19a36de3458d1872cb
Author: Finn Thain <fthain@telegraphics.com.au>
Date:   Mon Dec 5 01:07:20 2016 -0500

    scsi: g_NCR5380: Fix automatic IRQ on HP C2502 cards
    
    When IRQ_AUTO is used, the interrupt for HP C2502 cards gets disabled.
    Fix this by programming the card for a suitable free irq. The code for
    the free irq search comes from ALSA.
    
    Also allow IRQ 9 to work (it aliases to IRQ 2 on the card), as per
    Ondrej Zary's patch.
    
    Suggested-by: Ondrej Zary <linux@rainbow-software.org>
    Signed-off-by: Finn Thain <fthain@telegraphics.com.au>
    Tested-by: Ondrej Zary <linux@rainbow-software.org>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/g_NCR5380.c b/drivers/scsi/g_NCR5380.c
index 6d245a7b9363..58a0b826eb51 100644
--- a/drivers/scsi/g_NCR5380.c
+++ b/drivers/scsi/g_NCR5380.c
@@ -131,14 +131,33 @@ static void magic_configure(int idx, u8 irq, u8 magic[])
 	outb(magic[3], 0x379);
 	outb(magic[4], 0x379);
 
-	/* allowed IRQs for HP C2502 */
-	if (irq != 2 && irq != 3 && irq != 4 && irq != 5 && irq != 7)
-		irq = 0;
+	if (irq == 9)
+		irq = 2;
+
 	if (idx >= 0 && idx <= 7)
 		cfg = 0x80 | idx | (irq << 4);
 	outb(cfg, 0x379);
 }
 
+static irqreturn_t legacy_empty_irq_handler(int irq, void *dev_id)
+{
+	return IRQ_HANDLED;
+}
+
+static int legacy_find_free_irq(int *irq_table)
+{
+	while (*irq_table != -1) {
+		if (!request_irq(*irq_table, legacy_empty_irq_handler,
+		                 IRQF_PROBE_SHARED, "Test IRQ",
+		                 (void *)irq_table)) {
+			free_irq(*irq_table, (void *) irq_table);
+			return *irq_table;
+		}
+		irq_table++;
+	}
+	return -1;
+}
+
 static unsigned int ncr_53c400a_ports[] = {
 	0x280, 0x290, 0x300, 0x310, 0x330, 0x340, 0x348, 0x350, 0
 };
@@ -151,6 +170,9 @@ static u8 ncr_53c400a_magic[] = {	/* 53C400A & DTC436 */
 static u8 hp_c2502_magic[] = {	/* HP C2502 */
 	0x0f, 0x22, 0xf0, 0x20, 0x80
 };
+static int hp_c2502_irqs[] = {
+	9, 5, 7, 3, 4, -1
+};
 
 static int generic_NCR5380_init_one(struct scsi_host_template *tpnt,
 			struct device *pdev, int base, int irq, int board)
@@ -319,19 +341,41 @@ static int generic_NCR5380_init_one(struct scsi_host_template *tpnt,
 
 	NCR5380_maybe_reset_bus(instance);
 
-	if (irq != IRQ_AUTO)
-		instance->irq = irq;
-	else
-		instance->irq = g_NCR5380_probe_irq(instance);
-
 	/* Compatibility with documented NCR5380 kernel parameters */
-	if (instance->irq == 255)
-		instance->irq = NO_IRQ;
+	if (irq == 255 || irq == 0)
+		irq = NO_IRQ;
+
+	if (board == BOARD_HP_C2502) {
+		int *irq_table = hp_c2502_irqs;
+		int board_irq = -1;
+
+		switch (irq) {
+		case NO_IRQ:
+			board_irq = 0;
+			break;
+		case IRQ_AUTO:
+			board_irq = legacy_find_free_irq(irq_table);
+			break;
+		default:
+			while (*irq_table != -1)
+				if (*irq_table++ == irq)
+					board_irq = irq;
+		}
+
+		if (board_irq <= 0) {
+			board_irq = 0;
+			irq = NO_IRQ;
+		}
+
+		magic_configure(port_idx, board_irq, magic);
+	}
+
+	if (irq == IRQ_AUTO)
+		instance->irq = g_NCR5380_probe_irq(instance);
+	else
+		instance->irq = irq;
 
 	if (instance->irq != NO_IRQ) {
-		/* set IRQ for HP C2502 */
-		if (board == BOARD_HP_C2502)
-			magic_configure(port_idx, instance->irq, magic);
 		if (request_irq(instance->irq, generic_NCR5380_intr,
 				0, "NCR5380", instance)) {
 			printk(KERN_WARNING "scsi%d : IRQ%d not free, interrupts disabled\n", instance->host_no, instance->irq);

commit 906e4a3c7e03701008d343daec8952d6cf49f82b
Author: Ondrej Zary <linux@rainbow-software.org>
Date:   Mon Dec 5 01:07:20 2016 -0500

    scsi: g_NCR5380: Use probe_irq_*() for IRQ probing
    
    Use standard probe_irq_on() and probe_irq_off() functions instead of own
    implementation.  This prevents warning messages like this in the kernel
    log: genirq: Flags mismatch irq 1. 00000000 (NCR-probe) vs. 00000080
    (i8042)
    
    Move the IRQ trigger code from NCR5380 to g_NCR5380 where it is used.
    
    Also clear interrupt flag before and after the probe.
    
    Signed-off-by: Ondrej Zary <linux@rainbow-software.org>
    Signed-off-by: Finn Thain <fthain@telegraphics.com.au>
    Tested-by: Ondrej Zary <linux@rainbow-software.org>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/g_NCR5380.c b/drivers/scsi/g_NCR5380.c
index 76e37455480e..6d245a7b9363 100644
--- a/drivers/scsi/g_NCR5380.c
+++ b/drivers/scsi/g_NCR5380.c
@@ -67,6 +67,56 @@ MODULE_PARM_DESC(card, "card type (0=NCR5380, 1=NCR53C400, 2=NCR53C400A, 3=DTC31
 MODULE_ALIAS("g_NCR5380_mmio");
 MODULE_LICENSE("GPL");
 
+static void g_NCR5380_trigger_irq(struct Scsi_Host *instance)
+{
+	struct NCR5380_hostdata *hostdata = shost_priv(instance);
+
+	/*
+	 * An interrupt is triggered whenever BSY = false, SEL = true
+	 * and a bit set in the SELECT_ENABLE_REG is asserted on the
+	 * SCSI bus.
+	 *
+	 * Note that the bus is only driven when the phase control signals
+	 * (I/O, C/D, and MSG) match those in the TCR.
+	 */
+	NCR5380_write(TARGET_COMMAND_REG,
+	              PHASE_SR_TO_TCR(NCR5380_read(STATUS_REG) & PHASE_MASK));
+	NCR5380_write(SELECT_ENABLE_REG, hostdata->id_mask);
+	NCR5380_write(OUTPUT_DATA_REG, hostdata->id_mask);
+	NCR5380_write(INITIATOR_COMMAND_REG,
+	              ICR_BASE | ICR_ASSERT_DATA | ICR_ASSERT_SEL);
+
+	msleep(1);
+
+	NCR5380_write(INITIATOR_COMMAND_REG, ICR_BASE);
+	NCR5380_write(SELECT_ENABLE_REG, 0);
+	NCR5380_write(TARGET_COMMAND_REG, 0);
+}
+
+/**
+ * g_NCR5380_probe_irq - find the IRQ of a NCR5380 or equivalent
+ * @instance: SCSI host instance
+ *
+ * Autoprobe for the IRQ line used by the card by triggering an IRQ
+ * and then looking to see what interrupt actually turned up.
+ */
+
+static int g_NCR5380_probe_irq(struct Scsi_Host *instance)
+{
+	struct NCR5380_hostdata *hostdata = shost_priv(instance);
+	int irq_mask, irq;
+
+	NCR5380_read(RESET_PARITY_INTERRUPT_REG);
+	irq_mask = probe_irq_on();
+	g_NCR5380_trigger_irq(instance);
+	irq = probe_irq_off(irq_mask);
+	NCR5380_read(RESET_PARITY_INTERRUPT_REG);
+
+	if (irq <= 0)
+		return NO_IRQ;
+	return irq;
+}
+
 /*
  * Configure I/O address of 53C400A or DTC436 by writing magic numbers
  * to ports 0x779 and 0x379.
@@ -272,7 +322,7 @@ static int generic_NCR5380_init_one(struct scsi_host_template *tpnt,
 	if (irq != IRQ_AUTO)
 		instance->irq = irq;
 	else
-		instance->irq = NCR5380_probe_irq(instance, 0xffff);
+		instance->irq = g_NCR5380_probe_irq(instance);
 
 	/* Compatibility with documented NCR5380 kernel parameters */
 	if (instance->irq == 255)

commit 89fa9b5cb08c9d8ad709415b88395be463eceeee
Author: Ondrej Zary <linux@rainbow-software.org>
Date:   Mon Dec 5 01:07:19 2016 -0500

    scsi: g_NCR5380: Check for chip presence before calling NCR5380_init()
    
    Write and read back mode register to check that a chip is really there.
    If no card is present, reads result in 0xff.
    
    Signed-off-by: Ondrej Zary <linux@rainbow-software.org>
    Signed-off-by: Finn Thain <fthain@telegraphics.com.au>
    Tested-by: Ondrej Zary <linux@rainbow-software.org>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/g_NCR5380.c b/drivers/scsi/g_NCR5380.c
index de5147a8c959..76e37455480e 100644
--- a/drivers/scsi/g_NCR5380.c
+++ b/drivers/scsi/g_NCR5380.c
@@ -248,6 +248,13 @@ static int generic_NCR5380_init_one(struct scsi_host_template *tpnt,
 		}
 	}
 
+	/* Check for vacant slot */
+	NCR5380_write(MODE_REG, 0);
+	if (NCR5380_read(MODE_REG) != 0) {
+		ret = -ENODEV;
+		goto out_unregister;
+	}
+
 	ret = NCR5380_init(instance, flags | FLAG_LATE_DMA_SETUP);
 	if (ret)
 		goto out_unregister;

commit 7b93ca43b7e21fbe6fb1a6f4ecce4a2f70f424a0
Author: Ondrej Zary <linux@rainbow-software.org>
Date:   Fri Nov 11 10:00:20 2016 +1100

    scsi: g_NCR5380: Fix release_region in error handling
    
    When a SW-configurable card is specified but not found, the driver
    releases wrong region, causing the following message in kernel log:
    Trying to free nonexistent resource <0000000000000000-000000000000000f>
    
    Fix it by assigning base earlier.
    
    Signed-off-by: Ondrej Zary <linux@rainbow-software.org>
    Fixes: a8cfbcaec0c1 ("scsi: g_NCR5380: Stop using scsi_module.c")
    Signed-off-by: Finn Thain <fthain@telegraphics.com.au>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/g_NCR5380.c b/drivers/scsi/g_NCR5380.c
index 7299ad9889c9..de5147a8c959 100644
--- a/drivers/scsi/g_NCR5380.c
+++ b/drivers/scsi/g_NCR5380.c
@@ -164,12 +164,12 @@ static int generic_NCR5380_init_one(struct scsi_host_template *tpnt,
 		if (ports[i]) {
 			/* At this point we have our region reserved */
 			magic_configure(i, 0, magic); /* no IRQ yet */
-			outb(0xc0, ports[i] + 9);
-			if (inb(ports[i] + 9) != 0x80) {
+			base = ports[i];
+			outb(0xc0, base + 9);
+			if (inb(base + 9) != 0x80) {
 				ret = -ENODEV;
 				goto out_release;
 			}
-			base = ports[i];
 			port_idx = i;
 		} else
 			return -EINVAL;

commit 4a98f896bf2c66a69517fc5e10dc67288cb8da93
Author: Finn Thain <fthain@telegraphics.com.au>
Date:   Mon Oct 10 00:46:53 2016 -0400

    scsi: ncr5380: Use correct types for DMA routines
    
    Apply prototypes to get consistent function signatures for the DMA
    functions implemented in the board-specific drivers. To avoid using
    macros to alter actual parameters, some of those functions are reworked
    slightly.
    
    This is a step toward the goal of passing the board-specific routines
    to the core driver using an ops struct (as in a platform driver or
    library module).
    
    This also helps fix some inconsistent types: where the core driver uses
    ints (cmd->SCp.this_residual and hostdata->dma_len) for keeping track of
    transfers, certain board-specific routines used unsigned long.
    
    While we are fixing these function signatures, pass the hostdata pointer
    to DMA routines instead of a Scsi_Host pointer, for shorter and faster
    code.
    
    Signed-off-by: Finn Thain <fthain@telegraphics.com.au>
    Reviewed-by: Hannes Reinecke <hare@suse.com>
    Tested-by: Ondrej Zary <linux@rainbow-software.org>
    Tested-by: Michael Schmitz <schmitzmic@gmail.com>
    Acked-by: Russell King <rmk+kernel@armlinux.org.uk>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/g_NCR5380.c b/drivers/scsi/g_NCR5380.c
index 98aef0eb8b59..7299ad9889c9 100644
--- a/drivers/scsi/g_NCR5380.c
+++ b/drivers/scsi/g_NCR5380.c
@@ -332,7 +332,7 @@ static void generic_NCR5380_release_resources(struct Scsi_Host *instance)
 
 /**
  *	generic_NCR5380_pread - pseudo DMA read
- *	@instance: adapter to read from
+ *	@hostdata: scsi host private data
  *	@dst: buffer to read into
  *	@len: buffer length
  *
@@ -340,10 +340,9 @@ static void generic_NCR5380_release_resources(struct Scsi_Host *instance)
  *	controller
  */
  
-static inline int generic_NCR5380_pread(struct Scsi_Host *instance,
+static inline int generic_NCR5380_pread(struct NCR5380_hostdata *hostdata,
                                         unsigned char *dst, int len)
 {
-	struct NCR5380_hostdata *hostdata = shost_priv(instance);
 	int blocks = len / 128;
 	int start = 0;
 
@@ -406,7 +405,7 @@ static inline int generic_NCR5380_pread(struct Scsi_Host *instance,
 
 /**
  *	generic_NCR5380_pwrite - pseudo DMA write
- *	@instance: adapter to read from
+ *	@hostdata: scsi host private data
  *	@dst: buffer to read into
  *	@len: buffer length
  *
@@ -414,10 +413,9 @@ static inline int generic_NCR5380_pread(struct Scsi_Host *instance,
  *	controller
  */
 
-static inline int generic_NCR5380_pwrite(struct Scsi_Host *instance,
+static inline int generic_NCR5380_pwrite(struct NCR5380_hostdata *hostdata,
                                          unsigned char *src, int len)
 {
-	struct NCR5380_hostdata *hostdata = shost_priv(instance);
 	int blocks = len / 128;
 	int start = 0;
 
@@ -480,10 +478,9 @@ static inline int generic_NCR5380_pwrite(struct Scsi_Host *instance,
 	return 0;
 }
 
-static int generic_NCR5380_dma_xfer_len(struct Scsi_Host *instance,
+static int generic_NCR5380_dma_xfer_len(struct NCR5380_hostdata *hostdata,
                                         struct scsi_cmnd *cmd)
 {
-	struct NCR5380_hostdata *hostdata = shost_priv(instance);
 	int transfersize = cmd->transfersize;
 
 	if (hostdata->flags & FLAG_NO_PSEUDO_DMA)

commit 820682b1b34ebb97434c4abc00c744870364e2be
Author: Finn Thain <fthain@telegraphics.com.au>
Date:   Mon Oct 10 00:46:53 2016 -0400

    scsi: ncr5380: Store IO ports and addresses in host private data
    
    The various 5380 drivers inconsistently store register pointers
    either in the Scsi_Host struct "legacy crap" area or in special,
    board-specific members of the NCR5380_hostdata struct. Uniform
    use of the latter struct makes for simpler and faster code (see
    the following patches) and helps to reduce use of the
    NCR5380_implementation_fields macro.
    
    Signed-off-by: Finn Thain <fthain@telegraphics.com.au>
    Reviewed-by: Hannes Reinecke <hare@suse.com>
    Tested-by: Ondrej Zary <linux@rainbow-software.org>
    Tested-by: Michael Schmitz <schmitzmic@gmail.com>
    Acked-by: Russell King <rmk+kernel@armlinux.org.uk>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/g_NCR5380.c b/drivers/scsi/g_NCR5380.c
index 4d7a9de01645..98aef0eb8b59 100644
--- a/drivers/scsi/g_NCR5380.c
+++ b/drivers/scsi/g_NCR5380.c
@@ -115,7 +115,7 @@ static int generic_NCR5380_init_one(struct scsi_host_template *tpnt,
 	unsigned long region_size;
 	struct Scsi_Host *instance;
 	struct NCR5380_hostdata *hostdata;
-	void __iomem *iomem;
+	u8 __iomem *iomem;
 
 	switch (board) {
 	case BOARD_NCR5380:
@@ -201,11 +201,11 @@ static int generic_NCR5380_init_one(struct scsi_host_template *tpnt,
 	}
 	hostdata = shost_priv(instance);
 
-	hostdata->iomem = iomem;
+	hostdata->io = iomem;
+	hostdata->region_size = region_size;
 
 	if (is_pmio) {
-		instance->io_port = base;
-		instance->n_io_port = region_size;
+		hostdata->io_port = base;
 		hostdata->io_width = 1; /* 8-bit PDMA by default */
 		hostdata->offset = 0;
 
@@ -215,7 +215,7 @@ static int generic_NCR5380_init_one(struct scsi_host_template *tpnt,
 		 */
 		switch (board) {
 		case BOARD_NCR53C400:
-			instance->io_port += 8;
+			hostdata->io_port += 8;
 			hostdata->c400_ctl_status = 0;
 			hostdata->c400_blk_cnt = 1;
 			hostdata->c400_host_buf = 4;
@@ -231,8 +231,7 @@ static int generic_NCR5380_init_one(struct scsi_host_template *tpnt,
 			break;
 		}
 	} else {
-		instance->base = base;
-		hostdata->iomem_size = region_size;
+		hostdata->base = base;
 		hostdata->offset = NCR53C400_mem_base;
 		switch (board) {
 		case BOARD_NCR53C400:
@@ -314,17 +313,21 @@ static int generic_NCR5380_init_one(struct scsi_host_template *tpnt,
 static void generic_NCR5380_release_resources(struct Scsi_Host *instance)
 {
 	struct NCR5380_hostdata *hostdata = shost_priv(instance);
+	void __iomem *iomem = hostdata->io;
+	unsigned long io_port = hostdata->io_port;
+	unsigned long base = hostdata->base;
+	unsigned long region_size = hostdata->region_size;
 
 	scsi_remove_host(instance);
 	if (instance->irq != NO_IRQ)
 		free_irq(instance->irq, instance);
 	NCR5380_exit(instance);
-	iounmap(hostdata->iomem);
-	if (instance->io_port)
-		release_region(instance->io_port, instance->n_io_port);
-	else
-		release_mem_region(instance->base, hostdata->iomem_size);
 	scsi_host_put(instance);
+	iounmap(iomem);
+	if (io_port)
+		release_region(io_port, region_size);
+	else
+		release_mem_region(base, region_size);
 }
 
 /**
@@ -356,15 +359,15 @@ static inline int generic_NCR5380_pread(struct Scsi_Host *instance,
 		while (NCR5380_read(hostdata->c400_ctl_status) & CSR_HOST_BUF_NOT_RDY)
 			; /* FIXME - no timeout */
 
-		if (instance->io_port && hostdata->io_width == 2)
-			insw(instance->io_port + hostdata->c400_host_buf,
+		if (hostdata->io_port && hostdata->io_width == 2)
+			insw(hostdata->io_port + hostdata->c400_host_buf,
 							dst + start, 64);
-		else if (instance->io_port)
-			insb(instance->io_port + hostdata->c400_host_buf,
+		else if (hostdata->io_port)
+			insb(hostdata->io_port + hostdata->c400_host_buf,
 							dst + start, 128);
 		else
 			memcpy_fromio(dst + start,
-				hostdata->iomem + NCR53C400_host_buffer, 128);
+				hostdata->io + NCR53C400_host_buffer, 128);
 
 		start += 128;
 		blocks--;
@@ -374,15 +377,15 @@ static inline int generic_NCR5380_pread(struct Scsi_Host *instance,
 		while (NCR5380_read(hostdata->c400_ctl_status) & CSR_HOST_BUF_NOT_RDY)
 			; /* FIXME - no timeout */
 
-		if (instance->io_port && hostdata->io_width == 2)
-			insw(instance->io_port + hostdata->c400_host_buf,
+		if (hostdata->io_port && hostdata->io_width == 2)
+			insw(hostdata->io_port + hostdata->c400_host_buf,
 							dst + start, 64);
-		else if (instance->io_port)
-			insb(instance->io_port + hostdata->c400_host_buf,
+		else if (hostdata->io_port)
+			insb(hostdata->io_port + hostdata->c400_host_buf,
 							dst + start, 128);
 		else
 			memcpy_fromio(dst + start,
-				hostdata->iomem + NCR53C400_host_buffer, 128);
+				hostdata->io + NCR53C400_host_buffer, 128);
 
 		start += 128;
 		blocks--;
@@ -431,14 +434,14 @@ static inline int generic_NCR5380_pwrite(struct Scsi_Host *instance,
 		while (NCR5380_read(hostdata->c400_ctl_status) & CSR_HOST_BUF_NOT_RDY)
 			; // FIXME - timeout
 
-		if (instance->io_port && hostdata->io_width == 2)
-			outsw(instance->io_port + hostdata->c400_host_buf,
+		if (hostdata->io_port && hostdata->io_width == 2)
+			outsw(hostdata->io_port + hostdata->c400_host_buf,
 							src + start, 64);
-		else if (instance->io_port)
-			outsb(instance->io_port + hostdata->c400_host_buf,
+		else if (hostdata->io_port)
+			outsb(hostdata->io_port + hostdata->c400_host_buf,
 							src + start, 128);
 		else
-			memcpy_toio(hostdata->iomem + NCR53C400_host_buffer,
+			memcpy_toio(hostdata->io + NCR53C400_host_buffer,
 			            src + start, 128);
 
 		start += 128;
@@ -448,14 +451,14 @@ static inline int generic_NCR5380_pwrite(struct Scsi_Host *instance,
 		while (NCR5380_read(hostdata->c400_ctl_status) & CSR_HOST_BUF_NOT_RDY)
 			; // FIXME - no timeout
 
-		if (instance->io_port && hostdata->io_width == 2)
-			outsw(instance->io_port + hostdata->c400_host_buf,
+		if (hostdata->io_port && hostdata->io_width == 2)
+			outsw(hostdata->io_port + hostdata->c400_host_buf,
 							src + start, 64);
-		else if (instance->io_port)
-			outsb(instance->io_port + hostdata->c400_host_buf,
+		else if (hostdata->io_port)
+			outsb(hostdata->io_port + hostdata->c400_host_buf,
 							src + start, 128);
 		else
-			memcpy_toio(hostdata->iomem + NCR53C400_host_buffer,
+			memcpy_toio(hostdata->io + NCR53C400_host_buffer,
 			            src + start, 128);
 
 		start += 128;

commit b61bacbc2bf5df11f227bd9bd97b3bace4dc9108
Author: Ondrej Zary <linux@rainbow-software.org>
Date:   Mon Oct 10 00:46:52 2016 -0400

    scsi: g_NCR5380: Merge g_NCR5380 and g_NCR5380_mmio drivers
    
    Merge the port-mapped IO and memory-mapped IO support (with the help of
    ioport_map) into the g_NCR5380 module and delete g_NCR5380_mmio.
    
    Signed-off-by: Ondrej Zary <linux@rainbow-software.org>
    Signed-off-by: Finn Thain <fthain@telegraphics.com.au>
    Reviewed-by: Hannes Reinecke <hare@suse.com>
    Tested-by: Ondrej Zary <linux@rainbow-software.org>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/g_NCR5380.c b/drivers/scsi/g_NCR5380.c
index cbf010324c18..4d7a9de01645 100644
--- a/drivers/scsi/g_NCR5380.c
+++ b/drivers/scsi/g_NCR5380.c
@@ -64,9 +64,9 @@ static int card[] = { -1, -1, -1, -1, -1, -1, -1, -1 };
 module_param_array(card, int, NULL, 0);
 MODULE_PARM_DESC(card, "card type (0=NCR5380, 1=NCR53C400, 2=NCR53C400A, 3=DTC3181E, 4=HP C2502)");
 
+MODULE_ALIAS("g_NCR5380_mmio");
 MODULE_LICENSE("GPL");
 
-#ifndef SCSI_G_NCR5380_MEM
 /*
  * Configure I/O address of 53C400A or DTC436 by writing magic numbers
  * to ports 0x779 and 0x379.
@@ -88,40 +88,35 @@ static void magic_configure(int idx, u8 irq, u8 magic[])
 		cfg = 0x80 | idx | (irq << 4);
 	outb(cfg, 0x379);
 }
-#endif
+
+static unsigned int ncr_53c400a_ports[] = {
+	0x280, 0x290, 0x300, 0x310, 0x330, 0x340, 0x348, 0x350, 0
+};
+static unsigned int dtc_3181e_ports[] = {
+	0x220, 0x240, 0x280, 0x2a0, 0x2c0, 0x300, 0x320, 0x340, 0
+};
+static u8 ncr_53c400a_magic[] = {	/* 53C400A & DTC436 */
+	0x59, 0xb9, 0xc5, 0xae, 0xa6
+};
+static u8 hp_c2502_magic[] = {	/* HP C2502 */
+	0x0f, 0x22, 0xf0, 0x20, 0x80
+};
 
 static int generic_NCR5380_init_one(struct scsi_host_template *tpnt,
 			struct device *pdev, int base, int irq, int board)
 {
-	unsigned int *ports;
+	bool is_pmio = base <= 0xffff;
+	int ret;
+	int flags = 0;
+	unsigned int *ports = NULL;
 	u8 *magic = NULL;
-#ifndef SCSI_G_NCR5380_MEM
 	int i;
 	int port_idx = -1;
 	unsigned long region_size;
-#endif
-	static unsigned int ncr_53c400a_ports[] = {
-		0x280, 0x290, 0x300, 0x310, 0x330, 0x340, 0x348, 0x350, 0
-	};
-	static unsigned int dtc_3181e_ports[] = {
-		0x220, 0x240, 0x280, 0x2a0, 0x2c0, 0x300, 0x320, 0x340, 0
-	};
-	static u8 ncr_53c400a_magic[] = {	/* 53C400A & DTC436 */
-		0x59, 0xb9, 0xc5, 0xae, 0xa6
-	};
-	static u8 hp_c2502_magic[] = {	/* HP C2502 */
-		0x0f, 0x22, 0xf0, 0x20, 0x80
-	};
-	int flags, ret;
 	struct Scsi_Host *instance;
 	struct NCR5380_hostdata *hostdata;
-#ifdef SCSI_G_NCR5380_MEM
 	void __iomem *iomem;
-	resource_size_t iomem_size;
-#endif
 
-	ports = NULL;
-	flags = 0;
 	switch (board) {
 	case BOARD_NCR5380:
 		flags = FLAG_NO_PSEUDO_DMA | FLAG_DMA_FIXUP;
@@ -140,8 +135,7 @@ static int generic_NCR5380_init_one(struct scsi_host_template *tpnt,
 		break;
 	}
 
-#ifndef SCSI_G_NCR5380_MEM
-	if (ports && magic) {
+	if (is_pmio && ports && magic) {
 		/* wakeup sequence for the NCR53C400A and DTC3181E */
 
 		/* Disable the adapter and look for a free io port */
@@ -179,75 +173,81 @@ static int generic_NCR5380_init_one(struct scsi_host_template *tpnt,
 			port_idx = i;
 		} else
 			return -EINVAL;
-	}
-	else
-	{
+	} else if (is_pmio) {
 		/* NCR5380 - no configuration, just grab */
 		region_size = 8;
 		if (!base || !request_region(base, region_size, "ncr5380"))
 			return -EBUSY;
+	} else {	/* MMIO */
+		region_size = NCR53C400_region_size;
+		if (!request_mem_region(base, region_size, "ncr5380"))
+			return -EBUSY;
 	}
-#else
-	iomem_size = NCR53C400_region_size;
-	if (!request_mem_region(base, iomem_size, "ncr5380"))
-		return -EBUSY;
-	iomem = ioremap(base, iomem_size);
+
+	if (is_pmio)
+		iomem = ioport_map(base, region_size);
+	else
+		iomem = ioremap(base, region_size);
+
 	if (!iomem) {
-		release_mem_region(base, iomem_size);
-		return -ENOMEM;
+		ret = -ENOMEM;
+		goto out_release;
 	}
-#endif
+
 	instance = scsi_host_alloc(tpnt, sizeof(struct NCR5380_hostdata));
 	if (instance == NULL) {
 		ret = -ENOMEM;
-		goto out_release;
+		goto out_unmap;
 	}
 	hostdata = shost_priv(instance);
 
-#ifndef SCSI_G_NCR5380_MEM
-	instance->io_port = base;
-	instance->n_io_port = region_size;
-	hostdata->io_width = 1; /* 8-bit PDMA by default */
-
-	/*
-	 * On NCR53C400 boards, NCR5380 registers are mapped 8 past
-	 * the base address.
-	 */
-	switch (board) {
-	case BOARD_NCR53C400:
-		instance->io_port += 8;
-		hostdata->c400_ctl_status = 0;
-		hostdata->c400_blk_cnt = 1;
-		hostdata->c400_host_buf = 4;
-		break;
-	case BOARD_DTC3181E:
-		hostdata->io_width = 2;	/* 16-bit PDMA */
-		/* fall through */
-	case BOARD_NCR53C400A:
-	case BOARD_HP_C2502:
-		hostdata->c400_ctl_status = 9;
-		hostdata->c400_blk_cnt = 10;
-		hostdata->c400_host_buf = 8;
-		break;
-	}
-#else
-	instance->base = base;
 	hostdata->iomem = iomem;
-	hostdata->iomem_size = iomem_size;
-	switch (board) {
-	case BOARD_NCR53C400:
-		hostdata->c400_ctl_status = 0x100;
-		hostdata->c400_blk_cnt = 0x101;
-		hostdata->c400_host_buf = 0x104;
-		break;
-	case BOARD_DTC3181E:
-	case BOARD_NCR53C400A:
-	case BOARD_HP_C2502:
-		pr_err(DRV_MODULE_NAME ": unknown register offsets\n");
-		ret = -EINVAL;
-		goto out_unregister;
+
+	if (is_pmio) {
+		instance->io_port = base;
+		instance->n_io_port = region_size;
+		hostdata->io_width = 1; /* 8-bit PDMA by default */
+		hostdata->offset = 0;
+
+		/*
+		 * On NCR53C400 boards, NCR5380 registers are mapped 8 past
+		 * the base address.
+		 */
+		switch (board) {
+		case BOARD_NCR53C400:
+			instance->io_port += 8;
+			hostdata->c400_ctl_status = 0;
+			hostdata->c400_blk_cnt = 1;
+			hostdata->c400_host_buf = 4;
+			break;
+		case BOARD_DTC3181E:
+			hostdata->io_width = 2;	/* 16-bit PDMA */
+			/* fall through */
+		case BOARD_NCR53C400A:
+		case BOARD_HP_C2502:
+			hostdata->c400_ctl_status = 9;
+			hostdata->c400_blk_cnt = 10;
+			hostdata->c400_host_buf = 8;
+			break;
+		}
+	} else {
+		instance->base = base;
+		hostdata->iomem_size = region_size;
+		hostdata->offset = NCR53C400_mem_base;
+		switch (board) {
+		case BOARD_NCR53C400:
+			hostdata->c400_ctl_status = 0x100;
+			hostdata->c400_blk_cnt = 0x101;
+			hostdata->c400_host_buf = 0x104;
+			break;
+		case BOARD_DTC3181E:
+		case BOARD_NCR53C400A:
+		case BOARD_HP_C2502:
+			pr_err(DRV_MODULE_NAME ": unknown register offsets\n");
+			ret = -EINVAL;
+			goto out_unregister;
+		}
 	}
-#endif
 
 	ret = NCR5380_init(instance, flags | FLAG_LATE_DMA_SETUP);
 	if (ret)
@@ -273,11 +273,9 @@ static int generic_NCR5380_init_one(struct scsi_host_template *tpnt,
 		instance->irq = NO_IRQ;
 
 	if (instance->irq != NO_IRQ) {
-#ifndef SCSI_G_NCR5380_MEM
 		/* set IRQ for HP C2502 */
 		if (board == BOARD_HP_C2502)
 			magic_configure(port_idx, instance->irq, magic);
-#endif
 		if (request_irq(instance->irq, generic_NCR5380_intr,
 				0, "NCR5380", instance)) {
 			printk(KERN_WARNING "scsi%d : IRQ%d not free, interrupts disabled\n", instance->host_no, instance->irq);
@@ -303,32 +301,29 @@ static int generic_NCR5380_init_one(struct scsi_host_template *tpnt,
 	NCR5380_exit(instance);
 out_unregister:
 	scsi_host_put(instance);
-out_release:
-#ifndef SCSI_G_NCR5380_MEM
-	release_region(base, region_size);
-#else
+out_unmap:
 	iounmap(iomem);
-	release_mem_region(base, iomem_size);
-#endif
+out_release:
+	if (is_pmio)
+		release_region(base, region_size);
+	else
+		release_mem_region(base, region_size);
 	return ret;
 }
 
 static void generic_NCR5380_release_resources(struct Scsi_Host *instance)
 {
+	struct NCR5380_hostdata *hostdata = shost_priv(instance);
+
 	scsi_remove_host(instance);
 	if (instance->irq != NO_IRQ)
 		free_irq(instance->irq, instance);
 	NCR5380_exit(instance);
-#ifndef SCSI_G_NCR5380_MEM
-	release_region(instance->io_port, instance->n_io_port);
-#else
-	{
-		struct NCR5380_hostdata *hostdata = shost_priv(instance);
-
-		iounmap(hostdata->iomem);
+	iounmap(hostdata->iomem);
+	if (instance->io_port)
+		release_region(instance->io_port, instance->n_io_port);
+	else
 		release_mem_region(instance->base, hostdata->iomem_size);
-	}
-#endif
 	scsi_host_put(instance);
 }
 
@@ -361,18 +356,16 @@ static inline int generic_NCR5380_pread(struct Scsi_Host *instance,
 		while (NCR5380_read(hostdata->c400_ctl_status) & CSR_HOST_BUF_NOT_RDY)
 			; /* FIXME - no timeout */
 
-#ifndef SCSI_G_NCR5380_MEM
-		if (hostdata->io_width == 2)
+		if (instance->io_port && hostdata->io_width == 2)
 			insw(instance->io_port + hostdata->c400_host_buf,
 							dst + start, 64);
-		else
+		else if (instance->io_port)
 			insb(instance->io_port + hostdata->c400_host_buf,
 							dst + start, 128);
-#else
-		/* implies SCSI_G_NCR5380_MEM */
-		memcpy_fromio(dst + start,
-		              hostdata->iomem + NCR53C400_host_buffer, 128);
-#endif
+		else
+			memcpy_fromio(dst + start,
+				hostdata->iomem + NCR53C400_host_buffer, 128);
+
 		start += 128;
 		blocks--;
 	}
@@ -381,18 +374,16 @@ static inline int generic_NCR5380_pread(struct Scsi_Host *instance,
 		while (NCR5380_read(hostdata->c400_ctl_status) & CSR_HOST_BUF_NOT_RDY)
 			; /* FIXME - no timeout */
 
-#ifndef SCSI_G_NCR5380_MEM
-		if (hostdata->io_width == 2)
+		if (instance->io_port && hostdata->io_width == 2)
 			insw(instance->io_port + hostdata->c400_host_buf,
 							dst + start, 64);
-		else
+		else if (instance->io_port)
 			insb(instance->io_port + hostdata->c400_host_buf,
 							dst + start, 128);
-#else
-		/* implies SCSI_G_NCR5380_MEM */
-		memcpy_fromio(dst + start,
-		              hostdata->iomem + NCR53C400_host_buffer, 128);
-#endif
+		else
+			memcpy_fromio(dst + start,
+				hostdata->iomem + NCR53C400_host_buffer, 128);
+
 		start += 128;
 		blocks--;
 	}
@@ -439,18 +430,17 @@ static inline int generic_NCR5380_pwrite(struct Scsi_Host *instance,
 			break;
 		while (NCR5380_read(hostdata->c400_ctl_status) & CSR_HOST_BUF_NOT_RDY)
 			; // FIXME - timeout
-#ifndef SCSI_G_NCR5380_MEM
-		if (hostdata->io_width == 2)
+
+		if (instance->io_port && hostdata->io_width == 2)
 			outsw(instance->io_port + hostdata->c400_host_buf,
 							src + start, 64);
-		else
+		else if (instance->io_port)
 			outsb(instance->io_port + hostdata->c400_host_buf,
 							src + start, 128);
-#else
-		/* implies SCSI_G_NCR5380_MEM */
-		memcpy_toio(hostdata->iomem + NCR53C400_host_buffer,
-		            src + start, 128);
-#endif
+		else
+			memcpy_toio(hostdata->iomem + NCR53C400_host_buffer,
+			            src + start, 128);
+
 		start += 128;
 		blocks--;
 	}
@@ -458,18 +448,16 @@ static inline int generic_NCR5380_pwrite(struct Scsi_Host *instance,
 		while (NCR5380_read(hostdata->c400_ctl_status) & CSR_HOST_BUF_NOT_RDY)
 			; // FIXME - no timeout
 
-#ifndef SCSI_G_NCR5380_MEM
-		if (hostdata->io_width == 2)
+		if (instance->io_port && hostdata->io_width == 2)
 			outsw(instance->io_port + hostdata->c400_host_buf,
 							src + start, 64);
-		else
+		else if (instance->io_port)
 			outsb(instance->io_port + hostdata->c400_host_buf,
 							src + start, 128);
-#else
-		/* implies SCSI_G_NCR5380_MEM */
-		memcpy_toio(hostdata->iomem + NCR53C400_host_buffer,
-		            src + start, 128);
-#endif
+		else
+			memcpy_toio(hostdata->iomem + NCR53C400_host_buffer,
+			            src + start, 128);
+
 		start += 128;
 		blocks--;
 	}
@@ -566,7 +554,7 @@ static struct isa_driver generic_NCR5380_isa_driver = {
 	},
 };
 
-#if !defined(SCSI_G_NCR5380_MEM) && defined(CONFIG_PNP)
+#ifdef CONFIG_PNP
 static struct pnp_device_id generic_NCR5380_pnp_ids[] = {
 	{ .id = "DTC436e", .driver_data = BOARD_DTC3181E },
 	{ .id = "" }
@@ -600,7 +588,7 @@ static struct pnp_driver generic_NCR5380_pnp_driver = {
 	.probe		= generic_NCR5380_pnp_probe,
 	.remove		= generic_NCR5380_pnp_remove,
 };
-#endif /* !defined(SCSI_G_NCR5380_MEM) && defined(CONFIG_PNP) */
+#endif /* defined(CONFIG_PNP) */
 
 static int pnp_registered, isa_registered;
 
@@ -624,7 +612,7 @@ static int __init generic_NCR5380_init(void)
 			card[0] = BOARD_HP_C2502;
 	}
 
-#if !defined(SCSI_G_NCR5380_MEM) && defined(CONFIG_PNP)
+#ifdef CONFIG_PNP
 	if (!pnp_register_driver(&generic_NCR5380_pnp_driver))
 		pnp_registered = 1;
 #endif
@@ -637,7 +625,7 @@ static int __init generic_NCR5380_init(void)
 
 static void __exit generic_NCR5380_exit(void)
 {
-#if !defined(SCSI_G_NCR5380_MEM) && defined(CONFIG_PNP)
+#ifdef CONFIG_PNP
 	if (pnp_registered)
 		pnp_unregister_driver(&generic_NCR5380_pnp_driver);
 #endif

commit a8cfbcaec0c1214ddebf1b7a39aa0df545fbbf90
Author: Ondrej Zary <linux@rainbow-software.org>
Date:   Tue Sep 27 21:00:25 2016 +0200

    scsi: g_NCR5380: Stop using scsi_module.c
    
    Convert g_NCR5380 to use scsi_add_host instead of scsi_module.c Use
    pnp_driver and isa_driver to manage cards.
    
    In order to support multiple cards, new module parameter format is
    introduced. The old parameters are kept for compatibility.
    
    Signed-off-by: Ondrej Zary <linux@rainbow-software.org>
    Acked-by: Finn Thain <fthain@telegraphics.com.au>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/g_NCR5380.c b/drivers/scsi/g_NCR5380.c
index 5162de61a92f..cbf010324c18 100644
--- a/drivers/scsi/g_NCR5380.c
+++ b/drivers/scsi/g_NCR5380.c
@@ -30,24 +30,41 @@
 #include "NCR5380.h"
 #include <linux/init.h>
 #include <linux/ioport.h>
-#include <linux/isapnp.h>
+#include <linux/isa.h>
+#include <linux/pnp.h>
 #include <linux/interrupt.h>
 
+#define MAX_CARDS 8
+
+/* old-style parameters for compatibility */
 static int ncr_irq;
-static int ncr_dma;
 static int ncr_addr;
 static int ncr_5380;
 static int ncr_53c400;
 static int ncr_53c400a;
 static int dtc_3181e;
 static int hp_c2502;
+module_param(ncr_irq, int, 0);
+module_param(ncr_addr, int, 0);
+module_param(ncr_5380, int, 0);
+module_param(ncr_53c400, int, 0);
+module_param(ncr_53c400a, int, 0);
+module_param(dtc_3181e, int, 0);
+module_param(hp_c2502, int, 0);
+
+static int irq[] = { 0, 0, 0, 0, 0, 0, 0, 0 };
+module_param_array(irq, int, NULL, 0);
+MODULE_PARM_DESC(irq, "IRQ number(s)");
 
-static struct card {
-	NCR5380_map_type NCR5380_map_name;
-	int irq;
-	int dma;
-	int board;		/* Use NCR53c400, Ricoh, etc. extensions ? */
-} card;
+static int base[] = { 0, 0, 0, 0, 0, 0, 0, 0 };
+module_param_array(base, int, NULL, 0);
+MODULE_PARM_DESC(base, "base address(es)");
+
+static int card[] = { -1, -1, -1, -1, -1, -1, -1, -1 };
+module_param_array(card, int, NULL, 0);
+MODULE_PARM_DESC(card, "card type (0=NCR5380, 1=NCR53C400, 2=NCR53C400A, 3=DTC3181E, 4=HP C2502)");
+
+MODULE_LICENSE("GPL");
 
 #ifndef SCSI_G_NCR5380_MEM
 /*
@@ -73,17 +90,8 @@ static void magic_configure(int idx, u8 irq, u8 magic[])
 }
 #endif
 
-/**
- * 	generic_NCR5380_detect	-	look for NCR5380 controllers
- *	@tpnt: the scsi template
- *
- *	Scan for the present of NCR5380, NCR53C400, NCR53C400A, DTC3181E
- *	and DTC436(ISAPnP) controllers.
- *
- *	Locks: none
- */
-
-static int __init generic_NCR5380_detect(struct scsi_host_template *tpnt)
+static int generic_NCR5380_init_one(struct scsi_host_template *tpnt,
+			struct device *pdev, int base, int irq, int board)
 {
 	unsigned int *ports;
 	u8 *magic = NULL;
@@ -92,80 +100,29 @@ static int __init generic_NCR5380_detect(struct scsi_host_template *tpnt)
 	int port_idx = -1;
 	unsigned long region_size;
 #endif
-	static unsigned int __initdata ncr_53c400a_ports[] = {
+	static unsigned int ncr_53c400a_ports[] = {
 		0x280, 0x290, 0x300, 0x310, 0x330, 0x340, 0x348, 0x350, 0
 	};
-	static unsigned int __initdata dtc_3181e_ports[] = {
+	static unsigned int dtc_3181e_ports[] = {
 		0x220, 0x240, 0x280, 0x2a0, 0x2c0, 0x300, 0x320, 0x340, 0
 	};
-	static u8 ncr_53c400a_magic[] __initdata = {	/* 53C400A & DTC436 */
+	static u8 ncr_53c400a_magic[] = {	/* 53C400A & DTC436 */
 		0x59, 0xb9, 0xc5, 0xae, 0xa6
 	};
-	static u8 hp_c2502_magic[] __initdata = {	/* HP C2502 */
+	static u8 hp_c2502_magic[] = {	/* HP C2502 */
 		0x0f, 0x22, 0xf0, 0x20, 0x80
 	};
-	int flags;
+	int flags, ret;
 	struct Scsi_Host *instance;
 	struct NCR5380_hostdata *hostdata;
 #ifdef SCSI_G_NCR5380_MEM
-	unsigned long base;
 	void __iomem *iomem;
 	resource_size_t iomem_size;
 #endif
 
-	if (ncr_irq)
-		card.irq = ncr_irq;
-	if (ncr_dma)
-		card.dma = ncr_dma;
-	if (ncr_addr)
-		card.NCR5380_map_name = (NCR5380_map_type) ncr_addr;
-	if (ncr_5380)
-		card.board = BOARD_NCR5380;
-	else if (ncr_53c400)
-		card.board = BOARD_NCR53C400;
-	else if (ncr_53c400a)
-		card.board = BOARD_NCR53C400A;
-	else if (dtc_3181e)
-		card.board = BOARD_DTC3181E;
-	else if (hp_c2502)
-		card.board = BOARD_HP_C2502;
-#ifndef SCSI_G_NCR5380_MEM
-	if (isapnp_present()) {
-		struct pnp_dev *dev = NULL;
-		while ((dev = pnp_find_dev(NULL, ISAPNP_VENDOR('D', 'T', 'C'), ISAPNP_FUNCTION(0x436e), dev))) {
-			if (pnp_device_attach(dev) < 0)
-				continue;
-			if (pnp_activate_dev(dev) < 0) {
-				printk(KERN_ERR "dtc436e probe: activate failed\n");
-				pnp_device_detach(dev);
-				continue;
-			}
-			if (!pnp_port_valid(dev, 0)) {
-				printk(KERN_ERR "dtc436e probe: no valid port\n");
-				pnp_device_detach(dev);
-				continue;
-			}
-			if (pnp_irq_valid(dev, 0))
-				card.irq = pnp_irq(dev, 0);
-			else
-				card.irq = NO_IRQ;
-			if (pnp_dma_valid(dev, 0))
-				card.dma = pnp_dma(dev, 0);
-			else
-				card.dma = DMA_NONE;
-			card.NCR5380_map_name = (NCR5380_map_type) pnp_port_start(dev, 0);
-			card.board = BOARD_DTC3181E;
-			break;
-		}
-	}
-#endif
-
-	if (!(card.NCR5380_map_name))
-		return 0;
-
 	ports = NULL;
 	flags = 0;
-	switch (card.board) {
+	switch (board) {
 	case BOARD_NCR5380:
 		flags = FLAG_NO_PSEUDO_DMA | FLAG_DMA_FIXUP;
 		break;
@@ -191,17 +148,20 @@ static int __init generic_NCR5380_detect(struct scsi_host_template *tpnt)
 		magic_configure(-1, 0, magic);
 
 		region_size = 16;
-
-		if (card.NCR5380_map_name != PORT_AUTO)
+		if (base)
 			for (i = 0; ports[i]; i++) {
-				if (!request_region(ports[i], region_size, "ncr53c80"))
-					continue;
-				if (card.NCR5380_map_name == ports[i])
+				if (base == ports[i]) {	/* index found */
+					if (!request_region(ports[i],
+							    region_size,
+							    "ncr53c80"))
+						return -EBUSY;
 					break;
-				release_region(ports[i], region_size);
-		} else
+				}
+			}
+		else
 			for (i = 0; ports[i]; i++) {
-				if (!request_region(ports[i], region_size, "ncr53c80"))
+				if (!request_region(ports[i], region_size,
+						    "ncr53c80"))
 					continue;
 				if (inb(ports[i]) == 0xff)
 					break;
@@ -211,39 +171,41 @@ static int __init generic_NCR5380_detect(struct scsi_host_template *tpnt)
 			/* At this point we have our region reserved */
 			magic_configure(i, 0, magic); /* no IRQ yet */
 			outb(0xc0, ports[i] + 9);
-			if (inb(ports[i] + 9) != 0x80)
-				return 0;
-			card.NCR5380_map_name = ports[i];
+			if (inb(ports[i] + 9) != 0x80) {
+				ret = -ENODEV;
+				goto out_release;
+			}
+			base = ports[i];
 			port_idx = i;
 		} else
-			return 0;
+			return -EINVAL;
 	}
 	else
 	{
-		/* Not a 53C400A style setup - just grab */
+		/* NCR5380 - no configuration, just grab */
 		region_size = 8;
-		if (!request_region(card.NCR5380_map_name,
-		                    region_size, "ncr5380"))
-			return 0;
+		if (!base || !request_region(base, region_size, "ncr5380"))
+			return -EBUSY;
 	}
 #else
-	base = card.NCR5380_map_name;
 	iomem_size = NCR53C400_region_size;
 	if (!request_mem_region(base, iomem_size, "ncr5380"))
-		return 0;
+		return -EBUSY;
 	iomem = ioremap(base, iomem_size);
 	if (!iomem) {
 		release_mem_region(base, iomem_size);
-		return 0;
+		return -ENOMEM;
 	}
 #endif
-	instance = scsi_register(tpnt, sizeof(struct NCR5380_hostdata));
-	if (instance == NULL)
+	instance = scsi_host_alloc(tpnt, sizeof(struct NCR5380_hostdata));
+	if (instance == NULL) {
+		ret = -ENOMEM;
 		goto out_release;
+	}
 	hostdata = shost_priv(instance);
 
 #ifndef SCSI_G_NCR5380_MEM
-	instance->io_port = card.NCR5380_map_name;
+	instance->io_port = base;
 	instance->n_io_port = region_size;
 	hostdata->io_width = 1; /* 8-bit PDMA by default */
 
@@ -251,7 +213,7 @@ static int __init generic_NCR5380_detect(struct scsi_host_template *tpnt)
 	 * On NCR53C400 boards, NCR5380 registers are mapped 8 past
 	 * the base address.
 	 */
-	switch (card.board) {
+	switch (board) {
 	case BOARD_NCR53C400:
 		instance->io_port += 8;
 		hostdata->c400_ctl_status = 0;
@@ -269,10 +231,10 @@ static int __init generic_NCR5380_detect(struct scsi_host_template *tpnt)
 		break;
 	}
 #else
-	instance->base = card.NCR5380_map_name;
+	instance->base = base;
 	hostdata->iomem = iomem;
 	hostdata->iomem_size = iomem_size;
-	switch (card.board) {
+	switch (board) {
 	case BOARD_NCR53C400:
 		hostdata->c400_ctl_status = 0x100;
 		hostdata->c400_blk_cnt = 0x101;
@@ -282,14 +244,16 @@ static int __init generic_NCR5380_detect(struct scsi_host_template *tpnt)
 	case BOARD_NCR53C400A:
 	case BOARD_HP_C2502:
 		pr_err(DRV_MODULE_NAME ": unknown register offsets\n");
+		ret = -EINVAL;
 		goto out_unregister;
 	}
 #endif
 
-	if (NCR5380_init(instance, flags | FLAG_LATE_DMA_SETUP))
+	ret = NCR5380_init(instance, flags | FLAG_LATE_DMA_SETUP);
+	if (ret)
 		goto out_unregister;
 
-	switch (card.board) {
+	switch (board) {
 	case BOARD_NCR53C400:
 	case BOARD_DTC3181E:
 	case BOARD_NCR53C400A:
@@ -299,8 +263,8 @@ static int __init generic_NCR5380_detect(struct scsi_host_template *tpnt)
 
 	NCR5380_maybe_reset_bus(instance);
 
-	if (card.irq != IRQ_AUTO)
-		instance->irq = card.irq;
+	if (irq != IRQ_AUTO)
+		instance->irq = irq;
 	else
 		instance->irq = NCR5380_probe_irq(instance, 0xffff);
 
@@ -311,7 +275,7 @@ static int __init generic_NCR5380_detect(struct scsi_host_template *tpnt)
 	if (instance->irq != NO_IRQ) {
 #ifndef SCSI_G_NCR5380_MEM
 		/* set IRQ for HP C2502 */
-		if (card.board == BOARD_HP_C2502)
+		if (board == BOARD_HP_C2502)
 			magic_configure(port_idx, instance->irq, magic);
 #endif
 		if (request_irq(instance->irq, generic_NCR5380_intr,
@@ -326,31 +290,32 @@ static int __init generic_NCR5380_detect(struct scsi_host_template *tpnt)
 		printk(KERN_INFO "scsi%d : please jumper the board for a free IRQ.\n", instance->host_no);
 	}
 
-	return 1;
+	ret = scsi_add_host(instance, pdev);
+	if (ret)
+		goto out_free_irq;
+	scsi_scan_host(instance);
+	dev_set_drvdata(pdev, instance);
+	return 0;
 
+out_free_irq:
+	if (instance->irq != NO_IRQ)
+		free_irq(instance->irq, instance);
+	NCR5380_exit(instance);
 out_unregister:
-	scsi_unregister(instance);
+	scsi_host_put(instance);
 out_release:
 #ifndef SCSI_G_NCR5380_MEM
-	release_region(card.NCR5380_map_name, region_size);
+	release_region(base, region_size);
 #else
 	iounmap(iomem);
 	release_mem_region(base, iomem_size);
 #endif
-	return 0;
+	return ret;
 }
 
-/**
- *	generic_NCR5380_release_resources	-	free resources
- *	@instance: host adapter to clean up 
- *
- *	Free the generic interface resources from this adapter.
- *
- *	Locks: none
- */
- 
-static int generic_NCR5380_release_resources(struct Scsi_Host *instance)
+static void generic_NCR5380_release_resources(struct Scsi_Host *instance)
 {
+	scsi_remove_host(instance);
 	if (instance->irq != NO_IRQ)
 		free_irq(instance->irq, instance);
 	NCR5380_exit(instance);
@@ -364,7 +329,7 @@ static int generic_NCR5380_release_resources(struct Scsi_Host *instance)
 		release_mem_region(instance->base, hostdata->iomem_size);
 	}
 #endif
-	return 0;
+	scsi_host_put(instance);
 }
 
 /**
@@ -554,10 +519,9 @@ static int generic_NCR5380_dma_xfer_len(struct Scsi_Host *instance,
 #include "NCR5380.c"
 
 static struct scsi_host_template driver_template = {
+	.module			= THIS_MODULE,
 	.proc_name		= DRV_MODULE_NAME,
 	.name			= "Generic NCR5380/NCR53C400 SCSI",
-	.detect			= generic_NCR5380_detect,
-	.release		= generic_NCR5380_release_resources,
 	.info			= generic_NCR5380_info,
 	.queuecommand		= generic_NCR5380_queue_command,
 	.eh_abort_handler	= generic_NCR5380_abort,
@@ -571,26 +535,115 @@ static struct scsi_host_template driver_template = {
 	.max_sectors		= 128,
 };
 
-#include "scsi_module.c"
 
-module_param(ncr_irq, int, 0);
-module_param(ncr_dma, int, 0);
-module_param(ncr_addr, int, 0);
-module_param(ncr_5380, int, 0);
-module_param(ncr_53c400, int, 0);
-module_param(ncr_53c400a, int, 0);
-module_param(dtc_3181e, int, 0);
-module_param(hp_c2502, int, 0);
-MODULE_LICENSE("GPL");
+static int generic_NCR5380_isa_match(struct device *pdev, unsigned int ndev)
+{
+	int ret = generic_NCR5380_init_one(&driver_template, pdev, base[ndev],
+					  irq[ndev], card[ndev]);
+	if (ret) {
+		if (base[ndev])
+			printk(KERN_WARNING "Card not found at address 0x%03x\n",
+			       base[ndev]);
+		return 0;
+	}
 
-#if !defined(SCSI_G_NCR5380_MEM) && defined(MODULE)
-static struct isapnp_device_id id_table[] = {
-	{
-	 ISAPNP_ANY_ID, ISAPNP_ANY_ID,
-	 ISAPNP_VENDOR('D', 'T', 'C'), ISAPNP_FUNCTION(0x436e),
-	 0},
-	{0}
+	return 1;
+}
+
+static int generic_NCR5380_isa_remove(struct device *pdev,
+				   unsigned int ndev)
+{
+	generic_NCR5380_release_resources(dev_get_drvdata(pdev));
+	dev_set_drvdata(pdev, NULL);
+	return 0;
+}
+
+static struct isa_driver generic_NCR5380_isa_driver = {
+	.match		= generic_NCR5380_isa_match,
+	.remove		= generic_NCR5380_isa_remove,
+	.driver		= {
+		.name	= DRV_MODULE_NAME
+	},
+};
+
+#if !defined(SCSI_G_NCR5380_MEM) && defined(CONFIG_PNP)
+static struct pnp_device_id generic_NCR5380_pnp_ids[] = {
+	{ .id = "DTC436e", .driver_data = BOARD_DTC3181E },
+	{ .id = "" }
+};
+MODULE_DEVICE_TABLE(pnp, generic_NCR5380_pnp_ids);
+
+static int generic_NCR5380_pnp_probe(struct pnp_dev *pdev,
+			       const struct pnp_device_id *id)
+{
+	int base, irq;
+
+	if (pnp_activate_dev(pdev) < 0)
+		return -EBUSY;
+
+	base = pnp_port_start(pdev, 0);
+	irq = pnp_irq(pdev, 0);
+
+	return generic_NCR5380_init_one(&driver_template, &pdev->dev, base, irq,
+				       id->driver_data);
+}
+
+static void generic_NCR5380_pnp_remove(struct pnp_dev *pdev)
+{
+	generic_NCR5380_release_resources(pnp_get_drvdata(pdev));
+	pnp_set_drvdata(pdev, NULL);
+}
+
+static struct pnp_driver generic_NCR5380_pnp_driver = {
+	.name		= DRV_MODULE_NAME,
+	.id_table	= generic_NCR5380_pnp_ids,
+	.probe		= generic_NCR5380_pnp_probe,
+	.remove		= generic_NCR5380_pnp_remove,
 };
+#endif /* !defined(SCSI_G_NCR5380_MEM) && defined(CONFIG_PNP) */
 
-MODULE_DEVICE_TABLE(isapnp, id_table);
+static int pnp_registered, isa_registered;
+
+static int __init generic_NCR5380_init(void)
+{
+	int ret = 0;
+
+	/* compatibility with old-style parameters */
+	if (irq[0] == 0 && base[0] == 0 && card[0] == -1) {
+		irq[0] = ncr_irq;
+		base[0] = ncr_addr;
+		if (ncr_5380)
+			card[0] = BOARD_NCR5380;
+		if (ncr_53c400)
+			card[0] = BOARD_NCR53C400;
+		if (ncr_53c400a)
+			card[0] = BOARD_NCR53C400A;
+		if (dtc_3181e)
+			card[0] = BOARD_DTC3181E;
+		if (hp_c2502)
+			card[0] = BOARD_HP_C2502;
+	}
+
+#if !defined(SCSI_G_NCR5380_MEM) && defined(CONFIG_PNP)
+	if (!pnp_register_driver(&generic_NCR5380_pnp_driver))
+		pnp_registered = 1;
 #endif
+	ret = isa_register_driver(&generic_NCR5380_isa_driver, MAX_CARDS);
+	if (!ret)
+		isa_registered = 1;
+
+	return (pnp_registered || isa_registered) ? 0 : ret;
+}
+
+static void __exit generic_NCR5380_exit(void)
+{
+#if !defined(SCSI_G_NCR5380_MEM) && defined(CONFIG_PNP)
+	if (pnp_registered)
+		pnp_unregister_driver(&generic_NCR5380_pnp_driver);
+#endif
+	if (isa_registered)
+		isa_unregister_driver(&generic_NCR5380_isa_driver);
+}
+
+module_init(generic_NCR5380_init);
+module_exit(generic_NCR5380_exit);

commit d91f5afe595a3c4bdc1b755225024862c2e917f0
Author: Ondrej Zary <linux@rainbow-software.org>
Date:   Tue Sep 27 21:00:24 2016 +0200

    scsi: g_NCR5380: Reduce overrides[] from array to struct
    
    Remove compile-time card type definition GENERIC_NCR5380_OVERRIDE.  Then
    remove all code iterating the overrides[] array and reduce it to struct
    card.
    
    Signed-off-by: Ondrej Zary <linux@rainbow-software.org>
    Acked-by: Finn Thain <fthain@telegraphics.com.au>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/g_NCR5380.c b/drivers/scsi/g_NCR5380.c
index 7e50b44eb36a..5162de61a92f 100644
--- a/drivers/scsi/g_NCR5380.c
+++ b/drivers/scsi/g_NCR5380.c
@@ -42,19 +42,12 @@ static int ncr_53c400a;
 static int dtc_3181e;
 static int hp_c2502;
 
-static struct override {
+static struct card {
 	NCR5380_map_type NCR5380_map_name;
 	int irq;
 	int dma;
 	int board;		/* Use NCR53c400, Ricoh, etc. extensions ? */
-} overrides
-#ifdef GENERIC_NCR5380_OVERRIDE
-[] __initdata = GENERIC_NCR5380_OVERRIDE;
-#else
-[1] __initdata = { { 0,},};
-#endif
-
-#define NO_OVERRIDES ARRAY_SIZE(overrides)
+} card;
 
 #ifndef SCSI_G_NCR5380_MEM
 /*
@@ -85,16 +78,13 @@ static void magic_configure(int idx, u8 irq, u8 magic[])
  *	@tpnt: the scsi template
  *
  *	Scan for the present of NCR5380, NCR53C400, NCR53C400A, DTC3181E
- *	and DTC436(ISAPnP) controllers. If overrides have been set we use
- *	them.
+ *	and DTC436(ISAPnP) controllers.
  *
  *	Locks: none
  */
 
 static int __init generic_NCR5380_detect(struct scsi_host_template *tpnt)
 {
-	static int current_override;
-	int count;
 	unsigned int *ports;
 	u8 *magic = NULL;
 #ifndef SCSI_G_NCR5380_MEM
@@ -124,28 +114,25 @@ static int __init generic_NCR5380_detect(struct scsi_host_template *tpnt)
 #endif
 
 	if (ncr_irq)
-		overrides[0].irq = ncr_irq;
+		card.irq = ncr_irq;
 	if (ncr_dma)
-		overrides[0].dma = ncr_dma;
+		card.dma = ncr_dma;
 	if (ncr_addr)
-		overrides[0].NCR5380_map_name = (NCR5380_map_type) ncr_addr;
+		card.NCR5380_map_name = (NCR5380_map_type) ncr_addr;
 	if (ncr_5380)
-		overrides[0].board = BOARD_NCR5380;
+		card.board = BOARD_NCR5380;
 	else if (ncr_53c400)
-		overrides[0].board = BOARD_NCR53C400;
+		card.board = BOARD_NCR53C400;
 	else if (ncr_53c400a)
-		overrides[0].board = BOARD_NCR53C400A;
+		card.board = BOARD_NCR53C400A;
 	else if (dtc_3181e)
-		overrides[0].board = BOARD_DTC3181E;
+		card.board = BOARD_DTC3181E;
 	else if (hp_c2502)
-		overrides[0].board = BOARD_HP_C2502;
+		card.board = BOARD_HP_C2502;
 #ifndef SCSI_G_NCR5380_MEM
-	if (!current_override && isapnp_present()) {
+	if (isapnp_present()) {
 		struct pnp_dev *dev = NULL;
-		count = 0;
 		while ((dev = pnp_find_dev(NULL, ISAPNP_VENDOR('D', 'T', 'C'), ISAPNP_FUNCTION(0x436e), dev))) {
-			if (count >= NO_OVERRIDES)
-				break;
 			if (pnp_device_attach(dev) < 0)
 				continue;
 			if (pnp_activate_dev(dev) < 0) {
@@ -159,202 +146,198 @@ static int __init generic_NCR5380_detect(struct scsi_host_template *tpnt)
 				continue;
 			}
 			if (pnp_irq_valid(dev, 0))
-				overrides[count].irq = pnp_irq(dev, 0);
+				card.irq = pnp_irq(dev, 0);
 			else
-				overrides[count].irq = NO_IRQ;
+				card.irq = NO_IRQ;
 			if (pnp_dma_valid(dev, 0))
-				overrides[count].dma = pnp_dma(dev, 0);
+				card.dma = pnp_dma(dev, 0);
 			else
-				overrides[count].dma = DMA_NONE;
-			overrides[count].NCR5380_map_name = (NCR5380_map_type) pnp_port_start(dev, 0);
-			overrides[count].board = BOARD_DTC3181E;
-			count++;
+				card.dma = DMA_NONE;
+			card.NCR5380_map_name = (NCR5380_map_type) pnp_port_start(dev, 0);
+			card.board = BOARD_DTC3181E;
+			break;
 		}
 	}
 #endif
 
-	for (count = 0; current_override < NO_OVERRIDES; ++current_override) {
-		if (!(overrides[current_override].NCR5380_map_name))
-			continue;
+	if (!(card.NCR5380_map_name))
+		return 0;
 
-		ports = NULL;
-		flags = 0;
-		switch (overrides[current_override].board) {
-		case BOARD_NCR5380:
-			flags = FLAG_NO_PSEUDO_DMA | FLAG_DMA_FIXUP;
-			break;
-		case BOARD_NCR53C400A:
-			ports = ncr_53c400a_ports;
-			magic = ncr_53c400a_magic;
-			break;
-		case BOARD_HP_C2502:
-			ports = ncr_53c400a_ports;
-			magic = hp_c2502_magic;
-			break;
-		case BOARD_DTC3181E:
-			ports = dtc_3181e_ports;
-			magic = ncr_53c400a_magic;
-			break;
-		}
+	ports = NULL;
+	flags = 0;
+	switch (card.board) {
+	case BOARD_NCR5380:
+		flags = FLAG_NO_PSEUDO_DMA | FLAG_DMA_FIXUP;
+		break;
+	case BOARD_NCR53C400A:
+		ports = ncr_53c400a_ports;
+		magic = ncr_53c400a_magic;
+		break;
+	case BOARD_HP_C2502:
+		ports = ncr_53c400a_ports;
+		magic = hp_c2502_magic;
+		break;
+	case BOARD_DTC3181E:
+		ports = dtc_3181e_ports;
+		magic = ncr_53c400a_magic;
+		break;
+	}
 
 #ifndef SCSI_G_NCR5380_MEM
-		if (ports && magic) {
-			/* wakeup sequence for the NCR53C400A and DTC3181E */
-
-			/* Disable the adapter and look for a free io port */
-			magic_configure(-1, 0, magic);
-
-			region_size = 16;
-
-			if (overrides[current_override].NCR5380_map_name != PORT_AUTO)
-				for (i = 0; ports[i]; i++) {
-					if (!request_region(ports[i], region_size, "ncr53c80"))
-						continue;
-					if (overrides[current_override].NCR5380_map_name == ports[i])
-						break;
-					release_region(ports[i], region_size);
-			} else
-				for (i = 0; ports[i]; i++) {
-					if (!request_region(ports[i], region_size, "ncr53c80"))
-						continue;
-					if (inb(ports[i]) == 0xff)
-						break;
-					release_region(ports[i], region_size);
-				}
-			if (ports[i]) {
-				/* At this point we have our region reserved */
-				magic_configure(i, 0, magic); /* no IRQ yet */
-				outb(0xc0, ports[i] + 9);
-				if (inb(ports[i] + 9) != 0x80)
+	if (ports && magic) {
+		/* wakeup sequence for the NCR53C400A and DTC3181E */
+
+		/* Disable the adapter and look for a free io port */
+		magic_configure(-1, 0, magic);
+
+		region_size = 16;
+
+		if (card.NCR5380_map_name != PORT_AUTO)
+			for (i = 0; ports[i]; i++) {
+				if (!request_region(ports[i], region_size, "ncr53c80"))
 					continue;
-				overrides[current_override].NCR5380_map_name = ports[i];
-				port_idx = i;
-			} else
-				continue;
-		}
-		else
-		{
-			/* Not a 53C400A style setup - just grab */
-			region_size = 8;
-			if (!request_region(overrides[current_override].NCR5380_map_name,
-			                    region_size, "ncr5380"))
-				continue;
-		}
+				if (card.NCR5380_map_name == ports[i])
+					break;
+				release_region(ports[i], region_size);
+		} else
+			for (i = 0; ports[i]; i++) {
+				if (!request_region(ports[i], region_size, "ncr53c80"))
+					continue;
+				if (inb(ports[i]) == 0xff)
+					break;
+				release_region(ports[i], region_size);
+			}
+		if (ports[i]) {
+			/* At this point we have our region reserved */
+			magic_configure(i, 0, magic); /* no IRQ yet */
+			outb(0xc0, ports[i] + 9);
+			if (inb(ports[i] + 9) != 0x80)
+				return 0;
+			card.NCR5380_map_name = ports[i];
+			port_idx = i;
+		} else
+			return 0;
+	}
+	else
+	{
+		/* Not a 53C400A style setup - just grab */
+		region_size = 8;
+		if (!request_region(card.NCR5380_map_name,
+		                    region_size, "ncr5380"))
+			return 0;
+	}
 #else
-		base = overrides[current_override].NCR5380_map_name;
-		iomem_size = NCR53C400_region_size;
-		if (!request_mem_region(base, iomem_size, "ncr5380"))
-			continue;
-		iomem = ioremap(base, iomem_size);
-		if (!iomem) {
-			release_mem_region(base, iomem_size);
-			continue;
-		}
+	base = card.NCR5380_map_name;
+	iomem_size = NCR53C400_region_size;
+	if (!request_mem_region(base, iomem_size, "ncr5380"))
+		return 0;
+	iomem = ioremap(base, iomem_size);
+	if (!iomem) {
+		release_mem_region(base, iomem_size);
+		return 0;
+	}
 #endif
-		instance = scsi_register(tpnt, sizeof(struct NCR5380_hostdata));
-		if (instance == NULL)
-			goto out_release;
-		hostdata = shost_priv(instance);
+	instance = scsi_register(tpnt, sizeof(struct NCR5380_hostdata));
+	if (instance == NULL)
+		goto out_release;
+	hostdata = shost_priv(instance);
 
 #ifndef SCSI_G_NCR5380_MEM
-		instance->io_port = overrides[current_override].NCR5380_map_name;
-		instance->n_io_port = region_size;
-		hostdata->io_width = 1; /* 8-bit PDMA by default */
-
-		/*
-		 * On NCR53C400 boards, NCR5380 registers are mapped 8 past
-		 * the base address.
-		 */
-		switch (overrides[current_override].board) {
-		case BOARD_NCR53C400:
-			instance->io_port += 8;
-			hostdata->c400_ctl_status = 0;
-			hostdata->c400_blk_cnt = 1;
-			hostdata->c400_host_buf = 4;
-			break;
-		case BOARD_DTC3181E:
-			hostdata->io_width = 2;	/* 16-bit PDMA */
-			/* fall through */
-		case BOARD_NCR53C400A:
-		case BOARD_HP_C2502:
-			hostdata->c400_ctl_status = 9;
-			hostdata->c400_blk_cnt = 10;
-			hostdata->c400_host_buf = 8;
-			break;
-		}
+	instance->io_port = card.NCR5380_map_name;
+	instance->n_io_port = region_size;
+	hostdata->io_width = 1; /* 8-bit PDMA by default */
+
+	/*
+	 * On NCR53C400 boards, NCR5380 registers are mapped 8 past
+	 * the base address.
+	 */
+	switch (card.board) {
+	case BOARD_NCR53C400:
+		instance->io_port += 8;
+		hostdata->c400_ctl_status = 0;
+		hostdata->c400_blk_cnt = 1;
+		hostdata->c400_host_buf = 4;
+		break;
+	case BOARD_DTC3181E:
+		hostdata->io_width = 2;	/* 16-bit PDMA */
+		/* fall through */
+	case BOARD_NCR53C400A:
+	case BOARD_HP_C2502:
+		hostdata->c400_ctl_status = 9;
+		hostdata->c400_blk_cnt = 10;
+		hostdata->c400_host_buf = 8;
+		break;
+	}
 #else
-		instance->base = overrides[current_override].NCR5380_map_name;
-		hostdata->iomem = iomem;
-		hostdata->iomem_size = iomem_size;
-		switch (overrides[current_override].board) {
-		case BOARD_NCR53C400:
-			hostdata->c400_ctl_status = 0x100;
-			hostdata->c400_blk_cnt = 0x101;
-			hostdata->c400_host_buf = 0x104;
-			break;
-		case BOARD_DTC3181E:
-		case BOARD_NCR53C400A:
-		case BOARD_HP_C2502:
-			pr_err(DRV_MODULE_NAME ": unknown register offsets\n");
-			goto out_unregister;
-		}
+	instance->base = card.NCR5380_map_name;
+	hostdata->iomem = iomem;
+	hostdata->iomem_size = iomem_size;
+	switch (card.board) {
+	case BOARD_NCR53C400:
+		hostdata->c400_ctl_status = 0x100;
+		hostdata->c400_blk_cnt = 0x101;
+		hostdata->c400_host_buf = 0x104;
+		break;
+	case BOARD_DTC3181E:
+	case BOARD_NCR53C400A:
+	case BOARD_HP_C2502:
+		pr_err(DRV_MODULE_NAME ": unknown register offsets\n");
+		goto out_unregister;
+	}
 #endif
 
-		if (NCR5380_init(instance, flags | FLAG_LATE_DMA_SETUP))
-			goto out_unregister;
+	if (NCR5380_init(instance, flags | FLAG_LATE_DMA_SETUP))
+		goto out_unregister;
 
-		switch (overrides[current_override].board) {
-		case BOARD_NCR53C400:
-		case BOARD_DTC3181E:
-		case BOARD_NCR53C400A:
-		case BOARD_HP_C2502:
-			NCR5380_write(hostdata->c400_ctl_status, CSR_BASE);
-		}
+	switch (card.board) {
+	case BOARD_NCR53C400:
+	case BOARD_DTC3181E:
+	case BOARD_NCR53C400A:
+	case BOARD_HP_C2502:
+		NCR5380_write(hostdata->c400_ctl_status, CSR_BASE);
+	}
 
-		NCR5380_maybe_reset_bus(instance);
+	NCR5380_maybe_reset_bus(instance);
 
-		if (overrides[current_override].irq != IRQ_AUTO)
-			instance->irq = overrides[current_override].irq;
-		else
-			instance->irq = NCR5380_probe_irq(instance, 0xffff);
+	if (card.irq != IRQ_AUTO)
+		instance->irq = card.irq;
+	else
+		instance->irq = NCR5380_probe_irq(instance, 0xffff);
 
-		/* Compatibility with documented NCR5380 kernel parameters */
-		if (instance->irq == 255)
-			instance->irq = NO_IRQ;
+	/* Compatibility with documented NCR5380 kernel parameters */
+	if (instance->irq == 255)
+		instance->irq = NO_IRQ;
 
-		if (instance->irq != NO_IRQ) {
+	if (instance->irq != NO_IRQ) {
 #ifndef SCSI_G_NCR5380_MEM
-			/* set IRQ for HP C2502 */
-			if (overrides[current_override].board == BOARD_HP_C2502)
-				magic_configure(port_idx, instance->irq, magic);
+		/* set IRQ for HP C2502 */
+		if (card.board == BOARD_HP_C2502)
+			magic_configure(port_idx, instance->irq, magic);
 #endif
-			if (request_irq(instance->irq, generic_NCR5380_intr,
-					0, "NCR5380", instance)) {
-				printk(KERN_WARNING "scsi%d : IRQ%d not free, interrupts disabled\n", instance->host_no, instance->irq);
-				instance->irq = NO_IRQ;
-			}
-		}
-
-		if (instance->irq == NO_IRQ) {
-			printk(KERN_INFO "scsi%d : interrupts not enabled. for better interactive performance,\n", instance->host_no);
-			printk(KERN_INFO "scsi%d : please jumper the board for a free IRQ.\n", instance->host_no);
+		if (request_irq(instance->irq, generic_NCR5380_intr,
+				0, "NCR5380", instance)) {
+			printk(KERN_WARNING "scsi%d : IRQ%d not free, interrupts disabled\n", instance->host_no, instance->irq);
+			instance->irq = NO_IRQ;
 		}
+	}
 
-		++current_override;
-		++count;
+	if (instance->irq == NO_IRQ) {
+		printk(KERN_INFO "scsi%d : interrupts not enabled. for better interactive performance,\n", instance->host_no);
+		printk(KERN_INFO "scsi%d : please jumper the board for a free IRQ.\n", instance->host_no);
 	}
-	return count;
+
+	return 1;
 
 out_unregister:
 	scsi_unregister(instance);
 out_release:
 #ifndef SCSI_G_NCR5380_MEM
-	release_region(overrides[current_override].NCR5380_map_name, region_size);
+	release_region(card.NCR5380_map_name, region_size);
 #else
 	iounmap(iomem);
 	release_mem_region(base, iomem_size);
 #endif
-	return count;
+	return 0;
 }
 
 /**

commit c47946c2dda311216ac11e981809b2d70609258f
Author: Ondrej Zary <linux@rainbow-software.org>
Date:   Tue Sep 27 21:00:23 2016 +0200

    scsi: g_NCR5380: Remove deprecated __setup
    
    Remove deprecated __setup for parsing command line parameters.
    g_NCR5380.* parameters could be used instead.
    
    This might break existing setups with g_NCR5380 built-in (if there are
    any). But it has to go in order to remove the overrides[] array.
    
    Signed-off-by: Ondrej Zary <linux@rainbow-software.org>
    Acked-by: Finn Thain <fthain@telegraphics.com.au>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/g_NCR5380.c b/drivers/scsi/g_NCR5380.c
index 516bd6c4f442..7e50b44eb36a 100644
--- a/drivers/scsi/g_NCR5380.c
+++ b/drivers/scsi/g_NCR5380.c
@@ -56,136 +56,6 @@ static struct override {
 
 #define NO_OVERRIDES ARRAY_SIZE(overrides)
 
-#ifndef MODULE
-
-/**
- *	internal_setup		-	handle lilo command string override
- *	@board:	BOARD_* identifier for the board
- *	@str: unused
- *	@ints: numeric parameters
- *
- * 	Do LILO command line initialization of the overrides array. Display
- *	errors when needed
- *
- *	Locks: none
- */
-
-static void __init internal_setup(int board, char *str, int *ints)
-{
-	static int commandline_current;
-	switch (board) {
-	case BOARD_NCR5380:
-		if (ints[0] != 2 && ints[0] != 3) {
-			printk(KERN_ERR "generic_NCR5380_setup : usage ncr5380=" STRVAL(NCR5380_map_name) ",irq,dma\n");
-			return;
-		}
-		break;
-	case BOARD_NCR53C400:
-		if (ints[0] != 2) {
-			printk(KERN_ERR "generic_NCR53C400_setup : usage ncr53c400=" STRVAL(NCR5380_map_name) ",irq\n");
-			return;
-		}
-		break;
-	case BOARD_NCR53C400A:
-		if (ints[0] != 2) {
-			printk(KERN_ERR "generic_NCR53C400A_setup : usage ncr53c400a=" STRVAL(NCR5380_map_name) ",irq\n");
-			return;
-		}
-		break;
-	case BOARD_DTC3181E:
-		if (ints[0] != 2) {
-			printk("generic_DTC3181E_setup : usage dtc3181e=" STRVAL(NCR5380_map_name) ",irq\n");
-			return;
-		}
-		break;
-	}
-
-	if (commandline_current < NO_OVERRIDES) {
-		overrides[commandline_current].NCR5380_map_name = (NCR5380_map_type) ints[1];
-		overrides[commandline_current].irq = ints[2];
-		if (ints[0] == 3)
-			overrides[commandline_current].dma = ints[3];
-		else
-			overrides[commandline_current].dma = DMA_NONE;
-		overrides[commandline_current].board = board;
-		++commandline_current;
-	}
-}
-
-
-/**
- * 	do_NCR53C80_setup		-	set up entry point
- *	@str: unused
- *
- *	Setup function invoked at boot to parse the ncr5380= command
- *	line.
- */
-
-static int __init do_NCR5380_setup(char *str)
-{
-	int ints[10];
-
-	get_options(str, ARRAY_SIZE(ints), ints);
-	internal_setup(BOARD_NCR5380, str, ints);
-	return 1;
-}
-
-/**
- * 	do_NCR53C400_setup		-	set up entry point
- *	@str: unused
- *	@ints: integer parameters from kernel setup code
- *
- *	Setup function invoked at boot to parse the ncr53c400= command
- *	line.
- */
-
-static int __init do_NCR53C400_setup(char *str)
-{
-	int ints[10];
-
-	get_options(str, ARRAY_SIZE(ints), ints);
-	internal_setup(BOARD_NCR53C400, str, ints);
-	return 1;
-}
-
-/**
- * 	do_NCR53C400A_setup	-	set up entry point
- *	@str: unused
- *	@ints: integer parameters from kernel setup code
- *
- *	Setup function invoked at boot to parse the ncr53c400a= command
- *	line.
- */
-
-static int __init do_NCR53C400A_setup(char *str)
-{
-	int ints[10];
-
-	get_options(str, ARRAY_SIZE(ints), ints);
-	internal_setup(BOARD_NCR53C400A, str, ints);
-	return 1;
-}
-
-/**
- * 	do_DTC3181E_setup	-	set up entry point
- *	@str: unused
- *	@ints: integer parameters from kernel setup code
- *
- *	Setup function invoked at boot to parse the dtc3181e= command
- *	line.
- */
-
-static int __init do_DTC3181E_setup(char *str)
-{
-	int ints[10];
-
-	get_options(str, ARRAY_SIZE(ints), ints);
-	internal_setup(BOARD_DTC3181E, str, ints);
-	return 1;
-}
-
-#endif
-
 #ifndef SCSI_G_NCR5380_MEM
 /*
  * Configure I/O address of 53C400A or DTC436 by writing magic numbers
@@ -741,8 +611,3 @@ static struct isapnp_device_id id_table[] = {
 
 MODULE_DEVICE_TABLE(isapnp, id_table);
 #endif
-
-__setup("ncr5380=", do_NCR5380_setup);
-__setup("ncr53c400=", do_NCR53C400_setup);
-__setup("ncr53c400a=", do_NCR53C400A_setup);
-__setup("dtc3181e=", do_DTC3181E_setup);

commit 9c41ab27e3fe0cfec16d3ac23f2067a516e337a4
Author: Finn Thain <fthain@telegraphics.com.au>
Date:   Wed Mar 23 21:10:28 2016 +1100

    ncr5380: Update usage documentation
    
    Update kernel parameter documentation for atari_scsi, mac_scsi and
    g_NCR5380 drivers. Remove duplication.
    
    Signed-off-by: Finn Thain <fthain@telegraphics.com.au>
    Reviewed-by: Hannes Reinecke <hare@suse.com>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/g_NCR5380.c b/drivers/scsi/g_NCR5380.c
index 18f4a4f99336..516bd6c4f442 100644
--- a/drivers/scsi/g_NCR5380.c
+++ b/drivers/scsi/g_NCR5380.c
@@ -18,42 +18,8 @@
  *
  * Added ISAPNP support for DTC436 adapters,
  * Thomas Sailer, sailer@ife.ee.ethz.ch
- */
-
-/* 
- * TODO : flesh out DMA support, find some one actually using this (I have
- * 	a memory mapped Trantor board that works fine)
- */
-
-/*
- * The card is detected and initialized in one of several ways : 
- * 1.  With command line overrides - NCR5380=port,irq may be 
- *     used on the LILO command line to override the defaults.
- *
- * 2.  With the GENERIC_NCR5380_OVERRIDE compile time define.  This is 
- *     specified as an array of address, irq, dma, board tuples.  Ie, for
- *     one board at 0x350, IRQ5, no dma, I could say  
- *     -DGENERIC_NCR5380_OVERRIDE={{0xcc000, 5, DMA_NONE, BOARD_NCR5380}}
- * 
- * -1 should be specified for no or DMA interrupt, -2 to autoprobe for an 
- * 	IRQ line if overridden on the command line.
  *
- * 3.  When included as a module, with arguments passed on the command line:
- *         ncr_irq=xx	the interrupt
- *         ncr_addr=xx  the port or base address (for port or memory
- *              	mapped, resp.)
- *         ncr_dma=xx	the DMA
- *         ncr_5380=1	to set up for a NCR5380 board
- *         ncr_53c400=1	to set up for a NCR53C400 board
- *     e.g.
- *     modprobe g_NCR5380 ncr_irq=5 ncr_addr=0x350 ncr_5380=1
- *       for a port mapped NCR5380 board or
- *     modprobe g_NCR5380 ncr_irq=255 ncr_addr=0xc8000 ncr_53c400=1
- *       for a memory mapped NCR53C400 board with interrupts disabled.
- * 
- * 255 should be specified for no or DMA interrupt, 254 to autoprobe for an 
- * 	IRQ line if overridden on the command line.
- *     
+ * See Documentation/scsi/g_NCR5380.txt for more info.
  */
 
 #include <asm/io.h>

commit a46865dcf1f7166808664ab096678f81d4fbb853
Author: Finn Thain <fthain@telegraphics.com.au>
Date:   Wed Mar 23 21:10:27 2016 +1100

    ncr5380: Remove DONT_USE_INTR and AUTOPROBE_IRQ macros
    
    Signed-off-by: Finn Thain <fthain@telegraphics.com.au>
    Reviewed-by: Hannes Reinecke <hare@suse.com>
    Tested-by: Michael Schmitz <schmitzmic@gmail.com>
    Tested-by: Ondrej Zary <linux@rainbow-software.org>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/g_NCR5380.c b/drivers/scsi/g_NCR5380.c
index 09e1cf938ecf..18f4a4f99336 100644
--- a/drivers/scsi/g_NCR5380.c
+++ b/drivers/scsi/g_NCR5380.c
@@ -56,8 +56,6 @@
  *     
  */
 
-#define AUTOPROBE_IRQ
-
 #include <asm/io.h>
 #include <linux/blkdev.h>
 #include <linux/module.h>

commit 8053b0ee79c0129e827ce8f222398ff4b332dfd7
Author: Finn Thain <fthain@telegraphics.com.au>
Date:   Wed Mar 23 21:10:19 2016 +1100

    ncr5380: Merge DMA implementation from atari_NCR5380 core driver
    
    Adopt the DMA implementation from atari_NCR5380.c. This means that
    atari_scsi and sun3_scsi can make use of the NCR5380.c core driver
    and the atari_NCR5380.c driver fork can be made redundant.
    
    Signed-off-by: Finn Thain <fthain@telegraphics.com.au>
    Reviewed-by: Hannes Reinecke <hare@suse.com>
    Tested-by: Michael Schmitz <schmitzmic@gmail.com>
    Tested-by: Ondrej Zary <linux@rainbow-software.org>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/g_NCR5380.c b/drivers/scsi/g_NCR5380.c
index f8c00c96a837..09e1cf938ecf 100644
--- a/drivers/scsi/g_NCR5380.c
+++ b/drivers/scsi/g_NCR5380.c
@@ -466,7 +466,7 @@ static int __init generic_NCR5380_detect(struct scsi_host_template *tpnt)
 		}
 #endif
 
-		if (NCR5380_init(instance, flags))
+		if (NCR5380_init(instance, flags | FLAG_LATE_DMA_SETUP))
 			goto out_unregister;
 
 		switch (overrides[current_override].board) {

commit 6c4b88ca59ba1a68f707f19dba1744ed19e89fce
Author: Finn Thain <fthain@telegraphics.com.au>
Date:   Wed Mar 23 21:10:17 2016 +1100

    ncr5380: Use DMA hooks for PDMA
    
    Those wrapper drivers which use DMA define the REAL_DMA macro and
    those which use pseudo DMA define PSEUDO_DMA. These macros need to be
    removed for a number of reasons, not least of which is to have drivers
    share more code.
    
    Redefine the PDMA send and receive hooks as DMA setup hooks, so that the
    DMA code can be shared by all 5380 wrapper drivers. This will help to
    reunify the forked core driver.
    
    Signed-off-by: Finn Thain <fthain@telegraphics.com.au>
    Reviewed-by: Hannes Reinecke <hare@suse.com>
    Tested-by: Michael Schmitz <schmitzmic@gmail.com>
    Tested-by: Ondrej Zary <linux@rainbow-software.org>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/g_NCR5380.c b/drivers/scsi/g_NCR5380.c
index fc7bcbcf3f43..f8c00c96a837 100644
--- a/drivers/scsi/g_NCR5380.c
+++ b/drivers/scsi/g_NCR5380.c
@@ -551,7 +551,7 @@ static int generic_NCR5380_release_resources(struct Scsi_Host *instance)
 }
 
 /**
- *	NCR5380_pread		-	pseudo DMA read
+ *	generic_NCR5380_pread - pseudo DMA read
  *	@instance: adapter to read from
  *	@dst: buffer to read into
  *	@len: buffer length
@@ -560,7 +560,8 @@ static int generic_NCR5380_release_resources(struct Scsi_Host *instance)
  *	controller
  */
  
-static inline int NCR5380_pread(struct Scsi_Host *instance, unsigned char *dst, int len)
+static inline int generic_NCR5380_pread(struct Scsi_Host *instance,
+                                        unsigned char *dst, int len)
 {
 	struct NCR5380_hostdata *hostdata = shost_priv(instance);
 	int blocks = len / 128;
@@ -628,7 +629,7 @@ static inline int NCR5380_pread(struct Scsi_Host *instance, unsigned char *dst,
 }
 
 /**
- *	NCR5380_write		-	pseudo DMA write
+ *	generic_NCR5380_pwrite - pseudo DMA write
  *	@instance: adapter to read from
  *	@dst: buffer to read into
  *	@len: buffer length
@@ -637,7 +638,8 @@ static inline int NCR5380_pread(struct Scsi_Host *instance, unsigned char *dst,
  *	controller
  */
 
-static inline int NCR5380_pwrite(struct Scsi_Host *instance, unsigned char *src, int len)
+static inline int generic_NCR5380_pwrite(struct Scsi_Host *instance,
+                                         unsigned char *src, int len)
 {
 	struct NCR5380_hostdata *hostdata = shost_priv(instance);
 	int blocks = len / 128;

commit f825e40b235f4daf1c9017366809d34c7f5c8c7f
Author: Finn Thain <fthain@telegraphics.com.au>
Date:   Wed Mar 23 21:10:15 2016 +1100

    ncr5380: Remove PSEUDO_DMA macro
    
    For those wrapper drivers which only implement Programmed IO, have
    NCR5380_dma_xfer_len() evaluate to zero. That allows PDMA to be easily
    disabled at run-time and so the PSEUDO_DMA macro is no longer needed.
    
    Also remove the spin counters used for debugging pseudo DMA drivers.
    
    Signed-off-by: Finn Thain <fthain@telegraphics.com.au>
    Reviewed-by: Hannes Reinecke <hare@suse.com>
    Tested-by: Michael Schmitz <schmitzmic@gmail.com>
    Tested-by: Ondrej Zary <linux@rainbow-software.org>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/g_NCR5380.c b/drivers/scsi/g_NCR5380.c
index aaeb6b6b4b16..fc7bcbcf3f43 100644
--- a/drivers/scsi/g_NCR5380.c
+++ b/drivers/scsi/g_NCR5380.c
@@ -57,7 +57,6 @@
  */
 
 #define AUTOPROBE_IRQ
-#define PSEUDO_DMA
 
 #include <asm/io.h>
 #include <linux/blkdev.h>

commit 1bb4600245d4d40245dd505ca17528e0b9a9ba8c
Author: Finn Thain <fthain@telegraphics.com.au>
Date:   Wed Mar 23 21:10:14 2016 +1100

    ncr5380: Disable the DMA errata workaround flag by default
    
    The only chip that needs the workarounds enabled is an early NMOS
    device. That means that the common case is to disable them.
    
    Unfortunately the sense of the flag is such that it has to be set
    for the common case.
    
    Rename the flag so that zero can be used to mean "no errata workarounds
    needed". This simplifies the code.
    
    Signed-off-by: Finn Thain <fthain@telegraphics.com.au>
    Reviewed-by: Hannes Reinecke <hare@suse.com>
    Tested-by: Michael Schmitz <schmitzmic@gmail.com>
    Tested-by: Ondrej Zary <linux@rainbow-software.org>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/g_NCR5380.c b/drivers/scsi/g_NCR5380.c
index b8fc26d9231d..aaeb6b6b4b16 100644
--- a/drivers/scsi/g_NCR5380.c
+++ b/drivers/scsi/g_NCR5380.c
@@ -348,23 +348,17 @@ static int __init generic_NCR5380_detect(struct scsi_host_template *tpnt)
 		flags = 0;
 		switch (overrides[current_override].board) {
 		case BOARD_NCR5380:
-			flags = FLAG_NO_PSEUDO_DMA;
-			break;
-		case BOARD_NCR53C400:
-			flags = FLAG_NO_DMA_FIXUP;
+			flags = FLAG_NO_PSEUDO_DMA | FLAG_DMA_FIXUP;
 			break;
 		case BOARD_NCR53C400A:
-			flags = FLAG_NO_DMA_FIXUP;
 			ports = ncr_53c400a_ports;
 			magic = ncr_53c400a_magic;
 			break;
 		case BOARD_HP_C2502:
-			flags = FLAG_NO_DMA_FIXUP;
 			ports = ncr_53c400a_ports;
 			magic = hp_c2502_magic;
 			break;
 		case BOARD_DTC3181E:
-			flags = FLAG_NO_DMA_FIXUP;
 			ports = dtc_3181e_ports;
 			magic = ncr_53c400a_magic;
 			break;

commit 7e9ec8d9cc18a85e8a4c28aef9136867b46aba42
Author: Finn Thain <fthain@telegraphics.com.au>
Date:   Wed Mar 23 21:10:11 2016 +1100

    ncr5380: Remove FLAG_NO_PSEUDO_DMA where possible
    
    Drivers that define PSEUDO_DMA also define NCR5380_dma_xfer_len.
    The core driver must call NCR5380_dma_xfer_len which means
    FLAG_NO_PSEUDO_DMA can be eradicated from the core driver.
    
    dmx3191d doesn't define PSEUDO_DMA and has no use for FLAG_NO_PSEUDO_DMA,
    so remove it there also.
    
    Signed-off-by: Finn Thain <fthain@telegraphics.com.au>
    Reviewed-by: Hannes Reinecke <hare@suse.com>
    Tested-by: Michael Schmitz <schmitzmic@gmail.com>
    Tested-by: Ondrej Zary <linux@rainbow-software.org>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/g_NCR5380.c b/drivers/scsi/g_NCR5380.c
index 85ebe109d15d..b8fc26d9231d 100644
--- a/drivers/scsi/g_NCR5380.c
+++ b/drivers/scsi/g_NCR5380.c
@@ -712,10 +712,15 @@ static inline int NCR5380_pwrite(struct Scsi_Host *instance, unsigned char *src,
 	return 0;
 }
 
-static int generic_NCR5380_dma_xfer_len(struct scsi_cmnd *cmd)
+static int generic_NCR5380_dma_xfer_len(struct Scsi_Host *instance,
+                                        struct scsi_cmnd *cmd)
 {
+	struct NCR5380_hostdata *hostdata = shost_priv(instance);
 	int transfersize = cmd->transfersize;
 
+	if (hostdata->flags & FLAG_NO_PSEUDO_DMA)
+		return 0;
+
 	/* Limit transfers to 32K, for xx400 & xx406
 	 * pseudoDMA that transfers in 128 bytes blocks.
 	 */

commit 9d376402c80cfe2356d84577d366ca790e576bd9
Author: Finn Thain <fthain@telegraphics.com.au>
Date:   Wed Mar 23 21:10:10 2016 +1100

    g_ncr5380: Remove CONFIG_SCSI_GENERIC_NCR53C400
    
    This change brings a number of improvements: fewer macros, better test
    coverage, simpler code and sane Kconfig options. The downside is a small
    chance of incompatibility (which seems unavoidable).
    
    CONFIG_SCSI_GENERIC_NCR53C400 exists to enable or inhibit pseudo DMA
    transfers when the driver is used with 53C400-compatible cards. Thanks to
    Ondrej Zary's patches, PDMA now works which means it can be enabled
    unconditionally.
    
    Due to bad design, CONFIG_SCSI_GENERIC_NCR53C400 ties together unrelated
    functionality as it sets both PSEUDO_DMA and BIOSPARAM macros. This patch
    effectively enables PSEUDO_DMA and disables BIOSPARAM.
    
    The defconfigs and the Kconfig default leave CONFIG_SCSI_GENERIC_NCR53C400
    undefined. Red Hat 9 and CentOS 2.1 were the same. This leaves both
    PSEUDO_DMA and BIOSPARAM disabled. The effect of this patch should be
    better performance from enabling PSEUDO_DMA.
    
    On the other hand, Debian 4 and SLES 10 had CONFIG_SCSI_GENERIC_NCR53C400
    enabled, so both PSEUDO_DMA and BIOSPARAM were enabled. This patch might
    affect configurations like this by disabling BIOSPARAM. My best guess is
    that this could be a problem only in the vanishingly rare case that
    1) the CHS values stored in the boot device partition table are wrong and
    2) a 5380 card is in use (because PDMA on 53C400 used to be broken).
    
    Signed-off-by: Finn Thain <fthain@telegraphics.com.au>
    Reviewed-by: Hannes Reinecke <hare@suse.com>
    Tested-by: Ondrej Zary <linux@rainbow-software.org>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/g_NCR5380.c b/drivers/scsi/g_NCR5380.c
index 90091e693020..85ebe109d15d 100644
--- a/drivers/scsi/g_NCR5380.c
+++ b/drivers/scsi/g_NCR5380.c
@@ -57,10 +57,7 @@
  */
 
 #define AUTOPROBE_IRQ
-
-#ifdef CONFIG_SCSI_GENERIC_NCR53C400
 #define PSEUDO_DMA
-#endif
 
 #include <asm/io.h>
 #include <linux/blkdev.h>
@@ -270,7 +267,7 @@ static int __init generic_NCR5380_detect(struct scsi_host_template *tpnt)
 #ifndef SCSI_G_NCR5380_MEM
 	int i;
 	int port_idx = -1;
-	unsigned long region_size = 16;
+	unsigned long region_size;
 #endif
 	static unsigned int __initdata ncr_53c400a_ports[] = {
 		0x280, 0x290, 0x300, 0x310, 0x330, 0x340, 0x348, 0x350, 0
@@ -290,6 +287,7 @@ static int __init generic_NCR5380_detect(struct scsi_host_template *tpnt)
 #ifdef SCSI_G_NCR5380_MEM
 	unsigned long base;
 	void __iomem *iomem;
+	resource_size_t iomem_size;
 #endif
 
 	if (ncr_irq)
@@ -353,9 +351,7 @@ static int __init generic_NCR5380_detect(struct scsi_host_template *tpnt)
 			flags = FLAG_NO_PSEUDO_DMA;
 			break;
 		case BOARD_NCR53C400:
-#ifdef PSEUDO_DMA
 			flags = FLAG_NO_DMA_FIXUP;
-#endif
 			break;
 		case BOARD_NCR53C400A:
 			flags = FLAG_NO_DMA_FIXUP;
@@ -381,20 +377,22 @@ static int __init generic_NCR5380_detect(struct scsi_host_template *tpnt)
 			/* Disable the adapter and look for a free io port */
 			magic_configure(-1, 0, magic);
 
+			region_size = 16;
+
 			if (overrides[current_override].NCR5380_map_name != PORT_AUTO)
 				for (i = 0; ports[i]; i++) {
-					if (!request_region(ports[i],  16, "ncr53c80"))
+					if (!request_region(ports[i], region_size, "ncr53c80"))
 						continue;
 					if (overrides[current_override].NCR5380_map_name == ports[i])
 						break;
-					release_region(ports[i], 16);
+					release_region(ports[i], region_size);
 			} else
 				for (i = 0; ports[i]; i++) {
-					if (!request_region(ports[i],  16, "ncr53c80"))
+					if (!request_region(ports[i], region_size, "ncr53c80"))
 						continue;
 					if (inb(ports[i]) == 0xff)
 						break;
-					release_region(ports[i], 16);
+					release_region(ports[i], region_size);
 				}
 			if (ports[i]) {
 				/* At this point we have our region reserved */
@@ -410,17 +408,19 @@ static int __init generic_NCR5380_detect(struct scsi_host_template *tpnt)
 		else
 		{
 			/* Not a 53C400A style setup - just grab */
-			if(!(request_region(overrides[current_override].NCR5380_map_name, NCR5380_region_size, "ncr5380")))
+			region_size = 8;
+			if (!request_region(overrides[current_override].NCR5380_map_name,
+			                    region_size, "ncr5380"))
 				continue;
-			region_size = NCR5380_region_size;
 		}
 #else
 		base = overrides[current_override].NCR5380_map_name;
-		if (!request_mem_region(base, NCR5380_region_size, "ncr5380"))
+		iomem_size = NCR53C400_region_size;
+		if (!request_mem_region(base, iomem_size, "ncr5380"))
 			continue;
-		iomem = ioremap(base, NCR5380_region_size);
+		iomem = ioremap(base, iomem_size);
 		if (!iomem) {
-			release_mem_region(base, NCR5380_region_size);
+			release_mem_region(base, iomem_size);
 			continue;
 		}
 #endif
@@ -458,6 +458,7 @@ static int __init generic_NCR5380_detect(struct scsi_host_template *tpnt)
 #else
 		instance->base = overrides[current_override].NCR5380_map_name;
 		hostdata->iomem = iomem;
+		hostdata->iomem_size = iomem_size;
 		switch (overrides[current_override].board) {
 		case BOARD_NCR53C400:
 			hostdata->c400_ctl_status = 0x100;
@@ -524,7 +525,7 @@ static int __init generic_NCR5380_detect(struct scsi_host_template *tpnt)
 	release_region(overrides[current_override].NCR5380_map_name, region_size);
 #else
 	iounmap(iomem);
-	release_mem_region(base, NCR5380_region_size);
+	release_mem_region(base, iomem_size);
 #endif
 	return count;
 }
@@ -546,42 +547,15 @@ static int generic_NCR5380_release_resources(struct Scsi_Host *instance)
 #ifndef SCSI_G_NCR5380_MEM
 	release_region(instance->io_port, instance->n_io_port);
 #else
-	iounmap(((struct NCR5380_hostdata *)instance->hostdata)->iomem);
-	release_mem_region(instance->base, NCR5380_region_size);
-#endif
-	return 0;
-}
-
-#ifdef BIOSPARAM
-/**
- *	generic_NCR5380_biosparam
- *	@disk: disk to compute geometry for
- *	@dev: device identifier for this disk
- *	@ip: sizes to fill in
- *
- *	Generates a BIOS / DOS compatible H-C-S mapping for the specified 
- *	device / size.
- * 
- * 	XXX Most SCSI boards use this mapping, I could be incorrect.  Someone
- *	using hard disks on a trantor should verify that this mapping
- *	corresponds to that used by the BIOS / ASPI driver by running the linux
- *	fdisk program and matching the H_C_S coordinates to what DOS uses.
- *
- *	Locks: none
- */
+	{
+		struct NCR5380_hostdata *hostdata = shost_priv(instance);
 
-static int
-generic_NCR5380_biosparam(struct scsi_device *sdev, struct block_device *bdev,
-			  sector_t capacity, int *ip)
-{
-	ip[0] = 64;
-	ip[1] = 32;
-	ip[2] = capacity >> 11;
+		iounmap(hostdata->iomem);
+		release_mem_region(instance->base, hostdata->iomem_size);
+	}
+#endif
 	return 0;
 }
-#endif
-
-#ifdef PSEUDO_DMA
 
 /**
  *	NCR5380_pread		-	pseudo DMA read
@@ -756,8 +730,6 @@ static int generic_NCR5380_dma_xfer_len(struct scsi_cmnd *cmd)
 	return transfersize;
 }
 
-#endif /* PSEUDO_DMA */
-
 /*
  *	Include the NCR5380 core code that we build our driver around	
  */
@@ -773,7 +745,6 @@ static struct scsi_host_template driver_template = {
 	.queuecommand		= generic_NCR5380_queue_command,
 	.eh_abort_handler	= generic_NCR5380_abort,
 	.eh_bus_reset_handler	= generic_NCR5380_bus_reset,
-	.bios_param		= NCR5380_BIOSPARAM,
 	.can_queue		= 16,
 	.this_id		= 7,
 	.sg_tablesize		= SG_ALL,

commit c6084cbce435fbf800f47026896137b3bae483c3
Author: Ondrej Zary <linux@rainbow-software.org>
Date:   Sun Jan 3 16:06:19 2016 +1100

    ncr5380: Add support for HP C2502
    
    HP C2502 cards (based on 53C400A chips) use different magic numbers for
    software-based I/O address configuration than other cards.
    The configuration is also extended to allow setting the IRQ.
    
    Move the configuration to a new function magic_configure() and move
    magic the magic numbers into an array. Add new magic numbers for these
    HP cards and hp_c2502 module parameter to use them, e.g.:
    modprobe g_NCR5380 ncr_irq=7 ncr_addr=0x280 hp_c2502=1
    
    Tested with HP C2502 and DTCT-436P.
    
    Signed-off-by: Ondrej Zary <linux@rainbow-software.org>
    Signed-off-by: Finn Thain <fthain@telegraphics.com.au>
    Reviewed-by: Hannes Reinecke <hare@suse.com>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/g_NCR5380.c b/drivers/scsi/g_NCR5380.c
index 5030cc0dd90a..90091e693020 100644
--- a/drivers/scsi/g_NCR5380.c
+++ b/drivers/scsi/g_NCR5380.c
@@ -80,6 +80,7 @@ static int ncr_5380;
 static int ncr_53c400;
 static int ncr_53c400a;
 static int dtc_3181e;
+static int hp_c2502;
 
 static struct override {
 	NCR5380_map_type NCR5380_map_name;
@@ -225,6 +226,30 @@ static int __init do_DTC3181E_setup(char *str)
 
 #endif
 
+#ifndef SCSI_G_NCR5380_MEM
+/*
+ * Configure I/O address of 53C400A or DTC436 by writing magic numbers
+ * to ports 0x779 and 0x379.
+ */
+static void magic_configure(int idx, u8 irq, u8 magic[])
+{
+	u8 cfg = 0;
+
+	outb(magic[0], 0x779);
+	outb(magic[1], 0x379);
+	outb(magic[2], 0x379);
+	outb(magic[3], 0x379);
+	outb(magic[4], 0x379);
+
+	/* allowed IRQs for HP C2502 */
+	if (irq != 2 && irq != 3 && irq != 4 && irq != 5 && irq != 7)
+		irq = 0;
+	if (idx >= 0 && idx <= 7)
+		cfg = 0x80 | idx | (irq << 4);
+	outb(cfg, 0x379);
+}
+#endif
+
 /**
  * 	generic_NCR5380_detect	-	look for NCR5380 controllers
  *	@tpnt: the scsi template
@@ -241,8 +266,10 @@ static int __init generic_NCR5380_detect(struct scsi_host_template *tpnt)
 	static int current_override;
 	int count;
 	unsigned int *ports;
+	u8 *magic = NULL;
 #ifndef SCSI_G_NCR5380_MEM
 	int i;
+	int port_idx = -1;
 	unsigned long region_size = 16;
 #endif
 	static unsigned int __initdata ncr_53c400a_ports[] = {
@@ -251,6 +278,12 @@ static int __init generic_NCR5380_detect(struct scsi_host_template *tpnt)
 	static unsigned int __initdata dtc_3181e_ports[] = {
 		0x220, 0x240, 0x280, 0x2a0, 0x2c0, 0x300, 0x320, 0x340, 0
 	};
+	static u8 ncr_53c400a_magic[] __initdata = {	/* 53C400A & DTC436 */
+		0x59, 0xb9, 0xc5, 0xae, 0xa6
+	};
+	static u8 hp_c2502_magic[] __initdata = {	/* HP C2502 */
+		0x0f, 0x22, 0xf0, 0x20, 0x80
+	};
 	int flags;
 	struct Scsi_Host *instance;
 	struct NCR5380_hostdata *hostdata;
@@ -273,6 +306,8 @@ static int __init generic_NCR5380_detect(struct scsi_host_template *tpnt)
 		overrides[0].board = BOARD_NCR53C400A;
 	else if (dtc_3181e)
 		overrides[0].board = BOARD_DTC3181E;
+	else if (hp_c2502)
+		overrides[0].board = BOARD_HP_C2502;
 #ifndef SCSI_G_NCR5380_MEM
 	if (!current_override && isapnp_present()) {
 		struct pnp_dev *dev = NULL;
@@ -325,24 +360,26 @@ static int __init generic_NCR5380_detect(struct scsi_host_template *tpnt)
 		case BOARD_NCR53C400A:
 			flags = FLAG_NO_DMA_FIXUP;
 			ports = ncr_53c400a_ports;
+			magic = ncr_53c400a_magic;
+			break;
+		case BOARD_HP_C2502:
+			flags = FLAG_NO_DMA_FIXUP;
+			ports = ncr_53c400a_ports;
+			magic = hp_c2502_magic;
 			break;
 		case BOARD_DTC3181E:
 			flags = FLAG_NO_DMA_FIXUP;
 			ports = dtc_3181e_ports;
+			magic = ncr_53c400a_magic;
 			break;
 		}
 
 #ifndef SCSI_G_NCR5380_MEM
-		if (ports) {
+		if (ports && magic) {
 			/* wakeup sequence for the NCR53C400A and DTC3181E */
 
 			/* Disable the adapter and look for a free io port */
-			outb(0x59, 0x779);
-			outb(0xb9, 0x379);
-			outb(0xc5, 0x379);
-			outb(0xae, 0x379);
-			outb(0xa6, 0x379);
-			outb(0x00, 0x379);
+			magic_configure(-1, 0, magic);
 
 			if (overrides[current_override].NCR5380_map_name != PORT_AUTO)
 				for (i = 0; ports[i]; i++) {
@@ -361,17 +398,12 @@ static int __init generic_NCR5380_detect(struct scsi_host_template *tpnt)
 				}
 			if (ports[i]) {
 				/* At this point we have our region reserved */
-				outb(0x59, 0x779);
-				outb(0xb9, 0x379);
-				outb(0xc5, 0x379);
-				outb(0xae, 0x379);
-				outb(0xa6, 0x379);
-				outb(0x80 | i, 0x379);	/* set io port to be used */
+				magic_configure(i, 0, magic); /* no IRQ yet */
 				outb(0xc0, ports[i] + 9);
 				if (inb(ports[i] + 9) != 0x80)
 					continue;
-				else
-					overrides[current_override].NCR5380_map_name = ports[i];
+				overrides[current_override].NCR5380_map_name = ports[i];
+				port_idx = i;
 			} else
 				continue;
 		}
@@ -417,6 +449,7 @@ static int __init generic_NCR5380_detect(struct scsi_host_template *tpnt)
 			hostdata->io_width = 2;	/* 16-bit PDMA */
 			/* fall through */
 		case BOARD_NCR53C400A:
+		case BOARD_HP_C2502:
 			hostdata->c400_ctl_status = 9;
 			hostdata->c400_blk_cnt = 10;
 			hostdata->c400_host_buf = 8;
@@ -433,6 +466,7 @@ static int __init generic_NCR5380_detect(struct scsi_host_template *tpnt)
 			break;
 		case BOARD_DTC3181E:
 		case BOARD_NCR53C400A:
+		case BOARD_HP_C2502:
 			pr_err(DRV_MODULE_NAME ": unknown register offsets\n");
 			goto out_unregister;
 		}
@@ -445,6 +479,7 @@ static int __init generic_NCR5380_detect(struct scsi_host_template *tpnt)
 		case BOARD_NCR53C400:
 		case BOARD_DTC3181E:
 		case BOARD_NCR53C400A:
+		case BOARD_HP_C2502:
 			NCR5380_write(hostdata->c400_ctl_status, CSR_BASE);
 		}
 
@@ -459,12 +494,18 @@ static int __init generic_NCR5380_detect(struct scsi_host_template *tpnt)
 		if (instance->irq == 255)
 			instance->irq = NO_IRQ;
 
-		if (instance->irq != NO_IRQ)
+		if (instance->irq != NO_IRQ) {
+#ifndef SCSI_G_NCR5380_MEM
+			/* set IRQ for HP C2502 */
+			if (overrides[current_override].board == BOARD_HP_C2502)
+				magic_configure(port_idx, instance->irq, magic);
+#endif
 			if (request_irq(instance->irq, generic_NCR5380_intr,
 					0, "NCR5380", instance)) {
 				printk(KERN_WARNING "scsi%d : IRQ%d not free, interrupts disabled\n", instance->host_no, instance->irq);
 				instance->irq = NO_IRQ;
 			}
+		}
 
 		if (instance->irq == NO_IRQ) {
 			printk(KERN_INFO "scsi%d : interrupts not enabled. for better interactive performance,\n", instance->host_no);
@@ -751,6 +792,7 @@ module_param(ncr_5380, int, 0);
 module_param(ncr_53c400, int, 0);
 module_param(ncr_53c400a, int, 0);
 module_param(dtc_3181e, int, 0);
+module_param(hp_c2502, int, 0);
 MODULE_LICENSE("GPL");
 
 #if !defined(SCSI_G_NCR5380_MEM) && defined(MODULE)

commit 42fc6370c95df507b925b11372e8baa17eb0da41
Author: Ondrej Zary <linux@rainbow-software.org>
Date:   Sun Jan 3 16:06:18 2016 +1100

    ncr5380: Fix wait for 53C80 registers registers after PDMA
    
    The check for 53C80 registers accessibility was commented out because
    it was broken (inverted). Fix and enable it.
    
    Signed-off-by: Ondrej Zary <linux@rainbow-software.org>
    Signed-off-by: Finn Thain <fthain@telegraphics.com.au>
    Reviewed-by: Hannes Reinecke <hare@suse.com>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/g_NCR5380.c b/drivers/scsi/g_NCR5380.c
index 87060c49693b..5030cc0dd90a 100644
--- a/drivers/scsi/g_NCR5380.c
+++ b/drivers/scsi/g_NCR5380.c
@@ -609,14 +609,10 @@ static inline int NCR5380_pread(struct Scsi_Host *instance, unsigned char *dst,
 	if (!(NCR5380_read(hostdata->c400_ctl_status) & CSR_GATED_53C80_IRQ))
 		printk("53C400r: no 53C80 gated irq after transfer");
 
-#if 0
-	/*
-	 *	DON'T DO THIS - THEY NEVER ARRIVE!
-	 */
-	printk("53C400r: Waiting for 53C80 registers\n");
-	while (NCR5380_read(hostdata->c400_ctl_status) & CSR_53C80_REG)
+	/* wait for 53C80 registers to be available */
+	while (!(NCR5380_read(hostdata->c400_ctl_status) & CSR_53C80_REG))
 		;
-#endif
+
 	if (!(NCR5380_read(BUS_AND_STATUS_REG) & BASR_END_DMA_TRANSFER))
 		printk(KERN_ERR "53C400r: no end dma signal\n");
 		
@@ -638,7 +634,6 @@ static inline int NCR5380_pwrite(struct Scsi_Host *instance, unsigned char *src,
 	struct NCR5380_hostdata *hostdata = shost_priv(instance);
 	int blocks = len / 128;
 	int start = 0;
-	int i;
 
 	NCR5380_write(hostdata->c400_ctl_status, CSR_BASE);
 	NCR5380_write(hostdata->c400_blk_cnt, blocks);
@@ -687,36 +682,16 @@ static inline int NCR5380_pwrite(struct Scsi_Host *instance, unsigned char *src,
 		blocks--;
 	}
 
-#if 0
-	printk("53C400w: waiting for registers to be available\n");
-	THEY NEVER DO ! while (NCR5380_read(hostdata->c400_ctl_status) & CSR_53C80_REG);
-	printk("53C400w: Got em\n");
-#endif
-
-	/* Let's wait for this instead - could be ugly */
-	/* All documentation says to check for this. Maybe my hardware is too
-	 * fast. Waiting for it seems to work fine! KLL
-	 */
-	while (!(i = NCR5380_read(hostdata->c400_ctl_status) & CSR_GATED_53C80_IRQ)) {
+	/* wait for 53C80 registers to be available */
+	while (!(NCR5380_read(hostdata->c400_ctl_status) & CSR_53C80_REG)) {
 		udelay(4); /* DTC436 chip hangs without this */
 		/* FIXME - no timeout */
 	}
 
-	/*
-	 * I know. i is certainly != 0 here but the loop is new. See previous
-	 * comment.
-	 */
-	if (i) {
-		if (!((i = NCR5380_read(BUS_AND_STATUS_REG)) & BASR_END_DMA_TRANSFER))
-			printk(KERN_ERR "53C400w: No END OF DMA bit - WHOOPS! BASR=%0x\n", i);
-	} else
-		printk(KERN_ERR "53C400w: no 53C80 gated irq after transfer (last block)\n");
-
-#if 0
 	if (!(NCR5380_read(BUS_AND_STATUS_REG) & BASR_END_DMA_TRANSFER)) {
 		printk(KERN_ERR "53C400w: no end dma signal\n");
 	}
-#endif
+
 	while (!(NCR5380_read(TARGET_COMMAND_REG) & TCR_LAST_BYTE_SENT))
 		; 	// TIMEOUT
 	return 0;

commit aeb51152bb55451f7a3ddb8c1ec4d4bc19d4a195
Author: Ondrej Zary <linux@rainbow-software.org>
Date:   Sun Jan 3 16:06:17 2016 +1100

    ncr5380: Enable PDMA for DTC chips
    
    Add I/O register mapping for DTC chips and enable PDMA mode.
    
    These chips have 16-bit wide HOST BUFFER register and it must be read
    by 16-bit accesses (we lose data otherwise).
    
    Large PIO transfers crash at least the DTCT-436P chip (all reads result
    in 0xFF) so this patch actually makes it work.
    
    The chip also crashes when we bang on the C400 host status register too
    heavily after PDMA write - a small udelay is needed.
    
    Tested on DTCT-436P and verified that it does not break 53C400A.
    
    Signed-off-by: Ondrej Zary <linux@rainbow-software.org>
    Signed-off-by: Finn Thain <fthain@telegraphics.com.au>
    Reviewed-by: Hannes Reinecke <hare@suse.com>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/g_NCR5380.c b/drivers/scsi/g_NCR5380.c
index 53e437744c4f..87060c49693b 100644
--- a/drivers/scsi/g_NCR5380.c
+++ b/drivers/scsi/g_NCR5380.c
@@ -327,7 +327,7 @@ static int __init generic_NCR5380_detect(struct scsi_host_template *tpnt)
 			ports = ncr_53c400a_ports;
 			break;
 		case BOARD_DTC3181E:
-			flags = FLAG_NO_PSEUDO_DMA;
+			flags = FLAG_NO_DMA_FIXUP;
 			ports = dtc_3181e_ports;
 			break;
 		}
@@ -400,6 +400,7 @@ static int __init generic_NCR5380_detect(struct scsi_host_template *tpnt)
 #ifndef SCSI_G_NCR5380_MEM
 		instance->io_port = overrides[current_override].NCR5380_map_name;
 		instance->n_io_port = region_size;
+		hostdata->io_width = 1; /* 8-bit PDMA by default */
 
 		/*
 		 * On NCR53C400 boards, NCR5380 registers are mapped 8 past
@@ -412,6 +413,9 @@ static int __init generic_NCR5380_detect(struct scsi_host_template *tpnt)
 			hostdata->c400_blk_cnt = 1;
 			hostdata->c400_host_buf = 4;
 			break;
+		case BOARD_DTC3181E:
+			hostdata->io_width = 2;	/* 16-bit PDMA */
+			/* fall through */
 		case BOARD_NCR53C400A:
 			hostdata->c400_ctl_status = 9;
 			hostdata->c400_blk_cnt = 10;
@@ -427,6 +431,7 @@ static int __init generic_NCR5380_detect(struct scsi_host_template *tpnt)
 			hostdata->c400_blk_cnt = 0x101;
 			hostdata->c400_host_buf = 0x104;
 			break;
+		case BOARD_DTC3181E:
 		case BOARD_NCR53C400A:
 			pr_err(DRV_MODULE_NAME ": unknown register offsets\n");
 			goto out_unregister;
@@ -438,6 +443,7 @@ static int __init generic_NCR5380_detect(struct scsi_host_template *tpnt)
 
 		switch (overrides[current_override].board) {
 		case BOARD_NCR53C400:
+		case BOARD_DTC3181E:
 		case BOARD_NCR53C400A:
 			NCR5380_write(hostdata->c400_ctl_status, CSR_BASE);
 		}
@@ -565,7 +571,11 @@ static inline int NCR5380_pread(struct Scsi_Host *instance, unsigned char *dst,
 			; /* FIXME - no timeout */
 
 #ifndef SCSI_G_NCR5380_MEM
-		insb(instance->io_port + hostdata->c400_host_buf,
+		if (hostdata->io_width == 2)
+			insw(instance->io_port + hostdata->c400_host_buf,
+							dst + start, 64);
+		else
+			insb(instance->io_port + hostdata->c400_host_buf,
 							dst + start, 128);
 #else
 		/* implies SCSI_G_NCR5380_MEM */
@@ -581,7 +591,11 @@ static inline int NCR5380_pread(struct Scsi_Host *instance, unsigned char *dst,
 			; /* FIXME - no timeout */
 
 #ifndef SCSI_G_NCR5380_MEM
-		insb(instance->io_port + hostdata->c400_host_buf,
+		if (hostdata->io_width == 2)
+			insw(instance->io_port + hostdata->c400_host_buf,
+							dst + start, 64);
+		else
+			insb(instance->io_port + hostdata->c400_host_buf,
 							dst + start, 128);
 #else
 		/* implies SCSI_G_NCR5380_MEM */
@@ -639,7 +653,11 @@ static inline int NCR5380_pwrite(struct Scsi_Host *instance, unsigned char *src,
 		while (NCR5380_read(hostdata->c400_ctl_status) & CSR_HOST_BUF_NOT_RDY)
 			; // FIXME - timeout
 #ifndef SCSI_G_NCR5380_MEM
-		outsb(instance->io_port + hostdata->c400_host_buf,
+		if (hostdata->io_width == 2)
+			outsw(instance->io_port + hostdata->c400_host_buf,
+							src + start, 64);
+		else
+			outsb(instance->io_port + hostdata->c400_host_buf,
 							src + start, 128);
 #else
 		/* implies SCSI_G_NCR5380_MEM */
@@ -654,7 +672,11 @@ static inline int NCR5380_pwrite(struct Scsi_Host *instance, unsigned char *src,
 			; // FIXME - no timeout
 
 #ifndef SCSI_G_NCR5380_MEM
-		outsb(instance->io_port + hostdata->c400_host_buf,
+		if (hostdata->io_width == 2)
+			outsw(instance->io_port + hostdata->c400_host_buf,
+							src + start, 64);
+		else
+			outsb(instance->io_port + hostdata->c400_host_buf,
 							src + start, 128);
 #else
 		/* implies SCSI_G_NCR5380_MEM */
@@ -675,8 +697,10 @@ static inline int NCR5380_pwrite(struct Scsi_Host *instance, unsigned char *src,
 	/* All documentation says to check for this. Maybe my hardware is too
 	 * fast. Waiting for it seems to work fine! KLL
 	 */
-	while (!(i = NCR5380_read(hostdata->c400_ctl_status) & CSR_GATED_53C80_IRQ))
-		;	// FIXME - no timeout
+	while (!(i = NCR5380_read(hostdata->c400_ctl_status) & CSR_GATED_53C80_IRQ)) {
+		udelay(4); /* DTC436 chip hangs without this */
+		/* FIXME - no timeout */
+	}
 
 	/*
 	 * I know. i is certainly != 0 here but the loop is new. See previous

commit cecf3beef0ef311b5b375b6307fd5dc3f5dc3edb
Author: Ondrej Zary <linux@rainbow-software.org>
Date:   Sun Jan 3 16:06:16 2016 +1100

    ncr5380: Enable PDMA for NCR53C400A
    
    Add I/O register mapping for NCR53C400A and enable PDMA mode to
    improve performance and fix non-working IRQ.
    
    Tested with HP C2502 (and user-space enabler).
    
    Signed-off-by: Ondrej Zary <linux@rainbow-software.org>
    Signed-off-by: Finn Thain <fthain@telegraphics.com.au>
    Reviewed-by: Hannes Reinecke <hare@suse.com>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/g_NCR5380.c b/drivers/scsi/g_NCR5380.c
index ddc0a18974d4..53e437744c4f 100644
--- a/drivers/scsi/g_NCR5380.c
+++ b/drivers/scsi/g_NCR5380.c
@@ -323,7 +323,7 @@ static int __init generic_NCR5380_detect(struct scsi_host_template *tpnt)
 #endif
 			break;
 		case BOARD_NCR53C400A:
-			flags = FLAG_NO_PSEUDO_DMA;
+			flags = FLAG_NO_DMA_FIXUP;
 			ports = ncr_53c400a_ports;
 			break;
 		case BOARD_DTC3181E:
@@ -405,27 +405,42 @@ static int __init generic_NCR5380_detect(struct scsi_host_template *tpnt)
 		 * On NCR53C400 boards, NCR5380 registers are mapped 8 past
 		 * the base address.
 		 */
-		if (overrides[current_override].board == BOARD_NCR53C400) {
+		switch (overrides[current_override].board) {
+		case BOARD_NCR53C400:
 			instance->io_port += 8;
 			hostdata->c400_ctl_status = 0;
 			hostdata->c400_blk_cnt = 1;
 			hostdata->c400_host_buf = 4;
+			break;
+		case BOARD_NCR53C400A:
+			hostdata->c400_ctl_status = 9;
+			hostdata->c400_blk_cnt = 10;
+			hostdata->c400_host_buf = 8;
+			break;
 		}
 #else
 		instance->base = overrides[current_override].NCR5380_map_name;
 		hostdata->iomem = iomem;
-		if (overrides[current_override].board == BOARD_NCR53C400) {
+		switch (overrides[current_override].board) {
+		case BOARD_NCR53C400:
 			hostdata->c400_ctl_status = 0x100;
 			hostdata->c400_blk_cnt = 0x101;
 			hostdata->c400_host_buf = 0x104;
+			break;
+		case BOARD_NCR53C400A:
+			pr_err(DRV_MODULE_NAME ": unknown register offsets\n");
+			goto out_unregister;
 		}
 #endif
 
 		if (NCR5380_init(instance, flags))
 			goto out_unregister;
 
-		if (overrides[current_override].board == BOARD_NCR53C400)
+		switch (overrides[current_override].board) {
+		case BOARD_NCR53C400:
+		case BOARD_NCR53C400A:
 			NCR5380_write(hostdata->c400_ctl_status, CSR_BASE);
+		}
 
 		NCR5380_maybe_reset_bus(instance);
 

commit 12150797d064e2936154a8c01be24ce1b0115cfe
Author: Ondrej Zary <linux@rainbow-software.org>
Date:   Sun Jan 3 16:06:15 2016 +1100

    ncr5380: Use runtime register mapping
    
    Convert compile-time C400_ register mapping to runtime mapping.
    This removes the weird negative register offsets and allows adding
    additional mappings.
    
    While at it, convert read/write loops into insb/outsb.
    
    Signed-off-by: Ondrej Zary <linux@rainbow-software.org>
    Signed-off-by: Finn Thain <fthain@telegraphics.com.au>
    Reviewed-by: Hannes Reinecke <hare@suse.com>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/g_NCR5380.c b/drivers/scsi/g_NCR5380.c
index 454b565c0417..ddc0a18974d4 100644
--- a/drivers/scsi/g_NCR5380.c
+++ b/drivers/scsi/g_NCR5380.c
@@ -253,6 +253,7 @@ static int __init generic_NCR5380_detect(struct scsi_host_template *tpnt)
 	};
 	int flags;
 	struct Scsi_Host *instance;
+	struct NCR5380_hostdata *hostdata;
 #ifdef SCSI_G_NCR5380_MEM
 	unsigned long base;
 	void __iomem *iomem;
@@ -394,6 +395,7 @@ static int __init generic_NCR5380_detect(struct scsi_host_template *tpnt)
 		instance = scsi_register(tpnt, sizeof(struct NCR5380_hostdata));
 		if (instance == NULL)
 			goto out_release;
+		hostdata = shost_priv(instance);
 
 #ifndef SCSI_G_NCR5380_MEM
 		instance->io_port = overrides[current_override].NCR5380_map_name;
@@ -403,18 +405,27 @@ static int __init generic_NCR5380_detect(struct scsi_host_template *tpnt)
 		 * On NCR53C400 boards, NCR5380 registers are mapped 8 past
 		 * the base address.
 		 */
-		if (overrides[current_override].board == BOARD_NCR53C400)
+		if (overrides[current_override].board == BOARD_NCR53C400) {
 			instance->io_port += 8;
+			hostdata->c400_ctl_status = 0;
+			hostdata->c400_blk_cnt = 1;
+			hostdata->c400_host_buf = 4;
+		}
 #else
 		instance->base = overrides[current_override].NCR5380_map_name;
-		((struct NCR5380_hostdata *)instance->hostdata)->iomem = iomem;
+		hostdata->iomem = iomem;
+		if (overrides[current_override].board == BOARD_NCR53C400) {
+			hostdata->c400_ctl_status = 0x100;
+			hostdata->c400_blk_cnt = 0x101;
+			hostdata->c400_host_buf = 0x104;
+		}
 #endif
 
 		if (NCR5380_init(instance, flags))
 			goto out_unregister;
 
 		if (overrides[current_override].board == BOARD_NCR53C400)
-			NCR5380_write(C400_CONTROL_STATUS_REG, CSR_BASE);
+			NCR5380_write(hostdata->c400_ctl_status, CSR_BASE);
 
 		NCR5380_maybe_reset_bus(instance);
 
@@ -522,31 +533,25 @@ generic_NCR5380_biosparam(struct scsi_device *sdev, struct block_device *bdev,
  
 static inline int NCR5380_pread(struct Scsi_Host *instance, unsigned char *dst, int len)
 {
-#ifdef SCSI_G_NCR5380_MEM
 	struct NCR5380_hostdata *hostdata = shost_priv(instance);
-#endif
 	int blocks = len / 128;
 	int start = 0;
-	int bl;
 
-	NCR5380_write(C400_CONTROL_STATUS_REG, CSR_BASE | CSR_TRANS_DIR);
-	NCR5380_write(C400_BLOCK_COUNTER_REG, blocks);
+	NCR5380_write(hostdata->c400_ctl_status, CSR_BASE | CSR_TRANS_DIR);
+	NCR5380_write(hostdata->c400_blk_cnt, blocks);
 	while (1) {
-		if ((bl = NCR5380_read(C400_BLOCK_COUNTER_REG)) == 0) {
+		if (NCR5380_read(hostdata->c400_blk_cnt) == 0)
 			break;
-		}
-		if (NCR5380_read(C400_CONTROL_STATUS_REG) & CSR_GATED_53C80_IRQ) {
+		if (NCR5380_read(hostdata->c400_ctl_status) & CSR_GATED_53C80_IRQ) {
 			printk(KERN_ERR "53C400r: Got 53C80_IRQ start=%d, blocks=%d\n", start, blocks);
 			return -1;
 		}
-		while (NCR5380_read(C400_CONTROL_STATUS_REG) & CSR_HOST_BUF_NOT_RDY);
+		while (NCR5380_read(hostdata->c400_ctl_status) & CSR_HOST_BUF_NOT_RDY)
+			; /* FIXME - no timeout */
 
 #ifndef SCSI_G_NCR5380_MEM
-		{
-			int i;
-			for (i = 0; i < 128; i++)
-				dst[start + i] = NCR5380_read(C400_HOST_BUFFER);
-		}
+		insb(instance->io_port + hostdata->c400_host_buf,
+							dst + start, 128);
 #else
 		/* implies SCSI_G_NCR5380_MEM */
 		memcpy_fromio(dst + start,
@@ -557,17 +562,12 @@ static inline int NCR5380_pread(struct Scsi_Host *instance, unsigned char *dst,
 	}
 
 	if (blocks) {
-		while (NCR5380_read(C400_CONTROL_STATUS_REG) & CSR_HOST_BUF_NOT_RDY)
-		{
-			// FIXME - no timeout
-		}
+		while (NCR5380_read(hostdata->c400_ctl_status) & CSR_HOST_BUF_NOT_RDY)
+			; /* FIXME - no timeout */
 
 #ifndef SCSI_G_NCR5380_MEM
-		{
-			int i;	
-			for (i = 0; i < 128; i++)
-				dst[start + i] = NCR5380_read(C400_HOST_BUFFER);
-		}
+		insb(instance->io_port + hostdata->c400_host_buf,
+							dst + start, 128);
 #else
 		/* implies SCSI_G_NCR5380_MEM */
 		memcpy_fromio(dst + start,
@@ -577,7 +577,7 @@ static inline int NCR5380_pread(struct Scsi_Host *instance, unsigned char *dst,
 		blocks--;
 	}
 
-	if (!(NCR5380_read(C400_CONTROL_STATUS_REG) & CSR_GATED_53C80_IRQ))
+	if (!(NCR5380_read(hostdata->c400_ctl_status) & CSR_GATED_53C80_IRQ))
 		printk("53C400r: no 53C80 gated irq after transfer");
 
 #if 0
@@ -585,7 +585,7 @@ static inline int NCR5380_pread(struct Scsi_Host *instance, unsigned char *dst,
 	 *	DON'T DO THIS - THEY NEVER ARRIVE!
 	 */
 	printk("53C400r: Waiting for 53C80 registers\n");
-	while (NCR5380_read(C400_CONTROL_STATUS_REG) & CSR_53C80_REG)
+	while (NCR5380_read(hostdata->c400_ctl_status) & CSR_53C80_REG)
 		;
 #endif
 	if (!(NCR5380_read(BUS_AND_STATUS_REG) & BASR_END_DMA_TRANSFER))
@@ -606,32 +606,26 @@ static inline int NCR5380_pread(struct Scsi_Host *instance, unsigned char *dst,
 
 static inline int NCR5380_pwrite(struct Scsi_Host *instance, unsigned char *src, int len)
 {
-#ifdef SCSI_G_NCR5380_MEM
 	struct NCR5380_hostdata *hostdata = shost_priv(instance);
-#endif
 	int blocks = len / 128;
 	int start = 0;
-	int bl;
 	int i;
 
-	NCR5380_write(C400_CONTROL_STATUS_REG, CSR_BASE);
-	NCR5380_write(C400_BLOCK_COUNTER_REG, blocks);
+	NCR5380_write(hostdata->c400_ctl_status, CSR_BASE);
+	NCR5380_write(hostdata->c400_blk_cnt, blocks);
 	while (1) {
-		if (NCR5380_read(C400_CONTROL_STATUS_REG) & CSR_GATED_53C80_IRQ) {
+		if (NCR5380_read(hostdata->c400_ctl_status) & CSR_GATED_53C80_IRQ) {
 			printk(KERN_ERR "53C400w: Got 53C80_IRQ start=%d, blocks=%d\n", start, blocks);
 			return -1;
 		}
 
-		if ((bl = NCR5380_read(C400_BLOCK_COUNTER_REG)) == 0) {
+		if (NCR5380_read(hostdata->c400_blk_cnt) == 0)
 			break;
-		}
-		while (NCR5380_read(C400_CONTROL_STATUS_REG) & CSR_HOST_BUF_NOT_RDY)
+		while (NCR5380_read(hostdata->c400_ctl_status) & CSR_HOST_BUF_NOT_RDY)
 			; // FIXME - timeout
 #ifndef SCSI_G_NCR5380_MEM
-		{
-			for (i = 0; i < 128; i++)
-				NCR5380_write(C400_HOST_BUFFER, src[start + i]);
-		}
+		outsb(instance->io_port + hostdata->c400_host_buf,
+							src + start, 128);
 #else
 		/* implies SCSI_G_NCR5380_MEM */
 		memcpy_toio(hostdata->iomem + NCR53C400_host_buffer,
@@ -641,14 +635,12 @@ static inline int NCR5380_pwrite(struct Scsi_Host *instance, unsigned char *src,
 		blocks--;
 	}
 	if (blocks) {
-		while (NCR5380_read(C400_CONTROL_STATUS_REG) & CSR_HOST_BUF_NOT_RDY)
+		while (NCR5380_read(hostdata->c400_ctl_status) & CSR_HOST_BUF_NOT_RDY)
 			; // FIXME - no timeout
 
 #ifndef SCSI_G_NCR5380_MEM
-		{
-			for (i = 0; i < 128; i++)
-				NCR5380_write(C400_HOST_BUFFER, src[start + i]);
-		}
+		outsb(instance->io_port + hostdata->c400_host_buf,
+							src + start, 128);
 #else
 		/* implies SCSI_G_NCR5380_MEM */
 		memcpy_toio(hostdata->iomem + NCR53C400_host_buffer,
@@ -660,7 +652,7 @@ static inline int NCR5380_pwrite(struct Scsi_Host *instance, unsigned char *src,
 
 #if 0
 	printk("53C400w: waiting for registers to be available\n");
-	THEY NEVER DO ! while (NCR5380_read(C400_CONTROL_STATUS_REG) & CSR_53C80_REG);
+	THEY NEVER DO ! while (NCR5380_read(hostdata->c400_ctl_status) & CSR_53C80_REG);
 	printk("53C400w: Got em\n");
 #endif
 
@@ -668,7 +660,7 @@ static inline int NCR5380_pwrite(struct Scsi_Host *instance, unsigned char *src,
 	/* All documentation says to check for this. Maybe my hardware is too
 	 * fast. Waiting for it seems to work fine! KLL
 	 */
-	while (!(i = NCR5380_read(C400_CONTROL_STATUS_REG) & CSR_GATED_53C80_IRQ))
+	while (!(i = NCR5380_read(hostdata->c400_ctl_status) & CSR_GATED_53C80_IRQ))
 		;	// FIXME - no timeout
 
 	/*

commit f03946210d67be9a33ad63f6a0eed7cdf8c28334
Author: Ondrej Zary <linux@rainbow-software.org>
Date:   Sun Jan 3 16:06:14 2016 +1100

    ncr5380: Fix pseudo DMA transfers on 53C400
    
    Pseudo-DMA (PDMA) has been broken for ages, resulting in hangs on
    53C400-based cards.
    
    According to 53C400 datasheet, PDMA transfer length must be a multiple
    of 128. Check if that's true and use PIO if it's not.
    
    This makes PDMA work on 53C400 (Canon FG2-5202).
    
    Signed-off-by: Ondrej Zary <linux@rainbow-software.org>
    Signed-off-by: Finn Thain <fthain@telegraphics.com.au>
    Reviewed-by: Hannes Reinecke <hare@suse.com>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/g_NCR5380.c b/drivers/scsi/g_NCR5380.c
index cd79ef402d7a..454b565c0417 100644
--- a/drivers/scsi/g_NCR5380.c
+++ b/drivers/scsi/g_NCR5380.c
@@ -702,6 +702,10 @@ static int generic_NCR5380_dma_xfer_len(struct scsi_cmnd *cmd)
 	    !(cmd->SCp.this_residual % transfersize))
 		transfersize = 32 * 1024;
 
+	/* 53C400 datasheet: non-modulo-128-byte transfers should use PIO */
+	if (transfersize % 128)
+		transfersize = 0;
+
 	return transfersize;
 }
 

commit 0a4e36125451165847c6d4e7d5633d92e53f5c69
Author: Finn Thain <fthain@telegraphics.com.au>
Date:   Sun Jan 3 16:06:07 2016 +1100

    ncr5380: Fix soft lockups
    
    Because of the rudimentary design of the chip, it is necessary to poll the
    SCSI bus signals during PIO and this tends to hog the CPU. The driver will
    accept new commands while others execute, and this causes a soft lockup
    because the workqueue item will not terminate until the issue queue is
    emptied.
    
    When exercising dmx3191d using sequential IO from dd, the driver is sent
    512 KiB WRITE commands and 128 KiB READs. For a PIO transfer, the rate is
    is only about 300 KiB/s, so these are long-running commands. And although
    PDMA may run at several MiB/s, interrupts are disabled for the duration
    of the transfer.
    
    Fix the unresponsiveness and soft lockup issues by calling cond_resched()
    after each command is completed and by limiting max_sectors for drivers
    that don't implement real DMA.
    
    Signed-off-by: Finn Thain <fthain@telegraphics.com.au>
    Reviewed-by: Hannes Reinecke <hare@suse.com>
    Tested-by: Ondrej Zary <linux@rainbow-software.org>
    Tested-by: Michael Schmitz <schmitzmic@gmail.com>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/g_NCR5380.c b/drivers/scsi/g_NCR5380.c
index 30472064170e..cd79ef402d7a 100644
--- a/drivers/scsi/g_NCR5380.c
+++ b/drivers/scsi/g_NCR5380.c
@@ -729,6 +729,7 @@ static struct scsi_host_template driver_template = {
 	.cmd_per_lun		= 2,
 	.use_clustering		= DISABLE_CLUSTERING,
 	.cmd_size		= NCR5380_CMD_SIZE,
+	.max_sectors		= 128,
 };
 
 #include "scsi_module.c"

commit 32b26a104237c1ba3575a6c8d47e46060cc416fb
Author: Finn Thain <fthain@telegraphics.com.au>
Date:   Sun Jan 3 16:05:58 2016 +1100

    ncr5380: Use standard list data structure
    
    The NCR5380 drivers have a home-spun linked list implementation for
    scsi_cmnd structs that uses cmd->host_scribble as a 'next' pointer. Adopt
    the standard list_head data structure and list operations instead. Remove
    the eh_abort_handler rather than convert it. Doing the conversion would
    only be churn because the existing EH handlers don't work and get replaced
    in a subsequent patch.
    
    Signed-off-by: Finn Thain <fthain@telegraphics.com.au>
    Reviewed-by: Hannes Reinecke <hare@suse.com>
    Tested-by: Ondrej Zary <linux@rainbow-software.org>
    Tested-by: Michael Schmitz <schmitzmic@gmail.com>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/g_NCR5380.c b/drivers/scsi/g_NCR5380.c
index 0f2b3d9a6ae8..30472064170e 100644
--- a/drivers/scsi/g_NCR5380.c
+++ b/drivers/scsi/g_NCR5380.c
@@ -728,6 +728,7 @@ static struct scsi_host_template driver_template = {
 	.sg_tablesize		= SG_ALL,
 	.cmd_per_lun		= 2,
 	.use_clustering		= DISABLE_CLUSTERING,
+	.cmd_size		= NCR5380_CMD_SIZE,
 };
 
 #include "scsi_module.c"

commit e5c3fddfaa066e440315e713ddf8b60e9ac48cf7
Author: Finn Thain <fthain@telegraphics.com.au>
Date:   Sun Jan 3 16:05:52 2016 +1100

    ncr5380: Remove command list debug code
    
    Some NCR5380 hosts offer a .show_info method to access the contents of
    the various command list data structures from a procfs file. When NDEBUG
    is set, the same information is sent to the console during EH.
    
    The two core drivers, atari_NCR5380.c and NCR5380.c differ here. Because
    it is just for debugging, the easiest way to fix the discrepancy is
    simply remove this code.
    
    The only remaining users of NCR5380_show_info() and NCR5380_write_info()
    are drivers that define PSEUDO_DMA. The others have no use for the
    .show_info method, so don't initialize it.
    
    Signed-off-by: Finn Thain <fthain@telegraphics.com.au>
    Reviewed-by: Hannes Reinecke <hare@suse.com>
    Tested-by: Ondrej Zary <linux@rainbow-software.org>
    Tested-by: Michael Schmitz <schmitzmic@gmail.com>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/g_NCR5380.c b/drivers/scsi/g_NCR5380.c
index 0e59df6b4f5f..0f2b3d9a6ae8 100644
--- a/drivers/scsi/g_NCR5380.c
+++ b/drivers/scsi/g_NCR5380.c
@@ -715,7 +715,6 @@ static int generic_NCR5380_dma_xfer_len(struct scsi_cmnd *cmd)
 
 static struct scsi_host_template driver_template = {
 	.proc_name		= DRV_MODULE_NAME,
-	.show_info		= generic_NCR5380_show_info,
 	.name			= "Generic NCR5380/NCR53C400 SCSI",
 	.detect			= generic_NCR5380_detect,
 	.release		= generic_NCR5380_release_resources,

commit be3f4121aa352d8fef77a57df4b5e106d7f9a917
Author: Finn Thain <fthain@telegraphics.com.au>
Date:   Sun Jan 3 16:05:50 2016 +1100

    ncr5380: Remove redundant ICR_ARBITRATION_LOST test and eliminate FLAG_DTC3181E
    
    Remove FLAG_DTC3181E. It was used to suppress a final Arbitration Lost
    (SEL asserted) test that isn't actually needed. The test was suppressed
    because it causes problems for DTC436 and DTC536 chips. It takes place
    after the host wins arbitration, so SEL has been asserted. These chips
    can't seem to tell whether it was the host or another bus device that
    did so.
    
    This questionable final test appears in a flow chart in an early NCR5380
    datasheet. It was removed from later documents like the DP5380 datasheet.
    
    By the time this final test takes place, the driver has already tested
    the Arbitration Lost bit several times. The first test happens 3 us after
    BUS FREE (or longer due to register access delays). The protocol requires
    that a device stop signalling within 1.8 us after BUS FREE unless it won
    arbitration, in which case it must assert SEL, which is detected 1.2 us
    later by the first Arbitration Lost test.
    
    Signed-off-by: Finn Thain <fthain@telegraphics.com.au>
    Reviewed-by: Hannes Reinecke <hare@suse.com>
    Tested-by: Ondrej Zary <linux@rainbow-software.org>
    Tested-by: Michael Schmitz <schmitzmic@gmail.com>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/g_NCR5380.c b/drivers/scsi/g_NCR5380.c
index ea9d0de2fc85..0e59df6b4f5f 100644
--- a/drivers/scsi/g_NCR5380.c
+++ b/drivers/scsi/g_NCR5380.c
@@ -326,7 +326,7 @@ static int __init generic_NCR5380_detect(struct scsi_host_template *tpnt)
 			ports = ncr_53c400a_ports;
 			break;
 		case BOARD_DTC3181E:
-			flags = FLAG_NO_PSEUDO_DMA | FLAG_DTC3181E;
+			flags = FLAG_NO_PSEUDO_DMA;
 			ports = dtc_3181e_ports;
 			break;
 		}

commit aa2e2cb1dde0e72e039f94210fb17e73661a6351
Author: Finn Thain <fthain@telegraphics.com.au>
Date:   Sun Jan 3 16:05:48 2016 +1100

    ncr5380: Fix and cleanup scsi_host_template initializers
    
    Add missing .module initializer. Use distinct .proc_name values for the
    g_NCR5380 and g_NCR5380_mmio modules. Remove pointless CAN_QUEUE and
    CMD_PER_LUN override macros. Cleanup whitespace and code style.
    
    Signed-off-by: Finn Thain <fthain@telegraphics.com.au>
    Reviewed-by: Hannes Reinecke <hare@suse.com>
    Tested-by: Ondrej Zary <linux@rainbow-software.org>
    Tested-by: Michael Schmitz <schmitzmic@gmail.com>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/g_NCR5380.c b/drivers/scsi/g_NCR5380.c
index 1e8f29f500d5..ea9d0de2fc85 100644
--- a/drivers/scsi/g_NCR5380.c
+++ b/drivers/scsi/g_NCR5380.c
@@ -305,7 +305,6 @@ static int __init generic_NCR5380_detect(struct scsi_host_template *tpnt)
 		}
 	}
 #endif
-	tpnt->proc_name = "g_NCR5380";
 
 	for (count = 0; current_override < NO_OVERRIDES; ++current_override) {
 		if (!(overrides[current_override].NCR5380_map_name))
@@ -715,20 +714,21 @@ static int generic_NCR5380_dma_xfer_len(struct scsi_cmnd *cmd)
 #include "NCR5380.c"
 
 static struct scsi_host_template driver_template = {
-	.show_info      	= generic_NCR5380_show_info,
-	.name           	= "Generic NCR5380/NCR53C400 SCSI",
-	.detect         	= generic_NCR5380_detect,
-	.release        	= generic_NCR5380_release_resources,
-	.info           	= generic_NCR5380_info,
-	.queuecommand   	= generic_NCR5380_queue_command,
+	.proc_name		= DRV_MODULE_NAME,
+	.show_info		= generic_NCR5380_show_info,
+	.name			= "Generic NCR5380/NCR53C400 SCSI",
+	.detect			= generic_NCR5380_detect,
+	.release		= generic_NCR5380_release_resources,
+	.info			= generic_NCR5380_info,
+	.queuecommand		= generic_NCR5380_queue_command,
 	.eh_abort_handler	= generic_NCR5380_abort,
 	.eh_bus_reset_handler	= generic_NCR5380_bus_reset,
-	.bios_param     	= NCR5380_BIOSPARAM,
-	.can_queue      	= CAN_QUEUE,
-        .this_id        	= 7,
-        .sg_tablesize   	= SG_ALL,
-	.cmd_per_lun    	= CMD_PER_LUN,
-        .use_clustering		= DISABLE_CLUSTERING,
+	.bios_param		= NCR5380_BIOSPARAM,
+	.can_queue		= 16,
+	.this_id		= 7,
+	.sg_tablesize		= SG_ALL,
+	.cmd_per_lun		= 2,
+	.use_clustering		= DISABLE_CLUSTERING,
 };
 
 #include "scsi_module.c"

commit 161c0059a2a80aefe7000d9ab7ce5c36e5463b5f
Author: Finn Thain <fthain@telegraphics.com.au>
Date:   Sun Jan 3 16:05:46 2016 +1100

    ncr5380: Cleanup #include directives
    
    Remove unused includes (stat.h, signal.h, proc_fs.h) and move includes
    needed by the core drivers into the common header (delay.h etc).
    
    Signed-off-by: Finn Thain <fthain@telegraphics.com.au>
    Reviewed-by: Hannes Reinecke <hare@suse.com>
    Tested-by: Ondrej Zary <linux@rainbow-software.org>
    Tested-by: Michael Schmitz <schmitzmic@gmail.com>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/g_NCR5380.c b/drivers/scsi/g_NCR5380.c
index e71c79683925..1e8f29f500d5 100644
--- a/drivers/scsi/g_NCR5380.c
+++ b/drivers/scsi/g_NCR5380.c
@@ -63,16 +63,14 @@
 #endif
 
 #include <asm/io.h>
-#include <linux/signal.h>
 #include <linux/blkdev.h>
+#include <linux/module.h>
 #include <scsi/scsi_host.h>
 #include "g_NCR5380.h"
 #include "NCR5380.h"
-#include <linux/stat.h>
 #include <linux/init.h>
 #include <linux/ioport.h>
 #include <linux/isapnp.h>
-#include <linux/delay.h>
 #include <linux/interrupt.h>
 
 static int ncr_irq;
@@ -732,7 +730,7 @@ static struct scsi_host_template driver_template = {
 	.cmd_per_lun    	= CMD_PER_LUN,
         .use_clustering		= DISABLE_CLUSTERING,
 };
-#include <linux/module.h>
+
 #include "scsi_module.c"
 
 module_param(ncr_irq, int, 0);

commit 55181be8ced18697e48f75d53028b9ee36522dba
Author: Finn Thain <fthain@telegraphics.com.au>
Date:   Sun Jan 3 16:05:42 2016 +1100

    ncr5380: Replace redundant flags with FLAG_NO_DMA_FIXUP
    
    The flags DMA_WORKS_RIGHT, FLAG_NCR53C400 and FLAG_HAS_LAST_BYTE_SENT
    all mean the same thing, i.e. the chip is not a 538[01]. (More recent
    devices such as the 53C80 have a 'Last Byte Sent' bit in the Target
    Command Register as well as other fixes for End-of-DMA errata.)
    
    These flags have no additional meanings since previous cleanup patches
    eliminated the NCR53C400 macro, moved g_NCR5380-specific code out of the
    core driver and standardized interrupt handling.
    
    Use the FLAG_NO_DMA_FIXUP flag to suppress End-of-DMA errata workarounds,
    for those cards and drivers that make use of the TCR_LAST_BYTE_SENT bit.
    Remove the old flags.
    
    Signed-off-by: Finn Thain <fthain@telegraphics.com.au>
    Reviewed-by: Hannes Reinecke <hare@suse.com>
    Tested-by: Ondrej Zary <linux@rainbow-software.org>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/g_NCR5380.c b/drivers/scsi/g_NCR5380.c
index 4124f053d1b3..e71c79683925 100644
--- a/drivers/scsi/g_NCR5380.c
+++ b/drivers/scsi/g_NCR5380.c
@@ -321,7 +321,7 @@ static int __init generic_NCR5380_detect(struct scsi_host_template *tpnt)
 			break;
 		case BOARD_NCR53C400:
 #ifdef PSEUDO_DMA
-			flags = FLAG_NCR53C400;
+			flags = FLAG_NO_DMA_FIXUP;
 #endif
 			break;
 		case BOARD_NCR53C400A:

commit cd400825c95d4b883232614255c4f35c53bf3582
Author: Finn Thain <fthain@telegraphics.com.au>
Date:   Sun Jan 3 16:05:40 2016 +1100

    ncr5380: Standardize interrupt handling
    
    Because interrupt handling is crucial to the core driver(s), all wrapper
    drivers need to agree on this code. This patch removes discrepancies.
    
    NCR5380_intr() in NCR5380.c has the following pointless loop that differs
    from the code in atari_NCR5380.c.
    
            done = 1;
            do {
                    /* ... */
            } while (!done);
    
    The 'done' flag gets cleared when a reconnected command is to be processed
    from the work queue. But in NCR5380.c, the flag is also used to cause the
    interrupt conditions to be re-examined. Perhaps this was because
    NCR5380_reselect() was expected to cause another interrupt, or perhaps
    the remaining present interrupt conditions need to be handled after the
    NCR5380_reselect() call?
    
    Actually, both possibilities are bogus, as is the loop itself. It seems
    have been overlooked in the hit-and-miss removal of scsi host instance
    list iteration many years ago; see history/history.git commit 491447e1fcff
    ("[PATCH] next NCR5380 updates") and commit 69e1a9482e57 ("[PATCH] fix up
    NCR5380 private data"). See also my earlier patch, "Always retry
    arbitration and selection".
    
    The datasheet says, "IRQ can be reset simply by reading the Reset
    Parity/Interrupt Register". So don't treat the chip IRQ like a
    level-triggered interrupt. Of the conditions that set the IRQ flag,
    some are level-triggered and some are edge-triggered, which means IRQ
    itself must be edge-triggered.
    
    Some interrupt conditions are latched and some are not. Before clearing
    the chip IRQ flag, clear all state that may cause it to be raised. That
    means clearing the DMA Mode and Busy Monitor bits in the Mode Register
    and clearing the host ID in the Select Enable register.
    
    Also clean up some printk's and some comments. Keep atari_NCR5380.c and
    NCR5380.c in agreement.
    
    Signed-off-by: Finn Thain <fthain@telegraphics.com.au>
    Reviewed-by: Hannes Reinecke <hare@suse.com>
    Tested-by: Ondrej Zary <linux@rainbow-software.org>
    Tested-by: Michael Schmitz <schmitzmic@gmail.com>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/g_NCR5380.c b/drivers/scsi/g_NCR5380.c
index 258bc2ff0d1c..4124f053d1b3 100644
--- a/drivers/scsi/g_NCR5380.c
+++ b/drivers/scsi/g_NCR5380.c
@@ -594,8 +594,6 @@ static inline int NCR5380_pread(struct Scsi_Host *instance, unsigned char *dst,
 	if (!(NCR5380_read(BUS_AND_STATUS_REG) & BASR_END_DMA_TRANSFER))
 		printk(KERN_ERR "53C400r: no end dma signal\n");
 		
-	NCR5380_write(MODE_REG, MR_BASE);
-	NCR5380_read(RESET_PARITY_INTERRUPT_REG);
 	return 0;
 }
 

commit 686f3990e6a9111f97f2d385f4d1c1a5b0628c15
Author: Finn Thain <fthain@telegraphics.com.au>
Date:   Sun Jan 3 16:05:26 2016 +1100

    ncr5380: Rework disconnect versus poll logic
    
    The atari_NCR5380.c and NCR5380.c core drivers differ in their handling of
    target disconnection. This is partly because atari_NCR5380.c had all of
    the polling and sleeping removed to become entirely interrupt-driven, and
    it is partly because of damage done to NCR5380.c after atari_NCR5380.c was
    forked. See commit 37cd23b44929 ("Linux 2.1.105") in history/history.git.
    
    The polling changes that were made in v2.1.105 are questionable at best:
    if REQ is not already asserted when NCR5380_transfer_pio() is invoked, and
    if the expected phase is DATA IN or DATA OUT, the function will schedule
    main() to execute after USLEEP_SLEEP jiffies and then return. The problems
    here are the expected REQ timing and the sleep interval*. Avoid this issue
    by using NCR5380_poll_politely() instead of scheduling main().
    
    The atari_NCR5380.c core driver requires the use of the chip interrupt and
    always permits target disconnection. It sets the cmd->device->disconnect
    flag when a device disconnects, but never tests this flag.
    
    The NCR5380.c core driver permits disconnection only when
    instance->irq != NO_IRQ. It sets the cmd->device->disconnect flag when
    a device disconnects and it tests this flag in a couple of places:
    
    1. During NCR5380_information_transfer(), following COMMAND OUT phase,
       if !cmd->device->disconnect, the initiator will take a guess as to
       whether or not the target will then choose to go to MESSAGE IN phase
       and disconnect. If the driver guesses "yes", it will schedule main()
       to execute after USLEEP_SLEEP jiffies and then return there.
    
       Unfortunately the driver may guess "yes" even after it has denied
       the target the disconnection privilege. When the target does not
       disconnect, the sleep can be beneficial, assuming the sleep interval
       is appropriate (mostly it is not*).
    
       And even if the driver guesses "yes" correctly, and the target would
       then disconnect, the driver still has to go through the MESSAGE IN
       phase in order to get to BUS FREE phase. The main loop can do nothing
       useful until BUS FREE, and sleeping just delays the phase transition.
    
    2. If !cmd->device->disconnect and REQ is not already asserted when
       NCR5380_information_transfer() is invoked, the function polls for REQ
       for USLEEP_POLL jiffies. If REQ is not asserted, it then schedules
       main() to execute after USLEEP_SLEEP jiffies and returns.
    
       The idea is apparently to yeild the CPU while waiting for REQ.
       This is conditional upon !cmd->device->disconnect, but there seems
       to be no rhyme or reason for that. For example, the flag may be
       unset because disconnection privilege was denied because the driver
       has no IRQ. Or the flag may be unset because the device has never
       needed to disconnect before. Or if the flag is set, disconnection
       may have no relevance to the present bus phase.
    
    Another deficiency of the existing algorithm is as follows. When the
    driver has no IRQ, it prevents disconnection, and generally polls and
    sleeps more than it would normally. Now, if the driver is going to poll
    anyway, why not allow the target to disconnect? That way the driver can do
    something useful with the bus instead of polling unproductively!
    
    Avoid this pointless latency, complexity and guesswork by using
    NCR5380_poll_politely() instead of scheduling main().
    
    * For g_NCR5380, the time intervals for USLEEP_SLEEP and USLEEP_POLL are
      200 ms and 10 ms, respectively. They are 20 ms and 200 ms respectively
      for the other NCR5380 drivers. There doesn't seem to be any reason for
      this discrepancy. The timing seems to have no relation to the type of
      adapter. Bizarrely, the timing in g_NCR5380 seems to relate only to one
      particular type of target device. This patch attempts to solve the
      problem for all NCR5380 drivers and all target devices.
    
    Signed-off-by: Finn Thain <fthain@telegraphics.com.au>
    Reviewed-by: Hannes Reinecke <hare@suse.com>
    Tested-by: Ondrej Zary <linux@rainbow-software.org>
    Tested-by: Michael Schmitz <schmitzmic@gmail.com>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/g_NCR5380.c b/drivers/scsi/g_NCR5380.c
index 5b3e03ad50ce..258bc2ff0d1c 100644
--- a/drivers/scsi/g_NCR5380.c
+++ b/drivers/scsi/g_NCR5380.c
@@ -56,10 +56,6 @@
  *     
  */
 
-/* settings for DTC3181E card with only Mustek scanner attached */
-#define USLEEP_POLL	msecs_to_jiffies(10)
-#define USLEEP_SLEEP	msecs_to_jiffies(200)
-
 #define AUTOPROBE_IRQ
 
 #ifdef CONFIG_SCSI_GENERIC_NCR53C400

commit ff3d4578840fd96a50558edf02ca0178b9ebb652
Author: Finn Thain <fthain@telegraphics.com.au>
Date:   Sun Jan 3 16:05:25 2016 +1100

    ncr5380: Implement NCR5380_dma_xfer_len and remove LIMIT_TRANSFERSIZE macro
    
    Follow the example of the atari_NCR5380.c core driver and adopt the
    NCR5380_dma_xfer_len() hook. Implement NCR5380_dma_xfer_len() for dtc.c
    and g_NCR5380.c to take care of the limitations of these cards. Keep the
    default for drivers using PSEUDO_DMA.
    
    Eliminate the unused macro LIMIT_TRANSFERSIZE.
    
    Signed-off-by: Finn Thain <fthain@telegraphics.com.au>
    Reviewed-by: Hannes Reinecke <hare@suse.com>
    Tested-by: Ondrej Zary <linux@rainbow-software.org>
    Tested-by: Michael Schmitz <schmitzmic@gmail.com>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/g_NCR5380.c b/drivers/scsi/g_NCR5380.c
index afd092ff0c2e..5b3e03ad50ce 100644
--- a/drivers/scsi/g_NCR5380.c
+++ b/drivers/scsi/g_NCR5380.c
@@ -699,6 +699,21 @@ static inline int NCR5380_pwrite(struct Scsi_Host *instance, unsigned char *src,
 		; 	// TIMEOUT
 	return 0;
 }
+
+static int generic_NCR5380_dma_xfer_len(struct scsi_cmnd *cmd)
+{
+	int transfersize = cmd->transfersize;
+
+	/* Limit transfers to 32K, for xx400 & xx406
+	 * pseudoDMA that transfers in 128 bytes blocks.
+	 */
+	if (transfersize > 32 * 1024 && cmd->SCp.this_residual &&
+	    !(cmd->SCp.this_residual % transfersize))
+		transfersize = 32 * 1024;
+
+	return transfersize;
+}
+
 #endif /* PSEUDO_DMA */
 
 /*

commit 0ad0eff98fec3c940ec199047ff580abaaa5bb1a
Author: Finn Thain <fthain@telegraphics.com.au>
Date:   Sun Jan 3 16:05:21 2016 +1100

    ncr5380: Introduce unbound workqueue
    
    Allocate a work queue that will permit busy waiting and sleeping. This
    means NCR5380_init() can potentially fail, so add this error path.
    
    Signed-off-by: Finn Thain <fthain@telegraphics.com.au>
    Reviewed-by: Hannes Reinecke <hare@suse.com>
    Tested-by: Ondrej Zary <linux@rainbow-software.org>
    Tested-by: Michael Schmitz <schmitzmic@gmail.com>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/g_NCR5380.c b/drivers/scsi/g_NCR5380.c
index fa9f6d41548b..afd092ff0c2e 100644
--- a/drivers/scsi/g_NCR5380.c
+++ b/drivers/scsi/g_NCR5380.c
@@ -239,9 +239,6 @@ static int __init do_DTC3181E_setup(char *str)
  *	and DTC436(ISAPnP) controllers. If overrides have been set we use
  *	them.
  *
- *	The caller supplied NCR5380_init function is invoked from here, before
- *	the interrupt line is taken.
- *
  *	Locks: none
  */
 
@@ -402,15 +399,8 @@ static int __init generic_NCR5380_detect(struct scsi_host_template *tpnt)
 		}
 #endif
 		instance = scsi_register(tpnt, sizeof(struct NCR5380_hostdata));
-		if (instance == NULL) {
-#ifndef SCSI_G_NCR5380_MEM
-			release_region(overrides[current_override].NCR5380_map_name, region_size);
-#else
-			iounmap(iomem);
-			release_mem_region(base, NCR5380_region_size);
-#endif
-			continue;
-		}
+		if (instance == NULL)
+			goto out_release;
 
 #ifndef SCSI_G_NCR5380_MEM
 		instance->io_port = overrides[current_override].NCR5380_map_name;
@@ -427,7 +417,8 @@ static int __init generic_NCR5380_detect(struct scsi_host_template *tpnt)
 		((struct NCR5380_hostdata *)instance->hostdata)->iomem = iomem;
 #endif
 
-		NCR5380_init(instance, flags);
+		if (NCR5380_init(instance, flags))
+			goto out_unregister;
 
 		if (overrides[current_override].board == BOARD_NCR53C400)
 			NCR5380_write(C400_CONTROL_STATUS_REG, CSR_BASE);
@@ -459,6 +450,17 @@ static int __init generic_NCR5380_detect(struct scsi_host_template *tpnt)
 		++count;
 	}
 	return count;
+
+out_unregister:
+	scsi_unregister(instance);
+out_release:
+#ifndef SCSI_G_NCR5380_MEM
+	release_region(overrides[current_override].NCR5380_map_name, region_size);
+#else
+	iounmap(iomem);
+	release_mem_region(base, NCR5380_region_size);
+#endif
+	return count;
 }
 
 /**
@@ -475,15 +477,12 @@ static int generic_NCR5380_release_resources(struct Scsi_Host *instance)
 	if (instance->irq != NO_IRQ)
 		free_irq(instance->irq, instance);
 	NCR5380_exit(instance);
-
 #ifndef SCSI_G_NCR5380_MEM
 	release_region(instance->io_port, instance->n_io_port);
 #else
 	iounmap(((struct NCR5380_hostdata *)instance->hostdata)->iomem);
 	release_mem_region(instance->base, NCR5380_region_size);
 #endif
-
-
 	return 0;
 }
 

commit 4d029e9ae9c382b149b16632f49970d8b215e2da
Author: Finn Thain <fthain@telegraphics.com.au>
Date:   Sun Jan 3 16:05:19 2016 +1100

    ncr5380: Eliminate USLEEP_WAITLONG delay
    
    Linux 2.1.105 introduced the USLEEP_WAITLONG delay, apparently "needed for
    Mustek scanners". It is intended to stall the issue queue for 5 seconds.
    There are a number of problems with this.
    
    1. Only g_NCR5380 enables the delay, which implies that the other five
       drivers using the NCR5380.c core driver remain incompatible with
       Mustek scanners.
    
    2. The delay is not implemented by atari_NCR5380.c, which is problematic
       for re-unifying the two core driver forks.
    
    3. The delay is implemented using NCR5380_set_timer() which makes it
       unreliable. A new command queued by the mid-layer cancels the delay.
    
    4. The delay is applied indiscriminately in several situations in which
       NCR5380_select() returns -1. These are-- reselection by the target,
       failure of the target to assert BSY, and failure of the target to
       assert REQ. It's clear from the comments that USLEEP_WAITLONG is not
       relevant to the reselection case. And reportedly, these scanners do
       not disconnect.
    
    5. atari_NCR5380.c was forked before Linux 2.1.105, so it was spared some
       of the damage done to NCR5380.c. In this case, the atari_NCR5380.c core
       driver was more standard-compliant and may not have needed any
       workaround like the USLEEP_WAITLONG kludge. The compliance issue was
       addressed in the previous patch.
    
    If these scanners still don't work, we need a better solution. Retrying
    selection until EH aborts a command offers equivalent robustness. Bugs in
    the existing driver prevent EH working correctly but this is addressed in
    a subsequent patch. Remove USLEEP_WAITLONG.
    
    Signed-off-by: Finn Thain <fthain@telegraphics.com.au>
    Reviewed-by: Hannes Reinecke <hare@suse.com>
    Tested-by: Ondrej Zary <linux@rainbow-software.org>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/g_NCR5380.c b/drivers/scsi/g_NCR5380.c
index ffbb07b0e9e8..fa9f6d41548b 100644
--- a/drivers/scsi/g_NCR5380.c
+++ b/drivers/scsi/g_NCR5380.c
@@ -59,7 +59,6 @@
 /* settings for DTC3181E card with only Mustek scanner attached */
 #define USLEEP_POLL	msecs_to_jiffies(10)
 #define USLEEP_SLEEP	msecs_to_jiffies(200)
-#define USLEEP_WAITLONG	msecs_to_jiffies(5000)
 
 #define AUTOPROBE_IRQ
 

commit 4d8c08c71ea261a31855e4919fa8b875cd507ef3
Author: Finn Thain <fthain@telegraphics.com.au>
Date:   Sun Jan 3 16:05:09 2016 +1100

    ncr5380: Move NCR53C400-specific code
    
    Move board-specific code like this,
            NCR5380_write(C400_CONTROL_STATUS_REG, CSR_BASE);
    from the core driver to the board driver. Eliminate the NCR53C400 macro
    from the core driver. Removal of all macros like this one will be
    necessary in order to have one core driver that can support all kinds of
    boards.
    
    Signed-off-by: Finn Thain <fthain@telegraphics.com.au>
    Reviewed-by: Hannes Reinecke <hare@suse.com>
    Tested-by: Ondrej Zary <linux@rainbow-software.org>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/g_NCR5380.c b/drivers/scsi/g_NCR5380.c
index 6f5fdf642296..ffbb07b0e9e8 100644
--- a/drivers/scsi/g_NCR5380.c
+++ b/drivers/scsi/g_NCR5380.c
@@ -64,9 +64,7 @@
 #define AUTOPROBE_IRQ
 
 #ifdef CONFIG_SCSI_GENERIC_NCR53C400
-#define NCR53C400_PSEUDO_DMA 1
 #define PSEUDO_DMA
-#define NCR53C400
 #endif
 
 #include <asm/io.h>
@@ -263,7 +261,7 @@ static int __init generic_NCR5380_detect(struct scsi_host_template *tpnt)
 	static unsigned int __initdata dtc_3181e_ports[] = {
 		0x220, 0x240, 0x280, 0x2a0, 0x2c0, 0x300, 0x320, 0x340, 0
 	};
-	int flags = 0;
+	int flags;
 	struct Scsi_Host *instance;
 #ifdef SCSI_G_NCR5380_MEM
 	unsigned long base;
@@ -324,12 +322,15 @@ static int __init generic_NCR5380_detect(struct scsi_host_template *tpnt)
 			continue;
 
 		ports = NULL;
+		flags = 0;
 		switch (overrides[current_override].board) {
 		case BOARD_NCR5380:
 			flags = FLAG_NO_PSEUDO_DMA;
 			break;
 		case BOARD_NCR53C400:
+#ifdef PSEUDO_DMA
 			flags = FLAG_NCR53C400;
+#endif
 			break;
 		case BOARD_NCR53C400A:
 			flags = FLAG_NO_PSEUDO_DMA;
@@ -415,6 +416,13 @@ static int __init generic_NCR5380_detect(struct scsi_host_template *tpnt)
 #ifndef SCSI_G_NCR5380_MEM
 		instance->io_port = overrides[current_override].NCR5380_map_name;
 		instance->n_io_port = region_size;
+
+		/*
+		 * On NCR53C400 boards, NCR5380 registers are mapped 8 past
+		 * the base address.
+		 */
+		if (overrides[current_override].board == BOARD_NCR53C400)
+			instance->io_port += 8;
 #else
 		instance->base = overrides[current_override].NCR5380_map_name;
 		((struct NCR5380_hostdata *)instance->hostdata)->iomem = iomem;
@@ -422,6 +430,9 @@ static int __init generic_NCR5380_detect(struct scsi_host_template *tpnt)
 
 		NCR5380_init(instance, flags);
 
+		if (overrides[current_override].board == BOARD_NCR53C400)
+			NCR5380_write(C400_CONTROL_STATUS_REG, CSR_BASE);
+
 		NCR5380_maybe_reset_bus(instance);
 
 		if (overrides[current_override].irq != IRQ_AUTO)
@@ -506,7 +517,7 @@ generic_NCR5380_biosparam(struct scsi_device *sdev, struct block_device *bdev,
 }
 #endif
 
-#ifdef NCR53C400_PSEUDO_DMA
+#ifdef PSEUDO_DMA
 
 /**
  *	NCR5380_pread		-	pseudo DMA read
@@ -690,7 +701,7 @@ static inline int NCR5380_pwrite(struct Scsi_Host *instance, unsigned char *src,
 		; 	// TIMEOUT
 	return 0;
 }
-#endif				/* PSEUDO_DMA */
+#endif /* PSEUDO_DMA */
 
 /*
  *	Include the NCR5380 core code that we build our driver around	

commit b6488f97d3b5b602a066956e58a1ba282456d79b
Author: Finn Thain <fthain@telegraphics.com.au>
Date:   Sun Jan 3 16:05:08 2016 +1100

    ncr5380: Split NCR5380_init() into two functions
    
    This patch splits the NCR5380_init() function into two parts, similar
    to the scheme used with atari_NCR5380.c. This avoids two problems.
    
    Firstly, NCR5380_init() may perform a bus reset, which would cause the
    chip to assert IRQ. The chip is unable to mask its bus reset interrupt.
    Drivers can't call request_irq() before calling NCR5380_init(), because
    initialization must happen before the interrupt handler executes. If
    driver initialization causes an interrupt it may be problematic on some
    platforms. To avoid that, first move the bus reset code into
    NCR5380_maybe_reset_bus().
    
    Secondly, NCR5380_init() contains some board-specific interrupt setup code
    for the NCR53C400 that does not belong in the core driver. In moving this
    code, better not re-order interrupt initialization and bus reset. Again,
    the solution is to move the bus reset code into NCR5380_maybe_reset_bus().
    
    Signed-off-by: Finn Thain <fthain@telegraphics.com.au>
    Reviewed-by: Hannes Reinecke <hare@suse.com>
    Tested-by: Ondrej Zary <linux@rainbow-software.org>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/g_NCR5380.c b/drivers/scsi/g_NCR5380.c
index 4559fbc7f342..6f5fdf642296 100644
--- a/drivers/scsi/g_NCR5380.c
+++ b/drivers/scsi/g_NCR5380.c
@@ -422,6 +422,8 @@ static int __init generic_NCR5380_detect(struct scsi_host_template *tpnt)
 
 		NCR5380_init(instance, flags);
 
+		NCR5380_maybe_reset_bus(instance);
+
 		if (overrides[current_override].irq != IRQ_AUTO)
 			instance->irq = overrides[current_override].irq;
 		else

commit b01ec34895720348dab7eae6bfb28a5799130bce
Author: Finn Thain <fthain@telegraphics.com.au>
Date:   Sun Jan 3 16:05:07 2016 +1100

    ncr5380: Remove NCR5380_instance_name macro
    
    This macro makes the code cryptic. Remove it.
    
    Signed-off-by: Finn Thain <fthain@telegraphics.com.au>
    Reviewed-by: Hannes Reinecke <hare@suse.com>
    Tested-by: Ondrej Zary <linux@rainbow-software.org>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/g_NCR5380.c b/drivers/scsi/g_NCR5380.c
index 21f8236df48f..4559fbc7f342 100644
--- a/drivers/scsi/g_NCR5380.c
+++ b/drivers/scsi/g_NCR5380.c
@@ -412,10 +412,11 @@ static int __init generic_NCR5380_detect(struct scsi_host_template *tpnt)
 			continue;
 		}
 
-		instance->NCR5380_instance_name = overrides[current_override].NCR5380_map_name;
 #ifndef SCSI_G_NCR5380_MEM
+		instance->io_port = overrides[current_override].NCR5380_map_name;
 		instance->n_io_port = region_size;
 #else
+		instance->base = overrides[current_override].NCR5380_map_name;
 		((struct NCR5380_hostdata *)instance->hostdata)->iomem = iomem;
 #endif
 
@@ -464,10 +465,10 @@ static int generic_NCR5380_release_resources(struct Scsi_Host *instance)
 	NCR5380_exit(instance);
 
 #ifndef SCSI_G_NCR5380_MEM
-	release_region(instance->NCR5380_instance_name, instance->n_io_port);
+	release_region(instance->io_port, instance->n_io_port);
 #else
 	iounmap(((struct NCR5380_hostdata *)instance->hostdata)->iomem);
-	release_mem_region(instance->NCR5380_instance_name, NCR5380_region_size);
+	release_mem_region(instance->base, NCR5380_region_size);
 #endif
 
 

commit 54d8fe4425c9d3fdf8473c1833c6807b61c6e70e
Author: Finn Thain <fthain@telegraphics.com.au>
Date:   Sun Jan 3 16:05:06 2016 +1100

    ncr5380: Remove NCR5380_local_declare and NCR5380_setup macros
    
    The NCR5380_local_declare and NCR5380_setup macros exist to define and
    initialize a particular local variable, to provide the address of the
    chip registers needed for the driver's implementation of its
    NCR5380_read/write register access macros.
    
    In cumana_1 and macscsi, these macros generate pointless code like this,
            struct Scsi_Host *_instance;
            _instance = instance;
    
    In pas16, the use of NCR5380_read/write in pas16_hw_detect() requires that
    the io_port local variable has been defined and initialized, but the
    NCR5380_local_declare and NCR5380_setup macros can't be used for that
    purpose because the Scsi_Host struct has not yet been instantiated.
    
    Moreover, these macros were removed from atari_NCR5380.c long ago and
    now they constitute yet another discrepancy between the two core driver
    forks.
    
    Remove these "optimizations".
    
    Signed-off-by: Finn Thain <fthain@telegraphics.com.au>
    Reviewed-by: Hannes Reinecke <hare@suse.com>
    Tested-by: Ondrej Zary <linux@rainbow-software.org>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/g_NCR5380.c b/drivers/scsi/g_NCR5380.c
index 4cca9734175e..21f8236df48f 100644
--- a/drivers/scsi/g_NCR5380.c
+++ b/drivers/scsi/g_NCR5380.c
@@ -459,9 +459,6 @@ static int __init generic_NCR5380_detect(struct scsi_host_template *tpnt)
  
 static int generic_NCR5380_release_resources(struct Scsi_Host *instance)
 {
-	NCR5380_local_declare();
-	NCR5380_setup(instance);
-	
 	if (instance->irq != NO_IRQ)
 		free_irq(instance->irq, instance);
 	NCR5380_exit(instance);
@@ -520,13 +517,13 @@ generic_NCR5380_biosparam(struct scsi_device *sdev, struct block_device *bdev,
  
 static inline int NCR5380_pread(struct Scsi_Host *instance, unsigned char *dst, int len)
 {
+#ifdef SCSI_G_NCR5380_MEM
+	struct NCR5380_hostdata *hostdata = shost_priv(instance);
+#endif
 	int blocks = len / 128;
 	int start = 0;
 	int bl;
 
-	NCR5380_local_declare();
-	NCR5380_setup(instance);
-
 	NCR5380_write(C400_CONTROL_STATUS_REG, CSR_BASE | CSR_TRANS_DIR);
 	NCR5380_write(C400_BLOCK_COUNTER_REG, blocks);
 	while (1) {
@@ -547,7 +544,8 @@ static inline int NCR5380_pread(struct Scsi_Host *instance, unsigned char *dst,
 		}
 #else
 		/* implies SCSI_G_NCR5380_MEM */
-		memcpy_fromio(dst + start, iomem + NCR53C400_host_buffer, 128);
+		memcpy_fromio(dst + start,
+		              hostdata->iomem + NCR53C400_host_buffer, 128);
 #endif
 		start += 128;
 		blocks--;
@@ -567,7 +565,8 @@ static inline int NCR5380_pread(struct Scsi_Host *instance, unsigned char *dst,
 		}
 #else
 		/* implies SCSI_G_NCR5380_MEM */
-		memcpy_fromio(dst + start, iomem + NCR53C400_host_buffer, 128);
+		memcpy_fromio(dst + start,
+		              hostdata->iomem + NCR53C400_host_buffer, 128);
 #endif
 		start += 128;
 		blocks--;
@@ -604,14 +603,14 @@ static inline int NCR5380_pread(struct Scsi_Host *instance, unsigned char *dst,
 
 static inline int NCR5380_pwrite(struct Scsi_Host *instance, unsigned char *src, int len)
 {
+#ifdef SCSI_G_NCR5380_MEM
+	struct NCR5380_hostdata *hostdata = shost_priv(instance);
+#endif
 	int blocks = len / 128;
 	int start = 0;
 	int bl;
 	int i;
 
-	NCR5380_local_declare();
-	NCR5380_setup(instance);
-
 	NCR5380_write(C400_CONTROL_STATUS_REG, CSR_BASE);
 	NCR5380_write(C400_BLOCK_COUNTER_REG, blocks);
 	while (1) {
@@ -632,7 +631,8 @@ static inline int NCR5380_pwrite(struct Scsi_Host *instance, unsigned char *src,
 		}
 #else
 		/* implies SCSI_G_NCR5380_MEM */
-		memcpy_toio(iomem + NCR53C400_host_buffer, src + start, 128);
+		memcpy_toio(hostdata->iomem + NCR53C400_host_buffer,
+		            src + start, 128);
 #endif
 		start += 128;
 		blocks--;
@@ -648,7 +648,8 @@ static inline int NCR5380_pwrite(struct Scsi_Host *instance, unsigned char *src,
 		}
 #else
 		/* implies SCSI_G_NCR5380_MEM */
-		memcpy_toio(iomem + NCR53C400_host_buffer, src + start, 128);
+		memcpy_toio(hostdata->iomem + NCR53C400_host_buffer,
+		            src + start, 128);
 #endif
 		start += 128;
 		blocks--;

commit c0965e6371fa50fdf5cc2291915de97412fb1ec9
Author: Finn Thain <fthain@telegraphics.com.au>
Date:   Sun Jan 3 16:05:05 2016 +1100

    ncr5380: Remove more pointless macros
    
    ASM macro is never defined. rtrc in pas16.c is not used.
    NCR5380_map_config, do_NCR5380_intr, do_t128_intr and do_pas16_intr
    are unused. NCR_NOT_SET harms readability. Remove them.
    
    Signed-off-by: Finn Thain <fthain@telegraphics.com.au>
    Reviewed-by: Hannes Reinecke <hare@suse.com>
    Tested-by: Ondrej Zary <linux@rainbow-software.org>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/g_NCR5380.c b/drivers/scsi/g_NCR5380.c
index c2507475518e..4cca9734175e 100644
--- a/drivers/scsi/g_NCR5380.c
+++ b/drivers/scsi/g_NCR5380.c
@@ -82,14 +82,13 @@
 #include <linux/delay.h>
 #include <linux/interrupt.h>
 
-#define NCR_NOT_SET 0
-static int ncr_irq = NCR_NOT_SET;
-static int ncr_dma = NCR_NOT_SET;
-static int ncr_addr = NCR_NOT_SET;
-static int ncr_5380 = NCR_NOT_SET;
-static int ncr_53c400 = NCR_NOT_SET;
-static int ncr_53c400a = NCR_NOT_SET;
-static int dtc_3181e = NCR_NOT_SET;
+static int ncr_irq;
+static int ncr_dma;
+static int ncr_addr;
+static int ncr_5380;
+static int ncr_53c400;
+static int ncr_53c400a;
+static int dtc_3181e;
 
 static struct override {
 	NCR5380_map_type NCR5380_map_name;
@@ -271,19 +270,19 @@ static int __init generic_NCR5380_detect(struct scsi_host_template *tpnt)
 	void __iomem *iomem;
 #endif
 
-	if (ncr_irq != NCR_NOT_SET)
+	if (ncr_irq)
 		overrides[0].irq = ncr_irq;
-	if (ncr_dma != NCR_NOT_SET)
+	if (ncr_dma)
 		overrides[0].dma = ncr_dma;
-	if (ncr_addr != NCR_NOT_SET)
+	if (ncr_addr)
 		overrides[0].NCR5380_map_name = (NCR5380_map_type) ncr_addr;
-	if (ncr_5380 != NCR_NOT_SET)
+	if (ncr_5380)
 		overrides[0].board = BOARD_NCR5380;
-	else if (ncr_53c400 != NCR_NOT_SET)
+	else if (ncr_53c400)
 		overrides[0].board = BOARD_NCR53C400;
-	else if (ncr_53c400a != NCR_NOT_SET)
+	else if (ncr_53c400a)
 		overrides[0].board = BOARD_NCR53C400A;
-	else if (dtc_3181e != NCR_NOT_SET)
+	else if (dtc_3181e)
 		overrides[0].board = BOARD_DTC3181E;
 #ifndef SCSI_G_NCR5380_MEM
 	if (!current_override && isapnp_present()) {

commit d5f7e65df0d41982b1e9cbba9df04003ebb2178d
Author: Finn Thain <fthain@telegraphics.com.au>
Date:   Sun Jan 3 16:05:03 2016 +1100

    ncr5380: Remove redundant static variable initializers
    
    Signed-off-by: Finn Thain <fthain@telegraphics.com.au>
    Reviewed-by: Hannes Reinecke <hare@suse.com>
    Tested-by: Ondrej Zary <linux@rainbow-software.org>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/g_NCR5380.c b/drivers/scsi/g_NCR5380.c
index f8d2478b11cc..c2507475518e 100644
--- a/drivers/scsi/g_NCR5380.c
+++ b/drivers/scsi/g_NCR5380.c
@@ -121,7 +121,7 @@ static struct override {
 
 static void __init internal_setup(int board, char *str, int *ints)
 {
-	static int commandline_current = 0;
+	static int commandline_current;
 	switch (board) {
 	case BOARD_NCR5380:
 		if (ints[0] != 2 && ints[0] != 3) {
@@ -251,7 +251,7 @@ static int __init do_DTC3181E_setup(char *str)
 
 static int __init generic_NCR5380_detect(struct scsi_host_template *tpnt)
 {
-	static int current_override = 0;
+	static int current_override;
 	int count;
 	unsigned int *ports;
 #ifndef SCSI_G_NCR5380_MEM

commit 4e5a800c82ec21335349a97cf58d97fbb0d3c98e
Author: Nicholas Mc Guire <hofrat@osadl.org>
Date:   Wed Feb 4 13:30:20 2015 -0500

    ncr5380: Harmonize jiffies conversion with msecs_to_jiffies
    
    Instances of var * HZ / 1000 are replaced by msecs_to_jiffies(var).
    In addition some timing constants that assumed HZ 100 were adjusted
    to HZ independent settings based on review comments from Michael Schmitz
    <schmitzmic@gmail.com> and review of the original drivers in 1.0.31 and
    2.2.16.
    
    Signed-off-by: Nicholas Mc Guire <hofrat@osadl.org>
    Acked-by: Michael Schmitz <schmitzmic@gmail.com>
    Signed-off-by: Finn Thain <fthain@telegraphics.com.au>
    Signed-off-by: James Bottomley <JBottomley@Parallels.com>

diff --git a/drivers/scsi/g_NCR5380.c b/drivers/scsi/g_NCR5380.c
index 74ec2f5669ab..f8d2478b11cc 100644
--- a/drivers/scsi/g_NCR5380.c
+++ b/drivers/scsi/g_NCR5380.c
@@ -57,9 +57,9 @@
  */
 
 /* settings for DTC3181E card with only Mustek scanner attached */
-#define USLEEP_POLL	1
-#define USLEEP_SLEEP	20
-#define USLEEP_WAITLONG	500
+#define USLEEP_POLL	msecs_to_jiffies(10)
+#define USLEEP_SLEEP	msecs_to_jiffies(200)
+#define USLEEP_WAITLONG	msecs_to_jiffies(5000)
 
 #define AUTOPROBE_IRQ
 

commit b026e8ed55e05a81018ba4ce73ca0cf2c9300950
Author: Geert Uytterhoeven <geert@linux-m68k.org>
Date:   Sat Jan 3 23:00:16 2015 +0100

    g_NCR5380: Kill compiler warning if builtin
    
    If CONFIG_SCSI_GENERIC_NCR5380=y:
    
    drivers/scsi/g_NCR5380.c:727: warning: 'id_table' defined but not used
    
    In the non-modular case, MODULE_DEVICE_TABLE() expands to nothing, and
    id_table is not referenced.
    
    Correct the existing #ifdef to fix this.
    
    Signed-off-by: Geert Uytterhoeven <geert@linux-m68k.org>
    Signed-off-by: Finn Thain <fthain@telegraphics.com.au>
    Signed-off-by: James Bottomley <JBottomley@Parallels.com>

diff --git a/drivers/scsi/g_NCR5380.c b/drivers/scsi/g_NCR5380.c
index f35792f7051c..74ec2f5669ab 100644
--- a/drivers/scsi/g_NCR5380.c
+++ b/drivers/scsi/g_NCR5380.c
@@ -723,7 +723,7 @@ module_param(ncr_53c400a, int, 0);
 module_param(dtc_3181e, int, 0);
 MODULE_LICENSE("GPL");
 
-#ifndef SCSI_G_NCR5380_MEM
+#if !defined(SCSI_G_NCR5380_MEM) && defined(MODULE)
 static struct isapnp_device_id id_table[] = {
 	{
 	 ISAPNP_ANY_ID, ISAPNP_ANY_ID,

commit 710ddd0d50d22b40e3b644ea35966489ad178978
Author: Finn Thain <fthain@telegraphics.com.au>
Date:   Wed Nov 12 16:12:02 2014 +1100

    ncr5380: Drop legacy scsi.h include
    
    Convert Scsi_Cmnd to struct scsi_cmnd and drop the #include "scsi.h".
    The sun3_NCR5380.c core driver already uses struct scsi_cmnd so converting
    the other core drivers reduces the diff which makes them easier to unify.
    
    Signed-off-by: Finn Thain <fthain@telegraphics.com.au>
    Reviewed-by: Hannes Reinecke <hare@suse.de>
    Tested-by: Michael Schmitz <schmitzmic@gmail.com>
    Signed-off-by: Christoph Hellwig <hch@lst.de>

diff --git a/drivers/scsi/g_NCR5380.c b/drivers/scsi/g_NCR5380.c
index c158104fd3aa..f35792f7051c 100644
--- a/drivers/scsi/g_NCR5380.c
+++ b/drivers/scsi/g_NCR5380.c
@@ -72,7 +72,6 @@
 #include <asm/io.h>
 #include <linux/signal.h>
 #include <linux/blkdev.h>
-#include "scsi.h"
 #include <scsi/scsi_host.h>
 #include "g_NCR5380.h"
 #include "NCR5380.h"

commit 96068e6b4d86a397f50ae401723f315110874e1a
Author: Finn Thain <fthain@telegraphics.com.au>
Date:   Wed Nov 12 16:12:01 2014 +1100

    ncr5380: Remove *_RELEASE macros
    
    The *_RELEASE macros don't tell me anything. In some cases the version in
    the macro contradicts the version in the comments. Anyway, the Linux kernel
    version is sufficient information. Remove these macros to improve readability.
    
    Signed-off-by: Finn Thain <fthain@telegraphics.com.au>
    Reviewed-by: Hannes Reinecke <hare@suse.de>
    Tested-by: Michael Schmitz <schmitzmic@gmail.com>
    Signed-off-by: Christoph Hellwig <hch@lst.de>

diff --git a/drivers/scsi/g_NCR5380.c b/drivers/scsi/g_NCR5380.c
index 2b8155f1bf94..c158104fd3aa 100644
--- a/drivers/scsi/g_NCR5380.c
+++ b/drivers/scsi/g_NCR5380.c
@@ -18,8 +18,6 @@
  *
  * Added ISAPNP support for DTC436 adapters,
  * Thomas Sailer, sailer@ife.ee.ethz.ch
- *
- * ALPHA RELEASE 1. 
  */
 
 /* 

commit 8c32513bd395dc5d382e4883097482567cf8bbc5
Author: Finn Thain <fthain@telegraphics.com.au>
Date:   Wed Nov 12 16:11:58 2014 +1100

    ncr5380: Cleanup host info() methods
    
    If the host->info() method is not set, then host->name is used by default.
    For atari_scsi, that is exactly the same text. So remove the redundant
    info() method. Keep sun3_scsi.c in line with atari_scsi.
    
    Some NCR5380 drivers return an empty string from the info() method
    (arm/cumana_1.c arm/oak.c mac_scsi.c) while other drivers use the default
    (dmx3191d dtc.c g_NCR5380.c pas16.c t128.c).
    
    Implement a common info() method to replace a lot of duplicated code which
    the various drivers use to announce the same information.
    
    This replaces most of the (deprecated) show_info() output and all of the
    NCR5380_print_info() output. This also eliminates a bunch of code in
    g_NCR5380 which just duplicates functionality in the core driver.
    
    Signed-off-by: Finn Thain <fthain@telegraphics.com.au>
    Reviewed-by: Hannes Reinecke <hare@suse.de>
    Tested-by: Michael Schmitz <schmitzmic@gmail.com>
    Signed-off-by: Christoph Hellwig <hch@lst.de>

diff --git a/drivers/scsi/g_NCR5380.c b/drivers/scsi/g_NCR5380.c
index 9040023ed1c0..2b8155f1bf94 100644
--- a/drivers/scsi/g_NCR5380.c
+++ b/drivers/scsi/g_NCR5380.c
@@ -446,34 +446,12 @@ static int __init generic_NCR5380_detect(struct scsi_host_template *tpnt)
 			printk(KERN_INFO "scsi%d : please jumper the board for a free IRQ.\n", instance->host_no);
 		}
 
-		printk(KERN_INFO "scsi%d : at " STRVAL(NCR5380_map_name) " 0x%x", instance->host_no, (unsigned int) instance->NCR5380_instance_name);
-		if (instance->irq == NO_IRQ)
-			printk(" interrupts disabled");
-		else
-			printk(" irq %d", instance->irq);
-		printk(" options CAN_QUEUE=%d  CMD_PER_LUN=%d release=%d", CAN_QUEUE, CMD_PER_LUN, GENERIC_NCR5380_PUBLIC_RELEASE);
-		NCR5380_print_options(instance);
-		printk("\n");
-
 		++current_override;
 		++count;
 	}
 	return count;
 }
 
-/**
- *	generic_NCR5380_info	-	reporting string
- *	@host: NCR5380 to report on
- *
- *	Report driver information for the NCR5380
- */
- 	
-static const char *generic_NCR5380_info(struct Scsi_Host *host)
-{
-	static const char string[] = "Generic NCR5380/53C400 Driver";
-	return string;
-}
-
 /**
  *	generic_NCR5380_release_resources	-	free resources
  *	@instance: host adapter to clean up 
@@ -720,120 +698,9 @@ static inline int NCR5380_pwrite(struct Scsi_Host *instance, unsigned char *src,
  
 #include "NCR5380.c"
 
-#define PRINTP(x) seq_printf(m, x)
-#define ANDP ,
-
-static void sprint_opcode(struct seq_file *m, int opcode)
-{
-	PRINTP("0x%02x " ANDP opcode);
-}
-
-static void sprint_command(struct seq_file *m, unsigned char *command)
-{
-	int i, s;
-	sprint_opcode(m, command[0]);
-	for (i = 1, s = COMMAND_SIZE(command[0]); i < s; ++i)
-		PRINTP("%02x " ANDP command[i]);
-	PRINTP("\n");
-}
-
-/**
- *	sprintf_Scsi_Cmnd	-	print a scsi command
- *	@m: seq_fil to print into
- *	@cmd: SCSI command block
- *	
- *	Print out the target and command data in hex
- */
-
-static void sprint_Scsi_Cmnd(struct seq_file *m, Scsi_Cmnd * cmd)
-{
-	PRINTP("host number %d destination target %d, lun %llu\n" ANDP cmd->device->host->host_no ANDP cmd->device->id ANDP cmd->device->lun);
-	PRINTP("        command = ");
-	sprint_command(m, cmd->cmnd);
-}
-
-/**
- *	generic_NCR5380_proc_info	-	/proc for NCR5380 driver
- *	@buffer: buffer to print into
- *	@start: start position
- *	@offset: offset into buffer
- *	@len: length
- *	@hostno: instance to affect
- *	@inout: read/write
- *
- *	Provide the procfs information for the 5380 controller. We fill
- *	this with useful debugging information including the commands
- *	being executed, disconnected command queue and the statistical
- *	data
- *
- *	Locks: global cli/lock for queue walk
- */
- 
-static int generic_NCR5380_show_info(struct seq_file *m, struct Scsi_Host *scsi_ptr)
-{
-	NCR5380_local_declare();
-	unsigned long flags;
-	unsigned char status;
-	int i;
-	Scsi_Cmnd *ptr;
-	struct NCR5380_hostdata *hostdata;
-
-	NCR5380_setup(scsi_ptr);
-	hostdata = (struct NCR5380_hostdata *) scsi_ptr->hostdata;
-
-	spin_lock_irqsave(scsi_ptr->host_lock, flags);
-	PRINTP("SCSI host number %d : %s\n" ANDP scsi_ptr->host_no ANDP scsi_ptr->hostt->name);
-	PRINTP("Generic NCR5380 driver version %d\n" ANDP GENERIC_NCR5380_PUBLIC_RELEASE);
-	PRINTP("NCR5380 core version %d\n" ANDP NCR5380_PUBLIC_RELEASE);
-#ifdef NCR53C400
-	PRINTP("NCR53C400 extension version %d\n" ANDP NCR53C400_PUBLIC_RELEASE);
-	PRINTP("NCR53C400 card%s detected\n" ANDP(((struct NCR5380_hostdata *) scsi_ptr->hostdata)->flags & FLAG_NCR53C400) ? "" : " not");
-# if NCR53C400_PSEUDO_DMA
-	PRINTP("NCR53C400 pseudo DMA used\n");
-# endif
-#else
-	PRINTP("NO NCR53C400 driver extensions\n");
-#endif
-	PRINTP("Using %s mapping at %s 0x%lx, " ANDP STRVAL(NCR5380_map_config) ANDP STRVAL(NCR5380_map_name) ANDP scsi_ptr->NCR5380_instance_name);
-	if (scsi_ptr->irq == NO_IRQ)
-		PRINTP("no interrupt\n");
-	else
-		PRINTP("on interrupt %d\n" ANDP scsi_ptr->irq);
-
-	status = NCR5380_read(STATUS_REG);
-	if (!(status & SR_REQ))
-		PRINTP("REQ not asserted, phase unknown.\n");
-	else {
-		for (i = 0; (phases[i].value != PHASE_UNKNOWN) && (phases[i].value != (status & PHASE_MASK)); ++i);
-		PRINTP("Phase %s\n" ANDP phases[i].name);
-	}
-
-	if (!hostdata->connected) {
-		PRINTP("No currently connected command\n");
-	} else {
-		sprint_Scsi_Cmnd(m, (Scsi_Cmnd *) hostdata->connected);
-	}
-
-	PRINTP("issue_queue\n");
-
-	for (ptr = (Scsi_Cmnd *) hostdata->issue_queue; ptr; ptr = (Scsi_Cmnd *) ptr->host_scribble)
-		sprint_Scsi_Cmnd(m, ptr);
-
-	PRINTP("disconnected_queue\n");
-
-	for (ptr = (Scsi_Cmnd *) hostdata->disconnected_queue; ptr; ptr = (Scsi_Cmnd *) ptr->host_scribble)
-		sprint_Scsi_Cmnd(m, ptr);
-
-	spin_unlock_irqrestore(scsi_ptr->host_lock, flags);
-	return 0;
-}
-
-#undef PRINTP
-#undef ANDP
-
 static struct scsi_host_template driver_template = {
 	.show_info      	= generic_NCR5380_show_info,
-	.name           	= "Generic NCR5380/NCR53C400 Scsi Driver",
+	.name           	= "Generic NCR5380/NCR53C400 SCSI",
 	.detect         	= generic_NCR5380_detect,
 	.release        	= generic_NCR5380_release_resources,
 	.info           	= generic_NCR5380_info,

commit 270ac2c290ad8b83c92ceeed07aaf49ec5807851
Author: Finn Thain <fthain@telegraphics.com.au>
Date:   Wed Nov 12 16:11:57 2014 +1100

    ncr5380: Remove NCR5380_STATS
    
    The NCR5380_STATS option is only enabled by g_NCR5380 yet it adds
    clutter to all three core drivers. The atari_NCR5380.c and sun3_NCR5380.c
    core drivers have a slightly different implementation of the
    NCR5380_STATS option.
    
    Out of all ten NCR5380 drivers, only one of them (g_NCR5380) actually
    has the code to report on the collected stats. Aside from being unreadable,
    that code seems to be broken because there's no initialization of timebase.
    sun3_NCR5380.c and atari_NCR5380.c have the timebase initialization but
    lack the code to report the stats.
    
    Remove all of this code to improve readability and reduce divergence
    between the three core drivers.
    
    This patch and the next one completely eliminate the PRINTP and ANDP
    pre-processor abuse.
    
    Signed-off-by: Finn Thain <fthain@telegraphics.com.au>
    Reviewed-by: Hannes Reinecke <hare@suse.de>
    Tested-by: Michael Schmitz <schmitzmic@gmail.com>
    Signed-off-by: Christoph Hellwig <hch@lst.de>

diff --git a/drivers/scsi/g_NCR5380.c b/drivers/scsi/g_NCR5380.c
index a2b70fb4c67f..9040023ed1c0 100644
--- a/drivers/scsi/g_NCR5380.c
+++ b/drivers/scsi/g_NCR5380.c
@@ -69,8 +69,6 @@
 #define NCR53C400_PSEUDO_DMA 1
 #define PSEUDO_DMA
 #define NCR53C400
-#define NCR5380_STATS
-#undef NCR5380_STAT_LIMIT
 #endif
 
 #include <asm/io.h>
@@ -779,9 +777,6 @@ static int generic_NCR5380_show_info(struct seq_file *m, struct Scsi_Host *scsi_
 	int i;
 	Scsi_Cmnd *ptr;
 	struct NCR5380_hostdata *hostdata;
-#ifdef NCR5380_STATS
-	struct scsi_device *dev;
-#endif
 
 	NCR5380_setup(scsi_ptr);
 	hostdata = (struct NCR5380_hostdata *) scsi_ptr->hostdata;
@@ -805,46 +800,6 @@ static int generic_NCR5380_show_info(struct seq_file *m, struct Scsi_Host *scsi_
 	else
 		PRINTP("on interrupt %d\n" ANDP scsi_ptr->irq);
 
-#ifdef NCR5380_STATS
-	if (hostdata->connected || hostdata->issue_queue || hostdata->disconnected_queue)
-		PRINTP("There are commands pending, transfer rates may be crud\n");
-	if (hostdata->pendingr)
-		PRINTP("  %d pending reads" ANDP hostdata->pendingr);
-	if (hostdata->pendingw)
-		PRINTP("  %d pending writes" ANDP hostdata->pendingw);
-	if (hostdata->pendingr || hostdata->pendingw)
-		PRINTP("\n");
-	shost_for_each_device(dev, scsi_ptr) {
-		unsigned long br = hostdata->bytes_read[dev->id];
-		unsigned long bw = hostdata->bytes_write[dev->id];
-		long tr = hostdata->time_read[dev->id] / HZ;
-		long tw = hostdata->time_write[dev->id] / HZ;
-
-		PRINTP("  T:%d %s " ANDP dev->id ANDP scsi_device_type(dev->type));
-		for (i = 0; i < 8; i++)
-			if (dev->vendor[i] >= 0x20)
-				seq_putc(m, dev->vendor[i]);
-		seq_putc(m, ' ');
-		for (i = 0; i < 16; i++)
-			if (dev->model[i] >= 0x20)
-				seq_putc(m, dev->model[i]);
-		seq_putc(m, ' ');
-		for (i = 0; i < 4; i++)
-			if (dev->rev[i] >= 0x20)
-				seq_putc(m, dev->rev[i]);
-		seq_putc(m, ' ');
-
-		PRINTP("\n%10ld kb read    in %5ld secs" ANDP br / 1024 ANDP tr);
-		if (tr)
-			PRINTP(" @ %5ld bps" ANDP br / tr);
-
-		PRINTP("\n%10ld kb written in %5ld secs" ANDP bw / 1024 ANDP tw);
-		if (tw)
-			PRINTP(" @ %5ld bps" ANDP bw / tw);
-		PRINTP("\n");
-	}
-#endif
-
 	status = NCR5380_read(STATUS_REG);
 	if (!(status & SR_REQ))
 		PRINTP("REQ not asserted, phase unknown.\n");

commit 22f5f10d2dadc50bf26a482b782a5e04f6e9b362
Author: Finn Thain <fthain@telegraphics.com.au>
Date:   Wed Nov 12 16:11:56 2014 +1100

    ncr5380: Fix SCSI_IRQ_NONE bugs
    
    Oak scsi doesn't use any IRQ, but it sets irq = IRQ_NONE rather than
    SCSI_IRQ_NONE. Problem is, the core NCR5380 driver expects SCSI_IRQ_NONE
    if it is to issue IDENTIFY commands that prevent target disconnection.
    And, as Geert points out, IRQ_NONE is part of enum irqreturn.
    
    Other drivers, when they can't get an IRQ or can't use one, will set
    host->irq = SCSI_IRQ_NONE (that is, 255). But when they exit they will
    attempt to free IRQ 255 which was never requested.
    
    Fix these bugs by using NO_IRQ in place of SCSI_IRQ_NONE and IRQ_NONE.
    That means IRQ 0 is no longer probed by ISA drivers but I don't think
    this matters.
    
    Setting IRQ = 255 for these ISA drivers is understood to mean no IRQ.
    This remains supported so as to avoid breaking existing ISA setups (which
    can be difficult to get working) and because existing documentation
    (SANE, TLDP etc) describes this usage for the ISA NCR5380 driver options.
    
    Signed-off-by: Finn Thain <fthain@telegraphics.com.au>
    Reviewed-by: Hannes Reinecke <hare@suse.de>
    Tested-by: Michael Schmitz <schmitzmic@gmail.com>
    Signed-off-by: Christoph Hellwig <hch@lst.de>

diff --git a/drivers/scsi/g_NCR5380.c b/drivers/scsi/g_NCR5380.c
index 151e1ad8fe9f..a2b70fb4c67f 100644
--- a/drivers/scsi/g_NCR5380.c
+++ b/drivers/scsi/g_NCR5380.c
@@ -312,7 +312,7 @@ static int __init generic_NCR5380_detect(struct scsi_host_template *tpnt)
 			if (pnp_irq_valid(dev, 0))
 				overrides[count].irq = pnp_irq(dev, 0);
 			else
-				overrides[count].irq = SCSI_IRQ_NONE;
+				overrides[count].irq = NO_IRQ;
 			if (pnp_dma_valid(dev, 0))
 				overrides[count].dma = pnp_dma(dev, 0);
 			else
@@ -432,20 +432,24 @@ static int __init generic_NCR5380_detect(struct scsi_host_template *tpnt)
 		else
 			instance->irq = NCR5380_probe_irq(instance, 0xffff);
 
-		if (instance->irq != SCSI_IRQ_NONE)
+		/* Compatibility with documented NCR5380 kernel parameters */
+		if (instance->irq == 255)
+			instance->irq = NO_IRQ;
+
+		if (instance->irq != NO_IRQ)
 			if (request_irq(instance->irq, generic_NCR5380_intr,
 					0, "NCR5380", instance)) {
 				printk(KERN_WARNING "scsi%d : IRQ%d not free, interrupts disabled\n", instance->host_no, instance->irq);
-				instance->irq = SCSI_IRQ_NONE;
+				instance->irq = NO_IRQ;
 			}
 
-		if (instance->irq == SCSI_IRQ_NONE) {
+		if (instance->irq == NO_IRQ) {
 			printk(KERN_INFO "scsi%d : interrupts not enabled. for better interactive performance,\n", instance->host_no);
 			printk(KERN_INFO "scsi%d : please jumper the board for a free IRQ.\n", instance->host_no);
 		}
 
 		printk(KERN_INFO "scsi%d : at " STRVAL(NCR5380_map_name) " 0x%x", instance->host_no, (unsigned int) instance->NCR5380_instance_name);
-		if (instance->irq == SCSI_IRQ_NONE)
+		if (instance->irq == NO_IRQ)
 			printk(" interrupts disabled");
 		else
 			printk(" irq %d", instance->irq);
@@ -486,7 +490,7 @@ static int generic_NCR5380_release_resources(struct Scsi_Host *instance)
 	NCR5380_local_declare();
 	NCR5380_setup(instance);
 	
-	if (instance->irq != SCSI_IRQ_NONE)
+	if (instance->irq != NO_IRQ)
 		free_irq(instance->irq, instance);
 	NCR5380_exit(instance);
 
@@ -796,7 +800,7 @@ static int generic_NCR5380_show_info(struct seq_file *m, struct Scsi_Host *scsi_
 	PRINTP("NO NCR53C400 driver extensions\n");
 #endif
 	PRINTP("Using %s mapping at %s 0x%lx, " ANDP STRVAL(NCR5380_map_config) ANDP STRVAL(NCR5380_map_name) ANDP scsi_ptr->NCR5380_instance_name);
-	if (scsi_ptr->irq == SCSI_IRQ_NONE)
+	if (scsi_ptr->irq == NO_IRQ)
 		PRINTP("no interrupt\n");
 	else
 		PRINTP("on interrupt %d\n" ANDP scsi_ptr->irq);

commit 3f9e986e2f1df8fa69ffe213098c1ee98f1c9584
Author: Finn Thain <fthain@telegraphics.com.au>
Date:   Wed Nov 12 16:11:55 2014 +1100

    ncr5380: Remove duplicate comments
    
    The LIMIT_TRANSFERSIZE, PSEUDO_DMA, PARITY and UNSAFE options are all
    documented in the core drivers where they are used. The same goes for the
    chip databook reference. Remove the duplicate comments.
    
    Signed-off-by: Finn Thain <fthain@telegraphics.com.au>
    Reviewed-by: Hannes Reinecke <hare@suse.de>
    Signed-off-by: Christoph Hellwig <hch@lst.de>

diff --git a/drivers/scsi/g_NCR5380.c b/drivers/scsi/g_NCR5380.c
index eda978f29d9d..151e1ad8fe9f 100644
--- a/drivers/scsi/g_NCR5380.c
+++ b/drivers/scsi/g_NCR5380.c
@@ -20,18 +20,6 @@
  * Thomas Sailer, sailer@ife.ee.ethz.ch
  *
  * ALPHA RELEASE 1. 
- *
- * For more information, please consult 
- *
- * NCR 5380 Family
- * SCSI Protocol Controller
- * Databook
- *
- * NCR Microelectronics
- * 1635 Aeroplaza Drive
- * Colorado Springs, CO 80916
- * 1+ (719) 578-3400
- * 1+ (800) 334-5454
  */
 
 /* 
@@ -40,10 +28,6 @@
  */
 
 /*
- * Options :
- *
- * PARITY - enable parity checking.  Not supported.
- *
  * The card is detected and initialized in one of several ways : 
  * 1.  With command line overrides - NCR5380=port,irq may be 
  *     used on the LILO command line to override the defaults.

commit 997acab7d593913eaa0606ff257079efcfcb146d
Author: Finn Thain <fthain@telegraphics.com.au>
Date:   Wed Nov 12 16:11:54 2014 +1100

    ncr5380: Remove redundant AUTOSENSE macro
    
    Every NCR5380 driver sets AUTOSENSE so it need not be optional (and the
    mid-layer expects it). Remove this redundant macro to improve readability.
    
    Signed-off-by: Finn Thain <fthain@telegraphics.com.au>
    Reviewed-by: Hannes Reinecke <hare@suse.de>
    Tested-by: Michael Schmitz <schmitzmic@gmail.com>
    Signed-off-by: Christoph Hellwig <hch@lst.de>

diff --git a/drivers/scsi/g_NCR5380.c b/drivers/scsi/g_NCR5380.c
index c10466939a52..eda978f29d9d 100644
--- a/drivers/scsi/g_NCR5380.c
+++ b/drivers/scsi/g_NCR5380.c
@@ -80,8 +80,6 @@
 #define USLEEP_WAITLONG	500
 
 #define AUTOPROBE_IRQ
-#define AUTOSENSE
-
 
 #ifdef CONFIG_SCSI_GENERIC_NCR53C400
 #define NCR53C400_PSEUDO_DMA 1

commit ed8b9e7f1827ebae902e868866438d1bcdbef0a2
Author: Finn Thain <fthain@telegraphics.com.au>
Date:   Wed Nov 12 16:11:51 2014 +1100

    ncr5380: Remove useless prototypes
    
    Add missing static qualifiers and remove the now pointless prototypes. The
    NCR5380_* prototypes are all declared in NCR5380.h and renamed using macros.
    Further declarations are redundant (some are completely unused). Remove
    them.
    
    Signed-off-by: Finn Thain <fthain@telegraphics.com.au>
    Reviewed-by: Hannes Reinecke <hare@suse.de>
    Tested-by: Michael Schmitz <schmitzmic@gmail.com>
    Signed-off-by: Christoph Hellwig <hch@lst.de>

diff --git a/drivers/scsi/g_NCR5380.c b/drivers/scsi/g_NCR5380.c
index eeb8da5b2d4a..c10466939a52 100644
--- a/drivers/scsi/g_NCR5380.c
+++ b/drivers/scsi/g_NCR5380.c
@@ -272,7 +272,7 @@ static int __init do_DTC3181E_setup(char *str)
  *	Locks: none
  */
 
-int __init generic_NCR5380_detect(struct scsi_host_template * tpnt)
+static int __init generic_NCR5380_detect(struct scsi_host_template *tpnt)
 {
 	static int current_override = 0;
 	int count;
@@ -484,7 +484,7 @@ int __init generic_NCR5380_detect(struct scsi_host_template * tpnt)
  *	Report driver information for the NCR5380
  */
  	
-const char *generic_NCR5380_info(struct Scsi_Host *host)
+static const char *generic_NCR5380_info(struct Scsi_Host *host)
 {
 	static const char string[] = "Generic NCR5380/53C400 Driver";
 	return string;
@@ -499,7 +499,7 @@ const char *generic_NCR5380_info(struct Scsi_Host *host)
  *	Locks: none
  */
  
-int generic_NCR5380_release_resources(struct Scsi_Host *instance)
+static int generic_NCR5380_release_resources(struct Scsi_Host *instance)
 {
 	NCR5380_local_declare();
 	NCR5380_setup(instance);

commit 48f16c9bef8ee6b699ab8e7c5c55920ddd1c7e8f
Author: Finn Thain <fthain@telegraphics.com.au>
Date:   Wed Nov 12 16:11:50 2014 +1100

    ncr5380: Remove unused macros
    
    Some macros are never evaluated (i.e. FOO, USLEEP, SCSI2 and USE_WRAPPER;
    and in some drivers, NCR5380_intr and NCR5380_proc_info). DRIVER_SETUP
    serves no purpose anymore. Remove these macro definitions.
    
    Signed-off-by: Finn Thain <fthain@telegraphics.com.au>
    Reviewed-by: Hannes Reinecke <hare@suse.de>
    Tested-by: Michael Schmitz <schmitzmic@gmail.com>
    Signed-off-by: Christoph Hellwig <hch@lst.de>

diff --git a/drivers/scsi/g_NCR5380.c b/drivers/scsi/g_NCR5380.c
index b331272e93bc..eeb8da5b2d4a 100644
--- a/drivers/scsi/g_NCR5380.c
+++ b/drivers/scsi/g_NCR5380.c
@@ -44,10 +44,6 @@
  *
  * PARITY - enable parity checking.  Not supported.
  *
- * SCSI2 - enable support for SCSI-II tagged queueing.  Untested.
- *
- * USLEEP - enable support for devices that don't disconnect.  Untested.
- *
  * The card is detected and initialized in one of several ways : 
  * 1.  With command line overrides - NCR5380=port,irq may be 
  *     used on the LILO command line to override the defaults.
@@ -79,7 +75,6 @@
  */
 
 /* settings for DTC3181E card with only Mustek scanner attached */
-#define USLEEP
 #define USLEEP_POLL	1
 #define USLEEP_SLEEP	20
 #define USLEEP_WAITLONG	500

commit 9cb78c16f5dadefd8dc5ba0ae5a2f26cd59419b3
Author: Hannes Reinecke <hare@suse.de>
Date:   Wed Jun 25 15:27:36 2014 +0200

    scsi: use 64-bit LUNs
    
    The SCSI standard defines 64-bit values for LUNs, and large arrays
    employing large or hierarchical LUN numbers become more and more
    common.
    
    So update the linux SCSI stack to use 64-bit LUN numbers.
    
    Signed-off-by: Hannes Reinecke <hare@suse.de>
    Reviewed-by: Christoph Hellwig <hch@infradead.org>
    Reviewed-by: Ewan Milne <emilne@redhat.com>
    Signed-off-by: Christoph Hellwig <hch@lst.de>

diff --git a/drivers/scsi/g_NCR5380.c b/drivers/scsi/g_NCR5380.c
index a1bc8ca958e1..b331272e93bc 100644
--- a/drivers/scsi/g_NCR5380.c
+++ b/drivers/scsi/g_NCR5380.c
@@ -768,7 +768,7 @@ static void sprint_command(struct seq_file *m, unsigned char *command)
 
 static void sprint_Scsi_Cmnd(struct seq_file *m, Scsi_Cmnd * cmd)
 {
-	PRINTP("host number %d destination target %d, lun %d\n" ANDP cmd->device->host->host_no ANDP cmd->device->id ANDP cmd->device->lun);
+	PRINTP("host number %d destination target %d, lun %llu\n" ANDP cmd->device->host->host_no ANDP cmd->device->id ANDP cmd->device->lun);
 	PRINTP("        command = ");
 	sprint_command(m, cmd->cmnd);
 }

commit 7ac44e061b2eb7871f55f64fe794d221394d126f
Author: Finn Thain <fthain@telegraphics.com.au>
Date:   Tue Mar 18 11:42:15 2014 +1100

    scsi/NCR5380: remove old CVS keywords
    
    Signed-off-by: Finn Thain <fthain@telegraphics.com.au>
    Acked-by: Sam Creasey <sammy@sammy.net>
    Signed-off-by: Christoph Hellwig <hch@lst.de>

diff --git a/drivers/scsi/g_NCR5380.c b/drivers/scsi/g_NCR5380.c
index 7176365e916b..a1bc8ca958e1 100644
--- a/drivers/scsi/g_NCR5380.c
+++ b/drivers/scsi/g_NCR5380.c
@@ -78,10 +78,6 @@
  *     
  */
 
-/*
- * $Log: generic_NCR5380.c,v $
- */
-
 /* settings for DTC3181E card with only Mustek scanner attached */
 #define USLEEP
 #define USLEEP_POLL	1

commit 4909cc2b89715c2dfd4c466a37cc08b2b3890fed
Author: Michael Opdenacker <michael.opdenacker@free-electrons.com>
Date:   Wed Mar 5 06:09:41 2014 +0100

    [SCSI] remove deprecated IRQF_DISABLED from SCSI
    
    It's a NOOP since 2.6.35 and it will be removed one day.
    
    [jejb: remove from missed arm scsi drivers]
    Signed-off-by: Michael Opdenacker <michael.opdenacker@free-electrons.com>
    Signed-off-by: James Bottomley <JBottomley@Parallels.com>

diff --git a/drivers/scsi/g_NCR5380.c b/drivers/scsi/g_NCR5380.c
index 5cec6c60ca22..7176365e916b 100644
--- a/drivers/scsi/g_NCR5380.c
+++ b/drivers/scsi/g_NCR5380.c
@@ -461,7 +461,7 @@ int __init generic_NCR5380_detect(struct scsi_host_template * tpnt)
 
 		if (instance->irq != SCSI_IRQ_NONE)
 			if (request_irq(instance->irq, generic_NCR5380_intr,
-					IRQF_DISABLED, "NCR5380", instance)) {
+					0, "NCR5380", instance)) {
 				printk(KERN_WARNING "scsi%d : IRQ%d not free, interrupts disabled\n", instance->host_no, instance->irq);
 				instance->irq = SCSI_IRQ_NONE;
 			}

commit dd7ab71bb3b4dad7fa1c4fd89706d6870991cfe6
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Sun Mar 31 01:15:54 2013 -0400

    NCR5830: switch to ->show_info()
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/drivers/scsi/g_NCR5380.c b/drivers/scsi/g_NCR5380.c
index 5041f925c191..5cec6c60ca22 100644
--- a/drivers/scsi/g_NCR5380.c
+++ b/drivers/scsi/g_NCR5380.c
@@ -745,42 +745,36 @@ static inline int NCR5380_pwrite(struct Scsi_Host *instance, unsigned char *src,
  
 #include "NCR5380.c"
 
-#define PRINTP(x) len += sprintf(buffer+len, x)
+#define PRINTP(x) seq_printf(m, x)
 #define ANDP ,
 
-static int sprint_opcode(char *buffer, int len, int opcode)
+static void sprint_opcode(struct seq_file *m, int opcode)
 {
-	int start = len;
 	PRINTP("0x%02x " ANDP opcode);
-	return len - start;
 }
 
-static int sprint_command(char *buffer, int len, unsigned char *command)
+static void sprint_command(struct seq_file *m, unsigned char *command)
 {
-	int i, s, start = len;
-	len += sprint_opcode(buffer, len, command[0]);
+	int i, s;
+	sprint_opcode(m, command[0]);
 	for (i = 1, s = COMMAND_SIZE(command[0]); i < s; ++i)
 		PRINTP("%02x " ANDP command[i]);
 	PRINTP("\n");
-	return len - start;
 }
 
 /**
  *	sprintf_Scsi_Cmnd	-	print a scsi command
- *	@buffer: buffr to print into
- *	@len: buffer length
+ *	@m: seq_fil to print into
  *	@cmd: SCSI command block
  *	
  *	Print out the target and command data in hex
  */
 
-static int sprint_Scsi_Cmnd(char *buffer, int len, Scsi_Cmnd * cmd)
+static void sprint_Scsi_Cmnd(struct seq_file *m, Scsi_Cmnd * cmd)
 {
-	int start = len;
 	PRINTP("host number %d destination target %d, lun %d\n" ANDP cmd->device->host->host_no ANDP cmd->device->id ANDP cmd->device->lun);
 	PRINTP("        command = ");
-	len += sprint_command(buffer, len, cmd->cmnd);
-	return len - start;
+	sprint_command(m, cmd->cmnd);
 }
 
 /**
@@ -800,9 +794,8 @@ static int sprint_Scsi_Cmnd(char *buffer, int len, Scsi_Cmnd * cmd)
  *	Locks: global cli/lock for queue walk
  */
  
-static int generic_NCR5380_proc_info(struct Scsi_Host *scsi_ptr, char *buffer, char **start, off_t offset, int length, int inout)
+static int generic_NCR5380_show_info(struct seq_file *m, struct Scsi_Host *scsi_ptr)
 {
-	int len = 0;
 	NCR5380_local_declare();
 	unsigned long flags;
 	unsigned char status;
@@ -853,16 +846,16 @@ static int generic_NCR5380_proc_info(struct Scsi_Host *scsi_ptr, char *buffer, c
 		PRINTP("  T:%d %s " ANDP dev->id ANDP scsi_device_type(dev->type));
 		for (i = 0; i < 8; i++)
 			if (dev->vendor[i] >= 0x20)
-				*(buffer + (len++)) = dev->vendor[i];
-		*(buffer + (len++)) = ' ';
+				seq_putc(m, dev->vendor[i]);
+		seq_putc(m, ' ');
 		for (i = 0; i < 16; i++)
 			if (dev->model[i] >= 0x20)
-				*(buffer + (len++)) = dev->model[i];
-		*(buffer + (len++)) = ' ';
+				seq_putc(m, dev->model[i]);
+		seq_putc(m, ' ');
 		for (i = 0; i < 4; i++)
 			if (dev->rev[i] >= 0x20)
-				*(buffer + (len++)) = dev->rev[i];
-		*(buffer + (len++)) = ' ';
+				seq_putc(m, dev->rev[i]);
+		seq_putc(m, ' ');
 
 		PRINTP("\n%10ld kb read    in %5ld secs" ANDP br / 1024 ANDP tr);
 		if (tr)
@@ -886,32 +879,28 @@ static int generic_NCR5380_proc_info(struct Scsi_Host *scsi_ptr, char *buffer, c
 	if (!hostdata->connected) {
 		PRINTP("No currently connected command\n");
 	} else {
-		len += sprint_Scsi_Cmnd(buffer, len, (Scsi_Cmnd *) hostdata->connected);
+		sprint_Scsi_Cmnd(m, (Scsi_Cmnd *) hostdata->connected);
 	}
 
 	PRINTP("issue_queue\n");
 
 	for (ptr = (Scsi_Cmnd *) hostdata->issue_queue; ptr; ptr = (Scsi_Cmnd *) ptr->host_scribble)
-		len += sprint_Scsi_Cmnd(buffer, len, ptr);
+		sprint_Scsi_Cmnd(m, ptr);
 
 	PRINTP("disconnected_queue\n");
 
 	for (ptr = (Scsi_Cmnd *) hostdata->disconnected_queue; ptr; ptr = (Scsi_Cmnd *) ptr->host_scribble)
-		len += sprint_Scsi_Cmnd(buffer, len, ptr);
+		sprint_Scsi_Cmnd(m, ptr);
 
-	*start = buffer + offset;
-	len -= offset;
-	if (len > length)
-		len = length;
 	spin_unlock_irqrestore(scsi_ptr->host_lock, flags);
-	return len;
+	return 0;
 }
 
 #undef PRINTP
 #undef ANDP
 
 static struct scsi_host_template driver_template = {
-	.proc_info      	= generic_NCR5380_proc_info,
+	.show_info      	= generic_NCR5380_show_info,
 	.name           	= "Generic NCR5380/NCR53C400 Scsi Driver",
 	.detect         	= generic_NCR5380_detect,
 	.release        	= generic_NCR5380_release_resources,

commit 6f039790510fd630ff348efe8c4802dbaa041fba
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Fri Dec 21 13:08:55 2012 -0800

    Drivers: scsi: remove __dev* attributes.
    
    CONFIG_HOTPLUG is going away as an option.  As a result, the __dev*
    markings need to be removed.
    
    This change removes the use of __devinit, __devexit_p, __devinitdata,
    __devinitconst, and __devexit from these drivers.
    
    Based on patches originally written by Bill Pemberton, but redone by me
    in order to handle some of the coding style issues better, by hand.
    
    Cc: Bill Pemberton <wfp5p@virginia.edu>
    Cc: Adam Radford <linuxraid@lsi.com>
    Cc: "James E.J. Bottomley" <JBottomley@parallels.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/scsi/g_NCR5380.c b/drivers/scsi/g_NCR5380.c
index 1a5954f0915a..5041f925c191 100644
--- a/drivers/scsi/g_NCR5380.c
+++ b/drivers/scsi/g_NCR5380.c
@@ -939,7 +939,7 @@ module_param(dtc_3181e, int, 0);
 MODULE_LICENSE("GPL");
 
 #ifndef SCSI_G_NCR5380_MEM
-static struct isapnp_device_id id_table[] __devinitdata = {
+static struct isapnp_device_id id_table[] = {
 	{
 	 ISAPNP_ANY_ID, ISAPNP_ANY_ID,
 	 ISAPNP_VENDOR('D', 'T', 'C'), ISAPNP_FUNCTION(0x436e),

commit 9ffc93f203c18a70623f21950f1dd473c9ec48cd
Author: David Howells <dhowells@redhat.com>
Date:   Wed Mar 28 18:30:03 2012 +0100

    Remove all #inclusions of asm/system.h
    
    Remove all #inclusions of asm/system.h preparatory to splitting and killing
    it.  Performed with the following command:
    
    perl -p -i -e 's!^#\s*include\s*<asm/system[.]h>.*\n!!' `grep -Irl '^#\s*include\s*<asm/system[.]h>' *`
    
    Signed-off-by: David Howells <dhowells@redhat.com>

diff --git a/drivers/scsi/g_NCR5380.c b/drivers/scsi/g_NCR5380.c
index 81182badfeb1..1a5954f0915a 100644
--- a/drivers/scsi/g_NCR5380.c
+++ b/drivers/scsi/g_NCR5380.c
@@ -100,7 +100,6 @@
 #undef NCR5380_STAT_LIMIT
 #endif
 
-#include <asm/system.h>
 #include <asm/io.h>
 #include <linux/signal.h>
 #include <linux/blkdev.h>

commit 25985edcedea6396277003854657b5f3cb31a628
Author: Lucas De Marchi <lucas.demarchi@profusion.mobi>
Date:   Wed Mar 30 22:57:33 2011 -0300

    Fix common misspellings
    
    Fixes generated by 'codespell' and manually reviewed.
    
    Signed-off-by: Lucas De Marchi <lucas.demarchi@profusion.mobi>

diff --git a/drivers/scsi/g_NCR5380.c b/drivers/scsi/g_NCR5380.c
index 427a56d3117e..81182badfeb1 100644
--- a/drivers/scsi/g_NCR5380.c
+++ b/drivers/scsi/g_NCR5380.c
@@ -566,7 +566,7 @@ generic_NCR5380_biosparam(struct scsi_device *sdev, struct block_device *bdev,
  *	@dst: buffer to read into
  *	@len: buffer length
  *
- *	Perform a psuedo DMA mode read from an NCR53C400 or equivalent
+ *	Perform a pseudo DMA mode read from an NCR53C400 or equivalent
  *	controller
  */
  
@@ -650,7 +650,7 @@ static inline int NCR5380_pread(struct Scsi_Host *instance, unsigned char *dst,
  *	@dst: buffer to read into
  *	@len: buffer length
  *
- *	Perform a psuedo DMA mode read from an NCR53C400 or equivalent
+ *	Perform a pseudo DMA mode read from an NCR53C400 or equivalent
  *	controller
  */
 

commit 702a98c63355b74aec50897870eb1c89b5009cfb
Author: Ondrej Zary <linux@rainbow-software.org>
Date:   Tue Aug 10 18:01:16 2010 -0700

    g_NCR5380: fix broken MMIO compilation
    
    The ifdefs are broken so the MMIO code is never compiled and so it's
    broken too.  Fix them all.  Untested as I don't have the hardware.
    
    Signed-off-by: Ondrej Zary <linux@rainbow-software.org>
    Reviewed-by: Andy Walls <awalls@md.metrocast.net>
    Cc: James Bottomley <James.Bottomley@HansenPartnership.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/scsi/g_NCR5380.c b/drivers/scsi/g_NCR5380.c
index 6bc0015662e0..427a56d3117e 100644
--- a/drivers/scsi/g_NCR5380.c
+++ b/drivers/scsi/g_NCR5380.c
@@ -285,9 +285,12 @@ static int __init do_DTC3181E_setup(char *str)
 int __init generic_NCR5380_detect(struct scsi_host_template * tpnt)
 {
 	static int current_override = 0;
-	int count, i;
+	int count;
 	unsigned int *ports;
+#ifndef SCSI_G_NCR5380_MEM
+	int i;
 	unsigned long region_size = 16;
+#endif
 	static unsigned int __initdata ncr_53c400a_ports[] = {
 		0x280, 0x290, 0x300, 0x310, 0x330, 0x340, 0x348, 0x350, 0
 	};
@@ -296,7 +299,7 @@ int __init generic_NCR5380_detect(struct scsi_host_template * tpnt)
 	};
 	int flags = 0;
 	struct Scsi_Host *instance;
-#ifdef CONFIG_SCSI_G_NCR5380_MEM
+#ifdef SCSI_G_NCR5380_MEM
 	unsigned long base;
 	void __iomem *iomem;
 #endif
@@ -315,7 +318,7 @@ int __init generic_NCR5380_detect(struct scsi_host_template * tpnt)
 		overrides[0].board = BOARD_NCR53C400A;
 	else if (dtc_3181e != NCR_NOT_SET)
 		overrides[0].board = BOARD_DTC3181E;
-
+#ifndef SCSI_G_NCR5380_MEM
 	if (!current_override && isapnp_present()) {
 		struct pnp_dev *dev = NULL;
 		count = 0;
@@ -347,7 +350,7 @@ int __init generic_NCR5380_detect(struct scsi_host_template * tpnt)
 			count++;
 		}
 	}
-
+#endif
 	tpnt->proc_name = "g_NCR5380";
 
 	for (count = 0; current_override < NO_OVERRIDES; ++current_override) {
@@ -372,7 +375,7 @@ int __init generic_NCR5380_detect(struct scsi_host_template * tpnt)
 			break;
 		}
 
-#ifndef CONFIG_SCSI_G_NCR5380_MEM
+#ifndef SCSI_G_NCR5380_MEM
 		if (ports) {
 			/* wakeup sequence for the NCR53C400A and DTC3181E */
 
@@ -434,7 +437,7 @@ int __init generic_NCR5380_detect(struct scsi_host_template * tpnt)
 #endif
 		instance = scsi_register(tpnt, sizeof(struct NCR5380_hostdata));
 		if (instance == NULL) {
-#ifndef CONFIG_SCSI_G_NCR5380_MEM
+#ifndef SCSI_G_NCR5380_MEM
 			release_region(overrides[current_override].NCR5380_map_name, region_size);
 #else
 			iounmap(iomem);
@@ -444,10 +447,10 @@ int __init generic_NCR5380_detect(struct scsi_host_template * tpnt)
 		}
 
 		instance->NCR5380_instance_name = overrides[current_override].NCR5380_map_name;
-#ifndef CONFIG_SCSI_G_NCR5380_MEM
+#ifndef SCSI_G_NCR5380_MEM
 		instance->n_io_port = region_size;
 #else
-		((struct NCR5380_hostdata *)instance->hostdata).iomem = iomem;
+		((struct NCR5380_hostdata *)instance->hostdata)->iomem = iomem;
 #endif
 
 		NCR5380_init(instance, flags);
@@ -515,10 +518,10 @@ int generic_NCR5380_release_resources(struct Scsi_Host *instance)
 		free_irq(instance->irq, instance);
 	NCR5380_exit(instance);
 
-#ifndef CONFIG_SCSI_G_NCR5380_MEM
+#ifndef SCSI_G_NCR5380_MEM
 	release_region(instance->NCR5380_instance_name, instance->n_io_port);
 #else
-	iounmap(((struct NCR5380_hostdata *)instance->hostdata).iomem);
+	iounmap(((struct NCR5380_hostdata *)instance->hostdata)->iomem);
 	release_mem_region(instance->NCR5380_instance_name, NCR5380_region_size);
 #endif
 
@@ -588,14 +591,14 @@ static inline int NCR5380_pread(struct Scsi_Host *instance, unsigned char *dst,
 		}
 		while (NCR5380_read(C400_CONTROL_STATUS_REG) & CSR_HOST_BUF_NOT_RDY);
 
-#ifndef CONFIG_SCSI_G_NCR5380_MEM
+#ifndef SCSI_G_NCR5380_MEM
 		{
 			int i;
 			for (i = 0; i < 128; i++)
 				dst[start + i] = NCR5380_read(C400_HOST_BUFFER);
 		}
 #else
-		/* implies CONFIG_SCSI_G_NCR5380_MEM */
+		/* implies SCSI_G_NCR5380_MEM */
 		memcpy_fromio(dst + start, iomem + NCR53C400_host_buffer, 128);
 #endif
 		start += 128;
@@ -608,14 +611,14 @@ static inline int NCR5380_pread(struct Scsi_Host *instance, unsigned char *dst,
 			// FIXME - no timeout
 		}
 
-#ifndef CONFIG_SCSI_G_NCR5380_MEM
+#ifndef SCSI_G_NCR5380_MEM
 		{
 			int i;	
 			for (i = 0; i < 128; i++)
 				dst[start + i] = NCR5380_read(C400_HOST_BUFFER);
 		}
 #else
-		/* implies CONFIG_SCSI_G_NCR5380_MEM */
+		/* implies SCSI_G_NCR5380_MEM */
 		memcpy_fromio(dst + start, iomem + NCR53C400_host_buffer, 128);
 #endif
 		start += 128;
@@ -674,13 +677,13 @@ static inline int NCR5380_pwrite(struct Scsi_Host *instance, unsigned char *src,
 		}
 		while (NCR5380_read(C400_CONTROL_STATUS_REG) & CSR_HOST_BUF_NOT_RDY)
 			; // FIXME - timeout
-#ifndef CONFIG_SCSI_G_NCR5380_MEM
+#ifndef SCSI_G_NCR5380_MEM
 		{
 			for (i = 0; i < 128; i++)
 				NCR5380_write(C400_HOST_BUFFER, src[start + i]);
 		}
 #else
-		/* implies CONFIG_SCSI_G_NCR5380_MEM */
+		/* implies SCSI_G_NCR5380_MEM */
 		memcpy_toio(iomem + NCR53C400_host_buffer, src + start, 128);
 #endif
 		start += 128;
@@ -690,13 +693,13 @@ static inline int NCR5380_pwrite(struct Scsi_Host *instance, unsigned char *src,
 		while (NCR5380_read(C400_CONTROL_STATUS_REG) & CSR_HOST_BUF_NOT_RDY)
 			; // FIXME - no timeout
 
-#ifndef CONFIG_SCSI_G_NCR5380_MEM
+#ifndef SCSI_G_NCR5380_MEM
 		{
 			for (i = 0; i < 128; i++)
 				NCR5380_write(C400_HOST_BUFFER, src[start + i]);
 		}
 #else
-		/* implies CONFIG_SCSI_G_NCR5380_MEM */
+		/* implies SCSI_G_NCR5380_MEM */
 		memcpy_toio(iomem + NCR53C400_host_buffer, src + start, 128);
 #endif
 		start += 128;
@@ -936,7 +939,7 @@ module_param(ncr_53c400a, int, 0);
 module_param(dtc_3181e, int, 0);
 MODULE_LICENSE("GPL");
 
-
+#ifndef SCSI_G_NCR5380_MEM
 static struct isapnp_device_id id_table[] __devinitdata = {
 	{
 	 ISAPNP_ANY_ID, ISAPNP_ANY_ID,
@@ -946,7 +949,7 @@ static struct isapnp_device_id id_table[] __devinitdata = {
 };
 
 MODULE_DEVICE_TABLE(isapnp, id_table);
-
+#endif
 
 __setup("ncr5380=", do_NCR5380_setup);
 __setup("ncr53c400=", do_NCR53C400_setup);

commit c94babbaf85c3162bd53a722ceeea32a0982d436
Author: Ondrej Zary <linux@rainbow-software.org>
Date:   Tue Aug 10 18:01:15 2010 -0700

    g_NCR5380: remove misleading pnp error message
    
    Remove misleading error message that appears after pnp card has been
    detected correctly.
    
    Signed-off-by: Ondrej Zary <linux@rainbow-software.org>
    Cc: James Bottomley <James.Bottomley@HansenPartnership.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/scsi/g_NCR5380.c b/drivers/scsi/g_NCR5380.c
index 75585a52c88b..6bc0015662e0 100644
--- a/drivers/scsi/g_NCR5380.c
+++ b/drivers/scsi/g_NCR5380.c
@@ -322,10 +322,8 @@ int __init generic_NCR5380_detect(struct scsi_host_template * tpnt)
 		while ((dev = pnp_find_dev(NULL, ISAPNP_VENDOR('D', 'T', 'C'), ISAPNP_FUNCTION(0x436e), dev))) {
 			if (count >= NO_OVERRIDES)
 				break;
-			if (pnp_device_attach(dev) < 0) {
-				printk(KERN_ERR "dtc436e probe: attach failed\n");
+			if (pnp_device_attach(dev) < 0)
 				continue;
-			}
 			if (pnp_activate_dev(dev) < 0) {
 				printk(KERN_ERR "dtc436e probe: activate failed\n");
 				pnp_device_detach(dev);

commit 1e641664301744f0d381de43ae1e12343e60b479
Author: Jeff Garzik <jeff@garzik.org>
Date:   Sun Nov 11 19:52:05 2007 -0500

    [SCSI] NCR5380: Fix bugs and canonicalize irq handler usage
    
    * Always pass the same value to free_irq() that we pass to
      request_irq().  This fixes several bugs.
    
    * Always call NCR5380_intr() with 'irq' and 'dev_id' arguments.
    
      Note, scsi_falcon_intr() is the only case now where dev_id is not the
      scsi_host.
    
    * Always pass Scsi_Host to request_irq().  For most cases, the drivers
      already did so, and I merely neated the source code line.  In other
      cases, either NULL or a non-sensical value was passed, verified to be
      unused, then changed to be Scsi_Host in anticipation of the future.
    
    In addition to the bugs fixes, this change makes the interface usage
    consistent, which in turn enables the possibility of directly
    referencing Scsi_Host from all NCR5380_intr() invocations.
    
    Signed-off-by: Jeff Garzik <jgarzik@redhat.com>
    Signed-off-by: James Bottomley <James.Bottomley@HansenPartnership.com>

diff --git a/drivers/scsi/g_NCR5380.c b/drivers/scsi/g_NCR5380.c
index 607336f56d55..75585a52c88b 100644
--- a/drivers/scsi/g_NCR5380.c
+++ b/drivers/scsi/g_NCR5380.c
@@ -460,7 +460,8 @@ int __init generic_NCR5380_detect(struct scsi_host_template * tpnt)
 			instance->irq = NCR5380_probe_irq(instance, 0xffff);
 
 		if (instance->irq != SCSI_IRQ_NONE)
-			if (request_irq(instance->irq, generic_NCR5380_intr, IRQF_DISABLED, "NCR5380", instance)) {
+			if (request_irq(instance->irq, generic_NCR5380_intr,
+					IRQF_DISABLED, "NCR5380", instance)) {
 				printk(KERN_WARNING "scsi%d : IRQ%d not free, interrupts disabled\n", instance->host_no, instance->irq);
 				instance->irq = SCSI_IRQ_NONE;
 			}
@@ -513,7 +514,7 @@ int generic_NCR5380_release_resources(struct Scsi_Host *instance)
 	NCR5380_setup(instance);
 	
 	if (instance->irq != SCSI_IRQ_NONE)
-		free_irq(instance->irq, NULL);
+		free_irq(instance->irq, instance);
 	NCR5380_exit(instance);
 
 #ifndef CONFIG_SCSI_G_NCR5380_MEM

commit 8d9e0f46b4a37077e112bdec3c6228e31547e3c9
Author: Gabriel C <nix.or.die@googlemail.com>
Date:   Fri Aug 10 14:50:39 2007 -0700

    [SCSI] NCR5380: fix NCR53C400_PSEUDO_DMA is not defined
    
    In file included from drivers/scsi/g_NCR5380_mmio.c:9:
    drivers/scsi/g_NCR5380.c:559:5: warning: "NCR53C400_PSEUDO_DMA" is not defined
    
    Signed-off-by: Gabriel Craciunescu <nix.or.die@googlemail.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>

diff --git a/drivers/scsi/g_NCR5380.c b/drivers/scsi/g_NCR5380.c
index 880f70d24e65..607336f56d55 100644
--- a/drivers/scsi/g_NCR5380.c
+++ b/drivers/scsi/g_NCR5380.c
@@ -556,7 +556,7 @@ generic_NCR5380_biosparam(struct scsi_device *sdev, struct block_device *bdev,
 }
 #endif
 
-#if NCR53C400_PSEUDO_DMA
+#ifdef NCR53C400_PSEUDO_DMA
 
 /**
  *	NCR5380_pread		-	pseudo DMA read

commit cd354f1ae75e6466a7e31b727faede57a1f89ca5
Author: Tim Schmielau <tim@physik3.uni-rostock.de>
Date:   Wed Feb 14 00:33:14 2007 -0800

    [PATCH] remove many unneeded #includes of sched.h
    
    After Al Viro (finally) succeeded in removing the sched.h #include in module.h
    recently, it makes sense again to remove other superfluous sched.h includes.
    There are quite a lot of files which include it but don't actually need
    anything defined in there.  Presumably these includes were once needed for
    macros that used to live in sched.h, but moved to other header files in the
    course of cleaning it up.
    
    To ease the pain, this time I did not fiddle with any header files and only
    removed #includes from .c-files, which tend to cause less trouble.
    
    Compile tested against 2.6.20-rc2 and 2.6.20-rc2-mm2 (with offsets) on alpha,
    arm, i386, ia64, mips, powerpc, and x86_64 with allnoconfig, defconfig,
    allmodconfig, and allyesconfig as well as a few randconfigs on x86_64 and all
    configs in arch/arm/configs on arm.  I also checked that no new warnings were
    introduced by the patch (actually, some warnings are removed that were emitted
    by unnecessarily included header files).
    
    Signed-off-by: Tim Schmielau <tim@physik3.uni-rostock.de>
    Acked-by: Russell King <rmk+kernel@arm.linux.org.uk>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/scsi/g_NCR5380.c b/drivers/scsi/g_NCR5380.c
index cdd893bb4e28..880f70d24e65 100644
--- a/drivers/scsi/g_NCR5380.c
+++ b/drivers/scsi/g_NCR5380.c
@@ -103,7 +103,6 @@
 #include <asm/system.h>
 #include <asm/io.h>
 #include <linux/signal.h>
-#include <linux/sched.h>
 #include <linux/blkdev.h>
 #include "scsi.h"
 #include <scsi/scsi_host.h>

commit 4ff36718ede26ee2da73f2dae94d71e2b06845fc
Author: Matthew Wilcox <matthew@wil.cx>
Date:   Tue Jul 4 12:15:20 2006 -0600

    [SCSI] Improve inquiry printing
    
     - Replace scsi_device_types array API with scsi_device_type function API.
       Gets rid of a lot of common code, as well as being easier to use.
     - Add the new device types in SPC4 r05a, and rename some of the older ones.
     - Reformat the printing of inquiry data; now fits on one line and
       includes PQ.
    
    I think I've addressed all the feedback from the previous versions.  My
    current test box prints:
    
    scsi 2:0:1:0: Direct access     HP 18.2G ATLAS10K3_18_SCA HP05 PQ: 0 ANSI: 2
    
    Signed-off-by: Matthew Wilcox <matthew@wil.cx>
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>

diff --git a/drivers/scsi/g_NCR5380.c b/drivers/scsi/g_NCR5380.c
index 67f1100f3103..cdd893bb4e28 100644
--- a/drivers/scsi/g_NCR5380.c
+++ b/drivers/scsi/g_NCR5380.c
@@ -811,7 +811,6 @@ static int generic_NCR5380_proc_info(struct Scsi_Host *scsi_ptr, char *buffer, c
 	struct NCR5380_hostdata *hostdata;
 #ifdef NCR5380_STATS
 	struct scsi_device *dev;
-	extern const char *const scsi_device_types[MAX_SCSI_DEVICE_CODE];
 #endif
 
 	NCR5380_setup(scsi_ptr);
@@ -851,7 +850,7 @@ static int generic_NCR5380_proc_info(struct Scsi_Host *scsi_ptr, char *buffer, c
 		long tr = hostdata->time_read[dev->id] / HZ;
 		long tw = hostdata->time_write[dev->id] / HZ;
 
-		PRINTP("  T:%d %s " ANDP dev->id ANDP(dev->type < MAX_SCSI_DEVICE_CODE) ? scsi_device_types[(int) dev->type] : "Unknown");
+		PRINTP("  T:%d %s " ANDP dev->id ANDP scsi_device_type(dev->type));
 		for (i = 0; i < 8; i++)
 			if (dev->vendor[i] >= 0x20)
 				*(buffer + (len++)) = dev->vendor[i];

commit 1d6f359a2e06296418481239f8054a878f36e819
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Sat Jul 1 19:29:42 2006 -0700

    [PATCH] irq-flags: scsi: Use the new IRQF_ constants
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: Ingo Molnar <mingo@elte.hu>
    Cc: "David S. Miller" <davem@davemloft.net>
    Cc: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Cc: James Bottomley <James.Bottomley@steeleye.com>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/drivers/scsi/g_NCR5380.c b/drivers/scsi/g_NCR5380.c
index fbc8e16c8d15..67f1100f3103 100644
--- a/drivers/scsi/g_NCR5380.c
+++ b/drivers/scsi/g_NCR5380.c
@@ -461,7 +461,7 @@ int __init generic_NCR5380_detect(struct scsi_host_template * tpnt)
 			instance->irq = NCR5380_probe_irq(instance, 0xffff);
 
 		if (instance->irq != SCSI_IRQ_NONE)
-			if (request_irq(instance->irq, generic_NCR5380_intr, SA_INTERRUPT, "NCR5380", instance)) {
+			if (request_irq(instance->irq, generic_NCR5380_intr, IRQF_DISABLED, "NCR5380", instance)) {
 				printk(KERN_WARNING "scsi%d : IRQ%d not free, interrupts disabled\n", instance->host_no, instance->irq);
 				instance->irq = SCSI_IRQ_NONE;
 			}

commit 6ab3d5624e172c553004ecc862bfeac16d9d68b7
Author: Jrn Engel <joern@wohnheim.fh-wedel.de>
Date:   Fri Jun 30 19:25:36 2006 +0200

    Remove obsolete #include <linux/config.h>
    
    Signed-off-by: Jrn Engel <joern@wohnheim.fh-wedel.de>
    Signed-off-by: Adrian Bunk <bunk@stusta.de>

diff --git a/drivers/scsi/g_NCR5380.c b/drivers/scsi/g_NCR5380.c
index 5f313c93b7a9..fbc8e16c8d15 100644
--- a/drivers/scsi/g_NCR5380.c
+++ b/drivers/scsi/g_NCR5380.c
@@ -91,7 +91,6 @@
 #define AUTOPROBE_IRQ
 #define AUTOSENSE
 
-#include <linux/config.h>
 
 #ifdef CONFIG_SCSI_GENERIC_NCR53C400
 #define NCR53C400_PSEUDO_DMA 1

commit 6391a11375de5e2bb1eb8481e54619761dc65d9f
Author: Tobias Klauser <tklauser@nuerscht.ch>
Date:   Thu Jun 8 22:23:48 2006 -0700

    [SCSI] drivers/scsi: Use ARRAY_SIZE macro
    
    Use ARRAY_SIZE macro instead of sizeof(x)/sizeof(x[0]) and remove
    duplicates of the macro.
    
    Signed-off-by: Tobias Klauser <tklauser@nuerscht.ch>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>

diff --git a/drivers/scsi/g_NCR5380.c b/drivers/scsi/g_NCR5380.c
index e6bcfe949340..5f313c93b7a9 100644
--- a/drivers/scsi/g_NCR5380.c
+++ b/drivers/scsi/g_NCR5380.c
@@ -138,10 +138,9 @@ static struct override {
 [1] __initdata = { { 0,},};
 #endif
 
+#define NO_OVERRIDES ARRAY_SIZE(overrides)
 
-#define NO_OVERRIDES (sizeof(overrides) / sizeof(struct override))
-
-#ifndef MODULE 
+#ifndef MODULE
 
 /**
  *	internal_setup		-	handle lilo command string override
@@ -210,7 +209,7 @@ static int __init do_NCR5380_setup(char *str)
 {
 	int ints[10];
 
-	get_options(str, sizeof(ints) / sizeof(int), ints);
+	get_options(str, ARRAY_SIZE(ints), ints);
 	internal_setup(BOARD_NCR5380, str, ints);
 	return 1;
 }
@@ -218,7 +217,7 @@ static int __init do_NCR5380_setup(char *str)
 /**
  * 	do_NCR53C400_setup		-	set up entry point
  *	@str: unused
- *	@ints: integer parameters from kernel setup code 
+ *	@ints: integer parameters from kernel setup code
  *
  *	Setup function invoked at boot to parse the ncr53c400= command
  *	line.
@@ -228,7 +227,7 @@ static int __init do_NCR53C400_setup(char *str)
 {
 	int ints[10];
 
-	get_options(str, sizeof(ints) / sizeof(int), ints);
+	get_options(str, ARRAY_SIZE(ints), ints);
 	internal_setup(BOARD_NCR53C400, str, ints);
 	return 1;
 }
@@ -236,7 +235,7 @@ static int __init do_NCR53C400_setup(char *str)
 /**
  * 	do_NCR53C400A_setup	-	set up entry point
  *	@str: unused
- *	@ints: integer parameters from kernel setup code 
+ *	@ints: integer parameters from kernel setup code
  *
  *	Setup function invoked at boot to parse the ncr53c400a= command
  *	line.
@@ -246,7 +245,7 @@ static int __init do_NCR53C400A_setup(char *str)
 {
 	int ints[10];
 
-	get_options(str, sizeof(ints) / sizeof(int), ints);
+	get_options(str, ARRAY_SIZE(ints), ints);
 	internal_setup(BOARD_NCR53C400A, str, ints);
 	return 1;
 }
@@ -254,7 +253,7 @@ static int __init do_NCR53C400A_setup(char *str)
 /**
  * 	do_DTC3181E_setup	-	set up entry point
  *	@str: unused
- *	@ints: integer parameters from kernel setup code 
+ *	@ints: integer parameters from kernel setup code
  *
  *	Setup function invoked at boot to parse the dtc3181e= command
  *	line.
@@ -264,7 +263,7 @@ static int __init do_DTC3181E_setup(char *str)
 {
 	int ints[10];
 
-	get_options(str, sizeof(ints) / sizeof(int), ints);
+	get_options(str, ARRAY_SIZE(ints), ints);
 	internal_setup(BOARD_DTC3181E, str, ints);
 	return 1;
 }

commit c818cb6406815716ab210ae15655ed94a973b15f
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Fri Mar 24 03:15:37 2006 -0800

    [PATCH] remove ISA legacy functions: drivers/scsi/g_NCR5380.c
    
    switched CONFIG_SCSI_G_NCR5380_MEM code in g_NCR5380 to ioremap(); massaged
    g_NCR5380.h accordingly.
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
    Signed-off-by: Adrian Bunk <bunk@stusta.de>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/drivers/scsi/g_NCR5380.c b/drivers/scsi/g_NCR5380.c
index 45756fa90777..e6bcfe949340 100644
--- a/drivers/scsi/g_NCR5380.c
+++ b/drivers/scsi/g_NCR5380.c
@@ -127,7 +127,7 @@ static int ncr_53c400a = NCR_NOT_SET;
 static int dtc_3181e = NCR_NOT_SET;
 
 static struct override {
-	NCR5380_implementation_fields;
+	NCR5380_map_type NCR5380_map_name;
 	int irq;
 	int dma;
 	int board;		/* Use NCR53c400, Ricoh, etc. extensions ? */
@@ -299,6 +299,10 @@ int __init generic_NCR5380_detect(struct scsi_host_template * tpnt)
 	};
 	int flags = 0;
 	struct Scsi_Host *instance;
+#ifdef CONFIG_SCSI_G_NCR5380_MEM
+	unsigned long base;
+	void __iomem *iomem;
+#endif
 
 	if (ncr_irq != NCR_NOT_SET)
 		overrides[0].irq = ncr_irq;
@@ -424,15 +428,22 @@ int __init generic_NCR5380_detect(struct scsi_host_template * tpnt)
 			region_size = NCR5380_region_size;
 		}
 #else
-		if(!request_mem_region(overrides[current_override].NCR5380_map_name, NCR5380_region_size, "ncr5380"))
+		base = overrides[current_override].NCR5380_map_name;
+		if (!request_mem_region(base, NCR5380_region_size, "ncr5380"))
+			continue;
+		iomem = ioremap(base, NCR5380_region_size);
+		if (!iomem) {
+			release_mem_region(base, NCR5380_region_size);
 			continue;
+		}
 #endif
 		instance = scsi_register(tpnt, sizeof(struct NCR5380_hostdata));
 		if (instance == NULL) {
 #ifndef CONFIG_SCSI_G_NCR5380_MEM
 			release_region(overrides[current_override].NCR5380_map_name, region_size);
 #else
-			release_mem_region(overrides[current_override].NCR5380_map_name, NCR5380_region_size);
+			iounmap(iomem);
+			release_mem_region(base, NCR5380_region_size);
 #endif
 			continue;
 		}
@@ -440,6 +451,8 @@ int __init generic_NCR5380_detect(struct scsi_host_template * tpnt)
 		instance->NCR5380_instance_name = overrides[current_override].NCR5380_map_name;
 #ifndef CONFIG_SCSI_G_NCR5380_MEM
 		instance->n_io_port = region_size;
+#else
+		((struct NCR5380_hostdata *)instance->hostdata).iomem = iomem;
 #endif
 
 		NCR5380_init(instance, flags);
@@ -509,6 +522,7 @@ int generic_NCR5380_release_resources(struct Scsi_Host *instance)
 #ifndef CONFIG_SCSI_G_NCR5380_MEM
 	release_region(instance->NCR5380_instance_name, instance->n_io_port);
 #else
+	iounmap(((struct NCR5380_hostdata *)instance->hostdata).iomem);
 	release_mem_region(instance->NCR5380_instance_name, NCR5380_region_size);
 #endif
 
@@ -586,7 +600,7 @@ static inline int NCR5380_pread(struct Scsi_Host *instance, unsigned char *dst,
 		}
 #else
 		/* implies CONFIG_SCSI_G_NCR5380_MEM */
-		isa_memcpy_fromio(dst + start, NCR53C400_host_buffer + NCR5380_map_name, 128);
+		memcpy_fromio(dst + start, iomem + NCR53C400_host_buffer, 128);
 #endif
 		start += 128;
 		blocks--;
@@ -606,7 +620,7 @@ static inline int NCR5380_pread(struct Scsi_Host *instance, unsigned char *dst,
 		}
 #else
 		/* implies CONFIG_SCSI_G_NCR5380_MEM */
-		isa_memcpy_fromio(dst + start, NCR53C400_host_buffer + NCR5380_map_name, 128);
+		memcpy_fromio(dst + start, iomem + NCR53C400_host_buffer, 128);
 #endif
 		start += 128;
 		blocks--;
@@ -671,7 +685,7 @@ static inline int NCR5380_pwrite(struct Scsi_Host *instance, unsigned char *src,
 		}
 #else
 		/* implies CONFIG_SCSI_G_NCR5380_MEM */
-		isa_memcpy_toio(NCR53C400_host_buffer + NCR5380_map_name, src + start, 128);
+		memcpy_toio(iomem + NCR53C400_host_buffer, src + start, 128);
 #endif
 		start += 128;
 		blocks--;
@@ -687,7 +701,7 @@ static inline int NCR5380_pwrite(struct Scsi_Host *instance, unsigned char *src,
 		}
 #else
 		/* implies CONFIG_SCSI_G_NCR5380_MEM */
-		isa_memcpy_toio(NCR53C400_host_buffer + NCR5380_map_name, src + start, 128);
+		memcpy_toio(iomem + NCR53C400_host_buffer, src + start, 128);
 #endif
 		start += 128;
 		blocks--;

commit f64a181d898e0518d5ae90c4870069510de977e1
Author: Christoph Hellwig <hch@lst.de>
Date:   Mon Oct 31 18:32:08 2005 +0100

    [SCSI] remove Scsi_Device typedef
    
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>

diff --git a/drivers/scsi/g_NCR5380.c b/drivers/scsi/g_NCR5380.c
index 1c1c50ef3ac1..45756fa90777 100644
--- a/drivers/scsi/g_NCR5380.c
+++ b/drivers/scsi/g_NCR5380.c
@@ -798,7 +798,7 @@ static int generic_NCR5380_proc_info(struct Scsi_Host *scsi_ptr, char *buffer, c
 	Scsi_Cmnd *ptr;
 	struct NCR5380_hostdata *hostdata;
 #ifdef NCR5380_STATS
-	Scsi_Device *dev;
+	struct scsi_device *dev;
 	extern const char *const scsi_device_types[MAX_SCSI_DEVICE_CODE];
 #endif
 

commit d0be4a7d29ad0bd3ce2209dd9e46d410b632db59
Author: Christoph Hellwig <hch@lst.de>
Date:   Mon Oct 31 18:31:40 2005 +0100

    [SCSI] remove Scsi_Host_Template typedef
    
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>

diff --git a/drivers/scsi/g_NCR5380.c b/drivers/scsi/g_NCR5380.c
index a3aa729b9d3c..1c1c50ef3ac1 100644
--- a/drivers/scsi/g_NCR5380.c
+++ b/drivers/scsi/g_NCR5380.c
@@ -285,7 +285,7 @@ static int __init do_DTC3181E_setup(char *str)
  *	Locks: none
  */
 
-int __init generic_NCR5380_detect(Scsi_Host_Template * tpnt)
+int __init generic_NCR5380_detect(struct scsi_host_template * tpnt)
 {
 	static int current_override = 0;
 	int count, i;
@@ -899,7 +899,7 @@ static int generic_NCR5380_proc_info(struct Scsi_Host *scsi_ptr, char *buffer, c
 #undef PRINTP
 #undef ANDP
 
-static Scsi_Host_Template driver_template = {
+static struct scsi_host_template driver_template = {
 	.proc_info      	= generic_NCR5380_proc_info,
 	.name           	= "Generic NCR5380/NCR53C400 Scsi Driver",
 	.detect         	= generic_NCR5380_detect,

commit 3471c288036bf0835a82d0b1bbce2002f6e68390
Author: Jeff Garzik <jgarzik@pobox.com>
Date:   Sat May 28 07:52:51 2005 -0400

    [SCSI] Remove no-op implementations of SCSI EH hooks
    
    Drivers need not implement a hook that returns FAILED, and does nothing
    else, since the SCSI midlayer code will do that for us.
    
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>

diff --git a/drivers/scsi/g_NCR5380.c b/drivers/scsi/g_NCR5380.c
index ca9d5bd26ca3..a3aa729b9d3c 100644
--- a/drivers/scsi/g_NCR5380.c
+++ b/drivers/scsi/g_NCR5380.c
@@ -908,8 +908,6 @@ static Scsi_Host_Template driver_template = {
 	.queuecommand   	= generic_NCR5380_queue_command,
 	.eh_abort_handler	= generic_NCR5380_abort,
 	.eh_bus_reset_handler	= generic_NCR5380_bus_reset,
-	.eh_device_reset_handler = generic_NCR5380_device_reset,
-	.eh_host_reset_handler	= generic_NCR5380_host_reset,
 	.bios_param     	= NCR5380_BIOSPARAM,
 	.can_queue      	= CAN_QUEUE,
         .this_id        	= 7,

commit 1da177e4c3f41524e886b7f1b8a0c1fc7321cac2
Author: Linus Torvalds <torvalds@ppc970.osdl.org>
Date:   Sat Apr 16 15:20:36 2005 -0700

    Linux-2.6.12-rc2
    
    Initial git repository build. I'm not bothering with the full history,
    even though we have it. We can create a separate "historical" git
    archive of that later if we want to, and in the meantime it's about
    3.2GB when imported into git - space that would just make the early
    git days unnecessarily complicated, when we don't have a lot of good
    infrastructure for it.
    
    Let it rip!

diff --git a/drivers/scsi/g_NCR5380.c b/drivers/scsi/g_NCR5380.c
new file mode 100644
index 000000000000..ca9d5bd26ca3
--- /dev/null
+++ b/drivers/scsi/g_NCR5380.c
@@ -0,0 +1,947 @@
+/*
+ * Generic Generic NCR5380 driver
+ *	
+ * Copyright 1993, Drew Eckhardt
+ *	Visionary Computing
+ *	(Unix and Linux consulting and custom programming)
+ *	drew@colorado.edu
+ *      +1 (303) 440-4894
+ *
+ * NCR53C400 extensions (c) 1994,1995,1996, Kevin Lentin
+ *    K.Lentin@cs.monash.edu.au
+ *
+ * NCR53C400A extensions (c) 1996, Ingmar Baumgart
+ *    ingmar@gonzo.schwaben.de
+ *
+ * DTC3181E extensions (c) 1997, Ronald van Cuijlenborg
+ * ronald.van.cuijlenborg@tip.nl or nutty@dds.nl
+ *
+ * Added ISAPNP support for DTC436 adapters,
+ * Thomas Sailer, sailer@ife.ee.ethz.ch
+ *
+ * ALPHA RELEASE 1. 
+ *
+ * For more information, please consult 
+ *
+ * NCR 5380 Family
+ * SCSI Protocol Controller
+ * Databook
+ *
+ * NCR Microelectronics
+ * 1635 Aeroplaza Drive
+ * Colorado Springs, CO 80916
+ * 1+ (719) 578-3400
+ * 1+ (800) 334-5454
+ */
+
+/* 
+ * TODO : flesh out DMA support, find some one actually using this (I have
+ * 	a memory mapped Trantor board that works fine)
+ */
+
+/*
+ * Options :
+ *
+ * PARITY - enable parity checking.  Not supported.
+ *
+ * SCSI2 - enable support for SCSI-II tagged queueing.  Untested.
+ *
+ * USLEEP - enable support for devices that don't disconnect.  Untested.
+ *
+ * The card is detected and initialized in one of several ways : 
+ * 1.  With command line overrides - NCR5380=port,irq may be 
+ *     used on the LILO command line to override the defaults.
+ *
+ * 2.  With the GENERIC_NCR5380_OVERRIDE compile time define.  This is 
+ *     specified as an array of address, irq, dma, board tuples.  Ie, for
+ *     one board at 0x350, IRQ5, no dma, I could say  
+ *     -DGENERIC_NCR5380_OVERRIDE={{0xcc000, 5, DMA_NONE, BOARD_NCR5380}}
+ * 
+ * -1 should be specified for no or DMA interrupt, -2 to autoprobe for an 
+ * 	IRQ line if overridden on the command line.
+ *
+ * 3.  When included as a module, with arguments passed on the command line:
+ *         ncr_irq=xx	the interrupt
+ *         ncr_addr=xx  the port or base address (for port or memory
+ *              	mapped, resp.)
+ *         ncr_dma=xx	the DMA
+ *         ncr_5380=1	to set up for a NCR5380 board
+ *         ncr_53c400=1	to set up for a NCR53C400 board
+ *     e.g.
+ *     modprobe g_NCR5380 ncr_irq=5 ncr_addr=0x350 ncr_5380=1
+ *       for a port mapped NCR5380 board or
+ *     modprobe g_NCR5380 ncr_irq=255 ncr_addr=0xc8000 ncr_53c400=1
+ *       for a memory mapped NCR53C400 board with interrupts disabled.
+ * 
+ * 255 should be specified for no or DMA interrupt, 254 to autoprobe for an 
+ * 	IRQ line if overridden on the command line.
+ *     
+ */
+
+/*
+ * $Log: generic_NCR5380.c,v $
+ */
+
+/* settings for DTC3181E card with only Mustek scanner attached */
+#define USLEEP
+#define USLEEP_POLL	1
+#define USLEEP_SLEEP	20
+#define USLEEP_WAITLONG	500
+
+#define AUTOPROBE_IRQ
+#define AUTOSENSE
+
+#include <linux/config.h>
+
+#ifdef CONFIG_SCSI_GENERIC_NCR53C400
+#define NCR53C400_PSEUDO_DMA 1
+#define PSEUDO_DMA
+#define NCR53C400
+#define NCR5380_STATS
+#undef NCR5380_STAT_LIMIT
+#endif
+
+#include <asm/system.h>
+#include <asm/io.h>
+#include <linux/signal.h>
+#include <linux/sched.h>
+#include <linux/blkdev.h>
+#include "scsi.h"
+#include <scsi/scsi_host.h>
+#include "g_NCR5380.h"
+#include "NCR5380.h"
+#include <linux/stat.h>
+#include <linux/init.h>
+#include <linux/ioport.h>
+#include <linux/isapnp.h>
+#include <linux/delay.h>
+#include <linux/interrupt.h>
+
+#define NCR_NOT_SET 0
+static int ncr_irq = NCR_NOT_SET;
+static int ncr_dma = NCR_NOT_SET;
+static int ncr_addr = NCR_NOT_SET;
+static int ncr_5380 = NCR_NOT_SET;
+static int ncr_53c400 = NCR_NOT_SET;
+static int ncr_53c400a = NCR_NOT_SET;
+static int dtc_3181e = NCR_NOT_SET;
+
+static struct override {
+	NCR5380_implementation_fields;
+	int irq;
+	int dma;
+	int board;		/* Use NCR53c400, Ricoh, etc. extensions ? */
+} overrides
+#ifdef GENERIC_NCR5380_OVERRIDE
+[] __initdata = GENERIC_NCR5380_OVERRIDE;
+#else
+[1] __initdata = { { 0,},};
+#endif
+
+
+#define NO_OVERRIDES (sizeof(overrides) / sizeof(struct override))
+
+#ifndef MODULE 
+
+/**
+ *	internal_setup		-	handle lilo command string override
+ *	@board:	BOARD_* identifier for the board
+ *	@str: unused
+ *	@ints: numeric parameters
+ *
+ * 	Do LILO command line initialization of the overrides array. Display
+ *	errors when needed
+ *
+ *	Locks: none
+ */
+
+static void __init internal_setup(int board, char *str, int *ints)
+{
+	static int commandline_current = 0;
+	switch (board) {
+	case BOARD_NCR5380:
+		if (ints[0] != 2 && ints[0] != 3) {
+			printk(KERN_ERR "generic_NCR5380_setup : usage ncr5380=" STRVAL(NCR5380_map_name) ",irq,dma\n");
+			return;
+		}
+		break;
+	case BOARD_NCR53C400:
+		if (ints[0] != 2) {
+			printk(KERN_ERR "generic_NCR53C400_setup : usage ncr53c400=" STRVAL(NCR5380_map_name) ",irq\n");
+			return;
+		}
+		break;
+	case BOARD_NCR53C400A:
+		if (ints[0] != 2) {
+			printk(KERN_ERR "generic_NCR53C400A_setup : usage ncr53c400a=" STRVAL(NCR5380_map_name) ",irq\n");
+			return;
+		}
+		break;
+	case BOARD_DTC3181E:
+		if (ints[0] != 2) {
+			printk("generic_DTC3181E_setup : usage dtc3181e=" STRVAL(NCR5380_map_name) ",irq\n");
+			return;
+		}
+		break;
+	}
+
+	if (commandline_current < NO_OVERRIDES) {
+		overrides[commandline_current].NCR5380_map_name = (NCR5380_map_type) ints[1];
+		overrides[commandline_current].irq = ints[2];
+		if (ints[0] == 3)
+			overrides[commandline_current].dma = ints[3];
+		else
+			overrides[commandline_current].dma = DMA_NONE;
+		overrides[commandline_current].board = board;
+		++commandline_current;
+	}
+}
+
+
+/**
+ * 	do_NCR53C80_setup		-	set up entry point
+ *	@str: unused
+ *
+ *	Setup function invoked at boot to parse the ncr5380= command
+ *	line.
+ */
+
+static int __init do_NCR5380_setup(char *str)
+{
+	int ints[10];
+
+	get_options(str, sizeof(ints) / sizeof(int), ints);
+	internal_setup(BOARD_NCR5380, str, ints);
+	return 1;
+}
+
+/**
+ * 	do_NCR53C400_setup		-	set up entry point
+ *	@str: unused
+ *	@ints: integer parameters from kernel setup code 
+ *
+ *	Setup function invoked at boot to parse the ncr53c400= command
+ *	line.
+ */
+
+static int __init do_NCR53C400_setup(char *str)
+{
+	int ints[10];
+
+	get_options(str, sizeof(ints) / sizeof(int), ints);
+	internal_setup(BOARD_NCR53C400, str, ints);
+	return 1;
+}
+
+/**
+ * 	do_NCR53C400A_setup	-	set up entry point
+ *	@str: unused
+ *	@ints: integer parameters from kernel setup code 
+ *
+ *	Setup function invoked at boot to parse the ncr53c400a= command
+ *	line.
+ */
+
+static int __init do_NCR53C400A_setup(char *str)
+{
+	int ints[10];
+
+	get_options(str, sizeof(ints) / sizeof(int), ints);
+	internal_setup(BOARD_NCR53C400A, str, ints);
+	return 1;
+}
+
+/**
+ * 	do_DTC3181E_setup	-	set up entry point
+ *	@str: unused
+ *	@ints: integer parameters from kernel setup code 
+ *
+ *	Setup function invoked at boot to parse the dtc3181e= command
+ *	line.
+ */
+
+static int __init do_DTC3181E_setup(char *str)
+{
+	int ints[10];
+
+	get_options(str, sizeof(ints) / sizeof(int), ints);
+	internal_setup(BOARD_DTC3181E, str, ints);
+	return 1;
+}
+
+#endif
+
+/**
+ * 	generic_NCR5380_detect	-	look for NCR5380 controllers
+ *	@tpnt: the scsi template
+ *
+ *	Scan for the present of NCR5380, NCR53C400, NCR53C400A, DTC3181E
+ *	and DTC436(ISAPnP) controllers. If overrides have been set we use
+ *	them.
+ *
+ *	The caller supplied NCR5380_init function is invoked from here, before
+ *	the interrupt line is taken.
+ *
+ *	Locks: none
+ */
+
+int __init generic_NCR5380_detect(Scsi_Host_Template * tpnt)
+{
+	static int current_override = 0;
+	int count, i;
+	unsigned int *ports;
+	unsigned long region_size = 16;
+	static unsigned int __initdata ncr_53c400a_ports[] = {
+		0x280, 0x290, 0x300, 0x310, 0x330, 0x340, 0x348, 0x350, 0
+	};
+	static unsigned int __initdata dtc_3181e_ports[] = {
+		0x220, 0x240, 0x280, 0x2a0, 0x2c0, 0x300, 0x320, 0x340, 0
+	};
+	int flags = 0;
+	struct Scsi_Host *instance;
+
+	if (ncr_irq != NCR_NOT_SET)
+		overrides[0].irq = ncr_irq;
+	if (ncr_dma != NCR_NOT_SET)
+		overrides[0].dma = ncr_dma;
+	if (ncr_addr != NCR_NOT_SET)
+		overrides[0].NCR5380_map_name = (NCR5380_map_type) ncr_addr;
+	if (ncr_5380 != NCR_NOT_SET)
+		overrides[0].board = BOARD_NCR5380;
+	else if (ncr_53c400 != NCR_NOT_SET)
+		overrides[0].board = BOARD_NCR53C400;
+	else if (ncr_53c400a != NCR_NOT_SET)
+		overrides[0].board = BOARD_NCR53C400A;
+	else if (dtc_3181e != NCR_NOT_SET)
+		overrides[0].board = BOARD_DTC3181E;
+
+	if (!current_override && isapnp_present()) {
+		struct pnp_dev *dev = NULL;
+		count = 0;
+		while ((dev = pnp_find_dev(NULL, ISAPNP_VENDOR('D', 'T', 'C'), ISAPNP_FUNCTION(0x436e), dev))) {
+			if (count >= NO_OVERRIDES)
+				break;
+			if (pnp_device_attach(dev) < 0) {
+				printk(KERN_ERR "dtc436e probe: attach failed\n");
+				continue;
+			}
+			if (pnp_activate_dev(dev) < 0) {
+				printk(KERN_ERR "dtc436e probe: activate failed\n");
+				pnp_device_detach(dev);
+				continue;
+			}
+			if (!pnp_port_valid(dev, 0)) {
+				printk(KERN_ERR "dtc436e probe: no valid port\n");
+				pnp_device_detach(dev);
+				continue;
+			}
+			if (pnp_irq_valid(dev, 0))
+				overrides[count].irq = pnp_irq(dev, 0);
+			else
+				overrides[count].irq = SCSI_IRQ_NONE;
+			if (pnp_dma_valid(dev, 0))
+				overrides[count].dma = pnp_dma(dev, 0);
+			else
+				overrides[count].dma = DMA_NONE;
+			overrides[count].NCR5380_map_name = (NCR5380_map_type) pnp_port_start(dev, 0);
+			overrides[count].board = BOARD_DTC3181E;
+			count++;
+		}
+	}
+
+	tpnt->proc_name = "g_NCR5380";
+
+	for (count = 0; current_override < NO_OVERRIDES; ++current_override) {
+		if (!(overrides[current_override].NCR5380_map_name))
+			continue;
+
+		ports = NULL;
+		switch (overrides[current_override].board) {
+		case BOARD_NCR5380:
+			flags = FLAG_NO_PSEUDO_DMA;
+			break;
+		case BOARD_NCR53C400:
+			flags = FLAG_NCR53C400;
+			break;
+		case BOARD_NCR53C400A:
+			flags = FLAG_NO_PSEUDO_DMA;
+			ports = ncr_53c400a_ports;
+			break;
+		case BOARD_DTC3181E:
+			flags = FLAG_NO_PSEUDO_DMA | FLAG_DTC3181E;
+			ports = dtc_3181e_ports;
+			break;
+		}
+
+#ifndef CONFIG_SCSI_G_NCR5380_MEM
+		if (ports) {
+			/* wakeup sequence for the NCR53C400A and DTC3181E */
+
+			/* Disable the adapter and look for a free io port */
+			outb(0x59, 0x779);
+			outb(0xb9, 0x379);
+			outb(0xc5, 0x379);
+			outb(0xae, 0x379);
+			outb(0xa6, 0x379);
+			outb(0x00, 0x379);
+
+			if (overrides[current_override].NCR5380_map_name != PORT_AUTO)
+				for (i = 0; ports[i]; i++) {
+					if (!request_region(ports[i],  16, "ncr53c80"))
+						continue;
+					if (overrides[current_override].NCR5380_map_name == ports[i])
+						break;
+					release_region(ports[i], 16);
+			} else
+				for (i = 0; ports[i]; i++) {
+					if (!request_region(ports[i],  16, "ncr53c80"))
+						continue;
+					if (inb(ports[i]) == 0xff)
+						break;
+					release_region(ports[i], 16);
+				}
+			if (ports[i]) {
+				/* At this point we have our region reserved */
+				outb(0x59, 0x779);
+				outb(0xb9, 0x379);
+				outb(0xc5, 0x379);
+				outb(0xae, 0x379);
+				outb(0xa6, 0x379);
+				outb(0x80 | i, 0x379);	/* set io port to be used */
+				outb(0xc0, ports[i] + 9);
+				if (inb(ports[i] + 9) != 0x80)
+					continue;
+				else
+					overrides[current_override].NCR5380_map_name = ports[i];
+			} else
+				continue;
+		}
+		else
+		{
+			/* Not a 53C400A style setup - just grab */
+			if(!(request_region(overrides[current_override].NCR5380_map_name, NCR5380_region_size, "ncr5380")))
+				continue;
+			region_size = NCR5380_region_size;
+		}
+#else
+		if(!request_mem_region(overrides[current_override].NCR5380_map_name, NCR5380_region_size, "ncr5380"))
+			continue;
+#endif
+		instance = scsi_register(tpnt, sizeof(struct NCR5380_hostdata));
+		if (instance == NULL) {
+#ifndef CONFIG_SCSI_G_NCR5380_MEM
+			release_region(overrides[current_override].NCR5380_map_name, region_size);
+#else
+			release_mem_region(overrides[current_override].NCR5380_map_name, NCR5380_region_size);
+#endif
+			continue;
+		}
+
+		instance->NCR5380_instance_name = overrides[current_override].NCR5380_map_name;
+#ifndef CONFIG_SCSI_G_NCR5380_MEM
+		instance->n_io_port = region_size;
+#endif
+
+		NCR5380_init(instance, flags);
+
+		if (overrides[current_override].irq != IRQ_AUTO)
+			instance->irq = overrides[current_override].irq;
+		else
+			instance->irq = NCR5380_probe_irq(instance, 0xffff);
+
+		if (instance->irq != SCSI_IRQ_NONE)
+			if (request_irq(instance->irq, generic_NCR5380_intr, SA_INTERRUPT, "NCR5380", instance)) {
+				printk(KERN_WARNING "scsi%d : IRQ%d not free, interrupts disabled\n", instance->host_no, instance->irq);
+				instance->irq = SCSI_IRQ_NONE;
+			}
+
+		if (instance->irq == SCSI_IRQ_NONE) {
+			printk(KERN_INFO "scsi%d : interrupts not enabled. for better interactive performance,\n", instance->host_no);
+			printk(KERN_INFO "scsi%d : please jumper the board for a free IRQ.\n", instance->host_no);
+		}
+
+		printk(KERN_INFO "scsi%d : at " STRVAL(NCR5380_map_name) " 0x%x", instance->host_no, (unsigned int) instance->NCR5380_instance_name);
+		if (instance->irq == SCSI_IRQ_NONE)
+			printk(" interrupts disabled");
+		else
+			printk(" irq %d", instance->irq);
+		printk(" options CAN_QUEUE=%d  CMD_PER_LUN=%d release=%d", CAN_QUEUE, CMD_PER_LUN, GENERIC_NCR5380_PUBLIC_RELEASE);
+		NCR5380_print_options(instance);
+		printk("\n");
+
+		++current_override;
+		++count;
+	}
+	return count;
+}
+
+/**
+ *	generic_NCR5380_info	-	reporting string
+ *	@host: NCR5380 to report on
+ *
+ *	Report driver information for the NCR5380
+ */
+ 	
+const char *generic_NCR5380_info(struct Scsi_Host *host)
+{
+	static const char string[] = "Generic NCR5380/53C400 Driver";
+	return string;
+}
+
+/**
+ *	generic_NCR5380_release_resources	-	free resources
+ *	@instance: host adapter to clean up 
+ *
+ *	Free the generic interface resources from this adapter.
+ *
+ *	Locks: none
+ */
+ 
+int generic_NCR5380_release_resources(struct Scsi_Host *instance)
+{
+	NCR5380_local_declare();
+	NCR5380_setup(instance);
+	
+	if (instance->irq != SCSI_IRQ_NONE)
+		free_irq(instance->irq, NULL);
+	NCR5380_exit(instance);
+
+#ifndef CONFIG_SCSI_G_NCR5380_MEM
+	release_region(instance->NCR5380_instance_name, instance->n_io_port);
+#else
+	release_mem_region(instance->NCR5380_instance_name, NCR5380_region_size);
+#endif
+
+
+	return 0;
+}
+
+#ifdef BIOSPARAM
+/**
+ *	generic_NCR5380_biosparam
+ *	@disk: disk to compute geometry for
+ *	@dev: device identifier for this disk
+ *	@ip: sizes to fill in
+ *
+ *	Generates a BIOS / DOS compatible H-C-S mapping for the specified 
+ *	device / size.
+ * 
+ * 	XXX Most SCSI boards use this mapping, I could be incorrect.  Someone
+ *	using hard disks on a trantor should verify that this mapping
+ *	corresponds to that used by the BIOS / ASPI driver by running the linux
+ *	fdisk program and matching the H_C_S coordinates to what DOS uses.
+ *
+ *	Locks: none
+ */
+
+static int
+generic_NCR5380_biosparam(struct scsi_device *sdev, struct block_device *bdev,
+			  sector_t capacity, int *ip)
+{
+	ip[0] = 64;
+	ip[1] = 32;
+	ip[2] = capacity >> 11;
+	return 0;
+}
+#endif
+
+#if NCR53C400_PSEUDO_DMA
+
+/**
+ *	NCR5380_pread		-	pseudo DMA read
+ *	@instance: adapter to read from
+ *	@dst: buffer to read into
+ *	@len: buffer length
+ *
+ *	Perform a psuedo DMA mode read from an NCR53C400 or equivalent
+ *	controller
+ */
+ 
+static inline int NCR5380_pread(struct Scsi_Host *instance, unsigned char *dst, int len)
+{
+	int blocks = len / 128;
+	int start = 0;
+	int bl;
+
+	NCR5380_local_declare();
+	NCR5380_setup(instance);
+
+	NCR5380_write(C400_CONTROL_STATUS_REG, CSR_BASE | CSR_TRANS_DIR);
+	NCR5380_write(C400_BLOCK_COUNTER_REG, blocks);
+	while (1) {
+		if ((bl = NCR5380_read(C400_BLOCK_COUNTER_REG)) == 0) {
+			break;
+		}
+		if (NCR5380_read(C400_CONTROL_STATUS_REG) & CSR_GATED_53C80_IRQ) {
+			printk(KERN_ERR "53C400r: Got 53C80_IRQ start=%d, blocks=%d\n", start, blocks);
+			return -1;
+		}
+		while (NCR5380_read(C400_CONTROL_STATUS_REG) & CSR_HOST_BUF_NOT_RDY);
+
+#ifndef CONFIG_SCSI_G_NCR5380_MEM
+		{
+			int i;
+			for (i = 0; i < 128; i++)
+				dst[start + i] = NCR5380_read(C400_HOST_BUFFER);
+		}
+#else
+		/* implies CONFIG_SCSI_G_NCR5380_MEM */
+		isa_memcpy_fromio(dst + start, NCR53C400_host_buffer + NCR5380_map_name, 128);
+#endif
+		start += 128;
+		blocks--;
+	}
+
+	if (blocks) {
+		while (NCR5380_read(C400_CONTROL_STATUS_REG) & CSR_HOST_BUF_NOT_RDY)
+		{
+			// FIXME - no timeout
+		}
+
+#ifndef CONFIG_SCSI_G_NCR5380_MEM
+		{
+			int i;	
+			for (i = 0; i < 128; i++)
+				dst[start + i] = NCR5380_read(C400_HOST_BUFFER);
+		}
+#else
+		/* implies CONFIG_SCSI_G_NCR5380_MEM */
+		isa_memcpy_fromio(dst + start, NCR53C400_host_buffer + NCR5380_map_name, 128);
+#endif
+		start += 128;
+		blocks--;
+	}
+
+	if (!(NCR5380_read(C400_CONTROL_STATUS_REG) & CSR_GATED_53C80_IRQ))
+		printk("53C400r: no 53C80 gated irq after transfer");
+
+#if 0
+	/*
+	 *	DON'T DO THIS - THEY NEVER ARRIVE!
+	 */
+	printk("53C400r: Waiting for 53C80 registers\n");
+	while (NCR5380_read(C400_CONTROL_STATUS_REG) & CSR_53C80_REG)
+		;
+#endif
+	if (!(NCR5380_read(BUS_AND_STATUS_REG) & BASR_END_DMA_TRANSFER))
+		printk(KERN_ERR "53C400r: no end dma signal\n");
+		
+	NCR5380_write(MODE_REG, MR_BASE);
+	NCR5380_read(RESET_PARITY_INTERRUPT_REG);
+	return 0;
+}
+
+/**
+ *	NCR5380_write		-	pseudo DMA write
+ *	@instance: adapter to read from
+ *	@dst: buffer to read into
+ *	@len: buffer length
+ *
+ *	Perform a psuedo DMA mode read from an NCR53C400 or equivalent
+ *	controller
+ */
+
+static inline int NCR5380_pwrite(struct Scsi_Host *instance, unsigned char *src, int len)
+{
+	int blocks = len / 128;
+	int start = 0;
+	int bl;
+	int i;
+
+	NCR5380_local_declare();
+	NCR5380_setup(instance);
+
+	NCR5380_write(C400_CONTROL_STATUS_REG, CSR_BASE);
+	NCR5380_write(C400_BLOCK_COUNTER_REG, blocks);
+	while (1) {
+		if (NCR5380_read(C400_CONTROL_STATUS_REG) & CSR_GATED_53C80_IRQ) {
+			printk(KERN_ERR "53C400w: Got 53C80_IRQ start=%d, blocks=%d\n", start, blocks);
+			return -1;
+		}
+
+		if ((bl = NCR5380_read(C400_BLOCK_COUNTER_REG)) == 0) {
+			break;
+		}
+		while (NCR5380_read(C400_CONTROL_STATUS_REG) & CSR_HOST_BUF_NOT_RDY)
+			; // FIXME - timeout
+#ifndef CONFIG_SCSI_G_NCR5380_MEM
+		{
+			for (i = 0; i < 128; i++)
+				NCR5380_write(C400_HOST_BUFFER, src[start + i]);
+		}
+#else
+		/* implies CONFIG_SCSI_G_NCR5380_MEM */
+		isa_memcpy_toio(NCR53C400_host_buffer + NCR5380_map_name, src + start, 128);
+#endif
+		start += 128;
+		blocks--;
+	}
+	if (blocks) {
+		while (NCR5380_read(C400_CONTROL_STATUS_REG) & CSR_HOST_BUF_NOT_RDY)
+			; // FIXME - no timeout
+
+#ifndef CONFIG_SCSI_G_NCR5380_MEM
+		{
+			for (i = 0; i < 128; i++)
+				NCR5380_write(C400_HOST_BUFFER, src[start + i]);
+		}
+#else
+		/* implies CONFIG_SCSI_G_NCR5380_MEM */
+		isa_memcpy_toio(NCR53C400_host_buffer + NCR5380_map_name, src + start, 128);
+#endif
+		start += 128;
+		blocks--;
+	}
+
+#if 0
+	printk("53C400w: waiting for registers to be available\n");
+	THEY NEVER DO ! while (NCR5380_read(C400_CONTROL_STATUS_REG) & CSR_53C80_REG);
+	printk("53C400w: Got em\n");
+#endif
+
+	/* Let's wait for this instead - could be ugly */
+	/* All documentation says to check for this. Maybe my hardware is too
+	 * fast. Waiting for it seems to work fine! KLL
+	 */
+	while (!(i = NCR5380_read(C400_CONTROL_STATUS_REG) & CSR_GATED_53C80_IRQ))
+		;	// FIXME - no timeout
+
+	/*
+	 * I know. i is certainly != 0 here but the loop is new. See previous
+	 * comment.
+	 */
+	if (i) {
+		if (!((i = NCR5380_read(BUS_AND_STATUS_REG)) & BASR_END_DMA_TRANSFER))
+			printk(KERN_ERR "53C400w: No END OF DMA bit - WHOOPS! BASR=%0x\n", i);
+	} else
+		printk(KERN_ERR "53C400w: no 53C80 gated irq after transfer (last block)\n");
+
+#if 0
+	if (!(NCR5380_read(BUS_AND_STATUS_REG) & BASR_END_DMA_TRANSFER)) {
+		printk(KERN_ERR "53C400w: no end dma signal\n");
+	}
+#endif
+	while (!(NCR5380_read(TARGET_COMMAND_REG) & TCR_LAST_BYTE_SENT))
+		; 	// TIMEOUT
+	return 0;
+}
+#endif				/* PSEUDO_DMA */
+
+/*
+ *	Include the NCR5380 core code that we build our driver around	
+ */
+ 
+#include "NCR5380.c"
+
+#define PRINTP(x) len += sprintf(buffer+len, x)
+#define ANDP ,
+
+static int sprint_opcode(char *buffer, int len, int opcode)
+{
+	int start = len;
+	PRINTP("0x%02x " ANDP opcode);
+	return len - start;
+}
+
+static int sprint_command(char *buffer, int len, unsigned char *command)
+{
+	int i, s, start = len;
+	len += sprint_opcode(buffer, len, command[0]);
+	for (i = 1, s = COMMAND_SIZE(command[0]); i < s; ++i)
+		PRINTP("%02x " ANDP command[i]);
+	PRINTP("\n");
+	return len - start;
+}
+
+/**
+ *	sprintf_Scsi_Cmnd	-	print a scsi command
+ *	@buffer: buffr to print into
+ *	@len: buffer length
+ *	@cmd: SCSI command block
+ *	
+ *	Print out the target and command data in hex
+ */
+
+static int sprint_Scsi_Cmnd(char *buffer, int len, Scsi_Cmnd * cmd)
+{
+	int start = len;
+	PRINTP("host number %d destination target %d, lun %d\n" ANDP cmd->device->host->host_no ANDP cmd->device->id ANDP cmd->device->lun);
+	PRINTP("        command = ");
+	len += sprint_command(buffer, len, cmd->cmnd);
+	return len - start;
+}
+
+/**
+ *	generic_NCR5380_proc_info	-	/proc for NCR5380 driver
+ *	@buffer: buffer to print into
+ *	@start: start position
+ *	@offset: offset into buffer
+ *	@len: length
+ *	@hostno: instance to affect
+ *	@inout: read/write
+ *
+ *	Provide the procfs information for the 5380 controller. We fill
+ *	this with useful debugging information including the commands
+ *	being executed, disconnected command queue and the statistical
+ *	data
+ *
+ *	Locks: global cli/lock for queue walk
+ */
+ 
+static int generic_NCR5380_proc_info(struct Scsi_Host *scsi_ptr, char *buffer, char **start, off_t offset, int length, int inout)
+{
+	int len = 0;
+	NCR5380_local_declare();
+	unsigned long flags;
+	unsigned char status;
+	int i;
+	Scsi_Cmnd *ptr;
+	struct NCR5380_hostdata *hostdata;
+#ifdef NCR5380_STATS
+	Scsi_Device *dev;
+	extern const char *const scsi_device_types[MAX_SCSI_DEVICE_CODE];
+#endif
+
+	NCR5380_setup(scsi_ptr);
+	hostdata = (struct NCR5380_hostdata *) scsi_ptr->hostdata;
+
+	spin_lock_irqsave(scsi_ptr->host_lock, flags);
+	PRINTP("SCSI host number %d : %s\n" ANDP scsi_ptr->host_no ANDP scsi_ptr->hostt->name);
+	PRINTP("Generic NCR5380 driver version %d\n" ANDP GENERIC_NCR5380_PUBLIC_RELEASE);
+	PRINTP("NCR5380 core version %d\n" ANDP NCR5380_PUBLIC_RELEASE);
+#ifdef NCR53C400
+	PRINTP("NCR53C400 extension version %d\n" ANDP NCR53C400_PUBLIC_RELEASE);
+	PRINTP("NCR53C400 card%s detected\n" ANDP(((struct NCR5380_hostdata *) scsi_ptr->hostdata)->flags & FLAG_NCR53C400) ? "" : " not");
+# if NCR53C400_PSEUDO_DMA
+	PRINTP("NCR53C400 pseudo DMA used\n");
+# endif
+#else
+	PRINTP("NO NCR53C400 driver extensions\n");
+#endif
+	PRINTP("Using %s mapping at %s 0x%lx, " ANDP STRVAL(NCR5380_map_config) ANDP STRVAL(NCR5380_map_name) ANDP scsi_ptr->NCR5380_instance_name);
+	if (scsi_ptr->irq == SCSI_IRQ_NONE)
+		PRINTP("no interrupt\n");
+	else
+		PRINTP("on interrupt %d\n" ANDP scsi_ptr->irq);
+
+#ifdef NCR5380_STATS
+	if (hostdata->connected || hostdata->issue_queue || hostdata->disconnected_queue)
+		PRINTP("There are commands pending, transfer rates may be crud\n");
+	if (hostdata->pendingr)
+		PRINTP("  %d pending reads" ANDP hostdata->pendingr);
+	if (hostdata->pendingw)
+		PRINTP("  %d pending writes" ANDP hostdata->pendingw);
+	if (hostdata->pendingr || hostdata->pendingw)
+		PRINTP("\n");
+	shost_for_each_device(dev, scsi_ptr) {
+		unsigned long br = hostdata->bytes_read[dev->id];
+		unsigned long bw = hostdata->bytes_write[dev->id];
+		long tr = hostdata->time_read[dev->id] / HZ;
+		long tw = hostdata->time_write[dev->id] / HZ;
+
+		PRINTP("  T:%d %s " ANDP dev->id ANDP(dev->type < MAX_SCSI_DEVICE_CODE) ? scsi_device_types[(int) dev->type] : "Unknown");
+		for (i = 0; i < 8; i++)
+			if (dev->vendor[i] >= 0x20)
+				*(buffer + (len++)) = dev->vendor[i];
+		*(buffer + (len++)) = ' ';
+		for (i = 0; i < 16; i++)
+			if (dev->model[i] >= 0x20)
+				*(buffer + (len++)) = dev->model[i];
+		*(buffer + (len++)) = ' ';
+		for (i = 0; i < 4; i++)
+			if (dev->rev[i] >= 0x20)
+				*(buffer + (len++)) = dev->rev[i];
+		*(buffer + (len++)) = ' ';
+
+		PRINTP("\n%10ld kb read    in %5ld secs" ANDP br / 1024 ANDP tr);
+		if (tr)
+			PRINTP(" @ %5ld bps" ANDP br / tr);
+
+		PRINTP("\n%10ld kb written in %5ld secs" ANDP bw / 1024 ANDP tw);
+		if (tw)
+			PRINTP(" @ %5ld bps" ANDP bw / tw);
+		PRINTP("\n");
+	}
+#endif
+
+	status = NCR5380_read(STATUS_REG);
+	if (!(status & SR_REQ))
+		PRINTP("REQ not asserted, phase unknown.\n");
+	else {
+		for (i = 0; (phases[i].value != PHASE_UNKNOWN) && (phases[i].value != (status & PHASE_MASK)); ++i);
+		PRINTP("Phase %s\n" ANDP phases[i].name);
+	}
+
+	if (!hostdata->connected) {
+		PRINTP("No currently connected command\n");
+	} else {
+		len += sprint_Scsi_Cmnd(buffer, len, (Scsi_Cmnd *) hostdata->connected);
+	}
+
+	PRINTP("issue_queue\n");
+
+	for (ptr = (Scsi_Cmnd *) hostdata->issue_queue; ptr; ptr = (Scsi_Cmnd *) ptr->host_scribble)
+		len += sprint_Scsi_Cmnd(buffer, len, ptr);
+
+	PRINTP("disconnected_queue\n");
+
+	for (ptr = (Scsi_Cmnd *) hostdata->disconnected_queue; ptr; ptr = (Scsi_Cmnd *) ptr->host_scribble)
+		len += sprint_Scsi_Cmnd(buffer, len, ptr);
+
+	*start = buffer + offset;
+	len -= offset;
+	if (len > length)
+		len = length;
+	spin_unlock_irqrestore(scsi_ptr->host_lock, flags);
+	return len;
+}
+
+#undef PRINTP
+#undef ANDP
+
+static Scsi_Host_Template driver_template = {
+	.proc_info      	= generic_NCR5380_proc_info,
+	.name           	= "Generic NCR5380/NCR53C400 Scsi Driver",
+	.detect         	= generic_NCR5380_detect,
+	.release        	= generic_NCR5380_release_resources,
+	.info           	= generic_NCR5380_info,
+	.queuecommand   	= generic_NCR5380_queue_command,
+	.eh_abort_handler	= generic_NCR5380_abort,
+	.eh_bus_reset_handler	= generic_NCR5380_bus_reset,
+	.eh_device_reset_handler = generic_NCR5380_device_reset,
+	.eh_host_reset_handler	= generic_NCR5380_host_reset,
+	.bios_param     	= NCR5380_BIOSPARAM,
+	.can_queue      	= CAN_QUEUE,
+        .this_id        	= 7,
+        .sg_tablesize   	= SG_ALL,
+	.cmd_per_lun    	= CMD_PER_LUN,
+        .use_clustering		= DISABLE_CLUSTERING,
+};
+#include <linux/module.h>
+#include "scsi_module.c"
+
+module_param(ncr_irq, int, 0);
+module_param(ncr_dma, int, 0);
+module_param(ncr_addr, int, 0);
+module_param(ncr_5380, int, 0);
+module_param(ncr_53c400, int, 0);
+module_param(ncr_53c400a, int, 0);
+module_param(dtc_3181e, int, 0);
+MODULE_LICENSE("GPL");
+
+
+static struct isapnp_device_id id_table[] __devinitdata = {
+	{
+	 ISAPNP_ANY_ID, ISAPNP_ANY_ID,
+	 ISAPNP_VENDOR('D', 'T', 'C'), ISAPNP_FUNCTION(0x436e),
+	 0},
+	{0}
+};
+
+MODULE_DEVICE_TABLE(isapnp, id_table);
+
+
+__setup("ncr5380=", do_NCR5380_setup);
+__setup("ncr53c400=", do_NCR53C400_setup);
+__setup("ncr53c400a=", do_NCR53C400A_setup);
+__setup("dtc3181e=", do_DTC3181E_setup);
