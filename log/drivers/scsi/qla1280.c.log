commit 5d296cc9ab6e5cafaef2f81e1376320a6b6de50b
Author: Jason Yan <yanaijie@huawei.com>
Date:   Thu Apr 9 16:49:10 2020 +0800

    scsi: qla1280: make qla1280_firmware_mutex and qla1280_fw_tbl static
    
    Fix the following sparse warning:
    
    drivers/scsi/qla1280.c:529:1: warning: symbol 'qla1280_firmware_mutex'
    was not declared. Should it be static?
    drivers/scsi/qla1280.c:538:15: warning: symbol 'qla1280_fw_tbl' was not
    declared. Should it be static?
    
    Link: https://lore.kernel.org/r/20200409084910.44336-1-yanaijie@huawei.com
    Reported-by: Hulk Robot <hulkci@huawei.com>
    Signed-off-by: Jason Yan <yanaijie@huawei.com>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/qla1280.c b/drivers/scsi/qla1280.c
index 3337cd341d21..441a45349349 100644
--- a/drivers/scsi/qla1280.c
+++ b/drivers/scsi/qla1280.c
@@ -526,7 +526,7 @@ static struct pci_device_id qla1280_pci_tbl[] = {
 };
 MODULE_DEVICE_TABLE(pci, qla1280_pci_tbl);
 
-DEFINE_MUTEX(qla1280_firmware_mutex);
+static DEFINE_MUTEX(qla1280_firmware_mutex);
 
 struct qla_fw {
 	char *fwname;
@@ -535,7 +535,7 @@ struct qla_fw {
 
 #define QL_NUM_FW_IMAGES 3
 
-struct qla_fw qla1280_fw_tbl[QL_NUM_FW_IMAGES] = {
+static struct qla_fw qla1280_fw_tbl[QL_NUM_FW_IMAGES] = {
 	{"qlogic/1040.bin",  NULL},	/* image 0 */
 	{"qlogic/1280.bin",  NULL},	/* image 1 */
 	{"qlogic/12160.bin", NULL},	/* image 2 */

commit 6ca67a8e7bed55389a0297647b6196910776971c
Author: Thomas Bogendoerfer <tbogendoerfer@suse.de>
Date:   Fri Jan 17 12:56:27 2020 +0100

    scsi: qla1280: Make checking for 64bit support consistent
    
    Use #ifdef QLA_64BIT_PTR to check if 64bit support is enabled.  This
    fixes ("scsi: qla1280: Fix dma firmware download, if dma address is
    64bit").
    
    Link: https://lore.kernel.org/r/20200117115628.13219-1-tbogendoerfer@suse.de
    Signed-off-by: Thomas Bogendoerfer <tbogendoerfer@suse.de>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/qla1280.c b/drivers/scsi/qla1280.c
index 607cbddcdd14..3337cd341d21 100644
--- a/drivers/scsi/qla1280.c
+++ b/drivers/scsi/qla1280.c
@@ -1699,7 +1699,7 @@ qla1280_load_firmware_pio(struct scsi_qla_host *ha)
 	return err;
 }
 
-#if QLA_64BIT_PTR
+#ifdef QLA_64BIT_PTR
 #define LOAD_CMD	MBC_LOAD_RAM_A64_ROM
 #define DUMP_CMD	MBC_DUMP_RAM_A64_ROM
 #define CMD_ARGS	(BIT_7 | BIT_6 | BIT_4 | BIT_3 | BIT_2 | BIT_1 | BIT_0)

commit ba304e5b4498157bd8c53ba14bb9a89a68996238
Author: Thomas Bogendoerfer <tbogendoerfer@suse.de>
Date:   Tue Jan 14 17:09:36 2020 +0100

    scsi: qla1280: Fix dma firmware download, if dma address is 64bit
    
    Do firmware download with 64bit LOAD_RAM command, if driver is using
    64bit addressing.
    
    Link: https://lore.kernel.org/r/20200114160936.1517-1-tbogendoerfer@suse.de
    Signed-off-by: Thomas Bogendoerfer <tbogendoerfer@suse.de>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/qla1280.c b/drivers/scsi/qla1280.c
index 832af4213046..607cbddcdd14 100644
--- a/drivers/scsi/qla1280.c
+++ b/drivers/scsi/qla1280.c
@@ -1699,6 +1699,16 @@ qla1280_load_firmware_pio(struct scsi_qla_host *ha)
 	return err;
 }
 
+#if QLA_64BIT_PTR
+#define LOAD_CMD	MBC_LOAD_RAM_A64_ROM
+#define DUMP_CMD	MBC_DUMP_RAM_A64_ROM
+#define CMD_ARGS	(BIT_7 | BIT_6 | BIT_4 | BIT_3 | BIT_2 | BIT_1 | BIT_0)
+#else
+#define LOAD_CMD	MBC_LOAD_RAM
+#define DUMP_CMD	MBC_DUMP_RAM
+#define CMD_ARGS	(BIT_4 | BIT_3 | BIT_2 | BIT_1 | BIT_0)
+#endif
+
 #define DUMP_IT_BACK 0		/* for debug of RISC loading */
 static int
 qla1280_load_firmware_dma(struct scsi_qla_host *ha)
@@ -1748,7 +1758,7 @@ qla1280_load_firmware_dma(struct scsi_qla_host *ha)
 		for(i = 0; i < cnt; i++)
 			((__le16 *)ha->request_ring)[i] = fw_data[i];
 
-		mb[0] = MBC_LOAD_RAM;
+		mb[0] = LOAD_CMD;
 		mb[1] = risc_address;
 		mb[4] = cnt;
 		mb[3] = ha->request_dma & 0xffff;
@@ -1759,8 +1769,7 @@ qla1280_load_firmware_dma(struct scsi_qla_host *ha)
 				__func__, mb[0],
 				(void *)(long)ha->request_dma,
 				mb[6], mb[7], mb[2], mb[3]);
-		err = qla1280_mailbox_command(ha, BIT_4 | BIT_3 | BIT_2 |
-				BIT_1 | BIT_0, mb);
+		err = qla1280_mailbox_command(ha, CMD_ARGS, mb);
 		if (err) {
 			printk(KERN_ERR "scsi(%li): Failed to load partial "
 			       "segment of f\n", ha->host_no);
@@ -1768,7 +1777,7 @@ qla1280_load_firmware_dma(struct scsi_qla_host *ha)
 		}
 
 #if DUMP_IT_BACK
-		mb[0] = MBC_DUMP_RAM;
+		mb[0] = DUMP_CMD;
 		mb[1] = risc_address;
 		mb[4] = cnt;
 		mb[3] = p_tbuf & 0xffff;
@@ -1776,8 +1785,7 @@ qla1280_load_firmware_dma(struct scsi_qla_host *ha)
 		mb[7] = upper_32_bits(p_tbuf) & 0xffff;
 		mb[6] = upper_32_bits(p_tbuf) >> 16;
 
-		err = qla1280_mailbox_command(ha, BIT_4 | BIT_3 | BIT_2 |
-				BIT_1 | BIT_0, mb);
+		err = qla1280_mailbox_command(ha, CMD_ARGS, mb);
 		if (err) {
 			printk(KERN_ERR
 			       "Failed to dump partial segment of f/w\n");

commit f877a786b1dd314ec081355507b8605508e4dfab
Author: Christoph Hellwig <hch@lst.de>
Date:   Tue Aug 13 09:24:57 2019 +0200

    qla1280: remove SGI SN2 support
    
    The SGI SN2 support is about to be removed, so drop the bits specific to
    it from this driver.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Link: https://lkml.kernel.org/r/20190813072514.23299-12-hch@lst.de
    Signed-off-by: Tony Luck <tony.luck@intel.com>

diff --git a/drivers/scsi/qla1280.c b/drivers/scsi/qla1280.c
index e5760c4a27f0..832af4213046 100644
--- a/drivers/scsi/qla1280.c
+++ b/drivers/scsi/qla1280.c
@@ -357,10 +357,6 @@
 #include <scsi/scsi_host.h>
 #include <scsi/scsi_tcq.h>
 
-#if defined(CONFIG_IA64_GENERIC) || defined(CONFIG_IA64_SGI_SN2)
-#include <asm/sn/io.h>
-#endif
-
 
 /*
  * Compile time Options:
@@ -380,11 +376,6 @@
 
 #define NVRAM_DELAY()			udelay(500)	/* 2 microseconds */
 
-#if defined(__ia64__) && !defined(ia64_platform_is)
-#define ia64_platform_is(foo)		(!strcmp(x, platform_name))
-#endif
-
-
 #define IS_ISP1040(ha) (ha->pdev->device == PCI_DEVICE_ID_QLOGIC_ISP1020)
 #define IS_ISP1x40(ha) (ha->pdev->device == PCI_DEVICE_ID_QLOGIC_ISP1020 || \
 			ha->pdev->device == PCI_DEVICE_ID_QLOGIC_ISP1240)
@@ -1427,15 +1418,6 @@ qla1280_initialize_adapter(struct scsi_qla_host *ha)
 	ha->flags.reset_active = 0;
 	ha->flags.abort_isp_active = 0;
 
-#if defined(CONFIG_IA64_GENERIC) || defined(CONFIG_IA64_SGI_SN2)
-	if (ia64_platform_is("sn2")) {
-		printk(KERN_INFO "scsi(%li): Enabling SN2 PCI DMA "
-		       "dual channel lockup workaround\n", ha->host_no);
-		ha->flags.use_pci_vchannel = 1;
-		driver_setup.no_nvram = 1;
-	}
-#endif
-
 	/* TODO: implement support for the 1040 nvram format */
 	if (IS_ISP1040(ha))
 		driver_setup.no_nvram = 1;
@@ -2251,13 +2233,6 @@ qla1280_nvram_config(struct scsi_qla_host *ha)
 	mb[1] = nv->firmware_feature.f.enable_fast_posting;
 	mb[1] |= nv->firmware_feature.f.report_lvd_bus_transition << 1;
 	mb[1] |= nv->firmware_feature.f.disable_synchronous_backoff << 5;
-#if defined(CONFIG_IA64_GENERIC) || defined (CONFIG_IA64_SGI_SN2)
-	if (ia64_platform_is("sn2")) {
-		printk(KERN_INFO "scsi(%li): Enabling SN2 PCI DMA "
-		       "workaround\n", ha->host_no);
-		mb[1] |= nv->firmware_feature.f.unused_9 << 9; /* XXX */
-	}
-#endif
 	status |= qla1280_mailbox_command(ha, BIT_1 | BIT_0, mb);
 
 	/* Retry count and delay. */
@@ -2888,12 +2863,6 @@ qla1280_64bit_start_scsi(struct scsi_qla_host *ha, struct srb * sp)
 				break;
 
 			dma_handle = sg_dma_address(s);
-#if defined(CONFIG_IA64_GENERIC) || defined(CONFIG_IA64_SGI_SN2)
-			if (ha->flags.use_pci_vchannel)
-				sn_pci_set_vchan(ha->pdev,
-						 (unsigned long *)&dma_handle,
-						 SCSI_BUS_32(cmd));
-#endif
 			*dword_ptr++ =
 				cpu_to_le32(lower_32_bits(dma_handle));
 			*dword_ptr++ =
@@ -2950,12 +2919,6 @@ qla1280_64bit_start_scsi(struct scsi_qla_host *ha, struct srb * sp)
 				if (cnt == 5)
 					break;
 				dma_handle = sg_dma_address(s);
-#if defined(CONFIG_IA64_GENERIC) || defined(CONFIG_IA64_SGI_SN2)
-				if (ha->flags.use_pci_vchannel)
-					sn_pci_set_vchan(ha->pdev,
-							 (unsigned long *)&dma_handle,
-							 SCSI_BUS_32(cmd));
-#endif
 				*dword_ptr++ =
 					cpu_to_le32(lower_32_bits(dma_handle));
 				*dword_ptr++ =

commit 3e0a4e85803345e31ae2d0009bedf252e43278cb
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Thu May 23 11:14:55 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 118
    
    Based on 1 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license as published by
      the free software foundation either version 2 or at your option any
      later version this program is distributed in the hope that it will
      be useful but without any warranty without even the implied warranty
      of merchantability or fitness for a particular purpose see the gnu
      general public license for more details
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-or-later
    
    has been chosen to replace the boilerplate/reference in 44 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Richard Fontana <rfontana@redhat.com>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190523091651.032047323@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/scsi/qla1280.c b/drivers/scsi/qla1280.c
index 327eff67a1ee..e5760c4a27f0 100644
--- a/drivers/scsi/qla1280.c
+++ b/drivers/scsi/qla1280.c
@@ -1,3 +1,4 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
 /******************************************************************************
 *                  QLOGIC LINUX SOFTWARE
 *
@@ -6,16 +7,6 @@
 * Copyright (C) 2001-2004 Jes Sorensen, Wild Open Source Inc.
 * Copyright (C) 2003-2004 Christoph Hellwig
 *
-* This program is free software; you can redistribute it and/or modify it
-* under the terms of the GNU General Public License as published by the
-* Free Software Foundation; either version 2, or (at your option) any
-* later version.
-*
-* This program is distributed in the hope that it will be useful, but
-* WITHOUT ANY WARRANTY; without even the implied warranty of
-* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
-* General Public License for more details.
-*
 ******************************************************************************/
 #define QLA1280_VERSION      "3.27.1"
 /*****************************************************************************

commit 161861a4c8279f136e5419deb95c58176af83e48
Author: Will Deacon <will.deacon@arm.com>
Date:   Fri Feb 22 17:18:02 2019 +0000

    scsi/qla1280: Remove stale comment about mmiowb()
    
    All mmiowb() invocations have been removed, so there's no need to keep
    banging on about it.
    
    Acked-by: Linus Torvalds <torvalds@linux-foundation.org>
    Signed-off-by: Will Deacon <will.deacon@arm.com>

diff --git a/drivers/scsi/qla1280.c b/drivers/scsi/qla1280.c
index 93acbc5094f0..327eff67a1ee 100644
--- a/drivers/scsi/qla1280.c
+++ b/drivers/scsi/qla1280.c
@@ -3363,16 +3363,6 @@ qla1280_isp_cmd(struct scsi_qla_host *ha)
 
 	/*
 	 * Update request index to mailbox4 (Request Queue In).
-	 * The mmiowb() ensures that this write is ordered with writes by other
-	 * CPUs.  Without the mmiowb(), it is possible for the following:
-	 *    CPUA posts write of index 5 to mailbox4
-	 *    CPUA releases host lock
-	 *    CPUB acquires host lock
-	 *    CPUB posts write of index 6 to mailbox4
-	 *    On PCI bus, order reverses and write of 6 posts, then index 5,
-	 *       causing chip to issue full queue of stale commands
-	 * The mmiowb() prevents future writes from crossing the barrier.
-	 * See Documentation/driver-api/device-io.rst for more information.
 	 */
 	WRT_REG_WORD(&reg->mailbox4, ha->req_ring_index);
 

commit fb24ea52f78e0d595852e09e3a55697c8f442189
Author: Will Deacon <will.deacon@arm.com>
Date:   Fri Feb 22 17:14:59 2019 +0000

    drivers: Remove explicit invocations of mmiowb()
    
    mmiowb() is now implied by spin_unlock() on architectures that require
    it, so there is no reason to call it from driver code. This patch was
    generated using coccinelle:
    
            @mmiowb@
            @@
            - mmiowb();
    
    and invoked as:
    
    $ for d in drivers include/linux/qed sound; do \
    spatch --include-headers --sp-file mmiowb.cocci --dir $d --in-place; done
    
    NOTE: mmiowb() has only ever guaranteed ordering in conjunction with
    spin_unlock(). However, pairing each mmiowb() removal in this patch with
    the corresponding call to spin_unlock() is not at all trivial, so there
    is a small chance that this change may regress any drivers incorrectly
    relying on mmiowb() to order MMIO writes between CPUs using lock-free
    synchronisation. If you've ended up bisecting to this commit, you can
    reintroduce the mmiowb() calls using wmb() instead, which should restore
    the old behaviour on all architectures other than some esoteric ia64
    systems.
    
    Acked-by: Linus Torvalds <torvalds@linux-foundation.org>
    Signed-off-by: Will Deacon <will.deacon@arm.com>

diff --git a/drivers/scsi/qla1280.c b/drivers/scsi/qla1280.c
index 6856dfdfa473..93acbc5094f0 100644
--- a/drivers/scsi/qla1280.c
+++ b/drivers/scsi/qla1280.c
@@ -3004,8 +3004,6 @@ qla1280_64bit_start_scsi(struct scsi_qla_host *ha, struct srb * sp)
 	sp->flags |= SRB_SENT;
 	ha->actthreads++;
 	WRT_REG_WORD(&reg->mailbox4, ha->req_ring_index);
-	/* Enforce mmio write ordering; see comment in qla1280_isp_cmd(). */
-	mmiowb();
 
  out:
 	if (status)
@@ -3254,8 +3252,6 @@ qla1280_32bit_start_scsi(struct scsi_qla_host *ha, struct srb * sp)
 	sp->flags |= SRB_SENT;
 	ha->actthreads++;
 	WRT_REG_WORD(&reg->mailbox4, ha->req_ring_index);
-	/* Enforce mmio write ordering; see comment in qla1280_isp_cmd(). */
-	mmiowb();
 
 out:
 	if (status)
@@ -3379,7 +3375,6 @@ qla1280_isp_cmd(struct scsi_qla_host *ha)
 	 * See Documentation/driver-api/device-io.rst for more information.
 	 */
 	WRT_REG_WORD(&reg->mailbox4, ha->req_ring_index);
-	mmiowb();
 
 	LEAVE("qla1280_isp_cmd");
 }

commit 4a01ab60f55041b1ccc760e43258a5b3aeeca1bc
Author: Thomas Bogendoerfer <tbogendoerfer@suse.de>
Date:   Wed Jan 9 15:09:02 2019 +0100

    scsi: qla1280: set 64bit coherent mask
    
    After Commit 54aed4dd3526 ("MIPS: IP27: use dma_direct_ops") qla1280 driver
    failed on SGI IP27 machines with
    
    qla1280: QLA1040 found on PCI bus 0, dev 0
    qla1280 0000:00:00.0: enabling device (0006 -> 0007)
    qla1280: Failed to get request memory
    qla1280: probe of 0000:00:00.0 failed with error -12
    
    Reason is that SGI IP27 always generates 64bit DMA addresses and has no
    fallback mode for 32bit DMA addresses implemented. QLA1280 supports 64bit
    addressing for all DMA accesses so setting coherent mask to 64bit fixes the
    issue.
    
    Signed-off-by: Thomas Bogendoerfer <tbogendoerfer@suse.de>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/qla1280.c b/drivers/scsi/qla1280.c
index a414f51302b7..6856dfdfa473 100644
--- a/drivers/scsi/qla1280.c
+++ b/drivers/scsi/qla1280.c
@@ -4248,7 +4248,7 @@ qla1280_probe_one(struct pci_dev *pdev, const struct pci_device_id *id)
 	ha->devnum = devnum;	/* specifies microcode load address */
 
 #ifdef QLA_64BIT_PTR
-	if (dma_set_mask(&ha->pdev->dev, DMA_BIT_MASK(64))) {
+	if (dma_set_mask_and_coherent(&ha->pdev->dev, DMA_BIT_MASK(64))) {
 		if (dma_set_mask(&ha->pdev->dev, DMA_BIT_MASK(32))) {
 			printk(KERN_WARNING "scsi(%li): Unable to set a "
 			       "suitable DMA mask - aborting\n", ha->host_no);

commit 2a3d4eb8e228061c09d5ca8bf39e7f00c2091213
Author: Christoph Hellwig <hch@lst.de>
Date:   Thu Dec 13 16:17:02 2018 +0100

    scsi: flip the default on use_clustering
    
    Most SCSI drivers want to enable "clustering", that is merging of
    segments so that they might span more than a single page.  Remove the
    ENABLE_CLUSTERING define, and require drivers to explicitly set
    DISABLE_CLUSTERING to disable this feature.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/qla1280.c b/drivers/scsi/qla1280.c
index 9c5b67304a76..a414f51302b7 100644
--- a/drivers/scsi/qla1280.c
+++ b/drivers/scsi/qla1280.c
@@ -4203,7 +4203,6 @@ static struct scsi_host_template qla1280_driver_template = {
 	.can_queue		= MAX_OUTSTANDING_COMMANDS,
 	.this_id		= -1,
 	.sg_tablesize		= SG_ALL,
-	.use_clustering		= ENABLE_CLUSTERING,
 };
 
 

commit ac4b1657b75251f9c8731403e5b79fa812e0b05c
Author: Christoph Hellwig <hch@lst.de>
Date:   Thu Oct 18 15:03:36 2018 +0200

    scsi: qla1280: properly handle 64-bit DMA
    
    CONFIG_HIGHMEM is not in fact an indicator for > 32-bit dma addressing
    Given that the driver is a bit weird and wants a compile time selection
    switch to checking CONFIG_ARCH_DMA_ADDR_T_64BIT instead.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/qla1280.c b/drivers/scsi/qla1280.c
index f19e8d192d36..9c5b67304a76 100644
--- a/drivers/scsi/qla1280.c
+++ b/drivers/scsi/qla1280.c
@@ -383,10 +383,7 @@
 
 #include "qla1280.h"
 
-#ifndef BITS_PER_LONG
-#error "BITS_PER_LONG not defined!"
-#endif
-#if (BITS_PER_LONG == 64) || defined CONFIG_HIGHMEM
+#ifdef CONFIG_ARCH_DMA_ADDR_T_64BIT
 #define QLA_64BIT_PTR	1
 #endif
 

commit f20f43c35aa4ebce8fed57168cb358611259c634
Author: Christoph Hellwig <hch@lst.de>
Date:   Thu Oct 18 15:03:35 2018 +0200

    scsi: qla1280: use lower_32_bits and upper_32_bits instead of reinventing them
    
    This also moves the optimization for builds with 32-bit dma_addr_t to
    the compiler (where it belongs) instead of opencoding it.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/qla1280.c b/drivers/scsi/qla1280.c
index 15a50cc7e4b3..f19e8d192d36 100644
--- a/drivers/scsi/qla1280.c
+++ b/drivers/scsi/qla1280.c
@@ -390,13 +390,6 @@
 #define QLA_64BIT_PTR	1
 #endif
 
-#ifdef QLA_64BIT_PTR
-#define pci_dma_hi32(a)			((a >> 16) >> 16)
-#else
-#define pci_dma_hi32(a)			0
-#endif
-#define pci_dma_lo32(a)			(a & 0xffffffff)
-
 #define NVRAM_DELAY()			udelay(500)	/* 2 microseconds */
 
 #if defined(__ia64__) && !defined(ia64_platform_is)
@@ -1790,8 +1783,8 @@ qla1280_load_firmware_dma(struct scsi_qla_host *ha)
 		mb[4] = cnt;
 		mb[3] = ha->request_dma & 0xffff;
 		mb[2] = (ha->request_dma >> 16) & 0xffff;
-		mb[7] = pci_dma_hi32(ha->request_dma) & 0xffff;
-		mb[6] = pci_dma_hi32(ha->request_dma) >> 16;
+		mb[7] = upper_32_bits(ha->request_dma) & 0xffff;
+		mb[6] = upper_32_bits(ha->request_dma) >> 16;
 		dprintk(2, "%s: op=%d  0x%p = 0x%4x,0x%4x,0x%4x,0x%4x\n",
 				__func__, mb[0],
 				(void *)(long)ha->request_dma,
@@ -1810,8 +1803,8 @@ qla1280_load_firmware_dma(struct scsi_qla_host *ha)
 		mb[4] = cnt;
 		mb[3] = p_tbuf & 0xffff;
 		mb[2] = (p_tbuf >> 16) & 0xffff;
-		mb[7] = pci_dma_hi32(p_tbuf) & 0xffff;
-		mb[6] = pci_dma_hi32(p_tbuf) >> 16;
+		mb[7] = upper_32_bits(p_tbuf) & 0xffff;
+		mb[6] = upper_32_bits(p_tbuf) >> 16;
 
 		err = qla1280_mailbox_command(ha, BIT_4 | BIT_3 | BIT_2 |
 				BIT_1 | BIT_0, mb);
@@ -1933,8 +1926,8 @@ qla1280_init_rings(struct scsi_qla_host *ha)
 	mb[3] = ha->request_dma & 0xffff;
 	mb[2] = (ha->request_dma >> 16) & 0xffff;
 	mb[4] = 0;
-	mb[7] = pci_dma_hi32(ha->request_dma) & 0xffff;
-	mb[6] = pci_dma_hi32(ha->request_dma) >> 16;
+	mb[7] = upper_32_bits(ha->request_dma) & 0xffff;
+	mb[6] = upper_32_bits(ha->request_dma) >> 16;
 	if (!(status = qla1280_mailbox_command(ha, BIT_7 | BIT_6 | BIT_4 |
 					       BIT_3 | BIT_2 | BIT_1 | BIT_0,
 					       &mb[0]))) {
@@ -1947,8 +1940,8 @@ qla1280_init_rings(struct scsi_qla_host *ha)
 		mb[3] = ha->response_dma & 0xffff;
 		mb[2] = (ha->response_dma >> 16) & 0xffff;
 		mb[5] = 0;
-		mb[7] = pci_dma_hi32(ha->response_dma) & 0xffff;
-		mb[6] = pci_dma_hi32(ha->response_dma) >> 16;
+		mb[7] = upper_32_bits(ha->response_dma) & 0xffff;
+		mb[6] = upper_32_bits(ha->response_dma) >> 16;
 		status = qla1280_mailbox_command(ha, BIT_7 | BIT_6 | BIT_5 |
 						 BIT_3 | BIT_2 | BIT_1 | BIT_0,
 						 &mb[0]);
@@ -2914,13 +2907,13 @@ qla1280_64bit_start_scsi(struct scsi_qla_host *ha, struct srb * sp)
 						 SCSI_BUS_32(cmd));
 #endif
 			*dword_ptr++ =
-				cpu_to_le32(pci_dma_lo32(dma_handle));
+				cpu_to_le32(lower_32_bits(dma_handle));
 			*dword_ptr++ =
-				cpu_to_le32(pci_dma_hi32(dma_handle));
+				cpu_to_le32(upper_32_bits(dma_handle));
 			*dword_ptr++ = cpu_to_le32(sg_dma_len(s));
 			dprintk(3, "S/G Segment phys_addr=%x %x, len=0x%x\n",
-				cpu_to_le32(pci_dma_hi32(dma_handle)),
-				cpu_to_le32(pci_dma_lo32(dma_handle)),
+				cpu_to_le32(upper_32_bits(dma_handle)),
+				cpu_to_le32(lower_32_bits(dma_handle)),
 				cpu_to_le32(sg_dma_len(sg_next(s))));
 			remseg--;
 		}
@@ -2976,14 +2969,14 @@ qla1280_64bit_start_scsi(struct scsi_qla_host *ha, struct srb * sp)
 							 SCSI_BUS_32(cmd));
 #endif
 				*dword_ptr++ =
-					cpu_to_le32(pci_dma_lo32(dma_handle));
+					cpu_to_le32(lower_32_bits(dma_handle));
 				*dword_ptr++ =
-					cpu_to_le32(pci_dma_hi32(dma_handle));
+					cpu_to_le32(upper_32_bits(dma_handle));
 				*dword_ptr++ =
 					cpu_to_le32(sg_dma_len(s));
 				dprintk(3, "S/G Segment Cont. phys_addr=%x %x, len=0x%x\n",
-					cpu_to_le32(pci_dma_hi32(dma_handle)),
-					cpu_to_le32(pci_dma_lo32(dma_handle)),
+					cpu_to_le32(upper_32_bits(dma_handle)),
+					cpu_to_le32(lower_32_bits(dma_handle)),
 					cpu_to_le32(sg_dma_len(s)));
 			}
 			remseg -= cnt;
@@ -3178,10 +3171,10 @@ qla1280_32bit_start_scsi(struct scsi_qla_host *ha, struct srb * sp)
 			if (cnt == 4)
 				break;
 			*dword_ptr++ =
-				cpu_to_le32(pci_dma_lo32(sg_dma_address(s)));
+				cpu_to_le32(lower_32_bits(sg_dma_address(s)));
 			*dword_ptr++ = cpu_to_le32(sg_dma_len(s));
 			dprintk(3, "S/G Segment phys_addr=0x%lx, len=0x%x\n",
-				(pci_dma_lo32(sg_dma_address(s))),
+				(lower_32_bits(sg_dma_address(s))),
 				(sg_dma_len(s)));
 			remseg--;
 		}
@@ -3224,13 +3217,13 @@ qla1280_32bit_start_scsi(struct scsi_qla_host *ha, struct srb * sp)
 				if (cnt == 7)
 					break;
 				*dword_ptr++ =
-					cpu_to_le32(pci_dma_lo32(sg_dma_address(s)));
+					cpu_to_le32(lower_32_bits(sg_dma_address(s)));
 				*dword_ptr++ =
 					cpu_to_le32(sg_dma_len(s));
 				dprintk(1,
 					"S/G Segment Cont. phys_addr=0x%x, "
 					"len=0x%x\n",
-					cpu_to_le32(pci_dma_lo32(sg_dma_address(s))),
+					cpu_to_le32(lower_32_bits(sg_dma_address(s))),
 					cpu_to_le32(sg_dma_len(s)));
 			}
 			remseg -= cnt;

commit 60ea4fb138a66f8e08bc165225b89dfb942d0790
Author: Christoph Hellwig <hch@lst.de>
Date:   Wed Oct 10 20:09:04 2018 +0200

    scsi: qla1280: switch to generic DMA API
    
    Switch from the legacy PCI DMA API to the generic DMA API.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Reviewed-by: Johannes Thumshirn <jthumshirn@suse.de>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/qla1280.c b/drivers/scsi/qla1280.c
index 390775d5c918..15a50cc7e4b3 100644
--- a/drivers/scsi/qla1280.c
+++ b/drivers/scsi/qla1280.c
@@ -1750,7 +1750,7 @@ qla1280_load_firmware_dma(struct scsi_qla_host *ha)
 	uint8_t *sp, *tbuf;
 	dma_addr_t p_tbuf;
 
-	tbuf = pci_alloc_consistent(ha->pdev, 8000, &p_tbuf);
+	tbuf = dma_alloc_coherent(&ha->pdev->dev, 8000, &p_tbuf, GFP_KERNEL);
 	if (!tbuf)
 		return -ENOMEM;
 #endif
@@ -1841,7 +1841,7 @@ qla1280_load_firmware_dma(struct scsi_qla_host *ha)
 
  out:
 #if DUMP_IT_BACK
-	pci_free_consistent(ha->pdev, 8000, tbuf, p_tbuf);
+	dma_free_coherent(&ha->pdev->dev, 8000, tbuf, p_tbuf);
 #endif
 	return err;
 }
@@ -4259,8 +4259,8 @@ qla1280_probe_one(struct pci_dev *pdev, const struct pci_device_id *id)
 	ha->devnum = devnum;	/* specifies microcode load address */
 
 #ifdef QLA_64BIT_PTR
-	if (pci_set_dma_mask(ha->pdev, DMA_BIT_MASK(64))) {
-		if (pci_set_dma_mask(ha->pdev, DMA_BIT_MASK(32))) {
+	if (dma_set_mask(&ha->pdev->dev, DMA_BIT_MASK(64))) {
+		if (dma_set_mask(&ha->pdev->dev, DMA_BIT_MASK(32))) {
 			printk(KERN_WARNING "scsi(%li): Unable to set a "
 			       "suitable DMA mask - aborting\n", ha->host_no);
 			error = -ENODEV;
@@ -4270,7 +4270,7 @@ qla1280_probe_one(struct pci_dev *pdev, const struct pci_device_id *id)
 		dprintk(2, "scsi(%li): 64 Bit PCI Addressing Enabled\n",
 			ha->host_no);
 #else
-	if (pci_set_dma_mask(ha->pdev, DMA_BIT_MASK(32))) {
+	if (dma_set_mask(&ha->pdev->dev, DMA_BIT_MASK(32))) {
 		printk(KERN_WARNING "scsi(%li): Unable to set a "
 		       "suitable DMA mask - aborting\n", ha->host_no);
 		error = -ENODEV;
@@ -4278,17 +4278,17 @@ qla1280_probe_one(struct pci_dev *pdev, const struct pci_device_id *id)
 	}
 #endif
 
-	ha->request_ring = pci_alloc_consistent(ha->pdev,
+	ha->request_ring = dma_alloc_coherent(&ha->pdev->dev,
 			((REQUEST_ENTRY_CNT + 1) * sizeof(request_t)),
-			&ha->request_dma);
+			&ha->request_dma, GFP_KERNEL);
 	if (!ha->request_ring) {
 		printk(KERN_INFO "qla1280: Failed to get request memory\n");
 		goto error_put_host;
 	}
 
-	ha->response_ring = pci_alloc_consistent(ha->pdev,
+	ha->response_ring = dma_alloc_coherent(&ha->pdev->dev,
 			((RESPONSE_ENTRY_CNT + 1) * sizeof(struct response)),
-			&ha->response_dma);
+			&ha->response_dma, GFP_KERNEL);
 	if (!ha->response_ring) {
 		printk(KERN_INFO "qla1280: Failed to get response memory\n");
 		goto error_free_request_ring;
@@ -4370,11 +4370,11 @@ qla1280_probe_one(struct pci_dev *pdev, const struct pci_device_id *id)
 	release_region(host->io_port, 0xff);
 #endif
  error_free_response_ring:
-	pci_free_consistent(ha->pdev,
+	dma_free_coherent(&ha->pdev->dev,
 			((RESPONSE_ENTRY_CNT + 1) * sizeof(struct response)),
 			ha->response_ring, ha->response_dma);
  error_free_request_ring:
-	pci_free_consistent(ha->pdev,
+	dma_free_coherent(&ha->pdev->dev,
 			((REQUEST_ENTRY_CNT + 1) * sizeof(request_t)),
 			ha->request_ring, ha->request_dma);
  error_put_host:
@@ -4404,10 +4404,10 @@ qla1280_remove_one(struct pci_dev *pdev)
 	release_region(host->io_port, 0xff);
 #endif
 
-	pci_free_consistent(ha->pdev,
+	dma_free_coherent(&ha->pdev->dev,
 			((REQUEST_ENTRY_CNT + 1) * (sizeof(request_t))),
 			ha->request_ring, ha->request_dma);
-	pci_free_consistent(ha->pdev,
+	dma_free_coherent(&ha->pdev->dev,
 			((RESPONSE_ENTRY_CNT + 1) * (sizeof(struct response))),
 			ha->response_ring, ha->response_dma);
 

commit 9c6c273aa4248c60569de6ef7e7e9c7bed3cd32e
Author: Kees Cook <keescook@chromium.org>
Date:   Wed Oct 4 16:26:57 2017 -0700

    timer: Remove init_timer_on_stack() in favor of timer_setup_on_stack()
    
    Remove uses of init_timer_on_stack() with open-coded function and data
    assignments that could be expressed using timer_setup_on_stack(). Several
    were removed from the stack entirely since there was a one-to-one mapping
    of parent structure to timer, those are switched to using timer_setup()
    instead. All related callbacks were adjusted to use from_timer().
    
    Signed-off-by: Kees Cook <keescook@chromium.org>
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: linux-mips@linux-mips.org
    Cc: Petr Mladek <pmladek@suse.com>
    Cc: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Cc: Heiko Carstens <heiko.carstens@de.ibm.com>
    Cc: Sebastian Reichel <sre@kernel.org>
    Cc: Kalle Valo <kvalo@qca.qualcomm.com>
    Cc: Paul Mackerras <paulus@samba.org>
    Cc: Pavel Machek <pavel@ucw.cz>
    Cc: Wim Van Sebroeck <wim@iguana.be>
    Cc: linux1394-devel@lists.sourceforge.net
    Cc: Chris Metcalf <cmetcalf@mellanox.com>
    Cc: linux-s390@vger.kernel.org
    Cc: linux-wireless@vger.kernel.org
    Cc: "James E.J. Bottomley" <jejb@linux.vnet.ibm.com>
    Cc: linux-scsi@vger.kernel.org
    Cc: Michael Ellerman <mpe@ellerman.id.au>
    Cc: Ursula Braun <ubraun@linux.vnet.ibm.com>
    Cc: Geert Uytterhoeven <geert@linux-m68k.org>
    Cc: Viresh Kumar <viresh.kumar@linaro.org>
    Cc: Harish Patil <harish.patil@cavium.com>
    Cc: Stephen Boyd <sboyd@codeaurora.org>
    Cc: Michael Reed <mdr@sgi.com>
    Cc: Manish Chopra <manish.chopra@cavium.com>
    Cc: Len Brown <len.brown@intel.com>
    Cc: Arnd Bergmann <arnd@arndb.de>
    Cc: linux-pm@vger.kernel.org
    Cc: Lai Jiangshan <jiangshanlai@gmail.com>
    Cc: Tejun Heo <tj@kernel.org>
    Cc: Julian Wiedmann <jwi@linux.vnet.ibm.com>
    Cc: John Stultz <john.stultz@linaro.org>
    Cc: Mark Gross <mark.gross@intel.com>
    Cc: linux-watchdog@vger.kernel.org
    Cc: "Martin K. Petersen" <martin.petersen@oracle.com>
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Cc: "Rafael J. Wysocki" <rjw@rjwysocki.net>
    Cc: Oleg Nesterov <oleg@redhat.com>
    Cc: Ralf Baechle <ralf@linux-mips.org>
    Cc: Stefan Richter <stefanr@s5r6.in-berlin.de>
    Cc: Guenter Roeck <linux@roeck-us.net>
    Cc: netdev@vger.kernel.org
    Cc: Martin Schwidefsky <schwidefsky@de.ibm.com>
    Cc: Andrew Morton <akpm@linux-foundation.org>
    Cc: linuxppc-dev@lists.ozlabs.org
    Cc: Sudip Mukherjee <sudipm.mukherjee@gmail.com>
    Link: https://lkml.kernel.org/r/1507159627-127660-4-git-send-email-keescook@chromium.org

diff --git a/drivers/scsi/qla1280.c b/drivers/scsi/qla1280.c
index 8a29fb09db14..390775d5c918 100644
--- a/drivers/scsi/qla1280.c
+++ b/drivers/scsi/qla1280.c
@@ -758,9 +758,9 @@ enum action {
 };
 
 
-static void qla1280_mailbox_timeout(unsigned long __data)
+static void qla1280_mailbox_timeout(struct timer_list *t)
 {
-	struct scsi_qla_host *ha = (struct scsi_qla_host *)__data;
+	struct scsi_qla_host *ha = from_timer(ha, t, mailbox_timer);
 	struct device_reg __iomem *reg;
 	reg = ha->iobase;
 
@@ -2465,7 +2465,6 @@ qla1280_mailbox_command(struct scsi_qla_host *ha, uint8_t mr, uint16_t *mb)
 	uint16_t __iomem *mptr;
 	uint16_t data;
 	DECLARE_COMPLETION_ONSTACK(wait);
-	struct timer_list timer;
 
 	ENTER("qla1280_mailbox_command");
 
@@ -2494,18 +2493,15 @@ qla1280_mailbox_command(struct scsi_qla_host *ha, uint8_t mr, uint16_t *mb)
 	/* Issue set host interrupt command. */
 
 	/* set up a timer just in case we're really jammed */
-	init_timer_on_stack(&timer);
-	timer.expires = jiffies + 20*HZ;
-	timer.data = (unsigned long)ha;
-	timer.function = qla1280_mailbox_timeout;
-	add_timer(&timer);
+	timer_setup(&ha->mailbox_timer, qla1280_mailbox_timeout, 0);
+	mod_timer(&ha->mailbox_timer, jiffies + 20 * HZ);
 
 	spin_unlock_irq(ha->host->host_lock);
 	WRT_REG_WORD(&reg->host_cmd, HC_SET_HOST_INT);
 	data = qla1280_debounce_register(&reg->istatus);
 
 	wait_for_completion(&wait);
-	del_timer_sync(&timer);
+	del_timer_sync(&ha->mailbox_timer);
 
 	spin_lock_irq(ha->host->host_lock);
 

commit 2a76213072c8d6ac4364455e236d52b7d36601ca
Author: Mauro Carvalho Chehab <mchehab@s-opensource.com>
Date:   Sun May 14 11:54:11 2017 -0300

    ia64, scsi: update references for the device-io book
    
    The book is now at Documentation/driver-api/device-io.rst.
    Update such references.
    
    Signed-off-by: Mauro Carvalho Chehab <mchehab@s-opensource.com>

diff --git a/drivers/scsi/qla1280.c b/drivers/scsi/qla1280.c
index 634254a52301..8a29fb09db14 100644
--- a/drivers/scsi/qla1280.c
+++ b/drivers/scsi/qla1280.c
@@ -3390,7 +3390,7 @@ qla1280_isp_cmd(struct scsi_qla_host *ha)
 	 *    On PCI bus, order reverses and write of 6 posts, then index 5,
 	 *       causing chip to issue full queue of stale commands
 	 * The mmiowb() prevents future writes from crossing the barrier.
-	 * See Documentation/DocBook/deviceiobook.tmpl for more information.
+	 * See Documentation/driver-api/device-io.rst for more information.
 	 */
 	WRT_REG_WORD(&reg->mailbox4, ha->req_ring_index);
 	mmiowb();

commit 2bcbc81421c511ef117cadcf0bee9c4340e68db0
Author: Johannes Thumshirn <jthumshirn@suse.de>
Date:   Wed Apr 27 10:48:52 2016 +0200

    qla1280: Don't allocate 512kb of host tags
    
    The qla1280 driver sets the scsi_host_template's can_queue field to 0xfffff
    which results in an allocation failure when allocating the block layer tags
    for the driver's queues. This was introduced with the change for host wide
    tags in commit 64d513ac31b - "scsi: use host wide tags by default".
    
    Reduce can_queue to MAX_OUTSTANDING_COMMANDS (512) to solve the allocation
    error.
    
    Signed-off-by: Johannes Thumshirn <jthumshirn@suse.de>
    Fixes: 64d513ac31b - "scsi: use host wide tags by default"
    Cc: stable@vger.kernel.org # v4.4
    Cc: Laura Abbott <labbott@redhat.com>
    Cc: Michael Reed <mdr@sgi.com>
    Reviewed-by: Laurence Oberman <loberman@redhat.com>
    Reviewed-by: Lee Duncan <lduncan@suse.com>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>
    Signed-off-by: James Bottomley <jejb@linux.vnet.ibm.com>

diff --git a/drivers/scsi/qla1280.c b/drivers/scsi/qla1280.c
index 5d0ec42a9317..634254a52301 100644
--- a/drivers/scsi/qla1280.c
+++ b/drivers/scsi/qla1280.c
@@ -4214,7 +4214,7 @@ static struct scsi_host_template qla1280_driver_template = {
 	.eh_bus_reset_handler	= qla1280_eh_bus_reset,
 	.eh_host_reset_handler	= qla1280_eh_adapter_reset,
 	.bios_param		= qla1280_biosparam,
-	.can_queue		= 0xfffff,
+	.can_queue		= MAX_OUTSTANDING_COMMANDS,
 	.this_id		= -1,
 	.sg_tablesize		= SG_ALL,
 	.use_clustering		= ENABLE_CLUSTERING,

commit b84b1d522f979fb53ad347605e24b2940fa2ad99
Author: Hannes Reinecke <hare@suse.de>
Date:   Wed Apr 29 08:57:34 2015 +0200

    scsi: Do not set cmd_per_lun to 1 in the host template
    
    '0' is now used as the default cmd_per_lun value,
    so there's no need to explicitly set it to '1' in the
    host template.
    
    Signed-off-by: Hannes Reinecke <hare@suse.de>
    Reviewed-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: James Bottomley <JBottomley@Odin.com>

diff --git a/drivers/scsi/qla1280.c b/drivers/scsi/qla1280.c
index c68a66e8cfc1..5d0ec42a9317 100644
--- a/drivers/scsi/qla1280.c
+++ b/drivers/scsi/qla1280.c
@@ -4217,7 +4217,6 @@ static struct scsi_host_template qla1280_driver_template = {
 	.can_queue		= 0xfffff,
 	.this_id		= -1,
 	.sg_tablesize		= SG_ALL,
-	.cmd_per_lun		= 1,
 	.use_clustering		= ENABLE_CLUSTERING,
 };
 

commit db5ed4dfd5dd0142ec36ff7b335e0ec3b836b3e6
Author: Christoph Hellwig <hch@lst.de>
Date:   Thu Nov 13 15:08:42 2014 +0100

    scsi: drop reason argument from ->change_queue_depth
    
    Drop the now unused reason argument from the ->change_queue_depth method.
    Also add a return value to scsi_adjust_queue_depth, and rename it to
    scsi_change_queue_depth now that it can be used as the default
    ->change_queue_depth implementation.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Reviewed-by: Mike Christie <michaelc@cs.wisc.edu>
    Reviewed-by: Hannes Reinecke <hare@suse.de>

diff --git a/drivers/scsi/qla1280.c b/drivers/scsi/qla1280.c
index adedb6ef8eec..c68a66e8cfc1 100644
--- a/drivers/scsi/qla1280.c
+++ b/drivers/scsi/qla1280.c
@@ -1224,9 +1224,9 @@ qla1280_slave_configure(struct scsi_device *device)
 
 	if (device->tagged_supported &&
 	    (ha->bus_settings[bus].qtag_enables & (BIT_0 << target))) {
-		scsi_adjust_queue_depth(device, ha->bus_settings[bus].hiwat);
+		scsi_change_queue_depth(device, ha->bus_settings[bus].hiwat);
 	} else {
-		scsi_adjust_queue_depth(device, default_depth);
+		scsi_change_queue_depth(device, default_depth);
 	}
 
 	nv->bus[bus].target[target].parameter.enable_sync = device->sdtr;

commit c8b09f6fb67df7fc1b51ced1037fa9b677428149
Author: Christoph Hellwig <hch@lst.de>
Date:   Mon Nov 3 20:15:14 2014 +0100

    scsi: don't set tagging state from scsi_adjust_queue_depth
    
    Remove the tagged argument from scsi_adjust_queue_depth, and just let it
    handle the queue depth.  For most drivers those two are fairly separate,
    given that most modern drivers don't care about the SCSI "tagged" status
    of a command at all, and many old drivers allow queuing of multiple
    untagged commands in the driver.
    
    Instead we start out with the ->simple_tags flag set before calling
    ->slave_configure, which is how all drivers actually looking at
    ->simple_tags except for one worke anyway.  The one other case looks
    broken, but I've kept the behavior as-is for now.
    
    Except for that we only change ->simple_tags from the ->change_queue_type,
    and when rejecting a tag message in a single driver, so keeping this
    churn out of scsi_adjust_queue_depth is a clear win.
    
    Now that the usage of scsi_adjust_queue_depth is more obvious we can
    also remove all the trivial instances in ->slave_alloc or ->slave_configure
    that just set it to the cmd_per_lun default.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Reviewed-by: Mike Christie <michaelc@cs.wisc.edu>
    Reviewed-by: Hannes Reinecke <hare@suse.de>
    Reviewed-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/qla1280.c b/drivers/scsi/qla1280.c
index 158020522dfb..adedb6ef8eec 100644
--- a/drivers/scsi/qla1280.c
+++ b/drivers/scsi/qla1280.c
@@ -1224,10 +1224,9 @@ qla1280_slave_configure(struct scsi_device *device)
 
 	if (device->tagged_supported &&
 	    (ha->bus_settings[bus].qtag_enables & (BIT_0 << target))) {
-		scsi_adjust_queue_depth(device, MSG_ORDERED_TAG,
-					ha->bus_settings[bus].hiwat);
+		scsi_adjust_queue_depth(device, ha->bus_settings[bus].hiwat);
 	} else {
-		scsi_adjust_queue_depth(device, 0, default_depth);
+		scsi_adjust_queue_depth(device, default_depth);
 	}
 
 	nv->bus[bus].target[target].parameter.enable_sync = device->sdtr;

commit c5f9ee3d665a7660b296aa1e91949ae3376f0d07
Author: H. Peter Anvin <hpa@linux.intel.com>
Date:   Tue Feb 25 12:05:34 2014 -0800

    x86, platforms: Remove SGI Visual Workstation
    
    The SGI Visual Workstation seems to be dead; remove support so we
    don't have to continue maintaining it.
    
    Cc: Andrey Panin <pazke@donpac.ru>
    Cc: Michael Reed <mdr@sgi.com>
    Link: http://lkml.kernel.org/r/530CFD6C.7040705@zytor.com
    Signed-off-by: H. Peter Anvin <hpa@linux.intel.com>

diff --git a/drivers/scsi/qla1280.c b/drivers/scsi/qla1280.c
index 97dabd39b092..158020522dfb 100644
--- a/drivers/scsi/qla1280.c
+++ b/drivers/scsi/qla1280.c
@@ -379,14 +379,7 @@
 #define  DEBUG_PRINT_NVRAM	0
 #define  DEBUG_QLA1280		0
 
-/*
- * The SGI VISWS is broken and doesn't support MMIO ;-(
- */
-#ifdef CONFIG_X86_VISWS
-#define	MEMORY_MAPPED_IO	0
-#else
 #define	MEMORY_MAPPED_IO	1
-#endif
 
 #include "qla1280.h"
 

commit 762a86a901417280b2af9e2004f05d7481f30441
Author: Meelis Roos <mroos@linux.ee>
Date:   Fri Nov 29 11:05:47 2013 +0200

    [SCSI] qla1280: Annotate timer on stack so object debug does not complain
    
    Object Debug option in 3.13-rc1 resultsin  the following warning, cure
    it by annotating the timer to be on stack. The timer is deleted in the
    same function so stack seems OK.
    
    ODEBUG: object is on stack, but not annotated
    ------------[ cut here ]------------
    WARNING: CPU: 6 PID: 18 at lib/debugobjects.c:300 __debug_object_init+0x184/0x240()
    Modules linked in:
    CPU: 6 PID: 18 Comm: kworker/u4:1 Tainted: G        W    3.13.0-rc1 #16
    Workqueue: events_unbound async_run_entry_fn
    Call Trace:
    [00000000004585cc] warn_slowpath_common+0x4c/0x80
    [0000000000458614] warn_slowpath_null+0x14/0x40
    [000000000063d524] __debug_object_init+0x184/0x240
    [000000000063d5fc] debug_object_init+0x1c/0x40
    [00000000004645ec] init_timer_key+0xc/0x60
    [00000000006cca60] qla1280_mailbox_command+0xc0/0x2a0
    [00000000006ccdd4] qla1280_set_target_parameters+0x194/0x220
    [00000000006cd324] qla1280_slave_configure+0x384/0x3c0
    [00000000006a5d48] scsi_add_lun+0x5c8/0x640
    [00000000006a62b8] scsi_probe_and_add_lun+0x1b8/0x2e0
    [00000000006a6c2c] __scsi_scan_target+0x8c/0x100
    [00000000006a6cf4] scsi_scan_channel+0x54/0xa0
    [00000000006a7008] scsi_scan_host_selected+0xc8/0x120
    [00000000006a70e0] do_scsi_scan_host+0x80/0xa0
    [00000000006a7164] do_scan_async+0x4/0x20
    [00000000004817b8] async_run_entry_fn+0x58/0x120
    ---[ end trace 9a1420108ebfd590 ]---
    
    Signed-off-by: Meelis Roos <mroos@linux.ee>
    Signed-off-by: James Bottomley <JBottomley@Parallels.com>

diff --git a/drivers/scsi/qla1280.c b/drivers/scsi/qla1280.c
index 5a522c5bbd43..97dabd39b092 100644
--- a/drivers/scsi/qla1280.c
+++ b/drivers/scsi/qla1280.c
@@ -2502,7 +2502,7 @@ qla1280_mailbox_command(struct scsi_qla_host *ha, uint8_t mr, uint16_t *mb)
 	/* Issue set host interrupt command. */
 
 	/* set up a timer just in case we're really jammed */
-	init_timer(&timer);
+	init_timer_on_stack(&timer);
 	timer.expires = jiffies + 20*HZ;
 	timer.data = (unsigned long)ha;
 	timer.function = qla1280_mailbox_timeout;

commit 6f039790510fd630ff348efe8c4802dbaa041fba
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Fri Dec 21 13:08:55 2012 -0800

    Drivers: scsi: remove __dev* attributes.
    
    CONFIG_HOTPLUG is going away as an option.  As a result, the __dev*
    markings need to be removed.
    
    This change removes the use of __devinit, __devexit_p, __devinitdata,
    __devinitconst, and __devexit from these drivers.
    
    Based on patches originally written by Bill Pemberton, but redone by me
    in order to handle some of the coding style issues better, by hand.
    
    Cc: Bill Pemberton <wfp5p@virginia.edu>
    Cc: Adam Radford <linuxraid@lsi.com>
    Cc: "James E.J. Bottomley" <JBottomley@parallels.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/scsi/qla1280.c b/drivers/scsi/qla1280.c
index 538230be5cca..5a522c5bbd43 100644
--- a/drivers/scsi/qla1280.c
+++ b/drivers/scsi/qla1280.c
@@ -1438,7 +1438,7 @@ qla1280_return_status(struct response * sts, struct scsi_cmnd *cp)
  * Returns:
  *      0 = success
  */
-static int __devinit
+static int
 qla1280_initialize_adapter(struct scsi_qla_host *ha)
 {
 	struct device_reg __iomem *reg;
@@ -4230,7 +4230,7 @@ static struct scsi_host_template qla1280_driver_template = {
 };
 
 
-static int __devinit
+static int
 qla1280_probe_one(struct pci_dev *pdev, const struct pci_device_id *id)
 {
 	int devnum = id->driver_data;
@@ -4399,7 +4399,7 @@ qla1280_probe_one(struct pci_dev *pdev, const struct pci_device_id *id)
 }
 
 
-static void __devexit
+static void
 qla1280_remove_one(struct pci_dev *pdev)
 {
 	struct Scsi_Host *host = pci_get_drvdata(pdev);
@@ -4433,7 +4433,7 @@ static struct pci_driver qla1280_pci_driver = {
 	.name		= "qla1280",
 	.id_table	= qla1280_pci_tbl,
 	.probe		= qla1280_probe_one,
-	.remove		= __devexit_p(qla1280_remove_one),
+	.remove		= qla1280_remove_one,
 };
 
 static int __init

commit 90449e5dee4800721a352af11ae4d65d4a56ba93
Author: Jesper Juhl <jj@chaosbits.net>
Date:   Mon Apr 9 22:51:36 2012 +0200

    qla1280: Remove redundant NULL check before release_firmware() call
    
    release_firmware() checks for NULL pointers internally so checking
    before calling the function is redundant.
    
    Signed-off-by: Jesper Juhl <jj@chaosbits.net>
    Signed-off-by: Jiri Kosina <jkosina@suse.cz>

diff --git a/drivers/scsi/qla1280.c b/drivers/scsi/qla1280.c
index 6c6486f626ee..538230be5cca 100644
--- a/drivers/scsi/qla1280.c
+++ b/drivers/scsi/qla1280.c
@@ -4473,17 +4473,14 @@ qla1280_exit(void)
 	pci_unregister_driver(&qla1280_pci_driver);
 	/* release any allocated firmware images */
 	for (i = 0; i < QL_NUM_FW_IMAGES; i++) {
-		if (qla1280_fw_tbl[i].fw) {
-			release_firmware(qla1280_fw_tbl[i].fw);
-			qla1280_fw_tbl[i].fw = NULL;
-		}
+		release_firmware(qla1280_fw_tbl[i].fw);
+		qla1280_fw_tbl[i].fw = NULL;
 	}
 }
 
 module_init(qla1280_init);
 module_exit(qla1280_exit);
 
-
 MODULE_AUTHOR("Qlogic & Jes Sorensen");
 MODULE_DESCRIPTION("Qlogic ISP SCSI (qla1x80/qla1x160) driver");
 MODULE_LICENSE("GPL");

commit 9ffc93f203c18a70623f21950f1dd473c9ec48cd
Author: David Howells <dhowells@redhat.com>
Date:   Wed Mar 28 18:30:03 2012 +0100

    Remove all #inclusions of asm/system.h
    
    Remove all #inclusions of asm/system.h preparatory to splitting and killing
    it.  Performed with the following command:
    
    perl -p -i -e 's!^#\s*include\s*<asm/system[.]h>.*\n!!' `grep -Irl '^#\s*include\s*<asm/system[.]h>' *`
    
    Signed-off-by: David Howells <dhowells@redhat.com>

diff --git a/drivers/scsi/qla1280.c b/drivers/scsi/qla1280.c
index d838205ab169..6c6486f626ee 100644
--- a/drivers/scsi/qla1280.c
+++ b/drivers/scsi/qla1280.c
@@ -359,7 +359,6 @@
 #include <asm/byteorder.h>
 #include <asm/processor.h>
 #include <asm/types.h>
-#include <asm/system.h>
 
 #include <scsi/scsi.h>
 #include <scsi/scsi_cmnd.h>

commit 5cd049a59913f359e7d30c11d2dc6187822e77b1
Author: Christoph Hellwig <hch@infradead.org>
Date:   Mon Apr 4 09:42:14 2011 -0400

    [SCSI] remove cmd->serial_number litter
    
    Stop using cmd->serial_number in printks.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: James Bottomley <James.Bottomley@suse.de>

diff --git a/drivers/scsi/qla1280.c b/drivers/scsi/qla1280.c
index 8ba5744c267e..d838205ab169 100644
--- a/drivers/scsi/qla1280.c
+++ b/drivers/scsi/qla1280.c
@@ -4066,7 +4066,7 @@ __qla1280_print_scsi_cmd(struct scsi_cmnd *cmd)
 	   } */
 	printk("  tag=%d, transfersize=0x%x \n",
 	       cmd->tag, cmd->transfersize);
-	printk("  Pid=%li, SP=0x%p\n", cmd->serial_number, CMD_SP(cmd));
+	printk("  SP=0x%p\n", CMD_SP(cmd));
 	printk(" underflow size = 0x%x, direction=0x%x\n",
 	       cmd->underflow, cmd->sc_data_direction);
 }

commit 25985edcedea6396277003854657b5f3cb31a628
Author: Lucas De Marchi <lucas.demarchi@profusion.mobi>
Date:   Wed Mar 30 22:57:33 2011 -0300

    Fix common misspellings
    
    Fixes generated by 'codespell' and manually reviewed.
    
    Signed-off-by: Lucas De Marchi <lucas.demarchi@profusion.mobi>

diff --git a/drivers/scsi/qla1280.c b/drivers/scsi/qla1280.c
index 5dec684bf010..8ba5744c267e 100644
--- a/drivers/scsi/qla1280.c
+++ b/drivers/scsi/qla1280.c
@@ -78,7 +78,7 @@
 	- Clean up vchan handling
     Rev  3.23.33 July 3, 2003, Jes Sorensen
 	- Don't define register access macros before define determining MMIO.
-	  This just happend to work out on ia64 but not elsewhere.
+	  This just happened to work out on ia64 but not elsewhere.
 	- Don't try and read from the card while it is in reset as
 	  it won't respond and causes an MCA
     Rev  3.23.32 June 23, 2003, Jes Sorensen

commit f281233d3eba15fb225d21ae2e228fd4553d824a
Author: Jeff Garzik <jeff@garzik.org>
Date:   Tue Nov 16 02:10:29 2010 -0500

    SCSI host lock push-down
    
    Move the mid-layer's ->queuecommand() invocation from being locked
    with the host lock to being unlocked to facilitate speeding up the
    critical path for drivers who don't need this lock taken anyway.
    
    The patch below presents a simple SCSI host lock push-down as an
    equivalent transformation.  No locking or other behavior should change
    with this patch.  All existing bugs and locking orders are preserved.
    
    Additionally, add one parameter to queuecommand,
            struct Scsi_Host *
    and remove one parameter from queuecommand,
            void (*done)(struct scsi_cmnd *)
    
    Scsi_Host* is a convenient pointer that most host drivers need anyway,
    and 'done' is redundant to struct scsi_cmnd->scsi_done.
    
    Minimal code disturbance was attempted with this change.  Most drivers
    needed only two one-line modifications for their host lock push-down.
    
    Signed-off-by: Jeff Garzik <jgarzik@redhat.com>
    Acked-by: James Bottomley <James.Bottomley@suse.de>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/scsi/qla1280.c b/drivers/scsi/qla1280.c
index b8166ecfd0e3..5dec684bf010 100644
--- a/drivers/scsi/qla1280.c
+++ b/drivers/scsi/qla1280.c
@@ -727,7 +727,7 @@ qla1280_info(struct Scsi_Host *host)
  * context which is a big NO! NO!.
  **************************************************************************/
 static int
-qla1280_queuecommand(struct scsi_cmnd *cmd, void (*fn)(struct scsi_cmnd *))
+qla1280_queuecommand_lck(struct scsi_cmnd *cmd, void (*fn)(struct scsi_cmnd *))
 {
 	struct Scsi_Host *host = cmd->device->host;
 	struct scsi_qla_host *ha = (struct scsi_qla_host *)host->hostdata;
@@ -756,6 +756,8 @@ qla1280_queuecommand(struct scsi_cmnd *cmd, void (*fn)(struct scsi_cmnd *))
 	return status;
 }
 
+static DEF_SCSI_QCMD(qla1280_queuecommand)
+
 enum action {
 	ABORT_COMMAND,
 	DEVICE_RESET,

commit 7da23b86e14b77c094b11a9fa5ef5b3758fc9193
Merge: 749d229761ff 421e33d0045a
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Mon Apr 5 15:37:12 2010 -0700

    Merge git://git.kernel.org/pub/scm/linux/kernel/git/jejb/scsi-rc-fixes-2.6
    
    * git://git.kernel.org/pub/scm/linux/kernel/git/jejb/scsi-rc-fixes-2.6:
      [SCSI] qla1280: retain firmware for error recovery
      [SCSI] attirbute_container: Initialize sysfs attributes with sysfs_attr_init
      [SCSI] advansys: fix regression with request_firmware change
      [SCSI] qla2xxx: Updated version number to 8.03.02-k2.
      [SCSI] qla2xxx: Prevent sending mbx commands from sysfs during isp reset.
      [SCSI] qla2xxx: Disable MSI on qla24xx chips other than QLA2432.
      [SCSI] qla2xxx: Check to make sure multique and CPU affinity support is not enabled at the same time.
      [SCSI] qla2xxx: Correct vp_idx checking during PORT_UPDATE processing.
      [SCSI] qla2xxx: Honour "Extended BB credits" bit for CNAs.
      [SCSI] scsi_transport_fc: Make sure commands are completed when rport is offline
      [SCSI] libiscsi: Fix recovery slowdown regression

commit 5a0e3ad6af8660be21ca98a971cd00f331318c05
Author: Tejun Heo <tj@kernel.org>
Date:   Wed Mar 24 17:04:11 2010 +0900

    include cleanup: Update gfp.h and slab.h includes to prepare for breaking implicit slab.h inclusion from percpu.h
    
    percpu.h is included by sched.h and module.h and thus ends up being
    included when building most .c files.  percpu.h includes slab.h which
    in turn includes gfp.h making everything defined by the two files
    universally available and complicating inclusion dependencies.
    
    percpu.h -> slab.h dependency is about to be removed.  Prepare for
    this change by updating users of gfp and slab facilities include those
    headers directly instead of assuming availability.  As this conversion
    needs to touch large number of source files, the following script is
    used as the basis of conversion.
    
      http://userweb.kernel.org/~tj/misc/slabh-sweep.py
    
    The script does the followings.
    
    * Scan files for gfp and slab usages and update includes such that
      only the necessary includes are there.  ie. if only gfp is used,
      gfp.h, if slab is used, slab.h.
    
    * When the script inserts a new include, it looks at the include
      blocks and try to put the new include such that its order conforms
      to its surrounding.  It's put in the include block which contains
      core kernel includes, in the same order that the rest are ordered -
      alphabetical, Christmas tree, rev-Xmas-tree or at the end if there
      doesn't seem to be any matching order.
    
    * If the script can't find a place to put a new include (mostly
      because the file doesn't have fitting include block), it prints out
      an error message indicating which .h file needs to be added to the
      file.
    
    The conversion was done in the following steps.
    
    1. The initial automatic conversion of all .c files updated slightly
       over 4000 files, deleting around 700 includes and adding ~480 gfp.h
       and ~3000 slab.h inclusions.  The script emitted errors for ~400
       files.
    
    2. Each error was manually checked.  Some didn't need the inclusion,
       some needed manual addition while adding it to implementation .h or
       embedding .c file was more appropriate for others.  This step added
       inclusions to around 150 files.
    
    3. The script was run again and the output was compared to the edits
       from #2 to make sure no file was left behind.
    
    4. Several build tests were done and a couple of problems were fixed.
       e.g. lib/decompress_*.c used malloc/free() wrappers around slab
       APIs requiring slab.h to be added manually.
    
    5. The script was run on all .h files but without automatically
       editing them as sprinkling gfp.h and slab.h inclusions around .h
       files could easily lead to inclusion dependency hell.  Most gfp.h
       inclusion directives were ignored as stuff from gfp.h was usually
       wildly available and often used in preprocessor macros.  Each
       slab.h inclusion directive was examined and added manually as
       necessary.
    
    6. percpu.h was updated not to include slab.h.
    
    7. Build test were done on the following configurations and failures
       were fixed.  CONFIG_GCOV_KERNEL was turned off for all tests (as my
       distributed build env didn't work with gcov compiles) and a few
       more options had to be turned off depending on archs to make things
       build (like ipr on powerpc/64 which failed due to missing writeq).
    
       * x86 and x86_64 UP and SMP allmodconfig and a custom test config.
       * powerpc and powerpc64 SMP allmodconfig
       * sparc and sparc64 SMP allmodconfig
       * ia64 SMP allmodconfig
       * s390 SMP allmodconfig
       * alpha SMP allmodconfig
       * um on x86_64 SMP allmodconfig
    
    8. percpu.h modifications were reverted so that it could be applied as
       a separate patch and serve as bisection point.
    
    Given the fact that I had only a couple of failures from tests on step
    6, I'm fairly confident about the coverage of this conversion patch.
    If there is a breakage, it's likely to be something in one of the arch
    headers which should be easily discoverable easily on most builds of
    the specific arch.
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Guess-its-ok-by: Christoph Lameter <cl@linux-foundation.org>
    Cc: Ingo Molnar <mingo@redhat.com>
    Cc: Lee Schermerhorn <Lee.Schermerhorn@hp.com>

diff --git a/drivers/scsi/qla1280.c b/drivers/scsi/qla1280.c
index 49ac4148493b..8ef87781e51d 100644
--- a/drivers/scsi/qla1280.c
+++ b/drivers/scsi/qla1280.c
@@ -346,7 +346,6 @@
 #include <linux/pci.h>
 #include <linux/proc_fs.h>
 #include <linux/stat.h>
-#include <linux/slab.h>
 #include <linux/pci_ids.h>
 #include <linux/interrupt.h>
 #include <linux/init.h>

commit 421e33d0045ac0aa119c033b78742e0fbf4c3b21
Author: Michael Reed <mdr@sgi.com>
Date:   Tue Mar 23 15:00:58 2010 -0500

    [SCSI] qla1280: retain firmware for error recovery
    
    The qla1280 driver acquires its firmware via udev.  During boot the firmware
    is located in the initrd.  If, after root is mounted, the adapter needs to
    reload firmware (host reset), the firmware load may fail if the root device
    is on the adapter being reset.  This patch modifies qla1280 to retain the
    firmware loaded via the initial request_firmware() for use during error
    recovery.
    
    [jejb: fix up checkpatch issues]
    Signed-off-by: Michael Reed <mdr@sgi.com>
    Acked-by: Jes Sorensen <Jes.Sorensen@redhat.com>
    Signed-off-by: James Bottomley <James.Bottomley@suse.de>

diff --git a/drivers/scsi/qla1280.c b/drivers/scsi/qla1280.c
index 49ac4148493b..66e2dd43008a 100644
--- a/drivers/scsi/qla1280.c
+++ b/drivers/scsi/qla1280.c
@@ -17,9 +17,11 @@
 * General Public License for more details.
 *
 ******************************************************************************/
-#define QLA1280_VERSION      "3.27"
+#define QLA1280_VERSION      "3.27.1"
 /*****************************************************************************
     Revision History:
+    Rev  3.27.1, February 8, 2010, Michael Reed
+	- Retain firmware image for error recovery.
     Rev  3.27, February 10, 2009, Michael Reed
 	- General code cleanup.
 	- Improve error recovery.
@@ -538,9 +540,9 @@ __setup("qla1280=", qla1280_setup);
 /*****************************************/
 
 struct qla_boards {
-	unsigned char name[9];	/* Board ID String */
+	char *name;		/* Board ID String */
 	int numPorts;		/* Number of SCSI ports */
-	char *fwname;		/* firmware name        */
+	int fw_index;		/* index into qla1280_fw_tbl for firmware */
 };
 
 /* NOTE: the last argument in each entry is used to index ql1280_board_tbl */
@@ -561,15 +563,30 @@ static struct pci_device_id qla1280_pci_tbl[] = {
 };
 MODULE_DEVICE_TABLE(pci, qla1280_pci_tbl);
 
+DEFINE_MUTEX(qla1280_firmware_mutex);
+
+struct qla_fw {
+	char *fwname;
+	const struct firmware *fw;
+};
+
+#define QL_NUM_FW_IMAGES 3
+
+struct qla_fw qla1280_fw_tbl[QL_NUM_FW_IMAGES] = {
+	{"qlogic/1040.bin",  NULL},	/* image 0 */
+	{"qlogic/1280.bin",  NULL},	/* image 1 */
+	{"qlogic/12160.bin", NULL},	/* image 2 */
+};
+
+/* NOTE: Order of boards in this table must match order in qla1280_pci_tbl */
 static struct qla_boards ql1280_board_tbl[] = {
-	/* Name ,  Number of ports, FW details */
-	{"QLA12160",	2, "qlogic/12160.bin"},
-	{"QLA1040",	1, "qlogic/1040.bin"},
-	{"QLA1080",	1, "qlogic/1280.bin"},
-	{"QLA1240",	2, "qlogic/1280.bin"},
-	{"QLA1280",	2, "qlogic/1280.bin"},
-	{"QLA10160",	1, "qlogic/12160.bin"},
-	{"        ",	0, "   "},
+	{.name = "QLA12160", .numPorts = 2, .fw_index = 2},
+	{.name = "QLA1040" , .numPorts = 1, .fw_index = 0},
+	{.name = "QLA1080" , .numPorts = 1, .fw_index = 1},
+	{.name = "QLA1240" , .numPorts = 2, .fw_index = 1},
+	{.name = "QLA1280" , .numPorts = 2, .fw_index = 1},
+	{.name = "QLA10160", .numPorts = 1, .fw_index = 2},
+	{.name = "        ", .numPorts = 0, .fw_index = -1},
 };
 
 static int qla1280_verbose = 1;
@@ -1511,6 +1528,63 @@ qla1280_initialize_adapter(struct scsi_qla_host *ha)
 	return status;
 }
 
+/*
+ * qla1280_request_firmware
+ *      Acquire firmware for chip.  Retain in memory
+ *      for error recovery.
+ *
+ * Input:
+ *      ha = adapter block pointer.
+ *
+ * Returns:
+ *      Pointer to firmware image or an error code
+ *      cast to pointer via ERR_PTR().
+ */
+static const struct firmware *
+qla1280_request_firmware(struct scsi_qla_host *ha)
+{
+	const struct firmware *fw;
+	int err;
+	int index;
+	char *fwname;
+
+	spin_unlock_irq(ha->host->host_lock);
+	mutex_lock(&qla1280_firmware_mutex);
+
+	index = ql1280_board_tbl[ha->devnum].fw_index;
+	fw = qla1280_fw_tbl[index].fw;
+	if (fw)
+		goto out;
+
+	fwname = qla1280_fw_tbl[index].fwname;
+	err = request_firmware(&fw, fwname, &ha->pdev->dev);
+
+	if (err) {
+		printk(KERN_ERR "Failed to load image \"%s\" err %d\n",
+		       fwname, err);
+		fw = ERR_PTR(err);
+		goto unlock;
+	}
+	if ((fw->size % 2) || (fw->size < 6)) {
+		printk(KERN_ERR "Invalid firmware length %zu in image \"%s\"\n",
+		       fw->size, fwname);
+		release_firmware(fw);
+		fw = ERR_PTR(-EINVAL);
+		goto unlock;
+	}
+
+	qla1280_fw_tbl[index].fw = fw;
+
+ out:
+	ha->fwver1 = fw->data[0];
+	ha->fwver2 = fw->data[1];
+	ha->fwver3 = fw->data[2];
+ unlock:
+	mutex_unlock(&qla1280_firmware_mutex);
+	spin_lock_irq(ha->host->host_lock);
+	return fw;
+}
+
 /*
  * Chip diagnostics
  *      Test chip for proper operation.
@@ -1634,30 +1708,18 @@ qla1280_chip_diag(struct scsi_qla_host *ha)
 static int
 qla1280_load_firmware_pio(struct scsi_qla_host *ha)
 {
+	/* enter with host_lock acquired */
+
 	const struct firmware *fw;
 	const __le16 *fw_data;
 	uint16_t risc_address, risc_code_size;
 	uint16_t mb[MAILBOX_REGISTER_COUNT], i;
-	int err;
+	int err = 0;
+
+	fw = qla1280_request_firmware(ha);
+	if (IS_ERR(fw))
+		return PTR_ERR(fw);
 
-	spin_unlock_irq(ha->host->host_lock);
-	err = request_firmware(&fw, ql1280_board_tbl[ha->devnum].fwname,
-			       &ha->pdev->dev);
-	spin_lock_irq(ha->host->host_lock);
-	if (err) {
-		printk(KERN_ERR "Failed to load image \"%s\" err %d\n",
-		       ql1280_board_tbl[ha->devnum].fwname, err);
-		return err;
-	}
-	if ((fw->size % 2) || (fw->size < 6)) {
-		printk(KERN_ERR "Bogus length %zu in image \"%s\"\n",
-		       fw->size, ql1280_board_tbl[ha->devnum].fwname);
-		err = -EINVAL;
-		goto out;
-	}
-	ha->fwver1 = fw->data[0];
-	ha->fwver2 = fw->data[1];
-	ha->fwver3 = fw->data[2];
 	fw_data = (const __le16 *)&fw->data[0];
 	ha->fwstart = __le16_to_cpu(fw_data[2]);
 
@@ -1675,11 +1737,10 @@ qla1280_load_firmware_pio(struct scsi_qla_host *ha)
 		if (err) {
 			printk(KERN_ERR "scsi(%li): Failed to load firmware\n",
 					ha->host_no);
-			goto out;
+			break;
 		}
 	}
-out:
-	release_firmware(fw);
+
 	return err;
 }
 
@@ -1687,6 +1748,7 @@ qla1280_load_firmware_pio(struct scsi_qla_host *ha)
 static int
 qla1280_load_firmware_dma(struct scsi_qla_host *ha)
 {
+	/* enter with host_lock acquired */
 	const struct firmware *fw;
 	const __le16 *fw_data;
 	uint16_t risc_address, risc_code_size;
@@ -1701,24 +1763,10 @@ qla1280_load_firmware_dma(struct scsi_qla_host *ha)
 		return -ENOMEM;
 #endif
 
-	spin_unlock_irq(ha->host->host_lock);
-	err = request_firmware(&fw, ql1280_board_tbl[ha->devnum].fwname,
-			       &ha->pdev->dev);
-	spin_lock_irq(ha->host->host_lock);
-	if (err) {
-		printk(KERN_ERR "Failed to load image \"%s\" err %d\n",
-		       ql1280_board_tbl[ha->devnum].fwname, err);
-		return err;
-	}
-	if ((fw->size % 2) || (fw->size < 6)) {
-		printk(KERN_ERR "Bogus length %zu in image \"%s\"\n",
-		       fw->size, ql1280_board_tbl[ha->devnum].fwname);
-		err = -EINVAL;
-		goto out;
-	}
-	ha->fwver1 = fw->data[0];
-	ha->fwver2 = fw->data[1];
-	ha->fwver3 = fw->data[2];
+	fw = qla1280_request_firmware(ha);
+	if (IS_ERR(fw))
+		return PTR_ERR(fw);
+
 	fw_data = (const __le16 *)&fw->data[0];
 	ha->fwstart = __le16_to_cpu(fw_data[2]);
 
@@ -1803,7 +1851,6 @@ qla1280_load_firmware_dma(struct scsi_qla_host *ha)
 #if DUMP_IT_BACK
 	pci_free_consistent(ha->pdev, 8000, tbuf, p_tbuf);
 #endif
-	release_firmware(fw);
 	return err;
 }
 
@@ -1842,6 +1889,7 @@ qla1280_start_firmware(struct scsi_qla_host *ha)
 static int
 qla1280_load_firmware(struct scsi_qla_host *ha)
 {
+	/* enter with host_lock taken */
 	int err;
 
 	err = qla1280_chip_diag(ha);
@@ -4420,7 +4468,16 @@ qla1280_init(void)
 static void __exit
 qla1280_exit(void)
 {
+	int i;
+
 	pci_unregister_driver(&qla1280_pci_driver);
+	/* release any allocated firmware images */
+	for (i = 0; i < QL_NUM_FW_IMAGES; i++) {
+		if (qla1280_fw_tbl[i].fw) {
+			release_firmware(qla1280_fw_tbl[i].fw);
+			qla1280_fw_tbl[i].fw = NULL;
+		}
+	}
 }
 
 module_init(qla1280_init);

commit 2cec802980727f1daa46d8c31b411e083d49d7a2
Author: Ben Hutchings <ben@decadent.org.uk>
Date:   Sat Jan 23 18:40:29 2010 +0000

    [SCSI] qla1280: Drop host_lock while requesting firmware
    
    request_firmware() may sleep and it appears to be safe to release the
    spinlock here.
    
    Signed-off-by: Ben Hutchings <ben@decadent.org.uk>
    Cc: stable@kernel.org
    Signed-off-by: James Bottomley <James.Bottomley@suse.de>

diff --git a/drivers/scsi/qla1280.c b/drivers/scsi/qla1280.c
index 8371d917a9a2..49ac4148493b 100644
--- a/drivers/scsi/qla1280.c
+++ b/drivers/scsi/qla1280.c
@@ -1640,8 +1640,10 @@ qla1280_load_firmware_pio(struct scsi_qla_host *ha)
 	uint16_t mb[MAILBOX_REGISTER_COUNT], i;
 	int err;
 
+	spin_unlock_irq(ha->host->host_lock);
 	err = request_firmware(&fw, ql1280_board_tbl[ha->devnum].fwname,
 			       &ha->pdev->dev);
+	spin_lock_irq(ha->host->host_lock);
 	if (err) {
 		printk(KERN_ERR "Failed to load image \"%s\" err %d\n",
 		       ql1280_board_tbl[ha->devnum].fwname, err);
@@ -1699,8 +1701,10 @@ qla1280_load_firmware_dma(struct scsi_qla_host *ha)
 		return -ENOMEM;
 #endif
 
+	spin_unlock_irq(ha->host->host_lock);
 	err = request_firmware(&fw, ql1280_board_tbl[ha->devnum].fwname,
 			       &ha->pdev->dev);
+	spin_lock_irq(ha->host->host_lock);
 	if (err) {
 		printk(KERN_ERR "Failed to load image \"%s\" err %d\n",
 		       ql1280_board_tbl[ha->devnum].fwname, err);

commit 413e6e18b483de272bdafa56e5c086c75f11d681
Author: Michael Reed <mdr@sgi.com>
Date:   Wed Apr 8 14:34:33 2009 -0500

    [SCSI] qla1280: error recovery rewrite
    
    The driver now waits for the scsi commands associated with a
    particular error recovery step to be returned to the mid-layer,
    and returns the appropriate SUCCESS or FAILED status.  Removes
    unneeded polling of chip for interrupts.
    
    This patch also bumps the driver version number.
    
    Signed-off-by: Michael Reed <mdr@sgi.com>
    Signed-off-by: James Bottomley <James.Bottomley@HansenPartnership.com>

diff --git a/drivers/scsi/qla1280.c b/drivers/scsi/qla1280.c
index 0cbad4982db9..8371d917a9a2 100644
--- a/drivers/scsi/qla1280.c
+++ b/drivers/scsi/qla1280.c
@@ -17,9 +17,12 @@
 * General Public License for more details.
 *
 ******************************************************************************/
-#define QLA1280_VERSION      "3.26"
+#define QLA1280_VERSION      "3.27"
 /*****************************************************************************
     Revision History:
+    Rev  3.27, February 10, 2009, Michael Reed
+	- General code cleanup.
+	- Improve error recovery.
     Rev  3.26, January 16, 2006 Jes Sorensen
 	- Ditch all < 2.6 support
     Rev  3.25.1, February 10, 2005 Christoph Hellwig
@@ -718,6 +721,8 @@ qla1280_queuecommand(struct scsi_cmnd *cmd, void (*fn)(struct scsi_cmnd *))
 	cmd->scsi_done = fn;
 	sp->cmd = cmd;
 	sp->flags = 0;
+	sp->wait = NULL;
+	CMD_HANDLE(cmd) = (unsigned char *)NULL;
 
 	qla1280_print_scsi_cmd(5, cmd);
 
@@ -742,14 +747,6 @@ enum action {
 	ADAPTER_RESET,
 };
 
-/* timer action for error action processor */
-static void qla1280_error_wait_timeout(unsigned long __data)
-{
-	struct scsi_cmnd *cmd = (struct scsi_cmnd *)__data;
-	struct srb *sp = (struct srb *)CMD_SP(cmd);
-
-	complete(sp->wait);
-}
 
 static void qla1280_mailbox_timeout(unsigned long __data)
 {
@@ -764,6 +761,65 @@ static void qla1280_mailbox_timeout(unsigned long __data)
 	complete(ha->mailbox_wait);
 }
 
+static int
+_qla1280_wait_for_single_command(struct scsi_qla_host *ha, struct srb *sp,
+				 struct completion *wait)
+{
+	int	status = FAILED;
+	struct scsi_cmnd *cmd = sp->cmd;
+
+	spin_unlock_irq(ha->host->host_lock);
+	wait_for_completion_timeout(wait, 4*HZ);
+	spin_lock_irq(ha->host->host_lock);
+	sp->wait = NULL;
+	if(CMD_HANDLE(cmd) == COMPLETED_HANDLE) {
+		status = SUCCESS;
+		(*cmd->scsi_done)(cmd);
+	}
+	return status;
+}
+
+static int
+qla1280_wait_for_single_command(struct scsi_qla_host *ha, struct srb *sp)
+{
+	DECLARE_COMPLETION_ONSTACK(wait);
+
+	sp->wait = &wait;
+	return _qla1280_wait_for_single_command(ha, sp, &wait);
+}
+
+static int
+qla1280_wait_for_pending_commands(struct scsi_qla_host *ha, int bus, int target)
+{
+	int		cnt;
+	int		status;
+	struct srb	*sp;
+	struct scsi_cmnd *cmd;
+
+	status = SUCCESS;
+
+	/*
+	 * Wait for all commands with the designated bus/target
+	 * to be completed by the firmware
+	 */
+	for (cnt = 0; cnt < MAX_OUTSTANDING_COMMANDS; cnt++) {
+		sp = ha->outstanding_cmds[cnt];
+		if (sp) {
+			cmd = sp->cmd;
+
+			if (bus >= 0 && SCSI_BUS_32(cmd) != bus)
+				continue;
+			if (target >= 0 && SCSI_TCN_32(cmd) != target)
+				continue;
+
+			status = qla1280_wait_for_single_command(ha, sp);
+			if (status == FAILED)
+				break;
+		}
+	}
+	return status;
+}
+
 /**************************************************************************
  * qla1280_error_action
  *    The function will attempt to perform a specified error action and
@@ -777,11 +833,6 @@ static void qla1280_mailbox_timeout(unsigned long __data)
  * Returns:
  *      SUCCESS or FAILED
  *
- * Note:
- *      Resetting the bus always succeeds - is has to, otherwise the
- *      kernel will panic! Try a surgical technique - sending a BUS
- *      DEVICE RESET message - on the offending target before pulling
- *      the SCSI bus reset line.
  **************************************************************************/
 static int
 qla1280_error_action(struct scsi_cmnd *cmd, enum action action)
@@ -789,15 +840,19 @@ qla1280_error_action(struct scsi_cmnd *cmd, enum action action)
 	struct scsi_qla_host *ha;
 	int bus, target, lun;
 	struct srb *sp;
-	uint16_t data;
-	unsigned char *handle;
-	int result, i;
+	int i, found;
+	int result=FAILED;
+	int wait_for_bus=-1;
+	int wait_for_target = -1;
 	DECLARE_COMPLETION_ONSTACK(wait);
-	struct timer_list timer;
 
 	ENTER("qla1280_error_action");
 
 	ha = (struct scsi_qla_host *)(CMD_HOST(cmd)->hostdata);
+	sp = (struct srb *)CMD_SP(cmd);
+	bus = SCSI_BUS_32(cmd);
+	target = SCSI_TCN_32(cmd);
+	lun = SCSI_LUN_32(cmd);
 
 	dprintk(4, "error_action %i, istatus 0x%04x\n", action,
 		RD_REG_WORD(&ha->iobase->istatus));
@@ -811,73 +866,42 @@ qla1280_error_action(struct scsi_cmnd *cmd, enum action action)
 		       "Handle=0x%p, action=0x%x\n",
 		       ha->host_no, cmd, CMD_HANDLE(cmd), action);
 
-	sp = (struct srb *)CMD_SP(cmd);
-	handle = CMD_HANDLE(cmd);
-
-	/* Check for pending interrupts. */
-	data = qla1280_debounce_register(&ha->iobase->istatus);
-	/*
-	 * The io_request_lock is held when the reset handler is called, hence
-	 * the interrupt handler cannot be running in parallel as it also
-	 * grabs the lock. /Jes
-	 */
-	if (data & RISC_INT)
-		qla1280_isr(ha, &ha->done_q);
-
 	/*
-	 * Determine the suggested action that the mid-level driver wants
-	 * us to perform.
+	 * Check to see if we have the command in the outstanding_cmds[]
+	 * array.  If not then it must have completed before this error
+	 * action was initiated.  If the error_action isn't ABORT_COMMAND
+	 * then the driver must proceed with the requested action.
 	 */
-	if (handle == (unsigned char *)INVALID_HANDLE || handle == NULL) {
-		if(action == ABORT_COMMAND) {
-			/* we never got this command */
-			printk(KERN_INFO "qla1280: Aborting a NULL handle\n");
-			return SUCCESS;	/* no action - we don't have command */
+	found = -1;
+	for (i = 0; i < MAX_OUTSTANDING_COMMANDS; i++) {
+		if (sp == ha->outstanding_cmds[i]) {
+			found = i;
+			sp->wait = &wait; /* we'll wait for it to complete */
+			break;
 		}
-	} else {
-		sp->wait = &wait;
 	}
 
-	bus = SCSI_BUS_32(cmd);
-	target = SCSI_TCN_32(cmd);
-	lun = SCSI_LUN_32(cmd);
+	if (found < 0) {	/* driver doesn't have command */
+		result = SUCCESS;
+		if (qla1280_verbose) {
+			printk(KERN_INFO
+			       "scsi(%ld:%d:%d:%d): specified command has "
+			       "already completed.\n", ha->host_no, bus,
+				target, lun);
+		}
+	}
 
-	/* Overloading result.  Here it means the success or fail of the
-	 * *issue* of the action.  When we return from the routine, it must
-	 * mean the actual success or fail of the action */
-	result = FAILED;
 	switch (action) {
-	case ABORT_COMMAND:
-		if ((sp->flags & SRB_ABORT_PENDING)) {
-			printk(KERN_WARNING
-			       "scsi(): Command has a pending abort "
-			       "message - ABORT_PENDING.\n");
-			/* This should technically be impossible since we
-			 * now wait for abort completion */
-			break;
-		}
 
-		for (i = 0; i < MAX_OUTSTANDING_COMMANDS; i++) {
-			if (sp == ha->outstanding_cmds[i]) {
-				dprintk(1, "qla1280: RISC aborting command\n");
-				if (qla1280_abort_command(ha, sp, i) == 0)
-					result = SUCCESS;
-				else {
-					/*
-					 * Since we don't know what might
-					 * have happend to the command, it
-					 * is unsafe to remove it from the
-					 * device's queue at this point.
-					 * Wait and let the escalation
-					 * process take care of it.
-					 */
-					printk(KERN_WARNING
-					       "scsi(%li:%i:%i:%i): Unable"
-					       " to abort command!\n",
-					       ha->host_no, bus, target, lun);
-				}
-			}
-		}
+	case ABORT_COMMAND:
+		dprintk(1, "qla1280: RISC aborting command\n");
+		/*
+		 * The abort might fail due to race when the host_lock
+		 * is released to issue the abort.  As such, we
+		 * don't bother to check the return status.
+		 */
+		if (found >= 0)
+			qla1280_abort_command(ha, sp, found);
 		break;
 
 	case DEVICE_RESET:
@@ -885,16 +909,21 @@ qla1280_error_action(struct scsi_cmnd *cmd, enum action action)
 			printk(KERN_INFO
 			       "scsi(%ld:%d:%d:%d): Queueing device reset "
 			       "command.\n", ha->host_no, bus, target, lun);
-		if (qla1280_device_reset(ha, bus, target) == 0)
-			result = SUCCESS;
+		if (qla1280_device_reset(ha, bus, target) == 0) {
+			/* issued device reset, set wait conditions */
+			wait_for_bus = bus;
+			wait_for_target = target;
+		}
 		break;
 
 	case BUS_RESET:
 		if (qla1280_verbose)
 			printk(KERN_INFO "qla1280(%ld:%d): Issued bus "
 			       "reset.\n", ha->host_no, bus);
-		if (qla1280_bus_reset(ha, bus) == 0)
-			result = SUCCESS;
+		if (qla1280_bus_reset(ha, bus) == 0) {
+			/* issued bus reset, set wait conditions */
+			wait_for_bus = bus;
+		}
 		break;
 
 	case ADAPTER_RESET:
@@ -907,55 +936,48 @@ qla1280_error_action(struct scsi_cmnd *cmd, enum action action)
 			       "continue automatically\n", ha->host_no);
 		}
 		ha->flags.reset_active = 1;
-		/*
-		 * We restarted all of the commands automatically, so the
-		 * mid-level code can expect completions momentitarily.
-		 */
-		if (qla1280_abort_isp(ha) == 0)
-			result = SUCCESS;
+
+		if (qla1280_abort_isp(ha) != 0) {	/* it's dead */
+			result = FAILED;
+		}
 
 		ha->flags.reset_active = 0;
 	}
 
-	if (!list_empty(&ha->done_q))
-		qla1280_done(ha);
-
-	/* If we didn't manage to issue the action, or we have no
-	 * command to wait for, exit here */
-	if (result == FAILED || handle == NULL ||
-	    handle == (unsigned char *)INVALID_HANDLE) {
-		/*
-		 * Clear completion queue to avoid qla1280_done() trying
-		 * to complete the command at a later stage after we
-		 * have exited the current context
-		 */
-		sp->wait = NULL;
-		goto leave;
-	}
+	/*
+	 * At this point, the host_lock has been released and retaken
+	 * by the issuance of the mailbox command.
+	 * Wait for the command passed in by the mid-layer if it
+	 * was found by the driver.  It might have been returned
+	 * between eh recovery steps, hence the check of the "found"
+	 * variable.
+	 */
 
-	/* set up a timer just in case we're really jammed */
-	init_timer(&timer);
-	timer.expires = jiffies + 4*HZ;
-	timer.data = (unsigned long)cmd;
-	timer.function = qla1280_error_wait_timeout;
-	add_timer(&timer);
+	if (found >= 0)
+		result = _qla1280_wait_for_single_command(ha, sp, &wait);
 
-	/* wait for the action to complete (or the timer to expire) */
-	spin_unlock_irq(ha->host->host_lock);
-	wait_for_completion(&wait);
-	del_timer_sync(&timer);
-	spin_lock_irq(ha->host->host_lock);
-	sp->wait = NULL;
+	if (action == ABORT_COMMAND && result != SUCCESS) {
+		printk(KERN_WARNING
+		       "scsi(%li:%i:%i:%i): "
+		       "Unable to abort command!\n",
+		       ha->host_no, bus, target, lun);
+	}
 
-	/* the only action we might get a fail for is abort */
-	if (action == ABORT_COMMAND) {
-		if(sp->flags & SRB_ABORTED)
-			result = SUCCESS;
-		else
-			result = FAILED;
+	/*
+	 * If the command passed in by the mid-layer has been
+	 * returned by the board, then wait for any additional
+	 * commands which are supposed to complete based upon
+	 * the error action.
+	 *
+	 * All commands are unconditionally returned during a
+	 * call to qla1280_abort_isp(), ADAPTER_RESET.  No need
+	 * to wait for them.
+	 */
+	if (result == SUCCESS && wait_for_bus >= 0) {
+		result = qla1280_wait_for_pending_commands(ha,
+					wait_for_bus, wait_for_target);
 	}
 
- leave:
 	dprintk(1, "RESET returning %d\n", result);
 
 	LEAVE("qla1280_error_action");
@@ -1258,7 +1280,8 @@ qla1280_done(struct scsi_qla_host *ha)
 		switch ((CMD_RESULT(cmd) >> 16)) {
 		case DID_RESET:
 			/* Issue marker command. */
-			qla1280_marker(ha, bus, target, 0, MK_SYNC_ID);
+			if (!ha->flags.abort_isp_active)
+				qla1280_marker(ha, bus, target, 0, MK_SYNC_ID);
 			break;
 		case DID_ABORT:
 			sp->flags &= ~SRB_ABORT_PENDING;
@@ -1272,12 +1295,11 @@ qla1280_done(struct scsi_qla_host *ha)
 		scsi_dma_unmap(cmd);
 
 		/* Call the mid-level driver interrupt handler */
-		CMD_HANDLE(sp->cmd) = (unsigned char *)INVALID_HANDLE;
 		ha->actthreads--;
 
-		(*(cmd)->scsi_done)(cmd);
-
-		if(sp->wait != NULL)
+		if (sp->wait == NULL)
+			(*(cmd)->scsi_done)(cmd);
+		else
 			complete(sp->wait);
 	}
 	LEAVE("qla1280_done");
@@ -3415,6 +3437,7 @@ qla1280_isr(struct scsi_qla_host *ha, struct list_head *done_q)
 
 					/* Save ISP completion status */
 					CMD_RESULT(sp->cmd) = 0;
+					CMD_HANDLE(sp->cmd) = COMPLETED_HANDLE;
 
 					/* Place block on done queue */
 					list_add_tail(&sp->list, done_q);
@@ -3681,6 +3704,8 @@ qla1280_status_entry(struct scsi_qla_host *ha, struct response *pkt,
 		}
 	}
 
+	CMD_HANDLE(sp->cmd) = COMPLETED_HANDLE;
+
 	/* Place command on done queue. */
 	list_add_tail(&sp->list, done_q);
  out:
@@ -3736,6 +3761,8 @@ qla1280_error_entry(struct scsi_qla_host *ha, struct response *pkt,
 			CMD_RESULT(sp->cmd) = DID_ERROR << 16;
 		}
 
+		CMD_HANDLE(sp->cmd) = COMPLETED_HANDLE;
+
 		/* Place command on done queue. */
 		list_add_tail(&sp->list, done_q);
 	}
@@ -3786,19 +3813,16 @@ qla1280_abort_isp(struct scsi_qla_host *ha)
 		struct scsi_cmnd *cmd;
 		sp = ha->outstanding_cmds[cnt];
 		if (sp) {
-
 			cmd = sp->cmd;
 			CMD_RESULT(cmd) = DID_RESET << 16;
-
-			sp->cmd = NULL;
+			CMD_HANDLE(cmd) = COMPLETED_HANDLE;
 			ha->outstanding_cmds[cnt] = NULL;
-
-			(*cmd->scsi_done)(cmd);
-
-			sp->flags = 0;
+			list_add_tail(&sp->list, &ha->done_q);
 		}
 	}
 
+	qla1280_done(ha);
+
 	status = qla1280_load_firmware(ha);
 	if (status)
 		goto out;

commit fd65e5e93cbd9d2f34bbb0f0b2f46a30a1d20915
Author: Michael Reed <mdr@sgi.com>
Date:   Wed Apr 8 14:33:48 2009 -0500

    [SCSI] qla1280: driver clean up
    
    Remove some unneeded, inactive and unused code, make some trivial
    corrections to comments and a printk, and return a proper status
    in qla1280_queuecommand.  No fundamental logic changes are made.
    
    Signed-off-by: Michael Reed <mdr@sgi.com>
    Signed-off-by: James Bottomley <James.Bottomley@HansenPartnership.com>

diff --git a/drivers/scsi/qla1280.c b/drivers/scsi/qla1280.c
index 5defe5ea5eda..0cbad4982db9 100644
--- a/drivers/scsi/qla1280.c
+++ b/drivers/scsi/qla1280.c
@@ -435,7 +435,6 @@ static int qla1280_mailbox_command(struct scsi_qla_host *,
 				   uint8_t, uint16_t *);
 static int qla1280_bus_reset(struct scsi_qla_host *, int);
 static int qla1280_device_reset(struct scsi_qla_host *, int, int);
-static int qla1280_abort_device(struct scsi_qla_host *, int, int, int);
 static int qla1280_abort_command(struct scsi_qla_host *, struct srb *, int);
 static int qla1280_abort_isp(struct scsi_qla_host *);
 #ifdef QLA_64BIT_PTR
@@ -698,7 +697,7 @@ qla1280_info(struct Scsi_Host *host)
 }
 
 /**************************************************************************
- *   qla1200_queuecommand
+ *   qla1280_queuecommand
  *     Queue a command to the controller.
  *
  * Note:
@@ -713,7 +712,7 @@ qla1280_queuecommand(struct scsi_cmnd *cmd, void (*fn)(struct scsi_cmnd *))
 {
 	struct Scsi_Host *host = cmd->device->host;
 	struct scsi_qla_host *ha = (struct scsi_qla_host *)host->hostdata;
-	struct srb *sp = (struct srb *)&cmd->SCp;
+	struct srb *sp = (struct srb *)CMD_SP(cmd);
 	int status;
 
 	cmd->scsi_done = fn;
@@ -738,11 +737,9 @@ qla1280_queuecommand(struct scsi_cmnd *cmd, void (*fn)(struct scsi_cmnd *))
 
 enum action {
 	ABORT_COMMAND,
-	ABORT_DEVICE,
 	DEVICE_RESET,
 	BUS_RESET,
 	ADAPTER_RESET,
-	FAIL
 };
 
 /* timer action for error action processor */
@@ -768,7 +765,7 @@ static void qla1280_mailbox_timeout(unsigned long __data)
 }
 
 /**************************************************************************
- * qla1200_error_action
+ * qla1280_error_action
  *    The function will attempt to perform a specified error action and
  *    wait for the results (or time out).
  *
@@ -798,6 +795,8 @@ qla1280_error_action(struct scsi_cmnd *cmd, enum action action)
 	DECLARE_COMPLETION_ONSTACK(wait);
 	struct timer_list timer;
 
+	ENTER("qla1280_error_action");
+
 	ha = (struct scsi_qla_host *)(CMD_HOST(cmd)->hostdata);
 
 	dprintk(4, "error_action %i, istatus 0x%04x\n", action,
@@ -807,20 +806,11 @@ qla1280_error_action(struct scsi_cmnd *cmd, enum action action)
 		RD_REG_WORD(&ha->iobase->host_cmd),
 		RD_REG_WORD(&ha->iobase->ictrl), jiffies);
 
-	ENTER("qla1280_error_action");
 	if (qla1280_verbose)
 		printk(KERN_INFO "scsi(%li): Resetting Cmnd=0x%p, "
 		       "Handle=0x%p, action=0x%x\n",
 		       ha->host_no, cmd, CMD_HANDLE(cmd), action);
 
-	if (cmd == NULL) {
-		printk(KERN_WARNING "(scsi?:?:?:?) Reset called with NULL "
-		       "si_Cmnd pointer, failing.\n");
-		LEAVE("qla1280_error_action");
-		return FAILED;
-	}
-
-	ha = (struct scsi_qla_host *)cmd->device->host->hostdata;
 	sp = (struct srb *)CMD_SP(cmd);
 	handle = CMD_HANDLE(cmd);
 
@@ -857,9 +847,6 @@ qla1280_error_action(struct scsi_cmnd *cmd, enum action action)
 	 * mean the actual success or fail of the action */
 	result = FAILED;
 	switch (action) {
-	case FAIL:
-		break;
-
 	case ABORT_COMMAND:
 		if ((sp->flags & SRB_ABORT_PENDING)) {
 			printk(KERN_WARNING
@@ -893,15 +880,6 @@ qla1280_error_action(struct scsi_cmnd *cmd, enum action action)
 		}
 		break;
 
-	case ABORT_DEVICE:
-		if (qla1280_verbose)
-			printk(KERN_INFO
-			       "scsi(%ld:%d:%d:%d): Queueing abort device "
-			       "command.\n", ha->host_no, bus, target, lun);
-		if (qla1280_abort_device(ha, bus, target, lun) == 0)
-			result = SUCCESS;
-		break;
-
 	case DEVICE_RESET:
 		if (qla1280_verbose)
 			printk(KERN_INFO
@@ -1285,8 +1263,6 @@ qla1280_done(struct scsi_qla_host *ha)
 		case DID_ABORT:
 			sp->flags &= ~SRB_ABORT_PENDING;
 			sp->flags |= SRB_ABORTED;
-			if (sp->flags & SRB_TIMEOUT)
-				CMD_RESULT(sp->cmd) = DID_TIME_OUT << 16;
 			break;
 		default:
 			break;
@@ -2417,9 +2393,6 @@ static int
 qla1280_mailbox_command(struct scsi_qla_host *ha, uint8_t mr, uint16_t *mb)
 {
 	struct device_reg __iomem *reg = ha->iobase;
-#if 0
-	LIST_HEAD(done_q);
-#endif
 	int status = 0;
 	int cnt;
 	uint16_t *optr, *iptr;
@@ -2493,19 +2466,9 @@ qla1280_mailbox_command(struct scsi_qla_host *ha, uint8_t mr, uint16_t *mb)
 	mr = MAILBOX_REGISTER_COUNT;
 	memcpy(optr, iptr, MAILBOX_REGISTER_COUNT * sizeof(uint16_t));
 
-#if 0
-	/* Go check for any response interrupts pending. */
-	qla1280_isr(ha, &done_q);
-#endif
-
 	if (ha->flags.reset_marker)
 		qla1280_rst_aen(ha);
 
-#if 0
-	if (!list_empty(&done_q))
-		qla1280_done(ha, &done_q);
-#endif
-
 	if (status)
 		dprintk(2, "qla1280_mailbox_command: **** FAILED, mailbox0 = "
 			"0x%x ****\n", mb[0]);
@@ -2640,41 +2603,6 @@ qla1280_device_reset(struct scsi_qla_host *ha, int bus, int target)
 	return status;
 }
 
-/*
- * qla1280_abort_device
- *      Issue an abort message to the device
- *
- * Input:
- *      ha     = adapter block pointer.
- *      bus    = SCSI BUS.
- *      target = SCSI ID.
- *      lun    = SCSI LUN.
- *
- * Returns:
- *      0 = success
- */
-static int
-qla1280_abort_device(struct scsi_qla_host *ha, int bus, int target, int lun)
-{
-	uint16_t mb[MAILBOX_REGISTER_COUNT];
-	int status;
-
-	ENTER("qla1280_abort_device");
-
-	mb[0] = MBC_ABORT_DEVICE;
-	mb[1] = (bus ? target | BIT_7 : target) << 8 | lun;
-	status = qla1280_mailbox_command(ha, BIT_1 | BIT_0, &mb[0]);
-
-	/* Issue marker command. */
-	qla1280_marker(ha, bus, target, lun, MK_SYNC_ID_LUN);
-
-	if (status)
-		dprintk(2, "qla1280_abort_device: **** FAILED ****\n");
-
-	LEAVE("qla1280_abort_device");
-	return status;
-}
-
 /*
  * qla1280_abort_command
  *      Abort command aborts a specified IOCB.
@@ -2833,7 +2761,7 @@ qla1280_64bit_start_scsi(struct scsi_qla_host *ha, struct srb * sp)
 
 	/* If room for request in request ring. */
 	if ((req_cnt + 2) >= ha->req_q_cnt) {
-		status = 1;
+		status = SCSI_MLQUEUE_HOST_BUSY;
 		dprintk(2, "qla1280_start_scsi: in-ptr=0x%x  req_q_cnt="
 			"0x%xreq_cnt=0x%x", ha->req_ring_index, ha->req_q_cnt,
 			req_cnt);
@@ -2845,7 +2773,7 @@ qla1280_64bit_start_scsi(struct scsi_qla_host *ha, struct srb * sp)
 		     ha->outstanding_cmds[cnt] != NULL; cnt++);
 
 	if (cnt >= MAX_OUTSTANDING_COMMANDS) {
-		status = 1;
+		status = SCSI_MLQUEUE_HOST_BUSY;
 		dprintk(2, "qla1280_start_scsi: NO ROOM IN "
 			"OUTSTANDING ARRAY, req_q_cnt=0x%x", ha->req_q_cnt);
 		goto out;
@@ -3108,7 +3036,7 @@ qla1280_32bit_start_scsi(struct scsi_qla_host *ha, struct srb * sp)
 		ha->req_q_cnt, seg_cnt);
 	/* If room for request in request ring. */
 	if ((req_cnt + 2) >= ha->req_q_cnt) {
-		status = 1;
+		status = SCSI_MLQUEUE_HOST_BUSY;
 		dprintk(2, "qla1280_32bit_start_scsi: in-ptr=0x%x, "
 			"req_q_cnt=0x%x, req_cnt=0x%x", ha->req_ring_index,
 			ha->req_q_cnt, req_cnt);
@@ -3120,7 +3048,7 @@ qla1280_32bit_start_scsi(struct scsi_qla_host *ha, struct srb * sp)
 		     (ha->outstanding_cmds[cnt] != 0); cnt++) ;
 
 	if (cnt >= MAX_OUTSTANDING_COMMANDS) {
-		status = 1;
+		status = SCSI_MLQUEUE_HOST_BUSY;
 		dprintk(2, "qla1280_32bit_start_scsi: NO ROOM IN OUTSTANDING "
 			"ARRAY, req_q_cnt=0x%x\n", ha->req_q_cnt);
 		goto out;
@@ -3495,7 +3423,7 @@ qla1280_isr(struct scsi_qla_host *ha, struct list_head *done_q)
 					 * If we get here we have a real problem!
 					 */
 					printk(KERN_WARNING
-					       "qla1280: ISP invalid handle");
+					       "qla1280: ISP invalid handle\n");
 				}
 			}
 			break;
@@ -3955,13 +3883,6 @@ qla1280_check_for_dead_scsi_bus(struct scsi_qla_host *ha, unsigned int bus)
 
 		if (scsi_control == SCSI_PHASE_INVALID) {
 			ha->bus_settings[bus].scsi_bus_dead = 1;
-#if 0
-			CMD_RESULT(cp) = DID_NO_CONNECT << 16;
-			CMD_HANDLE(cp) = INVALID_HANDLE;
-			/* ha->actthreads--; */
-
-			(*(cp)->scsi_done)(cp);
-#endif
 			return 1;	/* bus is dead */
 		} else {
 			ha->bus_settings[bus].scsi_bus_dead = 0;

commit 1e17d774db837fe1a536066cbe971114405d2ba1
Merge: d848223808c5 0ce49d6da993
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Fri Apr 10 12:01:22 2009 -0700

    Merge git://git.infradead.org/~dwmw2/firmware-2.6
    
    * git://git.infradead.org/~dwmw2/firmware-2.6:
      qla1280: Fix off-by-some error in firmware loading.
      Add README.AddingFirmware file. Basically telling people not to.
      firmware: Remove newly-added slicoss and sxg firmware images
      firmware/WHENCE: Add missing origin information for Ambassador atmsar11.fw
      ALSA: wavefront - Always use request_firmware()
      Remove fdump tool for av7110 firmware
      firmware: convert av7110 driver to request_firmware()
      Partially revert "V4L/DVB (9533): cx88: Add support for TurboSight TBS8910 DVB-S PCI card"
      Revert "fix modules_install via NFS"
    
    Add-add conflicts in firmware/WHENCE fixed manually

commit 0ce49d6da993adf8b17b7f3ed9805ade14a6a6f3
Author: David Woodhouse <David.Woodhouse@intel.com>
Date:   Wed Apr 8 01:22:36 2009 -0700

    qla1280: Fix off-by-some error in firmware loading.
    
    We were calculating the wrong address for the start of the data.
    
    Signed-off-by: David Woodhouse <David.Woodhouse@intel.com>
    Tested-by: Jeremy Higdon <jeremy@sgi.com>

diff --git a/drivers/scsi/qla1280.c b/drivers/scsi/qla1280.c
index 351b56ced925..d030db93d55b 100644
--- a/drivers/scsi/qla1280.c
+++ b/drivers/scsi/qla1280.c
@@ -1663,7 +1663,7 @@ qla1280_load_firmware_pio(struct scsi_qla_host *ha)
 
 	/* Load RISC code. */
 	risc_address = ha->fwstart;
-	fw_data = (const __le16 *)&fw->data[4];
+	fw_data = (const __le16 *)&fw->data[6];
 	risc_code_size = (fw->size - 6) / 2;
 
 	for (i = 0; i < risc_code_size; i++) {
@@ -1722,7 +1722,7 @@ qla1280_load_firmware_dma(struct scsi_qla_host *ha)
 
 	/* Load RISC code. */
 	risc_address = ha->fwstart;
-	fw_data = (const __le16 *)&fw->data[4];
+	fw_data = (const __le16 *)&fw->data[6];
 	risc_code_size = (fw->size - 6) / 2;
 
 	dprintk(1, "%s: DMA RISC code (%i) words\n",

commit 284901a90a9e0b812ca3f5f852cbbfb60d10249d
Author: Yang Hongyang <yanghy@cn.fujitsu.com>
Date:   Mon Apr 6 19:01:15 2009 -0700

    dma-mapping: replace all DMA_32BIT_MASK macro with DMA_BIT_MASK(32)
    
    Replace all DMA_32BIT_MASK macro with DMA_BIT_MASK(32)
    
    Signed-off-by: Yang Hongyang<yanghy@cn.fujitsu.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/scsi/qla1280.c b/drivers/scsi/qla1280.c
index 18f7f98ba571..687dcf2d0154 100644
--- a/drivers/scsi/qla1280.c
+++ b/drivers/scsi/qla1280.c
@@ -4276,7 +4276,7 @@ qla1280_probe_one(struct pci_dev *pdev, const struct pci_device_id *id)
 
 #ifdef QLA_64BIT_PTR
 	if (pci_set_dma_mask(ha->pdev, DMA_BIT_MASK(64))) {
-		if (pci_set_dma_mask(ha->pdev, DMA_32BIT_MASK)) {
+		if (pci_set_dma_mask(ha->pdev, DMA_BIT_MASK(32))) {
 			printk(KERN_WARNING "scsi(%li): Unable to set a "
 			       "suitable DMA mask - aborting\n", ha->host_no);
 			error = -ENODEV;
@@ -4286,7 +4286,7 @@ qla1280_probe_one(struct pci_dev *pdev, const struct pci_device_id *id)
 		dprintk(2, "scsi(%li): 64 Bit PCI Addressing Enabled\n",
 			ha->host_no);
 #else
-	if (pci_set_dma_mask(ha->pdev, DMA_32BIT_MASK)) {
+	if (pci_set_dma_mask(ha->pdev, DMA_BIT_MASK(32))) {
 		printk(KERN_WARNING "scsi(%li): Unable to set a "
 		       "suitable DMA mask - aborting\n", ha->host_no);
 		error = -ENODEV;

commit 6a35528a8346f6e6fd32ed7e51f04d1fa4ca2c01
Author: Yang Hongyang <yanghy@cn.fujitsu.com>
Date:   Mon Apr 6 19:01:13 2009 -0700

    dma-mapping: replace all DMA_64BIT_MASK macro with DMA_BIT_MASK(64)
    
    Replace all DMA_64BIT_MASK macro with DMA_BIT_MASK(64)
    
    Signed-off-by: Yang Hongyang<yanghy@cn.fujitsu.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/scsi/qla1280.c b/drivers/scsi/qla1280.c
index 351b56ced925..18f7f98ba571 100644
--- a/drivers/scsi/qla1280.c
+++ b/drivers/scsi/qla1280.c
@@ -4275,7 +4275,7 @@ qla1280_probe_one(struct pci_dev *pdev, const struct pci_device_id *id)
 	ha->devnum = devnum;	/* specifies microcode load address */
 
 #ifdef QLA_64BIT_PTR
-	if (pci_set_dma_mask(ha->pdev, DMA_64BIT_MASK)) {
+	if (pci_set_dma_mask(ha->pdev, DMA_BIT_MASK(64))) {
 		if (pci_set_dma_mask(ha->pdev, DMA_32BIT_MASK)) {
 			printk(KERN_WARNING "scsi(%li): Unable to set a "
 			       "suitable DMA mask - aborting\n", ha->host_no);

commit 1bfa11db712cbf4af1ae037cd25fd4f781f0c215
Author: Jaswinder Singh Rajput <jaswinderrajput@gmail.com>
Date:   Thu Apr 2 11:13:17 2009 +0530

    [SCSI] qla1280: use request_firmware
    
    Firmware blob is little endian looks like this...
            unsigned char  Version1
            unsigned char  Version2
            unsigned char  Version3
            unsigned char  Padding
            unsigned short start_address
            unsigned short data
    
    Signed-off-by: Jaswinder Singh Rajput <jaswinderrajput@gmail.com>
    Signed-off-by: James Bottomley <James.Bottomley@HansenPartnership.com>

diff --git a/drivers/scsi/qla1280.c b/drivers/scsi/qla1280.c
index df09820e8916..351b56ced925 100644
--- a/drivers/scsi/qla1280.c
+++ b/drivers/scsi/qla1280.c
@@ -348,6 +348,7 @@
 #include <linux/interrupt.h>
 #include <linux/init.h>
 #include <linux/dma-mapping.h>
+#include <linux/firmware.h>
 
 #include <asm/io.h>
 #include <asm/irq.h>
@@ -384,11 +385,7 @@
 #define	MEMORY_MAPPED_IO	1
 #endif
 
-#define UNIQUE_FW_NAME
 #include "qla1280.h"
-#include "ql12160_fw.h"		/* ISP RISC codes */
-#include "ql1280_fw.h"
-#include "ql1040_fw.h"
 
 #ifndef BITS_PER_LONG
 #error "BITS_PER_LONG not defined!"
@@ -541,10 +538,7 @@ __setup("qla1280=", qla1280_setup);
 struct qla_boards {
 	unsigned char name[9];	/* Board ID String */
 	int numPorts;		/* Number of SCSI ports */
-	unsigned short *fwcode;	/* pointer to FW array         */
-	unsigned short *fwlen;	/* number of words in array    */
-	unsigned short *fwstart;	/* start address for F/W       */
-	unsigned char *fwver;	/* Ptr to F/W version array    */
+	char *fwname;		/* firmware name        */
 };
 
 /* NOTE: the last argument in each entry is used to index ql1280_board_tbl */
@@ -567,19 +561,13 @@ MODULE_DEVICE_TABLE(pci, qla1280_pci_tbl);
 
 static struct qla_boards ql1280_board_tbl[] = {
 	/* Name ,  Number of ports, FW details */
-	{"QLA12160", 2, &fw12160i_code01[0], &fw12160i_length01,
-	 &fw12160i_addr01, &fw12160i_version_str[0]},
-	{"QLA1040", 1, &risc_code01[0], &risc_code_length01,
-	 &risc_code_addr01, &firmware_version[0]},
-	{"QLA1080", 1, &fw1280ei_code01[0], &fw1280ei_length01,
-	 &fw1280ei_addr01, &fw1280ei_version_str[0]},
-	{"QLA1240", 2, &fw1280ei_code01[0], &fw1280ei_length01,
-	 &fw1280ei_addr01, &fw1280ei_version_str[0]},
-	{"QLA1280", 2, &fw1280ei_code01[0], &fw1280ei_length01,
-	 &fw1280ei_addr01, &fw1280ei_version_str[0]},
-	{"QLA10160", 1, &fw12160i_code01[0], &fw12160i_length01,
-	 &fw12160i_addr01, &fw12160i_version_str[0]},
-	{"        ", 0}
+	{"QLA12160",	2, "qlogic/12160.bin"},
+	{"QLA1040",	1, "qlogic/1040.bin"},
+	{"QLA1080",	1, "qlogic/1280.bin"},
+	{"QLA1240",	2, "qlogic/1280.bin"},
+	{"QLA1280",	2, "qlogic/1280.bin"},
+	{"QLA10160",	1, "qlogic/12160.bin"},
+	{"        ",	0, "   "},
 };
 
 static int qla1280_verbose = 1;
@@ -704,7 +692,7 @@ qla1280_info(struct Scsi_Host *host)
 	sprintf (bp,
 		 "QLogic %s PCI to SCSI Host Adapter\n"
 		 "       Firmware version: %2d.%02d.%02d, Driver version %s",
-		 &bdp->name[0], bdp->fwver[0], bdp->fwver[1], bdp->fwver[2],
+		 &bdp->name[0], ha->fwver1, ha->fwver2, ha->fwver3,
 		 QLA1280_VERSION);
 	return bp;
 }
@@ -1648,36 +1636,60 @@ qla1280_chip_diag(struct scsi_qla_host *ha)
 static int
 qla1280_load_firmware_pio(struct scsi_qla_host *ha)
 {
-	uint16_t risc_address, *risc_code_address, risc_code_size;
+	const struct firmware *fw;
+	const __le16 *fw_data;
+	uint16_t risc_address, risc_code_size;
 	uint16_t mb[MAILBOX_REGISTER_COUNT], i;
 	int err;
 
+	err = request_firmware(&fw, ql1280_board_tbl[ha->devnum].fwname,
+			       &ha->pdev->dev);
+	if (err) {
+		printk(KERN_ERR "Failed to load image \"%s\" err %d\n",
+		       ql1280_board_tbl[ha->devnum].fwname, err);
+		return err;
+	}
+	if ((fw->size % 2) || (fw->size < 6)) {
+		printk(KERN_ERR "Bogus length %zu in image \"%s\"\n",
+		       fw->size, ql1280_board_tbl[ha->devnum].fwname);
+		err = -EINVAL;
+		goto out;
+	}
+	ha->fwver1 = fw->data[0];
+	ha->fwver2 = fw->data[1];
+	ha->fwver3 = fw->data[2];
+	fw_data = (const __le16 *)&fw->data[0];
+	ha->fwstart = __le16_to_cpu(fw_data[2]);
+
 	/* Load RISC code. */
-	risc_address = *ql1280_board_tbl[ha->devnum].fwstart;
-	risc_code_address = ql1280_board_tbl[ha->devnum].fwcode;
-	risc_code_size = *ql1280_board_tbl[ha->devnum].fwlen;
+	risc_address = ha->fwstart;
+	fw_data = (const __le16 *)&fw->data[4];
+	risc_code_size = (fw->size - 6) / 2;
 
 	for (i = 0; i < risc_code_size; i++) {
 		mb[0] = MBC_WRITE_RAM_WORD;
 		mb[1] = risc_address + i;
-		mb[2] = risc_code_address[i];
+		mb[2] = __le16_to_cpu(fw_data[i]);
 
 		err = qla1280_mailbox_command(ha, BIT_0 | BIT_1 | BIT_2, mb);
 		if (err) {
 			printk(KERN_ERR "scsi(%li): Failed to load firmware\n",
 					ha->host_no);
-			return err;
+			goto out;
 		}
 	}
-
-	return 0;
+out:
+	release_firmware(fw);
+	return err;
 }
 
 #define DUMP_IT_BACK 0		/* for debug of RISC loading */
 static int
 qla1280_load_firmware_dma(struct scsi_qla_host *ha)
 {
-	uint16_t risc_address, *risc_code_address, risc_code_size;
+	const struct firmware *fw;
+	const __le16 *fw_data;
+	uint16_t risc_address, risc_code_size;
 	uint16_t mb[MAILBOX_REGISTER_COUNT], cnt;
 	int err = 0, num, i;
 #if DUMP_IT_BACK
@@ -1689,10 +1701,29 @@ qla1280_load_firmware_dma(struct scsi_qla_host *ha)
 		return -ENOMEM;
 #endif
 
+	err = request_firmware(&fw, ql1280_board_tbl[ha->devnum].fwname,
+			       &ha->pdev->dev);
+	if (err) {
+		printk(KERN_ERR "Failed to load image \"%s\" err %d\n",
+		       ql1280_board_tbl[ha->devnum].fwname, err);
+		return err;
+	}
+	if ((fw->size % 2) || (fw->size < 6)) {
+		printk(KERN_ERR "Bogus length %zu in image \"%s\"\n",
+		       fw->size, ql1280_board_tbl[ha->devnum].fwname);
+		err = -EINVAL;
+		goto out;
+	}
+	ha->fwver1 = fw->data[0];
+	ha->fwver2 = fw->data[1];
+	ha->fwver3 = fw->data[2];
+	fw_data = (const __le16 *)&fw->data[0];
+	ha->fwstart = __le16_to_cpu(fw_data[2]);
+
 	/* Load RISC code. */
-	risc_address = *ql1280_board_tbl[ha->devnum].fwstart;
-	risc_code_address = ql1280_board_tbl[ha->devnum].fwcode;
-	risc_code_size = *ql1280_board_tbl[ha->devnum].fwlen;
+	risc_address = ha->fwstart;
+	fw_data = (const __le16 *)&fw->data[4];
+	risc_code_size = (fw->size - 6) / 2;
 
 	dprintk(1, "%s: DMA RISC code (%i) words\n",
 			__func__, risc_code_size);
@@ -1708,10 +1739,9 @@ qla1280_load_firmware_dma(struct scsi_qla_host *ha)
 
 		dprintk(2, "qla1280_setup_chip:  loading risc @ =(0x%p),"
 			"%d,%d(0x%x)\n",
-			risc_code_address, cnt, num, risc_address);
+			fw_data, cnt, num, risc_address);
 		for(i = 0; i < cnt; i++)
-			((__le16 *)ha->request_ring)[i] =
-				cpu_to_le16(risc_code_address[i]);
+			((__le16 *)ha->request_ring)[i] = fw_data[i];
 
 		mb[0] = MBC_LOAD_RAM;
 		mb[1] = risc_address;
@@ -1763,7 +1793,7 @@ qla1280_load_firmware_dma(struct scsi_qla_host *ha)
 #endif
 		risc_address += cnt;
 		risc_code_size = risc_code_size - cnt;
-		risc_code_address = risc_code_address + cnt;
+		fw_data = fw_data + cnt;
 		num++;
 	}
 
@@ -1771,6 +1801,7 @@ qla1280_load_firmware_dma(struct scsi_qla_host *ha)
 #if DUMP_IT_BACK
 	pci_free_consistent(ha->pdev, 8000, tbuf, p_tbuf);
 #endif
+	release_firmware(fw);
 	return err;
 }
 
@@ -1786,7 +1817,7 @@ qla1280_start_firmware(struct scsi_qla_host *ha)
 	/* Verify checksum of loaded RISC code. */
 	mb[0] = MBC_VERIFY_CHECKSUM;
 	/* mb[1] = ql12_risc_code_addr01; */
-	mb[1] = *ql1280_board_tbl[ha->devnum].fwstart;
+	mb[1] = ha->fwstart;
 	err = qla1280_mailbox_command(ha, BIT_1 | BIT_0, mb);
 	if (err) {
 		printk(KERN_ERR "scsi(%li): RISC checksum failed.\n", ha->host_no);
@@ -1796,7 +1827,7 @@ qla1280_start_firmware(struct scsi_qla_host *ha)
 	/* Start firmware execution. */
 	dprintk(1, "%s: start firmware running.\n", __func__);
 	mb[0] = MBC_EXECUTE_FIRMWARE;
-	mb[1] = *ql1280_board_tbl[ha->devnum].fwstart;
+	mb[1] = ha->fwstart;
 	err = qla1280_mailbox_command(ha, BIT_1 | BIT_0, &mb[0]);
 	if (err) {
 		printk(KERN_ERR "scsi(%li): Failed to start firmware\n",
@@ -4450,6 +4481,9 @@ module_exit(qla1280_exit);
 MODULE_AUTHOR("Qlogic & Jes Sorensen");
 MODULE_DESCRIPTION("Qlogic ISP SCSI (qla1x80/qla1x160) driver");
 MODULE_LICENSE("GPL");
+MODULE_FIRMWARE("qlogic/1040.bin");
+MODULE_FIRMWARE("qlogic/1280.bin");
+MODULE_FIRMWARE("qlogic/12160.bin");
 MODULE_VERSION(QLA1280_VERSION);
 
 /*

commit c3af1715928ce07300595b9e050728787f6a1718
Author: Nick Andrew <nick@nick-andrew.net>
Date:   Sat Jan 3 18:57:37 2009 +1100

    trivial: Fix misspelling of "firmware" in qla1280.c
    
    Fix misspelling of "firmware" in qla1280.c
    
    It's spelled "firmware".
    
    Signed-off-by: Nick Andrew <nick@nick-andrew.net>
    Signed-off-by: Jiri Kosina <jkosina@suse.cz>

diff --git a/drivers/scsi/qla1280.c b/drivers/scsi/qla1280.c
index 8cb9240596ab..df09820e8916 100644
--- a/drivers/scsi/qla1280.c
+++ b/drivers/scsi/qla1280.c
@@ -128,7 +128,7 @@
 	- Integrate ql12160_set_target_parameters() with 1280 version
 	- Make qla1280_setup() non static
 	- Do not call qla1280_check_for_dead_scsi_bus() on every I/O request
-	  sent to the card - this command pauses the firmare!!!
+	  sent to the card - this command pauses the firmware!!!
     Rev  3.23.15 Beta March 19, 2002, Jes Sorensen
 	- Clean up qla1280.h - remove obsolete QL_DEBUG_LEVEL_x definitions
 	- Remove a pile of pointless and confusing (srb_t **) and
@@ -659,7 +659,7 @@ static int qla1280_read_nvram(struct scsi_qla_host *ha)
 	/* The firmware interface is, um, interesting, in that the
 	 * actual firmware image on the chip is little endian, thus,
 	 * the process of taking that image to the CPU would end up
-	 * little endian.  However, the firmare interface requires it
+	 * little endian.  However, the firmware interface requires it
 	 * to be read a word (two bytes) at a time.
 	 *
 	 * The net result of this would be that the word (and

commit 25729a7fb88ef2912fcb869abe3a76b3be07fc06
Author: Arjan van de Ven <arjan@linux.intel.com>
Date:   Sun Sep 28 16:18:02 2008 -0700

    [SCSI] advansys, arcmsr, ipr, nsp32, qla1280, stex: use pci_ioremap_bar()
    
    Use the newly introduced pci_ioremap_bar() function in drivers/scsi.
    pci_ioremap_bar() just takes a pci device and a bar number, with the goal
    of making it really hard to get wrong, while also having a central place
    to stick sanity checks.
    
    Signed-off-by: Arjan van de Ven <arjan@linux.intel.com>
    Acked-by: Matthew Wilcox <willy@linux.intel.com>
    Cc: Brian King <brking@us.ibm.com>
    Cc: Ed Lin <ed.lin@promise.com>
    Cc: Nick Cheng <nick.cheng@areca.com.tw>
    Signed-off-by: James Bottomley <James.Bottomley@HansenPartnership.com>

diff --git a/drivers/scsi/qla1280.c b/drivers/scsi/qla1280.c
index b6cd12b2e996..8cb9240596ab 100644
--- a/drivers/scsi/qla1280.c
+++ b/drivers/scsi/qla1280.c
@@ -4294,8 +4294,7 @@ qla1280_probe_one(struct pci_dev *pdev, const struct pci_device_id *id)
 	error = -ENODEV;
 
 #if MEMORY_MAPPED_IO
-	ha->mmpbase = ioremap(pci_resource_start(ha->pdev, 1),
-			      pci_resource_len(ha->pdev, 1));
+	ha->mmpbase = pci_ioremap_bar(ha->pdev, 1);
 	if (!ha->mmpbase) {
 		printk(KERN_INFO "qla1280: Unable to map I/O memory\n");
 		goto error_free_response_ring;

commit 242f9dcb8ba6f68fcd217a119a7648a4f69290e9
Author: Jens Axboe <jens.axboe@oracle.com>
Date:   Sun Sep 14 05:55:09 2008 -0700

    block: unify request timeout handling
    
    Right now SCSI and others do their own command timeout handling.
    Move those bits to the block layer.
    
    Instead of having a timer per command, we try to be a bit more clever
    and simply have one per-queue. This avoids the overhead of having to
    tear down and setup a timer for each command, so it will result in a lot
    less timer fiddling.
    
    Signed-off-by: Mike Anderson <andmike@linux.vnet.ibm.com>
    Signed-off-by: Jens Axboe <jens.axboe@oracle.com>

diff --git a/drivers/scsi/qla1280.c b/drivers/scsi/qla1280.c
index 37f9ba0cd798..b6cd12b2e996 100644
--- a/drivers/scsi/qla1280.c
+++ b/drivers/scsi/qla1280.c
@@ -2845,7 +2845,7 @@ qla1280_64bit_start_scsi(struct scsi_qla_host *ha, struct srb * sp)
 	memset(((char *)pkt + 8), 0, (REQUEST_ENTRY_SIZE - 8));
 
 	/* Set ISP command timeout. */
-	pkt->timeout = cpu_to_le16(cmd->timeout_per_command/HZ);
+	pkt->timeout = cpu_to_le16(cmd->request->timeout/HZ);
 
 	/* Set device target ID and LUN */
 	pkt->lun = SCSI_LUN_32(cmd);
@@ -3114,7 +3114,7 @@ qla1280_32bit_start_scsi(struct scsi_qla_host *ha, struct srb * sp)
 	memset(((char *)pkt + 8), 0, (REQUEST_ENTRY_SIZE - 8));
 
 	/* Set ISP command timeout. */
-	pkt->timeout = cpu_to_le16(cmd->timeout_per_command/HZ);
+	pkt->timeout = cpu_to_le16(cmd->request->timeout/HZ);
 
 	/* Set device target ID and LUN */
 	pkt->lun = SCSI_LUN_32(cmd);

commit cadbd4a5e36dde7e6c49b587b2c419103c0b7218
Author: Harvey Harrison <harvey.harrison@gmail.com>
Date:   Thu Jul 3 23:47:27 2008 -0700

    [SCSI] replace __FUNCTION__ with __func__
    
    [jejb: fixed up a ton of missed conversions.
    
     All of you are on notice this has happened, driver trees will now
     need to be rebased]
    
    Signed-off-by: Harvey Harrison <harvey.harrison@gmail.com>
    Cc: SCSI List <linux-scsi@vger.kernel.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: James Bottomley <James.Bottomley@HansenPartnership.com>

diff --git a/drivers/scsi/qla1280.c b/drivers/scsi/qla1280.c
index 3754ab87f89a..37f9ba0cd798 100644
--- a/drivers/scsi/qla1280.c
+++ b/drivers/scsi/qla1280.c
@@ -1695,7 +1695,7 @@ qla1280_load_firmware_dma(struct scsi_qla_host *ha)
 	risc_code_size = *ql1280_board_tbl[ha->devnum].fwlen;
 
 	dprintk(1, "%s: DMA RISC code (%i) words\n",
-			__FUNCTION__, risc_code_size);
+			__func__, risc_code_size);
 
 	num = 0;
 	while (risc_code_size > 0) {
@@ -1721,7 +1721,7 @@ qla1280_load_firmware_dma(struct scsi_qla_host *ha)
 		mb[7] = pci_dma_hi32(ha->request_dma) & 0xffff;
 		mb[6] = pci_dma_hi32(ha->request_dma) >> 16;
 		dprintk(2, "%s: op=%d  0x%p = 0x%4x,0x%4x,0x%4x,0x%4x\n",
-				__FUNCTION__, mb[0],
+				__func__, mb[0],
 				(void *)(long)ha->request_dma,
 				mb[6], mb[7], mb[2], mb[3]);
 		err = qla1280_mailbox_command(ha, BIT_4 | BIT_3 | BIT_2 |
@@ -1753,10 +1753,10 @@ qla1280_load_firmware_dma(struct scsi_qla_host *ha)
 			if (tbuf[i] != sp[i] && warn++ < 10) {
 				printk(KERN_ERR "%s: FW compare error @ "
 						"byte(0x%x) loop#=%x\n",
-						__FUNCTION__, i, num);
+						__func__, i, num);
 				printk(KERN_ERR "%s: FWbyte=%x  "
 						"FWfromChip=%x\n",
-						__FUNCTION__, sp[i], tbuf[i]);
+						__func__, sp[i], tbuf[i]);
 				/*break; */
 			}
 		}
@@ -1781,7 +1781,7 @@ qla1280_start_firmware(struct scsi_qla_host *ha)
 	int err;
 
 	dprintk(1, "%s: Verifying checksum of loaded RISC code.\n",
-			__FUNCTION__);
+			__func__);
 
 	/* Verify checksum of loaded RISC code. */
 	mb[0] = MBC_VERIFY_CHECKSUM;
@@ -1794,7 +1794,7 @@ qla1280_start_firmware(struct scsi_qla_host *ha)
 	}
 
 	/* Start firmware execution. */
-	dprintk(1, "%s: start firmware running.\n", __FUNCTION__);
+	dprintk(1, "%s: start firmware running.\n", __func__);
 	mb[0] = MBC_EXECUTE_FIRMWARE;
 	mb[1] = *ql1280_board_tbl[ha->devnum].fwstart;
 	err = qla1280_mailbox_command(ha, BIT_1 | BIT_0, &mb[0]);

commit 9bcf091083065c751a4d90317b766370d2497ae9
Author: Harvey Harrison <harvey.harrison@gmail.com>
Date:   Thu May 22 15:45:07 2008 -0700

    scsi: fix integer as NULL pointer warning
    
    drivers/scsi/aha152x.c:3585:60: warning: Using plain integer as NULL pointer
    drivers/scsi/aha152x.c:3845:56: warning: Using plain integer as NULL pointer
    drivers/scsi/qla1280.c:2814:37: warning: Using plain integer as NULL pointer
    drivers/scsi/atp870u.c:750:47: warning: Using plain integer as NULL pointer
    drivers/scsi/3w-9xxx.c:1281:36: warning: Using plain integer as NULL pointer
    drivers/scsi/3w-9xxx.c:1293:36: warning: Using plain integer as NULL pointer
    drivers/scsi/3w-9xxx.c:1301:35: warning: Using plain integer as NULL pointer
    drivers/scsi/hptiop.c:447:10: warning: Using plain integer as NULL pointer
    drivers/scsi/hptiop.c:457:10: warning: Using plain integer as NULL pointer
    drivers/scsi/hptiop.c:479:24: warning: Using plain integer as NULL pointer
    drivers/scsi/hptiop.c:483:22: warning: Using plain integer as NULL pointer
    drivers/scsi/hptiop.c:1213:23: warning: Using plain integer as NULL pointer
    drivers/scsi/hptiop.c:1214:23: warning: Using plain integer as NULL pointer
    
    Signed-off-by: Harvey Harrison <harvey.harrison@gmail.com>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/scsi/qla1280.c b/drivers/scsi/qla1280.c
index 51e2f299dbbb..3754ab87f89a 100644
--- a/drivers/scsi/qla1280.c
+++ b/drivers/scsi/qla1280.c
@@ -2811,7 +2811,7 @@ qla1280_64bit_start_scsi(struct scsi_qla_host *ha, struct srb * sp)
 
 	/* Check for room in outstanding command list. */
 	for (cnt = 0; cnt < MAX_OUTSTANDING_COMMANDS &&
-		     ha->outstanding_cmds[cnt] != 0; cnt++);
+		     ha->outstanding_cmds[cnt] != NULL; cnt++);
 
 	if (cnt >= MAX_OUTSTANDING_COMMANDS) {
 		status = 1;

commit af5741c6de4f4a1d8608b0f00867c77cb7123635
Author: Jeremy Higdon <jeremy@sgi.com>
Date:   Sun May 11 23:17:03 2008 -0700

    [SCSI] qla1280: Fix queue depth problem
    
    The qla1280 driver was ANDing the output value of mailbox register
    0 with (1 << target-number) to determine whether to enable queueing
    on the target in question.
    
    But mailbox register 0 has the status code for the mailbox command
    (in this case, Set Target Parameters).  Potential values are:
    /*
     * ISP mailbox command complete status codes
     */
    
    So clearly that is in error.  I can't think what the author of that
    line was looking for in a mailbox register, so I just eliminated the
    AND.  flag is used later in the function, and I think that the later
    usage was also wrong, though it was used to set values that aren't
    used.  Oh well, an overhaul of this driver is not what I want to do
    now -- just a bugfix.
    
    After the fix, I found that my disks were getting a queue depth of
    255, which is far too many.  Most SCSI disks are limited to 32 or
    64.  In any case, there's no point, queueing up a bunch of commands
    to the adapter that will just result in queue full or starve other
    targets from being issued commands due to running out of internal
    memory.  So I dropped default queue depth to 32 (from which 1 is
    subtracted elsewhere, giving net of 31).
    
    I tested with a Seagate ST336753LC, and results look good, so
    I'm satisfied with this patch.
    
    Signed-off-by: Jeremy Higdon <jeremy@sgi.com>
    Acked-by: Jes Sorensen <jes@sgi.com>
    Cc: Stable Tree <stable@kernel.org>
    Signed-off-by: James Bottomley <James.Bottomley@HansenPartnership.com>

diff --git a/drivers/scsi/qla1280.c b/drivers/scsi/qla1280.c
index fa060932d2b4..51e2f299dbbb 100644
--- a/drivers/scsi/qla1280.c
+++ b/drivers/scsi/qla1280.c
@@ -2007,7 +2007,7 @@ qla1280_set_defaults(struct scsi_qla_host *ha)
 		nv->bus[bus].config_2.req_ack_active_negation = 1;
 		nv->bus[bus].config_2.data_line_active_negation = 1;
 		nv->bus[bus].selection_timeout = 250;
-		nv->bus[bus].max_queue_depth = 256;
+		nv->bus[bus].max_queue_depth = 32;
 
 		if (IS_ISP1040(ha)) {
 			nv->bus[bus].bus_reset_delay = 3;
@@ -2051,7 +2051,7 @@ qla1280_config_target(struct scsi_qla_host *ha, int bus, int target)
 	status = qla1280_mailbox_command(ha, 0x0f, mb);
 
 	/* Save Tag queuing enable flag. */
-	flag = (BIT_0 << target) & mb[0];
+	flag = (BIT_0 << target);
 	if (nv->bus[bus].target[target].parameter.tag_queuing)
 		ha->bus_settings[bus].qtag_enables |= flag;
 

commit 64a87b244b9297667ca80264aab849a36f494884
Author: Boaz Harrosh <bharrosh@panasas.com>
Date:   Wed Apr 30 11:19:47 2008 +0300

    [SCSI] Let scsi_cmnd->cmnd use request->cmd buffer
    
     - struct scsi_cmnd had a 16 bytes command buffer of its own.
       This is an unnecessary duplication and copy of request's
       cmd. It is probably left overs from the time that scsi_cmnd
       could function without a request attached. So clean that up.
    
     - Once above is done, few places, apart from scsi-ml, needed
       adjustments due to changing the data type of scsi_cmnd->cmnd.
    
     - Lots of drivers still use MAX_COMMAND_SIZE. So I have left
       that #define but equate it to BLK_MAX_CDB. The way I see it
       and is reflected in the patch below is.
       MAX_COMMAND_SIZE - means: The longest fixed-length (*) SCSI CDB
                          as per the SCSI standard and is not related
                          to the implementation.
       BLK_MAX_CDB.     - The allocated space at the request level
    
     - I have audit all ISA drivers and made sure none use ->cmnd in a DMA
       Operation. Same audit was done by Andi Kleen.
    
    (*)fixed-length here means commands that their size can be determined
       by their opcode and the CDB does not carry a length specifier, (unlike
       the VARIABLE_LENGTH_CMD(0x7f) command). This is actually not exactly
       true and the SCSI standard also defines extended commands and
       vendor specific commands that can be bigger than 16 bytes. The kernel
       will support these using the same infrastructure used for VARLEN CDB's.
       So in effect MAX_COMMAND_SIZE means the maximum size command
       scsi-ml supports without specifying a cmd_len by ULD's
    
    Signed-off-by: Boaz Harrosh <bharrosh@panasas.com>
    Signed-off-by: James Bottomley <James.Bottomley@HansenPartnership.com>

diff --git a/drivers/scsi/qla1280.c b/drivers/scsi/qla1280.c
index 09ab3eac1c1a..fa060932d2b4 100644
--- a/drivers/scsi/qla1280.c
+++ b/drivers/scsi/qla1280.c
@@ -2858,7 +2858,7 @@ qla1280_64bit_start_scsi(struct scsi_qla_host *ha, struct srb * sp)
 
 	/* Load SCSI command packet. */
 	pkt->cdb_len = cpu_to_le16(CMD_CDBLEN(cmd));
-	memcpy(pkt->scsi_cdb, &(CMD_CDBP(cmd)), CMD_CDBLEN(cmd));
+	memcpy(pkt->scsi_cdb, CMD_CDBP(cmd), CMD_CDBLEN(cmd));
 	/* dprintk(1, "Build packet for command[0]=0x%x\n",pkt->scsi_cdb[0]); */
 
 	/* Set transfer direction. */
@@ -3127,7 +3127,7 @@ qla1280_32bit_start_scsi(struct scsi_qla_host *ha, struct srb * sp)
 
 	/* Load SCSI command packet. */
 	pkt->cdb_len = cpu_to_le16(CMD_CDBLEN(cmd));
-	memcpy(pkt->scsi_cdb, &(CMD_CDBP(cmd)), CMD_CDBLEN(cmd));
+	memcpy(pkt->scsi_cdb, CMD_CDBP(cmd), CMD_CDBLEN(cmd));
 
 	/*dprintk(1, "Build packet for command[0]=0x%x\n",pkt->scsi_cdb[0]); */
 	/* Set transfer direction. */

commit 0e4ff797d7f2f2bb860b8f31dc5d1f2273b2f05a
Author: Adrian Bunk <bunk@kernel.org>
Date:   Thu Apr 17 12:37:01 2008 +0300

    [SCSI] qla1280: remove version check
    
    There's no point for an in-kernel driver to check whether it's compiled
    under kernel < 2.6.0 .
    
    Signed-off-by: Adrian Bunk <bunk@kernel.org>
    Cc: Jes Sorensen <jes@sgi.com>
    Signed-off-by: James Bottomley <James.Bottomley@HansenPartnership.com>

diff --git a/drivers/scsi/qla1280.c b/drivers/scsi/qla1280.c
index 68c0d09ffe78..09ab3eac1c1a 100644
--- a/drivers/scsi/qla1280.c
+++ b/drivers/scsi/qla1280.c
@@ -333,7 +333,6 @@
 
 #include <linux/module.h>
 
-#include <linux/version.h>
 #include <linux/types.h>
 #include <linux/string.h>
 #include <linux/errno.h>
@@ -367,10 +366,6 @@
 #include <asm/sn/io.h>
 #endif
 
-#if LINUX_VERSION_CODE < 0x020600
-#error "Kernels older than 2.6.0 are no longer supported"
-#endif
-
 
 /*
  * Compile time Options:

commit d3f46f39b7092594b498abc12f0c73b0b9913bde
Author: James Bottomley <James.Bottomley@HansenPartnership.com>
Date:   Tue Jan 15 11:11:46 2008 -0600

    [SCSI] remove use_sg_chaining
    
    With the sg table code, every SCSI driver is now either chain capable
    or broken (or has sg_tablesize set so chaining is never activated), so
    there's no need to have a check in the host template.
    
    Also tidy up the code by moving the scatterlist size defines into the
    SCSI includes and permit the last entry of the scatterlist pools not
    to be a power of two.
    Signed-off-by: James Bottomley <James.Bottomley@HansenPartnership.com>

diff --git a/drivers/scsi/qla1280.c b/drivers/scsi/qla1280.c
index c94906abfee3..68c0d09ffe78 100644
--- a/drivers/scsi/qla1280.c
+++ b/drivers/scsi/qla1280.c
@@ -4204,7 +4204,6 @@ static struct scsi_host_template qla1280_driver_template = {
 	.sg_tablesize		= SG_ALL,
 	.cmd_per_lun		= 1,
 	.use_clustering		= ENABLE_CLUSTERING,
-	.use_sg_chaining	= ENABLE_SG_CHAINING,
 };
 
 

commit b80ca4f7ee36c26d300c5a8f429e73372d153379
Author: FUJITA Tomonori <tomof@acm.org>
Date:   Sun Jan 13 15:46:13 2008 +0900

    [SCSI] replace sizeof sense_buffer with SCSI_SENSE_BUFFERSIZE
    
    This replaces sizeof sense_buffer with SCSI_SENSE_BUFFERSIZE in
    several LLDs. It's a preparation for the future changes to remove
    sense_buffer array in scsi_cmnd structure.
    
    Signed-off-by: FUJITA Tomonori <fujita.tomonori@lab.ntt.co.jp>
    Signed-off-by: James Bottomley <James.Bottomley@HansenPartnership.com>

diff --git a/drivers/scsi/qla1280.c b/drivers/scsi/qla1280.c
index 288640756099..c94906abfee3 100644
--- a/drivers/scsi/qla1280.c
+++ b/drivers/scsi/qla1280.c
@@ -528,7 +528,7 @@ __setup("qla1280=", qla1280_setup);
 #define	CMD_CDBLEN(Cmnd)	Cmnd->cmd_len
 #define	CMD_CDBP(Cmnd)		Cmnd->cmnd
 #define	CMD_SNSP(Cmnd)		Cmnd->sense_buffer
-#define	CMD_SNSLEN(Cmnd)	sizeof(Cmnd->sense_buffer)
+#define	CMD_SNSLEN(Cmnd)	SCSI_SENSE_BUFFERSIZE
 #define	CMD_RESULT(Cmnd)	Cmnd->result
 #define	CMD_HANDLE(Cmnd)	Cmnd->host_scribble
 #define CMD_REQUEST(Cmnd)	Cmnd->request->cmd
@@ -3715,7 +3715,7 @@ qla1280_status_entry(struct scsi_qla_host *ha, struct response *pkt,
 			} else
 				sense_sz = 0;
 			memset(cmd->sense_buffer + sense_sz, 0,
-			       sizeof(cmd->sense_buffer) - sense_sz);
+			       SCSI_SENSE_BUFFERSIZE - sense_sz);
 
 			dprintk(2, "qla1280_status_entry: Check "
 				"condition Sense data, b %i, t %i, "

commit 3a43e69ce50d467ded2f17f6e571e831d3677ab5
Author: FUJITA Tomonori <tomof@acm.org>
Date:   Tue Jan 8 23:07:01 2008 +0900

    [SCSI] qla1280: fix 32 bit segment code
    
    There's an error remaining in the 32 bit descriptor code after the
    conversion to dma accessors:  req_cnt is left uninitialised.
    
    qla1280_32bit_start_scsi gives the following warnings:
    
    drivers/scsi/qla1280.c: In function 'qla1280_32bit_start_scsi':
    drivers/scsi/qla1280.c:3044: warning: unused variable 'dma_handle'
    drivers/scsi/qla1280.c: In function 'qla1280_queuecommand':
    drivers/scsi/qla1280.c:3060: warning: 'req_cnt' is used uninitialized in this function
    drivers/scsi/qla1280.c:3042: note: 'req_cnt' was declared here
    
    Signed-off-by: FUJITA Tomonori <fujita.tomonori@lab.ntt.co.jp>
    Signed-off-by: James Bottomley <James.Bottomley@HansenPartnership.com>

diff --git a/drivers/scsi/qla1280.c b/drivers/scsi/qla1280.c
index 146d540f6281..288640756099 100644
--- a/drivers/scsi/qla1280.c
+++ b/drivers/scsi/qla1280.c
@@ -3041,7 +3041,6 @@ qla1280_32bit_start_scsi(struct scsi_qla_host *ha, struct srb * sp)
 	int cnt;
 	int req_cnt;
 	int seg_cnt;
-	dma_addr_t dma_handle;
 	u8 dir;
 
 	ENTER("qla1280_32bit_start_scsi");
@@ -3050,6 +3049,7 @@ qla1280_32bit_start_scsi(struct scsi_qla_host *ha, struct srb * sp)
 		cmd->cmnd[0]);
 
 	/* Calculate number of entries and segments required. */
+	req_cnt = 1;
 	seg_cnt = scsi_dma_map(cmd);
 	if (seg_cnt) {
 		/*

commit 5c1da582b3a95123ffb1e70ec7cd60e757c7c8c2
Author: Jes Sorensen <jes@sgi.com>
Date:   Fri Nov 9 14:40:41 2007 +0100

    [SCSI] qla1280: convert to use the data buffer accessors
    
    - remove the unnecessary map_single path.
    - convert to use the new accessors for the sg lists and the parameters.
    
    Fixed to missing initialization of sg lists before calling
    for_each_sg() by Jes Sorensen - sg list needs to be initialized before
    trying to pull the elements out of it.
    
    Signed-off-by: FUJITA Tomonori <fujita.tomonori@lab.ntt.co.jp>
    Signed-off-by: Jes Sorensen <jes@sgi.com>
    Signed-off-by: James Bottomley <James.Bottomley@HansenPartnership.com>

diff --git a/drivers/scsi/qla1280.c b/drivers/scsi/qla1280.c
index 3aeb68bcb7ac..146d540f6281 100644
--- a/drivers/scsi/qla1280.c
+++ b/drivers/scsi/qla1280.c
@@ -1310,14 +1310,7 @@ qla1280_done(struct scsi_qla_host *ha)
 		}
 
 		/* Release memory used for this I/O */
-		if (cmd->use_sg) {
-			pci_unmap_sg(ha->pdev, cmd->request_buffer,
-					cmd->use_sg, cmd->sc_data_direction);
-		} else if (cmd->request_bufflen) {
-			pci_unmap_single(ha->pdev, sp->saved_dma_handle,
-					cmd->request_bufflen,
-					cmd->sc_data_direction);
-		}
+		scsi_dma_unmap(cmd);
 
 		/* Call the mid-level driver interrupt handler */
 		CMD_HANDLE(sp->cmd) = (unsigned char *)INVALID_HANDLE;
@@ -1406,14 +1399,14 @@ qla1280_return_status(struct response * sts, struct scsi_cmnd *cp)
 		break;
 
 	case CS_DATA_UNDERRUN:
-		if ((cp->request_bufflen - residual_length) <
+		if ((scsi_bufflen(cp) - residual_length) <
 		    cp->underflow) {
 			printk(KERN_WARNING
 			       "scsi: Underflow detected - retrying "
 			       "command.\n");
 			host_status = DID_ERROR;
 		} else {
-			cp->resid = residual_length;
+			scsi_set_resid(cp, residual_length);
 			host_status = DID_OK;
 		}
 		break;
@@ -2775,33 +2768,28 @@ qla1280_64bit_start_scsi(struct scsi_qla_host *ha, struct srb * sp)
 	struct device_reg __iomem *reg = ha->iobase;
 	struct scsi_cmnd *cmd = sp->cmd;
 	cmd_a64_entry_t *pkt;
-	struct scatterlist *sg = NULL, *s;
 	__le32 *dword_ptr;
 	dma_addr_t dma_handle;
 	int status = 0;
 	int cnt;
 	int req_cnt;
-	u16 seg_cnt;
+	int seg_cnt;
 	u8 dir;
 
 	ENTER("qla1280_64bit_start_scsi:");
 
 	/* Calculate number of entries and segments required. */
 	req_cnt = 1;
-	if (cmd->use_sg) {
-		sg = (struct scatterlist *) cmd->request_buffer;
-		seg_cnt = pci_map_sg(ha->pdev, sg, cmd->use_sg,
-				     cmd->sc_data_direction);
-
+	seg_cnt = scsi_dma_map(cmd);
+	if (seg_cnt > 0) {
 		if (seg_cnt > 2) {
 			req_cnt += (seg_cnt - 2) / 5;
 			if ((seg_cnt - 2) % 5)
 				req_cnt++;
 		}
-	} else if (cmd->request_bufflen) {	/* If data transfer. */
-		seg_cnt = 1;
-	} else {
-		seg_cnt = 0;
+	} else if (seg_cnt < 0) {
+		status = 1;
+		goto out;
 	}
 
 	if ((req_cnt + 2) >= ha->req_q_cnt) {
@@ -2889,124 +2877,104 @@ qla1280_64bit_start_scsi(struct scsi_qla_host *ha, struct srb * sp)
 	 * Load data segments.
 	 */
 	if (seg_cnt) {	/* If data transfer. */
+		struct scatterlist *sg, *s;
 		int remseg = seg_cnt;
+
+		sg = scsi_sglist(cmd);
+
 		/* Setup packet address segment pointer. */
 		dword_ptr = (u32 *)&pkt->dseg_0_address;
 
-		if (cmd->use_sg) {	/* If scatter gather */
-			/* Load command entry data segments. */
-			for_each_sg(sg, s, seg_cnt, cnt) {
-				if (cnt == 2)
+		/* Load command entry data segments. */
+		for_each_sg(sg, s, seg_cnt, cnt) {
+			if (cnt == 2)
+				break;
+
+			dma_handle = sg_dma_address(s);
+#if defined(CONFIG_IA64_GENERIC) || defined(CONFIG_IA64_SGI_SN2)
+			if (ha->flags.use_pci_vchannel)
+				sn_pci_set_vchan(ha->pdev,
+						 (unsigned long *)&dma_handle,
+						 SCSI_BUS_32(cmd));
+#endif
+			*dword_ptr++ =
+				cpu_to_le32(pci_dma_lo32(dma_handle));
+			*dword_ptr++ =
+				cpu_to_le32(pci_dma_hi32(dma_handle));
+			*dword_ptr++ = cpu_to_le32(sg_dma_len(s));
+			dprintk(3, "S/G Segment phys_addr=%x %x, len=0x%x\n",
+				cpu_to_le32(pci_dma_hi32(dma_handle)),
+				cpu_to_le32(pci_dma_lo32(dma_handle)),
+				cpu_to_le32(sg_dma_len(sg_next(s))));
+			remseg--;
+		}
+		dprintk(5, "qla1280_64bit_start_scsi: Scatter/gather "
+			"command packet data - b %i, t %i, l %i \n",
+			SCSI_BUS_32(cmd), SCSI_TCN_32(cmd),
+			SCSI_LUN_32(cmd));
+		qla1280_dump_buffer(5, (char *)pkt,
+				    REQUEST_ENTRY_SIZE);
+
+		/*
+		 * Build continuation packets.
+		 */
+		dprintk(3, "S/G Building Continuation...seg_cnt=0x%x "
+			"remains\n", seg_cnt);
+
+		while (remseg > 0) {
+			/* Update sg start */
+			sg = s;
+			/* Adjust ring index. */
+			ha->req_ring_index++;
+			if (ha->req_ring_index == REQUEST_ENTRY_CNT) {
+				ha->req_ring_index = 0;
+				ha->request_ring_ptr =
+					ha->request_ring;
+			} else
+				ha->request_ring_ptr++;
+
+			pkt = (cmd_a64_entry_t *)ha->request_ring_ptr;
+
+			/* Zero out packet. */
+			memset(pkt, 0, REQUEST_ENTRY_SIZE);
+
+			/* Load packet defaults. */
+			((struct cont_a64_entry *) pkt)->entry_type =
+				CONTINUE_A64_TYPE;
+			((struct cont_a64_entry *) pkt)->entry_count = 1;
+			((struct cont_a64_entry *) pkt)->sys_define =
+				(uint8_t)ha->req_ring_index;
+			/* Setup packet address segment pointer. */
+			dword_ptr =
+				(u32 *)&((struct cont_a64_entry *) pkt)->dseg_0_address;
+
+			/* Load continuation entry data segments. */
+			for_each_sg(sg, s, remseg, cnt) {
+				if (cnt == 5)
 					break;
 				dma_handle = sg_dma_address(s);
 #if defined(CONFIG_IA64_GENERIC) || defined(CONFIG_IA64_SGI_SN2)
 				if (ha->flags.use_pci_vchannel)
 					sn_pci_set_vchan(ha->pdev,
-							(unsigned long *)&dma_handle,
+							 (unsigned long *)&dma_handle,
 							 SCSI_BUS_32(cmd));
 #endif
 				*dword_ptr++ =
 					cpu_to_le32(pci_dma_lo32(dma_handle));
 				*dword_ptr++ =
 					cpu_to_le32(pci_dma_hi32(dma_handle));
-				*dword_ptr++ = cpu_to_le32(sg_dma_len(s));
-				dprintk(3, "S/G Segment phys_addr=%x %x, len=0x%x\n",
+				*dword_ptr++ =
+					cpu_to_le32(sg_dma_len(s));
+				dprintk(3, "S/G Segment Cont. phys_addr=%x %x, len=0x%x\n",
 					cpu_to_le32(pci_dma_hi32(dma_handle)),
 					cpu_to_le32(pci_dma_lo32(dma_handle)),
-					cpu_to_le32(sg_dma_len(sg_next(s))));
-				remseg--;
+					cpu_to_le32(sg_dma_len(s)));
 			}
-			dprintk(5, "qla1280_64bit_start_scsi: Scatter/gather "
-				"command packet data - b %i, t %i, l %i \n",
-				SCSI_BUS_32(cmd), SCSI_TCN_32(cmd),
-				SCSI_LUN_32(cmd));
-			qla1280_dump_buffer(5, (char *)pkt,
-					    REQUEST_ENTRY_SIZE);
-
-			/*
-			 * Build continuation packets.
-			 */
-			dprintk(3, "S/G Building Continuation...seg_cnt=0x%x "
-				"remains\n", seg_cnt);
-
-			while (remseg > 0) {
-				/* Update sg start */
-				sg = s;
-				/* Adjust ring index. */
-				ha->req_ring_index++;
-				if (ha->req_ring_index == REQUEST_ENTRY_CNT) {
-					ha->req_ring_index = 0;
-					ha->request_ring_ptr =
-						ha->request_ring;
-				} else
-						ha->request_ring_ptr++;
-
-				pkt = (cmd_a64_entry_t *)ha->request_ring_ptr;
-
-				/* Zero out packet. */
-				memset(pkt, 0, REQUEST_ENTRY_SIZE);
-
-				/* Load packet defaults. */
-				((struct cont_a64_entry *) pkt)->entry_type =
-					CONTINUE_A64_TYPE;
-				((struct cont_a64_entry *) pkt)->entry_count = 1;
-				((struct cont_a64_entry *) pkt)->sys_define =
-					(uint8_t)ha->req_ring_index;
-				/* Setup packet address segment pointer. */
-				dword_ptr =
-					(u32 *)&((struct cont_a64_entry *) pkt)->dseg_0_address;
-
-				/* Load continuation entry data segments. */
-				for_each_sg(sg, s, remseg, cnt) {
-					if (cnt == 5)
-						break;
-					dma_handle = sg_dma_address(s);
-#if defined(CONFIG_IA64_GENERIC) || defined(CONFIG_IA64_SGI_SN2)
-				if (ha->flags.use_pci_vchannel)
-					sn_pci_set_vchan(ha->pdev, 
-							(unsigned long *)&dma_handle,
-							 SCSI_BUS_32(cmd));
-#endif
-					*dword_ptr++ =
-						cpu_to_le32(pci_dma_lo32(dma_handle));
-					*dword_ptr++ =
-						cpu_to_le32(pci_dma_hi32(dma_handle));
-					*dword_ptr++ =
-						cpu_to_le32(sg_dma_len(s));
-					dprintk(3, "S/G Segment Cont. phys_addr=%x %x, len=0x%x\n",
-						cpu_to_le32(pci_dma_hi32(dma_handle)),
-						cpu_to_le32(pci_dma_lo32(dma_handle)),
-						cpu_to_le32(sg_dma_len(s)));
-				}
-				remseg -= cnt;
-				dprintk(5, "qla1280_64bit_start_scsi: "
-					"continuation packet data - b %i, t "
-					"%i, l %i \n", SCSI_BUS_32(cmd),
-					SCSI_TCN_32(cmd), SCSI_LUN_32(cmd));
-				qla1280_dump_buffer(5, (char *)pkt,
-						    REQUEST_ENTRY_SIZE);
-			}
-		} else {	/* No scatter gather data transfer */
-			dma_handle = pci_map_single(ha->pdev,
-					cmd->request_buffer,
-					cmd->request_bufflen,
-					cmd->sc_data_direction);
-
-			sp->saved_dma_handle = dma_handle;
-#if defined(CONFIG_IA64_GENERIC) || defined(CONFIG_IA64_SGI_SN2)
-			if (ha->flags.use_pci_vchannel)
-				sn_pci_set_vchan(ha->pdev, 
-						(unsigned long *)&dma_handle,
-						 SCSI_BUS_32(cmd));
-#endif
-			*dword_ptr++ = cpu_to_le32(pci_dma_lo32(dma_handle));
-			*dword_ptr++ = cpu_to_le32(pci_dma_hi32(dma_handle));
-			*dword_ptr = cpu_to_le32(cmd->request_bufflen);
-
-			dprintk(5, "qla1280_64bit_start_scsi: No scatter/"
-				"gather command packet data - b %i, t %i, "
-				"l %i \n", SCSI_BUS_32(cmd), SCSI_TCN_32(cmd),
-				SCSI_LUN_32(cmd));
+			remseg -= cnt;
+			dprintk(5, "qla1280_64bit_start_scsi: "
+				"continuation packet data - b %i, t "
+				"%i, l %i \n", SCSI_BUS_32(cmd),
+				SCSI_TCN_32(cmd), SCSI_LUN_32(cmd));
 			qla1280_dump_buffer(5, (char *)pkt,
 					    REQUEST_ENTRY_SIZE);
 		}
@@ -3068,12 +3036,11 @@ qla1280_32bit_start_scsi(struct scsi_qla_host *ha, struct srb * sp)
 	struct device_reg __iomem *reg = ha->iobase;
 	struct scsi_cmnd *cmd = sp->cmd;
 	struct cmd_entry *pkt;
-	struct scatterlist *sg = NULL, *s;
 	__le32 *dword_ptr;
 	int status = 0;
 	int cnt;
 	int req_cnt;
-	uint16_t seg_cnt;
+	int seg_cnt;
 	dma_addr_t dma_handle;
 	u8 dir;
 
@@ -3083,18 +3050,8 @@ qla1280_32bit_start_scsi(struct scsi_qla_host *ha, struct srb * sp)
 		cmd->cmnd[0]);
 
 	/* Calculate number of entries and segments required. */
-	req_cnt = 1;
-	if (cmd->use_sg) {
-		/*
-		 * We must build an SG list in adapter format, as the kernel's
-		 * SG list cannot be used directly because of data field size
-		 * (__alpha__) differences and the kernel SG list uses virtual
-		 * addresses where we need physical addresses.
-		 */
-		sg = (struct scatterlist *) cmd->request_buffer;
-		seg_cnt = pci_map_sg(ha->pdev, sg, cmd->use_sg,
-				     cmd->sc_data_direction);
-
+	seg_cnt = scsi_dma_map(cmd);
+	if (seg_cnt) {
 		/*
 		 * if greater than four sg entries then we need to allocate
 		 * continuation entries
@@ -3106,14 +3063,9 @@ qla1280_32bit_start_scsi(struct scsi_qla_host *ha, struct srb * sp)
 		}
 		dprintk(3, "S/G Transfer cmd=%p seg_cnt=0x%x, req_cnt=%x\n",
 			cmd, seg_cnt, req_cnt);
-	} else if (cmd->request_bufflen) {	/* If data transfer. */
-		dprintk(3, "No S/G transfer t=%x cmd=%p len=%x CDB=%x\n",
-			SCSI_TCN_32(cmd), cmd, cmd->request_bufflen,
-			cmd->cmnd[0]);
-		seg_cnt = 1;
-	} else {
-		/* dprintk(1, "No data transfer \n"); */
-		seg_cnt = 0;
+	} else if (seg_cnt < 0) {
+		status = 1;
+		goto out;
 	}
 
 	if ((req_cnt + 2) >= ha->req_q_cnt) {
@@ -3194,91 +3146,84 @@ qla1280_32bit_start_scsi(struct scsi_qla_host *ha, struct srb * sp)
 	 * Load data segments.
 	 */
 	if (seg_cnt) {
+		struct scatterlist *sg, *s;
 		int remseg = seg_cnt;
+
+		sg = scsi_sglist(cmd);
+
 		/* Setup packet address segment pointer. */
 		dword_ptr = &pkt->dseg_0_address;
 
-		if (cmd->use_sg) {	/* If scatter gather */
-			dprintk(3, "Building S/G data segments..\n");
-			qla1280_dump_buffer(1, (char *)sg, 4 * 16);
+		dprintk(3, "Building S/G data segments..\n");
+		qla1280_dump_buffer(1, (char *)sg, 4 * 16);
+
+		/* Load command entry data segments. */
+		for_each_sg(sg, s, seg_cnt, cnt) {
+			if (cnt == 4)
+				break;
+			*dword_ptr++ =
+				cpu_to_le32(pci_dma_lo32(sg_dma_address(s)));
+			*dword_ptr++ = cpu_to_le32(sg_dma_len(s));
+			dprintk(3, "S/G Segment phys_addr=0x%lx, len=0x%x\n",
+				(pci_dma_lo32(sg_dma_address(s))),
+				(sg_dma_len(s)));
+			remseg--;
+		}
+		/*
+		 * Build continuation packets.
+		 */
+		dprintk(3, "S/G Building Continuation"
+			"...seg_cnt=0x%x remains\n", seg_cnt);
+		while (remseg > 0) {
+			/* Continue from end point */
+			sg = s;
+			/* Adjust ring index. */
+			ha->req_ring_index++;
+			if (ha->req_ring_index == REQUEST_ENTRY_CNT) {
+				ha->req_ring_index = 0;
+				ha->request_ring_ptr =
+					ha->request_ring;
+			} else
+				ha->request_ring_ptr++;
+
+			pkt = (struct cmd_entry *)ha->request_ring_ptr;
+
+			/* Zero out packet. */
+			memset(pkt, 0, REQUEST_ENTRY_SIZE);
+
+			/* Load packet defaults. */
+			((struct cont_entry *) pkt)->
+				entry_type = CONTINUE_TYPE;
+			((struct cont_entry *) pkt)->entry_count = 1;
 
-			/* Load command entry data segments. */
-			for_each_sg(sg, s, seg_cnt, cnt) {
-				if (cnt == 4)
+			((struct cont_entry *) pkt)->sys_define =
+				(uint8_t) ha->req_ring_index;
+
+			/* Setup packet address segment pointer. */
+			dword_ptr =
+				&((struct cont_entry *) pkt)->dseg_0_address;
+
+			/* Load continuation entry data segments. */
+			for_each_sg(sg, s, remseg, cnt) {
+				if (cnt == 7)
 					break;
 				*dword_ptr++ =
 					cpu_to_le32(pci_dma_lo32(sg_dma_address(s)));
-				*dword_ptr++ = cpu_to_le32(sg_dma_len(s));
-				dprintk(3, "S/G Segment phys_addr=0x%lx, len=0x%x\n",
-					(pci_dma_lo32(sg_dma_address(s))),
-					(sg_dma_len(s)));
-				remseg--;
-			}
-			/*
-			 * Build continuation packets.
-			 */
-			dprintk(3, "S/G Building Continuation"
-				"...seg_cnt=0x%x remains\n", seg_cnt);
-			while (remseg > 0) {
-				/* Continue from end point */
-				sg = s;
-				/* Adjust ring index. */
-				ha->req_ring_index++;
-				if (ha->req_ring_index == REQUEST_ENTRY_CNT) {
-					ha->req_ring_index = 0;
-					ha->request_ring_ptr =
-						ha->request_ring;
-				} else
-					ha->request_ring_ptr++;
-
-				pkt = (struct cmd_entry *)ha->request_ring_ptr;
-
-				/* Zero out packet. */
-				memset(pkt, 0, REQUEST_ENTRY_SIZE);
-
-				/* Load packet defaults. */
-				((struct cont_entry *) pkt)->
-					entry_type = CONTINUE_TYPE;
-				((struct cont_entry *) pkt)->entry_count = 1;
-
-				((struct cont_entry *) pkt)->sys_define =
-					(uint8_t) ha->req_ring_index;
-
-				/* Setup packet address segment pointer. */
-				dword_ptr =
-					&((struct cont_entry *) pkt)->dseg_0_address;
-
-				/* Load continuation entry data segments. */
-				for_each_sg(sg, s, remseg, cnt) {
-					if (cnt == 7)
-						break;
-					*dword_ptr++ =
-						cpu_to_le32(pci_dma_lo32(sg_dma_address(s)));
-					*dword_ptr++ =
-						cpu_to_le32(sg_dma_len(s));
-					dprintk(1,
-						"S/G Segment Cont. phys_addr=0x%x, "
-						"len=0x%x\n",
-						cpu_to_le32(pci_dma_lo32(sg_dma_address(s))),
-						cpu_to_le32(sg_dma_len(s)));
-				}
-				remseg -= cnt;
-				dprintk(5, "qla1280_32bit_start_scsi: "
-					"continuation packet data - "
-					"scsi(%i:%i:%i)\n", SCSI_BUS_32(cmd),
-					SCSI_TCN_32(cmd), SCSI_LUN_32(cmd));
-				qla1280_dump_buffer(5, (char *)pkt,
-						    REQUEST_ENTRY_SIZE);
+				*dword_ptr++ =
+					cpu_to_le32(sg_dma_len(s));
+				dprintk(1,
+					"S/G Segment Cont. phys_addr=0x%x, "
+					"len=0x%x\n",
+					cpu_to_le32(pci_dma_lo32(sg_dma_address(s))),
+					cpu_to_le32(sg_dma_len(s)));
 			}
-		} else {	/* No S/G data transfer */
-			dma_handle = pci_map_single(ha->pdev,
-					cmd->request_buffer,
-					cmd->request_bufflen,
-					cmd->sc_data_direction);
-			sp->saved_dma_handle = dma_handle;
-
-			*dword_ptr++ = cpu_to_le32(pci_dma_lo32(dma_handle));
-			*dword_ptr = cpu_to_le32(cmd->request_bufflen);
+			remseg -= cnt;
+			dprintk(5, "qla1280_32bit_start_scsi: "
+				"continuation packet data - "
+				"scsi(%i:%i:%i)\n", SCSI_BUS_32(cmd),
+				SCSI_TCN_32(cmd), SCSI_LUN_32(cmd));
+			qla1280_dump_buffer(5, (char *)pkt,
+					    REQUEST_ENTRY_SIZE);
 		}
 	} else {	/* No data transfer at all */
 		dprintk(5, "qla1280_32bit_start_scsi: No data, command "
@@ -4086,9 +4031,9 @@ __qla1280_print_scsi_cmd(struct scsi_cmnd *cmd)
 	for (i = 0; i < cmd->cmd_len; i++) {
 		printk("0x%02x ", cmd->cmnd[i]);
 	}
-	printk("  seg_cnt =%d\n", cmd->use_sg);
+	printk("  seg_cnt =%d\n", scsi_sg_count(cmd));
 	printk("  request buffer=0x%p, request buffer len=0x%x\n",
-	       cmd->request_buffer, cmd->request_bufflen);
+	       scsi_sglist(cmd), scsi_bufflen(cmd));
 	/* if (cmd->use_sg)
 	   {
 	   sg = (struct scatterlist *) cmd->request_buffer;

commit eb7a1698d24783dd215cb86a12cadebe9b4e7046
Author: Johannes Dickgreber <tanzy@gmx.de>
Date:   Wed Oct 3 13:22:19 2007 +0200

    [SCSI] qla1280: uses wrong failure path after failed pci_set_dma_mask
    
    A failure here wouldn't currently free the irq; go to the irq free
    path instead.
    
    Signed-off-by: Johannes Dickgreber <tanzy@gmx.de>
    Acked-by: Jes Sorensen <jes@sgi.com>
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>

diff --git a/drivers/scsi/qla1280.c b/drivers/scsi/qla1280.c
index 76089cf55f4e..3aeb68bcb7ac 100644
--- a/drivers/scsi/qla1280.c
+++ b/drivers/scsi/qla1280.c
@@ -4310,7 +4310,7 @@ qla1280_probe_one(struct pci_dev *pdev, const struct pci_device_id *id)
 			printk(KERN_WARNING "scsi(%li): Unable to set a "
 			       "suitable DMA mask - aborting\n", ha->host_no);
 			error = -ENODEV;
-			goto error_free_irq;
+			goto error_put_host;
 		}
 	} else
 		dprintk(2, "scsi(%li): 64 Bit PCI Addressing Enabled\n",
@@ -4320,7 +4320,7 @@ qla1280_probe_one(struct pci_dev *pdev, const struct pci_device_id *id)
 		printk(KERN_WARNING "scsi(%li): Unable to set a "
 		       "suitable DMA mask - aborting\n", ha->host_no);
 		error = -ENODEV;
-		goto error_free_irq;
+		goto error_put_host;
 	}
 #endif
 

commit 633ed113d477c1a8c77d5fe3574c410ea52f58cc
Author: FUJITA Tomonori <fujita.tomonori@lab.ntt.co.jp>
Date:   Mon Sep 17 15:28:22 2007 +0200

    qla1280: enable use_sg_chaining option
    
    Signed-off-by: FUJITA Tomonori <fujita.tomonori@lab.ntt.co.jp>
    Signed-off-by: Jens Axboe <jens.axboe@oracle.com>

diff --git a/drivers/scsi/qla1280.c b/drivers/scsi/qla1280.c
index 5cc23f8f370a..76089cf55f4e 100644
--- a/drivers/scsi/qla1280.c
+++ b/drivers/scsi/qla1280.c
@@ -4259,6 +4259,7 @@ static struct scsi_host_template qla1280_driver_template = {
 	.sg_tablesize		= SG_ALL,
 	.cmd_per_lun		= 1,
 	.use_clustering		= ENABLE_CLUSTERING,
+	.use_sg_chaining	= ENABLE_SG_CHAINING,
 };
 
 

commit c0dcffd71d5064efefa620231152c38eca8e066b
Author: FUJITA Tomonori <fujita.tomonori@lab.ntt.co.jp>
Date:   Mon Sep 10 04:17:13 2007 +0100

    qla1280: sg chaining fixes
    
    Signed-off-by: FUJITA Tomonori <fujita.tomonori@lab.ntt.co.jp>
    Signed-off-by: Jens Axboe <jens.axboe@oracle.com>

diff --git a/drivers/scsi/qla1280.c b/drivers/scsi/qla1280.c
index 1f17dec7d6fc..5cc23f8f370a 100644
--- a/drivers/scsi/qla1280.c
+++ b/drivers/scsi/qla1280.c
@@ -2977,8 +2977,8 @@ qla1280_64bit_start_scsi(struct scsi_qla_host *ha, struct srb * sp)
 						cpu_to_le32(pci_dma_hi32(dma_handle)),
 						cpu_to_le32(pci_dma_lo32(dma_handle)),
 						cpu_to_le32(sg_dma_len(s)));
-					remseg--;
 				}
+				remseg -= cnt;
 				dprintk(5, "qla1280_64bit_start_scsi: "
 					"continuation packet data - b %i, t "
 					"%i, l %i \n", SCSI_BUS_32(cmd),
@@ -3250,6 +3250,8 @@ qla1280_32bit_start_scsi(struct scsi_qla_host *ha, struct srb * sp)
 
 				/* Load continuation entry data segments. */
 				for_each_sg(sg, s, remseg, cnt) {
+					if (cnt == 7)
+						break;
 					*dword_ptr++ =
 						cpu_to_le32(pci_dma_lo32(sg_dma_address(s)));
 					*dword_ptr++ =
@@ -3260,6 +3262,7 @@ qla1280_32bit_start_scsi(struct scsi_qla_host *ha, struct srb * sp)
 						cpu_to_le32(pci_dma_lo32(sg_dma_address(s))),
 						cpu_to_le32(sg_dma_len(s)));
 				}
+				remseg -= cnt;
 				dprintk(5, "qla1280_32bit_start_scsi: "
 					"continuation packet data - "
 					"scsi(%i:%i:%i)\n", SCSI_BUS_32(cmd),

commit a0441891373fe2db582075a4639fdfcccea470c1
Author: Jens Axboe <jens.axboe@oracle.com>
Date:   Wed May 9 13:02:43 2007 +0200

    qla1280: sg chaining support
    
    Interesting hardware setup...
    
    Signed-off-by: Jens Axboe <jens.axboe@oracle.com>

diff --git a/drivers/scsi/qla1280.c b/drivers/scsi/qla1280.c
index fba8aa8a81b5..1f17dec7d6fc 100644
--- a/drivers/scsi/qla1280.c
+++ b/drivers/scsi/qla1280.c
@@ -2775,7 +2775,7 @@ qla1280_64bit_start_scsi(struct scsi_qla_host *ha, struct srb * sp)
 	struct device_reg __iomem *reg = ha->iobase;
 	struct scsi_cmnd *cmd = sp->cmd;
 	cmd_a64_entry_t *pkt;
-	struct scatterlist *sg = NULL;
+	struct scatterlist *sg = NULL, *s;
 	__le32 *dword_ptr;
 	dma_addr_t dma_handle;
 	int status = 0;
@@ -2889,13 +2889,16 @@ qla1280_64bit_start_scsi(struct scsi_qla_host *ha, struct srb * sp)
 	 * Load data segments.
 	 */
 	if (seg_cnt) {	/* If data transfer. */
+		int remseg = seg_cnt;
 		/* Setup packet address segment pointer. */
 		dword_ptr = (u32 *)&pkt->dseg_0_address;
 
 		if (cmd->use_sg) {	/* If scatter gather */
 			/* Load command entry data segments. */
-			for (cnt = 0; cnt < 2 && seg_cnt; cnt++, seg_cnt--) {
-				dma_handle = sg_dma_address(sg);
+			for_each_sg(sg, s, seg_cnt, cnt) {
+				if (cnt == 2)
+					break;
+				dma_handle = sg_dma_address(s);
 #if defined(CONFIG_IA64_GENERIC) || defined(CONFIG_IA64_SGI_SN2)
 				if (ha->flags.use_pci_vchannel)
 					sn_pci_set_vchan(ha->pdev,
@@ -2906,12 +2909,12 @@ qla1280_64bit_start_scsi(struct scsi_qla_host *ha, struct srb * sp)
 					cpu_to_le32(pci_dma_lo32(dma_handle));
 				*dword_ptr++ =
 					cpu_to_le32(pci_dma_hi32(dma_handle));
-				*dword_ptr++ = cpu_to_le32(sg_dma_len(sg));
-				sg++;
+				*dword_ptr++ = cpu_to_le32(sg_dma_len(s));
 				dprintk(3, "S/G Segment phys_addr=%x %x, len=0x%x\n",
 					cpu_to_le32(pci_dma_hi32(dma_handle)),
 					cpu_to_le32(pci_dma_lo32(dma_handle)),
-					cpu_to_le32(sg_dma_len(sg)));
+					cpu_to_le32(sg_dma_len(sg_next(s))));
+				remseg--;
 			}
 			dprintk(5, "qla1280_64bit_start_scsi: Scatter/gather "
 				"command packet data - b %i, t %i, l %i \n",
@@ -2926,7 +2929,9 @@ qla1280_64bit_start_scsi(struct scsi_qla_host *ha, struct srb * sp)
 			dprintk(3, "S/G Building Continuation...seg_cnt=0x%x "
 				"remains\n", seg_cnt);
 
-			while (seg_cnt > 0) {
+			while (remseg > 0) {
+				/* Update sg start */
+				sg = s;
 				/* Adjust ring index. */
 				ha->req_ring_index++;
 				if (ha->req_ring_index == REQUEST_ENTRY_CNT) {
@@ -2952,9 +2957,10 @@ qla1280_64bit_start_scsi(struct scsi_qla_host *ha, struct srb * sp)
 					(u32 *)&((struct cont_a64_entry *) pkt)->dseg_0_address;
 
 				/* Load continuation entry data segments. */
-				for (cnt = 0; cnt < 5 && seg_cnt;
-				     cnt++, seg_cnt--) {
-					dma_handle = sg_dma_address(sg);
+				for_each_sg(sg, s, remseg, cnt) {
+					if (cnt == 5)
+						break;
+					dma_handle = sg_dma_address(s);
 #if defined(CONFIG_IA64_GENERIC) || defined(CONFIG_IA64_SGI_SN2)
 				if (ha->flags.use_pci_vchannel)
 					sn_pci_set_vchan(ha->pdev, 
@@ -2966,12 +2972,12 @@ qla1280_64bit_start_scsi(struct scsi_qla_host *ha, struct srb * sp)
 					*dword_ptr++ =
 						cpu_to_le32(pci_dma_hi32(dma_handle));
 					*dword_ptr++ =
-						cpu_to_le32(sg_dma_len(sg));
+						cpu_to_le32(sg_dma_len(s));
 					dprintk(3, "S/G Segment Cont. phys_addr=%x %x, len=0x%x\n",
 						cpu_to_le32(pci_dma_hi32(dma_handle)),
 						cpu_to_le32(pci_dma_lo32(dma_handle)),
-						cpu_to_le32(sg_dma_len(sg)));
-					sg++;
+						cpu_to_le32(sg_dma_len(s)));
+					remseg--;
 				}
 				dprintk(5, "qla1280_64bit_start_scsi: "
 					"continuation packet data - b %i, t "
@@ -3062,7 +3068,7 @@ qla1280_32bit_start_scsi(struct scsi_qla_host *ha, struct srb * sp)
 	struct device_reg __iomem *reg = ha->iobase;
 	struct scsi_cmnd *cmd = sp->cmd;
 	struct cmd_entry *pkt;
-	struct scatterlist *sg = NULL;
+	struct scatterlist *sg = NULL, *s;
 	__le32 *dword_ptr;
 	int status = 0;
 	int cnt;
@@ -3188,6 +3194,7 @@ qla1280_32bit_start_scsi(struct scsi_qla_host *ha, struct srb * sp)
 	 * Load data segments.
 	 */
 	if (seg_cnt) {
+		int remseg = seg_cnt;
 		/* Setup packet address segment pointer. */
 		dword_ptr = &pkt->dseg_0_address;
 
@@ -3196,22 +3203,25 @@ qla1280_32bit_start_scsi(struct scsi_qla_host *ha, struct srb * sp)
 			qla1280_dump_buffer(1, (char *)sg, 4 * 16);
 
 			/* Load command entry data segments. */
-			for (cnt = 0; cnt < 4 && seg_cnt; cnt++, seg_cnt--) {
+			for_each_sg(sg, s, seg_cnt, cnt) {
+				if (cnt == 4)
+					break;
 				*dword_ptr++ =
-					cpu_to_le32(pci_dma_lo32(sg_dma_address(sg)));
-				*dword_ptr++ =
-					cpu_to_le32(sg_dma_len(sg));
+					cpu_to_le32(pci_dma_lo32(sg_dma_address(s)));
+				*dword_ptr++ = cpu_to_le32(sg_dma_len(s));
 				dprintk(3, "S/G Segment phys_addr=0x%lx, len=0x%x\n",
-					(pci_dma_lo32(sg_dma_address(sg))),
-					(sg_dma_len(sg)));
-				sg++;
+					(pci_dma_lo32(sg_dma_address(s))),
+					(sg_dma_len(s)));
+				remseg--;
 			}
 			/*
 			 * Build continuation packets.
 			 */
 			dprintk(3, "S/G Building Continuation"
 				"...seg_cnt=0x%x remains\n", seg_cnt);
-			while (seg_cnt > 0) {
+			while (remseg > 0) {
+				/* Continue from end point */
+				sg = s;
 				/* Adjust ring index. */
 				ha->req_ring_index++;
 				if (ha->req_ring_index == REQUEST_ENTRY_CNT) {
@@ -3239,18 +3249,16 @@ qla1280_32bit_start_scsi(struct scsi_qla_host *ha, struct srb * sp)
 					&((struct cont_entry *) pkt)->dseg_0_address;
 
 				/* Load continuation entry data segments. */
-				for (cnt = 0; cnt < 7 && seg_cnt;
-				     cnt++, seg_cnt--) {
+				for_each_sg(sg, s, remseg, cnt) {
 					*dword_ptr++ =
-						cpu_to_le32(pci_dma_lo32(sg_dma_address(sg)));
+						cpu_to_le32(pci_dma_lo32(sg_dma_address(s)));
 					*dword_ptr++ =
-						cpu_to_le32(sg_dma_len(sg));
+						cpu_to_le32(sg_dma_len(s));
 					dprintk(1,
 						"S/G Segment Cont. phys_addr=0x%x, "
 						"len=0x%x\n",
-						cpu_to_le32(pci_dma_lo32(sg_dma_address(sg))),
-						cpu_to_le32(sg_dma_len(sg)));
-					sg++;
+						cpu_to_le32(pci_dma_lo32(sg_dma_address(s))),
+						cpu_to_le32(sg_dma_len(s)));
 				}
 				dprintk(5, "qla1280_32bit_start_scsi: "
 					"continuation packet data - "

commit 12a441622b753684cc73d1c6f225e9ac53e0bf77
Author: Matthew Wilcox <matthew@wil.cx>
Date:   Tue Sep 18 19:54:43 2007 -0600

    [SCSI] Remove ->pid field from scsi_cmnd
    
    The pid field is a duplicate of the serial_number field and has been
    scheduled for removal for a long time.  A few drivers were still using
    it, so just change them to use serial_number instead.
    
    Signed-off-by: Matthew Wilcox <willy@linux.intel.com>
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>

diff --git a/drivers/scsi/qla1280.c b/drivers/scsi/qla1280.c
index 54d8bdf86852..fba8aa8a81b5 100644
--- a/drivers/scsi/qla1280.c
+++ b/drivers/scsi/qla1280.c
@@ -4086,7 +4086,7 @@ __qla1280_print_scsi_cmd(struct scsi_cmnd *cmd)
 	   } */
 	printk("  tag=%d, transfersize=0x%x \n",
 	       cmd->tag, cmd->transfersize);
-	printk("  Pid=%li, SP=0x%p\n", cmd->pid, CMD_SP(cmd));
+	printk("  Pid=%li, SP=0x%p\n", cmd->serial_number, CMD_SP(cmd));
 	printk(" underflow size = 0x%x, direction=0x%x\n",
 	       cmd->underflow, cmd->sc_data_direction);
 }

commit b22c9d9bc214d602647c3f94e6072655c36a61db
Author: Matthias Kaehlcke <matthias.kaehlcke@gmail.com>
Date:   Tue Apr 17 09:58:36 2007 +0200

    [SCSI] qla1280: use DMA_64BIT_MASK instead of ~ 0ULL
    
    QLA1280: call pci_set_dma_mask with DMA_64BIT_MASK instead of  ~ 0ULL
    
    Signed-off-by: Matthias Kaehlcke <matthias.kaehlcke@gmail.com>
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>

diff --git a/drivers/scsi/qla1280.c b/drivers/scsi/qla1280.c
index 6777e8a69153..54d8bdf86852 100644
--- a/drivers/scsi/qla1280.c
+++ b/drivers/scsi/qla1280.c
@@ -4293,7 +4293,7 @@ qla1280_probe_one(struct pci_dev *pdev, const struct pci_device_id *id)
 	ha->devnum = devnum;	/* specifies microcode load address */
 
 #ifdef QLA_64BIT_PTR
-	if (pci_set_dma_mask(ha->pdev, (dma_addr_t) ~ 0ULL)) {
+	if (pci_set_dma_mask(ha->pdev, DMA_64BIT_MASK)) {
 		if (pci_set_dma_mask(ha->pdev, DMA_32BIT_MASK)) {
 			printk(KERN_WARNING "scsi(%li): Unable to set a "
 			       "suitable DMA mask - aborting\n", ha->host_no);

commit cd354f1ae75e6466a7e31b727faede57a1f89ca5
Author: Tim Schmielau <tim@physik3.uni-rostock.de>
Date:   Wed Feb 14 00:33:14 2007 -0800

    [PATCH] remove many unneeded #includes of sched.h
    
    After Al Viro (finally) succeeded in removing the sched.h #include in module.h
    recently, it makes sense again to remove other superfluous sched.h includes.
    There are quite a lot of files which include it but don't actually need
    anything defined in there.  Presumably these includes were once needed for
    macros that used to live in sched.h, but moved to other header files in the
    course of cleaning it up.
    
    To ease the pain, this time I did not fiddle with any header files and only
    removed #includes from .c-files, which tend to cause less trouble.
    
    Compile tested against 2.6.20-rc2 and 2.6.20-rc2-mm2 (with offsets) on alpha,
    arm, i386, ia64, mips, powerpc, and x86_64 with allnoconfig, defconfig,
    allmodconfig, and allyesconfig as well as a few randconfigs on x86_64 and all
    configs in arch/arm/configs on arm.  I also checked that no new warnings were
    introduced by the patch (actually, some warnings are removed that were emitted
    by unnecessarily included header files).
    
    Signed-off-by: Tim Schmielau <tim@physik3.uni-rostock.de>
    Acked-by: Russell King <rmk+kernel@arm.linux.org.uk>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/scsi/qla1280.c b/drivers/scsi/qla1280.c
index 1548d42a3b43..6777e8a69153 100644
--- a/drivers/scsi/qla1280.c
+++ b/drivers/scsi/qla1280.c
@@ -341,7 +341,6 @@
 #include <linux/ioport.h>
 #include <linux/delay.h>
 #include <linux/timer.h>
-#include <linux/sched.h>
 #include <linux/pci.h>
 #include <linux/proc_fs.h>
 #include <linux/stat.h>

commit 3ef49a3b45c33b055002402f01e5da98cb773086
Author: Jes Sorensen <jes@sgi.com>
Date:   Fri Jan 5 12:05:37 2007 -0500

    [SCSI] qla1280: set residual correctly
    
    Jeremy caught a bug in the qla1280 driver where it didn't set the
    residual value correctly.
    
    Signed-off-by: Jeremy Higdon <jeremy@sgi.com>
    Signed-off-by: Jes Sorensen <jes@sgi.com>
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>

diff --git a/drivers/scsi/qla1280.c b/drivers/scsi/qla1280.c
index 16af5b79e587..1548d42a3b43 100644
--- a/drivers/scsi/qla1280.c
+++ b/drivers/scsi/qla1280.c
@@ -1341,7 +1341,7 @@ qla1280_return_status(struct response * sts, struct scsi_cmnd *cp)
 	int host_status = DID_ERROR;
 	uint16_t comp_status = le16_to_cpu(sts->comp_status);
 	uint16_t state_flags = le16_to_cpu(sts->state_flags);
-	uint16_t residual_length = le32_to_cpu(sts->residual_length);
+	uint32_t residual_length = le32_to_cpu(sts->residual_length);
 	uint16_t scsi_status = le16_to_cpu(sts->scsi_status);
 #if DEBUG_QLA1280_INTR
 	static char *reason[] = {
@@ -1413,8 +1413,10 @@ qla1280_return_status(struct response * sts, struct scsi_cmnd *cp)
 			       "scsi: Underflow detected - retrying "
 			       "command.\n");
 			host_status = DID_ERROR;
-		} else
+		} else {
+			cp->resid = residual_length;
 			host_status = DID_OK;
+		}
 		break;
 
 	default:

commit cd00b7f5d814ba87b36371f122ce36ba4a88ba69
Author: Jes Sorensen <jes@sgi.com>
Date:   Tue Oct 17 09:32:06 2006 -0400

    [SCSI] qla1280 bus reset typo
    
    Fix typo in check of return value of qla1280_bus_reset() which would
    result in an adapter reset in addition to the bus reset.
    
    Signed-off-by: Jes Sorensen <jes@sgi.com>
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>

diff --git a/drivers/scsi/qla1280.c b/drivers/scsi/qla1280.c
index 2521d548dd59..16af5b79e587 100644
--- a/drivers/scsi/qla1280.c
+++ b/drivers/scsi/qla1280.c
@@ -931,11 +931,10 @@ qla1280_error_action(struct scsi_cmnd *cmd, enum action action)
 
 	case BUS_RESET:
 		if (qla1280_verbose)
-			printk(KERN_INFO "qla1280(%ld:%d): Issuing BUS "
-			       "DEVICE RESET\n", ha->host_no, bus);
-		if (qla1280_bus_reset(ha, bus == 0))
+			printk(KERN_INFO "qla1280(%ld:%d): Issued bus "
+			       "reset.\n", ha->host_no, bus);
+		if (qla1280_bus_reset(ha, bus) == 0)
 			result = SUCCESS;
-
 		break;
 
 	case ADAPTER_RESET:

commit 7d12e780e003f93433d49ce78cfedf4b4c52adc5
Author: David Howells <dhowells@redhat.com>
Date:   Thu Oct 5 14:55:46 2006 +0100

    IRQ: Maintain regs pointer globally rather than passing to IRQ handlers
    
    Maintain a per-CPU global "struct pt_regs *" variable which can be used instead
    of passing regs around manually through all ~1800 interrupt handlers in the
    Linux kernel.
    
    The regs pointer is used in few places, but it potentially costs both stack
    space and code to pass it around.  On the FRV arch, removing the regs parameter
    from all the genirq function results in a 20% speed up of the IRQ exit path
    (ie: from leaving timer_interrupt() to leaving do_IRQ()).
    
    Where appropriate, an arch may override the generic storage facility and do
    something different with the variable.  On FRV, for instance, the address is
    maintained in GR28 at all times inside the kernel as part of general exception
    handling.
    
    Having looked over the code, it appears that the parameter may be handed down
    through up to twenty or so layers of functions.  Consider a USB character
    device attached to a USB hub, attached to a USB controller that posts its
    interrupts through a cascaded auxiliary interrupt controller.  A character
    device driver may want to pass regs to the sysrq handler through the input
    layer which adds another few layers of parameter passing.
    
    I've build this code with allyesconfig for x86_64 and i386.  I've runtested the
    main part of the code on FRV and i386, though I can't test most of the drivers.
    I've also done partial conversion for powerpc and MIPS - these at least compile
    with minimal configurations.
    
    This will affect all archs.  Mostly the changes should be relatively easy.
    Take do_IRQ(), store the regs pointer at the beginning, saving the old one:
    
            struct pt_regs *old_regs = set_irq_regs(regs);
    
    And put the old one back at the end:
    
            set_irq_regs(old_regs);
    
    Don't pass regs through to generic_handle_irq() or __do_IRQ().
    
    In timer_interrupt(), this sort of change will be necessary:
    
            -       update_process_times(user_mode(regs));
            -       profile_tick(CPU_PROFILING, regs);
            +       update_process_times(user_mode(get_irq_regs()));
            +       profile_tick(CPU_PROFILING);
    
    I'd like to move update_process_times()'s use of get_irq_regs() into itself,
    except that i386, alone of the archs, uses something other than user_mode().
    
    Some notes on the interrupt handling in the drivers:
    
     (*) input_dev() is now gone entirely.  The regs pointer is no longer stored in
         the input_dev struct.
    
     (*) finish_unlinks() in drivers/usb/host/ohci-q.c needs checking.  It does
         something different depending on whether it's been supplied with a regs
         pointer or not.
    
     (*) Various IRQ handler function pointers have been moved to type
         irq_handler_t.
    
    Signed-Off-By: David Howells <dhowells@redhat.com>
    (cherry picked from 1b16e7ac850969f38b375e511e3fa2f474a33867 commit)

diff --git a/drivers/scsi/qla1280.c b/drivers/scsi/qla1280.c
index 9f33e5946c0d..2521d548dd59 100644
--- a/drivers/scsi/qla1280.c
+++ b/drivers/scsi/qla1280.c
@@ -1113,7 +1113,7 @@ qla1280_enable_intrs(struct scsi_qla_host *ha)
  *   Handles the H/W interrupt
  **************************************************************************/
 static irqreturn_t
-qla1280_intr_handler(int irq, void *dev_id, struct pt_regs *regs)
+qla1280_intr_handler(int irq, void *dev_id)
 {
 	struct scsi_qla_host *ha;
 	struct device_reg __iomem *reg;

commit 97d41e90fe61399b99d74820cb7f2d6e0fbac91d
Merge: 3bdc9d0b408e afaf5a2d341d
Author: Linus Torvalds <torvalds@g5.osdl.org>
Date:   Wed Oct 4 18:57:35 2006 -0700

    Merge master.kernel.org:/pub/scm/linux/kernel/git/jejb/scsi-misc-2.6
    
    * master.kernel.org:/pub/scm/linux/kernel/git/jejb/scsi-misc-2.6: (54 commits)
      [SCSI] Initial Commit of qla4xxx
      [SCSI] raid class: handle component-add errors
      [SCSI] SCSI megaraid_sas: handle thrown errors
      [SCSI] SCSI aic94xx: handle sysfs errors
      [SCSI] SCSI st: fix error handling in module init, sysfs
      [SCSI] SCSI sd: fix module init/exit error handling
      [SCSI] SCSI osst: add error handling to module init, sysfs
      [SCSI] scsi: remove hosts.h
      [SCSI] scsi: Scsi_Cmnd convertion in aic7xxx_old.c
      [SCSI] megaraid_sas: sets ioctl timeout and updates version,changelog
      [SCSI] megaraid_sas: adds tasklet for cmd completion
      [SCSI] megaraid_sas: prints pending cmds before setting hw_crit_error
      [SCSI] megaraid_sas: function pointer for disable interrupt
      [SCSI] megaraid_sas: frame count optimization
      [SCSI] megaraid_sas: FW transition and q size changes
      [SCSI] qla2xxx: Update version number to 8.01.07-k2.
      [SCSI] qla2xxx: Stall mid-layer error handlers while rport is blocked.
      [SCSI] qla2xxx: Add MODULE_FIRMWARE tags.
      [SCSI] qla2xxx: Add support for host port state FC transport attribute.
      [SCSI] qla2xxx: Add support for fabric name FC transport attribute.
      ...

commit 6e9a4738c9fadb7cbdcabc1e3b415159f3741ed9
Author: Peter Zijlstra <a.p.zijlstra@chello.nl>
Date:   Sat Sep 30 23:28:10 2006 -0700

    [PATCH] completions: lockdep annotate on stack completions
    
    All on stack DECLARE_COMPLETIONs should be replaced by:
    DECLARE_COMPLETION_ONSTACK
    
    Signed-off-by: Peter Zijlstra <a.p.zijlstra@chello.nl>
    Acked-by: Ingo Molnar <mingo@elte.hu>
    Acked-by: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/drivers/scsi/qla1280.c b/drivers/scsi/qla1280.c
index 8953991462d7..332151e2a018 100644
--- a/drivers/scsi/qla1280.c
+++ b/drivers/scsi/qla1280.c
@@ -813,7 +813,7 @@ qla1280_error_action(struct scsi_cmnd *cmd, enum action action)
 	uint16_t data;
 	unsigned char *handle;
 	int result, i;
-	DECLARE_COMPLETION(wait);
+	DECLARE_COMPLETION_ONSTACK(wait);
 	struct timer_list timer;
 
 	ha = (struct scsi_qla_host *)(CMD_HOST(cmd)->hostdata);
@@ -2406,7 +2406,7 @@ qla1280_mailbox_command(struct scsi_qla_host *ha, uint8_t mr, uint16_t *mb)
 	uint16_t *optr, *iptr;
 	uint16_t __iomem *mptr;
 	uint16_t data;
-	DECLARE_COMPLETION(wait);
+	DECLARE_COMPLETION_ONSTACK(wait);
 	struct timer_list timer;
 
 	ENTER("qla1280_mailbox_command");

commit dcbccbde00b85b4d4a1c206b419e7a3d2ab2b1cd
Author: Henrik Kretzschmar <henne@nachtwindheim.de>
Date:   Mon Sep 25 16:58:58 2006 -0700

    [SCSI] pci_module_init conversion in scsi subsystem
    
    Converts pci_module_init() to pci_register_driver() in the scsi subsys on
    23 drivers which only return the value of pci_module_init().
    
    Signed-off-by: Henrik Kretzschmar <henne@nachtwindheim.de>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>

diff --git a/drivers/scsi/qla1280.c b/drivers/scsi/qla1280.c
index 2747c8e02f83..bdecde1c515f 100644
--- a/drivers/scsi/qla1280.c
+++ b/drivers/scsi/qla1280.c
@@ -4484,7 +4484,7 @@ qla1280_init(void)
 		qla1280_setup(qla1280);
 #endif
 
-	return pci_module_init(&qla1280_pci_driver);
+	return pci_register_driver(&qla1280_pci_driver);
 }
 
 static void __exit

commit 15d1f53fc7654d62af7e9b23049ae3b71f5b161c
Author: Jes Sorensen <jes@sgi.com>
Date:   Mon Sep 25 05:44:57 2006 -0400

    [SCSI] qla1280 command timeout
    
    Original patch from Ian Dall in bugzilla. Set command timeout as
    specified by the SCSI layer rather than hardcode it to 30 seconds. I
    have received a couple of reports of people hitting this one with
    various tape configurations and the patch looks obviously correct.
                                                                      - Jes
    
    From http://bugzilla.kernel.org/show_bug.cgi?id=6275
    
    ian@beware.dropbear.id.au (Ian Dall):
    
    The command sent to the card was using a 30second timeout regardless of the
    timeout requested in the scsi command passed down from higher levels.
    
    Signed-off-by: Jes Sorensen <jes@sgi.com>
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>

diff --git a/drivers/scsi/qla1280.c b/drivers/scsi/qla1280.c
index 8953991462d7..2747c8e02f83 100644
--- a/drivers/scsi/qla1280.c
+++ b/drivers/scsi/qla1280.c
@@ -2862,7 +2862,7 @@ qla1280_64bit_start_scsi(struct scsi_qla_host *ha, struct srb * sp)
 	memset(((char *)pkt + 8), 0, (REQUEST_ENTRY_SIZE - 8));
 
 	/* Set ISP command timeout. */
-	pkt->timeout = cpu_to_le16(30);
+	pkt->timeout = cpu_to_le16(cmd->timeout_per_command/HZ);
 
 	/* Set device target ID and LUN */
 	pkt->lun = SCSI_LUN_32(cmd);
@@ -3161,7 +3161,7 @@ qla1280_32bit_start_scsi(struct scsi_qla_host *ha, struct srb * sp)
 	memset(((char *)pkt + 8), 0, (REQUEST_ENTRY_SIZE - 8));
 
 	/* Set ISP command timeout. */
-	pkt->timeout = cpu_to_le16(30);
+	pkt->timeout = cpu_to_le16(cmd->timeout_per_command/HZ);
 
 	/* Set device target ID and LUN */
 	pkt->lun = SCSI_LUN_32(cmd);

commit c4e00fac42f268ed0a547cdd1d12bb8399864040
Merge: 29454dde27d8 d6b0c5372375
Author: James Bottomley <jejb@mulgrave.il.steeleye.com>
Date:   Mon Jul 3 09:41:12 2006 -0500

    Merge ../scsi-misc-2.6
    
    Conflicts:
    
            drivers/scsi/nsp32.c
            drivers/scsi/pcmcia/nsp_cs.c
    
    Removal of randomness flag conflicts with SA_ -> IRQF_ global
    replacement.
    
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>

commit 1d6f359a2e06296418481239f8054a878f36e819
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Sat Jul 1 19:29:42 2006 -0700

    [PATCH] irq-flags: scsi: Use the new IRQF_ constants
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: Ingo Molnar <mingo@elte.hu>
    Cc: "David S. Miller" <davem@davemloft.net>
    Cc: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Cc: James Bottomley <James.Bottomley@steeleye.com>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/drivers/scsi/qla1280.c b/drivers/scsi/qla1280.c
index a7e4183462b8..b818b9bfe678 100644
--- a/drivers/scsi/qla1280.c
+++ b/drivers/scsi/qla1280.c
@@ -192,7 +192,7 @@
         - Don't walk the entire list in qla1280_putq_t() just to directly
 	  grab the pointer to the last element afterwards
     Rev  3.23.5 Beta August 9, 2001, Jes Sorensen
-	- Don't use SA_INTERRUPT, it's use is deprecated for this kinda driver
+	- Don't use IRQF_DISABLED, it's use is deprecated for this kinda driver
     Rev  3.23.4 Beta August 8, 2001, Jes Sorensen
 	- Set dev->max_sectors to 1024
     Rev  3.23.3 Beta August 6, 2001, Jes Sorensen
@@ -4369,7 +4369,7 @@ qla1280_probe_one(struct pci_dev *pdev, const struct pci_device_id *id)
 	/* Disable ISP interrupts. */
 	qla1280_disable_intrs(ha);
 
-	if (request_irq(pdev->irq, qla1280_intr_handler, SA_SHIRQ,
+	if (request_irq(pdev->irq, qla1280_intr_handler, IRQF_SHARED,
 				"qla1280", ha)) {
 		printk("qla1280 : Failed to reserve interrupt %d already "
 		       "in use\n", pdev->irq);

commit f58f8313a6f552d1e7889926a29f0cf91c02f55d
Author: Randy Dunlap <rdunlap@xenotime.net>
Date:   Fri Jun 30 02:33:14 2006 -0700

    [SCSI] qla1280: fix section mismatch warnings
    
    Fix section mismatch warnings:
    WARNING: drivers/scsi/qla1280.o - Section mismatch: reference to
    .init.data: from .text between 'qla1280_get_token' (at offset 0x2a16)
    and 'qla1280_probe_one'
    WARNING: drivers/scsi/qla1280.o - Section mismatch: reference to
    .init.data: from .text between 'qla1280_get_token' (at offset 0x2a3c)
    and 'qla1280_probe_one'
    
    Signed-off-by: Randy Dunlap <rdunlap@xenotime.net>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>

diff --git a/drivers/scsi/qla1280.c b/drivers/scsi/qla1280.c
index 680f6063954b..f09d54058ce1 100644
--- a/drivers/scsi/qla1280.c
+++ b/drivers/scsi/qla1280.c
@@ -4210,7 +4210,7 @@ qla1280_setup(char *s)
 }
 
 
-static int
+static int __init
 qla1280_get_token(char *str)
 {
 	char *sep;

commit 6ab3d5624e172c553004ecc862bfeac16d9d68b7
Author: Jrn Engel <joern@wohnheim.fh-wedel.de>
Date:   Fri Jun 30 19:25:36 2006 +0200

    Remove obsolete #include <linux/config.h>
    
    Signed-off-by: Jrn Engel <joern@wohnheim.fh-wedel.de>
    Signed-off-by: Adrian Bunk <bunk@stusta.de>

diff --git a/drivers/scsi/qla1280.c b/drivers/scsi/qla1280.c
index 680f6063954b..a7e4183462b8 100644
--- a/drivers/scsi/qla1280.c
+++ b/drivers/scsi/qla1280.c
@@ -331,7 +331,6 @@
 *****************************************************************************/
 
 
-#include <linux/config.h>
 #include <linux/module.h>
 
 #include <linux/version.h>

commit 74d0a988d3aa359b6b8a8536c8cb92cce02ca5d5
Author: Brent Casavant <bcasavan@sgi.com>
Date:   Wed May 10 01:49:14 2006 -0700

    [PATCH] PCI: Move various PCI IDs to header file
    
    Move various QLogic, Vitesse, and Intel storage controller PCI IDs to the
    main header file.
    
    Signed-off-by: Brent Casavant <bcasavan@sgi.com>
    Acked-by: Jes Sorensen <jes@sgi.com>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/scsi/qla1280.c b/drivers/scsi/qla1280.c
index 77bb2351500c..680f6063954b 100644
--- a/drivers/scsi/qla1280.c
+++ b/drivers/scsi/qla1280.c
@@ -397,30 +397,6 @@
 #include "ql1280_fw.h"
 #include "ql1040_fw.h"
 
-
-/*
- * Missing PCI ID's
- */
-#ifndef PCI_DEVICE_ID_QLOGIC_ISP1080
-#define PCI_DEVICE_ID_QLOGIC_ISP1080	0x1080
-#endif
-#ifndef PCI_DEVICE_ID_QLOGIC_ISP1240
-#define PCI_DEVICE_ID_QLOGIC_ISP1240	0x1240
-#endif
-#ifndef PCI_DEVICE_ID_QLOGIC_ISP1280
-#define PCI_DEVICE_ID_QLOGIC_ISP1280	0x1280
-#endif
-#ifndef PCI_DEVICE_ID_QLOGIC_ISP10160
-#define PCI_DEVICE_ID_QLOGIC_ISP10160	0x1016
-#endif
-#ifndef PCI_DEVICE_ID_QLOGIC_ISP12160
-#define PCI_DEVICE_ID_QLOGIC_ISP12160	0x1216
-#endif
-
-#ifndef PCI_VENDOR_ID_AMI
-#define PCI_VENDOR_ID_AMI               0x101e
-#endif
-
 #ifndef BITS_PER_LONG
 #error "BITS_PER_LONG not defined!"
 #endif

commit 6391a11375de5e2bb1eb8481e54619761dc65d9f
Author: Tobias Klauser <tklauser@nuerscht.ch>
Date:   Thu Jun 8 22:23:48 2006 -0700

    [SCSI] drivers/scsi: Use ARRAY_SIZE macro
    
    Use ARRAY_SIZE macro instead of sizeof(x)/sizeof(x[0]) and remove
    duplicates of the macro.
    
    Signed-off-by: Tobias Klauser <tklauser@nuerscht.ch>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>

diff --git a/drivers/scsi/qla1280.c b/drivers/scsi/qla1280.c
index 5a48e55f9418..77bb2351500c 100644
--- a/drivers/scsi/qla1280.c
+++ b/drivers/scsi/qla1280.c
@@ -4239,15 +4239,12 @@ qla1280_get_token(char *str)
 {
 	char *sep;
 	long ret = -1;
-	int i, len;
-
-	len = sizeof(setup_token)/sizeof(struct setup_tokens);
+	int i;
 
 	sep = strchr(str, ':');
 
 	if (sep) {
-		for (i = 0; i < len; i++){
-
+		for (i = 0; i < ARRAY_SIZE(setup_token); i++) {
 			if (!strncmp(setup_token[i].token, str, (sep - str))) {
 				ret =  setup_token[i].val;
 				break;

commit 910638ae7ed4be27d6af55f6c9b5bf54b838e78b
Author: Matthias Gehre <M.Gehre@gmx.de>
Date:   Tue Mar 28 01:56:48 2006 -0800

    [PATCH] Replace 0xff.. with correct DMA_xBIT_MASK
    
    Replace all occurences of 0xff..  in calls to function pci_set_dma_mask()
    and pci_set_consistant_dma_mask() with the corresponding DMA_xBIT_MASK from
    linux/dma-mapping.h.
    
    Signed-off-by: Matthias Gehre <M.Gehre@gmx.de>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/drivers/scsi/qla1280.c b/drivers/scsi/qla1280.c
index e0230249fa0f..5a48e55f9418 100644
--- a/drivers/scsi/qla1280.c
+++ b/drivers/scsi/qla1280.c
@@ -350,6 +350,7 @@
 #include <linux/pci_ids.h>
 #include <linux/interrupt.h>
 #include <linux/init.h>
+#include <linux/dma-mapping.h>
 
 #include <asm/io.h>
 #include <asm/irq.h>
@@ -4321,7 +4322,7 @@ qla1280_probe_one(struct pci_dev *pdev, const struct pci_device_id *id)
 
 #ifdef QLA_64BIT_PTR
 	if (pci_set_dma_mask(ha->pdev, (dma_addr_t) ~ 0ULL)) {
-		if (pci_set_dma_mask(ha->pdev, 0xffffffff)) {
+		if (pci_set_dma_mask(ha->pdev, DMA_32BIT_MASK)) {
 			printk(KERN_WARNING "scsi(%li): Unable to set a "
 			       "suitable DMA mask - aborting\n", ha->host_no);
 			error = -ENODEV;
@@ -4331,7 +4332,7 @@ qla1280_probe_one(struct pci_dev *pdev, const struct pci_device_id *id)
 		dprintk(2, "scsi(%li): 64 Bit PCI Addressing Enabled\n",
 			ha->host_no);
 #else
-	if (pci_set_dma_mask(ha->pdev, 0xffffffff)) {
+	if (pci_set_dma_mask(ha->pdev, DMA_32BIT_MASK)) {
 		printk(KERN_WARNING "scsi(%li): Unable to set a "
 		       "suitable DMA mask - aborting\n", ha->host_no);
 		error = -ENODEV;

commit 2dbb04c65561122cc53b22dbea9aa59f9609215b
Author: Jes Sorensen <jes@sgi.com>
Date:   Mon Jan 16 11:49:29 2006 -0500

    [SCSI] qla1280: remove < 2.6.0 support
    
    Remove support for kernels older than 2.6.0.
    
    Signed-off-by: Jes Sorensen <jes@sgi.com>
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>

diff --git a/drivers/scsi/qla1280.c b/drivers/scsi/qla1280.c
index 0878f95b5449..e0230249fa0f 100644
--- a/drivers/scsi/qla1280.c
+++ b/drivers/scsi/qla1280.c
@@ -17,9 +17,11 @@
 * General Public License for more details.
 *
 ******************************************************************************/
-#define QLA1280_VERSION      "3.25"
+#define QLA1280_VERSION      "3.26"
 /*****************************************************************************
     Revision History:
+    Rev  3.26, January 16, 2006 Jes Sorensen
+	- Ditch all < 2.6 support
     Rev  3.25.1, February 10, 2005 Christoph Hellwig
 	- use pci_map_single to map non-S/G requests
 	- remove qla1280_proc_info
@@ -356,25 +358,18 @@
 #include <asm/types.h>
 #include <asm/system.h>
 
-#if LINUX_VERSION_CODE >= 0x020545
 #include <scsi/scsi.h>
 #include <scsi/scsi_cmnd.h>
 #include <scsi/scsi_device.h>
 #include <scsi/scsi_host.h>
 #include <scsi/scsi_tcq.h>
-#else
-#include <linux/blk.h>
-#include "scsi.h"
-#include <scsi/scsi_host.h>
-#include "sd.h"
-#endif
 
 #if defined(CONFIG_IA64_GENERIC) || defined(CONFIG_IA64_SGI_SN2)
 #include <asm/sn/io.h>
 #endif
 
-#if LINUX_VERSION_CODE < 0x020407
-#error "Kernels older than 2.4.7 are no longer supported"
+#if LINUX_VERSION_CODE < 0x020600
+#error "Kernels older than 2.6.0 are no longer supported"
 #endif
 
 
@@ -441,52 +436,6 @@
 
 #define NVRAM_DELAY()			udelay(500)	/* 2 microseconds */
 
-#if LINUX_VERSION_CODE < 0x020500
-#define HOST_LOCK			&io_request_lock
-#define irqreturn_t			void
-#define IRQ_RETVAL(foo)
-#define MSG_ORDERED_TAG			1
-
-#define DMA_BIDIRECTIONAL	SCSI_DATA_UNKNOWN
-#define DMA_TO_DEVICE		SCSI_DATA_WRITE
-#define DMA_FROM_DEVICE		SCSI_DATA_READ
-#define DMA_NONE		SCSI_DATA_NONE
-
-#ifndef HAVE_SECTOR_T
-typedef unsigned int sector_t;
-#endif
-
-static inline void
-scsi_adjust_queue_depth(struct scsi_device *device, int tag, int depth)
-{
-	if (tag) {
-		device->tagged_queue = tag;
-		device->current_tag = 0;
-	}
-	device->queue_depth = depth;
-}
-static inline struct Scsi_Host *scsi_host_alloc(struct scsi_host_template *t, size_t s)
-{
-	return scsi_register(t, s);
-}
-static inline void scsi_host_put(struct Scsi_Host *h)
-{
-	scsi_unregister(h);
-}
-#else
-#define HOST_LOCK			ha->host->host_lock
-#endif
-#if LINUX_VERSION_CODE < 0x020600
-#define DEV_SIMPLE_TAGS(device)		device->tagged_queue
-/*
- * Hack around that qla1280_remove_one is called from
- * qla1280_release in 2.4
- */
-#undef __devexit
-#define __devexit
-#else
-#define DEV_SIMPLE_TAGS(device)		device->simple_tags
-#endif
 #if defined(__ia64__) && !defined(ia64_platform_is)
 #define ia64_platform_is(foo)		(!strcmp(x, platform_name))
 #endif
@@ -506,9 +455,6 @@ static void qla1280_remove_one(struct pci_dev *);
  *  QLogic Driver Support Function Prototypes.
  */
 static void qla1280_done(struct scsi_qla_host *);
-#if LINUX_VERSION_CODE < 0x020545
-static void qla1280_get_target_options(struct scsi_cmnd *, struct scsi_qla_host *);
-#endif
 static int qla1280_get_token(char *);
 static int qla1280_setup(char *s) __init;
 
@@ -610,11 +556,7 @@ __setup("qla1280=", qla1280_setup);
 #define	CMD_SNSLEN(Cmnd)	sizeof(Cmnd->sense_buffer)
 #define	CMD_RESULT(Cmnd)	Cmnd->result
 #define	CMD_HANDLE(Cmnd)	Cmnd->host_scribble
-#if LINUX_VERSION_CODE < 0x020545
-#define CMD_REQUEST(Cmnd)	Cmnd->request.cmd
-#else
 #define CMD_REQUEST(Cmnd)	Cmnd->request->cmd
-#endif
 
 #define CMD_HOST(Cmnd)		Cmnd->device->host
 #define SCSI_BUS_32(Cmnd)	Cmnd->device->channel
@@ -1064,10 +1006,10 @@ qla1280_error_action(struct scsi_cmnd *cmd, enum action action)
 	add_timer(&timer);
 
 	/* wait for the action to complete (or the timer to expire) */
-	spin_unlock_irq(HOST_LOCK);
+	spin_unlock_irq(ha->host->host_lock);
 	wait_for_completion(&wait);
 	del_timer_sync(&timer);
-	spin_lock_irq(HOST_LOCK);
+	spin_lock_irq(ha->host->host_lock);
 	sp->wait = NULL;
 
 	/* the only action we might get a fail for is abort */
@@ -1173,96 +1115,6 @@ qla1280_biosparam(struct scsi_device *sdev, struct block_device *bdev,
 	return 0;
 }
 
-#if LINUX_VERSION_CODE < 0x020600
-static int
-qla1280_detect(struct scsi_host_template *template)
-{
-	struct pci_device_id *id = &qla1280_pci_tbl[0];
-	struct pci_dev *pdev = NULL;
-	int num_hosts = 0;
-
-	if (sizeof(struct srb) > sizeof(Scsi_Pointer)) {
-		printk(KERN_WARNING
-		       "qla1280: struct srb too big, aborting\n");
-		return 0;
-	}
-
-	if ((DMA_BIDIRECTIONAL != PCI_DMA_BIDIRECTIONAL) ||
-	    (DMA_TO_DEVICE != PCI_DMA_TODEVICE) ||
-	    (DMA_FROM_DEVICE != PCI_DMA_FROMDEVICE) ||
-	    (DMA_NONE != PCI_DMA_NONE)) {
-		printk(KERN_WARNING
-		       "qla1280: dma direction bits don't match\n");
-		return 0;
-	}
-
-#ifdef MODULE
-	/*
-	 * If we are called as a module, the qla1280 pointer may not be null
-	 * and it would point to our bootup string, just like on the lilo
-	 * command line.  IF not NULL, then process this config string with
-	 * qla1280_setup
-	 *
-	 * Boot time Options
-	 * To add options at boot time add a line to your lilo.conf file like:
-	 * append="qla1280=verbose,max_tags:{{255,255,255,255},{255,255,255,255}}"
-	 * which will result in the first four devices on the first two
-	 * controllers being set to a tagged queue depth of 32.
-	 */
-	if (qla1280)
-		qla1280_setup(qla1280);
-#endif
-
-	/* First Initialize QLA12160 on PCI Bus 1 Dev 2 */
-	while ((pdev = pci_find_device(id->vendor, id->device, pdev))) {
-		if (pdev->bus->number == 1 && PCI_SLOT(pdev->devfn) == 2) {
-			if (!qla1280_probe_one(pdev, id))
-				num_hosts++;
-		}
-	}
-
-	pdev = NULL;
-	/* Try and find each different type of adapter we support */
-	for (id = &qla1280_pci_tbl[0]; id->device; id++) {
-		while ((pdev = pci_find_device(id->vendor, id->device, pdev))) {
-			/*
-			 * skip QLA12160 already initialized on
-			 * PCI Bus 1 Dev 2 since we already initialized
-			 * and presented it
-			 */
-			if (id->device == PCI_DEVICE_ID_QLOGIC_ISP12160 &&
-			    pdev->bus->number == 1 &&
-			    PCI_SLOT(pdev->devfn) == 2)
-				continue;
-
-			if (!qla1280_probe_one(pdev, id))
-				num_hosts++;
-		}
-	}
-
-	return num_hosts;
-}
-
-/*
- * This looks a bit ugly as we could just pass down host to
- * qla1280_remove_one, but I want to keep qla1280_release purely a wrapper
- * around pci_driver::remove as used from 2.6 onwards.
- */
-static int
-qla1280_release(struct Scsi_Host *host)
-{
-	struct scsi_qla_host *ha = (struct scsi_qla_host *)host->hostdata;
-
-	qla1280_remove_one(ha->pdev);
-	return 0;
-}
-
-static int
-qla1280_biosparam_old(Disk * disk, kdev_t dev, int geom[])
-{
-	return qla1280_biosparam(disk->device, NULL, disk->capacity, geom);
-}
-#endif
  
 /* disable risc and host interrupts */
 static inline void
@@ -1295,7 +1147,7 @@ qla1280_intr_handler(int irq, void *dev_id, struct pt_regs *regs)
 	ENTER_INTR ("qla1280_intr_handler");
 	ha = (struct scsi_qla_host *)dev_id;
 
-	spin_lock(HOST_LOCK);
+	spin_lock(ha->host->host_lock);
 
 	ha->isr_count++;
 	reg = ha->iobase;
@@ -1311,7 +1163,7 @@ qla1280_intr_handler(int irq, void *dev_id, struct pt_regs *regs)
 	if (!list_empty(&ha->done_q))
 		qla1280_done(ha);
 
-	spin_unlock(HOST_LOCK);
+	spin_unlock(ha->host->host_lock);
 
 	qla1280_enable_intrs(ha);
 
@@ -1411,11 +1263,9 @@ qla1280_slave_configure(struct scsi_device *device)
 		scsi_adjust_queue_depth(device, 0, default_depth);
 	}
 
-#if LINUX_VERSION_CODE > 0x020500
 	nv->bus[bus].target[target].parameter.enable_sync = device->sdtr;
 	nv->bus[bus].target[target].parameter.enable_wide = device->wdtr;
 	nv->bus[bus].target[target].ppr_1x160.flags.enable_ppr = device->ppr;
-#endif
 
 	if (driver_setup.no_sync ||
 	    (driver_setup.sync_mask &&
@@ -1432,38 +1282,14 @@ qla1280_slave_configure(struct scsi_device *device)
 			nv->bus[bus].target[target].ppr_1x160.flags.enable_ppr = 0;
 	}
 
-	spin_lock_irqsave(HOST_LOCK, flags);
+	spin_lock_irqsave(ha->host->host_lock, flags);
 	if (nv->bus[bus].target[target].parameter.enable_sync)
 		status = qla1280_set_target_parameters(ha, bus, target);
 	qla1280_get_target_parameters(ha, device);
-	spin_unlock_irqrestore(HOST_LOCK, flags);
+	spin_unlock_irqrestore(ha->host->host_lock, flags);
 	return status;
 }
 
-#if LINUX_VERSION_CODE < 0x020545
-/**************************************************************************
- *   qla1280_select_queue_depth
- *
- *   Sets the queue depth for each SCSI device hanging off the input
- *   host adapter.  We use a queue depth of 2 for devices that do not
- *   support tagged queueing.
- **************************************************************************/
-static void
-qla1280_select_queue_depth(struct Scsi_Host *host, struct scsi_device *sdev_q)
-{
-	struct scsi_qla_host *ha = (struct scsi_qla_host *)host->hostdata;
-	struct scsi_device *sdev;
-
-	ENTER("qla1280_select_queue_depth");
-	for (sdev = sdev_q; sdev; sdev = sdev->next)
-		if (sdev->host == host)
-			qla1280_slave_configure(sdev);
-
-	if (sdev_q)
-		qla1280_check_for_dead_scsi_bus(ha, sdev_q->channel);
-	LEAVE("qla1280_select_queue_depth");
-}
-#endif
 
 /*
  * qla1280_done
@@ -1523,10 +1349,6 @@ qla1280_done(struct scsi_qla_host *ha)
 		CMD_HANDLE(sp->cmd) = (unsigned char *)INVALID_HANDLE;
 		ha->actthreads--;
 
-#if LINUX_VERSION_CODE < 0x020500
-		if (cmd->cmnd[0] == INQUIRY)
-			qla1280_get_target_options(cmd, ha);
-#endif
 		(*(cmd)->scsi_done)(cmd);
 
 		if(sp->wait != NULL)
@@ -1655,9 +1477,7 @@ qla1280_initialize_adapter(struct scsi_qla_host *ha)
 	struct device_reg __iomem *reg;
 	int status;
 	int bus;
-#if LINUX_VERSION_CODE > 0x020500
 	unsigned long flags;
-#endif
 
 	ENTER("qla1280_initialize_adapter");
 
@@ -1695,15 +1515,12 @@ qla1280_initialize_adapter(struct scsi_qla_host *ha)
 			"NVRAM\n");
 	}
 
-#if LINUX_VERSION_CODE >= 0x020500
 	/*
 	 * It's necessary to grab the spin here as qla1280_mailbox_command
 	 * needs to be able to drop the lock unconditionally to wait
 	 * for completion.
-	 * In 2.4 ->detect is called with the io_request_lock held.
 	 */
-	spin_lock_irqsave(HOST_LOCK, flags);
-#endif
+	spin_lock_irqsave(ha->host->host_lock, flags);
 
 	status = qla1280_load_firmware(ha);
 	if (status) {
@@ -1735,9 +1552,8 @@ qla1280_initialize_adapter(struct scsi_qla_host *ha)
 
 	ha->flags.online = 1;
  out:
-#if LINUX_VERSION_CODE >= 0x020500
-	spin_unlock_irqrestore(HOST_LOCK, flags);
-#endif
+	spin_unlock_irqrestore(ha->host->host_lock, flags);
+
 	if (status)
 		dprintk(2, "qla1280_initialize_adapter: **** FAILED ****\n");
 
@@ -2650,14 +2466,14 @@ qla1280_mailbox_command(struct scsi_qla_host *ha, uint8_t mr, uint16_t *mb)
 	timer.function = qla1280_mailbox_timeout;
 	add_timer(&timer);
 
-	spin_unlock_irq(HOST_LOCK);
+	spin_unlock_irq(ha->host->host_lock);
 	WRT_REG_WORD(&reg->host_cmd, HC_SET_HOST_INT);
 	data = qla1280_debounce_register(&reg->istatus);
 
 	wait_for_completion(&wait);
 	del_timer_sync(&timer);
 
-	spin_lock_irq(HOST_LOCK);
+	spin_lock_irq(ha->host->host_lock);
 
 	ha->mailbox_wait = NULL;
 
@@ -2770,9 +2586,9 @@ qla1280_bus_reset(struct scsi_qla_host *ha, int bus)
 			ha->bus_settings[bus].scsi_bus_dead = 1;
 		ha->bus_settings[bus].failed_reset_count++;
 	} else {
-		spin_unlock_irq(HOST_LOCK);
+		spin_unlock_irq(ha->host->host_lock);
 		ssleep(reset_delay);
-		spin_lock_irq(HOST_LOCK);
+		spin_lock_irq(ha->host->host_lock);
 
 		ha->bus_settings[bus].scsi_bus_dead = 0;
 		ha->bus_settings[bus].failed_reset_count = 0;
@@ -3078,7 +2894,7 @@ qla1280_64bit_start_scsi(struct scsi_qla_host *ha, struct srb * sp)
 		(SCSI_TCN_32(cmd) | BIT_7) : SCSI_TCN_32(cmd);
 
 	/* Enable simple tag queuing if device supports it. */
-	if (DEV_SIMPLE_TAGS(cmd->device))
+	if (cmd->device->simple_tags)
 		pkt->control_flags |= cpu_to_le16(BIT_3);
 
 	/* Load SCSI command packet. */
@@ -3377,7 +3193,7 @@ qla1280_32bit_start_scsi(struct scsi_qla_host *ha, struct srb * sp)
 		(SCSI_TCN_32(cmd) | BIT_7) : SCSI_TCN_32(cmd);
 
 	/* Enable simple tag queuing if device supports it. */
-	if (DEV_SIMPLE_TAGS(cmd->device))
+	if (cmd->device->simple_tags)
 		pkt->control_flags |= cpu_to_le16(BIT_3);
 
 	/* Load SCSI command packet. */
@@ -3889,50 +3705,6 @@ qla1280_rst_aen(struct scsi_qla_host *ha)
 }
 
 
-#if LINUX_VERSION_CODE < 0x020500
-/*
- *
- */
-static void
-qla1280_get_target_options(struct scsi_cmnd *cmd, struct scsi_qla_host *ha)
-{
-	unsigned char *result;
-	struct nvram *n;
-	int bus, target, lun;
-
-	bus = SCSI_BUS_32(cmd);
-	target = SCSI_TCN_32(cmd);
-	lun = SCSI_LUN_32(cmd);
-
-	/*
-	 * Make sure to not touch anything if someone is using the
-	 * sg interface.
-	 */
-	if (cmd->use_sg || (CMD_RESULT(cmd) >> 16) != DID_OK || lun)
-		return;
-
-	result = cmd->request_buffer;
-	n = &ha->nvram;
-
-	n->bus[bus].target[target].parameter.enable_wide = 0;
-	n->bus[bus].target[target].parameter.enable_sync = 0;
-	n->bus[bus].target[target].ppr_1x160.flags.enable_ppr = 0;
-
-        if (result[7] & 0x60)
-		n->bus[bus].target[target].parameter.enable_wide = 1;
-        if (result[7] & 0x10)
-		n->bus[bus].target[target].parameter.enable_sync = 1;
-	if ((result[2] >= 3) && (result[4] + 5 > 56) &&
-	    (result[56] & 0x4))
-		n->bus[bus].target[target].ppr_1x160.flags.enable_ppr = 1;
-
-	dprintk(2, "get_target_options(): wide %i, sync %i, ppr %i\n",
-		n->bus[bus].target[target].parameter.enable_wide,
-		n->bus[bus].target[target].parameter.enable_sync,
-		n->bus[bus].target[target].ppr_1x160.flags.enable_ppr);
-}
-#endif
-
 /*
  *  qla1280_status_entry
  *      Processes received ISP status entry.
@@ -4271,7 +4043,7 @@ qla1280_get_target_parameters(struct scsi_qla_host *ha,
 	} else
 		printk(" Async");
 
-	if (DEV_SIMPLE_TAGS(device))
+	if (device->simple_tags)
 		printk(", Tagged queuing: depth %d", device->queue_depth);
 	printk("\n");
 }
@@ -4485,7 +4257,7 @@ qla1280_get_token(char *str)
 	return ret;
 }
 
-#if LINUX_VERSION_CODE >= 0x020600
+
 static struct scsi_host_template qla1280_driver_template = {
 	.module			= THIS_MODULE,
 	.proc_name		= "qla1280",
@@ -4504,27 +4276,7 @@ static struct scsi_host_template qla1280_driver_template = {
 	.cmd_per_lun		= 1,
 	.use_clustering		= ENABLE_CLUSTERING,
 };
-#else
-static struct scsi_host_template qla1280_driver_template = {
-	.proc_name		= "qla1280",
-	.name			= "Qlogic ISP 1280/12160",
-	.detect			= qla1280_detect,
-	.release		= qla1280_release,
-	.info			= qla1280_info,
-	.queuecommand		= qla1280_queuecommand,
-	.eh_abort_handler	= qla1280_eh_abort,
-	.eh_device_reset_handler= qla1280_eh_device_reset,
-	.eh_bus_reset_handler	= qla1280_eh_bus_reset,
-	.eh_host_reset_handler	= qla1280_eh_adapter_reset,
-	.bios_param		= qla1280_biosparam_old,
-	.can_queue		= 0xfffff,
-	.this_id		= -1,
-	.sg_tablesize		= SG_ALL,
-	.cmd_per_lun		= 1,
-	.use_clustering		= ENABLE_CLUSTERING,
-	.use_new_eh_code	= 1,
-};
-#endif
+
 
 static int __devinit
 qla1280_probe_one(struct pci_dev *pdev, const struct pci_device_id *id)
@@ -4615,10 +4367,6 @@ qla1280_probe_one(struct pci_dev *pdev, const struct pci_device_id *id)
 	host->max_sectors = 1024;
 	host->unique_id = host->host_no;
 
-#if LINUX_VERSION_CODE < 0x020545
-	host->select_queue_depths = qla1280_select_queue_depth;
-#endif
-
 	error = -ENODEV;
 
 #if MEMORY_MAPPED_IO
@@ -4666,21 +4414,15 @@ qla1280_probe_one(struct pci_dev *pdev, const struct pci_device_id *id)
 
 	pci_set_drvdata(pdev, host);
 
-#if LINUX_VERSION_CODE >= 0x020600
 	error = scsi_add_host(host, &pdev->dev);
 	if (error)
 		goto error_disable_adapter;
 	scsi_scan_host(host);
-#else
-	scsi_set_pci_device(host, pdev);
-#endif
 
 	return 0;
 
-#if LINUX_VERSION_CODE >= 0x020600
  error_disable_adapter:
 	qla1280_disable_intrs(ha);
-#endif
  error_free_irq:
 	free_irq(pdev->irq, ha);
  error_release_region:
@@ -4712,9 +4454,7 @@ qla1280_remove_one(struct pci_dev *pdev)
 	struct Scsi_Host *host = pci_get_drvdata(pdev);
 	struct scsi_qla_host *ha = (struct scsi_qla_host *)host->hostdata;
 
-#if LINUX_VERSION_CODE >= 0x020600
 	scsi_remove_host(host);
-#endif
 
 	qla1280_disable_intrs(ha);
 
@@ -4738,7 +4478,6 @@ qla1280_remove_one(struct pci_dev *pdev)
 	scsi_host_put(host);
 }
 
-#if LINUX_VERSION_CODE >= 0x020600
 static struct pci_driver qla1280_pci_driver = {
 	.name		= "qla1280",
 	.id_table	= qla1280_pci_tbl,
@@ -4784,10 +4523,6 @@ qla1280_exit(void)
 module_init(qla1280_init);
 module_exit(qla1280_exit);
 
-#else
-# define driver_template qla1280_driver_template
-# include "scsi_module.c"
-#endif
 
 MODULE_AUTHOR("Qlogic & Jes Sorensen");
 MODULE_DESCRIPTION("Qlogic ISP SCSI (qla1x80/qla1x160) driver");

commit d0be4a7d29ad0bd3ce2209dd9e46d410b632db59
Author: Christoph Hellwig <hch@lst.de>
Date:   Mon Oct 31 18:31:40 2005 +0100

    [SCSI] remove Scsi_Host_Template typedef
    
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>

diff --git a/drivers/scsi/qla1280.c b/drivers/scsi/qla1280.c
index cc7593b97def..0878f95b5449 100644
--- a/drivers/scsi/qla1280.c
+++ b/drivers/scsi/qla1280.c
@@ -465,7 +465,7 @@ scsi_adjust_queue_depth(struct scsi_device *device, int tag, int depth)
 	}
 	device->queue_depth = depth;
 }
-static inline struct Scsi_Host *scsi_host_alloc(Scsi_Host_Template *t, size_t s)
+static inline struct Scsi_Host *scsi_host_alloc(struct scsi_host_template *t, size_t s)
 {
 	return scsi_register(t, s);
 }
@@ -1175,7 +1175,7 @@ qla1280_biosparam(struct scsi_device *sdev, struct block_device *bdev,
 
 #if LINUX_VERSION_CODE < 0x020600
 static int
-qla1280_detect(Scsi_Host_Template *template)
+qla1280_detect(struct scsi_host_template *template)
 {
 	struct pci_device_id *id = &qla1280_pci_tbl[0];
 	struct pci_dev *pdev = NULL;
@@ -4505,7 +4505,7 @@ static struct scsi_host_template qla1280_driver_template = {
 	.use_clustering		= ENABLE_CLUSTERING,
 };
 #else
-static Scsi_Host_Template qla1280_driver_template = {
+static struct scsi_host_template qla1280_driver_template = {
 	.proc_name		= "qla1280",
 	.name			= "Qlogic ISP 1280/12160",
 	.detect			= qla1280_detect,

commit d6933df97a486d9c73a6bb4fed75154343c8638f
Author: Adrian Bunk <bunk@stusta.de>
Date:   Tue Nov 1 21:47:37 2005 +0100

    [SCSI] remove the obsolete SCSI qlogicisp driver
    
    The SCSI qlogicisp driver is both marked BROKEN and superseded by the
    qla1280 driver.
    
    Signed-off-by: Adrian Bunk <bunk@stusta.de>
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>

diff --git a/drivers/scsi/qla1280.c b/drivers/scsi/qla1280.c
index 637fb6565d28..cc7593b97def 100644
--- a/drivers/scsi/qla1280.c
+++ b/drivers/scsi/qla1280.c
@@ -639,10 +639,8 @@ struct qla_boards {
 static struct pci_device_id qla1280_pci_tbl[] = {
 	{PCI_VENDOR_ID_QLOGIC, PCI_DEVICE_ID_QLOGIC_ISP12160,
 		PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},
-#ifdef CONFIG_SCSI_QLOGIC_1280_1040
 	{PCI_VENDOR_ID_QLOGIC, PCI_DEVICE_ID_QLOGIC_ISP1020,
 		PCI_ANY_ID, PCI_ANY_ID, 0, 0, 1},
-#endif
 	{PCI_VENDOR_ID_QLOGIC, PCI_DEVICE_ID_QLOGIC_ISP1080,
 		PCI_ANY_ID, PCI_ANY_ID, 0, 0, 2},
 	{PCI_VENDOR_ID_QLOGIC, PCI_DEVICE_ID_QLOGIC_ISP1240,

commit 8d6810d33e5e43b11675190318a81303c601a568
Author: Christoph Hellwig <hch@lst.de>
Date:   Mon Jul 4 17:49:26 2005 +0200

    [SCSI] qla1280: endianess annotations
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>

diff --git a/drivers/scsi/qla1280.c b/drivers/scsi/qla1280.c
index 6481deb57048..637fb6565d28 100644
--- a/drivers/scsi/qla1280.c
+++ b/drivers/scsi/qla1280.c
@@ -1546,7 +1546,7 @@ qla1280_return_status(struct response * sts, struct scsi_cmnd *cp)
 	int host_status = DID_ERROR;
 	uint16_t comp_status = le16_to_cpu(sts->comp_status);
 	uint16_t state_flags = le16_to_cpu(sts->state_flags);
-	uint16_t residual_length = le16_to_cpu(sts->residual_length);
+	uint16_t residual_length = le32_to_cpu(sts->residual_length);
 	uint16_t scsi_status = le16_to_cpu(sts->scsi_status);
 #if DEBUG_QLA1280_INTR
 	static char *reason[] = {
@@ -1932,7 +1932,7 @@ qla1280_load_firmware_dma(struct scsi_qla_host *ha)
 			"%d,%d(0x%x)\n",
 			risc_code_address, cnt, num, risc_address);
 		for(i = 0; i < cnt; i++)
-			((uint16_t *)ha->request_ring)[i] =
+			((__le16 *)ha->request_ring)[i] =
 				cpu_to_le16(risc_code_address[i]);
 
 		mb[0] = MBC_LOAD_RAM;
@@ -2986,7 +2986,7 @@ qla1280_64bit_start_scsi(struct scsi_qla_host *ha, struct srb * sp)
 	struct scsi_cmnd *cmd = sp->cmd;
 	cmd_a64_entry_t *pkt;
 	struct scatterlist *sg = NULL;
-	u32 *dword_ptr;
+	__le32 *dword_ptr;
 	dma_addr_t dma_handle;
 	int status = 0;
 	int cnt;
@@ -3273,7 +3273,7 @@ qla1280_32bit_start_scsi(struct scsi_qla_host *ha, struct srb * sp)
 	struct scsi_cmnd *cmd = sp->cmd;
 	struct cmd_entry *pkt;
 	struct scatterlist *sg = NULL;
-	uint32_t *dword_ptr;
+	__le32 *dword_ptr;
 	int status = 0;
 	int cnt;
 	int req_cnt;

commit 7a34766fdcec0c619aa68ace203b934dd7cf9dbc
Author: Christoph Hellwig <hch@lst.de>
Date:   Mon Jul 4 17:49:22 2005 +0200

    [SCSI] qla1280: don't use bitfields for hardware access, parameters
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Thiemo Seufer <ths@linux-mips.org>
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>

diff --git a/drivers/scsi/qla1280.c b/drivers/scsi/qla1280.c
index 1a8b1147821d..6481deb57048 100644
--- a/drivers/scsi/qla1280.c
+++ b/drivers/scsi/qla1280.c
@@ -1328,7 +1328,7 @@ qla1280_set_target_parameters(struct scsi_qla_host *ha, int bus, int target)
 	uint8_t mr;
 	uint16_t mb[MAILBOX_REGISTER_COUNT];
 	struct nvram *nv;
-	int status;
+	int status, lun;
 
 	nv = &ha->nvram;
 
@@ -1336,24 +1336,38 @@ qla1280_set_target_parameters(struct scsi_qla_host *ha, int bus, int target)
 
 	/* Set Target Parameters. */
 	mb[0] = MBC_SET_TARGET_PARAMETERS;
-	mb[1] = (uint16_t) (bus ? target | BIT_7 : target);
-	mb[1] <<= 8;
-
-	mb[2] = (nv->bus[bus].target[target].parameter.c << 8);
+	mb[1] = (uint16_t)((bus ? target | BIT_7 : target) << 8);
+	mb[2] = nv->bus[bus].target[target].parameter.renegotiate_on_error << 8;
+	mb[2] |= nv->bus[bus].target[target].parameter.stop_queue_on_check << 9;
+	mb[2] |= nv->bus[bus].target[target].parameter.auto_request_sense << 10;
+	mb[2] |= nv->bus[bus].target[target].parameter.tag_queuing << 11;
+	mb[2] |= nv->bus[bus].target[target].parameter.enable_sync << 12;
+	mb[2] |= nv->bus[bus].target[target].parameter.enable_wide << 13;
+	mb[2] |= nv->bus[bus].target[target].parameter.parity_checking << 14;
+	mb[2] |= nv->bus[bus].target[target].parameter.disconnect_allowed << 15;
 
 	if (IS_ISP1x160(ha)) {
 		mb[2] |= nv->bus[bus].target[target].ppr_1x160.flags.enable_ppr << 5;
-		mb[3] =	(nv->bus[bus].target[target].flags.flags1x160.sync_offset << 8) |
-			 nv->bus[bus].target[target].sync_period;
+		mb[3] =	(nv->bus[bus].target[target].flags.flags1x160.sync_offset << 8);
 		mb[6] =	(nv->bus[bus].target[target].ppr_1x160.flags.ppr_options << 8) |
 			 nv->bus[bus].target[target].ppr_1x160.flags.ppr_bus_width;
 		mr |= BIT_6;
 	} else {
-		mb[3] =	(nv->bus[bus].target[target].flags.flags1x80.sync_offset << 8) |
-			 nv->bus[bus].target[target].sync_period;
+		mb[3] =	(nv->bus[bus].target[target].flags.flags1x80.sync_offset << 8);
 	}
+	mb[3] |= nv->bus[bus].target[target].sync_period;
+
+	status = qla1280_mailbox_command(ha, mr, mb);
 
-	status = qla1280_mailbox_command(ha, mr, &mb[0]);
+	/* Set Device Queue Parameters. */
+	for (lun = 0; lun < MAX_LUNS; lun++) {
+		mb[0] = MBC_SET_DEVICE_QUEUE;
+		mb[1] = (uint16_t)((bus ? target | BIT_7 : target) << 8);
+		mb[1] |= lun;
+		mb[2] = nv->bus[bus].max_queue_depth;
+		mb[3] = nv->bus[bus].target[target].execution_throttle;
+		status |= qla1280_mailbox_command(ha, 0x0f, mb);
+	}
 
 	if (status)
 		printk(KERN_WARNING "scsi(%ld:%i:%i): "
@@ -1400,19 +1414,19 @@ qla1280_slave_configure(struct scsi_device *device)
 	}
 
 #if LINUX_VERSION_CODE > 0x020500
-	nv->bus[bus].target[target].parameter.f.enable_sync = device->sdtr;
-	nv->bus[bus].target[target].parameter.f.enable_wide = device->wdtr;
+	nv->bus[bus].target[target].parameter.enable_sync = device->sdtr;
+	nv->bus[bus].target[target].parameter.enable_wide = device->wdtr;
 	nv->bus[bus].target[target].ppr_1x160.flags.enable_ppr = device->ppr;
 #endif
 
 	if (driver_setup.no_sync ||
 	    (driver_setup.sync_mask &&
 	     (~driver_setup.sync_mask & (1 << target))))
-		nv->bus[bus].target[target].parameter.f.enable_sync = 0;
+		nv->bus[bus].target[target].parameter.enable_sync = 0;
 	if (driver_setup.no_wide ||
 	    (driver_setup.wide_mask &&
 	     (~driver_setup.wide_mask & (1 << target))))
-		nv->bus[bus].target[target].parameter.f.enable_wide = 0;
+		nv->bus[bus].target[target].parameter.enable_wide = 0;
 	if (IS_ISP1x160(ha)) {
 		if (driver_setup.no_ppr ||
 		    (driver_setup.ppr_mask &&
@@ -1421,7 +1435,7 @@ qla1280_slave_configure(struct scsi_device *device)
 	}
 
 	spin_lock_irqsave(HOST_LOCK, flags);
-	if (nv->bus[bus].target[target].parameter.f.enable_sync)
+	if (nv->bus[bus].target[target].parameter.enable_sync)
 		status = qla1280_set_target_parameters(ha, bus, target);
 	qla1280_get_target_parameters(ha, device);
 	spin_unlock_irqrestore(HOST_LOCK, flags);
@@ -2151,17 +2165,17 @@ qla1280_set_target_defaults(struct scsi_qla_host *ha, int bus, int target)
 {
 	struct nvram *nv = &ha->nvram;
 
-	nv->bus[bus].target[target].parameter.f.renegotiate_on_error = 1;
-	nv->bus[bus].target[target].parameter.f.auto_request_sense = 1;
-	nv->bus[bus].target[target].parameter.f.tag_queuing = 1;
-	nv->bus[bus].target[target].parameter.f.enable_sync = 1;
+	nv->bus[bus].target[target].parameter.renegotiate_on_error = 1;
+	nv->bus[bus].target[target].parameter.auto_request_sense = 1;
+	nv->bus[bus].target[target].parameter.tag_queuing = 1;
+	nv->bus[bus].target[target].parameter.enable_sync = 1;
 #if 1	/* Some SCSI Processors do not seem to like this */
-	nv->bus[bus].target[target].parameter.f.enable_wide = 1;
+	nv->bus[bus].target[target].parameter.enable_wide = 1;
 #endif
-	nv->bus[bus].target[target].parameter.f.parity_checking = 1;
-	nv->bus[bus].target[target].parameter.f.disconnect_allowed = 1;
 	nv->bus[bus].target[target].execution_throttle =
 		nv->bus[bus].max_queue_depth - 1;
+	nv->bus[bus].target[target].parameter.parity_checking = 1;
+	nv->bus[bus].target[target].parameter.disconnect_allowed = 1;
 
 	if (IS_ISP1x160(ha)) {
 		nv->bus[bus].target[target].flags.flags1x160.device_enable = 1;
@@ -2237,66 +2251,53 @@ qla1280_config_target(struct scsi_qla_host *ha, int bus, int target)
 	struct nvram *nv = &ha->nvram;
 	uint16_t mb[MAILBOX_REGISTER_COUNT];
 	int status, lun;
+	uint16_t flag;
 
 	/* Set Target Parameters. */
 	mb[0] = MBC_SET_TARGET_PARAMETERS;
-	mb[1] = (uint16_t) (bus ? target | BIT_7 : target);
-	mb[1] <<= 8;
-
-	/*
-	 * Do not enable wide, sync, and ppr for the initial
-	 * INQUIRY run. We enable this later if we determine
-	 * the target actually supports it.
-	 */
-	nv->bus[bus].target[target].parameter.f.
-		auto_request_sense = 1;
-	nv->bus[bus].target[target].parameter.f.
-		stop_queue_on_check = 0;
-
-	if (IS_ISP1x160(ha))
-		nv->bus[bus].target[target].ppr_1x160.
-			flags.enable_ppr = 0;
+	mb[1] = (uint16_t)((bus ? target | BIT_7 : target) << 8);
 
 	/*
-	 * No sync, wide, etc. while probing
+	 * Do not enable sync and ppr for the initial INQUIRY run. We
+	 * enable this later if we determine the target actually
+	 * supports it.
 	 */
-	mb[2] = (nv->bus[bus].target[target].parameter.c << 8) &
-		~(TP_SYNC /*| TP_WIDE | TP_PPR*/);
+	mb[2] = (TP_RENEGOTIATE | TP_AUTO_REQUEST_SENSE | TP_TAGGED_QUEUE
+		 | TP_WIDE | TP_PARITY | TP_DISCONNECT);
 
 	if (IS_ISP1x160(ha))
 		mb[3] =	nv->bus[bus].target[target].flags.flags1x160.sync_offset << 8;
 	else
 		mb[3] =	nv->bus[bus].target[target].flags.flags1x80.sync_offset << 8;
 	mb[3] |= nv->bus[bus].target[target].sync_period;
-
-	status = qla1280_mailbox_command(ha, BIT_3 | BIT_2 | BIT_1 | BIT_0, &mb[0]);
+	status = qla1280_mailbox_command(ha, 0x0f, mb);
 
 	/* Save Tag queuing enable flag. */
-	mb[0] = BIT_0 << target;
-	if (nv->bus[bus].target[target].parameter.f.tag_queuing)
-		ha->bus_settings[bus].qtag_enables |= mb[0];
+	flag = (BIT_0 << target) & mb[0];
+	if (nv->bus[bus].target[target].parameter.tag_queuing)
+		ha->bus_settings[bus].qtag_enables |= flag;
 
 	/* Save Device enable flag. */
 	if (IS_ISP1x160(ha)) {
 		if (nv->bus[bus].target[target].flags.flags1x160.device_enable)
-			ha->bus_settings[bus].device_enables |= mb[0];
+			ha->bus_settings[bus].device_enables |= flag;
 		ha->bus_settings[bus].lun_disables |= 0;
 	} else {
 		if (nv->bus[bus].target[target].flags.flags1x80.device_enable)
-			ha->bus_settings[bus].device_enables |= mb[0];
+			ha->bus_settings[bus].device_enables |= flag;
 		/* Save LUN disable flag. */
 		if (nv->bus[bus].target[target].flags.flags1x80.lun_disable)
-			ha->bus_settings[bus].lun_disables |= mb[0];
+			ha->bus_settings[bus].lun_disables |= flag;
 	}
 
 	/* Set Device Queue Parameters. */
 	for (lun = 0; lun < MAX_LUNS; lun++) {
 		mb[0] = MBC_SET_DEVICE_QUEUE;
-		mb[1] = (uint16_t)(bus ? target | BIT_7 : target);
-		mb[1] = mb[1] << 8 | lun;
+		mb[1] = (uint16_t)((bus ? target | BIT_7 : target) << 8);
+		mb[1] |= lun;
 		mb[2] = nv->bus[bus].max_queue_depth;
 		mb[3] = nv->bus[bus].target[target].execution_throttle;
-		status |= qla1280_mailbox_command(ha, 0x0f, &mb[0]);
+		status |= qla1280_mailbox_command(ha, 0x0f, mb);
 	}
 
 	return status;
@@ -2341,7 +2342,6 @@ qla1280_nvram_config(struct scsi_qla_host *ha)
 	struct nvram *nv = &ha->nvram;
 	int bus, target, status = 0;
 	uint16_t mb[MAILBOX_REGISTER_COUNT];
-	uint16_t mask;
 
 	ENTER("qla1280_nvram_config");
 
@@ -2349,7 +2349,7 @@ qla1280_nvram_config(struct scsi_qla_host *ha)
 		/* Always force AUTO sense for LINUX SCSI */
 		for (bus = 0; bus < MAX_BUSES; bus++)
 			for (target = 0; target < MAX_TARGETS; target++) {
-				nv->bus[bus].target[target].parameter.f.
+				nv->bus[bus].target[target].parameter.
 					auto_request_sense = 1;
 			}
 	} else {
@@ -2416,16 +2416,17 @@ qla1280_nvram_config(struct scsi_qla_host *ha)
 
 	/* Firmware feature word. */
 	mb[0] = MBC_SET_FIRMWARE_FEATURES;
-	mask = BIT_5 | BIT_1 | BIT_0;
-	mb[1] = le16_to_cpu(nv->firmware_feature.w) & (mask);
+	mb[1] = nv->firmware_feature.f.enable_fast_posting;
+	mb[1] |= nv->firmware_feature.f.report_lvd_bus_transition << 1;
+	mb[1] |= nv->firmware_feature.f.disable_synchronous_backoff << 5;
 #if defined(CONFIG_IA64_GENERIC) || defined (CONFIG_IA64_SGI_SN2)
 	if (ia64_platform_is("sn2")) {
 		printk(KERN_INFO "scsi(%li): Enabling SN2 PCI DMA "
 		       "workaround\n", ha->host_no);
-		mb[1] |= BIT_9;
+		mb[1] |= nv->firmware_feature.f.unused_9 << 9; /* XXX */
 	}
 #endif
-	status |= qla1280_mailbox_command(ha, mask, &mb[0]);
+	status |= qla1280_mailbox_command(ha, BIT_1 | BIT_0, mb);
 
 	/* Retry count and delay. */
 	mb[0] = MBC_SET_RETRY_COUNT;
@@ -2454,27 +2455,27 @@ qla1280_nvram_config(struct scsi_qla_host *ha)
 		mb[2] |= BIT_5;
 	if (nv->bus[1].config_2.data_line_active_negation)
 		mb[2] |= BIT_4;
-	status |= qla1280_mailbox_command(ha, BIT_2 | BIT_1 | BIT_0, &mb[0]);
+	status |= qla1280_mailbox_command(ha, BIT_2 | BIT_1 | BIT_0, mb);
 
 	mb[0] = MBC_SET_DATA_OVERRUN_RECOVERY;
 	mb[1] = 2;	/* Reset SCSI bus and return all outstanding IO */
-	status |= qla1280_mailbox_command(ha, BIT_1 | BIT_0, &mb[0]);
+	status |= qla1280_mailbox_command(ha, BIT_1 | BIT_0, mb);
 
 	/* thingy */
 	mb[0] = MBC_SET_PCI_CONTROL;
-	mb[1] = 2;	/* Data DMA Channel Burst Enable */
-	mb[2] = 2;	/* Command DMA Channel Burst Enable */
-	status |= qla1280_mailbox_command(ha, BIT_2 | BIT_1 | BIT_0, &mb[0]);
+	mb[1] = BIT_1;	/* Data DMA Channel Burst Enable */
+	mb[2] = BIT_1;	/* Command DMA Channel Burst Enable */
+	status |= qla1280_mailbox_command(ha, BIT_2 | BIT_1 | BIT_0, mb);
 
 	mb[0] = MBC_SET_TAG_AGE_LIMIT;
 	mb[1] = 8;
-	status |= qla1280_mailbox_command(ha, BIT_1 | BIT_0, &mb[0]);
+	status |= qla1280_mailbox_command(ha, BIT_1 | BIT_0, mb);
 
 	/* Selection timeout. */
 	mb[0] = MBC_SET_SELECTION_TIMEOUT;
 	mb[1] = nv->bus[0].selection_timeout;
 	mb[2] = nv->bus[1].selection_timeout;
-	status |= qla1280_mailbox_command(ha, BIT_2 | BIT_1 | BIT_0, &mb[0]);
+	status |= qla1280_mailbox_command(ha, BIT_2 | BIT_1 | BIT_0, mb);
 
 	for (bus = 0; bus < ha->ports; bus++)
 		status |= qla1280_config_bus(ha, bus);
@@ -3915,21 +3916,21 @@ qla1280_get_target_options(struct scsi_cmnd *cmd, struct scsi_qla_host *ha)
 	result = cmd->request_buffer;
 	n = &ha->nvram;
 
-	n->bus[bus].target[target].parameter.f.enable_wide = 0;
-	n->bus[bus].target[target].parameter.f.enable_sync = 0;
+	n->bus[bus].target[target].parameter.enable_wide = 0;
+	n->bus[bus].target[target].parameter.enable_sync = 0;
 	n->bus[bus].target[target].ppr_1x160.flags.enable_ppr = 0;
 
         if (result[7] & 0x60)
-		n->bus[bus].target[target].parameter.f.enable_wide = 1;
+		n->bus[bus].target[target].parameter.enable_wide = 1;
         if (result[7] & 0x10)
-		n->bus[bus].target[target].parameter.f.enable_sync = 1;
+		n->bus[bus].target[target].parameter.enable_sync = 1;
 	if ((result[2] >= 3) && (result[4] + 5 > 56) &&
 	    (result[56] & 0x4))
 		n->bus[bus].target[target].ppr_1x160.flags.enable_ppr = 1;
 
 	dprintk(2, "get_target_options(): wide %i, sync %i, ppr %i\n",
-		n->bus[bus].target[target].parameter.f.enable_wide,
-		n->bus[bus].target[target].parameter.f.enable_sync,
+		n->bus[bus].target[target].parameter.enable_wide,
+		n->bus[bus].target[target].parameter.enable_sync,
 		n->bus[bus].target[target].ppr_1x160.flags.enable_ppr);
 }
 #endif

commit 0888f4c3312847eec4814a6d7cdcaaaa9fbd3345
Author: Christoph Hellwig <hch@lst.de>
Date:   Mon Jul 4 17:48:55 2005 +0200

    [SCSI] qla1280: don't use bitfields for hardware access in isp_config
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Thiemo Seufer <ths@linux-mips.org>
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>

diff --git a/drivers/scsi/qla1280.c b/drivers/scsi/qla1280.c
index 9f975f7c1ea8..1a8b1147821d 100644
--- a/drivers/scsi/qla1280.c
+++ b/drivers/scsi/qla1280.c
@@ -2189,9 +2189,9 @@ qla1280_set_defaults(struct scsi_qla_host *ha)
 	/* nv->cntr_flags_1.disable_loading_risc_code = 1; */
 	nv->firmware_feature.f.enable_fast_posting = 1;
 	nv->firmware_feature.f.disable_synchronous_backoff = 1;
-	nv->termination.f.scsi_bus_0_control = 3;
-	nv->termination.f.scsi_bus_1_control = 3;
-	nv->termination.f.auto_term_support = 1;
+	nv->termination.scsi_bus_0_control = 3;
+	nv->termination.scsi_bus_1_control = 3;
+	nv->termination.auto_term_support = 1;
 
 	/*
 	 * Set default FIFO magic - What appropriate values would be here
@@ -2201,7 +2201,12 @@ qla1280_set_defaults(struct scsi_qla_host *ha)
 	 * header file provided by QLogic seems to be bogus or incomplete
 	 * at best.
 	 */
-	nv->isp_config.c = ISP_CFG1_BENAB|ISP_CFG1_F128;
+	nv->isp_config.burst_enable = 1;
+	if (IS_ISP1040(ha))
+		nv->isp_config.fifo_threshold |= 3;
+	else
+		nv->isp_config.fifo_threshold |= 4;
+
 	if (IS_ISP1x160(ha))
 		nv->isp_parameter = 0x01; /* fast memory enable */
 
@@ -2362,31 +2367,40 @@ qla1280_nvram_config(struct scsi_qla_host *ha)
 
 		hwrev = RD_REG_WORD(&reg->cfg_0) & ISP_CFG0_HWMSK;
 
-		cfg1 = RD_REG_WORD(&reg->cfg_1);
+		cfg1 = RD_REG_WORD(&reg->cfg_1) & ~(BIT_4 | BIT_5 | BIT_6);
 		cdma_conf = RD_REG_WORD(&reg->cdma_cfg);
 		ddma_conf = RD_REG_WORD(&reg->ddma_cfg);
 
 		/* Busted fifo, says mjacob. */
-		if (hwrev == ISP_CFG0_1040A)
-			WRT_REG_WORD(&reg->cfg_1, cfg1 | ISP_CFG1_F64);
-		else
-			WRT_REG_WORD(&reg->cfg_1, cfg1 | ISP_CFG1_F64 | ISP_CFG1_BENAB);
+		if (hwrev != ISP_CFG0_1040A)
+			cfg1 |= nv->isp_config.fifo_threshold << 4;
+
+		cfg1 |= nv->isp_config.burst_enable << 2;
+		WRT_REG_WORD(&reg->cfg_1, cfg1);
 
 		WRT_REG_WORD(&reg->cdma_cfg, cdma_conf | CDMA_CONF_BENAB);
 		WRT_REG_WORD(&reg->ddma_cfg, cdma_conf | DDMA_CONF_BENAB);
 	} else {
+		uint16_t cfg1, term;
+
 		/* Set ISP hardware DMA burst */
-		mb[0] = nv->isp_config.c;
+		cfg1 = nv->isp_config.fifo_threshold << 4;
+		cfg1 |= nv->isp_config.burst_enable << 2;
 		/* Enable DMA arbitration on dual channel controllers */
 		if (ha->ports > 1)
-			mb[0] |= BIT_13;
-		WRT_REG_WORD(&reg->cfg_1, mb[0]);
+			cfg1 |= BIT_13;
+		WRT_REG_WORD(&reg->cfg_1, cfg1);
 
 		/* Set SCSI termination. */
-		WRT_REG_WORD(&reg->gpio_enable, (BIT_3 + BIT_2 + BIT_1 + BIT_0));
-		mb[0] = nv->termination.c & (BIT_3 + BIT_2 + BIT_1 + BIT_0);
-		WRT_REG_WORD(&reg->gpio_data, mb[0]);
+		WRT_REG_WORD(&reg->gpio_enable,
+			     BIT_7 | BIT_3 | BIT_2 | BIT_1 | BIT_0);
+		term = nv->termination.scsi_bus_1_control;
+		term |= nv->termination.scsi_bus_0_control << 2;
+		term |= nv->termination.auto_term_support << 7;
+		RD_REG_WORD(&reg->id_l);	/* Flush PCI write */
+		WRT_REG_WORD(&reg->gpio_data, term);
 	}
+	RD_REG_WORD(&reg->id_l);	/* Flush PCI write */
 
 	/* ISP parameter word. */
 	mb[0] = MBC_SET_SYSTEM_PARAMETER;

commit 5c79d6154f335543ea4c4a555f645a1f76b5d117
Author: Christoph Hellwig <hch@lst.de>
Date:   Mon Jul 4 17:48:46 2005 +0200

    [SCSI] qla1280: always load microcode
    
    we have the most recent microcode, make sure to always load it.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>

diff --git a/drivers/scsi/qla1280.c b/drivers/scsi/qla1280.c
index 3732230b2e3a..9f975f7c1ea8 100644
--- a/drivers/scsi/qla1280.c
+++ b/drivers/scsi/qla1280.c
@@ -1733,69 +1733,6 @@ qla1280_initialize_adapter(struct scsi_qla_host *ha)
 	return status;
 }
 
-
-/*
- * ISP Firmware Test
- *      Checks if present version of RISC firmware is older than
- *      driver firmware.
- *
- * Input:
- *      ha = adapter block pointer.
- *
- * Returns:
- *      0 = firmware does not need to be loaded.
- */
-static int
-qla1280_isp_firmware(struct scsi_qla_host *ha)
-{
-	struct nvram *nv = (struct nvram *) ha->response_ring;
-	int status = 0;		/* dg 2/27 always loads RISC */
-	uint16_t mb[MAILBOX_REGISTER_COUNT];
-
-	ENTER("qla1280_isp_firmware");
-
-	dprintk(1, "scsi(%li): Determining if RISC is loaded\n", ha->host_no);
-
-	/* Bad NVRAM data, load RISC code. */
-	if (!ha->nvram_valid) {
-		ha->flags.disable_risc_code_load = 0;
-	} else
-		ha->flags.disable_risc_code_load =
-			nv->cntr_flags_1.disable_loading_risc_code;
-
-	if (ha->flags.disable_risc_code_load) {
-		dprintk(3, "qla1280_isp_firmware: Telling RISC to verify "
-			"checksum of loaded BIOS code.\n");
-
-		/* Verify checksum of loaded RISC code. */
-		mb[0] = MBC_VERIFY_CHECKSUM;
-		/* mb[1] = ql12_risc_code_addr01; */
-		mb[1] = *ql1280_board_tbl[ha->devnum].fwstart;
-
-		if (!(status =
-		      qla1280_mailbox_command(ha, BIT_1 | BIT_0, &mb[0]))) {
-			/* Start firmware execution. */
-			dprintk(3, "qla1280_isp_firmware: Startng F/W "
-				"execution.\n");
-
-			mb[0] = MBC_EXECUTE_FIRMWARE;
-			/* mb[1] = ql12_risc_code_addr01; */
-			mb[1] = *ql1280_board_tbl[ha->devnum].fwstart;
-			qla1280_mailbox_command(ha, BIT_1 | BIT_0, &mb[0]);
-		} else
-			printk(KERN_INFO "qla1280: RISC checksum failed.\n");
-	} else {
-		dprintk(1, "qla1280: NVRAM configured to load RISC load.\n");
-		status = 1;
-	}
-
-	if (status)
-		dprintk(2, "qla1280_isp_firmware: **** Load RISC code ****\n");
-
-	LEAVE("qla1280_isp_firmware");
-	return status;
-}
-
 /*
  * Chip diagnostics
  *      Test chip for proper operation.
@@ -2080,14 +2017,7 @@ qla1280_start_firmware(struct scsi_qla_host *ha)
 static int
 qla1280_load_firmware(struct scsi_qla_host *ha)
 {
-	int err = -ENODEV;
-
-	/* If firmware needs to be loaded */
-	if (!qla1280_isp_firmware(ha)) {
-		printk(KERN_ERR "scsi(%li): isp_firmware() failed!\n",
-				ha->host_no);
-		goto out;
-	}
+	int err;
 
 	err = qla1280_chip_diag(ha);
 	if (err)

commit d6db3e8d5fe3178776d0a0314e612c3f55e55fb4
Author: Christoph Hellwig <hch@lst.de>
Date:   Mon Jul 4 17:48:36 2005 +0200

    [SCSI] qla1280: use SAM_ constants
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Thiemo Seufer <ths@linux-mips.org>
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>

diff --git a/drivers/scsi/qla1280.c b/drivers/scsi/qla1280.c
index e5354550d762..3732230b2e3a 100644
--- a/drivers/scsi/qla1280.c
+++ b/drivers/scsi/qla1280.c
@@ -4049,7 +4049,7 @@ qla1280_status_entry(struct scsi_qla_host *ha, struct response *pkt,
 		/* Save ISP completion status */
 		CMD_RESULT(cmd) = qla1280_return_status(pkt, cmd);
 
-		if (scsi_status & SS_CHECK_CONDITION) {
+		if (scsi_status & SAM_STAT_CHECK_CONDITION) {
 			if (comp_status != CS_ARS_FAILED) {
 				uint16_t req_sense_length =
 					le16_to_cpu(pkt->req_sense_length);

commit 2b55cac3d2d9f545c141748d00eae86e2c042ca5
Author: Christoph Hellwig <hch@lst.de>
Date:   Mon Jul 4 17:48:30 2005 +0200

    [SCSI] qla1280: misc cleanups
    
    print message tidy ups and some excess brace removal.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Thiemo Seufer <ths@linux-mips.org>
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>

diff --git a/drivers/scsi/qla1280.c b/drivers/scsi/qla1280.c
index 58ecdc696675..e5354550d762 100644
--- a/drivers/scsi/qla1280.c
+++ b/drivers/scsi/qla1280.c
@@ -1459,7 +1459,6 @@ qla1280_select_queue_depth(struct Scsi_Host *host, struct scsi_device *sdev_q)
  *
  * Input:
  *      ha           = adapter block pointer.
- *      done_q       = done queue.
  */
 static void
 qla1280_done(struct scsi_qla_host *ha)
@@ -1593,7 +1592,7 @@ qla1280_return_status(struct response * sts, struct scsi_cmnd *cp)
 
 	case CS_DATA_OVERRUN:
 		dprintk(2, "Data overrun 0x%x\n", residual_length);
-		dprintk(2, "qla1280_isr: response packet data\n");
+		dprintk(2, "qla1280_return_status: response packet data\n");
 		qla1280_dump_buffer(2, (char *)sts, RESPONSE_ENTRY_SIZE);
 		host_status = DID_ERROR;
 		break;
@@ -2061,7 +2060,7 @@ qla1280_start_firmware(struct scsi_qla_host *ha)
 	mb[1] = *ql1280_board_tbl[ha->devnum].fwstart;
 	err = qla1280_mailbox_command(ha, BIT_1 | BIT_0, mb);
 	if (err) {
-		printk(KERN_ERR "scsi(%li): Failed checksum\n", ha->host_no);
+		printk(KERN_ERR "scsi(%li): RISC checksum failed.\n", ha->host_no);
 		return err;
 	}
 
@@ -3080,10 +3079,13 @@ qla1280_64bit_start_scsi(struct scsi_qla_host *ha, struct srb * sp)
 				REQUEST_ENTRY_CNT - (ha->req_ring_index - cnt);
 	}
 
+	dprintk(3, "Number of free entries=(%d) seg_cnt=0x%x\n",
+		ha->req_q_cnt, seg_cnt);
+
 	/* If room for request in request ring. */
 	if ((req_cnt + 2) >= ha->req_q_cnt) {
 		status = 1;
-		dprintk(2, "qla1280_64bit_start_scsi: in-ptr=0x%x  req_q_cnt="
+		dprintk(2, "qla1280_start_scsi: in-ptr=0x%x  req_q_cnt="
 			"0x%xreq_cnt=0x%x", ha->req_ring_index, ha->req_q_cnt,
 			req_cnt);
 		goto out;
@@ -3095,7 +3097,7 @@ qla1280_64bit_start_scsi(struct scsi_qla_host *ha, struct srb * sp)
 
 	if (cnt >= MAX_OUTSTANDING_COMMANDS) {
 		status = 1;
-		dprintk(2, "qla1280_64bit_start_scsi: NO ROOM IN "
+		dprintk(2, "qla1280_start_scsi: NO ROOM IN "
 			"OUTSTANDING ARRAY, req_q_cnt=0x%x", ha->req_q_cnt);
 		goto out;
 	}
@@ -3104,7 +3106,7 @@ qla1280_64bit_start_scsi(struct scsi_qla_host *ha, struct srb * sp)
 	ha->req_q_cnt -= req_cnt;
 	CMD_HANDLE(sp->cmd) = (unsigned char *)(unsigned long)(cnt + 1);
 
-	dprintk(2, "64bit_start: cmd=%p sp=%p CDB=%xm, handle %lx\n", cmd, sp,
+	dprintk(2, "start: cmd=%p sp=%p CDB=%xm, handle %lx\n", cmd, sp,
 		cmd->cmnd[0], (long)CMD_HANDLE(sp->cmd));
 	dprintk(2, "             bus %i, target %i, lun %i\n",
 		SCSI_BUS_32(cmd), SCSI_TCN_32(cmd), SCSI_LUN_32(cmd));
@@ -4626,7 +4628,7 @@ qla1280_probe_one(struct pci_dev *pdev, const struct pci_device_id *id)
 	if (pci_set_dma_mask(ha->pdev, (dma_addr_t) ~ 0ULL)) {
 		if (pci_set_dma_mask(ha->pdev, 0xffffffff)) {
 			printk(KERN_WARNING "scsi(%li): Unable to set a "
-			       " suitable DMA mask - aboring\n", ha->host_no);
+			       "suitable DMA mask - aborting\n", ha->host_no);
 			error = -ENODEV;
 			goto error_free_irq;
 		}
@@ -4636,14 +4638,14 @@ qla1280_probe_one(struct pci_dev *pdev, const struct pci_device_id *id)
 #else
 	if (pci_set_dma_mask(ha->pdev, 0xffffffff)) {
 		printk(KERN_WARNING "scsi(%li): Unable to set a "
-		       " suitable DMA mask - aboring\n", ha->host_no);
+		       "suitable DMA mask - aborting\n", ha->host_no);
 		error = -ENODEV;
 		goto error_free_irq;
 	}
 #endif
 
 	ha->request_ring = pci_alloc_consistent(ha->pdev,
-			((REQUEST_ENTRY_CNT + 1) * (sizeof(request_t))),
+			((REQUEST_ENTRY_CNT + 1) * sizeof(request_t)),
 			&ha->request_dma);
 	if (!ha->request_ring) {
 		printk(KERN_INFO "qla1280: Failed to get request memory\n");
@@ -4651,7 +4653,7 @@ qla1280_probe_one(struct pci_dev *pdev, const struct pci_device_id *id)
 	}
 
 	ha->response_ring = pci_alloc_consistent(ha->pdev,
-			((RESPONSE_ENTRY_CNT + 1) * (sizeof(struct response))),
+			((RESPONSE_ENTRY_CNT + 1) * sizeof(struct response)),
 			&ha->response_dma);
 	if (!ha->response_ring) {
 		printk(KERN_INFO "qla1280: Failed to get response memory\n");
@@ -4746,11 +4748,11 @@ qla1280_probe_one(struct pci_dev *pdev, const struct pci_device_id *id)
 #endif
  error_free_response_ring:
 	pci_free_consistent(ha->pdev,
-			((RESPONSE_ENTRY_CNT + 1) * (sizeof(struct response))),
+			((RESPONSE_ENTRY_CNT + 1) * sizeof(struct response)),
 			ha->response_ring, ha->response_dma);
  error_free_request_ring:
 	pci_free_consistent(ha->pdev,
-			((REQUEST_ENTRY_CNT + 1) * (sizeof(request_t))),
+			((REQUEST_ENTRY_CNT + 1) * sizeof(request_t)),
 			ha->request_ring, ha->request_dma);
  error_put_host:
 	scsi_host_put(host);

commit 8af50dcd22aa0a5840f18276ff10a6977abc3853
Author: Christoph Hellwig <hch@lst.de>
Date:   Mon Jul 4 17:48:19 2005 +0200

    [SCSI] qla1280: interupt posting for irq disabling/enabling
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Thiemo Seufer <ths@linux-mips.org>
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>

diff --git a/drivers/scsi/qla1280.c b/drivers/scsi/qla1280.c
index eb5543ef513b..58ecdc696675 100644
--- a/drivers/scsi/qla1280.c
+++ b/drivers/scsi/qla1280.c
@@ -1265,6 +1265,22 @@ qla1280_biosparam_old(Disk * disk, kdev_t dev, int geom[])
 	return qla1280_biosparam(disk->device, NULL, disk->capacity, geom);
 }
 #endif
+ 
+/* disable risc and host interrupts */
+static inline void
+qla1280_disable_intrs(struct scsi_qla_host *ha)
+{
+	WRT_REG_WORD(&ha->iobase->ictrl, 0);
+	RD_REG_WORD(&ha->iobase->ictrl);	/* PCI Posted Write flush */
+}
+
+/* enable risc and host interrupts */
+static inline void
+qla1280_enable_intrs(struct scsi_qla_host *ha)
+{
+	WRT_REG_WORD(&ha->iobase->ictrl, (ISP_EN_INT | ISP_EN_RISC));
+	RD_REG_WORD(&ha->iobase->ictrl);	/* PCI Posted Write flush */
+}
 
 /**************************************************************************
  * qla1280_intr_handler
@@ -1286,7 +1302,7 @@ qla1280_intr_handler(int irq, void *dev_id, struct pt_regs *regs)
 	ha->isr_count++;
 	reg = ha->iobase;
 
-	WRT_REG_WORD(&reg->ictrl, 0);	/* disable our interrupt. */
+	qla1280_disable_intrs(ha);
 
 	data = qla1280_debounce_register(&reg->istatus);
 	/* Check for pending interrupts. */
@@ -1299,8 +1315,7 @@ qla1280_intr_handler(int irq, void *dev_id, struct pt_regs *regs)
 
 	spin_unlock(HOST_LOCK);
 
-	/* enable our interrupt. */
-	WRT_REG_WORD(&reg->ictrl, (ISP_EN_INT | ISP_EN_RISC));
+	qla1280_enable_intrs(ha);
 
 	LEAVE_INTR("qla1280_intr_handler");
 	return IRQ_RETVAL(handled);
@@ -1613,38 +1628,6 @@ qla1280_return_status(struct response * sts, struct scsi_cmnd *cp)
 /*                QLogic ISP1280 Hardware Support Functions.                */
 /****************************************************************************/
 
- /*
-  * qla2100_enable_intrs
-  * qla2100_disable_intrs
-  *
-  * Input:
-  *      ha = adapter block pointer.
-  *
-  * Returns:
-  *      None
-  */
-static inline void
-qla1280_enable_intrs(struct scsi_qla_host *ha)
-{
-	struct device_reg __iomem *reg;
-
-	reg = ha->iobase;
-	/* enable risc and host interrupts */
-	WRT_REG_WORD(&reg->ictrl, (ISP_EN_INT | ISP_EN_RISC));
-	RD_REG_WORD(&reg->ictrl);	/* PCI Posted Write flush */
-}
-
-static inline void
-qla1280_disable_intrs(struct scsi_qla_host *ha)
-{
-	struct device_reg __iomem *reg;
-
-	reg = ha->iobase;
-	/* disable risc and host interrupts */
-	WRT_REG_WORD(&reg->ictrl, 0);
-	RD_REG_WORD(&reg->ictrl);	/* PCI Posted Write flush */
-}
-
 /*
  * qla1280_initialize_adapter
  *      Initialize board.
@@ -4751,7 +4734,7 @@ qla1280_probe_one(struct pci_dev *pdev, const struct pci_device_id *id)
 
 #if LINUX_VERSION_CODE >= 0x020600
  error_disable_adapter:
-	WRT_REG_WORD(&ha->iobase->ictrl, 0);
+	qla1280_disable_intrs(ha);
 #endif
  error_free_irq:
 	free_irq(pdev->irq, ha);
@@ -4788,7 +4771,7 @@ qla1280_remove_one(struct pci_dev *pdev)
 	scsi_remove_host(host);
 #endif
 
-	WRT_REG_WORD(&ha->iobase->ictrl, 0);
+	qla1280_disable_intrs(ha);
 
 	free_irq(pdev->irq, ha);
 

commit a6c42741ace2fee235b6902e76f3c86a01d32146
Author: Christoph Hellwig <hch@lst.de>
Date:   Mon Jul 4 17:48:13 2005 +0200

    [SCSI] qla1280: remove dead per-host flag variables
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Thiemo Seufer <ths@linux-mips.org>
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>

diff --git a/drivers/scsi/qla1280.c b/drivers/scsi/qla1280.c
index b993652bfa25..eb5543ef513b 100644
--- a/drivers/scsi/qla1280.c
+++ b/drivers/scsi/qla1280.c
@@ -996,7 +996,6 @@ qla1280_error_action(struct scsi_cmnd *cmd, enum action action)
 		break;
 
 	case ABORT_DEVICE:
-		ha->flags.in_reset = 1;
 		if (qla1280_verbose)
 			printk(KERN_INFO
 			       "scsi(%ld:%d:%d:%d): Queueing abort device "
@@ -1010,7 +1009,6 @@ qla1280_error_action(struct scsi_cmnd *cmd, enum action action)
 			printk(KERN_INFO
 			       "scsi(%ld:%d:%d:%d): Queueing device reset "
 			       "command.\n", ha->host_no, bus, target, lun);
-		ha->flags.in_reset = 1;
 		if (qla1280_device_reset(ha, bus, target) == 0)
 			result = SUCCESS;
 		break;
@@ -1019,7 +1017,6 @@ qla1280_error_action(struct scsi_cmnd *cmd, enum action action)
 		if (qla1280_verbose)
 			printk(KERN_INFO "qla1280(%ld:%d): Issuing BUS "
 			       "DEVICE RESET\n", ha->host_no, bus);
-		ha->flags.in_reset = 1;
 		if (qla1280_bus_reset(ha, bus == 0))
 			result = SUCCESS;
 
@@ -1047,7 +1044,6 @@ qla1280_error_action(struct scsi_cmnd *cmd, enum action action)
 
 	if (!list_empty(&ha->done_q))
 		qla1280_done(ha);
-	ha->flags.in_reset = 0;
 
 	/* If we didn't manage to issue the action, or we have no
 	 * command to wait for, exit here */
@@ -1636,7 +1632,6 @@ qla1280_enable_intrs(struct scsi_qla_host *ha)
 	/* enable risc and host interrupts */
 	WRT_REG_WORD(&reg->ictrl, (ISP_EN_INT | ISP_EN_RISC));
 	RD_REG_WORD(&reg->ictrl);	/* PCI Posted Write flush */
-	ha->flags.ints_enabled = 1;
 }
 
 static inline void
@@ -1648,7 +1643,6 @@ qla1280_disable_intrs(struct scsi_qla_host *ha)
 	/* disable risc and host interrupts */
 	WRT_REG_WORD(&reg->ictrl, 0);
 	RD_REG_WORD(&reg->ictrl);	/* PCI Posted Write flush */
-	ha->flags.ints_enabled = 0;
 }
 
 /*
@@ -1679,7 +1673,6 @@ qla1280_initialize_adapter(struct scsi_qla_host *ha)
 	ha->flags.reset_active = 0;
 	ha->flags.abort_isp_active = 0;
 
-	ha->flags.ints_enabled = 0;
 #if defined(CONFIG_IA64_GENERIC) || defined(CONFIG_IA64_SGI_SN2)
 	if (ia64_platform_is("sn2")) {
 		printk(KERN_INFO "scsi(%li): Enabling SN2 PCI DMA "

commit 117e4b27ebb1133072b1453145e60e576569e8af
Author: Nishanth Aravamudan <nacc@us.ibm.com>
Date:   Mon Jun 20 23:55:07 2005 +0200

    [SCSI] scsi/qla1280: replace schedule_timeout() with ssleep()
    
    Use ssleep() instead of schedule_timeout to guarantee the task
    delays as expected.
    
    Signed-off-by: Nishanth Aravamudan <nacc@us.ibm.com>
    Signed-off-by: Domen Puncer <domen@coderock.org>
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>

diff --git a/drivers/scsi/qla1280.c b/drivers/scsi/qla1280.c
index 1a4ce1c39478..b993652bfa25 100644
--- a/drivers/scsi/qla1280.c
+++ b/drivers/scsi/qla1280.c
@@ -2853,7 +2853,7 @@ qla1280_bus_reset(struct scsi_qla_host *ha, int bus)
 		ha->bus_settings[bus].failed_reset_count++;
 	} else {
 		spin_unlock_irq(HOST_LOCK);
-		schedule_timeout(reset_delay * HZ);
+		ssleep(reset_delay);
 		spin_lock_irq(HOST_LOCK);
 
 		ha->bus_settings[bus].scsi_bus_dead = 0;

commit df0ae2497ddefd72a87f3a3b34ff32455d7d4ae0
Author: Jeff Garzik <jgarzik@pobox.com>
Date:   Sat May 28 07:57:14 2005 -0400

    [SCSI] allow sleeping in ->eh_host_reset_handler()
    
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>

diff --git a/drivers/scsi/qla1280.c b/drivers/scsi/qla1280.c
index d26dbe2a33fe..1a4ce1c39478 100644
--- a/drivers/scsi/qla1280.c
+++ b/drivers/scsi/qla1280.c
@@ -1146,7 +1146,13 @@ qla1280_eh_bus_reset(struct scsi_cmnd *cmd)
 static int
 qla1280_eh_adapter_reset(struct scsi_cmnd *cmd)
 {
-	return qla1280_error_action(cmd, ADAPTER_RESET);
+	int rc;
+
+	spin_lock_irq(cmd->device->host->host_lock);
+	rc = qla1280_error_action(cmd, ADAPTER_RESET);
+	spin_unlock_irq(cmd->device->host->host_lock);
+
+	return rc;
 }
 
 static int

commit 68b3aa7c9805aee9005a8ca53c5e99177961fbb9
Author: Jeff Garzik <jgarzik@pobox.com>
Date:   Sat May 28 07:56:31 2005 -0400

    [SCSI] allow sleeping in ->eh_bus_reset_handler()
    
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>

diff --git a/drivers/scsi/qla1280.c b/drivers/scsi/qla1280.c
index 907a1e8cc880..d26dbe2a33fe 100644
--- a/drivers/scsi/qla1280.c
+++ b/drivers/scsi/qla1280.c
@@ -1130,7 +1130,13 @@ qla1280_eh_device_reset(struct scsi_cmnd *cmd)
 static int
 qla1280_eh_bus_reset(struct scsi_cmnd *cmd)
 {
-	return qla1280_error_action(cmd, BUS_RESET);
+	int rc;
+
+	spin_lock_irq(cmd->device->host->host_lock);
+	rc = qla1280_error_action(cmd, BUS_RESET);
+	spin_unlock_irq(cmd->device->host->host_lock);
+
+	return rc;
 }
 
 /**************************************************************************

commit 94d0e7b805961c44e4dc486ffc21075084bb7175
Author: Jeff Garzik <jgarzik@pobox.com>
Date:   Sat May 28 07:55:48 2005 -0400

    [SCSI] allow sleeping in ->eh_device_reset_handler()
    
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>

diff --git a/drivers/scsi/qla1280.c b/drivers/scsi/qla1280.c
index 638be81c4509..907a1e8cc880 100644
--- a/drivers/scsi/qla1280.c
+++ b/drivers/scsi/qla1280.c
@@ -1114,7 +1114,13 @@ qla1280_eh_abort(struct scsi_cmnd * cmd)
 static int
 qla1280_eh_device_reset(struct scsi_cmnd *cmd)
 {
-	return qla1280_error_action(cmd, DEVICE_RESET);
+	int rc;
+
+	spin_lock_irq(cmd->device->host->host_lock);
+	rc = qla1280_error_action(cmd, DEVICE_RESET);
+	spin_unlock_irq(cmd->device->host->host_lock);
+
+	return rc;
 }
 
 /**************************************************************************

commit 8fa728a26886f56a9ee10a44fea0ddda301d21c3
Author: Jeff Garzik <jgarzik@pobox.com>
Date:   Sat May 28 07:54:40 2005 -0400

    [SCSI] allow sleeping in ->eh_abort_handler()
    
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>

diff --git a/drivers/scsi/qla1280.c b/drivers/scsi/qla1280.c
index 653e589b7d7f..638be81c4509 100644
--- a/drivers/scsi/qla1280.c
+++ b/drivers/scsi/qla1280.c
@@ -1098,7 +1098,13 @@ qla1280_error_action(struct scsi_cmnd *cmd, enum action action)
 static int
 qla1280_eh_abort(struct scsi_cmnd * cmd)
 {
-	return qla1280_error_action(cmd, ABORT_COMMAND);
+	int rc;
+
+	spin_lock_irq(cmd->device->host->host_lock);
+	rc = qla1280_error_action(cmd, ABORT_COMMAND);
+	spin_unlock_irq(cmd->device->host->host_lock);
+
+	return rc;
 }
 
 /**************************************************************************

commit 7d0e11fb20b08790c71f5336b493662f952641c9
Author: Jeremy Higdon <jeremy@sgi.com>
Date:   Sun May 1 05:18:48 2005 -0700

    [SCSI] qla1280.c - fix result for device Busy and Queue Full
    
    I discovered that the qla1280 driver does not send the correct status
    to the midlayer when it gets Queue Full or Busy from a device.
    
    Signed-off-by: Jeremy Higdon <jeremy@sgi.com>
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>

diff --git a/drivers/scsi/qla1280.c b/drivers/scsi/qla1280.c
index 4ad280814990..653e589b7d7f 100644
--- a/drivers/scsi/qla1280.c
+++ b/drivers/scsi/qla1280.c
@@ -4038,11 +4038,10 @@ qla1280_status_entry(struct scsi_qla_host *ha, struct response *pkt,
 			scsi_status, handle);
 	}
 
-	/* Target busy */
-	if (scsi_status & SS_BUSY_CONDITION &&
-	    scsi_status != SS_RESERVE_CONFLICT) {
-		CMD_RESULT(cmd) =
-			DID_BUS_BUSY << 16 | (scsi_status & 0xff);
+	/* Target busy or queue full */
+	if ((scsi_status & 0xFF) == SAM_STAT_TASK_SET_FULL ||
+	    (scsi_status & 0xFF) == SAM_STAT_BUSY) {
+		CMD_RESULT(cmd) = scsi_status & 0xff;
 	} else {
 
 		/* Save ISP completion status */

commit 1da177e4c3f41524e886b7f1b8a0c1fc7321cac2
Author: Linus Torvalds <torvalds@ppc970.osdl.org>
Date:   Sat Apr 16 15:20:36 2005 -0700

    Linux-2.6.12-rc2
    
    Initial git repository build. I'm not bothering with the full history,
    even though we have it. We can create a separate "historical" git
    archive of that later if we want to, and in the meantime it's about
    3.2GB when imported into git - space that would just make the early
    git days unnecessarily complicated, when we don't have a lot of good
    infrastructure for it.
    
    Let it rip!

diff --git a/drivers/scsi/qla1280.c b/drivers/scsi/qla1280.c
new file mode 100644
index 000000000000..4ad280814990
--- /dev/null
+++ b/drivers/scsi/qla1280.c
@@ -0,0 +1,4863 @@
+/******************************************************************************
+*                  QLOGIC LINUX SOFTWARE
+*
+* QLogic  QLA1280 (Ultra2)  and  QLA12160 (Ultra3) SCSI driver
+* Copyright (C) 2000 Qlogic Corporation (www.qlogic.com)
+* Copyright (C) 2001-2004 Jes Sorensen, Wild Open Source Inc.
+* Copyright (C) 2003-2004 Christoph Hellwig
+*
+* This program is free software; you can redistribute it and/or modify it
+* under the terms of the GNU General Public License as published by the
+* Free Software Foundation; either version 2, or (at your option) any
+* later version.
+*
+* This program is distributed in the hope that it will be useful, but
+* WITHOUT ANY WARRANTY; without even the implied warranty of
+* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+* General Public License for more details.
+*
+******************************************************************************/
+#define QLA1280_VERSION      "3.25"
+/*****************************************************************************
+    Revision History:
+    Rev  3.25.1, February 10, 2005 Christoph Hellwig
+	- use pci_map_single to map non-S/G requests
+	- remove qla1280_proc_info
+    Rev  3.25, September 28, 2004, Christoph Hellwig
+	- add support for ISP1020/1040
+	- don't include "scsi.h" anymore for 2.6.x
+    Rev  3.24.4 June 7, 2004 Christoph Hellwig
+	- restructure firmware loading, cleanup initialization code
+	- prepare support for ISP1020/1040 chips
+    Rev  3.24.3 January 19, 2004, Jes Sorensen
+	- Handle PCI DMA mask settings correctly
+	- Correct order of error handling in probe_one, free_irq should not
+	  be called if request_irq failed
+    Rev  3.24.2 January 19, 2004, James Bottomley & Andrew Vasquez
+	- Big endian fixes (James)
+	- Remove bogus IOCB content on zero data transfer commands (Andrew)
+    Rev  3.24.1 January 5, 2004, Jes Sorensen
+	- Initialize completion queue to avoid OOPS on probe
+	- Handle interrupts during mailbox testing
+    Rev  3.24 November 17, 2003, Christoph Hellwig
+    	- use struct list_head for completion queue
+	- avoid old Scsi_FOO typedefs
+	- cleanup 2.4 compat glue a bit
+	- use <scsi/scsi_*.h> headers on 2.6 instead of "scsi.h"
+	- make initialization for memory mapped vs port I/O more similar
+	- remove broken pci config space manipulation
+	- kill more cruft
+	- this is an almost perfect 2.6 scsi driver now! ;)
+    Rev  3.23.39 December 17, 2003, Jes Sorensen
+	- Delete completion queue from srb if mailbox command failed to
+	  to avoid qla1280_done completeting qla1280_error_action's
+	  obsolete context
+	- Reduce arguments for qla1280_done
+    Rev  3.23.38 October 18, 2003, Christoph Hellwig
+	- Convert to new-style hotplugable driver for 2.6
+	- Fix missing scsi_unregister/scsi_host_put on HBA removal
+	- Kill some more cruft
+    Rev  3.23.37 October 1, 2003, Jes Sorensen
+	- Make MMIO depend on CONFIG_X86_VISWS instead of yet another
+	  random CONFIG option
+	- Clean up locking in probe path
+    Rev  3.23.36 October 1, 2003, Christoph Hellwig
+	- queuecommand only ever receives new commands - clear flags
+	- Reintegrate lost fixes from Linux 2.5
+    Rev  3.23.35 August 14, 2003, Jes Sorensen
+	- Build against 2.6
+    Rev  3.23.34 July 23, 2003, Jes Sorensen
+	- Remove pointless TRUE/FALSE macros
+	- Clean up vchan handling
+    Rev  3.23.33 July 3, 2003, Jes Sorensen
+	- Don't define register access macros before define determining MMIO.
+	  This just happend to work out on ia64 but not elsewhere.
+	- Don't try and read from the card while it is in reset as
+	  it won't respond and causes an MCA
+    Rev  3.23.32 June 23, 2003, Jes Sorensen
+	- Basic support for boot time arguments
+    Rev  3.23.31 June 8, 2003, Jes Sorensen
+	- Reduce boot time messages
+    Rev  3.23.30 June 6, 2003, Jes Sorensen
+	- Do not enable sync/wide/ppr before it has been determined
+	  that the target device actually supports it
+	- Enable DMA arbitration for multi channel controllers
+    Rev  3.23.29 June 3, 2003, Jes Sorensen
+	- Port to 2.5.69
+    Rev  3.23.28 June 3, 2003, Jes Sorensen
+	- Eliminate duplicate marker commands on bus resets
+	- Handle outstanding commands appropriately on bus/device resets
+    Rev  3.23.27 May 28, 2003, Jes Sorensen
+	- Remove bogus input queue code, let the Linux SCSI layer do the work
+	- Clean up NVRAM handling, only read it once from the card
+	- Add a number of missing default nvram parameters
+    Rev  3.23.26 Beta May 28, 2003, Jes Sorensen
+	- Use completion queue for mailbox commands instead of busy wait
+    Rev  3.23.25 Beta May 27, 2003, James Bottomley
+	- Migrate to use new error handling code
+    Rev  3.23.24 Beta May 21, 2003, James Bottomley
+	- Big endian support
+	- Cleanup data direction code
+    Rev  3.23.23 Beta May 12, 2003, Jes Sorensen
+	- Switch to using MMIO instead of PIO
+    Rev  3.23.22 Beta April 15, 2003, Jes Sorensen
+	- Fix PCI parity problem with 12160 during reset.
+    Rev  3.23.21 Beta April 14, 2003, Jes Sorensen
+	- Use pci_map_page()/pci_unmap_page() instead of map_single version.
+    Rev  3.23.20 Beta April 9, 2003, Jes Sorensen
+	- Remove < 2.4.x support
+	- Introduce HOST_LOCK to make the spin lock changes portable.
+	- Remove a bunch of idiotic and unnecessary typedef's
+	- Kill all leftovers of target-mode support which never worked anyway
+    Rev  3.23.19 Beta April 11, 2002, Linus Torvalds
+	- Do qla1280_pci_config() before calling request_irq() and
+	  request_region()
+	- Use pci_dma_hi32() to handle upper word of DMA addresses instead
+	  of large shifts
+	- Hand correct arguments to free_irq() in case of failure
+    Rev  3.23.18 Beta April 11, 2002, Jes Sorensen
+	- Run source through Lindent and clean up the output
+    Rev  3.23.17 Beta April 11, 2002, Jes Sorensen
+	- Update SCSI firmware to qla1280 v8.15.00 and qla12160 v10.04.32
+    Rev  3.23.16 Beta March 19, 2002, Jes Sorensen
+	- Rely on mailbox commands generating interrupts - do not
+	  run qla1280_isr() from ql1280_mailbox_command()
+	- Remove device_reg_t
+	- Integrate ql12160_set_target_parameters() with 1280 version
+	- Make qla1280_setup() non static
+	- Do not call qla1280_check_for_dead_scsi_bus() on every I/O request
+	  sent to the card - this command pauses the firmare!!!
+    Rev  3.23.15 Beta March 19, 2002, Jes Sorensen
+	- Clean up qla1280.h - remove obsolete QL_DEBUG_LEVEL_x definitions
+	- Remove a pile of pointless and confusing (srb_t **) and
+	  (scsi_lu_t *) typecasts
+	- Explicit mark that we do not use the new error handling (for now)
+	- Remove scsi_qla_host_t and use 'struct' instead
+	- Remove in_abort, watchdog_enabled, dpc, dpc_sched, bios_enabled,
+	  pci_64bit_slot flags which weren't used for anything anyway
+	- Grab host->host_lock while calling qla1280_isr() from abort()
+	- Use spin_lock()/spin_unlock() in qla1280_intr_handler() - we
+	  do not need to save/restore flags in the interrupt handler
+	- Enable interrupts early (before any mailbox access) in preparation
+	  for cleaning up the mailbox handling
+    Rev  3.23.14 Beta March 14, 2002, Jes Sorensen
+	- Further cleanups. Remove all trace of QL_DEBUG_LEVEL_x and replace
+	  it with proper use of dprintk().
+	- Make qla1280_print_scsi_cmd() and qla1280_dump_buffer() both take
+	  a debug level argument to determine if data is to be printed
+	- Add KERN_* info to printk()
+    Rev  3.23.13 Beta March 14, 2002, Jes Sorensen
+	- Significant cosmetic cleanups
+	- Change debug code to use dprintk() and remove #if mess
+    Rev  3.23.12 Beta March 13, 2002, Jes Sorensen
+	- More cosmetic cleanups, fix places treating return as function
+	- use cpu_relax() in qla1280_debounce_register()
+    Rev  3.23.11 Beta March 13, 2002, Jes Sorensen
+	- Make it compile under 2.5.5
+    Rev  3.23.10 Beta October 1, 2001, Jes Sorensen
+	- Do no typecast short * to long * in QL1280BoardTbl, this
+	  broke miserably on big endian boxes
+    Rev  3.23.9 Beta September 30, 2001, Jes Sorensen
+	- Remove pre 2.2 hack for checking for reentrance in interrupt handler
+	- Make data types used to receive from SCSI_{BUS,TCN,LUN}_32
+	  unsigned int to match the types from struct scsi_cmnd
+    Rev  3.23.8 Beta September 29, 2001, Jes Sorensen
+	- Remove bogus timer_t typedef from qla1280.h
+	- Remove obsolete pre 2.2 PCI setup code, use proper #define's
+	  for PCI_ values, call pci_set_master()
+	- Fix memleak of qla1280_buffer on module unload
+	- Only compile module parsing code #ifdef MODULE - should be
+	  changed to use individual MODULE_PARM's later
+	- Remove dummy_buffer that was never modified nor printed
+	- ENTER()/LEAVE() are noops unless QL_DEBUG_LEVEL_3, hence remove
+	  #ifdef QL_DEBUG_LEVEL_3/#endif around ENTER()/LEAVE() calls
+	- Remove \r from print statements, this is Linux, not DOS
+	- Remove obsolete QLA1280_{SCSILU,INTR,RING}_{LOCK,UNLOCK}
+	  dummy macros
+	- Remove C++ compile hack in header file as Linux driver are not
+	  supposed to be compiled as C++
+	- Kill MS_64BITS macro as it makes the code more readable
+	- Remove unnecessary flags.in_interrupts bit
+    Rev  3.23.7 Beta August 20, 2001, Jes Sorensen
+	- Dont' check for set flags on q->q_flag one by one in qla1280_next()
+        - Check whether the interrupt was generated by the QLA1280 before
+          doing any processing
+	- qla1280_status_entry(): Only zero out part of sense_buffer that
+	  is not being copied into
+	- Remove more superflouous typecasts
+	- qla1280_32bit_start_scsi() replace home-brew memcpy() with memcpy()
+    Rev  3.23.6 Beta August 20, 2001, Tony Luck, Intel
+        - Don't walk the entire list in qla1280_putq_t() just to directly
+	  grab the pointer to the last element afterwards
+    Rev  3.23.5 Beta August 9, 2001, Jes Sorensen
+	- Don't use SA_INTERRUPT, it's use is deprecated for this kinda driver
+    Rev  3.23.4 Beta August 8, 2001, Jes Sorensen
+	- Set dev->max_sectors to 1024
+    Rev  3.23.3 Beta August 6, 2001, Jes Sorensen
+	- Provide compat macros for pci_enable_device(), pci_find_subsys()
+	  and scsi_set_pci_device()
+	- Call scsi_set_pci_device() for all devices
+	- Reduce size of kernel version dependent device probe code
+	- Move duplicate probe/init code to separate function
+	- Handle error if qla1280_mem_alloc() fails
+	- Kill OFFSET() macro and use Linux's PCI definitions instead
+        - Kill private structure defining PCI config space (struct config_reg)
+	- Only allocate I/O port region if not in MMIO mode
+	- Remove duplicate (unused) sanity check of sife of srb_t
+    Rev  3.23.2 Beta August 6, 2001, Jes Sorensen
+	- Change home-brew memset() implementations to use memset()
+        - Remove all references to COMTRACE() - accessing a PC's COM2 serial
+          port directly is not legal under Linux.
+    Rev  3.23.1 Beta April 24, 2001, Jes Sorensen
+        - Remove pre 2.2 kernel support
+        - clean up 64 bit DMA setting to use 2.4 API (provide backwards compat)
+        - Fix MMIO access to use readl/writel instead of directly
+          dereferencing pointers
+        - Nuke MSDOS debugging code
+        - Change true/false data types to int from uint8_t
+        - Use int for counters instead of uint8_t etc.
+        - Clean up size & byte order conversion macro usage
+    Rev  3.23 Beta January 11, 2001 BN Qlogic
+        - Added check of device_id when handling non
+          QLA12160s during detect().
+    Rev  3.22 Beta January 5, 2001 BN Qlogic
+        - Changed queue_task() to schedule_task()
+          for kernels 2.4.0 and higher.
+          Note: 2.4.0-testxx kernels released prior to
+                the actual 2.4.0 kernel release on January 2001
+                will get compile/link errors with schedule_task().
+                Please update your kernel to released 2.4.0 level,
+                or comment lines in this file flagged with  3.22
+                to resolve compile/link error of schedule_task().
+        - Added -DCONFIG_SMP in addition to -D__SMP__
+          in Makefile for 2.4.0 builds of driver as module.
+    Rev  3.21 Beta January 4, 2001 BN Qlogic
+        - Changed criteria of 64/32 Bit mode of HBA
+          operation according to BITS_PER_LONG rather
+          than HBA's NVRAM setting of >4Gig memory bit;
+          so that the HBA auto-configures without the need
+          to setup each system individually.
+    Rev  3.20 Beta December 5, 2000 BN Qlogic
+        - Added priority handling to IA-64  onboard SCSI
+          ISP12160 chip for kernels greater than 2.3.18.
+        - Added irqrestore for qla1280_intr_handler.
+        - Enabled /proc/scsi/qla1280 interface.
+        - Clear /proc/scsi/qla1280 counters in detect().
+    Rev  3.19 Beta October 13, 2000 BN Qlogic
+        - Declare driver_template for new kernel
+          (2.4.0 and greater) scsi initialization scheme.
+        - Update /proc/scsi entry for 2.3.18 kernels and
+          above as qla1280
+    Rev  3.18 Beta October 10, 2000 BN Qlogic
+        - Changed scan order of adapters to map
+          the QLA12160 followed by the QLA1280.
+    Rev  3.17 Beta September 18, 2000 BN Qlogic
+        - Removed warnings for 32 bit 2.4.x compiles
+        - Corrected declared size for request and response
+          DMA addresses that are kept in each ha
+    Rev. 3.16 Beta  August 25, 2000   BN  Qlogic
+        - Corrected 64 bit addressing issue on IA-64
+          where the upper 32 bits were not properly
+          passed to the RISC engine.
+    Rev. 3.15 Beta  August 22, 2000   BN  Qlogic
+        - Modified qla1280_setup_chip to properly load
+          ISP firmware for greater that 4 Gig memory on IA-64
+    Rev. 3.14 Beta  August 16, 2000   BN  Qlogic
+        - Added setting of dma_mask to full 64 bit
+          if flags.enable_64bit_addressing is set in NVRAM
+    Rev. 3.13 Beta  August 16, 2000   BN  Qlogic
+        - Use new PCI DMA mapping APIs for 2.4.x kernel
+    Rev. 3.12       July 18, 2000    Redhat & BN Qlogic
+        - Added check of pci_enable_device to detect() for 2.3.x
+        - Use pci_resource_start() instead of
+          pdev->resource[0].start in detect() for 2.3.x
+        - Updated driver version
+    Rev. 3.11       July 14, 2000    BN  Qlogic
+	- Updated SCSI Firmware to following versions:
+	  qla1x80:   8.13.08
+	  qla1x160:  10.04.08
+	- Updated driver version to 3.11
+    Rev. 3.10    June 23, 2000   BN Qlogic
+        - Added filtering of AMI SubSys Vendor ID devices
+    Rev. 3.9
+        - DEBUG_QLA1280 undefined and  new version  BN Qlogic
+    Rev. 3.08b      May 9, 2000    MD Dell
+        - Added logic to check against AMI subsystem vendor ID
+	Rev. 3.08       May 4, 2000    DG  Qlogic
+        - Added logic to check for PCI subsystem ID.
+	Rev. 3.07       Apr 24, 2000    DG & BN  Qlogic
+	   - Updated SCSI Firmware to following versions:
+	     qla12160:   10.01.19
+		 qla1280:     8.09.00
+	Rev. 3.06       Apr 12, 2000    DG & BN  Qlogic
+	   - Internal revision; not released
+    Rev. 3.05       Mar 28, 2000    DG & BN  Qlogic
+       - Edit correction for virt_to_bus and PROC.
+    Rev. 3.04       Mar 28, 2000    DG & BN  Qlogic
+       - Merge changes from ia64 port.
+    Rev. 3.03       Mar 28, 2000    BN  Qlogic
+       - Increase version to reflect new code drop with compile fix
+         of issue with inclusion of linux/spinlock for 2.3 kernels
+    Rev. 3.02       Mar 15, 2000    BN  Qlogic
+       - Merge qla1280_proc_info from 2.10 code base
+    Rev. 3.01       Feb 10, 2000    BN  Qlogic
+       - Corrected code to compile on a 2.2.x kernel.
+    Rev. 3.00       Jan 17, 2000    DG  Qlogic
+	   - Added 64-bit support.
+    Rev. 2.07       Nov 9, 1999     DG  Qlogic
+	   - Added new routine to set target parameters for ISP12160.
+    Rev. 2.06       Sept 10, 1999     DG  Qlogic
+       - Added support for ISP12160 Ultra 3 chip.
+    Rev. 2.03       August 3, 1999    Fred Lewis, Intel DuPont
+	- Modified code to remove errors generated when compiling with
+	  Cygnus IA64 Compiler.
+        - Changed conversion of pointers to unsigned longs instead of integers.
+        - Changed type of I/O port variables from uint32_t to unsigned long.
+        - Modified OFFSET macro to work with 64-bit as well as 32-bit.
+        - Changed sprintf and printk format specifiers for pointers to %p.
+        - Changed some int to long type casts where needed in sprintf & printk.
+        - Added l modifiers to sprintf and printk format specifiers for longs.
+        - Removed unused local variables.
+    Rev. 1.20       June 8, 1999      DG,  Qlogic
+         Changes to support RedHat release 6.0 (kernel 2.2.5).
+       - Added SCSI exclusive access lock (io_request_lock) when accessing
+         the adapter.
+       - Added changes for the new LINUX interface template. Some new error
+         handling routines have been added to the template, but for now we
+         will use the old ones.
+    -   Initial Beta Release.
+*****************************************************************************/
+
+
+#include <linux/config.h>
+#include <linux/module.h>
+
+#include <linux/version.h>
+#include <linux/types.h>
+#include <linux/string.h>
+#include <linux/errno.h>
+#include <linux/kernel.h>
+#include <linux/ioport.h>
+#include <linux/delay.h>
+#include <linux/timer.h>
+#include <linux/sched.h>
+#include <linux/pci.h>
+#include <linux/proc_fs.h>
+#include <linux/stat.h>
+#include <linux/slab.h>
+#include <linux/pci_ids.h>
+#include <linux/interrupt.h>
+#include <linux/init.h>
+
+#include <asm/io.h>
+#include <asm/irq.h>
+#include <asm/byteorder.h>
+#include <asm/processor.h>
+#include <asm/types.h>
+#include <asm/system.h>
+
+#if LINUX_VERSION_CODE >= 0x020545
+#include <scsi/scsi.h>
+#include <scsi/scsi_cmnd.h>
+#include <scsi/scsi_device.h>
+#include <scsi/scsi_host.h>
+#include <scsi/scsi_tcq.h>
+#else
+#include <linux/blk.h>
+#include "scsi.h"
+#include <scsi/scsi_host.h>
+#include "sd.h"
+#endif
+
+#if defined(CONFIG_IA64_GENERIC) || defined(CONFIG_IA64_SGI_SN2)
+#include <asm/sn/io.h>
+#endif
+
+#if LINUX_VERSION_CODE < 0x020407
+#error "Kernels older than 2.4.7 are no longer supported"
+#endif
+
+
+/*
+ * Compile time Options:
+ *            0 - Disable and 1 - Enable
+ */
+#define  DEBUG_QLA1280_INTR	0
+#define  DEBUG_PRINT_NVRAM	0
+#define  DEBUG_QLA1280		0
+
+/*
+ * The SGI VISWS is broken and doesn't support MMIO ;-(
+ */
+#ifdef CONFIG_X86_VISWS
+#define	MEMORY_MAPPED_IO	0
+#else
+#define	MEMORY_MAPPED_IO	1
+#endif
+
+#define UNIQUE_FW_NAME
+#include "qla1280.h"
+#include "ql12160_fw.h"		/* ISP RISC codes */
+#include "ql1280_fw.h"
+#include "ql1040_fw.h"
+
+
+/*
+ * Missing PCI ID's
+ */
+#ifndef PCI_DEVICE_ID_QLOGIC_ISP1080
+#define PCI_DEVICE_ID_QLOGIC_ISP1080	0x1080
+#endif
+#ifndef PCI_DEVICE_ID_QLOGIC_ISP1240
+#define PCI_DEVICE_ID_QLOGIC_ISP1240	0x1240
+#endif
+#ifndef PCI_DEVICE_ID_QLOGIC_ISP1280
+#define PCI_DEVICE_ID_QLOGIC_ISP1280	0x1280
+#endif
+#ifndef PCI_DEVICE_ID_QLOGIC_ISP10160
+#define PCI_DEVICE_ID_QLOGIC_ISP10160	0x1016
+#endif
+#ifndef PCI_DEVICE_ID_QLOGIC_ISP12160
+#define PCI_DEVICE_ID_QLOGIC_ISP12160	0x1216
+#endif
+
+#ifndef PCI_VENDOR_ID_AMI
+#define PCI_VENDOR_ID_AMI               0x101e
+#endif
+
+#ifndef BITS_PER_LONG
+#error "BITS_PER_LONG not defined!"
+#endif
+#if (BITS_PER_LONG == 64) || defined CONFIG_HIGHMEM
+#define QLA_64BIT_PTR	1
+#endif
+
+#ifdef QLA_64BIT_PTR
+#define pci_dma_hi32(a)			((a >> 16) >> 16)
+#else
+#define pci_dma_hi32(a)			0
+#endif
+#define pci_dma_lo32(a)			(a & 0xffffffff)
+
+#define NVRAM_DELAY()			udelay(500)	/* 2 microseconds */
+
+#if LINUX_VERSION_CODE < 0x020500
+#define HOST_LOCK			&io_request_lock
+#define irqreturn_t			void
+#define IRQ_RETVAL(foo)
+#define MSG_ORDERED_TAG			1
+
+#define DMA_BIDIRECTIONAL	SCSI_DATA_UNKNOWN
+#define DMA_TO_DEVICE		SCSI_DATA_WRITE
+#define DMA_FROM_DEVICE		SCSI_DATA_READ
+#define DMA_NONE		SCSI_DATA_NONE
+
+#ifndef HAVE_SECTOR_T
+typedef unsigned int sector_t;
+#endif
+
+static inline void
+scsi_adjust_queue_depth(struct scsi_device *device, int tag, int depth)
+{
+	if (tag) {
+		device->tagged_queue = tag;
+		device->current_tag = 0;
+	}
+	device->queue_depth = depth;
+}
+static inline struct Scsi_Host *scsi_host_alloc(Scsi_Host_Template *t, size_t s)
+{
+	return scsi_register(t, s);
+}
+static inline void scsi_host_put(struct Scsi_Host *h)
+{
+	scsi_unregister(h);
+}
+#else
+#define HOST_LOCK			ha->host->host_lock
+#endif
+#if LINUX_VERSION_CODE < 0x020600
+#define DEV_SIMPLE_TAGS(device)		device->tagged_queue
+/*
+ * Hack around that qla1280_remove_one is called from
+ * qla1280_release in 2.4
+ */
+#undef __devexit
+#define __devexit
+#else
+#define DEV_SIMPLE_TAGS(device)		device->simple_tags
+#endif
+#if defined(__ia64__) && !defined(ia64_platform_is)
+#define ia64_platform_is(foo)		(!strcmp(x, platform_name))
+#endif
+
+
+#define IS_ISP1040(ha) (ha->pdev->device == PCI_DEVICE_ID_QLOGIC_ISP1020)
+#define IS_ISP1x40(ha) (ha->pdev->device == PCI_DEVICE_ID_QLOGIC_ISP1020 || \
+			ha->pdev->device == PCI_DEVICE_ID_QLOGIC_ISP1240)
+#define IS_ISP1x160(ha)        (ha->pdev->device == PCI_DEVICE_ID_QLOGIC_ISP10160 || \
+				ha->pdev->device == PCI_DEVICE_ID_QLOGIC_ISP12160)
+
+
+static int qla1280_probe_one(struct pci_dev *, const struct pci_device_id *);
+static void qla1280_remove_one(struct pci_dev *);
+
+/*
+ *  QLogic Driver Support Function Prototypes.
+ */
+static void qla1280_done(struct scsi_qla_host *);
+#if LINUX_VERSION_CODE < 0x020545
+static void qla1280_get_target_options(struct scsi_cmnd *, struct scsi_qla_host *);
+#endif
+static int qla1280_get_token(char *);
+static int qla1280_setup(char *s) __init;
+
+/*
+ *  QLogic ISP1280 Hardware Support Function Prototypes.
+ */
+static int qla1280_load_firmware(struct scsi_qla_host *);
+static int qla1280_init_rings(struct scsi_qla_host *);
+static int qla1280_nvram_config(struct scsi_qla_host *);
+static int qla1280_mailbox_command(struct scsi_qla_host *,
+				   uint8_t, uint16_t *);
+static int qla1280_bus_reset(struct scsi_qla_host *, int);
+static int qla1280_device_reset(struct scsi_qla_host *, int, int);
+static int qla1280_abort_device(struct scsi_qla_host *, int, int, int);
+static int qla1280_abort_command(struct scsi_qla_host *, struct srb *, int);
+static int qla1280_abort_isp(struct scsi_qla_host *);
+#ifdef QLA_64BIT_PTR
+static int qla1280_64bit_start_scsi(struct scsi_qla_host *, struct srb *);
+#else
+static int qla1280_32bit_start_scsi(struct scsi_qla_host *, struct srb *);
+#endif
+static void qla1280_nv_write(struct scsi_qla_host *, uint16_t);
+static void qla1280_poll(struct scsi_qla_host *);
+static void qla1280_reset_adapter(struct scsi_qla_host *);
+static void qla1280_marker(struct scsi_qla_host *, int, int, int, u8);
+static void qla1280_isp_cmd(struct scsi_qla_host *);
+static void qla1280_isr(struct scsi_qla_host *, struct list_head *);
+static void qla1280_rst_aen(struct scsi_qla_host *);
+static void qla1280_status_entry(struct scsi_qla_host *, struct response *,
+				 struct list_head *);
+static void qla1280_error_entry(struct scsi_qla_host *, struct response *,
+				struct list_head *);
+static uint16_t qla1280_get_nvram_word(struct scsi_qla_host *, uint32_t);
+static uint16_t qla1280_nvram_request(struct scsi_qla_host *, uint32_t);
+static uint16_t qla1280_debounce_register(volatile uint16_t __iomem *);
+static request_t *qla1280_req_pkt(struct scsi_qla_host *);
+static int qla1280_check_for_dead_scsi_bus(struct scsi_qla_host *,
+					   unsigned int);
+static void qla1280_get_target_parameters(struct scsi_qla_host *,
+					   struct scsi_device *);
+static int qla1280_set_target_parameters(struct scsi_qla_host *, int, int);
+
+
+static struct qla_driver_setup driver_setup;
+
+/*
+ * convert scsi data direction to request_t control flags
+ */
+static inline uint16_t
+qla1280_data_direction(struct scsi_cmnd *cmnd)
+{
+	switch(cmnd->sc_data_direction) {
+	case DMA_FROM_DEVICE:
+		return BIT_5;
+	case DMA_TO_DEVICE:
+		return BIT_6;
+	case DMA_BIDIRECTIONAL:
+		return BIT_5 | BIT_6;
+	/*
+	 * We could BUG() on default here if one of the four cases aren't
+	 * met, but then again if we receive something like that from the
+	 * SCSI layer we have more serious problems. This shuts up GCC.
+	 */
+	case DMA_NONE:
+	default:
+		return 0;
+	}
+}
+		
+#if DEBUG_QLA1280
+static void __qla1280_print_scsi_cmd(struct scsi_cmnd * cmd);
+static void __qla1280_dump_buffer(char *, int);
+#endif
+
+
+/*
+ * insmod needs to find the variable and make it point to something
+ */
+#ifdef MODULE
+static char *qla1280;
+
+/* insmod qla1280 options=verbose" */
+module_param(qla1280, charp, 0);
+#else
+__setup("qla1280=", qla1280_setup);
+#endif
+
+
+/*
+ * We use the scsi_pointer structure that's included with each scsi_command
+ * to overlay our struct srb over it. qla1280_init() checks that a srb is not
+ * bigger than a scsi_pointer.
+ */
+
+#define	CMD_SP(Cmnd)		&Cmnd->SCp
+#define	CMD_CDBLEN(Cmnd)	Cmnd->cmd_len
+#define	CMD_CDBP(Cmnd)		Cmnd->cmnd
+#define	CMD_SNSP(Cmnd)		Cmnd->sense_buffer
+#define	CMD_SNSLEN(Cmnd)	sizeof(Cmnd->sense_buffer)
+#define	CMD_RESULT(Cmnd)	Cmnd->result
+#define	CMD_HANDLE(Cmnd)	Cmnd->host_scribble
+#if LINUX_VERSION_CODE < 0x020545
+#define CMD_REQUEST(Cmnd)	Cmnd->request.cmd
+#else
+#define CMD_REQUEST(Cmnd)	Cmnd->request->cmd
+#endif
+
+#define CMD_HOST(Cmnd)		Cmnd->device->host
+#define SCSI_BUS_32(Cmnd)	Cmnd->device->channel
+#define SCSI_TCN_32(Cmnd)	Cmnd->device->id
+#define SCSI_LUN_32(Cmnd)	Cmnd->device->lun
+
+
+/*****************************************/
+/*   ISP Boards supported by this driver */
+/*****************************************/
+
+struct qla_boards {
+	unsigned char name[9];	/* Board ID String */
+	int numPorts;		/* Number of SCSI ports */
+	unsigned short *fwcode;	/* pointer to FW array         */
+	unsigned short *fwlen;	/* number of words in array    */
+	unsigned short *fwstart;	/* start address for F/W       */
+	unsigned char *fwver;	/* Ptr to F/W version array    */
+};
+
+/* NOTE: the last argument in each entry is used to index ql1280_board_tbl */
+static struct pci_device_id qla1280_pci_tbl[] = {
+	{PCI_VENDOR_ID_QLOGIC, PCI_DEVICE_ID_QLOGIC_ISP12160,
+		PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},
+#ifdef CONFIG_SCSI_QLOGIC_1280_1040
+	{PCI_VENDOR_ID_QLOGIC, PCI_DEVICE_ID_QLOGIC_ISP1020,
+		PCI_ANY_ID, PCI_ANY_ID, 0, 0, 1},
+#endif
+	{PCI_VENDOR_ID_QLOGIC, PCI_DEVICE_ID_QLOGIC_ISP1080,
+		PCI_ANY_ID, PCI_ANY_ID, 0, 0, 2},
+	{PCI_VENDOR_ID_QLOGIC, PCI_DEVICE_ID_QLOGIC_ISP1240,
+		PCI_ANY_ID, PCI_ANY_ID, 0, 0, 3},
+	{PCI_VENDOR_ID_QLOGIC, PCI_DEVICE_ID_QLOGIC_ISP1280,
+		PCI_ANY_ID, PCI_ANY_ID, 0, 0, 4},
+	{PCI_VENDOR_ID_QLOGIC, PCI_DEVICE_ID_QLOGIC_ISP10160,
+		PCI_ANY_ID, PCI_ANY_ID, 0, 0, 5},
+	{0,}
+};
+MODULE_DEVICE_TABLE(pci, qla1280_pci_tbl);
+
+static struct qla_boards ql1280_board_tbl[] = {
+	/* Name ,  Number of ports, FW details */
+	{"QLA12160", 2, &fw12160i_code01[0], &fw12160i_length01,
+	 &fw12160i_addr01, &fw12160i_version_str[0]},
+	{"QLA1040", 1, &risc_code01[0], &risc_code_length01,
+	 &risc_code_addr01, &firmware_version[0]},
+	{"QLA1080", 1, &fw1280ei_code01[0], &fw1280ei_length01,
+	 &fw1280ei_addr01, &fw1280ei_version_str[0]},
+	{"QLA1240", 2, &fw1280ei_code01[0], &fw1280ei_length01,
+	 &fw1280ei_addr01, &fw1280ei_version_str[0]},
+	{"QLA1280", 2, &fw1280ei_code01[0], &fw1280ei_length01,
+	 &fw1280ei_addr01, &fw1280ei_version_str[0]},
+	{"QLA10160", 1, &fw12160i_code01[0], &fw12160i_length01,
+	 &fw12160i_addr01, &fw12160i_version_str[0]},
+	{"        ", 0}
+};
+
+static int qla1280_verbose = 1;
+
+#if DEBUG_QLA1280
+static int ql_debug_level = 1;
+#define dprintk(level, format, a...)	\
+	do { if (ql_debug_level >= level) printk(KERN_ERR format, ##a); } while(0)
+#define qla1280_dump_buffer(level, buf, size)	\
+	if (ql_debug_level >= level) __qla1280_dump_buffer(buf, size)
+#define qla1280_print_scsi_cmd(level, cmd)	\
+	if (ql_debug_level >= level) __qla1280_print_scsi_cmd(cmd)
+#else
+#define ql_debug_level			0
+#define dprintk(level, format, a...)	do{}while(0)
+#define qla1280_dump_buffer(a, b, c)	do{}while(0)
+#define qla1280_print_scsi_cmd(a, b)	do{}while(0)
+#endif
+
+#define ENTER(x)		dprintk(3, "qla1280 : Entering %s()\n", x);
+#define LEAVE(x)		dprintk(3, "qla1280 : Leaving %s()\n", x);
+#define ENTER_INTR(x)		dprintk(4, "qla1280 : Entering %s()\n", x);
+#define LEAVE_INTR(x)		dprintk(4, "qla1280 : Leaving %s()\n", x);
+
+
+static int qla1280_read_nvram(struct scsi_qla_host *ha)
+{
+	uint16_t *wptr;
+	uint8_t chksum;
+	int cnt, i;
+	struct nvram *nv;
+
+	ENTER("qla1280_read_nvram");
+
+	if (driver_setup.no_nvram)
+		return 1;
+
+	printk(KERN_INFO "scsi(%ld): Reading NVRAM\n", ha->host_no);
+
+	wptr = (uint16_t *)&ha->nvram;
+	nv = &ha->nvram;
+	chksum = 0;
+	for (cnt = 0; cnt < 3; cnt++) {
+		*wptr = qla1280_get_nvram_word(ha, cnt);
+		chksum += *wptr & 0xff;
+		chksum += (*wptr >> 8) & 0xff;
+		wptr++;
+	}
+
+	if (nv->id0 != 'I' || nv->id1 != 'S' ||
+	    nv->id2 != 'P' || nv->id3 != ' ' || nv->version < 1) {
+		dprintk(2, "Invalid nvram ID or version!\n");
+		chksum = 1;
+	} else {
+		for (; cnt < sizeof(struct nvram); cnt++) {
+			*wptr = qla1280_get_nvram_word(ha, cnt);
+			chksum += *wptr & 0xff;
+			chksum += (*wptr >> 8) & 0xff;
+			wptr++;
+		}
+	}
+
+	dprintk(3, "qla1280_read_nvram: NVRAM Magic ID= %c %c %c %02x"
+	       " version %i\n", nv->id0, nv->id1, nv->id2, nv->id3,
+	       nv->version);
+
+
+	if (chksum) {
+		if (!driver_setup.no_nvram)
+			printk(KERN_WARNING "scsi(%ld): Unable to identify or "
+			       "validate NVRAM checksum, using default "
+			       "settings\n", ha->host_no);
+		ha->nvram_valid = 0;
+	} else
+		ha->nvram_valid = 1;
+
+	/* The firmware interface is, um, interesting, in that the
+	 * actual firmware image on the chip is little endian, thus,
+	 * the process of taking that image to the CPU would end up
+	 * little endian.  However, the firmare interface requires it
+	 * to be read a word (two bytes) at a time.
+	 *
+	 * The net result of this would be that the word (and
+	 * doubleword) quantites in the firmware would be correct, but
+	 * the bytes would be pairwise reversed.  Since most of the
+	 * firmware quantites are, in fact, bytes, we do an extra
+	 * le16_to_cpu() in the firmware read routine.
+	 *
+	 * The upshot of all this is that the bytes in the firmware
+	 * are in the correct places, but the 16 and 32 bit quantites
+	 * are still in little endian format.  We fix that up below by
+	 * doing extra reverses on them */
+	nv->isp_parameter = cpu_to_le16(nv->isp_parameter);
+	nv->firmware_feature.w = cpu_to_le16(nv->firmware_feature.w);
+	for(i = 0; i < MAX_BUSES; i++) {
+		nv->bus[i].selection_timeout = cpu_to_le16(nv->bus[i].selection_timeout);
+		nv->bus[i].max_queue_depth = cpu_to_le16(nv->bus[i].max_queue_depth);
+	}
+	dprintk(1, "qla1280_read_nvram: Completed Reading NVRAM\n");
+	LEAVE("qla1280_read_nvram");
+
+	return chksum;
+}
+
+/**************************************************************************
+ *   qla1280_info
+ *     Return a string describing the driver.
+ **************************************************************************/
+static const char *
+qla1280_info(struct Scsi_Host *host)
+{
+	static char qla1280_scsi_name_buffer[125];
+	char *bp;
+	struct scsi_qla_host *ha;
+	struct qla_boards *bdp;
+
+	bp = &qla1280_scsi_name_buffer[0];
+	ha = (struct scsi_qla_host *)host->hostdata;
+	bdp = &ql1280_board_tbl[ha->devnum];
+	memset(bp, 0, sizeof(qla1280_scsi_name_buffer));
+
+	sprintf (bp,
+		 "QLogic %s PCI to SCSI Host Adapter\n"
+		 "       Firmware version: %2d.%02d.%02d, Driver version %s",
+		 &bdp->name[0], bdp->fwver[0], bdp->fwver[1], bdp->fwver[2],
+		 QLA1280_VERSION);
+	return bp;
+}
+
+/**************************************************************************
+ *   qla1200_queuecommand
+ *     Queue a command to the controller.
+ *
+ * Note:
+ * The mid-level driver tries to ensures that queuecommand never gets invoked
+ * concurrently with itself or the interrupt handler (although the
+ * interrupt handler may call this routine as part of request-completion
+ * handling).   Unfortunely, it sometimes calls the scheduler in interrupt
+ * context which is a big NO! NO!.
+ **************************************************************************/
+static int
+qla1280_queuecommand(struct scsi_cmnd *cmd, void (*fn)(struct scsi_cmnd *))
+{
+	struct Scsi_Host *host = cmd->device->host;
+	struct scsi_qla_host *ha = (struct scsi_qla_host *)host->hostdata;
+	struct srb *sp = (struct srb *)&cmd->SCp;
+	int status;
+
+	cmd->scsi_done = fn;
+	sp->cmd = cmd;
+	sp->flags = 0;
+
+	qla1280_print_scsi_cmd(5, cmd);
+
+#ifdef QLA_64BIT_PTR
+	/*
+	 * Using 64 bit commands if the PCI bridge doesn't support it is a
+	 * bit wasteful, however this should really only happen if one's
+	 * PCI controller is completely broken, like the BCM1250. For
+	 * sane hardware this is not an issue.
+	 */
+	status = qla1280_64bit_start_scsi(ha, sp);
+#else
+	status = qla1280_32bit_start_scsi(ha, sp);
+#endif
+	return status;
+}
+
+enum action {
+	ABORT_COMMAND,
+	ABORT_DEVICE,
+	DEVICE_RESET,
+	BUS_RESET,
+	ADAPTER_RESET,
+	FAIL
+};
+
+/* timer action for error action processor */
+static void qla1280_error_wait_timeout(unsigned long __data)
+{
+	struct scsi_cmnd *cmd = (struct scsi_cmnd *)__data;
+	struct srb *sp = (struct srb *)CMD_SP(cmd);
+
+	complete(sp->wait);
+}
+
+static void qla1280_mailbox_timeout(unsigned long __data)
+{
+	struct scsi_qla_host *ha = (struct scsi_qla_host *)__data;
+	struct device_reg __iomem *reg;
+	reg = ha->iobase;
+
+	ha->mailbox_out[0] = RD_REG_WORD(&reg->mailbox0);
+	printk(KERN_ERR "scsi(%ld): mailbox timed out, mailbox0 %04x, "
+	       "ictrl %04x, istatus %04x\n", ha->host_no, ha->mailbox_out[0],
+	       RD_REG_WORD(&reg->ictrl), RD_REG_WORD(&reg->istatus));
+	complete(ha->mailbox_wait);
+}
+
+/**************************************************************************
+ * qla1200_error_action
+ *    The function will attempt to perform a specified error action and
+ *    wait for the results (or time out).
+ *
+ * Input:
+ *      cmd = Linux SCSI command packet of the command that cause the
+ *            bus reset.
+ *      action = error action to take (see action_t)
+ *
+ * Returns:
+ *      SUCCESS or FAILED
+ *
+ * Note:
+ *      Resetting the bus always succeeds - is has to, otherwise the
+ *      kernel will panic! Try a surgical technique - sending a BUS
+ *      DEVICE RESET message - on the offending target before pulling
+ *      the SCSI bus reset line.
+ **************************************************************************/
+static int
+qla1280_error_action(struct scsi_cmnd *cmd, enum action action)
+{
+	struct scsi_qla_host *ha;
+	int bus, target, lun;
+	struct srb *sp;
+	uint16_t data;
+	unsigned char *handle;
+	int result, i;
+	DECLARE_COMPLETION(wait);
+	struct timer_list timer;
+
+	ha = (struct scsi_qla_host *)(CMD_HOST(cmd)->hostdata);
+
+	dprintk(4, "error_action %i, istatus 0x%04x\n", action,
+		RD_REG_WORD(&ha->iobase->istatus));
+
+	dprintk(4, "host_cmd 0x%04x, ictrl 0x%04x, jiffies %li\n",
+		RD_REG_WORD(&ha->iobase->host_cmd),
+		RD_REG_WORD(&ha->iobase->ictrl), jiffies);
+
+	ENTER("qla1280_error_action");
+	if (qla1280_verbose)
+		printk(KERN_INFO "scsi(%li): Resetting Cmnd=0x%p, "
+		       "Handle=0x%p, action=0x%x\n",
+		       ha->host_no, cmd, CMD_HANDLE(cmd), action);
+
+	if (cmd == NULL) {
+		printk(KERN_WARNING "(scsi?:?:?:?) Reset called with NULL "
+		       "si_Cmnd pointer, failing.\n");
+		LEAVE("qla1280_error_action");
+		return FAILED;
+	}
+
+	ha = (struct scsi_qla_host *)cmd->device->host->hostdata;
+	sp = (struct srb *)CMD_SP(cmd);
+	handle = CMD_HANDLE(cmd);
+
+	/* Check for pending interrupts. */
+	data = qla1280_debounce_register(&ha->iobase->istatus);
+	/*
+	 * The io_request_lock is held when the reset handler is called, hence
+	 * the interrupt handler cannot be running in parallel as it also
+	 * grabs the lock. /Jes
+	 */
+	if (data & RISC_INT)
+		qla1280_isr(ha, &ha->done_q);
+
+	/*
+	 * Determine the suggested action that the mid-level driver wants
+	 * us to perform.
+	 */
+	if (handle == (unsigned char *)INVALID_HANDLE || handle == NULL) {
+		if(action == ABORT_COMMAND) {
+			/* we never got this command */
+			printk(KERN_INFO "qla1280: Aborting a NULL handle\n");
+			return SUCCESS;	/* no action - we don't have command */
+		}
+	} else {
+		sp->wait = &wait;
+	}
+
+	bus = SCSI_BUS_32(cmd);
+	target = SCSI_TCN_32(cmd);
+	lun = SCSI_LUN_32(cmd);
+
+	/* Overloading result.  Here it means the success or fail of the
+	 * *issue* of the action.  When we return from the routine, it must
+	 * mean the actual success or fail of the action */
+	result = FAILED;
+	switch (action) {
+	case FAIL:
+		break;
+
+	case ABORT_COMMAND:
+		if ((sp->flags & SRB_ABORT_PENDING)) {
+			printk(KERN_WARNING
+			       "scsi(): Command has a pending abort "
+			       "message - ABORT_PENDING.\n");
+			/* This should technically be impossible since we
+			 * now wait for abort completion */
+			break;
+		}
+
+		for (i = 0; i < MAX_OUTSTANDING_COMMANDS; i++) {
+			if (sp == ha->outstanding_cmds[i]) {
+				dprintk(1, "qla1280: RISC aborting command\n");
+				if (qla1280_abort_command(ha, sp, i) == 0)
+					result = SUCCESS;
+				else {
+					/*
+					 * Since we don't know what might
+					 * have happend to the command, it
+					 * is unsafe to remove it from the
+					 * device's queue at this point.
+					 * Wait and let the escalation
+					 * process take care of it.
+					 */
+					printk(KERN_WARNING
+					       "scsi(%li:%i:%i:%i): Unable"
+					       " to abort command!\n",
+					       ha->host_no, bus, target, lun);
+				}
+			}
+		}
+		break;
+
+	case ABORT_DEVICE:
+		ha->flags.in_reset = 1;
+		if (qla1280_verbose)
+			printk(KERN_INFO
+			       "scsi(%ld:%d:%d:%d): Queueing abort device "
+			       "command.\n", ha->host_no, bus, target, lun);
+		if (qla1280_abort_device(ha, bus, target, lun) == 0)
+			result = SUCCESS;
+		break;
+
+	case DEVICE_RESET:
+		if (qla1280_verbose)
+			printk(KERN_INFO
+			       "scsi(%ld:%d:%d:%d): Queueing device reset "
+			       "command.\n", ha->host_no, bus, target, lun);
+		ha->flags.in_reset = 1;
+		if (qla1280_device_reset(ha, bus, target) == 0)
+			result = SUCCESS;
+		break;
+
+	case BUS_RESET:
+		if (qla1280_verbose)
+			printk(KERN_INFO "qla1280(%ld:%d): Issuing BUS "
+			       "DEVICE RESET\n", ha->host_no, bus);
+		ha->flags.in_reset = 1;
+		if (qla1280_bus_reset(ha, bus == 0))
+			result = SUCCESS;
+
+		break;
+
+	case ADAPTER_RESET:
+	default:
+		if (qla1280_verbose) {
+			printk(KERN_INFO
+			       "scsi(%ld): Issued ADAPTER RESET\n",
+			       ha->host_no);
+			printk(KERN_INFO "scsi(%ld): I/O processing will "
+			       "continue automatically\n", ha->host_no);
+		}
+		ha->flags.reset_active = 1;
+		/*
+		 * We restarted all of the commands automatically, so the
+		 * mid-level code can expect completions momentitarily.
+		 */
+		if (qla1280_abort_isp(ha) == 0)
+			result = SUCCESS;
+
+		ha->flags.reset_active = 0;
+	}
+
+	if (!list_empty(&ha->done_q))
+		qla1280_done(ha);
+	ha->flags.in_reset = 0;
+
+	/* If we didn't manage to issue the action, or we have no
+	 * command to wait for, exit here */
+	if (result == FAILED || handle == NULL ||
+	    handle == (unsigned char *)INVALID_HANDLE) {
+		/*
+		 * Clear completion queue to avoid qla1280_done() trying
+		 * to complete the command at a later stage after we
+		 * have exited the current context
+		 */
+		sp->wait = NULL;
+		goto leave;
+	}
+
+	/* set up a timer just in case we're really jammed */
+	init_timer(&timer);
+	timer.expires = jiffies + 4*HZ;
+	timer.data = (unsigned long)cmd;
+	timer.function = qla1280_error_wait_timeout;
+	add_timer(&timer);
+
+	/* wait for the action to complete (or the timer to expire) */
+	spin_unlock_irq(HOST_LOCK);
+	wait_for_completion(&wait);
+	del_timer_sync(&timer);
+	spin_lock_irq(HOST_LOCK);
+	sp->wait = NULL;
+
+	/* the only action we might get a fail for is abort */
+	if (action == ABORT_COMMAND) {
+		if(sp->flags & SRB_ABORTED)
+			result = SUCCESS;
+		else
+			result = FAILED;
+	}
+
+ leave:
+	dprintk(1, "RESET returning %d\n", result);
+
+	LEAVE("qla1280_error_action");
+	return result;
+}
+
+/**************************************************************************
+ *   qla1280_abort
+ *     Abort the specified SCSI command(s).
+ **************************************************************************/
+static int
+qla1280_eh_abort(struct scsi_cmnd * cmd)
+{
+	return qla1280_error_action(cmd, ABORT_COMMAND);
+}
+
+/**************************************************************************
+ *   qla1280_device_reset
+ *     Reset the specified SCSI device
+ **************************************************************************/
+static int
+qla1280_eh_device_reset(struct scsi_cmnd *cmd)
+{
+	return qla1280_error_action(cmd, DEVICE_RESET);
+}
+
+/**************************************************************************
+ *   qla1280_bus_reset
+ *     Reset the specified bus.
+ **************************************************************************/
+static int
+qla1280_eh_bus_reset(struct scsi_cmnd *cmd)
+{
+	return qla1280_error_action(cmd, BUS_RESET);
+}
+
+/**************************************************************************
+ *   qla1280_adapter_reset
+ *     Reset the specified adapter (both channels)
+ **************************************************************************/
+static int
+qla1280_eh_adapter_reset(struct scsi_cmnd *cmd)
+{
+	return qla1280_error_action(cmd, ADAPTER_RESET);
+}
+
+static int
+qla1280_biosparam(struct scsi_device *sdev, struct block_device *bdev,
+		  sector_t capacity, int geom[])
+{
+	int heads, sectors, cylinders;
+
+	heads = 64;
+	sectors = 32;
+	cylinders = (unsigned long)capacity / (heads * sectors);
+	if (cylinders > 1024) {
+		heads = 255;
+		sectors = 63;
+		cylinders = (unsigned long)capacity / (heads * sectors);
+		/* if (cylinders > 1023)
+		   cylinders = 1023; */
+	}
+
+	geom[0] = heads;
+	geom[1] = sectors;
+	geom[2] = cylinders;
+
+	return 0;
+}
+
+#if LINUX_VERSION_CODE < 0x020600
+static int
+qla1280_detect(Scsi_Host_Template *template)
+{
+	struct pci_device_id *id = &qla1280_pci_tbl[0];
+	struct pci_dev *pdev = NULL;
+	int num_hosts = 0;
+
+	if (sizeof(struct srb) > sizeof(Scsi_Pointer)) {
+		printk(KERN_WARNING
+		       "qla1280: struct srb too big, aborting\n");
+		return 0;
+	}
+
+	if ((DMA_BIDIRECTIONAL != PCI_DMA_BIDIRECTIONAL) ||
+	    (DMA_TO_DEVICE != PCI_DMA_TODEVICE) ||
+	    (DMA_FROM_DEVICE != PCI_DMA_FROMDEVICE) ||
+	    (DMA_NONE != PCI_DMA_NONE)) {
+		printk(KERN_WARNING
+		       "qla1280: dma direction bits don't match\n");
+		return 0;
+	}
+
+#ifdef MODULE
+	/*
+	 * If we are called as a module, the qla1280 pointer may not be null
+	 * and it would point to our bootup string, just like on the lilo
+	 * command line.  IF not NULL, then process this config string with
+	 * qla1280_setup
+	 *
+	 * Boot time Options
+	 * To add options at boot time add a line to your lilo.conf file like:
+	 * append="qla1280=verbose,max_tags:{{255,255,255,255},{255,255,255,255}}"
+	 * which will result in the first four devices on the first two
+	 * controllers being set to a tagged queue depth of 32.
+	 */
+	if (qla1280)
+		qla1280_setup(qla1280);
+#endif
+
+	/* First Initialize QLA12160 on PCI Bus 1 Dev 2 */
+	while ((pdev = pci_find_device(id->vendor, id->device, pdev))) {
+		if (pdev->bus->number == 1 && PCI_SLOT(pdev->devfn) == 2) {
+			if (!qla1280_probe_one(pdev, id))
+				num_hosts++;
+		}
+	}
+
+	pdev = NULL;
+	/* Try and find each different type of adapter we support */
+	for (id = &qla1280_pci_tbl[0]; id->device; id++) {
+		while ((pdev = pci_find_device(id->vendor, id->device, pdev))) {
+			/*
+			 * skip QLA12160 already initialized on
+			 * PCI Bus 1 Dev 2 since we already initialized
+			 * and presented it
+			 */
+			if (id->device == PCI_DEVICE_ID_QLOGIC_ISP12160 &&
+			    pdev->bus->number == 1 &&
+			    PCI_SLOT(pdev->devfn) == 2)
+				continue;
+
+			if (!qla1280_probe_one(pdev, id))
+				num_hosts++;
+		}
+	}
+
+	return num_hosts;
+}
+
+/*
+ * This looks a bit ugly as we could just pass down host to
+ * qla1280_remove_one, but I want to keep qla1280_release purely a wrapper
+ * around pci_driver::remove as used from 2.6 onwards.
+ */
+static int
+qla1280_release(struct Scsi_Host *host)
+{
+	struct scsi_qla_host *ha = (struct scsi_qla_host *)host->hostdata;
+
+	qla1280_remove_one(ha->pdev);
+	return 0;
+}
+
+static int
+qla1280_biosparam_old(Disk * disk, kdev_t dev, int geom[])
+{
+	return qla1280_biosparam(disk->device, NULL, disk->capacity, geom);
+}
+#endif
+
+/**************************************************************************
+ * qla1280_intr_handler
+ *   Handles the H/W interrupt
+ **************************************************************************/
+static irqreturn_t
+qla1280_intr_handler(int irq, void *dev_id, struct pt_regs *regs)
+{
+	struct scsi_qla_host *ha;
+	struct device_reg __iomem *reg;
+	u16 data;
+	int handled = 0;
+
+	ENTER_INTR ("qla1280_intr_handler");
+	ha = (struct scsi_qla_host *)dev_id;
+
+	spin_lock(HOST_LOCK);
+
+	ha->isr_count++;
+	reg = ha->iobase;
+
+	WRT_REG_WORD(&reg->ictrl, 0);	/* disable our interrupt. */
+
+	data = qla1280_debounce_register(&reg->istatus);
+	/* Check for pending interrupts. */
+	if (data & RISC_INT) {	
+		qla1280_isr(ha, &ha->done_q);
+		handled = 1;
+	}
+	if (!list_empty(&ha->done_q))
+		qla1280_done(ha);
+
+	spin_unlock(HOST_LOCK);
+
+	/* enable our interrupt. */
+	WRT_REG_WORD(&reg->ictrl, (ISP_EN_INT | ISP_EN_RISC));
+
+	LEAVE_INTR("qla1280_intr_handler");
+	return IRQ_RETVAL(handled);
+}
+
+
+static int
+qla1280_set_target_parameters(struct scsi_qla_host *ha, int bus, int target)
+{
+	uint8_t mr;
+	uint16_t mb[MAILBOX_REGISTER_COUNT];
+	struct nvram *nv;
+	int status;
+
+	nv = &ha->nvram;
+
+	mr = BIT_3 | BIT_2 | BIT_1 | BIT_0;
+
+	/* Set Target Parameters. */
+	mb[0] = MBC_SET_TARGET_PARAMETERS;
+	mb[1] = (uint16_t) (bus ? target | BIT_7 : target);
+	mb[1] <<= 8;
+
+	mb[2] = (nv->bus[bus].target[target].parameter.c << 8);
+
+	if (IS_ISP1x160(ha)) {
+		mb[2] |= nv->bus[bus].target[target].ppr_1x160.flags.enable_ppr << 5;
+		mb[3] =	(nv->bus[bus].target[target].flags.flags1x160.sync_offset << 8) |
+			 nv->bus[bus].target[target].sync_period;
+		mb[6] =	(nv->bus[bus].target[target].ppr_1x160.flags.ppr_options << 8) |
+			 nv->bus[bus].target[target].ppr_1x160.flags.ppr_bus_width;
+		mr |= BIT_6;
+	} else {
+		mb[3] =	(nv->bus[bus].target[target].flags.flags1x80.sync_offset << 8) |
+			 nv->bus[bus].target[target].sync_period;
+	}
+
+	status = qla1280_mailbox_command(ha, mr, &mb[0]);
+
+	if (status)
+		printk(KERN_WARNING "scsi(%ld:%i:%i): "
+		       "qla1280_set_target_parameters() failed\n",
+		       ha->host_no, bus, target);
+	return status;
+}
+
+
+/**************************************************************************
+ *   qla1280_slave_configure
+ *
+ * Description:
+ *   Determines the queue depth for a given device.  There are two ways
+ *   a queue depth can be obtained for a tagged queueing device.  One
+ *   way is the default queue depth which is determined by whether
+ *   If it is defined, then it is used
+ *   as the default queue depth.  Otherwise, we use either 4 or 8 as the
+ *   default queue depth (dependent on the number of hardware SCBs).
+ **************************************************************************/
+static int
+qla1280_slave_configure(struct scsi_device *device)
+{
+	struct scsi_qla_host *ha;
+	int default_depth = 3;
+	int bus = device->channel;
+	int target = device->id;
+	int status = 0;
+	struct nvram *nv;
+	unsigned long flags;
+
+	ha = (struct scsi_qla_host *)device->host->hostdata;
+	nv = &ha->nvram;
+
+	if (qla1280_check_for_dead_scsi_bus(ha, bus))
+		return 1;
+
+	if (device->tagged_supported &&
+	    (ha->bus_settings[bus].qtag_enables & (BIT_0 << target))) {
+		scsi_adjust_queue_depth(device, MSG_ORDERED_TAG,
+					ha->bus_settings[bus].hiwat);
+	} else {
+		scsi_adjust_queue_depth(device, 0, default_depth);
+	}
+
+#if LINUX_VERSION_CODE > 0x020500
+	nv->bus[bus].target[target].parameter.f.enable_sync = device->sdtr;
+	nv->bus[bus].target[target].parameter.f.enable_wide = device->wdtr;
+	nv->bus[bus].target[target].ppr_1x160.flags.enable_ppr = device->ppr;
+#endif
+
+	if (driver_setup.no_sync ||
+	    (driver_setup.sync_mask &&
+	     (~driver_setup.sync_mask & (1 << target))))
+		nv->bus[bus].target[target].parameter.f.enable_sync = 0;
+	if (driver_setup.no_wide ||
+	    (driver_setup.wide_mask &&
+	     (~driver_setup.wide_mask & (1 << target))))
+		nv->bus[bus].target[target].parameter.f.enable_wide = 0;
+	if (IS_ISP1x160(ha)) {
+		if (driver_setup.no_ppr ||
+		    (driver_setup.ppr_mask &&
+		     (~driver_setup.ppr_mask & (1 << target))))
+			nv->bus[bus].target[target].ppr_1x160.flags.enable_ppr = 0;
+	}
+
+	spin_lock_irqsave(HOST_LOCK, flags);
+	if (nv->bus[bus].target[target].parameter.f.enable_sync)
+		status = qla1280_set_target_parameters(ha, bus, target);
+	qla1280_get_target_parameters(ha, device);
+	spin_unlock_irqrestore(HOST_LOCK, flags);
+	return status;
+}
+
+#if LINUX_VERSION_CODE < 0x020545
+/**************************************************************************
+ *   qla1280_select_queue_depth
+ *
+ *   Sets the queue depth for each SCSI device hanging off the input
+ *   host adapter.  We use a queue depth of 2 for devices that do not
+ *   support tagged queueing.
+ **************************************************************************/
+static void
+qla1280_select_queue_depth(struct Scsi_Host *host, struct scsi_device *sdev_q)
+{
+	struct scsi_qla_host *ha = (struct scsi_qla_host *)host->hostdata;
+	struct scsi_device *sdev;
+
+	ENTER("qla1280_select_queue_depth");
+	for (sdev = sdev_q; sdev; sdev = sdev->next)
+		if (sdev->host == host)
+			qla1280_slave_configure(sdev);
+
+	if (sdev_q)
+		qla1280_check_for_dead_scsi_bus(ha, sdev_q->channel);
+	LEAVE("qla1280_select_queue_depth");
+}
+#endif
+
+/*
+ * qla1280_done
+ *      Process completed commands.
+ *
+ * Input:
+ *      ha           = adapter block pointer.
+ *      done_q       = done queue.
+ */
+static void
+qla1280_done(struct scsi_qla_host *ha)
+{
+	struct srb *sp;
+	struct list_head *done_q;
+	int bus, target, lun;
+	struct scsi_cmnd *cmd;
+
+	ENTER("qla1280_done");
+
+	done_q = &ha->done_q;
+
+	while (!list_empty(done_q)) {
+		sp = list_entry(done_q->next, struct srb, list);
+
+		list_del(&sp->list);
+	
+		cmd = sp->cmd;
+		bus = SCSI_BUS_32(cmd);
+		target = SCSI_TCN_32(cmd);
+		lun = SCSI_LUN_32(cmd);
+
+		switch ((CMD_RESULT(cmd) >> 16)) {
+		case DID_RESET:
+			/* Issue marker command. */
+			qla1280_marker(ha, bus, target, 0, MK_SYNC_ID);
+			break;
+		case DID_ABORT:
+			sp->flags &= ~SRB_ABORT_PENDING;
+			sp->flags |= SRB_ABORTED;
+			if (sp->flags & SRB_TIMEOUT)
+				CMD_RESULT(sp->cmd) = DID_TIME_OUT << 16;
+			break;
+		default:
+			break;
+		}
+
+		/* Release memory used for this I/O */
+		if (cmd->use_sg) {
+			pci_unmap_sg(ha->pdev, cmd->request_buffer,
+					cmd->use_sg, cmd->sc_data_direction);
+		} else if (cmd->request_bufflen) {
+			pci_unmap_single(ha->pdev, sp->saved_dma_handle,
+					cmd->request_bufflen,
+					cmd->sc_data_direction);
+		}
+
+		/* Call the mid-level driver interrupt handler */
+		CMD_HANDLE(sp->cmd) = (unsigned char *)INVALID_HANDLE;
+		ha->actthreads--;
+
+#if LINUX_VERSION_CODE < 0x020500
+		if (cmd->cmnd[0] == INQUIRY)
+			qla1280_get_target_options(cmd, ha);
+#endif
+		(*(cmd)->scsi_done)(cmd);
+
+		if(sp->wait != NULL)
+			complete(sp->wait);
+	}
+	LEAVE("qla1280_done");
+}
+
+/*
+ * Translates a ISP error to a Linux SCSI error
+ */
+static int
+qla1280_return_status(struct response * sts, struct scsi_cmnd *cp)
+{
+	int host_status = DID_ERROR;
+	uint16_t comp_status = le16_to_cpu(sts->comp_status);
+	uint16_t state_flags = le16_to_cpu(sts->state_flags);
+	uint16_t residual_length = le16_to_cpu(sts->residual_length);
+	uint16_t scsi_status = le16_to_cpu(sts->scsi_status);
+#if DEBUG_QLA1280_INTR
+	static char *reason[] = {
+		"DID_OK",
+		"DID_NO_CONNECT",
+		"DID_BUS_BUSY",
+		"DID_TIME_OUT",
+		"DID_BAD_TARGET",
+		"DID_ABORT",
+		"DID_PARITY",
+		"DID_ERROR",
+		"DID_RESET",
+		"DID_BAD_INTR"
+	};
+#endif				/* DEBUG_QLA1280_INTR */
+
+	ENTER("qla1280_return_status");
+
+#if DEBUG_QLA1280_INTR
+	/*
+	  dprintk(1, "qla1280_return_status: compl status = 0x%04x\n",
+	  comp_status);
+	*/
+#endif
+
+	switch (comp_status) {
+	case CS_COMPLETE:
+		host_status = DID_OK;
+		break;
+
+	case CS_INCOMPLETE:
+		if (!(state_flags & SF_GOT_BUS))
+			host_status = DID_NO_CONNECT;
+		else if (!(state_flags & SF_GOT_TARGET))
+			host_status = DID_BAD_TARGET;
+		else if (!(state_flags & SF_SENT_CDB))
+			host_status = DID_ERROR;
+		else if (!(state_flags & SF_TRANSFERRED_DATA))
+			host_status = DID_ERROR;
+		else if (!(state_flags & SF_GOT_STATUS))
+			host_status = DID_ERROR;
+		else if (!(state_flags & SF_GOT_SENSE))
+			host_status = DID_ERROR;
+		break;
+
+	case CS_RESET:
+		host_status = DID_RESET;
+		break;
+
+	case CS_ABORTED:
+		host_status = DID_ABORT;
+		break;
+
+	case CS_TIMEOUT:
+		host_status = DID_TIME_OUT;
+		break;
+
+	case CS_DATA_OVERRUN:
+		dprintk(2, "Data overrun 0x%x\n", residual_length);
+		dprintk(2, "qla1280_isr: response packet data\n");
+		qla1280_dump_buffer(2, (char *)sts, RESPONSE_ENTRY_SIZE);
+		host_status = DID_ERROR;
+		break;
+
+	case CS_DATA_UNDERRUN:
+		if ((cp->request_bufflen - residual_length) <
+		    cp->underflow) {
+			printk(KERN_WARNING
+			       "scsi: Underflow detected - retrying "
+			       "command.\n");
+			host_status = DID_ERROR;
+		} else
+			host_status = DID_OK;
+		break;
+
+	default:
+		host_status = DID_ERROR;
+		break;
+	}
+
+#if DEBUG_QLA1280_INTR
+	dprintk(1, "qla1280 ISP status: host status (%s) scsi status %x\n",
+		reason[host_status], scsi_status);
+#endif
+
+	LEAVE("qla1280_return_status");
+
+	return (scsi_status & 0xff) | (host_status << 16);
+}
+
+/****************************************************************************/
+/*                QLogic ISP1280 Hardware Support Functions.                */
+/****************************************************************************/
+
+ /*
+  * qla2100_enable_intrs
+  * qla2100_disable_intrs
+  *
+  * Input:
+  *      ha = adapter block pointer.
+  *
+  * Returns:
+  *      None
+  */
+static inline void
+qla1280_enable_intrs(struct scsi_qla_host *ha)
+{
+	struct device_reg __iomem *reg;
+
+	reg = ha->iobase;
+	/* enable risc and host interrupts */
+	WRT_REG_WORD(&reg->ictrl, (ISP_EN_INT | ISP_EN_RISC));
+	RD_REG_WORD(&reg->ictrl);	/* PCI Posted Write flush */
+	ha->flags.ints_enabled = 1;
+}
+
+static inline void
+qla1280_disable_intrs(struct scsi_qla_host *ha)
+{
+	struct device_reg __iomem *reg;
+
+	reg = ha->iobase;
+	/* disable risc and host interrupts */
+	WRT_REG_WORD(&reg->ictrl, 0);
+	RD_REG_WORD(&reg->ictrl);	/* PCI Posted Write flush */
+	ha->flags.ints_enabled = 0;
+}
+
+/*
+ * qla1280_initialize_adapter
+ *      Initialize board.
+ *
+ * Input:
+ *      ha = adapter block pointer.
+ *
+ * Returns:
+ *      0 = success
+ */
+static int __devinit
+qla1280_initialize_adapter(struct scsi_qla_host *ha)
+{
+	struct device_reg __iomem *reg;
+	int status;
+	int bus;
+#if LINUX_VERSION_CODE > 0x020500
+	unsigned long flags;
+#endif
+
+	ENTER("qla1280_initialize_adapter");
+
+	/* Clear adapter flags. */
+	ha->flags.online = 0;
+	ha->flags.disable_host_adapter = 0;
+	ha->flags.reset_active = 0;
+	ha->flags.abort_isp_active = 0;
+
+	ha->flags.ints_enabled = 0;
+#if defined(CONFIG_IA64_GENERIC) || defined(CONFIG_IA64_SGI_SN2)
+	if (ia64_platform_is("sn2")) {
+		printk(KERN_INFO "scsi(%li): Enabling SN2 PCI DMA "
+		       "dual channel lockup workaround\n", ha->host_no);
+		ha->flags.use_pci_vchannel = 1;
+		driver_setup.no_nvram = 1;
+	}
+#endif
+
+	/* TODO: implement support for the 1040 nvram format */
+	if (IS_ISP1040(ha))
+		driver_setup.no_nvram = 1;
+
+	dprintk(1, "Configure PCI space for adapter...\n");
+
+	reg = ha->iobase;
+
+	/* Insure mailbox registers are free. */
+	WRT_REG_WORD(&reg->semaphore, 0);
+	WRT_REG_WORD(&reg->host_cmd, HC_CLR_RISC_INT);
+	WRT_REG_WORD(&reg->host_cmd, HC_CLR_HOST_INT);
+	RD_REG_WORD(&reg->host_cmd);
+
+	if (qla1280_read_nvram(ha)) {
+		dprintk(2, "qla1280_initialize_adapter: failed to read "
+			"NVRAM\n");
+	}
+
+#if LINUX_VERSION_CODE >= 0x020500
+	/*
+	 * It's necessary to grab the spin here as qla1280_mailbox_command
+	 * needs to be able to drop the lock unconditionally to wait
+	 * for completion.
+	 * In 2.4 ->detect is called with the io_request_lock held.
+	 */
+	spin_lock_irqsave(HOST_LOCK, flags);
+#endif
+
+	status = qla1280_load_firmware(ha);
+	if (status) {
+		printk(KERN_ERR "scsi(%li): initialize: pci probe failed!\n",
+		       ha->host_no);
+		goto out;
+	}
+
+	/* Setup adapter based on NVRAM parameters. */
+	dprintk(1, "scsi(%ld): Configure NVRAM parameters\n", ha->host_no);
+	qla1280_nvram_config(ha);
+
+	if (ha->flags.disable_host_adapter) {
+		status = 1;
+		goto out;
+	}
+
+	status = qla1280_init_rings(ha);
+	if (status)
+		goto out;
+
+	/* Issue SCSI reset, if we can't reset twice then bus is dead */
+	for (bus = 0; bus < ha->ports; bus++) {
+		if (!ha->bus_settings[bus].disable_scsi_reset &&
+		    qla1280_bus_reset(ha, bus) &&
+		    qla1280_bus_reset(ha, bus))
+			ha->bus_settings[bus].scsi_bus_dead = 1;
+	}
+
+	ha->flags.online = 1;
+ out:
+#if LINUX_VERSION_CODE >= 0x020500
+	spin_unlock_irqrestore(HOST_LOCK, flags);
+#endif
+	if (status)
+		dprintk(2, "qla1280_initialize_adapter: **** FAILED ****\n");
+
+	LEAVE("qla1280_initialize_adapter");
+	return status;
+}
+
+
+/*
+ * ISP Firmware Test
+ *      Checks if present version of RISC firmware is older than
+ *      driver firmware.
+ *
+ * Input:
+ *      ha = adapter block pointer.
+ *
+ * Returns:
+ *      0 = firmware does not need to be loaded.
+ */
+static int
+qla1280_isp_firmware(struct scsi_qla_host *ha)
+{
+	struct nvram *nv = (struct nvram *) ha->response_ring;
+	int status = 0;		/* dg 2/27 always loads RISC */
+	uint16_t mb[MAILBOX_REGISTER_COUNT];
+
+	ENTER("qla1280_isp_firmware");
+
+	dprintk(1, "scsi(%li): Determining if RISC is loaded\n", ha->host_no);
+
+	/* Bad NVRAM data, load RISC code. */
+	if (!ha->nvram_valid) {
+		ha->flags.disable_risc_code_load = 0;
+	} else
+		ha->flags.disable_risc_code_load =
+			nv->cntr_flags_1.disable_loading_risc_code;
+
+	if (ha->flags.disable_risc_code_load) {
+		dprintk(3, "qla1280_isp_firmware: Telling RISC to verify "
+			"checksum of loaded BIOS code.\n");
+
+		/* Verify checksum of loaded RISC code. */
+		mb[0] = MBC_VERIFY_CHECKSUM;
+		/* mb[1] = ql12_risc_code_addr01; */
+		mb[1] = *ql1280_board_tbl[ha->devnum].fwstart;
+
+		if (!(status =
+		      qla1280_mailbox_command(ha, BIT_1 | BIT_0, &mb[0]))) {
+			/* Start firmware execution. */
+			dprintk(3, "qla1280_isp_firmware: Startng F/W "
+				"execution.\n");
+
+			mb[0] = MBC_EXECUTE_FIRMWARE;
+			/* mb[1] = ql12_risc_code_addr01; */
+			mb[1] = *ql1280_board_tbl[ha->devnum].fwstart;
+			qla1280_mailbox_command(ha, BIT_1 | BIT_0, &mb[0]);
+		} else
+			printk(KERN_INFO "qla1280: RISC checksum failed.\n");
+	} else {
+		dprintk(1, "qla1280: NVRAM configured to load RISC load.\n");
+		status = 1;
+	}
+
+	if (status)
+		dprintk(2, "qla1280_isp_firmware: **** Load RISC code ****\n");
+
+	LEAVE("qla1280_isp_firmware");
+	return status;
+}
+
+/*
+ * Chip diagnostics
+ *      Test chip for proper operation.
+ *
+ * Input:
+ *      ha = adapter block pointer.
+ *
+ * Returns:
+ *      0 = success.
+ */
+static int
+qla1280_chip_diag(struct scsi_qla_host *ha)
+{
+	uint16_t mb[MAILBOX_REGISTER_COUNT];
+	struct device_reg __iomem *reg = ha->iobase;
+	int status = 0;
+	int cnt;
+	uint16_t data;
+	dprintk(3, "qla1280_chip_diag: testing device at 0x%p \n", &reg->id_l);
+
+	dprintk(1, "scsi(%ld): Verifying chip\n", ha->host_no);
+
+	/* Soft reset chip and wait for it to finish. */
+	WRT_REG_WORD(&reg->ictrl, ISP_RESET);
+
+	/*
+	 * We can't do a traditional PCI write flush here by reading
+	 * back the register. The card will not respond once the reset
+	 * is in action and we end up with a machine check exception
+	 * instead. Nothing to do but wait and hope for the best.
+	 * A portable pci_write_flush(pdev) call would be very useful here.
+	 */
+	udelay(20);
+	data = qla1280_debounce_register(&reg->ictrl);
+	/*
+	 * Yet another QLogic gem ;-(
+	 */
+	for (cnt = 1000000; cnt && data & ISP_RESET; cnt--) {
+		udelay(5);
+		data = RD_REG_WORD(&reg->ictrl);
+	}
+
+	if (!cnt)
+		goto fail;
+
+	/* Reset register cleared by chip reset. */
+	dprintk(3, "qla1280_chip_diag: reset register cleared by chip reset\n");
+
+	WRT_REG_WORD(&reg->cfg_1, 0);
+
+	/* Reset RISC and disable BIOS which
+	   allows RISC to execute out of RAM. */
+	WRT_REG_WORD(&reg->host_cmd, HC_RESET_RISC |
+		     HC_RELEASE_RISC | HC_DISABLE_BIOS);
+
+	RD_REG_WORD(&reg->id_l);	/* Flush PCI write */
+	data = qla1280_debounce_register(&reg->mailbox0);
+
+	/*
+	 * I *LOVE* this code!
+	 */
+	for (cnt = 1000000; cnt && data == MBS_BUSY; cnt--) {
+		udelay(5);
+		data = RD_REG_WORD(&reg->mailbox0);
+	}
+
+	if (!cnt)
+		goto fail;
+
+	/* Check product ID of chip */
+	dprintk(3, "qla1280_chip_diag: Checking product ID of chip\n");
+
+	if (RD_REG_WORD(&reg->mailbox1) != PROD_ID_1 ||
+	    (RD_REG_WORD(&reg->mailbox2) != PROD_ID_2 &&
+	     RD_REG_WORD(&reg->mailbox2) != PROD_ID_2a) ||
+	    RD_REG_WORD(&reg->mailbox3) != PROD_ID_3 ||
+	    RD_REG_WORD(&reg->mailbox4) != PROD_ID_4) {
+		printk(KERN_INFO "qla1280: Wrong product ID = "
+		       "0x%x,0x%x,0x%x,0x%x\n",
+		       RD_REG_WORD(&reg->mailbox1),
+		       RD_REG_WORD(&reg->mailbox2),
+		       RD_REG_WORD(&reg->mailbox3),
+		       RD_REG_WORD(&reg->mailbox4));
+		goto fail;
+	}
+
+	/*
+	 * Enable ints early!!!
+	 */
+	qla1280_enable_intrs(ha);
+
+	dprintk(1, "qla1280_chip_diag: Checking mailboxes of chip\n");
+	/* Wrap Incoming Mailboxes Test. */
+	mb[0] = MBC_MAILBOX_REGISTER_TEST;
+	mb[1] = 0xAAAA;
+	mb[2] = 0x5555;
+	mb[3] = 0xAA55;
+	mb[4] = 0x55AA;
+	mb[5] = 0xA5A5;
+	mb[6] = 0x5A5A;
+	mb[7] = 0x2525;
+
+	status = qla1280_mailbox_command(ha, 0xff, mb);
+	if (status)
+		goto fail;
+
+	if (mb[1] != 0xAAAA || mb[2] != 0x5555 || mb[3] != 0xAA55 ||
+	    mb[4] != 0x55AA || mb[5] != 0xA5A5 || mb[6] != 0x5A5A ||
+	    mb[7] != 0x2525) {
+		printk(KERN_INFO "qla1280: Failed mbox check\n");
+		goto fail;
+	}
+
+	dprintk(3, "qla1280_chip_diag: exiting normally\n");
+	return 0;
+ fail:
+	dprintk(2, "qla1280_chip_diag: **** FAILED ****\n");
+	return status;
+}
+
+static int
+qla1280_load_firmware_pio(struct scsi_qla_host *ha)
+{
+	uint16_t risc_address, *risc_code_address, risc_code_size;
+	uint16_t mb[MAILBOX_REGISTER_COUNT], i;
+	int err;
+
+	/* Load RISC code. */
+	risc_address = *ql1280_board_tbl[ha->devnum].fwstart;
+	risc_code_address = ql1280_board_tbl[ha->devnum].fwcode;
+	risc_code_size = *ql1280_board_tbl[ha->devnum].fwlen;
+
+	for (i = 0; i < risc_code_size; i++) {
+		mb[0] = MBC_WRITE_RAM_WORD;
+		mb[1] = risc_address + i;
+		mb[2] = risc_code_address[i];
+
+		err = qla1280_mailbox_command(ha, BIT_0 | BIT_1 | BIT_2, mb);
+		if (err) {
+			printk(KERN_ERR "scsi(%li): Failed to load firmware\n",
+					ha->host_no);
+			return err;
+		}
+	}
+
+	return 0;
+}
+
+#define DUMP_IT_BACK 0		/* for debug of RISC loading */
+static int
+qla1280_load_firmware_dma(struct scsi_qla_host *ha)
+{
+	uint16_t risc_address, *risc_code_address, risc_code_size;
+	uint16_t mb[MAILBOX_REGISTER_COUNT], cnt;
+	int err = 0, num, i;
+#if DUMP_IT_BACK
+	uint8_t *sp, *tbuf;
+	dma_addr_t p_tbuf;
+
+	tbuf = pci_alloc_consistent(ha->pdev, 8000, &p_tbuf);
+	if (!tbuf)
+		return -ENOMEM;
+#endif
+
+	/* Load RISC code. */
+	risc_address = *ql1280_board_tbl[ha->devnum].fwstart;
+	risc_code_address = ql1280_board_tbl[ha->devnum].fwcode;
+	risc_code_size = *ql1280_board_tbl[ha->devnum].fwlen;
+
+	dprintk(1, "%s: DMA RISC code (%i) words\n",
+			__FUNCTION__, risc_code_size);
+
+	num = 0;
+	while (risc_code_size > 0) {
+		int warn __attribute__((unused)) = 0;
+
+		cnt = 2000 >> 1;
+
+		if (cnt > risc_code_size)
+			cnt = risc_code_size;
+
+		dprintk(2, "qla1280_setup_chip:  loading risc @ =(0x%p),"
+			"%d,%d(0x%x)\n",
+			risc_code_address, cnt, num, risc_address);
+		for(i = 0; i < cnt; i++)
+			((uint16_t *)ha->request_ring)[i] =
+				cpu_to_le16(risc_code_address[i]);
+
+		mb[0] = MBC_LOAD_RAM;
+		mb[1] = risc_address;
+		mb[4] = cnt;
+		mb[3] = ha->request_dma & 0xffff;
+		mb[2] = (ha->request_dma >> 16) & 0xffff;
+		mb[7] = pci_dma_hi32(ha->request_dma) & 0xffff;
+		mb[6] = pci_dma_hi32(ha->request_dma) >> 16;
+		dprintk(2, "%s: op=%d  0x%p = 0x%4x,0x%4x,0x%4x,0x%4x\n",
+				__FUNCTION__, mb[0],
+				(void *)(long)ha->request_dma,
+				mb[6], mb[7], mb[2], mb[3]);
+		err = qla1280_mailbox_command(ha, BIT_4 | BIT_3 | BIT_2 |
+				BIT_1 | BIT_0, mb);
+		if (err) {
+			printk(KERN_ERR "scsi(%li): Failed to load partial "
+			       "segment of f\n", ha->host_no);
+			goto out;
+		}
+
+#if DUMP_IT_BACK
+		mb[0] = MBC_DUMP_RAM;
+		mb[1] = risc_address;
+		mb[4] = cnt;
+		mb[3] = p_tbuf & 0xffff;
+		mb[2] = (p_tbuf >> 16) & 0xffff;
+		mb[7] = pci_dma_hi32(p_tbuf) & 0xffff;
+		mb[6] = pci_dma_hi32(p_tbuf) >> 16;
+
+		err = qla1280_mailbox_command(ha, BIT_4 | BIT_3 | BIT_2 |
+				BIT_1 | BIT_0, mb);
+		if (err) {
+			printk(KERN_ERR
+			       "Failed to dump partial segment of f/w\n");
+			goto out;
+		}
+		sp = (uint8_t *)ha->request_ring;
+		for (i = 0; i < (cnt << 1); i++) {
+			if (tbuf[i] != sp[i] && warn++ < 10) {
+				printk(KERN_ERR "%s: FW compare error @ "
+						"byte(0x%x) loop#=%x\n",
+						__FUNCTION__, i, num);
+				printk(KERN_ERR "%s: FWbyte=%x  "
+						"FWfromChip=%x\n",
+						__FUNCTION__, sp[i], tbuf[i]);
+				/*break; */
+			}
+		}
+#endif
+		risc_address += cnt;
+		risc_code_size = risc_code_size - cnt;
+		risc_code_address = risc_code_address + cnt;
+		num++;
+	}
+
+ out:
+#if DUMP_IT_BACK
+	pci_free_consistent(ha->pdev, 8000, tbuf, p_tbuf);
+#endif
+	return err;
+}
+
+static int
+qla1280_start_firmware(struct scsi_qla_host *ha)
+{
+	uint16_t mb[MAILBOX_REGISTER_COUNT];
+	int err;
+
+	dprintk(1, "%s: Verifying checksum of loaded RISC code.\n",
+			__FUNCTION__);
+
+	/* Verify checksum of loaded RISC code. */
+	mb[0] = MBC_VERIFY_CHECKSUM;
+	/* mb[1] = ql12_risc_code_addr01; */
+	mb[1] = *ql1280_board_tbl[ha->devnum].fwstart;
+	err = qla1280_mailbox_command(ha, BIT_1 | BIT_0, mb);
+	if (err) {
+		printk(KERN_ERR "scsi(%li): Failed checksum\n", ha->host_no);
+		return err;
+	}
+
+	/* Start firmware execution. */
+	dprintk(1, "%s: start firmware running.\n", __FUNCTION__);
+	mb[0] = MBC_EXECUTE_FIRMWARE;
+	mb[1] = *ql1280_board_tbl[ha->devnum].fwstart;
+	err = qla1280_mailbox_command(ha, BIT_1 | BIT_0, &mb[0]);
+	if (err) {
+		printk(KERN_ERR "scsi(%li): Failed to start firmware\n",
+				ha->host_no);
+	}
+
+	return err;
+}
+
+static int
+qla1280_load_firmware(struct scsi_qla_host *ha)
+{
+	int err = -ENODEV;
+
+	/* If firmware needs to be loaded */
+	if (!qla1280_isp_firmware(ha)) {
+		printk(KERN_ERR "scsi(%li): isp_firmware() failed!\n",
+				ha->host_no);
+		goto out;
+	}
+
+	err = qla1280_chip_diag(ha);
+	if (err)
+		goto out;
+	if (IS_ISP1040(ha))
+		err = qla1280_load_firmware_pio(ha);
+	else
+		err = qla1280_load_firmware_dma(ha);
+	if (err)
+		goto out;
+	err = qla1280_start_firmware(ha);
+ out:
+	return err;
+}
+
+/*
+ * Initialize rings
+ *
+ * Input:
+ *      ha                = adapter block pointer.
+ *      ha->request_ring  = request ring virtual address
+ *      ha->response_ring = response ring virtual address
+ *      ha->request_dma   = request ring physical address
+ *      ha->response_dma  = response ring physical address
+ *
+ * Returns:
+ *      0 = success.
+ */
+static int
+qla1280_init_rings(struct scsi_qla_host *ha)
+{
+	uint16_t mb[MAILBOX_REGISTER_COUNT];
+	int status = 0;
+
+	ENTER("qla1280_init_rings");
+
+	/* Clear outstanding commands array. */
+	memset(ha->outstanding_cmds, 0,
+	       sizeof(struct srb *) * MAX_OUTSTANDING_COMMANDS);
+
+	/* Initialize request queue. */
+	ha->request_ring_ptr = ha->request_ring;
+	ha->req_ring_index = 0;
+	ha->req_q_cnt = REQUEST_ENTRY_CNT;
+	/* mb[0] = MBC_INIT_REQUEST_QUEUE; */
+	mb[0] = MBC_INIT_REQUEST_QUEUE_A64;
+	mb[1] = REQUEST_ENTRY_CNT;
+	mb[3] = ha->request_dma & 0xffff;
+	mb[2] = (ha->request_dma >> 16) & 0xffff;
+	mb[4] = 0;
+	mb[7] = pci_dma_hi32(ha->request_dma) & 0xffff;
+	mb[6] = pci_dma_hi32(ha->request_dma) >> 16;
+	if (!(status = qla1280_mailbox_command(ha, BIT_7 | BIT_6 | BIT_4 |
+					       BIT_3 | BIT_2 | BIT_1 | BIT_0,
+					       &mb[0]))) {
+		/* Initialize response queue. */
+		ha->response_ring_ptr = ha->response_ring;
+		ha->rsp_ring_index = 0;
+		/* mb[0] = MBC_INIT_RESPONSE_QUEUE; */
+		mb[0] = MBC_INIT_RESPONSE_QUEUE_A64;
+		mb[1] = RESPONSE_ENTRY_CNT;
+		mb[3] = ha->response_dma & 0xffff;
+		mb[2] = (ha->response_dma >> 16) & 0xffff;
+		mb[5] = 0;
+		mb[7] = pci_dma_hi32(ha->response_dma) & 0xffff;
+		mb[6] = pci_dma_hi32(ha->response_dma) >> 16;
+		status = qla1280_mailbox_command(ha, BIT_7 | BIT_6 | BIT_5 |
+						 BIT_3 | BIT_2 | BIT_1 | BIT_0,
+						 &mb[0]);
+	}
+
+	if (status)
+		dprintk(2, "qla1280_init_rings: **** FAILED ****\n");
+
+	LEAVE("qla1280_init_rings");
+	return status;
+}
+
+static void
+qla1280_print_settings(struct nvram *nv)
+{
+	dprintk(1, "qla1280 : initiator scsi id bus[0]=%d\n",
+		nv->bus[0].config_1.initiator_id);
+	dprintk(1, "qla1280 : initiator scsi id bus[1]=%d\n",
+		nv->bus[1].config_1.initiator_id);
+
+	dprintk(1, "qla1280 : bus reset delay[0]=%d\n",
+		nv->bus[0].bus_reset_delay);
+	dprintk(1, "qla1280 : bus reset delay[1]=%d\n",
+		nv->bus[1].bus_reset_delay);
+
+	dprintk(1, "qla1280 : retry count[0]=%d\n", nv->bus[0].retry_count);
+	dprintk(1, "qla1280 : retry delay[0]=%d\n", nv->bus[0].retry_delay);
+	dprintk(1, "qla1280 : retry count[1]=%d\n", nv->bus[1].retry_count);
+	dprintk(1, "qla1280 : retry delay[1]=%d\n", nv->bus[1].retry_delay);
+
+	dprintk(1, "qla1280 : async data setup time[0]=%d\n",
+		nv->bus[0].config_2.async_data_setup_time);
+	dprintk(1, "qla1280 : async data setup time[1]=%d\n",
+		nv->bus[1].config_2.async_data_setup_time);
+
+	dprintk(1, "qla1280 : req/ack active negation[0]=%d\n",
+		nv->bus[0].config_2.req_ack_active_negation);
+	dprintk(1, "qla1280 : req/ack active negation[1]=%d\n",
+		nv->bus[1].config_2.req_ack_active_negation);
+
+	dprintk(1, "qla1280 : data line active negation[0]=%d\n",
+		nv->bus[0].config_2.data_line_active_negation);
+	dprintk(1, "qla1280 : data line active negation[1]=%d\n",
+		nv->bus[1].config_2.data_line_active_negation);
+
+	dprintk(1, "qla1280 : disable loading risc code=%d\n",
+		nv->cntr_flags_1.disable_loading_risc_code);
+
+	dprintk(1, "qla1280 : enable 64bit addressing=%d\n",
+		nv->cntr_flags_1.enable_64bit_addressing);
+
+	dprintk(1, "qla1280 : selection timeout limit[0]=%d\n",
+		nv->bus[0].selection_timeout);
+	dprintk(1, "qla1280 : selection timeout limit[1]=%d\n",
+		nv->bus[1].selection_timeout);
+
+	dprintk(1, "qla1280 : max queue depth[0]=%d\n",
+		nv->bus[0].max_queue_depth);
+	dprintk(1, "qla1280 : max queue depth[1]=%d\n",
+		nv->bus[1].max_queue_depth);
+}
+
+static void
+qla1280_set_target_defaults(struct scsi_qla_host *ha, int bus, int target)
+{
+	struct nvram *nv = &ha->nvram;
+
+	nv->bus[bus].target[target].parameter.f.renegotiate_on_error = 1;
+	nv->bus[bus].target[target].parameter.f.auto_request_sense = 1;
+	nv->bus[bus].target[target].parameter.f.tag_queuing = 1;
+	nv->bus[bus].target[target].parameter.f.enable_sync = 1;
+#if 1	/* Some SCSI Processors do not seem to like this */
+	nv->bus[bus].target[target].parameter.f.enable_wide = 1;
+#endif
+	nv->bus[bus].target[target].parameter.f.parity_checking = 1;
+	nv->bus[bus].target[target].parameter.f.disconnect_allowed = 1;
+	nv->bus[bus].target[target].execution_throttle =
+		nv->bus[bus].max_queue_depth - 1;
+
+	if (IS_ISP1x160(ha)) {
+		nv->bus[bus].target[target].flags.flags1x160.device_enable = 1;
+		nv->bus[bus].target[target].flags.flags1x160.sync_offset = 0x0e;
+		nv->bus[bus].target[target].sync_period = 9;
+		nv->bus[bus].target[target].ppr_1x160.flags.enable_ppr = 1;
+		nv->bus[bus].target[target].ppr_1x160.flags.ppr_options = 2;
+		nv->bus[bus].target[target].ppr_1x160.flags.ppr_bus_width = 1;
+	} else {
+		nv->bus[bus].target[target].flags.flags1x80.device_enable = 1;
+		nv->bus[bus].target[target].flags.flags1x80.sync_offset = 12;
+		nv->bus[bus].target[target].sync_period = 10;
+	}
+}
+
+static void
+qla1280_set_defaults(struct scsi_qla_host *ha)
+{
+	struct nvram *nv = &ha->nvram;
+	int bus, target;
+
+	dprintk(1, "Using defaults for NVRAM: \n");
+	memset(nv, 0, sizeof(struct nvram));
+
+	/* nv->cntr_flags_1.disable_loading_risc_code = 1; */
+	nv->firmware_feature.f.enable_fast_posting = 1;
+	nv->firmware_feature.f.disable_synchronous_backoff = 1;
+	nv->termination.f.scsi_bus_0_control = 3;
+	nv->termination.f.scsi_bus_1_control = 3;
+	nv->termination.f.auto_term_support = 1;
+
+	/*
+	 * Set default FIFO magic - What appropriate values would be here
+	 * is unknown. This is what I have found testing with 12160s.
+	 *
+	 * Now, I would love the magic decoder ring for this one, the
+	 * header file provided by QLogic seems to be bogus or incomplete
+	 * at best.
+	 */
+	nv->isp_config.c = ISP_CFG1_BENAB|ISP_CFG1_F128;
+	if (IS_ISP1x160(ha))
+		nv->isp_parameter = 0x01; /* fast memory enable */
+
+	for (bus = 0; bus < MAX_BUSES; bus++) {
+		nv->bus[bus].config_1.initiator_id = 7;
+		nv->bus[bus].config_2.req_ack_active_negation = 1;
+		nv->bus[bus].config_2.data_line_active_negation = 1;
+		nv->bus[bus].selection_timeout = 250;
+		nv->bus[bus].max_queue_depth = 256;
+
+		if (IS_ISP1040(ha)) {
+			nv->bus[bus].bus_reset_delay = 3;
+			nv->bus[bus].config_2.async_data_setup_time = 6;
+			nv->bus[bus].retry_delay = 1;
+		} else {
+			nv->bus[bus].bus_reset_delay = 5;
+			nv->bus[bus].config_2.async_data_setup_time = 8;
+		}
+
+		for (target = 0; target < MAX_TARGETS; target++)
+			qla1280_set_target_defaults(ha, bus, target);
+	}
+}
+
+static int
+qla1280_config_target(struct scsi_qla_host *ha, int bus, int target)
+{
+	struct nvram *nv = &ha->nvram;
+	uint16_t mb[MAILBOX_REGISTER_COUNT];
+	int status, lun;
+
+	/* Set Target Parameters. */
+	mb[0] = MBC_SET_TARGET_PARAMETERS;
+	mb[1] = (uint16_t) (bus ? target | BIT_7 : target);
+	mb[1] <<= 8;
+
+	/*
+	 * Do not enable wide, sync, and ppr for the initial
+	 * INQUIRY run. We enable this later if we determine
+	 * the target actually supports it.
+	 */
+	nv->bus[bus].target[target].parameter.f.
+		auto_request_sense = 1;
+	nv->bus[bus].target[target].parameter.f.
+		stop_queue_on_check = 0;
+
+	if (IS_ISP1x160(ha))
+		nv->bus[bus].target[target].ppr_1x160.
+			flags.enable_ppr = 0;
+
+	/*
+	 * No sync, wide, etc. while probing
+	 */
+	mb[2] = (nv->bus[bus].target[target].parameter.c << 8) &
+		~(TP_SYNC /*| TP_WIDE | TP_PPR*/);
+
+	if (IS_ISP1x160(ha))
+		mb[3] =	nv->bus[bus].target[target].flags.flags1x160.sync_offset << 8;
+	else
+		mb[3] =	nv->bus[bus].target[target].flags.flags1x80.sync_offset << 8;
+	mb[3] |= nv->bus[bus].target[target].sync_period;
+
+	status = qla1280_mailbox_command(ha, BIT_3 | BIT_2 | BIT_1 | BIT_0, &mb[0]);
+
+	/* Save Tag queuing enable flag. */
+	mb[0] = BIT_0 << target;
+	if (nv->bus[bus].target[target].parameter.f.tag_queuing)
+		ha->bus_settings[bus].qtag_enables |= mb[0];
+
+	/* Save Device enable flag. */
+	if (IS_ISP1x160(ha)) {
+		if (nv->bus[bus].target[target].flags.flags1x160.device_enable)
+			ha->bus_settings[bus].device_enables |= mb[0];
+		ha->bus_settings[bus].lun_disables |= 0;
+	} else {
+		if (nv->bus[bus].target[target].flags.flags1x80.device_enable)
+			ha->bus_settings[bus].device_enables |= mb[0];
+		/* Save LUN disable flag. */
+		if (nv->bus[bus].target[target].flags.flags1x80.lun_disable)
+			ha->bus_settings[bus].lun_disables |= mb[0];
+	}
+
+	/* Set Device Queue Parameters. */
+	for (lun = 0; lun < MAX_LUNS; lun++) {
+		mb[0] = MBC_SET_DEVICE_QUEUE;
+		mb[1] = (uint16_t)(bus ? target | BIT_7 : target);
+		mb[1] = mb[1] << 8 | lun;
+		mb[2] = nv->bus[bus].max_queue_depth;
+		mb[3] = nv->bus[bus].target[target].execution_throttle;
+		status |= qla1280_mailbox_command(ha, 0x0f, &mb[0]);
+	}
+
+	return status;
+}
+
+static int
+qla1280_config_bus(struct scsi_qla_host *ha, int bus)
+{
+	struct nvram *nv = &ha->nvram;
+	uint16_t mb[MAILBOX_REGISTER_COUNT];
+	int target, status;
+
+	/* SCSI Reset Disable. */
+	ha->bus_settings[bus].disable_scsi_reset =
+		nv->bus[bus].config_1.scsi_reset_disable;
+
+	/* Initiator ID. */
+	ha->bus_settings[bus].id = nv->bus[bus].config_1.initiator_id;
+	mb[0] = MBC_SET_INITIATOR_ID;
+	mb[1] = bus ? ha->bus_settings[bus].id | BIT_7 :
+		ha->bus_settings[bus].id;
+	status = qla1280_mailbox_command(ha, BIT_1 | BIT_0, &mb[0]);
+
+	/* Reset Delay. */
+	ha->bus_settings[bus].bus_reset_delay =
+		nv->bus[bus].bus_reset_delay;
+
+	/* Command queue depth per device. */
+	ha->bus_settings[bus].hiwat = nv->bus[bus].max_queue_depth - 1;
+
+	/* Set target parameters. */
+	for (target = 0; target < MAX_TARGETS; target++)
+		status |= qla1280_config_target(ha, bus, target);
+
+	return status;
+}
+
+static int
+qla1280_nvram_config(struct scsi_qla_host *ha)
+{
+	struct device_reg __iomem *reg = ha->iobase;
+	struct nvram *nv = &ha->nvram;
+	int bus, target, status = 0;
+	uint16_t mb[MAILBOX_REGISTER_COUNT];
+	uint16_t mask;
+
+	ENTER("qla1280_nvram_config");
+
+	if (ha->nvram_valid) {
+		/* Always force AUTO sense for LINUX SCSI */
+		for (bus = 0; bus < MAX_BUSES; bus++)
+			for (target = 0; target < MAX_TARGETS; target++) {
+				nv->bus[bus].target[target].parameter.f.
+					auto_request_sense = 1;
+			}
+	} else {
+		qla1280_set_defaults(ha);
+	}
+
+	qla1280_print_settings(nv);
+
+	/* Disable RISC load of firmware. */
+	ha->flags.disable_risc_code_load =
+		nv->cntr_flags_1.disable_loading_risc_code;
+
+	if (IS_ISP1040(ha)) {
+		uint16_t hwrev, cfg1, cdma_conf, ddma_conf;
+
+		hwrev = RD_REG_WORD(&reg->cfg_0) & ISP_CFG0_HWMSK;
+
+		cfg1 = RD_REG_WORD(&reg->cfg_1);
+		cdma_conf = RD_REG_WORD(&reg->cdma_cfg);
+		ddma_conf = RD_REG_WORD(&reg->ddma_cfg);
+
+		/* Busted fifo, says mjacob. */
+		if (hwrev == ISP_CFG0_1040A)
+			WRT_REG_WORD(&reg->cfg_1, cfg1 | ISP_CFG1_F64);
+		else
+			WRT_REG_WORD(&reg->cfg_1, cfg1 | ISP_CFG1_F64 | ISP_CFG1_BENAB);
+
+		WRT_REG_WORD(&reg->cdma_cfg, cdma_conf | CDMA_CONF_BENAB);
+		WRT_REG_WORD(&reg->ddma_cfg, cdma_conf | DDMA_CONF_BENAB);
+	} else {
+		/* Set ISP hardware DMA burst */
+		mb[0] = nv->isp_config.c;
+		/* Enable DMA arbitration on dual channel controllers */
+		if (ha->ports > 1)
+			mb[0] |= BIT_13;
+		WRT_REG_WORD(&reg->cfg_1, mb[0]);
+
+		/* Set SCSI termination. */
+		WRT_REG_WORD(&reg->gpio_enable, (BIT_3 + BIT_2 + BIT_1 + BIT_0));
+		mb[0] = nv->termination.c & (BIT_3 + BIT_2 + BIT_1 + BIT_0);
+		WRT_REG_WORD(&reg->gpio_data, mb[0]);
+	}
+
+	/* ISP parameter word. */
+	mb[0] = MBC_SET_SYSTEM_PARAMETER;
+	mb[1] = nv->isp_parameter;
+	status |= qla1280_mailbox_command(ha, BIT_1 | BIT_0, &mb[0]);
+
+	if (IS_ISP1x40(ha)) {
+		/* clock rate - for qla1240 and older, only */
+		mb[0] = MBC_SET_CLOCK_RATE;
+		mb[1] = 40;
+	 	status |= qla1280_mailbox_command(ha, BIT_1 | BIT_0, mb);
+	}
+
+	/* Firmware feature word. */
+	mb[0] = MBC_SET_FIRMWARE_FEATURES;
+	mask = BIT_5 | BIT_1 | BIT_0;
+	mb[1] = le16_to_cpu(nv->firmware_feature.w) & (mask);
+#if defined(CONFIG_IA64_GENERIC) || defined (CONFIG_IA64_SGI_SN2)
+	if (ia64_platform_is("sn2")) {
+		printk(KERN_INFO "scsi(%li): Enabling SN2 PCI DMA "
+		       "workaround\n", ha->host_no);
+		mb[1] |= BIT_9;
+	}
+#endif
+	status |= qla1280_mailbox_command(ha, mask, &mb[0]);
+
+	/* Retry count and delay. */
+	mb[0] = MBC_SET_RETRY_COUNT;
+	mb[1] = nv->bus[0].retry_count;
+	mb[2] = nv->bus[0].retry_delay;
+	mb[6] = nv->bus[1].retry_count;
+	mb[7] = nv->bus[1].retry_delay;
+	status |= qla1280_mailbox_command(ha, BIT_7 | BIT_6 | BIT_2 |
+					  BIT_1 | BIT_0, &mb[0]);
+
+	/* ASYNC data setup time. */
+	mb[0] = MBC_SET_ASYNC_DATA_SETUP;
+	mb[1] = nv->bus[0].config_2.async_data_setup_time;
+	mb[2] = nv->bus[1].config_2.async_data_setup_time;
+	status |= qla1280_mailbox_command(ha, BIT_2 | BIT_1 | BIT_0, &mb[0]);
+
+	/* Active negation states. */
+	mb[0] = MBC_SET_ACTIVE_NEGATION;
+	mb[1] = 0;
+	if (nv->bus[0].config_2.req_ack_active_negation)
+		mb[1] |= BIT_5;
+	if (nv->bus[0].config_2.data_line_active_negation)
+		mb[1] |= BIT_4;
+	mb[2] = 0;
+	if (nv->bus[1].config_2.req_ack_active_negation)
+		mb[2] |= BIT_5;
+	if (nv->bus[1].config_2.data_line_active_negation)
+		mb[2] |= BIT_4;
+	status |= qla1280_mailbox_command(ha, BIT_2 | BIT_1 | BIT_0, &mb[0]);
+
+	mb[0] = MBC_SET_DATA_OVERRUN_RECOVERY;
+	mb[1] = 2;	/* Reset SCSI bus and return all outstanding IO */
+	status |= qla1280_mailbox_command(ha, BIT_1 | BIT_0, &mb[0]);
+
+	/* thingy */
+	mb[0] = MBC_SET_PCI_CONTROL;
+	mb[1] = 2;	/* Data DMA Channel Burst Enable */
+	mb[2] = 2;	/* Command DMA Channel Burst Enable */
+	status |= qla1280_mailbox_command(ha, BIT_2 | BIT_1 | BIT_0, &mb[0]);
+
+	mb[0] = MBC_SET_TAG_AGE_LIMIT;
+	mb[1] = 8;
+	status |= qla1280_mailbox_command(ha, BIT_1 | BIT_0, &mb[0]);
+
+	/* Selection timeout. */
+	mb[0] = MBC_SET_SELECTION_TIMEOUT;
+	mb[1] = nv->bus[0].selection_timeout;
+	mb[2] = nv->bus[1].selection_timeout;
+	status |= qla1280_mailbox_command(ha, BIT_2 | BIT_1 | BIT_0, &mb[0]);
+
+	for (bus = 0; bus < ha->ports; bus++)
+		status |= qla1280_config_bus(ha, bus);
+
+	if (status)
+		dprintk(2, "qla1280_nvram_config: **** FAILED ****\n");
+
+	LEAVE("qla1280_nvram_config");
+	return status;
+}
+
+/*
+ * Get NVRAM data word
+ *      Calculates word position in NVRAM and calls request routine to
+ *      get the word from NVRAM.
+ *
+ * Input:
+ *      ha      = adapter block pointer.
+ *      address = NVRAM word address.
+ *
+ * Returns:
+ *      data word.
+ */
+static uint16_t
+qla1280_get_nvram_word(struct scsi_qla_host *ha, uint32_t address)
+{
+	uint32_t nv_cmd;
+	uint16_t data;
+
+	nv_cmd = address << 16;
+	nv_cmd |= NV_READ_OP;
+
+	data = le16_to_cpu(qla1280_nvram_request(ha, nv_cmd));
+
+	dprintk(8, "qla1280_get_nvram_word: exiting normally NVRAM data = "
+		"0x%x", data);
+
+	return data;
+}
+
+/*
+ * NVRAM request
+ *      Sends read command to NVRAM and gets data from NVRAM.
+ *
+ * Input:
+ *      ha     = adapter block pointer.
+ *      nv_cmd = Bit 26     = start bit
+ *               Bit 25, 24 = opcode
+ *               Bit 23-16  = address
+ *               Bit 15-0   = write data
+ *
+ * Returns:
+ *      data word.
+ */
+static uint16_t
+qla1280_nvram_request(struct scsi_qla_host *ha, uint32_t nv_cmd)
+{
+	struct device_reg __iomem *reg = ha->iobase;
+	int cnt;
+	uint16_t data = 0;
+	uint16_t reg_data;
+
+	/* Send command to NVRAM. */
+
+	nv_cmd <<= 5;
+	for (cnt = 0; cnt < 11; cnt++) {
+		if (nv_cmd & BIT_31)
+			qla1280_nv_write(ha, NV_DATA_OUT);
+		else
+			qla1280_nv_write(ha, 0);
+		nv_cmd <<= 1;
+	}
+
+	/* Read data from NVRAM. */
+
+	for (cnt = 0; cnt < 16; cnt++) {
+		WRT_REG_WORD(&reg->nvram, (NV_SELECT | NV_CLOCK));
+		RD_REG_WORD(&reg->id_l);	/* Flush PCI write */
+		NVRAM_DELAY();
+		data <<= 1;
+		reg_data = RD_REG_WORD(&reg->nvram);
+		if (reg_data & NV_DATA_IN)
+			data |= BIT_0;
+		WRT_REG_WORD(&reg->nvram, NV_SELECT);
+		RD_REG_WORD(&reg->id_l);	/* Flush PCI write */
+		NVRAM_DELAY();
+	}
+
+	/* Deselect chip. */
+
+	WRT_REG_WORD(&reg->nvram, NV_DESELECT);
+	RD_REG_WORD(&reg->id_l);	/* Flush PCI write */
+	NVRAM_DELAY();
+
+	return data;
+}
+
+static void
+qla1280_nv_write(struct scsi_qla_host *ha, uint16_t data)
+{
+	struct device_reg __iomem *reg = ha->iobase;
+
+	WRT_REG_WORD(&reg->nvram, data | NV_SELECT);
+	RD_REG_WORD(&reg->id_l);	/* Flush PCI write */
+	NVRAM_DELAY();
+	WRT_REG_WORD(&reg->nvram, data | NV_SELECT | NV_CLOCK);
+	RD_REG_WORD(&reg->id_l);	/* Flush PCI write */
+	NVRAM_DELAY();
+	WRT_REG_WORD(&reg->nvram, data | NV_SELECT);
+	RD_REG_WORD(&reg->id_l);	/* Flush PCI write */
+	NVRAM_DELAY();
+}
+
+/*
+ * Mailbox Command
+ *      Issue mailbox command and waits for completion.
+ *
+ * Input:
+ *      ha = adapter block pointer.
+ *      mr = mailbox registers to load.
+ *      mb = data pointer for mailbox registers.
+ *
+ * Output:
+ *      mb[MAILBOX_REGISTER_COUNT] = returned mailbox data.
+ *
+ * Returns:
+ *      0 = success
+ */
+static int
+qla1280_mailbox_command(struct scsi_qla_host *ha, uint8_t mr, uint16_t *mb)
+{
+	struct device_reg __iomem *reg = ha->iobase;
+#if 0
+	LIST_HEAD(done_q);
+#endif
+	int status = 0;
+	int cnt;
+	uint16_t *optr, *iptr;
+	uint16_t __iomem *mptr;
+	uint16_t data;
+	DECLARE_COMPLETION(wait);
+	struct timer_list timer;
+
+	ENTER("qla1280_mailbox_command");
+
+	if (ha->mailbox_wait) {
+		printk(KERN_ERR "Warning mailbox wait already in use!\n");
+	}
+	ha->mailbox_wait = &wait;
+
+	/*
+	 * We really should start out by verifying that the mailbox is
+	 * available before starting sending the command data
+	 */
+	/* Load mailbox registers. */
+	mptr = (uint16_t __iomem *) &reg->mailbox0;
+	iptr = mb;
+	for (cnt = 0; cnt < MAILBOX_REGISTER_COUNT; cnt++) {
+		if (mr & BIT_0) {
+			WRT_REG_WORD(mptr, (*iptr));
+		}
+
+		mr >>= 1;
+		mptr++;
+		iptr++;
+	}
+
+	/* Issue set host interrupt command. */
+
+	/* set up a timer just in case we're really jammed */
+	init_timer(&timer);
+	timer.expires = jiffies + 20*HZ;
+	timer.data = (unsigned long)ha;
+	timer.function = qla1280_mailbox_timeout;
+	add_timer(&timer);
+
+	spin_unlock_irq(HOST_LOCK);
+	WRT_REG_WORD(&reg->host_cmd, HC_SET_HOST_INT);
+	data = qla1280_debounce_register(&reg->istatus);
+
+	wait_for_completion(&wait);
+	del_timer_sync(&timer);
+
+	spin_lock_irq(HOST_LOCK);
+
+	ha->mailbox_wait = NULL;
+
+	/* Check for mailbox command timeout. */
+	if (ha->mailbox_out[0] != MBS_CMD_CMP) {
+		printk(KERN_WARNING "qla1280_mailbox_command: Command failed, "
+		       "mailbox0 = 0x%04x, mailbox_out0 = 0x%04x, istatus = "
+		       "0x%04x\n", 
+		       mb[0], ha->mailbox_out[0], RD_REG_WORD(&reg->istatus));
+		printk(KERN_WARNING "m0 %04x, m1 %04x, m2 %04x, m3 %04x\n",
+		       RD_REG_WORD(&reg->mailbox0), RD_REG_WORD(&reg->mailbox1),
+		       RD_REG_WORD(&reg->mailbox2), RD_REG_WORD(&reg->mailbox3));
+		printk(KERN_WARNING "m4 %04x, m5 %04x, m6 %04x, m7 %04x\n",
+		       RD_REG_WORD(&reg->mailbox4), RD_REG_WORD(&reg->mailbox5),
+		       RD_REG_WORD(&reg->mailbox6), RD_REG_WORD(&reg->mailbox7));
+		status = 1;
+	}
+
+	/* Load return mailbox registers. */
+	optr = mb;
+	iptr = (uint16_t *) &ha->mailbox_out[0];
+	mr = MAILBOX_REGISTER_COUNT;
+	memcpy(optr, iptr, MAILBOX_REGISTER_COUNT * sizeof(uint16_t));
+
+#if 0
+	/* Go check for any response interrupts pending. */
+	qla1280_isr(ha, &done_q);
+#endif
+
+	if (ha->flags.reset_marker)
+		qla1280_rst_aen(ha);
+
+#if 0
+	if (!list_empty(&done_q))
+		qla1280_done(ha, &done_q);
+#endif
+
+	if (status)
+		dprintk(2, "qla1280_mailbox_command: **** FAILED, mailbox0 = "
+			"0x%x ****\n", mb[0]);
+
+	LEAVE("qla1280_mailbox_command");
+	return status;
+}
+
+/*
+ * qla1280_poll
+ *      Polls ISP for interrupts.
+ *
+ * Input:
+ *      ha = adapter block pointer.
+ */
+static void
+qla1280_poll(struct scsi_qla_host *ha)
+{
+	struct device_reg __iomem *reg = ha->iobase;
+	uint16_t data;
+	LIST_HEAD(done_q);
+
+	/* ENTER("qla1280_poll"); */
+
+	/* Check for pending interrupts. */
+	data = RD_REG_WORD(&reg->istatus);
+	if (data & RISC_INT)
+		qla1280_isr(ha, &done_q);
+
+	if (!ha->mailbox_wait) {
+		if (ha->flags.reset_marker)
+			qla1280_rst_aen(ha);
+	}
+
+	if (!list_empty(&done_q))
+		qla1280_done(ha);
+
+	/* LEAVE("qla1280_poll"); */
+}
+
+/*
+ * qla1280_bus_reset
+ *      Issue SCSI bus reset.
+ *
+ * Input:
+ *      ha  = adapter block pointer.
+ *      bus = SCSI bus number.
+ *
+ * Returns:
+ *      0 = success
+ */
+static int
+qla1280_bus_reset(struct scsi_qla_host *ha, int bus)
+{
+	uint16_t mb[MAILBOX_REGISTER_COUNT];
+	uint16_t reset_delay;
+	int status;
+
+	dprintk(3, "qla1280_bus_reset: entered\n");
+
+	if (qla1280_verbose)
+		printk(KERN_INFO "scsi(%li:%i): Resetting SCSI BUS\n",
+		       ha->host_no, bus);
+
+	reset_delay = ha->bus_settings[bus].bus_reset_delay;
+	mb[0] = MBC_BUS_RESET;
+	mb[1] = reset_delay;
+	mb[2] = (uint16_t) bus;
+	status = qla1280_mailbox_command(ha, BIT_2 | BIT_1 | BIT_0, &mb[0]);
+
+	if (status) {
+		if (ha->bus_settings[bus].failed_reset_count > 2)
+			ha->bus_settings[bus].scsi_bus_dead = 1;
+		ha->bus_settings[bus].failed_reset_count++;
+	} else {
+		spin_unlock_irq(HOST_LOCK);
+		schedule_timeout(reset_delay * HZ);
+		spin_lock_irq(HOST_LOCK);
+
+		ha->bus_settings[bus].scsi_bus_dead = 0;
+		ha->bus_settings[bus].failed_reset_count = 0;
+		ha->bus_settings[bus].reset_marker = 0;
+		/* Issue marker command. */
+		qla1280_marker(ha, bus, 0, 0, MK_SYNC_ALL);
+	}
+
+	/*
+	 * We should probably call qla1280_set_target_parameters()
+	 * here as well for all devices on the bus.
+	 */
+
+	if (status)
+		dprintk(2, "qla1280_bus_reset: **** FAILED ****\n");
+	else
+		dprintk(3, "qla1280_bus_reset: exiting normally\n");
+
+	return status;
+}
+
+/*
+ * qla1280_device_reset
+ *      Issue bus device reset message to the target.
+ *
+ * Input:
+ *      ha      = adapter block pointer.
+ *      bus     = SCSI BUS number.
+ *      target  = SCSI ID.
+ *
+ * Returns:
+ *      0 = success
+ */
+static int
+qla1280_device_reset(struct scsi_qla_host *ha, int bus, int target)
+{
+	uint16_t mb[MAILBOX_REGISTER_COUNT];
+	int status;
+
+	ENTER("qla1280_device_reset");
+
+	mb[0] = MBC_ABORT_TARGET;
+	mb[1] = (bus ? (target | BIT_7) : target) << 8;
+	mb[2] = 1;
+	status = qla1280_mailbox_command(ha, BIT_2 | BIT_1 | BIT_0, &mb[0]);
+
+	/* Issue marker command. */
+	qla1280_marker(ha, bus, target, 0, MK_SYNC_ID);
+
+	if (status)
+		dprintk(2, "qla1280_device_reset: **** FAILED ****\n");
+
+	LEAVE("qla1280_device_reset");
+	return status;
+}
+
+/*
+ * qla1280_abort_device
+ *      Issue an abort message to the device
+ *
+ * Input:
+ *      ha     = adapter block pointer.
+ *      bus    = SCSI BUS.
+ *      target = SCSI ID.
+ *      lun    = SCSI LUN.
+ *
+ * Returns:
+ *      0 = success
+ */
+static int
+qla1280_abort_device(struct scsi_qla_host *ha, int bus, int target, int lun)
+{
+	uint16_t mb[MAILBOX_REGISTER_COUNT];
+	int status;
+
+	ENTER("qla1280_abort_device");
+
+	mb[0] = MBC_ABORT_DEVICE;
+	mb[1] = (bus ? target | BIT_7 : target) << 8 | lun;
+	status = qla1280_mailbox_command(ha, BIT_1 | BIT_0, &mb[0]);
+
+	/* Issue marker command. */
+	qla1280_marker(ha, bus, target, lun, MK_SYNC_ID_LUN);
+
+	if (status)
+		dprintk(2, "qla1280_abort_device: **** FAILED ****\n");
+
+	LEAVE("qla1280_abort_device");
+	return status;
+}
+
+/*
+ * qla1280_abort_command
+ *      Abort command aborts a specified IOCB.
+ *
+ * Input:
+ *      ha = adapter block pointer.
+ *      sp = SB structure pointer.
+ *
+ * Returns:
+ *      0 = success
+ */
+static int
+qla1280_abort_command(struct scsi_qla_host *ha, struct srb * sp, int handle)
+{
+	uint16_t mb[MAILBOX_REGISTER_COUNT];
+	unsigned int bus, target, lun;
+	int status;
+
+	ENTER("qla1280_abort_command");
+
+	bus = SCSI_BUS_32(sp->cmd);
+	target = SCSI_TCN_32(sp->cmd);
+	lun = SCSI_LUN_32(sp->cmd);
+
+	sp->flags |= SRB_ABORT_PENDING;
+
+	mb[0] = MBC_ABORT_COMMAND;
+	mb[1] = (bus ? target | BIT_7 : target) << 8 | lun;
+	mb[2] = handle >> 16;
+	mb[3] = handle & 0xffff;
+	status = qla1280_mailbox_command(ha, 0x0f, &mb[0]);
+
+	if (status) {
+		dprintk(2, "qla1280_abort_command: **** FAILED ****\n");
+		sp->flags &= ~SRB_ABORT_PENDING;
+	}
+
+
+	LEAVE("qla1280_abort_command");
+	return status;
+}
+
+/*
+ * qla1280_reset_adapter
+ *      Reset adapter.
+ *
+ * Input:
+ *      ha = adapter block pointer.
+ */
+static void
+qla1280_reset_adapter(struct scsi_qla_host *ha)
+{
+	struct device_reg __iomem *reg = ha->iobase;
+
+	ENTER("qla1280_reset_adapter");
+
+	/* Disable ISP chip */
+	ha->flags.online = 0;
+	WRT_REG_WORD(&reg->ictrl, ISP_RESET);
+	WRT_REG_WORD(&reg->host_cmd,
+		     HC_RESET_RISC | HC_RELEASE_RISC | HC_DISABLE_BIOS);
+	RD_REG_WORD(&reg->id_l);	/* Flush PCI write */
+
+	LEAVE("qla1280_reset_adapter");
+}
+
+/*
+ *  Issue marker command.
+ *      Function issues marker IOCB.
+ *
+ * Input:
+ *      ha   = adapter block pointer.
+ *      bus  = SCSI BUS number
+ *      id   = SCSI ID
+ *      lun  = SCSI LUN
+ *      type = marker modifier
+ */
+static void
+qla1280_marker(struct scsi_qla_host *ha, int bus, int id, int lun, u8 type)
+{
+	struct mrk_entry *pkt;
+
+	ENTER("qla1280_marker");
+
+	/* Get request packet. */
+	if ((pkt = (struct mrk_entry *) qla1280_req_pkt(ha))) {
+		pkt->entry_type = MARKER_TYPE;
+		pkt->lun = (uint8_t) lun;
+		pkt->target = (uint8_t) (bus ? (id | BIT_7) : id);
+		pkt->modifier = type;
+		pkt->entry_status = 0;
+
+		/* Issue command to ISP */
+		qla1280_isp_cmd(ha);
+	}
+
+	LEAVE("qla1280_marker");
+}
+
+
+/*
+ * qla1280_64bit_start_scsi
+ *      The start SCSI is responsible for building request packets on
+ *      request ring and modifying ISP input pointer.
+ *
+ * Input:
+ *      ha = adapter block pointer.
+ *      sp = SB structure pointer.
+ *
+ * Returns:
+ *      0 = success, was able to issue command.
+ */
+#ifdef QLA_64BIT_PTR
+static int
+qla1280_64bit_start_scsi(struct scsi_qla_host *ha, struct srb * sp)
+{
+	struct device_reg __iomem *reg = ha->iobase;
+	struct scsi_cmnd *cmd = sp->cmd;
+	cmd_a64_entry_t *pkt;
+	struct scatterlist *sg = NULL;
+	u32 *dword_ptr;
+	dma_addr_t dma_handle;
+	int status = 0;
+	int cnt;
+	int req_cnt;
+	u16 seg_cnt;
+	u8 dir;
+
+	ENTER("qla1280_64bit_start_scsi:");
+
+	/* Calculate number of entries and segments required. */
+	req_cnt = 1;
+	if (cmd->use_sg) {
+		sg = (struct scatterlist *) cmd->request_buffer;
+		seg_cnt = pci_map_sg(ha->pdev, sg, cmd->use_sg,
+				     cmd->sc_data_direction);
+
+		if (seg_cnt > 2) {
+			req_cnt += (seg_cnt - 2) / 5;
+			if ((seg_cnt - 2) % 5)
+				req_cnt++;
+		}
+	} else if (cmd->request_bufflen) {	/* If data transfer. */
+		seg_cnt = 1;
+	} else {
+		seg_cnt = 0;
+	}
+
+	if ((req_cnt + 2) >= ha->req_q_cnt) {
+		/* Calculate number of free request entries. */
+		cnt = RD_REG_WORD(&reg->mailbox4);
+		if (ha->req_ring_index < cnt)
+			ha->req_q_cnt = cnt - ha->req_ring_index;
+		else
+			ha->req_q_cnt =
+				REQUEST_ENTRY_CNT - (ha->req_ring_index - cnt);
+	}
+
+	/* If room for request in request ring. */
+	if ((req_cnt + 2) >= ha->req_q_cnt) {
+		status = 1;
+		dprintk(2, "qla1280_64bit_start_scsi: in-ptr=0x%x  req_q_cnt="
+			"0x%xreq_cnt=0x%x", ha->req_ring_index, ha->req_q_cnt,
+			req_cnt);
+		goto out;
+	}
+
+	/* Check for room in outstanding command list. */
+	for (cnt = 0; cnt < MAX_OUTSTANDING_COMMANDS &&
+		     ha->outstanding_cmds[cnt] != 0; cnt++);
+
+	if (cnt >= MAX_OUTSTANDING_COMMANDS) {
+		status = 1;
+		dprintk(2, "qla1280_64bit_start_scsi: NO ROOM IN "
+			"OUTSTANDING ARRAY, req_q_cnt=0x%x", ha->req_q_cnt);
+		goto out;
+	}
+
+	ha->outstanding_cmds[cnt] = sp;
+	ha->req_q_cnt -= req_cnt;
+	CMD_HANDLE(sp->cmd) = (unsigned char *)(unsigned long)(cnt + 1);
+
+	dprintk(2, "64bit_start: cmd=%p sp=%p CDB=%xm, handle %lx\n", cmd, sp,
+		cmd->cmnd[0], (long)CMD_HANDLE(sp->cmd));
+	dprintk(2, "             bus %i, target %i, lun %i\n",
+		SCSI_BUS_32(cmd), SCSI_TCN_32(cmd), SCSI_LUN_32(cmd));
+	qla1280_dump_buffer(2, cmd->cmnd, MAX_COMMAND_SIZE);
+
+	/*
+	 * Build command packet.
+	 */
+	pkt = (cmd_a64_entry_t *) ha->request_ring_ptr;
+
+	pkt->entry_type = COMMAND_A64_TYPE;
+	pkt->entry_count = (uint8_t) req_cnt;
+	pkt->sys_define = (uint8_t) ha->req_ring_index;
+	pkt->entry_status = 0;
+	pkt->handle = cpu_to_le32(cnt);
+
+	/* Zero out remaining portion of packet. */
+	memset(((char *)pkt + 8), 0, (REQUEST_ENTRY_SIZE - 8));
+
+	/* Set ISP command timeout. */
+	pkt->timeout = cpu_to_le16(30);
+
+	/* Set device target ID and LUN */
+	pkt->lun = SCSI_LUN_32(cmd);
+	pkt->target = SCSI_BUS_32(cmd) ?
+		(SCSI_TCN_32(cmd) | BIT_7) : SCSI_TCN_32(cmd);
+
+	/* Enable simple tag queuing if device supports it. */
+	if (DEV_SIMPLE_TAGS(cmd->device))
+		pkt->control_flags |= cpu_to_le16(BIT_3);
+
+	/* Load SCSI command packet. */
+	pkt->cdb_len = cpu_to_le16(CMD_CDBLEN(cmd));
+	memcpy(pkt->scsi_cdb, &(CMD_CDBP(cmd)), CMD_CDBLEN(cmd));
+	/* dprintk(1, "Build packet for command[0]=0x%x\n",pkt->scsi_cdb[0]); */
+
+	/* Set transfer direction. */
+	dir = qla1280_data_direction(cmd);
+	pkt->control_flags |= cpu_to_le16(dir);
+
+	/* Set total data segment count. */
+	pkt->dseg_count = cpu_to_le16(seg_cnt);
+
+	/*
+	 * Load data segments.
+	 */
+	if (seg_cnt) {	/* If data transfer. */
+		/* Setup packet address segment pointer. */
+		dword_ptr = (u32 *)&pkt->dseg_0_address;
+
+		if (cmd->use_sg) {	/* If scatter gather */
+			/* Load command entry data segments. */
+			for (cnt = 0; cnt < 2 && seg_cnt; cnt++, seg_cnt--) {
+				dma_handle = sg_dma_address(sg);
+#if defined(CONFIG_IA64_GENERIC) || defined(CONFIG_IA64_SGI_SN2)
+				if (ha->flags.use_pci_vchannel)
+					sn_pci_set_vchan(ha->pdev,
+							(unsigned long *)&dma_handle,
+							 SCSI_BUS_32(cmd));
+#endif
+				*dword_ptr++ =
+					cpu_to_le32(pci_dma_lo32(dma_handle));
+				*dword_ptr++ =
+					cpu_to_le32(pci_dma_hi32(dma_handle));
+				*dword_ptr++ = cpu_to_le32(sg_dma_len(sg));
+				sg++;
+				dprintk(3, "S/G Segment phys_addr=%x %x, len=0x%x\n",
+					cpu_to_le32(pci_dma_hi32(dma_handle)),
+					cpu_to_le32(pci_dma_lo32(dma_handle)),
+					cpu_to_le32(sg_dma_len(sg)));
+			}
+			dprintk(5, "qla1280_64bit_start_scsi: Scatter/gather "
+				"command packet data - b %i, t %i, l %i \n",
+				SCSI_BUS_32(cmd), SCSI_TCN_32(cmd),
+				SCSI_LUN_32(cmd));
+			qla1280_dump_buffer(5, (char *)pkt,
+					    REQUEST_ENTRY_SIZE);
+
+			/*
+			 * Build continuation packets.
+			 */
+			dprintk(3, "S/G Building Continuation...seg_cnt=0x%x "
+				"remains\n", seg_cnt);
+
+			while (seg_cnt > 0) {
+				/* Adjust ring index. */
+				ha->req_ring_index++;
+				if (ha->req_ring_index == REQUEST_ENTRY_CNT) {
+					ha->req_ring_index = 0;
+					ha->request_ring_ptr =
+						ha->request_ring;
+				} else
+						ha->request_ring_ptr++;
+
+				pkt = (cmd_a64_entry_t *)ha->request_ring_ptr;
+
+				/* Zero out packet. */
+				memset(pkt, 0, REQUEST_ENTRY_SIZE);
+
+				/* Load packet defaults. */
+				((struct cont_a64_entry *) pkt)->entry_type =
+					CONTINUE_A64_TYPE;
+				((struct cont_a64_entry *) pkt)->entry_count = 1;
+				((struct cont_a64_entry *) pkt)->sys_define =
+					(uint8_t)ha->req_ring_index;
+				/* Setup packet address segment pointer. */
+				dword_ptr =
+					(u32 *)&((struct cont_a64_entry *) pkt)->dseg_0_address;
+
+				/* Load continuation entry data segments. */
+				for (cnt = 0; cnt < 5 && seg_cnt;
+				     cnt++, seg_cnt--) {
+					dma_handle = sg_dma_address(sg);
+#if defined(CONFIG_IA64_GENERIC) || defined(CONFIG_IA64_SGI_SN2)
+				if (ha->flags.use_pci_vchannel)
+					sn_pci_set_vchan(ha->pdev, 
+							(unsigned long *)&dma_handle,
+							 SCSI_BUS_32(cmd));
+#endif
+					*dword_ptr++ =
+						cpu_to_le32(pci_dma_lo32(dma_handle));
+					*dword_ptr++ =
+						cpu_to_le32(pci_dma_hi32(dma_handle));
+					*dword_ptr++ =
+						cpu_to_le32(sg_dma_len(sg));
+					dprintk(3, "S/G Segment Cont. phys_addr=%x %x, len=0x%x\n",
+						cpu_to_le32(pci_dma_hi32(dma_handle)),
+						cpu_to_le32(pci_dma_lo32(dma_handle)),
+						cpu_to_le32(sg_dma_len(sg)));
+					sg++;
+				}
+				dprintk(5, "qla1280_64bit_start_scsi: "
+					"continuation packet data - b %i, t "
+					"%i, l %i \n", SCSI_BUS_32(cmd),
+					SCSI_TCN_32(cmd), SCSI_LUN_32(cmd));
+				qla1280_dump_buffer(5, (char *)pkt,
+						    REQUEST_ENTRY_SIZE);
+			}
+		} else {	/* No scatter gather data transfer */
+			dma_handle = pci_map_single(ha->pdev,
+					cmd->request_buffer,
+					cmd->request_bufflen,
+					cmd->sc_data_direction);
+
+			sp->saved_dma_handle = dma_handle;
+#if defined(CONFIG_IA64_GENERIC) || defined(CONFIG_IA64_SGI_SN2)
+			if (ha->flags.use_pci_vchannel)
+				sn_pci_set_vchan(ha->pdev, 
+						(unsigned long *)&dma_handle,
+						 SCSI_BUS_32(cmd));
+#endif
+			*dword_ptr++ = cpu_to_le32(pci_dma_lo32(dma_handle));
+			*dword_ptr++ = cpu_to_le32(pci_dma_hi32(dma_handle));
+			*dword_ptr = cpu_to_le32(cmd->request_bufflen);
+
+			dprintk(5, "qla1280_64bit_start_scsi: No scatter/"
+				"gather command packet data - b %i, t %i, "
+				"l %i \n", SCSI_BUS_32(cmd), SCSI_TCN_32(cmd),
+				SCSI_LUN_32(cmd));
+			qla1280_dump_buffer(5, (char *)pkt,
+					    REQUEST_ENTRY_SIZE);
+		}
+	} else {	/* No data transfer */
+		dprintk(5, "qla1280_64bit_start_scsi: No data, command "
+			"packet data - b %i, t %i, l %i \n",
+			SCSI_BUS_32(cmd), SCSI_TCN_32(cmd), SCSI_LUN_32(cmd));
+		qla1280_dump_buffer(5, (char *)pkt, REQUEST_ENTRY_SIZE);
+	}
+	/* Adjust ring index. */
+	ha->req_ring_index++;
+	if (ha->req_ring_index == REQUEST_ENTRY_CNT) {
+		ha->req_ring_index = 0;
+		ha->request_ring_ptr = ha->request_ring;
+	} else
+		ha->request_ring_ptr++;
+
+	/* Set chip new ring index. */
+	dprintk(2,
+		"qla1280_64bit_start_scsi: Wakeup RISC for pending command\n");
+	sp->flags |= SRB_SENT;
+	ha->actthreads++;
+	WRT_REG_WORD(&reg->mailbox4, ha->req_ring_index);
+	/* Enforce mmio write ordering; see comment in qla1280_isp_cmd(). */
+	mmiowb();
+
+ out:
+	if (status)
+		dprintk(2, "qla1280_64bit_start_scsi: **** FAILED ****\n");
+	else
+		dprintk(3, "qla1280_64bit_start_scsi: exiting normally\n");
+
+	return status;
+}
+#else /* !QLA_64BIT_PTR */
+
+/*
+ * qla1280_32bit_start_scsi
+ *      The start SCSI is responsible for building request packets on
+ *      request ring and modifying ISP input pointer.
+ *
+ *      The Qlogic firmware interface allows every queue slot to have a SCSI
+ *      command and up to 4 scatter/gather (SG) entries.  If we need more
+ *      than 4 SG entries, then continuation entries are used that can
+ *      hold another 7 entries each.  The start routine determines if there
+ *      is eought empty slots then build the combination of requests to
+ *      fulfill the OS request.
+ *
+ * Input:
+ *      ha = adapter block pointer.
+ *      sp = SCSI Request Block structure pointer.
+ *
+ * Returns:
+ *      0 = success, was able to issue command.
+ */
+static int
+qla1280_32bit_start_scsi(struct scsi_qla_host *ha, struct srb * sp)
+{
+	struct device_reg __iomem *reg = ha->iobase;
+	struct scsi_cmnd *cmd = sp->cmd;
+	struct cmd_entry *pkt;
+	struct scatterlist *sg = NULL;
+	uint32_t *dword_ptr;
+	int status = 0;
+	int cnt;
+	int req_cnt;
+	uint16_t seg_cnt;
+	dma_addr_t dma_handle;
+	u8 dir;
+
+	ENTER("qla1280_32bit_start_scsi");
+
+	dprintk(1, "32bit_start: cmd=%p sp=%p CDB=%x\n", cmd, sp,
+		cmd->cmnd[0]);
+
+	/* Calculate number of entries and segments required. */
+	req_cnt = 1;
+	if (cmd->use_sg) {
+		/*
+		 * We must build an SG list in adapter format, as the kernel's
+		 * SG list cannot be used directly because of data field size
+		 * (__alpha__) differences and the kernel SG list uses virtual
+		 * addresses where we need physical addresses.
+		 */
+		sg = (struct scatterlist *) cmd->request_buffer;
+		seg_cnt = pci_map_sg(ha->pdev, sg, cmd->use_sg,
+				     cmd->sc_data_direction);
+
+		/*
+		 * if greater than four sg entries then we need to allocate
+		 * continuation entries
+		 */
+		if (seg_cnt > 4) {
+			req_cnt += (seg_cnt - 4) / 7;
+			if ((seg_cnt - 4) % 7)
+				req_cnt++;
+		}
+		dprintk(3, "S/G Transfer cmd=%p seg_cnt=0x%x, req_cnt=%x\n",
+			cmd, seg_cnt, req_cnt);
+	} else if (cmd->request_bufflen) {	/* If data transfer. */
+		dprintk(3, "No S/G transfer t=%x cmd=%p len=%x CDB=%x\n",
+			SCSI_TCN_32(cmd), cmd, cmd->request_bufflen,
+			cmd->cmnd[0]);
+		seg_cnt = 1;
+	} else {
+		/* dprintk(1, "No data transfer \n"); */
+		seg_cnt = 0;
+	}
+
+	if ((req_cnt + 2) >= ha->req_q_cnt) {
+		/* Calculate number of free request entries. */
+		cnt = RD_REG_WORD(&reg->mailbox4);
+		if (ha->req_ring_index < cnt)
+			ha->req_q_cnt = cnt - ha->req_ring_index;
+		else
+			ha->req_q_cnt =
+				REQUEST_ENTRY_CNT - (ha->req_ring_index - cnt);
+	}
+
+	dprintk(3, "Number of free entries=(%d) seg_cnt=0x%x\n",
+		ha->req_q_cnt, seg_cnt);
+	/* If room for request in request ring. */
+	if ((req_cnt + 2) >= ha->req_q_cnt) {
+		status = 1;
+		dprintk(2, "qla1280_32bit_start_scsi: in-ptr=0x%x, "
+			"req_q_cnt=0x%x, req_cnt=0x%x", ha->req_ring_index,
+			ha->req_q_cnt, req_cnt);
+		goto out;
+	}
+
+	/* Check for empty slot in outstanding command list. */
+	for (cnt = 0; cnt < MAX_OUTSTANDING_COMMANDS &&
+		     (ha->outstanding_cmds[cnt] != 0); cnt++) ;
+
+	if (cnt >= MAX_OUTSTANDING_COMMANDS) {
+		status = 1;
+		dprintk(2, "qla1280_32bit_start_scsi: NO ROOM IN OUTSTANDING "
+			"ARRAY, req_q_cnt=0x%x\n", ha->req_q_cnt);
+		goto out;
+	}
+
+	CMD_HANDLE(sp->cmd) = (unsigned char *) (unsigned long)(cnt + 1);
+	ha->outstanding_cmds[cnt] = sp;
+	ha->req_q_cnt -= req_cnt;
+
+	/*
+	 * Build command packet.
+	 */
+	pkt = (struct cmd_entry *) ha->request_ring_ptr;
+
+	pkt->entry_type = COMMAND_TYPE;
+	pkt->entry_count = (uint8_t) req_cnt;
+	pkt->sys_define = (uint8_t) ha->req_ring_index;
+	pkt->entry_status = 0;
+	pkt->handle = cpu_to_le32(cnt);
+
+	/* Zero out remaining portion of packet. */
+	memset(((char *)pkt + 8), 0, (REQUEST_ENTRY_SIZE - 8));
+
+	/* Set ISP command timeout. */
+	pkt->timeout = cpu_to_le16(30);
+
+	/* Set device target ID and LUN */
+	pkt->lun = SCSI_LUN_32(cmd);
+	pkt->target = SCSI_BUS_32(cmd) ?
+		(SCSI_TCN_32(cmd) | BIT_7) : SCSI_TCN_32(cmd);
+
+	/* Enable simple tag queuing if device supports it. */
+	if (DEV_SIMPLE_TAGS(cmd->device))
+		pkt->control_flags |= cpu_to_le16(BIT_3);
+
+	/* Load SCSI command packet. */
+	pkt->cdb_len = cpu_to_le16(CMD_CDBLEN(cmd));
+	memcpy(pkt->scsi_cdb, &(CMD_CDBP(cmd)), CMD_CDBLEN(cmd));
+
+	/*dprintk(1, "Build packet for command[0]=0x%x\n",pkt->scsi_cdb[0]); */
+	/* Set transfer direction. */
+	dir = qla1280_data_direction(cmd);
+	pkt->control_flags |= cpu_to_le16(dir);
+
+	/* Set total data segment count. */
+	pkt->dseg_count = cpu_to_le16(seg_cnt);
+
+	/*
+	 * Load data segments.
+	 */
+	if (seg_cnt) {
+		/* Setup packet address segment pointer. */
+		dword_ptr = &pkt->dseg_0_address;
+
+		if (cmd->use_sg) {	/* If scatter gather */
+			dprintk(3, "Building S/G data segments..\n");
+			qla1280_dump_buffer(1, (char *)sg, 4 * 16);
+
+			/* Load command entry data segments. */
+			for (cnt = 0; cnt < 4 && seg_cnt; cnt++, seg_cnt--) {
+				*dword_ptr++ =
+					cpu_to_le32(pci_dma_lo32(sg_dma_address(sg)));
+				*dword_ptr++ =
+					cpu_to_le32(sg_dma_len(sg));
+				dprintk(3, "S/G Segment phys_addr=0x%lx, len=0x%x\n",
+					(pci_dma_lo32(sg_dma_address(sg))),
+					(sg_dma_len(sg)));
+				sg++;
+			}
+			/*
+			 * Build continuation packets.
+			 */
+			dprintk(3, "S/G Building Continuation"
+				"...seg_cnt=0x%x remains\n", seg_cnt);
+			while (seg_cnt > 0) {
+				/* Adjust ring index. */
+				ha->req_ring_index++;
+				if (ha->req_ring_index == REQUEST_ENTRY_CNT) {
+					ha->req_ring_index = 0;
+					ha->request_ring_ptr =
+						ha->request_ring;
+				} else
+					ha->request_ring_ptr++;
+
+				pkt = (struct cmd_entry *)ha->request_ring_ptr;
+
+				/* Zero out packet. */
+				memset(pkt, 0, REQUEST_ENTRY_SIZE);
+
+				/* Load packet defaults. */
+				((struct cont_entry *) pkt)->
+					entry_type = CONTINUE_TYPE;
+				((struct cont_entry *) pkt)->entry_count = 1;
+
+				((struct cont_entry *) pkt)->sys_define =
+					(uint8_t) ha->req_ring_index;
+
+				/* Setup packet address segment pointer. */
+				dword_ptr =
+					&((struct cont_entry *) pkt)->dseg_0_address;
+
+				/* Load continuation entry data segments. */
+				for (cnt = 0; cnt < 7 && seg_cnt;
+				     cnt++, seg_cnt--) {
+					*dword_ptr++ =
+						cpu_to_le32(pci_dma_lo32(sg_dma_address(sg)));
+					*dword_ptr++ =
+						cpu_to_le32(sg_dma_len(sg));
+					dprintk(1,
+						"S/G Segment Cont. phys_addr=0x%x, "
+						"len=0x%x\n",
+						cpu_to_le32(pci_dma_lo32(sg_dma_address(sg))),
+						cpu_to_le32(sg_dma_len(sg)));
+					sg++;
+				}
+				dprintk(5, "qla1280_32bit_start_scsi: "
+					"continuation packet data - "
+					"scsi(%i:%i:%i)\n", SCSI_BUS_32(cmd),
+					SCSI_TCN_32(cmd), SCSI_LUN_32(cmd));
+				qla1280_dump_buffer(5, (char *)pkt,
+						    REQUEST_ENTRY_SIZE);
+			}
+		} else {	/* No S/G data transfer */
+			dma_handle = pci_map_single(ha->pdev,
+					cmd->request_buffer,
+					cmd->request_bufflen,
+					cmd->sc_data_direction);
+			sp->saved_dma_handle = dma_handle;
+
+			*dword_ptr++ = cpu_to_le32(pci_dma_lo32(dma_handle));
+			*dword_ptr = cpu_to_le32(cmd->request_bufflen);
+		}
+	} else {	/* No data transfer at all */
+		dprintk(5, "qla1280_32bit_start_scsi: No data, command "
+			"packet data - \n");
+		qla1280_dump_buffer(5, (char *)pkt, REQUEST_ENTRY_SIZE);
+	}
+	dprintk(5, "qla1280_32bit_start_scsi: First IOCB block:\n");
+	qla1280_dump_buffer(5, (char *)ha->request_ring_ptr,
+			    REQUEST_ENTRY_SIZE);
+
+	/* Adjust ring index. */
+	ha->req_ring_index++;
+	if (ha->req_ring_index == REQUEST_ENTRY_CNT) {
+		ha->req_ring_index = 0;
+		ha->request_ring_ptr = ha->request_ring;
+	} else
+		ha->request_ring_ptr++;
+
+	/* Set chip new ring index. */
+	dprintk(2, "qla1280_32bit_start_scsi: Wakeup RISC "
+		"for pending command\n");
+	sp->flags |= SRB_SENT;
+	ha->actthreads++;
+	WRT_REG_WORD(&reg->mailbox4, ha->req_ring_index);
+	/* Enforce mmio write ordering; see comment in qla1280_isp_cmd(). */
+	mmiowb();
+
+out:
+	if (status)
+		dprintk(2, "qla1280_32bit_start_scsi: **** FAILED ****\n");
+
+	LEAVE("qla1280_32bit_start_scsi");
+
+	return status;
+}
+#endif
+
+/*
+ * qla1280_req_pkt
+ *      Function is responsible for locking ring and
+ *      getting a zeroed out request packet.
+ *
+ * Input:
+ *      ha  = adapter block pointer.
+ *
+ * Returns:
+ *      0 = failed to get slot.
+ */
+static request_t *
+qla1280_req_pkt(struct scsi_qla_host *ha)
+{
+	struct device_reg __iomem *reg = ha->iobase;
+	request_t *pkt = NULL;
+	int cnt;
+	uint32_t timer;
+
+	ENTER("qla1280_req_pkt");
+
+	/*
+	 * This can be called from interrupt context, damn it!!!
+	 */
+	/* Wait for 30 seconds for slot. */
+	for (timer = 15000000; timer; timer--) {
+		if (ha->req_q_cnt > 0) {
+			/* Calculate number of free request entries. */
+			cnt = RD_REG_WORD(&reg->mailbox4);
+			if (ha->req_ring_index < cnt)
+				ha->req_q_cnt = cnt - ha->req_ring_index;
+			else
+				ha->req_q_cnt =
+					REQUEST_ENTRY_CNT - (ha->req_ring_index - cnt);
+		}
+
+		/* Found empty request ring slot? */
+		if (ha->req_q_cnt > 0) {
+			ha->req_q_cnt--;
+			pkt = ha->request_ring_ptr;
+
+			/* Zero out packet. */
+			memset(pkt, 0, REQUEST_ENTRY_SIZE);
+
+			/*
+			 * How can this be right when we have a ring
+			 * size of 512???
+			 */
+			/* Set system defined field. */
+			pkt->sys_define = (uint8_t) ha->req_ring_index;
+
+			/* Set entry count. */
+			pkt->entry_count = 1;
+
+			break;
+		}
+
+		udelay(2);	/* 10 */
+
+		/* Check for pending interrupts. */
+		qla1280_poll(ha);
+	}
+
+	if (!pkt)
+		dprintk(2, "qla1280_req_pkt: **** FAILED ****\n");
+	else
+		dprintk(3, "qla1280_req_pkt: exiting normally\n");
+
+	return pkt;
+}
+
+/*
+ * qla1280_isp_cmd
+ *      Function is responsible for modifying ISP input pointer.
+ *      Releases ring lock.
+ *
+ * Input:
+ *      ha  = adapter block pointer.
+ */
+static void
+qla1280_isp_cmd(struct scsi_qla_host *ha)
+{
+	struct device_reg __iomem *reg = ha->iobase;
+
+	ENTER("qla1280_isp_cmd");
+
+	dprintk(5, "qla1280_isp_cmd: IOCB data:\n");
+	qla1280_dump_buffer(5, (char *)ha->request_ring_ptr,
+			    REQUEST_ENTRY_SIZE);
+
+	/* Adjust ring index. */
+	ha->req_ring_index++;
+	if (ha->req_ring_index == REQUEST_ENTRY_CNT) {
+		ha->req_ring_index = 0;
+		ha->request_ring_ptr = ha->request_ring;
+	} else
+		ha->request_ring_ptr++;
+
+	/*
+	 * Update request index to mailbox4 (Request Queue In).
+	 * The mmiowb() ensures that this write is ordered with writes by other
+	 * CPUs.  Without the mmiowb(), it is possible for the following:
+	 *    CPUA posts write of index 5 to mailbox4
+	 *    CPUA releases host lock
+	 *    CPUB acquires host lock
+	 *    CPUB posts write of index 6 to mailbox4
+	 *    On PCI bus, order reverses and write of 6 posts, then index 5,
+	 *       causing chip to issue full queue of stale commands
+	 * The mmiowb() prevents future writes from crossing the barrier.
+	 * See Documentation/DocBook/deviceiobook.tmpl for more information.
+	 */
+	WRT_REG_WORD(&reg->mailbox4, ha->req_ring_index);
+	mmiowb();
+
+	LEAVE("qla1280_isp_cmd");
+}
+
+/****************************************************************************/
+/*                        Interrupt Service Routine.                        */
+/****************************************************************************/
+
+/****************************************************************************
+ *  qla1280_isr
+ *      Calls I/O done on command completion.
+ *
+ * Input:
+ *      ha           = adapter block pointer.
+ *      done_q       = done queue.
+ ****************************************************************************/
+static void
+qla1280_isr(struct scsi_qla_host *ha, struct list_head *done_q)
+{
+	struct device_reg __iomem *reg = ha->iobase;
+	struct response *pkt;
+	struct srb *sp = NULL;
+	uint16_t mailbox[MAILBOX_REGISTER_COUNT];
+	uint16_t *wptr;
+	uint32_t index;
+	u16 istatus;
+
+	ENTER("qla1280_isr");
+
+	istatus = RD_REG_WORD(&reg->istatus);
+	if (!(istatus & (RISC_INT | PCI_INT)))
+		return;
+
+	/* Save mailbox register 5 */
+	mailbox[5] = RD_REG_WORD(&reg->mailbox5);
+
+	/* Check for mailbox interrupt. */
+
+	mailbox[0] = RD_REG_WORD_dmasync(&reg->semaphore);
+
+	if (mailbox[0] & BIT_0) {
+		/* Get mailbox data. */
+		/* dprintk(1, "qla1280_isr: In Get mailbox data \n"); */
+
+		wptr = &mailbox[0];
+		*wptr++ = RD_REG_WORD(&reg->mailbox0);
+		*wptr++ = RD_REG_WORD(&reg->mailbox1);
+		*wptr = RD_REG_WORD(&reg->mailbox2);
+		if (mailbox[0] != MBA_SCSI_COMPLETION) {
+			wptr++;
+			*wptr++ = RD_REG_WORD(&reg->mailbox3);
+			*wptr++ = RD_REG_WORD(&reg->mailbox4);
+			wptr++;
+			*wptr++ = RD_REG_WORD(&reg->mailbox6);
+			*wptr = RD_REG_WORD(&reg->mailbox7);
+		}
+
+		/* Release mailbox registers. */
+
+		WRT_REG_WORD(&reg->semaphore, 0);
+		WRT_REG_WORD(&reg->host_cmd, HC_CLR_RISC_INT);
+
+		dprintk(5, "qla1280_isr: mailbox interrupt mailbox[0] = 0x%x",
+			mailbox[0]);
+
+		/* Handle asynchronous event */
+		switch (mailbox[0]) {
+		case MBA_SCSI_COMPLETION:	/* Response completion */
+			dprintk(5, "qla1280_isr: mailbox SCSI response "
+				"completion\n");
+
+			if (ha->flags.online) {
+				/* Get outstanding command index. */
+				index = mailbox[2] << 16 | mailbox[1];
+
+				/* Validate handle. */
+				if (index < MAX_OUTSTANDING_COMMANDS)
+					sp = ha->outstanding_cmds[index];
+				else
+					sp = NULL;
+
+				if (sp) {
+					/* Free outstanding command slot. */
+					ha->outstanding_cmds[index] = NULL;
+
+					/* Save ISP completion status */
+					CMD_RESULT(sp->cmd) = 0;
+
+					/* Place block on done queue */
+					list_add_tail(&sp->list, done_q);
+				} else {
+					/*
+					 * If we get here we have a real problem!
+					 */
+					printk(KERN_WARNING
+					       "qla1280: ISP invalid handle");
+				}
+			}
+			break;
+
+		case MBA_BUS_RESET:	/* SCSI Bus Reset */
+			ha->flags.reset_marker = 1;
+			index = mailbox[6] & BIT_0;
+			ha->bus_settings[index].reset_marker = 1;
+
+			printk(KERN_DEBUG "qla1280_isr(): index %i "
+			       "asynchronous BUS_RESET\n", index);
+			break;
+
+		case MBA_SYSTEM_ERR:	/* System Error */
+			printk(KERN_WARNING
+			       "qla1280: ISP System Error - mbx1=%xh, mbx2="
+			       "%xh, mbx3=%xh\n", mailbox[1], mailbox[2],
+			       mailbox[3]);
+			break;
+
+		case MBA_REQ_TRANSFER_ERR:	/* Request Transfer Error */
+			printk(KERN_WARNING
+			       "qla1280: ISP Request Transfer Error\n");
+			break;
+
+		case MBA_RSP_TRANSFER_ERR:	/* Response Transfer Error */
+			printk(KERN_WARNING
+			       "qla1280: ISP Response Transfer Error\n");
+			break;
+
+		case MBA_WAKEUP_THRES:	/* Request Queue Wake-up */
+			dprintk(2, "qla1280_isr: asynchronous WAKEUP_THRES\n");
+			break;
+
+		case MBA_TIMEOUT_RESET:	/* Execution Timeout Reset */
+			dprintk(2,
+				"qla1280_isr: asynchronous TIMEOUT_RESET\n");
+			break;
+
+		case MBA_DEVICE_RESET:	/* Bus Device Reset */
+			printk(KERN_INFO "qla1280_isr(): asynchronous "
+			       "BUS_DEVICE_RESET\n");
+
+			ha->flags.reset_marker = 1;
+			index = mailbox[6] & BIT_0;
+			ha->bus_settings[index].reset_marker = 1;
+			break;
+
+		case MBA_BUS_MODE_CHANGE:
+			dprintk(2,
+				"qla1280_isr: asynchronous BUS_MODE_CHANGE\n");
+			break;
+
+		default:
+			/* dprintk(1, "qla1280_isr: default case of switch MB \n"); */
+			if (mailbox[0] < MBA_ASYNC_EVENT) {
+				wptr = &mailbox[0];
+				memcpy((uint16_t *) ha->mailbox_out, wptr,
+				       MAILBOX_REGISTER_COUNT *
+				       sizeof(uint16_t));
+
+				if(ha->mailbox_wait != NULL)
+					complete(ha->mailbox_wait);
+			}
+			break;
+		}
+	} else {
+		WRT_REG_WORD(&reg->host_cmd, HC_CLR_RISC_INT);
+	}
+
+	/*
+	 * We will receive interrupts during mailbox testing prior to
+	 * the card being marked online, hence the double check.
+	 */
+	if (!(ha->flags.online && !ha->mailbox_wait)) {
+		dprintk(2, "qla1280_isr: Response pointer Error\n");
+		goto out;
+	}
+
+	if (mailbox[5] >= RESPONSE_ENTRY_CNT)
+		goto out;
+
+	while (ha->rsp_ring_index != mailbox[5]) {
+		pkt = ha->response_ring_ptr;
+
+		dprintk(5, "qla1280_isr: ha->rsp_ring_index = 0x%x, mailbox[5]"
+			" = 0x%x\n", ha->rsp_ring_index, mailbox[5]);
+		dprintk(5,"qla1280_isr: response packet data\n");
+		qla1280_dump_buffer(5, (char *)pkt, RESPONSE_ENTRY_SIZE);
+
+		if (pkt->entry_type == STATUS_TYPE) {
+			if ((le16_to_cpu(pkt->scsi_status) & 0xff)
+			    || pkt->comp_status || pkt->entry_status) {
+				dprintk(2, "qla1280_isr: ha->rsp_ring_index = "
+					"0x%x mailbox[5] = 0x%x, comp_status "
+					"= 0x%x, scsi_status = 0x%x\n",
+					ha->rsp_ring_index, mailbox[5],
+					le16_to_cpu(pkt->comp_status),
+					le16_to_cpu(pkt->scsi_status));
+			}
+		} else {
+			dprintk(2, "qla1280_isr: ha->rsp_ring_index = "
+				"0x%x, mailbox[5] = 0x%x\n",
+				ha->rsp_ring_index, mailbox[5]);
+			dprintk(2, "qla1280_isr: response packet data\n");
+			qla1280_dump_buffer(2, (char *)pkt,
+					    RESPONSE_ENTRY_SIZE);
+		}
+
+		if (pkt->entry_type == STATUS_TYPE || pkt->entry_status) {
+			dprintk(2, "status: Cmd %p, handle %i\n",
+				ha->outstanding_cmds[pkt->handle]->cmd,
+				pkt->handle);
+			if (pkt->entry_type == STATUS_TYPE)
+				qla1280_status_entry(ha, pkt, done_q);
+			else
+				qla1280_error_entry(ha, pkt, done_q);
+			/* Adjust ring index. */
+			ha->rsp_ring_index++;
+			if (ha->rsp_ring_index == RESPONSE_ENTRY_CNT) {
+				ha->rsp_ring_index = 0;
+				ha->response_ring_ptr =	ha->response_ring;
+			} else
+				ha->response_ring_ptr++;
+			WRT_REG_WORD(&reg->mailbox5, ha->rsp_ring_index);
+		}
+	}
+	
+ out:
+	LEAVE("qla1280_isr");
+}
+
+/*
+ *  qla1280_rst_aen
+ *      Processes asynchronous reset.
+ *
+ * Input:
+ *      ha  = adapter block pointer.
+ */
+static void
+qla1280_rst_aen(struct scsi_qla_host *ha)
+{
+	uint8_t bus;
+
+	ENTER("qla1280_rst_aen");
+
+	if (ha->flags.online && !ha->flags.reset_active &&
+	    !ha->flags.abort_isp_active) {
+		ha->flags.reset_active = 1;
+		while (ha->flags.reset_marker) {
+			/* Issue marker command. */
+			ha->flags.reset_marker = 0;
+			for (bus = 0; bus < ha->ports &&
+				     !ha->flags.reset_marker; bus++) {
+				if (ha->bus_settings[bus].reset_marker) {
+					ha->bus_settings[bus].reset_marker = 0;
+					qla1280_marker(ha, bus, 0, 0,
+						       MK_SYNC_ALL);
+				}
+			}
+		}
+	}
+
+	LEAVE("qla1280_rst_aen");
+}
+
+
+#if LINUX_VERSION_CODE < 0x020500
+/*
+ *
+ */
+static void
+qla1280_get_target_options(struct scsi_cmnd *cmd, struct scsi_qla_host *ha)
+{
+	unsigned char *result;
+	struct nvram *n;
+	int bus, target, lun;
+
+	bus = SCSI_BUS_32(cmd);
+	target = SCSI_TCN_32(cmd);
+	lun = SCSI_LUN_32(cmd);
+
+	/*
+	 * Make sure to not touch anything if someone is using the
+	 * sg interface.
+	 */
+	if (cmd->use_sg || (CMD_RESULT(cmd) >> 16) != DID_OK || lun)
+		return;
+
+	result = cmd->request_buffer;
+	n = &ha->nvram;
+
+	n->bus[bus].target[target].parameter.f.enable_wide = 0;
+	n->bus[bus].target[target].parameter.f.enable_sync = 0;
+	n->bus[bus].target[target].ppr_1x160.flags.enable_ppr = 0;
+
+        if (result[7] & 0x60)
+		n->bus[bus].target[target].parameter.f.enable_wide = 1;
+        if (result[7] & 0x10)
+		n->bus[bus].target[target].parameter.f.enable_sync = 1;
+	if ((result[2] >= 3) && (result[4] + 5 > 56) &&
+	    (result[56] & 0x4))
+		n->bus[bus].target[target].ppr_1x160.flags.enable_ppr = 1;
+
+	dprintk(2, "get_target_options(): wide %i, sync %i, ppr %i\n",
+		n->bus[bus].target[target].parameter.f.enable_wide,
+		n->bus[bus].target[target].parameter.f.enable_sync,
+		n->bus[bus].target[target].ppr_1x160.flags.enable_ppr);
+}
+#endif
+
+/*
+ *  qla1280_status_entry
+ *      Processes received ISP status entry.
+ *
+ * Input:
+ *      ha           = adapter block pointer.
+ *      pkt          = entry pointer.
+ *      done_q       = done queue.
+ */
+static void
+qla1280_status_entry(struct scsi_qla_host *ha, struct response *pkt,
+		     struct list_head *done_q)
+{
+	unsigned int bus, target, lun;
+	int sense_sz;
+	struct srb *sp;
+	struct scsi_cmnd *cmd;
+	uint32_t handle = le32_to_cpu(pkt->handle);
+	uint16_t scsi_status = le16_to_cpu(pkt->scsi_status);
+	uint16_t comp_status = le16_to_cpu(pkt->comp_status);
+
+	ENTER("qla1280_status_entry");
+
+	/* Validate handle. */
+	if (handle < MAX_OUTSTANDING_COMMANDS)
+		sp = ha->outstanding_cmds[handle];
+	else
+		sp = NULL;
+
+	if (!sp) {
+		printk(KERN_WARNING "qla1280: Status Entry invalid handle\n");
+		goto out;
+	}
+
+	/* Free outstanding command slot. */
+	ha->outstanding_cmds[handle] = NULL;
+
+	cmd = sp->cmd;
+
+	/* Generate LU queue on cntrl, target, LUN */
+	bus = SCSI_BUS_32(cmd);
+	target = SCSI_TCN_32(cmd);
+	lun = SCSI_LUN_32(cmd);
+
+	if (comp_status || scsi_status) {
+		dprintk(3, "scsi: comp_status = 0x%x, scsi_status = "
+			"0x%x, handle = 0x%x\n", comp_status,
+			scsi_status, handle);
+	}
+
+	/* Target busy */
+	if (scsi_status & SS_BUSY_CONDITION &&
+	    scsi_status != SS_RESERVE_CONFLICT) {
+		CMD_RESULT(cmd) =
+			DID_BUS_BUSY << 16 | (scsi_status & 0xff);
+	} else {
+
+		/* Save ISP completion status */
+		CMD_RESULT(cmd) = qla1280_return_status(pkt, cmd);
+
+		if (scsi_status & SS_CHECK_CONDITION) {
+			if (comp_status != CS_ARS_FAILED) {
+				uint16_t req_sense_length =
+					le16_to_cpu(pkt->req_sense_length);
+				if (req_sense_length < CMD_SNSLEN(cmd))
+					sense_sz = req_sense_length;
+				else
+					/*
+					 * scsi_cmnd->sense_buffer is
+					 * 64 bytes, why only copy 63?
+					 * This looks wrong! /Jes
+					 */
+					sense_sz = CMD_SNSLEN(cmd) - 1;
+
+				memcpy(cmd->sense_buffer,
+				       &pkt->req_sense_data, sense_sz);
+			} else
+				sense_sz = 0;
+			memset(cmd->sense_buffer + sense_sz, 0,
+			       sizeof(cmd->sense_buffer) - sense_sz);
+
+			dprintk(2, "qla1280_status_entry: Check "
+				"condition Sense data, b %i, t %i, "
+				"l %i\n", bus, target, lun);
+			if (sense_sz)
+				qla1280_dump_buffer(2,
+						    (char *)cmd->sense_buffer,
+						    sense_sz);
+		}
+	}
+
+	/* Place command on done queue. */
+	list_add_tail(&sp->list, done_q);
+ out:
+	LEAVE("qla1280_status_entry");
+}
+
+/*
+ *  qla1280_error_entry
+ *      Processes error entry.
+ *
+ * Input:
+ *      ha           = adapter block pointer.
+ *      pkt          = entry pointer.
+ *      done_q       = done queue.
+ */
+static void
+qla1280_error_entry(struct scsi_qla_host *ha, struct response *pkt,
+		    struct list_head *done_q)
+{
+	struct srb *sp;
+	uint32_t handle = le32_to_cpu(pkt->handle);
+
+	ENTER("qla1280_error_entry");
+
+	if (pkt->entry_status & BIT_3)
+		dprintk(2, "qla1280_error_entry: BAD PAYLOAD flag error\n");
+	else if (pkt->entry_status & BIT_2)
+		dprintk(2, "qla1280_error_entry: BAD HEADER flag error\n");
+	else if (pkt->entry_status & BIT_1)
+		dprintk(2, "qla1280_error_entry: FULL flag error\n");
+	else
+		dprintk(2, "qla1280_error_entry: UNKNOWN flag error\n");
+
+	/* Validate handle. */
+	if (handle < MAX_OUTSTANDING_COMMANDS)
+		sp = ha->outstanding_cmds[handle];
+	else
+		sp = NULL;
+
+	if (sp) {
+		/* Free outstanding command slot. */
+		ha->outstanding_cmds[handle] = NULL;
+
+		/* Bad payload or header */
+		if (pkt->entry_status & (BIT_3 + BIT_2)) {
+			/* Bad payload or header, set error status. */
+			/* CMD_RESULT(sp->cmd) = CS_BAD_PAYLOAD; */
+			CMD_RESULT(sp->cmd) = DID_ERROR << 16;
+		} else if (pkt->entry_status & BIT_1) {	/* FULL flag */
+			CMD_RESULT(sp->cmd) = DID_BUS_BUSY << 16;
+		} else {
+			/* Set error status. */
+			CMD_RESULT(sp->cmd) = DID_ERROR << 16;
+		}
+
+		/* Place command on done queue. */
+		list_add_tail(&sp->list, done_q);
+	}
+#ifdef QLA_64BIT_PTR
+	else if (pkt->entry_type == COMMAND_A64_TYPE) {
+		printk(KERN_WARNING "!qla1280: Error Entry invalid handle");
+	}
+#endif
+
+	LEAVE("qla1280_error_entry");
+}
+
+/*
+ *  qla1280_abort_isp
+ *      Resets ISP and aborts all outstanding commands.
+ *
+ * Input:
+ *      ha           = adapter block pointer.
+ *
+ * Returns:
+ *      0 = success
+ */
+static int
+qla1280_abort_isp(struct scsi_qla_host *ha)
+{
+	struct device_reg __iomem *reg = ha->iobase;
+	struct srb *sp;
+	int status = 0;
+	int cnt;
+	int bus;
+
+	ENTER("qla1280_abort_isp");
+
+	if (ha->flags.abort_isp_active || !ha->flags.online)
+		goto out;
+	
+	ha->flags.abort_isp_active = 1;
+
+	/* Disable ISP interrupts. */
+	qla1280_disable_intrs(ha);
+	WRT_REG_WORD(&reg->host_cmd, HC_PAUSE_RISC);
+	RD_REG_WORD(&reg->id_l);
+
+	printk(KERN_INFO "scsi(%li): dequeuing outstanding commands\n",
+	       ha->host_no);
+	/* Dequeue all commands in outstanding command list. */
+	for (cnt = 0; cnt < MAX_OUTSTANDING_COMMANDS; cnt++) {
+		struct scsi_cmnd *cmd;
+		sp = ha->outstanding_cmds[cnt];
+		if (sp) {
+
+			cmd = sp->cmd;
+			CMD_RESULT(cmd) = DID_RESET << 16;
+
+			sp->cmd = NULL;
+			ha->outstanding_cmds[cnt] = NULL;
+
+			(*cmd->scsi_done)(cmd);
+
+			sp->flags = 0;
+		}
+	}
+
+	status = qla1280_load_firmware(ha);
+	if (status)
+		goto out;
+
+	/* Setup adapter based on NVRAM parameters. */
+	qla1280_nvram_config (ha);
+
+	status = qla1280_init_rings(ha);
+	if (status)
+		goto out;
+		
+	/* Issue SCSI reset. */
+	for (bus = 0; bus < ha->ports; bus++)
+		qla1280_bus_reset(ha, bus);
+		
+	ha->flags.abort_isp_active = 0;
+ out:
+	if (status) {
+		printk(KERN_WARNING
+		       "qla1280: ISP error recovery failed, board disabled");
+		qla1280_reset_adapter(ha);
+		dprintk(2, "qla1280_abort_isp: **** FAILED ****\n");
+	}
+
+	LEAVE("qla1280_abort_isp");
+	return status;
+}
+
+
+/*
+ * qla1280_debounce_register
+ *      Debounce register.
+ *
+ * Input:
+ *      port = register address.
+ *
+ * Returns:
+ *      register value.
+ */
+static u16
+qla1280_debounce_register(volatile u16 __iomem * addr)
+{
+	volatile u16 ret;
+	volatile u16 ret2;
+
+	ret = RD_REG_WORD(addr);
+	ret2 = RD_REG_WORD(addr);
+
+	if (ret == ret2)
+		return ret;
+
+	do {
+		cpu_relax();
+		ret = RD_REG_WORD(addr);
+		ret2 = RD_REG_WORD(addr);
+	} while (ret != ret2);
+
+	return ret;
+}
+
+
+/************************************************************************
+ * qla1280_check_for_dead_scsi_bus                                      *
+ *                                                                      *
+ *    This routine checks for a dead SCSI bus                           *
+ ************************************************************************/
+#define SET_SXP_BANK            0x0100
+#define SCSI_PHASE_INVALID      0x87FF
+static int
+qla1280_check_for_dead_scsi_bus(struct scsi_qla_host *ha, unsigned int bus)
+{
+	uint16_t config_reg, scsi_control;
+	struct device_reg __iomem *reg = ha->iobase;
+
+	if (ha->bus_settings[bus].scsi_bus_dead) {
+		WRT_REG_WORD(&reg->host_cmd, HC_PAUSE_RISC);
+		config_reg = RD_REG_WORD(&reg->cfg_1);
+		WRT_REG_WORD(&reg->cfg_1, SET_SXP_BANK);
+		scsi_control = RD_REG_WORD(&reg->scsiControlPins);
+		WRT_REG_WORD(&reg->cfg_1, config_reg);
+		WRT_REG_WORD(&reg->host_cmd, HC_RELEASE_RISC);
+
+		if (scsi_control == SCSI_PHASE_INVALID) {
+			ha->bus_settings[bus].scsi_bus_dead = 1;
+#if 0
+			CMD_RESULT(cp) = DID_NO_CONNECT << 16;
+			CMD_HANDLE(cp) = INVALID_HANDLE;
+			/* ha->actthreads--; */
+
+			(*(cp)->scsi_done)(cp);
+#endif
+			return 1;	/* bus is dead */
+		} else {
+			ha->bus_settings[bus].scsi_bus_dead = 0;
+			ha->bus_settings[bus].failed_reset_count = 0;
+		}
+	}
+	return 0;		/* bus is not dead */
+}
+
+static void
+qla1280_get_target_parameters(struct scsi_qla_host *ha,
+			      struct scsi_device *device)
+{
+	uint16_t mb[MAILBOX_REGISTER_COUNT];
+	int bus, target, lun;
+
+	bus = device->channel;
+	target = device->id;
+	lun = device->lun;
+
+
+	mb[0] = MBC_GET_TARGET_PARAMETERS;
+	mb[1] = (uint16_t) (bus ? target | BIT_7 : target);
+	mb[1] <<= 8;
+	qla1280_mailbox_command(ha, BIT_6 | BIT_3 | BIT_2 | BIT_1 | BIT_0,
+				&mb[0]);
+
+	printk(KERN_INFO "scsi(%li:%d:%d:%d):", ha->host_no, bus, target, lun);
+
+	if (mb[3] != 0) {
+		printk(" Sync: period %d, offset %d",
+		       (mb[3] & 0xff), (mb[3] >> 8));
+		if (mb[2] & BIT_13)
+			printk(", Wide");
+		if ((mb[2] & BIT_5) && ((mb[6] >> 8) & 0xff) >= 2)
+			printk(", DT");
+	} else
+		printk(" Async");
+
+	if (DEV_SIMPLE_TAGS(device))
+		printk(", Tagged queuing: depth %d", device->queue_depth);
+	printk("\n");
+}
+
+
+#if DEBUG_QLA1280
+static void
+__qla1280_dump_buffer(char *b, int size)
+{
+	int cnt;
+	u8 c;
+
+	printk(KERN_DEBUG " 0   1   2   3   4   5   6   7   8   9   Ah  "
+	       "Bh  Ch  Dh  Eh  Fh\n");
+	printk(KERN_DEBUG "---------------------------------------------"
+	       "------------------\n");
+
+	for (cnt = 0; cnt < size;) {
+		c = *b++;
+
+		printk("0x%02x", c);
+		cnt++;
+		if (!(cnt % 16))
+			printk("\n");
+		else
+			printk(" ");
+	}
+	if (cnt % 16)
+		printk("\n");
+}
+
+/**************************************************************************
+ *   ql1280_print_scsi_cmd
+ *
+ **************************************************************************/
+static void
+__qla1280_print_scsi_cmd(struct scsi_cmnd *cmd)
+{
+	struct scsi_qla_host *ha;
+	struct Scsi_Host *host = CMD_HOST(cmd);
+	struct srb *sp;
+	/* struct scatterlist *sg; */
+
+	int i;
+	ha = (struct scsi_qla_host *)host->hostdata;
+
+	sp = (struct srb *)CMD_SP(cmd);
+	printk("SCSI Command @= 0x%p, Handle=0x%p\n", cmd, CMD_HANDLE(cmd));
+	printk("  chan=%d, target = 0x%02x, lun = 0x%02x, cmd_len = 0x%02x\n",
+	       SCSI_BUS_32(cmd), SCSI_TCN_32(cmd), SCSI_LUN_32(cmd),
+	       CMD_CDBLEN(cmd));
+	printk(" CDB = ");
+	for (i = 0; i < cmd->cmd_len; i++) {
+		printk("0x%02x ", cmd->cmnd[i]);
+	}
+	printk("  seg_cnt =%d\n", cmd->use_sg);
+	printk("  request buffer=0x%p, request buffer len=0x%x\n",
+	       cmd->request_buffer, cmd->request_bufflen);
+	/* if (cmd->use_sg)
+	   {
+	   sg = (struct scatterlist *) cmd->request_buffer;
+	   printk("  SG buffer: \n");
+	   qla1280_dump_buffer(1, (char *)sg, (cmd->use_sg*sizeof(struct scatterlist)));
+	   } */
+	printk("  tag=%d, transfersize=0x%x \n",
+	       cmd->tag, cmd->transfersize);
+	printk("  Pid=%li, SP=0x%p\n", cmd->pid, CMD_SP(cmd));
+	printk(" underflow size = 0x%x, direction=0x%x\n",
+	       cmd->underflow, cmd->sc_data_direction);
+}
+
+/**************************************************************************
+ *   ql1280_dump_device
+ *
+ **************************************************************************/
+static void
+ql1280_dump_device(struct scsi_qla_host *ha)
+{
+
+	struct scsi_cmnd *cp;
+	struct srb *sp;
+	int i;
+
+	printk(KERN_DEBUG "Outstanding Commands on controller:\n");
+
+	for (i = 0; i < MAX_OUTSTANDING_COMMANDS; i++) {
+		if ((sp = ha->outstanding_cmds[i]) == NULL)
+			continue;
+		if ((cp = sp->cmd) == NULL)
+			continue;
+		qla1280_print_scsi_cmd(1, cp);
+	}
+}
+#endif
+
+
+enum tokens {
+	TOKEN_NVRAM,
+	TOKEN_SYNC,
+	TOKEN_WIDE,
+	TOKEN_PPR,
+	TOKEN_VERBOSE,
+	TOKEN_DEBUG,
+};
+
+struct setup_tokens {
+	char *token;
+	int val;
+};
+
+static struct setup_tokens setup_token[] __initdata = 
+{
+	{ "nvram", TOKEN_NVRAM },
+	{ "sync", TOKEN_SYNC },
+	{ "wide", TOKEN_WIDE },
+	{ "ppr", TOKEN_PPR },
+	{ "verbose", TOKEN_VERBOSE },
+	{ "debug", TOKEN_DEBUG },
+};
+
+
+/**************************************************************************
+ *   qla1280_setup
+ *
+ *   Handle boot parameters. This really needs to be changed so one
+ *   can specify per adapter parameters.
+ **************************************************************************/
+static int __init
+qla1280_setup(char *s)
+{
+	char *cp, *ptr;
+	unsigned long val;
+	int toke;
+
+	cp = s;
+
+	while (cp && (ptr = strchr(cp, ':'))) {
+		ptr++;
+		if (!strcmp(ptr, "yes")) {
+			val = 0x10000;
+			ptr += 3;
+		} else if (!strcmp(ptr, "no")) {
+ 			val = 0;
+			ptr += 2;
+		} else
+			val = simple_strtoul(ptr, &ptr, 0);
+
+		switch ((toke = qla1280_get_token(cp))) {
+		case TOKEN_NVRAM:
+			if (!val)
+				driver_setup.no_nvram = 1;
+			break;
+		case TOKEN_SYNC:
+			if (!val)
+				driver_setup.no_sync = 1;
+			else if (val != 0x10000)
+				driver_setup.sync_mask = val;
+			break;
+		case TOKEN_WIDE:
+			if (!val)
+				driver_setup.no_wide = 1;
+			else if (val != 0x10000)
+				driver_setup.wide_mask = val;
+			break;
+		case TOKEN_PPR:
+			if (!val)
+				driver_setup.no_ppr = 1;
+			else if (val != 0x10000)
+				driver_setup.ppr_mask = val;
+			break;
+		case TOKEN_VERBOSE:
+			qla1280_verbose = val;
+			break;
+		default:
+			printk(KERN_INFO "qla1280: unknown boot option %s\n",
+			       cp);
+		}
+
+		cp = strchr(ptr, ';');
+		if (cp)
+			cp++;
+		else {
+			break;
+		}
+	}
+	return 1;
+}
+
+
+static int
+qla1280_get_token(char *str)
+{
+	char *sep;
+	long ret = -1;
+	int i, len;
+
+	len = sizeof(setup_token)/sizeof(struct setup_tokens);
+
+	sep = strchr(str, ':');
+
+	if (sep) {
+		for (i = 0; i < len; i++){
+
+			if (!strncmp(setup_token[i].token, str, (sep - str))) {
+				ret =  setup_token[i].val;
+				break;
+			}
+		}
+	}
+
+	return ret;
+}
+
+#if LINUX_VERSION_CODE >= 0x020600
+static struct scsi_host_template qla1280_driver_template = {
+	.module			= THIS_MODULE,
+	.proc_name		= "qla1280",
+	.name			= "Qlogic ISP 1280/12160",
+	.info			= qla1280_info,
+	.slave_configure	= qla1280_slave_configure,
+	.queuecommand		= qla1280_queuecommand,
+	.eh_abort_handler	= qla1280_eh_abort,
+	.eh_device_reset_handler= qla1280_eh_device_reset,
+	.eh_bus_reset_handler	= qla1280_eh_bus_reset,
+	.eh_host_reset_handler	= qla1280_eh_adapter_reset,
+	.bios_param		= qla1280_biosparam,
+	.can_queue		= 0xfffff,
+	.this_id		= -1,
+	.sg_tablesize		= SG_ALL,
+	.cmd_per_lun		= 1,
+	.use_clustering		= ENABLE_CLUSTERING,
+};
+#else
+static Scsi_Host_Template qla1280_driver_template = {
+	.proc_name		= "qla1280",
+	.name			= "Qlogic ISP 1280/12160",
+	.detect			= qla1280_detect,
+	.release		= qla1280_release,
+	.info			= qla1280_info,
+	.queuecommand		= qla1280_queuecommand,
+	.eh_abort_handler	= qla1280_eh_abort,
+	.eh_device_reset_handler= qla1280_eh_device_reset,
+	.eh_bus_reset_handler	= qla1280_eh_bus_reset,
+	.eh_host_reset_handler	= qla1280_eh_adapter_reset,
+	.bios_param		= qla1280_biosparam_old,
+	.can_queue		= 0xfffff,
+	.this_id		= -1,
+	.sg_tablesize		= SG_ALL,
+	.cmd_per_lun		= 1,
+	.use_clustering		= ENABLE_CLUSTERING,
+	.use_new_eh_code	= 1,
+};
+#endif
+
+static int __devinit
+qla1280_probe_one(struct pci_dev *pdev, const struct pci_device_id *id)
+{
+	int devnum = id->driver_data;
+	struct qla_boards *bdp = &ql1280_board_tbl[devnum];
+	struct Scsi_Host *host;
+	struct scsi_qla_host *ha;
+	int error = -ENODEV;
+
+	/* Bypass all AMI SUBSYS VENDOR IDs */
+	if (pdev->subsystem_vendor == PCI_VENDOR_ID_AMI) {
+		printk(KERN_INFO
+		       "qla1280: Skipping AMI SubSys Vendor ID Chip\n");
+		goto error;
+	}
+
+	printk(KERN_INFO "qla1280: %s found on PCI bus %i, dev %i\n",
+	       bdp->name, pdev->bus->number, PCI_SLOT(pdev->devfn));
+	
+	if (pci_enable_device(pdev)) {
+		printk(KERN_WARNING
+		       "qla1280: Failed to enabled pci device, aborting.\n");
+		goto error;
+	}
+
+	pci_set_master(pdev);
+
+	error = -ENOMEM;
+	host = scsi_host_alloc(&qla1280_driver_template, sizeof(*ha));
+	if (!host) {
+		printk(KERN_WARNING
+		       "qla1280: Failed to register host, aborting.\n");
+		goto error_disable_device;
+	}
+
+	ha = (struct scsi_qla_host *)host->hostdata;
+	memset(ha, 0, sizeof(struct scsi_qla_host));
+
+	ha->pdev = pdev;
+	ha->devnum = devnum;	/* specifies microcode load address */
+
+#ifdef QLA_64BIT_PTR
+	if (pci_set_dma_mask(ha->pdev, (dma_addr_t) ~ 0ULL)) {
+		if (pci_set_dma_mask(ha->pdev, 0xffffffff)) {
+			printk(KERN_WARNING "scsi(%li): Unable to set a "
+			       " suitable DMA mask - aboring\n", ha->host_no);
+			error = -ENODEV;
+			goto error_free_irq;
+		}
+	} else
+		dprintk(2, "scsi(%li): 64 Bit PCI Addressing Enabled\n",
+			ha->host_no);
+#else
+	if (pci_set_dma_mask(ha->pdev, 0xffffffff)) {
+		printk(KERN_WARNING "scsi(%li): Unable to set a "
+		       " suitable DMA mask - aboring\n", ha->host_no);
+		error = -ENODEV;
+		goto error_free_irq;
+	}
+#endif
+
+	ha->request_ring = pci_alloc_consistent(ha->pdev,
+			((REQUEST_ENTRY_CNT + 1) * (sizeof(request_t))),
+			&ha->request_dma);
+	if (!ha->request_ring) {
+		printk(KERN_INFO "qla1280: Failed to get request memory\n");
+		goto error_put_host;
+	}
+
+	ha->response_ring = pci_alloc_consistent(ha->pdev,
+			((RESPONSE_ENTRY_CNT + 1) * (sizeof(struct response))),
+			&ha->response_dma);
+	if (!ha->response_ring) {
+		printk(KERN_INFO "qla1280: Failed to get response memory\n");
+		goto error_free_request_ring;
+	}
+
+	ha->ports = bdp->numPorts;
+
+	ha->host = host;
+	ha->host_no = host->host_no;
+
+	host->irq = pdev->irq;
+	host->max_channel = bdp->numPorts - 1;
+	host->max_lun = MAX_LUNS - 1;
+	host->max_id = MAX_TARGETS;
+	host->max_sectors = 1024;
+	host->unique_id = host->host_no;
+
+#if LINUX_VERSION_CODE < 0x020545
+	host->select_queue_depths = qla1280_select_queue_depth;
+#endif
+
+	error = -ENODEV;
+
+#if MEMORY_MAPPED_IO
+	ha->mmpbase = ioremap(pci_resource_start(ha->pdev, 1),
+			      pci_resource_len(ha->pdev, 1));
+	if (!ha->mmpbase) {
+		printk(KERN_INFO "qla1280: Unable to map I/O memory\n");
+		goto error_free_response_ring;
+	}
+
+	host->base = (unsigned long)ha->mmpbase;
+	ha->iobase = (struct device_reg __iomem *)ha->mmpbase;
+#else
+	host->io_port = pci_resource_start(ha->pdev, 0);
+	if (!request_region(host->io_port, 0xff, "qla1280")) {
+		printk(KERN_INFO "qla1280: Failed to reserve i/o region "
+				 "0x%04lx-0x%04lx - already in use\n",
+		       host->io_port, host->io_port + 0xff);
+		goto error_free_response_ring;
+	}
+
+	ha->iobase = (struct device_reg *)host->io_port;
+#endif
+
+	INIT_LIST_HEAD(&ha->done_q);
+
+	/* Disable ISP interrupts. */
+	qla1280_disable_intrs(ha);
+
+	if (request_irq(pdev->irq, qla1280_intr_handler, SA_SHIRQ,
+				"qla1280", ha)) {
+		printk("qla1280 : Failed to reserve interrupt %d already "
+		       "in use\n", pdev->irq);
+		goto error_release_region;
+	}
+
+	/* load the F/W, read paramaters, and init the H/W */
+	if (qla1280_initialize_adapter(ha)) {
+		printk(KERN_INFO "qla1x160: Failed to initialize adapter\n");
+		goto error_free_irq;
+	}
+
+	/* set our host ID  (need to do something about our two IDs) */
+	host->this_id = ha->bus_settings[0].id;
+
+	pci_set_drvdata(pdev, host);
+
+#if LINUX_VERSION_CODE >= 0x020600
+	error = scsi_add_host(host, &pdev->dev);
+	if (error)
+		goto error_disable_adapter;
+	scsi_scan_host(host);
+#else
+	scsi_set_pci_device(host, pdev);
+#endif
+
+	return 0;
+
+#if LINUX_VERSION_CODE >= 0x020600
+ error_disable_adapter:
+	WRT_REG_WORD(&ha->iobase->ictrl, 0);
+#endif
+ error_free_irq:
+	free_irq(pdev->irq, ha);
+ error_release_region:
+#if MEMORY_MAPPED_IO
+	iounmap(ha->mmpbase);
+#else
+	release_region(host->io_port, 0xff);
+#endif
+ error_free_response_ring:
+	pci_free_consistent(ha->pdev,
+			((RESPONSE_ENTRY_CNT + 1) * (sizeof(struct response))),
+			ha->response_ring, ha->response_dma);
+ error_free_request_ring:
+	pci_free_consistent(ha->pdev,
+			((REQUEST_ENTRY_CNT + 1) * (sizeof(request_t))),
+			ha->request_ring, ha->request_dma);
+ error_put_host:
+	scsi_host_put(host);
+ error_disable_device:
+	pci_disable_device(pdev);
+ error:
+	return error;
+}
+
+
+static void __devexit
+qla1280_remove_one(struct pci_dev *pdev)
+{
+	struct Scsi_Host *host = pci_get_drvdata(pdev);
+	struct scsi_qla_host *ha = (struct scsi_qla_host *)host->hostdata;
+
+#if LINUX_VERSION_CODE >= 0x020600
+	scsi_remove_host(host);
+#endif
+
+	WRT_REG_WORD(&ha->iobase->ictrl, 0);
+
+	free_irq(pdev->irq, ha);
+
+#if MEMORY_MAPPED_IO
+	iounmap(ha->mmpbase);
+#else
+	release_region(host->io_port, 0xff);
+#endif
+
+	pci_free_consistent(ha->pdev,
+			((REQUEST_ENTRY_CNT + 1) * (sizeof(request_t))),
+			ha->request_ring, ha->request_dma);
+	pci_free_consistent(ha->pdev,
+			((RESPONSE_ENTRY_CNT + 1) * (sizeof(struct response))),
+			ha->response_ring, ha->response_dma);
+
+	pci_disable_device(pdev);
+
+	scsi_host_put(host);
+}
+
+#if LINUX_VERSION_CODE >= 0x020600
+static struct pci_driver qla1280_pci_driver = {
+	.name		= "qla1280",
+	.id_table	= qla1280_pci_tbl,
+	.probe		= qla1280_probe_one,
+	.remove		= __devexit_p(qla1280_remove_one),
+};
+
+static int __init
+qla1280_init(void)
+{
+	if (sizeof(struct srb) > sizeof(struct scsi_pointer)) {
+		printk(KERN_WARNING
+		       "qla1280: struct srb too big, aborting\n");
+		return -EINVAL;
+	}
+
+#ifdef MODULE
+	/*
+	 * If we are called as a module, the qla1280 pointer may not be null
+	 * and it would point to our bootup string, just like on the lilo
+	 * command line.  IF not NULL, then process this config string with
+	 * qla1280_setup
+	 *
+	 * Boot time Options
+	 * To add options at boot time add a line to your lilo.conf file like:
+	 * append="qla1280=verbose,max_tags:{{255,255,255,255},{255,255,255,255}}"
+	 * which will result in the first four devices on the first two
+	 * controllers being set to a tagged queue depth of 32.
+	 */
+	if (qla1280)
+		qla1280_setup(qla1280);
+#endif
+
+	return pci_module_init(&qla1280_pci_driver);
+}
+
+static void __exit
+qla1280_exit(void)
+{
+	pci_unregister_driver(&qla1280_pci_driver);
+}
+
+module_init(qla1280_init);
+module_exit(qla1280_exit);
+
+#else
+# define driver_template qla1280_driver_template
+# include "scsi_module.c"
+#endif
+
+MODULE_AUTHOR("Qlogic & Jes Sorensen");
+MODULE_DESCRIPTION("Qlogic ISP SCSI (qla1x80/qla1x160) driver");
+MODULE_LICENSE("GPL");
+MODULE_VERSION(QLA1280_VERSION);
+
+/*
+ * Overrides for Emacs so that we almost follow Linus's tabbing style.
+ * Emacs will notice this stuff at the end of the file and automatically
+ * adjust the settings for this buffer only.  This must remain at the end
+ * of the file.
+ * ---------------------------------------------------------------------------
+ * Local variables:
+ * c-basic-offset: 8
+ * tab-width: 8
+ * End:
+ */
