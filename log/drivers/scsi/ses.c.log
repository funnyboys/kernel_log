commit ba6d10ab8014ac10d25ca513352b6665e73b5785
Merge: 64b08df460cf baf23eddbf2a
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Thu Jul 11 15:14:01 2019 -0700

    Merge tag 'scsi-misc' of git://git.kernel.org/pub/scm/linux/kernel/git/jejb/scsi
    
    Pull SCSI updates from James Bottomley:
     "This is mostly update of the usual drivers: qla2xxx, hpsa, lpfc, ufs,
      mpt3sas, ibmvscsi, megaraid_sas, bnx2fc and hisi_sas as well as the
      removal of the osst driver (I heard from Willem privately that he
      would like the driver removed because all his test hardware has
      failed). Plus number of minor changes, spelling fixes and other
      trivia.
    
      The big merge conflict this time around is the SPDX licence tags.
      Following discussion on linux-next, we believe our version to be more
      accurate than the one in the tree, so the resolution is to take our
      version for all the SPDX conflicts"
    
    Note on the SPDX license tag conversion conflicts: the SCSI tree had
    done its own SPDX conversion, which in some cases conflicted with the
    treewide ones done by Thomas & co.
    
    In almost all cases, the conflicts were purely syntactic: the SCSI tree
    used the old-style SPDX tags ("GPL-2.0" and "GPL-2.0+") while the
    treewide conversion had used the new-style ones ("GPL-2.0-only" and
    "GPL-2.0-or-later").
    
    In these cases I picked the new-style one.
    
    In a few cases, the SPDX conversion was actually different, though.  As
    explained by James above, and in more detail in a pre-pull-request
    thread:
    
     "The other problem is actually substantive: In the libsas code Luben
      Tuikov originally specified gpl 2.0 only by dint of stating:
    
      * This file is licensed under GPLv2.
    
      In all the libsas files, but then muddied the water by quoting GPLv2
      verbatim (which includes the or later than language). So for these
      files Christoph did the conversion to v2 only SPDX tags and Thomas
      converted to v2 or later tags"
    
    So in those cases, where the spdx tag substantially mattered, I took the
    SCSI tree conversion of it, but then also took the opportunity to turn
    the old-style "GPL-2.0" into a new-style "GPL-2.0-only" tag.
    
    Similarly, when there were whitespace differences or other differences
    to the comments around the copyright notices, I took the version from
    the SCSI tree as being the more specific conversion.
    
    Finally, in the spdx conversions that had no conflicts (because the
    treewide ones hadn't been done for those files), I just took the SCSI
    tree version as-is, even if it was old-style.  The old-style conversions
    are perfectly valid, even if the "-only" and "-or-later" versions are
    perhaps more descriptive.
    
    * tag 'scsi-misc' of git://git.kernel.org/pub/scm/linux/kernel/git/jejb/scsi: (185 commits)
      scsi: qla2xxx: move IO flush to the front of NVME rport unregistration
      scsi: qla2xxx: Fix NVME cmd and LS cmd timeout race condition
      scsi: qla2xxx: on session delete, return nvme cmd
      scsi: qla2xxx: Fix kernel crash after disconnecting NVMe devices
      scsi: megaraid_sas: Update driver version to 07.710.06.00-rc1
      scsi: megaraid_sas: Introduce various Aero performance modes
      scsi: megaraid_sas: Use high IOPS queues based on IO workload
      scsi: megaraid_sas: Set affinity for high IOPS reply queues
      scsi: megaraid_sas: Enable coalescing for high IOPS queues
      scsi: megaraid_sas: Add support for High IOPS queues
      scsi: megaraid_sas: Add support for MPI toolbox commands
      scsi: megaraid_sas: Offload Aero RAID5/6 division calculations to driver
      scsi: megaraid_sas: RAID1 PCI bandwidth limit algorithm is applicable for only Ventura
      scsi: megaraid_sas: megaraid_sas: Add check for count returned by HOST_DEVICE_LIST DCMD
      scsi: megaraid_sas: Handle sequence JBOD map failure at driver level
      scsi: megaraid_sas: Don't send FPIO to RL Bypass queue
      scsi: megaraid_sas: In probe context, retry IOC INIT once if firmware is in fault
      scsi: megaraid_sas: Release Mutex lock before OCR in case of DCMD timeout
      scsi: megaraid_sas: Call disable_irq from process IRQ poll
      scsi: megaraid_sas: Remove few debug counters from IO path
      ...

commit 82c298100a2db7e4241e0fee73d94dc5ee573837
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Tue May 28 09:57:05 2019 -0700

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 176
    
    Based on 1 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license version 2 as
      published by the free software foundation this program is
      distributed in the hope that it will be useful but without any
      warranty without even the implied warranty of merchantability or
      fitness for a particular purpose see the gnu general public license
      for more details you should have received a copy of the gnu general
      public license along with this program if not write to the free
      software foundation inc 675 mass ave cambridge ma 02139 usa
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-only
    
    has been chosen to replace the boilerplate/reference in 44 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Reviewed-by: Steve Winslow <swinslow@gmail.com>
    Reviewed-by: Alexios Zavras <alexios.zavras@intel.com>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190528170025.980374610@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/scsi/ses.c b/drivers/scsi/ses.c
index 0fc39224ce1e..60f01a7b728c 100644
--- a/drivers/scsi/ses.c
+++ b/drivers/scsi/ses.c
@@ -1,3 +1,4 @@
+// SPDX-License-Identifier: GPL-2.0-only
 /*
  * SCSI Enclosure Services
  *
@@ -5,18 +6,6 @@
  *
 **-----------------------------------------------------------------------------
 **
-**  This program is free software; you can redistribute it and/or
-**  modify it under the terms of the GNU General Public License
-**  version 2 as published by the Free Software Foundation.
-**
-**  This program is distributed in the hope that it will be useful,
-**  but WITHOUT ANY WARRANTY; without even the implied warranty of
-**  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-**  GNU General Public License for more details.
-**
-**  You should have received a copy of the GNU General Public License
-**  along with this program; if not, write to the Free Software
-**  Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
 **
 **-----------------------------------------------------------------------------
 */

commit 5ee7e1f1c6c1263f0970462d19a2853ca1bb694d
Author: Christoph Hellwig <hch@lst.de>
Date:   Wed May 1 12:14:13 2019 -0400

    scsi: ses: switch to SPDX tags
    
    Use the the GPLv2 SPDX tag instead of verbose boilerplate text.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Reviewed-by: Hannes Reinecke <hare@suse.com>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/ses.c b/drivers/scsi/ses.c
index 0fc39224ce1e..8afea5a1d3f0 100644
--- a/drivers/scsi/ses.c
+++ b/drivers/scsi/ses.c
@@ -1,25 +1,9 @@
+// SPDX-License-Identifier: GPL-2.0
 /*
  * SCSI Enclosure Services
  *
  * Copyright (C) 2008 James Bottomley <James.Bottomley@HansenPartnership.com>
- *
-**-----------------------------------------------------------------------------
-**
-**  This program is free software; you can redistribute it and/or
-**  modify it under the terms of the GNU General Public License
-**  version 2 as published by the Free Software Foundation.
-**
-**  This program is distributed in the hope that it will be useful,
-**  but WITHOUT ANY WARRANTY; without even the implied warranty of
-**  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-**  GNU General Public License for more details.
-**
-**  You should have received a copy of the GNU General Public License
-**  along with this program; if not, write to the Free Software
-**  Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
-**
-**-----------------------------------------------------------------------------
-*/
+ */
 
 #include <linux/slab.h>
 #include <linux/module.h>

commit 6396bb221514d2876fd6dc0aa2a1f240d99b37bb
Author: Kees Cook <keescook@chromium.org>
Date:   Tue Jun 12 14:03:40 2018 -0700

    treewide: kzalloc() -> kcalloc()
    
    The kzalloc() function has a 2-factor argument form, kcalloc(). This
    patch replaces cases of:
    
            kzalloc(a * b, gfp)
    
    with:
            kcalloc(a * b, gfp)
    
    as well as handling cases of:
    
            kzalloc(a * b * c, gfp)
    
    with:
    
            kzalloc(array3_size(a, b, c), gfp)
    
    as it's slightly less ugly than:
    
            kzalloc_array(array_size(a, b), c, gfp)
    
    This does, however, attempt to ignore constant size factors like:
    
            kzalloc(4 * 1024, gfp)
    
    though any constants defined via macros get caught up in the conversion.
    
    Any factors with a sizeof() of "unsigned char", "char", and "u8" were
    dropped, since they're redundant.
    
    The Coccinelle script used for this was:
    
    // Fix redundant parens around sizeof().
    @@
    type TYPE;
    expression THING, E;
    @@
    
    (
      kzalloc(
    -       (sizeof(TYPE)) * E
    +       sizeof(TYPE) * E
      , ...)
    |
      kzalloc(
    -       (sizeof(THING)) * E
    +       sizeof(THING) * E
      , ...)
    )
    
    // Drop single-byte sizes and redundant parens.
    @@
    expression COUNT;
    typedef u8;
    typedef __u8;
    @@
    
    (
      kzalloc(
    -       sizeof(u8) * (COUNT)
    +       COUNT
      , ...)
    |
      kzalloc(
    -       sizeof(__u8) * (COUNT)
    +       COUNT
      , ...)
    |
      kzalloc(
    -       sizeof(char) * (COUNT)
    +       COUNT
      , ...)
    |
      kzalloc(
    -       sizeof(unsigned char) * (COUNT)
    +       COUNT
      , ...)
    |
      kzalloc(
    -       sizeof(u8) * COUNT
    +       COUNT
      , ...)
    |
      kzalloc(
    -       sizeof(__u8) * COUNT
    +       COUNT
      , ...)
    |
      kzalloc(
    -       sizeof(char) * COUNT
    +       COUNT
      , ...)
    |
      kzalloc(
    -       sizeof(unsigned char) * COUNT
    +       COUNT
      , ...)
    )
    
    // 2-factor product with sizeof(type/expression) and identifier or constant.
    @@
    type TYPE;
    expression THING;
    identifier COUNT_ID;
    constant COUNT_CONST;
    @@
    
    (
    - kzalloc
    + kcalloc
      (
    -       sizeof(TYPE) * (COUNT_ID)
    +       COUNT_ID, sizeof(TYPE)
      , ...)
    |
    - kzalloc
    + kcalloc
      (
    -       sizeof(TYPE) * COUNT_ID
    +       COUNT_ID, sizeof(TYPE)
      , ...)
    |
    - kzalloc
    + kcalloc
      (
    -       sizeof(TYPE) * (COUNT_CONST)
    +       COUNT_CONST, sizeof(TYPE)
      , ...)
    |
    - kzalloc
    + kcalloc
      (
    -       sizeof(TYPE) * COUNT_CONST
    +       COUNT_CONST, sizeof(TYPE)
      , ...)
    |
    - kzalloc
    + kcalloc
      (
    -       sizeof(THING) * (COUNT_ID)
    +       COUNT_ID, sizeof(THING)
      , ...)
    |
    - kzalloc
    + kcalloc
      (
    -       sizeof(THING) * COUNT_ID
    +       COUNT_ID, sizeof(THING)
      , ...)
    |
    - kzalloc
    + kcalloc
      (
    -       sizeof(THING) * (COUNT_CONST)
    +       COUNT_CONST, sizeof(THING)
      , ...)
    |
    - kzalloc
    + kcalloc
      (
    -       sizeof(THING) * COUNT_CONST
    +       COUNT_CONST, sizeof(THING)
      , ...)
    )
    
    // 2-factor product, only identifiers.
    @@
    identifier SIZE, COUNT;
    @@
    
    - kzalloc
    + kcalloc
      (
    -       SIZE * COUNT
    +       COUNT, SIZE
      , ...)
    
    // 3-factor product with 1 sizeof(type) or sizeof(expression), with
    // redundant parens removed.
    @@
    expression THING;
    identifier STRIDE, COUNT;
    type TYPE;
    @@
    
    (
      kzalloc(
    -       sizeof(TYPE) * (COUNT) * (STRIDE)
    +       array3_size(COUNT, STRIDE, sizeof(TYPE))
      , ...)
    |
      kzalloc(
    -       sizeof(TYPE) * (COUNT) * STRIDE
    +       array3_size(COUNT, STRIDE, sizeof(TYPE))
      , ...)
    |
      kzalloc(
    -       sizeof(TYPE) * COUNT * (STRIDE)
    +       array3_size(COUNT, STRIDE, sizeof(TYPE))
      , ...)
    |
      kzalloc(
    -       sizeof(TYPE) * COUNT * STRIDE
    +       array3_size(COUNT, STRIDE, sizeof(TYPE))
      , ...)
    |
      kzalloc(
    -       sizeof(THING) * (COUNT) * (STRIDE)
    +       array3_size(COUNT, STRIDE, sizeof(THING))
      , ...)
    |
      kzalloc(
    -       sizeof(THING) * (COUNT) * STRIDE
    +       array3_size(COUNT, STRIDE, sizeof(THING))
      , ...)
    |
      kzalloc(
    -       sizeof(THING) * COUNT * (STRIDE)
    +       array3_size(COUNT, STRIDE, sizeof(THING))
      , ...)
    |
      kzalloc(
    -       sizeof(THING) * COUNT * STRIDE
    +       array3_size(COUNT, STRIDE, sizeof(THING))
      , ...)
    )
    
    // 3-factor product with 2 sizeof(variable), with redundant parens removed.
    @@
    expression THING1, THING2;
    identifier COUNT;
    type TYPE1, TYPE2;
    @@
    
    (
      kzalloc(
    -       sizeof(TYPE1) * sizeof(TYPE2) * COUNT
    +       array3_size(COUNT, sizeof(TYPE1), sizeof(TYPE2))
      , ...)
    |
      kzalloc(
    -       sizeof(TYPE1) * sizeof(THING2) * (COUNT)
    +       array3_size(COUNT, sizeof(TYPE1), sizeof(TYPE2))
      , ...)
    |
      kzalloc(
    -       sizeof(THING1) * sizeof(THING2) * COUNT
    +       array3_size(COUNT, sizeof(THING1), sizeof(THING2))
      , ...)
    |
      kzalloc(
    -       sizeof(THING1) * sizeof(THING2) * (COUNT)
    +       array3_size(COUNT, sizeof(THING1), sizeof(THING2))
      , ...)
    |
      kzalloc(
    -       sizeof(TYPE1) * sizeof(THING2) * COUNT
    +       array3_size(COUNT, sizeof(TYPE1), sizeof(THING2))
      , ...)
    |
      kzalloc(
    -       sizeof(TYPE1) * sizeof(THING2) * (COUNT)
    +       array3_size(COUNT, sizeof(TYPE1), sizeof(THING2))
      , ...)
    )
    
    // 3-factor product, only identifiers, with redundant parens removed.
    @@
    identifier STRIDE, SIZE, COUNT;
    @@
    
    (
      kzalloc(
    -       (COUNT) * STRIDE * SIZE
    +       array3_size(COUNT, STRIDE, SIZE)
      , ...)
    |
      kzalloc(
    -       COUNT * (STRIDE) * SIZE
    +       array3_size(COUNT, STRIDE, SIZE)
      , ...)
    |
      kzalloc(
    -       COUNT * STRIDE * (SIZE)
    +       array3_size(COUNT, STRIDE, SIZE)
      , ...)
    |
      kzalloc(
    -       (COUNT) * (STRIDE) * SIZE
    +       array3_size(COUNT, STRIDE, SIZE)
      , ...)
    |
      kzalloc(
    -       COUNT * (STRIDE) * (SIZE)
    +       array3_size(COUNT, STRIDE, SIZE)
      , ...)
    |
      kzalloc(
    -       (COUNT) * STRIDE * (SIZE)
    +       array3_size(COUNT, STRIDE, SIZE)
      , ...)
    |
      kzalloc(
    -       (COUNT) * (STRIDE) * (SIZE)
    +       array3_size(COUNT, STRIDE, SIZE)
      , ...)
    |
      kzalloc(
    -       COUNT * STRIDE * SIZE
    +       array3_size(COUNT, STRIDE, SIZE)
      , ...)
    )
    
    // Any remaining multi-factor products, first at least 3-factor products,
    // when they're not all constants...
    @@
    expression E1, E2, E3;
    constant C1, C2, C3;
    @@
    
    (
      kzalloc(C1 * C2 * C3, ...)
    |
      kzalloc(
    -       (E1) * E2 * E3
    +       array3_size(E1, E2, E3)
      , ...)
    |
      kzalloc(
    -       (E1) * (E2) * E3
    +       array3_size(E1, E2, E3)
      , ...)
    |
      kzalloc(
    -       (E1) * (E2) * (E3)
    +       array3_size(E1, E2, E3)
      , ...)
    |
      kzalloc(
    -       E1 * E2 * E3
    +       array3_size(E1, E2, E3)
      , ...)
    )
    
    // And then all remaining 2 factors products when they're not all constants,
    // keeping sizeof() as the second factor argument.
    @@
    expression THING, E1, E2;
    type TYPE;
    constant C1, C2, C3;
    @@
    
    (
      kzalloc(sizeof(THING) * C2, ...)
    |
      kzalloc(sizeof(TYPE) * C2, ...)
    |
      kzalloc(C1 * C2 * C3, ...)
    |
      kzalloc(C1 * C2, ...)
    |
    - kzalloc
    + kcalloc
      (
    -       sizeof(TYPE) * (E2)
    +       E2, sizeof(TYPE)
      , ...)
    |
    - kzalloc
    + kcalloc
      (
    -       sizeof(TYPE) * E2
    +       E2, sizeof(TYPE)
      , ...)
    |
    - kzalloc
    + kcalloc
      (
    -       sizeof(THING) * (E2)
    +       E2, sizeof(THING)
      , ...)
    |
    - kzalloc
    + kcalloc
      (
    -       sizeof(THING) * E2
    +       E2, sizeof(THING)
      , ...)
    |
    - kzalloc
    + kcalloc
      (
    -       (E1) * E2
    +       E1, E2
      , ...)
    |
    - kzalloc
    + kcalloc
      (
    -       (E1) * (E2)
    +       E1, E2
      , ...)
    |
    - kzalloc
    + kcalloc
      (
    -       E1 * E2
    +       E1, E2
      , ...)
    )
    
    Signed-off-by: Kees Cook <keescook@chromium.org>

diff --git a/drivers/scsi/ses.c b/drivers/scsi/ses.c
index 62f04c0511cf..0fc39224ce1e 100644
--- a/drivers/scsi/ses.c
+++ b/drivers/scsi/ses.c
@@ -747,7 +747,7 @@ static int ses_intf_add(struct device *cdev,
 		buf = NULL;
 	}
 page2_not_supported:
-	scomp = kzalloc(sizeof(struct ses_component) * components, GFP_KERNEL);
+	scomp = kcalloc(components, sizeof(struct ses_component), GFP_KERNEL);
 	if (!scomp)
 		goto err_free;
 

commit 9c0a50022b8ac7e863e6ec8342fa476fe5d1d75c
Author: Li Dongyang <dongyang.li@anu.edu.au>
Date:   Tue Nov 14 10:48:04 2017 +1100

    scsi: ses: don't ask for diagnostic pages repeatedly during probe
    
    We are testing if there is a match with the ses device in a loop by
    calling ses_match_to_enclosure(), which will issue scsi receive
    diagnostics commands to the ses device for every device on the same
    host.  On one of our boxes with 840 disks, it takes a long time to load
    the driver:
    
    [root@g1b-oss06 ~]# time modprobe ses
    
    real    40m48.247s
    user    0m0.001s
    sys     0m0.196s
    
    With the patch:
    
    [root@g1b-oss06 ~]# time modprobe ses
    
    real    0m17.915s
    user    0m0.008s
    sys     0m0.053s
    
    Note that we still need to refresh page 10 when we see a new disk to
    create the link.
    
    Signed-off-by: Li Dongyang <dongyang.li@anu.edu.au>
    Tested-by: Jason Ozolins <jason.ozolins@hpe.com>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/ses.c b/drivers/scsi/ses.c
index 11826c5c2dd4..62f04c0511cf 100644
--- a/drivers/scsi/ses.c
+++ b/drivers/scsi/ses.c
@@ -615,13 +615,16 @@ static void ses_enclosure_data_process(struct enclosure_device *edev,
 }
 
 static void ses_match_to_enclosure(struct enclosure_device *edev,
-				   struct scsi_device *sdev)
+				   struct scsi_device *sdev,
+				   int refresh)
 {
+	struct scsi_device *edev_sdev = to_scsi_device(edev->edev.parent);
 	struct efd efd = {
 		.addr = 0,
 	};
 
-	ses_enclosure_data_process(edev, to_scsi_device(edev->edev.parent), 0);
+	if (refresh)
+		ses_enclosure_data_process(edev, edev_sdev, 0);
 
 	if (scsi_is_sas_rphy(sdev->sdev_target->dev.parent))
 		efd.addr = sas_get_address(sdev);
@@ -652,7 +655,7 @@ static int ses_intf_add(struct device *cdev,
 		struct enclosure_device *prev = NULL;
 
 		while ((edev = enclosure_find(&sdev->host->shost_gendev, prev)) != NULL) {
-			ses_match_to_enclosure(edev, sdev);
+			ses_match_to_enclosure(edev, sdev, 1);
 			prev = edev;
 		}
 		return -ENODEV;
@@ -768,7 +771,7 @@ static int ses_intf_add(struct device *cdev,
 	shost_for_each_device(tmp_sdev, sdev->host) {
 		if (tmp_sdev->lun != 0 || scsi_device_enclosure(tmp_sdev))
 			continue;
-		ses_match_to_enclosure(edev, tmp_sdev);
+		ses_match_to_enclosure(edev, tmp_sdev, 0);
 	}
 
 	return 0;

commit 2441500a41a9b17ff657626eb81972f62bc8cc5a
Merge: a45a1f361418 e6f77540c067
Author: James Bottomley <James.Bottomley@HansenPartnership.com>
Date:   Thu Sep 7 12:12:43 2017 -0700

    Merge branch 'fixes' into misc

commit a5a039b01729e729ee4cf1e11200f002af787f6e
Author: Calvin Owens <calvinowens@fb.com>
Date:   Thu Aug 24 15:13:52 2017 +0200

    scsi: ses: Fix racy cleanup of /sys in remove_dev()
    
    Currently we free the resources backing the enclosure device before we
    call device_unregister(). This is racy: during rmmod of low-level SCSI
    drivers that hook into enclosure, we end up with a small window of time
    during which writing to /sys can OOPS. Example trace with mpt3sas:
    
      general protection fault: 0000 [#1] SMP KASAN
      Modules linked in: mpt3sas(-) <...>
      RIP: [<ffffffffa0388a98>] ses_get_page2_descriptor.isra.6+0x38/0x220 [ses]
      Call Trace:
       [<ffffffffa0389d14>] ses_set_fault+0xf4/0x400 [ses]
       [<ffffffffa0361069>] set_component_fault+0xa9/0xf0 [enclosure]
       [<ffffffff8205bffc>] dev_attr_store+0x3c/0x70
       [<ffffffff81677df5>] sysfs_kf_write+0x115/0x180
       [<ffffffff81675725>] kernfs_fop_write+0x275/0x3a0
       [<ffffffff8151f810>] __vfs_write+0xe0/0x3e0
       [<ffffffff8152281f>] vfs_write+0x13f/0x4a0
       [<ffffffff81526731>] SyS_write+0x111/0x230
       [<ffffffff828b401b>] entry_SYSCALL_64_fastpath+0x13/0x94
    
    Fortunately the solution is extremely simple: call device_unregister()
    before we free the resources, and the race no longer exists. The driver
    core holds a reference over ->remove_dev(), so AFAICT this is safe.
    
    Signed-off-by: Calvin Owens <calvinowens@fb.com>
    Acked-by: Hannes Reinecke <hare@suse.com>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/ses.c b/drivers/scsi/ses.c
index a3f935008cc1..ea7066cbf0d5 100644
--- a/drivers/scsi/ses.c
+++ b/drivers/scsi/ses.c
@@ -818,8 +818,6 @@ static void ses_intf_remove_enclosure(struct scsi_device *sdev)
 	if (!edev)
 		return;
 
-	enclosure_unregister(edev);
-
 	ses_dev = edev->scratch;
 	edev->scratch = NULL;
 
@@ -831,6 +829,7 @@ static void ses_intf_remove_enclosure(struct scsi_device *sdev)
 	kfree(edev->component[0].scratch);
 
 	put_device(&edev->edev);
+	enclosure_unregister(edev);
 }
 
 static void ses_intf_remove(struct device *cdev,

commit dc56ce12d50c0adc1243bd3d080133bc6b63f403
Author: Hannes Reinecke <hare@suse.de>
Date:   Tue Aug 15 10:21:43 2017 +0200

    scsi: ses: make page2 support optional
    
    Simple subenclosures do not need to support SES page 2, so make it
    optional.
    
    Signed-off-by: Hannes Reinecke <hare@suse.com>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/ses.c b/drivers/scsi/ses.c
index c863c271c781..a3f935008cc1 100644
--- a/drivers/scsi/ses.c
+++ b/drivers/scsi/ses.c
@@ -51,6 +51,13 @@ struct ses_component {
 	u64 addr;
 };
 
+static bool ses_page2_supported(struct enclosure_device *edev)
+{
+	struct ses_device *ses_dev = edev->scratch;
+
+	return (ses_dev->page2 != NULL);
+}
+
 static int ses_probe(struct device *dev)
 {
 	struct scsi_device *sdev = to_scsi_device(dev);
@@ -204,6 +211,10 @@ static void ses_get_fault(struct enclosure_device *edev,
 {
 	unsigned char *desc;
 
+	if (!ses_page2_supported(edev)) {
+		ecomp->fault = 0;
+		return;
+	}
 	desc = ses_get_page2_descriptor(edev, ecomp);
 	if (desc)
 		ecomp->fault = (desc[3] & 0x60) >> 4;
@@ -216,6 +227,9 @@ static int ses_set_fault(struct enclosure_device *edev,
 	unsigned char desc[4];
 	unsigned char *desc_ptr;
 
+	if (!ses_page2_supported(edev))
+		return -EINVAL;
+
 	desc_ptr = ses_get_page2_descriptor(edev, ecomp);
 
 	if (!desc_ptr)
@@ -243,6 +257,10 @@ static void ses_get_status(struct enclosure_device *edev,
 {
 	unsigned char *desc;
 
+	if (!ses_page2_supported(edev)) {
+		ecomp->status = 0;
+		return;
+	}
 	desc = ses_get_page2_descriptor(edev, ecomp);
 	if (desc)
 		ecomp->status = (desc[0] & 0x0f);
@@ -253,6 +271,10 @@ static void ses_get_locate(struct enclosure_device *edev,
 {
 	unsigned char *desc;
 
+	if (!ses_page2_supported(edev)) {
+		ecomp->locate = 0;
+		return;
+	}
 	desc = ses_get_page2_descriptor(edev, ecomp);
 	if (desc)
 		ecomp->locate = (desc[2] & 0x02) ? 1 : 0;
@@ -265,6 +287,9 @@ static int ses_set_locate(struct enclosure_device *edev,
 	unsigned char desc[4];
 	unsigned char *desc_ptr;
 
+	if (!ses_page2_supported(edev))
+		return -EINVAL;
+
 	desc_ptr = ses_get_page2_descriptor(edev, ecomp);
 
 	if (!desc_ptr)
@@ -293,6 +318,9 @@ static int ses_set_active(struct enclosure_device *edev,
 	unsigned char desc[4];
 	unsigned char *desc_ptr;
 
+	if (!ses_page2_supported(edev))
+		return -EINVAL;
+
 	desc_ptr = ses_get_page2_descriptor(edev, ecomp);
 
 	if (!desc_ptr)
@@ -329,6 +357,11 @@ static void ses_get_power_status(struct enclosure_device *edev,
 {
 	unsigned char *desc;
 
+	if (!ses_page2_supported(edev)) {
+		ecomp->power_status = 0;
+		return;
+	}
+
 	desc = ses_get_page2_descriptor(edev, ecomp);
 	if (desc)
 		ecomp->power_status = (desc[3] & 0x10) ? 0 : 1;
@@ -341,6 +374,9 @@ static int ses_set_power_status(struct enclosure_device *edev,
 	unsigned char desc[4];
 	unsigned char *desc_ptr;
 
+	if (!ses_page2_supported(edev))
+		return -EINVAL;
+
 	desc_ptr = ses_get_page2_descriptor(edev, ecomp);
 
 	if (!desc_ptr)
@@ -674,7 +710,7 @@ static int ses_intf_add(struct device *cdev,
 	page = 2;
 	result = ses_recv_diag(sdev, page, hdr_buf, INIT_ALLOC_SIZE);
 	if (result)
-		goto recv_failed;
+		goto page2_not_supported;
 
 	len = (hdr_buf[2] << 8) + hdr_buf[3] + 4;
 	buf = kzalloc(len, GFP_KERNEL);
@@ -707,6 +743,7 @@ static int ses_intf_add(struct device *cdev,
 		ses_dev->page10_len = len;
 		buf = NULL;
 	}
+page2_not_supported:
 	scomp = kzalloc(sizeof(struct ses_component) * components, GFP_KERNEL);
 	if (!scomp)
 		goto err_free;

commit 81b59d7565b8703dfdf738e81e6dc0a417818000
Author: Hannes Reinecke <hare@suse.de>
Date:   Tue Aug 15 10:21:42 2017 +0200

    scsi: ses: Fixup error message 'failed to get diagnostic page 0xffffffea'
    
    The printk was using the result as argument, leading to a slightly
    confusing log message.
    
    Signed-off-by: Hannes Reinecke <hare@suse.com>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/ses.c b/drivers/scsi/ses.c
index 2a651b2063a2..c863c271c781 100644
--- a/drivers/scsi/ses.c
+++ b/drivers/scsi/ses.c
@@ -602,7 +602,7 @@ static int ses_intf_add(struct device *cdev,
 {
 	struct scsi_device *sdev = to_scsi_device(cdev->parent);
 	struct scsi_device *tmp_sdev;
-	unsigned char *buf = NULL, *hdr_buf, *type_ptr;
+	unsigned char *buf = NULL, *hdr_buf, *type_ptr, page;
 	struct ses_device *ses_dev;
 	u32 result;
 	int i, types, len, components = 0;
@@ -631,7 +631,8 @@ static int ses_intf_add(struct device *cdev,
 	if (!hdr_buf || !ses_dev)
 		goto err_init_free;
 
-	result = ses_recv_diag(sdev, 1, hdr_buf, INIT_ALLOC_SIZE);
+	page = 1;
+	result = ses_recv_diag(sdev, page, hdr_buf, INIT_ALLOC_SIZE);
 	if (result)
 		goto recv_failed;
 
@@ -640,7 +641,7 @@ static int ses_intf_add(struct device *cdev,
 	if (!buf)
 		goto err_free;
 
-	result = ses_recv_diag(sdev, 1, buf, len);
+	result = ses_recv_diag(sdev, page, buf, len);
 	if (result)
 		goto recv_failed;
 
@@ -670,7 +671,8 @@ static int ses_intf_add(struct device *cdev,
 	ses_dev->page1_len = len;
 	buf = NULL;
 
-	result = ses_recv_diag(sdev, 2, hdr_buf, INIT_ALLOC_SIZE);
+	page = 2;
+	result = ses_recv_diag(sdev, page, hdr_buf, INIT_ALLOC_SIZE);
 	if (result)
 		goto recv_failed;
 
@@ -689,7 +691,8 @@ static int ses_intf_add(struct device *cdev,
 
 	/* The additional information page --- allows us
 	 * to match up the devices */
-	result = ses_recv_diag(sdev, 10, hdr_buf, INIT_ALLOC_SIZE);
+	page = 10;
+	result = ses_recv_diag(sdev, page, hdr_buf, INIT_ALLOC_SIZE);
 	if (!result) {
 
 		len = (hdr_buf[2] << 8) + hdr_buf[3] + 4;
@@ -697,7 +700,7 @@ static int ses_intf_add(struct device *cdev,
 		if (!buf)
 			goto err_free;
 
-		result = ses_recv_diag(sdev, 10, buf, len);
+		result = ses_recv_diag(sdev, page, buf, len);
 		if (result)
 			goto recv_failed;
 		ses_dev->page10 = buf;
@@ -735,7 +738,7 @@ static int ses_intf_add(struct device *cdev,
 
  recv_failed:
 	sdev_printk(KERN_ERR, sdev, "Failed to get diagnostic page 0x%x\n",
-		    result);
+		    page);
 	err = -ENODEV;
  err_free:
 	kfree(buf);

commit acf8ab9a85bfd6ead185a59c4cfe26b25d5a082f
Author: Hannes Reinecke <hare@suse.de>
Date:   Tue Aug 15 10:21:41 2017 +0200

    scsi: ses: check return code from ses_recv_diag()
    
    We should be checking the return code from ses_recv_diag() to avoid
    accessing invalid data.
    
    Signed-off-by: Hannes Reinecke <hare@suse.com>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/ses.c b/drivers/scsi/ses.c
index f1cdf32d7514..2a651b2063a2 100644
--- a/drivers/scsi/ses.c
+++ b/drivers/scsi/ses.c
@@ -179,7 +179,8 @@ static unsigned char *ses_get_page2_descriptor(struct enclosure_device *edev,
 	unsigned char *type_ptr = ses_dev->page1_types;
 	unsigned char *desc_ptr = ses_dev->page2 + 8;
 
-	ses_recv_diag(sdev, 2, ses_dev->page2, ses_dev->page2_len);
+	if (ses_recv_diag(sdev, 2, ses_dev->page2, ses_dev->page2_len) < 0)
+		return NULL;
 
 	for (i = 0; i < ses_dev->page1_num_types; i++, type_ptr += 4) {
 		for (j = 0; j < type_ptr[1]; j++) {

commit 424f727b94132a4193af401dd823c44612d1d59f
Author: Brian King <brking@linux.vnet.ibm.com>
Date:   Tue Aug 1 13:45:36 2017 -0500

    scsi: ses: Fix wrong page error
    
    If a SES device returns an error on a requested diagnostic page, we are
    currently printing an error indicating the wrong page was received. Fix
    this up to simply return a failure and only check the returned page when
    the diagnostic page buffer was populated by the device.
    
    Signed-off-by: Brian King <brking@linux.vnet.ibm.com>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/ses.c b/drivers/scsi/ses.c
index f1cdf32d7514..8927f9f54ad9 100644
--- a/drivers/scsi/ses.c
+++ b/drivers/scsi/ses.c
@@ -99,7 +99,7 @@ static int ses_recv_diag(struct scsi_device *sdev, int page_code,
 
 	ret =  scsi_execute_req(sdev, cmd, DMA_FROM_DEVICE, buf, bufflen,
 				NULL, SES_TIMEOUT, SES_RETRIES, NULL);
-	if (unlikely(!ret))
+	if (unlikely(ret))
 		return ret;
 
 	recv_page_code = ((unsigned char *)buf)[0];

commit 75106523f39751390b5789b36ee1d213b3af1945
Author: Mauricio Faria de Oliveira <mauricfo@linux.vnet.ibm.com>
Date:   Wed Apr 5 12:18:19 2017 -0300

    scsi: ses: don't get power status of SES device slot on probe
    
    The commit 08024885a2a3 ("ses: Add power_status to SES device slot")
    introduced the 'power_status' attribute to enclosure components and
    the associated callbacks.
    
    There are 2 callbacks available to get the power status of a device:
    1) ses_get_power_status() for 'struct enclosure_component_callbacks'
    2) get_component_power_status() for the sysfs device attribute
    (these are available for kernel-space and user-space, respectively.)
    
    However, despite both methods being available to get power status
    on demand, that commit also introduced a call to get power status
    in ses_enclosure_data_process().
    
    This dramatically increased the total probe time for SCSI devices
    on larger configurations, because ses_enclosure_data_process() is
    called several times during the SCSI devices probe and loops over
    the component devices (but that is another problem, another patch).
    
    That results in a tremendous continuous hammering of SCSI Receive
    Diagnostics commands to the enclosure-services device, which does
    delay the total probe time for the SCSI devices __significantly__:
    
      Originally, ~34 minutes on a system attached to ~170 disks:
    
        [ 9214.490703] mpt3sas version 13.100.00.00 loaded
        ...
        [11256.580231] scsi 17:0:177:0: qdepth(16), tagged(1), simple(0),
                       ordered(0), scsi_level(6), cmd_que(1)
    
      With this patch, it decreased to ~2.5 minutes -- a 13.6x faster
    
        [ 1002.992533] mpt3sas version 13.100.00.00 loaded
        ...
        [ 1151.978831] scsi 11:0:177:0: qdepth(16), tagged(1), simple(0),
                       ordered(0), scsi_level(6), cmd_que(1)
    
    Back to the commit discussion.. on the ses_get_power_status() call
    introduced in ses_enclosure_data_process(): impact of removing it.
    
    That may possibly be in place to initialize the power status value
    on device probe.  However, those 2 functions available to retrieve
    that value _do_ automatically refresh/update it.  So the potential
    benefit would be a direct access of the 'power_status' field which
    does not use the callbacks...
    
    But the only reader of 'struct enclosure_component::power_status'
    is the get_component_power_status() callback for sysfs attribute,
    and it _does_ check for and call the .get_power_status callback,
    (which indeed is defined and implemented by that commit), so the
    power status value is, again, automatically updated.
    
    So, the remaining potential for a direct/non-callback access to
    the power_status attribute would be out-of-tree modules -- well,
    for those, if they are for whatever reason interested in values
    that are set during device probe and not up-to-date by the time
    they need it.. well, that would be curious.
    
    Well, to handle that more properly, set the initial power state
    value to '-1' (i.e., uninitialized) instead of '1' (power 'on'),
    and check for it in that callback which may do an direct access
    to the field value _if_ a callback function is not defined.
    
    Signed-off-by: Mauricio Faria de Oliveira <mauricfo@linux.vnet.ibm.com>
    Fixes: 08024885a2a3 ("ses: Add power_status to SES device slot")
    Reviewed-by: Dan Williams <dan.j.williams@intel.com>
    Reviewed-by: Song Liu <songliubraving@fb.com>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/ses.c b/drivers/scsi/ses.c
index 50adabbb5808..f1cdf32d7514 100644
--- a/drivers/scsi/ses.c
+++ b/drivers/scsi/ses.c
@@ -548,7 +548,6 @@ static void ses_enclosure_data_process(struct enclosure_device *edev,
 					ecomp = &edev->component[components++];
 
 				if (!IS_ERR(ecomp)) {
-					ses_get_power_status(edev, ecomp);
 					if (addl_desc_ptr)
 						ses_process_descriptor(
 							ecomp,

commit 9373eba6cfae48911b977d14323032cd5d161aae
Author: Ewan D. Milne <emilne@redhat.com>
Date:   Mon Jan 9 16:33:36 2017 -0500

    scsi: ses: Fix SAS device detection in enclosure
    
    The call to scsi_is_sas_rphy() needs to be made on the SAS end_device,
    not on the SCSI device.
    
    Fixes: 835831c57e9b ("ses: use scsi_is_sas_rphy instead of is_sas_attached")
    Signed-off-by: Ewan D. Milne <emilne@redhat.com>
    Reviewed-by: Johannes Thumshirn <jthumshirn@suse.de>
    Reviewed-by: James Bottomley <James.Bottomley@HansenPartnership.com>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/ses.c b/drivers/scsi/ses.c
index 8c9a35c91705..50adabbb5808 100644
--- a/drivers/scsi/ses.c
+++ b/drivers/scsi/ses.c
@@ -587,7 +587,7 @@ static void ses_match_to_enclosure(struct enclosure_device *edev,
 
 	ses_enclosure_data_process(edev, to_scsi_device(edev->edev.parent), 0);
 
-	if (scsi_is_sas_rphy(&sdev->sdev_gendev))
+	if (scsi_is_sas_rphy(sdev->sdev_target->dev.parent))
 		efd.addr = sas_get_address(sdev);
 
 	if (efd.addr) {

commit 835831c57e9b0cccc24e96a812542875471d75b5
Author: Johannes Thumshirn <jthumshirn@suse.de>
Date:   Wed Aug 17 11:46:17 2016 +0200

    scsi: ses: use scsi_is_sas_rphy instead of is_sas_attached
    
    Use scsi_is_sas_rphy() instead of is_sas_attached() to decide whether we
    should obtain the SAS address from a scsi device or not. This will
    prevent us from tripping on the BUG_ON() in sas_sdev_to_rdev() if the
    rphy isn't attached to the SAS transport class, like it is with hpsa's
    logical devices.
    
    Fixes: 3f8d6f2a0 ('ses: fix discovery of SATA devices in SAS enclosures')
    Signed-off-by: Johannes Thumshirn <jthumshirn@suse.de>
    Reviewed-by: James E.J. Bottomley <jejb@linux.vnet.ibm.com>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/ses.c b/drivers/scsi/ses.c
index 0e8601aa877a..8c9a35c91705 100644
--- a/drivers/scsi/ses.c
+++ b/drivers/scsi/ses.c
@@ -587,7 +587,7 @@ static void ses_match_to_enclosure(struct enclosure_device *edev,
 
 	ses_enclosure_data_process(edev, to_scsi_device(edev->edev.parent), 0);
 
-	if (is_sas_attached(sdev))
+	if (scsi_is_sas_rphy(&sdev->sdev_gendev))
 		efd.addr = sas_get_address(sdev);
 
 	if (efd.addr) {

commit e120dcb6b2a11840b08f0fc0d2e90256b7b6e842
Author: Calvin Owens <calvinowens@fb.com>
Date:   Fri May 13 13:28:21 2016 -0700

    ses: Fix racy cleanup of /sys in remove_dev()
    
    Currently we free the resources backing the enclosure device before we
    call device_unregister(). This is racy: during rmmod of low-level SCSI
    drivers that hook into enclosure, we end up with a small window of time
    during which writing to /sys can OOPS. Example trace with mpt3sas:
    
      general protection fault: 0000 [#1] SMP KASAN
      Modules linked in: mpt3sas(-) <...>
      RIP: [<ffffffffa0388a98>] ses_get_page2_descriptor.isra.6+0x38/0x220 [ses]
      Call Trace:
       [<ffffffffa0389d14>] ses_set_fault+0xf4/0x400 [ses]
       [<ffffffffa0361069>] set_component_fault+0xa9/0xf0 [enclosure]
       [<ffffffff8205bffc>] dev_attr_store+0x3c/0x70
       [<ffffffff81677df5>] sysfs_kf_write+0x115/0x180
       [<ffffffff81675725>] kernfs_fop_write+0x275/0x3a0
       [<ffffffff8151f810>] __vfs_write+0xe0/0x3e0
       [<ffffffff8152281f>] vfs_write+0x13f/0x4a0
       [<ffffffff81526731>] SyS_write+0x111/0x230
       [<ffffffff828b401b>] entry_SYSCALL_64_fastpath+0x13/0x94
    
    Fortunately the solution is extremely simple: call device_unregister()
    before we free the resources, and the race no longer exists. The driver
    core holds a reference over ->remove_dev(), so AFAICT this is safe.
    
    Signed-off-by: Calvin Owens <calvinowens@fb.com>
    Reviewed-by: James Bottomley <jejb@linux.vnet.ibm.com>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/ses.c b/drivers/scsi/ses.c
index 53ef1cb6418e..0e8601aa877a 100644
--- a/drivers/scsi/ses.c
+++ b/drivers/scsi/ses.c
@@ -778,6 +778,8 @@ static void ses_intf_remove_enclosure(struct scsi_device *sdev)
 	if (!edev)
 		return;
 
+	enclosure_unregister(edev);
+
 	ses_dev = edev->scratch;
 	edev->scratch = NULL;
 
@@ -789,7 +791,6 @@ static void ses_intf_remove_enclosure(struct scsi_device *sdev)
 	kfree(edev->component[0].scratch);
 
 	put_device(&edev->edev);
-	enclosure_unregister(edev);
 }
 
 static void ses_intf_remove(struct device *cdev,

commit 3f8d6f2a0797e8c650a47e5c1b5c2601a46f4293
Author: James Bottomley <James.Bottomley@HansenPartnership.com>
Date:   Wed Dec 9 12:56:07 2015 -0800

    ses: fix discovery of SATA devices in SAS enclosures
    
    The current discovery routines use the VPD 0x83 inquiry page to find
    the device SAS address and match it to the end point in the enclosure.
    This doesn't work for SATA devices because expanders (or hosts) simply
    make up an endpoint address for STP and thus the address returned by
    the VPD page never matches.  Instead of doing this, for SAS attached
    devices, match by the direct endpoint address instead.
    
    Signed-off-by: James Bottomley <James.Bottomley@HansenPartnership.com>

diff --git a/drivers/scsi/ses.c b/drivers/scsi/ses.c
index 044d06410d4c..53ef1cb6418e 100644
--- a/drivers/scsi/ses.c
+++ b/drivers/scsi/ses.c
@@ -34,6 +34,8 @@
 #include <scsi/scsi_driver.h>
 #include <scsi/scsi_host.h>
 
+#include <scsi/scsi_transport_sas.h>
+
 struct ses_device {
 	unsigned char *page1;
 	unsigned char *page1_types;
@@ -579,31 +581,15 @@ static void ses_enclosure_data_process(struct enclosure_device *edev,
 static void ses_match_to_enclosure(struct enclosure_device *edev,
 				   struct scsi_device *sdev)
 {
-	unsigned char *desc;
 	struct efd efd = {
 		.addr = 0,
 	};
 
 	ses_enclosure_data_process(edev, to_scsi_device(edev->edev.parent), 0);
 
-	if (!sdev->vpd_pg83_len)
-		return;
-
-	desc = sdev->vpd_pg83 + 4;
-	while (desc < sdev->vpd_pg83 + sdev->vpd_pg83_len) {
-		enum scsi_protocol proto = desc[0] >> 4;
-		u8 code_set = desc[0] & 0x0f;
-		u8 piv = desc[1] & 0x80;
-		u8 assoc = (desc[1] & 0x30) >> 4;
-		u8 type = desc[1] & 0x0f;
-		u8 len = desc[3];
-
-		if (piv && code_set == 1 && assoc == 1
-		    && proto == SCSI_PROTOCOL_SAS && type == 3 && len == 8)
-			efd.addr = get_unaligned_be64(&desc[4]);
+	if (is_sas_attached(sdev))
+		efd.addr = sas_get_address(sdev);
 
-		desc += len + 4;
-	}
 	if (efd.addr) {
 		efd.dev = &sdev->sdev_gendev;
 

commit 5e1033561da1152c57b97ee84371dba2b3d64c25
Author: James Bottomley <James.Bottomley@HansenPartnership.com>
Date:   Fri Dec 11 09:16:38 2015 -0800

    ses: fix additional element traversal bug
    
    KASAN found that our additional element processing scripts drop off
    the end of the VPD page into unallocated space.  The reason is that
    not every element has additional information but our traversal
    routines think they do, leading to them expecting far more additional
    information than is present.  Fix this by adding a gate to the
    traversal routine so that it only processes elements that are expected
    to have additional information (list is in SES-2 section 6.1.13.1:
    Additional Element Status diagnostic page overview)
    
    Reported-by: Pavel Tikhomirov <ptikhomirov@virtuozzo.com>
    Tested-by: Pavel Tikhomirov <ptikhomirov@virtuozzo.com>
    Cc: stable@vger.kernel.org
    Signed-off-by: James Bottomley <James.Bottomley@HansenPartnership.com>

diff --git a/drivers/scsi/ses.c b/drivers/scsi/ses.c
index 7d9cec50b77d..044d06410d4c 100644
--- a/drivers/scsi/ses.c
+++ b/drivers/scsi/ses.c
@@ -559,7 +559,15 @@ static void ses_enclosure_data_process(struct enclosure_device *edev,
 			if (desc_ptr)
 				desc_ptr += len;
 
-			if (addl_desc_ptr)
+			if (addl_desc_ptr &&
+			    /* only find additional descriptions for specific devices */
+			    (type_ptr[0] == ENCLOSURE_COMPONENT_DEVICE ||
+			     type_ptr[0] == ENCLOSURE_COMPONENT_ARRAY_DEVICE ||
+			     type_ptr[0] == ENCLOSURE_COMPONENT_SAS_EXPANDER ||
+			     /* these elements are optional */
+			     type_ptr[0] == ENCLOSURE_COMPONENT_SCSI_TARGET_PORT ||
+			     type_ptr[0] == ENCLOSURE_COMPONENT_SCSI_INITIATOR_PORT ||
+			     type_ptr[0] == ENCLOSURE_COMPONENT_CONTROLLER_ELECTRONICS))
 				addl_desc_ptr += addl_desc_ptr[1] + 2;
 
 		}

commit 3417c1b5cb1fdc10261dbed42b05cc93166a78fd
Author: James Bottomley <James.Bottomley@HansenPartnership.com>
Date:   Tue Dec 8 09:00:31 2015 -0800

    ses: Fix problems with simple enclosures
    
    Simple enclosure implementations (mostly USB) are allowed to return only
    page 8 to every diagnostic query.  That really confuses our
    implementation because we assume the return is the page we asked for and
    end up doing incorrect offsets based on bogus information leading to
    accesses outside of allocated ranges.  Fix that by checking the page
    code of the return and giving an error if it isn't the one we asked for.
    This should fix reported bugs with USB storage by simply refusing to
    attach to enclosures that behave like this.  It's also good defensive
    practise now that we're starting to see more USB enclosures.
    
    Reported-by: Andrea Gelmini <andrea.gelmini@gelma.net>
    Cc: stable@vger.kernel.org
    Reviewed-by: Ewan D. Milne <emilne@redhat.com>
    Reviewed-by: Tomas Henzl <thenzl@redhat.com>
    Signed-off-by: James Bottomley <James.Bottomley@HansenPartnership.com>

diff --git a/drivers/scsi/ses.c b/drivers/scsi/ses.c
index dcb0d76d7312..7d9cec50b77d 100644
--- a/drivers/scsi/ses.c
+++ b/drivers/scsi/ses.c
@@ -84,6 +84,7 @@ static void init_device_slot_control(unsigned char *dest_desc,
 static int ses_recv_diag(struct scsi_device *sdev, int page_code,
 			 void *buf, int bufflen)
 {
+	int ret;
 	unsigned char cmd[] = {
 		RECEIVE_DIAGNOSTIC,
 		1,		/* Set PCV bit */
@@ -92,9 +93,26 @@ static int ses_recv_diag(struct scsi_device *sdev, int page_code,
 		bufflen & 0xff,
 		0
 	};
+	unsigned char recv_page_code;
 
-	return scsi_execute_req(sdev, cmd, DMA_FROM_DEVICE, buf, bufflen,
+	ret =  scsi_execute_req(sdev, cmd, DMA_FROM_DEVICE, buf, bufflen,
 				NULL, SES_TIMEOUT, SES_RETRIES, NULL);
+	if (unlikely(!ret))
+		return ret;
+
+	recv_page_code = ((unsigned char *)buf)[0];
+
+	if (likely(recv_page_code == page_code))
+		return ret;
+
+	/* successful diagnostic but wrong page code.  This happens to some
+	 * USB devices, just print a message and pretend there was an error */
+
+	sdev_printk(KERN_ERR, sdev,
+		    "Wrong diagnostic page; asked for %d got %u\n",
+		    page_code, recv_page_code);
+
+	return -EINVAL;
 }
 
 static int ses_send_diag(struct scsi_device *sdev, int page_code,

commit 08024885a2a3ed432716e9d50046a620a5b2df05
Author: Song Liu <songliubraving@fb.com>
Date:   Tue Dec 30 14:46:18 2014 -0800

    ses: Add power_status to SES device slot
    
    Add power_status to SES device slot, so we can power on/off the
    HDDs behind the enclosure.
    
    Check firmware status in ses_set_* before sending control pages to
    firmware.
    
    Signed-off-by: Song Liu <songliubraving@fb.com>
    Acked-by: Dan Williams <dan.j.williams@intel.com>
    Reviewed-by: Jens Axboe <axboe@fb.com>
    Cc: Hannes Reinecke <hare@suse.de>
    Signed-off-by: Christoph Hellwig <hch@lst.de>

diff --git a/drivers/scsi/ses.c b/drivers/scsi/ses.c
index 433de8e6f538..dcb0d76d7312 100644
--- a/drivers/scsi/ses.c
+++ b/drivers/scsi/ses.c
@@ -67,6 +67,20 @@ static int ses_probe(struct device *dev)
 #define SES_TIMEOUT (30 * HZ)
 #define SES_RETRIES 3
 
+static void init_device_slot_control(unsigned char *dest_desc,
+				     struct enclosure_component *ecomp,
+				     unsigned char *status)
+{
+	memcpy(dest_desc, status, 4);
+	dest_desc[0] = 0;
+	/* only clear byte 1 for ENCLOSURE_COMPONENT_DEVICE */
+	if (ecomp->type == ENCLOSURE_COMPONENT_DEVICE)
+		dest_desc[1] = 0;
+	dest_desc[2] &= 0xde;
+	dest_desc[3] &= 0x3c;
+}
+
+
 static int ses_recv_diag(struct scsi_device *sdev, int page_code,
 			 void *buf, int bufflen)
 {
@@ -178,14 +192,22 @@ static int ses_set_fault(struct enclosure_device *edev,
 			  struct enclosure_component *ecomp,
 			 enum enclosure_component_setting val)
 {
-	unsigned char desc[4] = {0 };
+	unsigned char desc[4];
+	unsigned char *desc_ptr;
+
+	desc_ptr = ses_get_page2_descriptor(edev, ecomp);
+
+	if (!desc_ptr)
+		return -EIO;
+
+	init_device_slot_control(desc, ecomp, desc_ptr);
 
 	switch (val) {
 	case ENCLOSURE_SETTING_DISABLED:
-		/* zero is disabled */
+		desc[3] &= 0xdf;
 		break;
 	case ENCLOSURE_SETTING_ENABLED:
-		desc[3] = 0x20;
+		desc[3] |= 0x20;
 		break;
 	default:
 		/* SES doesn't do the SGPIO blink settings */
@@ -219,14 +241,22 @@ static int ses_set_locate(struct enclosure_device *edev,
 			  struct enclosure_component *ecomp,
 			  enum enclosure_component_setting val)
 {
-	unsigned char desc[4] = {0 };
+	unsigned char desc[4];
+	unsigned char *desc_ptr;
+
+	desc_ptr = ses_get_page2_descriptor(edev, ecomp);
+
+	if (!desc_ptr)
+		return -EIO;
+
+	init_device_slot_control(desc, ecomp, desc_ptr);
 
 	switch (val) {
 	case ENCLOSURE_SETTING_DISABLED:
-		/* zero is disabled */
+		desc[2] &= 0xfd;
 		break;
 	case ENCLOSURE_SETTING_ENABLED:
-		desc[2] = 0x02;
+		desc[2] |= 0x02;
 		break;
 	default:
 		/* SES doesn't do the SGPIO blink settings */
@@ -239,15 +269,23 @@ static int ses_set_active(struct enclosure_device *edev,
 			  struct enclosure_component *ecomp,
 			  enum enclosure_component_setting val)
 {
-	unsigned char desc[4] = {0 };
+	unsigned char desc[4];
+	unsigned char *desc_ptr;
+
+	desc_ptr = ses_get_page2_descriptor(edev, ecomp);
+
+	if (!desc_ptr)
+		return -EIO;
+
+	init_device_slot_control(desc, ecomp, desc_ptr);
 
 	switch (val) {
 	case ENCLOSURE_SETTING_DISABLED:
-		/* zero is disabled */
+		desc[2] &= 0x7f;
 		ecomp->active = 0;
 		break;
 	case ENCLOSURE_SETTING_ENABLED:
-		desc[2] = 0x80;
+		desc[2] |= 0x80;
 		ecomp->active = 1;
 		break;
 	default:
@@ -265,12 +303,53 @@ static int ses_show_id(struct enclosure_device *edev, char *buf)
 	return sprintf(buf, "%#llx\n", id);
 }
 
+static void ses_get_power_status(struct enclosure_device *edev,
+				 struct enclosure_component *ecomp)
+{
+	unsigned char *desc;
+
+	desc = ses_get_page2_descriptor(edev, ecomp);
+	if (desc)
+		ecomp->power_status = (desc[3] & 0x10) ? 0 : 1;
+}
+
+static int ses_set_power_status(struct enclosure_device *edev,
+				struct enclosure_component *ecomp,
+				int val)
+{
+	unsigned char desc[4];
+	unsigned char *desc_ptr;
+
+	desc_ptr = ses_get_page2_descriptor(edev, ecomp);
+
+	if (!desc_ptr)
+		return -EIO;
+
+	init_device_slot_control(desc, ecomp, desc_ptr);
+
+	switch (val) {
+	/* power = 1 is device_off = 0 and vice versa */
+	case 0:
+		desc[3] |= 0x10;
+		break;
+	case 1:
+		desc[3] &= 0xef;
+		break;
+	default:
+		return -EINVAL;
+	}
+	ecomp->power_status = val;
+	return ses_set_page2_descriptor(edev, ecomp, desc);
+}
+
 static struct enclosure_component_callbacks ses_enclosure_callbacks = {
 	.get_fault		= ses_get_fault,
 	.set_fault		= ses_set_fault,
 	.get_status		= ses_get_status,
 	.get_locate		= ses_get_locate,
 	.set_locate		= ses_set_locate,
+	.get_power_status	= ses_get_power_status,
+	.set_power_status	= ses_set_power_status,
 	.set_active		= ses_set_active,
 	.show_id		= ses_show_id,
 };
@@ -449,6 +528,7 @@ static void ses_enclosure_data_process(struct enclosure_device *edev,
 					ecomp = &edev->component[components++];
 
 				if (!IS_ERR(ecomp)) {
+					ses_get_power_status(edev, ecomp);
 					if (addl_desc_ptr)
 						ses_process_descriptor(
 							ecomp,

commit 921ce7f5786052749a22a75780f5ce1a456bcdc6
Author: Dan Williams <dan.j.williams@intel.com>
Date:   Tue Dec 30 14:46:17 2014 -0800

    ses: add reliable slot attribute
    
    The name provided by firmware is in a vendor specific format, publish
    the slot number to have a reliable mechanism for identifying slots
    across firmware implementations.  If the enclosure does not provide a
    slot number fallback to the component number which is guaranteed unique,
    and usually mirrors the slot number.
    
    Cleaned up the unused ses_component.desc in the process.
    
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>
    Signed-off-by: Song Liu <songliubraving@fb.com>
    Reviewed-by: Jens Axboe <axboe@fb.com>
    Reviewed-by: Hannes Reinecke <hare@suse.de>
    Signed-off-by: Christoph Hellwig <hch@lst.de>

diff --git a/drivers/scsi/ses.c b/drivers/scsi/ses.c
index 1041556cdbf3..433de8e6f538 100644
--- a/drivers/scsi/ses.c
+++ b/drivers/scsi/ses.c
@@ -47,7 +47,6 @@ struct ses_device {
 
 struct ses_component {
 	u64 addr;
-	unsigned char *desc;
 };
 
 static int ses_probe(struct device *dev)
@@ -307,19 +306,26 @@ static void ses_process_descriptor(struct enclosure_component *ecomp,
 	int invalid = desc[0] & 0x80;
 	enum scsi_protocol proto = desc[0] & 0x0f;
 	u64 addr = 0;
+	int slot = -1;
 	struct ses_component *scomp = ecomp->scratch;
 	unsigned char *d;
 
-	scomp->desc = desc;
-
 	if (invalid)
 		return;
 
 	switch (proto) {
+	case SCSI_PROTOCOL_FCP:
+		if (eip) {
+			d = desc + 4;
+			slot = d[3];
+		}
+		break;
 	case SCSI_PROTOCOL_SAS:
-		if (eip)
+		if (eip) {
+			d = desc + 4;
+			slot = d[3];
 			d = desc + 8;
-		else
+		} else
 			d = desc + 4;
 		/* only take the phy0 addr */
 		addr = (u64)d[12] << 56 |
@@ -335,6 +341,7 @@ static void ses_process_descriptor(struct enclosure_component *ecomp,
 		/* FIXME: Need to add more protocols than just SAS */
 		break;
 	}
+	ecomp->slot = slot;
 	scomp->addr = addr;
 }
 

commit 967f7bab0eaaa74d7d01a56d45aa309f78fb87dd
Author: Dan Williams <dan.j.williams@intel.com>
Date:   Tue Dec 30 14:46:16 2014 -0800

    ses: add enclosure logical id
    
    Export the NAA logical id for the enclosure.  This is optionally
    available from the sas_transport_class, but it is really a property of
    the enclosure.
    
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>
    Signed-off-by: Song Liu <songliubraving@fb.com>
    Reviewed-by: Jens Axboe <axboe@fb.com>
    Cc: Hannes Reinecke <hare@suse.de>
    Signed-off-by: Christoph Hellwig <hch@lst.de>

diff --git a/drivers/scsi/ses.c b/drivers/scsi/ses.c
index 6662b0ca6cfd..1041556cdbf3 100644
--- a/drivers/scsi/ses.c
+++ b/drivers/scsi/ses.c
@@ -258,6 +258,14 @@ static int ses_set_active(struct enclosure_device *edev,
 	return ses_set_page2_descriptor(edev, ecomp, desc);
 }
 
+static int ses_show_id(struct enclosure_device *edev, char *buf)
+{
+	struct ses_device *ses_dev = edev->scratch;
+	unsigned long long id = get_unaligned_be64(ses_dev->page1+8+4);
+
+	return sprintf(buf, "%#llx\n", id);
+}
+
 static struct enclosure_component_callbacks ses_enclosure_callbacks = {
 	.get_fault		= ses_get_fault,
 	.set_fault		= ses_set_fault,
@@ -265,6 +273,7 @@ static struct enclosure_component_callbacks ses_enclosure_callbacks = {
 	.get_locate		= ses_get_locate,
 	.set_locate		= ses_set_locate,
 	.set_active		= ses_set_active,
+	.show_id		= ses_show_id,
 };
 
 struct ses_host_edev {

commit 15a0fbbc8e0d4c135b069c34258fbaebad471dd7
Author: Dan Williams <dan.j.williams@intel.com>
Date:   Tue Dec 30 14:46:15 2014 -0800

    ses: generate KOBJ_CHANGE on enclosure attach
    
    In support of a /dev/disk/by-slot populated with data from the enclosure
    and ses modules udev needs notification when the new interface
    files/links are available.  Otherwise, any udev rules specified for the
    disk cannot assume that the enclosure topology has settled.
    
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>
    Signed-off-by: Song Liu <songliubraving@fb.com>
    Reviewed-by: Jens Axboe <axboe@fb.com>
    Reviewed-by: Hannes Reinecke <hare@suse.de>
    Signed-off-by: Christoph Hellwig <hch@lst.de>

diff --git a/drivers/scsi/ses.c b/drivers/scsi/ses.c
index 7dd9cf558380..6662b0ca6cfd 100644
--- a/drivers/scsi/ses.c
+++ b/drivers/scsi/ses.c
@@ -349,7 +349,8 @@ static int ses_enclosure_find_by_addr(struct enclosure_device *edev,
 		if (scomp->addr != efd->addr)
 			continue;
 
-		enclosure_add_device(edev, i, efd->dev);
+		if (enclosure_add_device(edev, i, efd->dev) == 0)
+			kobject_uevent(&efd->dev->kobj, KOBJ_CHANGE);
 		return 1;
 	}
 	return 0;

commit ed09dcc8bd7fe0991af7737e675996cbd022f38f
Author: Dan Williams <dan.j.williams@intel.com>
Date:   Tue Dec 30 14:46:14 2014 -0800

    ses: close potential registration race
    
    The slot and address fields have a small window of instability when
    userspace can read them before initialization. Separate
    enclosure_component
    allocation from registration.
    
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>
    Signed-off-by: Song Liu <songliubraving@fb.com>
    Reviewed-by: Jens Axboe <axboe@fb.com>
    Cc: Hannes Reinecke <hare@suse.de>
    Signed-off-by: Christoph Hellwig <hch@lst.de>

diff --git a/drivers/scsi/ses.c b/drivers/scsi/ses.c
index b7e79e7646ad..7dd9cf558380 100644
--- a/drivers/scsi/ses.c
+++ b/drivers/scsi/ses.c
@@ -423,16 +423,23 @@ static void ses_enclosure_data_process(struct enclosure_device *edev,
 			    type_ptr[0] == ENCLOSURE_COMPONENT_ARRAY_DEVICE) {
 
 				if (create)
-					ecomp =	enclosure_component_register(edev,
-									     components++,
-									     type_ptr[0],
-									     name);
+					ecomp =	enclosure_component_alloc(
+						edev,
+						components++,
+						type_ptr[0],
+						name);
 				else
 					ecomp = &edev->component[components++];
 
-				if (!IS_ERR(ecomp) && addl_desc_ptr)
-					ses_process_descriptor(ecomp,
-							       addl_desc_ptr);
+				if (!IS_ERR(ecomp)) {
+					if (addl_desc_ptr)
+						ses_process_descriptor(
+							ecomp,
+							addl_desc_ptr);
+					if (create)
+						enclosure_component_register(
+							ecomp);
+				}
 			}
 			if (desc_ptr)
 				desc_ptr += len;

commit 3af6b35261182ff185db1f0fd271254147e2663e
Author: Christoph Hellwig <hch@lst.de>
Date:   Wed Nov 12 18:34:51 2014 +0100

    scsi: remove scsi_driver owner field
    
    The driver core driver structure has grown an owner field and now
    requires it to be set for all modular drivers.  Set it up for
    all scsi_driver instances and get rid of the now superflous
    scsi_driver owner field.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Reported-by: Shane M Seymour <shane.seymour@hp.com>
    Reviewed-by: Ewan D. Milne <emilne@redhat.com
    Reviewed-by: Hannes Reinecke <hare@suse.de>

diff --git a/drivers/scsi/ses.c b/drivers/scsi/ses.c
index 80bfece1a2de..b7e79e7646ad 100644
--- a/drivers/scsi/ses.c
+++ b/drivers/scsi/ses.c
@@ -693,9 +693,9 @@ static struct class_interface ses_interface = {
 };
 
 static struct scsi_driver ses_template = {
-	.owner			= THIS_MODULE,
 	.gendrv = {
 		.name		= "ses",
+		.owner		= THIS_MODULE,
 		.probe		= ses_probe,
 		.remove		= ses_remove,
 	},

commit c38c007af04b928b5285da8cc44fbe2f4810e24e
Author: Hannes Reinecke <hare@suse.de>
Date:   Sat Mar 15 09:51:51 2014 +0100

    [SCSI] ses: Use vpd information from scsi_device
    
    The scsi_device now has VPD page83 information attached, so
    there is no need to query it again.
    
    Signed-off-by: Hannes Reinecke <hare@suse.de>
    Signed-off-by: James Bottomley <JBottomley@Parallels.com>

diff --git a/drivers/scsi/ses.c b/drivers/scsi/ses.c
index eba183c428cf..80bfece1a2de 100644
--- a/drivers/scsi/ses.c
+++ b/drivers/scsi/ses.c
@@ -25,6 +25,7 @@
 #include <linux/module.h>
 #include <linux/kernel.h>
 #include <linux/enclosure.h>
+#include <asm/unaligned.h>
 
 #include <scsi/scsi.h>
 #include <scsi/scsi_cmnd.h>
@@ -448,27 +449,18 @@ static void ses_enclosure_data_process(struct enclosure_device *edev,
 static void ses_match_to_enclosure(struct enclosure_device *edev,
 				   struct scsi_device *sdev)
 {
-	unsigned char *buf;
 	unsigned char *desc;
-	unsigned int vpd_len;
 	struct efd efd = {
 		.addr = 0,
 	};
 
-	buf = kmalloc(INIT_ALLOC_SIZE, GFP_KERNEL);
-	if (!buf || scsi_get_vpd_page(sdev, 0x83, buf, INIT_ALLOC_SIZE))
-		goto free;
-
 	ses_enclosure_data_process(edev, to_scsi_device(edev->edev.parent), 0);
 
-	vpd_len = ((buf[2] << 8) | buf[3]) + 4;
-	kfree(buf);
-	buf = kmalloc(vpd_len, GFP_KERNEL);
-	if (!buf ||scsi_get_vpd_page(sdev, 0x83, buf, vpd_len))
-		goto free;
+	if (!sdev->vpd_pg83_len)
+		return;
 
-	desc = buf + 4;
-	while (desc < buf + vpd_len) {
+	desc = sdev->vpd_pg83 + 4;
+	while (desc < sdev->vpd_pg83 + sdev->vpd_pg83_len) {
 		enum scsi_protocol proto = desc[0] >> 4;
 		u8 code_set = desc[0] & 0x0f;
 		u8 piv = desc[1] & 0x80;
@@ -478,25 +470,15 @@ static void ses_match_to_enclosure(struct enclosure_device *edev,
 
 		if (piv && code_set == 1 && assoc == 1
 		    && proto == SCSI_PROTOCOL_SAS && type == 3 && len == 8)
-			efd.addr = (u64)desc[4] << 56 |
-				(u64)desc[5] << 48 |
-				(u64)desc[6] << 40 |
-				(u64)desc[7] << 32 |
-				(u64)desc[8] << 24 |
-				(u64)desc[9] << 16 |
-				(u64)desc[10] << 8 |
-				(u64)desc[11];
+			efd.addr = get_unaligned_be64(&desc[4]);
 
 		desc += len + 4;
 	}
-	if (!efd.addr)
-		goto free;
+	if (efd.addr) {
+		efd.dev = &sdev->sdev_gendev;
 
-	efd.dev = &sdev->sdev_gendev;
-
-	enclosure_for_each_device(ses_enclosure_find_by_addr, &efd);
- free:
-	kfree(buf);
+		enclosure_for_each_device(ses_enclosure_find_by_addr, &efd);
+	}
 }
 
 static int ses_intf_add(struct device *cdev,

commit 2a350cab9daf9a46322d83b091bb05cf54ccf6ab
Author: Douglas Gilbert <dgilbert@interlog.com>
Date:   Thu Jun 9 00:27:07 2011 -0400

    [SCSI] ses: requesting a fault indication
    
    Noticed that when the sysfs interface of the SCSI SES
    driver was used to request a fault indication the LED
    flashed but the buzzer didn't sound. So it was doing
    what REQUEST IDENT (locate) should do.
    
    Changelog:
       - fix the setting of REQUEST FAULT for the device slot
         and array device slot elements in the enclosure control
         diagnostic page
       - note the potentially defective code that reads the
         FAULT SENSED and FAULT REQUESTED bits from the enclosure
         status diagnostic page
    
    The attached patch is against git/scsi-misc-2.6
    
    Signed-off-by: Douglas Gilbert <dgilbert@interlog.com>
    Cc: stable@kernel.org
    Signed-off-by: James Bottomley <JBottomley@Parallels.com>

diff --git a/drivers/scsi/ses.c b/drivers/scsi/ses.c
index eb7a3e85304f..eba183c428cf 100644
--- a/drivers/scsi/ses.c
+++ b/drivers/scsi/ses.c
@@ -160,6 +160,10 @@ static unsigned char *ses_get_page2_descriptor(struct enclosure_device *edev,
 	return NULL;
 }
 
+/* For device slot and array device slot elements, byte 3 bit 6
+ * is "fault sensed" while byte 3 bit 5 is "fault reqstd". As this
+ * code stands these bits are shifted 4 positions right so in
+ * sysfs they will appear as bits 2 and 1 respectively. Strange. */
 static void ses_get_fault(struct enclosure_device *edev,
 			  struct enclosure_component *ecomp)
 {
@@ -181,7 +185,7 @@ static int ses_set_fault(struct enclosure_device *edev,
 		/* zero is disabled */
 		break;
 	case ENCLOSURE_SETTING_ENABLED:
-		desc[2] = 0x02;
+		desc[3] = 0x20;
 		break;
 	default:
 		/* SES doesn't do the SGPIO blink settings */

commit 8c3adc796f32fa4878ec843f8960717ba377e024
Author: James Bottomley <James.Bottomley@suse.de>
Date:   Fri Mar 18 11:24:23 2011 -0400

    [SCSI] ses: add subenclosure support
    
    There have been many complaints that an enclosure with subenclosures
    isn't attached to by the ses driver.   Until now, though, no-one had
    been willing to provide access to one.
    
    Subenclosures are added simply by flattening the tree (i.e. all
    subenclosure devices show up under the one main device).  This may have
    consequences if the naming is only unique per subenclosure, but that's a
    bug for another day.  The tested array had no page 7, so no device
    naming at all.  It also only had the disk devices on one of its
    subenclosures (all the others had power, fans, temperature and various
    sensors), so testing of this is fairly rudimentary.
    
    Signed-off-by: James Bottomley <James.Bottomley@suse.de>

diff --git a/drivers/scsi/ses.c b/drivers/scsi/ses.c
index 3b00e907b917..eb7a3e85304f 100644
--- a/drivers/scsi/ses.c
+++ b/drivers/scsi/ses.c
@@ -35,9 +35,11 @@
 
 struct ses_device {
 	unsigned char *page1;
+	unsigned char *page1_types;
 	unsigned char *page2;
 	unsigned char *page10;
 	short page1_len;
+	short page1_num_types;
 	short page2_len;
 	short page10_len;
 };
@@ -110,12 +112,12 @@ static int ses_set_page2_descriptor(struct enclosure_device *edev,
 	int i, j, count = 0, descriptor = ecomp->number;
 	struct scsi_device *sdev = to_scsi_device(edev->edev.parent);
 	struct ses_device *ses_dev = edev->scratch;
-	unsigned char *type_ptr = ses_dev->page1 + 12 + ses_dev->page1[11];
+	unsigned char *type_ptr = ses_dev->page1_types;
 	unsigned char *desc_ptr = ses_dev->page2 + 8;
 
 	/* Clear everything */
 	memset(desc_ptr, 0, ses_dev->page2_len - 8);
-	for (i = 0; i < ses_dev->page1[10]; i++, type_ptr += 4) {
+	for (i = 0; i < ses_dev->page1_num_types; i++, type_ptr += 4) {
 		for (j = 0; j < type_ptr[1]; j++) {
 			desc_ptr += 4;
 			if (type_ptr[0] != ENCLOSURE_COMPONENT_DEVICE &&
@@ -140,12 +142,12 @@ static unsigned char *ses_get_page2_descriptor(struct enclosure_device *edev,
 	int i, j, count = 0, descriptor = ecomp->number;
 	struct scsi_device *sdev = to_scsi_device(edev->edev.parent);
 	struct ses_device *ses_dev = edev->scratch;
-	unsigned char *type_ptr = ses_dev->page1 + 12 + ses_dev->page1[11];
+	unsigned char *type_ptr = ses_dev->page1_types;
 	unsigned char *desc_ptr = ses_dev->page2 + 8;
 
 	ses_recv_diag(sdev, 2, ses_dev->page2, ses_dev->page2_len);
 
-	for (i = 0; i < ses_dev->page1[10]; i++, type_ptr += 4) {
+	for (i = 0; i < ses_dev->page1_num_types; i++, type_ptr += 4) {
 		for (j = 0; j < type_ptr[1]; j++) {
 			desc_ptr += 4;
 			if (type_ptr[0] != ENCLOSURE_COMPONENT_DEVICE &&
@@ -358,7 +360,7 @@ static void ses_enclosure_data_process(struct enclosure_device *edev,
 	unsigned char *buf = NULL, *type_ptr, *desc_ptr, *addl_desc_ptr = NULL;
 	int i, j, page7_len, len, components;
 	struct ses_device *ses_dev = edev->scratch;
-	int types = ses_dev->page1[10];
+	int types = ses_dev->page1_num_types;
 	unsigned char *hdr_buf = kzalloc(INIT_ALLOC_SIZE, GFP_KERNEL);
 
 	if (!hdr_buf)
@@ -393,7 +395,7 @@ static void ses_enclosure_data_process(struct enclosure_device *edev,
 	}
 	if (ses_dev->page10)
 		addl_desc_ptr = ses_dev->page10 + 8;
-	type_ptr = ses_dev->page1 + 12 + ses_dev->page1[11];
+	type_ptr = ses_dev->page1_types;
 	components = 0;
 	for (i = 0; i < types; i++, type_ptr += 4) {
 		for (j = 0; j < type_ptr[1]; j++) {
@@ -503,6 +505,7 @@ static int ses_intf_add(struct device *cdev,
 	u32 result;
 	int i, types, len, components = 0;
 	int err = -ENOMEM;
+	int num_enclosures;
 	struct enclosure_device *edev;
 	struct ses_component *scomp = NULL;
 
@@ -530,16 +533,6 @@ static int ses_intf_add(struct device *cdev,
 	if (result)
 		goto recv_failed;
 
-	if (hdr_buf[1] != 0) {
-		/* FIXME: need subenclosure support; I've just never
-		 * seen a device with subenclosures and it makes the
-		 * traversal routines more complex */
-		sdev_printk(KERN_ERR, sdev,
-			"FIXME driver has no support for subenclosures (%d)\n",
-			hdr_buf[1]);
-		goto err_free;
-	}
-
 	len = (hdr_buf[2] << 8) + hdr_buf[3] + 4;
 	buf = kzalloc(len, GFP_KERNEL);
 	if (!buf)
@@ -549,11 +542,24 @@ static int ses_intf_add(struct device *cdev,
 	if (result)
 		goto recv_failed;
 
-	types = buf[10];
+	types = 0;
 
-	type_ptr = buf + 12 + buf[11];
+	/* we always have one main enclosure and the rest are referred
+	 * to as secondary subenclosures */
+	num_enclosures = buf[1] + 1;
 
-	for (i = 0; i < types; i++, type_ptr += 4) {
+	/* begin at the enclosure descriptor */
+	type_ptr = buf + 8;
+	/* skip all the enclosure descriptors */
+	for (i = 0; i < num_enclosures && type_ptr < buf + len; i++) {
+		types += type_ptr[2];
+		type_ptr += type_ptr[3] + 4;
+	}
+
+	ses_dev->page1_types = type_ptr;
+	ses_dev->page1_num_types = types;
+
+	for (i = 0; i < types && type_ptr < buf + len; i++, type_ptr += 4) {
 		if (type_ptr[0] == ENCLOSURE_COMPONENT_DEVICE ||
 		    type_ptr[0] == ENCLOSURE_COMPONENT_ARRAY_DEVICE)
 			components += type_ptr[1];

commit 877a55979c189c590e819a61cbbe2b7947875f17
Author: John Hughes <john@Calva.COM>
Date:   Wed Nov 4 19:01:22 2009 +0100

    [SCSI] ses: show devices for enclosures with no page 7
    
    enclosure page 7 gives us the "pretty" names of the enclosure slots.
    Without a page 7, we can still use the enclosure code as long as we
    make up numeric names for the slots. Unfortunately, the current code
    fails to add any devices because the check for page 10 is in the wrong
    place if we have no page 7.  Fix it so that devices show up even if
    the enclosure has no page 7.
    
    Cc: stable@kernel.org
    Signed-off-by: James Bottomley <James.Bottomley@suse.de>

diff --git a/drivers/scsi/ses.c b/drivers/scsi/ses.c
index 7f5a6a86f820..3b00e907b917 100644
--- a/drivers/scsi/ses.c
+++ b/drivers/scsi/ses.c
@@ -390,9 +390,9 @@ static void ses_enclosure_data_process(struct enclosure_device *edev,
 		len = (desc_ptr[2] << 8) + desc_ptr[3];
 		/* skip past overall descriptor */
 		desc_ptr += len + 4;
-		if (ses_dev->page10)
-			addl_desc_ptr = ses_dev->page10 + 8;
 	}
+	if (ses_dev->page10)
+		addl_desc_ptr = ses_dev->page10 + 8;
 	type_ptr = ses_dev->page1 + 12 + ses_dev->page1[11];
 	components = 0;
 	for (i = 0; i < types; i++, type_ptr += 4) {

commit 5a0e3ad6af8660be21ca98a971cd00f331318c05
Author: Tejun Heo <tj@kernel.org>
Date:   Wed Mar 24 17:04:11 2010 +0900

    include cleanup: Update gfp.h and slab.h includes to prepare for breaking implicit slab.h inclusion from percpu.h
    
    percpu.h is included by sched.h and module.h and thus ends up being
    included when building most .c files.  percpu.h includes slab.h which
    in turn includes gfp.h making everything defined by the two files
    universally available and complicating inclusion dependencies.
    
    percpu.h -> slab.h dependency is about to be removed.  Prepare for
    this change by updating users of gfp and slab facilities include those
    headers directly instead of assuming availability.  As this conversion
    needs to touch large number of source files, the following script is
    used as the basis of conversion.
    
      http://userweb.kernel.org/~tj/misc/slabh-sweep.py
    
    The script does the followings.
    
    * Scan files for gfp and slab usages and update includes such that
      only the necessary includes are there.  ie. if only gfp is used,
      gfp.h, if slab is used, slab.h.
    
    * When the script inserts a new include, it looks at the include
      blocks and try to put the new include such that its order conforms
      to its surrounding.  It's put in the include block which contains
      core kernel includes, in the same order that the rest are ordered -
      alphabetical, Christmas tree, rev-Xmas-tree or at the end if there
      doesn't seem to be any matching order.
    
    * If the script can't find a place to put a new include (mostly
      because the file doesn't have fitting include block), it prints out
      an error message indicating which .h file needs to be added to the
      file.
    
    The conversion was done in the following steps.
    
    1. The initial automatic conversion of all .c files updated slightly
       over 4000 files, deleting around 700 includes and adding ~480 gfp.h
       and ~3000 slab.h inclusions.  The script emitted errors for ~400
       files.
    
    2. Each error was manually checked.  Some didn't need the inclusion,
       some needed manual addition while adding it to implementation .h or
       embedding .c file was more appropriate for others.  This step added
       inclusions to around 150 files.
    
    3. The script was run again and the output was compared to the edits
       from #2 to make sure no file was left behind.
    
    4. Several build tests were done and a couple of problems were fixed.
       e.g. lib/decompress_*.c used malloc/free() wrappers around slab
       APIs requiring slab.h to be added manually.
    
    5. The script was run on all .h files but without automatically
       editing them as sprinkling gfp.h and slab.h inclusions around .h
       files could easily lead to inclusion dependency hell.  Most gfp.h
       inclusion directives were ignored as stuff from gfp.h was usually
       wildly available and often used in preprocessor macros.  Each
       slab.h inclusion directive was examined and added manually as
       necessary.
    
    6. percpu.h was updated not to include slab.h.
    
    7. Build test were done on the following configurations and failures
       were fixed.  CONFIG_GCOV_KERNEL was turned off for all tests (as my
       distributed build env didn't work with gcov compiles) and a few
       more options had to be turned off depending on archs to make things
       build (like ipr on powerpc/64 which failed due to missing writeq).
    
       * x86 and x86_64 UP and SMP allmodconfig and a custom test config.
       * powerpc and powerpc64 SMP allmodconfig
       * sparc and sparc64 SMP allmodconfig
       * ia64 SMP allmodconfig
       * s390 SMP allmodconfig
       * alpha SMP allmodconfig
       * um on x86_64 SMP allmodconfig
    
    8. percpu.h modifications were reverted so that it could be applied as
       a separate patch and serve as bisection point.
    
    Given the fact that I had only a couple of failures from tests on step
    6, I'm fairly confident about the coverage of this conversion patch.
    If there is a breakage, it's likely to be something in one of the arch
    headers which should be easily discoverable easily on most builds of
    the specific arch.
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Guess-its-ok-by: Christoph Lameter <cl@linux-foundation.org>
    Cc: Ingo Molnar <mingo@redhat.com>
    Cc: Lee Schermerhorn <Lee.Schermerhorn@hp.com>

diff --git a/drivers/scsi/ses.c b/drivers/scsi/ses.c
index 0d9d6f7567f5..7f5a6a86f820 100644
--- a/drivers/scsi/ses.c
+++ b/drivers/scsi/ses.c
@@ -21,6 +21,7 @@
 **-----------------------------------------------------------------------------
 */
 
+#include <linux/slab.h>
 #include <linux/module.h>
 #include <linux/kernel.h>
 #include <linux/enclosure.h>

commit 9b3a6549b2602ca30f58715a0071e29f9898cae9
Author: Julia Lawall <julia@diku.dk>
Date:   Wed Mar 10 15:20:42 2010 -0800

    drivers/scsi/ses.c: eliminate double free
    
    The few lines below the kfree of hdr_buf may go to the label err_free
    which will also free hdr_buf.  The most straightforward solution seems to
    be to just move the kfree of hdr_buf after these gotos.
    
    A simplified version of the semantic match that finds this problem is as
    follows: (http://coccinelle.lip6.fr/)
    
    // <smpl>
    @r@
    identifier E;
    expression E1;
    iterator I;
    statement S;
    @@
    
    *kfree(E);
    ... when != E = E1
        when != I(E,...) S
        when != &E
    *kfree(E);
    // </smpl>
    
    Signed-off-by: Julia Lawall <julia@diku.dk>
    Cc: James Bottomley <James.Bottomley@HansenPartnership.com>
    Cc: <stable@kernel.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/scsi/ses.c b/drivers/scsi/ses.c
index 1d7a8780e00c..0d9d6f7567f5 100644
--- a/drivers/scsi/ses.c
+++ b/drivers/scsi/ses.c
@@ -595,8 +595,6 @@ static int ses_intf_add(struct device *cdev,
 		ses_dev->page10_len = len;
 		buf = NULL;
 	}
-	kfree(hdr_buf);
-
 	scomp = kzalloc(sizeof(struct ses_component) * components, GFP_KERNEL);
 	if (!scomp)
 		goto err_free;
@@ -608,6 +606,8 @@ static int ses_intf_add(struct device *cdev,
 		goto err_free;
 	}
 
+	kfree(hdr_buf);
+
 	edev->scratch = ses_dev;
 	for (i = 0; i < components; i++)
 		edev->component[i].scratch = scomp + i;

commit e3deec090558d5cb5ffdc574e5560f3ed9723394
Author: James Bottomley <James.Bottomley@suse.de>
Date:   Tue Nov 3 12:33:07 2009 -0600

    [SCSI] eliminate potential kmalloc failure in scsi_get_vpd_page()
    
    The best way to fix this is to eliminate the intenal kmalloc() and
    make the caller allocate the required amount of storage.
    
    Signed-off-by: James Bottomley <James.Bottomley@suse.de>

diff --git a/drivers/scsi/ses.c b/drivers/scsi/ses.c
index 55b034b72708..1d7a8780e00c 100644
--- a/drivers/scsi/ses.c
+++ b/drivers/scsi/ses.c
@@ -448,13 +448,17 @@ static void ses_match_to_enclosure(struct enclosure_device *edev,
 		.addr = 0,
 	};
 
-	buf = scsi_get_vpd_page(sdev, 0x83);
-	if (!buf)
-		return;
+	buf = kmalloc(INIT_ALLOC_SIZE, GFP_KERNEL);
+	if (!buf || scsi_get_vpd_page(sdev, 0x83, buf, INIT_ALLOC_SIZE))
+		goto free;
 
 	ses_enclosure_data_process(edev, to_scsi_device(edev->edev.parent), 0);
 
 	vpd_len = ((buf[2] << 8) | buf[3]) + 4;
+	kfree(buf);
+	buf = kmalloc(vpd_len, GFP_KERNEL);
+	if (!buf ||scsi_get_vpd_page(sdev, 0x83, buf, vpd_len))
+		goto free;
 
 	desc = buf + 4;
 	while (desc < buf + vpd_len) {

commit 21fab1d0595eacf781705ec3509012a28f298245
Author: James Bottomley <James.Bottomley@HansenPartnership.com>
Date:   Sat Aug 1 00:43:59 2009 +0000

    [SCSI] ses: update enclosure data on hot add
    
    Now that hot add works correctly, if a new device is added, we're still
    operating on stale enclosure data, so fix that by updating the enclosure
    diagnostic pages when we get notified of a device hot add
    
    Signed-off-by: James Bottomley <James.Bottomley@HansenPartnership.com>
    Signed-off-by: James Bottomley <James.Bottomley@suse.de>

diff --git a/drivers/scsi/ses.c b/drivers/scsi/ses.c
index be593c8525b5..55b034b72708 100644
--- a/drivers/scsi/ses.c
+++ b/drivers/scsi/ses.c
@@ -347,6 +347,97 @@ static int ses_enclosure_find_by_addr(struct enclosure_device *edev,
 	return 0;
 }
 
+#define INIT_ALLOC_SIZE 32
+
+static void ses_enclosure_data_process(struct enclosure_device *edev,
+				       struct scsi_device *sdev,
+				       int create)
+{
+	u32 result;
+	unsigned char *buf = NULL, *type_ptr, *desc_ptr, *addl_desc_ptr = NULL;
+	int i, j, page7_len, len, components;
+	struct ses_device *ses_dev = edev->scratch;
+	int types = ses_dev->page1[10];
+	unsigned char *hdr_buf = kzalloc(INIT_ALLOC_SIZE, GFP_KERNEL);
+
+	if (!hdr_buf)
+		goto simple_populate;
+
+	/* re-read page 10 */
+	if (ses_dev->page10)
+		ses_recv_diag(sdev, 10, ses_dev->page10, ses_dev->page10_len);
+	/* Page 7 for the descriptors is optional */
+	result = ses_recv_diag(sdev, 7, hdr_buf, INIT_ALLOC_SIZE);
+	if (result)
+		goto simple_populate;
+
+	page7_len = len = (hdr_buf[2] << 8) + hdr_buf[3] + 4;
+	/* add 1 for trailing '\0' we'll use */
+	buf = kzalloc(len + 1, GFP_KERNEL);
+	if (!buf)
+		goto simple_populate;
+	result = ses_recv_diag(sdev, 7, buf, len);
+	if (result) {
+ simple_populate:
+		kfree(buf);
+		buf = NULL;
+		desc_ptr = NULL;
+		len = 0;
+		page7_len = 0;
+	} else {
+		desc_ptr = buf + 8;
+		len = (desc_ptr[2] << 8) + desc_ptr[3];
+		/* skip past overall descriptor */
+		desc_ptr += len + 4;
+		if (ses_dev->page10)
+			addl_desc_ptr = ses_dev->page10 + 8;
+	}
+	type_ptr = ses_dev->page1 + 12 + ses_dev->page1[11];
+	components = 0;
+	for (i = 0; i < types; i++, type_ptr += 4) {
+		for (j = 0; j < type_ptr[1]; j++) {
+			char *name = NULL;
+			struct enclosure_component *ecomp;
+
+			if (desc_ptr) {
+				if (desc_ptr >= buf + page7_len) {
+					desc_ptr = NULL;
+				} else {
+					len = (desc_ptr[2] << 8) + desc_ptr[3];
+					desc_ptr += 4;
+					/* Add trailing zero - pushes into
+					 * reserved space */
+					desc_ptr[len] = '\0';
+					name = desc_ptr;
+				}
+			}
+			if (type_ptr[0] == ENCLOSURE_COMPONENT_DEVICE ||
+			    type_ptr[0] == ENCLOSURE_COMPONENT_ARRAY_DEVICE) {
+
+				if (create)
+					ecomp =	enclosure_component_register(edev,
+									     components++,
+									     type_ptr[0],
+									     name);
+				else
+					ecomp = &edev->component[components++];
+
+				if (!IS_ERR(ecomp) && addl_desc_ptr)
+					ses_process_descriptor(ecomp,
+							       addl_desc_ptr);
+			}
+			if (desc_ptr)
+				desc_ptr += len;
+
+			if (addl_desc_ptr)
+				addl_desc_ptr += addl_desc_ptr[1] + 2;
+
+		}
+	}
+	kfree(buf);
+	kfree(hdr_buf);
+}
+
 static void ses_match_to_enclosure(struct enclosure_device *edev,
 				   struct scsi_device *sdev)
 {
@@ -361,6 +452,8 @@ static void ses_match_to_enclosure(struct enclosure_device *edev,
 	if (!buf)
 		return;
 
+	ses_enclosure_data_process(edev, to_scsi_device(edev->edev.parent), 0);
+
 	vpd_len = ((buf[2] << 8) | buf[3]) + 4;
 
 	desc = buf + 4;
@@ -395,18 +488,15 @@ static void ses_match_to_enclosure(struct enclosure_device *edev,
 	kfree(buf);
 }
 
-#define INIT_ALLOC_SIZE 32
-
 static int ses_intf_add(struct device *cdev,
 			struct class_interface *intf)
 {
 	struct scsi_device *sdev = to_scsi_device(cdev->parent);
 	struct scsi_device *tmp_sdev;
-	unsigned char *buf = NULL, *hdr_buf, *type_ptr, *desc_ptr = NULL,
-		*addl_desc_ptr = NULL;
+	unsigned char *buf = NULL, *hdr_buf, *type_ptr;
 	struct ses_device *ses_dev;
 	u32 result;
-	int i, j, types, len, page7_len = 0, components = 0;
+	int i, types, len, components = 0;
 	int err = -ENOMEM;
 	struct enclosure_device *edev;
 	struct ses_component *scomp = NULL;
@@ -501,6 +591,7 @@ static int ses_intf_add(struct device *cdev,
 		ses_dev->page10_len = len;
 		buf = NULL;
 	}
+	kfree(hdr_buf);
 
 	scomp = kzalloc(sizeof(struct ses_component) * components, GFP_KERNEL);
 	if (!scomp)
@@ -517,72 +608,7 @@ static int ses_intf_add(struct device *cdev,
 	for (i = 0; i < components; i++)
 		edev->component[i].scratch = scomp + i;
 
-	/* Page 7 for the descriptors is optional */
-	result = ses_recv_diag(sdev, 7, hdr_buf, INIT_ALLOC_SIZE);
-	if (result)
-		goto simple_populate;
-
-	page7_len = len = (hdr_buf[2] << 8) + hdr_buf[3] + 4;
-	/* add 1 for trailing '\0' we'll use */
-	buf = kzalloc(len + 1, GFP_KERNEL);
-	if (!buf)
-		goto simple_populate;
-	result = ses_recv_diag(sdev, 7, buf, len);
-	if (result) {
- simple_populate:
-		kfree(buf);
-		buf = NULL;
-		desc_ptr = NULL;
-		addl_desc_ptr = NULL;
-	} else {
-		desc_ptr = buf + 8;
-		len = (desc_ptr[2] << 8) + desc_ptr[3];
-		/* skip past overall descriptor */
-		desc_ptr += len + 4;
-		if (ses_dev->page10)
-			addl_desc_ptr = ses_dev->page10 + 8;
-	}
-	type_ptr = ses_dev->page1 + 12 + ses_dev->page1[11];
-	components = 0;
-	for (i = 0; i < types; i++, type_ptr += 4) {
-		for (j = 0; j < type_ptr[1]; j++) {
-			char *name = NULL;
-			struct enclosure_component *ecomp;
-
-			if (desc_ptr) {
-				if (desc_ptr >= buf + page7_len) {
-					desc_ptr = NULL;
-				} else {
-					len = (desc_ptr[2] << 8) + desc_ptr[3];
-					desc_ptr += 4;
-					/* Add trailing zero - pushes into
-					 * reserved space */
-					desc_ptr[len] = '\0';
-					name = desc_ptr;
-				}
-			}
-			if (type_ptr[0] == ENCLOSURE_COMPONENT_DEVICE ||
-			    type_ptr[0] == ENCLOSURE_COMPONENT_ARRAY_DEVICE) {
-
-				ecomp =	enclosure_component_register(edev,
-							     components++,
-							     type_ptr[0],
-							     name);
-
-				if (!IS_ERR(ecomp) && addl_desc_ptr)
-					ses_process_descriptor(ecomp,
-							       addl_desc_ptr);
-			}
-			if (desc_ptr)
-				desc_ptr += len;
-
-			if (addl_desc_ptr)
-				addl_desc_ptr += addl_desc_ptr[1] + 2;
-
-		}
-	}
-	kfree(buf);
-	kfree(hdr_buf);
+	ses_enclosure_data_process(edev, sdev, 1);
 
 	/* see if there are any devices matching before
 	 * we found the enclosure */

commit 43d8eb9cfd0aea93be32181c64e18191b69c211c
Author: James Bottomley <James.Bottomley@HansenPartnership.com>
Date:   Sat Aug 1 00:41:22 2009 +0000

    [SCSI] ses: add support for enclosure component hot removal
    
    Right at the moment, hot removal of a device within an enclosure does
    nothing (because the intf_remove only copes with enclosure removal not
    with component removal). Fix this by adding a function to remove the
    component.  Also needed to fix the prototype of
    enclosure_remove_device, since we know the device we've removed but
    not the internal component number
    
    Signed-off-by: James Bottomley <James.Bottomley@HansenPartnership.com>
    Signed-off-by: James Bottomley <James.Bottomley@suse.de>

diff --git a/drivers/scsi/ses.c b/drivers/scsi/ses.c
index e1b8c828f03a..be593c8525b5 100644
--- a/drivers/scsi/ses.c
+++ b/drivers/scsi/ses.c
@@ -616,18 +616,26 @@ static int ses_remove(struct device *dev)
 	return 0;
 }
 
-static void ses_intf_remove(struct device *cdev,
-			    struct class_interface *intf)
+static void ses_intf_remove_component(struct scsi_device *sdev)
+{
+	struct enclosure_device *edev, *prev = NULL;
+
+	while ((edev = enclosure_find(&sdev->host->shost_gendev, prev)) != NULL) {
+		prev = edev;
+		if (!enclosure_remove_device(edev, &sdev->sdev_gendev))
+			break;
+	}
+	if (edev)
+		put_device(&edev->edev);
+}
+
+static void ses_intf_remove_enclosure(struct scsi_device *sdev)
 {
-	struct scsi_device *sdev = to_scsi_device(cdev->parent);
 	struct enclosure_device *edev;
 	struct ses_device *ses_dev;
 
-	if (!scsi_device_enclosure(sdev))
-		return;
-
 	/*  exact match to this enclosure */
-	edev = enclosure_find(cdev->parent, NULL);
+	edev = enclosure_find(&sdev->sdev_gendev, NULL);
 	if (!edev)
 		return;
 
@@ -645,6 +653,17 @@ static void ses_intf_remove(struct device *cdev,
 	enclosure_unregister(edev);
 }
 
+static void ses_intf_remove(struct device *cdev,
+			    struct class_interface *intf)
+{
+	struct scsi_device *sdev = to_scsi_device(cdev->parent);
+
+	if (!scsi_device_enclosure(sdev))
+		ses_intf_remove_component(sdev);
+	else
+		ses_intf_remove_enclosure(sdev);
+}
+
 static struct class_interface ses_interface = {
 	.add_dev	= ses_intf_add,
 	.remove_dev	= ses_intf_remove,

commit 163f52b6cf3a639df6a72c7937e0eb88b20f1ef3
Author: James Bottomley <James.Bottomley@HansenPartnership.com>
Date:   Sat Aug 1 00:39:36 2009 +0000

    [SCSI] ses: fix hotplug with multiple devices and expanders
    
    In a situation either with expanders or with multiple enclosure
    devices, hot add doesn't always work.  This is because we try to find
    a single enclosure device attached to the host.  Fix this by looping
    over all enclosure devices attached to the host and also by making the
    find loop recognise that the enclosure devices may be expander remote
    (i.e. not parented by the host).
    
    Signed-off-by: James Bottomley <James.Bottomley@HansenPartnership.com>
    Signed-off-by: James Bottomley <James.Bottomley@suse.de>

diff --git a/drivers/scsi/ses.c b/drivers/scsi/ses.c
index 4f618f487356..e1b8c828f03a 100644
--- a/drivers/scsi/ses.c
+++ b/drivers/scsi/ses.c
@@ -413,10 +413,11 @@ static int ses_intf_add(struct device *cdev,
 
 	if (!scsi_device_enclosure(sdev)) {
 		/* not an enclosure, but might be in one */
-		edev = enclosure_find(&sdev->host->shost_gendev);
-		if (edev) {
+		struct enclosure_device *prev = NULL;
+
+		while ((edev = enclosure_find(&sdev->host->shost_gendev, prev)) != NULL) {
 			ses_match_to_enclosure(edev, sdev);
-			put_device(&edev->edev);
+			prev = edev;
 		}
 		return -ENODEV;
 	}
@@ -625,7 +626,8 @@ static void ses_intf_remove(struct device *cdev,
 	if (!scsi_device_enclosure(sdev))
 		return;
 
-	edev = enclosure_find(cdev->parent);
+	/*  exact match to this enclosure */
+	edev = enclosure_find(cdev->parent, NULL);
 	if (!edev)
 		return;
 

commit e0aae1a53133f0d7833c8f358a0ccc7055fc5b28
Author: Adrian Bunk <bunk@kernel.org>
Date:   Wed Mar 4 12:06:05 2009 -0800

    [SCSI] ses: #if 0 the unused ses_match_host()
    
    Signed-off-by: Adrian Bunk <bunk@kernel.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: James Bottomley <James.Bottomley@HansenPartnership.com>

diff --git a/drivers/scsi/ses.c b/drivers/scsi/ses.c
index c9146d751cbf..4f618f487356 100644
--- a/drivers/scsi/ses.c
+++ b/drivers/scsi/ses.c
@@ -264,6 +264,7 @@ struct ses_host_edev {
 	struct enclosure_device *edev;
 };
 
+#if 0
 int ses_match_host(struct enclosure_device *edev, void *data)
 {
 	struct ses_host_edev *sed = data;
@@ -280,6 +281,7 @@ int ses_match_host(struct enclosure_device *edev, void *data)
 	sed->edev = edev;
 	return 1;
 }
+#endif  /*  0  */
 
 static void ses_process_descriptor(struct enclosure_component *ecomp,
 				   unsigned char *desc)

commit b3f1f9aa082b2ab86dec4db3d8b1566af345387e
Author: Roel Kluin <roel.kluin@gmail.com>
Date:   Tue Feb 17 16:59:24 2009 +0100

    [SCSI] ses: code_set == 1 is tested twice
    
    Signed-off-by: Roel Kluin <roel.kluin@gmail.com>
    Signed-off-by: James Bottomley <James.Bottomley@HansenPartnership.com>

diff --git a/drivers/scsi/ses.c b/drivers/scsi/ses.c
index f2cf95235543..c9146d751cbf 100644
--- a/drivers/scsi/ses.c
+++ b/drivers/scsi/ses.c
@@ -370,7 +370,7 @@ static void ses_match_to_enclosure(struct enclosure_device *edev,
 		u8 type = desc[1] & 0x0f;
 		u8 len = desc[3];
 
-		if (piv && code_set == 1 && assoc == 1 && code_set == 1
+		if (piv && code_set == 1 && assoc == 1
 		    && proto == SCSI_PROTOCOL_SAS && type == 3 && len == 8)
 			efd.addr = (u64)desc[4] << 56 |
 				(u64)desc[5] << 48 |

commit 40c3460f3cad1672f22baadcdbe20b9b3200cc20
Author: Matthew Wilcox <matthew@wil.cx>
Date:   Wed Dec 31 12:11:17 2008 -0700

    [SCSI] ses: Use new scsi VPD helper
    
    SES had its own code to retrieve VPD from devices; convert it to use the
    new scsi_get_vpd_page helper.
    
    Signed-off-by: Matthew Wilcox <willy@linux.intel.com>
    Signed-off-by: James Bottomley <James.Bottomley@HansenPartnership.com>

diff --git a/drivers/scsi/ses.c b/drivers/scsi/ses.c
index e946e05db7f7..f2cf95235543 100644
--- a/drivers/scsi/ses.c
+++ b/drivers/scsi/ses.c
@@ -345,44 +345,21 @@ static int ses_enclosure_find_by_addr(struct enclosure_device *edev,
 	return 0;
 }
 
-#define VPD_INQUIRY_SIZE 36
-
 static void ses_match_to_enclosure(struct enclosure_device *edev,
 				   struct scsi_device *sdev)
 {
-	unsigned char *buf = kmalloc(VPD_INQUIRY_SIZE, GFP_KERNEL);
+	unsigned char *buf;
 	unsigned char *desc;
-	u16 vpd_len;
+	unsigned int vpd_len;
 	struct efd efd = {
 		.addr = 0,
 	};
-	unsigned char cmd[] = {
-		INQUIRY,
-		1,
-		0x83,
-		VPD_INQUIRY_SIZE >> 8,
-		VPD_INQUIRY_SIZE & 0xff,
-		0
-	};
 
+	buf = scsi_get_vpd_page(sdev, 0x83);
 	if (!buf)
 		return;
 
-	if (scsi_execute_req(sdev, cmd, DMA_FROM_DEVICE, buf,
-			     VPD_INQUIRY_SIZE, NULL, SES_TIMEOUT, SES_RETRIES,
-			     NULL))
-		goto free;
-
-	vpd_len = (buf[2] << 8) + buf[3];
-	kfree(buf);
-	buf = kmalloc(vpd_len, GFP_KERNEL);
-	if (!buf)
-		return;
-	cmd[3] = vpd_len >> 8;
-	cmd[4] = vpd_len & 0xff;
-	if (scsi_execute_req(sdev, cmd, DMA_FROM_DEVICE, buf,
-			     vpd_len, NULL, SES_TIMEOUT, SES_RETRIES, NULL))
-		goto free;
+	vpd_len = ((buf[2] << 8) | buf[3]) + 4;
 
 	desc = buf + 4;
 	while (desc < buf + vpd_len) {

commit 71610f55fa4db63dbf5385929a47c9fb2451f332
Author: Kay Sievers <kay.sievers@vrfy.org>
Date:   Wed Dec 3 22:41:36 2008 +0100

    [SCSI] struct device - replace bus_id with dev_name(), dev_set_name()
    
    [jejb: limit ioctl to returning 20 characters to avoid overrun
           on long device names and add a few more conversions]
    Signed-off-by: Kay Sievers <kay.sievers@vrfy.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>
    Signed-off-by: James Bottomley <James.Bottomley@HansenPartnership.com>

diff --git a/drivers/scsi/ses.c b/drivers/scsi/ses.c
index 7f0df29f3a64..e946e05db7f7 100644
--- a/drivers/scsi/ses.c
+++ b/drivers/scsi/ses.c
@@ -526,7 +526,7 @@ static int ses_intf_add(struct device *cdev,
 	if (!scomp)
 		goto err_free;
 
-	edev = enclosure_register(cdev->parent, sdev->sdev_gendev.bus_id,
+	edev = enclosure_register(cdev->parent, dev_name(&sdev->sdev_gendev),
 				  components, &ses_enclosure_callbacks);
 	if (IS_ERR(edev)) {
 		err = PTR_ERR(edev);

commit f4f4e47e4af6b02dd1c425b931c65d0165356e33
Author: FUJITA Tomonori <fujita.tomonori@lab.ntt.co.jp>
Date:   Thu Dec 4 14:24:39 2008 +0900

    [SCSI] add residual argument to scsi_execute and scsi_execute_req
    
    scsi_execute() and scsi_execute_req() discard the residual length
    information. Some callers need it. This adds residual argument
    (optional) to scsi_execute and scsi_execute_req.
    
    Signed-off-by: FUJITA Tomonori <fujita.tomonori@lab.ntt.co.jp>
    Signed-off-by: James Bottomley <James.Bottomley@HansenPartnership.com>

diff --git a/drivers/scsi/ses.c b/drivers/scsi/ses.c
index 1bcf3c33d7ff..7f0df29f3a64 100644
--- a/drivers/scsi/ses.c
+++ b/drivers/scsi/ses.c
@@ -77,7 +77,7 @@ static int ses_recv_diag(struct scsi_device *sdev, int page_code,
 	};
 
 	return scsi_execute_req(sdev, cmd, DMA_FROM_DEVICE, buf, bufflen,
-				NULL, SES_TIMEOUT, SES_RETRIES);
+				NULL, SES_TIMEOUT, SES_RETRIES, NULL);
 }
 
 static int ses_send_diag(struct scsi_device *sdev, int page_code,
@@ -95,7 +95,7 @@ static int ses_send_diag(struct scsi_device *sdev, int page_code,
 	};
 
 	result = scsi_execute_req(sdev, cmd, DMA_TO_DEVICE, buf, bufflen,
-				  NULL, SES_TIMEOUT, SES_RETRIES);
+				  NULL, SES_TIMEOUT, SES_RETRIES, NULL);
 	if (result)
 		sdev_printk(KERN_ERR, sdev, "SEND DIAGNOSTIC result: %8x\n",
 			    result);
@@ -369,7 +369,8 @@ static void ses_match_to_enclosure(struct enclosure_device *edev,
 		return;
 
 	if (scsi_execute_req(sdev, cmd, DMA_FROM_DEVICE, buf,
-			     VPD_INQUIRY_SIZE, NULL, SES_TIMEOUT, SES_RETRIES))
+			     VPD_INQUIRY_SIZE, NULL, SES_TIMEOUT, SES_RETRIES,
+			     NULL))
 		goto free;
 
 	vpd_len = (buf[2] << 8) + buf[3];
@@ -380,7 +381,7 @@ static void ses_match_to_enclosure(struct enclosure_device *edev,
 	cmd[3] = vpd_len >> 8;
 	cmd[4] = vpd_len & 0xff;
 	if (scsi_execute_req(sdev, cmd, DMA_FROM_DEVICE, buf,
-			     vpd_len, NULL, SES_TIMEOUT, SES_RETRIES))
+			     vpd_len, NULL, SES_TIMEOUT, SES_RETRIES, NULL))
 		goto free;
 
 	desc = buf + 4;

commit 671a99c8eb2f1dde08ac5538d8cd912047c61ddf
Author: James Bottomley <James.Bottomley@HansenPartnership.com>
Date:   Tue Jul 29 11:38:25 2008 -0500

    [SCSI] ses: fix VPD inquiry overrun
    
    There are a few kerneloops.org reports like this one:
    
    http://www.kerneloops.org/search.php?search=ses_match_to_enclosure
    
    That seem to imply we're running off the end of the VPD inquiry data
    (although at 512 bytes, it should be long enough for just about
    anything).  we should be using correctly sized buffers anyway, so put
    those in and hope this oops goes away.
    
    Cc: Stable Tree <stable@kernel.org>
    Signed-off-by: James Bottomley <James.Bottomley@HansenPartnership.com>

diff --git a/drivers/scsi/ses.c b/drivers/scsi/ses.c
index 0fe031f003e7..1bcf3c33d7ff 100644
--- a/drivers/scsi/ses.c
+++ b/drivers/scsi/ses.c
@@ -345,14 +345,14 @@ static int ses_enclosure_find_by_addr(struct enclosure_device *edev,
 	return 0;
 }
 
-#define VPD_INQUIRY_SIZE 512
+#define VPD_INQUIRY_SIZE 36
 
 static void ses_match_to_enclosure(struct enclosure_device *edev,
 				   struct scsi_device *sdev)
 {
 	unsigned char *buf = kmalloc(VPD_INQUIRY_SIZE, GFP_KERNEL);
 	unsigned char *desc;
-	int len;
+	u16 vpd_len;
 	struct efd efd = {
 		.addr = 0,
 	};
@@ -372,9 +372,19 @@ static void ses_match_to_enclosure(struct enclosure_device *edev,
 			     VPD_INQUIRY_SIZE, NULL, SES_TIMEOUT, SES_RETRIES))
 		goto free;
 
-	len = (buf[2] << 8) + buf[3];
+	vpd_len = (buf[2] << 8) + buf[3];
+	kfree(buf);
+	buf = kmalloc(vpd_len, GFP_KERNEL);
+	if (!buf)
+		return;
+	cmd[3] = vpd_len >> 8;
+	cmd[4] = vpd_len & 0xff;
+	if (scsi_execute_req(sdev, cmd, DMA_FROM_DEVICE, buf,
+			     vpd_len, NULL, SES_TIMEOUT, SES_RETRIES))
+		goto free;
+
 	desc = buf + 4;
-	while (desc < buf + len) {
+	while (desc < buf + vpd_len) {
 		enum scsi_protocol proto = desc[0] >> 4;
 		u8 code_set = desc[0] & 0x0f;
 		u8 piv = desc[1] & 0x80;

commit c95e62ce8905aab62fed224eaaa9b8558a0ef652
Author: Matthew Wilcox <matthew@wil.cx>
Date:   Mon Jun 23 09:14:31 2008 -0600

    [SCSI] ses: Fix timeout
    
    Timeouts are measured in jiffies, not in seconds.
    
    Signed-off-by: Matthew Wilcox <willy@linux.intel.com>
    Cc: Stable Tree <stable@kernel.org>
    Signed-off-by: James Bottomley <James.Bottomley@HansenPartnership.com>

diff --git a/drivers/scsi/ses.c b/drivers/scsi/ses.c
index 45df83b9d847..0fe031f003e7 100644
--- a/drivers/scsi/ses.c
+++ b/drivers/scsi/ses.c
@@ -61,7 +61,7 @@ static int ses_probe(struct device *dev)
 	return err;
 }
 
-#define SES_TIMEOUT 30
+#define SES_TIMEOUT (30 * HZ)
 #define SES_RETRIES 3
 
 static int ses_recv_diag(struct scsi_device *sdev, int page_code,

commit ee959b00c335d7780136c5abda37809191fe52c3
Author: Tony Jones <tonyj@suse.de>
Date:   Fri Feb 22 00:13:36 2008 +0100

    SCSI: convert struct class_device to struct device
    
    It's big, but there doesn't seem to be a way to split it up smaller...
    
    Signed-off-by: Tony Jones <tonyj@suse.de>
    Signed-off-by: Kay Sievers <kay.sievers@vrfy.org>
    Cc: Roland Dreier <rolandd@cisco.com>
    Cc: Sean Hefty <sean.hefty@intel.com>
    Cc: Hal Rosenstock <hal.rosenstock@gmail.com>
    Cc: James Bottomley <James.Bottomley@HansenPartnership.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/scsi/ses.c b/drivers/scsi/ses.c
index a6d96694d0a5..45df83b9d847 100644
--- a/drivers/scsi/ses.c
+++ b/drivers/scsi/ses.c
@@ -107,7 +107,7 @@ static int ses_set_page2_descriptor(struct enclosure_device *edev,
 				      unsigned char *desc)
 {
 	int i, j, count = 0, descriptor = ecomp->number;
-	struct scsi_device *sdev = to_scsi_device(edev->cdev.dev);
+	struct scsi_device *sdev = to_scsi_device(edev->edev.parent);
 	struct ses_device *ses_dev = edev->scratch;
 	unsigned char *type_ptr = ses_dev->page1 + 12 + ses_dev->page1[11];
 	unsigned char *desc_ptr = ses_dev->page2 + 8;
@@ -137,7 +137,7 @@ static unsigned char *ses_get_page2_descriptor(struct enclosure_device *edev,
 				      struct enclosure_component *ecomp)
 {
 	int i, j, count = 0, descriptor = ecomp->number;
-	struct scsi_device *sdev = to_scsi_device(edev->cdev.dev);
+	struct scsi_device *sdev = to_scsi_device(edev->edev.parent);
 	struct ses_device *ses_dev = edev->scratch;
 	unsigned char *type_ptr = ses_dev->page1 + 12 + ses_dev->page1[11];
 	unsigned char *desc_ptr = ses_dev->page2 + 8;
@@ -269,10 +269,10 @@ int ses_match_host(struct enclosure_device *edev, void *data)
 	struct ses_host_edev *sed = data;
 	struct scsi_device *sdev;
 
-	if (!scsi_is_sdev_device(edev->cdev.dev))
+	if (!scsi_is_sdev_device(edev->edev.parent))
 		return 0;
 
-	sdev = to_scsi_device(edev->cdev.dev);
+	sdev = to_scsi_device(edev->edev.parent);
 
 	if (sdev->host != sed->shost)
 		return 0;
@@ -407,10 +407,10 @@ static void ses_match_to_enclosure(struct enclosure_device *edev,
 
 #define INIT_ALLOC_SIZE 32
 
-static int ses_intf_add(struct class_device *cdev,
+static int ses_intf_add(struct device *cdev,
 			struct class_interface *intf)
 {
-	struct scsi_device *sdev = to_scsi_device(cdev->dev);
+	struct scsi_device *sdev = to_scsi_device(cdev->parent);
 	struct scsi_device *tmp_sdev;
 	unsigned char *buf = NULL, *hdr_buf, *type_ptr, *desc_ptr = NULL,
 		*addl_desc_ptr = NULL;
@@ -426,7 +426,7 @@ static int ses_intf_add(struct class_device *cdev,
 		edev = enclosure_find(&sdev->host->shost_gendev);
 		if (edev) {
 			ses_match_to_enclosure(edev, sdev);
-			class_device_put(&edev->cdev);
+			put_device(&edev->edev);
 		}
 		return -ENODEV;
 	}
@@ -515,7 +515,7 @@ static int ses_intf_add(struct class_device *cdev,
 	if (!scomp)
 		goto err_free;
 
-	edev = enclosure_register(cdev->dev, sdev->sdev_gendev.bus_id,
+	edev = enclosure_register(cdev->parent, sdev->sdev_gendev.bus_id,
 				  components, &ses_enclosure_callbacks);
 	if (IS_ERR(edev)) {
 		err = PTR_ERR(edev);
@@ -625,17 +625,17 @@ static int ses_remove(struct device *dev)
 	return 0;
 }
 
-static void ses_intf_remove(struct class_device *cdev,
+static void ses_intf_remove(struct device *cdev,
 			    struct class_interface *intf)
 {
-	struct scsi_device *sdev = to_scsi_device(cdev->dev);
+	struct scsi_device *sdev = to_scsi_device(cdev->parent);
 	struct enclosure_device *edev;
 	struct ses_device *ses_dev;
 
 	if (!scsi_device_enclosure(sdev))
 		return;
 
-	edev = enclosure_find(cdev->dev);
+	edev = enclosure_find(cdev->parent);
 	if (!edev)
 		return;
 
@@ -649,13 +649,13 @@ static void ses_intf_remove(struct class_device *cdev,
 
 	kfree(edev->component[0].scratch);
 
-	class_device_put(&edev->cdev);
+	put_device(&edev->edev);
 	enclosure_unregister(edev);
 }
 
 static struct class_interface ses_interface = {
-	.add	= ses_intf_add,
-	.remove	= ses_intf_remove,
+	.add_dev	= ses_intf_add,
+	.remove_dev	= ses_intf_remove,
 };
 
 static struct scsi_driver ses_template = {

commit 691b4773aa556d0975dbc25c93e6c8b839dad325
Author: Yinghai Lu <Yinghai.Lu@Sun.COM>
Date:   Wed Feb 13 16:25:16 2008 -0800

    [SCSI] ses: fix data corruption
    
    one system: initrd get courrupted:
    
    RAMDISK: Compressed image found at block 0
    RAMDISK: incomplete write (-28 != 2048) 134217728
    crc error
    VFS: Mounted root (ext2 filesystem).
    Freeing unused kernel memory: 388k freed
    init_special_inode: bogus i_mode (177777)
    Warning: unable to open an initial console.
    init_special_inode: bogus i_mode (177777)
    init_special_inode: bogus i_mode (177777)
    Kernel panic - not syncing: No init found.  Try passing init= option to kernel.
    
    bisected to
    commit 9927c68864e9c39cc317b4f559309ba29e642168
    Author: James Bottomley <James.Bottomley@HansenPartnership.com>
    Date:   Sun Feb 3 15:48:56 2008 -0600
    
        [SCSI] ses: add new Enclosure ULD
    
    changes:
    1. change char to unsigned char to avoid type change later.
    2. preserve len for page1
    3. need to move desc_ptr even the entry is not enclosure_component_device/raid.
       so keep desc_ptr on right position
    4. record page7 len, and double check if desc_ptr out of boundary before touch.
    5. fix typo in subenclosure checking: should use hdr_buf instead.
    
    [jejb: style fixes]
    
    Signed-off-by: Yinghai Lu <yinghai.lu@sun.com>
    Signed-off-by: James Bottomley <James.Bottomley@HansenPartnership.com>

diff --git a/drivers/scsi/ses.c b/drivers/scsi/ses.c
index a57fed47b39d..a6d96694d0a5 100644
--- a/drivers/scsi/ses.c
+++ b/drivers/scsi/ses.c
@@ -33,9 +33,9 @@
 #include <scsi/scsi_host.h>
 
 struct ses_device {
-	char *page1;
-	char *page2;
-	char *page10;
+	unsigned char *page1;
+	unsigned char *page2;
+	unsigned char *page10;
 	short page1_len;
 	short page2_len;
 	short page10_len;
@@ -67,7 +67,7 @@ static int ses_probe(struct device *dev)
 static int ses_recv_diag(struct scsi_device *sdev, int page_code,
 			 void *buf, int bufflen)
 {
-	char cmd[] = {
+	unsigned char cmd[] = {
 		RECEIVE_DIAGNOSTIC,
 		1,		/* Set PCV bit */
 		page_code,
@@ -85,7 +85,7 @@ static int ses_send_diag(struct scsi_device *sdev, int page_code,
 {
 	u32 result;
 
-	char cmd[] = {
+	unsigned char cmd[] = {
 		SEND_DIAGNOSTIC,
 		0x10,		/* Set PF bit */
 		0,
@@ -104,13 +104,13 @@ static int ses_send_diag(struct scsi_device *sdev, int page_code,
 
 static int ses_set_page2_descriptor(struct enclosure_device *edev,
 				      struct enclosure_component *ecomp,
-				      char *desc)
+				      unsigned char *desc)
 {
 	int i, j, count = 0, descriptor = ecomp->number;
 	struct scsi_device *sdev = to_scsi_device(edev->cdev.dev);
 	struct ses_device *ses_dev = edev->scratch;
-	char *type_ptr = ses_dev->page1 + 12 + ses_dev->page1[11];
-	char *desc_ptr = ses_dev->page2 + 8;
+	unsigned char *type_ptr = ses_dev->page1 + 12 + ses_dev->page1[11];
+	unsigned char *desc_ptr = ses_dev->page2 + 8;
 
 	/* Clear everything */
 	memset(desc_ptr, 0, ses_dev->page2_len - 8);
@@ -133,14 +133,14 @@ static int ses_set_page2_descriptor(struct enclosure_device *edev,
 	return ses_send_diag(sdev, 2, ses_dev->page2, ses_dev->page2_len);
 }
 
-static char *ses_get_page2_descriptor(struct enclosure_device *edev,
+static unsigned char *ses_get_page2_descriptor(struct enclosure_device *edev,
 				      struct enclosure_component *ecomp)
 {
 	int i, j, count = 0, descriptor = ecomp->number;
 	struct scsi_device *sdev = to_scsi_device(edev->cdev.dev);
 	struct ses_device *ses_dev = edev->scratch;
-	char *type_ptr = ses_dev->page1 + 12 + ses_dev->page1[11];
-	char *desc_ptr = ses_dev->page2 + 8;
+	unsigned char *type_ptr = ses_dev->page1 + 12 + ses_dev->page1[11];
+	unsigned char *desc_ptr = ses_dev->page2 + 8;
 
 	ses_recv_diag(sdev, 2, ses_dev->page2, ses_dev->page2_len);
 
@@ -160,17 +160,18 @@ static char *ses_get_page2_descriptor(struct enclosure_device *edev,
 static void ses_get_fault(struct enclosure_device *edev,
 			  struct enclosure_component *ecomp)
 {
-	char *desc;
+	unsigned char *desc;
 
 	desc = ses_get_page2_descriptor(edev, ecomp);
-	ecomp->fault = (desc[3] & 0x60) >> 4;
+	if (desc)
+		ecomp->fault = (desc[3] & 0x60) >> 4;
 }
 
 static int ses_set_fault(struct enclosure_device *edev,
 			  struct enclosure_component *ecomp,
 			 enum enclosure_component_setting val)
 {
-	char desc[4] = {0 };
+	unsigned char desc[4] = {0 };
 
 	switch (val) {
 	case ENCLOSURE_SETTING_DISABLED:
@@ -190,26 +191,28 @@ static int ses_set_fault(struct enclosure_device *edev,
 static void ses_get_status(struct enclosure_device *edev,
 			   struct enclosure_component *ecomp)
 {
-	char *desc;
+	unsigned char *desc;
 
 	desc = ses_get_page2_descriptor(edev, ecomp);
-	ecomp->status = (desc[0] & 0x0f);
+	if (desc)
+		ecomp->status = (desc[0] & 0x0f);
 }
 
 static void ses_get_locate(struct enclosure_device *edev,
 			   struct enclosure_component *ecomp)
 {
-	char *desc;
+	unsigned char *desc;
 
 	desc = ses_get_page2_descriptor(edev, ecomp);
-	ecomp->locate = (desc[2] & 0x02) ? 1 : 0;
+	if (desc)
+		ecomp->locate = (desc[2] & 0x02) ? 1 : 0;
 }
 
 static int ses_set_locate(struct enclosure_device *edev,
 			  struct enclosure_component *ecomp,
 			  enum enclosure_component_setting val)
 {
-	char desc[4] = {0 };
+	unsigned char desc[4] = {0 };
 
 	switch (val) {
 	case ENCLOSURE_SETTING_DISABLED:
@@ -229,7 +232,7 @@ static int ses_set_active(struct enclosure_device *edev,
 			  struct enclosure_component *ecomp,
 			  enum enclosure_component_setting val)
 {
-	char desc[4] = {0 };
+	unsigned char desc[4] = {0 };
 
 	switch (val) {
 	case ENCLOSURE_SETTING_DISABLED:
@@ -409,11 +412,11 @@ static int ses_intf_add(struct class_device *cdev,
 {
 	struct scsi_device *sdev = to_scsi_device(cdev->dev);
 	struct scsi_device *tmp_sdev;
-	unsigned char *buf = NULL, *hdr_buf, *type_ptr, *desc_ptr,
-		*addl_desc_ptr;
+	unsigned char *buf = NULL, *hdr_buf, *type_ptr, *desc_ptr = NULL,
+		*addl_desc_ptr = NULL;
 	struct ses_device *ses_dev;
 	u32 result;
-	int i, j, types, len, components = 0;
+	int i, j, types, len, page7_len = 0, components = 0;
 	int err = -ENOMEM;
 	struct enclosure_device *edev;
 	struct ses_component *scomp = NULL;
@@ -447,7 +450,7 @@ static int ses_intf_add(struct class_device *cdev,
 		 * traversal routines more complex */
 		sdev_printk(KERN_ERR, sdev,
 			"FIXME driver has no support for subenclosures (%d)\n",
-			buf[1]);
+			hdr_buf[1]);
 		goto err_free;
 	}
 
@@ -461,9 +464,8 @@ static int ses_intf_add(struct class_device *cdev,
 		goto recv_failed;
 
 	types = buf[10];
-	len = buf[11];
 
-	type_ptr = buf + 12 + len;
+	type_ptr = buf + 12 + buf[11];
 
 	for (i = 0; i < types; i++, type_ptr += 4) {
 		if (type_ptr[0] == ENCLOSURE_COMPONENT_DEVICE ||
@@ -494,22 +496,21 @@ static int ses_intf_add(struct class_device *cdev,
 	/* The additional information page --- allows us
 	 * to match up the devices */
 	result = ses_recv_diag(sdev, 10, hdr_buf, INIT_ALLOC_SIZE);
-	if (result)
-		goto no_page10;
-
-	len = (hdr_buf[2] << 8) + hdr_buf[3] + 4;
-	buf = kzalloc(len, GFP_KERNEL);
-	if (!buf)
-		goto err_free;
-
-	result = ses_recv_diag(sdev, 10, buf, len);
-	if (result)
-		goto recv_failed;
-	ses_dev->page10 = buf;
-	ses_dev->page10_len = len;
-	buf = NULL;
+	if (!result) {
+
+		len = (hdr_buf[2] << 8) + hdr_buf[3] + 4;
+		buf = kzalloc(len, GFP_KERNEL);
+		if (!buf)
+			goto err_free;
+
+		result = ses_recv_diag(sdev, 10, buf, len);
+		if (result)
+			goto recv_failed;
+		ses_dev->page10 = buf;
+		ses_dev->page10_len = len;
+		buf = NULL;
+	}
 
- no_page10:
 	scomp = kzalloc(sizeof(struct ses_component) * components, GFP_KERNEL);
 	if (!scomp)
 		goto err_free;
@@ -530,7 +531,7 @@ static int ses_intf_add(struct class_device *cdev,
 	if (result)
 		goto simple_populate;
 
-	len = (hdr_buf[2] << 8) + hdr_buf[3] + 4;
+	page7_len = len = (hdr_buf[2] << 8) + hdr_buf[3] + 4;
 	/* add 1 for trailing '\0' we'll use */
 	buf = kzalloc(len + 1, GFP_KERNEL);
 	if (!buf)
@@ -547,7 +548,8 @@ static int ses_intf_add(struct class_device *cdev,
 		len = (desc_ptr[2] << 8) + desc_ptr[3];
 		/* skip past overall descriptor */
 		desc_ptr += len + 4;
-		addl_desc_ptr = ses_dev->page10 + 8;
+		if (ses_dev->page10)
+			addl_desc_ptr = ses_dev->page10 + 8;
 	}
 	type_ptr = ses_dev->page1 + 12 + ses_dev->page1[11];
 	components = 0;
@@ -557,29 +559,35 @@ static int ses_intf_add(struct class_device *cdev,
 			struct enclosure_component *ecomp;
 
 			if (desc_ptr) {
-				len = (desc_ptr[2] << 8) + desc_ptr[3];
-				desc_ptr += 4;
-				/* Add trailing zero - pushes into
-				 * reserved space */
-				desc_ptr[len] = '\0';
-				name = desc_ptr;
+				if (desc_ptr >= buf + page7_len) {
+					desc_ptr = NULL;
+				} else {
+					len = (desc_ptr[2] << 8) + desc_ptr[3];
+					desc_ptr += 4;
+					/* Add trailing zero - pushes into
+					 * reserved space */
+					desc_ptr[len] = '\0';
+					name = desc_ptr;
+				}
 			}
-			if (type_ptr[0] != ENCLOSURE_COMPONENT_DEVICE &&
-			    type_ptr[0] != ENCLOSURE_COMPONENT_ARRAY_DEVICE)
-				continue;
-			ecomp =	enclosure_component_register(edev,
+			if (type_ptr[0] == ENCLOSURE_COMPONENT_DEVICE ||
+			    type_ptr[0] == ENCLOSURE_COMPONENT_ARRAY_DEVICE) {
+
+				ecomp =	enclosure_component_register(edev,
 							     components++,
 							     type_ptr[0],
 							     name);
-			if (desc_ptr) {
-				desc_ptr += len;
-				if (!IS_ERR(ecomp))
+
+				if (!IS_ERR(ecomp) && addl_desc_ptr)
 					ses_process_descriptor(ecomp,
 							       addl_desc_ptr);
-
-				if (addl_desc_ptr)
-					addl_desc_ptr += addl_desc_ptr[1] + 2;
 			}
+			if (desc_ptr)
+				desc_ptr += len;
+
+			if (addl_desc_ptr)
+				addl_desc_ptr += addl_desc_ptr[1] + 2;
+
 		}
 	}
 	kfree(buf);

commit 7c46c20aef185c3782d28c5111dcf1df88bbab32
Author: Yinghai Lu <yinghai.lu@sun.com>
Date:   Sun Feb 10 23:25:25 2008 -0800

    [SCSI] ses: fix memory leaks
    
    fix leaking with scomp leaking when failing. Also free page10 on
    driver removal and remove one extra space.
    
    Signed-off-by: Yinghai Lu <yinghai.lu@sun.com>
    Signed-off-by: James Bottomley <James.Bottomley@HansenPartnership.com>

diff --git a/drivers/scsi/ses.c b/drivers/scsi/ses.c
index 2a6e4f472eaa..a57fed47b39d 100644
--- a/drivers/scsi/ses.c
+++ b/drivers/scsi/ses.c
@@ -416,11 +416,11 @@ static int ses_intf_add(struct class_device *cdev,
 	int i, j, types, len, components = 0;
 	int err = -ENOMEM;
 	struct enclosure_device *edev;
-	struct ses_component *scomp;
+	struct ses_component *scomp = NULL;
 
 	if (!scsi_device_enclosure(sdev)) {
 		/* not an enclosure, but might be in one */
-		edev = 	enclosure_find(&sdev->host->shost_gendev);
+		edev = enclosure_find(&sdev->host->shost_gendev);
 		if (edev) {
 			ses_match_to_enclosure(edev, sdev);
 			class_device_put(&edev->cdev);
@@ -456,9 +456,6 @@ static int ses_intf_add(struct class_device *cdev,
 	if (!buf)
 		goto err_free;
 
-	ses_dev->page1 = buf;
-	ses_dev->page1_len = len;
-
 	result = ses_recv_diag(sdev, 1, buf, len);
 	if (result)
 		goto recv_failed;
@@ -473,6 +470,9 @@ static int ses_intf_add(struct class_device *cdev,
 		    type_ptr[0] == ENCLOSURE_COMPONENT_ARRAY_DEVICE)
 			components += type_ptr[1];
 	}
+	ses_dev->page1 = buf;
+	ses_dev->page1_len = len;
+	buf = NULL;
 
 	result = ses_recv_diag(sdev, 2, hdr_buf, INIT_ALLOC_SIZE);
 	if (result)
@@ -489,6 +489,7 @@ static int ses_intf_add(struct class_device *cdev,
 		goto recv_failed;
 	ses_dev->page2 = buf;
 	ses_dev->page2_len = len;
+	buf = NULL;
 
 	/* The additional information page --- allows us
 	 * to match up the devices */
@@ -506,11 +507,12 @@ static int ses_intf_add(struct class_device *cdev,
 		goto recv_failed;
 	ses_dev->page10 = buf;
 	ses_dev->page10_len = len;
+	buf = NULL;
 
  no_page10:
-	scomp = kmalloc(sizeof(struct ses_component) * components, GFP_KERNEL);
+	scomp = kzalloc(sizeof(struct ses_component) * components, GFP_KERNEL);
 	if (!scomp)
-		goto  err_free;
+		goto err_free;
 
 	edev = enclosure_register(cdev->dev, sdev->sdev_gendev.bus_id,
 				  components, &ses_enclosure_callbacks);
@@ -521,10 +523,9 @@ static int ses_intf_add(struct class_device *cdev,
 
 	edev->scratch = ses_dev;
 	for (i = 0; i < components; i++)
-		edev->component[i].scratch = scomp++;
+		edev->component[i].scratch = scomp + i;
 
 	/* Page 7 for the descriptors is optional */
-	buf = NULL;
 	result = ses_recv_diag(sdev, 7, hdr_buf, INIT_ALLOC_SIZE);
 	if (result)
 		goto simple_populate;
@@ -532,6 +533,8 @@ static int ses_intf_add(struct class_device *cdev,
 	len = (hdr_buf[2] << 8) + hdr_buf[3] + 4;
 	/* add 1 for trailing '\0' we'll use */
 	buf = kzalloc(len + 1, GFP_KERNEL);
+	if (!buf)
+		goto simple_populate;
 	result = ses_recv_diag(sdev, 7, buf, len);
 	if (result) {
  simple_populate:
@@ -598,6 +601,7 @@ static int ses_intf_add(struct class_device *cdev,
 	err = -ENODEV;
  err_free:
 	kfree(buf);
+	kfree(scomp);
 	kfree(ses_dev->page10);
 	kfree(ses_dev->page2);
 	kfree(ses_dev->page1);
@@ -630,6 +634,7 @@ static void ses_intf_remove(struct class_device *cdev,
 	ses_dev = edev->scratch;
 	edev->scratch = NULL;
 
+	kfree(ses_dev->page10);
 	kfree(ses_dev->page1);
 	kfree(ses_dev->page2);
 	kfree(ses_dev);

commit 9927c68864e9c39cc317b4f559309ba29e642168
Author: James Bottomley <James.Bottomley@HansenPartnership.com>
Date:   Sun Feb 3 15:48:56 2008 -0600

    [SCSI] ses: add new Enclosure ULD
    
    This adds support to SCSI for enclosure services devices. It also makes
    use of the enclosure services added in an earlier patch to display the
    enclosure topology in sysfs.
    
    At the moment, the enclosures are SAS specific, but if anyone actually
    has a non-SAS enclosure that follows the SES-2 standard, we can add that
    as well.
    
    On my Vitesse based system, the enclosures show up like this:
    
    sparkweed:~# ls -l /sys/class/enclosure/0\:0\:1\:0/
    total 0
    -r--r--r-- 1 root root 4096 2008-02-03 15:44 components
    lrwxrwxrwx 1 root root    0 2008-02-03 15:44 device -> ../../../devices/pci0000:01/0000:01:02.0/host0/port-0:0/expander-0:0/port-0:0:12/end_device-0:0:12/target0:0:1/0:0:1:0
    drwxr-xr-x 2 root root    0 2008-02-03 15:44 SLOT 000
    drwxr-xr-x 2 root root    0 2008-02-03 15:44 SLOT 001
    drwxr-xr-x 2 root root    0 2008-02-03 15:44 SLOT 002
    drwxr-xr-x 2 root root    0 2008-02-03 15:44 SLOT 003
    drwxr-xr-x 2 root root    0 2008-02-03 15:44 SLOT 004
    drwxr-xr-x 2 root root    0 2008-02-03 15:44 SLOT 005
    lrwxrwxrwx 1 root root    0 2008-02-03 15:44 subsystem -> ../../enclosure
    --w------- 1 root root 4096 2008-02-03 15:44 uevent
    
    And the individual occupied slots like this:
    
    sparkweed:~# ls -l /sys/class/enclosure/0\:0\:1\:0/SLOT\ 001/
    total 0
    -rw-r--r-- 1 root root 4096 2008-02-03 15:45 active
    lrwxrwxrwx 1 root root    0 2008-02-03 15:45 device -> ../../../../devices/pci0000:01/0000:01:02.0/host0/port-0:0/expander-0:0/port-0:0:11/end_device-0:0:11/target0:0:0/0:0:0:0
    -rw-r--r-- 1 root root 4096 2008-02-03 15:45 fault
    -rw-r--r-- 1 root root 4096 2008-02-03 15:45 locate
    -rw-r--r-- 1 root root 4096 2008-02-03 15:45 status
    lrwxrwxrwx 1 root root    0 2008-02-03 15:45 subsystem -> ../../../enclosure_component
    -r--r--r-- 1 root root 4096 2008-02-03 15:45 type
    --w------- 1 root root 4096 2008-02-03 15:45 uevent
    
    You can flash the various blinky lights by echoing to the fault and locate files.
    
    >From the device's point of view, you can see it has an enclosure like this:
    
    sparkweed:~# ls /sys/class/scsi_disk/0\:0\:0\:0/device/
    block:sda                     generic        queue_depth          state
    bsg:0:0:0:0                   iocounterbits  queue_type           subsystem
    bus                           iodone_cnt     rescan               timeout
    delete                        ioerr_cnt      rev                  type
    device_blocked                iorequest_cnt  scsi_device:0:0:0:0  uevent
    driver                        modalias       scsi_disk:0:0:0:0    vendor
    enclosure_component:SLOT 001  model          scsi_generic:sg0
    evt_media_change              power          scsi_level
    
    Note the enclosure_component:SLOT 001 which shows where in the enclosure
    this device fits.
    
    The astute will notice that I'm using SCSI VPD Inquiries to identify the
    devices.  This, unfortunately, won't work for SATA devices unless we do
    some really nasty hacking about on the SAT because the only think that
    knows the SAS addresses for SATA devices is libsas, not libata where the
    SAT resides.
    
    Signed-off-by: James Bottomley <James.Bottomley@HansenPartnership.com>

diff --git a/drivers/scsi/ses.c b/drivers/scsi/ses.c
new file mode 100644
index 000000000000..2a6e4f472eaa
--- /dev/null
+++ b/drivers/scsi/ses.c
@@ -0,0 +1,689 @@
+/*
+ * SCSI Enclosure Services
+ *
+ * Copyright (C) 2008 James Bottomley <James.Bottomley@HansenPartnership.com>
+ *
+**-----------------------------------------------------------------------------
+**
+**  This program is free software; you can redistribute it and/or
+**  modify it under the terms of the GNU General Public License
+**  version 2 as published by the Free Software Foundation.
+**
+**  This program is distributed in the hope that it will be useful,
+**  but WITHOUT ANY WARRANTY; without even the implied warranty of
+**  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+**  GNU General Public License for more details.
+**
+**  You should have received a copy of the GNU General Public License
+**  along with this program; if not, write to the Free Software
+**  Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+**
+**-----------------------------------------------------------------------------
+*/
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/enclosure.h>
+
+#include <scsi/scsi.h>
+#include <scsi/scsi_cmnd.h>
+#include <scsi/scsi_dbg.h>
+#include <scsi/scsi_device.h>
+#include <scsi/scsi_driver.h>
+#include <scsi/scsi_host.h>
+
+struct ses_device {
+	char *page1;
+	char *page2;
+	char *page10;
+	short page1_len;
+	short page2_len;
+	short page10_len;
+};
+
+struct ses_component {
+	u64 addr;
+	unsigned char *desc;
+};
+
+static int ses_probe(struct device *dev)
+{
+	struct scsi_device *sdev = to_scsi_device(dev);
+	int err = -ENODEV;
+
+	if (sdev->type != TYPE_ENCLOSURE)
+		goto out;
+
+	err = 0;
+	sdev_printk(KERN_NOTICE, sdev, "Attached Enclosure device\n");
+
+ out:
+	return err;
+}
+
+#define SES_TIMEOUT 30
+#define SES_RETRIES 3
+
+static int ses_recv_diag(struct scsi_device *sdev, int page_code,
+			 void *buf, int bufflen)
+{
+	char cmd[] = {
+		RECEIVE_DIAGNOSTIC,
+		1,		/* Set PCV bit */
+		page_code,
+		bufflen >> 8,
+		bufflen & 0xff,
+		0
+	};
+
+	return scsi_execute_req(sdev, cmd, DMA_FROM_DEVICE, buf, bufflen,
+				NULL, SES_TIMEOUT, SES_RETRIES);
+}
+
+static int ses_send_diag(struct scsi_device *sdev, int page_code,
+			 void *buf, int bufflen)
+{
+	u32 result;
+
+	char cmd[] = {
+		SEND_DIAGNOSTIC,
+		0x10,		/* Set PF bit */
+		0,
+		bufflen >> 8,
+		bufflen & 0xff,
+		0
+	};
+
+	result = scsi_execute_req(sdev, cmd, DMA_TO_DEVICE, buf, bufflen,
+				  NULL, SES_TIMEOUT, SES_RETRIES);
+	if (result)
+		sdev_printk(KERN_ERR, sdev, "SEND DIAGNOSTIC result: %8x\n",
+			    result);
+	return result;
+}
+
+static int ses_set_page2_descriptor(struct enclosure_device *edev,
+				      struct enclosure_component *ecomp,
+				      char *desc)
+{
+	int i, j, count = 0, descriptor = ecomp->number;
+	struct scsi_device *sdev = to_scsi_device(edev->cdev.dev);
+	struct ses_device *ses_dev = edev->scratch;
+	char *type_ptr = ses_dev->page1 + 12 + ses_dev->page1[11];
+	char *desc_ptr = ses_dev->page2 + 8;
+
+	/* Clear everything */
+	memset(desc_ptr, 0, ses_dev->page2_len - 8);
+	for (i = 0; i < ses_dev->page1[10]; i++, type_ptr += 4) {
+		for (j = 0; j < type_ptr[1]; j++) {
+			desc_ptr += 4;
+			if (type_ptr[0] != ENCLOSURE_COMPONENT_DEVICE &&
+			    type_ptr[0] != ENCLOSURE_COMPONENT_ARRAY_DEVICE)
+				continue;
+			if (count++ == descriptor) {
+				memcpy(desc_ptr, desc, 4);
+				/* set select */
+				desc_ptr[0] |= 0x80;
+				/* clear reserved, just in case */
+				desc_ptr[0] &= 0xf0;
+			}
+		}
+	}
+
+	return ses_send_diag(sdev, 2, ses_dev->page2, ses_dev->page2_len);
+}
+
+static char *ses_get_page2_descriptor(struct enclosure_device *edev,
+				      struct enclosure_component *ecomp)
+{
+	int i, j, count = 0, descriptor = ecomp->number;
+	struct scsi_device *sdev = to_scsi_device(edev->cdev.dev);
+	struct ses_device *ses_dev = edev->scratch;
+	char *type_ptr = ses_dev->page1 + 12 + ses_dev->page1[11];
+	char *desc_ptr = ses_dev->page2 + 8;
+
+	ses_recv_diag(sdev, 2, ses_dev->page2, ses_dev->page2_len);
+
+	for (i = 0; i < ses_dev->page1[10]; i++, type_ptr += 4) {
+		for (j = 0; j < type_ptr[1]; j++) {
+			desc_ptr += 4;
+			if (type_ptr[0] != ENCLOSURE_COMPONENT_DEVICE &&
+			    type_ptr[0] != ENCLOSURE_COMPONENT_ARRAY_DEVICE)
+				continue;
+			if (count++ == descriptor)
+				return desc_ptr;
+		}
+	}
+	return NULL;
+}
+
+static void ses_get_fault(struct enclosure_device *edev,
+			  struct enclosure_component *ecomp)
+{
+	char *desc;
+
+	desc = ses_get_page2_descriptor(edev, ecomp);
+	ecomp->fault = (desc[3] & 0x60) >> 4;
+}
+
+static int ses_set_fault(struct enclosure_device *edev,
+			  struct enclosure_component *ecomp,
+			 enum enclosure_component_setting val)
+{
+	char desc[4] = {0 };
+
+	switch (val) {
+	case ENCLOSURE_SETTING_DISABLED:
+		/* zero is disabled */
+		break;
+	case ENCLOSURE_SETTING_ENABLED:
+		desc[2] = 0x02;
+		break;
+	default:
+		/* SES doesn't do the SGPIO blink settings */
+		return -EINVAL;
+	}
+
+	return ses_set_page2_descriptor(edev, ecomp, desc);
+}
+
+static void ses_get_status(struct enclosure_device *edev,
+			   struct enclosure_component *ecomp)
+{
+	char *desc;
+
+	desc = ses_get_page2_descriptor(edev, ecomp);
+	ecomp->status = (desc[0] & 0x0f);
+}
+
+static void ses_get_locate(struct enclosure_device *edev,
+			   struct enclosure_component *ecomp)
+{
+	char *desc;
+
+	desc = ses_get_page2_descriptor(edev, ecomp);
+	ecomp->locate = (desc[2] & 0x02) ? 1 : 0;
+}
+
+static int ses_set_locate(struct enclosure_device *edev,
+			  struct enclosure_component *ecomp,
+			  enum enclosure_component_setting val)
+{
+	char desc[4] = {0 };
+
+	switch (val) {
+	case ENCLOSURE_SETTING_DISABLED:
+		/* zero is disabled */
+		break;
+	case ENCLOSURE_SETTING_ENABLED:
+		desc[2] = 0x02;
+		break;
+	default:
+		/* SES doesn't do the SGPIO blink settings */
+		return -EINVAL;
+	}
+	return ses_set_page2_descriptor(edev, ecomp, desc);
+}
+
+static int ses_set_active(struct enclosure_device *edev,
+			  struct enclosure_component *ecomp,
+			  enum enclosure_component_setting val)
+{
+	char desc[4] = {0 };
+
+	switch (val) {
+	case ENCLOSURE_SETTING_DISABLED:
+		/* zero is disabled */
+		ecomp->active = 0;
+		break;
+	case ENCLOSURE_SETTING_ENABLED:
+		desc[2] = 0x80;
+		ecomp->active = 1;
+		break;
+	default:
+		/* SES doesn't do the SGPIO blink settings */
+		return -EINVAL;
+	}
+	return ses_set_page2_descriptor(edev, ecomp, desc);
+}
+
+static struct enclosure_component_callbacks ses_enclosure_callbacks = {
+	.get_fault		= ses_get_fault,
+	.set_fault		= ses_set_fault,
+	.get_status		= ses_get_status,
+	.get_locate		= ses_get_locate,
+	.set_locate		= ses_set_locate,
+	.set_active		= ses_set_active,
+};
+
+struct ses_host_edev {
+	struct Scsi_Host *shost;
+	struct enclosure_device *edev;
+};
+
+int ses_match_host(struct enclosure_device *edev, void *data)
+{
+	struct ses_host_edev *sed = data;
+	struct scsi_device *sdev;
+
+	if (!scsi_is_sdev_device(edev->cdev.dev))
+		return 0;
+
+	sdev = to_scsi_device(edev->cdev.dev);
+
+	if (sdev->host != sed->shost)
+		return 0;
+
+	sed->edev = edev;
+	return 1;
+}
+
+static void ses_process_descriptor(struct enclosure_component *ecomp,
+				   unsigned char *desc)
+{
+	int eip = desc[0] & 0x10;
+	int invalid = desc[0] & 0x80;
+	enum scsi_protocol proto = desc[0] & 0x0f;
+	u64 addr = 0;
+	struct ses_component *scomp = ecomp->scratch;
+	unsigned char *d;
+
+	scomp->desc = desc;
+
+	if (invalid)
+		return;
+
+	switch (proto) {
+	case SCSI_PROTOCOL_SAS:
+		if (eip)
+			d = desc + 8;
+		else
+			d = desc + 4;
+		/* only take the phy0 addr */
+		addr = (u64)d[12] << 56 |
+			(u64)d[13] << 48 |
+			(u64)d[14] << 40 |
+			(u64)d[15] << 32 |
+			(u64)d[16] << 24 |
+			(u64)d[17] << 16 |
+			(u64)d[18] << 8 |
+			(u64)d[19];
+		break;
+	default:
+		/* FIXME: Need to add more protocols than just SAS */
+		break;
+	}
+	scomp->addr = addr;
+}
+
+struct efd {
+	u64 addr;
+	struct device *dev;
+};
+
+static int ses_enclosure_find_by_addr(struct enclosure_device *edev,
+				      void *data)
+{
+	struct efd *efd = data;
+	int i;
+	struct ses_component *scomp;
+
+	if (!edev->component[0].scratch)
+		return 0;
+
+	for (i = 0; i < edev->components; i++) {
+		scomp = edev->component[i].scratch;
+		if (scomp->addr != efd->addr)
+			continue;
+
+		enclosure_add_device(edev, i, efd->dev);
+		return 1;
+	}
+	return 0;
+}
+
+#define VPD_INQUIRY_SIZE 512
+
+static void ses_match_to_enclosure(struct enclosure_device *edev,
+				   struct scsi_device *sdev)
+{
+	unsigned char *buf = kmalloc(VPD_INQUIRY_SIZE, GFP_KERNEL);
+	unsigned char *desc;
+	int len;
+	struct efd efd = {
+		.addr = 0,
+	};
+	unsigned char cmd[] = {
+		INQUIRY,
+		1,
+		0x83,
+		VPD_INQUIRY_SIZE >> 8,
+		VPD_INQUIRY_SIZE & 0xff,
+		0
+	};
+
+	if (!buf)
+		return;
+
+	if (scsi_execute_req(sdev, cmd, DMA_FROM_DEVICE, buf,
+			     VPD_INQUIRY_SIZE, NULL, SES_TIMEOUT, SES_RETRIES))
+		goto free;
+
+	len = (buf[2] << 8) + buf[3];
+	desc = buf + 4;
+	while (desc < buf + len) {
+		enum scsi_protocol proto = desc[0] >> 4;
+		u8 code_set = desc[0] & 0x0f;
+		u8 piv = desc[1] & 0x80;
+		u8 assoc = (desc[1] & 0x30) >> 4;
+		u8 type = desc[1] & 0x0f;
+		u8 len = desc[3];
+
+		if (piv && code_set == 1 && assoc == 1 && code_set == 1
+		    && proto == SCSI_PROTOCOL_SAS && type == 3 && len == 8)
+			efd.addr = (u64)desc[4] << 56 |
+				(u64)desc[5] << 48 |
+				(u64)desc[6] << 40 |
+				(u64)desc[7] << 32 |
+				(u64)desc[8] << 24 |
+				(u64)desc[9] << 16 |
+				(u64)desc[10] << 8 |
+				(u64)desc[11];
+
+		desc += len + 4;
+	}
+	if (!efd.addr)
+		goto free;
+
+	efd.dev = &sdev->sdev_gendev;
+
+	enclosure_for_each_device(ses_enclosure_find_by_addr, &efd);
+ free:
+	kfree(buf);
+}
+
+#define INIT_ALLOC_SIZE 32
+
+static int ses_intf_add(struct class_device *cdev,
+			struct class_interface *intf)
+{
+	struct scsi_device *sdev = to_scsi_device(cdev->dev);
+	struct scsi_device *tmp_sdev;
+	unsigned char *buf = NULL, *hdr_buf, *type_ptr, *desc_ptr,
+		*addl_desc_ptr;
+	struct ses_device *ses_dev;
+	u32 result;
+	int i, j, types, len, components = 0;
+	int err = -ENOMEM;
+	struct enclosure_device *edev;
+	struct ses_component *scomp;
+
+	if (!scsi_device_enclosure(sdev)) {
+		/* not an enclosure, but might be in one */
+		edev = 	enclosure_find(&sdev->host->shost_gendev);
+		if (edev) {
+			ses_match_to_enclosure(edev, sdev);
+			class_device_put(&edev->cdev);
+		}
+		return -ENODEV;
+	}
+
+	/* TYPE_ENCLOSURE prints a message in probe */
+	if (sdev->type != TYPE_ENCLOSURE)
+		sdev_printk(KERN_NOTICE, sdev, "Embedded Enclosure Device\n");
+
+	ses_dev = kzalloc(sizeof(*ses_dev), GFP_KERNEL);
+	hdr_buf = kzalloc(INIT_ALLOC_SIZE, GFP_KERNEL);
+	if (!hdr_buf || !ses_dev)
+		goto err_init_free;
+
+	result = ses_recv_diag(sdev, 1, hdr_buf, INIT_ALLOC_SIZE);
+	if (result)
+		goto recv_failed;
+
+	if (hdr_buf[1] != 0) {
+		/* FIXME: need subenclosure support; I've just never
+		 * seen a device with subenclosures and it makes the
+		 * traversal routines more complex */
+		sdev_printk(KERN_ERR, sdev,
+			"FIXME driver has no support for subenclosures (%d)\n",
+			buf[1]);
+		goto err_free;
+	}
+
+	len = (hdr_buf[2] << 8) + hdr_buf[3] + 4;
+	buf = kzalloc(len, GFP_KERNEL);
+	if (!buf)
+		goto err_free;
+
+	ses_dev->page1 = buf;
+	ses_dev->page1_len = len;
+
+	result = ses_recv_diag(sdev, 1, buf, len);
+	if (result)
+		goto recv_failed;
+
+	types = buf[10];
+	len = buf[11];
+
+	type_ptr = buf + 12 + len;
+
+	for (i = 0; i < types; i++, type_ptr += 4) {
+		if (type_ptr[0] == ENCLOSURE_COMPONENT_DEVICE ||
+		    type_ptr[0] == ENCLOSURE_COMPONENT_ARRAY_DEVICE)
+			components += type_ptr[1];
+	}
+
+	result = ses_recv_diag(sdev, 2, hdr_buf, INIT_ALLOC_SIZE);
+	if (result)
+		goto recv_failed;
+
+	len = (hdr_buf[2] << 8) + hdr_buf[3] + 4;
+	buf = kzalloc(len, GFP_KERNEL);
+	if (!buf)
+		goto err_free;
+
+	/* make sure getting page 2 actually works */
+	result = ses_recv_diag(sdev, 2, buf, len);
+	if (result)
+		goto recv_failed;
+	ses_dev->page2 = buf;
+	ses_dev->page2_len = len;
+
+	/* The additional information page --- allows us
+	 * to match up the devices */
+	result = ses_recv_diag(sdev, 10, hdr_buf, INIT_ALLOC_SIZE);
+	if (result)
+		goto no_page10;
+
+	len = (hdr_buf[2] << 8) + hdr_buf[3] + 4;
+	buf = kzalloc(len, GFP_KERNEL);
+	if (!buf)
+		goto err_free;
+
+	result = ses_recv_diag(sdev, 10, buf, len);
+	if (result)
+		goto recv_failed;
+	ses_dev->page10 = buf;
+	ses_dev->page10_len = len;
+
+ no_page10:
+	scomp = kmalloc(sizeof(struct ses_component) * components, GFP_KERNEL);
+	if (!scomp)
+		goto  err_free;
+
+	edev = enclosure_register(cdev->dev, sdev->sdev_gendev.bus_id,
+				  components, &ses_enclosure_callbacks);
+	if (IS_ERR(edev)) {
+		err = PTR_ERR(edev);
+		goto err_free;
+	}
+
+	edev->scratch = ses_dev;
+	for (i = 0; i < components; i++)
+		edev->component[i].scratch = scomp++;
+
+	/* Page 7 for the descriptors is optional */
+	buf = NULL;
+	result = ses_recv_diag(sdev, 7, hdr_buf, INIT_ALLOC_SIZE);
+	if (result)
+		goto simple_populate;
+
+	len = (hdr_buf[2] << 8) + hdr_buf[3] + 4;
+	/* add 1 for trailing '\0' we'll use */
+	buf = kzalloc(len + 1, GFP_KERNEL);
+	result = ses_recv_diag(sdev, 7, buf, len);
+	if (result) {
+ simple_populate:
+		kfree(buf);
+		buf = NULL;
+		desc_ptr = NULL;
+		addl_desc_ptr = NULL;
+	} else {
+		desc_ptr = buf + 8;
+		len = (desc_ptr[2] << 8) + desc_ptr[3];
+		/* skip past overall descriptor */
+		desc_ptr += len + 4;
+		addl_desc_ptr = ses_dev->page10 + 8;
+	}
+	type_ptr = ses_dev->page1 + 12 + ses_dev->page1[11];
+	components = 0;
+	for (i = 0; i < types; i++, type_ptr += 4) {
+		for (j = 0; j < type_ptr[1]; j++) {
+			char *name = NULL;
+			struct enclosure_component *ecomp;
+
+			if (desc_ptr) {
+				len = (desc_ptr[2] << 8) + desc_ptr[3];
+				desc_ptr += 4;
+				/* Add trailing zero - pushes into
+				 * reserved space */
+				desc_ptr[len] = '\0';
+				name = desc_ptr;
+			}
+			if (type_ptr[0] != ENCLOSURE_COMPONENT_DEVICE &&
+			    type_ptr[0] != ENCLOSURE_COMPONENT_ARRAY_DEVICE)
+				continue;
+			ecomp =	enclosure_component_register(edev,
+							     components++,
+							     type_ptr[0],
+							     name);
+			if (desc_ptr) {
+				desc_ptr += len;
+				if (!IS_ERR(ecomp))
+					ses_process_descriptor(ecomp,
+							       addl_desc_ptr);
+
+				if (addl_desc_ptr)
+					addl_desc_ptr += addl_desc_ptr[1] + 2;
+			}
+		}
+	}
+	kfree(buf);
+	kfree(hdr_buf);
+
+	/* see if there are any devices matching before
+	 * we found the enclosure */
+	shost_for_each_device(tmp_sdev, sdev->host) {
+		if (tmp_sdev->lun != 0 || scsi_device_enclosure(tmp_sdev))
+			continue;
+		ses_match_to_enclosure(edev, tmp_sdev);
+	}
+
+	return 0;
+
+ recv_failed:
+	sdev_printk(KERN_ERR, sdev, "Failed to get diagnostic page 0x%x\n",
+		    result);
+	err = -ENODEV;
+ err_free:
+	kfree(buf);
+	kfree(ses_dev->page10);
+	kfree(ses_dev->page2);
+	kfree(ses_dev->page1);
+ err_init_free:
+	kfree(ses_dev);
+	kfree(hdr_buf);
+	sdev_printk(KERN_ERR, sdev, "Failed to bind enclosure %d\n", err);
+	return err;
+}
+
+static int ses_remove(struct device *dev)
+{
+	return 0;
+}
+
+static void ses_intf_remove(struct class_device *cdev,
+			    struct class_interface *intf)
+{
+	struct scsi_device *sdev = to_scsi_device(cdev->dev);
+	struct enclosure_device *edev;
+	struct ses_device *ses_dev;
+
+	if (!scsi_device_enclosure(sdev))
+		return;
+
+	edev = enclosure_find(cdev->dev);
+	if (!edev)
+		return;
+
+	ses_dev = edev->scratch;
+	edev->scratch = NULL;
+
+	kfree(ses_dev->page1);
+	kfree(ses_dev->page2);
+	kfree(ses_dev);
+
+	kfree(edev->component[0].scratch);
+
+	class_device_put(&edev->cdev);
+	enclosure_unregister(edev);
+}
+
+static struct class_interface ses_interface = {
+	.add	= ses_intf_add,
+	.remove	= ses_intf_remove,
+};
+
+static struct scsi_driver ses_template = {
+	.owner			= THIS_MODULE,
+	.gendrv = {
+		.name		= "ses",
+		.probe		= ses_probe,
+		.remove		= ses_remove,
+	},
+};
+
+static int __init ses_init(void)
+{
+	int err;
+
+	err = scsi_register_interface(&ses_interface);
+	if (err)
+		return err;
+
+	err = scsi_register_driver(&ses_template.gendrv);
+	if (err)
+		goto out_unreg;
+
+	return 0;
+
+ out_unreg:
+	scsi_unregister_interface(&ses_interface);
+	return err;
+}
+
+static void __exit ses_exit(void)
+{
+	scsi_unregister_driver(&ses_template.gendrv);
+	scsi_unregister_interface(&ses_interface);
+}
+
+module_init(ses_init);
+module_exit(ses_exit);
+
+MODULE_ALIAS_SCSI_DEVICE(TYPE_ENCLOSURE);
+
+MODULE_AUTHOR("James Bottomley");
+MODULE_DESCRIPTION("SCSI Enclosure Services (ses) driver");
+MODULE_LICENSE("GPL v2");
