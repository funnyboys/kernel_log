commit 79172ab20bfd8437b277254028efdb68484e2c21
Author: Finn Thain <fthain@telegraphics.com.au>
Date:   Sat Nov 2 12:06:54 2019 +1100

    scsi: atari_scsi: sun3_scsi: Set sg_tablesize to 1 instead of SG_NONE
    
    Since the scsi subsystem adopted the blk-mq API, a host with zero
    sg_tablesize crashes with a NULL pointer dereference.
    
    blk_queue_max_segments: set to minimum 1
    scsi 0:0:0:0: Direct-Access     QEMU     QEMU HARDDISK    2.5+ PQ: 0 ANSI: 5
    scsi target0:0:0: Beginning Domain Validation
    scsi target0:0:0: Domain Validation skipping write tests
    scsi target0:0:0: Ending Domain Validation
    blk_queue_max_segments: set to minimum 1
    scsi 0:0:1:0: Direct-Access     QEMU     QEMU HARDDISK    2.5+ PQ: 0 ANSI: 5
    scsi target0:0:1: Beginning Domain Validation
    scsi target0:0:1: Domain Validation skipping write tests
    scsi target0:0:1: Ending Domain Validation
    blk_queue_max_segments: set to minimum 1
    scsi 0:0:2:0: CD-ROM            QEMU     QEMU CD-ROM      2.5+ PQ: 0 ANSI: 5
    scsi target0:0:2: Beginning Domain Validation
    scsi target0:0:2: Domain Validation skipping write tests
    scsi target0:0:2: Ending Domain Validation
    blk_queue_max_segments: set to minimum 1
    blk_queue_max_segments: set to minimum 1
    blk_queue_max_segments: set to minimum 1
    blk_queue_max_segments: set to minimum 1
    sr 0:0:2:0: Power-on or device reset occurred
    sd 0:0:0:0: Power-on or device reset occurred
    sd 0:0:1:0: Power-on or device reset occurred
    sd 0:0:0:0: [sda] 10485762 512-byte logical blocks: (5.37 GB/5.00 GiB)
    sd 0:0:0:0: [sda] Write Protect is off
    sd 0:0:0:0: [sda] Write cache: enabled, read cache: enabled, doesn't support DPO or FUA
    Unable to handle kernel NULL pointer dereference at virtual address (ptrval)
    Oops: 00000000
    Modules linked in:
    PC: [<001cd874>] blk_mq_free_request+0x66/0xe2
    SR: 2004  SP: (ptrval)  a2: 00874520
    d0: 00000000    d1: 00000000    d2: 009ba800    d3: 00000000
    d4: 00000000    d5: 08000002    a0: 0087be68    a1: 009a81e0
    Process kworker/u2:2 (pid: 15, task=(ptrval))
    Frame format=7 eff addr=0000007a ssw=0505 faddr=0000007a
    wb 1 stat/addr/data: 0000 00000000 00000000
    wb 2 stat/addr/data: 0000 00000000 00000000
    wb 3 stat/addr/data: 0000 0000007a 00000000
    push data: 00000000 00000000 00000000 00000000
    Stack from 0087bd98:
            00000002 00000000 0087be72 009a7820 0087bdb4 001c4f6c 009a7820 0087bdd4
            0024d200 009a7820 0024d0dc 0087be72 009baa00 0087be68 009a5000 0087be7c
            00265d10 009a5000 0087be72 00000003 00000000 00000000 00000000 0087be68
            00000bb8 00000005 00000000 00000000 00000000 00000000 00265c56 00000000
            009ba60c 0036ddf4 00000002 ffffffff 009baa00 009ba600 009a50d6 0087be74
            00227ba0 009baa08 00000001 009baa08 009ba60c 0036ddf4 00000000 00000000
    Call Trace: [<001c4f6c>] blk_put_request+0xe/0x14
     [<0024d200>] __scsi_execute+0x124/0x174
     [<0024d0dc>] __scsi_execute+0x0/0x174
     [<00265d10>] sd_revalidate_disk+0xba/0x1f02
     [<00265c56>] sd_revalidate_disk+0x0/0x1f02
     [<0036ddf4>] strlen+0x0/0x22
     [<00227ba0>] device_add+0x3da/0x604
     [<0036ddf4>] strlen+0x0/0x22
     [<00267e64>] sd_probe+0x30c/0x4b4
     [<0002da44>] process_one_work+0x0/0x402
     [<0022b978>] really_probe+0x226/0x354
     [<0022bc34>] driver_probe_device+0xa4/0xf0
     [<0002da44>] process_one_work+0x0/0x402
     [<0022bcd0>] __driver_attach_async_helper+0x50/0x70
     [<00035dae>] async_run_entry_fn+0x36/0x130
     [<0002db88>] process_one_work+0x144/0x402
     [<0002e1aa>] worker_thread+0x0/0x570
     [<0002e29a>] worker_thread+0xf0/0x570
     [<0002e1aa>] worker_thread+0x0/0x570
     [<003768d8>] schedule+0x0/0xb8
     [<0003f58c>] __init_waitqueue_head+0x0/0x12
     [<00033e92>] kthread+0xc2/0xf6
     [<000331e8>] kthread_parkme+0x0/0x4e
     [<003768d8>] schedule+0x0/0xb8
     [<00033dd0>] kthread+0x0/0xf6
     [<00002c10>] ret_from_kernel_thread+0xc/0x14
    Code: 0280 0006 0800 56c0 4400 0280 0000 00ff <52b4> 0c3a 082b 0006 0013 6706 2042 53a8 00c4 4ab9 0047 3374 6640 202d 000c 670c
    Disabling lock debugging due to kernel taint
    
    Avoid this by setting sg_tablesize = 1.
    
    Link: https://lore.kernel.org/r/4567bcae94523b47d6f3b77450ba305823bca479.1572656814.git.fthain@telegraphics.com.au
    Reported-and-tested-by: Michael Schmitz <schmitzmic@gmail.com>
    Reviewed-by: Michael Schmitz <schmitzmic@gmail.com>
    References: commit 68ab2d76e4be ("scsi: cxlflash: Set sg_tablesize to 1 instead of SG_NONE")
    Signed-off-by: Finn Thain <fthain@telegraphics.com.au>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/atari_scsi.c b/drivers/scsi/atari_scsi.c
index e809493d0d06..a82b63a66635 100644
--- a/drivers/scsi/atari_scsi.c
+++ b/drivers/scsi/atari_scsi.c
@@ -742,7 +742,7 @@ static int __init atari_scsi_probe(struct platform_device *pdev)
 		atari_scsi_template.sg_tablesize = SG_ALL;
 	} else {
 		atari_scsi_template.can_queue    = 1;
-		atari_scsi_template.sg_tablesize = SG_NONE;
+		atari_scsi_template.sg_tablesize = 1;
 	}
 
 	if (setup_can_queue > 0)
@@ -751,8 +751,8 @@ static int __init atari_scsi_probe(struct platform_device *pdev)
 	if (setup_cmd_per_lun > 0)
 		atari_scsi_template.cmd_per_lun = setup_cmd_per_lun;
 
-	/* Leave sg_tablesize at 0 on a Falcon! */
-	if (ATARIHW_PRESENT(TT_SCSI) && setup_sg_tablesize >= 0)
+	/* Don't increase sg_tablesize on Falcon! */
+	if (ATARIHW_PRESENT(TT_SCSI) && setup_sg_tablesize > 0)
 		atari_scsi_template.sg_tablesize = setup_sg_tablesize;
 
 	if (setup_hostid >= 0) {

commit 1278cf66cf4b1c3d30e311200b50c45457c92baa
Author: Finn Thain <fthain@telegraphics.com.au>
Date:   Tue Jan 15 15:18:56 2019 +1100

    nvram: Replace nvram_* function exports with static functions
    
    Replace nvram_* functions with static functions in nvram.h. These will
    become wrappers for struct nvram_ops method calls.
    
    This patch effectively disables existing NVRAM functionality so as to
    allow the rest of the series to be bisected without build failures.
    That functionality is gradually re-implemented in subsequent patches.
    
    Replace the sole validate-checksum-and-read-byte sequence with a call to
    nvram_read() which will gain the same semantics in subsequent patches.
    
    Remove unused exports.
    
    Acked-by: Geert Uytterhoeven <geert@linux-m68k.org>
    Signed-off-by: Finn Thain <fthain@telegraphics.com.au>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/scsi/atari_scsi.c b/drivers/scsi/atari_scsi.c
index 78b43200c99e..e809493d0d06 100644
--- a/drivers/scsi/atari_scsi.c
+++ b/drivers/scsi/atari_scsi.c
@@ -759,13 +759,15 @@ static int __init atari_scsi_probe(struct platform_device *pdev)
 		atari_scsi_template.this_id = setup_hostid & 7;
 	} else if (IS_REACHABLE(CONFIG_NVRAM)) {
 		/* Test if a host id is set in the NVRam */
-		if (ATARIHW_PRESENT(TT_CLK) && nvram_check_checksum()) {
-			unsigned char b = nvram_read_byte(16);
+		if (ATARIHW_PRESENT(TT_CLK)) {
+			unsigned char b;
+			loff_t offset = 16;
+			ssize_t count = nvram_read(&b, 1, &offset);
 
 			/* Arbitration enabled? (for TOS)
 			 * If yes, use configured host ID
 			 */
-			if (b & 0x80)
+			if ((count == 1) && (b & 0x80))
 				atari_scsi_template.this_id = b & 7;
 		}
 	}

commit 83d2aed4440c47acc813abeac4acf4390cb40a8c
Author: Finn Thain <fthain@telegraphics.com.au>
Date:   Tue Jan 15 15:18:56 2019 +1100

    scsi/atari_scsi: Don't select CONFIG_NVRAM
    
    On powerpc, setting CONFIG_NVRAM=n builds a kernel with no NVRAM support.
    Setting CONFIG_NVRAM=m enables the /dev/nvram misc device module without
    enabling NVRAM support in drivers. Setting CONFIG_NVRAM=y enables the
    misc device (built-in) and also enables NVRAM support in drivers.
    
    m68k shares the valkyriefb driver with powerpc, and since that driver uses
    NVRAM, it is affected by CONFIG_ATARI_SCSI, because of the use of
    "select NVRAM". We can avoid the "select" here, but drivers still have
    to interpret the CONFIG_NVRAM symbol consistently regardless of platform.
    
    In this patch and the subsequent fbdev driver patch, the convention is
    adopted across all relevant platforms whereby NVRAM functionality gets
    enabled in a given device driver when the nvram misc device is built-in
    or when both drivers are modules.
    
    Acked-by: Michael Schmitz <schmitzmic@gmail.com>
    Signed-off-by: Finn Thain <fthain@telegraphics.com.au>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/scsi/atari_scsi.c b/drivers/scsi/atari_scsi.c
index a503dc50c4f8..78b43200c99e 100644
--- a/drivers/scsi/atari_scsi.c
+++ b/drivers/scsi/atari_scsi.c
@@ -757,7 +757,7 @@ static int __init atari_scsi_probe(struct platform_device *pdev)
 
 	if (setup_hostid >= 0) {
 		atari_scsi_template.this_id = setup_hostid & 7;
-	} else {
+	} else if (IS_REACHABLE(CONFIG_NVRAM)) {
 		/* Test if a host id is set in the NVRam */
 		if (ATARIHW_PRESENT(TT_CLK) && nvram_check_checksum()) {
 			unsigned char b = nvram_read_byte(16);

commit 4af14d113bcf95c12d1462ba623b7e7117bd3fb3
Author: Christoph Hellwig <hch@lst.de>
Date:   Thu Dec 13 16:17:09 2018 +0100

    scsi: remove the use_clustering flag
    
    The same effects can be achieved by setting the dma_boundary to
    PAGE_SIZE - 1 and the max_segment_size to PAGE_SIZE, so shift those
    settings into the drivers.  Note that in many cases the setting might
    be bogus, but this keeps the status quo.
    
    [mkp: fix myrs and myrb]
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/atari_scsi.c b/drivers/scsi/atari_scsi.c
index 89f5154c40b6..a503dc50c4f8 100644
--- a/drivers/scsi/atari_scsi.c
+++ b/drivers/scsi/atari_scsi.c
@@ -714,7 +714,7 @@ static struct scsi_host_template atari_scsi_template = {
 	.eh_host_reset_handler	= atari_scsi_host_reset,
 	.this_id		= 7,
 	.cmd_per_lun		= 2,
-	.use_clustering		= DISABLE_CLUSTERING,
+	.dma_boundary		= PAGE_SIZE - 1,
 	.cmd_size		= NCR5380_CMD_SIZE,
 };
 

commit 12e5fc665a2d8380c1551291a0d7684fc181b02d
Author: Hannes Reinecke <hare@suse.de>
Date:   Fri Aug 25 13:57:10 2017 +0200

    scsi: NCR5380: Move bus reset to host reset
    
    The bus reset handler really is a host reset, so move it to
    eh_bus_reset_handler.
    
    Signed-off-by: Hannes Reinecke <hare@suse.com>
    Acked-by: Finn Thain <fthain@telegraphics.com.au>
    Reviewed-by: Christoph Hellwig <hch@lst.de>
    Reviewed-by: Johannes Thumshirn <jthumshirn@suse.de>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/atari_scsi.c b/drivers/scsi/atari_scsi.c
index a75feebe6ad6..89f5154c40b6 100644
--- a/drivers/scsi/atari_scsi.c
+++ b/drivers/scsi/atari_scsi.c
@@ -671,7 +671,7 @@ static void atari_scsi_falcon_reg_write(unsigned int reg, u8 value)
 
 #include "NCR5380.c"
 
-static int atari_scsi_bus_reset(struct scsi_cmnd *cmd)
+static int atari_scsi_host_reset(struct scsi_cmnd *cmd)
 {
 	int rv;
 	unsigned long flags;
@@ -688,7 +688,7 @@ static int atari_scsi_bus_reset(struct scsi_cmnd *cmd)
 		atari_dma_orig_addr = NULL;
 	}
 
-	rv = NCR5380_bus_reset(cmd);
+	rv = NCR5380_host_reset(cmd);
 
 	/* The 5380 raises its IRQ line while _RST is active but the ST DMA
 	 * "lock" has been released so this interrupt may end up handled by
@@ -711,7 +711,7 @@ static struct scsi_host_template atari_scsi_template = {
 	.info			= atari_scsi_info,
 	.queuecommand		= atari_scsi_queue_command,
 	.eh_abort_handler	= atari_scsi_abort,
-	.eh_bus_reset_handler	= atari_scsi_bus_reset,
+	.eh_host_reset_handler	= atari_scsi_host_reset,
 	.this_id		= 7,
 	.cmd_per_lun		= 2,
 	.use_clustering		= DISABLE_CLUSTERING,

commit 6ff8a3b2a1e9ad5f0b559e7ef3b991918ef1caf9
Author: Michael Schmitz <schmitzmic@gmail.com>
Date:   Mon Jun 5 19:37:59 2017 +1200

    scsi: atari_scsi: Use m68k_realnum_memory for FastRAM test
    
    m68k_num_memory is unsuitable to test for the presence of FastRAM on
    CT60 if the kernel is located in FastRAM: in arch/m68k/mm/motorola.c the
    ST-RAM chunk is skipped and m68k_num_memory is decremented in this
    case. m68k_realnum_memory still contains the actual number of RAM chunks
    so use that.
    
    Signed-off-by: Michael Schmitz <schmitzmic@gmail.com>
    Tested-by: Christian T. Steigies <cts@debian.org>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/atari_scsi.c b/drivers/scsi/atari_scsi.c
index f792420c533e..a75feebe6ad6 100644
--- a/drivers/scsi/atari_scsi.c
+++ b/drivers/scsi/atari_scsi.c
@@ -776,7 +776,7 @@ static int __init atari_scsi_probe(struct platform_device *pdev)
 	 * from/to alternative Ram.
 	 */
 	if (ATARIHW_PRESENT(ST_SCSI) && !ATARIHW_PRESENT(EXTD_DMA) &&
-	    m68k_num_memory > 1) {
+	    m68k_realnum_memory > 1) {
 		atari_dma_buffer = atari_stram_alloc(STRAM_BUFFER_SIZE, "SCSI");
 		if (!atari_dma_buffer) {
 			pr_err(PFX "can't allocate ST-RAM double buffer\n");

commit 546a4d1812b647fddad58a4416c7a44c27bb0499
Author: Finn Thain <fthain@telegraphics.com.au>
Date:   Sun Jan 15 18:50:57 2017 -0500

    scsi: atari_scsi: Reset DMA during bus reset only under ST-DMA lock
    
    The atari_scsi driver should not access Falcon DMA chip registers unless
    it has acquired exclusive access to that chip. If the driver doesn't
    have exclusive access then there's no need for a DMA reset as there are
    no scsi commands in progress.
    
    Signed-off-by: Finn Thain <fthain@telegraphics.com.au>
    Tested-by: Ondrej Zary <linux@rainbow-software.org>
    Tested-by: Michael Schmitz <schmitzmic@gmail.com>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/atari_scsi.c b/drivers/scsi/atari_scsi.c
index b2ffab6577a6..f792420c533e 100644
--- a/drivers/scsi/atari_scsi.c
+++ b/drivers/scsi/atari_scsi.c
@@ -682,7 +682,8 @@ static int atari_scsi_bus_reset(struct scsi_cmnd *cmd)
 	if (IS_A_TT()) {
 		tt_scsi_dma.dma_ctrl = 0;
 	} else {
-		st_dma.dma_mode_status = 0x90;
+		if (stdma_is_locked_by(scsi_falcon_intr))
+			st_dma.dma_mode_status = 0x90;
 		atari_dma_active = 0;
 		atari_dma_orig_addr = NULL;
 	}

commit 4ab2a7878fa56ae7581bf8a94049b355c730aef0
Author: Finn Thain <fthain@telegraphics.com.au>
Date:   Sun Jan 15 18:50:57 2017 -0500

    scsi: ncr5380: Resolve various static checker warnings
    
    Avoid various warnings from "make C=1" by annotating a couple of
    unlock-then-lock sequences, replacing a zero with NULL and correcting
    some type casts.
    
    Also avoid a warning from "make W=1" by adding braces.
    
    Signed-off-by: Finn Thain <fthain@telegraphics.com.au>
    Tested-by: Ondrej Zary <linux@rainbow-software.org>
    Tested-by: Michael Schmitz <schmitzmic@gmail.com>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/atari_scsi.c b/drivers/scsi/atari_scsi.c
index 2b6eb7c24c69..b2ffab6577a6 100644
--- a/drivers/scsi/atari_scsi.c
+++ b/drivers/scsi/atari_scsi.c
@@ -782,7 +782,7 @@ static int __init atari_scsi_probe(struct platform_device *pdev)
 			return -ENOMEM;
 		}
 		atari_dma_phys_buffer = atari_stram_to_phys(atari_dma_buffer);
-		atari_dma_orig_addr = 0;
+		atari_dma_orig_addr = NULL;
 	}
 
 	instance = scsi_host_alloc(&atari_scsi_template,

commit 9507037304e581493bcd8bf76e013e44be71470e
Author: Finn Thain <fthain@telegraphics.com.au>
Date:   Sun Jan 15 18:50:57 2017 -0500

    scsi: ncr5380: Clean up dead code and redundant macro usage
    
    Remove dead code inside #if 0 conditionals.
    
    Remove the #ifdef __KERNEL__ test, since NCR5380.h has no definitions
    that relate to userspace code.
    
    Remove two redundant macro definitions which were overlooked in
    commit e9db3198e08b ("sun3_scsi: Adopt NCR5380.c core driver").
    
    Signed-off-by: Finn Thain <fthain@telegraphics.com.au>
    Tested-by: Ondrej Zary <linux@rainbow-software.org>
    Tested-by: Michael Schmitz <schmitzmic@gmail.com>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/atari_scsi.c b/drivers/scsi/atari_scsi.c
index 105b35393ce9..2b6eb7c24c69 100644
--- a/drivers/scsi/atari_scsi.c
+++ b/drivers/scsi/atari_scsi.c
@@ -178,37 +178,6 @@ static int scsi_dma_is_ignored_buserr(unsigned char dma_stat)
 }
 
 
-#if 0
-/* Dead code... wasn't called anyway :-) and causes some trouble, because at
- * end-of-DMA, both SCSI ints are triggered simultaneously, so the NCR int has
- * to clear the DMA int pending bit before it allows other level 6 interrupts.
- */
-static void scsi_dma_buserr(int irq, void *dummy)
-{
-	unsigned char dma_stat = tt_scsi_dma.dma_ctrl;
-
-	/* Don't do anything if a NCR interrupt is pending. Probably it's just
-	 * masked... */
-	if (atari_irq_pending(IRQ_TT_MFP_SCSI))
-		return;
-
-	printk("Bad SCSI DMA interrupt! dma_addr=0x%08lx dma_stat=%02x dma_cnt=%08lx\n",
-	       SCSI_DMA_READ_P(dma_addr), dma_stat, SCSI_DMA_READ_P(dma_cnt));
-	if (dma_stat & 0x80) {
-		if (!scsi_dma_is_ignored_buserr(dma_stat))
-			printk("SCSI DMA bus error -- bad DMA programming!\n");
-	} else {
-		/* Under normal circumstances we never should get to this point,
-		 * since both interrupts are triggered simultaneously and the 5380
-		 * int has higher priority. When this irq is handled, that DMA
-		 * interrupt is cleared. So a warning message is printed here.
-		 */
-		printk("SCSI DMA intr ?? -- this shouldn't happen!\n");
-	}
-}
-#endif
-
-
 static irqreturn_t scsi_tt_intr(int irq, void *dev)
 {
 	struct Scsi_Host *instance = dev;

commit 4a98f896bf2c66a69517fc5e10dc67288cb8da93
Author: Finn Thain <fthain@telegraphics.com.au>
Date:   Mon Oct 10 00:46:53 2016 -0400

    scsi: ncr5380: Use correct types for DMA routines
    
    Apply prototypes to get consistent function signatures for the DMA
    functions implemented in the board-specific drivers. To avoid using
    macros to alter actual parameters, some of those functions are reworked
    slightly.
    
    This is a step toward the goal of passing the board-specific routines
    to the core driver using an ops struct (as in a platform driver or
    library module).
    
    This also helps fix some inconsistent types: where the core driver uses
    ints (cmd->SCp.this_residual and hostdata->dma_len) for keeping track of
    transfers, certain board-specific routines used unsigned long.
    
    While we are fixing these function signatures, pass the hostdata pointer
    to DMA routines instead of a Scsi_Host pointer, for shorter and faster
    code.
    
    Signed-off-by: Finn Thain <fthain@telegraphics.com.au>
    Reviewed-by: Hannes Reinecke <hare@suse.com>
    Tested-by: Ondrej Zary <linux@rainbow-software.org>
    Tested-by: Michael Schmitz <schmitzmic@gmail.com>
    Acked-by: Russell King <rmk+kernel@armlinux.org.uk>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/atari_scsi.c b/drivers/scsi/atari_scsi.c
index f77c311ba5d0..105b35393ce9 100644
--- a/drivers/scsi/atari_scsi.c
+++ b/drivers/scsi/atari_scsi.c
@@ -67,14 +67,10 @@ static void (*atari_scsi_reg_write)(unsigned int, u8);
 #define NCR5380_abort                   atari_scsi_abort
 #define NCR5380_info                    atari_scsi_info
 
-#define NCR5380_dma_recv_setup(instance, data, count) \
-        atari_scsi_dma_setup(instance, data, count, 0)
-#define NCR5380_dma_send_setup(instance, data, count) \
-        atari_scsi_dma_setup(instance, data, count, 1)
-#define NCR5380_dma_residual(instance) \
-        atari_scsi_dma_residual(instance)
-#define NCR5380_dma_xfer_len(instance, cmd, phase) \
-        atari_dma_xfer_len(cmd->SCp.this_residual, cmd, !((phase) & SR_IO))
+#define NCR5380_dma_xfer_len            atari_scsi_dma_xfer_len
+#define NCR5380_dma_recv_setup          atari_scsi_dma_recv_setup
+#define NCR5380_dma_send_setup          atari_scsi_dma_send_setup
+#define NCR5380_dma_residual            atari_scsi_dma_residual
 
 #define NCR5380_acquire_dma_irq(instance)      falcon_get_lock(instance)
 #define NCR5380_release_dma_irq(instance)      falcon_release_lock()
@@ -457,15 +453,14 @@ static int __init atari_scsi_setup(char *str)
 __setup("atascsi=", atari_scsi_setup);
 #endif /* !MODULE */
 
-
-static unsigned long atari_scsi_dma_setup(struct Scsi_Host *instance,
+static unsigned long atari_scsi_dma_setup(struct NCR5380_hostdata *hostdata,
 					  void *data, unsigned long count,
 					  int dir)
 {
 	unsigned long addr = virt_to_phys(data);
 
-	dprintk(NDEBUG_DMA, "scsi%d: setting up dma, data = %p, phys = %lx, count = %ld, "
-		   "dir = %d\n", instance->host_no, data, addr, count, dir);
+	dprintk(NDEBUG_DMA, "scsi%d: setting up dma, data = %p, phys = %lx, count = %ld, dir = %d\n",
+	        hostdata->host->host_no, data, addr, count, dir);
 
 	if (!IS_A_TT() && !STRAM_ADDR(addr)) {
 		/* If we have a non-DMAable address on a Falcon, use the dribble
@@ -522,8 +517,19 @@ static unsigned long atari_scsi_dma_setup(struct Scsi_Host *instance,
 	return count;
 }
 
+static inline int atari_scsi_dma_recv_setup(struct NCR5380_hostdata *hostdata,
+                                            unsigned char *data, int count)
+{
+	return atari_scsi_dma_setup(hostdata, data, count, 0);
+}
+
+static inline int atari_scsi_dma_send_setup(struct NCR5380_hostdata *hostdata,
+                                            unsigned char *data, int count)
+{
+	return atari_scsi_dma_setup(hostdata, data, count, 1);
+}
 
-static long atari_scsi_dma_residual(struct Scsi_Host *instance)
+static int atari_scsi_dma_residual(struct NCR5380_hostdata *hostdata)
 {
 	return atari_dma_residual;
 }
@@ -564,10 +570,11 @@ static int falcon_classify_cmd(struct scsi_cmnd *cmd)
  * the overrun problem, so this question is academic :-)
  */
 
-static unsigned long atari_dma_xfer_len(unsigned long wanted_len,
-					struct scsi_cmnd *cmd, int write_flag)
+static int atari_scsi_dma_xfer_len(struct NCR5380_hostdata *hostdata,
+                                   struct scsi_cmnd *cmd)
 {
-	unsigned long	possible_len, limit;
+	int wanted_len = cmd->SCp.this_residual;
+	int possible_len, limit;
 
 	if (wanted_len < DMA_MIN_SIZE)
 		return 0;
@@ -604,7 +611,7 @@ static unsigned long atari_dma_xfer_len(unsigned long wanted_len,
 	 * use the dribble buffer and thus can do only STRAM_BUFFER_SIZE bytes.
 	 */
 
-	if (write_flag) {
+	if (cmd->sc_data_direction == DMA_TO_DEVICE) {
 		/* Write operation can always use the DMA, but the transfer size must
 		 * be rounded up to the next multiple of 512 (atari_dma_setup() does
 		 * this).
@@ -644,8 +651,8 @@ static unsigned long atari_dma_xfer_len(unsigned long wanted_len,
 		possible_len = limit;
 
 	if (possible_len != wanted_len)
-		dprintk(NDEBUG_DMA, "Sorry, must cut DMA transfer size to %ld bytes "
-			   "instead of %ld\n", possible_len, wanted_len);
+		dprintk(NDEBUG_DMA, "DMA transfer now %d bytes instead of %d\n",
+		        possible_len, wanted_len);
 
 	return possible_len;
 }

commit 7c60663143c29ea64f51e692f950f8619e0e4c77
Author: Finn Thain <fthain@telegraphics.com.au>
Date:   Mon Oct 10 00:46:53 2016 -0400

    scsi: ncr5380: Expedite register polling
    
    Avoid the call to NCR5380_poll_politely2() when possible. The call is
    easily short-circuited on the PIO fast path, using the inline wrapper.
    This requires that the NCR5380_read macro be made available before
    any #include "NCR5380.h" so a few declarations have to be moved too.
    
    Signed-off-by: Finn Thain <fthain@telegraphics.com.au>
    Reviewed-by: Hannes Reinecke <hare@suse.com>
    Tested-by: Ondrej Zary <linux@rainbow-software.org>
    Tested-by: Michael Schmitz <schmitzmic@gmail.com>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/atari_scsi.c b/drivers/scsi/atari_scsi.c
index aed69ac334eb..f77c311ba5d0 100644
--- a/drivers/scsi/atari_scsi.c
+++ b/drivers/scsi/atari_scsi.c
@@ -57,6 +57,9 @@
 
 #define NCR5380_implementation_fields   /* none */
 
+static u8 (*atari_scsi_reg_read)(unsigned int);
+static void (*atari_scsi_reg_write)(unsigned int, u8);
+
 #define NCR5380_read(reg)               atari_scsi_reg_read(reg)
 #define NCR5380_write(reg, value)       atari_scsi_reg_write(reg, value)
 
@@ -126,9 +129,6 @@ static inline unsigned long SCSI_DMA_GETADR(void)
 
 static void atari_scsi_fetch_restbytes(void);
 
-static u8 (*atari_scsi_reg_read)(unsigned int);
-static void (*atari_scsi_reg_write)(unsigned int, u8);
-
 static unsigned long	atari_dma_residual, atari_dma_startaddr;
 static short		atari_dma_active;
 /* pointer to the dribble buffer */

commit 61e1ce588b101f13a4c6f713b95d65551c8572e3
Author: Finn Thain <fthain@telegraphics.com.au>
Date:   Mon Oct 10 00:46:53 2016 -0400

    scsi: ncr5380: Use correct types for device register accessors
    
    For timeout values adopt unsigned long, which is the type of jiffies etc.
    
    For chip register values and bit masks pass u8, which is the return type
    of readb, inb etc.
    
    For device register offsets adopt unsigned int, as it is suitable for
    adding to base addresses.
    
    Pass the NCR5380_hostdata pointer to the board-specific routines instead
    of the Scsi_Host pointer. The board-specific code is concerned with
    hardware and not with SCSI protocol or the mid-layer.
    
    Signed-off-by: Finn Thain <fthain@telegraphics.com.au>
    Reviewed-by: Hannes Reinecke <hare@suse.com>
    Tested-by: Ondrej Zary <linux@rainbow-software.org>
    Tested-by: Michael Schmitz <schmitzmic@gmail.com>
    Acked-by: Russell King <rmk+kernel@armlinux.org.uk>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/atari_scsi.c b/drivers/scsi/atari_scsi.c
index 862f30c23ff0..aed69ac334eb 100644
--- a/drivers/scsi/atari_scsi.c
+++ b/drivers/scsi/atari_scsi.c
@@ -126,8 +126,8 @@ static inline unsigned long SCSI_DMA_GETADR(void)
 
 static void atari_scsi_fetch_restbytes(void);
 
-static unsigned char (*atari_scsi_reg_read)(unsigned char reg);
-static void (*atari_scsi_reg_write)(unsigned char reg, unsigned char value);
+static u8 (*atari_scsi_reg_read)(unsigned int);
+static void (*atari_scsi_reg_write)(unsigned int, u8);
 
 static unsigned long	atari_dma_residual, atari_dma_startaddr;
 static short		atari_dma_active;
@@ -658,30 +658,30 @@ static unsigned long atari_dma_xfer_len(unsigned long wanted_len,
  * NCR5380_write call these functions via function pointers.
  */
 
-static unsigned char atari_scsi_tt_reg_read(unsigned char reg)
+static u8 atari_scsi_tt_reg_read(unsigned int reg)
 {
 	return tt_scsi_regp[reg * 2];
 }
 
-static void atari_scsi_tt_reg_write(unsigned char reg, unsigned char value)
+static void atari_scsi_tt_reg_write(unsigned int reg, u8 value)
 {
 	tt_scsi_regp[reg * 2] = value;
 }
 
-static unsigned char atari_scsi_falcon_reg_read(unsigned char reg)
+static u8 atari_scsi_falcon_reg_read(unsigned int reg)
 {
 	unsigned long flags;
-	unsigned char result;
+	u8 result;
 
 	reg += 0x88;
 	local_irq_save(flags);
 	dma_wd.dma_mode_status = (u_short)reg;
-	result = (u_char)dma_wd.fdc_acces_seccount;
+	result = (u8)dma_wd.fdc_acces_seccount;
 	local_irq_restore(flags);
 	return result;
 }
 
-static void atari_scsi_falcon_reg_write(unsigned char reg, unsigned char value)
+static void atari_scsi_falcon_reg_write(unsigned int reg, u8 value)
 {
 	unsigned long flags;
 

commit abd12b09292cc87a75f7c3e3c3f2b12589560bb1
Author: Finn Thain <fthain@telegraphics.com.au>
Date:   Mon Oct 10 00:46:52 2016 -0400

    scsi: atari_scsi: Make device register accessors re-entrant
    
    This patch fixes an old bug: accesses to device registers from the
    interrupt handler (after reselection, DMA completion etc.) could mess
    up a device register access elsewhere, if the latter takes place outside
    of an irq lock (during selection etc.).
    
    Signed-off-by: Finn Thain <fthain@telegraphics.com.au>
    Reviewed-by: Hannes Reinecke <hare@suse.com>
    Tested-by: Michael Schmitz <schmitzmic@gmail.com>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/atari_scsi.c b/drivers/scsi/atari_scsi.c
index a59ad94ea52b..862f30c23ff0 100644
--- a/drivers/scsi/atari_scsi.c
+++ b/drivers/scsi/atari_scsi.c
@@ -670,14 +670,26 @@ static void atari_scsi_tt_reg_write(unsigned char reg, unsigned char value)
 
 static unsigned char atari_scsi_falcon_reg_read(unsigned char reg)
 {
-	dma_wd.dma_mode_status= (u_short)(0x88 + reg);
-	return (u_char)dma_wd.fdc_acces_seccount;
+	unsigned long flags;
+	unsigned char result;
+
+	reg += 0x88;
+	local_irq_save(flags);
+	dma_wd.dma_mode_status = (u_short)reg;
+	result = (u_char)dma_wd.fdc_acces_seccount;
+	local_irq_restore(flags);
+	return result;
 }
 
 static void atari_scsi_falcon_reg_write(unsigned char reg, unsigned char value)
 {
-	dma_wd.dma_mode_status = (u_short)(0x88 + reg);
+	unsigned long flags;
+
+	reg += 0x88;
+	local_irq_save(flags);
+	dma_wd.dma_mode_status = (u_short)reg;
 	dma_wd.fdc_acces_seccount = (u_short)value;
+	local_irq_restore(flags);
 }
 
 

commit ded155b5e4e735bdd654306145dff6491ce85766
Author: Finn Thain <fthain@telegraphics.com.au>
Date:   Wed Mar 23 21:10:30 2016 +1100

    atari_scsi: Allow can_queue to be increased for Falcon
    
    The benefit of limiting can_queue to 1 is that atari_scsi shares the
    ST DMA chip more fairly with other drivers (e.g. falcon-ide).
    
    Unfortunately, this can limit SCSI bus utilization. On systems without
    IDE, atari_scsi should issue SCSI commands whenever it can arbitrate for
    the bus. Make that possible by making can_queue configurable.
    
    Signed-off-by: Finn Thain <fthain@telegraphics.com.au>
    Reviewed-by: Hannes Reinecke <hare@suse.com>
    Tested-by: Michael Schmitz <schmitzmic@gmail.com>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/atari_scsi.c b/drivers/scsi/atari_scsi.c
index 65af08139787..a59ad94ea52b 100644
--- a/drivers/scsi/atari_scsi.c
+++ b/drivers/scsi/atari_scsi.c
@@ -14,55 +14,23 @@
  *
  */
 
-
-/**************************************************************************/
-/*                                                                        */
-/* Notes for Falcon SCSI:                                                 */
-/* ----------------------                                                 */
-/*                                                                        */
-/* Since the Falcon SCSI uses the ST-DMA chip, that is shared among       */
-/* several device drivers, locking and unlocking the access to this       */
-/* chip is required. But locking is not possible from an interrupt,       */
-/* since it puts the process to sleep if the lock is not available.       */
-/* This prevents "late" locking of the DMA chip, i.e. locking it just     */
-/* before using it, since in case of disconnection-reconnection           */
-/* commands, the DMA is started from the reselection interrupt.           */
-/*                                                                        */
-/* Two possible schemes for ST-DMA-locking would be:                      */
-/*  1) The lock is taken for each command separately and disconnecting    */
-/*     is forbidden (i.e. can_queue = 1).                                 */
-/*  2) The DMA chip is locked when the first command comes in and         */
-/*     released when the last command is finished and all queues are      */
-/*     empty.                                                             */
-/* The first alternative would result in bad performance, since the       */
-/* interleaving of commands would not be used. The second is unfair to    */
-/* other drivers using the ST-DMA, because the queues will seldom be      */
-/* totally empty if there is a lot of disk traffic.                       */
-/*                                                                        */
-/* For this reasons I decided to employ a more elaborate scheme:          */
-/*  - First, we give up the lock every time we can (for fairness), this    */
-/*    means every time a command finishes and there are no other commands */
-/*    on the disconnected queue.                                          */
-/*  - If there are others waiting to lock the DMA chip, we stop           */
-/*    issuing commands, i.e. moving them onto the issue queue.           */
-/*    Because of that, the disconnected queue will run empty in a         */
-/*    while. Instead we go to sleep on a 'fairness_queue'.                */
-/*  - If the lock is released, all processes waiting on the fairness      */
-/*    queue will be woken. The first of them tries to re-lock the DMA,     */
-/*    the others wait for the first to finish this task. After that,      */
-/*    they can all run on and do their commands...                        */
-/* This sounds complicated (and it is it :-(), but it seems to be a       */
-/* good compromise between fairness and performance: As long as no one     */
-/* else wants to work with the ST-DMA chip, SCSI can go along as          */
-/* usual. If now someone else comes, this behaviour is changed to a       */
-/* "fairness mode": just already initiated commands are finished and      */
-/* then the lock is released. The other one waiting will probably win     */
-/* the race for locking the DMA, since it was waiting for longer. And     */
-/* after it has finished, SCSI can go ahead again. Finally: I hope I      */
-/* have not produced any deadlock possibilities!                          */
-/*                                                                        */
-/**************************************************************************/
-
+/*
+ * Notes for Falcon SCSI DMA
+ *
+ * The 5380 device is one of several that all share the DMA chip. Hence
+ * "locking" and "unlocking" access to this chip is required.
+ *
+ * Two possible schemes for ST DMA acquisition by atari_scsi are:
+ * 1) The lock is taken for each command separately (i.e. can_queue == 1).
+ * 2) The lock is taken when the first command arrives and released
+ * when the last command is finished (i.e. can_queue > 1).
+ *
+ * The first alternative limits SCSI bus utilization, since interleaving
+ * commands is not possible. The second gives better performance but is
+ * unfair to other drivers needing to use the ST DMA chip. In order to
+ * allow the IDE and floppy drivers equal access to the ST DMA chip
+ * the default is can_queue == 1.
+ */
 
 #include <linux/module.h>
 #include <linux/types.h>
@@ -443,6 +411,10 @@ static int falcon_get_lock(struct Scsi_Host *instance)
 	if (IS_A_TT())
 		return 1;
 
+	if (stdma_is_locked_by(scsi_falcon_intr) &&
+	    instance->hostt->can_queue > 1)
+		return 1;
+
 	if (in_interrupt())
 		return stdma_try_lock(scsi_falcon_intr, instance);
 
@@ -776,22 +748,11 @@ static int __init atari_scsi_probe(struct platform_device *pdev)
 		atari_scsi_reg_write = atari_scsi_falcon_reg_write;
 	}
 
-	/* The values for CMD_PER_LUN and CAN_QUEUE are somehow arbitrary.
-	 * Higher values should work, too; try it!
-	 * (But cmd_per_lun costs memory!)
-	 *
-	 * But there seems to be a bug somewhere that requires CAN_QUEUE to be
-	 * 2*CMD_PER_LUN. At least on a TT, no spurious timeouts seen since
-	 * changed CMD_PER_LUN...
-	 *
-	 * Note: The Falcon currently uses 8/1 setting due to unsolved problems
-	 * with cmd_per_lun != 1
-	 */
 	if (ATARIHW_PRESENT(TT_SCSI)) {
 		atari_scsi_template.can_queue    = 16;
 		atari_scsi_template.sg_tablesize = SG_ALL;
 	} else {
-		atari_scsi_template.can_queue    = 8;
+		atari_scsi_template.can_queue    = 1;
 		atari_scsi_template.sg_tablesize = SG_NONE;
 	}
 

commit a5217a86369083af1f9630d17e9bb9e41ae7405a
Author: Finn Thain <fthain@telegraphics.com.au>
Date:   Wed Mar 23 21:10:29 2016 +1100

    atari_scsi: Set a reasonable default for cmd_per_lun
    
    This setting does not need to be conditional on Atari ST or TT.
    
    Signed-off-by: Finn Thain <fthain@telegraphics.com.au>
    Tested-by: Michael Schmitz <schmitzmic@gmail.com>
    Reviewed-by: Hannes Reinecke <hare@suse.com>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/atari_scsi.c b/drivers/scsi/atari_scsi.c
index 49b7b14e8913..65af08139787 100644
--- a/drivers/scsi/atari_scsi.c
+++ b/drivers/scsi/atari_scsi.c
@@ -752,6 +752,7 @@ static struct scsi_host_template atari_scsi_template = {
 	.eh_abort_handler	= atari_scsi_abort,
 	.eh_bus_reset_handler	= atari_scsi_bus_reset,
 	.this_id		= 7,
+	.cmd_per_lun		= 2,
 	.use_clustering		= DISABLE_CLUSTERING,
 	.cmd_size		= NCR5380_CMD_SIZE,
 };
@@ -788,11 +789,9 @@ static int __init atari_scsi_probe(struct platform_device *pdev)
 	 */
 	if (ATARIHW_PRESENT(TT_SCSI)) {
 		atari_scsi_template.can_queue    = 16;
-		atari_scsi_template.cmd_per_lun  = 8;
 		atari_scsi_template.sg_tablesize = SG_ALL;
 	} else {
 		atari_scsi_template.can_queue    = 8;
-		atari_scsi_template.cmd_per_lun  = 1;
 		atari_scsi_template.sg_tablesize = SG_NONE;
 	}
 

commit c4ec6f924f0682e1f40107204152e977d6b1bd07
Author: Finn Thain <fthain@telegraphics.com.au>
Date:   Wed Mar 23 21:10:22 2016 +1100

    ncr5380: Remove disused atari_NCR5380.c core driver
    
    Now that atari_scsi and sun3_scsi have been converted to use the NCR5380.c
    core driver, remove atari_NCR5380.c. Also remove the last vestiges of its
    Tagged Command Queueing implementation from the wrapper drivers.
    
    The TCQ support in atari_NCR5380.c is abandoned by this patch. It is not
    merged into the remaining core driver because,
    
    1) atari_scsi defines SUPPORT_TAGS but leaves FLAG_TAGGED_QUEUING disabled
    by default, which indicates that it is mostly undesirable.
    
    2) I'm told that it doesn't work correctly when enabled.
    
    3) The algorithm does not make use of block layer tags which it will have
    to do because scmd->tag is deprecated.
    
    4) sun3_scsi doesn't define SUPPORT_TAGS at all, yet the the SUPPORT_TAGS
    macro interacts with the CONFIG_SUN3 macro in 'interesting' ways.
    
    5) Compile-time configuration with macros like SUPPORT_TAGS caused the
    configuration space to explode, leading to untestable and unmaintainable
    code that is too hard to reason about.
    
    The merge_contiguous_buffers() code is also abandoned. This was unused
    by sun3_scsi. Only atari_scsi used it and then only on TT, because only TT
    supports scatter/gather. I suspect that the TT would work fine with
    ENABLE_CLUSTERING instead. If someone can benchmark the difference then
    perhaps the merge_contiguous_buffers() code can be be justified. Until
    then we are better off without the extra complexity.
    
    Signed-off-by: Finn Thain <fthain@telegraphics.com.au>
    Reviewed-by: Hannes Reinecke <hare@suse.com>
    Tested-by: Michael Schmitz <schmitzmic@gmail.com>
    Tested-by: Ondrej Zary <linux@rainbow-software.org>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/atari_scsi.c b/drivers/scsi/atari_scsi.c
index 445c26724ba1..49b7b14e8913 100644
--- a/drivers/scsi/atari_scsi.c
+++ b/drivers/scsi/atari_scsi.c
@@ -87,9 +87,6 @@
 
 /* Definitions for the core NCR5380 driver. */
 
-#define SUPPORT_TAGS
-#define MAX_TAGS                        32
-
 #define NCR5380_implementation_fields   /* none */
 
 #define NCR5380_read(reg)               atari_scsi_reg_read(reg)
@@ -189,8 +186,6 @@ static int setup_cmd_per_lun = -1;
 module_param(setup_cmd_per_lun, int, 0);
 static int setup_sg_tablesize = -1;
 module_param(setup_sg_tablesize, int, 0);
-static int setup_use_tagged_queuing = -1;
-module_param(setup_use_tagged_queuing, int, 0);
 static int setup_hostid = -1;
 module_param(setup_hostid, int, 0);
 static int setup_toshiba_delay = -1;
@@ -479,8 +474,7 @@ static int __init atari_scsi_setup(char *str)
 		setup_sg_tablesize = ints[3];
 	if (ints[0] >= 4)
 		setup_hostid = ints[4];
-	if (ints[0] >= 5)
-		setup_use_tagged_queuing = ints[5];
+	/* ints[5] (use_tagged_queuing) is ignored */
 	/* ints[6] (use_pdma) is ignored */
 	if (ints[0] >= 7)
 		setup_toshiba_delay = ints[7];
@@ -853,9 +847,6 @@ static int __init atari_scsi_probe(struct platform_device *pdev)
 	instance->irq = irq->start;
 
 	host_flags |= IS_A_TT() ? 0 : FLAG_LATE_DMA_SETUP;
-#ifdef SUPPORT_TAGS
-	host_flags |= setup_use_tagged_queuing > 0 ? FLAG_TAGGED_QUEUING : 0;
-#endif
 	host_flags |= setup_toshiba_delay > 0 ? FLAG_TOSHIBA_DELAY : 0;
 
 	error = NCR5380_init(instance, host_flags);

commit 52d3e561cb13df431364a69e783469ba8a9ea8eb
Author: Finn Thain <fthain@telegraphics.com.au>
Date:   Wed Mar 23 21:10:20 2016 +1100

    atari_scsi: Adopt NCR5380.c core driver
    
    Add support for the Atari ST DMA chip to the NCR5380.c core driver.
    This code is copied from atari_NCR5380.c.
    
    Signed-off-by: Finn Thain <fthain@telegraphics.com.au>
    Reviewed-by: Hannes Reinecke <hare@suse.com>
    Tested-by: Michael Schmitz <schmitzmic@gmail.com>
    Tested-by: Ondrej Zary <linux@rainbow-software.org>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/atari_scsi.c b/drivers/scsi/atari_scsi.c
index 5a81cec79a59..445c26724ba1 100644
--- a/drivers/scsi/atari_scsi.c
+++ b/drivers/scsi/atari_scsi.c
@@ -99,9 +99,9 @@
 #define NCR5380_abort                   atari_scsi_abort
 #define NCR5380_info                    atari_scsi_info
 
-#define NCR5380_dma_read_setup(instance, data, count) \
+#define NCR5380_dma_recv_setup(instance, data, count) \
         atari_scsi_dma_setup(instance, data, count, 0)
-#define NCR5380_dma_write_setup(instance, data, count) \
+#define NCR5380_dma_send_setup(instance, data, count) \
         atari_scsi_dma_setup(instance, data, count, 1)
 #define NCR5380_dma_residual(instance) \
         atari_scsi_dma_residual(instance)
@@ -715,7 +715,7 @@ static void atari_scsi_falcon_reg_write(unsigned char reg, unsigned char value)
 }
 
 
-#include "atari_NCR5380.c"
+#include "NCR5380.c"
 
 static int atari_scsi_bus_reset(struct scsi_cmnd *cmd)
 {

commit 438af51c642926f1c1844846bee1c3fb568dcd64
Author: Finn Thain <fthain@telegraphics.com.au>
Date:   Wed Mar 23 21:10:18 2016 +1100

    ncr5380: Adopt uniform DMA setup convention
    
    Standardize the DMA setup hooks so that the DMA implementation in
    atari_NCR5380.c can be reconciled with pseudo DMA implementation in
    NCR5380.c.
    
    Calls to NCR5380_dma_recv_setup() and NCR5380_dma_send_setup() return
    a negative value on failure, zero on PDMA transfer success and a positive
    byte count for DMA setup success.
    
    This convention is not entirely new, but is now applied consistently.
    
    Also remove a pointless Status Register access: the *phase assignment is
    redundant because after NCR5380_transfer_dma() returns control to
    NCR5380_information_transfer(), that routine then returns control
    to NCR5380_main(), which means *phase is dead.
    
    Signed-off-by: Finn Thain <fthain@telegraphics.com.au>
    Reviewed-by: Hannes Reinecke <hare@suse.com>
    Tested-by: Michael Schmitz <schmitzmic@gmail.com>
    Tested-by: Ondrej Zary <linux@rainbow-software.org>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/atari_scsi.c b/drivers/scsi/atari_scsi.c
index 41ddd95cebe6..5a81cec79a59 100644
--- a/drivers/scsi/atari_scsi.c
+++ b/drivers/scsi/atari_scsi.c
@@ -527,9 +527,6 @@ static unsigned long atari_scsi_dma_setup(struct Scsi_Host *instance,
 	 */
 	dma_cache_maintenance(addr, count, dir);
 
-	if (count == 0)
-		printk(KERN_NOTICE "SCSI warning: DMA programmed for 0 bytes !\n");
-
 	if (IS_A_TT()) {
 		tt_scsi_dma.dma_ctrl = dir;
 		SCSI_DMA_WRITE_P(dma_addr, addr);

commit e63449c43a58fc185ff35ace6a842817f57ec6c8
Author: Finn Thain <fthain@telegraphics.com.au>
Date:   Wed Mar 23 21:10:13 2016 +1100

    atari_NCR5380: Remove DMA_MIN_SIZE macro
    
    Only the atari_scsi and sun3_scsi drivers define DMA_MIN_SIZE.
    Both drivers also define NCR5380_dma_xfer_len, which means
    DMA_MIN_SIZE can be removed from the core driver.
    
    This removes another discrepancy between the two core drivers.
    
    Signed-off-by: Finn Thain <fthain@telegraphics.com.au>
    Tested-by: Michael Schmitz <schmitzmic@gmail.com>
    Reviewed-by: Hannes Reinecke <hare@suse.com>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/atari_scsi.c b/drivers/scsi/atari_scsi.c
index c68e895e971f..41ddd95cebe6 100644
--- a/drivers/scsi/atari_scsi.c
+++ b/drivers/scsi/atari_scsi.c
@@ -83,11 +83,12 @@
 
 #include <scsi/scsi_host.h>
 
+#define DMA_MIN_SIZE                    32
+
 /* Definitions for the core NCR5380 driver. */
 
 #define SUPPORT_TAGS
 #define MAX_TAGS                        32
-#define DMA_MIN_SIZE                    32
 
 #define NCR5380_implementation_fields   /* none */
 
@@ -605,6 +606,9 @@ static unsigned long atari_dma_xfer_len(unsigned long wanted_len,
 {
 	unsigned long	possible_len, limit;
 
+	if (wanted_len < DMA_MIN_SIZE)
+		return 0;
+
 	if (IS_A_TT())
 		/* TT SCSI DMA can transfer arbitrary #bytes */
 		return wanted_len;

commit e4dec6806aceca768b74c1c6402e6d31ecf3c960
Author: Finn Thain <fthain@telegraphics.com.au>
Date:   Wed Mar 23 21:10:12 2016 +1100

    ncr5380: Remove REAL_DMA and REAL_DMA_POLL macros
    
    For the NCR5380.c core driver, these macros are never used.
    If REAL_DMA were to be defined, compilation would fail.
    
    For the atari_NCR5380.c core driver, REAL_DMA is always defined.
    
    Hence these macros are pointless.
    
    Signed-off-by: Finn Thain <fthain@telegraphics.com.au>
    Reviewed-by: Hannes Reinecke <hare@suse.com>
    Tested-by: Michael Schmitz <schmitzmic@gmail.com>
    Tested-by: Ondrej Zary <linux@rainbow-software.org>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/atari_scsi.c b/drivers/scsi/atari_scsi.c
index 78d1b2963f2c..c68e895e971f 100644
--- a/drivers/scsi/atari_scsi.c
+++ b/drivers/scsi/atari_scsi.c
@@ -85,7 +85,6 @@
 
 /* Definitions for the core NCR5380 driver. */
 
-#define REAL_DMA
 #define SUPPORT_TAGS
 #define MAX_TAGS                        32
 #define DMA_MIN_SIZE                    32
@@ -159,14 +158,11 @@ static inline unsigned long SCSI_DMA_GETADR(void)
 	return adr;
 }
 
-#ifdef REAL_DMA
 static void atari_scsi_fetch_restbytes(void);
-#endif
 
 static unsigned char (*atari_scsi_reg_read)(unsigned char reg);
 static void (*atari_scsi_reg_write)(unsigned char reg, unsigned char value);
 
-#ifdef REAL_DMA
 static unsigned long	atari_dma_residual, atari_dma_startaddr;
 static short		atari_dma_active;
 /* pointer to the dribble buffer */
@@ -185,7 +181,6 @@ static char		*atari_dma_orig_addr;
 /* mask for address bits that can't be used with the ST-DMA */
 static unsigned long	atari_dma_stram_mask;
 #define STRAM_ADDR(a)	(((a) & atari_dma_stram_mask) == 0)
-#endif
 
 static int setup_can_queue = -1;
 module_param(setup_can_queue, int, 0);
@@ -201,8 +196,6 @@ static int setup_toshiba_delay = -1;
 module_param(setup_toshiba_delay, int, 0);
 
 
-#if defined(REAL_DMA)
-
 static int scsi_dma_is_ignored_buserr(unsigned char dma_stat)
 {
 	int i;
@@ -255,12 +248,9 @@ static void scsi_dma_buserr(int irq, void *dummy)
 }
 #endif
 
-#endif
-
 
 static irqreturn_t scsi_tt_intr(int irq, void *dev)
 {
-#ifdef REAL_DMA
 	struct Scsi_Host *instance = dev;
 	struct NCR5380_hostdata *hostdata = shost_priv(instance);
 	int dma_stat;
@@ -342,8 +332,6 @@ static irqreturn_t scsi_tt_intr(int irq, void *dev)
 		tt_scsi_dma.dma_ctrl = 0;
 	}
 
-#endif /* REAL_DMA */
-
 	NCR5380_intr(irq, dev);
 
 	return IRQ_HANDLED;
@@ -352,7 +340,6 @@ static irqreturn_t scsi_tt_intr(int irq, void *dev)
 
 static irqreturn_t scsi_falcon_intr(int irq, void *dev)
 {
-#ifdef REAL_DMA
 	struct Scsi_Host *instance = dev;
 	struct NCR5380_hostdata *hostdata = shost_priv(instance);
 	int dma_stat;
@@ -405,15 +392,12 @@ static irqreturn_t scsi_falcon_intr(int irq, void *dev)
 		atari_dma_orig_addr = NULL;
 	}
 
-#endif /* REAL_DMA */
-
 	NCR5380_intr(irq, dev);
 
 	return IRQ_HANDLED;
 }
 
 
-#ifdef REAL_DMA
 static void atari_scsi_fetch_restbytes(void)
 {
 	int nr;
@@ -436,7 +420,6 @@ static void atari_scsi_fetch_restbytes(void)
 			*dst++ = *src++;
 	}
 }
-#endif /* REAL_DMA */
 
 
 /* This function releases the lock on the DMA chip if there is no
@@ -508,8 +491,6 @@ __setup("atascsi=", atari_scsi_setup);
 #endif /* !MODULE */
 
 
-#if defined(REAL_DMA)
-
 static unsigned long atari_scsi_dma_setup(struct Scsi_Host *instance,
 					  void *data, unsigned long count,
 					  int dir)
@@ -703,9 +684,6 @@ static unsigned long atari_dma_xfer_len(unsigned long wanted_len,
 }
 
 
-#endif	/* REAL_DMA */
-
-
 /* NCR5380 register access functions
  *
  * There are separate functions for TT and Falcon, because the access
@@ -745,7 +723,6 @@ static int atari_scsi_bus_reset(struct scsi_cmnd *cmd)
 
 	local_irq_save(flags);
 
-#ifdef REAL_DMA
 	/* Abort a maybe active DMA transfer */
 	if (IS_A_TT()) {
 		tt_scsi_dma.dma_ctrl = 0;
@@ -754,7 +731,6 @@ static int atari_scsi_bus_reset(struct scsi_cmnd *cmd)
 		atari_dma_active = 0;
 		atari_dma_orig_addr = NULL;
 	}
-#endif
 
 	rv = NCR5380_bus_reset(cmd);
 
@@ -850,8 +826,6 @@ static int __init atari_scsi_probe(struct platform_device *pdev)
 		}
 	}
 
-
-#ifdef REAL_DMA
 	/* If running on a Falcon and if there's TT-Ram (i.e., more than one
 	 * memory block, since there's always ST-Ram in a Falcon), then
 	 * allocate a STRAM_BUFFER_SIZE byte dribble buffer for transfers
@@ -867,7 +841,6 @@ static int __init atari_scsi_probe(struct platform_device *pdev)
 		atari_dma_phys_buffer = atari_stram_to_phys(atari_dma_buffer);
 		atari_dma_orig_addr = 0;
 	}
-#endif
 
 	instance = scsi_host_alloc(&atari_scsi_template,
 	                           sizeof(struct NCR5380_hostdata));
@@ -897,7 +870,7 @@ static int __init atari_scsi_probe(struct platform_device *pdev)
 			goto fail_irq;
 		}
 		tt_mfp.active_edge |= 0x80;	/* SCSI int on L->H */
-#ifdef REAL_DMA
+
 		tt_scsi_dma.dma_ctrl = 0;
 		atari_dma_residual = 0;
 
@@ -919,17 +892,14 @@ static int __init atari_scsi_probe(struct platform_device *pdev)
 
 			hostdata->read_overruns = 4;
 		}
-#endif
 	} else {
 		/* Nothing to do for the interrupt: the ST-DMA is initialized
 		 * already.
 		 */
-#ifdef REAL_DMA
 		atari_dma_residual = 0;
 		atari_dma_active = 0;
 		atari_dma_stram_mask = (ATARIHW_PRESENT(EXTD_DMA) ? 0x00000000
 					: 0xff000000);
-#endif
 	}
 
 	NCR5380_maybe_reset_bus(instance);

commit cd46140a9a2f8fe0208262dc5f4d1fba15c93063
Author: Finn Thain <fthain@telegraphics.com.au>
Date:   Sun Jan 3 16:06:06 2016 +1100

    atari_scsi, sun3_scsi: Remove global Scsi_Host pointer
    
    This refactoring removes two global Scsi_Host pointers. This
    improves consistency with other ncr5380 drivers. Adopting the same
    conventions as the other drivers makes them easier to read.
    
    Signed-off-by: Finn Thain <fthain@telegraphics.com.au>
    Reviewed-by: Hannes Reinecke <hare@suse.com>
    Tested-by: Michael Schmitz <schmitzmic@gmail.com>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/atari_scsi.c b/drivers/scsi/atari_scsi.c
index 263cf06a8f30..78d1b2963f2c 100644
--- a/drivers/scsi/atari_scsi.c
+++ b/drivers/scsi/atari_scsi.c
@@ -159,14 +159,10 @@ static inline unsigned long SCSI_DMA_GETADR(void)
 	return adr;
 }
 
-#define HOSTDATA_DMALEN		(((struct NCR5380_hostdata *) \
-				(atari_scsi_host->hostdata))->dma_len)
-
 #ifdef REAL_DMA
 static void atari_scsi_fetch_restbytes(void);
 #endif
 
-static struct Scsi_Host *atari_scsi_host;
 static unsigned char (*atari_scsi_reg_read)(unsigned char reg);
 static void (*atari_scsi_reg_write)(unsigned char reg, unsigned char value);
 
@@ -262,15 +258,17 @@ static void scsi_dma_buserr(int irq, void *dummy)
 #endif
 
 
-static irqreturn_t scsi_tt_intr(int irq, void *dummy)
+static irqreturn_t scsi_tt_intr(int irq, void *dev)
 {
 #ifdef REAL_DMA
+	struct Scsi_Host *instance = dev;
+	struct NCR5380_hostdata *hostdata = shost_priv(instance);
 	int dma_stat;
 
 	dma_stat = tt_scsi_dma.dma_ctrl;
 
-	dprintk(NDEBUG_INTR, "scsi%d: NCR5380 interrupt, DMA status = %02x\n",
-		   atari_scsi_host->host_no, dma_stat & 0xff);
+	dsprintk(NDEBUG_INTR, instance, "NCR5380 interrupt, DMA status = %02x\n",
+	         dma_stat & 0xff);
 
 	/* Look if it was the DMA that has interrupted: First possibility
 	 * is that a bus error occurred...
@@ -293,7 +291,8 @@ static irqreturn_t scsi_tt_intr(int irq, void *dummy)
 	 * data reg!
 	 */
 	if ((dma_stat & 0x02) && !(dma_stat & 0x40)) {
-		atari_dma_residual = HOSTDATA_DMALEN - (SCSI_DMA_READ_P(dma_addr) - atari_dma_startaddr);
+		atari_dma_residual = hostdata->dma_len -
+			(SCSI_DMA_READ_P(dma_addr) - atari_dma_startaddr);
 
 		dprintk(NDEBUG_DMA, "SCSI DMA: There are %ld residual bytes.\n",
 			   atari_dma_residual);
@@ -345,15 +344,17 @@ static irqreturn_t scsi_tt_intr(int irq, void *dummy)
 
 #endif /* REAL_DMA */
 
-	NCR5380_intr(irq, dummy);
+	NCR5380_intr(irq, dev);
 
 	return IRQ_HANDLED;
 }
 
 
-static irqreturn_t scsi_falcon_intr(int irq, void *dummy)
+static irqreturn_t scsi_falcon_intr(int irq, void *dev)
 {
 #ifdef REAL_DMA
+	struct Scsi_Host *instance = dev;
+	struct NCR5380_hostdata *hostdata = shost_priv(instance);
 	int dma_stat;
 
 	/* Turn off DMA and select sector counter register before
@@ -388,7 +389,7 @@ static irqreturn_t scsi_falcon_intr(int irq, void *dummy)
 			printk(KERN_ERR "SCSI DMA error: %ld bytes lost in "
 			       "ST-DMA fifo\n", transferred & 15);
 
-		atari_dma_residual = HOSTDATA_DMALEN - transferred;
+		atari_dma_residual = hostdata->dma_len - transferred;
 		dprintk(NDEBUG_DMA, "SCSI DMA: There are %ld residual bytes.\n",
 			   atari_dma_residual);
 	} else
@@ -400,13 +401,14 @@ static irqreturn_t scsi_falcon_intr(int irq, void *dummy)
 		 * data to the original destination address.
 		 */
 		memcpy(atari_dma_orig_addr, phys_to_virt(atari_dma_startaddr),
-		       HOSTDATA_DMALEN - atari_dma_residual);
+		       hostdata->dma_len - atari_dma_residual);
 		atari_dma_orig_addr = NULL;
 	}
 
 #endif /* REAL_DMA */
 
-	NCR5380_intr(irq, dummy);
+	NCR5380_intr(irq, dev);
+
 	return IRQ_HANDLED;
 }
 
@@ -873,7 +875,6 @@ static int __init atari_scsi_probe(struct platform_device *pdev)
 		error = -ENOMEM;
 		goto fail_alloc;
 	}
-	atari_scsi_host = instance;
 
 	instance->irq = irq->start;
 

commit 32b26a104237c1ba3575a6c8d47e46060cc416fb
Author: Finn Thain <fthain@telegraphics.com.au>
Date:   Sun Jan 3 16:05:58 2016 +1100

    ncr5380: Use standard list data structure
    
    The NCR5380 drivers have a home-spun linked list implementation for
    scsi_cmnd structs that uses cmd->host_scribble as a 'next' pointer. Adopt
    the standard list_head data structure and list operations instead. Remove
    the eh_abort_handler rather than convert it. Doing the conversion would
    only be churn because the existing EH handlers don't work and get replaced
    in a subsequent patch.
    
    Signed-off-by: Finn Thain <fthain@telegraphics.com.au>
    Reviewed-by: Hannes Reinecke <hare@suse.com>
    Tested-by: Ondrej Zary <linux@rainbow-software.org>
    Tested-by: Michael Schmitz <schmitzmic@gmail.com>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/atari_scsi.c b/drivers/scsi/atari_scsi.c
index e271b08ccbb2..263cf06a8f30 100644
--- a/drivers/scsi/atari_scsi.c
+++ b/drivers/scsi/atari_scsi.c
@@ -780,6 +780,7 @@ static struct scsi_host_template atari_scsi_template = {
 	.eh_bus_reset_handler	= atari_scsi_bus_reset,
 	.this_id		= 7,
 	.use_clustering		= DISABLE_CLUSTERING,
+	.cmd_size		= NCR5380_CMD_SIZE,
 };
 
 static int __init atari_scsi_probe(struct platform_device *pdev)

commit e5c3fddfaa066e440315e713ddf8b60e9ac48cf7
Author: Finn Thain <fthain@telegraphics.com.au>
Date:   Sun Jan 3 16:05:52 2016 +1100

    ncr5380: Remove command list debug code
    
    Some NCR5380 hosts offer a .show_info method to access the contents of
    the various command list data structures from a procfs file. When NDEBUG
    is set, the same information is sent to the console during EH.
    
    The two core drivers, atari_NCR5380.c and NCR5380.c differ here. Because
    it is just for debugging, the easiest way to fix the discrepancy is
    simply remove this code.
    
    The only remaining users of NCR5380_show_info() and NCR5380_write_info()
    are drivers that define PSEUDO_DMA. The others have no use for the
    .show_info method, so don't initialize it.
    
    Signed-off-by: Finn Thain <fthain@telegraphics.com.au>
    Reviewed-by: Hannes Reinecke <hare@suse.com>
    Tested-by: Ondrej Zary <linux@rainbow-software.org>
    Tested-by: Michael Schmitz <schmitzmic@gmail.com>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/atari_scsi.c b/drivers/scsi/atari_scsi.c
index e263aa30282b..e271b08ccbb2 100644
--- a/drivers/scsi/atari_scsi.c
+++ b/drivers/scsi/atari_scsi.c
@@ -97,7 +97,6 @@
 
 #define NCR5380_queue_command           atari_scsi_queue_command
 #define NCR5380_abort                   atari_scsi_abort
-#define NCR5380_show_info               atari_scsi_show_info
 #define NCR5380_info                    atari_scsi_info
 
 #define NCR5380_dma_read_setup(instance, data, count) \
@@ -774,7 +773,6 @@ static int atari_scsi_bus_reset(struct scsi_cmnd *cmd)
 static struct scsi_host_template atari_scsi_template = {
 	.module			= THIS_MODULE,
 	.proc_name		= DRV_MODULE_NAME,
-	.show_info		= atari_scsi_show_info,
 	.name			= "Atari native SCSI",
 	.info			= atari_scsi_info,
 	.queuecommand		= atari_scsi_queue_command,

commit aa2e2cb1dde0e72e039f94210fb17e73661a6351
Author: Finn Thain <fthain@telegraphics.com.au>
Date:   Sun Jan 3 16:05:48 2016 +1100

    ncr5380: Fix and cleanup scsi_host_template initializers
    
    Add missing .module initializer. Use distinct .proc_name values for the
    g_NCR5380 and g_NCR5380_mmio modules. Remove pointless CAN_QUEUE and
    CMD_PER_LUN override macros. Cleanup whitespace and code style.
    
    Signed-off-by: Finn Thain <fthain@telegraphics.com.au>
    Reviewed-by: Hannes Reinecke <hare@suse.com>
    Tested-by: Ondrej Zary <linux@rainbow-software.org>
    Tested-by: Michael Schmitz <schmitzmic@gmail.com>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/atari_scsi.c b/drivers/scsi/atari_scsi.c
index 2ba075749326..e263aa30282b 100644
--- a/drivers/scsi/atari_scsi.c
+++ b/drivers/scsi/atari_scsi.c
@@ -781,7 +781,7 @@ static struct scsi_host_template atari_scsi_template = {
 	.eh_abort_handler	= atari_scsi_abort,
 	.eh_bus_reset_handler	= atari_scsi_bus_reset,
 	.this_id		= 7,
-	.use_clustering		= DISABLE_CLUSTERING
+	.use_clustering		= DISABLE_CLUSTERING,
 };
 
 static int __init atari_scsi_probe(struct platform_device *pdev)

commit 161c0059a2a80aefe7000d9ab7ce5c36e5463b5f
Author: Finn Thain <fthain@telegraphics.com.au>
Date:   Sun Jan 3 16:05:46 2016 +1100

    ncr5380: Cleanup #include directives
    
    Remove unused includes (stat.h, signal.h, proc_fs.h) and move includes
    needed by the core drivers into the common header (delay.h etc).
    
    Signed-off-by: Finn Thain <fthain@telegraphics.com.au>
    Reviewed-by: Hannes Reinecke <hare@suse.com>
    Tested-by: Ondrej Zary <linux@rainbow-software.org>
    Tested-by: Michael Schmitz <schmitzmic@gmail.com>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/atari_scsi.c b/drivers/scsi/atari_scsi.c
index 1c6c4ca0a82f..2ba075749326 100644
--- a/drivers/scsi/atari_scsi.c
+++ b/drivers/scsi/atari_scsi.c
@@ -66,7 +66,6 @@
 
 #include <linux/module.h>
 #include <linux/types.h>
-#include <linux/delay.h>
 #include <linux/blkdev.h>
 #include <linux/interrupt.h>
 #include <linux/init.h>

commit 0ad0eff98fec3c940ec199047ff580abaaa5bb1a
Author: Finn Thain <fthain@telegraphics.com.au>
Date:   Sun Jan 3 16:05:21 2016 +1100

    ncr5380: Introduce unbound workqueue
    
    Allocate a work queue that will permit busy waiting and sleeping. This
    means NCR5380_init() can potentially fail, so add this error path.
    
    Signed-off-by: Finn Thain <fthain@telegraphics.com.au>
    Reviewed-by: Hannes Reinecke <hare@suse.com>
    Tested-by: Ondrej Zary <linux@rainbow-software.org>
    Tested-by: Michael Schmitz <schmitzmic@gmail.com>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/atari_scsi.c b/drivers/scsi/atari_scsi.c
index 5b233ccae962..1c6c4ca0a82f 100644
--- a/drivers/scsi/atari_scsi.c
+++ b/drivers/scsi/atari_scsi.c
@@ -885,7 +885,9 @@ static int __init atari_scsi_probe(struct platform_device *pdev)
 #endif
 	host_flags |= setup_toshiba_delay > 0 ? FLAG_TOSHIBA_DELAY : 0;
 
-	NCR5380_init(instance, host_flags);
+	error = NCR5380_init(instance, host_flags);
+	if (error)
+		goto fail_init;
 
 	if (IS_A_TT()) {
 		error = request_irq(instance->irq, scsi_tt_intr, 0,
@@ -947,6 +949,7 @@ static int __init atari_scsi_probe(struct platform_device *pdev)
 		free_irq(instance->irq, instance);
 fail_irq:
 	NCR5380_exit(instance);
+fail_init:
 	scsi_host_put(instance);
 fail_alloc:
 	if (atari_dma_buffer)

commit 9c3f0e2b52ada30fe72beec27b83e91e12566609
Author: Finn Thain <fthain@telegraphics.com.au>
Date:   Sun Jan 3 16:05:11 2016 +1100

    atari_NCR5380: Remove RESET_BOOT, CONFIG_ATARI_SCSI_TOSHIBA_DELAY and CONFIG_ATARI_SCSI_RESET_BOOT
    
    The atari_NCR5380.c core driver now takes care of bus reset upon driver
    initialization if required (same as NCR5380.c). Move the Toshiba CD-ROM
    support into the core driver, enabled with a host flag, so that all
    NCR5380 drivers can make use of it.
    
    Drop the RESET_BOOT macros and the ATARI_SCSI_RESET_BOOT and
    ATARI_SCSI_TOSHIBA_DELAY Kconfig symbols, which are now redundant.
    
    Remove the atari_scsi_reset_boot(), mac_scsi_reset_boot() and
    sun3_scsi_reset_boot() routines. None of this duplicated code is needed
    now that all drivers can use NCR5380_maybe_reset_bus().
    
    This brings atari_scsi, mac_scsi and sun3_scsi into line with all of the
    other NCR5380 drivers.
    
    The bus reset may raise an interrupt. That would be new behaviour for
    atari_scsi only when CONFIG_ATARI_SCSI_RESET_BOOT=n. The ST DMA interrupt
    is not assigned to atari_scsi at this stage, so
    CONFIG_ATARI_SCSI_RESET_BOOT=y may well be problematic already.
    Regardless, do_reset() now raises and clears the interrupt within
    local_irq_save/restore which should avoid problems.
    
    Signed-off-by: Finn Thain <fthain@telegraphics.com.au>
    Reviewed-by: Hannes Reinecke <hare@suse.com>
    Tested-by: Ondrej Zary <linux@rainbow-software.org>
    Tested-by: Michael Schmitz <schmitzmic@gmail.com>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/atari_scsi.c b/drivers/scsi/atari_scsi.c
index 1852ed6e8a48..5b233ccae962 100644
--- a/drivers/scsi/atari_scsi.c
+++ b/drivers/scsi/atari_scsi.c
@@ -164,15 +164,6 @@ static inline unsigned long SCSI_DMA_GETADR(void)
 #define HOSTDATA_DMALEN		(((struct NCR5380_hostdata *) \
 				(atari_scsi_host->hostdata))->dma_len)
 
-/* Time (in jiffies) to wait after a reset; the SCSI standard calls for 250ms,
- * we usually do 0.5s to be on the safe side. But Toshiba CD-ROMs once more
- * need ten times the standard value... */
-#ifndef CONFIG_ATARI_SCSI_TOSHIBA_DELAY
-#define	AFTER_RESET_DELAY	(HZ/2)
-#else
-#define	AFTER_RESET_DELAY	(5*HZ/2)
-#endif
-
 #ifdef REAL_DMA
 static void atari_scsi_fetch_restbytes(void);
 #endif
@@ -208,12 +199,12 @@ static int setup_cmd_per_lun = -1;
 module_param(setup_cmd_per_lun, int, 0);
 static int setup_sg_tablesize = -1;
 module_param(setup_sg_tablesize, int, 0);
-#ifdef SUPPORT_TAGS
 static int setup_use_tagged_queuing = -1;
 module_param(setup_use_tagged_queuing, int, 0);
-#endif
 static int setup_hostid = -1;
 module_param(setup_hostid, int, 0);
+static int setup_toshiba_delay = -1;
+module_param(setup_toshiba_delay, int, 0);
 
 
 #if defined(REAL_DMA)
@@ -488,7 +479,7 @@ static int __init atari_scsi_setup(char *str)
 	 * Defaults depend on TT or Falcon, determined at run time.
 	 * Negative values mean don't change.
 	 */
-	int ints[6];
+	int ints[8];
 
 	get_options(str, ARRAY_SIZE(ints), ints);
 
@@ -504,10 +495,11 @@ static int __init atari_scsi_setup(char *str)
 		setup_sg_tablesize = ints[3];
 	if (ints[0] >= 4)
 		setup_hostid = ints[4];
-#ifdef SUPPORT_TAGS
 	if (ints[0] >= 5)
 		setup_use_tagged_queuing = ints[5];
-#endif
+	/* ints[6] (use_pdma) is ignored */
+	if (ints[0] >= 7)
+		setup_toshiba_delay = ints[7];
 
 	return 1;
 }
@@ -516,38 +508,6 @@ __setup("atascsi=", atari_scsi_setup);
 #endif /* !MODULE */
 
 
-#ifdef CONFIG_ATARI_SCSI_RESET_BOOT
-static void __init atari_scsi_reset_boot(void)
-{
-	unsigned long end;
-
-	/*
-	 * Do a SCSI reset to clean up the bus during initialization. No messing
-	 * with the queues, interrupts, or locks necessary here.
-	 */
-
-	printk("Atari SCSI: resetting the SCSI bus...");
-
-	/* get in phase */
-	NCR5380_write(TARGET_COMMAND_REG,
-		      PHASE_SR_TO_TCR(NCR5380_read(STATUS_REG)));
-
-	/* assert RST */
-	NCR5380_write(INITIATOR_COMMAND_REG, ICR_BASE | ICR_ASSERT_RST);
-	/* The min. reset hold time is 25us, so 40us should be enough */
-	udelay(50);
-	/* reset RST and interrupt */
-	NCR5380_write(INITIATOR_COMMAND_REG, ICR_BASE);
-	NCR5380_read(RESET_PARITY_INTERRUPT_REG);
-
-	end = jiffies + AFTER_RESET_DELAY;
-	while (time_before(jiffies, end))
-		barrier();
-
-	printk(" done\n");
-}
-#endif
-
 #if defined(REAL_DMA)
 
 static unsigned long atari_scsi_dma_setup(struct Scsi_Host *instance,
@@ -917,17 +877,13 @@ static int __init atari_scsi_probe(struct platform_device *pdev)
 	}
 	atari_scsi_host = instance;
 
-#ifdef CONFIG_ATARI_SCSI_RESET_BOOT
-	atari_scsi_reset_boot();
-#endif
-
 	instance->irq = irq->start;
 
 	host_flags |= IS_A_TT() ? 0 : FLAG_LATE_DMA_SETUP;
-
 #ifdef SUPPORT_TAGS
 	host_flags |= setup_use_tagged_queuing > 0 ? FLAG_TAGGED_QUEUING : 0;
 #endif
+	host_flags |= setup_toshiba_delay > 0 ? FLAG_TOSHIBA_DELAY : 0;
 
 	NCR5380_init(instance, host_flags);
 
@@ -975,6 +931,8 @@ static int __init atari_scsi_probe(struct platform_device *pdev)
 #endif
 	}
 
+	NCR5380_maybe_reset_bus(instance);
+
 	error = scsi_add_host(instance, NULL);
 	if (error)
 		goto fail_host;

commit 6225a16a071c8636e9f6257183bb501479ad23c2
Author: Finn Thain <fthain@telegraphics.com.au>
Date:   Sun Jan 3 16:05:02 2016 +1100

    atari_scsi: Fix SCSI host ID setting
    
    The NVRAM location of this byte is 16, as documented in
    http://toshyp.atari.org/en/004009.html
    
    This was confirmed by Michael Schmitz, by setting the SCSI host ID
    under EmuTOS and then checking the value in /proc/driver/nvram and
    /dev/nvram under Linux.
    
    Signed-off-by: Finn Thain <fthain@telegraphics.com.au>
    Reviewed-by: Hannes Reinecke <hare@suse.com>
    Tested-by: Michael Schmitz <schmitzmic@gmail.com>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/atari_scsi.c b/drivers/scsi/atari_scsi.c
index 5ede3daa93dc..1852ed6e8a48 100644
--- a/drivers/scsi/atari_scsi.c
+++ b/drivers/scsi/atari_scsi.c
@@ -880,7 +880,7 @@ static int __init atari_scsi_probe(struct platform_device *pdev)
 	} else {
 		/* Test if a host id is set in the NVRam */
 		if (ATARIHW_PRESENT(TT_CLK) && nvram_check_checksum()) {
-			unsigned char b = nvram_read_byte(14);
+			unsigned char b = nvram_read_byte(16);
 
 			/* Arbitration enabled? (for TOS)
 			 * If yes, use configured host ID

commit 700d98551ff16a59e164bf884aefbdc5d798ff75
Author: Wolfram Sang <wsa@the-dreams.de>
Date:   Thu Jan 29 17:54:46 2015 +1100

    ncr5380: Drop owner assignment from platform_drivers
    
    This platform_driver does not need to set an owner, it will be populated by
    the driver core.
    
    Signed-off-by: Wolfram Sang <wsa@the-dreams.de>
    Signed-off-by: Finn Thain <fthain@telegraphics.com.au>
    Signed-off-by: James Bottomley <JBottomley@Parallels.com>

diff --git a/drivers/scsi/atari_scsi.c b/drivers/scsi/atari_scsi.c
index d1c37a386947..5ede3daa93dc 100644
--- a/drivers/scsi/atari_scsi.c
+++ b/drivers/scsi/atari_scsi.c
@@ -1014,7 +1014,6 @@ static struct platform_driver atari_scsi_driver = {
 	.remove = __exit_p(atari_scsi_remove),
 	.driver = {
 		.name	= DRV_MODULE_NAME,
-		.owner	= THIS_MODULE,
 	},
 };
 

commit a53a21e4662fd2ed27863f511715898459312393
Author: Finn Thain <fthain@telegraphics.com.au>
Date:   Wed Nov 12 16:12:21 2014 +1100

    atari_NCR5380: Move static co-routine variables to host data
    
    Unlike NCR5380.c, the atari_NCR5380.c core driver is limited to a single
    instance because co-routine state is stored globally.
    
    Fix this by removing the static scsi host pointer. For the co-routine,
    obtain this pointer from the work_struct pointer instead. For the interrupt
    handler, obtain it from the dev_id argument.
    
    Signed-off-by: Finn Thain <fthain@telegraphics.com.au>
    Reviewed-by: Hannes Reinecke <hare@suse.de>
    Tested-by: Michael Schmitz <schmitzmic@gmail.com>
    Signed-off-by: Christoph Hellwig <hch@lst.de>

diff --git a/drivers/scsi/atari_scsi.c b/drivers/scsi/atari_scsi.c
index b69010604699..d1c37a386947 100644
--- a/drivers/scsi/atari_scsi.c
+++ b/drivers/scsi/atari_scsi.c
@@ -110,7 +110,7 @@
 #define NCR5380_dma_xfer_len(instance, cmd, phase) \
         atari_dma_xfer_len(cmd->SCp.this_residual, cmd, !((phase) & SR_IO))
 
-#define NCR5380_acquire_dma_irq(instance)      falcon_get_lock()
+#define NCR5380_acquire_dma_irq(instance)      falcon_get_lock(instance)
 #define NCR5380_release_dma_irq(instance)      falcon_release_lock()
 
 #include "NCR5380.h"
@@ -468,15 +468,15 @@ static void falcon_release_lock(void)
  * command immediately but tell the SCSI mid-layer to defer.
  */
 
-static int falcon_get_lock(void)
+static int falcon_get_lock(struct Scsi_Host *instance)
 {
 	if (IS_A_TT())
 		return 1;
 
 	if (in_interrupt())
-		return stdma_try_lock(scsi_falcon_intr, NULL);
+		return stdma_try_lock(scsi_falcon_intr, instance);
 
-	stdma_lock(scsi_falcon_intr, NULL);
+	stdma_lock(scsi_falcon_intr, instance);
 	return 1;
 }
 

commit ca513fc948e66ecdd3c75cca9371762bb4c06776
Author: Finn Thain <fthain@telegraphics.com.au>
Date:   Wed Nov 12 16:12:19 2014 +1100

    atari_NCR5380: Introduce FLAG_TAGGED_QUEUING
    
    The static variable setup_use_tagged_queuing is declared in mac_scsi.c,
    sun3_scsi.c and atari_scsi.c and doesn't belong in the core driver.
    None of the other NCR5380 drivers suffer from this layering issue which
    makes merging the core drivers more difficult and will likely hinder plans
    for future use of platform data to configure the driver.
    
    Replace the static variable with a host flag. This way it can be reported
    along with the other flags.
    
    Signed-off-by: Finn Thain <fthain@telegraphics.com.au>
    Reviewed-by: Hannes Reinecke <hare@suse.de>
    Tested-by: Michael Schmitz <schmitzmic@gmail.com>
    Signed-off-by: Christoph Hellwig <hch@lst.de>

diff --git a/drivers/scsi/atari_scsi.c b/drivers/scsi/atari_scsi.c
index f0da0c8cbb0d..b69010604699 100644
--- a/drivers/scsi/atari_scsi.c
+++ b/drivers/scsi/atari_scsi.c
@@ -890,10 +890,6 @@ static int __init atari_scsi_probe(struct platform_device *pdev)
 		}
 	}
 
-#ifdef SUPPORT_TAGS
-	if (setup_use_tagged_queuing < 0)
-		setup_use_tagged_queuing = 0;
-#endif
 
 #ifdef REAL_DMA
 	/* If running on a Falcon and if there's TT-Ram (i.e., more than one
@@ -929,6 +925,10 @@ static int __init atari_scsi_probe(struct platform_device *pdev)
 
 	host_flags |= IS_A_TT() ? 0 : FLAG_LATE_DMA_SETUP;
 
+#ifdef SUPPORT_TAGS
+	host_flags |= setup_use_tagged_queuing > 0 ? FLAG_TAGGED_QUEUING : 0;
+#endif
+
 	NCR5380_init(instance, host_flags);
 
 	if (IS_A_TT()) {

commit e3f463b034bad82cd247d9a1b39209ba7152e545
Author: Finn Thain <fthain@telegraphics.com.au>
Date:   Wed Nov 12 16:12:16 2014 +1100

    atari_NCR5380: Merge from sun3_NCR5380.c
    
    There is very little difference between the sun3_NCR5380.c core driver
    and atari_NCR5380.c. The former is a fork of the latter.
    
    Merge the sun3_NCR5380.c core driver into atari_NCR5380.c so that
    sun3_scsi.c can adopt the latter and the former can be deleted.
    
    Signed-off-by: Finn Thain <fthain@telegraphics.com.au>
    Reviewed-by: Hannes Reinecke <hare@suse.de>
    Tested-by: Michael Schmitz <schmitzmic@gmail.com>
    Signed-off-by: Christoph Hellwig <hch@lst.de>

diff --git a/drivers/scsi/atari_scsi.c b/drivers/scsi/atari_scsi.c
index 045112186f84..f0da0c8cbb0d 100644
--- a/drivers/scsi/atari_scsi.c
+++ b/drivers/scsi/atari_scsi.c
@@ -89,6 +89,7 @@
 #define REAL_DMA
 #define SUPPORT_TAGS
 #define MAX_TAGS                        32
+#define DMA_MIN_SIZE                    32
 
 #define NCR5380_implementation_fields   /* none */
 

commit e3c3da67340ac7d1d2f630f319eb718474b0d9c3
Author: Finn Thain <fthain@telegraphics.com.au>
Date:   Wed Nov 12 16:12:15 2014 +1100

    atari_NCR5380: Refactor Falcon locking
    
    Simplify falcon_release_lock_if_possible() by making callers responsible for
    disabling local IRQ's, which they must do anyway to correctly synchronize
    the ST DMA "lock" with core driver data structures. Move this
    synchronization logic to the core driver with which it is tightly coupled.
    
    Other LLD's like sun3_scsi and mac_scsi that can make use of this core
    driver can just stub out the NCR5380_acquire_dma_irq() and
    NCR5380_release_dma_irq() calls so the compiler will eliminate the
    ST DMA code.
    
    Remove a redundant local_irq_save/restore pair (irq's are disabled for
    interrupt handlers these days). Revise the locking for
    atari_scsi_bus_reset(): use local_irq_save/restore() instead of
    atari_turnoff/turnon_irq(). There is no guarantee that atari_scsi still
    holds the ST DMA lock during EH, so atari_turnoff/turnon_irq() could
    end up dropping an IDE or floppy interrupt.
    
    Signed-off-by: Finn Thain <fthain@telegraphics.com.au>
    Tested-by: Michael Schmitz <schmitzmic@gmail.com>
    Reviewed-by: Hannes Reinecke <hare@suse.de>
    Signed-off-by: Christoph Hellwig <hch@lst.de>

diff --git a/drivers/scsi/atari_scsi.c b/drivers/scsi/atari_scsi.c
index 70c662f9fee4..045112186f84 100644
--- a/drivers/scsi/atari_scsi.c
+++ b/drivers/scsi/atari_scsi.c
@@ -109,6 +109,9 @@
 #define NCR5380_dma_xfer_len(instance, cmd, phase) \
         atari_dma_xfer_len(cmd->SCp.this_residual, cmd, !((phase) & SR_IO))
 
+#define NCR5380_acquire_dma_irq(instance)      falcon_get_lock()
+#define NCR5380_release_dma_irq(instance)      falcon_release_lock()
+
 #include "NCR5380.h"
 
 
@@ -448,23 +451,13 @@ static void atari_scsi_fetch_restbytes(void)
  * connected command and the disconnected queue is empty.
  */
 
-static void falcon_release_lock_if_possible(struct NCR5380_hostdata *hostdata)
+static void falcon_release_lock(void)
 {
-	unsigned long flags;
-
 	if (IS_A_TT())
 		return;
 
-	local_irq_save(flags);
-
-	if (!hostdata->disconnected_queue &&
-	    !hostdata->issue_queue &&
-	    !hostdata->connected &&
-	    !hostdata->retain_dma_intr &&
-	    stdma_is_locked_by(scsi_falcon_intr))
+	if (stdma_is_locked_by(scsi_falcon_intr))
 		stdma_release();
-
-	local_irq_restore(flags);
 }
 
 /* This function manages the locking of the ST-DMA.
@@ -787,36 +780,30 @@ static void atari_scsi_falcon_reg_write(unsigned char reg, unsigned char value)
 static int atari_scsi_bus_reset(struct scsi_cmnd *cmd)
 {
 	int rv;
-	struct NCR5380_hostdata *hostdata = shost_priv(cmd->device->host);
+	unsigned long flags;
+
+	local_irq_save(flags);
 
-	/* For doing the reset, SCSI interrupts must be disabled first,
-	 * since the 5380 raises its IRQ line while _RST is active and we
-	 * can't disable interrupts completely, since we need the timer.
-	 */
-	/* And abort a maybe active DMA transfer */
-	if (IS_A_TT()) {
-		atari_turnoff_irq(IRQ_TT_MFP_SCSI);
 #ifdef REAL_DMA
+	/* Abort a maybe active DMA transfer */
+	if (IS_A_TT()) {
 		tt_scsi_dma.dma_ctrl = 0;
-#endif
 	} else {
-		atari_turnoff_irq(IRQ_MFP_FSCSI);
-#ifdef REAL_DMA
 		st_dma.dma_mode_status = 0x90;
 		atari_dma_active = 0;
 		atari_dma_orig_addr = NULL;
-#endif
 	}
+#endif
 
 	rv = NCR5380_bus_reset(cmd);
 
-	if (IS_A_TT())
-		atari_turnon_irq(IRQ_TT_MFP_SCSI);
-	else
-		atari_turnon_irq(IRQ_MFP_FSCSI);
+	/* The 5380 raises its IRQ line while _RST is active but the ST DMA
+	 * "lock" has been released so this interrupt may end up handled by
+	 * floppy or IDE driver (if one of them holds the lock). The NCR5380
+	 * interrupt flag has been cleared already.
+	 */
 
-	if (rv == SUCCESS)
-		falcon_release_lock_if_possible(hostdata);
+	local_irq_restore(flags);
 
 	return rv;
 }

commit ef1081cbf05b22d3d0e05b267a5559a8cd8e8d4a
Author: Finn Thain <fthain@telegraphics.com.au>
Date:   Wed Nov 12 16:12:14 2014 +1100

    atari_NCR5380: Refactor Falcon special cases
    
    Make the atari_NCR5380.c core driver usable by sun3_scsi, mac_scsi and
    others by moving some of the Falcon-specific code out of the core driver:
    !IS_A_TT, atari_read_overruns and falcon_dont_release. Replace these with
    hostdata variables and flags. FLAG_CHECK_LAST_BYTE_SENT is unused in
    atari_NCR5380.c so don't set it.
    
    Signed-off-by: Finn Thain <fthain@telegraphics.com.au>
    Reviewed-by: Hannes Reinecke <hare@suse.de>
    Tested-by: Michael Schmitz <schmitzmic@gmail.com>
    Signed-off-by: Christoph Hellwig <hch@lst.de>

diff --git a/drivers/scsi/atari_scsi.c b/drivers/scsi/atari_scsi.c
index 78324e056d4c..70c662f9fee4 100644
--- a/drivers/scsi/atari_scsi.c
+++ b/drivers/scsi/atari_scsi.c
@@ -196,8 +196,6 @@ static char		*atari_dma_orig_addr;
 /* mask for address bits that can't be used with the ST-DMA */
 static unsigned long	atari_dma_stram_mask;
 #define STRAM_ADDR(a)	(((a) & atari_dma_stram_mask) == 0)
-/* number of bytes to cut from a transfer to handle NCR overruns */
-static int atari_read_overruns;
 #endif
 
 static int setup_can_queue = -1;
@@ -446,8 +444,6 @@ static void atari_scsi_fetch_restbytes(void)
 #endif /* REAL_DMA */
 
 
-static int falcon_dont_release = 0;
-
 /* This function releases the lock on the DMA chip if there is no
  * connected command and the disconnected queue is empty.
  */
@@ -464,7 +460,7 @@ static void falcon_release_lock_if_possible(struct NCR5380_hostdata *hostdata)
 	if (!hostdata->disconnected_queue &&
 	    !hostdata->issue_queue &&
 	    !hostdata->connected &&
-	    !falcon_dont_release &&
+	    !hostdata->retain_dma_intr &&
 	    stdma_is_locked_by(scsi_falcon_intr))
 		stdma_release();
 
@@ -846,6 +842,7 @@ static int __init atari_scsi_probe(struct platform_device *pdev)
 	struct Scsi_Host *instance;
 	int error;
 	struct resource *irq;
+	int host_flags = 0;
 
 	irq = platform_get_resource(pdev, IORESOURCE_IRQ, 0);
 	if (!irq)
@@ -942,7 +939,9 @@ static int __init atari_scsi_probe(struct platform_device *pdev)
 
 	instance->irq = irq->start;
 
-	NCR5380_init(instance, 0);
+	host_flags |= IS_A_TT() ? 0 : FLAG_LATE_DMA_SETUP;
+
+	NCR5380_init(instance, host_flags);
 
 	if (IS_A_TT()) {
 		error = request_irq(instance->irq, scsi_tt_intr, 0,
@@ -965,12 +964,16 @@ static int __init atari_scsi_probe(struct platform_device *pdev)
 		 *
 		 * In principle it should be sufficient to do max. 1 byte with
 		 * PIO, but there is another problem on the Medusa with the DMA
-		 * rest data register. So 'atari_read_overruns' is currently set
+		 * rest data register. So read_overruns is currently set
 		 * to 4 to avoid having transfers that aren't a multiple of 4.
 		 * If the rest data bug is fixed, this can be lowered to 1.
 		 */
-		if (MACH_IS_MEDUSA)
-			atari_read_overruns = 4;
+		if (MACH_IS_MEDUSA) {
+			struct NCR5380_hostdata *hostdata =
+				shost_priv(instance);
+
+			hostdata->read_overruns = 4;
+		}
 #endif
 	} else {
 		/* Nothing to do for the interrupt: the ST-DMA is initialized

commit f527590278f1b823ba979a234241d09ed2c436b4
Author: Finn Thain <fthain@telegraphics.com.au>
Date:   Wed Nov 12 16:12:13 2014 +1100

    ncr5380: Remove ENABLE_IRQ/DISABLE_IRQ macros
    
    atari_NCR5380.c enables its IRQ when it is already enabled. Sun3 doesn't
    use the ENABLE_IRQ/DISABLE_IRQ cruft. Remove it.
    
    Signed-off-by: Finn Thain <fthain@telegraphics.com.au>
    Reviewed-by: Hannes Reinecke <hare@suse.de>
    Tested-by: Michael Schmitz <schmitzmic@gmail.com>
    Signed-off-by: Christoph Hellwig <hch@lst.de>

diff --git a/drivers/scsi/atari_scsi.c b/drivers/scsi/atari_scsi.c
index e031f6dbcebc..78324e056d4c 100644
--- a/drivers/scsi/atari_scsi.c
+++ b/drivers/scsi/atari_scsi.c
@@ -157,23 +157,6 @@ static inline unsigned long SCSI_DMA_GETADR(void)
 	return adr;
 }
 
-static inline void ENABLE_IRQ(void)
-{
-	if (IS_A_TT())
-		atari_enable_irq(IRQ_TT_MFP_SCSI);
-	else
-		atari_enable_irq(IRQ_MFP_FSCSI);
-}
-
-static inline void DISABLE_IRQ(void)
-{
-	if (IS_A_TT())
-		atari_disable_irq(IRQ_TT_MFP_SCSI);
-	else
-		atari_disable_irq(IRQ_MFP_FSCSI);
-}
-
-
 #define HOSTDATA_DMALEN		(((struct NCR5380_hostdata *) \
 				(atari_scsi_host->hostdata))->dma_len)
 
@@ -373,10 +356,6 @@ static irqreturn_t scsi_tt_intr(int irq, void *dummy)
 
 	NCR5380_intr(irq, dummy);
 
-#if 0
-	/* To be sure the int is not masked */
-	atari_enable_irq(IRQ_TT_MFP_SCSI);
-#endif
 	return IRQ_HANDLED;
 }
 

commit 4e705205252ffc6979b938ab10facf765692f5cf
Author: Finn Thain <fthain@telegraphics.com.au>
Date:   Wed Nov 12 16:12:10 2014 +1100

    atari_scsi: Remove header
    
    The #defines in atari_scsi.h are intended to influence subsequent #includes
    in atari_scsi.c. IMHO, that's too convoluted.
    
    Remove atari_scsi.h by moving those macro definitions to atari_scsi.c,
    consistent with other NCR5380 drivers.
    
    Signed-off-by: Finn Thain <fthain@telegraphics.com.au>
    Reviewed-by: Hannes Reinecke <hare@suse.de>
    Tested-by: Michael Schmitz <schmitzmic@gmail.com>
    Signed-off-by: Christoph Hellwig <hch@lst.de>

diff --git a/drivers/scsi/atari_scsi.c b/drivers/scsi/atari_scsi.c
index b765e1c2277f..e031f6dbcebc 100644
--- a/drivers/scsi/atari_scsi.c
+++ b/drivers/scsi/atari_scsi.c
@@ -64,15 +64,7 @@
 /**************************************************************************/
 
 
-
 #include <linux/module.h>
-
-/* For the Atari version, use only polled IO or REAL_DMA */
-#define	REAL_DMA
-/* Support tagged queuing? (on devices that are able to... :-) */
-#define	SUPPORT_TAGS
-#define	MAX_TAGS 32
-
 #include <linux/types.h>
 #include <linux/delay.h>
 #include <linux/blkdev.h>
@@ -92,9 +84,34 @@
 
 #include <scsi/scsi_host.h>
 
-#include "atari_scsi.h"
+/* Definitions for the core NCR5380 driver. */
+
+#define REAL_DMA
+#define SUPPORT_TAGS
+#define MAX_TAGS                        32
+
+#define NCR5380_implementation_fields   /* none */
+
+#define NCR5380_read(reg)               atari_scsi_reg_read(reg)
+#define NCR5380_write(reg, value)       atari_scsi_reg_write(reg, value)
+
+#define NCR5380_queue_command           atari_scsi_queue_command
+#define NCR5380_abort                   atari_scsi_abort
+#define NCR5380_show_info               atari_scsi_show_info
+#define NCR5380_info                    atari_scsi_info
+
+#define NCR5380_dma_read_setup(instance, data, count) \
+        atari_scsi_dma_setup(instance, data, count, 0)
+#define NCR5380_dma_write_setup(instance, data, count) \
+        atari_scsi_dma_setup(instance, data, count, 1)
+#define NCR5380_dma_residual(instance) \
+        atari_scsi_dma_residual(instance)
+#define NCR5380_dma_xfer_len(instance, cmd, phase) \
+        atari_dma_xfer_len(cmd->SCp.this_residual, cmd, !((phase) & SR_IO))
+
 #include "NCR5380.h"
 
+
 #define	IS_A_TT()	ATARIHW_PRESENT(TT_SCSI)
 
 #define	SCSI_DMA_WRITE_P(elt,val)				\

commit 3ff228af84b57767645d81a89c166c777646ad61
Author: Finn Thain <fthain@telegraphics.com.au>
Date:   Wed Nov 12 16:12:09 2014 +1100

    atari_scsi: Convert to platform device
    
    Convert atari_scsi to platform device and eliminate scsi_register().
    
    Validate __setup options later on so that module options are checked as well.
    
    Remove the comment about the scsi mid-layer disabling the host irq as it
    is no longer true (AFAICT). Also remove the obsolete slow interrupt stuff
    (IRQ_TYPE_SLOW == 0 anyway).
    
    Signed-off-by: Finn Thain <fthain@telegraphics.com.au>
    Reviewed-by: Hannes Reinecke <hare@suse.de>
    Tested-by: Michael Schmitz <schmitzmic@gmail.com>
    Acked-by: Geert Uytterhoeven <geert@linux-m68k.org>
    Signed-off-by: Christoph Hellwig <hch@lst.de>

diff --git a/drivers/scsi/atari_scsi.c b/drivers/scsi/atari_scsi.c
index b2e86d0630ce..b765e1c2277f 100644
--- a/drivers/scsi/atari_scsi.c
+++ b/drivers/scsi/atari_scsi.c
@@ -74,33 +74,26 @@
 #define	MAX_TAGS 32
 
 #include <linux/types.h>
-#include <linux/stddef.h>
-#include <linux/ctype.h>
 #include <linux/delay.h>
-#include <linux/mm.h>
 #include <linux/blkdev.h>
 #include <linux/interrupt.h>
 #include <linux/init.h>
 #include <linux/nvram.h>
 #include <linux/bitops.h>
 #include <linux/wait.h>
+#include <linux/platform_device.h>
 
 #include <asm/setup.h>
 #include <asm/atarihw.h>
 #include <asm/atariints.h>
-#include <asm/page.h>
-#include <asm/pgtable.h>
-#include <asm/irq.h>
-#include <asm/traps.h>
-
-#include <scsi/scsi_host.h>
-#include "atari_scsi.h"
-#include "NCR5380.h"
 #include <asm/atari_stdma.h>
 #include <asm/atari_stram.h>
 #include <asm/io.h>
 
-#include <linux/stat.h>
+#include <scsi/scsi_host.h>
+
+#include "atari_scsi.h"
+#include "NCR5380.h"
 
 #define	IS_A_TT()	ATARIHW_PRESENT(TT_SCSI)
 
@@ -176,25 +169,9 @@ static inline void DISABLE_IRQ(void)
 #define	AFTER_RESET_DELAY	(5*HZ/2)
 #endif
 
-/***************************** Prototypes *****************************/
-
 #ifdef REAL_DMA
 static void atari_scsi_fetch_restbytes(void);
 #endif
-static irqreturn_t scsi_tt_intr(int irq, void *dummy);
-static irqreturn_t scsi_falcon_intr(int irq, void *dummy);
-static void falcon_release_lock_if_possible(struct NCR5380_hostdata *hostdata);
-static int falcon_get_lock(void);
-#ifdef CONFIG_ATARI_SCSI_RESET_BOOT
-static void atari_scsi_reset_boot(void);
-#endif
-static unsigned char atari_scsi_tt_reg_read(unsigned char reg);
-static void atari_scsi_tt_reg_write(unsigned char reg, unsigned char value);
-static unsigned char atari_scsi_falcon_reg_read(unsigned char reg);
-static void atari_scsi_falcon_reg_write(unsigned char reg, unsigned char value);
-
-/************************* End of Prototypes **************************/
-
 
 static struct Scsi_Host *atari_scsi_host;
 static unsigned char (*atari_scsi_reg_read)(unsigned char reg);
@@ -517,160 +494,12 @@ static int falcon_get_lock(void)
 	return 1;
 }
 
-
-static int __init atari_scsi_detect(struct scsi_host_template *host)
-{
-	static int called = 0;
-	struct Scsi_Host *instance;
-
-	if (!MACH_IS_ATARI ||
-	    (!ATARIHW_PRESENT(ST_SCSI) && !ATARIHW_PRESENT(TT_SCSI)) ||
-	    called)
-		return 0;
-
-	host->proc_name = "Atari";
-
-	atari_scsi_reg_read  = IS_A_TT() ? atari_scsi_tt_reg_read :
-					   atari_scsi_falcon_reg_read;
-	atari_scsi_reg_write = IS_A_TT() ? atari_scsi_tt_reg_write :
-					   atari_scsi_falcon_reg_write;
-
-	/* setup variables */
-	host->can_queue =
-		(setup_can_queue > 0) ? setup_can_queue :
-		IS_A_TT() ? ATARI_TT_CAN_QUEUE : ATARI_FALCON_CAN_QUEUE;
-	host->cmd_per_lun =
-		(setup_cmd_per_lun > 0) ? setup_cmd_per_lun :
-		IS_A_TT() ? ATARI_TT_CMD_PER_LUN : ATARI_FALCON_CMD_PER_LUN;
-	/* Force sg_tablesize to 0 on a Falcon! */
-	host->sg_tablesize =
-		!IS_A_TT() ? ATARI_FALCON_SG_TABLESIZE :
-		(setup_sg_tablesize >= 0) ? setup_sg_tablesize : ATARI_TT_SG_TABLESIZE;
-
-	if (setup_hostid >= 0)
-		host->this_id = setup_hostid;
-	else {
-		/* use 7 as default */
-		host->this_id = 7;
-		/* Test if a host id is set in the NVRam */
-		if (ATARIHW_PRESENT(TT_CLK) && nvram_check_checksum()) {
-			unsigned char b = nvram_read_byte( 14 );
-			/* Arbitration enabled? (for TOS) If yes, use configured host ID */
-			if (b & 0x80)
-				host->this_id = b & 7;
-		}
-	}
-
-#ifdef SUPPORT_TAGS
-	if (setup_use_tagged_queuing < 0)
-		setup_use_tagged_queuing = 0;
-#endif
-#ifdef REAL_DMA
-	/* If running on a Falcon and if there's TT-Ram (i.e., more than one
-	 * memory block, since there's always ST-Ram in a Falcon), then allocate a
-	 * STRAM_BUFFER_SIZE byte dribble buffer for transfers from/to alternative
-	 * Ram.
-	 */
-	if (MACH_IS_ATARI && ATARIHW_PRESENT(ST_SCSI) &&
-	    !ATARIHW_PRESENT(EXTD_DMA) && m68k_num_memory > 1) {
-		atari_dma_buffer = atari_stram_alloc(STRAM_BUFFER_SIZE, "SCSI");
-		if (!atari_dma_buffer) {
-			printk(KERN_ERR "atari_scsi_detect: can't allocate ST-RAM "
-					"double buffer\n");
-			return 0;
-		}
-		atari_dma_phys_buffer = atari_stram_to_phys(atari_dma_buffer);
-		atari_dma_orig_addr = 0;
-	}
-#endif
-	instance = scsi_register(host, sizeof(struct NCR5380_hostdata));
-	if (instance == NULL) {
-		atari_stram_free(atari_dma_buffer);
-		atari_dma_buffer = 0;
-		return 0;
-	}
-	atari_scsi_host = instance;
-	/*
-	 * Set irq to 0, to avoid that the mid-level code disables our interrupt
-	 * during queue_command calls. This is completely unnecessary, and even
-	 * worse causes bad problems on the Falcon, where the int is shared with
-	 * IDE and floppy!
-	 */
-       instance->irq = 0;
-
-#ifdef CONFIG_ATARI_SCSI_RESET_BOOT
-	atari_scsi_reset_boot();
-#endif
-	NCR5380_init(instance, 0);
-
-	if (IS_A_TT()) {
-
-		/* This int is actually "pseudo-slow", i.e. it acts like a slow
-		 * interrupt after having cleared the pending flag for the DMA
-		 * interrupt. */
-		if (request_irq(IRQ_TT_MFP_SCSI, scsi_tt_intr, IRQ_TYPE_SLOW,
-				 "SCSI NCR5380", instance)) {
-			printk(KERN_ERR "atari_scsi_detect: cannot allocate irq %d, aborting",IRQ_TT_MFP_SCSI);
-			scsi_unregister(atari_scsi_host);
-			atari_stram_free(atari_dma_buffer);
-			atari_dma_buffer = 0;
-			return 0;
-		}
-		tt_mfp.active_edge |= 0x80;		/* SCSI int on L->H */
-#ifdef REAL_DMA
-		tt_scsi_dma.dma_ctrl = 0;
-		atari_dma_residual = 0;
-
-		if (MACH_IS_MEDUSA) {
-			/* While the read overruns (described by Drew Eckhardt in
-			 * NCR5380.c) never happened on TTs, they do in fact on the Medusa
-			 * (This was the cause why SCSI didn't work right for so long
-			 * there.) Since handling the overruns slows down a bit, I turned
-			 * the #ifdef's into a runtime condition.
-			 *
-			 * In principle it should be sufficient to do max. 1 byte with
-			 * PIO, but there is another problem on the Medusa with the DMA
-			 * rest data register. So 'atari_read_overruns' is currently set
-			 * to 4 to avoid having transfers that aren't a multiple of 4. If
-			 * the rest data bug is fixed, this can be lowered to 1.
-			 */
-			atari_read_overruns = 4;
-		}
-#endif /*REAL_DMA*/
-	} else { /* ! IS_A_TT */
-
-		/* Nothing to do for the interrupt: the ST-DMA is initialized
-		 * already by atari_init_INTS()
-		 */
-
-#ifdef REAL_DMA
-		atari_dma_residual = 0;
-		atari_dma_active = 0;
-		atari_dma_stram_mask = (ATARIHW_PRESENT(EXTD_DMA) ? 0x00000000
-					: 0xff000000);
-#endif
-	}
-
-	called = 1;
-	return 1;
-}
-
-static int atari_scsi_release(struct Scsi_Host *sh)
-{
-	if (IS_A_TT())
-		free_irq(IRQ_TT_MFP_SCSI, sh);
-	if (atari_dma_buffer)
-		atari_stram_free(atari_dma_buffer);
-	NCR5380_exit(sh);
-	return 1;
-}
-
 #ifndef MODULE
 static int __init atari_scsi_setup(char *str)
 {
 	/* Format of atascsi parameter is:
 	 *   atascsi=<can_queue>,<cmd_per_lun>,<sg_tablesize>,<hostid>,<use_tags>
-	 * Defaults depend on TT or Falcon, hostid determined at run time.
+	 * Defaults depend on TT or Falcon, determined at run time.
 	 * Negative values mean don't change.
 	 */
 	int ints[6];
@@ -681,36 +510,17 @@ static int __init atari_scsi_setup(char *str)
 		printk("atari_scsi_setup: no arguments!\n");
 		return 0;
 	}
-
-	if (ints[0] >= 1) {
-		if (ints[1] > 0)
-			/* no limits on this, just > 0 */
-			setup_can_queue = ints[1];
-	}
-	if (ints[0] >= 2) {
-		if (ints[2] > 0)
-			setup_cmd_per_lun = ints[2];
-	}
-	if (ints[0] >= 3) {
-		if (ints[3] >= 0) {
-			setup_sg_tablesize = ints[3];
-			/* Must be <= SG_ALL (255) */
-			if (setup_sg_tablesize > SG_ALL)
-				setup_sg_tablesize = SG_ALL;
-		}
-	}
-	if (ints[0] >= 4) {
-		/* Must be between 0 and 7 */
-		if (ints[4] >= 0 && ints[4] <= 7)
-			setup_hostid = ints[4];
-		else if (ints[4] > 7)
-			printk("atari_scsi_setup: invalid host ID %d !\n", ints[4]);
-	}
+	if (ints[0] >= 1)
+		setup_can_queue = ints[1];
+	if (ints[0] >= 2)
+		setup_cmd_per_lun = ints[2];
+	if (ints[0] >= 3)
+		setup_sg_tablesize = ints[3];
+	if (ints[0] >= 4)
+		setup_hostid = ints[4];
 #ifdef SUPPORT_TAGS
-	if (ints[0] >= 5) {
-		if (ints[5] >= 0)
-			setup_use_tagged_queuing = !!ints[5];
-	}
+	if (ints[0] >= 5)
+		setup_use_tagged_queuing = ints[5];
 #endif
 
 	return 1;
@@ -1019,23 +829,209 @@ static int atari_scsi_bus_reset(struct scsi_cmnd *cmd)
 	return rv;
 }
 
-static struct scsi_host_template driver_template = {
+#define DRV_MODULE_NAME         "atari_scsi"
+#define PFX                     DRV_MODULE_NAME ": "
+
+static struct scsi_host_template atari_scsi_template = {
+	.module			= THIS_MODULE,
+	.proc_name		= DRV_MODULE_NAME,
 	.show_info		= atari_scsi_show_info,
 	.name			= "Atari native SCSI",
-	.detect			= atari_scsi_detect,
-	.release		= atari_scsi_release,
 	.info			= atari_scsi_info,
 	.queuecommand		= atari_scsi_queue_command,
 	.eh_abort_handler	= atari_scsi_abort,
 	.eh_bus_reset_handler	= atari_scsi_bus_reset,
-	.can_queue		= 0, /* initialized at run-time */
-	.this_id		= 0, /* initialized at run-time */
-	.sg_tablesize		= 0, /* initialized at run-time */
-	.cmd_per_lun		= 0, /* initialized at run-time */
+	.this_id		= 7,
 	.use_clustering		= DISABLE_CLUSTERING
 };
 
+static int __init atari_scsi_probe(struct platform_device *pdev)
+{
+	struct Scsi_Host *instance;
+	int error;
+	struct resource *irq;
+
+	irq = platform_get_resource(pdev, IORESOURCE_IRQ, 0);
+	if (!irq)
+		return -ENODEV;
+
+	if (ATARIHW_PRESENT(TT_SCSI)) {
+		atari_scsi_reg_read  = atari_scsi_tt_reg_read;
+		atari_scsi_reg_write = atari_scsi_tt_reg_write;
+	} else {
+		atari_scsi_reg_read  = atari_scsi_falcon_reg_read;
+		atari_scsi_reg_write = atari_scsi_falcon_reg_write;
+	}
+
+	/* The values for CMD_PER_LUN and CAN_QUEUE are somehow arbitrary.
+	 * Higher values should work, too; try it!
+	 * (But cmd_per_lun costs memory!)
+	 *
+	 * But there seems to be a bug somewhere that requires CAN_QUEUE to be
+	 * 2*CMD_PER_LUN. At least on a TT, no spurious timeouts seen since
+	 * changed CMD_PER_LUN...
+	 *
+	 * Note: The Falcon currently uses 8/1 setting due to unsolved problems
+	 * with cmd_per_lun != 1
+	 */
+	if (ATARIHW_PRESENT(TT_SCSI)) {
+		atari_scsi_template.can_queue    = 16;
+		atari_scsi_template.cmd_per_lun  = 8;
+		atari_scsi_template.sg_tablesize = SG_ALL;
+	} else {
+		atari_scsi_template.can_queue    = 8;
+		atari_scsi_template.cmd_per_lun  = 1;
+		atari_scsi_template.sg_tablesize = SG_NONE;
+	}
+
+	if (setup_can_queue > 0)
+		atari_scsi_template.can_queue = setup_can_queue;
+
+	if (setup_cmd_per_lun > 0)
+		atari_scsi_template.cmd_per_lun = setup_cmd_per_lun;
+
+	/* Leave sg_tablesize at 0 on a Falcon! */
+	if (ATARIHW_PRESENT(TT_SCSI) && setup_sg_tablesize >= 0)
+		atari_scsi_template.sg_tablesize = setup_sg_tablesize;
+
+	if (setup_hostid >= 0) {
+		atari_scsi_template.this_id = setup_hostid & 7;
+	} else {
+		/* Test if a host id is set in the NVRam */
+		if (ATARIHW_PRESENT(TT_CLK) && nvram_check_checksum()) {
+			unsigned char b = nvram_read_byte(14);
+
+			/* Arbitration enabled? (for TOS)
+			 * If yes, use configured host ID
+			 */
+			if (b & 0x80)
+				atari_scsi_template.this_id = b & 7;
+		}
+	}
+
+#ifdef SUPPORT_TAGS
+	if (setup_use_tagged_queuing < 0)
+		setup_use_tagged_queuing = 0;
+#endif
+
+#ifdef REAL_DMA
+	/* If running on a Falcon and if there's TT-Ram (i.e., more than one
+	 * memory block, since there's always ST-Ram in a Falcon), then
+	 * allocate a STRAM_BUFFER_SIZE byte dribble buffer for transfers
+	 * from/to alternative Ram.
+	 */
+	if (ATARIHW_PRESENT(ST_SCSI) && !ATARIHW_PRESENT(EXTD_DMA) &&
+	    m68k_num_memory > 1) {
+		atari_dma_buffer = atari_stram_alloc(STRAM_BUFFER_SIZE, "SCSI");
+		if (!atari_dma_buffer) {
+			pr_err(PFX "can't allocate ST-RAM double buffer\n");
+			return -ENOMEM;
+		}
+		atari_dma_phys_buffer = atari_stram_to_phys(atari_dma_buffer);
+		atari_dma_orig_addr = 0;
+	}
+#endif
+
+	instance = scsi_host_alloc(&atari_scsi_template,
+	                           sizeof(struct NCR5380_hostdata));
+	if (!instance) {
+		error = -ENOMEM;
+		goto fail_alloc;
+	}
+	atari_scsi_host = instance;
+
+#ifdef CONFIG_ATARI_SCSI_RESET_BOOT
+	atari_scsi_reset_boot();
+#endif
+
+	instance->irq = irq->start;
+
+	NCR5380_init(instance, 0);
+
+	if (IS_A_TT()) {
+		error = request_irq(instance->irq, scsi_tt_intr, 0,
+		                    "NCR5380", instance);
+		if (error) {
+			pr_err(PFX "request irq %d failed, aborting\n",
+			       instance->irq);
+			goto fail_irq;
+		}
+		tt_mfp.active_edge |= 0x80;	/* SCSI int on L->H */
+#ifdef REAL_DMA
+		tt_scsi_dma.dma_ctrl = 0;
+		atari_dma_residual = 0;
+
+		/* While the read overruns (described by Drew Eckhardt in
+		 * NCR5380.c) never happened on TTs, they do in fact on the
+		 * Medusa (This was the cause why SCSI didn't work right for
+		 * so long there.) Since handling the overruns slows down
+		 * a bit, I turned the #ifdef's into a runtime condition.
+		 *
+		 * In principle it should be sufficient to do max. 1 byte with
+		 * PIO, but there is another problem on the Medusa with the DMA
+		 * rest data register. So 'atari_read_overruns' is currently set
+		 * to 4 to avoid having transfers that aren't a multiple of 4.
+		 * If the rest data bug is fixed, this can be lowered to 1.
+		 */
+		if (MACH_IS_MEDUSA)
+			atari_read_overruns = 4;
+#endif
+	} else {
+		/* Nothing to do for the interrupt: the ST-DMA is initialized
+		 * already.
+		 */
+#ifdef REAL_DMA
+		atari_dma_residual = 0;
+		atari_dma_active = 0;
+		atari_dma_stram_mask = (ATARIHW_PRESENT(EXTD_DMA) ? 0x00000000
+					: 0xff000000);
+#endif
+	}
+
+	error = scsi_add_host(instance, NULL);
+	if (error)
+		goto fail_host;
+
+	platform_set_drvdata(pdev, instance);
+
+	scsi_scan_host(instance);
+	return 0;
+
+fail_host:
+	if (IS_A_TT())
+		free_irq(instance->irq, instance);
+fail_irq:
+	NCR5380_exit(instance);
+	scsi_host_put(instance);
+fail_alloc:
+	if (atari_dma_buffer)
+		atari_stram_free(atari_dma_buffer);
+	return error;
+}
+
+static int __exit atari_scsi_remove(struct platform_device *pdev)
+{
+	struct Scsi_Host *instance = platform_get_drvdata(pdev);
+
+	scsi_remove_host(instance);
+	if (IS_A_TT())
+		free_irq(instance->irq, instance);
+	NCR5380_exit(instance);
+	scsi_host_put(instance);
+	if (atari_dma_buffer)
+		atari_stram_free(atari_dma_buffer);
+	return 0;
+}
+
+static struct platform_driver atari_scsi_driver = {
+	.remove = __exit_p(atari_scsi_remove),
+	.driver = {
+		.name	= DRV_MODULE_NAME,
+		.owner	= THIS_MODULE,
+	},
+};
 
-#include "scsi_module.c"
+module_platform_driver_probe(atari_scsi_driver, atari_scsi_probe);
 
+MODULE_ALIAS("platform:" DRV_MODULE_NAME);
 MODULE_LICENSE("GPL");

commit 16b29e75a78ae03250233468b68f7ae467d3dc7a
Author: Finn Thain <fthain@telegraphics.com.au>
Date:   Wed Nov 12 16:12:08 2014 +1100

    atari_scsi: Fix atari_scsi deadlocks on Falcon
    
    Don't disable irqs when waiting for the ST DMA "lock"; its release may
    require an interrupt.
    
    Introduce stdma_try_lock() for use in soft irq context. atari_scsi now tells
    the SCSI mid-layer to defer queueing a command if the ST DMA lock is not
    available, as per Michael's patch:
    http://marc.info/?l=linux-m68k&m=139095335824863&w=2
    
    The falcon_got_lock variable is race prone: we can't disable IRQs while
    waiting to acquire the lock, so after acquiring it there must be some
    interval during which falcon_got_lock remains false. Introduce
    stdma_is_locked_by() to replace falcon_got_lock.
    
    The falcon_got_lock tests in the EH handlers are incorrect these days. It
    can happen that an EH handler is called after a command completes normally.
    Remove these checks along with falcon_got_lock.
    
    Also remove the complicated and racy fairness wait queues. If fairness is an
    issue (when SCSI competes with IDE for the ST DMA interrupt), the solution
    is likely to be a lower value for host->can_queue.
    
    Signed-off-by: Finn Thain <fthain@telegraphics.com.au>
    Reviewed-by: Hannes Reinecke <hare@suse.de>
    Tested-by: Michael Schmitz <schmitzmic@gmail.com>
    Acked-by: Geert Uytterhoeven <geert@linux-m68k.org>
    Signed-off-by: Christoph Hellwig <hch@lst.de>

diff --git a/drivers/scsi/atari_scsi.c b/drivers/scsi/atari_scsi.c
index 48fabebdbbb0..b2e86d0630ce 100644
--- a/drivers/scsi/atari_scsi.c
+++ b/drivers/scsi/atari_scsi.c
@@ -184,7 +184,7 @@ static void atari_scsi_fetch_restbytes(void);
 static irqreturn_t scsi_tt_intr(int irq, void *dummy);
 static irqreturn_t scsi_falcon_intr(int irq, void *dummy);
 static void falcon_release_lock_if_possible(struct NCR5380_hostdata *hostdata);
-static void falcon_get_lock(void);
+static int falcon_get_lock(void);
 #ifdef CONFIG_ATARI_SCSI_RESET_BOOT
 static void atari_scsi_reset_boot(void);
 #endif
@@ -473,17 +473,10 @@ static void atari_scsi_fetch_restbytes(void)
 #endif /* REAL_DMA */
 
 
-static int falcon_got_lock = 0;
-static DECLARE_WAIT_QUEUE_HEAD(falcon_fairness_wait);
-static int falcon_trying_lock = 0;
-static DECLARE_WAIT_QUEUE_HEAD(falcon_try_wait);
 static int falcon_dont_release = 0;
 
 /* This function releases the lock on the DMA chip if there is no
- * connected command and the disconnected queue is empty. On
- * releasing, instances of falcon_get_lock are awoken, that put
- * themselves to sleep for fairness. They can now try to get the lock
- * again (but others waiting longer more probably will win).
+ * connected command and the disconnected queue is empty.
  */
 
 static void falcon_release_lock_if_possible(struct NCR5380_hostdata *hostdata)
@@ -495,20 +488,12 @@ static void falcon_release_lock_if_possible(struct NCR5380_hostdata *hostdata)
 
 	local_irq_save(flags);
 
-	if (falcon_got_lock && !hostdata->disconnected_queue &&
-	    !hostdata->issue_queue && !hostdata->connected) {
-
-		if (falcon_dont_release) {
-#if 0
-			printk("WARNING: Lock release not allowed. Ignored\n");
-#endif
-			local_irq_restore(flags);
-			return;
-		}
-		falcon_got_lock = 0;
+	if (!hostdata->disconnected_queue &&
+	    !hostdata->issue_queue &&
+	    !hostdata->connected &&
+	    !falcon_dont_release &&
+	    stdma_is_locked_by(scsi_falcon_intr))
 		stdma_release();
-		wake_up(&falcon_fairness_wait);
-	}
 
 	local_irq_restore(flags);
 }
@@ -517,51 +502,19 @@ static void falcon_release_lock_if_possible(struct NCR5380_hostdata *hostdata)
  * If the DMA isn't locked already for SCSI, it tries to lock it by
  * calling stdma_lock(). But if the DMA is locked by the SCSI code and
  * there are other drivers waiting for the chip, we do not issue the
- * command immediately but wait on 'falcon_fairness_queue'. We will be
- * waked up when the DMA is unlocked by some SCSI interrupt. After that
- * we try to get the lock again.
- * But we must be prepared that more than one instance of
- * falcon_get_lock() is waiting on the fairness queue. They should not
- * try all at once to call stdma_lock(), one is enough! For that, the
- * first one sets 'falcon_trying_lock', others that see that variable
- * set wait on the queue 'falcon_try_wait'.
- * Complicated, complicated.... Sigh...
+ * command immediately but tell the SCSI mid-layer to defer.
  */
 
-static void falcon_get_lock(void)
+static int falcon_get_lock(void)
 {
-	unsigned long flags;
-
 	if (IS_A_TT())
-		return;
+		return 1;
 
-	local_irq_save(flags);
+	if (in_interrupt())
+		return stdma_try_lock(scsi_falcon_intr, NULL);
 
-	wait_event_cmd(falcon_fairness_wait,
-		in_interrupt() || !falcon_got_lock || !stdma_others_waiting(),
-		local_irq_restore(flags),
-		local_irq_save(flags));
-
-	while (!falcon_got_lock) {
-		if (in_irq())
-			panic("Falcon SCSI hasn't ST-DMA lock in interrupt");
-		if (!falcon_trying_lock) {
-			falcon_trying_lock = 1;
-			stdma_lock(scsi_falcon_intr, NULL);
-			falcon_got_lock = 1;
-			falcon_trying_lock = 0;
-			wake_up(&falcon_try_wait);
-		} else {
-			wait_event_cmd(falcon_try_wait,
-				falcon_got_lock && !falcon_trying_lock,
-				local_irq_restore(flags),
-				local_irq_save(flags));
-		}
-	}
-
-	local_irq_restore(flags);
-	if (!falcon_got_lock)
-		panic("Falcon SCSI: someone stole the lock :-(\n");
+	stdma_lock(scsi_falcon_intr, NULL);
+	return 1;
 }
 
 

commit 710ddd0d50d22b40e3b644ea35966489ad178978
Author: Finn Thain <fthain@telegraphics.com.au>
Date:   Wed Nov 12 16:12:02 2014 +1100

    ncr5380: Drop legacy scsi.h include
    
    Convert Scsi_Cmnd to struct scsi_cmnd and drop the #include "scsi.h".
    The sun3_NCR5380.c core driver already uses struct scsi_cmnd so converting
    the other core drivers reduces the diff which makes them easier to unify.
    
    Signed-off-by: Finn Thain <fthain@telegraphics.com.au>
    Reviewed-by: Hannes Reinecke <hare@suse.de>
    Tested-by: Michael Schmitz <schmitzmic@gmail.com>
    Signed-off-by: Christoph Hellwig <hch@lst.de>

diff --git a/drivers/scsi/atari_scsi.c b/drivers/scsi/atari_scsi.c
index 0e3a9cc40c94..48fabebdbbb0 100644
--- a/drivers/scsi/atari_scsi.c
+++ b/drivers/scsi/atari_scsi.c
@@ -93,7 +93,6 @@
 #include <asm/irq.h>
 #include <asm/traps.h>
 
-#include "scsi.h"
 #include <scsi/scsi_host.h>
 #include "atari_scsi.h"
 #include "NCR5380.h"
@@ -880,7 +879,7 @@ static long atari_scsi_dma_residual(struct Scsi_Host *instance)
 #define	CMD_SURELY_BYTE_MODE	1
 #define	CMD_MODE_UNKNOWN		2
 
-static int falcon_classify_cmd(Scsi_Cmnd *cmd)
+static int falcon_classify_cmd(struct scsi_cmnd *cmd)
 {
 	unsigned char opcode = cmd->cmnd[0];
 
@@ -912,7 +911,7 @@ static int falcon_classify_cmd(Scsi_Cmnd *cmd)
  */
 
 static unsigned long atari_dma_xfer_len(unsigned long wanted_len,
-					Scsi_Cmnd *cmd, int write_flag)
+					struct scsi_cmnd *cmd, int write_flag)
 {
 	unsigned long	possible_len, limit;
 

commit d572f65fdf78a6dcb55b86ad8684f88830bf2e08
Author: Finn Thain <fthain@telegraphics.com.au>
Date:   Wed Nov 12 16:12:00 2014 +1100

    ncr5380: Remove pointless compiler command line override macros
    
    Compile-time override of scsi host defaults is pointless for drivers that
    provide module parameters and __setup options for that. Too many macros make
    the code hard to read so remove them.
    
    Signed-off-by: Finn Thain <fthain@telegraphics.com.au>
    Reviewed-by: Hannes Reinecke <hare@suse.de>
    Tested-by: Michael Schmitz <schmitzmic@gmail.com>
    Signed-off-by: Christoph Hellwig <hch@lst.de>

diff --git a/drivers/scsi/atari_scsi.c b/drivers/scsi/atari_scsi.c
index 1022a391c82a..0e3a9cc40c94 100644
--- a/drivers/scsi/atari_scsi.c
+++ b/drivers/scsi/atari_scsi.c
@@ -611,7 +611,7 @@ static int __init atari_scsi_detect(struct scsi_host_template *host)
 
 #ifdef SUPPORT_TAGS
 	if (setup_use_tagged_queuing < 0)
-		setup_use_tagged_queuing = DEFAULT_USE_TAGGED_QUEUING;
+		setup_use_tagged_queuing = 0;
 #endif
 #ifdef REAL_DMA
 	/* If running on a Falcon and if there's TT-Ram (i.e., more than one

commit 8c32513bd395dc5d382e4883097482567cf8bbc5
Author: Finn Thain <fthain@telegraphics.com.au>
Date:   Wed Nov 12 16:11:58 2014 +1100

    ncr5380: Cleanup host info() methods
    
    If the host->info() method is not set, then host->name is used by default.
    For atari_scsi, that is exactly the same text. So remove the redundant
    info() method. Keep sun3_scsi.c in line with atari_scsi.
    
    Some NCR5380 drivers return an empty string from the info() method
    (arm/cumana_1.c arm/oak.c mac_scsi.c) while other drivers use the default
    (dmx3191d dtc.c g_NCR5380.c pas16.c t128.c).
    
    Implement a common info() method to replace a lot of duplicated code which
    the various drivers use to announce the same information.
    
    This replaces most of the (deprecated) show_info() output and all of the
    NCR5380_print_info() output. This also eliminates a bunch of code in
    g_NCR5380 which just duplicates functionality in the core driver.
    
    Signed-off-by: Finn Thain <fthain@telegraphics.com.au>
    Reviewed-by: Hannes Reinecke <hare@suse.de>
    Tested-by: Michael Schmitz <schmitzmic@gmail.com>
    Signed-off-by: Christoph Hellwig <hch@lst.de>

diff --git a/drivers/scsi/atari_scsi.c b/drivers/scsi/atari_scsi.c
index 9f4d58ca3647..1022a391c82a 100644
--- a/drivers/scsi/atari_scsi.c
+++ b/drivers/scsi/atari_scsi.c
@@ -699,21 +699,6 @@ static int __init atari_scsi_detect(struct scsi_host_template *host)
 #endif
 	}
 
-	printk(KERN_INFO "scsi%d: options CAN_QUEUE=%d CMD_PER_LUN=%d SCAT-GAT=%d "
-#ifdef SUPPORT_TAGS
-			"TAGGED-QUEUING=%s "
-#endif
-			"HOSTID=%d",
-			instance->host_no, instance->hostt->can_queue,
-			instance->hostt->cmd_per_lun,
-			instance->hostt->sg_tablesize,
-#ifdef SUPPORT_TAGS
-			setup_use_tagged_queuing ? "yes" : "no",
-#endif
-			instance->hostt->this_id );
-	NCR5380_print_options(instance);
-	printk("\n");
-
 	called = 1;
 	return 1;
 }
@@ -815,15 +800,6 @@ static void __init atari_scsi_reset_boot(void)
 }
 #endif
 
-
-static const char *atari_scsi_info(struct Scsi_Host *host)
-{
-	/* atari_scsi_detect() is verbose enough... */
-	static const char string[] = "Atari native SCSI";
-	return string;
-}
-
-
 #if defined(REAL_DMA)
 
 static unsigned long atari_scsi_dma_setup(struct Scsi_Host *instance,

commit 997acab7d593913eaa0606ff257079efcfcb146d
Author: Finn Thain <fthain@telegraphics.com.au>
Date:   Wed Nov 12 16:11:54 2014 +1100

    ncr5380: Remove redundant AUTOSENSE macro
    
    Every NCR5380 driver sets AUTOSENSE so it need not be optional (and the
    mid-layer expects it). Remove this redundant macro to improve readability.
    
    Signed-off-by: Finn Thain <fthain@telegraphics.com.au>
    Reviewed-by: Hannes Reinecke <hare@suse.de>
    Tested-by: Michael Schmitz <schmitzmic@gmail.com>
    Signed-off-by: Christoph Hellwig <hch@lst.de>

diff --git a/drivers/scsi/atari_scsi.c b/drivers/scsi/atari_scsi.c
index a68d6257bc68..9f4d58ca3647 100644
--- a/drivers/scsi/atari_scsi.c
+++ b/drivers/scsi/atari_scsi.c
@@ -67,7 +67,6 @@
 
 #include <linux/module.h>
 
-#define AUTOSENSE
 /* For the Atari version, use only polled IO or REAL_DMA */
 #define	REAL_DMA
 /* Support tagged queuing? (on devices that are able to... :-) */

commit 4d3d2a54f731aa25f66adcf934ba9a55ca8204d4
Author: Finn Thain <fthain@telegraphics.com.au>
Date:   Wed Nov 12 16:11:52 2014 +1100

    ncr5380: Remove more useless prototypes
    
    Make use of the host template static initializer instead of assigning
    handlers at run-time. Move __maybe_unused qualifiers from declarations
    to definitions. Move the atari_scsi_bus_reset() wrapper after the
    definition of NCR5380_bus_reset(). All of the host template handler
    prototypes are now redundant so remove them.
    
    The write_info() handler is only relevant to drivers using PSEUDO_DMA so
    this patch fixes the compiler warning in atari_NCR5380.c and sun3_NCR5380.c:
    
      CC      drivers/scsi/atari_scsi.o
      drivers/scsi/NCR5380.h:329: warning: 'NCR5380_write_info' declared 'static' but never defined
    
    Signed-off-by: Finn Thain <fthain@telegraphics.com.au>
    Tested-by: Michael Schmitz <schmitzmic@gmail.com>
    Reviewed-by: Hannes Reinecke <hare@suse.de>
    Signed-off-by: Christoph Hellwig <hch@lst.de>

diff --git a/drivers/scsi/atari_scsi.c b/drivers/scsi/atari_scsi.c
index 151beea19b9a..a68d6257bc68 100644
--- a/drivers/scsi/atari_scsi.c
+++ b/drivers/scsi/atari_scsi.c
@@ -783,45 +783,6 @@ static int __init atari_scsi_setup(char *str)
 __setup("atascsi=", atari_scsi_setup);
 #endif /* !MODULE */
 
-static int atari_scsi_bus_reset(Scsi_Cmnd *cmd)
-{
-	int rv;
-	struct NCR5380_hostdata *hostdata =
-		(struct NCR5380_hostdata *)cmd->device->host->hostdata;
-
-	/* For doing the reset, SCSI interrupts must be disabled first,
-	 * since the 5380 raises its IRQ line while _RST is active and we
-	 * can't disable interrupts completely, since we need the timer.
-	 */
-	/* And abort a maybe active DMA transfer */
-	if (IS_A_TT()) {
-		atari_turnoff_irq(IRQ_TT_MFP_SCSI);
-#ifdef REAL_DMA
-		tt_scsi_dma.dma_ctrl = 0;
-#endif /* REAL_DMA */
-	} else {
-		atari_turnoff_irq(IRQ_MFP_FSCSI);
-#ifdef REAL_DMA
-		st_dma.dma_mode_status = 0x90;
-		atari_dma_active = 0;
-		atari_dma_orig_addr = NULL;
-#endif /* REAL_DMA */
-	}
-
-	rv = NCR5380_bus_reset(cmd);
-
-	/* Re-enable ints */
-	if (IS_A_TT()) {
-		atari_turnon_irq(IRQ_TT_MFP_SCSI);
-	} else {
-		atari_turnon_irq(IRQ_MFP_FSCSI);
-	}
-	if (rv == SUCCESS)
-		falcon_release_lock_if_possible(hostdata);
-
-	return rv;
-}
-
 
 #ifdef CONFIG_ATARI_SCSI_RESET_BOOT
 static void __init atari_scsi_reset_boot(void)
@@ -1094,6 +1055,43 @@ static void atari_scsi_falcon_reg_write(unsigned char reg, unsigned char value)
 
 #include "atari_NCR5380.c"
 
+static int atari_scsi_bus_reset(struct scsi_cmnd *cmd)
+{
+	int rv;
+	struct NCR5380_hostdata *hostdata = shost_priv(cmd->device->host);
+
+	/* For doing the reset, SCSI interrupts must be disabled first,
+	 * since the 5380 raises its IRQ line while _RST is active and we
+	 * can't disable interrupts completely, since we need the timer.
+	 */
+	/* And abort a maybe active DMA transfer */
+	if (IS_A_TT()) {
+		atari_turnoff_irq(IRQ_TT_MFP_SCSI);
+#ifdef REAL_DMA
+		tt_scsi_dma.dma_ctrl = 0;
+#endif
+	} else {
+		atari_turnoff_irq(IRQ_MFP_FSCSI);
+#ifdef REAL_DMA
+		st_dma.dma_mode_status = 0x90;
+		atari_dma_active = 0;
+		atari_dma_orig_addr = NULL;
+#endif
+	}
+
+	rv = NCR5380_bus_reset(cmd);
+
+	if (IS_A_TT())
+		atari_turnon_irq(IRQ_TT_MFP_SCSI);
+	else
+		atari_turnon_irq(IRQ_MFP_FSCSI);
+
+	if (rv == SUCCESS)
+		falcon_release_lock_if_possible(hostdata);
+
+	return rv;
+}
+
 static struct scsi_host_template driver_template = {
 	.show_info		= atari_scsi_show_info,
 	.name			= "Atari native SCSI",

commit ed8b9e7f1827ebae902e868866438d1bcdbef0a2
Author: Finn Thain <fthain@telegraphics.com.au>
Date:   Wed Nov 12 16:11:51 2014 +1100

    ncr5380: Remove useless prototypes
    
    Add missing static qualifiers and remove the now pointless prototypes. The
    NCR5380_* prototypes are all declared in NCR5380.h and renamed using macros.
    Further declarations are redundant (some are completely unused). Remove
    them.
    
    Signed-off-by: Finn Thain <fthain@telegraphics.com.au>
    Reviewed-by: Hannes Reinecke <hare@suse.de>
    Tested-by: Michael Schmitz <schmitzmic@gmail.com>
    Signed-off-by: Christoph Hellwig <hch@lst.de>

diff --git a/drivers/scsi/atari_scsi.c b/drivers/scsi/atari_scsi.c
index b522134528d6..151beea19b9a 100644
--- a/drivers/scsi/atari_scsi.c
+++ b/drivers/scsi/atari_scsi.c
@@ -181,12 +181,7 @@ static inline void DISABLE_IRQ(void)
 /***************************** Prototypes *****************************/
 
 #ifdef REAL_DMA
-static int scsi_dma_is_ignored_buserr(unsigned char dma_stat);
 static void atari_scsi_fetch_restbytes(void);
-static long atari_scsi_dma_residual(struct Scsi_Host *instance);
-static int falcon_classify_cmd(Scsi_Cmnd *cmd);
-static unsigned long atari_dma_xfer_len(unsigned long wanted_len,
-					Scsi_Cmnd *cmd, int write_flag);
 #endif
 static irqreturn_t scsi_tt_intr(int irq, void *dummy);
 static irqreturn_t scsi_falcon_intr(int irq, void *dummy);

commit 1c54fc1efe6922b4e7ffd591739d72050976ccd6
Merge: f4f9b8fc73f9 b4c43993f448
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Mon Jun 9 18:54:06 2014 -0700

    Merge tag 'scsi-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/jejb/scsi
    
    Pull SCSI updates from James Bottomley:
     "This patch consists of the usual driver updates (qla2xxx, qla4xxx,
      lpfc, be2iscsi, fnic, ufs, NCR5380) The NCR5380 is the addition to
      maintained status of a long neglected driver for older hardware.  In
      addition there are a lot of minor fixes and cleanups and some more
      updates to make scsi mq ready"
    
    * tag 'scsi-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/jejb/scsi: (130 commits)
      include/scsi/osd_protocol.h: remove unnecessary __constant
      mvsas: Recognise device/subsystem 9485/9485 as 88SE9485
      Revert "be2iscsi: Fix processing cqe for cxn whose endpoint is freed"
      mptfusion: fix msgContext in mptctl_hp_hostinfo
      acornscsi: remove linked command support
      scsi/NCR5380: dprintk macro
      fusion: Remove use of DEF_SCSI_QCMD
      fusion: Add free msg frames to the head, not tail of list
      mpt2sas: Add free smids to the head, not tail of list
      mpt2sas: Remove use of DEF_SCSI_QCMD
      mpt2sas: Remove uses of serial_number
      mpt3sas: Remove use of DEF_SCSI_QCMD
      mpt3sas: Remove uses of serial_number
      qla2xxx: Use kmemdup instead of kmalloc + memcpy
      qla4xxx: Use kmemdup instead of kmalloc + memcpy
      qla2xxx: fix incorrect debug printk
      be2iscsi: Bump the driver version
      be2iscsi: Fix processing cqe for cxn whose endpoint is freed
      be2iscsi: Fix destroy MCC-CQ before MCC-EQ is destroyed
      be2iscsi: Fix memory corruption in MBX path
      ...

commit 9829e52897359a17169410960e2a9dfcababb83b
Author: Finn Thain <fthain@telegraphics.com.au>
Date:   Tue Mar 18 11:42:21 2014 +1100

    scsi/NCR5380: fix and standardize NDEBUG macros
    
    All three NCR5380 core driver implementations share the same NCR5380.h
    header file so they need to agree on certain macro definitions.
    
    The flag bit used by the NDEBUG_MERGING macro in atari_NCR5380 and
    sun3_NCR5380 collides with the bit used by NDEBUG_LISTS.
    
    Moreover, NDEBUG_ABORT appears in NCR5380.c so it should be defined in
    NCR5380.h rather than in each of the many drivers using that core.
    
    An undefined NDEBUG_ABORT macro caused compiler errors and led to dodgy
    workarounds in the core driver that can now be removed.
    (See commits f566a576bca09de85bf477fc0ab2c8c96405b77b and
    185a7a1cd79b9891e3c17abdb103ba1c98d6ca7a.)
    
    Move all of the NDEBUG_ABORT, NDEBUG_TAGS and NDEBUG_MERGING macro
    definitions into NCR5380.h where all the other NDEBUG macros live.
    
    Also, incorrect "#ifdef NDEBUG" becomes "#if NDEBUG" to fix the warning:
    drivers/scsi/mac_scsi.c: At top level:
    drivers/scsi/NCR5380.c:418: warning: 'NCR5380_print' defined but not used
    drivers/scsi/NCR5380.c:459: warning: 'NCR5380_print_phase' defined but not used
    
    The debugging code is now enabled when NDEBUG != 0.
    
    Signed-off-by: Finn Thain <fthain@telegraphics.com.au>
    Acked-by: Sam Creasey <sammy@sammy.net>
    Signed-off-by: Christoph Hellwig <hch@lst.de>

diff --git a/drivers/scsi/atari_scsi.c b/drivers/scsi/atari_scsi.c
index c66b4caee9c6..b51aa54ecf0f 100644
--- a/drivers/scsi/atari_scsi.c
+++ b/drivers/scsi/atari_scsi.c
@@ -67,12 +67,6 @@
 
 #include <linux/module.h>
 
-#define NDEBUG (0)
-
-#define NDEBUG_ABORT		0x00100000
-#define NDEBUG_TAGS		0x00200000
-#define NDEBUG_MERGING		0x00400000
-
 #define AUTOSENSE
 /* For the Atari version, use only polled IO or REAL_DMA */
 #define	REAL_DMA

commit d65e634a86e681ffd36717cde63fb81edbb6f719
Author: Finn Thain <fthain@telegraphics.com.au>
Date:   Tue Mar 18 11:42:20 2014 +1100

    scsi/NCR5380: adopt dprintk()
    
    All NCR5380 drivers already include the NCR5380.h header. Better to
    adopt those macros rather than have three variations on them.
    
    Moreover, the macros in NCR5380.h are preferable because the atari_NCR5380
    and sun3_NCR5380 versions are inflexible. For example, they can't accomodate
    dprintk(NDEBUG_MAIN | NDEBUG_QUEUES, ...)
    
    Replace the *_PRINTK macros from atari_NCR5380.h and sun3_NCR5380.h with
    the equivalent macros from NCR5380.h.
    
    Signed-off-by: Finn Thain <fthain@telegraphics.com.au>
    Acked-by: Sam Creasey <sammy@sammy.net>
    Acked-by: Michael Schmitz <schmitz@debian.org>
    Signed-off-by: Christoph Hellwig <hch@lst.de>

diff --git a/drivers/scsi/atari_scsi.c b/drivers/scsi/atari_scsi.c
index 4ae0c1a29598..c66b4caee9c6 100644
--- a/drivers/scsi/atari_scsi.c
+++ b/drivers/scsi/atari_scsi.c
@@ -314,7 +314,7 @@ static irqreturn_t scsi_tt_intr(int irq, void *dummy)
 
 	dma_stat = tt_scsi_dma.dma_ctrl;
 
-	INT_PRINTK("scsi%d: NCR5380 interrupt, DMA status = %02x\n",
+	dprintk(NDEBUG_INTR, "scsi%d: NCR5380 interrupt, DMA status = %02x\n",
 		   atari_scsi_host->host_no, dma_stat & 0xff);
 
 	/* Look if it was the DMA that has interrupted: First possibility
@@ -340,7 +340,7 @@ static irqreturn_t scsi_tt_intr(int irq, void *dummy)
 	if ((dma_stat & 0x02) && !(dma_stat & 0x40)) {
 		atari_dma_residual = HOSTDATA_DMALEN - (SCSI_DMA_READ_P(dma_addr) - atari_dma_startaddr);
 
-		DMA_PRINTK("SCSI DMA: There are %ld residual bytes.\n",
+		dprintk(NDEBUG_DMA, "SCSI DMA: There are %ld residual bytes.\n",
 			   atari_dma_residual);
 
 		if ((signed int)atari_dma_residual < 0)
@@ -371,7 +371,7 @@ static irqreturn_t scsi_tt_intr(int irq, void *dummy)
 			 * other command.  These shouldn't disconnect anyway.
 			 */
 			if (atari_dma_residual & 0x1ff) {
-				DMA_PRINTK("SCSI DMA: DMA bug corrected, "
+				dprintk(NDEBUG_DMA, "SCSI DMA: DMA bug corrected, "
 					   "difference %ld bytes\n",
 					   512 - (atari_dma_residual & 0x1ff));
 				atari_dma_residual = (atari_dma_residual + 511) & ~0x1ff;
@@ -438,7 +438,7 @@ static irqreturn_t scsi_falcon_intr(int irq, void *dummy)
 			       "ST-DMA fifo\n", transferred & 15);
 
 		atari_dma_residual = HOSTDATA_DMALEN - transferred;
-		DMA_PRINTK("SCSI DMA: There are %ld residual bytes.\n",
+		dprintk(NDEBUG_DMA, "SCSI DMA: There are %ld residual bytes.\n",
 			   atari_dma_residual);
 	} else
 		atari_dma_residual = 0;
@@ -474,11 +474,11 @@ static void atari_scsi_fetch_restbytes(void)
 		/* there are 'nr' bytes left for the last long address
 		   before the DMA pointer */
 		phys_dst ^= nr;
-		DMA_PRINTK("SCSI DMA: there are %d rest bytes for phys addr 0x%08lx",
+		dprintk(NDEBUG_DMA, "SCSI DMA: there are %d rest bytes for phys addr 0x%08lx",
 			   nr, phys_dst);
 		/* The content of the DMA pointer is a physical address!  */
 		dst = phys_to_virt(phys_dst);
-		DMA_PRINTK(" = virt addr %p\n", dst);
+		dprintk(NDEBUG_DMA, " = virt addr %p\n", dst);
 		for (src = (char *)&tt_scsi_dma.dma_restdata; nr != 0; --nr)
 			*dst++ = *src++;
 	}
@@ -883,7 +883,7 @@ static unsigned long atari_scsi_dma_setup(struct Scsi_Host *instance,
 {
 	unsigned long addr = virt_to_phys(data);
 
-	DMA_PRINTK("scsi%d: setting up dma, data = %p, phys = %lx, count = %ld, "
+	dprintk(NDEBUG_DMA, "scsi%d: setting up dma, data = %p, phys = %lx, count = %ld, "
 		   "dir = %d\n", instance->host_no, data, addr, count, dir);
 
 	if (!IS_A_TT() && !STRAM_ADDR(addr)) {
@@ -1063,7 +1063,7 @@ static unsigned long atari_dma_xfer_len(unsigned long wanted_len,
 		possible_len = limit;
 
 	if (possible_len != wanted_len)
-		DMA_PRINTK("Sorry, must cut DMA transfer size to %ld bytes "
+		dprintk(NDEBUG_DMA, "Sorry, must cut DMA transfer size to %ld bytes "
 			   "instead of %ld\n", possible_len, wanted_len);
 
 	return possible_len;

commit a19f8165dcec3e47486f6aa5ddb72d13bb31bdf6
Author: Michael Schmitz <schmitzmic@gmail.com>
Date:   Mon Mar 31 21:06:08 2014 +1300

    m68k/atari - atari_scsi: use correct virt/phys translation for DMA buffer
    
    With the kernel running from FastRAM instead of ST-RAM, none of ST-RAM is
    mapped by mem_init, and DMA-addressable buffer must be mapped by ioremap.
    
    Use platform specific virt/phys translation helpers for this case.
    
    Signed-off-by: Michael Schmitz <schmitz@debian.org>
    Cc: linux-scsi@vger.kernel.org
    Signed-off-by: Geert Uytterhoeven <geert@linux-m68k.org>

diff --git a/drivers/scsi/atari_scsi.c b/drivers/scsi/atari_scsi.c
index 296c936cc03c..a8d721ff19eb 100644
--- a/drivers/scsi/atari_scsi.c
+++ b/drivers/scsi/atari_scsi.c
@@ -639,7 +639,7 @@ static int __init atari_scsi_detect(struct scsi_host_template *host)
 					"double buffer\n");
 			return 0;
 		}
-		atari_dma_phys_buffer = virt_to_phys(atari_dma_buffer);
+		atari_dma_phys_buffer = atari_stram_to_phys(atari_dma_buffer);
 		atari_dma_orig_addr = 0;
 	}
 #endif

commit 2b0f834ca3c93e3d76ae335586b41ed921c5a293
Author: Michael Schmitz <schmitzmic@gmail.com>
Date:   Fri May 2 20:43:01 2014 +1200

    m68k/atari - atari_scsi: change abort/reset return codes
    
    [Resend of earlier patch - added equivalent changes to sun3 NCR5380 code]
    
    The abort/reset lowlevel return codes had changed with the new
    error SCSI handling - update Atari and Sun3 NCR5380 drivers to reflect this.
    
    Change reset handling for Atari to clear queues only, do not attempt
    to call done() on each command aborted by the reset. The EH code
    should do that for us. Queues _must_ be cleared, otherwise
    atari_scsi_bus_reset will not release the ST-DMA lock, deadlocking
    further error recovery.
    
    Update the Sun3 NCR5380 driver as well - the Sun3 driver was
    derived from the Atari one. Kudos to Finn Thain for the Sun3 part
    and cleaning up the header files. After the header cleanup, the
    initio.h include (!) can be dropped from sun3_scsi.h now.
    
    Signed-off-by: Michael Schmitz <schmitz@debian.org>
    Signed-off-by: Finn Thain <fthain@telegraphics.com.au>
    Acked-by: Sam Creasey <sammy@sammy.net>
    Cc: Geert Uytterhoeven <geert@linux-m68k.org>
    Cc: James E.J. Bottomley <JBottomley@parallels.com>
    Cc: linux-scsi@vger.kernel.org
    Signed-off-by: Christoph Hellwig <hch@lst.de>

diff --git a/drivers/scsi/atari_scsi.c b/drivers/scsi/atari_scsi.c
index 296c936cc03c..4ae0c1a29598 100644
--- a/drivers/scsi/atari_scsi.c
+++ b/drivers/scsi/atari_scsi.c
@@ -827,7 +827,7 @@ static int atari_scsi_bus_reset(Scsi_Cmnd *cmd)
 	} else {
 		atari_turnon_irq(IRQ_MFP_FSCSI);
 	}
-	if ((rv & SCSI_RESET_ACTION) == SCSI_RESET_SUCCESS)
+	if (rv == SUCCESS)
 		falcon_release_lock_if_possible(hostdata);
 
 	return rv;

commit eff9cf8d6e8b048f2f744a1cc382e213a00f3d2c
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Sat Mar 1 20:51:03 2014 +1300

    [SCSI] atari_scsi: Fix sleep_on race
    
    sleep_on is known broken and going away. The atari_scsi driver is one of
    two remaining users in the falcon_get_lock() function, which is a rather
    crazy piece of code. This does not attempt to fix the driver's locking
    scheme in general, but at least prevents falcon_get_lock from going to
    sleep when no other thread holds the same lock or tries to get it,
    and we no longer schedule with irqs disabled.
    
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>
    [MSch: fixed completion conditions missed in Arnds' original RFC patch]
    Signed-off-by: Michael Schmitz <schmitz@debian.org>
    Cc: Geert Uytterhoeven <geert@linux-m68k.org>
    Cc: James E.J. Bottomley <JBottomley@parallels.com>
    Cc: linux-scsi@vger.kernel.org
    Signed-off-by: Geert Uytterhoeven <geert@linux-m68k.org>

diff --git a/drivers/scsi/atari_scsi.c b/drivers/scsi/atari_scsi.c
index a3e6c8a3ff0f..296c936cc03c 100644
--- a/drivers/scsi/atari_scsi.c
+++ b/drivers/scsi/atari_scsi.c
@@ -90,6 +90,7 @@
 #include <linux/init.h>
 #include <linux/nvram.h>
 #include <linux/bitops.h>
+#include <linux/wait.h>
 
 #include <asm/setup.h>
 #include <asm/atarihw.h>
@@ -549,8 +550,10 @@ static void falcon_get_lock(void)
 
 	local_irq_save(flags);
 
-	while (!in_irq() && falcon_got_lock && stdma_others_waiting())
-		sleep_on(&falcon_fairness_wait);
+	wait_event_cmd(falcon_fairness_wait,
+		in_interrupt() || !falcon_got_lock || !stdma_others_waiting(),
+		local_irq_restore(flags),
+		local_irq_save(flags));
 
 	while (!falcon_got_lock) {
 		if (in_irq())
@@ -562,7 +565,10 @@ static void falcon_get_lock(void)
 			falcon_trying_lock = 0;
 			wake_up(&falcon_try_wait);
 		} else {
-			sleep_on(&falcon_try_wait);
+			wait_event_cmd(falcon_try_wait,
+				falcon_got_lock && !falcon_trying_lock,
+				local_irq_restore(flags),
+				local_irq_save(flags));
 		}
 	}
 

commit d89537e1b124ad661ea340798965a96e123cb211
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Sun Mar 31 13:24:44 2013 -0400

    atari_scsi: switch to ->show_info()
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/drivers/scsi/atari_scsi.c b/drivers/scsi/atari_scsi.c
index df740cbbaef4..a3e6c8a3ff0f 100644
--- a/drivers/scsi/atari_scsi.c
+++ b/drivers/scsi/atari_scsi.c
@@ -1100,7 +1100,7 @@ static void atari_scsi_falcon_reg_write(unsigned char reg, unsigned char value)
 #include "atari_NCR5380.c"
 
 static struct scsi_host_template driver_template = {
-	.proc_info		= atari_scsi_proc_info,
+	.show_info		= atari_scsi_show_info,
 	.name			= "Atari native SCSI",
 	.detect			= atari_scsi_detect,
 	.release		= atari_scsi_release,

commit 107b5d5302b184b72a2f12d9d23f2fcd4ce8a6ec
Author: Geert Uytterhoeven <geert@linux-m68k.org>
Date:   Sun Jun 12 20:48:33 2011 +0200

    scsi/atari: Make more functions static
    
    Signed-off-by: Geert Uytterhoeven <geert@linux-m68k.org>
    Cc: Michael Schmitz <schmitzmic@googlemail.com>
    Cc: James E.J. Bottomley <JBottomley@parallels.com>
    Cc: linux-scsi@vger.kernel.org

diff --git a/drivers/scsi/atari_scsi.c b/drivers/scsi/atari_scsi.c
index 3102ce524f61..df740cbbaef4 100644
--- a/drivers/scsi/atari_scsi.c
+++ b/drivers/scsi/atari_scsi.c
@@ -572,7 +572,7 @@ static void falcon_get_lock(void)
 }
 
 
-int __init atari_scsi_detect(struct scsi_host_template *host)
+static int __init atari_scsi_detect(struct scsi_host_template *host)
 {
 	static int called = 0;
 	struct Scsi_Host *instance;
@@ -724,7 +724,7 @@ int __init atari_scsi_detect(struct scsi_host_template *host)
 	return 1;
 }
 
-int atari_scsi_release(struct Scsi_Host *sh)
+static int atari_scsi_release(struct Scsi_Host *sh)
 {
 	if (IS_A_TT())
 		free_irq(IRQ_TT_MFP_SCSI, sh);
@@ -788,7 +788,7 @@ static int __init atari_scsi_setup(char *str)
 __setup("atascsi=", atari_scsi_setup);
 #endif /* !MODULE */
 
-int atari_scsi_bus_reset(Scsi_Cmnd *cmd)
+static int atari_scsi_bus_reset(Scsi_Cmnd *cmd)
 {
 	int rv;
 	struct NCR5380_hostdata *hostdata =
@@ -861,7 +861,7 @@ static void __init atari_scsi_reset_boot(void)
 #endif
 
 
-const char *atari_scsi_info(struct Scsi_Host *host)
+static const char *atari_scsi_info(struct Scsi_Host *host)
 {
 	/* atari_scsi_detect() is verbose enough... */
 	static const char string[] = "Atari native SCSI";
@@ -871,8 +871,9 @@ const char *atari_scsi_info(struct Scsi_Host *host)
 
 #if defined(REAL_DMA)
 
-unsigned long atari_scsi_dma_setup(struct Scsi_Host *instance, void *data,
-				   unsigned long count, int dir)
+static unsigned long atari_scsi_dma_setup(struct Scsi_Host *instance,
+					  void *data, unsigned long count,
+					  int dir)
 {
 	unsigned long addr = virt_to_phys(data);
 

commit 7b54e43a8d1140153e317de5e0dc00d81c709d4d
Author: Geert Uytterhoeven <geert@linux-m68k.org>
Date:   Sun Mar 18 11:54:40 2012 +0100

    scsi/atari: Revive "atascsi=" setup option
    
    It was documented in Documentation/m68k/kernel-options.txt and
    Documentation/scsi/scsi-parameters.txt, but the implementation was
    missing.
    
    Signed-off-by: Geert Uytterhoeven <geert@linux-m68k.org>
    Cc: Michael Schmitz <schmitzmic@googlemail.com>
    Cc: James E.J. Bottomley <JBottomley@parallels.com>
    Cc: linux-scsi@vger.kernel.org

diff --git a/drivers/scsi/atari_scsi.c b/drivers/scsi/atari_scsi.c
index 04a154f87e3e..3102ce524f61 100644
--- a/drivers/scsi/atari_scsi.c
+++ b/drivers/scsi/atari_scsi.c
@@ -734,17 +734,21 @@ int atari_scsi_release(struct Scsi_Host *sh)
 	return 1;
 }
 
-void __init atari_scsi_setup(char *str, int *ints)
+#ifndef MODULE
+static int __init atari_scsi_setup(char *str)
 {
 	/* Format of atascsi parameter is:
 	 *   atascsi=<can_queue>,<cmd_per_lun>,<sg_tablesize>,<hostid>,<use_tags>
 	 * Defaults depend on TT or Falcon, hostid determined at run time.
 	 * Negative values mean don't change.
 	 */
+	int ints[6];
+
+	get_options(str, ARRAY_SIZE(ints), ints);
 
 	if (ints[0] < 1) {
 		printk("atari_scsi_setup: no arguments!\n");
-		return;
+		return 0;
 	}
 
 	if (ints[0] >= 1) {
@@ -777,8 +781,13 @@ void __init atari_scsi_setup(char *str, int *ints)
 			setup_use_tagged_queuing = !!ints[5];
 	}
 #endif
+
+	return 1;
 }
 
+__setup("atascsi=", atari_scsi_setup);
+#endif /* !MODULE */
+
 int atari_scsi_bus_reset(Scsi_Cmnd *cmd)
 {
 	int rv;

commit 6323e4fe7f61f77c87c26d2b5dcb3472246c1341
Author: Geert Uytterhoeven <geert@linux-m68k.org>
Date:   Mon Jun 13 20:39:15 2011 +0200

    [SCSI] atari_NCR5380: Provide a dummy NCR5380_exit()
    
    and call it from atari_scsi_release(), cfr. the other NCR5380 drivers.
    
    This fixes:
    
    drivers/scsi/NCR5380.h:303: warning: ‘NCR5380_exit’ declared ‘static’ but never defined
    
    Signed-off-by: Geert Uytterhoeven <geert@linux-m68k.org>
    Signed-off-by: James Bottomley <JBottomley@Parallels.com>

diff --git a/drivers/scsi/atari_scsi.c b/drivers/scsi/atari_scsi.c
index 3e8658e2f154..04a154f87e3e 100644
--- a/drivers/scsi/atari_scsi.c
+++ b/drivers/scsi/atari_scsi.c
@@ -730,6 +730,7 @@ int atari_scsi_release(struct Scsi_Host *sh)
 		free_irq(IRQ_TT_MFP_SCSI, sh);
 	if (atari_dma_buffer)
 		atari_stram_free(atari_dma_buffer);
+	NCR5380_exit(sh);
 	return 1;
 }
 

commit f281233d3eba15fb225d21ae2e228fd4553d824a
Author: Jeff Garzik <jeff@garzik.org>
Date:   Tue Nov 16 02:10:29 2010 -0500

    SCSI host lock push-down
    
    Move the mid-layer's ->queuecommand() invocation from being locked
    with the host lock to being unlocked to facilitate speeding up the
    critical path for drivers who don't need this lock taken anyway.
    
    The patch below presents a simple SCSI host lock push-down as an
    equivalent transformation.  No locking or other behavior should change
    with this patch.  All existing bugs and locking orders are preserved.
    
    Additionally, add one parameter to queuecommand,
            struct Scsi_Host *
    and remove one parameter from queuecommand,
            void (*done)(struct scsi_cmnd *)
    
    Scsi_Host* is a convenient pointer that most host drivers need anyway,
    and 'done' is redundant to struct scsi_cmnd->scsi_done.
    
    Minimal code disturbance was attempted with this change.  Most drivers
    needed only two one-line modifications for their host lock push-down.
    
    Signed-off-by: Jeff Garzik <jgarzik@redhat.com>
    Acked-by: James Bottomley <James.Bottomley@suse.de>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/scsi/atari_scsi.c b/drivers/scsi/atari_scsi.c
index ad7a23aef0ec..3e8658e2f154 100644
--- a/drivers/scsi/atari_scsi.c
+++ b/drivers/scsi/atari_scsi.c
@@ -572,23 +572,6 @@ static void falcon_get_lock(void)
 }
 
 
-/* This is the wrapper function for NCR5380_queue_command(). It just
- * tries to get the lock on the ST-DMA (see above) and then calls the
- * original function.
- */
-
-#if 0
-int atari_queue_command(Scsi_Cmnd *cmd, void (*done)(Scsi_Cmnd *))
-{
-	/* falcon_get_lock();
-	 * ++guenther: moved to NCR5380_queue_command() to prevent
-	 * race condition, see there for an explanation.
-	 */
-	return NCR5380_queue_command(cmd, done);
-}
-#endif
-
-
 int __init atari_scsi_detect(struct scsi_host_template *host)
 {
 	static int called = 0;

commit 95fde7a83989d595c06105629f42f3691bf62f91
Author: Michael Schmitz <schmitz@biophys.uni-duesseldorf.de>
Date:   Sun Jan 18 03:22:15 2009 +0100

    m68k: section mismatch fixes: Atari SCSI
    
    add __init annotations to probe routines
    
    Signed-off-by: Michael Schmitz <schmitz@debian.org>
    Signed-off-by: Geert Uytterhoeven <geert@linux-m68k.org>

diff --git a/drivers/scsi/atari_scsi.c b/drivers/scsi/atari_scsi.c
index 21fe07f9df87..ad7a23aef0ec 100644
--- a/drivers/scsi/atari_scsi.c
+++ b/drivers/scsi/atari_scsi.c
@@ -589,7 +589,7 @@ int atari_queue_command(Scsi_Cmnd *cmd, void (*done)(Scsi_Cmnd *))
 #endif
 
 
-int atari_scsi_detect(struct scsi_host_template *host)
+int __init atari_scsi_detect(struct scsi_host_template *host)
 {
 	static int called = 0;
 	struct Scsi_Host *instance;

commit 29c8a24672e1cdfee99c15b870c57eb30ae69daf
Author: Adrian Bunk <bunk@kernel.org>
Date:   Mon Oct 13 21:58:59 2008 +0200

    m68k: Remove the broken Hades support
    
    This patch removes the Hades support that was marked as BROKEN 5 years ago.
    
    Signed-off-by: Adrian Bunk <bunk@kernel.org>
    Signed-off-by: Geert Uytterhoeven <geert@linux-m68k.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/scsi/atari_scsi.c b/drivers/scsi/atari_scsi.c
index f5732d8f67fe..21fe07f9df87 100644
--- a/drivers/scsi/atari_scsi.c
+++ b/drivers/scsi/atari_scsi.c
@@ -249,10 +249,6 @@ static int setup_hostid = -1;
 module_param(setup_hostid, int, 0);
 
 
-#if defined(CONFIG_TT_DMA_EMUL)
-#include "atari_dma_emul.c"
-#endif
-
 #if defined(REAL_DMA)
 
 static int scsi_dma_is_ignored_buserr(unsigned char dma_stat)
@@ -695,21 +691,8 @@ int atari_scsi_detect(struct scsi_host_template *host)
 #ifdef REAL_DMA
 		tt_scsi_dma.dma_ctrl = 0;
 		atari_dma_residual = 0;
-#ifdef CONFIG_TT_DMA_EMUL
-		if (MACH_IS_HADES) {
-			if (request_irq(IRQ_AUTO_2, hades_dma_emulator,
-					 IRQ_TYPE_PRIO, "Hades DMA emulator",
-					 hades_dma_emulator)) {
-				printk(KERN_ERR "atari_scsi_detect: cannot allocate irq %d, aborting (MACH_IS_HADES)",IRQ_AUTO_2);
-				free_irq(IRQ_TT_MFP_SCSI, instance);
-				scsi_unregister(atari_scsi_host);
-				atari_stram_free(atari_dma_buffer);
-				atari_dma_buffer = 0;
-				return 0;
-			}
-		}
-#endif
-		if (MACH_IS_MEDUSA || MACH_IS_HADES) {
+
+		if (MACH_IS_MEDUSA) {
 			/* While the read overruns (described by Drew Eckhardt in
 			 * NCR5380.c) never happened on TTs, they do in fact on the Medusa
 			 * (This was the cause why SCSI didn't work right for so long
@@ -1007,11 +990,7 @@ static unsigned long atari_dma_xfer_len(unsigned long wanted_len,
 					Scsi_Cmnd *cmd, int write_flag)
 {
 	unsigned long	possible_len, limit;
-#ifndef CONFIG_TT_DMA_EMUL
-	if (MACH_IS_HADES)
-		/* Hades has no SCSI DMA at all :-( Always force use of PIO */
-		return 0;
-#endif
+
 	if (IS_A_TT())
 		/* TT SCSI DMA can transfer arbitrary #bytes */
 		return wanted_len;

commit 1e641664301744f0d381de43ae1e12343e60b479
Author: Jeff Garzik <jeff@garzik.org>
Date:   Sun Nov 11 19:52:05 2007 -0500

    [SCSI] NCR5380: Fix bugs and canonicalize irq handler usage
    
    * Always pass the same value to free_irq() that we pass to
      request_irq().  This fixes several bugs.
    
    * Always call NCR5380_intr() with 'irq' and 'dev_id' arguments.
    
      Note, scsi_falcon_intr() is the only case now where dev_id is not the
      scsi_host.
    
    * Always pass Scsi_Host to request_irq().  For most cases, the drivers
      already did so, and I merely neated the source code line.  In other
      cases, either NULL or a non-sensical value was passed, verified to be
      unused, then changed to be Scsi_Host in anticipation of the future.
    
    In addition to the bugs fixes, this change makes the interface usage
    consistent, which in turn enables the possibility of directly
    referencing Scsi_Host from all NCR5380_intr() invocations.
    
    Signed-off-by: Jeff Garzik <jgarzik@redhat.com>
    Signed-off-by: James Bottomley <James.Bottomley@HansenPartnership.com>

diff --git a/drivers/scsi/atari_scsi.c b/drivers/scsi/atari_scsi.c
index 6f8403b82ba1..f5732d8f67fe 100644
--- a/drivers/scsi/atari_scsi.c
+++ b/drivers/scsi/atari_scsi.c
@@ -393,7 +393,7 @@ static irqreturn_t scsi_tt_intr(int irq, void *dummy)
 
 #endif /* REAL_DMA */
 
-	NCR5380_intr(0, 0);
+	NCR5380_intr(irq, dummy);
 
 #if 0
 	/* To be sure the int is not masked */
@@ -458,7 +458,7 @@ static irqreturn_t scsi_falcon_intr(int irq, void *dummy)
 
 #endif /* REAL_DMA */
 
-	NCR5380_intr(0, 0);
+	NCR5380_intr(irq, dummy);
 	return IRQ_HANDLED;
 }
 
@@ -684,7 +684,7 @@ int atari_scsi_detect(struct scsi_host_template *host)
 		 * interrupt after having cleared the pending flag for the DMA
 		 * interrupt. */
 		if (request_irq(IRQ_TT_MFP_SCSI, scsi_tt_intr, IRQ_TYPE_SLOW,
-				 "SCSI NCR5380", scsi_tt_intr)) {
+				 "SCSI NCR5380", instance)) {
 			printk(KERN_ERR "atari_scsi_detect: cannot allocate irq %d, aborting",IRQ_TT_MFP_SCSI);
 			scsi_unregister(atari_scsi_host);
 			atari_stram_free(atari_dma_buffer);
@@ -701,7 +701,7 @@ int atari_scsi_detect(struct scsi_host_template *host)
 					 IRQ_TYPE_PRIO, "Hades DMA emulator",
 					 hades_dma_emulator)) {
 				printk(KERN_ERR "atari_scsi_detect: cannot allocate irq %d, aborting (MACH_IS_HADES)",IRQ_AUTO_2);
-				free_irq(IRQ_TT_MFP_SCSI, scsi_tt_intr);
+				free_irq(IRQ_TT_MFP_SCSI, instance);
 				scsi_unregister(atari_scsi_host);
 				atari_stram_free(atari_dma_buffer);
 				atari_dma_buffer = 0;
@@ -761,7 +761,7 @@ int atari_scsi_detect(struct scsi_host_template *host)
 int atari_scsi_release(struct Scsi_Host *sh)
 {
 	if (IS_A_TT())
-		free_irq(IRQ_TT_MFP_SCSI, scsi_tt_intr);
+		free_irq(IRQ_TT_MFP_SCSI, sh);
 	if (atari_dma_buffer)
 		atari_stram_free(atari_dma_buffer);
 	return 1;

commit 3130d905ba86d5f2636b2f45d5beefe82cb03df6
Author: Roman Zippel <zippel@linux-m68k.org>
Date:   Tue May 1 22:32:37 2007 +0200

    m68k: Atari SCSI driver compile fixes
    
    Atari SCSI driver compile fixes
    
    Signed-off-by: Roman Zippel <zippel@linux-m68k.org>
    Signed-off-by: Geert Uytterhoeven <geert@linux-m68k.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/scsi/atari_scsi.c b/drivers/scsi/atari_scsi.c
index f766d0d81c99..6f8403b82ba1 100644
--- a/drivers/scsi/atari_scsi.c
+++ b/drivers/scsi/atari_scsi.c
@@ -69,9 +69,9 @@
 
 #define NDEBUG (0)
 
-#define NDEBUG_ABORT	0x800000
-#define NDEBUG_TAGS	0x1000000
-#define NDEBUG_MERGING	0x2000000
+#define NDEBUG_ABORT		0x00100000
+#define NDEBUG_TAGS		0x00200000
+#define NDEBUG_MERGING		0x00400000
 
 #define AUTOSENSE
 /* For the Atari version, use only polled IO or REAL_DMA */

commit c28bda25175913c88396b643813321ef9cffe663
Author: Roman Zippel <zippel@linux-m68k.org>
Date:   Tue May 1 22:32:36 2007 +0200

    m68k: Reformat the Atari SCSI driver
    
    Reformat the Atari SCSI driver
    
    Signed-off-by: Roman Zippel <zippel@linux-m68k.org>
    Signed-off-by: Geert Uytterhoeven <geert@linux-m68k.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/scsi/atari_scsi.c b/drivers/scsi/atari_scsi.c
index 85b8acc94034..f766d0d81c99 100644
--- a/drivers/scsi/atari_scsi.c
+++ b/drivers/scsi/atari_scsi.c
@@ -186,38 +186,37 @@ static inline void DISABLE_IRQ(void)
 /***************************** Prototypes *****************************/
 
 #ifdef REAL_DMA
-static int scsi_dma_is_ignored_buserr( unsigned char dma_stat );
-static void atari_scsi_fetch_restbytes( void );
-static long atari_scsi_dma_residual( struct Scsi_Host *instance );
-static int falcon_classify_cmd( Scsi_Cmnd *cmd );
-static unsigned long atari_dma_xfer_len( unsigned long wanted_len,
-                                         Scsi_Cmnd *cmd, int write_flag );
+static int scsi_dma_is_ignored_buserr(unsigned char dma_stat);
+static void atari_scsi_fetch_restbytes(void);
+static long atari_scsi_dma_residual(struct Scsi_Host *instance);
+static int falcon_classify_cmd(Scsi_Cmnd *cmd);
+static unsigned long atari_dma_xfer_len(unsigned long wanted_len,
+					Scsi_Cmnd *cmd, int write_flag);
 #endif
-static irqreturn_t scsi_tt_intr( int irq, void *dummy);
-static irqreturn_t scsi_falcon_intr( int irq, void *dummy);
-static void falcon_release_lock_if_possible( struct NCR5380_hostdata *
-                                             hostdata );
-static void falcon_get_lock( void );
+static irqreturn_t scsi_tt_intr(int irq, void *dummy);
+static irqreturn_t scsi_falcon_intr(int irq, void *dummy);
+static void falcon_release_lock_if_possible(struct NCR5380_hostdata *hostdata);
+static void falcon_get_lock(void);
 #ifdef CONFIG_ATARI_SCSI_RESET_BOOT
-static void atari_scsi_reset_boot( void );
+static void atari_scsi_reset_boot(void);
 #endif
-static unsigned char atari_scsi_tt_reg_read( unsigned char reg );
-static void atari_scsi_tt_reg_write( unsigned char reg, unsigned char value);
-static unsigned char atari_scsi_falcon_reg_read( unsigned char reg );
-static void atari_scsi_falcon_reg_write( unsigned char reg, unsigned char value );
+static unsigned char atari_scsi_tt_reg_read(unsigned char reg);
+static void atari_scsi_tt_reg_write(unsigned char reg, unsigned char value);
+static unsigned char atari_scsi_falcon_reg_read(unsigned char reg);
+static void atari_scsi_falcon_reg_write(unsigned char reg, unsigned char value);
 
 /************************* End of Prototypes **************************/
 
 
-static struct Scsi_Host *atari_scsi_host = NULL;
-static unsigned char (*atari_scsi_reg_read)( unsigned char reg );
-static void (*atari_scsi_reg_write)( unsigned char reg, unsigned char value );
+static struct Scsi_Host *atari_scsi_host;
+static unsigned char (*atari_scsi_reg_read)(unsigned char reg);
+static void (*atari_scsi_reg_write)(unsigned char reg, unsigned char value);
 
 #ifdef REAL_DMA
 static unsigned long	atari_dma_residual, atari_dma_startaddr;
 static short		atari_dma_active;
 /* pointer to the dribble buffer */
-static char		*atari_dma_buffer = NULL;
+static char		*atari_dma_buffer;
 /* precalculated physical address of the dribble buffer */
 static unsigned long	atari_dma_phys_buffer;
 /* != 0 tells the Falcon int handler to copy data from the dribble buffer */
@@ -233,7 +232,7 @@ static char		*atari_dma_orig_addr;
 static unsigned long	atari_dma_stram_mask;
 #define STRAM_ADDR(a)	(((a) & atari_dma_stram_mask) == 0)
 /* number of bytes to cut from a transfer to handle NCR overruns */
-static int atari_read_overruns = 0;
+static int atari_read_overruns;
 #endif
 
 static int setup_can_queue = -1;
@@ -256,10 +255,10 @@ module_param(setup_hostid, int, 0);
 
 #if defined(REAL_DMA)
 
-static int scsi_dma_is_ignored_buserr( unsigned char dma_stat )
+static int scsi_dma_is_ignored_buserr(unsigned char dma_stat)
 {
 	int i;
-	unsigned long	addr = SCSI_DMA_READ_P( dma_addr ), end_addr;
+	unsigned long addr = SCSI_DMA_READ_P(dma_addr), end_addr;
 
 	if (dma_stat & 0x01) {
 
@@ -267,15 +266,14 @@ static int scsi_dma_is_ignored_buserr( unsigned char dma_stat )
 		 * physical memory chunk (DMA prefetch!), but that doesn't hurt.
 		 * Check for this case:
 		 */
-		
-		for( i = 0; i < m68k_num_memory; ++i ) {
-			end_addr = m68k_memory[i].addr +
-				m68k_memory[i].size;
+
+		for (i = 0; i < m68k_num_memory; ++i) {
+			end_addr = m68k_memory[i].addr + m68k_memory[i].size;
 			if (end_addr <= addr && addr <= end_addr + 4)
-				return( 1 );
+				return 1;
 		}
 	}
-	return( 0 );
+	return 0;
 }
 
 
@@ -284,28 +282,27 @@ static int scsi_dma_is_ignored_buserr( unsigned char dma_stat )
  * end-of-DMA, both SCSI ints are triggered simultaneously, so the NCR int has
  * to clear the DMA int pending bit before it allows other level 6 interrupts.
  */
-static void scsi_dma_buserr (int irq, void *dummy)
+static void scsi_dma_buserr(int irq, void *dummy)
 {
-	unsigned char	dma_stat = tt_scsi_dma.dma_ctrl;
+	unsigned char dma_stat = tt_scsi_dma.dma_ctrl;
 
 	/* Don't do anything if a NCR interrupt is pending. Probably it's just
 	 * masked... */
-	if (atari_irq_pending( IRQ_TT_MFP_SCSI ))
+	if (atari_irq_pending(IRQ_TT_MFP_SCSI))
 		return;
-	
+
 	printk("Bad SCSI DMA interrupt! dma_addr=0x%08lx dma_stat=%02x dma_cnt=%08lx\n",
 	       SCSI_DMA_READ_P(dma_addr), dma_stat, SCSI_DMA_READ_P(dma_cnt));
 	if (dma_stat & 0x80) {
-		if (!scsi_dma_is_ignored_buserr( dma_stat ))
-			printk( "SCSI DMA bus error -- bad DMA programming!\n" );
-	}
-	else {
+		if (!scsi_dma_is_ignored_buserr(dma_stat))
+			printk("SCSI DMA bus error -- bad DMA programming!\n");
+	} else {
 		/* Under normal circumstances we never should get to this point,
 		 * since both interrupts are triggered simultaneously and the 5380
 		 * int has higher priority. When this irq is handled, that DMA
 		 * interrupt is cleared. So a warning message is printed here.
 		 */
-		printk( "SCSI DMA intr ?? -- this shouldn't happen!\n" );
+		printk("SCSI DMA intr ?? -- this shouldn't happen!\n");
 	}
 }
 #endif
@@ -313,7 +310,7 @@ static void scsi_dma_buserr (int irq, void *dummy)
 #endif
 
 
-static irqreturn_t scsi_tt_intr (int irq, void *dummy)
+static irqreturn_t scsi_tt_intr(int irq, void *dummy)
 {
 #ifdef REAL_DMA
 	int dma_stat;
@@ -327,7 +324,7 @@ static irqreturn_t scsi_tt_intr (int irq, void *dummy)
 	 * is that a bus error occurred...
 	 */
 	if (dma_stat & 0x80) {
-		if (!scsi_dma_is_ignored_buserr( dma_stat )) {
+		if (!scsi_dma_is_ignored_buserr(dma_stat)) {
 			printk(KERN_ERR "SCSI DMA caused bus error near 0x%08lx\n",
 			       SCSI_DMA_READ_P(dma_addr));
 			printk(KERN_CRIT "SCSI DMA bus error -- bad DMA programming!");
@@ -344,8 +341,7 @@ static irqreturn_t scsi_tt_intr (int irq, void *dummy)
 	 * data reg!
 	 */
 	if ((dma_stat & 0x02) && !(dma_stat & 0x40)) {
-		atari_dma_residual = HOSTDATA_DMALEN - (SCSI_DMA_READ_P( dma_addr ) -
-												atari_dma_startaddr);
+		atari_dma_residual = HOSTDATA_DMALEN - (SCSI_DMA_READ_P(dma_addr) - atari_dma_startaddr);
 
 		DMA_PRINTK("SCSI DMA: There are %ld residual bytes.\n",
 			   atari_dma_residual);
@@ -353,28 +349,30 @@ static irqreturn_t scsi_tt_intr (int irq, void *dummy)
 		if ((signed int)atari_dma_residual < 0)
 			atari_dma_residual = 0;
 		if ((dma_stat & 1) == 0) {
-			/* After read operations, we maybe have to
-			   transport some rest bytes */
+			/*
+			 * After read operations, we maybe have to
+			 * transport some rest bytes
+			 */
 			atari_scsi_fetch_restbytes();
-		}
-		else {
-			/* There seems to be a nasty bug in some SCSI-DMA/NCR
-			   combinations: If a target disconnects while a write
-			   operation is going on, the address register of the
-			   DMA may be a few bytes farer than it actually read.
-			   This is probably due to DMA prefetching and a delay
-			   between DMA and NCR.  Experiments showed that the
-			   dma_addr is 9 bytes to high, but this could vary.
-			   The problem is, that the residual is thus calculated
-			   wrong and the next transfer will start behind where
-			   it should.  So we round up the residual to the next
-			   multiple of a sector size, if it isn't already a
-			   multiple and the originally expected transfer size
-			   was.  The latter condition is there to ensure that
-			   the correction is taken only for "real" data
-			   transfers and not for, e.g., the parameters of some
-			   other command.  These shouldn't disconnect anyway.
-			   */
+		} else {
+			/*
+			 * There seems to be a nasty bug in some SCSI-DMA/NCR
+			 * combinations: If a target disconnects while a write
+			 * operation is going on, the address register of the
+			 * DMA may be a few bytes farer than it actually read.
+			 * This is probably due to DMA prefetching and a delay
+			 * between DMA and NCR.  Experiments showed that the
+			 * dma_addr is 9 bytes to high, but this could vary.
+			 * The problem is, that the residual is thus calculated
+			 * wrong and the next transfer will start behind where
+			 * it should.  So we round up the residual to the next
+			 * multiple of a sector size, if it isn't already a
+			 * multiple and the originally expected transfer size
+			 * was.  The latter condition is there to ensure that
+			 * the correction is taken only for "real" data
+			 * transfers and not for, e.g., the parameters of some
+			 * other command.  These shouldn't disconnect anyway.
+			 */
 			if (atari_dma_residual & 0x1ff) {
 				DMA_PRINTK("SCSI DMA: DMA bug corrected, "
 					   "difference %ld bytes\n",
@@ -394,18 +392,18 @@ static irqreturn_t scsi_tt_intr (int irq, void *dummy)
 	}
 
 #endif /* REAL_DMA */
-	
+
 	NCR5380_intr(0, 0);
 
 #if 0
 	/* To be sure the int is not masked */
-	atari_enable_irq( IRQ_TT_MFP_SCSI );
+	atari_enable_irq(IRQ_TT_MFP_SCSI);
 #endif
 	return IRQ_HANDLED;
 }
 
 
-static irqreturn_t scsi_falcon_intr (int irq, void *dummy)
+static irqreturn_t scsi_falcon_intr(int irq, void *dummy)
 {
 #ifdef REAL_DMA
 	int dma_stat;
@@ -430,7 +428,7 @@ static irqreturn_t scsi_falcon_intr (int irq, void *dummy)
 	 * bytes are stuck in the ST-DMA fifo (there's no way to reach them!)
 	 */
 	if (atari_dma_active && (dma_stat & 0x02)) {
-		unsigned long	transferred;
+		unsigned long transferred;
 
 		transferred = SCSI_DMA_GETADR() - atari_dma_startaddr;
 		/* The ST-DMA address is incremented in 2-byte steps, but the
@@ -445,8 +443,7 @@ static irqreturn_t scsi_falcon_intr (int irq, void *dummy)
 		atari_dma_residual = HOSTDATA_DMALEN - transferred;
 		DMA_PRINTK("SCSI DMA: There are %ld residual bytes.\n",
 			   atari_dma_residual);
-	}
-	else
+	} else
 		atari_dma_residual = 0;
 	atari_dma_active = 0;
 
@@ -467,7 +464,7 @@ static irqreturn_t scsi_falcon_intr (int irq, void *dummy)
 
 
 #ifdef REAL_DMA
-static void atari_scsi_fetch_restbytes( void )
+static void atari_scsi_fetch_restbytes(void)
 {
 	int nr;
 	char *src, *dst;
@@ -505,19 +502,17 @@ static int falcon_dont_release = 0;
  * again (but others waiting longer more probably will win).
  */
 
-static void
-falcon_release_lock_if_possible( struct NCR5380_hostdata * hostdata )
+static void falcon_release_lock_if_possible(struct NCR5380_hostdata *hostdata)
 {
 	unsigned long flags;
-		
-	if (IS_A_TT()) return;
-	
+
+	if (IS_A_TT())
+		return;
+
 	local_irq_save(flags);
 
-	if (falcon_got_lock &&
-		!hostdata->disconnected_queue &&
-		!hostdata->issue_queue &&
-		!hostdata->connected) {
+	if (falcon_got_lock && !hostdata->disconnected_queue &&
+	    !hostdata->issue_queue && !hostdata->connected) {
 
 		if (falcon_dont_release) {
 #if 0
@@ -528,7 +523,7 @@ falcon_release_lock_if_possible( struct NCR5380_hostdata * hostdata )
 		}
 		falcon_got_lock = 0;
 		stdma_release();
-		wake_up( &falcon_fairness_wait );
+		wake_up(&falcon_fairness_wait);
 	}
 
 	local_irq_restore(flags);
@@ -549,31 +544,31 @@ falcon_release_lock_if_possible( struct NCR5380_hostdata * hostdata )
  * Complicated, complicated.... Sigh...
  */
 
-static void falcon_get_lock( void )
+static void falcon_get_lock(void)
 {
 	unsigned long flags;
 
-	if (IS_A_TT()) return;
+	if (IS_A_TT())
+		return;
 
 	local_irq_save(flags);
 
 	while (!in_irq() && falcon_got_lock && stdma_others_waiting())
-		sleep_on( &falcon_fairness_wait );
+		sleep_on(&falcon_fairness_wait);
 
 	while (!falcon_got_lock) {
 		if (in_irq())
-			panic( "Falcon SCSI hasn't ST-DMA lock in interrupt" );
+			panic("Falcon SCSI hasn't ST-DMA lock in interrupt");
 		if (!falcon_trying_lock) {
 			falcon_trying_lock = 1;
 			stdma_lock(scsi_falcon_intr, NULL);
 			falcon_got_lock = 1;
 			falcon_trying_lock = 0;
-			wake_up( &falcon_try_wait );
-		}
-		else {
-			sleep_on( &falcon_try_wait );
+			wake_up(&falcon_try_wait);
+		} else {
+			sleep_on(&falcon_try_wait);
 		}
-	}	
+	}
 
 	local_irq_restore(flags);
 	if (!falcon_got_lock)
@@ -587,18 +582,18 @@ static void falcon_get_lock( void )
  */
 
 #if 0
-int atari_queue_command (Scsi_Cmnd *cmd, void (*done)(Scsi_Cmnd *))
+int atari_queue_command(Scsi_Cmnd *cmd, void (*done)(Scsi_Cmnd *))
 {
 	/* falcon_get_lock();
 	 * ++guenther: moved to NCR5380_queue_command() to prevent
 	 * race condition, see there for an explanation.
 	 */
-	return( NCR5380_queue_command( cmd, done ) );
+	return NCR5380_queue_command(cmd, done);
 }
 #endif
 
 
-int atari_scsi_detect (struct scsi_host_template *host)
+int atari_scsi_detect(struct scsi_host_template *host)
 {
 	static int called = 0;
 	struct Scsi_Host *instance;
@@ -606,7 +601,7 @@ int atari_scsi_detect (struct scsi_host_template *host)
 	if (!MACH_IS_ATARI ||
 	    (!ATARIHW_PRESENT(ST_SCSI) && !ATARIHW_PRESENT(TT_SCSI)) ||
 	    called)
-		return( 0 );
+		return 0;
 
 	host->proc_name = "Atari";
 
@@ -655,32 +650,33 @@ int atari_scsi_detect (struct scsi_host_template *host)
 	    !ATARIHW_PRESENT(EXTD_DMA) && m68k_num_memory > 1) {
 		atari_dma_buffer = atari_stram_alloc(STRAM_BUFFER_SIZE, "SCSI");
 		if (!atari_dma_buffer) {
-			printk( KERN_ERR "atari_scsi_detect: can't allocate ST-RAM "
-					"double buffer\n" );
-			return( 0 );
+			printk(KERN_ERR "atari_scsi_detect: can't allocate ST-RAM "
+					"double buffer\n");
+			return 0;
 		}
-		atari_dma_phys_buffer = virt_to_phys( atari_dma_buffer );
+		atari_dma_phys_buffer = virt_to_phys(atari_dma_buffer);
 		atari_dma_orig_addr = 0;
 	}
 #endif
-	instance = scsi_register (host, sizeof (struct NCR5380_hostdata));
-	if(instance == NULL)
-	{
+	instance = scsi_register(host, sizeof(struct NCR5380_hostdata));
+	if (instance == NULL) {
 		atari_stram_free(atari_dma_buffer);
 		atari_dma_buffer = 0;
 		return 0;
 	}
 	atari_scsi_host = instance;
-       /* Set irq to 0, to avoid that the mid-level code disables our interrupt
-        * during queue_command calls. This is completely unnecessary, and even
-        * worse causes bad problems on the Falcon, where the int is shared with
-        * IDE and floppy! */
+	/*
+	 * Set irq to 0, to avoid that the mid-level code disables our interrupt
+	 * during queue_command calls. This is completely unnecessary, and even
+	 * worse causes bad problems on the Falcon, where the int is shared with
+	 * IDE and floppy!
+	 */
        instance->irq = 0;
 
 #ifdef CONFIG_ATARI_SCSI_RESET_BOOT
 	atari_scsi_reset_boot();
 #endif
-	NCR5380_init (instance, 0);
+	NCR5380_init(instance, 0);
 
 	if (IS_A_TT()) {
 
@@ -727,11 +723,10 @@ int atari_scsi_detect (struct scsi_host_template *host)
 			 * the rest data bug is fixed, this can be lowered to 1.
 			 */
 			atari_read_overruns = 4;
-		}		
+		}
 #endif /*REAL_DMA*/
-	}
-	else { /* ! IS_A_TT */
-		
+	} else { /* ! IS_A_TT */
+
 		/* Nothing to do for the interrupt: the ST-DMA is initialized
 		 * already by atari_init_INTS()
 		 */
@@ -756,19 +751,19 @@ int atari_scsi_detect (struct scsi_host_template *host)
 			setup_use_tagged_queuing ? "yes" : "no",
 #endif
 			instance->hostt->this_id );
-	NCR5380_print_options (instance);
-	printk ("\n");
+	NCR5380_print_options(instance);
+	printk("\n");
 
 	called = 1;
-	return( 1 );
+	return 1;
 }
 
-int atari_scsi_release (struct Scsi_Host *sh)
+int atari_scsi_release(struct Scsi_Host *sh)
 {
 	if (IS_A_TT())
 		free_irq(IRQ_TT_MFP_SCSI, scsi_tt_intr);
 	if (atari_dma_buffer)
-		atari_stram_free (atari_dma_buffer);
+		atari_stram_free(atari_dma_buffer);
 	return 1;
 }
 
@@ -779,9 +774,9 @@ void __init atari_scsi_setup(char *str, int *ints)
 	 * Defaults depend on TT or Falcon, hostid determined at run time.
 	 * Negative values mean don't change.
 	 */
-	
+
 	if (ints[0] < 1) {
-		printk( "atari_scsi_setup: no arguments!\n" );
+		printk("atari_scsi_setup: no arguments!\n");
 		return;
 	}
 
@@ -807,7 +802,7 @@ void __init atari_scsi_setup(char *str, int *ints)
 		if (ints[4] >= 0 && ints[4] <= 7)
 			setup_hostid = ints[4];
 		else if (ints[4] > 7)
-			printk( "atari_scsi_setup: invalid host ID %d !\n", ints[4] );
+			printk("atari_scsi_setup: invalid host ID %d !\n", ints[4]);
 	}
 #ifdef SUPPORT_TAGS
 	if (ints[0] >= 5) {
@@ -819,7 +814,7 @@ void __init atari_scsi_setup(char *str, int *ints)
 
 int atari_scsi_bus_reset(Scsi_Cmnd *cmd)
 {
-	int		rv;
+	int rv;
 	struct NCR5380_hostdata *hostdata =
 		(struct NCR5380_hostdata *)cmd->device->host->hostdata;
 
@@ -829,13 +824,12 @@ int atari_scsi_bus_reset(Scsi_Cmnd *cmd)
 	 */
 	/* And abort a maybe active DMA transfer */
 	if (IS_A_TT()) {
-		atari_turnoff_irq( IRQ_TT_MFP_SCSI );
+		atari_turnoff_irq(IRQ_TT_MFP_SCSI);
 #ifdef REAL_DMA
 		tt_scsi_dma.dma_ctrl = 0;
 #endif /* REAL_DMA */
-	}
-	else {
-		atari_turnoff_irq( IRQ_MFP_FSCSI );
+	} else {
+		atari_turnoff_irq(IRQ_MFP_FSCSI);
 #ifdef REAL_DMA
 		st_dma.dma_mode_status = 0x90;
 		atari_dma_active = 0;
@@ -847,52 +841,51 @@ int atari_scsi_bus_reset(Scsi_Cmnd *cmd)
 
 	/* Re-enable ints */
 	if (IS_A_TT()) {
-		atari_turnon_irq( IRQ_TT_MFP_SCSI );
-	}
-	else {
-		atari_turnon_irq( IRQ_MFP_FSCSI );
+		atari_turnon_irq(IRQ_TT_MFP_SCSI);
+	} else {
+		atari_turnon_irq(IRQ_MFP_FSCSI);
 	}
 	if ((rv & SCSI_RESET_ACTION) == SCSI_RESET_SUCCESS)
 		falcon_release_lock_if_possible(hostdata);
 
-	return( rv );
+	return rv;
 }
 
-	
+
 #ifdef CONFIG_ATARI_SCSI_RESET_BOOT
 static void __init atari_scsi_reset_boot(void)
 {
 	unsigned long end;
-	
+
 	/*
 	 * Do a SCSI reset to clean up the bus during initialization. No messing
 	 * with the queues, interrupts, or locks necessary here.
 	 */
 
-	printk( "Atari SCSI: resetting the SCSI bus..." );
+	printk("Atari SCSI: resetting the SCSI bus...");
 
 	/* get in phase */
-	NCR5380_write( TARGET_COMMAND_REG,
-		      PHASE_SR_TO_TCR( NCR5380_read(STATUS_REG) ));
+	NCR5380_write(TARGET_COMMAND_REG,
+		      PHASE_SR_TO_TCR(NCR5380_read(STATUS_REG)));
 
 	/* assert RST */
-	NCR5380_write( INITIATOR_COMMAND_REG, ICR_BASE | ICR_ASSERT_RST );
+	NCR5380_write(INITIATOR_COMMAND_REG, ICR_BASE | ICR_ASSERT_RST);
 	/* The min. reset hold time is 25us, so 40us should be enough */
-	udelay( 50 );
+	udelay(50);
 	/* reset RST and interrupt */
-	NCR5380_write( INITIATOR_COMMAND_REG, ICR_BASE );
-	NCR5380_read( RESET_PARITY_INTERRUPT_REG );
+	NCR5380_write(INITIATOR_COMMAND_REG, ICR_BASE);
+	NCR5380_read(RESET_PARITY_INTERRUPT_REG);
 
 	end = jiffies + AFTER_RESET_DELAY;
 	while (time_before(jiffies, end))
 		barrier();
 
-	printk( " done\n" );
+	printk(" done\n");
 }
 #endif
 
 
-const char * atari_scsi_info (struct Scsi_Host *host)
+const char *atari_scsi_info(struct Scsi_Host *host)
 {
 	/* atari_scsi_detect() is verbose enough... */
 	static const char string[] = "Atari native SCSI";
@@ -902,10 +895,10 @@ const char * atari_scsi_info (struct Scsi_Host *host)
 
 #if defined(REAL_DMA)
 
-unsigned long atari_scsi_dma_setup( struct Scsi_Host *instance, void *data,
-				   unsigned long count, int dir )
+unsigned long atari_scsi_dma_setup(struct Scsi_Host *instance, void *data,
+				   unsigned long count, int dir)
 {
-	unsigned long addr = virt_to_phys( data );
+	unsigned long addr = virt_to_phys(data);
 
 	DMA_PRINTK("scsi%d: setting up dma, data = %p, phys = %lx, count = %ld, "
 		   "dir = %d\n", instance->host_no, data, addr, count, dir);
@@ -917,38 +910,37 @@ unsigned long atari_scsi_dma_setup( struct Scsi_Host *instance, void *data,
 		 * wanted address.
 		 */
 		if (dir)
-			memcpy( atari_dma_buffer, data, count );
+			memcpy(atari_dma_buffer, data, count);
 		else
 			atari_dma_orig_addr = data;
 		addr = atari_dma_phys_buffer;
 	}
-	
+
 	atari_dma_startaddr = addr;	/* Needed for calculating residual later. */
-  
+
 	/* Cache cleanup stuff: On writes, push any dirty cache out before sending
 	 * it to the peripheral. (Must be done before DMA setup, since at least
 	 * the ST-DMA begins to fill internal buffers right after setup. For
 	 * reads, invalidate any cache, may be altered after DMA without CPU
 	 * knowledge.
-	 * 
+	 *
 	 * ++roman: For the Medusa, there's no need at all for that cache stuff,
 	 * because the hardware does bus snooping (fine!).
 	 */
-	dma_cache_maintenance( addr, count, dir );
+	dma_cache_maintenance(addr, count, dir);
 
 	if (count == 0)
 		printk(KERN_NOTICE "SCSI warning: DMA programmed for 0 bytes !\n");
 
 	if (IS_A_TT()) {
 		tt_scsi_dma.dma_ctrl = dir;
-		SCSI_DMA_WRITE_P( dma_addr, addr );
-		SCSI_DMA_WRITE_P( dma_cnt, count );
+		SCSI_DMA_WRITE_P(dma_addr, addr);
+		SCSI_DMA_WRITE_P(dma_cnt, count);
 		tt_scsi_dma.dma_ctrl = dir | 2;
-	}
-	else { /* ! IS_A_TT */
-  
+	} else { /* ! IS_A_TT */
+
 		/* set address */
-		SCSI_DMA_SETADR( addr );
+		SCSI_DMA_SETADR(addr);
 
 		/* toggle direction bit to clear FIFO and set DMA direction */
 		dir <<= 8;
@@ -966,13 +958,13 @@ unsigned long atari_scsi_dma_setup( struct Scsi_Host *instance, void *data,
 		atari_dma_active = 1;
 	}
 
-	return( count );
+	return count;
 }
 
 
-static long atari_scsi_dma_residual( struct Scsi_Host *instance )
+static long atari_scsi_dma_residual(struct Scsi_Host *instance)
 {
-	return( atari_dma_residual );
+	return atari_dma_residual;
 }
 
 
@@ -980,13 +972,13 @@ static long atari_scsi_dma_residual( struct Scsi_Host *instance )
 #define	CMD_SURELY_BYTE_MODE	1
 #define	CMD_MODE_UNKNOWN		2
 
-static int falcon_classify_cmd( Scsi_Cmnd *cmd )
+static int falcon_classify_cmd(Scsi_Cmnd *cmd)
 {
 	unsigned char opcode = cmd->cmnd[0];
-	
+
 	if (opcode == READ_DEFECT_DATA || opcode == READ_LONG ||
-		opcode == READ_BUFFER)
-		return( CMD_SURELY_BYTE_MODE );
+	    opcode == READ_BUFFER)
+		return CMD_SURELY_BYTE_MODE;
 	else if (opcode == READ_6 || opcode == READ_10 ||
 		 opcode == 0xa8 /* READ_12 */ || opcode == READ_REVERSE ||
 		 opcode == RECOVER_BUFFERED_DATA) {
@@ -994,12 +986,11 @@ static int falcon_classify_cmd( Scsi_Cmnd *cmd )
 		 * needed here: The transfer is block-mode only if the 'fixed' bit is
 		 * set! */
 		if (cmd->device->type == TYPE_TAPE && !(cmd->cmnd[1] & 1))
-			return( CMD_SURELY_BYTE_MODE );
+			return CMD_SURELY_BYTE_MODE;
 		else
-			return( CMD_SURELY_BLOCK_MODE );
-	}
-	else
-		return( CMD_MODE_UNKNOWN );
+			return CMD_SURELY_BLOCK_MODE;
+	} else
+		return CMD_MODE_UNKNOWN;
 }
 
 
@@ -1012,19 +1003,18 @@ static int falcon_classify_cmd( Scsi_Cmnd *cmd )
  * the overrun problem, so this question is academic :-)
  */
 
-static unsigned long atari_dma_xfer_len( unsigned long wanted_len,
-					Scsi_Cmnd *cmd,
-					int write_flag )
+static unsigned long atari_dma_xfer_len(unsigned long wanted_len,
+					Scsi_Cmnd *cmd, int write_flag)
 {
 	unsigned long	possible_len, limit;
 #ifndef CONFIG_TT_DMA_EMUL
 	if (MACH_IS_HADES)
 		/* Hades has no SCSI DMA at all :-( Always force use of PIO */
-		return( 0 );
-#endif	
+		return 0;
+#endif
 	if (IS_A_TT())
 		/* TT SCSI DMA can transfer arbitrary #bytes */
-		return( wanted_len );
+		return wanted_len;
 
 	/* ST DMA chip is stupid -- only multiples of 512 bytes! (and max.
 	 * 255*512 bytes, but this should be enough)
@@ -1060,8 +1050,7 @@ static unsigned long atari_dma_xfer_len( unsigned long wanted_len,
 		 * this).
 		 */
 		possible_len = wanted_len;
-	}
-	else {
+	} else {
 		/* Read operations: if the wanted transfer length is not a multiple of
 		 * 512, we cannot use DMA, since the ST-DMA cannot split transfers
 		 * (no interrupt on DMA finished!)
@@ -1071,15 +1060,15 @@ static unsigned long atari_dma_xfer_len( unsigned long wanted_len,
 		else {
 			/* Now classify the command (see above) and decide whether it is
 			 * allowed to do DMA at all */
-			switch( falcon_classify_cmd( cmd )) {
-			  case CMD_SURELY_BLOCK_MODE:
+			switch (falcon_classify_cmd(cmd)) {
+			case CMD_SURELY_BLOCK_MODE:
 				possible_len = wanted_len;
 				break;
-			  case CMD_SURELY_BYTE_MODE:
+			case CMD_SURELY_BYTE_MODE:
 				possible_len = 0; /* DMA prohibited */
 				break;
-			  case CMD_MODE_UNKNOWN:
-			  default:
+			case CMD_MODE_UNKNOWN:
+			default:
 				/* For unknown commands assume block transfers if the transfer
 				 * size/allocation length is >= 1024 */
 				possible_len = (wanted_len < 1024) ? 0 : wanted_len;
@@ -1087,9 +1076,9 @@ static unsigned long atari_dma_xfer_len( unsigned long wanted_len,
 			}
 		}
 	}
-	
+
 	/* Last step: apply the hard limit on DMA transfers */
-	limit = (atari_dma_buffer && !STRAM_ADDR( virt_to_phys(cmd->SCp.ptr) )) ?
+	limit = (atari_dma_buffer && !STRAM_ADDR(virt_to_phys(cmd->SCp.ptr))) ?
 		    STRAM_BUFFER_SIZE : 255*512;
 	if (possible_len > limit)
 		possible_len = limit;
@@ -1098,7 +1087,7 @@ static unsigned long atari_dma_xfer_len( unsigned long wanted_len,
 		DMA_PRINTK("Sorry, must cut DMA transfer size to %ld bytes "
 			   "instead of %ld\n", possible_len, wanted_len);
 
-	return( possible_len );
+	return possible_len;
 }
 
 
@@ -1112,23 +1101,23 @@ static unsigned long atari_dma_xfer_len( unsigned long wanted_len,
  * NCR5380_write call these functions via function pointers.
  */
 
-static unsigned char atari_scsi_tt_reg_read( unsigned char reg )
+static unsigned char atari_scsi_tt_reg_read(unsigned char reg)
 {
-	return( tt_scsi_regp[reg * 2] );
+	return tt_scsi_regp[reg * 2];
 }
 
-static void atari_scsi_tt_reg_write( unsigned char reg, unsigned char value )
+static void atari_scsi_tt_reg_write(unsigned char reg, unsigned char value)
 {
 	tt_scsi_regp[reg * 2] = value;
 }
 
-static unsigned char atari_scsi_falcon_reg_read( unsigned char reg )
+static unsigned char atari_scsi_falcon_reg_read(unsigned char reg)
 {
 	dma_wd.dma_mode_status= (u_short)(0x88 + reg);
-	return( (u_char)dma_wd.fdc_acces_seccount );
+	return (u_char)dma_wd.fdc_acces_seccount;
 }
 
-static void atari_scsi_falcon_reg_write( unsigned char reg, unsigned char value )
+static void atari_scsi_falcon_reg_write(unsigned char reg, unsigned char value)
 {
 	dma_wd.dma_mode_status = (u_short)(0x88 + reg);
 	dma_wd.fdc_acces_seccount = (u_short)value;

commit fb810d121bceb945c5e576356bccba11cbfad7e3
Author: Michael Schmitz <schmitz@opal.biophys.uni-duesseldorf.de>
Date:   Tue May 1 22:32:35 2007 +0200

    m68k: Atari SCSI revival
    
    SCSI should be working on a TT (but someone should really try!) but causes
    trouble on a Falcon (as in: it ate a filesystem of mine) at least when
    used concurrently with IDE. I have the notion it's because locking of the
    ST-DMA interrupt by IDE is broken in 2.6 (the IDE driver always complains
    about trying to release an already-released ST-DMA). Needs more work, but
    that's on the IDE or m68k interrupt side rather than SCSI.
    
    Signed-off-by: Michael Schmitz <schmitz@debian.org>
    Signed-off-by: Roman Zippel <zippel@linux-m68k.org>
    Signed-off-by: Geert Uytterhoeven <geert@linux-m68k.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/scsi/atari_scsi.c b/drivers/scsi/atari_scsi.c
index 642de7b2b7a2..85b8acc94034 100644
--- a/drivers/scsi/atari_scsi.c
+++ b/drivers/scsi/atari_scsi.c
@@ -395,7 +395,7 @@ static irqreturn_t scsi_tt_intr (int irq, void *dummy)
 
 #endif /* REAL_DMA */
 	
-	NCR5380_intr (0, 0, 0);
+	NCR5380_intr(0, 0);
 
 #if 0
 	/* To be sure the int is not masked */
@@ -461,7 +461,7 @@ static irqreturn_t scsi_falcon_intr (int irq, void *dummy)
 
 #endif /* REAL_DMA */
 
-	NCR5380_intr (0, 0, 0);
+	NCR5380_intr(0, 0);
 	return IRQ_HANDLED;
 }
 
@@ -557,11 +557,11 @@ static void falcon_get_lock( void )
 
 	local_irq_save(flags);
 
-	while( !in_interrupt() && falcon_got_lock && stdma_others_waiting() )
+	while (!in_irq() && falcon_got_lock && stdma_others_waiting())
 		sleep_on( &falcon_fairness_wait );
 
 	while (!falcon_got_lock) {
-		if (in_interrupt())
+		if (in_irq())
 			panic( "Falcon SCSI hasn't ST-DMA lock in interrupt" );
 		if (!falcon_trying_lock) {
 			falcon_trying_lock = 1;
@@ -763,7 +763,6 @@ int atari_scsi_detect (struct scsi_host_template *host)
 	return( 1 );
 }
 
-#ifdef MODULE
 int atari_scsi_release (struct Scsi_Host *sh)
 {
 	if (IS_A_TT())
@@ -772,7 +771,6 @@ int atari_scsi_release (struct Scsi_Host *sh)
 		atari_stram_free (atari_dma_buffer);
 	return 1;
 }
-#endif
 
 void __init atari_scsi_setup(char *str, int *ints)
 {

commit cd354f1ae75e6466a7e31b727faede57a1f89ca5
Author: Tim Schmielau <tim@physik3.uni-rostock.de>
Date:   Wed Feb 14 00:33:14 2007 -0800

    [PATCH] remove many unneeded #includes of sched.h
    
    After Al Viro (finally) succeeded in removing the sched.h #include in module.h
    recently, it makes sense again to remove other superfluous sched.h includes.
    There are quite a lot of files which include it but don't actually need
    anything defined in there.  Presumably these includes were once needed for
    macros that used to live in sched.h, but moved to other header files in the
    course of cleaning it up.
    
    To ease the pain, this time I did not fiddle with any header files and only
    removed #includes from .c-files, which tend to cause less trouble.
    
    Compile tested against 2.6.20-rc2 and 2.6.20-rc2-mm2 (with offsets) on alpha,
    arm, i386, ia64, mips, powerpc, and x86_64 with allnoconfig, defconfig,
    allmodconfig, and allyesconfig as well as a few randconfigs on x86_64 and all
    configs in arch/arm/configs on arm.  I also checked that no new warnings were
    introduced by the patch (actually, some warnings are removed that were emitted
    by unnecessarily included header files).
    
    Signed-off-by: Tim Schmielau <tim@physik3.uni-rostock.de>
    Acked-by: Russell King <rmk+kernel@arm.linux.org.uk>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/scsi/atari_scsi.c b/drivers/scsi/atari_scsi.c
index dfb1bcfae82e..642de7b2b7a2 100644
--- a/drivers/scsi/atari_scsi.c
+++ b/drivers/scsi/atari_scsi.c
@@ -86,7 +86,6 @@
 #include <linux/delay.h>
 #include <linux/mm.h>
 #include <linux/blkdev.h>
-#include <linux/sched.h>
 #include <linux/interrupt.h>
 #include <linux/init.h>
 #include <linux/nvram.h>

commit 7d12e780e003f93433d49ce78cfedf4b4c52adc5
Author: David Howells <dhowells@redhat.com>
Date:   Thu Oct 5 14:55:46 2006 +0100

    IRQ: Maintain regs pointer globally rather than passing to IRQ handlers
    
    Maintain a per-CPU global "struct pt_regs *" variable which can be used instead
    of passing regs around manually through all ~1800 interrupt handlers in the
    Linux kernel.
    
    The regs pointer is used in few places, but it potentially costs both stack
    space and code to pass it around.  On the FRV arch, removing the regs parameter
    from all the genirq function results in a 20% speed up of the IRQ exit path
    (ie: from leaving timer_interrupt() to leaving do_IRQ()).
    
    Where appropriate, an arch may override the generic storage facility and do
    something different with the variable.  On FRV, for instance, the address is
    maintained in GR28 at all times inside the kernel as part of general exception
    handling.
    
    Having looked over the code, it appears that the parameter may be handed down
    through up to twenty or so layers of functions.  Consider a USB character
    device attached to a USB hub, attached to a USB controller that posts its
    interrupts through a cascaded auxiliary interrupt controller.  A character
    device driver may want to pass regs to the sysrq handler through the input
    layer which adds another few layers of parameter passing.
    
    I've build this code with allyesconfig for x86_64 and i386.  I've runtested the
    main part of the code on FRV and i386, though I can't test most of the drivers.
    I've also done partial conversion for powerpc and MIPS - these at least compile
    with minimal configurations.
    
    This will affect all archs.  Mostly the changes should be relatively easy.
    Take do_IRQ(), store the regs pointer at the beginning, saving the old one:
    
            struct pt_regs *old_regs = set_irq_regs(regs);
    
    And put the old one back at the end:
    
            set_irq_regs(old_regs);
    
    Don't pass regs through to generic_handle_irq() or __do_IRQ().
    
    In timer_interrupt(), this sort of change will be necessary:
    
            -       update_process_times(user_mode(regs));
            -       profile_tick(CPU_PROFILING, regs);
            +       update_process_times(user_mode(get_irq_regs()));
            +       profile_tick(CPU_PROFILING);
    
    I'd like to move update_process_times()'s use of get_irq_regs() into itself,
    except that i386, alone of the archs, uses something other than user_mode().
    
    Some notes on the interrupt handling in the drivers:
    
     (*) input_dev() is now gone entirely.  The regs pointer is no longer stored in
         the input_dev struct.
    
     (*) finish_unlinks() in drivers/usb/host/ohci-q.c needs checking.  It does
         something different depending on whether it's been supplied with a regs
         pointer or not.
    
     (*) Various IRQ handler function pointers have been moved to type
         irq_handler_t.
    
    Signed-Off-By: David Howells <dhowells@redhat.com>
    (cherry picked from 1b16e7ac850969f38b375e511e3fa2f474a33867 commit)

diff --git a/drivers/scsi/atari_scsi.c b/drivers/scsi/atari_scsi.c
index e1be4a4387cd..dfb1bcfae82e 100644
--- a/drivers/scsi/atari_scsi.c
+++ b/drivers/scsi/atari_scsi.c
@@ -194,8 +194,8 @@ static int falcon_classify_cmd( Scsi_Cmnd *cmd );
 static unsigned long atari_dma_xfer_len( unsigned long wanted_len,
                                          Scsi_Cmnd *cmd, int write_flag );
 #endif
-static irqreturn_t scsi_tt_intr( int irq, void *dummy, struct pt_regs *fp);
-static irqreturn_t scsi_falcon_intr( int irq, void *dummy, struct pt_regs *fp);
+static irqreturn_t scsi_tt_intr( int irq, void *dummy);
+static irqreturn_t scsi_falcon_intr( int irq, void *dummy);
 static void falcon_release_lock_if_possible( struct NCR5380_hostdata *
                                              hostdata );
 static void falcon_get_lock( void );
@@ -285,7 +285,7 @@ static int scsi_dma_is_ignored_buserr( unsigned char dma_stat )
  * end-of-DMA, both SCSI ints are triggered simultaneously, so the NCR int has
  * to clear the DMA int pending bit before it allows other level 6 interrupts.
  */
-static void scsi_dma_buserr (int irq, void *dummy, struct pt_regs *fp)
+static void scsi_dma_buserr (int irq, void *dummy)
 {
 	unsigned char	dma_stat = tt_scsi_dma.dma_ctrl;
 
@@ -314,7 +314,7 @@ static void scsi_dma_buserr (int irq, void *dummy, struct pt_regs *fp)
 #endif
 
 
-static irqreturn_t scsi_tt_intr (int irq, void *dummy, struct pt_regs *fp)
+static irqreturn_t scsi_tt_intr (int irq, void *dummy)
 {
 #ifdef REAL_DMA
 	int dma_stat;
@@ -406,7 +406,7 @@ static irqreturn_t scsi_tt_intr (int irq, void *dummy, struct pt_regs *fp)
 }
 
 
-static irqreturn_t scsi_falcon_intr (int irq, void *dummy, struct pt_regs *fp)
+static irqreturn_t scsi_falcon_intr (int irq, void *dummy)
 {
 #ifdef REAL_DMA
 	int dma_stat;

commit 6ab3d5624e172c553004ecc862bfeac16d9d68b7
Author: Jörn Engel <joern@wohnheim.fh-wedel.de>
Date:   Fri Jun 30 19:25:36 2006 +0200

    Remove obsolete #include <linux/config.h>
    
    Signed-off-by: Jörn Engel <joern@wohnheim.fh-wedel.de>
    Signed-off-by: Adrian Bunk <bunk@stusta.de>

diff --git a/drivers/scsi/atari_scsi.c b/drivers/scsi/atari_scsi.c
index f677c5a32a68..e1be4a4387cd 100644
--- a/drivers/scsi/atari_scsi.c
+++ b/drivers/scsi/atari_scsi.c
@@ -65,7 +65,6 @@
 
 
 
-#include <linux/config.h>
 #include <linux/module.h>
 
 #define NDEBUG (0)

commit 8d3b33f67fdc0fb364a1ef6d8fbbea7c2e4e6c98
Author: Rusty Russell <rusty@rustcorp.com.au>
Date:   Sat Mar 25 03:07:05 2006 -0800

    [PATCH] Remove MODULE_PARM
    
    MODULE_PARM was actually breaking: recent gcc version optimize them out as
    unused.  It's time to replace the last users, which are generally in the
    most unloved drivers anyway.
    
    Signed-off-by: Rusty Russell <rusty@rustcorp.com.au>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/drivers/scsi/atari_scsi.c b/drivers/scsi/atari_scsi.c
index f4c1ca7c1572..f677c5a32a68 100644
--- a/drivers/scsi/atari_scsi.c
+++ b/drivers/scsi/atari_scsi.c
@@ -239,17 +239,17 @@ static int atari_read_overruns = 0;
 #endif
 
 static int setup_can_queue = -1;
-MODULE_PARM(setup_can_queue, "i");
+module_param(setup_can_queue, int, 0);
 static int setup_cmd_per_lun = -1;
-MODULE_PARM(setup_cmd_per_lun, "i");
+module_param(setup_cmd_per_lun, int, 0);
 static int setup_sg_tablesize = -1;
-MODULE_PARM(setup_sg_tablesize, "i");
+module_param(setup_sg_tablesize, int, 0);
 #ifdef SUPPORT_TAGS
 static int setup_use_tagged_queuing = -1;
-MODULE_PARM(setup_use_tagged_queuing, "i");
+module_param(setup_use_tagged_queuing, int, 0);
 #endif
 static int setup_hostid = -1;
-MODULE_PARM(setup_hostid, "i");
+module_param(setup_hostid, int, 0);
 
 
 #if defined(CONFIG_TT_DMA_EMUL)

commit d0be4a7d29ad0bd3ce2209dd9e46d410b632db59
Author: Christoph Hellwig <hch@lst.de>
Date:   Mon Oct 31 18:31:40 2005 +0100

    [SCSI] remove Scsi_Host_Template typedef
    
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>

diff --git a/drivers/scsi/atari_scsi.c b/drivers/scsi/atari_scsi.c
index af8adb629b33..f4c1ca7c1572 100644
--- a/drivers/scsi/atari_scsi.c
+++ b/drivers/scsi/atari_scsi.c
@@ -600,7 +600,7 @@ int atari_queue_command (Scsi_Cmnd *cmd, void (*done)(Scsi_Cmnd *))
 #endif
 
 
-int atari_scsi_detect (Scsi_Host_Template *host)
+int atari_scsi_detect (struct scsi_host_template *host)
 {
 	static int called = 0;
 	struct Scsi_Host *instance;
@@ -1141,7 +1141,7 @@ static void atari_scsi_falcon_reg_write( unsigned char reg, unsigned char value
 
 #include "atari_NCR5380.c"
 
-static Scsi_Host_Template driver_template = {
+static struct scsi_host_template driver_template = {
 	.proc_info		= atari_scsi_proc_info,
 	.name			= "Atari native SCSI",
 	.detect			= atari_scsi_detect,

commit 1da177e4c3f41524e886b7f1b8a0c1fc7321cac2
Author: Linus Torvalds <torvalds@ppc970.osdl.org>
Date:   Sat Apr 16 15:20:36 2005 -0700

    Linux-2.6.12-rc2
    
    Initial git repository build. I'm not bothering with the full history,
    even though we have it. We can create a separate "historical" git
    archive of that later if we want to, and in the meantime it's about
    3.2GB when imported into git - space that would just make the early
    git days unnecessarily complicated, when we don't have a lot of good
    infrastructure for it.
    
    Let it rip!

diff --git a/drivers/scsi/atari_scsi.c b/drivers/scsi/atari_scsi.c
new file mode 100644
index 000000000000..af8adb629b33
--- /dev/null
+++ b/drivers/scsi/atari_scsi.c
@@ -0,0 +1,1163 @@
+/*
+ * atari_scsi.c -- Device dependent functions for the Atari generic SCSI port
+ *
+ * Copyright 1994 Roman Hodek <Roman.Hodek@informatik.uni-erlangen.de>
+ *
+ *   Loosely based on the work of Robert De Vries' team and added:
+ *    - working real DMA
+ *    - Falcon support (untested yet!)   ++bjoern fixed and now it works
+ *    - lots of extensions and bug fixes.
+ *
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file COPYING in the main directory of this archive
+ * for more details.
+ *
+ */
+
+
+/**************************************************************************/
+/*                                                                        */
+/* Notes for Falcon SCSI:                                                 */
+/* ----------------------                                                 */
+/*                                                                        */
+/* Since the Falcon SCSI uses the ST-DMA chip, that is shared among       */
+/* several device drivers, locking and unlocking the access to this       */
+/* chip is required. But locking is not possible from an interrupt,       */
+/* since it puts the process to sleep if the lock is not available.       */
+/* This prevents "late" locking of the DMA chip, i.e. locking it just     */
+/* before using it, since in case of disconnection-reconnection           */
+/* commands, the DMA is started from the reselection interrupt.           */
+/*                                                                        */
+/* Two possible schemes for ST-DMA-locking would be:                      */
+/*  1) The lock is taken for each command separately and disconnecting    */
+/*     is forbidden (i.e. can_queue = 1).                                 */
+/*  2) The DMA chip is locked when the first command comes in and         */
+/*     released when the last command is finished and all queues are      */
+/*     empty.                                                             */
+/* The first alternative would result in bad performance, since the       */
+/* interleaving of commands would not be used. The second is unfair to    */
+/* other drivers using the ST-DMA, because the queues will seldom be      */
+/* totally empty if there is a lot of disk traffic.                       */
+/*                                                                        */
+/* For this reasons I decided to employ a more elaborate scheme:          */
+/*  - First, we give up the lock every time we can (for fairness), this    */
+/*    means every time a command finishes and there are no other commands */
+/*    on the disconnected queue.                                          */
+/*  - If there are others waiting to lock the DMA chip, we stop           */
+/*    issuing commands, i.e. moving them onto the issue queue.           */
+/*    Because of that, the disconnected queue will run empty in a         */
+/*    while. Instead we go to sleep on a 'fairness_queue'.                */
+/*  - If the lock is released, all processes waiting on the fairness      */
+/*    queue will be woken. The first of them tries to re-lock the DMA,     */
+/*    the others wait for the first to finish this task. After that,      */
+/*    they can all run on and do their commands...                        */
+/* This sounds complicated (and it is it :-(), but it seems to be a       */
+/* good compromise between fairness and performance: As long as no one     */
+/* else wants to work with the ST-DMA chip, SCSI can go along as          */
+/* usual. If now someone else comes, this behaviour is changed to a       */
+/* "fairness mode": just already initiated commands are finished and      */
+/* then the lock is released. The other one waiting will probably win     */
+/* the race for locking the DMA, since it was waiting for longer. And     */
+/* after it has finished, SCSI can go ahead again. Finally: I hope I      */
+/* have not produced any deadlock possibilities!                          */
+/*                                                                        */
+/**************************************************************************/
+
+
+
+#include <linux/config.h>
+#include <linux/module.h>
+
+#define NDEBUG (0)
+
+#define NDEBUG_ABORT	0x800000
+#define NDEBUG_TAGS	0x1000000
+#define NDEBUG_MERGING	0x2000000
+
+#define AUTOSENSE
+/* For the Atari version, use only polled IO or REAL_DMA */
+#define	REAL_DMA
+/* Support tagged queuing? (on devices that are able to... :-) */
+#define	SUPPORT_TAGS
+#define	MAX_TAGS 32
+
+#include <linux/types.h>
+#include <linux/stddef.h>
+#include <linux/ctype.h>
+#include <linux/delay.h>
+#include <linux/mm.h>
+#include <linux/blkdev.h>
+#include <linux/sched.h>
+#include <linux/interrupt.h>
+#include <linux/init.h>
+#include <linux/nvram.h>
+#include <linux/bitops.h>
+
+#include <asm/setup.h>
+#include <asm/atarihw.h>
+#include <asm/atariints.h>
+#include <asm/page.h>
+#include <asm/pgtable.h>
+#include <asm/irq.h>
+#include <asm/traps.h>
+
+#include "scsi.h"
+#include <scsi/scsi_host.h>
+#include "atari_scsi.h"
+#include "NCR5380.h"
+#include <asm/atari_stdma.h>
+#include <asm/atari_stram.h>
+#include <asm/io.h>
+
+#include <linux/stat.h>
+
+#define	IS_A_TT()	ATARIHW_PRESENT(TT_SCSI)
+
+#define	SCSI_DMA_WRITE_P(elt,val)				\
+	do {							\
+		unsigned long v = val;				\
+		tt_scsi_dma.elt##_lo = v & 0xff;		\
+		v >>= 8;					\
+		tt_scsi_dma.elt##_lmd = v & 0xff;		\
+		v >>= 8;					\
+		tt_scsi_dma.elt##_hmd = v & 0xff;		\
+		v >>= 8;					\
+		tt_scsi_dma.elt##_hi = v & 0xff;		\
+	} while(0)
+
+#define	SCSI_DMA_READ_P(elt)					\
+	(((((((unsigned long)tt_scsi_dma.elt##_hi << 8) |	\
+	     (unsigned long)tt_scsi_dma.elt##_hmd) << 8) |	\
+	   (unsigned long)tt_scsi_dma.elt##_lmd) << 8) |	\
+	 (unsigned long)tt_scsi_dma.elt##_lo)
+
+
+static inline void SCSI_DMA_SETADR(unsigned long adr)
+{
+	st_dma.dma_lo = (unsigned char)adr;
+	MFPDELAY();
+	adr >>= 8;
+	st_dma.dma_md = (unsigned char)adr;
+	MFPDELAY();
+	adr >>= 8;
+	st_dma.dma_hi = (unsigned char)adr;
+	MFPDELAY();
+}
+
+static inline unsigned long SCSI_DMA_GETADR(void)
+{
+	unsigned long adr;
+	adr = st_dma.dma_lo;
+	MFPDELAY();
+	adr |= (st_dma.dma_md & 0xff) << 8;
+	MFPDELAY();
+	adr |= (st_dma.dma_hi & 0xff) << 16;
+	MFPDELAY();
+	return adr;
+}
+
+static inline void ENABLE_IRQ(void)
+{
+	if (IS_A_TT())
+		atari_enable_irq(IRQ_TT_MFP_SCSI);
+	else
+		atari_enable_irq(IRQ_MFP_FSCSI);
+}
+
+static inline void DISABLE_IRQ(void)
+{
+	if (IS_A_TT())
+		atari_disable_irq(IRQ_TT_MFP_SCSI);
+	else
+		atari_disable_irq(IRQ_MFP_FSCSI);
+}
+
+
+#define HOSTDATA_DMALEN		(((struct NCR5380_hostdata *) \
+				(atari_scsi_host->hostdata))->dma_len)
+
+/* Time (in jiffies) to wait after a reset; the SCSI standard calls for 250ms,
+ * we usually do 0.5s to be on the safe side. But Toshiba CD-ROMs once more
+ * need ten times the standard value... */
+#ifndef CONFIG_ATARI_SCSI_TOSHIBA_DELAY
+#define	AFTER_RESET_DELAY	(HZ/2)
+#else
+#define	AFTER_RESET_DELAY	(5*HZ/2)
+#endif
+
+/***************************** Prototypes *****************************/
+
+#ifdef REAL_DMA
+static int scsi_dma_is_ignored_buserr( unsigned char dma_stat );
+static void atari_scsi_fetch_restbytes( void );
+static long atari_scsi_dma_residual( struct Scsi_Host *instance );
+static int falcon_classify_cmd( Scsi_Cmnd *cmd );
+static unsigned long atari_dma_xfer_len( unsigned long wanted_len,
+                                         Scsi_Cmnd *cmd, int write_flag );
+#endif
+static irqreturn_t scsi_tt_intr( int irq, void *dummy, struct pt_regs *fp);
+static irqreturn_t scsi_falcon_intr( int irq, void *dummy, struct pt_regs *fp);
+static void falcon_release_lock_if_possible( struct NCR5380_hostdata *
+                                             hostdata );
+static void falcon_get_lock( void );
+#ifdef CONFIG_ATARI_SCSI_RESET_BOOT
+static void atari_scsi_reset_boot( void );
+#endif
+static unsigned char atari_scsi_tt_reg_read( unsigned char reg );
+static void atari_scsi_tt_reg_write( unsigned char reg, unsigned char value);
+static unsigned char atari_scsi_falcon_reg_read( unsigned char reg );
+static void atari_scsi_falcon_reg_write( unsigned char reg, unsigned char value );
+
+/************************* End of Prototypes **************************/
+
+
+static struct Scsi_Host *atari_scsi_host = NULL;
+static unsigned char (*atari_scsi_reg_read)( unsigned char reg );
+static void (*atari_scsi_reg_write)( unsigned char reg, unsigned char value );
+
+#ifdef REAL_DMA
+static unsigned long	atari_dma_residual, atari_dma_startaddr;
+static short		atari_dma_active;
+/* pointer to the dribble buffer */
+static char		*atari_dma_buffer = NULL;
+/* precalculated physical address of the dribble buffer */
+static unsigned long	atari_dma_phys_buffer;
+/* != 0 tells the Falcon int handler to copy data from the dribble buffer */
+static char		*atari_dma_orig_addr;
+/* size of the dribble buffer; 4k seems enough, since the Falcon cannot use
+ * scatter-gather anyway, so most transfers are 1024 byte only. In the rare
+ * cases where requests to physical contiguous buffers have been merged, this
+ * request is <= 4k (one page). So I don't think we have to split transfers
+ * just due to this buffer size...
+ */
+#define	STRAM_BUFFER_SIZE	(4096)
+/* mask for address bits that can't be used with the ST-DMA */
+static unsigned long	atari_dma_stram_mask;
+#define STRAM_ADDR(a)	(((a) & atari_dma_stram_mask) == 0)
+/* number of bytes to cut from a transfer to handle NCR overruns */
+static int atari_read_overruns = 0;
+#endif
+
+static int setup_can_queue = -1;
+MODULE_PARM(setup_can_queue, "i");
+static int setup_cmd_per_lun = -1;
+MODULE_PARM(setup_cmd_per_lun, "i");
+static int setup_sg_tablesize = -1;
+MODULE_PARM(setup_sg_tablesize, "i");
+#ifdef SUPPORT_TAGS
+static int setup_use_tagged_queuing = -1;
+MODULE_PARM(setup_use_tagged_queuing, "i");
+#endif
+static int setup_hostid = -1;
+MODULE_PARM(setup_hostid, "i");
+
+
+#if defined(CONFIG_TT_DMA_EMUL)
+#include "atari_dma_emul.c"
+#endif
+
+#if defined(REAL_DMA)
+
+static int scsi_dma_is_ignored_buserr( unsigned char dma_stat )
+{
+	int i;
+	unsigned long	addr = SCSI_DMA_READ_P( dma_addr ), end_addr;
+
+	if (dma_stat & 0x01) {
+
+		/* A bus error happens when DMA-ing from the last page of a
+		 * physical memory chunk (DMA prefetch!), but that doesn't hurt.
+		 * Check for this case:
+		 */
+		
+		for( i = 0; i < m68k_num_memory; ++i ) {
+			end_addr = m68k_memory[i].addr +
+				m68k_memory[i].size;
+			if (end_addr <= addr && addr <= end_addr + 4)
+				return( 1 );
+		}
+	}
+	return( 0 );
+}
+
+
+#if 0
+/* Dead code... wasn't called anyway :-) and causes some trouble, because at
+ * end-of-DMA, both SCSI ints are triggered simultaneously, so the NCR int has
+ * to clear the DMA int pending bit before it allows other level 6 interrupts.
+ */
+static void scsi_dma_buserr (int irq, void *dummy, struct pt_regs *fp)
+{
+	unsigned char	dma_stat = tt_scsi_dma.dma_ctrl;
+
+	/* Don't do anything if a NCR interrupt is pending. Probably it's just
+	 * masked... */
+	if (atari_irq_pending( IRQ_TT_MFP_SCSI ))
+		return;
+	
+	printk("Bad SCSI DMA interrupt! dma_addr=0x%08lx dma_stat=%02x dma_cnt=%08lx\n",
+	       SCSI_DMA_READ_P(dma_addr), dma_stat, SCSI_DMA_READ_P(dma_cnt));
+	if (dma_stat & 0x80) {
+		if (!scsi_dma_is_ignored_buserr( dma_stat ))
+			printk( "SCSI DMA bus error -- bad DMA programming!\n" );
+	}
+	else {
+		/* Under normal circumstances we never should get to this point,
+		 * since both interrupts are triggered simultaneously and the 5380
+		 * int has higher priority. When this irq is handled, that DMA
+		 * interrupt is cleared. So a warning message is printed here.
+		 */
+		printk( "SCSI DMA intr ?? -- this shouldn't happen!\n" );
+	}
+}
+#endif
+
+#endif
+
+
+static irqreturn_t scsi_tt_intr (int irq, void *dummy, struct pt_regs *fp)
+{
+#ifdef REAL_DMA
+	int dma_stat;
+
+	dma_stat = tt_scsi_dma.dma_ctrl;
+
+	INT_PRINTK("scsi%d: NCR5380 interrupt, DMA status = %02x\n",
+		   atari_scsi_host->host_no, dma_stat & 0xff);
+
+	/* Look if it was the DMA that has interrupted: First possibility
+	 * is that a bus error occurred...
+	 */
+	if (dma_stat & 0x80) {
+		if (!scsi_dma_is_ignored_buserr( dma_stat )) {
+			printk(KERN_ERR "SCSI DMA caused bus error near 0x%08lx\n",
+			       SCSI_DMA_READ_P(dma_addr));
+			printk(KERN_CRIT "SCSI DMA bus error -- bad DMA programming!");
+		}
+	}
+
+	/* If the DMA is active but not finished, we have the case
+	 * that some other 5380 interrupt occurred within the DMA transfer.
+	 * This means we have residual bytes, if the desired end address
+	 * is not yet reached. Maybe we have to fetch some bytes from the
+	 * rest data register, too. The residual must be calculated from
+	 * the address pointer, not the counter register, because only the
+	 * addr reg counts bytes not yet written and pending in the rest
+	 * data reg!
+	 */
+	if ((dma_stat & 0x02) && !(dma_stat & 0x40)) {
+		atari_dma_residual = HOSTDATA_DMALEN - (SCSI_DMA_READ_P( dma_addr ) -
+												atari_dma_startaddr);
+
+		DMA_PRINTK("SCSI DMA: There are %ld residual bytes.\n",
+			   atari_dma_residual);
+
+		if ((signed int)atari_dma_residual < 0)
+			atari_dma_residual = 0;
+		if ((dma_stat & 1) == 0) {
+			/* After read operations, we maybe have to
+			   transport some rest bytes */
+			atari_scsi_fetch_restbytes();
+		}
+		else {
+			/* There seems to be a nasty bug in some SCSI-DMA/NCR
+			   combinations: If a target disconnects while a write
+			   operation is going on, the address register of the
+			   DMA may be a few bytes farer than it actually read.
+			   This is probably due to DMA prefetching and a delay
+			   between DMA and NCR.  Experiments showed that the
+			   dma_addr is 9 bytes to high, but this could vary.
+			   The problem is, that the residual is thus calculated
+			   wrong and the next transfer will start behind where
+			   it should.  So we round up the residual to the next
+			   multiple of a sector size, if it isn't already a
+			   multiple and the originally expected transfer size
+			   was.  The latter condition is there to ensure that
+			   the correction is taken only for "real" data
+			   transfers and not for, e.g., the parameters of some
+			   other command.  These shouldn't disconnect anyway.
+			   */
+			if (atari_dma_residual & 0x1ff) {
+				DMA_PRINTK("SCSI DMA: DMA bug corrected, "
+					   "difference %ld bytes\n",
+					   512 - (atari_dma_residual & 0x1ff));
+				atari_dma_residual = (atari_dma_residual + 511) & ~0x1ff;
+			}
+		}
+		tt_scsi_dma.dma_ctrl = 0;
+	}
+
+	/* If the DMA is finished, fetch the rest bytes and turn it off */
+	if (dma_stat & 0x40) {
+		atari_dma_residual = 0;
+		if ((dma_stat & 1) == 0)
+			atari_scsi_fetch_restbytes();
+		tt_scsi_dma.dma_ctrl = 0;
+	}
+
+#endif /* REAL_DMA */
+	
+	NCR5380_intr (0, 0, 0);
+
+#if 0
+	/* To be sure the int is not masked */
+	atari_enable_irq( IRQ_TT_MFP_SCSI );
+#endif
+	return IRQ_HANDLED;
+}
+
+
+static irqreturn_t scsi_falcon_intr (int irq, void *dummy, struct pt_regs *fp)
+{
+#ifdef REAL_DMA
+	int dma_stat;
+
+	/* Turn off DMA and select sector counter register before
+	 * accessing the status register (Atari recommendation!)
+	 */
+	st_dma.dma_mode_status = 0x90;
+	dma_stat = st_dma.dma_mode_status;
+
+	/* Bit 0 indicates some error in the DMA process... don't know
+	 * what happened exactly (no further docu).
+	 */
+	if (!(dma_stat & 0x01)) {
+		/* DMA error */
+		printk(KERN_CRIT "SCSI DMA error near 0x%08lx!\n", SCSI_DMA_GETADR());
+	}
+
+	/* If the DMA was active, but now bit 1 is not clear, it is some
+	 * other 5380 interrupt that finishes the DMA transfer. We have to
+	 * calculate the number of residual bytes and give a warning if
+	 * bytes are stuck in the ST-DMA fifo (there's no way to reach them!)
+	 */
+	if (atari_dma_active && (dma_stat & 0x02)) {
+		unsigned long	transferred;
+
+		transferred = SCSI_DMA_GETADR() - atari_dma_startaddr;
+		/* The ST-DMA address is incremented in 2-byte steps, but the
+		 * data are written only in 16-byte chunks. If the number of
+		 * transferred bytes is not divisible by 16, the remainder is
+		 * lost somewhere in outer space.
+		 */
+		if (transferred & 15)
+			printk(KERN_ERR "SCSI DMA error: %ld bytes lost in "
+			       "ST-DMA fifo\n", transferred & 15);
+
+		atari_dma_residual = HOSTDATA_DMALEN - transferred;
+		DMA_PRINTK("SCSI DMA: There are %ld residual bytes.\n",
+			   atari_dma_residual);
+	}
+	else
+		atari_dma_residual = 0;
+	atari_dma_active = 0;
+
+	if (atari_dma_orig_addr) {
+		/* If the dribble buffer was used on a read operation, copy the DMA-ed
+		 * data to the original destination address.
+		 */
+		memcpy(atari_dma_orig_addr, phys_to_virt(atari_dma_startaddr),
+		       HOSTDATA_DMALEN - atari_dma_residual);
+		atari_dma_orig_addr = NULL;
+	}
+
+#endif /* REAL_DMA */
+
+	NCR5380_intr (0, 0, 0);
+	return IRQ_HANDLED;
+}
+
+
+#ifdef REAL_DMA
+static void atari_scsi_fetch_restbytes( void )
+{
+	int nr;
+	char *src, *dst;
+	unsigned long phys_dst;
+
+	/* fetch rest bytes in the DMA register */
+	phys_dst = SCSI_DMA_READ_P(dma_addr);
+	nr = phys_dst & 3;
+	if (nr) {
+		/* there are 'nr' bytes left for the last long address
+		   before the DMA pointer */
+		phys_dst ^= nr;
+		DMA_PRINTK("SCSI DMA: there are %d rest bytes for phys addr 0x%08lx",
+			   nr, phys_dst);
+		/* The content of the DMA pointer is a physical address!  */
+		dst = phys_to_virt(phys_dst);
+		DMA_PRINTK(" = virt addr %p\n", dst);
+		for (src = (char *)&tt_scsi_dma.dma_restdata; nr != 0; --nr)
+			*dst++ = *src++;
+	}
+}
+#endif /* REAL_DMA */
+
+
+static int falcon_got_lock = 0;
+static DECLARE_WAIT_QUEUE_HEAD(falcon_fairness_wait);
+static int falcon_trying_lock = 0;
+static DECLARE_WAIT_QUEUE_HEAD(falcon_try_wait);
+static int falcon_dont_release = 0;
+
+/* This function releases the lock on the DMA chip if there is no
+ * connected command and the disconnected queue is empty. On
+ * releasing, instances of falcon_get_lock are awoken, that put
+ * themselves to sleep for fairness. They can now try to get the lock
+ * again (but others waiting longer more probably will win).
+ */
+
+static void
+falcon_release_lock_if_possible( struct NCR5380_hostdata * hostdata )
+{
+	unsigned long flags;
+		
+	if (IS_A_TT()) return;
+	
+	local_irq_save(flags);
+
+	if (falcon_got_lock &&
+		!hostdata->disconnected_queue &&
+		!hostdata->issue_queue &&
+		!hostdata->connected) {
+
+		if (falcon_dont_release) {
+#if 0
+			printk("WARNING: Lock release not allowed. Ignored\n");
+#endif
+			local_irq_restore(flags);
+			return;
+		}
+		falcon_got_lock = 0;
+		stdma_release();
+		wake_up( &falcon_fairness_wait );
+	}
+
+	local_irq_restore(flags);
+}
+
+/* This function manages the locking of the ST-DMA.
+ * If the DMA isn't locked already for SCSI, it tries to lock it by
+ * calling stdma_lock(). But if the DMA is locked by the SCSI code and
+ * there are other drivers waiting for the chip, we do not issue the
+ * command immediately but wait on 'falcon_fairness_queue'. We will be
+ * waked up when the DMA is unlocked by some SCSI interrupt. After that
+ * we try to get the lock again.
+ * But we must be prepared that more than one instance of
+ * falcon_get_lock() is waiting on the fairness queue. They should not
+ * try all at once to call stdma_lock(), one is enough! For that, the
+ * first one sets 'falcon_trying_lock', others that see that variable
+ * set wait on the queue 'falcon_try_wait'.
+ * Complicated, complicated.... Sigh...
+ */
+
+static void falcon_get_lock( void )
+{
+	unsigned long flags;
+
+	if (IS_A_TT()) return;
+
+	local_irq_save(flags);
+
+	while( !in_interrupt() && falcon_got_lock && stdma_others_waiting() )
+		sleep_on( &falcon_fairness_wait );
+
+	while (!falcon_got_lock) {
+		if (in_interrupt())
+			panic( "Falcon SCSI hasn't ST-DMA lock in interrupt" );
+		if (!falcon_trying_lock) {
+			falcon_trying_lock = 1;
+			stdma_lock(scsi_falcon_intr, NULL);
+			falcon_got_lock = 1;
+			falcon_trying_lock = 0;
+			wake_up( &falcon_try_wait );
+		}
+		else {
+			sleep_on( &falcon_try_wait );
+		}
+	}	
+
+	local_irq_restore(flags);
+	if (!falcon_got_lock)
+		panic("Falcon SCSI: someone stole the lock :-(\n");
+}
+
+
+/* This is the wrapper function for NCR5380_queue_command(). It just
+ * tries to get the lock on the ST-DMA (see above) and then calls the
+ * original function.
+ */
+
+#if 0
+int atari_queue_command (Scsi_Cmnd *cmd, void (*done)(Scsi_Cmnd *))
+{
+	/* falcon_get_lock();
+	 * ++guenther: moved to NCR5380_queue_command() to prevent
+	 * race condition, see there for an explanation.
+	 */
+	return( NCR5380_queue_command( cmd, done ) );
+}
+#endif
+
+
+int atari_scsi_detect (Scsi_Host_Template *host)
+{
+	static int called = 0;
+	struct Scsi_Host *instance;
+
+	if (!MACH_IS_ATARI ||
+	    (!ATARIHW_PRESENT(ST_SCSI) && !ATARIHW_PRESENT(TT_SCSI)) ||
+	    called)
+		return( 0 );
+
+	host->proc_name = "Atari";
+
+	atari_scsi_reg_read  = IS_A_TT() ? atari_scsi_tt_reg_read :
+					   atari_scsi_falcon_reg_read;
+	atari_scsi_reg_write = IS_A_TT() ? atari_scsi_tt_reg_write :
+					   atari_scsi_falcon_reg_write;
+
+	/* setup variables */
+	host->can_queue =
+		(setup_can_queue > 0) ? setup_can_queue :
+		IS_A_TT() ? ATARI_TT_CAN_QUEUE : ATARI_FALCON_CAN_QUEUE;
+	host->cmd_per_lun =
+		(setup_cmd_per_lun > 0) ? setup_cmd_per_lun :
+		IS_A_TT() ? ATARI_TT_CMD_PER_LUN : ATARI_FALCON_CMD_PER_LUN;
+	/* Force sg_tablesize to 0 on a Falcon! */
+	host->sg_tablesize =
+		!IS_A_TT() ? ATARI_FALCON_SG_TABLESIZE :
+		(setup_sg_tablesize >= 0) ? setup_sg_tablesize : ATARI_TT_SG_TABLESIZE;
+
+	if (setup_hostid >= 0)
+		host->this_id = setup_hostid;
+	else {
+		/* use 7 as default */
+		host->this_id = 7;
+		/* Test if a host id is set in the NVRam */
+		if (ATARIHW_PRESENT(TT_CLK) && nvram_check_checksum()) {
+			unsigned char b = nvram_read_byte( 14 );
+			/* Arbitration enabled? (for TOS) If yes, use configured host ID */
+			if (b & 0x80)
+				host->this_id = b & 7;
+		}
+	}
+
+#ifdef SUPPORT_TAGS
+	if (setup_use_tagged_queuing < 0)
+		setup_use_tagged_queuing = DEFAULT_USE_TAGGED_QUEUING;
+#endif
+#ifdef REAL_DMA
+	/* If running on a Falcon and if there's TT-Ram (i.e., more than one
+	 * memory block, since there's always ST-Ram in a Falcon), then allocate a
+	 * STRAM_BUFFER_SIZE byte dribble buffer for transfers from/to alternative
+	 * Ram.
+	 */
+	if (MACH_IS_ATARI && ATARIHW_PRESENT(ST_SCSI) &&
+	    !ATARIHW_PRESENT(EXTD_DMA) && m68k_num_memory > 1) {
+		atari_dma_buffer = atari_stram_alloc(STRAM_BUFFER_SIZE, "SCSI");
+		if (!atari_dma_buffer) {
+			printk( KERN_ERR "atari_scsi_detect: can't allocate ST-RAM "
+					"double buffer\n" );
+			return( 0 );
+		}
+		atari_dma_phys_buffer = virt_to_phys( atari_dma_buffer );
+		atari_dma_orig_addr = 0;
+	}
+#endif
+	instance = scsi_register (host, sizeof (struct NCR5380_hostdata));
+	if(instance == NULL)
+	{
+		atari_stram_free(atari_dma_buffer);
+		atari_dma_buffer = 0;
+		return 0;
+	}
+	atari_scsi_host = instance;
+       /* Set irq to 0, to avoid that the mid-level code disables our interrupt
+        * during queue_command calls. This is completely unnecessary, and even
+        * worse causes bad problems on the Falcon, where the int is shared with
+        * IDE and floppy! */
+       instance->irq = 0;
+
+#ifdef CONFIG_ATARI_SCSI_RESET_BOOT
+	atari_scsi_reset_boot();
+#endif
+	NCR5380_init (instance, 0);
+
+	if (IS_A_TT()) {
+
+		/* This int is actually "pseudo-slow", i.e. it acts like a slow
+		 * interrupt after having cleared the pending flag for the DMA
+		 * interrupt. */
+		if (request_irq(IRQ_TT_MFP_SCSI, scsi_tt_intr, IRQ_TYPE_SLOW,
+				 "SCSI NCR5380", scsi_tt_intr)) {
+			printk(KERN_ERR "atari_scsi_detect: cannot allocate irq %d, aborting",IRQ_TT_MFP_SCSI);
+			scsi_unregister(atari_scsi_host);
+			atari_stram_free(atari_dma_buffer);
+			atari_dma_buffer = 0;
+			return 0;
+		}
+		tt_mfp.active_edge |= 0x80;		/* SCSI int on L->H */
+#ifdef REAL_DMA
+		tt_scsi_dma.dma_ctrl = 0;
+		atari_dma_residual = 0;
+#ifdef CONFIG_TT_DMA_EMUL
+		if (MACH_IS_HADES) {
+			if (request_irq(IRQ_AUTO_2, hades_dma_emulator,
+					 IRQ_TYPE_PRIO, "Hades DMA emulator",
+					 hades_dma_emulator)) {
+				printk(KERN_ERR "atari_scsi_detect: cannot allocate irq %d, aborting (MACH_IS_HADES)",IRQ_AUTO_2);
+				free_irq(IRQ_TT_MFP_SCSI, scsi_tt_intr);
+				scsi_unregister(atari_scsi_host);
+				atari_stram_free(atari_dma_buffer);
+				atari_dma_buffer = 0;
+				return 0;
+			}
+		}
+#endif
+		if (MACH_IS_MEDUSA || MACH_IS_HADES) {
+			/* While the read overruns (described by Drew Eckhardt in
+			 * NCR5380.c) never happened on TTs, they do in fact on the Medusa
+			 * (This was the cause why SCSI didn't work right for so long
+			 * there.) Since handling the overruns slows down a bit, I turned
+			 * the #ifdef's into a runtime condition.
+			 *
+			 * In principle it should be sufficient to do max. 1 byte with
+			 * PIO, but there is another problem on the Medusa with the DMA
+			 * rest data register. So 'atari_read_overruns' is currently set
+			 * to 4 to avoid having transfers that aren't a multiple of 4. If
+			 * the rest data bug is fixed, this can be lowered to 1.
+			 */
+			atari_read_overruns = 4;
+		}		
+#endif /*REAL_DMA*/
+	}
+	else { /* ! IS_A_TT */
+		
+		/* Nothing to do for the interrupt: the ST-DMA is initialized
+		 * already by atari_init_INTS()
+		 */
+
+#ifdef REAL_DMA
+		atari_dma_residual = 0;
+		atari_dma_active = 0;
+		atari_dma_stram_mask = (ATARIHW_PRESENT(EXTD_DMA) ? 0x00000000
+					: 0xff000000);
+#endif
+	}
+
+	printk(KERN_INFO "scsi%d: options CAN_QUEUE=%d CMD_PER_LUN=%d SCAT-GAT=%d "
+#ifdef SUPPORT_TAGS
+			"TAGGED-QUEUING=%s "
+#endif
+			"HOSTID=%d",
+			instance->host_no, instance->hostt->can_queue,
+			instance->hostt->cmd_per_lun,
+			instance->hostt->sg_tablesize,
+#ifdef SUPPORT_TAGS
+			setup_use_tagged_queuing ? "yes" : "no",
+#endif
+			instance->hostt->this_id );
+	NCR5380_print_options (instance);
+	printk ("\n");
+
+	called = 1;
+	return( 1 );
+}
+
+#ifdef MODULE
+int atari_scsi_release (struct Scsi_Host *sh)
+{
+	if (IS_A_TT())
+		free_irq(IRQ_TT_MFP_SCSI, scsi_tt_intr);
+	if (atari_dma_buffer)
+		atari_stram_free (atari_dma_buffer);
+	return 1;
+}
+#endif
+
+void __init atari_scsi_setup(char *str, int *ints)
+{
+	/* Format of atascsi parameter is:
+	 *   atascsi=<can_queue>,<cmd_per_lun>,<sg_tablesize>,<hostid>,<use_tags>
+	 * Defaults depend on TT or Falcon, hostid determined at run time.
+	 * Negative values mean don't change.
+	 */
+	
+	if (ints[0] < 1) {
+		printk( "atari_scsi_setup: no arguments!\n" );
+		return;
+	}
+
+	if (ints[0] >= 1) {
+		if (ints[1] > 0)
+			/* no limits on this, just > 0 */
+			setup_can_queue = ints[1];
+	}
+	if (ints[0] >= 2) {
+		if (ints[2] > 0)
+			setup_cmd_per_lun = ints[2];
+	}
+	if (ints[0] >= 3) {
+		if (ints[3] >= 0) {
+			setup_sg_tablesize = ints[3];
+			/* Must be <= SG_ALL (255) */
+			if (setup_sg_tablesize > SG_ALL)
+				setup_sg_tablesize = SG_ALL;
+		}
+	}
+	if (ints[0] >= 4) {
+		/* Must be between 0 and 7 */
+		if (ints[4] >= 0 && ints[4] <= 7)
+			setup_hostid = ints[4];
+		else if (ints[4] > 7)
+			printk( "atari_scsi_setup: invalid host ID %d !\n", ints[4] );
+	}
+#ifdef SUPPORT_TAGS
+	if (ints[0] >= 5) {
+		if (ints[5] >= 0)
+			setup_use_tagged_queuing = !!ints[5];
+	}
+#endif
+}
+
+int atari_scsi_bus_reset(Scsi_Cmnd *cmd)
+{
+	int		rv;
+	struct NCR5380_hostdata *hostdata =
+		(struct NCR5380_hostdata *)cmd->device->host->hostdata;
+
+	/* For doing the reset, SCSI interrupts must be disabled first,
+	 * since the 5380 raises its IRQ line while _RST is active and we
+	 * can't disable interrupts completely, since we need the timer.
+	 */
+	/* And abort a maybe active DMA transfer */
+	if (IS_A_TT()) {
+		atari_turnoff_irq( IRQ_TT_MFP_SCSI );
+#ifdef REAL_DMA
+		tt_scsi_dma.dma_ctrl = 0;
+#endif /* REAL_DMA */
+	}
+	else {
+		atari_turnoff_irq( IRQ_MFP_FSCSI );
+#ifdef REAL_DMA
+		st_dma.dma_mode_status = 0x90;
+		atari_dma_active = 0;
+		atari_dma_orig_addr = NULL;
+#endif /* REAL_DMA */
+	}
+
+	rv = NCR5380_bus_reset(cmd);
+
+	/* Re-enable ints */
+	if (IS_A_TT()) {
+		atari_turnon_irq( IRQ_TT_MFP_SCSI );
+	}
+	else {
+		atari_turnon_irq( IRQ_MFP_FSCSI );
+	}
+	if ((rv & SCSI_RESET_ACTION) == SCSI_RESET_SUCCESS)
+		falcon_release_lock_if_possible(hostdata);
+
+	return( rv );
+}
+
+	
+#ifdef CONFIG_ATARI_SCSI_RESET_BOOT
+static void __init atari_scsi_reset_boot(void)
+{
+	unsigned long end;
+	
+	/*
+	 * Do a SCSI reset to clean up the bus during initialization. No messing
+	 * with the queues, interrupts, or locks necessary here.
+	 */
+
+	printk( "Atari SCSI: resetting the SCSI bus..." );
+
+	/* get in phase */
+	NCR5380_write( TARGET_COMMAND_REG,
+		      PHASE_SR_TO_TCR( NCR5380_read(STATUS_REG) ));
+
+	/* assert RST */
+	NCR5380_write( INITIATOR_COMMAND_REG, ICR_BASE | ICR_ASSERT_RST );
+	/* The min. reset hold time is 25us, so 40us should be enough */
+	udelay( 50 );
+	/* reset RST and interrupt */
+	NCR5380_write( INITIATOR_COMMAND_REG, ICR_BASE );
+	NCR5380_read( RESET_PARITY_INTERRUPT_REG );
+
+	end = jiffies + AFTER_RESET_DELAY;
+	while (time_before(jiffies, end))
+		barrier();
+
+	printk( " done\n" );
+}
+#endif
+
+
+const char * atari_scsi_info (struct Scsi_Host *host)
+{
+	/* atari_scsi_detect() is verbose enough... */
+	static const char string[] = "Atari native SCSI";
+	return string;
+}
+
+
+#if defined(REAL_DMA)
+
+unsigned long atari_scsi_dma_setup( struct Scsi_Host *instance, void *data,
+				   unsigned long count, int dir )
+{
+	unsigned long addr = virt_to_phys( data );
+
+	DMA_PRINTK("scsi%d: setting up dma, data = %p, phys = %lx, count = %ld, "
+		   "dir = %d\n", instance->host_no, data, addr, count, dir);
+
+	if (!IS_A_TT() && !STRAM_ADDR(addr)) {
+		/* If we have a non-DMAable address on a Falcon, use the dribble
+		 * buffer; 'orig_addr' != 0 in the read case tells the interrupt
+		 * handler to copy data from the dribble buffer to the originally
+		 * wanted address.
+		 */
+		if (dir)
+			memcpy( atari_dma_buffer, data, count );
+		else
+			atari_dma_orig_addr = data;
+		addr = atari_dma_phys_buffer;
+	}
+	
+	atari_dma_startaddr = addr;	/* Needed for calculating residual later. */
+  
+	/* Cache cleanup stuff: On writes, push any dirty cache out before sending
+	 * it to the peripheral. (Must be done before DMA setup, since at least
+	 * the ST-DMA begins to fill internal buffers right after setup. For
+	 * reads, invalidate any cache, may be altered after DMA without CPU
+	 * knowledge.
+	 * 
+	 * ++roman: For the Medusa, there's no need at all for that cache stuff,
+	 * because the hardware does bus snooping (fine!).
+	 */
+	dma_cache_maintenance( addr, count, dir );
+
+	if (count == 0)
+		printk(KERN_NOTICE "SCSI warning: DMA programmed for 0 bytes !\n");
+
+	if (IS_A_TT()) {
+		tt_scsi_dma.dma_ctrl = dir;
+		SCSI_DMA_WRITE_P( dma_addr, addr );
+		SCSI_DMA_WRITE_P( dma_cnt, count );
+		tt_scsi_dma.dma_ctrl = dir | 2;
+	}
+	else { /* ! IS_A_TT */
+  
+		/* set address */
+		SCSI_DMA_SETADR( addr );
+
+		/* toggle direction bit to clear FIFO and set DMA direction */
+		dir <<= 8;
+		st_dma.dma_mode_status = 0x90 | dir;
+		st_dma.dma_mode_status = 0x90 | (dir ^ 0x100);
+		st_dma.dma_mode_status = 0x90 | dir;
+		udelay(40);
+		/* On writes, round up the transfer length to the next multiple of 512
+		 * (see also comment at atari_dma_xfer_len()). */
+		st_dma.fdc_acces_seccount = (count + (dir ? 511 : 0)) >> 9;
+		udelay(40);
+		st_dma.dma_mode_status = 0x10 | dir;
+		udelay(40);
+		/* need not restore value of dir, only boolean value is tested */
+		atari_dma_active = 1;
+	}
+
+	return( count );
+}
+
+
+static long atari_scsi_dma_residual( struct Scsi_Host *instance )
+{
+	return( atari_dma_residual );
+}
+
+
+#define	CMD_SURELY_BLOCK_MODE	0
+#define	CMD_SURELY_BYTE_MODE	1
+#define	CMD_MODE_UNKNOWN		2
+
+static int falcon_classify_cmd( Scsi_Cmnd *cmd )
+{
+	unsigned char opcode = cmd->cmnd[0];
+	
+	if (opcode == READ_DEFECT_DATA || opcode == READ_LONG ||
+		opcode == READ_BUFFER)
+		return( CMD_SURELY_BYTE_MODE );
+	else if (opcode == READ_6 || opcode == READ_10 ||
+		 opcode == 0xa8 /* READ_12 */ || opcode == READ_REVERSE ||
+		 opcode == RECOVER_BUFFERED_DATA) {
+		/* In case of a sequential-access target (tape), special care is
+		 * needed here: The transfer is block-mode only if the 'fixed' bit is
+		 * set! */
+		if (cmd->device->type == TYPE_TAPE && !(cmd->cmnd[1] & 1))
+			return( CMD_SURELY_BYTE_MODE );
+		else
+			return( CMD_SURELY_BLOCK_MODE );
+	}
+	else
+		return( CMD_MODE_UNKNOWN );
+}
+
+
+/* This function calculates the number of bytes that can be transferred via
+ * DMA. On the TT, this is arbitrary, but on the Falcon we have to use the
+ * ST-DMA chip. There are only multiples of 512 bytes possible and max.
+ * 255*512 bytes :-( This means also, that defining READ_OVERRUNS is not
+ * possible on the Falcon, since that would require to program the DMA for
+ * n*512 - atari_read_overrun bytes. But it seems that the Falcon doesn't have
+ * the overrun problem, so this question is academic :-)
+ */
+
+static unsigned long atari_dma_xfer_len( unsigned long wanted_len,
+					Scsi_Cmnd *cmd,
+					int write_flag )
+{
+	unsigned long	possible_len, limit;
+#ifndef CONFIG_TT_DMA_EMUL
+	if (MACH_IS_HADES)
+		/* Hades has no SCSI DMA at all :-( Always force use of PIO */
+		return( 0 );
+#endif	
+	if (IS_A_TT())
+		/* TT SCSI DMA can transfer arbitrary #bytes */
+		return( wanted_len );
+
+	/* ST DMA chip is stupid -- only multiples of 512 bytes! (and max.
+	 * 255*512 bytes, but this should be enough)
+	 *
+	 * ++roman: Aaargl! Another Falcon-SCSI problem... There are some commands
+	 * that return a number of bytes which cannot be known beforehand. In this
+	 * case, the given transfer length is an "allocation length". Now it
+	 * can happen that this allocation length is a multiple of 512 bytes and
+	 * the DMA is used. But if not n*512 bytes really arrive, some input data
+	 * will be lost in the ST-DMA's FIFO :-( Thus, we have to distinguish
+	 * between commands that do block transfers and those that do byte
+	 * transfers. But this isn't easy... there are lots of vendor specific
+	 * commands, and the user can issue any command via the
+	 * SCSI_IOCTL_SEND_COMMAND.
+	 *
+	 * The solution: We classify SCSI commands in 1) surely block-mode cmd.s,
+	 * 2) surely byte-mode cmd.s and 3) cmd.s with unknown mode. In case 1)
+	 * and 3), the thing to do is obvious: allow any number of blocks via DMA
+	 * or none. In case 2), we apply some heuristic: Byte mode is assumed if
+	 * the transfer (allocation) length is < 1024, hoping that no cmd. not
+	 * explicitly known as byte mode have such big allocation lengths...
+	 * BTW, all the discussion above applies only to reads. DMA writes are
+	 * unproblematic anyways, since the targets aborts the transfer after
+	 * receiving a sufficient number of bytes.
+	 *
+	 * Another point: If the transfer is from/to an non-ST-RAM address, we
+	 * use the dribble buffer and thus can do only STRAM_BUFFER_SIZE bytes.
+	 */
+
+	if (write_flag) {
+		/* Write operation can always use the DMA, but the transfer size must
+		 * be rounded up to the next multiple of 512 (atari_dma_setup() does
+		 * this).
+		 */
+		possible_len = wanted_len;
+	}
+	else {
+		/* Read operations: if the wanted transfer length is not a multiple of
+		 * 512, we cannot use DMA, since the ST-DMA cannot split transfers
+		 * (no interrupt on DMA finished!)
+		 */
+		if (wanted_len & 0x1ff)
+			possible_len = 0;
+		else {
+			/* Now classify the command (see above) and decide whether it is
+			 * allowed to do DMA at all */
+			switch( falcon_classify_cmd( cmd )) {
+			  case CMD_SURELY_BLOCK_MODE:
+				possible_len = wanted_len;
+				break;
+			  case CMD_SURELY_BYTE_MODE:
+				possible_len = 0; /* DMA prohibited */
+				break;
+			  case CMD_MODE_UNKNOWN:
+			  default:
+				/* For unknown commands assume block transfers if the transfer
+				 * size/allocation length is >= 1024 */
+				possible_len = (wanted_len < 1024) ? 0 : wanted_len;
+				break;
+			}
+		}
+	}
+	
+	/* Last step: apply the hard limit on DMA transfers */
+	limit = (atari_dma_buffer && !STRAM_ADDR( virt_to_phys(cmd->SCp.ptr) )) ?
+		    STRAM_BUFFER_SIZE : 255*512;
+	if (possible_len > limit)
+		possible_len = limit;
+
+	if (possible_len != wanted_len)
+		DMA_PRINTK("Sorry, must cut DMA transfer size to %ld bytes "
+			   "instead of %ld\n", possible_len, wanted_len);
+
+	return( possible_len );
+}
+
+
+#endif	/* REAL_DMA */
+
+
+/* NCR5380 register access functions
+ *
+ * There are separate functions for TT and Falcon, because the access
+ * methods are quite different. The calling macros NCR5380_read and
+ * NCR5380_write call these functions via function pointers.
+ */
+
+static unsigned char atari_scsi_tt_reg_read( unsigned char reg )
+{
+	return( tt_scsi_regp[reg * 2] );
+}
+
+static void atari_scsi_tt_reg_write( unsigned char reg, unsigned char value )
+{
+	tt_scsi_regp[reg * 2] = value;
+}
+
+static unsigned char atari_scsi_falcon_reg_read( unsigned char reg )
+{
+	dma_wd.dma_mode_status= (u_short)(0x88 + reg);
+	return( (u_char)dma_wd.fdc_acces_seccount );
+}
+
+static void atari_scsi_falcon_reg_write( unsigned char reg, unsigned char value )
+{
+	dma_wd.dma_mode_status = (u_short)(0x88 + reg);
+	dma_wd.fdc_acces_seccount = (u_short)value;
+}
+
+
+#include "atari_NCR5380.c"
+
+static Scsi_Host_Template driver_template = {
+	.proc_info		= atari_scsi_proc_info,
+	.name			= "Atari native SCSI",
+	.detect			= atari_scsi_detect,
+	.release		= atari_scsi_release,
+	.info			= atari_scsi_info,
+	.queuecommand		= atari_scsi_queue_command,
+	.eh_abort_handler	= atari_scsi_abort,
+	.eh_bus_reset_handler	= atari_scsi_bus_reset,
+	.can_queue		= 0, /* initialized at run-time */
+	.this_id		= 0, /* initialized at run-time */
+	.sg_tablesize		= 0, /* initialized at run-time */
+	.cmd_per_lun		= 0, /* initialized at run-time */
+	.use_clustering		= DISABLE_CLUSTERING
+};
+
+
+#include "scsi_module.c"
+
+MODULE_LICENSE("GPL");
