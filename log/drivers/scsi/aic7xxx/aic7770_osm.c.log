commit 144ec97493af34efdb77c5aba146e9c7de8d0a06
Author: Christoph Hellwig <hch@lst.de>
Date:   Thu Apr 18 18:13:58 2019 +0200

    scsi: aic7xxx: fix EISA support
    
    Instead of relying on the now removed NULL argument to
    pci_alloc_consistent, switch to the generic DMA API, and store the struct
    device so that we can pass it.
    
    Fixes: 4167b2ad5182 ("PCI: Remove NULL device handling from PCI DMA API")
    Reported-by: Matthew Whitehead <tedheadster@gmail.com>
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Tested-by: Matthew Whitehead <tedheadster@gmail.com>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/aic7xxx/aic7770_osm.c b/drivers/scsi/aic7xxx/aic7770_osm.c
index 3d401d02c019..bdd177e3d762 100644
--- a/drivers/scsi/aic7xxx/aic7770_osm.c
+++ b/drivers/scsi/aic7xxx/aic7770_osm.c
@@ -91,6 +91,7 @@ aic7770_probe(struct device *dev)
 	ahc = ahc_alloc(&aic7xxx_driver_template, name);
 	if (ahc == NULL)
 		return (ENOMEM);
+	ahc->dev = dev;
 	error = aic7770_config(ahc, aic7770_ident_table + edev->id.driver_data,
 			       eisaBase);
 	if (error != 0) {

commit 1f3d2d9edc832bdd5507130446abf1c8d2923ac5
Author: Himangi Saraogi <himangi774@gmail.com>
Date:   Tue Jun 10 19:48:47 2014 +0530

    aic7xxx: Use kstrdup
    
    Use kstrdup when the goal of an allocation is copy a string into the
    allocated region.
    
    The Coccinelle semantic patch that makes this change is as follows:
    
    // <smpl>
    @@
    expression from,to;
    expression flag,E1,E2;
    statement S;
    @@
    
    -  to = kmalloc(strlen(from) + 1,flag);
    +  to = kstrdup(from, flag);
       ... when != \(from = E1 \| to = E1 \)
       if (to==NULL || ...) S
       ... when != \(from = E2 \| to = E2 \)
    -  strcpy(to, from);
    // </smpl>
    
    Signed-off-by: Himangi Saraogi <himangi774@gmail.com>
    Acked-by: Julia Lawall <julia.lawall@lip6.fr>
    Signed-off-by: Christoph Hellwig <hch@lst.de>

diff --git a/drivers/scsi/aic7xxx/aic7770_osm.c b/drivers/scsi/aic7xxx/aic7770_osm.c
index 0cb8ef64b5ce..3d401d02c019 100644
--- a/drivers/scsi/aic7xxx/aic7770_osm.c
+++ b/drivers/scsi/aic7xxx/aic7770_osm.c
@@ -85,10 +85,9 @@ aic7770_probe(struct device *dev)
 	int	error;
 
 	sprintf(buf, "ahc_eisa:%d", eisaBase >> 12);
-	name = kmalloc(strlen(buf) + 1, GFP_ATOMIC);
+	name = kstrdup(buf, GFP_ATOMIC);
 	if (name == NULL)
 		return (ENOMEM);
-	strcpy(name, buf);
 	ahc = ahc_alloc(&aic7xxx_driver_template, name);
 	if (ahc == NULL)
 		return (ENOMEM);

commit 48813cf989eb8695fe84df30207fc8ff5f15783c
Author: Pekka Enberg <penberg@cs.helsinki.fi>
Date:   Wed Jul 14 13:12:57 2010 +0300

    [SCSI] aic7xxx: Remove OS utility wrappers
    
    This patch removes malloc(), free(), and printf() wrappers from the aic7xxx
    SCSI driver. I didn't use pr_debug for printf because of some 'clever' uses of
    printf don't compile with the pr_debug. I didn't fix the overeager uses of
    GFP_ATOMIC either because I wanted to keep this patch as simple as possible.
    
    [jejb:fixed up checkpatch errors and fixed up missed conversion]
    Signed-off-by: Pekka Enberg <penberg@cs.helsinki.fi>
    Acked-by: Hannes Reinecke <hare@suse.de>
    Signed-off-by: James Bottomley <James.Bottomley@suse.de>

diff --git a/drivers/scsi/aic7xxx/aic7770_osm.c b/drivers/scsi/aic7xxx/aic7770_osm.c
index f220e5e436ab..0cb8ef64b5ce 100644
--- a/drivers/scsi/aic7xxx/aic7770_osm.c
+++ b/drivers/scsi/aic7xxx/aic7770_osm.c
@@ -85,7 +85,7 @@ aic7770_probe(struct device *dev)
 	int	error;
 
 	sprintf(buf, "ahc_eisa:%d", eisaBase >> 12);
-	name = malloc(strlen(buf) + 1, M_DEVBUF, M_NOWAIT);
+	name = kmalloc(strlen(buf) + 1, GFP_ATOMIC);
 	if (name == NULL)
 		return (ENOMEM);
 	strcpy(name, buf);

commit 172c122df5186e7cbd413d61757ff90267331002
Author: Harvey Harrison <harvey.harrison@gmail.com>
Date:   Mon Apr 28 16:50:03 2008 -0700

    scsi: fix integer as NULL pointer warnings
    
    drivers/scsi/aic7xxx/aic7770_osm.c:53:58: warning: Using plain integer as NULL pointer
    drivers/scsi/aic7xxx/aic7xxx_osm_pci.c:355:47: warning: Using plain integer as NULL pointer
    drivers/scsi/aic7xxx/aic7xxx_osm_pci.c:372:55: warning: Using plain integer as NULL pointer
    drivers/scsi/aha152x.c:997:28: warning: Using plain integer as NULL pointer
    drivers/scsi/aha152x.c:1003:28: warning: Using plain integer as NULL pointer
    drivers/scsi/aha152x.c:1165:46: warning: Using plain integer as NULL pointer
    drivers/scsi/fdomain.c:1446:40: warning: Using plain integer as NULL pointer
    drivers/scsi/sym53c8xx_2/sym_hipd.c:1650:51: warning: Using plain integer as NULL pointer
    drivers/scsi/sym53c8xx_2/sym_hipd.c:3171:42: warning: Using plain integer as NULL pointer
    drivers/scsi/sym53c8xx_2/sym_hipd.c:5732:52: warning: Using plain integer as NULL pointer
    drivers/scsi/ncr53c8xx.c:8189:31: warning: Using plain integer as NULL pointer
    drivers/scsi/ncr53c8xx.c:8225:34: warning: Using plain integer as NULL pointer
    drivers/scsi/dpt_i2o.c:156:32: warning: Using plain integer as NULL pointer
    drivers/scsi/ultrastor.c:954:42: warning: Using plain integer as NULL pointer
    drivers/scsi/ultrastor.c:1104:18: warning: Using plain integer as NULL pointer
    
    Signed-off-by: Harvey Harrison <harvey.harrison@gmail.com>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/scsi/aic7xxx/aic7770_osm.c b/drivers/scsi/aic7xxx/aic7770_osm.c
index 1ac119733bac..f220e5e436ab 100644
--- a/drivers/scsi/aic7xxx/aic7770_osm.c
+++ b/drivers/scsi/aic7xxx/aic7770_osm.c
@@ -50,7 +50,7 @@ aic7770_map_registers(struct ahc_softc *ahc, u_int port)
 	/*
 	 * Lock out other contenders for our i/o space.
 	 */
-	if (request_region(port, AHC_EISA_IOSIZE, "aic7xxx") == 0)
+	if (!request_region(port, AHC_EISA_IOSIZE, "aic7xxx"))
 		return (ENOMEM);
 	ahc->tag = BUS_SPACE_PIO;
 	ahc->bsh.ioport = port;

commit 07563c711fbc25389e58ab9c9f0b9de2fce56760
Author: Michael Tokarev <mjt@tls.mks.ru>
Date:   Wed Sep 27 01:50:56 2006 -0700

    [PATCH] EISA bus MODALIAS attributes support
    
    Add modalias attribute support for the almost forgotten now EISA bus and
    (at least some) EISA-aware modules.
    
    The modalias entry looks like (for an 3c509 NIC):
    
     eisa:sTCM5093
    
    and the in-module alias like:
    
     eisa:sTCM5093*
    
    The patch moves struct eisa_device_id declaration from include/linux/eisa.h
    to include/linux/mod_devicetable.h (so that the former now #includes the
    latter), adds proper MODULE_DEVICE_TABLE(eisa, ...) statements for all
    drivers with EISA IDs I found (some drivers already have that DEVICE_TABLE
    declared), and adds recognision of __mod_eisa_device_table to
    scripts/mod/file2alias.c so that proper modules.alias will be generated.
    
    There's no support for /lib/modules/$kver/modules.eisamap, as it's not used
    by any existing tools, and because with in-kernel modalias mechanism those
    maps are obsolete anyway.
    
    The rationale for this patch is:
    
     a) to make EISA bus to act as other busses with modalias
        support, to unify driver loading
    
     b) to foget about EISA finally - with this patch, kernel
        (who still supports EISA) will be the only one who knows
        how to choose the necessary drivers for this bus ;)
    
    [akpm@osdl.org: fix the kbuild bit]
    Signed-off-by: Michael Tokarev <mjt@tls.msk.ru>
    Cc: Rusty Russell <rusty@rustcorp.com.au>
    Cc: Randy Dunlap <rdunlap@xenotime.net>
    Acked-the-net-bits-by: Jeff Garzik <jeff@garzik.org>
    Acked-the-tulip-bit-by: Valerie Henson <val_henson@linux.intel.com>
    Cc: James Bottomley <James.Bottomley@steeleye.com>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/drivers/scsi/aic7xxx/aic7770_osm.c b/drivers/scsi/aic7xxx/aic7770_osm.c
index 867cbe23579b..1ac119733bac 100644
--- a/drivers/scsi/aic7xxx/aic7770_osm.c
+++ b/drivers/scsi/aic7xxx/aic7770_osm.c
@@ -132,7 +132,8 @@ static struct eisa_device_id aic7770_ids[] = {
 	{ "ADP7770", 5 }, /* AIC7770 generic */
 	{ "" }
 };
-  
+MODULE_DEVICE_TABLE(eisa, aic7770_ids);
+
 static struct eisa_driver aic7770_driver = {
 	.id_table	= aic7770_ids,
 	.driver = {

commit 1d6f359a2e06296418481239f8054a878f36e819
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Sat Jul 1 19:29:42 2006 -0700

    [PATCH] irq-flags: scsi: Use the new IRQF_ constants
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: Ingo Molnar <mingo@elte.hu>
    Cc: "David S. Miller" <davem@davemloft.net>
    Cc: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Cc: James Bottomley <James.Bottomley@steeleye.com>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/drivers/scsi/aic7xxx/aic7770_osm.c b/drivers/scsi/aic7xxx/aic7770_osm.c
index d754b3267863..867cbe23579b 100644
--- a/drivers/scsi/aic7xxx/aic7770_osm.c
+++ b/drivers/scsi/aic7xxx/aic7770_osm.c
@@ -65,7 +65,7 @@ aic7770_map_int(struct ahc_softc *ahc, u_int irq)
 
 	shared = 0;
 	if ((ahc->flags & AHC_EDGE_INTERRUPT) == 0)
-		shared = SA_SHIRQ;
+		shared = IRQF_SHARED;
 
 	error = request_irq(irq, ahc_linux_isr, shared, "aic7xxx", ahc);
 	if (error == 0)

commit 97af50f60ff1202b0dd9ce481d4cf98c6a578bec
Author: James Bottomley <James.Bottomley@steeleye.com>
Date:   Sun Oct 2 15:22:35 2005 -0500

    [SCSI] aic7xxx/aic79xx: fix module removal path not to panic
    
    In these drivers, scsi_remove_host() is called too late, at the point
    it is called, the driver has already shut down too far to accept any
    I/O that the shutdown might generate.  Any generated I/O actually
    triggers a panic.
    
    Fix this by calling scsi_remove_host() as early as possible and not
    calling scsi_host_put() until just before we kfree the ahc_softc.
    
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>

diff --git a/drivers/scsi/aic7xxx/aic7770_osm.c b/drivers/scsi/aic7xxx/aic7770_osm.c
index 70c5fb59c9ea..d754b3267863 100644
--- a/drivers/scsi/aic7xxx/aic7770_osm.c
+++ b/drivers/scsi/aic7xxx/aic7770_osm.c
@@ -112,6 +112,9 @@ aic7770_remove(struct device *dev)
 	struct ahc_softc *ahc = dev_get_drvdata(dev);
 	u_long s;
 
+	if (ahc->platform_data && ahc->platform_data->host)
+			scsi_remove_host(ahc->platform_data->host);
+
 	ahc_lock(ahc, &s);
 	ahc_intr_enable(ahc, FALSE);
 	ahc_unlock(ahc, &s);

commit dfd287f6ee9be1e3ae8fe1160c185aac6ca83c6a
Author: Christoph Hellwig <hch@lst.de>
Date:   Tue Jun 28 16:49:44 2005 +0200

    [SCSI] aic7xxx: sane pci probing
    
    always probe in bus order, avoid any reordering
    
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>

diff --git a/drivers/scsi/aic7xxx/aic7770_osm.c b/drivers/scsi/aic7xxx/aic7770_osm.c
index d4ed5e9f830a..70c5fb59c9ea 100644
--- a/drivers/scsi/aic7xxx/aic7770_osm.c
+++ b/drivers/scsi/aic7xxx/aic7770_osm.c
@@ -102,8 +102,7 @@ aic7770_probe(struct device *dev)
 
  	dev_set_drvdata(dev, ahc);
 
-	if (aic7xxx_detect_complete)
-		error = ahc_linux_register_host(ahc, &aic7xxx_driver_template);
+	error = ahc_linux_register_host(ahc, &aic7xxx_driver_template);
 	return (error);
 }
 

commit d6cbbad7296538b6a38c0fe36e6ecf67f1e600a7
Author: Christoph Hellwig <hch@lst.de>
Date:   Sat Jun 11 00:17:03 2005 +0200

    [SCSI] aic7xxx: clean up eisa support
    
     - the eisa layer only probes when it's actually safe, no need for
       a driver option
     - store the id table directly in linux format instead of convering
       at runtime
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>

diff --git a/drivers/scsi/aic7xxx/aic7770_osm.c b/drivers/scsi/aic7xxx/aic7770_osm.c
index d0e9b54ab008..d4ed5e9f830a 100644
--- a/drivers/scsi/aic7xxx/aic7770_osm.c
+++ b/drivers/scsi/aic7xxx/aic7770_osm.c
@@ -44,109 +44,6 @@
 #include <linux/device.h>
 #include <linux/eisa.h>
 
-#define EISA_MFCTR_CHAR0(ID) (char)(((ID>>26) & 0x1F) | '@')  /* Bits 26-30 */
-#define EISA_MFCTR_CHAR1(ID) (char)(((ID>>21) & 0x1F) | '@')  /* Bits 21-25 */
-#define EISA_MFCTR_CHAR2(ID) (char)(((ID>>16) & 0x1F) | '@')  /* Bits 16-20 */
-#define EISA_PRODUCT_ID(ID)  (short)((ID>>4)  & 0xFFF)        /* Bits  4-15 */
-#define EISA_REVISION_ID(ID) (uint8_t)(ID & 0x0F)             /* Bits  0-3  */
-
-static int aic7770_eisa_dev_probe(struct device *dev);
-static int aic7770_eisa_dev_remove(struct device *dev);
-static struct eisa_driver aic7770_driver = {
-	.driver = {
-		.name   = "aic7xxx",
-		.probe  = aic7770_eisa_dev_probe,
-		.remove = aic7770_eisa_dev_remove,
-	}
-};
-
-typedef  struct device *aic7770_dev_t;
-
-static int aic7770_linux_config(struct aic7770_identity *entry,
-				aic7770_dev_t dev, u_int eisaBase);
-
-int
-ahc_linux_eisa_init(void)
-{
-	struct eisa_device_id *eid;
-	struct aic7770_identity *id;
-	int i;
-
-	if (aic7xxx_probe_eisa_vl == 0)
-		return -ENODEV;
-
-	/*
-	 * Linux requires the EISA IDs to be specified in
-	 * the EISA ID string format.  Perform the conversion
-	 * and setup a table with a NUL terminal entry.
-	 */
-	aic7770_driver.id_table = malloc(sizeof(struct eisa_device_id) *
-					 (ahc_num_aic7770_devs + 1),
-					 M_DEVBUF, M_NOWAIT);
-	if (aic7770_driver.id_table == NULL)
-		return -ENOMEM;
-
-	for (eid = (struct eisa_device_id *)aic7770_driver.id_table,
-	     id = aic7770_ident_table, i = 0;
-	     i < ahc_num_aic7770_devs; eid++, id++, i++) {
-
-		sprintf(eid->sig, "%c%c%c%03X%01X",
-			EISA_MFCTR_CHAR0(id->full_id),
-			EISA_MFCTR_CHAR1(id->full_id),
-			EISA_MFCTR_CHAR2(id->full_id),
-			EISA_PRODUCT_ID(id->full_id),
-			EISA_REVISION_ID(id->full_id));
-		eid->driver_data = i;
-	}
-	eid->sig[0] = 0;
-
-	return eisa_driver_register(&aic7770_driver);
-}
-
-void
-ahc_linux_eisa_exit(void)
-{
-	if(aic7xxx_probe_eisa_vl != 0 && aic7770_driver.id_table != NULL) {
-		eisa_driver_unregister(&aic7770_driver);
-		free(aic7770_driver.id_table, M_DEVBUF);
-	}
-}
-
-static int
-aic7770_linux_config(struct aic7770_identity *entry, aic7770_dev_t dev,
-		     u_int eisaBase)
-{
-	struct	ahc_softc *ahc;
-	char	buf[80];
-	char   *name;
-	int	error;
-
-	/*
-	 * Allocate a softc for this card and
-	 * set it up for attachment by our
-	 * common detect routine.
-	 */
-	sprintf(buf, "ahc_eisa:%d", eisaBase >> 12);
-	name = malloc(strlen(buf) + 1, M_DEVBUF, M_NOWAIT);
-	if (name == NULL)
-		return (ENOMEM);
-	strcpy(name, buf);
-	ahc = ahc_alloc(&aic7xxx_driver_template, name);
-	if (ahc == NULL)
-		return (ENOMEM);
-	error = aic7770_config(ahc, entry, eisaBase);
-	if (error != 0) {
-		ahc->bsh.ioport = 0;
-		ahc_free(ahc);
-		return (error);
-	}
-
-	dev->driver_data = (void *)ahc;
-	if (aic7xxx_detect_complete)
-		error = ahc_linux_register_host(ahc, &aic7xxx_driver_template);
-	return (error);
-}
-
 int
 aic7770_map_registers(struct ahc_softc *ahc, u_int port)
 {
@@ -178,25 +75,79 @@ aic7770_map_int(struct ahc_softc *ahc, u_int irq)
 }
 
 static int
-aic7770_eisa_dev_probe(struct device *dev)
+aic7770_probe(struct device *dev)
 {
-	struct eisa_device *edev;
+	struct eisa_device *edev = to_eisa_device(dev);
+	u_int eisaBase = edev->base_addr+AHC_EISA_SLOT_OFFSET;
+	struct	ahc_softc *ahc;
+	char	buf[80];
+	char   *name;
+	int	error;
+
+	sprintf(buf, "ahc_eisa:%d", eisaBase >> 12);
+	name = malloc(strlen(buf) + 1, M_DEVBUF, M_NOWAIT);
+	if (name == NULL)
+		return (ENOMEM);
+	strcpy(name, buf);
+	ahc = ahc_alloc(&aic7xxx_driver_template, name);
+	if (ahc == NULL)
+		return (ENOMEM);
+	error = aic7770_config(ahc, aic7770_ident_table + edev->id.driver_data,
+			       eisaBase);
+	if (error != 0) {
+		ahc->bsh.ioport = 0;
+		ahc_free(ahc);
+		return (error);
+	}
+
+ 	dev_set_drvdata(dev, ahc);
 
-	edev = to_eisa_device(dev);
-	return (aic7770_linux_config(aic7770_ident_table + edev->id.driver_data,
-				    dev, edev->base_addr+AHC_EISA_SLOT_OFFSET));
+	if (aic7xxx_detect_complete)
+		error = ahc_linux_register_host(ahc, &aic7xxx_driver_template);
+	return (error);
 }
 
 static int
-aic7770_eisa_dev_remove(struct device *dev)
+aic7770_remove(struct device *dev)
 {
-	struct ahc_softc *ahc = dev_get_drvata(dev);
+	struct ahc_softc *ahc = dev_get_drvdata(dev);
 	u_long s;
 
 	ahc_lock(ahc, &s);
 	ahc_intr_enable(ahc, FALSE);
 	ahc_unlock(ahc, &s);
-	ahc_free(ahc);
 
-	return (0);
+	ahc_free(ahc);
+	return 0;
+}
+ 
+static struct eisa_device_id aic7770_ids[] = {
+	{ "ADP7771", 0 }, /* AHA 274x */
+	{ "ADP7756", 1 }, /* AHA 284x BIOS enabled */
+	{ "ADP7757", 2 }, /* AHA 284x BIOS disabled */
+	{ "ADP7782", 3 }, /* AHA 274x Olivetti OEM */
+	{ "ADP7783", 4 }, /* AHA 274x Olivetti OEM (Differential) */
+	{ "ADP7770", 5 }, /* AIC7770 generic */
+	{ "" }
+};
+  
+static struct eisa_driver aic7770_driver = {
+	.id_table	= aic7770_ids,
+	.driver = {
+		.name   = "aic7xxx",
+		.probe  = aic7770_probe,
+		.remove = aic7770_remove,
+	}
+};
+  
+int
+ahc_linux_eisa_init(void)
+{
+	return eisa_driver_register(&aic7770_driver);
+}
+  
+void
+ahc_linux_eisa_exit(void)
+{
+	eisa_driver_unregister(&aic7770_driver);
 }

commit 3d65692aed727c7fb4105f03795781ace437a84e
Author: Christoph Hellwig <hch@lst.de>
Date:   Sat Jun 11 00:14:30 2005 +0200

    [SCSI] aic7xxx: remove ahc_find_softc
    
    there's absolutely no reason not to trust the driver private data
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>

diff --git a/drivers/scsi/aic7xxx/aic7770_osm.c b/drivers/scsi/aic7xxx/aic7770_osm.c
index 682ca0b32b44..d0e9b54ab008 100644
--- a/drivers/scsi/aic7xxx/aic7770_osm.c
+++ b/drivers/scsi/aic7xxx/aic7770_osm.c
@@ -190,25 +190,13 @@ aic7770_eisa_dev_probe(struct device *dev)
 static int
 aic7770_eisa_dev_remove(struct device *dev)
 {
-	struct ahc_softc *ahc;
-	u_long l;
+	struct ahc_softc *ahc = dev_get_drvata(dev);
+	u_long s;
 
-	/*
-	 * We should be able to just perform
-	 * the free directly, but check our
-	 * list for extra sanity.
-	 */
-	ahc_list_lock(&l);
-	ahc = ahc_find_softc((struct ahc_softc *)dev->driver_data);
-	if (ahc != NULL) {
-		u_long s;
-
-		ahc_lock(ahc, &s);
-		ahc_intr_enable(ahc, FALSE);
-		ahc_unlock(ahc, &s);
-		ahc_free(ahc);
-	}
-	ahc_list_unlock(&l);
+	ahc_lock(ahc, &s);
+	ahc_intr_enable(ahc, FALSE);
+	ahc_unlock(ahc, &s);
+	ahc_free(ahc);
 
 	return (0);
 }

commit dedd831081052028f35aaf924ea3d6c55109074f
Author: Christoph Hellwig <hch@lst.de>
Date:   Mon May 16 18:52:06 2005 +0200

    [SCSI] aic7xxx: remove Linux 2.4 ifdefs
    
    There's not much sense in sharing code anymore now that aic7xxx uses
    various transport class facilities.
    
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>

diff --git a/drivers/scsi/aic7xxx/aic7770_osm.c b/drivers/scsi/aic7xxx/aic7770_osm.c
index c2b47f2bdffd..682ca0b32b44 100644
--- a/drivers/scsi/aic7xxx/aic7770_osm.c
+++ b/drivers/scsi/aic7xxx/aic7770_osm.c
@@ -41,7 +41,6 @@
 
 #include "aic7xxx_osm.h"
 
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,5,0)
 #include <linux/device.h>
 #include <linux/eisa.h>
 
@@ -62,13 +61,6 @@ static struct eisa_driver aic7770_driver = {
 };
 
 typedef  struct device *aic7770_dev_t;
-#else
-#define MINSLOT			1
-#define NUMSLOTS		16
-#define IDOFFSET		0x80
-
-typedef void *aic7770_dev_t;
-#endif
 
 static int aic7770_linux_config(struct aic7770_identity *entry,
 				aic7770_dev_t dev, u_int eisaBase);
@@ -76,7 +68,6 @@ static int aic7770_linux_config(struct aic7770_identity *entry,
 int
 ahc_linux_eisa_init(void)
 {
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,5,0)
 	struct eisa_device_id *eid;
 	struct aic7770_identity *id;
 	int i;
@@ -110,44 +101,6 @@ ahc_linux_eisa_init(void)
 	eid->sig[0] = 0;
 
 	return eisa_driver_register(&aic7770_driver);
-#else /* LINUX_VERSION_CODE < KERNEL_VERSION(2,5,0) */
-	struct aic7770_identity *entry;
-	u_int  slot;
-	u_int  eisaBase;
-	u_int  i;
-	int ret = -ENODEV;
-
-	if (aic7xxx_probe_eisa_vl == 0)
-		return ret;
-
-	eisaBase = 0x1000 + AHC_EISA_SLOT_OFFSET;
-	for (slot = 1; slot < NUMSLOTS; eisaBase+=0x1000, slot++) {
-		uint32_t eisa_id;
-		size_t	 id_size;
-
-		if (request_region(eisaBase, AHC_EISA_IOSIZE, "aic7xxx") == 0)
-			continue;
-
-		eisa_id = 0;
-		id_size = sizeof(eisa_id);
-		for (i = 0; i < 4; i++) {
-			/* VLcards require priming*/
-			outb(0x80 + i, eisaBase + IDOFFSET);
-			eisa_id |= inb(eisaBase + IDOFFSET + i)
-				   << ((id_size-i-1) * 8);
-		}
-		release_region(eisaBase, AHC_EISA_IOSIZE);
-		if (eisa_id & 0x80000000)
-			continue;  /* no EISA card in slot */
-
-		entry = aic7770_find_device(eisa_id);
-		if (entry != NULL) {
-			aic7770_linux_config(entry, NULL, eisaBase);
-			ret = 0;
-		}
-	}
-	return ret;
-#endif
 }
 
 void
@@ -187,11 +140,10 @@ aic7770_linux_config(struct aic7770_identity *entry, aic7770_dev_t dev,
 		ahc_free(ahc);
 		return (error);
 	}
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,5,0)
+
 	dev->driver_data = (void *)ahc;
 	if (aic7xxx_detect_complete)
 		error = ahc_linux_register_host(ahc, &aic7xxx_driver_template);
-#endif
 	return (error);
 }
 
@@ -225,7 +177,6 @@ aic7770_map_int(struct ahc_softc *ahc, u_int irq)
 	return (-error);
 }
 
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,5,0)
 static int
 aic7770_eisa_dev_probe(struct device *dev)
 {
@@ -261,4 +212,3 @@ aic7770_eisa_dev_remove(struct device *dev)
 
 	return (0);
 }
-#endif

commit 1da177e4c3f41524e886b7f1b8a0c1fc7321cac2
Author: Linus Torvalds <torvalds@ppc970.osdl.org>
Date:   Sat Apr 16 15:20:36 2005 -0700

    Linux-2.6.12-rc2
    
    Initial git repository build. I'm not bothering with the full history,
    even though we have it. We can create a separate "historical" git
    archive of that later if we want to, and in the meantime it's about
    3.2GB when imported into git - space that would just make the early
    git days unnecessarily complicated, when we don't have a lot of good
    infrastructure for it.
    
    Let it rip!

diff --git a/drivers/scsi/aic7xxx/aic7770_osm.c b/drivers/scsi/aic7xxx/aic7770_osm.c
new file mode 100644
index 000000000000..c2b47f2bdffd
--- /dev/null
+++ b/drivers/scsi/aic7xxx/aic7770_osm.c
@@ -0,0 +1,264 @@
+/*
+ * Linux driver attachment glue for aic7770 based controllers.
+ *
+ * Copyright (c) 2000-2003 Adaptec Inc.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions, and the following disclaimer,
+ *    without modification.
+ * 2. Redistributions in binary form must reproduce at minimum a disclaimer
+ *    substantially similar to the "NO WARRANTY" disclaimer below
+ *    ("Disclaimer") and any redistribution must be conditioned upon
+ *    including a substantially similar Disclaimer requirement for further
+ *    binary redistribution.
+ * 3. Neither the names of the above-listed copyright holders nor the names
+ *    of any contributors may be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * Alternatively, this software may be distributed under the terms of the
+ * GNU General Public License ("GPL") version 2 as published by the Free
+ * Software Foundation.
+ *
+ * NO WARRANTY
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * HOLDERS OR CONTRIBUTORS BE LIABLE FOR SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
+ * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGES.
+ *
+ * $Id: //depot/aic7xxx/linux/drivers/scsi/aic7xxx/aic7770_osm.c#14 $
+ */
+
+#include "aic7xxx_osm.h"
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,5,0)
+#include <linux/device.h>
+#include <linux/eisa.h>
+
+#define EISA_MFCTR_CHAR0(ID) (char)(((ID>>26) & 0x1F) | '@')  /* Bits 26-30 */
+#define EISA_MFCTR_CHAR1(ID) (char)(((ID>>21) & 0x1F) | '@')  /* Bits 21-25 */
+#define EISA_MFCTR_CHAR2(ID) (char)(((ID>>16) & 0x1F) | '@')  /* Bits 16-20 */
+#define EISA_PRODUCT_ID(ID)  (short)((ID>>4)  & 0xFFF)        /* Bits  4-15 */
+#define EISA_REVISION_ID(ID) (uint8_t)(ID & 0x0F)             /* Bits  0-3  */
+
+static int aic7770_eisa_dev_probe(struct device *dev);
+static int aic7770_eisa_dev_remove(struct device *dev);
+static struct eisa_driver aic7770_driver = {
+	.driver = {
+		.name   = "aic7xxx",
+		.probe  = aic7770_eisa_dev_probe,
+		.remove = aic7770_eisa_dev_remove,
+	}
+};
+
+typedef  struct device *aic7770_dev_t;
+#else
+#define MINSLOT			1
+#define NUMSLOTS		16
+#define IDOFFSET		0x80
+
+typedef void *aic7770_dev_t;
+#endif
+
+static int aic7770_linux_config(struct aic7770_identity *entry,
+				aic7770_dev_t dev, u_int eisaBase);
+
+int
+ahc_linux_eisa_init(void)
+{
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,5,0)
+	struct eisa_device_id *eid;
+	struct aic7770_identity *id;
+	int i;
+
+	if (aic7xxx_probe_eisa_vl == 0)
+		return -ENODEV;
+
+	/*
+	 * Linux requires the EISA IDs to be specified in
+	 * the EISA ID string format.  Perform the conversion
+	 * and setup a table with a NUL terminal entry.
+	 */
+	aic7770_driver.id_table = malloc(sizeof(struct eisa_device_id) *
+					 (ahc_num_aic7770_devs + 1),
+					 M_DEVBUF, M_NOWAIT);
+	if (aic7770_driver.id_table == NULL)
+		return -ENOMEM;
+
+	for (eid = (struct eisa_device_id *)aic7770_driver.id_table,
+	     id = aic7770_ident_table, i = 0;
+	     i < ahc_num_aic7770_devs; eid++, id++, i++) {
+
+		sprintf(eid->sig, "%c%c%c%03X%01X",
+			EISA_MFCTR_CHAR0(id->full_id),
+			EISA_MFCTR_CHAR1(id->full_id),
+			EISA_MFCTR_CHAR2(id->full_id),
+			EISA_PRODUCT_ID(id->full_id),
+			EISA_REVISION_ID(id->full_id));
+		eid->driver_data = i;
+	}
+	eid->sig[0] = 0;
+
+	return eisa_driver_register(&aic7770_driver);
+#else /* LINUX_VERSION_CODE < KERNEL_VERSION(2,5,0) */
+	struct aic7770_identity *entry;
+	u_int  slot;
+	u_int  eisaBase;
+	u_int  i;
+	int ret = -ENODEV;
+
+	if (aic7xxx_probe_eisa_vl == 0)
+		return ret;
+
+	eisaBase = 0x1000 + AHC_EISA_SLOT_OFFSET;
+	for (slot = 1; slot < NUMSLOTS; eisaBase+=0x1000, slot++) {
+		uint32_t eisa_id;
+		size_t	 id_size;
+
+		if (request_region(eisaBase, AHC_EISA_IOSIZE, "aic7xxx") == 0)
+			continue;
+
+		eisa_id = 0;
+		id_size = sizeof(eisa_id);
+		for (i = 0; i < 4; i++) {
+			/* VLcards require priming*/
+			outb(0x80 + i, eisaBase + IDOFFSET);
+			eisa_id |= inb(eisaBase + IDOFFSET + i)
+				   << ((id_size-i-1) * 8);
+		}
+		release_region(eisaBase, AHC_EISA_IOSIZE);
+		if (eisa_id & 0x80000000)
+			continue;  /* no EISA card in slot */
+
+		entry = aic7770_find_device(eisa_id);
+		if (entry != NULL) {
+			aic7770_linux_config(entry, NULL, eisaBase);
+			ret = 0;
+		}
+	}
+	return ret;
+#endif
+}
+
+void
+ahc_linux_eisa_exit(void)
+{
+	if(aic7xxx_probe_eisa_vl != 0 && aic7770_driver.id_table != NULL) {
+		eisa_driver_unregister(&aic7770_driver);
+		free(aic7770_driver.id_table, M_DEVBUF);
+	}
+}
+
+static int
+aic7770_linux_config(struct aic7770_identity *entry, aic7770_dev_t dev,
+		     u_int eisaBase)
+{
+	struct	ahc_softc *ahc;
+	char	buf[80];
+	char   *name;
+	int	error;
+
+	/*
+	 * Allocate a softc for this card and
+	 * set it up for attachment by our
+	 * common detect routine.
+	 */
+	sprintf(buf, "ahc_eisa:%d", eisaBase >> 12);
+	name = malloc(strlen(buf) + 1, M_DEVBUF, M_NOWAIT);
+	if (name == NULL)
+		return (ENOMEM);
+	strcpy(name, buf);
+	ahc = ahc_alloc(&aic7xxx_driver_template, name);
+	if (ahc == NULL)
+		return (ENOMEM);
+	error = aic7770_config(ahc, entry, eisaBase);
+	if (error != 0) {
+		ahc->bsh.ioport = 0;
+		ahc_free(ahc);
+		return (error);
+	}
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,5,0)
+	dev->driver_data = (void *)ahc;
+	if (aic7xxx_detect_complete)
+		error = ahc_linux_register_host(ahc, &aic7xxx_driver_template);
+#endif
+	return (error);
+}
+
+int
+aic7770_map_registers(struct ahc_softc *ahc, u_int port)
+{
+	/*
+	 * Lock out other contenders for our i/o space.
+	 */
+	if (request_region(port, AHC_EISA_IOSIZE, "aic7xxx") == 0)
+		return (ENOMEM);
+	ahc->tag = BUS_SPACE_PIO;
+	ahc->bsh.ioport = port;
+	return (0);
+}
+
+int
+aic7770_map_int(struct ahc_softc *ahc, u_int irq)
+{
+	int error;
+	int shared;
+
+	shared = 0;
+	if ((ahc->flags & AHC_EDGE_INTERRUPT) == 0)
+		shared = SA_SHIRQ;
+
+	error = request_irq(irq, ahc_linux_isr, shared, "aic7xxx", ahc);
+	if (error == 0)
+		ahc->platform_data->irq = irq;
+	
+	return (-error);
+}
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,5,0)
+static int
+aic7770_eisa_dev_probe(struct device *dev)
+{
+	struct eisa_device *edev;
+
+	edev = to_eisa_device(dev);
+	return (aic7770_linux_config(aic7770_ident_table + edev->id.driver_data,
+				    dev, edev->base_addr+AHC_EISA_SLOT_OFFSET));
+}
+
+static int
+aic7770_eisa_dev_remove(struct device *dev)
+{
+	struct ahc_softc *ahc;
+	u_long l;
+
+	/*
+	 * We should be able to just perform
+	 * the free directly, but check our
+	 * list for extra sanity.
+	 */
+	ahc_list_lock(&l);
+	ahc = ahc_find_softc((struct ahc_softc *)dev->driver_data);
+	if (ahc != NULL) {
+		u_long s;
+
+		ahc_lock(ahc, &s);
+		ahc_intr_enable(ahc, FALSE);
+		ahc_unlock(ahc, &s);
+		ahc_free(ahc);
+	}
+	ahc_list_unlock(&l);
+
+	return (0);
+}
+#endif
