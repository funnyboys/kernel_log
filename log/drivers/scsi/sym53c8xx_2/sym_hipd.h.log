commit 1a59d1b8e05ea6ab45f7e18897de1ef0e6bc3da6
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon May 27 08:55:05 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 156
    
    Based on 1 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license as published by
      the free software foundation either version 2 of the license or at
      your option any later version this program is distributed in the
      hope that it will be useful but without any warranty without even
      the implied warranty of merchantability or fitness for a particular
      purpose see the gnu general public license for more details you
      should have received a copy of the gnu general public license along
      with this program if not write to the free software foundation inc
      59 temple place suite 330 boston ma 02111 1307 usa
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-or-later
    
    has been chosen to replace the boilerplate/reference in 1334 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Reviewed-by: Richard Fontana <rfontana@redhat.com>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190527070033.113240726@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/scsi/sym53c8xx_2/sym_hipd.h b/drivers/scsi/sym53c8xx_2/sym_hipd.h
index a141b1758033..9231a2899064 100644
--- a/drivers/scsi/sym53c8xx_2/sym_hipd.h
+++ b/drivers/scsi/sym53c8xx_2/sym_hipd.h
@@ -1,3 +1,4 @@
+/* SPDX-License-Identifier: GPL-2.0-or-later */
 /*
  * Device driver for the SYMBIOS/LSILOGIC 53C8XX and 53C1010 family 
  * of PCI-SCSI IO processors.
@@ -21,20 +22,6 @@
  * Copyright (C) 1997 Richard Waltham <dormouse@farsrobt.demon.co.uk>
  *
  *-----------------------------------------------------------------------------
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  */
 
 #include <linux/gfp.h>

commit 9cb78c16f5dadefd8dc5ba0ae5a2f26cd59419b3
Author: Hannes Reinecke <hare@suse.de>
Date:   Wed Jun 25 15:27:36 2014 +0200

    scsi: use 64-bit LUNs
    
    The SCSI standard defines 64-bit values for LUNs, and large arrays
    employing large or hierarchical LUN numbers become more and more
    common.
    
    So update the linux SCSI stack to use 64-bit LUN numbers.
    
    Signed-off-by: Hannes Reinecke <hare@suse.de>
    Reviewed-by: Christoph Hellwig <hch@infradead.org>
    Reviewed-by: Ewan Milne <emilne@redhat.com>
    Signed-off-by: Christoph Hellwig <hch@lst.de>

diff --git a/drivers/scsi/sym53c8xx_2/sym_hipd.h b/drivers/scsi/sym53c8xx_2/sym_hipd.h
index 5a80cbac3f92..a141b1758033 100644
--- a/drivers/scsi/sym53c8xx_2/sym_hipd.h
+++ b/drivers/scsi/sym53c8xx_2/sym_hipd.h
@@ -581,7 +581,7 @@ struct sym_pmc {
 #define sym_lp(tp, lun) (!lun) ? (tp)->lun0p : NULL
 #else
 #define sym_lp(tp, lun) \
-	(!lun) ? (tp)->lun0p : (tp)->lunmp ? (tp)->lunmp[(lun)] : NULL
+	(!lun) ? (tp)->lun0p : (tp)->lunmp ? (tp)->lunmp[((u8)lun)] : NULL
 #endif
 
 /*

commit af901ca181d92aac3a7dc265144a9081a86d8f39
Author: André Goddard Rosa <andre.goddard@gmail.com>
Date:   Sat Nov 14 13:09:05 2009 -0200

    tree-wide: fix assorted typos all over the place
    
    That is "success", "unknown", "through", "performance", "[re|un]mapping"
    , "access", "default", "reasonable", "[con]currently", "temperature"
    , "channel", "[un]used", "application", "example","hierarchy", "therefore"
    , "[over|under]flow", "contiguous", "threshold", "enough" and others.
    
    Signed-off-by: André Goddard Rosa <andre.goddard@gmail.com>
    Signed-off-by: Jiri Kosina <jkosina@suse.cz>

diff --git a/drivers/scsi/sym53c8xx_2/sym_hipd.h b/drivers/scsi/sym53c8xx_2/sym_hipd.h
index 053e63c86822..5a80cbac3f92 100644
--- a/drivers/scsi/sym53c8xx_2/sym_hipd.h
+++ b/drivers/scsi/sym53c8xx_2/sym_hipd.h
@@ -54,7 +54,7 @@
  *
  *    SYM_OPT_LIMIT_COMMAND_REORDERING
  *        When this option is set, the driver tries to limit tagged 
- *        command reordering to some reasonnable value.
+ *        command reordering to some reasonable value.
  *        (set for Linux)
  */
 #if 0

commit fa8584566cc9cdaf067dbc12132792887a521da9
Author: Aaro Koskinen <Aaro.Koskinen@nokia.com>
Date:   Tue Apr 14 15:47:00 2009 -0500

    [SCSI] sym53c8xx_2: slave_alloc/destroy safety (2.6.27.5)
    
    Make the sym53c8xx_2 driver slave_alloc/destroy less unsafe. References
    to the destroyed LCB are cleared from the target structure (instead of
    leaving a dangling pointer), and when the last LCB for the target is
    destroyed the reference to the upper layer target data is cleared. The
    host lock is used to prevent a race with the interrupt handler. Also
    user commands are prevented for targets with all LCBs destroyed.
    
    Signed-off-by: Aaro Koskinen <Aaro.Koskinen@nokia.com>
    Tested-by: Tony Battersby <tonyb@cybernetics.com>
    Signed-off-by: Mike Christie <michaelc@cs.wisc.edu>
    Signed-off-by: James Bottomley <James.Bottomley@HansenPartnership.com>

diff --git a/drivers/scsi/sym53c8xx_2/sym_hipd.h b/drivers/scsi/sym53c8xx_2/sym_hipd.h
index 9ebc8706b6bf..053e63c86822 100644
--- a/drivers/scsi/sym53c8xx_2/sym_hipd.h
+++ b/drivers/scsi/sym53c8xx_2/sym_hipd.h
@@ -401,6 +401,7 @@ struct sym_tcb {
 	 *  An array of bus addresses is used on reselection.
 	 */
 	u32	*luntbl;	/* LCBs bus address table	*/
+	int	nlcb;		/* Number of valid LCBs (including LUN #0) */
 
 	/*
 	 *  LUN table used by the C code.
@@ -1065,6 +1066,7 @@ int sym_clear_tasks(struct sym_hcb *np, int cam_status, int target, int lun, int
 struct sym_ccb *sym_get_ccb(struct sym_hcb *np, struct scsi_cmnd *cmd, u_char tag_order);
 void sym_free_ccb(struct sym_hcb *np, struct sym_ccb *cp);
 struct sym_lcb *sym_alloc_lcb(struct sym_hcb *np, u_char tn, u_char ln);
+int sym_free_lcb(struct sym_hcb *np, u_char tn, u_char ln);
 int sym_queue_scsiio(struct sym_hcb *np, struct scsi_cmnd *csio, struct sym_ccb *cp);
 int sym_abort_scsiio(struct sym_hcb *np, struct scsi_cmnd *ccb, int timed_out);
 int sym_reset_scsi_target(struct sym_hcb *np, int target);

commit 284901a90a9e0b812ca3f5f852cbbfb60d10249d
Author: Yang Hongyang <yanghy@cn.fujitsu.com>
Date:   Mon Apr 6 19:01:15 2009 -0700

    dma-mapping: replace all DMA_32BIT_MASK macro with DMA_BIT_MASK(32)
    
    Replace all DMA_32BIT_MASK macro with DMA_BIT_MASK(32)
    
    Signed-off-by: Yang Hongyang<yanghy@cn.fujitsu.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/scsi/sym53c8xx_2/sym_hipd.h b/drivers/scsi/sym53c8xx_2/sym_hipd.h
index b707abe90821..9ebc8706b6bf 100644
--- a/drivers/scsi/sym53c8xx_2/sym_hipd.h
+++ b/drivers/scsi/sym53c8xx_2/sym_hipd.h
@@ -1080,7 +1080,7 @@ int sym_hcb_attach(struct Scsi_Host *shost, struct sym_fw *fw, struct sym_nvram
  */
 
 #if   SYM_CONF_DMA_ADDRESSING_MODE == 0
-#define DMA_DAC_MASK	DMA_32BIT_MASK
+#define DMA_DAC_MASK	DMA_BIT_MASK(32)
 #define sym_build_sge(np, data, badd, len)	\
 do {						\
 	(data)->addr = cpu_to_scr(badd);	\

commit 50cf156af7dc68a44409bef636585ef88ebbab34
Author: Yang Hongyang <yanghy@cn.fujitsu.com>
Date:   Mon Apr 6 19:01:14 2009 -0700

    dma-mapping: replace all DMA_40BIT_MASK macro with DMA_BIT_MASK(40)
    
    Replace all DMA_40BIT_MASK macro with DMA_BIT_MASK(40)
    
    Signed-off-by: Yang Hongyang<yanghy@cn.fujitsu.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/scsi/sym53c8xx_2/sym_hipd.h b/drivers/scsi/sym53c8xx_2/sym_hipd.h
index 76f6295ee881..b707abe90821 100644
--- a/drivers/scsi/sym53c8xx_2/sym_hipd.h
+++ b/drivers/scsi/sym53c8xx_2/sym_hipd.h
@@ -1087,7 +1087,7 @@ do {						\
 	(data)->size = cpu_to_scr(len);		\
 } while (0)
 #elif SYM_CONF_DMA_ADDRESSING_MODE == 1
-#define DMA_DAC_MASK	DMA_40BIT_MASK
+#define DMA_DAC_MASK	DMA_BIT_MASK(40)
 #define sym_build_sge(np, data, badd, len)				\
 do {									\
 	(data)->addr = cpu_to_scr(badd);				\

commit 6a35528a8346f6e6fd32ed7e51f04d1fa4ca2c01
Author: Yang Hongyang <yanghy@cn.fujitsu.com>
Date:   Mon Apr 6 19:01:13 2009 -0700

    dma-mapping: replace all DMA_64BIT_MASK macro with DMA_BIT_MASK(64)
    
    Replace all DMA_64BIT_MASK macro with DMA_BIT_MASK(64)
    
    Signed-off-by: Yang Hongyang<yanghy@cn.fujitsu.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/scsi/sym53c8xx_2/sym_hipd.h b/drivers/scsi/sym53c8xx_2/sym_hipd.h
index 1588c90518d4..76f6295ee881 100644
--- a/drivers/scsi/sym53c8xx_2/sym_hipd.h
+++ b/drivers/scsi/sym53c8xx_2/sym_hipd.h
@@ -1094,7 +1094,7 @@ do {									\
 	(data)->size = cpu_to_scr((((badd) >> 8) & 0xff000000) + len);	\
 } while (0)
 #elif SYM_CONF_DMA_ADDRESSING_MODE == 2
-#define DMA_DAC_MASK	DMA_64BIT_MASK
+#define DMA_DAC_MASK	DMA_BIT_MASK(64)
 int sym_lookup_dmap(struct sym_hcb *np, u32 h, int s);
 static inline void
 sym_build_sge(struct sym_hcb *np, struct sym_tblmove *data, u64 badd, int len)

commit 1beb6fa85ca9afaee109811a3f4a984232a32a4f
Author: Harvey Harrison <harvey.harrison@gmail.com>
Date:   Wed Mar 4 12:06:06 2009 -0800

    [SCSI] replace __inline with inline
    
    Signed-off-by: Harvey Harrison <harvey.harrison@gmail.com>
    Acked-by: Jeff Garzik <jgarzik@redhat.com>
    Acked-by: Hannes Reinecke <hare@suse.de>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: James Bottomley <James.Bottomley@HansenPartnership.com>

diff --git a/drivers/scsi/sym53c8xx_2/sym_hipd.h b/drivers/scsi/sym53c8xx_2/sym_hipd.h
index 61d28fcfffbf..1588c90518d4 100644
--- a/drivers/scsi/sym53c8xx_2/sym_hipd.h
+++ b/drivers/scsi/sym53c8xx_2/sym_hipd.h
@@ -1096,7 +1096,7 @@ do {									\
 #elif SYM_CONF_DMA_ADDRESSING_MODE == 2
 #define DMA_DAC_MASK	DMA_64BIT_MASK
 int sym_lookup_dmap(struct sym_hcb *np, u32 h, int s);
-static __inline void 
+static inline void
 sym_build_sge(struct sym_hcb *np, struct sym_tblmove *data, u64 badd, int len)
 {
 	u32 h = (badd>>32);
@@ -1201,7 +1201,7 @@ dma_addr_t __vtobus(m_pool_ident_t dev_dmat, void *m);
 
 #define sym_m_pool_match(mp_id1, mp_id2)	(mp_id1 == mp_id2)
 
-static __inline void *sym_m_get_dma_mem_cluster(m_pool_p mp, m_vtob_p vbp)
+static inline void *sym_m_get_dma_mem_cluster(m_pool_p mp, m_vtob_p vbp)
 {
 	void *vaddr = NULL;
 	dma_addr_t baddr = 0;
@@ -1215,7 +1215,7 @@ static __inline void *sym_m_get_dma_mem_cluster(m_pool_p mp, m_vtob_p vbp)
 	return vaddr;
 }
 
-static __inline void sym_m_free_dma_mem_cluster(m_pool_p mp, m_vtob_p vbp)
+static inline void sym_m_free_dma_mem_cluster(m_pool_p mp, m_vtob_p vbp)
 {
 	dma_free_coherent(mp->dev_dmat, SYM_MEM_CLUSTER_SIZE, vbp->vaddr,
 			vbp->baddr);

commit 058bb82c5628c88af802c19e2b56ae43551552d5
Author: Tony Battersby <tonyb@cybernetics.com>
Date:   Thu Jan 8 12:59:08 2009 -0500

    [SCSI] sym53c8xx: don't flood syslog with negotiation messages
    
    sym53c8xx prints a negotiation message after every check condition.
    This can add up to a lot of messages for removable-medium devices
    (CD-ROM, tape drives, etc.) that are being polled, since they return
    check condition when no medium is present.  This patch suppresses the
    negotiation message if it would be the same as the last one printed.
    
    Signed-off-by: Tony Battersby <tonyb@cybernetics.com>
    Signed-off-by: James Bottomley <James.Bottomley@HansenPartnership.com>

diff --git a/drivers/scsi/sym53c8xx_2/sym_hipd.h b/drivers/scsi/sym53c8xx_2/sym_hipd.h
index 233a3d0b2cef..61d28fcfffbf 100644
--- a/drivers/scsi/sym53c8xx_2/sym_hipd.h
+++ b/drivers/scsi/sym53c8xx_2/sym_hipd.h
@@ -420,6 +420,9 @@ struct sym_tcb {
 	/* Transfer goal */
 	struct sym_trans tgoal;
 
+	/* Last printed transfer speed */
+	struct sym_trans tprint;
+
 	/*
 	 * Keep track of the CCB used for the negotiation in order
 	 * to ensure that only 1 negotiation is queued at a time.

commit 49799fee82b4f78c45b1926be24e45b5cf667083
Author: Aaro Koskinen <Aaro.Koskinen@nokia.com>
Date:   Thu Jan 15 17:13:36 2009 +0200

    [SCSI] sym53c8xx: Keep transfer negotiations valid
    
    (The patch updated based on testing and comments from Tony Battersby.)
    
    Change the sym53c8xx_2 driver negotiation logic so that the driver will
    tolerate better device removals. Negotiation message(s) will be sent
    with every INQUIRY and REQUEST SENSE command, and whenever there is a
    change in goals or when the device reports check condition.
    
    The patch was made specifically to address the case where you hotswap
    the disk using remove-single-device/add-single-device commands through
    /proc/scsi/scsi. Without the patch the driver keeps using old transfer
    parameters even though the target is reset and reports check condition,
    so the data transfer of the very first INQUIRY will fail.
    
    Signed-off-by: Aaro Koskinen <Aaro.Koskinen@nokia.com>
    Tested-by: Tony Battersby <tonyb@cybernetics.com>
    Signed-off-by: James Bottomley <James.Bottomley@HansenPartnership.com>

diff --git a/drivers/scsi/sym53c8xx_2/sym_hipd.h b/drivers/scsi/sym53c8xx_2/sym_hipd.h
index ad078805e62b..233a3d0b2cef 100644
--- a/drivers/scsi/sym53c8xx_2/sym_hipd.h
+++ b/drivers/scsi/sym53c8xx_2/sym_hipd.h
@@ -354,6 +354,7 @@ struct sym_trans {
 	unsigned int dt:1;
 	unsigned int qas:1;
 	unsigned int check_nego:1;
+	unsigned int renego:2;
 };
 
 /*

commit 5111eefa17615bdf17ca00ec2cdca16302c7697e
Author: Matthew Wilcox <matthew@wil.cx>
Date:   Fri Oct 5 15:55:13 2007 -0400

    [SCSI] sym53c8xx: Remove pci_dev pointer from sym_shcb
    
    This structure is accessed by the device; the fewer Linux things in it,
    the better.  Using the pci_dev pointer from the hostdata requires a lot
    of changes:
    
     - Pass Scsi_Host to a lot of routines which currently take a sym_hcb.
     - Set the Scsi_Host as the pci drvdata (instead of the sym_hcb)
    
    Signed-off-by: Matthew Wilcox <willy@linux.intel.com>
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>

diff --git a/drivers/scsi/sym53c8xx_2/sym_hipd.h b/drivers/scsi/sym53c8xx_2/sym_hipd.h
index a9c08668b98c..ad078805e62b 100644
--- a/drivers/scsi/sym53c8xx_2/sym_hipd.h
+++ b/drivers/scsi/sym53c8xx_2/sym_hipd.h
@@ -909,7 +909,7 @@ struct sym_hcb {
 	struct sym_fwb_ba fwb_bas;	/* Useful SCRIPTB bus addresses	*/
 	struct sym_fwz_ba fwz_bas;	/* Useful SCRIPTZ bus addresses	*/
 	void		(*fw_setup)(struct sym_hcb *np, struct sym_fw *fw);
-	void		(*fw_patch)(struct sym_hcb *np);
+	void		(*fw_patch)(struct Scsi_Host *);
 	char		*fw_name;
 
 	/*
@@ -1055,7 +1055,7 @@ void sym_start_next_ccbs(struct sym_hcb *np, struct sym_lcb *lp, int maxn);
 #else
 void sym_put_start_queue(struct sym_hcb *np, struct sym_ccb *cp);
 #endif
-void sym_start_up(struct sym_hcb *np, int reason);
+void sym_start_up(struct Scsi_Host *, int reason);
 irqreturn_t sym_interrupt(struct Scsi_Host *);
 int sym_clear_tasks(struct sym_hcb *np, int cam_status, int target, int lun, int task);
 struct sym_ccb *sym_get_ccb(struct sym_hcb *np, struct scsi_cmnd *cmd, u_char tag_order);

commit 99c9e0a1d6cfe1ba1169a7a81435ee85bc00e4a1
Author: Matthew Wilcox <matthew@wil.cx>
Date:   Fri Oct 5 15:55:12 2007 -0400

    [SCSI] sym53c8xx: Make interrupt handler capable of returning IRQ_NONE
    
    Make sym_interrupt return an irqreturn_t instead of void, and take a
    Scsi_Host instead of a sym_hcb.  Pass the Scsi_Host to the interrupt
    handler instead of the sym_hcb.  Rename the host_data to sym_data.
    Keep a pci_dev pointer in the sym_data.  Rename the Scsi_Host from
    instance to shost.
    
    Signed-off-by: Matthew Wilcox <willy@linux.intel.com>
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>

diff --git a/drivers/scsi/sym53c8xx_2/sym_hipd.h b/drivers/scsi/sym53c8xx_2/sym_hipd.h
index 4354571a63ef..a9c08668b98c 100644
--- a/drivers/scsi/sym53c8xx_2/sym_hipd.h
+++ b/drivers/scsi/sym53c8xx_2/sym_hipd.h
@@ -1056,7 +1056,7 @@ void sym_start_next_ccbs(struct sym_hcb *np, struct sym_lcb *lp, int maxn);
 void sym_put_start_queue(struct sym_hcb *np, struct sym_ccb *cp);
 #endif
 void sym_start_up(struct sym_hcb *np, int reason);
-void sym_interrupt(struct sym_hcb *np);
+irqreturn_t sym_interrupt(struct Scsi_Host *);
 int sym_clear_tasks(struct sym_hcb *np, int cam_status, int target, int lun, int task);
 struct sym_ccb *sym_get_ccb(struct sym_hcb *np, struct scsi_cmnd *cmd, u_char tag_order);
 void sym_free_ccb(struct sym_hcb *np, struct sym_ccb *cp);

commit 4d85b471593d03e141f9160a58574b9204363267
Author: Matthew Wilcox <matthew@wil.cx>
Date:   Fri Oct 5 15:55:09 2007 -0400

    [SCSI] sym53c8xx: Simplify DAC DMA handling
    
    By introducing the use_dac(), set_dac() and DMA_DAC_MASK macros, we can
    eliminate a lot of ifdefs from the code.  We now rely on the compiler to
    optimise away a few things that we'd formerly relied on the preprocessor
    to do.  This makes sym_setup_bus_dma_mask() small enough to inline into
    its only caller.
    
    Signed-off-by: Matthew Wilcox <willy@linux.intel.com>
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>

diff --git a/drivers/scsi/sym53c8xx_2/sym_hipd.h b/drivers/scsi/sym53c8xx_2/sym_hipd.h
index f76b27f0aa2c..4354571a63ef 100644
--- a/drivers/scsi/sym53c8xx_2/sym_hipd.h
+++ b/drivers/scsi/sym53c8xx_2/sym_hipd.h
@@ -1026,6 +1026,14 @@ struct sym_hcb {
 #endif
 };
 
+#if SYM_CONF_DMA_ADDRESSING_MODE == 0
+#define use_dac(np)	0
+#define set_dac(np)	do { } while (0)
+#else
+#define use_dac(np)	(np)->use_dac
+#define set_dac(np)	(np)->use_dac = 1
+#endif
+
 #define HCB_BA(np, lbl)	(np->hcb_ba + offsetof(struct sym_hcb, lbl))
 
 
@@ -1068,18 +1076,21 @@ int sym_hcb_attach(struct Scsi_Host *shost, struct sym_fw *fw, struct sym_nvram
  */
 
 #if   SYM_CONF_DMA_ADDRESSING_MODE == 0
+#define DMA_DAC_MASK	DMA_32BIT_MASK
 #define sym_build_sge(np, data, badd, len)	\
 do {						\
 	(data)->addr = cpu_to_scr(badd);	\
 	(data)->size = cpu_to_scr(len);		\
 } while (0)
 #elif SYM_CONF_DMA_ADDRESSING_MODE == 1
+#define DMA_DAC_MASK	DMA_40BIT_MASK
 #define sym_build_sge(np, data, badd, len)				\
 do {									\
 	(data)->addr = cpu_to_scr(badd);				\
 	(data)->size = cpu_to_scr((((badd) >> 8) & 0xff000000) + len);	\
 } while (0)
 #elif SYM_CONF_DMA_ADDRESSING_MODE == 2
+#define DMA_DAC_MASK	DMA_64BIT_MASK
 int sym_lookup_dmap(struct sym_hcb *np, u32 h, int s);
 static __inline void 
 sym_build_sge(struct sym_hcb *np, struct sym_tblmove *data, u64 badd, int len)

commit 8637baa3609afff9fe4c65ad4c64d72484c699fc
Author: Matthew Wilcox <matthew@wil.cx>
Date:   Fri Oct 5 15:55:07 2007 -0400

    [SCSI] sym53c8xx: Remove io_ws, mmio_ws and ram_ws elements
    
    These struct elements record info that is never needed
    
    Signed-off-by: Matthew Wilcox <willy@linux.intel.com>
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>

diff --git a/drivers/scsi/sym53c8xx_2/sym_hipd.h b/drivers/scsi/sym53c8xx_2/sym_hipd.h
index b8908e10162a..f76b27f0aa2c 100644
--- a/drivers/scsi/sym53c8xx_2/sym_hipd.h
+++ b/drivers/scsi/sym53c8xx_2/sym_hipd.h
@@ -883,10 +883,7 @@ struct sym_hcb {
 	 *  Physical bus addresses of the chip.
 	 */
 	u32		mmio_ba;	/* MMIO 32 bit BUS address	*/
-	int		mmio_ws;	/* MMIO Window size		*/
-
 	u32		ram_ba;		/* RAM 32 bit BUS address	*/
-	int		ram_ws;		/* RAM window size		*/
 
 	/*
 	 *  SCRIPTS virtual and physical bus addresses.

commit e58bc06ed071e43bef4e2f94340853761a4bf034
Author: Matthew Wilcox <matthew@wil.cx>
Date:   Fri Oct 5 15:55:06 2007 -0400

    [SCSI] sym53c8xx: Remove ->device_id
    
    Following the same path as ->revision_id, remove ->device_id
    
    Signed-off-by: Matthew Wilcox <willy@linux.intel.com>
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>

diff --git a/drivers/scsi/sym53c8xx_2/sym_hipd.h b/drivers/scsi/sym53c8xx_2/sym_hipd.h
index 3aa8060a4d2a..b8908e10162a 100644
--- a/drivers/scsi/sym53c8xx_2/sym_hipd.h
+++ b/drivers/scsi/sym53c8xx_2/sym_hipd.h
@@ -918,7 +918,6 @@ struct sym_hcb {
 	/*
 	 *  General controller parameters and configuration.
 	 */
-	u_short	device_id;	/* PCI device id		*/
 	u_int	features;	/* Chip features map		*/
 	u_char	myaddr;		/* SCSI id of the adapter	*/
 	u_char	maxburst;	/* log base 2 of dwords burst	*/

commit bd678450bfbd4bb6543a7138d9ee3418c2a11e7c
Author: Matthew Wilcox <matthew@wil.cx>
Date:   Fri Oct 5 15:55:05 2007 -0400

    [SCSI] sym53c8xx: Use pdev->revision
    
    Auke missed the sym2 driver in his initial sweep.
    
    Signed-off-by: Matthew Wilcox <willy@linux.intel.com>
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>

diff --git a/drivers/scsi/sym53c8xx_2/sym_hipd.h b/drivers/scsi/sym53c8xx_2/sym_hipd.h
index 79ab6a177039..3aa8060a4d2a 100644
--- a/drivers/scsi/sym53c8xx_2/sym_hipd.h
+++ b/drivers/scsi/sym53c8xx_2/sym_hipd.h
@@ -919,7 +919,6 @@ struct sym_hcb {
 	 *  General controller parameters and configuration.
 	 */
 	u_short	device_id;	/* PCI device id		*/
-	u_char	revision_id;	/* PCI device revision id	*/
 	u_int	features;	/* Chip features map		*/
 	u_char	myaddr;		/* SCSI id of the adapter	*/
 	u_char	maxburst;	/* log base 2 of dwords burst	*/

commit 3bea15a76eecc03729bf74d6ab2a1f849c08423e
Author: Matthew Wilcox <matthew@wil.cx>
Date:   Tue Mar 28 11:03:44 2006 -0500

    [SCSI] Disable sym2 driver queueing
    
    Undef SYM_OPT_HANDLE_DEVICE_QUEUEING.
    Call sym_put_start_queue instead of sym_start_next_ccbs.
    Turn asserts into checks that we can send the command to the adapter,
    and return busy from queuecommand if we can't.
    
    Signed-off-by: Matthew Wilcox <matthew@wil.cx>
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>

diff --git a/drivers/scsi/sym53c8xx_2/sym_hipd.h b/drivers/scsi/sym53c8xx_2/sym_hipd.h
index 2456090bb241..79ab6a177039 100644
--- a/drivers/scsi/sym53c8xx_2/sym_hipd.h
+++ b/drivers/scsi/sym53c8xx_2/sym_hipd.h
@@ -1049,6 +1049,8 @@ int sym_reset_scsi_bus(struct sym_hcb *np, int enab_int);
 struct sym_chip *sym_lookup_chip_table(u_short device_id, u_char revision);
 #ifdef SYM_OPT_HANDLE_DEVICE_QUEUEING
 void sym_start_next_ccbs(struct sym_hcb *np, struct sym_lcb *lp, int maxn);
+#else
+void sym_put_start_queue(struct sym_hcb *np, struct sym_ccb *cp);
 #endif
 void sym_start_up(struct sym_hcb *np, int reason);
 void sym_interrupt(struct sym_hcb *np);

commit b37df48923b76155de2a728e1155ed263dba5f53
Author: Matthew Wilcox <matthew@wil.cx>
Date:   Tue Nov 29 23:08:44 2005 -0500

    [SCSI] sym2: Allow NVRAM settings to limit speed and width
    
    The NVRAM for both Tekram and Symbios boards allows the user to set the
    speed and width for individual targets.  I took that code out in March
    2004 when we introduced Domain Validation, but it seems there's still
    a legitimate need for it in some configurations.
    
    Signed-off-by: Matthew Wilcox <matthew@wil.cx>
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>

diff --git a/drivers/scsi/sym53c8xx_2/sym_hipd.h b/drivers/scsi/sym53c8xx_2/sym_hipd.h
index 17181101f6c8..2456090bb241 100644
--- a/drivers/scsi/sym53c8xx_2/sym_hipd.h
+++ b/drivers/scsi/sym53c8xx_2/sym_hipd.h
@@ -434,8 +434,10 @@ struct sym_tcb {
 	 *  Other user settable limits and options.
 	 *  These limits are read from the NVRAM if present.
 	 */
-	u_char	usrflags;
-	u_short	usrtags;
+	unsigned char	usrflags;
+	unsigned char	usr_period;
+	unsigned char	usr_width;
+	unsigned short	usrtags;
 	struct scsi_target *starget;
 };
 

commit 44f30b0f59d628eb6f57cfa9d8ab06da670e5306
Author: Matthew Wilcox <matthew@wil.cx>
Date:   Tue Nov 29 23:08:33 2005 -0500

    [SCSI] sym2: Remove code to handle DMA_BIDIRECTION requests
    
    The upper layer doesn't send these down since 2.4.x (or 2.6 in
    practice), so no need to handle it.  Inline sym_setup_data_pointers
    into its only caller so we can fail gracefully in the case we'd get
    one neverless.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Matthew Wilcox <matthew@wil.cx>
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>

diff --git a/drivers/scsi/sym53c8xx_2/sym_hipd.h b/drivers/scsi/sym53c8xx_2/sym_hipd.h
index 756008812aa1..17181101f6c8 100644
--- a/drivers/scsi/sym53c8xx_2/sym_hipd.h
+++ b/drivers/scsi/sym53c8xx_2/sym_hipd.h
@@ -48,12 +48,6 @@
  *  They may be defined in platform specific headers, if they 
  *  are useful.
  *
- *    SYM_OPT_HANDLE_DIR_UNKNOWN
- *        When this option is set, the SCRIPTS used by the driver 
- *        are able to handle SCSI transfers with direction not 
- *        supplied by user.
- *        (set for Linux-2.0.X)
- *
  *    SYM_OPT_HANDLE_DEVICE_QUEUEING
  *        When this option is set, the driver will use a queue per 
  *        device and handle QUEUE FULL status requeuing internally.
@@ -64,7 +58,6 @@
  *        (set for Linux)
  */
 #if 0
-#define SYM_OPT_HANDLE_DIR_UNKNOWN
 #define SYM_OPT_HANDLE_DEVICE_QUEUEING
 #define SYM_OPT_LIMIT_COMMAND_REORDERING
 #endif
@@ -659,9 +652,6 @@ struct sym_ccbh {
 	 */
 	u32	savep;		/* Jump address to saved data pointer	*/
 	u32	lastp;		/* SCRIPTS address at end of data	*/
-#ifdef	SYM_OPT_HANDLE_DIR_UNKNOWN
-	u32	wlastp;
-#endif
 
 	/*
 	 *  Status fields.
@@ -791,9 +781,6 @@ struct sym_ccb {
 	SYM_QUEHEAD link_ccbq;	/* Link to free/busy CCB queue	*/
 	u32	startp;		/* Initial data pointer		*/
 	u32	goalp;		/* Expected last data pointer	*/
-#ifdef	SYM_OPT_HANDLE_DIR_UNKNOWN
-	u32	wgoalp;
-#endif
 	int	ext_sg;		/* Extreme data pointer, used	*/
 	int	ext_ofs;	/*  to calculate the residual.	*/
 #ifdef SYM_OPT_HANDLE_DEVICE_QUEUEING
@@ -808,12 +795,6 @@ struct sym_ccb {
 
 #define CCB_BA(cp,lbl)	cpu_to_scr(cp->ccb_ba + offsetof(struct sym_ccb, lbl))
 
-#ifdef	SYM_OPT_HANDLE_DIR_UNKNOWN
-#define	sym_goalp(cp) ((cp->host_flags & HF_DATA_IN) ? cp->goalp : cp->wgoalp)
-#else
-#define	sym_goalp(cp) (cp->goalp)
-#endif
-
 typedef struct device *m_pool_ident_t;
 
 /*
@@ -1121,71 +1102,6 @@ sym_build_sge(struct sym_hcb *np, struct sym_tblmove *data, u64 badd, int len)
 #error "Unsupported DMA addressing mode"
 #endif
 
-/*
- *  Set up data pointers used by SCRIPTS.
- *  Called from O/S specific code.
- */
-static inline void sym_setup_data_pointers(struct sym_hcb *np,
-		struct sym_ccb *cp, int dir)
-{
-	u32 lastp, goalp;
-
-	/*
-	 *  No segments means no data.
-	 */
-	if (!cp->segments)
-		dir = DMA_NONE;
-
-	/*
-	 *  Set the data pointer.
-	 */
-	switch(dir) {
-#ifdef	SYM_OPT_HANDLE_DIR_UNKNOWN
-	case DMA_BIDIRECTIONAL:
-#endif
-	case DMA_TO_DEVICE:
-		goalp = SCRIPTA_BA(np, data_out2) + 8;
-		lastp = goalp - 8 - (cp->segments * (2*4));
-#ifdef	SYM_OPT_HANDLE_DIR_UNKNOWN
-		cp->wgoalp = cpu_to_scr(goalp);
-		if (dir != DMA_BIDIRECTIONAL)
-			break;
-		cp->phys.head.wlastp = cpu_to_scr(lastp);
-		/* fall through */
-#else
-		break;
-#endif
-	case DMA_FROM_DEVICE:
-		cp->host_flags |= HF_DATA_IN;
-		goalp = SCRIPTA_BA(np, data_in2) + 8;
-		lastp = goalp - 8 - (cp->segments * (2*4));
-		break;
-	case DMA_NONE:
-	default:
-#ifdef	SYM_OPT_HANDLE_DIR_UNKNOWN
-		cp->host_flags |= HF_DATA_IN;
-#endif
-		lastp = goalp = SCRIPTB_BA(np, no_data);
-		break;
-	}
-
-	/*
-	 *  Set all pointers values needed by SCRIPTS.
-	 */
-	cp->phys.head.lastp = cpu_to_scr(lastp);
-	cp->phys.head.savep = cpu_to_scr(lastp);
-	cp->startp	    = cp->phys.head.savep;
-	cp->goalp	    = cpu_to_scr(goalp);
-
-#ifdef	SYM_OPT_HANDLE_DIR_UNKNOWN
-	/*
-	 *  If direction is unknown, start at data_io.
-	 */
-	if (dir == DMA_BIDIRECTIONAL)
-		cp->phys.head.savep = cpu_to_scr(SCRIPTB_BA(np, data_io));
-#endif
-}
-
 /*
  *  MEMORY ALLOCATOR.
  */

commit 84e203a279d3de1c8a41a73ab45e55a89bc19345
Author: Matthew Wilcox <matthew@wil.cx>
Date:   Tue Nov 29 23:08:31 2005 -0500

    [SCSI] sym2: Manage sym_lcb properly
    
    Allocate the lcb in slave_alloc and free it in slave_destroy.  This allows
    us to remove all the code that checks to see if it's already been allocated.
    
    From: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Matthew Wilcox <matthew@wil.cx>
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>

diff --git a/drivers/scsi/sym53c8xx_2/sym_hipd.h b/drivers/scsi/sym53c8xx_2/sym_hipd.h
index 3a264a408216..756008812aa1 100644
--- a/drivers/scsi/sym53c8xx_2/sym_hipd.h
+++ b/drivers/scsi/sym53c8xx_2/sym_hipd.h
@@ -416,19 +416,6 @@ struct sym_tcb {
 	struct sym_lcb **lunmp;		/* Other LCBs [1..MAX_LUN]	*/
 #endif
 
-	/*
-	 *  Bitmap that tells about LUNs that succeeded at least 
-	 *  1 IO and therefore assumed to be a real device.
-	 *  Avoid useless allocation of the LCB structure.
-	 */
-	u32	lun_map[(SYM_CONF_MAX_LUN+31)/32];
-
-	/*
-	 *  Bitmap that tells about LUNs that haven't yet an LCB 
-	 *  allocated (not discovered or LCB allocation failed).
-	 */
-	u32	busy0_map[(SYM_CONF_MAX_LUN+31)/32];
-
 #ifdef	SYM_HAVE_STCB
 	/*
 	 *  O/S specific data structure.
@@ -1077,7 +1064,6 @@ char *sym_driver_name(void);
 void sym_print_xerr(struct scsi_cmnd *cmd, int x_status);
 int sym_reset_scsi_bus(struct sym_hcb *np, int enab_int);
 struct sym_chip *sym_lookup_chip_table(u_short device_id, u_char revision);
-void sym_put_start_queue(struct sym_hcb *np, struct sym_ccb *cp);
 #ifdef SYM_OPT_HANDLE_DEVICE_QUEUEING
 void sym_start_next_ccbs(struct sym_hcb *np, struct sym_lcb *lp, int maxn);
 #endif

commit 4e57b6817880946a3a78d5d8cad1ace363f7e449
Author: Tim Schmielau <tim@physik3.uni-rostock.de>
Date:   Sun Oct 30 15:03:48 2005 -0800

    [PATCH] fix missing includes
    
    I recently picked up my older work to remove unnecessary #includes of
    sched.h, starting from a patch by Dave Jones to not include sched.h
    from module.h. This reduces the number of indirect includes of sched.h
    by ~300. Another ~400 pointless direct includes can be removed after
    this disentangling (patch to follow later).
    However, quite a few indirect includes need to be fixed up for this.
    
    In order to feed the patches through -mm with as little disturbance as
    possible, I've split out the fixes I accumulated up to now (complete for
    i386 and x86_64, more archs to follow later) and post them before the real
    patch.  This way this large part of the patch is kept simple with only
    adding #includes, and all hunks are independent of each other.  So if any
    hunk rejects or gets in the way of other patches, just drop it.  My scripts
    will pick it up again in the next round.
    
    Signed-off-by: Tim Schmielau <tim@physik3.uni-rostock.de>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/drivers/scsi/sym53c8xx_2/sym_hipd.h b/drivers/scsi/sym53c8xx_2/sym_hipd.h
index 3131a6bf7ab7..3a264a408216 100644
--- a/drivers/scsi/sym53c8xx_2/sym_hipd.h
+++ b/drivers/scsi/sym53c8xx_2/sym_hipd.h
@@ -37,6 +37,8 @@
  * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
  */
 
+#include <linux/gfp.h>
+
 #ifndef SYM_HIPD_H
 #define SYM_HIPD_H
 

commit 44456d37b59d8e541936ed26d8b6e08d27e88ac1
Author: Olaf Hering <olh@suse.de>
Date:   Wed Jul 27 11:45:17 2005 -0700

    [PATCH] turn many #if $undefined_string into #ifdef $undefined_string
    
    turn many #if $undefined_string into #ifdef $undefined_string to fix some
    warnings after -Wno-def was added to global CFLAGS
    
    Signed-off-by: Olaf Hering <olh@suse.de>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/drivers/scsi/sym53c8xx_2/sym_hipd.h b/drivers/scsi/sym53c8xx_2/sym_hipd.h
index c55c7a57afa0..3131a6bf7ab7 100644
--- a/drivers/scsi/sym53c8xx_2/sym_hipd.h
+++ b/drivers/scsi/sym53c8xx_2/sym_hipd.h
@@ -151,6 +151,16 @@
  */
 #define	SYM_CONF_MIN_ASYNC (40)
 
+
+/*
+ * MEMORY ALLOCATOR.
+ */
+
+#define SYM_MEM_WARN	1	/* Warn on failed operations */
+
+#define SYM_MEM_PAGE_ORDER 0	/* 1 PAGE  maximum */
+#define SYM_MEM_CLUSTER_SHIFT	(PAGE_SHIFT+SYM_MEM_PAGE_ORDER)
+#define SYM_MEM_FREE_UNUSED	/* Free unused pages immediately */
 /*
  *  Shortest memory chunk is (1<<SYM_MEM_SHIFT), currently 16.
  *  Actual allocations happen as SYM_MEM_CLUSTER_SIZE sized.
@@ -1192,12 +1202,6 @@ static inline void sym_setup_data_pointers(struct sym_hcb *np,
  *  MEMORY ALLOCATOR.
  */
 
-#define SYM_MEM_PAGE_ORDER 0	/* 1 PAGE  maximum */
-#define SYM_MEM_CLUSTER_SHIFT	(PAGE_SHIFT+SYM_MEM_PAGE_ORDER)
-#define SYM_MEM_FREE_UNUSED	/* Free unused pages immediately */
-
-#define SYM_MEM_WARN	1	/* Warn on failed operations */
-
 #define sym_get_mem_cluster()	\
 	(void *) __get_free_pages(GFP_ATOMIC, SYM_MEM_PAGE_ORDER)
 #define sym_free_mem_cluster(p)	\

commit 53222b906903fd861dc24ebccfa07ee125941313
Author: Matthew Wilcox <matthew@wil.cx>
Date:   Fri May 20 19:15:43 2005 +0100

    [SCSI] sym2 version 2.2.1
    
    sym2 version 2.2.1:
     - Fix MMIO BAR detection (Thanks to Bob Picco)
     - Fix odd-sized transfers with a wide bus (Thanks to Larry Stephens)
     - Write posting fixes (Thanks to Thibaut Varene)
     - Change one of the GFP_KERNEL allocations back into a GFP_ATOMIC
     - Make CCB_BA() return a script-endian address
     - Move range checks and disabling of devices from the queuecommand path
       to slave_alloc()
     - Remove a warning in sym_setup_cdb()
     - Keep a pointer to the scsi_target instead of the scsi_dev in the tcb
     - Remove a check for the upper layers passing an oversized cmd
     - Replace CAM_REQ_ constants with the Linux DID_ constants
     - Replace CAM_DIR_ constants with the Linux DMA_ constants
     - Inline sym_read_parisc_pdc() on non-parisc systems
    
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>

diff --git a/drivers/scsi/sym53c8xx_2/sym_hipd.h b/drivers/scsi/sym53c8xx_2/sym_hipd.h
index a95cbe4b8e39..c55c7a57afa0 100644
--- a/drivers/scsi/sym53c8xx_2/sym_hipd.h
+++ b/drivers/scsi/sym53c8xx_2/sym_hipd.h
@@ -444,7 +444,7 @@ struct sym_tcb {
 	 */
 	u_char	usrflags;
 	u_short	usrtags;
-	struct scsi_device *sdev;
+	struct scsi_target *starget;
 };
 
 /*
@@ -754,10 +754,8 @@ struct sym_ccb {
 	int	segments;	/* Number of SG segments	*/
 
 	u8	order;		/* Tag type (if tagged command)	*/
+	unsigned char odd_byte_adjustment;	/* odd-sized req on wide bus */
 
-	/*
-	 *  Miscellaneous status'.
-	 */
 	u_char	nego_status;	/* Negotiation status		*/
 	u_char	xerr_status;	/* Extended error flags		*/
 	u32	extra_bytes;	/* Extraneous bytes transferred	*/
@@ -809,7 +807,7 @@ struct sym_ccb {
 #endif
 };
 
-#define CCB_BA(cp,lbl)	(cp->ccb_ba + offsetof(struct sym_ccb, lbl))
+#define CCB_BA(cp,lbl)	cpu_to_scr(cp->ccb_ba + offsetof(struct sym_ccb, lbl))
 
 #ifdef	SYM_OPT_HANDLE_DIR_UNKNOWN
 #define	sym_goalp(cp) ((cp->host_flags & HF_DATA_IN) ? cp->goalp : cp->wgoalp)
@@ -1138,33 +1136,33 @@ static inline void sym_setup_data_pointers(struct sym_hcb *np,
 	 *  No segments means no data.
 	 */
 	if (!cp->segments)
-		dir = CAM_DIR_NONE;
+		dir = DMA_NONE;
 
 	/*
 	 *  Set the data pointer.
 	 */
 	switch(dir) {
 #ifdef	SYM_OPT_HANDLE_DIR_UNKNOWN
-	case CAM_DIR_UNKNOWN:
+	case DMA_BIDIRECTIONAL:
 #endif
-	case CAM_DIR_OUT:
+	case DMA_TO_DEVICE:
 		goalp = SCRIPTA_BA(np, data_out2) + 8;
 		lastp = goalp - 8 - (cp->segments * (2*4));
 #ifdef	SYM_OPT_HANDLE_DIR_UNKNOWN
 		cp->wgoalp = cpu_to_scr(goalp);
-		if (dir != CAM_DIR_UNKNOWN)
+		if (dir != DMA_BIDIRECTIONAL)
 			break;
 		cp->phys.head.wlastp = cpu_to_scr(lastp);
 		/* fall through */
 #else
 		break;
 #endif
-	case CAM_DIR_IN:
+	case DMA_FROM_DEVICE:
 		cp->host_flags |= HF_DATA_IN;
 		goalp = SCRIPTA_BA(np, data_in2) + 8;
 		lastp = goalp - 8 - (cp->segments * (2*4));
 		break;
-	case CAM_DIR_NONE:
+	case DMA_NONE:
 	default:
 #ifdef	SYM_OPT_HANDLE_DIR_UNKNOWN
 		cp->host_flags |= HF_DATA_IN;
@@ -1185,7 +1183,7 @@ static inline void sym_setup_data_pointers(struct sym_hcb *np,
 	/*
 	 *  If direction is unknown, start at data_io.
 	 */
-	if (dir == CAM_DIR_UNKNOWN)
+	if (dir == DMA_BIDIRECTIONAL)
 		cp->phys.head.savep = cpu_to_scr(SCRIPTB_BA(np, data_io));
 #endif
 }

commit 1da177e4c3f41524e886b7f1b8a0c1fc7321cac2
Author: Linus Torvalds <torvalds@ppc970.osdl.org>
Date:   Sat Apr 16 15:20:36 2005 -0700

    Linux-2.6.12-rc2
    
    Initial git repository build. I'm not bothering with the full history,
    even though we have it. We can create a separate "historical" git
    archive of that later if we want to, and in the meantime it's about
    3.2GB when imported into git - space that would just make the early
    git days unnecessarily complicated, when we don't have a lot of good
    infrastructure for it.
    
    Let it rip!

diff --git a/drivers/scsi/sym53c8xx_2/sym_hipd.h b/drivers/scsi/sym53c8xx_2/sym_hipd.h
new file mode 100644
index 000000000000..a95cbe4b8e39
--- /dev/null
+++ b/drivers/scsi/sym53c8xx_2/sym_hipd.h
@@ -0,0 +1,1304 @@
+/*
+ * Device driver for the SYMBIOS/LSILOGIC 53C8XX and 53C1010 family 
+ * of PCI-SCSI IO processors.
+ *
+ * Copyright (C) 1999-2001  Gerard Roudier <groudier@free.fr>
+ *
+ * This driver is derived from the Linux sym53c8xx driver.
+ * Copyright (C) 1998-2000  Gerard Roudier
+ *
+ * The sym53c8xx driver is derived from the ncr53c8xx driver that had been 
+ * a port of the FreeBSD ncr driver to Linux-1.2.13.
+ *
+ * The original ncr driver has been written for 386bsd and FreeBSD by
+ *         Wolfgang Stanglmeier        <wolf@cologne.de>
+ *         Stefan Esser                <se@mi.Uni-Koeln.de>
+ * Copyright (C) 1994  Wolfgang Stanglmeier
+ *
+ * Other major contributions:
+ *
+ * NVRAM detection and reading.
+ * Copyright (C) 1997 Richard Waltham <dormouse@farsrobt.demon.co.uk>
+ *
+ *-----------------------------------------------------------------------------
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#ifndef SYM_HIPD_H
+#define SYM_HIPD_H
+
+/*
+ *  Generic driver options.
+ *
+ *  They may be defined in platform specific headers, if they 
+ *  are useful.
+ *
+ *    SYM_OPT_HANDLE_DIR_UNKNOWN
+ *        When this option is set, the SCRIPTS used by the driver 
+ *        are able to handle SCSI transfers with direction not 
+ *        supplied by user.
+ *        (set for Linux-2.0.X)
+ *
+ *    SYM_OPT_HANDLE_DEVICE_QUEUEING
+ *        When this option is set, the driver will use a queue per 
+ *        device and handle QUEUE FULL status requeuing internally.
+ *
+ *    SYM_OPT_LIMIT_COMMAND_REORDERING
+ *        When this option is set, the driver tries to limit tagged 
+ *        command reordering to some reasonnable value.
+ *        (set for Linux)
+ */
+#if 0
+#define SYM_OPT_HANDLE_DIR_UNKNOWN
+#define SYM_OPT_HANDLE_DEVICE_QUEUEING
+#define SYM_OPT_LIMIT_COMMAND_REORDERING
+#endif
+
+/*
+ *  Active debugging tags and verbosity.
+ *  Both DEBUG_FLAGS and sym_verbose can be redefined 
+ *  by the platform specific code to something else.
+ */
+#define DEBUG_ALLOC	(0x0001)
+#define DEBUG_PHASE	(0x0002)
+#define DEBUG_POLL	(0x0004)
+#define DEBUG_QUEUE	(0x0008)
+#define DEBUG_RESULT	(0x0010)
+#define DEBUG_SCATTER	(0x0020)
+#define DEBUG_SCRIPT	(0x0040)
+#define DEBUG_TINY	(0x0080)
+#define DEBUG_TIMING	(0x0100)
+#define DEBUG_NEGO	(0x0200)
+#define DEBUG_TAGS	(0x0400)
+#define DEBUG_POINTER	(0x0800)
+
+#ifndef DEBUG_FLAGS
+#define DEBUG_FLAGS	(0x0000)
+#endif
+
+#ifndef sym_verbose
+#define sym_verbose	(np->verbose)
+#endif
+
+/*
+ *  These ones should have been already defined.
+ */
+#ifndef assert
+#define	assert(expression) { \
+	if (!(expression)) { \
+		(void)panic( \
+			"assertion \"%s\" failed: file \"%s\", line %d\n", \
+			#expression, \
+			__FILE__, __LINE__); \
+	} \
+}
+#endif
+
+/*
+ *  Number of tasks per device we want to handle.
+ */
+#if	SYM_CONF_MAX_TAG_ORDER > 8
+#error	"more than 256 tags per logical unit not allowed."
+#endif
+#define	SYM_CONF_MAX_TASK	(1<<SYM_CONF_MAX_TAG_ORDER)
+
+/*
+ *  Donnot use more tasks that we can handle.
+ */
+#ifndef	SYM_CONF_MAX_TAG
+#define	SYM_CONF_MAX_TAG	SYM_CONF_MAX_TASK
+#endif
+#if	SYM_CONF_MAX_TAG > SYM_CONF_MAX_TASK
+#undef	SYM_CONF_MAX_TAG
+#define	SYM_CONF_MAX_TAG	SYM_CONF_MAX_TASK
+#endif
+
+/*
+ *    This one means 'NO TAG for this job'
+ */
+#define NO_TAG	(256)
+
+/*
+ *  Number of SCSI targets.
+ */
+#if	SYM_CONF_MAX_TARGET > 16
+#error	"more than 16 targets not allowed."
+#endif
+
+/*
+ *  Number of logical units per target.
+ */
+#if	SYM_CONF_MAX_LUN > 64
+#error	"more than 64 logical units per target not allowed."
+#endif
+
+/*
+ *    Asynchronous pre-scaler (ns). Shall be 40 for 
+ *    the SCSI timings to be compliant.
+ */
+#define	SYM_CONF_MIN_ASYNC (40)
+
+/*
+ *  Shortest memory chunk is (1<<SYM_MEM_SHIFT), currently 16.
+ *  Actual allocations happen as SYM_MEM_CLUSTER_SIZE sized.
+ *  (1 PAGE at a time is just fine).
+ */
+#define SYM_MEM_SHIFT	4
+#define SYM_MEM_CLUSTER_SIZE	(1UL << SYM_MEM_CLUSTER_SHIFT)
+#define SYM_MEM_CLUSTER_MASK	(SYM_MEM_CLUSTER_SIZE-1)
+
+/*
+ *  Number of entries in the START and DONE queues.
+ *
+ *  We limit to 1 PAGE in order to succeed allocation of 
+ *  these queues. Each entry is 8 bytes long (2 DWORDS).
+ */
+#ifdef	SYM_CONF_MAX_START
+#define	SYM_CONF_MAX_QUEUE (SYM_CONF_MAX_START+2)
+#else
+#define	SYM_CONF_MAX_QUEUE (7*SYM_CONF_MAX_TASK+2)
+#define	SYM_CONF_MAX_START (SYM_CONF_MAX_QUEUE-2)
+#endif
+
+#if	SYM_CONF_MAX_QUEUE > SYM_MEM_CLUSTER_SIZE/8
+#undef	SYM_CONF_MAX_QUEUE
+#define	SYM_CONF_MAX_QUEUE (SYM_MEM_CLUSTER_SIZE/8)
+#undef	SYM_CONF_MAX_START
+#define	SYM_CONF_MAX_START (SYM_CONF_MAX_QUEUE-2)
+#endif
+
+/*
+ *  For this one, we want a short name :-)
+ */
+#define MAX_QUEUE	SYM_CONF_MAX_QUEUE
+
+/*
+ *  Common definitions for both bus space based and legacy IO methods.
+ */
+
+#define INB_OFF(np, o)		ioread8(np->s.ioaddr + (o))
+#define INW_OFF(np, o)		ioread16(np->s.ioaddr + (o))
+#define INL_OFF(np, o)		ioread32(np->s.ioaddr + (o))
+
+#define OUTB_OFF(np, o, val)	iowrite8((val), np->s.ioaddr + (o))
+#define OUTW_OFF(np, o, val)	iowrite16((val), np->s.ioaddr + (o))
+#define OUTL_OFF(np, o, val)	iowrite32((val), np->s.ioaddr + (o))
+
+#define INB(np, r)		INB_OFF(np, offsetof(struct sym_reg, r))
+#define INW(np, r)		INW_OFF(np, offsetof(struct sym_reg, r))
+#define INL(np, r)		INL_OFF(np, offsetof(struct sym_reg, r))
+
+#define OUTB(np, r, v)		OUTB_OFF(np, offsetof(struct sym_reg, r), (v))
+#define OUTW(np, r, v)		OUTW_OFF(np, offsetof(struct sym_reg, r), (v))
+#define OUTL(np, r, v)		OUTL_OFF(np, offsetof(struct sym_reg, r), (v))
+
+#define OUTONB(np, r, m)	OUTB(np, r, INB(np, r) | (m))
+#define OUTOFFB(np, r, m)	OUTB(np, r, INB(np, r) & ~(m))
+#define OUTONW(np, r, m)	OUTW(np, r, INW(np, r) | (m))
+#define OUTOFFW(np, r, m)	OUTW(np, r, INW(np, r) & ~(m))
+#define OUTONL(np, r, m)	OUTL(np, r, INL(np, r) | (m))
+#define OUTOFFL(np, r, m)	OUTL(np, r, INL(np, r) & ~(m))
+
+/*
+ *  We normally want the chip to have a consistent view
+ *  of driver internal data structures when we restart it.
+ *  Thus these macros.
+ */
+#define OUTL_DSP(np, v)				\
+	do {					\
+		MEMORY_WRITE_BARRIER();		\
+		OUTL(np, nc_dsp, (v));		\
+	} while (0)
+
+#define OUTONB_STD()				\
+	do {					\
+		MEMORY_WRITE_BARRIER();		\
+		OUTONB(np, nc_dcntl, (STD|NOCOM));	\
+	} while (0)
+
+/*
+ *  Command control block states.
+ */
+#define HS_IDLE		(0)
+#define HS_BUSY		(1)
+#define HS_NEGOTIATE	(2)	/* sync/wide data transfer*/
+#define HS_DISCONNECT	(3)	/* Disconnected by target */
+#define HS_WAIT		(4)	/* waiting for resource	  */
+
+#define HS_DONEMASK	(0x80)
+#define HS_COMPLETE	(4|HS_DONEMASK)
+#define HS_SEL_TIMEOUT	(5|HS_DONEMASK)	/* Selection timeout      */
+#define HS_UNEXPECTED	(6|HS_DONEMASK)	/* Unexpected disconnect  */
+#define HS_COMP_ERR	(7|HS_DONEMASK)	/* Completed with error	  */
+
+/*
+ *  Software Interrupt Codes
+ */
+#define	SIR_BAD_SCSI_STATUS	(1)
+#define	SIR_SEL_ATN_NO_MSG_OUT	(2)
+#define	SIR_MSG_RECEIVED	(3)
+#define	SIR_MSG_WEIRD		(4)
+#define	SIR_NEGO_FAILED		(5)
+#define	SIR_NEGO_PROTO		(6)
+#define	SIR_SCRIPT_STOPPED	(7)
+#define	SIR_REJECT_TO_SEND	(8)
+#define	SIR_SWIDE_OVERRUN	(9)
+#define	SIR_SODL_UNDERRUN	(10)
+#define	SIR_RESEL_NO_MSG_IN	(11)
+#define	SIR_RESEL_NO_IDENTIFY	(12)
+#define	SIR_RESEL_BAD_LUN	(13)
+#define	SIR_TARGET_SELECTED	(14)
+#define	SIR_RESEL_BAD_I_T_L	(15)
+#define	SIR_RESEL_BAD_I_T_L_Q	(16)
+#define	SIR_ABORT_SENT		(17)
+#define	SIR_RESEL_ABORTED	(18)
+#define	SIR_MSG_OUT_DONE	(19)
+#define	SIR_COMPLETE_ERROR	(20)
+#define	SIR_DATA_OVERRUN	(21)
+#define	SIR_BAD_PHASE		(22)
+#if	SYM_CONF_DMA_ADDRESSING_MODE == 2
+#define	SIR_DMAP_DIRTY		(23)
+#define	SIR_MAX			(23)
+#else
+#define	SIR_MAX			(22)
+#endif
+
+/*
+ *  Extended error bit codes.
+ *  xerr_status field of struct sym_ccb.
+ */
+#define	XE_EXTRA_DATA	(1)	/* unexpected data phase	 */
+#define	XE_BAD_PHASE	(1<<1)	/* illegal phase (4/5)		 */
+#define	XE_PARITY_ERR	(1<<2)	/* unrecovered SCSI parity error */
+#define	XE_SODL_UNRUN	(1<<3)	/* ODD transfer in DATA OUT phase */
+#define	XE_SWIDE_OVRUN	(1<<4)	/* ODD transfer in DATA IN phase */
+
+/*
+ *  Negotiation status.
+ *  nego_status field of struct sym_ccb.
+ */
+#define NS_SYNC		(1)
+#define NS_WIDE		(2)
+#define NS_PPR		(3)
+
+/*
+ *  A CCB hashed table is used to retrieve CCB address 
+ *  from DSA value.
+ */
+#define CCB_HASH_SHIFT		8
+#define CCB_HASH_SIZE		(1UL << CCB_HASH_SHIFT)
+#define CCB_HASH_MASK		(CCB_HASH_SIZE-1)
+#if 1
+#define CCB_HASH_CODE(dsa)	\
+	(((dsa) >> (_LGRU16_(sizeof(struct sym_ccb)))) & CCB_HASH_MASK)
+#else
+#define CCB_HASH_CODE(dsa)	(((dsa) >> 9) & CCB_HASH_MASK)
+#endif
+
+#if	SYM_CONF_DMA_ADDRESSING_MODE == 2
+/*
+ *  We may want to use segment registers for 64 bit DMA.
+ *  16 segments registers -> up to 64 GB addressable.
+ */
+#define SYM_DMAP_SHIFT	(4)
+#define SYM_DMAP_SIZE	(1u<<SYM_DMAP_SHIFT)
+#define SYM_DMAP_MASK	(SYM_DMAP_SIZE-1)
+#endif
+
+/*
+ *  Device flags.
+ */
+#define SYM_DISC_ENABLED	(1)
+#define SYM_TAGS_ENABLED	(1<<1)
+#define SYM_SCAN_BOOT_DISABLED	(1<<2)
+#define SYM_SCAN_LUNS_DISABLED	(1<<3)
+
+/*
+ *  Host adapter miscellaneous flags.
+ */
+#define SYM_AVOID_BUS_RESET	(1)
+
+/*
+ *  Misc.
+ */
+#define SYM_SNOOP_TIMEOUT (10000000)
+#define BUS_8_BIT	0
+#define BUS_16_BIT	1
+
+/*
+ *  Gather negotiable parameters value
+ */
+struct sym_trans {
+	u8 period;
+	u8 offset;
+	unsigned int width:1;
+	unsigned int iu:1;
+	unsigned int dt:1;
+	unsigned int qas:1;
+	unsigned int check_nego:1;
+};
+
+/*
+ *  Global TCB HEADER.
+ *
+ *  Due to lack of indirect addressing on earlier NCR chips,
+ *  this substructure is copied from the TCB to a global 
+ *  address after selection.
+ *  For SYMBIOS chips that support LOAD/STORE this copy is 
+ *  not needed and thus not performed.
+ */
+struct sym_tcbh {
+	/*
+	 *  Scripts bus addresses of LUN table accessed from scripts.
+	 *  LUN #0 is a special case, since multi-lun devices are rare, 
+	 *  and we we want to speed-up the general case and not waste 
+	 *  resources.
+	 */
+	u32	luntbl_sa;	/* bus address of this table	*/
+	u32	lun0_sa;	/* bus address of LCB #0	*/
+	/*
+	 *  Actual SYNC/WIDE IO registers value for this target.
+	 *  'sval', 'wval' and 'uval' are read from SCRIPTS and 
+	 *  so have alignment constraints.
+	 */
+/*0*/	u_char	uval;		/* -> SCNTL4 register		*/
+/*1*/	u_char	sval;		/* -> SXFER  io register	*/
+/*2*/	u_char	filler1;
+/*3*/	u_char	wval;		/* -> SCNTL3 io register	*/
+};
+
+/*
+ *  Target Control Block
+ */
+struct sym_tcb {
+	/*
+	 *  TCB header.
+	 *  Assumed at offset 0.
+	 */
+/*0*/	struct sym_tcbh head;
+
+	/*
+	 *  LUN table used by the SCRIPTS processor.
+	 *  An array of bus addresses is used on reselection.
+	 */
+	u32	*luntbl;	/* LCBs bus address table	*/
+
+	/*
+	 *  LUN table used by the C code.
+	 */
+	struct sym_lcb *lun0p;		/* LCB of LUN #0 (usual case)	*/
+#if SYM_CONF_MAX_LUN > 1
+	struct sym_lcb **lunmp;		/* Other LCBs [1..MAX_LUN]	*/
+#endif
+
+	/*
+	 *  Bitmap that tells about LUNs that succeeded at least 
+	 *  1 IO and therefore assumed to be a real device.
+	 *  Avoid useless allocation of the LCB structure.
+	 */
+	u32	lun_map[(SYM_CONF_MAX_LUN+31)/32];
+
+	/*
+	 *  Bitmap that tells about LUNs that haven't yet an LCB 
+	 *  allocated (not discovered or LCB allocation failed).
+	 */
+	u32	busy0_map[(SYM_CONF_MAX_LUN+31)/32];
+
+#ifdef	SYM_HAVE_STCB
+	/*
+	 *  O/S specific data structure.
+	 */
+	struct sym_stcb s;
+#endif
+
+	/* Transfer goal */
+	struct sym_trans tgoal;
+
+	/*
+	 * Keep track of the CCB used for the negotiation in order
+	 * to ensure that only 1 negotiation is queued at a time.
+	 */
+	struct sym_ccb *  nego_cp;	/* CCB used for the nego		*/
+
+	/*
+	 *  Set when we want to reset the device.
+	 */
+	u_char	to_reset;
+
+	/*
+	 *  Other user settable limits and options.
+	 *  These limits are read from the NVRAM if present.
+	 */
+	u_char	usrflags;
+	u_short	usrtags;
+	struct scsi_device *sdev;
+};
+
+/*
+ *  Global LCB HEADER.
+ *
+ *  Due to lack of indirect addressing on earlier NCR chips,
+ *  this substructure is copied from the LCB to a global 
+ *  address after selection.
+ *  For SYMBIOS chips that support LOAD/STORE this copy is 
+ *  not needed and thus not performed.
+ */
+struct sym_lcbh {
+	/*
+	 *  SCRIPTS address jumped by SCRIPTS on reselection.
+	 *  For not probed logical units, this address points to 
+	 *  SCRIPTS that deal with bad LU handling (must be at 
+	 *  offset zero of the LCB for that reason).
+	 */
+/*0*/	u32	resel_sa;
+
+	/*
+	 *  Task (bus address of a CCB) read from SCRIPTS that points 
+	 *  to the unique ITL nexus allowed to be disconnected.
+	 */
+	u32	itl_task_sa;
+
+	/*
+	 *  Task table bus address (read from SCRIPTS).
+	 */
+	u32	itlq_tbl_sa;
+};
+
+/*
+ *  Logical Unit Control Block
+ */
+struct sym_lcb {
+	/*
+	 *  TCB header.
+	 *  Assumed at offset 0.
+	 */
+/*0*/	struct sym_lcbh head;
+
+	/*
+	 *  Task table read from SCRIPTS that contains pointers to 
+	 *  ITLQ nexuses. The bus address read from SCRIPTS is 
+	 *  inside the header.
+	 */
+	u32	*itlq_tbl;	/* Kernel virtual address	*/
+
+	/*
+	 *  Busy CCBs management.
+	 */
+	u_short	busy_itlq;	/* Number of busy tagged CCBs	*/
+	u_short	busy_itl;	/* Number of busy untagged CCBs	*/
+
+	/*
+	 *  Circular tag allocation buffer.
+	 */
+	u_short	ia_tag;		/* Tag allocation index		*/
+	u_short	if_tag;		/* Tag release index		*/
+	u_char	*cb_tags;	/* Circular tags buffer		*/
+
+	/*
+	 *  O/S specific data structure.
+	 */
+#ifdef	SYM_HAVE_SLCB
+	struct sym_slcb s;
+#endif
+
+#ifdef SYM_OPT_HANDLE_DEVICE_QUEUEING
+	/*
+	 *  Optionnaly the driver can handle device queueing, 
+	 *  and requeues internally command to redo.
+	 */
+	SYM_QUEHEAD waiting_ccbq;
+	SYM_QUEHEAD started_ccbq;
+	int	num_sgood;
+	u_short	started_tags;
+	u_short	started_no_tag;
+	u_short	started_max;
+	u_short	started_limit;
+#endif
+
+#ifdef SYM_OPT_LIMIT_COMMAND_REORDERING
+	/*
+	 *  Optionally the driver can try to prevent SCSI 
+	 *  IOs from being reordered too much.
+	 */
+	u_char		tags_si;	/* Current index to tags sum	*/
+	u_short		tags_sum[2];	/* Tags sum counters		*/
+	u_short		tags_since;	/* # of tags since last switch	*/
+#endif
+
+	/*
+	 *  Set when we want to clear all tasks.
+	 */
+	u_char to_clear;
+
+	/*
+	 *  Capabilities.
+	 */
+	u_char	user_flags;
+	u_char	curr_flags;
+};
+
+/*
+ *  Action from SCRIPTS on a task.
+ *  Is part of the CCB, but is also used separately to plug 
+ *  error handling action to perform from SCRIPTS.
+ */
+struct sym_actscr {
+	u32	start;		/* Jumped by SCRIPTS after selection	*/
+	u32	restart;	/* Jumped by SCRIPTS on relection	*/
+};
+
+/*
+ *  Phase mismatch context.
+ *
+ *  It is part of the CCB and is used as parameters for the 
+ *  DATA pointer. We need two contexts to handle correctly the 
+ *  SAVED DATA POINTER.
+ */
+struct sym_pmc {
+	struct	sym_tblmove sg;	/* Updated interrupted SG block	*/
+	u32	ret;		/* SCRIPT return address	*/
+};
+
+/*
+ *  LUN control block lookup.
+ *  We use a direct pointer for LUN #0, and a table of 
+ *  pointers which is only allocated for devices that support 
+ *  LUN(s) > 0.
+ */
+#if SYM_CONF_MAX_LUN <= 1
+#define sym_lp(tp, lun) (!lun) ? (tp)->lun0p : NULL
+#else
+#define sym_lp(tp, lun) \
+	(!lun) ? (tp)->lun0p : (tp)->lunmp ? (tp)->lunmp[(lun)] : NULL
+#endif
+
+/*
+ *  Status are used by the host and the script processor.
+ *
+ *  The last four bytes (status[4]) are copied to the 
+ *  scratchb register (declared as scr0..scr3) just after the 
+ *  select/reselect, and copied back just after disconnecting.
+ *  Inside the script the XX_REG are used.
+ */
+
+/*
+ *  Last four bytes (script)
+ */
+#define  HX_REG	scr0
+#define  HX_PRT	nc_scr0
+#define  HS_REG	scr1
+#define  HS_PRT	nc_scr1
+#define  SS_REG	scr2
+#define  SS_PRT	nc_scr2
+#define  HF_REG	scr3
+#define  HF_PRT	nc_scr3
+
+/*
+ *  Last four bytes (host)
+ */
+#define  host_xflags   phys.head.status[0]
+#define  host_status   phys.head.status[1]
+#define  ssss_status   phys.head.status[2]
+#define  host_flags    phys.head.status[3]
+
+/*
+ *  Host flags
+ */
+#define HF_IN_PM0	1u
+#define HF_IN_PM1	(1u<<1)
+#define HF_ACT_PM	(1u<<2)
+#define HF_DP_SAVED	(1u<<3)
+#define HF_SENSE	(1u<<4)
+#define HF_EXT_ERR	(1u<<5)
+#define HF_DATA_IN	(1u<<6)
+#ifdef SYM_CONF_IARB_SUPPORT
+#define HF_HINT_IARB	(1u<<7)
+#endif
+
+/*
+ *  More host flags
+ */
+#if	SYM_CONF_DMA_ADDRESSING_MODE == 2
+#define	HX_DMAP_DIRTY	(1u<<7)
+#endif
+
+/*
+ *  Global CCB HEADER.
+ *
+ *  Due to lack of indirect addressing on earlier NCR chips,
+ *  this substructure is copied from the ccb to a global 
+ *  address after selection (or reselection) and copied back 
+ *  before disconnect.
+ *  For SYMBIOS chips that support LOAD/STORE this copy is 
+ *  not needed and thus not performed.
+ */
+
+struct sym_ccbh {
+	/*
+	 *  Start and restart SCRIPTS addresses (must be at 0).
+	 */
+/*0*/	struct sym_actscr go;
+
+	/*
+	 *  SCRIPTS jump address that deal with data pointers.
+	 *  'savep' points to the position in the script responsible 
+	 *  for the actual transfer of data.
+	 *  It's written on reception of a SAVE_DATA_POINTER message.
+	 */
+	u32	savep;		/* Jump address to saved data pointer	*/
+	u32	lastp;		/* SCRIPTS address at end of data	*/
+#ifdef	SYM_OPT_HANDLE_DIR_UNKNOWN
+	u32	wlastp;
+#endif
+
+	/*
+	 *  Status fields.
+	 */
+	u8	status[4];
+};
+
+/*
+ *  GET/SET the value of the data pointer used by SCRIPTS.
+ *
+ *  We must distinguish between the LOAD/STORE-based SCRIPTS 
+ *  that use directly the header in the CCB, and the NCR-GENERIC 
+ *  SCRIPTS that use the copy of the header in the HCB.
+ */
+#if	SYM_CONF_GENERIC_SUPPORT
+#define sym_set_script_dp(np, cp, dp)				\
+	do {							\
+		if (np->features & FE_LDSTR)			\
+			cp->phys.head.lastp = cpu_to_scr(dp);	\
+		else						\
+			np->ccb_head.lastp = cpu_to_scr(dp);	\
+	} while (0)
+#define sym_get_script_dp(np, cp) 				\
+	scr_to_cpu((np->features & FE_LDSTR) ?			\
+		cp->phys.head.lastp : np->ccb_head.lastp)
+#else
+#define sym_set_script_dp(np, cp, dp)				\
+	do {							\
+		cp->phys.head.lastp = cpu_to_scr(dp);		\
+	} while (0)
+
+#define sym_get_script_dp(np, cp) (cp->phys.head.lastp)
+#endif
+
+/*
+ *  Data Structure Block
+ *
+ *  During execution of a ccb by the script processor, the 
+ *  DSA (data structure address) register points to this 
+ *  substructure of the ccb.
+ */
+struct sym_dsb {
+	/*
+	 *  CCB header.
+	 *  Also assumed at offset 0 of the sym_ccb structure.
+	 */
+/*0*/	struct sym_ccbh head;
+
+	/*
+	 *  Phase mismatch contexts.
+	 *  We need two to handle correctly the SAVED DATA POINTER.
+	 *  MUST BOTH BE AT OFFSET < 256, due to using 8 bit arithmetic 
+	 *  for address calculation from SCRIPTS.
+	 */
+	struct sym_pmc pm0;
+	struct sym_pmc pm1;
+
+	/*
+	 *  Table data for Script
+	 */
+	struct sym_tblsel  select;
+	struct sym_tblmove smsg;
+	struct sym_tblmove smsg_ext;
+	struct sym_tblmove cmd;
+	struct sym_tblmove sense;
+	struct sym_tblmove wresid;
+	struct sym_tblmove data [SYM_CONF_MAX_SG];
+};
+
+/*
+ *  Our Command Control Block
+ */
+struct sym_ccb {
+	/*
+	 *  This is the data structure which is pointed by the DSA 
+	 *  register when it is executed by the script processor.
+	 *  It must be the first entry.
+	 */
+	struct sym_dsb phys;
+
+	/*
+	 *  Pointer to CAM ccb and related stuff.
+	 */
+	struct scsi_cmnd *cmd;	/* CAM scsiio ccb		*/
+	u8	cdb_buf[16];	/* Copy of CDB			*/
+#define	SYM_SNS_BBUF_LEN 32
+	u8	sns_bbuf[SYM_SNS_BBUF_LEN]; /* Bounce buffer for sense data */
+	int	data_len;	/* Total data length		*/
+	int	segments;	/* Number of SG segments	*/
+
+	u8	order;		/* Tag type (if tagged command)	*/
+
+	/*
+	 *  Miscellaneous status'.
+	 */
+	u_char	nego_status;	/* Negotiation status		*/
+	u_char	xerr_status;	/* Extended error flags		*/
+	u32	extra_bytes;	/* Extraneous bytes transferred	*/
+
+	/*
+	 *  Message areas.
+	 *  We prepare a message to be sent after selection.
+	 *  We may use a second one if the command is rescheduled 
+	 *  due to CHECK_CONDITION or COMMAND TERMINATED.
+	 *  Contents are IDENTIFY and SIMPLE_TAG.
+	 *  While negotiating sync or wide transfer,
+	 *  a SDTR or WDTR message is appended.
+	 */
+	u_char	scsi_smsg [12];
+	u_char	scsi_smsg2[12];
+
+	/*
+	 *  Auto request sense related fields.
+	 */
+	u_char	sensecmd[6];	/* Request Sense command	*/
+	u_char	sv_scsi_status;	/* Saved SCSI status 		*/
+	u_char	sv_xerr_status;	/* Saved extended status	*/
+	int	sv_resid;	/* Saved residual		*/
+
+	/*
+	 *  Other fields.
+	 */
+	u32	ccb_ba;		/* BUS address of this CCB	*/
+	u_short	tag;		/* Tag for this transfer	*/
+				/*  NO_TAG means no tag		*/
+	u_char	target;
+	u_char	lun;
+	struct sym_ccb *link_ccbh;	/* Host adapter CCB hash chain	*/
+	SYM_QUEHEAD link_ccbq;	/* Link to free/busy CCB queue	*/
+	u32	startp;		/* Initial data pointer		*/
+	u32	goalp;		/* Expected last data pointer	*/
+#ifdef	SYM_OPT_HANDLE_DIR_UNKNOWN
+	u32	wgoalp;
+#endif
+	int	ext_sg;		/* Extreme data pointer, used	*/
+	int	ext_ofs;	/*  to calculate the residual.	*/
+#ifdef SYM_OPT_HANDLE_DEVICE_QUEUEING
+	SYM_QUEHEAD link2_ccbq;	/* Link for device queueing	*/
+	u_char	started;	/* CCB queued to the squeue	*/
+#endif
+	u_char	to_abort;	/* Want this IO to be aborted	*/
+#ifdef SYM_OPT_LIMIT_COMMAND_REORDERING
+	u_char	tags_si;	/* Lun tags sum index (0,1)	*/
+#endif
+};
+
+#define CCB_BA(cp,lbl)	(cp->ccb_ba + offsetof(struct sym_ccb, lbl))
+
+#ifdef	SYM_OPT_HANDLE_DIR_UNKNOWN
+#define	sym_goalp(cp) ((cp->host_flags & HF_DATA_IN) ? cp->goalp : cp->wgoalp)
+#else
+#define	sym_goalp(cp) (cp->goalp)
+#endif
+
+typedef struct device *m_pool_ident_t;
+
+/*
+ *  Host Control Block
+ */
+struct sym_hcb {
+	/*
+	 *  Global headers.
+	 *  Due to poorness of addressing capabilities, earlier 
+	 *  chips (810, 815, 825) copy part of the data structures 
+	 *  (CCB, TCB and LCB) in fixed areas.
+	 */
+#if	SYM_CONF_GENERIC_SUPPORT
+	struct sym_ccbh	ccb_head;
+	struct sym_tcbh	tcb_head;
+	struct sym_lcbh	lcb_head;
+#endif
+	/*
+	 *  Idle task and invalid task actions and 
+	 *  their bus addresses.
+	 */
+	struct sym_actscr idletask, notask, bad_itl, bad_itlq;
+	u32 idletask_ba, notask_ba, bad_itl_ba, bad_itlq_ba;
+
+	/*
+	 *  Dummy lun table to protect us against target 
+	 *  returning bad lun number on reselection.
+	 */
+	u32	*badluntbl;	/* Table physical address	*/
+	u32	badlun_sa;	/* SCRIPT handler BUS address	*/
+
+	/*
+	 *  Bus address of this host control block.
+	 */
+	u32	hcb_ba;
+
+	/*
+	 *  Bit 32-63 of the on-chip RAM bus address in LE format.
+	 *  The START_RAM64 script loads the MMRS and MMWS from this 
+	 *  field.
+	 */
+	u32	scr_ram_seg;
+
+	/*
+	 *  Initial value of some IO register bits.
+	 *  These values are assumed to have been set by BIOS, and may 
+	 *  be used to probe adapter implementation differences.
+	 */
+	u_char	sv_scntl0, sv_scntl3, sv_dmode, sv_dcntl, sv_ctest3, sv_ctest4,
+		sv_ctest5, sv_gpcntl, sv_stest2, sv_stest4, sv_scntl4,
+		sv_stest1;
+
+	/*
+	 *  Actual initial value of IO register bits used by the 
+	 *  driver. They are loaded at initialisation according to  
+	 *  features that are to be enabled/disabled.
+	 */
+	u_char	rv_scntl0, rv_scntl3, rv_dmode, rv_dcntl, rv_ctest3, rv_ctest4, 
+		rv_ctest5, rv_stest2, rv_ccntl0, rv_ccntl1, rv_scntl4;
+
+	/*
+	 *  Target data.
+	 */
+	struct sym_tcb	target[SYM_CONF_MAX_TARGET];
+
+	/*
+	 *  Target control block bus address array used by the SCRIPT 
+	 *  on reselection.
+	 */
+	u32		*targtbl;
+	u32		targtbl_ba;
+
+	/*
+	 *  DMA pool handle for this HBA.
+	 */
+	m_pool_ident_t	bus_dmat;
+
+	/*
+	 *  O/S specific data structure
+	 */
+	struct sym_shcb s;
+
+	/*
+	 *  Physical bus addresses of the chip.
+	 */
+	u32		mmio_ba;	/* MMIO 32 bit BUS address	*/
+	int		mmio_ws;	/* MMIO Window size		*/
+
+	u32		ram_ba;		/* RAM 32 bit BUS address	*/
+	int		ram_ws;		/* RAM window size		*/
+
+	/*
+	 *  SCRIPTS virtual and physical bus addresses.
+	 *  'script'  is loaded in the on-chip RAM if present.
+	 *  'scripth' stays in main memory for all chips except the 
+	 *  53C895A, 53C896 and 53C1010 that provide 8K on-chip RAM.
+	 */
+	u_char		*scripta0;	/* Copy of scripts A, B, Z	*/
+	u_char		*scriptb0;
+	u_char		*scriptz0;
+	u32		scripta_ba;	/* Actual scripts A, B, Z	*/
+	u32		scriptb_ba;	/* 32 bit bus addresses.	*/
+	u32		scriptz_ba;
+	u_short		scripta_sz;	/* Actual size of script A, B, Z*/
+	u_short		scriptb_sz;
+	u_short		scriptz_sz;
+
+	/*
+	 *  Bus addresses, setup and patch methods for 
+	 *  the selected firmware.
+	 */
+	struct sym_fwa_ba fwa_bas;	/* Useful SCRIPTA bus addresses	*/
+	struct sym_fwb_ba fwb_bas;	/* Useful SCRIPTB bus addresses	*/
+	struct sym_fwz_ba fwz_bas;	/* Useful SCRIPTZ bus addresses	*/
+	void		(*fw_setup)(struct sym_hcb *np, struct sym_fw *fw);
+	void		(*fw_patch)(struct sym_hcb *np);
+	char		*fw_name;
+
+	/*
+	 *  General controller parameters and configuration.
+	 */
+	u_short	device_id;	/* PCI device id		*/
+	u_char	revision_id;	/* PCI device revision id	*/
+	u_int	features;	/* Chip features map		*/
+	u_char	myaddr;		/* SCSI id of the adapter	*/
+	u_char	maxburst;	/* log base 2 of dwords burst	*/
+	u_char	maxwide;	/* Maximum transfer width	*/
+	u_char	minsync;	/* Min sync period factor (ST)	*/
+	u_char	maxsync;	/* Max sync period factor (ST)	*/
+	u_char	maxoffs;	/* Max scsi offset        (ST)	*/
+	u_char	minsync_dt;	/* Min sync period factor (DT)	*/
+	u_char	maxsync_dt;	/* Max sync period factor (DT)	*/
+	u_char	maxoffs_dt;	/* Max scsi offset        (DT)	*/
+	u_char	multiplier;	/* Clock multiplier (1,2,4)	*/
+	u_char	clock_divn;	/* Number of clock divisors	*/
+	u32	clock_khz;	/* SCSI clock frequency in KHz	*/
+	u32	pciclk_khz;	/* Estimated PCI clock  in KHz	*/
+	/*
+	 *  Start queue management.
+	 *  It is filled up by the host processor and accessed by the 
+	 *  SCRIPTS processor in order to start SCSI commands.
+	 */
+	volatile		/* Prevent code optimizations	*/
+	u32	*squeue;	/* Start queue virtual address	*/
+	u32	squeue_ba;	/* Start queue BUS address	*/
+	u_short	squeueput;	/* Next free slot of the queue	*/
+	u_short	actccbs;	/* Number of allocated CCBs	*/
+
+	/*
+	 *  Command completion queue.
+	 *  It is the same size as the start queue to avoid overflow.
+	 */
+	u_short	dqueueget;	/* Next position to scan	*/
+	volatile		/* Prevent code optimizations	*/
+	u32	*dqueue;	/* Completion (done) queue	*/
+	u32	dqueue_ba;	/* Done queue BUS address	*/
+
+	/*
+	 *  Miscellaneous buffers accessed by the scripts-processor.
+	 *  They shall be DWORD aligned, because they may be read or 
+	 *  written with a script command.
+	 */
+	u_char		msgout[8];	/* Buffer for MESSAGE OUT 	*/
+	u_char		msgin [8];	/* Buffer for MESSAGE IN	*/
+	u32		lastmsg;	/* Last SCSI message sent	*/
+	u32		scratch;	/* Scratch for SCSI receive	*/
+					/* Also used for cache test 	*/
+	/*
+	 *  Miscellaneous configuration and status parameters.
+	 */
+	u_char		usrflags;	/* Miscellaneous user flags	*/
+	u_char		scsi_mode;	/* Current SCSI BUS mode	*/
+	u_char		verbose;	/* Verbosity for this controller*/
+
+	/*
+	 *  CCB lists and queue.
+	 */
+	struct sym_ccb **ccbh;			/* CCBs hashed by DSA value	*/
+					/* CCB_HASH_SIZE lists of CCBs	*/
+	SYM_QUEHEAD	free_ccbq;	/* Queue of available CCBs	*/
+	SYM_QUEHEAD	busy_ccbq;	/* Queue of busy CCBs		*/
+
+	/*
+	 *  During error handling and/or recovery,
+	 *  active CCBs that are to be completed with 
+	 *  error or requeued are moved from the busy_ccbq
+	 *  to the comp_ccbq prior to completion.
+	 */
+	SYM_QUEHEAD	comp_ccbq;
+
+#ifdef SYM_OPT_HANDLE_DEVICE_QUEUEING
+	SYM_QUEHEAD	dummy_ccbq;
+#endif
+
+	/*
+	 *  IMMEDIATE ARBITRATION (IARB) control.
+	 *
+	 *  We keep track in 'last_cp' of the last CCB that has been 
+	 *  queued to the SCRIPTS processor and clear 'last_cp' when 
+	 *  this CCB completes. If last_cp is not zero at the moment 
+	 *  we queue a new CCB, we set a flag in 'last_cp' that is 
+	 *  used by the SCRIPTS as a hint for setting IARB.
+	 *  We donnot set more than 'iarb_max' consecutive hints for 
+	 *  IARB in order to leave devices a chance to reselect.
+	 *  By the way, any non zero value of 'iarb_max' is unfair. :)
+	 */
+#ifdef SYM_CONF_IARB_SUPPORT
+	u_short		iarb_max;	/* Max. # consecutive IARB hints*/
+	u_short		iarb_count;	/* Actual # of these hints	*/
+	struct sym_ccb *	last_cp;
+#endif
+
+	/*
+	 *  Command abort handling.
+	 *  We need to synchronize tightly with the SCRIPTS 
+	 *  processor in order to handle things correctly.
+	 */
+	u_char		abrt_msg[4];	/* Message to send buffer	*/
+	struct sym_tblmove abrt_tbl;	/* Table for the MOV of it 	*/
+	struct sym_tblsel  abrt_sel;	/* Sync params for selection	*/
+	u_char		istat_sem;	/* Tells the chip to stop (SEM)	*/
+
+	/*
+	 *  64 bit DMA handling.
+	 */
+#if	SYM_CONF_DMA_ADDRESSING_MODE != 0
+	u_char	use_dac;		/* Use PCI DAC cycles		*/
+#if	SYM_CONF_DMA_ADDRESSING_MODE == 2
+	u_char	dmap_dirty;		/* Dma segments registers dirty	*/
+	u32	dmap_bah[SYM_DMAP_SIZE];/* Segment registers map	*/
+#endif
+#endif
+};
+
+#define HCB_BA(np, lbl)	(np->hcb_ba + offsetof(struct sym_hcb, lbl))
+
+
+/*
+ *  FIRMWARES (sym_fw.c)
+ */
+struct sym_fw * sym_find_firmware(struct sym_chip *chip);
+void sym_fw_bind_script(struct sym_hcb *np, u32 *start, int len);
+
+/*
+ *  Driver methods called from O/S specific code.
+ */
+char *sym_driver_name(void);
+void sym_print_xerr(struct scsi_cmnd *cmd, int x_status);
+int sym_reset_scsi_bus(struct sym_hcb *np, int enab_int);
+struct sym_chip *sym_lookup_chip_table(u_short device_id, u_char revision);
+void sym_put_start_queue(struct sym_hcb *np, struct sym_ccb *cp);
+#ifdef SYM_OPT_HANDLE_DEVICE_QUEUEING
+void sym_start_next_ccbs(struct sym_hcb *np, struct sym_lcb *lp, int maxn);
+#endif
+void sym_start_up(struct sym_hcb *np, int reason);
+void sym_interrupt(struct sym_hcb *np);
+int sym_clear_tasks(struct sym_hcb *np, int cam_status, int target, int lun, int task);
+struct sym_ccb *sym_get_ccb(struct sym_hcb *np, struct scsi_cmnd *cmd, u_char tag_order);
+void sym_free_ccb(struct sym_hcb *np, struct sym_ccb *cp);
+struct sym_lcb *sym_alloc_lcb(struct sym_hcb *np, u_char tn, u_char ln);
+int sym_queue_scsiio(struct sym_hcb *np, struct scsi_cmnd *csio, struct sym_ccb *cp);
+int sym_abort_scsiio(struct sym_hcb *np, struct scsi_cmnd *ccb, int timed_out);
+int sym_reset_scsi_target(struct sym_hcb *np, int target);
+void sym_hcb_free(struct sym_hcb *np);
+int sym_hcb_attach(struct Scsi_Host *shost, struct sym_fw *fw, struct sym_nvram *nvram);
+
+/*
+ *  Build a scatter/gather entry.
+ *
+ *  For 64 bit systems, we use the 8 upper bits of the size field 
+ *  to provide bus address bits 32-39 to the SCRIPTS processor.
+ *  This allows the 895A, 896, 1010 to address up to 1 TB of memory.
+ */
+
+#if   SYM_CONF_DMA_ADDRESSING_MODE == 0
+#define sym_build_sge(np, data, badd, len)	\
+do {						\
+	(data)->addr = cpu_to_scr(badd);	\
+	(data)->size = cpu_to_scr(len);		\
+} while (0)
+#elif SYM_CONF_DMA_ADDRESSING_MODE == 1
+#define sym_build_sge(np, data, badd, len)				\
+do {									\
+	(data)->addr = cpu_to_scr(badd);				\
+	(data)->size = cpu_to_scr((((badd) >> 8) & 0xff000000) + len);	\
+} while (0)
+#elif SYM_CONF_DMA_ADDRESSING_MODE == 2
+int sym_lookup_dmap(struct sym_hcb *np, u32 h, int s);
+static __inline void 
+sym_build_sge(struct sym_hcb *np, struct sym_tblmove *data, u64 badd, int len)
+{
+	u32 h = (badd>>32);
+	int s = (h&SYM_DMAP_MASK);
+
+	if (h != np->dmap_bah[s])
+		goto bad;
+good:
+	(data)->addr = cpu_to_scr(badd);
+	(data)->size = cpu_to_scr((s<<24) + len);
+	return;
+bad:
+	s = sym_lookup_dmap(np, h, s);
+	goto good;
+}
+#else
+#error "Unsupported DMA addressing mode"
+#endif
+
+/*
+ *  Set up data pointers used by SCRIPTS.
+ *  Called from O/S specific code.
+ */
+static inline void sym_setup_data_pointers(struct sym_hcb *np,
+		struct sym_ccb *cp, int dir)
+{
+	u32 lastp, goalp;
+
+	/*
+	 *  No segments means no data.
+	 */
+	if (!cp->segments)
+		dir = CAM_DIR_NONE;
+
+	/*
+	 *  Set the data pointer.
+	 */
+	switch(dir) {
+#ifdef	SYM_OPT_HANDLE_DIR_UNKNOWN
+	case CAM_DIR_UNKNOWN:
+#endif
+	case CAM_DIR_OUT:
+		goalp = SCRIPTA_BA(np, data_out2) + 8;
+		lastp = goalp - 8 - (cp->segments * (2*4));
+#ifdef	SYM_OPT_HANDLE_DIR_UNKNOWN
+		cp->wgoalp = cpu_to_scr(goalp);
+		if (dir != CAM_DIR_UNKNOWN)
+			break;
+		cp->phys.head.wlastp = cpu_to_scr(lastp);
+		/* fall through */
+#else
+		break;
+#endif
+	case CAM_DIR_IN:
+		cp->host_flags |= HF_DATA_IN;
+		goalp = SCRIPTA_BA(np, data_in2) + 8;
+		lastp = goalp - 8 - (cp->segments * (2*4));
+		break;
+	case CAM_DIR_NONE:
+	default:
+#ifdef	SYM_OPT_HANDLE_DIR_UNKNOWN
+		cp->host_flags |= HF_DATA_IN;
+#endif
+		lastp = goalp = SCRIPTB_BA(np, no_data);
+		break;
+	}
+
+	/*
+	 *  Set all pointers values needed by SCRIPTS.
+	 */
+	cp->phys.head.lastp = cpu_to_scr(lastp);
+	cp->phys.head.savep = cpu_to_scr(lastp);
+	cp->startp	    = cp->phys.head.savep;
+	cp->goalp	    = cpu_to_scr(goalp);
+
+#ifdef	SYM_OPT_HANDLE_DIR_UNKNOWN
+	/*
+	 *  If direction is unknown, start at data_io.
+	 */
+	if (dir == CAM_DIR_UNKNOWN)
+		cp->phys.head.savep = cpu_to_scr(SCRIPTB_BA(np, data_io));
+#endif
+}
+
+/*
+ *  MEMORY ALLOCATOR.
+ */
+
+#define SYM_MEM_PAGE_ORDER 0	/* 1 PAGE  maximum */
+#define SYM_MEM_CLUSTER_SHIFT	(PAGE_SHIFT+SYM_MEM_PAGE_ORDER)
+#define SYM_MEM_FREE_UNUSED	/* Free unused pages immediately */
+
+#define SYM_MEM_WARN	1	/* Warn on failed operations */
+
+#define sym_get_mem_cluster()	\
+	(void *) __get_free_pages(GFP_ATOMIC, SYM_MEM_PAGE_ORDER)
+#define sym_free_mem_cluster(p)	\
+	free_pages((unsigned long)p, SYM_MEM_PAGE_ORDER)
+
+/*
+ *  Link between free memory chunks of a given size.
+ */
+typedef struct sym_m_link {
+	struct sym_m_link *next;
+} *m_link_p;
+
+/*
+ *  Virtual to bus physical translation for a given cluster.
+ *  Such a structure is only useful with DMA abstraction.
+ */
+typedef struct sym_m_vtob {	/* Virtual to Bus address translation */
+	struct sym_m_vtob *next;
+	void *vaddr;		/* Virtual address */
+	dma_addr_t baddr;	/* Bus physical address */
+} *m_vtob_p;
+
+/* Hash this stuff a bit to speed up translations */
+#define VTOB_HASH_SHIFT		5
+#define VTOB_HASH_SIZE		(1UL << VTOB_HASH_SHIFT)
+#define VTOB_HASH_MASK		(VTOB_HASH_SIZE-1)
+#define VTOB_HASH_CODE(m)	\
+	((((unsigned long)(m)) >> SYM_MEM_CLUSTER_SHIFT) & VTOB_HASH_MASK)
+
+/*
+ *  Memory pool of a given kind.
+ *  Ideally, we want to use:
+ *  1) 1 pool for memory we donnot need to involve in DMA.
+ *  2) The same pool for controllers that require same DMA 
+ *     constraints and features.
+ *     The OS specific m_pool_id_t thing and the sym_m_pool_match() 
+ *     method are expected to tell the driver about.
+ */
+typedef struct sym_m_pool {
+	m_pool_ident_t	dev_dmat;	/* Identifies the pool (see above) */
+	void * (*get_mem_cluster)(struct sym_m_pool *);
+#ifdef	SYM_MEM_FREE_UNUSED
+	void (*free_mem_cluster)(struct sym_m_pool *, void *);
+#endif
+#define M_GET_MEM_CLUSTER()		mp->get_mem_cluster(mp)
+#define M_FREE_MEM_CLUSTER(p)		mp->free_mem_cluster(mp, p)
+	int nump;
+	m_vtob_p vtob[VTOB_HASH_SIZE];
+	struct sym_m_pool *next;
+	struct sym_m_link h[SYM_MEM_CLUSTER_SHIFT - SYM_MEM_SHIFT + 1];
+} *m_pool_p;
+
+/*
+ *  Alloc, free and translate addresses to bus physical 
+ *  for DMAable memory.
+ */
+void *__sym_calloc_dma(m_pool_ident_t dev_dmat, int size, char *name);
+void __sym_mfree_dma(m_pool_ident_t dev_dmat, void *m, int size, char *name);
+dma_addr_t __vtobus(m_pool_ident_t dev_dmat, void *m);
+
+/*
+ * Verbs used by the driver code for DMAable memory handling.
+ * The _uvptv_ macro avoids a nasty warning about pointer to volatile 
+ * being discarded.
+ */
+#define _uvptv_(p) ((void *)((u_long)(p)))
+
+#define _sym_calloc_dma(np, l, n)	__sym_calloc_dma(np->bus_dmat, l, n)
+#define _sym_mfree_dma(np, p, l, n)	\
+			__sym_mfree_dma(np->bus_dmat, _uvptv_(p), l, n)
+#define sym_calloc_dma(l, n)		_sym_calloc_dma(np, l, n)
+#define sym_mfree_dma(p, l, n)		_sym_mfree_dma(np, p, l, n)
+#define vtobus(p)			__vtobus(np->bus_dmat, _uvptv_(p))
+
+/*
+ *  We have to provide the driver memory allocator with methods for 
+ *  it to maintain virtual to bus physical address translations.
+ */
+
+#define sym_m_pool_match(mp_id1, mp_id2)	(mp_id1 == mp_id2)
+
+static __inline void *sym_m_get_dma_mem_cluster(m_pool_p mp, m_vtob_p vbp)
+{
+	void *vaddr = NULL;
+	dma_addr_t baddr = 0;
+
+	vaddr = dma_alloc_coherent(mp->dev_dmat, SYM_MEM_CLUSTER_SIZE, &baddr,
+			GFP_ATOMIC);
+	if (vaddr) {
+		vbp->vaddr = vaddr;
+		vbp->baddr = baddr;
+	}
+	return vaddr;
+}
+
+static __inline void sym_m_free_dma_mem_cluster(m_pool_p mp, m_vtob_p vbp)
+{
+	dma_free_coherent(mp->dev_dmat, SYM_MEM_CLUSTER_SIZE, vbp->vaddr,
+			vbp->baddr);
+}
+
+#endif /* SYM_HIPD_H */
