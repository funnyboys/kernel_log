commit 79855d178557cc3e3ffd179fd26a64cef48dfb30
Author: Christoph Hellwig <hch@lst.de>
Date:   Wed Nov 5 10:36:28 2014 +0100

    libsas: remove task_collector mode
    
    The task_collector mode (or "latency_injector", (C) Dan Willians) is an
    optional I/O path in libsas that queues up scsi commands instead of
    directly sending it to the hardware.  It generall increases latencies
    to in the optiomal case slightly reduce mmio traffic to the hardware.
    
    Only the obsolete aic94xx driver and the mvsas driver allowed to use
    it without recompiling the kernel, and most drivers didn't support it
    at all.
    
    Remove the giant blob of code to allow better optimizations for scsi-mq
    in the future.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Reviewed-by: Hannes Reinecke <hare@suse.de>
    Acked-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/drivers/scsi/isci/task.h b/drivers/scsi/isci/task.h
index 9c06cbad1d26..8f4531f22ac2 100644
--- a/drivers/scsi/isci/task.h
+++ b/drivers/scsi/isci/task.h
@@ -131,7 +131,6 @@ static inline void isci_print_tmf(struct isci_host *ihost, struct isci_tmf *tmf)
 
 int isci_task_execute_task(
 	struct sas_task *task,
-	int num,
 	gfp_t gfp_flags);
 
 int isci_task_abort_task(

commit 14aaa9f0a318bd04cbb9d822524b817e95d8b343
Author: Jeff Skirvin <jeffrey.d.skirvin@intel.com>
Date:   Thu Mar 8 22:41:54 2012 -0800

    isci: Redesign device suspension, abort, cleanup.
    
    This commit changes the means by which outstanding I/Os are handled
    for cleanup.
    The likelihood is that this commit will be broken into smaller pieces,
    however that will be a later revision.  Among the changes:
    
    - All completion structures have been removed from the tmf and
    abort paths.
    - Now using one completed I/O list, with the I/O completed in host bit being
    used to select error or normal callback paths.
    
    Signed-off-by: Jeff Skirvin <jeffrey.d.skirvin@intel.com>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/drivers/scsi/isci/task.h b/drivers/scsi/isci/task.h
index 7b6d0e32fd9b..9c06cbad1d26 100644
--- a/drivers/scsi/isci/task.h
+++ b/drivers/scsi/isci/task.h
@@ -62,19 +62,6 @@
 
 struct isci_request;
 
-/**
- * enum isci_tmf_cb_state - This enum defines the possible states in which the
- *    TMF callback function is invoked during the TMF execution process.
- *
- *
- */
-enum isci_tmf_cb_state {
-
-	isci_tmf_init_state = 0,
-	isci_tmf_started,
-	isci_tmf_timed_out
-};
-
 /**
  * enum isci_tmf_function_codes - This enum defines the possible preparations
  *    of task management requests.
@@ -87,6 +74,7 @@ enum isci_tmf_function_codes {
 	isci_tmf_ssp_task_abort = TMF_ABORT_TASK,
 	isci_tmf_ssp_lun_reset  = TMF_LU_RESET,
 };
+
 /**
  * struct isci_tmf - This class represents the task management object which
  *    acts as an interface to libsas for processing task management requests
@@ -106,15 +94,6 @@ struct isci_tmf {
 	u16 io_tag;
 	enum isci_tmf_function_codes tmf_code;
 	int status;
-
-	/* The optional callback function allows the user process to
-	 * track the TMF transmit / timeout conditions.
-	 */
-	void (*cb_state_func)(
-		enum isci_tmf_cb_state,
-		struct isci_tmf *, void *);
-	void *cb_data;
-
 };
 
 static inline void isci_print_tmf(struct isci_host *ihost, struct isci_tmf *tmf)
@@ -208,113 +187,4 @@ int isci_queuecommand(
 	struct scsi_cmnd *scsi_cmd,
 	void (*donefunc)(struct scsi_cmnd *));
 
-/**
- * enum isci_completion_selection - This enum defines the possible actions to
- *    take with respect to a given request's notification back to libsas.
- *
- *
- */
-enum isci_completion_selection {
-
-	isci_perform_normal_io_completion,      /* Normal notify (task_done) */
-	isci_perform_aborted_io_completion,     /* No notification.   */
-	isci_perform_error_io_completion        /* Use sas_task_abort */
-};
-
-/**
- * isci_task_set_completion_status() - This function sets the completion status
- *    for the request.
- * @task: This parameter is the completed request.
- * @response: This parameter is the response code for the completed task.
- * @status: This parameter is the status code for the completed task.
- *
-* @return The new notification mode for the request.
-*/
-static inline enum isci_completion_selection
-isci_task_set_completion_status(
-	struct sas_task *task,
-	enum service_response response,
-	enum exec_status status,
-	enum isci_completion_selection task_notification_selection)
-{
-	unsigned long flags;
-
-	spin_lock_irqsave(&task->task_state_lock, flags);
-
-	/* If a device reset is being indicated, make sure the I/O
-	* is in the error path.
-	*/
-	if (task->task_state_flags & SAS_TASK_NEED_DEV_RESET) {
-		/* Fail the I/O to make sure it goes into the error path. */
-		response = SAS_TASK_UNDELIVERED;
-		status = SAM_STAT_TASK_ABORTED;
-
-		task_notification_selection = isci_perform_error_io_completion;
-	}
-	task->task_status.resp = response;
-	task->task_status.stat = status;
-
-	switch (task->task_proto) {
-
-	case SAS_PROTOCOL_SATA:
-	case SAS_PROTOCOL_STP:
-	case SAS_PROTOCOL_SATA | SAS_PROTOCOL_STP:
-
-		if (task_notification_selection
-		    == isci_perform_error_io_completion) {
-			/* SATA/STP I/O has it's own means of scheduling device
-			* error handling on the normal path.
-			*/
-			task_notification_selection
-				= isci_perform_normal_io_completion;
-		}
-		break;
-	default:
-		break;
-	}
-
-	switch (task_notification_selection) {
-
-	case isci_perform_error_io_completion:
-
-		if (task->task_proto == SAS_PROTOCOL_SMP) {
-			/* There is no error escalation in the SMP case.
-			 * Convert to a normal completion to avoid the
-			 * timeout in the discovery path and to let the
-			 * next action take place quickly.
-			 */
-			task_notification_selection
-				= isci_perform_normal_io_completion;
-
-			/* Fall through to the normal case... */
-		} else {
-			/* Use sas_task_abort */
-			/* Leave SAS_TASK_STATE_DONE clear
-			 * Leave SAS_TASK_AT_INITIATOR set.
-			 */
-			break;
-		}
-
-	case isci_perform_aborted_io_completion:
-		/* This path can occur with task-managed requests as well as
-		 * requests terminated because of LUN or device resets.
-		 */
-		/* Fall through to the normal case... */
-	case isci_perform_normal_io_completion:
-		/* Normal notification (task_done) */
-		task->task_state_flags |= SAS_TASK_STATE_DONE;
-		task->task_state_flags &= ~(SAS_TASK_AT_INITIATOR |
-					    SAS_TASK_STATE_PENDING);
-		break;
-	default:
-		WARN_ONCE(1, "unknown task_notification_selection: %d\n",
-			 task_notification_selection);
-		break;
-	}
-
-	spin_unlock_irqrestore(&task->task_state_lock, flags);
-
-	return task_notification_selection;
-
-}
 #endif /* !defined(_SCI_TASK_H_) */

commit 6a719391e4a13d5fa2ec7642ef0c780d7f3f5716
Author: Dan Williams <dan.j.williams@intel.com>
Date:   Thu Dec 8 00:37:25 2011 -0800

    [SCSI] isci: remove bus and reset handlers
    
    Remove ->eh_device_reset_handler() and ->eh_bus_reset_handler() for the
    same reason they are not implemented for libata hosts, they cannot be
    implemented reliably with ata-eh.  ATA error recovery wants to divert
    all resets to the eh thread and wait for completion, these handlers may
    be invoked from a non-blocking ioctl.
    
    The other path they are called from is libsas-eh, and if we escalate
    past I_T_nexus reset we have larger problems i.e. tear down all
    in-flight commands in the domain potentially without notification to the
    lldd if it has chosen not to implement ->lldd_clear_nexus_port() /
    ->lldd_clear_nexus_ha().
    
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>
    Signed-off-by: James Bottomley <JBottomley@Parallels.com>

diff --git a/drivers/scsi/isci/task.h b/drivers/scsi/isci/task.h
index 5ba00c3081f4..7b6d0e32fd9b 100644
--- a/drivers/scsi/isci/task.h
+++ b/drivers/scsi/isci/task.h
@@ -208,8 +208,6 @@ int isci_queuecommand(
 	struct scsi_cmnd *scsi_cmd,
 	void (*donefunc)(struct scsi_cmnd *));
 
-int isci_bus_reset_handler(struct scsi_cmnd *cmd);
-
 /**
  * enum isci_completion_selection - This enum defines the possible actions to
  *    take with respect to a given request's notification back to libsas.

commit 43a5ab151f0268459c4368292c2ddb2266b8f243
Author: Dan Williams <dan.j.williams@intel.com>
Date:   Thu Dec 8 23:20:44 2011 -0800

    [SCSI] isci: stop interpreting ->lldd_lu_reset() as an ata soft-reset
    
    Driving resets from libsas-eh is pre-mature as libata will make a
    decision about performing a softreset.  Currently libata determines
    whether to perform a softreset based on ata_eh_followup_srst_needed(),
    and none of those conditions apply to isci.
    
    Remove the srst implementation and translate ->lldd_lu_reset() for ata
    devices as a request to drive a reset via libata-eh.
    
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>
    Signed-off-by: James Bottomley <JBottomley@Parallels.com>

diff --git a/drivers/scsi/isci/task.h b/drivers/scsi/isci/task.h
index bb472c339523..5ba00c3081f4 100644
--- a/drivers/scsi/isci/task.h
+++ b/drivers/scsi/isci/task.h
@@ -86,8 +86,6 @@ enum isci_tmf_function_codes {
 	isci_tmf_func_none      = 0,
 	isci_tmf_ssp_task_abort = TMF_ABORT_TASK,
 	isci_tmf_ssp_lun_reset  = TMF_LU_RESET,
-	isci_tmf_sata_srst_high = TMF_LU_RESET + 0x100, /* Non SCSI */
-	isci_tmf_sata_srst_low  = TMF_LU_RESET + 0x101  /* Non SCSI */
 };
 /**
  * struct isci_tmf - This class represents the task management object which

commit 312d3e56119a4bc5c36a96818f87f650c069ddc2
Author: Dan Williams <dan.j.williams@intel.com>
Date:   Thu Nov 17 17:59:50 2011 -0800

    [SCSI] libsas: remove ata_port.lock management duties from lldds
    
    Each libsas driver (mvsas, pm8001, and isci) has invented a different
    method for managing the ap->lock.  The lock is held by the ata
    ->queuecommand() path.  mvsas drops it prior to acquiring any internal
    locks which allows it to hold its internal lock across calls to
    task->task_done().  This capability is important as it is the only way
    the driver can flush task->task_done() instances to guarantee that it no
    longer has any in-flight references to a domain_device at
    ->lldd_dev_gone() time.
    
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>
    Signed-off-by: James Bottomley <JBottomley@Parallels.com>

diff --git a/drivers/scsi/isci/task.h b/drivers/scsi/isci/task.h
index 1b27b3797c6c..bb472c339523 100644
--- a/drivers/scsi/isci/task.h
+++ b/drivers/scsi/isci/task.h
@@ -321,40 +321,4 @@ isci_task_set_completion_status(
 	return task_notification_selection;
 
 }
-/**
-* isci_execpath_callback() - This function is called from the task
-* execute path when the task needs to callback libsas about the submit-time
-* task failure.  The callback occurs either through the task's done function
-* or through sas_task_abort.  In the case of regular non-discovery SATA/STP I/O
-* requests, libsas takes the host lock before calling execute task.  Therefore
-* in this situation the host lock must be managed before calling the func.
-*
-* @ihost: This parameter is the controller to which the I/O request was sent.
-* @task: This parameter is the I/O request.
-* @func: This parameter is the function to call in the correct context.
-* @status: This parameter is the status code for the completed task.
-*
-*/
-static inline void isci_execpath_callback(struct isci_host *ihost,
-					  struct sas_task  *task,
-					  void (*func)(struct sas_task *))
-{
-	struct domain_device *dev = task->dev;
-
-	if (dev_is_sata(dev) && task->uldd_task) {
-		unsigned long flags;
-
-		/* Since we are still in the submit path, and since
-		 * libsas takes the host lock on behalf of SATA
-		 * devices before I/O starts (in the non-discovery case),
-		 * we need to unlock before we can call the callback function.
-		 */
-		raw_local_irq_save(flags);
-		spin_unlock(dev->sata_dev.ap->lock);
-		func(task);
-		spin_lock(dev->sata_dev.ap->lock);
-		raw_local_irq_restore(flags);
-	} else
-		func(task);
-}
 #endif /* !defined(_SCI_TASK_H_) */

commit 27234ab44f97d85bab062a9d18aaff99addd267d
Author: Maciej Trela <maciej.trela@intel.com>
Date:   Wed Jan 4 01:33:05 2012 -0800

    [SCSI] isci: remove unused 'isci_tmf->device' field
    
    As the field was never set, isci_print_tmf() using 'isci_tmf->device'
    sometimes causes a kernel crash if the dev_dbg() statement is enabled.
    Remove the unused field both from isci_tmf struct definition and from
    isci_print_tmf()
    
    Signed-off-by: Maciej Trela <maciej.trela@intel.com>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>
    Signed-off-by: James Bottomley <JBottomley@Parallels.com>

diff --git a/drivers/scsi/isci/task.h b/drivers/scsi/isci/task.h
index bc78c0a41d5c..1b27b3797c6c 100644
--- a/drivers/scsi/isci/task.h
+++ b/drivers/scsi/isci/task.h
@@ -106,7 +106,6 @@ struct isci_tmf {
 	} resp;
 	unsigned char lun[8];
 	u16 io_tag;
-	struct isci_remote_device *device;
 	enum isci_tmf_function_codes tmf_code;
 	int status;
 
@@ -120,10 +119,10 @@ struct isci_tmf {
 
 };
 
-static inline void isci_print_tmf(struct isci_tmf *tmf)
+static inline void isci_print_tmf(struct isci_host *ihost, struct isci_tmf *tmf)
 {
 	if (SAS_PROTOCOL_SATA == tmf->proto)
-		dev_dbg(&tmf->device->isci_port->isci_host->pdev->dev,
+		dev_dbg(&ihost->pdev->dev,
 			"%s: status = %x\n"
 			"tmf->resp.d2h_fis.status = %x\n"
 			"tmf->resp.d2h_fis.error = %x\n",
@@ -132,7 +131,7 @@ static inline void isci_print_tmf(struct isci_tmf *tmf)
 			tmf->resp.d2h_fis.status,
 			tmf->resp.d2h_fis.error);
 	else
-		dev_dbg(&tmf->device->isci_port->isci_host->pdev->dev,
+		dev_dbg(&ihost->pdev->dev,
 			"%s: status = %x\n"
 			"tmf->resp.resp_iu.data_present = %x\n"
 			"tmf->resp.resp_iu.status = %x\n"

commit 98145cb722b51ccc3ba27166c9803545accba950
Author: Jeff Skirvin <jeffrey.d.skirvin@intel.com>
Date:   Thu Oct 27 15:05:16 2011 -0700

    [SCSI] isci: Fix task management for SMP, SATA and on dev remove.
    
    libsas uses the LLDD abort task interface to handle I/O timeouts
    in the SATA/STP and SMP discovery paths, so this change will terminate
    STP/SMP requests. Also, if the device is gone, the lldd will prevent
    libsas from further escalations in the error handler.
    
    Signed-off-by: Jeff Skirvin <jeffrey.d.skirvin@intel.com>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>
    Signed-off-by: James Bottomley <JBottomley@Parallels.com>

diff --git a/drivers/scsi/isci/task.h b/drivers/scsi/isci/task.h
index c9ccd0b5ff53..bc78c0a41d5c 100644
--- a/drivers/scsi/isci/task.h
+++ b/drivers/scsi/isci/task.h
@@ -226,35 +226,6 @@ enum isci_completion_selection {
 	isci_perform_error_io_completion        /* Use sas_task_abort */
 };
 
-static inline void isci_set_task_doneflags(
-	struct sas_task *task)
-{
-	/* Since no futher action will be taken on this task,
-	 * make sure to mark it complete from the lldd perspective.
-	 */
-	task->task_state_flags |= SAS_TASK_STATE_DONE;
-	task->task_state_flags &= ~SAS_TASK_AT_INITIATOR;
-	task->task_state_flags &= ~SAS_TASK_STATE_PENDING;
-}
-/**
- * isci_task_all_done() - This function clears the task bits to indicate the
- *    LLDD is done with the task.
- *
- *
- */
-static inline void isci_task_all_done(
-	struct sas_task *task)
-{
-	unsigned long flags;
-
-	/* Since no futher action will be taken on this task,
-	 * make sure to mark it complete from the lldd perspective.
-	 */
-	spin_lock_irqsave(&task->task_state_lock, flags);
-	isci_set_task_doneflags(task);
-	spin_unlock_irqrestore(&task->task_state_lock, flags);
-}
-
 /**
  * isci_task_set_completion_status() - This function sets the completion status
  *    for the request.
@@ -336,7 +307,9 @@ isci_task_set_completion_status(
 		/* Fall through to the normal case... */
 	case isci_perform_normal_io_completion:
 		/* Normal notification (task_done) */
-		isci_set_task_doneflags(task);
+		task->task_state_flags |= SAS_TASK_STATE_DONE;
+		task->task_state_flags &= ~(SAS_TASK_AT_INITIATOR |
+					    SAS_TASK_STATE_PENDING);
 		break;
 	default:
 		WARN_ONCE(1, "unknown task_notification_selection: %d\n",

commit b343dff1a269bcc0eac123ef541c5476b03d52c1
Author: Jeff Skirvin <jeffrey.d.skirvin@intel.com>
Date:   Thu Oct 27 15:05:06 2011 -0700

    [SCSI] isci: Handle task request timeouts correctly.
    
    In the case where "task" requests timeout (note that this class of
    requests can also include SATA/STP soft reset FIS transmissions),
    handle the case where the task was being managed by some call to
    terminate the task request by completing both the tmf and the aborting
    process.
    
    Signed-off-by: Jeff Skirvin <jeffrey.d.skirvin@intel.com>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>
    Signed-off-by: James Bottomley <JBottomley@Parallels.com>

diff --git a/drivers/scsi/isci/task.h b/drivers/scsi/isci/task.h
index 15b18d158993..c9ccd0b5ff53 100644
--- a/drivers/scsi/isci/task.h
+++ b/drivers/scsi/isci/task.h
@@ -58,6 +58,8 @@
 #include <scsi/sas_ata.h>
 #include "host.h"
 
+#define ISCI_TERMINATION_TIMEOUT_MSEC 500
+
 struct isci_request;
 
 /**

commit cd06b9bae18c64658d5a86526fb19cfe0ea8814f
Author: Jeff Skirvin <jeffrey.d.skirvin@intel.com>
Date:   Wed Sep 28 18:47:46 2011 -0700

    [SCSI] isci: SATA/STP I/O is only returned in the normal path to libsas
    
    Since libsas has it's own means to escalate SATA/STP device error
    handling depending on task status codes, return all SATA/STP I/O
    on the normal path.
    
    i.e. skip sas_task_abort() and let sas_ata_task_done() disposition the
    qc.  Longer term we want to audit non-essential calls to
    sas_task_abort().
    
    Signed-off-by: Jeff Skirvin <jeffrey.d.skirvin@intel.com>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>
    Signed-off-by: James Bottomley <JBottomley@Parallels.com>

diff --git a/drivers/scsi/isci/task.h b/drivers/scsi/isci/task.h
index 4a7fa90287ef..15b18d158993 100644
--- a/drivers/scsi/isci/task.h
+++ b/drivers/scsi/isci/task.h
@@ -286,6 +286,25 @@ isci_task_set_completion_status(
 	task->task_status.resp = response;
 	task->task_status.stat = status;
 
+	switch (task->task_proto) {
+
+	case SAS_PROTOCOL_SATA:
+	case SAS_PROTOCOL_STP:
+	case SAS_PROTOCOL_SATA | SAS_PROTOCOL_STP:
+
+		if (task_notification_selection
+		    == isci_perform_error_io_completion) {
+			/* SATA/STP I/O has it's own means of scheduling device
+			* error handling on the normal path.
+			*/
+			task_notification_selection
+				= isci_perform_normal_io_completion;
+		}
+		break;
+	default:
+		break;
+	}
+
 	switch (task_notification_selection) {
 
 	case isci_perform_error_io_completion:

commit 16ba77091b44af28b3ff3318b4a2aa4fbf7d4c24
Author: Dan Williams <dan.j.williams@intel.com>
Date:   Fri Jul 1 10:52:55 2011 -0700

    isci: merge sata.[ch] into request.c
    
    Undo some needless separation.
    
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/drivers/scsi/isci/task.h b/drivers/scsi/isci/task.h
index 42019de23805..4a7fa90287ef 100644
--- a/drivers/scsi/isci/task.h
+++ b/drivers/scsi/isci/task.h
@@ -211,18 +211,6 @@ int isci_queuecommand(
 
 int isci_bus_reset_handler(struct scsi_cmnd *cmd);
 
-void isci_task_build_tmf(
-	struct isci_tmf *tmf,
-	enum isci_tmf_function_codes code,
-	void (*tmf_sent_cb)(enum isci_tmf_cb_state,
-			    struct isci_tmf *,
-			    void *),
-	void *cb_data);
-
-int isci_task_execute_tmf(struct isci_host *isci_host,
-			  struct isci_remote_device *idev,
-			  struct isci_tmf *tmf, unsigned long timeout_ms);
-
 /**
  * enum isci_completion_selection - This enum defines the possible actions to
  *    take with respect to a given request's notification back to libsas.

commit 209fae14fabfd48525e5630bebbbd4ca15090c60
Author: Dan Williams <dan.j.williams@intel.com>
Date:   Mon Jun 13 17:39:44 2011 -0700

    isci: atomic device lookup and reference counting
    
    We have unsafe references to remote devices that are notified to
    disappear at lldd_dev_gone.  In order to clean this up we need a single
    canonical source for device lookups and stable references once a lookup
    succeeds.  Towards that end guarantee that domain_device.lldd_dev is
    NULL as soon as we start the process of stopping a device.  Any code
    path that wants to safely lookup a remote device must do so through
    task->dev->lldd_dev (isci_lookup_device()).
    
    For in-flight references outside of scic_lock we need reference counting
    to ensure that the device is not recycled before we are done with it.
    Simplify device back references to just scic_sds_request.target_device
    which is now the only permissible internal reference that is maintained
    relative to the reference count.
    
    There were two occasions where we wanted new i/o's to be treated as
    SAS_TASK_UNDELIVERED but where the domain_dev->lldd_dev link is still
    intact.  Introduce a 'gone' flag to prevent i/o while waiting for libsas
    to take action on the port down event.
    
    One 'core' leftover is that we currently call
    scic_remote_device_destruct() from isci_remote_device_deconstruct()
    which is called when the 'core' says the device is stopped.  It would be
    more natural for the final put to trigger
    isci_remote_device_deconstruct() but this implementation is deferred as
    it requires other changes.
    
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/drivers/scsi/isci/task.h b/drivers/scsi/isci/task.h
index d574a18956d7..42019de23805 100644
--- a/drivers/scsi/isci/task.h
+++ b/drivers/scsi/isci/task.h
@@ -213,18 +213,15 @@ int isci_bus_reset_handler(struct scsi_cmnd *cmd);
 
 void isci_task_build_tmf(
 	struct isci_tmf *tmf,
-	struct isci_remote_device *isci_device,
 	enum isci_tmf_function_codes code,
 	void (*tmf_sent_cb)(enum isci_tmf_cb_state,
 			    struct isci_tmf *,
 			    void *),
 	void *cb_data);
 
-
-int isci_task_execute_tmf(
-	struct isci_host *isci_host,
-	struct isci_tmf *tmf,
-	unsigned long timeout_ms);
+int isci_task_execute_tmf(struct isci_host *isci_host,
+			  struct isci_remote_device *idev,
+			  struct isci_tmf *tmf, unsigned long timeout_ms);
 
 /**
  * enum isci_completion_selection - This enum defines the possible actions to

commit 360b03ed178a4fe3971b0a098d8feeb53333481b
Author: Dan Williams <dan.j.williams@intel.com>
Date:   Wed Jun 15 11:11:03 2011 -0700

    isci: fix ssp response iu buffer size in isci_tmf
    
    In isci_task_request_complete() we save the response/sense data from the
    command.  Make sure isci_tmf has enough space to hold the full response.
    
    [ it does not look like we actually use this data, and
      response_data_len/sense_data_len should be specifying the byte count,
      in any event do the simple fix first so we don't corrupt memory ]
    
    Reported-by: Adam Gruchala <adam.gruchala@intel.com>
    Tested-by: Edmund Nadolski <edmund.nadolski@intel.com>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/drivers/scsi/isci/task.h b/drivers/scsi/isci/task.h
index c8dd075d2be2..d574a18956d7 100644
--- a/drivers/scsi/isci/task.h
+++ b/drivers/scsi/isci/task.h
@@ -100,7 +100,8 @@ struct isci_tmf {
 	union {
 		struct ssp_response_iu resp_iu;
 		struct dev_to_host_fis d2h_fis;
-	}                            resp;
+		u8 rsp_buf[SSP_RESP_IU_MAX_SIZE];
+	} resp;
 	unsigned char lun[8];
 	u16 io_tag;
 	struct isci_remote_device *device;

commit cde76fbf1f27551a08860227765ae8d5026ac0d9
Author: Jeff Skirvin <jeffrey.d.skirvin@intel.com>
Date:   Mon Jun 20 14:09:06 2011 -0700

    isci: Add decode for SMP request retry error condition
    
    There are situations with slow expanders in which a first attempt
    to execute an SMP request will fail with a timeout.  Immediate
    subsequent retries will generally succeed.  This change makes sure
    SMP I/O failures are immediately failed to libsas so that retries
    happen with no discovery process timeout delay.
    
    Signed-off-by: Jeff Skirvin <jeffrey.d.skirvin@intel.com>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/drivers/scsi/isci/task.h b/drivers/scsi/isci/task.h
index 432b81aecd47..c8dd075d2be2 100644
--- a/drivers/scsi/isci/task.h
+++ b/drivers/scsi/isci/task.h
@@ -301,6 +301,27 @@ isci_task_set_completion_status(
 	task->task_status.stat = status;
 
 	switch (task_notification_selection) {
+
+	case isci_perform_error_io_completion:
+
+		if (task->task_proto == SAS_PROTOCOL_SMP) {
+			/* There is no error escalation in the SMP case.
+			 * Convert to a normal completion to avoid the
+			 * timeout in the discovery path and to let the
+			 * next action take place quickly.
+			 */
+			task_notification_selection
+				= isci_perform_normal_io_completion;
+
+			/* Fall through to the normal case... */
+		} else {
+			/* Use sas_task_abort */
+			/* Leave SAS_TASK_STATE_DONE clear
+			 * Leave SAS_TASK_AT_INITIATOR set.
+			 */
+			break;
+		}
+
 	case isci_perform_aborted_io_completion:
 		/* This path can occur with task-managed requests as well as
 		 * requests terminated because of LUN or device resets.
@@ -313,12 +334,6 @@ isci_task_set_completion_status(
 	default:
 		WARN_ONCE(1, "unknown task_notification_selection: %d\n",
 			 task_notification_selection);
-		/* Fall through to the error case... */
-	case isci_perform_error_io_completion:
-		/* Use sas_task_abort */
-		/* Leave SAS_TASK_STATE_DONE clear
-		 * Leave SAS_TASK_AT_INITIATOR set.
-		 */
 		break;
 	}
 

commit fd18388bc5820b3e7807302ac18e8e7de83c9f4c
Author: Edmund Nadolski <edmund.nadolski@intel.com>
Date:   Thu May 19 12:00:15 2011 +0000

    isci: Remove tmf timeout_timer
    
    Replace the timeout_timer in the isci_tmf with a call to
    wait_for_completion_timeout
    
    Signed-off-by: Edmund Nadolski <edmund.nadolski@intel.com>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/drivers/scsi/isci/task.h b/drivers/scsi/isci/task.h
index c59dc9620cf9..432b81aecd47 100644
--- a/drivers/scsi/isci/task.h
+++ b/drivers/scsi/isci/task.h
@@ -107,8 +107,6 @@ struct isci_tmf {
 	enum isci_tmf_function_codes tmf_code;
 	int status;
 
-	struct isci_timer *timeout_timer;
-
 	/* The optional callback function allows the user process to
 	 * track the TMF transmit / timeout conditions.
 	 */

commit ce2b3261b6765c3b80fda95426c73e8d3bb1b035
Author: Dan Williams <dan.j.williams@intel.com>
Date:   Sun May 8 15:49:15 2011 -0700

    isci: unify constants
    
    cross driver constants are spread out over multiple header files, consolidate
    them into isci.h, and push some includes out to the source files that need
    them.
    
    TODO: remove SCI_MODE_SIZE infrastructure.
    TODO: task.h is full of inlines that are too large
    
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/drivers/scsi/isci/task.h b/drivers/scsi/isci/task.h
index ecc5f1395063..c59dc9620cf9 100644
--- a/drivers/scsi/isci/task.h
+++ b/drivers/scsi/isci/task.h
@@ -56,6 +56,7 @@
 #define _ISCI_TASK_H_
 
 #include <scsi/sas_ata.h>
+#include "host.h"
 
 struct isci_request;
 

commit cc3dbd0a9178865d4444f8e28b51715808e9ac85
Author: Artur Wojcik <artur.wojcik@intel.com>
Date:   Wed May 4 07:58:16 2011 +0000

    isci: unify isci_host data structures
    
    Make it explicit that isci_host and scic_sds_controller are one in the same
    object.
    
    Signed-off-by: Artur Wojcik <artur.wojcik@intel.com>
    [removed ->ihost back pointer]
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/drivers/scsi/isci/task.h b/drivers/scsi/isci/task.h
index aa2458658d1e..ecc5f1395063 100644
--- a/drivers/scsi/isci/task.h
+++ b/drivers/scsi/isci/task.h
@@ -52,14 +52,12 @@
  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
-
-#if !defined(_ISCI_TASK_H_)
+#ifndef _ISCI_TASK_H_
 #define _ISCI_TASK_H_
 
 #include <scsi/sas_ata.h>
 
 struct isci_request;
-struct isci_host;
 
 /**
  * enum isci_tmf_cb_state - This enum defines the possible states in which the

commit 5b3f2bd877382eaf4b5a7d90fdec72ef14b9ec97
Author: Dan Williams <dan.j.williams@intel.com>
Date:   Thu May 5 17:47:44 2011 -0700

    isci: fix ata locking
    
    Upstream commit a29b5dad "libata: fix locking for sas paths" switched
    libsas ata locking to the ata_host lock.  We need to do the same when
    returning ata tasks from the execute path.
    
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/drivers/scsi/isci/task.h b/drivers/scsi/isci/task.h
index 77cc54dbe81f..aa2458658d1e 100644
--- a/drivers/scsi/isci/task.h
+++ b/drivers/scsi/isci/task.h
@@ -344,26 +344,26 @@ isci_task_set_completion_status(
 * @status: This parameter is the status code for the completed task.
 *
 */
-static inline void isci_execpath_callback(
-	struct isci_host *ihost,
-	struct sas_task  *task,
-	void (*func)(struct sas_task *))
+static inline void isci_execpath_callback(struct isci_host *ihost,
+					  struct sas_task  *task,
+					  void (*func)(struct sas_task *))
 {
-	unsigned long flags;
+	struct domain_device *dev = task->dev;
+
+	if (dev_is_sata(dev) && task->uldd_task) {
+		unsigned long flags;
 
-	if (dev_is_sata(task->dev) && task->uldd_task) {
 		/* Since we are still in the submit path, and since
-		* libsas takes the host lock on behalf of SATA
-		* devices before I/O starts (in the non-discovery case),
-		* we need to unlock before we can call the callback function.
-		*/
+		 * libsas takes the host lock on behalf of SATA
+		 * devices before I/O starts (in the non-discovery case),
+		 * we need to unlock before we can call the callback function.
+		 */
 		raw_local_irq_save(flags);
-		spin_unlock(ihost->shost->host_lock);
+		spin_unlock(dev->sata_dev.ap->lock);
 		func(task);
-		spin_lock(ihost->shost->host_lock);
+		spin_lock(dev->sata_dev.ap->lock);
 		raw_local_irq_restore(flags);
 	} else
 		func(task);
 }
-
 #endif /* !defined(_SCI_TASK_H_) */

commit af5ae89350840b9d724fc4fb81d928673bffdd4d
Author: Dave Jiang <dave.jiang@intel.com>
Date:   Wed May 4 17:53:24 2011 -0700

    isci: Convert of sci_ssp_response_iu to ssp_response_iu
    
    Converting to Linux native format. However the isci driver does a lot of
    the calculation based on the max size of this data structure and the
    Linux data structure only has a pointer to the response data. Thus the
    sizeof(struct ssp_response_iu) will be incorrect and we need to define
    the max size.
    
    Signed-off-by: Dave Jiang <dave.jiang@intel.com>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/drivers/scsi/isci/task.h b/drivers/scsi/isci/task.h
index c5afd1cfbde7..77cc54dbe81f 100644
--- a/drivers/scsi/isci/task.h
+++ b/drivers/scsi/isci/task.h
@@ -99,7 +99,7 @@ struct isci_tmf {
 	struct completion *complete;
 	enum sas_protocol proto;
 	union {
-		struct sci_ssp_response_iu resp_iu;
+		struct ssp_response_iu resp_iu;
 		struct dev_to_host_fis d2h_fis;
 	}                            resp;
 	unsigned char lun[8];
@@ -120,8 +120,7 @@ struct isci_tmf {
 
 };
 
-static inline void isci_print_tmf(
-	struct isci_tmf *tmf)
+static inline void isci_print_tmf(struct isci_tmf *tmf)
 {
 	if (SAS_PROTOCOL_SATA == tmf->proto)
 		dev_dbg(&tmf->device->isci_port->isci_host->pdev->dev,
@@ -144,16 +143,13 @@ static inline void isci_print_tmf(
 			"tmf->resp.resp_iu.data[3] = %x\n",
 			__func__,
 			tmf->status,
-			tmf->resp.resp_iu.data_present,
+			tmf->resp.resp_iu.datapres,
 			tmf->resp.resp_iu.status,
-			(tmf->resp.resp_iu.response_data_length[0] << 24) +
-			(tmf->resp.resp_iu.response_data_length[1] << 16) +
-			(tmf->resp.resp_iu.response_data_length[2] << 8) +
-			tmf->resp.resp_iu.response_data_length[3],
-			tmf->resp.resp_iu.data[0],
-			tmf->resp.resp_iu.data[1],
-			tmf->resp.resp_iu.data[2],
-			tmf->resp.resp_iu.data[3]);
+			be32_to_cpu(tmf->resp.resp_iu.response_data_len),
+			tmf->resp.resp_iu.resp_data[0],
+			tmf->resp.resp_iu.resp_data[1],
+			tmf->resp.resp_iu.resp_data[2],
+			tmf->resp.resp_iu.resp_data[3]);
 }
 
 

commit ed8a72d108bd951909b28fa4a89aad6489f414e1
Author: Jeff Skirvin <jeffrey.d.skirvin@intel.com>
Date:   Thu Mar 31 13:10:40 2011 -0700

    isci: Qualify when the host lock is managed for STP/SATA callbacks.
    
    In the case of internal discovery related STP/SATA I/O started
    through sas_execute_task the host lock is not taken by libsas before
    calling lldd_execute_task, so the lock should not be managed before
    calling back to libsas through task->task_done or sas_task_abort.
    
    Signed-off-by: Jeff Skirvin <jeffrey.d.skirvin@intel.com>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/drivers/scsi/isci/task.h b/drivers/scsi/isci/task.h
index d7cb6fe268c4..c5afd1cfbde7 100644
--- a/drivers/scsi/isci/task.h
+++ b/drivers/scsi/isci/task.h
@@ -56,6 +56,8 @@
 #if !defined(_ISCI_TASK_H_)
 #define _ISCI_TASK_H_
 
+#include <scsi/sas_ata.h>
+
 struct isci_request;
 struct isci_host;
 
@@ -332,5 +334,40 @@ isci_task_set_completion_status(
 	return task_notification_selection;
 
 }
+/**
+* isci_execpath_callback() - This function is called from the task
+* execute path when the task needs to callback libsas about the submit-time
+* task failure.  The callback occurs either through the task's done function
+* or through sas_task_abort.  In the case of regular non-discovery SATA/STP I/O
+* requests, libsas takes the host lock before calling execute task.  Therefore
+* in this situation the host lock must be managed before calling the func.
+*
+* @ihost: This parameter is the controller to which the I/O request was sent.
+* @task: This parameter is the I/O request.
+* @func: This parameter is the function to call in the correct context.
+* @status: This parameter is the status code for the completed task.
+*
+*/
+static inline void isci_execpath_callback(
+	struct isci_host *ihost,
+	struct sas_task  *task,
+	void (*func)(struct sas_task *))
+{
+	unsigned long flags;
+
+	if (dev_is_sata(task->dev) && task->uldd_task) {
+		/* Since we are still in the submit path, and since
+		* libsas takes the host lock on behalf of SATA
+		* devices before I/O starts (in the non-discovery case),
+		* we need to unlock before we can call the callback function.
+		*/
+		raw_local_irq_save(flags);
+		spin_unlock(ihost->shost->host_lock);
+		func(task);
+		spin_lock(ihost->shost->host_lock);
+		raw_local_irq_restore(flags);
+	} else
+		func(task);
+}
 
 #endif /* !defined(_SCI_TASK_H_) */

commit 35173d579a08c0d145b3020039d3ba33fbf2c184
Author: Dan Williams <dan.j.williams@intel.com>
Date:   Sat Mar 26 16:43:01 2011 -0700

    isci: namespacecheck cleanups
    
    * mark needlessly global routines static
    * delete unused functions
    * move kernel-doc blocks from header files to source
    * reorder some functions to delete declarations
    * more default handler cleanups phy
    
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/drivers/scsi/isci/task.h b/drivers/scsi/isci/task.h
index 9754b43f5b0b..d7cb6fe268c4 100644
--- a/drivers/scsi/isci/task.h
+++ b/drivers/scsi/isci/task.h
@@ -202,8 +202,6 @@ u16 isci_task_ssp_request_get_io_tag_to_manage(
 u8 isci_task_ssp_request_get_function(
 	struct isci_request *request);
 
-u32 isci_task_ssp_request_get_lun(
-	struct isci_request *request);
 
 void *isci_task_ssp_request_get_response_data_address(
 	struct isci_request *request);
@@ -226,14 +224,6 @@ void isci_task_build_tmf(
 			    void *),
 	void *cb_data);
 
-void isci_task_build_abort_task_tmf(
-	struct isci_tmf *tmf,
-	struct isci_remote_device *isci_device,
-	enum isci_tmf_function_codes code,
-	void (*tmf_sent_cb)(
-		enum isci_tmf_cb_state,
-		struct isci_tmf *, void *),
-	struct isci_request *old_request);
 
 int isci_task_execute_tmf(
 	struct isci_host *isci_host,

commit ce0b89f35636f3a69fbde851aff8a284c4b4c22b
Author: Dan Williams <dan.j.williams@intel.com>
Date:   Thu Mar 17 08:04:43 2011 -0700

    isci: task.h compile and checkpatch fixes
    
    A usage of "FALSE" leaked in as well as some checkpatch escapes.
    
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/drivers/scsi/isci/task.h b/drivers/scsi/isci/task.h
index b84bedd94601..9754b43f5b0b 100644
--- a/drivers/scsi/isci/task.h
+++ b/drivers/scsi/isci/task.h
@@ -306,7 +306,6 @@ isci_task_set_completion_status(
 	* is in the error path.
 	*/
 	if (task->task_state_flags & SAS_TASK_NEED_DEV_RESET) {
-
 		/* Fail the I/O to make sure it goes into the error path. */
 		response = SAS_TASK_UNDELIVERED;
 		status = SAM_STAT_TASK_ABORTED;
@@ -317,28 +316,25 @@ isci_task_set_completion_status(
 	task->task_status.stat = status;
 
 	switch (task_notification_selection) {
-
-		case isci_perform_aborted_io_completion:
-			/* This path can occur with task-managed requests as well as
-			* requests terminated because of LUN or device resets.
-			*/
-			/* Fall through to the normal case... */
-
-		case isci_perform_normal_io_completion:
-			/* Normal notification (task_done) */
-			isci_set_task_doneflags(task);
-			break;
-
-		default:
-			WARN_ON(FALSE);
-			/* Fall through to the error case... */
-
-		case isci_perform_error_io_completion:
-			/* Use sas_task_abort */
-			/* Leave SAS_TASK_STATE_DONE clear
-			*  Leave SAS_TASK_AT_INITIATOR set.
-			*/
-			break;
+	case isci_perform_aborted_io_completion:
+		/* This path can occur with task-managed requests as well as
+		 * requests terminated because of LUN or device resets.
+		 */
+		/* Fall through to the normal case... */
+	case isci_perform_normal_io_completion:
+		/* Normal notification (task_done) */
+		isci_set_task_doneflags(task);
+		break;
+	default:
+		WARN_ONCE(1, "unknown task_notification_selection: %d\n",
+			 task_notification_selection);
+		/* Fall through to the error case... */
+	case isci_perform_error_io_completion:
+		/* Use sas_task_abort */
+		/* Leave SAS_TASK_STATE_DONE clear
+		 * Leave SAS_TASK_AT_INITIATOR set.
+		 */
+		break;
 	}
 
 	spin_unlock_irqrestore(&task->task_state_lock, flags);

commit aa14510295d3d87431c915c0b2bc5dd3af7f2c35
Author: Jeff Skirvin <jeffrey.d.skirvin@intel.com>
Date:   Mon Mar 7 16:40:47 2011 -0700

    isci: Always set response/status for requests going into the error path.
    
    In the case of I/O requests being failed because of a required device
    reset condition, set the response and status to indicate an I/O failure.
    
    Signed-off-by: Jeff Skirvin <jeffrey.d.skirvin@intel.com>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/drivers/scsi/isci/task.h b/drivers/scsi/isci/task.h
index e1c9c8f04050..b84bedd94601 100644
--- a/drivers/scsi/isci/task.h
+++ b/drivers/scsi/isci/task.h
@@ -302,14 +302,19 @@ isci_task_set_completion_status(
 
 	spin_lock_irqsave(&task->task_state_lock, flags);
 
-	task->task_status.resp = response;
-	task->task_status.stat = status;
-
 	/* If a device reset is being indicated, make sure the I/O
 	* is in the error path.
 	*/
-	if (task->task_state_flags & SAS_TASK_NEED_DEV_RESET)
+	if (task->task_state_flags & SAS_TASK_NEED_DEV_RESET) {
+
+		/* Fail the I/O to make sure it goes into the error path. */
+		response = SAS_TASK_UNDELIVERED;
+		status = SAM_STAT_TASK_ABORTED;
+
 		task_notification_selection = isci_perform_error_io_completion;
+	}
+	task->task_status.resp = response;
+	task->task_status.stat = status;
 
 	switch (task_notification_selection) {
 

commit 50e7f9b5a9ae4a763b2c27500807cf237faca9b0
Author: Dan Williams <dan.j.williams@intel.com>
Date:   Wed Mar 9 21:27:46 2011 -0800

    isci: Errors in the submit path for SATA devices manage the ap lock.
    
    Since libsas takes the domain device sata_dev.ap->lock before submitting
    a task, error completions in the submit path for SATA devices must
    unlock/relock when completing the sas_task back to libsas.
    
    Signed-off-by: Jeff Skirvin <jeffrey.d.skirvin@intel.com>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/drivers/scsi/isci/task.h b/drivers/scsi/isci/task.h
index 4c2a27eede49..e1c9c8f04050 100644
--- a/drivers/scsi/isci/task.h
+++ b/drivers/scsi/isci/task.h
@@ -341,64 +341,5 @@ isci_task_set_completion_status(
 	return task_notification_selection;
 
 }
-/**
- * isci_task_complete_for_upper_layer() - This function completes the request
- *    to the upper layer driver.
- * @host: This parameter is a pointer to the host on which the the request
- *    should be queued (either as an error or success).
- * @request: This parameter is the completed request.
- * @response: This parameter is the response code for the completed task.
- * @status: This parameter is the status code for the completed task.
- *
- * none.
- */
-static inline void isci_task_complete_for_upper_layer(
-	struct sas_task *task,
-	enum service_response response,
-	enum exec_status status,
-	enum isci_completion_selection task_notification_selection)
-{
-	task_notification_selection
-		= isci_task_set_completion_status(task, response, status,
-						  task_notification_selection);
-
-	/* Tasks aborted specifically by a call to the lldd_abort_task
-	 * function should not be completed to the host in the regular path.
-	 */
-	switch (task_notification_selection) {
-	case isci_perform_normal_io_completion:
-		/* Normal notification (task_done) */
-		dev_dbg(task->dev->port->ha->dev,
-			"%s: Normal - task = %p, response=%d, status=%d\n",
-			__func__, task, response, status);
-		task->task_done(task);
-		task->lldd_task = NULL;
-		break;
-
-	case isci_perform_aborted_io_completion:
-		/* No notification because this request is already in the
-		 * abort path.
-		 */
-		dev_warn(task->dev->port->ha->dev,
-			 "%s: Aborted - task = %p, response=%d, status=%d\n",
-			 __func__, task, response, status);
-		break;
-
-	case isci_perform_error_io_completion:
-		/* Use sas_task_abort */
-		dev_warn(task->dev->port->ha->dev,
-			 "%s: Error - task = %p, response=%d, status=%d\n",
-			 __func__, task, response, status);
-		sas_task_abort(task);
-		break;
-
-	default:
-		dev_warn(task->dev->port->ha->dev,
-			 "%s: isci task notification default case!",
-			 __func__);
-		sas_task_abort(task);
-		break;
-	}
-}
 
 #endif /* !defined(_SCI_TASK_H_) */

commit c3f42feb0c3d20dc7007336e7de949408b93afef
Author: Jeff Skirvin <jeffrey.d.skirvin@intel.com>
Date:   Fri Mar 4 14:06:56 2011 -0800

    isci: Fix TMF build for SAS/SATA LUN reset cases.
    
    In the case where a SAS or SATA LUN reset TMF is built a NULL pointer
    dereference occurred because of the (unused) callback data pointer.
    
    Signed-off-by: Jeff Skirvin <jeffrey.d.skirvin@intel.com>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>
    Signed-off-by: Jacek Danecki <Jacek.Danecki@intel.com>

diff --git a/drivers/scsi/isci/task.h b/drivers/scsi/isci/task.h
index 5a5a4ec2dc90..4c2a27eede49 100644
--- a/drivers/scsi/isci/task.h
+++ b/drivers/scsi/isci/task.h
@@ -218,6 +218,15 @@ int isci_queuecommand(
 int isci_bus_reset_handler(struct scsi_cmnd *cmd);
 
 void isci_task_build_tmf(
+	struct isci_tmf *tmf,
+	struct isci_remote_device *isci_device,
+	enum isci_tmf_function_codes code,
+	void (*tmf_sent_cb)(enum isci_tmf_cb_state,
+			    struct isci_tmf *,
+			    void *),
+	void *cb_data);
+
+void isci_task_build_abort_task_tmf(
 	struct isci_tmf *tmf,
 	struct isci_remote_device *isci_device,
 	enum isci_tmf_function_codes code,

commit 1fad9e934a43407c1ba397b1b6b8882aa8a2cafd
Author: Jeff Skirvin <jeffrey.d.skirvin@intel.com>
Date:   Fri Mar 4 14:06:46 2011 -0800

    isci: save the i/o tag outside the scic request structure.
    
    The pointer to the core representation of a request is marked NULL at
    completion, but we need to save the i/o tag for task management.
    
    Signed-off-by: Jeff Skirvin <jeffrey.d.skirvin@intel.com>
    Signed-off-by: Jacek Danecki <Jacek.Danecki@intel.com>
    [revise changelog]
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/drivers/scsi/isci/task.h b/drivers/scsi/isci/task.h
index 68d8e5e65a73..5a5a4ec2dc90 100644
--- a/drivers/scsi/isci/task.h
+++ b/drivers/scsi/isci/task.h
@@ -224,7 +224,7 @@ void isci_task_build_tmf(
 	void (*tmf_sent_cb)(
 		enum isci_tmf_cb_state,
 		struct isci_tmf *, void *),
-	void *cb_data);
+	struct isci_request *old_request);
 
 int isci_task_execute_tmf(
 	struct isci_host *isci_host,

commit ec6c9638b0d0537430f78a3e20503b5e68a537b6
Author: Jeff Skirvin <jeffrey.d.skirvin@intel.com>
Date:   Fri Mar 4 14:06:44 2011 -0800

    isci: Any reset indicated on an I/O completion escalates it to the error path.
    
    If there is a pending device reset, the I/O is used to accomplish the reset by setting the
    RESET bit in the task status, and then putting the task into the error handler
    path using sas abort task.
    
    Signed-off-by: Jeff Skirvin <jeffrey.d.skirvin@intel.com>
    Signed-off-by: Jacek Danecki <Jacek.Danecki@intel.com>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/drivers/scsi/isci/task.h b/drivers/scsi/isci/task.h
index ced6a8be1b31..68d8e5e65a73 100644
--- a/drivers/scsi/isci/task.h
+++ b/drivers/scsi/isci/task.h
@@ -280,9 +280,10 @@ static inline void isci_task_all_done(
  * @response: This parameter is the response code for the completed task.
  * @status: This parameter is the status code for the completed task.
  *
- * none.
- */
-static inline void isci_task_set_completion_status(
+* @return The new notification mode for the request.
+*/
+static inline enum isci_completion_selection
+isci_task_set_completion_status(
 	struct sas_task *task,
 	enum service_response response,
 	enum exec_status status,
@@ -295,15 +296,41 @@ static inline void isci_task_set_completion_status(
 	task->task_status.resp = response;
 	task->task_status.stat = status;
 
-	/* Don't set DONE (or clear AT_INITIATOR) for any task going into the
-	 * error path, because the EH interprets that as a handled error condition.
-	 * Also don't take action if there is a reset pending.
-	 */
-	if ((task_notification_selection != isci_perform_error_io_completion)
-	    && !(task->task_state_flags & SAS_TASK_NEED_DEV_RESET))
-		isci_set_task_doneflags(task);
+	/* If a device reset is being indicated, make sure the I/O
+	* is in the error path.
+	*/
+	if (task->task_state_flags & SAS_TASK_NEED_DEV_RESET)
+		task_notification_selection = isci_perform_error_io_completion;
+
+	switch (task_notification_selection) {
+
+		case isci_perform_aborted_io_completion:
+			/* This path can occur with task-managed requests as well as
+			* requests terminated because of LUN or device resets.
+			*/
+			/* Fall through to the normal case... */
+
+		case isci_perform_normal_io_completion:
+			/* Normal notification (task_done) */
+			isci_set_task_doneflags(task);
+			break;
+
+		default:
+			WARN_ON(FALSE);
+			/* Fall through to the error case... */
+
+		case isci_perform_error_io_completion:
+			/* Use sas_task_abort */
+			/* Leave SAS_TASK_STATE_DONE clear
+			*  Leave SAS_TASK_AT_INITIATOR set.
+			*/
+			break;
+	}
 
 	spin_unlock_irqrestore(&task->task_state_lock, flags);
+
+	return task_notification_selection;
+
 }
 /**
  * isci_task_complete_for_upper_layer() - This function completes the request
@@ -322,9 +349,9 @@ static inline void isci_task_complete_for_upper_layer(
 	enum exec_status status,
 	enum isci_completion_selection task_notification_selection)
 {
-	isci_task_set_completion_status(task, response, status,
-					 task_notification_selection);
-
+	task_notification_selection
+		= isci_task_set_completion_status(task, response, status,
+						  task_notification_selection);
 
 	/* Tasks aborted specifically by a call to the lldd_abort_task
 	 * function should not be completed to the host in the regular path.

commit 6f231dda68080759f1aed3769896e94c73099f0f
Author: Dan Williams <dan.j.williams@intel.com>
Date:   Sat Jul 2 22:56:22 2011 -0700

    isci: Intel(R) C600 Series Chipset Storage Control Unit Driver
    
    Support for the up to 2x4-port 6Gb/s SAS controllers embedded in the
    chipset.
    
    This is a snapshot of the first publicly available version of the driver,
    commit 4c1db2d0 in the 'historical' branch.
    
       git://git.kernel.org/pub/scm/linux/kernel/git/djbw/isci.git historical
    
    Signed-off-by: Maciej Trela <maciej.trela@intel.com>
    Signed-off-by: Dave Jiang <dave.jiang@intel.com>
    Signed-off-by: Edmund Nadolski <edmund.nadolski@intel.com>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/drivers/scsi/isci/task.h b/drivers/scsi/isci/task.h
new file mode 100644
index 000000000000..ced6a8be1b31
--- /dev/null
+++ b/drivers/scsi/isci/task.h
@@ -0,0 +1,368 @@
+/*
+ * This file is provided under a dual BSD/GPLv2 license.  When using or
+ * redistributing this file, you may do so under either license.
+ *
+ * GPL LICENSE SUMMARY
+ *
+ * Copyright(c) 2008 - 2011 Intel Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
+ * The full GNU General Public License is included in this distribution
+ * in the file called LICENSE.GPL.
+ *
+ * BSD LICENSE
+ *
+ * Copyright(c) 2008 - 2011 Intel Corporation. All rights reserved.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ *   * Redistributions of source code must retain the above copyright
+ *     notice, this list of conditions and the following disclaimer.
+ *   * Redistributions in binary form must reproduce the above copyright
+ *     notice, this list of conditions and the following disclaimer in
+ *     the documentation and/or other materials provided with the
+ *     distribution.
+ *   * Neither the name of Intel Corporation nor the names of its
+ *     contributors may be used to endorse or promote products derived
+ *     from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#if !defined(_ISCI_TASK_H_)
+#define _ISCI_TASK_H_
+
+struct isci_request;
+struct isci_host;
+
+/**
+ * enum isci_tmf_cb_state - This enum defines the possible states in which the
+ *    TMF callback function is invoked during the TMF execution process.
+ *
+ *
+ */
+enum isci_tmf_cb_state {
+
+	isci_tmf_init_state = 0,
+	isci_tmf_started,
+	isci_tmf_timed_out
+};
+
+/**
+ * enum isci_tmf_function_codes - This enum defines the possible preparations
+ *    of task management requests.
+ *
+ *
+ */
+enum isci_tmf_function_codes {
+
+	isci_tmf_func_none      = 0,
+	isci_tmf_ssp_task_abort = TMF_ABORT_TASK,
+	isci_tmf_ssp_lun_reset  = TMF_LU_RESET,
+	isci_tmf_sata_srst_high = TMF_LU_RESET + 0x100, /* Non SCSI */
+	isci_tmf_sata_srst_low  = TMF_LU_RESET + 0x101  /* Non SCSI */
+};
+/**
+ * struct isci_tmf - This class represents the task management object which
+ *    acts as an interface to libsas for processing task management requests
+ *
+ *
+ */
+struct isci_tmf {
+
+	struct completion *complete;
+	enum sas_protocol proto;
+	union {
+		struct sci_ssp_response_iu resp_iu;
+		struct dev_to_host_fis d2h_fis;
+	}                            resp;
+	unsigned char lun[8];
+	u16 io_tag;
+	struct isci_remote_device *device;
+	enum isci_tmf_function_codes tmf_code;
+	int status;
+
+	struct isci_timer *timeout_timer;
+
+	/* The optional callback function allows the user process to
+	 * track the TMF transmit / timeout conditions.
+	 */
+	void (*cb_state_func)(
+		enum isci_tmf_cb_state,
+		struct isci_tmf *, void *);
+	void *cb_data;
+
+};
+
+static inline void isci_print_tmf(
+	struct isci_tmf *tmf)
+{
+	if (SAS_PROTOCOL_SATA == tmf->proto)
+		dev_dbg(&tmf->device->isci_port->isci_host->pdev->dev,
+			"%s: status = %x\n"
+			"tmf->resp.d2h_fis.status = %x\n"
+			"tmf->resp.d2h_fis.error = %x\n",
+			__func__,
+			tmf->status,
+			tmf->resp.d2h_fis.status,
+			tmf->resp.d2h_fis.error);
+	else
+		dev_dbg(&tmf->device->isci_port->isci_host->pdev->dev,
+			"%s: status = %x\n"
+			"tmf->resp.resp_iu.data_present = %x\n"
+			"tmf->resp.resp_iu.status = %x\n"
+			"tmf->resp.resp_iu.data_length = %x\n"
+			"tmf->resp.resp_iu.data[0] = %x\n"
+			"tmf->resp.resp_iu.data[1] = %x\n"
+			"tmf->resp.resp_iu.data[2] = %x\n"
+			"tmf->resp.resp_iu.data[3] = %x\n",
+			__func__,
+			tmf->status,
+			tmf->resp.resp_iu.data_present,
+			tmf->resp.resp_iu.status,
+			(tmf->resp.resp_iu.response_data_length[0] << 24) +
+			(tmf->resp.resp_iu.response_data_length[1] << 16) +
+			(tmf->resp.resp_iu.response_data_length[2] << 8) +
+			tmf->resp.resp_iu.response_data_length[3],
+			tmf->resp.resp_iu.data[0],
+			tmf->resp.resp_iu.data[1],
+			tmf->resp.resp_iu.data[2],
+			tmf->resp.resp_iu.data[3]);
+}
+
+
+int isci_task_execute_task(
+	struct sas_task *task,
+	int num,
+	gfp_t gfp_flags);
+
+int isci_task_abort_task(
+	struct sas_task *task);
+
+int isci_task_abort_task_set(
+	struct domain_device *d_device,
+	u8 *lun);
+
+int isci_task_clear_aca(
+	struct domain_device *d_device,
+	u8 *lun);
+
+int isci_task_clear_task_set(
+	struct domain_device *d_device,
+	u8 *lun);
+
+int isci_task_query_task(
+	struct sas_task *task);
+
+int isci_task_lu_reset(
+	struct domain_device *d_device,
+	u8 *lun);
+
+int isci_task_clear_nexus_port(
+	struct asd_sas_port *port);
+
+int isci_task_clear_nexus_ha(
+	struct sas_ha_struct *ha);
+
+int isci_task_I_T_nexus_reset(
+	struct domain_device *d_device);
+
+void isci_task_request_complete(
+	struct isci_host *isci_host,
+	struct isci_request *request,
+	enum sci_task_status completion_status);
+
+u16 isci_task_ssp_request_get_io_tag_to_manage(
+	struct isci_request *request);
+
+u8 isci_task_ssp_request_get_function(
+	struct isci_request *request);
+
+u32 isci_task_ssp_request_get_lun(
+	struct isci_request *request);
+
+void *isci_task_ssp_request_get_response_data_address(
+	struct isci_request *request);
+
+u32 isci_task_ssp_request_get_response_data_length(
+	struct isci_request *request);
+
+int isci_queuecommand(
+	struct scsi_cmnd *scsi_cmd,
+	void (*donefunc)(struct scsi_cmnd *));
+
+int isci_bus_reset_handler(struct scsi_cmnd *cmd);
+
+void isci_task_build_tmf(
+	struct isci_tmf *tmf,
+	struct isci_remote_device *isci_device,
+	enum isci_tmf_function_codes code,
+	void (*tmf_sent_cb)(
+		enum isci_tmf_cb_state,
+		struct isci_tmf *, void *),
+	void *cb_data);
+
+int isci_task_execute_tmf(
+	struct isci_host *isci_host,
+	struct isci_tmf *tmf,
+	unsigned long timeout_ms);
+
+/**
+ * enum isci_completion_selection - This enum defines the possible actions to
+ *    take with respect to a given request's notification back to libsas.
+ *
+ *
+ */
+enum isci_completion_selection {
+
+	isci_perform_normal_io_completion,      /* Normal notify (task_done) */
+	isci_perform_aborted_io_completion,     /* No notification.   */
+	isci_perform_error_io_completion        /* Use sas_task_abort */
+};
+
+static inline void isci_set_task_doneflags(
+	struct sas_task *task)
+{
+	/* Since no futher action will be taken on this task,
+	 * make sure to mark it complete from the lldd perspective.
+	 */
+	task->task_state_flags |= SAS_TASK_STATE_DONE;
+	task->task_state_flags &= ~SAS_TASK_AT_INITIATOR;
+	task->task_state_flags &= ~SAS_TASK_STATE_PENDING;
+}
+/**
+ * isci_task_all_done() - This function clears the task bits to indicate the
+ *    LLDD is done with the task.
+ *
+ *
+ */
+static inline void isci_task_all_done(
+	struct sas_task *task)
+{
+	unsigned long flags;
+
+	/* Since no futher action will be taken on this task,
+	 * make sure to mark it complete from the lldd perspective.
+	 */
+	spin_lock_irqsave(&task->task_state_lock, flags);
+	isci_set_task_doneflags(task);
+	spin_unlock_irqrestore(&task->task_state_lock, flags);
+}
+
+/**
+ * isci_task_set_completion_status() - This function sets the completion status
+ *    for the request.
+ * @task: This parameter is the completed request.
+ * @response: This parameter is the response code for the completed task.
+ * @status: This parameter is the status code for the completed task.
+ *
+ * none.
+ */
+static inline void isci_task_set_completion_status(
+	struct sas_task *task,
+	enum service_response response,
+	enum exec_status status,
+	enum isci_completion_selection task_notification_selection)
+{
+	unsigned long flags;
+
+	spin_lock_irqsave(&task->task_state_lock, flags);
+
+	task->task_status.resp = response;
+	task->task_status.stat = status;
+
+	/* Don't set DONE (or clear AT_INITIATOR) for any task going into the
+	 * error path, because the EH interprets that as a handled error condition.
+	 * Also don't take action if there is a reset pending.
+	 */
+	if ((task_notification_selection != isci_perform_error_io_completion)
+	    && !(task->task_state_flags & SAS_TASK_NEED_DEV_RESET))
+		isci_set_task_doneflags(task);
+
+	spin_unlock_irqrestore(&task->task_state_lock, flags);
+}
+/**
+ * isci_task_complete_for_upper_layer() - This function completes the request
+ *    to the upper layer driver.
+ * @host: This parameter is a pointer to the host on which the the request
+ *    should be queued (either as an error or success).
+ * @request: This parameter is the completed request.
+ * @response: This parameter is the response code for the completed task.
+ * @status: This parameter is the status code for the completed task.
+ *
+ * none.
+ */
+static inline void isci_task_complete_for_upper_layer(
+	struct sas_task *task,
+	enum service_response response,
+	enum exec_status status,
+	enum isci_completion_selection task_notification_selection)
+{
+	isci_task_set_completion_status(task, response, status,
+					 task_notification_selection);
+
+
+	/* Tasks aborted specifically by a call to the lldd_abort_task
+	 * function should not be completed to the host in the regular path.
+	 */
+	switch (task_notification_selection) {
+	case isci_perform_normal_io_completion:
+		/* Normal notification (task_done) */
+		dev_dbg(task->dev->port->ha->dev,
+			"%s: Normal - task = %p, response=%d, status=%d\n",
+			__func__, task, response, status);
+		task->task_done(task);
+		task->lldd_task = NULL;
+		break;
+
+	case isci_perform_aborted_io_completion:
+		/* No notification because this request is already in the
+		 * abort path.
+		 */
+		dev_warn(task->dev->port->ha->dev,
+			 "%s: Aborted - task = %p, response=%d, status=%d\n",
+			 __func__, task, response, status);
+		break;
+
+	case isci_perform_error_io_completion:
+		/* Use sas_task_abort */
+		dev_warn(task->dev->port->ha->dev,
+			 "%s: Error - task = %p, response=%d, status=%d\n",
+			 __func__, task, response, status);
+		sas_task_abort(task);
+		break;
+
+	default:
+		dev_warn(task->dev->port->ha->dev,
+			 "%s: isci task notification default case!",
+			 __func__);
+		sas_task_abort(task);
+		break;
+	}
+}
+
+#endif /* !defined(_SCI_TASK_H_) */
