commit 362b5da3dfceada6e74ecdd7af3991bbe42c0c0f
Author: Nathan Chancellor <natechancellor@gmail.com>
Date:   Wed Sep 26 17:12:00 2018 -0700

    scsi: isci: Change sci_controller_start_task's return type to sci_status
    
    Clang warns when an enumerated type is implicitly converted to another.
    
    drivers/scsi/isci/request.c:3476:13: warning: implicit conversion from
    enumeration type 'enum sci_task_status' to different enumeration type
    'enum sci_status' [-Wenum-conversion]
                            status = sci_controller_start_task(ihost,
                                   ~ ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    drivers/scsi/isci/host.c:2744:10: warning: implicit conversion from
    enumeration type 'enum sci_status' to different enumeration type 'enum
    sci_task_status' [-Wenum-conversion]
                    return SCI_SUCCESS;
                    ~~~~~~ ^~~~~~~~~~~
    drivers/scsi/isci/host.c:2753:9: warning: implicit conversion from
    enumeration type 'enum sci_status' to different enumeration type 'enum
    sci_task_status' [-Wenum-conversion]
            return status;
            ~~~~~~ ^~~~~~
    
    Avoid all of these implicit conversion by just making
    sci_controller_start_task use sci_status. This silences
    Clang and has no functional change since sci_task_status
    has all of its values mapped to something in sci_status.
    
    Link: https://github.com/ClangBuiltLinux/linux/issues/153
    Signed-off-by: Nathan Chancellor <natechancellor@gmail.com>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/isci/host.h b/drivers/scsi/isci/host.h
index b3539928073c..6bc3f022630a 100644
--- a/drivers/scsi/isci/host.h
+++ b/drivers/scsi/isci/host.h
@@ -489,7 +489,7 @@ enum sci_status sci_controller_start_io(
 	struct isci_remote_device *idev,
 	struct isci_request *ireq);
 
-enum sci_task_status sci_controller_start_task(
+enum sci_status sci_controller_start_task(
 	struct isci_host *ihost,
 	struct isci_remote_device *idev,
 	struct isci_request *ireq);

commit e3cb0e47b9233a42f8c5865ad748666b6bbbc12f
Author: Christoph Hellwig <hch@lst.de>
Date:   Wed Nov 30 17:21:01 2016 +0100

    scsi: isci: switch to pci_alloc_irq_vectors
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Reviewed-by: Artur Paszkiewicz <artur.paszkiewicz@intel.com>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/isci/host.h b/drivers/scsi/isci/host.h
index 22a9bb1abae1..b3539928073c 100644
--- a/drivers/scsi/isci/host.h
+++ b/drivers/scsi/isci/host.h
@@ -295,7 +295,6 @@ enum sci_controller_states {
 #define SCI_MAX_MSIX_INT (SCI_NUM_MSI_X_INT*SCI_MAX_CONTROLLERS)
 
 struct isci_pci_info {
-	struct msix_entry msix_entries[SCI_MAX_MSIX_INT];
 	struct isci_host *hosts[SCI_MAX_CONTROLLERS];
 	struct isci_orom *orom;
 };

commit c59053a23d586675c25d789a7494adfdc02fba57
Author: Lukasz Dorau <lukasz.dorau@intel.com>
Date:   Thu Feb 6 12:23:20 2014 -0800

    [SCSI] isci: correct erroneous for_each_isci_host macro
    
    In the first place, the loop 'for' in the macro 'for_each_isci_host'
    (drivers/scsi/isci/host.h:314) is incorrect, because it accesses
    the 3rd element of 2 element array. After the 2nd iteration it executes
    the instruction:
            ihost = to_pci_info(pdev)->hosts[2]
    (while the size of the 'hosts' array equals 2) and reads an
    out of range element.
    
    In the second place, this loop is incorrectly optimized by GCC v4.8
    (see http://marc.info/?l=linux-kernel&m=138998871911336&w=2).
    As a result, on platforms with two SCU controllers,
    the loop is executed more times than it can be (for i=0,1 and 2).
    It causes kernel panic during entering the S3 state
    and the following oops after 'rmmod isci':
    
    BUG: unable to handle kernel NULL pointer dereference at (null)
    IP: [<ffffffff8131360b>] __list_add+0x1b/0xc0
    Oops: 0000 [#1] SMP
    RIP: 0010:[<ffffffff8131360b>]  [<ffffffff8131360b>] __list_add+0x1b/0xc0
    Call Trace:
      [<ffffffff81661b84>] __mutex_lock_slowpath+0x114/0x1b0
      [<ffffffff81661c3f>] mutex_lock+0x1f/0x30
      [<ffffffffa03e97cb>] sas_disable_events+0x1b/0x50 [libsas]
      [<ffffffffa03e9818>] sas_unregister_ha+0x18/0x60 [libsas]
      [<ffffffffa040316e>] isci_unregister+0x1e/0x40 [isci]
      [<ffffffffa0403efd>] isci_pci_remove+0x5d/0x100 [isci]
      [<ffffffff813391cb>] pci_device_remove+0x3b/0xb0
      [<ffffffff813fbf7f>] __device_release_driver+0x7f/0xf0
      [<ffffffff813fc8f8>] driver_detach+0xa8/0xb0
      [<ffffffff813fbb8b>] bus_remove_driver+0x9b/0x120
      [<ffffffff813fcf2c>] driver_unregister+0x2c/0x50
      [<ffffffff813381f3>] pci_unregister_driver+0x23/0x80
      [<ffffffffa04152f8>] isci_exit+0x10/0x1e [isci]
      [<ffffffff810d199b>] SyS_delete_module+0x16b/0x2d0
      [<ffffffff81012a21>] ? do_notify_resume+0x61/0xa0
      [<ffffffff8166ce29>] system_call_fastpath+0x16/0x1b
    
    The loop has been corrected.
    This patch fixes kernel panic during entering the S3 state
    and the above oops.
    
    Signed-off-by: Lukasz Dorau <lukasz.dorau@intel.com>
    Reviewed-by: Maciej Patelczyk <maciej.patelczyk@intel.com>
    Tested-by: Lukasz Dorau <lukasz.dorau@intel.com>
    Cc: <stable@vger.kernel.org>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>
    Signed-off-by: James Bottomley <JBottomley@Parallels.com>

diff --git a/drivers/scsi/isci/host.h b/drivers/scsi/isci/host.h
index 4911310a38f5..22a9bb1abae1 100644
--- a/drivers/scsi/isci/host.h
+++ b/drivers/scsi/isci/host.h
@@ -311,9 +311,8 @@ static inline struct Scsi_Host *to_shost(struct isci_host *ihost)
 }
 
 #define for_each_isci_host(id, ihost, pdev) \
-	for (id = 0, ihost = to_pci_info(pdev)->hosts[id]; \
-	     id < ARRAY_SIZE(to_pci_info(pdev)->hosts) && ihost; \
-	     ihost = to_pci_info(pdev)->hosts[++id])
+	for (id = 0; id < SCI_MAX_CONTROLLERS && \
+	     (ihost = to_pci_info(pdev)->hosts[id]); id++)
 
 static inline void wait_for_start(struct isci_host *ihost)
 {

commit e468dc112f38220ee78bc0de64190eca9812749b
Author: Artur Wojcik <artur.wojcik@intel.com>
Date:   Thu Jun 21 23:41:56 2012 -0700

    [SCSI] isci: implement suspend/resume support
    
    Provide a "simple-dev-pm-ops" implementation that shuts down the domain
    and the device on suspend, and resumes the device and the domain on
    resume.  All of the mechanics of restoring domain connectivity are
    handled by libsas once isci has notified libsas that all links should be
    back up.  libsas is in charge of handling links that did not resume, or
    resumed out of order.
    
    Signed-off-by: Artur Wojcik <artur.wojcik@intel.com>
    Signed-off-by: Jacek Danecki <jacek.danecki@intel.com>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>
    Signed-off-by: James Bottomley <JBottomley@Parallels.com>

diff --git a/drivers/scsi/isci/host.h b/drivers/scsi/isci/host.h
index 9ab58e0540e7..4911310a38f5 100644
--- a/drivers/scsi/isci/host.h
+++ b/drivers/scsi/isci/host.h
@@ -473,7 +473,7 @@ void sci_controller_remote_device_stopped(struct isci_host *ihost,
 
 enum sci_status sci_controller_continue_io(struct isci_request *ireq);
 int isci_host_scan_finished(struct Scsi_Host *, unsigned long);
-void isci_host_scan_start(struct Scsi_Host *);
+void isci_host_start(struct Scsi_Host *);
 u16 isci_alloc_tag(struct isci_host *ihost);
 enum sci_status isci_free_tag(struct isci_host *ihost, u16 io_tag);
 void isci_tci_free(struct isci_host *ihost, u16 tci);

commit de2eb4d5c5c25e8fb75d1e19092f24b83cb7d8d5
Author: Jeff Skirvin <jeffrey.d.skirvin@intel.com>
Date:   Tue Mar 13 17:15:11 2012 -0700

    isci: End the RNC resumption wait when the RNC is destroyed.
    
    While the RNC is suspended for I/O cleanup, the remote device can be
    stopped and the RNC setup for destruction.  These changes accomodate that
    case in the abort path.
    
    Signed-off-by: Jeff Skirvin <jeffrey.d.skirvin@intel.com>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/drivers/scsi/isci/host.h b/drivers/scsi/isci/host.h
index 8e8b46322c64..9ab58e0540e7 100644
--- a/drivers/scsi/isci/host.h
+++ b/drivers/scsi/isci/host.h
@@ -340,6 +340,11 @@ static inline struct isci_host *dev_to_ihost(struct domain_device *dev)
 	return dev->port->ha->lldd_ha;
 }
 
+static inline struct isci_host *idev_to_ihost(struct isci_remote_device *idev)
+{
+	return dev_to_ihost(idev->domain_dev);
+}
+
 /* we always use protocol engine group zero */
 #define ISCI_PEG 0
 

commit f8381807ebdfffa34c2c5aa38eda33673d1a7adf
Author: Jeff Skirvin <jeffrey.d.skirvin@intel.com>
Date:   Sun Mar 4 12:44:53 2012 +0000

    isci: Remove obviated host callback list.
    
    Since the callbacks to libsas now occur under scic_lock, there is no
    longer any reason to save the completed requests in a separate list
    for completion to libsas.
    
    Signed-off-by: Jeff Skirvin <jeffrey.d.skirvin@intel.com>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/drivers/scsi/isci/host.h b/drivers/scsi/isci/host.h
index eaa13c0be09a..8e8b46322c64 100644
--- a/drivers/scsi/isci/host.h
+++ b/drivers/scsi/isci/host.h
@@ -204,7 +204,6 @@ struct isci_host {
 	unsigned long flags;
 	wait_queue_head_t eventq;
 	struct tasklet_struct completion_tasklet;
-	struct list_head requests_to_complete;
 	spinlock_t scic_lock;
 	struct isci_request *reqs[SCI_MAX_IO_REQUESTS];
 	struct isci_remote_device devices[SCI_MAX_REMOTE_DEVICES];
@@ -473,6 +472,7 @@ void isci_host_scan_start(struct Scsi_Host *);
 u16 isci_alloc_tag(struct isci_host *ihost);
 enum sci_status isci_free_tag(struct isci_host *ihost, u16 io_tag);
 void isci_tci_free(struct isci_host *ihost, u16 tci);
+void ireq_done(struct isci_host *ihost, struct isci_request *ireq, struct sas_task *task);
 
 int isci_host_init(struct isci_host *);
 void isci_host_completion_routine(unsigned long data);

commit 14aaa9f0a318bd04cbb9d822524b817e95d8b343
Author: Jeff Skirvin <jeffrey.d.skirvin@intel.com>
Date:   Thu Mar 8 22:41:54 2012 -0800

    isci: Redesign device suspension, abort, cleanup.
    
    This commit changes the means by which outstanding I/Os are handled
    for cleanup.
    The likelihood is that this commit will be broken into smaller pieces,
    however that will be a later revision.  Among the changes:
    
    - All completion structures have been removed from the tmf and
    abort paths.
    - Now using one completed I/O list, with the I/O completed in host bit being
    used to select error or normal callback paths.
    
    Signed-off-by: Jeff Skirvin <jeffrey.d.skirvin@intel.com>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/drivers/scsi/isci/host.h b/drivers/scsi/isci/host.h
index 7272a0a375f2..eaa13c0be09a 100644
--- a/drivers/scsi/isci/host.h
+++ b/drivers/scsi/isci/host.h
@@ -205,7 +205,6 @@ struct isci_host {
 	wait_queue_head_t eventq;
 	struct tasklet_struct completion_tasklet;
 	struct list_head requests_to_complete;
-	struct list_head requests_to_errorback;
 	spinlock_t scic_lock;
 	struct isci_request *reqs[SCI_MAX_IO_REQUESTS];
 	struct isci_remote_device devices[SCI_MAX_REMOTE_DEVICES];

commit d1dc5e2d21a55538167d7ce82aa147c91c5e6788
Author: Dan Williams <dan.j.williams@intel.com>
Date:   Sat Feb 25 14:29:49 2012 -0800

    isci: kill isci_host.shost
    
    We can retrieve the shost from the sas_ha like the rest of libsas and
    drop this out of our local data structure.
    
    Acked-by: Jacek Danecki <jacek.danecki@intel.com>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/drivers/scsi/isci/host.h b/drivers/scsi/isci/host.h
index 9701c1d673ba..7272a0a375f2 100644
--- a/drivers/scsi/isci/host.h
+++ b/drivers/scsi/isci/host.h
@@ -203,7 +203,6 @@ struct isci_host {
 	#define IHOST_IRQ_ENABLED 2
 	unsigned long flags;
 	wait_queue_head_t eventq;
-	struct Scsi_Host *shost;
 	struct tasklet_struct completion_tasklet;
 	struct list_head requests_to_complete;
 	struct list_head requests_to_errorback;
@@ -308,6 +307,11 @@ static inline struct isci_pci_info *to_pci_info(struct pci_dev *pdev)
 	return pci_get_drvdata(pdev);
 }
 
+static inline struct Scsi_Host *to_shost(struct isci_host *ihost)
+{
+	return ihost->sas_ha.core.shost;
+}
+
 #define for_each_isci_host(id, ihost, pdev) \
 	for (id = 0, ihost = to_pci_info(pdev)->hosts[id]; \
 	     id < ARRAY_SIZE(to_pci_info(pdev)->hosts) && ihost; \

commit 2396a2650a5a39634e3ad6b29e1104944e5ab88f
Author: Dan Williams <dan.j.williams@intel.com>
Date:   Thu Mar 1 17:06:24 2012 -0800

    isci: fix interrupt disable
    
    There is a (dubious?) lost irq workaround in sci_controller_isr() that
    effectively nullifies attempts to disable interrupts.  Until the
    workaround can be re-evaluated add some infrastructure to prevent the
    interrupt handler from inadvertantly re-enabling interrupts.
    
    The failure mode was interrupts continuing to run after the driver had
    been removed and its iomappings torn down.
    
    Reported-by: Jacek Danecki <jacek.danecki@intel.com>
    Tested-by: Jacek Danecki <jacek.danecki@intel.com>
    [richard: clear remaining interrupts at the end of reset]
    Acked-by: Richard Boyd <richard.g.boyd@intel.com>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/drivers/scsi/isci/host.h b/drivers/scsi/isci/host.h
index 9dc910b9d921..9701c1d673ba 100644
--- a/drivers/scsi/isci/host.h
+++ b/drivers/scsi/isci/host.h
@@ -200,6 +200,7 @@ struct isci_host {
 	struct pci_dev *pdev;
 	#define IHOST_START_PENDING 0
 	#define IHOST_STOP_PENDING 1
+	#define IHOST_IRQ_ENABLED 2
 	unsigned long flags;
 	wait_queue_head_t eventq;
 	struct Scsi_Host *shost;

commit 50a92d93148ec073efd2456b007e04ecae452086
Author: Dan Williams <dan.j.williams@intel.com>
Date:   Wed Feb 29 01:07:56 2012 -0800

    isci: fix 'link-up' events occur after 'start-complete'
    
    The call to wait_for_start() is meant to ensure that all links have been
    given a chance to come up before letting the kernel proceed with
    probing.  However, the implementation is not correctly syncing with the
    port configuration agent.  In the MPC case the ports are hard-coded, in
    the APC case we need to wait for the port-configuration to form ports
    from the started phys.
    
    Towards that end increase the timeout for the APC agent to form ports,
    and delay start complete until all phys are out of link-training.
    
    Cc: <stable@vger.kernel.org>
    Cc: Richard Boyd <richard.g.boyd@intel.com>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/drivers/scsi/isci/host.h b/drivers/scsi/isci/host.h
index a89c0e3c5a14..9dc910b9d921 100644
--- a/drivers/scsi/isci/host.h
+++ b/drivers/scsi/isci/host.h
@@ -109,6 +109,8 @@ struct sci_port_configuration_agent;
 typedef void (*port_config_fn)(struct isci_host *,
 			       struct sci_port_configuration_agent *,
 			       struct isci_port *, struct isci_phy *);
+bool is_port_config_apc(struct isci_host *ihost);
+bool is_controller_start_complete(struct isci_host *ihost);
 
 struct sci_port_configuration_agent {
 	u16 phy_configured_mask;
@@ -473,6 +475,7 @@ void isci_host_completion_routine(unsigned long data);
 void isci_host_deinit(struct isci_host *);
 void sci_controller_disable_interrupts(struct isci_host *ihost);
 bool sci_controller_has_remote_devices_stopping(struct isci_host *ihost);
+void sci_controller_transition_to_ready(struct isci_host *ihost, enum sci_status status);
 
 enum sci_status sci_controller_start_io(
 	struct isci_host *ihost,

commit eb608c3cb3f0a6b99252ea6a69fc0d2bbecf1f4f
Author: Dan Williams <dan.j.williams@intel.com>
Date:   Thu Feb 23 01:12:10 2012 -0800

    isci: fix controller stop
    
    1/ notify waiters when controller stop completes (fixes 10 second stall
       unloading the driver)
    2/ make sure phy stop is after port and device stop
    
    Cc: Richard Boyd <richard.g.boyd@intel.com>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/drivers/scsi/isci/host.h b/drivers/scsi/isci/host.h
index 4695162f406e..a89c0e3c5a14 100644
--- a/drivers/scsi/isci/host.h
+++ b/drivers/scsi/isci/host.h
@@ -276,13 +276,6 @@ enum sci_controller_states {
 	 */
 	SCIC_STOPPING,
 
-	/**
-	 * This state indicates that the controller has successfully been stopped.
-	 * In this state no new IO operations are permitted.
-	 * This state is entered from the STOPPING state.
-	 */
-	SCIC_STOPPED,
-
 	/**
 	 * This state indicates that the controller could not successfully be
 	 * initialized.  In this state no new IO operations are permitted.
@@ -479,6 +472,7 @@ int isci_host_init(struct isci_host *);
 void isci_host_completion_routine(unsigned long data);
 void isci_host_deinit(struct isci_host *);
 void sci_controller_disable_interrupts(struct isci_host *ihost);
+bool sci_controller_has_remote_devices_stopping(struct isci_host *ihost);
 
 enum sci_status sci_controller_start_io(
 	struct isci_host *ihost,

commit abec912d71c44bbd642ce12ad98aab76f5a53163
Author: Dan Williams <dan.j.williams@intel.com>
Date:   Wed Feb 15 13:58:42 2012 -0800

    isci: refactor initialization for S3/S4
    
    Based on an original implementation by Ed Nadolski and Artur Wojcik
    
    In preparation for S3/S4 support refactor initialization so that
    driver-load and resume-from-suspend can share the common init path of
    isci_host_init().  Organize the initialization into objects that are
    self-contained to the driver (initialized by isci_host_init) versus
    those that have some upward registration (initialized at allocation time
    asd_sas_phy, asd_sas_port, dma allocations).  The largest change is
    moving the the validation of the oem and module parameters from
    isci_host_init() to isci_host_alloc().
    
    The S3/S4 approach being taken is that libsas will be tasked with
    remembering the state of the domain and the lldd is free to be
    forgetful.  In the case of isci we'll just re-init using a subset of the
    normal driver load path.
    
    [clean up some unused / mis-indented function definitions in host.h]
    
    Signed-off-by: Ed Nadolski <edmund.nadolski@intel.com>
    Signed-off-by: Artur Wojcik <artur.wojcik@intel.com>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/drivers/scsi/isci/host.h b/drivers/scsi/isci/host.h
index 81485b4a1a51..4695162f406e 100644
--- a/drivers/scsi/isci/host.h
+++ b/drivers/scsi/isci/host.h
@@ -158,13 +158,17 @@ struct isci_host {
 	struct sci_power_control power_control;
 	u8 io_request_sequence[SCI_MAX_IO_REQUESTS];
 	struct scu_task_context *task_context_table;
-	dma_addr_t task_context_dma;
+	dma_addr_t tc_dma;
 	union scu_remote_node_context *remote_node_context_table;
+	dma_addr_t rnc_dma;
 	u32 *completion_queue;
+	dma_addr_t cq_dma;
 	u32 completion_queue_get;
 	u32 logical_port_entries;
 	u32 remote_node_entries;
 	u32 task_context_entries;
+	void *ufi_buf;
+	dma_addr_t ufi_dma;
 	struct sci_unsolicited_frame_control uf_control;
 
 	/* phy startup */
@@ -452,36 +456,17 @@ void sci_controller_free_remote_node_context(
 	struct isci_remote_device *idev,
 	u16 node_id);
 
-struct isci_request *sci_request_by_tag(struct isci_host *ihost,
-					     u16 io_tag);
-
-void sci_controller_power_control_queue_insert(
-	struct isci_host *ihost,
-	struct isci_phy *iphy);
-
-void sci_controller_power_control_queue_remove(
-	struct isci_host *ihost,
-	struct isci_phy *iphy);
-
-void sci_controller_link_up(
-	struct isci_host *ihost,
-	struct isci_port *iport,
-	struct isci_phy *iphy);
-
-void sci_controller_link_down(
-	struct isci_host *ihost,
-	struct isci_port *iport,
-	struct isci_phy *iphy);
-
-void sci_controller_remote_device_stopped(
-	struct isci_host *ihost,
-	struct isci_remote_device *idev);
-
-void sci_controller_copy_task_context(
-	struct isci_host *ihost,
-	struct isci_request *ireq);
-
-void sci_controller_register_setup(struct isci_host *ihost);
+struct isci_request *sci_request_by_tag(struct isci_host *ihost, u16 io_tag);
+void sci_controller_power_control_queue_insert(struct isci_host *ihost,
+					       struct isci_phy *iphy);
+void sci_controller_power_control_queue_remove(struct isci_host *ihost,
+					       struct isci_phy *iphy);
+void sci_controller_link_up(struct isci_host *ihost, struct isci_port *iport,
+			    struct isci_phy *iphy);
+void sci_controller_link_down(struct isci_host *ihost, struct isci_port *iport,
+			      struct isci_phy *iphy);
+void sci_controller_remote_device_stopped(struct isci_host *ihost,
+					  struct isci_remote_device *idev);
 
 enum sci_status sci_controller_continue_io(struct isci_request *ireq);
 int isci_host_scan_finished(struct Scsi_Host *, unsigned long);
@@ -491,27 +476,9 @@ enum sci_status isci_free_tag(struct isci_host *ihost, u16 io_tag);
 void isci_tci_free(struct isci_host *ihost, u16 tci);
 
 int isci_host_init(struct isci_host *);
-
-void isci_host_init_controller_names(
-	struct isci_host *isci_host,
-	unsigned int controller_idx);
-
-void isci_host_deinit(
-	struct isci_host *);
-
-void isci_host_port_link_up(
-	struct isci_host *,
-	struct isci_port *,
-	struct isci_phy *);
-int isci_host_dev_found(struct domain_device *);
-
-void isci_host_remote_device_start_complete(
-	struct isci_host *,
-	struct isci_remote_device *,
-	enum sci_status);
-
-void sci_controller_disable_interrupts(
-	struct isci_host *ihost);
+void isci_host_completion_routine(unsigned long data);
+void isci_host_deinit(struct isci_host *);
+void sci_controller_disable_interrupts(struct isci_host *ihost);
 
 enum sci_status sci_controller_start_io(
 	struct isci_host *ihost,

commit 1844e4789fe5c97a9ff3bb82628111abbe7cc846
Author: Dan Williams <dan.j.williams@intel.com>
Date:   Wed Feb 15 13:20:31 2012 -0800

    isci: kill ->status, and ->state_lock in isci_host
    
    They serve no incremental purpose over the existing sas_ha state.
    
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/drivers/scsi/isci/host.h b/drivers/scsi/isci/host.h
index a9679ee7084b..81485b4a1a51 100644
--- a/drivers/scsi/isci/host.h
+++ b/drivers/scsi/isci/host.h
@@ -191,9 +191,7 @@ struct isci_host {
 	struct asd_sas_port sas_ports[SCI_MAX_PORTS];
 	struct sas_ha_struct sas_ha;
 
-	spinlock_t state_lock;
 	struct pci_dev *pdev;
-	enum isci_status status;
 	#define IHOST_START_PENDING 0
 	#define IHOST_STOP_PENDING 1
 	unsigned long flags;
@@ -315,27 +313,6 @@ static inline struct isci_pci_info *to_pci_info(struct pci_dev *pdev)
 	     id < ARRAY_SIZE(to_pci_info(pdev)->hosts) && ihost; \
 	     ihost = to_pci_info(pdev)->hosts[++id])
 
-static inline enum isci_status isci_host_get_state(struct isci_host *isci_host)
-{
-	return isci_host->status;
-}
-
-static inline void isci_host_change_state(struct isci_host *isci_host,
-					  enum isci_status status)
-{
-	unsigned long flags;
-
-	dev_dbg(&isci_host->pdev->dev,
-		"%s: isci_host = %p, state = 0x%x",
-		__func__,
-		isci_host,
-		status);
-	spin_lock_irqsave(&isci_host->state_lock, flags);
-	isci_host->status = status;
-	spin_unlock_irqrestore(&isci_host->state_lock, flags);
-
-}
-
 static inline void wait_for_start(struct isci_host *ihost)
 {
 	wait_event(ihost->eventq, !test_bit(IHOST_START_PENDING, &ihost->flags));

commit 11cc51835af0e6fbb2da9cb012bdaaa036497b7f
Author: Dan Williams <dan.j.williams@intel.com>
Date:   Wed Feb 1 00:23:10 2012 -0800

    isci: kill ->is_direct_attached
    
    domain_device ->parent conveys the same information.
    
    Occurrences of ->is_direct_attached appear next to incomplete open-coded
    versions of dev_is_sata(), clean those up as well.
    
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/drivers/scsi/isci/host.h b/drivers/scsi/isci/host.h
index adbad69d1069..a9679ee7084b 100644
--- a/drivers/scsi/isci/host.h
+++ b/drivers/scsi/isci/host.h
@@ -55,6 +55,7 @@
 #ifndef _SCI_HOST_H_
 #define _SCI_HOST_H_
 
+#include <scsi/sas_ata.h>
 #include "remote_device.h"
 #include "phy.h"
 #include "isci.h"
@@ -378,8 +379,7 @@ static inline int sci_remote_device_node_count(struct isci_remote_device *idev)
 {
 	struct domain_device *dev = idev->domain_dev;
 
-	if ((dev->dev_type == SATA_DEV || (dev->tproto & SAS_PROTOCOL_STP)) &&
-	    !idev->is_direct_attached)
+	if (dev_is_sata(dev) && dev->parent)
 		return SCU_STP_REMOTE_NODE_COUNT;
 	return SCU_SSP_REMOTE_NODE_COUNT;
 }

commit c132f692085ac624d7c8123df781846c8dcb3166
Author: Dan Williams <dan.j.williams@intel.com>
Date:   Tue Jan 3 23:26:08 2012 -0800

    [SCSI] isci: kill iphy->isci_port lookups
    
    This field is a holdover from the OS abstraction conversion.  The stable
    phy to port lookups are done via iphy->ownining_port under scic_lock.
    After this conversion to use port->lldd_port the only volatile lookup is
    the initial lookup in isci_port_formed().  After that point any lookup
    via a successfully notified domain_device is guaranteed to be valid
    until the domain_device is destroyed.
    
    Delete ->start_complete as it is only set once and is set as a
    consequence of the port going link up, by definition of getting a port
    formed event the port is "ready".
    
    While we are correcting port lookups also move the asd_sas_port table
    out from under the isci_port.  This is to preclude any temptation to use
    container_of() to convert an asd_sas_port to an isci_port, the
    association is dynamic and under libsas control.
    
    Tested-by: Maciej Trela <maciej.trela@intel.com>
    [dmilburn@redhat.com: fix i686 compile error]
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>
    Signed-off-by: James Bottomley <JBottomley@Parallels.com>

diff --git a/drivers/scsi/isci/host.h b/drivers/scsi/isci/host.h
index 5477f0fa8233..adbad69d1069 100644
--- a/drivers/scsi/isci/host.h
+++ b/drivers/scsi/isci/host.h
@@ -187,6 +187,7 @@ struct isci_host {
 	int id; /* unique within a given pci device */
 	struct isci_phy phys[SCI_MAX_PHYS];
 	struct isci_port ports[SCI_MAX_PORTS + 1]; /* includes dummy port */
+	struct asd_sas_port sas_ports[SCI_MAX_PORTS];
 	struct sas_ha_struct sas_ha;
 
 	spinlock_t state_lock;
@@ -393,24 +394,6 @@ static inline int sci_remote_device_node_count(struct isci_remote_device *idev)
 #define sci_controller_clear_invalid_phy(controller, phy) \
 	((controller)->invalid_phy_mask &= ~(1 << (phy)->phy_index))
 
-static inline struct device *sciphy_to_dev(struct isci_phy *iphy)
-{
-
-	if (!iphy || !iphy->isci_port || !iphy->isci_port->isci_host)
-		return NULL;
-
-	return &iphy->isci_port->isci_host->pdev->dev;
-}
-
-static inline struct device *sciport_to_dev(struct isci_port *iport)
-{
-
-	if (!iport || !iport->isci_host)
-		return NULL;
-
-	return &iport->isci_host->pdev->dev;
-}
-
 static inline struct device *scirdev_to_dev(struct isci_remote_device *idev)
 {
 	if (!idev || !idev->isci_port || !idev->isci_port->isci_host)

commit 9fee607f0b29adabd72265a847b8e421dff10d66
Author: Jeff Skirvin <jeffrey.d.skirvin@intel.com>
Date:   Wed Jan 4 01:32:49 2012 -0800

    [SCSI] isci: oem parameter format v1.3 (cable select)
    
    v1.3 allows the attenuation of the attached cables to be specified to
    the driver in terms of 'short', 'medium', and 'long' (see probe_roms.h).
    These settings (per phy) are retrieved from the platform oem-parameters
    (BIOS rom) or via a module parameter override.
    
    Reviewed-by: Jiangbi Liu <jiangbi.liu@intel.com>
    Signed-off-by: Jeff Skirvin <jeffrey.d.skirvin@intel.com>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>
    Signed-off-by: James Bottomley <JBottomley@Parallels.com>

diff --git a/drivers/scsi/isci/host.h b/drivers/scsi/isci/host.h
index 4573075a6b97..5477f0fa8233 100644
--- a/drivers/scsi/isci/host.h
+++ b/drivers/scsi/isci/host.h
@@ -447,6 +447,24 @@ static inline bool is_c1(struct pci_dev *pdev)
 	return false;
 }
 
+enum cable_selections {
+	short_cable     = 0,
+	long_cable      = 1,
+	medium_cable    = 2,
+	undefined_cable = 3
+};
+
+#define CABLE_OVERRIDE_DISABLED (0x10000)
+
+static inline int is_cable_select_overridden(void)
+{
+	return cable_selection_override < CABLE_OVERRIDE_DISABLED;
+}
+
+enum cable_selections decode_cable_selection(struct isci_host *ihost, int phy);
+void validate_cable_selections(struct isci_host *ihost);
+char *lookup_cable_names(enum cable_selections);
+
 /* set hw control for 'activity', even though active enclosures seem to drive
  * the activity led on their own.  Skip setting FSENG control on 'status' due
  * to unexpected operation and 'error' due to not being a supported automatic

commit afd13a1f2b05157c7621d87dfe89ea6ea9061bd8
Author: Jeff Skirvin <jeffrey.d.skirvin@intel.com>
Date:   Wed Jan 4 01:32:39 2012 -0800

    [SCSI] isci: update afe (analog-front-end) recipe for C1
    
    C1 silicon requires updates to the phy tuning recipe and also support
    for user provided cable selects (per-phy) for short, medium, and long
    cables.  Default to 'short' awaiting support for selecting the cable via
    oem parameters.
    
    Reviewed-by: Jiangbi Liu <jiangbi.liu@intel.com>
    Signed-off-by: Marcin Tomczak <marcin.tomczak@intel.com>
    Signed-off-by: Jeff Skirvin <jeffrey.d.skirvin@intel.com>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>
    Signed-off-by: James Bottomley <JBottomley@Parallels.com>

diff --git a/drivers/scsi/isci/host.h b/drivers/scsi/isci/host.h
index 646051afd3cb..4573075a6b97 100644
--- a/drivers/scsi/isci/host.h
+++ b/drivers/scsi/isci/host.h
@@ -435,7 +435,14 @@ static inline bool is_b0(struct pci_dev *pdev)
 
 static inline bool is_c0(struct pci_dev *pdev)
 {
-	if (pdev->revision >= 5)
+	if (pdev->revision == 5)
+		return true;
+	return false;
+}
+
+static inline bool is_c1(struct pci_dev *pdev)
+{
+	if (pdev->revision >= 6)
 		return true;
 	return false;
 }

commit ad4f4c1de80abdda5d55315289505598aa78e355
Author: Dan Williams <dan.j.williams@intel.com>
Date:   Thu Sep 1 21:18:31 2011 -0700

    [SCSI] isci: initial sgpio write support
    
    Basic support to initialize the gpio unit, accept an incomming
    SAS_GPIO_REG_TX_GP bitstream, and translate it to the ODx.n fields in
    the hardware registers.  If register indexes outside the supported range
    are specified in the SMP frame we simply accept the write and return how
    many registers (SFF-8485) were written (libsas reports this as residue
    in the request).
    
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>
    Signed-off-by: James Bottomley <JBottomley@Parallels.com>

diff --git a/drivers/scsi/isci/host.h b/drivers/scsi/isci/host.h
index 9f33831a2f04..646051afd3cb 100644
--- a/drivers/scsi/isci/host.h
+++ b/drivers/scsi/isci/host.h
@@ -440,6 +440,18 @@ static inline bool is_c0(struct pci_dev *pdev)
 	return false;
 }
 
+/* set hw control for 'activity', even though active enclosures seem to drive
+ * the activity led on their own.  Skip setting FSENG control on 'status' due
+ * to unexpected operation and 'error' due to not being a supported automatic
+ * FSENG output
+ */
+#define SGPIO_HW_CONTROL 0x00000443
+
+static inline int isci_gpio_count(struct isci_host *ihost)
+{
+	return ARRAY_SIZE(ihost->scu_registers->peg0.sgpio.output_data_select);
+}
+
 void sci_controller_post_request(struct isci_host *ihost,
 				      u32 request);
 void sci_controller_release_frame(struct isci_host *ihost,
@@ -542,4 +554,7 @@ void sci_port_configuration_agent_construct(
 enum sci_status sci_port_configuration_agent_initialize(
 	struct isci_host *ihost,
 	struct sci_port_configuration_agent *port_agent);
+
+int isci_gpio_write(struct sas_ha_struct *, u8 reg_type, u8 reg_index,
+		    u8 reg_count, u8 *write_data);
 #endif

commit 9b4be528999483d70a1ffc0accd102e477d5a503
Author: Dan Williams <dan.j.williams@intel.com>
Date:   Fri Jul 29 17:17:10 2011 -0700

    [SCSI] isci: dynamic interrupt coalescing
    
    Hardware allows both an outstanding number commands and a timeout value
    (whichever occurs first) as a gate to the next interrupt generation.  This
    scheme at completion time looks at the remaining number of outstanding tasks
    and sets the timeout to maximize small transaction operation.  If transactions
    are large (take more than a few 10s of microseconds to complete) then
    performance is not interrupt processing bound, so the small timeouts this
    scheme generates are overridden by the time it takes for a completion to
    arrive.
    
    Tested-by: Dave Jiang <dave.jiang@intel.com>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>
    Signed-off-by: James Bottomley <JBottomley@Parallels.com>

diff --git a/drivers/scsi/isci/host.h b/drivers/scsi/isci/host.h
index 062101a39f79..9f33831a2f04 100644
--- a/drivers/scsi/isci/host.h
+++ b/drivers/scsi/isci/host.h
@@ -369,6 +369,9 @@ static inline struct isci_host *dev_to_ihost(struct domain_device *dev)
 #define ISCI_TAG_SEQ(tag) (((tag) >> 12) & (SCI_MAX_SEQ-1))
 #define ISCI_TAG_TCI(tag) ((tag) & (SCI_MAX_IO_REQUESTS-1))
 
+/* interrupt coalescing baseline: 9 == 3 to 5us interrupt delay per command */
+#define ISCI_COALESCE_BASE 9
+
 /* expander attached sata devices require 3 rnc slots */
 static inline int sci_remote_device_node_count(struct isci_remote_device *idev)
 {

commit dc00c8b6940aa10ab1ce6a4d10b1bfe7b848781b
Author: Dan Williams <dan.j.williams@intel.com>
Date:   Fri Jul 1 11:41:21 2011 -0700

    isci: cleanup silicon revision detection
    
    Perform checking per-pci device (even though all systems will only have
    1 pci device in this generation), and delete support for silicon that
    does not report a proper revision (i.e. A0).
    
    Reported-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/drivers/scsi/isci/host.h b/drivers/scsi/isci/host.h
index ec0bba5367ba..062101a39f79 100644
--- a/drivers/scsi/isci/host.h
+++ b/drivers/scsi/isci/host.h
@@ -416,33 +416,25 @@ static inline struct device *scirdev_to_dev(struct isci_remote_device *idev)
 	return &idev->isci_port->isci_host->pdev->dev;
 }
 
-enum {
-	ISCI_SI_REVA0,
-	ISCI_SI_REVA2,
-	ISCI_SI_REVB0,
-	ISCI_SI_REVC0
-};
-
-extern int isci_si_rev;
-
-static inline bool is_a0(void)
-{
-	return isci_si_rev == ISCI_SI_REVA0;
-}
-
-static inline bool is_a2(void)
+static inline bool is_a2(struct pci_dev *pdev)
 {
-	return isci_si_rev == ISCI_SI_REVA2;
+	if (pdev->revision < 4)
+		return true;
+	return false;
 }
 
-static inline bool is_b0(void)
+static inline bool is_b0(struct pci_dev *pdev)
 {
-	return isci_si_rev == ISCI_SI_REVB0;
+	if (pdev->revision == 4)
+		return true;
+	return false;
 }
 
-static inline bool is_c0(void)
+static inline bool is_c0(struct pci_dev *pdev)
 {
-	return isci_si_rev > ISCI_SI_REVB0;
+	if (pdev->revision >= 5)
+		return true;
+	return false;
 }
 
 void sci_controller_post_request(struct isci_host *ihost,

commit 4e4dca3de9658f364d34924e072f2b64e5c3d267
Author: Dan Williams <dan.j.williams@intel.com>
Date:   Fri Jul 1 11:15:12 2011 -0700

    isci: merge scu_unsolicited_frame.h into unsolicited_frame_control.h
    
    Does not need its own file.
    
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/drivers/scsi/isci/host.h b/drivers/scsi/isci/host.h
index a72d2be2445d..ec0bba5367ba 100644
--- a/drivers/scsi/isci/host.h
+++ b/drivers/scsi/isci/host.h
@@ -60,7 +60,6 @@
 #include "isci.h"
 #include "remote_node_table.h"
 #include "registers.h"
-#include "scu_unsolicited_frame.h"
 #include "unsolicited_frame_control.h"
 #include "probe_roms.h"
 

commit 34a991587a5cc9f78960c2c9beea217866458c41
Author: Dan Williams <dan.j.williams@intel.com>
Date:   Fri Jul 1 02:25:15 2011 -0700

    isci: kill 'get/set' macros
    
    Most of these simple dereference macros are longer than their open coded
    equivalent.  Deleting enum sci_controller_mode is thrown in for good
    measure.
    
    Reported-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/drivers/scsi/isci/host.h b/drivers/scsi/isci/host.h
index d87f21de1807..a72d2be2445d 100644
--- a/drivers/scsi/isci/host.h
+++ b/drivers/scsi/isci/host.h
@@ -172,6 +172,7 @@ struct isci_host {
 	/* XXX kill */
 	bool phy_startup_timer_pending;
 	u32 next_phy_to_start;
+	/* XXX convert to unsigned long and use bitops */
 	u8 invalid_phy_mask;
 
 	/* TODO attempt dynamic interrupt coalescing scheme */
@@ -359,13 +360,8 @@ static inline struct isci_host *dev_to_ihost(struct domain_device *dev)
 	return dev->port->ha->lldd_ha;
 }
 
-/**
- * sci_controller_get_protocol_engine_group() -
- *
- * This macro returns the protocol engine group for this controller object.
- * Presently we only support protocol engine group 0 so just return that
- */
-#define sci_controller_get_protocol_engine_group(controller) 0
+/* we always use protocol engine group zero */
+#define ISCI_PEG 0
 
 /* see sci_controller_io_tag_allocate|free for how seq and tci are built */
 #define ISCI_TAG(seq, tci) (((u16) (seq)) << 12 | tci)
@@ -385,16 +381,6 @@ static inline int sci_remote_device_node_count(struct isci_remote_device *idev)
 	return SCU_SSP_REMOTE_NODE_COUNT;
 }
 
-/**
- * sci_controller_set_invalid_phy() -
- *
- * This macro will set the bit in the invalid phy mask for this controller
- * object.  This is used to control messages reported for invalid link up
- * notifications.
- */
-#define sci_controller_set_invalid_phy(controller, phy) \
-	((controller)->invalid_phy_mask |= (1 << (phy)->phy_index))
-
 /**
  * sci_controller_clear_invalid_phy() -
  *

commit 89a7301f21fb00e753089671eb9e4132aab8ea08
Author: Dan Williams <dan.j.williams@intel.com>
Date:   Thu Jun 30 19:14:33 2011 -0700

    isci: retire scic_sds_ and scic_ prefixes
    
    The distinction between scic_sds_ scic_ and sci_ are no longer relevant
    so just unify the prefixes on sci_.  The distinction between isci_ and
    sci_ is historically significant, and useful for comparing the old
    'core' to the current Linux driver. 'sci_' represents the former core as
    well as the routines that are closer to the hardware and protocol than
    their 'isci_' brethren. sci == sas controller interface.
    
    Also unwind the 'sds1' out of the parameter structs.
    
    Reported-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/drivers/scsi/isci/host.h b/drivers/scsi/isci/host.h
index 013f672a8fd7..d87f21de1807 100644
--- a/drivers/scsi/isci/host.h
+++ b/drivers/scsi/isci/host.h
@@ -69,12 +69,12 @@ struct scu_task_context;
 
 
 /**
- * struct scic_power_control -
+ * struct sci_power_control -
  *
  * This structure defines the fields for managing power control for direct
  * attached disk devices.
  */
-struct scic_power_control {
+struct sci_power_control {
 	/**
 	 * This field is set when the power control timer is running and cleared when
 	 * it is not.
@@ -99,18 +99,18 @@ struct scic_power_control {
 
 	/**
 	 * This field is an array of phys that we are waiting on. The phys are direct
-	 * mapped into requesters via struct scic_sds_phy.phy_index
+	 * mapped into requesters via struct sci_phy.phy_index
 	 */
 	struct isci_phy *requesters[SCI_MAX_PHYS];
 
 };
 
-struct scic_sds_port_configuration_agent;
+struct sci_port_configuration_agent;
 typedef void (*port_config_fn)(struct isci_host *,
-			       struct scic_sds_port_configuration_agent *,
+			       struct sci_port_configuration_agent *,
 			       struct isci_port *, struct isci_phy *);
 
-struct scic_sds_port_configuration_agent {
+struct sci_port_configuration_agent {
 	u16 phy_configured_mask;
 	u16 phy_ready_mask;
 	struct {
@@ -149,13 +149,13 @@ struct isci_host {
 	/* XXX can we time this externally */
 	struct sci_timer timer;
 	/* XXX drop reference module params directly */
-	union scic_user_parameters user_parameters;
+	struct sci_user_parameters user_parameters;
 	/* XXX no need to be a union */
-	union scic_oem_parameters oem_parameters;
-	struct scic_sds_port_configuration_agent port_agent;
+	struct sci_oem_params oem_parameters;
+	struct sci_port_configuration_agent port_agent;
 	struct isci_remote_device *device_table[SCI_MAX_REMOTE_DEVICES];
-	struct scic_remote_node_table available_remote_nodes;
-	struct scic_power_control power_control;
+	struct sci_remote_node_table available_remote_nodes;
+	struct sci_power_control power_control;
 	u8 io_request_sequence[SCI_MAX_IO_REQUESTS];
 	struct scu_task_context *task_context_table;
 	dma_addr_t task_context_dma;
@@ -165,7 +165,7 @@ struct isci_host {
 	u32 logical_port_entries;
 	u32 remote_node_entries;
 	u32 task_context_entries;
-	struct scic_sds_unsolicited_frame_control uf_control;
+	struct sci_unsolicited_frame_control uf_control;
 
 	/* phy startup */
 	struct sci_timer phy_timer;
@@ -206,10 +206,10 @@ struct isci_host {
 };
 
 /**
- * enum scic_sds_controller_states - This enumeration depicts all the states
+ * enum sci_controller_states - This enumeration depicts all the states
  *    for the common controller state machine.
  */
-enum scic_sds_controller_states {
+enum sci_controller_states {
 	/**
 	 * Simply the initial state for the base controller state machine.
 	 */
@@ -360,14 +360,14 @@ static inline struct isci_host *dev_to_ihost(struct domain_device *dev)
 }
 
 /**
- * scic_sds_controller_get_protocol_engine_group() -
+ * sci_controller_get_protocol_engine_group() -
  *
  * This macro returns the protocol engine group for this controller object.
  * Presently we only support protocol engine group 0 so just return that
  */
-#define scic_sds_controller_get_protocol_engine_group(controller) 0
+#define sci_controller_get_protocol_engine_group(controller) 0
 
-/* see scic_controller_io_tag_allocate|free for how seq and tci are built */
+/* see sci_controller_io_tag_allocate|free for how seq and tci are built */
 #define ISCI_TAG(seq, tci) (((u16) (seq)) << 12 | tci)
 
 /* these are returned by the hardware, so sanitize them */
@@ -375,7 +375,7 @@ static inline struct isci_host *dev_to_ihost(struct domain_device *dev)
 #define ISCI_TAG_TCI(tag) ((tag) & (SCI_MAX_IO_REQUESTS-1))
 
 /* expander attached sata devices require 3 rnc slots */
-static inline int scic_sds_remote_device_node_count(struct isci_remote_device *idev)
+static inline int sci_remote_device_node_count(struct isci_remote_device *idev)
 {
 	struct domain_device *dev = idev->domain_dev;
 
@@ -386,23 +386,23 @@ static inline int scic_sds_remote_device_node_count(struct isci_remote_device *i
 }
 
 /**
- * scic_sds_controller_set_invalid_phy() -
+ * sci_controller_set_invalid_phy() -
  *
  * This macro will set the bit in the invalid phy mask for this controller
  * object.  This is used to control messages reported for invalid link up
  * notifications.
  */
-#define scic_sds_controller_set_invalid_phy(controller, phy) \
+#define sci_controller_set_invalid_phy(controller, phy) \
 	((controller)->invalid_phy_mask |= (1 << (phy)->phy_index))
 
 /**
- * scic_sds_controller_clear_invalid_phy() -
+ * sci_controller_clear_invalid_phy() -
  *
  * This macro will clear the bit in the invalid phy mask for this controller
  * object.  This is used to control messages reported for invalid link up
  * notifications.
  */
-#define scic_sds_controller_clear_invalid_phy(controller, phy) \
+#define sci_controller_clear_invalid_phy(controller, phy) \
 	((controller)->invalid_phy_mask &= ~(1 << (phy)->phy_index))
 
 static inline struct device *sciphy_to_dev(struct isci_phy *iphy)
@@ -460,56 +460,53 @@ static inline bool is_c0(void)
 	return isci_si_rev > ISCI_SI_REVB0;
 }
 
-void scic_sds_controller_post_request(struct isci_host *ihost,
+void sci_controller_post_request(struct isci_host *ihost,
 				      u32 request);
-void scic_sds_controller_release_frame(struct isci_host *ihost,
+void sci_controller_release_frame(struct isci_host *ihost,
 				       u32 frame_index);
-void scic_sds_controller_copy_sata_response(void *response_buffer,
+void sci_controller_copy_sata_response(void *response_buffer,
 					    void *frame_header,
 					    void *frame_buffer);
-enum sci_status scic_sds_controller_allocate_remote_node_context(struct isci_host *ihost,
+enum sci_status sci_controller_allocate_remote_node_context(struct isci_host *ihost,
 								 struct isci_remote_device *idev,
 								 u16 *node_id);
-void scic_sds_controller_free_remote_node_context(
+void sci_controller_free_remote_node_context(
 	struct isci_host *ihost,
 	struct isci_remote_device *idev,
 	u16 node_id);
-union scu_remote_node_context *scic_sds_controller_get_remote_node_context_buffer(
-	struct isci_host *ihost,
-	u16 node_id);
 
-struct isci_request *scic_request_by_tag(struct isci_host *ihost,
+struct isci_request *sci_request_by_tag(struct isci_host *ihost,
 					     u16 io_tag);
 
-void scic_sds_controller_power_control_queue_insert(
+void sci_controller_power_control_queue_insert(
 	struct isci_host *ihost,
 	struct isci_phy *iphy);
 
-void scic_sds_controller_power_control_queue_remove(
+void sci_controller_power_control_queue_remove(
 	struct isci_host *ihost,
 	struct isci_phy *iphy);
 
-void scic_sds_controller_link_up(
+void sci_controller_link_up(
 	struct isci_host *ihost,
 	struct isci_port *iport,
 	struct isci_phy *iphy);
 
-void scic_sds_controller_link_down(
+void sci_controller_link_down(
 	struct isci_host *ihost,
 	struct isci_port *iport,
 	struct isci_phy *iphy);
 
-void scic_sds_controller_remote_device_stopped(
+void sci_controller_remote_device_stopped(
 	struct isci_host *ihost,
 	struct isci_remote_device *idev);
 
-void scic_sds_controller_copy_task_context(
+void sci_controller_copy_task_context(
 	struct isci_host *ihost,
 	struct isci_request *ireq);
 
-void scic_sds_controller_register_setup(struct isci_host *ihost);
+void sci_controller_register_setup(struct isci_host *ihost);
 
-enum sci_status scic_controller_continue_io(struct isci_request *ireq);
+enum sci_status sci_controller_continue_io(struct isci_request *ireq);
 int isci_host_scan_finished(struct Scsi_Host *, unsigned long);
 void isci_host_scan_start(struct Scsi_Host *);
 u16 isci_alloc_tag(struct isci_host *ihost);
@@ -536,33 +533,33 @@ void isci_host_remote_device_start_complete(
 	struct isci_remote_device *,
 	enum sci_status);
 
-void scic_controller_disable_interrupts(
+void sci_controller_disable_interrupts(
 	struct isci_host *ihost);
 
-enum sci_status scic_controller_start_io(
+enum sci_status sci_controller_start_io(
 	struct isci_host *ihost,
 	struct isci_remote_device *idev,
 	struct isci_request *ireq);
 
-enum sci_task_status scic_controller_start_task(
+enum sci_task_status sci_controller_start_task(
 	struct isci_host *ihost,
 	struct isci_remote_device *idev,
 	struct isci_request *ireq);
 
-enum sci_status scic_controller_terminate_request(
+enum sci_status sci_controller_terminate_request(
 	struct isci_host *ihost,
 	struct isci_remote_device *idev,
 	struct isci_request *ireq);
 
-enum sci_status scic_controller_complete_io(
+enum sci_status sci_controller_complete_io(
 	struct isci_host *ihost,
 	struct isci_remote_device *idev,
 	struct isci_request *ireq);
 
-void scic_sds_port_configuration_agent_construct(
-	struct scic_sds_port_configuration_agent *port_agent);
+void sci_port_configuration_agent_construct(
+	struct sci_port_configuration_agent *port_agent);
 
-enum sci_status scic_sds_port_configuration_agent_initialize(
+enum sci_status sci_port_configuration_agent_initialize(
 	struct isci_host *ihost,
-	struct scic_sds_port_configuration_agent *port_agent);
+	struct sci_port_configuration_agent *port_agent);
 #endif

commit d9dcb4ba791de2a06b19ac47cd61601cf3d4e208
Author: Dan Williams <dan.j.williams@intel.com>
Date:   Thu Jun 30 17:38:32 2011 -0700

    isci: unify isci_host and scic_sds_controller
    
    Remove the distinction between these two implementations and unify on
    isci_host (local instances named ihost).  Hmmm, we had two
    'oem_parameters' instances, one was unused... nice.
    
    Reported-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/drivers/scsi/isci/host.h b/drivers/scsi/isci/host.h
index ca2e3b0ee0dd..013f672a8fd7 100644
--- a/drivers/scsi/isci/host.h
+++ b/drivers/scsi/isci/host.h
@@ -106,7 +106,7 @@ struct scic_power_control {
 };
 
 struct scic_sds_port_configuration_agent;
-typedef void (*port_config_fn)(struct scic_sds_controller *,
+typedef void (*port_config_fn)(struct isci_host *,
 			       struct scic_sds_port_configuration_agent *,
 			       struct isci_port *, struct isci_phy *);
 
@@ -124,171 +124,66 @@ struct scic_sds_port_configuration_agent {
 };
 
 /**
- * struct scic_sds_controller -
- *
- * This structure represents the SCU controller object.
+ * isci_host - primary host/controller object
+ * @timer: timeout start/stop operations
+ * @device_table: rni (hw remote node index) to remote device lookup table
+ * @available_remote_nodes: rni allocator
+ * @power_control: manage device spin up
+ * @io_request_sequence: generation number for tci's (task contexts)
+ * @task_context_table: hw task context table
+ * @remote_node_context_table: hw remote node context table
+ * @completion_queue: hw-producer driver-consumer communication ring
+ * @completion_queue_get: tracks the driver 'head' of the ring to notify hw
+ * @logical_port_entries: min({driver|silicon}-supported-port-count)
+ * @remote_node_entries: min({driver|silicon}-supported-node-count)
+ * @task_context_entries: min({driver|silicon}-supported-task-count)
+ * @phy_timer: phy startup timer
+ * @invalid_phy_mask: if an invalid_link_up notification is reported a bit for
+ * 		      the phy index is set so further notifications are not
+ * 		      made.  Once the phy reports link up and is made part of a
+ * 		      port then this bit is cleared.
+
  */
-struct scic_sds_controller {
-	/**
-	 * This field contains the information for the base controller state
-	 * machine.
-	 */
+struct isci_host {
 	struct sci_base_state_machine sm;
-
-	/**
-	 * Timer for controller start/stop operations.
-	 */
+	/* XXX can we time this externally */
 	struct sci_timer timer;
-
-	/**
-	 * This field contains the user parameters to be utilized for this
-	 * core controller object.
-	 */
+	/* XXX drop reference module params directly */
 	union scic_user_parameters user_parameters;
-
-	/**
-	 * This field contains the OEM parameters to be utilized for this
-	 * core controller object.
-	 */
+	/* XXX no need to be a union */
 	union scic_oem_parameters oem_parameters;
-
-	/**
-	 * This field contains the port configuration agent for this controller.
-	 */
 	struct scic_sds_port_configuration_agent port_agent;
-
-	/**
-	 * This field is the array of device objects that are currently constructed
-	 * for this controller object.  This table is used as a fast lookup of device
-	 * objects that need to handle device completion notifications from the
-	 * hardware. The table is RNi based.
-	 */
 	struct isci_remote_device *device_table[SCI_MAX_REMOTE_DEVICES];
-
-	/**
-	 * This field is the free RNi data structure
-	 */
 	struct scic_remote_node_table available_remote_nodes;
-
-	/**
-	 * This filed is the struct scic_power_control data used to controll when direct
-	 * attached devices can consume power.
-	 */
 	struct scic_power_control power_control;
-
-	/* sequence number per tci */
 	u8 io_request_sequence[SCI_MAX_IO_REQUESTS];
-
-	/**
-	 * This field is a pointer to the memory allocated by the driver for the task
-	 * context table.  This data is shared between the hardware and software.
-	 */
 	struct scu_task_context *task_context_table;
 	dma_addr_t task_context_dma;
-
-	/**
-	 * This field is a pointer to the memory allocated by the driver for the
-	 * remote node context table.  This table is shared between the hardware and
-	 * software.
-	 */
 	union scu_remote_node_context *remote_node_context_table;
-
-	/**
-	 * This field is a pointer to the completion queue.  This memory is
-	 * written to by the hardware and read by the software.
-	 */
 	u32 *completion_queue;
-
-	/**
-	 * This field is the software copy of the completion queue get pointer.  The
-	 * controller object writes this value to the hardware after processing the
-	 * completion entries.
-	 */
 	u32 completion_queue_get;
-
-	/**
-	 * This field is the minimum of the number of hardware supported port entries
-	 * and the software requested port entries.
-	 */
 	u32 logical_port_entries;
-
-	/**
-	 * This field is the minimum number of devices supported by the hardware and
-	 * the number of devices requested by the software.
-	 */
 	u32 remote_node_entries;
-
-	/**
-	 * This field is the minimum number of IO requests supported by the hardware
-	 * and the number of IO requests requested by the software.
-	 */
 	u32 task_context_entries;
-
-	/**
-	 * This object contains all of the unsolicited frame specific
-	 * data utilized by the core controller.
-	 */
 	struct scic_sds_unsolicited_frame_control uf_control;
 
-	/* Phy Startup Data */
-	/**
-	 * Timer for controller phy request startup. On controller start the
-	 * controller will start each PHY individually in order of phy index.
-	 */
+	/* phy startup */
 	struct sci_timer phy_timer;
-
-	/**
-	 * This field is set when the phy_timer is running and is cleared when
-	 * the phy_timer is stopped.
-	 */
+	/* XXX kill */
 	bool phy_startup_timer_pending;
-
-	/**
-	 * This field is the index of the next phy start.  It is initialized to 0 and
-	 * increments for each phy index that is started.
-	 */
 	u32 next_phy_to_start;
-
-	/**
-	 * This field controlls the invalid link up notifications to the SCI_USER.  If
-	 * an invalid_link_up notification is reported a bit for the PHY index is set
-	 * so further notifications are not made.  Once the PHY object reports link up
-	 * and is made part of a port then this bit for the PHY index is cleared.
-	 */
 	u8 invalid_phy_mask;
 
-	/*
-	 * This field saves the current interrupt coalescing number of the controller.
-	 */
+	/* TODO attempt dynamic interrupt coalescing scheme */
 	u16 interrupt_coalesce_number;
-
-	/*
-	 * This field saves the current interrupt coalescing timeout value in microseconds.
-	 */
 	u32 interrupt_coalesce_timeout;
-
-	/**
-	 * This field is a pointer to the memory mapped register space for the
-	 * struct smu_registers.
-	 */
 	struct smu_registers __iomem *smu_registers;
-
-	/**
-	 * This field is a pointer to the memory mapped register space for the
-	 * struct scu_registers.
-	 */
 	struct scu_registers __iomem *scu_registers;
 
-};
-
-struct isci_host {
-	struct scic_sds_controller sci;
 	u16 tci_head;
 	u16 tci_tail;
 	u16 tci_pool[SCI_MAX_IO_REQUESTS];
 
-	union scic_oem_parameters oem_parameters;
-
 	int id; /* unique within a given pci device */
 	struct isci_phy phys[SCI_MAX_PHYS];
 	struct isci_port ports[SCI_MAX_PORTS + 1]; /* includes dummy port */
@@ -464,14 +359,6 @@ static inline struct isci_host *dev_to_ihost(struct domain_device *dev)
 	return dev->port->ha->lldd_ha;
 }
 
-static inline struct isci_host *scic_to_ihost(struct scic_sds_controller *scic)
-{
-	/* XXX delete after merging scic_sds_contoller and isci_host */
-	struct isci_host *ihost = container_of(scic, typeof(*ihost), sci);
-
-	return ihost;
-}
-
 /**
  * scic_sds_controller_get_protocol_engine_group() -
  *
@@ -518,11 +405,6 @@ static inline int scic_sds_remote_device_node_count(struct isci_remote_device *i
 #define scic_sds_controller_clear_invalid_phy(controller, phy) \
 	((controller)->invalid_phy_mask &= ~(1 << (phy)->phy_index))
 
-static inline struct device *scic_to_dev(struct scic_sds_controller *scic)
-{
-	return &scic_to_ihost(scic)->pdev->dev;
-}
-
 static inline struct device *sciphy_to_dev(struct isci_phy *iphy)
 {
 
@@ -578,54 +460,54 @@ static inline bool is_c0(void)
 	return isci_si_rev > ISCI_SI_REVB0;
 }
 
-void scic_sds_controller_post_request(struct scic_sds_controller *scic,
+void scic_sds_controller_post_request(struct isci_host *ihost,
 				      u32 request);
-void scic_sds_controller_release_frame(struct scic_sds_controller *scic,
+void scic_sds_controller_release_frame(struct isci_host *ihost,
 				       u32 frame_index);
 void scic_sds_controller_copy_sata_response(void *response_buffer,
 					    void *frame_header,
 					    void *frame_buffer);
-enum sci_status scic_sds_controller_allocate_remote_node_context(struct scic_sds_controller *scic,
+enum sci_status scic_sds_controller_allocate_remote_node_context(struct isci_host *ihost,
 								 struct isci_remote_device *idev,
 								 u16 *node_id);
 void scic_sds_controller_free_remote_node_context(
-	struct scic_sds_controller *scic,
+	struct isci_host *ihost,
 	struct isci_remote_device *idev,
 	u16 node_id);
 union scu_remote_node_context *scic_sds_controller_get_remote_node_context_buffer(
-	struct scic_sds_controller *scic,
+	struct isci_host *ihost,
 	u16 node_id);
 
-struct isci_request *scic_request_by_tag(struct scic_sds_controller *scic,
+struct isci_request *scic_request_by_tag(struct isci_host *ihost,
 					     u16 io_tag);
 
 void scic_sds_controller_power_control_queue_insert(
-	struct scic_sds_controller *scic,
+	struct isci_host *ihost,
 	struct isci_phy *iphy);
 
 void scic_sds_controller_power_control_queue_remove(
-	struct scic_sds_controller *scic,
+	struct isci_host *ihost,
 	struct isci_phy *iphy);
 
 void scic_sds_controller_link_up(
-	struct scic_sds_controller *scic,
+	struct isci_host *ihost,
 	struct isci_port *iport,
 	struct isci_phy *iphy);
 
 void scic_sds_controller_link_down(
-	struct scic_sds_controller *scic,
+	struct isci_host *ihost,
 	struct isci_port *iport,
 	struct isci_phy *iphy);
 
 void scic_sds_controller_remote_device_stopped(
-	struct scic_sds_controller *scic,
+	struct isci_host *ihost,
 	struct isci_remote_device *idev);
 
 void scic_sds_controller_copy_task_context(
-	struct scic_sds_controller *scic,
+	struct isci_host *ihost,
 	struct isci_request *ireq);
 
-void scic_sds_controller_register_setup(struct scic_sds_controller *scic);
+void scic_sds_controller_register_setup(struct isci_host *ihost);
 
 enum sci_status scic_controller_continue_io(struct isci_request *ireq);
 int isci_host_scan_finished(struct Scsi_Host *, unsigned long);
@@ -655,25 +537,25 @@ void isci_host_remote_device_start_complete(
 	enum sci_status);
 
 void scic_controller_disable_interrupts(
-	struct scic_sds_controller *scic);
+	struct isci_host *ihost);
 
 enum sci_status scic_controller_start_io(
-	struct scic_sds_controller *scic,
+	struct isci_host *ihost,
 	struct isci_remote_device *idev,
 	struct isci_request *ireq);
 
 enum sci_task_status scic_controller_start_task(
-	struct scic_sds_controller *scic,
+	struct isci_host *ihost,
 	struct isci_remote_device *idev,
 	struct isci_request *ireq);
 
 enum sci_status scic_controller_terminate_request(
-	struct scic_sds_controller *scic,
+	struct isci_host *ihost,
 	struct isci_remote_device *idev,
 	struct isci_request *ireq);
 
 enum sci_status scic_controller_complete_io(
-	struct scic_sds_controller *scic,
+	struct isci_host *ihost,
 	struct isci_remote_device *idev,
 	struct isci_request *ireq);
 
@@ -681,6 +563,6 @@ void scic_sds_port_configuration_agent_construct(
 	struct scic_sds_port_configuration_agent *port_agent);
 
 enum sci_status scic_sds_port_configuration_agent_initialize(
-	struct scic_sds_controller *controller,
+	struct isci_host *ihost,
 	struct scic_sds_port_configuration_agent *port_agent);
 #endif

commit 78a6f06e0e82125787d7aa308fe28c2c8381540c
Author: Dan Williams <dan.j.williams@intel.com>
Date:   Thu Jun 30 16:31:37 2011 -0700

    isci: unify isci_remote_device and scic_sds_remote_device
    
    Remove the distinction between these two implementations and unify on
    isci_remote_device (local instances named idev).
    
    Reported-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/drivers/scsi/isci/host.h b/drivers/scsi/isci/host.h
index fb8048e5fce7..ca2e3b0ee0dd 100644
--- a/drivers/scsi/isci/host.h
+++ b/drivers/scsi/isci/host.h
@@ -163,7 +163,7 @@ struct scic_sds_controller {
 	 * objects that need to handle device completion notifications from the
 	 * hardware. The table is RNi based.
 	 */
-	struct scic_sds_remote_device *device_table[SCI_MAX_REMOTE_DEVICES];
+	struct isci_remote_device *device_table[SCI_MAX_REMOTE_DEVICES];
 
 	/**
 	 * This field is the free RNi data structure
@@ -488,12 +488,12 @@ static inline struct isci_host *scic_to_ihost(struct scic_sds_controller *scic)
 #define ISCI_TAG_TCI(tag) ((tag) & (SCI_MAX_IO_REQUESTS-1))
 
 /* expander attached sata devices require 3 rnc slots */
-static inline int scic_sds_remote_device_node_count(struct scic_sds_remote_device *sci_dev)
+static inline int scic_sds_remote_device_node_count(struct isci_remote_device *idev)
 {
-	struct domain_device *dev = sci_dev_to_domain(sci_dev);
+	struct domain_device *dev = idev->domain_dev;
 
 	if ((dev->dev_type == SATA_DEV || (dev->tproto & SAS_PROTOCOL_STP)) &&
-	    !sci_dev->is_direct_attached)
+	    !idev->is_direct_attached)
 		return SCU_STP_REMOTE_NODE_COUNT;
 	return SCU_SSP_REMOTE_NODE_COUNT;
 }
@@ -541,11 +541,8 @@ static inline struct device *sciport_to_dev(struct isci_port *iport)
 	return &iport->isci_host->pdev->dev;
 }
 
-static inline struct device *scirdev_to_dev(struct scic_sds_remote_device *sci_dev)
+static inline struct device *scirdev_to_dev(struct isci_remote_device *idev)
 {
-	struct isci_remote_device *idev =
-			container_of(sci_dev, typeof(*idev), sci);
-
 	if (!idev || !idev->isci_port || !idev->isci_port->isci_host)
 		return NULL;
 
@@ -589,11 +586,11 @@ void scic_sds_controller_copy_sata_response(void *response_buffer,
 					    void *frame_header,
 					    void *frame_buffer);
 enum sci_status scic_sds_controller_allocate_remote_node_context(struct scic_sds_controller *scic,
-								 struct scic_sds_remote_device *sci_dev,
+								 struct isci_remote_device *idev,
 								 u16 *node_id);
 void scic_sds_controller_free_remote_node_context(
 	struct scic_sds_controller *scic,
-	struct scic_sds_remote_device *sci_dev,
+	struct isci_remote_device *idev,
 	u16 node_id);
 union scu_remote_node_context *scic_sds_controller_get_remote_node_context_buffer(
 	struct scic_sds_controller *scic,
@@ -622,7 +619,7 @@ void scic_sds_controller_link_down(
 
 void scic_sds_controller_remote_device_stopped(
 	struct scic_sds_controller *scic,
-	struct scic_sds_remote_device *sci_dev);
+	struct isci_remote_device *idev);
 
 void scic_sds_controller_copy_task_context(
 	struct scic_sds_controller *scic,
@@ -662,22 +659,22 @@ void scic_controller_disable_interrupts(
 
 enum sci_status scic_controller_start_io(
 	struct scic_sds_controller *scic,
-	struct scic_sds_remote_device *remote_device,
+	struct isci_remote_device *idev,
 	struct isci_request *ireq);
 
 enum sci_task_status scic_controller_start_task(
 	struct scic_sds_controller *scic,
-	struct scic_sds_remote_device *remote_device,
+	struct isci_remote_device *idev,
 	struct isci_request *ireq);
 
 enum sci_status scic_controller_terminate_request(
 	struct scic_sds_controller *scic,
-	struct scic_sds_remote_device *remote_device,
+	struct isci_remote_device *idev,
 	struct isci_request *ireq);
 
 enum sci_status scic_controller_complete_io(
 	struct scic_sds_controller *scic,
-	struct scic_sds_remote_device *remote_device,
+	struct isci_remote_device *idev,
 	struct isci_request *ireq);
 
 void scic_sds_port_configuration_agent_construct(

commit ffe191c92ff195d73f9130b1490045ca2dd4c5e0
Author: Dan Williams <dan.j.williams@intel.com>
Date:   Wed Jun 29 13:09:25 2011 -0700

    isci: unify isci_port and scic_sds_port
    
    Remove the distinction between these two implementations and unify on
    isci_port (local instances named iport).  The duplicate '->owning_port' and
    '->isci_port' in both isci_phy and isci_remote_device will be fixed in a later
    patch... this is just the straightforward rename/unification.
    
    Reported-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/drivers/scsi/isci/host.h b/drivers/scsi/isci/host.h
index 1edd13535c24..fb8048e5fce7 100644
--- a/drivers/scsi/isci/host.h
+++ b/drivers/scsi/isci/host.h
@@ -108,7 +108,7 @@ struct scic_power_control {
 struct scic_sds_port_configuration_agent;
 typedef void (*port_config_fn)(struct scic_sds_controller *,
 			       struct scic_sds_port_configuration_agent *,
-			       struct scic_sds_port *, struct isci_phy *);
+			       struct isci_port *, struct isci_phy *);
 
 struct scic_sds_port_configuration_agent {
 	u16 phy_configured_mask;
@@ -532,9 +532,8 @@ static inline struct device *sciphy_to_dev(struct isci_phy *iphy)
 	return &iphy->isci_port->isci_host->pdev->dev;
 }
 
-static inline struct device *sciport_to_dev(struct scic_sds_port *sci_port)
+static inline struct device *sciport_to_dev(struct isci_port *iport)
 {
-	struct isci_port *iport = sci_port_to_iport(sci_port);
 
 	if (!iport || !iport->isci_host)
 		return NULL;
@@ -613,12 +612,12 @@ void scic_sds_controller_power_control_queue_remove(
 
 void scic_sds_controller_link_up(
 	struct scic_sds_controller *scic,
-	struct scic_sds_port *sci_port,
+	struct isci_port *iport,
 	struct isci_phy *iphy);
 
 void scic_sds_controller_link_down(
 	struct scic_sds_controller *scic,
-	struct scic_sds_port *sci_port,
+	struct isci_port *iport,
 	struct isci_phy *iphy);
 
 void scic_sds_controller_remote_device_stopped(
@@ -649,7 +648,7 @@ void isci_host_deinit(
 
 void isci_host_port_link_up(
 	struct isci_host *,
-	struct scic_sds_port *,
+	struct isci_port *,
 	struct isci_phy *);
 int isci_host_dev_found(struct domain_device *);
 

commit 852809559e4680ba4768262a6c3d21454fcd460e
Author: Dan Williams <dan.j.williams@intel.com>
Date:   Tue Jun 28 15:05:53 2011 -0700

    isci: unify isci_phy and scic_sds_phy
    
    They are one in the same object so remove the distinction.  The near
    duplicate fields (owning_port, and isci_port) will be cleaned up
    after the scic_sds_port isci_port unification.
    
    Reported-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/drivers/scsi/isci/host.h b/drivers/scsi/isci/host.h
index 0b26d25c19a9..1edd13535c24 100644
--- a/drivers/scsi/isci/host.h
+++ b/drivers/scsi/isci/host.h
@@ -101,14 +101,14 @@ struct scic_power_control {
 	 * This field is an array of phys that we are waiting on. The phys are direct
 	 * mapped into requesters via struct scic_sds_phy.phy_index
 	 */
-	struct scic_sds_phy *requesters[SCI_MAX_PHYS];
+	struct isci_phy *requesters[SCI_MAX_PHYS];
 
 };
 
 struct scic_sds_port_configuration_agent;
 typedef void (*port_config_fn)(struct scic_sds_controller *,
 			       struct scic_sds_port_configuration_agent *,
-			       struct scic_sds_port *, struct scic_sds_phy *);
+			       struct scic_sds_port *, struct isci_phy *);
 
 struct scic_sds_port_configuration_agent {
 	u16 phy_configured_mask;
@@ -523,9 +523,8 @@ static inline struct device *scic_to_dev(struct scic_sds_controller *scic)
 	return &scic_to_ihost(scic)->pdev->dev;
 }
 
-static inline struct device *sciphy_to_dev(struct scic_sds_phy *sci_phy)
+static inline struct device *sciphy_to_dev(struct isci_phy *iphy)
 {
-	struct isci_phy *iphy = sci_phy_to_iphy(sci_phy);
 
 	if (!iphy || !iphy->isci_port || !iphy->isci_port->isci_host)
 		return NULL;
@@ -606,21 +605,21 @@ struct isci_request *scic_request_by_tag(struct scic_sds_controller *scic,
 
 void scic_sds_controller_power_control_queue_insert(
 	struct scic_sds_controller *scic,
-	struct scic_sds_phy *sci_phy);
+	struct isci_phy *iphy);
 
 void scic_sds_controller_power_control_queue_remove(
 	struct scic_sds_controller *scic,
-	struct scic_sds_phy *sci_phy);
+	struct isci_phy *iphy);
 
 void scic_sds_controller_link_up(
 	struct scic_sds_controller *scic,
 	struct scic_sds_port *sci_port,
-	struct scic_sds_phy *sci_phy);
+	struct isci_phy *iphy);
 
 void scic_sds_controller_link_down(
 	struct scic_sds_controller *scic,
 	struct scic_sds_port *sci_port,
-	struct scic_sds_phy *sci_phy);
+	struct isci_phy *iphy);
 
 void scic_sds_controller_remote_device_stopped(
 	struct scic_sds_controller *scic,
@@ -651,7 +650,7 @@ void isci_host_deinit(
 void isci_host_port_link_up(
 	struct isci_host *,
 	struct scic_sds_port *,
-	struct scic_sds_phy *);
+	struct isci_phy *);
 int isci_host_dev_found(struct domain_device *);
 
 void isci_host_remote_device_start_complete(

commit 5076a1a97e2fa61c847a5fdd4b1991faf7716da6
Author: Dan Williams <dan.j.williams@intel.com>
Date:   Mon Jun 27 14:57:03 2011 -0700

    isci: unify isci_request and scic_sds_request
    
    They are one in the same object so remove the distinction.  The near
    duplicate fields (owning_controller, and isci_host) will be cleaned up
    after the scic_sds_contoller isci_host unification.
    
    Reported-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/drivers/scsi/isci/host.h b/drivers/scsi/isci/host.h
index 446fade19b3a..0b26d25c19a9 100644
--- a/drivers/scsi/isci/host.h
+++ b/drivers/scsi/isci/host.h
@@ -64,7 +64,7 @@
 #include "unsolicited_frame_control.h"
 #include "probe_roms.h"
 
-struct scic_sds_request;
+struct isci_request;
 struct scu_task_context;
 
 
@@ -601,7 +601,7 @@ union scu_remote_node_context *scic_sds_controller_get_remote_node_context_buffe
 	struct scic_sds_controller *scic,
 	u16 node_id);
 
-struct scic_sds_request *scic_request_by_tag(struct scic_sds_controller *scic,
+struct isci_request *scic_request_by_tag(struct scic_sds_controller *scic,
 					     u16 io_tag);
 
 void scic_sds_controller_power_control_queue_insert(
@@ -628,11 +628,11 @@ void scic_sds_controller_remote_device_stopped(
 
 void scic_sds_controller_copy_task_context(
 	struct scic_sds_controller *scic,
-	struct scic_sds_request *this_request);
+	struct isci_request *ireq);
 
 void scic_sds_controller_register_setup(struct scic_sds_controller *scic);
 
-enum sci_status scic_controller_continue_io(struct scic_sds_request *sci_req);
+enum sci_status scic_controller_continue_io(struct isci_request *ireq);
 int isci_host_scan_finished(struct Scsi_Host *, unsigned long);
 void isci_host_scan_start(struct Scsi_Host *);
 u16 isci_alloc_tag(struct isci_host *ihost);
@@ -665,22 +665,22 @@ void scic_controller_disable_interrupts(
 enum sci_status scic_controller_start_io(
 	struct scic_sds_controller *scic,
 	struct scic_sds_remote_device *remote_device,
-	struct scic_sds_request *io_request);
+	struct isci_request *ireq);
 
 enum sci_task_status scic_controller_start_task(
 	struct scic_sds_controller *scic,
 	struct scic_sds_remote_device *remote_device,
-	struct scic_sds_request *task_request);
+	struct isci_request *ireq);
 
 enum sci_status scic_controller_terminate_request(
 	struct scic_sds_controller *scic,
 	struct scic_sds_remote_device *remote_device,
-	struct scic_sds_request *request);
+	struct isci_request *ireq);
 
 enum sci_status scic_controller_complete_io(
 	struct scic_sds_controller *scic,
 	struct scic_sds_remote_device *remote_device,
-	struct scic_sds_request *io_request);
+	struct isci_request *ireq);
 
 void scic_sds_port_configuration_agent_construct(
 	struct scic_sds_port_configuration_agent *port_agent);

commit db0562509800a2d4cb5cb14a66413c30484f165c
Author: Dan Williams <dan.j.williams@intel.com>
Date:   Fri Jun 17 14:18:39 2011 -0700

    isci: preallocate requests
    
    the dma_pool interface is optimized for object_size << page_size which
    is not the case with isci_request objects and the dma_pool routines show
    up in the top of the profile.
    
    The old io_request_table which tracked whether tci slots were in-flight
    or not is replaced with an IREQ_ACTIVE flag per request.
    
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/drivers/scsi/isci/host.h b/drivers/scsi/isci/host.h
index d8164f5d7988..446fade19b3a 100644
--- a/drivers/scsi/isci/host.h
+++ b/drivers/scsi/isci/host.h
@@ -165,14 +165,6 @@ struct scic_sds_controller {
 	 */
 	struct scic_sds_remote_device *device_table[SCI_MAX_REMOTE_DEVICES];
 
-	/**
-	 * This field is the array of IO request objects that are currently active for
-	 * this controller object.  This table is used as a fast lookup of the io
-	 * request object that need to handle completion queue notifications.  The
-	 * table is TCi based.
-	 */
-	struct scic_sds_request *io_request_table[SCI_MAX_IO_REQUESTS];
-
 	/**
 	 * This field is the free RNi data structure
 	 */
@@ -298,7 +290,6 @@ struct isci_host {
 	union scic_oem_parameters oem_parameters;
 
 	int id; /* unique within a given pci device */
-	struct dma_pool *dma_pool;
 	struct isci_phy phys[SCI_MAX_PHYS];
 	struct isci_port ports[SCI_MAX_PORTS + 1]; /* includes dummy port */
 	struct sas_ha_struct sas_ha;
@@ -315,7 +306,7 @@ struct isci_host {
 	struct list_head requests_to_complete;
 	struct list_head requests_to_errorback;
 	spinlock_t scic_lock;
-
+	struct isci_request *reqs[SCI_MAX_IO_REQUESTS];
 	struct isci_remote_device devices[SCI_MAX_REMOTE_DEVICES];
 };
 

commit 312e0c2455c18716cf640d4336dcb1e9e5053818
Author: Dan Williams <dan.j.williams@intel.com>
Date:   Tue Jun 28 13:47:09 2011 -0700

    isci: unify can_queue tracking on the tci_pool, uplevel tag assignment
    
    The tci_pool tracks our outstanding command slots which are also the 'index'
    portion of our tags.  Grabbing the tag early in ->lldd_execute_task let's us
    drop the isci_host_can_queue() and ->was_tag_assigned_by_user infrastructure.
    ->was_tag_assigned_by_user required the task context to be duplicated in
    request-local buffer.  With the tci established early we can build the
    task_context directly into its final location and skip a memcpy.
    
    With the task context buffer at a known address at request construction we
    have the opportunity/obligation to also fix sgl handling.  This rework feels
    like it belongs in another patch but the sgl handling and task_context are too
    intertwined.
    1/ fix the 'ab' pair embedded in the task context to point to the 'cd' pair in
       the task context (previously we were prematurely linking to the staging
       buffer).
    2/ fix the broken iteration of pio sgls that assumes all sgls are relative to
       the request, and does a dangerous looking reverse lookup of physical
       address to virtual address.
    
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/drivers/scsi/isci/host.h b/drivers/scsi/isci/host.h
index a54397e1bf16..d8164f5d7988 100644
--- a/drivers/scsi/isci/host.h
+++ b/drivers/scsi/isci/host.h
@@ -192,6 +192,7 @@ struct scic_sds_controller {
 	 * context table.  This data is shared between the hardware and software.
 	 */
 	struct scu_task_context *task_context_table;
+	dma_addr_t task_context_dma;
 
 	/**
 	 * This field is a pointer to the memory allocated by the driver for the
@@ -302,12 +303,8 @@ struct isci_host {
 	struct isci_port ports[SCI_MAX_PORTS + 1]; /* includes dummy port */
 	struct sas_ha_struct sas_ha;
 
-	int can_queue;
-	spinlock_t queue_lock;
 	spinlock_t state_lock;
-
 	struct pci_dev *pdev;
-
 	enum isci_status status;
 	#define IHOST_START_PENDING 0
 	#define IHOST_STOP_PENDING 1
@@ -451,36 +448,6 @@ static inline void isci_host_change_state(struct isci_host *isci_host,
 
 }
 
-static inline int isci_host_can_queue(struct isci_host *isci_host, int num)
-{
-	int ret = 0;
-	unsigned long flags;
-
-	spin_lock_irqsave(&isci_host->queue_lock, flags);
-	if ((isci_host->can_queue - num) < 0) {
-		dev_dbg(&isci_host->pdev->dev,
-			"%s: isci_host->can_queue = %d\n",
-			__func__,
-			isci_host->can_queue);
-		ret = -SAS_QUEUE_FULL;
-
-	} else
-		isci_host->can_queue -= num;
-
-	spin_unlock_irqrestore(&isci_host->queue_lock, flags);
-
-	return ret;
-}
-
-static inline void isci_host_can_dequeue(struct isci_host *isci_host, int num)
-{
-	unsigned long flags;
-
-	spin_lock_irqsave(&isci_host->queue_lock, flags);
-	isci_host->can_queue += num;
-	spin_unlock_irqrestore(&isci_host->queue_lock, flags);
-}
-
 static inline void wait_for_start(struct isci_host *ihost)
 {
 	wait_event(ihost->eventq, !test_bit(IHOST_START_PENDING, &ihost->flags));
@@ -646,10 +613,6 @@ union scu_remote_node_context *scic_sds_controller_get_remote_node_context_buffe
 struct scic_sds_request *scic_request_by_tag(struct scic_sds_controller *scic,
 					     u16 io_tag);
 
-struct scu_task_context *scic_sds_controller_get_task_context_buffer(
-	struct scic_sds_controller *scic,
-	u16 io_tag);
-
 void scic_sds_controller_power_control_queue_insert(
 	struct scic_sds_controller *scic,
 	struct scic_sds_phy *sci_phy);
@@ -681,6 +644,9 @@ void scic_sds_controller_register_setup(struct scic_sds_controller *scic);
 enum sci_status scic_controller_continue_io(struct scic_sds_request *sci_req);
 int isci_host_scan_finished(struct Scsi_Host *, unsigned long);
 void isci_host_scan_start(struct Scsi_Host *);
+u16 isci_alloc_tag(struct isci_host *ihost);
+enum sci_status isci_free_tag(struct isci_host *ihost, u16 io_tag);
+void isci_tci_free(struct isci_host *ihost, u16 tci);
 
 int isci_host_init(struct isci_host *);
 
@@ -708,14 +674,12 @@ void scic_controller_disable_interrupts(
 enum sci_status scic_controller_start_io(
 	struct scic_sds_controller *scic,
 	struct scic_sds_remote_device *remote_device,
-	struct scic_sds_request *io_request,
-	u16 io_tag);
+	struct scic_sds_request *io_request);
 
 enum sci_task_status scic_controller_start_task(
 	struct scic_sds_controller *scic,
 	struct scic_sds_remote_device *remote_device,
-	struct scic_sds_request *task_request,
-	u16 io_tag);
+	struct scic_sds_request *task_request);
 
 enum sci_status scic_controller_terminate_request(
 	struct scic_sds_controller *scic,
@@ -727,13 +691,6 @@ enum sci_status scic_controller_complete_io(
 	struct scic_sds_remote_device *remote_device,
 	struct scic_sds_request *io_request);
 
-u16 scic_controller_allocate_io_tag(
-	struct scic_sds_controller *scic);
-
-enum sci_status scic_controller_free_io_tag(
-	struct scic_sds_controller *scic,
-	u16 io_tag);
-
 void scic_sds_port_configuration_agent_construct(
 	struct scic_sds_port_configuration_agent *port_agent);
 

commit ff60639dc9a461883db9192d2da0674a00339f12
Author: Dan Williams <dan.j.williams@intel.com>
Date:   Fri Jun 17 13:34:43 2011 -0700

    isci: kill device_sequence
    
    Now that we have upleveled device reassignment protection to the
    isci_remote_device reference count we no longer need this level of
    self-defense.
    
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/drivers/scsi/isci/host.h b/drivers/scsi/isci/host.h
index 94fd54dc9f01..a54397e1bf16 100644
--- a/drivers/scsi/isci/host.h
+++ b/drivers/scsi/isci/host.h
@@ -187,15 +187,6 @@ struct scic_sds_controller {
 	/* sequence number per tci */
 	u8 io_request_sequence[SCI_MAX_IO_REQUESTS];
 
-	/**
-	 * This field in the array of sequence values for the RNi.  These are used
-	 * to control io request build to io request start operations.  The sequence
-	 * value is recorded into an io request when it is built and is checked on
-	 * the io request start operation to make sure that there was not a device
-	 * hot plug between the build and start operation.
-	 */
-	u8 remote_device_sequence[SCI_MAX_REMOTE_DEVICES];
-
 	/**
 	 * This field is a pointer to the memory allocated by the driver for the task
 	 * context table.  This data is shared between the hardware and software.

commit 994a9303d33f8238d57f58c26067b6d4ac9af222
Author: Dan Williams <dan.j.williams@intel.com>
Date:   Thu Jun 9 16:04:28 2011 -0700

    isci: cleanup/optimize queue increment macros
    
    Every single i/o or event completion incurs a test and branch to see if
    the cycle bit changed.  For power-of-2 queue sizes the cycle bit can be
    read directly from the rollover of the queue pointer.
    
    Likely premature optimization, but the hidden if() and hidden
    assignments / side-effects in the macros were already asking to be
    cleaned up.
    
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/drivers/scsi/isci/host.h b/drivers/scsi/isci/host.h
index 7d17ab80f1a9..94fd54dc9f01 100644
--- a/drivers/scsi/isci/host.h
+++ b/drivers/scsi/isci/host.h
@@ -523,22 +523,6 @@ static inline struct isci_host *scic_to_ihost(struct scic_sds_controller *scic)
 	return ihost;
 }
 
-/**
- * INCREMENT_QUEUE_GET() -
- *
- * This macro will increment the specified index to and if the index wraps to 0
- * it will toggel the cycle bit.
- */
-#define INCREMENT_QUEUE_GET(index, cycle, entry_count, bit_toggle) \
-	{ \
-		if ((index) + 1 == entry_count) {	\
-			(index) = 0; \
-			(cycle) = (cycle) ^ (bit_toggle); \
-		} else { \
-			index = index + 1; \
-		} \
-	}
-
 /**
  * scic_sds_controller_get_protocol_engine_group() -
  *

commit dd047c8e2bca22856050dbe0378a37cf44eecc97
Author: Dan Williams <dan.j.williams@intel.com>
Date:   Thu Jun 9 11:06:58 2011 -0700

    isci: cleanup tag macros
    
    A tag is a 16 bit number where the upper four bits is a sequence number
    and the remainder is the task context index (tci).  Sanitize the macro
    names and shave 256-bytes out of scic_sds_controller by reducing the size of
    io_request_sequence.
    
    scic_sds_io_tag_construct --> ISCI_TAG
    scic_sds_io_tag_get_sequence --> ISCI_TAG_SEQ
    scic_sds_io_tag_get_index() --> ISCI_TAG_TCI
    scic_sds_io_sequence_increment() [delete / open code]
    
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/drivers/scsi/isci/host.h b/drivers/scsi/isci/host.h
index c61a9fa130b7..7d17ab80f1a9 100644
--- a/drivers/scsi/isci/host.h
+++ b/drivers/scsi/isci/host.h
@@ -184,13 +184,8 @@ struct scic_sds_controller {
 	 */
 	struct scic_power_control power_control;
 
-	/**
-	 * This field is the array of sequence values for the IO Tag fields.  Even
-	 * though only 4 bits of the field is used for the sequence the sequence is 16
-	 * bits in size so the sequence can be bitwise or'd with the TCi to build the
-	 * IO Tag value.
-	 */
-	u16 io_request_sequence[SCI_MAX_IO_REQUESTS];
+	/* sequence number per tci */
+	u8 io_request_sequence[SCI_MAX_IO_REQUESTS];
 
 	/**
 	 * This field in the array of sequence values for the RNi.  These are used
@@ -552,40 +547,12 @@ static inline struct isci_host *scic_to_ihost(struct scic_sds_controller *scic)
  */
 #define scic_sds_controller_get_protocol_engine_group(controller) 0
 
-/**
- * scic_sds_io_tag_construct() -
- *
- * This macro constructs an IO tag from the sequence and index values.
- */
-#define scic_sds_io_tag_construct(sequence, task_index)	\
-	((sequence) << 12 | (task_index))
-
-/**
- * scic_sds_io_tag_get_sequence() -
- *
- * This macro returns the IO sequence from the IO tag value.
- */
-#define scic_sds_io_tag_get_sequence(io_tag) \
-	(((io_tag) & 0xF000) >> 12)
-
-/**
- * scic_sds_io_tag_get_index() -
- *
- * This macro returns the TCi from the io tag value
- */
-#define scic_sds_io_tag_get_index(io_tag) \
-	((io_tag) & 0x0FFF)
+/* see scic_controller_io_tag_allocate|free for how seq and tci are built */
+#define ISCI_TAG(seq, tci) (((u16) (seq)) << 12 | tci)
 
-/**
- * scic_sds_io_sequence_increment() -
- *
- * This is a helper macro to increment the io sequence count. We may find in
- * the future that it will be faster to store the sequence count in such a way
- * as we dont perform the shift operation to build io tag values so therefore
- * need a way to incrment them correctly
- */
-#define scic_sds_io_sequence_increment(value) \
-	((value) = (((value) + 1) & 0x000F))
+/* these are returned by the hardware, so sanitize them */
+#define ISCI_TAG_SEQ(tag) (((tag) >> 12) & (SCI_MAX_SEQ-1))
+#define ISCI_TAG_TCI(tag) ((tag) & (SCI_MAX_IO_REQUESTS-1))
 
 /* expander attached sata devices require 3 rnc slots */
 static inline int scic_sds_remote_device_node_count(struct scic_sds_remote_device *sci_dev)

commit ac668c69709c7d927015c5cf3d9e87bf4eaaf57d
Author: Dan Williams <dan.j.williams@intel.com>
Date:   Tue Jun 7 18:50:55 2011 -0700

    isci: cleanup/optimize pool implementation
    
    The circ_buf macros are ~6% faster, as measured by perf, because they take
    advantage of power-of-two math assumptions i.e. no test and branch for
    rollover. Their semantics are clearer than the hidden side effects in pool.h
    (like sci_pool_get() which hides an assignment).
    
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/drivers/scsi/isci/host.h b/drivers/scsi/isci/host.h
index 740350043d89..c61a9fa130b7 100644
--- a/drivers/scsi/isci/host.h
+++ b/drivers/scsi/isci/host.h
@@ -57,7 +57,6 @@
 
 #include "remote_device.h"
 #include "phy.h"
-#include "pool.h"
 #include "isci.h"
 #include "remote_node_table.h"
 #include "registers.h"
@@ -179,11 +178,6 @@ struct scic_sds_controller {
 	 */
 	struct scic_remote_node_table available_remote_nodes;
 
-	/**
-	 * This field is the TCi pool used to manage the task context index.
-	 */
-	SCI_POOL_CREATE(tci_pool, u16, SCI_MAX_IO_REQUESTS);
-
 	/**
 	 * This filed is the struct scic_power_control data used to controll when direct
 	 * attached devices can consume power.
@@ -310,6 +304,10 @@ struct scic_sds_controller {
 
 struct isci_host {
 	struct scic_sds_controller sci;
+	u16 tci_head;
+	u16 tci_tail;
+	u16 tci_pool[SCI_MAX_IO_REQUESTS];
+
 	union scic_oem_parameters oem_parameters;
 
 	int id; /* unique within a given pci device */
@@ -423,8 +421,6 @@ enum scic_sds_controller_states {
 	SCIC_FAILED,
 };
 
-
-
 /**
  * struct isci_pci_info - This class represents the pci function containing the
  *    controllers. Depending on PCI SKU, there could be up to 2 controllers in

commit 7c78da3175177c905a75c54b5830029c778494ea
Author: Dan Williams <dan.j.williams@intel.com>
Date:   Wed Jun 1 16:00:01 2011 -0700

    isci: remove 'min memory' infrastructure
    
    The old 'core' had aspirations of running in severely memory constrained
    environments like bios option-rom, it's not needed for Linux and gets in
    the way of other cleanups (like unifying/reducing the number of structure
    members in scic_sds_controller/isci_host).
    
    This also fixes a theoretical bug in that the driver would blindly override
    the silicon advertised limits for number of ports, task contexts, and remote
    node contexts.
    
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/drivers/scsi/isci/host.h b/drivers/scsi/isci/host.h
index 04698dd75ad6..740350043d89 100644
--- a/drivers/scsi/isci/host.h
+++ b/drivers/scsi/isci/host.h
@@ -239,18 +239,6 @@ struct scic_sds_controller {
 	 */
 	u32 logical_port_entries;
 
-	/**
-	 * This field is the minimum number of hardware supported completion queue
-	 * entries and the software requested completion queue entries.
-	 */
-	u32 completion_queue_entries;
-
-	/**
-	 * This field is the minimum number of hardware supported event entries and
-	 * the software requested event entries.
-	 */
-	u32 completion_event_entries;
-
 	/**
 	 * This field is the minimum number of devices supported by the hardware and
 	 * the number of devices requested by the software.
@@ -325,7 +313,6 @@ struct isci_host {
 	union scic_oem_parameters oem_parameters;
 
 	int id; /* unique within a given pci device */
-	void *core_ctrl_memory;
 	struct dma_pool *dma_pool;
 	struct isci_phy phys[SCI_MAX_PHYS];
 	struct isci_port ports[SCI_MAX_PORTS + 1]; /* includes dummy port */

commit dbb0743a58825d94f1b3fdfa90a8d61dfef88f7b
Author: Adam Gruchala <adam.gruchala@intel.com>
Date:   Wed Jun 1 22:31:03 2011 +0000

    isci: Added support for C0 to SCU Driver
    
    C0 silicon updates the pci revision id and requires new AFE parameters
    for phy signal integrity.  Support for previous silicon revisions is
    deprecated (it's also broken for the theoretical case of multiple
    controllers at different silicon revisions, all the more reason to get
    it removed as soon as possible)
    
    Signed-off-by: Adam Gruchala <adam.gruchala@intel.com>
    [fixed up deprecated silicon support]
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/drivers/scsi/isci/host.h b/drivers/scsi/isci/host.h
index 4020cf7b6f2a..04698dd75ad6 100644
--- a/drivers/scsi/isci/host.h
+++ b/drivers/scsi/isci/host.h
@@ -675,6 +675,7 @@ enum {
 	ISCI_SI_REVA0,
 	ISCI_SI_REVA2,
 	ISCI_SI_REVB0,
+	ISCI_SI_REVC0
 };
 
 extern int isci_si_rev;
@@ -691,7 +692,12 @@ static inline bool is_a2(void)
 
 static inline bool is_b0(void)
 {
-	return isci_si_rev > ISCI_SI_REVA2;
+	return isci_si_rev == ISCI_SI_REVB0;
+}
+
+static inline bool is_c0(void)
+{
+	return isci_si_rev > ISCI_SI_REVB0;
 }
 
 void scic_sds_controller_post_request(struct scic_sds_controller *scic,

commit 12ef65444de9d387a383b9991960848bed5bbe74
Author: Edmund Nadolski <edmund.nadolski@intel.com>
Date:   Thu Jun 2 00:10:50 2011 +0000

    isci: additional state machine cleanup
    
    Additional state machine cleanups:
    
     o Remove static functions sci_state_machine_exit_state() and
       sci_state_machine_enter_state()
     o Combines sci_base_state_machine_construct() and
       sci_base_state_machine_start() into a single function,
       sci_init_sm()
     o Remove sci_base_state_machine_stop() which is unused.
     o Kill state_machine.[ch]
    
    Signed-off-by: Edmund Nadolski <edmund.nadolski@intel.com>
    [fixed too large to inline functions]
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/drivers/scsi/isci/host.h b/drivers/scsi/isci/host.h
index be09765ee1d5..4020cf7b6f2a 100644
--- a/drivers/scsi/isci/host.h
+++ b/drivers/scsi/isci/host.h
@@ -58,7 +58,7 @@
 #include "remote_device.h"
 #include "phy.h"
 #include "pool.h"
-#include "state_machine.h"
+#include "isci.h"
 #include "remote_node_table.h"
 #include "registers.h"
 #include "scu_unsolicited_frame.h"

commit e301370ac553a9a0ac0d1d25e769b86cf60395b3
Author: Edmund Nadolski <edmund.nadolski@intel.com>
Date:   Thu Jun 2 00:10:43 2011 +0000

    isci: state machine cleanup
    
    This cleans up several areas of the state machine mechanism:
    
     o Rename sci_base_state_machine_change_state to sci_change_state
     o Remove sci_base_state_machine_get_state function
     o Rename 'state_machine' struct member to 'sm' in client structs
     o Shorten the name of request states
     o Shorten state machine state names as follows:
            SCI_BASE_CONTROLLER_STATE_xxx to SCIC_xxx
            SCI_BASE_PHY_STATE_xxx to SCI_PHY_xxx
            SCIC_SDS_PHY_STARTING_SUBSTATE_xxx to SCI_PHY_SUB_xxx
            SCI_BASE_PORT_STATE_xxx to SCI_PORT_xxx and
            SCIC_SDS_PORT_READY_SUBSTATE_xxx to SCI_PORT_SUB_xxx
            SCI_BASE_REMOTE_DEVICE_STATE_xxx to SCI_DEV_xxx
            SCIC_SDS_STP_REMOTE_DEVICE_READY_SUBSTATE_xxx to SCI_STP_DEV_xxx
            SCIC_SDS_SMP_REMOTE_DEVICE_READY_SUBSTATE_xxx to SCI_SMP_DEV_xxx
            SCIC_SDS_REMOTE_NODE_CONTEXT_xxx_STATE to SCI_RNC_xxx
    
    Signed-off-by: Edmund Nadolski <edmund.nadolski@intel.com>
    Signed-off-by: Dave Jiang <dave.jiang@intel.com>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/drivers/scsi/isci/host.h b/drivers/scsi/isci/host.h
index 4ce39e1803ff..be09765ee1d5 100644
--- a/drivers/scsi/isci/host.h
+++ b/drivers/scsi/isci/host.h
@@ -134,7 +134,7 @@ struct scic_sds_controller {
 	 * This field contains the information for the base controller state
 	 * machine.
 	 */
-	struct sci_base_state_machine state_machine;
+	struct sci_base_state_machine sm;
 
 	/**
 	 * Timer for controller start/stop operations.
@@ -359,7 +359,7 @@ enum scic_sds_controller_states {
 	/**
 	 * Simply the initial state for the base controller state machine.
 	 */
-	SCI_BASE_CONTROLLER_STATE_INITIAL = 0,
+	SCIC_INITIAL = 0,
 
 	/**
 	 * This state indicates that the controller is reset.  The memory for
@@ -368,7 +368,7 @@ enum scic_sds_controller_states {
 	 * This state is entered from the INITIAL state.
 	 * This state is entered from the RESETTING state.
 	 */
-	SCI_BASE_CONTROLLER_STATE_RESET,
+	SCIC_RESET,
 
 	/**
 	 * This state is typically an action state that indicates the controller
@@ -376,28 +376,28 @@ enum scic_sds_controller_states {
 	 * are permitted.
 	 * This state is entered from the RESET state.
 	 */
-	SCI_BASE_CONTROLLER_STATE_INITIALIZING,
+	SCIC_INITIALIZING,
 
 	/**
 	 * This state indicates that the controller has been successfully
 	 * initialized.  In this state no new IO operations are permitted.
 	 * This state is entered from the INITIALIZING state.
 	 */
-	SCI_BASE_CONTROLLER_STATE_INITIALIZED,
+	SCIC_INITIALIZED,
 
 	/**
 	 * This state indicates the the controller is in the process of becoming
 	 * ready (i.e. starting).  In this state no new IO operations are permitted.
 	 * This state is entered from the INITIALIZED state.
 	 */
-	SCI_BASE_CONTROLLER_STATE_STARTING,
+	SCIC_STARTING,
 
 	/**
 	 * This state indicates the controller is now ready.  Thus, the user
 	 * is able to perform IO operations on the controller.
 	 * This state is entered from the STARTING state.
 	 */
-	SCI_BASE_CONTROLLER_STATE_READY,
+	SCIC_READY,
 
 	/**
 	 * This state is typically an action state that indicates the controller
@@ -408,7 +408,7 @@ enum scic_sds_controller_states {
 	 * This state is entered from the FAILED state.
 	 * This state is entered from the STOPPED state.
 	 */
-	SCI_BASE_CONTROLLER_STATE_RESETTING,
+	SCIC_RESETTING,
 
 	/**
 	 * This state indicates that the controller is in the process of stopping.
@@ -416,14 +416,14 @@ enum scic_sds_controller_states {
 	 * operations are allowed to complete.
 	 * This state is entered from the READY state.
 	 */
-	SCI_BASE_CONTROLLER_STATE_STOPPING,
+	SCIC_STOPPING,
 
 	/**
 	 * This state indicates that the controller has successfully been stopped.
 	 * In this state no new IO operations are permitted.
 	 * This state is entered from the STOPPING state.
 	 */
-	SCI_BASE_CONTROLLER_STATE_STOPPED,
+	SCIC_STOPPED,
 
 	/**
 	 * This state indicates that the controller could not successfully be
@@ -433,10 +433,7 @@ enum scic_sds_controller_states {
 	 * This state is entered from the STOPPING state.
 	 * This state is entered from the RESETTING state.
 	 */
-	SCI_BASE_CONTROLLER_STATE_FAILED,
-
-	SCI_BASE_CONTROLLER_MAX_STATES
-
+	SCIC_FAILED,
 };
 
 

commit 8db02da52895285e99d7eb2fa825fd393e61d9c5
Author: Edmund Nadolski <edmund.nadolski@intel.com>
Date:   Thu May 19 12:00:22 2011 +0000

    isci: remove isci_timer interface
    
    Delete code which is no longer used.
    
    Signed-off-by: Edmund Nadolski <edmund.nadolski@intel.com>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/drivers/scsi/isci/host.h b/drivers/scsi/isci/host.h
index 9fd47b42da05..4ce39e1803ff 100644
--- a/drivers/scsi/isci/host.h
+++ b/drivers/scsi/isci/host.h
@@ -325,7 +325,6 @@ struct isci_host {
 	union scic_oem_parameters oem_parameters;
 
 	int id; /* unique within a given pci device */
-	struct list_head timers;
 	void *core_ctrl_memory;
 	struct dma_pool *dma_pool;
 	struct isci_phy phys[SCI_MAX_PHYS];

commit bb3dbdf6c835a145e46119ed18a920a774694583
Author: Edmund Nadolski <edmund.nadolski@intel.com>
Date:   Thu May 19 20:26:02 2011 -0700

    isci: convert phy_startup_timer to sci_timer
    
    Signed-off-by: Edmund Nadolski <edmund.nadolski@intel.com>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/drivers/scsi/isci/host.h b/drivers/scsi/isci/host.h
index 80808661ce5c..9fd47b42da05 100644
--- a/drivers/scsi/isci/host.h
+++ b/drivers/scsi/isci/host.h
@@ -271,15 +271,14 @@ struct scic_sds_controller {
 
 	/* Phy Startup Data */
 	/**
-	 * This field is the driver timer handle for controller phy request startup.
-	 * On controller start the controller will start each PHY individually in
-	 * order of phy index.
+	 * Timer for controller phy request startup. On controller start the
+	 * controller will start each PHY individually in order of phy index.
 	 */
-	void *phy_startup_timer;
+	struct sci_timer phy_timer;
 
 	/**
-	 * This field is set when the phy_startup_timer is running and is cleared when
-	 * the phy_startup_timer is stopped.
+	 * This field is set when the phy_timer is running and is cleared when
+	 * the phy_timer is stopped.
 	 */
 	bool phy_startup_timer_pending;
 

commit 6cb5853d3e252015eaf72d3761491e3da959556d
Author: Edmund Nadolski <edmund.nadolski@intel.com>
Date:   Thu May 19 11:59:56 2011 +0000

    isci: convert scic_timeout_timer to sci_timer
    
    Signed-off-by: Edmund Nadolski <edmund.nadolski@intel.com>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/drivers/scsi/isci/host.h b/drivers/scsi/isci/host.h
index 2be935fa6af2..80808661ce5c 100644
--- a/drivers/scsi/isci/host.h
+++ b/drivers/scsi/isci/host.h
@@ -137,10 +137,9 @@ struct scic_sds_controller {
 	struct sci_base_state_machine state_machine;
 
 	/**
-	 * This field is the driver timer object handler used to time the controller
-	 * object start and stop requests.
+	 * Timer for controller start/stop operations.
 	 */
-	void *timeout_timer;
+	struct sci_timer timer;
 
 	/**
 	 * This field contains the user parameters to be utilized for this

commit 0473661a125905240879456567e117ed8a58cf5d
Author: Edmund Nadolski <edmund.nadolski@intel.com>
Date:   Thu May 19 20:17:47 2011 -0700

    isci: convert power control timer to sci_timer
    
    Signed-off-by: Edmund Nadolski <edmund.nadolski@intel.com>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/drivers/scsi/isci/host.h b/drivers/scsi/isci/host.h
index deb0ee031f27..2be935fa6af2 100644
--- a/drivers/scsi/isci/host.h
+++ b/drivers/scsi/isci/host.h
@@ -83,10 +83,9 @@ struct scic_power_control {
 	bool timer_started;
 
 	/**
-	 * This field is the handle to the driver timer object.  This timer is used to
-	 * control when the directed attached disks can consume power.
+	 * Timer to control when the directed attached disks can consume power.
 	 */
-	void *timer;
+	struct sci_timer timer;
 
 	/**
 	 * This field is used to keep track of how many phys are put into the

commit ac0eeb4f774261d1da21a68169f7ddd4f6c082fc
Author: Edmund Nadolski <edmund.nadolski@intel.com>
Date:   Thu May 19 20:00:51 2011 -0700

    isci: convert port config agent timer to sci_timer
    
    Signed-off-by: Edmund Nadolski <edmund.nadolski@intel.com>
    [squashed collateral cleanups]
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/drivers/scsi/isci/host.h b/drivers/scsi/isci/host.h
index 784e1355e8ec..deb0ee031f27 100644
--- a/drivers/scsi/isci/host.h
+++ b/drivers/scsi/isci/host.h
@@ -122,7 +122,7 @@ struct scic_sds_port_configuration_agent {
 	bool timer_pending;
 	port_config_fn link_up_handler;
 	port_config_fn link_down_handler;
-	void *timer;
+	struct sci_timer	timer;
 };
 
 /**
@@ -568,15 +568,6 @@ static inline struct isci_host *scic_to_ihost(struct scic_sds_controller *scic)
 		} \
 	}
 
-/**
- * scic_sds_controller_get_port_configuration_agent() -
- *
- * This is a helper macro to get the port configuration agent from the
- * controller object.
- */
-#define scic_sds_controller_get_port_configuration_agent(controller) \
-	(&(controller)->port_agent)
-
 /**
  * scic_sds_controller_get_protocol_engine_group() -
  *

commit e2f8db509fdd354bb7a68c86515e9d2d8909ccc9
Author: Dan Williams <dan.j.williams@intel.com>
Date:   Tue May 10 02:28:46 2011 -0700

    isci: uplevel port infrastructure
    
    * Move port configuration agent implementation
    * Merge core/scic_sds_port.[ch] into port.[ch]
    
    Reported-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/drivers/scsi/isci/host.h b/drivers/scsi/isci/host.h
index 9c5d121ce791..784e1355e8ec 100644
--- a/drivers/scsi/isci/host.h
+++ b/drivers/scsi/isci/host.h
@@ -55,7 +55,6 @@
 #ifndef _SCI_HOST_H_
 #define _SCI_HOST_H_
 
-#include "scic_config_parameters.h"
 #include "remote_device.h"
 #include "phy.h"
 #include "pool.h"
@@ -64,11 +63,12 @@
 #include "registers.h"
 #include "scu_unsolicited_frame.h"
 #include "unsolicited_frame_control.h"
-#include "scic_sds_port_configuration_agent.h"
+#include "probe_roms.h"
 
 struct scic_sds_request;
 struct scu_task_context;
 
+
 /**
  * struct scic_power_control -
  *
@@ -107,6 +107,24 @@ struct scic_power_control {
 
 };
 
+struct scic_sds_port_configuration_agent;
+typedef void (*port_config_fn)(struct scic_sds_controller *,
+			       struct scic_sds_port_configuration_agent *,
+			       struct scic_sds_port *, struct scic_sds_phy *);
+
+struct scic_sds_port_configuration_agent {
+	u16 phy_configured_mask;
+	u16 phy_ready_mask;
+	struct {
+		u8 min_index;
+		u8 max_index;
+	} phy_valid_port_range[SCI_MAX_PHYS];
+	bool timer_pending;
+	port_config_fn link_up_handler;
+	port_config_fn link_down_handler;
+	void *timer;
+};
+
 /**
  * struct scic_sds_controller -
  *
@@ -800,4 +818,11 @@ u16 scic_controller_allocate_io_tag(
 enum sci_status scic_controller_free_io_tag(
 	struct scic_sds_controller *scic,
 	u16 io_tag);
+
+void scic_sds_port_configuration_agent_construct(
+	struct scic_sds_port_configuration_agent *port_agent);
+
+enum sci_status scic_sds_port_configuration_agent_initialize(
+	struct scic_sds_controller *controller,
+	struct scic_sds_port_configuration_agent *port_agent);
 #endif

commit 3bff9d54ecba84e538da822349a9a6fd6e534539
Author: Dan Williams <dan.j.williams@intel.com>
Date:   Sun May 8 22:15:10 2011 -0700

    isci: uplevel state machine
    
    unify core/sci_base_state.h and core/sci_base_state_machine.[ch] into
    state_machine.[ch]
    
    Reported-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/drivers/scsi/isci/host.h b/drivers/scsi/isci/host.h
index 64edac8ccce1..9c5d121ce791 100644
--- a/drivers/scsi/isci/host.h
+++ b/drivers/scsi/isci/host.h
@@ -59,7 +59,7 @@
 #include "remote_device.h"
 #include "phy.h"
 #include "pool.h"
-#include "sci_base_state_machine.h"
+#include "state_machine.h"
 #include "remote_node_table.h"
 #include "registers.h"
 #include "scu_unsolicited_frame.h"

commit 63a3a15fb00ef49e50e98ff675094afcd92f113a
Author: Dan Williams <dan.j.williams@intel.com>
Date:   Sun May 8 21:36:46 2011 -0700

    isci: uplevel register hardware data structures and unsolicited frame handling
    
    Reported-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/drivers/scsi/isci/host.h b/drivers/scsi/isci/host.h
index 1f542c47fb3a..64edac8ccce1 100644
--- a/drivers/scsi/isci/host.h
+++ b/drivers/scsi/isci/host.h
@@ -61,9 +61,9 @@
 #include "pool.h"
 #include "sci_base_state_machine.h"
 #include "remote_node_table.h"
-#include "scu_registers.h"
+#include "registers.h"
 #include "scu_unsolicited_frame.h"
-#include "scic_sds_unsolicited_frame_control.h"
+#include "unsolicited_frame_control.h"
 #include "scic_sds_port_configuration_agent.h"
 
 struct scic_sds_request;

commit cc9203bf381a465cd115762b9cf7c9a313c874bc
Author: Dan Williams <dan.j.williams@intel.com>
Date:   Sun May 8 17:34:44 2011 -0700

    isci: move core/controller to host
    
    Now that the data structures are unified unify the implementation in
    host.[ch] and cleanup namespace pollution.
    
    Reported-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/drivers/scsi/isci/host.h b/drivers/scsi/isci/host.h
index 13c1c99ef294..1f542c47fb3a 100644
--- a/drivers/scsi/isci/host.h
+++ b/drivers/scsi/isci/host.h
@@ -52,13 +52,258 @@
  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
-
 #ifndef _SCI_HOST_H_
 #define _SCI_HOST_H_
 
-#include "scic_sds_controller.h"
+#include "scic_config_parameters.h"
 #include "remote_device.h"
 #include "phy.h"
+#include "pool.h"
+#include "sci_base_state_machine.h"
+#include "remote_node_table.h"
+#include "scu_registers.h"
+#include "scu_unsolicited_frame.h"
+#include "scic_sds_unsolicited_frame_control.h"
+#include "scic_sds_port_configuration_agent.h"
+
+struct scic_sds_request;
+struct scu_task_context;
+
+/**
+ * struct scic_power_control -
+ *
+ * This structure defines the fields for managing power control for direct
+ * attached disk devices.
+ */
+struct scic_power_control {
+	/**
+	 * This field is set when the power control timer is running and cleared when
+	 * it is not.
+	 */
+	bool timer_started;
+
+	/**
+	 * This field is the handle to the driver timer object.  This timer is used to
+	 * control when the directed attached disks can consume power.
+	 */
+	void *timer;
+
+	/**
+	 * This field is used to keep track of how many phys are put into the
+	 * requesters field.
+	 */
+	u8 phys_waiting;
+
+	/**
+	 * This field is used to keep track of how many phys have been granted to consume power
+	 */
+	u8 phys_granted_power;
+
+	/**
+	 * This field is an array of phys that we are waiting on. The phys are direct
+	 * mapped into requesters via struct scic_sds_phy.phy_index
+	 */
+	struct scic_sds_phy *requesters[SCI_MAX_PHYS];
+
+};
+
+/**
+ * struct scic_sds_controller -
+ *
+ * This structure represents the SCU controller object.
+ */
+struct scic_sds_controller {
+	/**
+	 * This field contains the information for the base controller state
+	 * machine.
+	 */
+	struct sci_base_state_machine state_machine;
+
+	/**
+	 * This field is the driver timer object handler used to time the controller
+	 * object start and stop requests.
+	 */
+	void *timeout_timer;
+
+	/**
+	 * This field contains the user parameters to be utilized for this
+	 * core controller object.
+	 */
+	union scic_user_parameters user_parameters;
+
+	/**
+	 * This field contains the OEM parameters to be utilized for this
+	 * core controller object.
+	 */
+	union scic_oem_parameters oem_parameters;
+
+	/**
+	 * This field contains the port configuration agent for this controller.
+	 */
+	struct scic_sds_port_configuration_agent port_agent;
+
+	/**
+	 * This field is the array of device objects that are currently constructed
+	 * for this controller object.  This table is used as a fast lookup of device
+	 * objects that need to handle device completion notifications from the
+	 * hardware. The table is RNi based.
+	 */
+	struct scic_sds_remote_device *device_table[SCI_MAX_REMOTE_DEVICES];
+
+	/**
+	 * This field is the array of IO request objects that are currently active for
+	 * this controller object.  This table is used as a fast lookup of the io
+	 * request object that need to handle completion queue notifications.  The
+	 * table is TCi based.
+	 */
+	struct scic_sds_request *io_request_table[SCI_MAX_IO_REQUESTS];
+
+	/**
+	 * This field is the free RNi data structure
+	 */
+	struct scic_remote_node_table available_remote_nodes;
+
+	/**
+	 * This field is the TCi pool used to manage the task context index.
+	 */
+	SCI_POOL_CREATE(tci_pool, u16, SCI_MAX_IO_REQUESTS);
+
+	/**
+	 * This filed is the struct scic_power_control data used to controll when direct
+	 * attached devices can consume power.
+	 */
+	struct scic_power_control power_control;
+
+	/**
+	 * This field is the array of sequence values for the IO Tag fields.  Even
+	 * though only 4 bits of the field is used for the sequence the sequence is 16
+	 * bits in size so the sequence can be bitwise or'd with the TCi to build the
+	 * IO Tag value.
+	 */
+	u16 io_request_sequence[SCI_MAX_IO_REQUESTS];
+
+	/**
+	 * This field in the array of sequence values for the RNi.  These are used
+	 * to control io request build to io request start operations.  The sequence
+	 * value is recorded into an io request when it is built and is checked on
+	 * the io request start operation to make sure that there was not a device
+	 * hot plug between the build and start operation.
+	 */
+	u8 remote_device_sequence[SCI_MAX_REMOTE_DEVICES];
+
+	/**
+	 * This field is a pointer to the memory allocated by the driver for the task
+	 * context table.  This data is shared between the hardware and software.
+	 */
+	struct scu_task_context *task_context_table;
+
+	/**
+	 * This field is a pointer to the memory allocated by the driver for the
+	 * remote node context table.  This table is shared between the hardware and
+	 * software.
+	 */
+	union scu_remote_node_context *remote_node_context_table;
+
+	/**
+	 * This field is a pointer to the completion queue.  This memory is
+	 * written to by the hardware and read by the software.
+	 */
+	u32 *completion_queue;
+
+	/**
+	 * This field is the software copy of the completion queue get pointer.  The
+	 * controller object writes this value to the hardware after processing the
+	 * completion entries.
+	 */
+	u32 completion_queue_get;
+
+	/**
+	 * This field is the minimum of the number of hardware supported port entries
+	 * and the software requested port entries.
+	 */
+	u32 logical_port_entries;
+
+	/**
+	 * This field is the minimum number of hardware supported completion queue
+	 * entries and the software requested completion queue entries.
+	 */
+	u32 completion_queue_entries;
+
+	/**
+	 * This field is the minimum number of hardware supported event entries and
+	 * the software requested event entries.
+	 */
+	u32 completion_event_entries;
+
+	/**
+	 * This field is the minimum number of devices supported by the hardware and
+	 * the number of devices requested by the software.
+	 */
+	u32 remote_node_entries;
+
+	/**
+	 * This field is the minimum number of IO requests supported by the hardware
+	 * and the number of IO requests requested by the software.
+	 */
+	u32 task_context_entries;
+
+	/**
+	 * This object contains all of the unsolicited frame specific
+	 * data utilized by the core controller.
+	 */
+	struct scic_sds_unsolicited_frame_control uf_control;
+
+	/* Phy Startup Data */
+	/**
+	 * This field is the driver timer handle for controller phy request startup.
+	 * On controller start the controller will start each PHY individually in
+	 * order of phy index.
+	 */
+	void *phy_startup_timer;
+
+	/**
+	 * This field is set when the phy_startup_timer is running and is cleared when
+	 * the phy_startup_timer is stopped.
+	 */
+	bool phy_startup_timer_pending;
+
+	/**
+	 * This field is the index of the next phy start.  It is initialized to 0 and
+	 * increments for each phy index that is started.
+	 */
+	u32 next_phy_to_start;
+
+	/**
+	 * This field controlls the invalid link up notifications to the SCI_USER.  If
+	 * an invalid_link_up notification is reported a bit for the PHY index is set
+	 * so further notifications are not made.  Once the PHY object reports link up
+	 * and is made part of a port then this bit for the PHY index is cleared.
+	 */
+	u8 invalid_phy_mask;
+
+	/*
+	 * This field saves the current interrupt coalescing number of the controller.
+	 */
+	u16 interrupt_coalesce_number;
+
+	/*
+	 * This field saves the current interrupt coalescing timeout value in microseconds.
+	 */
+	u32 interrupt_coalesce_timeout;
+
+	/**
+	 * This field is a pointer to the memory mapped register space for the
+	 * struct smu_registers.
+	 */
+	struct smu_registers __iomem *smu_registers;
+
+	/**
+	 * This field is a pointer to the memory mapped register space for the
+	 * struct scu_registers.
+	 */
+	struct scu_registers __iomem *scu_registers;
+
+};
 
 struct isci_host {
 	struct scic_sds_controller sci;
@@ -92,6 +337,96 @@ struct isci_host {
 	struct isci_remote_device devices[SCI_MAX_REMOTE_DEVICES];
 };
 
+/**
+ * enum scic_sds_controller_states - This enumeration depicts all the states
+ *    for the common controller state machine.
+ */
+enum scic_sds_controller_states {
+	/**
+	 * Simply the initial state for the base controller state machine.
+	 */
+	SCI_BASE_CONTROLLER_STATE_INITIAL = 0,
+
+	/**
+	 * This state indicates that the controller is reset.  The memory for
+	 * the controller is in it's initial state, but the controller requires
+	 * initialization.
+	 * This state is entered from the INITIAL state.
+	 * This state is entered from the RESETTING state.
+	 */
+	SCI_BASE_CONTROLLER_STATE_RESET,
+
+	/**
+	 * This state is typically an action state that indicates the controller
+	 * is in the process of initialization.  In this state no new IO operations
+	 * are permitted.
+	 * This state is entered from the RESET state.
+	 */
+	SCI_BASE_CONTROLLER_STATE_INITIALIZING,
+
+	/**
+	 * This state indicates that the controller has been successfully
+	 * initialized.  In this state no new IO operations are permitted.
+	 * This state is entered from the INITIALIZING state.
+	 */
+	SCI_BASE_CONTROLLER_STATE_INITIALIZED,
+
+	/**
+	 * This state indicates the the controller is in the process of becoming
+	 * ready (i.e. starting).  In this state no new IO operations are permitted.
+	 * This state is entered from the INITIALIZED state.
+	 */
+	SCI_BASE_CONTROLLER_STATE_STARTING,
+
+	/**
+	 * This state indicates the controller is now ready.  Thus, the user
+	 * is able to perform IO operations on the controller.
+	 * This state is entered from the STARTING state.
+	 */
+	SCI_BASE_CONTROLLER_STATE_READY,
+
+	/**
+	 * This state is typically an action state that indicates the controller
+	 * is in the process of resetting.  Thus, the user is unable to perform
+	 * IO operations on the controller.  A reset is considered destructive in
+	 * most cases.
+	 * This state is entered from the READY state.
+	 * This state is entered from the FAILED state.
+	 * This state is entered from the STOPPED state.
+	 */
+	SCI_BASE_CONTROLLER_STATE_RESETTING,
+
+	/**
+	 * This state indicates that the controller is in the process of stopping.
+	 * In this state no new IO operations are permitted, but existing IO
+	 * operations are allowed to complete.
+	 * This state is entered from the READY state.
+	 */
+	SCI_BASE_CONTROLLER_STATE_STOPPING,
+
+	/**
+	 * This state indicates that the controller has successfully been stopped.
+	 * In this state no new IO operations are permitted.
+	 * This state is entered from the STOPPING state.
+	 */
+	SCI_BASE_CONTROLLER_STATE_STOPPED,
+
+	/**
+	 * This state indicates that the controller could not successfully be
+	 * initialized.  In this state no new IO operations are permitted.
+	 * This state is entered from the INITIALIZING state.
+	 * This state is entered from the STARTING state.
+	 * This state is entered from the STOPPING state.
+	 * This state is entered from the RESETTING state.
+	 */
+	SCI_BASE_CONTROLLER_STATE_FAILED,
+
+	SCI_BASE_CONTROLLER_MAX_STATES
+
+};
+
+
+
 /**
  * struct isci_pci_info - This class represents the pci function containing the
  *    controllers. Depending on PCI SKU, there could be up to 2 controllers in
@@ -115,17 +450,13 @@ static inline struct isci_pci_info *to_pci_info(struct pci_dev *pdev)
 	     id < ARRAY_SIZE(to_pci_info(pdev)->hosts) && ihost; \
 	     ihost = to_pci_info(pdev)->hosts[++id])
 
-static inline
-enum isci_status isci_host_get_state(
-	struct isci_host *isci_host)
+static inline enum isci_status isci_host_get_state(struct isci_host *isci_host)
 {
 	return isci_host->status;
 }
 
-
-static inline void isci_host_change_state(
-	struct isci_host *isci_host,
-	enum isci_status status)
+static inline void isci_host_change_state(struct isci_host *isci_host,
+					  enum isci_status status)
 {
 	unsigned long flags;
 
@@ -140,9 +471,7 @@ static inline void isci_host_change_state(
 
 }
 
-static inline int isci_host_can_queue(
-	struct isci_host *isci_host,
-	int num)
+static inline int isci_host_can_queue(struct isci_host *isci_host, int num)
 {
 	int ret = 0;
 	unsigned long flags;
@@ -163,9 +492,7 @@ static inline int isci_host_can_queue(
 	return ret;
 }
 
-static inline void isci_host_can_dequeue(
-	struct isci_host *isci_host,
-	int num)
+static inline void isci_host_can_dequeue(struct isci_host *isci_host, int num)
 {
 	unsigned long flags;
 
@@ -208,39 +535,219 @@ static inline struct isci_host *scic_to_ihost(struct scic_sds_controller *scic)
 }
 
 /**
- * isci_host_scan_finished() -
+ * INCREMENT_QUEUE_GET() -
  *
- * This function is one of the SCSI Host Template functions. The SCSI midlayer
- * calls this function during a target scan, approx. once every 10 millisecs.
+ * This macro will increment the specified index to and if the index wraps to 0
+ * it will toggel the cycle bit.
  */
-int isci_host_scan_finished(
-	struct Scsi_Host *,
-	unsigned long);
+#define INCREMENT_QUEUE_GET(index, cycle, entry_count, bit_toggle) \
+	{ \
+		if ((index) + 1 == entry_count) {	\
+			(index) = 0; \
+			(cycle) = (cycle) ^ (bit_toggle); \
+		} else { \
+			index = index + 1; \
+		} \
+	}
 
+/**
+ * scic_sds_controller_get_port_configuration_agent() -
+ *
+ * This is a helper macro to get the port configuration agent from the
+ * controller object.
+ */
+#define scic_sds_controller_get_port_configuration_agent(controller) \
+	(&(controller)->port_agent)
 
 /**
- * isci_host_scan_start() -
+ * scic_sds_controller_get_protocol_engine_group() -
  *
- * This function is one of the SCSI Host Template function, called by the SCSI
- * mid layer berfore a target scan begins. The core library controller start
- * routine is called from here.
+ * This macro returns the protocol engine group for this controller object.
+ * Presently we only support protocol engine group 0 so just return that
  */
-void isci_host_scan_start(
-	struct Scsi_Host *);
+#define scic_sds_controller_get_protocol_engine_group(controller) 0
 
 /**
- * isci_host_start_complete() -
+ * scic_sds_io_tag_construct() -
  *
- * This function is called by the core library, through the ISCI Module, to
- * indicate controller start status.
+ * This macro constructs an IO tag from the sequence and index values.
  */
-void isci_host_start_complete(
-	struct isci_host *,
-	enum sci_status);
+#define scic_sds_io_tag_construct(sequence, task_index)	\
+	((sequence) << 12 | (task_index))
 
-void isci_host_stop_complete(
-	struct isci_host *isci_host,
-	enum sci_status completion_status);
+/**
+ * scic_sds_io_tag_get_sequence() -
+ *
+ * This macro returns the IO sequence from the IO tag value.
+ */
+#define scic_sds_io_tag_get_sequence(io_tag) \
+	(((io_tag) & 0xF000) >> 12)
+
+/**
+ * scic_sds_io_tag_get_index() -
+ *
+ * This macro returns the TCi from the io tag value
+ */
+#define scic_sds_io_tag_get_index(io_tag) \
+	((io_tag) & 0x0FFF)
+
+/**
+ * scic_sds_io_sequence_increment() -
+ *
+ * This is a helper macro to increment the io sequence count. We may find in
+ * the future that it will be faster to store the sequence count in such a way
+ * as we dont perform the shift operation to build io tag values so therefore
+ * need a way to incrment them correctly
+ */
+#define scic_sds_io_sequence_increment(value) \
+	((value) = (((value) + 1) & 0x000F))
+
+/* expander attached sata devices require 3 rnc slots */
+static inline int scic_sds_remote_device_node_count(struct scic_sds_remote_device *sci_dev)
+{
+	struct domain_device *dev = sci_dev_to_domain(sci_dev);
+
+	if ((dev->dev_type == SATA_DEV || (dev->tproto & SAS_PROTOCOL_STP)) &&
+	    !sci_dev->is_direct_attached)
+		return SCU_STP_REMOTE_NODE_COUNT;
+	return SCU_SSP_REMOTE_NODE_COUNT;
+}
+
+/**
+ * scic_sds_controller_set_invalid_phy() -
+ *
+ * This macro will set the bit in the invalid phy mask for this controller
+ * object.  This is used to control messages reported for invalid link up
+ * notifications.
+ */
+#define scic_sds_controller_set_invalid_phy(controller, phy) \
+	((controller)->invalid_phy_mask |= (1 << (phy)->phy_index))
+
+/**
+ * scic_sds_controller_clear_invalid_phy() -
+ *
+ * This macro will clear the bit in the invalid phy mask for this controller
+ * object.  This is used to control messages reported for invalid link up
+ * notifications.
+ */
+#define scic_sds_controller_clear_invalid_phy(controller, phy) \
+	((controller)->invalid_phy_mask &= ~(1 << (phy)->phy_index))
+
+static inline struct device *scic_to_dev(struct scic_sds_controller *scic)
+{
+	return &scic_to_ihost(scic)->pdev->dev;
+}
+
+static inline struct device *sciphy_to_dev(struct scic_sds_phy *sci_phy)
+{
+	struct isci_phy *iphy = sci_phy_to_iphy(sci_phy);
+
+	if (!iphy || !iphy->isci_port || !iphy->isci_port->isci_host)
+		return NULL;
+
+	return &iphy->isci_port->isci_host->pdev->dev;
+}
+
+static inline struct device *sciport_to_dev(struct scic_sds_port *sci_port)
+{
+	struct isci_port *iport = sci_port_to_iport(sci_port);
+
+	if (!iport || !iport->isci_host)
+		return NULL;
+
+	return &iport->isci_host->pdev->dev;
+}
+
+static inline struct device *scirdev_to_dev(struct scic_sds_remote_device *sci_dev)
+{
+	struct isci_remote_device *idev =
+			container_of(sci_dev, typeof(*idev), sci);
+
+	if (!idev || !idev->isci_port || !idev->isci_port->isci_host)
+		return NULL;
+
+	return &idev->isci_port->isci_host->pdev->dev;
+}
+
+enum {
+	ISCI_SI_REVA0,
+	ISCI_SI_REVA2,
+	ISCI_SI_REVB0,
+};
+
+extern int isci_si_rev;
+
+static inline bool is_a0(void)
+{
+	return isci_si_rev == ISCI_SI_REVA0;
+}
+
+static inline bool is_a2(void)
+{
+	return isci_si_rev == ISCI_SI_REVA2;
+}
+
+static inline bool is_b0(void)
+{
+	return isci_si_rev > ISCI_SI_REVA2;
+}
+
+void scic_sds_controller_post_request(struct scic_sds_controller *scic,
+				      u32 request);
+void scic_sds_controller_release_frame(struct scic_sds_controller *scic,
+				       u32 frame_index);
+void scic_sds_controller_copy_sata_response(void *response_buffer,
+					    void *frame_header,
+					    void *frame_buffer);
+enum sci_status scic_sds_controller_allocate_remote_node_context(struct scic_sds_controller *scic,
+								 struct scic_sds_remote_device *sci_dev,
+								 u16 *node_id);
+void scic_sds_controller_free_remote_node_context(
+	struct scic_sds_controller *scic,
+	struct scic_sds_remote_device *sci_dev,
+	u16 node_id);
+union scu_remote_node_context *scic_sds_controller_get_remote_node_context_buffer(
+	struct scic_sds_controller *scic,
+	u16 node_id);
+
+struct scic_sds_request *scic_request_by_tag(struct scic_sds_controller *scic,
+					     u16 io_tag);
+
+struct scu_task_context *scic_sds_controller_get_task_context_buffer(
+	struct scic_sds_controller *scic,
+	u16 io_tag);
+
+void scic_sds_controller_power_control_queue_insert(
+	struct scic_sds_controller *scic,
+	struct scic_sds_phy *sci_phy);
+
+void scic_sds_controller_power_control_queue_remove(
+	struct scic_sds_controller *scic,
+	struct scic_sds_phy *sci_phy);
+
+void scic_sds_controller_link_up(
+	struct scic_sds_controller *scic,
+	struct scic_sds_port *sci_port,
+	struct scic_sds_phy *sci_phy);
+
+void scic_sds_controller_link_down(
+	struct scic_sds_controller *scic,
+	struct scic_sds_port *sci_port,
+	struct scic_sds_phy *sci_phy);
+
+void scic_sds_controller_remote_device_stopped(
+	struct scic_sds_controller *scic,
+	struct scic_sds_remote_device *sci_dev);
+
+void scic_sds_controller_copy_task_context(
+	struct scic_sds_controller *scic,
+	struct scic_sds_request *this_request);
+
+void scic_sds_controller_register_setup(struct scic_sds_controller *scic);
+
+enum sci_status scic_controller_continue_io(struct scic_sds_request *sci_req);
+int isci_host_scan_finished(struct Scsi_Host *, unsigned long);
+void isci_host_scan_start(struct Scsi_Host *);
 
 int isci_host_init(struct isci_host *);
 
@@ -262,4 +769,35 @@ void isci_host_remote_device_start_complete(
 	struct isci_remote_device *,
 	enum sci_status);
 
-#endif /* !defined(_SCI_HOST_H_) */
+void scic_controller_disable_interrupts(
+	struct scic_sds_controller *scic);
+
+enum sci_status scic_controller_start_io(
+	struct scic_sds_controller *scic,
+	struct scic_sds_remote_device *remote_device,
+	struct scic_sds_request *io_request,
+	u16 io_tag);
+
+enum sci_task_status scic_controller_start_task(
+	struct scic_sds_controller *scic,
+	struct scic_sds_remote_device *remote_device,
+	struct scic_sds_request *task_request,
+	u16 io_tag);
+
+enum sci_status scic_controller_terminate_request(
+	struct scic_sds_controller *scic,
+	struct scic_sds_remote_device *remote_device,
+	struct scic_sds_request *request);
+
+enum sci_status scic_controller_complete_io(
+	struct scic_sds_controller *scic,
+	struct scic_sds_remote_device *remote_device,
+	struct scic_sds_request *io_request);
+
+u16 scic_controller_allocate_io_tag(
+	struct scic_sds_controller *scic);
+
+enum sci_status scic_controller_free_io_tag(
+	struct scic_sds_controller *scic,
+	u16 io_tag);
+#endif

commit ce2b3261b6765c3b80fda95426c73e8d3bb1b035
Author: Dan Williams <dan.j.williams@intel.com>
Date:   Sun May 8 15:49:15 2011 -0700

    isci: unify constants
    
    cross driver constants are spread out over multiple header files, consolidate
    them into isci.h, and push some includes out to the source files that need
    them.
    
    TODO: remove SCI_MODE_SIZE infrastructure.
    TODO: task.h is full of inlines that are too large
    
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/drivers/scsi/isci/host.h b/drivers/scsi/isci/host.h
index afa41e83eaa7..13c1c99ef294 100644
--- a/drivers/scsi/isci/host.h
+++ b/drivers/scsi/isci/host.h
@@ -53,26 +53,12 @@
  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
 
-
-#if !defined(_SCI_HOST_H_)
+#ifndef _SCI_HOST_H_
 #define _SCI_HOST_H_
 
-#include "phy.h"
 #include "scic_sds_controller.h"
-#include "timers.h"
 #include "remote_device.h"
-
-#define DRV_NAME "isci"
-#define SCI_PCI_BAR_COUNT 2
-#define SCI_NUM_MSI_X_INT 2
-#define SCI_SMU_BAR       0
-#define SCI_SMU_BAR_SIZE  (16*1024)
-#define SCI_SCU_BAR       1
-#define SCI_SCU_BAR_SIZE  (4*1024*1024)
-#define SCI_IO_SPACE_BAR0 2
-#define SCI_IO_SPACE_BAR1 3
-#define ISCI_CAN_QUEUE_VAL 250 /* < SCI_MAX_IO_REQUESTS ? */
-#define SCIC_CONTROLLER_STOP_TIMEOUT 5000
+#include "phy.h"
 
 struct isci_host {
 	struct scic_sds_controller sci;

commit 67ea838d17acdad3331aeae848683c768df96aaa
Author: Dan Williams <dan.j.williams@intel.com>
Date:   Sun May 8 11:47:15 2011 -0700

    isci: unify request data structures
    
    Make scic_sds_request a proper member of isci_request.  Also let's us
    get rid of the dma pool object size tracking since we now know that all
    requests are sizeof(isci_request).  While cleaning up the construct
    routine incidentally replaced SCI_FIELD_OFFSET with offsetof.
    
    Reported-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/drivers/scsi/isci/host.h b/drivers/scsi/isci/host.h
index 5a414c31a877..afa41e83eaa7 100644
--- a/drivers/scsi/isci/host.h
+++ b/drivers/scsi/isci/host.h
@@ -82,7 +82,6 @@ struct isci_host {
 	struct list_head timers;
 	void *core_ctrl_memory;
 	struct dma_pool *dma_pool;
-	unsigned int dma_pool_alloc_size;
 	struct isci_phy phys[SCI_MAX_PHYS];
 	struct isci_port ports[SCI_MAX_PORTS + 1]; /* includes dummy port */
 	struct sas_ha_struct sas_ha;

commit e531381e2f8a68b8737c63c7bb890ad80b2470bd
Author: Dan Williams <dan.j.williams@intel.com>
Date:   Sat May 7 10:11:43 2011 -0700

    isci: unify port data structures
    
    Make scic_sds_port a member of isci_port and merge their lifetimes which
    means removing the port table from scic_sds_controller in favor of the
    one at the isci_host level.  Merge ihost->sas_ports into ihost->ports.
    _
    Reported-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/drivers/scsi/isci/host.h b/drivers/scsi/isci/host.h
index 00e4854e20d9..5a414c31a877 100644
--- a/drivers/scsi/isci/host.h
+++ b/drivers/scsi/isci/host.h
@@ -84,12 +84,7 @@ struct isci_host {
 	struct dma_pool *dma_pool;
 	unsigned int dma_pool_alloc_size;
 	struct isci_phy phys[SCI_MAX_PHYS];
-
-	/* isci_ports and sas_ports are implicitly parallel to the
-	 * ports maintained by the core
-	 */
-	struct isci_port isci_ports[SCI_MAX_PORTS];
-	struct asd_sas_port sas_ports[SCI_MAX_PORTS];
+	struct isci_port ports[SCI_MAX_PORTS + 1]; /* includes dummy port */
 	struct sas_ha_struct sas_ha;
 
 	int can_queue;

commit cc3dbd0a9178865d4444f8e28b51715808e9ac85
Author: Artur Wojcik <artur.wojcik@intel.com>
Date:   Wed May 4 07:58:16 2011 +0000

    isci: unify isci_host data structures
    
    Make it explicit that isci_host and scic_sds_controller are one in the same
    object.
    
    Signed-off-by: Artur Wojcik <artur.wojcik@intel.com>
    [removed ->ihost back pointer]
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/drivers/scsi/isci/host.h b/drivers/scsi/isci/host.h
index 8dc8d1c46986..00e4854e20d9 100644
--- a/drivers/scsi/isci/host.h
+++ b/drivers/scsi/isci/host.h
@@ -58,7 +58,7 @@
 #define _SCI_HOST_H_
 
 #include "phy.h"
-/*#include "task.h"*/
+#include "scic_sds_controller.h"
 #include "timers.h"
 #include "remote_device.h"
 
@@ -75,7 +75,7 @@
 #define SCIC_CONTROLLER_STOP_TIMEOUT 5000
 
 struct isci_host {
-	struct scic_sds_controller *core_controller;
+	struct scic_sds_controller sci;
 	union scic_oem_parameters oem_parameters;
 
 	int id; /* unique within a given pci device */
@@ -219,6 +219,14 @@ static inline struct isci_host *dev_to_ihost(struct domain_device *dev)
 	return dev->port->ha->lldd_ha;
 }
 
+static inline struct isci_host *scic_to_ihost(struct scic_sds_controller *scic)
+{
+	/* XXX delete after merging scic_sds_contoller and isci_host */
+	struct isci_host *ihost = container_of(scic, typeof(*ihost), sci);
+
+	return ihost;
+}
+
 /**
  * isci_host_scan_finished() -
  *

commit 88f3b62ac131e2549b6c262cacbd47e8cca42d6e
Author: Dan Williams <dan.j.williams@intel.com>
Date:   Fri Apr 22 19:18:03 2011 -0700

    isci: move remote_device handling out of the core
    
    Now that the core/lldd remote_device data structures are nominally unified
    merge the corresponding sources into the top-level directory.  Also move the
    remote_node_context infrastructure which has no analog at the lldd level.
    
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/drivers/scsi/isci/host.h b/drivers/scsi/isci/host.h
index 21bd7d88e5d8..8dc8d1c46986 100644
--- a/drivers/scsi/isci/host.h
+++ b/drivers/scsi/isci/host.h
@@ -61,7 +61,6 @@
 /*#include "task.h"*/
 #include "timers.h"
 #include "remote_device.h"
-#include "scic_remote_device.h"
 
 #define DRV_NAME "isci"
 #define SCI_PCI_BAR_COUNT 2

commit 57f20f4ed6fb702339be2ef4dea9d15e6a7d0d07
Author: Dan Williams <dan.j.williams@intel.com>
Date:   Thu Apr 21 18:14:45 2011 -0700

    isci: unify remote_device data structures
    
    Make it explicit that isci_remote_device and scic_sds_remote_device are
    one in the same object.
    
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/drivers/scsi/isci/host.h b/drivers/scsi/isci/host.h
index 6e660744d8d4..21bd7d88e5d8 100644
--- a/drivers/scsi/isci/host.h
+++ b/drivers/scsi/isci/host.h
@@ -110,18 +110,9 @@ struct isci_host {
 	struct list_head requests_to_errorback;
 	spinlock_t scic_lock;
 
-	/* careful only access this via idev_by_id */
-	struct isci_remote_device devices[0];
+	struct isci_remote_device devices[SCI_MAX_REMOTE_DEVICES];
 };
 
-static inline struct isci_remote_device *idev_by_id(struct isci_host *ihost, int i)
-{
-	void *p = ihost->devices;
-
-	return p + i * (sizeof(struct isci_remote_device) +
-			scic_remote_device_get_object_size());
-}
-
 /**
  * struct isci_pci_info - This class represents the pci function containing the
  *    controllers. Depending on PCI SKU, there could be up to 2 controllers in

commit bc5c96748a5f2067193faa8131b2aa5f9775d309
Author: Christoph Hellwig <hch@infradead.org>
Date:   Sat Apr 2 08:15:04 2011 -0400

    isci: simplify dma coherent allocation
    
    Remove the insane infrastructure for preallocating coheren DMA regions,
    and just allocate the memory where needed.  This also gets rid of the
    aligment adjustments given that Documentation/DMA-API-HOWTO.txt sais:
    
      "The cpu return address and the DMA bus master address are both
       guaranteed to be aligned to the smallest PAGE_SIZE order which
       is greater than or equal to the requested size.  This invariant
       exists (for example) to guarantee that if you allocate a chunk
       which is smaller than or equal to 64 kilobytes, the extent of the
       buffer you receive will not cross a 64K boundary."
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    [djbw: moved allocation from start to init, re-add memset]
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/drivers/scsi/isci/host.h b/drivers/scsi/isci/host.h
index 8372094ef5ad..6e660744d8d4 100644
--- a/drivers/scsi/isci/host.h
+++ b/drivers/scsi/isci/host.h
@@ -75,14 +75,6 @@
 #define ISCI_CAN_QUEUE_VAL 250 /* < SCI_MAX_IO_REQUESTS ? */
 #define SCIC_CONTROLLER_STOP_TIMEOUT 5000
 
-struct coherent_memory_info {
-	struct list_head node;
-	dma_addr_t dma_handle;
-	void *vaddr;
-	size_t size;
-	struct sci_physical_memory_descriptor *mde;
-};
-
 struct isci_host {
 	struct scic_sds_controller *core_controller;
 	union scic_oem_parameters oem_parameters;
@@ -114,7 +106,6 @@ struct isci_host {
 	wait_queue_head_t eventq;
 	struct Scsi_Host *shost;
 	struct tasklet_struct completion_tasklet;
-	struct list_head mdl_struct_list;
 	struct list_head requests_to_complete;
 	struct list_head requests_to_errorback;
 	spinlock_t scic_lock;

commit 4393aa4e6b9517a666f0ef6b774fd421a9dc4c68
Author: Dan Williams <dan.j.williams@intel.com>
Date:   Thu Mar 31 13:10:44 2011 -0700

    isci: fix fragile/conditional isci_host lookups
    
    A domain_device can always reference back to ->lldd_ha unlike local lldd
    structures.  Fix up cases where the driver uses local objects to look up the
    isci_host.  This also changes the calling conventions of some routines to
    expect a valid isci_host parameter rather than re-lookup the pointer on entry.
    
    Incidentally cleans up some macros that are longer to type than the open-coded
    equivalent:
      isci_host_from_sas_ha
      isci_dev_from_domain_dev
    
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/drivers/scsi/isci/host.h b/drivers/scsi/isci/host.h
index d012b69d8d61..8372094ef5ad 100644
--- a/drivers/scsi/isci/host.h
+++ b/drivers/scsi/isci/host.h
@@ -233,15 +233,10 @@ static inline void wait_for_device_stop(struct isci_host *ihost, struct isci_rem
 	wait_event(ihost->eventq, !test_bit(IDEV_STOP_PENDING, &idev->flags));
 }
 
-/**
- * isci_host_from_sas_ha() - This accessor retrieves the isci_host object
- *    reference from the Linux sas_ha_struct reference.
- * @ha_struct,: This parameter points to the Linux sas_ha_struct object
- *
- * A reference to the associated isci_host structure.
- */
-#define isci_host_from_sas_ha(ha_struct) \
-	((struct isci_host *)(ha_struct)->lldd_ha)
+static inline struct isci_host *dev_to_ihost(struct domain_device *dev)
+{
+	return dev->port->ha->lldd_ha;
+}
 
 /**
  * isci_host_scan_finished() -

commit d044af17aacd03a1f4fced1af4b7570d205c8fd9
Author: Dan Williams <dan.j.williams@intel.com>
Date:   Tue Mar 8 09:52:49 2011 -0800

    isci: Add support for probing OROM for OEM params
    
    We need to scan the OROM for signature and grab the OEM parameters. We
    also need to do the same for EFI. If all fails then we resort to user
    binary blob, and if that fails then we go to the defaults.
    
    Share the format with the create_fw utility so that all possible sources
    of the parameters are in-sync.
    
    Signed-off-by: Dave Jiang <dave.jiang@intel.com>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/drivers/scsi/isci/host.h b/drivers/scsi/isci/host.h
index 889a7850255a..d012b69d8d61 100644
--- a/drivers/scsi/isci/host.h
+++ b/drivers/scsi/isci/host.h
@@ -140,8 +140,8 @@ static inline struct isci_remote_device *idev_by_id(struct isci_host *ihost, int
 
 struct isci_pci_info {
 	struct msix_entry msix_entries[SCI_MAX_MSIX_INT];
-	int core_lib_array_index;
 	struct isci_host *hosts[SCI_MAX_CONTROLLERS];
+	struct isci_orom *orom;
 };
 
 static inline struct isci_pci_info *to_pci_info(struct pci_dev *pdev)

commit 11b00c194cfbd0eb0d90f32c096508b2bb8be6ec
Author: Jeff Skirvin <jeffrey.d.skirvin@intel.com>
Date:   Fri Mar 4 14:06:40 2011 -0800

    isci: Changes in isci_host_completion_routine
    
    Changes to move management of the reqs_in_process entry for the request here.
    Made changes to note when the task is already in the abort path and
    cannot be completed through callbacks.
    
    Signed-off-by: Jeff Skirvin <jeffrey.d.skirvin@intel.com>
    Signed-off-by: Jacek Danecki <Jacek.Danecki@intel.com>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/drivers/scsi/isci/host.h b/drivers/scsi/isci/host.h
index 3c69f1ffb1c3..889a7850255a 100644
--- a/drivers/scsi/isci/host.h
+++ b/drivers/scsi/isci/host.h
@@ -116,7 +116,7 @@ struct isci_host {
 	struct tasklet_struct completion_tasklet;
 	struct list_head mdl_struct_list;
 	struct list_head requests_to_complete;
-	struct list_head requests_to_abort;
+	struct list_head requests_to_errorback;
 	spinlock_t scic_lock;
 
 	/* careful only access this via idev_by_id */

commit d9c37390c4f02153188a64a7a89fa6798dc3ffc2
Author: Dan Williams <dan.j.williams@intel.com>
Date:   Thu Mar 3 17:59:32 2011 -0800

    isci: preallocate remote devices
    
    Until we synchronize against device removal this limits the damage of
    use after free bugs to the driver's own objects.  Unless we implement
    reference counting we need to ensure at least a subset of a remote
    device is valid at all times.  We follow the lead of other libsas
    drivers that also preallocate devices.
    
    This also enforces maximum remote device accounting at the lldd layer,
    but the core may still run out of RNC's before we hit this limit.
    
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/drivers/scsi/isci/host.h b/drivers/scsi/isci/host.h
index 6a6304c06976..3c69f1ffb1c3 100644
--- a/drivers/scsi/isci/host.h
+++ b/drivers/scsi/isci/host.h
@@ -61,6 +61,7 @@
 /*#include "task.h"*/
 #include "timers.h"
 #include "remote_device.h"
+#include "scic_remote_device.h"
 
 #define DRV_NAME "isci"
 #define SCI_PCI_BAR_COUNT 2
@@ -117,8 +118,18 @@ struct isci_host {
 	struct list_head requests_to_complete;
 	struct list_head requests_to_abort;
 	spinlock_t scic_lock;
+
+	/* careful only access this via idev_by_id */
+	struct isci_remote_device devices[0];
 };
 
+static inline struct isci_remote_device *idev_by_id(struct isci_host *ihost, int i)
+{
+	void *p = ihost->devices;
+
+	return p + i * (sizeof(struct isci_remote_device) +
+			scic_remote_device_get_object_size());
+}
 
 /**
  * struct isci_pci_info - This class represents the pci function containing the
@@ -219,11 +230,7 @@ static inline void wait_for_device_start(struct isci_host *ihost, struct isci_re
 
 static inline void wait_for_device_stop(struct isci_host *ihost, struct isci_remote_device *idev)
 {
-	/* todo switch to:
-	 * wait_event(ihost->eventq, !test_bit(IDEV_STOP_PENDING, &idev->flags));
-	 * once devices are statically allocated
-	 */
-	wait_for_completion(idev->cmp);
+	wait_event(ihost->eventq, !test_bit(IDEV_STOP_PENDING, &idev->flags));
 }
 
 /**

commit 6ad31fec306d532031b2f778f8656385df1b9d8f
Author: Dan Williams <dan.j.williams@intel.com>
Date:   Fri Mar 4 12:10:29 2011 -0800

    isci: replace isci_remote_device completion with event queue
    
    Replace the device completion infrastructure with the controller wide
    event queue.  There was a potential for the stop and ready notifications
    to corrupt each other, now that cannot happen.
    
    The stop pending flag cannot be used until devices are statically
    allocated.  We temporarily need to maintain a completion to handle
    waiting for an object that has disappeared, but we can at least stop
    scribbling on freed memory.
    
    A future change will also get rid of the "stopping" state as it should
    not be exposed to the rest of the driver.
    
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/drivers/scsi/isci/host.h b/drivers/scsi/isci/host.h
index 7c1f0b5cee7d..6a6304c06976 100644
--- a/drivers/scsi/isci/host.h
+++ b/drivers/scsi/isci/host.h
@@ -212,6 +212,19 @@ static inline void wait_for_stop(struct isci_host *ihost)
 	wait_event(ihost->eventq, !test_bit(IHOST_STOP_PENDING, &ihost->flags));
 }
 
+static inline void wait_for_device_start(struct isci_host *ihost, struct isci_remote_device *idev)
+{
+	wait_event(ihost->eventq, !test_bit(IDEV_START_PENDING, &idev->flags));
+}
+
+static inline void wait_for_device_stop(struct isci_host *ihost, struct isci_remote_device *idev)
+{
+	/* todo switch to:
+	 * wait_event(ihost->eventq, !test_bit(IDEV_STOP_PENDING, &idev->flags));
+	 * once devices are statically allocated
+	 */
+	wait_for_completion(idev->cmp);
+}
 
 /**
  * isci_host_from_sas_ha() - This accessor retrieves the isci_host object

commit b329aff107543c3c4db26c1572405034c3baf906
Author: Dan Williams <dan.j.williams@intel.com>
Date:   Mon Mar 7 16:02:25 2011 -0800

    isci: kill isci_host list in favor of an array
    
    isci_host_by_id() should have been a clue that an array would have been
    a simpler approach.
    
    Reported-by: James Bottomley <James.Bottomley@suse.de>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/drivers/scsi/isci/host.h b/drivers/scsi/isci/host.h
index ef3e7d1440b0..7c1f0b5cee7d 100644
--- a/drivers/scsi/isci/host.h
+++ b/drivers/scsi/isci/host.h
@@ -117,7 +117,6 @@ struct isci_host {
 	struct list_head requests_to_complete;
 	struct list_head requests_to_abort;
 	spinlock_t scic_lock;
-	struct isci_host *next;
 };
 
 
@@ -131,7 +130,7 @@ struct isci_host {
 struct isci_pci_info {
 	struct msix_entry msix_entries[SCI_MAX_MSIX_INT];
 	int core_lib_array_index;
-	struct isci_host *hosts;
+	struct isci_host *hosts[SCI_MAX_CONTROLLERS];
 };
 
 static inline struct isci_pci_info *to_pci_info(struct pci_dev *pdev)
@@ -139,9 +138,10 @@ static inline struct isci_pci_info *to_pci_info(struct pci_dev *pdev)
 	return pci_get_drvdata(pdev);
 }
 
-#define for_each_isci_host(isci_host, pdev) \
-	for (isci_host = to_pci_info(pdev)->hosts;\
-	     isci_host; isci_host = isci_host->next)
+#define for_each_isci_host(id, ihost, pdev) \
+	for (id = 0, ihost = to_pci_info(pdev)->hosts[id]; \
+	     id < ARRAY_SIZE(to_pci_info(pdev)->hosts) && ihost; \
+	     ihost = to_pci_info(pdev)->hosts[++id])
 
 static inline
 enum isci_status isci_host_get_state(

commit 7c40a8035815479c7c12ab0cdcea71e0f4c3a9c8
Author: Dan Williams <dan.j.williams@intel.com>
Date:   Wed Mar 2 11:49:26 2011 -0800

    isci: rework timer api
    
    Prepare the timer api for the arrival of dynamic creation and
    destruction events from the core.  It pretended to do this previously
    but the core to date only used it in a static init-time only fashion.
    This is an interim fix until a cleaner event queue can be developed.
    
    1/ make all locking external to the api (add WARN_ONCE to verify)
    2/ add a timer_destroy interface (to be used by the core)
    3/ use del_timer_sync() prior to deallocating timer data
    4/ delete the "timer_list" indirection, we only have timers allocated
       for the isci_host
    5/ fix detection of timer list allocation errors
    
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/drivers/scsi/isci/host.h b/drivers/scsi/isci/host.h
index b794dfd0819e..ef3e7d1440b0 100644
--- a/drivers/scsi/isci/host.h
+++ b/drivers/scsi/isci/host.h
@@ -87,7 +87,7 @@ struct isci_host {
 	union scic_oem_parameters oem_parameters;
 
 	int id; /* unique within a given pci device */
-	struct isci_timer_list timer_list_struct;
+	struct list_head timers;
 	void *core_ctrl_memory;
 	struct dma_pool *dma_pool;
 	unsigned int dma_pool_alloc_size;

commit 150fc6fc725055b400a8865e6785dc8dd0a2225d
Author: Dan Williams <dan.j.williams@intel.com>
Date:   Fri Feb 25 10:25:21 2011 -0800

    isci: fix sas address reporting
    
    Undo the open coded and incorrect translation of the oem parameter sas
    address to its libsas expected format.
    
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/drivers/scsi/isci/host.h b/drivers/scsi/isci/host.h
index 06154a625aec..b794dfd0819e 100644
--- a/drivers/scsi/isci/host.h
+++ b/drivers/scsi/isci/host.h
@@ -105,7 +105,6 @@ struct isci_host {
 	spinlock_t state_lock;
 
 	struct pci_dev *pdev;
-	u8 sas_addr[SAS_ADDR_SIZE];
 
 	enum isci_status status;
 	#define IHOST_START_PENDING 0

commit 7392d27580df2d14b5c3b1a1d7989c06457a819d
Author: Dave Jiang <dave.jiang@intel.com>
Date:   Wed Feb 23 15:57:33 2011 -0800

    isci: Removing deprecated functions
    
    Removed all callbacks in the deprecated.c. Core will call the appropriate
    functions directly.
    
    Signed-off-by: Dave Jiang <dave.jiang@intel.com>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/drivers/scsi/isci/host.h b/drivers/scsi/isci/host.h
index 26768c5bbe01..06154a625aec 100644
--- a/drivers/scsi/isci/host.h
+++ b/drivers/scsi/isci/host.h
@@ -61,7 +61,6 @@
 /*#include "task.h"*/
 #include "timers.h"
 #include "remote_device.h"
-#include "scic_user_callback.h"
 
 #define DRV_NAME "isci"
 #define SCI_PCI_BAR_COUNT 2

commit 0cf89d1d27c1bdd0abf1714096f98ea44704dcff
Author: Dan Williams <dan.j.williams@intel.com>
Date:   Fri Feb 18 09:25:07 2011 -0800

    isci: cleanup "starting" state handling
    
    The lldd actively disallows requests in the "starting" state.  Retrying
    or holding off commands in this state is sub-optimal:
    1/ it adds another state check to the fast path
    2/ retrying can cause libsas to give up
    
    However, isci's ->lldd_dev_found() routine already waits for controller
    start to complete before allowing further progress.  Checking the
    "starting" state in isci_task_execute_task and the isr is redundant and
    misleading.  Clean this up and introduce a controller-wide event queue
    to start reeling in "completion" proliferation in the driver.
    
    The "stopping" state cleanups are in a similar vein, rely on the the isr
    and other paths being precluded from occurring rather than implementing
    state checking logic.
    
    Reported-by: Christoph Hellwig <hch@infradead.org>
    Cc: Jeff Garzik <jeff@garzik.org>
    Signed-off-by: Edmund Nadolski <edmund.nadolski@intel.com>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/drivers/scsi/isci/host.h b/drivers/scsi/isci/host.h
index 421d3debdaed..26768c5bbe01 100644
--- a/drivers/scsi/isci/host.h
+++ b/drivers/scsi/isci/host.h
@@ -109,13 +109,15 @@ struct isci_host {
 	u8 sas_addr[SAS_ADDR_SIZE];
 
 	enum isci_status status;
+	#define IHOST_START_PENDING 0
+	#define IHOST_STOP_PENDING 1
+	unsigned long flags;
+	wait_queue_head_t eventq;
 	struct Scsi_Host *shost;
 	struct tasklet_struct completion_tasklet;
 	struct list_head mdl_struct_list;
 	struct list_head requests_to_complete;
 	struct list_head requests_to_abort;
-	struct completion stop_complete;
-	struct completion start_complete;
 	spinlock_t scic_lock;
 	struct isci_host *next;
 };
@@ -202,6 +204,17 @@ static inline void isci_host_can_dequeue(
 	spin_unlock_irqrestore(&isci_host->queue_lock, flags);
 }
 
+static inline void wait_for_start(struct isci_host *ihost)
+{
+	wait_event(ihost->eventq, !test_bit(IHOST_START_PENDING, &ihost->flags));
+}
+
+static inline void wait_for_stop(struct isci_host *ihost)
+{
+	wait_event(ihost->eventq, !test_bit(IHOST_STOP_PENDING, &ihost->flags));
+}
+
+
 /**
  * isci_host_from_sas_ha() - This accessor retrieves the isci_host object
  *    reference from the Linux sas_ha_struct reference.

commit c7ef4031f01301298bbaba2666740183cd399f8c
Author: Dan Williams <dan.j.williams@intel.com>
Date:   Fri Feb 18 09:25:05 2011 -0800

    isci: bypass scic_controller_get_handler_methods()
    
    The indirection is unecessary and broken in the current case that assigns the
    handlers based on a not up-to-date pdev->msix_enabled value.
    
    Route the handlers directly to the requisite core routines.
    
    Todo: hook up error interrupt handling
    
    Reported-by: Jeff Garzik <jeff@garzik.org>
    Cc: Christoph Hellwig <hch@infradead.org>
    Signed-off-by: Edmund Nadolski <edmund.nadolski@intel.com>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/drivers/scsi/isci/host.h b/drivers/scsi/isci/host.h
index 4f4b99d29589..421d3debdaed 100644
--- a/drivers/scsi/isci/host.h
+++ b/drivers/scsi/isci/host.h
@@ -53,13 +53,6 @@
  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
 
-/**
- * This file contains the isci_module initialization routines.
- *
- * host.h
- */
-
-
 
 #if !defined(_SCI_HOST_H_)
 #define _SCI_HOST_H_
@@ -79,10 +72,6 @@
 #define SCI_SCU_BAR_SIZE  (4*1024*1024)
 #define SCI_IO_SPACE_BAR0 2
 #define SCI_IO_SPACE_BAR1 3
-#define SCI_MSIX_NORMAL_VECTOR 0
-#define SCI_MSIX_ERROR_VECTOR 1
-#define SCI_MSIX_SINGLE_VECTOR 1
-#define SCI_MSIX_DOUBLE_VECTOR 2
 #define ISCI_CAN_QUEUE_VAL 250 /* < SCI_MAX_IO_REQUESTS ? */
 #define SCIC_CONTROLLER_STOP_TIMEOUT 5000
 
@@ -96,7 +85,6 @@ struct coherent_memory_info {
 
 struct isci_host {
 	struct scic_sds_controller *core_controller;
-	struct scic_controller_handler_methods scic_irq_handlers[SCI_NUM_MSI_X_INT];
 	union scic_oem_parameters oem_parameters;
 
 	int id; /* unique within a given pci device */

commit 74ea9c163a5c09638b453208cd129b686b85e91e
Author: Edmund Nadolski <edmund.nadolski@intel.com>
Date:   Tue Feb 8 08:09:10 2011 -0700

    isci: remove unused SC_LIBRARY_HANDLE_T typedef
    
    Signed-off-by: Edmund Nadolski <edmund.nadolski@intel.com>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/drivers/scsi/isci/host.h b/drivers/scsi/isci/host.h
index 3530076d6107..4f4b99d29589 100644
--- a/drivers/scsi/isci/host.h
+++ b/drivers/scsi/isci/host.h
@@ -143,7 +143,6 @@ struct isci_host {
 struct isci_pci_info {
 	struct msix_entry msix_entries[SCI_MAX_MSIX_INT];
 	int core_lib_array_index;
-	SCI_LIBRARY_HANDLE_T core_lib_handle;
 	struct isci_host *hosts;
 };
 

commit 6f231dda68080759f1aed3769896e94c73099f0f
Author: Dan Williams <dan.j.williams@intel.com>
Date:   Sat Jul 2 22:56:22 2011 -0700

    isci: Intel(R) C600 Series Chipset Storage Control Unit Driver
    
    Support for the up to 2x4-port 6Gb/s SAS controllers embedded in the
    chipset.
    
    This is a snapshot of the first publicly available version of the driver,
    commit 4c1db2d0 in the 'historical' branch.
    
       git://git.kernel.org/pub/scm/linux/kernel/git/djbw/isci.git historical
    
    Signed-off-by: Maciej Trela <maciej.trela@intel.com>
    Signed-off-by: Dave Jiang <dave.jiang@intel.com>
    Signed-off-by: Edmund Nadolski <edmund.nadolski@intel.com>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/drivers/scsi/isci/host.h b/drivers/scsi/isci/host.h
new file mode 100644
index 000000000000..3530076d6107
--- /dev/null
+++ b/drivers/scsi/isci/host.h
@@ -0,0 +1,283 @@
+/*
+ * This file is provided under a dual BSD/GPLv2 license.  When using or
+ * redistributing this file, you may do so under either license.
+ *
+ * GPL LICENSE SUMMARY
+ *
+ * Copyright(c) 2008 - 2011 Intel Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
+ * The full GNU General Public License is included in this distribution
+ * in the file called LICENSE.GPL.
+ *
+ * BSD LICENSE
+ *
+ * Copyright(c) 2008 - 2011 Intel Corporation. All rights reserved.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ *   * Redistributions of source code must retain the above copyright
+ *     notice, this list of conditions and the following disclaimer.
+ *   * Redistributions in binary form must reproduce the above copyright
+ *     notice, this list of conditions and the following disclaimer in
+ *     the documentation and/or other materials provided with the
+ *     distribution.
+ *   * Neither the name of Intel Corporation nor the names of its
+ *     contributors may be used to endorse or promote products derived
+ *     from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/**
+ * This file contains the isci_module initialization routines.
+ *
+ * host.h
+ */
+
+
+
+#if !defined(_SCI_HOST_H_)
+#define _SCI_HOST_H_
+
+#include "phy.h"
+/*#include "task.h"*/
+#include "timers.h"
+#include "remote_device.h"
+#include "scic_user_callback.h"
+
+#define DRV_NAME "isci"
+#define SCI_PCI_BAR_COUNT 2
+#define SCI_NUM_MSI_X_INT 2
+#define SCI_SMU_BAR       0
+#define SCI_SMU_BAR_SIZE  (16*1024)
+#define SCI_SCU_BAR       1
+#define SCI_SCU_BAR_SIZE  (4*1024*1024)
+#define SCI_IO_SPACE_BAR0 2
+#define SCI_IO_SPACE_BAR1 3
+#define SCI_MSIX_NORMAL_VECTOR 0
+#define SCI_MSIX_ERROR_VECTOR 1
+#define SCI_MSIX_SINGLE_VECTOR 1
+#define SCI_MSIX_DOUBLE_VECTOR 2
+#define ISCI_CAN_QUEUE_VAL 250 /* < SCI_MAX_IO_REQUESTS ? */
+#define SCIC_CONTROLLER_STOP_TIMEOUT 5000
+
+struct coherent_memory_info {
+	struct list_head node;
+	dma_addr_t dma_handle;
+	void *vaddr;
+	size_t size;
+	struct sci_physical_memory_descriptor *mde;
+};
+
+struct isci_host {
+	struct scic_sds_controller *core_controller;
+	struct scic_controller_handler_methods scic_irq_handlers[SCI_NUM_MSI_X_INT];
+	union scic_oem_parameters oem_parameters;
+
+	int id; /* unique within a given pci device */
+	struct isci_timer_list timer_list_struct;
+	void *core_ctrl_memory;
+	struct dma_pool *dma_pool;
+	unsigned int dma_pool_alloc_size;
+	struct isci_phy phys[SCI_MAX_PHYS];
+
+	/* isci_ports and sas_ports are implicitly parallel to the
+	 * ports maintained by the core
+	 */
+	struct isci_port isci_ports[SCI_MAX_PORTS];
+	struct asd_sas_port sas_ports[SCI_MAX_PORTS];
+	struct sas_ha_struct sas_ha;
+
+	int can_queue;
+	spinlock_t queue_lock;
+	spinlock_t state_lock;
+
+	struct pci_dev *pdev;
+	u8 sas_addr[SAS_ADDR_SIZE];
+
+	enum isci_status status;
+	struct Scsi_Host *shost;
+	struct tasklet_struct completion_tasklet;
+	struct list_head mdl_struct_list;
+	struct list_head requests_to_complete;
+	struct list_head requests_to_abort;
+	struct completion stop_complete;
+	struct completion start_complete;
+	spinlock_t scic_lock;
+	struct isci_host *next;
+};
+
+
+/**
+ * struct isci_pci_info - This class represents the pci function containing the
+ *    controllers. Depending on PCI SKU, there could be up to 2 controllers in
+ *    the PCI function.
+ */
+#define SCI_MAX_MSIX_INT (SCI_NUM_MSI_X_INT*SCI_MAX_CONTROLLERS)
+
+struct isci_pci_info {
+	struct msix_entry msix_entries[SCI_MAX_MSIX_INT];
+	int core_lib_array_index;
+	SCI_LIBRARY_HANDLE_T core_lib_handle;
+	struct isci_host *hosts;
+};
+
+static inline struct isci_pci_info *to_pci_info(struct pci_dev *pdev)
+{
+	return pci_get_drvdata(pdev);
+}
+
+#define for_each_isci_host(isci_host, pdev) \
+	for (isci_host = to_pci_info(pdev)->hosts;\
+	     isci_host; isci_host = isci_host->next)
+
+static inline
+enum isci_status isci_host_get_state(
+	struct isci_host *isci_host)
+{
+	return isci_host->status;
+}
+
+
+static inline void isci_host_change_state(
+	struct isci_host *isci_host,
+	enum isci_status status)
+{
+	unsigned long flags;
+
+	dev_dbg(&isci_host->pdev->dev,
+		"%s: isci_host = %p, state = 0x%x",
+		__func__,
+		isci_host,
+		status);
+	spin_lock_irqsave(&isci_host->state_lock, flags);
+	isci_host->status = status;
+	spin_unlock_irqrestore(&isci_host->state_lock, flags);
+
+}
+
+static inline int isci_host_can_queue(
+	struct isci_host *isci_host,
+	int num)
+{
+	int ret = 0;
+	unsigned long flags;
+
+	spin_lock_irqsave(&isci_host->queue_lock, flags);
+	if ((isci_host->can_queue - num) < 0) {
+		dev_dbg(&isci_host->pdev->dev,
+			"%s: isci_host->can_queue = %d\n",
+			__func__,
+			isci_host->can_queue);
+		ret = -SAS_QUEUE_FULL;
+
+	} else
+		isci_host->can_queue -= num;
+
+	spin_unlock_irqrestore(&isci_host->queue_lock, flags);
+
+	return ret;
+}
+
+static inline void isci_host_can_dequeue(
+	struct isci_host *isci_host,
+	int num)
+{
+	unsigned long flags;
+
+	spin_lock_irqsave(&isci_host->queue_lock, flags);
+	isci_host->can_queue += num;
+	spin_unlock_irqrestore(&isci_host->queue_lock, flags);
+}
+
+/**
+ * isci_host_from_sas_ha() - This accessor retrieves the isci_host object
+ *    reference from the Linux sas_ha_struct reference.
+ * @ha_struct,: This parameter points to the Linux sas_ha_struct object
+ *
+ * A reference to the associated isci_host structure.
+ */
+#define isci_host_from_sas_ha(ha_struct) \
+	((struct isci_host *)(ha_struct)->lldd_ha)
+
+/**
+ * isci_host_scan_finished() -
+ *
+ * This function is one of the SCSI Host Template functions. The SCSI midlayer
+ * calls this function during a target scan, approx. once every 10 millisecs.
+ */
+int isci_host_scan_finished(
+	struct Scsi_Host *,
+	unsigned long);
+
+
+/**
+ * isci_host_scan_start() -
+ *
+ * This function is one of the SCSI Host Template function, called by the SCSI
+ * mid layer berfore a target scan begins. The core library controller start
+ * routine is called from here.
+ */
+void isci_host_scan_start(
+	struct Scsi_Host *);
+
+/**
+ * isci_host_start_complete() -
+ *
+ * This function is called by the core library, through the ISCI Module, to
+ * indicate controller start status.
+ */
+void isci_host_start_complete(
+	struct isci_host *,
+	enum sci_status);
+
+void isci_host_stop_complete(
+	struct isci_host *isci_host,
+	enum sci_status completion_status);
+
+int isci_host_init(struct isci_host *);
+
+void isci_host_init_controller_names(
+	struct isci_host *isci_host,
+	unsigned int controller_idx);
+
+void isci_host_deinit(
+	struct isci_host *);
+
+void isci_host_port_link_up(
+	struct isci_host *,
+	struct scic_sds_port *,
+	struct scic_sds_phy *);
+int isci_host_dev_found(struct domain_device *);
+
+void isci_host_remote_device_start_complete(
+	struct isci_host *,
+	struct isci_remote_device *,
+	enum sci_status);
+
+#endif /* !defined(_SCI_HOST_H_) */
