commit d44c897c391ed55b7cede2f58d40b0a6e0c5763b
Author: Geert Uytterhoeven <geert+renesas@glider.be>
Date:   Thu Oct 24 17:25:43 2019 +0200

    scsi: isci: Spelling s/configruation/configuration/
    
    Fix misspelling of "configuration".
    
    Link: https://lore.kernel.org/r/20191024152543.30310-1-geert+renesas@glider.be
    Signed-off-by: Geert Uytterhoeven <geert+renesas@glider.be>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/isci/port_config.c b/drivers/scsi/isci/port_config.c
index 9e8de1462593..b1c197505579 100644
--- a/drivers/scsi/isci/port_config.c
+++ b/drivers/scsi/isci/port_config.c
@@ -147,7 +147,7 @@ static struct isci_port *sci_port_configuration_agent_find_port(
 /**
  *
  * @controller: This is the controller object that contains the port agent
- * @port_agent: This is the port configruation agent for the controller.
+ * @port_agent: This is the port configuration agent for the controller.
  *
  * This routine will validate the port configuration is correct for the SCU
  * hardware.  The SCU hardware allows for port configurations as follows. LP0

commit 4bc83b3f272fe8f36450f9c003df49cf07ffe5fd
Author: Colin Ian King <colin.king@canonical.com>
Date:   Fri Apr 20 10:57:16 2018 +0100

    scsi: isci: Fix infinite loop in while loop
    
    In the case when the phy_mask is bitwise anded with the phy_index bit is
    zero the continue statement currently jumps to the next iteration of the
    while loop and phy_index is never actually incremented, potentially
    causing an infinite loop if phy_index is less than SCI_MAX_PHS. Fix this
    by turning the while loop into a for loop.
    
    Signed-off-by: Colin Ian King <colin.king@canonical.com>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/isci/port_config.c b/drivers/scsi/isci/port_config.c
index edb7be786c65..9e8de1462593 100644
--- a/drivers/scsi/isci/port_config.c
+++ b/drivers/scsi/isci/port_config.c
@@ -291,7 +291,7 @@ sci_mpc_agent_validate_phy_configuration(struct isci_host *ihost,
 		 * Note: We have not moved the current phy_index so we will actually
 		 *       compare the startting phy with itself.
 		 *       This is expected and required to add the phy to the port. */
-		while (phy_index < SCI_MAX_PHYS) {
+		for (; phy_index < SCI_MAX_PHYS; phy_index++) {
 			if ((phy_mask & (1 << phy_index)) == 0)
 				continue;
 			sci_phy_get_sas_address(&ihost->phys[phy_index],
@@ -311,7 +311,6 @@ sci_mpc_agent_validate_phy_configuration(struct isci_host *ihost,
 					      &ihost->phys[phy_index]);
 
 			assigned_phy_mask |= (1 << phy_index);
-			phy_index++;
 		}
 
 	}

commit b0a2dc66152aa409860e02804169b0007244ebd7
Author: Kees Cook <keescook@chromium.org>
Date:   Fri Sep 1 23:21:24 2017 -0700

    scsi: isci: Convert timers to use timer_setup()
    
    In preparation for unconditionally passing the struct timer_list pointer to
    all timer callbacks, switch to using the new timer_setup() and from_timer()
    to pass the timer pointer explicitly.
    
    Cc: Intel SCU Linux support <intel-linux-scu@intel.com>
    Cc: Artur Paszkiewicz <artur.paszkiewicz@intel.com>
    Cc: "James E.J. Bottomley" <jejb@linux.vnet.ibm.com>
    Cc: "Martin K. Petersen" <martin.petersen@oracle.com>
    Cc: linux-scsi@vger.kernel.org
    Signed-off-by: Kees Cook <keescook@chromium.org>
    Reviewed-by: Artur Paszkiewicz <artur.paszkiewicz@intel.com>

diff --git a/drivers/scsi/isci/port_config.c b/drivers/scsi/isci/port_config.c
index ac879745ef80..edb7be786c65 100644
--- a/drivers/scsi/isci/port_config.c
+++ b/drivers/scsi/isci/port_config.c
@@ -319,10 +319,10 @@ sci_mpc_agent_validate_phy_configuration(struct isci_host *ihost,
 	return sci_port_configuration_agent_validate_ports(ihost, port_agent);
 }
 
-static void mpc_agent_timeout(unsigned long data)
+static void mpc_agent_timeout(struct timer_list *t)
 {
 	u8 index;
-	struct sci_timer *tmr = (struct sci_timer *)data;
+	struct sci_timer *tmr = from_timer(tmr, t, timer);
 	struct sci_port_configuration_agent *port_agent;
 	struct isci_host *ihost;
 	unsigned long flags;
@@ -654,10 +654,10 @@ static void sci_apc_agent_link_down(
 }
 
 /* configure the phys into ports when the timer fires */
-static void apc_agent_timeout(unsigned long data)
+static void apc_agent_timeout(struct timer_list *t)
 {
 	u32 index;
-	struct sci_timer *tmr = (struct sci_timer *)data;
+	struct sci_timer *tmr = from_timer(tmr, t, timer);
 	struct sci_port_configuration_agent *port_agent;
 	struct isci_host *ihost;
 	unsigned long flags;

commit ddfadd7736b677de2d4ca2cd5b4b655368c85a7a
Author: Dan Williams <dan.j.williams@intel.com>
Date:   Thu Feb 6 12:23:01 2014 -0800

    [SCSI] isci: fix reset timeout handling
    
    Remove an erroneous BUG_ON() in the case of a hard reset timeout.  The
    reset timeout handler puts the port into the "awaiting link-up" state.
    The timeout causes the device to be disconnected and we need to be in
    the awaiting link-up state to re-connect the port.  The BUG_ON() made
    the incorrect assumption that resets never timeout and we always
    complete the reset in the "resetting" state.
    
    Testing this patch also uncovered that libata continues to attempt to
    reset the port long after the driver has torn down the context.  Once
    the driver has committed to abandoning the link it must indicate to
    libata that recovery ends by returning -ENODEV from
    ->lldd_I_T_nexus_reset().
    
    Cc: <stable@vger.kernel.org>
    Acked-by: Lukasz Dorau <lukasz.dorau@intel.com>
    Reported-by: David Milburn <dmilburn@redhat.com>
    Reported-by: Xun Ni <xun.ni@intel.com>
    Tested-by: Xun Ni <xun.ni@intel.com>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>
    Signed-off-by: James Bottomley <JBottomley@Parallels.com>

diff --git a/drivers/scsi/isci/port_config.c b/drivers/scsi/isci/port_config.c
index 85c77f6b802b..ac879745ef80 100644
--- a/drivers/scsi/isci/port_config.c
+++ b/drivers/scsi/isci/port_config.c
@@ -615,13 +615,6 @@ static void sci_apc_agent_link_up(struct isci_host *ihost,
 					  SCIC_SDS_APC_WAIT_LINK_UP_NOTIFICATION);
 	} else {
 		/* the phy is already the part of the port */
-		u32 port_state = iport->sm.current_state_id;
-
-		/* if the PORT'S state is resetting then the link up is from
-		 * port hard reset in this case, we need to tell the port
-		 * that link up is recieved
-		 */
-		BUG_ON(port_state != SCI_PORT_RESETTING);
 		port_agent->phy_ready_mask |= 1 << phy_index;
 		sci_port_link_up(iport, iphy);
 	}

commit 80aebef7c112ca2610ba8aa6cd8cb02f3828e366
Author: Xinghai Yu <yuxinghai@cn.fujitsu.com>
Date:   Wed Jul 17 10:54:01 2013 +0800

    [SCSI] isci: Fix a infinite loop.
    
    It seems the "phy_index++;" have been placed in wrong place, without it
    the while circle up will do a infinite loop.
    
    Signed-off-by: Xinghai Yu <yuxinghai@cn.fujitsu.com>
    Acked-by: Lukasz Dorau <lukasz.dorau@intel.com>
    Signed-off-by: James Bottomley <JBottomley@Parallels.com>

diff --git a/drivers/scsi/isci/port_config.c b/drivers/scsi/isci/port_config.c
index cd962da4a57a..85c77f6b802b 100644
--- a/drivers/scsi/isci/port_config.c
+++ b/drivers/scsi/isci/port_config.c
@@ -311,9 +311,9 @@ sci_mpc_agent_validate_phy_configuration(struct isci_host *ihost,
 					      &ihost->phys[phy_index]);
 
 			assigned_phy_mask |= (1 << phy_index);
+			phy_index++;
 		}
 
-		phy_index++;
 	}
 
 	return sci_port_configuration_agent_validate_ports(ihost, port_agent);

commit 50a92d93148ec073efd2456b007e04ecae452086
Author: Dan Williams <dan.j.williams@intel.com>
Date:   Wed Feb 29 01:07:56 2012 -0800

    isci: fix 'link-up' events occur after 'start-complete'
    
    The call to wait_for_start() is meant to ensure that all links have been
    given a chance to come up before letting the kernel proceed with
    probing.  However, the implementation is not correctly syncing with the
    port configuration agent.  In the MPC case the ports are hard-coded, in
    the APC case we need to wait for the port-configuration to form ports
    from the started phys.
    
    Towards that end increase the timeout for the APC agent to form ports,
    and delay start complete until all phys are out of link-training.
    
    Cc: <stable@vger.kernel.org>
    Cc: Richard Boyd <richard.g.boyd@intel.com>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/drivers/scsi/isci/port_config.c b/drivers/scsi/isci/port_config.c
index 6d1e9544cbe5..cd962da4a57a 100644
--- a/drivers/scsi/isci/port_config.c
+++ b/drivers/scsi/isci/port_config.c
@@ -57,7 +57,7 @@
 
 #define SCIC_SDS_MPC_RECONFIGURATION_TIMEOUT    (10)
 #define SCIC_SDS_APC_RECONFIGURATION_TIMEOUT    (10)
-#define SCIC_SDS_APC_WAIT_LINK_UP_NOTIFICATION  (250)
+#define SCIC_SDS_APC_WAIT_LINK_UP_NOTIFICATION  (1000)
 
 enum SCIC_SDS_APC_ACTIVITY {
 	SCIC_SDS_APC_SKIP_PHY,
@@ -472,13 +472,9 @@ sci_apc_agent_validate_phy_configuration(struct isci_host *ihost,
  * down event or a link up event where we can not yet tell to which a phy
  * belongs.
  */
-static void sci_apc_agent_start_timer(
-	struct sci_port_configuration_agent *port_agent,
-	u32 timeout)
+static void sci_apc_agent_start_timer(struct sci_port_configuration_agent *port_agent,
+				      u32 timeout)
 {
-	if (port_agent->timer_pending)
-		sci_del_timer(&port_agent->timer);
-
 	port_agent->timer_pending = true;
 	sci_mod_timer(&port_agent->timer, timeout);
 }
@@ -697,6 +693,9 @@ static void apc_agent_timeout(unsigned long data)
 						   &ihost->phys[index], false);
 	}
 
+	if (is_controller_start_complete(ihost))
+		sci_controller_transition_to_ready(ihost, SCI_SUCCESS);
+
 done:
 	spin_unlock_irqrestore(&ihost->scic_lock, flags);
 }
@@ -732,6 +731,11 @@ void sci_port_configuration_agent_construct(
 	}
 }
 
+bool is_port_config_apc(struct isci_host *ihost)
+{
+	return ihost->port_agent.link_up_handler == sci_apc_agent_link_up;
+}
+
 enum sci_status sci_port_configuration_agent_initialize(
 	struct isci_host *ihost,
 	struct sci_port_configuration_agent *port_agent)

commit be778341812dc75b1c515fab6ebd39c0daf1e2bc
Author: Marcin Tomczak <marcin.tomczak@intel.com>
Date:   Wed Jan 4 01:33:31 2012 -0800

    [SCSI] isci: fix io failures while wide port links are coming up
    
    When the first phy of a wide port comes up, don't report the port ready
    yet, always wait for 250 miliseconds then config the port with all phys
    added to the port. So that we can avoid reporting wide port device too
    early to kernel, which caused the first IOs (report luns, inquirys)
    failed due to not all the phys are configured into its port. Changes
    also made that the phys in a wide port don't need to go through half
    second wait time for consuming power.
    
    Signed-off-by: Marcin Tomczak <marcin.tomczak@intel.com>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>
    Signed-off-by: James Bottomley <JBottomley@Parallels.com>

diff --git a/drivers/scsi/isci/port_config.c b/drivers/scsi/isci/port_config.c
index 37d15d3165da..6d1e9544cbe5 100644
--- a/drivers/scsi/isci/port_config.c
+++ b/drivers/scsi/isci/port_config.c
@@ -466,6 +466,23 @@ sci_apc_agent_validate_phy_configuration(struct isci_host *ihost,
 	return sci_port_configuration_agent_validate_ports(ihost, port_agent);
 }
 
+/*
+ * This routine will restart the automatic port configuration timeout
+ * timer for the next time period. This could be caused by either a link
+ * down event or a link up event where we can not yet tell to which a phy
+ * belongs.
+ */
+static void sci_apc_agent_start_timer(
+	struct sci_port_configuration_agent *port_agent,
+	u32 timeout)
+{
+	if (port_agent->timer_pending)
+		sci_del_timer(&port_agent->timer);
+
+	port_agent->timer_pending = true;
+	sci_mod_timer(&port_agent->timer, timeout);
+}
+
 static void sci_apc_agent_configure_ports(struct isci_host *ihost,
 					       struct sci_port_configuration_agent *port_agent,
 					       struct isci_phy *iphy,
@@ -565,17 +582,8 @@ static void sci_apc_agent_configure_ports(struct isci_host *ihost,
 		break;
 
 	case SCIC_SDS_APC_START_TIMER:
-		/*
-		 * This can occur for either a link down event, or a link
-		 * up event where we cannot yet tell the port to which a
-		 * phy belongs.
-		 */
-		if (port_agent->timer_pending)
-			sci_del_timer(&port_agent->timer);
-
-		port_agent->timer_pending = true;
-		sci_mod_timer(&port_agent->timer,
-			      SCIC_SDS_APC_WAIT_LINK_UP_NOTIFICATION);
+		sci_apc_agent_start_timer(port_agent,
+					  SCIC_SDS_APC_WAIT_LINK_UP_NOTIFICATION);
 		break;
 
 	case SCIC_SDS_APC_SKIP_PHY:
@@ -607,7 +615,8 @@ static void sci_apc_agent_link_up(struct isci_host *ihost,
 	if (!iport) {
 		/* the phy is not the part of this port */
 		port_agent->phy_ready_mask |= 1 << phy_index;
-		sci_apc_agent_configure_ports(ihost, port_agent, iphy, true);
+		sci_apc_agent_start_timer(port_agent,
+					  SCIC_SDS_APC_WAIT_LINK_UP_NOTIFICATION);
 	} else {
 		/* the phy is already the part of the port */
 		u32 port_state = iport->sm.current_state_id;

commit 472d4d2cfbc169f3868a5f63ce727a482a2fd487
Author: Marcin Tomczak <marcin.tomczak@intel.com>
Date:   Wed Jan 4 01:33:26 2012 -0800

    [SCSI] isci: allow more time for wide port targets
    
    When hot insert the wide port device through the mini-sas port,
    the first IOs (Report Luns or Inquiry) may fail due to the device
    trying to open to a SCU phy that is still in suspended state. This
    IO failure causes the wide port device stuck in UPDATING_PORT_WIDTH
    state.
    
    Signed-off-by: Marcin Tomczak <marcin.tomczak@intel.com>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>
    Signed-off-by: James Bottomley <JBottomley@Parallels.com>

diff --git a/drivers/scsi/isci/port_config.c b/drivers/scsi/isci/port_config.c
index 38a99d281141..37d15d3165da 100644
--- a/drivers/scsi/isci/port_config.c
+++ b/drivers/scsi/isci/port_config.c
@@ -57,7 +57,7 @@
 
 #define SCIC_SDS_MPC_RECONFIGURATION_TIMEOUT    (10)
 #define SCIC_SDS_APC_RECONFIGURATION_TIMEOUT    (10)
-#define SCIC_SDS_APC_WAIT_LINK_UP_NOTIFICATION  (100)
+#define SCIC_SDS_APC_WAIT_LINK_UP_NOTIFICATION  (250)
 
 enum SCIC_SDS_APC_ACTIVITY {
 	SCIC_SDS_APC_SKIP_PHY,

commit 983d3fdd332742167d0482c06fd29cf4b8a687c0
Author: Jeff Skirvin <jeffrey.d.skirvin@intel.com>
Date:   Wed Sep 28 18:35:32 2011 -0700

    [SCSI] isci: fix missed unlock in apc_agent_timeout()
    
    Needed to jump to scic_lock unlock.
    
    Also spotted by coccicheck.
    
    Signed-off-by: Jeff Skirvin <jeffrey.d.skirvin@intel.com>
    Cc: <stable@kernel.org>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>
    Signed-off-by: James Bottomley <JBottomley@Parallels.com>

diff --git a/drivers/scsi/isci/port_config.c b/drivers/scsi/isci/port_config.c
index 486b113c634a..38a99d281141 100644
--- a/drivers/scsi/isci/port_config.c
+++ b/drivers/scsi/isci/port_config.c
@@ -678,7 +678,7 @@ static void apc_agent_timeout(unsigned long data)
 	configure_phy_mask = ~port_agent->phy_configured_mask & port_agent->phy_ready_mask;
 
 	if (!configure_phy_mask)
-		return;
+		goto done;
 
 	for (index = 0; index < SCI_MAX_PHYS; index++) {
 		if ((configure_phy_mask & (1 << index)) == 0)

commit 34a991587a5cc9f78960c2c9beea217866458c41
Author: Dan Williams <dan.j.williams@intel.com>
Date:   Fri Jul 1 02:25:15 2011 -0700

    isci: kill 'get/set' macros
    
    Most of these simple dereference macros are longer than their open coded
    equivalent.  Deleting enum sci_controller_mode is thrown in for good
    measure.
    
    Reported-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/drivers/scsi/isci/port_config.c b/drivers/scsi/isci/port_config.c
index c8b16db6bbde..486b113c634a 100644
--- a/drivers/scsi/isci/port_config.c
+++ b/drivers/scsi/isci/port_config.c
@@ -367,10 +367,10 @@ static void sci_mpc_agent_link_up(struct isci_host *ihost,
 	if (!iport)
 		return;
 
-	port_agent->phy_ready_mask |= (1 << sci_phy_get_index(iphy));
+	port_agent->phy_ready_mask |= (1 << iphy->phy_index);
 	sci_port_link_up(iport, iphy);
-	if ((iport->active_phy_mask & (1 << sci_phy_get_index(iphy))))
-		port_agent->phy_configured_mask |= (1 << sci_phy_get_index(iphy));
+	if ((iport->active_phy_mask & (1 << iphy->phy_index)))
+		port_agent->phy_configured_mask |= (1 << iphy->phy_index);
 }
 
 /**
@@ -404,10 +404,8 @@ static void sci_mpc_agent_link_down(
 		 * rebuilding the port with the phys that remain in the ready
 		 * state.
 		 */
-		port_agent->phy_ready_mask &=
-			~(1 << sci_phy_get_index(iphy));
-		port_agent->phy_configured_mask &=
-			~(1 << sci_phy_get_index(iphy));
+		port_agent->phy_ready_mask &= ~(1 << iphy->phy_index);
+		port_agent->phy_configured_mask &= ~(1 << iphy->phy_index);
 
 		/*
 		 * Check to see if there are more phys waiting to be
@@ -643,7 +641,7 @@ static void sci_apc_agent_link_down(
 	struct isci_port *iport,
 	struct isci_phy *iphy)
 {
-	port_agent->phy_ready_mask &= ~(1 << sci_phy_get_index(iphy));
+	port_agent->phy_ready_mask &= ~(1 << iphy->phy_index);
 
 	if (!iport)
 		return;

commit 89a7301f21fb00e753089671eb9e4132aab8ea08
Author: Dan Williams <dan.j.williams@intel.com>
Date:   Thu Jun 30 19:14:33 2011 -0700

    isci: retire scic_sds_ and scic_ prefixes
    
    The distinction between scic_sds_ scic_ and sci_ are no longer relevant
    so just unify the prefixes on sci_.  The distinction between isci_ and
    sci_ is historically significant, and useful for comparing the old
    'core' to the current Linux driver. 'sci_' represents the former core as
    well as the routines that are closer to the hardware and protocol than
    their 'isci_' brethren. sci == sas controller interface.
    
    Also unwind the 'sds1' out of the parameter structs.
    
    Reported-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/drivers/scsi/isci/port_config.c b/drivers/scsi/isci/port_config.c
index a0a135d54e95..c8b16db6bbde 100644
--- a/drivers/scsi/isci/port_config.c
+++ b/drivers/scsi/isci/port_config.c
@@ -112,7 +112,7 @@ static s32 sci_sas_address_compare(
  * port. port address if the port can be found to match the phy.
  * NULL if there is no matching port for the phy.
  */
-static struct isci_port *scic_sds_port_configuration_agent_find_port(
+static struct isci_port *sci_port_configuration_agent_find_port(
 	struct isci_host *ihost,
 	struct isci_phy *iphy)
 {
@@ -127,14 +127,14 @@ static struct isci_port *scic_sds_port_configuration_agent_find_port(
 	 * more phys match the sent and received SAS address as this phy in which
 	 * case it should participate in the same port.
 	 */
-	scic_sds_phy_get_sas_address(iphy, &phy_sas_address);
-	scic_sds_phy_get_attached_sas_address(iphy, &phy_attached_device_address);
+	sci_phy_get_sas_address(iphy, &phy_sas_address);
+	sci_phy_get_attached_sas_address(iphy, &phy_attached_device_address);
 
 	for (i = 0; i < ihost->logical_port_entries; i++) {
 		struct isci_port *iport = &ihost->ports[i];
 
-		scic_sds_port_get_sas_address(iport, &port_sas_address);
-		scic_sds_port_get_attached_sas_address(iport, &port_attached_device_address);
+		sci_port_get_sas_address(iport, &port_sas_address);
+		sci_port_get_attached_sas_address(iport, &port_attached_device_address);
 
 		if (sci_sas_address_compare(port_sas_address, phy_sas_address) == 0 &&
 		    sci_sas_address_compare(port_attached_device_address, phy_attached_device_address) == 0)
@@ -156,9 +156,9 @@ static struct isci_port *scic_sds_port_configuration_agent_find_port(
  * this port configuration agent. SCI_FAILURE_UNSUPPORTED_PORT_CONFIGURATION
  * the port configuration is not valid for this port configuration agent.
  */
-static enum sci_status scic_sds_port_configuration_agent_validate_ports(
+static enum sci_status sci_port_configuration_agent_validate_ports(
 	struct isci_host *ihost,
-	struct scic_sds_port_configuration_agent *port_agent)
+	struct sci_port_configuration_agent *port_agent)
 {
 	struct sci_sas_address first_address;
 	struct sci_sas_address second_address;
@@ -194,8 +194,8 @@ static enum sci_status scic_sds_port_configuration_agent_validate_ports(
 	 * PE0 and PE3 can never have the same SAS Address unless they
 	 * are part of the same x4 wide port and we have already checked
 	 * for this condition. */
-	scic_sds_phy_get_sas_address(&ihost->phys[0], &first_address);
-	scic_sds_phy_get_sas_address(&ihost->phys[3], &second_address);
+	sci_phy_get_sas_address(&ihost->phys[0], &first_address);
+	sci_phy_get_sas_address(&ihost->phys[3], &second_address);
 
 	if (sci_sas_address_compare(first_address, second_address) == 0) {
 		return SCI_FAILURE_UNSUPPORTED_PORT_CONFIGURATION;
@@ -207,8 +207,8 @@ static enum sci_status scic_sds_port_configuration_agent_validate_ports(
 	 * part of the same port. */
 	if (port_agent->phy_valid_port_range[0].min_index == 0 &&
 	    port_agent->phy_valid_port_range[1].min_index == 1) {
-		scic_sds_phy_get_sas_address(&ihost->phys[0], &first_address);
-		scic_sds_phy_get_sas_address(&ihost->phys[2], &second_address);
+		sci_phy_get_sas_address(&ihost->phys[0], &first_address);
+		sci_phy_get_sas_address(&ihost->phys[2], &second_address);
 
 		if (sci_sas_address_compare(first_address, second_address) == 0) {
 			return SCI_FAILURE_UNSUPPORTED_PORT_CONFIGURATION;
@@ -221,8 +221,8 @@ static enum sci_status scic_sds_port_configuration_agent_validate_ports(
 	 * part of the same port. */
 	if (port_agent->phy_valid_port_range[2].min_index == 2 &&
 	    port_agent->phy_valid_port_range[3].min_index == 3) {
-		scic_sds_phy_get_sas_address(&ihost->phys[1], &first_address);
-		scic_sds_phy_get_sas_address(&ihost->phys[3], &second_address);
+		sci_phy_get_sas_address(&ihost->phys[1], &first_address);
+		sci_phy_get_sas_address(&ihost->phys[3], &second_address);
 
 		if (sci_sas_address_compare(first_address, second_address) == 0) {
 			return SCI_FAILURE_UNSUPPORTED_PORT_CONFIGURATION;
@@ -239,8 +239,8 @@ static enum sci_status scic_sds_port_configuration_agent_validate_ports(
 
 /* verify all of the phys in the same port are using the same SAS address */
 static enum sci_status
-scic_sds_mpc_agent_validate_phy_configuration(struct isci_host *ihost,
-					      struct scic_sds_port_configuration_agent *port_agent)
+sci_mpc_agent_validate_phy_configuration(struct isci_host *ihost,
+					      struct sci_port_configuration_agent *port_agent)
 {
 	u32 phy_mask;
 	u32 assigned_phy_mask;
@@ -254,7 +254,7 @@ scic_sds_mpc_agent_validate_phy_configuration(struct isci_host *ihost,
 	sas_address.low = 0;
 
 	for (port_index = 0; port_index < SCI_MAX_PORTS; port_index++) {
-		phy_mask = ihost->oem_parameters.sds1.ports[port_index].phy_mask;
+		phy_mask = ihost->oem_parameters.ports[port_index].phy_mask;
 
 		if (!phy_mask)
 			continue;
@@ -269,7 +269,7 @@ scic_sds_mpc_agent_validate_phy_configuration(struct isci_host *ihost,
 		for (phy_index = 0; phy_index < SCI_MAX_PHYS; phy_index++) {
 			if ((phy_mask & (1 << phy_index)) == 0)
 				continue;
-			scic_sds_phy_get_sas_address(&ihost->phys[phy_index],
+			sci_phy_get_sas_address(&ihost->phys[phy_index],
 						     &sas_address);
 
 			/*
@@ -294,7 +294,7 @@ scic_sds_mpc_agent_validate_phy_configuration(struct isci_host *ihost,
 		while (phy_index < SCI_MAX_PHYS) {
 			if ((phy_mask & (1 << phy_index)) == 0)
 				continue;
-			scic_sds_phy_get_sas_address(&ihost->phys[phy_index],
+			sci_phy_get_sas_address(&ihost->phys[phy_index],
 						     &phy_assigned_address);
 
 			if (sci_sas_address_compare(sas_address, phy_assigned_address) != 0) {
@@ -307,7 +307,7 @@ scic_sds_mpc_agent_validate_phy_configuration(struct isci_host *ihost,
 			port_agent->phy_valid_port_range[phy_index].min_index = port_index;
 			port_agent->phy_valid_port_range[phy_index].max_index = phy_index;
 
-			scic_sds_port_add_phy(&ihost->ports[port_index],
+			sci_port_add_phy(&ihost->ports[port_index],
 					      &ihost->phys[phy_index]);
 
 			assigned_phy_mask |= (1 << phy_index);
@@ -316,14 +316,14 @@ scic_sds_mpc_agent_validate_phy_configuration(struct isci_host *ihost,
 		phy_index++;
 	}
 
-	return scic_sds_port_configuration_agent_validate_ports(ihost, port_agent);
+	return sci_port_configuration_agent_validate_ports(ihost, port_agent);
 }
 
 static void mpc_agent_timeout(unsigned long data)
 {
 	u8 index;
 	struct sci_timer *tmr = (struct sci_timer *)data;
-	struct scic_sds_port_configuration_agent *port_agent;
+	struct sci_port_configuration_agent *port_agent;
 	struct isci_host *ihost;
 	unsigned long flags;
 	u16 configure_phy_mask;
@@ -355,8 +355,8 @@ static void mpc_agent_timeout(unsigned long data)
 	spin_unlock_irqrestore(&ihost->scic_lock, flags);
 }
 
-static void scic_sds_mpc_agent_link_up(struct isci_host *ihost,
-				       struct scic_sds_port_configuration_agent *port_agent,
+static void sci_mpc_agent_link_up(struct isci_host *ihost,
+				       struct sci_port_configuration_agent *port_agent,
 				       struct isci_port *iport,
 				       struct isci_phy *iphy)
 {
@@ -367,10 +367,10 @@ static void scic_sds_mpc_agent_link_up(struct isci_host *ihost,
 	if (!iport)
 		return;
 
-	port_agent->phy_ready_mask |= (1 << scic_sds_phy_get_index(iphy));
-	scic_sds_port_link_up(iport, iphy);
-	if ((iport->active_phy_mask & (1 << scic_sds_phy_get_index(iphy))))
-		port_agent->phy_configured_mask |= (1 << scic_sds_phy_get_index(iphy));
+	port_agent->phy_ready_mask |= (1 << sci_phy_get_index(iphy));
+	sci_port_link_up(iport, iphy);
+	if ((iport->active_phy_mask & (1 << sci_phy_get_index(iphy))))
+		port_agent->phy_configured_mask |= (1 << sci_phy_get_index(iphy));
 }
 
 /**
@@ -390,9 +390,9 @@ static void scic_sds_mpc_agent_link_up(struct isci_host *ihost,
  * not associated with a port there is no action taken. Is it possible to get a
  * link down notification from a phy that has no assocoated port?
  */
-static void scic_sds_mpc_agent_link_down(
+static void sci_mpc_agent_link_down(
 	struct isci_host *ihost,
-	struct scic_sds_port_configuration_agent *port_agent,
+	struct sci_port_configuration_agent *port_agent,
 	struct isci_port *iport,
 	struct isci_phy *iphy)
 {
@@ -405,9 +405,9 @@ static void scic_sds_mpc_agent_link_down(
 		 * state.
 		 */
 		port_agent->phy_ready_mask &=
-			~(1 << scic_sds_phy_get_index(iphy));
+			~(1 << sci_phy_get_index(iphy));
 		port_agent->phy_configured_mask &=
-			~(1 << scic_sds_phy_get_index(iphy));
+			~(1 << sci_phy_get_index(iphy));
 
 		/*
 		 * Check to see if there are more phys waiting to be
@@ -424,7 +424,7 @@ static void scic_sds_mpc_agent_link_down(
 				      SCIC_SDS_MPC_RECONFIGURATION_TIMEOUT);
 		}
 
-		scic_sds_port_link_down(iport, iphy);
+		sci_port_link_down(iport, iphy);
 	}
 }
 
@@ -432,8 +432,8 @@ static void scic_sds_mpc_agent_link_down(
  * configuration mode.
  */
 static enum sci_status
-scic_sds_apc_agent_validate_phy_configuration(struct isci_host *ihost,
-					      struct scic_sds_port_configuration_agent *port_agent)
+sci_apc_agent_validate_phy_configuration(struct isci_host *ihost,
+					      struct sci_port_configuration_agent *port_agent)
 {
 	u8 phy_index;
 	u8 port_index;
@@ -446,11 +446,11 @@ scic_sds_apc_agent_validate_phy_configuration(struct isci_host *ihost,
 		port_index = phy_index;
 
 		/* Get the assigned SAS Address for the first PHY on the controller. */
-		scic_sds_phy_get_sas_address(&ihost->phys[phy_index],
+		sci_phy_get_sas_address(&ihost->phys[phy_index],
 					    &sas_address);
 
 		while (++phy_index < SCI_MAX_PHYS) {
-			scic_sds_phy_get_sas_address(&ihost->phys[phy_index],
+			sci_phy_get_sas_address(&ihost->phys[phy_index],
 						     &phy_assigned_address);
 
 			/* Verify each of the SAS address are all the same for every PHY */
@@ -465,11 +465,11 @@ scic_sds_apc_agent_validate_phy_configuration(struct isci_host *ihost,
 		}
 	}
 
-	return scic_sds_port_configuration_agent_validate_ports(ihost, port_agent);
+	return sci_port_configuration_agent_validate_ports(ihost, port_agent);
 }
 
-static void scic_sds_apc_agent_configure_ports(struct isci_host *ihost,
-					       struct scic_sds_port_configuration_agent *port_agent,
+static void sci_apc_agent_configure_ports(struct isci_host *ihost,
+					       struct sci_port_configuration_agent *port_agent,
 					       struct isci_phy *iphy,
 					       bool start_timer)
 {
@@ -478,10 +478,10 @@ static void scic_sds_apc_agent_configure_ports(struct isci_host *ihost,
 	struct isci_port *iport;
 	enum SCIC_SDS_APC_ACTIVITY apc_activity = SCIC_SDS_APC_SKIP_PHY;
 
-	iport = scic_sds_port_configuration_agent_find_port(ihost, iphy);
+	iport = sci_port_configuration_agent_find_port(ihost, iphy);
 
 	if (iport) {
-		if (scic_sds_port_is_valid_phy_assignment(iport, iphy->phy_index))
+		if (sci_port_is_valid_phy_assignment(iport, iphy->phy_index))
 			apc_activity = SCIC_SDS_APC_ADD_PHY;
 		else
 			apc_activity = SCIC_SDS_APC_SKIP_PHY;
@@ -499,7 +499,7 @@ static void scic_sds_apc_agent_configure_ports(struct isci_host *ihost,
 			iport = &ihost->ports[port_index];
 
 			/* First we must make sure that this PHY can be added to this Port. */
-			if (scic_sds_port_is_valid_phy_assignment(iport, iphy->phy_index)) {
+			if (sci_port_is_valid_phy_assignment(iport, iphy->phy_index)) {
 				/*
 				 * Port contains a PHY with a greater PHY ID than the current
 				 * PHY that has gone link up.  This phy can not be part of any
@@ -559,7 +559,7 @@ static void scic_sds_apc_agent_configure_ports(struct isci_host *ihost,
 
 	switch (apc_activity) {
 	case SCIC_SDS_APC_ADD_PHY:
-		status = scic_sds_port_add_phy(iport, iphy);
+		status = sci_port_add_phy(iport, iphy);
 
 		if (status == SCI_SUCCESS) {
 			port_agent->phy_configured_mask |= (1 << iphy->phy_index);
@@ -588,7 +588,7 @@ static void scic_sds_apc_agent_configure_ports(struct isci_host *ihost,
 }
 
 /**
- * scic_sds_apc_agent_link_up - handle apc link up events
+ * sci_apc_agent_link_up - handle apc link up events
  * @scic: This is the controller object that receives the link up
  *    notification.
  * @sci_port: This is the port object associated with the phy.  If the is no
@@ -599,8 +599,8 @@ static void scic_sds_apc_agent_configure_ports(struct isci_host *ihost,
  * notifications. Is it possible to get a link down notification from a phy
  * that has no assocoated port?
  */
-static void scic_sds_apc_agent_link_up(struct isci_host *ihost,
-				       struct scic_sds_port_configuration_agent *port_agent,
+static void sci_apc_agent_link_up(struct isci_host *ihost,
+				       struct sci_port_configuration_agent *port_agent,
 				       struct isci_port *iport,
 				       struct isci_phy *iphy)
 {
@@ -609,7 +609,7 @@ static void scic_sds_apc_agent_link_up(struct isci_host *ihost,
 	if (!iport) {
 		/* the phy is not the part of this port */
 		port_agent->phy_ready_mask |= 1 << phy_index;
-		scic_sds_apc_agent_configure_ports(ihost, port_agent, iphy, true);
+		sci_apc_agent_configure_ports(ihost, port_agent, iphy, true);
 	} else {
 		/* the phy is already the part of the port */
 		u32 port_state = iport->sm.current_state_id;
@@ -620,7 +620,7 @@ static void scic_sds_apc_agent_link_up(struct isci_host *ihost,
 		 */
 		BUG_ON(port_state != SCI_PORT_RESETTING);
 		port_agent->phy_ready_mask |= 1 << phy_index;
-		scic_sds_port_link_up(iport, iphy);
+		sci_port_link_up(iport, iphy);
 	}
 }
 
@@ -637,20 +637,20 @@ static void scic_sds_apc_agent_link_up(struct isci_host *ihost,
  * possible to get a link down notification from a phy that has no assocoated
  * port?
  */
-static void scic_sds_apc_agent_link_down(
+static void sci_apc_agent_link_down(
 	struct isci_host *ihost,
-	struct scic_sds_port_configuration_agent *port_agent,
+	struct sci_port_configuration_agent *port_agent,
 	struct isci_port *iport,
 	struct isci_phy *iphy)
 {
-	port_agent->phy_ready_mask &= ~(1 << scic_sds_phy_get_index(iphy));
+	port_agent->phy_ready_mask &= ~(1 << sci_phy_get_index(iphy));
 
 	if (!iport)
 		return;
 	if (port_agent->phy_configured_mask & (1 << iphy->phy_index)) {
 		enum sci_status status;
 
-		status = scic_sds_port_remove_phy(iport, iphy);
+		status = sci_port_remove_phy(iport, iphy);
 
 		if (status == SCI_SUCCESS)
 			port_agent->phy_configured_mask &= ~(1 << iphy->phy_index);
@@ -662,7 +662,7 @@ static void apc_agent_timeout(unsigned long data)
 {
 	u32 index;
 	struct sci_timer *tmr = (struct sci_timer *)data;
-	struct scic_sds_port_configuration_agent *port_agent;
+	struct sci_port_configuration_agent *port_agent;
 	struct isci_host *ihost;
 	unsigned long flags;
 	u16 configure_phy_mask;
@@ -686,7 +686,7 @@ static void apc_agent_timeout(unsigned long data)
 		if ((configure_phy_mask & (1 << index)) == 0)
 			continue;
 
-		scic_sds_apc_agent_configure_ports(ihost, port_agent,
+		sci_apc_agent_configure_ports(ihost, port_agent,
 						   &ihost->phys[index], false);
 	}
 
@@ -706,8 +706,8 @@ static void apc_agent_timeout(unsigned long data)
  * call is universal for both manual port configuration and automatic port
  * configuration modes.
  */
-void scic_sds_port_configuration_agent_construct(
-	struct scic_sds_port_configuration_agent *port_agent)
+void sci_port_configuration_agent_construct(
+	struct sci_port_configuration_agent *port_agent)
 {
 	u32 index;
 
@@ -725,29 +725,29 @@ void scic_sds_port_configuration_agent_construct(
 	}
 }
 
-enum sci_status scic_sds_port_configuration_agent_initialize(
+enum sci_status sci_port_configuration_agent_initialize(
 	struct isci_host *ihost,
-	struct scic_sds_port_configuration_agent *port_agent)
+	struct sci_port_configuration_agent *port_agent)
 {
 	enum sci_status status;
-	enum scic_port_configuration_mode mode;
+	enum sci_port_configuration_mode mode;
 
-	mode = ihost->oem_parameters.sds1.controller.mode_type;
+	mode = ihost->oem_parameters.controller.mode_type;
 
 	if (mode == SCIC_PORT_MANUAL_CONFIGURATION_MODE) {
-		status = scic_sds_mpc_agent_validate_phy_configuration(
+		status = sci_mpc_agent_validate_phy_configuration(
 				ihost, port_agent);
 
-		port_agent->link_up_handler = scic_sds_mpc_agent_link_up;
-		port_agent->link_down_handler = scic_sds_mpc_agent_link_down;
+		port_agent->link_up_handler = sci_mpc_agent_link_up;
+		port_agent->link_down_handler = sci_mpc_agent_link_down;
 
 		sci_init_timer(&port_agent->timer, mpc_agent_timeout);
 	} else {
-		status = scic_sds_apc_agent_validate_phy_configuration(
+		status = sci_apc_agent_validate_phy_configuration(
 				ihost, port_agent);
 
-		port_agent->link_up_handler = scic_sds_apc_agent_link_up;
-		port_agent->link_down_handler = scic_sds_apc_agent_link_down;
+		port_agent->link_up_handler = sci_apc_agent_link_up;
+		port_agent->link_down_handler = sci_apc_agent_link_down;
 
 		sci_init_timer(&port_agent->timer, apc_agent_timeout);
 	}

commit d9dcb4ba791de2a06b19ac47cd61601cf3d4e208
Author: Dan Williams <dan.j.williams@intel.com>
Date:   Thu Jun 30 17:38:32 2011 -0700

    isci: unify isci_host and scic_sds_controller
    
    Remove the distinction between these two implementations and unify on
    isci_host (local instances named ihost).  Hmmm, we had two
    'oem_parameters' instances, one was unused... nice.
    
    Reported-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/drivers/scsi/isci/port_config.c b/drivers/scsi/isci/port_config.c
index bb62d2a25217..a0a135d54e95 100644
--- a/drivers/scsi/isci/port_config.c
+++ b/drivers/scsi/isci/port_config.c
@@ -113,7 +113,7 @@ static s32 sci_sas_address_compare(
  * NULL if there is no matching port for the phy.
  */
 static struct isci_port *scic_sds_port_configuration_agent_find_port(
-	struct scic_sds_controller *scic,
+	struct isci_host *ihost,
 	struct isci_phy *iphy)
 {
 	u8 i;
@@ -130,8 +130,7 @@ static struct isci_port *scic_sds_port_configuration_agent_find_port(
 	scic_sds_phy_get_sas_address(iphy, &phy_sas_address);
 	scic_sds_phy_get_attached_sas_address(iphy, &phy_attached_device_address);
 
-	for (i = 0; i < scic->logical_port_entries; i++) {
-		struct isci_host *ihost = scic_to_ihost(scic);
+	for (i = 0; i < ihost->logical_port_entries; i++) {
 		struct isci_port *iport = &ihost->ports[i];
 
 		scic_sds_port_get_sas_address(iport, &port_sas_address);
@@ -158,10 +157,9 @@ static struct isci_port *scic_sds_port_configuration_agent_find_port(
  * the port configuration is not valid for this port configuration agent.
  */
 static enum sci_status scic_sds_port_configuration_agent_validate_ports(
-	struct scic_sds_controller *controller,
+	struct isci_host *ihost,
 	struct scic_sds_port_configuration_agent *port_agent)
 {
-	struct isci_host *ihost = scic_to_ihost(controller);
 	struct sci_sas_address first_address;
 	struct sci_sas_address second_address;
 
@@ -239,17 +237,11 @@ static enum sci_status scic_sds_port_configuration_agent_validate_ports(
  * Manual port configuration agent routines
  * ****************************************************************************** */
 
-/**
- *
- *
- * This routine will verify that all of the phys in the same port are using the
- * same SAS address.
- */
-static enum sci_status scic_sds_mpc_agent_validate_phy_configuration(
-	struct scic_sds_controller *controller,
-	struct scic_sds_port_configuration_agent *port_agent)
+/* verify all of the phys in the same port are using the same SAS address */
+static enum sci_status
+scic_sds_mpc_agent_validate_phy_configuration(struct isci_host *ihost,
+					      struct scic_sds_port_configuration_agent *port_agent)
 {
-	struct isci_host *ihost = scic_to_ihost(controller);
 	u32 phy_mask;
 	u32 assigned_phy_mask;
 	struct sci_sas_address sas_address;
@@ -262,7 +254,7 @@ static enum sci_status scic_sds_mpc_agent_validate_phy_configuration(
 	sas_address.low = 0;
 
 	for (port_index = 0; port_index < SCI_MAX_PORTS; port_index++) {
-		phy_mask = controller->oem_parameters.sds1.ports[port_index].phy_mask;
+		phy_mask = ihost->oem_parameters.sds1.ports[port_index].phy_mask;
 
 		if (!phy_mask)
 			continue;
@@ -324,7 +316,7 @@ static enum sci_status scic_sds_mpc_agent_validate_phy_configuration(
 		phy_index++;
 	}
 
-	return scic_sds_port_configuration_agent_validate_ports(controller, port_agent);
+	return scic_sds_port_configuration_agent_validate_ports(ihost, port_agent);
 }
 
 static void mpc_agent_timeout(unsigned long data)
@@ -332,14 +324,12 @@ static void mpc_agent_timeout(unsigned long data)
 	u8 index;
 	struct sci_timer *tmr = (struct sci_timer *)data;
 	struct scic_sds_port_configuration_agent *port_agent;
-	struct scic_sds_controller *scic;
 	struct isci_host *ihost;
 	unsigned long flags;
 	u16 configure_phy_mask;
 
 	port_agent = container_of(tmr, typeof(*port_agent), timer);
-	scic = container_of(port_agent, typeof(*scic), port_agent);
-	ihost = scic_to_ihost(scic);
+	ihost = container_of(port_agent, typeof(*ihost), port_agent);
 
 	spin_lock_irqsave(&ihost->scic_lock, flags);
 
@@ -355,7 +345,7 @@ static void mpc_agent_timeout(unsigned long data)
 		struct isci_phy *iphy = &ihost->phys[index];
 
 		if (configure_phy_mask & (1 << index)) {
-			port_agent->link_up_handler(scic, port_agent,
+			port_agent->link_up_handler(ihost, port_agent,
 						    phy_get_non_dummy_port(iphy),
 						    iphy);
 		}
@@ -365,7 +355,7 @@ static void mpc_agent_timeout(unsigned long data)
 	spin_unlock_irqrestore(&ihost->scic_lock, flags);
 }
 
-static void scic_sds_mpc_agent_link_up(struct scic_sds_controller *controller,
+static void scic_sds_mpc_agent_link_up(struct isci_host *ihost,
 				       struct scic_sds_port_configuration_agent *port_agent,
 				       struct isci_port *iport,
 				       struct isci_phy *iphy)
@@ -401,7 +391,7 @@ static void scic_sds_mpc_agent_link_up(struct scic_sds_controller *controller,
  * link down notification from a phy that has no assocoated port?
  */
 static void scic_sds_mpc_agent_link_down(
-	struct scic_sds_controller *scic,
+	struct isci_host *ihost,
 	struct scic_sds_port_configuration_agent *port_agent,
 	struct isci_port *iport,
 	struct isci_phy *iphy)
@@ -438,26 +428,17 @@ static void scic_sds_mpc_agent_link_down(
 	}
 }
 
-/*
- * ******************************************************************************
- * Automatic port configuration agent routines
- * ****************************************************************************** */
-
-/**
- *
- *
- * This routine will verify that the phys are assigned a valid SAS address for
- * automatic port configuration mode.
+/* verify phys are assigned a valid SAS address for automatic port
+ * configuration mode.
  */
-static enum sci_status scic_sds_apc_agent_validate_phy_configuration(
-	struct scic_sds_controller *controller,
-	struct scic_sds_port_configuration_agent *port_agent)
+static enum sci_status
+scic_sds_apc_agent_validate_phy_configuration(struct isci_host *ihost,
+					      struct scic_sds_port_configuration_agent *port_agent)
 {
 	u8 phy_index;
 	u8 port_index;
 	struct sci_sas_address sas_address;
 	struct sci_sas_address phy_assigned_address;
-	struct isci_host *ihost = scic_to_ihost(controller);
 
 	phy_index = 0;
 
@@ -484,10 +465,10 @@ static enum sci_status scic_sds_apc_agent_validate_phy_configuration(
 		}
 	}
 
-	return scic_sds_port_configuration_agent_validate_ports(controller, port_agent);
+	return scic_sds_port_configuration_agent_validate_ports(ihost, port_agent);
 }
 
-static void scic_sds_apc_agent_configure_ports(struct scic_sds_controller *controller,
+static void scic_sds_apc_agent_configure_ports(struct isci_host *ihost,
 					       struct scic_sds_port_configuration_agent *port_agent,
 					       struct isci_phy *iphy,
 					       bool start_timer)
@@ -496,9 +477,8 @@ static void scic_sds_apc_agent_configure_ports(struct scic_sds_controller *contr
 	enum sci_status status;
 	struct isci_port *iport;
 	enum SCIC_SDS_APC_ACTIVITY apc_activity = SCIC_SDS_APC_SKIP_PHY;
-	struct isci_host *ihost = scic_to_ihost(controller);
 
-	iport = scic_sds_port_configuration_agent_find_port(controller, iphy);
+	iport = scic_sds_port_configuration_agent_find_port(ihost, iphy);
 
 	if (iport) {
 		if (scic_sds_port_is_valid_phy_assignment(iport, iphy->phy_index))
@@ -619,7 +599,7 @@ static void scic_sds_apc_agent_configure_ports(struct scic_sds_controller *contr
  * notifications. Is it possible to get a link down notification from a phy
  * that has no assocoated port?
  */
-static void scic_sds_apc_agent_link_up(struct scic_sds_controller *scic,
+static void scic_sds_apc_agent_link_up(struct isci_host *ihost,
 				       struct scic_sds_port_configuration_agent *port_agent,
 				       struct isci_port *iport,
 				       struct isci_phy *iphy)
@@ -629,7 +609,7 @@ static void scic_sds_apc_agent_link_up(struct scic_sds_controller *scic,
 	if (!iport) {
 		/* the phy is not the part of this port */
 		port_agent->phy_ready_mask |= 1 << phy_index;
-		scic_sds_apc_agent_configure_ports(scic, port_agent, iphy, true);
+		scic_sds_apc_agent_configure_ports(ihost, port_agent, iphy, true);
 	} else {
 		/* the phy is already the part of the port */
 		u32 port_state = iport->sm.current_state_id;
@@ -658,7 +638,7 @@ static void scic_sds_apc_agent_link_up(struct scic_sds_controller *scic,
  * port?
  */
 static void scic_sds_apc_agent_link_down(
-	struct scic_sds_controller *controller,
+	struct isci_host *ihost,
 	struct scic_sds_port_configuration_agent *port_agent,
 	struct isci_port *iport,
 	struct isci_phy *iphy)
@@ -683,14 +663,12 @@ static void apc_agent_timeout(unsigned long data)
 	u32 index;
 	struct sci_timer *tmr = (struct sci_timer *)data;
 	struct scic_sds_port_configuration_agent *port_agent;
-	struct scic_sds_controller *scic;
 	struct isci_host *ihost;
 	unsigned long flags;
 	u16 configure_phy_mask;
 
 	port_agent = container_of(tmr, typeof(*port_agent), timer);
-	scic = container_of(port_agent, typeof(*scic), port_agent);
-	ihost = scic_to_ihost(scic);
+	ihost = container_of(port_agent, typeof(*ihost), port_agent);
 
 	spin_lock_irqsave(&ihost->scic_lock, flags);
 
@@ -708,7 +686,7 @@ static void apc_agent_timeout(unsigned long data)
 		if ((configure_phy_mask & (1 << index)) == 0)
 			continue;
 
-		scic_sds_apc_agent_configure_ports(scic, port_agent,
+		scic_sds_apc_agent_configure_ports(ihost, port_agent,
 						   &ihost->phys[index], false);
 	}
 
@@ -748,17 +726,17 @@ void scic_sds_port_configuration_agent_construct(
 }
 
 enum sci_status scic_sds_port_configuration_agent_initialize(
-	struct scic_sds_controller *scic,
+	struct isci_host *ihost,
 	struct scic_sds_port_configuration_agent *port_agent)
 {
 	enum sci_status status;
 	enum scic_port_configuration_mode mode;
 
-	mode = scic->oem_parameters.sds1.controller.mode_type;
+	mode = ihost->oem_parameters.sds1.controller.mode_type;
 
 	if (mode == SCIC_PORT_MANUAL_CONFIGURATION_MODE) {
 		status = scic_sds_mpc_agent_validate_phy_configuration(
-				scic, port_agent);
+				ihost, port_agent);
 
 		port_agent->link_up_handler = scic_sds_mpc_agent_link_up;
 		port_agent->link_down_handler = scic_sds_mpc_agent_link_down;
@@ -766,7 +744,7 @@ enum sci_status scic_sds_port_configuration_agent_initialize(
 		sci_init_timer(&port_agent->timer, mpc_agent_timeout);
 	} else {
 		status = scic_sds_apc_agent_validate_phy_configuration(
-				scic, port_agent);
+				ihost, port_agent);
 
 		port_agent->link_up_handler = scic_sds_apc_agent_link_up;
 		port_agent->link_down_handler = scic_sds_apc_agent_link_down;

commit ffe191c92ff195d73f9130b1490045ca2dd4c5e0
Author: Dan Williams <dan.j.williams@intel.com>
Date:   Wed Jun 29 13:09:25 2011 -0700

    isci: unify isci_port and scic_sds_port
    
    Remove the distinction between these two implementations and unify on
    isci_port (local instances named iport).  The duplicate '->owning_port' and
    '->isci_port' in both isci_phy and isci_remote_device will be fixed in a later
    patch... this is just the straightforward rename/unification.
    
    Reported-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/drivers/scsi/isci/port_config.c b/drivers/scsi/isci/port_config.c
index 8444fd8219dd..bb62d2a25217 100644
--- a/drivers/scsi/isci/port_config.c
+++ b/drivers/scsi/isci/port_config.c
@@ -112,7 +112,7 @@ static s32 sci_sas_address_compare(
  * port. port address if the port can be found to match the phy.
  * NULL if there is no matching port for the phy.
  */
-static struct scic_sds_port *scic_sds_port_configuration_agent_find_port(
+static struct isci_port *scic_sds_port_configuration_agent_find_port(
 	struct scic_sds_controller *scic,
 	struct isci_phy *iphy)
 {
@@ -132,14 +132,14 @@ static struct scic_sds_port *scic_sds_port_configuration_agent_find_port(
 
 	for (i = 0; i < scic->logical_port_entries; i++) {
 		struct isci_host *ihost = scic_to_ihost(scic);
-		struct scic_sds_port *sci_port = &ihost->ports[i].sci;
+		struct isci_port *iport = &ihost->ports[i];
 
-		scic_sds_port_get_sas_address(sci_port, &port_sas_address);
-		scic_sds_port_get_attached_sas_address(sci_port, &port_attached_device_address);
+		scic_sds_port_get_sas_address(iport, &port_sas_address);
+		scic_sds_port_get_attached_sas_address(iport, &port_attached_device_address);
 
 		if (sci_sas_address_compare(port_sas_address, phy_sas_address) == 0 &&
 		    sci_sas_address_compare(port_attached_device_address, phy_attached_device_address) == 0)
-			return sci_port;
+			return iport;
 	}
 
 	return NULL;
@@ -315,7 +315,7 @@ static enum sci_status scic_sds_mpc_agent_validate_phy_configuration(
 			port_agent->phy_valid_port_range[phy_index].min_index = port_index;
 			port_agent->phy_valid_port_range[phy_index].max_index = phy_index;
 
-			scic_sds_port_add_phy(&ihost->ports[port_index].sci,
+			scic_sds_port_add_phy(&ihost->ports[port_index],
 					      &ihost->phys[phy_index]);
 
 			assigned_phy_mask |= (1 << phy_index);
@@ -367,22 +367,20 @@ static void mpc_agent_timeout(unsigned long data)
 
 static void scic_sds_mpc_agent_link_up(struct scic_sds_controller *controller,
 				       struct scic_sds_port_configuration_agent *port_agent,
-				       struct scic_sds_port *port,
+				       struct isci_port *iport,
 				       struct isci_phy *iphy)
 {
-	/* If the port has an invalid handle then the phy was not assigned to
-	 * a port.  This is because the phy was not given the same SAS Address
-	 * as the other PHYs in the port.
+	/* If the port is NULL then the phy was not assigned to a port.
+	 * This is because the phy was not given the same SAS Address as
+	 * the other PHYs in the port.
 	 */
-	if (port != NULL) {
-		port_agent->phy_ready_mask |= (1 << scic_sds_phy_get_index(iphy));
-
-		scic_sds_port_link_up(port, iphy);
+	if (!iport)
+		return;
 
-		if ((port->active_phy_mask & (1 << scic_sds_phy_get_index(iphy))) != 0) {
-			port_agent->phy_configured_mask |= (1 << scic_sds_phy_get_index(iphy));
-		}
-	}
+	port_agent->phy_ready_mask |= (1 << scic_sds_phy_get_index(iphy));
+	scic_sds_port_link_up(iport, iphy);
+	if ((iport->active_phy_mask & (1 << scic_sds_phy_get_index(iphy))))
+		port_agent->phy_configured_mask |= (1 << scic_sds_phy_get_index(iphy));
 }
 
 /**
@@ -405,10 +403,10 @@ static void scic_sds_mpc_agent_link_up(struct scic_sds_controller *controller,
 static void scic_sds_mpc_agent_link_down(
 	struct scic_sds_controller *scic,
 	struct scic_sds_port_configuration_agent *port_agent,
-	struct scic_sds_port *sci_port,
+	struct isci_port *iport,
 	struct isci_phy *iphy)
 {
-	if (sci_port != NULL) {
+	if (iport != NULL) {
 		/*
 		 * If we can form a new port from the remainder of the phys
 		 * then we want to start the timer to allow the SCI User to
@@ -436,7 +434,7 @@ static void scic_sds_mpc_agent_link_down(
 				      SCIC_SDS_MPC_RECONFIGURATION_TIMEOUT);
 		}
 
-		scic_sds_port_link_down(sci_port, iphy);
+		scic_sds_port_link_down(iport, iphy);
 	}
 }
 
@@ -496,14 +494,14 @@ static void scic_sds_apc_agent_configure_ports(struct scic_sds_controller *contr
 {
 	u8 port_index;
 	enum sci_status status;
-	struct scic_sds_port *port;
+	struct isci_port *iport;
 	enum SCIC_SDS_APC_ACTIVITY apc_activity = SCIC_SDS_APC_SKIP_PHY;
 	struct isci_host *ihost = scic_to_ihost(controller);
 
-	port = scic_sds_port_configuration_agent_find_port(controller, iphy);
+	iport = scic_sds_port_configuration_agent_find_port(controller, iphy);
 
-	if (port != NULL) {
-		if (scic_sds_port_is_valid_phy_assignment(port, iphy->phy_index))
+	if (iport) {
+		if (scic_sds_port_is_valid_phy_assignment(iport, iphy->phy_index))
 			apc_activity = SCIC_SDS_APC_ADD_PHY;
 		else
 			apc_activity = SCIC_SDS_APC_SKIP_PHY;
@@ -514,21 +512,19 @@ static void scic_sds_apc_agent_configure_ports(struct scic_sds_controller *contr
 		 * the timer and wait to see if a wider port can be made.
 		 *
 		 * Note the break when we reach the condition of the port id == phy id */
-		for (
-			port_index = port_agent->phy_valid_port_range[iphy->phy_index].min_index;
-			port_index <= port_agent->phy_valid_port_range[iphy->phy_index].max_index;
-			port_index++
-			) {
+		for (port_index = port_agent->phy_valid_port_range[iphy->phy_index].min_index;
+		     port_index <= port_agent->phy_valid_port_range[iphy->phy_index].max_index;
+		     port_index++) {
 
-			port = &ihost->ports[port_index].sci;
+			iport = &ihost->ports[port_index];
 
 			/* First we must make sure that this PHY can be added to this Port. */
-			if (scic_sds_port_is_valid_phy_assignment(port, iphy->phy_index)) {
+			if (scic_sds_port_is_valid_phy_assignment(iport, iphy->phy_index)) {
 				/*
 				 * Port contains a PHY with a greater PHY ID than the current
 				 * PHY that has gone link up.  This phy can not be part of any
 				 * port so skip it and move on. */
-				if (port->active_phy_mask > (1 << iphy->phy_index)) {
+				if (iport->active_phy_mask > (1 << iphy->phy_index)) {
 					apc_activity = SCIC_SDS_APC_SKIP_PHY;
 					break;
 				}
@@ -537,7 +533,7 @@ static void scic_sds_apc_agent_configure_ports(struct scic_sds_controller *contr
 				 * We have reached the end of our Port list and have not found
 				 * any reason why we should not either add the PHY to the port
 				 * or wait for more phys to become active. */
-				if (port->physical_port_index == iphy->phy_index) {
+				if (iport->physical_port_index == iphy->phy_index) {
 					/*
 					 * The Port either has no active PHYs.
 					 * Consider that if the port had any active PHYs we would have
@@ -554,10 +550,10 @@ static void scic_sds_apc_agent_configure_ports(struct scic_sds_controller *contr
 				 * The current Port has no active PHYs and this PHY could be part
 				 * of this Port.  Since we dont know as yet setup to start the
 				 * timer and see if there is a better configuration. */
-				if (port->active_phy_mask == 0) {
+				if (iport->active_phy_mask == 0) {
 					apc_activity = SCIC_SDS_APC_START_TIMER;
 				}
-			} else if (port->active_phy_mask != 0) {
+			} else if (iport->active_phy_mask != 0) {
 				/*
 				 * The Port has an active phy and the current Phy can not
 				 * participate in this port so skip the PHY and see if
@@ -583,7 +579,7 @@ static void scic_sds_apc_agent_configure_ports(struct scic_sds_controller *contr
 
 	switch (apc_activity) {
 	case SCIC_SDS_APC_ADD_PHY:
-		status = scic_sds_port_add_phy(port, iphy);
+		status = scic_sds_port_add_phy(iport, iphy);
 
 		if (status == SCI_SUCCESS) {
 			port_agent->phy_configured_mask |= (1 << iphy->phy_index);
@@ -625,18 +621,18 @@ static void scic_sds_apc_agent_configure_ports(struct scic_sds_controller *contr
  */
 static void scic_sds_apc_agent_link_up(struct scic_sds_controller *scic,
 				       struct scic_sds_port_configuration_agent *port_agent,
-				       struct scic_sds_port *sci_port,
+				       struct isci_port *iport,
 				       struct isci_phy *iphy)
 {
 	u8 phy_index  = iphy->phy_index;
 
-	if (!sci_port) {
+	if (!iport) {
 		/* the phy is not the part of this port */
 		port_agent->phy_ready_mask |= 1 << phy_index;
 		scic_sds_apc_agent_configure_ports(scic, port_agent, iphy, true);
 	} else {
 		/* the phy is already the part of the port */
-		u32 port_state = sci_port->sm.current_state_id;
+		u32 port_state = iport->sm.current_state_id;
 
 		/* if the PORT'S state is resetting then the link up is from
 		 * port hard reset in this case, we need to tell the port
@@ -644,7 +640,7 @@ static void scic_sds_apc_agent_link_up(struct scic_sds_controller *scic,
 		 */
 		BUG_ON(port_state != SCI_PORT_RESETTING);
 		port_agent->phy_ready_mask |= 1 << phy_index;
-		scic_sds_port_link_up(sci_port, iphy);
+		scic_sds_port_link_up(iport, iphy);
 	}
 }
 
@@ -652,9 +648,9 @@ static void scic_sds_apc_agent_link_up(struct scic_sds_controller *scic,
  *
  * @controller: This is the controller object that receives the link down
  *    notification.
- * @port: This is the port object associated with the phy.  If the is no
+ * @iport: This is the port object associated with the phy.  If the is no
  *    associated port this is an NULL.
- * @phy: This is the phy object which has gone link down.
+ * @iphy: This is the phy object which has gone link down.
  *
  * This method handles the automatic port configuration link down
  * notifications. not associated with a port there is no action taken. Is it
@@ -664,21 +660,20 @@ static void scic_sds_apc_agent_link_up(struct scic_sds_controller *scic,
 static void scic_sds_apc_agent_link_down(
 	struct scic_sds_controller *controller,
 	struct scic_sds_port_configuration_agent *port_agent,
-	struct scic_sds_port *port,
+	struct isci_port *iport,
 	struct isci_phy *iphy)
 {
 	port_agent->phy_ready_mask &= ~(1 << scic_sds_phy_get_index(iphy));
 
-	if (port != NULL) {
-		if (port_agent->phy_configured_mask & (1 << iphy->phy_index)) {
-			enum sci_status status;
+	if (!iport)
+		return;
+	if (port_agent->phy_configured_mask & (1 << iphy->phy_index)) {
+		enum sci_status status;
 
-			status = scic_sds_port_remove_phy(port, iphy);
+		status = scic_sds_port_remove_phy(iport, iphy);
 
-			if (status == SCI_SUCCESS) {
-				port_agent->phy_configured_mask &= ~(1 << iphy->phy_index);
-			}
-		}
+		if (status == SCI_SUCCESS)
+			port_agent->phy_configured_mask &= ~(1 << iphy->phy_index);
 	}
 }
 

commit 852809559e4680ba4768262a6c3d21454fcd460e
Author: Dan Williams <dan.j.williams@intel.com>
Date:   Tue Jun 28 15:05:53 2011 -0700

    isci: unify isci_phy and scic_sds_phy
    
    They are one in the same object so remove the distinction.  The near
    duplicate fields (owning_port, and isci_port) will be cleaned up
    after the scic_sds_port isci_port unification.
    
    Reported-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/drivers/scsi/isci/port_config.c b/drivers/scsi/isci/port_config.c
index fcb8f030b7ae..8444fd8219dd 100644
--- a/drivers/scsi/isci/port_config.c
+++ b/drivers/scsi/isci/port_config.c
@@ -114,7 +114,7 @@ static s32 sci_sas_address_compare(
  */
 static struct scic_sds_port *scic_sds_port_configuration_agent_find_port(
 	struct scic_sds_controller *scic,
-	struct scic_sds_phy *phy)
+	struct isci_phy *iphy)
 {
 	u8 i;
 	struct sci_sas_address port_sas_address;
@@ -127,8 +127,8 @@ static struct scic_sds_port *scic_sds_port_configuration_agent_find_port(
 	 * more phys match the sent and received SAS address as this phy in which
 	 * case it should participate in the same port.
 	 */
-	scic_sds_phy_get_sas_address(phy, &phy_sas_address);
-	scic_sds_phy_get_attached_sas_address(phy, &phy_attached_device_address);
+	scic_sds_phy_get_sas_address(iphy, &phy_sas_address);
+	scic_sds_phy_get_attached_sas_address(iphy, &phy_attached_device_address);
 
 	for (i = 0; i < scic->logical_port_entries; i++) {
 		struct isci_host *ihost = scic_to_ihost(scic);
@@ -196,8 +196,8 @@ static enum sci_status scic_sds_port_configuration_agent_validate_ports(
 	 * PE0 and PE3 can never have the same SAS Address unless they
 	 * are part of the same x4 wide port and we have already checked
 	 * for this condition. */
-	scic_sds_phy_get_sas_address(&ihost->phys[0].sci, &first_address);
-	scic_sds_phy_get_sas_address(&ihost->phys[3].sci, &second_address);
+	scic_sds_phy_get_sas_address(&ihost->phys[0], &first_address);
+	scic_sds_phy_get_sas_address(&ihost->phys[3], &second_address);
 
 	if (sci_sas_address_compare(first_address, second_address) == 0) {
 		return SCI_FAILURE_UNSUPPORTED_PORT_CONFIGURATION;
@@ -209,8 +209,8 @@ static enum sci_status scic_sds_port_configuration_agent_validate_ports(
 	 * part of the same port. */
 	if (port_agent->phy_valid_port_range[0].min_index == 0 &&
 	    port_agent->phy_valid_port_range[1].min_index == 1) {
-		scic_sds_phy_get_sas_address(&ihost->phys[0].sci, &first_address);
-		scic_sds_phy_get_sas_address(&ihost->phys[2].sci, &second_address);
+		scic_sds_phy_get_sas_address(&ihost->phys[0], &first_address);
+		scic_sds_phy_get_sas_address(&ihost->phys[2], &second_address);
 
 		if (sci_sas_address_compare(first_address, second_address) == 0) {
 			return SCI_FAILURE_UNSUPPORTED_PORT_CONFIGURATION;
@@ -223,8 +223,8 @@ static enum sci_status scic_sds_port_configuration_agent_validate_ports(
 	 * part of the same port. */
 	if (port_agent->phy_valid_port_range[2].min_index == 2 &&
 	    port_agent->phy_valid_port_range[3].min_index == 3) {
-		scic_sds_phy_get_sas_address(&ihost->phys[1].sci, &first_address);
-		scic_sds_phy_get_sas_address(&ihost->phys[3].sci, &second_address);
+		scic_sds_phy_get_sas_address(&ihost->phys[1], &first_address);
+		scic_sds_phy_get_sas_address(&ihost->phys[3], &second_address);
 
 		if (sci_sas_address_compare(first_address, second_address) == 0) {
 			return SCI_FAILURE_UNSUPPORTED_PORT_CONFIGURATION;
@@ -277,7 +277,7 @@ static enum sci_status scic_sds_mpc_agent_validate_phy_configuration(
 		for (phy_index = 0; phy_index < SCI_MAX_PHYS; phy_index++) {
 			if ((phy_mask & (1 << phy_index)) == 0)
 				continue;
-			scic_sds_phy_get_sas_address(&ihost->phys[phy_index].sci,
+			scic_sds_phy_get_sas_address(&ihost->phys[phy_index],
 						     &sas_address);
 
 			/*
@@ -302,7 +302,7 @@ static enum sci_status scic_sds_mpc_agent_validate_phy_configuration(
 		while (phy_index < SCI_MAX_PHYS) {
 			if ((phy_mask & (1 << phy_index)) == 0)
 				continue;
-			scic_sds_phy_get_sas_address(&ihost->phys[phy_index].sci,
+			scic_sds_phy_get_sas_address(&ihost->phys[phy_index],
 						     &phy_assigned_address);
 
 			if (sci_sas_address_compare(sas_address, phy_assigned_address) != 0) {
@@ -316,7 +316,7 @@ static enum sci_status scic_sds_mpc_agent_validate_phy_configuration(
 			port_agent->phy_valid_port_range[phy_index].max_index = phy_index;
 
 			scic_sds_port_add_phy(&ihost->ports[port_index].sci,
-					      &ihost->phys[phy_index].sci);
+					      &ihost->phys[phy_index]);
 
 			assigned_phy_mask |= (1 << phy_index);
 		}
@@ -352,12 +352,12 @@ static void mpc_agent_timeout(unsigned long data)
 	configure_phy_mask = ~port_agent->phy_configured_mask & port_agent->phy_ready_mask;
 
 	for (index = 0; index < SCI_MAX_PHYS; index++) {
-		struct scic_sds_phy *sci_phy = &ihost->phys[index].sci;
+		struct isci_phy *iphy = &ihost->phys[index];
 
 		if (configure_phy_mask & (1 << index)) {
 			port_agent->link_up_handler(scic, port_agent,
-						    phy_get_non_dummy_port(sci_phy),
-						    sci_phy);
+						    phy_get_non_dummy_port(iphy),
+						    iphy);
 		}
 	}
 
@@ -365,37 +365,22 @@ static void mpc_agent_timeout(unsigned long data)
 	spin_unlock_irqrestore(&ihost->scic_lock, flags);
 }
 
-/**
- *
- * @controller: This is the controller object that receives the link up
- *    notification.
- * @port: This is the port object associated with the phy.  If the is no
- *    associated port this is an NULL.
- * @phy: This is the phy object which has gone ready.
- *
- * This method handles the manual port configuration link up notifications.
- * Since all ports and phys are associate at initialization time we just turn
- * around and notifiy the port object that there is a link up.  If this PHY is
- * not associated with a port there is no action taken. Is it possible to get a
- * link up notification from a phy that has no assocoated port?
- */
-static void scic_sds_mpc_agent_link_up(
-	struct scic_sds_controller *controller,
-	struct scic_sds_port_configuration_agent *port_agent,
-	struct scic_sds_port *port,
-	struct scic_sds_phy *phy)
+static void scic_sds_mpc_agent_link_up(struct scic_sds_controller *controller,
+				       struct scic_sds_port_configuration_agent *port_agent,
+				       struct scic_sds_port *port,
+				       struct isci_phy *iphy)
 {
-	/*
-	 * If the port has an invalid handle then the phy was not assigned to
+	/* If the port has an invalid handle then the phy was not assigned to
 	 * a port.  This is because the phy was not given the same SAS Address
-	 * as the other PHYs in the port. */
+	 * as the other PHYs in the port.
+	 */
 	if (port != NULL) {
-		port_agent->phy_ready_mask |= (1 << scic_sds_phy_get_index(phy));
+		port_agent->phy_ready_mask |= (1 << scic_sds_phy_get_index(iphy));
 
-		scic_sds_port_link_up(port, phy);
+		scic_sds_port_link_up(port, iphy);
 
-		if ((port->active_phy_mask & (1 << scic_sds_phy_get_index(phy))) != 0) {
-			port_agent->phy_configured_mask |= (1 << scic_sds_phy_get_index(phy));
+		if ((port->active_phy_mask & (1 << scic_sds_phy_get_index(iphy))) != 0) {
+			port_agent->phy_configured_mask |= (1 << scic_sds_phy_get_index(iphy));
 		}
 	}
 }
@@ -421,7 +406,7 @@ static void scic_sds_mpc_agent_link_down(
 	struct scic_sds_controller *scic,
 	struct scic_sds_port_configuration_agent *port_agent,
 	struct scic_sds_port *sci_port,
-	struct scic_sds_phy *sci_phy)
+	struct isci_phy *iphy)
 {
 	if (sci_port != NULL) {
 		/*
@@ -432,9 +417,9 @@ static void scic_sds_mpc_agent_link_down(
 		 * state.
 		 */
 		port_agent->phy_ready_mask &=
-			~(1 << scic_sds_phy_get_index(sci_phy));
+			~(1 << scic_sds_phy_get_index(iphy));
 		port_agent->phy_configured_mask &=
-			~(1 << scic_sds_phy_get_index(sci_phy));
+			~(1 << scic_sds_phy_get_index(iphy));
 
 		/*
 		 * Check to see if there are more phys waiting to be
@@ -451,7 +436,7 @@ static void scic_sds_mpc_agent_link_down(
 				      SCIC_SDS_MPC_RECONFIGURATION_TIMEOUT);
 		}
 
-		scic_sds_port_link_down(sci_port, sci_phy);
+		scic_sds_port_link_down(sci_port, iphy);
 	}
 }
 
@@ -482,11 +467,11 @@ static enum sci_status scic_sds_apc_agent_validate_phy_configuration(
 		port_index = phy_index;
 
 		/* Get the assigned SAS Address for the first PHY on the controller. */
-		scic_sds_phy_get_sas_address(&ihost->phys[phy_index].sci,
+		scic_sds_phy_get_sas_address(&ihost->phys[phy_index],
 					    &sas_address);
 
 		while (++phy_index < SCI_MAX_PHYS) {
-			scic_sds_phy_get_sas_address(&ihost->phys[phy_index].sci,
+			scic_sds_phy_get_sas_address(&ihost->phys[phy_index],
 						     &phy_assigned_address);
 
 			/* Verify each of the SAS address are all the same for every PHY */
@@ -504,20 +489,10 @@ static enum sci_status scic_sds_apc_agent_validate_phy_configuration(
 	return scic_sds_port_configuration_agent_validate_ports(controller, port_agent);
 }
 
-/**
- *
- * @controller: This is the controller object that receives the link up
- *    notification.
- * @phy: This is the phy object which has gone link up.
- *
- * This method handles the automatic port configuration for link up
- * notifications.
- */
-static void scic_sds_apc_agent_configure_ports(
-	struct scic_sds_controller *controller,
-	struct scic_sds_port_configuration_agent *port_agent,
-	struct scic_sds_phy *phy,
-	bool start_timer)
+static void scic_sds_apc_agent_configure_ports(struct scic_sds_controller *controller,
+					       struct scic_sds_port_configuration_agent *port_agent,
+					       struct isci_phy *iphy,
+					       bool start_timer)
 {
 	u8 port_index;
 	enum sci_status status;
@@ -525,10 +500,10 @@ static void scic_sds_apc_agent_configure_ports(
 	enum SCIC_SDS_APC_ACTIVITY apc_activity = SCIC_SDS_APC_SKIP_PHY;
 	struct isci_host *ihost = scic_to_ihost(controller);
 
-	port = scic_sds_port_configuration_agent_find_port(controller, phy);
+	port = scic_sds_port_configuration_agent_find_port(controller, iphy);
 
 	if (port != NULL) {
-		if (scic_sds_port_is_valid_phy_assignment(port, phy->phy_index))
+		if (scic_sds_port_is_valid_phy_assignment(port, iphy->phy_index))
 			apc_activity = SCIC_SDS_APC_ADD_PHY;
 		else
 			apc_activity = SCIC_SDS_APC_SKIP_PHY;
@@ -540,20 +515,20 @@ static void scic_sds_apc_agent_configure_ports(
 		 *
 		 * Note the break when we reach the condition of the port id == phy id */
 		for (
-			port_index = port_agent->phy_valid_port_range[phy->phy_index].min_index;
-			port_index <= port_agent->phy_valid_port_range[phy->phy_index].max_index;
+			port_index = port_agent->phy_valid_port_range[iphy->phy_index].min_index;
+			port_index <= port_agent->phy_valid_port_range[iphy->phy_index].max_index;
 			port_index++
 			) {
 
 			port = &ihost->ports[port_index].sci;
 
 			/* First we must make sure that this PHY can be added to this Port. */
-			if (scic_sds_port_is_valid_phy_assignment(port, phy->phy_index)) {
+			if (scic_sds_port_is_valid_phy_assignment(port, iphy->phy_index)) {
 				/*
 				 * Port contains a PHY with a greater PHY ID than the current
 				 * PHY that has gone link up.  This phy can not be part of any
 				 * port so skip it and move on. */
-				if (port->active_phy_mask > (1 << phy->phy_index)) {
+				if (port->active_phy_mask > (1 << iphy->phy_index)) {
 					apc_activity = SCIC_SDS_APC_SKIP_PHY;
 					break;
 				}
@@ -562,7 +537,7 @@ static void scic_sds_apc_agent_configure_ports(
 				 * We have reached the end of our Port list and have not found
 				 * any reason why we should not either add the PHY to the port
 				 * or wait for more phys to become active. */
-				if (port->physical_port_index == phy->phy_index) {
+				if (port->physical_port_index == iphy->phy_index) {
 					/*
 					 * The Port either has no active PHYs.
 					 * Consider that if the port had any active PHYs we would have
@@ -608,10 +583,10 @@ static void scic_sds_apc_agent_configure_ports(
 
 	switch (apc_activity) {
 	case SCIC_SDS_APC_ADD_PHY:
-		status = scic_sds_port_add_phy(port, phy);
+		status = scic_sds_port_add_phy(port, iphy);
 
 		if (status == SCI_SUCCESS) {
-			port_agent->phy_configured_mask |= (1 << phy->phy_index);
+			port_agent->phy_configured_mask |= (1 << iphy->phy_index);
 		}
 		break;
 
@@ -651,14 +626,14 @@ static void scic_sds_apc_agent_configure_ports(
 static void scic_sds_apc_agent_link_up(struct scic_sds_controller *scic,
 				       struct scic_sds_port_configuration_agent *port_agent,
 				       struct scic_sds_port *sci_port,
-				       struct scic_sds_phy *sci_phy)
+				       struct isci_phy *iphy)
 {
-	u8 phy_index  = sci_phy->phy_index;
+	u8 phy_index  = iphy->phy_index;
 
 	if (!sci_port) {
 		/* the phy is not the part of this port */
 		port_agent->phy_ready_mask |= 1 << phy_index;
-		scic_sds_apc_agent_configure_ports(scic, port_agent, sci_phy, true);
+		scic_sds_apc_agent_configure_ports(scic, port_agent, iphy, true);
 	} else {
 		/* the phy is already the part of the port */
 		u32 port_state = sci_port->sm.current_state_id;
@@ -669,7 +644,7 @@ static void scic_sds_apc_agent_link_up(struct scic_sds_controller *scic,
 		 */
 		BUG_ON(port_state != SCI_PORT_RESETTING);
 		port_agent->phy_ready_mask |= 1 << phy_index;
-		scic_sds_port_link_up(sci_port, sci_phy);
+		scic_sds_port_link_up(sci_port, iphy);
 	}
 }
 
@@ -690,18 +665,18 @@ static void scic_sds_apc_agent_link_down(
 	struct scic_sds_controller *controller,
 	struct scic_sds_port_configuration_agent *port_agent,
 	struct scic_sds_port *port,
-	struct scic_sds_phy *phy)
+	struct isci_phy *iphy)
 {
-	port_agent->phy_ready_mask &= ~(1 << scic_sds_phy_get_index(phy));
+	port_agent->phy_ready_mask &= ~(1 << scic_sds_phy_get_index(iphy));
 
 	if (port != NULL) {
-		if (port_agent->phy_configured_mask & (1 << phy->phy_index)) {
+		if (port_agent->phy_configured_mask & (1 << iphy->phy_index)) {
 			enum sci_status status;
 
-			status = scic_sds_port_remove_phy(port, phy);
+			status = scic_sds_port_remove_phy(port, iphy);
 
 			if (status == SCI_SUCCESS) {
-				port_agent->phy_configured_mask &= ~(1 << phy->phy_index);
+				port_agent->phy_configured_mask &= ~(1 << iphy->phy_index);
 			}
 		}
 	}
@@ -739,7 +714,7 @@ static void apc_agent_timeout(unsigned long data)
 			continue;
 
 		scic_sds_apc_agent_configure_ports(scic, port_agent,
-						   &ihost->phys[index].sci, false);
+						   &ihost->phys[index], false);
 	}
 
 done:

commit e301370ac553a9a0ac0d1d25e769b86cf60395b3
Author: Edmund Nadolski <edmund.nadolski@intel.com>
Date:   Thu Jun 2 00:10:43 2011 +0000

    isci: state machine cleanup
    
    This cleans up several areas of the state machine mechanism:
    
     o Rename sci_base_state_machine_change_state to sci_change_state
     o Remove sci_base_state_machine_get_state function
     o Rename 'state_machine' struct member to 'sm' in client structs
     o Shorten the name of request states
     o Shorten state machine state names as follows:
            SCI_BASE_CONTROLLER_STATE_xxx to SCIC_xxx
            SCI_BASE_PHY_STATE_xxx to SCI_PHY_xxx
            SCIC_SDS_PHY_STARTING_SUBSTATE_xxx to SCI_PHY_SUB_xxx
            SCI_BASE_PORT_STATE_xxx to SCI_PORT_xxx and
            SCIC_SDS_PORT_READY_SUBSTATE_xxx to SCI_PORT_SUB_xxx
            SCI_BASE_REMOTE_DEVICE_STATE_xxx to SCI_DEV_xxx
            SCIC_SDS_STP_REMOTE_DEVICE_READY_SUBSTATE_xxx to SCI_STP_DEV_xxx
            SCIC_SDS_SMP_REMOTE_DEVICE_READY_SUBSTATE_xxx to SCI_SMP_DEV_xxx
            SCIC_SDS_REMOTE_NODE_CONTEXT_xxx_STATE to SCI_RNC_xxx
    
    Signed-off-by: Edmund Nadolski <edmund.nadolski@intel.com>
    Signed-off-by: Dave Jiang <dave.jiang@intel.com>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/drivers/scsi/isci/port_config.c b/drivers/scsi/isci/port_config.c
index 38401f644e18..fcb8f030b7ae 100644
--- a/drivers/scsi/isci/port_config.c
+++ b/drivers/scsi/isci/port_config.c
@@ -661,13 +661,13 @@ static void scic_sds_apc_agent_link_up(struct scic_sds_controller *scic,
 		scic_sds_apc_agent_configure_ports(scic, port_agent, sci_phy, true);
 	} else {
 		/* the phy is already the part of the port */
-		u32 port_state = sci_port->state_machine.current_state_id;
+		u32 port_state = sci_port->sm.current_state_id;
 
 		/* if the PORT'S state is resetting then the link up is from
 		 * port hard reset in this case, we need to tell the port
 		 * that link up is recieved
 		 */
-		BUG_ON(port_state != SCI_BASE_PORT_STATE_RESETTING);
+		BUG_ON(port_state != SCI_PORT_RESETTING);
 		port_agent->phy_ready_mask |= 1 << phy_index;
 		scic_sds_port_link_up(sci_port, sci_phy);
 	}

commit 8db02da52895285e99d7eb2fa825fd393e61d9c5
Author: Edmund Nadolski <edmund.nadolski@intel.com>
Date:   Thu May 19 12:00:22 2011 +0000

    isci: remove isci_timer interface
    
    Delete code which is no longer used.
    
    Signed-off-by: Edmund Nadolski <edmund.nadolski@intel.com>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/drivers/scsi/isci/port_config.c b/drivers/scsi/isci/port_config.c
index 1cde7b9165f4..38401f644e18 100644
--- a/drivers/scsi/isci/port_config.c
+++ b/drivers/scsi/isci/port_config.c
@@ -54,7 +54,6 @@
  */
 
 #include "host.h"
-#include "timers.h"
 
 #define SCIC_SDS_MPC_RECONFIGURATION_TIMEOUT    (10)
 #define SCIC_SDS_APC_RECONFIGURATION_TIMEOUT    (10)

commit ac0eeb4f774261d1da21a68169f7ddd4f6c082fc
Author: Edmund Nadolski <edmund.nadolski@intel.com>
Date:   Thu May 19 20:00:51 2011 -0700

    isci: convert port config agent timer to sci_timer
    
    Signed-off-by: Edmund Nadolski <edmund.nadolski@intel.com>
    [squashed collateral cleanups]
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/drivers/scsi/isci/port_config.c b/drivers/scsi/isci/port_config.c
index ca76f493c30d..1cde7b9165f4 100644
--- a/drivers/scsi/isci/port_config.c
+++ b/drivers/scsi/isci/port_config.c
@@ -328,21 +328,25 @@ static enum sci_status scic_sds_mpc_agent_validate_phy_configuration(
 	return scic_sds_port_configuration_agent_validate_ports(controller, port_agent);
 }
 
-/**
- *
- *
- * This timer routine is used to allow the SCI User to rediscover or change
- * device objects before a new series of link up notifications because a link
- * down has allowed a better port configuration.
- */
-static void scic_sds_mpc_agent_timeout_handler(void *object)
+static void mpc_agent_timeout(unsigned long data)
 {
 	u8 index;
-	struct scic_sds_controller *scic = object;
-	struct isci_host *ihost = scic_to_ihost(scic);
-	struct scic_sds_port_configuration_agent *port_agent = &scic->port_agent;
+	struct sci_timer *tmr = (struct sci_timer *)data;
+	struct scic_sds_port_configuration_agent *port_agent;
+	struct scic_sds_controller *scic;
+	struct isci_host *ihost;
+	unsigned long flags;
 	u16 configure_phy_mask;
 
+	port_agent = container_of(tmr, typeof(*port_agent), timer);
+	scic = container_of(port_agent, typeof(*scic), port_agent);
+	ihost = scic_to_ihost(scic);
+
+	spin_lock_irqsave(&ihost->scic_lock, flags);
+
+	if (tmr->cancel)
+		goto done;
+
 	port_agent->timer_pending = false;
 
 	/* Find the mask of phys that are reported read but as yet unconfigured into a port */
@@ -357,6 +361,9 @@ static void scic_sds_mpc_agent_timeout_handler(void *object)
 						    sci_phy);
 		}
 	}
+
+done:
+	spin_unlock_irqrestore(&ihost->scic_lock, flags);
 }
 
 /**
@@ -441,8 +448,8 @@ static void scic_sds_mpc_agent_link_down(
 		    !port_agent->timer_pending) {
 			port_agent->timer_pending = true;
 
-			isci_timer_start(port_agent->timer,
-					 SCIC_SDS_MPC_RECONFIGURATION_TIMEOUT);
+			sci_mod_timer(&port_agent->timer,
+				      SCIC_SDS_MPC_RECONFIGURATION_TIMEOUT);
 		}
 
 		scic_sds_port_link_down(sci_port, sci_phy);
@@ -498,31 +505,6 @@ static enum sci_status scic_sds_apc_agent_validate_phy_configuration(
 	return scic_sds_port_configuration_agent_validate_ports(controller, port_agent);
 }
 
-/**
- *
- * @controller: This is the controller that to which the port agent is assigned.
- * @port_agent: This is the port agent that is requesting the timer start
- *    operation.
- * @phy: This is the phy that has caused the timer operation to be scheduled.
- *
- * This routine will restart the automatic port configuration timeout timer for
- * the next time period.  This could be caused by either a link down event or a
- * link up event where we can not yet tell to which port a phy belongs.
- */
-static inline void scic_sds_apc_agent_start_timer(
-	struct scic_sds_controller *scic,
-	struct scic_sds_port_configuration_agent *port_agent,
-	struct scic_sds_phy *sci_phy,
-	u32 timeout)
-{
-	if (port_agent->timer_pending)
-		isci_timer_stop(port_agent->timer);
-
-	port_agent->timer_pending = true;
-
-	isci_timer_start(port_agent->timer, timeout);
-}
-
 /**
  *
  * @controller: This is the controller object that receives the link up
@@ -635,9 +617,17 @@ static void scic_sds_apc_agent_configure_ports(
 		break;
 
 	case SCIC_SDS_APC_START_TIMER:
-		scic_sds_apc_agent_start_timer(
-			controller, port_agent, phy, SCIC_SDS_APC_WAIT_LINK_UP_NOTIFICATION
-			);
+		/*
+		 * This can occur for either a link down event, or a link
+		 * up event where we cannot yet tell the port to which a
+		 * phy belongs.
+		 */
+		if (port_agent->timer_pending)
+			sci_del_timer(&port_agent->timer);
+
+		port_agent->timer_pending = true;
+		sci_mod_timer(&port_agent->timer,
+			      SCIC_SDS_APC_WAIT_LINK_UP_NOTIFICATION);
 		break;
 
 	case SCIC_SDS_APC_SKIP_PHY:
@@ -719,15 +709,24 @@ static void scic_sds_apc_agent_link_down(
 }
 
 /* configure the phys into ports when the timer fires */
-static void scic_sds_apc_agent_timeout_handler(void *object)
+static void apc_agent_timeout(unsigned long data)
 {
 	u32 index;
+	struct sci_timer *tmr = (struct sci_timer *)data;
 	struct scic_sds_port_configuration_agent *port_agent;
-	struct scic_sds_controller *scic = object;
-	struct isci_host *ihost = scic_to_ihost(scic);
+	struct scic_sds_controller *scic;
+	struct isci_host *ihost;
+	unsigned long flags;
 	u16 configure_phy_mask;
 
-	port_agent = scic_sds_controller_get_port_configuration_agent(scic);
+	port_agent = container_of(tmr, typeof(*port_agent), timer);
+	scic = container_of(port_agent, typeof(*scic), port_agent);
+	ihost = scic_to_ihost(scic);
+
+	spin_lock_irqsave(&ihost->scic_lock, flags);
+
+	if (tmr->cancel)
+		goto done;
 
 	port_agent->timer_pending = false;
 
@@ -743,6 +742,9 @@ static void scic_sds_apc_agent_timeout_handler(void *object)
 		scic_sds_apc_agent_configure_ports(scic, port_agent,
 						   &ihost->phys[index].sci, false);
 	}
+
+done:
+	spin_unlock_irqrestore(&ihost->scic_lock, flags);
 }
 
 /*
@@ -769,7 +771,6 @@ void scic_sds_port_configuration_agent_construct(
 	port_agent->link_down_handler = NULL;
 
 	port_agent->timer_pending = false;
-	port_agent->timer = NULL;
 
 	for (index = 0; index < SCI_MAX_PORTS; index++) {
 		port_agent->phy_valid_port_range[index].min_index = 0;
@@ -781,9 +782,8 @@ enum sci_status scic_sds_port_configuration_agent_initialize(
 	struct scic_sds_controller *scic,
 	struct scic_sds_port_configuration_agent *port_agent)
 {
-	enum sci_status status = SCI_SUCCESS;
+	enum sci_status status;
 	enum scic_port_configuration_mode mode;
-	struct isci_host *ihost = scic_to_ihost(scic);
 
 	mode = scic->oem_parameters.sds1.controller.mode_type;
 
@@ -794,10 +794,7 @@ enum sci_status scic_sds_port_configuration_agent_initialize(
 		port_agent->link_up_handler = scic_sds_mpc_agent_link_up;
 		port_agent->link_down_handler = scic_sds_mpc_agent_link_down;
 
-		port_agent->timer = isci_timer_create(
-				ihost,
-				scic,
-				scic_sds_mpc_agent_timeout_handler);
+		sci_init_timer(&port_agent->timer, mpc_agent_timeout);
 	} else {
 		status = scic_sds_apc_agent_validate_phy_configuration(
 				scic, port_agent);
@@ -805,21 +802,7 @@ enum sci_status scic_sds_port_configuration_agent_initialize(
 		port_agent->link_up_handler = scic_sds_apc_agent_link_up;
 		port_agent->link_down_handler = scic_sds_apc_agent_link_down;
 
-		port_agent->timer = isci_timer_create(
-				ihost,
-				scic,
-				scic_sds_apc_agent_timeout_handler);
-	}
-
-	/* Make sure we have actually gotten a timer */
-	if ((status == SCI_SUCCESS) && (port_agent->timer == NULL)) {
-		dev_err(scic_to_dev(scic),
-			"%s: Controller 0x%p automatic port configuration "
-			"agent could not get timer.\n",
-			__func__,
-			scic);
-
-		status = SCI_FAILURE;
+		sci_init_timer(&port_agent->timer, apc_agent_timeout);
 	}
 
 	return status;

commit 4f20ef4f57aa52fd3356c143a8f3d2bd18dc61fc
Author: Dan Williams <dan.j.williams@intel.com>
Date:   Thu May 12 06:00:31 2011 -0700

    isci: clarify phy to port lookups
    
    While cleaning up the driver it is very tempting to convert scic_sds_get_*
    macros to their open coded equivalent.  They are all just pointer dereferences
    *except* scic_sds_phy_get_port() which returns NULL if the phy is assigned to
    the dummy port.  Clarify this by renaming it to phy_get_non_dummy_port().
    
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/drivers/scsi/isci/port_config.c b/drivers/scsi/isci/port_config.c
index 028ffa370c90..ca76f493c30d 100644
--- a/drivers/scsi/isci/port_config.c
+++ b/drivers/scsi/isci/port_config.c
@@ -353,7 +353,7 @@ static void scic_sds_mpc_agent_timeout_handler(void *object)
 
 		if (configure_phy_mask & (1 << index)) {
 			port_agent->link_up_handler(scic, port_agent,
-						    scic_sds_phy_get_port(sci_phy),
+						    phy_get_non_dummy_port(sci_phy),
 						    sci_phy);
 		}
 	}

commit e2f8db509fdd354bb7a68c86515e9d2d8909ccc9
Author: Dan Williams <dan.j.williams@intel.com>
Date:   Tue May 10 02:28:46 2011 -0700

    isci: uplevel port infrastructure
    
    * Move port configuration agent implementation
    * Merge core/scic_sds_port.[ch] into port.[ch]
    
    Reported-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/drivers/scsi/isci/port_config.c b/drivers/scsi/isci/port_config.c
new file mode 100644
index 000000000000..028ffa370c90
--- /dev/null
+++ b/drivers/scsi/isci/port_config.c
@@ -0,0 +1,826 @@
+/*
+ * This file is provided under a dual BSD/GPLv2 license.  When using or
+ * redistributing this file, you may do so under either license.
+ *
+ * GPL LICENSE SUMMARY
+ *
+ * Copyright(c) 2008 - 2011 Intel Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
+ * The full GNU General Public License is included in this distribution
+ * in the file called LICENSE.GPL.
+ *
+ * BSD LICENSE
+ *
+ * Copyright(c) 2008 - 2011 Intel Corporation. All rights reserved.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ *   * Redistributions of source code must retain the above copyright
+ *     notice, this list of conditions and the following disclaimer.
+ *   * Redistributions in binary form must reproduce the above copyright
+ *     notice, this list of conditions and the following disclaimer in
+ *     the documentation and/or other materials provided with the
+ *     distribution.
+ *   * Neither the name of Intel Corporation nor the names of its
+ *     contributors may be used to endorse or promote products derived
+ *     from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include "host.h"
+#include "timers.h"
+
+#define SCIC_SDS_MPC_RECONFIGURATION_TIMEOUT    (10)
+#define SCIC_SDS_APC_RECONFIGURATION_TIMEOUT    (10)
+#define SCIC_SDS_APC_WAIT_LINK_UP_NOTIFICATION  (100)
+
+enum SCIC_SDS_APC_ACTIVITY {
+	SCIC_SDS_APC_SKIP_PHY,
+	SCIC_SDS_APC_ADD_PHY,
+	SCIC_SDS_APC_START_TIMER,
+
+	SCIC_SDS_APC_ACTIVITY_MAX
+};
+
+/*
+ * ******************************************************************************
+ * General port configuration agent routines
+ * ****************************************************************************** */
+
+/**
+ *
+ * @address_one: A SAS Address to be compared.
+ * @address_two: A SAS Address to be compared.
+ *
+ * Compare the two SAS Address and if SAS Address One is greater than SAS
+ * Address Two then return > 0 else if SAS Address One is less than SAS Address
+ * Two return < 0 Otherwise they are the same return 0 A signed value of x > 0
+ * > y where x is returned for Address One > Address Two y is returned for
+ * Address One < Address Two 0 is returned ofr Address One = Address Two
+ */
+static s32 sci_sas_address_compare(
+	struct sci_sas_address address_one,
+	struct sci_sas_address address_two)
+{
+	if (address_one.high > address_two.high) {
+		return 1;
+	} else if (address_one.high < address_two.high) {
+		return -1;
+	} else if (address_one.low > address_two.low) {
+		return 1;
+	} else if (address_one.low < address_two.low) {
+		return -1;
+	}
+
+	/* The two SAS Address must be identical */
+	return 0;
+}
+
+/**
+ *
+ * @controller: The controller object used for the port search.
+ * @phy: The phy object to match.
+ *
+ * This routine will find a matching port for the phy.  This means that the
+ * port and phy both have the same broadcast sas address and same received sas
+ * address. The port address or the NULL if there is no matching
+ * port. port address if the port can be found to match the phy.
+ * NULL if there is no matching port for the phy.
+ */
+static struct scic_sds_port *scic_sds_port_configuration_agent_find_port(
+	struct scic_sds_controller *scic,
+	struct scic_sds_phy *phy)
+{
+	u8 i;
+	struct sci_sas_address port_sas_address;
+	struct sci_sas_address port_attached_device_address;
+	struct sci_sas_address phy_sas_address;
+	struct sci_sas_address phy_attached_device_address;
+
+	/*
+	 * Since this phy can be a member of a wide port check to see if one or
+	 * more phys match the sent and received SAS address as this phy in which
+	 * case it should participate in the same port.
+	 */
+	scic_sds_phy_get_sas_address(phy, &phy_sas_address);
+	scic_sds_phy_get_attached_sas_address(phy, &phy_attached_device_address);
+
+	for (i = 0; i < scic->logical_port_entries; i++) {
+		struct isci_host *ihost = scic_to_ihost(scic);
+		struct scic_sds_port *sci_port = &ihost->ports[i].sci;
+
+		scic_sds_port_get_sas_address(sci_port, &port_sas_address);
+		scic_sds_port_get_attached_sas_address(sci_port, &port_attached_device_address);
+
+		if (sci_sas_address_compare(port_sas_address, phy_sas_address) == 0 &&
+		    sci_sas_address_compare(port_attached_device_address, phy_attached_device_address) == 0)
+			return sci_port;
+	}
+
+	return NULL;
+}
+
+/**
+ *
+ * @controller: This is the controller object that contains the port agent
+ * @port_agent: This is the port configruation agent for the controller.
+ *
+ * This routine will validate the port configuration is correct for the SCU
+ * hardware.  The SCU hardware allows for port configurations as follows. LP0
+ * -> (PE0), (PE0, PE1), (PE0, PE1, PE2, PE3) LP1 -> (PE1) LP2 -> (PE2), (PE2,
+ * PE3) LP3 -> (PE3) enum sci_status SCI_SUCCESS the port configuration is valid for
+ * this port configuration agent. SCI_FAILURE_UNSUPPORTED_PORT_CONFIGURATION
+ * the port configuration is not valid for this port configuration agent.
+ */
+static enum sci_status scic_sds_port_configuration_agent_validate_ports(
+	struct scic_sds_controller *controller,
+	struct scic_sds_port_configuration_agent *port_agent)
+{
+	struct isci_host *ihost = scic_to_ihost(controller);
+	struct sci_sas_address first_address;
+	struct sci_sas_address second_address;
+
+	/*
+	 * Sanity check the max ranges for all the phys the max index
+	 * is always equal to the port range index */
+	if (port_agent->phy_valid_port_range[0].max_index != 0 ||
+	    port_agent->phy_valid_port_range[1].max_index != 1 ||
+	    port_agent->phy_valid_port_range[2].max_index != 2 ||
+	    port_agent->phy_valid_port_range[3].max_index != 3)
+		return SCI_FAILURE_UNSUPPORTED_PORT_CONFIGURATION;
+
+	/*
+	 * This is a request to configure a single x4 port or at least attempt
+	 * to make all the phys into a single port */
+	if (port_agent->phy_valid_port_range[0].min_index == 0 &&
+	    port_agent->phy_valid_port_range[1].min_index == 0 &&
+	    port_agent->phy_valid_port_range[2].min_index == 0 &&
+	    port_agent->phy_valid_port_range[3].min_index == 0)
+		return SCI_SUCCESS;
+
+	/*
+	 * This is a degenerate case where phy 1 and phy 2 are assigned
+	 * to the same port this is explicitly disallowed by the hardware
+	 * unless they are part of the same x4 port and this condition was
+	 * already checked above. */
+	if (port_agent->phy_valid_port_range[2].min_index == 1) {
+		return SCI_FAILURE_UNSUPPORTED_PORT_CONFIGURATION;
+	}
+
+	/*
+	 * PE0 and PE3 can never have the same SAS Address unless they
+	 * are part of the same x4 wide port and we have already checked
+	 * for this condition. */
+	scic_sds_phy_get_sas_address(&ihost->phys[0].sci, &first_address);
+	scic_sds_phy_get_sas_address(&ihost->phys[3].sci, &second_address);
+
+	if (sci_sas_address_compare(first_address, second_address) == 0) {
+		return SCI_FAILURE_UNSUPPORTED_PORT_CONFIGURATION;
+	}
+
+	/*
+	 * PE0 and PE1 are configured into a 2x1 ports make sure that the
+	 * SAS Address for PE0 and PE2 are different since they can not be
+	 * part of the same port. */
+	if (port_agent->phy_valid_port_range[0].min_index == 0 &&
+	    port_agent->phy_valid_port_range[1].min_index == 1) {
+		scic_sds_phy_get_sas_address(&ihost->phys[0].sci, &first_address);
+		scic_sds_phy_get_sas_address(&ihost->phys[2].sci, &second_address);
+
+		if (sci_sas_address_compare(first_address, second_address) == 0) {
+			return SCI_FAILURE_UNSUPPORTED_PORT_CONFIGURATION;
+		}
+	}
+
+	/*
+	 * PE2 and PE3 are configured into a 2x1 ports make sure that the
+	 * SAS Address for PE1 and PE3 are different since they can not be
+	 * part of the same port. */
+	if (port_agent->phy_valid_port_range[2].min_index == 2 &&
+	    port_agent->phy_valid_port_range[3].min_index == 3) {
+		scic_sds_phy_get_sas_address(&ihost->phys[1].sci, &first_address);
+		scic_sds_phy_get_sas_address(&ihost->phys[3].sci, &second_address);
+
+		if (sci_sas_address_compare(first_address, second_address) == 0) {
+			return SCI_FAILURE_UNSUPPORTED_PORT_CONFIGURATION;
+		}
+	}
+
+	return SCI_SUCCESS;
+}
+
+/*
+ * ******************************************************************************
+ * Manual port configuration agent routines
+ * ****************************************************************************** */
+
+/**
+ *
+ *
+ * This routine will verify that all of the phys in the same port are using the
+ * same SAS address.
+ */
+static enum sci_status scic_sds_mpc_agent_validate_phy_configuration(
+	struct scic_sds_controller *controller,
+	struct scic_sds_port_configuration_agent *port_agent)
+{
+	struct isci_host *ihost = scic_to_ihost(controller);
+	u32 phy_mask;
+	u32 assigned_phy_mask;
+	struct sci_sas_address sas_address;
+	struct sci_sas_address phy_assigned_address;
+	u8 port_index;
+	u8 phy_index;
+
+	assigned_phy_mask = 0;
+	sas_address.high = 0;
+	sas_address.low = 0;
+
+	for (port_index = 0; port_index < SCI_MAX_PORTS; port_index++) {
+		phy_mask = controller->oem_parameters.sds1.ports[port_index].phy_mask;
+
+		if (!phy_mask)
+			continue;
+		/*
+		 * Make sure that one or more of the phys were not already assinged to
+		 * a different port. */
+		if ((phy_mask & ~assigned_phy_mask) == 0) {
+			return SCI_FAILURE_UNSUPPORTED_PORT_CONFIGURATION;
+		}
+
+		/* Find the starting phy index for this round through the loop */
+		for (phy_index = 0; phy_index < SCI_MAX_PHYS; phy_index++) {
+			if ((phy_mask & (1 << phy_index)) == 0)
+				continue;
+			scic_sds_phy_get_sas_address(&ihost->phys[phy_index].sci,
+						     &sas_address);
+
+			/*
+			 * The phy_index can be used as the starting point for the
+			 * port range since the hardware starts all logical ports
+			 * the same as the PE index. */
+			port_agent->phy_valid_port_range[phy_index].min_index = port_index;
+			port_agent->phy_valid_port_range[phy_index].max_index = phy_index;
+
+			if (phy_index != port_index) {
+				return SCI_FAILURE_UNSUPPORTED_PORT_CONFIGURATION;
+			}
+
+			break;
+		}
+
+		/*
+		 * See how many additional phys are being added to this logical port.
+		 * Note: We have not moved the current phy_index so we will actually
+		 *       compare the startting phy with itself.
+		 *       This is expected and required to add the phy to the port. */
+		while (phy_index < SCI_MAX_PHYS) {
+			if ((phy_mask & (1 << phy_index)) == 0)
+				continue;
+			scic_sds_phy_get_sas_address(&ihost->phys[phy_index].sci,
+						     &phy_assigned_address);
+
+			if (sci_sas_address_compare(sas_address, phy_assigned_address) != 0) {
+				/*
+				 * The phy mask specified that this phy is part of the same port
+				 * as the starting phy and it is not so fail this configuration */
+				return SCI_FAILURE_UNSUPPORTED_PORT_CONFIGURATION;
+			}
+
+			port_agent->phy_valid_port_range[phy_index].min_index = port_index;
+			port_agent->phy_valid_port_range[phy_index].max_index = phy_index;
+
+			scic_sds_port_add_phy(&ihost->ports[port_index].sci,
+					      &ihost->phys[phy_index].sci);
+
+			assigned_phy_mask |= (1 << phy_index);
+		}
+
+		phy_index++;
+	}
+
+	return scic_sds_port_configuration_agent_validate_ports(controller, port_agent);
+}
+
+/**
+ *
+ *
+ * This timer routine is used to allow the SCI User to rediscover or change
+ * device objects before a new series of link up notifications because a link
+ * down has allowed a better port configuration.
+ */
+static void scic_sds_mpc_agent_timeout_handler(void *object)
+{
+	u8 index;
+	struct scic_sds_controller *scic = object;
+	struct isci_host *ihost = scic_to_ihost(scic);
+	struct scic_sds_port_configuration_agent *port_agent = &scic->port_agent;
+	u16 configure_phy_mask;
+
+	port_agent->timer_pending = false;
+
+	/* Find the mask of phys that are reported read but as yet unconfigured into a port */
+	configure_phy_mask = ~port_agent->phy_configured_mask & port_agent->phy_ready_mask;
+
+	for (index = 0; index < SCI_MAX_PHYS; index++) {
+		struct scic_sds_phy *sci_phy = &ihost->phys[index].sci;
+
+		if (configure_phy_mask & (1 << index)) {
+			port_agent->link_up_handler(scic, port_agent,
+						    scic_sds_phy_get_port(sci_phy),
+						    sci_phy);
+		}
+	}
+}
+
+/**
+ *
+ * @controller: This is the controller object that receives the link up
+ *    notification.
+ * @port: This is the port object associated with the phy.  If the is no
+ *    associated port this is an NULL.
+ * @phy: This is the phy object which has gone ready.
+ *
+ * This method handles the manual port configuration link up notifications.
+ * Since all ports and phys are associate at initialization time we just turn
+ * around and notifiy the port object that there is a link up.  If this PHY is
+ * not associated with a port there is no action taken. Is it possible to get a
+ * link up notification from a phy that has no assocoated port?
+ */
+static void scic_sds_mpc_agent_link_up(
+	struct scic_sds_controller *controller,
+	struct scic_sds_port_configuration_agent *port_agent,
+	struct scic_sds_port *port,
+	struct scic_sds_phy *phy)
+{
+	/*
+	 * If the port has an invalid handle then the phy was not assigned to
+	 * a port.  This is because the phy was not given the same SAS Address
+	 * as the other PHYs in the port. */
+	if (port != NULL) {
+		port_agent->phy_ready_mask |= (1 << scic_sds_phy_get_index(phy));
+
+		scic_sds_port_link_up(port, phy);
+
+		if ((port->active_phy_mask & (1 << scic_sds_phy_get_index(phy))) != 0) {
+			port_agent->phy_configured_mask |= (1 << scic_sds_phy_get_index(phy));
+		}
+	}
+}
+
+/**
+ *
+ * @controller: This is the controller object that receives the link down
+ *    notification.
+ * @port: This is the port object associated with the phy.  If the is no
+ *    associated port this is an NULL.  The port is an invalid
+ *    handle only if the phy was never port of this port.  This happens when
+ *    the phy is not broadcasting the same SAS address as the other phys in the
+ *    assigned port.
+ * @phy: This is the phy object which has gone link down.
+ *
+ * This function handles the manual port configuration link down notifications.
+ * Since all ports and phys are associated at initialization time we just turn
+ * around and notifiy the port object of the link down event.  If this PHY is
+ * not associated with a port there is no action taken. Is it possible to get a
+ * link down notification from a phy that has no assocoated port?
+ */
+static void scic_sds_mpc_agent_link_down(
+	struct scic_sds_controller *scic,
+	struct scic_sds_port_configuration_agent *port_agent,
+	struct scic_sds_port *sci_port,
+	struct scic_sds_phy *sci_phy)
+{
+	if (sci_port != NULL) {
+		/*
+		 * If we can form a new port from the remainder of the phys
+		 * then we want to start the timer to allow the SCI User to
+		 * cleanup old devices and rediscover the port before
+		 * rebuilding the port with the phys that remain in the ready
+		 * state.
+		 */
+		port_agent->phy_ready_mask &=
+			~(1 << scic_sds_phy_get_index(sci_phy));
+		port_agent->phy_configured_mask &=
+			~(1 << scic_sds_phy_get_index(sci_phy));
+
+		/*
+		 * Check to see if there are more phys waiting to be
+		 * configured into a port. If there are allow the SCI User
+		 * to tear down this port, if necessary, and then reconstruct
+		 * the port after the timeout.
+		 */
+		if ((port_agent->phy_configured_mask == 0x0000) &&
+		    (port_agent->phy_ready_mask != 0x0000) &&
+		    !port_agent->timer_pending) {
+			port_agent->timer_pending = true;
+
+			isci_timer_start(port_agent->timer,
+					 SCIC_SDS_MPC_RECONFIGURATION_TIMEOUT);
+		}
+
+		scic_sds_port_link_down(sci_port, sci_phy);
+	}
+}
+
+/*
+ * ******************************************************************************
+ * Automatic port configuration agent routines
+ * ****************************************************************************** */
+
+/**
+ *
+ *
+ * This routine will verify that the phys are assigned a valid SAS address for
+ * automatic port configuration mode.
+ */
+static enum sci_status scic_sds_apc_agent_validate_phy_configuration(
+	struct scic_sds_controller *controller,
+	struct scic_sds_port_configuration_agent *port_agent)
+{
+	u8 phy_index;
+	u8 port_index;
+	struct sci_sas_address sas_address;
+	struct sci_sas_address phy_assigned_address;
+	struct isci_host *ihost = scic_to_ihost(controller);
+
+	phy_index = 0;
+
+	while (phy_index < SCI_MAX_PHYS) {
+		port_index = phy_index;
+
+		/* Get the assigned SAS Address for the first PHY on the controller. */
+		scic_sds_phy_get_sas_address(&ihost->phys[phy_index].sci,
+					    &sas_address);
+
+		while (++phy_index < SCI_MAX_PHYS) {
+			scic_sds_phy_get_sas_address(&ihost->phys[phy_index].sci,
+						     &phy_assigned_address);
+
+			/* Verify each of the SAS address are all the same for every PHY */
+			if (sci_sas_address_compare(sas_address, phy_assigned_address) == 0) {
+				port_agent->phy_valid_port_range[phy_index].min_index = port_index;
+				port_agent->phy_valid_port_range[phy_index].max_index = phy_index;
+			} else {
+				port_agent->phy_valid_port_range[phy_index].min_index = phy_index;
+				port_agent->phy_valid_port_range[phy_index].max_index = phy_index;
+				break;
+			}
+		}
+	}
+
+	return scic_sds_port_configuration_agent_validate_ports(controller, port_agent);
+}
+
+/**
+ *
+ * @controller: This is the controller that to which the port agent is assigned.
+ * @port_agent: This is the port agent that is requesting the timer start
+ *    operation.
+ * @phy: This is the phy that has caused the timer operation to be scheduled.
+ *
+ * This routine will restart the automatic port configuration timeout timer for
+ * the next time period.  This could be caused by either a link down event or a
+ * link up event where we can not yet tell to which port a phy belongs.
+ */
+static inline void scic_sds_apc_agent_start_timer(
+	struct scic_sds_controller *scic,
+	struct scic_sds_port_configuration_agent *port_agent,
+	struct scic_sds_phy *sci_phy,
+	u32 timeout)
+{
+	if (port_agent->timer_pending)
+		isci_timer_stop(port_agent->timer);
+
+	port_agent->timer_pending = true;
+
+	isci_timer_start(port_agent->timer, timeout);
+}
+
+/**
+ *
+ * @controller: This is the controller object that receives the link up
+ *    notification.
+ * @phy: This is the phy object which has gone link up.
+ *
+ * This method handles the automatic port configuration for link up
+ * notifications.
+ */
+static void scic_sds_apc_agent_configure_ports(
+	struct scic_sds_controller *controller,
+	struct scic_sds_port_configuration_agent *port_agent,
+	struct scic_sds_phy *phy,
+	bool start_timer)
+{
+	u8 port_index;
+	enum sci_status status;
+	struct scic_sds_port *port;
+	enum SCIC_SDS_APC_ACTIVITY apc_activity = SCIC_SDS_APC_SKIP_PHY;
+	struct isci_host *ihost = scic_to_ihost(controller);
+
+	port = scic_sds_port_configuration_agent_find_port(controller, phy);
+
+	if (port != NULL) {
+		if (scic_sds_port_is_valid_phy_assignment(port, phy->phy_index))
+			apc_activity = SCIC_SDS_APC_ADD_PHY;
+		else
+			apc_activity = SCIC_SDS_APC_SKIP_PHY;
+	} else {
+		/*
+		 * There is no matching Port for this PHY so lets search through the
+		 * Ports and see if we can add the PHY to its own port or maybe start
+		 * the timer and wait to see if a wider port can be made.
+		 *
+		 * Note the break when we reach the condition of the port id == phy id */
+		for (
+			port_index = port_agent->phy_valid_port_range[phy->phy_index].min_index;
+			port_index <= port_agent->phy_valid_port_range[phy->phy_index].max_index;
+			port_index++
+			) {
+
+			port = &ihost->ports[port_index].sci;
+
+			/* First we must make sure that this PHY can be added to this Port. */
+			if (scic_sds_port_is_valid_phy_assignment(port, phy->phy_index)) {
+				/*
+				 * Port contains a PHY with a greater PHY ID than the current
+				 * PHY that has gone link up.  This phy can not be part of any
+				 * port so skip it and move on. */
+				if (port->active_phy_mask > (1 << phy->phy_index)) {
+					apc_activity = SCIC_SDS_APC_SKIP_PHY;
+					break;
+				}
+
+				/*
+				 * We have reached the end of our Port list and have not found
+				 * any reason why we should not either add the PHY to the port
+				 * or wait for more phys to become active. */
+				if (port->physical_port_index == phy->phy_index) {
+					/*
+					 * The Port either has no active PHYs.
+					 * Consider that if the port had any active PHYs we would have
+					 * or active PHYs with
+					 * a lower PHY Id than this PHY. */
+					if (apc_activity != SCIC_SDS_APC_START_TIMER) {
+						apc_activity = SCIC_SDS_APC_ADD_PHY;
+					}
+
+					break;
+				}
+
+				/*
+				 * The current Port has no active PHYs and this PHY could be part
+				 * of this Port.  Since we dont know as yet setup to start the
+				 * timer and see if there is a better configuration. */
+				if (port->active_phy_mask == 0) {
+					apc_activity = SCIC_SDS_APC_START_TIMER;
+				}
+			} else if (port->active_phy_mask != 0) {
+				/*
+				 * The Port has an active phy and the current Phy can not
+				 * participate in this port so skip the PHY and see if
+				 * there is a better configuration. */
+				apc_activity = SCIC_SDS_APC_SKIP_PHY;
+			}
+		}
+	}
+
+	/*
+	 * Check to see if the start timer operations should instead map to an
+	 * add phy operation.  This is caused because we have been waiting to
+	 * add a phy to a port but could not becuase the automatic port
+	 * configuration engine had a choice of possible ports for the phy.
+	 * Since we have gone through a timeout we are going to restrict the
+	 * choice to the smallest possible port. */
+	if (
+		(start_timer == false)
+		&& (apc_activity == SCIC_SDS_APC_START_TIMER)
+		) {
+		apc_activity = SCIC_SDS_APC_ADD_PHY;
+	}
+
+	switch (apc_activity) {
+	case SCIC_SDS_APC_ADD_PHY:
+		status = scic_sds_port_add_phy(port, phy);
+
+		if (status == SCI_SUCCESS) {
+			port_agent->phy_configured_mask |= (1 << phy->phy_index);
+		}
+		break;
+
+	case SCIC_SDS_APC_START_TIMER:
+		scic_sds_apc_agent_start_timer(
+			controller, port_agent, phy, SCIC_SDS_APC_WAIT_LINK_UP_NOTIFICATION
+			);
+		break;
+
+	case SCIC_SDS_APC_SKIP_PHY:
+	default:
+		/* do nothing the PHY can not be made part of a port at this time. */
+		break;
+	}
+}
+
+/**
+ * scic_sds_apc_agent_link_up - handle apc link up events
+ * @scic: This is the controller object that receives the link up
+ *    notification.
+ * @sci_port: This is the port object associated with the phy.  If the is no
+ *    associated port this is an NULL.
+ * @sci_phy: This is the phy object which has gone link up.
+ *
+ * This method handles the automatic port configuration for link up
+ * notifications. Is it possible to get a link down notification from a phy
+ * that has no assocoated port?
+ */
+static void scic_sds_apc_agent_link_up(struct scic_sds_controller *scic,
+				       struct scic_sds_port_configuration_agent *port_agent,
+				       struct scic_sds_port *sci_port,
+				       struct scic_sds_phy *sci_phy)
+{
+	u8 phy_index  = sci_phy->phy_index;
+
+	if (!sci_port) {
+		/* the phy is not the part of this port */
+		port_agent->phy_ready_mask |= 1 << phy_index;
+		scic_sds_apc_agent_configure_ports(scic, port_agent, sci_phy, true);
+	} else {
+		/* the phy is already the part of the port */
+		u32 port_state = sci_port->state_machine.current_state_id;
+
+		/* if the PORT'S state is resetting then the link up is from
+		 * port hard reset in this case, we need to tell the port
+		 * that link up is recieved
+		 */
+		BUG_ON(port_state != SCI_BASE_PORT_STATE_RESETTING);
+		port_agent->phy_ready_mask |= 1 << phy_index;
+		scic_sds_port_link_up(sci_port, sci_phy);
+	}
+}
+
+/**
+ *
+ * @controller: This is the controller object that receives the link down
+ *    notification.
+ * @port: This is the port object associated with the phy.  If the is no
+ *    associated port this is an NULL.
+ * @phy: This is the phy object which has gone link down.
+ *
+ * This method handles the automatic port configuration link down
+ * notifications. not associated with a port there is no action taken. Is it
+ * possible to get a link down notification from a phy that has no assocoated
+ * port?
+ */
+static void scic_sds_apc_agent_link_down(
+	struct scic_sds_controller *controller,
+	struct scic_sds_port_configuration_agent *port_agent,
+	struct scic_sds_port *port,
+	struct scic_sds_phy *phy)
+{
+	port_agent->phy_ready_mask &= ~(1 << scic_sds_phy_get_index(phy));
+
+	if (port != NULL) {
+		if (port_agent->phy_configured_mask & (1 << phy->phy_index)) {
+			enum sci_status status;
+
+			status = scic_sds_port_remove_phy(port, phy);
+
+			if (status == SCI_SUCCESS) {
+				port_agent->phy_configured_mask &= ~(1 << phy->phy_index);
+			}
+		}
+	}
+}
+
+/* configure the phys into ports when the timer fires */
+static void scic_sds_apc_agent_timeout_handler(void *object)
+{
+	u32 index;
+	struct scic_sds_port_configuration_agent *port_agent;
+	struct scic_sds_controller *scic = object;
+	struct isci_host *ihost = scic_to_ihost(scic);
+	u16 configure_phy_mask;
+
+	port_agent = scic_sds_controller_get_port_configuration_agent(scic);
+
+	port_agent->timer_pending = false;
+
+	configure_phy_mask = ~port_agent->phy_configured_mask & port_agent->phy_ready_mask;
+
+	if (!configure_phy_mask)
+		return;
+
+	for (index = 0; index < SCI_MAX_PHYS; index++) {
+		if ((configure_phy_mask & (1 << index)) == 0)
+			continue;
+
+		scic_sds_apc_agent_configure_ports(scic, port_agent,
+						   &ihost->phys[index].sci, false);
+	}
+}
+
+/*
+ * ******************************************************************************
+ * Public port configuration agent routines
+ * ****************************************************************************** */
+
+/**
+ *
+ *
+ * This method will construct the port configuration agent for operation. This
+ * call is universal for both manual port configuration and automatic port
+ * configuration modes.
+ */
+void scic_sds_port_configuration_agent_construct(
+	struct scic_sds_port_configuration_agent *port_agent)
+{
+	u32 index;
+
+	port_agent->phy_configured_mask = 0x00;
+	port_agent->phy_ready_mask = 0x00;
+
+	port_agent->link_up_handler = NULL;
+	port_agent->link_down_handler = NULL;
+
+	port_agent->timer_pending = false;
+	port_agent->timer = NULL;
+
+	for (index = 0; index < SCI_MAX_PORTS; index++) {
+		port_agent->phy_valid_port_range[index].min_index = 0;
+		port_agent->phy_valid_port_range[index].max_index = 0;
+	}
+}
+
+enum sci_status scic_sds_port_configuration_agent_initialize(
+	struct scic_sds_controller *scic,
+	struct scic_sds_port_configuration_agent *port_agent)
+{
+	enum sci_status status = SCI_SUCCESS;
+	enum scic_port_configuration_mode mode;
+	struct isci_host *ihost = scic_to_ihost(scic);
+
+	mode = scic->oem_parameters.sds1.controller.mode_type;
+
+	if (mode == SCIC_PORT_MANUAL_CONFIGURATION_MODE) {
+		status = scic_sds_mpc_agent_validate_phy_configuration(
+				scic, port_agent);
+
+		port_agent->link_up_handler = scic_sds_mpc_agent_link_up;
+		port_agent->link_down_handler = scic_sds_mpc_agent_link_down;
+
+		port_agent->timer = isci_timer_create(
+				ihost,
+				scic,
+				scic_sds_mpc_agent_timeout_handler);
+	} else {
+		status = scic_sds_apc_agent_validate_phy_configuration(
+				scic, port_agent);
+
+		port_agent->link_up_handler = scic_sds_apc_agent_link_up;
+		port_agent->link_down_handler = scic_sds_apc_agent_link_down;
+
+		port_agent->timer = isci_timer_create(
+				ihost,
+				scic,
+				scic_sds_apc_agent_timeout_handler);
+	}
+
+	/* Make sure we have actually gotten a timer */
+	if ((status == SCI_SUCCESS) && (port_agent->timer == NULL)) {
+		dev_err(scic_to_dev(scic),
+			"%s: Controller 0x%p automatic port configuration "
+			"agent could not get timer.\n",
+			__func__,
+			scic);
+
+		status = SCI_FAILURE;
+	}
+
+	return status;
+}
