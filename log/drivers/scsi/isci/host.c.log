commit 362b5da3dfceada6e74ecdd7af3991bbe42c0c0f
Author: Nathan Chancellor <natechancellor@gmail.com>
Date:   Wed Sep 26 17:12:00 2018 -0700

    scsi: isci: Change sci_controller_start_task's return type to sci_status
    
    Clang warns when an enumerated type is implicitly converted to another.
    
    drivers/scsi/isci/request.c:3476:13: warning: implicit conversion from
    enumeration type 'enum sci_task_status' to different enumeration type
    'enum sci_status' [-Wenum-conversion]
                            status = sci_controller_start_task(ihost,
                                   ~ ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    drivers/scsi/isci/host.c:2744:10: warning: implicit conversion from
    enumeration type 'enum sci_status' to different enumeration type 'enum
    sci_task_status' [-Wenum-conversion]
                    return SCI_SUCCESS;
                    ~~~~~~ ^~~~~~~~~~~
    drivers/scsi/isci/host.c:2753:9: warning: implicit conversion from
    enumeration type 'enum sci_status' to different enumeration type 'enum
    sci_task_status' [-Wenum-conversion]
            return status;
            ~~~~~~ ^~~~~~
    
    Avoid all of these implicit conversion by just making
    sci_controller_start_task use sci_status. This silences
    Clang and has no functional change since sci_task_status
    has all of its values mapped to something in sci_status.
    
    Link: https://github.com/ClangBuiltLinux/linux/issues/153
    Signed-off-by: Nathan Chancellor <natechancellor@gmail.com>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/isci/host.c b/drivers/scsi/isci/host.c
index 1ee3868ade07..7b5deae68d33 100644
--- a/drivers/scsi/isci/host.c
+++ b/drivers/scsi/isci/host.c
@@ -2717,9 +2717,9 @@ enum sci_status sci_controller_continue_io(struct isci_request *ireq)
  *    the task management request.
  * @task_request: the handle to the task request object to start.
  */
-enum sci_task_status sci_controller_start_task(struct isci_host *ihost,
-					       struct isci_remote_device *idev,
-					       struct isci_request *ireq)
+enum sci_status sci_controller_start_task(struct isci_host *ihost,
+					  struct isci_remote_device *idev,
+					  struct isci_request *ireq)
 {
 	enum sci_status status;
 
@@ -2728,7 +2728,7 @@ enum sci_task_status sci_controller_start_task(struct isci_host *ihost,
 			 "%s: SCIC Controller starting task from invalid "
 			 "state\n",
 			 __func__);
-		return SCI_TASK_FAILURE_INVALID_STATE;
+		return SCI_FAILURE_INVALID_STATE;
 	}
 
 	status = sci_remote_device_start_task(ihost, idev, ireq);

commit 2976fbb6a7aff04076d13d2a37e4b8dbe0d6fd4c
Author: Colin Ian King <colin.king@canonical.com>
Date:   Tue Feb 6 14:12:36 2018 +0000

    scsi: isci: remove redundant initialization to 'bit'
    
    Variable bit is initialized with a value that is never read and is being
    updated immediately after the initialization, hence the initialization
    is redundant and can be removed.
    
    Cleans up clang warning:
    drivers/scsi/isci/host.c:2769:8: warning: Value stored to 'bit' during
    its initialization is never read
    
    Signed-off-by: Colin Ian King <colin.king@canonical.com>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/isci/host.c b/drivers/scsi/isci/host.c
index 13b37cdffa8e..1ee3868ade07 100644
--- a/drivers/scsi/isci/host.c
+++ b/drivers/scsi/isci/host.c
@@ -2766,7 +2766,7 @@ static int sci_write_gpio_tx_gp(struct isci_host *ihost, u8 reg_index, u8 reg_co
 		int i;
 
 		for (i = 0; i < 3; i++) {
-			int bit = (i << 2) + 2;
+			int bit;
 
 			bit = try_test_sas_gpio_gp_bit(to_sas_gpio_od(d, i),
 						       write_data, reg_index,

commit b0a2dc66152aa409860e02804169b0007244ebd7
Author: Kees Cook <keescook@chromium.org>
Date:   Fri Sep 1 23:21:24 2017 -0700

    scsi: isci: Convert timers to use timer_setup()
    
    In preparation for unconditionally passing the struct timer_list pointer to
    all timer callbacks, switch to using the new timer_setup() and from_timer()
    to pass the timer pointer explicitly.
    
    Cc: Intel SCU Linux support <intel-linux-scu@intel.com>
    Cc: Artur Paszkiewicz <artur.paszkiewicz@intel.com>
    Cc: "James E.J. Bottomley" <jejb@linux.vnet.ibm.com>
    Cc: "Martin K. Petersen" <martin.petersen@oracle.com>
    Cc: linux-scsi@vger.kernel.org
    Signed-off-by: Kees Cook <keescook@chromium.org>
    Reviewed-by: Artur Paszkiewicz <artur.paszkiewicz@intel.com>

diff --git a/drivers/scsi/isci/host.c b/drivers/scsi/isci/host.c
index 609dafd661d1..13b37cdffa8e 100644
--- a/drivers/scsi/isci/host.c
+++ b/drivers/scsi/isci/host.c
@@ -958,9 +958,9 @@ static enum sci_status sci_controller_start_next_phy(struct isci_host *ihost)
 	return status;
 }
 
-static void phy_startup_timeout(unsigned long data)
+static void phy_startup_timeout(struct timer_list *t)
 {
-	struct sci_timer *tmr = (struct sci_timer *)data;
+	struct sci_timer *tmr = from_timer(tmr, t, timer);
 	struct isci_host *ihost = container_of(tmr, typeof(*ihost), phy_timer);
 	unsigned long flags;
 	enum sci_status status;
@@ -1592,9 +1592,9 @@ static const struct sci_base_state sci_controller_state_table[] = {
 	[SCIC_FAILED] = {}
 };
 
-static void controller_timeout(unsigned long data)
+static void controller_timeout(struct timer_list *t)
 {
-	struct sci_timer *tmr = (struct sci_timer *)data;
+	struct sci_timer *tmr = from_timer(tmr, t, timer);
 	struct isci_host *ihost = container_of(tmr, typeof(*ihost), timer);
 	struct sci_base_state_machine *sm = &ihost->sm;
 	unsigned long flags;
@@ -1737,9 +1737,9 @@ static u8 max_spin_up(struct isci_host *ihost)
 			     MAX_CONCURRENT_DEVICE_SPIN_UP_COUNT);
 }
 
-static void power_control_timeout(unsigned long data)
+static void power_control_timeout(struct timer_list *t)
 {
-	struct sci_timer *tmr = (struct sci_timer *)data;
+	struct sci_timer *tmr = from_timer(tmr, t, timer);
 	struct isci_host *ihost = container_of(tmr, typeof(*ihost), power_control.timer);
 	struct isci_phy *iphy;
 	unsigned long flags;

commit 3151367f8778a1789d6f6e6f6c642681b6cd6d64
Merge: 16642a2e7be2 fe709ed827d3
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue Oct 2 19:01:32 2012 -0700

    Merge tag 'scsi-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/jejb/scsi
    
    Pull first round of SCSI updates from James Bottomley:
     "This is a large set of updates, mostly for drivers (qla2xxx [including
      support for new 83xx based card], qla4xxx, mpt2sas, bfa, zfcp, hpsa,
      be2iscsi, isci, lpfc, ipr, ibmvfc, ibmvscsi, megaraid_sas).
    
      There's also a rework for tape adding virtually unlimited numbers of
      tape drives plus a set of dif fixes for sd and a fix for a live lock
      on hot remove of SCSI devices.
    
      This round includes a signed tag pull of isci-for-3.6
    
      Signed-off-by: James Bottomley <JBottomley@Parallels.com>"
    
    Fix up trivial conflict in drivers/scsi/qla2xxx/qla_nx.c due to new PCI
    helper function use in a function that was removed by this pull.
    
    * tag 'scsi-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/jejb/scsi: (198 commits)
      [SCSI] st: remove st_mutex
      [SCSI] sd: Ensure we correctly disable devices with unknown protection type
      [SCSI] hpsa: gen8plus Smart Array IDs
      [SCSI] qla4xxx: Update driver version to 5.03.00-k1
      [SCSI] qla4xxx: Disable generating pause frames for ISP83XX
      [SCSI] qla4xxx: Fix double clearing of risc_intr for ISP83XX
      [SCSI] qla4xxx: IDC implementation for Loopback
      [SCSI] qla4xxx: update copyrights in LICENSE.qla4xxx
      [SCSI] qla4xxx: Fix panic while rmmod
      [SCSI] qla4xxx: Fail probe_adapter if IRQ allocation fails
      [SCSI] qla4xxx: Prevent MSI/MSI-X falling back to INTx for ISP82XX
      [SCSI] qla4xxx: Update idc reg in case of PCI AER
      [SCSI] qla4xxx: Fix double IDC locking in qla4_8xxx_error_recovery
      [SCSI] qla4xxx: Clear interrupt while unloading driver for ISP83XX
      [SCSI] qla4xxx: Print correct IDC version
      [SCSI] qla4xxx: Added new mbox cmd to pass driver version to FW
      [SCSI] scsi_dh_alua: Enable STPG for unavailable ports
      [SCSI] scsi_remove_target: fix softlockup regression on hot remove
      [SCSI] ibmvscsi: Fix host config length field overflow
      [SCSI] ibmvscsi: Remove backend abstraction
      ...

commit fe709ed827d370e6b0c0a9f9456da1c22bdcd118
Merge: 1c4cf1d5845b 0644f5393e91
Author: James Bottomley <JBottomley@Parallels.com>
Date:   Tue Oct 2 08:55:12 2012 +0100

    Merge SCSI misc branch into isci-for-3.6 tag

commit 44ef2bf72df34ef2628dc3475b4507ab984d6744
Author: Dave Jiang <dave.jiang@intel.com>
Date:   Wed Sep 5 16:35:44 2012 -0700

    [SCSI] isci: Fix interrupt coalescing assumption of active TCs
    
    We always assign a dummy task context to a port in order to address a
    silicon issue. We have 4 ports per controller. So when idle, there are always
    exactly 4 TCs "active". The adaptive interrupt coalescing code uses number of
    active TCs to figure out the coalescing values. However, we never hit "0" TCs
    because of the 4 dummy TCs. Putting in fix so that we calculate this correctly.
    
    Reported-by: Dan Melnic <dan@seamicro.com>
    Signed-off-by: Dave Jiang <dave.jiang@intel.com>
    Signed-off-by: James Bottomley <JBottomley@Parallels.com>

diff --git a/drivers/scsi/isci/host.c b/drivers/scsi/isci/host.c
index d4daa0f24595..ab026a50ace3 100644
--- a/drivers/scsi/isci/host.c
+++ b/drivers/scsi/isci/host.c
@@ -1122,10 +1122,16 @@ void isci_host_completion_routine(unsigned long data)
 	sci_controller_completion_handler(ihost);
 	spin_unlock_irq(&ihost->scic_lock);
 
-	/* the coalesence timeout doubles at each encoding step, so
+	/*
+	 * we subtract SCI_MAX_PORTS to account for the number of dummy TCs
+	 * issued for hardware issue workaround
+	 */
+	active = isci_tci_active(ihost) - SCI_MAX_PORTS;
+
+	/*
+	 * the coalesence timeout doubles at each encoding step, so
 	 * update it based on the ilog2 value of the outstanding requests
 	 */
-	active = isci_tci_active(ihost);
 	writel(SMU_ICC_GEN_VAL(NUMBER, active) |
 	       SMU_ICC_GEN_VAL(TIMER, ISCI_COALESCE_BASE + ilog2(active)),
 	       &ihost->smu_registers->interrupt_coalesce_control);

commit 54b46677757ff8d6c282305fc7710f466b63d6dc
Author: Jeff Skirvin <jeffrey.d.skirvin@intel.com>
Date:   Wed Sep 5 21:36:47 2012 -0700

    [SCSI] isci: Allow SSP tasks into the task management path.
    
    This commit fixes a driver bug for SSP tasks that require task management
    in the target after they complete in the SCU hardware.  The problem was
    manifested in the function "isci_task_abort_task", which tests
    to see if the sas_task.lldd_task is non-NULL before allowing task
    management; this bug would always NULL lldd_task in the SCU I/O completion
    path even if target management was required, which would prevent
    task / target manangement from happening.
    
    Note that in the case of SATA/STP targets, error recovery is provided by
    the libata error handler which is why SATA/STP device recovery worked
    correctly even though SSP handling did not.
    
    Signed-off-by: Jeff Skirvin <jeffrey.d.skirvin@intel.com>
    Signed-off-by: James Bottomley <JBottomley@Parallels.com>

diff --git a/drivers/scsi/isci/host.c b/drivers/scsi/isci/host.c
index bc8981ed02b3..d4daa0f24595 100644
--- a/drivers/scsi/isci/host.c
+++ b/drivers/scsi/isci/host.c
@@ -1079,7 +1079,6 @@ static void sci_controller_completion_handler(struct isci_host *ihost)
 
 void ireq_done(struct isci_host *ihost, struct isci_request *ireq, struct sas_task *task)
 {
-	task->lldd_task = NULL;
 	if (!test_bit(IREQ_ABORT_PATH_ACTIVE, &ireq->flags) &&
 	    !(task->task_state_flags & SAS_TASK_STATE_ABORTED)) {
 		if (test_bit(IREQ_COMPLETE_IN_TARGET, &ireq->flags)) {
@@ -1087,16 +1086,19 @@ void ireq_done(struct isci_host *ihost, struct isci_request *ireq, struct sas_ta
 			dev_dbg(&ihost->pdev->dev,
 				"%s: Normal - ireq/task = %p/%p\n",
 				__func__, ireq, task);
-
+			task->lldd_task = NULL;
 			task->task_done(task);
 		} else {
 			dev_dbg(&ihost->pdev->dev,
 				"%s: Error - ireq/task = %p/%p\n",
 				__func__, ireq, task);
-
+			if (sas_protocol_ata(task->task_proto))
+				task->lldd_task = NULL;
 			sas_task_abort(task);
 		}
-	}
+	} else
+		task->lldd_task = NULL;
+
 	if (test_and_clear_bit(IREQ_ABORT_PATH_ACTIVE, &ireq->flags))
 		wake_up_all(&ihost->eventq);
 

commit 59e13d48334c38a73aec1759fe9a13eb4e476bf6
Author: Masanari Iida <standby24x7@gmail.com>
Date:   Wed Apr 25 00:24:16 2012 +0900

    scsi: fix various printk and comment typos
    
    Correct spelling typo within drivers/scsi
    
    Signed-off-by: Masanari Iida <standby24x7@gmail.com>
    Signed-off-by: Jiri Kosina <jkosina@suse.cz>

diff --git a/drivers/scsi/isci/host.c b/drivers/scsi/isci/host.c
index 45385f531649..b334fdc1726a 100644
--- a/drivers/scsi/isci/host.c
+++ b/drivers/scsi/isci/host.c
@@ -492,7 +492,7 @@ static void sci_controller_process_completions(struct isci_host *ihost)
 	u32 event_cycle;
 
 	dev_dbg(&ihost->pdev->dev,
-		"%s: completion queue begining get:0x%08x\n",
+		"%s: completion queue beginning get:0x%08x\n",
 		__func__,
 		ihost->completion_queue_get);
 

commit e468dc112f38220ee78bc0de64190eca9812749b
Author: Artur Wojcik <artur.wojcik@intel.com>
Date:   Thu Jun 21 23:41:56 2012 -0700

    [SCSI] isci: implement suspend/resume support
    
    Provide a "simple-dev-pm-ops" implementation that shuts down the domain
    and the device on suspend, and resumes the device and the domain on
    resume.  All of the mechanics of restoring domain connectivity are
    handled by libsas once isci has notified libsas that all links should be
    back up.  libsas is in charge of handling links that did not resume, or
    resumed out of order.
    
    Signed-off-by: Artur Wojcik <artur.wojcik@intel.com>
    Signed-off-by: Jacek Danecki <jacek.danecki@intel.com>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>
    Signed-off-by: James Bottomley <JBottomley@Parallels.com>

diff --git a/drivers/scsi/isci/host.c b/drivers/scsi/isci/host.c
index 45385f531649..bc8981ed02b3 100644
--- a/drivers/scsi/isci/host.c
+++ b/drivers/scsi/isci/host.c
@@ -1044,7 +1044,7 @@ static enum sci_status sci_controller_start(struct isci_host *ihost,
 	return SCI_SUCCESS;
 }
 
-void isci_host_scan_start(struct Scsi_Host *shost)
+void isci_host_start(struct Scsi_Host *shost)
 {
 	struct isci_host *ihost = SHOST_TO_SAS_HA(shost)->lldd_ha;
 	unsigned long tmo = sci_controller_get_suggested_start_timeout(ihost);

commit 6734092e66011def7875bd67beef889d0fee1cc9
Author: Dan Carpenter <dan.carpenter@oracle.com>
Date:   Wed Jun 27 12:05:21 2012 +0300

    isci: add a couple __iomem annotations
    
    These are __iomem.  Sparse complains if we don't have that.
    
    drivers/scsi/isci/phy.c +149 70: warning:
            incorrect type in initializer (different address spaces)
    
    Signed-off-by: Dan Carpenter <dan.carpenter@oracle.com>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/drivers/scsi/isci/host.c b/drivers/scsi/isci/host.c
index 45385f531649..b425ed523ccc 100644
--- a/drivers/scsi/isci/host.c
+++ b/drivers/scsi/isci/host.c
@@ -1973,7 +1973,7 @@ static void sci_controller_afe_initialization(struct isci_host *ihost)
 	}
 
 	for (phy_id = 0; phy_id < SCI_MAX_PHYS; phy_id++) {
-		struct scu_afe_transceiver *xcvr = &afe->scu_afe_xcvr[phy_id];
+		struct scu_afe_transceiver __iomem *xcvr = &afe->scu_afe_xcvr[phy_id];
 		const struct sci_phy_oem_params *oem_phy = &oem->phys[phy_id];
 		int cable_length_long =
 			is_long_cable(phy_id, cable_selection_mask);

commit f8381807ebdfffa34c2c5aa38eda33673d1a7adf
Author: Jeff Skirvin <jeffrey.d.skirvin@intel.com>
Date:   Sun Mar 4 12:44:53 2012 +0000

    isci: Remove obviated host callback list.
    
    Since the callbacks to libsas now occur under scic_lock, there is no
    longer any reason to save the completed requests in a separate list
    for completion to libsas.
    
    Signed-off-by: Jeff Skirvin <jeffrey.d.skirvin@intel.com>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/drivers/scsi/isci/host.c b/drivers/scsi/isci/host.c
index ef2790faeab8..45385f531649 100644
--- a/drivers/scsi/isci/host.c
+++ b/drivers/scsi/isci/host.c
@@ -1077,6 +1077,32 @@ static void sci_controller_completion_handler(struct isci_host *ihost)
 	writel(0, &ihost->smu_registers->interrupt_mask);
 }
 
+void ireq_done(struct isci_host *ihost, struct isci_request *ireq, struct sas_task *task)
+{
+	task->lldd_task = NULL;
+	if (!test_bit(IREQ_ABORT_PATH_ACTIVE, &ireq->flags) &&
+	    !(task->task_state_flags & SAS_TASK_STATE_ABORTED)) {
+		if (test_bit(IREQ_COMPLETE_IN_TARGET, &ireq->flags)) {
+			/* Normal notification (task_done) */
+			dev_dbg(&ihost->pdev->dev,
+				"%s: Normal - ireq/task = %p/%p\n",
+				__func__, ireq, task);
+
+			task->task_done(task);
+		} else {
+			dev_dbg(&ihost->pdev->dev,
+				"%s: Error - ireq/task = %p/%p\n",
+				__func__, ireq, task);
+
+			sas_task_abort(task);
+		}
+	}
+	if (test_and_clear_bit(IREQ_ABORT_PATH_ACTIVE, &ireq->flags))
+		wake_up_all(&ihost->eventq);
+
+	if (!test_bit(IREQ_NO_AUTO_FREE_TAG, &ireq->flags))
+		isci_free_tag(ihost, ireq->io_tag);
+}
 /**
  * isci_host_completion_routine() - This function is the delayed service
  *    routine that calls the sci core library's completion handler. It's
@@ -1088,62 +1114,10 @@ static void sci_controller_completion_handler(struct isci_host *ihost)
 void isci_host_completion_routine(unsigned long data)
 {
 	struct isci_host *ihost = (struct isci_host *)data;
-	struct list_head    completed_request_list;
-	struct list_head    *current_position;
-	struct list_head    *next_position;
-	struct isci_request *request;
-	struct sas_task     *task;
 	u16 active;
 
-	INIT_LIST_HEAD(&completed_request_list);
-
 	spin_lock_irq(&ihost->scic_lock);
-
 	sci_controller_completion_handler(ihost);
-
-	/* Take the lists of completed I/Os from the host. */
-	list_splice_init(&ihost->requests_to_complete,
-			 &completed_request_list);
-
-	/* Process any completions in the list. */
-	list_for_each_safe(current_position, next_position,
-			   &completed_request_list) {
-
-		request = list_entry(current_position, struct isci_request,
-				     completed_node);
-		task = isci_request_access_task(request);
-
-		/* Return the task to libsas */
-		if (task != NULL) {
-
-			task->lldd_task = NULL;
-			if (!test_bit(IREQ_ABORT_PATH_ACTIVE, &request->flags) &&
-			    !(task->task_state_flags & SAS_TASK_STATE_ABORTED)) {
-				if (test_bit(IREQ_COMPLETE_IN_TARGET,
-					     &request->flags)) {
-
-					/* Normal notification (task_done) */
-					dev_dbg(&ihost->pdev->dev, "%s: Normal"
-						" - request/task = %p/%p\n",
-						__func__, request, task);
-
-					task->task_done(task);
-				} else {
-					dev_warn(&ihost->pdev->dev,
-						 "%s: Error - request/task"
-						 " = %p/%p\n",
-						 __func__, request, task);
-
-					sas_task_abort(task);
-				}
-			}
-		}
-		if (test_and_clear_bit(IREQ_ABORT_PATH_ACTIVE, &request->flags))
-			wake_up_all(&ihost->eventq);
-
-		if (!test_bit(IREQ_NO_AUTO_FREE_TAG, &request->flags))
-			isci_free_tag(ihost, request->io_tag);
-	}
 	spin_unlock_irq(&ihost->scic_lock);
 
 	/* the coalesence timeout doubles at each encoding step, so

commit 621120ca56850249554996c94efe75f8200a2cc0
Author: Jeff Skirvin <jeffrey.d.skirvin@intel.com>
Date:   Thu Mar 8 22:42:03 2012 -0800

    isci: Manage tag releases differently when aborting tasks.
    
    When an individual request is being terminated, the request's tag
    is managed in the terminate function.
    
    Signed-off-by: Jeff Skirvin <jeffrey.d.skirvin@intel.com>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/drivers/scsi/isci/host.c b/drivers/scsi/isci/host.c
index 53c3ad64c998..ef2790faeab8 100644
--- a/drivers/scsi/isci/host.c
+++ b/drivers/scsi/isci/host.c
@@ -1141,7 +1141,8 @@ void isci_host_completion_routine(unsigned long data)
 		if (test_and_clear_bit(IREQ_ABORT_PATH_ACTIVE, &request->flags))
 			wake_up_all(&ihost->eventq);
 
-		isci_free_tag(ihost, request->io_tag);
+		if (!test_bit(IREQ_NO_AUTO_FREE_TAG, &request->flags))
+			isci_free_tag(ihost, request->io_tag);
 	}
 	spin_unlock_irq(&ihost->scic_lock);
 

commit 033d19d298b4245da2d3d6c795ea97e419f9ac61
Author: Jeff Skirvin <jeffrey.d.skirvin@intel.com>
Date:   Thu Mar 8 22:42:03 2012 -0800

    isci: Callbacks to libsas occur under scic_lock and are synchronized.
    
    This patch changes the callback mechanism to libsas to only occur while
    the scic_lock is held; the abort path cleanup of I/Os also checks to make
    sure IREQ_ABORT_PATH_ACTIVE is clear before proceding.
    
    Signed-off-by: Jeff Skirvin <jeffrey.d.skirvin@intel.com>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/drivers/scsi/isci/host.c b/drivers/scsi/isci/host.c
index 25d537e2f5c4..53c3ad64c998 100644
--- a/drivers/scsi/isci/host.c
+++ b/drivers/scsi/isci/host.c
@@ -1105,8 +1105,6 @@ void isci_host_completion_routine(unsigned long data)
 	list_splice_init(&ihost->requests_to_complete,
 			 &completed_request_list);
 
-	spin_unlock_irq(&ihost->scic_lock);
-
 	/* Process any completions in the list. */
 	list_for_each_safe(current_position, next_position,
 			   &completed_request_list) {
@@ -1115,7 +1113,6 @@ void isci_host_completion_routine(unsigned long data)
 				     completed_node);
 		task = isci_request_access_task(request);
 
-
 		/* Return the task to libsas */
 		if (task != NULL) {
 
@@ -1141,11 +1138,12 @@ void isci_host_completion_routine(unsigned long data)
 				}
 			}
 		}
+		if (test_and_clear_bit(IREQ_ABORT_PATH_ACTIVE, &request->flags))
+			wake_up_all(&ihost->eventq);
 
-		spin_lock_irq(&ihost->scic_lock);
 		isci_free_tag(ihost, request->io_tag);
-		spin_unlock_irq(&ihost->scic_lock);
 	}
+	spin_unlock_irq(&ihost->scic_lock);
 
 	/* the coalesence timeout doubles at each encoding step, so
 	 * update it based on the ilog2 value of the outstanding requests
@@ -2703,8 +2701,6 @@ enum sci_status sci_controller_complete_io(struct isci_host *ihost,
 
 		index = ISCI_TAG_TCI(ireq->io_tag);
 		clear_bit(IREQ_ACTIVE, &ireq->flags);
-		if (test_bit(IREQ_ABORT_PATH_ACTIVE, &ireq->flags))
-			wake_up_all(&ihost->eventq);
 		return SCI_SUCCESS;
 	default:
 		dev_warn(&ihost->pdev->dev, "%s invalid state: %d\n",

commit 14aaa9f0a318bd04cbb9d822524b817e95d8b343
Author: Jeff Skirvin <jeffrey.d.skirvin@intel.com>
Date:   Thu Mar 8 22:41:54 2012 -0800

    isci: Redesign device suspension, abort, cleanup.
    
    This commit changes the means by which outstanding I/Os are handled
    for cleanup.
    The likelihood is that this commit will be broken into smaller pieces,
    however that will be a later revision.  Among the changes:
    
    - All completion structures have been removed from the tmf and
    abort paths.
    - Now using one completed I/O list, with the I/O completed in host bit being
    used to select error or normal callback paths.
    
    Signed-off-by: Jeff Skirvin <jeffrey.d.skirvin@intel.com>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/drivers/scsi/isci/host.c b/drivers/scsi/isci/host.c
index d241b5722eb3..25d537e2f5c4 100644
--- a/drivers/scsi/isci/host.c
+++ b/drivers/scsi/isci/host.c
@@ -1089,33 +1089,25 @@ void isci_host_completion_routine(unsigned long data)
 {
 	struct isci_host *ihost = (struct isci_host *)data;
 	struct list_head    completed_request_list;
-	struct list_head    errored_request_list;
 	struct list_head    *current_position;
 	struct list_head    *next_position;
 	struct isci_request *request;
-	struct isci_request *next_request;
 	struct sas_task     *task;
 	u16 active;
 
 	INIT_LIST_HEAD(&completed_request_list);
-	INIT_LIST_HEAD(&errored_request_list);
 
 	spin_lock_irq(&ihost->scic_lock);
 
 	sci_controller_completion_handler(ihost);
 
 	/* Take the lists of completed I/Os from the host. */
-
 	list_splice_init(&ihost->requests_to_complete,
 			 &completed_request_list);
 
-	/* Take the list of errored I/Os from the host. */
-	list_splice_init(&ihost->requests_to_errorback,
-			 &errored_request_list);
-
 	spin_unlock_irq(&ihost->scic_lock);
 
-	/* Process any completions in the lists. */
+	/* Process any completions in the list. */
 	list_for_each_safe(current_position, next_position,
 			   &completed_request_list) {
 
@@ -1123,23 +1115,30 @@ void isci_host_completion_routine(unsigned long data)
 				     completed_node);
 		task = isci_request_access_task(request);
 
-		/* Normal notification (task_done) */
-		dev_dbg(&ihost->pdev->dev,
-			"%s: Normal - request/task = %p/%p\n",
-			__func__,
-			request,
-			task);
 
 		/* Return the task to libsas */
 		if (task != NULL) {
 
 			task->lldd_task = NULL;
-			if (!(task->task_state_flags & SAS_TASK_STATE_ABORTED)) {
-
-				/* If the task is already in the abort path,
-				* the task_done callback cannot be called.
-				*/
-				task->task_done(task);
+			if (!test_bit(IREQ_ABORT_PATH_ACTIVE, &request->flags) &&
+			    !(task->task_state_flags & SAS_TASK_STATE_ABORTED)) {
+				if (test_bit(IREQ_COMPLETE_IN_TARGET,
+					     &request->flags)) {
+
+					/* Normal notification (task_done) */
+					dev_dbg(&ihost->pdev->dev, "%s: Normal"
+						" - request/task = %p/%p\n",
+						__func__, request, task);
+
+					task->task_done(task);
+				} else {
+					dev_warn(&ihost->pdev->dev,
+						 "%s: Error - request/task"
+						 " = %p/%p\n",
+						 __func__, request, task);
+
+					sas_task_abort(task);
+				}
 			}
 		}
 
@@ -1147,44 +1146,6 @@ void isci_host_completion_routine(unsigned long data)
 		isci_free_tag(ihost, request->io_tag);
 		spin_unlock_irq(&ihost->scic_lock);
 	}
-	list_for_each_entry_safe(request, next_request, &errored_request_list,
-				 completed_node) {
-
-		task = isci_request_access_task(request);
-
-		/* Use sas_task_abort */
-		dev_warn(&ihost->pdev->dev,
-			 "%s: Error - request/task = %p/%p\n",
-			 __func__,
-			 request,
-			 task);
-
-		if (task != NULL) {
-
-			/* Put the task into the abort path if it's not there
-			 * already.
-			 */
-			if (!(task->task_state_flags & SAS_TASK_STATE_ABORTED))
-				sas_task_abort(task);
-
-		} else {
-			/* This is a case where the request has completed with a
-			 * status such that it needed further target servicing,
-			 * but the sas_task reference has already been removed
-			 * from the request.  Since it was errored, it was not
-			 * being aborted, so there is nothing to do except free
-			 * it.
-			 */
-
-			spin_lock_irq(&ihost->scic_lock);
-			/* Remove the request from the remote device's list
-			* of pending requests.
-			*/
-			list_del_init(&request->dev_node);
-			isci_free_tag(ihost, request->io_tag);
-			spin_unlock_irq(&ihost->scic_lock);
-		}
-	}
 
 	/* the coalesence timeout doubles at each encoding step, so
 	 * update it based on the ilog2 value of the outstanding requests
@@ -2345,7 +2306,6 @@ static int sci_controller_dma_alloc(struct isci_host *ihost)
 
 		ireq->tc = &ihost->task_context_table[i];
 		ireq->owning_controller = ihost;
-		spin_lock_init(&ireq->state_lock);
 		ireq->request_daddr = dma;
 		ireq->isci_host = ihost;
 		ihost->reqs[i] = ireq;
@@ -2697,6 +2657,10 @@ enum sci_status sci_controller_terminate_request(struct isci_host *ihost,
 		return SCI_FAILURE_INVALID_STATE;
 	}
 	status = sci_io_request_terminate(ireq);
+
+	dev_dbg(&ihost->pdev->dev, "%s: status=%d; ireq=%p; flags=%lx\n",
+		__func__, status, ireq, ireq->flags);
+
 	if ((status == SCI_SUCCESS) &&
 	    !test_bit(IREQ_PENDING_ABORT, &ireq->flags) &&
 	    !test_and_set_bit(IREQ_TC_ABORT_POSTED, &ireq->flags)) {
@@ -2739,6 +2703,8 @@ enum sci_status sci_controller_complete_io(struct isci_host *ihost,
 
 		index = ISCI_TAG_TCI(ireq->io_tag);
 		clear_bit(IREQ_ACTIVE, &ireq->flags);
+		if (test_bit(IREQ_ABORT_PATH_ACTIVE, &ireq->flags))
+			wake_up_all(&ihost->eventq);
 		return SCI_SUCCESS;
 	default:
 		dev_warn(&ihost->pdev->dev, "%s invalid state: %d\n",

commit 726980d56908f2e230624394f03743689db3110c
Author: Jeff Skirvin <jeffrey.d.skirvin@intel.com>
Date:   Thu Mar 8 22:41:50 2012 -0800

    isci: Terminate outstanding TCs on TX/RX RNC suspensions.
    
    TCs must only be terminated when RNCs are suspended.
    
    Signed-off-by: Jeff Skirvin <jeffrey.d.skirvin@intel.com>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/drivers/scsi/isci/host.c b/drivers/scsi/isci/host.c
index 5832b13e7b07..d241b5722eb3 100644
--- a/drivers/scsi/isci/host.c
+++ b/drivers/scsi/isci/host.c
@@ -2696,18 +2696,18 @@ enum sci_status sci_controller_terminate_request(struct isci_host *ihost,
 			 __func__, ihost->sm.current_state_id);
 		return SCI_FAILURE_INVALID_STATE;
 	}
-
 	status = sci_io_request_terminate(ireq);
-	if (status != SCI_SUCCESS)
-		return status;
-
-	/*
-	 * Utilize the original post context command and or in the POST_TC_ABORT
-	 * request sub-type.
-	 */
-	sci_controller_post_request(ihost,
-				    ireq->post_context | SCU_CONTEXT_COMMAND_REQUEST_POST_TC_ABORT);
-	return SCI_SUCCESS;
+	if ((status == SCI_SUCCESS) &&
+	    !test_bit(IREQ_PENDING_ABORT, &ireq->flags) &&
+	    !test_and_set_bit(IREQ_TC_ABORT_POSTED, &ireq->flags)) {
+		/* Utilize the original post context command and or in the
+		 * POST_TC_ABORT request sub-type.
+		 */
+		sci_controller_post_request(
+			ihost, ireq->post_context |
+				SCU_CONTEXT_COMMAND_REQUEST_POST_TC_ABORT);
+	}
+	return status;
 }
 
 /**

commit 2396a2650a5a39634e3ad6b29e1104944e5ab88f
Author: Dan Williams <dan.j.williams@intel.com>
Date:   Thu Mar 1 17:06:24 2012 -0800

    isci: fix interrupt disable
    
    There is a (dubious?) lost irq workaround in sci_controller_isr() that
    effectively nullifies attempts to disable interrupts.  Until the
    workaround can be re-evaluated add some infrastructure to prevent the
    interrupt handler from inadvertantly re-enabling interrupts.
    
    The failure mode was interrupts continuing to run after the driver had
    been removed and its iomappings torn down.
    
    Reported-by: Jacek Danecki <jacek.danecki@intel.com>
    Tested-by: Jacek Danecki <jacek.danecki@intel.com>
    [richard: clear remaining interrupts at the end of reset]
    Acked-by: Richard Boyd <richard.g.boyd@intel.com>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/drivers/scsi/isci/host.c b/drivers/scsi/isci/host.c
index 577a8369274c..5832b13e7b07 100644
--- a/drivers/scsi/isci/host.c
+++ b/drivers/scsi/isci/host.c
@@ -192,22 +192,27 @@ static bool sci_controller_completion_queue_has_entries(struct isci_host *ihost)
 
 static bool sci_controller_isr(struct isci_host *ihost)
 {
-	if (sci_controller_completion_queue_has_entries(ihost)) {
+	if (sci_controller_completion_queue_has_entries(ihost))
 		return true;
-	} else {
-		/*
-		 * we have a spurious interrupt it could be that we have already
-		 * emptied the completion queue from a previous interrupt */
-		writel(SMU_ISR_COMPLETION, &ihost->smu_registers->interrupt_status);
 
-		/*
-		 * There is a race in the hardware that could cause us not to be notified
-		 * of an interrupt completion if we do not take this step.  We will mask
-		 * then unmask the interrupts so if there is another interrupt pending
-		 * the clearing of the interrupt source we get the next interrupt message. */
+	/* we have a spurious interrupt it could be that we have already
+	 * emptied the completion queue from a previous interrupt
+	 * FIXME: really!?
+	 */
+	writel(SMU_ISR_COMPLETION, &ihost->smu_registers->interrupt_status);
+
+	/* There is a race in the hardware that could cause us not to be
+	 * notified of an interrupt completion if we do not take this
+	 * step.  We will mask then unmask the interrupts so if there is
+	 * another interrupt pending the clearing of the interrupt
+	 * source we get the next interrupt message.
+	 */
+	spin_lock(&ihost->scic_lock);
+	if (test_bit(IHOST_IRQ_ENABLED, &ihost->flags)) {
 		writel(0xFF000000, &ihost->smu_registers->interrupt_mask);
 		writel(0, &ihost->smu_registers->interrupt_mask);
 	}
+	spin_unlock(&ihost->scic_lock);
 
 	return false;
 }
@@ -698,14 +703,15 @@ static u32 sci_controller_get_suggested_start_timeout(struct isci_host *ihost)
 
 static void sci_controller_enable_interrupts(struct isci_host *ihost)
 {
-	BUG_ON(ihost->smu_registers == NULL);
+	set_bit(IHOST_IRQ_ENABLED, &ihost->flags);
 	writel(0, &ihost->smu_registers->interrupt_mask);
 }
 
 void sci_controller_disable_interrupts(struct isci_host *ihost)
 {
-	BUG_ON(ihost->smu_registers == NULL);
+	clear_bit(IHOST_IRQ_ENABLED, &ihost->flags);
 	writel(0xffffffff, &ihost->smu_registers->interrupt_mask);
+	readl(&ihost->smu_registers->interrupt_mask); /* flush */
 }
 
 static void sci_controller_enable_port_task_scheduler(struct isci_host *ihost)
@@ -1318,7 +1324,9 @@ void isci_host_deinit(struct isci_host *ihost)
 	 */
 	writel(0, &ihost->scu_registers->peg0.sgpio.interface_control);
 
+	spin_lock_irq(&ihost->scic_lock);
 	sci_controller_reset(ihost);
+	spin_unlock_irq(&ihost->scic_lock);
 
 	/* Cancel any/all outstanding port timers */
 	for (i = 0; i < ihost->logical_port_entries; i++) {
@@ -1605,6 +1613,9 @@ static void sci_controller_reset_hardware(struct isci_host *ihost)
 
 	/* The write to the UFQGP clears the UFQPR */
 	writel(0, &ihost->scu_registers->sdma.unsolicited_frame_get_pointer);
+
+	/* clear all interrupts */
+	writel(~SMU_INTERRUPT_STATUS_RESERVED_MASK, &ihost->smu_registers->interrupt_status);
 }
 
 static void sci_controller_resetting_state_enter(struct sci_base_state_machine *sm)
@@ -2391,7 +2402,9 @@ int isci_host_init(struct isci_host *ihost)
 	int i, err;
 	enum sci_status status;
 
+	spin_lock_irq(&ihost->scic_lock);
 	status = sci_controller_construct(ihost, scu_base(ihost), smu_base(ihost));
+	spin_unlock_irq(&ihost->scic_lock);
 	if (status != SCI_SUCCESS) {
 		dev_err(&ihost->pdev->dev,
 			"%s: sci_controller_construct failed - status = %x\n",

commit 50a92d93148ec073efd2456b007e04ecae452086
Author: Dan Williams <dan.j.williams@intel.com>
Date:   Wed Feb 29 01:07:56 2012 -0800

    isci: fix 'link-up' events occur after 'start-complete'
    
    The call to wait_for_start() is meant to ensure that all links have been
    given a chance to come up before letting the kernel proceed with
    probing.  However, the implementation is not correctly syncing with the
    port configuration agent.  In the MPC case the ports are hard-coded, in
    the APC case we need to wait for the port-configuration to form ports
    from the started phys.
    
    Towards that end increase the timeout for the APC agent to form ports,
    and delay start complete until all phys are out of link-training.
    
    Cc: <stable@vger.kernel.org>
    Cc: Richard Boyd <richard.g.boyd@intel.com>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/drivers/scsi/isci/host.c b/drivers/scsi/isci/host.c
index 95c3da66ea4b..577a8369274c 100644
--- a/drivers/scsi/isci/host.c
+++ b/drivers/scsi/isci/host.c
@@ -816,7 +816,7 @@ static void sci_controller_initialize_unsolicited_frame_queue(struct isci_host *
 	       &ihost->scu_registers->sdma.unsolicited_frame_put_pointer);
 }
 
-static void sci_controller_transition_to_ready(struct isci_host *ihost, enum sci_status status)
+void sci_controller_transition_to_ready(struct isci_host *ihost, enum sci_status status)
 {
 	if (ihost->sm.current_state_id == SCIC_STARTING) {
 		/*
@@ -843,6 +843,7 @@ static bool is_phy_starting(struct isci_phy *iphy)
 	case SCI_PHY_SUB_AWAIT_SATA_POWER:
 	case SCI_PHY_SUB_AWAIT_SATA_PHY_EN:
 	case SCI_PHY_SUB_AWAIT_SATA_SPEED_EN:
+	case SCI_PHY_SUB_AWAIT_OSSP_EN:
 	case SCI_PHY_SUB_AWAIT_SIG_FIS_UF:
 	case SCI_PHY_SUB_FINAL:
 		return true;
@@ -851,6 +852,39 @@ static bool is_phy_starting(struct isci_phy *iphy)
 	}
 }
 
+bool is_controller_start_complete(struct isci_host *ihost)
+{
+	int i;
+
+	for (i = 0; i < SCI_MAX_PHYS; i++) {
+		struct isci_phy *iphy = &ihost->phys[i];
+		u32 state = iphy->sm.current_state_id;
+
+		/* in apc mode we need to check every phy, in
+		 * mpc mode we only need to check phys that have
+		 * been configured into a port
+		 */
+		if (is_port_config_apc(ihost))
+			/* pass */;
+		else if (!phy_get_non_dummy_port(iphy))
+			continue;
+
+		/* The controller start operation is complete iff:
+		 * - all links have been given an opportunity to start
+		 * - have no indication of a connected device
+		 * - have an indication of a connected device and it has
+		 *   finished the link training process.
+		 */
+		if ((iphy->is_in_link_training == false && state == SCI_PHY_INITIAL) ||
+		    (iphy->is_in_link_training == false && state == SCI_PHY_STOPPED) ||
+		    (iphy->is_in_link_training == true && is_phy_starting(iphy)) ||
+		    (ihost->port_agent.phy_ready_mask != ihost->port_agent.phy_configured_mask))
+			return false;
+	}
+
+	return true;
+}
+
 /**
  * sci_controller_start_next_phy - start phy
  * @scic: controller
@@ -871,36 +905,7 @@ static enum sci_status sci_controller_start_next_phy(struct isci_host *ihost)
 		return status;
 
 	if (ihost->next_phy_to_start >= SCI_MAX_PHYS) {
-		bool is_controller_start_complete = true;
-		u32 state;
-		u8 index;
-
-		for (index = 0; index < SCI_MAX_PHYS; index++) {
-			iphy = &ihost->phys[index];
-			state = iphy->sm.current_state_id;
-
-			if (!phy_get_non_dummy_port(iphy))
-				continue;
-
-			/* The controller start operation is complete iff:
-			 * - all links have been given an opportunity to start
-			 * - have no indication of a connected device
-			 * - have an indication of a connected device and it has
-			 *   finished the link training process.
-			 */
-			if ((iphy->is_in_link_training == false && state == SCI_PHY_INITIAL) ||
-			    (iphy->is_in_link_training == false && state == SCI_PHY_STOPPED) ||
-			    (iphy->is_in_link_training == true && is_phy_starting(iphy)) ||
-			    (ihost->port_agent.phy_ready_mask != ihost->port_agent.phy_configured_mask)) {
-				is_controller_start_complete = false;
-				break;
-			}
-		}
-
-		/*
-		 * The controller has successfully finished the start process.
-		 * Inform the SCI Core user and transition to the READY state. */
-		if (is_controller_start_complete == true) {
+		if (is_controller_start_complete(ihost)) {
 			sci_controller_transition_to_ready(ihost, SCI_SUCCESS);
 			sci_del_timer(&ihost->phy_timer);
 			ihost->phy_startup_timer_pending = false;

commit eb608c3cb3f0a6b99252ea6a69fc0d2bbecf1f4f
Author: Dan Williams <dan.j.williams@intel.com>
Date:   Thu Feb 23 01:12:10 2012 -0800

    isci: fix controller stop
    
    1/ notify waiters when controller stop completes (fixes 10 second stall
       unloading the driver)
    2/ make sure phy stop is after port and device stop
    
    Cc: Richard Boyd <richard.g.boyd@intel.com>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/drivers/scsi/isci/host.c b/drivers/scsi/isci/host.c
index 0fe372f93289..95c3da66ea4b 100644
--- a/drivers/scsi/isci/host.c
+++ b/drivers/scsi/isci/host.c
@@ -1046,7 +1046,7 @@ void isci_host_scan_start(struct Scsi_Host *shost)
 	spin_unlock_irq(&ihost->scic_lock);
 }
 
-static void isci_host_stop_complete(struct isci_host *ihost, enum sci_status completion_status)
+static void isci_host_stop_complete(struct isci_host *ihost)
 {
 	sci_controller_disable_interrupts(ihost);
 	clear_bit(IHOST_STOP_PENDING, &ihost->flags);
@@ -1232,7 +1232,7 @@ static enum sci_status sci_controller_reset(struct isci_host *ihost)
 	switch (ihost->sm.current_state_id) {
 	case SCIC_RESET:
 	case SCIC_READY:
-	case SCIC_STOPPED:
+	case SCIC_STOPPING:
 	case SCIC_FAILED:
 		/*
 		 * The reset operation is not a graceful cleanup, just
@@ -1247,6 +1247,44 @@ static enum sci_status sci_controller_reset(struct isci_host *ihost)
 	}
 }
 
+static enum sci_status sci_controller_stop_phys(struct isci_host *ihost)
+{
+	u32 index;
+	enum sci_status status;
+	enum sci_status phy_status;
+
+	status = SCI_SUCCESS;
+
+	for (index = 0; index < SCI_MAX_PHYS; index++) {
+		phy_status = sci_phy_stop(&ihost->phys[index]);
+
+		if (phy_status != SCI_SUCCESS &&
+		    phy_status != SCI_FAILURE_INVALID_STATE) {
+			status = SCI_FAILURE;
+
+			dev_warn(&ihost->pdev->dev,
+				 "%s: Controller stop operation failed to stop "
+				 "phy %d because of status %d.\n",
+				 __func__,
+				 ihost->phys[index].phy_index, phy_status);
+		}
+	}
+
+	return status;
+}
+
+
+/**
+ * isci_host_deinit - shutdown frame reception and dma
+ * @ihost: host to take down
+ *
+ * This is called in either the driver shutdown or the suspend path.  In
+ * the shutdown case libsas went through port teardown and normal device
+ * removal (i.e. physical links stayed up to service scsi_device removal
+ * commands).  In the suspend case we disable the hardware without
+ * notifying libsas of the link down events since we want libsas to
+ * remember the domain across the suspend/resume cycle
+ */
 void isci_host_deinit(struct isci_host *ihost)
 {
 	int i;
@@ -1255,16 +1293,6 @@ void isci_host_deinit(struct isci_host *ihost)
 	for (i = 0; i < isci_gpio_count(ihost); i++)
 		writel(SGPIO_HW_CONTROL, &ihost->scu_registers->peg0.sgpio.output_data_select[i]);
 
-	for (i = 0; i < SCI_MAX_PORTS; i++) {
-		struct isci_port *iport = &ihost->ports[i];
-		struct isci_remote_device *idev, *d;
-
-		list_for_each_entry_safe(idev, d, &iport->remote_dev_list, node) {
-			if (test_bit(IDEV_ALLOCATED, &idev->flags))
-				isci_remote_device_stop(ihost, idev);
-		}
-	}
-
 	set_bit(IHOST_STOP_PENDING, &ihost->flags);
 
 	spin_lock_irq(&ihost->scic_lock);
@@ -1273,6 +1301,13 @@ void isci_host_deinit(struct isci_host *ihost)
 
 	wait_for_stop(ihost);
 
+	/* phy stop is after controller stop to allow port and device to
+	 * go idle before shutting down the phys, but the expectation is
+	 * that i/o has been shut off well before we reach this
+	 * function.
+	 */
+	sci_controller_stop_phys(ihost);
+
 	/* disable sgpio: where the above wait should give time for the
 	 * enclosure to sample the gpios going inactive
 	 */
@@ -1476,32 +1511,6 @@ static void sci_controller_ready_state_exit(struct sci_base_state_machine *sm)
 	sci_controller_set_interrupt_coalescence(ihost, 0, 0);
 }
 
-static enum sci_status sci_controller_stop_phys(struct isci_host *ihost)
-{
-	u32 index;
-	enum sci_status status;
-	enum sci_status phy_status;
-
-	status = SCI_SUCCESS;
-
-	for (index = 0; index < SCI_MAX_PHYS; index++) {
-		phy_status = sci_phy_stop(&ihost->phys[index]);
-
-		if (phy_status != SCI_SUCCESS &&
-		    phy_status != SCI_FAILURE_INVALID_STATE) {
-			status = SCI_FAILURE;
-
-			dev_warn(&ihost->pdev->dev,
-				 "%s: Controller stop operation failed to stop "
-				 "phy %d because of status %d.\n",
-				 __func__,
-				 ihost->phys[index].phy_index, phy_status);
-		}
-	}
-
-	return status;
-}
-
 static enum sci_status sci_controller_stop_ports(struct isci_host *ihost)
 {
 	u32 index;
@@ -1561,10 +1570,11 @@ static void sci_controller_stopping_state_enter(struct sci_base_state_machine *s
 {
 	struct isci_host *ihost = container_of(sm, typeof(*ihost), sm);
 
-	/* Stop all of the components for this controller */
-	sci_controller_stop_phys(ihost);
-	sci_controller_stop_ports(ihost);
 	sci_controller_stop_devices(ihost);
+	sci_controller_stop_ports(ihost);
+
+	if (!sci_controller_has_remote_devices_stopping(ihost))
+		isci_host_stop_complete(ihost);
 }
 
 static void sci_controller_stopping_state_exit(struct sci_base_state_machine *sm)
@@ -1621,7 +1631,6 @@ static const struct sci_base_state sci_controller_state_table[] = {
 		.enter_state = sci_controller_stopping_state_enter,
 		.exit_state = sci_controller_stopping_state_exit,
 	},
-	[SCIC_STOPPED] = {},
 	[SCIC_FAILED] = {}
 };
 
@@ -1641,7 +1650,7 @@ static void controller_timeout(unsigned long data)
 		sci_controller_transition_to_ready(ihost, SCI_FAILURE_TIMEOUT);
 	else if (sm->current_state_id == SCIC_STOPPING) {
 		sci_change_state(sm, SCIC_FAILED);
-		isci_host_stop_complete(ihost, SCI_FAILURE_TIMEOUT);
+		isci_host_stop_complete(ihost);
 	} else	/* / @todo Now what do we want to do in this case? */
 		dev_err(&ihost->pdev->dev,
 			"%s: Controller timer fired when controller was not "
@@ -2452,7 +2461,7 @@ void sci_controller_link_down(struct isci_host *ihost, struct isci_port *iport,
 	}
 }
 
-static bool sci_controller_has_remote_devices_stopping(struct isci_host *ihost)
+bool sci_controller_has_remote_devices_stopping(struct isci_host *ihost)
 {
 	u32 index;
 
@@ -2478,7 +2487,7 @@ void sci_controller_remote_device_stopped(struct isci_host *ihost,
 	}
 
 	if (!sci_controller_has_remote_devices_stopping(ihost))
-		sci_change_state(&ihost->sm, SCIC_STOPPED);
+		isci_host_stop_complete(ihost);
 }
 
 void sci_controller_post_request(struct isci_host *ihost, u32 request)

commit abec912d71c44bbd642ce12ad98aab76f5a53163
Author: Dan Williams <dan.j.williams@intel.com>
Date:   Wed Feb 15 13:58:42 2012 -0800

    isci: refactor initialization for S3/S4
    
    Based on an original implementation by Ed Nadolski and Artur Wojcik
    
    In preparation for S3/S4 support refactor initialization so that
    driver-load and resume-from-suspend can share the common init path of
    isci_host_init().  Organize the initialization into objects that are
    self-contained to the driver (initialized by isci_host_init) versus
    those that have some upward registration (initialized at allocation time
    asd_sas_phy, asd_sas_port, dma allocations).  The largest change is
    moving the the validation of the oem and module parameters from
    isci_host_init() to isci_host_alloc().
    
    The S3/S4 approach being taken is that libsas will be tasked with
    remembering the state of the domain and the lldd is free to be
    forgetful.  In the case of isci we'll just re-init using a subset of the
    normal driver load path.
    
    [clean up some unused / mis-indented function definitions in host.h]
    
    Signed-off-by: Ed Nadolski <edmund.nadolski@intel.com>
    Signed-off-by: Artur Wojcik <artur.wojcik@intel.com>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/drivers/scsi/isci/host.c b/drivers/scsi/isci/host.c
index bbec1982d07f..0fe372f93289 100644
--- a/drivers/scsi/isci/host.c
+++ b/drivers/scsi/isci/host.c
@@ -1074,7 +1074,7 @@ static void sci_controller_completion_handler(struct isci_host *ihost)
  * @data: This parameter specifies the ISCI host object
  *
  */
-static void isci_host_completion_routine(unsigned long data)
+void isci_host_completion_routine(unsigned long data)
 {
 	struct isci_host *ihost = (struct isci_host *)data;
 	struct list_head    completed_request_list;
@@ -1317,29 +1317,6 @@ static void __iomem *smu_base(struct isci_host *isci_host)
 	return pcim_iomap_table(pdev)[SCI_SMU_BAR * 2] + SCI_SMU_BAR_SIZE * id;
 }
 
-static void isci_user_parameters_get(struct sci_user_parameters *u)
-{
-	int i;
-
-	for (i = 0; i < SCI_MAX_PHYS; i++) {
-		struct sci_phy_user_params *u_phy = &u->phys[i];
-
-		u_phy->max_speed_generation = phy_gen;
-
-		/* we are not exporting these for now */
-		u_phy->align_insertion_frequency = 0x7f;
-		u_phy->in_connection_align_insertion_frequency = 0xff;
-		u_phy->notify_enable_spin_up_insertion_frequency = 0x33;
-	}
-
-	u->stp_inactivity_timeout = stp_inactive_to;
-	u->ssp_inactivity_timeout = ssp_inactive_to;
-	u->stp_max_occupancy_timeout = stp_max_occ_to;
-	u->ssp_max_occupancy_timeout = ssp_max_occ_to;
-	u->no_outbound_task_timeout = no_outbound_task_to;
-	u->max_concurr_spinup = max_concurr_spinup;
-}
-
 static void sci_controller_initial_state_enter(struct sci_base_state_machine *sm)
 {
 	struct isci_host *ihost = container_of(sm, typeof(*ihost), sm);
@@ -1648,55 +1625,6 @@ static const struct sci_base_state sci_controller_state_table[] = {
 	[SCIC_FAILED] = {}
 };
 
-static void sci_controller_set_default_config_parameters(struct isci_host *ihost)
-{
-	/* these defaults are overridden by the platform / firmware */
-	u16 index;
-
-	/* Default to APC mode. */
-	ihost->oem_parameters.controller.mode_type = SCIC_PORT_AUTOMATIC_CONFIGURATION_MODE;
-
-	/* Default to APC mode. */
-	ihost->oem_parameters.controller.max_concurr_spin_up = 1;
-
-	/* Default to no SSC operation. */
-	ihost->oem_parameters.controller.do_enable_ssc = false;
-
-	/* Default to short cables on all phys. */
-	ihost->oem_parameters.controller.cable_selection_mask = 0;
-
-	/* Initialize all of the port parameter information to narrow ports. */
-	for (index = 0; index < SCI_MAX_PORTS; index++) {
-		ihost->oem_parameters.ports[index].phy_mask = 0;
-	}
-
-	/* Initialize all of the phy parameter information. */
-	for (index = 0; index < SCI_MAX_PHYS; index++) {
-		/* Default to 3G (i.e. Gen 2). */
-		ihost->user_parameters.phys[index].max_speed_generation =
-			SCIC_SDS_PARM_GEN2_SPEED;
-
-		/* the frequencies cannot be 0 */
-		ihost->user_parameters.phys[index].align_insertion_frequency = 0x7f;
-		ihost->user_parameters.phys[index].in_connection_align_insertion_frequency = 0xff;
-		ihost->user_parameters.phys[index].notify_enable_spin_up_insertion_frequency = 0x33;
-
-		/*
-		 * Previous Vitesse based expanders had a arbitration issue that
-		 * is worked around by having the upper 32-bits of SAS address
-		 * with a value greater then the Vitesse company identifier.
-		 * Hence, usage of 0x5FCFFFFF. */
-		ihost->oem_parameters.phys[index].sas_address.low = 0x1 + ihost->id;
-		ihost->oem_parameters.phys[index].sas_address.high = 0x5FCFFFFF;
-	}
-
-	ihost->user_parameters.stp_inactivity_timeout = 5;
-	ihost->user_parameters.ssp_inactivity_timeout = 5;
-	ihost->user_parameters.stp_max_occupancy_timeout = 5;
-	ihost->user_parameters.ssp_max_occupancy_timeout = 20;
-	ihost->user_parameters.no_outbound_task_timeout = 2;
-}
-
 static void controller_timeout(unsigned long data)
 {
 	struct sci_timer *tmr = (struct sci_timer *)data;
@@ -1753,9 +1681,6 @@ static enum sci_status sci_controller_construct(struct isci_host *ihost,
 
 	sci_init_timer(&ihost->timer, controller_timeout);
 
-	/* Initialize the User and OEM parameters to default values. */
-	sci_controller_set_default_config_parameters(ihost);
-
 	return sci_controller_reset(ihost);
 }
 
@@ -1835,27 +1760,6 @@ int sci_oem_parameters_validate(struct sci_oem_params *oem, u8 version)
 	return 0;
 }
 
-static enum sci_status sci_oem_parameters_set(struct isci_host *ihost)
-{
-	u32 state = ihost->sm.current_state_id;
-	struct isci_pci_info *pci_info = to_pci_info(ihost->pdev);
-
-	if (state == SCIC_RESET ||
-	    state == SCIC_INITIALIZING ||
-	    state == SCIC_INITIALIZED) {
-		u8 oem_version = pci_info->orom ? pci_info->orom->hdr.version :
-			ISCI_ROM_VER_1_0;
-
-		if (sci_oem_parameters_validate(&ihost->oem_parameters,
-						oem_version))
-			return SCI_FAILURE_INVALID_PARAMETER_VALUE;
-
-		return SCI_SUCCESS;
-	}
-
-	return SCI_FAILURE_INVALID_STATE;
-}
-
 static u8 max_spin_up(struct isci_host *ihost)
 {
 	if (ihost->user_parameters.max_concurr_spinup)
@@ -2372,96 +2276,77 @@ static enum sci_status sci_controller_initialize(struct isci_host *ihost)
 	return result;
 }
 
-static enum sci_status sci_user_parameters_set(struct isci_host *ihost,
-					       struct sci_user_parameters *sci_parms)
-{
-	u32 state = ihost->sm.current_state_id;
-
-	if (state == SCIC_RESET ||
-	    state == SCIC_INITIALIZING ||
-	    state == SCIC_INITIALIZED) {
-		u16 index;
-
-		/*
-		 * Validate the user parameters.  If they are not legal, then
-		 * return a failure.
-		 */
-		for (index = 0; index < SCI_MAX_PHYS; index++) {
-			struct sci_phy_user_params *user_phy;
-
-			user_phy = &sci_parms->phys[index];
-
-			if (!((user_phy->max_speed_generation <=
-						SCIC_SDS_PARM_MAX_SPEED) &&
-			      (user_phy->max_speed_generation >
-						SCIC_SDS_PARM_NO_SPEED)))
-				return SCI_FAILURE_INVALID_PARAMETER_VALUE;
-
-			if (user_phy->in_connection_align_insertion_frequency <
-					3)
-				return SCI_FAILURE_INVALID_PARAMETER_VALUE;
-
-			if ((user_phy->in_connection_align_insertion_frequency <
-						3) ||
-			    (user_phy->align_insertion_frequency == 0) ||
-			    (user_phy->
-				notify_enable_spin_up_insertion_frequency ==
-						0))
-				return SCI_FAILURE_INVALID_PARAMETER_VALUE;
-		}
-
-		if ((sci_parms->stp_inactivity_timeout == 0) ||
-		    (sci_parms->ssp_inactivity_timeout == 0) ||
-		    (sci_parms->stp_max_occupancy_timeout == 0) ||
-		    (sci_parms->ssp_max_occupancy_timeout == 0) ||
-		    (sci_parms->no_outbound_task_timeout == 0))
-			return SCI_FAILURE_INVALID_PARAMETER_VALUE;
-
-		memcpy(&ihost->user_parameters, sci_parms, sizeof(*sci_parms));
-
-		return SCI_SUCCESS;
-	}
-
-	return SCI_FAILURE_INVALID_STATE;
-}
-
-static int sci_controller_mem_init(struct isci_host *ihost)
+static int sci_controller_dma_alloc(struct isci_host *ihost)
 {
 	struct device *dev = &ihost->pdev->dev;
-	dma_addr_t dma;
 	size_t size;
-	int err;
+	int i;
+
+	/* detect re-initialization */
+	if (ihost->completion_queue)
+		return 0;
 
 	size = SCU_MAX_COMPLETION_QUEUE_ENTRIES * sizeof(u32);
-	ihost->completion_queue = dmam_alloc_coherent(dev, size, &dma, GFP_KERNEL);
+	ihost->completion_queue = dmam_alloc_coherent(dev, size, &ihost->cq_dma,
+						      GFP_KERNEL);
 	if (!ihost->completion_queue)
 		return -ENOMEM;
 
-	writel(lower_32_bits(dma), &ihost->smu_registers->completion_queue_lower);
-	writel(upper_32_bits(dma), &ihost->smu_registers->completion_queue_upper);
-
 	size = ihost->remote_node_entries * sizeof(union scu_remote_node_context);
-	ihost->remote_node_context_table = dmam_alloc_coherent(dev, size, &dma,
+	ihost->remote_node_context_table = dmam_alloc_coherent(dev, size, &ihost->rnc_dma,
 							       GFP_KERNEL);
+
 	if (!ihost->remote_node_context_table)
 		return -ENOMEM;
 
-	writel(lower_32_bits(dma), &ihost->smu_registers->remote_node_context_lower);
-	writel(upper_32_bits(dma), &ihost->smu_registers->remote_node_context_upper);
-
 	size = ihost->task_context_entries * sizeof(struct scu_task_context),
-	ihost->task_context_table = dmam_alloc_coherent(dev, size, &dma, GFP_KERNEL);
+	ihost->task_context_table = dmam_alloc_coherent(dev, size, &ihost->tc_dma,
+							GFP_KERNEL);
 	if (!ihost->task_context_table)
 		return -ENOMEM;
 
-	ihost->task_context_dma = dma;
-	writel(lower_32_bits(dma), &ihost->smu_registers->host_task_table_lower);
-	writel(upper_32_bits(dma), &ihost->smu_registers->host_task_table_upper);
+	size = SCI_UFI_TOTAL_SIZE;
+	ihost->ufi_buf = dmam_alloc_coherent(dev, size, &ihost->ufi_dma, GFP_KERNEL);
+	if (!ihost->ufi_buf)
+		return -ENOMEM;
+
+	for (i = 0; i < SCI_MAX_IO_REQUESTS; i++) {
+		struct isci_request *ireq;
+		dma_addr_t dma;
+
+		ireq = dmam_alloc_coherent(dev, sizeof(*ireq), &dma, GFP_KERNEL);
+		if (!ireq)
+			return -ENOMEM;
+
+		ireq->tc = &ihost->task_context_table[i];
+		ireq->owning_controller = ihost;
+		spin_lock_init(&ireq->state_lock);
+		ireq->request_daddr = dma;
+		ireq->isci_host = ihost;
+		ihost->reqs[i] = ireq;
+	}
+
+	return 0;
+}
+
+static int sci_controller_mem_init(struct isci_host *ihost)
+{
+	int err = sci_controller_dma_alloc(ihost);
 
-	err = sci_unsolicited_frame_control_construct(ihost);
 	if (err)
 		return err;
 
+	writel(lower_32_bits(ihost->cq_dma), &ihost->smu_registers->completion_queue_lower);
+	writel(upper_32_bits(ihost->cq_dma), &ihost->smu_registers->completion_queue_upper);
+
+	writel(lower_32_bits(ihost->rnc_dma), &ihost->smu_registers->remote_node_context_lower);
+	writel(upper_32_bits(ihost->rnc_dma), &ihost->smu_registers->remote_node_context_upper);
+
+	writel(lower_32_bits(ihost->tc_dma), &ihost->smu_registers->host_task_table_lower);
+	writel(upper_32_bits(ihost->tc_dma), &ihost->smu_registers->host_task_table_upper);
+
+	sci_unsolicited_frame_control_construct(ihost);
+
 	/*
 	 * Inform the silicon as to the location of the UF headers and
 	 * address table.
@@ -2479,19 +2364,20 @@ static int sci_controller_mem_init(struct isci_host *ihost)
 	return 0;
 }
 
+/**
+ * isci_host_init - (re-)initialize hardware and internal (private) state
+ * @ihost: host to init
+ *
+ * Any public facing objects (like asd_sas_port, and asd_sas_phys), or
+ * one-time initialization objects like locks and waitqueues, are
+ * not touched (they are initialized in isci_host_alloc)
+ */
 int isci_host_init(struct isci_host *ihost)
 {
-	int err = 0, i;
+	int i, err;
 	enum sci_status status;
-	struct sci_user_parameters sci_user_params;
-	struct isci_pci_info *pci_info = to_pci_info(ihost->pdev);
-
-	spin_lock_init(&ihost->scic_lock);
-	init_waitqueue_head(&ihost->eventq);
-
-	status = sci_controller_construct(ihost, scu_base(ihost),
-					  smu_base(ihost));
 
+	status = sci_controller_construct(ihost, scu_base(ihost), smu_base(ihost));
 	if (status != SCI_SUCCESS) {
 		dev_err(&ihost->pdev->dev,
 			"%s: sci_controller_construct failed - status = %x\n",
@@ -2500,48 +2386,6 @@ int isci_host_init(struct isci_host *ihost)
 		return -ENODEV;
 	}
 
-	ihost->sas_ha.dev = &ihost->pdev->dev;
-	ihost->sas_ha.lldd_ha = ihost;
-
-	/*
-	 * grab initial values stored in the controller object for OEM and USER
-	 * parameters
-	 */
-	isci_user_parameters_get(&sci_user_params);
-	status = sci_user_parameters_set(ihost, &sci_user_params);
-	if (status != SCI_SUCCESS) {
-		dev_warn(&ihost->pdev->dev,
-			 "%s: sci_user_parameters_set failed\n",
-			 __func__);
-		return -ENODEV;
-	}
-
-	/* grab any OEM parameters specified in orom */
-	if (pci_info->orom) {
-		status = isci_parse_oem_parameters(&ihost->oem_parameters,
-						   pci_info->orom,
-						   ihost->id);
-		if (status != SCI_SUCCESS) {
-			dev_warn(&ihost->pdev->dev,
-				 "parsing firmware oem parameters failed\n");
-			return -EINVAL;
-		}
-	}
-
-	status = sci_oem_parameters_set(ihost);
-	if (status != SCI_SUCCESS) {
-		dev_warn(&ihost->pdev->dev,
-				"%s: sci_oem_parameters_set failed\n",
-				__func__);
-		return -ENODEV;
-	}
-
-	tasklet_init(&ihost->completion_tasklet,
-		     isci_host_completion_routine, (unsigned long)ihost);
-
-	INIT_LIST_HEAD(&ihost->requests_to_complete);
-	INIT_LIST_HEAD(&ihost->requests_to_errorback);
-
 	spin_lock_irq(&ihost->scic_lock);
 	status = sci_controller_initialize(ihost);
 	spin_unlock_irq(&ihost->scic_lock);
@@ -2557,47 +2401,12 @@ int isci_host_init(struct isci_host *ihost)
 	if (err)
 		return err;
 
-	for (i = 0; i < SCI_MAX_PORTS; i++) {
-		struct isci_port *iport = &ihost->ports[i];
-
-		INIT_LIST_HEAD(&iport->remote_dev_list);
-		iport->isci_host = ihost;
-	}
-
-	for (i = 0; i < SCI_MAX_PHYS; i++)
-		isci_phy_init(&ihost->phys[i], ihost, i);
-
 	/* enable sgpio */
 	writel(1, &ihost->scu_registers->peg0.sgpio.interface_control);
 	for (i = 0; i < isci_gpio_count(ihost); i++)
 		writel(SGPIO_HW_CONTROL, &ihost->scu_registers->peg0.sgpio.output_data_select[i]);
 	writel(0, &ihost->scu_registers->peg0.sgpio.vendor_specific_code);
 
-	for (i = 0; i < SCI_MAX_REMOTE_DEVICES; i++) {
-		struct isci_remote_device *idev = &ihost->devices[i];
-
-		INIT_LIST_HEAD(&idev->reqs_in_process);
-		INIT_LIST_HEAD(&idev->node);
-	}
-
-	for (i = 0; i < SCI_MAX_IO_REQUESTS; i++) {
-		struct isci_request *ireq;
-		dma_addr_t dma;
-
-		ireq = dmam_alloc_coherent(&ihost->pdev->dev,
-					   sizeof(struct isci_request), &dma,
-					   GFP_KERNEL);
-		if (!ireq)
-			return -ENOMEM;
-
-		ireq->tc = &ihost->task_context_table[i];
-		ireq->owning_controller = ihost;
-		spin_lock_init(&ireq->state_lock);
-		ireq->request_daddr = dma;
-		ireq->isci_host = ihost;
-		ihost->reqs[i] = ireq;
-	}
-
 	return 0;
 }
 

commit ae904d15cf344bcb426f63982016f6bacc45825b
Author: Dan Williams <dan.j.williams@intel.com>
Date:   Fri Feb 17 16:30:47 2012 -0800

    isci: kill isci_port.domain_dev_list
    
    Another unused field, and isci_port_init is overkill.
    
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/drivers/scsi/isci/host.c b/drivers/scsi/isci/host.c
index d647b07ba1a3..bbec1982d07f 100644
--- a/drivers/scsi/isci/host.c
+++ b/drivers/scsi/isci/host.c
@@ -2557,8 +2557,12 @@ int isci_host_init(struct isci_host *ihost)
 	if (err)
 		return err;
 
-	for (i = 0; i < SCI_MAX_PORTS; i++)
-		isci_port_init(&ihost->ports[i], ihost, i);
+	for (i = 0; i < SCI_MAX_PORTS; i++) {
+		struct isci_port *iport = &ihost->ports[i];
+
+		INIT_LIST_HEAD(&iport->remote_dev_list);
+		iport->isci_host = ihost;
+	}
 
 	for (i = 0; i < SCI_MAX_PHYS; i++)
 		isci_phy_init(&ihost->phys[i], ihost, i);

commit 1844e4789fe5c97a9ff3bb82628111abbe7cc846
Author: Dan Williams <dan.j.williams@intel.com>
Date:   Wed Feb 15 13:20:31 2012 -0800

    isci: kill ->status, and ->state_lock in isci_host
    
    They serve no incremental purpose over the existing sas_ha state.
    
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/drivers/scsi/isci/host.c b/drivers/scsi/isci/host.c
index 83886a27e848..d647b07ba1a3 100644
--- a/drivers/scsi/isci/host.c
+++ b/drivers/scsi/isci/host.c
@@ -642,7 +642,6 @@ static void isci_host_start_complete(struct isci_host *ihost, enum sci_status co
 	if (completion_status != SCI_SUCCESS)
 		dev_info(&ihost->pdev->dev,
 			"controller start timed out, continuing...\n");
-	isci_host_change_state(ihost, isci_ready);
 	clear_bit(IHOST_START_PENDING, &ihost->flags);
 	wake_up(&ihost->eventq);
 }
@@ -657,12 +656,7 @@ int isci_host_scan_finished(struct Scsi_Host *shost, unsigned long time)
 
 	sas_drain_work(ha);
 
-	dev_dbg(&ihost->pdev->dev,
-		"%s: ihost->status = %d, time = %ld\n",
-		 __func__, isci_host_get_state(ihost), time);
-
 	return 1;
-
 }
 
 /**
@@ -1054,7 +1048,6 @@ void isci_host_scan_start(struct Scsi_Host *shost)
 
 static void isci_host_stop_complete(struct isci_host *ihost, enum sci_status completion_status)
 {
-	isci_host_change_state(ihost, isci_stopped);
 	sci_controller_disable_interrupts(ihost);
 	clear_bit(IHOST_STOP_PENDING, &ihost->flags);
 	wake_up(&ihost->eventq);
@@ -1262,7 +1255,6 @@ void isci_host_deinit(struct isci_host *ihost)
 	for (i = 0; i < isci_gpio_count(ihost); i++)
 		writel(SGPIO_HW_CONTROL, &ihost->scu_registers->peg0.sgpio.output_data_select[i]);
 
-	isci_host_change_state(ihost, isci_stopping);
 	for (i = 0; i < SCI_MAX_PORTS; i++) {
 		struct isci_port *iport = &ihost->ports[i];
 		struct isci_remote_device *idev, *d;
@@ -2494,12 +2486,9 @@ int isci_host_init(struct isci_host *ihost)
 	struct sci_user_parameters sci_user_params;
 	struct isci_pci_info *pci_info = to_pci_info(ihost->pdev);
 
-	spin_lock_init(&ihost->state_lock);
 	spin_lock_init(&ihost->scic_lock);
 	init_waitqueue_head(&ihost->eventq);
 
-	isci_host_change_state(ihost, isci_starting);
-
 	status = sci_controller_construct(ihost, scu_base(ihost),
 					  smu_base(ihost));
 

commit c79dd80d73017a88a2c2ae46e7d5303cba6a32e0
Author: Dan Williams <dan.j.williams@intel.com>
Date:   Wed Feb 1 00:44:14 2012 -0800

    isci: kill sci_phy_protocol and sci_request_protocol
    
    Holdovers from the initial driver cleanup, replace with enum sas_protocol.
    
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/drivers/scsi/isci/host.c b/drivers/scsi/isci/host.c
index 3822ffb71caf..83886a27e848 100644
--- a/drivers/scsi/isci/host.c
+++ b/drivers/scsi/isci/host.c
@@ -1911,7 +1911,7 @@ static void power_control_timeout(unsigned long data)
 		ihost->power_control.phys_granted_power++;
 		sci_phy_consume_power_handler(iphy);
 
-		if (iphy->protocol == SCIC_SDS_PHY_PROTOCOL_SAS) {
+		if (iphy->protocol == SAS_PROTOCOL_SSP) {
 			u8 j;
 
 			for (j = 0; j < SCI_MAX_PHYS; j++) {
@@ -1985,7 +1985,7 @@ void sci_controller_power_control_queue_insert(struct isci_host *ihost,
 				       sizeof(current_phy->frame_rcvd.iaf.sas_addr));
 
 			if (current_phy->sm.current_state_id == SCI_PHY_READY &&
-			    current_phy->protocol == SCIC_SDS_PHY_PROTOCOL_SAS &&
+			    current_phy->protocol == SAS_PROTOCOL_SSP &&
 			    other == 0) {
 				sci_phy_consume_power_handler(iphy);
 				break;

commit 14e99b4a3f5323bb961754de5024daff79e59b98
Author: Dan Williams <dan.j.williams@intel.com>
Date:   Fri Feb 10 01:05:43 2012 -0800

    isci: improve 'invalid state' warnings
    
    Convert controller state machine warnings to emit the state number (it
    missed the number to string conversion, but since these error rarely
    happen not much motivation to go further).
    
    Fix up the rnc warnings to use the state name.
    
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/drivers/scsi/isci/host.c b/drivers/scsi/isci/host.c
index d4bf9c12ecd4..3822ffb71caf 100644
--- a/drivers/scsi/isci/host.c
+++ b/drivers/scsi/isci/host.c
@@ -987,9 +987,8 @@ static enum sci_status sci_controller_start(struct isci_host *ihost,
 	u16 index;
 
 	if (ihost->sm.current_state_id != SCIC_INITIALIZED) {
-		dev_warn(&ihost->pdev->dev,
-			 "SCIC Controller start operation requested in "
-			 "invalid state\n");
+		dev_warn(&ihost->pdev->dev, "%s invalid state: %d\n",
+			 __func__, ihost->sm.current_state_id);
 		return SCI_FAILURE_INVALID_STATE;
 	}
 
@@ -1213,9 +1212,8 @@ static void isci_host_completion_routine(unsigned long data)
 static enum sci_status sci_controller_stop(struct isci_host *ihost, u32 timeout)
 {
 	if (ihost->sm.current_state_id != SCIC_READY) {
-		dev_warn(&ihost->pdev->dev,
-			 "SCIC Controller stop operation requested in "
-			 "invalid state\n");
+		dev_warn(&ihost->pdev->dev, "%s invalid state: %d\n",
+			 __func__, ihost->sm.current_state_id);
 		return SCI_FAILURE_INVALID_STATE;
 	}
 
@@ -1250,9 +1248,8 @@ static enum sci_status sci_controller_reset(struct isci_host *ihost)
 		sci_change_state(&ihost->sm, SCIC_RESETTING);
 		return SCI_SUCCESS;
 	default:
-		dev_warn(&ihost->pdev->dev,
-			 "SCIC Controller reset operation requested in "
-			 "invalid state\n");
+		dev_warn(&ihost->pdev->dev, "%s invalid state: %d\n",
+			 __func__, ihost->sm.current_state_id);
 		return SCI_FAILURE_INVALID_STATE;
 	}
 }
@@ -2279,9 +2276,8 @@ static enum sci_status sci_controller_initialize(struct isci_host *ihost)
 	unsigned long i, state, val;
 
 	if (ihost->sm.current_state_id != SCIC_RESET) {
-		dev_warn(&ihost->pdev->dev,
-			 "SCIC Controller initialize operation requested "
-			 "in invalid state\n");
+		dev_warn(&ihost->pdev->dev, "%s invalid state: %d\n",
+			 __func__, ihost->sm.current_state_id);
 		return SCI_FAILURE_INVALID_STATE;
 	}
 
@@ -2842,7 +2838,8 @@ enum sci_status sci_controller_start_io(struct isci_host *ihost,
 	enum sci_status status;
 
 	if (ihost->sm.current_state_id != SCIC_READY) {
-		dev_warn(&ihost->pdev->dev, "invalid state to start I/O");
+		dev_warn(&ihost->pdev->dev, "%s invalid state: %d\n",
+			 __func__, ihost->sm.current_state_id);
 		return SCI_FAILURE_INVALID_STATE;
 	}
 
@@ -2866,8 +2863,8 @@ enum sci_status sci_controller_terminate_request(struct isci_host *ihost,
 	enum sci_status status;
 
 	if (ihost->sm.current_state_id != SCIC_READY) {
-		dev_warn(&ihost->pdev->dev,
-			 "invalid state to terminate request\n");
+		dev_warn(&ihost->pdev->dev, "%s invalid state: %d\n",
+			 __func__, ihost->sm.current_state_id);
 		return SCI_FAILURE_INVALID_STATE;
 	}
 
@@ -2915,7 +2912,8 @@ enum sci_status sci_controller_complete_io(struct isci_host *ihost,
 		clear_bit(IREQ_ACTIVE, &ireq->flags);
 		return SCI_SUCCESS;
 	default:
-		dev_warn(&ihost->pdev->dev, "invalid state to complete I/O");
+		dev_warn(&ihost->pdev->dev, "%s invalid state: %d\n",
+			 __func__, ihost->sm.current_state_id);
 		return SCI_FAILURE_INVALID_STATE;
 	}
 
@@ -2926,7 +2924,8 @@ enum sci_status sci_controller_continue_io(struct isci_request *ireq)
 	struct isci_host *ihost = ireq->owning_controller;
 
 	if (ihost->sm.current_state_id != SCIC_READY) {
-		dev_warn(&ihost->pdev->dev, "invalid state to continue I/O");
+		dev_warn(&ihost->pdev->dev, "%s invalid state: %d\n",
+			 __func__, ihost->sm.current_state_id);
 		return SCI_FAILURE_INVALID_STATE;
 	}
 

commit 424a6f6ef990b7e9f56f6627bfc6c46b493faeb4
Merge: 1ab142d49929 cd8df932d894
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Thu Mar 22 12:55:29 2012 -0700

    Merge tag 'scsi-misc' of git://git.kernel.org/pub/scm/linux/kernel/git/jejb/scsi-misc-2.6
    
    SCSI updates from James Bottomley:
     "The update includes the usual assortment of driver updates (lpfc,
      qla2xxx, qla4xxx, bfa, bnx2fc, bnx2i, isci, fcoe, hpsa) plus a huge
      amount of infrastructure work in the SAS library and transport class
      as well as an iSCSI update.  There's also a new SCSI based virtio
      driver."
    
    * tag 'scsi-misc' of git://git.kernel.org/pub/scm/linux/kernel/git/jejb/scsi-misc-2.6: (177 commits)
      [SCSI] qla4xxx: Update driver version to 5.02.00-k15
      [SCSI] qla4xxx: trivial cleanup
      [SCSI] qla4xxx: Fix sparse warning
      [SCSI] qla4xxx: Add support for multiple session per host.
      [SCSI] qla4xxx: Export CHAP index as sysfs attribute
      [SCSI] scsi_transport: Export CHAP index as sysfs attribute
      [SCSI] qla4xxx: Add support to display CHAP list and delete CHAP entry
      [SCSI] iscsi_transport: Add support to display CHAP list and delete CHAP entry
      [SCSI] pm8001: fix endian issue with code optimization.
      [SCSI] pm8001: Fix possible racing condition.
      [SCSI] pm8001: Fix bogus interrupt state flag issue.
      [SCSI] ipr: update PCI ID definitions for new adapters
      [SCSI] qla2xxx: handle default case in qla2x00_request_firmware()
      [SCSI] isci: improvements in driver unloading routine
      [SCSI] isci: improve phy event warnings
      [SCSI] isci: debug, provide state-enum-to-string conversions
      [SCSI] scsi_transport_sas: 'enable' phys on reset
      [SCSI] libsas: don't recover end devices attached to disabled phys
      [SCSI] libsas: fixup target_port_protocols for expanders that don't report sata
      [SCSI] libsas: set attached device type and target protocols for local phys
      ...

commit 69a7aebcf019ab3ff5764525ad6858fbe23bb86d
Merge: d464c92b5234 f1f996b66cc3
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue Mar 20 21:12:50 2012 -0700

    Merge branch 'for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/jikos/trivial
    
    Pull trivial tree from Jiri Kosina:
     "It's indeed trivial -- mostly documentation updates and a bunch of
      typo fixes from Masanari.
    
      There are also several linux/version.h include removals from Jesper."
    
    * 'for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/jikos/trivial: (101 commits)
      kcore: fix spelling in read_kcore() comment
      constify struct pci_dev * in obvious cases
      Revert "char: Fix typo in viotape.c"
      init: fix wording error in mm_init comment
      usb: gadget: Kconfig: fix typo for 'different'
      Revert "power, max8998: Include linux/module.h just once in drivers/power/max8998_charger.c"
      writeback: fix fn name in writeback_inodes_sb_nr_if_idle() comment header
      writeback: fix typo in the writeback_control comment
      Documentation: Fix multiple typo in Documentation
      tpm_tis: fix tis_lock with respect to RCU
      Revert "media: Fix typo in mixer_drv.c and hdmi_drv.c"
      Doc: Update numastat.txt
      qla4xxx: Add missing spaces to error messages
      compiler.h: Fix typo
      security: struct security_operations kerneldoc fix
      Documentation: broken URL in libata.tmpl
      Documentation: broken URL in filesystems.tmpl
      mtd: simplify return logic in do_map_probe()
      mm: fix comment typo of truncate_inode_pages_range
      power: bq27x00: Fix typos in comment
      ...

commit b1124cd3ec97406c767b90bf7e93ecd2d2915592
Author: Dan Williams <dan.j.williams@intel.com>
Date:   Mon Dec 19 16:42:34 2011 -0800

    [SCSI] libsas: introduce sas_drain_work()
    
    When an lldd invokes ->notify_port_event() it can trigger a chain of libsas
    events to:
    
      1/ form the port and find the direct attached device
    
      2/ if the attached device is an expander perform domain discovery
    
    A call to flush_workqueue() will only flush the initial port formation work.
    Currently libsas users need to call scsi_flush_work() up to the max depth of
    chain (which will grow from 2 to 3 when ata discovery is moved to its own
    discovery event).  Instead of open coding multiple calls switch to use
    drain_workqueue() to flush sas work.
    
    drain_workqueue() does not handle new work submitted during the drain so
    libsas needs a bit of infrastructure to hold off unchained work submissions
    while a drain is in flight.  A lldd ->notify() event is considered 'unchained'
    while a sas_discover_event() is 'chained'.  As Tejun notes:
    
      "For now, I think it would be best to add private wrapper in libsas to
       support deferring unchained work items while draining."
    
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>
    Signed-off-by: James Bottomley <JBottomley@Parallels.com>

diff --git a/drivers/scsi/isci/host.c b/drivers/scsi/isci/host.c
index 508aa8ce25b4..e3cf3832c5b6 100644
--- a/drivers/scsi/isci/host.c
+++ b/drivers/scsi/isci/host.c
@@ -650,15 +650,13 @@ static void isci_host_start_complete(struct isci_host *ihost, enum sci_status co
 
 int isci_host_scan_finished(struct Scsi_Host *shost, unsigned long time)
 {
-	struct isci_host *ihost = SHOST_TO_SAS_HA(shost)->lldd_ha;
+	struct sas_ha_struct *ha = SHOST_TO_SAS_HA(shost);
+	struct isci_host *ihost = ha->lldd_ha;
 
 	if (test_bit(IHOST_START_PENDING, &ihost->flags))
 		return 0;
 
-	/* todo: use sas_flush_discovery once it is upstream */
-	scsi_flush_work(shost);
-
-	scsi_flush_work(shost);
+	sas_drain_work(ha);
 
 	dev_dbg(&ihost->pdev->dev,
 		"%s: ihost->status = %d, time = %ld\n",

commit e5cc6aa4b6ef34c3f054af8c61a4f73c157589c3
Author: Marcin Tomczak <marcin.tomczak@intel.com>
Date:   Fri Jan 27 11:14:50 2012 -0800

    [SCSI] isci: enable clock gating
    
    Enabling clock gating for power savings on entry to controller ready
    state. Disable SCU clock gating for power savings on exit from the
    controller ready state.
    
    The gating is fully automated by silicon after setting the mode.
    
    Signed-off-by: Marcin Tomczak <marcin.tomczak@intel.com>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>
    Signed-off-by: James Bottomley <JBottomley@Parallels.com>

diff --git a/drivers/scsi/isci/host.c b/drivers/scsi/isci/host.c
index 418391b1c361..508aa8ce25b4 100644
--- a/drivers/scsi/isci/host.c
+++ b/drivers/scsi/isci/host.c
@@ -1491,6 +1491,15 @@ sci_controller_set_interrupt_coalescence(struct isci_host *ihost,
 static void sci_controller_ready_state_enter(struct sci_base_state_machine *sm)
 {
 	struct isci_host *ihost = container_of(sm, typeof(*ihost), sm);
+	u32 val;
+
+	/* enable clock gating for power control of the scu unit */
+	val = readl(&ihost->smu_registers->clock_gating_control);
+	val &= ~(SMU_CGUCR_GEN_BIT(REGCLK_ENABLE) |
+		 SMU_CGUCR_GEN_BIT(TXCLK_ENABLE) |
+		 SMU_CGUCR_GEN_BIT(XCLK_ENABLE));
+	val |= SMU_CGUCR_GEN_BIT(IDLE_ENABLE);
+	writel(val, &ihost->smu_registers->clock_gating_control);
 
 	/* set the default interrupt coalescence number and timeout value. */
 	sci_controller_set_interrupt_coalescence(ihost, 0, 0);

commit 6d7938f46f89c9773f9396c1d13b20bbc5c6d95b
Author: Dave Jiang <dave.jiang@intel.com>
Date:   Fri Jan 27 11:17:37 2012 -0800

    [SCSI] isci: Fix NULL ptr dereference when no firmware is being loaded
    
    NULL orom ptr passed in for verification which caused page fault.
    We will set a default version when we don't have orom struct.
    
    Reported-by: Dan Melnic <dan@seamicro.com>
    Signed-off-by: Dave Jiang <dave.jiang@intel.com>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>
    Signed-off-by: James Bottomley <JBottomley@Parallels.com>

diff --git a/drivers/scsi/isci/host.c b/drivers/scsi/isci/host.c
index 1a65d6514237..418391b1c361 100644
--- a/drivers/scsi/isci/host.c
+++ b/drivers/scsi/isci/host.c
@@ -1848,9 +1848,11 @@ static enum sci_status sci_oem_parameters_set(struct isci_host *ihost)
 	if (state == SCIC_RESET ||
 	    state == SCIC_INITIALIZING ||
 	    state == SCIC_INITIALIZED) {
+		u8 oem_version = pci_info->orom ? pci_info->orom->hdr.version :
+			ISCI_ROM_VER_1_0;
 
 		if (sci_oem_parameters_validate(&ihost->oem_parameters,
-						pci_info->orom->hdr.version))
+						oem_version))
 			return SCI_FAILURE_INVALID_PARAMETER_VALUE;
 
 		return SCI_SUCCESS;

commit a2888ec985f36f8584609fedc916e5b1fd37aaac
Author: Jesper Juhl <jj@chaosbits.net>
Date:   Sun Feb 5 01:37:56 2012 +0100

    SCSI, ISCSI: Just #include "host.h" once in host.c
    
    There's no need to include the header twice.
    
    Signed-off-by: Jesper Juhl <jj@chaosbits.net>
    Signed-off-by: Jiri Kosina <jkosina@suse.cz>

diff --git a/drivers/scsi/isci/host.c b/drivers/scsi/isci/host.c
index 1a65d6514237..0061cfd93bb2 100644
--- a/drivers/scsi/isci/host.c
+++ b/drivers/scsi/isci/host.c
@@ -58,7 +58,6 @@
 #include "host.h"
 #include "isci.h"
 #include "port.h"
-#include "host.h"
 #include "probe_roms.h"
 #include "remote_device.h"
 #include "request.h"

commit be778341812dc75b1c515fab6ebd39c0daf1e2bc
Author: Marcin Tomczak <marcin.tomczak@intel.com>
Date:   Wed Jan 4 01:33:31 2012 -0800

    [SCSI] isci: fix io failures while wide port links are coming up
    
    When the first phy of a wide port comes up, don't report the port ready
    yet, always wait for 250 miliseconds then config the port with all phys
    added to the port. So that we can avoid reporting wide port device too
    early to kernel, which caused the first IOs (report luns, inquirys)
    failed due to not all the phys are configured into its port. Changes
    also made that the phys in a wide port don't need to go through half
    second wait time for consuming power.
    
    Signed-off-by: Marcin Tomczak <marcin.tomczak@intel.com>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>
    Signed-off-by: James Bottomley <JBottomley@Parallels.com>

diff --git a/drivers/scsi/isci/host.c b/drivers/scsi/isci/host.c
index 7e4d709dc201..1a65d6514237 100644
--- a/drivers/scsi/isci/host.c
+++ b/drivers/scsi/isci/host.c
@@ -899,7 +899,8 @@ static enum sci_status sci_controller_start_next_phy(struct isci_host *ihost)
 			 */
 			if ((iphy->is_in_link_training == false && state == SCI_PHY_INITIAL) ||
 			    (iphy->is_in_link_training == false && state == SCI_PHY_STOPPED) ||
-			    (iphy->is_in_link_training == true && is_phy_starting(iphy))) {
+			    (iphy->is_in_link_training == true && is_phy_starting(iphy)) ||
+			    (ihost->port_agent.phy_ready_mask != ihost->port_agent.phy_configured_mask)) {
 				is_controller_start_complete = false;
 				break;
 			}
@@ -1904,6 +1905,31 @@ static void power_control_timeout(unsigned long data)
 		ihost->power_control.phys_waiting--;
 		ihost->power_control.phys_granted_power++;
 		sci_phy_consume_power_handler(iphy);
+
+		if (iphy->protocol == SCIC_SDS_PHY_PROTOCOL_SAS) {
+			u8 j;
+
+			for (j = 0; j < SCI_MAX_PHYS; j++) {
+				struct isci_phy *requester = ihost->power_control.requesters[j];
+
+				/*
+				 * Search the power_control queue to see if there are other phys
+				 * attached to the same remote device. If found, take all of
+				 * them out of await_sas_power state.
+				 */
+				if (requester != NULL && requester != iphy) {
+					u8 other = memcmp(requester->frame_rcvd.iaf.sas_addr,
+							  iphy->frame_rcvd.iaf.sas_addr,
+							  sizeof(requester->frame_rcvd.iaf.sas_addr));
+
+					if (other == 0) {
+						ihost->power_control.requesters[j] = NULL;
+						ihost->power_control.phys_waiting--;
+						sci_phy_consume_power_handler(requester);
+					}
+				}
+			}
+		}
 	}
 
 	/*
@@ -1938,9 +1964,34 @@ void sci_controller_power_control_queue_insert(struct isci_host *ihost,
 		ihost->power_control.timer_started = true;
 
 	} else {
-		/* Add the phy in the waiting list */
-		ihost->power_control.requesters[iphy->phy_index] = iphy;
-		ihost->power_control.phys_waiting++;
+		/*
+		 * There are phys, attached to the same sas address as this phy, are
+		 * already in READY state, this phy don't need wait.
+		 */
+		u8 i;
+		struct isci_phy *current_phy;
+
+		for (i = 0; i < SCI_MAX_PHYS; i++) {
+			u8 other;
+			current_phy = &ihost->phys[i];
+
+			other = memcmp(current_phy->frame_rcvd.iaf.sas_addr,
+				       iphy->frame_rcvd.iaf.sas_addr,
+				       sizeof(current_phy->frame_rcvd.iaf.sas_addr));
+
+			if (current_phy->sm.current_state_id == SCI_PHY_READY &&
+			    current_phy->protocol == SCIC_SDS_PHY_PROTOCOL_SAS &&
+			    other == 0) {
+				sci_phy_consume_power_handler(iphy);
+				break;
+			}
+		}
+
+		if (i == SCI_MAX_PHYS) {
+			/* Add the phy in the waiting list */
+			ihost->power_control.requesters[iphy->phy_index] = iphy;
+			ihost->power_control.phys_waiting++;
+		}
 	}
 }
 

commit be168a3b89b43b8bb4ef71066e91439d400e20a6
Author: Jeff Skirvin <jeffrey.d.skirvin@intel.com>
Date:   Wed Jan 4 01:33:00 2012 -0800

    [SCSI] isci: link speeds default to gen 2
    
    Gen-3 operation is marginal, default to gen-2 for now.
    
    Signed-off-by: Jeff Skirvin <jeffrey.d.skirvin@intel.com>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>
    Signed-off-by: James Bottomley <JBottomley@Parallels.com>

diff --git a/drivers/scsi/isci/host.c b/drivers/scsi/isci/host.c
index 670ecb456d48..7e4d709dc201 100644
--- a/drivers/scsi/isci/host.c
+++ b/drivers/scsi/isci/host.c
@@ -1676,8 +1676,9 @@ static void sci_controller_set_default_config_parameters(struct isci_host *ihost
 
 	/* Initialize all of the phy parameter information. */
 	for (index = 0; index < SCI_MAX_PHYS; index++) {
-		/* Default to 6G (i.e. Gen 3) for now. */
-		ihost->user_parameters.phys[index].max_speed_generation = 3;
+		/* Default to 3G (i.e. Gen 2). */
+		ihost->user_parameters.phys[index].max_speed_generation =
+			SCIC_SDS_PARM_GEN2_SPEED;
 
 		/* the frequencies cannot be 0 */
 		ihost->user_parameters.phys[index].align_insertion_frequency = 0x7f;

commit 6024d38b86ecc7943e398ef01b0dc2765870d444
Author: Marcin Tomczak <marcin.tomczak@intel.com>
Date:   Wed Jan 4 01:32:54 2012 -0800

    [SCSI] isci: performance-fix, shorten default "no outbound task" timeout
    
    "No task timeout timer reduced from 20 to 2 This timer controls how
    long the SCU hardware will hold open the TX side of the connection
    before sending a DONE.  The timer allows the hardware to attempt to
    optimize the DONE/CLOSE behavior to allow for new COMMAND IU to be
    posted.  In practice closing the connection quicker is better."
    
    Signed-off-by: Marcin Tomczak <marcin.tomczak@intel.com>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>
    Signed-off-by: James Bottomley <JBottomley@Parallels.com>

diff --git a/drivers/scsi/isci/host.c b/drivers/scsi/isci/host.c
index 9a52b984620f..670ecb456d48 100644
--- a/drivers/scsi/isci/host.c
+++ b/drivers/scsi/isci/host.c
@@ -1697,7 +1697,7 @@ static void sci_controller_set_default_config_parameters(struct isci_host *ihost
 	ihost->user_parameters.ssp_inactivity_timeout = 5;
 	ihost->user_parameters.stp_max_occupancy_timeout = 5;
 	ihost->user_parameters.ssp_max_occupancy_timeout = 20;
-	ihost->user_parameters.no_outbound_task_timeout = 20;
+	ihost->user_parameters.no_outbound_task_timeout = 2;
 }
 
 static void controller_timeout(unsigned long data)

commit 9fee607f0b29adabd72265a847b8e421dff10d66
Author: Jeff Skirvin <jeffrey.d.skirvin@intel.com>
Date:   Wed Jan 4 01:32:49 2012 -0800

    [SCSI] isci: oem parameter format v1.3 (cable select)
    
    v1.3 allows the attenuation of the attached cables to be specified to
    the driver in terms of 'short', 'medium', and 'long' (see probe_roms.h).
    These settings (per phy) are retrieved from the platform oem-parameters
    (BIOS rom) or via a module parameter override.
    
    Reviewed-by: Jiangbi Liu <jiangbi.liu@intel.com>
    Signed-off-by: Jeff Skirvin <jeffrey.d.skirvin@intel.com>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>
    Signed-off-by: James Bottomley <JBottomley@Parallels.com>

diff --git a/drivers/scsi/isci/host.c b/drivers/scsi/isci/host.c
index ed1441c89577..9a52b984620f 100644
--- a/drivers/scsi/isci/host.c
+++ b/drivers/scsi/isci/host.c
@@ -1666,6 +1666,9 @@ static void sci_controller_set_default_config_parameters(struct isci_host *ihost
 	/* Default to no SSC operation. */
 	ihost->oem_parameters.controller.do_enable_ssc = false;
 
+	/* Default to short cables on all phys. */
+	ihost->oem_parameters.controller.cable_selection_mask = 0;
+
 	/* Initialize all of the port parameter information to narrow ports. */
 	for (index = 0; index < SCI_MAX_PORTS; index++) {
 		ihost->oem_parameters.ports[index].phy_mask = 0;
@@ -1953,12 +1956,46 @@ void sci_controller_power_control_queue_remove(struct isci_host *ihost,
 
 static int is_long_cable(int phy, unsigned char selection_byte)
 {
-	return 0;
+	return !!(selection_byte & (1 << phy));
 }
 
 static int is_medium_cable(int phy, unsigned char selection_byte)
 {
-	return 0;
+	return !!(selection_byte & (1 << (phy + 4)));
+}
+
+static enum cable_selections decode_selection_byte(
+	int phy,
+	unsigned char selection_byte)
+{
+	return ((selection_byte & (1 << phy)) ? 1 : 0)
+		+ (selection_byte & (1 << (phy + 4)) ? 2 : 0);
+}
+
+static unsigned char *to_cable_select(struct isci_host *ihost)
+{
+	if (is_cable_select_overridden())
+		return ((unsigned char *)&cable_selection_override)
+			+ ihost->id;
+	else
+		return &ihost->oem_parameters.controller.cable_selection_mask;
+}
+
+enum cable_selections decode_cable_selection(struct isci_host *ihost, int phy)
+{
+	return decode_selection_byte(phy, *to_cable_select(ihost));
+}
+
+char *lookup_cable_names(enum cable_selections selection)
+{
+	static char *cable_names[] = {
+		[short_cable]     = "short",
+		[long_cable]      = "long",
+		[medium_cable]    = "medium",
+		[undefined_cable] = "<undefined, assumed long>" /* bit 0==1 */
+	};
+	return (selection <= undefined_cable) ? cable_names[selection]
+					      : cable_names[undefined_cable];
 }
 
 #define AFE_REGISTER_WRITE_DELAY 10
@@ -1967,10 +2004,10 @@ static void sci_controller_afe_initialization(struct isci_host *ihost)
 {
 	struct scu_afe_registers __iomem *afe = &ihost->scu_registers->afe;
 	const struct sci_oem_params *oem = &ihost->oem_parameters;
-	unsigned char cable_selection_mask = 0;
 	struct pci_dev *pdev = ihost->pdev;
 	u32 afe_status;
 	u32 phy_id;
+	unsigned char cable_selection_mask = *to_cable_select(ihost);
 
 	/* Clear DFX Status registers */
 	writel(0x0081000f, &afe->afe_dfx_master_control0);

commit 594e566ae5985e0cc3185ac21509a86e90aad577
Author: Dave Jiang <dave.jiang@intel.com>
Date:   Wed Jan 4 01:32:44 2012 -0800

    [SCSI] isci: oem parameter format v1.1 (ssc select)
    
    v1.1 allows finer grained tuning of the SSC (spread-spectrum-clocking)
    settings for SAS and SATA.  See notes in probe_roms.h
    
    Signed-off-by: Dave Jiang <dave.jiang@intel.com>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>
    Signed-off-by: James Bottomley <JBottomley@Parallels.com>

diff --git a/drivers/scsi/isci/host.c b/drivers/scsi/isci/host.c
index 383bb6913087..ed1441c89577 100644
--- a/drivers/scsi/isci/host.c
+++ b/drivers/scsi/isci/host.c
@@ -1759,7 +1759,7 @@ static enum sci_status sci_controller_construct(struct isci_host *ihost,
 	return sci_controller_reset(ihost);
 }
 
-int sci_oem_parameters_validate(struct sci_oem_params *oem)
+int sci_oem_parameters_validate(struct sci_oem_params *oem, u8 version)
 {
 	int i;
 
@@ -1791,18 +1791,61 @@ int sci_oem_parameters_validate(struct sci_oem_params *oem)
 	    oem->controller.max_concurr_spin_up < 1)
 		return -EINVAL;
 
+	if (oem->controller.do_enable_ssc) {
+		if (version < ISCI_ROM_VER_1_1 && oem->controller.do_enable_ssc != 1)
+			return -EINVAL;
+
+		if (version >= ISCI_ROM_VER_1_1) {
+			u8 test = oem->controller.ssc_sata_tx_spread_level;
+
+			switch (test) {
+			case 0:
+			case 2:
+			case 3:
+			case 6:
+			case 7:
+				break;
+			default:
+				return -EINVAL;
+			}
+
+			test = oem->controller.ssc_sas_tx_spread_level;
+			if (oem->controller.ssc_sas_tx_type == 0) {
+				switch (test) {
+				case 0:
+				case 2:
+				case 3:
+					break;
+				default:
+					return -EINVAL;
+				}
+			} else if (oem->controller.ssc_sas_tx_type == 1) {
+				switch (test) {
+				case 0:
+				case 3:
+				case 6:
+					break;
+				default:
+					return -EINVAL;
+				}
+			}
+		}
+	}
+
 	return 0;
 }
 
 static enum sci_status sci_oem_parameters_set(struct isci_host *ihost)
 {
 	u32 state = ihost->sm.current_state_id;
+	struct isci_pci_info *pci_info = to_pci_info(ihost->pdev);
 
 	if (state == SCIC_RESET ||
 	    state == SCIC_INITIALIZING ||
 	    state == SCIC_INITIALIZED) {
 
-		if (sci_oem_parameters_validate(&ihost->oem_parameters))
+		if (sci_oem_parameters_validate(&ihost->oem_parameters,
+						pci_info->orom->hdr.version))
 			return SCI_FAILURE_INVALID_PARAMETER_VALUE;
 
 		return SCI_SUCCESS;

commit afd13a1f2b05157c7621d87dfe89ea6ea9061bd8
Author: Jeff Skirvin <jeffrey.d.skirvin@intel.com>
Date:   Wed Jan 4 01:32:39 2012 -0800

    [SCSI] isci: update afe (analog-front-end) recipe for C1
    
    C1 silicon requires updates to the phy tuning recipe and also support
    for user provided cable selects (per-phy) for short, medium, and long
    cables.  Default to 'short' awaiting support for selecting the cable via
    oem parameters.
    
    Reviewed-by: Jiangbi Liu <jiangbi.liu@intel.com>
    Signed-off-by: Marcin Tomczak <marcin.tomczak@intel.com>
    Signed-off-by: Jeff Skirvin <jeffrey.d.skirvin@intel.com>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>
    Signed-off-by: James Bottomley <JBottomley@Parallels.com>

diff --git a/drivers/scsi/isci/host.c b/drivers/scsi/isci/host.c
index 8e7de192cf6d..383bb6913087 100644
--- a/drivers/scsi/isci/host.c
+++ b/drivers/scsi/isci/host.c
@@ -1908,12 +1908,23 @@ void sci_controller_power_control_queue_remove(struct isci_host *ihost,
 	ihost->power_control.requesters[iphy->phy_index] = NULL;
 }
 
+static int is_long_cable(int phy, unsigned char selection_byte)
+{
+	return 0;
+}
+
+static int is_medium_cable(int phy, unsigned char selection_byte)
+{
+	return 0;
+}
+
 #define AFE_REGISTER_WRITE_DELAY 10
 
 static void sci_controller_afe_initialization(struct isci_host *ihost)
 {
 	struct scu_afe_registers __iomem *afe = &ihost->scu_registers->afe;
 	const struct sci_oem_params *oem = &ihost->oem_parameters;
+	unsigned char cable_selection_mask = 0;
 	struct pci_dev *pdev = ihost->pdev;
 	u32 afe_status;
 	u32 phy_id;
@@ -1922,11 +1933,11 @@ static void sci_controller_afe_initialization(struct isci_host *ihost)
 	writel(0x0081000f, &afe->afe_dfx_master_control0);
 	udelay(AFE_REGISTER_WRITE_DELAY);
 
-	if (is_b0(pdev)) {
+	if (is_b0(pdev) || is_c0(pdev) || is_c1(pdev)) {
 		/* PM Rx Equalization Save, PM SPhy Rx Acknowledgement
 		 * Timer, PM Stagger Timer
 		 */
-		writel(0x0007BFFF, &afe->afe_pmsn_master_control2);
+		writel(0x0007FFFF, &afe->afe_pmsn_master_control2);
 		udelay(AFE_REGISTER_WRITE_DELAY);
 	}
 
@@ -1935,14 +1946,23 @@ static void sci_controller_afe_initialization(struct isci_host *ihost)
 		writel(0x00005A00, &afe->afe_bias_control);
 	else if (is_b0(pdev) || is_c0(pdev))
 		writel(0x00005F00, &afe->afe_bias_control);
+	else if (is_c1(pdev))
+		writel(0x00005500, &afe->afe_bias_control);
 
 	udelay(AFE_REGISTER_WRITE_DELAY);
 
 	/* Enable PLL */
-	if (is_b0(pdev) || is_c0(pdev))
-		writel(0x80040A08, &afe->afe_pll_control0);
-	else
+	if (is_a2(pdev))
 		writel(0x80040908, &afe->afe_pll_control0);
+	else if (is_b0(pdev) || is_c0(pdev))
+		writel(0x80040A08, &afe->afe_pll_control0);
+	else if (is_c1(pdev)) {
+		writel(0x80000B08, &afe->afe_pll_control0);
+		udelay(AFE_REGISTER_WRITE_DELAY);
+		writel(0x00000B08, &afe->afe_pll_control0);
+		udelay(AFE_REGISTER_WRITE_DELAY);
+		writel(0x80000B08, &afe->afe_pll_control0);
+	}
 
 	udelay(AFE_REGISTER_WRITE_DELAY);
 
@@ -1963,46 +1983,68 @@ static void sci_controller_afe_initialization(struct isci_host *ihost)
 	for (phy_id = 0; phy_id < SCI_MAX_PHYS; phy_id++) {
 		struct scu_afe_transceiver *xcvr = &afe->scu_afe_xcvr[phy_id];
 		const struct sci_phy_oem_params *oem_phy = &oem->phys[phy_id];
+		int cable_length_long =
+			is_long_cable(phy_id, cable_selection_mask);
+		int cable_length_medium =
+			is_medium_cable(phy_id, cable_selection_mask);
+
+		if (is_a2(pdev)) {
+			/* All defaults, except the Receive Word
+			 * Alignament/Comma Detect Enable....(0xe800)
+			 */
+			writel(0x00004512, &xcvr->afe_xcvr_control0);
+			udelay(AFE_REGISTER_WRITE_DELAY);
 
-		if (is_b0(pdev)) {
-			 /* Configure transmitter SSC parameters */
+			writel(0x0050100F, &xcvr->afe_xcvr_control1);
+			udelay(AFE_REGISTER_WRITE_DELAY);
+		} else if (is_b0(pdev)) {
+			/* Configure transmitter SSC parameters */
 			writel(0x00030000, &xcvr->afe_tx_ssc_control);
 			udelay(AFE_REGISTER_WRITE_DELAY);
 		} else if (is_c0(pdev)) {
-			 /* Configure transmitter SSC parameters */
-			writel(0x0003000, &xcvr->afe_tx_ssc_control);
+			/* Configure transmitter SSC parameters */
+			writel(0x00010202, &xcvr->afe_tx_ssc_control);
 			udelay(AFE_REGISTER_WRITE_DELAY);
 
 			/* All defaults, except the Receive Word
 			 * Alignament/Comma Detect Enable....(0xe800)
 			 */
-			writel(0x00004500, &xcvr->afe_xcvr_control0);
+			writel(0x00014500, &xcvr->afe_xcvr_control0);
 			udelay(AFE_REGISTER_WRITE_DELAY);
-		} else {
+		} else if (is_c1(pdev)) {
+			/* Configure transmitter SSC parameters */
+			writel(0x00010202, &xcvr->afe_tx_ssc_control);
+			udelay(AFE_REGISTER_WRITE_DELAY);
+
 			/* All defaults, except the Receive Word
 			 * Alignament/Comma Detect Enable....(0xe800)
 			 */
-			writel(0x00004512, &xcvr->afe_xcvr_control0);
-			udelay(AFE_REGISTER_WRITE_DELAY);
-
-			writel(0x0050100F, &xcvr->afe_xcvr_control1);
+			writel(0x0001C500, &xcvr->afe_xcvr_control0);
 			udelay(AFE_REGISTER_WRITE_DELAY);
 		}
 
-		/* Power up TX and RX out from power down (PWRDNTX and PWRDNRX)
-		 * & increase TX int & ext bias 20%....(0xe85c)
+		/* Power up TX and RX out from power down (PWRDNTX and
+		 * PWRDNRX) & increase TX int & ext bias 20%....(0xe85c)
 		 */
 		if (is_a2(pdev))
 			writel(0x000003F0, &xcvr->afe_channel_control);
 		else if (is_b0(pdev)) {
-			 /* Power down TX and RX (PWRDNTX and PWRDNRX) */
 			writel(0x000003D7, &xcvr->afe_channel_control);
 			udelay(AFE_REGISTER_WRITE_DELAY);
+
 			writel(0x000003D4, &xcvr->afe_channel_control);
-		} else {
+		} else if (is_c0(pdev)) {
 			writel(0x000001E7, &xcvr->afe_channel_control);
 			udelay(AFE_REGISTER_WRITE_DELAY);
+
 			writel(0x000001E4, &xcvr->afe_channel_control);
+		} else if (is_c1(pdev)) {
+			writel(cable_length_long ? 0x000002F7 : 0x000001F7,
+			       &xcvr->afe_channel_control);
+			udelay(AFE_REGISTER_WRITE_DELAY);
+
+			writel(cable_length_long ? 0x000002F4 : 0x000001F4,
+			       &xcvr->afe_channel_control);
 		}
 		udelay(AFE_REGISTER_WRITE_DELAY);
 
@@ -2012,7 +2054,16 @@ static void sci_controller_afe_initialization(struct isci_host *ihost)
 			udelay(AFE_REGISTER_WRITE_DELAY);
 		}
 
-		writel(0x00004100, &xcvr->afe_xcvr_control0);
+		if (is_a2(pdev) || is_b0(pdev))
+			/* RDPI=0x0(RX Power On), RXOOBDETPDNC=0x0,
+			 * TPD=0x0(TX Power On), RDD=0x0(RX Detect
+			 * Enabled) ....(0xe800)
+			 */
+			writel(0x00004100, &xcvr->afe_xcvr_control0);
+		else if (is_c0(pdev))
+			writel(0x00014100, &xcvr->afe_xcvr_control0);
+		else if (is_c1(pdev))
+			writel(0x0001C100, &xcvr->afe_xcvr_control0);
 		udelay(AFE_REGISTER_WRITE_DELAY);
 
 		/* Leave DFE/FFE on */
@@ -2023,13 +2074,29 @@ static void sci_controller_afe_initialization(struct isci_host *ihost)
 			udelay(AFE_REGISTER_WRITE_DELAY);
 			/* Enable TX equalization (0xe824) */
 			writel(0x00040000, &xcvr->afe_tx_control);
-		} else {
-			writel(0x0140DF0F, &xcvr->afe_rx_ssc_control1);
+		} else if (is_c0(pdev)) {
+			writel(0x01400C0F, &xcvr->afe_rx_ssc_control1);
 			udelay(AFE_REGISTER_WRITE_DELAY);
 
 			writel(0x3F6F103F, &xcvr->afe_rx_ssc_control0);
 			udelay(AFE_REGISTER_WRITE_DELAY);
 
+			/* Enable TX equalization (0xe824) */
+			writel(0x00040000, &xcvr->afe_tx_control);
+		} else if (is_c1(pdev)) {
+			writel(cable_length_long ? 0x01500C0C :
+			       cable_length_medium ? 0x01400C0D : 0x02400C0D,
+			       &xcvr->afe_xcvr_control1);
+			udelay(AFE_REGISTER_WRITE_DELAY);
+
+			writel(0x000003E0, &xcvr->afe_dfx_rx_control1);
+			udelay(AFE_REGISTER_WRITE_DELAY);
+
+			writel(cable_length_long ? 0x33091C1F :
+			       cable_length_medium ? 0x3315181F : 0x2B17161F,
+			       &xcvr->afe_rx_ssc_control0);
+			udelay(AFE_REGISTER_WRITE_DELAY);
+
 			/* Enable TX equalization (0xe824) */
 			writel(0x00040000, &xcvr->afe_tx_control);
 		}

commit 2e5da889d44a3a9629f895de3488306e7f5ddf16
Author: Dan Williams <dan.j.williams@intel.com>
Date:   Wed Jan 4 01:32:34 2012 -0800

    [SCSI] isci: cleanup oem parameter and recipe handling
    
    Before updating the code to support the latest platform updates and
    silicon revision cleanup some of the long deref chains.
    
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>
    Signed-off-by: James Bottomley <JBottomley@Parallels.com>

diff --git a/drivers/scsi/isci/host.c b/drivers/scsi/isci/host.c
index e7fe9c4c85b8..8e7de192cf6d 100644
--- a/drivers/scsi/isci/host.c
+++ b/drivers/scsi/isci/host.c
@@ -1910,160 +1910,147 @@ void sci_controller_power_control_queue_remove(struct isci_host *ihost,
 
 #define AFE_REGISTER_WRITE_DELAY 10
 
-/* Initialize the AFE for this phy index. We need to read the AFE setup from
- * the OEM parameters
- */
 static void sci_controller_afe_initialization(struct isci_host *ihost)
 {
+	struct scu_afe_registers __iomem *afe = &ihost->scu_registers->afe;
 	const struct sci_oem_params *oem = &ihost->oem_parameters;
 	struct pci_dev *pdev = ihost->pdev;
 	u32 afe_status;
 	u32 phy_id;
 
 	/* Clear DFX Status registers */
-	writel(0x0081000f, &ihost->scu_registers->afe.afe_dfx_master_control0);
+	writel(0x0081000f, &afe->afe_dfx_master_control0);
 	udelay(AFE_REGISTER_WRITE_DELAY);
 
 	if (is_b0(pdev)) {
 		/* PM Rx Equalization Save, PM SPhy Rx Acknowledgement
-		 * Timer, PM Stagger Timer */
-		writel(0x0007BFFF, &ihost->scu_registers->afe.afe_pmsn_master_control2);
+		 * Timer, PM Stagger Timer
+		 */
+		writel(0x0007BFFF, &afe->afe_pmsn_master_control2);
 		udelay(AFE_REGISTER_WRITE_DELAY);
 	}
 
 	/* Configure bias currents to normal */
 	if (is_a2(pdev))
-		writel(0x00005A00, &ihost->scu_registers->afe.afe_bias_control);
+		writel(0x00005A00, &afe->afe_bias_control);
 	else if (is_b0(pdev) || is_c0(pdev))
-		writel(0x00005F00, &ihost->scu_registers->afe.afe_bias_control);
+		writel(0x00005F00, &afe->afe_bias_control);
 
 	udelay(AFE_REGISTER_WRITE_DELAY);
 
 	/* Enable PLL */
 	if (is_b0(pdev) || is_c0(pdev))
-		writel(0x80040A08, &ihost->scu_registers->afe.afe_pll_control0);
+		writel(0x80040A08, &afe->afe_pll_control0);
 	else
-		writel(0x80040908, &ihost->scu_registers->afe.afe_pll_control0);
+		writel(0x80040908, &afe->afe_pll_control0);
 
 	udelay(AFE_REGISTER_WRITE_DELAY);
 
 	/* Wait for the PLL to lock */
 	do {
-		afe_status = readl(&ihost->scu_registers->afe.afe_common_block_status);
+		afe_status = readl(&afe->afe_common_block_status);
 		udelay(AFE_REGISTER_WRITE_DELAY);
 	} while ((afe_status & 0x00001000) == 0);
 
 	if (is_a2(pdev)) {
-		/* Shorten SAS SNW lock time (RxLock timer value from 76 us to 50 us) */
-		writel(0x7bcc96ad, &ihost->scu_registers->afe.afe_pmsn_master_control0);
+		/* Shorten SAS SNW lock time (RxLock timer value from 76
+		 * us to 50 us)
+		 */
+		writel(0x7bcc96ad, &afe->afe_pmsn_master_control0);
 		udelay(AFE_REGISTER_WRITE_DELAY);
 	}
 
 	for (phy_id = 0; phy_id < SCI_MAX_PHYS; phy_id++) {
+		struct scu_afe_transceiver *xcvr = &afe->scu_afe_xcvr[phy_id];
 		const struct sci_phy_oem_params *oem_phy = &oem->phys[phy_id];
 
 		if (is_b0(pdev)) {
 			 /* Configure transmitter SSC parameters */
-			writel(0x00030000, &ihost->scu_registers->afe.scu_afe_xcvr[phy_id].afe_tx_ssc_control);
+			writel(0x00030000, &xcvr->afe_tx_ssc_control);
 			udelay(AFE_REGISTER_WRITE_DELAY);
 		} else if (is_c0(pdev)) {
 			 /* Configure transmitter SSC parameters */
-			writel(0x0003000, &ihost->scu_registers->afe.scu_afe_xcvr[phy_id].afe_tx_ssc_control);
+			writel(0x0003000, &xcvr->afe_tx_ssc_control);
 			udelay(AFE_REGISTER_WRITE_DELAY);
 
-			/*
-			 * All defaults, except the Receive Word Alignament/Comma Detect
-			 * Enable....(0xe800) */
-			writel(0x00004500, &ihost->scu_registers->afe.scu_afe_xcvr[phy_id].afe_xcvr_control0);
+			/* All defaults, except the Receive Word
+			 * Alignament/Comma Detect Enable....(0xe800)
+			 */
+			writel(0x00004500, &xcvr->afe_xcvr_control0);
 			udelay(AFE_REGISTER_WRITE_DELAY);
 		} else {
-			/*
-			 * All defaults, except the Receive Word Alignament/Comma Detect
-			 * Enable....(0xe800) */
-			writel(0x00004512, &ihost->scu_registers->afe.scu_afe_xcvr[phy_id].afe_xcvr_control0);
+			/* All defaults, except the Receive Word
+			 * Alignament/Comma Detect Enable....(0xe800)
+			 */
+			writel(0x00004512, &xcvr->afe_xcvr_control0);
 			udelay(AFE_REGISTER_WRITE_DELAY);
 
-			writel(0x0050100F, &ihost->scu_registers->afe.scu_afe_xcvr[phy_id].afe_xcvr_control1);
+			writel(0x0050100F, &xcvr->afe_xcvr_control1);
 			udelay(AFE_REGISTER_WRITE_DELAY);
 		}
 
-		/*
-		 * Power up TX and RX out from power down (PWRDNTX and PWRDNRX)
-		 * & increase TX int & ext bias 20%....(0xe85c) */
+		/* Power up TX and RX out from power down (PWRDNTX and PWRDNRX)
+		 * & increase TX int & ext bias 20%....(0xe85c)
+		 */
 		if (is_a2(pdev))
-			writel(0x000003F0, &ihost->scu_registers->afe.scu_afe_xcvr[phy_id].afe_channel_control);
+			writel(0x000003F0, &xcvr->afe_channel_control);
 		else if (is_b0(pdev)) {
 			 /* Power down TX and RX (PWRDNTX and PWRDNRX) */
-			writel(0x000003D7, &ihost->scu_registers->afe.scu_afe_xcvr[phy_id].afe_channel_control);
+			writel(0x000003D7, &xcvr->afe_channel_control);
 			udelay(AFE_REGISTER_WRITE_DELAY);
-
-			/*
-			 * Power up TX and RX out from power down (PWRDNTX and PWRDNRX)
-			 * & increase TX int & ext bias 20%....(0xe85c) */
-			writel(0x000003D4, &ihost->scu_registers->afe.scu_afe_xcvr[phy_id].afe_channel_control);
+			writel(0x000003D4, &xcvr->afe_channel_control);
 		} else {
-			writel(0x000001E7, &ihost->scu_registers->afe.scu_afe_xcvr[phy_id].afe_channel_control);
+			writel(0x000001E7, &xcvr->afe_channel_control);
 			udelay(AFE_REGISTER_WRITE_DELAY);
-
-			/*
-			 * Power up TX and RX out from power down (PWRDNTX and PWRDNRX)
-			 * & increase TX int & ext bias 20%....(0xe85c) */
-			writel(0x000001E4, &ihost->scu_registers->afe.scu_afe_xcvr[phy_id].afe_channel_control);
+			writel(0x000001E4, &xcvr->afe_channel_control);
 		}
 		udelay(AFE_REGISTER_WRITE_DELAY);
 
 		if (is_a2(pdev)) {
 			/* Enable TX equalization (0xe824) */
-			writel(0x00040000, &ihost->scu_registers->afe.scu_afe_xcvr[phy_id].afe_tx_control);
+			writel(0x00040000, &xcvr->afe_tx_control);
 			udelay(AFE_REGISTER_WRITE_DELAY);
 		}
 
-		/*
-		 * RDPI=0x0(RX Power On), RXOOBDETPDNC=0x0, TPD=0x0(TX Power On),
-		 * RDD=0x0(RX Detect Enabled) ....(0xe800) */
-		writel(0x00004100, &ihost->scu_registers->afe.scu_afe_xcvr[phy_id].afe_xcvr_control0);
+		writel(0x00004100, &xcvr->afe_xcvr_control0);
 		udelay(AFE_REGISTER_WRITE_DELAY);
 
 		/* Leave DFE/FFE on */
 		if (is_a2(pdev))
-			writel(0x3F11103F, &ihost->scu_registers->afe.scu_afe_xcvr[phy_id].afe_rx_ssc_control0);
+			writel(0x3F11103F, &xcvr->afe_rx_ssc_control0);
 		else if (is_b0(pdev)) {
-			writel(0x3F11103F, &ihost->scu_registers->afe.scu_afe_xcvr[phy_id].afe_rx_ssc_control0);
+			writel(0x3F11103F, &xcvr->afe_rx_ssc_control0);
 			udelay(AFE_REGISTER_WRITE_DELAY);
 			/* Enable TX equalization (0xe824) */
-			writel(0x00040000, &ihost->scu_registers->afe.scu_afe_xcvr[phy_id].afe_tx_control);
+			writel(0x00040000, &xcvr->afe_tx_control);
 		} else {
-			writel(0x0140DF0F, &ihost->scu_registers->afe.scu_afe_xcvr[phy_id].afe_rx_ssc_control1);
+			writel(0x0140DF0F, &xcvr->afe_rx_ssc_control1);
 			udelay(AFE_REGISTER_WRITE_DELAY);
 
-			writel(0x3F6F103F, &ihost->scu_registers->afe.scu_afe_xcvr[phy_id].afe_rx_ssc_control0);
+			writel(0x3F6F103F, &xcvr->afe_rx_ssc_control0);
 			udelay(AFE_REGISTER_WRITE_DELAY);
 
 			/* Enable TX equalization (0xe824) */
-			writel(0x00040000, &ihost->scu_registers->afe.scu_afe_xcvr[phy_id].afe_tx_control);
+			writel(0x00040000, &xcvr->afe_tx_control);
 		}
 
 		udelay(AFE_REGISTER_WRITE_DELAY);
 
-		writel(oem_phy->afe_tx_amp_control0,
-			&ihost->scu_registers->afe.scu_afe_xcvr[phy_id].afe_tx_amp_control0);
+		writel(oem_phy->afe_tx_amp_control0, &xcvr->afe_tx_amp_control0);
 		udelay(AFE_REGISTER_WRITE_DELAY);
 
-		writel(oem_phy->afe_tx_amp_control1,
-			&ihost->scu_registers->afe.scu_afe_xcvr[phy_id].afe_tx_amp_control1);
+		writel(oem_phy->afe_tx_amp_control1, &xcvr->afe_tx_amp_control1);
 		udelay(AFE_REGISTER_WRITE_DELAY);
 
-		writel(oem_phy->afe_tx_amp_control2,
-			&ihost->scu_registers->afe.scu_afe_xcvr[phy_id].afe_tx_amp_control2);
+		writel(oem_phy->afe_tx_amp_control2, &xcvr->afe_tx_amp_control2);
 		udelay(AFE_REGISTER_WRITE_DELAY);
 
-		writel(oem_phy->afe_tx_amp_control3,
-			&ihost->scu_registers->afe.scu_afe_xcvr[phy_id].afe_tx_amp_control3);
+		writel(oem_phy->afe_tx_amp_control3, &xcvr->afe_tx_amp_control3);
 		udelay(AFE_REGISTER_WRITE_DELAY);
 	}
 
 	/* Transfer control to the PEs */
-	writel(0x00010f00, &ihost->scu_registers->afe.afe_dfx_master_control0);
+	writel(0x00010f00, &afe->afe_dfx_master_control0);
 	udelay(AFE_REGISTER_WRITE_DELAY);
 }
 

commit 7000f7c71e2457391e3249eac1ae53c91f49a8c0
Author: Andrzej Jakowski <andrzej.jakowski@intel.com>
Date:   Thu Oct 27 15:05:42 2011 -0700

    [SCSI] isci: overriding max_concurr_spinup oem parameter by max(oem, user)
    
    Fixes bug where max_concurr_spinup oem parameter should be
    overriden by max_concurr_spinup user parameter. Override should
    happen only when max_concurr_spinup user parameter is specified
    in command line (greater than 0). Also this fix shortens variables
    representing max_conxurr_spinup for oem and user parameters.
    
    Signed-off-by: Andrzej Jakowski <andrzej.jakowski@intel.com>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>
    Signed-off-by: James Bottomley <JBottomley@Parallels.com>

diff --git a/drivers/scsi/isci/host.c b/drivers/scsi/isci/host.c
index f07f30fada1b..e7fe9c4c85b8 100644
--- a/drivers/scsi/isci/host.c
+++ b/drivers/scsi/isci/host.c
@@ -1350,7 +1350,7 @@ static void isci_user_parameters_get(struct sci_user_parameters *u)
 	u->stp_max_occupancy_timeout = stp_max_occ_to;
 	u->ssp_max_occupancy_timeout = ssp_max_occ_to;
 	u->no_outbound_task_timeout = no_outbound_task_to;
-	u->max_number_concurrent_device_spin_up = max_concurr_spinup;
+	u->max_concurr_spinup = max_concurr_spinup;
 }
 
 static void sci_controller_initial_state_enter(struct sci_base_state_machine *sm)
@@ -1661,7 +1661,7 @@ static void sci_controller_set_default_config_parameters(struct isci_host *ihost
 	ihost->oem_parameters.controller.mode_type = SCIC_PORT_AUTOMATIC_CONFIGURATION_MODE;
 
 	/* Default to APC mode. */
-	ihost->oem_parameters.controller.max_concurrent_dev_spin_up = 1;
+	ihost->oem_parameters.controller.max_concurr_spin_up = 1;
 
 	/* Default to no SSC operation. */
 	ihost->oem_parameters.controller.do_enable_ssc = false;
@@ -1787,7 +1787,8 @@ int sci_oem_parameters_validate(struct sci_oem_params *oem)
 	} else
 		return -EINVAL;
 
-	if (oem->controller.max_concurrent_dev_spin_up > MAX_CONCURRENT_DEVICE_SPIN_UP_COUNT)
+	if (oem->controller.max_concurr_spin_up > MAX_CONCURRENT_DEVICE_SPIN_UP_COUNT ||
+	    oem->controller.max_concurr_spin_up < 1)
 		return -EINVAL;
 
 	return 0;
@@ -1810,6 +1811,16 @@ static enum sci_status sci_oem_parameters_set(struct isci_host *ihost)
 	return SCI_FAILURE_INVALID_STATE;
 }
 
+static u8 max_spin_up(struct isci_host *ihost)
+{
+	if (ihost->user_parameters.max_concurr_spinup)
+		return min_t(u8, ihost->user_parameters.max_concurr_spinup,
+			     MAX_CONCURRENT_DEVICE_SPIN_UP_COUNT);
+	else
+		return min_t(u8, ihost->oem_parameters.controller.max_concurr_spin_up,
+			     MAX_CONCURRENT_DEVICE_SPIN_UP_COUNT);
+}
+
 static void power_control_timeout(unsigned long data)
 {
 	struct sci_timer *tmr = (struct sci_timer *)data;
@@ -1839,8 +1850,7 @@ static void power_control_timeout(unsigned long data)
 		if (iphy == NULL)
 			continue;
 
-		if (ihost->power_control.phys_granted_power >=
-		    ihost->oem_parameters.controller.max_concurrent_dev_spin_up)
+		if (ihost->power_control.phys_granted_power >= max_spin_up(ihost))
 			break;
 
 		ihost->power_control.requesters[i] = NULL;
@@ -1865,8 +1875,7 @@ void sci_controller_power_control_queue_insert(struct isci_host *ihost,
 {
 	BUG_ON(iphy == NULL);
 
-	if (ihost->power_control.phys_granted_power <
-	    ihost->oem_parameters.controller.max_concurrent_dev_spin_up) {
+	if (ihost->power_control.phys_granted_power < max_spin_up(ihost)) {
 		ihost->power_control.phys_granted_power++;
 		sci_phy_consume_power_handler(iphy);
 

commit ad4f4c1de80abdda5d55315289505598aa78e355
Author: Dan Williams <dan.j.williams@intel.com>
Date:   Thu Sep 1 21:18:31 2011 -0700

    [SCSI] isci: initial sgpio write support
    
    Basic support to initialize the gpio unit, accept an incomming
    SAS_GPIO_REG_TX_GP bitstream, and translate it to the ODx.n fields in
    the hardware registers.  If register indexes outside the supported range
    are specified in the SMP frame we simply accept the write and return how
    many registers (SFF-8485) were written (libsas reports this as residue
    in the request).
    
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>
    Signed-off-by: James Bottomley <JBottomley@Parallels.com>

diff --git a/drivers/scsi/isci/host.c b/drivers/scsi/isci/host.c
index 6981b773a88d..f07f30fada1b 100644
--- a/drivers/scsi/isci/host.c
+++ b/drivers/scsi/isci/host.c
@@ -1263,6 +1263,10 @@ void isci_host_deinit(struct isci_host *ihost)
 {
 	int i;
 
+	/* disable output data selects */
+	for (i = 0; i < isci_gpio_count(ihost); i++)
+		writel(SGPIO_HW_CONTROL, &ihost->scu_registers->peg0.sgpio.output_data_select[i]);
+
 	isci_host_change_state(ihost, isci_stopping);
 	for (i = 0; i < SCI_MAX_PORTS; i++) {
 		struct isci_port *iport = &ihost->ports[i];
@@ -1281,6 +1285,12 @@ void isci_host_deinit(struct isci_host *ihost)
 	spin_unlock_irq(&ihost->scic_lock);
 
 	wait_for_stop(ihost);
+
+	/* disable sgpio: where the above wait should give time for the
+	 * enclosure to sample the gpios going inactive
+	 */
+	writel(0, &ihost->scu_registers->peg0.sgpio.interface_control);
+
 	sci_controller_reset(ihost);
 
 	/* Cancel any/all outstanding port timers */
@@ -2365,6 +2375,12 @@ int isci_host_init(struct isci_host *ihost)
 	for (i = 0; i < SCI_MAX_PHYS; i++)
 		isci_phy_init(&ihost->phys[i], ihost, i);
 
+	/* enable sgpio */
+	writel(1, &ihost->scu_registers->peg0.sgpio.interface_control);
+	for (i = 0; i < isci_gpio_count(ihost); i++)
+		writel(SGPIO_HW_CONTROL, &ihost->scu_registers->peg0.sgpio.output_data_select[i]);
+	writel(0, &ihost->scu_registers->peg0.sgpio.vendor_specific_code);
+
 	for (i = 0; i < SCI_MAX_REMOTE_DEVICES; i++) {
 		struct isci_remote_device *idev = &ihost->devices[i];
 
@@ -2760,3 +2776,56 @@ enum sci_task_status sci_controller_start_task(struct isci_host *ihost,
 
 	return status;
 }
+
+static int sci_write_gpio_tx_gp(struct isci_host *ihost, u8 reg_index, u8 reg_count, u8 *write_data)
+{
+	int d;
+
+	/* no support for TX_GP_CFG */
+	if (reg_index == 0)
+		return -EINVAL;
+
+	for (d = 0; d < isci_gpio_count(ihost); d++) {
+		u32 val = 0x444; /* all ODx.n clear */
+		int i;
+
+		for (i = 0; i < 3; i++) {
+			int bit = (i << 2) + 2;
+
+			bit = try_test_sas_gpio_gp_bit(to_sas_gpio_od(d, i),
+						       write_data, reg_index,
+						       reg_count);
+			if (bit < 0)
+				break;
+
+			/* if od is set, clear the 'invert' bit */
+			val &= ~(bit << ((i << 2) + 2));
+		}
+
+		if (i < 3)
+			break;
+		writel(val, &ihost->scu_registers->peg0.sgpio.output_data_select[d]);
+	}
+
+	/* unless reg_index is > 1, we should always be able to write at
+	 * least one register
+	 */
+	return d > 0;
+}
+
+int isci_gpio_write(struct sas_ha_struct *sas_ha, u8 reg_type, u8 reg_index,
+		    u8 reg_count, u8 *write_data)
+{
+	struct isci_host *ihost = sas_ha->lldd_ha;
+	int written;
+
+	switch (reg_type) {
+	case SAS_GPIO_REG_TX_GP:
+		written = sci_write_gpio_tx_gp(ihost, reg_index, reg_count, write_data);
+		break;
+	default:
+		written = -EINVAL;
+	}
+
+	return written;
+}

commit 77cd72a53f6426f81b7f56a862402849ee903bda
Author: Dan Williams <dan.j.williams@intel.com>
Date:   Fri Jul 29 17:17:16 2011 -0700

    [SCSI] isci: fix event-get pointer increment
    
    Hardware only increments the put pointer on event types >= 4.  Do not
    increment the get pointer for event type 3.
    
    Reported-by: Kapil Karkra <kapil.karkra@intel.com>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>
    Signed-off-by: James Bottomley <JBottomley@Parallels.com>

diff --git a/drivers/scsi/isci/host.c b/drivers/scsi/isci/host.c
index 2328f98c7f1e..6981b773a88d 100644
--- a/drivers/scsi/isci/host.c
+++ b/drivers/scsi/isci/host.c
@@ -531,6 +531,9 @@ static void sci_controller_process_completions(struct isci_host *ihost)
 			break;
 
 		case SCU_COMPLETION_TYPE_EVENT:
+			sci_controller_event_completion(ihost, ent);
+			break;
+
 		case SCU_COMPLETION_TYPE_NOTIFY: {
 			event_cycle ^= ((event_get+1) & SCU_MAX_EVENTS) <<
 				       (SMU_COMPLETION_QUEUE_GET_EVENT_CYCLE_BIT_SHIFT - SCU_MAX_EVENTS_SHIFT);

commit 9b4be528999483d70a1ffc0accd102e477d5a503
Author: Dan Williams <dan.j.williams@intel.com>
Date:   Fri Jul 29 17:17:10 2011 -0700

    [SCSI] isci: dynamic interrupt coalescing
    
    Hardware allows both an outstanding number commands and a timeout value
    (whichever occurs first) as a gate to the next interrupt generation.  This
    scheme at completion time looks at the remaining number of outstanding tasks
    and sets the timeout to maximize small transaction operation.  If transactions
    are large (take more than a few 10s of microseconds to complete) then
    performance is not interrupt processing bound, so the small timeouts this
    scheme generates are overridden by the time it takes for a completion to
    arrive.
    
    Tested-by: Dave Jiang <dave.jiang@intel.com>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>
    Signed-off-by: James Bottomley <JBottomley@Parallels.com>

diff --git a/drivers/scsi/isci/host.c b/drivers/scsi/isci/host.c
index 26072f1e9852..2328f98c7f1e 100644
--- a/drivers/scsi/isci/host.c
+++ b/drivers/scsi/isci/host.c
@@ -1091,6 +1091,7 @@ static void isci_host_completion_routine(unsigned long data)
 	struct isci_request *request;
 	struct isci_request *next_request;
 	struct sas_task     *task;
+	u16 active;
 
 	INIT_LIST_HEAD(&completed_request_list);
 	INIT_LIST_HEAD(&errored_request_list);
@@ -1181,6 +1182,13 @@ static void isci_host_completion_routine(unsigned long data)
 		}
 	}
 
+	/* the coalesence timeout doubles at each encoding step, so
+	 * update it based on the ilog2 value of the outstanding requests
+	 */
+	active = isci_tci_active(ihost);
+	writel(SMU_ICC_GEN_VAL(NUMBER, active) |
+	       SMU_ICC_GEN_VAL(TIMER, ISCI_COALESCE_BASE + ilog2(active)),
+	       &ihost->smu_registers->interrupt_coalesce_control);
 }
 
 /**
@@ -1471,7 +1479,7 @@ static void sci_controller_ready_state_enter(struct sci_base_state_machine *sm)
 	struct isci_host *ihost = container_of(sm, typeof(*ihost), sm);
 
 	/* set the default interrupt coalescence number and timeout value. */
-	sci_controller_set_interrupt_coalescence(ihost, 0x10, 250);
+	sci_controller_set_interrupt_coalescence(ihost, 0, 0);
 }
 
 static void sci_controller_ready_state_exit(struct sci_base_state_machine *sm)

commit dc00c8b6940aa10ab1ce6a4d10b1bfe7b848781b
Author: Dan Williams <dan.j.williams@intel.com>
Date:   Fri Jul 1 11:41:21 2011 -0700

    isci: cleanup silicon revision detection
    
    Perform checking per-pci device (even though all systems will only have
    1 pci device in this generation), and delete support for silicon that
    does not report a proper revision (i.e. A0).
    
    Reported-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/drivers/scsi/isci/host.c b/drivers/scsi/isci/host.c
index b554ea271ba6..26072f1e9852 100644
--- a/drivers/scsi/isci/host.c
+++ b/drivers/scsi/isci/host.c
@@ -1886,6 +1886,7 @@ void sci_controller_power_control_queue_remove(struct isci_host *ihost,
 static void sci_controller_afe_initialization(struct isci_host *ihost)
 {
 	const struct sci_oem_params *oem = &ihost->oem_parameters;
+	struct pci_dev *pdev = ihost->pdev;
 	u32 afe_status;
 	u32 phy_id;
 
@@ -1893,7 +1894,7 @@ static void sci_controller_afe_initialization(struct isci_host *ihost)
 	writel(0x0081000f, &ihost->scu_registers->afe.afe_dfx_master_control0);
 	udelay(AFE_REGISTER_WRITE_DELAY);
 
-	if (is_b0()) {
+	if (is_b0(pdev)) {
 		/* PM Rx Equalization Save, PM SPhy Rx Acknowledgement
 		 * Timer, PM Stagger Timer */
 		writel(0x0007BFFF, &ihost->scu_registers->afe.afe_pmsn_master_control2);
@@ -1901,17 +1902,15 @@ static void sci_controller_afe_initialization(struct isci_host *ihost)
 	}
 
 	/* Configure bias currents to normal */
-	if (is_a0())
-		writel(0x00005500, &ihost->scu_registers->afe.afe_bias_control);
-	else if (is_a2())
+	if (is_a2(pdev))
 		writel(0x00005A00, &ihost->scu_registers->afe.afe_bias_control);
-	else if (is_b0() || is_c0())
+	else if (is_b0(pdev) || is_c0(pdev))
 		writel(0x00005F00, &ihost->scu_registers->afe.afe_bias_control);
 
 	udelay(AFE_REGISTER_WRITE_DELAY);
 
 	/* Enable PLL */
-	if (is_b0() || is_c0())
+	if (is_b0(pdev) || is_c0(pdev))
 		writel(0x80040A08, &ihost->scu_registers->afe.afe_pll_control0);
 	else
 		writel(0x80040908, &ihost->scu_registers->afe.afe_pll_control0);
@@ -1924,7 +1923,7 @@ static void sci_controller_afe_initialization(struct isci_host *ihost)
 		udelay(AFE_REGISTER_WRITE_DELAY);
 	} while ((afe_status & 0x00001000) == 0);
 
-	if (is_a0() || is_a2()) {
+	if (is_a2(pdev)) {
 		/* Shorten SAS SNW lock time (RxLock timer value from 76 us to 50 us) */
 		writel(0x7bcc96ad, &ihost->scu_registers->afe.afe_pmsn_master_control0);
 		udelay(AFE_REGISTER_WRITE_DELAY);
@@ -1933,11 +1932,11 @@ static void sci_controller_afe_initialization(struct isci_host *ihost)
 	for (phy_id = 0; phy_id < SCI_MAX_PHYS; phy_id++) {
 		const struct sci_phy_oem_params *oem_phy = &oem->phys[phy_id];
 
-		if (is_b0()) {
+		if (is_b0(pdev)) {
 			 /* Configure transmitter SSC parameters */
 			writel(0x00030000, &ihost->scu_registers->afe.scu_afe_xcvr[phy_id].afe_tx_ssc_control);
 			udelay(AFE_REGISTER_WRITE_DELAY);
-		} else if (is_c0()) {
+		} else if (is_c0(pdev)) {
 			 /* Configure transmitter SSC parameters */
 			writel(0x0003000, &ihost->scu_registers->afe.scu_afe_xcvr[phy_id].afe_tx_ssc_control);
 			udelay(AFE_REGISTER_WRITE_DELAY);
@@ -1961,11 +1960,9 @@ static void sci_controller_afe_initialization(struct isci_host *ihost)
 		/*
 		 * Power up TX and RX out from power down (PWRDNTX and PWRDNRX)
 		 * & increase TX int & ext bias 20%....(0xe85c) */
-		if (is_a0())
-			writel(0x000003D4, &ihost->scu_registers->afe.scu_afe_xcvr[phy_id].afe_channel_control);
-		else if (is_a2())
+		if (is_a2(pdev))
 			writel(0x000003F0, &ihost->scu_registers->afe.scu_afe_xcvr[phy_id].afe_channel_control);
-		else if (is_b0()) {
+		else if (is_b0(pdev)) {
 			 /* Power down TX and RX (PWRDNTX and PWRDNRX) */
 			writel(0x000003D7, &ihost->scu_registers->afe.scu_afe_xcvr[phy_id].afe_channel_control);
 			udelay(AFE_REGISTER_WRITE_DELAY);
@@ -1985,7 +1982,7 @@ static void sci_controller_afe_initialization(struct isci_host *ihost)
 		}
 		udelay(AFE_REGISTER_WRITE_DELAY);
 
-		if (is_a0() || is_a2()) {
+		if (is_a2(pdev)) {
 			/* Enable TX equalization (0xe824) */
 			writel(0x00040000, &ihost->scu_registers->afe.scu_afe_xcvr[phy_id].afe_tx_control);
 			udelay(AFE_REGISTER_WRITE_DELAY);
@@ -1998,11 +1995,9 @@ static void sci_controller_afe_initialization(struct isci_host *ihost)
 		udelay(AFE_REGISTER_WRITE_DELAY);
 
 		/* Leave DFE/FFE on */
-		if (is_a0())
-			writel(0x3F09983F, &ihost->scu_registers->afe.scu_afe_xcvr[phy_id].afe_rx_ssc_control0);
-		else if (is_a2())
+		if (is_a2(pdev))
 			writel(0x3F11103F, &ihost->scu_registers->afe.scu_afe_xcvr[phy_id].afe_rx_ssc_control0);
-		else if (is_b0()) {
+		else if (is_b0(pdev)) {
 			writel(0x3F11103F, &ihost->scu_registers->afe.scu_afe_xcvr[phy_id].afe_rx_ssc_control0);
 			udelay(AFE_REGISTER_WRITE_DELAY);
 			/* Enable TX equalization (0xe824) */

commit 4e4dca3de9658f364d34924e072f2b64e5c3d267
Author: Dan Williams <dan.j.williams@intel.com>
Date:   Fri Jul 1 11:15:12 2011 -0700

    isci: merge scu_unsolicited_frame.h into unsolicited_frame_control.h
    
    Does not need its own file.
    
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/drivers/scsi/isci/host.c b/drivers/scsi/isci/host.c
index 88e731333532..b554ea271ba6 100644
--- a/drivers/scsi/isci/host.c
+++ b/drivers/scsi/isci/host.c
@@ -67,7 +67,6 @@
 #include "registers.h"
 #include "scu_remote_node_context.h"
 #include "scu_task_context.h"
-#include "scu_unsolicited_frame.h"
 
 #define SCU_CONTEXT_RAM_INIT_STALL_TIME      200
 

commit 34a991587a5cc9f78960c2c9beea217866458c41
Author: Dan Williams <dan.j.williams@intel.com>
Date:   Fri Jul 1 02:25:15 2011 -0700

    isci: kill 'get/set' macros
    
    Most of these simple dereference macros are longer than their open coded
    equivalent.  Deleting enum sci_controller_mode is thrown in for good
    measure.
    
    Reported-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/drivers/scsi/isci/host.c b/drivers/scsi/isci/host.c
index f31f64e4b713..88e731333532 100644
--- a/drivers/scsi/isci/host.c
+++ b/drivers/scsi/isci/host.c
@@ -2627,7 +2627,7 @@ enum sci_status sci_controller_start_io(struct isci_host *ihost,
 		return status;
 
 	set_bit(IREQ_ACTIVE, &ireq->flags);
-	sci_controller_post_request(ihost, sci_request_get_post_context(ireq));
+	sci_controller_post_request(ihost, ireq->post_context);
 	return SCI_SUCCESS;
 }
 
@@ -2707,7 +2707,7 @@ enum sci_status sci_controller_continue_io(struct isci_request *ireq)
 	}
 
 	set_bit(IREQ_ACTIVE, &ireq->flags);
-	sci_controller_post_request(ihost, sci_request_get_post_context(ireq));
+	sci_controller_post_request(ihost, ireq->post_context);
 	return SCI_SUCCESS;
 }
 
@@ -2747,9 +2747,7 @@ enum sci_task_status sci_controller_start_task(struct isci_host *ihost,
 		return SCI_SUCCESS;
 	case SCI_SUCCESS:
 		set_bit(IREQ_ACTIVE, &ireq->flags);
-
-		sci_controller_post_request(ihost,
-			sci_request_get_post_context(ireq));
+		sci_controller_post_request(ihost, ireq->post_context);
 		break;
 	default:
 		break;

commit 89a7301f21fb00e753089671eb9e4132aab8ea08
Author: Dan Williams <dan.j.williams@intel.com>
Date:   Thu Jun 30 19:14:33 2011 -0700

    isci: retire scic_sds_ and scic_ prefixes
    
    The distinction between scic_sds_ scic_ and sci_ are no longer relevant
    so just unify the prefixes on sci_.  The distinction between isci_ and
    sci_ is historically significant, and useful for comparing the old
    'core' to the current Linux driver. 'sci_' represents the former core as
    well as the routines that are closer to the hardware and protocol than
    their 'isci_' brethren. sci == sas controller interface.
    
    Also unwind the 'sds1' out of the parameter structs.
    
    Reported-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/drivers/scsi/isci/host.c b/drivers/scsi/isci/host.c
index bb298f8f609a..f31f64e4b713 100644
--- a/drivers/scsi/isci/host.c
+++ b/drivers/scsi/isci/host.c
@@ -180,8 +180,7 @@ void sci_change_state(struct sci_base_state_machine *sm, u32 next_state)
 		handler(sm);
 }
 
-static bool scic_sds_controller_completion_queue_has_entries(
-	struct isci_host *ihost)
+static bool sci_controller_completion_queue_has_entries(struct isci_host *ihost)
 {
 	u32 get_value = ihost->completion_queue_get;
 	u32 get_index = get_value & SMU_COMPLETION_QUEUE_GET_POINTER_MASK;
@@ -193,9 +192,9 @@ static bool scic_sds_controller_completion_queue_has_entries(
 	return false;
 }
 
-static bool scic_sds_controller_isr(struct isci_host *ihost)
+static bool sci_controller_isr(struct isci_host *ihost)
 {
-	if (scic_sds_controller_completion_queue_has_entries(ihost)) {
+	if (sci_controller_completion_queue_has_entries(ihost)) {
 		return true;
 	} else {
 		/*
@@ -219,13 +218,13 @@ irqreturn_t isci_msix_isr(int vec, void *data)
 {
 	struct isci_host *ihost = data;
 
-	if (scic_sds_controller_isr(ihost))
+	if (sci_controller_isr(ihost))
 		tasklet_schedule(&ihost->completion_tasklet);
 
 	return IRQ_HANDLED;
 }
 
-static bool scic_sds_controller_error_isr(struct isci_host *ihost)
+static bool sci_controller_error_isr(struct isci_host *ihost)
 {
 	u32 interrupt_status;
 
@@ -252,35 +251,35 @@ static bool scic_sds_controller_error_isr(struct isci_host *ihost)
 	return false;
 }
 
-static void scic_sds_controller_task_completion(struct isci_host *ihost,
-						u32 completion_entry)
+static void sci_controller_task_completion(struct isci_host *ihost, u32 ent)
 {
-	u32 index = SCU_GET_COMPLETION_INDEX(completion_entry);
+	u32 index = SCU_GET_COMPLETION_INDEX(ent);
 	struct isci_request *ireq = ihost->reqs[index];
 
 	/* Make sure that we really want to process this IO request */
 	if (test_bit(IREQ_ACTIVE, &ireq->flags) &&
 	    ireq->io_tag != SCI_CONTROLLER_INVALID_IO_TAG &&
 	    ISCI_TAG_SEQ(ireq->io_tag) == ihost->io_request_sequence[index])
-		/* Yep this is a valid io request pass it along to the io request handler */
-		scic_sds_io_request_tc_completion(ireq, completion_entry);
+		/* Yep this is a valid io request pass it along to the
+		 * io request handler
+		 */
+		sci_io_request_tc_completion(ireq, ent);
 }
 
-static void scic_sds_controller_sdma_completion(struct isci_host *ihost,
-						u32 completion_entry)
+static void sci_controller_sdma_completion(struct isci_host *ihost, u32 ent)
 {
 	u32 index;
 	struct isci_request *ireq;
 	struct isci_remote_device *idev;
 
-	index = SCU_GET_COMPLETION_INDEX(completion_entry);
+	index = SCU_GET_COMPLETION_INDEX(ent);
 
-	switch (scu_get_command_request_type(completion_entry)) {
+	switch (scu_get_command_request_type(ent)) {
 	case SCU_CONTEXT_COMMAND_REQUEST_TYPE_POST_TC:
 	case SCU_CONTEXT_COMMAND_REQUEST_TYPE_DUMP_TC:
 		ireq = ihost->reqs[index];
 		dev_warn(&ihost->pdev->dev, "%s: %x for io request %p\n",
-			 __func__, completion_entry, ireq);
+			 __func__, ent, ireq);
 		/* @todo For a post TC operation we need to fail the IO
 		 * request
 		 */
@@ -290,20 +289,19 @@ static void scic_sds_controller_sdma_completion(struct isci_host *ihost,
 	case SCU_CONTEXT_COMMAND_REQUEST_TYPE_POST_RNC:
 		idev = ihost->device_table[index];
 		dev_warn(&ihost->pdev->dev, "%s: %x for device %p\n",
-			 __func__, completion_entry, idev);
+			 __func__, ent, idev);
 		/* @todo For a port RNC operation we need to fail the
 		 * device
 		 */
 		break;
 	default:
 		dev_warn(&ihost->pdev->dev, "%s: unknown completion type %x\n",
-			 __func__, completion_entry);
+			 __func__, ent);
 		break;
 	}
 }
 
-static void scic_sds_controller_unsolicited_frame(struct isci_host *ihost,
-						  u32 completion_entry)
+static void sci_controller_unsolicited_frame(struct isci_host *ihost, u32 ent)
 {
 	u32 index;
 	u32 frame_index;
@@ -314,36 +312,36 @@ static void scic_sds_controller_unsolicited_frame(struct isci_host *ihost,
 
 	enum sci_status result = SCI_FAILURE;
 
-	frame_index = SCU_GET_FRAME_INDEX(completion_entry);
+	frame_index = SCU_GET_FRAME_INDEX(ent);
 
 	frame_header = ihost->uf_control.buffers.array[frame_index].header;
 	ihost->uf_control.buffers.array[frame_index].state = UNSOLICITED_FRAME_IN_USE;
 
-	if (SCU_GET_FRAME_ERROR(completion_entry)) {
+	if (SCU_GET_FRAME_ERROR(ent)) {
 		/*
 		 * / @todo If the IAF frame or SIGNATURE FIS frame has an error will
 		 * /       this cause a problem? We expect the phy initialization will
 		 * /       fail if there is an error in the frame. */
-		scic_sds_controller_release_frame(ihost, frame_index);
+		sci_controller_release_frame(ihost, frame_index);
 		return;
 	}
 
 	if (frame_header->is_address_frame) {
-		index = SCU_GET_PROTOCOL_ENGINE_INDEX(completion_entry);
+		index = SCU_GET_PROTOCOL_ENGINE_INDEX(ent);
 		iphy = &ihost->phys[index];
-		result = scic_sds_phy_frame_handler(iphy, frame_index);
+		result = sci_phy_frame_handler(iphy, frame_index);
 	} else {
 
-		index = SCU_GET_COMPLETION_INDEX(completion_entry);
+		index = SCU_GET_COMPLETION_INDEX(ent);
 
 		if (index == SCIC_SDS_REMOTE_NODE_CONTEXT_INVALID_INDEX) {
 			/*
 			 * This is a signature fis or a frame from a direct attached SATA
 			 * device that has not yet been created.  In either case forwared
 			 * the frame to the PE and let it take care of the frame data. */
-			index = SCU_GET_PROTOCOL_ENGINE_INDEX(completion_entry);
+			index = SCU_GET_PROTOCOL_ENGINE_INDEX(ent);
 			iphy = &ihost->phys[index];
-			result = scic_sds_phy_frame_handler(iphy, frame_index);
+			result = sci_phy_frame_handler(iphy, frame_index);
 		} else {
 			if (index < ihost->remote_node_entries)
 				idev = ihost->device_table[index];
@@ -351,9 +349,9 @@ static void scic_sds_controller_unsolicited_frame(struct isci_host *ihost,
 				idev = NULL;
 
 			if (idev != NULL)
-				result = scic_sds_remote_device_frame_handler(idev, frame_index);
+				result = sci_remote_device_frame_handler(idev, frame_index);
 			else
-				scic_sds_controller_release_frame(ihost, frame_index);
+				sci_controller_release_frame(ihost, frame_index);
 		}
 	}
 
@@ -364,17 +362,16 @@ static void scic_sds_controller_unsolicited_frame(struct isci_host *ihost,
 	}
 }
 
-static void scic_sds_controller_event_completion(struct isci_host *ihost,
-						 u32 completion_entry)
+static void sci_controller_event_completion(struct isci_host *ihost, u32 ent)
 {
 	struct isci_remote_device *idev;
 	struct isci_request *ireq;
 	struct isci_phy *iphy;
 	u32 index;
 
-	index = SCU_GET_COMPLETION_INDEX(completion_entry);
+	index = SCU_GET_COMPLETION_INDEX(ent);
 
-	switch (scu_get_event_type(completion_entry)) {
+	switch (scu_get_event_type(ent)) {
 	case SCU_EVENT_TYPE_SMU_COMMAND_ERROR:
 		/* / @todo The driver did something wrong and we need to fix the condtion. */
 		dev_err(&ihost->pdev->dev,
@@ -382,7 +379,7 @@ static void scic_sds_controller_event_completion(struct isci_host *ihost,
 			"0x%x\n",
 			__func__,
 			ihost,
-			completion_entry);
+			ent);
 		break;
 
 	case SCU_EVENT_TYPE_SMU_PCQ_ERROR:
@@ -396,21 +393,21 @@ static void scic_sds_controller_event_completion(struct isci_host *ihost,
 			"event  0x%x\n",
 			__func__,
 			ihost,
-			completion_entry);
+			ent);
 		break;
 
 	case SCU_EVENT_TYPE_TRANSPORT_ERROR:
 		ireq = ihost->reqs[index];
-		scic_sds_io_request_event_handler(ireq, completion_entry);
+		sci_io_request_event_handler(ireq, ent);
 		break;
 
 	case SCU_EVENT_TYPE_PTX_SCHEDULE_EVENT:
-		switch (scu_get_event_specifier(completion_entry)) {
+		switch (scu_get_event_specifier(ent)) {
 		case SCU_EVENT_SPECIFIC_SMP_RESPONSE_NO_PE:
 		case SCU_EVENT_SPECIFIC_TASK_TIMEOUT:
 			ireq = ihost->reqs[index];
 			if (ireq != NULL)
-				scic_sds_io_request_event_handler(ireq, completion_entry);
+				sci_io_request_event_handler(ireq, ent);
 			else
 				dev_warn(&ihost->pdev->dev,
 					 "%s: SCIC Controller 0x%p received "
@@ -418,14 +415,14 @@ static void scic_sds_controller_event_completion(struct isci_host *ihost,
 					 "that doesnt exist.\n",
 					 __func__,
 					 ihost,
-					 completion_entry);
+					 ent);
 
 			break;
 
 		case SCU_EVENT_SPECIFIC_IT_NEXUS_TIMEOUT:
 			idev = ihost->device_table[index];
 			if (idev != NULL)
-				scic_sds_remote_device_event_handler(idev, completion_entry);
+				sci_remote_device_event_handler(idev, ent);
 			else
 				dev_warn(&ihost->pdev->dev,
 					 "%s: SCIC Controller 0x%p received "
@@ -433,7 +430,7 @@ static void scic_sds_controller_event_completion(struct isci_host *ihost,
 					 "that doesnt exist.\n",
 					 __func__,
 					 ihost,
-					 completion_entry);
+					 ent);
 
 			break;
 		}
@@ -448,9 +445,9 @@ static void scic_sds_controller_event_completion(struct isci_host *ihost,
 	 * direct error counter event to the phy object since that is where
 	 * we get the event notification.  This is a type 4 event. */
 	case SCU_EVENT_TYPE_OSSP_EVENT:
-		index = SCU_GET_PROTOCOL_ENGINE_INDEX(completion_entry);
+		index = SCU_GET_PROTOCOL_ENGINE_INDEX(ent);
 		iphy = &ihost->phys[index];
-		scic_sds_phy_event_handler(iphy, completion_entry);
+		sci_phy_event_handler(iphy, ent);
 		break;
 
 	case SCU_EVENT_TYPE_RNC_SUSPEND_TX:
@@ -460,7 +457,7 @@ static void scic_sds_controller_event_completion(struct isci_host *ihost,
 			idev = ihost->device_table[index];
 
 			if (idev != NULL)
-				scic_sds_remote_device_event_handler(idev, completion_entry);
+				sci_remote_device_event_handler(idev, ent);
 		} else
 			dev_err(&ihost->pdev->dev,
 				"%s: SCIC Controller 0x%p received event 0x%x "
@@ -468,7 +465,7 @@ static void scic_sds_controller_event_completion(struct isci_host *ihost,
 				"exist.\n",
 				__func__,
 				ihost,
-				completion_entry,
+				ent,
 				index);
 
 		break;
@@ -477,15 +474,15 @@ static void scic_sds_controller_event_completion(struct isci_host *ihost,
 		dev_warn(&ihost->pdev->dev,
 			 "%s: SCIC Controller received unknown event code %x\n",
 			 __func__,
-			 completion_entry);
+			 ent);
 		break;
 	}
 }
 
-static void scic_sds_controller_process_completions(struct isci_host *ihost)
+static void sci_controller_process_completions(struct isci_host *ihost)
 {
 	u32 completion_count = 0;
-	u32 completion_entry;
+	u32 ent;
 	u32 get_index;
 	u32 get_cycle;
 	u32 event_get;
@@ -509,7 +506,7 @@ static void scic_sds_controller_process_completions(struct isci_host *ihost)
 		) {
 		completion_count++;
 
-		completion_entry = ihost->completion_queue[get_index];
+		ent = ihost->completion_queue[get_index];
 
 		/* increment the get pointer and check for rollover to toggle the cycle bit */
 		get_cycle ^= ((get_index+1) & SCU_MAX_COMPLETION_QUEUE_ENTRIES) <<
@@ -519,19 +516,19 @@ static void scic_sds_controller_process_completions(struct isci_host *ihost)
 		dev_dbg(&ihost->pdev->dev,
 			"%s: completion queue entry:0x%08x\n",
 			__func__,
-			completion_entry);
+			ent);
 
-		switch (SCU_GET_COMPLETION_TYPE(completion_entry)) {
+		switch (SCU_GET_COMPLETION_TYPE(ent)) {
 		case SCU_COMPLETION_TYPE_TASK:
-			scic_sds_controller_task_completion(ihost, completion_entry);
+			sci_controller_task_completion(ihost, ent);
 			break;
 
 		case SCU_COMPLETION_TYPE_SDMA:
-			scic_sds_controller_sdma_completion(ihost, completion_entry);
+			sci_controller_sdma_completion(ihost, ent);
 			break;
 
 		case SCU_COMPLETION_TYPE_UFI:
-			scic_sds_controller_unsolicited_frame(ihost, completion_entry);
+			sci_controller_unsolicited_frame(ihost, ent);
 			break;
 
 		case SCU_COMPLETION_TYPE_EVENT:
@@ -540,7 +537,7 @@ static void scic_sds_controller_process_completions(struct isci_host *ihost)
 				       (SMU_COMPLETION_QUEUE_GET_EVENT_CYCLE_BIT_SHIFT - SCU_MAX_EVENTS_SHIFT);
 			event_get = (event_get+1) & (SCU_MAX_EVENTS-1);
 
-			scic_sds_controller_event_completion(ihost, completion_entry);
+			sci_controller_event_completion(ihost, ent);
 			break;
 		}
 		default:
@@ -548,7 +545,7 @@ static void scic_sds_controller_process_completions(struct isci_host *ihost)
 				 "%s: SCIC Controller received unknown "
 				 "completion type %x\n",
 				 __func__,
-				 completion_entry);
+				 ent);
 			break;
 		}
 	}
@@ -575,7 +572,7 @@ static void scic_sds_controller_process_completions(struct isci_host *ihost)
 
 }
 
-static void scic_sds_controller_error_handler(struct isci_host *ihost)
+static void sci_controller_error_handler(struct isci_host *ihost)
 {
 	u32 interrupt_status;
 
@@ -583,9 +580,9 @@ static void scic_sds_controller_error_handler(struct isci_host *ihost)
 		readl(&ihost->smu_registers->interrupt_status);
 
 	if ((interrupt_status & SMU_ISR_QUEUE_SUSPEND) &&
-	    scic_sds_controller_completion_queue_has_entries(ihost)) {
+	    sci_controller_completion_queue_has_entries(ihost)) {
 
-		scic_sds_controller_process_completions(ihost);
+		sci_controller_process_completions(ihost);
 		writel(SMU_ISR_QUEUE_SUSPEND, &ihost->smu_registers->interrupt_status);
 	} else {
 		dev_err(&ihost->pdev->dev, "%s: status: %#x\n", __func__,
@@ -607,13 +604,13 @@ irqreturn_t isci_intx_isr(int vec, void *data)
 	irqreturn_t ret = IRQ_NONE;
 	struct isci_host *ihost = data;
 
-	if (scic_sds_controller_isr(ihost)) {
+	if (sci_controller_isr(ihost)) {
 		writel(SMU_ISR_COMPLETION, &ihost->smu_registers->interrupt_status);
 		tasklet_schedule(&ihost->completion_tasklet);
 		ret = IRQ_HANDLED;
-	} else if (scic_sds_controller_error_isr(ihost)) {
+	} else if (sci_controller_error_isr(ihost)) {
 		spin_lock(&ihost->scic_lock);
-		scic_sds_controller_error_handler(ihost);
+		sci_controller_error_handler(ihost);
 		spin_unlock(&ihost->scic_lock);
 		ret = IRQ_HANDLED;
 	}
@@ -625,8 +622,8 @@ irqreturn_t isci_error_isr(int vec, void *data)
 {
 	struct isci_host *ihost = data;
 
-	if (scic_sds_controller_error_isr(ihost))
-		scic_sds_controller_error_handler(ihost);
+	if (sci_controller_error_isr(ihost))
+		sci_controller_error_handler(ihost);
 
 	return IRQ_HANDLED;
 }
@@ -670,8 +667,8 @@ int isci_host_scan_finished(struct Scsi_Host *shost, unsigned long time)
 }
 
 /**
- * scic_controller_get_suggested_start_timeout() - This method returns the
- *    suggested scic_controller_start() timeout amount.  The user is free to
+ * sci_controller_get_suggested_start_timeout() - This method returns the
+ *    suggested sci_controller_start() timeout amount.  The user is free to
  *    use any timeout value, but this method provides the suggested minimum
  *    start timeout value.  The returned value is based upon empirical
  *    information determined as a result of interoperability testing.
@@ -681,7 +678,7 @@ int isci_host_scan_finished(struct Scsi_Host *shost, unsigned long time)
  * This method returns the number of milliseconds for the suggested start
  * operation timeout.
  */
-static u32 scic_controller_get_suggested_start_timeout(struct isci_host *ihost)
+static u32 sci_controller_get_suggested_start_timeout(struct isci_host *ihost)
 {
 	/* Validate the user supplied parameters. */
 	if (!ihost)
@@ -706,19 +703,19 @@ static u32 scic_controller_get_suggested_start_timeout(struct isci_host *ihost)
 		+ ((SCI_MAX_PHYS - 1) * SCIC_SDS_CONTROLLER_POWER_CONTROL_INTERVAL);
 }
 
-static void scic_controller_enable_interrupts(struct isci_host *ihost)
+static void sci_controller_enable_interrupts(struct isci_host *ihost)
 {
 	BUG_ON(ihost->smu_registers == NULL);
 	writel(0, &ihost->smu_registers->interrupt_mask);
 }
 
-void scic_controller_disable_interrupts(struct isci_host *ihost)
+void sci_controller_disable_interrupts(struct isci_host *ihost)
 {
 	BUG_ON(ihost->smu_registers == NULL);
 	writel(0xffffffff, &ihost->smu_registers->interrupt_mask);
 }
 
-static void scic_sds_controller_enable_port_task_scheduler(struct isci_host *ihost)
+static void sci_controller_enable_port_task_scheduler(struct isci_host *ihost)
 {
 	u32 port_task_scheduler_value;
 
@@ -731,7 +728,7 @@ static void scic_sds_controller_enable_port_task_scheduler(struct isci_host *iho
 	       &ihost->scu_registers->peg0.ptsg.control);
 }
 
-static void scic_sds_controller_assign_task_entries(struct isci_host *ihost)
+static void sci_controller_assign_task_entries(struct isci_host *ihost)
 {
 	u32 task_assignment;
 
@@ -752,7 +749,7 @@ static void scic_sds_controller_assign_task_entries(struct isci_host *ihost)
 
 }
 
-static void scic_sds_controller_initialize_completion_queue(struct isci_host *ihost)
+static void sci_controller_initialize_completion_queue(struct isci_host *ihost)
 {
 	u32 index;
 	u32 completion_queue_control_value;
@@ -799,7 +796,7 @@ static void scic_sds_controller_initialize_completion_queue(struct isci_host *ih
 	}
 }
 
-static void scic_sds_controller_initialize_unsolicited_frame_queue(struct isci_host *ihost)
+static void sci_controller_initialize_unsolicited_frame_queue(struct isci_host *ihost)
 {
 	u32 frame_queue_control_value;
 	u32 frame_queue_get_value;
@@ -826,22 +823,8 @@ static void scic_sds_controller_initialize_unsolicited_frame_queue(struct isci_h
 	       &ihost->scu_registers->sdma.unsolicited_frame_put_pointer);
 }
 
-/**
- * This method will attempt to transition into the ready state for the
- *    controller and indicate that the controller start operation has completed
- *    if all criteria are met.
- * @scic: This parameter indicates the controller object for which
- *    to transition to ready.
- * @status: This parameter indicates the status value to be pass into the call
- *    to scic_cb_controller_start_complete().
- *
- * none.
- */
-static void scic_sds_controller_transition_to_ready(
-	struct isci_host *ihost,
-	enum sci_status status)
+static void sci_controller_transition_to_ready(struct isci_host *ihost, enum sci_status status)
 {
-
 	if (ihost->sm.current_state_id == SCIC_STARTING) {
 		/*
 		 * We move into the ready state, because some of the phys/ports
@@ -855,7 +838,7 @@ static void scic_sds_controller_transition_to_ready(
 
 static bool is_phy_starting(struct isci_phy *iphy)
 {
-	enum scic_sds_phy_states state;
+	enum sci_phy_states state;
 
 	state = iphy->sm.current_state_id;
 	switch (state) {
@@ -876,16 +859,16 @@ static bool is_phy_starting(struct isci_phy *iphy)
 }
 
 /**
- * scic_sds_controller_start_next_phy - start phy
+ * sci_controller_start_next_phy - start phy
  * @scic: controller
  *
  * If all the phys have been started, then attempt to transition the
  * controller to the READY state and inform the user
- * (scic_cb_controller_start_complete()).
+ * (sci_cb_controller_start_complete()).
  */
-static enum sci_status scic_sds_controller_start_next_phy(struct isci_host *ihost)
+static enum sci_status sci_controller_start_next_phy(struct isci_host *ihost)
 {
-	struct scic_sds_oem_params *oem = &ihost->oem_parameters.sds1;
+	struct sci_oem_params *oem = &ihost->oem_parameters;
 	struct isci_phy *iphy;
 	enum sci_status status;
 
@@ -924,7 +907,7 @@ static enum sci_status scic_sds_controller_start_next_phy(struct isci_host *ihos
 		 * The controller has successfully finished the start process.
 		 * Inform the SCI Core user and transition to the READY state. */
 		if (is_controller_start_complete == true) {
-			scic_sds_controller_transition_to_ready(ihost, SCI_SUCCESS);
+			sci_controller_transition_to_ready(ihost, SCI_SUCCESS);
 			sci_del_timer(&ihost->phy_timer);
 			ihost->phy_startup_timer_pending = false;
 		}
@@ -944,11 +927,11 @@ static enum sci_status scic_sds_controller_start_next_phy(struct isci_host *ihos
 				 * incorrectly for the PORT or it was never
 				 * assigned to a PORT
 				 */
-				return scic_sds_controller_start_next_phy(ihost);
+				return sci_controller_start_next_phy(ihost);
 			}
 		}
 
-		status = scic_sds_phy_start(iphy);
+		status = sci_phy_start(iphy);
 
 		if (status == SCI_SUCCESS) {
 			sci_mod_timer(&ihost->phy_timer,
@@ -985,7 +968,7 @@ static void phy_startup_timeout(unsigned long data)
 	ihost->phy_startup_timer_pending = false;
 
 	do {
-		status = scic_sds_controller_start_next_phy(ihost);
+		status = sci_controller_start_next_phy(ihost);
 	} while (status != SCI_SUCCESS);
 
 done:
@@ -997,7 +980,7 @@ static u16 isci_tci_active(struct isci_host *ihost)
 	return CIRC_CNT(ihost->tci_head, ihost->tci_tail, SCI_MAX_IO_REQUESTS);
 }
 
-static enum sci_status scic_controller_start(struct isci_host *ihost,
+static enum sci_status sci_controller_start(struct isci_host *ihost,
 					     u32 timeout)
 {
 	enum sci_status result;
@@ -1018,38 +1001,37 @@ static enum sci_status scic_controller_start(struct isci_host *ihost,
 		isci_tci_free(ihost, index);
 
 	/* Build the RNi free pool */
-	scic_sds_remote_node_table_initialize(
-			&ihost->available_remote_nodes,
-			ihost->remote_node_entries);
+	sci_remote_node_table_initialize(&ihost->available_remote_nodes,
+					 ihost->remote_node_entries);
 
 	/*
 	 * Before anything else lets make sure we will not be
 	 * interrupted by the hardware.
 	 */
-	scic_controller_disable_interrupts(ihost);
+	sci_controller_disable_interrupts(ihost);
 
 	/* Enable the port task scheduler */
-	scic_sds_controller_enable_port_task_scheduler(ihost);
+	sci_controller_enable_port_task_scheduler(ihost);
 
 	/* Assign all the task entries to ihost physical function */
-	scic_sds_controller_assign_task_entries(ihost);
+	sci_controller_assign_task_entries(ihost);
 
 	/* Now initialize the completion queue */
-	scic_sds_controller_initialize_completion_queue(ihost);
+	sci_controller_initialize_completion_queue(ihost);
 
 	/* Initialize the unsolicited frame queue for use */
-	scic_sds_controller_initialize_unsolicited_frame_queue(ihost);
+	sci_controller_initialize_unsolicited_frame_queue(ihost);
 
 	/* Start all of the ports on this controller */
 	for (index = 0; index < ihost->logical_port_entries; index++) {
 		struct isci_port *iport = &ihost->ports[index];
 
-		result = scic_sds_port_start(iport);
+		result = sci_port_start(iport);
 		if (result)
 			return result;
 	}
 
-	scic_sds_controller_start_next_phy(ihost);
+	sci_controller_start_next_phy(ihost);
 
 	sci_mod_timer(&ihost->timer, timeout);
 
@@ -1061,29 +1043,29 @@ static enum sci_status scic_controller_start(struct isci_host *ihost,
 void isci_host_scan_start(struct Scsi_Host *shost)
 {
 	struct isci_host *ihost = SHOST_TO_SAS_HA(shost)->lldd_ha;
-	unsigned long tmo = scic_controller_get_suggested_start_timeout(ihost);
+	unsigned long tmo = sci_controller_get_suggested_start_timeout(ihost);
 
 	set_bit(IHOST_START_PENDING, &ihost->flags);
 
 	spin_lock_irq(&ihost->scic_lock);
-	scic_controller_start(ihost, tmo);
-	scic_controller_enable_interrupts(ihost);
+	sci_controller_start(ihost, tmo);
+	sci_controller_enable_interrupts(ihost);
 	spin_unlock_irq(&ihost->scic_lock);
 }
 
 static void isci_host_stop_complete(struct isci_host *ihost, enum sci_status completion_status)
 {
 	isci_host_change_state(ihost, isci_stopped);
-	scic_controller_disable_interrupts(ihost);
+	sci_controller_disable_interrupts(ihost);
 	clear_bit(IHOST_STOP_PENDING, &ihost->flags);
 	wake_up(&ihost->eventq);
 }
 
-static void scic_sds_controller_completion_handler(struct isci_host *ihost)
+static void sci_controller_completion_handler(struct isci_host *ihost)
 {
 	/* Empty out the completion queue */
-	if (scic_sds_controller_completion_queue_has_entries(ihost))
-		scic_sds_controller_process_completions(ihost);
+	if (sci_controller_completion_queue_has_entries(ihost))
+		sci_controller_process_completions(ihost);
 
 	/* Clear the interrupt and enable all interrupts again */
 	writel(SMU_ISR_COMPLETION, &ihost->smu_registers->interrupt_status);
@@ -1116,7 +1098,7 @@ static void isci_host_completion_routine(unsigned long data)
 
 	spin_lock_irq(&ihost->scic_lock);
 
-	scic_sds_controller_completion_handler(ihost);
+	sci_controller_completion_handler(ihost);
 
 	/* Take the lists of completed I/Os from the host. */
 
@@ -1203,7 +1185,7 @@ static void isci_host_completion_routine(unsigned long data)
 }
 
 /**
- * scic_controller_stop() - This method will stop an individual controller
+ * sci_controller_stop() - This method will stop an individual controller
  *    object.This method will invoke the associated user callback upon
  *    completion.  The completion callback is called when the following
  *    conditions are met: -# the method return status is SCI_SUCCESS. -# the
@@ -1220,8 +1202,7 @@ static void isci_host_completion_routine(unsigned long data)
  * controller is already in the STOPPED state. SCI_FAILURE_INVALID_STATE if the
  * controller is not either in the STARTED or STOPPED states.
  */
-static enum sci_status scic_controller_stop(struct isci_host *ihost,
-					    u32 timeout)
+static enum sci_status sci_controller_stop(struct isci_host *ihost, u32 timeout)
 {
 	if (ihost->sm.current_state_id != SCIC_READY) {
 		dev_warn(&ihost->pdev->dev,
@@ -1236,7 +1217,7 @@ static enum sci_status scic_controller_stop(struct isci_host *ihost,
 }
 
 /**
- * scic_controller_reset() - This method will reset the supplied core
+ * sci_controller_reset() - This method will reset the supplied core
  *    controller regardless of the state of said controller.  This operation is
  *    considered destructive.  In other words, all current operations are wiped
  *    out.  No IO completions for outstanding devices occur.  Outstanding IO
@@ -1247,7 +1228,7 @@ static enum sci_status scic_controller_stop(struct isci_host *ihost,
  * SCI_SUCCESS if the reset operation successfully started. SCI_FATAL_ERROR if
  * the controller reset operation is unable to complete.
  */
-static enum sci_status scic_controller_reset(struct isci_host *ihost)
+static enum sci_status sci_controller_reset(struct isci_host *ihost)
 {
 	switch (ihost->sm.current_state_id) {
 	case SCIC_RESET:
@@ -1286,11 +1267,11 @@ void isci_host_deinit(struct isci_host *ihost)
 	set_bit(IHOST_STOP_PENDING, &ihost->flags);
 
 	spin_lock_irq(&ihost->scic_lock);
-	scic_controller_stop(ihost, SCIC_CONTROLLER_STOP_TIMEOUT);
+	sci_controller_stop(ihost, SCIC_CONTROLLER_STOP_TIMEOUT);
 	spin_unlock_irq(&ihost->scic_lock);
 
 	wait_for_stop(ihost);
-	scic_controller_reset(ihost);
+	sci_controller_reset(ihost);
 
 	/* Cancel any/all outstanding port timers */
 	for (i = 0; i < ihost->logical_port_entries; i++) {
@@ -1329,11 +1310,8 @@ static void __iomem *smu_base(struct isci_host *isci_host)
 	return pcim_iomap_table(pdev)[SCI_SMU_BAR * 2] + SCI_SMU_BAR_SIZE * id;
 }
 
-static void isci_user_parameters_get(
-		struct isci_host *isci_host,
-		union scic_user_parameters *scic_user_params)
+static void isci_user_parameters_get(struct sci_user_parameters *u)
 {
-	struct scic_sds_user_parameters *u = &scic_user_params->sds1;
 	int i;
 
 	for (i = 0; i < SCI_MAX_PHYS; i++) {
@@ -1355,14 +1333,14 @@ static void isci_user_parameters_get(
 	u->max_number_concurrent_device_spin_up = max_concurr_spinup;
 }
 
-static void scic_sds_controller_initial_state_enter(struct sci_base_state_machine *sm)
+static void sci_controller_initial_state_enter(struct sci_base_state_machine *sm)
 {
 	struct isci_host *ihost = container_of(sm, typeof(*ihost), sm);
 
 	sci_change_state(&ihost->sm, SCIC_RESET);
 }
 
-static inline void scic_sds_controller_starting_state_exit(struct sci_base_state_machine *sm)
+static inline void sci_controller_starting_state_exit(struct sci_base_state_machine *sm)
 {
 	struct isci_host *ihost = container_of(sm, typeof(*ihost), sm);
 
@@ -1377,7 +1355,7 @@ static inline void scic_sds_controller_starting_state_exit(struct sci_base_state
 #define INTERRUPT_COALESCE_TIMEOUT_ENCODE_MAX                28
 
 /**
- * scic_controller_set_interrupt_coalescence() - This method allows the user to
+ * sci_controller_set_interrupt_coalescence() - This method allows the user to
  *    configure the interrupt coalescence.
  * @controller: This parameter represents the handle to the controller object
  *    for which its interrupt coalesce register is overridden.
@@ -1394,9 +1372,9 @@ static inline void scic_sds_controller_starting_state_exit(struct sci_base_state
  * SCI_FAILURE_INVALID_PARAMETER_VALUE The user input value is out of range.
  */
 static enum sci_status
-scic_controller_set_interrupt_coalescence(struct isci_host *ihost,
-					  u32 coalesce_number,
-					  u32 coalesce_timeout)
+sci_controller_set_interrupt_coalescence(struct isci_host *ihost,
+					 u32 coalesce_number,
+					 u32 coalesce_timeout)
 {
 	u8 timeout_encode = 0;
 	u32 min = 0;
@@ -1489,23 +1467,23 @@ scic_controller_set_interrupt_coalescence(struct isci_host *ihost,
 }
 
 
-static void scic_sds_controller_ready_state_enter(struct sci_base_state_machine *sm)
+static void sci_controller_ready_state_enter(struct sci_base_state_machine *sm)
 {
 	struct isci_host *ihost = container_of(sm, typeof(*ihost), sm);
 
 	/* set the default interrupt coalescence number and timeout value. */
-	scic_controller_set_interrupt_coalescence(ihost, 0x10, 250);
+	sci_controller_set_interrupt_coalescence(ihost, 0x10, 250);
 }
 
-static void scic_sds_controller_ready_state_exit(struct sci_base_state_machine *sm)
+static void sci_controller_ready_state_exit(struct sci_base_state_machine *sm)
 {
 	struct isci_host *ihost = container_of(sm, typeof(*ihost), sm);
 
 	/* disable interrupt coalescence. */
-	scic_controller_set_interrupt_coalescence(ihost, 0, 0);
+	sci_controller_set_interrupt_coalescence(ihost, 0, 0);
 }
 
-static enum sci_status scic_sds_controller_stop_phys(struct isci_host *ihost)
+static enum sci_status sci_controller_stop_phys(struct isci_host *ihost)
 {
 	u32 index;
 	enum sci_status status;
@@ -1514,7 +1492,7 @@ static enum sci_status scic_sds_controller_stop_phys(struct isci_host *ihost)
 	status = SCI_SUCCESS;
 
 	for (index = 0; index < SCI_MAX_PHYS; index++) {
-		phy_status = scic_sds_phy_stop(&ihost->phys[index]);
+		phy_status = sci_phy_stop(&ihost->phys[index]);
 
 		if (phy_status != SCI_SUCCESS &&
 		    phy_status != SCI_FAILURE_INVALID_STATE) {
@@ -1531,7 +1509,7 @@ static enum sci_status scic_sds_controller_stop_phys(struct isci_host *ihost)
 	return status;
 }
 
-static enum sci_status scic_sds_controller_stop_ports(struct isci_host *ihost)
+static enum sci_status sci_controller_stop_ports(struct isci_host *ihost)
 {
 	u32 index;
 	enum sci_status port_status;
@@ -1540,7 +1518,7 @@ static enum sci_status scic_sds_controller_stop_ports(struct isci_host *ihost)
 	for (index = 0; index < ihost->logical_port_entries; index++) {
 		struct isci_port *iport = &ihost->ports[index];
 
-		port_status = scic_sds_port_stop(iport);
+		port_status = sci_port_stop(iport);
 
 		if ((port_status != SCI_SUCCESS) &&
 		    (port_status != SCI_FAILURE_INVALID_STATE)) {
@@ -1558,7 +1536,7 @@ static enum sci_status scic_sds_controller_stop_ports(struct isci_host *ihost)
 	return status;
 }
 
-static enum sci_status scic_sds_controller_stop_devices(struct isci_host *ihost)
+static enum sci_status sci_controller_stop_devices(struct isci_host *ihost)
 {
 	u32 index;
 	enum sci_status status;
@@ -1569,7 +1547,7 @@ static enum sci_status scic_sds_controller_stop_devices(struct isci_host *ihost)
 	for (index = 0; index < ihost->remote_node_entries; index++) {
 		if (ihost->device_table[index] != NULL) {
 			/* / @todo What timeout value do we want to provide to this request? */
-			device_status = scic_remote_device_stop(ihost->device_table[index], 0);
+			device_status = sci_remote_device_stop(ihost->device_table[index], 0);
 
 			if ((device_status != SCI_SUCCESS) &&
 			    (device_status != SCI_FAILURE_INVALID_STATE)) {
@@ -1586,33 +1564,27 @@ static enum sci_status scic_sds_controller_stop_devices(struct isci_host *ihost)
 	return status;
 }
 
-static void scic_sds_controller_stopping_state_enter(struct sci_base_state_machine *sm)
+static void sci_controller_stopping_state_enter(struct sci_base_state_machine *sm)
 {
 	struct isci_host *ihost = container_of(sm, typeof(*ihost), sm);
 
 	/* Stop all of the components for this controller */
-	scic_sds_controller_stop_phys(ihost);
-	scic_sds_controller_stop_ports(ihost);
-	scic_sds_controller_stop_devices(ihost);
+	sci_controller_stop_phys(ihost);
+	sci_controller_stop_ports(ihost);
+	sci_controller_stop_devices(ihost);
 }
 
-static void scic_sds_controller_stopping_state_exit(struct sci_base_state_machine *sm)
+static void sci_controller_stopping_state_exit(struct sci_base_state_machine *sm)
 {
 	struct isci_host *ihost = container_of(sm, typeof(*ihost), sm);
 
 	sci_del_timer(&ihost->timer);
 }
 
-
-/**
- * scic_sds_controller_reset_hardware() -
- *
- * This method will reset the controller hardware.
- */
-static void scic_sds_controller_reset_hardware(struct isci_host *ihost)
+static void sci_controller_reset_hardware(struct isci_host *ihost)
 {
 	/* Disable interrupts so we dont take any spurious interrupts */
-	scic_controller_disable_interrupts(ihost);
+	sci_controller_disable_interrupts(ihost);
 
 	/* Reset the SCU */
 	writel(0xFFFFFFFF, &ihost->smu_registers->soft_reset_control);
@@ -1627,82 +1599,82 @@ static void scic_sds_controller_reset_hardware(struct isci_host *ihost)
 	writel(0, &ihost->scu_registers->sdma.unsolicited_frame_get_pointer);
 }
 
-static void scic_sds_controller_resetting_state_enter(struct sci_base_state_machine *sm)
+static void sci_controller_resetting_state_enter(struct sci_base_state_machine *sm)
 {
 	struct isci_host *ihost = container_of(sm, typeof(*ihost), sm);
 
-	scic_sds_controller_reset_hardware(ihost);
+	sci_controller_reset_hardware(ihost);
 	sci_change_state(&ihost->sm, SCIC_RESET);
 }
 
-static const struct sci_base_state scic_sds_controller_state_table[] = {
+static const struct sci_base_state sci_controller_state_table[] = {
 	[SCIC_INITIAL] = {
-		.enter_state = scic_sds_controller_initial_state_enter,
+		.enter_state = sci_controller_initial_state_enter,
 	},
 	[SCIC_RESET] = {},
 	[SCIC_INITIALIZING] = {},
 	[SCIC_INITIALIZED] = {},
 	[SCIC_STARTING] = {
-		.exit_state  = scic_sds_controller_starting_state_exit,
+		.exit_state  = sci_controller_starting_state_exit,
 	},
 	[SCIC_READY] = {
-		.enter_state = scic_sds_controller_ready_state_enter,
-		.exit_state  = scic_sds_controller_ready_state_exit,
+		.enter_state = sci_controller_ready_state_enter,
+		.exit_state  = sci_controller_ready_state_exit,
 	},
 	[SCIC_RESETTING] = {
-		.enter_state = scic_sds_controller_resetting_state_enter,
+		.enter_state = sci_controller_resetting_state_enter,
 	},
 	[SCIC_STOPPING] = {
-		.enter_state = scic_sds_controller_stopping_state_enter,
-		.exit_state = scic_sds_controller_stopping_state_exit,
+		.enter_state = sci_controller_stopping_state_enter,
+		.exit_state = sci_controller_stopping_state_exit,
 	},
 	[SCIC_STOPPED] = {},
 	[SCIC_FAILED] = {}
 };
 
-static void scic_sds_controller_set_default_config_parameters(struct isci_host *ihost)
+static void sci_controller_set_default_config_parameters(struct isci_host *ihost)
 {
 	/* these defaults are overridden by the platform / firmware */
 	u16 index;
 
 	/* Default to APC mode. */
-	ihost->oem_parameters.sds1.controller.mode_type = SCIC_PORT_AUTOMATIC_CONFIGURATION_MODE;
+	ihost->oem_parameters.controller.mode_type = SCIC_PORT_AUTOMATIC_CONFIGURATION_MODE;
 
 	/* Default to APC mode. */
-	ihost->oem_parameters.sds1.controller.max_concurrent_dev_spin_up = 1;
+	ihost->oem_parameters.controller.max_concurrent_dev_spin_up = 1;
 
 	/* Default to no SSC operation. */
-	ihost->oem_parameters.sds1.controller.do_enable_ssc = false;
+	ihost->oem_parameters.controller.do_enable_ssc = false;
 
 	/* Initialize all of the port parameter information to narrow ports. */
 	for (index = 0; index < SCI_MAX_PORTS; index++) {
-		ihost->oem_parameters.sds1.ports[index].phy_mask = 0;
+		ihost->oem_parameters.ports[index].phy_mask = 0;
 	}
 
 	/* Initialize all of the phy parameter information. */
 	for (index = 0; index < SCI_MAX_PHYS; index++) {
 		/* Default to 6G (i.e. Gen 3) for now. */
-		ihost->user_parameters.sds1.phys[index].max_speed_generation = 3;
+		ihost->user_parameters.phys[index].max_speed_generation = 3;
 
 		/* the frequencies cannot be 0 */
-		ihost->user_parameters.sds1.phys[index].align_insertion_frequency = 0x7f;
-		ihost->user_parameters.sds1.phys[index].in_connection_align_insertion_frequency = 0xff;
-		ihost->user_parameters.sds1.phys[index].notify_enable_spin_up_insertion_frequency = 0x33;
+		ihost->user_parameters.phys[index].align_insertion_frequency = 0x7f;
+		ihost->user_parameters.phys[index].in_connection_align_insertion_frequency = 0xff;
+		ihost->user_parameters.phys[index].notify_enable_spin_up_insertion_frequency = 0x33;
 
 		/*
 		 * Previous Vitesse based expanders had a arbitration issue that
 		 * is worked around by having the upper 32-bits of SAS address
 		 * with a value greater then the Vitesse company identifier.
 		 * Hence, usage of 0x5FCFFFFF. */
-		ihost->oem_parameters.sds1.phys[index].sas_address.low = 0x1 + ihost->id;
-		ihost->oem_parameters.sds1.phys[index].sas_address.high = 0x5FCFFFFF;
+		ihost->oem_parameters.phys[index].sas_address.low = 0x1 + ihost->id;
+		ihost->oem_parameters.phys[index].sas_address.high = 0x5FCFFFFF;
 	}
 
-	ihost->user_parameters.sds1.stp_inactivity_timeout = 5;
-	ihost->user_parameters.sds1.ssp_inactivity_timeout = 5;
-	ihost->user_parameters.sds1.stp_max_occupancy_timeout = 5;
-	ihost->user_parameters.sds1.ssp_max_occupancy_timeout = 20;
-	ihost->user_parameters.sds1.no_outbound_task_timeout = 20;
+	ihost->user_parameters.stp_inactivity_timeout = 5;
+	ihost->user_parameters.ssp_inactivity_timeout = 5;
+	ihost->user_parameters.stp_max_occupancy_timeout = 5;
+	ihost->user_parameters.ssp_max_occupancy_timeout = 20;
+	ihost->user_parameters.no_outbound_task_timeout = 20;
 }
 
 static void controller_timeout(unsigned long data)
@@ -1718,7 +1690,7 @@ static void controller_timeout(unsigned long data)
 		goto done;
 
 	if (sm->current_state_id == SCIC_STARTING)
-		scic_sds_controller_transition_to_ready(ihost, SCI_FAILURE_TIMEOUT);
+		sci_controller_transition_to_ready(ihost, SCI_FAILURE_TIMEOUT);
 	else if (sm->current_state_id == SCIC_STOPPING) {
 		sci_change_state(sm, SCIC_FAILED);
 		isci_host_stop_complete(ihost, SCI_FAILURE_TIMEOUT);
@@ -1732,45 +1704,29 @@ static void controller_timeout(unsigned long data)
 	spin_unlock_irqrestore(&ihost->scic_lock, flags);
 }
 
-/**
- * scic_controller_construct() - This method will attempt to construct a
- *    controller object utilizing the supplied parameter information.
- * @c: This parameter specifies the controller to be constructed.
- * @scu_base: mapped base address of the scu registers
- * @smu_base: mapped base address of the smu registers
- *
- * Indicate if the controller was successfully constructed or if it failed in
- * some way. SCI_SUCCESS This value is returned if the controller was
- * successfully constructed. SCI_WARNING_TIMER_CONFLICT This value is returned
- * if the interrupt coalescence timer may cause SAS compliance issues for SMP
- * Target mode response processing. SCI_FAILURE_UNSUPPORTED_CONTROLLER_TYPE
- * This value is returned if the controller does not support the supplied type.
- * SCI_FAILURE_UNSUPPORTED_INIT_DATA_VERSION This value is returned if the
- * controller does not support the supplied initialization data version.
- */
-static enum sci_status scic_controller_construct(struct isci_host *ihost,
-					  void __iomem *scu_base,
-					  void __iomem *smu_base)
+static enum sci_status sci_controller_construct(struct isci_host *ihost,
+						void __iomem *scu_base,
+						void __iomem *smu_base)
 {
 	u8 i;
 
-	sci_init_sm(&ihost->sm, scic_sds_controller_state_table, SCIC_INITIAL);
+	sci_init_sm(&ihost->sm, sci_controller_state_table, SCIC_INITIAL);
 
 	ihost->scu_registers = scu_base;
 	ihost->smu_registers = smu_base;
 
-	scic_sds_port_configuration_agent_construct(&ihost->port_agent);
+	sci_port_configuration_agent_construct(&ihost->port_agent);
 
 	/* Construct the ports for this controller */
 	for (i = 0; i < SCI_MAX_PORTS; i++)
-		scic_sds_port_construct(&ihost->ports[i], i, ihost);
-	scic_sds_port_construct(&ihost->ports[i], SCIC_SDS_DUMMY_PORT, ihost);
+		sci_port_construct(&ihost->ports[i], i, ihost);
+	sci_port_construct(&ihost->ports[i], SCIC_SDS_DUMMY_PORT, ihost);
 
 	/* Construct the phys for this controller */
 	for (i = 0; i < SCI_MAX_PHYS; i++) {
 		/* Add all the PHYs to the dummy port */
-		scic_sds_phy_construct(&ihost->phys[i],
-				       &ihost->ports[SCI_MAX_PORTS], i);
+		sci_phy_construct(&ihost->phys[i],
+				  &ihost->ports[SCI_MAX_PORTS], i);
 	}
 
 	ihost->invalid_phy_mask = 0;
@@ -1778,12 +1734,12 @@ static enum sci_status scic_controller_construct(struct isci_host *ihost,
 	sci_init_timer(&ihost->timer, controller_timeout);
 
 	/* Initialize the User and OEM parameters to default values. */
-	scic_sds_controller_set_default_config_parameters(ihost);
+	sci_controller_set_default_config_parameters(ihost);
 
-	return scic_controller_reset(ihost);
+	return sci_controller_reset(ihost);
 }
 
-int scic_oem_parameters_validate(struct scic_sds_oem_params *oem)
+int sci_oem_parameters_validate(struct sci_oem_params *oem)
 {
 	int i;
 
@@ -1817,8 +1773,7 @@ int scic_oem_parameters_validate(struct scic_sds_oem_params *oem)
 	return 0;
 }
 
-static enum sci_status scic_oem_parameters_set(struct isci_host *ihost,
-					union scic_oem_parameters *scic_parms)
+static enum sci_status sci_oem_parameters_set(struct isci_host *ihost)
 {
 	u32 state = ihost->sm.current_state_id;
 
@@ -1826,9 +1781,8 @@ static enum sci_status scic_oem_parameters_set(struct isci_host *ihost,
 	    state == SCIC_INITIALIZING ||
 	    state == SCIC_INITIALIZED) {
 
-		if (scic_oem_parameters_validate(&scic_parms->sds1))
+		if (sci_oem_parameters_validate(&ihost->oem_parameters))
 			return SCI_FAILURE_INVALID_PARAMETER_VALUE;
-		ihost->oem_parameters.sds1 = scic_parms->sds1;
 
 		return SCI_SUCCESS;
 	}
@@ -1836,13 +1790,6 @@ static enum sci_status scic_oem_parameters_set(struct isci_host *ihost,
 	return SCI_FAILURE_INVALID_STATE;
 }
 
-void scic_oem_parameters_get(
-	struct isci_host *ihost,
-	union scic_oem_parameters *scic_parms)
-{
-	memcpy(scic_parms, (&ihost->oem_parameters), sizeof(*scic_parms));
-}
-
 static void power_control_timeout(unsigned long data)
 {
 	struct sci_timer *tmr = (struct sci_timer *)data;
@@ -1873,13 +1820,13 @@ static void power_control_timeout(unsigned long data)
 			continue;
 
 		if (ihost->power_control.phys_granted_power >=
-		    ihost->oem_parameters.sds1.controller.max_concurrent_dev_spin_up)
+		    ihost->oem_parameters.controller.max_concurrent_dev_spin_up)
 			break;
 
 		ihost->power_control.requesters[i] = NULL;
 		ihost->power_control.phys_waiting--;
 		ihost->power_control.phys_granted_power++;
-		scic_sds_phy_consume_power_handler(iphy);
+		sci_phy_consume_power_handler(iphy);
 	}
 
 	/*
@@ -1893,22 +1840,15 @@ static void power_control_timeout(unsigned long data)
 	spin_unlock_irqrestore(&ihost->scic_lock, flags);
 }
 
-/**
- * This method inserts the phy in the stagger spinup control queue.
- * @scic:
- *
- *
- */
-void scic_sds_controller_power_control_queue_insert(
-	struct isci_host *ihost,
-	struct isci_phy *iphy)
+void sci_controller_power_control_queue_insert(struct isci_host *ihost,
+					       struct isci_phy *iphy)
 {
 	BUG_ON(iphy == NULL);
 
 	if (ihost->power_control.phys_granted_power <
-	    ihost->oem_parameters.sds1.controller.max_concurrent_dev_spin_up) {
+	    ihost->oem_parameters.controller.max_concurrent_dev_spin_up) {
 		ihost->power_control.phys_granted_power++;
-		scic_sds_phy_consume_power_handler(iphy);
+		sci_phy_consume_power_handler(iphy);
 
 		/*
 		 * stop and start the power_control timer. When the timer fires, the
@@ -1928,21 +1868,13 @@ void scic_sds_controller_power_control_queue_insert(
 	}
 }
 
-/**
- * This method removes the phy from the stagger spinup control queue.
- * @scic:
- *
- *
- */
-void scic_sds_controller_power_control_queue_remove(
-	struct isci_host *ihost,
-	struct isci_phy *iphy)
+void sci_controller_power_control_queue_remove(struct isci_host *ihost,
+					       struct isci_phy *iphy)
 {
 	BUG_ON(iphy == NULL);
 
-	if (ihost->power_control.requesters[iphy->phy_index] != NULL) {
+	if (ihost->power_control.requesters[iphy->phy_index])
 		ihost->power_control.phys_waiting--;
-	}
 
 	ihost->power_control.requesters[iphy->phy_index] = NULL;
 }
@@ -1952,9 +1884,9 @@ void scic_sds_controller_power_control_queue_remove(
 /* Initialize the AFE for this phy index. We need to read the AFE setup from
  * the OEM parameters
  */
-static void scic_sds_controller_afe_initialization(struct isci_host *ihost)
+static void sci_controller_afe_initialization(struct isci_host *ihost)
 {
-	const struct scic_sds_oem_params *oem = &ihost->oem_parameters.sds1;
+	const struct sci_oem_params *oem = &ihost->oem_parameters;
 	u32 afe_status;
 	u32 phy_id;
 
@@ -2111,7 +2043,7 @@ static void scic_sds_controller_afe_initialization(struct isci_host *ihost)
 	udelay(AFE_REGISTER_WRITE_DELAY);
 }
 
-static void scic_sds_controller_initialize_power_control(struct isci_host *ihost)
+static void sci_controller_initialize_power_control(struct isci_host *ihost)
 {
 	sci_init_timer(&ihost->power_control.timer, power_control_timeout);
 
@@ -2122,7 +2054,7 @@ static void scic_sds_controller_initialize_power_control(struct isci_host *ihost
 	ihost->power_control.phys_granted_power = 0;
 }
 
-static enum sci_status scic_controller_initialize(struct isci_host *ihost)
+static enum sci_status sci_controller_initialize(struct isci_host *ihost)
 {
 	struct sci_base_state_machine *sm = &ihost->sm;
 	enum sci_status result = SCI_FAILURE;
@@ -2142,14 +2074,14 @@ static enum sci_status scic_controller_initialize(struct isci_host *ihost)
 	ihost->next_phy_to_start = 0;
 	ihost->phy_startup_timer_pending = false;
 
-	scic_sds_controller_initialize_power_control(ihost);
+	sci_controller_initialize_power_control(ihost);
 
 	/*
 	 * There is nothing to do here for B0 since we do not have to
 	 * program the AFE registers.
 	 * / @todo The AFE settings are supposed to be correct for the B0 but
 	 * /       presently they seem to be wrong. */
-	scic_sds_controller_afe_initialization(ihost);
+	sci_controller_afe_initialization(ihost);
 
 
 	/* Take the hardware out of reset */
@@ -2206,24 +2138,22 @@ static enum sci_status scic_controller_initialize(struct isci_host *ihost)
 	 * are accessed during the port initialization.
 	 */
 	for (i = 0; i < SCI_MAX_PHYS; i++) {
-		result = scic_sds_phy_initialize(&ihost->phys[i],
-						 &ihost->scu_registers->peg0.pe[i].tl,
-						 &ihost->scu_registers->peg0.pe[i].ll);
+		result = sci_phy_initialize(&ihost->phys[i],
+					    &ihost->scu_registers->peg0.pe[i].tl,
+					    &ihost->scu_registers->peg0.pe[i].ll);
 		if (result != SCI_SUCCESS)
 			goto out;
 	}
 
 	for (i = 0; i < ihost->logical_port_entries; i++) {
-		result = scic_sds_port_initialize(&ihost->ports[i],
-						  &ihost->scu_registers->peg0.ptsg.port[i],
-						  &ihost->scu_registers->peg0.ptsg.protocol_engine,
-						  &ihost->scu_registers->peg0.viit[i]);
+		struct isci_port *iport = &ihost->ports[i];
 
-		if (result != SCI_SUCCESS)
-			goto out;
+		iport->port_task_scheduler_registers = &ihost->scu_registers->peg0.ptsg.port[i];
+		iport->port_pe_configuration_register = &ihost->scu_registers->peg0.ptsg.protocol_engine[0];
+		iport->viit_registers = &ihost->scu_registers->peg0.viit[i];
 	}
 
-	result = scic_sds_port_configuration_agent_initialize(ihost, &ihost->port_agent);
+	result = sci_port_configuration_agent_initialize(ihost, &ihost->port_agent);
 
  out:
 	/* Advance the controller state machine */
@@ -2236,9 +2166,8 @@ static enum sci_status scic_controller_initialize(struct isci_host *ihost)
 	return result;
 }
 
-static enum sci_status scic_user_parameters_set(
-	struct isci_host *ihost,
-	union scic_user_parameters *scic_parms)
+static enum sci_status sci_user_parameters_set(struct isci_host *ihost,
+					       struct sci_user_parameters *sci_parms)
 {
 	u32 state = ihost->sm.current_state_id;
 
@@ -2254,7 +2183,7 @@ static enum sci_status scic_user_parameters_set(
 		for (index = 0; index < SCI_MAX_PHYS; index++) {
 			struct sci_phy_user_params *user_phy;
 
-			user_phy = &scic_parms->sds1.phys[index];
+			user_phy = &sci_parms->phys[index];
 
 			if (!((user_phy->max_speed_generation <=
 						SCIC_SDS_PARM_MAX_SPEED) &&
@@ -2275,14 +2204,14 @@ static enum sci_status scic_user_parameters_set(
 				return SCI_FAILURE_INVALID_PARAMETER_VALUE;
 		}
 
-		if ((scic_parms->sds1.stp_inactivity_timeout == 0) ||
-		    (scic_parms->sds1.ssp_inactivity_timeout == 0) ||
-		    (scic_parms->sds1.stp_max_occupancy_timeout == 0) ||
-		    (scic_parms->sds1.ssp_max_occupancy_timeout == 0) ||
-		    (scic_parms->sds1.no_outbound_task_timeout == 0))
+		if ((sci_parms->stp_inactivity_timeout == 0) ||
+		    (sci_parms->ssp_inactivity_timeout == 0) ||
+		    (sci_parms->stp_max_occupancy_timeout == 0) ||
+		    (sci_parms->ssp_max_occupancy_timeout == 0) ||
+		    (sci_parms->no_outbound_task_timeout == 0))
 			return SCI_FAILURE_INVALID_PARAMETER_VALUE;
 
-		memcpy(&ihost->user_parameters, scic_parms, sizeof(*scic_parms));
+		memcpy(&ihost->user_parameters, sci_parms, sizeof(*sci_parms));
 
 		return SCI_SUCCESS;
 	}
@@ -2290,7 +2219,7 @@ static enum sci_status scic_user_parameters_set(
 	return SCI_FAILURE_INVALID_STATE;
 }
 
-static int scic_controller_mem_init(struct isci_host *ihost)
+static int sci_controller_mem_init(struct isci_host *ihost)
 {
 	struct device *dev = &ihost->pdev->dev;
 	dma_addr_t dma;
@@ -2307,7 +2236,7 @@ static int scic_controller_mem_init(struct isci_host *ihost)
 
 	size = ihost->remote_node_entries * sizeof(union scu_remote_node_context);
 	ihost->remote_node_context_table = dmam_alloc_coherent(dev, size, &dma,
-							      GFP_KERNEL);
+							       GFP_KERNEL);
 	if (!ihost->remote_node_context_table)
 		return -ENOMEM;
 
@@ -2323,7 +2252,7 @@ static int scic_controller_mem_init(struct isci_host *ihost)
 	writel(lower_32_bits(dma), &ihost->smu_registers->host_task_table_lower);
 	writel(upper_32_bits(dma), &ihost->smu_registers->host_task_table_upper);
 
-	err = scic_sds_unsolicited_frame_control_construct(ihost);
+	err = sci_unsolicited_frame_control_construct(ihost);
 	if (err)
 		return err;
 
@@ -2348,8 +2277,7 @@ int isci_host_init(struct isci_host *ihost)
 {
 	int err = 0, i;
 	enum sci_status status;
-	union scic_oem_parameters oem;
-	union scic_user_parameters scic_user_params;
+	struct sci_user_parameters sci_user_params;
 	struct isci_pci_info *pci_info = to_pci_info(ihost->pdev);
 
 	spin_lock_init(&ihost->state_lock);
@@ -2358,12 +2286,12 @@ int isci_host_init(struct isci_host *ihost)
 
 	isci_host_change_state(ihost, isci_starting);
 
-	status = scic_controller_construct(ihost, scu_base(ihost),
-					   smu_base(ihost));
+	status = sci_controller_construct(ihost, scu_base(ihost),
+					  smu_base(ihost));
 
 	if (status != SCI_SUCCESS) {
 		dev_err(&ihost->pdev->dev,
-			"%s: scic_controller_construct failed - status = %x\n",
+			"%s: sci_controller_construct failed - status = %x\n",
 			__func__,
 			status);
 		return -ENODEV;
@@ -2376,21 +2304,18 @@ int isci_host_init(struct isci_host *ihost)
 	 * grab initial values stored in the controller object for OEM and USER
 	 * parameters
 	 */
-	isci_user_parameters_get(ihost, &scic_user_params);
-	status = scic_user_parameters_set(ihost,
-					  &scic_user_params);
+	isci_user_parameters_get(&sci_user_params);
+	status = sci_user_parameters_set(ihost, &sci_user_params);
 	if (status != SCI_SUCCESS) {
 		dev_warn(&ihost->pdev->dev,
-			 "%s: scic_user_parameters_set failed\n",
+			 "%s: sci_user_parameters_set failed\n",
 			 __func__);
 		return -ENODEV;
 	}
 
-	scic_oem_parameters_get(ihost, &oem);
-
 	/* grab any OEM parameters specified in orom */
 	if (pci_info->orom) {
-		status = isci_parse_oem_parameters(&oem,
+		status = isci_parse_oem_parameters(&ihost->oem_parameters,
 						   pci_info->orom,
 						   ihost->id);
 		if (status != SCI_SUCCESS) {
@@ -2400,10 +2325,10 @@ int isci_host_init(struct isci_host *ihost)
 		}
 	}
 
-	status = scic_oem_parameters_set(ihost, &oem);
+	status = sci_oem_parameters_set(ihost);
 	if (status != SCI_SUCCESS) {
 		dev_warn(&ihost->pdev->dev,
-				"%s: scic_oem_parameters_set failed\n",
+				"%s: sci_oem_parameters_set failed\n",
 				__func__);
 		return -ENODEV;
 	}
@@ -2415,17 +2340,17 @@ int isci_host_init(struct isci_host *ihost)
 	INIT_LIST_HEAD(&ihost->requests_to_errorback);
 
 	spin_lock_irq(&ihost->scic_lock);
-	status = scic_controller_initialize(ihost);
+	status = sci_controller_initialize(ihost);
 	spin_unlock_irq(&ihost->scic_lock);
 	if (status != SCI_SUCCESS) {
 		dev_warn(&ihost->pdev->dev,
-			 "%s: scic_controller_initialize failed -"
+			 "%s: sci_controller_initialize failed -"
 			 " status = 0x%x\n",
 			 __func__, status);
 		return -ENODEV;
 	}
 
-	err = scic_controller_mem_init(ihost);
+	err = sci_controller_mem_init(ihost);
 	if (err)
 		return err;
 
@@ -2463,20 +2388,20 @@ int isci_host_init(struct isci_host *ihost)
 	return 0;
 }
 
-void scic_sds_controller_link_up(struct isci_host *ihost,
-		struct isci_port *iport, struct isci_phy *iphy)
+void sci_controller_link_up(struct isci_host *ihost, struct isci_port *iport,
+			    struct isci_phy *iphy)
 {
 	switch (ihost->sm.current_state_id) {
 	case SCIC_STARTING:
 		sci_del_timer(&ihost->phy_timer);
 		ihost->phy_startup_timer_pending = false;
 		ihost->port_agent.link_up_handler(ihost, &ihost->port_agent,
-						 iport, iphy);
-		scic_sds_controller_start_next_phy(ihost);
+						  iport, iphy);
+		sci_controller_start_next_phy(ihost);
 		break;
 	case SCIC_READY:
 		ihost->port_agent.link_up_handler(ihost, &ihost->port_agent,
-						 iport, iphy);
+						  iport, iphy);
 		break;
 	default:
 		dev_dbg(&ihost->pdev->dev,
@@ -2486,8 +2411,8 @@ void scic_sds_controller_link_up(struct isci_host *ihost,
 	}
 }
 
-void scic_sds_controller_link_down(struct isci_host *ihost,
-		struct isci_port *iport, struct isci_phy *iphy)
+void sci_controller_link_down(struct isci_host *ihost, struct isci_port *iport,
+			      struct isci_phy *iphy)
 {
 	switch (ihost->sm.current_state_id) {
 	case SCIC_STARTING:
@@ -2505,12 +2430,7 @@ void scic_sds_controller_link_down(struct isci_host *ihost,
 	}
 }
 
-/**
- * This is a helper method to determine if any remote devices on this
- * controller are still in the stopping state.
- *
- */
-static bool scic_sds_controller_has_remote_devices_stopping(struct isci_host *ihost)
+static bool sci_controller_has_remote_devices_stopping(struct isci_host *ihost)
 {
 	u32 index;
 
@@ -2523,12 +2443,8 @@ static bool scic_sds_controller_has_remote_devices_stopping(struct isci_host *ih
 	return false;
 }
 
-/**
- * This method is called by the remote device to inform the controller
- * object that the remote device has stopped.
- */
-void scic_sds_controller_remote_device_stopped(struct isci_host *ihost,
-					       struct isci_remote_device *idev)
+void sci_controller_remote_device_stopped(struct isci_host *ihost,
+					  struct isci_remote_device *idev)
 {
 	if (ihost->sm.current_state_id != SCIC_STOPPING) {
 		dev_dbg(&ihost->pdev->dev,
@@ -2539,32 +2455,19 @@ void scic_sds_controller_remote_device_stopped(struct isci_host *ihost,
 		return;
 	}
 
-	if (!scic_sds_controller_has_remote_devices_stopping(ihost)) {
+	if (!sci_controller_has_remote_devices_stopping(ihost))
 		sci_change_state(&ihost->sm, SCIC_STOPPED);
-	}
 }
 
-/**
- * This method will write to the SCU PCP register the request value. The method
- *    is used to suspend/resume ports, devices, and phys.
- * @scic:
- *
- *
- */
-void scic_sds_controller_post_request(
-	struct isci_host *ihost,
-	u32 request)
+void sci_controller_post_request(struct isci_host *ihost, u32 request)
 {
-	dev_dbg(&ihost->pdev->dev,
-		"%s: SCIC Controller 0x%p post request 0x%08x\n",
-		__func__,
-		ihost,
-		request);
+	dev_dbg(&ihost->pdev->dev, "%s[%d]: %#x\n",
+		__func__, ihost->id, request);
 
 	writel(request, &ihost->smu_registers->post_context_port);
 }
 
-struct isci_request *scic_request_by_tag(struct isci_host *ihost, u16 io_tag)
+struct isci_request *sci_request_by_tag(struct isci_host *ihost, u16 io_tag)
 {
 	u16 task_index;
 	u16 task_sequence;
@@ -2599,15 +2502,14 @@ struct isci_request *scic_request_by_tag(struct isci_host *ihost, u16 io_tag)
  * enum sci_status SCI_FAILURE_OUT_OF_RESOURCES if there are no available remote
  * node index available.
  */
-enum sci_status scic_sds_controller_allocate_remote_node_context(
-	struct isci_host *ihost,
-	struct isci_remote_device *idev,
-	u16 *node_id)
+enum sci_status sci_controller_allocate_remote_node_context(struct isci_host *ihost,
+							    struct isci_remote_device *idev,
+							    u16 *node_id)
 {
 	u16 node_index;
-	u32 remote_node_count = scic_sds_remote_device_node_count(idev);
+	u32 remote_node_count = sci_remote_device_node_count(idev);
 
-	node_index = scic_sds_remote_node_table_allocate_remote_node(
+	node_index = sci_remote_node_table_allocate_remote_node(
 		&ihost->available_remote_nodes, remote_node_count
 		);
 
@@ -2622,68 +2524,26 @@ enum sci_status scic_sds_controller_allocate_remote_node_context(
 	return SCI_FAILURE_INSUFFICIENT_RESOURCES;
 }
 
-/**
- * This method frees the remote node index back to the available pool.  Once
- *    this is done the remote node context buffer is no longer valid and can
- *    not be used.
- * @scic:
- * @sci_dev:
- * @node_id:
- *
- */
-void scic_sds_controller_free_remote_node_context(
-	struct isci_host *ihost,
-	struct isci_remote_device *idev,
-	u16 node_id)
+void sci_controller_free_remote_node_context(struct isci_host *ihost,
+					     struct isci_remote_device *idev,
+					     u16 node_id)
 {
-	u32 remote_node_count = scic_sds_remote_device_node_count(idev);
+	u32 remote_node_count = sci_remote_device_node_count(idev);
 
 	if (ihost->device_table[node_id] == idev) {
 		ihost->device_table[node_id] = NULL;
 
-		scic_sds_remote_node_table_release_remote_node_index(
+		sci_remote_node_table_release_remote_node_index(
 			&ihost->available_remote_nodes, remote_node_count, node_id
 			);
 	}
 }
 
-/**
- * This method returns the union scu_remote_node_context for the specified remote
- *    node id.
- * @scic:
- * @node_id:
- *
- * union scu_remote_node_context*
- */
-union scu_remote_node_context *scic_sds_controller_get_remote_node_context_buffer(
-	struct isci_host *ihost,
-	u16 node_id
-	) {
-	if (
-		(node_id < ihost->remote_node_entries)
-		&& (ihost->device_table[node_id] != NULL)
-		) {
-		return &ihost->remote_node_context_table[node_id];
-	}
-
-	return NULL;
-}
-
-/**
- *
- * @resposne_buffer: This is the buffer into which the D2H register FIS will be
- *    constructed.
- * @frame_header: This is the frame header returned by the hardware.
- * @frame_buffer: This is the frame buffer returned by the hardware.
- *
- * This method will combind the frame header and frame buffer to create a SATA
- * D2H register FIS none
- */
-void scic_sds_controller_copy_sata_response(
-	void *response_buffer,
-	void *frame_header,
-	void *frame_buffer)
+void sci_controller_copy_sata_response(void *response_buffer,
+				       void *frame_header,
+				       void *frame_buffer)
 {
+	/* XXX type safety? */
 	memcpy(response_buffer, frame_header, sizeof(u32));
 
 	memcpy(response_buffer + sizeof(u32),
@@ -2691,21 +2551,9 @@ void scic_sds_controller_copy_sata_response(
 	       sizeof(struct dev_to_host_fis) - sizeof(u32));
 }
 
-/**
- * This method releases the frame once this is done the frame is available for
- *    re-use by the hardware.  The data contained in the frame header and frame
- *    buffer is no longer valid. The UF queue get pointer is only updated if UF
- *    control indicates this is appropriate.
- * @scic:
- * @frame_index:
- *
- */
-void scic_sds_controller_release_frame(
-	struct isci_host *ihost,
-	u32 frame_index)
+void sci_controller_release_frame(struct isci_host *ihost, u32 frame_index)
 {
-	if (scic_sds_unsolicited_frame_control_release_frame(
-		    &ihost->uf_control, frame_index) == true)
+	if (sci_unsolicited_frame_control_release_frame(&ihost->uf_control, frame_index))
 		writel(ihost->uf_control.get,
 			&ihost->scu_registers->sdma.unsolicited_frame_get_pointer);
 }
@@ -2763,21 +2611,9 @@ enum sci_status isci_free_tag(struct isci_host *ihost, u16 io_tag)
 	return SCI_FAILURE_INVALID_IO_TAG;
 }
 
-/**
- * scic_controller_start_io() - This method is called by the SCI user to
- *    send/start an IO request. If the method invocation is successful, then
- *    the IO request has been queued to the hardware for processing.
- * @controller: the handle to the controller object for which to start an IO
- *    request.
- * @remote_device: the handle to the remote device object for which to start an
- *    IO request.
- * @io_request: the handle to the io request object to start.
- * @io_tag: This parameter specifies a previously allocated IO tag that the
- *    user desires to be utilized for this request.
- */
-enum sci_status scic_controller_start_io(struct isci_host *ihost,
-					 struct isci_remote_device *idev,
-					 struct isci_request *ireq)
+enum sci_status sci_controller_start_io(struct isci_host *ihost,
+					struct isci_remote_device *idev,
+					struct isci_request *ireq)
 {
 	enum sci_status status;
 
@@ -2786,36 +2622,23 @@ enum sci_status scic_controller_start_io(struct isci_host *ihost,
 		return SCI_FAILURE_INVALID_STATE;
 	}
 
-	status = scic_sds_remote_device_start_io(ihost, idev, ireq);
+	status = sci_remote_device_start_io(ihost, idev, ireq);
 	if (status != SCI_SUCCESS)
 		return status;
 
 	set_bit(IREQ_ACTIVE, &ireq->flags);
-	scic_sds_controller_post_request(ihost, scic_sds_request_get_post_context(ireq));
+	sci_controller_post_request(ihost, sci_request_get_post_context(ireq));
 	return SCI_SUCCESS;
 }
 
-/**
- * scic_controller_terminate_request() - This method is called by the SCI Core
- *    user to terminate an ongoing (i.e. started) core IO request.  This does
- *    not abort the IO request at the target, but rather removes the IO request
- *    from the host controller.
- * @controller: the handle to the controller object for which to terminate a
- *    request.
- * @remote_device: the handle to the remote device object for which to
- *    terminate a request.
- * @request: the handle to the io or task management request object to
- *    terminate.
- *
- * Indicate if the controller successfully began the terminate process for the
- * IO request. SCI_SUCCESS if the terminate process was successfully started
- * for the request. Determine the failure situations and return values.
- */
-enum sci_status scic_controller_terminate_request(
-	struct isci_host *ihost,
-	struct isci_remote_device *idev,
-	struct isci_request *ireq)
+enum sci_status sci_controller_terminate_request(struct isci_host *ihost,
+						 struct isci_remote_device *idev,
+						 struct isci_request *ireq)
 {
+	/* terminate an ongoing (i.e. started) core IO request.  This does not
+	 * abort the IO request at the target, but rather removes the IO
+	 * request from the host controller.
+	 */
 	enum sci_status status;
 
 	if (ihost->sm.current_state_id != SCIC_READY) {
@@ -2824,7 +2647,7 @@ enum sci_status scic_controller_terminate_request(
 		return SCI_FAILURE_INVALID_STATE;
 	}
 
-	status = scic_sds_io_request_terminate(ireq);
+	status = sci_io_request_terminate(ireq);
 	if (status != SCI_SUCCESS)
 		return status;
 
@@ -2832,27 +2655,25 @@ enum sci_status scic_controller_terminate_request(
 	 * Utilize the original post context command and or in the POST_TC_ABORT
 	 * request sub-type.
 	 */
-	scic_sds_controller_post_request(ihost,
-		scic_sds_request_get_post_context(ireq) |
-		SCU_CONTEXT_COMMAND_REQUEST_POST_TC_ABORT);
+	sci_controller_post_request(ihost,
+				    ireq->post_context | SCU_CONTEXT_COMMAND_REQUEST_POST_TC_ABORT);
 	return SCI_SUCCESS;
 }
 
 /**
- * scic_controller_complete_io() - This method will perform core specific
+ * sci_controller_complete_io() - This method will perform core specific
  *    completion operations for an IO request.  After this method is invoked,
  *    the user should consider the IO request as invalid until it is properly
  *    reused (i.e. re-constructed).
- * @controller: The handle to the controller object for which to complete the
+ * @ihost: The handle to the controller object for which to complete the
  *    IO request.
- * @remote_device: The handle to the remote device object for which to complete
+ * @idev: The handle to the remote device object for which to complete
  *    the IO request.
- * @io_request: the handle to the io request object to complete.
+ * @ireq: the handle to the io request object to complete.
  */
-enum sci_status scic_controller_complete_io(
-	struct isci_host *ihost,
-	struct isci_remote_device *idev,
-	struct isci_request *ireq)
+enum sci_status sci_controller_complete_io(struct isci_host *ihost,
+					   struct isci_remote_device *idev,
+					   struct isci_request *ireq)
 {
 	enum sci_status status;
 	u16 index;
@@ -2862,7 +2683,7 @@ enum sci_status scic_controller_complete_io(
 		/* XXX: Implement this function */
 		return SCI_FAILURE;
 	case SCIC_READY:
-		status = scic_sds_remote_device_complete_io(ihost, idev, ireq);
+		status = sci_remote_device_complete_io(ihost, idev, ireq);
 		if (status != SCI_SUCCESS)
 			return status;
 
@@ -2876,7 +2697,7 @@ enum sci_status scic_controller_complete_io(
 
 }
 
-enum sci_status scic_controller_continue_io(struct isci_request *ireq)
+enum sci_status sci_controller_continue_io(struct isci_request *ireq)
 {
 	struct isci_host *ihost = ireq->owning_controller;
 
@@ -2886,12 +2707,12 @@ enum sci_status scic_controller_continue_io(struct isci_request *ireq)
 	}
 
 	set_bit(IREQ_ACTIVE, &ireq->flags);
-	scic_sds_controller_post_request(ihost, scic_sds_request_get_post_context(ireq));
+	sci_controller_post_request(ihost, sci_request_get_post_context(ireq));
 	return SCI_SUCCESS;
 }
 
 /**
- * scic_controller_start_task() - This method is called by the SCIC user to
+ * sci_controller_start_task() - This method is called by the SCIC user to
  *    send/start a framework task management request.
  * @controller: the handle to the controller object for which to start the task
  *    management request.
@@ -2899,10 +2720,9 @@ enum sci_status scic_controller_continue_io(struct isci_request *ireq)
  *    the task management request.
  * @task_request: the handle to the task request object to start.
  */
-enum sci_task_status scic_controller_start_task(
-	struct isci_host *ihost,
-	struct isci_remote_device *idev,
-	struct isci_request *ireq)
+enum sci_task_status sci_controller_start_task(struct isci_host *ihost,
+					       struct isci_remote_device *idev,
+					       struct isci_request *ireq)
 {
 	enum sci_status status;
 
@@ -2914,7 +2734,7 @@ enum sci_task_status scic_controller_start_task(
 		return SCI_TASK_FAILURE_INVALID_STATE;
 	}
 
-	status = scic_sds_remote_device_start_task(ihost, idev, ireq);
+	status = sci_remote_device_start_task(ihost, idev, ireq);
 	switch (status) {
 	case SCI_FAILURE_RESET_DEVICE_PARTIAL_SUCCESS:
 		set_bit(IREQ_ACTIVE, &ireq->flags);
@@ -2928,8 +2748,8 @@ enum sci_task_status scic_controller_start_task(
 	case SCI_SUCCESS:
 		set_bit(IREQ_ACTIVE, &ireq->flags);
 
-		scic_sds_controller_post_request(ihost,
-			scic_sds_request_get_post_context(ireq));
+		sci_controller_post_request(ihost,
+			sci_request_get_post_context(ireq));
 		break;
 	default:
 		break;

commit d9dcb4ba791de2a06b19ac47cd61601cf3d4e208
Author: Dan Williams <dan.j.williams@intel.com>
Date:   Thu Jun 30 17:38:32 2011 -0700

    isci: unify isci_host and scic_sds_controller
    
    Remove the distinction between these two implementations and unify on
    isci_host (local instances named ihost).  Hmmm, we had two
    'oem_parameters' instances, one was unused... nice.
    
    Reported-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/drivers/scsi/isci/host.c b/drivers/scsi/isci/host.c
index 45d7f71c609a..bb298f8f609a 100644
--- a/drivers/scsi/isci/host.c
+++ b/drivers/scsi/isci/host.c
@@ -181,35 +181,35 @@ void sci_change_state(struct sci_base_state_machine *sm, u32 next_state)
 }
 
 static bool scic_sds_controller_completion_queue_has_entries(
-	struct scic_sds_controller *scic)
+	struct isci_host *ihost)
 {
-	u32 get_value = scic->completion_queue_get;
+	u32 get_value = ihost->completion_queue_get;
 	u32 get_index = get_value & SMU_COMPLETION_QUEUE_GET_POINTER_MASK;
 
 	if (NORMALIZE_GET_POINTER_CYCLE_BIT(get_value) ==
-	    COMPLETION_QUEUE_CYCLE_BIT(scic->completion_queue[get_index]))
+	    COMPLETION_QUEUE_CYCLE_BIT(ihost->completion_queue[get_index]))
 		return true;
 
 	return false;
 }
 
-static bool scic_sds_controller_isr(struct scic_sds_controller *scic)
+static bool scic_sds_controller_isr(struct isci_host *ihost)
 {
-	if (scic_sds_controller_completion_queue_has_entries(scic)) {
+	if (scic_sds_controller_completion_queue_has_entries(ihost)) {
 		return true;
 	} else {
 		/*
 		 * we have a spurious interrupt it could be that we have already
 		 * emptied the completion queue from a previous interrupt */
-		writel(SMU_ISR_COMPLETION, &scic->smu_registers->interrupt_status);
+		writel(SMU_ISR_COMPLETION, &ihost->smu_registers->interrupt_status);
 
 		/*
 		 * There is a race in the hardware that could cause us not to be notified
 		 * of an interrupt completion if we do not take this step.  We will mask
 		 * then unmask the interrupts so if there is another interrupt pending
 		 * the clearing of the interrupt source we get the next interrupt message. */
-		writel(0xFF000000, &scic->smu_registers->interrupt_mask);
-		writel(0, &scic->smu_registers->interrupt_mask);
+		writel(0xFF000000, &ihost->smu_registers->interrupt_mask);
+		writel(0, &ihost->smu_registers->interrupt_mask);
 	}
 
 	return false;
@@ -219,18 +219,18 @@ irqreturn_t isci_msix_isr(int vec, void *data)
 {
 	struct isci_host *ihost = data;
 
-	if (scic_sds_controller_isr(&ihost->sci))
+	if (scic_sds_controller_isr(ihost))
 		tasklet_schedule(&ihost->completion_tasklet);
 
 	return IRQ_HANDLED;
 }
 
-static bool scic_sds_controller_error_isr(struct scic_sds_controller *scic)
+static bool scic_sds_controller_error_isr(struct isci_host *ihost)
 {
 	u32 interrupt_status;
 
 	interrupt_status =
-		readl(&scic->smu_registers->interrupt_status);
+		readl(&ihost->smu_registers->interrupt_status);
 	interrupt_status &= (SMU_ISR_QUEUE_ERROR | SMU_ISR_QUEUE_SUSPEND);
 
 	if (interrupt_status != 0) {
@@ -246,28 +246,27 @@ static bool scic_sds_controller_error_isr(struct scic_sds_controller *scic)
 	 * then unmask the error interrupts so if there was another interrupt
 	 * pending we will be notified.
 	 * Could we write the value of (SMU_ISR_QUEUE_ERROR | SMU_ISR_QUEUE_SUSPEND)? */
-	writel(0xff, &scic->smu_registers->interrupt_mask);
-	writel(0, &scic->smu_registers->interrupt_mask);
+	writel(0xff, &ihost->smu_registers->interrupt_mask);
+	writel(0, &ihost->smu_registers->interrupt_mask);
 
 	return false;
 }
 
-static void scic_sds_controller_task_completion(struct scic_sds_controller *scic,
+static void scic_sds_controller_task_completion(struct isci_host *ihost,
 						u32 completion_entry)
 {
 	u32 index = SCU_GET_COMPLETION_INDEX(completion_entry);
-	struct isci_host *ihost = scic_to_ihost(scic);
 	struct isci_request *ireq = ihost->reqs[index];
 
 	/* Make sure that we really want to process this IO request */
 	if (test_bit(IREQ_ACTIVE, &ireq->flags) &&
 	    ireq->io_tag != SCI_CONTROLLER_INVALID_IO_TAG &&
-	    ISCI_TAG_SEQ(ireq->io_tag) == scic->io_request_sequence[index])
+	    ISCI_TAG_SEQ(ireq->io_tag) == ihost->io_request_sequence[index])
 		/* Yep this is a valid io request pass it along to the io request handler */
 		scic_sds_io_request_tc_completion(ireq, completion_entry);
 }
 
-static void scic_sds_controller_sdma_completion(struct scic_sds_controller *scic,
+static void scic_sds_controller_sdma_completion(struct isci_host *ihost,
 						u32 completion_entry)
 {
 	u32 index;
@@ -279,8 +278,8 @@ static void scic_sds_controller_sdma_completion(struct scic_sds_controller *scic
 	switch (scu_get_command_request_type(completion_entry)) {
 	case SCU_CONTEXT_COMMAND_REQUEST_TYPE_POST_TC:
 	case SCU_CONTEXT_COMMAND_REQUEST_TYPE_DUMP_TC:
-		ireq = scic_to_ihost(scic)->reqs[index];
-		dev_warn(scic_to_dev(scic), "%s: %x for io request %p\n",
+		ireq = ihost->reqs[index];
+		dev_warn(&ihost->pdev->dev, "%s: %x for io request %p\n",
 			 __func__, completion_entry, ireq);
 		/* @todo For a post TC operation we need to fail the IO
 		 * request
@@ -289,27 +288,26 @@ static void scic_sds_controller_sdma_completion(struct scic_sds_controller *scic
 	case SCU_CONTEXT_COMMAND_REQUEST_TYPE_DUMP_RNC:
 	case SCU_CONTEXT_COMMAND_REQUEST_TYPE_OTHER_RNC:
 	case SCU_CONTEXT_COMMAND_REQUEST_TYPE_POST_RNC:
-		idev = scic->device_table[index];
-		dev_warn(scic_to_dev(scic), "%s: %x for device %p\n",
+		idev = ihost->device_table[index];
+		dev_warn(&ihost->pdev->dev, "%s: %x for device %p\n",
 			 __func__, completion_entry, idev);
 		/* @todo For a port RNC operation we need to fail the
 		 * device
 		 */
 		break;
 	default:
-		dev_warn(scic_to_dev(scic), "%s: unknown completion type %x\n",
+		dev_warn(&ihost->pdev->dev, "%s: unknown completion type %x\n",
 			 __func__, completion_entry);
 		break;
 	}
 }
 
-static void scic_sds_controller_unsolicited_frame(struct scic_sds_controller *scic,
+static void scic_sds_controller_unsolicited_frame(struct isci_host *ihost,
 						  u32 completion_entry)
 {
 	u32 index;
 	u32 frame_index;
 
-	struct isci_host *ihost = scic_to_ihost(scic);
 	struct scu_unsolicited_frame_header *frame_header;
 	struct isci_phy *iphy;
 	struct isci_remote_device *idev;
@@ -318,15 +316,15 @@ static void scic_sds_controller_unsolicited_frame(struct scic_sds_controller *sc
 
 	frame_index = SCU_GET_FRAME_INDEX(completion_entry);
 
-	frame_header = scic->uf_control.buffers.array[frame_index].header;
-	scic->uf_control.buffers.array[frame_index].state = UNSOLICITED_FRAME_IN_USE;
+	frame_header = ihost->uf_control.buffers.array[frame_index].header;
+	ihost->uf_control.buffers.array[frame_index].state = UNSOLICITED_FRAME_IN_USE;
 
 	if (SCU_GET_FRAME_ERROR(completion_entry)) {
 		/*
 		 * / @todo If the IAF frame or SIGNATURE FIS frame has an error will
 		 * /       this cause a problem? We expect the phy initialization will
 		 * /       fail if there is an error in the frame. */
-		scic_sds_controller_release_frame(scic, frame_index);
+		scic_sds_controller_release_frame(ihost, frame_index);
 		return;
 	}
 
@@ -347,15 +345,15 @@ static void scic_sds_controller_unsolicited_frame(struct scic_sds_controller *sc
 			iphy = &ihost->phys[index];
 			result = scic_sds_phy_frame_handler(iphy, frame_index);
 		} else {
-			if (index < scic->remote_node_entries)
-				idev = scic->device_table[index];
+			if (index < ihost->remote_node_entries)
+				idev = ihost->device_table[index];
 			else
 				idev = NULL;
 
 			if (idev != NULL)
 				result = scic_sds_remote_device_frame_handler(idev, frame_index);
 			else
-				scic_sds_controller_release_frame(scic, frame_index);
+				scic_sds_controller_release_frame(ihost, frame_index);
 		}
 	}
 
@@ -366,10 +364,9 @@ static void scic_sds_controller_unsolicited_frame(struct scic_sds_controller *sc
 	}
 }
 
-static void scic_sds_controller_event_completion(struct scic_sds_controller *scic,
+static void scic_sds_controller_event_completion(struct isci_host *ihost,
 						 u32 completion_entry)
 {
-	struct isci_host *ihost = scic_to_ihost(scic);
 	struct isci_remote_device *idev;
 	struct isci_request *ireq;
 	struct isci_phy *iphy;
@@ -380,11 +377,11 @@ static void scic_sds_controller_event_completion(struct scic_sds_controller *sci
 	switch (scu_get_event_type(completion_entry)) {
 	case SCU_EVENT_TYPE_SMU_COMMAND_ERROR:
 		/* / @todo The driver did something wrong and we need to fix the condtion. */
-		dev_err(scic_to_dev(scic),
+		dev_err(&ihost->pdev->dev,
 			"%s: SCIC Controller 0x%p received SMU command error "
 			"0x%x\n",
 			__func__,
-			scic,
+			ihost,
 			completion_entry);
 		break;
 
@@ -394,11 +391,11 @@ static void scic_sds_controller_event_completion(struct scic_sds_controller *sci
 		/*
 		 * / @todo This is a hardware failure and its likely that we want to
 		 * /       reset the controller. */
-		dev_err(scic_to_dev(scic),
+		dev_err(&ihost->pdev->dev,
 			"%s: SCIC Controller 0x%p received fatal controller "
 			"event  0x%x\n",
 			__func__,
-			scic,
+			ihost,
 			completion_entry);
 		break;
 
@@ -415,27 +412,27 @@ static void scic_sds_controller_event_completion(struct scic_sds_controller *sci
 			if (ireq != NULL)
 				scic_sds_io_request_event_handler(ireq, completion_entry);
 			else
-				dev_warn(scic_to_dev(scic),
+				dev_warn(&ihost->pdev->dev,
 					 "%s: SCIC Controller 0x%p received "
 					 "event 0x%x for io request object "
 					 "that doesnt exist.\n",
 					 __func__,
-					 scic,
+					 ihost,
 					 completion_entry);
 
 			break;
 
 		case SCU_EVENT_SPECIFIC_IT_NEXUS_TIMEOUT:
-			idev = scic->device_table[index];
+			idev = ihost->device_table[index];
 			if (idev != NULL)
 				scic_sds_remote_device_event_handler(idev, completion_entry);
 			else
-				dev_warn(scic_to_dev(scic),
+				dev_warn(&ihost->pdev->dev,
 					 "%s: SCIC Controller 0x%p received "
 					 "event 0x%x for remote device object "
 					 "that doesnt exist.\n",
 					 __func__,
-					 scic,
+					 ihost,
 					 completion_entry);
 
 			break;
@@ -459,25 +456,25 @@ static void scic_sds_controller_event_completion(struct scic_sds_controller *sci
 	case SCU_EVENT_TYPE_RNC_SUSPEND_TX:
 	case SCU_EVENT_TYPE_RNC_SUSPEND_TX_RX:
 	case SCU_EVENT_TYPE_RNC_OPS_MISC:
-		if (index < scic->remote_node_entries) {
-			idev = scic->device_table[index];
+		if (index < ihost->remote_node_entries) {
+			idev = ihost->device_table[index];
 
 			if (idev != NULL)
 				scic_sds_remote_device_event_handler(idev, completion_entry);
 		} else
-			dev_err(scic_to_dev(scic),
+			dev_err(&ihost->pdev->dev,
 				"%s: SCIC Controller 0x%p received event 0x%x "
 				"for remote device object 0x%0x that doesnt "
 				"exist.\n",
 				__func__,
-				scic,
+				ihost,
 				completion_entry,
 				index);
 
 		break;
 
 	default:
-		dev_warn(scic_to_dev(scic),
+		dev_warn(&ihost->pdev->dev,
 			 "%s: SCIC Controller received unknown event code %x\n",
 			 __func__,
 			 completion_entry);
@@ -485,7 +482,7 @@ static void scic_sds_controller_event_completion(struct scic_sds_controller *sci
 	}
 }
 
-static void scic_sds_controller_process_completions(struct scic_sds_controller *scic)
+static void scic_sds_controller_process_completions(struct isci_host *ihost)
 {
 	u32 completion_count = 0;
 	u32 completion_entry;
@@ -494,47 +491,47 @@ static void scic_sds_controller_process_completions(struct scic_sds_controller *
 	u32 event_get;
 	u32 event_cycle;
 
-	dev_dbg(scic_to_dev(scic),
+	dev_dbg(&ihost->pdev->dev,
 		"%s: completion queue begining get:0x%08x\n",
 		__func__,
-		scic->completion_queue_get);
+		ihost->completion_queue_get);
 
 	/* Get the component parts of the completion queue */
-	get_index = NORMALIZE_GET_POINTER(scic->completion_queue_get);
-	get_cycle = SMU_CQGR_CYCLE_BIT & scic->completion_queue_get;
+	get_index = NORMALIZE_GET_POINTER(ihost->completion_queue_get);
+	get_cycle = SMU_CQGR_CYCLE_BIT & ihost->completion_queue_get;
 
-	event_get = NORMALIZE_EVENT_POINTER(scic->completion_queue_get);
-	event_cycle = SMU_CQGR_EVENT_CYCLE_BIT & scic->completion_queue_get;
+	event_get = NORMALIZE_EVENT_POINTER(ihost->completion_queue_get);
+	event_cycle = SMU_CQGR_EVENT_CYCLE_BIT & ihost->completion_queue_get;
 
 	while (
 		NORMALIZE_GET_POINTER_CYCLE_BIT(get_cycle)
-		== COMPLETION_QUEUE_CYCLE_BIT(scic->completion_queue[get_index])
+		== COMPLETION_QUEUE_CYCLE_BIT(ihost->completion_queue[get_index])
 		) {
 		completion_count++;
 
-		completion_entry = scic->completion_queue[get_index];
+		completion_entry = ihost->completion_queue[get_index];
 
 		/* increment the get pointer and check for rollover to toggle the cycle bit */
 		get_cycle ^= ((get_index+1) & SCU_MAX_COMPLETION_QUEUE_ENTRIES) <<
 			     (SMU_COMPLETION_QUEUE_GET_CYCLE_BIT_SHIFT - SCU_MAX_COMPLETION_QUEUE_SHIFT);
 		get_index = (get_index+1) & (SCU_MAX_COMPLETION_QUEUE_ENTRIES-1);
 
-		dev_dbg(scic_to_dev(scic),
+		dev_dbg(&ihost->pdev->dev,
 			"%s: completion queue entry:0x%08x\n",
 			__func__,
 			completion_entry);
 
 		switch (SCU_GET_COMPLETION_TYPE(completion_entry)) {
 		case SCU_COMPLETION_TYPE_TASK:
-			scic_sds_controller_task_completion(scic, completion_entry);
+			scic_sds_controller_task_completion(ihost, completion_entry);
 			break;
 
 		case SCU_COMPLETION_TYPE_SDMA:
-			scic_sds_controller_sdma_completion(scic, completion_entry);
+			scic_sds_controller_sdma_completion(ihost, completion_entry);
 			break;
 
 		case SCU_COMPLETION_TYPE_UFI:
-			scic_sds_controller_unsolicited_frame(scic, completion_entry);
+			scic_sds_controller_unsolicited_frame(ihost, completion_entry);
 			break;
 
 		case SCU_COMPLETION_TYPE_EVENT:
@@ -543,11 +540,11 @@ static void scic_sds_controller_process_completions(struct scic_sds_controller *
 				       (SMU_COMPLETION_QUEUE_GET_EVENT_CYCLE_BIT_SHIFT - SCU_MAX_EVENTS_SHIFT);
 			event_get = (event_get+1) & (SCU_MAX_EVENTS-1);
 
-			scic_sds_controller_event_completion(scic, completion_entry);
+			scic_sds_controller_event_completion(ihost, completion_entry);
 			break;
 		}
 		default:
-			dev_warn(scic_to_dev(scic),
+			dev_warn(&ihost->pdev->dev,
 				 "%s: SCIC Controller received unknown "
 				 "completion type %x\n",
 				 __func__,
@@ -558,7 +555,7 @@ static void scic_sds_controller_process_completions(struct scic_sds_controller *
 
 	/* Update the get register if we completed one or more entries */
 	if (completion_count > 0) {
-		scic->completion_queue_get =
+		ihost->completion_queue_get =
 			SMU_CQGR_GEN_BIT(ENABLE) |
 			SMU_CQGR_GEN_BIT(EVENT_ENABLE) |
 			event_cycle |
@@ -566,35 +563,35 @@ static void scic_sds_controller_process_completions(struct scic_sds_controller *
 			get_cycle |
 			SMU_CQGR_GEN_VAL(POINTER, get_index);
 
-		writel(scic->completion_queue_get,
-		       &scic->smu_registers->completion_queue_get);
+		writel(ihost->completion_queue_get,
+		       &ihost->smu_registers->completion_queue_get);
 
 	}
 
-	dev_dbg(scic_to_dev(scic),
+	dev_dbg(&ihost->pdev->dev,
 		"%s: completion queue ending get:0x%08x\n",
 		__func__,
-		scic->completion_queue_get);
+		ihost->completion_queue_get);
 
 }
 
-static void scic_sds_controller_error_handler(struct scic_sds_controller *scic)
+static void scic_sds_controller_error_handler(struct isci_host *ihost)
 {
 	u32 interrupt_status;
 
 	interrupt_status =
-		readl(&scic->smu_registers->interrupt_status);
+		readl(&ihost->smu_registers->interrupt_status);
 
 	if ((interrupt_status & SMU_ISR_QUEUE_SUSPEND) &&
-	    scic_sds_controller_completion_queue_has_entries(scic)) {
+	    scic_sds_controller_completion_queue_has_entries(ihost)) {
 
-		scic_sds_controller_process_completions(scic);
-		writel(SMU_ISR_QUEUE_SUSPEND, &scic->smu_registers->interrupt_status);
+		scic_sds_controller_process_completions(ihost);
+		writel(SMU_ISR_QUEUE_SUSPEND, &ihost->smu_registers->interrupt_status);
 	} else {
-		dev_err(scic_to_dev(scic), "%s: status: %#x\n", __func__,
+		dev_err(&ihost->pdev->dev, "%s: status: %#x\n", __func__,
 			interrupt_status);
 
-		sci_change_state(&scic->sm, SCIC_FAILED);
+		sci_change_state(&ihost->sm, SCIC_FAILED);
 
 		return;
 	}
@@ -602,22 +599,21 @@ static void scic_sds_controller_error_handler(struct scic_sds_controller *scic)
 	/* If we dont process any completions I am not sure that we want to do this.
 	 * We are in the middle of a hardware fault and should probably be reset.
 	 */
-	writel(0, &scic->smu_registers->interrupt_mask);
+	writel(0, &ihost->smu_registers->interrupt_mask);
 }
 
 irqreturn_t isci_intx_isr(int vec, void *data)
 {
 	irqreturn_t ret = IRQ_NONE;
 	struct isci_host *ihost = data;
-	struct scic_sds_controller *scic = &ihost->sci;
 
-	if (scic_sds_controller_isr(scic)) {
-		writel(SMU_ISR_COMPLETION, &scic->smu_registers->interrupt_status);
+	if (scic_sds_controller_isr(ihost)) {
+		writel(SMU_ISR_COMPLETION, &ihost->smu_registers->interrupt_status);
 		tasklet_schedule(&ihost->completion_tasklet);
 		ret = IRQ_HANDLED;
-	} else if (scic_sds_controller_error_isr(scic)) {
+	} else if (scic_sds_controller_error_isr(ihost)) {
 		spin_lock(&ihost->scic_lock);
-		scic_sds_controller_error_handler(scic);
+		scic_sds_controller_error_handler(ihost);
 		spin_unlock(&ihost->scic_lock);
 		ret = IRQ_HANDLED;
 	}
@@ -629,8 +625,8 @@ irqreturn_t isci_error_isr(int vec, void *data)
 {
 	struct isci_host *ihost = data;
 
-	if (scic_sds_controller_error_isr(&ihost->sci))
-		scic_sds_controller_error_handler(&ihost->sci);
+	if (scic_sds_controller_error_isr(ihost))
+		scic_sds_controller_error_handler(ihost);
 
 	return IRQ_HANDLED;
 }
@@ -685,11 +681,10 @@ int isci_host_scan_finished(struct Scsi_Host *shost, unsigned long time)
  * This method returns the number of milliseconds for the suggested start
  * operation timeout.
  */
-static u32 scic_controller_get_suggested_start_timeout(
-	struct scic_sds_controller *sc)
+static u32 scic_controller_get_suggested_start_timeout(struct isci_host *ihost)
 {
 	/* Validate the user supplied parameters. */
-	if (sc == NULL)
+	if (!ihost)
 		return 0;
 
 	/*
@@ -711,35 +706,32 @@ static u32 scic_controller_get_suggested_start_timeout(
 		+ ((SCI_MAX_PHYS - 1) * SCIC_SDS_CONTROLLER_POWER_CONTROL_INTERVAL);
 }
 
-static void scic_controller_enable_interrupts(
-	struct scic_sds_controller *scic)
+static void scic_controller_enable_interrupts(struct isci_host *ihost)
 {
-	BUG_ON(scic->smu_registers == NULL);
-	writel(0, &scic->smu_registers->interrupt_mask);
+	BUG_ON(ihost->smu_registers == NULL);
+	writel(0, &ihost->smu_registers->interrupt_mask);
 }
 
-void scic_controller_disable_interrupts(
-	struct scic_sds_controller *scic)
+void scic_controller_disable_interrupts(struct isci_host *ihost)
 {
-	BUG_ON(scic->smu_registers == NULL);
-	writel(0xffffffff, &scic->smu_registers->interrupt_mask);
+	BUG_ON(ihost->smu_registers == NULL);
+	writel(0xffffffff, &ihost->smu_registers->interrupt_mask);
 }
 
-static void scic_sds_controller_enable_port_task_scheduler(
-	struct scic_sds_controller *scic)
+static void scic_sds_controller_enable_port_task_scheduler(struct isci_host *ihost)
 {
 	u32 port_task_scheduler_value;
 
 	port_task_scheduler_value =
-		readl(&scic->scu_registers->peg0.ptsg.control);
+		readl(&ihost->scu_registers->peg0.ptsg.control);
 	port_task_scheduler_value |=
 		(SCU_PTSGCR_GEN_BIT(ETM_ENABLE) |
 		 SCU_PTSGCR_GEN_BIT(PTSG_ENABLE));
 	writel(port_task_scheduler_value,
-	       &scic->scu_registers->peg0.ptsg.control);
+	       &ihost->scu_registers->peg0.ptsg.control);
 }
 
-static void scic_sds_controller_assign_task_entries(struct scic_sds_controller *scic)
+static void scic_sds_controller_assign_task_entries(struct isci_host *ihost)
 {
 	u32 task_assignment;
 
@@ -749,32 +741,32 @@ static void scic_sds_controller_assign_task_entries(struct scic_sds_controller *
 	 */
 
 	task_assignment =
-		readl(&scic->smu_registers->task_context_assignment[0]);
+		readl(&ihost->smu_registers->task_context_assignment[0]);
 
 	task_assignment |= (SMU_TCA_GEN_VAL(STARTING, 0)) |
-		(SMU_TCA_GEN_VAL(ENDING,  scic->task_context_entries - 1)) |
+		(SMU_TCA_GEN_VAL(ENDING,  ihost->task_context_entries - 1)) |
 		(SMU_TCA_GEN_BIT(RANGE_CHECK_ENABLE));
 
 	writel(task_assignment,
-		&scic->smu_registers->task_context_assignment[0]);
+		&ihost->smu_registers->task_context_assignment[0]);
 
 }
 
-static void scic_sds_controller_initialize_completion_queue(struct scic_sds_controller *scic)
+static void scic_sds_controller_initialize_completion_queue(struct isci_host *ihost)
 {
 	u32 index;
 	u32 completion_queue_control_value;
 	u32 completion_queue_get_value;
 	u32 completion_queue_put_value;
 
-	scic->completion_queue_get = 0;
+	ihost->completion_queue_get = 0;
 
 	completion_queue_control_value =
 		(SMU_CQC_QUEUE_LIMIT_SET(SCU_MAX_COMPLETION_QUEUE_ENTRIES - 1) |
 		 SMU_CQC_EVENT_LIMIT_SET(SCU_MAX_EVENTS - 1));
 
 	writel(completion_queue_control_value,
-	       &scic->smu_registers->completion_queue_control);
+	       &ihost->smu_registers->completion_queue_control);
 
 
 	/* Set the completion queue get pointer and enable the queue */
@@ -786,7 +778,7 @@ static void scic_sds_controller_initialize_completion_queue(struct scic_sds_cont
 		);
 
 	writel(completion_queue_get_value,
-	       &scic->smu_registers->completion_queue_get);
+	       &ihost->smu_registers->completion_queue_get);
 
 	/* Set the completion queue put pointer */
 	completion_queue_put_value = (
@@ -795,7 +787,7 @@ static void scic_sds_controller_initialize_completion_queue(struct scic_sds_cont
 		);
 
 	writel(completion_queue_put_value,
-	       &scic->smu_registers->completion_queue_put);
+	       &ihost->smu_registers->completion_queue_put);
 
 	/* Initialize the cycle bit of the completion queue entries */
 	for (index = 0; index < SCU_MAX_COMPLETION_QUEUE_ENTRIES; index++) {
@@ -803,11 +795,11 @@ static void scic_sds_controller_initialize_completion_queue(struct scic_sds_cont
 		 * If get.cycle_bit != completion_queue.cycle_bit
 		 * its not a valid completion queue entry
 		 * so at system start all entries are invalid */
-		scic->completion_queue[index] = 0x80000000;
+		ihost->completion_queue[index] = 0x80000000;
 	}
 }
 
-static void scic_sds_controller_initialize_unsolicited_frame_queue(struct scic_sds_controller *scic)
+static void scic_sds_controller_initialize_unsolicited_frame_queue(struct isci_host *ihost)
 {
 	u32 frame_queue_control_value;
 	u32 frame_queue_get_value;
@@ -818,7 +810,7 @@ static void scic_sds_controller_initialize_unsolicited_frame_queue(struct scic_s
 		SCU_UFQC_GEN_VAL(QUEUE_SIZE, SCU_MAX_UNSOLICITED_FRAMES);
 
 	writel(frame_queue_control_value,
-	       &scic->scu_registers->sdma.unsolicited_frame_queue_control);
+	       &ihost->scu_registers->sdma.unsolicited_frame_queue_control);
 
 	/* Setup the get pointer for the unsolicited frame queue */
 	frame_queue_get_value = (
@@ -827,11 +819,11 @@ static void scic_sds_controller_initialize_unsolicited_frame_queue(struct scic_s
 		);
 
 	writel(frame_queue_get_value,
-	       &scic->scu_registers->sdma.unsolicited_frame_get_pointer);
+	       &ihost->scu_registers->sdma.unsolicited_frame_get_pointer);
 	/* Setup the put pointer for the unsolicited frame queue */
 	frame_queue_put_value = SCU_UFQPP_GEN_VAL(POINTER, 0);
 	writel(frame_queue_put_value,
-	       &scic->scu_registers->sdma.unsolicited_frame_put_pointer);
+	       &ihost->scu_registers->sdma.unsolicited_frame_put_pointer);
 }
 
 /**
@@ -846,17 +838,16 @@ static void scic_sds_controller_initialize_unsolicited_frame_queue(struct scic_s
  * none.
  */
 static void scic_sds_controller_transition_to_ready(
-	struct scic_sds_controller *scic,
+	struct isci_host *ihost,
 	enum sci_status status)
 {
-	struct isci_host *ihost = scic_to_ihost(scic);
 
-	if (scic->sm.current_state_id == SCIC_STARTING) {
+	if (ihost->sm.current_state_id == SCIC_STARTING) {
 		/*
 		 * We move into the ready state, because some of the phys/ports
 		 * may be up and operational.
 		 */
-		sci_change_state(&scic->sm, SCIC_READY);
+		sci_change_state(&ihost->sm, SCIC_READY);
 
 		isci_host_start_complete(ihost, status);
 	}
@@ -892,19 +883,18 @@ static bool is_phy_starting(struct isci_phy *iphy)
  * controller to the READY state and inform the user
  * (scic_cb_controller_start_complete()).
  */
-static enum sci_status scic_sds_controller_start_next_phy(struct scic_sds_controller *scic)
+static enum sci_status scic_sds_controller_start_next_phy(struct isci_host *ihost)
 {
-	struct isci_host *ihost = scic_to_ihost(scic);
-	struct scic_sds_oem_params *oem = &scic->oem_parameters.sds1;
+	struct scic_sds_oem_params *oem = &ihost->oem_parameters.sds1;
 	struct isci_phy *iphy;
 	enum sci_status status;
 
 	status = SCI_SUCCESS;
 
-	if (scic->phy_startup_timer_pending)
+	if (ihost->phy_startup_timer_pending)
 		return status;
 
-	if (scic->next_phy_to_start >= SCI_MAX_PHYS) {
+	if (ihost->next_phy_to_start >= SCI_MAX_PHYS) {
 		bool is_controller_start_complete = true;
 		u32 state;
 		u8 index;
@@ -934,16 +924,16 @@ static enum sci_status scic_sds_controller_start_next_phy(struct scic_sds_contro
 		 * The controller has successfully finished the start process.
 		 * Inform the SCI Core user and transition to the READY state. */
 		if (is_controller_start_complete == true) {
-			scic_sds_controller_transition_to_ready(scic, SCI_SUCCESS);
-			sci_del_timer(&scic->phy_timer);
-			scic->phy_startup_timer_pending = false;
+			scic_sds_controller_transition_to_ready(ihost, SCI_SUCCESS);
+			sci_del_timer(&ihost->phy_timer);
+			ihost->phy_startup_timer_pending = false;
 		}
 	} else {
-		iphy = &ihost->phys[scic->next_phy_to_start];
+		iphy = &ihost->phys[ihost->next_phy_to_start];
 
 		if (oem->controller.mode_type == SCIC_PORT_MANUAL_CONFIGURATION_MODE) {
 			if (phy_get_non_dummy_port(iphy) == NULL) {
-				scic->next_phy_to_start++;
+				ihost->next_phy_to_start++;
 
 				/* Caution recursion ahead be forwarned
 				 *
@@ -954,27 +944,27 @@ static enum sci_status scic_sds_controller_start_next_phy(struct scic_sds_contro
 				 * incorrectly for the PORT or it was never
 				 * assigned to a PORT
 				 */
-				return scic_sds_controller_start_next_phy(scic);
+				return scic_sds_controller_start_next_phy(ihost);
 			}
 		}
 
 		status = scic_sds_phy_start(iphy);
 
 		if (status == SCI_SUCCESS) {
-			sci_mod_timer(&scic->phy_timer,
+			sci_mod_timer(&ihost->phy_timer,
 				      SCIC_SDS_CONTROLLER_PHY_START_TIMEOUT);
-			scic->phy_startup_timer_pending = true;
+			ihost->phy_startup_timer_pending = true;
 		} else {
-			dev_warn(scic_to_dev(scic),
+			dev_warn(&ihost->pdev->dev,
 				 "%s: Controller stop operation failed "
 				 "to stop phy %d because of status "
 				 "%d.\n",
 				 __func__,
-				 ihost->phys[scic->next_phy_to_start].phy_index,
+				 ihost->phys[ihost->next_phy_to_start].phy_index,
 				 status);
 		}
 
-		scic->next_phy_to_start++;
+		ihost->next_phy_to_start++;
 	}
 
 	return status;
@@ -983,8 +973,7 @@ static enum sci_status scic_sds_controller_start_next_phy(struct scic_sds_contro
 static void phy_startup_timeout(unsigned long data)
 {
 	struct sci_timer *tmr = (struct sci_timer *)data;
-	struct scic_sds_controller *scic = container_of(tmr, typeof(*scic), phy_timer);
-	struct isci_host *ihost = scic_to_ihost(scic);
+	struct isci_host *ihost = container_of(tmr, typeof(*ihost), phy_timer);
 	unsigned long flags;
 	enum sci_status status;
 
@@ -993,10 +982,10 @@ static void phy_startup_timeout(unsigned long data)
 	if (tmr->cancel)
 		goto done;
 
-	scic->phy_startup_timer_pending = false;
+	ihost->phy_startup_timer_pending = false;
 
 	do {
-		status = scic_sds_controller_start_next_phy(scic);
+		status = scic_sds_controller_start_next_phy(ihost);
 	} while (status != SCI_SUCCESS);
 
 done:
@@ -1008,15 +997,14 @@ static u16 isci_tci_active(struct isci_host *ihost)
 	return CIRC_CNT(ihost->tci_head, ihost->tci_tail, SCI_MAX_IO_REQUESTS);
 }
 
-static enum sci_status scic_controller_start(struct scic_sds_controller *scic,
+static enum sci_status scic_controller_start(struct isci_host *ihost,
 					     u32 timeout)
 {
-	struct isci_host *ihost = scic_to_ihost(scic);
 	enum sci_status result;
 	u16 index;
 
-	if (scic->sm.current_state_id != SCIC_INITIALIZED) {
-		dev_warn(scic_to_dev(scic),
+	if (ihost->sm.current_state_id != SCIC_INITIALIZED) {
+		dev_warn(&ihost->pdev->dev,
 			 "SCIC Controller start operation requested in "
 			 "invalid state\n");
 		return SCI_FAILURE_INVALID_STATE;
@@ -1026,34 +1014,34 @@ static enum sci_status scic_controller_start(struct scic_sds_controller *scic,
 	BUILD_BUG_ON(SCI_MAX_IO_REQUESTS > 1 << sizeof(ihost->tci_pool[0]) * 8);
 	ihost->tci_head = 0;
 	ihost->tci_tail = 0;
-	for (index = 0; index < scic->task_context_entries; index++)
+	for (index = 0; index < ihost->task_context_entries; index++)
 		isci_tci_free(ihost, index);
 
 	/* Build the RNi free pool */
 	scic_sds_remote_node_table_initialize(
-			&scic->available_remote_nodes,
-			scic->remote_node_entries);
+			&ihost->available_remote_nodes,
+			ihost->remote_node_entries);
 
 	/*
 	 * Before anything else lets make sure we will not be
 	 * interrupted by the hardware.
 	 */
-	scic_controller_disable_interrupts(scic);
+	scic_controller_disable_interrupts(ihost);
 
 	/* Enable the port task scheduler */
-	scic_sds_controller_enable_port_task_scheduler(scic);
+	scic_sds_controller_enable_port_task_scheduler(ihost);
 
-	/* Assign all the task entries to scic physical function */
-	scic_sds_controller_assign_task_entries(scic);
+	/* Assign all the task entries to ihost physical function */
+	scic_sds_controller_assign_task_entries(ihost);
 
 	/* Now initialize the completion queue */
-	scic_sds_controller_initialize_completion_queue(scic);
+	scic_sds_controller_initialize_completion_queue(ihost);
 
 	/* Initialize the unsolicited frame queue for use */
-	scic_sds_controller_initialize_unsolicited_frame_queue(scic);
+	scic_sds_controller_initialize_unsolicited_frame_queue(ihost);
 
 	/* Start all of the ports on this controller */
-	for (index = 0; index < scic->logical_port_entries; index++) {
+	for (index = 0; index < ihost->logical_port_entries; index++) {
 		struct isci_port *iport = &ihost->ports[index];
 
 		result = scic_sds_port_start(iport);
@@ -1061,11 +1049,11 @@ static enum sci_status scic_controller_start(struct scic_sds_controller *scic,
 			return result;
 	}
 
-	scic_sds_controller_start_next_phy(scic);
+	scic_sds_controller_start_next_phy(ihost);
 
-	sci_mod_timer(&scic->timer, timeout);
+	sci_mod_timer(&ihost->timer, timeout);
 
-	sci_change_state(&scic->sm, SCIC_STARTING);
+	sci_change_state(&ihost->sm, SCIC_STARTING);
 
 	return SCI_SUCCESS;
 }
@@ -1073,35 +1061,35 @@ static enum sci_status scic_controller_start(struct scic_sds_controller *scic,
 void isci_host_scan_start(struct Scsi_Host *shost)
 {
 	struct isci_host *ihost = SHOST_TO_SAS_HA(shost)->lldd_ha;
-	unsigned long tmo = scic_controller_get_suggested_start_timeout(&ihost->sci);
+	unsigned long tmo = scic_controller_get_suggested_start_timeout(ihost);
 
 	set_bit(IHOST_START_PENDING, &ihost->flags);
 
 	spin_lock_irq(&ihost->scic_lock);
-	scic_controller_start(&ihost->sci, tmo);
-	scic_controller_enable_interrupts(&ihost->sci);
+	scic_controller_start(ihost, tmo);
+	scic_controller_enable_interrupts(ihost);
 	spin_unlock_irq(&ihost->scic_lock);
 }
 
 static void isci_host_stop_complete(struct isci_host *ihost, enum sci_status completion_status)
 {
 	isci_host_change_state(ihost, isci_stopped);
-	scic_controller_disable_interrupts(&ihost->sci);
+	scic_controller_disable_interrupts(ihost);
 	clear_bit(IHOST_STOP_PENDING, &ihost->flags);
 	wake_up(&ihost->eventq);
 }
 
-static void scic_sds_controller_completion_handler(struct scic_sds_controller *scic)
+static void scic_sds_controller_completion_handler(struct isci_host *ihost)
 {
 	/* Empty out the completion queue */
-	if (scic_sds_controller_completion_queue_has_entries(scic))
-		scic_sds_controller_process_completions(scic);
+	if (scic_sds_controller_completion_queue_has_entries(ihost))
+		scic_sds_controller_process_completions(ihost);
 
 	/* Clear the interrupt and enable all interrupts again */
-	writel(SMU_ISR_COMPLETION, &scic->smu_registers->interrupt_status);
+	writel(SMU_ISR_COMPLETION, &ihost->smu_registers->interrupt_status);
 	/* Could we write the value of SMU_ISR_COMPLETION? */
-	writel(0xFF000000, &scic->smu_registers->interrupt_mask);
-	writel(0, &scic->smu_registers->interrupt_mask);
+	writel(0xFF000000, &ihost->smu_registers->interrupt_mask);
+	writel(0, &ihost->smu_registers->interrupt_mask);
 }
 
 /**
@@ -1114,7 +1102,7 @@ static void scic_sds_controller_completion_handler(struct scic_sds_controller *s
  */
 static void isci_host_completion_routine(unsigned long data)
 {
-	struct isci_host *isci_host = (struct isci_host *)data;
+	struct isci_host *ihost = (struct isci_host *)data;
 	struct list_head    completed_request_list;
 	struct list_head    errored_request_list;
 	struct list_head    *current_position;
@@ -1126,20 +1114,20 @@ static void isci_host_completion_routine(unsigned long data)
 	INIT_LIST_HEAD(&completed_request_list);
 	INIT_LIST_HEAD(&errored_request_list);
 
-	spin_lock_irq(&isci_host->scic_lock);
+	spin_lock_irq(&ihost->scic_lock);
 
-	scic_sds_controller_completion_handler(&isci_host->sci);
+	scic_sds_controller_completion_handler(ihost);
 
 	/* Take the lists of completed I/Os from the host. */
 
-	list_splice_init(&isci_host->requests_to_complete,
+	list_splice_init(&ihost->requests_to_complete,
 			 &completed_request_list);
 
 	/* Take the list of errored I/Os from the host. */
-	list_splice_init(&isci_host->requests_to_errorback,
+	list_splice_init(&ihost->requests_to_errorback,
 			 &errored_request_list);
 
-	spin_unlock_irq(&isci_host->scic_lock);
+	spin_unlock_irq(&ihost->scic_lock);
 
 	/* Process any completions in the lists. */
 	list_for_each_safe(current_position, next_position,
@@ -1150,7 +1138,7 @@ static void isci_host_completion_routine(unsigned long data)
 		task = isci_request_access_task(request);
 
 		/* Normal notification (task_done) */
-		dev_dbg(&isci_host->pdev->dev,
+		dev_dbg(&ihost->pdev->dev,
 			"%s: Normal - request/task = %p/%p\n",
 			__func__,
 			request,
@@ -1169,9 +1157,9 @@ static void isci_host_completion_routine(unsigned long data)
 			}
 		}
 
-		spin_lock_irq(&isci_host->scic_lock);
-		isci_free_tag(isci_host, request->io_tag);
-		spin_unlock_irq(&isci_host->scic_lock);
+		spin_lock_irq(&ihost->scic_lock);
+		isci_free_tag(ihost, request->io_tag);
+		spin_unlock_irq(&ihost->scic_lock);
 	}
 	list_for_each_entry_safe(request, next_request, &errored_request_list,
 				 completed_node) {
@@ -1179,7 +1167,7 @@ static void isci_host_completion_routine(unsigned long data)
 		task = isci_request_access_task(request);
 
 		/* Use sas_task_abort */
-		dev_warn(&isci_host->pdev->dev,
+		dev_warn(&ihost->pdev->dev,
 			 "%s: Error - request/task = %p/%p\n",
 			 __func__,
 			 request,
@@ -1202,13 +1190,13 @@ static void isci_host_completion_routine(unsigned long data)
 			 * it.
 			 */
 
-			spin_lock_irq(&isci_host->scic_lock);
+			spin_lock_irq(&ihost->scic_lock);
 			/* Remove the request from the remote device's list
 			* of pending requests.
 			*/
 			list_del_init(&request->dev_node);
-			isci_free_tag(isci_host, request->io_tag);
-			spin_unlock_irq(&isci_host->scic_lock);
+			isci_free_tag(ihost, request->io_tag);
+			spin_unlock_irq(&ihost->scic_lock);
 		}
 	}
 
@@ -1232,18 +1220,18 @@ static void isci_host_completion_routine(unsigned long data)
  * controller is already in the STOPPED state. SCI_FAILURE_INVALID_STATE if the
  * controller is not either in the STARTED or STOPPED states.
  */
-static enum sci_status scic_controller_stop(struct scic_sds_controller *scic,
+static enum sci_status scic_controller_stop(struct isci_host *ihost,
 					    u32 timeout)
 {
-	if (scic->sm.current_state_id != SCIC_READY) {
-		dev_warn(scic_to_dev(scic),
+	if (ihost->sm.current_state_id != SCIC_READY) {
+		dev_warn(&ihost->pdev->dev,
 			 "SCIC Controller stop operation requested in "
 			 "invalid state\n");
 		return SCI_FAILURE_INVALID_STATE;
 	}
 
-	sci_mod_timer(&scic->timer, timeout);
-	sci_change_state(&scic->sm, SCIC_STOPPING);
+	sci_mod_timer(&ihost->timer, timeout);
+	sci_change_state(&ihost->sm, SCIC_STOPPING);
 	return SCI_SUCCESS;
 }
 
@@ -1259,9 +1247,9 @@ static enum sci_status scic_controller_stop(struct scic_sds_controller *scic,
  * SCI_SUCCESS if the reset operation successfully started. SCI_FATAL_ERROR if
  * the controller reset operation is unable to complete.
  */
-static enum sci_status scic_controller_reset(struct scic_sds_controller *scic)
+static enum sci_status scic_controller_reset(struct isci_host *ihost)
 {
-	switch (scic->sm.current_state_id) {
+	switch (ihost->sm.current_state_id) {
 	case SCIC_RESET:
 	case SCIC_READY:
 	case SCIC_STOPPED:
@@ -1270,10 +1258,10 @@ static enum sci_status scic_controller_reset(struct scic_sds_controller *scic)
 		 * The reset operation is not a graceful cleanup, just
 		 * perform the state transition.
 		 */
-		sci_change_state(&scic->sm, SCIC_RESETTING);
+		sci_change_state(&ihost->sm, SCIC_RESETTING);
 		return SCI_SUCCESS;
 	default:
-		dev_warn(scic_to_dev(scic),
+		dev_warn(&ihost->pdev->dev,
 			 "SCIC Controller reset operation requested in "
 			 "invalid state\n");
 		return SCI_FAILURE_INVALID_STATE;
@@ -1298,14 +1286,14 @@ void isci_host_deinit(struct isci_host *ihost)
 	set_bit(IHOST_STOP_PENDING, &ihost->flags);
 
 	spin_lock_irq(&ihost->scic_lock);
-	scic_controller_stop(&ihost->sci, SCIC_CONTROLLER_STOP_TIMEOUT);
+	scic_controller_stop(ihost, SCIC_CONTROLLER_STOP_TIMEOUT);
 	spin_unlock_irq(&ihost->scic_lock);
 
 	wait_for_stop(ihost);
-	scic_controller_reset(&ihost->sci);
+	scic_controller_reset(ihost);
 
 	/* Cancel any/all outstanding port timers */
-	for (i = 0; i < ihost->sci.logical_port_entries; i++) {
+	for (i = 0; i < ihost->logical_port_entries; i++) {
 		struct isci_port *iport = &ihost->ports[i];
 		del_timer_sync(&iport->timer.timer);
 	}
@@ -1316,13 +1304,13 @@ void isci_host_deinit(struct isci_host *ihost)
 		del_timer_sync(&iphy->sata_timer.timer);
 	}
 
-	del_timer_sync(&ihost->sci.port_agent.timer.timer);
+	del_timer_sync(&ihost->port_agent.timer.timer);
 
-	del_timer_sync(&ihost->sci.power_control.timer.timer);
+	del_timer_sync(&ihost->power_control.timer.timer);
 
-	del_timer_sync(&ihost->sci.timer.timer);
+	del_timer_sync(&ihost->timer.timer);
 
-	del_timer_sync(&ihost->sci.phy_timer.timer);
+	del_timer_sync(&ihost->phy_timer.timer);
 }
 
 static void __iomem *scu_base(struct isci_host *isci_host)
@@ -1369,16 +1357,16 @@ static void isci_user_parameters_get(
 
 static void scic_sds_controller_initial_state_enter(struct sci_base_state_machine *sm)
 {
-	struct scic_sds_controller *scic = container_of(sm, typeof(*scic), sm);
+	struct isci_host *ihost = container_of(sm, typeof(*ihost), sm);
 
-	sci_change_state(&scic->sm, SCIC_RESET);
+	sci_change_state(&ihost->sm, SCIC_RESET);
 }
 
 static inline void scic_sds_controller_starting_state_exit(struct sci_base_state_machine *sm)
 {
-	struct scic_sds_controller *scic = container_of(sm, typeof(*scic), sm);
+	struct isci_host *ihost = container_of(sm, typeof(*ihost), sm);
 
-	sci_del_timer(&scic->timer);
+	sci_del_timer(&ihost->timer);
 }
 
 #define INTERRUPT_COALESCE_TIMEOUT_BASE_RANGE_LOWER_BOUND_NS 853
@@ -1405,10 +1393,10 @@ static inline void scic_sds_controller_starting_state_exit(struct sci_base_state
  * SCI_SUCCESS The user successfully updated the interrutp coalescence.
  * SCI_FAILURE_INVALID_PARAMETER_VALUE The user input value is out of range.
  */
-static enum sci_status scic_controller_set_interrupt_coalescence(
-	struct scic_sds_controller *scic_controller,
-	u32 coalesce_number,
-	u32 coalesce_timeout)
+static enum sci_status
+scic_controller_set_interrupt_coalescence(struct isci_host *ihost,
+					  u32 coalesce_number,
+					  u32 coalesce_timeout)
 {
 	u8 timeout_encode = 0;
 	u32 min = 0;
@@ -1491,11 +1479,11 @@ static enum sci_status scic_controller_set_interrupt_coalescence(
 
 	writel(SMU_ICC_GEN_VAL(NUMBER, coalesce_number) |
 	       SMU_ICC_GEN_VAL(TIMER, timeout_encode),
-	       &scic_controller->smu_registers->interrupt_coalesce_control);
+	       &ihost->smu_registers->interrupt_coalesce_control);
 
 
-	scic_controller->interrupt_coalesce_number = (u16)coalesce_number;
-	scic_controller->interrupt_coalesce_timeout = coalesce_timeout / 100;
+	ihost->interrupt_coalesce_number = (u16)coalesce_number;
+	ihost->interrupt_coalesce_timeout = coalesce_timeout / 100;
 
 	return SCI_SUCCESS;
 }
@@ -1503,26 +1491,25 @@ static enum sci_status scic_controller_set_interrupt_coalescence(
 
 static void scic_sds_controller_ready_state_enter(struct sci_base_state_machine *sm)
 {
-	struct scic_sds_controller *scic = container_of(sm, typeof(*scic), sm);
+	struct isci_host *ihost = container_of(sm, typeof(*ihost), sm);
 
 	/* set the default interrupt coalescence number and timeout value. */
-	scic_controller_set_interrupt_coalescence(scic, 0x10, 250);
+	scic_controller_set_interrupt_coalescence(ihost, 0x10, 250);
 }
 
 static void scic_sds_controller_ready_state_exit(struct sci_base_state_machine *sm)
 {
-	struct scic_sds_controller *scic = container_of(sm, typeof(*scic), sm);
+	struct isci_host *ihost = container_of(sm, typeof(*ihost), sm);
 
 	/* disable interrupt coalescence. */
-	scic_controller_set_interrupt_coalescence(scic, 0, 0);
+	scic_controller_set_interrupt_coalescence(ihost, 0, 0);
 }
 
-static enum sci_status scic_sds_controller_stop_phys(struct scic_sds_controller *scic)
+static enum sci_status scic_sds_controller_stop_phys(struct isci_host *ihost)
 {
 	u32 index;
 	enum sci_status status;
 	enum sci_status phy_status;
-	struct isci_host *ihost = scic_to_ihost(scic);
 
 	status = SCI_SUCCESS;
 
@@ -1533,7 +1520,7 @@ static enum sci_status scic_sds_controller_stop_phys(struct scic_sds_controller
 		    phy_status != SCI_FAILURE_INVALID_STATE) {
 			status = SCI_FAILURE;
 
-			dev_warn(scic_to_dev(scic),
+			dev_warn(&ihost->pdev->dev,
 				 "%s: Controller stop operation failed to stop "
 				 "phy %d because of status %d.\n",
 				 __func__,
@@ -1544,14 +1531,13 @@ static enum sci_status scic_sds_controller_stop_phys(struct scic_sds_controller
 	return status;
 }
 
-static enum sci_status scic_sds_controller_stop_ports(struct scic_sds_controller *scic)
+static enum sci_status scic_sds_controller_stop_ports(struct isci_host *ihost)
 {
 	u32 index;
 	enum sci_status port_status;
 	enum sci_status status = SCI_SUCCESS;
-	struct isci_host *ihost = scic_to_ihost(scic);
 
-	for (index = 0; index < scic->logical_port_entries; index++) {
+	for (index = 0; index < ihost->logical_port_entries; index++) {
 		struct isci_port *iport = &ihost->ports[index];
 
 		port_status = scic_sds_port_stop(iport);
@@ -1560,7 +1546,7 @@ static enum sci_status scic_sds_controller_stop_ports(struct scic_sds_controller
 		    (port_status != SCI_FAILURE_INVALID_STATE)) {
 			status = SCI_FAILURE;
 
-			dev_warn(scic_to_dev(scic),
+			dev_warn(&ihost->pdev->dev,
 				 "%s: Controller stop operation failed to "
 				 "stop port %d because of status %d.\n",
 				 __func__,
@@ -1572,7 +1558,7 @@ static enum sci_status scic_sds_controller_stop_ports(struct scic_sds_controller
 	return status;
 }
 
-static enum sci_status scic_sds_controller_stop_devices(struct scic_sds_controller *scic)
+static enum sci_status scic_sds_controller_stop_devices(struct isci_host *ihost)
 {
 	u32 index;
 	enum sci_status status;
@@ -1580,19 +1566,19 @@ static enum sci_status scic_sds_controller_stop_devices(struct scic_sds_controll
 
 	status = SCI_SUCCESS;
 
-	for (index = 0; index < scic->remote_node_entries; index++) {
-		if (scic->device_table[index] != NULL) {
+	for (index = 0; index < ihost->remote_node_entries; index++) {
+		if (ihost->device_table[index] != NULL) {
 			/* / @todo What timeout value do we want to provide to this request? */
-			device_status = scic_remote_device_stop(scic->device_table[index], 0);
+			device_status = scic_remote_device_stop(ihost->device_table[index], 0);
 
 			if ((device_status != SCI_SUCCESS) &&
 			    (device_status != SCI_FAILURE_INVALID_STATE)) {
-				dev_warn(scic_to_dev(scic),
+				dev_warn(&ihost->pdev->dev,
 					 "%s: Controller stop operation failed "
 					 "to stop device 0x%p because of "
 					 "status %d.\n",
 					 __func__,
-					 scic->device_table[index], device_status);
+					 ihost->device_table[index], device_status);
 			}
 		}
 	}
@@ -1602,19 +1588,19 @@ static enum sci_status scic_sds_controller_stop_devices(struct scic_sds_controll
 
 static void scic_sds_controller_stopping_state_enter(struct sci_base_state_machine *sm)
 {
-	struct scic_sds_controller *scic = container_of(sm, typeof(*scic), sm);
+	struct isci_host *ihost = container_of(sm, typeof(*ihost), sm);
 
 	/* Stop all of the components for this controller */
-	scic_sds_controller_stop_phys(scic);
-	scic_sds_controller_stop_ports(scic);
-	scic_sds_controller_stop_devices(scic);
+	scic_sds_controller_stop_phys(ihost);
+	scic_sds_controller_stop_ports(ihost);
+	scic_sds_controller_stop_devices(ihost);
 }
 
 static void scic_sds_controller_stopping_state_exit(struct sci_base_state_machine *sm)
 {
-	struct scic_sds_controller *scic = container_of(sm, typeof(*scic), sm);
+	struct isci_host *ihost = container_of(sm, typeof(*ihost), sm);
 
-	sci_del_timer(&scic->timer);
+	sci_del_timer(&ihost->timer);
 }
 
 
@@ -1623,30 +1609,30 @@ static void scic_sds_controller_stopping_state_exit(struct sci_base_state_machin
  *
  * This method will reset the controller hardware.
  */
-static void scic_sds_controller_reset_hardware(struct scic_sds_controller *scic)
+static void scic_sds_controller_reset_hardware(struct isci_host *ihost)
 {
 	/* Disable interrupts so we dont take any spurious interrupts */
-	scic_controller_disable_interrupts(scic);
+	scic_controller_disable_interrupts(ihost);
 
 	/* Reset the SCU */
-	writel(0xFFFFFFFF, &scic->smu_registers->soft_reset_control);
+	writel(0xFFFFFFFF, &ihost->smu_registers->soft_reset_control);
 
 	/* Delay for 1ms to before clearing the CQP and UFQPR. */
 	udelay(1000);
 
 	/* The write to the CQGR clears the CQP */
-	writel(0x00000000, &scic->smu_registers->completion_queue_get);
+	writel(0x00000000, &ihost->smu_registers->completion_queue_get);
 
 	/* The write to the UFQGP clears the UFQPR */
-	writel(0, &scic->scu_registers->sdma.unsolicited_frame_get_pointer);
+	writel(0, &ihost->scu_registers->sdma.unsolicited_frame_get_pointer);
 }
 
 static void scic_sds_controller_resetting_state_enter(struct sci_base_state_machine *sm)
 {
-	struct scic_sds_controller *scic = container_of(sm, typeof(*scic), sm);
+	struct isci_host *ihost = container_of(sm, typeof(*ihost), sm);
 
-	scic_sds_controller_reset_hardware(scic);
-	sci_change_state(&scic->sm, SCIC_RESET);
+	scic_sds_controller_reset_hardware(ihost);
+	sci_change_state(&ihost->sm, SCIC_RESET);
 }
 
 static const struct sci_base_state scic_sds_controller_state_table[] = {
@@ -1674,58 +1660,56 @@ static const struct sci_base_state scic_sds_controller_state_table[] = {
 	[SCIC_FAILED] = {}
 };
 
-static void scic_sds_controller_set_default_config_parameters(struct scic_sds_controller *scic)
+static void scic_sds_controller_set_default_config_parameters(struct isci_host *ihost)
 {
 	/* these defaults are overridden by the platform / firmware */
-	struct isci_host *ihost = scic_to_ihost(scic);
 	u16 index;
 
 	/* Default to APC mode. */
-	scic->oem_parameters.sds1.controller.mode_type = SCIC_PORT_AUTOMATIC_CONFIGURATION_MODE;
+	ihost->oem_parameters.sds1.controller.mode_type = SCIC_PORT_AUTOMATIC_CONFIGURATION_MODE;
 
 	/* Default to APC mode. */
-	scic->oem_parameters.sds1.controller.max_concurrent_dev_spin_up = 1;
+	ihost->oem_parameters.sds1.controller.max_concurrent_dev_spin_up = 1;
 
 	/* Default to no SSC operation. */
-	scic->oem_parameters.sds1.controller.do_enable_ssc = false;
+	ihost->oem_parameters.sds1.controller.do_enable_ssc = false;
 
 	/* Initialize all of the port parameter information to narrow ports. */
 	for (index = 0; index < SCI_MAX_PORTS; index++) {
-		scic->oem_parameters.sds1.ports[index].phy_mask = 0;
+		ihost->oem_parameters.sds1.ports[index].phy_mask = 0;
 	}
 
 	/* Initialize all of the phy parameter information. */
 	for (index = 0; index < SCI_MAX_PHYS; index++) {
 		/* Default to 6G (i.e. Gen 3) for now. */
-		scic->user_parameters.sds1.phys[index].max_speed_generation = 3;
+		ihost->user_parameters.sds1.phys[index].max_speed_generation = 3;
 
 		/* the frequencies cannot be 0 */
-		scic->user_parameters.sds1.phys[index].align_insertion_frequency = 0x7f;
-		scic->user_parameters.sds1.phys[index].in_connection_align_insertion_frequency = 0xff;
-		scic->user_parameters.sds1.phys[index].notify_enable_spin_up_insertion_frequency = 0x33;
+		ihost->user_parameters.sds1.phys[index].align_insertion_frequency = 0x7f;
+		ihost->user_parameters.sds1.phys[index].in_connection_align_insertion_frequency = 0xff;
+		ihost->user_parameters.sds1.phys[index].notify_enable_spin_up_insertion_frequency = 0x33;
 
 		/*
 		 * Previous Vitesse based expanders had a arbitration issue that
 		 * is worked around by having the upper 32-bits of SAS address
 		 * with a value greater then the Vitesse company identifier.
 		 * Hence, usage of 0x5FCFFFFF. */
-		scic->oem_parameters.sds1.phys[index].sas_address.low = 0x1 + ihost->id;
-		scic->oem_parameters.sds1.phys[index].sas_address.high = 0x5FCFFFFF;
+		ihost->oem_parameters.sds1.phys[index].sas_address.low = 0x1 + ihost->id;
+		ihost->oem_parameters.sds1.phys[index].sas_address.high = 0x5FCFFFFF;
 	}
 
-	scic->user_parameters.sds1.stp_inactivity_timeout = 5;
-	scic->user_parameters.sds1.ssp_inactivity_timeout = 5;
-	scic->user_parameters.sds1.stp_max_occupancy_timeout = 5;
-	scic->user_parameters.sds1.ssp_max_occupancy_timeout = 20;
-	scic->user_parameters.sds1.no_outbound_task_timeout = 20;
+	ihost->user_parameters.sds1.stp_inactivity_timeout = 5;
+	ihost->user_parameters.sds1.ssp_inactivity_timeout = 5;
+	ihost->user_parameters.sds1.stp_max_occupancy_timeout = 5;
+	ihost->user_parameters.sds1.ssp_max_occupancy_timeout = 20;
+	ihost->user_parameters.sds1.no_outbound_task_timeout = 20;
 }
 
 static void controller_timeout(unsigned long data)
 {
 	struct sci_timer *tmr = (struct sci_timer *)data;
-	struct scic_sds_controller *scic = container_of(tmr, typeof(*scic), timer);
-	struct isci_host *ihost = scic_to_ihost(scic);
-	struct sci_base_state_machine *sm = &scic->sm;
+	struct isci_host *ihost = container_of(tmr, typeof(*ihost), timer);
+	struct sci_base_state_machine *sm = &ihost->sm;
 	unsigned long flags;
 
 	spin_lock_irqsave(&ihost->scic_lock, flags);
@@ -1734,12 +1718,12 @@ static void controller_timeout(unsigned long data)
 		goto done;
 
 	if (sm->current_state_id == SCIC_STARTING)
-		scic_sds_controller_transition_to_ready(scic, SCI_FAILURE_TIMEOUT);
+		scic_sds_controller_transition_to_ready(ihost, SCI_FAILURE_TIMEOUT);
 	else if (sm->current_state_id == SCIC_STOPPING) {
 		sci_change_state(sm, SCIC_FAILED);
 		isci_host_stop_complete(ihost, SCI_FAILURE_TIMEOUT);
 	} else	/* / @todo Now what do we want to do in this case? */
-		dev_err(scic_to_dev(scic),
+		dev_err(&ihost->pdev->dev,
 			"%s: Controller timer fired when controller was not "
 			"in a state being timed.\n",
 			__func__);
@@ -1764,24 +1748,23 @@ static void controller_timeout(unsigned long data)
  * SCI_FAILURE_UNSUPPORTED_INIT_DATA_VERSION This value is returned if the
  * controller does not support the supplied initialization data version.
  */
-static enum sci_status scic_controller_construct(struct scic_sds_controller *scic,
+static enum sci_status scic_controller_construct(struct isci_host *ihost,
 					  void __iomem *scu_base,
 					  void __iomem *smu_base)
 {
-	struct isci_host *ihost = scic_to_ihost(scic);
 	u8 i;
 
-	sci_init_sm(&scic->sm, scic_sds_controller_state_table, SCIC_INITIAL);
+	sci_init_sm(&ihost->sm, scic_sds_controller_state_table, SCIC_INITIAL);
 
-	scic->scu_registers = scu_base;
-	scic->smu_registers = smu_base;
+	ihost->scu_registers = scu_base;
+	ihost->smu_registers = smu_base;
 
-	scic_sds_port_configuration_agent_construct(&scic->port_agent);
+	scic_sds_port_configuration_agent_construct(&ihost->port_agent);
 
 	/* Construct the ports for this controller */
 	for (i = 0; i < SCI_MAX_PORTS; i++)
-		scic_sds_port_construct(&ihost->ports[i], i, scic);
-	scic_sds_port_construct(&ihost->ports[i], SCIC_SDS_DUMMY_PORT, scic);
+		scic_sds_port_construct(&ihost->ports[i], i, ihost);
+	scic_sds_port_construct(&ihost->ports[i], SCIC_SDS_DUMMY_PORT, ihost);
 
 	/* Construct the phys for this controller */
 	for (i = 0; i < SCI_MAX_PHYS; i++) {
@@ -1790,14 +1773,14 @@ static enum sci_status scic_controller_construct(struct scic_sds_controller *sci
 				       &ihost->ports[SCI_MAX_PORTS], i);
 	}
 
-	scic->invalid_phy_mask = 0;
+	ihost->invalid_phy_mask = 0;
 
-	sci_init_timer(&scic->timer, controller_timeout);
+	sci_init_timer(&ihost->timer, controller_timeout);
 
 	/* Initialize the User and OEM parameters to default values. */
-	scic_sds_controller_set_default_config_parameters(scic);
+	scic_sds_controller_set_default_config_parameters(ihost);
 
-	return scic_controller_reset(scic);
+	return scic_controller_reset(ihost);
 }
 
 int scic_oem_parameters_validate(struct scic_sds_oem_params *oem)
@@ -1834,10 +1817,10 @@ int scic_oem_parameters_validate(struct scic_sds_oem_params *oem)
 	return 0;
 }
 
-static enum sci_status scic_oem_parameters_set(struct scic_sds_controller *scic,
+static enum sci_status scic_oem_parameters_set(struct isci_host *ihost,
 					union scic_oem_parameters *scic_parms)
 {
-	u32 state = scic->sm.current_state_id;
+	u32 state = ihost->sm.current_state_id;
 
 	if (state == SCIC_RESET ||
 	    state == SCIC_INITIALIZING ||
@@ -1845,7 +1828,7 @@ static enum sci_status scic_oem_parameters_set(struct scic_sds_controller *scic,
 
 		if (scic_oem_parameters_validate(&scic_parms->sds1))
 			return SCI_FAILURE_INVALID_PARAMETER_VALUE;
-		scic->oem_parameters.sds1 = scic_parms->sds1;
+		ihost->oem_parameters.sds1 = scic_parms->sds1;
 
 		return SCI_SUCCESS;
 	}
@@ -1854,17 +1837,16 @@ static enum sci_status scic_oem_parameters_set(struct scic_sds_controller *scic,
 }
 
 void scic_oem_parameters_get(
-	struct scic_sds_controller *scic,
+	struct isci_host *ihost,
 	union scic_oem_parameters *scic_parms)
 {
-	memcpy(scic_parms, (&scic->oem_parameters), sizeof(*scic_parms));
+	memcpy(scic_parms, (&ihost->oem_parameters), sizeof(*scic_parms));
 }
 
 static void power_control_timeout(unsigned long data)
 {
 	struct sci_timer *tmr = (struct sci_timer *)data;
-	struct scic_sds_controller *scic = container_of(tmr, typeof(*scic), power_control.timer);
-	struct isci_host *ihost = scic_to_ihost(scic);
+	struct isci_host *ihost = container_of(tmr, typeof(*ihost), power_control.timer);
 	struct isci_phy *iphy;
 	unsigned long flags;
 	u8 i;
@@ -1874,29 +1856,29 @@ static void power_control_timeout(unsigned long data)
 	if (tmr->cancel)
 		goto done;
 
-	scic->power_control.phys_granted_power = 0;
+	ihost->power_control.phys_granted_power = 0;
 
-	if (scic->power_control.phys_waiting == 0) {
-		scic->power_control.timer_started = false;
+	if (ihost->power_control.phys_waiting == 0) {
+		ihost->power_control.timer_started = false;
 		goto done;
 	}
 
 	for (i = 0; i < SCI_MAX_PHYS; i++) {
 
-		if (scic->power_control.phys_waiting == 0)
+		if (ihost->power_control.phys_waiting == 0)
 			break;
 
-		iphy = scic->power_control.requesters[i];
+		iphy = ihost->power_control.requesters[i];
 		if (iphy == NULL)
 			continue;
 
-		if (scic->power_control.phys_granted_power >=
-		    scic->oem_parameters.sds1.controller.max_concurrent_dev_spin_up)
+		if (ihost->power_control.phys_granted_power >=
+		    ihost->oem_parameters.sds1.controller.max_concurrent_dev_spin_up)
 			break;
 
-		scic->power_control.requesters[i] = NULL;
-		scic->power_control.phys_waiting--;
-		scic->power_control.phys_granted_power++;
+		ihost->power_control.requesters[i] = NULL;
+		ihost->power_control.phys_waiting--;
+		ihost->power_control.phys_granted_power++;
 		scic_sds_phy_consume_power_handler(iphy);
 	}
 
@@ -1905,7 +1887,7 @@ static void power_control_timeout(unsigned long data)
 	 * timer in case another phy becomes ready.
 	 */
 	sci_mod_timer(tmr, SCIC_SDS_CONTROLLER_POWER_CONTROL_INTERVAL);
-	scic->power_control.timer_started = true;
+	ihost->power_control.timer_started = true;
 
 done:
 	spin_unlock_irqrestore(&ihost->scic_lock, flags);
@@ -1918,31 +1900,31 @@ static void power_control_timeout(unsigned long data)
  *
  */
 void scic_sds_controller_power_control_queue_insert(
-	struct scic_sds_controller *scic,
+	struct isci_host *ihost,
 	struct isci_phy *iphy)
 {
 	BUG_ON(iphy == NULL);
 
-	if (scic->power_control.phys_granted_power <
-	    scic->oem_parameters.sds1.controller.max_concurrent_dev_spin_up) {
-		scic->power_control.phys_granted_power++;
+	if (ihost->power_control.phys_granted_power <
+	    ihost->oem_parameters.sds1.controller.max_concurrent_dev_spin_up) {
+		ihost->power_control.phys_granted_power++;
 		scic_sds_phy_consume_power_handler(iphy);
 
 		/*
 		 * stop and start the power_control timer. When the timer fires, the
 		 * no_of_phys_granted_power will be set to 0
 		 */
-		if (scic->power_control.timer_started)
-			sci_del_timer(&scic->power_control.timer);
+		if (ihost->power_control.timer_started)
+			sci_del_timer(&ihost->power_control.timer);
 
-		sci_mod_timer(&scic->power_control.timer,
+		sci_mod_timer(&ihost->power_control.timer,
 				 SCIC_SDS_CONTROLLER_POWER_CONTROL_INTERVAL);
-		scic->power_control.timer_started = true;
+		ihost->power_control.timer_started = true;
 
 	} else {
 		/* Add the phy in the waiting list */
-		scic->power_control.requesters[iphy->phy_index] = iphy;
-		scic->power_control.phys_waiting++;
+		ihost->power_control.requesters[iphy->phy_index] = iphy;
+		ihost->power_control.phys_waiting++;
 	}
 }
 
@@ -1953,16 +1935,16 @@ void scic_sds_controller_power_control_queue_insert(
  *
  */
 void scic_sds_controller_power_control_queue_remove(
-	struct scic_sds_controller *scic,
+	struct isci_host *ihost,
 	struct isci_phy *iphy)
 {
 	BUG_ON(iphy == NULL);
 
-	if (scic->power_control.requesters[iphy->phy_index] != NULL) {
-		scic->power_control.phys_waiting--;
+	if (ihost->power_control.requesters[iphy->phy_index] != NULL) {
+		ihost->power_control.phys_waiting--;
 	}
 
-	scic->power_control.requesters[iphy->phy_index] = NULL;
+	ihost->power_control.requesters[iphy->phy_index] = NULL;
 }
 
 #define AFE_REGISTER_WRITE_DELAY 10
@@ -1970,50 +1952,50 @@ void scic_sds_controller_power_control_queue_remove(
 /* Initialize the AFE for this phy index. We need to read the AFE setup from
  * the OEM parameters
  */
-static void scic_sds_controller_afe_initialization(struct scic_sds_controller *scic)
+static void scic_sds_controller_afe_initialization(struct isci_host *ihost)
 {
-	const struct scic_sds_oem_params *oem = &scic->oem_parameters.sds1;
+	const struct scic_sds_oem_params *oem = &ihost->oem_parameters.sds1;
 	u32 afe_status;
 	u32 phy_id;
 
 	/* Clear DFX Status registers */
-	writel(0x0081000f, &scic->scu_registers->afe.afe_dfx_master_control0);
+	writel(0x0081000f, &ihost->scu_registers->afe.afe_dfx_master_control0);
 	udelay(AFE_REGISTER_WRITE_DELAY);
 
 	if (is_b0()) {
 		/* PM Rx Equalization Save, PM SPhy Rx Acknowledgement
 		 * Timer, PM Stagger Timer */
-		writel(0x0007BFFF, &scic->scu_registers->afe.afe_pmsn_master_control2);
+		writel(0x0007BFFF, &ihost->scu_registers->afe.afe_pmsn_master_control2);
 		udelay(AFE_REGISTER_WRITE_DELAY);
 	}
 
 	/* Configure bias currents to normal */
 	if (is_a0())
-		writel(0x00005500, &scic->scu_registers->afe.afe_bias_control);
+		writel(0x00005500, &ihost->scu_registers->afe.afe_bias_control);
 	else if (is_a2())
-		writel(0x00005A00, &scic->scu_registers->afe.afe_bias_control);
+		writel(0x00005A00, &ihost->scu_registers->afe.afe_bias_control);
 	else if (is_b0() || is_c0())
-		writel(0x00005F00, &scic->scu_registers->afe.afe_bias_control);
+		writel(0x00005F00, &ihost->scu_registers->afe.afe_bias_control);
 
 	udelay(AFE_REGISTER_WRITE_DELAY);
 
 	/* Enable PLL */
 	if (is_b0() || is_c0())
-		writel(0x80040A08, &scic->scu_registers->afe.afe_pll_control0);
+		writel(0x80040A08, &ihost->scu_registers->afe.afe_pll_control0);
 	else
-		writel(0x80040908, &scic->scu_registers->afe.afe_pll_control0);
+		writel(0x80040908, &ihost->scu_registers->afe.afe_pll_control0);
 
 	udelay(AFE_REGISTER_WRITE_DELAY);
 
 	/* Wait for the PLL to lock */
 	do {
-		afe_status = readl(&scic->scu_registers->afe.afe_common_block_status);
+		afe_status = readl(&ihost->scu_registers->afe.afe_common_block_status);
 		udelay(AFE_REGISTER_WRITE_DELAY);
 	} while ((afe_status & 0x00001000) == 0);
 
 	if (is_a0() || is_a2()) {
 		/* Shorten SAS SNW lock time (RxLock timer value from 76 us to 50 us) */
-		writel(0x7bcc96ad, &scic->scu_registers->afe.afe_pmsn_master_control0);
+		writel(0x7bcc96ad, &ihost->scu_registers->afe.afe_pmsn_master_control0);
 		udelay(AFE_REGISTER_WRITE_DELAY);
 	}
 
@@ -2022,26 +2004,26 @@ static void scic_sds_controller_afe_initialization(struct scic_sds_controller *s
 
 		if (is_b0()) {
 			 /* Configure transmitter SSC parameters */
-			writel(0x00030000, &scic->scu_registers->afe.scu_afe_xcvr[phy_id].afe_tx_ssc_control);
+			writel(0x00030000, &ihost->scu_registers->afe.scu_afe_xcvr[phy_id].afe_tx_ssc_control);
 			udelay(AFE_REGISTER_WRITE_DELAY);
 		} else if (is_c0()) {
 			 /* Configure transmitter SSC parameters */
-			writel(0x0003000, &scic->scu_registers->afe.scu_afe_xcvr[phy_id].afe_tx_ssc_control);
+			writel(0x0003000, &ihost->scu_registers->afe.scu_afe_xcvr[phy_id].afe_tx_ssc_control);
 			udelay(AFE_REGISTER_WRITE_DELAY);
 
 			/*
 			 * All defaults, except the Receive Word Alignament/Comma Detect
 			 * Enable....(0xe800) */
-			writel(0x00004500, &scic->scu_registers->afe.scu_afe_xcvr[phy_id].afe_xcvr_control0);
+			writel(0x00004500, &ihost->scu_registers->afe.scu_afe_xcvr[phy_id].afe_xcvr_control0);
 			udelay(AFE_REGISTER_WRITE_DELAY);
 		} else {
 			/*
 			 * All defaults, except the Receive Word Alignament/Comma Detect
 			 * Enable....(0xe800) */
-			writel(0x00004512, &scic->scu_registers->afe.scu_afe_xcvr[phy_id].afe_xcvr_control0);
+			writel(0x00004512, &ihost->scu_registers->afe.scu_afe_xcvr[phy_id].afe_xcvr_control0);
 			udelay(AFE_REGISTER_WRITE_DELAY);
 
-			writel(0x0050100F, &scic->scu_registers->afe.scu_afe_xcvr[phy_id].afe_xcvr_control1);
+			writel(0x0050100F, &ihost->scu_registers->afe.scu_afe_xcvr[phy_id].afe_xcvr_control1);
 			udelay(AFE_REGISTER_WRITE_DELAY);
 		}
 
@@ -2049,106 +2031,105 @@ static void scic_sds_controller_afe_initialization(struct scic_sds_controller *s
 		 * Power up TX and RX out from power down (PWRDNTX and PWRDNRX)
 		 * & increase TX int & ext bias 20%....(0xe85c) */
 		if (is_a0())
-			writel(0x000003D4, &scic->scu_registers->afe.scu_afe_xcvr[phy_id].afe_channel_control);
+			writel(0x000003D4, &ihost->scu_registers->afe.scu_afe_xcvr[phy_id].afe_channel_control);
 		else if (is_a2())
-			writel(0x000003F0, &scic->scu_registers->afe.scu_afe_xcvr[phy_id].afe_channel_control);
+			writel(0x000003F0, &ihost->scu_registers->afe.scu_afe_xcvr[phy_id].afe_channel_control);
 		else if (is_b0()) {
 			 /* Power down TX and RX (PWRDNTX and PWRDNRX) */
-			writel(0x000003D7, &scic->scu_registers->afe.scu_afe_xcvr[phy_id].afe_channel_control);
+			writel(0x000003D7, &ihost->scu_registers->afe.scu_afe_xcvr[phy_id].afe_channel_control);
 			udelay(AFE_REGISTER_WRITE_DELAY);
 
 			/*
 			 * Power up TX and RX out from power down (PWRDNTX and PWRDNRX)
 			 * & increase TX int & ext bias 20%....(0xe85c) */
-			writel(0x000003D4, &scic->scu_registers->afe.scu_afe_xcvr[phy_id].afe_channel_control);
+			writel(0x000003D4, &ihost->scu_registers->afe.scu_afe_xcvr[phy_id].afe_channel_control);
 		} else {
-			writel(0x000001E7, &scic->scu_registers->afe.scu_afe_xcvr[phy_id].afe_channel_control);
+			writel(0x000001E7, &ihost->scu_registers->afe.scu_afe_xcvr[phy_id].afe_channel_control);
 			udelay(AFE_REGISTER_WRITE_DELAY);
 
 			/*
 			 * Power up TX and RX out from power down (PWRDNTX and PWRDNRX)
 			 * & increase TX int & ext bias 20%....(0xe85c) */
-			writel(0x000001E4, &scic->scu_registers->afe.scu_afe_xcvr[phy_id].afe_channel_control);
+			writel(0x000001E4, &ihost->scu_registers->afe.scu_afe_xcvr[phy_id].afe_channel_control);
 		}
 		udelay(AFE_REGISTER_WRITE_DELAY);
 
 		if (is_a0() || is_a2()) {
 			/* Enable TX equalization (0xe824) */
-			writel(0x00040000, &scic->scu_registers->afe.scu_afe_xcvr[phy_id].afe_tx_control);
+			writel(0x00040000, &ihost->scu_registers->afe.scu_afe_xcvr[phy_id].afe_tx_control);
 			udelay(AFE_REGISTER_WRITE_DELAY);
 		}
 
 		/*
 		 * RDPI=0x0(RX Power On), RXOOBDETPDNC=0x0, TPD=0x0(TX Power On),
 		 * RDD=0x0(RX Detect Enabled) ....(0xe800) */
-		writel(0x00004100, &scic->scu_registers->afe.scu_afe_xcvr[phy_id].afe_xcvr_control0);
+		writel(0x00004100, &ihost->scu_registers->afe.scu_afe_xcvr[phy_id].afe_xcvr_control0);
 		udelay(AFE_REGISTER_WRITE_DELAY);
 
 		/* Leave DFE/FFE on */
 		if (is_a0())
-			writel(0x3F09983F, &scic->scu_registers->afe.scu_afe_xcvr[phy_id].afe_rx_ssc_control0);
+			writel(0x3F09983F, &ihost->scu_registers->afe.scu_afe_xcvr[phy_id].afe_rx_ssc_control0);
 		else if (is_a2())
-			writel(0x3F11103F, &scic->scu_registers->afe.scu_afe_xcvr[phy_id].afe_rx_ssc_control0);
+			writel(0x3F11103F, &ihost->scu_registers->afe.scu_afe_xcvr[phy_id].afe_rx_ssc_control0);
 		else if (is_b0()) {
-			writel(0x3F11103F, &scic->scu_registers->afe.scu_afe_xcvr[phy_id].afe_rx_ssc_control0);
+			writel(0x3F11103F, &ihost->scu_registers->afe.scu_afe_xcvr[phy_id].afe_rx_ssc_control0);
 			udelay(AFE_REGISTER_WRITE_DELAY);
 			/* Enable TX equalization (0xe824) */
-			writel(0x00040000, &scic->scu_registers->afe.scu_afe_xcvr[phy_id].afe_tx_control);
+			writel(0x00040000, &ihost->scu_registers->afe.scu_afe_xcvr[phy_id].afe_tx_control);
 		} else {
-			writel(0x0140DF0F, &scic->scu_registers->afe.scu_afe_xcvr[phy_id].afe_rx_ssc_control1);
+			writel(0x0140DF0F, &ihost->scu_registers->afe.scu_afe_xcvr[phy_id].afe_rx_ssc_control1);
 			udelay(AFE_REGISTER_WRITE_DELAY);
 
-			writel(0x3F6F103F, &scic->scu_registers->afe.scu_afe_xcvr[phy_id].afe_rx_ssc_control0);
+			writel(0x3F6F103F, &ihost->scu_registers->afe.scu_afe_xcvr[phy_id].afe_rx_ssc_control0);
 			udelay(AFE_REGISTER_WRITE_DELAY);
 
 			/* Enable TX equalization (0xe824) */
-			writel(0x00040000, &scic->scu_registers->afe.scu_afe_xcvr[phy_id].afe_tx_control);
+			writel(0x00040000, &ihost->scu_registers->afe.scu_afe_xcvr[phy_id].afe_tx_control);
 		}
 
 		udelay(AFE_REGISTER_WRITE_DELAY);
 
 		writel(oem_phy->afe_tx_amp_control0,
-			&scic->scu_registers->afe.scu_afe_xcvr[phy_id].afe_tx_amp_control0);
+			&ihost->scu_registers->afe.scu_afe_xcvr[phy_id].afe_tx_amp_control0);
 		udelay(AFE_REGISTER_WRITE_DELAY);
 
 		writel(oem_phy->afe_tx_amp_control1,
-			&scic->scu_registers->afe.scu_afe_xcvr[phy_id].afe_tx_amp_control1);
+			&ihost->scu_registers->afe.scu_afe_xcvr[phy_id].afe_tx_amp_control1);
 		udelay(AFE_REGISTER_WRITE_DELAY);
 
 		writel(oem_phy->afe_tx_amp_control2,
-			&scic->scu_registers->afe.scu_afe_xcvr[phy_id].afe_tx_amp_control2);
+			&ihost->scu_registers->afe.scu_afe_xcvr[phy_id].afe_tx_amp_control2);
 		udelay(AFE_REGISTER_WRITE_DELAY);
 
 		writel(oem_phy->afe_tx_amp_control3,
-			&scic->scu_registers->afe.scu_afe_xcvr[phy_id].afe_tx_amp_control3);
+			&ihost->scu_registers->afe.scu_afe_xcvr[phy_id].afe_tx_amp_control3);
 		udelay(AFE_REGISTER_WRITE_DELAY);
 	}
 
 	/* Transfer control to the PEs */
-	writel(0x00010f00, &scic->scu_registers->afe.afe_dfx_master_control0);
+	writel(0x00010f00, &ihost->scu_registers->afe.afe_dfx_master_control0);
 	udelay(AFE_REGISTER_WRITE_DELAY);
 }
 
-static void scic_sds_controller_initialize_power_control(struct scic_sds_controller *scic)
+static void scic_sds_controller_initialize_power_control(struct isci_host *ihost)
 {
-	sci_init_timer(&scic->power_control.timer, power_control_timeout);
+	sci_init_timer(&ihost->power_control.timer, power_control_timeout);
 
-	memset(scic->power_control.requesters, 0,
-	       sizeof(scic->power_control.requesters));
+	memset(ihost->power_control.requesters, 0,
+	       sizeof(ihost->power_control.requesters));
 
-	scic->power_control.phys_waiting = 0;
-	scic->power_control.phys_granted_power = 0;
+	ihost->power_control.phys_waiting = 0;
+	ihost->power_control.phys_granted_power = 0;
 }
 
-static enum sci_status scic_controller_initialize(struct scic_sds_controller *scic)
+static enum sci_status scic_controller_initialize(struct isci_host *ihost)
 {
-	struct sci_base_state_machine *sm = &scic->sm;
-	struct isci_host *ihost = scic_to_ihost(scic);
+	struct sci_base_state_machine *sm = &ihost->sm;
 	enum sci_status result = SCI_FAILURE;
 	unsigned long i, state, val;
 
-	if (scic->sm.current_state_id != SCIC_RESET) {
-		dev_warn(scic_to_dev(scic),
+	if (ihost->sm.current_state_id != SCIC_RESET) {
+		dev_warn(&ihost->pdev->dev,
 			 "SCIC Controller initialize operation requested "
 			 "in invalid state\n");
 		return SCI_FAILURE_INVALID_STATE;
@@ -2156,23 +2137,23 @@ static enum sci_status scic_controller_initialize(struct scic_sds_controller *sc
 
 	sci_change_state(sm, SCIC_INITIALIZING);
 
-	sci_init_timer(&scic->phy_timer, phy_startup_timeout);
+	sci_init_timer(&ihost->phy_timer, phy_startup_timeout);
 
-	scic->next_phy_to_start = 0;
-	scic->phy_startup_timer_pending = false;
+	ihost->next_phy_to_start = 0;
+	ihost->phy_startup_timer_pending = false;
 
-	scic_sds_controller_initialize_power_control(scic);
+	scic_sds_controller_initialize_power_control(ihost);
 
 	/*
 	 * There is nothing to do here for B0 since we do not have to
 	 * program the AFE registers.
 	 * / @todo The AFE settings are supposed to be correct for the B0 but
 	 * /       presently they seem to be wrong. */
-	scic_sds_controller_afe_initialization(scic);
+	scic_sds_controller_afe_initialization(ihost);
 
 
 	/* Take the hardware out of reset */
-	writel(0, &scic->smu_registers->soft_reset_control);
+	writel(0, &ihost->smu_registers->soft_reset_control);
 
 	/*
 	 * / @todo Provide meaningfull error code for hardware failure
@@ -2182,7 +2163,7 @@ static enum sci_status scic_controller_initialize(struct scic_sds_controller *sc
 
 		/* Loop until the hardware reports success */
 		udelay(SCU_CONTEXT_RAM_INIT_STALL_TIME);
-		status = readl(&scic->smu_registers->control_status);
+		status = readl(&ihost->smu_registers->control_status);
 
 		if ((status & SCU_RAM_INIT_COMPLETED) == SCU_RAM_INIT_COMPLETED)
 			break;
@@ -2193,32 +2174,32 @@ static enum sci_status scic_controller_initialize(struct scic_sds_controller *sc
 	/*
 	 * Determine what are the actaul device capacities that the
 	 * hardware will support */
-	val = readl(&scic->smu_registers->device_context_capacity);
+	val = readl(&ihost->smu_registers->device_context_capacity);
 
 	/* Record the smaller of the two capacity values */
-	scic->logical_port_entries = min(smu_max_ports(val), SCI_MAX_PORTS);
-	scic->task_context_entries = min(smu_max_task_contexts(val), SCI_MAX_IO_REQUESTS);
-	scic->remote_node_entries = min(smu_max_rncs(val), SCI_MAX_REMOTE_DEVICES);
+	ihost->logical_port_entries = min(smu_max_ports(val), SCI_MAX_PORTS);
+	ihost->task_context_entries = min(smu_max_task_contexts(val), SCI_MAX_IO_REQUESTS);
+	ihost->remote_node_entries = min(smu_max_rncs(val), SCI_MAX_REMOTE_DEVICES);
 
 	/*
 	 * Make all PEs that are unassigned match up with the
 	 * logical ports
 	 */
-	for (i = 0; i < scic->logical_port_entries; i++) {
+	for (i = 0; i < ihost->logical_port_entries; i++) {
 		struct scu_port_task_scheduler_group_registers __iomem
-			*ptsg = &scic->scu_registers->peg0.ptsg;
+			*ptsg = &ihost->scu_registers->peg0.ptsg;
 
 		writel(i, &ptsg->protocol_engine[i]);
 	}
 
 	/* Initialize hardware PCI Relaxed ordering in DMA engines */
-	val = readl(&scic->scu_registers->sdma.pdma_configuration);
+	val = readl(&ihost->scu_registers->sdma.pdma_configuration);
 	val |= SCU_PDMACR_GEN_BIT(PCI_RELAXED_ORDERING_ENABLE);
-	writel(val, &scic->scu_registers->sdma.pdma_configuration);
+	writel(val, &ihost->scu_registers->sdma.pdma_configuration);
 
-	val = readl(&scic->scu_registers->sdma.cdma_configuration);
+	val = readl(&ihost->scu_registers->sdma.cdma_configuration);
 	val |= SCU_CDMACR_GEN_BIT(PCI_RELAXED_ORDERING_ENABLE);
-	writel(val, &scic->scu_registers->sdma.cdma_configuration);
+	writel(val, &ihost->scu_registers->sdma.cdma_configuration);
 
 	/*
 	 * Initialize the PHYs before the PORTs because the PHY registers
@@ -2226,23 +2207,23 @@ static enum sci_status scic_controller_initialize(struct scic_sds_controller *sc
 	 */
 	for (i = 0; i < SCI_MAX_PHYS; i++) {
 		result = scic_sds_phy_initialize(&ihost->phys[i],
-						 &scic->scu_registers->peg0.pe[i].tl,
-						 &scic->scu_registers->peg0.pe[i].ll);
+						 &ihost->scu_registers->peg0.pe[i].tl,
+						 &ihost->scu_registers->peg0.pe[i].ll);
 		if (result != SCI_SUCCESS)
 			goto out;
 	}
 
-	for (i = 0; i < scic->logical_port_entries; i++) {
+	for (i = 0; i < ihost->logical_port_entries; i++) {
 		result = scic_sds_port_initialize(&ihost->ports[i],
-						  &scic->scu_registers->peg0.ptsg.port[i],
-						  &scic->scu_registers->peg0.ptsg.protocol_engine,
-						  &scic->scu_registers->peg0.viit[i]);
+						  &ihost->scu_registers->peg0.ptsg.port[i],
+						  &ihost->scu_registers->peg0.ptsg.protocol_engine,
+						  &ihost->scu_registers->peg0.viit[i]);
 
 		if (result != SCI_SUCCESS)
 			goto out;
 	}
 
-	result = scic_sds_port_configuration_agent_initialize(scic, &scic->port_agent);
+	result = scic_sds_port_configuration_agent_initialize(ihost, &ihost->port_agent);
 
  out:
 	/* Advance the controller state machine */
@@ -2256,10 +2237,10 @@ static enum sci_status scic_controller_initialize(struct scic_sds_controller *sc
 }
 
 static enum sci_status scic_user_parameters_set(
-	struct scic_sds_controller *scic,
+	struct isci_host *ihost,
 	union scic_user_parameters *scic_parms)
 {
-	u32 state = scic->sm.current_state_id;
+	u32 state = ihost->sm.current_state_id;
 
 	if (state == SCIC_RESET ||
 	    state == SCIC_INITIALIZING ||
@@ -2301,7 +2282,7 @@ static enum sci_status scic_user_parameters_set(
 		    (scic_parms->sds1.no_outbound_task_timeout == 0))
 			return SCI_FAILURE_INVALID_PARAMETER_VALUE;
 
-		memcpy(&scic->user_parameters, scic_parms, sizeof(*scic_parms));
+		memcpy(&ihost->user_parameters, scic_parms, sizeof(*scic_parms));
 
 		return SCI_SUCCESS;
 	}
@@ -2309,40 +2290,40 @@ static enum sci_status scic_user_parameters_set(
 	return SCI_FAILURE_INVALID_STATE;
 }
 
-static int scic_controller_mem_init(struct scic_sds_controller *scic)
+static int scic_controller_mem_init(struct isci_host *ihost)
 {
-	struct device *dev = scic_to_dev(scic);
+	struct device *dev = &ihost->pdev->dev;
 	dma_addr_t dma;
 	size_t size;
 	int err;
 
 	size = SCU_MAX_COMPLETION_QUEUE_ENTRIES * sizeof(u32);
-	scic->completion_queue = dmam_alloc_coherent(dev, size, &dma, GFP_KERNEL);
-	if (!scic->completion_queue)
+	ihost->completion_queue = dmam_alloc_coherent(dev, size, &dma, GFP_KERNEL);
+	if (!ihost->completion_queue)
 		return -ENOMEM;
 
-	writel(lower_32_bits(dma), &scic->smu_registers->completion_queue_lower);
-	writel(upper_32_bits(dma), &scic->smu_registers->completion_queue_upper);
+	writel(lower_32_bits(dma), &ihost->smu_registers->completion_queue_lower);
+	writel(upper_32_bits(dma), &ihost->smu_registers->completion_queue_upper);
 
-	size = scic->remote_node_entries * sizeof(union scu_remote_node_context);
-	scic->remote_node_context_table = dmam_alloc_coherent(dev, size, &dma,
+	size = ihost->remote_node_entries * sizeof(union scu_remote_node_context);
+	ihost->remote_node_context_table = dmam_alloc_coherent(dev, size, &dma,
 							      GFP_KERNEL);
-	if (!scic->remote_node_context_table)
+	if (!ihost->remote_node_context_table)
 		return -ENOMEM;
 
-	writel(lower_32_bits(dma), &scic->smu_registers->remote_node_context_lower);
-	writel(upper_32_bits(dma), &scic->smu_registers->remote_node_context_upper);
+	writel(lower_32_bits(dma), &ihost->smu_registers->remote_node_context_lower);
+	writel(upper_32_bits(dma), &ihost->smu_registers->remote_node_context_upper);
 
-	size = scic->task_context_entries * sizeof(struct scu_task_context),
-	scic->task_context_table = dmam_alloc_coherent(dev, size, &dma, GFP_KERNEL);
-	if (!scic->task_context_table)
+	size = ihost->task_context_entries * sizeof(struct scu_task_context),
+	ihost->task_context_table = dmam_alloc_coherent(dev, size, &dma, GFP_KERNEL);
+	if (!ihost->task_context_table)
 		return -ENOMEM;
 
-	scic->task_context_dma = dma;
-	writel(lower_32_bits(dma), &scic->smu_registers->host_task_table_lower);
-	writel(upper_32_bits(dma), &scic->smu_registers->host_task_table_upper);
+	ihost->task_context_dma = dma;
+	writel(lower_32_bits(dma), &ihost->smu_registers->host_task_table_lower);
+	writel(upper_32_bits(dma), &ihost->smu_registers->host_task_table_upper);
 
-	err = scic_sds_unsolicited_frame_control_construct(scic);
+	err = scic_sds_unsolicited_frame_control_construct(ihost);
 	if (err)
 		return err;
 
@@ -2350,112 +2331,112 @@ static int scic_controller_mem_init(struct scic_sds_controller *scic)
 	 * Inform the silicon as to the location of the UF headers and
 	 * address table.
 	 */
-	writel(lower_32_bits(scic->uf_control.headers.physical_address),
-		&scic->scu_registers->sdma.uf_header_base_address_lower);
-	writel(upper_32_bits(scic->uf_control.headers.physical_address),
-		&scic->scu_registers->sdma.uf_header_base_address_upper);
+	writel(lower_32_bits(ihost->uf_control.headers.physical_address),
+		&ihost->scu_registers->sdma.uf_header_base_address_lower);
+	writel(upper_32_bits(ihost->uf_control.headers.physical_address),
+		&ihost->scu_registers->sdma.uf_header_base_address_upper);
 
-	writel(lower_32_bits(scic->uf_control.address_table.physical_address),
-		&scic->scu_registers->sdma.uf_address_table_lower);
-	writel(upper_32_bits(scic->uf_control.address_table.physical_address),
-		&scic->scu_registers->sdma.uf_address_table_upper);
+	writel(lower_32_bits(ihost->uf_control.address_table.physical_address),
+		&ihost->scu_registers->sdma.uf_address_table_lower);
+	writel(upper_32_bits(ihost->uf_control.address_table.physical_address),
+		&ihost->scu_registers->sdma.uf_address_table_upper);
 
 	return 0;
 }
 
-int isci_host_init(struct isci_host *isci_host)
+int isci_host_init(struct isci_host *ihost)
 {
 	int err = 0, i;
 	enum sci_status status;
 	union scic_oem_parameters oem;
 	union scic_user_parameters scic_user_params;
-	struct isci_pci_info *pci_info = to_pci_info(isci_host->pdev);
+	struct isci_pci_info *pci_info = to_pci_info(ihost->pdev);
 
-	spin_lock_init(&isci_host->state_lock);
-	spin_lock_init(&isci_host->scic_lock);
-	init_waitqueue_head(&isci_host->eventq);
+	spin_lock_init(&ihost->state_lock);
+	spin_lock_init(&ihost->scic_lock);
+	init_waitqueue_head(&ihost->eventq);
 
-	isci_host_change_state(isci_host, isci_starting);
+	isci_host_change_state(ihost, isci_starting);
 
-	status = scic_controller_construct(&isci_host->sci, scu_base(isci_host),
-					   smu_base(isci_host));
+	status = scic_controller_construct(ihost, scu_base(ihost),
+					   smu_base(ihost));
 
 	if (status != SCI_SUCCESS) {
-		dev_err(&isci_host->pdev->dev,
+		dev_err(&ihost->pdev->dev,
 			"%s: scic_controller_construct failed - status = %x\n",
 			__func__,
 			status);
 		return -ENODEV;
 	}
 
-	isci_host->sas_ha.dev = &isci_host->pdev->dev;
-	isci_host->sas_ha.lldd_ha = isci_host;
+	ihost->sas_ha.dev = &ihost->pdev->dev;
+	ihost->sas_ha.lldd_ha = ihost;
 
 	/*
 	 * grab initial values stored in the controller object for OEM and USER
 	 * parameters
 	 */
-	isci_user_parameters_get(isci_host, &scic_user_params);
-	status = scic_user_parameters_set(&isci_host->sci,
+	isci_user_parameters_get(ihost, &scic_user_params);
+	status = scic_user_parameters_set(ihost,
 					  &scic_user_params);
 	if (status != SCI_SUCCESS) {
-		dev_warn(&isci_host->pdev->dev,
+		dev_warn(&ihost->pdev->dev,
 			 "%s: scic_user_parameters_set failed\n",
 			 __func__);
 		return -ENODEV;
 	}
 
-	scic_oem_parameters_get(&isci_host->sci, &oem);
+	scic_oem_parameters_get(ihost, &oem);
 
 	/* grab any OEM parameters specified in orom */
 	if (pci_info->orom) {
 		status = isci_parse_oem_parameters(&oem,
 						   pci_info->orom,
-						   isci_host->id);
+						   ihost->id);
 		if (status != SCI_SUCCESS) {
-			dev_warn(&isci_host->pdev->dev,
+			dev_warn(&ihost->pdev->dev,
 				 "parsing firmware oem parameters failed\n");
 			return -EINVAL;
 		}
 	}
 
-	status = scic_oem_parameters_set(&isci_host->sci, &oem);
+	status = scic_oem_parameters_set(ihost, &oem);
 	if (status != SCI_SUCCESS) {
-		dev_warn(&isci_host->pdev->dev,
+		dev_warn(&ihost->pdev->dev,
 				"%s: scic_oem_parameters_set failed\n",
 				__func__);
 		return -ENODEV;
 	}
 
-	tasklet_init(&isci_host->completion_tasklet,
-		     isci_host_completion_routine, (unsigned long)isci_host);
+	tasklet_init(&ihost->completion_tasklet,
+		     isci_host_completion_routine, (unsigned long)ihost);
 
-	INIT_LIST_HEAD(&isci_host->requests_to_complete);
-	INIT_LIST_HEAD(&isci_host->requests_to_errorback);
+	INIT_LIST_HEAD(&ihost->requests_to_complete);
+	INIT_LIST_HEAD(&ihost->requests_to_errorback);
 
-	spin_lock_irq(&isci_host->scic_lock);
-	status = scic_controller_initialize(&isci_host->sci);
-	spin_unlock_irq(&isci_host->scic_lock);
+	spin_lock_irq(&ihost->scic_lock);
+	status = scic_controller_initialize(ihost);
+	spin_unlock_irq(&ihost->scic_lock);
 	if (status != SCI_SUCCESS) {
-		dev_warn(&isci_host->pdev->dev,
+		dev_warn(&ihost->pdev->dev,
 			 "%s: scic_controller_initialize failed -"
 			 " status = 0x%x\n",
 			 __func__, status);
 		return -ENODEV;
 	}
 
-	err = scic_controller_mem_init(&isci_host->sci);
+	err = scic_controller_mem_init(ihost);
 	if (err)
 		return err;
 
 	for (i = 0; i < SCI_MAX_PORTS; i++)
-		isci_port_init(&isci_host->ports[i], isci_host, i);
+		isci_port_init(&ihost->ports[i], ihost, i);
 
 	for (i = 0; i < SCI_MAX_PHYS; i++)
-		isci_phy_init(&isci_host->phys[i], isci_host, i);
+		isci_phy_init(&ihost->phys[i], ihost, i);
 
 	for (i = 0; i < SCI_MAX_REMOTE_DEVICES; i++) {
-		struct isci_remote_device *idev = &isci_host->devices[i];
+		struct isci_remote_device *idev = &ihost->devices[i];
 
 		INIT_LIST_HEAD(&idev->reqs_in_process);
 		INIT_LIST_HEAD(&idev->node);
@@ -2465,63 +2446,62 @@ int isci_host_init(struct isci_host *isci_host)
 		struct isci_request *ireq;
 		dma_addr_t dma;
 
-		ireq = dmam_alloc_coherent(&isci_host->pdev->dev,
+		ireq = dmam_alloc_coherent(&ihost->pdev->dev,
 					   sizeof(struct isci_request), &dma,
 					   GFP_KERNEL);
 		if (!ireq)
 			return -ENOMEM;
 
-		ireq->tc = &isci_host->sci.task_context_table[i];
-		ireq->owning_controller = &isci_host->sci;
+		ireq->tc = &ihost->task_context_table[i];
+		ireq->owning_controller = ihost;
 		spin_lock_init(&ireq->state_lock);
 		ireq->request_daddr = dma;
-		ireq->isci_host = isci_host;
-
-		isci_host->reqs[i] = ireq;
+		ireq->isci_host = ihost;
+		ihost->reqs[i] = ireq;
 	}
 
 	return 0;
 }
 
-void scic_sds_controller_link_up(struct scic_sds_controller *scic,
+void scic_sds_controller_link_up(struct isci_host *ihost,
 		struct isci_port *iport, struct isci_phy *iphy)
 {
-	switch (scic->sm.current_state_id) {
+	switch (ihost->sm.current_state_id) {
 	case SCIC_STARTING:
-		sci_del_timer(&scic->phy_timer);
-		scic->phy_startup_timer_pending = false;
-		scic->port_agent.link_up_handler(scic, &scic->port_agent,
+		sci_del_timer(&ihost->phy_timer);
+		ihost->phy_startup_timer_pending = false;
+		ihost->port_agent.link_up_handler(ihost, &ihost->port_agent,
 						 iport, iphy);
-		scic_sds_controller_start_next_phy(scic);
+		scic_sds_controller_start_next_phy(ihost);
 		break;
 	case SCIC_READY:
-		scic->port_agent.link_up_handler(scic, &scic->port_agent,
+		ihost->port_agent.link_up_handler(ihost, &ihost->port_agent,
 						 iport, iphy);
 		break;
 	default:
-		dev_dbg(scic_to_dev(scic),
+		dev_dbg(&ihost->pdev->dev,
 			"%s: SCIC Controller linkup event from phy %d in "
 			"unexpected state %d\n", __func__, iphy->phy_index,
-			scic->sm.current_state_id);
+			ihost->sm.current_state_id);
 	}
 }
 
-void scic_sds_controller_link_down(struct scic_sds_controller *scic,
+void scic_sds_controller_link_down(struct isci_host *ihost,
 		struct isci_port *iport, struct isci_phy *iphy)
 {
-	switch (scic->sm.current_state_id) {
+	switch (ihost->sm.current_state_id) {
 	case SCIC_STARTING:
 	case SCIC_READY:
-		scic->port_agent.link_down_handler(scic, &scic->port_agent,
+		ihost->port_agent.link_down_handler(ihost, &ihost->port_agent,
 						   iport, iphy);
 		break;
 	default:
-		dev_dbg(scic_to_dev(scic),
+		dev_dbg(&ihost->pdev->dev,
 			"%s: SCIC Controller linkdown event from phy %d in "
 			"unexpected state %d\n",
 			__func__,
 			iphy->phy_index,
-			scic->sm.current_state_id);
+			ihost->sm.current_state_id);
 	}
 }
 
@@ -2530,14 +2510,13 @@ void scic_sds_controller_link_down(struct scic_sds_controller *scic,
  * controller are still in the stopping state.
  *
  */
-static bool scic_sds_controller_has_remote_devices_stopping(
-	struct scic_sds_controller *controller)
+static bool scic_sds_controller_has_remote_devices_stopping(struct isci_host *ihost)
 {
 	u32 index;
 
-	for (index = 0; index < controller->remote_node_entries; index++) {
-		if ((controller->device_table[index] != NULL) &&
-		   (controller->device_table[index]->sm.current_state_id == SCI_DEV_STOPPING))
+	for (index = 0; index < ihost->remote_node_entries; index++) {
+		if ((ihost->device_table[index] != NULL) &&
+		   (ihost->device_table[index]->sm.current_state_id == SCI_DEV_STOPPING))
 			return true;
 	}
 
@@ -2548,20 +2527,20 @@ static bool scic_sds_controller_has_remote_devices_stopping(
  * This method is called by the remote device to inform the controller
  * object that the remote device has stopped.
  */
-void scic_sds_controller_remote_device_stopped(struct scic_sds_controller *scic,
+void scic_sds_controller_remote_device_stopped(struct isci_host *ihost,
 					       struct isci_remote_device *idev)
 {
-	if (scic->sm.current_state_id != SCIC_STOPPING) {
-		dev_dbg(scic_to_dev(scic),
+	if (ihost->sm.current_state_id != SCIC_STOPPING) {
+		dev_dbg(&ihost->pdev->dev,
 			"SCIC Controller 0x%p remote device stopped event "
 			"from device 0x%p in unexpected state %d\n",
-			scic, idev,
-			scic->sm.current_state_id);
+			ihost, idev,
+			ihost->sm.current_state_id);
 		return;
 	}
 
-	if (!scic_sds_controller_has_remote_devices_stopping(scic)) {
-		sci_change_state(&scic->sm, SCIC_STOPPED);
+	if (!scic_sds_controller_has_remote_devices_stopping(ihost)) {
+		sci_change_state(&ihost->sm, SCIC_STOPPED);
 	}
 }
 
@@ -2573,32 +2552,32 @@ void scic_sds_controller_remote_device_stopped(struct scic_sds_controller *scic,
  *
  */
 void scic_sds_controller_post_request(
-	struct scic_sds_controller *scic,
+	struct isci_host *ihost,
 	u32 request)
 {
-	dev_dbg(scic_to_dev(scic),
+	dev_dbg(&ihost->pdev->dev,
 		"%s: SCIC Controller 0x%p post request 0x%08x\n",
 		__func__,
-		scic,
+		ihost,
 		request);
 
-	writel(request, &scic->smu_registers->post_context_port);
+	writel(request, &ihost->smu_registers->post_context_port);
 }
 
-struct isci_request *scic_request_by_tag(struct scic_sds_controller *scic, u16 io_tag)
+struct isci_request *scic_request_by_tag(struct isci_host *ihost, u16 io_tag)
 {
 	u16 task_index;
 	u16 task_sequence;
 
 	task_index = ISCI_TAG_TCI(io_tag);
 
-	if (task_index < scic->task_context_entries) {
-		struct isci_request *ireq = scic_to_ihost(scic)->reqs[task_index];
+	if (task_index < ihost->task_context_entries) {
+		struct isci_request *ireq = ihost->reqs[task_index];
 
 		if (test_bit(IREQ_ACTIVE, &ireq->flags)) {
 			task_sequence = ISCI_TAG_SEQ(io_tag);
 
-			if (task_sequence == scic->io_request_sequence[task_index])
+			if (task_sequence == ihost->io_request_sequence[task_index])
 				return ireq;
 		}
 	}
@@ -2621,7 +2600,7 @@ struct isci_request *scic_request_by_tag(struct scic_sds_controller *scic, u16 i
  * node index available.
  */
 enum sci_status scic_sds_controller_allocate_remote_node_context(
-	struct scic_sds_controller *scic,
+	struct isci_host *ihost,
 	struct isci_remote_device *idev,
 	u16 *node_id)
 {
@@ -2629,11 +2608,11 @@ enum sci_status scic_sds_controller_allocate_remote_node_context(
 	u32 remote_node_count = scic_sds_remote_device_node_count(idev);
 
 	node_index = scic_sds_remote_node_table_allocate_remote_node(
-		&scic->available_remote_nodes, remote_node_count
+		&ihost->available_remote_nodes, remote_node_count
 		);
 
 	if (node_index != SCIC_SDS_REMOTE_NODE_CONTEXT_INVALID_INDEX) {
-		scic->device_table[node_index] = idev;
+		ihost->device_table[node_index] = idev;
 
 		*node_id = node_index;
 
@@ -2653,17 +2632,17 @@ enum sci_status scic_sds_controller_allocate_remote_node_context(
  *
  */
 void scic_sds_controller_free_remote_node_context(
-	struct scic_sds_controller *scic,
+	struct isci_host *ihost,
 	struct isci_remote_device *idev,
 	u16 node_id)
 {
 	u32 remote_node_count = scic_sds_remote_device_node_count(idev);
 
-	if (scic->device_table[node_id] == idev) {
-		scic->device_table[node_id] = NULL;
+	if (ihost->device_table[node_id] == idev) {
+		ihost->device_table[node_id] = NULL;
 
 		scic_sds_remote_node_table_release_remote_node_index(
-			&scic->available_remote_nodes, remote_node_count, node_id
+			&ihost->available_remote_nodes, remote_node_count, node_id
 			);
 	}
 }
@@ -2677,14 +2656,14 @@ void scic_sds_controller_free_remote_node_context(
  * union scu_remote_node_context*
  */
 union scu_remote_node_context *scic_sds_controller_get_remote_node_context_buffer(
-	struct scic_sds_controller *scic,
+	struct isci_host *ihost,
 	u16 node_id
 	) {
 	if (
-		(node_id < scic->remote_node_entries)
-		&& (scic->device_table[node_id] != NULL)
+		(node_id < ihost->remote_node_entries)
+		&& (ihost->device_table[node_id] != NULL)
 		) {
-		return &scic->remote_node_context_table[node_id];
+		return &ihost->remote_node_context_table[node_id];
 	}
 
 	return NULL;
@@ -2722,13 +2701,13 @@ void scic_sds_controller_copy_sata_response(
  *
  */
 void scic_sds_controller_release_frame(
-	struct scic_sds_controller *scic,
+	struct isci_host *ihost,
 	u32 frame_index)
 {
 	if (scic_sds_unsolicited_frame_control_release_frame(
-		    &scic->uf_control, frame_index) == true)
-		writel(scic->uf_control.get,
-			&scic->scu_registers->sdma.unsolicited_frame_get_pointer);
+		    &ihost->uf_control, frame_index) == true)
+		writel(ihost->uf_control.get,
+			&ihost->scu_registers->sdma.unsolicited_frame_get_pointer);
 }
 
 void isci_tci_free(struct isci_host *ihost, u16 tci)
@@ -2757,7 +2736,7 @@ u16 isci_alloc_tag(struct isci_host *ihost)
 {
 	if (isci_tci_space(ihost)) {
 		u16 tci = isci_tci_alloc(ihost);
-		u8 seq = ihost->sci.io_request_sequence[tci];
+		u8 seq = ihost->io_request_sequence[tci];
 
 		return ISCI_TAG(seq, tci);
 	}
@@ -2767,7 +2746,6 @@ u16 isci_alloc_tag(struct isci_host *ihost)
 
 enum sci_status isci_free_tag(struct isci_host *ihost, u16 io_tag)
 {
-	struct scic_sds_controller *scic = &ihost->sci;
 	u16 tci = ISCI_TAG_TCI(io_tag);
 	u16 seq = ISCI_TAG_SEQ(io_tag);
 
@@ -2775,8 +2753,8 @@ enum sci_status isci_free_tag(struct isci_host *ihost, u16 io_tag)
 	if (isci_tci_active(ihost) == 0)
 		return SCI_FAILURE_INVALID_IO_TAG;
 
-	if (seq == scic->io_request_sequence[tci]) {
-		scic->io_request_sequence[tci] = (seq+1) & (SCI_MAX_SEQ-1);
+	if (seq == ihost->io_request_sequence[tci]) {
+		ihost->io_request_sequence[tci] = (seq+1) & (SCI_MAX_SEQ-1);
 
 		isci_tci_free(ihost, tci);
 
@@ -2797,23 +2775,23 @@ enum sci_status isci_free_tag(struct isci_host *ihost, u16 io_tag)
  * @io_tag: This parameter specifies a previously allocated IO tag that the
  *    user desires to be utilized for this request.
  */
-enum sci_status scic_controller_start_io(struct scic_sds_controller *scic,
+enum sci_status scic_controller_start_io(struct isci_host *ihost,
 					 struct isci_remote_device *idev,
 					 struct isci_request *ireq)
 {
 	enum sci_status status;
 
-	if (scic->sm.current_state_id != SCIC_READY) {
-		dev_warn(scic_to_dev(scic), "invalid state to start I/O");
+	if (ihost->sm.current_state_id != SCIC_READY) {
+		dev_warn(&ihost->pdev->dev, "invalid state to start I/O");
 		return SCI_FAILURE_INVALID_STATE;
 	}
 
-	status = scic_sds_remote_device_start_io(scic, idev, ireq);
+	status = scic_sds_remote_device_start_io(ihost, idev, ireq);
 	if (status != SCI_SUCCESS)
 		return status;
 
 	set_bit(IREQ_ACTIVE, &ireq->flags);
-	scic_sds_controller_post_request(scic, scic_sds_request_get_post_context(ireq));
+	scic_sds_controller_post_request(ihost, scic_sds_request_get_post_context(ireq));
 	return SCI_SUCCESS;
 }
 
@@ -2834,14 +2812,14 @@ enum sci_status scic_controller_start_io(struct scic_sds_controller *scic,
  * for the request. Determine the failure situations and return values.
  */
 enum sci_status scic_controller_terminate_request(
-	struct scic_sds_controller *scic,
+	struct isci_host *ihost,
 	struct isci_remote_device *idev,
 	struct isci_request *ireq)
 {
 	enum sci_status status;
 
-	if (scic->sm.current_state_id != SCIC_READY) {
-		dev_warn(scic_to_dev(scic),
+	if (ihost->sm.current_state_id != SCIC_READY) {
+		dev_warn(&ihost->pdev->dev,
 			 "invalid state to terminate request\n");
 		return SCI_FAILURE_INVALID_STATE;
 	}
@@ -2854,7 +2832,7 @@ enum sci_status scic_controller_terminate_request(
 	 * Utilize the original post context command and or in the POST_TC_ABORT
 	 * request sub-type.
 	 */
-	scic_sds_controller_post_request(scic,
+	scic_sds_controller_post_request(ihost,
 		scic_sds_request_get_post_context(ireq) |
 		SCU_CONTEXT_COMMAND_REQUEST_POST_TC_ABORT);
 	return SCI_SUCCESS;
@@ -2872,19 +2850,19 @@ enum sci_status scic_controller_terminate_request(
  * @io_request: the handle to the io request object to complete.
  */
 enum sci_status scic_controller_complete_io(
-	struct scic_sds_controller *scic,
+	struct isci_host *ihost,
 	struct isci_remote_device *idev,
 	struct isci_request *ireq)
 {
 	enum sci_status status;
 	u16 index;
 
-	switch (scic->sm.current_state_id) {
+	switch (ihost->sm.current_state_id) {
 	case SCIC_STOPPING:
 		/* XXX: Implement this function */
 		return SCI_FAILURE;
 	case SCIC_READY:
-		status = scic_sds_remote_device_complete_io(scic, idev, ireq);
+		status = scic_sds_remote_device_complete_io(ihost, idev, ireq);
 		if (status != SCI_SUCCESS)
 			return status;
 
@@ -2892,7 +2870,7 @@ enum sci_status scic_controller_complete_io(
 		clear_bit(IREQ_ACTIVE, &ireq->flags);
 		return SCI_SUCCESS;
 	default:
-		dev_warn(scic_to_dev(scic), "invalid state to complete I/O");
+		dev_warn(&ihost->pdev->dev, "invalid state to complete I/O");
 		return SCI_FAILURE_INVALID_STATE;
 	}
 
@@ -2900,15 +2878,15 @@ enum sci_status scic_controller_complete_io(
 
 enum sci_status scic_controller_continue_io(struct isci_request *ireq)
 {
-	struct scic_sds_controller *scic = ireq->owning_controller;
+	struct isci_host *ihost = ireq->owning_controller;
 
-	if (scic->sm.current_state_id != SCIC_READY) {
-		dev_warn(scic_to_dev(scic), "invalid state to continue I/O");
+	if (ihost->sm.current_state_id != SCIC_READY) {
+		dev_warn(&ihost->pdev->dev, "invalid state to continue I/O");
 		return SCI_FAILURE_INVALID_STATE;
 	}
 
 	set_bit(IREQ_ACTIVE, &ireq->flags);
-	scic_sds_controller_post_request(scic, scic_sds_request_get_post_context(ireq));
+	scic_sds_controller_post_request(ihost, scic_sds_request_get_post_context(ireq));
 	return SCI_SUCCESS;
 }
 
@@ -2922,21 +2900,21 @@ enum sci_status scic_controller_continue_io(struct isci_request *ireq)
  * @task_request: the handle to the task request object to start.
  */
 enum sci_task_status scic_controller_start_task(
-	struct scic_sds_controller *scic,
+	struct isci_host *ihost,
 	struct isci_remote_device *idev,
 	struct isci_request *ireq)
 {
 	enum sci_status status;
 
-	if (scic->sm.current_state_id != SCIC_READY) {
-		dev_warn(scic_to_dev(scic),
+	if (ihost->sm.current_state_id != SCIC_READY) {
+		dev_warn(&ihost->pdev->dev,
 			 "%s: SCIC Controller starting task from invalid "
 			 "state\n",
 			 __func__);
 		return SCI_TASK_FAILURE_INVALID_STATE;
 	}
 
-	status = scic_sds_remote_device_start_task(scic, idev, ireq);
+	status = scic_sds_remote_device_start_task(ihost, idev, ireq);
 	switch (status) {
 	case SCI_FAILURE_RESET_DEVICE_PARTIAL_SUCCESS:
 		set_bit(IREQ_ACTIVE, &ireq->flags);
@@ -2950,7 +2928,7 @@ enum sci_task_status scic_controller_start_task(
 	case SCI_SUCCESS:
 		set_bit(IREQ_ACTIVE, &ireq->flags);
 
-		scic_sds_controller_post_request(scic,
+		scic_sds_controller_post_request(ihost,
 			scic_sds_request_get_post_context(ireq));
 		break;
 	default:

commit 78a6f06e0e82125787d7aa308fe28c2c8381540c
Author: Dan Williams <dan.j.williams@intel.com>
Date:   Thu Jun 30 16:31:37 2011 -0700

    isci: unify isci_remote_device and scic_sds_remote_device
    
    Remove the distinction between these two implementations and unify on
    isci_remote_device (local instances named idev).
    
    Reported-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/drivers/scsi/isci/host.c b/drivers/scsi/isci/host.c
index 4e11f9e6d766..45d7f71c609a 100644
--- a/drivers/scsi/isci/host.c
+++ b/drivers/scsi/isci/host.c
@@ -272,7 +272,7 @@ static void scic_sds_controller_sdma_completion(struct scic_sds_controller *scic
 {
 	u32 index;
 	struct isci_request *ireq;
-	struct scic_sds_remote_device *device;
+	struct isci_remote_device *idev;
 
 	index = SCU_GET_COMPLETION_INDEX(completion_entry);
 
@@ -289,9 +289,9 @@ static void scic_sds_controller_sdma_completion(struct scic_sds_controller *scic
 	case SCU_CONTEXT_COMMAND_REQUEST_TYPE_DUMP_RNC:
 	case SCU_CONTEXT_COMMAND_REQUEST_TYPE_OTHER_RNC:
 	case SCU_CONTEXT_COMMAND_REQUEST_TYPE_POST_RNC:
-		device = scic->device_table[index];
+		idev = scic->device_table[index];
 		dev_warn(scic_to_dev(scic), "%s: %x for device %p\n",
-			 __func__, completion_entry, device);
+			 __func__, completion_entry, idev);
 		/* @todo For a port RNC operation we need to fail the
 		 * device
 		 */
@@ -312,7 +312,7 @@ static void scic_sds_controller_unsolicited_frame(struct scic_sds_controller *sc
 	struct isci_host *ihost = scic_to_ihost(scic);
 	struct scu_unsolicited_frame_header *frame_header;
 	struct isci_phy *iphy;
-	struct scic_sds_remote_device *device;
+	struct isci_remote_device *idev;
 
 	enum sci_status result = SCI_FAILURE;
 
@@ -348,12 +348,12 @@ static void scic_sds_controller_unsolicited_frame(struct scic_sds_controller *sc
 			result = scic_sds_phy_frame_handler(iphy, frame_index);
 		} else {
 			if (index < scic->remote_node_entries)
-				device = scic->device_table[index];
+				idev = scic->device_table[index];
 			else
-				device = NULL;
+				idev = NULL;
 
-			if (device != NULL)
-				result = scic_sds_remote_device_frame_handler(device, frame_index);
+			if (idev != NULL)
+				result = scic_sds_remote_device_frame_handler(idev, frame_index);
 			else
 				scic_sds_controller_release_frame(scic, frame_index);
 		}
@@ -370,7 +370,7 @@ static void scic_sds_controller_event_completion(struct scic_sds_controller *sci
 						 u32 completion_entry)
 {
 	struct isci_host *ihost = scic_to_ihost(scic);
-	struct scic_sds_remote_device *device;
+	struct isci_remote_device *idev;
 	struct isci_request *ireq;
 	struct isci_phy *iphy;
 	u32 index;
@@ -426,9 +426,9 @@ static void scic_sds_controller_event_completion(struct scic_sds_controller *sci
 			break;
 
 		case SCU_EVENT_SPECIFIC_IT_NEXUS_TIMEOUT:
-			device = scic->device_table[index];
-			if (device != NULL)
-				scic_sds_remote_device_event_handler(device, completion_entry);
+			idev = scic->device_table[index];
+			if (idev != NULL)
+				scic_sds_remote_device_event_handler(idev, completion_entry);
 			else
 				dev_warn(scic_to_dev(scic),
 					 "%s: SCIC Controller 0x%p received "
@@ -460,10 +460,10 @@ static void scic_sds_controller_event_completion(struct scic_sds_controller *sci
 	case SCU_EVENT_TYPE_RNC_SUSPEND_TX_RX:
 	case SCU_EVENT_TYPE_RNC_OPS_MISC:
 		if (index < scic->remote_node_entries) {
-			device = scic->device_table[index];
+			idev = scic->device_table[index];
 
-			if (device != NULL)
-				scic_sds_remote_device_event_handler(device, completion_entry);
+			if (idev != NULL)
+				scic_sds_remote_device_event_handler(idev, completion_entry);
 		} else
 			dev_err(scic_to_dev(scic),
 				"%s: SCIC Controller 0x%p received event 0x%x "
@@ -2549,13 +2549,13 @@ static bool scic_sds_controller_has_remote_devices_stopping(
  * object that the remote device has stopped.
  */
 void scic_sds_controller_remote_device_stopped(struct scic_sds_controller *scic,
-					       struct scic_sds_remote_device *sci_dev)
+					       struct isci_remote_device *idev)
 {
 	if (scic->sm.current_state_id != SCIC_STOPPING) {
 		dev_dbg(scic_to_dev(scic),
 			"SCIC Controller 0x%p remote device stopped event "
 			"from device 0x%p in unexpected state %d\n",
-			scic, sci_dev,
+			scic, idev,
 			scic->sm.current_state_id);
 		return;
 	}
@@ -2622,18 +2622,18 @@ struct isci_request *scic_request_by_tag(struct scic_sds_controller *scic, u16 i
  */
 enum sci_status scic_sds_controller_allocate_remote_node_context(
 	struct scic_sds_controller *scic,
-	struct scic_sds_remote_device *sci_dev,
+	struct isci_remote_device *idev,
 	u16 *node_id)
 {
 	u16 node_index;
-	u32 remote_node_count = scic_sds_remote_device_node_count(sci_dev);
+	u32 remote_node_count = scic_sds_remote_device_node_count(idev);
 
 	node_index = scic_sds_remote_node_table_allocate_remote_node(
 		&scic->available_remote_nodes, remote_node_count
 		);
 
 	if (node_index != SCIC_SDS_REMOTE_NODE_CONTEXT_INVALID_INDEX) {
-		scic->device_table[node_index] = sci_dev;
+		scic->device_table[node_index] = idev;
 
 		*node_id = node_index;
 
@@ -2654,12 +2654,12 @@ enum sci_status scic_sds_controller_allocate_remote_node_context(
  */
 void scic_sds_controller_free_remote_node_context(
 	struct scic_sds_controller *scic,
-	struct scic_sds_remote_device *sci_dev,
+	struct isci_remote_device *idev,
 	u16 node_id)
 {
-	u32 remote_node_count = scic_sds_remote_device_node_count(sci_dev);
+	u32 remote_node_count = scic_sds_remote_device_node_count(idev);
 
-	if (scic->device_table[node_id] == sci_dev) {
+	if (scic->device_table[node_id] == idev) {
 		scic->device_table[node_id] = NULL;
 
 		scic_sds_remote_node_table_release_remote_node_index(
@@ -2798,7 +2798,7 @@ enum sci_status isci_free_tag(struct isci_host *ihost, u16 io_tag)
  *    user desires to be utilized for this request.
  */
 enum sci_status scic_controller_start_io(struct scic_sds_controller *scic,
-					 struct scic_sds_remote_device *rdev,
+					 struct isci_remote_device *idev,
 					 struct isci_request *ireq)
 {
 	enum sci_status status;
@@ -2808,7 +2808,7 @@ enum sci_status scic_controller_start_io(struct scic_sds_controller *scic,
 		return SCI_FAILURE_INVALID_STATE;
 	}
 
-	status = scic_sds_remote_device_start_io(scic, rdev, ireq);
+	status = scic_sds_remote_device_start_io(scic, idev, ireq);
 	if (status != SCI_SUCCESS)
 		return status;
 
@@ -2835,7 +2835,7 @@ enum sci_status scic_controller_start_io(struct scic_sds_controller *scic,
  */
 enum sci_status scic_controller_terminate_request(
 	struct scic_sds_controller *scic,
-	struct scic_sds_remote_device *rdev,
+	struct isci_remote_device *idev,
 	struct isci_request *ireq)
 {
 	enum sci_status status;
@@ -2873,7 +2873,7 @@ enum sci_status scic_controller_terminate_request(
  */
 enum sci_status scic_controller_complete_io(
 	struct scic_sds_controller *scic,
-	struct scic_sds_remote_device *rdev,
+	struct isci_remote_device *idev,
 	struct isci_request *ireq)
 {
 	enum sci_status status;
@@ -2884,7 +2884,7 @@ enum sci_status scic_controller_complete_io(
 		/* XXX: Implement this function */
 		return SCI_FAILURE;
 	case SCIC_READY:
-		status = scic_sds_remote_device_complete_io(scic, rdev, ireq);
+		status = scic_sds_remote_device_complete_io(scic, idev, ireq);
 		if (status != SCI_SUCCESS)
 			return status;
 
@@ -2923,7 +2923,7 @@ enum sci_status scic_controller_continue_io(struct isci_request *ireq)
  */
 enum sci_task_status scic_controller_start_task(
 	struct scic_sds_controller *scic,
-	struct scic_sds_remote_device *rdev,
+	struct isci_remote_device *idev,
 	struct isci_request *ireq)
 {
 	enum sci_status status;
@@ -2936,7 +2936,7 @@ enum sci_task_status scic_controller_start_task(
 		return SCI_TASK_FAILURE_INVALID_STATE;
 	}
 
-	status = scic_sds_remote_device_start_task(scic, rdev, ireq);
+	status = scic_sds_remote_device_start_task(scic, idev, ireq);
 	switch (status) {
 	case SCI_FAILURE_RESET_DEVICE_PARTIAL_SUCCESS:
 		set_bit(IREQ_ACTIVE, &ireq->flags);

commit ffe191c92ff195d73f9130b1490045ca2dd4c5e0
Author: Dan Williams <dan.j.williams@intel.com>
Date:   Wed Jun 29 13:09:25 2011 -0700

    isci: unify isci_port and scic_sds_port
    
    Remove the distinction between these two implementations and unify on
    isci_port (local instances named iport).  The duplicate '->owning_port' and
    '->isci_port' in both isci_phy and isci_remote_device will be fixed in a later
    patch... this is just the straightforward rename/unification.
    
    Reported-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/drivers/scsi/isci/host.c b/drivers/scsi/isci/host.c
index c5c2733a5197..4e11f9e6d766 100644
--- a/drivers/scsi/isci/host.c
+++ b/drivers/scsi/isci/host.c
@@ -1054,9 +1054,9 @@ static enum sci_status scic_controller_start(struct scic_sds_controller *scic,
 
 	/* Start all of the ports on this controller */
 	for (index = 0; index < scic->logical_port_entries; index++) {
-		struct scic_sds_port *sci_port = &ihost->ports[index].sci;
+		struct isci_port *iport = &ihost->ports[index];
 
-		result = scic_sds_port_start(sci_port);
+		result = scic_sds_port_start(iport);
 		if (result)
 			return result;
 	}
@@ -1306,8 +1306,8 @@ void isci_host_deinit(struct isci_host *ihost)
 
 	/* Cancel any/all outstanding port timers */
 	for (i = 0; i < ihost->sci.logical_port_entries; i++) {
-		struct scic_sds_port *sci_port = &ihost->ports[i].sci;
-		del_timer_sync(&sci_port->timer.timer);
+		struct isci_port *iport = &ihost->ports[i];
+		del_timer_sync(&iport->timer.timer);
 	}
 
 	/* Cancel any/all outstanding phy timers */
@@ -1552,9 +1552,9 @@ static enum sci_status scic_sds_controller_stop_ports(struct scic_sds_controller
 	struct isci_host *ihost = scic_to_ihost(scic);
 
 	for (index = 0; index < scic->logical_port_entries; index++) {
-		struct scic_sds_port *sci_port = &ihost->ports[index].sci;
+		struct isci_port *iport = &ihost->ports[index];
 
-		port_status = scic_sds_port_stop(sci_port);
+		port_status = scic_sds_port_stop(iport);
 
 		if ((port_status != SCI_SUCCESS) &&
 		    (port_status != SCI_FAILURE_INVALID_STATE)) {
@@ -1564,7 +1564,7 @@ static enum sci_status scic_sds_controller_stop_ports(struct scic_sds_controller
 				 "%s: Controller stop operation failed to "
 				 "stop port %d because of status %d.\n",
 				 __func__,
-				 sci_port->logical_port_index,
+				 iport->logical_port_index,
 				 port_status);
 		}
 	}
@@ -1780,14 +1780,14 @@ static enum sci_status scic_controller_construct(struct scic_sds_controller *sci
 
 	/* Construct the ports for this controller */
 	for (i = 0; i < SCI_MAX_PORTS; i++)
-		scic_sds_port_construct(&ihost->ports[i].sci, i, scic);
-	scic_sds_port_construct(&ihost->ports[i].sci, SCIC_SDS_DUMMY_PORT, scic);
+		scic_sds_port_construct(&ihost->ports[i], i, scic);
+	scic_sds_port_construct(&ihost->ports[i], SCIC_SDS_DUMMY_PORT, scic);
 
 	/* Construct the phys for this controller */
 	for (i = 0; i < SCI_MAX_PHYS; i++) {
 		/* Add all the PHYs to the dummy port */
 		scic_sds_phy_construct(&ihost->phys[i],
-				       &ihost->ports[SCI_MAX_PORTS].sci, i);
+				       &ihost->ports[SCI_MAX_PORTS], i);
 	}
 
 	scic->invalid_phy_mask = 0;
@@ -2233,7 +2233,7 @@ static enum sci_status scic_controller_initialize(struct scic_sds_controller *sc
 	}
 
 	for (i = 0; i < scic->logical_port_entries; i++) {
-		result = scic_sds_port_initialize(&ihost->ports[i].sci,
+		result = scic_sds_port_initialize(&ihost->ports[i],
 						  &scic->scu_registers->peg0.ptsg.port[i],
 						  &scic->scu_registers->peg0.ptsg.protocol_engine,
 						  &scic->scu_registers->peg0.viit[i]);
@@ -2484,19 +2484,19 @@ int isci_host_init(struct isci_host *isci_host)
 }
 
 void scic_sds_controller_link_up(struct scic_sds_controller *scic,
-		struct scic_sds_port *port, struct isci_phy *iphy)
+		struct isci_port *iport, struct isci_phy *iphy)
 {
 	switch (scic->sm.current_state_id) {
 	case SCIC_STARTING:
 		sci_del_timer(&scic->phy_timer);
 		scic->phy_startup_timer_pending = false;
 		scic->port_agent.link_up_handler(scic, &scic->port_agent,
-						 port, iphy);
+						 iport, iphy);
 		scic_sds_controller_start_next_phy(scic);
 		break;
 	case SCIC_READY:
 		scic->port_agent.link_up_handler(scic, &scic->port_agent,
-						 port, iphy);
+						 iport, iphy);
 		break;
 	default:
 		dev_dbg(scic_to_dev(scic),
@@ -2507,13 +2507,13 @@ void scic_sds_controller_link_up(struct scic_sds_controller *scic,
 }
 
 void scic_sds_controller_link_down(struct scic_sds_controller *scic,
-		struct scic_sds_port *port, struct isci_phy *iphy)
+		struct isci_port *iport, struct isci_phy *iphy)
 {
 	switch (scic->sm.current_state_id) {
 	case SCIC_STARTING:
 	case SCIC_READY:
 		scic->port_agent.link_down_handler(scic, &scic->port_agent,
-						   port, iphy);
+						   iport, iphy);
 		break;
 	default:
 		dev_dbg(scic_to_dev(scic),

commit 852809559e4680ba4768262a6c3d21454fcd460e
Author: Dan Williams <dan.j.williams@intel.com>
Date:   Tue Jun 28 15:05:53 2011 -0700

    isci: unify isci_phy and scic_sds_phy
    
    They are one in the same object so remove the distinction.  The near
    duplicate fields (owning_port, and isci_port) will be cleaned up
    after the scic_sds_port isci_port unification.
    
    Reported-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/drivers/scsi/isci/host.c b/drivers/scsi/isci/host.c
index d91cd6d82747..c5c2733a5197 100644
--- a/drivers/scsi/isci/host.c
+++ b/drivers/scsi/isci/host.c
@@ -311,7 +311,7 @@ static void scic_sds_controller_unsolicited_frame(struct scic_sds_controller *sc
 
 	struct isci_host *ihost = scic_to_ihost(scic);
 	struct scu_unsolicited_frame_header *frame_header;
-	struct scic_sds_phy *phy;
+	struct isci_phy *iphy;
 	struct scic_sds_remote_device *device;
 
 	enum sci_status result = SCI_FAILURE;
@@ -332,8 +332,8 @@ static void scic_sds_controller_unsolicited_frame(struct scic_sds_controller *sc
 
 	if (frame_header->is_address_frame) {
 		index = SCU_GET_PROTOCOL_ENGINE_INDEX(completion_entry);
-		phy = &ihost->phys[index].sci;
-		result = scic_sds_phy_frame_handler(phy, frame_index);
+		iphy = &ihost->phys[index];
+		result = scic_sds_phy_frame_handler(iphy, frame_index);
 	} else {
 
 		index = SCU_GET_COMPLETION_INDEX(completion_entry);
@@ -344,8 +344,8 @@ static void scic_sds_controller_unsolicited_frame(struct scic_sds_controller *sc
 			 * device that has not yet been created.  In either case forwared
 			 * the frame to the PE and let it take care of the frame data. */
 			index = SCU_GET_PROTOCOL_ENGINE_INDEX(completion_entry);
-			phy = &ihost->phys[index].sci;
-			result = scic_sds_phy_frame_handler(phy, frame_index);
+			iphy = &ihost->phys[index];
+			result = scic_sds_phy_frame_handler(iphy, frame_index);
 		} else {
 			if (index < scic->remote_node_entries)
 				device = scic->device_table[index];
@@ -372,7 +372,7 @@ static void scic_sds_controller_event_completion(struct scic_sds_controller *sci
 	struct isci_host *ihost = scic_to_ihost(scic);
 	struct scic_sds_remote_device *device;
 	struct isci_request *ireq;
-	struct scic_sds_phy *phy;
+	struct isci_phy *iphy;
 	u32 index;
 
 	index = SCU_GET_COMPLETION_INDEX(completion_entry);
@@ -452,8 +452,8 @@ static void scic_sds_controller_event_completion(struct scic_sds_controller *sci
 	 * we get the event notification.  This is a type 4 event. */
 	case SCU_EVENT_TYPE_OSSP_EVENT:
 		index = SCU_GET_PROTOCOL_ENGINE_INDEX(completion_entry);
-		phy = &ihost->phys[index].sci;
-		scic_sds_phy_event_handler(phy, completion_entry);
+		iphy = &ihost->phys[index];
+		scic_sds_phy_event_handler(iphy, completion_entry);
 		break;
 
 	case SCU_EVENT_TYPE_RNC_SUSPEND_TX:
@@ -862,11 +862,11 @@ static void scic_sds_controller_transition_to_ready(
 	}
 }
 
-static bool is_phy_starting(struct scic_sds_phy *sci_phy)
+static bool is_phy_starting(struct isci_phy *iphy)
 {
 	enum scic_sds_phy_states state;
 
-	state = sci_phy->sm.current_state_id;
+	state = iphy->sm.current_state_id;
 	switch (state) {
 	case SCI_PHY_STARTING:
 	case SCI_PHY_SUB_INITIAL:
@@ -896,7 +896,7 @@ static enum sci_status scic_sds_controller_start_next_phy(struct scic_sds_contro
 {
 	struct isci_host *ihost = scic_to_ihost(scic);
 	struct scic_sds_oem_params *oem = &scic->oem_parameters.sds1;
-	struct scic_sds_phy *sci_phy;
+	struct isci_phy *iphy;
 	enum sci_status status;
 
 	status = SCI_SUCCESS;
@@ -910,10 +910,10 @@ static enum sci_status scic_sds_controller_start_next_phy(struct scic_sds_contro
 		u8 index;
 
 		for (index = 0; index < SCI_MAX_PHYS; index++) {
-			sci_phy = &ihost->phys[index].sci;
-			state = sci_phy->sm.current_state_id;
+			iphy = &ihost->phys[index];
+			state = iphy->sm.current_state_id;
 
-			if (!phy_get_non_dummy_port(sci_phy))
+			if (!phy_get_non_dummy_port(iphy))
 				continue;
 
 			/* The controller start operation is complete iff:
@@ -922,9 +922,9 @@ static enum sci_status scic_sds_controller_start_next_phy(struct scic_sds_contro
 			 * - have an indication of a connected device and it has
 			 *   finished the link training process.
 			 */
-			if ((sci_phy->is_in_link_training == false && state == SCI_PHY_INITIAL) ||
-			    (sci_phy->is_in_link_training == false && state == SCI_PHY_STOPPED) ||
-			    (sci_phy->is_in_link_training == true && is_phy_starting(sci_phy))) {
+			if ((iphy->is_in_link_training == false && state == SCI_PHY_INITIAL) ||
+			    (iphy->is_in_link_training == false && state == SCI_PHY_STOPPED) ||
+			    (iphy->is_in_link_training == true && is_phy_starting(iphy))) {
 				is_controller_start_complete = false;
 				break;
 			}
@@ -939,10 +939,10 @@ static enum sci_status scic_sds_controller_start_next_phy(struct scic_sds_contro
 			scic->phy_startup_timer_pending = false;
 		}
 	} else {
-		sci_phy = &ihost->phys[scic->next_phy_to_start].sci;
+		iphy = &ihost->phys[scic->next_phy_to_start];
 
 		if (oem->controller.mode_type == SCIC_PORT_MANUAL_CONFIGURATION_MODE) {
-			if (phy_get_non_dummy_port(sci_phy) == NULL) {
+			if (phy_get_non_dummy_port(iphy) == NULL) {
 				scic->next_phy_to_start++;
 
 				/* Caution recursion ahead be forwarned
@@ -958,7 +958,7 @@ static enum sci_status scic_sds_controller_start_next_phy(struct scic_sds_contro
 			}
 		}
 
-		status = scic_sds_phy_start(sci_phy);
+		status = scic_sds_phy_start(iphy);
 
 		if (status == SCI_SUCCESS) {
 			sci_mod_timer(&scic->phy_timer,
@@ -970,7 +970,7 @@ static enum sci_status scic_sds_controller_start_next_phy(struct scic_sds_contro
 				 "to stop phy %d because of status "
 				 "%d.\n",
 				 __func__,
-				 ihost->phys[scic->next_phy_to_start].sci.phy_index,
+				 ihost->phys[scic->next_phy_to_start].phy_index,
 				 status);
 		}
 
@@ -1312,8 +1312,8 @@ void isci_host_deinit(struct isci_host *ihost)
 
 	/* Cancel any/all outstanding phy timers */
 	for (i = 0; i < SCI_MAX_PHYS; i++) {
-		struct scic_sds_phy *sci_phy = &ihost->phys[i].sci;
-		del_timer_sync(&sci_phy->sata_timer.timer);
+		struct isci_phy *iphy = &ihost->phys[i];
+		del_timer_sync(&iphy->sata_timer.timer);
 	}
 
 	del_timer_sync(&ihost->sci.port_agent.timer.timer);
@@ -1527,7 +1527,7 @@ static enum sci_status scic_sds_controller_stop_phys(struct scic_sds_controller
 	status = SCI_SUCCESS;
 
 	for (index = 0; index < SCI_MAX_PHYS; index++) {
-		phy_status = scic_sds_phy_stop(&ihost->phys[index].sci);
+		phy_status = scic_sds_phy_stop(&ihost->phys[index]);
 
 		if (phy_status != SCI_SUCCESS &&
 		    phy_status != SCI_FAILURE_INVALID_STATE) {
@@ -1537,7 +1537,7 @@ static enum sci_status scic_sds_controller_stop_phys(struct scic_sds_controller
 				 "%s: Controller stop operation failed to stop "
 				 "phy %d because of status %d.\n",
 				 __func__,
-				 ihost->phys[index].sci.phy_index, phy_status);
+				 ihost->phys[index].phy_index, phy_status);
 		}
 	}
 
@@ -1786,7 +1786,7 @@ static enum sci_status scic_controller_construct(struct scic_sds_controller *sci
 	/* Construct the phys for this controller */
 	for (i = 0; i < SCI_MAX_PHYS; i++) {
 		/* Add all the PHYs to the dummy port */
-		scic_sds_phy_construct(&ihost->phys[i].sci,
+		scic_sds_phy_construct(&ihost->phys[i],
 				       &ihost->ports[SCI_MAX_PORTS].sci, i);
 	}
 
@@ -1865,7 +1865,7 @@ static void power_control_timeout(unsigned long data)
 	struct sci_timer *tmr = (struct sci_timer *)data;
 	struct scic_sds_controller *scic = container_of(tmr, typeof(*scic), power_control.timer);
 	struct isci_host *ihost = scic_to_ihost(scic);
-	struct scic_sds_phy *sci_phy;
+	struct isci_phy *iphy;
 	unsigned long flags;
 	u8 i;
 
@@ -1886,8 +1886,8 @@ static void power_control_timeout(unsigned long data)
 		if (scic->power_control.phys_waiting == 0)
 			break;
 
-		sci_phy = scic->power_control.requesters[i];
-		if (sci_phy == NULL)
+		iphy = scic->power_control.requesters[i];
+		if (iphy == NULL)
 			continue;
 
 		if (scic->power_control.phys_granted_power >=
@@ -1897,7 +1897,7 @@ static void power_control_timeout(unsigned long data)
 		scic->power_control.requesters[i] = NULL;
 		scic->power_control.phys_waiting--;
 		scic->power_control.phys_granted_power++;
-		scic_sds_phy_consume_power_handler(sci_phy);
+		scic_sds_phy_consume_power_handler(iphy);
 	}
 
 	/*
@@ -1919,14 +1919,14 @@ static void power_control_timeout(unsigned long data)
  */
 void scic_sds_controller_power_control_queue_insert(
 	struct scic_sds_controller *scic,
-	struct scic_sds_phy *sci_phy)
+	struct isci_phy *iphy)
 {
-	BUG_ON(sci_phy == NULL);
+	BUG_ON(iphy == NULL);
 
 	if (scic->power_control.phys_granted_power <
 	    scic->oem_parameters.sds1.controller.max_concurrent_dev_spin_up) {
 		scic->power_control.phys_granted_power++;
-		scic_sds_phy_consume_power_handler(sci_phy);
+		scic_sds_phy_consume_power_handler(iphy);
 
 		/*
 		 * stop and start the power_control timer. When the timer fires, the
@@ -1941,7 +1941,7 @@ void scic_sds_controller_power_control_queue_insert(
 
 	} else {
 		/* Add the phy in the waiting list */
-		scic->power_control.requesters[sci_phy->phy_index] = sci_phy;
+		scic->power_control.requesters[iphy->phy_index] = iphy;
 		scic->power_control.phys_waiting++;
 	}
 }
@@ -1954,15 +1954,15 @@ void scic_sds_controller_power_control_queue_insert(
  */
 void scic_sds_controller_power_control_queue_remove(
 	struct scic_sds_controller *scic,
-	struct scic_sds_phy *sci_phy)
+	struct isci_phy *iphy)
 {
-	BUG_ON(sci_phy == NULL);
+	BUG_ON(iphy == NULL);
 
-	if (scic->power_control.requesters[sci_phy->phy_index] != NULL) {
+	if (scic->power_control.requesters[iphy->phy_index] != NULL) {
 		scic->power_control.phys_waiting--;
 	}
 
-	scic->power_control.requesters[sci_phy->phy_index] = NULL;
+	scic->power_control.requesters[iphy->phy_index] = NULL;
 }
 
 #define AFE_REGISTER_WRITE_DELAY 10
@@ -2225,7 +2225,7 @@ static enum sci_status scic_controller_initialize(struct scic_sds_controller *sc
 	 * are accessed during the port initialization.
 	 */
 	for (i = 0; i < SCI_MAX_PHYS; i++) {
-		result = scic_sds_phy_initialize(&ihost->phys[i].sci,
+		result = scic_sds_phy_initialize(&ihost->phys[i],
 						 &scic->scu_registers->peg0.pe[i].tl,
 						 &scic->scu_registers->peg0.pe[i].ll);
 		if (result != SCI_SUCCESS)
@@ -2484,43 +2484,43 @@ int isci_host_init(struct isci_host *isci_host)
 }
 
 void scic_sds_controller_link_up(struct scic_sds_controller *scic,
-		struct scic_sds_port *port, struct scic_sds_phy *phy)
+		struct scic_sds_port *port, struct isci_phy *iphy)
 {
 	switch (scic->sm.current_state_id) {
 	case SCIC_STARTING:
 		sci_del_timer(&scic->phy_timer);
 		scic->phy_startup_timer_pending = false;
 		scic->port_agent.link_up_handler(scic, &scic->port_agent,
-						 port, phy);
+						 port, iphy);
 		scic_sds_controller_start_next_phy(scic);
 		break;
 	case SCIC_READY:
 		scic->port_agent.link_up_handler(scic, &scic->port_agent,
-						 port, phy);
+						 port, iphy);
 		break;
 	default:
 		dev_dbg(scic_to_dev(scic),
 			"%s: SCIC Controller linkup event from phy %d in "
-			"unexpected state %d\n", __func__, phy->phy_index,
+			"unexpected state %d\n", __func__, iphy->phy_index,
 			scic->sm.current_state_id);
 	}
 }
 
 void scic_sds_controller_link_down(struct scic_sds_controller *scic,
-		struct scic_sds_port *port, struct scic_sds_phy *phy)
+		struct scic_sds_port *port, struct isci_phy *iphy)
 {
 	switch (scic->sm.current_state_id) {
 	case SCIC_STARTING:
 	case SCIC_READY:
 		scic->port_agent.link_down_handler(scic, &scic->port_agent,
-						   port, phy);
+						   port, iphy);
 		break;
 	default:
 		dev_dbg(scic_to_dev(scic),
 			"%s: SCIC Controller linkdown event from phy %d in "
 			"unexpected state %d\n",
 			__func__,
-			phy->phy_index,
+			iphy->phy_index,
 			scic->sm.current_state_id);
 	}
 }

commit 5076a1a97e2fa61c847a5fdd4b1991faf7716da6
Author: Dan Williams <dan.j.williams@intel.com>
Date:   Mon Jun 27 14:57:03 2011 -0700

    isci: unify isci_request and scic_sds_request
    
    They are one in the same object so remove the distinction.  The near
    duplicate fields (owning_controller, and isci_host) will be cleaned up
    after the scic_sds_contoller isci_host unification.
    
    Reported-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/drivers/scsi/isci/host.c b/drivers/scsi/isci/host.c
index 0884ae3253e5..d91cd6d82747 100644
--- a/drivers/scsi/isci/host.c
+++ b/drivers/scsi/isci/host.c
@@ -258,21 +258,20 @@ static void scic_sds_controller_task_completion(struct scic_sds_controller *scic
 	u32 index = SCU_GET_COMPLETION_INDEX(completion_entry);
 	struct isci_host *ihost = scic_to_ihost(scic);
 	struct isci_request *ireq = ihost->reqs[index];
-	struct scic_sds_request *sci_req = &ireq->sci;
 
 	/* Make sure that we really want to process this IO request */
 	if (test_bit(IREQ_ACTIVE, &ireq->flags) &&
-	    sci_req->io_tag != SCI_CONTROLLER_INVALID_IO_TAG &&
-	    ISCI_TAG_SEQ(sci_req->io_tag) == scic->io_request_sequence[index])
+	    ireq->io_tag != SCI_CONTROLLER_INVALID_IO_TAG &&
+	    ISCI_TAG_SEQ(ireq->io_tag) == scic->io_request_sequence[index])
 		/* Yep this is a valid io request pass it along to the io request handler */
-		scic_sds_io_request_tc_completion(sci_req, completion_entry);
+		scic_sds_io_request_tc_completion(ireq, completion_entry);
 }
 
 static void scic_sds_controller_sdma_completion(struct scic_sds_controller *scic,
 						u32 completion_entry)
 {
 	u32 index;
-	struct scic_sds_request *io_request;
+	struct isci_request *ireq;
 	struct scic_sds_remote_device *device;
 
 	index = SCU_GET_COMPLETION_INDEX(completion_entry);
@@ -280,41 +279,27 @@ static void scic_sds_controller_sdma_completion(struct scic_sds_controller *scic
 	switch (scu_get_command_request_type(completion_entry)) {
 	case SCU_CONTEXT_COMMAND_REQUEST_TYPE_POST_TC:
 	case SCU_CONTEXT_COMMAND_REQUEST_TYPE_DUMP_TC:
-		io_request = &scic_to_ihost(scic)->reqs[index]->sci;
-		dev_warn(scic_to_dev(scic),
-			 "%s: SCIC SDS Completion type SDMA %x for io request "
-			 "%p\n",
-			 __func__,
-			 completion_entry,
-			 io_request);
+		ireq = scic_to_ihost(scic)->reqs[index];
+		dev_warn(scic_to_dev(scic), "%s: %x for io request %p\n",
+			 __func__, completion_entry, ireq);
 		/* @todo For a post TC operation we need to fail the IO
 		 * request
 		 */
 		break;
-
 	case SCU_CONTEXT_COMMAND_REQUEST_TYPE_DUMP_RNC:
 	case SCU_CONTEXT_COMMAND_REQUEST_TYPE_OTHER_RNC:
 	case SCU_CONTEXT_COMMAND_REQUEST_TYPE_POST_RNC:
 		device = scic->device_table[index];
-		dev_warn(scic_to_dev(scic),
-			 "%s: SCIC SDS Completion type SDMA %x for remote "
-			 "device %p\n",
-			 __func__,
-			 completion_entry,
-			 device);
+		dev_warn(scic_to_dev(scic), "%s: %x for device %p\n",
+			 __func__, completion_entry, device);
 		/* @todo For a port RNC operation we need to fail the
 		 * device
 		 */
 		break;
-
 	default:
-		dev_warn(scic_to_dev(scic),
-			 "%s: SCIC SDS Completion unknown SDMA completion "
-			 "type %x\n",
-			 __func__,
-			 completion_entry);
+		dev_warn(scic_to_dev(scic), "%s: unknown completion type %x\n",
+			 __func__, completion_entry);
 		break;
-
 	}
 }
 
@@ -385,8 +370,8 @@ static void scic_sds_controller_event_completion(struct scic_sds_controller *sci
 						 u32 completion_entry)
 {
 	struct isci_host *ihost = scic_to_ihost(scic);
-	struct scic_sds_request *io_request;
 	struct scic_sds_remote_device *device;
+	struct isci_request *ireq;
 	struct scic_sds_phy *phy;
 	u32 index;
 
@@ -418,17 +403,17 @@ static void scic_sds_controller_event_completion(struct scic_sds_controller *sci
 		break;
 
 	case SCU_EVENT_TYPE_TRANSPORT_ERROR:
-		io_request = &ihost->reqs[index]->sci;
-		scic_sds_io_request_event_handler(io_request, completion_entry);
+		ireq = ihost->reqs[index];
+		scic_sds_io_request_event_handler(ireq, completion_entry);
 		break;
 
 	case SCU_EVENT_TYPE_PTX_SCHEDULE_EVENT:
 		switch (scu_get_event_specifier(completion_entry)) {
 		case SCU_EVENT_SPECIFIC_SMP_RESPONSE_NO_PE:
 		case SCU_EVENT_SPECIFIC_TASK_TIMEOUT:
-			io_request = &ihost->reqs[index]->sci;
-			if (io_request != NULL)
-				scic_sds_io_request_event_handler(io_request, completion_entry);
+			ireq = ihost->reqs[index];
+			if (ireq != NULL)
+				scic_sds_io_request_event_handler(ireq, completion_entry);
 			else
 				dev_warn(scic_to_dev(scic),
 					 "%s: SCIC Controller 0x%p received "
@@ -1185,7 +1170,7 @@ static void isci_host_completion_routine(unsigned long data)
 		}
 
 		spin_lock_irq(&isci_host->scic_lock);
-		isci_free_tag(isci_host, request->sci.io_tag);
+		isci_free_tag(isci_host, request->io_tag);
 		spin_unlock_irq(&isci_host->scic_lock);
 	}
 	list_for_each_entry_safe(request, next_request, &errored_request_list,
@@ -1222,7 +1207,7 @@ static void isci_host_completion_routine(unsigned long data)
 			* of pending requests.
 			*/
 			list_del_init(&request->dev_node);
-			isci_free_tag(isci_host, request->sci.io_tag);
+			isci_free_tag(isci_host, request->io_tag);
 			spin_unlock_irq(&isci_host->scic_lock);
 		}
 	}
@@ -2486,8 +2471,8 @@ int isci_host_init(struct isci_host *isci_host)
 		if (!ireq)
 			return -ENOMEM;
 
-		ireq->sci.tc = &isci_host->sci.task_context_table[i];
-		ireq->sci.owning_controller = &isci_host->sci;
+		ireq->tc = &isci_host->sci.task_context_table[i];
+		ireq->owning_controller = &isci_host->sci;
 		spin_lock_init(&ireq->state_lock);
 		ireq->request_daddr = dma;
 		ireq->isci_host = isci_host;
@@ -2600,7 +2585,7 @@ void scic_sds_controller_post_request(
 	writel(request, &scic->smu_registers->post_context_port);
 }
 
-struct scic_sds_request *scic_request_by_tag(struct scic_sds_controller *scic, u16 io_tag)
+struct isci_request *scic_request_by_tag(struct scic_sds_controller *scic, u16 io_tag)
 {
 	u16 task_index;
 	u16 task_sequence;
@@ -2614,7 +2599,7 @@ struct scic_sds_request *scic_request_by_tag(struct scic_sds_controller *scic, u
 			task_sequence = ISCI_TAG_SEQ(io_tag);
 
 			if (task_sequence == scic->io_request_sequence[task_index])
-				return &ireq->sci;
+				return ireq;
 		}
 	}
 
@@ -2814,7 +2799,7 @@ enum sci_status isci_free_tag(struct isci_host *ihost, u16 io_tag)
  */
 enum sci_status scic_controller_start_io(struct scic_sds_controller *scic,
 					 struct scic_sds_remote_device *rdev,
-					 struct scic_sds_request *req)
+					 struct isci_request *ireq)
 {
 	enum sci_status status;
 
@@ -2823,12 +2808,12 @@ enum sci_status scic_controller_start_io(struct scic_sds_controller *scic,
 		return SCI_FAILURE_INVALID_STATE;
 	}
 
-	status = scic_sds_remote_device_start_io(scic, rdev, req);
+	status = scic_sds_remote_device_start_io(scic, rdev, ireq);
 	if (status != SCI_SUCCESS)
 		return status;
 
-	set_bit(IREQ_ACTIVE, &sci_req_to_ireq(req)->flags);
-	scic_sds_controller_post_request(scic, scic_sds_request_get_post_context(req));
+	set_bit(IREQ_ACTIVE, &ireq->flags);
+	scic_sds_controller_post_request(scic, scic_sds_request_get_post_context(ireq));
 	return SCI_SUCCESS;
 }
 
@@ -2851,7 +2836,7 @@ enum sci_status scic_controller_start_io(struct scic_sds_controller *scic,
 enum sci_status scic_controller_terminate_request(
 	struct scic_sds_controller *scic,
 	struct scic_sds_remote_device *rdev,
-	struct scic_sds_request *req)
+	struct isci_request *ireq)
 {
 	enum sci_status status;
 
@@ -2861,7 +2846,7 @@ enum sci_status scic_controller_terminate_request(
 		return SCI_FAILURE_INVALID_STATE;
 	}
 
-	status = scic_sds_io_request_terminate(req);
+	status = scic_sds_io_request_terminate(ireq);
 	if (status != SCI_SUCCESS)
 		return status;
 
@@ -2870,7 +2855,7 @@ enum sci_status scic_controller_terminate_request(
 	 * request sub-type.
 	 */
 	scic_sds_controller_post_request(scic,
-		scic_sds_request_get_post_context(req) |
+		scic_sds_request_get_post_context(ireq) |
 		SCU_CONTEXT_COMMAND_REQUEST_POST_TC_ABORT);
 	return SCI_SUCCESS;
 }
@@ -2889,7 +2874,7 @@ enum sci_status scic_controller_terminate_request(
 enum sci_status scic_controller_complete_io(
 	struct scic_sds_controller *scic,
 	struct scic_sds_remote_device *rdev,
-	struct scic_sds_request *request)
+	struct isci_request *ireq)
 {
 	enum sci_status status;
 	u16 index;
@@ -2899,12 +2884,12 @@ enum sci_status scic_controller_complete_io(
 		/* XXX: Implement this function */
 		return SCI_FAILURE;
 	case SCIC_READY:
-		status = scic_sds_remote_device_complete_io(scic, rdev, request);
+		status = scic_sds_remote_device_complete_io(scic, rdev, ireq);
 		if (status != SCI_SUCCESS)
 			return status;
 
-		index = ISCI_TAG_TCI(request->io_tag);
-		clear_bit(IREQ_ACTIVE, &sci_req_to_ireq(request)->flags);
+		index = ISCI_TAG_TCI(ireq->io_tag);
+		clear_bit(IREQ_ACTIVE, &ireq->flags);
 		return SCI_SUCCESS;
 	default:
 		dev_warn(scic_to_dev(scic), "invalid state to complete I/O");
@@ -2913,17 +2898,17 @@ enum sci_status scic_controller_complete_io(
 
 }
 
-enum sci_status scic_controller_continue_io(struct scic_sds_request *sci_req)
+enum sci_status scic_controller_continue_io(struct isci_request *ireq)
 {
-	struct scic_sds_controller *scic = sci_req->owning_controller;
+	struct scic_sds_controller *scic = ireq->owning_controller;
 
 	if (scic->sm.current_state_id != SCIC_READY) {
 		dev_warn(scic_to_dev(scic), "invalid state to continue I/O");
 		return SCI_FAILURE_INVALID_STATE;
 	}
 
-	set_bit(IREQ_ACTIVE, &sci_req_to_ireq(sci_req)->flags);
-	scic_sds_controller_post_request(scic, scic_sds_request_get_post_context(sci_req));
+	set_bit(IREQ_ACTIVE, &ireq->flags);
+	scic_sds_controller_post_request(scic, scic_sds_request_get_post_context(ireq));
 	return SCI_SUCCESS;
 }
 
@@ -2939,9 +2924,8 @@ enum sci_status scic_controller_continue_io(struct scic_sds_request *sci_req)
 enum sci_task_status scic_controller_start_task(
 	struct scic_sds_controller *scic,
 	struct scic_sds_remote_device *rdev,
-	struct scic_sds_request *req)
+	struct isci_request *ireq)
 {
-	struct isci_request *ireq = sci_req_to_ireq(req);
 	enum sci_status status;
 
 	if (scic->sm.current_state_id != SCIC_READY) {
@@ -2952,7 +2936,7 @@ enum sci_task_status scic_controller_start_task(
 		return SCI_TASK_FAILURE_INVALID_STATE;
 	}
 
-	status = scic_sds_remote_device_start_task(scic, rdev, req);
+	status = scic_sds_remote_device_start_task(scic, rdev, ireq);
 	switch (status) {
 	case SCI_FAILURE_RESET_DEVICE_PARTIAL_SUCCESS:
 		set_bit(IREQ_ACTIVE, &ireq->flags);
@@ -2967,7 +2951,7 @@ enum sci_task_status scic_controller_start_task(
 		set_bit(IREQ_ACTIVE, &ireq->flags);
 
 		scic_sds_controller_post_request(scic,
-			scic_sds_request_get_post_context(req));
+			scic_sds_request_get_post_context(ireq));
 		break;
 	default:
 		break;

commit db0562509800a2d4cb5cb14a66413c30484f165c
Author: Dan Williams <dan.j.williams@intel.com>
Date:   Fri Jun 17 14:18:39 2011 -0700

    isci: preallocate requests
    
    the dma_pool interface is optimized for object_size << page_size which
    is not the case with isci_request objects and the dma_pool routines show
    up in the top of the profile.
    
    The old io_request_table which tracked whether tci slots were in-flight
    or not is replaced with an IREQ_ACTIVE flag per request.
    
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/drivers/scsi/isci/host.c b/drivers/scsi/isci/host.c
index c99fab53dd0c..0884ae3253e5 100644
--- a/drivers/scsi/isci/host.c
+++ b/drivers/scsi/isci/host.c
@@ -255,14 +255,14 @@ static bool scic_sds_controller_error_isr(struct scic_sds_controller *scic)
 static void scic_sds_controller_task_completion(struct scic_sds_controller *scic,
 						u32 completion_entry)
 {
-	u32 index;
-	struct scic_sds_request *sci_req;
-
-	index = SCU_GET_COMPLETION_INDEX(completion_entry);
-	sci_req = scic->io_request_table[index];
+	u32 index = SCU_GET_COMPLETION_INDEX(completion_entry);
+	struct isci_host *ihost = scic_to_ihost(scic);
+	struct isci_request *ireq = ihost->reqs[index];
+	struct scic_sds_request *sci_req = &ireq->sci;
 
 	/* Make sure that we really want to process this IO request */
-	if (sci_req && sci_req->io_tag != SCI_CONTROLLER_INVALID_IO_TAG &&
+	if (test_bit(IREQ_ACTIVE, &ireq->flags) &&
+	    sci_req->io_tag != SCI_CONTROLLER_INVALID_IO_TAG &&
 	    ISCI_TAG_SEQ(sci_req->io_tag) == scic->io_request_sequence[index])
 		/* Yep this is a valid io request pass it along to the io request handler */
 		scic_sds_io_request_tc_completion(sci_req, completion_entry);
@@ -280,7 +280,7 @@ static void scic_sds_controller_sdma_completion(struct scic_sds_controller *scic
 	switch (scu_get_command_request_type(completion_entry)) {
 	case SCU_CONTEXT_COMMAND_REQUEST_TYPE_POST_TC:
 	case SCU_CONTEXT_COMMAND_REQUEST_TYPE_DUMP_TC:
-		io_request = scic->io_request_table[index];
+		io_request = &scic_to_ihost(scic)->reqs[index]->sci;
 		dev_warn(scic_to_dev(scic),
 			 "%s: SCIC SDS Completion type SDMA %x for io request "
 			 "%p\n",
@@ -418,7 +418,7 @@ static void scic_sds_controller_event_completion(struct scic_sds_controller *sci
 		break;
 
 	case SCU_EVENT_TYPE_TRANSPORT_ERROR:
-		io_request = scic->io_request_table[index];
+		io_request = &ihost->reqs[index]->sci;
 		scic_sds_io_request_event_handler(io_request, completion_entry);
 		break;
 
@@ -426,7 +426,7 @@ static void scic_sds_controller_event_completion(struct scic_sds_controller *sci
 		switch (scu_get_event_specifier(completion_entry)) {
 		case SCU_EVENT_SPECIFIC_SMP_RESPONSE_NO_PE:
 		case SCU_EVENT_SPECIFIC_TASK_TIMEOUT:
-			io_request = scic->io_request_table[index];
+			io_request = &ihost->reqs[index]->sci;
 			if (io_request != NULL)
 				scic_sds_io_request_event_handler(io_request, completion_entry);
 			else
@@ -1187,9 +1187,6 @@ static void isci_host_completion_routine(unsigned long data)
 		spin_lock_irq(&isci_host->scic_lock);
 		isci_free_tag(isci_host, request->sci.io_tag);
 		spin_unlock_irq(&isci_host->scic_lock);
-
-		/* Free the request object. */
-		isci_request_free(isci_host, request);
 	}
 	list_for_each_entry_safe(request, next_request, &errored_request_list,
 				 completed_node) {
@@ -1227,9 +1224,6 @@ static void isci_host_completion_routine(unsigned long data)
 			list_del_init(&request->dev_node);
 			isci_free_tag(isci_host, request->sci.io_tag);
 			spin_unlock_irq(&isci_host->scic_lock);
-
-			/* Free the request object. */
-			isci_request_free(isci_host, request);
 		}
 	}
 
@@ -2469,13 +2463,6 @@ int isci_host_init(struct isci_host *isci_host)
 	if (err)
 		return err;
 
-	isci_host->dma_pool = dmam_pool_create(DRV_NAME, &isci_host->pdev->dev,
-					       sizeof(struct isci_request),
-					       SLAB_HWCACHE_ALIGN, 0);
-
-	if (!isci_host->dma_pool)
-		return -ENOMEM;
-
 	for (i = 0; i < SCI_MAX_PORTS; i++)
 		isci_port_init(&isci_host->ports[i], isci_host, i);
 
@@ -2489,6 +2476,25 @@ int isci_host_init(struct isci_host *isci_host)
 		INIT_LIST_HEAD(&idev->node);
 	}
 
+	for (i = 0; i < SCI_MAX_IO_REQUESTS; i++) {
+		struct isci_request *ireq;
+		dma_addr_t dma;
+
+		ireq = dmam_alloc_coherent(&isci_host->pdev->dev,
+					   sizeof(struct isci_request), &dma,
+					   GFP_KERNEL);
+		if (!ireq)
+			return -ENOMEM;
+
+		ireq->sci.tc = &isci_host->sci.task_context_table[i];
+		ireq->sci.owning_controller = &isci_host->sci;
+		spin_lock_init(&ireq->state_lock);
+		ireq->request_daddr = dma;
+		ireq->isci_host = isci_host;
+
+		isci_host->reqs[i] = ireq;
+	}
+
 	return 0;
 }
 
@@ -2602,12 +2608,13 @@ struct scic_sds_request *scic_request_by_tag(struct scic_sds_controller *scic, u
 	task_index = ISCI_TAG_TCI(io_tag);
 
 	if (task_index < scic->task_context_entries) {
-		if (scic->io_request_table[task_index] != NULL) {
+		struct isci_request *ireq = scic_to_ihost(scic)->reqs[task_index];
+
+		if (test_bit(IREQ_ACTIVE, &ireq->flags)) {
 			task_sequence = ISCI_TAG_SEQ(io_tag);
 
-			if (task_sequence == scic->io_request_sequence[task_index]) {
-				return scic->io_request_table[task_index];
-			}
+			if (task_sequence == scic->io_request_sequence[task_index])
+				return &ireq->sci;
 		}
 	}
 
@@ -2820,7 +2827,7 @@ enum sci_status scic_controller_start_io(struct scic_sds_controller *scic,
 	if (status != SCI_SUCCESS)
 		return status;
 
-	scic->io_request_table[ISCI_TAG_TCI(req->io_tag)] = req;
+	set_bit(IREQ_ACTIVE, &sci_req_to_ireq(req)->flags);
 	scic_sds_controller_post_request(scic, scic_sds_request_get_post_context(req));
 	return SCI_SUCCESS;
 }
@@ -2897,7 +2904,7 @@ enum sci_status scic_controller_complete_io(
 			return status;
 
 		index = ISCI_TAG_TCI(request->io_tag);
-		scic->io_request_table[index] = NULL;
+		clear_bit(IREQ_ACTIVE, &sci_req_to_ireq(request)->flags);
 		return SCI_SUCCESS;
 	default:
 		dev_warn(scic_to_dev(scic), "invalid state to complete I/O");
@@ -2915,7 +2922,7 @@ enum sci_status scic_controller_continue_io(struct scic_sds_request *sci_req)
 		return SCI_FAILURE_INVALID_STATE;
 	}
 
-	scic->io_request_table[ISCI_TAG_TCI(sci_req->io_tag)] = sci_req;
+	set_bit(IREQ_ACTIVE, &sci_req_to_ireq(sci_req)->flags);
 	scic_sds_controller_post_request(scic, scic_sds_request_get_post_context(sci_req));
 	return SCI_SUCCESS;
 }
@@ -2934,6 +2941,7 @@ enum sci_task_status scic_controller_start_task(
 	struct scic_sds_remote_device *rdev,
 	struct scic_sds_request *req)
 {
+	struct isci_request *ireq = sci_req_to_ireq(req);
 	enum sci_status status;
 
 	if (scic->sm.current_state_id != SCIC_READY) {
@@ -2947,7 +2955,7 @@ enum sci_task_status scic_controller_start_task(
 	status = scic_sds_remote_device_start_task(scic, rdev, req);
 	switch (status) {
 	case SCI_FAILURE_RESET_DEVICE_PARTIAL_SUCCESS:
-		scic->io_request_table[ISCI_TAG_TCI(req->io_tag)] = req;
+		set_bit(IREQ_ACTIVE, &ireq->flags);
 
 		/*
 		 * We will let framework know this task request started successfully,
@@ -2956,7 +2964,7 @@ enum sci_task_status scic_controller_start_task(
 		 */
 		return SCI_SUCCESS;
 	case SCI_SUCCESS:
-		scic->io_request_table[ISCI_TAG_TCI(req->io_tag)] = req;
+		set_bit(IREQ_ACTIVE, &ireq->flags);
 
 		scic_sds_controller_post_request(scic,
 			scic_sds_request_get_post_context(req));

commit 312e0c2455c18716cf640d4336dcb1e9e5053818
Author: Dan Williams <dan.j.williams@intel.com>
Date:   Tue Jun 28 13:47:09 2011 -0700

    isci: unify can_queue tracking on the tci_pool, uplevel tag assignment
    
    The tci_pool tracks our outstanding command slots which are also the 'index'
    portion of our tags.  Grabbing the tag early in ->lldd_execute_task let's us
    drop the isci_host_can_queue() and ->was_tag_assigned_by_user infrastructure.
    ->was_tag_assigned_by_user required the task context to be duplicated in
    request-local buffer.  With the tci established early we can build the
    task_context directly into its final location and skip a memcpy.
    
    With the task context buffer at a known address at request construction we
    have the opportunity/obligation to also fix sgl handling.  This rework feels
    like it belongs in another patch but the sgl handling and task_context are too
    intertwined.
    1/ fix the 'ab' pair embedded in the task context to point to the 'cd' pair in
       the task context (previously we were prematurely linking to the staging
       buffer).
    2/ fix the broken iteration of pio sgls that assumes all sgls are relative to
       the request, and does a dangerous looking reverse lookup of physical
       address to virtual address.
    
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/drivers/scsi/isci/host.c b/drivers/scsi/isci/host.c
index b08455f0d350..c99fab53dd0c 100644
--- a/drivers/scsi/isci/host.c
+++ b/drivers/scsi/isci/host.c
@@ -1018,33 +1018,11 @@ static void phy_startup_timeout(unsigned long data)
 	spin_unlock_irqrestore(&ihost->scic_lock, flags);
 }
 
-static void isci_tci_free(struct isci_host *ihost, u16 tci)
-{
-	u16 tail = ihost->tci_tail & (SCI_MAX_IO_REQUESTS-1);
-
-	ihost->tci_pool[tail] = tci;
-	ihost->tci_tail = tail + 1;
-}
-
-static u16 isci_tci_alloc(struct isci_host *ihost)
-{
-	u16 head = ihost->tci_head & (SCI_MAX_IO_REQUESTS-1);
-	u16 tci = ihost->tci_pool[head];
-
-	ihost->tci_head = head + 1;
-	return tci;
-}
-
 static u16 isci_tci_active(struct isci_host *ihost)
 {
 	return CIRC_CNT(ihost->tci_head, ihost->tci_tail, SCI_MAX_IO_REQUESTS);
 }
 
-static u16 isci_tci_space(struct isci_host *ihost)
-{
-	return CIRC_SPACE(ihost->tci_head, ihost->tci_tail, SCI_MAX_IO_REQUESTS);
-}
-
 static enum sci_status scic_controller_start(struct scic_sds_controller *scic,
 					     u32 timeout)
 {
@@ -1205,6 +1183,11 @@ static void isci_host_completion_routine(unsigned long data)
 				task->task_done(task);
 			}
 		}
+
+		spin_lock_irq(&isci_host->scic_lock);
+		isci_free_tag(isci_host, request->sci.io_tag);
+		spin_unlock_irq(&isci_host->scic_lock);
+
 		/* Free the request object. */
 		isci_request_free(isci_host, request);
 	}
@@ -1242,6 +1225,7 @@ static void isci_host_completion_routine(unsigned long data)
 			* of pending requests.
 			*/
 			list_del_init(&request->dev_node);
+			isci_free_tag(isci_host, request->sci.io_tag);
 			spin_unlock_irq(&isci_host->scic_lock);
 
 			/* Free the request object. */
@@ -2375,6 +2359,7 @@ static int scic_controller_mem_init(struct scic_sds_controller *scic)
 	if (!scic->task_context_table)
 		return -ENOMEM;
 
+	scic->task_context_dma = dma;
 	writel(lower_32_bits(dma), &scic->smu_registers->host_task_table_lower);
 	writel(upper_32_bits(dma), &scic->smu_registers->host_task_table_upper);
 
@@ -2409,11 +2394,9 @@ int isci_host_init(struct isci_host *isci_host)
 
 	spin_lock_init(&isci_host->state_lock);
 	spin_lock_init(&isci_host->scic_lock);
-	spin_lock_init(&isci_host->queue_lock);
 	init_waitqueue_head(&isci_host->eventq);
 
 	isci_host_change_state(isci_host, isci_starting);
-	isci_host->can_queue = ISCI_CAN_QUEUE_VAL;
 
 	status = scic_controller_construct(&isci_host->sci, scu_base(isci_host),
 					   smu_base(isci_host));
@@ -2611,51 +2594,6 @@ void scic_sds_controller_post_request(
 	writel(request, &scic->smu_registers->post_context_port);
 }
 
-/**
- * This method will copy the soft copy of the task context into the physical
- *    memory accessible by the controller.
- * @scic: This parameter specifies the controller for which to copy
- *    the task context.
- * @sci_req: This parameter specifies the request for which the task
- *    context is being copied.
- *
- * After this call is made the SCIC_SDS_IO_REQUEST object will always point to
- * the physical memory version of the task context. Thus, all subsequent
- * updates to the task context are performed in the TC table (i.e. DMAable
- * memory). none
- */
-void scic_sds_controller_copy_task_context(
-	struct scic_sds_controller *scic,
-	struct scic_sds_request *sci_req)
-{
-	struct scu_task_context *task_context_buffer;
-
-	task_context_buffer = scic_sds_controller_get_task_context_buffer(
-		scic, sci_req->io_tag);
-
-	memcpy(task_context_buffer,
-	       sci_req->task_context_buffer,
-	       offsetof(struct scu_task_context, sgl_snapshot_ac));
-
-	/*
-	 * Now that the soft copy of the TC has been copied into the TC
-	 * table accessible by the silicon.  Thus, any further changes to
-	 * the TC (e.g. TC termination) occur in the appropriate location. */
-	sci_req->task_context_buffer = task_context_buffer;
-}
-
-struct scu_task_context *scic_sds_controller_get_task_context_buffer(struct scic_sds_controller *scic,
-								     u16 io_tag)
-{
-	u16 tci = ISCI_TAG_TCI(io_tag);
-
-	if (tci < scic->task_context_entries) {
-		return &scic->task_context_table[tci];
-	}
-
-	return NULL;
-}
-
 struct scic_sds_request *scic_request_by_tag(struct scic_sds_controller *scic, u16 io_tag)
 {
 	u16 task_index;
@@ -2801,6 +2739,60 @@ void scic_sds_controller_release_frame(
 			&scic->scu_registers->sdma.unsolicited_frame_get_pointer);
 }
 
+void isci_tci_free(struct isci_host *ihost, u16 tci)
+{
+	u16 tail = ihost->tci_tail & (SCI_MAX_IO_REQUESTS-1);
+
+	ihost->tci_pool[tail] = tci;
+	ihost->tci_tail = tail + 1;
+}
+
+static u16 isci_tci_alloc(struct isci_host *ihost)
+{
+	u16 head = ihost->tci_head & (SCI_MAX_IO_REQUESTS-1);
+	u16 tci = ihost->tci_pool[head];
+
+	ihost->tci_head = head + 1;
+	return tci;
+}
+
+static u16 isci_tci_space(struct isci_host *ihost)
+{
+	return CIRC_SPACE(ihost->tci_head, ihost->tci_tail, SCI_MAX_IO_REQUESTS);
+}
+
+u16 isci_alloc_tag(struct isci_host *ihost)
+{
+	if (isci_tci_space(ihost)) {
+		u16 tci = isci_tci_alloc(ihost);
+		u8 seq = ihost->sci.io_request_sequence[tci];
+
+		return ISCI_TAG(seq, tci);
+	}
+
+	return SCI_CONTROLLER_INVALID_IO_TAG;
+}
+
+enum sci_status isci_free_tag(struct isci_host *ihost, u16 io_tag)
+{
+	struct scic_sds_controller *scic = &ihost->sci;
+	u16 tci = ISCI_TAG_TCI(io_tag);
+	u16 seq = ISCI_TAG_SEQ(io_tag);
+
+	/* prevent tail from passing head */
+	if (isci_tci_active(ihost) == 0)
+		return SCI_FAILURE_INVALID_IO_TAG;
+
+	if (seq == scic->io_request_sequence[tci]) {
+		scic->io_request_sequence[tci] = (seq+1) & (SCI_MAX_SEQ-1);
+
+		isci_tci_free(ihost, tci);
+
+		return SCI_SUCCESS;
+	}
+	return SCI_FAILURE_INVALID_IO_TAG;
+}
+
 /**
  * scic_controller_start_io() - This method is called by the SCI user to
  *    send/start an IO request. If the method invocation is successful, then
@@ -2811,27 +2803,11 @@ void scic_sds_controller_release_frame(
  *    IO request.
  * @io_request: the handle to the io request object to start.
  * @io_tag: This parameter specifies a previously allocated IO tag that the
- *    user desires to be utilized for this request. This parameter is optional.
- *     The user is allowed to supply SCI_CONTROLLER_INVALID_IO_TAG as the value
- *    for this parameter.
- *
- * - IO tags are a protected resource.  It is incumbent upon the SCI Core user
- * to ensure that each of the methods that may allocate or free available IO
- * tags are handled in a mutually exclusive manner.  This method is one of said
- * methods requiring proper critical code section protection (e.g. semaphore,
- * spin-lock, etc.). - For SATA, the user is required to manage NCQ tags.  As a
- * result, it is expected the user will have set the NCQ tag field in the host
- * to device register FIS prior to calling this method.  There is also a
- * requirement for the user to call scic_stp_io_set_ncq_tag() prior to invoking
- * the scic_controller_start_io() method. scic_controller_allocate_tag() for
- * more information on allocating a tag. Indicate if the controller
- * successfully started the IO request. SCI_SUCCESS if the IO request was
- * successfully started. Determine the failure situations and return values.
+ *    user desires to be utilized for this request.
  */
 enum sci_status scic_controller_start_io(struct scic_sds_controller *scic,
 					 struct scic_sds_remote_device *rdev,
-					 struct scic_sds_request *req,
-					 u16 io_tag)
+					 struct scic_sds_request *req)
 {
 	enum sci_status status;
 
@@ -2902,17 +2878,6 @@ enum sci_status scic_controller_terminate_request(
  * @remote_device: The handle to the remote device object for which to complete
  *    the IO request.
  * @io_request: the handle to the io request object to complete.
- *
- * - IO tags are a protected resource.  It is incumbent upon the SCI Core user
- * to ensure that each of the methods that may allocate or free available IO
- * tags are handled in a mutually exclusive manner.  This method is one of said
- * methods requiring proper critical code section protection (e.g. semaphore,
- * spin-lock, etc.). - If the IO tag for a request was allocated, by the SCI
- * Core user, using the scic_controller_allocate_io_tag() method, then it is
- * the responsibility of the caller to invoke the scic_controller_free_io_tag()
- * method to free the tag (i.e. this method will not free the IO tag). Indicate
- * if the controller successfully completed the IO request. SCI_SUCCESS if the
- * completion process was successful.
  */
 enum sci_status scic_controller_complete_io(
 	struct scic_sds_controller *scic,
@@ -2963,31 +2928,11 @@ enum sci_status scic_controller_continue_io(struct scic_sds_request *sci_req)
  * @remote_device: the handle to the remote device object for which to start
  *    the task management request.
  * @task_request: the handle to the task request object to start.
- * @io_tag: This parameter specifies a previously allocated IO tag that the
- *    user desires to be utilized for this request.  Note this not the io_tag
- *    of the request being managed.  It is to be utilized for the task request
- *    itself. This parameter is optional.  The user is allowed to supply
- *    SCI_CONTROLLER_INVALID_IO_TAG as the value for this parameter.
- *
- * - IO tags are a protected resource.  It is incumbent upon the SCI Core user
- * to ensure that each of the methods that may allocate or free available IO
- * tags are handled in a mutually exclusive manner.  This method is one of said
- * methods requiring proper critical code section protection (e.g. semaphore,
- * spin-lock, etc.). - The user must synchronize this task with completion
- * queue processing.  If they are not synchronized then it is possible for the
- * io requests that are being managed by the task request can complete before
- * starting the task request. scic_controller_allocate_tag() for more
- * information on allocating a tag. Indicate if the controller successfully
- * started the IO request. SCI_TASK_SUCCESS if the task request was
- * successfully started. SCI_TASK_FAILURE_REQUIRES_SCSI_ABORT This value is
- * returned if there is/are task(s) outstanding that require termination or
- * completion before this request can succeed.
  */
 enum sci_task_status scic_controller_start_task(
 	struct scic_sds_controller *scic,
 	struct scic_sds_remote_device *rdev,
-	struct scic_sds_request *req,
-	u16 task_tag)
+	struct scic_sds_request *req)
 {
 	enum sci_status status;
 
@@ -3022,85 +2967,3 @@ enum sci_task_status scic_controller_start_task(
 
 	return status;
 }
-
-/**
- * scic_controller_allocate_io_tag() - This method will allocate a tag from the
- *    pool of free IO tags. Direct allocation of IO tags by the SCI Core user
- *    is optional. The scic_controller_start_io() method will allocate an IO
- *    tag if this method is not utilized and the tag is not supplied to the IO
- *    construct routine.  Direct allocation of IO tags may provide additional
- *    performance improvements in environments capable of supporting this usage
- *    model.  Additionally, direct allocation of IO tags also provides
- *    additional flexibility to the SCI Core user.  Specifically, the user may
- *    retain IO tags across the lives of multiple IO requests.
- * @controller: the handle to the controller object for which to allocate the
- *    tag.
- *
- * IO tags are a protected resource.  It is incumbent upon the SCI Core user to
- * ensure that each of the methods that may allocate or free available IO tags
- * are handled in a mutually exclusive manner.  This method is one of said
- * methods requiring proper critical code section protection (e.g. semaphore,
- * spin-lock, etc.). An unsigned integer representing an available IO tag.
- * SCI_CONTROLLER_INVALID_IO_TAG This value is returned if there are no
- * currently available tags to be allocated. All return other values indicate a
- * legitimate tag.
- */
-u16 scic_controller_allocate_io_tag(struct scic_sds_controller *scic)
-{
-	struct isci_host *ihost = scic_to_ihost(scic);
-
-	if (isci_tci_space(ihost)) {
-		u16 tci = isci_tci_alloc(ihost);
-		u8 seq = scic->io_request_sequence[tci];
-
-		return ISCI_TAG(seq, tci);
-	}
-
-	return SCI_CONTROLLER_INVALID_IO_TAG;
-}
-
-/**
- * scic_controller_free_io_tag() - This method will free an IO tag to the pool
- *    of free IO tags. This method provides the SCI Core user more flexibility
- *    with regards to IO tags.  The user may desire to keep an IO tag after an
- *    IO request has completed, because they plan on re-using the tag for a
- *    subsequent IO request.  This method is only legal if the tag was
- *    allocated via scic_controller_allocate_io_tag().
- * @controller: This parameter specifies the handle to the controller object
- *    for which to free/return the tag.
- * @io_tag: This parameter represents the tag to be freed to the pool of
- *    available tags.
- *
- * - IO tags are a protected resource.  It is incumbent upon the SCI Core user
- * to ensure that each of the methods that may allocate or free available IO
- * tags are handled in a mutually exclusive manner.  This method is one of said
- * methods requiring proper critical code section protection (e.g. semaphore,
- * spin-lock, etc.). - If the IO tag for a request was allocated, by the SCI
- * Core user, using the scic_controller_allocate_io_tag() method, then it is
- * the responsibility of the caller to invoke this method to free the tag. This
- * method returns an indication of whether the tag was successfully put back
- * (freed) to the pool of available tags. SCI_SUCCESS This return value
- * indicates the tag was successfully placed into the pool of available IO
- * tags. SCI_FAILURE_INVALID_IO_TAG This value is returned if the supplied tag
- * is not a valid IO tag value.
- */
-enum sci_status scic_controller_free_io_tag(struct scic_sds_controller *scic,
-					    u16 io_tag)
-{
-	struct isci_host *ihost = scic_to_ihost(scic);
-	u16 tci = ISCI_TAG_TCI(io_tag);
-	u16 seq = ISCI_TAG_SEQ(io_tag);
-
-	/* prevent tail from passing head */
-	if (isci_tci_active(ihost) == 0)
-		return SCI_FAILURE_INVALID_IO_TAG;
-
-	if (seq == scic->io_request_sequence[tci]) {
-		scic->io_request_sequence[tci] = (seq+1) & (SCI_MAX_SEQ-1);
-
-		isci_tci_free(ihost, ISCI_TAG_TCI(io_tag));
-
-		return SCI_SUCCESS;
-	}
-	return SCI_FAILURE_INVALID_IO_TAG;
-}

commit f2088267514b39af1a94409168101527769a911c
Author: Dan Williams <dan.j.williams@intel.com>
Date:   Thu Jun 16 11:26:12 2011 -0700

    isci: kill isci_remote_device_change_state()
    
    Now that "stopping/stopped" are one in the same and signalled by a NULL device
    pointer the rest of the device status infrastructure can be removed (->status
    and ->state_lock).  The "not ready for i/o state" is replaced with a state
    flag, and is evaluated under scic_lock so that we don't see transients from
    taking the device reference to submitting the i/o.
    
    This also fixes a potential leakage of can_queue slots in the rare case that
    SAS_TASK_ABORTED is set at submission.
    
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/drivers/scsi/isci/host.c b/drivers/scsi/isci/host.c
index 40f35fad244b..b08455f0d350 100644
--- a/drivers/scsi/isci/host.c
+++ b/drivers/scsi/isci/host.c
@@ -2504,7 +2504,6 @@ int isci_host_init(struct isci_host *isci_host)
 
 		INIT_LIST_HEAD(&idev->reqs_in_process);
 		INIT_LIST_HEAD(&idev->node);
-		spin_lock_init(&idev->state_lock);
 	}
 
 	return 0;

commit 209fae14fabfd48525e5630bebbbd4ca15090c60
Author: Dan Williams <dan.j.williams@intel.com>
Date:   Mon Jun 13 17:39:44 2011 -0700

    isci: atomic device lookup and reference counting
    
    We have unsafe references to remote devices that are notified to
    disappear at lldd_dev_gone.  In order to clean this up we need a single
    canonical source for device lookups and stable references once a lookup
    succeeds.  Towards that end guarantee that domain_device.lldd_dev is
    NULL as soon as we start the process of stopping a device.  Any code
    path that wants to safely lookup a remote device must do so through
    task->dev->lldd_dev (isci_lookup_device()).
    
    For in-flight references outside of scic_lock we need reference counting
    to ensure that the device is not recycled before we are done with it.
    Simplify device back references to just scic_sds_request.target_device
    which is now the only permissible internal reference that is maintained
    relative to the reference count.
    
    There were two occasions where we wanted new i/o's to be treated as
    SAS_TASK_UNDELIVERED but where the domain_dev->lldd_dev link is still
    intact.  Introduce a 'gone' flag to prevent i/o while waiting for libsas
    to take action on the port down event.
    
    One 'core' leftover is that we currently call
    scic_remote_device_destruct() from isci_remote_device_deconstruct()
    which is called when the 'core' says the device is stopped.  It would be
    more natural for the final put to trigger
    isci_remote_device_deconstruct() but this implementation is deferred as
    it requires other changes.
    
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/drivers/scsi/isci/host.c b/drivers/scsi/isci/host.c
index ae9edae1d245..40f35fad244b 100644
--- a/drivers/scsi/isci/host.c
+++ b/drivers/scsi/isci/host.c
@@ -1327,8 +1327,8 @@ void isci_host_deinit(struct isci_host *ihost)
 		struct isci_remote_device *idev, *d;
 
 		list_for_each_entry_safe(idev, d, &iport->remote_dev_list, node) {
-			isci_remote_device_change_state(idev, isci_stopping);
-			isci_remote_device_stop(ihost, idev);
+			if (test_bit(IDEV_ALLOCATED, &idev->flags))
+				isci_remote_device_stop(ihost, idev);
 		}
 	}
 

commit 994a9303d33f8238d57f58c26067b6d4ac9af222
Author: Dan Williams <dan.j.williams@intel.com>
Date:   Thu Jun 9 16:04:28 2011 -0700

    isci: cleanup/optimize queue increment macros
    
    Every single i/o or event completion incurs a test and branch to see if
    the cycle bit changed.  For power-of-2 queue sizes the cycle bit can be
    read directly from the rollover of the queue pointer.
    
    Likely premature optimization, but the hidden if() and hidden
    assignments / side-effects in the macros were already asking to be
    cleaned up.
    
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/drivers/scsi/isci/host.c b/drivers/scsi/isci/host.c
index 3c7042b8bc0e..ae9edae1d245 100644
--- a/drivers/scsi/isci/host.c
+++ b/drivers/scsi/isci/host.c
@@ -122,34 +122,6 @@
 		>> SMU_COMPLETION_QUEUE_GET_EVENT_POINTER_SHIFT	\
 	)
 
-/**
- * INCREMENT_COMPLETION_QUEUE_GET() -
- *
- * This macro will increment the controllers completion queue index value and
- * possibly toggle the cycle bit if the completion queue index wraps back to 0.
- */
-#define INCREMENT_COMPLETION_QUEUE_GET(controller, index, cycle) \
-	INCREMENT_QUEUE_GET(\
-		(index), \
-		(cycle), \
-		SCU_MAX_COMPLETION_QUEUE_ENTRIES, \
-		SMU_CQGR_CYCLE_BIT)
-
-/**
- * INCREMENT_EVENT_QUEUE_GET() -
- *
- * This macro will increment the controllers event queue index value and
- * possibly toggle the event cycle bit if the event queue index wraps back to 0.
- */
-#define INCREMENT_EVENT_QUEUE_GET(controller, index, cycle) \
-	INCREMENT_QUEUE_GET(\
-		(index), \
-		(cycle), \
-		SCU_MAX_EVENTS, \
-		SMU_CQGR_EVENT_CYCLE_BIT \
-		)
-
-
 /**
  * NORMALIZE_GET_POINTER() -
  *
@@ -528,15 +500,13 @@ static void scic_sds_controller_event_completion(struct scic_sds_controller *sci
 	}
 }
 
-
-
 static void scic_sds_controller_process_completions(struct scic_sds_controller *scic)
 {
 	u32 completion_count = 0;
 	u32 completion_entry;
 	u32 get_index;
 	u32 get_cycle;
-	u32 event_index;
+	u32 event_get;
 	u32 event_cycle;
 
 	dev_dbg(scic_to_dev(scic),
@@ -548,7 +518,7 @@ static void scic_sds_controller_process_completions(struct scic_sds_controller *
 	get_index = NORMALIZE_GET_POINTER(scic->completion_queue_get);
 	get_cycle = SMU_CQGR_CYCLE_BIT & scic->completion_queue_get;
 
-	event_index = NORMALIZE_EVENT_POINTER(scic->completion_queue_get);
+	event_get = NORMALIZE_EVENT_POINTER(scic->completion_queue_get);
 	event_cycle = SMU_CQGR_EVENT_CYCLE_BIT & scic->completion_queue_get;
 
 	while (
@@ -558,7 +528,11 @@ static void scic_sds_controller_process_completions(struct scic_sds_controller *
 		completion_count++;
 
 		completion_entry = scic->completion_queue[get_index];
-		INCREMENT_COMPLETION_QUEUE_GET(scic, get_index, get_cycle);
+
+		/* increment the get pointer and check for rollover to toggle the cycle bit */
+		get_cycle ^= ((get_index+1) & SCU_MAX_COMPLETION_QUEUE_ENTRIES) <<
+			     (SMU_COMPLETION_QUEUE_GET_CYCLE_BIT_SHIFT - SCU_MAX_COMPLETION_QUEUE_SHIFT);
+		get_index = (get_index+1) & (SCU_MAX_COMPLETION_QUEUE_ENTRIES-1);
 
 		dev_dbg(scic_to_dev(scic),
 			"%s: completion queue entry:0x%08x\n",
@@ -579,18 +553,14 @@ static void scic_sds_controller_process_completions(struct scic_sds_controller *
 			break;
 
 		case SCU_COMPLETION_TYPE_EVENT:
-			INCREMENT_EVENT_QUEUE_GET(scic, event_index, event_cycle);
-			scic_sds_controller_event_completion(scic, completion_entry);
-			break;
+		case SCU_COMPLETION_TYPE_NOTIFY: {
+			event_cycle ^= ((event_get+1) & SCU_MAX_EVENTS) <<
+				       (SMU_COMPLETION_QUEUE_GET_EVENT_CYCLE_BIT_SHIFT - SCU_MAX_EVENTS_SHIFT);
+			event_get = (event_get+1) & (SCU_MAX_EVENTS-1);
 
-		case SCU_COMPLETION_TYPE_NOTIFY:
-			/*
-			 * Presently we do the same thing with a notify event that we do with the
-			 * other event codes. */
-			INCREMENT_EVENT_QUEUE_GET(scic, event_index, event_cycle);
 			scic_sds_controller_event_completion(scic, completion_entry);
 			break;
-
+		}
 		default:
 			dev_warn(scic_to_dev(scic),
 				 "%s: SCIC Controller received unknown "
@@ -607,7 +577,7 @@ static void scic_sds_controller_process_completions(struct scic_sds_controller *
 			SMU_CQGR_GEN_BIT(ENABLE) |
 			SMU_CQGR_GEN_BIT(EVENT_ENABLE) |
 			event_cycle |
-			SMU_CQGR_GEN_VAL(EVENT_POINTER, event_index) |
+			SMU_CQGR_GEN_VAL(EVENT_POINTER, event_get) |
 			get_cycle |
 			SMU_CQGR_GEN_VAL(POINTER, get_index);
 

commit dd047c8e2bca22856050dbe0378a37cf44eecc97
Author: Dan Williams <dan.j.williams@intel.com>
Date:   Thu Jun 9 11:06:58 2011 -0700

    isci: cleanup tag macros
    
    A tag is a 16 bit number where the upper four bits is a sequence number
    and the remainder is the task context index (tci).  Sanitize the macro
    names and shave 256-bytes out of scic_sds_controller by reducing the size of
    io_request_sequence.
    
    scic_sds_io_tag_construct --> ISCI_TAG
    scic_sds_io_tag_get_sequence --> ISCI_TAG_SEQ
    scic_sds_io_tag_get_index() --> ISCI_TAG_TCI
    scic_sds_io_sequence_increment() [delete / open code]
    
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/drivers/scsi/isci/host.c b/drivers/scsi/isci/host.c
index 343655bd1a6a..3c7042b8bc0e 100644
--- a/drivers/scsi/isci/host.c
+++ b/drivers/scsi/isci/host.c
@@ -284,23 +284,16 @@ static void scic_sds_controller_task_completion(struct scic_sds_controller *scic
 						u32 completion_entry)
 {
 	u32 index;
-	struct scic_sds_request *io_request;
+	struct scic_sds_request *sci_req;
 
 	index = SCU_GET_COMPLETION_INDEX(completion_entry);
-	io_request = scic->io_request_table[index];
+	sci_req = scic->io_request_table[index];
 
 	/* Make sure that we really want to process this IO request */
-	if (
-		(io_request != NULL)
-		&& (io_request->io_tag != SCI_CONTROLLER_INVALID_IO_TAG)
-		&& (
-			scic_sds_io_tag_get_sequence(io_request->io_tag)
-			== scic->io_request_sequence[index]
-			)
-		) {
+	if (sci_req && sci_req->io_tag != SCI_CONTROLLER_INVALID_IO_TAG &&
+	    ISCI_TAG_SEQ(sci_req->io_tag) == scic->io_request_sequence[index])
 		/* Yep this is a valid io request pass it along to the io request handler */
-		scic_sds_io_request_tc_completion(io_request, completion_entry);
-	}
+		scic_sds_io_request_tc_completion(sci_req, completion_entry);
 }
 
 static void scic_sds_controller_sdma_completion(struct scic_sds_controller *scic,
@@ -2682,37 +2675,28 @@ void scic_sds_controller_copy_task_context(
 	sci_req->task_context_buffer = task_context_buffer;
 }
 
-/**
- * This method returns the task context buffer for the given io tag.
- * @scic:
- * @io_tag:
- *
- * struct scu_task_context*
- */
-struct scu_task_context *scic_sds_controller_get_task_context_buffer(
-	struct scic_sds_controller *scic,
-	u16 io_tag
-	) {
-	u16 task_index = scic_sds_io_tag_get_index(io_tag);
+struct scu_task_context *scic_sds_controller_get_task_context_buffer(struct scic_sds_controller *scic,
+								     u16 io_tag)
+{
+	u16 tci = ISCI_TAG_TCI(io_tag);
 
-	if (task_index < scic->task_context_entries) {
-		return &scic->task_context_table[task_index];
+	if (tci < scic->task_context_entries) {
+		return &scic->task_context_table[tci];
 	}
 
 	return NULL;
 }
 
-struct scic_sds_request *scic_request_by_tag(struct scic_sds_controller *scic,
-					     u16 io_tag)
+struct scic_sds_request *scic_request_by_tag(struct scic_sds_controller *scic, u16 io_tag)
 {
 	u16 task_index;
 	u16 task_sequence;
 
-	task_index = scic_sds_io_tag_get_index(io_tag);
+	task_index = ISCI_TAG_TCI(io_tag);
 
-	if (task_index  < scic->task_context_entries) {
+	if (task_index < scic->task_context_entries) {
 		if (scic->io_request_table[task_index] != NULL) {
-			task_sequence = scic_sds_io_tag_get_sequence(io_tag);
+			task_sequence = ISCI_TAG_SEQ(io_tag);
 
 			if (task_sequence == scic->io_request_sequence[task_index]) {
 				return scic->io_request_table[task_index];
@@ -2875,11 +2859,10 @@ void scic_sds_controller_release_frame(
  * successfully started the IO request. SCI_SUCCESS if the IO request was
  * successfully started. Determine the failure situations and return values.
  */
-enum sci_status scic_controller_start_io(
-	struct scic_sds_controller *scic,
-	struct scic_sds_remote_device *rdev,
-	struct scic_sds_request *req,
-	u16 io_tag)
+enum sci_status scic_controller_start_io(struct scic_sds_controller *scic,
+					 struct scic_sds_remote_device *rdev,
+					 struct scic_sds_request *req,
+					 u16 io_tag)
 {
 	enum sci_status status;
 
@@ -2892,7 +2875,7 @@ enum sci_status scic_controller_start_io(
 	if (status != SCI_SUCCESS)
 		return status;
 
-	scic->io_request_table[scic_sds_io_tag_get_index(req->io_tag)] = req;
+	scic->io_request_table[ISCI_TAG_TCI(req->io_tag)] = req;
 	scic_sds_controller_post_request(scic, scic_sds_request_get_post_context(req));
 	return SCI_SUCCESS;
 }
@@ -2979,7 +2962,7 @@ enum sci_status scic_controller_complete_io(
 		if (status != SCI_SUCCESS)
 			return status;
 
-		index = scic_sds_io_tag_get_index(request->io_tag);
+		index = ISCI_TAG_TCI(request->io_tag);
 		scic->io_request_table[index] = NULL;
 		return SCI_SUCCESS;
 	default:
@@ -2998,7 +2981,7 @@ enum sci_status scic_controller_continue_io(struct scic_sds_request *sci_req)
 		return SCI_FAILURE_INVALID_STATE;
 	}
 
-	scic->io_request_table[scic_sds_io_tag_get_index(sci_req->io_tag)] = sci_req;
+	scic->io_request_table[ISCI_TAG_TCI(sci_req->io_tag)] = sci_req;
 	scic_sds_controller_post_request(scic, scic_sds_request_get_post_context(sci_req));
 	return SCI_SUCCESS;
 }
@@ -3050,7 +3033,7 @@ enum sci_task_status scic_controller_start_task(
 	status = scic_sds_remote_device_start_task(scic, rdev, req);
 	switch (status) {
 	case SCI_FAILURE_RESET_DEVICE_PARTIAL_SUCCESS:
-		scic->io_request_table[scic_sds_io_tag_get_index(req->io_tag)] = req;
+		scic->io_request_table[ISCI_TAG_TCI(req->io_tag)] = req;
 
 		/*
 		 * We will let framework know this task request started successfully,
@@ -3059,7 +3042,7 @@ enum sci_task_status scic_controller_start_task(
 		 */
 		return SCI_SUCCESS;
 	case SCI_SUCCESS:
-		scic->io_request_table[scic_sds_io_tag_get_index(req->io_tag)] = req;
+		scic->io_request_table[ISCI_TAG_TCI(req->io_tag)] = req;
 
 		scic_sds_controller_post_request(scic,
 			scic_sds_request_get_post_context(req));
@@ -3096,14 +3079,12 @@ enum sci_task_status scic_controller_start_task(
 u16 scic_controller_allocate_io_tag(struct scic_sds_controller *scic)
 {
 	struct isci_host *ihost = scic_to_ihost(scic);
-	u16 tci;
-	u16 seq;
 
 	if (isci_tci_space(ihost)) {
-		tci = isci_tci_alloc(ihost);
-		seq = scic->io_request_sequence[tci];
+		u16 tci = isci_tci_alloc(ihost);
+		u8 seq = scic->io_request_sequence[tci];
 
-		return scic_sds_io_tag_construct(seq, tci);
+		return ISCI_TAG(seq, tci);
 	}
 
 	return SCI_CONTROLLER_INVALID_IO_TAG;
@@ -3138,22 +3119,17 @@ enum sci_status scic_controller_free_io_tag(struct scic_sds_controller *scic,
 					    u16 io_tag)
 {
 	struct isci_host *ihost = scic_to_ihost(scic);
-	u16 sequence;
-	u16 index;
-
-	BUG_ON(io_tag == SCI_CONTROLLER_INVALID_IO_TAG);
-
-	sequence = scic_sds_io_tag_get_sequence(io_tag);
-	index    = scic_sds_io_tag_get_index(io_tag);
+	u16 tci = ISCI_TAG_TCI(io_tag);
+	u16 seq = ISCI_TAG_SEQ(io_tag);
 
 	/* prevent tail from passing head */
 	if (isci_tci_active(ihost) == 0)
 		return SCI_FAILURE_INVALID_IO_TAG;
 
-	if (sequence == scic->io_request_sequence[index]) {
-		scic_sds_io_sequence_increment(scic->io_request_sequence[index]);
+	if (seq == scic->io_request_sequence[tci]) {
+		scic->io_request_sequence[tci] = (seq+1) & (SCI_MAX_SEQ-1);
 
-		isci_tci_free(ihost, index);
+		isci_tci_free(ihost, ISCI_TAG_TCI(io_tag));
 
 		return SCI_SUCCESS;
 	}

commit ac668c69709c7d927015c5cf3d9e87bf4eaaf57d
Author: Dan Williams <dan.j.williams@intel.com>
Date:   Tue Jun 7 18:50:55 2011 -0700

    isci: cleanup/optimize pool implementation
    
    The circ_buf macros are ~6% faster, as measured by perf, because they take
    advantage of power-of-two math assumptions i.e. no test and branch for
    rollover. Their semantics are clearer than the hidden side effects in pool.h
    (like sci_pool_get() which hides an assignment).
    
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/drivers/scsi/isci/host.c b/drivers/scsi/isci/host.c
index 41a7c5099dea..343655bd1a6a 100644
--- a/drivers/scsi/isci/host.c
+++ b/drivers/scsi/isci/host.c
@@ -52,6 +52,7 @@
  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
+#include <linux/circ_buf.h>
 #include <linux/device.h>
 #include <scsi/sas.h>
 #include "host.h"
@@ -1054,6 +1055,33 @@ static void phy_startup_timeout(unsigned long data)
 	spin_unlock_irqrestore(&ihost->scic_lock, flags);
 }
 
+static void isci_tci_free(struct isci_host *ihost, u16 tci)
+{
+	u16 tail = ihost->tci_tail & (SCI_MAX_IO_REQUESTS-1);
+
+	ihost->tci_pool[tail] = tci;
+	ihost->tci_tail = tail + 1;
+}
+
+static u16 isci_tci_alloc(struct isci_host *ihost)
+{
+	u16 head = ihost->tci_head & (SCI_MAX_IO_REQUESTS-1);
+	u16 tci = ihost->tci_pool[head];
+
+	ihost->tci_head = head + 1;
+	return tci;
+}
+
+static u16 isci_tci_active(struct isci_host *ihost)
+{
+	return CIRC_CNT(ihost->tci_head, ihost->tci_tail, SCI_MAX_IO_REQUESTS);
+}
+
+static u16 isci_tci_space(struct isci_host *ihost)
+{
+	return CIRC_SPACE(ihost->tci_head, ihost->tci_tail, SCI_MAX_IO_REQUESTS);
+}
+
 static enum sci_status scic_controller_start(struct scic_sds_controller *scic,
 					     u32 timeout)
 {
@@ -1069,9 +1097,11 @@ static enum sci_status scic_controller_start(struct scic_sds_controller *scic,
 	}
 
 	/* Build the TCi free pool */
-	sci_pool_initialize(scic->tci_pool);
+	BUILD_BUG_ON(SCI_MAX_IO_REQUESTS > 1 << sizeof(ihost->tci_pool[0]) * 8);
+	ihost->tci_head = 0;
+	ihost->tci_tail = 0;
 	for (index = 0; index < scic->task_context_entries; index++)
-		sci_pool_put(scic->tci_pool, index);
+		isci_tci_free(ihost, index);
 
 	/* Build the RNi free pool */
 	scic_sds_remote_node_table_initialize(
@@ -3063,18 +3093,17 @@ enum sci_task_status scic_controller_start_task(
  * currently available tags to be allocated. All return other values indicate a
  * legitimate tag.
  */
-u16 scic_controller_allocate_io_tag(
-	struct scic_sds_controller *scic)
+u16 scic_controller_allocate_io_tag(struct scic_sds_controller *scic)
 {
-	u16 task_context;
-	u16 sequence_count;
-
-	if (!sci_pool_empty(scic->tci_pool)) {
-		sci_pool_get(scic->tci_pool, task_context);
+	struct isci_host *ihost = scic_to_ihost(scic);
+	u16 tci;
+	u16 seq;
 
-		sequence_count = scic->io_request_sequence[task_context];
+	if (isci_tci_space(ihost)) {
+		tci = isci_tci_alloc(ihost);
+		seq = scic->io_request_sequence[tci];
 
-		return scic_sds_io_tag_construct(sequence_count, task_context);
+		return scic_sds_io_tag_construct(seq, tci);
 	}
 
 	return SCI_CONTROLLER_INVALID_IO_TAG;
@@ -3105,10 +3134,10 @@ u16 scic_controller_allocate_io_tag(
  * tags. SCI_FAILURE_INVALID_IO_TAG This value is returned if the supplied tag
  * is not a valid IO tag value.
  */
-enum sci_status scic_controller_free_io_tag(
-	struct scic_sds_controller *scic,
-	u16 io_tag)
+enum sci_status scic_controller_free_io_tag(struct scic_sds_controller *scic,
+					    u16 io_tag)
 {
+	struct isci_host *ihost = scic_to_ihost(scic);
 	u16 sequence;
 	u16 index;
 
@@ -3117,18 +3146,16 @@ enum sci_status scic_controller_free_io_tag(
 	sequence = scic_sds_io_tag_get_sequence(io_tag);
 	index    = scic_sds_io_tag_get_index(io_tag);
 
-	if (!sci_pool_full(scic->tci_pool)) {
-		if (sequence == scic->io_request_sequence[index]) {
-			scic_sds_io_sequence_increment(
-				scic->io_request_sequence[index]);
+	/* prevent tail from passing head */
+	if (isci_tci_active(ihost) == 0)
+		return SCI_FAILURE_INVALID_IO_TAG;
 
-			sci_pool_put(scic->tci_pool, index);
+	if (sequence == scic->io_request_sequence[index]) {
+		scic_sds_io_sequence_increment(scic->io_request_sequence[index]);
 
-			return SCI_SUCCESS;
-		}
-	}
+		isci_tci_free(ihost, index);
 
+		return SCI_SUCCESS;
+	}
 	return SCI_FAILURE_INVALID_IO_TAG;
 }
-
-

commit 7c78da3175177c905a75c54b5830029c778494ea
Author: Dan Williams <dan.j.williams@intel.com>
Date:   Wed Jun 1 16:00:01 2011 -0700

    isci: remove 'min memory' infrastructure
    
    The old 'core' had aspirations of running in severely memory constrained
    environments like bios option-rom, it's not needed for Linux and gets in
    the way of other cleanups (like unifying/reducing the number of structure
    members in scic_sds_controller/isci_host).
    
    This also fixes a theoretical bug in that the driver would blindly override
    the silicon advertised limits for number of ports, task contexts, and remote
    node contexts.
    
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/drivers/scsi/isci/host.c b/drivers/scsi/isci/host.c
index 009c0ee83ed6..41a7c5099dea 100644
--- a/drivers/scsi/isci/host.c
+++ b/drivers/scsi/isci/host.c
@@ -70,46 +70,24 @@
 
 #define SCU_CONTEXT_RAM_INIT_STALL_TIME      200
 
-/**
- * smu_dcc_get_max_ports() -
- *
- * This macro returns the maximum number of logical ports supported by the
- * hardware. The caller passes in the value read from the device context
- * capacity register and this macro will mash and shift the value appropriately.
- */
-#define smu_dcc_get_max_ports(dcc_value) \
+#define smu_max_ports(dcc_value) \
 	(\
 		(((dcc_value) & SMU_DEVICE_CONTEXT_CAPACITY_MAX_LP_MASK) \
 		 >> SMU_DEVICE_CONTEXT_CAPACITY_MAX_LP_SHIFT) + 1 \
 	)
 
-/**
- * smu_dcc_get_max_task_context() -
- *
- * This macro returns the maximum number of task contexts supported by the
- * hardware. The caller passes in the value read from the device context
- * capacity register and this macro will mash and shift the value appropriately.
- */
-#define smu_dcc_get_max_task_context(dcc_value)	\
+#define smu_max_task_contexts(dcc_value)	\
 	(\
 		(((dcc_value) & SMU_DEVICE_CONTEXT_CAPACITY_MAX_TC_MASK) \
 		 >> SMU_DEVICE_CONTEXT_CAPACITY_MAX_TC_SHIFT) + 1 \
 	)
 
-/**
- * smu_dcc_get_max_remote_node_context() -
- *
- * This macro returns the maximum number of remote node contexts supported by
- * the hardware. The caller passes in the value read from the device context
- * capacity register and this macro will mash and shift the value appropriately.
- */
-#define smu_dcc_get_max_remote_node_context(dcc_value) \
+#define smu_max_rncs(dcc_value) \
 	(\
 		(((dcc_value) & SMU_DEVICE_CONTEXT_CAPACITY_MAX_RNC_MASK) \
 		 >> SMU_DEVICE_CONTEXT_CAPACITY_MAX_RNC_SHIFT) + 1 \
 	)
 
-
 #define SCIC_SDS_CONTROLLER_PHY_START_TIMEOUT      100
 
 /**
@@ -153,9 +131,8 @@
 	INCREMENT_QUEUE_GET(\
 		(index), \
 		(cycle), \
-		(controller)->completion_queue_entries,	\
-		SMU_CQGR_CYCLE_BIT \
-		)
+		SCU_MAX_COMPLETION_QUEUE_ENTRIES, \
+		SMU_CQGR_CYCLE_BIT)
 
 /**
  * INCREMENT_EVENT_QUEUE_GET() -
@@ -167,7 +144,7 @@
 	INCREMENT_QUEUE_GET(\
 		(index), \
 		(cycle), \
-		(controller)->completion_event_entries,	\
+		SCU_MAX_EVENTS, \
 		SMU_CQGR_EVENT_CYCLE_BIT \
 		)
 
@@ -843,10 +820,9 @@ static void scic_sds_controller_initialize_completion_queue(struct scic_sds_cont
 
 	scic->completion_queue_get = 0;
 
-	completion_queue_control_value = (
-		SMU_CQC_QUEUE_LIMIT_SET(scic->completion_queue_entries - 1)
-		| SMU_CQC_EVENT_LIMIT_SET(scic->completion_event_entries - 1)
-		);
+	completion_queue_control_value =
+		(SMU_CQC_QUEUE_LIMIT_SET(SCU_MAX_COMPLETION_QUEUE_ENTRIES - 1) |
+		 SMU_CQC_EVENT_LIMIT_SET(SCU_MAX_EVENTS - 1));
 
 	writel(completion_queue_control_value,
 	       &scic->smu_registers->completion_queue_control);
@@ -873,7 +849,7 @@ static void scic_sds_controller_initialize_completion_queue(struct scic_sds_cont
 	       &scic->smu_registers->completion_queue_put);
 
 	/* Initialize the cycle bit of the completion queue entries */
-	for (index = 0; index < scic->completion_queue_entries; index++) {
+	for (index = 0; index < SCU_MAX_COMPLETION_QUEUE_ENTRIES; index++) {
 		/*
 		 * If get.cycle_bit != completion_queue.cycle_bit
 		 * its not a valid completion queue entry
@@ -890,8 +866,7 @@ static void scic_sds_controller_initialize_unsolicited_frame_queue(struct scic_s
 
 	/* Write the queue size */
 	frame_queue_control_value =
-		SCU_UFQC_GEN_VAL(QUEUE_SIZE,
-				 scic->uf_control.address_table.count);
+		SCU_UFQC_GEN_VAL(QUEUE_SIZE, SCU_MAX_UNSOLICITED_FRAMES);
 
 	writel(frame_queue_control_value,
 	       &scic->scu_registers->sdma.unsolicited_frame_queue_control);
@@ -1863,15 +1838,6 @@ static enum sci_status scic_controller_construct(struct scic_sds_controller *sci
 
 	sci_init_timer(&scic->timer, controller_timeout);
 
-	/* Set the default maximum values */
-	scic->completion_event_entries      = SCU_EVENT_COUNT;
-	scic->completion_queue_entries      = SCU_COMPLETION_QUEUE_COUNT;
-	scic->remote_node_entries           = SCI_MAX_REMOTE_DEVICES;
-	scic->logical_port_entries          = SCI_MAX_PORTS;
-	scic->task_context_entries          = SCU_IO_REQUEST_COUNT;
-	scic->uf_control.buffers.count      = SCU_UNSOLICITED_FRAME_COUNT;
-	scic->uf_control.address_table.count = SCU_UNSOLICITED_FRAME_COUNT;
-
 	/* Initialize the User and OEM parameters to default values. */
 	scic_sds_controller_set_default_config_parameters(scic);
 
@@ -2207,44 +2173,6 @@ static void scic_sds_controller_afe_initialization(struct scic_sds_controller *s
 	udelay(AFE_REGISTER_WRITE_DELAY);
 }
 
-static enum sci_status scic_controller_set_mode(struct scic_sds_controller *scic,
-						enum sci_controller_mode operating_mode)
-{
-	enum sci_status status          = SCI_SUCCESS;
-
-	if ((scic->sm.current_state_id == SCIC_INITIALIZING) ||
-	    (scic->sm.current_state_id == SCIC_INITIALIZED)) {
-		switch (operating_mode) {
-		case SCI_MODE_SPEED:
-			scic->remote_node_entries      = SCI_MAX_REMOTE_DEVICES;
-			scic->task_context_entries     = SCU_IO_REQUEST_COUNT;
-			scic->uf_control.buffers.count =
-				SCU_UNSOLICITED_FRAME_COUNT;
-			scic->completion_event_entries = SCU_EVENT_COUNT;
-			scic->completion_queue_entries =
-				SCU_COMPLETION_QUEUE_COUNT;
-			break;
-
-		case SCI_MODE_SIZE:
-			scic->remote_node_entries      = SCI_MIN_REMOTE_DEVICES;
-			scic->task_context_entries     = SCI_MIN_IO_REQUESTS;
-			scic->uf_control.buffers.count =
-				SCU_MIN_UNSOLICITED_FRAMES;
-			scic->completion_event_entries = SCU_MIN_EVENTS;
-			scic->completion_queue_entries =
-				SCU_MIN_COMPLETION_QUEUE_ENTRIES;
-			break;
-
-		default:
-			status = SCI_FAILURE_INVALID_PARAMETER_VALUE;
-			break;
-		}
-	} else
-		status = SCI_FAILURE_INVALID_STATE;
-
-	return status;
-}
-
 static void scic_sds_controller_initialize_power_control(struct scic_sds_controller *scic)
 {
 	sci_init_timer(&scic->power_control.timer, power_control_timeout);
@@ -2259,9 +2187,9 @@ static void scic_sds_controller_initialize_power_control(struct scic_sds_control
 static enum sci_status scic_controller_initialize(struct scic_sds_controller *scic)
 {
 	struct sci_base_state_machine *sm = &scic->sm;
-	enum sci_status result = SCI_SUCCESS;
 	struct isci_host *ihost = scic_to_ihost(scic);
-	u32 index, state;
+	enum sci_status result = SCI_FAILURE;
+	unsigned long i, state, val;
 
 	if (scic->sm.current_state_id != SCIC_RESET) {
 		dev_warn(scic_to_dev(scic),
@@ -2286,133 +2214,81 @@ static enum sci_status scic_controller_initialize(struct scic_sds_controller *sc
 	 * /       presently they seem to be wrong. */
 	scic_sds_controller_afe_initialization(scic);
 
-	if (result == SCI_SUCCESS) {
-		u32 status;
-		u32 terminate_loop;
-
-		/* Take the hardware out of reset */
-		writel(0, &scic->smu_registers->soft_reset_control);
 
-		/*
-		 * / @todo Provide meaningfull error code for hardware failure
-		 * result = SCI_FAILURE_CONTROLLER_HARDWARE; */
-		result = SCI_FAILURE;
-		terminate_loop = 100;
-
-		while (terminate_loop-- && (result != SCI_SUCCESS)) {
-			/* Loop until the hardware reports success */
-			udelay(SCU_CONTEXT_RAM_INIT_STALL_TIME);
-			status = readl(&scic->smu_registers->control_status);
-
-			if ((status & SCU_RAM_INIT_COMPLETED) ==
-					SCU_RAM_INIT_COMPLETED)
-				result = SCI_SUCCESS;
-		}
-	}
-
-	if (result == SCI_SUCCESS) {
-		u32 max_supported_ports;
-		u32 max_supported_devices;
-		u32 max_supported_io_requests;
-		u32 device_context_capacity;
+	/* Take the hardware out of reset */
+	writel(0, &scic->smu_registers->soft_reset_control);
 
-		/*
-		 * Determine what are the actaul device capacities that the
-		 * hardware will support */
-		device_context_capacity =
-			readl(&scic->smu_registers->device_context_capacity);
-
-
-		max_supported_ports = smu_dcc_get_max_ports(device_context_capacity);
-		max_supported_devices = smu_dcc_get_max_remote_node_context(device_context_capacity);
-		max_supported_io_requests = smu_dcc_get_max_task_context(device_context_capacity);
+	/*
+	 * / @todo Provide meaningfull error code for hardware failure
+	 * result = SCI_FAILURE_CONTROLLER_HARDWARE; */
+	for (i = 100; i >= 1; i--) {
+		u32 status;
 
-		/*
-		 * Make all PEs that are unassigned match up with the
-		 * logical ports
-		 */
-		for (index = 0; index < max_supported_ports; index++) {
-			struct scu_port_task_scheduler_group_registers __iomem
-				*ptsg = &scic->scu_registers->peg0.ptsg;
+		/* Loop until the hardware reports success */
+		udelay(SCU_CONTEXT_RAM_INIT_STALL_TIME);
+		status = readl(&scic->smu_registers->control_status);
 
-			writel(index, &ptsg->protocol_engine[index]);
-		}
+		if ((status & SCU_RAM_INIT_COMPLETED) == SCU_RAM_INIT_COMPLETED)
+			break;
+	}
+	if (i == 0)
+		goto out;
 
-		/* Record the smaller of the two capacity values */
-		scic->logical_port_entries =
-			min(max_supported_ports, scic->logical_port_entries);
+	/*
+	 * Determine what are the actaul device capacities that the
+	 * hardware will support */
+	val = readl(&scic->smu_registers->device_context_capacity);
 
-		scic->task_context_entries =
-			min(max_supported_io_requests,
-			    scic->task_context_entries);
+	/* Record the smaller of the two capacity values */
+	scic->logical_port_entries = min(smu_max_ports(val), SCI_MAX_PORTS);
+	scic->task_context_entries = min(smu_max_task_contexts(val), SCI_MAX_IO_REQUESTS);
+	scic->remote_node_entries = min(smu_max_rncs(val), SCI_MAX_REMOTE_DEVICES);
 
-		scic->remote_node_entries =
-			min(max_supported_devices, scic->remote_node_entries);
+	/*
+	 * Make all PEs that are unassigned match up with the
+	 * logical ports
+	 */
+	for (i = 0; i < scic->logical_port_entries; i++) {
+		struct scu_port_task_scheduler_group_registers __iomem
+			*ptsg = &scic->scu_registers->peg0.ptsg;
 
-		/*
-		 * Now that we have the correct hardware reported minimum values
-		 * build the MDL for the controller.  Default to a performance
-		 * configuration.
-		 */
-		scic_controller_set_mode(scic, SCI_MODE_SPEED);
+		writel(i, &ptsg->protocol_engine[i]);
 	}
 
 	/* Initialize hardware PCI Relaxed ordering in DMA engines */
-	if (result == SCI_SUCCESS) {
-		u32 dma_configuration;
-
-		/* Configure the payload DMA */
-		dma_configuration =
-			readl(&scic->scu_registers->sdma.pdma_configuration);
-		dma_configuration |=
-			SCU_PDMACR_GEN_BIT(PCI_RELAXED_ORDERING_ENABLE);
-		writel(dma_configuration,
-			&scic->scu_registers->sdma.pdma_configuration);
-
-		/* Configure the control DMA */
-		dma_configuration =
-			readl(&scic->scu_registers->sdma.cdma_configuration);
-		dma_configuration |=
-			SCU_CDMACR_GEN_BIT(PCI_RELAXED_ORDERING_ENABLE);
-		writel(dma_configuration,
-			&scic->scu_registers->sdma.cdma_configuration);
-	}
+	val = readl(&scic->scu_registers->sdma.pdma_configuration);
+	val |= SCU_PDMACR_GEN_BIT(PCI_RELAXED_ORDERING_ENABLE);
+	writel(val, &scic->scu_registers->sdma.pdma_configuration);
+
+	val = readl(&scic->scu_registers->sdma.cdma_configuration);
+	val |= SCU_CDMACR_GEN_BIT(PCI_RELAXED_ORDERING_ENABLE);
+	writel(val, &scic->scu_registers->sdma.cdma_configuration);
 
 	/*
 	 * Initialize the PHYs before the PORTs because the PHY registers
 	 * are accessed during the port initialization.
 	 */
-	if (result == SCI_SUCCESS) {
-		/* Initialize the phys */
-		for (index = 0;
-		     (result == SCI_SUCCESS) && (index < SCI_MAX_PHYS);
-		     index++) {
-			result = scic_sds_phy_initialize(
-				&ihost->phys[index].sci,
-				&scic->scu_registers->peg0.pe[index].tl,
-				&scic->scu_registers->peg0.pe[index].ll);
-		}
+	for (i = 0; i < SCI_MAX_PHYS; i++) {
+		result = scic_sds_phy_initialize(&ihost->phys[i].sci,
+						 &scic->scu_registers->peg0.pe[i].tl,
+						 &scic->scu_registers->peg0.pe[i].ll);
+		if (result != SCI_SUCCESS)
+			goto out;
 	}
 
-	if (result == SCI_SUCCESS) {
-		/* Initialize the logical ports */
-		for (index = 0;
-		     (index < scic->logical_port_entries) &&
-		     (result == SCI_SUCCESS);
-		     index++) {
-			result = scic_sds_port_initialize(
-				&ihost->ports[index].sci,
-				&scic->scu_registers->peg0.ptsg.port[index],
-				&scic->scu_registers->peg0.ptsg.protocol_engine,
-				&scic->scu_registers->peg0.viit[index]);
-		}
+	for (i = 0; i < scic->logical_port_entries; i++) {
+		result = scic_sds_port_initialize(&ihost->ports[i].sci,
+						  &scic->scu_registers->peg0.ptsg.port[i],
+						  &scic->scu_registers->peg0.ptsg.protocol_engine,
+						  &scic->scu_registers->peg0.viit[i]);
+
+		if (result != SCI_SUCCESS)
+			goto out;
 	}
 
-	if (result == SCI_SUCCESS)
-		result = scic_sds_port_configuration_agent_initialize(
-				scic,
-				&scic->port_agent);
+	result = scic_sds_port_configuration_agent_initialize(scic, &scic->port_agent);
 
+ out:
 	/* Advance the controller state machine */
 	if (result == SCI_SUCCESS)
 		state = SCIC_INITIALIZED;
@@ -2480,47 +2356,38 @@ static enum sci_status scic_user_parameters_set(
 static int scic_controller_mem_init(struct scic_sds_controller *scic)
 {
 	struct device *dev = scic_to_dev(scic);
-	dma_addr_t dma_handle;
-	enum sci_status result;
+	dma_addr_t dma;
+	size_t size;
+	int err;
 
-	scic->completion_queue = dmam_alloc_coherent(dev,
-			scic->completion_queue_entries * sizeof(u32),
-			&dma_handle, GFP_KERNEL);
+	size = SCU_MAX_COMPLETION_QUEUE_ENTRIES * sizeof(u32);
+	scic->completion_queue = dmam_alloc_coherent(dev, size, &dma, GFP_KERNEL);
 	if (!scic->completion_queue)
 		return -ENOMEM;
 
-	writel(lower_32_bits(dma_handle),
-		&scic->smu_registers->completion_queue_lower);
-	writel(upper_32_bits(dma_handle),
-		&scic->smu_registers->completion_queue_upper);
+	writel(lower_32_bits(dma), &scic->smu_registers->completion_queue_lower);
+	writel(upper_32_bits(dma), &scic->smu_registers->completion_queue_upper);
 
-	scic->remote_node_context_table = dmam_alloc_coherent(dev,
-			scic->remote_node_entries *
-				sizeof(union scu_remote_node_context),
-			&dma_handle, GFP_KERNEL);
+	size = scic->remote_node_entries * sizeof(union scu_remote_node_context);
+	scic->remote_node_context_table = dmam_alloc_coherent(dev, size, &dma,
+							      GFP_KERNEL);
 	if (!scic->remote_node_context_table)
 		return -ENOMEM;
 
-	writel(lower_32_bits(dma_handle),
-		&scic->smu_registers->remote_node_context_lower);
-	writel(upper_32_bits(dma_handle),
-		&scic->smu_registers->remote_node_context_upper);
+	writel(lower_32_bits(dma), &scic->smu_registers->remote_node_context_lower);
+	writel(upper_32_bits(dma), &scic->smu_registers->remote_node_context_upper);
 
-	scic->task_context_table = dmam_alloc_coherent(dev,
-			scic->task_context_entries *
-				sizeof(struct scu_task_context),
-			&dma_handle, GFP_KERNEL);
+	size = scic->task_context_entries * sizeof(struct scu_task_context),
+	scic->task_context_table = dmam_alloc_coherent(dev, size, &dma, GFP_KERNEL);
 	if (!scic->task_context_table)
 		return -ENOMEM;
 
-	writel(lower_32_bits(dma_handle),
-		&scic->smu_registers->host_task_table_lower);
-	writel(upper_32_bits(dma_handle),
-		&scic->smu_registers->host_task_table_upper);
+	writel(lower_32_bits(dma), &scic->smu_registers->host_task_table_lower);
+	writel(upper_32_bits(dma), &scic->smu_registers->host_task_table_upper);
 
-	result = scic_sds_unsolicited_frame_control_construct(scic);
-	if (result)
-		return result;
+	err = scic_sds_unsolicited_frame_control_construct(scic);
+	if (err)
+		return err;
 
 	/*
 	 * Inform the silicon as to the location of the UF headers and

commit dbb0743a58825d94f1b3fdfa90a8d61dfef88f7b
Author: Adam Gruchala <adam.gruchala@intel.com>
Date:   Wed Jun 1 22:31:03 2011 +0000

    isci: Added support for C0 to SCU Driver
    
    C0 silicon updates the pci revision id and requires new AFE parameters
    for phy signal integrity.  Support for previous silicon revisions is
    deprecated (it's also broken for the theoretical case of multiple
    controllers at different silicon revisions, all the more reason to get
    it removed as soon as possible)
    
    Signed-off-by: Adam Gruchala <adam.gruchala@intel.com>
    [fixed up deprecated silicon support]
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/drivers/scsi/isci/host.c b/drivers/scsi/isci/host.c
index f502882a2e17..009c0ee83ed6 100644
--- a/drivers/scsi/isci/host.c
+++ b/drivers/scsi/isci/host.c
@@ -2070,13 +2070,13 @@ static void scic_sds_controller_afe_initialization(struct scic_sds_controller *s
 		writel(0x00005500, &scic->scu_registers->afe.afe_bias_control);
 	else if (is_a2())
 		writel(0x00005A00, &scic->scu_registers->afe.afe_bias_control);
-	else if (is_b0())
+	else if (is_b0() || is_c0())
 		writel(0x00005F00, &scic->scu_registers->afe.afe_bias_control);
 
 	udelay(AFE_REGISTER_WRITE_DELAY);
 
 	/* Enable PLL */
-	if (is_b0())
+	if (is_b0() || is_c0())
 		writel(0x80040A08, &scic->scu_registers->afe.afe_pll_control0);
 	else
 		writel(0x80040908, &scic->scu_registers->afe.afe_pll_control0);
@@ -2102,6 +2102,16 @@ static void scic_sds_controller_afe_initialization(struct scic_sds_controller *s
 			 /* Configure transmitter SSC parameters */
 			writel(0x00030000, &scic->scu_registers->afe.scu_afe_xcvr[phy_id].afe_tx_ssc_control);
 			udelay(AFE_REGISTER_WRITE_DELAY);
+		} else if (is_c0()) {
+			 /* Configure transmitter SSC parameters */
+			writel(0x0003000, &scic->scu_registers->afe.scu_afe_xcvr[phy_id].afe_tx_ssc_control);
+			udelay(AFE_REGISTER_WRITE_DELAY);
+
+			/*
+			 * All defaults, except the Receive Word Alignament/Comma Detect
+			 * Enable....(0xe800) */
+			writel(0x00004500, &scic->scu_registers->afe.scu_afe_xcvr[phy_id].afe_xcvr_control0);
+			udelay(AFE_REGISTER_WRITE_DELAY);
 		} else {
 			/*
 			 * All defaults, except the Receive Word Alignament/Comma Detect
@@ -2120,15 +2130,23 @@ static void scic_sds_controller_afe_initialization(struct scic_sds_controller *s
 			writel(0x000003D4, &scic->scu_registers->afe.scu_afe_xcvr[phy_id].afe_channel_control);
 		else if (is_a2())
 			writel(0x000003F0, &scic->scu_registers->afe.scu_afe_xcvr[phy_id].afe_channel_control);
-		else {
+		else if (is_b0()) {
 			 /* Power down TX and RX (PWRDNTX and PWRDNRX) */
-			writel(0x000003d7, &scic->scu_registers->afe.scu_afe_xcvr[phy_id].afe_channel_control);
+			writel(0x000003D7, &scic->scu_registers->afe.scu_afe_xcvr[phy_id].afe_channel_control);
+			udelay(AFE_REGISTER_WRITE_DELAY);
+
+			/*
+			 * Power up TX and RX out from power down (PWRDNTX and PWRDNRX)
+			 * & increase TX int & ext bias 20%....(0xe85c) */
+			writel(0x000003D4, &scic->scu_registers->afe.scu_afe_xcvr[phy_id].afe_channel_control);
+		} else {
+			writel(0x000001E7, &scic->scu_registers->afe.scu_afe_xcvr[phy_id].afe_channel_control);
 			udelay(AFE_REGISTER_WRITE_DELAY);
 
 			/*
 			 * Power up TX and RX out from power down (PWRDNTX and PWRDNRX)
 			 * & increase TX int & ext bias 20%....(0xe85c) */
-			writel(0x000003d4, &scic->scu_registers->afe.scu_afe_xcvr[phy_id].afe_channel_control);
+			writel(0x000001E4, &scic->scu_registers->afe.scu_afe_xcvr[phy_id].afe_channel_control);
 		}
 		udelay(AFE_REGISTER_WRITE_DELAY);
 
@@ -2149,12 +2167,22 @@ static void scic_sds_controller_afe_initialization(struct scic_sds_controller *s
 			writel(0x3F09983F, &scic->scu_registers->afe.scu_afe_xcvr[phy_id].afe_rx_ssc_control0);
 		else if (is_a2())
 			writel(0x3F11103F, &scic->scu_registers->afe.scu_afe_xcvr[phy_id].afe_rx_ssc_control0);
-		else {
+		else if (is_b0()) {
 			writel(0x3F11103F, &scic->scu_registers->afe.scu_afe_xcvr[phy_id].afe_rx_ssc_control0);
 			udelay(AFE_REGISTER_WRITE_DELAY);
+			/* Enable TX equalization (0xe824) */
+			writel(0x00040000, &scic->scu_registers->afe.scu_afe_xcvr[phy_id].afe_tx_control);
+		} else {
+			writel(0x0140DF0F, &scic->scu_registers->afe.scu_afe_xcvr[phy_id].afe_rx_ssc_control1);
+			udelay(AFE_REGISTER_WRITE_DELAY);
+
+			writel(0x3F6F103F, &scic->scu_registers->afe.scu_afe_xcvr[phy_id].afe_rx_ssc_control0);
+			udelay(AFE_REGISTER_WRITE_DELAY);
+
 			/* Enable TX equalization (0xe824) */
 			writel(0x00040000, &scic->scu_registers->afe.scu_afe_xcvr[phy_id].afe_tx_control);
 		}
+
 		udelay(AFE_REGISTER_WRITE_DELAY);
 
 		writel(oem_phy->afe_tx_amp_control0,

commit 12ef65444de9d387a383b9991960848bed5bbe74
Author: Edmund Nadolski <edmund.nadolski@intel.com>
Date:   Thu Jun 2 00:10:50 2011 +0000

    isci: additional state machine cleanup
    
    Additional state machine cleanups:
    
     o Remove static functions sci_state_machine_exit_state() and
       sci_state_machine_enter_state()
     o Combines sci_base_state_machine_construct() and
       sci_base_state_machine_start() into a single function,
       sci_init_sm()
     o Remove sci_base_state_machine_stop() which is unused.
     o Kill state_machine.[ch]
    
    Signed-off-by: Edmund Nadolski <edmund.nadolski@intel.com>
    [fixed too large to inline functions]
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/drivers/scsi/isci/host.c b/drivers/scsi/isci/host.c
index 81ee64c0a4b7..f502882a2e17 100644
--- a/drivers/scsi/isci/host.c
+++ b/drivers/scsi/isci/host.c
@@ -197,6 +197,39 @@
  */
 #define COMPLETION_QUEUE_CYCLE_BIT(x) ((x) & 0x80000000)
 
+/* Init the state machine and call the state entry function (if any) */
+void sci_init_sm(struct sci_base_state_machine *sm,
+		 const struct sci_base_state *state_table, u32 initial_state)
+{
+	sci_state_transition_t handler;
+
+	sm->initial_state_id    = initial_state;
+	sm->previous_state_id   = initial_state;
+	sm->current_state_id    = initial_state;
+	sm->state_table         = state_table;
+
+	handler = sm->state_table[initial_state].enter_state;
+	if (handler)
+		handler(sm);
+}
+
+/* Call the state exit fn, update the current state, call the state entry fn */
+void sci_change_state(struct sci_base_state_machine *sm, u32 next_state)
+{
+	sci_state_transition_t handler;
+
+	handler = sm->state_table[sm->current_state_id].exit_state;
+	if (handler)
+		handler(sm);
+
+	sm->previous_state_id = sm->current_state_id;
+	sm->current_state_id = next_state;
+
+	handler = sm->state_table[sm->current_state_id].enter_state;
+	if (handler)
+		handler(sm);
+}
+
 static bool scic_sds_controller_completion_queue_has_entries(
 	struct scic_sds_controller *scic)
 {
@@ -1807,11 +1840,7 @@ static enum sci_status scic_controller_construct(struct scic_sds_controller *sci
 	struct isci_host *ihost = scic_to_ihost(scic);
 	u8 i;
 
-	sci_base_state_machine_construct(&scic->sm,
-					 scic_sds_controller_state_table,
-					 SCIC_INITIAL);
-
-	sci_base_state_machine_start(&scic->sm);
+	sci_init_sm(&scic->sm, scic_sds_controller_state_table, SCIC_INITIAL);
 
 	scic->scu_registers = scu_base;
 	scic->smu_registers = smu_base;

commit e301370ac553a9a0ac0d1d25e769b86cf60395b3
Author: Edmund Nadolski <edmund.nadolski@intel.com>
Date:   Thu Jun 2 00:10:43 2011 +0000

    isci: state machine cleanup
    
    This cleans up several areas of the state machine mechanism:
    
     o Rename sci_base_state_machine_change_state to sci_change_state
     o Remove sci_base_state_machine_get_state function
     o Rename 'state_machine' struct member to 'sm' in client structs
     o Shorten the name of request states
     o Shorten state machine state names as follows:
            SCI_BASE_CONTROLLER_STATE_xxx to SCIC_xxx
            SCI_BASE_PHY_STATE_xxx to SCI_PHY_xxx
            SCIC_SDS_PHY_STARTING_SUBSTATE_xxx to SCI_PHY_SUB_xxx
            SCI_BASE_PORT_STATE_xxx to SCI_PORT_xxx and
            SCIC_SDS_PORT_READY_SUBSTATE_xxx to SCI_PORT_SUB_xxx
            SCI_BASE_REMOTE_DEVICE_STATE_xxx to SCI_DEV_xxx
            SCIC_SDS_STP_REMOTE_DEVICE_READY_SUBSTATE_xxx to SCI_STP_DEV_xxx
            SCIC_SDS_SMP_REMOTE_DEVICE_READY_SUBSTATE_xxx to SCI_SMP_DEV_xxx
            SCIC_SDS_REMOTE_NODE_CONTEXT_xxx_STATE to SCI_RNC_xxx
    
    Signed-off-by: Edmund Nadolski <edmund.nadolski@intel.com>
    Signed-off-by: Dave Jiang <dave.jiang@intel.com>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/drivers/scsi/isci/host.c b/drivers/scsi/isci/host.c
index 8801955be213..81ee64c0a4b7 100644
--- a/drivers/scsi/isci/host.c
+++ b/drivers/scsi/isci/host.c
@@ -635,8 +635,7 @@ static void scic_sds_controller_error_handler(struct scic_sds_controller *scic)
 		dev_err(scic_to_dev(scic), "%s: status: %#x\n", __func__,
 			interrupt_status);
 
-		sci_base_state_machine_change_state(&scic->state_machine,
-						    SCI_BASE_CONTROLLER_STATE_FAILED);
+		sci_change_state(&scic->sm, SCIC_FAILED);
 
 		return;
 	}
@@ -895,14 +894,12 @@ static void scic_sds_controller_transition_to_ready(
 {
 	struct isci_host *ihost = scic_to_ihost(scic);
 
-	if (scic->state_machine.current_state_id ==
-	    SCI_BASE_CONTROLLER_STATE_STARTING) {
+	if (scic->sm.current_state_id == SCIC_STARTING) {
 		/*
 		 * We move into the ready state, because some of the phys/ports
 		 * may be up and operational.
 		 */
-		sci_base_state_machine_change_state(&scic->state_machine,
-						    SCI_BASE_CONTROLLER_STATE_READY);
+		sci_change_state(&scic->sm, SCIC_READY);
 
 		isci_host_start_complete(ihost, status);
 	}
@@ -912,18 +909,18 @@ static bool is_phy_starting(struct scic_sds_phy *sci_phy)
 {
 	enum scic_sds_phy_states state;
 
-	state = sci_phy->state_machine.current_state_id;
+	state = sci_phy->sm.current_state_id;
 	switch (state) {
-	case SCI_BASE_PHY_STATE_STARTING:
-	case SCIC_SDS_PHY_STARTING_SUBSTATE_INITIAL:
-	case SCIC_SDS_PHY_STARTING_SUBSTATE_AWAIT_SAS_SPEED_EN:
-	case SCIC_SDS_PHY_STARTING_SUBSTATE_AWAIT_IAF_UF:
-	case SCIC_SDS_PHY_STARTING_SUBSTATE_AWAIT_SAS_POWER:
-	case SCIC_SDS_PHY_STARTING_SUBSTATE_AWAIT_SATA_POWER:
-	case SCIC_SDS_PHY_STARTING_SUBSTATE_AWAIT_SATA_PHY_EN:
-	case SCIC_SDS_PHY_STARTING_SUBSTATE_AWAIT_SATA_SPEED_EN:
-	case SCIC_SDS_PHY_STARTING_SUBSTATE_AWAIT_SIG_FIS_UF:
-	case SCIC_SDS_PHY_STARTING_SUBSTATE_FINAL:
+	case SCI_PHY_STARTING:
+	case SCI_PHY_SUB_INITIAL:
+	case SCI_PHY_SUB_AWAIT_SAS_SPEED_EN:
+	case SCI_PHY_SUB_AWAIT_IAF_UF:
+	case SCI_PHY_SUB_AWAIT_SAS_POWER:
+	case SCI_PHY_SUB_AWAIT_SATA_POWER:
+	case SCI_PHY_SUB_AWAIT_SATA_PHY_EN:
+	case SCI_PHY_SUB_AWAIT_SATA_SPEED_EN:
+	case SCI_PHY_SUB_AWAIT_SIG_FIS_UF:
+	case SCI_PHY_SUB_FINAL:
 		return true;
 	default:
 		return false;
@@ -957,7 +954,7 @@ static enum sci_status scic_sds_controller_start_next_phy(struct scic_sds_contro
 
 		for (index = 0; index < SCI_MAX_PHYS; index++) {
 			sci_phy = &ihost->phys[index].sci;
-			state = sci_phy->state_machine.current_state_id;
+			state = sci_phy->sm.current_state_id;
 
 			if (!phy_get_non_dummy_port(sci_phy))
 				continue;
@@ -968,12 +965,9 @@ static enum sci_status scic_sds_controller_start_next_phy(struct scic_sds_contro
 			 * - have an indication of a connected device and it has
 			 *   finished the link training process.
 			 */
-			if ((sci_phy->is_in_link_training == false &&
-			     state == SCI_BASE_PHY_STATE_INITIAL) ||
-			    (sci_phy->is_in_link_training == false &&
-			     state == SCI_BASE_PHY_STATE_STOPPED) ||
-			    (sci_phy->is_in_link_training == true &&
-			     is_phy_starting(sci_phy))) {
+			if ((sci_phy->is_in_link_training == false && state == SCI_PHY_INITIAL) ||
+			    (sci_phy->is_in_link_training == false && state == SCI_PHY_STOPPED) ||
+			    (sci_phy->is_in_link_training == true && is_phy_starting(sci_phy))) {
 				is_controller_start_complete = false;
 				break;
 			}
@@ -1059,8 +1053,7 @@ static enum sci_status scic_controller_start(struct scic_sds_controller *scic,
 	enum sci_status result;
 	u16 index;
 
-	if (scic->state_machine.current_state_id !=
-	    SCI_BASE_CONTROLLER_STATE_INITIALIZED) {
+	if (scic->sm.current_state_id != SCIC_INITIALIZED) {
 		dev_warn(scic_to_dev(scic),
 			 "SCIC Controller start operation requested in "
 			 "invalid state\n");
@@ -1108,8 +1101,7 @@ static enum sci_status scic_controller_start(struct scic_sds_controller *scic,
 
 	sci_mod_timer(&scic->timer, timeout);
 
-	sci_base_state_machine_change_state(&scic->state_machine,
-					    SCI_BASE_CONTROLLER_STATE_STARTING);
+	sci_change_state(&scic->sm, SCIC_STARTING);
 
 	return SCI_SUCCESS;
 }
@@ -1279,8 +1271,7 @@ static void isci_host_completion_routine(unsigned long data)
 static enum sci_status scic_controller_stop(struct scic_sds_controller *scic,
 					    u32 timeout)
 {
-	if (scic->state_machine.current_state_id !=
-	    SCI_BASE_CONTROLLER_STATE_READY) {
+	if (scic->sm.current_state_id != SCIC_READY) {
 		dev_warn(scic_to_dev(scic),
 			 "SCIC Controller stop operation requested in "
 			 "invalid state\n");
@@ -1288,8 +1279,7 @@ static enum sci_status scic_controller_stop(struct scic_sds_controller *scic,
 	}
 
 	sci_mod_timer(&scic->timer, timeout);
-	sci_base_state_machine_change_state(&scic->state_machine,
-					    SCI_BASE_CONTROLLER_STATE_STOPPING);
+	sci_change_state(&scic->sm, SCIC_STOPPING);
 	return SCI_SUCCESS;
 }
 
@@ -1307,17 +1297,16 @@ static enum sci_status scic_controller_stop(struct scic_sds_controller *scic,
  */
 static enum sci_status scic_controller_reset(struct scic_sds_controller *scic)
 {
-	switch (scic->state_machine.current_state_id) {
-	case SCI_BASE_CONTROLLER_STATE_RESET:
-	case SCI_BASE_CONTROLLER_STATE_READY:
-	case SCI_BASE_CONTROLLER_STATE_STOPPED:
-	case SCI_BASE_CONTROLLER_STATE_FAILED:
+	switch (scic->sm.current_state_id) {
+	case SCIC_RESET:
+	case SCIC_READY:
+	case SCIC_STOPPED:
+	case SCIC_FAILED:
 		/*
 		 * The reset operation is not a graceful cleanup, just
 		 * perform the state transition.
 		 */
-		sci_base_state_machine_change_state(&scic->state_machine,
-				SCI_BASE_CONTROLLER_STATE_RESETTING);
+		sci_change_state(&scic->sm, SCIC_RESETTING);
 		return SCI_SUCCESS;
 	default:
 		dev_warn(scic_to_dev(scic),
@@ -1416,15 +1405,14 @@ static void isci_user_parameters_get(
 
 static void scic_sds_controller_initial_state_enter(struct sci_base_state_machine *sm)
 {
-	struct scic_sds_controller *scic = container_of(sm, typeof(*scic), state_machine);
+	struct scic_sds_controller *scic = container_of(sm, typeof(*scic), sm);
 
-	sci_base_state_machine_change_state(&scic->state_machine,
-			SCI_BASE_CONTROLLER_STATE_RESET);
+	sci_change_state(&scic->sm, SCIC_RESET);
 }
 
 static inline void scic_sds_controller_starting_state_exit(struct sci_base_state_machine *sm)
 {
-	struct scic_sds_controller *scic = container_of(sm, typeof(*scic), state_machine);
+	struct scic_sds_controller *scic = container_of(sm, typeof(*scic), sm);
 
 	sci_del_timer(&scic->timer);
 }
@@ -1551,7 +1539,7 @@ static enum sci_status scic_controller_set_interrupt_coalescence(
 
 static void scic_sds_controller_ready_state_enter(struct sci_base_state_machine *sm)
 {
-	struct scic_sds_controller *scic = container_of(sm, typeof(*scic), state_machine);
+	struct scic_sds_controller *scic = container_of(sm, typeof(*scic), sm);
 
 	/* set the default interrupt coalescence number and timeout value. */
 	scic_controller_set_interrupt_coalescence(scic, 0x10, 250);
@@ -1559,7 +1547,7 @@ static void scic_sds_controller_ready_state_enter(struct sci_base_state_machine
 
 static void scic_sds_controller_ready_state_exit(struct sci_base_state_machine *sm)
 {
-	struct scic_sds_controller *scic = container_of(sm, typeof(*scic), state_machine);
+	struct scic_sds_controller *scic = container_of(sm, typeof(*scic), sm);
 
 	/* disable interrupt coalescence. */
 	scic_controller_set_interrupt_coalescence(scic, 0, 0);
@@ -1650,7 +1638,7 @@ static enum sci_status scic_sds_controller_stop_devices(struct scic_sds_controll
 
 static void scic_sds_controller_stopping_state_enter(struct sci_base_state_machine *sm)
 {
-	struct scic_sds_controller *scic = container_of(sm, typeof(*scic), state_machine);
+	struct scic_sds_controller *scic = container_of(sm, typeof(*scic), sm);
 
 	/* Stop all of the components for this controller */
 	scic_sds_controller_stop_phys(scic);
@@ -1660,7 +1648,7 @@ static void scic_sds_controller_stopping_state_enter(struct sci_base_state_machi
 
 static void scic_sds_controller_stopping_state_exit(struct sci_base_state_machine *sm)
 {
-	struct scic_sds_controller *scic = container_of(sm, typeof(*scic), state_machine);
+	struct scic_sds_controller *scic = container_of(sm, typeof(*scic), sm);
 
 	sci_del_timer(&scic->timer);
 }
@@ -1691,36 +1679,35 @@ static void scic_sds_controller_reset_hardware(struct scic_sds_controller *scic)
 
 static void scic_sds_controller_resetting_state_enter(struct sci_base_state_machine *sm)
 {
-	struct scic_sds_controller *scic = container_of(sm, typeof(*scic), state_machine);
+	struct scic_sds_controller *scic = container_of(sm, typeof(*scic), sm);
 
 	scic_sds_controller_reset_hardware(scic);
-	sci_base_state_machine_change_state(&scic->state_machine,
-					    SCI_BASE_CONTROLLER_STATE_RESET);
+	sci_change_state(&scic->sm, SCIC_RESET);
 }
 
 static const struct sci_base_state scic_sds_controller_state_table[] = {
-	[SCI_BASE_CONTROLLER_STATE_INITIAL] = {
+	[SCIC_INITIAL] = {
 		.enter_state = scic_sds_controller_initial_state_enter,
 	},
-	[SCI_BASE_CONTROLLER_STATE_RESET] = {},
-	[SCI_BASE_CONTROLLER_STATE_INITIALIZING] = {},
-	[SCI_BASE_CONTROLLER_STATE_INITIALIZED] = {},
-	[SCI_BASE_CONTROLLER_STATE_STARTING] = {
+	[SCIC_RESET] = {},
+	[SCIC_INITIALIZING] = {},
+	[SCIC_INITIALIZED] = {},
+	[SCIC_STARTING] = {
 		.exit_state  = scic_sds_controller_starting_state_exit,
 	},
-	[SCI_BASE_CONTROLLER_STATE_READY] = {
+	[SCIC_READY] = {
 		.enter_state = scic_sds_controller_ready_state_enter,
 		.exit_state  = scic_sds_controller_ready_state_exit,
 	},
-	[SCI_BASE_CONTROLLER_STATE_RESETTING] = {
+	[SCIC_RESETTING] = {
 		.enter_state = scic_sds_controller_resetting_state_enter,
 	},
-	[SCI_BASE_CONTROLLER_STATE_STOPPING] = {
+	[SCIC_STOPPING] = {
 		.enter_state = scic_sds_controller_stopping_state_enter,
 		.exit_state = scic_sds_controller_stopping_state_exit,
 	},
-	[SCI_BASE_CONTROLLER_STATE_STOPPED] = {},
-	[SCI_BASE_CONTROLLER_STATE_FAILED] = {}
+	[SCIC_STOPPED] = {},
+	[SCIC_FAILED] = {}
 };
 
 static void scic_sds_controller_set_default_config_parameters(struct scic_sds_controller *scic)
@@ -1774,7 +1761,7 @@ static void controller_timeout(unsigned long data)
 	struct sci_timer *tmr = (struct sci_timer *)data;
 	struct scic_sds_controller *scic = container_of(tmr, typeof(*scic), timer);
 	struct isci_host *ihost = scic_to_ihost(scic);
-	struct sci_base_state_machine *sm = &scic->state_machine;
+	struct sci_base_state_machine *sm = &scic->sm;
 	unsigned long flags;
 
 	spin_lock_irqsave(&ihost->scic_lock, flags);
@@ -1782,10 +1769,10 @@ static void controller_timeout(unsigned long data)
 	if (tmr->cancel)
 		goto done;
 
-	if (sm->current_state_id == SCI_BASE_CONTROLLER_STATE_STARTING)
+	if (sm->current_state_id == SCIC_STARTING)
 		scic_sds_controller_transition_to_ready(scic, SCI_FAILURE_TIMEOUT);
-	else if (sm->current_state_id == SCI_BASE_CONTROLLER_STATE_STOPPING) {
-		sci_base_state_machine_change_state(sm, SCI_BASE_CONTROLLER_STATE_FAILED);
+	else if (sm->current_state_id == SCIC_STOPPING) {
+		sci_change_state(sm, SCIC_FAILED);
 		isci_host_stop_complete(ihost, SCI_FAILURE_TIMEOUT);
 	} else	/* / @todo Now what do we want to do in this case? */
 		dev_err(scic_to_dev(scic),
@@ -1820,11 +1807,11 @@ static enum sci_status scic_controller_construct(struct scic_sds_controller *sci
 	struct isci_host *ihost = scic_to_ihost(scic);
 	u8 i;
 
-	sci_base_state_machine_construct(&scic->state_machine,
+	sci_base_state_machine_construct(&scic->sm,
 					 scic_sds_controller_state_table,
-					 SCI_BASE_CONTROLLER_STATE_INITIAL);
+					 SCIC_INITIAL);
 
-	sci_base_state_machine_start(&scic->state_machine);
+	sci_base_state_machine_start(&scic->sm);
 
 	scic->scu_registers = scu_base;
 	scic->smu_registers = smu_base;
@@ -1899,11 +1886,11 @@ int scic_oem_parameters_validate(struct scic_sds_oem_params *oem)
 static enum sci_status scic_oem_parameters_set(struct scic_sds_controller *scic,
 					union scic_oem_parameters *scic_parms)
 {
-	u32 state = scic->state_machine.current_state_id;
+	u32 state = scic->sm.current_state_id;
 
-	if (state == SCI_BASE_CONTROLLER_STATE_RESET ||
-	    state == SCI_BASE_CONTROLLER_STATE_INITIALIZING ||
-	    state == SCI_BASE_CONTROLLER_STATE_INITIALIZED) {
+	if (state == SCIC_RESET ||
+	    state == SCIC_INITIALIZING ||
+	    state == SCIC_INITIALIZED) {
 
 		if (scic_oem_parameters_validate(&scic_parms->sds1))
 			return SCI_FAILURE_INVALID_PARAMETER_VALUE;
@@ -2168,10 +2155,8 @@ static enum sci_status scic_controller_set_mode(struct scic_sds_controller *scic
 {
 	enum sci_status status          = SCI_SUCCESS;
 
-	if ((scic->state_machine.current_state_id ==
-				SCI_BASE_CONTROLLER_STATE_INITIALIZING) ||
-	    (scic->state_machine.current_state_id ==
-				SCI_BASE_CONTROLLER_STATE_INITIALIZED)) {
+	if ((scic->sm.current_state_id == SCIC_INITIALIZING) ||
+	    (scic->sm.current_state_id == SCIC_INITIALIZED)) {
 		switch (operating_mode) {
 		case SCI_MODE_SPEED:
 			scic->remote_node_entries      = SCI_MAX_REMOTE_DEVICES;
@@ -2216,20 +2201,19 @@ static void scic_sds_controller_initialize_power_control(struct scic_sds_control
 
 static enum sci_status scic_controller_initialize(struct scic_sds_controller *scic)
 {
-	struct sci_base_state_machine *sm = &scic->state_machine;
+	struct sci_base_state_machine *sm = &scic->sm;
 	enum sci_status result = SCI_SUCCESS;
 	struct isci_host *ihost = scic_to_ihost(scic);
 	u32 index, state;
 
-	if (scic->state_machine.current_state_id !=
-	    SCI_BASE_CONTROLLER_STATE_RESET) {
+	if (scic->sm.current_state_id != SCIC_RESET) {
 		dev_warn(scic_to_dev(scic),
 			 "SCIC Controller initialize operation requested "
 			 "in invalid state\n");
 		return SCI_FAILURE_INVALID_STATE;
 	}
 
-	sci_base_state_machine_change_state(sm, SCI_BASE_CONTROLLER_STATE_INITIALIZING);
+	sci_change_state(sm, SCIC_INITIALIZING);
 
 	sci_init_timer(&scic->phy_timer, phy_startup_timeout);
 
@@ -2374,10 +2358,10 @@ static enum sci_status scic_controller_initialize(struct scic_sds_controller *sc
 
 	/* Advance the controller state machine */
 	if (result == SCI_SUCCESS)
-		state = SCI_BASE_CONTROLLER_STATE_INITIALIZED;
+		state = SCIC_INITIALIZED;
 	else
-		state = SCI_BASE_CONTROLLER_STATE_FAILED;
-	sci_base_state_machine_change_state(sm, state);
+		state = SCIC_FAILED;
+	sci_change_state(sm, state);
 
 	return result;
 }
@@ -2386,11 +2370,11 @@ static enum sci_status scic_user_parameters_set(
 	struct scic_sds_controller *scic,
 	union scic_user_parameters *scic_parms)
 {
-	u32 state = scic->state_machine.current_state_id;
+	u32 state = scic->sm.current_state_id;
 
-	if (state == SCI_BASE_CONTROLLER_STATE_RESET ||
-	    state == SCI_BASE_CONTROLLER_STATE_INITIALIZING ||
-	    state == SCI_BASE_CONTROLLER_STATE_INITIALIZED) {
+	if (state == SCIC_RESET ||
+	    state == SCIC_INITIALIZING ||
+	    state == SCIC_INITIALIZED) {
 		u16 index;
 
 		/*
@@ -2612,15 +2596,15 @@ int isci_host_init(struct isci_host *isci_host)
 void scic_sds_controller_link_up(struct scic_sds_controller *scic,
 		struct scic_sds_port *port, struct scic_sds_phy *phy)
 {
-	switch (scic->state_machine.current_state_id) {
-	case SCI_BASE_CONTROLLER_STATE_STARTING:
+	switch (scic->sm.current_state_id) {
+	case SCIC_STARTING:
 		sci_del_timer(&scic->phy_timer);
 		scic->phy_startup_timer_pending = false;
 		scic->port_agent.link_up_handler(scic, &scic->port_agent,
 						 port, phy);
 		scic_sds_controller_start_next_phy(scic);
 		break;
-	case SCI_BASE_CONTROLLER_STATE_READY:
+	case SCIC_READY:
 		scic->port_agent.link_up_handler(scic, &scic->port_agent,
 						 port, phy);
 		break;
@@ -2628,16 +2612,16 @@ void scic_sds_controller_link_up(struct scic_sds_controller *scic,
 		dev_dbg(scic_to_dev(scic),
 			"%s: SCIC Controller linkup event from phy %d in "
 			"unexpected state %d\n", __func__, phy->phy_index,
-			scic->state_machine.current_state_id);
+			scic->sm.current_state_id);
 	}
 }
 
 void scic_sds_controller_link_down(struct scic_sds_controller *scic,
 		struct scic_sds_port *port, struct scic_sds_phy *phy)
 {
-	switch (scic->state_machine.current_state_id) {
-	case SCI_BASE_CONTROLLER_STATE_STARTING:
-	case SCI_BASE_CONTROLLER_STATE_READY:
+	switch (scic->sm.current_state_id) {
+	case SCIC_STARTING:
+	case SCIC_READY:
 		scic->port_agent.link_down_handler(scic, &scic->port_agent,
 						   port, phy);
 		break;
@@ -2647,7 +2631,7 @@ void scic_sds_controller_link_down(struct scic_sds_controller *scic,
 			"unexpected state %d\n",
 			__func__,
 			phy->phy_index,
-			scic->state_machine.current_state_id);
+			scic->sm.current_state_id);
 	}
 }
 
@@ -2663,8 +2647,7 @@ static bool scic_sds_controller_has_remote_devices_stopping(
 
 	for (index = 0; index < controller->remote_node_entries; index++) {
 		if ((controller->device_table[index] != NULL) &&
-		   (controller->device_table[index]->state_machine.current_state_id
-		    == SCI_BASE_REMOTE_DEVICE_STATE_STOPPING))
+		   (controller->device_table[index]->sm.current_state_id == SCI_DEV_STOPPING))
 			return true;
 	}
 
@@ -2678,19 +2661,17 @@ static bool scic_sds_controller_has_remote_devices_stopping(
 void scic_sds_controller_remote_device_stopped(struct scic_sds_controller *scic,
 					       struct scic_sds_remote_device *sci_dev)
 {
-	if (scic->state_machine.current_state_id !=
-	    SCI_BASE_CONTROLLER_STATE_STOPPING) {
+	if (scic->sm.current_state_id != SCIC_STOPPING) {
 		dev_dbg(scic_to_dev(scic),
 			"SCIC Controller 0x%p remote device stopped event "
 			"from device 0x%p in unexpected state %d\n",
 			scic, sci_dev,
-			scic->state_machine.current_state_id);
+			scic->sm.current_state_id);
 		return;
 	}
 
 	if (!scic_sds_controller_has_remote_devices_stopping(scic)) {
-		sci_base_state_machine_change_state(&scic->state_machine,
-				SCI_BASE_CONTROLLER_STATE_STOPPED);
+		sci_change_state(&scic->sm, SCIC_STOPPED);
 	}
 }
 
@@ -2948,8 +2929,7 @@ enum sci_status scic_controller_start_io(
 {
 	enum sci_status status;
 
-	if (scic->state_machine.current_state_id !=
-	    SCI_BASE_CONTROLLER_STATE_READY) {
+	if (scic->sm.current_state_id != SCIC_READY) {
 		dev_warn(scic_to_dev(scic), "invalid state to start I/O");
 		return SCI_FAILURE_INVALID_STATE;
 	}
@@ -2986,8 +2966,7 @@ enum sci_status scic_controller_terminate_request(
 {
 	enum sci_status status;
 
-	if (scic->state_machine.current_state_id !=
-	    SCI_BASE_CONTROLLER_STATE_READY) {
+	if (scic->sm.current_state_id != SCIC_READY) {
 		dev_warn(scic_to_dev(scic),
 			 "invalid state to terminate request\n");
 		return SCI_FAILURE_INVALID_STATE;
@@ -3037,11 +3016,11 @@ enum sci_status scic_controller_complete_io(
 	enum sci_status status;
 	u16 index;
 
-	switch (scic->state_machine.current_state_id) {
-	case SCI_BASE_CONTROLLER_STATE_STOPPING:
+	switch (scic->sm.current_state_id) {
+	case SCIC_STOPPING:
 		/* XXX: Implement this function */
 		return SCI_FAILURE;
-	case SCI_BASE_CONTROLLER_STATE_READY:
+	case SCIC_READY:
 		status = scic_sds_remote_device_complete_io(scic, rdev, request);
 		if (status != SCI_SUCCESS)
 			return status;
@@ -3060,8 +3039,7 @@ enum sci_status scic_controller_continue_io(struct scic_sds_request *sci_req)
 {
 	struct scic_sds_controller *scic = sci_req->owning_controller;
 
-	if (scic->state_machine.current_state_id !=
-	    SCI_BASE_CONTROLLER_STATE_READY) {
+	if (scic->sm.current_state_id != SCIC_READY) {
 		dev_warn(scic_to_dev(scic), "invalid state to continue I/O");
 		return SCI_FAILURE_INVALID_STATE;
 	}
@@ -3107,8 +3085,7 @@ enum sci_task_status scic_controller_start_task(
 {
 	enum sci_status status;
 
-	if (scic->state_machine.current_state_id !=
-	    SCI_BASE_CONTROLLER_STATE_READY) {
+	if (scic->sm.current_state_id != SCIC_READY) {
 		dev_warn(scic_to_dev(scic),
 			 "%s: SCIC Controller starting task from invalid "
 			 "state\n",

commit 8db02da52895285e99d7eb2fa825fd393e61d9c5
Author: Edmund Nadolski <edmund.nadolski@intel.com>
Date:   Thu May 19 12:00:22 2011 +0000

    isci: remove isci_timer interface
    
    Delete code which is no longer used.
    
    Signed-off-by: Edmund Nadolski <edmund.nadolski@intel.com>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/drivers/scsi/isci/host.c b/drivers/scsi/isci/host.c
index e79f35d510c7..8801955be213 100644
--- a/drivers/scsi/isci/host.c
+++ b/drivers/scsi/isci/host.c
@@ -67,7 +67,6 @@
 #include "scu_remote_node_context.h"
 #include "scu_task_context.h"
 #include "scu_unsolicited_frame.h"
-#include "timers.h"
 
 #define SCU_CONTEXT_RAM_INIT_STALL_TIME      200
 
@@ -111,14 +110,6 @@
 	)
 
 
-#define SCIC_SDS_CONTROLLER_MIN_TIMER_COUNT  3
-#define SCIC_SDS_CONTROLLER_MAX_TIMER_COUNT  3
-
-/**
- *
- *
- * The number of milliseconds to wait for a phy to start.
- */
 #define SCIC_SDS_CONTROLLER_PHY_START_TIMEOUT      100
 
 /**
@@ -1379,8 +1370,6 @@ void isci_host_deinit(struct isci_host *ihost)
 	del_timer_sync(&ihost->sci.timer.timer);
 
 	del_timer_sync(&ihost->sci.phy_timer.timer);
-
-	isci_timer_list_destroy(ihost);
 }
 
 static void __iomem *scu_base(struct isci_host *isci_host)
@@ -2517,8 +2506,6 @@ int isci_host_init(struct isci_host *isci_host)
 	union scic_user_parameters scic_user_params;
 	struct isci_pci_info *pci_info = to_pci_info(isci_host->pdev);
 
-	isci_timer_list_construct(isci_host);
-
 	spin_lock_init(&isci_host->state_lock);
 	spin_lock_init(&isci_host->scic_lock);
 	spin_lock_init(&isci_host->queue_lock);

commit bb3dbdf6c835a145e46119ed18a920a774694583
Author: Edmund Nadolski <edmund.nadolski@intel.com>
Date:   Thu May 19 20:26:02 2011 -0700

    isci: convert phy_startup_timer to sci_timer
    
    Signed-off-by: Edmund Nadolski <edmund.nadolski@intel.com>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/drivers/scsi/isci/host.c b/drivers/scsi/isci/host.c
index 156b37563761..e79f35d510c7 100644
--- a/drivers/scsi/isci/host.c
+++ b/drivers/scsi/isci/host.c
@@ -917,21 +917,6 @@ static void scic_sds_controller_transition_to_ready(
 	}
 }
 
-static void scic_sds_controller_phy_timer_stop(struct scic_sds_controller *scic)
-{
-	isci_timer_stop(scic->phy_startup_timer);
-
-	scic->phy_startup_timer_pending = false;
-}
-
-static void scic_sds_controller_phy_timer_start(struct scic_sds_controller *scic)
-{
-	isci_timer_start(scic->phy_startup_timer,
-			 SCIC_SDS_CONTROLLER_PHY_START_TIMEOUT);
-
-	scic->phy_startup_timer_pending = true;
-}
-
 static bool is_phy_starting(struct scic_sds_phy *sci_phy)
 {
 	enum scic_sds_phy_states state;
@@ -1008,7 +993,8 @@ static enum sci_status scic_sds_controller_start_next_phy(struct scic_sds_contro
 		 * Inform the SCI Core user and transition to the READY state. */
 		if (is_controller_start_complete == true) {
 			scic_sds_controller_transition_to_ready(scic, SCI_SUCCESS);
-			scic_sds_controller_phy_timer_stop(scic);
+			sci_del_timer(&scic->phy_timer);
+			scic->phy_startup_timer_pending = false;
 		}
 	} else {
 		sci_phy = &ihost->phys[scic->next_phy_to_start].sci;
@@ -1033,7 +1019,9 @@ static enum sci_status scic_sds_controller_start_next_phy(struct scic_sds_contro
 		status = scic_sds_phy_start(sci_phy);
 
 		if (status == SCI_SUCCESS) {
-			scic_sds_controller_phy_timer_start(scic);
+			sci_mod_timer(&scic->phy_timer,
+				      SCIC_SDS_CONTROLLER_PHY_START_TIMEOUT);
+			scic->phy_startup_timer_pending = true;
 		} else {
 			dev_warn(scic_to_dev(scic),
 				 "%s: Controller stop operation failed "
@@ -1050,15 +1038,27 @@ static enum sci_status scic_sds_controller_start_next_phy(struct scic_sds_contro
 	return status;
 }
 
-static void scic_sds_controller_phy_startup_timeout_handler(void *_scic)
+static void phy_startup_timeout(unsigned long data)
 {
-	struct scic_sds_controller *scic = _scic;
+	struct sci_timer *tmr = (struct sci_timer *)data;
+	struct scic_sds_controller *scic = container_of(tmr, typeof(*scic), phy_timer);
+	struct isci_host *ihost = scic_to_ihost(scic);
+	unsigned long flags;
 	enum sci_status status;
 
+	spin_lock_irqsave(&ihost->scic_lock, flags);
+
+	if (tmr->cancel)
+		goto done;
+
 	scic->phy_startup_timer_pending = false;
-	status = SCI_FAILURE;
-	while (status != SCI_SUCCESS)
+
+	do {
 		status = scic_sds_controller_start_next_phy(scic);
+	} while (status != SCI_SUCCESS);
+
+done:
+	spin_unlock_irqrestore(&ihost->scic_lock, flags);
 }
 
 static enum sci_status scic_controller_start(struct scic_sds_controller *scic,
@@ -1378,6 +1378,8 @@ void isci_host_deinit(struct isci_host *ihost)
 
 	del_timer_sync(&ihost->sci.timer.timer);
 
+	del_timer_sync(&ihost->sci.phy_timer.timer);
+
 	isci_timer_list_destroy(ihost);
 }
 
@@ -1931,24 +1933,6 @@ void scic_oem_parameters_get(
 	memcpy(scic_parms, (&scic->oem_parameters), sizeof(*scic_parms));
 }
 
-static enum sci_status scic_sds_controller_initialize_phy_startup(struct scic_sds_controller *scic)
-{
-	struct isci_host *ihost = scic_to_ihost(scic);
-
-	scic->phy_startup_timer = isci_timer_create(ihost,
-						    scic,
-						    scic_sds_controller_phy_startup_timeout_handler);
-
-	if (scic->phy_startup_timer == NULL)
-		return SCI_FAILURE_INSUFFICIENT_RESOURCES;
-	else {
-		scic->next_phy_to_start = 0;
-		scic->phy_startup_timer_pending = false;
-	}
-
-	return SCI_SUCCESS;
-}
-
 static void power_control_timeout(unsigned long data)
 {
 	struct sci_timer *tmr = (struct sci_timer *)data;
@@ -2258,7 +2242,10 @@ static enum sci_status scic_controller_initialize(struct scic_sds_controller *sc
 
 	sci_base_state_machine_change_state(sm, SCI_BASE_CONTROLLER_STATE_INITIALIZING);
 
-	scic_sds_controller_initialize_phy_startup(scic);
+	sci_init_timer(&scic->phy_timer, phy_startup_timeout);
+
+	scic->next_phy_to_start = 0;
+	scic->phy_startup_timer_pending = false;
 
 	scic_sds_controller_initialize_power_control(scic);
 
@@ -2640,7 +2627,8 @@ void scic_sds_controller_link_up(struct scic_sds_controller *scic,
 {
 	switch (scic->state_machine.current_state_id) {
 	case SCI_BASE_CONTROLLER_STATE_STARTING:
-		scic_sds_controller_phy_timer_stop(scic);
+		sci_del_timer(&scic->phy_timer);
+		scic->phy_startup_timer_pending = false;
 		scic->port_agent.link_up_handler(scic, &scic->port_agent,
 						 port, phy);
 		scic_sds_controller_start_next_phy(scic);

commit 6cb5853d3e252015eaf72d3761491e3da959556d
Author: Edmund Nadolski <edmund.nadolski@intel.com>
Date:   Thu May 19 11:59:56 2011 +0000

    isci: convert scic_timeout_timer to sci_timer
    
    Signed-off-by: Edmund Nadolski <edmund.nadolski@intel.com>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/drivers/scsi/isci/host.c b/drivers/scsi/isci/host.c
index 7b497f2667b7..156b37563761 100644
--- a/drivers/scsi/isci/host.c
+++ b/drivers/scsi/isci/host.c
@@ -1115,7 +1115,7 @@ static enum sci_status scic_controller_start(struct scic_sds_controller *scic,
 
 	scic_sds_controller_start_next_phy(scic);
 
-	isci_timer_start(scic->timeout_timer, timeout);
+	sci_mod_timer(&scic->timer, timeout);
 
 	sci_base_state_machine_change_state(&scic->state_machine,
 					    SCI_BASE_CONTROLLER_STATE_STARTING);
@@ -1296,7 +1296,7 @@ static enum sci_status scic_controller_stop(struct scic_sds_controller *scic,
 		return SCI_FAILURE_INVALID_STATE;
 	}
 
-	isci_timer_start(scic->timeout_timer, timeout);
+	sci_mod_timer(&scic->timer, timeout);
 	sci_base_state_machine_change_state(&scic->state_machine,
 					    SCI_BASE_CONTROLLER_STATE_STOPPING);
 	return SCI_SUCCESS;
@@ -1376,6 +1376,8 @@ void isci_host_deinit(struct isci_host *ihost)
 
 	del_timer_sync(&ihost->sci.power_control.timer.timer);
 
+	del_timer_sync(&ihost->sci.timer.timer);
+
 	isci_timer_list_destroy(ihost);
 }
 
@@ -1433,7 +1435,7 @@ static inline void scic_sds_controller_starting_state_exit(struct sci_base_state
 {
 	struct scic_sds_controller *scic = container_of(sm, typeof(*scic), state_machine);
 
-	isci_timer_stop(scic->timeout_timer);
+	sci_del_timer(&scic->timer);
 }
 
 #define INTERRUPT_COALESCE_TIMEOUT_BASE_RANGE_LOWER_BOUND_NS 853
@@ -1669,7 +1671,7 @@ static void scic_sds_controller_stopping_state_exit(struct sci_base_state_machin
 {
 	struct scic_sds_controller *scic = container_of(sm, typeof(*scic), state_machine);
 
-	isci_timer_stop(scic->timeout_timer);
+	sci_del_timer(&scic->timer);
 }
 
 
@@ -1776,7 +1778,33 @@ static void scic_sds_controller_set_default_config_parameters(struct scic_sds_co
 	scic->user_parameters.sds1.no_outbound_task_timeout = 20;
 }
 
+static void controller_timeout(unsigned long data)
+{
+	struct sci_timer *tmr = (struct sci_timer *)data;
+	struct scic_sds_controller *scic = container_of(tmr, typeof(*scic), timer);
+	struct isci_host *ihost = scic_to_ihost(scic);
+	struct sci_base_state_machine *sm = &scic->state_machine;
+	unsigned long flags;
+
+	spin_lock_irqsave(&ihost->scic_lock, flags);
+
+	if (tmr->cancel)
+		goto done;
+
+	if (sm->current_state_id == SCI_BASE_CONTROLLER_STATE_STARTING)
+		scic_sds_controller_transition_to_ready(scic, SCI_FAILURE_TIMEOUT);
+	else if (sm->current_state_id == SCI_BASE_CONTROLLER_STATE_STOPPING) {
+		sci_base_state_machine_change_state(sm, SCI_BASE_CONTROLLER_STATE_FAILED);
+		isci_host_stop_complete(ihost, SCI_FAILURE_TIMEOUT);
+	} else	/* / @todo Now what do we want to do in this case? */
+		dev_err(scic_to_dev(scic),
+			"%s: Controller timer fired when controller was not "
+			"in a state being timed.\n",
+			__func__);
 
+done:
+	spin_unlock_irqrestore(&ihost->scic_lock, flags);
+}
 
 /**
  * scic_controller_construct() - This method will attempt to construct a
@@ -1826,6 +1854,8 @@ static enum sci_status scic_controller_construct(struct scic_sds_controller *sci
 
 	scic->invalid_phy_mask = 0;
 
+	sci_init_timer(&scic->timer, controller_timeout);
+
 	/* Set the default maximum values */
 	scic->completion_event_entries      = SCU_EVENT_COUNT;
 	scic->completion_queue_entries      = SCU_COMPLETION_QUEUE_COUNT;
@@ -1901,24 +1931,6 @@ void scic_oem_parameters_get(
 	memcpy(scic_parms, (&scic->oem_parameters), sizeof(*scic_parms));
 }
 
-static void scic_sds_controller_timeout_handler(void *_scic)
-{
-	struct scic_sds_controller *scic = _scic;
-	struct isci_host *ihost = scic_to_ihost(scic);
-	struct sci_base_state_machine *sm = &scic->state_machine;
-
-	if (sm->current_state_id == SCI_BASE_CONTROLLER_STATE_STARTING)
-		scic_sds_controller_transition_to_ready(scic, SCI_FAILURE_TIMEOUT);
-	else if (sm->current_state_id == SCI_BASE_CONTROLLER_STATE_STOPPING) {
-		sci_base_state_machine_change_state(sm, SCI_BASE_CONTROLLER_STATE_FAILED);
-		isci_host_stop_complete(ihost, SCI_FAILURE_TIMEOUT);
-	} else	/* / @todo Now what do we want to do in this case? */
-		dev_err(scic_to_dev(scic),
-			"%s: Controller timer fired when controller was not "
-			"in a state being timed.\n",
-			__func__);
-}
-
 static enum sci_status scic_sds_controller_initialize_phy_startup(struct scic_sds_controller *scic)
 {
 	struct isci_host *ihost = scic_to_ihost(scic);
@@ -2246,9 +2258,6 @@ static enum sci_status scic_controller_initialize(struct scic_sds_controller *sc
 
 	sci_base_state_machine_change_state(sm, SCI_BASE_CONTROLLER_STATE_INITIALIZING);
 
-	scic->timeout_timer = isci_timer_create(ihost, scic,
-						scic_sds_controller_timeout_handler);
-
 	scic_sds_controller_initialize_phy_startup(scic);
 
 	scic_sds_controller_initialize_power_control(scic);

commit 0473661a125905240879456567e117ed8a58cf5d
Author: Edmund Nadolski <edmund.nadolski@intel.com>
Date:   Thu May 19 20:17:47 2011 -0700

    isci: convert power control timer to sci_timer
    
    Signed-off-by: Edmund Nadolski <edmund.nadolski@intel.com>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/drivers/scsi/isci/host.c b/drivers/scsi/isci/host.c
index aa00cce37821..7b497f2667b7 100644
--- a/drivers/scsi/isci/host.c
+++ b/drivers/scsi/isci/host.c
@@ -1374,6 +1374,8 @@ void isci_host_deinit(struct isci_host *ihost)
 
 	del_timer_sync(&ihost->sci.port_agent.timer.timer);
 
+	del_timer_sync(&ihost->sci.power_control.timer.timer);
+
 	isci_timer_list_destroy(ihost);
 }
 
@@ -1935,67 +1937,55 @@ static enum sci_status scic_sds_controller_initialize_phy_startup(struct scic_sd
 	return SCI_SUCCESS;
 }
 
-static void scic_sds_controller_power_control_timer_start(struct scic_sds_controller *scic)
+static void power_control_timeout(unsigned long data)
 {
-	isci_timer_start(scic->power_control.timer,
-			 SCIC_SDS_CONTROLLER_POWER_CONTROL_INTERVAL);
+	struct sci_timer *tmr = (struct sci_timer *)data;
+	struct scic_sds_controller *scic = container_of(tmr, typeof(*scic), power_control.timer);
+	struct isci_host *ihost = scic_to_ihost(scic);
+	struct scic_sds_phy *sci_phy;
+	unsigned long flags;
+	u8 i;
 
-	scic->power_control.timer_started = true;
-}
+	spin_lock_irqsave(&ihost->scic_lock, flags);
 
-static void scic_sds_controller_power_control_timer_stop(struct scic_sds_controller *scic)
-{
-	if (scic->power_control.timer_started) {
-		isci_timer_stop(scic->power_control.timer);
+	if (tmr->cancel)
+		goto done;
+
+	scic->power_control.phys_granted_power = 0;
+
+	if (scic->power_control.phys_waiting == 0) {
 		scic->power_control.timer_started = false;
+		goto done;
 	}
-}
-
-static void scic_sds_controller_power_control_timer_restart(struct scic_sds_controller *scic)
-{
-	scic_sds_controller_power_control_timer_stop(scic);
-	scic_sds_controller_power_control_timer_start(scic);
-}
 
-static void scic_sds_controller_power_control_timer_handler(
-	void *controller)
-{
-	struct scic_sds_controller *scic;
+	for (i = 0; i < SCI_MAX_PHYS; i++) {
 
-	scic = (struct scic_sds_controller *)controller;
+		if (scic->power_control.phys_waiting == 0)
+			break;
 
-	scic->power_control.phys_granted_power = 0;
+		sci_phy = scic->power_control.requesters[i];
+		if (sci_phy == NULL)
+			continue;
 
-	if (scic->power_control.phys_waiting == 0) {
-		scic->power_control.timer_started = false;
-	} else {
-		struct scic_sds_phy *sci_phy = NULL;
-		u8 i;
-
-		for (i = 0;
-		     (i < SCI_MAX_PHYS)
-		     && (scic->power_control.phys_waiting != 0);
-		     i++) {
-			if (scic->power_control.requesters[i] != NULL) {
-				if (scic->power_control.phys_granted_power <
-				    scic->oem_parameters.sds1.controller.max_concurrent_dev_spin_up) {
-					sci_phy = scic->power_control.requesters[i];
-					scic->power_control.requesters[i] = NULL;
-					scic->power_control.phys_waiting--;
-					scic->power_control.phys_granted_power++;
-					scic_sds_phy_consume_power_handler(sci_phy);
-				} else {
-					break;
-				}
-			}
-		}
+		if (scic->power_control.phys_granted_power >=
+		    scic->oem_parameters.sds1.controller.max_concurrent_dev_spin_up)
+			break;
 
-		/*
-		 * It doesn't matter if the power list is empty, we need to start the
-		 * timer in case another phy becomes ready.
-		 */
-		scic_sds_controller_power_control_timer_start(scic);
+		scic->power_control.requesters[i] = NULL;
+		scic->power_control.phys_waiting--;
+		scic->power_control.phys_granted_power++;
+		scic_sds_phy_consume_power_handler(sci_phy);
 	}
+
+	/*
+	 * It doesn't matter if the power list is empty, we need to start the
+	 * timer in case another phy becomes ready.
+	 */
+	sci_mod_timer(tmr, SCIC_SDS_CONTROLLER_POWER_CONTROL_INTERVAL);
+	scic->power_control.timer_started = true;
+
+done:
+	spin_unlock_irqrestore(&ihost->scic_lock, flags);
 }
 
 /**
@@ -2019,7 +2009,13 @@ void scic_sds_controller_power_control_queue_insert(
 		 * stop and start the power_control timer. When the timer fires, the
 		 * no_of_phys_granted_power will be set to 0
 		 */
-		scic_sds_controller_power_control_timer_restart(scic);
+		if (scic->power_control.timer_started)
+			sci_del_timer(&scic->power_control.timer);
+
+		sci_mod_timer(&scic->power_control.timer,
+				 SCIC_SDS_CONTROLLER_POWER_CONTROL_INTERVAL);
+		scic->power_control.timer_started = true;
+
 	} else {
 		/* Add the phy in the waiting list */
 		scic->power_control.requesters[sci_phy->phy_index] = sci_phy;
@@ -2224,10 +2220,7 @@ static enum sci_status scic_controller_set_mode(struct scic_sds_controller *scic
 
 static void scic_sds_controller_initialize_power_control(struct scic_sds_controller *scic)
 {
-	struct isci_host *ihost = scic_to_ihost(scic);
-	scic->power_control.timer = isci_timer_create(ihost,
-						      scic,
-					scic_sds_controller_power_control_timer_handler);
+	sci_init_timer(&scic->power_control.timer, power_control_timeout);
 
 	memset(scic->power_control.requesters, 0,
 	       sizeof(scic->power_control.requesters));

commit a628d478570d71fb8751ad09b8017139c5056002
Author: Edmund Nadolski <edmund.nadolski@intel.com>
Date:   Thu May 19 11:59:36 2011 +0000

    isci: convert phy sata_timeout_timer to sci_timer
    
    Convert the sata_timeout_timer in the scic_sds_phy struct to
    use a struct sci_timer
    
    Signed-off-by: Edmund Nadolski <edmund.nadolski@intel.com>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/drivers/scsi/isci/host.c b/drivers/scsi/isci/host.c
index 468357ffc771..aa00cce37821 100644
--- a/drivers/scsi/isci/host.c
+++ b/drivers/scsi/isci/host.c
@@ -1366,6 +1366,12 @@ void isci_host_deinit(struct isci_host *ihost)
 		del_timer_sync(&sci_port->timer.timer);
 	}
 
+	/* Cancel any/all outstanding phy timers */
+	for (i = 0; i < SCI_MAX_PHYS; i++) {
+		struct scic_sds_phy *sci_phy = &ihost->phys[i].sci;
+		del_timer_sync(&sci_phy->sata_timer.timer);
+	}
+
 	del_timer_sync(&ihost->sci.port_agent.timer.timer);
 
 	isci_timer_list_destroy(ihost);

commit ac0eeb4f774261d1da21a68169f7ddd4f6c082fc
Author: Edmund Nadolski <edmund.nadolski@intel.com>
Date:   Thu May 19 20:00:51 2011 -0700

    isci: convert port config agent timer to sci_timer
    
    Signed-off-by: Edmund Nadolski <edmund.nadolski@intel.com>
    [squashed collateral cleanups]
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/drivers/scsi/isci/host.c b/drivers/scsi/isci/host.c
index a3269b6fa225..468357ffc771 100644
--- a/drivers/scsi/isci/host.c
+++ b/drivers/scsi/isci/host.c
@@ -1366,6 +1366,8 @@ void isci_host_deinit(struct isci_host *ihost)
 		del_timer_sync(&sci_port->timer.timer);
 	}
 
+	del_timer_sync(&ihost->sci.port_agent.timer.timer);
+
 	isci_timer_list_destroy(ihost);
 }
 

commit 5553ba2be0f3e3741e1a885a33d2b89921f9fd48
Author: Edmund Nadolski <edmund.nadolski@intel.com>
Date:   Thu May 19 11:59:10 2011 +0000

    isci: replace isci_timer list with proper embedded timers
    
    Rather than preallocating a list of timers and doling them out at runtime,
    embed a struct timerlist in each object that needs one.  A struct sci_timer
    interface is introduced to manage the timer cancellation semantics which
    currently need to guarantee the timer is cancelled while holding
    spin_lock(ihost->scic_lock).  Since the timeout functions also need to acquire
    the lock it currently prevents the driver from using del_timer_sync() for
    runtime cancellations.
    
    del_timer_sync() is used however before the objects go out of scope.
    
    Signed-off-by: Edmund Nadolski <edmund.nadolski@intel.com>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/drivers/scsi/isci/host.c b/drivers/scsi/isci/host.c
index 6cd7648197e1..a3269b6fa225 100644
--- a/drivers/scsi/isci/host.c
+++ b/drivers/scsi/isci/host.c
@@ -1359,6 +1359,13 @@ void isci_host_deinit(struct isci_host *ihost)
 
 	wait_for_stop(ihost);
 	scic_controller_reset(&ihost->sci);
+
+	/* Cancel any/all outstanding port timers */
+	for (i = 0; i < ihost->sci.logical_port_entries; i++) {
+		struct scic_sds_port *sci_port = &ihost->ports[i].sci;
+		del_timer_sync(&sci_port->timer.timer);
+	}
+
 	isci_timer_list_destroy(ihost);
 }
 

commit 9269e0e898594c65dee6b20d4ed48e33dbbd4eeb
Author: Dan Williams <dan.j.williams@intel.com>
Date:   Thu May 12 07:42:17 2011 -0700

    isci: add some type safety to the state machine interface
    
    Now that any given object type only has one state_machine we can use
    container_of() to get back to the given state machine owner.
    
    Reported-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/drivers/scsi/isci/host.c b/drivers/scsi/isci/host.c
index a942384f2798..6cd7648197e1 100644
--- a/drivers/scsi/isci/host.c
+++ b/drivers/scsi/isci/host.c
@@ -1404,17 +1404,17 @@ static void isci_user_parameters_get(
 	u->max_number_concurrent_device_spin_up = max_concurr_spinup;
 }
 
-static void scic_sds_controller_initial_state_enter(void *object)
+static void scic_sds_controller_initial_state_enter(struct sci_base_state_machine *sm)
 {
-	struct scic_sds_controller *scic = object;
+	struct scic_sds_controller *scic = container_of(sm, typeof(*scic), state_machine);
 
 	sci_base_state_machine_change_state(&scic->state_machine,
 			SCI_BASE_CONTROLLER_STATE_RESET);
 }
 
-static inline void scic_sds_controller_starting_state_exit(void *object)
+static inline void scic_sds_controller_starting_state_exit(struct sci_base_state_machine *sm)
 {
-	struct scic_sds_controller *scic = object;
+	struct scic_sds_controller *scic = container_of(sm, typeof(*scic), state_machine);
 
 	isci_timer_stop(scic->timeout_timer);
 }
@@ -1539,17 +1539,17 @@ static enum sci_status scic_controller_set_interrupt_coalescence(
 }
 
 
-static void scic_sds_controller_ready_state_enter(void *object)
+static void scic_sds_controller_ready_state_enter(struct sci_base_state_machine *sm)
 {
-	struct scic_sds_controller *scic = object;
+	struct scic_sds_controller *scic = container_of(sm, typeof(*scic), state_machine);
 
 	/* set the default interrupt coalescence number and timeout value. */
 	scic_controller_set_interrupt_coalescence(scic, 0x10, 250);
 }
 
-static void scic_sds_controller_ready_state_exit(void *object)
+static void scic_sds_controller_ready_state_exit(struct sci_base_state_machine *sm)
 {
-	struct scic_sds_controller *scic = object;
+	struct scic_sds_controller *scic = container_of(sm, typeof(*scic), state_machine);
 
 	/* disable interrupt coalescence. */
 	scic_controller_set_interrupt_coalescence(scic, 0, 0);
@@ -1638,9 +1638,9 @@ static enum sci_status scic_sds_controller_stop_devices(struct scic_sds_controll
 	return status;
 }
 
-static void scic_sds_controller_stopping_state_enter(void *object)
+static void scic_sds_controller_stopping_state_enter(struct sci_base_state_machine *sm)
 {
-	struct scic_sds_controller *scic = object;
+	struct scic_sds_controller *scic = container_of(sm, typeof(*scic), state_machine);
 
 	/* Stop all of the components for this controller */
 	scic_sds_controller_stop_phys(scic);
@@ -1648,9 +1648,9 @@ static void scic_sds_controller_stopping_state_enter(void *object)
 	scic_sds_controller_stop_devices(scic);
 }
 
-static void scic_sds_controller_stopping_state_exit(void *object)
+static void scic_sds_controller_stopping_state_exit(struct sci_base_state_machine *sm)
 {
-	struct scic_sds_controller *scic = object;
+	struct scic_sds_controller *scic = container_of(sm, typeof(*scic), state_machine);
 
 	isci_timer_stop(scic->timeout_timer);
 }
@@ -1679,9 +1679,9 @@ static void scic_sds_controller_reset_hardware(struct scic_sds_controller *scic)
 	writel(0, &scic->scu_registers->sdma.unsolicited_frame_get_pointer);
 }
 
-static void scic_sds_controller_resetting_state_enter(void *object)
+static void scic_sds_controller_resetting_state_enter(struct sci_base_state_machine *sm)
 {
-	struct scic_sds_controller *scic = object;
+	struct scic_sds_controller *scic = container_of(sm, typeof(*scic), state_machine);
 
 	scic_sds_controller_reset_hardware(scic);
 	sci_base_state_machine_change_state(&scic->state_machine,
@@ -1785,8 +1785,8 @@ static enum sci_status scic_controller_construct(struct scic_sds_controller *sci
 	u8 i;
 
 	sci_base_state_machine_construct(&scic->state_machine,
-		scic, scic_sds_controller_state_table,
-		SCI_BASE_CONTROLLER_STATE_INITIAL);
+					 scic_sds_controller_state_table,
+					 SCI_BASE_CONTROLLER_STATE_INITIAL);
 
 	sci_base_state_machine_start(&scic->state_machine);
 

commit 8bc80d303063d9540493be623df1c9a8dee9ccb8
Author: Piotr Sawicki <piotr.sawicki@intel.com>
Date:   Wed May 11 23:52:31 2011 +0000

    isci: unify port stop handlers
    
    Implement the stop handlers directly in scic_sds_port_stop()
    
    Reported-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Piotr Sawicki <piotr.sawicki@intel.com>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/drivers/scsi/isci/host.c b/drivers/scsi/isci/host.c
index 7abfb663ca94..a942384f2798 100644
--- a/drivers/scsi/isci/host.c
+++ b/drivers/scsi/isci/host.c
@@ -1591,10 +1591,8 @@ static enum sci_status scic_sds_controller_stop_ports(struct scic_sds_controller
 
 	for (index = 0; index < scic->logical_port_entries; index++) {
 		struct scic_sds_port *sci_port = &ihost->ports[index].sci;
-		scic_sds_port_handler_t stop;
 
-		stop = sci_port->state_handlers->stop_handler;
-		port_status = stop(sci_port);
+		port_status = scic_sds_port_stop(sci_port);
 
 		if ((port_status != SCI_SUCCESS) &&
 		    (port_status != SCI_FAILURE_INVALID_STATE)) {

commit d76f71d988ef48384593ad97ebc762d9257d96a8
Author: Piotr Sawicki <piotr.sawicki@intel.com>
Date:   Wed May 11 23:52:26 2011 +0000

    isci: remove port start handler
    
    remove the handler from the port state handler table and implement the
    logic directly in scic_sds_port_start().
    
    Signed-off-by: Piotr Sawicki <piotr.sawicki@intel.com>
    [remove a level of indirection]
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/drivers/scsi/isci/host.c b/drivers/scsi/isci/host.c
index 2ef1c592a16f..7abfb663ca94 100644
--- a/drivers/scsi/isci/host.c
+++ b/drivers/scsi/isci/host.c
@@ -1108,7 +1108,7 @@ static enum sci_status scic_controller_start(struct scic_sds_controller *scic,
 	for (index = 0; index < scic->logical_port_entries; index++) {
 		struct scic_sds_port *sci_port = &ihost->ports[index].sci;
 
-		result = sci_port->state_handlers->start_handler(sci_port);
+		result = scic_sds_port_start(sci_port);
 		if (result)
 			return result;
 	}

commit 4f20ef4f57aa52fd3356c143a8f3d2bd18dc61fc
Author: Dan Williams <dan.j.williams@intel.com>
Date:   Thu May 12 06:00:31 2011 -0700

    isci: clarify phy to port lookups
    
    While cleaning up the driver it is very tempting to convert scic_sds_get_*
    macros to their open coded equivalent.  They are all just pointer dereferences
    *except* scic_sds_phy_get_port() which returns NULL if the phy is assigned to
    the dummy port.  Clarify this by renaming it to phy_get_non_dummy_port().
    
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/drivers/scsi/isci/host.c b/drivers/scsi/isci/host.c
index 675eddd3963e..2ef1c592a16f 100644
--- a/drivers/scsi/isci/host.c
+++ b/drivers/scsi/isci/host.c
@@ -983,7 +983,7 @@ static enum sci_status scic_sds_controller_start_next_phy(struct scic_sds_contro
 			sci_phy = &ihost->phys[index].sci;
 			state = sci_phy->state_machine.current_state_id;
 
-			if (!scic_sds_phy_get_port(sci_phy))
+			if (!phy_get_non_dummy_port(sci_phy))
 				continue;
 
 			/* The controller start operation is complete iff:
@@ -1014,7 +1014,7 @@ static enum sci_status scic_sds_controller_start_next_phy(struct scic_sds_contro
 		sci_phy = &ihost->phys[scic->next_phy_to_start].sci;
 
 		if (oem->controller.mode_type == SCIC_PORT_MANUAL_CONFIGURATION_MODE) {
-			if (scic_sds_phy_get_port(sci_phy) == NULL) {
+			if (phy_get_non_dummy_port(sci_phy) == NULL) {
 				scic->next_phy_to_start++;
 
 				/* Caution recursion ahead be forwarned

commit 4a33c525f0e94b57602abd1e43644cbf6f5418f4
Author: Adam Gruchala <adam.gruchala@intel.com>
Date:   Tue May 10 23:54:23 2011 +0000

    isci: merge phy substates
    
    Merged states and substates into one state machine, as we always
    unconditionally transitioned to the substate machine it was straightforward to
    enter that substate from the starting state.
    
    Reported-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Adam Gruchala <adam.gruchala@intel.com>
    [fixed construction, starting_state_enter, and starting check]
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/drivers/scsi/isci/host.c b/drivers/scsi/isci/host.c
index 2bb9f1073e73..675eddd3963e 100644
--- a/drivers/scsi/isci/host.c
+++ b/drivers/scsi/isci/host.c
@@ -932,6 +932,28 @@ static void scic_sds_controller_phy_timer_start(struct scic_sds_controller *scic
 	scic->phy_startup_timer_pending = true;
 }
 
+static bool is_phy_starting(struct scic_sds_phy *sci_phy)
+{
+	enum scic_sds_phy_states state;
+
+	state = sci_phy->state_machine.current_state_id;
+	switch (state) {
+	case SCI_BASE_PHY_STATE_STARTING:
+	case SCIC_SDS_PHY_STARTING_SUBSTATE_INITIAL:
+	case SCIC_SDS_PHY_STARTING_SUBSTATE_AWAIT_SAS_SPEED_EN:
+	case SCIC_SDS_PHY_STARTING_SUBSTATE_AWAIT_IAF_UF:
+	case SCIC_SDS_PHY_STARTING_SUBSTATE_AWAIT_SAS_POWER:
+	case SCIC_SDS_PHY_STARTING_SUBSTATE_AWAIT_SATA_POWER:
+	case SCIC_SDS_PHY_STARTING_SUBSTATE_AWAIT_SATA_PHY_EN:
+	case SCIC_SDS_PHY_STARTING_SUBSTATE_AWAIT_SATA_SPEED_EN:
+	case SCIC_SDS_PHY_STARTING_SUBSTATE_AWAIT_SIG_FIS_UF:
+	case SCIC_SDS_PHY_STARTING_SUBSTATE_FINAL:
+		return true;
+	default:
+		return false;
+	}
+}
+
 /**
  * scic_sds_controller_start_next_phy - start phy
  * @scic: controller
@@ -975,7 +997,7 @@ static enum sci_status scic_sds_controller_start_next_phy(struct scic_sds_contro
 			    (sci_phy->is_in_link_training == false &&
 			     state == SCI_BASE_PHY_STATE_STOPPED) ||
 			    (sci_phy->is_in_link_training == true &&
-			     state == SCI_BASE_PHY_STATE_STARTING)) {
+			     is_phy_starting(sci_phy))) {
 				is_controller_start_complete = false;
 				break;
 			}

commit e2f8db509fdd354bb7a68c86515e9d2d8909ccc9
Author: Dan Williams <dan.j.williams@intel.com>
Date:   Tue May 10 02:28:46 2011 -0700

    isci: uplevel port infrastructure
    
    * Move port configuration agent implementation
    * Merge core/scic_sds_port.[ch] into port.[ch]
    
    Reported-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/drivers/scsi/isci/host.c b/drivers/scsi/isci/host.c
index e1930da08d4e..2bb9f1073e73 100644
--- a/drivers/scsi/isci/host.c
+++ b/drivers/scsi/isci/host.c
@@ -61,7 +61,6 @@
 #include "probe_roms.h"
 #include "remote_device.h"
 #include "request.h"
-#include "scic_sds_port_configuration_agent.h"
 #include "scu_completion_codes.h"
 #include "scu_event_codes.h"
 #include "registers.h"

commit f1f52e75939b56c40b3d153ae99faf2720250242
Author: Dan Williams <dan.j.williams@intel.com>
Date:   Tue May 10 02:28:45 2011 -0700

    isci: uplevel request infrastructure
    
    * Consolidate tiny header files
    * Move files out of core/ (drop core/scic_sds_ prefix)
    * Merge core/scic_sds_request.[ch] into request.[ch]
    * Cleanup request.c namespace (clean forward declarations and global
      namespace pollution)
    
    Reported-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/drivers/scsi/isci/host.c b/drivers/scsi/isci/host.c
index 71a0466d1c8e..e1930da08d4e 100644
--- a/drivers/scsi/isci/host.c
+++ b/drivers/scsi/isci/host.c
@@ -61,9 +61,7 @@
 #include "probe_roms.h"
 #include "remote_device.h"
 #include "request.h"
-#include "scic_io_request.h"
 #include "scic_sds_port_configuration_agent.h"
-#include "sci_util.h"
 #include "scu_completion_codes.h"
 #include "scu_event_codes.h"
 #include "registers.h"

commit 63a3a15fb00ef49e50e98ff675094afcd92f113a
Author: Dan Williams <dan.j.williams@intel.com>
Date:   Sun May 8 21:36:46 2011 -0700

    isci: uplevel register hardware data structures and unsolicited frame handling
    
    Reported-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/drivers/scsi/isci/host.c b/drivers/scsi/isci/host.c
index 43a5d7a8b291..71a0466d1c8e 100644
--- a/drivers/scsi/isci/host.c
+++ b/drivers/scsi/isci/host.c
@@ -66,7 +66,7 @@
 #include "sci_util.h"
 #include "scu_completion_codes.h"
 #include "scu_event_codes.h"
-#include "scu_registers.h"
+#include "registers.h"
 #include "scu_remote_node_context.h"
 #include "scu_task_context.h"
 #include "scu_unsolicited_frame.h"

commit cc9203bf381a465cd115762b9cf7c9a313c874bc
Author: Dan Williams <dan.j.williams@intel.com>
Date:   Sun May 8 17:34:44 2011 -0700

    isci: move core/controller to host
    
    Now that the data structures are unified unify the implementation in
    host.[ch] and cleanup namespace pollution.
    
    Reported-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/drivers/scsi/isci/host.c b/drivers/scsi/isci/host.c
index 5847149857a9..43a5d7a8b291 100644
--- a/drivers/scsi/isci/host.c
+++ b/drivers/scsi/isci/host.c
@@ -52,18 +52,198 @@
  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
-
+#include <linux/device.h>
+#include <scsi/sas.h>
+#include "host.h"
 #include "isci.h"
-#include "scic_io_request.h"
-#include "scic_port.h"
 #include "port.h"
-#include "request.h"
 #include "host.h"
 #include "probe_roms.h"
-#include "scic_controller.h"
-#include "scic_sds_controller.h"
+#include "remote_device.h"
+#include "request.h"
+#include "scic_io_request.h"
+#include "scic_sds_port_configuration_agent.h"
+#include "sci_util.h"
+#include "scu_completion_codes.h"
+#include "scu_event_codes.h"
+#include "scu_registers.h"
+#include "scu_remote_node_context.h"
+#include "scu_task_context.h"
+#include "scu_unsolicited_frame.h"
 #include "timers.h"
 
+#define SCU_CONTEXT_RAM_INIT_STALL_TIME      200
+
+/**
+ * smu_dcc_get_max_ports() -
+ *
+ * This macro returns the maximum number of logical ports supported by the
+ * hardware. The caller passes in the value read from the device context
+ * capacity register and this macro will mash and shift the value appropriately.
+ */
+#define smu_dcc_get_max_ports(dcc_value) \
+	(\
+		(((dcc_value) & SMU_DEVICE_CONTEXT_CAPACITY_MAX_LP_MASK) \
+		 >> SMU_DEVICE_CONTEXT_CAPACITY_MAX_LP_SHIFT) + 1 \
+	)
+
+/**
+ * smu_dcc_get_max_task_context() -
+ *
+ * This macro returns the maximum number of task contexts supported by the
+ * hardware. The caller passes in the value read from the device context
+ * capacity register and this macro will mash and shift the value appropriately.
+ */
+#define smu_dcc_get_max_task_context(dcc_value)	\
+	(\
+		(((dcc_value) & SMU_DEVICE_CONTEXT_CAPACITY_MAX_TC_MASK) \
+		 >> SMU_DEVICE_CONTEXT_CAPACITY_MAX_TC_SHIFT) + 1 \
+	)
+
+/**
+ * smu_dcc_get_max_remote_node_context() -
+ *
+ * This macro returns the maximum number of remote node contexts supported by
+ * the hardware. The caller passes in the value read from the device context
+ * capacity register and this macro will mash and shift the value appropriately.
+ */
+#define smu_dcc_get_max_remote_node_context(dcc_value) \
+	(\
+		(((dcc_value) & SMU_DEVICE_CONTEXT_CAPACITY_MAX_RNC_MASK) \
+		 >> SMU_DEVICE_CONTEXT_CAPACITY_MAX_RNC_SHIFT) + 1 \
+	)
+
+
+#define SCIC_SDS_CONTROLLER_MIN_TIMER_COUNT  3
+#define SCIC_SDS_CONTROLLER_MAX_TIMER_COUNT  3
+
+/**
+ *
+ *
+ * The number of milliseconds to wait for a phy to start.
+ */
+#define SCIC_SDS_CONTROLLER_PHY_START_TIMEOUT      100
+
+/**
+ *
+ *
+ * The number of milliseconds to wait while a given phy is consuming power
+ * before allowing another set of phys to consume power. Ultimately, this will
+ * be specified by OEM parameter.
+ */
+#define SCIC_SDS_CONTROLLER_POWER_CONTROL_INTERVAL 500
+
+/**
+ * NORMALIZE_PUT_POINTER() -
+ *
+ * This macro will normalize the completion queue put pointer so its value can
+ * be used as an array inde
+ */
+#define NORMALIZE_PUT_POINTER(x) \
+	((x) & SMU_COMPLETION_QUEUE_PUT_POINTER_MASK)
+
+
+/**
+ * NORMALIZE_EVENT_POINTER() -
+ *
+ * This macro will normalize the completion queue event entry so its value can
+ * be used as an index.
+ */
+#define NORMALIZE_EVENT_POINTER(x) \
+	(\
+		((x) & SMU_COMPLETION_QUEUE_GET_EVENT_POINTER_MASK) \
+		>> SMU_COMPLETION_QUEUE_GET_EVENT_POINTER_SHIFT	\
+	)
+
+/**
+ * INCREMENT_COMPLETION_QUEUE_GET() -
+ *
+ * This macro will increment the controllers completion queue index value and
+ * possibly toggle the cycle bit if the completion queue index wraps back to 0.
+ */
+#define INCREMENT_COMPLETION_QUEUE_GET(controller, index, cycle) \
+	INCREMENT_QUEUE_GET(\
+		(index), \
+		(cycle), \
+		(controller)->completion_queue_entries,	\
+		SMU_CQGR_CYCLE_BIT \
+		)
+
+/**
+ * INCREMENT_EVENT_QUEUE_GET() -
+ *
+ * This macro will increment the controllers event queue index value and
+ * possibly toggle the event cycle bit if the event queue index wraps back to 0.
+ */
+#define INCREMENT_EVENT_QUEUE_GET(controller, index, cycle) \
+	INCREMENT_QUEUE_GET(\
+		(index), \
+		(cycle), \
+		(controller)->completion_event_entries,	\
+		SMU_CQGR_EVENT_CYCLE_BIT \
+		)
+
+
+/**
+ * NORMALIZE_GET_POINTER() -
+ *
+ * This macro will normalize the completion queue get pointer so its value can
+ * be used as an index into an array
+ */
+#define NORMALIZE_GET_POINTER(x) \
+	((x) & SMU_COMPLETION_QUEUE_GET_POINTER_MASK)
+
+/**
+ * NORMALIZE_GET_POINTER_CYCLE_BIT() -
+ *
+ * This macro will normalize the completion queue cycle pointer so it matches
+ * the completion queue cycle bit
+ */
+#define NORMALIZE_GET_POINTER_CYCLE_BIT(x) \
+	((SMU_CQGR_CYCLE_BIT & (x)) << (31 - SMU_COMPLETION_QUEUE_GET_CYCLE_BIT_SHIFT))
+
+/**
+ * COMPLETION_QUEUE_CYCLE_BIT() -
+ *
+ * This macro will return the cycle bit of the completion queue entry
+ */
+#define COMPLETION_QUEUE_CYCLE_BIT(x) ((x) & 0x80000000)
+
+static bool scic_sds_controller_completion_queue_has_entries(
+	struct scic_sds_controller *scic)
+{
+	u32 get_value = scic->completion_queue_get;
+	u32 get_index = get_value & SMU_COMPLETION_QUEUE_GET_POINTER_MASK;
+
+	if (NORMALIZE_GET_POINTER_CYCLE_BIT(get_value) ==
+	    COMPLETION_QUEUE_CYCLE_BIT(scic->completion_queue[get_index]))
+		return true;
+
+	return false;
+}
+
+static bool scic_sds_controller_isr(struct scic_sds_controller *scic)
+{
+	if (scic_sds_controller_completion_queue_has_entries(scic)) {
+		return true;
+	} else {
+		/*
+		 * we have a spurious interrupt it could be that we have already
+		 * emptied the completion queue from a previous interrupt */
+		writel(SMU_ISR_COMPLETION, &scic->smu_registers->interrupt_status);
+
+		/*
+		 * There is a race in the hardware that could cause us not to be notified
+		 * of an interrupt completion if we do not take this step.  We will mask
+		 * then unmask the interrupts so if there is another interrupt pending
+		 * the clearing of the interrupt source we get the next interrupt message. */
+		writel(0xFF000000, &scic->smu_registers->interrupt_mask);
+		writel(0, &scic->smu_registers->interrupt_mask);
+	}
+
+	return false;
+}
+
 irqreturn_t isci_msix_isr(int vec, void *data)
 {
 	struct isci_host *ihost = data;
@@ -74,6 +254,411 @@ irqreturn_t isci_msix_isr(int vec, void *data)
 	return IRQ_HANDLED;
 }
 
+static bool scic_sds_controller_error_isr(struct scic_sds_controller *scic)
+{
+	u32 interrupt_status;
+
+	interrupt_status =
+		readl(&scic->smu_registers->interrupt_status);
+	interrupt_status &= (SMU_ISR_QUEUE_ERROR | SMU_ISR_QUEUE_SUSPEND);
+
+	if (interrupt_status != 0) {
+		/*
+		 * There is an error interrupt pending so let it through and handle
+		 * in the callback */
+		return true;
+	}
+
+	/*
+	 * There is a race in the hardware that could cause us not to be notified
+	 * of an interrupt completion if we do not take this step.  We will mask
+	 * then unmask the error interrupts so if there was another interrupt
+	 * pending we will be notified.
+	 * Could we write the value of (SMU_ISR_QUEUE_ERROR | SMU_ISR_QUEUE_SUSPEND)? */
+	writel(0xff, &scic->smu_registers->interrupt_mask);
+	writel(0, &scic->smu_registers->interrupt_mask);
+
+	return false;
+}
+
+static void scic_sds_controller_task_completion(struct scic_sds_controller *scic,
+						u32 completion_entry)
+{
+	u32 index;
+	struct scic_sds_request *io_request;
+
+	index = SCU_GET_COMPLETION_INDEX(completion_entry);
+	io_request = scic->io_request_table[index];
+
+	/* Make sure that we really want to process this IO request */
+	if (
+		(io_request != NULL)
+		&& (io_request->io_tag != SCI_CONTROLLER_INVALID_IO_TAG)
+		&& (
+			scic_sds_io_tag_get_sequence(io_request->io_tag)
+			== scic->io_request_sequence[index]
+			)
+		) {
+		/* Yep this is a valid io request pass it along to the io request handler */
+		scic_sds_io_request_tc_completion(io_request, completion_entry);
+	}
+}
+
+static void scic_sds_controller_sdma_completion(struct scic_sds_controller *scic,
+						u32 completion_entry)
+{
+	u32 index;
+	struct scic_sds_request *io_request;
+	struct scic_sds_remote_device *device;
+
+	index = SCU_GET_COMPLETION_INDEX(completion_entry);
+
+	switch (scu_get_command_request_type(completion_entry)) {
+	case SCU_CONTEXT_COMMAND_REQUEST_TYPE_POST_TC:
+	case SCU_CONTEXT_COMMAND_REQUEST_TYPE_DUMP_TC:
+		io_request = scic->io_request_table[index];
+		dev_warn(scic_to_dev(scic),
+			 "%s: SCIC SDS Completion type SDMA %x for io request "
+			 "%p\n",
+			 __func__,
+			 completion_entry,
+			 io_request);
+		/* @todo For a post TC operation we need to fail the IO
+		 * request
+		 */
+		break;
+
+	case SCU_CONTEXT_COMMAND_REQUEST_TYPE_DUMP_RNC:
+	case SCU_CONTEXT_COMMAND_REQUEST_TYPE_OTHER_RNC:
+	case SCU_CONTEXT_COMMAND_REQUEST_TYPE_POST_RNC:
+		device = scic->device_table[index];
+		dev_warn(scic_to_dev(scic),
+			 "%s: SCIC SDS Completion type SDMA %x for remote "
+			 "device %p\n",
+			 __func__,
+			 completion_entry,
+			 device);
+		/* @todo For a port RNC operation we need to fail the
+		 * device
+		 */
+		break;
+
+	default:
+		dev_warn(scic_to_dev(scic),
+			 "%s: SCIC SDS Completion unknown SDMA completion "
+			 "type %x\n",
+			 __func__,
+			 completion_entry);
+		break;
+
+	}
+}
+
+static void scic_sds_controller_unsolicited_frame(struct scic_sds_controller *scic,
+						  u32 completion_entry)
+{
+	u32 index;
+	u32 frame_index;
+
+	struct isci_host *ihost = scic_to_ihost(scic);
+	struct scu_unsolicited_frame_header *frame_header;
+	struct scic_sds_phy *phy;
+	struct scic_sds_remote_device *device;
+
+	enum sci_status result = SCI_FAILURE;
+
+	frame_index = SCU_GET_FRAME_INDEX(completion_entry);
+
+	frame_header = scic->uf_control.buffers.array[frame_index].header;
+	scic->uf_control.buffers.array[frame_index].state = UNSOLICITED_FRAME_IN_USE;
+
+	if (SCU_GET_FRAME_ERROR(completion_entry)) {
+		/*
+		 * / @todo If the IAF frame or SIGNATURE FIS frame has an error will
+		 * /       this cause a problem? We expect the phy initialization will
+		 * /       fail if there is an error in the frame. */
+		scic_sds_controller_release_frame(scic, frame_index);
+		return;
+	}
+
+	if (frame_header->is_address_frame) {
+		index = SCU_GET_PROTOCOL_ENGINE_INDEX(completion_entry);
+		phy = &ihost->phys[index].sci;
+		result = scic_sds_phy_frame_handler(phy, frame_index);
+	} else {
+
+		index = SCU_GET_COMPLETION_INDEX(completion_entry);
+
+		if (index == SCIC_SDS_REMOTE_NODE_CONTEXT_INVALID_INDEX) {
+			/*
+			 * This is a signature fis or a frame from a direct attached SATA
+			 * device that has not yet been created.  In either case forwared
+			 * the frame to the PE and let it take care of the frame data. */
+			index = SCU_GET_PROTOCOL_ENGINE_INDEX(completion_entry);
+			phy = &ihost->phys[index].sci;
+			result = scic_sds_phy_frame_handler(phy, frame_index);
+		} else {
+			if (index < scic->remote_node_entries)
+				device = scic->device_table[index];
+			else
+				device = NULL;
+
+			if (device != NULL)
+				result = scic_sds_remote_device_frame_handler(device, frame_index);
+			else
+				scic_sds_controller_release_frame(scic, frame_index);
+		}
+	}
+
+	if (result != SCI_SUCCESS) {
+		/*
+		 * / @todo Is there any reason to report some additional error message
+		 * /       when we get this failure notifiction? */
+	}
+}
+
+static void scic_sds_controller_event_completion(struct scic_sds_controller *scic,
+						 u32 completion_entry)
+{
+	struct isci_host *ihost = scic_to_ihost(scic);
+	struct scic_sds_request *io_request;
+	struct scic_sds_remote_device *device;
+	struct scic_sds_phy *phy;
+	u32 index;
+
+	index = SCU_GET_COMPLETION_INDEX(completion_entry);
+
+	switch (scu_get_event_type(completion_entry)) {
+	case SCU_EVENT_TYPE_SMU_COMMAND_ERROR:
+		/* / @todo The driver did something wrong and we need to fix the condtion. */
+		dev_err(scic_to_dev(scic),
+			"%s: SCIC Controller 0x%p received SMU command error "
+			"0x%x\n",
+			__func__,
+			scic,
+			completion_entry);
+		break;
+
+	case SCU_EVENT_TYPE_SMU_PCQ_ERROR:
+	case SCU_EVENT_TYPE_SMU_ERROR:
+	case SCU_EVENT_TYPE_FATAL_MEMORY_ERROR:
+		/*
+		 * / @todo This is a hardware failure and its likely that we want to
+		 * /       reset the controller. */
+		dev_err(scic_to_dev(scic),
+			"%s: SCIC Controller 0x%p received fatal controller "
+			"event  0x%x\n",
+			__func__,
+			scic,
+			completion_entry);
+		break;
+
+	case SCU_EVENT_TYPE_TRANSPORT_ERROR:
+		io_request = scic->io_request_table[index];
+		scic_sds_io_request_event_handler(io_request, completion_entry);
+		break;
+
+	case SCU_EVENT_TYPE_PTX_SCHEDULE_EVENT:
+		switch (scu_get_event_specifier(completion_entry)) {
+		case SCU_EVENT_SPECIFIC_SMP_RESPONSE_NO_PE:
+		case SCU_EVENT_SPECIFIC_TASK_TIMEOUT:
+			io_request = scic->io_request_table[index];
+			if (io_request != NULL)
+				scic_sds_io_request_event_handler(io_request, completion_entry);
+			else
+				dev_warn(scic_to_dev(scic),
+					 "%s: SCIC Controller 0x%p received "
+					 "event 0x%x for io request object "
+					 "that doesnt exist.\n",
+					 __func__,
+					 scic,
+					 completion_entry);
+
+			break;
+
+		case SCU_EVENT_SPECIFIC_IT_NEXUS_TIMEOUT:
+			device = scic->device_table[index];
+			if (device != NULL)
+				scic_sds_remote_device_event_handler(device, completion_entry);
+			else
+				dev_warn(scic_to_dev(scic),
+					 "%s: SCIC Controller 0x%p received "
+					 "event 0x%x for remote device object "
+					 "that doesnt exist.\n",
+					 __func__,
+					 scic,
+					 completion_entry);
+
+			break;
+		}
+		break;
+
+	case SCU_EVENT_TYPE_BROADCAST_CHANGE:
+	/*
+	 * direct the broadcast change event to the phy first and then let
+	 * the phy redirect the broadcast change to the port object */
+	case SCU_EVENT_TYPE_ERR_CNT_EVENT:
+	/*
+	 * direct error counter event to the phy object since that is where
+	 * we get the event notification.  This is a type 4 event. */
+	case SCU_EVENT_TYPE_OSSP_EVENT:
+		index = SCU_GET_PROTOCOL_ENGINE_INDEX(completion_entry);
+		phy = &ihost->phys[index].sci;
+		scic_sds_phy_event_handler(phy, completion_entry);
+		break;
+
+	case SCU_EVENT_TYPE_RNC_SUSPEND_TX:
+	case SCU_EVENT_TYPE_RNC_SUSPEND_TX_RX:
+	case SCU_EVENT_TYPE_RNC_OPS_MISC:
+		if (index < scic->remote_node_entries) {
+			device = scic->device_table[index];
+
+			if (device != NULL)
+				scic_sds_remote_device_event_handler(device, completion_entry);
+		} else
+			dev_err(scic_to_dev(scic),
+				"%s: SCIC Controller 0x%p received event 0x%x "
+				"for remote device object 0x%0x that doesnt "
+				"exist.\n",
+				__func__,
+				scic,
+				completion_entry,
+				index);
+
+		break;
+
+	default:
+		dev_warn(scic_to_dev(scic),
+			 "%s: SCIC Controller received unknown event code %x\n",
+			 __func__,
+			 completion_entry);
+		break;
+	}
+}
+
+
+
+static void scic_sds_controller_process_completions(struct scic_sds_controller *scic)
+{
+	u32 completion_count = 0;
+	u32 completion_entry;
+	u32 get_index;
+	u32 get_cycle;
+	u32 event_index;
+	u32 event_cycle;
+
+	dev_dbg(scic_to_dev(scic),
+		"%s: completion queue begining get:0x%08x\n",
+		__func__,
+		scic->completion_queue_get);
+
+	/* Get the component parts of the completion queue */
+	get_index = NORMALIZE_GET_POINTER(scic->completion_queue_get);
+	get_cycle = SMU_CQGR_CYCLE_BIT & scic->completion_queue_get;
+
+	event_index = NORMALIZE_EVENT_POINTER(scic->completion_queue_get);
+	event_cycle = SMU_CQGR_EVENT_CYCLE_BIT & scic->completion_queue_get;
+
+	while (
+		NORMALIZE_GET_POINTER_CYCLE_BIT(get_cycle)
+		== COMPLETION_QUEUE_CYCLE_BIT(scic->completion_queue[get_index])
+		) {
+		completion_count++;
+
+		completion_entry = scic->completion_queue[get_index];
+		INCREMENT_COMPLETION_QUEUE_GET(scic, get_index, get_cycle);
+
+		dev_dbg(scic_to_dev(scic),
+			"%s: completion queue entry:0x%08x\n",
+			__func__,
+			completion_entry);
+
+		switch (SCU_GET_COMPLETION_TYPE(completion_entry)) {
+		case SCU_COMPLETION_TYPE_TASK:
+			scic_sds_controller_task_completion(scic, completion_entry);
+			break;
+
+		case SCU_COMPLETION_TYPE_SDMA:
+			scic_sds_controller_sdma_completion(scic, completion_entry);
+			break;
+
+		case SCU_COMPLETION_TYPE_UFI:
+			scic_sds_controller_unsolicited_frame(scic, completion_entry);
+			break;
+
+		case SCU_COMPLETION_TYPE_EVENT:
+			INCREMENT_EVENT_QUEUE_GET(scic, event_index, event_cycle);
+			scic_sds_controller_event_completion(scic, completion_entry);
+			break;
+
+		case SCU_COMPLETION_TYPE_NOTIFY:
+			/*
+			 * Presently we do the same thing with a notify event that we do with the
+			 * other event codes. */
+			INCREMENT_EVENT_QUEUE_GET(scic, event_index, event_cycle);
+			scic_sds_controller_event_completion(scic, completion_entry);
+			break;
+
+		default:
+			dev_warn(scic_to_dev(scic),
+				 "%s: SCIC Controller received unknown "
+				 "completion type %x\n",
+				 __func__,
+				 completion_entry);
+			break;
+		}
+	}
+
+	/* Update the get register if we completed one or more entries */
+	if (completion_count > 0) {
+		scic->completion_queue_get =
+			SMU_CQGR_GEN_BIT(ENABLE) |
+			SMU_CQGR_GEN_BIT(EVENT_ENABLE) |
+			event_cycle |
+			SMU_CQGR_GEN_VAL(EVENT_POINTER, event_index) |
+			get_cycle |
+			SMU_CQGR_GEN_VAL(POINTER, get_index);
+
+		writel(scic->completion_queue_get,
+		       &scic->smu_registers->completion_queue_get);
+
+	}
+
+	dev_dbg(scic_to_dev(scic),
+		"%s: completion queue ending get:0x%08x\n",
+		__func__,
+		scic->completion_queue_get);
+
+}
+
+static void scic_sds_controller_error_handler(struct scic_sds_controller *scic)
+{
+	u32 interrupt_status;
+
+	interrupt_status =
+		readl(&scic->smu_registers->interrupt_status);
+
+	if ((interrupt_status & SMU_ISR_QUEUE_SUSPEND) &&
+	    scic_sds_controller_completion_queue_has_entries(scic)) {
+
+		scic_sds_controller_process_completions(scic);
+		writel(SMU_ISR_QUEUE_SUSPEND, &scic->smu_registers->interrupt_status);
+	} else {
+		dev_err(scic_to_dev(scic), "%s: status: %#x\n", __func__,
+			interrupt_status);
+
+		sci_base_state_machine_change_state(&scic->state_machine,
+						    SCI_BASE_CONTROLLER_STATE_FAILED);
+
+		return;
+	}
+
+	/* If we dont process any completions I am not sure that we want to do this.
+	 * We are in the middle of a hardware fault and should probably be reset.
+	 */
+	writel(0, &scic->smu_registers->interrupt_mask);
+}
+
 irqreturn_t isci_intx_isr(int vec, void *data)
 {
 	irqreturn_t ret = IRQ_NONE;
@@ -112,7 +697,7 @@ irqreturn_t isci_error_isr(int vec, void *data)
  *    core library.
  *
  */
-void isci_host_start_complete(struct isci_host *ihost, enum sci_status completion_status)
+static void isci_host_start_complete(struct isci_host *ihost, enum sci_status completion_status)
 {
 	if (completion_status != SCI_SUCCESS)
 		dev_info(&ihost->pdev->dev,
@@ -142,6 +727,383 @@ int isci_host_scan_finished(struct Scsi_Host *shost, unsigned long time)
 
 }
 
+/**
+ * scic_controller_get_suggested_start_timeout() - This method returns the
+ *    suggested scic_controller_start() timeout amount.  The user is free to
+ *    use any timeout value, but this method provides the suggested minimum
+ *    start timeout value.  The returned value is based upon empirical
+ *    information determined as a result of interoperability testing.
+ * @controller: the handle to the controller object for which to return the
+ *    suggested start timeout.
+ *
+ * This method returns the number of milliseconds for the suggested start
+ * operation timeout.
+ */
+static u32 scic_controller_get_suggested_start_timeout(
+	struct scic_sds_controller *sc)
+{
+	/* Validate the user supplied parameters. */
+	if (sc == NULL)
+		return 0;
+
+	/*
+	 * The suggested minimum timeout value for a controller start operation:
+	 *
+	 *     Signature FIS Timeout
+	 *   + Phy Start Timeout
+	 *   + Number of Phy Spin Up Intervals
+	 *   ---------------------------------
+	 *   Number of milliseconds for the controller start operation.
+	 *
+	 * NOTE: The number of phy spin up intervals will be equivalent
+	 *       to the number of phys divided by the number phys allowed
+	 *       per interval - 1 (once OEM parameters are supported).
+	 *       Currently we assume only 1 phy per interval. */
+
+	return SCIC_SDS_SIGNATURE_FIS_TIMEOUT
+		+ SCIC_SDS_CONTROLLER_PHY_START_TIMEOUT
+		+ ((SCI_MAX_PHYS - 1) * SCIC_SDS_CONTROLLER_POWER_CONTROL_INTERVAL);
+}
+
+static void scic_controller_enable_interrupts(
+	struct scic_sds_controller *scic)
+{
+	BUG_ON(scic->smu_registers == NULL);
+	writel(0, &scic->smu_registers->interrupt_mask);
+}
+
+void scic_controller_disable_interrupts(
+	struct scic_sds_controller *scic)
+{
+	BUG_ON(scic->smu_registers == NULL);
+	writel(0xffffffff, &scic->smu_registers->interrupt_mask);
+}
+
+static void scic_sds_controller_enable_port_task_scheduler(
+	struct scic_sds_controller *scic)
+{
+	u32 port_task_scheduler_value;
+
+	port_task_scheduler_value =
+		readl(&scic->scu_registers->peg0.ptsg.control);
+	port_task_scheduler_value |=
+		(SCU_PTSGCR_GEN_BIT(ETM_ENABLE) |
+		 SCU_PTSGCR_GEN_BIT(PTSG_ENABLE));
+	writel(port_task_scheduler_value,
+	       &scic->scu_registers->peg0.ptsg.control);
+}
+
+static void scic_sds_controller_assign_task_entries(struct scic_sds_controller *scic)
+{
+	u32 task_assignment;
+
+	/*
+	 * Assign all the TCs to function 0
+	 * TODO: Do we actually need to read this register to write it back?
+	 */
+
+	task_assignment =
+		readl(&scic->smu_registers->task_context_assignment[0]);
+
+	task_assignment |= (SMU_TCA_GEN_VAL(STARTING, 0)) |
+		(SMU_TCA_GEN_VAL(ENDING,  scic->task_context_entries - 1)) |
+		(SMU_TCA_GEN_BIT(RANGE_CHECK_ENABLE));
+
+	writel(task_assignment,
+		&scic->smu_registers->task_context_assignment[0]);
+
+}
+
+static void scic_sds_controller_initialize_completion_queue(struct scic_sds_controller *scic)
+{
+	u32 index;
+	u32 completion_queue_control_value;
+	u32 completion_queue_get_value;
+	u32 completion_queue_put_value;
+
+	scic->completion_queue_get = 0;
+
+	completion_queue_control_value = (
+		SMU_CQC_QUEUE_LIMIT_SET(scic->completion_queue_entries - 1)
+		| SMU_CQC_EVENT_LIMIT_SET(scic->completion_event_entries - 1)
+		);
+
+	writel(completion_queue_control_value,
+	       &scic->smu_registers->completion_queue_control);
+
+
+	/* Set the completion queue get pointer and enable the queue */
+	completion_queue_get_value = (
+		(SMU_CQGR_GEN_VAL(POINTER, 0))
+		| (SMU_CQGR_GEN_VAL(EVENT_POINTER, 0))
+		| (SMU_CQGR_GEN_BIT(ENABLE))
+		| (SMU_CQGR_GEN_BIT(EVENT_ENABLE))
+		);
+
+	writel(completion_queue_get_value,
+	       &scic->smu_registers->completion_queue_get);
+
+	/* Set the completion queue put pointer */
+	completion_queue_put_value = (
+		(SMU_CQPR_GEN_VAL(POINTER, 0))
+		| (SMU_CQPR_GEN_VAL(EVENT_POINTER, 0))
+		);
+
+	writel(completion_queue_put_value,
+	       &scic->smu_registers->completion_queue_put);
+
+	/* Initialize the cycle bit of the completion queue entries */
+	for (index = 0; index < scic->completion_queue_entries; index++) {
+		/*
+		 * If get.cycle_bit != completion_queue.cycle_bit
+		 * its not a valid completion queue entry
+		 * so at system start all entries are invalid */
+		scic->completion_queue[index] = 0x80000000;
+	}
+}
+
+static void scic_sds_controller_initialize_unsolicited_frame_queue(struct scic_sds_controller *scic)
+{
+	u32 frame_queue_control_value;
+	u32 frame_queue_get_value;
+	u32 frame_queue_put_value;
+
+	/* Write the queue size */
+	frame_queue_control_value =
+		SCU_UFQC_GEN_VAL(QUEUE_SIZE,
+				 scic->uf_control.address_table.count);
+
+	writel(frame_queue_control_value,
+	       &scic->scu_registers->sdma.unsolicited_frame_queue_control);
+
+	/* Setup the get pointer for the unsolicited frame queue */
+	frame_queue_get_value = (
+		SCU_UFQGP_GEN_VAL(POINTER, 0)
+		|  SCU_UFQGP_GEN_BIT(ENABLE_BIT)
+		);
+
+	writel(frame_queue_get_value,
+	       &scic->scu_registers->sdma.unsolicited_frame_get_pointer);
+	/* Setup the put pointer for the unsolicited frame queue */
+	frame_queue_put_value = SCU_UFQPP_GEN_VAL(POINTER, 0);
+	writel(frame_queue_put_value,
+	       &scic->scu_registers->sdma.unsolicited_frame_put_pointer);
+}
+
+/**
+ * This method will attempt to transition into the ready state for the
+ *    controller and indicate that the controller start operation has completed
+ *    if all criteria are met.
+ * @scic: This parameter indicates the controller object for which
+ *    to transition to ready.
+ * @status: This parameter indicates the status value to be pass into the call
+ *    to scic_cb_controller_start_complete().
+ *
+ * none.
+ */
+static void scic_sds_controller_transition_to_ready(
+	struct scic_sds_controller *scic,
+	enum sci_status status)
+{
+	struct isci_host *ihost = scic_to_ihost(scic);
+
+	if (scic->state_machine.current_state_id ==
+	    SCI_BASE_CONTROLLER_STATE_STARTING) {
+		/*
+		 * We move into the ready state, because some of the phys/ports
+		 * may be up and operational.
+		 */
+		sci_base_state_machine_change_state(&scic->state_machine,
+						    SCI_BASE_CONTROLLER_STATE_READY);
+
+		isci_host_start_complete(ihost, status);
+	}
+}
+
+static void scic_sds_controller_phy_timer_stop(struct scic_sds_controller *scic)
+{
+	isci_timer_stop(scic->phy_startup_timer);
+
+	scic->phy_startup_timer_pending = false;
+}
+
+static void scic_sds_controller_phy_timer_start(struct scic_sds_controller *scic)
+{
+	isci_timer_start(scic->phy_startup_timer,
+			 SCIC_SDS_CONTROLLER_PHY_START_TIMEOUT);
+
+	scic->phy_startup_timer_pending = true;
+}
+
+/**
+ * scic_sds_controller_start_next_phy - start phy
+ * @scic: controller
+ *
+ * If all the phys have been started, then attempt to transition the
+ * controller to the READY state and inform the user
+ * (scic_cb_controller_start_complete()).
+ */
+static enum sci_status scic_sds_controller_start_next_phy(struct scic_sds_controller *scic)
+{
+	struct isci_host *ihost = scic_to_ihost(scic);
+	struct scic_sds_oem_params *oem = &scic->oem_parameters.sds1;
+	struct scic_sds_phy *sci_phy;
+	enum sci_status status;
+
+	status = SCI_SUCCESS;
+
+	if (scic->phy_startup_timer_pending)
+		return status;
+
+	if (scic->next_phy_to_start >= SCI_MAX_PHYS) {
+		bool is_controller_start_complete = true;
+		u32 state;
+		u8 index;
+
+		for (index = 0; index < SCI_MAX_PHYS; index++) {
+			sci_phy = &ihost->phys[index].sci;
+			state = sci_phy->state_machine.current_state_id;
+
+			if (!scic_sds_phy_get_port(sci_phy))
+				continue;
+
+			/* The controller start operation is complete iff:
+			 * - all links have been given an opportunity to start
+			 * - have no indication of a connected device
+			 * - have an indication of a connected device and it has
+			 *   finished the link training process.
+			 */
+			if ((sci_phy->is_in_link_training == false &&
+			     state == SCI_BASE_PHY_STATE_INITIAL) ||
+			    (sci_phy->is_in_link_training == false &&
+			     state == SCI_BASE_PHY_STATE_STOPPED) ||
+			    (sci_phy->is_in_link_training == true &&
+			     state == SCI_BASE_PHY_STATE_STARTING)) {
+				is_controller_start_complete = false;
+				break;
+			}
+		}
+
+		/*
+		 * The controller has successfully finished the start process.
+		 * Inform the SCI Core user and transition to the READY state. */
+		if (is_controller_start_complete == true) {
+			scic_sds_controller_transition_to_ready(scic, SCI_SUCCESS);
+			scic_sds_controller_phy_timer_stop(scic);
+		}
+	} else {
+		sci_phy = &ihost->phys[scic->next_phy_to_start].sci;
+
+		if (oem->controller.mode_type == SCIC_PORT_MANUAL_CONFIGURATION_MODE) {
+			if (scic_sds_phy_get_port(sci_phy) == NULL) {
+				scic->next_phy_to_start++;
+
+				/* Caution recursion ahead be forwarned
+				 *
+				 * The PHY was never added to a PORT in MPC mode
+				 * so start the next phy in sequence This phy
+				 * will never go link up and will not draw power
+				 * the OEM parameters either configured the phy
+				 * incorrectly for the PORT or it was never
+				 * assigned to a PORT
+				 */
+				return scic_sds_controller_start_next_phy(scic);
+			}
+		}
+
+		status = scic_sds_phy_start(sci_phy);
+
+		if (status == SCI_SUCCESS) {
+			scic_sds_controller_phy_timer_start(scic);
+		} else {
+			dev_warn(scic_to_dev(scic),
+				 "%s: Controller stop operation failed "
+				 "to stop phy %d because of status "
+				 "%d.\n",
+				 __func__,
+				 ihost->phys[scic->next_phy_to_start].sci.phy_index,
+				 status);
+		}
+
+		scic->next_phy_to_start++;
+	}
+
+	return status;
+}
+
+static void scic_sds_controller_phy_startup_timeout_handler(void *_scic)
+{
+	struct scic_sds_controller *scic = _scic;
+	enum sci_status status;
+
+	scic->phy_startup_timer_pending = false;
+	status = SCI_FAILURE;
+	while (status != SCI_SUCCESS)
+		status = scic_sds_controller_start_next_phy(scic);
+}
+
+static enum sci_status scic_controller_start(struct scic_sds_controller *scic,
+					     u32 timeout)
+{
+	struct isci_host *ihost = scic_to_ihost(scic);
+	enum sci_status result;
+	u16 index;
+
+	if (scic->state_machine.current_state_id !=
+	    SCI_BASE_CONTROLLER_STATE_INITIALIZED) {
+		dev_warn(scic_to_dev(scic),
+			 "SCIC Controller start operation requested in "
+			 "invalid state\n");
+		return SCI_FAILURE_INVALID_STATE;
+	}
+
+	/* Build the TCi free pool */
+	sci_pool_initialize(scic->tci_pool);
+	for (index = 0; index < scic->task_context_entries; index++)
+		sci_pool_put(scic->tci_pool, index);
+
+	/* Build the RNi free pool */
+	scic_sds_remote_node_table_initialize(
+			&scic->available_remote_nodes,
+			scic->remote_node_entries);
+
+	/*
+	 * Before anything else lets make sure we will not be
+	 * interrupted by the hardware.
+	 */
+	scic_controller_disable_interrupts(scic);
+
+	/* Enable the port task scheduler */
+	scic_sds_controller_enable_port_task_scheduler(scic);
+
+	/* Assign all the task entries to scic physical function */
+	scic_sds_controller_assign_task_entries(scic);
+
+	/* Now initialize the completion queue */
+	scic_sds_controller_initialize_completion_queue(scic);
+
+	/* Initialize the unsolicited frame queue for use */
+	scic_sds_controller_initialize_unsolicited_frame_queue(scic);
+
+	/* Start all of the ports on this controller */
+	for (index = 0; index < scic->logical_port_entries; index++) {
+		struct scic_sds_port *sci_port = &ihost->ports[index].sci;
+
+		result = sci_port->state_handlers->start_handler(sci_port);
+		if (result)
+			return result;
+	}
+
+	scic_sds_controller_start_next_phy(scic);
+
+	isci_timer_start(scic->timeout_timer, timeout);
+
+	sci_base_state_machine_change_state(&scic->state_machine,
+					    SCI_BASE_CONTROLLER_STATE_STARTING);
+
+	return SCI_SUCCESS;
+}
+
 void isci_host_scan_start(struct Scsi_Host *shost)
 {
 	struct isci_host *ihost = SHOST_TO_SAS_HA(shost)->lldd_ha;
@@ -155,7 +1117,7 @@ void isci_host_scan_start(struct Scsi_Host *shost)
 	spin_unlock_irq(&ihost->scic_lock);
 }
 
-void isci_host_stop_complete(struct isci_host *ihost, enum sci_status completion_status)
+static void isci_host_stop_complete(struct isci_host *ihost, enum sci_status completion_status)
 {
 	isci_host_change_state(ihost, isci_stopped);
 	scic_controller_disable_interrupts(&ihost->sci);
@@ -163,6 +1125,19 @@ void isci_host_stop_complete(struct isci_host *ihost, enum sci_status completion
 	wake_up(&ihost->eventq);
 }
 
+static void scic_sds_controller_completion_handler(struct scic_sds_controller *scic)
+{
+	/* Empty out the completion queue */
+	if (scic_sds_controller_completion_queue_has_entries(scic))
+		scic_sds_controller_process_completions(scic);
+
+	/* Clear the interrupt and enable all interrupts again */
+	writel(SMU_ISR_COMPLETION, &scic->smu_registers->interrupt_status);
+	/* Could we write the value of SMU_ISR_COMPLETION? */
+	writel(0xFF000000, &scic->smu_registers->interrupt_mask);
+	writel(0, &scic->smu_registers->interrupt_mask);
+}
+
 /**
  * isci_host_completion_routine() - This function is the delayed service
  *    routine that calls the sci core library's completion handler. It's
@@ -273,11 +1248,80 @@ static void isci_host_completion_routine(unsigned long data)
 
 }
 
-void isci_host_deinit(struct isci_host *ihost)
+/**
+ * scic_controller_stop() - This method will stop an individual controller
+ *    object.This method will invoke the associated user callback upon
+ *    completion.  The completion callback is called when the following
+ *    conditions are met: -# the method return status is SCI_SUCCESS. -# the
+ *    controller has been quiesced. This method will ensure that all IO
+ *    requests are quiesced, phys are stopped, and all additional operation by
+ *    the hardware is halted.
+ * @controller: the handle to the controller object to stop.
+ * @timeout: This parameter specifies the number of milliseconds in which the
+ *    stop operation should complete.
+ *
+ * The controller must be in the STARTED or STOPPED state. Indicate if the
+ * controller stop method succeeded or failed in some way. SCI_SUCCESS if the
+ * stop operation successfully began. SCI_WARNING_ALREADY_IN_STATE if the
+ * controller is already in the STOPPED state. SCI_FAILURE_INVALID_STATE if the
+ * controller is not either in the STARTED or STOPPED states.
+ */
+static enum sci_status scic_controller_stop(struct scic_sds_controller *scic,
+					    u32 timeout)
 {
-	int i;
+	if (scic->state_machine.current_state_id !=
+	    SCI_BASE_CONTROLLER_STATE_READY) {
+		dev_warn(scic_to_dev(scic),
+			 "SCIC Controller stop operation requested in "
+			 "invalid state\n");
+		return SCI_FAILURE_INVALID_STATE;
+	}
 
-	isci_host_change_state(ihost, isci_stopping);
+	isci_timer_start(scic->timeout_timer, timeout);
+	sci_base_state_machine_change_state(&scic->state_machine,
+					    SCI_BASE_CONTROLLER_STATE_STOPPING);
+	return SCI_SUCCESS;
+}
+
+/**
+ * scic_controller_reset() - This method will reset the supplied core
+ *    controller regardless of the state of said controller.  This operation is
+ *    considered destructive.  In other words, all current operations are wiped
+ *    out.  No IO completions for outstanding devices occur.  Outstanding IO
+ *    requests are not aborted or completed at the actual remote device.
+ * @controller: the handle to the controller object to reset.
+ *
+ * Indicate if the controller reset method succeeded or failed in some way.
+ * SCI_SUCCESS if the reset operation successfully started. SCI_FATAL_ERROR if
+ * the controller reset operation is unable to complete.
+ */
+static enum sci_status scic_controller_reset(struct scic_sds_controller *scic)
+{
+	switch (scic->state_machine.current_state_id) {
+	case SCI_BASE_CONTROLLER_STATE_RESET:
+	case SCI_BASE_CONTROLLER_STATE_READY:
+	case SCI_BASE_CONTROLLER_STATE_STOPPED:
+	case SCI_BASE_CONTROLLER_STATE_FAILED:
+		/*
+		 * The reset operation is not a graceful cleanup, just
+		 * perform the state transition.
+		 */
+		sci_base_state_machine_change_state(&scic->state_machine,
+				SCI_BASE_CONTROLLER_STATE_RESETTING);
+		return SCI_SUCCESS;
+	default:
+		dev_warn(scic_to_dev(scic),
+			 "SCIC Controller reset operation requested in "
+			 "invalid state\n");
+		return SCI_FAILURE_INVALID_STATE;
+	}
+}
+
+void isci_host_deinit(struct isci_host *ihost)
+{
+	int i;
+
+	isci_host_change_state(ihost, isci_stopping);
 	for (i = 0; i < SCI_MAX_PORTS; i++) {
 		struct isci_port *iport = &ihost->ports[i];
 		struct isci_remote_device *idev, *d;
@@ -341,6 +1385,1109 @@ static void isci_user_parameters_get(
 	u->max_number_concurrent_device_spin_up = max_concurr_spinup;
 }
 
+static void scic_sds_controller_initial_state_enter(void *object)
+{
+	struct scic_sds_controller *scic = object;
+
+	sci_base_state_machine_change_state(&scic->state_machine,
+			SCI_BASE_CONTROLLER_STATE_RESET);
+}
+
+static inline void scic_sds_controller_starting_state_exit(void *object)
+{
+	struct scic_sds_controller *scic = object;
+
+	isci_timer_stop(scic->timeout_timer);
+}
+
+#define INTERRUPT_COALESCE_TIMEOUT_BASE_RANGE_LOWER_BOUND_NS 853
+#define INTERRUPT_COALESCE_TIMEOUT_BASE_RANGE_UPPER_BOUND_NS 1280
+#define INTERRUPT_COALESCE_TIMEOUT_MAX_US                    2700000
+#define INTERRUPT_COALESCE_NUMBER_MAX                        256
+#define INTERRUPT_COALESCE_TIMEOUT_ENCODE_MIN                7
+#define INTERRUPT_COALESCE_TIMEOUT_ENCODE_MAX                28
+
+/**
+ * scic_controller_set_interrupt_coalescence() - This method allows the user to
+ *    configure the interrupt coalescence.
+ * @controller: This parameter represents the handle to the controller object
+ *    for which its interrupt coalesce register is overridden.
+ * @coalesce_number: Used to control the number of entries in the Completion
+ *    Queue before an interrupt is generated. If the number of entries exceed
+ *    this number, an interrupt will be generated. The valid range of the input
+ *    is [0, 256]. A setting of 0 results in coalescing being disabled.
+ * @coalesce_timeout: Timeout value in microseconds. The valid range of the
+ *    input is [0, 2700000] . A setting of 0 is allowed and results in no
+ *    interrupt coalescing timeout.
+ *
+ * Indicate if the user successfully set the interrupt coalesce parameters.
+ * SCI_SUCCESS The user successfully updated the interrutp coalescence.
+ * SCI_FAILURE_INVALID_PARAMETER_VALUE The user input value is out of range.
+ */
+static enum sci_status scic_controller_set_interrupt_coalescence(
+	struct scic_sds_controller *scic_controller,
+	u32 coalesce_number,
+	u32 coalesce_timeout)
+{
+	u8 timeout_encode = 0;
+	u32 min = 0;
+	u32 max = 0;
+
+	/* Check if the input parameters fall in the range. */
+	if (coalesce_number > INTERRUPT_COALESCE_NUMBER_MAX)
+		return SCI_FAILURE_INVALID_PARAMETER_VALUE;
+
+	/*
+	 *  Defined encoding for interrupt coalescing timeout:
+	 *              Value   Min      Max     Units
+	 *              -----   ---      ---     -----
+	 *              0       -        -       Disabled
+	 *              1       13.3     20.0    ns
+	 *              2       26.7     40.0
+	 *              3       53.3     80.0
+	 *              4       106.7    160.0
+	 *              5       213.3    320.0
+	 *              6       426.7    640.0
+	 *              7       853.3    1280.0
+	 *              8       1.7      2.6     us
+	 *              9       3.4      5.1
+	 *              10      6.8      10.2
+	 *              11      13.7     20.5
+	 *              12      27.3     41.0
+	 *              13      54.6     81.9
+	 *              14      109.2    163.8
+	 *              15      218.5    327.7
+	 *              16      436.9    655.4
+	 *              17      873.8    1310.7
+	 *              18      1.7      2.6     ms
+	 *              19      3.5      5.2
+	 *              20      7.0      10.5
+	 *              21      14.0     21.0
+	 *              22      28.0     41.9
+	 *              23      55.9     83.9
+	 *              24      111.8    167.8
+	 *              25      223.7    335.5
+	 *              26      447.4    671.1
+	 *              27      894.8    1342.2
+	 *              28      1.8      2.7     s
+	 *              Others Undefined */
+
+	/*
+	 * Use the table above to decide the encode of interrupt coalescing timeout
+	 * value for register writing. */
+	if (coalesce_timeout == 0)
+		timeout_encode = 0;
+	else{
+		/* make the timeout value in unit of (10 ns). */
+		coalesce_timeout = coalesce_timeout * 100;
+		min = INTERRUPT_COALESCE_TIMEOUT_BASE_RANGE_LOWER_BOUND_NS / 10;
+		max = INTERRUPT_COALESCE_TIMEOUT_BASE_RANGE_UPPER_BOUND_NS / 10;
+
+		/* get the encode of timeout for register writing. */
+		for (timeout_encode = INTERRUPT_COALESCE_TIMEOUT_ENCODE_MIN;
+		      timeout_encode <= INTERRUPT_COALESCE_TIMEOUT_ENCODE_MAX;
+		      timeout_encode++) {
+			if (min <= coalesce_timeout &&  max > coalesce_timeout)
+				break;
+			else if (coalesce_timeout >= max && coalesce_timeout < min * 2
+				 && coalesce_timeout <= INTERRUPT_COALESCE_TIMEOUT_MAX_US * 100) {
+				if ((coalesce_timeout - max) < (2 * min - coalesce_timeout))
+					break;
+				else{
+					timeout_encode++;
+					break;
+				}
+			} else {
+				max = max * 2;
+				min = min * 2;
+			}
+		}
+
+		if (timeout_encode == INTERRUPT_COALESCE_TIMEOUT_ENCODE_MAX + 1)
+			/* the value is out of range. */
+			return SCI_FAILURE_INVALID_PARAMETER_VALUE;
+	}
+
+	writel(SMU_ICC_GEN_VAL(NUMBER, coalesce_number) |
+	       SMU_ICC_GEN_VAL(TIMER, timeout_encode),
+	       &scic_controller->smu_registers->interrupt_coalesce_control);
+
+
+	scic_controller->interrupt_coalesce_number = (u16)coalesce_number;
+	scic_controller->interrupt_coalesce_timeout = coalesce_timeout / 100;
+
+	return SCI_SUCCESS;
+}
+
+
+static void scic_sds_controller_ready_state_enter(void *object)
+{
+	struct scic_sds_controller *scic = object;
+
+	/* set the default interrupt coalescence number and timeout value. */
+	scic_controller_set_interrupt_coalescence(scic, 0x10, 250);
+}
+
+static void scic_sds_controller_ready_state_exit(void *object)
+{
+	struct scic_sds_controller *scic = object;
+
+	/* disable interrupt coalescence. */
+	scic_controller_set_interrupt_coalescence(scic, 0, 0);
+}
+
+static enum sci_status scic_sds_controller_stop_phys(struct scic_sds_controller *scic)
+{
+	u32 index;
+	enum sci_status status;
+	enum sci_status phy_status;
+	struct isci_host *ihost = scic_to_ihost(scic);
+
+	status = SCI_SUCCESS;
+
+	for (index = 0; index < SCI_MAX_PHYS; index++) {
+		phy_status = scic_sds_phy_stop(&ihost->phys[index].sci);
+
+		if (phy_status != SCI_SUCCESS &&
+		    phy_status != SCI_FAILURE_INVALID_STATE) {
+			status = SCI_FAILURE;
+
+			dev_warn(scic_to_dev(scic),
+				 "%s: Controller stop operation failed to stop "
+				 "phy %d because of status %d.\n",
+				 __func__,
+				 ihost->phys[index].sci.phy_index, phy_status);
+		}
+	}
+
+	return status;
+}
+
+static enum sci_status scic_sds_controller_stop_ports(struct scic_sds_controller *scic)
+{
+	u32 index;
+	enum sci_status port_status;
+	enum sci_status status = SCI_SUCCESS;
+	struct isci_host *ihost = scic_to_ihost(scic);
+
+	for (index = 0; index < scic->logical_port_entries; index++) {
+		struct scic_sds_port *sci_port = &ihost->ports[index].sci;
+		scic_sds_port_handler_t stop;
+
+		stop = sci_port->state_handlers->stop_handler;
+		port_status = stop(sci_port);
+
+		if ((port_status != SCI_SUCCESS) &&
+		    (port_status != SCI_FAILURE_INVALID_STATE)) {
+			status = SCI_FAILURE;
+
+			dev_warn(scic_to_dev(scic),
+				 "%s: Controller stop operation failed to "
+				 "stop port %d because of status %d.\n",
+				 __func__,
+				 sci_port->logical_port_index,
+				 port_status);
+		}
+	}
+
+	return status;
+}
+
+static enum sci_status scic_sds_controller_stop_devices(struct scic_sds_controller *scic)
+{
+	u32 index;
+	enum sci_status status;
+	enum sci_status device_status;
+
+	status = SCI_SUCCESS;
+
+	for (index = 0; index < scic->remote_node_entries; index++) {
+		if (scic->device_table[index] != NULL) {
+			/* / @todo What timeout value do we want to provide to this request? */
+			device_status = scic_remote_device_stop(scic->device_table[index], 0);
+
+			if ((device_status != SCI_SUCCESS) &&
+			    (device_status != SCI_FAILURE_INVALID_STATE)) {
+				dev_warn(scic_to_dev(scic),
+					 "%s: Controller stop operation failed "
+					 "to stop device 0x%p because of "
+					 "status %d.\n",
+					 __func__,
+					 scic->device_table[index], device_status);
+			}
+		}
+	}
+
+	return status;
+}
+
+static void scic_sds_controller_stopping_state_enter(void *object)
+{
+	struct scic_sds_controller *scic = object;
+
+	/* Stop all of the components for this controller */
+	scic_sds_controller_stop_phys(scic);
+	scic_sds_controller_stop_ports(scic);
+	scic_sds_controller_stop_devices(scic);
+}
+
+static void scic_sds_controller_stopping_state_exit(void *object)
+{
+	struct scic_sds_controller *scic = object;
+
+	isci_timer_stop(scic->timeout_timer);
+}
+
+
+/**
+ * scic_sds_controller_reset_hardware() -
+ *
+ * This method will reset the controller hardware.
+ */
+static void scic_sds_controller_reset_hardware(struct scic_sds_controller *scic)
+{
+	/* Disable interrupts so we dont take any spurious interrupts */
+	scic_controller_disable_interrupts(scic);
+
+	/* Reset the SCU */
+	writel(0xFFFFFFFF, &scic->smu_registers->soft_reset_control);
+
+	/* Delay for 1ms to before clearing the CQP and UFQPR. */
+	udelay(1000);
+
+	/* The write to the CQGR clears the CQP */
+	writel(0x00000000, &scic->smu_registers->completion_queue_get);
+
+	/* The write to the UFQGP clears the UFQPR */
+	writel(0, &scic->scu_registers->sdma.unsolicited_frame_get_pointer);
+}
+
+static void scic_sds_controller_resetting_state_enter(void *object)
+{
+	struct scic_sds_controller *scic = object;
+
+	scic_sds_controller_reset_hardware(scic);
+	sci_base_state_machine_change_state(&scic->state_machine,
+					    SCI_BASE_CONTROLLER_STATE_RESET);
+}
+
+static const struct sci_base_state scic_sds_controller_state_table[] = {
+	[SCI_BASE_CONTROLLER_STATE_INITIAL] = {
+		.enter_state = scic_sds_controller_initial_state_enter,
+	},
+	[SCI_BASE_CONTROLLER_STATE_RESET] = {},
+	[SCI_BASE_CONTROLLER_STATE_INITIALIZING] = {},
+	[SCI_BASE_CONTROLLER_STATE_INITIALIZED] = {},
+	[SCI_BASE_CONTROLLER_STATE_STARTING] = {
+		.exit_state  = scic_sds_controller_starting_state_exit,
+	},
+	[SCI_BASE_CONTROLLER_STATE_READY] = {
+		.enter_state = scic_sds_controller_ready_state_enter,
+		.exit_state  = scic_sds_controller_ready_state_exit,
+	},
+	[SCI_BASE_CONTROLLER_STATE_RESETTING] = {
+		.enter_state = scic_sds_controller_resetting_state_enter,
+	},
+	[SCI_BASE_CONTROLLER_STATE_STOPPING] = {
+		.enter_state = scic_sds_controller_stopping_state_enter,
+		.exit_state = scic_sds_controller_stopping_state_exit,
+	},
+	[SCI_BASE_CONTROLLER_STATE_STOPPED] = {},
+	[SCI_BASE_CONTROLLER_STATE_FAILED] = {}
+};
+
+static void scic_sds_controller_set_default_config_parameters(struct scic_sds_controller *scic)
+{
+	/* these defaults are overridden by the platform / firmware */
+	struct isci_host *ihost = scic_to_ihost(scic);
+	u16 index;
+
+	/* Default to APC mode. */
+	scic->oem_parameters.sds1.controller.mode_type = SCIC_PORT_AUTOMATIC_CONFIGURATION_MODE;
+
+	/* Default to APC mode. */
+	scic->oem_parameters.sds1.controller.max_concurrent_dev_spin_up = 1;
+
+	/* Default to no SSC operation. */
+	scic->oem_parameters.sds1.controller.do_enable_ssc = false;
+
+	/* Initialize all of the port parameter information to narrow ports. */
+	for (index = 0; index < SCI_MAX_PORTS; index++) {
+		scic->oem_parameters.sds1.ports[index].phy_mask = 0;
+	}
+
+	/* Initialize all of the phy parameter information. */
+	for (index = 0; index < SCI_MAX_PHYS; index++) {
+		/* Default to 6G (i.e. Gen 3) for now. */
+		scic->user_parameters.sds1.phys[index].max_speed_generation = 3;
+
+		/* the frequencies cannot be 0 */
+		scic->user_parameters.sds1.phys[index].align_insertion_frequency = 0x7f;
+		scic->user_parameters.sds1.phys[index].in_connection_align_insertion_frequency = 0xff;
+		scic->user_parameters.sds1.phys[index].notify_enable_spin_up_insertion_frequency = 0x33;
+
+		/*
+		 * Previous Vitesse based expanders had a arbitration issue that
+		 * is worked around by having the upper 32-bits of SAS address
+		 * with a value greater then the Vitesse company identifier.
+		 * Hence, usage of 0x5FCFFFFF. */
+		scic->oem_parameters.sds1.phys[index].sas_address.low = 0x1 + ihost->id;
+		scic->oem_parameters.sds1.phys[index].sas_address.high = 0x5FCFFFFF;
+	}
+
+	scic->user_parameters.sds1.stp_inactivity_timeout = 5;
+	scic->user_parameters.sds1.ssp_inactivity_timeout = 5;
+	scic->user_parameters.sds1.stp_max_occupancy_timeout = 5;
+	scic->user_parameters.sds1.ssp_max_occupancy_timeout = 20;
+	scic->user_parameters.sds1.no_outbound_task_timeout = 20;
+}
+
+
+
+/**
+ * scic_controller_construct() - This method will attempt to construct a
+ *    controller object utilizing the supplied parameter information.
+ * @c: This parameter specifies the controller to be constructed.
+ * @scu_base: mapped base address of the scu registers
+ * @smu_base: mapped base address of the smu registers
+ *
+ * Indicate if the controller was successfully constructed or if it failed in
+ * some way. SCI_SUCCESS This value is returned if the controller was
+ * successfully constructed. SCI_WARNING_TIMER_CONFLICT This value is returned
+ * if the interrupt coalescence timer may cause SAS compliance issues for SMP
+ * Target mode response processing. SCI_FAILURE_UNSUPPORTED_CONTROLLER_TYPE
+ * This value is returned if the controller does not support the supplied type.
+ * SCI_FAILURE_UNSUPPORTED_INIT_DATA_VERSION This value is returned if the
+ * controller does not support the supplied initialization data version.
+ */
+static enum sci_status scic_controller_construct(struct scic_sds_controller *scic,
+					  void __iomem *scu_base,
+					  void __iomem *smu_base)
+{
+	struct isci_host *ihost = scic_to_ihost(scic);
+	u8 i;
+
+	sci_base_state_machine_construct(&scic->state_machine,
+		scic, scic_sds_controller_state_table,
+		SCI_BASE_CONTROLLER_STATE_INITIAL);
+
+	sci_base_state_machine_start(&scic->state_machine);
+
+	scic->scu_registers = scu_base;
+	scic->smu_registers = smu_base;
+
+	scic_sds_port_configuration_agent_construct(&scic->port_agent);
+
+	/* Construct the ports for this controller */
+	for (i = 0; i < SCI_MAX_PORTS; i++)
+		scic_sds_port_construct(&ihost->ports[i].sci, i, scic);
+	scic_sds_port_construct(&ihost->ports[i].sci, SCIC_SDS_DUMMY_PORT, scic);
+
+	/* Construct the phys for this controller */
+	for (i = 0; i < SCI_MAX_PHYS; i++) {
+		/* Add all the PHYs to the dummy port */
+		scic_sds_phy_construct(&ihost->phys[i].sci,
+				       &ihost->ports[SCI_MAX_PORTS].sci, i);
+	}
+
+	scic->invalid_phy_mask = 0;
+
+	/* Set the default maximum values */
+	scic->completion_event_entries      = SCU_EVENT_COUNT;
+	scic->completion_queue_entries      = SCU_COMPLETION_QUEUE_COUNT;
+	scic->remote_node_entries           = SCI_MAX_REMOTE_DEVICES;
+	scic->logical_port_entries          = SCI_MAX_PORTS;
+	scic->task_context_entries          = SCU_IO_REQUEST_COUNT;
+	scic->uf_control.buffers.count      = SCU_UNSOLICITED_FRAME_COUNT;
+	scic->uf_control.address_table.count = SCU_UNSOLICITED_FRAME_COUNT;
+
+	/* Initialize the User and OEM parameters to default values. */
+	scic_sds_controller_set_default_config_parameters(scic);
+
+	return scic_controller_reset(scic);
+}
+
+int scic_oem_parameters_validate(struct scic_sds_oem_params *oem)
+{
+	int i;
+
+	for (i = 0; i < SCI_MAX_PORTS; i++)
+		if (oem->ports[i].phy_mask > SCIC_SDS_PARM_PHY_MASK_MAX)
+			return -EINVAL;
+
+	for (i = 0; i < SCI_MAX_PHYS; i++)
+		if (oem->phys[i].sas_address.high == 0 &&
+		    oem->phys[i].sas_address.low == 0)
+			return -EINVAL;
+
+	if (oem->controller.mode_type == SCIC_PORT_AUTOMATIC_CONFIGURATION_MODE) {
+		for (i = 0; i < SCI_MAX_PHYS; i++)
+			if (oem->ports[i].phy_mask != 0)
+				return -EINVAL;
+	} else if (oem->controller.mode_type == SCIC_PORT_MANUAL_CONFIGURATION_MODE) {
+		u8 phy_mask = 0;
+
+		for (i = 0; i < SCI_MAX_PHYS; i++)
+			phy_mask |= oem->ports[i].phy_mask;
+
+		if (phy_mask == 0)
+			return -EINVAL;
+	} else
+		return -EINVAL;
+
+	if (oem->controller.max_concurrent_dev_spin_up > MAX_CONCURRENT_DEVICE_SPIN_UP_COUNT)
+		return -EINVAL;
+
+	return 0;
+}
+
+static enum sci_status scic_oem_parameters_set(struct scic_sds_controller *scic,
+					union scic_oem_parameters *scic_parms)
+{
+	u32 state = scic->state_machine.current_state_id;
+
+	if (state == SCI_BASE_CONTROLLER_STATE_RESET ||
+	    state == SCI_BASE_CONTROLLER_STATE_INITIALIZING ||
+	    state == SCI_BASE_CONTROLLER_STATE_INITIALIZED) {
+
+		if (scic_oem_parameters_validate(&scic_parms->sds1))
+			return SCI_FAILURE_INVALID_PARAMETER_VALUE;
+		scic->oem_parameters.sds1 = scic_parms->sds1;
+
+		return SCI_SUCCESS;
+	}
+
+	return SCI_FAILURE_INVALID_STATE;
+}
+
+void scic_oem_parameters_get(
+	struct scic_sds_controller *scic,
+	union scic_oem_parameters *scic_parms)
+{
+	memcpy(scic_parms, (&scic->oem_parameters), sizeof(*scic_parms));
+}
+
+static void scic_sds_controller_timeout_handler(void *_scic)
+{
+	struct scic_sds_controller *scic = _scic;
+	struct isci_host *ihost = scic_to_ihost(scic);
+	struct sci_base_state_machine *sm = &scic->state_machine;
+
+	if (sm->current_state_id == SCI_BASE_CONTROLLER_STATE_STARTING)
+		scic_sds_controller_transition_to_ready(scic, SCI_FAILURE_TIMEOUT);
+	else if (sm->current_state_id == SCI_BASE_CONTROLLER_STATE_STOPPING) {
+		sci_base_state_machine_change_state(sm, SCI_BASE_CONTROLLER_STATE_FAILED);
+		isci_host_stop_complete(ihost, SCI_FAILURE_TIMEOUT);
+	} else	/* / @todo Now what do we want to do in this case? */
+		dev_err(scic_to_dev(scic),
+			"%s: Controller timer fired when controller was not "
+			"in a state being timed.\n",
+			__func__);
+}
+
+static enum sci_status scic_sds_controller_initialize_phy_startup(struct scic_sds_controller *scic)
+{
+	struct isci_host *ihost = scic_to_ihost(scic);
+
+	scic->phy_startup_timer = isci_timer_create(ihost,
+						    scic,
+						    scic_sds_controller_phy_startup_timeout_handler);
+
+	if (scic->phy_startup_timer == NULL)
+		return SCI_FAILURE_INSUFFICIENT_RESOURCES;
+	else {
+		scic->next_phy_to_start = 0;
+		scic->phy_startup_timer_pending = false;
+	}
+
+	return SCI_SUCCESS;
+}
+
+static void scic_sds_controller_power_control_timer_start(struct scic_sds_controller *scic)
+{
+	isci_timer_start(scic->power_control.timer,
+			 SCIC_SDS_CONTROLLER_POWER_CONTROL_INTERVAL);
+
+	scic->power_control.timer_started = true;
+}
+
+static void scic_sds_controller_power_control_timer_stop(struct scic_sds_controller *scic)
+{
+	if (scic->power_control.timer_started) {
+		isci_timer_stop(scic->power_control.timer);
+		scic->power_control.timer_started = false;
+	}
+}
+
+static void scic_sds_controller_power_control_timer_restart(struct scic_sds_controller *scic)
+{
+	scic_sds_controller_power_control_timer_stop(scic);
+	scic_sds_controller_power_control_timer_start(scic);
+}
+
+static void scic_sds_controller_power_control_timer_handler(
+	void *controller)
+{
+	struct scic_sds_controller *scic;
+
+	scic = (struct scic_sds_controller *)controller;
+
+	scic->power_control.phys_granted_power = 0;
+
+	if (scic->power_control.phys_waiting == 0) {
+		scic->power_control.timer_started = false;
+	} else {
+		struct scic_sds_phy *sci_phy = NULL;
+		u8 i;
+
+		for (i = 0;
+		     (i < SCI_MAX_PHYS)
+		     && (scic->power_control.phys_waiting != 0);
+		     i++) {
+			if (scic->power_control.requesters[i] != NULL) {
+				if (scic->power_control.phys_granted_power <
+				    scic->oem_parameters.sds1.controller.max_concurrent_dev_spin_up) {
+					sci_phy = scic->power_control.requesters[i];
+					scic->power_control.requesters[i] = NULL;
+					scic->power_control.phys_waiting--;
+					scic->power_control.phys_granted_power++;
+					scic_sds_phy_consume_power_handler(sci_phy);
+				} else {
+					break;
+				}
+			}
+		}
+
+		/*
+		 * It doesn't matter if the power list is empty, we need to start the
+		 * timer in case another phy becomes ready.
+		 */
+		scic_sds_controller_power_control_timer_start(scic);
+	}
+}
+
+/**
+ * This method inserts the phy in the stagger spinup control queue.
+ * @scic:
+ *
+ *
+ */
+void scic_sds_controller_power_control_queue_insert(
+	struct scic_sds_controller *scic,
+	struct scic_sds_phy *sci_phy)
+{
+	BUG_ON(sci_phy == NULL);
+
+	if (scic->power_control.phys_granted_power <
+	    scic->oem_parameters.sds1.controller.max_concurrent_dev_spin_up) {
+		scic->power_control.phys_granted_power++;
+		scic_sds_phy_consume_power_handler(sci_phy);
+
+		/*
+		 * stop and start the power_control timer. When the timer fires, the
+		 * no_of_phys_granted_power will be set to 0
+		 */
+		scic_sds_controller_power_control_timer_restart(scic);
+	} else {
+		/* Add the phy in the waiting list */
+		scic->power_control.requesters[sci_phy->phy_index] = sci_phy;
+		scic->power_control.phys_waiting++;
+	}
+}
+
+/**
+ * This method removes the phy from the stagger spinup control queue.
+ * @scic:
+ *
+ *
+ */
+void scic_sds_controller_power_control_queue_remove(
+	struct scic_sds_controller *scic,
+	struct scic_sds_phy *sci_phy)
+{
+	BUG_ON(sci_phy == NULL);
+
+	if (scic->power_control.requesters[sci_phy->phy_index] != NULL) {
+		scic->power_control.phys_waiting--;
+	}
+
+	scic->power_control.requesters[sci_phy->phy_index] = NULL;
+}
+
+#define AFE_REGISTER_WRITE_DELAY 10
+
+/* Initialize the AFE for this phy index. We need to read the AFE setup from
+ * the OEM parameters
+ */
+static void scic_sds_controller_afe_initialization(struct scic_sds_controller *scic)
+{
+	const struct scic_sds_oem_params *oem = &scic->oem_parameters.sds1;
+	u32 afe_status;
+	u32 phy_id;
+
+	/* Clear DFX Status registers */
+	writel(0x0081000f, &scic->scu_registers->afe.afe_dfx_master_control0);
+	udelay(AFE_REGISTER_WRITE_DELAY);
+
+	if (is_b0()) {
+		/* PM Rx Equalization Save, PM SPhy Rx Acknowledgement
+		 * Timer, PM Stagger Timer */
+		writel(0x0007BFFF, &scic->scu_registers->afe.afe_pmsn_master_control2);
+		udelay(AFE_REGISTER_WRITE_DELAY);
+	}
+
+	/* Configure bias currents to normal */
+	if (is_a0())
+		writel(0x00005500, &scic->scu_registers->afe.afe_bias_control);
+	else if (is_a2())
+		writel(0x00005A00, &scic->scu_registers->afe.afe_bias_control);
+	else if (is_b0())
+		writel(0x00005F00, &scic->scu_registers->afe.afe_bias_control);
+
+	udelay(AFE_REGISTER_WRITE_DELAY);
+
+	/* Enable PLL */
+	if (is_b0())
+		writel(0x80040A08, &scic->scu_registers->afe.afe_pll_control0);
+	else
+		writel(0x80040908, &scic->scu_registers->afe.afe_pll_control0);
+
+	udelay(AFE_REGISTER_WRITE_DELAY);
+
+	/* Wait for the PLL to lock */
+	do {
+		afe_status = readl(&scic->scu_registers->afe.afe_common_block_status);
+		udelay(AFE_REGISTER_WRITE_DELAY);
+	} while ((afe_status & 0x00001000) == 0);
+
+	if (is_a0() || is_a2()) {
+		/* Shorten SAS SNW lock time (RxLock timer value from 76 us to 50 us) */
+		writel(0x7bcc96ad, &scic->scu_registers->afe.afe_pmsn_master_control0);
+		udelay(AFE_REGISTER_WRITE_DELAY);
+	}
+
+	for (phy_id = 0; phy_id < SCI_MAX_PHYS; phy_id++) {
+		const struct sci_phy_oem_params *oem_phy = &oem->phys[phy_id];
+
+		if (is_b0()) {
+			 /* Configure transmitter SSC parameters */
+			writel(0x00030000, &scic->scu_registers->afe.scu_afe_xcvr[phy_id].afe_tx_ssc_control);
+			udelay(AFE_REGISTER_WRITE_DELAY);
+		} else {
+			/*
+			 * All defaults, except the Receive Word Alignament/Comma Detect
+			 * Enable....(0xe800) */
+			writel(0x00004512, &scic->scu_registers->afe.scu_afe_xcvr[phy_id].afe_xcvr_control0);
+			udelay(AFE_REGISTER_WRITE_DELAY);
+
+			writel(0x0050100F, &scic->scu_registers->afe.scu_afe_xcvr[phy_id].afe_xcvr_control1);
+			udelay(AFE_REGISTER_WRITE_DELAY);
+		}
+
+		/*
+		 * Power up TX and RX out from power down (PWRDNTX and PWRDNRX)
+		 * & increase TX int & ext bias 20%....(0xe85c) */
+		if (is_a0())
+			writel(0x000003D4, &scic->scu_registers->afe.scu_afe_xcvr[phy_id].afe_channel_control);
+		else if (is_a2())
+			writel(0x000003F0, &scic->scu_registers->afe.scu_afe_xcvr[phy_id].afe_channel_control);
+		else {
+			 /* Power down TX and RX (PWRDNTX and PWRDNRX) */
+			writel(0x000003d7, &scic->scu_registers->afe.scu_afe_xcvr[phy_id].afe_channel_control);
+			udelay(AFE_REGISTER_WRITE_DELAY);
+
+			/*
+			 * Power up TX and RX out from power down (PWRDNTX and PWRDNRX)
+			 * & increase TX int & ext bias 20%....(0xe85c) */
+			writel(0x000003d4, &scic->scu_registers->afe.scu_afe_xcvr[phy_id].afe_channel_control);
+		}
+		udelay(AFE_REGISTER_WRITE_DELAY);
+
+		if (is_a0() || is_a2()) {
+			/* Enable TX equalization (0xe824) */
+			writel(0x00040000, &scic->scu_registers->afe.scu_afe_xcvr[phy_id].afe_tx_control);
+			udelay(AFE_REGISTER_WRITE_DELAY);
+		}
+
+		/*
+		 * RDPI=0x0(RX Power On), RXOOBDETPDNC=0x0, TPD=0x0(TX Power On),
+		 * RDD=0x0(RX Detect Enabled) ....(0xe800) */
+		writel(0x00004100, &scic->scu_registers->afe.scu_afe_xcvr[phy_id].afe_xcvr_control0);
+		udelay(AFE_REGISTER_WRITE_DELAY);
+
+		/* Leave DFE/FFE on */
+		if (is_a0())
+			writel(0x3F09983F, &scic->scu_registers->afe.scu_afe_xcvr[phy_id].afe_rx_ssc_control0);
+		else if (is_a2())
+			writel(0x3F11103F, &scic->scu_registers->afe.scu_afe_xcvr[phy_id].afe_rx_ssc_control0);
+		else {
+			writel(0x3F11103F, &scic->scu_registers->afe.scu_afe_xcvr[phy_id].afe_rx_ssc_control0);
+			udelay(AFE_REGISTER_WRITE_DELAY);
+			/* Enable TX equalization (0xe824) */
+			writel(0x00040000, &scic->scu_registers->afe.scu_afe_xcvr[phy_id].afe_tx_control);
+		}
+		udelay(AFE_REGISTER_WRITE_DELAY);
+
+		writel(oem_phy->afe_tx_amp_control0,
+			&scic->scu_registers->afe.scu_afe_xcvr[phy_id].afe_tx_amp_control0);
+		udelay(AFE_REGISTER_WRITE_DELAY);
+
+		writel(oem_phy->afe_tx_amp_control1,
+			&scic->scu_registers->afe.scu_afe_xcvr[phy_id].afe_tx_amp_control1);
+		udelay(AFE_REGISTER_WRITE_DELAY);
+
+		writel(oem_phy->afe_tx_amp_control2,
+			&scic->scu_registers->afe.scu_afe_xcvr[phy_id].afe_tx_amp_control2);
+		udelay(AFE_REGISTER_WRITE_DELAY);
+
+		writel(oem_phy->afe_tx_amp_control3,
+			&scic->scu_registers->afe.scu_afe_xcvr[phy_id].afe_tx_amp_control3);
+		udelay(AFE_REGISTER_WRITE_DELAY);
+	}
+
+	/* Transfer control to the PEs */
+	writel(0x00010f00, &scic->scu_registers->afe.afe_dfx_master_control0);
+	udelay(AFE_REGISTER_WRITE_DELAY);
+}
+
+static enum sci_status scic_controller_set_mode(struct scic_sds_controller *scic,
+						enum sci_controller_mode operating_mode)
+{
+	enum sci_status status          = SCI_SUCCESS;
+
+	if ((scic->state_machine.current_state_id ==
+				SCI_BASE_CONTROLLER_STATE_INITIALIZING) ||
+	    (scic->state_machine.current_state_id ==
+				SCI_BASE_CONTROLLER_STATE_INITIALIZED)) {
+		switch (operating_mode) {
+		case SCI_MODE_SPEED:
+			scic->remote_node_entries      = SCI_MAX_REMOTE_DEVICES;
+			scic->task_context_entries     = SCU_IO_REQUEST_COUNT;
+			scic->uf_control.buffers.count =
+				SCU_UNSOLICITED_FRAME_COUNT;
+			scic->completion_event_entries = SCU_EVENT_COUNT;
+			scic->completion_queue_entries =
+				SCU_COMPLETION_QUEUE_COUNT;
+			break;
+
+		case SCI_MODE_SIZE:
+			scic->remote_node_entries      = SCI_MIN_REMOTE_DEVICES;
+			scic->task_context_entries     = SCI_MIN_IO_REQUESTS;
+			scic->uf_control.buffers.count =
+				SCU_MIN_UNSOLICITED_FRAMES;
+			scic->completion_event_entries = SCU_MIN_EVENTS;
+			scic->completion_queue_entries =
+				SCU_MIN_COMPLETION_QUEUE_ENTRIES;
+			break;
+
+		default:
+			status = SCI_FAILURE_INVALID_PARAMETER_VALUE;
+			break;
+		}
+	} else
+		status = SCI_FAILURE_INVALID_STATE;
+
+	return status;
+}
+
+static void scic_sds_controller_initialize_power_control(struct scic_sds_controller *scic)
+{
+	struct isci_host *ihost = scic_to_ihost(scic);
+	scic->power_control.timer = isci_timer_create(ihost,
+						      scic,
+					scic_sds_controller_power_control_timer_handler);
+
+	memset(scic->power_control.requesters, 0,
+	       sizeof(scic->power_control.requesters));
+
+	scic->power_control.phys_waiting = 0;
+	scic->power_control.phys_granted_power = 0;
+}
+
+static enum sci_status scic_controller_initialize(struct scic_sds_controller *scic)
+{
+	struct sci_base_state_machine *sm = &scic->state_machine;
+	enum sci_status result = SCI_SUCCESS;
+	struct isci_host *ihost = scic_to_ihost(scic);
+	u32 index, state;
+
+	if (scic->state_machine.current_state_id !=
+	    SCI_BASE_CONTROLLER_STATE_RESET) {
+		dev_warn(scic_to_dev(scic),
+			 "SCIC Controller initialize operation requested "
+			 "in invalid state\n");
+		return SCI_FAILURE_INVALID_STATE;
+	}
+
+	sci_base_state_machine_change_state(sm, SCI_BASE_CONTROLLER_STATE_INITIALIZING);
+
+	scic->timeout_timer = isci_timer_create(ihost, scic,
+						scic_sds_controller_timeout_handler);
+
+	scic_sds_controller_initialize_phy_startup(scic);
+
+	scic_sds_controller_initialize_power_control(scic);
+
+	/*
+	 * There is nothing to do here for B0 since we do not have to
+	 * program the AFE registers.
+	 * / @todo The AFE settings are supposed to be correct for the B0 but
+	 * /       presently they seem to be wrong. */
+	scic_sds_controller_afe_initialization(scic);
+
+	if (result == SCI_SUCCESS) {
+		u32 status;
+		u32 terminate_loop;
+
+		/* Take the hardware out of reset */
+		writel(0, &scic->smu_registers->soft_reset_control);
+
+		/*
+		 * / @todo Provide meaningfull error code for hardware failure
+		 * result = SCI_FAILURE_CONTROLLER_HARDWARE; */
+		result = SCI_FAILURE;
+		terminate_loop = 100;
+
+		while (terminate_loop-- && (result != SCI_SUCCESS)) {
+			/* Loop until the hardware reports success */
+			udelay(SCU_CONTEXT_RAM_INIT_STALL_TIME);
+			status = readl(&scic->smu_registers->control_status);
+
+			if ((status & SCU_RAM_INIT_COMPLETED) ==
+					SCU_RAM_INIT_COMPLETED)
+				result = SCI_SUCCESS;
+		}
+	}
+
+	if (result == SCI_SUCCESS) {
+		u32 max_supported_ports;
+		u32 max_supported_devices;
+		u32 max_supported_io_requests;
+		u32 device_context_capacity;
+
+		/*
+		 * Determine what are the actaul device capacities that the
+		 * hardware will support */
+		device_context_capacity =
+			readl(&scic->smu_registers->device_context_capacity);
+
+
+		max_supported_ports = smu_dcc_get_max_ports(device_context_capacity);
+		max_supported_devices = smu_dcc_get_max_remote_node_context(device_context_capacity);
+		max_supported_io_requests = smu_dcc_get_max_task_context(device_context_capacity);
+
+		/*
+		 * Make all PEs that are unassigned match up with the
+		 * logical ports
+		 */
+		for (index = 0; index < max_supported_ports; index++) {
+			struct scu_port_task_scheduler_group_registers __iomem
+				*ptsg = &scic->scu_registers->peg0.ptsg;
+
+			writel(index, &ptsg->protocol_engine[index]);
+		}
+
+		/* Record the smaller of the two capacity values */
+		scic->logical_port_entries =
+			min(max_supported_ports, scic->logical_port_entries);
+
+		scic->task_context_entries =
+			min(max_supported_io_requests,
+			    scic->task_context_entries);
+
+		scic->remote_node_entries =
+			min(max_supported_devices, scic->remote_node_entries);
+
+		/*
+		 * Now that we have the correct hardware reported minimum values
+		 * build the MDL for the controller.  Default to a performance
+		 * configuration.
+		 */
+		scic_controller_set_mode(scic, SCI_MODE_SPEED);
+	}
+
+	/* Initialize hardware PCI Relaxed ordering in DMA engines */
+	if (result == SCI_SUCCESS) {
+		u32 dma_configuration;
+
+		/* Configure the payload DMA */
+		dma_configuration =
+			readl(&scic->scu_registers->sdma.pdma_configuration);
+		dma_configuration |=
+			SCU_PDMACR_GEN_BIT(PCI_RELAXED_ORDERING_ENABLE);
+		writel(dma_configuration,
+			&scic->scu_registers->sdma.pdma_configuration);
+
+		/* Configure the control DMA */
+		dma_configuration =
+			readl(&scic->scu_registers->sdma.cdma_configuration);
+		dma_configuration |=
+			SCU_CDMACR_GEN_BIT(PCI_RELAXED_ORDERING_ENABLE);
+		writel(dma_configuration,
+			&scic->scu_registers->sdma.cdma_configuration);
+	}
+
+	/*
+	 * Initialize the PHYs before the PORTs because the PHY registers
+	 * are accessed during the port initialization.
+	 */
+	if (result == SCI_SUCCESS) {
+		/* Initialize the phys */
+		for (index = 0;
+		     (result == SCI_SUCCESS) && (index < SCI_MAX_PHYS);
+		     index++) {
+			result = scic_sds_phy_initialize(
+				&ihost->phys[index].sci,
+				&scic->scu_registers->peg0.pe[index].tl,
+				&scic->scu_registers->peg0.pe[index].ll);
+		}
+	}
+
+	if (result == SCI_SUCCESS) {
+		/* Initialize the logical ports */
+		for (index = 0;
+		     (index < scic->logical_port_entries) &&
+		     (result == SCI_SUCCESS);
+		     index++) {
+			result = scic_sds_port_initialize(
+				&ihost->ports[index].sci,
+				&scic->scu_registers->peg0.ptsg.port[index],
+				&scic->scu_registers->peg0.ptsg.protocol_engine,
+				&scic->scu_registers->peg0.viit[index]);
+		}
+	}
+
+	if (result == SCI_SUCCESS)
+		result = scic_sds_port_configuration_agent_initialize(
+				scic,
+				&scic->port_agent);
+
+	/* Advance the controller state machine */
+	if (result == SCI_SUCCESS)
+		state = SCI_BASE_CONTROLLER_STATE_INITIALIZED;
+	else
+		state = SCI_BASE_CONTROLLER_STATE_FAILED;
+	sci_base_state_machine_change_state(sm, state);
+
+	return result;
+}
+
+static enum sci_status scic_user_parameters_set(
+	struct scic_sds_controller *scic,
+	union scic_user_parameters *scic_parms)
+{
+	u32 state = scic->state_machine.current_state_id;
+
+	if (state == SCI_BASE_CONTROLLER_STATE_RESET ||
+	    state == SCI_BASE_CONTROLLER_STATE_INITIALIZING ||
+	    state == SCI_BASE_CONTROLLER_STATE_INITIALIZED) {
+		u16 index;
+
+		/*
+		 * Validate the user parameters.  If they are not legal, then
+		 * return a failure.
+		 */
+		for (index = 0; index < SCI_MAX_PHYS; index++) {
+			struct sci_phy_user_params *user_phy;
+
+			user_phy = &scic_parms->sds1.phys[index];
+
+			if (!((user_phy->max_speed_generation <=
+						SCIC_SDS_PARM_MAX_SPEED) &&
+			      (user_phy->max_speed_generation >
+						SCIC_SDS_PARM_NO_SPEED)))
+				return SCI_FAILURE_INVALID_PARAMETER_VALUE;
+
+			if (user_phy->in_connection_align_insertion_frequency <
+					3)
+				return SCI_FAILURE_INVALID_PARAMETER_VALUE;
+
+			if ((user_phy->in_connection_align_insertion_frequency <
+						3) ||
+			    (user_phy->align_insertion_frequency == 0) ||
+			    (user_phy->
+				notify_enable_spin_up_insertion_frequency ==
+						0))
+				return SCI_FAILURE_INVALID_PARAMETER_VALUE;
+		}
+
+		if ((scic_parms->sds1.stp_inactivity_timeout == 0) ||
+		    (scic_parms->sds1.ssp_inactivity_timeout == 0) ||
+		    (scic_parms->sds1.stp_max_occupancy_timeout == 0) ||
+		    (scic_parms->sds1.ssp_max_occupancy_timeout == 0) ||
+		    (scic_parms->sds1.no_outbound_task_timeout == 0))
+			return SCI_FAILURE_INVALID_PARAMETER_VALUE;
+
+		memcpy(&scic->user_parameters, scic_parms, sizeof(*scic_parms));
+
+		return SCI_SUCCESS;
+	}
+
+	return SCI_FAILURE_INVALID_STATE;
+}
+
+static int scic_controller_mem_init(struct scic_sds_controller *scic)
+{
+	struct device *dev = scic_to_dev(scic);
+	dma_addr_t dma_handle;
+	enum sci_status result;
+
+	scic->completion_queue = dmam_alloc_coherent(dev,
+			scic->completion_queue_entries * sizeof(u32),
+			&dma_handle, GFP_KERNEL);
+	if (!scic->completion_queue)
+		return -ENOMEM;
+
+	writel(lower_32_bits(dma_handle),
+		&scic->smu_registers->completion_queue_lower);
+	writel(upper_32_bits(dma_handle),
+		&scic->smu_registers->completion_queue_upper);
+
+	scic->remote_node_context_table = dmam_alloc_coherent(dev,
+			scic->remote_node_entries *
+				sizeof(union scu_remote_node_context),
+			&dma_handle, GFP_KERNEL);
+	if (!scic->remote_node_context_table)
+		return -ENOMEM;
+
+	writel(lower_32_bits(dma_handle),
+		&scic->smu_registers->remote_node_context_lower);
+	writel(upper_32_bits(dma_handle),
+		&scic->smu_registers->remote_node_context_upper);
+
+	scic->task_context_table = dmam_alloc_coherent(dev,
+			scic->task_context_entries *
+				sizeof(struct scu_task_context),
+			&dma_handle, GFP_KERNEL);
+	if (!scic->task_context_table)
+		return -ENOMEM;
+
+	writel(lower_32_bits(dma_handle),
+		&scic->smu_registers->host_task_table_lower);
+	writel(upper_32_bits(dma_handle),
+		&scic->smu_registers->host_task_table_upper);
+
+	result = scic_sds_unsolicited_frame_control_construct(scic);
+	if (result)
+		return result;
+
+	/*
+	 * Inform the silicon as to the location of the UF headers and
+	 * address table.
+	 */
+	writel(lower_32_bits(scic->uf_control.headers.physical_address),
+		&scic->scu_registers->sdma.uf_header_base_address_lower);
+	writel(upper_32_bits(scic->uf_control.headers.physical_address),
+		&scic->scu_registers->sdma.uf_header_base_address_upper);
+
+	writel(lower_32_bits(scic->uf_control.address_table.physical_address),
+		&scic->scu_registers->sdma.uf_address_table_lower);
+	writel(upper_32_bits(scic->uf_control.address_table.physical_address),
+		&scic->scu_registers->sdma.uf_address_table_upper);
+
+	return 0;
+}
+
 int isci_host_init(struct isci_host *isci_host)
 {
 	int err = 0, i;
@@ -453,3 +2600,625 @@ int isci_host_init(struct isci_host *isci_host)
 
 	return 0;
 }
+
+void scic_sds_controller_link_up(struct scic_sds_controller *scic,
+		struct scic_sds_port *port, struct scic_sds_phy *phy)
+{
+	switch (scic->state_machine.current_state_id) {
+	case SCI_BASE_CONTROLLER_STATE_STARTING:
+		scic_sds_controller_phy_timer_stop(scic);
+		scic->port_agent.link_up_handler(scic, &scic->port_agent,
+						 port, phy);
+		scic_sds_controller_start_next_phy(scic);
+		break;
+	case SCI_BASE_CONTROLLER_STATE_READY:
+		scic->port_agent.link_up_handler(scic, &scic->port_agent,
+						 port, phy);
+		break;
+	default:
+		dev_dbg(scic_to_dev(scic),
+			"%s: SCIC Controller linkup event from phy %d in "
+			"unexpected state %d\n", __func__, phy->phy_index,
+			scic->state_machine.current_state_id);
+	}
+}
+
+void scic_sds_controller_link_down(struct scic_sds_controller *scic,
+		struct scic_sds_port *port, struct scic_sds_phy *phy)
+{
+	switch (scic->state_machine.current_state_id) {
+	case SCI_BASE_CONTROLLER_STATE_STARTING:
+	case SCI_BASE_CONTROLLER_STATE_READY:
+		scic->port_agent.link_down_handler(scic, &scic->port_agent,
+						   port, phy);
+		break;
+	default:
+		dev_dbg(scic_to_dev(scic),
+			"%s: SCIC Controller linkdown event from phy %d in "
+			"unexpected state %d\n",
+			__func__,
+			phy->phy_index,
+			scic->state_machine.current_state_id);
+	}
+}
+
+/**
+ * This is a helper method to determine if any remote devices on this
+ * controller are still in the stopping state.
+ *
+ */
+static bool scic_sds_controller_has_remote_devices_stopping(
+	struct scic_sds_controller *controller)
+{
+	u32 index;
+
+	for (index = 0; index < controller->remote_node_entries; index++) {
+		if ((controller->device_table[index] != NULL) &&
+		   (controller->device_table[index]->state_machine.current_state_id
+		    == SCI_BASE_REMOTE_DEVICE_STATE_STOPPING))
+			return true;
+	}
+
+	return false;
+}
+
+/**
+ * This method is called by the remote device to inform the controller
+ * object that the remote device has stopped.
+ */
+void scic_sds_controller_remote_device_stopped(struct scic_sds_controller *scic,
+					       struct scic_sds_remote_device *sci_dev)
+{
+	if (scic->state_machine.current_state_id !=
+	    SCI_BASE_CONTROLLER_STATE_STOPPING) {
+		dev_dbg(scic_to_dev(scic),
+			"SCIC Controller 0x%p remote device stopped event "
+			"from device 0x%p in unexpected state %d\n",
+			scic, sci_dev,
+			scic->state_machine.current_state_id);
+		return;
+	}
+
+	if (!scic_sds_controller_has_remote_devices_stopping(scic)) {
+		sci_base_state_machine_change_state(&scic->state_machine,
+				SCI_BASE_CONTROLLER_STATE_STOPPED);
+	}
+}
+
+/**
+ * This method will write to the SCU PCP register the request value. The method
+ *    is used to suspend/resume ports, devices, and phys.
+ * @scic:
+ *
+ *
+ */
+void scic_sds_controller_post_request(
+	struct scic_sds_controller *scic,
+	u32 request)
+{
+	dev_dbg(scic_to_dev(scic),
+		"%s: SCIC Controller 0x%p post request 0x%08x\n",
+		__func__,
+		scic,
+		request);
+
+	writel(request, &scic->smu_registers->post_context_port);
+}
+
+/**
+ * This method will copy the soft copy of the task context into the physical
+ *    memory accessible by the controller.
+ * @scic: This parameter specifies the controller for which to copy
+ *    the task context.
+ * @sci_req: This parameter specifies the request for which the task
+ *    context is being copied.
+ *
+ * After this call is made the SCIC_SDS_IO_REQUEST object will always point to
+ * the physical memory version of the task context. Thus, all subsequent
+ * updates to the task context are performed in the TC table (i.e. DMAable
+ * memory). none
+ */
+void scic_sds_controller_copy_task_context(
+	struct scic_sds_controller *scic,
+	struct scic_sds_request *sci_req)
+{
+	struct scu_task_context *task_context_buffer;
+
+	task_context_buffer = scic_sds_controller_get_task_context_buffer(
+		scic, sci_req->io_tag);
+
+	memcpy(task_context_buffer,
+	       sci_req->task_context_buffer,
+	       offsetof(struct scu_task_context, sgl_snapshot_ac));
+
+	/*
+	 * Now that the soft copy of the TC has been copied into the TC
+	 * table accessible by the silicon.  Thus, any further changes to
+	 * the TC (e.g. TC termination) occur in the appropriate location. */
+	sci_req->task_context_buffer = task_context_buffer;
+}
+
+/**
+ * This method returns the task context buffer for the given io tag.
+ * @scic:
+ * @io_tag:
+ *
+ * struct scu_task_context*
+ */
+struct scu_task_context *scic_sds_controller_get_task_context_buffer(
+	struct scic_sds_controller *scic,
+	u16 io_tag
+	) {
+	u16 task_index = scic_sds_io_tag_get_index(io_tag);
+
+	if (task_index < scic->task_context_entries) {
+		return &scic->task_context_table[task_index];
+	}
+
+	return NULL;
+}
+
+struct scic_sds_request *scic_request_by_tag(struct scic_sds_controller *scic,
+					     u16 io_tag)
+{
+	u16 task_index;
+	u16 task_sequence;
+
+	task_index = scic_sds_io_tag_get_index(io_tag);
+
+	if (task_index  < scic->task_context_entries) {
+		if (scic->io_request_table[task_index] != NULL) {
+			task_sequence = scic_sds_io_tag_get_sequence(io_tag);
+
+			if (task_sequence == scic->io_request_sequence[task_index]) {
+				return scic->io_request_table[task_index];
+			}
+		}
+	}
+
+	return NULL;
+}
+
+/**
+ * This method allocates remote node index and the reserves the remote node
+ *    context space for use. This method can fail if there are no more remote
+ *    node index available.
+ * @scic: This is the controller object which contains the set of
+ *    free remote node ids
+ * @sci_dev: This is the device object which is requesting the a remote node
+ *    id
+ * @node_id: This is the remote node id that is assinged to the device if one
+ *    is available
+ *
+ * enum sci_status SCI_FAILURE_OUT_OF_RESOURCES if there are no available remote
+ * node index available.
+ */
+enum sci_status scic_sds_controller_allocate_remote_node_context(
+	struct scic_sds_controller *scic,
+	struct scic_sds_remote_device *sci_dev,
+	u16 *node_id)
+{
+	u16 node_index;
+	u32 remote_node_count = scic_sds_remote_device_node_count(sci_dev);
+
+	node_index = scic_sds_remote_node_table_allocate_remote_node(
+		&scic->available_remote_nodes, remote_node_count
+		);
+
+	if (node_index != SCIC_SDS_REMOTE_NODE_CONTEXT_INVALID_INDEX) {
+		scic->device_table[node_index] = sci_dev;
+
+		*node_id = node_index;
+
+		return SCI_SUCCESS;
+	}
+
+	return SCI_FAILURE_INSUFFICIENT_RESOURCES;
+}
+
+/**
+ * This method frees the remote node index back to the available pool.  Once
+ *    this is done the remote node context buffer is no longer valid and can
+ *    not be used.
+ * @scic:
+ * @sci_dev:
+ * @node_id:
+ *
+ */
+void scic_sds_controller_free_remote_node_context(
+	struct scic_sds_controller *scic,
+	struct scic_sds_remote_device *sci_dev,
+	u16 node_id)
+{
+	u32 remote_node_count = scic_sds_remote_device_node_count(sci_dev);
+
+	if (scic->device_table[node_id] == sci_dev) {
+		scic->device_table[node_id] = NULL;
+
+		scic_sds_remote_node_table_release_remote_node_index(
+			&scic->available_remote_nodes, remote_node_count, node_id
+			);
+	}
+}
+
+/**
+ * This method returns the union scu_remote_node_context for the specified remote
+ *    node id.
+ * @scic:
+ * @node_id:
+ *
+ * union scu_remote_node_context*
+ */
+union scu_remote_node_context *scic_sds_controller_get_remote_node_context_buffer(
+	struct scic_sds_controller *scic,
+	u16 node_id
+	) {
+	if (
+		(node_id < scic->remote_node_entries)
+		&& (scic->device_table[node_id] != NULL)
+		) {
+		return &scic->remote_node_context_table[node_id];
+	}
+
+	return NULL;
+}
+
+/**
+ *
+ * @resposne_buffer: This is the buffer into which the D2H register FIS will be
+ *    constructed.
+ * @frame_header: This is the frame header returned by the hardware.
+ * @frame_buffer: This is the frame buffer returned by the hardware.
+ *
+ * This method will combind the frame header and frame buffer to create a SATA
+ * D2H register FIS none
+ */
+void scic_sds_controller_copy_sata_response(
+	void *response_buffer,
+	void *frame_header,
+	void *frame_buffer)
+{
+	memcpy(response_buffer, frame_header, sizeof(u32));
+
+	memcpy(response_buffer + sizeof(u32),
+	       frame_buffer,
+	       sizeof(struct dev_to_host_fis) - sizeof(u32));
+}
+
+/**
+ * This method releases the frame once this is done the frame is available for
+ *    re-use by the hardware.  The data contained in the frame header and frame
+ *    buffer is no longer valid. The UF queue get pointer is only updated if UF
+ *    control indicates this is appropriate.
+ * @scic:
+ * @frame_index:
+ *
+ */
+void scic_sds_controller_release_frame(
+	struct scic_sds_controller *scic,
+	u32 frame_index)
+{
+	if (scic_sds_unsolicited_frame_control_release_frame(
+		    &scic->uf_control, frame_index) == true)
+		writel(scic->uf_control.get,
+			&scic->scu_registers->sdma.unsolicited_frame_get_pointer);
+}
+
+/**
+ * scic_controller_start_io() - This method is called by the SCI user to
+ *    send/start an IO request. If the method invocation is successful, then
+ *    the IO request has been queued to the hardware for processing.
+ * @controller: the handle to the controller object for which to start an IO
+ *    request.
+ * @remote_device: the handle to the remote device object for which to start an
+ *    IO request.
+ * @io_request: the handle to the io request object to start.
+ * @io_tag: This parameter specifies a previously allocated IO tag that the
+ *    user desires to be utilized for this request. This parameter is optional.
+ *     The user is allowed to supply SCI_CONTROLLER_INVALID_IO_TAG as the value
+ *    for this parameter.
+ *
+ * - IO tags are a protected resource.  It is incumbent upon the SCI Core user
+ * to ensure that each of the methods that may allocate or free available IO
+ * tags are handled in a mutually exclusive manner.  This method is one of said
+ * methods requiring proper critical code section protection (e.g. semaphore,
+ * spin-lock, etc.). - For SATA, the user is required to manage NCQ tags.  As a
+ * result, it is expected the user will have set the NCQ tag field in the host
+ * to device register FIS prior to calling this method.  There is also a
+ * requirement for the user to call scic_stp_io_set_ncq_tag() prior to invoking
+ * the scic_controller_start_io() method. scic_controller_allocate_tag() for
+ * more information on allocating a tag. Indicate if the controller
+ * successfully started the IO request. SCI_SUCCESS if the IO request was
+ * successfully started. Determine the failure situations and return values.
+ */
+enum sci_status scic_controller_start_io(
+	struct scic_sds_controller *scic,
+	struct scic_sds_remote_device *rdev,
+	struct scic_sds_request *req,
+	u16 io_tag)
+{
+	enum sci_status status;
+
+	if (scic->state_machine.current_state_id !=
+	    SCI_BASE_CONTROLLER_STATE_READY) {
+		dev_warn(scic_to_dev(scic), "invalid state to start I/O");
+		return SCI_FAILURE_INVALID_STATE;
+	}
+
+	status = scic_sds_remote_device_start_io(scic, rdev, req);
+	if (status != SCI_SUCCESS)
+		return status;
+
+	scic->io_request_table[scic_sds_io_tag_get_index(req->io_tag)] = req;
+	scic_sds_controller_post_request(scic, scic_sds_request_get_post_context(req));
+	return SCI_SUCCESS;
+}
+
+/**
+ * scic_controller_terminate_request() - This method is called by the SCI Core
+ *    user to terminate an ongoing (i.e. started) core IO request.  This does
+ *    not abort the IO request at the target, but rather removes the IO request
+ *    from the host controller.
+ * @controller: the handle to the controller object for which to terminate a
+ *    request.
+ * @remote_device: the handle to the remote device object for which to
+ *    terminate a request.
+ * @request: the handle to the io or task management request object to
+ *    terminate.
+ *
+ * Indicate if the controller successfully began the terminate process for the
+ * IO request. SCI_SUCCESS if the terminate process was successfully started
+ * for the request. Determine the failure situations and return values.
+ */
+enum sci_status scic_controller_terminate_request(
+	struct scic_sds_controller *scic,
+	struct scic_sds_remote_device *rdev,
+	struct scic_sds_request *req)
+{
+	enum sci_status status;
+
+	if (scic->state_machine.current_state_id !=
+	    SCI_BASE_CONTROLLER_STATE_READY) {
+		dev_warn(scic_to_dev(scic),
+			 "invalid state to terminate request\n");
+		return SCI_FAILURE_INVALID_STATE;
+	}
+
+	status = scic_sds_io_request_terminate(req);
+	if (status != SCI_SUCCESS)
+		return status;
+
+	/*
+	 * Utilize the original post context command and or in the POST_TC_ABORT
+	 * request sub-type.
+	 */
+	scic_sds_controller_post_request(scic,
+		scic_sds_request_get_post_context(req) |
+		SCU_CONTEXT_COMMAND_REQUEST_POST_TC_ABORT);
+	return SCI_SUCCESS;
+}
+
+/**
+ * scic_controller_complete_io() - This method will perform core specific
+ *    completion operations for an IO request.  After this method is invoked,
+ *    the user should consider the IO request as invalid until it is properly
+ *    reused (i.e. re-constructed).
+ * @controller: The handle to the controller object for which to complete the
+ *    IO request.
+ * @remote_device: The handle to the remote device object for which to complete
+ *    the IO request.
+ * @io_request: the handle to the io request object to complete.
+ *
+ * - IO tags are a protected resource.  It is incumbent upon the SCI Core user
+ * to ensure that each of the methods that may allocate or free available IO
+ * tags are handled in a mutually exclusive manner.  This method is one of said
+ * methods requiring proper critical code section protection (e.g. semaphore,
+ * spin-lock, etc.). - If the IO tag for a request was allocated, by the SCI
+ * Core user, using the scic_controller_allocate_io_tag() method, then it is
+ * the responsibility of the caller to invoke the scic_controller_free_io_tag()
+ * method to free the tag (i.e. this method will not free the IO tag). Indicate
+ * if the controller successfully completed the IO request. SCI_SUCCESS if the
+ * completion process was successful.
+ */
+enum sci_status scic_controller_complete_io(
+	struct scic_sds_controller *scic,
+	struct scic_sds_remote_device *rdev,
+	struct scic_sds_request *request)
+{
+	enum sci_status status;
+	u16 index;
+
+	switch (scic->state_machine.current_state_id) {
+	case SCI_BASE_CONTROLLER_STATE_STOPPING:
+		/* XXX: Implement this function */
+		return SCI_FAILURE;
+	case SCI_BASE_CONTROLLER_STATE_READY:
+		status = scic_sds_remote_device_complete_io(scic, rdev, request);
+		if (status != SCI_SUCCESS)
+			return status;
+
+		index = scic_sds_io_tag_get_index(request->io_tag);
+		scic->io_request_table[index] = NULL;
+		return SCI_SUCCESS;
+	default:
+		dev_warn(scic_to_dev(scic), "invalid state to complete I/O");
+		return SCI_FAILURE_INVALID_STATE;
+	}
+
+}
+
+enum sci_status scic_controller_continue_io(struct scic_sds_request *sci_req)
+{
+	struct scic_sds_controller *scic = sci_req->owning_controller;
+
+	if (scic->state_machine.current_state_id !=
+	    SCI_BASE_CONTROLLER_STATE_READY) {
+		dev_warn(scic_to_dev(scic), "invalid state to continue I/O");
+		return SCI_FAILURE_INVALID_STATE;
+	}
+
+	scic->io_request_table[scic_sds_io_tag_get_index(sci_req->io_tag)] = sci_req;
+	scic_sds_controller_post_request(scic, scic_sds_request_get_post_context(sci_req));
+	return SCI_SUCCESS;
+}
+
+/**
+ * scic_controller_start_task() - This method is called by the SCIC user to
+ *    send/start a framework task management request.
+ * @controller: the handle to the controller object for which to start the task
+ *    management request.
+ * @remote_device: the handle to the remote device object for which to start
+ *    the task management request.
+ * @task_request: the handle to the task request object to start.
+ * @io_tag: This parameter specifies a previously allocated IO tag that the
+ *    user desires to be utilized for this request.  Note this not the io_tag
+ *    of the request being managed.  It is to be utilized for the task request
+ *    itself. This parameter is optional.  The user is allowed to supply
+ *    SCI_CONTROLLER_INVALID_IO_TAG as the value for this parameter.
+ *
+ * - IO tags are a protected resource.  It is incumbent upon the SCI Core user
+ * to ensure that each of the methods that may allocate or free available IO
+ * tags are handled in a mutually exclusive manner.  This method is one of said
+ * methods requiring proper critical code section protection (e.g. semaphore,
+ * spin-lock, etc.). - The user must synchronize this task with completion
+ * queue processing.  If they are not synchronized then it is possible for the
+ * io requests that are being managed by the task request can complete before
+ * starting the task request. scic_controller_allocate_tag() for more
+ * information on allocating a tag. Indicate if the controller successfully
+ * started the IO request. SCI_TASK_SUCCESS if the task request was
+ * successfully started. SCI_TASK_FAILURE_REQUIRES_SCSI_ABORT This value is
+ * returned if there is/are task(s) outstanding that require termination or
+ * completion before this request can succeed.
+ */
+enum sci_task_status scic_controller_start_task(
+	struct scic_sds_controller *scic,
+	struct scic_sds_remote_device *rdev,
+	struct scic_sds_request *req,
+	u16 task_tag)
+{
+	enum sci_status status;
+
+	if (scic->state_machine.current_state_id !=
+	    SCI_BASE_CONTROLLER_STATE_READY) {
+		dev_warn(scic_to_dev(scic),
+			 "%s: SCIC Controller starting task from invalid "
+			 "state\n",
+			 __func__);
+		return SCI_TASK_FAILURE_INVALID_STATE;
+	}
+
+	status = scic_sds_remote_device_start_task(scic, rdev, req);
+	switch (status) {
+	case SCI_FAILURE_RESET_DEVICE_PARTIAL_SUCCESS:
+		scic->io_request_table[scic_sds_io_tag_get_index(req->io_tag)] = req;
+
+		/*
+		 * We will let framework know this task request started successfully,
+		 * although core is still woring on starting the request (to post tc when
+		 * RNC is resumed.)
+		 */
+		return SCI_SUCCESS;
+	case SCI_SUCCESS:
+		scic->io_request_table[scic_sds_io_tag_get_index(req->io_tag)] = req;
+
+		scic_sds_controller_post_request(scic,
+			scic_sds_request_get_post_context(req));
+		break;
+	default:
+		break;
+	}
+
+	return status;
+}
+
+/**
+ * scic_controller_allocate_io_tag() - This method will allocate a tag from the
+ *    pool of free IO tags. Direct allocation of IO tags by the SCI Core user
+ *    is optional. The scic_controller_start_io() method will allocate an IO
+ *    tag if this method is not utilized and the tag is not supplied to the IO
+ *    construct routine.  Direct allocation of IO tags may provide additional
+ *    performance improvements in environments capable of supporting this usage
+ *    model.  Additionally, direct allocation of IO tags also provides
+ *    additional flexibility to the SCI Core user.  Specifically, the user may
+ *    retain IO tags across the lives of multiple IO requests.
+ * @controller: the handle to the controller object for which to allocate the
+ *    tag.
+ *
+ * IO tags are a protected resource.  It is incumbent upon the SCI Core user to
+ * ensure that each of the methods that may allocate or free available IO tags
+ * are handled in a mutually exclusive manner.  This method is one of said
+ * methods requiring proper critical code section protection (e.g. semaphore,
+ * spin-lock, etc.). An unsigned integer representing an available IO tag.
+ * SCI_CONTROLLER_INVALID_IO_TAG This value is returned if there are no
+ * currently available tags to be allocated. All return other values indicate a
+ * legitimate tag.
+ */
+u16 scic_controller_allocate_io_tag(
+	struct scic_sds_controller *scic)
+{
+	u16 task_context;
+	u16 sequence_count;
+
+	if (!sci_pool_empty(scic->tci_pool)) {
+		sci_pool_get(scic->tci_pool, task_context);
+
+		sequence_count = scic->io_request_sequence[task_context];
+
+		return scic_sds_io_tag_construct(sequence_count, task_context);
+	}
+
+	return SCI_CONTROLLER_INVALID_IO_TAG;
+}
+
+/**
+ * scic_controller_free_io_tag() - This method will free an IO tag to the pool
+ *    of free IO tags. This method provides the SCI Core user more flexibility
+ *    with regards to IO tags.  The user may desire to keep an IO tag after an
+ *    IO request has completed, because they plan on re-using the tag for a
+ *    subsequent IO request.  This method is only legal if the tag was
+ *    allocated via scic_controller_allocate_io_tag().
+ * @controller: This parameter specifies the handle to the controller object
+ *    for which to free/return the tag.
+ * @io_tag: This parameter represents the tag to be freed to the pool of
+ *    available tags.
+ *
+ * - IO tags are a protected resource.  It is incumbent upon the SCI Core user
+ * to ensure that each of the methods that may allocate or free available IO
+ * tags are handled in a mutually exclusive manner.  This method is one of said
+ * methods requiring proper critical code section protection (e.g. semaphore,
+ * spin-lock, etc.). - If the IO tag for a request was allocated, by the SCI
+ * Core user, using the scic_controller_allocate_io_tag() method, then it is
+ * the responsibility of the caller to invoke this method to free the tag. This
+ * method returns an indication of whether the tag was successfully put back
+ * (freed) to the pool of available tags. SCI_SUCCESS This return value
+ * indicates the tag was successfully placed into the pool of available IO
+ * tags. SCI_FAILURE_INVALID_IO_TAG This value is returned if the supplied tag
+ * is not a valid IO tag value.
+ */
+enum sci_status scic_controller_free_io_tag(
+	struct scic_sds_controller *scic,
+	u16 io_tag)
+{
+	u16 sequence;
+	u16 index;
+
+	BUG_ON(io_tag == SCI_CONTROLLER_INVALID_IO_TAG);
+
+	sequence = scic_sds_io_tag_get_sequence(io_tag);
+	index    = scic_sds_io_tag_get_index(io_tag);
+
+	if (!sci_pool_full(scic->tci_pool)) {
+		if (sequence == scic->io_request_sequence[index]) {
+			scic_sds_io_sequence_increment(
+				scic->io_request_sequence[index]);
+
+			sci_pool_put(scic->tci_pool, index);
+
+			return SCI_SUCCESS;
+		}
+	}
+
+	return SCI_FAILURE_INVALID_IO_TAG;
+}
+
+

commit ce2b3261b6765c3b80fda95426c73e8d3bb1b035
Author: Dan Williams <dan.j.williams@intel.com>
Date:   Sun May 8 15:49:15 2011 -0700

    isci: unify constants
    
    cross driver constants are spread out over multiple header files, consolidate
    them into isci.h, and push some includes out to the source files that need
    them.
    
    TODO: remove SCI_MODE_SIZE infrastructure.
    TODO: task.h is full of inlines that are too large
    
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/drivers/scsi/isci/host.c b/drivers/scsi/isci/host.c
index 271a7e171e7d..5847149857a9 100644
--- a/drivers/scsi/isci/host.c
+++ b/drivers/scsi/isci/host.c
@@ -60,7 +60,9 @@
 #include "request.h"
 #include "host.h"
 #include "probe_roms.h"
+#include "scic_controller.h"
 #include "scic_sds_controller.h"
+#include "timers.h"
 
 irqreturn_t isci_msix_isr(int vec, void *data)
 {

commit 67ea838d17acdad3331aeae848683c768df96aaa
Author: Dan Williams <dan.j.williams@intel.com>
Date:   Sun May 8 11:47:15 2011 -0700

    isci: unify request data structures
    
    Make scic_sds_request a proper member of isci_request.  Also let's us
    get rid of the dma pool object size tracking since we now know that all
    requests are sizeof(isci_request).  While cleaning up the construct
    routine incidentally replaced SCI_FIELD_OFFSET with offsetof.
    
    Reported-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/drivers/scsi/isci/host.c b/drivers/scsi/isci/host.c
index 4d0ee7bf847b..271a7e171e7d 100644
--- a/drivers/scsi/isci/host.c
+++ b/drivers/scsi/isci/host.c
@@ -428,14 +428,8 @@ int isci_host_init(struct isci_host *isci_host)
 	if (err)
 		return err;
 
-	/*
-	 * keep the pool alloc size around, will use it for a bounds checking
-	 * when trying to convert virtual addresses to physical addresses
-	 */
-	isci_host->dma_pool_alloc_size = sizeof(struct isci_request) +
-					 sizeof(struct scic_sds_request);
 	isci_host->dma_pool = dmam_pool_create(DRV_NAME, &isci_host->pdev->dev,
-					       isci_host->dma_pool_alloc_size,
+					       sizeof(struct isci_request),
 					       SLAB_HWCACHE_ALIGN, 0);
 
 	if (!isci_host->dma_pool)

commit b7645818cff1536038c0b21407eefb6b9d5755e6
Author: Dan Williams <dan.j.williams@intel.com>
Date:   Sun May 8 02:35:32 2011 -0700

    isci: make command/response iu explicit request object members
    
    Final elimination of the anonymous data at the end of the request
    structure.
    
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/drivers/scsi/isci/host.c b/drivers/scsi/isci/host.c
index cdd99304c363..4d0ee7bf847b 100644
--- a/drivers/scsi/isci/host.c
+++ b/drivers/scsi/isci/host.c
@@ -433,7 +433,7 @@ int isci_host_init(struct isci_host *isci_host)
 	 * when trying to convert virtual addresses to physical addresses
 	 */
 	isci_host->dma_pool_alloc_size = sizeof(struct isci_request) +
-					 scic_io_request_get_object_size();
+					 sizeof(struct scic_sds_request);
 	isci_host->dma_pool = dmam_pool_create(DRV_NAME, &isci_host->pdev->dev,
 					       isci_host->dma_pool_alloc_size,
 					       SLAB_HWCACHE_ALIGN, 0);

commit e531381e2f8a68b8737c63c7bb890ad80b2470bd
Author: Dan Williams <dan.j.williams@intel.com>
Date:   Sat May 7 10:11:43 2011 -0700

    isci: unify port data structures
    
    Make scic_sds_port a member of isci_port and merge their lifetimes which
    means removing the port table from scic_sds_controller in favor of the
    one at the isci_host level.  Merge ihost->sas_ports into ihost->ports.
    _
    Reported-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/drivers/scsi/isci/host.c b/drivers/scsi/isci/host.c
index d180ad8a8bcf..cdd99304c363 100644
--- a/drivers/scsi/isci/host.c
+++ b/drivers/scsi/isci/host.c
@@ -277,10 +277,10 @@ void isci_host_deinit(struct isci_host *ihost)
 
 	isci_host_change_state(ihost, isci_stopping);
 	for (i = 0; i < SCI_MAX_PORTS; i++) {
-		struct isci_port *port = &ihost->isci_ports[i];
+		struct isci_port *iport = &ihost->ports[i];
 		struct isci_remote_device *idev, *d;
 
-		list_for_each_entry_safe(idev, d, &port->remote_dev_list, node) {
+		list_for_each_entry_safe(idev, d, &iport->remote_dev_list, node) {
 			isci_remote_device_change_state(idev, isci_stopping);
 			isci_remote_device_stop(ihost, idev);
 		}
@@ -442,7 +442,7 @@ int isci_host_init(struct isci_host *isci_host)
 		return -ENOMEM;
 
 	for (i = 0; i < SCI_MAX_PORTS; i++)
-		isci_port_init(&isci_host->isci_ports[i], isci_host, i);
+		isci_port_init(&isci_host->ports[i], isci_host, i);
 
 	for (i = 0; i < SCI_MAX_PHYS; i++)
 		isci_phy_init(&isci_host->phys[i], isci_host, i);

commit cc3dbd0a9178865d4444f8e28b51715808e9ac85
Author: Artur Wojcik <artur.wojcik@intel.com>
Date:   Wed May 4 07:58:16 2011 +0000

    isci: unify isci_host data structures
    
    Make it explicit that isci_host and scic_sds_controller are one in the same
    object.
    
    Signed-off-by: Artur Wojcik <artur.wojcik@intel.com>
    [removed ->ihost back pointer]
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/drivers/scsi/isci/host.c b/drivers/scsi/isci/host.c
index 55bfa3dbfb8f..d180ad8a8bcf 100644
--- a/drivers/scsi/isci/host.c
+++ b/drivers/scsi/isci/host.c
@@ -65,9 +65,8 @@
 irqreturn_t isci_msix_isr(int vec, void *data)
 {
 	struct isci_host *ihost = data;
-	struct scic_sds_controller *scic = ihost->core_controller;
 
-	if (scic_sds_controller_isr(scic))
+	if (scic_sds_controller_isr(&ihost->sci))
 		tasklet_schedule(&ihost->completion_tasklet);
 
 	return IRQ_HANDLED;
@@ -77,7 +76,7 @@ irqreturn_t isci_intx_isr(int vec, void *data)
 {
 	irqreturn_t ret = IRQ_NONE;
 	struct isci_host *ihost = data;
-	struct scic_sds_controller *scic = ihost->core_controller;
+	struct scic_sds_controller *scic = &ihost->sci;
 
 	if (scic_sds_controller_isr(scic)) {
 		writel(SMU_ISR_COMPLETION, &scic->smu_registers->interrupt_status);
@@ -96,10 +95,9 @@ irqreturn_t isci_intx_isr(int vec, void *data)
 irqreturn_t isci_error_isr(int vec, void *data)
 {
 	struct isci_host *ihost = data;
-	struct scic_sds_controller *scic = ihost->core_controller;
 
-	if (scic_sds_controller_error_isr(scic))
-		scic_sds_controller_error_handler(scic);
+	if (scic_sds_controller_error_isr(&ihost->sci))
+		scic_sds_controller_error_handler(&ihost->sci);
 
 	return IRQ_HANDLED;
 }
@@ -145,21 +143,20 @@ int isci_host_scan_finished(struct Scsi_Host *shost, unsigned long time)
 void isci_host_scan_start(struct Scsi_Host *shost)
 {
 	struct isci_host *ihost = SHOST_TO_SAS_HA(shost)->lldd_ha;
-	struct scic_sds_controller *scic = ihost->core_controller;
-	unsigned long tmo = scic_controller_get_suggested_start_timeout(scic);
+	unsigned long tmo = scic_controller_get_suggested_start_timeout(&ihost->sci);
 
 	set_bit(IHOST_START_PENDING, &ihost->flags);
 
 	spin_lock_irq(&ihost->scic_lock);
-	scic_controller_start(scic, tmo);
-	scic_controller_enable_interrupts(scic);
+	scic_controller_start(&ihost->sci, tmo);
+	scic_controller_enable_interrupts(&ihost->sci);
 	spin_unlock_irq(&ihost->scic_lock);
 }
 
 void isci_host_stop_complete(struct isci_host *ihost, enum sci_status completion_status)
 {
 	isci_host_change_state(ihost, isci_stopped);
-	scic_controller_disable_interrupts(ihost->core_controller);
+	scic_controller_disable_interrupts(&ihost->sci);
 	clear_bit(IHOST_STOP_PENDING, &ihost->flags);
 	wake_up(&ihost->eventq);
 }
@@ -188,7 +185,7 @@ static void isci_host_completion_routine(unsigned long data)
 
 	spin_lock_irq(&isci_host->scic_lock);
 
-	scic_sds_controller_completion_handler(isci_host->core_controller);
+	scic_sds_controller_completion_handler(&isci_host->sci);
 
 	/* Take the lists of completed I/Os from the host. */
 
@@ -276,7 +273,6 @@ static void isci_host_completion_routine(unsigned long data)
 
 void isci_host_deinit(struct isci_host *ihost)
 {
-	struct scic_sds_controller *scic = ihost->core_controller;
 	int i;
 
 	isci_host_change_state(ihost, isci_stopping);
@@ -293,11 +289,11 @@ void isci_host_deinit(struct isci_host *ihost)
 	set_bit(IHOST_STOP_PENDING, &ihost->flags);
 
 	spin_lock_irq(&ihost->scic_lock);
-	scic_controller_stop(scic, SCIC_CONTROLLER_STOP_TIMEOUT);
+	scic_controller_stop(&ihost->sci, SCIC_CONTROLLER_STOP_TIMEOUT);
 	spin_unlock_irq(&ihost->scic_lock);
 
 	wait_for_stop(ihost);
-	scic_controller_reset(scic);
+	scic_controller_reset(&ihost->sci);
 	isci_timer_list_destroy(ihost);
 }
 
@@ -347,25 +343,12 @@ int isci_host_init(struct isci_host *isci_host)
 {
 	int err = 0, i;
 	enum sci_status status;
-	struct scic_sds_controller *controller;
 	union scic_oem_parameters oem;
 	union scic_user_parameters scic_user_params;
 	struct isci_pci_info *pci_info = to_pci_info(isci_host->pdev);
 
 	isci_timer_list_construct(isci_host);
 
-	controller = scic_controller_alloc(&isci_host->pdev->dev);
-
-	if (!controller) {
-		dev_err(&isci_host->pdev->dev,
-			"%s: failed (%d)\n",
-			__func__,
-			err);
-		return -ENOMEM;
-	}
-
-	isci_host->core_controller = controller;
-	controller->ihost = isci_host;
 	spin_lock_init(&isci_host->state_lock);
 	spin_lock_init(&isci_host->scic_lock);
 	spin_lock_init(&isci_host->queue_lock);
@@ -374,7 +357,7 @@ int isci_host_init(struct isci_host *isci_host)
 	isci_host_change_state(isci_host, isci_starting);
 	isci_host->can_queue = ISCI_CAN_QUEUE_VAL;
 
-	status = scic_controller_construct(controller, scu_base(isci_host),
+	status = scic_controller_construct(&isci_host->sci, scu_base(isci_host),
 					   smu_base(isci_host));
 
 	if (status != SCI_SUCCESS) {
@@ -393,7 +376,7 @@ int isci_host_init(struct isci_host *isci_host)
 	 * parameters
 	 */
 	isci_user_parameters_get(isci_host, &scic_user_params);
-	status = scic_user_parameters_set(isci_host->core_controller,
+	status = scic_user_parameters_set(&isci_host->sci,
 					  &scic_user_params);
 	if (status != SCI_SUCCESS) {
 		dev_warn(&isci_host->pdev->dev,
@@ -402,7 +385,7 @@ int isci_host_init(struct isci_host *isci_host)
 		return -ENODEV;
 	}
 
-	scic_oem_parameters_get(controller, &oem);
+	scic_oem_parameters_get(&isci_host->sci, &oem);
 
 	/* grab any OEM parameters specified in orom */
 	if (pci_info->orom) {
@@ -416,7 +399,7 @@ int isci_host_init(struct isci_host *isci_host)
 		}
 	}
 
-	status = scic_oem_parameters_set(isci_host->core_controller, &oem);
+	status = scic_oem_parameters_set(&isci_host->sci, &oem);
 	if (status != SCI_SUCCESS) {
 		dev_warn(&isci_host->pdev->dev,
 				"%s: scic_oem_parameters_set failed\n",
@@ -431,7 +414,7 @@ int isci_host_init(struct isci_host *isci_host)
 	INIT_LIST_HEAD(&isci_host->requests_to_errorback);
 
 	spin_lock_irq(&isci_host->scic_lock);
-	status = scic_controller_initialize(isci_host->core_controller);
+	status = scic_controller_initialize(&isci_host->sci);
 	spin_unlock_irq(&isci_host->scic_lock);
 	if (status != SCI_SUCCESS) {
 		dev_warn(&isci_host->pdev->dev,
@@ -441,7 +424,7 @@ int isci_host_init(struct isci_host *isci_host)
 		return -ENODEV;
 	}
 
-	err = scic_controller_mem_init(isci_host->core_controller);
+	err = scic_controller_mem_init(&isci_host->sci);
 	if (err)
 		return err;
 

commit d3757c3aeb75259e0b86a872e98841a2ea4cb5e8
Author: Maciej Patelczyk <maciej.patelczyk@intel.com>
Date:   Thu Apr 28 22:06:06 2011 +0000

    isci: Removed sci_base_object from scic_sds_controller.
    
    The 'struct sci_base_object' was removed from the struct
    scic_sds_controller and was replaced by a pointer to
    struct isci_host.
    
    Signed-off-by: Maciej Patelczyk <maciej.patelczyk@intel.com>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/drivers/scsi/isci/host.c b/drivers/scsi/isci/host.c
index 676bcdbfc316..55bfa3dbfb8f 100644
--- a/drivers/scsi/isci/host.c
+++ b/drivers/scsi/isci/host.c
@@ -365,7 +365,7 @@ int isci_host_init(struct isci_host *isci_host)
 	}
 
 	isci_host->core_controller = controller;
-	sci_object_set_association(isci_host->core_controller, isci_host);
+	controller->ihost = isci_host;
 	spin_lock_init(&isci_host->state_lock);
 	spin_lock_init(&isci_host->scic_lock);
 	spin_lock_init(&isci_host->queue_lock);

commit 88f3b62ac131e2549b6c262cacbd47e8cca42d6e
Author: Dan Williams <dan.j.williams@intel.com>
Date:   Fri Apr 22 19:18:03 2011 -0700

    isci: move remote_device handling out of the core
    
    Now that the core/lldd remote_device data structures are nominally unified
    merge the corresponding sources into the top-level directory.  Also move the
    remote_node_context infrastructure which has no analog at the lldd level.
    
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/drivers/scsi/isci/host.c b/drivers/scsi/isci/host.c
index 3aceb9219d7b..676bcdbfc316 100644
--- a/drivers/scsi/isci/host.c
+++ b/drivers/scsi/isci/host.c
@@ -55,14 +55,12 @@
 
 #include "isci.h"
 #include "scic_io_request.h"
-#include "scic_remote_device.h"
 #include "scic_port.h"
-
 #include "port.h"
 #include "request.h"
 #include "host.h"
 #include "probe_roms.h"
-#include "core/scic_sds_controller.h"
+#include "scic_sds_controller.h"
 
 irqreturn_t isci_msix_isr(int vec, void *data)
 {

commit 57f20f4ed6fb702339be2ef4dea9d15e6a7d0d07
Author: Dan Williams <dan.j.williams@intel.com>
Date:   Thu Apr 21 18:14:45 2011 -0700

    isci: unify remote_device data structures
    
    Make it explicit that isci_remote_device and scic_sds_remote_device are
    one in the same object.
    
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/drivers/scsi/isci/host.c b/drivers/scsi/isci/host.c
index 0d706b2ce25e..3aceb9219d7b 100644
--- a/drivers/scsi/isci/host.c
+++ b/drivers/scsi/isci/host.c
@@ -467,7 +467,7 @@ int isci_host_init(struct isci_host *isci_host)
 		isci_phy_init(&isci_host->phys[i], isci_host, i);
 
 	for (i = 0; i < SCI_MAX_REMOTE_DEVICES; i++) {
-		struct isci_remote_device *idev = idev_by_id(isci_host, i);
+		struct isci_remote_device *idev = &isci_host->devices[i];
 
 		INIT_LIST_HEAD(&idev->reqs_in_process);
 		INIT_LIST_HEAD(&idev->node);

commit 31e824ed0d8c84c5232405167b2338ffc071ae8a
Author: Dan Williams <dan.j.williams@intel.com>
Date:   Tue Apr 19 12:32:51 2011 -0700

    isci: rely on irq core for intx multiplexing, and silence screaming intx
    
    Remove the extra logic to poll each controller for interrupts, that's
    the core's job for shared interrupts.
    
    While testing noticed that a number of interrupts fire while waiting for
    the completion tasklet to run, so added an irq-ack.
    
    Reported-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/drivers/scsi/isci/host.c b/drivers/scsi/isci/host.c
index 927f08892ad6..0d706b2ce25e 100644
--- a/drivers/scsi/isci/host.c
+++ b/drivers/scsi/isci/host.c
@@ -77,23 +77,19 @@ irqreturn_t isci_msix_isr(int vec, void *data)
 
 irqreturn_t isci_intx_isr(int vec, void *data)
 {
-	struct pci_dev *pdev = data;
-	struct isci_host *ihost;
 	irqreturn_t ret = IRQ_NONE;
-	int i;
+	struct isci_host *ihost = data;
+	struct scic_sds_controller *scic = ihost->core_controller;
 
-	for_each_isci_host(i, ihost, pdev) {
-		struct scic_sds_controller *scic = ihost->core_controller;
-
-		if (scic_sds_controller_isr(scic)) {
-			tasklet_schedule(&ihost->completion_tasklet);
-			ret = IRQ_HANDLED;
-		} else if (scic_sds_controller_error_isr(scic)) {
-			spin_lock(&ihost->scic_lock);
-			scic_sds_controller_error_handler(scic);
-			spin_unlock(&ihost->scic_lock);
-			ret = IRQ_HANDLED;
-		}
+	if (scic_sds_controller_isr(scic)) {
+		writel(SMU_ISR_COMPLETION, &scic->smu_registers->interrupt_status);
+		tasklet_schedule(&ihost->completion_tasklet);
+		ret = IRQ_HANDLED;
+	} else if (scic_sds_controller_error_isr(scic)) {
+		spin_lock(&ihost->scic_lock);
+		scic_sds_controller_error_handler(scic);
+		spin_unlock(&ihost->scic_lock);
+		ret = IRQ_HANDLED;
 	}
 
 	return ret;

commit bc5c96748a5f2067193faa8131b2aa5f9775d309
Author: Christoph Hellwig <hch@infradead.org>
Date:   Sat Apr 2 08:15:04 2011 -0400

    isci: simplify dma coherent allocation
    
    Remove the insane infrastructure for preallocating coheren DMA regions,
    and just allocate the memory where needed.  This also gets rid of the
    aligment adjustments given that Documentation/DMA-API-HOWTO.txt sais:
    
      "The cpu return address and the DMA bus master address are both
       guaranteed to be aligned to the smallest PAGE_SIZE order which
       is greater than or equal to the requested size.  This invariant
       exists (for example) to guarantee that if you allocate a chunk
       which is smaller than or equal to 64 kilobytes, the extent of the
       buffer you receive will not cross a 64K boundary."
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    [djbw: moved allocation from start to init, re-add memset]
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/drivers/scsi/isci/host.c b/drivers/scsi/isci/host.c
index adfc2452d216..927f08892ad6 100644
--- a/drivers/scsi/isci/host.c
+++ b/drivers/scsi/isci/host.c
@@ -170,96 +170,6 @@ void isci_host_stop_complete(struct isci_host *ihost, enum sci_status completion
 	wake_up(&ihost->eventq);
 }
 
-static struct coherent_memory_info *isci_host_alloc_mdl_struct(
-	struct isci_host *isci_host,
-	u32 size)
-{
-	struct coherent_memory_info *mdl_struct;
-	void *uncached_address = NULL;
-
-
-	mdl_struct = devm_kzalloc(&isci_host->pdev->dev,
-				  sizeof(*mdl_struct),
-				  GFP_KERNEL);
-	if (!mdl_struct)
-		return NULL;
-
-	INIT_LIST_HEAD(&mdl_struct->node);
-
-	uncached_address = dmam_alloc_coherent(&isci_host->pdev->dev,
-					       size,
-					       &mdl_struct->dma_handle,
-					       GFP_KERNEL);
-	if (!uncached_address)
-		return NULL;
-
-	/* memset the whole memory area. */
-	memset((char *)uncached_address, 0, size);
-	mdl_struct->vaddr = uncached_address;
-	mdl_struct->size = (size_t)size;
-
-	return mdl_struct;
-}
-
-static void isci_host_build_mde(
-	struct sci_physical_memory_descriptor *mde_struct,
-	struct coherent_memory_info *mdl_struct)
-{
-	unsigned long address = 0;
-	dma_addr_t dma_addr = 0;
-
-	address = (unsigned long)mdl_struct->vaddr;
-	dma_addr = mdl_struct->dma_handle;
-
-	/* to satisfy the alignment. */
-	if ((address % mde_struct->constant_memory_alignment) != 0) {
-		int align_offset
-			= (mde_struct->constant_memory_alignment
-			   - (address % mde_struct->constant_memory_alignment));
-		address += align_offset;
-		dma_addr += align_offset;
-	}
-
-	mde_struct->virtual_address = (void *)address;
-	mde_struct->physical_address = dma_addr;
-	mdl_struct->mde = mde_struct;
-}
-
-static int isci_host_mdl_allocate_coherent(
-	struct isci_host *isci_host)
-{
-	struct sci_physical_memory_descriptor *current_mde;
-	struct coherent_memory_info *mdl_struct;
-	u32 size = 0;
-
-	struct sci_base_memory_descriptor_list *mdl_handle =
-		&isci_host->core_controller->mdl;
-
-	sci_mdl_first_entry(mdl_handle);
-
-	current_mde = sci_mdl_get_current_entry(mdl_handle);
-
-	while (current_mde != NULL) {
-
-		size = (current_mde->constant_memory_size
-			+ current_mde->constant_memory_alignment);
-
-		mdl_struct = isci_host_alloc_mdl_struct(isci_host, size);
-		if (!mdl_struct)
-			return -ENOMEM;
-
-		list_add_tail(&mdl_struct->node, &isci_host->mdl_struct_list);
-
-		isci_host_build_mde(current_mde, mdl_struct);
-
-		sci_mdl_next_entry(mdl_handle);
-		current_mde = sci_mdl_get_current_entry(mdl_handle);
-	}
-
-	return 0;
-}
-
-
 /**
  * isci_host_completion_routine() - This function is the delayed service
  *    routine that calls the sci core library's completion handler. It's
@@ -523,8 +433,6 @@ int isci_host_init(struct isci_host *isci_host)
 	tasklet_init(&isci_host->completion_tasklet,
 		     isci_host_completion_routine, (unsigned long)isci_host);
 
-	INIT_LIST_HEAD(&(isci_host->mdl_struct_list));
-
 	INIT_LIST_HEAD(&isci_host->requests_to_complete);
 	INIT_LIST_HEAD(&isci_host->requests_to_errorback);
 
@@ -539,8 +447,7 @@ int isci_host_init(struct isci_host *isci_host)
 		return -ENODEV;
 	}
 
-	/* populate mdl with dma memory. scu_mdl_allocate_coherent() */
-	err = isci_host_mdl_allocate_coherent(isci_host);
+	err = scic_controller_mem_init(isci_host->core_controller);
 	if (err)
 		return err;
 

commit ca841f0e862bccd61f537b76c94579c1bd391448
Author: Christoph Hellwig <hch@infradead.org>
Date:   Mon Mar 28 09:21:04 2011 -0400

    isci: remove base_controller abstraction
    
    Merge struct sci_base_controller into scic_sds_controller, and also factor
    the two types of state machine handlers into one function.  While we're at
    it also remove lots of duplicate incorrect kerneldoc comments for the state
    machine handlers.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/drivers/scsi/isci/host.c b/drivers/scsi/isci/host.c
index 66449593aa8c..adfc2452d216 100644
--- a/drivers/scsi/isci/host.c
+++ b/drivers/scsi/isci/host.c
@@ -62,6 +62,7 @@
 #include "request.h"
 #include "host.h"
 #include "probe_roms.h"
+#include "core/scic_sds_controller.h"
 
 irqreturn_t isci_msix_isr(int vec, void *data)
 {
@@ -231,9 +232,8 @@ static int isci_host_mdl_allocate_coherent(
 	struct coherent_memory_info *mdl_struct;
 	u32 size = 0;
 
-	struct sci_base_memory_descriptor_list *mdl_handle
-		= sci_controller_get_memory_descriptor_list_handle(
-		isci_host->core_controller);
+	struct sci_base_memory_descriptor_list *mdl_handle =
+		&isci_host->core_controller->mdl;
 
 	sci_mdl_first_entry(mdl_handle);
 

commit 4393aa4e6b9517a666f0ef6b774fd421a9dc4c68
Author: Dan Williams <dan.j.williams@intel.com>
Date:   Thu Mar 31 13:10:44 2011 -0700

    isci: fix fragile/conditional isci_host lookups
    
    A domain_device can always reference back to ->lldd_ha unlike local lldd
    structures.  Fix up cases where the driver uses local objects to look up the
    isci_host.  This also changes the calling conventions of some routines to
    expect a valid isci_host parameter rather than re-lookup the pointer on entry.
    
    Incidentally cleans up some macros that are longer to type than the open-coded
    equivalent:
      isci_host_from_sas_ha
      isci_dev_from_domain_dev
    
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/drivers/scsi/isci/host.c b/drivers/scsi/isci/host.c
index 79515be5f7c1..66449593aa8c 100644
--- a/drivers/scsi/isci/host.c
+++ b/drivers/scsi/isci/host.c
@@ -129,7 +129,7 @@ void isci_host_start_complete(struct isci_host *ihost, enum sci_status completio
 
 int isci_host_scan_finished(struct Scsi_Host *shost, unsigned long time)
 {
-	struct isci_host *ihost = isci_host_from_sas_ha(SHOST_TO_SAS_HA(shost));
+	struct isci_host *ihost = SHOST_TO_SAS_HA(shost)->lldd_ha;
 
 	if (test_bit(IHOST_START_PENDING, &ihost->flags))
 		return 0;
@@ -149,7 +149,7 @@ int isci_host_scan_finished(struct Scsi_Host *shost, unsigned long time)
 
 void isci_host_scan_start(struct Scsi_Host *shost)
 {
-	struct isci_host *ihost = isci_host_from_sas_ha(SHOST_TO_SAS_HA(shost));
+	struct isci_host *ihost = SHOST_TO_SAS_HA(shost)->lldd_ha;
 	struct scic_sds_controller *scic = ihost->core_controller;
 	unsigned long tmo = scic_controller_get_suggested_start_timeout(scic);
 

commit b5f18a201ed82ed3776c9950646689b93713ae57
Author: Dave Jiang <dave.jiang@intel.com>
Date:   Wed Mar 16 14:57:23 2011 -0700

    isci: exposing user parameters via module params
    
    Exposing the user config parameters through the kernel module parameters.
    The kernel module params will have the default values set and we will no
    longer pulling the default values for user params from the core.
    
    Signed-off-by: Dave Jiang <dave.jiang@intel.com>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/drivers/scsi/isci/host.c b/drivers/scsi/isci/host.c
index d6e2a73e797a..79515be5f7c1 100644
--- a/drivers/scsi/isci/host.c
+++ b/drivers/scsi/isci/host.c
@@ -413,6 +413,32 @@ static void __iomem *smu_base(struct isci_host *isci_host)
 	return pcim_iomap_table(pdev)[SCI_SMU_BAR * 2] + SCI_SMU_BAR_SIZE * id;
 }
 
+static void isci_user_parameters_get(
+		struct isci_host *isci_host,
+		union scic_user_parameters *scic_user_params)
+{
+	struct scic_sds_user_parameters *u = &scic_user_params->sds1;
+	int i;
+
+	for (i = 0; i < SCI_MAX_PHYS; i++) {
+		struct sci_phy_user_params *u_phy = &u->phys[i];
+
+		u_phy->max_speed_generation = phy_gen;
+
+		/* we are not exporting these for now */
+		u_phy->align_insertion_frequency = 0x7f;
+		u_phy->in_connection_align_insertion_frequency = 0xff;
+		u_phy->notify_enable_spin_up_insertion_frequency = 0x33;
+	}
+
+	u->stp_inactivity_timeout = stp_inactive_to;
+	u->ssp_inactivity_timeout = ssp_inactive_to;
+	u->stp_max_occupancy_timeout = stp_max_occ_to;
+	u->ssp_max_occupancy_timeout = ssp_max_occ_to;
+	u->no_outbound_task_timeout = no_outbound_task_to;
+	u->max_number_concurrent_device_spin_up = max_concurr_spinup;
+}
+
 int isci_host_init(struct isci_host *isci_host)
 {
 	int err = 0, i;
@@ -462,7 +488,7 @@ int isci_host_init(struct isci_host *isci_host)
 	 * grab initial values stored in the controller object for OEM and USER
 	 * parameters
 	 */
-	scic_user_parameters_get(controller, &scic_user_params);
+	isci_user_parameters_get(isci_host, &scic_user_params);
 	status = scic_user_parameters_set(isci_host->core_controller,
 					  &scic_user_params);
 	if (status != SCI_SUCCESS) {

commit 4711ba10b13891edf228944a9d0a21dfe7fe90f0
Author: Dan Williams <dan.j.williams@intel.com>
Date:   Fri Mar 11 10:43:57 2011 -0800

    isci: fix oem parameter initialization and mode detection
    
    1/ Since commit 858d4aa7 "isci: Move firmware loading to per PCI device" we have
       been silently falling back to built-in defaults for the parameter settings by
       skipping the call to scic_oem_parameters_set().
    
    2/ The afe parameters from the firmware were not being honored
    
    3/ The latest oem parameter definition flips the mode_type values which are
       now 0: for APC 1: for MPC.  For APC we need to make sure all the phys
       default to the same address otherwise strict_wide_ports will cause duplicate
       domains.
    
    4/ Fix up the driver announcement to indicate the source of the
       parameters.
    
    5/ Fix up the sas addresses to be unique per controller (in the fallback case)
    
    Signed-off-by: Dave Jiang <dave.jiang@intel.com>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/drivers/scsi/isci/host.c b/drivers/scsi/isci/host.c
index bb5b54d361b0..d6e2a73e797a 100644
--- a/drivers/scsi/isci/host.c
+++ b/drivers/scsi/isci/host.c
@@ -418,7 +418,7 @@ int isci_host_init(struct isci_host *isci_host)
 	int err = 0, i;
 	enum sci_status status;
 	struct scic_sds_controller *controller;
-	union scic_oem_parameters scic_oem_params;
+	union scic_oem_parameters oem;
 	union scic_user_parameters scic_user_params;
 	struct isci_pci_info *pci_info = to_pci_info(isci_host->pdev);
 
@@ -435,6 +435,7 @@ int isci_host_init(struct isci_host *isci_host)
 	}
 
 	isci_host->core_controller = controller;
+	sci_object_set_association(isci_host->core_controller, isci_host);
 	spin_lock_init(&isci_host->state_lock);
 	spin_lock_init(&isci_host->scic_lock);
 	spin_lock_init(&isci_host->queue_lock);
@@ -457,12 +458,6 @@ int isci_host_init(struct isci_host *isci_host)
 	isci_host->sas_ha.dev = &isci_host->pdev->dev;
 	isci_host->sas_ha.lldd_ha = isci_host;
 
-	/*----------- SCIC controller Initialization Stuff ------------------
-	 * set association host adapter struct in core controller.
-	 */
-	sci_object_set_association(isci_host->core_controller,
-				   (void *)isci_host);
-
 	/*
 	 * grab initial values stored in the controller object for OEM and USER
 	 * parameters
@@ -477,11 +472,11 @@ int isci_host_init(struct isci_host *isci_host)
 		return -ENODEV;
 	}
 
-	scic_oem_parameters_get(controller, &scic_oem_params);
+	scic_oem_parameters_get(controller, &oem);
 
 	/* grab any OEM parameters specified in orom */
 	if (pci_info->orom) {
-		status = isci_parse_oem_parameters(&scic_oem_params,
+		status = isci_parse_oem_parameters(&oem,
 						   pci_info->orom,
 						   isci_host->id);
 		if (status != SCI_SUCCESS) {
@@ -489,15 +484,14 @@ int isci_host_init(struct isci_host *isci_host)
 				 "parsing firmware oem parameters failed\n");
 			return -EINVAL;
 		}
-	} else {
-		status = scic_oem_parameters_set(isci_host->core_controller,
-						 &scic_oem_params);
-		if (status != SCI_SUCCESS) {
-			dev_warn(&isci_host->pdev->dev,
-				 "%s: scic_oem_parameters_set failed\n",
-				 __func__);
-			return -ENODEV;
-		}
+	}
+
+	status = scic_oem_parameters_set(isci_host->core_controller, &oem);
+	if (status != SCI_SUCCESS) {
+		dev_warn(&isci_host->pdev->dev,
+				"%s: scic_oem_parameters_set failed\n",
+				__func__);
+		return -ENODEV;
 	}
 
 	tasklet_init(&isci_host->completion_tasklet,

commit d044af17aacd03a1f4fced1af4b7570d205c8fd9
Author: Dan Williams <dan.j.williams@intel.com>
Date:   Tue Mar 8 09:52:49 2011 -0800

    isci: Add support for probing OROM for OEM params
    
    We need to scan the OROM for signature and grab the OEM parameters. We
    also need to do the same for EFI. If all fails then we resort to user
    binary blob, and if that fails then we go to the defaults.
    
    Share the format with the create_fw utility so that all possible sources
    of the parameters are in-sync.
    
    Signed-off-by: Dave Jiang <dave.jiang@intel.com>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/drivers/scsi/isci/host.c b/drivers/scsi/isci/host.c
index dc231c22ea93..bb5b54d361b0 100644
--- a/drivers/scsi/isci/host.c
+++ b/drivers/scsi/isci/host.c
@@ -61,6 +61,7 @@
 #include "port.h"
 #include "request.h"
 #include "host.h"
+#include "probe_roms.h"
 
 irqreturn_t isci_msix_isr(int vec, void *data)
 {
@@ -419,6 +420,7 @@ int isci_host_init(struct isci_host *isci_host)
 	struct scic_sds_controller *controller;
 	union scic_oem_parameters scic_oem_params;
 	union scic_user_parameters scic_user_params;
+	struct isci_pci_info *pci_info = to_pci_info(isci_host->pdev);
 
 	isci_timer_list_construct(isci_host);
 
@@ -461,31 +463,32 @@ int isci_host_init(struct isci_host *isci_host)
 	sci_object_set_association(isci_host->core_controller,
 				   (void *)isci_host);
 
-	/* grab initial values stored in the controller object for OEM and USER
-	 * parameters */
-	scic_oem_parameters_get(controller, &scic_oem_params);
+	/*
+	 * grab initial values stored in the controller object for OEM and USER
+	 * parameters
+	 */
 	scic_user_parameters_get(controller, &scic_user_params);
+	status = scic_user_parameters_set(isci_host->core_controller,
+					  &scic_user_params);
+	if (status != SCI_SUCCESS) {
+		dev_warn(&isci_host->pdev->dev,
+			 "%s: scic_user_parameters_set failed\n",
+			 __func__);
+		return -ENODEV;
+	}
+
+	scic_oem_parameters_get(controller, &scic_oem_params);
 
-	if (isci_firmware) {
-		/* grab any OEM and USER parameters specified in binary blob */
+	/* grab any OEM parameters specified in orom */
+	if (pci_info->orom) {
 		status = isci_parse_oem_parameters(&scic_oem_params,
-						   isci_host->id,
-						   isci_firmware);
+						   pci_info->orom,
+						   isci_host->id);
 		if (status != SCI_SUCCESS) {
 			dev_warn(&isci_host->pdev->dev,
 				 "parsing firmware oem parameters failed\n");
 			return -EINVAL;
 		}
-
-		status = isci_parse_user_parameters(&scic_user_params,
-						    isci_host->id,
-						    isci_firmware);
-		if (status != SCI_SUCCESS) {
-			dev_warn(&isci_host->pdev->dev,
-				 "%s: isci_parse_user_parameters"
-				 " failed\n", __func__);
-			return -EINVAL;
-		}
 	} else {
 		status = scic_oem_parameters_set(isci_host->core_controller,
 						 &scic_oem_params);
@@ -495,16 +498,6 @@ int isci_host_init(struct isci_host *isci_host)
 				 __func__);
 			return -ENODEV;
 		}
-
-
-		status = scic_user_parameters_set(isci_host->core_controller,
-						  &scic_user_params);
-		if (status != SCI_SUCCESS) {
-			dev_warn(&isci_host->pdev->dev,
-				 "%s: scic_user_parameters_set failed\n",
-				 __func__);
-			return -ENODEV;
-		}
 	}
 
 	tasklet_init(&isci_host->completion_tasklet,

commit ec6c9638b0d0537430f78a3e20503b5e68a537b6
Author: Jeff Skirvin <jeffrey.d.skirvin@intel.com>
Date:   Fri Mar 4 14:06:44 2011 -0800

    isci: Any reset indicated on an I/O completion escalates it to the error path.
    
    If there is a pending device reset, the I/O is used to accomplish the reset by setting the
    RESET bit in the task status, and then putting the task into the error handler
    path using sas abort task.
    
    Signed-off-by: Jeff Skirvin <jeffrey.d.skirvin@intel.com>
    Signed-off-by: Jacek Danecki <Jacek.Danecki@intel.com>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/drivers/scsi/isci/host.c b/drivers/scsi/isci/host.c
index 153f419f1618..dc231c22ea93 100644
--- a/drivers/scsi/isci/host.c
+++ b/drivers/scsi/isci/host.c
@@ -290,17 +290,6 @@ static void isci_host_completion_routine(unsigned long data)
 	list_splice_init(&isci_host->requests_to_complete,
 			 &completed_request_list);
 
-	/* While holding the scic_lock take all of the normally completed
-	 * I/Os off of the device's pending lists.
-	 */
-	list_for_each_entry(request, &completed_request_list, completed_node) {
-
-		/* Remove the request from the remote device's list
-		* of pending requests.
-		*/
-		list_del_init(&request->dev_node);
-	}
-
 	/* Take the list of errored I/Os from the host. */
 	list_splice_init(&isci_host->requests_to_errorback,
 			 &errored_request_list);

commit 11b00c194cfbd0eb0d90f32c096508b2bb8be6ec
Author: Jeff Skirvin <jeffrey.d.skirvin@intel.com>
Date:   Fri Mar 4 14:06:40 2011 -0800

    isci: Changes in isci_host_completion_routine
    
    Changes to move management of the reqs_in_process entry for the request here.
    Made changes to note when the task is already in the abort path and
    cannot be completed through callbacks.
    
    Signed-off-by: Jeff Skirvin <jeffrey.d.skirvin@intel.com>
    Signed-off-by: Jacek Danecki <Jacek.Danecki@intel.com>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/drivers/scsi/isci/host.c b/drivers/scsi/isci/host.c
index ae5d46022073..153f419f1618 100644
--- a/drivers/scsi/isci/host.c
+++ b/drivers/scsi/isci/host.c
@@ -270,27 +270,40 @@ static int isci_host_mdl_allocate_coherent(
 static void isci_host_completion_routine(unsigned long data)
 {
 	struct isci_host *isci_host = (struct isci_host *)data;
-	struct list_head completed_request_list;
-	struct list_head aborted_request_list;
-	struct list_head *current_position;
-	struct list_head *next_position;
+	struct list_head    completed_request_list;
+	struct list_head    errored_request_list;
+	struct list_head    *current_position;
+	struct list_head    *next_position;
 	struct isci_request *request;
 	struct isci_request *next_request;
-	struct sas_task *task;
+	struct sas_task     *task;
 
 	INIT_LIST_HEAD(&completed_request_list);
-	INIT_LIST_HEAD(&aborted_request_list);
+	INIT_LIST_HEAD(&errored_request_list);
 
 	spin_lock_irq(&isci_host->scic_lock);
 
 	scic_sds_controller_completion_handler(isci_host->core_controller);
 
 	/* Take the lists of completed I/Os from the host. */
+
 	list_splice_init(&isci_host->requests_to_complete,
 			 &completed_request_list);
 
-	list_splice_init(&isci_host->requests_to_abort,
-			 &aborted_request_list);
+	/* While holding the scic_lock take all of the normally completed
+	 * I/Os off of the device's pending lists.
+	 */
+	list_for_each_entry(request, &completed_request_list, completed_node) {
+
+		/* Remove the request from the remote device's list
+		* of pending requests.
+		*/
+		list_del_init(&request->dev_node);
+	}
+
+	/* Take the list of errored I/Os from the host. */
+	list_splice_init(&isci_host->requests_to_errorback,
+			 &errored_request_list);
 
 	spin_unlock_irq(&isci_host->scic_lock);
 
@@ -309,13 +322,22 @@ static void isci_host_completion_routine(unsigned long data)
 			request,
 			task);
 
-		task->task_done(task);
-		task->lldd_task = NULL;
+		/* Return the task to libsas */
+		if (task != NULL) {
+
+			task->lldd_task = NULL;
+			if (!(task->task_state_flags & SAS_TASK_STATE_ABORTED)) {
 
+				/* If the task is already in the abort path,
+				* the task_done callback cannot be called.
+				*/
+				task->task_done(task);
+			}
+		}
 		/* Free the request object. */
 		isci_request_free(isci_host, request);
 	}
-	list_for_each_entry_safe(request, next_request, &aborted_request_list,
+	list_for_each_entry_safe(request, next_request, &errored_request_list,
 				 completed_node) {
 
 		task = isci_request_access_task(request);
@@ -327,8 +349,33 @@ static void isci_host_completion_routine(unsigned long data)
 			 request,
 			 task);
 
-		/* Put the task into the abort path. */
-		sas_task_abort(task);
+		if (task != NULL) {
+
+			/* Put the task into the abort path if it's not there
+			 * already.
+			 */
+			if (!(task->task_state_flags & SAS_TASK_STATE_ABORTED))
+				sas_task_abort(task);
+
+		} else {
+			/* This is a case where the request has completed with a
+			 * status such that it needed further target servicing,
+			 * but the sas_task reference has already been removed
+			 * from the request.  Since it was errored, it was not
+			 * being aborted, so there is nothing to do except free
+			 * it.
+			 */
+
+			spin_lock_irq(&isci_host->scic_lock);
+			/* Remove the request from the remote device's list
+			* of pending requests.
+			*/
+			list_del_init(&request->dev_node);
+			spin_unlock_irq(&isci_host->scic_lock);
+
+			/* Free the request object. */
+			isci_request_free(isci_host, request);
+		}
 	}
 
 }
@@ -477,7 +524,7 @@ int isci_host_init(struct isci_host *isci_host)
 	INIT_LIST_HEAD(&(isci_host->mdl_struct_list));
 
 	INIT_LIST_HEAD(&isci_host->requests_to_complete);
-	INIT_LIST_HEAD(&isci_host->requests_to_abort);
+	INIT_LIST_HEAD(&isci_host->requests_to_errorback);
 
 	spin_lock_irq(&isci_host->scic_lock);
 	status = scic_controller_initialize(isci_host->core_controller);

commit d9c37390c4f02153188a64a7a89fa6798dc3ffc2
Author: Dan Williams <dan.j.williams@intel.com>
Date:   Thu Mar 3 17:59:32 2011 -0800

    isci: preallocate remote devices
    
    Until we synchronize against device removal this limits the damage of
    use after free bugs to the driver's own objects.  Unless we implement
    reference counting we need to ensure at least a subset of a remote
    device is valid at all times.  We follow the lead of other libsas
    drivers that also preallocate devices.
    
    This also enforces maximum remote device accounting at the lldd layer,
    but the core may still run out of RNC's before we hit this limit.
    
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/drivers/scsi/isci/host.c b/drivers/scsi/isci/host.c
index 8d255666a657..ae5d46022073 100644
--- a/drivers/scsi/isci/host.c
+++ b/drivers/scsi/isci/host.c
@@ -378,8 +378,7 @@ static void __iomem *smu_base(struct isci_host *isci_host)
 
 int isci_host_init(struct isci_host *isci_host)
 {
-	int err = 0;
-	int index = 0;
+	int err = 0, i;
 	enum sci_status status;
 	struct scic_sds_controller *controller;
 	union scic_oem_parameters scic_oem_params;
@@ -509,13 +508,19 @@ int isci_host_init(struct isci_host *isci_host)
 	if (!isci_host->dma_pool)
 		return -ENOMEM;
 
-	for (index = 0; index < SCI_MAX_PORTS; index++)
-		isci_port_init(&isci_host->isci_ports[index],
-			       isci_host,
-			       index);
+	for (i = 0; i < SCI_MAX_PORTS; i++)
+		isci_port_init(&isci_host->isci_ports[i], isci_host, i);
 
-	for (index = 0; index < SCI_MAX_PHYS; index++)
-		isci_phy_init(&isci_host->phys[index], isci_host, index);
+	for (i = 0; i < SCI_MAX_PHYS; i++)
+		isci_phy_init(&isci_host->phys[i], isci_host, i);
+
+	for (i = 0; i < SCI_MAX_REMOTE_DEVICES; i++) {
+		struct isci_remote_device *idev = idev_by_id(isci_host, i);
+
+		INIT_LIST_HEAD(&idev->reqs_in_process);
+		INIT_LIST_HEAD(&idev->node);
+		spin_lock_init(&idev->state_lock);
+	}
 
 	return 0;
 }

commit 6ad31fec306d532031b2f778f8656385df1b9d8f
Author: Dan Williams <dan.j.williams@intel.com>
Date:   Fri Mar 4 12:10:29 2011 -0800

    isci: replace isci_remote_device completion with event queue
    
    Replace the device completion infrastructure with the controller wide
    event queue.  There was a potential for the stop and ready notifications
    to corrupt each other, now that cannot happen.
    
    The stop pending flag cannot be used until devices are statically
    allocated.  We temporarily need to maintain a completion to handle
    waiting for an object that has disappeared, but we can at least stop
    scribbling on freed memory.
    
    A future change will also get rid of the "stopping" state as it should
    not be exposed to the rest of the driver.
    
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/drivers/scsi/isci/host.c b/drivers/scsi/isci/host.c
index da0c0da4198f..8d255666a657 100644
--- a/drivers/scsi/isci/host.c
+++ b/drivers/scsi/isci/host.c
@@ -345,7 +345,7 @@ void isci_host_deinit(struct isci_host *ihost)
 
 		list_for_each_entry_safe(idev, d, &port->remote_dev_list, node) {
 			isci_remote_device_change_state(idev, isci_stopping);
-			isci_remote_device_stop(idev);
+			isci_remote_device_stop(ihost, idev);
 		}
 	}
 

commit b329aff107543c3c4db26c1572405034c3baf906
Author: Dan Williams <dan.j.williams@intel.com>
Date:   Mon Mar 7 16:02:25 2011 -0800

    isci: kill isci_host list in favor of an array
    
    isci_host_by_id() should have been a clue that an array would have been
    a simpler approach.
    
    Reported-by: James Bottomley <James.Bottomley@suse.de>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/drivers/scsi/isci/host.c b/drivers/scsi/isci/host.c
index 40614e9ab41b..da0c0da4198f 100644
--- a/drivers/scsi/isci/host.c
+++ b/drivers/scsi/isci/host.c
@@ -78,8 +78,9 @@ irqreturn_t isci_intx_isr(int vec, void *data)
 	struct pci_dev *pdev = data;
 	struct isci_host *ihost;
 	irqreturn_t ret = IRQ_NONE;
+	int i;
 
-	for_each_isci_host(ihost, pdev) {
+	for_each_isci_host(i, ihost, pdev) {
 		struct scic_sds_controller *scic = ihost->core_controller;
 
 		if (scic_sds_controller_isr(scic)) {

commit a8d4b9fe911c7d48f7a75c37eb1bfa3273547d97
Author: Tomasz Chudy <Tomasz.Chudy@intel.com>
Date:   Fri Feb 25 02:25:09 2011 -0800

    isci: workaround port task scheduler starvation issue
    
    There is a condition whereby TCs (task contexts) can jump to the head of
    the round robin queue causing indefinite starvation of pending tasks.
    Posting a TC to a suspended RNC (remote node context) causes the
    hardware to select that task first, but since the RNC is suspended the
    scheduler proceeds to the next task in the expected round robin fashion,
    restoring TC arbitration fairness.
    
    Signed-off-by: Tomasz Chudy <tomasz.chudy@intel.com>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/drivers/scsi/isci/host.c b/drivers/scsi/isci/host.c
index 1bc91f2b4f93..40614e9ab41b 100644
--- a/drivers/scsi/isci/host.c
+++ b/drivers/scsi/isci/host.c
@@ -381,7 +381,6 @@ int isci_host_init(struct isci_host *isci_host)
 	int index = 0;
 	enum sci_status status;
 	struct scic_sds_controller *controller;
-	struct scic_sds_port *scic_port;
 	union scic_oem_parameters scic_oem_params;
 	union scic_user_parameters scic_user_params;
 
@@ -517,11 +516,5 @@ int isci_host_init(struct isci_host *isci_host)
 	for (index = 0; index < SCI_MAX_PHYS; index++)
 		isci_phy_init(&isci_host->phys[index], isci_host, index);
 
-	/* Start the ports */
-	for (index = 0; index < SCI_MAX_PORTS; index++) {
-		scic_controller_get_port_handle(controller, index, &scic_port);
-		scic_port_start(scic_port);
-	}
-
 	return 0;
 }

commit 7c40a8035815479c7c12ab0cdcea71e0f4c3a9c8
Author: Dan Williams <dan.j.williams@intel.com>
Date:   Wed Mar 2 11:49:26 2011 -0800

    isci: rework timer api
    
    Prepare the timer api for the arrival of dynamic creation and
    destruction events from the core.  It pretended to do this previously
    but the core to date only used it in a static init-time only fashion.
    This is an interim fix until a cleaner event queue can be developed.
    
    1/ make all locking external to the api (add WARN_ONCE to verify)
    2/ add a timer_destroy interface (to be used by the core)
    3/ use del_timer_sync() prior to deallocating timer data
    4/ delete the "timer_list" indirection, we only have timers allocated
       for the isci_host
    5/ fix detection of timer list allocation errors
    
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/drivers/scsi/isci/host.c b/drivers/scsi/isci/host.c
index d8d6f67bd69c..1bc91f2b4f93 100644
--- a/drivers/scsi/isci/host.c
+++ b/drivers/scsi/isci/host.c
@@ -349,9 +349,14 @@ void isci_host_deinit(struct isci_host *ihost)
 	}
 
 	set_bit(IHOST_STOP_PENDING, &ihost->flags);
+
+	spin_lock_irq(&ihost->scic_lock);
 	scic_controller_stop(scic, SCIC_CONTROLLER_STOP_TIMEOUT);
+	spin_unlock_irq(&ihost->scic_lock);
+
 	wait_for_stop(ihost);
 	scic_controller_reset(scic);
+	isci_timer_list_destroy(ihost);
 }
 
 static void __iomem *scu_base(struct isci_host *isci_host)
@@ -370,8 +375,6 @@ static void __iomem *smu_base(struct isci_host *isci_host)
 	return pcim_iomap_table(pdev)[SCI_SMU_BAR * 2] + SCI_SMU_BAR_SIZE * id;
 }
 
-#define SCI_MAX_TIMER_COUNT 25
-
 int isci_host_init(struct isci_host *isci_host)
 {
 	int err = 0;
@@ -382,11 +385,7 @@ int isci_host_init(struct isci_host *isci_host)
 	union scic_oem_parameters scic_oem_params;
 	union scic_user_parameters scic_user_params;
 
-	INIT_LIST_HEAD(&isci_host->timer_list_struct.timers);
-	isci_timer_list_construct(
-		&isci_host->timer_list_struct,
-		SCI_MAX_TIMER_COUNT
-		);
+	isci_timer_list_construct(isci_host);
 
 	controller = scic_controller_alloc(&isci_host->pdev->dev);
 
@@ -473,7 +472,17 @@ int isci_host_init(struct isci_host *isci_host)
 		}
 	}
 
+	tasklet_init(&isci_host->completion_tasklet,
+		     isci_host_completion_routine, (unsigned long)isci_host);
+
+	INIT_LIST_HEAD(&(isci_host->mdl_struct_list));
+
+	INIT_LIST_HEAD(&isci_host->requests_to_complete);
+	INIT_LIST_HEAD(&isci_host->requests_to_abort);
+
+	spin_lock_irq(&isci_host->scic_lock);
 	status = scic_controller_initialize(isci_host->core_controller);
+	spin_unlock_irq(&isci_host->scic_lock);
 	if (status != SCI_SUCCESS) {
 		dev_warn(&isci_host->pdev->dev,
 			 "%s: scic_controller_initialize failed -"
@@ -482,17 +491,8 @@ int isci_host_init(struct isci_host *isci_host)
 		return -ENODEV;
 	}
 
-	tasklet_init(&isci_host->completion_tasklet,
-		     isci_host_completion_routine, (unsigned long)isci_host);
-
-	INIT_LIST_HEAD(&(isci_host->mdl_struct_list));
-
-	INIT_LIST_HEAD(&isci_host->requests_to_complete);
-	INIT_LIST_HEAD(&isci_host->requests_to_abort);
-
 	/* populate mdl with dma memory. scu_mdl_allocate_coherent() */
 	err = isci_host_mdl_allocate_coherent(isci_host);
-
 	if (err)
 		return err;
 

commit 150fc6fc725055b400a8865e6785dc8dd0a2225d
Author: Dan Williams <dan.j.williams@intel.com>
Date:   Fri Feb 25 10:25:21 2011 -0800

    isci: fix sas address reporting
    
    Undo the open coded and incorrect translation of the oem parameter sas
    address to its libsas expected format.
    
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/drivers/scsi/isci/host.c b/drivers/scsi/isci/host.c
index aa86615fa7a9..d8d6f67bd69c 100644
--- a/drivers/scsi/isci/host.c
+++ b/drivers/scsi/isci/host.c
@@ -517,11 +517,6 @@ int isci_host_init(struct isci_host *isci_host)
 	for (index = 0; index < SCI_MAX_PHYS; index++)
 		isci_phy_init(&isci_host->phys[index], isci_host, index);
 
-	/* Why are we doing this? Is this even necessary? */
-	memcpy(&isci_host->sas_addr[0],
-	       &isci_host->phys[0].sas_addr[0],
-	       SAS_ADDR_SIZE);
-
 	/* Start the ports */
 	for (index = 0; index < SCI_MAX_PORTS; index++) {
 		scic_controller_get_port_handle(controller, index, &scic_port);

commit 858d4aa741c80fb7579cda3517853f0cffc73772
Author: Dave Jiang <dave.jiang@intel.com>
Date:   Tue Feb 22 01:27:03 2011 -0800

    isci: Move firmware loading to per PCI device
    
    Moved the firmware loading from per adapter to per PCI device. This should
    prevent firmware from being loaded twice becuase of 2 SCU controller per
    PCI device. We do have to do it per PCI device because request_firmware()
    requires a struct device passed in.
    
    Signed-off-by: Dave Jiang <dave.jiang@intel.com>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/drivers/scsi/isci/host.c b/drivers/scsi/isci/host.c
index cb2e3f9558e9..aa86615fa7a9 100644
--- a/drivers/scsi/isci/host.c
+++ b/drivers/scsi/isci/host.c
@@ -354,67 +354,6 @@ void isci_host_deinit(struct isci_host *ihost)
 	scic_controller_reset(scic);
 }
 
-static int isci_verify_firmware(const struct firmware *fw,
-				struct isci_firmware *isci_fw)
-{
-	const u8 *tmp;
-
-	if (fw->size < ISCI_FIRMWARE_MIN_SIZE)
-		return -EINVAL;
-
-	tmp = fw->data;
-
-	/* 12th char should be the NULL terminate for the ID string */
-	if (tmp[11] != '\0')
-		return -EINVAL;
-
-	if (strncmp("#SCU MAGIC#", tmp, 11) != 0)
-		return -EINVAL;
-
-	isci_fw->id = tmp;
-	isci_fw->version = fw->data[ISCI_FW_VER_OFS];
-	isci_fw->subversion = fw->data[ISCI_FW_SUBVER_OFS];
-
-	tmp = fw->data + ISCI_FW_DATA_OFS;
-
-	while (*tmp != ISCI_FW_HDR_EOF) {
-		switch (*tmp) {
-		case ISCI_FW_HDR_PHYMASK:
-			tmp++;
-			isci_fw->phy_masks_size = *tmp;
-			tmp++;
-			isci_fw->phy_masks = (const u32 *)tmp;
-			tmp += sizeof(u32) * isci_fw->phy_masks_size;
-			break;
-
-		case ISCI_FW_HDR_PHYGEN:
-			tmp++;
-			isci_fw->phy_gens_size = *tmp;
-			tmp++;
-			isci_fw->phy_gens = (const u32 *)tmp;
-			tmp += sizeof(u32) * isci_fw->phy_gens_size;
-			break;
-
-		case ISCI_FW_HDR_SASADDR:
-			tmp++;
-			isci_fw->sas_addrs_size = *tmp;
-			tmp++;
-			isci_fw->sas_addrs = (const u64 *)tmp;
-			tmp += sizeof(u64) * isci_fw->sas_addrs_size;
-			break;
-
-		default:
-			pr_err("bad field in firmware binary blob\n");
-			return -EINVAL;
-		}
-	}
-
-	pr_info("isci firmware v%u.%u loaded.\n",
-	       isci_fw->version, isci_fw->subversion);
-
-	return SCI_SUCCESS;
-}
-
 static void __iomem *scu_base(struct isci_host *isci_host)
 {
 	struct pci_dev *pdev = isci_host->pdev;
@@ -442,8 +381,6 @@ int isci_host_init(struct isci_host *isci_host)
 	struct scic_sds_port *scic_port;
 	union scic_oem_parameters scic_oem_params;
 	union scic_user_parameters scic_user_params;
-	const struct firmware *fw = NULL;
-	struct isci_firmware *isci_fw = NULL;
 
 	INIT_LIST_HEAD(&isci_host->timer_list_struct.timers);
 	isci_timer_list_construct(
@@ -454,9 +391,11 @@ int isci_host_init(struct isci_host *isci_host)
 	controller = scic_controller_alloc(&isci_host->pdev->dev);
 
 	if (!controller) {
-		err = -ENOMEM;
-		dev_err(&isci_host->pdev->dev, "%s: failed (%d)\n", __func__, err);
-		goto out;
+		dev_err(&isci_host->pdev->dev,
+			"%s: failed (%d)\n",
+			__func__,
+			err);
+		return -ENOMEM;
 	}
 
 	isci_host->core_controller = controller;
@@ -476,8 +415,7 @@ int isci_host_init(struct isci_host *isci_host)
 			"%s: scic_controller_construct failed - status = %x\n",
 			__func__,
 			status);
-		err = -ENODEV;
-		goto out;
+		return -ENODEV;
 	}
 
 	isci_host->sas_ha.dev = &isci_host->pdev->dev;
@@ -487,93 +425,52 @@ int isci_host_init(struct isci_host *isci_host)
 	 * set association host adapter struct in core controller.
 	 */
 	sci_object_set_association(isci_host->core_controller,
-				   (void *)isci_host
-				   );
+				   (void *)isci_host);
 
 	/* grab initial values stored in the controller object for OEM and USER
 	 * parameters */
 	scic_oem_parameters_get(controller, &scic_oem_params);
 	scic_user_parameters_get(controller, &scic_user_params);
 
-	isci_fw = devm_kzalloc(&isci_host->pdev->dev,
-			       sizeof(struct isci_firmware),
-			       GFP_KERNEL);
-	if (!isci_fw) {
-		dev_warn(&isci_host->pdev->dev,
-			 "allocating firmware struct failed\n");
-		dev_warn(&isci_host->pdev->dev,
-			 "Default OEM configuration being used:"
-			 " 4 narrow ports, and default SAS Addresses\n");
-		goto set_default_params;
-	}
-
-	status = request_firmware(&fw, ISCI_FW_NAME, &isci_host->pdev->dev);
-	if (status) {
-		dev_warn(&isci_host->pdev->dev,
-			 "Loading firmware failed, using default values\n");
-		dev_warn(&isci_host->pdev->dev,
-			 "Default OEM configuration being used:"
-			 " 4 narrow ports, and default SAS Addresses\n");
-		goto set_default_params;
-	}
-	else {
-		status = isci_verify_firmware(fw, isci_fw);
-		if (status != SCI_SUCCESS) {
-			dev_warn(&isci_host->pdev->dev,
-				 "firmware verification failed\n");
-			dev_warn(&isci_host->pdev->dev,
-				 "Default OEM configuration being used:"
-				 " 4 narrow ports, and default SAS "
-				 "Addresses\n");
-			goto set_default_params;
-		}
-
-		/* grab any OEM and USER parameters specified at module load */
+	if (isci_firmware) {
+		/* grab any OEM and USER parameters specified in binary blob */
 		status = isci_parse_oem_parameters(&scic_oem_params,
-						   isci_host->id, isci_fw);
+						   isci_host->id,
+						   isci_firmware);
 		if (status != SCI_SUCCESS) {
 			dev_warn(&isci_host->pdev->dev,
 				 "parsing firmware oem parameters failed\n");
-			err = -EINVAL;
-			goto out;
+			return -EINVAL;
 		}
 
 		status = isci_parse_user_parameters(&scic_user_params,
-						    isci_host->id, isci_fw);
+						    isci_host->id,
+						    isci_firmware);
 		if (status != SCI_SUCCESS) {
 			dev_warn(&isci_host->pdev->dev,
 				 "%s: isci_parse_user_parameters"
 				 " failed\n", __func__);
-			err = -EINVAL;
-			goto out;
+			return -EINVAL;
+		}
+	} else {
+		status = scic_oem_parameters_set(isci_host->core_controller,
+						 &scic_oem_params);
+		if (status != SCI_SUCCESS) {
+			dev_warn(&isci_host->pdev->dev,
+				 "%s: scic_oem_parameters_set failed\n",
+				 __func__);
+			return -ENODEV;
 		}
-	}
-
- set_default_params:
-
-	status = scic_oem_parameters_set(isci_host->core_controller,
-					 &scic_oem_params
-					 );
-
-	if (status != SCI_SUCCESS) {
-		dev_warn(&isci_host->pdev->dev,
-			 "%s: scic_oem_parameters_set failed\n",
-			 __func__);
-		err = -ENODEV;
-		goto out;
-	}
-
 
-	status = scic_user_parameters_set(isci_host->core_controller,
-					  &scic_user_params
-					  );
 
-	if (status != SCI_SUCCESS) {
-		dev_warn(&isci_host->pdev->dev,
-			 "%s: scic_user_parameters_set failed\n",
-			 __func__);
-		err = -ENODEV;
-		goto out;
+		status = scic_user_parameters_set(isci_host->core_controller,
+						  &scic_user_params);
+		if (status != SCI_SUCCESS) {
+			dev_warn(&isci_host->pdev->dev,
+				 "%s: scic_user_parameters_set failed\n",
+				 __func__);
+			return -ENODEV;
+		}
 	}
 
 	status = scic_controller_initialize(isci_host->core_controller);
@@ -582,8 +479,7 @@ int isci_host_init(struct isci_host *isci_host)
 			 "%s: scic_controller_initialize failed -"
 			 " status = 0x%x\n",
 			 __func__, status);
-		err = -ENODEV;
-		goto out;
+		return -ENODEV;
 	}
 
 	tasklet_init(&isci_host->completion_tasklet,
@@ -598,7 +494,7 @@ int isci_host_init(struct isci_host *isci_host)
 	err = isci_host_mdl_allocate_coherent(isci_host);
 
 	if (err)
-		goto err_out;
+		return err;
 
 	/*
 	 * keep the pool alloc size around, will use it for a bounds checking
@@ -610,40 +506,27 @@ int isci_host_init(struct isci_host *isci_host)
 					       isci_host->dma_pool_alloc_size,
 					       SLAB_HWCACHE_ALIGN, 0);
 
-	if (!isci_host->dma_pool) {
-		err = -ENOMEM;
-		goto req_obj_err_out;
-	}
+	if (!isci_host->dma_pool)
+		return -ENOMEM;
 
-	for (index = 0; index < SCI_MAX_PORTS; index++) {
+	for (index = 0; index < SCI_MAX_PORTS; index++)
 		isci_port_init(&isci_host->isci_ports[index],
-			       isci_host, index);
-	}
+			       isci_host,
+			       index);
 
 	for (index = 0; index < SCI_MAX_PHYS; index++)
 		isci_phy_init(&isci_host->phys[index], isci_host, index);
 
 	/* Why are we doing this? Is this even necessary? */
-	memcpy(&isci_host->sas_addr[0], &isci_host->phys[0].sas_addr[0],
+	memcpy(&isci_host->sas_addr[0],
+	       &isci_host->phys[0].sas_addr[0],
 	       SAS_ADDR_SIZE);
 
 	/* Start the ports */
 	for (index = 0; index < SCI_MAX_PORTS; index++) {
-
 		scic_controller_get_port_handle(controller, index, &scic_port);
 		scic_port_start(scic_port);
 	}
 
-	goto out;
-
-/* SPB_Debug: destroy request object cache */
- req_obj_err_out:
-/* SPB_Debug: destroy remote object cache */
- err_out:
-/* SPB_Debug: undo controller init, construct and alloc, remove from parent
- * controller list. */
- out:
-	if (fw)
-		release_firmware(fw);
-	return err;
+	return 0;
 }

commit 92f4f0f544a6a75979bace0c43fee9c4fb95830c
Author: Dan Williams <dan.j.williams@intel.com>
Date:   Fri Feb 18 09:25:11 2011 -0800

    isci: implement error isr
    
    Add basic support for handling/reporting error interrupts.
    
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/drivers/scsi/isci/host.c b/drivers/scsi/isci/host.c
index 7f351a35e87b..cb2e3f9558e9 100644
--- a/drivers/scsi/isci/host.c
+++ b/drivers/scsi/isci/host.c
@@ -85,11 +85,27 @@ irqreturn_t isci_intx_isr(int vec, void *data)
 		if (scic_sds_controller_isr(scic)) {
 			tasklet_schedule(&ihost->completion_tasklet);
 			ret = IRQ_HANDLED;
+		} else if (scic_sds_controller_error_isr(scic)) {
+			spin_lock(&ihost->scic_lock);
+			scic_sds_controller_error_handler(scic);
+			spin_unlock(&ihost->scic_lock);
+			ret = IRQ_HANDLED;
 		}
 	}
+
 	return ret;
 }
 
+irqreturn_t isci_error_isr(int vec, void *data)
+{
+	struct isci_host *ihost = data;
+	struct scic_sds_controller *scic = ihost->core_controller;
+
+	if (scic_sds_controller_error_isr(scic))
+		scic_sds_controller_error_handler(scic);
+
+	return IRQ_HANDLED;
+}
 
 /**
  * isci_host_start_complete() - This function is called by the core library,

commit 77950f51f5299c1b4f4fa4a19974128da720d199
Author: Edmund Nadolski <edmund.nadolski@intel.com>
Date:   Fri Feb 18 09:25:09 2011 -0800

    isci: enable interrupts during controller start, and flush discovery
    
    Polling the event queue during scan is an unneeded holdover from the
    original driver.
    
    Signed-off-by: Edmund Nadolski <edmund.nadolski@intel.com>
    [djbw: ensure we flush all port events and domain discovery]
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/drivers/scsi/isci/host.c b/drivers/scsi/isci/host.c
index dbdc3bab9ca3..7f351a35e87b 100644
--- a/drivers/scsi/isci/host.c
+++ b/drivers/scsi/isci/host.c
@@ -113,32 +113,18 @@ int isci_host_scan_finished(struct Scsi_Host *shost, unsigned long time)
 {
 	struct isci_host *ihost = isci_host_from_sas_ha(SHOST_TO_SAS_HA(shost));
 
-	/**
-	 * check interrupt_handler's status and call completion_handler if true,
-	 * link_up events should be coming from the scu core lib, as phy's come
-	 * online. for each link_up from the core, call
-	 * get_received_identify_address_frame, copy the frame into the
-	 * sas_phy object and call libsas notify_port_event(PORTE_BYTES_DMAED).
-	 * continue to return zero from thee scan_finished routine until
-	 * the scic_cb_controller_start_complete() call comes from the core.
-	 **/
-	if (scic_sds_controller_isr(ihost->core_controller))
-		scic_sds_controller_completion_handler(ihost->core_controller);
-
-	if (test_bit(IHOST_START_PENDING, &ihost->flags) && time < HZ*10) {
-		dev_dbg(&ihost->pdev->dev,
-			"%s: ihost->status = %d, time = %ld\n",
-			     __func__, isci_host_get_state(ihost), time);
+	if (test_bit(IHOST_START_PENDING, &ihost->flags))
 		return 0;
-	}
 
+	/* todo: use sas_flush_discovery once it is upstream */
+	scsi_flush_work(shost);
+
+	scsi_flush_work(shost);
 
 	dev_dbg(&ihost->pdev->dev,
 		"%s: ihost->status = %d, time = %ld\n",
 		 __func__, isci_host_get_state(ihost), time);
 
-	scic_controller_enable_interrupts(ihost->core_controller);
-
 	return 1;
 
 }
@@ -150,8 +136,11 @@ void isci_host_scan_start(struct Scsi_Host *shost)
 	unsigned long tmo = scic_controller_get_suggested_start_timeout(scic);
 
 	set_bit(IHOST_START_PENDING, &ihost->flags);
-	scic_controller_disable_interrupts(ihost->core_controller);
+
+	spin_lock_irq(&ihost->scic_lock);
 	scic_controller_start(scic, tmo);
+	scic_controller_enable_interrupts(scic);
+	spin_unlock_irq(&ihost->scic_lock);
 }
 
 void isci_host_stop_complete(struct isci_host *ihost, enum sci_status completion_status)

commit 0cf89d1d27c1bdd0abf1714096f98ea44704dcff
Author: Dan Williams <dan.j.williams@intel.com>
Date:   Fri Feb 18 09:25:07 2011 -0800

    isci: cleanup "starting" state handling
    
    The lldd actively disallows requests in the "starting" state.  Retrying
    or holding off commands in this state is sub-optimal:
    1/ it adds another state check to the fast path
    2/ retrying can cause libsas to give up
    
    However, isci's ->lldd_dev_found() routine already waits for controller
    start to complete before allowing further progress.  Checking the
    "starting" state in isci_task_execute_task and the isr is redundant and
    misleading.  Clean this up and introduce a controller-wide event queue
    to start reeling in "completion" proliferation in the driver.
    
    The "stopping" state cleanups are in a similar vein, rely on the the isr
    and other paths being precluded from occurring rather than implementing
    state checking logic.
    
    Reported-by: Christoph Hellwig <hch@infradead.org>
    Cc: Jeff Garzik <jeff@garzik.org>
    Signed-off-by: Edmund Nadolski <edmund.nadolski@intel.com>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/drivers/scsi/isci/host.c b/drivers/scsi/isci/host.c
index b66e62027247..dbdc3bab9ca3 100644
--- a/drivers/scsi/isci/host.c
+++ b/drivers/scsi/isci/host.c
@@ -67,15 +67,8 @@ irqreturn_t isci_msix_isr(int vec, void *data)
 	struct isci_host *ihost = data;
 	struct scic_sds_controller *scic = ihost->core_controller;
 
-	if (isci_host_get_state(ihost) != isci_starting) {
-		if (scic_sds_controller_isr(scic)) {
-			if (isci_host_get_state(ihost) != isci_stopped)
-				tasklet_schedule(&ihost->completion_tasklet);
-			else
-				dev_dbg(&ihost->pdev->dev,
-					"%s: controller stopped\n", __func__);
-		}
-	}
+	if (scic_sds_controller_isr(scic))
+		tasklet_schedule(&ihost->completion_tasklet);
 
 	return IRQ_HANDLED;
 }
@@ -89,22 +82,10 @@ irqreturn_t isci_intx_isr(int vec, void *data)
 	for_each_isci_host(ihost, pdev) {
 		struct scic_sds_controller *scic = ihost->core_controller;
 
-		if (isci_host_get_state(ihost) != isci_starting) {
-			if (scic_sds_controller_isr(scic)) {
-				if (isci_host_get_state(ihost) != isci_stopped)
-					tasklet_schedule(&ihost->completion_tasklet);
-				else
-					dev_dbg(&ihost->pdev->dev,
-						"%s: controller stopped\n",
-						__func__);
-				ret = IRQ_HANDLED;
-			}
-		} else
-			dev_warn(&ihost->pdev->dev,
-				 "%s: get_handler_methods failed, "
-				 "ihost->status = 0x%x\n",
-				 __func__,
-				 isci_host_get_state(ihost));
+		if (scic_sds_controller_isr(scic)) {
+			tasklet_schedule(&ihost->completion_tasklet);
+			ret = IRQ_HANDLED;
+		}
 	}
 	return ret;
 }
@@ -118,26 +99,19 @@ irqreturn_t isci_intx_isr(int vec, void *data)
  *    core library.
  *
  */
-void isci_host_start_complete(
-	struct isci_host *isci_host,
-	enum sci_status completion_status)
+void isci_host_start_complete(struct isci_host *ihost, enum sci_status completion_status)
 {
-	if (completion_status == SCI_SUCCESS) {
-		dev_dbg(&isci_host->pdev->dev,
-			"%s: completion_status: SCI_SUCCESS\n", __func__);
-		isci_host_change_state(isci_host, isci_ready);
-		complete_all(&isci_host->start_complete);
-	} else
-		dev_err(&isci_host->pdev->dev,
-			"controller start failed with "
-			"completion_status = 0x%x;",
-			completion_status);
-
+	if (completion_status != SCI_SUCCESS)
+		dev_info(&ihost->pdev->dev,
+			"controller start timed out, continuing...\n");
+	isci_host_change_state(ihost, isci_ready);
+	clear_bit(IHOST_START_PENDING, &ihost->flags);
+	wake_up(&ihost->eventq);
 }
 
 int isci_host_scan_finished(struct Scsi_Host *shost, unsigned long time)
 {
-	struct isci_host *isci_host = isci_host_from_sas_ha(SHOST_TO_SAS_HA(shost));
+	struct isci_host *ihost = isci_host_from_sas_ha(SHOST_TO_SAS_HA(shost));
 
 	/**
 	 * check interrupt_handler's status and call completion_handler if true,
@@ -148,61 +122,44 @@ int isci_host_scan_finished(struct Scsi_Host *shost, unsigned long time)
 	 * continue to return zero from thee scan_finished routine until
 	 * the scic_cb_controller_start_complete() call comes from the core.
 	 **/
-	if (scic_sds_controller_isr(isci_host->core_controller))
-		scic_sds_controller_completion_handler(isci_host->core_controller);
+	if (scic_sds_controller_isr(ihost->core_controller))
+		scic_sds_controller_completion_handler(ihost->core_controller);
 
-	if (isci_starting == isci_host_get_state(isci_host)
-	    && time < (HZ * 10)) {
-		dev_dbg(&isci_host->pdev->dev,
-			"%s: isci_host->status = %d, time = %ld\n",
-			     __func__, isci_host_get_state(isci_host), time);
+	if (test_bit(IHOST_START_PENDING, &ihost->flags) && time < HZ*10) {
+		dev_dbg(&ihost->pdev->dev,
+			"%s: ihost->status = %d, time = %ld\n",
+			     __func__, isci_host_get_state(ihost), time);
 		return 0;
 	}
 
 
-	dev_dbg(&isci_host->pdev->dev,
-		"%s: isci_host->status = %d, time = %ld\n",
-		 __func__, isci_host_get_state(isci_host), time);
+	dev_dbg(&ihost->pdev->dev,
+		"%s: ihost->status = %d, time = %ld\n",
+		 __func__, isci_host_get_state(ihost), time);
 
-	scic_controller_enable_interrupts(isci_host->core_controller);
+	scic_controller_enable_interrupts(ihost->core_controller);
 
 	return 1;
 
 }
 
-
-/**
- * isci_host_scan_start() - This function is one of the SCSI Host Template
- *    function, called by the SCSI mid layer berfore a target scan begins. The
- *    core library controller start routine is called from here.
- * @shost: This parameter specifies the SCSI host to be scanned
- *
- */
 void isci_host_scan_start(struct Scsi_Host *shost)
 {
-	struct isci_host *isci_host;
-
-	isci_host = isci_host_from_sas_ha(SHOST_TO_SAS_HA(shost));
-	isci_host_change_state(isci_host, isci_starting);
+	struct isci_host *ihost = isci_host_from_sas_ha(SHOST_TO_SAS_HA(shost));
+	struct scic_sds_controller *scic = ihost->core_controller;
+	unsigned long tmo = scic_controller_get_suggested_start_timeout(scic);
 
-	scic_controller_disable_interrupts(isci_host->core_controller);
-	init_completion(&isci_host->start_complete);
-	scic_controller_start(
-		isci_host->core_controller,
-		scic_controller_get_suggested_start_timeout(
-			isci_host->core_controller)
-		);
+	set_bit(IHOST_START_PENDING, &ihost->flags);
+	scic_controller_disable_interrupts(ihost->core_controller);
+	scic_controller_start(scic, tmo);
 }
 
-void isci_host_stop_complete(
-	struct isci_host *isci_host,
-	enum sci_status completion_status)
+void isci_host_stop_complete(struct isci_host *ihost, enum sci_status completion_status)
 {
-	isci_host_change_state(isci_host, isci_stopped);
-	scic_controller_disable_interrupts(
-		isci_host->core_controller
-		);
-	complete(&isci_host->stop_complete);
+	isci_host_change_state(ihost, isci_stopped);
+	scic_controller_disable_interrupts(ihost->core_controller);
+	clear_bit(IHOST_STOP_PENDING, &ihost->flags);
+	wake_up(&ihost->eventq);
 }
 
 static struct coherent_memory_info *isci_host_alloc_mdl_struct(
@@ -370,31 +327,26 @@ static void isci_host_completion_routine(unsigned long data)
 
 }
 
-void isci_host_deinit(
-	struct isci_host *isci_host)
+void isci_host_deinit(struct isci_host *ihost)
 {
+	struct scic_sds_controller *scic = ihost->core_controller;
 	int i;
 
-	isci_host_change_state(isci_host, isci_stopping);
+	isci_host_change_state(ihost, isci_stopping);
 	for (i = 0; i < SCI_MAX_PORTS; i++) {
-		struct isci_port *port = &isci_host->isci_ports[i];
-		struct isci_remote_device *device, *tmpdev;
-		list_for_each_entry_safe(device, tmpdev,
-					 &port->remote_dev_list, node) {
-			isci_remote_device_change_state(device, isci_stopping);
-			isci_remote_device_stop(device);
+		struct isci_port *port = &ihost->isci_ports[i];
+		struct isci_remote_device *idev, *d;
+
+		list_for_each_entry_safe(idev, d, &port->remote_dev_list, node) {
+			isci_remote_device_change_state(idev, isci_stopping);
+			isci_remote_device_stop(idev);
 		}
 	}
 
-	/* stop the comtroller and wait for completion.  */
-	init_completion(&isci_host->stop_complete);
-	scic_controller_stop(
-		isci_host->core_controller,
-		SCIC_CONTROLLER_STOP_TIMEOUT
-		);
-	wait_for_completion(&isci_host->stop_complete);
-	/* next, reset the controller.           */
-	scic_controller_reset(isci_host->core_controller);
+	set_bit(IHOST_STOP_PENDING, &ihost->flags);
+	scic_controller_stop(scic, SCIC_CONTROLLER_STOP_TIMEOUT);
+	wait_for_stop(ihost);
+	scic_controller_reset(scic);
 }
 
 static int isci_verify_firmware(const struct firmware *fw,
@@ -506,6 +458,7 @@ int isci_host_init(struct isci_host *isci_host)
 	spin_lock_init(&isci_host->state_lock);
 	spin_lock_init(&isci_host->scic_lock);
 	spin_lock_init(&isci_host->queue_lock);
+	init_waitqueue_head(&isci_host->eventq);
 
 	isci_host_change_state(isci_host, isci_starting);
 	isci_host->can_queue = ISCI_CAN_QUEUE_VAL;

commit c7ef4031f01301298bbaba2666740183cd399f8c
Author: Dan Williams <dan.j.williams@intel.com>
Date:   Fri Feb 18 09:25:05 2011 -0800

    isci: bypass scic_controller_get_handler_methods()
    
    The indirection is unecessary and broken in the current case that assigns the
    handlers based on a not up-to-date pdev->msix_enabled value.
    
    Route the handlers directly to the requisite core routines.
    
    Todo: hook up error interrupt handling
    
    Reported-by: Jeff Garzik <jeff@garzik.org>
    Cc: Christoph Hellwig <hch@infradead.org>
    Signed-off-by: Edmund Nadolski <edmund.nadolski@intel.com>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/drivers/scsi/isci/host.c b/drivers/scsi/isci/host.c
index 6f16f4d6c82b..b66e62027247 100644
--- a/drivers/scsi/isci/host.c
+++ b/drivers/scsi/isci/host.c
@@ -62,80 +62,49 @@
 #include "request.h"
 #include "host.h"
 
-/**
- * isci_isr() - This function is the interrupt service routine for the
- *    controller. It schedules the tasklet and returns.
- * @vec: This parameter specifies the interrupt vector.
- * @data: This parameter specifies the ISCI host object.
- *
- * IRQ_HANDLED if out interrupt otherwise, IRQ_NONE
- */
-irqreturn_t isci_isr(int vec, void *data)
+irqreturn_t isci_msix_isr(int vec, void *data)
 {
-	struct isci_host *isci_host
-		= (struct isci_host *)data;
-	struct scic_controller_handler_methods *handlers
-		= &isci_host->scic_irq_handlers[SCI_MSIX_NORMAL_VECTOR];
-	irqreturn_t ret = IRQ_NONE;
-
-	if (isci_host_get_state(isci_host) != isci_starting
-	    && handlers->interrupt_handler) {
-
-		if (handlers->interrupt_handler(isci_host->core_controller)) {
-			if (isci_host_get_state(isci_host) != isci_stopped) {
-				tasklet_schedule(
-					&isci_host->completion_tasklet);
-			} else
-				dev_dbg(&isci_host->pdev->dev,
-					"%s: controller stopped\n",
-					__func__);
-			ret = IRQ_HANDLED;
+	struct isci_host *ihost = data;
+	struct scic_sds_controller *scic = ihost->core_controller;
+
+	if (isci_host_get_state(ihost) != isci_starting) {
+		if (scic_sds_controller_isr(scic)) {
+			if (isci_host_get_state(ihost) != isci_stopped)
+				tasklet_schedule(&ihost->completion_tasklet);
+			else
+				dev_dbg(&ihost->pdev->dev,
+					"%s: controller stopped\n", __func__);
 		}
-	} else
-		dev_warn(&isci_host->pdev->dev,
-			 "%s: get_handler_methods failed, "
-			 "isci_host->status = 0x%x\n",
-			 __func__,
-			 isci_host_get_state(isci_host));
+	}
 
-	return ret;
+	return IRQ_HANDLED;
 }
 
-irqreturn_t isci_legacy_isr(int vec, void *data)
+irqreturn_t isci_intx_isr(int vec, void *data)
 {
 	struct pci_dev *pdev = data;
-	struct isci_host *isci_host;
-	struct scic_controller_handler_methods *handlers;
+	struct isci_host *ihost;
 	irqreturn_t ret = IRQ_NONE;
 
-	/*
-	 *  Since this is a legacy interrupt, either or both
-	 *  controllers could have triggered it.  Thus, we have to call
-	 *  the legacy interrupt handler for all controllers on the
-	 *  PCI function.
-	 */
-	for_each_isci_host(isci_host, pdev) {
-		handlers = &isci_host->scic_irq_handlers[SCI_MSIX_NORMAL_VECTOR];
-
-		if (isci_host_get_state(isci_host) != isci_starting
-		    && handlers->interrupt_handler) {
-
-			if (handlers->interrupt_handler(isci_host->core_controller)) {
-				if (isci_host_get_state(isci_host) != isci_stopped) {
-					tasklet_schedule(
-						&isci_host->completion_tasklet);
-				} else
-					dev_dbg(&isci_host->pdev->dev,
+	for_each_isci_host(ihost, pdev) {
+		struct scic_sds_controller *scic = ihost->core_controller;
+
+		if (isci_host_get_state(ihost) != isci_starting) {
+			if (scic_sds_controller_isr(scic)) {
+				if (isci_host_get_state(ihost) != isci_stopped)
+					tasklet_schedule(&ihost->completion_tasklet);
+				else
+					dev_dbg(&ihost->pdev->dev,
 						"%s: controller stopped\n",
 						__func__);
 				ret = IRQ_HANDLED;
 			}
 		} else
-			dev_warn(&isci_host->pdev->dev,
+			dev_warn(&ihost->pdev->dev,
 				 "%s: get_handler_methods failed, "
-				 "isci_host->status = 0x%x\n",
+				 "ihost->status = 0x%x\n",
 				 __func__,
-				 isci_host_get_state(isci_host));
+				 isci_host_get_state(ihost));
 	}
 	return ret;
 }
@@ -166,34 +135,9 @@ void isci_host_start_complete(
 
 }
 
-
-
-/**
- * isci_host_scan_finished() - This function is one of the SCSI Host Template
- *    functions. The SCSI midlayer calls this function during a target scan,
- *    approx. once every 10 millisecs.
- * @shost: This parameter specifies the SCSI host being scanned
- * @time: This parameter specifies the number of ticks since the scan started.
- *
- * scan status, zero indicates the SCSI midlayer should continue to poll,
- * otherwise assume controller is ready.
- */
-int isci_host_scan_finished(
-	struct Scsi_Host *shost,
-	unsigned long time)
+int isci_host_scan_finished(struct Scsi_Host *shost, unsigned long time)
 {
-	struct isci_host *isci_host
-		= isci_host_from_sas_ha(SHOST_TO_SAS_HA(shost));
-
-	struct scic_controller_handler_methods *handlers
-		= &isci_host->scic_irq_handlers[SCI_MSIX_NORMAL_VECTOR];
-
-	if (handlers->interrupt_handler == NULL) {
-		dev_err(&isci_host->pdev->dev,
-			"%s: scic_controller_get_handler_methods failed\n",
-			__func__);
-		return 1;
-	}
+	struct isci_host *isci_host = isci_host_from_sas_ha(SHOST_TO_SAS_HA(shost));
 
 	/**
 	 * check interrupt_handler's status and call completion_handler if true,
@@ -204,8 +148,8 @@ int isci_host_scan_finished(
 	 * continue to return zero from thee scan_finished routine until
 	 * the scic_cb_controller_start_complete() call comes from the core.
 	 **/
-	if (handlers->interrupt_handler(isci_host->core_controller))
-		handlers->completion_handler(isci_host->core_controller);
+	if (scic_sds_controller_isr(isci_host->core_controller))
+		scic_sds_controller_completion_handler(isci_host->core_controller);
 
 	if (isci_starting == isci_host_get_state(isci_host)
 	    && time < (HZ * 10)) {
@@ -363,8 +307,6 @@ static int isci_host_mdl_allocate_coherent(
 static void isci_host_completion_routine(unsigned long data)
 {
 	struct isci_host *isci_host = (struct isci_host *)data;
-	struct scic_controller_handler_methods *handlers
-		= &isci_host->scic_irq_handlers[SCI_MSIX_NORMAL_VECTOR];
 	struct list_head completed_request_list;
 	struct list_head aborted_request_list;
 	struct list_head *current_position;
@@ -378,11 +320,8 @@ static void isci_host_completion_routine(unsigned long data)
 
 	spin_lock_irq(&isci_host->scic_lock);
 
-	if (handlers->completion_handler) {
-		handlers->completion_handler(
-			isci_host->core_controller
-			);
-	}
+	scic_sds_controller_completion_handler(isci_host->core_controller);
+
 	/* Take the lists of completed I/Os from the host. */
 	list_splice_init(&isci_host->requests_to_complete,
 			 &completed_request_list);
@@ -544,8 +483,6 @@ int isci_host_init(struct isci_host *isci_host)
 	enum sci_status status;
 	struct scic_sds_controller *controller;
 	struct scic_sds_port *scic_port;
-	struct scic_controller_handler_methods *handlers
-		= &isci_host->scic_irq_handlers[0];
 	union scic_oem_parameters scic_oem_params;
 	union scic_user_parameters scic_user_params;
 	const struct firmware *fw = NULL;
@@ -691,35 +628,8 @@ int isci_host_init(struct isci_host *isci_host)
 		goto out;
 	}
 
-	/* @todo: use both MSI-X interrupts, and don't do indirect
-	 * calls to the handlers just register direct calls
-	 */
-	if (isci_host->pdev->msix_enabled) {
-		status = scic_controller_get_handler_methods(
-			SCIC_MSIX_INTERRUPT_TYPE,
-			SCI_MSIX_DOUBLE_VECTOR,
-			handlers
-			);
-	} else {
-		status = scic_controller_get_handler_methods(
-			SCIC_LEGACY_LINE_INTERRUPT_TYPE,
-			0,
-			handlers
-			);
-	}
-
-	if (status != SCI_SUCCESS) {
-		handlers->interrupt_handler = NULL;
-		handlers->completion_handler = NULL;
-		dev_err(&isci_host->pdev->dev,
-			"%s: scic_controller_get_handler_methods failed\n",
-			__func__);
-	}
-
 	tasklet_init(&isci_host->completion_tasklet,
-		     isci_host_completion_routine,
-		     (unsigned long)isci_host
-		     );
+		     isci_host_completion_routine, (unsigned long)isci_host);
 
 	INIT_LIST_HEAD(&(isci_host->mdl_struct_list));
 

commit 6f231dda68080759f1aed3769896e94c73099f0f
Author: Dan Williams <dan.j.williams@intel.com>
Date:   Sat Jul 2 22:56:22 2011 -0700

    isci: Intel(R) C600 Series Chipset Storage Control Unit Driver
    
    Support for the up to 2x4-port 6Gb/s SAS controllers embedded in the
    chipset.
    
    This is a snapshot of the first publicly available version of the driver,
    commit 4c1db2d0 in the 'historical' branch.
    
       git://git.kernel.org/pub/scm/linux/kernel/git/djbw/isci.git historical
    
    Signed-off-by: Maciej Trela <maciej.trela@intel.com>
    Signed-off-by: Dave Jiang <dave.jiang@intel.com>
    Signed-off-by: Edmund Nadolski <edmund.nadolski@intel.com>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/drivers/scsi/isci/host.c b/drivers/scsi/isci/host.c
new file mode 100644
index 000000000000..6f16f4d6c82b
--- /dev/null
+++ b/drivers/scsi/isci/host.c
@@ -0,0 +1,781 @@
+/*
+ * This file is provided under a dual BSD/GPLv2 license.  When using or
+ * redistributing this file, you may do so under either license.
+ *
+ * GPL LICENSE SUMMARY
+ *
+ * Copyright(c) 2008 - 2011 Intel Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
+ * The full GNU General Public License is included in this distribution
+ * in the file called LICENSE.GPL.
+ *
+ * BSD LICENSE
+ *
+ * Copyright(c) 2008 - 2011 Intel Corporation. All rights reserved.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ *   * Redistributions of source code must retain the above copyright
+ *     notice, this list of conditions and the following disclaimer.
+ *   * Redistributions in binary form must reproduce the above copyright
+ *     notice, this list of conditions and the following disclaimer in
+ *     the documentation and/or other materials provided with the
+ *     distribution.
+ *   * Neither the name of Intel Corporation nor the names of its
+ *     contributors may be used to endorse or promote products derived
+ *     from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include "isci.h"
+#include "scic_io_request.h"
+#include "scic_remote_device.h"
+#include "scic_port.h"
+
+#include "port.h"
+#include "request.h"
+#include "host.h"
+
+/**
+ * isci_isr() - This function is the interrupt service routine for the
+ *    controller. It schedules the tasklet and returns.
+ * @vec: This parameter specifies the interrupt vector.
+ * @data: This parameter specifies the ISCI host object.
+ *
+ * IRQ_HANDLED if out interrupt otherwise, IRQ_NONE
+ */
+irqreturn_t isci_isr(int vec, void *data)
+{
+	struct isci_host *isci_host
+		= (struct isci_host *)data;
+	struct scic_controller_handler_methods *handlers
+		= &isci_host->scic_irq_handlers[SCI_MSIX_NORMAL_VECTOR];
+	irqreturn_t ret = IRQ_NONE;
+
+	if (isci_host_get_state(isci_host) != isci_starting
+	    && handlers->interrupt_handler) {
+
+		if (handlers->interrupt_handler(isci_host->core_controller)) {
+			if (isci_host_get_state(isci_host) != isci_stopped) {
+				tasklet_schedule(
+					&isci_host->completion_tasklet);
+			} else
+				dev_dbg(&isci_host->pdev->dev,
+					"%s: controller stopped\n",
+					__func__);
+			ret = IRQ_HANDLED;
+		}
+	} else
+		dev_warn(&isci_host->pdev->dev,
+			 "%s: get_handler_methods failed, "
+			 "isci_host->status = 0x%x\n",
+			 __func__,
+			 isci_host_get_state(isci_host));
+
+	return ret;
+}
+
+irqreturn_t isci_legacy_isr(int vec, void *data)
+{
+	struct pci_dev *pdev = data;
+	struct isci_host *isci_host;
+	struct scic_controller_handler_methods *handlers;
+	irqreturn_t ret = IRQ_NONE;
+
+	/*
+	 *  Since this is a legacy interrupt, either or both
+	 *  controllers could have triggered it.  Thus, we have to call
+	 *  the legacy interrupt handler for all controllers on the
+	 *  PCI function.
+	 */
+	for_each_isci_host(isci_host, pdev) {
+		handlers = &isci_host->scic_irq_handlers[SCI_MSIX_NORMAL_VECTOR];
+
+		if (isci_host_get_state(isci_host) != isci_starting
+		    && handlers->interrupt_handler) {
+
+			if (handlers->interrupt_handler(isci_host->core_controller)) {
+				if (isci_host_get_state(isci_host) != isci_stopped) {
+					tasklet_schedule(
+						&isci_host->completion_tasklet);
+				} else
+					dev_dbg(&isci_host->pdev->dev,
+						"%s: controller stopped\n",
+						__func__);
+				ret = IRQ_HANDLED;
+			}
+		} else
+			dev_warn(&isci_host->pdev->dev,
+				 "%s: get_handler_methods failed, "
+				 "isci_host->status = 0x%x\n",
+				 __func__,
+				 isci_host_get_state(isci_host));
+	}
+	return ret;
+}
+
+
+/**
+ * isci_host_start_complete() - This function is called by the core library,
+ *    through the ISCI Module, to indicate controller start status.
+ * @isci_host: This parameter specifies the ISCI host object
+ * @completion_status: This parameter specifies the completion status from the
+ *    core library.
+ *
+ */
+void isci_host_start_complete(
+	struct isci_host *isci_host,
+	enum sci_status completion_status)
+{
+	if (completion_status == SCI_SUCCESS) {
+		dev_dbg(&isci_host->pdev->dev,
+			"%s: completion_status: SCI_SUCCESS\n", __func__);
+		isci_host_change_state(isci_host, isci_ready);
+		complete_all(&isci_host->start_complete);
+	} else
+		dev_err(&isci_host->pdev->dev,
+			"controller start failed with "
+			"completion_status = 0x%x;",
+			completion_status);
+
+}
+
+
+
+/**
+ * isci_host_scan_finished() - This function is one of the SCSI Host Template
+ *    functions. The SCSI midlayer calls this function during a target scan,
+ *    approx. once every 10 millisecs.
+ * @shost: This parameter specifies the SCSI host being scanned
+ * @time: This parameter specifies the number of ticks since the scan started.
+ *
+ * scan status, zero indicates the SCSI midlayer should continue to poll,
+ * otherwise assume controller is ready.
+ */
+int isci_host_scan_finished(
+	struct Scsi_Host *shost,
+	unsigned long time)
+{
+	struct isci_host *isci_host
+		= isci_host_from_sas_ha(SHOST_TO_SAS_HA(shost));
+
+	struct scic_controller_handler_methods *handlers
+		= &isci_host->scic_irq_handlers[SCI_MSIX_NORMAL_VECTOR];
+
+	if (handlers->interrupt_handler == NULL) {
+		dev_err(&isci_host->pdev->dev,
+			"%s: scic_controller_get_handler_methods failed\n",
+			__func__);
+		return 1;
+	}
+
+	/**
+	 * check interrupt_handler's status and call completion_handler if true,
+	 * link_up events should be coming from the scu core lib, as phy's come
+	 * online. for each link_up from the core, call
+	 * get_received_identify_address_frame, copy the frame into the
+	 * sas_phy object and call libsas notify_port_event(PORTE_BYTES_DMAED).
+	 * continue to return zero from thee scan_finished routine until
+	 * the scic_cb_controller_start_complete() call comes from the core.
+	 **/
+	if (handlers->interrupt_handler(isci_host->core_controller))
+		handlers->completion_handler(isci_host->core_controller);
+
+	if (isci_starting == isci_host_get_state(isci_host)
+	    && time < (HZ * 10)) {
+		dev_dbg(&isci_host->pdev->dev,
+			"%s: isci_host->status = %d, time = %ld\n",
+			     __func__, isci_host_get_state(isci_host), time);
+		return 0;
+	}
+
+
+	dev_dbg(&isci_host->pdev->dev,
+		"%s: isci_host->status = %d, time = %ld\n",
+		 __func__, isci_host_get_state(isci_host), time);
+
+	scic_controller_enable_interrupts(isci_host->core_controller);
+
+	return 1;
+
+}
+
+
+/**
+ * isci_host_scan_start() - This function is one of the SCSI Host Template
+ *    function, called by the SCSI mid layer berfore a target scan begins. The
+ *    core library controller start routine is called from here.
+ * @shost: This parameter specifies the SCSI host to be scanned
+ *
+ */
+void isci_host_scan_start(struct Scsi_Host *shost)
+{
+	struct isci_host *isci_host;
+
+	isci_host = isci_host_from_sas_ha(SHOST_TO_SAS_HA(shost));
+	isci_host_change_state(isci_host, isci_starting);
+
+	scic_controller_disable_interrupts(isci_host->core_controller);
+	init_completion(&isci_host->start_complete);
+	scic_controller_start(
+		isci_host->core_controller,
+		scic_controller_get_suggested_start_timeout(
+			isci_host->core_controller)
+		);
+}
+
+void isci_host_stop_complete(
+	struct isci_host *isci_host,
+	enum sci_status completion_status)
+{
+	isci_host_change_state(isci_host, isci_stopped);
+	scic_controller_disable_interrupts(
+		isci_host->core_controller
+		);
+	complete(&isci_host->stop_complete);
+}
+
+static struct coherent_memory_info *isci_host_alloc_mdl_struct(
+	struct isci_host *isci_host,
+	u32 size)
+{
+	struct coherent_memory_info *mdl_struct;
+	void *uncached_address = NULL;
+
+
+	mdl_struct = devm_kzalloc(&isci_host->pdev->dev,
+				  sizeof(*mdl_struct),
+				  GFP_KERNEL);
+	if (!mdl_struct)
+		return NULL;
+
+	INIT_LIST_HEAD(&mdl_struct->node);
+
+	uncached_address = dmam_alloc_coherent(&isci_host->pdev->dev,
+					       size,
+					       &mdl_struct->dma_handle,
+					       GFP_KERNEL);
+	if (!uncached_address)
+		return NULL;
+
+	/* memset the whole memory area. */
+	memset((char *)uncached_address, 0, size);
+	mdl_struct->vaddr = uncached_address;
+	mdl_struct->size = (size_t)size;
+
+	return mdl_struct;
+}
+
+static void isci_host_build_mde(
+	struct sci_physical_memory_descriptor *mde_struct,
+	struct coherent_memory_info *mdl_struct)
+{
+	unsigned long address = 0;
+	dma_addr_t dma_addr = 0;
+
+	address = (unsigned long)mdl_struct->vaddr;
+	dma_addr = mdl_struct->dma_handle;
+
+	/* to satisfy the alignment. */
+	if ((address % mde_struct->constant_memory_alignment) != 0) {
+		int align_offset
+			= (mde_struct->constant_memory_alignment
+			   - (address % mde_struct->constant_memory_alignment));
+		address += align_offset;
+		dma_addr += align_offset;
+	}
+
+	mde_struct->virtual_address = (void *)address;
+	mde_struct->physical_address = dma_addr;
+	mdl_struct->mde = mde_struct;
+}
+
+static int isci_host_mdl_allocate_coherent(
+	struct isci_host *isci_host)
+{
+	struct sci_physical_memory_descriptor *current_mde;
+	struct coherent_memory_info *mdl_struct;
+	u32 size = 0;
+
+	struct sci_base_memory_descriptor_list *mdl_handle
+		= sci_controller_get_memory_descriptor_list_handle(
+		isci_host->core_controller);
+
+	sci_mdl_first_entry(mdl_handle);
+
+	current_mde = sci_mdl_get_current_entry(mdl_handle);
+
+	while (current_mde != NULL) {
+
+		size = (current_mde->constant_memory_size
+			+ current_mde->constant_memory_alignment);
+
+		mdl_struct = isci_host_alloc_mdl_struct(isci_host, size);
+		if (!mdl_struct)
+			return -ENOMEM;
+
+		list_add_tail(&mdl_struct->node, &isci_host->mdl_struct_list);
+
+		isci_host_build_mde(current_mde, mdl_struct);
+
+		sci_mdl_next_entry(mdl_handle);
+		current_mde = sci_mdl_get_current_entry(mdl_handle);
+	}
+
+	return 0;
+}
+
+
+/**
+ * isci_host_completion_routine() - This function is the delayed service
+ *    routine that calls the sci core library's completion handler. It's
+ *    scheduled as a tasklet from the interrupt service routine when interrupts
+ *    in use, or set as the timeout function in polled mode.
+ * @data: This parameter specifies the ISCI host object
+ *
+ */
+static void isci_host_completion_routine(unsigned long data)
+{
+	struct isci_host *isci_host = (struct isci_host *)data;
+	struct scic_controller_handler_methods *handlers
+		= &isci_host->scic_irq_handlers[SCI_MSIX_NORMAL_VECTOR];
+	struct list_head completed_request_list;
+	struct list_head aborted_request_list;
+	struct list_head *current_position;
+	struct list_head *next_position;
+	struct isci_request *request;
+	struct isci_request *next_request;
+	struct sas_task *task;
+
+	INIT_LIST_HEAD(&completed_request_list);
+	INIT_LIST_HEAD(&aborted_request_list);
+
+	spin_lock_irq(&isci_host->scic_lock);
+
+	if (handlers->completion_handler) {
+		handlers->completion_handler(
+			isci_host->core_controller
+			);
+	}
+	/* Take the lists of completed I/Os from the host. */
+	list_splice_init(&isci_host->requests_to_complete,
+			 &completed_request_list);
+
+	list_splice_init(&isci_host->requests_to_abort,
+			 &aborted_request_list);
+
+	spin_unlock_irq(&isci_host->scic_lock);
+
+	/* Process any completions in the lists. */
+	list_for_each_safe(current_position, next_position,
+			   &completed_request_list) {
+
+		request = list_entry(current_position, struct isci_request,
+				     completed_node);
+		task = isci_request_access_task(request);
+
+		/* Normal notification (task_done) */
+		dev_dbg(&isci_host->pdev->dev,
+			"%s: Normal - request/task = %p/%p\n",
+			__func__,
+			request,
+			task);
+
+		task->task_done(task);
+		task->lldd_task = NULL;
+
+		/* Free the request object. */
+		isci_request_free(isci_host, request);
+	}
+	list_for_each_entry_safe(request, next_request, &aborted_request_list,
+				 completed_node) {
+
+		task = isci_request_access_task(request);
+
+		/* Use sas_task_abort */
+		dev_warn(&isci_host->pdev->dev,
+			 "%s: Error - request/task = %p/%p\n",
+			 __func__,
+			 request,
+			 task);
+
+		/* Put the task into the abort path. */
+		sas_task_abort(task);
+	}
+
+}
+
+void isci_host_deinit(
+	struct isci_host *isci_host)
+{
+	int i;
+
+	isci_host_change_state(isci_host, isci_stopping);
+	for (i = 0; i < SCI_MAX_PORTS; i++) {
+		struct isci_port *port = &isci_host->isci_ports[i];
+		struct isci_remote_device *device, *tmpdev;
+		list_for_each_entry_safe(device, tmpdev,
+					 &port->remote_dev_list, node) {
+			isci_remote_device_change_state(device, isci_stopping);
+			isci_remote_device_stop(device);
+		}
+	}
+
+	/* stop the comtroller and wait for completion.  */
+	init_completion(&isci_host->stop_complete);
+	scic_controller_stop(
+		isci_host->core_controller,
+		SCIC_CONTROLLER_STOP_TIMEOUT
+		);
+	wait_for_completion(&isci_host->stop_complete);
+	/* next, reset the controller.           */
+	scic_controller_reset(isci_host->core_controller);
+}
+
+static int isci_verify_firmware(const struct firmware *fw,
+				struct isci_firmware *isci_fw)
+{
+	const u8 *tmp;
+
+	if (fw->size < ISCI_FIRMWARE_MIN_SIZE)
+		return -EINVAL;
+
+	tmp = fw->data;
+
+	/* 12th char should be the NULL terminate for the ID string */
+	if (tmp[11] != '\0')
+		return -EINVAL;
+
+	if (strncmp("#SCU MAGIC#", tmp, 11) != 0)
+		return -EINVAL;
+
+	isci_fw->id = tmp;
+	isci_fw->version = fw->data[ISCI_FW_VER_OFS];
+	isci_fw->subversion = fw->data[ISCI_FW_SUBVER_OFS];
+
+	tmp = fw->data + ISCI_FW_DATA_OFS;
+
+	while (*tmp != ISCI_FW_HDR_EOF) {
+		switch (*tmp) {
+		case ISCI_FW_HDR_PHYMASK:
+			tmp++;
+			isci_fw->phy_masks_size = *tmp;
+			tmp++;
+			isci_fw->phy_masks = (const u32 *)tmp;
+			tmp += sizeof(u32) * isci_fw->phy_masks_size;
+			break;
+
+		case ISCI_FW_HDR_PHYGEN:
+			tmp++;
+			isci_fw->phy_gens_size = *tmp;
+			tmp++;
+			isci_fw->phy_gens = (const u32 *)tmp;
+			tmp += sizeof(u32) * isci_fw->phy_gens_size;
+			break;
+
+		case ISCI_FW_HDR_SASADDR:
+			tmp++;
+			isci_fw->sas_addrs_size = *tmp;
+			tmp++;
+			isci_fw->sas_addrs = (const u64 *)tmp;
+			tmp += sizeof(u64) * isci_fw->sas_addrs_size;
+			break;
+
+		default:
+			pr_err("bad field in firmware binary blob\n");
+			return -EINVAL;
+		}
+	}
+
+	pr_info("isci firmware v%u.%u loaded.\n",
+	       isci_fw->version, isci_fw->subversion);
+
+	return SCI_SUCCESS;
+}
+
+static void __iomem *scu_base(struct isci_host *isci_host)
+{
+	struct pci_dev *pdev = isci_host->pdev;
+	int id = isci_host->id;
+
+	return pcim_iomap_table(pdev)[SCI_SCU_BAR * 2] + SCI_SCU_BAR_SIZE * id;
+}
+
+static void __iomem *smu_base(struct isci_host *isci_host)
+{
+	struct pci_dev *pdev = isci_host->pdev;
+	int id = isci_host->id;
+
+	return pcim_iomap_table(pdev)[SCI_SMU_BAR * 2] + SCI_SMU_BAR_SIZE * id;
+}
+
+#define SCI_MAX_TIMER_COUNT 25
+
+int isci_host_init(struct isci_host *isci_host)
+{
+	int err = 0;
+	int index = 0;
+	enum sci_status status;
+	struct scic_sds_controller *controller;
+	struct scic_sds_port *scic_port;
+	struct scic_controller_handler_methods *handlers
+		= &isci_host->scic_irq_handlers[0];
+	union scic_oem_parameters scic_oem_params;
+	union scic_user_parameters scic_user_params;
+	const struct firmware *fw = NULL;
+	struct isci_firmware *isci_fw = NULL;
+
+	INIT_LIST_HEAD(&isci_host->timer_list_struct.timers);
+	isci_timer_list_construct(
+		&isci_host->timer_list_struct,
+		SCI_MAX_TIMER_COUNT
+		);
+
+	controller = scic_controller_alloc(&isci_host->pdev->dev);
+
+	if (!controller) {
+		err = -ENOMEM;
+		dev_err(&isci_host->pdev->dev, "%s: failed (%d)\n", __func__, err);
+		goto out;
+	}
+
+	isci_host->core_controller = controller;
+	spin_lock_init(&isci_host->state_lock);
+	spin_lock_init(&isci_host->scic_lock);
+	spin_lock_init(&isci_host->queue_lock);
+
+	isci_host_change_state(isci_host, isci_starting);
+	isci_host->can_queue = ISCI_CAN_QUEUE_VAL;
+
+	status = scic_controller_construct(controller, scu_base(isci_host),
+					   smu_base(isci_host));
+
+	if (status != SCI_SUCCESS) {
+		dev_err(&isci_host->pdev->dev,
+			"%s: scic_controller_construct failed - status = %x\n",
+			__func__,
+			status);
+		err = -ENODEV;
+		goto out;
+	}
+
+	isci_host->sas_ha.dev = &isci_host->pdev->dev;
+	isci_host->sas_ha.lldd_ha = isci_host;
+
+	/*----------- SCIC controller Initialization Stuff ------------------
+	 * set association host adapter struct in core controller.
+	 */
+	sci_object_set_association(isci_host->core_controller,
+				   (void *)isci_host
+				   );
+
+	/* grab initial values stored in the controller object for OEM and USER
+	 * parameters */
+	scic_oem_parameters_get(controller, &scic_oem_params);
+	scic_user_parameters_get(controller, &scic_user_params);
+
+	isci_fw = devm_kzalloc(&isci_host->pdev->dev,
+			       sizeof(struct isci_firmware),
+			       GFP_KERNEL);
+	if (!isci_fw) {
+		dev_warn(&isci_host->pdev->dev,
+			 "allocating firmware struct failed\n");
+		dev_warn(&isci_host->pdev->dev,
+			 "Default OEM configuration being used:"
+			 " 4 narrow ports, and default SAS Addresses\n");
+		goto set_default_params;
+	}
+
+	status = request_firmware(&fw, ISCI_FW_NAME, &isci_host->pdev->dev);
+	if (status) {
+		dev_warn(&isci_host->pdev->dev,
+			 "Loading firmware failed, using default values\n");
+		dev_warn(&isci_host->pdev->dev,
+			 "Default OEM configuration being used:"
+			 " 4 narrow ports, and default SAS Addresses\n");
+		goto set_default_params;
+	}
+	else {
+		status = isci_verify_firmware(fw, isci_fw);
+		if (status != SCI_SUCCESS) {
+			dev_warn(&isci_host->pdev->dev,
+				 "firmware verification failed\n");
+			dev_warn(&isci_host->pdev->dev,
+				 "Default OEM configuration being used:"
+				 " 4 narrow ports, and default SAS "
+				 "Addresses\n");
+			goto set_default_params;
+		}
+
+		/* grab any OEM and USER parameters specified at module load */
+		status = isci_parse_oem_parameters(&scic_oem_params,
+						   isci_host->id, isci_fw);
+		if (status != SCI_SUCCESS) {
+			dev_warn(&isci_host->pdev->dev,
+				 "parsing firmware oem parameters failed\n");
+			err = -EINVAL;
+			goto out;
+		}
+
+		status = isci_parse_user_parameters(&scic_user_params,
+						    isci_host->id, isci_fw);
+		if (status != SCI_SUCCESS) {
+			dev_warn(&isci_host->pdev->dev,
+				 "%s: isci_parse_user_parameters"
+				 " failed\n", __func__);
+			err = -EINVAL;
+			goto out;
+		}
+	}
+
+ set_default_params:
+
+	status = scic_oem_parameters_set(isci_host->core_controller,
+					 &scic_oem_params
+					 );
+
+	if (status != SCI_SUCCESS) {
+		dev_warn(&isci_host->pdev->dev,
+			 "%s: scic_oem_parameters_set failed\n",
+			 __func__);
+		err = -ENODEV;
+		goto out;
+	}
+
+
+	status = scic_user_parameters_set(isci_host->core_controller,
+					  &scic_user_params
+					  );
+
+	if (status != SCI_SUCCESS) {
+		dev_warn(&isci_host->pdev->dev,
+			 "%s: scic_user_parameters_set failed\n",
+			 __func__);
+		err = -ENODEV;
+		goto out;
+	}
+
+	status = scic_controller_initialize(isci_host->core_controller);
+	if (status != SCI_SUCCESS) {
+		dev_warn(&isci_host->pdev->dev,
+			 "%s: scic_controller_initialize failed -"
+			 " status = 0x%x\n",
+			 __func__, status);
+		err = -ENODEV;
+		goto out;
+	}
+
+	/* @todo: use both MSI-X interrupts, and don't do indirect
+	 * calls to the handlers just register direct calls
+	 */
+	if (isci_host->pdev->msix_enabled) {
+		status = scic_controller_get_handler_methods(
+			SCIC_MSIX_INTERRUPT_TYPE,
+			SCI_MSIX_DOUBLE_VECTOR,
+			handlers
+			);
+	} else {
+		status = scic_controller_get_handler_methods(
+			SCIC_LEGACY_LINE_INTERRUPT_TYPE,
+			0,
+			handlers
+			);
+	}
+
+	if (status != SCI_SUCCESS) {
+		handlers->interrupt_handler = NULL;
+		handlers->completion_handler = NULL;
+		dev_err(&isci_host->pdev->dev,
+			"%s: scic_controller_get_handler_methods failed\n",
+			__func__);
+	}
+
+	tasklet_init(&isci_host->completion_tasklet,
+		     isci_host_completion_routine,
+		     (unsigned long)isci_host
+		     );
+
+	INIT_LIST_HEAD(&(isci_host->mdl_struct_list));
+
+	INIT_LIST_HEAD(&isci_host->requests_to_complete);
+	INIT_LIST_HEAD(&isci_host->requests_to_abort);
+
+	/* populate mdl with dma memory. scu_mdl_allocate_coherent() */
+	err = isci_host_mdl_allocate_coherent(isci_host);
+
+	if (err)
+		goto err_out;
+
+	/*
+	 * keep the pool alloc size around, will use it for a bounds checking
+	 * when trying to convert virtual addresses to physical addresses
+	 */
+	isci_host->dma_pool_alloc_size = sizeof(struct isci_request) +
+					 scic_io_request_get_object_size();
+	isci_host->dma_pool = dmam_pool_create(DRV_NAME, &isci_host->pdev->dev,
+					       isci_host->dma_pool_alloc_size,
+					       SLAB_HWCACHE_ALIGN, 0);
+
+	if (!isci_host->dma_pool) {
+		err = -ENOMEM;
+		goto req_obj_err_out;
+	}
+
+	for (index = 0; index < SCI_MAX_PORTS; index++) {
+		isci_port_init(&isci_host->isci_ports[index],
+			       isci_host, index);
+	}
+
+	for (index = 0; index < SCI_MAX_PHYS; index++)
+		isci_phy_init(&isci_host->phys[index], isci_host, index);
+
+	/* Why are we doing this? Is this even necessary? */
+	memcpy(&isci_host->sas_addr[0], &isci_host->phys[0].sas_addr[0],
+	       SAS_ADDR_SIZE);
+
+	/* Start the ports */
+	for (index = 0; index < SCI_MAX_PORTS; index++) {
+
+		scic_controller_get_port_handle(controller, index, &scic_port);
+		scic_port_start(scic_port);
+	}
+
+	goto out;
+
+/* SPB_Debug: destroy request object cache */
+ req_obj_err_out:
+/* SPB_Debug: destroy remote object cache */
+ err_out:
+/* SPB_Debug: undo controller init, construct and alloc, remove from parent
+ * controller list. */
+ out:
+	if (fw)
+		release_firmware(fw);
+	return err;
+}
