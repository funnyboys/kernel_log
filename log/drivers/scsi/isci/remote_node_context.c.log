commit 87be32b3ad27d7696cdc4340644894ba4c7a89e5
Author: Gustavo A. R. Silva <gustavo@embeddedor.com>
Date:   Tue Nov 27 22:30:11 2018 -0600

    scsi: isci: remote_node_context: mark expected switch fall-throughs
    
    In preparation to enabling -Wimplicit-fallthrough, mark switch cases where
    we are expecting to fall through.
    
    Notice that, in this particular case, a dash is added as a token in order
    to separate the "Fall through" annotations from the rest of the comment on
    the same line, which is what GCC is expecting to find.
    
    Signed-off-by: Gustavo A. R. Silva <gustavo@embeddedor.com>
    Acked-by: Artur Paszkiewicz <artur.paszkiewicz@intel.com>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/isci/remote_node_context.c b/drivers/scsi/isci/remote_node_context.c
index e3f2a5359d71..474a43460963 100644
--- a/drivers/scsi/isci/remote_node_context.c
+++ b/drivers/scsi/isci/remote_node_context.c
@@ -601,9 +601,9 @@ enum sci_status sci_remote_node_context_suspend(
 				 __func__, sci_rnc);
 			return SCI_FAILURE_INVALID_STATE;
 		}
-		/* Fall through and handle like SCI_RNC_POSTING */
+		/* Fall through - and handle like SCI_RNC_POSTING */
 	case SCI_RNC_RESUMING:
-		/* Fall through and handle like SCI_RNC_POSTING */
+		/* Fall through - and handle like SCI_RNC_POSTING */
 	case SCI_RNC_POSTING:
 		/* Set the destination state to AWAIT - this signals the
 		 * entry into the SCI_RNC_READY state that a suspension

commit 5cfa2a3c7342bd0b50716c8bb32ee491af43c785
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Fri Nov 18 17:14:01 2016 +0100

    scsi: isci: avoid array subscript warning
    
    I'm getting a new warning with gcc-7:
    
    isci/remote_node_context.c: In function 'sci_remote_node_context_destruct':
    isci/remote_node_context.c:69:16: error: array subscript is above array bounds [-Werror=array-bounds]
    
    This is odd, since we clearly cover all values for enum
    scis_sds_remote_node_context_states here. Anyway, checking for an array
    overflow can't harm and it makes the warning go away.
    
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/isci/remote_node_context.c b/drivers/scsi/isci/remote_node_context.c
index 30bd80052e03..e3f2a5359d71 100644
--- a/drivers/scsi/isci/remote_node_context.c
+++ b/drivers/scsi/isci/remote_node_context.c
@@ -66,6 +66,9 @@ const char *rnc_state_name(enum scis_sds_remote_node_context_states state)
 {
 	static const char * const strings[] = RNC_STATES;
 
+	if (state >= ARRAY_SIZE(strings))
+		return "UNKNOWN";
+
 	return strings[state];
 }
 #undef C

commit 99c7b6aec1d25c987ef9d4a34e34278b43b35f17
Author: Colin Ian King <colin.king@canonical.com>
Date:   Sat Nov 12 16:49:50 2016 +0000

    scsi: isci: fix spelling mistakes in dev_warn messages
    
    Trivial fix to spelling mistake "suspeneded" to "suspended" in dev_warn
    messages.
    
    [mkp: corrected description. Patch is against the isci driver, not iscsi]
    
    Signed-off-by: Colin Ian King <colin.king@canonical.com>
    Reviewed-by: Bart Van Assche <bart.vanassche@sandisk.com>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/isci/remote_node_context.c b/drivers/scsi/isci/remote_node_context.c
index 1910100638a2..30bd80052e03 100644
--- a/drivers/scsi/isci/remote_node_context.c
+++ b/drivers/scsi/isci/remote_node_context.c
@@ -454,7 +454,7 @@ enum sci_status sci_remote_node_context_event_handler(struct sci_remote_node_con
 				 * the device since it's being invalidated anyway */
 				dev_warn(scirdev_to_dev(rnc_to_dev(sci_rnc)),
 					"%s: SCIC Remote Node Context 0x%p was "
-					"suspeneded by hardware while being "
+					"suspended by hardware while being "
 					"invalidated.\n", __func__, sci_rnc);
 				break;
 			default:
@@ -473,7 +473,7 @@ enum sci_status sci_remote_node_context_event_handler(struct sci_remote_node_con
 				 * the device since it's being resumed anyway */
 				dev_warn(scirdev_to_dev(rnc_to_dev(sci_rnc)),
 					"%s: SCIC Remote Node Context 0x%p was "
-					"suspeneded by hardware while being resumed.\n",
+					"suspended by hardware while being resumed.\n",
 					__func__, sci_rnc);
 				break;
 			default:

commit de2eb4d5c5c25e8fb75d1e19092f24b83cb7d8d5
Author: Jeff Skirvin <jeffrey.d.skirvin@intel.com>
Date:   Tue Mar 13 17:15:11 2012 -0700

    isci: End the RNC resumption wait when the RNC is destroyed.
    
    While the RNC is suspended for I/O cleanup, the remote device can be
    stopped and the RNC setup for destruction.  These changes accomodate that
    case in the abort path.
    
    Signed-off-by: Jeff Skirvin <jeffrey.d.skirvin@intel.com>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/drivers/scsi/isci/remote_node_context.c b/drivers/scsi/isci/remote_node_context.c
index f5792a901e02..1910100638a2 100644
--- a/drivers/scsi/isci/remote_node_context.c
+++ b/drivers/scsi/isci/remote_node_context.c
@@ -190,9 +190,13 @@ static void sci_remote_node_context_setup_to_destroy(
 	scics_sds_remote_node_context_callback callback,
 	void *callback_parameter)
 {
+	struct isci_host *ihost = idev_to_ihost(rnc_to_dev(sci_rnc));
+
 	sci_rnc->destination_state = RNC_DEST_FINAL;
 	sci_rnc->user_callback     = callback;
 	sci_rnc->user_cookie       = callback_parameter;
+
+	wake_up(&ihost->eventq);
 }
 
 /**

commit 6c6aacbb7787dccc6fb662bae66e599bbf0f07b5
Author: Jeff Skirvin <jeffrey.d.skirvin@intel.com>
Date:   Tue Mar 13 17:03:00 2012 -0700

    isci: Fixed RNC bug that lost the suspension or resumption during destroy
    
    This fix corrects the saving of resume parameters when the destruction
    of the RNC has already been directed, and makes sure not to overwrite
    the RNC destruction callbacks.
    
    Signed-off-by: Jeff Skirvin <jeffrey.d.skirvin@intel.com>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/drivers/scsi/isci/remote_node_context.c b/drivers/scsi/isci/remote_node_context.c
index 6f0b61b2cca8..f5792a901e02 100644
--- a/drivers/scsi/isci/remote_node_context.c
+++ b/drivers/scsi/isci/remote_node_context.c
@@ -160,15 +160,6 @@ static void sci_remote_node_context_construct_buffer(struct sci_remote_node_cont
 	rnc->ssp.oaf_source_zone_group = 0;
 	rnc->ssp.oaf_more_compatibility_features = 0;
 }
-
-static void sci_remote_node_context_save_cbparams(
-	struct sci_remote_node_context *sci_rnc,
-	scics_sds_remote_node_context_callback callback,
-	void *callback_parameter)
-{
-	sci_rnc->user_callback = callback;
-	sci_rnc->user_cookie   = callback_parameter;
-}
 /**
  *
  * @sci_rnc:
@@ -187,9 +178,10 @@ static void sci_remote_node_context_setup_to_resume(
 {
 	if (sci_rnc->destination_state != RNC_DEST_FINAL) {
 		sci_rnc->destination_state = dest_param;
-		if (callback != NULL)
-			sci_remote_node_context_save_cbparams(
-				sci_rnc, callback, callback_parameter);
+		if (callback != NULL) {
+			sci_rnc->user_callback = callback;
+			sci_rnc->user_cookie   = callback_parameter;
+		}
 	}
 }
 
@@ -610,7 +602,8 @@ enum sci_status sci_remote_node_context_suspend(
 		 * entry into the SCI_RNC_READY state that a suspension
 		 * needs to be done immediately.
 		 */
-		sci_rnc->destination_state = RNC_DEST_SUSPENDED;
+		if (sci_rnc->destination_state != RNC_DEST_FINAL)
+			sci_rnc->destination_state = RNC_DEST_SUSPENDED;
 		sci_rnc->suspend_type = suspend_type;
 		sci_rnc->suspend_reason = suspend_reason;
 		return SCI_SUCCESS;
@@ -680,12 +673,9 @@ enum sci_status sci_remote_node_context_resume(struct sci_remote_node_context *s
 		if (sci_rnc->remote_node_index == SCIC_SDS_REMOTE_NODE_CONTEXT_INVALID_INDEX)
 			return SCI_FAILURE_INVALID_STATE;
 
-		if (test_bit(IDEV_ABORT_PATH_ACTIVE, &idev->flags))
-			sci_remote_node_context_save_cbparams(sci_rnc, cb_fn,
-							      cb_p);
-		else {
-			sci_remote_node_context_setup_to_resume(sci_rnc, cb_fn,
-							cb_p, RNC_DEST_READY);
+		sci_remote_node_context_setup_to_resume(sci_rnc, cb_fn,	cb_p,
+							RNC_DEST_READY);
+		if (!test_bit(IDEV_ABORT_PATH_ACTIVE, &idev->flags)) {
 			sci_remote_node_context_construct_buffer(sci_rnc);
 			sci_change_state(&sci_rnc->sm, SCI_RNC_POSTING);
 		}
@@ -694,38 +684,30 @@ enum sci_status sci_remote_node_context_resume(struct sci_remote_node_context *s
 	case SCI_RNC_POSTING:
 	case SCI_RNC_INVALIDATING:
 	case SCI_RNC_RESUMING:
-		if (test_bit(IDEV_ABORT_PATH_ACTIVE, &idev->flags))
-			sci_remote_node_context_save_cbparams(sci_rnc, cb_fn,
-							      cb_p);
-		else {
-			/* We are still waiting to post when a resume was
-			 * requested.
+		/* We are still waiting to post when a resume was
+		 * requested.
+		 */
+		switch (sci_rnc->destination_state) {
+		case RNC_DEST_SUSPENDED:
+		case RNC_DEST_SUSPENDED_RESUME:
+			/* Previously waiting to suspend after posting.
+			 * Now continue onto resumption.
 			 */
-			switch (sci_rnc->destination_state) {
-			case RNC_DEST_SUSPENDED:
-			case RNC_DEST_SUSPENDED_RESUME:
-				/* Previously waiting to suspend after posting.
-				 * Now continue onto resumption.
-				 */
-				sci_remote_node_context_setup_to_resume(
-					sci_rnc, cb_fn, cb_p,
-					RNC_DEST_SUSPENDED_RESUME);
-				break;
-			default:
-				sci_remote_node_context_setup_to_resume(
-					sci_rnc, cb_fn, cb_p,
-					RNC_DEST_READY);
-				break;
-			}
+			sci_remote_node_context_setup_to_resume(
+				sci_rnc, cb_fn, cb_p,
+				RNC_DEST_SUSPENDED_RESUME);
+			break;
+		default:
+			sci_remote_node_context_setup_to_resume(
+				sci_rnc, cb_fn, cb_p,
+				RNC_DEST_READY);
+			break;
 		}
 		return SCI_SUCCESS;
 
 	case SCI_RNC_TX_SUSPENDED:
 	case SCI_RNC_TX_RX_SUSPENDED:
-		if (test_bit(IDEV_ABORT_PATH_ACTIVE, &idev->flags))
-			sci_remote_node_context_save_cbparams(sci_rnc, cb_fn,
-							      cb_p);
-		else {
+		{
 			struct domain_device *dev = idev->domain_dev;
 			/* If this is an expander attached SATA device we must
 			 * invalidate and repost the RNC since this is the only
@@ -735,23 +717,21 @@ enum sci_status sci_remote_node_context_resume(struct sci_remote_node_context *s
 			sci_remote_node_context_setup_to_resume(
 				sci_rnc, cb_fn, cb_p, RNC_DEST_READY);
 
-			if (dev_is_sata(dev) && dev->parent)
-				sci_change_state(&sci_rnc->sm,
-						 SCI_RNC_INVALIDATING);
-			else
-				sci_change_state(&sci_rnc->sm,
-						 SCI_RNC_RESUMING);
+			if (!test_bit(IDEV_ABORT_PATH_ACTIVE, &idev->flags)) {
+				if ((dev_is_sata(dev) && dev->parent) ||
+				    (sci_rnc->destination_state == RNC_DEST_FINAL))
+					sci_change_state(&sci_rnc->sm,
+							 SCI_RNC_INVALIDATING);
+				else
+					sci_change_state(&sci_rnc->sm,
+							 SCI_RNC_RESUMING);
+			}
 		}
 		return SCI_SUCCESS;
 
 	case SCI_RNC_AWAIT_SUSPENSION:
-		if (test_bit(IDEV_ABORT_PATH_ACTIVE, &idev->flags))
-			sci_remote_node_context_save_cbparams(sci_rnc, cb_fn,
-							      cb_p);
-		else
-			sci_remote_node_context_setup_to_resume(
-				sci_rnc, cb_fn,	cb_p,
-				RNC_DEST_SUSPENDED_RESUME);
+		sci_remote_node_context_setup_to_resume(
+			sci_rnc, cb_fn, cb_p, RNC_DEST_SUSPENDED_RESUME);
 		return SCI_SUCCESS;
 	default:
 		dev_warn(scirdev_to_dev(rnc_to_dev(sci_rnc)),

commit 79cbab89ff31b6c6ab896d4ed5e3b2ae65193a96
Author: Jeff Skirvin <jeffrey.d.skirvin@intel.com>
Date:   Tue Mar 13 16:36:35 2012 -0700

    isci: Fix RNC AWAIT_SUSPENSION->INVALIDATING transition.
    
    The RNC state machine would incorrectly transition from
    SCI_RNC_AWAIT_SUSPENSION directly to SCI_RNC_INVALIDATING when a destruct
    request was made.  This would skip the increment of the suspension count
    and the abort of pending TCs (although the invalidating state would at
    least cleanup outstanding TCs).
    
    Instead, the RNC will transition to SCI_RNC_SUSPENDED and then start the
    destruction process.
    
    Signed-off-by: Jeff Skirvin <jeffrey.d.skirvin@intel.com>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/drivers/scsi/isci/remote_node_context.c b/drivers/scsi/isci/remote_node_context.c
index 920c2bb39333..6f0b61b2cca8 100644
--- a/drivers/scsi/isci/remote_node_context.c
+++ b/drivers/scsi/isci/remote_node_context.c
@@ -222,13 +222,19 @@ static void sci_remote_node_context_notify_user(
 
 static void sci_remote_node_context_continue_state_transitions(struct sci_remote_node_context *rnc)
 {
-	if ((rnc->destination_state == RNC_DEST_READY) ||
-	    (rnc->destination_state == RNC_DEST_SUSPENDED_RESUME)) {
+	switch (rnc->destination_state) {
+	case RNC_DEST_READY:
+	case RNC_DEST_SUSPENDED_RESUME:
 		rnc->destination_state = RNC_DEST_READY;
+		/* Fall through... */
+	case RNC_DEST_FINAL:
 		sci_remote_node_context_resume(rnc, rnc->user_callback,
-						    rnc->user_cookie);
-	} else
+					       rnc->user_cookie);
+		break;
+	default:
 		rnc->destination_state = RNC_DEST_UNSPECIFIED;
+		break;
+	}
 }
 
 static void sci_remote_node_context_validate_context_buffer(struct sci_remote_node_context *sci_rnc)
@@ -539,10 +545,12 @@ enum sci_status sci_remote_node_context_destruct(struct sci_remote_node_context
 	case SCI_RNC_READY:
 	case SCI_RNC_TX_SUSPENDED:
 	case SCI_RNC_TX_RX_SUSPENDED:
-	case SCI_RNC_AWAIT_SUSPENSION:
 		sci_remote_node_context_setup_to_destroy(sci_rnc, cb_fn, cb_p);
 		sci_change_state(&sci_rnc->sm, SCI_RNC_INVALIDATING);
 		return SCI_SUCCESS;
+	case SCI_RNC_AWAIT_SUSPENSION:
+		sci_remote_node_context_setup_to_destroy(sci_rnc, cb_fn, cb_p);
+		return SCI_SUCCESS;
 	case SCI_RNC_INITIAL:
 		dev_warn(scirdev_to_dev(rnc_to_dev(sci_rnc)),
 			 "%s: invalid state: %s\n", __func__,

commit 1f05388933cb6e57ed9e51768c194ff145002f3b
Author: Jeff Skirvin <jeffrey.d.skirvin@intel.com>
Date:   Thu Mar 8 22:42:08 2012 -0800

    isci: Don't wait for an RNC suspend if it's being destroyed.
    
    Make sure that the wait for suspend can handle the RNC destruction case.
    
    Signed-off-by: Jeff Skirvin <jeffrey.d.skirvin@intel.com>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/drivers/scsi/isci/remote_node_context.c b/drivers/scsi/isci/remote_node_context.c
index a0a62e3a500d..920c2bb39333 100644
--- a/drivers/scsi/isci/remote_node_context.c
+++ b/drivers/scsi/isci/remote_node_context.c
@@ -270,6 +270,8 @@ static void sci_remote_node_context_invalidate_context_buffer(struct sci_remote_
 static void sci_remote_node_context_initial_state_enter(struct sci_base_state_machine *sm)
 {
 	struct sci_remote_node_context *rnc = container_of(sm, typeof(*rnc), sm);
+	struct isci_remote_device *idev = rnc_to_dev(rnc);
+	struct isci_host *ihost = idev->owning_port->owning_controller;
 
 	/* Check to see if we have gotten back to the initial state because
 	 * someone requested to destroy the remote node context object.
@@ -277,6 +279,9 @@ static void sci_remote_node_context_initial_state_enter(struct sci_base_state_ma
 	if (sm->previous_state_id == SCI_RNC_INVALIDATING) {
 		rnc->destination_state = RNC_DEST_UNSPECIFIED;
 		sci_remote_node_context_notify_user(rnc);
+
+		smp_wmb();
+		wake_up(&ihost->eventq);
 	}
 }
 

commit 8c731888bf1be8d15d587ab1b4da80553302e653
Author: Jeff Skirvin <jeffrey.d.skirvin@intel.com>
Date:   Thu Mar 8 22:42:06 2012 -0800

    isci: Added timeouts to RNC suspensions in the abort path.
    
    This change adds timeouts to the RNC suspension wait.  It makes the
    suspend and resume timeouts the same.
    
    The previous resume timeout of 5 ms was too short, and timeouts were
    seen in resumptions of devices in the abort task/LUN reset path - which
    would receive an RNC resumed message within a tenth of a second later.
    
    Signed-off-by: Jeff Skirvin <jeffrey.d.skirvin@intel.com>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/drivers/scsi/isci/remote_node_context.c b/drivers/scsi/isci/remote_node_context.c
index b698081ce2dd..a0a62e3a500d 100644
--- a/drivers/scsi/isci/remote_node_context.c
+++ b/drivers/scsi/isci/remote_node_context.c
@@ -445,7 +445,7 @@ enum sci_status sci_remote_node_context_event_handler(struct sci_remote_node_con
 			case SCU_EVENT_TYPE_RNC_SUSPEND_TX_RX:
 				/* We really dont care if the hardware is going to suspend
 				 * the device since it's being invalidated anyway */
-				dev_dbg(scirdev_to_dev(rnc_to_dev(sci_rnc)),
+				dev_warn(scirdev_to_dev(rnc_to_dev(sci_rnc)),
 					"%s: SCIC Remote Node Context 0x%p was "
 					"suspeneded by hardware while being "
 					"invalidated.\n", __func__, sci_rnc);
@@ -464,7 +464,7 @@ enum sci_status sci_remote_node_context_event_handler(struct sci_remote_node_con
 			case SCU_EVENT_TYPE_RNC_SUSPEND_TX_RX:
 				/* We really dont care if the hardware is going to suspend
 				 * the device since it's being resumed anyway */
-				dev_dbg(scirdev_to_dev(rnc_to_dev(sci_rnc)),
+				dev_warn(scirdev_to_dev(rnc_to_dev(sci_rnc)),
 					"%s: SCIC Remote Node Context 0x%p was "
 					"suspeneded by hardware while being resumed.\n",
 					__func__, sci_rnc);
@@ -568,9 +568,9 @@ enum sci_status sci_remote_node_context_suspend(
 		RNC_DEST_UNSPECIFIED;
 
 	dev_dbg(scirdev_to_dev(idev),
-		"%s: current state %d, current suspend_type %x dest state %d,"
+		"%s: current state %s, current suspend_type %x dest state %d,"
 			" arg suspend_reason %d, arg suspend_type %x",
-		__func__, state, sci_rnc->suspend_type,
+		__func__, rnc_state_name(state), sci_rnc->suspend_type,
 		sci_rnc->destination_state, suspend_reason,
 		suspend_type);
 

commit d76689e46c8b2180c08575adc830cfda890ceb87
Author: Jeff Skirvin <jeffrey.d.skirvin@intel.com>
Date:   Thu Mar 8 22:42:04 2012 -0800

    isci: Fix RNC suspend call for SCI_RESUMING state.
    
    Instead of immediately transitioning to the SCI_RNC_AWAIT_SUSPENSION
    state, handle the SCI_RNC_RESUMING suspend transition from the
    SCI_RNC_READY state like the SCI_RNC_INVALIDATING --> SCI_RNC_POSTING
    transitions do now, by setting the destination state for the entry
    into the READY state.
    
    Signed-off-by: Jeff Skirvin <jeffrey.d.skirvin@intel.com>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/drivers/scsi/isci/remote_node_context.c b/drivers/scsi/isci/remote_node_context.c
index faeae9554ee3..b698081ce2dd 100644
--- a/drivers/scsi/isci/remote_node_context.c
+++ b/drivers/scsi/isci/remote_node_context.c
@@ -321,8 +321,6 @@ static void sci_remote_node_context_ready_state_enter(struct sci_base_state_mach
 {
 	struct sci_remote_node_context *rnc = container_of(sm, typeof(*rnc), sm);
 	enum sci_remote_node_context_destination_state dest_select;
-	scics_sds_remote_node_context_callback usr_cb = rnc->user_callback;
-	void *usr_param = rnc->user_cookie;
 	int tell_user = 1;
 
 	dest_select = rnc->destination_state;
@@ -334,12 +332,10 @@ static void sci_remote_node_context_ready_state_enter(struct sci_base_state_mach
 			rnc, rnc->suspend_reason,
 			SCI_SOFTWARE_SUSPEND_EXPECTED_EVENT);
 
-		if (dest_select == RNC_DEST_SUSPENDED_RESUME) {
-			sci_remote_node_context_resume(rnc, usr_cb, usr_param);
+		if (dest_select == RNC_DEST_SUSPENDED_RESUME)
 			tell_user = 0;  /* Wait until ready again. */
-		}
 	}
-	if (tell_user && rnc->user_callback)
+	if (tell_user)
 		sci_remote_node_context_notify_user(rnc);
 }
 
@@ -584,8 +580,6 @@ enum sci_status sci_remote_node_context_suspend(
 		dest_param = sci_rnc->destination_state;
 
 	switch (state) {
-	case SCI_RNC_RESUMING:
-		break;  /* The RNC has been posted, so start the suspend. */
 	case SCI_RNC_READY:
 		break;
 	case SCI_RNC_INVALIDATING:
@@ -596,6 +590,8 @@ enum sci_status sci_remote_node_context_suspend(
 			return SCI_FAILURE_INVALID_STATE;
 		}
 		/* Fall through and handle like SCI_RNC_POSTING */
+	case SCI_RNC_RESUMING:
+		/* Fall through and handle like SCI_RNC_POSTING */
 	case SCI_RNC_POSTING:
 		/* Set the destination state to AWAIT - this signals the
 		 * entry into the SCI_RNC_READY state that a suspension

commit 0c3ce38f1bc8b6a6d8df0959e3c0dece31f9350c
Author: Jeff Skirvin <jeffrey.d.skirvin@intel.com>
Date:   Thu Mar 8 22:42:02 2012 -0800

    isci: When in the abort path, defeat other resume calls until done.
    
    Completion of I/Os during the one of the abort path interface calls
    from libsas can drive remote device state changes and the resumption
    of the device RNC.  This is a problem when the abort path is
    attempting to cleanup outstanding I/O at the same time - the resumption
    can prevent the termination from occuring correctly.
    
    Signed-off-by: Jeff Skirvin <jeffrey.d.skirvin@intel.com>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/drivers/scsi/isci/remote_node_context.c b/drivers/scsi/isci/remote_node_context.c
index 77c8b5138b7e..faeae9554ee3 100644
--- a/drivers/scsi/isci/remote_node_context.c
+++ b/drivers/scsi/isci/remote_node_context.c
@@ -161,6 +161,14 @@ static void sci_remote_node_context_construct_buffer(struct sci_remote_node_cont
 	rnc->ssp.oaf_more_compatibility_features = 0;
 }
 
+static void sci_remote_node_context_save_cbparams(
+	struct sci_remote_node_context *sci_rnc,
+	scics_sds_remote_node_context_callback callback,
+	void *callback_parameter)
+{
+	sci_rnc->user_callback = callback;
+	sci_rnc->user_cookie   = callback_parameter;
+}
 /**
  *
  * @sci_rnc:
@@ -179,10 +187,9 @@ static void sci_remote_node_context_setup_to_resume(
 {
 	if (sci_rnc->destination_state != RNC_DEST_FINAL) {
 		sci_rnc->destination_state = dest_param;
-		if (callback != NULL) {
-			sci_rnc->user_callback = callback;
-			sci_rnc->user_cookie   = callback_parameter;
-		}
+		if (callback != NULL)
+			sci_remote_node_context_save_cbparams(
+				sci_rnc, callback, callback_parameter);
 	}
 }
 
@@ -648,67 +655,94 @@ enum sci_status sci_remote_node_context_resume(struct sci_remote_node_context *s
 						    void *cb_p)
 {
 	enum scis_sds_remote_node_context_states state;
+	struct isci_remote_device *idev = rnc_to_dev(sci_rnc);
 
 	state = sci_rnc->sm.current_state_id;
-	dev_dbg(scirdev_to_dev(rnc_to_dev(sci_rnc)),
-		 "%s: state %s, cb_fn = %p, cb_p = %p; dest_state = %d\n",
-		 __func__, rnc_state_name(state), cb_fn, cb_p,
-		 sci_rnc->destination_state);
+	dev_dbg(scirdev_to_dev(idev),
+		"%s: state %s, cb_fn = %p, cb_p = %p; dest_state = %d; "
+			"dev resume path %s\n",
+		__func__, rnc_state_name(state), cb_fn, cb_p,
+		sci_rnc->destination_state,
+		test_bit(IDEV_ABORT_PATH_ACTIVE, &idev->flags)
+			? "<abort active>" : "<normal>");
 
 	switch (state) {
 	case SCI_RNC_INITIAL:
 		if (sci_rnc->remote_node_index == SCIC_SDS_REMOTE_NODE_CONTEXT_INVALID_INDEX)
 			return SCI_FAILURE_INVALID_STATE;
 
-		sci_remote_node_context_setup_to_resume(sci_rnc, cb_fn, cb_p,
-							RNC_DEST_READY);
-		sci_remote_node_context_construct_buffer(sci_rnc);
-		sci_change_state(&sci_rnc->sm, SCI_RNC_POSTING);
+		if (test_bit(IDEV_ABORT_PATH_ACTIVE, &idev->flags))
+			sci_remote_node_context_save_cbparams(sci_rnc, cb_fn,
+							      cb_p);
+		else {
+			sci_remote_node_context_setup_to_resume(sci_rnc, cb_fn,
+							cb_p, RNC_DEST_READY);
+			sci_remote_node_context_construct_buffer(sci_rnc);
+			sci_change_state(&sci_rnc->sm, SCI_RNC_POSTING);
+		}
 		return SCI_SUCCESS;
+
 	case SCI_RNC_POSTING:
 	case SCI_RNC_INVALIDATING:
 	case SCI_RNC_RESUMING:
-		/* We are still waiting to post when a resume was requested. */
-		switch (sci_rnc->destination_state) {
-		case RNC_DEST_SUSPENDED:
-		case RNC_DEST_SUSPENDED_RESUME:
-			/* Previously waiting to suspend after posting.  Now
-			 * continue onto resumption.
+		if (test_bit(IDEV_ABORT_PATH_ACTIVE, &idev->flags))
+			sci_remote_node_context_save_cbparams(sci_rnc, cb_fn,
+							      cb_p);
+		else {
+			/* We are still waiting to post when a resume was
+			 * requested.
 			 */
-			sci_remote_node_context_setup_to_resume(
-				sci_rnc, cb_fn, cb_p,
-				RNC_DEST_SUSPENDED_RESUME);
-			break;
-		default:
-			sci_remote_node_context_setup_to_resume(
-				sci_rnc, cb_fn, cb_p,
-				RNC_DEST_READY);
-			break;
+			switch (sci_rnc->destination_state) {
+			case RNC_DEST_SUSPENDED:
+			case RNC_DEST_SUSPENDED_RESUME:
+				/* Previously waiting to suspend after posting.
+				 * Now continue onto resumption.
+				 */
+				sci_remote_node_context_setup_to_resume(
+					sci_rnc, cb_fn, cb_p,
+					RNC_DEST_SUSPENDED_RESUME);
+				break;
+			default:
+				sci_remote_node_context_setup_to_resume(
+					sci_rnc, cb_fn, cb_p,
+					RNC_DEST_READY);
+				break;
+			}
 		}
 		return SCI_SUCCESS;
+
 	case SCI_RNC_TX_SUSPENDED:
-	case SCI_RNC_TX_RX_SUSPENDED: {
-		struct isci_remote_device *idev = rnc_to_dev(sci_rnc);
-		struct domain_device *dev = idev->domain_dev;
-
-		/* If this is an expander attached SATA device we must
-		 * invalidate and repost the RNC since this is the only way
-		 * to clear the TCi to NCQ tag mapping table for the RNi.
-		 * All other device types we can just resume.
-		 */
-		sci_remote_node_context_setup_to_resume(sci_rnc, cb_fn, cb_p,
-							RNC_DEST_READY);
+	case SCI_RNC_TX_RX_SUSPENDED:
+		if (test_bit(IDEV_ABORT_PATH_ACTIVE, &idev->flags))
+			sci_remote_node_context_save_cbparams(sci_rnc, cb_fn,
+							      cb_p);
+		else {
+			struct domain_device *dev = idev->domain_dev;
+			/* If this is an expander attached SATA device we must
+			 * invalidate and repost the RNC since this is the only
+			 * way to clear the TCi to NCQ tag mapping table for
+			 * the RNi. All other device types we can just resume.
+			 */
+			sci_remote_node_context_setup_to_resume(
+				sci_rnc, cb_fn, cb_p, RNC_DEST_READY);
 
-		if (dev_is_sata(dev) && dev->parent)
-			sci_change_state(&sci_rnc->sm, SCI_RNC_INVALIDATING);
-		else
-			sci_change_state(&sci_rnc->sm, SCI_RNC_RESUMING);
+			if (dev_is_sata(dev) && dev->parent)
+				sci_change_state(&sci_rnc->sm,
+						 SCI_RNC_INVALIDATING);
+			else
+				sci_change_state(&sci_rnc->sm,
+						 SCI_RNC_RESUMING);
+		}
 		return SCI_SUCCESS;
-	}
+
 	case SCI_RNC_AWAIT_SUSPENSION:
-		sci_remote_node_context_setup_to_resume(
-			sci_rnc, cb_fn, cb_p,
-			RNC_DEST_SUSPENDED_RESUME);
+		if (test_bit(IDEV_ABORT_PATH_ACTIVE, &idev->flags))
+			sci_remote_node_context_save_cbparams(sci_rnc, cb_fn,
+							      cb_p);
+		else
+			sci_remote_node_context_setup_to_resume(
+				sci_rnc, cb_fn,	cb_p,
+				RNC_DEST_SUSPENDED_RESUME);
 		return SCI_SUCCESS;
 	default:
 		dev_warn(scirdev_to_dev(rnc_to_dev(sci_rnc)),

commit 31a38ef0a5ad12dbe262ca55d0a905657be55a8d
Author: Jeff Skirvin <jeffrey.d.skirvin@intel.com>
Date:   Thu Mar 8 22:42:01 2012 -0800

    isci: Implement waiting for suspend in the abort path.
    
    In order to prevent a device from receiving an I/O request while still
    in an RNC suspending or resuming state (and therefore failing that
    I/O back to libsas with a reset required status) wait for the RNC state
    change before proceding in the abort path.
    
    Signed-off-by: Jeff Skirvin <jeffrey.d.skirvin@intel.com>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/drivers/scsi/isci/remote_node_context.c b/drivers/scsi/isci/remote_node_context.c
index 48565de50016..77c8b5138b7e 100644
--- a/drivers/scsi/isci/remote_node_context.c
+++ b/drivers/scsi/isci/remote_node_context.c
@@ -90,6 +90,15 @@ bool sci_remote_node_context_is_ready(
 	return false;
 }
 
+bool sci_remote_node_context_is_suspended(struct sci_remote_node_context *sci_rnc)
+{
+	u32 current_state = sci_rnc->sm.current_state_id;
+
+	if (current_state == SCI_RNC_TX_RX_SUSPENDED)
+		return true;
+	return false;
+}
+
 static union scu_remote_node_context *sci_rnc_by_id(struct isci_host *ihost, u16 id)
 {
 	if (id < ihost->remote_node_entries &&
@@ -339,6 +348,13 @@ static void sci_remote_node_context_tx_rx_suspended_state_enter(struct sci_base_
 	struct sci_remote_node_context *rnc = container_of(sm, typeof(*rnc), sm);
 	struct isci_remote_device *idev = rnc_to_dev(rnc);
 	struct isci_host *ihost = idev->owning_port->owning_controller;
+	u32 new_count = rnc->suspend_count + 1;
+
+	if (new_count == 0)
+		rnc->suspend_count = 1;
+	else
+		rnc->suspend_count = new_count;
+	smp_wmb();
 
 	/* Terminate outstanding requests pending abort. */
 	sci_remote_device_abort_requests_pending_abort(idev);
@@ -634,6 +650,11 @@ enum sci_status sci_remote_node_context_resume(struct sci_remote_node_context *s
 	enum scis_sds_remote_node_context_states state;
 
 	state = sci_rnc->sm.current_state_id;
+	dev_dbg(scirdev_to_dev(rnc_to_dev(sci_rnc)),
+		 "%s: state %s, cb_fn = %p, cb_p = %p; dest_state = %d\n",
+		 __func__, rnc_state_name(state), cb_fn, cb_p,
+		 sci_rnc->destination_state);
+
 	switch (state) {
 	case SCI_RNC_INITIAL:
 		if (sci_rnc->remote_node_index == SCIC_SDS_REMOTE_NODE_CONTEXT_INVALID_INDEX)

commit 9608b6408e637abeec101abb6aebd3343f0ebac4
Author: Jeff Skirvin <jeffrey.d.skirvin@intel.com>
Date:   Thu Mar 8 22:42:00 2012 -0800

    isci: Manage the LLHANG timer enable/disable per-device.
    
    The LLHANG timer should be enabled once per device.  This patch corrects
    both the timer enable and the timer disable for the remote device.
    
    Signed-off-by: Jeff Skirvin <jeffrey.d.skirvin@intel.com>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/drivers/scsi/isci/remote_node_context.c b/drivers/scsi/isci/remote_node_context.c
index 2ac92608cc2d..48565de50016 100644
--- a/drivers/scsi/isci/remote_node_context.c
+++ b/drivers/scsi/isci/remote_node_context.c
@@ -615,8 +615,7 @@ enum sci_status sci_remote_node_context_suspend(
 	if ((suspend_reason == SCI_SW_SUSPEND_NORMAL) ||
 	    (suspend_reason == SCI_SW_SUSPEND_LINKHANG_DETECT)) {
 
-		if ((suspend_reason == SCI_SW_SUSPEND_LINKHANG_DETECT)
-		 && dev_is_sata(idev->domain_dev))
+		if (suspend_reason == SCI_SW_SUSPEND_LINKHANG_DETECT)
 			isci_dev_set_hang_detection_timeout(idev, 0x00000001);
 
 		sci_remote_device_post_request(

commit 447bfbcee070a0b43dd6abc743063d7a02fe65ca
Author: Jeff Skirvin <jeffrey.d.skirvin@intel.com>
Date:   Thu Mar 8 22:41:59 2012 -0800

    isci: Save the suspension hint for upcoming suspensions.
    
    In the case of a suspend call while in SCI_RNC_POSTING or INVALIDATING
    states, the LLHANG detect needed to be saved so the upcoming suspension
    would enable it correctly.  The unused suspend callback parameters were
    removed.
    
    Signed-off-by: Jeff Skirvin <jeffrey.d.skirvin@intel.com>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/drivers/scsi/isci/remote_node_context.c b/drivers/scsi/isci/remote_node_context.c
index 85bf5ec26417..2ac92608cc2d 100644
--- a/drivers/scsi/isci/remote_node_context.c
+++ b/drivers/scsi/isci/remote_node_context.c
@@ -315,8 +315,8 @@ static void sci_remote_node_context_ready_state_enter(struct sci_base_state_mach
 	if ((dest_select == RNC_DEST_SUSPENDED) ||
 	    (dest_select == RNC_DEST_SUSPENDED_RESUME)) {
 		sci_remote_node_context_suspend(
-			rnc, SCI_SW_SUSPEND_NORMAL,
-			SCI_SOFTWARE_SUSPEND_EXPECTED_EVENT, NULL, NULL);
+			rnc, rnc->suspend_reason,
+			SCI_SOFTWARE_SUSPEND_EXPECTED_EVENT);
 
 		if (dest_select == RNC_DEST_SUSPENDED_RESUME) {
 			sci_remote_node_context_resume(rnc, usr_cb, usr_param);
@@ -539,9 +539,7 @@ enum sci_status sci_remote_node_context_destruct(struct sci_remote_node_context
 enum sci_status sci_remote_node_context_suspend(
 			struct sci_remote_node_context *sci_rnc,
 			enum sci_remote_node_suspension_reasons suspend_reason,
-			u32 suspend_type,
-			scics_sds_remote_node_context_callback cb_fn,
-			void *cb_p)
+			u32 suspend_type)
 {
 	enum scis_sds_remote_node_context_states state
 		= sci_rnc->sm.current_state_id;
@@ -581,6 +579,8 @@ enum sci_status sci_remote_node_context_suspend(
 		 * needs to be done immediately.
 		 */
 		sci_rnc->destination_state = RNC_DEST_SUSPENDED;
+		sci_rnc->suspend_type = suspend_type;
+		sci_rnc->suspend_reason = suspend_reason;
 		return SCI_SUCCESS;
 
 	case SCI_RNC_TX_SUSPENDED:
@@ -603,14 +603,12 @@ enum sci_status sci_remote_node_context_suspend(
 		return SCI_FAILURE_INVALID_STATE;
 	}
 	sci_rnc->destination_state = dest_param;
-	sci_rnc->user_callback = cb_fn;
-	sci_rnc->user_cookie   = cb_p;
-	sci_rnc->suspend_type  = suspend_type;
+	sci_rnc->suspend_type = suspend_type;
+	sci_rnc->suspend_reason = suspend_reason;
 
 	if (status == SCI_SUCCESS) { /* Already in the destination state? */
 		struct isci_host *ihost = idev->owning_port->owning_controller;
 
-		sci_remote_node_context_notify_user(sci_rnc);
 		wake_up_all(&ihost->eventq); /* Let observers look. */
 		return SCI_SUCCESS;
 	}

commit c94fc1ad25de885e1c59f714f19bc726e7a21caf
Author: Jeff Skirvin <jeffrey.d.skirvin@intel.com>
Date:   Thu Mar 8 22:41:58 2012 -0800

    isci: Distinguish between remote device suspension cases
    
    For NCQ error conditions among others, there is no need to enable
    the link layer hang detect timer.
    
    Signed-off-by: Jeff Skirvin <jeffrey.d.skirvin@intel.com>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/drivers/scsi/isci/remote_node_context.c b/drivers/scsi/isci/remote_node_context.c
index adbb4b80d9e4..85bf5ec26417 100644
--- a/drivers/scsi/isci/remote_node_context.c
+++ b/drivers/scsi/isci/remote_node_context.c
@@ -52,7 +52,7 @@
  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
-
+#include <scsi/sas_ata.h>
 #include "host.h"
 #include "isci.h"
 #include "remote_device.h"
@@ -315,7 +315,7 @@ static void sci_remote_node_context_ready_state_enter(struct sci_base_state_mach
 	if ((dest_select == RNC_DEST_SUSPENDED) ||
 	    (dest_select == RNC_DEST_SUSPENDED_RESUME)) {
 		sci_remote_node_context_suspend(
-			rnc, SCI_SOFTWARE_SUSPENSION,
+			rnc, SCI_SW_SUSPEND_NORMAL,
 			SCI_SOFTWARE_SUSPEND_EXPECTED_EVENT, NULL, NULL);
 
 		if (dest_select == RNC_DEST_SUSPENDED_RESUME) {
@@ -352,8 +352,10 @@ static void sci_remote_node_context_await_suspend_state_exit(
 {
 	struct sci_remote_node_context *rnc
 		= container_of(sm, typeof(*rnc), sm);
+	struct isci_remote_device *idev = rnc_to_dev(rnc);
 
-	isci_dev_set_hang_detection_timeout(rnc_to_dev(rnc), 0);
+	if (dev_is_sata(idev->domain_dev))
+		isci_dev_set_hang_detection_timeout(idev, 0);
 }
 
 static const struct sci_base_state sci_remote_node_context_state_table[] = {
@@ -556,7 +558,7 @@ enum sci_status sci_remote_node_context_suspend(
 		suspend_type);
 
 	/* Disable automatic state continuations if explicitly suspending. */
-	if ((suspend_reason != SCI_SOFTWARE_SUSPENSION) ||
+	if ((suspend_reason == SCI_HW_SUSPEND) ||
 	    (sci_rnc->destination_state == RNC_DEST_FINAL))
 		dest_param = sci_rnc->destination_state;
 
@@ -612,8 +614,13 @@ enum sci_status sci_remote_node_context_suspend(
 		wake_up_all(&ihost->eventq); /* Let observers look. */
 		return SCI_SUCCESS;
 	}
-	if (suspend_reason == SCI_SOFTWARE_SUSPENSION) {
-		isci_dev_set_hang_detection_timeout(idev, 0x00000001);
+	if ((suspend_reason == SCI_SW_SUSPEND_NORMAL) ||
+	    (suspend_reason == SCI_SW_SUSPEND_LINKHANG_DETECT)) {
+
+		if ((suspend_reason == SCI_SW_SUSPEND_LINKHANG_DETECT)
+		 && dev_is_sata(idev->domain_dev))
+			isci_dev_set_hang_detection_timeout(idev, 0x00000001);
+
 		sci_remote_device_post_request(
 			idev, SCI_SOFTWARE_SUSPEND_CMD);
 	}

commit aa20d9343079b1f0bebd43dec82ecfd4af5e43da
Author: Jeff Skirvin <jeffrey.d.skirvin@intel.com>
Date:   Thu Mar 8 22:41:56 2012 -0800

    isci: All pending TCs are terminated when the RNC is invalidated.
    
    Signed-off-by: Jeff Skirvin <jeffrey.d.skirvin@intel.com>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/drivers/scsi/isci/remote_node_context.c b/drivers/scsi/isci/remote_node_context.c
index 75cf043e2adf..adbb4b80d9e4 100644
--- a/drivers/scsi/isci/remote_node_context.c
+++ b/drivers/scsi/isci/remote_node_context.c
@@ -275,8 +275,8 @@ static void sci_remote_node_context_invalidating_state_enter(struct sci_base_sta
 {
 	struct sci_remote_node_context *rnc = container_of(sm, typeof(*rnc), sm);
 
-	/* Terminate outstanding requests pending abort. */
-	sci_remote_device_abort_requests_pending_abort(rnc_to_dev(rnc));
+	/* Terminate all outstanding requests. */
+	sci_remote_device_terminate_requests(rnc_to_dev(rnc));
 	sci_remote_node_context_invalidate_context_buffer(rnc);
 }
 

commit 59e35396436c564b5019e1a70073900bc3e19f4f
Author: Jeff Skirvin <jeffrey.d.skirvin@intel.com>
Date:   Thu Mar 8 22:41:54 2012 -0800

    isci: Add suspension cases for RNC INVALIDATING, POSTING states.
    
    The RNC can be any of the states in the loop from suspended to
    ready when the API "suspend" or "resume" are called.  This change
    adds destination states parameters that control the suspension /
    resumption action of the RNC statemachine for those transition states.
    
    Signed-off-by: Jeff Skirvin <jeffrey.d.skirvin@intel.com>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/drivers/scsi/isci/remote_node_context.c b/drivers/scsi/isci/remote_node_context.c
index feeca17f0f13..75cf043e2adf 100644
--- a/drivers/scsi/isci/remote_node_context.c
+++ b/drivers/scsi/isci/remote_node_context.c
@@ -165,21 +165,24 @@ static void sci_remote_node_context_construct_buffer(struct sci_remote_node_cont
 static void sci_remote_node_context_setup_to_resume(
 	struct sci_remote_node_context *sci_rnc,
 	scics_sds_remote_node_context_callback callback,
-	void *callback_parameter)
+	void *callback_parameter,
+	enum sci_remote_node_context_destination_state dest_param)
 {
-	if (sci_rnc->destination_state != SCIC_SDS_REMOTE_NODE_DESTINATION_STATE_FINAL) {
-		sci_rnc->destination_state = SCIC_SDS_REMOTE_NODE_DESTINATION_STATE_READY;
-		sci_rnc->user_callback     = callback;
-		sci_rnc->user_cookie       = callback_parameter;
+	if (sci_rnc->destination_state != RNC_DEST_FINAL) {
+		sci_rnc->destination_state = dest_param;
+		if (callback != NULL) {
+			sci_rnc->user_callback = callback;
+			sci_rnc->user_cookie   = callback_parameter;
+		}
 	}
 }
 
-static void sci_remote_node_context_setup_to_destory(
+static void sci_remote_node_context_setup_to_destroy(
 	struct sci_remote_node_context *sci_rnc,
 	scics_sds_remote_node_context_callback callback,
 	void *callback_parameter)
 {
-	sci_rnc->destination_state = SCIC_SDS_REMOTE_NODE_DESTINATION_STATE_FINAL;
+	sci_rnc->destination_state = RNC_DEST_FINAL;
 	sci_rnc->user_callback     = callback;
 	sci_rnc->user_cookie       = callback_parameter;
 }
@@ -203,9 +206,13 @@ static void sci_remote_node_context_notify_user(
 
 static void sci_remote_node_context_continue_state_transitions(struct sci_remote_node_context *rnc)
 {
-	if (rnc->destination_state == SCIC_SDS_REMOTE_NODE_DESTINATION_STATE_READY)
+	if ((rnc->destination_state == RNC_DEST_READY) ||
+	    (rnc->destination_state == RNC_DEST_SUSPENDED_RESUME)) {
+		rnc->destination_state = RNC_DEST_READY;
 		sci_remote_node_context_resume(rnc, rnc->user_callback,
 						    rnc->user_cookie);
+	} else
+		rnc->destination_state = RNC_DEST_UNSPECIFIED;
 }
 
 static void sci_remote_node_context_validate_context_buffer(struct sci_remote_node_context *sci_rnc)
@@ -252,7 +259,7 @@ static void sci_remote_node_context_initial_state_enter(struct sci_base_state_ma
 	 * someone requested to destroy the remote node context object.
 	 */
 	if (sm->previous_state_id == SCI_RNC_INVALIDATING) {
-		rnc->destination_state = SCIC_SDS_REMOTE_NODE_DESTINATION_STATE_UNSPECIFIED;
+		rnc->destination_state = RNC_DEST_UNSPECIFIED;
 		sci_remote_node_context_notify_user(rnc);
 	}
 }
@@ -297,10 +304,26 @@ static void sci_remote_node_context_resuming_state_enter(struct sci_base_state_m
 static void sci_remote_node_context_ready_state_enter(struct sci_base_state_machine *sm)
 {
 	struct sci_remote_node_context *rnc = container_of(sm, typeof(*rnc), sm);
-
-	rnc->destination_state = SCIC_SDS_REMOTE_NODE_DESTINATION_STATE_UNSPECIFIED;
-
-	if (rnc->user_callback)
+	enum sci_remote_node_context_destination_state dest_select;
+	scics_sds_remote_node_context_callback usr_cb = rnc->user_callback;
+	void *usr_param = rnc->user_cookie;
+	int tell_user = 1;
+
+	dest_select = rnc->destination_state;
+	rnc->destination_state = RNC_DEST_UNSPECIFIED;
+
+	if ((dest_select == RNC_DEST_SUSPENDED) ||
+	    (dest_select == RNC_DEST_SUSPENDED_RESUME)) {
+		sci_remote_node_context_suspend(
+			rnc, SCI_SOFTWARE_SUSPENSION,
+			SCI_SOFTWARE_SUSPEND_EXPECTED_EVENT, NULL, NULL);
+
+		if (dest_select == RNC_DEST_SUSPENDED_RESUME) {
+			sci_remote_node_context_resume(rnc, usr_cb, usr_param);
+			tell_user = 0;  /* Wait until ready again. */
+		}
+	}
+	if (tell_user && rnc->user_callback)
 		sci_remote_node_context_notify_user(rnc);
 }
 
@@ -366,7 +389,7 @@ void sci_remote_node_context_construct(struct sci_remote_node_context *rnc,
 	memset(rnc, 0, sizeof(struct sci_remote_node_context));
 
 	rnc->remote_node_index = remote_node_index;
-	rnc->destination_state = SCIC_SDS_REMOTE_NODE_DESTINATION_STATE_UNSPECIFIED;
+	rnc->destination_state = RNC_DEST_UNSPECIFIED;
 
 	sci_init_sm(&rnc->sm, sci_remote_node_context_state_table, SCI_RNC_INITIAL);
 }
@@ -390,11 +413,11 @@ enum sci_status sci_remote_node_context_event_handler(struct sci_remote_node_con
 		break;
 	case SCI_RNC_INVALIDATING:
 		if (scu_get_event_code(event_code) == SCU_EVENT_POST_RNC_INVALIDATE_COMPLETE) {
-			if (sci_rnc->destination_state == SCIC_SDS_REMOTE_NODE_DESTINATION_STATE_FINAL)
-				state = SCI_RNC_INITIAL;
+			if (sci_rnc->destination_state == RNC_DEST_FINAL)
+				next_state = SCI_RNC_INITIAL;
 			else
-				state = SCI_RNC_POSTING;
-			sci_change_state(&sci_rnc->sm, state);
+				next_state = SCI_RNC_POSTING;
+			sci_change_state(&sci_rnc->sm, next_state);
 		} else {
 			switch (scu_get_event_type(event_code)) {
 			case SCU_EVENT_TYPE_RNC_SUSPEND_TX:
@@ -483,7 +506,7 @@ enum sci_status sci_remote_node_context_destruct(struct sci_remote_node_context
 	state = sci_rnc->sm.current_state_id;
 	switch (state) {
 	case SCI_RNC_INVALIDATING:
-		sci_remote_node_context_setup_to_destory(sci_rnc, cb_fn, cb_p);
+		sci_remote_node_context_setup_to_destroy(sci_rnc, cb_fn, cb_p);
 		return SCI_SUCCESS;
 	case SCI_RNC_POSTING:
 	case SCI_RNC_RESUMING:
@@ -491,7 +514,7 @@ enum sci_status sci_remote_node_context_destruct(struct sci_remote_node_context
 	case SCI_RNC_TX_SUSPENDED:
 	case SCI_RNC_TX_RX_SUSPENDED:
 	case SCI_RNC_AWAIT_SUSPENSION:
-		sci_remote_node_context_setup_to_destory(sci_rnc, cb_fn, cb_p);
+		sci_remote_node_context_setup_to_destroy(sci_rnc, cb_fn, cb_p);
 		sci_change_state(&sci_rnc->sm, SCI_RNC_INVALIDATING);
 		return SCI_SUCCESS;
 	case SCI_RNC_INITIAL:
@@ -522,6 +545,8 @@ enum sci_status sci_remote_node_context_suspend(
 		= sci_rnc->sm.current_state_id;
 	struct isci_remote_device *idev = rnc_to_dev(sci_rnc);
 	enum sci_status status = SCI_FAILURE_INVALID_STATE;
+	enum sci_remote_node_context_destination_state dest_param =
+		RNC_DEST_UNSPECIFIED;
 
 	dev_dbg(scirdev_to_dev(idev),
 		"%s: current state %d, current suspend_type %x dest state %d,"
@@ -531,12 +556,31 @@ enum sci_status sci_remote_node_context_suspend(
 		suspend_type);
 
 	/* Disable automatic state continuations if explicitly suspending. */
-	if (suspend_reason == SCI_SOFTWARE_SUSPENSION)
-		sci_rnc->destination_state
-			= SCIC_SDS_REMOTE_NODE_DESTINATION_STATE_UNSPECIFIED;
+	if ((suspend_reason != SCI_SOFTWARE_SUSPENSION) ||
+	    (sci_rnc->destination_state == RNC_DEST_FINAL))
+		dest_param = sci_rnc->destination_state;
+
 	switch (state) {
+	case SCI_RNC_RESUMING:
+		break;  /* The RNC has been posted, so start the suspend. */
 	case SCI_RNC_READY:
 		break;
+	case SCI_RNC_INVALIDATING:
+		if (sci_rnc->destination_state == RNC_DEST_FINAL) {
+			dev_warn(scirdev_to_dev(idev),
+				 "%s: already destroying %p\n",
+				 __func__, sci_rnc);
+			return SCI_FAILURE_INVALID_STATE;
+		}
+		/* Fall through and handle like SCI_RNC_POSTING */
+	case SCI_RNC_POSTING:
+		/* Set the destination state to AWAIT - this signals the
+		 * entry into the SCI_RNC_READY state that a suspension
+		 * needs to be done immediately.
+		 */
+		sci_rnc->destination_state = RNC_DEST_SUSPENDED;
+		return SCI_SUCCESS;
+
 	case SCI_RNC_TX_SUSPENDED:
 		if (suspend_type == SCU_EVENT_TL_RNC_SUSPEND_TX)
 			status = SCI_SUCCESS;
@@ -556,6 +600,7 @@ enum sci_status sci_remote_node_context_suspend(
 			 rnc_state_name(state));
 		return SCI_FAILURE_INVALID_STATE;
 	}
+	sci_rnc->destination_state = dest_param;
 	sci_rnc->user_callback = cb_fn;
 	sci_rnc->user_cookie   = cb_p;
 	sci_rnc->suspend_type  = suspend_type;
@@ -590,18 +635,31 @@ enum sci_status sci_remote_node_context_resume(struct sci_remote_node_context *s
 		if (sci_rnc->remote_node_index == SCIC_SDS_REMOTE_NODE_CONTEXT_INVALID_INDEX)
 			return SCI_FAILURE_INVALID_STATE;
 
-		sci_remote_node_context_setup_to_resume(sci_rnc, cb_fn, cb_p);
+		sci_remote_node_context_setup_to_resume(sci_rnc, cb_fn, cb_p,
+							RNC_DEST_READY);
 		sci_remote_node_context_construct_buffer(sci_rnc);
 		sci_change_state(&sci_rnc->sm, SCI_RNC_POSTING);
 		return SCI_SUCCESS;
 	case SCI_RNC_POSTING:
 	case SCI_RNC_INVALIDATING:
 	case SCI_RNC_RESUMING:
-		if (sci_rnc->destination_state != SCIC_SDS_REMOTE_NODE_DESTINATION_STATE_READY)
-			return SCI_FAILURE_INVALID_STATE;
-
-		sci_rnc->user_callback = cb_fn;
-		sci_rnc->user_cookie   = cb_p;
+		/* We are still waiting to post when a resume was requested. */
+		switch (sci_rnc->destination_state) {
+		case RNC_DEST_SUSPENDED:
+		case RNC_DEST_SUSPENDED_RESUME:
+			/* Previously waiting to suspend after posting.  Now
+			 * continue onto resumption.
+			 */
+			sci_remote_node_context_setup_to_resume(
+				sci_rnc, cb_fn, cb_p,
+				RNC_DEST_SUSPENDED_RESUME);
+			break;
+		default:
+			sci_remote_node_context_setup_to_resume(
+				sci_rnc, cb_fn, cb_p,
+				RNC_DEST_READY);
+			break;
+		}
 		return SCI_SUCCESS;
 	case SCI_RNC_TX_SUSPENDED:
 	case SCI_RNC_TX_RX_SUSPENDED: {
@@ -613,7 +671,8 @@ enum sci_status sci_remote_node_context_resume(struct sci_remote_node_context *s
 		 * to clear the TCi to NCQ tag mapping table for the RNi.
 		 * All other device types we can just resume.
 		 */
-		sci_remote_node_context_setup_to_resume(sci_rnc, cb_fn, cb_p);
+		sci_remote_node_context_setup_to_resume(sci_rnc, cb_fn, cb_p,
+							RNC_DEST_READY);
 
 		if (dev_is_sata(dev) && dev->parent)
 			sci_change_state(&sci_rnc->sm, SCI_RNC_INVALIDATING);
@@ -622,7 +681,9 @@ enum sci_status sci_remote_node_context_resume(struct sci_remote_node_context *s
 		return SCI_SUCCESS;
 	}
 	case SCI_RNC_AWAIT_SUSPENSION:
-		sci_remote_node_context_setup_to_resume(sci_rnc, cb_fn, cb_p);
+		sci_remote_node_context_setup_to_resume(
+			sci_rnc, cb_fn, cb_p,
+			RNC_DEST_SUSPENDED_RESUME);
 		return SCI_SUCCESS;
 	default:
 		dev_warn(scirdev_to_dev(rnc_to_dev(sci_rnc)),
@@ -663,24 +724,12 @@ enum sci_status sci_remote_node_context_start_task(
 	scics_sds_remote_node_context_callback cb_fn,
 	void *cb_p)
 {
-	enum scis_sds_remote_node_context_states state;
-
-	state = sci_rnc->sm.current_state_id;
-	switch (state) {
-	case SCI_RNC_RESUMING:
-	case SCI_RNC_READY:
-	case SCI_RNC_AWAIT_SUSPENSION:
-		return SCI_SUCCESS;
-	case SCI_RNC_TX_SUSPENDED:
-	case SCI_RNC_TX_RX_SUSPENDED:
-		sci_remote_node_context_resume(sci_rnc, cb_fn, cb_p);
-		return SCI_SUCCESS;
-	default:
+	enum sci_status status = sci_remote_node_context_resume(sci_rnc,
+								cb_fn, cb_p);
+	if (status != SCI_SUCCESS)
 		dev_warn(scirdev_to_dev(rnc_to_dev(sci_rnc)),
-			"%s: invalid state %s\n", __func__,
-			rnc_state_name(state));
-		return SCI_FAILURE_INVALID_STATE;
-	}
+			"%s: resume failed: %d\n", __func__, status);
+	return status;
 }
 
 int sci_remote_node_context_is_safe_to_abort(

commit 14aaa9f0a318bd04cbb9d822524b817e95d8b343
Author: Jeff Skirvin <jeffrey.d.skirvin@intel.com>
Date:   Thu Mar 8 22:41:54 2012 -0800

    isci: Redesign device suspension, abort, cleanup.
    
    This commit changes the means by which outstanding I/Os are handled
    for cleanup.
    The likelihood is that this commit will be broken into smaller pieces,
    however that will be a later revision.  Among the changes:
    
    - All completion structures have been removed from the tmf and
    abort paths.
    - Now using one completed I/O list, with the I/O completed in host bit being
    used to select error or normal callback paths.
    
    Signed-off-by: Jeff Skirvin <jeffrey.d.skirvin@intel.com>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/drivers/scsi/isci/remote_node_context.c b/drivers/scsi/isci/remote_node_context.c
index 7a8347e51767..feeca17f0f13 100644
--- a/drivers/scsi/isci/remote_node_context.c
+++ b/drivers/scsi/isci/remote_node_context.c
@@ -317,8 +317,6 @@ static void sci_remote_node_context_tx_rx_suspended_state_enter(struct sci_base_
 	struct isci_remote_device *idev = rnc_to_dev(rnc);
 	struct isci_host *ihost = idev->owning_port->owning_controller;
 
-	set_bit(IDEV_TXRX_SUSPENDED, &idev->flags);
-
 	/* Terminate outstanding requests pending abort. */
 	sci_remote_device_abort_requests_pending_abort(idev);
 
@@ -326,16 +324,6 @@ static void sci_remote_node_context_tx_rx_suspended_state_enter(struct sci_base_
 	sci_remote_node_context_continue_state_transitions(rnc);
 }
 
-static void sci_remote_node_context_tx_rx_suspended_state_exit(
-	struct sci_base_state_machine *sm)
-{
-	struct sci_remote_node_context *rnc
-		= container_of(sm, typeof(*rnc), sm);
-	struct isci_remote_device *idev = rnc_to_dev(rnc);
-
-	clear_bit(IDEV_TXRX_SUSPENDED, &idev->flags);
-}
-
 static void sci_remote_node_context_await_suspend_state_exit(
 	struct sci_base_state_machine *sm)
 {
@@ -366,8 +354,6 @@ static const struct sci_base_state sci_remote_node_context_state_table[] = {
 	},
 	[SCI_RNC_TX_RX_SUSPENDED] = {
 		.enter_state = sci_remote_node_context_tx_rx_suspended_state_enter,
-		.exit_state
-			= sci_remote_node_context_tx_rx_suspended_state_exit,
 	},
 	[SCI_RNC_AWAIT_SUSPENSION] = {
 		.exit_state = sci_remote_node_context_await_suspend_state_exit,
@@ -671,8 +657,11 @@ enum sci_status sci_remote_node_context_start_io(struct sci_remote_node_context
 	}
 }
 
-enum sci_status sci_remote_node_context_start_task(struct sci_remote_node_context *sci_rnc,
-							struct isci_request *ireq)
+enum sci_status sci_remote_node_context_start_task(
+	struct sci_remote_node_context *sci_rnc,
+	struct isci_request *ireq,
+	scics_sds_remote_node_context_callback cb_fn,
+	void *cb_p)
 {
 	enum scis_sds_remote_node_context_states state;
 
@@ -684,7 +673,7 @@ enum sci_status sci_remote_node_context_start_task(struct sci_remote_node_contex
 		return SCI_SUCCESS;
 	case SCI_RNC_TX_SUSPENDED:
 	case SCI_RNC_TX_RX_SUSPENDED:
-		sci_remote_node_context_resume(sci_rnc, NULL, NULL);
+		sci_remote_node_context_resume(sci_rnc, cb_fn, cb_p);
 		return SCI_SUCCESS;
 	default:
 		dev_warn(scirdev_to_dev(rnc_to_dev(sci_rnc)),

commit 726980d56908f2e230624394f03743689db3110c
Author: Jeff Skirvin <jeffrey.d.skirvin@intel.com>
Date:   Thu Mar 8 22:41:50 2012 -0800

    isci: Terminate outstanding TCs on TX/RX RNC suspensions.
    
    TCs must only be terminated when RNCs are suspended.
    
    Signed-off-by: Jeff Skirvin <jeffrey.d.skirvin@intel.com>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/drivers/scsi/isci/remote_node_context.c b/drivers/scsi/isci/remote_node_context.c
index f180c726c5bb..7a8347e51767 100644
--- a/drivers/scsi/isci/remote_node_context.c
+++ b/drivers/scsi/isci/remote_node_context.c
@@ -268,6 +268,8 @@ static void sci_remote_node_context_invalidating_state_enter(struct sci_base_sta
 {
 	struct sci_remote_node_context *rnc = container_of(sm, typeof(*rnc), sm);
 
+	/* Terminate outstanding requests pending abort. */
+	sci_remote_device_abort_requests_pending_abort(rnc_to_dev(rnc));
 	sci_remote_node_context_invalidate_context_buffer(rnc);
 }
 
@@ -312,10 +314,28 @@ static void sci_remote_node_context_tx_suspended_state_enter(struct sci_base_sta
 static void sci_remote_node_context_tx_rx_suspended_state_enter(struct sci_base_state_machine *sm)
 {
 	struct sci_remote_node_context *rnc = container_of(sm, typeof(*rnc), sm);
+	struct isci_remote_device *idev = rnc_to_dev(rnc);
+	struct isci_host *ihost = idev->owning_port->owning_controller;
+
+	set_bit(IDEV_TXRX_SUSPENDED, &idev->flags);
 
+	/* Terminate outstanding requests pending abort. */
+	sci_remote_device_abort_requests_pending_abort(idev);
+
+	wake_up(&ihost->eventq);
 	sci_remote_node_context_continue_state_transitions(rnc);
 }
 
+static void sci_remote_node_context_tx_rx_suspended_state_exit(
+	struct sci_base_state_machine *sm)
+{
+	struct sci_remote_node_context *rnc
+		= container_of(sm, typeof(*rnc), sm);
+	struct isci_remote_device *idev = rnc_to_dev(rnc);
+
+	clear_bit(IDEV_TXRX_SUSPENDED, &idev->flags);
+}
+
 static void sci_remote_node_context_await_suspend_state_exit(
 	struct sci_base_state_machine *sm)
 {
@@ -346,6 +366,8 @@ static const struct sci_base_state sci_remote_node_context_state_table[] = {
 	},
 	[SCI_RNC_TX_RX_SUSPENDED] = {
 		.enter_state = sci_remote_node_context_tx_rx_suspended_state_enter,
+		.exit_state
+			= sci_remote_node_context_tx_rx_suspended_state_exit,
 	},
 	[SCI_RNC_AWAIT_SUSPENSION] = {
 		.exit_state = sci_remote_node_context_await_suspend_state_exit,
@@ -515,6 +537,13 @@ enum sci_status sci_remote_node_context_suspend(
 	struct isci_remote_device *idev = rnc_to_dev(sci_rnc);
 	enum sci_status status = SCI_FAILURE_INVALID_STATE;
 
+	dev_dbg(scirdev_to_dev(idev),
+		"%s: current state %d, current suspend_type %x dest state %d,"
+			" arg suspend_reason %d, arg suspend_type %x",
+		__func__, state, sci_rnc->suspend_type,
+		sci_rnc->destination_state, suspend_reason,
+		suspend_type);
+
 	/* Disable automatic state continuations if explicitly suspending. */
 	if (suspend_reason == SCI_SOFTWARE_SUSPENSION)
 		sci_rnc->destination_state
@@ -546,7 +575,10 @@ enum sci_status sci_remote_node_context_suspend(
 	sci_rnc->suspend_type  = suspend_type;
 
 	if (status == SCI_SUCCESS) { /* Already in the destination state? */
+		struct isci_host *ihost = idev->owning_port->owning_controller;
+
 		sci_remote_node_context_notify_user(sci_rnc);
+		wake_up_all(&ihost->eventq); /* Let observers look. */
 		return SCI_SUCCESS;
 	}
 	if (suspend_reason == SCI_SOFTWARE_SUSPENSION) {
@@ -661,3 +693,27 @@ enum sci_status sci_remote_node_context_start_task(struct sci_remote_node_contex
 		return SCI_FAILURE_INVALID_STATE;
 	}
 }
+
+int sci_remote_node_context_is_safe_to_abort(
+	struct sci_remote_node_context *sci_rnc)
+{
+	enum scis_sds_remote_node_context_states state;
+
+	state = sci_rnc->sm.current_state_id;
+	switch (state) {
+	case SCI_RNC_INVALIDATING:
+	case SCI_RNC_TX_RX_SUSPENDED:
+		return 1;
+	case SCI_RNC_POSTING:
+	case SCI_RNC_RESUMING:
+	case SCI_RNC_READY:
+	case SCI_RNC_TX_SUSPENDED:
+	case SCI_RNC_AWAIT_SUSPENSION:
+	case SCI_RNC_INITIAL:
+		return 0;
+	default:
+		dev_warn(scirdev_to_dev(rnc_to_dev(sci_rnc)),
+			 "%s: invalid state %d\n", __func__, state);
+		return 0;
+	}
+}

commit ac78ed0f78eae5c3c918e132b5e2029cdc4fdedc
Author: Jeff Skirvin <jeffrey.d.skirvin@intel.com>
Date:   Thu Mar 8 22:41:50 2012 -0800

    isci: Handle all suspending TC completions
    
    Add comprehensive decode for all TC completions that generate RNC
    suspensions.
    
    Note that this commit also removes unconditional resumptions of ATAPI
    devices when in the SCI_STP_DEV_ATAPI_ERROR state, and STP devices
    when in the SCI_STP_DEV_IDLE state. This is because the SCI_STP_DEV_IDLE
    and SCI_STP_DEV_ATAPI state entry functions manage the RNC resumption.
    
    Signed-off-by: Jeff Skirvin <jeffrey.d.skirvin@intel.com>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/drivers/scsi/isci/remote_node_context.c b/drivers/scsi/isci/remote_node_context.c
index 3e849752bffa..f180c726c5bb 100644
--- a/drivers/scsi/isci/remote_node_context.c
+++ b/drivers/scsi/isci/remote_node_context.c
@@ -367,6 +367,7 @@ enum sci_status sci_remote_node_context_event_handler(struct sci_remote_node_con
 							   u32 event_code)
 {
 	enum scis_sds_remote_node_context_states state;
+	u32 next_state;
 
 	state = sci_rnc->sm.current_state_id;
 	switch (state) {
@@ -425,11 +426,11 @@ enum sci_status sci_remote_node_context_event_handler(struct sci_remote_node_con
 		switch (scu_get_event_type(event_code)) {
 		case SCU_EVENT_TL_RNC_SUSPEND_TX:
 			sci_change_state(&sci_rnc->sm, SCI_RNC_TX_SUSPENDED);
-			sci_rnc->suspension_code = scu_get_event_specifier(event_code);
+			sci_rnc->suspend_type = scu_get_event_type(event_code);
 			break;
 		case SCU_EVENT_TL_RNC_SUSPEND_TX_RX:
 			sci_change_state(&sci_rnc->sm, SCI_RNC_TX_RX_SUSPENDED);
-			sci_rnc->suspension_code = scu_get_event_specifier(event_code);
+			sci_rnc->suspend_type = scu_get_event_type(event_code);
 			break;
 		default:
 			goto out;
@@ -438,16 +439,16 @@ enum sci_status sci_remote_node_context_event_handler(struct sci_remote_node_con
 	case SCI_RNC_AWAIT_SUSPENSION:
 		switch (scu_get_event_type(event_code)) {
 		case SCU_EVENT_TL_RNC_SUSPEND_TX:
-			sci_change_state(&sci_rnc->sm, SCI_RNC_TX_SUSPENDED);
-			sci_rnc->suspension_code = scu_get_event_specifier(event_code);
+			next_state = SCI_RNC_TX_SUSPENDED;
 			break;
 		case SCU_EVENT_TL_RNC_SUSPEND_TX_RX:
-			sci_change_state(&sci_rnc->sm, SCI_RNC_TX_RX_SUSPENDED);
-			sci_rnc->suspension_code = scu_get_event_specifier(event_code);
+			next_state = SCI_RNC_TX_RX_SUSPENDED;
 			break;
 		default:
 			goto out;
 		}
+		if (sci_rnc->suspend_type == scu_get_event_type(event_code))
+			sci_change_state(&sci_rnc->sm, next_state);
 		break;
 	default:
 		dev_warn(scirdev_to_dev(rnc_to_dev(sci_rnc)),
@@ -502,33 +503,60 @@ enum sci_status sci_remote_node_context_destruct(struct sci_remote_node_context
 	}
 }
 
-enum sci_status sci_remote_node_context_suspend(struct sci_remote_node_context *sci_rnc,
-						     u32 suspend_type,
-						     scics_sds_remote_node_context_callback cb_fn,
-						     void *cb_p)
+enum sci_status sci_remote_node_context_suspend(
+			struct sci_remote_node_context *sci_rnc,
+			enum sci_remote_node_suspension_reasons suspend_reason,
+			u32 suspend_type,
+			scics_sds_remote_node_context_callback cb_fn,
+			void *cb_p)
 {
-	enum scis_sds_remote_node_context_states state;
+	enum scis_sds_remote_node_context_states state
+		= sci_rnc->sm.current_state_id;
+	struct isci_remote_device *idev = rnc_to_dev(sci_rnc);
+	enum sci_status status = SCI_FAILURE_INVALID_STATE;
 
-	state = sci_rnc->sm.current_state_id;
-	if (state != SCI_RNC_READY) {
+	/* Disable automatic state continuations if explicitly suspending. */
+	if (suspend_reason == SCI_SOFTWARE_SUSPENSION)
+		sci_rnc->destination_state
+			= SCIC_SDS_REMOTE_NODE_DESTINATION_STATE_UNSPECIFIED;
+	switch (state) {
+	case SCI_RNC_READY:
+		break;
+	case SCI_RNC_TX_SUSPENDED:
+		if (suspend_type == SCU_EVENT_TL_RNC_SUSPEND_TX)
+			status = SCI_SUCCESS;
+		break;
+	case SCI_RNC_TX_RX_SUSPENDED:
+		if (suspend_type == SCU_EVENT_TL_RNC_SUSPEND_TX_RX)
+			status = SCI_SUCCESS;
+		break;
+	case SCI_RNC_AWAIT_SUSPENSION:
+		if ((sci_rnc->suspend_type == SCU_EVENT_TL_RNC_SUSPEND_TX_RX)
+		    || (suspend_type == sci_rnc->suspend_type))
+			return SCI_SUCCESS;
+		break;
+	default:
 		dev_warn(scirdev_to_dev(rnc_to_dev(sci_rnc)),
 			 "%s: invalid state %s\n", __func__,
 			 rnc_state_name(state));
 		return SCI_FAILURE_INVALID_STATE;
 	}
+	sci_rnc->user_callback = cb_fn;
+	sci_rnc->user_cookie   = cb_p;
+	sci_rnc->suspend_type  = suspend_type;
 
-	sci_rnc->user_callback   = cb_fn;
-	sci_rnc->user_cookie     = cb_p;
-	sci_rnc->suspension_code = suspend_type;
-
-	if (suspend_type == SCI_SOFTWARE_SUSPENSION) {
-		sci_remote_device_post_request(rnc_to_dev(sci_rnc),
-						    SCU_CONTEXT_COMMAND_POST_RNC_SUSPEND_TX);
-		isci_dev_set_hang_detection_timeout(rnc_to_dev(sci_rnc),
-						    0x00000001);
+	if (status == SCI_SUCCESS) { /* Already in the destination state? */
+		sci_remote_node_context_notify_user(sci_rnc);
+		return SCI_SUCCESS;
+	}
+	if (suspend_reason == SCI_SOFTWARE_SUSPENSION) {
+		isci_dev_set_hang_detection_timeout(idev, 0x00000001);
+		sci_remote_device_post_request(
+			idev, SCI_SOFTWARE_SUSPEND_CMD);
 	}
+	if (state != SCI_RNC_AWAIT_SUSPENSION)
+		sci_change_state(&sci_rnc->sm, SCI_RNC_AWAIT_SUSPENSION);
 
-	sci_change_state(&sci_rnc->sm, SCI_RNC_AWAIT_SUSPENSION);
 	return SCI_SUCCESS;
 }
 

commit 56d7c013e714c6feab2ab5ac854808e29048b069
Author: Jeff Skirvin <jeffrey.d.skirvin@intel.com>
Date:   Thu Mar 8 22:41:49 2012 -0800

    isci: Fixed bug in resumption from RNC Tx/Rx suspend state.
    
    The resumption from the Tx/Rx suspended state should work the same
    as the Tx suspended state.
    
    Signed-off-by: Jeff Skirvin <jeffrey.d.skirvin@intel.com>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/drivers/scsi/isci/remote_node_context.c b/drivers/scsi/isci/remote_node_context.c
index 3a55ba66b8ac..3e849752bffa 100644
--- a/drivers/scsi/isci/remote_node_context.c
+++ b/drivers/scsi/isci/remote_node_context.c
@@ -557,10 +557,16 @@ enum sci_status sci_remote_node_context_resume(struct sci_remote_node_context *s
 		sci_rnc->user_callback = cb_fn;
 		sci_rnc->user_cookie   = cb_p;
 		return SCI_SUCCESS;
-	case SCI_RNC_TX_SUSPENDED: {
+	case SCI_RNC_TX_SUSPENDED:
+	case SCI_RNC_TX_RX_SUSPENDED: {
 		struct isci_remote_device *idev = rnc_to_dev(sci_rnc);
 		struct domain_device *dev = idev->domain_dev;
 
+		/* If this is an expander attached SATA device we must
+		 * invalidate and repost the RNC since this is the only way
+		 * to clear the TCi to NCQ tag mapping table for the RNi.
+		 * All other device types we can just resume.
+		 */
 		sci_remote_node_context_setup_to_resume(sci_rnc, cb_fn, cb_p);
 
 		if (dev_is_sata(dev) && dev->parent)
@@ -569,10 +575,6 @@ enum sci_status sci_remote_node_context_resume(struct sci_remote_node_context *s
 			sci_change_state(&sci_rnc->sm, SCI_RNC_RESUMING);
 		return SCI_SUCCESS;
 	}
-	case SCI_RNC_TX_RX_SUSPENDED:
-		sci_remote_node_context_setup_to_resume(sci_rnc, cb_fn, cb_p);
-		sci_change_state(&sci_rnc->sm, SCI_RNC_RESUMING);
-		return SCI_FAILURE_INVALID_STATE;
 	case SCI_RNC_AWAIT_SUSPENSION:
 		sci_remote_node_context_setup_to_resume(sci_rnc, cb_fn, cb_p);
 		return SCI_SUCCESS;

commit 6f48844e3f16b7d8a1f9a1a11bd9a11089a5292f
Author: Jeff Skirvin <jeffrey.d.skirvin@intel.com>
Date:   Thu Mar 8 22:41:48 2012 -0800

    isci: Manage the link layer hang detect timer for RNC suspensions.
    
    For STP devices under certain protocol conditions, an RNC will not
    suspend until the current transfer state is broken with a SYNC/ESC
    sequence from the SCU.  The SYNC/ESC driven by expiration of the
    SCU link layer hang detect timer, which has too small a dynamic
    range to support slow SATA devices, so normally it is disabled.
    
    This change enables the timer with the minimum period at the point
    when the suspension is requested.
    
    Note that there is potential collateral damage to other open
    connections to slow SATA devices on the same port, since there
    is no alternative but to enable the LLHANG timer on every phy in
    the port for the current suspension request - there is no way to
    tell on which phy the RNC in question is currently active.
    
    Signed-off-by: Jeff Skirvin <jeffrey.d.skirvin@intel.com>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/drivers/scsi/isci/remote_node_context.c b/drivers/scsi/isci/remote_node_context.c
index 8ce5a35891e1..3a55ba66b8ac 100644
--- a/drivers/scsi/isci/remote_node_context.c
+++ b/drivers/scsi/isci/remote_node_context.c
@@ -316,6 +316,15 @@ static void sci_remote_node_context_tx_rx_suspended_state_enter(struct sci_base_
 	sci_remote_node_context_continue_state_transitions(rnc);
 }
 
+static void sci_remote_node_context_await_suspend_state_exit(
+	struct sci_base_state_machine *sm)
+{
+	struct sci_remote_node_context *rnc
+		= container_of(sm, typeof(*rnc), sm);
+
+	isci_dev_set_hang_detection_timeout(rnc_to_dev(rnc), 0);
+}
+
 static const struct sci_base_state sci_remote_node_context_state_table[] = {
 	[SCI_RNC_INITIAL] = {
 		.enter_state = sci_remote_node_context_initial_state_enter,
@@ -338,7 +347,9 @@ static const struct sci_base_state sci_remote_node_context_state_table[] = {
 	[SCI_RNC_TX_RX_SUSPENDED] = {
 		.enter_state = sci_remote_node_context_tx_rx_suspended_state_enter,
 	},
-	[SCI_RNC_AWAIT_SUSPENSION] = { },
+	[SCI_RNC_AWAIT_SUSPENSION] = {
+		.exit_state = sci_remote_node_context_await_suspend_state_exit,
+	},
 };
 
 void sci_remote_node_context_construct(struct sci_remote_node_context *rnc,
@@ -513,6 +524,8 @@ enum sci_status sci_remote_node_context_suspend(struct sci_remote_node_context *
 	if (suspend_type == SCI_SOFTWARE_SUSPENSION) {
 		sci_remote_device_post_request(rnc_to_dev(sci_rnc),
 						    SCU_CONTEXT_COMMAND_POST_RNC_SUSPEND_TX);
+		isci_dev_set_hang_detection_timeout(rnc_to_dev(sci_rnc),
+						    0x00000001);
 	}
 
 	sci_change_state(&sci_rnc->sm, SCI_RNC_AWAIT_SUSPENSION);

commit 11cc51835af0e6fbb2da9cb012bdaaa036497b7f
Author: Dan Williams <dan.j.williams@intel.com>
Date:   Wed Feb 1 00:23:10 2012 -0800

    isci: kill ->is_direct_attached
    
    domain_device ->parent conveys the same information.
    
    Occurrences of ->is_direct_attached appear next to incomplete open-coded
    versions of dev_is_sata(), clean those up as well.
    
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/drivers/scsi/isci/remote_node_context.c b/drivers/scsi/isci/remote_node_context.c
index 994ec0c25a74..8ce5a35891e1 100644
--- a/drivers/scsi/isci/remote_node_context.c
+++ b/drivers/scsi/isci/remote_node_context.c
@@ -131,7 +131,7 @@ static void sci_remote_node_context_construct_buffer(struct sci_remote_node_cont
 
 	rnc->ssp.arbitration_wait_time = 0;
 
-	if (dev->dev_type == SATA_DEV || (dev->tproto & SAS_PROTOCOL_STP)) {
+	if (dev_is_sata(dev)) {
 		rnc->ssp.connection_occupancy_timeout =
 			ihost->user_parameters.stp_max_occupancy_timeout;
 		rnc->ssp.connection_inactivity_timeout =
@@ -219,13 +219,12 @@ static void sci_remote_node_context_validate_context_buffer(struct sci_remote_no
 
 	rnc_buffer->ssp.is_valid = true;
 
-	if (!idev->is_direct_attached &&
-	    (dev->dev_type == SATA_DEV || (dev->tproto & SAS_PROTOCOL_STP))) {
+	if (dev_is_sata(dev) && dev->parent) {
 		sci_remote_device_post_request(idev, SCU_CONTEXT_COMMAND_POST_RNC_96);
 	} else {
 		sci_remote_device_post_request(idev, SCU_CONTEXT_COMMAND_POST_RNC_32);
 
-		if (idev->is_direct_attached)
+		if (!dev->parent)
 			sci_port_setup_transports(idev->owning_port,
 						  sci_rnc->remote_node_index);
 	}
@@ -287,10 +286,8 @@ static void sci_remote_node_context_resuming_state_enter(struct sci_base_state_m
 	 * resume because of a target reset we also need to update
 	 * the STPTLDARNI register with the RNi of the device
 	 */
-	if ((dev->dev_type == SATA_DEV || (dev->tproto & SAS_PROTOCOL_STP)) &&
-	    idev->is_direct_attached)
-		sci_port_setup_transports(idev->owning_port,
-					       rnc->remote_node_index);
+	if (dev_is_sata(dev) && !dev->parent)
+		sci_port_setup_transports(idev->owning_port, rnc->remote_node_index);
 
 	sci_remote_device_post_request(idev, SCU_CONTEXT_COMMAND_POST_RNC_RESUME);
 }
@@ -553,18 +550,10 @@ enum sci_status sci_remote_node_context_resume(struct sci_remote_node_context *s
 
 		sci_remote_node_context_setup_to_resume(sci_rnc, cb_fn, cb_p);
 
-		/* TODO: consider adding a resume action of NONE, INVALIDATE, WRITE_TLCR */
-		if (dev->dev_type == SAS_END_DEV || dev_is_expander(dev))
+		if (dev_is_sata(dev) && dev->parent)
+			sci_change_state(&sci_rnc->sm, SCI_RNC_INVALIDATING);
+		else
 			sci_change_state(&sci_rnc->sm, SCI_RNC_RESUMING);
-		else if (dev->dev_type == SATA_DEV || (dev->tproto & SAS_PROTOCOL_STP)) {
-			if (idev->is_direct_attached) {
-				/* @todo Fix this since I am being silly in writing to the STPTLDARNI register. */
-				sci_change_state(&sci_rnc->sm, SCI_RNC_RESUMING);
-			} else {
-				sci_change_state(&sci_rnc->sm, SCI_RNC_INVALIDATING);
-			}
-		} else
-			return SCI_FAILURE;
 		return SCI_SUCCESS;
 	}
 	case SCI_RNC_TX_RX_SUSPENDED:

commit 14e99b4a3f5323bb961754de5024daff79e59b98
Author: Dan Williams <dan.j.williams@intel.com>
Date:   Fri Feb 10 01:05:43 2012 -0800

    isci: improve 'invalid state' warnings
    
    Convert controller state machine warnings to emit the state number (it
    missed the number to string conversion, but since these error rarely
    happen not much motivation to go further).
    
    Fix up the rnc warnings to use the state name.
    
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/drivers/scsi/isci/remote_node_context.c b/drivers/scsi/isci/remote_node_context.c
index 3a9463481f38..994ec0c25a74 100644
--- a/drivers/scsi/isci/remote_node_context.c
+++ b/drivers/scsi/isci/remote_node_context.c
@@ -443,14 +443,16 @@ enum sci_status sci_remote_node_context_event_handler(struct sci_remote_node_con
 		break;
 	default:
 		dev_warn(scirdev_to_dev(rnc_to_dev(sci_rnc)),
-			 "%s: invalid state %d\n", __func__, state);
+			 "%s: invalid state: %s\n", __func__,
+			 rnc_state_name(state));
 		return SCI_FAILURE_INVALID_STATE;
 	}
 	return SCI_SUCCESS;
 
  out:
 	dev_warn(scirdev_to_dev(rnc_to_dev(sci_rnc)),
-		 "%s: code: %#x state: %d\n", __func__, event_code, state);
+		 "%s: code: %#x state: %s\n", __func__, event_code,
+		 rnc_state_name(state));
 	return SCI_FAILURE;
 
 }
@@ -477,7 +479,8 @@ enum sci_status sci_remote_node_context_destruct(struct sci_remote_node_context
 		return SCI_SUCCESS;
 	case SCI_RNC_INITIAL:
 		dev_warn(scirdev_to_dev(rnc_to_dev(sci_rnc)),
-			 "%s: invalid state %d\n", __func__, state);
+			 "%s: invalid state: %s\n", __func__,
+			 rnc_state_name(state));
 		/* We have decided that the destruct request on the remote node context
 		 * can not fail since it is either in the initial/destroyed state or is
 		 * can be destroyed.
@@ -485,7 +488,8 @@ enum sci_status sci_remote_node_context_destruct(struct sci_remote_node_context
 		return SCI_SUCCESS;
 	default:
 		dev_warn(scirdev_to_dev(rnc_to_dev(sci_rnc)),
-			 "%s: invalid state %d\n", __func__, state);
+			 "%s: invalid state %s\n", __func__,
+			 rnc_state_name(state));
 		return SCI_FAILURE_INVALID_STATE;
 	}
 }
@@ -500,7 +504,8 @@ enum sci_status sci_remote_node_context_suspend(struct sci_remote_node_context *
 	state = sci_rnc->sm.current_state_id;
 	if (state != SCI_RNC_READY) {
 		dev_warn(scirdev_to_dev(rnc_to_dev(sci_rnc)),
-			 "%s: invalid state %d\n", __func__, state);
+			 "%s: invalid state %s\n", __func__,
+			 rnc_state_name(state));
 		return SCI_FAILURE_INVALID_STATE;
 	}
 
@@ -571,7 +576,8 @@ enum sci_status sci_remote_node_context_resume(struct sci_remote_node_context *s
 		return SCI_SUCCESS;
 	default:
 		dev_warn(scirdev_to_dev(rnc_to_dev(sci_rnc)),
-			 "%s: invalid state %d\n", __func__, state);
+			 "%s: invalid state %s\n", __func__,
+			 rnc_state_name(state));
 		return SCI_FAILURE_INVALID_STATE;
 	}
 }
@@ -590,15 +596,15 @@ enum sci_status sci_remote_node_context_start_io(struct sci_remote_node_context
 	case SCI_RNC_TX_RX_SUSPENDED:
 	case SCI_RNC_AWAIT_SUSPENSION:
 		dev_warn(scirdev_to_dev(rnc_to_dev(sci_rnc)),
-			 "%s: invalid state %d\n", __func__, state);
+			 "%s: invalid state %s\n", __func__,
+			 rnc_state_name(state));
 		return SCI_FAILURE_REMOTE_DEVICE_RESET_REQUIRED;
 	default:
-		break;
+		dev_dbg(scirdev_to_dev(rnc_to_dev(sci_rnc)),
+			"%s: invalid state %s\n", __func__,
+			rnc_state_name(state));
+		return SCI_FAILURE_INVALID_STATE;
 	}
-	dev_dbg(scirdev_to_dev(rnc_to_dev(sci_rnc)),
-		"%s: requested to start IO while still resuming, %d\n",
-		__func__, state);
-	return SCI_FAILURE_INVALID_STATE;
 }
 
 enum sci_status sci_remote_node_context_start_task(struct sci_remote_node_context *sci_rnc,
@@ -618,7 +624,8 @@ enum sci_status sci_remote_node_context_start_task(struct sci_remote_node_contex
 		return SCI_SUCCESS;
 	default:
 		dev_warn(scirdev_to_dev(rnc_to_dev(sci_rnc)),
-			 "%s: invalid state %d\n", __func__, state);
+			"%s: invalid state %s\n", __func__,
+			rnc_state_name(state));
 		return SCI_FAILURE_INVALID_STATE;
 	}
 }

commit d7a0ccdd9bd78b5b74d2963ec7ab67c9d896902a
Author: Dan Williams <dan.j.williams@intel.com>
Date:   Fri Feb 10 01:18:44 2012 -0800

    [SCSI] isci: debug, provide state-enum-to-string conversions
    
    Debugging the driver requires tracing the state transtions and tracing
    state names is less work than decoding numbers.
    
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>
    Signed-off-by: James Bottomley <JBottomley@Parallels.com>

diff --git a/drivers/scsi/isci/remote_node_context.c b/drivers/scsi/isci/remote_node_context.c
index 748e8339d1ec..3a9463481f38 100644
--- a/drivers/scsi/isci/remote_node_context.c
+++ b/drivers/scsi/isci/remote_node_context.c
@@ -60,18 +60,15 @@
 #include "scu_event_codes.h"
 #include "scu_task_context.h"
 
+#undef C
+#define C(a) (#a)
+const char *rnc_state_name(enum scis_sds_remote_node_context_states state)
+{
+	static const char * const strings[] = RNC_STATES;
 
-/**
- *
- * @sci_rnc: The RNC for which the is posted request is being made.
- *
- * This method will return true if the RNC is not in the initial state.  In all
- * other states the RNC is considered active and this will return true. The
- * destroy request of the state machine drives the RNC back to the initial
- * state.  If the state machine changes then this routine will also have to be
- * changed. bool true if the state machine is not in the initial state false if
- * the state machine is in the initial state
- */
+	return strings[state];
+}
+#undef C
 
 /**
  *

commit 34a991587a5cc9f78960c2c9beea217866458c41
Author: Dan Williams <dan.j.williams@intel.com>
Date:   Fri Jul 1 02:25:15 2011 -0700

    isci: kill 'get/set' macros
    
    Most of these simple dereference macros are longer than their open coded
    equivalent.  Deleting enum sci_controller_mode is thrown in for good
    measure.
    
    Reported-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/drivers/scsi/isci/remote_node_context.c b/drivers/scsi/isci/remote_node_context.c
index c2dfd5a72181..748e8339d1ec 100644
--- a/drivers/scsi/isci/remote_node_context.c
+++ b/drivers/scsi/isci/remote_node_context.c
@@ -111,7 +111,7 @@ static void sci_remote_node_context_construct_buffer(struct sci_remote_node_cont
 	struct isci_host *ihost;
 	__le64 sas_addr;
 
-	ihost = sci_remote_device_get_controller(idev);
+	ihost = idev->owning_port->owning_controller;
 	rnc = sci_rnc_by_id(ihost, rni);
 
 	memset(rnc, 0, sizeof(union scu_remote_node_context)

commit 89a7301f21fb00e753089671eb9e4132aab8ea08
Author: Dan Williams <dan.j.williams@intel.com>
Date:   Thu Jun 30 19:14:33 2011 -0700

    isci: retire scic_sds_ and scic_ prefixes
    
    The distinction between scic_sds_ scic_ and sci_ are no longer relevant
    so just unify the prefixes on sci_.  The distinction between isci_ and
    sci_ is historically significant, and useful for comparing the old
    'core' to the current Linux driver. 'sci_' represents the former core as
    well as the routines that are closer to the hardware and protocol than
    their 'isci_' brethren. sci == sas controller interface.
    
    Also unwind the 'sds1' out of the parameter structs.
    
    Reported-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/drivers/scsi/isci/remote_node_context.c b/drivers/scsi/isci/remote_node_context.c
index 8a5203b6eb09..c2dfd5a72181 100644
--- a/drivers/scsi/isci/remote_node_context.c
+++ b/drivers/scsi/isci/remote_node_context.c
@@ -81,8 +81,8 @@
  * otherwise it will return false bool true if the remote node context is in
  * the ready state. false if the remote node context is not in the ready state.
  */
-bool scic_sds_remote_node_context_is_ready(
-	struct scic_sds_remote_node_context *sci_rnc)
+bool sci_remote_node_context_is_ready(
+	struct sci_remote_node_context *sci_rnc)
 {
 	u32 current_state = sci_rnc->sm.current_state_id;
 
@@ -93,15 +93,16 @@ bool scic_sds_remote_node_context_is_ready(
 	return false;
 }
 
-/**
- *
- * @sci_dev: The remote device to use to construct the RNC buffer.
- * @rnc: The buffer into which the remote device data will be copied.
- *
- * This method will construct the RNC buffer for this remote device object. none
- */
-static void scic_sds_remote_node_context_construct_buffer(
-	struct scic_sds_remote_node_context *sci_rnc)
+static union scu_remote_node_context *sci_rnc_by_id(struct isci_host *ihost, u16 id)
+{
+	if (id < ihost->remote_node_entries &&
+	    ihost->device_table[id])
+		return &ihost->remote_node_context_table[id];
+
+	return NULL;
+}
+
+static void sci_remote_node_context_construct_buffer(struct sci_remote_node_context *sci_rnc)
 {
 	struct isci_remote_device *idev = rnc_to_dev(sci_rnc);
 	struct domain_device *dev = idev->domain_dev;
@@ -110,11 +111,11 @@ static void scic_sds_remote_node_context_construct_buffer(
 	struct isci_host *ihost;
 	__le64 sas_addr;
 
-	ihost = scic_sds_remote_device_get_controller(idev);
-	rnc = scic_sds_controller_get_remote_node_context_buffer(ihost, rni);
+	ihost = sci_remote_device_get_controller(idev);
+	rnc = sci_rnc_by_id(ihost, rni);
 
 	memset(rnc, 0, sizeof(union scu_remote_node_context)
-		* scic_sds_remote_device_node_count(idev));
+		* sci_remote_device_node_count(idev));
 
 	rnc->ssp.remote_node_index = rni;
 	rnc->ssp.remote_node_port_width = idev->device_port_width;
@@ -135,14 +136,14 @@ static void scic_sds_remote_node_context_construct_buffer(
 
 	if (dev->dev_type == SATA_DEV || (dev->tproto & SAS_PROTOCOL_STP)) {
 		rnc->ssp.connection_occupancy_timeout =
-			ihost->user_parameters.sds1.stp_max_occupancy_timeout;
+			ihost->user_parameters.stp_max_occupancy_timeout;
 		rnc->ssp.connection_inactivity_timeout =
-			ihost->user_parameters.sds1.stp_inactivity_timeout;
+			ihost->user_parameters.stp_inactivity_timeout;
 	} else {
 		rnc->ssp.connection_occupancy_timeout  =
-			ihost->user_parameters.sds1.ssp_max_occupancy_timeout;
+			ihost->user_parameters.ssp_max_occupancy_timeout;
 		rnc->ssp.connection_inactivity_timeout =
-			ihost->user_parameters.sds1.ssp_inactivity_timeout;
+			ihost->user_parameters.ssp_inactivity_timeout;
 	}
 
 	rnc->ssp.initial_arbitration_wait_time = 0;
@@ -164,8 +165,8 @@ static void scic_sds_remote_node_context_construct_buffer(
  * to its ready state.  If the remote node context is already setup to
  * transition to its final state then this function does nothing. none
  */
-static void scic_sds_remote_node_context_setup_to_resume(
-	struct scic_sds_remote_node_context *sci_rnc,
+static void sci_remote_node_context_setup_to_resume(
+	struct sci_remote_node_context *sci_rnc,
 	scics_sds_remote_node_context_callback callback,
 	void *callback_parameter)
 {
@@ -176,8 +177,8 @@ static void scic_sds_remote_node_context_setup_to_resume(
 	}
 }
 
-static void scic_sds_remote_node_context_setup_to_destory(
-	struct scic_sds_remote_node_context *sci_rnc,
+static void sci_remote_node_context_setup_to_destory(
+	struct sci_remote_node_context *sci_rnc,
 	scics_sds_remote_node_context_callback callback,
 	void *callback_parameter)
 {
@@ -192,8 +193,8 @@ static void scic_sds_remote_node_context_setup_to_destory(
  * This method just calls the user callback function and then resets the
  * callback.
  */
-static void scic_sds_remote_node_context_notify_user(
-	struct scic_sds_remote_node_context *rnc)
+static void sci_remote_node_context_notify_user(
+	struct sci_remote_node_context *rnc)
 {
 	if (rnc->user_callback != NULL) {
 		(*rnc->user_callback)(rnc->user_cookie);
@@ -203,99 +204,80 @@ static void scic_sds_remote_node_context_notify_user(
 	}
 }
 
-static void scic_sds_remote_node_context_continue_state_transitions(struct scic_sds_remote_node_context *rnc)
+static void sci_remote_node_context_continue_state_transitions(struct sci_remote_node_context *rnc)
 {
 	if (rnc->destination_state == SCIC_SDS_REMOTE_NODE_DESTINATION_STATE_READY)
-		scic_sds_remote_node_context_resume(rnc, rnc->user_callback,
+		sci_remote_node_context_resume(rnc, rnc->user_callback,
 						    rnc->user_cookie);
 }
 
-/**
- *
- * @sci_rnc: The remote node context object that is to be validated.
- *
- * This method will mark the rnc buffer as being valid and post the request to
- * the hardware. none
- */
-static void scic_sds_remote_node_context_validate_context_buffer(
-	struct scic_sds_remote_node_context *sci_rnc)
+static void sci_remote_node_context_validate_context_buffer(struct sci_remote_node_context *sci_rnc)
 {
+	union scu_remote_node_context *rnc_buffer;
 	struct isci_remote_device *idev = rnc_to_dev(sci_rnc);
 	struct domain_device *dev = idev->domain_dev;
-	union scu_remote_node_context *rnc_buffer;
+	struct isci_host *ihost = idev->owning_port->owning_controller;
 
-	rnc_buffer = scic_sds_controller_get_remote_node_context_buffer(
-		scic_sds_remote_device_get_controller(idev),
-		sci_rnc->remote_node_index
-		);
+	rnc_buffer = sci_rnc_by_id(ihost, sci_rnc->remote_node_index);
 
 	rnc_buffer->ssp.is_valid = true;
 
 	if (!idev->is_direct_attached &&
 	    (dev->dev_type == SATA_DEV || (dev->tproto & SAS_PROTOCOL_STP))) {
-		scic_sds_remote_device_post_request(idev,
-						    SCU_CONTEXT_COMMAND_POST_RNC_96);
+		sci_remote_device_post_request(idev, SCU_CONTEXT_COMMAND_POST_RNC_96);
 	} else {
-		scic_sds_remote_device_post_request(idev, SCU_CONTEXT_COMMAND_POST_RNC_32);
+		sci_remote_device_post_request(idev, SCU_CONTEXT_COMMAND_POST_RNC_32);
 
-		if (idev->is_direct_attached) {
-			scic_sds_port_setup_transports(idev->owning_port,
-						       sci_rnc->remote_node_index);
-		}
+		if (idev->is_direct_attached)
+			sci_port_setup_transports(idev->owning_port,
+						  sci_rnc->remote_node_index);
 	}
 }
 
-/**
- *
- * @sci_rnc: The remote node context object that is to be invalidated.
- *
- * This method will update the RNC buffer and post the invalidate request. none
- */
-static void scic_sds_remote_node_context_invalidate_context_buffer(
-	struct scic_sds_remote_node_context *sci_rnc)
+static void sci_remote_node_context_invalidate_context_buffer(struct sci_remote_node_context *sci_rnc)
 {
 	union scu_remote_node_context *rnc_buffer;
+	struct isci_remote_device *idev = rnc_to_dev(sci_rnc);
+	struct isci_host *ihost = idev->owning_port->owning_controller;
 
-	rnc_buffer = scic_sds_controller_get_remote_node_context_buffer(
-		scic_sds_remote_device_get_controller(rnc_to_dev(sci_rnc)),
-		sci_rnc->remote_node_index);
+	rnc_buffer = sci_rnc_by_id(ihost, sci_rnc->remote_node_index);
 
 	rnc_buffer->ssp.is_valid = false;
 
-	scic_sds_remote_device_post_request(rnc_to_dev(sci_rnc),
-					    SCU_CONTEXT_COMMAND_POST_RNC_INVALIDATE);
+	sci_remote_device_post_request(rnc_to_dev(sci_rnc),
+				       SCU_CONTEXT_COMMAND_POST_RNC_INVALIDATE);
 }
 
-static void scic_sds_remote_node_context_initial_state_enter(struct sci_base_state_machine *sm)
+static void sci_remote_node_context_initial_state_enter(struct sci_base_state_machine *sm)
 {
-	struct scic_sds_remote_node_context *rnc = container_of(sm, typeof(*rnc), sm);
+	struct sci_remote_node_context *rnc = container_of(sm, typeof(*rnc), sm);
 
 	/* Check to see if we have gotten back to the initial state because
 	 * someone requested to destroy the remote node context object.
 	 */
 	if (sm->previous_state_id == SCI_RNC_INVALIDATING) {
 		rnc->destination_state = SCIC_SDS_REMOTE_NODE_DESTINATION_STATE_UNSPECIFIED;
-		scic_sds_remote_node_context_notify_user(rnc);
+		sci_remote_node_context_notify_user(rnc);
 	}
 }
 
-static void scic_sds_remote_node_context_posting_state_enter(struct sci_base_state_machine *sm)
+static void sci_remote_node_context_posting_state_enter(struct sci_base_state_machine *sm)
 {
-	struct scic_sds_remote_node_context *sci_rnc = container_of(sm, typeof(*sci_rnc), sm);
+	struct sci_remote_node_context *sci_rnc = container_of(sm, typeof(*sci_rnc), sm);
 
-	scic_sds_remote_node_context_validate_context_buffer(sci_rnc);
+	sci_remote_node_context_validate_context_buffer(sci_rnc);
 }
 
-static void scic_sds_remote_node_context_invalidating_state_enter(struct sci_base_state_machine *sm)
+static void sci_remote_node_context_invalidating_state_enter(struct sci_base_state_machine *sm)
 {
-	struct scic_sds_remote_node_context *rnc = container_of(sm, typeof(*rnc), sm);
+	struct sci_remote_node_context *rnc = container_of(sm, typeof(*rnc), sm);
 
-	scic_sds_remote_node_context_invalidate_context_buffer(rnc);
+	sci_remote_node_context_invalidate_context_buffer(rnc);
 }
 
-static void scic_sds_remote_node_context_resuming_state_enter(struct sci_base_state_machine *sm)
+static void sci_remote_node_context_resuming_state_enter(struct sci_base_state_machine *sm)
 {
-	struct scic_sds_remote_node_context *rnc = container_of(sm, typeof(*rnc), sm);
+	struct sci_remote_node_context *rnc = container_of(sm, typeof(*rnc), sm);
 	struct isci_remote_device *idev;
 	struct domain_device *dev;
 
@@ -310,73 +292,73 @@ static void scic_sds_remote_node_context_resuming_state_enter(struct sci_base_st
 	 */
 	if ((dev->dev_type == SATA_DEV || (dev->tproto & SAS_PROTOCOL_STP)) &&
 	    idev->is_direct_attached)
-		scic_sds_port_setup_transports(idev->owning_port,
+		sci_port_setup_transports(idev->owning_port,
 					       rnc->remote_node_index);
 
-	scic_sds_remote_device_post_request(idev, SCU_CONTEXT_COMMAND_POST_RNC_RESUME);
+	sci_remote_device_post_request(idev, SCU_CONTEXT_COMMAND_POST_RNC_RESUME);
 }
 
-static void scic_sds_remote_node_context_ready_state_enter(struct sci_base_state_machine *sm)
+static void sci_remote_node_context_ready_state_enter(struct sci_base_state_machine *sm)
 {
-	struct scic_sds_remote_node_context *rnc = container_of(sm, typeof(*rnc), sm);
+	struct sci_remote_node_context *rnc = container_of(sm, typeof(*rnc), sm);
 
 	rnc->destination_state = SCIC_SDS_REMOTE_NODE_DESTINATION_STATE_UNSPECIFIED;
 
 	if (rnc->user_callback)
-		scic_sds_remote_node_context_notify_user(rnc);
+		sci_remote_node_context_notify_user(rnc);
 }
 
-static void scic_sds_remote_node_context_tx_suspended_state_enter(struct sci_base_state_machine *sm)
+static void sci_remote_node_context_tx_suspended_state_enter(struct sci_base_state_machine *sm)
 {
-	struct scic_sds_remote_node_context *rnc = container_of(sm, typeof(*rnc), sm);
+	struct sci_remote_node_context *rnc = container_of(sm, typeof(*rnc), sm);
 
-	scic_sds_remote_node_context_continue_state_transitions(rnc);
+	sci_remote_node_context_continue_state_transitions(rnc);
 }
 
-static void scic_sds_remote_node_context_tx_rx_suspended_state_enter(struct sci_base_state_machine *sm)
+static void sci_remote_node_context_tx_rx_suspended_state_enter(struct sci_base_state_machine *sm)
 {
-	struct scic_sds_remote_node_context *rnc = container_of(sm, typeof(*rnc), sm);
+	struct sci_remote_node_context *rnc = container_of(sm, typeof(*rnc), sm);
 
-	scic_sds_remote_node_context_continue_state_transitions(rnc);
+	sci_remote_node_context_continue_state_transitions(rnc);
 }
 
-static const struct sci_base_state scic_sds_remote_node_context_state_table[] = {
+static const struct sci_base_state sci_remote_node_context_state_table[] = {
 	[SCI_RNC_INITIAL] = {
-		.enter_state = scic_sds_remote_node_context_initial_state_enter,
+		.enter_state = sci_remote_node_context_initial_state_enter,
 	},
 	[SCI_RNC_POSTING] = {
-		.enter_state = scic_sds_remote_node_context_posting_state_enter,
+		.enter_state = sci_remote_node_context_posting_state_enter,
 	},
 	[SCI_RNC_INVALIDATING] = {
-		.enter_state = scic_sds_remote_node_context_invalidating_state_enter,
+		.enter_state = sci_remote_node_context_invalidating_state_enter,
 	},
 	[SCI_RNC_RESUMING] = {
-		.enter_state = scic_sds_remote_node_context_resuming_state_enter,
+		.enter_state = sci_remote_node_context_resuming_state_enter,
 	},
 	[SCI_RNC_READY] = {
-		.enter_state = scic_sds_remote_node_context_ready_state_enter,
+		.enter_state = sci_remote_node_context_ready_state_enter,
 	},
 	[SCI_RNC_TX_SUSPENDED] = {
-		.enter_state = scic_sds_remote_node_context_tx_suspended_state_enter,
+		.enter_state = sci_remote_node_context_tx_suspended_state_enter,
 	},
 	[SCI_RNC_TX_RX_SUSPENDED] = {
-		.enter_state = scic_sds_remote_node_context_tx_rx_suspended_state_enter,
+		.enter_state = sci_remote_node_context_tx_rx_suspended_state_enter,
 	},
 	[SCI_RNC_AWAIT_SUSPENSION] = { },
 };
 
-void scic_sds_remote_node_context_construct(struct scic_sds_remote_node_context *rnc,
+void sci_remote_node_context_construct(struct sci_remote_node_context *rnc,
 					    u16 remote_node_index)
 {
-	memset(rnc, 0, sizeof(struct scic_sds_remote_node_context));
+	memset(rnc, 0, sizeof(struct sci_remote_node_context));
 
 	rnc->remote_node_index = remote_node_index;
 	rnc->destination_state = SCIC_SDS_REMOTE_NODE_DESTINATION_STATE_UNSPECIFIED;
 
-	sci_init_sm(&rnc->sm, scic_sds_remote_node_context_state_table, SCI_RNC_INITIAL);
+	sci_init_sm(&rnc->sm, sci_remote_node_context_state_table, SCI_RNC_INITIAL);
 }
 
-enum sci_status scic_sds_remote_node_context_event_handler(struct scic_sds_remote_node_context *sci_rnc,
+enum sci_status sci_remote_node_context_event_handler(struct sci_remote_node_context *sci_rnc,
 							   u32 event_code)
 {
 	enum scis_sds_remote_node_context_states state;
@@ -476,7 +458,7 @@ enum sci_status scic_sds_remote_node_context_event_handler(struct scic_sds_remot
 
 }
 
-enum sci_status scic_sds_remote_node_context_destruct(struct scic_sds_remote_node_context *sci_rnc,
+enum sci_status sci_remote_node_context_destruct(struct sci_remote_node_context *sci_rnc,
 						      scics_sds_remote_node_context_callback cb_fn,
 						      void *cb_p)
 {
@@ -485,7 +467,7 @@ enum sci_status scic_sds_remote_node_context_destruct(struct scic_sds_remote_nod
 	state = sci_rnc->sm.current_state_id;
 	switch (state) {
 	case SCI_RNC_INVALIDATING:
-		scic_sds_remote_node_context_setup_to_destory(sci_rnc, cb_fn, cb_p);
+		sci_remote_node_context_setup_to_destory(sci_rnc, cb_fn, cb_p);
 		return SCI_SUCCESS;
 	case SCI_RNC_POSTING:
 	case SCI_RNC_RESUMING:
@@ -493,7 +475,7 @@ enum sci_status scic_sds_remote_node_context_destruct(struct scic_sds_remote_nod
 	case SCI_RNC_TX_SUSPENDED:
 	case SCI_RNC_TX_RX_SUSPENDED:
 	case SCI_RNC_AWAIT_SUSPENSION:
-		scic_sds_remote_node_context_setup_to_destory(sci_rnc, cb_fn, cb_p);
+		sci_remote_node_context_setup_to_destory(sci_rnc, cb_fn, cb_p);
 		sci_change_state(&sci_rnc->sm, SCI_RNC_INVALIDATING);
 		return SCI_SUCCESS;
 	case SCI_RNC_INITIAL:
@@ -511,7 +493,7 @@ enum sci_status scic_sds_remote_node_context_destruct(struct scic_sds_remote_nod
 	}
 }
 
-enum sci_status scic_sds_remote_node_context_suspend(struct scic_sds_remote_node_context *sci_rnc,
+enum sci_status sci_remote_node_context_suspend(struct sci_remote_node_context *sci_rnc,
 						     u32 suspend_type,
 						     scics_sds_remote_node_context_callback cb_fn,
 						     void *cb_p)
@@ -530,7 +512,7 @@ enum sci_status scic_sds_remote_node_context_suspend(struct scic_sds_remote_node
 	sci_rnc->suspension_code = suspend_type;
 
 	if (suspend_type == SCI_SOFTWARE_SUSPENSION) {
-		scic_sds_remote_device_post_request(rnc_to_dev(sci_rnc),
+		sci_remote_device_post_request(rnc_to_dev(sci_rnc),
 						    SCU_CONTEXT_COMMAND_POST_RNC_SUSPEND_TX);
 	}
 
@@ -538,7 +520,7 @@ enum sci_status scic_sds_remote_node_context_suspend(struct scic_sds_remote_node
 	return SCI_SUCCESS;
 }
 
-enum sci_status scic_sds_remote_node_context_resume(struct scic_sds_remote_node_context *sci_rnc,
+enum sci_status sci_remote_node_context_resume(struct sci_remote_node_context *sci_rnc,
 						    scics_sds_remote_node_context_callback cb_fn,
 						    void *cb_p)
 {
@@ -550,8 +532,8 @@ enum sci_status scic_sds_remote_node_context_resume(struct scic_sds_remote_node_
 		if (sci_rnc->remote_node_index == SCIC_SDS_REMOTE_NODE_CONTEXT_INVALID_INDEX)
 			return SCI_FAILURE_INVALID_STATE;
 
-		scic_sds_remote_node_context_setup_to_resume(sci_rnc, cb_fn, cb_p);
-		scic_sds_remote_node_context_construct_buffer(sci_rnc);
+		sci_remote_node_context_setup_to_resume(sci_rnc, cb_fn, cb_p);
+		sci_remote_node_context_construct_buffer(sci_rnc);
 		sci_change_state(&sci_rnc->sm, SCI_RNC_POSTING);
 		return SCI_SUCCESS;
 	case SCI_RNC_POSTING:
@@ -567,7 +549,7 @@ enum sci_status scic_sds_remote_node_context_resume(struct scic_sds_remote_node_
 		struct isci_remote_device *idev = rnc_to_dev(sci_rnc);
 		struct domain_device *dev = idev->domain_dev;
 
-		scic_sds_remote_node_context_setup_to_resume(sci_rnc, cb_fn, cb_p);
+		sci_remote_node_context_setup_to_resume(sci_rnc, cb_fn, cb_p);
 
 		/* TODO: consider adding a resume action of NONE, INVALIDATE, WRITE_TLCR */
 		if (dev->dev_type == SAS_END_DEV || dev_is_expander(dev))
@@ -584,11 +566,11 @@ enum sci_status scic_sds_remote_node_context_resume(struct scic_sds_remote_node_
 		return SCI_SUCCESS;
 	}
 	case SCI_RNC_TX_RX_SUSPENDED:
-		scic_sds_remote_node_context_setup_to_resume(sci_rnc, cb_fn, cb_p);
+		sci_remote_node_context_setup_to_resume(sci_rnc, cb_fn, cb_p);
 		sci_change_state(&sci_rnc->sm, SCI_RNC_RESUMING);
 		return SCI_FAILURE_INVALID_STATE;
 	case SCI_RNC_AWAIT_SUSPENSION:
-		scic_sds_remote_node_context_setup_to_resume(sci_rnc, cb_fn, cb_p);
+		sci_remote_node_context_setup_to_resume(sci_rnc, cb_fn, cb_p);
 		return SCI_SUCCESS;
 	default:
 		dev_warn(scirdev_to_dev(rnc_to_dev(sci_rnc)),
@@ -597,7 +579,7 @@ enum sci_status scic_sds_remote_node_context_resume(struct scic_sds_remote_node_
 	}
 }
 
-enum sci_status scic_sds_remote_node_context_start_io(struct scic_sds_remote_node_context *sci_rnc,
+enum sci_status sci_remote_node_context_start_io(struct sci_remote_node_context *sci_rnc,
 							     struct isci_request *ireq)
 {
 	enum scis_sds_remote_node_context_states state;
@@ -622,7 +604,7 @@ enum sci_status scic_sds_remote_node_context_start_io(struct scic_sds_remote_nod
 	return SCI_FAILURE_INVALID_STATE;
 }
 
-enum sci_status scic_sds_remote_node_context_start_task(struct scic_sds_remote_node_context *sci_rnc,
+enum sci_status sci_remote_node_context_start_task(struct sci_remote_node_context *sci_rnc,
 							struct isci_request *ireq)
 {
 	enum scis_sds_remote_node_context_states state;
@@ -635,7 +617,7 @@ enum sci_status scic_sds_remote_node_context_start_task(struct scic_sds_remote_n
 		return SCI_SUCCESS;
 	case SCI_RNC_TX_SUSPENDED:
 	case SCI_RNC_TX_RX_SUSPENDED:
-		scic_sds_remote_node_context_resume(sci_rnc, NULL, NULL);
+		sci_remote_node_context_resume(sci_rnc, NULL, NULL);
 		return SCI_SUCCESS;
 	default:
 		dev_warn(scirdev_to_dev(rnc_to_dev(sci_rnc)),

commit d9dcb4ba791de2a06b19ac47cd61601cf3d4e208
Author: Dan Williams <dan.j.williams@intel.com>
Date:   Thu Jun 30 17:38:32 2011 -0700

    isci: unify isci_host and scic_sds_controller
    
    Remove the distinction between these two implementations and unify on
    isci_host (local instances named ihost).  Hmmm, we had two
    'oem_parameters' instances, one was unused... nice.
    
    Reported-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/drivers/scsi/isci/remote_node_context.c b/drivers/scsi/isci/remote_node_context.c
index e485744e1263..8a5203b6eb09 100644
--- a/drivers/scsi/isci/remote_node_context.c
+++ b/drivers/scsi/isci/remote_node_context.c
@@ -107,11 +107,11 @@ static void scic_sds_remote_node_context_construct_buffer(
 	struct domain_device *dev = idev->domain_dev;
 	int rni = sci_rnc->remote_node_index;
 	union scu_remote_node_context *rnc;
-	struct scic_sds_controller *scic;
+	struct isci_host *ihost;
 	__le64 sas_addr;
 
-	scic = scic_sds_remote_device_get_controller(idev);
-	rnc = scic_sds_controller_get_remote_node_context_buffer(scic, rni);
+	ihost = scic_sds_remote_device_get_controller(idev);
+	rnc = scic_sds_controller_get_remote_node_context_buffer(ihost, rni);
 
 	memset(rnc, 0, sizeof(union scu_remote_node_context)
 		* scic_sds_remote_device_node_count(idev));
@@ -135,14 +135,14 @@ static void scic_sds_remote_node_context_construct_buffer(
 
 	if (dev->dev_type == SATA_DEV || (dev->tproto & SAS_PROTOCOL_STP)) {
 		rnc->ssp.connection_occupancy_timeout =
-			scic->user_parameters.sds1.stp_max_occupancy_timeout;
+			ihost->user_parameters.sds1.stp_max_occupancy_timeout;
 		rnc->ssp.connection_inactivity_timeout =
-			scic->user_parameters.sds1.stp_inactivity_timeout;
+			ihost->user_parameters.sds1.stp_inactivity_timeout;
 	} else {
 		rnc->ssp.connection_occupancy_timeout  =
-			scic->user_parameters.sds1.ssp_max_occupancy_timeout;
+			ihost->user_parameters.sds1.ssp_max_occupancy_timeout;
 		rnc->ssp.connection_inactivity_timeout =
-			scic->user_parameters.sds1.ssp_inactivity_timeout;
+			ihost->user_parameters.sds1.ssp_inactivity_timeout;
 	}
 
 	rnc->ssp.initial_arbitration_wait_time = 0;

commit 78a6f06e0e82125787d7aa308fe28c2c8381540c
Author: Dan Williams <dan.j.williams@intel.com>
Date:   Thu Jun 30 16:31:37 2011 -0700

    isci: unify isci_remote_device and scic_sds_remote_device
    
    Remove the distinction between these two implementations and unify on
    isci_remote_device (local instances named idev).
    
    Reported-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/drivers/scsi/isci/remote_node_context.c b/drivers/scsi/isci/remote_node_context.c
index 1b51fe55314d..e485744e1263 100644
--- a/drivers/scsi/isci/remote_node_context.c
+++ b/drivers/scsi/isci/remote_node_context.c
@@ -103,22 +103,22 @@ bool scic_sds_remote_node_context_is_ready(
 static void scic_sds_remote_node_context_construct_buffer(
 	struct scic_sds_remote_node_context *sci_rnc)
 {
-	struct scic_sds_remote_device *sci_dev = rnc_to_dev(sci_rnc);
-	struct domain_device *dev = sci_dev_to_domain(sci_dev);
+	struct isci_remote_device *idev = rnc_to_dev(sci_rnc);
+	struct domain_device *dev = idev->domain_dev;
 	int rni = sci_rnc->remote_node_index;
 	union scu_remote_node_context *rnc;
 	struct scic_sds_controller *scic;
 	__le64 sas_addr;
 
-	scic = scic_sds_remote_device_get_controller(sci_dev);
+	scic = scic_sds_remote_device_get_controller(idev);
 	rnc = scic_sds_controller_get_remote_node_context_buffer(scic, rni);
 
 	memset(rnc, 0, sizeof(union scu_remote_node_context)
-		* scic_sds_remote_device_node_count(sci_dev));
+		* scic_sds_remote_device_node_count(idev));
 
 	rnc->ssp.remote_node_index = rni;
-	rnc->ssp.remote_node_port_width = sci_dev->device_port_width;
-	rnc->ssp.logical_port_index = sci_dev->owning_port->physical_port_index;
+	rnc->ssp.remote_node_port_width = idev->device_port_width;
+	rnc->ssp.logical_port_index = idev->owning_port->physical_port_index;
 
 	/* sas address is __be64, context ram format is __le64 */
 	sas_addr = cpu_to_le64(SAS_ADDR(dev->sas_addr));
@@ -148,7 +148,7 @@ static void scic_sds_remote_node_context_construct_buffer(
 	rnc->ssp.initial_arbitration_wait_time = 0;
 
 	/* Open Address Frame Parameters */
-	rnc->ssp.oaf_connection_rate = sci_dev->connection_rate;
+	rnc->ssp.oaf_connection_rate = idev->connection_rate;
 	rnc->ssp.oaf_features = 0;
 	rnc->ssp.oaf_source_zone_group = 0;
 	rnc->ssp.oaf_more_compatibility_features = 0;
@@ -220,26 +220,26 @@ static void scic_sds_remote_node_context_continue_state_transitions(struct scic_
 static void scic_sds_remote_node_context_validate_context_buffer(
 	struct scic_sds_remote_node_context *sci_rnc)
 {
-	struct scic_sds_remote_device *sci_dev = rnc_to_dev(sci_rnc);
-	struct domain_device *dev = sci_dev_to_domain(sci_dev);
+	struct isci_remote_device *idev = rnc_to_dev(sci_rnc);
+	struct domain_device *dev = idev->domain_dev;
 	union scu_remote_node_context *rnc_buffer;
 
 	rnc_buffer = scic_sds_controller_get_remote_node_context_buffer(
-		scic_sds_remote_device_get_controller(sci_dev),
+		scic_sds_remote_device_get_controller(idev),
 		sci_rnc->remote_node_index
 		);
 
 	rnc_buffer->ssp.is_valid = true;
 
-	if (!sci_dev->is_direct_attached &&
+	if (!idev->is_direct_attached &&
 	    (dev->dev_type == SATA_DEV || (dev->tproto & SAS_PROTOCOL_STP))) {
-		scic_sds_remote_device_post_request(sci_dev,
+		scic_sds_remote_device_post_request(idev,
 						    SCU_CONTEXT_COMMAND_POST_RNC_96);
 	} else {
-		scic_sds_remote_device_post_request(sci_dev, SCU_CONTEXT_COMMAND_POST_RNC_32);
+		scic_sds_remote_device_post_request(idev, SCU_CONTEXT_COMMAND_POST_RNC_32);
 
-		if (sci_dev->is_direct_attached) {
-			scic_sds_port_setup_transports(sci_dev->owning_port,
+		if (idev->is_direct_attached) {
+			scic_sds_port_setup_transports(idev->owning_port,
 						       sci_rnc->remote_node_index);
 		}
 	}
@@ -296,11 +296,11 @@ static void scic_sds_remote_node_context_invalidating_state_enter(struct sci_bas
 static void scic_sds_remote_node_context_resuming_state_enter(struct sci_base_state_machine *sm)
 {
 	struct scic_sds_remote_node_context *rnc = container_of(sm, typeof(*rnc), sm);
-	struct scic_sds_remote_device *sci_dev;
+	struct isci_remote_device *idev;
 	struct domain_device *dev;
 
-	sci_dev = rnc_to_dev(rnc);
-	dev = sci_dev_to_domain(sci_dev);
+	idev = rnc_to_dev(rnc);
+	dev = idev->domain_dev;
 
 	/*
 	 * For direct attached SATA devices we need to clear the TLCR
@@ -309,11 +309,11 @@ static void scic_sds_remote_node_context_resuming_state_enter(struct sci_base_st
 	 * the STPTLDARNI register with the RNi of the device
 	 */
 	if ((dev->dev_type == SATA_DEV || (dev->tproto & SAS_PROTOCOL_STP)) &&
-	    sci_dev->is_direct_attached)
-		scic_sds_port_setup_transports(sci_dev->owning_port,
+	    idev->is_direct_attached)
+		scic_sds_port_setup_transports(idev->owning_port,
 					       rnc->remote_node_index);
 
-	scic_sds_remote_device_post_request(sci_dev, SCU_CONTEXT_COMMAND_POST_RNC_RESUME);
+	scic_sds_remote_device_post_request(idev, SCU_CONTEXT_COMMAND_POST_RNC_RESUME);
 }
 
 static void scic_sds_remote_node_context_ready_state_enter(struct sci_base_state_machine *sm)
@@ -564,8 +564,8 @@ enum sci_status scic_sds_remote_node_context_resume(struct scic_sds_remote_node_
 		sci_rnc->user_cookie   = cb_p;
 		return SCI_SUCCESS;
 	case SCI_RNC_TX_SUSPENDED: {
-		struct scic_sds_remote_device *sci_dev = rnc_to_dev(sci_rnc);
-		struct domain_device *dev = sci_dev_to_domain(sci_dev);
+		struct isci_remote_device *idev = rnc_to_dev(sci_rnc);
+		struct domain_device *dev = idev->domain_dev;
 
 		scic_sds_remote_node_context_setup_to_resume(sci_rnc, cb_fn, cb_p);
 
@@ -573,7 +573,7 @@ enum sci_status scic_sds_remote_node_context_resume(struct scic_sds_remote_node_
 		if (dev->dev_type == SAS_END_DEV || dev_is_expander(dev))
 			sci_change_state(&sci_rnc->sm, SCI_RNC_RESUMING);
 		else if (dev->dev_type == SATA_DEV || (dev->tproto & SAS_PROTOCOL_STP)) {
-			if (sci_dev->is_direct_attached) {
+			if (idev->is_direct_attached) {
 				/* @todo Fix this since I am being silly in writing to the STPTLDARNI register. */
 				sci_change_state(&sci_rnc->sm, SCI_RNC_RESUMING);
 			} else {

commit 5076a1a97e2fa61c847a5fdd4b1991faf7716da6
Author: Dan Williams <dan.j.williams@intel.com>
Date:   Mon Jun 27 14:57:03 2011 -0700

    isci: unify isci_request and scic_sds_request
    
    They are one in the same object so remove the distinction.  The near
    duplicate fields (owning_controller, and isci_host) will be cleaned up
    after the scic_sds_contoller isci_host unification.
    
    Reported-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/drivers/scsi/isci/remote_node_context.c b/drivers/scsi/isci/remote_node_context.c
index b6774bcdabd8..1b51fe55314d 100644
--- a/drivers/scsi/isci/remote_node_context.c
+++ b/drivers/scsi/isci/remote_node_context.c
@@ -598,7 +598,7 @@ enum sci_status scic_sds_remote_node_context_resume(struct scic_sds_remote_node_
 }
 
 enum sci_status scic_sds_remote_node_context_start_io(struct scic_sds_remote_node_context *sci_rnc,
-							     struct scic_sds_request *sci_req)
+							     struct isci_request *ireq)
 {
 	enum scis_sds_remote_node_context_states state;
 
@@ -623,7 +623,7 @@ enum sci_status scic_sds_remote_node_context_start_io(struct scic_sds_remote_nod
 }
 
 enum sci_status scic_sds_remote_node_context_start_task(struct scic_sds_remote_node_context *sci_rnc,
-							struct scic_sds_request *sci_req)
+							struct isci_request *ireq)
 {
 	enum scis_sds_remote_node_context_states state;
 

commit fd53660120b5eda06539225de56755dc389a4e64
Author: Jeff Skirvin <jeffrey.d.skirvin@intel.com>
Date:   Mon Jun 20 14:09:22 2011 -0700

    isci: Explicitly decode remote node ready and suspended states
    
    The remote node context should only signal a device reset condition
    in a suspended state.
    
    Signed-off-by: Jeff Skirvin <jeffrey.d.skirvin@intel.com>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/drivers/scsi/isci/remote_node_context.c b/drivers/scsi/isci/remote_node_context.c
index 9e8967e19688..b6774bcdabd8 100644
--- a/drivers/scsi/isci/remote_node_context.c
+++ b/drivers/scsi/isci/remote_node_context.c
@@ -603,12 +603,23 @@ enum sci_status scic_sds_remote_node_context_start_io(struct scic_sds_remote_nod
 	enum scis_sds_remote_node_context_states state;
 
 	state = sci_rnc->sm.current_state_id;
-	if (state != SCI_RNC_READY) {
+
+	switch (state) {
+	case SCI_RNC_READY:
+		return SCI_SUCCESS;
+	case SCI_RNC_TX_SUSPENDED:
+	case SCI_RNC_TX_RX_SUSPENDED:
+	case SCI_RNC_AWAIT_SUSPENSION:
 		dev_warn(scirdev_to_dev(rnc_to_dev(sci_rnc)),
 			 "%s: invalid state %d\n", __func__, state);
 		return SCI_FAILURE_REMOTE_DEVICE_RESET_REQUIRED;
+	default:
+		break;
 	}
-	return SCI_SUCCESS;
+	dev_dbg(scirdev_to_dev(rnc_to_dev(sci_rnc)),
+		"%s: requested to start IO while still resuming, %d\n",
+		__func__, state);
+	return SCI_FAILURE_INVALID_STATE;
 }
 
 enum sci_status scic_sds_remote_node_context_start_task(struct scic_sds_remote_node_context *sci_rnc,

commit 12ef65444de9d387a383b9991960848bed5bbe74
Author: Edmund Nadolski <edmund.nadolski@intel.com>
Date:   Thu Jun 2 00:10:50 2011 +0000

    isci: additional state machine cleanup
    
    Additional state machine cleanups:
    
     o Remove static functions sci_state_machine_exit_state() and
       sci_state_machine_enter_state()
     o Combines sci_base_state_machine_construct() and
       sci_base_state_machine_start() into a single function,
       sci_init_sm()
     o Remove sci_base_state_machine_stop() which is unused.
     o Kill state_machine.[ch]
    
    Signed-off-by: Edmund Nadolski <edmund.nadolski@intel.com>
    [fixed too large to inline functions]
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/drivers/scsi/isci/remote_node_context.c b/drivers/scsi/isci/remote_node_context.c
index 24b1d8acf7b8..9e8967e19688 100644
--- a/drivers/scsi/isci/remote_node_context.c
+++ b/drivers/scsi/isci/remote_node_context.c
@@ -54,7 +54,7 @@
  */
 
 #include "host.h"
-#include "state_machine.h"
+#include "isci.h"
 #include "remote_device.h"
 #include "remote_node_context.h"
 #include "scu_event_codes.h"
@@ -373,11 +373,7 @@ void scic_sds_remote_node_context_construct(struct scic_sds_remote_node_context
 	rnc->remote_node_index = remote_node_index;
 	rnc->destination_state = SCIC_SDS_REMOTE_NODE_DESTINATION_STATE_UNSPECIFIED;
 
-	sci_base_state_machine_construct(&rnc->sm,
-					 scic_sds_remote_node_context_state_table,
-					 SCI_RNC_INITIAL);
-
-	sci_base_state_machine_start(&rnc->sm);
+	sci_init_sm(&rnc->sm, scic_sds_remote_node_context_state_table, SCI_RNC_INITIAL);
 }
 
 enum sci_status scic_sds_remote_node_context_event_handler(struct scic_sds_remote_node_context *sci_rnc,

commit e301370ac553a9a0ac0d1d25e769b86cf60395b3
Author: Edmund Nadolski <edmund.nadolski@intel.com>
Date:   Thu Jun 2 00:10:43 2011 +0000

    isci: state machine cleanup
    
    This cleans up several areas of the state machine mechanism:
    
     o Rename sci_base_state_machine_change_state to sci_change_state
     o Remove sci_base_state_machine_get_state function
     o Rename 'state_machine' struct member to 'sm' in client structs
     o Shorten the name of request states
     o Shorten state machine state names as follows:
            SCI_BASE_CONTROLLER_STATE_xxx to SCIC_xxx
            SCI_BASE_PHY_STATE_xxx to SCI_PHY_xxx
            SCIC_SDS_PHY_STARTING_SUBSTATE_xxx to SCI_PHY_SUB_xxx
            SCI_BASE_PORT_STATE_xxx to SCI_PORT_xxx and
            SCIC_SDS_PORT_READY_SUBSTATE_xxx to SCI_PORT_SUB_xxx
            SCI_BASE_REMOTE_DEVICE_STATE_xxx to SCI_DEV_xxx
            SCIC_SDS_STP_REMOTE_DEVICE_READY_SUBSTATE_xxx to SCI_STP_DEV_xxx
            SCIC_SDS_SMP_REMOTE_DEVICE_READY_SUBSTATE_xxx to SCI_SMP_DEV_xxx
            SCIC_SDS_REMOTE_NODE_CONTEXT_xxx_STATE to SCI_RNC_xxx
    
    Signed-off-by: Edmund Nadolski <edmund.nadolski@intel.com>
    Signed-off-by: Dave Jiang <dave.jiang@intel.com>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/drivers/scsi/isci/remote_node_context.c b/drivers/scsi/isci/remote_node_context.c
index e7fa5bac7d53..24b1d8acf7b8 100644
--- a/drivers/scsi/isci/remote_node_context.c
+++ b/drivers/scsi/isci/remote_node_context.c
@@ -84,9 +84,9 @@
 bool scic_sds_remote_node_context_is_ready(
 	struct scic_sds_remote_node_context *sci_rnc)
 {
-	u32 current_state = sci_base_state_machine_get_state(&sci_rnc->state_machine);
+	u32 current_state = sci_rnc->sm.current_state_id;
 
-	if (current_state == SCIC_SDS_REMOTE_NODE_CONTEXT_READY_STATE) {
+	if (current_state == SCI_RNC_READY) {
 		return true;
 	}
 
@@ -268,12 +268,12 @@ static void scic_sds_remote_node_context_invalidate_context_buffer(
 
 static void scic_sds_remote_node_context_initial_state_enter(struct sci_base_state_machine *sm)
 {
-	struct scic_sds_remote_node_context *rnc = container_of(sm, typeof(*rnc), state_machine);
+	struct scic_sds_remote_node_context *rnc = container_of(sm, typeof(*rnc), sm);
 
 	/* Check to see if we have gotten back to the initial state because
 	 * someone requested to destroy the remote node context object.
 	 */
-	if (sm->previous_state_id == SCIC_SDS_REMOTE_NODE_CONTEXT_INVALIDATING_STATE) {
+	if (sm->previous_state_id == SCI_RNC_INVALIDATING) {
 		rnc->destination_state = SCIC_SDS_REMOTE_NODE_DESTINATION_STATE_UNSPECIFIED;
 		scic_sds_remote_node_context_notify_user(rnc);
 	}
@@ -281,21 +281,21 @@ static void scic_sds_remote_node_context_initial_state_enter(struct sci_base_sta
 
 static void scic_sds_remote_node_context_posting_state_enter(struct sci_base_state_machine *sm)
 {
-	struct scic_sds_remote_node_context *sci_rnc = container_of(sm, typeof(*sci_rnc), state_machine);
+	struct scic_sds_remote_node_context *sci_rnc = container_of(sm, typeof(*sci_rnc), sm);
 
 	scic_sds_remote_node_context_validate_context_buffer(sci_rnc);
 }
 
 static void scic_sds_remote_node_context_invalidating_state_enter(struct sci_base_state_machine *sm)
 {
-	struct scic_sds_remote_node_context *rnc = container_of(sm, typeof(*rnc), state_machine);
+	struct scic_sds_remote_node_context *rnc = container_of(sm, typeof(*rnc), sm);
 
 	scic_sds_remote_node_context_invalidate_context_buffer(rnc);
 }
 
 static void scic_sds_remote_node_context_resuming_state_enter(struct sci_base_state_machine *sm)
 {
-	struct scic_sds_remote_node_context *rnc = container_of(sm, typeof(*rnc), state_machine);
+	struct scic_sds_remote_node_context *rnc = container_of(sm, typeof(*rnc), sm);
 	struct scic_sds_remote_device *sci_dev;
 	struct domain_device *dev;
 
@@ -318,7 +318,7 @@ static void scic_sds_remote_node_context_resuming_state_enter(struct sci_base_st
 
 static void scic_sds_remote_node_context_ready_state_enter(struct sci_base_state_machine *sm)
 {
-	struct scic_sds_remote_node_context *rnc = container_of(sm, typeof(*rnc), state_machine);
+	struct scic_sds_remote_node_context *rnc = container_of(sm, typeof(*rnc), sm);
 
 	rnc->destination_state = SCIC_SDS_REMOTE_NODE_DESTINATION_STATE_UNSPECIFIED;
 
@@ -328,41 +328,41 @@ static void scic_sds_remote_node_context_ready_state_enter(struct sci_base_state
 
 static void scic_sds_remote_node_context_tx_suspended_state_enter(struct sci_base_state_machine *sm)
 {
-	struct scic_sds_remote_node_context *rnc = container_of(sm, typeof(*rnc), state_machine);
+	struct scic_sds_remote_node_context *rnc = container_of(sm, typeof(*rnc), sm);
 
 	scic_sds_remote_node_context_continue_state_transitions(rnc);
 }
 
 static void scic_sds_remote_node_context_tx_rx_suspended_state_enter(struct sci_base_state_machine *sm)
 {
-	struct scic_sds_remote_node_context *rnc = container_of(sm, typeof(*rnc), state_machine);
+	struct scic_sds_remote_node_context *rnc = container_of(sm, typeof(*rnc), sm);
 
 	scic_sds_remote_node_context_continue_state_transitions(rnc);
 }
 
 static const struct sci_base_state scic_sds_remote_node_context_state_table[] = {
-	[SCIC_SDS_REMOTE_NODE_CONTEXT_INITIAL_STATE] = {
+	[SCI_RNC_INITIAL] = {
 		.enter_state = scic_sds_remote_node_context_initial_state_enter,
 	},
-	[SCIC_SDS_REMOTE_NODE_CONTEXT_POSTING_STATE] = {
+	[SCI_RNC_POSTING] = {
 		.enter_state = scic_sds_remote_node_context_posting_state_enter,
 	},
-	[SCIC_SDS_REMOTE_NODE_CONTEXT_INVALIDATING_STATE] = {
+	[SCI_RNC_INVALIDATING] = {
 		.enter_state = scic_sds_remote_node_context_invalidating_state_enter,
 	},
-	[SCIC_SDS_REMOTE_NODE_CONTEXT_RESUMING_STATE] = {
+	[SCI_RNC_RESUMING] = {
 		.enter_state = scic_sds_remote_node_context_resuming_state_enter,
 	},
-	[SCIC_SDS_REMOTE_NODE_CONTEXT_READY_STATE] = {
+	[SCI_RNC_READY] = {
 		.enter_state = scic_sds_remote_node_context_ready_state_enter,
 	},
-	[SCIC_SDS_REMOTE_NODE_CONTEXT_TX_SUSPENDED_STATE] = {
+	[SCI_RNC_TX_SUSPENDED] = {
 		.enter_state = scic_sds_remote_node_context_tx_suspended_state_enter,
 	},
-	[SCIC_SDS_REMOTE_NODE_CONTEXT_TX_RX_SUSPENDED_STATE] = {
+	[SCI_RNC_TX_RX_SUSPENDED] = {
 		.enter_state = scic_sds_remote_node_context_tx_rx_suspended_state_enter,
 	},
-	[SCIC_SDS_REMOTE_NODE_CONTEXT_AWAIT_SUSPENSION_STATE] = { },
+	[SCI_RNC_AWAIT_SUSPENSION] = { },
 };
 
 void scic_sds_remote_node_context_construct(struct scic_sds_remote_node_context *rnc,
@@ -373,11 +373,11 @@ void scic_sds_remote_node_context_construct(struct scic_sds_remote_node_context
 	rnc->remote_node_index = remote_node_index;
 	rnc->destination_state = SCIC_SDS_REMOTE_NODE_DESTINATION_STATE_UNSPECIFIED;
 
-	sci_base_state_machine_construct(&rnc->state_machine,
+	sci_base_state_machine_construct(&rnc->sm,
 					 scic_sds_remote_node_context_state_table,
-					 SCIC_SDS_REMOTE_NODE_CONTEXT_INITIAL_STATE);
+					 SCI_RNC_INITIAL);
 
-	sci_base_state_machine_start(&rnc->state_machine);
+	sci_base_state_machine_start(&rnc->sm);
 }
 
 enum sci_status scic_sds_remote_node_context_event_handler(struct scic_sds_remote_node_context *sci_rnc,
@@ -385,26 +385,24 @@ enum sci_status scic_sds_remote_node_context_event_handler(struct scic_sds_remot
 {
 	enum scis_sds_remote_node_context_states state;
 
-	state = sci_rnc->state_machine.current_state_id;
+	state = sci_rnc->sm.current_state_id;
 	switch (state) {
-	case SCIC_SDS_REMOTE_NODE_CONTEXT_POSTING_STATE:
+	case SCI_RNC_POSTING:
 		switch (scu_get_event_code(event_code)) {
 		case SCU_EVENT_POST_RNC_COMPLETE:
-			sci_base_state_machine_change_state(&sci_rnc->state_machine,
-							    SCIC_SDS_REMOTE_NODE_CONTEXT_READY_STATE);
+			sci_change_state(&sci_rnc->sm, SCI_RNC_READY);
 			break;
 		default:
 			goto out;
 		}
 		break;
-	case SCIC_SDS_REMOTE_NODE_CONTEXT_INVALIDATING_STATE:
+	case SCI_RNC_INVALIDATING:
 		if (scu_get_event_code(event_code) == SCU_EVENT_POST_RNC_INVALIDATE_COMPLETE) {
 			if (sci_rnc->destination_state == SCIC_SDS_REMOTE_NODE_DESTINATION_STATE_FINAL)
-				state = SCIC_SDS_REMOTE_NODE_CONTEXT_INITIAL_STATE;
+				state = SCI_RNC_INITIAL;
 			else
-				state = SCIC_SDS_REMOTE_NODE_CONTEXT_POSTING_STATE;
-			sci_base_state_machine_change_state(&sci_rnc->state_machine,
-							    state);
+				state = SCI_RNC_POSTING;
+			sci_change_state(&sci_rnc->sm, state);
 		} else {
 			switch (scu_get_event_type(event_code)) {
 			case SCU_EVENT_TYPE_RNC_SUSPEND_TX:
@@ -421,10 +419,9 @@ enum sci_status scic_sds_remote_node_context_event_handler(struct scic_sds_remot
 			}
 		}
 		break;
-	case SCIC_SDS_REMOTE_NODE_CONTEXT_RESUMING_STATE:
+	case SCI_RNC_RESUMING:
 		if (scu_get_event_code(event_code) == SCU_EVENT_POST_RCN_RELEASE) {
-			sci_base_state_machine_change_state(&sci_rnc->state_machine,
-							    SCIC_SDS_REMOTE_NODE_CONTEXT_READY_STATE);
+			sci_change_state(&sci_rnc->sm, SCI_RNC_READY);
 		} else {
 			switch (scu_get_event_type(event_code)) {
 			case SCU_EVENT_TYPE_RNC_SUSPEND_TX:
@@ -441,32 +438,28 @@ enum sci_status scic_sds_remote_node_context_event_handler(struct scic_sds_remot
 			}
 		}
 		break;
-	case SCIC_SDS_REMOTE_NODE_CONTEXT_READY_STATE:
+	case SCI_RNC_READY:
 		switch (scu_get_event_type(event_code)) {
 		case SCU_EVENT_TL_RNC_SUSPEND_TX:
-			sci_base_state_machine_change_state(&sci_rnc->state_machine,
-							    SCIC_SDS_REMOTE_NODE_CONTEXT_TX_SUSPENDED_STATE);
+			sci_change_state(&sci_rnc->sm, SCI_RNC_TX_SUSPENDED);
 			sci_rnc->suspension_code = scu_get_event_specifier(event_code);
 			break;
 		case SCU_EVENT_TL_RNC_SUSPEND_TX_RX:
-			sci_base_state_machine_change_state(&sci_rnc->state_machine,
-							    SCIC_SDS_REMOTE_NODE_CONTEXT_TX_RX_SUSPENDED_STATE);
+			sci_change_state(&sci_rnc->sm, SCI_RNC_TX_RX_SUSPENDED);
 			sci_rnc->suspension_code = scu_get_event_specifier(event_code);
 			break;
 		default:
 			goto out;
 		}
 		break;
-	case SCIC_SDS_REMOTE_NODE_CONTEXT_AWAIT_SUSPENSION_STATE:
+	case SCI_RNC_AWAIT_SUSPENSION:
 		switch (scu_get_event_type(event_code)) {
 		case SCU_EVENT_TL_RNC_SUSPEND_TX:
-			sci_base_state_machine_change_state(&sci_rnc->state_machine,
-							    SCIC_SDS_REMOTE_NODE_CONTEXT_TX_SUSPENDED_STATE);
+			sci_change_state(&sci_rnc->sm, SCI_RNC_TX_SUSPENDED);
 			sci_rnc->suspension_code = scu_get_event_specifier(event_code);
 			break;
 		case SCU_EVENT_TL_RNC_SUSPEND_TX_RX:
-			sci_base_state_machine_change_state(&sci_rnc->state_machine,
-							    SCIC_SDS_REMOTE_NODE_CONTEXT_TX_RX_SUSPENDED_STATE);
+			sci_change_state(&sci_rnc->sm, SCI_RNC_TX_RX_SUSPENDED);
 			sci_rnc->suspension_code = scu_get_event_specifier(event_code);
 			break;
 		default:
@@ -493,22 +486,21 @@ enum sci_status scic_sds_remote_node_context_destruct(struct scic_sds_remote_nod
 {
 	enum scis_sds_remote_node_context_states state;
 
-	state = sci_rnc->state_machine.current_state_id;
+	state = sci_rnc->sm.current_state_id;
 	switch (state) {
-	case SCIC_SDS_REMOTE_NODE_CONTEXT_INVALIDATING_STATE:
+	case SCI_RNC_INVALIDATING:
 		scic_sds_remote_node_context_setup_to_destory(sci_rnc, cb_fn, cb_p);
 		return SCI_SUCCESS;
-	case SCIC_SDS_REMOTE_NODE_CONTEXT_POSTING_STATE:
-	case SCIC_SDS_REMOTE_NODE_CONTEXT_RESUMING_STATE:
-	case SCIC_SDS_REMOTE_NODE_CONTEXT_READY_STATE:
-	case SCIC_SDS_REMOTE_NODE_CONTEXT_TX_SUSPENDED_STATE:
-	case SCIC_SDS_REMOTE_NODE_CONTEXT_TX_RX_SUSPENDED_STATE:
-	case SCIC_SDS_REMOTE_NODE_CONTEXT_AWAIT_SUSPENSION_STATE:
+	case SCI_RNC_POSTING:
+	case SCI_RNC_RESUMING:
+	case SCI_RNC_READY:
+	case SCI_RNC_TX_SUSPENDED:
+	case SCI_RNC_TX_RX_SUSPENDED:
+	case SCI_RNC_AWAIT_SUSPENSION:
 		scic_sds_remote_node_context_setup_to_destory(sci_rnc, cb_fn, cb_p);
-		sci_base_state_machine_change_state(&sci_rnc->state_machine,
-						    SCIC_SDS_REMOTE_NODE_CONTEXT_INVALIDATING_STATE);
+		sci_change_state(&sci_rnc->sm, SCI_RNC_INVALIDATING);
 		return SCI_SUCCESS;
-	case SCIC_SDS_REMOTE_NODE_CONTEXT_INITIAL_STATE:
+	case SCI_RNC_INITIAL:
 		dev_warn(scirdev_to_dev(rnc_to_dev(sci_rnc)),
 			 "%s: invalid state %d\n", __func__, state);
 		/* We have decided that the destruct request on the remote node context
@@ -530,8 +522,8 @@ enum sci_status scic_sds_remote_node_context_suspend(struct scic_sds_remote_node
 {
 	enum scis_sds_remote_node_context_states state;
 
-	state = sci_rnc->state_machine.current_state_id;
-	if (state != SCIC_SDS_REMOTE_NODE_CONTEXT_READY_STATE) {
+	state = sci_rnc->sm.current_state_id;
+	if (state != SCI_RNC_READY) {
 		dev_warn(scirdev_to_dev(rnc_to_dev(sci_rnc)),
 			 "%s: invalid state %d\n", __func__, state);
 		return SCI_FAILURE_INVALID_STATE;
@@ -546,8 +538,7 @@ enum sci_status scic_sds_remote_node_context_suspend(struct scic_sds_remote_node
 						    SCU_CONTEXT_COMMAND_POST_RNC_SUSPEND_TX);
 	}
 
-	sci_base_state_machine_change_state(&sci_rnc->state_machine,
-					    SCIC_SDS_REMOTE_NODE_CONTEXT_AWAIT_SUSPENSION_STATE);
+	sci_change_state(&sci_rnc->sm, SCI_RNC_AWAIT_SUSPENSION);
 	return SCI_SUCCESS;
 }
 
@@ -557,27 +548,26 @@ enum sci_status scic_sds_remote_node_context_resume(struct scic_sds_remote_node_
 {
 	enum scis_sds_remote_node_context_states state;
 
-	state = sci_rnc->state_machine.current_state_id;
+	state = sci_rnc->sm.current_state_id;
 	switch (state) {
-	case SCIC_SDS_REMOTE_NODE_CONTEXT_INITIAL_STATE:
+	case SCI_RNC_INITIAL:
 		if (sci_rnc->remote_node_index == SCIC_SDS_REMOTE_NODE_CONTEXT_INVALID_INDEX)
 			return SCI_FAILURE_INVALID_STATE;
 
 		scic_sds_remote_node_context_setup_to_resume(sci_rnc, cb_fn, cb_p);
 		scic_sds_remote_node_context_construct_buffer(sci_rnc);
-		sci_base_state_machine_change_state(&sci_rnc->state_machine,
-						    SCIC_SDS_REMOTE_NODE_CONTEXT_POSTING_STATE);
+		sci_change_state(&sci_rnc->sm, SCI_RNC_POSTING);
 		return SCI_SUCCESS;
-	case SCIC_SDS_REMOTE_NODE_CONTEXT_POSTING_STATE:
-	case SCIC_SDS_REMOTE_NODE_CONTEXT_INVALIDATING_STATE:
-	case SCIC_SDS_REMOTE_NODE_CONTEXT_RESUMING_STATE:
+	case SCI_RNC_POSTING:
+	case SCI_RNC_INVALIDATING:
+	case SCI_RNC_RESUMING:
 		if (sci_rnc->destination_state != SCIC_SDS_REMOTE_NODE_DESTINATION_STATE_READY)
 			return SCI_FAILURE_INVALID_STATE;
 
 		sci_rnc->user_callback = cb_fn;
 		sci_rnc->user_cookie   = cb_p;
 		return SCI_SUCCESS;
-	case SCIC_SDS_REMOTE_NODE_CONTEXT_TX_SUSPENDED_STATE: {
+	case SCI_RNC_TX_SUSPENDED: {
 		struct scic_sds_remote_device *sci_dev = rnc_to_dev(sci_rnc);
 		struct domain_device *dev = sci_dev_to_domain(sci_dev);
 
@@ -585,27 +575,23 @@ enum sci_status scic_sds_remote_node_context_resume(struct scic_sds_remote_node_
 
 		/* TODO: consider adding a resume action of NONE, INVALIDATE, WRITE_TLCR */
 		if (dev->dev_type == SAS_END_DEV || dev_is_expander(dev))
-			sci_base_state_machine_change_state(&sci_rnc->state_machine,
-							    SCIC_SDS_REMOTE_NODE_CONTEXT_RESUMING_STATE);
+			sci_change_state(&sci_rnc->sm, SCI_RNC_RESUMING);
 		else if (dev->dev_type == SATA_DEV || (dev->tproto & SAS_PROTOCOL_STP)) {
 			if (sci_dev->is_direct_attached) {
 				/* @todo Fix this since I am being silly in writing to the STPTLDARNI register. */
-				sci_base_state_machine_change_state(&sci_rnc->state_machine,
-					SCIC_SDS_REMOTE_NODE_CONTEXT_RESUMING_STATE);
+				sci_change_state(&sci_rnc->sm, SCI_RNC_RESUMING);
 			} else {
-				sci_base_state_machine_change_state(&sci_rnc->state_machine,
-					SCIC_SDS_REMOTE_NODE_CONTEXT_INVALIDATING_STATE);
+				sci_change_state(&sci_rnc->sm, SCI_RNC_INVALIDATING);
 			}
 		} else
 			return SCI_FAILURE;
 		return SCI_SUCCESS;
 	}
-	case SCIC_SDS_REMOTE_NODE_CONTEXT_TX_RX_SUSPENDED_STATE:
+	case SCI_RNC_TX_RX_SUSPENDED:
 		scic_sds_remote_node_context_setup_to_resume(sci_rnc, cb_fn, cb_p);
-		sci_base_state_machine_change_state(&sci_rnc->state_machine,
-						    SCIC_SDS_REMOTE_NODE_CONTEXT_RESUMING_STATE);
+		sci_change_state(&sci_rnc->sm, SCI_RNC_RESUMING);
 		return SCI_FAILURE_INVALID_STATE;
-	case SCIC_SDS_REMOTE_NODE_CONTEXT_AWAIT_SUSPENSION_STATE:
+	case SCI_RNC_AWAIT_SUSPENSION:
 		scic_sds_remote_node_context_setup_to_resume(sci_rnc, cb_fn, cb_p);
 		return SCI_SUCCESS;
 	default:
@@ -620,8 +606,8 @@ enum sci_status scic_sds_remote_node_context_start_io(struct scic_sds_remote_nod
 {
 	enum scis_sds_remote_node_context_states state;
 
-	state = sci_rnc->state_machine.current_state_id;
-	if (state != SCIC_SDS_REMOTE_NODE_CONTEXT_READY_STATE) {
+	state = sci_rnc->sm.current_state_id;
+	if (state != SCI_RNC_READY) {
 		dev_warn(scirdev_to_dev(rnc_to_dev(sci_rnc)),
 			 "%s: invalid state %d\n", __func__, state);
 		return SCI_FAILURE_REMOTE_DEVICE_RESET_REQUIRED;
@@ -634,14 +620,14 @@ enum sci_status scic_sds_remote_node_context_start_task(struct scic_sds_remote_n
 {
 	enum scis_sds_remote_node_context_states state;
 
-	state = sci_rnc->state_machine.current_state_id;
+	state = sci_rnc->sm.current_state_id;
 	switch (state) {
-	case SCIC_SDS_REMOTE_NODE_CONTEXT_RESUMING_STATE:
-	case SCIC_SDS_REMOTE_NODE_CONTEXT_READY_STATE:
-	case SCIC_SDS_REMOTE_NODE_CONTEXT_AWAIT_SUSPENSION_STATE:
+	case SCI_RNC_RESUMING:
+	case SCI_RNC_READY:
+	case SCI_RNC_AWAIT_SUSPENSION:
 		return SCI_SUCCESS;
-	case SCIC_SDS_REMOTE_NODE_CONTEXT_TX_SUSPENDED_STATE:
-	case SCIC_SDS_REMOTE_NODE_CONTEXT_TX_RX_SUSPENDED_STATE:
+	case SCI_RNC_TX_SUSPENDED:
+	case SCI_RNC_TX_RX_SUSPENDED:
 		scic_sds_remote_node_context_resume(sci_rnc, NULL, NULL);
 		return SCI_SUCCESS;
 	default:

commit 9269e0e898594c65dee6b20d4ed48e33dbbd4eeb
Author: Dan Williams <dan.j.williams@intel.com>
Date:   Thu May 12 07:42:17 2011 -0700

    isci: add some type safety to the state machine interface
    
    Now that any given object type only has one state_machine we can use
    container_of() to get back to the given state machine owner.
    
    Reported-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/drivers/scsi/isci/remote_node_context.c b/drivers/scsi/isci/remote_node_context.c
index 82507bd228d4..e7fa5bac7d53 100644
--- a/drivers/scsi/isci/remote_node_context.c
+++ b/drivers/scsi/isci/remote_node_context.c
@@ -266,10 +266,9 @@ static void scic_sds_remote_node_context_invalidate_context_buffer(
 					    SCU_CONTEXT_COMMAND_POST_RNC_INVALIDATE);
 }
 
-static void scic_sds_remote_node_context_initial_state_enter(void *object)
+static void scic_sds_remote_node_context_initial_state_enter(struct sci_base_state_machine *sm)
 {
-	struct scic_sds_remote_node_context *rnc = object;
-	struct sci_base_state_machine *sm = &rnc->state_machine;
+	struct scic_sds_remote_node_context *rnc = container_of(sm, typeof(*rnc), state_machine);
 
 	/* Check to see if we have gotten back to the initial state because
 	 * someone requested to destroy the remote node context object.
@@ -280,23 +279,23 @@ static void scic_sds_remote_node_context_initial_state_enter(void *object)
 	}
 }
 
-static void scic_sds_remote_node_context_posting_state_enter(void *object)
+static void scic_sds_remote_node_context_posting_state_enter(struct sci_base_state_machine *sm)
 {
-	struct scic_sds_remote_node_context *sci_rnc = object;
+	struct scic_sds_remote_node_context *sci_rnc = container_of(sm, typeof(*sci_rnc), state_machine);
 
 	scic_sds_remote_node_context_validate_context_buffer(sci_rnc);
 }
 
-static void scic_sds_remote_node_context_invalidating_state_enter(void *object)
+static void scic_sds_remote_node_context_invalidating_state_enter(struct sci_base_state_machine *sm)
 {
-	struct scic_sds_remote_node_context *rnc = object;
+	struct scic_sds_remote_node_context *rnc = container_of(sm, typeof(*rnc), state_machine);
 
 	scic_sds_remote_node_context_invalidate_context_buffer(rnc);
 }
 
-static void scic_sds_remote_node_context_resuming_state_enter(void *object)
+static void scic_sds_remote_node_context_resuming_state_enter(struct sci_base_state_machine *sm)
 {
-	struct scic_sds_remote_node_context *rnc = object;
+	struct scic_sds_remote_node_context *rnc = container_of(sm, typeof(*rnc), state_machine);
 	struct scic_sds_remote_device *sci_dev;
 	struct domain_device *dev;
 
@@ -317,9 +316,9 @@ static void scic_sds_remote_node_context_resuming_state_enter(void *object)
 	scic_sds_remote_device_post_request(sci_dev, SCU_CONTEXT_COMMAND_POST_RNC_RESUME);
 }
 
-static void scic_sds_remote_node_context_ready_state_enter(void *object)
+static void scic_sds_remote_node_context_ready_state_enter(struct sci_base_state_machine *sm)
 {
-	struct scic_sds_remote_node_context *rnc = object;
+	struct scic_sds_remote_node_context *rnc = container_of(sm, typeof(*rnc), state_machine);
 
 	rnc->destination_state = SCIC_SDS_REMOTE_NODE_DESTINATION_STATE_UNSPECIFIED;
 
@@ -327,17 +326,16 @@ static void scic_sds_remote_node_context_ready_state_enter(void *object)
 		scic_sds_remote_node_context_notify_user(rnc);
 }
 
-static void scic_sds_remote_node_context_tx_suspended_state_enter(void *object)
+static void scic_sds_remote_node_context_tx_suspended_state_enter(struct sci_base_state_machine *sm)
 {
-	struct scic_sds_remote_node_context *rnc = object;
+	struct scic_sds_remote_node_context *rnc = container_of(sm, typeof(*rnc), state_machine);
 
 	scic_sds_remote_node_context_continue_state_transitions(rnc);
 }
 
-static void scic_sds_remote_node_context_tx_rx_suspended_state_enter(
-		void *object)
+static void scic_sds_remote_node_context_tx_rx_suspended_state_enter(struct sci_base_state_machine *sm)
 {
-	struct scic_sds_remote_node_context *rnc = object;
+	struct scic_sds_remote_node_context *rnc = container_of(sm, typeof(*rnc), state_machine);
 
 	scic_sds_remote_node_context_continue_state_transitions(rnc);
 }
@@ -375,12 +373,9 @@ void scic_sds_remote_node_context_construct(struct scic_sds_remote_node_context
 	rnc->remote_node_index = remote_node_index;
 	rnc->destination_state = SCIC_SDS_REMOTE_NODE_DESTINATION_STATE_UNSPECIFIED;
 
-	sci_base_state_machine_construct(
-		&rnc->state_machine,
-		rnc,
-		scic_sds_remote_node_context_state_table,
-		SCIC_SDS_REMOTE_NODE_CONTEXT_INITIAL_STATE
-		);
+	sci_base_state_machine_construct(&rnc->state_machine,
+					 scic_sds_remote_node_context_state_table,
+					 SCIC_SDS_REMOTE_NODE_CONTEXT_INITIAL_STATE);
 
 	sci_base_state_machine_start(&rnc->state_machine);
 }

commit f34d9e5d3f34f395a497a8747316b04ef3e865b1
Author: Dan Williams <dan.j.williams@intel.com>
Date:   Thu May 12 09:27:52 2011 -0700

    isci: unify rnc start{io|task} handlers
    
    Unify rnc start{io|task} handlers and delete the state handler
    infrastructure.
    
    Reported-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/drivers/scsi/isci/remote_node_context.c b/drivers/scsi/isci/remote_node_context.c
index 095d61288c3b..82507bd228d4 100644
--- a/drivers/scsi/isci/remote_node_context.c
+++ b/drivers/scsi/isci/remote_node_context.c
@@ -176,15 +176,6 @@ static void scic_sds_remote_node_context_setup_to_resume(
 	}
 }
 
-/**
- *
- * @sci_rnc:
- * @callback:
- * @callback_parameter:
- *
- * This method will setup the remote node context object so it will transistion
- * to its final state. none
- */
 static void scic_sds_remote_node_context_setup_to_destory(
 	struct scic_sds_remote_node_context *sci_rnc,
 	scics_sds_remote_node_context_callback callback,
@@ -195,146 +186,6 @@ static void scic_sds_remote_node_context_setup_to_destory(
 	sci_rnc->user_cookie       = callback_parameter;
 }
 
-static enum sci_status scic_sds_remote_node_context_default_start_io_handler(
-	struct scic_sds_remote_node_context *sci_rnc,
-	struct scic_sds_request *sci_req)
-{
-	dev_warn(scirdev_to_dev(rnc_to_dev(sci_rnc)),
-		 "%s: SCIC Remote Node Context 0x%p requested to start io "
-		 "0x%p while in wrong state %d\n",
-		 __func__,
-		 sci_rnc,
-		 sci_req,
-		 sci_base_state_machine_get_state(&sci_rnc->state_machine));
-
-	return SCI_FAILURE_REMOTE_DEVICE_RESET_REQUIRED;
-}
-
-static enum sci_status scic_sds_remote_node_context_default_start_task_handler(
-	struct scic_sds_remote_node_context *sci_rnc,
-	struct scic_sds_request *sci_req)
-{
-	dev_warn(scirdev_to_dev(rnc_to_dev(sci_rnc)),
-		 "%s: SCIC Remote Node Context 0x%p requested to start "
-		 "task 0x%p while in wrong state %d\n",
-		 __func__,
-		 sci_rnc,
-		 sci_req,
-		 sci_base_state_machine_get_state(&sci_rnc->state_machine));
-
-	return SCI_FAILURE;
-}
-
-/**
- *
- * @sci_rnc: The rnc for which the task request is targeted.
- * @sci_req: The request which is going to be started.
- *
- * This method determines if the task request can be started by the SCU
- * hardware. When the RNC is in the ready state any task can be started.
- * enum sci_status SCI_SUCCESS
- */
-static enum sci_status scic_sds_remote_node_context_success_start_task_handler(
-	struct scic_sds_remote_node_context *sci_rnc,
-	struct scic_sds_request *sci_req)
-{
-	return SCI_SUCCESS;
-}
-
-/**
- *
- * @sci_rnc: The rnc for which the io request is targeted.
- * @sci_req: The request which is going to be started.
- *
- * This method determines if the io request can be started by the SCU hardware.
- * When the RNC is in the ready state any io request can be started. enum sci_status
- * SCI_SUCCESS
- */
-static enum sci_status scic_sds_remote_node_context_ready_state_start_io_handler(
-	struct scic_sds_remote_node_context *sci_rnc,
-	struct scic_sds_request *sci_req)
-{
-	return SCI_SUCCESS;
-}
-
-/**
- *
- * @sci_rnc: The remote node context which is to receive the task request.
- * @sci_req: The task request to be transmitted to to the remote target
- *    device.
- *
- * This method will report a success or failure attempt to start a new task
- * request to the hardware.  Since all task requests are sent on the high
- * priority queue they can be sent when the RCN is in a TX suspend state.
- * enum sci_status SCI_SUCCESS
- */
-static enum sci_status scic_sds_remote_node_context_suspended_start_task_handler(
-	struct scic_sds_remote_node_context *sci_rnc,
-	struct scic_sds_request *sci_req)
-{
-	scic_sds_remote_node_context_resume(sci_rnc, NULL, NULL);
-
-	return SCI_SUCCESS;
-}
-
-/**
- *
- * @sci_rnc: The remote node context which is to receive the task request.
- * @sci_req: The task request to be transmitted to to the remote target
- *    device.
- *
- * This method will report a success or failure attempt to start a new task
- * request to the hardware.  Since all task requests are sent on the high
- * priority queue they can be sent when the RCN is in a TX suspend state.
- * enum sci_status SCI_SUCCESS
- */
-static enum sci_status scic_sds_remote_node_context_await_suspension_state_start_task_handler(
-	struct scic_sds_remote_node_context *sci_rnc,
-	struct scic_sds_request *sci_req)
-{
-	return SCI_SUCCESS;
-}
-
-static struct scic_sds_remote_node_context_handlers scic_sds_remote_node_context_state_handler_table[] = {
-	[SCIC_SDS_REMOTE_NODE_CONTEXT_INITIAL_STATE] = {
-		.start_io_handler	= scic_sds_remote_node_context_default_start_io_handler,
-		.start_task_handler	= scic_sds_remote_node_context_default_start_task_handler,
-	},
-	[SCIC_SDS_REMOTE_NODE_CONTEXT_POSTING_STATE] = {
-		.start_io_handler	= scic_sds_remote_node_context_default_start_io_handler,
-		.start_task_handler	= scic_sds_remote_node_context_default_start_task_handler,
-	},
-	[SCIC_SDS_REMOTE_NODE_CONTEXT_INVALIDATING_STATE] = {
-		.start_io_handler	= scic_sds_remote_node_context_default_start_io_handler,
-		.start_task_handler	= scic_sds_remote_node_context_default_start_task_handler,
-	},
-	[SCIC_SDS_REMOTE_NODE_CONTEXT_RESUMING_STATE] = {
-		.start_io_handler	= scic_sds_remote_node_context_default_start_io_handler,
-		.start_task_handler	= scic_sds_remote_node_context_success_start_task_handler,
-	},
-	[SCIC_SDS_REMOTE_NODE_CONTEXT_READY_STATE] = {
-		.start_io_handler	= scic_sds_remote_node_context_ready_state_start_io_handler,
-		.start_task_handler	= scic_sds_remote_node_context_success_start_task_handler,
-	},
-	[SCIC_SDS_REMOTE_NODE_CONTEXT_TX_SUSPENDED_STATE] = {
-		.start_io_handler	= scic_sds_remote_node_context_default_start_io_handler,
-		.start_task_handler	= scic_sds_remote_node_context_suspended_start_task_handler,
-	},
-	[SCIC_SDS_REMOTE_NODE_CONTEXT_TX_RX_SUSPENDED_STATE] = {
-		.start_io_handler	= scic_sds_remote_node_context_default_start_io_handler,
-		.start_task_handler	= scic_sds_remote_node_context_suspended_start_task_handler,
-	},
-	[SCIC_SDS_REMOTE_NODE_CONTEXT_AWAIT_SUSPENSION_STATE] = {
-		.start_io_handler	= scic_sds_remote_node_context_default_start_io_handler,
-		.start_task_handler	= scic_sds_remote_node_context_await_suspension_state_start_task_handler,
-	}
-};
-
-/*
- * *****************************************************************************
- * * REMOTE NODE CONTEXT PRIVATE METHODS
- * ***************************************************************************** */
-
 /**
  *
  *
@@ -415,80 +266,34 @@ static void scic_sds_remote_node_context_invalidate_context_buffer(
 					    SCU_CONTEXT_COMMAND_POST_RNC_INVALIDATE);
 }
 
-/*
- * *****************************************************************************
- * * REMOTE NODE CONTEXT STATE ENTER AND EXIT METHODS
- * ***************************************************************************** */
-
-/**
- *
- *
- *
- */
 static void scic_sds_remote_node_context_initial_state_enter(void *object)
 {
 	struct scic_sds_remote_node_context *rnc = object;
+	struct sci_base_state_machine *sm = &rnc->state_machine;
 
-	SET_STATE_HANDLER(
-		rnc,
-		scic_sds_remote_node_context_state_handler_table,
-		SCIC_SDS_REMOTE_NODE_CONTEXT_INITIAL_STATE
-		);
-
-	/*
-	 * Check to see if we have gotten back to the initial state because someone
-	 * requested to destroy the remote node context object. */
-	if (
-		rnc->state_machine.previous_state_id
-		== SCIC_SDS_REMOTE_NODE_CONTEXT_INVALIDATING_STATE
-		) {
+	/* Check to see if we have gotten back to the initial state because
+	 * someone requested to destroy the remote node context object.
+	 */
+	if (sm->previous_state_id == SCIC_SDS_REMOTE_NODE_CONTEXT_INVALIDATING_STATE) {
 		rnc->destination_state = SCIC_SDS_REMOTE_NODE_DESTINATION_STATE_UNSPECIFIED;
-
 		scic_sds_remote_node_context_notify_user(rnc);
 	}
 }
 
-/**
- *
- *
- *
- */
 static void scic_sds_remote_node_context_posting_state_enter(void *object)
 {
 	struct scic_sds_remote_node_context *sci_rnc = object;
 
-	SET_STATE_HANDLER(
-		sci_rnc,
-		scic_sds_remote_node_context_state_handler_table,
-		SCIC_SDS_REMOTE_NODE_CONTEXT_POSTING_STATE
-		);
-
 	scic_sds_remote_node_context_validate_context_buffer(sci_rnc);
 }
 
-/**
- *
- *
- *
- */
 static void scic_sds_remote_node_context_invalidating_state_enter(void *object)
 {
 	struct scic_sds_remote_node_context *rnc = object;
 
-	SET_STATE_HANDLER(
-		rnc,
-		scic_sds_remote_node_context_state_handler_table,
-		SCIC_SDS_REMOTE_NODE_CONTEXT_INVALIDATING_STATE
-		);
-
 	scic_sds_remote_node_context_invalidate_context_buffer(rnc);
 }
 
-/**
- *
- *
- *
- */
 static void scic_sds_remote_node_context_resuming_state_enter(void *object)
 {
 	struct scic_sds_remote_node_context *rnc = object;
@@ -498,12 +303,6 @@ static void scic_sds_remote_node_context_resuming_state_enter(void *object)
 	sci_dev = rnc_to_dev(rnc);
 	dev = sci_dev_to_domain(sci_dev);
 
-	SET_STATE_HANDLER(
-		rnc,
-		scic_sds_remote_node_context_state_handler_table,
-		SCIC_SDS_REMOTE_NODE_CONTEXT_RESUMING_STATE
-		);
-
 	/*
 	 * For direct attached SATA devices we need to clear the TLCR
 	 * NCQ to TCi tag mapping on the phy and in cases where we
@@ -518,84 +317,31 @@ static void scic_sds_remote_node_context_resuming_state_enter(void *object)
 	scic_sds_remote_device_post_request(sci_dev, SCU_CONTEXT_COMMAND_POST_RNC_RESUME);
 }
 
-/**
- *
- *
- *
- */
 static void scic_sds_remote_node_context_ready_state_enter(void *object)
 {
 	struct scic_sds_remote_node_context *rnc = object;
 
-	SET_STATE_HANDLER(
-		rnc,
-		scic_sds_remote_node_context_state_handler_table,
-		SCIC_SDS_REMOTE_NODE_CONTEXT_READY_STATE
-		);
-
 	rnc->destination_state = SCIC_SDS_REMOTE_NODE_DESTINATION_STATE_UNSPECIFIED;
 
-	if (rnc->user_callback != NULL) {
+	if (rnc->user_callback)
 		scic_sds_remote_node_context_notify_user(rnc);
-	}
 }
 
-/**
- *
- *
- *
- */
 static void scic_sds_remote_node_context_tx_suspended_state_enter(void *object)
 {
 	struct scic_sds_remote_node_context *rnc = object;
 
-	SET_STATE_HANDLER(
-		rnc,
-		scic_sds_remote_node_context_state_handler_table,
-		SCIC_SDS_REMOTE_NODE_CONTEXT_TX_SUSPENDED_STATE
-		);
-
 	scic_sds_remote_node_context_continue_state_transitions(rnc);
 }
 
-/**
- *
- *
- *
- */
 static void scic_sds_remote_node_context_tx_rx_suspended_state_enter(
 		void *object)
 {
 	struct scic_sds_remote_node_context *rnc = object;
 
-	SET_STATE_HANDLER(
-		rnc,
-		scic_sds_remote_node_context_state_handler_table,
-		SCIC_SDS_REMOTE_NODE_CONTEXT_TX_RX_SUSPENDED_STATE
-		);
-
 	scic_sds_remote_node_context_continue_state_transitions(rnc);
 }
 
-/**
- *
- *
- *
- */
-static void scic_sds_remote_node_context_await_suspension_state_enter(
-	void *object)
-{
-	struct scic_sds_remote_node_context *rnc = object;
-
-	SET_STATE_HANDLER(
-		rnc,
-		scic_sds_remote_node_context_state_handler_table,
-		SCIC_SDS_REMOTE_NODE_CONTEXT_AWAIT_SUSPENSION_STATE
-		);
-}
-
-/* --------------------------------------------------------------------------- */
-
 static const struct sci_base_state scic_sds_remote_node_context_state_table[] = {
 	[SCIC_SDS_REMOTE_NODE_CONTEXT_INITIAL_STATE] = {
 		.enter_state = scic_sds_remote_node_context_initial_state_enter,
@@ -618,9 +364,7 @@ static const struct sci_base_state scic_sds_remote_node_context_state_table[] =
 	[SCIC_SDS_REMOTE_NODE_CONTEXT_TX_RX_SUSPENDED_STATE] = {
 		.enter_state = scic_sds_remote_node_context_tx_rx_suspended_state_enter,
 	},
-	[SCIC_SDS_REMOTE_NODE_CONTEXT_AWAIT_SUSPENSION_STATE] = {
-		.enter_state = scic_sds_remote_node_context_await_suspension_state_enter,
-	},
+	[SCIC_SDS_REMOTE_NODE_CONTEXT_AWAIT_SUSPENSION_STATE] = { },
 };
 
 void scic_sds_remote_node_context_construct(struct scic_sds_remote_node_context *rnc,
@@ -875,3 +619,39 @@ enum sci_status scic_sds_remote_node_context_resume(struct scic_sds_remote_node_
 		return SCI_FAILURE_INVALID_STATE;
 	}
 }
+
+enum sci_status scic_sds_remote_node_context_start_io(struct scic_sds_remote_node_context *sci_rnc,
+							     struct scic_sds_request *sci_req)
+{
+	enum scis_sds_remote_node_context_states state;
+
+	state = sci_rnc->state_machine.current_state_id;
+	if (state != SCIC_SDS_REMOTE_NODE_CONTEXT_READY_STATE) {
+		dev_warn(scirdev_to_dev(rnc_to_dev(sci_rnc)),
+			 "%s: invalid state %d\n", __func__, state);
+		return SCI_FAILURE_REMOTE_DEVICE_RESET_REQUIRED;
+	}
+	return SCI_SUCCESS;
+}
+
+enum sci_status scic_sds_remote_node_context_start_task(struct scic_sds_remote_node_context *sci_rnc,
+							struct scic_sds_request *sci_req)
+{
+	enum scis_sds_remote_node_context_states state;
+
+	state = sci_rnc->state_machine.current_state_id;
+	switch (state) {
+	case SCIC_SDS_REMOTE_NODE_CONTEXT_RESUMING_STATE:
+	case SCIC_SDS_REMOTE_NODE_CONTEXT_READY_STATE:
+	case SCIC_SDS_REMOTE_NODE_CONTEXT_AWAIT_SUSPENSION_STATE:
+		return SCI_SUCCESS;
+	case SCIC_SDS_REMOTE_NODE_CONTEXT_TX_SUSPENDED_STATE:
+	case SCIC_SDS_REMOTE_NODE_CONTEXT_TX_RX_SUSPENDED_STATE:
+		scic_sds_remote_node_context_resume(sci_rnc, NULL, NULL);
+		return SCI_SUCCESS;
+	default:
+		dev_warn(scirdev_to_dev(rnc_to_dev(sci_rnc)),
+			 "%s: invalid state %d\n", __func__, state);
+		return SCI_FAILURE_INVALID_STATE;
+	}
+}

commit ed3efb7784cb0772558e9cc9440bd6c9a3139be4
Author: Dan Williams <dan.j.williams@intel.com>
Date:   Thu May 12 08:50:23 2011 -0700

    isci: unify rnc suspend/resume handlers
    
    Unify rnc suspend/resume handlers and delete the state handlers.
    
    Reported-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/drivers/scsi/isci/remote_node_context.c b/drivers/scsi/isci/remote_node_context.c
index 769a3fc6ec4b..095d61288c3b 100644
--- a/drivers/scsi/isci/remote_node_context.c
+++ b/drivers/scsi/isci/remote_node_context.c
@@ -195,60 +195,6 @@ static void scic_sds_remote_node_context_setup_to_destory(
 	sci_rnc->user_cookie       = callback_parameter;
 }
 
-/**
- *
- * @sci_rnc:
- * @callback:
- *
- * This method will continue to resume a remote node context.  This is used in
- * the states where a resume is requested while a resume is in progress.
- */
-static enum sci_status scic_sds_remote_node_context_continue_to_resume_handler(
-	struct scic_sds_remote_node_context *sci_rnc,
-	scics_sds_remote_node_context_callback callback,
-	void *callback_parameter)
-{
-	if (sci_rnc->destination_state == SCIC_SDS_REMOTE_NODE_DESTINATION_STATE_READY) {
-		sci_rnc->user_callback = callback;
-		sci_rnc->user_cookie   = callback_parameter;
-
-		return SCI_SUCCESS;
-	}
-
-	return SCI_FAILURE_INVALID_STATE;
-}
-
-static enum sci_status scic_sds_remote_node_context_default_suspend_handler(
-	struct scic_sds_remote_node_context *sci_rnc,
-	u32 suspend_type,
-	scics_sds_remote_node_context_callback callback,
-	void *callback_parameter)
-{
-	dev_warn(scirdev_to_dev(rnc_to_dev(sci_rnc)),
-		 "%s: SCIC Remote Node Context 0x%p requested to suspend "
-		 "while in wrong state %d\n",
-		 __func__,
-		 sci_rnc,
-		 sci_base_state_machine_get_state(&sci_rnc->state_machine));
-
-	return SCI_FAILURE_INVALID_STATE;
-}
-
-static enum sci_status scic_sds_remote_node_context_default_resume_handler(
-	struct scic_sds_remote_node_context *sci_rnc,
-	scics_sds_remote_node_context_callback callback,
-	void *callback_parameter)
-{
-	dev_warn(scirdev_to_dev(rnc_to_dev(sci_rnc)),
-		 "%s: SCIC Remote Node Context 0x%p requested to resume "
-		 "while in wrong state %d\n",
-		 __func__,
-		 sci_rnc,
-		 sci_base_state_machine_get_state(&sci_rnc->state_machine));
-
-	return SCI_FAILURE_INVALID_STATE;
-}
-
 static enum sci_status scic_sds_remote_node_context_default_start_io_handler(
 	struct scic_sds_remote_node_context *sci_rnc,
 	struct scic_sds_request *sci_req)
@@ -295,61 +241,6 @@ static enum sci_status scic_sds_remote_node_context_success_start_task_handler(
 	return SCI_SUCCESS;
 }
 
-static enum sci_status scic_sds_remote_node_context_initial_state_resume_handler(
-	struct scic_sds_remote_node_context *sci_rnc,
-	scics_sds_remote_node_context_callback callback,
-	void *callback_parameter)
-{
-	if (sci_rnc->remote_node_index != SCIC_SDS_REMOTE_NODE_CONTEXT_INVALID_INDEX) {
-		scic_sds_remote_node_context_setup_to_resume(
-			sci_rnc, callback, callback_parameter
-			);
-
-		scic_sds_remote_node_context_construct_buffer(sci_rnc);
-
-		sci_base_state_machine_change_state(
-			&sci_rnc->state_machine,
-			SCIC_SDS_REMOTE_NODE_CONTEXT_POSTING_STATE
-			);
-
-		return SCI_SUCCESS;
-	}
-
-	return SCI_FAILURE_INVALID_STATE;
-}
-
-/**
- *
- * @sci_rnc: The remote node context object being suspended.
- * @callback: The callback when the suspension is complete.
- * @callback_parameter: The parameter that is to be passed into the callback.
- *
- * This method will handle the suspend requests from the ready state.
- * SCI_SUCCESS
- */
-static enum sci_status scic_sds_remote_node_context_ready_state_suspend_handler(
-	struct scic_sds_remote_node_context *sci_rnc,
-	u32 suspend_type,
-	scics_sds_remote_node_context_callback callback,
-	void *callback_parameter)
-{
-	sci_rnc->user_callback   = callback;
-	sci_rnc->user_cookie     = callback_parameter;
-	sci_rnc->suspension_code = suspend_type;
-
-	if (suspend_type == SCI_SOFTWARE_SUSPENSION) {
-		scic_sds_remote_device_post_request(rnc_to_dev(sci_rnc),
-						    SCU_CONTEXT_COMMAND_POST_RNC_SUSPEND_TX);
-	}
-
-	sci_base_state_machine_change_state(
-		&sci_rnc->state_machine,
-		SCIC_SDS_REMOTE_NODE_CONTEXT_AWAIT_SUSPENSION_STATE
-		);
-
-	return SCI_SUCCESS;
-}
-
 /**
  *
  * @sci_rnc: The rnc for which the io request is targeted.
@@ -366,39 +257,6 @@ static enum sci_status scic_sds_remote_node_context_ready_state_start_io_handler
 	return SCI_SUCCESS;
 }
 
-static enum sci_status scic_sds_remote_node_context_tx_suspended_state_resume_handler(
-	struct scic_sds_remote_node_context *sci_rnc,
-	scics_sds_remote_node_context_callback callback,
-	void *callback_parameter)
-{
-	struct scic_sds_remote_device *sci_dev = rnc_to_dev(sci_rnc);
-	struct domain_device *dev = sci_dev_to_domain(sci_dev);
-	enum sci_status status = SCI_SUCCESS;
-
-	scic_sds_remote_node_context_setup_to_resume(sci_rnc, callback,
-						     callback_parameter);
-
-	/* TODO: consider adding a resume action of NONE, INVALIDATE, WRITE_TLCR */
-	if (dev->dev_type == SAS_END_DEV || dev_is_expander(dev))
-		sci_base_state_machine_change_state(&sci_rnc->state_machine,
-						    SCIC_SDS_REMOTE_NODE_CONTEXT_RESUMING_STATE);
-	else if (dev->dev_type == SATA_DEV || (dev->tproto & SAS_PROTOCOL_STP)) {
-		if (sci_dev->is_direct_attached) {
-			/* @todo Fix this since I am being silly in writing to the STPTLDARNI register. */
-			sci_base_state_machine_change_state(
-				&sci_rnc->state_machine,
-				SCIC_SDS_REMOTE_NODE_CONTEXT_RESUMING_STATE);
-		} else {
-			sci_base_state_machine_change_state(
-				&sci_rnc->state_machine,
-				SCIC_SDS_REMOTE_NODE_CONTEXT_INVALIDATING_STATE);
-		}
-	} else
-		status = SCI_FAILURE;
-
-	return status;
-}
-
 /**
  *
  * @sci_rnc: The remote node context which is to receive the task request.
@@ -419,44 +277,6 @@ static enum sci_status scic_sds_remote_node_context_suspended_start_task_handler
 	return SCI_SUCCESS;
 }
 
-/* --------------------------------------------------------------------------- */
-
-static enum sci_status scic_sds_remote_node_context_tx_rx_suspended_state_resume_handler(
-	struct scic_sds_remote_node_context *sci_rnc,
-	scics_sds_remote_node_context_callback callback,
-	void *callback_parameter)
-{
-	scic_sds_remote_node_context_setup_to_resume(
-		sci_rnc, callback, callback_parameter
-		);
-
-	sci_base_state_machine_change_state(
-		&sci_rnc->state_machine,
-		SCIC_SDS_REMOTE_NODE_CONTEXT_RESUMING_STATE
-		);
-
-	return SCI_FAILURE_INVALID_STATE;
-}
-
-/* --------------------------------------------------------------------------- */
-
-/**
- *
- *
- *
- */
-static enum sci_status scic_sds_remote_node_context_await_suspension_state_resume_handler(
-	struct scic_sds_remote_node_context *sci_rnc,
-	scics_sds_remote_node_context_callback callback,
-	void *callback_parameter)
-{
-	scic_sds_remote_node_context_setup_to_resume(
-		sci_rnc, callback, callback_parameter
-		);
-
-	return SCI_SUCCESS;
-}
-
 /**
  *
  * @sci_rnc: The remote node context which is to receive the task request.
@@ -477,50 +297,34 @@ static enum sci_status scic_sds_remote_node_context_await_suspension_state_start
 
 static struct scic_sds_remote_node_context_handlers scic_sds_remote_node_context_state_handler_table[] = {
 	[SCIC_SDS_REMOTE_NODE_CONTEXT_INITIAL_STATE] = {
-		.suspend_handler	= scic_sds_remote_node_context_default_suspend_handler,
-		.resume_handler		= scic_sds_remote_node_context_initial_state_resume_handler,
 		.start_io_handler	= scic_sds_remote_node_context_default_start_io_handler,
 		.start_task_handler	= scic_sds_remote_node_context_default_start_task_handler,
 	},
 	[SCIC_SDS_REMOTE_NODE_CONTEXT_POSTING_STATE] = {
-		.suspend_handler	= scic_sds_remote_node_context_default_suspend_handler,
-		.resume_handler		= scic_sds_remote_node_context_continue_to_resume_handler,
 		.start_io_handler	= scic_sds_remote_node_context_default_start_io_handler,
 		.start_task_handler	= scic_sds_remote_node_context_default_start_task_handler,
 	},
 	[SCIC_SDS_REMOTE_NODE_CONTEXT_INVALIDATING_STATE] = {
-		.suspend_handler	= scic_sds_remote_node_context_default_suspend_handler,
-		.resume_handler		= scic_sds_remote_node_context_continue_to_resume_handler,
 		.start_io_handler	= scic_sds_remote_node_context_default_start_io_handler,
 		.start_task_handler	= scic_sds_remote_node_context_default_start_task_handler,
 	},
 	[SCIC_SDS_REMOTE_NODE_CONTEXT_RESUMING_STATE] = {
-		.suspend_handler	= scic_sds_remote_node_context_default_suspend_handler,
-		.resume_handler		= scic_sds_remote_node_context_continue_to_resume_handler,
 		.start_io_handler	= scic_sds_remote_node_context_default_start_io_handler,
 		.start_task_handler	= scic_sds_remote_node_context_success_start_task_handler,
 	},
 	[SCIC_SDS_REMOTE_NODE_CONTEXT_READY_STATE] = {
-		.suspend_handler	= scic_sds_remote_node_context_ready_state_suspend_handler,
-		.resume_handler		= scic_sds_remote_node_context_default_resume_handler,
 		.start_io_handler	= scic_sds_remote_node_context_ready_state_start_io_handler,
 		.start_task_handler	= scic_sds_remote_node_context_success_start_task_handler,
 	},
 	[SCIC_SDS_REMOTE_NODE_CONTEXT_TX_SUSPENDED_STATE] = {
-		.suspend_handler	= scic_sds_remote_node_context_default_suspend_handler,
-		.resume_handler		= scic_sds_remote_node_context_tx_suspended_state_resume_handler,
 		.start_io_handler	= scic_sds_remote_node_context_default_start_io_handler,
 		.start_task_handler	= scic_sds_remote_node_context_suspended_start_task_handler,
 	},
 	[SCIC_SDS_REMOTE_NODE_CONTEXT_TX_RX_SUSPENDED_STATE] = {
-		.suspend_handler	= scic_sds_remote_node_context_default_suspend_handler,
-		.resume_handler		= scic_sds_remote_node_context_tx_rx_suspended_state_resume_handler,
 		.start_io_handler	= scic_sds_remote_node_context_default_start_io_handler,
 		.start_task_handler	= scic_sds_remote_node_context_suspended_start_task_handler,
 	},
 	[SCIC_SDS_REMOTE_NODE_CONTEXT_AWAIT_SUSPENSION_STATE] = {
-		.suspend_handler	= scic_sds_remote_node_context_default_suspend_handler,
-		.resume_handler		= scic_sds_remote_node_context_await_suspension_state_resume_handler,
 		.start_io_handler	= scic_sds_remote_node_context_default_start_io_handler,
 		.start_task_handler	= scic_sds_remote_node_context_await_suspension_state_start_task_handler,
 	}
@@ -548,21 +352,11 @@ static void scic_sds_remote_node_context_notify_user(
 	}
 }
 
-/**
- *
- *
- * This method will continue the remote node context state machine by
- * requesting to resume the remote node context state machine from its current
- * state.
- */
-static void scic_sds_remote_node_context_continue_state_transitions(
-	struct scic_sds_remote_node_context *rnc)
+static void scic_sds_remote_node_context_continue_state_transitions(struct scic_sds_remote_node_context *rnc)
 {
-	if (rnc->destination_state == SCIC_SDS_REMOTE_NODE_DESTINATION_STATE_READY) {
-		rnc->state_handlers->resume_handler(
-			rnc, rnc->user_callback, rnc->user_cookie
-			);
-	}
+	if (rnc->destination_state == SCIC_SDS_REMOTE_NODE_DESTINATION_STATE_READY)
+		scic_sds_remote_node_context_resume(rnc, rnc->user_callback,
+						    rnc->user_cookie);
 }
 
 /**
@@ -989,3 +783,95 @@ enum sci_status scic_sds_remote_node_context_destruct(struct scic_sds_remote_nod
 		return SCI_FAILURE_INVALID_STATE;
 	}
 }
+
+enum sci_status scic_sds_remote_node_context_suspend(struct scic_sds_remote_node_context *sci_rnc,
+						     u32 suspend_type,
+						     scics_sds_remote_node_context_callback cb_fn,
+						     void *cb_p)
+{
+	enum scis_sds_remote_node_context_states state;
+
+	state = sci_rnc->state_machine.current_state_id;
+	if (state != SCIC_SDS_REMOTE_NODE_CONTEXT_READY_STATE) {
+		dev_warn(scirdev_to_dev(rnc_to_dev(sci_rnc)),
+			 "%s: invalid state %d\n", __func__, state);
+		return SCI_FAILURE_INVALID_STATE;
+	}
+
+	sci_rnc->user_callback   = cb_fn;
+	sci_rnc->user_cookie     = cb_p;
+	sci_rnc->suspension_code = suspend_type;
+
+	if (suspend_type == SCI_SOFTWARE_SUSPENSION) {
+		scic_sds_remote_device_post_request(rnc_to_dev(sci_rnc),
+						    SCU_CONTEXT_COMMAND_POST_RNC_SUSPEND_TX);
+	}
+
+	sci_base_state_machine_change_state(&sci_rnc->state_machine,
+					    SCIC_SDS_REMOTE_NODE_CONTEXT_AWAIT_SUSPENSION_STATE);
+	return SCI_SUCCESS;
+}
+
+enum sci_status scic_sds_remote_node_context_resume(struct scic_sds_remote_node_context *sci_rnc,
+						    scics_sds_remote_node_context_callback cb_fn,
+						    void *cb_p)
+{
+	enum scis_sds_remote_node_context_states state;
+
+	state = sci_rnc->state_machine.current_state_id;
+	switch (state) {
+	case SCIC_SDS_REMOTE_NODE_CONTEXT_INITIAL_STATE:
+		if (sci_rnc->remote_node_index == SCIC_SDS_REMOTE_NODE_CONTEXT_INVALID_INDEX)
+			return SCI_FAILURE_INVALID_STATE;
+
+		scic_sds_remote_node_context_setup_to_resume(sci_rnc, cb_fn, cb_p);
+		scic_sds_remote_node_context_construct_buffer(sci_rnc);
+		sci_base_state_machine_change_state(&sci_rnc->state_machine,
+						    SCIC_SDS_REMOTE_NODE_CONTEXT_POSTING_STATE);
+		return SCI_SUCCESS;
+	case SCIC_SDS_REMOTE_NODE_CONTEXT_POSTING_STATE:
+	case SCIC_SDS_REMOTE_NODE_CONTEXT_INVALIDATING_STATE:
+	case SCIC_SDS_REMOTE_NODE_CONTEXT_RESUMING_STATE:
+		if (sci_rnc->destination_state != SCIC_SDS_REMOTE_NODE_DESTINATION_STATE_READY)
+			return SCI_FAILURE_INVALID_STATE;
+
+		sci_rnc->user_callback = cb_fn;
+		sci_rnc->user_cookie   = cb_p;
+		return SCI_SUCCESS;
+	case SCIC_SDS_REMOTE_NODE_CONTEXT_TX_SUSPENDED_STATE: {
+		struct scic_sds_remote_device *sci_dev = rnc_to_dev(sci_rnc);
+		struct domain_device *dev = sci_dev_to_domain(sci_dev);
+
+		scic_sds_remote_node_context_setup_to_resume(sci_rnc, cb_fn, cb_p);
+
+		/* TODO: consider adding a resume action of NONE, INVALIDATE, WRITE_TLCR */
+		if (dev->dev_type == SAS_END_DEV || dev_is_expander(dev))
+			sci_base_state_machine_change_state(&sci_rnc->state_machine,
+							    SCIC_SDS_REMOTE_NODE_CONTEXT_RESUMING_STATE);
+		else if (dev->dev_type == SATA_DEV || (dev->tproto & SAS_PROTOCOL_STP)) {
+			if (sci_dev->is_direct_attached) {
+				/* @todo Fix this since I am being silly in writing to the STPTLDARNI register. */
+				sci_base_state_machine_change_state(&sci_rnc->state_machine,
+					SCIC_SDS_REMOTE_NODE_CONTEXT_RESUMING_STATE);
+			} else {
+				sci_base_state_machine_change_state(&sci_rnc->state_machine,
+					SCIC_SDS_REMOTE_NODE_CONTEXT_INVALIDATING_STATE);
+			}
+		} else
+			return SCI_FAILURE;
+		return SCI_SUCCESS;
+	}
+	case SCIC_SDS_REMOTE_NODE_CONTEXT_TX_RX_SUSPENDED_STATE:
+		scic_sds_remote_node_context_setup_to_resume(sci_rnc, cb_fn, cb_p);
+		sci_base_state_machine_change_state(&sci_rnc->state_machine,
+						    SCIC_SDS_REMOTE_NODE_CONTEXT_RESUMING_STATE);
+		return SCI_FAILURE_INVALID_STATE;
+	case SCIC_SDS_REMOTE_NODE_CONTEXT_AWAIT_SUSPENSION_STATE:
+		scic_sds_remote_node_context_setup_to_resume(sci_rnc, cb_fn, cb_p);
+		return SCI_SUCCESS;
+	default:
+		dev_warn(scirdev_to_dev(rnc_to_dev(sci_rnc)),
+			 "%s: invalid state %d\n", __func__, state);
+		return SCI_FAILURE_INVALID_STATE;
+	}
+}

commit c845ae96bcb1625a093003248ffaf13b92a81ac2
Author: Dan Williams <dan.j.williams@intel.com>
Date:   Thu May 12 08:26:56 2011 -0700

    isci: unify rnc destruct handlers
    
    Unify rnc destruct handlers and delete the state handler.
    
    Reported-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/drivers/scsi/isci/remote_node_context.c b/drivers/scsi/isci/remote_node_context.c
index 9f2407f0f5a6..769a3fc6ec4b 100644
--- a/drivers/scsi/isci/remote_node_context.c
+++ b/drivers/scsi/isci/remote_node_context.c
@@ -218,26 +218,6 @@ static enum sci_status scic_sds_remote_node_context_continue_to_resume_handler(
 	return SCI_FAILURE_INVALID_STATE;
 }
 
-/* --------------------------------------------------------------------------- */
-
-static enum sci_status scic_sds_remote_node_context_default_destruct_handler(
-	struct scic_sds_remote_node_context *sci_rnc,
-	scics_sds_remote_node_context_callback callback,
-	void *callback_parameter)
-{
-	dev_warn(scirdev_to_dev(rnc_to_dev(sci_rnc)),
-		 "%s: SCIC Remote Node Context 0x%p requested to stop while "
-		 "in unexpected state %d\n",
-		 __func__,
-		 sci_rnc,
-		 sci_base_state_machine_get_state(&sci_rnc->state_machine));
-
-	/*
-	 * We have decided that the destruct request on the remote node context can not fail
-	 * since it is either in the initial/destroyed state or is can be destroyed. */
-	return SCI_SUCCESS;
-}
-
 static enum sci_status scic_sds_remote_node_context_default_suspend_handler(
 	struct scic_sds_remote_node_context *sci_rnc,
 	u32 suspend_type,
@@ -315,36 +295,6 @@ static enum sci_status scic_sds_remote_node_context_success_start_task_handler(
 	return SCI_SUCCESS;
 }
 
-/**
- *
- * @sci_rnc:
- * @callback:
- * @callback_parameter:
- *
- * This method handles destruct calls from the various state handlers.  The
- * remote node context can be requested to destroy from any state. If there was
- * a user callback it is always replaced with the request to destroy user
- * callback. enum sci_status
- */
-static enum sci_status scic_sds_remote_node_context_general_destruct_handler(
-	struct scic_sds_remote_node_context *sci_rnc,
-	scics_sds_remote_node_context_callback callback,
-	void *callback_parameter)
-{
-	scic_sds_remote_node_context_setup_to_destory(
-		sci_rnc, callback, callback_parameter
-		);
-
-	sci_base_state_machine_change_state(
-		&sci_rnc->state_machine,
-		SCIC_SDS_REMOTE_NODE_CONTEXT_INVALIDATING_STATE
-		);
-
-	return SCI_SUCCESS;
-}
-
-/* --------------------------------------------------------------------------- */
-
 static enum sci_status scic_sds_remote_node_context_initial_state_resume_handler(
 	struct scic_sds_remote_node_context *sci_rnc,
 	scics_sds_remote_node_context_callback callback,
@@ -368,18 +318,6 @@ static enum sci_status scic_sds_remote_node_context_initial_state_resume_handler
 	return SCI_FAILURE_INVALID_STATE;
 }
 
-static enum sci_status scic_sds_remote_node_context_invalidating_state_destruct_handler(
-	struct scic_sds_remote_node_context *sci_rnc,
-	scics_sds_remote_node_context_callback callback,
-	void *callback_parameter)
-{
-	scic_sds_remote_node_context_setup_to_destory(
-		sci_rnc, callback, callback_parameter
-		);
-
-	return SCI_SUCCESS;
-}
-
 /**
  *
  * @sci_rnc: The remote node context object being suspended.
@@ -539,56 +477,48 @@ static enum sci_status scic_sds_remote_node_context_await_suspension_state_start
 
 static struct scic_sds_remote_node_context_handlers scic_sds_remote_node_context_state_handler_table[] = {
 	[SCIC_SDS_REMOTE_NODE_CONTEXT_INITIAL_STATE] = {
-		.destruct_handler	= scic_sds_remote_node_context_default_destruct_handler,
 		.suspend_handler	= scic_sds_remote_node_context_default_suspend_handler,
 		.resume_handler		= scic_sds_remote_node_context_initial_state_resume_handler,
 		.start_io_handler	= scic_sds_remote_node_context_default_start_io_handler,
 		.start_task_handler	= scic_sds_remote_node_context_default_start_task_handler,
 	},
 	[SCIC_SDS_REMOTE_NODE_CONTEXT_POSTING_STATE] = {
-		.destruct_handler	= scic_sds_remote_node_context_general_destruct_handler,
 		.suspend_handler	= scic_sds_remote_node_context_default_suspend_handler,
 		.resume_handler		= scic_sds_remote_node_context_continue_to_resume_handler,
 		.start_io_handler	= scic_sds_remote_node_context_default_start_io_handler,
 		.start_task_handler	= scic_sds_remote_node_context_default_start_task_handler,
 	},
 	[SCIC_SDS_REMOTE_NODE_CONTEXT_INVALIDATING_STATE] = {
-		.destruct_handler	= scic_sds_remote_node_context_invalidating_state_destruct_handler,
 		.suspend_handler	= scic_sds_remote_node_context_default_suspend_handler,
 		.resume_handler		= scic_sds_remote_node_context_continue_to_resume_handler,
 		.start_io_handler	= scic_sds_remote_node_context_default_start_io_handler,
 		.start_task_handler	= scic_sds_remote_node_context_default_start_task_handler,
 	},
 	[SCIC_SDS_REMOTE_NODE_CONTEXT_RESUMING_STATE] = {
-		.destruct_handler	= scic_sds_remote_node_context_general_destruct_handler,
 		.suspend_handler	= scic_sds_remote_node_context_default_suspend_handler,
 		.resume_handler		= scic_sds_remote_node_context_continue_to_resume_handler,
 		.start_io_handler	= scic_sds_remote_node_context_default_start_io_handler,
 		.start_task_handler	= scic_sds_remote_node_context_success_start_task_handler,
 	},
 	[SCIC_SDS_REMOTE_NODE_CONTEXT_READY_STATE] = {
-		.destruct_handler	= scic_sds_remote_node_context_general_destruct_handler,
 		.suspend_handler	= scic_sds_remote_node_context_ready_state_suspend_handler,
 		.resume_handler		= scic_sds_remote_node_context_default_resume_handler,
 		.start_io_handler	= scic_sds_remote_node_context_ready_state_start_io_handler,
 		.start_task_handler	= scic_sds_remote_node_context_success_start_task_handler,
 	},
 	[SCIC_SDS_REMOTE_NODE_CONTEXT_TX_SUSPENDED_STATE] = {
-		.destruct_handler	= scic_sds_remote_node_context_general_destruct_handler,
 		.suspend_handler	= scic_sds_remote_node_context_default_suspend_handler,
 		.resume_handler		= scic_sds_remote_node_context_tx_suspended_state_resume_handler,
 		.start_io_handler	= scic_sds_remote_node_context_default_start_io_handler,
 		.start_task_handler	= scic_sds_remote_node_context_suspended_start_task_handler,
 	},
 	[SCIC_SDS_REMOTE_NODE_CONTEXT_TX_RX_SUSPENDED_STATE] = {
-		.destruct_handler	= scic_sds_remote_node_context_general_destruct_handler,
 		.suspend_handler	= scic_sds_remote_node_context_default_suspend_handler,
 		.resume_handler		= scic_sds_remote_node_context_tx_rx_suspended_state_resume_handler,
 		.start_io_handler	= scic_sds_remote_node_context_default_start_io_handler,
 		.start_task_handler	= scic_sds_remote_node_context_suspended_start_task_handler,
 	},
 	[SCIC_SDS_REMOTE_NODE_CONTEXT_AWAIT_SUSPENSION_STATE] = {
-		.destruct_handler	= scic_sds_remote_node_context_general_destruct_handler,
 		.suspend_handler	= scic_sds_remote_node_context_default_suspend_handler,
 		.resume_handler		= scic_sds_remote_node_context_await_suspension_state_resume_handler,
 		.start_io_handler	= scic_sds_remote_node_context_default_start_io_handler,
@@ -1023,3 +953,39 @@ enum sci_status scic_sds_remote_node_context_event_handler(struct scic_sds_remot
 	return SCI_FAILURE;
 
 }
+
+enum sci_status scic_sds_remote_node_context_destruct(struct scic_sds_remote_node_context *sci_rnc,
+						      scics_sds_remote_node_context_callback cb_fn,
+						      void *cb_p)
+{
+	enum scis_sds_remote_node_context_states state;
+
+	state = sci_rnc->state_machine.current_state_id;
+	switch (state) {
+	case SCIC_SDS_REMOTE_NODE_CONTEXT_INVALIDATING_STATE:
+		scic_sds_remote_node_context_setup_to_destory(sci_rnc, cb_fn, cb_p);
+		return SCI_SUCCESS;
+	case SCIC_SDS_REMOTE_NODE_CONTEXT_POSTING_STATE:
+	case SCIC_SDS_REMOTE_NODE_CONTEXT_RESUMING_STATE:
+	case SCIC_SDS_REMOTE_NODE_CONTEXT_READY_STATE:
+	case SCIC_SDS_REMOTE_NODE_CONTEXT_TX_SUSPENDED_STATE:
+	case SCIC_SDS_REMOTE_NODE_CONTEXT_TX_RX_SUSPENDED_STATE:
+	case SCIC_SDS_REMOTE_NODE_CONTEXT_AWAIT_SUSPENSION_STATE:
+		scic_sds_remote_node_context_setup_to_destory(sci_rnc, cb_fn, cb_p);
+		sci_base_state_machine_change_state(&sci_rnc->state_machine,
+						    SCIC_SDS_REMOTE_NODE_CONTEXT_INVALIDATING_STATE);
+		return SCI_SUCCESS;
+	case SCIC_SDS_REMOTE_NODE_CONTEXT_INITIAL_STATE:
+		dev_warn(scirdev_to_dev(rnc_to_dev(sci_rnc)),
+			 "%s: invalid state %d\n", __func__, state);
+		/* We have decided that the destruct request on the remote node context
+		 * can not fail since it is either in the initial/destroyed state or is
+		 * can be destroyed.
+		 */
+		return SCI_SUCCESS;
+	default:
+		dev_warn(scirdev_to_dev(rnc_to_dev(sci_rnc)),
+			 "%s: invalid state %d\n", __func__, state);
+		return SCI_FAILURE_INVALID_STATE;
+	}
+}

commit 338e386d12c2440e39c987d35fda403d319a79a0
Author: Dan Williams <dan.j.williams@intel.com>
Date:   Thu May 12 07:46:59 2011 -0700

    isci: unify rnc event handlers
    
    Unify rnc event handlers and delete the state handler.
    
    Reported-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/drivers/scsi/isci/remote_node_context.c b/drivers/scsi/isci/remote_node_context.c
index aef258b959f8..9f2407f0f5a6 100644
--- a/drivers/scsi/isci/remote_node_context.c
+++ b/drivers/scsi/isci/remote_node_context.c
@@ -299,21 +299,6 @@ static enum sci_status scic_sds_remote_node_context_default_start_task_handler(
 	return SCI_FAILURE;
 }
 
-static enum sci_status scic_sds_remote_node_context_default_event_handler(
-	struct scic_sds_remote_node_context *sci_rnc,
-	u32 event_code)
-{
-	dev_warn(scirdev_to_dev(rnc_to_dev(sci_rnc)),
-		 "%s: SCIC Remote Node Context 0x%p requested to process "
-		 "event 0x%x while in wrong state %d\n",
-		 __func__,
-		 sci_rnc,
-		 event_code,
-		 sci_base_state_machine_get_state(&sci_rnc->state_machine));
-
-	return SCI_FAILURE_INVALID_STATE;
-}
-
 /**
  *
  * @sci_rnc: The rnc for which the task request is targeted.
@@ -383,41 +368,6 @@ static enum sci_status scic_sds_remote_node_context_initial_state_resume_handler
 	return SCI_FAILURE_INVALID_STATE;
 }
 
-/* --------------------------------------------------------------------------- */
-
-static enum sci_status scic_sds_remote_node_context_posting_state_event_handler(
-	struct scic_sds_remote_node_context *sci_rnc,
-	u32 event_code)
-{
-	enum sci_status status;
-
-	switch (scu_get_event_code(event_code)) {
-	case SCU_EVENT_POST_RNC_COMPLETE:
-		status = SCI_SUCCESS;
-
-		sci_base_state_machine_change_state(
-			&sci_rnc->state_machine,
-			SCIC_SDS_REMOTE_NODE_CONTEXT_READY_STATE
-			);
-		break;
-
-	default:
-		status = SCI_FAILURE;
-		dev_warn(scirdev_to_dev(rnc_to_dev(sci_rnc)),
-			 "%s: SCIC Remote Node Context 0x%p requested to "
-			 "process unexpected event 0x%x while in posting "
-			 "state\n",
-			 __func__,
-			 sci_rnc,
-			 event_code);
-		break;
-	}
-
-	return status;
-}
-
-/* --------------------------------------------------------------------------- */
-
 static enum sci_status scic_sds_remote_node_context_invalidating_state_destruct_handler(
 	struct scic_sds_remote_node_context *sci_rnc,
 	scics_sds_remote_node_context_callback callback,
@@ -430,110 +380,6 @@ static enum sci_status scic_sds_remote_node_context_invalidating_state_destruct_
 	return SCI_SUCCESS;
 }
 
-static enum sci_status scic_sds_remote_node_context_invalidating_state_event_handler(
-	struct scic_sds_remote_node_context *sci_rnc,
-	u32 event_code)
-{
-	enum sci_status status;
-
-	if (scu_get_event_code(event_code) == SCU_EVENT_POST_RNC_INVALIDATE_COMPLETE) {
-		status = SCI_SUCCESS;
-
-		if (sci_rnc->destination_state == SCIC_SDS_REMOTE_NODE_DESTINATION_STATE_FINAL) {
-			sci_base_state_machine_change_state(
-				&sci_rnc->state_machine,
-				SCIC_SDS_REMOTE_NODE_CONTEXT_INITIAL_STATE
-				);
-		} else {
-			sci_base_state_machine_change_state(
-				&sci_rnc->state_machine,
-				SCIC_SDS_REMOTE_NODE_CONTEXT_POSTING_STATE
-				);
-		}
-	} else {
-		switch (scu_get_event_type(event_code)) {
-		case SCU_EVENT_TYPE_RNC_SUSPEND_TX:
-		case SCU_EVENT_TYPE_RNC_SUSPEND_TX_RX:
-			/*
-			 * We really dont care if the hardware is going to suspend
-			 * the device since it's being invalidated anyway */
-			dev_dbg(scirdev_to_dev(rnc_to_dev(sci_rnc)),
-				"%s: SCIC Remote Node Context 0x%p was "
-				"suspeneded by hardware while being "
-				"invalidated.\n",
-				__func__,
-				sci_rnc);
-			status = SCI_SUCCESS;
-			break;
-
-		default:
-			dev_warn(scirdev_to_dev(rnc_to_dev(sci_rnc)),
-				 "%s: SCIC Remote Node Context 0x%p "
-				 "requested to process event 0x%x while "
-				 "in state %d.\n",
-				 __func__,
-				 sci_rnc,
-				 event_code,
-				 sci_base_state_machine_get_state(
-					 &sci_rnc->state_machine));
-			status = SCI_FAILURE;
-			break;
-		}
-	}
-
-	return status;
-}
-
-/* --------------------------------------------------------------------------- */
-
-
-static enum sci_status scic_sds_remote_node_context_resuming_state_event_handler(
-	struct scic_sds_remote_node_context *sci_rnc,
-	u32 event_code)
-{
-	enum sci_status status;
-
-	if (scu_get_event_code(event_code) == SCU_EVENT_POST_RCN_RELEASE) {
-		status = SCI_SUCCESS;
-
-		sci_base_state_machine_change_state(
-			&sci_rnc->state_machine,
-			SCIC_SDS_REMOTE_NODE_CONTEXT_READY_STATE
-			);
-	} else {
-		switch (scu_get_event_type(event_code)) {
-		case SCU_EVENT_TYPE_RNC_SUSPEND_TX:
-		case SCU_EVENT_TYPE_RNC_SUSPEND_TX_RX:
-			/*
-			 * We really dont care if the hardware is going to suspend
-			 * the device since it's being resumed anyway */
-			dev_dbg(scirdev_to_dev(rnc_to_dev(sci_rnc)),
-				"%s: SCIC Remote Node Context 0x%p was "
-				"suspeneded by hardware while being resumed.\n",
-				__func__,
-				sci_rnc);
-			status = SCI_SUCCESS;
-			break;
-
-		default:
-			dev_warn(scirdev_to_dev(rnc_to_dev(sci_rnc)),
-				 "%s: SCIC Remote Node Context 0x%p requested "
-				 "to process event 0x%x while in state %d.\n",
-				 __func__,
-				 sci_rnc,
-				 event_code,
-				 sci_base_state_machine_get_state(
-					 &sci_rnc->state_machine));
-			status = SCI_FAILURE;
-			break;
-		}
-	}
-
-	return status;
-}
-
-/* --------------------------------------------------------------------------- */
-
 /**
  *
  * @sci_rnc: The remote node context object being suspended.
@@ -582,53 +428,6 @@ static enum sci_status scic_sds_remote_node_context_ready_state_start_io_handler
 	return SCI_SUCCESS;
 }
 
-
-static enum sci_status scic_sds_remote_node_context_ready_state_event_handler(
-	struct scic_sds_remote_node_context *sci_rnc,
-	u32 event_code)
-{
-	enum sci_status status;
-
-	switch (scu_get_event_type(event_code)) {
-	case SCU_EVENT_TL_RNC_SUSPEND_TX:
-		sci_base_state_machine_change_state(
-			&sci_rnc->state_machine,
-			SCIC_SDS_REMOTE_NODE_CONTEXT_TX_SUSPENDED_STATE
-			);
-
-		sci_rnc->suspension_code = scu_get_event_specifier(event_code);
-		status = SCI_SUCCESS;
-		break;
-
-	case SCU_EVENT_TL_RNC_SUSPEND_TX_RX:
-		sci_base_state_machine_change_state(
-			&sci_rnc->state_machine,
-			SCIC_SDS_REMOTE_NODE_CONTEXT_TX_RX_SUSPENDED_STATE
-			);
-
-		sci_rnc->suspension_code = scu_get_event_specifier(event_code);
-		status = SCI_SUCCESS;
-		break;
-
-	default:
-		dev_warn(scirdev_to_dev(rnc_to_dev(sci_rnc)),
-			"%s: SCIC Remote Node Context 0x%p requested to "
-			"process event 0x%x while in state %d.\n",
-			__func__,
-			sci_rnc,
-			event_code,
-			sci_base_state_machine_get_state(
-				&sci_rnc->state_machine));
-
-		status = SCI_FAILURE;
-		break;
-	}
-
-	return status;
-}
-
-/* --------------------------------------------------------------------------- */
-
 static enum sci_status scic_sds_remote_node_context_tx_suspended_state_resume_handler(
 	struct scic_sds_remote_node_context *sci_rnc,
 	scics_sds_remote_node_context_callback callback,
@@ -738,61 +537,13 @@ static enum sci_status scic_sds_remote_node_context_await_suspension_state_start
 	return SCI_SUCCESS;
 }
 
-static enum sci_status scic_sds_remote_node_context_await_suspension_state_event_handler(
-	struct scic_sds_remote_node_context *sci_rnc,
-	u32 event_code)
-{
-	enum sci_status status;
-
-	switch (scu_get_event_type(event_code)) {
-	case SCU_EVENT_TL_RNC_SUSPEND_TX:
-		sci_base_state_machine_change_state(
-			&sci_rnc->state_machine,
-			SCIC_SDS_REMOTE_NODE_CONTEXT_TX_SUSPENDED_STATE
-			);
-
-		sci_rnc->suspension_code = scu_get_event_specifier(event_code);
-		status = SCI_SUCCESS;
-		break;
-
-	case SCU_EVENT_TL_RNC_SUSPEND_TX_RX:
-		sci_base_state_machine_change_state(
-			&sci_rnc->state_machine,
-			SCIC_SDS_REMOTE_NODE_CONTEXT_TX_RX_SUSPENDED_STATE
-			);
-
-		sci_rnc->suspension_code = scu_get_event_specifier(event_code);
-		status = SCI_SUCCESS;
-		break;
-
-	default:
-		dev_warn(scirdev_to_dev(rnc_to_dev(sci_rnc)),
-			 "%s: SCIC Remote Node Context 0x%p requested to "
-			 "process event 0x%x while in state %d.\n",
-			 __func__,
-			 sci_rnc,
-			 event_code,
-			 sci_base_state_machine_get_state(
-				 &sci_rnc->state_machine));
-
-		status = SCI_FAILURE;
-		break;
-	}
-
-	return status;
-}
-
-/* --------------------------------------------------------------------------- */
-
-static struct scic_sds_remote_node_context_handlers
-scic_sds_remote_node_context_state_handler_table[] = {
+static struct scic_sds_remote_node_context_handlers scic_sds_remote_node_context_state_handler_table[] = {
 	[SCIC_SDS_REMOTE_NODE_CONTEXT_INITIAL_STATE] = {
 		.destruct_handler	= scic_sds_remote_node_context_default_destruct_handler,
 		.suspend_handler	= scic_sds_remote_node_context_default_suspend_handler,
 		.resume_handler		= scic_sds_remote_node_context_initial_state_resume_handler,
 		.start_io_handler	= scic_sds_remote_node_context_default_start_io_handler,
 		.start_task_handler	= scic_sds_remote_node_context_default_start_task_handler,
-		.event_handler		= scic_sds_remote_node_context_default_event_handler
 	},
 	[SCIC_SDS_REMOTE_NODE_CONTEXT_POSTING_STATE] = {
 		.destruct_handler	= scic_sds_remote_node_context_general_destruct_handler,
@@ -800,7 +551,6 @@ scic_sds_remote_node_context_state_handler_table[] = {
 		.resume_handler		= scic_sds_remote_node_context_continue_to_resume_handler,
 		.start_io_handler	= scic_sds_remote_node_context_default_start_io_handler,
 		.start_task_handler	= scic_sds_remote_node_context_default_start_task_handler,
-		.event_handler		= scic_sds_remote_node_context_posting_state_event_handler
 	},
 	[SCIC_SDS_REMOTE_NODE_CONTEXT_INVALIDATING_STATE] = {
 		.destruct_handler	= scic_sds_remote_node_context_invalidating_state_destruct_handler,
@@ -808,7 +558,6 @@ scic_sds_remote_node_context_state_handler_table[] = {
 		.resume_handler		= scic_sds_remote_node_context_continue_to_resume_handler,
 		.start_io_handler	= scic_sds_remote_node_context_default_start_io_handler,
 		.start_task_handler	= scic_sds_remote_node_context_default_start_task_handler,
-		.event_handler		= scic_sds_remote_node_context_invalidating_state_event_handler
 	},
 	[SCIC_SDS_REMOTE_NODE_CONTEXT_RESUMING_STATE] = {
 		.destruct_handler	= scic_sds_remote_node_context_general_destruct_handler,
@@ -816,7 +565,6 @@ scic_sds_remote_node_context_state_handler_table[] = {
 		.resume_handler		= scic_sds_remote_node_context_continue_to_resume_handler,
 		.start_io_handler	= scic_sds_remote_node_context_default_start_io_handler,
 		.start_task_handler	= scic_sds_remote_node_context_success_start_task_handler,
-		.event_handler		= scic_sds_remote_node_context_resuming_state_event_handler
 	},
 	[SCIC_SDS_REMOTE_NODE_CONTEXT_READY_STATE] = {
 		.destruct_handler	= scic_sds_remote_node_context_general_destruct_handler,
@@ -824,7 +572,6 @@ scic_sds_remote_node_context_state_handler_table[] = {
 		.resume_handler		= scic_sds_remote_node_context_default_resume_handler,
 		.start_io_handler	= scic_sds_remote_node_context_ready_state_start_io_handler,
 		.start_task_handler	= scic_sds_remote_node_context_success_start_task_handler,
-		.event_handler		= scic_sds_remote_node_context_ready_state_event_handler
 	},
 	[SCIC_SDS_REMOTE_NODE_CONTEXT_TX_SUSPENDED_STATE] = {
 		.destruct_handler	= scic_sds_remote_node_context_general_destruct_handler,
@@ -832,7 +579,6 @@ scic_sds_remote_node_context_state_handler_table[] = {
 		.resume_handler		= scic_sds_remote_node_context_tx_suspended_state_resume_handler,
 		.start_io_handler	= scic_sds_remote_node_context_default_start_io_handler,
 		.start_task_handler	= scic_sds_remote_node_context_suspended_start_task_handler,
-		.event_handler		= scic_sds_remote_node_context_default_event_handler
 	},
 	[SCIC_SDS_REMOTE_NODE_CONTEXT_TX_RX_SUSPENDED_STATE] = {
 		.destruct_handler	= scic_sds_remote_node_context_general_destruct_handler,
@@ -840,7 +586,6 @@ scic_sds_remote_node_context_state_handler_table[] = {
 		.resume_handler		= scic_sds_remote_node_context_tx_rx_suspended_state_resume_handler,
 		.start_io_handler	= scic_sds_remote_node_context_default_start_io_handler,
 		.start_task_handler	= scic_sds_remote_node_context_suspended_start_task_handler,
-		.event_handler		= scic_sds_remote_node_context_default_event_handler
 	},
 	[SCIC_SDS_REMOTE_NODE_CONTEXT_AWAIT_SUSPENSION_STATE] = {
 		.destruct_handler	= scic_sds_remote_node_context_general_destruct_handler,
@@ -848,7 +593,6 @@ scic_sds_remote_node_context_state_handler_table[] = {
 		.resume_handler		= scic_sds_remote_node_context_await_suspension_state_resume_handler,
 		.start_io_handler	= scic_sds_remote_node_context_default_start_io_handler,
 		.start_task_handler	= scic_sds_remote_node_context_await_suspension_state_start_task_handler,
-		.event_handler		= scic_sds_remote_node_context_await_suspension_state_event_handler
 	}
 };
 
@@ -1172,3 +916,110 @@ void scic_sds_remote_node_context_construct(struct scic_sds_remote_node_context
 
 	sci_base_state_machine_start(&rnc->state_machine);
 }
+
+enum sci_status scic_sds_remote_node_context_event_handler(struct scic_sds_remote_node_context *sci_rnc,
+							   u32 event_code)
+{
+	enum scis_sds_remote_node_context_states state;
+
+	state = sci_rnc->state_machine.current_state_id;
+	switch (state) {
+	case SCIC_SDS_REMOTE_NODE_CONTEXT_POSTING_STATE:
+		switch (scu_get_event_code(event_code)) {
+		case SCU_EVENT_POST_RNC_COMPLETE:
+			sci_base_state_machine_change_state(&sci_rnc->state_machine,
+							    SCIC_SDS_REMOTE_NODE_CONTEXT_READY_STATE);
+			break;
+		default:
+			goto out;
+		}
+		break;
+	case SCIC_SDS_REMOTE_NODE_CONTEXT_INVALIDATING_STATE:
+		if (scu_get_event_code(event_code) == SCU_EVENT_POST_RNC_INVALIDATE_COMPLETE) {
+			if (sci_rnc->destination_state == SCIC_SDS_REMOTE_NODE_DESTINATION_STATE_FINAL)
+				state = SCIC_SDS_REMOTE_NODE_CONTEXT_INITIAL_STATE;
+			else
+				state = SCIC_SDS_REMOTE_NODE_CONTEXT_POSTING_STATE;
+			sci_base_state_machine_change_state(&sci_rnc->state_machine,
+							    state);
+		} else {
+			switch (scu_get_event_type(event_code)) {
+			case SCU_EVENT_TYPE_RNC_SUSPEND_TX:
+			case SCU_EVENT_TYPE_RNC_SUSPEND_TX_RX:
+				/* We really dont care if the hardware is going to suspend
+				 * the device since it's being invalidated anyway */
+				dev_dbg(scirdev_to_dev(rnc_to_dev(sci_rnc)),
+					"%s: SCIC Remote Node Context 0x%p was "
+					"suspeneded by hardware while being "
+					"invalidated.\n", __func__, sci_rnc);
+				break;
+			default:
+				goto out;
+			}
+		}
+		break;
+	case SCIC_SDS_REMOTE_NODE_CONTEXT_RESUMING_STATE:
+		if (scu_get_event_code(event_code) == SCU_EVENT_POST_RCN_RELEASE) {
+			sci_base_state_machine_change_state(&sci_rnc->state_machine,
+							    SCIC_SDS_REMOTE_NODE_CONTEXT_READY_STATE);
+		} else {
+			switch (scu_get_event_type(event_code)) {
+			case SCU_EVENT_TYPE_RNC_SUSPEND_TX:
+			case SCU_EVENT_TYPE_RNC_SUSPEND_TX_RX:
+				/* We really dont care if the hardware is going to suspend
+				 * the device since it's being resumed anyway */
+				dev_dbg(scirdev_to_dev(rnc_to_dev(sci_rnc)),
+					"%s: SCIC Remote Node Context 0x%p was "
+					"suspeneded by hardware while being resumed.\n",
+					__func__, sci_rnc);
+				break;
+			default:
+				goto out;
+			}
+		}
+		break;
+	case SCIC_SDS_REMOTE_NODE_CONTEXT_READY_STATE:
+		switch (scu_get_event_type(event_code)) {
+		case SCU_EVENT_TL_RNC_SUSPEND_TX:
+			sci_base_state_machine_change_state(&sci_rnc->state_machine,
+							    SCIC_SDS_REMOTE_NODE_CONTEXT_TX_SUSPENDED_STATE);
+			sci_rnc->suspension_code = scu_get_event_specifier(event_code);
+			break;
+		case SCU_EVENT_TL_RNC_SUSPEND_TX_RX:
+			sci_base_state_machine_change_state(&sci_rnc->state_machine,
+							    SCIC_SDS_REMOTE_NODE_CONTEXT_TX_RX_SUSPENDED_STATE);
+			sci_rnc->suspension_code = scu_get_event_specifier(event_code);
+			break;
+		default:
+			goto out;
+		}
+		break;
+	case SCIC_SDS_REMOTE_NODE_CONTEXT_AWAIT_SUSPENSION_STATE:
+		switch (scu_get_event_type(event_code)) {
+		case SCU_EVENT_TL_RNC_SUSPEND_TX:
+			sci_base_state_machine_change_state(&sci_rnc->state_machine,
+							    SCIC_SDS_REMOTE_NODE_CONTEXT_TX_SUSPENDED_STATE);
+			sci_rnc->suspension_code = scu_get_event_specifier(event_code);
+			break;
+		case SCU_EVENT_TL_RNC_SUSPEND_TX_RX:
+			sci_base_state_machine_change_state(&sci_rnc->state_machine,
+							    SCIC_SDS_REMOTE_NODE_CONTEXT_TX_RX_SUSPENDED_STATE);
+			sci_rnc->suspension_code = scu_get_event_specifier(event_code);
+			break;
+		default:
+			goto out;
+		}
+		break;
+	default:
+		dev_warn(scirdev_to_dev(rnc_to_dev(sci_rnc)),
+			 "%s: invalid state %d\n", __func__, state);
+		return SCI_FAILURE_INVALID_STATE;
+	}
+	return SCI_SUCCESS;
+
+ out:
+	dev_warn(scirdev_to_dev(rnc_to_dev(sci_rnc)),
+		 "%s: code: %#x state: %d\n", __func__, event_code, state);
+	return SCI_FAILURE;
+
+}

commit e2f8db509fdd354bb7a68c86515e9d2d8909ccc9
Author: Dan Williams <dan.j.williams@intel.com>
Date:   Tue May 10 02:28:46 2011 -0700

    isci: uplevel port infrastructure
    
    * Move port configuration agent implementation
    * Merge core/scic_sds_port.[ch] into port.[ch]
    
    Reported-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/drivers/scsi/isci/remote_node_context.c b/drivers/scsi/isci/remote_node_context.c
index 35231e7407b1..aef258b959f8 100644
--- a/drivers/scsi/isci/remote_node_context.c
+++ b/drivers/scsi/isci/remote_node_context.c
@@ -55,7 +55,6 @@
 
 #include "host.h"
 #include "state_machine.h"
-#include "scic_sds_port.h"
 #include "remote_device.h"
 #include "remote_node_context.h"
 #include "scu_event_codes.h"

commit f1f52e75939b56c40b3d153ae99faf2720250242
Author: Dan Williams <dan.j.williams@intel.com>
Date:   Tue May 10 02:28:45 2011 -0700

    isci: uplevel request infrastructure
    
    * Consolidate tiny header files
    * Move files out of core/ (drop core/scic_sds_ prefix)
    * Merge core/scic_sds_request.[ch] into request.[ch]
    * Cleanup request.c namespace (clean forward declarations and global
      namespace pollution)
    
    Reported-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/drivers/scsi/isci/remote_node_context.c b/drivers/scsi/isci/remote_node_context.c
index 5891f3d50177..35231e7407b1 100644
--- a/drivers/scsi/isci/remote_node_context.c
+++ b/drivers/scsi/isci/remote_node_context.c
@@ -58,7 +58,6 @@
 #include "scic_sds_port.h"
 #include "remote_device.h"
 #include "remote_node_context.h"
-#include "sci_util.h"
 #include "scu_event_codes.h"
 #include "scu_task_context.h"
 

commit 3bff9d54ecba84e538da822349a9a6fd6e534539
Author: Dan Williams <dan.j.williams@intel.com>
Date:   Sun May 8 22:15:10 2011 -0700

    isci: uplevel state machine
    
    unify core/sci_base_state.h and core/sci_base_state_machine.[ch] into
    state_machine.[ch]
    
    Reported-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/drivers/scsi/isci/remote_node_context.c b/drivers/scsi/isci/remote_node_context.c
index af4759383db4..5891f3d50177 100644
--- a/drivers/scsi/isci/remote_node_context.c
+++ b/drivers/scsi/isci/remote_node_context.c
@@ -54,7 +54,7 @@
  */
 
 #include "host.h"
-#include "sci_base_state_machine.h"
+#include "state_machine.h"
 #include "scic_sds_port.h"
 #include "remote_device.h"
 #include "remote_node_context.h"

commit cc9203bf381a465cd115762b9cf7c9a313c874bc
Author: Dan Williams <dan.j.williams@intel.com>
Date:   Sun May 8 17:34:44 2011 -0700

    isci: move core/controller to host
    
    Now that the data structures are unified unify the implementation in
    host.[ch] and cleanup namespace pollution.
    
    Reported-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/drivers/scsi/isci/remote_node_context.c b/drivers/scsi/isci/remote_node_context.c
index 5e85a18a06de..af4759383db4 100644
--- a/drivers/scsi/isci/remote_node_context.c
+++ b/drivers/scsi/isci/remote_node_context.c
@@ -53,12 +53,11 @@
  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
 
+#include "host.h"
 #include "sci_base_state_machine.h"
-#include "scic_sds_controller.h"
 #include "scic_sds_port.h"
 #include "remote_device.h"
 #include "remote_node_context.h"
-#include "sci_environment.h"
 #include "sci_util.h"
 #include "scu_event_codes.h"
 #include "scu_task_context.h"

commit a98a7426bc91700ac8613701daf8470efe2ad2d2
Author: Jacek Danecki <Jacek.Danecki@intel.com>
Date:   Tue May 3 04:21:07 2011 +0000

    isci: rnc state machine table c99 conversion
    
    This makes the subsequent patches to delete rnc->state_handler more
    clear.
    
    Signed-off-by: Jacek Danecki <Jacek.Danecki@intel.com>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/drivers/scsi/isci/remote_node_context.c b/drivers/scsi/isci/remote_node_context.c
index 49d2dc5374f4..5e85a18a06de 100644
--- a/drivers/scsi/isci/remote_node_context.c
+++ b/drivers/scsi/isci/remote_node_context.c
@@ -788,80 +788,70 @@ static enum sci_status scic_sds_remote_node_context_await_suspension_state_event
 /* --------------------------------------------------------------------------- */
 
 static struct scic_sds_remote_node_context_handlers
-scic_sds_remote_node_context_state_handler_table[
-	SCIC_SDS_REMOTE_NODE_CONTEXT_MAX_STATES] =
-{
-	/* SCIC_SDS_REMOTE_NODE_CONTEXT_INITIAL_STATE */
-	{
-		scic_sds_remote_node_context_default_destruct_handler,
-		scic_sds_remote_node_context_default_suspend_handler,
-		scic_sds_remote_node_context_initial_state_resume_handler,
-		scic_sds_remote_node_context_default_start_io_handler,
-		scic_sds_remote_node_context_default_start_task_handler,
-		scic_sds_remote_node_context_default_event_handler
+scic_sds_remote_node_context_state_handler_table[] = {
+	[SCIC_SDS_REMOTE_NODE_CONTEXT_INITIAL_STATE] = {
+		.destruct_handler	= scic_sds_remote_node_context_default_destruct_handler,
+		.suspend_handler	= scic_sds_remote_node_context_default_suspend_handler,
+		.resume_handler		= scic_sds_remote_node_context_initial_state_resume_handler,
+		.start_io_handler	= scic_sds_remote_node_context_default_start_io_handler,
+		.start_task_handler	= scic_sds_remote_node_context_default_start_task_handler,
+		.event_handler		= scic_sds_remote_node_context_default_event_handler
 	},
-	/* SCIC_SDS_REMOTE_NODE_CONTEXT_POSTING_STATE */
-	{
-		scic_sds_remote_node_context_general_destruct_handler,
-		scic_sds_remote_node_context_default_suspend_handler,
-		scic_sds_remote_node_context_continue_to_resume_handler,
-		scic_sds_remote_node_context_default_start_io_handler,
-		scic_sds_remote_node_context_default_start_task_handler,
-		scic_sds_remote_node_context_posting_state_event_handler
+	[SCIC_SDS_REMOTE_NODE_CONTEXT_POSTING_STATE] = {
+		.destruct_handler	= scic_sds_remote_node_context_general_destruct_handler,
+		.suspend_handler	= scic_sds_remote_node_context_default_suspend_handler,
+		.resume_handler		= scic_sds_remote_node_context_continue_to_resume_handler,
+		.start_io_handler	= scic_sds_remote_node_context_default_start_io_handler,
+		.start_task_handler	= scic_sds_remote_node_context_default_start_task_handler,
+		.event_handler		= scic_sds_remote_node_context_posting_state_event_handler
 	},
-	/* SCIC_SDS_REMOTE_NODE_CONTEXT_INVALIDATING_STATE */
-	{
-		scic_sds_remote_node_context_invalidating_state_destruct_handler,
-		scic_sds_remote_node_context_default_suspend_handler,
-		scic_sds_remote_node_context_continue_to_resume_handler,
-		scic_sds_remote_node_context_default_start_io_handler,
-		scic_sds_remote_node_context_default_start_task_handler,
-		scic_sds_remote_node_context_invalidating_state_event_handler
+	[SCIC_SDS_REMOTE_NODE_CONTEXT_INVALIDATING_STATE] = {
+		.destruct_handler	= scic_sds_remote_node_context_invalidating_state_destruct_handler,
+		.suspend_handler	= scic_sds_remote_node_context_default_suspend_handler,
+		.resume_handler		= scic_sds_remote_node_context_continue_to_resume_handler,
+		.start_io_handler	= scic_sds_remote_node_context_default_start_io_handler,
+		.start_task_handler	= scic_sds_remote_node_context_default_start_task_handler,
+		.event_handler		= scic_sds_remote_node_context_invalidating_state_event_handler
 	},
-	/* SCIC_SDS_REMOTE_NODE_CONTEXT_RESUMING_STATE */
-	{
-		scic_sds_remote_node_context_general_destruct_handler,
-		scic_sds_remote_node_context_default_suspend_handler,
-		scic_sds_remote_node_context_continue_to_resume_handler,
-		scic_sds_remote_node_context_default_start_io_handler,
-		scic_sds_remote_node_context_success_start_task_handler,
-		scic_sds_remote_node_context_resuming_state_event_handler
+	[SCIC_SDS_REMOTE_NODE_CONTEXT_RESUMING_STATE] = {
+		.destruct_handler	= scic_sds_remote_node_context_general_destruct_handler,
+		.suspend_handler	= scic_sds_remote_node_context_default_suspend_handler,
+		.resume_handler		= scic_sds_remote_node_context_continue_to_resume_handler,
+		.start_io_handler	= scic_sds_remote_node_context_default_start_io_handler,
+		.start_task_handler	= scic_sds_remote_node_context_success_start_task_handler,
+		.event_handler		= scic_sds_remote_node_context_resuming_state_event_handler
 	},
-	/* SCIC_SDS_REMOTE_NODE_CONTEXT_READY_STATE */
-	{
-		scic_sds_remote_node_context_general_destruct_handler,
-		scic_sds_remote_node_context_ready_state_suspend_handler,
-		scic_sds_remote_node_context_default_resume_handler,
-		scic_sds_remote_node_context_ready_state_start_io_handler,
-		scic_sds_remote_node_context_success_start_task_handler,
-		scic_sds_remote_node_context_ready_state_event_handler
+	[SCIC_SDS_REMOTE_NODE_CONTEXT_READY_STATE] = {
+		.destruct_handler	= scic_sds_remote_node_context_general_destruct_handler,
+		.suspend_handler	= scic_sds_remote_node_context_ready_state_suspend_handler,
+		.resume_handler		= scic_sds_remote_node_context_default_resume_handler,
+		.start_io_handler	= scic_sds_remote_node_context_ready_state_start_io_handler,
+		.start_task_handler	= scic_sds_remote_node_context_success_start_task_handler,
+		.event_handler		= scic_sds_remote_node_context_ready_state_event_handler
 	},
-	/* SCIC_SDS_REMOTE_NODE_CONTEXT_TX_SUSPENDED_STATE */
-	{
-		scic_sds_remote_node_context_general_destruct_handler,
-		scic_sds_remote_node_context_default_suspend_handler,
-		scic_sds_remote_node_context_tx_suspended_state_resume_handler,
-		scic_sds_remote_node_context_default_start_io_handler,
-		scic_sds_remote_node_context_suspended_start_task_handler,
-		scic_sds_remote_node_context_default_event_handler
+	[SCIC_SDS_REMOTE_NODE_CONTEXT_TX_SUSPENDED_STATE] = {
+		.destruct_handler	= scic_sds_remote_node_context_general_destruct_handler,
+		.suspend_handler	= scic_sds_remote_node_context_default_suspend_handler,
+		.resume_handler		= scic_sds_remote_node_context_tx_suspended_state_resume_handler,
+		.start_io_handler	= scic_sds_remote_node_context_default_start_io_handler,
+		.start_task_handler	= scic_sds_remote_node_context_suspended_start_task_handler,
+		.event_handler		= scic_sds_remote_node_context_default_event_handler
 	},
-	/* SCIC_SDS_REMOTE_NODE_CONTEXT_TX_RX_SUSPENDED_STATE */
-	{
-		scic_sds_remote_node_context_general_destruct_handler,
-		scic_sds_remote_node_context_default_suspend_handler,
-		scic_sds_remote_node_context_tx_rx_suspended_state_resume_handler,
-		scic_sds_remote_node_context_default_start_io_handler,
-		scic_sds_remote_node_context_suspended_start_task_handler,
-		scic_sds_remote_node_context_default_event_handler
+	[SCIC_SDS_REMOTE_NODE_CONTEXT_TX_RX_SUSPENDED_STATE] = {
+		.destruct_handler	= scic_sds_remote_node_context_general_destruct_handler,
+		.suspend_handler	= scic_sds_remote_node_context_default_suspend_handler,
+		.resume_handler		= scic_sds_remote_node_context_tx_rx_suspended_state_resume_handler,
+		.start_io_handler	= scic_sds_remote_node_context_default_start_io_handler,
+		.start_task_handler	= scic_sds_remote_node_context_suspended_start_task_handler,
+		.event_handler		= scic_sds_remote_node_context_default_event_handler
 	},
-	/* SCIC_SDS_REMOTE_NODE_CONTEXT_AWAIT_SUSPENSION_STATE */
-	{
-		scic_sds_remote_node_context_general_destruct_handler,
-		scic_sds_remote_node_context_default_suspend_handler,
-		scic_sds_remote_node_context_await_suspension_state_resume_handler,
-		scic_sds_remote_node_context_default_start_io_handler,
-		scic_sds_remote_node_context_await_suspension_state_start_task_handler,
-		scic_sds_remote_node_context_await_suspension_state_event_handler
+	[SCIC_SDS_REMOTE_NODE_CONTEXT_AWAIT_SUSPENSION_STATE] = {
+		.destruct_handler	= scic_sds_remote_node_context_general_destruct_handler,
+		.suspend_handler	= scic_sds_remote_node_context_default_suspend_handler,
+		.resume_handler		= scic_sds_remote_node_context_await_suspension_state_resume_handler,
+		.start_io_handler	= scic_sds_remote_node_context_default_start_io_handler,
+		.start_task_handler	= scic_sds_remote_node_context_await_suspension_state_start_task_handler,
+		.event_handler		= scic_sds_remote_node_context_await_suspension_state_event_handler
 	}
 };
 

commit af23e85737253624cde84704008be40355ff6922
Author: Maciej Patelczyk <maciej.patelczyk@intel.com>
Date:   Thu Apr 28 22:06:26 2011 +0000

    isci: Removed sci_base_object from scic_sds_remote_node_context.
    
    The 'struct sci_base_object' was removed from the struct
    scic_sds_remote_node_context.
    
    Signed-off-by: Maciej Patelczyk <maciej.patelczyk@intel.com>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/drivers/scsi/isci/remote_node_context.c b/drivers/scsi/isci/remote_node_context.c
index bc51ecf76b14..49d2dc5374f4 100644
--- a/drivers/scsi/isci/remote_node_context.c
+++ b/drivers/scsi/isci/remote_node_context.c
@@ -972,9 +972,7 @@ static void scic_sds_remote_node_context_invalidate_context_buffer(
  */
 static void scic_sds_remote_node_context_initial_state_enter(void *object)
 {
-	struct scic_sds_remote_node_context *rnc;
-
-	rnc = (struct scic_sds_remote_node_context *)object;
+	struct scic_sds_remote_node_context *rnc = object;
 
 	SET_STATE_HANDLER(
 		rnc,
@@ -1002,9 +1000,7 @@ static void scic_sds_remote_node_context_initial_state_enter(void *object)
  */
 static void scic_sds_remote_node_context_posting_state_enter(void *object)
 {
-	struct scic_sds_remote_node_context *sci_rnc;
-
-	sci_rnc = (struct scic_sds_remote_node_context *)object;
+	struct scic_sds_remote_node_context *sci_rnc = object;
 
 	SET_STATE_HANDLER(
 		sci_rnc,
@@ -1022,9 +1018,7 @@ static void scic_sds_remote_node_context_posting_state_enter(void *object)
  */
 static void scic_sds_remote_node_context_invalidating_state_enter(void *object)
 {
-	struct scic_sds_remote_node_context *rnc;
-
-	rnc = (struct scic_sds_remote_node_context *)object;
+	struct scic_sds_remote_node_context *rnc = object;
 
 	SET_STATE_HANDLER(
 		rnc,
@@ -1042,11 +1036,10 @@ static void scic_sds_remote_node_context_invalidating_state_enter(void *object)
  */
 static void scic_sds_remote_node_context_resuming_state_enter(void *object)
 {
-	struct scic_sds_remote_node_context *rnc;
+	struct scic_sds_remote_node_context *rnc = object;
 	struct scic_sds_remote_device *sci_dev;
 	struct domain_device *dev;
 
-	rnc = (struct scic_sds_remote_node_context *)object;
 	sci_dev = rnc_to_dev(rnc);
 	dev = sci_dev_to_domain(sci_dev);
 
@@ -1077,9 +1070,7 @@ static void scic_sds_remote_node_context_resuming_state_enter(void *object)
  */
 static void scic_sds_remote_node_context_ready_state_enter(void *object)
 {
-	struct scic_sds_remote_node_context *rnc;
-
-	rnc = (struct scic_sds_remote_node_context *)object;
+	struct scic_sds_remote_node_context *rnc = object;
 
 	SET_STATE_HANDLER(
 		rnc,
@@ -1101,9 +1092,7 @@ static void scic_sds_remote_node_context_ready_state_enter(void *object)
  */
 static void scic_sds_remote_node_context_tx_suspended_state_enter(void *object)
 {
-	struct scic_sds_remote_node_context *rnc;
-
-	rnc = (struct scic_sds_remote_node_context *)object;
+	struct scic_sds_remote_node_context *rnc = object;
 
 	SET_STATE_HANDLER(
 		rnc,
@@ -1122,9 +1111,7 @@ static void scic_sds_remote_node_context_tx_suspended_state_enter(void *object)
 static void scic_sds_remote_node_context_tx_rx_suspended_state_enter(
 		void *object)
 {
-	struct scic_sds_remote_node_context *rnc;
-
-	rnc = (struct scic_sds_remote_node_context *)object;
+	struct scic_sds_remote_node_context *rnc = object;
 
 	SET_STATE_HANDLER(
 		rnc,
@@ -1143,9 +1130,7 @@ static void scic_sds_remote_node_context_tx_rx_suspended_state_enter(
 static void scic_sds_remote_node_context_await_suspension_state_enter(
 	void *object)
 {
-	struct scic_sds_remote_node_context *rnc;
-
-	rnc = (struct scic_sds_remote_node_context *)object;
+	struct scic_sds_remote_node_context *rnc = object;
 
 	SET_STATE_HANDLER(
 		rnc,
@@ -1193,7 +1178,7 @@ void scic_sds_remote_node_context_construct(struct scic_sds_remote_node_context
 
 	sci_base_state_machine_construct(
 		&rnc->state_machine,
-		&rnc->parent,
+		rnc,
 		scic_sds_remote_node_context_state_table,
 		SCIC_SDS_REMOTE_NODE_CONTEXT_INITIAL_STATE
 		);

commit 9a0fff7bf0ffd4f57fc71d8075a92008b606eb61
Author: Maciej Patelczyk <maciej.patelczyk@intel.com>
Date:   Thu Apr 28 22:06:01 2011 +0000

    isci: Removed struct sci_base_object from state machine.
    
    Changed any occurrence of struct sci_base_object into void.
    
    Signed-off-by: Maciej Patelczyk <maciej.patelczyk@intel.com>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/drivers/scsi/isci/remote_node_context.c b/drivers/scsi/isci/remote_node_context.c
index 291df19f027b..bc51ecf76b14 100644
--- a/drivers/scsi/isci/remote_node_context.c
+++ b/drivers/scsi/isci/remote_node_context.c
@@ -970,8 +970,7 @@ static void scic_sds_remote_node_context_invalidate_context_buffer(
  *
  *
  */
-static void scic_sds_remote_node_context_initial_state_enter(
-	struct sci_base_object *object)
+static void scic_sds_remote_node_context_initial_state_enter(void *object)
 {
 	struct scic_sds_remote_node_context *rnc;
 
@@ -1001,8 +1000,7 @@ static void scic_sds_remote_node_context_initial_state_enter(
  *
  *
  */
-static void scic_sds_remote_node_context_posting_state_enter(
-	struct sci_base_object *object)
+static void scic_sds_remote_node_context_posting_state_enter(void *object)
 {
 	struct scic_sds_remote_node_context *sci_rnc;
 
@@ -1022,8 +1020,7 @@ static void scic_sds_remote_node_context_posting_state_enter(
  *
  *
  */
-static void scic_sds_remote_node_context_invalidating_state_enter(
-	struct sci_base_object *object)
+static void scic_sds_remote_node_context_invalidating_state_enter(void *object)
 {
 	struct scic_sds_remote_node_context *rnc;
 
@@ -1043,8 +1040,7 @@ static void scic_sds_remote_node_context_invalidating_state_enter(
  *
  *
  */
-static void scic_sds_remote_node_context_resuming_state_enter(
-	struct sci_base_object *object)
+static void scic_sds_remote_node_context_resuming_state_enter(void *object)
 {
 	struct scic_sds_remote_node_context *rnc;
 	struct scic_sds_remote_device *sci_dev;
@@ -1079,8 +1075,7 @@ static void scic_sds_remote_node_context_resuming_state_enter(
  *
  *
  */
-static void scic_sds_remote_node_context_ready_state_enter(
-	struct sci_base_object *object)
+static void scic_sds_remote_node_context_ready_state_enter(void *object)
 {
 	struct scic_sds_remote_node_context *rnc;
 
@@ -1104,8 +1099,7 @@ static void scic_sds_remote_node_context_ready_state_enter(
  *
  *
  */
-static void scic_sds_remote_node_context_tx_suspended_state_enter(
-	struct sci_base_object *object)
+static void scic_sds_remote_node_context_tx_suspended_state_enter(void *object)
 {
 	struct scic_sds_remote_node_context *rnc;
 
@@ -1126,7 +1120,7 @@ static void scic_sds_remote_node_context_tx_suspended_state_enter(
  *
  */
 static void scic_sds_remote_node_context_tx_rx_suspended_state_enter(
-	struct sci_base_object *object)
+		void *object)
 {
 	struct scic_sds_remote_node_context *rnc;
 
@@ -1147,7 +1141,7 @@ static void scic_sds_remote_node_context_tx_rx_suspended_state_enter(
  *
  */
 static void scic_sds_remote_node_context_await_suspension_state_enter(
-	struct sci_base_object *object)
+	void *object)
 {
 	struct scic_sds_remote_node_context *rnc;
 

commit 1f4fa1f958ca678ea021b95c2799b018b2cebc9c
Author: Dan Williams <dan.j.williams@intel.com>
Date:   Tue Apr 26 11:44:06 2011 -0700

    isci: remove scic_sds_remote_device_get_port_index
    
    Longer to type than the open-coded equivalent.
    
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/drivers/scsi/isci/remote_node_context.c b/drivers/scsi/isci/remote_node_context.c
index e83657d554b7..291df19f027b 100644
--- a/drivers/scsi/isci/remote_node_context.c
+++ b/drivers/scsi/isci/remote_node_context.c
@@ -108,22 +108,20 @@ static void scic_sds_remote_node_context_construct_buffer(
 {
 	struct scic_sds_remote_device *sci_dev = rnc_to_dev(sci_rnc);
 	struct domain_device *dev = sci_dev_to_domain(sci_dev);
+	int rni = sci_rnc->remote_node_index;
 	union scu_remote_node_context *rnc;
 	struct scic_sds_controller *scic;
 	__le64 sas_addr;
 
 	scic = scic_sds_remote_device_get_controller(sci_dev);
-
-	rnc = scic_sds_controller_get_remote_node_context_buffer(
-		scic, sci_rnc->remote_node_index);
+	rnc = scic_sds_controller_get_remote_node_context_buffer(scic, rni);
 
 	memset(rnc, 0, sizeof(union scu_remote_node_context)
 		* scic_sds_remote_device_node_count(sci_dev));
 
-	rnc->ssp.remote_node_index = sci_rnc->remote_node_index;
+	rnc->ssp.remote_node_index = rni;
 	rnc->ssp.remote_node_port_width = sci_dev->device_port_width;
-	rnc->ssp.logical_port_index =
-		scic_sds_remote_device_get_port_index(sci_dev);
+	rnc->ssp.logical_port_index = sci_dev->owning_port->physical_port_index;
 
 	/* sas address is __be64, context ram format is __le64 */
 	sas_addr = cpu_to_le64(SAS_ADDR(dev->sas_addr));

commit a3d568f0dfbb6bc786df04ad13e0b401f80e614c
Author: Dan Williams <dan.j.williams@intel.com>
Date:   Tue Apr 26 09:41:52 2011 -0700

    isci: remove usage of sci_sas_address in scic_sds_remote_device
    
    The sas address can be retrieved from the domain device and then
    converted to the always little-endian format in the remote node context.
    
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/drivers/scsi/isci/remote_node_context.c b/drivers/scsi/isci/remote_node_context.c
index 59f878f11f33..e83657d554b7 100644
--- a/drivers/scsi/isci/remote_node_context.c
+++ b/drivers/scsi/isci/remote_node_context.c
@@ -110,6 +110,7 @@ static void scic_sds_remote_node_context_construct_buffer(
 	struct domain_device *dev = sci_dev_to_domain(sci_dev);
 	union scu_remote_node_context *rnc;
 	struct scic_sds_controller *scic;
+	__le64 sas_addr;
 
 	scic = scic_sds_remote_device_get_controller(sci_dev);
 
@@ -124,9 +125,10 @@ static void scic_sds_remote_node_context_construct_buffer(
 	rnc->ssp.logical_port_index =
 		scic_sds_remote_device_get_port_index(sci_dev);
 
-	/* address is always big endian, destination is always little */
-	rnc->ssp.remote_sas_address_hi = swab32(sci_dev->device_address.high);
-	rnc->ssp.remote_sas_address_lo = swab32(sci_dev->device_address.low);
+	/* sas address is __be64, context ram format is __le64 */
+	sas_addr = cpu_to_le64(SAS_ADDR(dev->sas_addr));
+	rnc->ssp.remote_sas_address_hi = upper_32_bits(sas_addr);
+	rnc->ssp.remote_sas_address_lo = lower_32_bits(sas_addr);
 
 	rnc->ssp.nexus_loss_timer_enable = true;
 	rnc->ssp.check_bit               = false;

commit 00d680ef84570bc7aea023772d27e85b0052004c
Author: Dan Williams <dan.j.williams@intel.com>
Date:   Mon Apr 25 14:29:29 2011 -0700

    isci: kill smp_discover_response
    
    An lldd need never look at the contents of an smp_discover_response frame.
    Kill the remaining locations where isci is looking at it:
    
    1/ covering for expanders that do not set the stp_attached bit (already
       handled by sas_ex_discover_end_dev)
    2/ an overkill method to notifiy the rest of the driver about remote_device
       sas addresses
    
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/drivers/scsi/isci/remote_node_context.c b/drivers/scsi/isci/remote_node_context.c
index 285232fd5e63..59f878f11f33 100644
--- a/drivers/scsi/isci/remote_node_context.c
+++ b/drivers/scsi/isci/remote_node_context.c
@@ -124,8 +124,9 @@ static void scic_sds_remote_node_context_construct_buffer(
 	rnc->ssp.logical_port_index =
 		scic_sds_remote_device_get_port_index(sci_dev);
 
-	rnc->ssp.remote_sas_address_hi = SCIC_SWAP_DWORD(sci_dev->device_address.high);
-	rnc->ssp.remote_sas_address_lo = SCIC_SWAP_DWORD(sci_dev->device_address.low);
+	/* address is always big endian, destination is always little */
+	rnc->ssp.remote_sas_address_hi = swab32(sci_dev->device_address.high);
+	rnc->ssp.remote_sas_address_lo = swab32(sci_dev->device_address.low);
 
 	rnc->ssp.nexus_loss_timer_enable = true;
 	rnc->ssp.check_bit               = false;

commit a1a113b0a1ea437daf099b44f8a39e93a02a3f47
Author: Dan Williams <dan.j.williams@intel.com>
Date:   Thu Apr 21 18:44:45 2011 -0700

    isci: kill smp_discover_response_protocols in favor of domain_device.dev_type
    
    This is step 1 of removing the contortions to:
    1/ unparse expander phy data into a smp discover frame
    2/ open-code-parse the smp discover fram into a domain_device.dev_type equivalent
    
    libsas has already spent cycles determining the dev_type, so now that
    scic_sds_remote_device is unified with isci_remote_device we can
    directly reference dev_type.
    
    This might also change multi-level expander detection as we previously only
    looked at dev_type == EDGE_DEV and we did not consider the FANOUT_DEV case.
    
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/drivers/scsi/isci/remote_node_context.c b/drivers/scsi/isci/remote_node_context.c
index bdf0b5101cfa..285232fd5e63 100644
--- a/drivers/scsi/isci/remote_node_context.c
+++ b/drivers/scsi/isci/remote_node_context.c
@@ -106,8 +106,9 @@ bool scic_sds_remote_node_context_is_ready(
 static void scic_sds_remote_node_context_construct_buffer(
 	struct scic_sds_remote_node_context *sci_rnc)
 {
-	union scu_remote_node_context *rnc;
 	struct scic_sds_remote_device *sci_dev = rnc_to_dev(sci_rnc);
+	struct domain_device *dev = sci_dev_to_domain(sci_dev);
+	union scu_remote_node_context *rnc;
 	struct scic_sds_controller *scic;
 
 	scic = scic_sds_remote_device_get_controller(sci_dev);
@@ -134,11 +135,7 @@ static void scic_sds_remote_node_context_construct_buffer(
 
 	rnc->ssp.arbitration_wait_time = 0;
 
-
-	if (
-		sci_dev->target_protocols.u.bits.attached_sata_device
-		|| sci_dev->target_protocols.u.bits.attached_stp_target
-		) {
+	if (dev->dev_type == SATA_DEV || (dev->tproto & SAS_PROTOCOL_STP)) {
 		rnc->ssp.connection_occupancy_timeout =
 			scic->user_parameters.sds1.stp_max_occupancy_timeout;
 		rnc->ssp.connection_inactivity_timeout =
@@ -639,45 +636,30 @@ static enum sci_status scic_sds_remote_node_context_tx_suspended_state_resume_ha
 	scics_sds_remote_node_context_callback callback,
 	void *callback_parameter)
 {
-	enum sci_status status;
-	struct smp_discover_response_protocols protocols;
+	struct scic_sds_remote_device *sci_dev = rnc_to_dev(sci_rnc);
+	struct domain_device *dev = sci_dev_to_domain(sci_dev);
+	enum sci_status status = SCI_SUCCESS;
 
-	scic_sds_remote_node_context_setup_to_resume(
-		sci_rnc, callback, callback_parameter
-		);
+	scic_sds_remote_node_context_setup_to_resume(sci_rnc, callback,
+						     callback_parameter);
 
 	/* TODO: consider adding a resume action of NONE, INVALIDATE, WRITE_TLCR */
-
-	scic_remote_device_get_protocols(rnc_to_dev(sci_rnc), &protocols);
-
-	if (
-		(protocols.u.bits.attached_ssp_target == 1)
-		|| (protocols.u.bits.attached_smp_target == 1)
-		) {
-		sci_base_state_machine_change_state(
-			&sci_rnc->state_machine,
-			SCIC_SDS_REMOTE_NODE_CONTEXT_RESUMING_STATE
-			);
-
-		status = SCI_SUCCESS;
-	} else if (protocols.u.bits.attached_stp_target == 1) {
-		if (rnc_to_dev(sci_rnc)->is_direct_attached) {
+	if (dev->dev_type == SAS_END_DEV || dev_is_expander(dev))
+		sci_base_state_machine_change_state(&sci_rnc->state_machine,
+						    SCIC_SDS_REMOTE_NODE_CONTEXT_RESUMING_STATE);
+	else if (dev->dev_type == SATA_DEV || (dev->tproto & SAS_PROTOCOL_STP)) {
+		if (sci_dev->is_direct_attached) {
 			/* @todo Fix this since I am being silly in writing to the STPTLDARNI register. */
 			sci_base_state_machine_change_state(
 				&sci_rnc->state_machine,
-				SCIC_SDS_REMOTE_NODE_CONTEXT_RESUMING_STATE
-				);
+				SCIC_SDS_REMOTE_NODE_CONTEXT_RESUMING_STATE);
 		} else {
 			sci_base_state_machine_change_state(
 				&sci_rnc->state_machine,
-				SCIC_SDS_REMOTE_NODE_CONTEXT_INVALIDATING_STATE
-				);
+				SCIC_SDS_REMOTE_NODE_CONTEXT_INVALIDATING_STATE);
 		}
-
-		status = SCI_SUCCESS;
-	} else {
+	} else
 		status = SCI_FAILURE;
-	}
 
 	return status;
 }
@@ -932,6 +914,7 @@ static void scic_sds_remote_node_context_validate_context_buffer(
 	struct scic_sds_remote_node_context *sci_rnc)
 {
 	struct scic_sds_remote_device *sci_dev = rnc_to_dev(sci_rnc);
+	struct domain_device *dev = sci_dev_to_domain(sci_dev);
 	union scu_remote_node_context *rnc_buffer;
 
 	rnc_buffer = scic_sds_controller_get_remote_node_context_buffer(
@@ -942,7 +925,7 @@ static void scic_sds_remote_node_context_validate_context_buffer(
 	rnc_buffer->ssp.is_valid = true;
 
 	if (!sci_dev->is_direct_attached &&
-	    sci_dev->target_protocols.u.bits.attached_stp_target) {
+	    (dev->dev_type == SATA_DEV || (dev->tproto & SAS_PROTOCOL_STP))) {
 		scic_sds_remote_device_post_request(sci_dev,
 						    SCU_CONTEXT_COMMAND_POST_RNC_96);
 	} else {
@@ -1063,11 +1046,12 @@ static void scic_sds_remote_node_context_resuming_state_enter(
 	struct sci_base_object *object)
 {
 	struct scic_sds_remote_node_context *rnc;
-	struct smp_discover_response_protocols protocols;
 	struct scic_sds_remote_device *sci_dev;
+	struct domain_device *dev;
 
 	rnc = (struct scic_sds_remote_node_context *)object;
 	sci_dev = rnc_to_dev(rnc);
+	dev = sci_dev_to_domain(sci_dev);
 
 	SET_STATE_HANDLER(
 		rnc,
@@ -1081,13 +1065,10 @@ static void scic_sds_remote_node_context_resuming_state_enter(
 	 * resume because of a target reset we also need to update
 	 * the STPTLDARNI register with the RNi of the device
 	 */
-	scic_remote_device_get_protocols(sci_dev, &protocols);
-
-	if (protocols.u.bits.attached_stp_target == 1 &&
-	    sci_dev->is_direct_attached) {
+	if ((dev->dev_type == SATA_DEV || (dev->tproto & SAS_PROTOCOL_STP)) &&
+	    sci_dev->is_direct_attached)
 		scic_sds_port_setup_transports(sci_dev->owning_port,
 					       rnc->remote_node_index);
-	}
 
 	scic_sds_remote_device_post_request(sci_dev, SCU_CONTEXT_COMMAND_POST_RNC_RESUME);
 }

commit 88f3b62ac131e2549b6c262cacbd47e8cca42d6e
Author: Dan Williams <dan.j.williams@intel.com>
Date:   Fri Apr 22 19:18:03 2011 -0700

    isci: move remote_device handling out of the core
    
    Now that the core/lldd remote_device data structures are nominally unified
    merge the corresponding sources into the top-level directory.  Also move the
    remote_node_context infrastructure which has no analog at the lldd level.
    
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/drivers/scsi/isci/remote_node_context.c b/drivers/scsi/isci/remote_node_context.c
new file mode 100644
index 000000000000..bdf0b5101cfa
--- /dev/null
+++ b/drivers/scsi/isci/remote_node_context.c
@@ -0,0 +1,1226 @@
+/*
+ * This file is provided under a dual BSD/GPLv2 license.  When using or
+ * redistributing this file, you may do so under either license.
+ *
+ * GPL LICENSE SUMMARY
+ *
+ * Copyright(c) 2008 - 2011 Intel Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
+ * The full GNU General Public License is included in this distribution
+ * in the file called LICENSE.GPL.
+ *
+ * BSD LICENSE
+ *
+ * Copyright(c) 2008 - 2011 Intel Corporation. All rights reserved.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ *   * Redistributions of source code must retain the above copyright
+ *     notice, this list of conditions and the following disclaimer.
+ *   * Redistributions in binary form must reproduce the above copyright
+ *     notice, this list of conditions and the following disclaimer in
+ *     the documentation and/or other materials provided with the
+ *     distribution.
+ *   * Neither the name of Intel Corporation nor the names of its
+ *     contributors may be used to endorse or promote products derived
+ *     from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include "sci_base_state_machine.h"
+#include "scic_sds_controller.h"
+#include "scic_sds_port.h"
+#include "remote_device.h"
+#include "remote_node_context.h"
+#include "sci_environment.h"
+#include "sci_util.h"
+#include "scu_event_codes.h"
+#include "scu_task_context.h"
+
+
+/**
+ *
+ * @sci_rnc: The RNC for which the is posted request is being made.
+ *
+ * This method will return true if the RNC is not in the initial state.  In all
+ * other states the RNC is considered active and this will return true. The
+ * destroy request of the state machine drives the RNC back to the initial
+ * state.  If the state machine changes then this routine will also have to be
+ * changed. bool true if the state machine is not in the initial state false if
+ * the state machine is in the initial state
+ */
+
+/**
+ *
+ * @sci_rnc: The state of the remote node context object to check.
+ *
+ * This method will return true if the remote node context is in a READY state
+ * otherwise it will return false bool true if the remote node context is in
+ * the ready state. false if the remote node context is not in the ready state.
+ */
+bool scic_sds_remote_node_context_is_ready(
+	struct scic_sds_remote_node_context *sci_rnc)
+{
+	u32 current_state = sci_base_state_machine_get_state(&sci_rnc->state_machine);
+
+	if (current_state == SCIC_SDS_REMOTE_NODE_CONTEXT_READY_STATE) {
+		return true;
+	}
+
+	return false;
+}
+
+/**
+ *
+ * @sci_dev: The remote device to use to construct the RNC buffer.
+ * @rnc: The buffer into which the remote device data will be copied.
+ *
+ * This method will construct the RNC buffer for this remote device object. none
+ */
+static void scic_sds_remote_node_context_construct_buffer(
+	struct scic_sds_remote_node_context *sci_rnc)
+{
+	union scu_remote_node_context *rnc;
+	struct scic_sds_remote_device *sci_dev = rnc_to_dev(sci_rnc);
+	struct scic_sds_controller *scic;
+
+	scic = scic_sds_remote_device_get_controller(sci_dev);
+
+	rnc = scic_sds_controller_get_remote_node_context_buffer(
+		scic, sci_rnc->remote_node_index);
+
+	memset(rnc, 0, sizeof(union scu_remote_node_context)
+		* scic_sds_remote_device_node_count(sci_dev));
+
+	rnc->ssp.remote_node_index = sci_rnc->remote_node_index;
+	rnc->ssp.remote_node_port_width = sci_dev->device_port_width;
+	rnc->ssp.logical_port_index =
+		scic_sds_remote_device_get_port_index(sci_dev);
+
+	rnc->ssp.remote_sas_address_hi = SCIC_SWAP_DWORD(sci_dev->device_address.high);
+	rnc->ssp.remote_sas_address_lo = SCIC_SWAP_DWORD(sci_dev->device_address.low);
+
+	rnc->ssp.nexus_loss_timer_enable = true;
+	rnc->ssp.check_bit               = false;
+	rnc->ssp.is_valid                = false;
+	rnc->ssp.is_remote_node_context  = true;
+	rnc->ssp.function_number         = 0;
+
+	rnc->ssp.arbitration_wait_time = 0;
+
+
+	if (
+		sci_dev->target_protocols.u.bits.attached_sata_device
+		|| sci_dev->target_protocols.u.bits.attached_stp_target
+		) {
+		rnc->ssp.connection_occupancy_timeout =
+			scic->user_parameters.sds1.stp_max_occupancy_timeout;
+		rnc->ssp.connection_inactivity_timeout =
+			scic->user_parameters.sds1.stp_inactivity_timeout;
+	} else {
+		rnc->ssp.connection_occupancy_timeout  =
+			scic->user_parameters.sds1.ssp_max_occupancy_timeout;
+		rnc->ssp.connection_inactivity_timeout =
+			scic->user_parameters.sds1.ssp_inactivity_timeout;
+	}
+
+	rnc->ssp.initial_arbitration_wait_time = 0;
+
+	/* Open Address Frame Parameters */
+	rnc->ssp.oaf_connection_rate = sci_dev->connection_rate;
+	rnc->ssp.oaf_features = 0;
+	rnc->ssp.oaf_source_zone_group = 0;
+	rnc->ssp.oaf_more_compatibility_features = 0;
+}
+
+/**
+ *
+ * @sci_rnc:
+ * @callback:
+ * @callback_parameter:
+ *
+ * This method will setup the remote node context object so it will transition
+ * to its ready state.  If the remote node context is already setup to
+ * transition to its final state then this function does nothing. none
+ */
+static void scic_sds_remote_node_context_setup_to_resume(
+	struct scic_sds_remote_node_context *sci_rnc,
+	scics_sds_remote_node_context_callback callback,
+	void *callback_parameter)
+{
+	if (sci_rnc->destination_state != SCIC_SDS_REMOTE_NODE_DESTINATION_STATE_FINAL) {
+		sci_rnc->destination_state = SCIC_SDS_REMOTE_NODE_DESTINATION_STATE_READY;
+		sci_rnc->user_callback     = callback;
+		sci_rnc->user_cookie       = callback_parameter;
+	}
+}
+
+/**
+ *
+ * @sci_rnc:
+ * @callback:
+ * @callback_parameter:
+ *
+ * This method will setup the remote node context object so it will transistion
+ * to its final state. none
+ */
+static void scic_sds_remote_node_context_setup_to_destory(
+	struct scic_sds_remote_node_context *sci_rnc,
+	scics_sds_remote_node_context_callback callback,
+	void *callback_parameter)
+{
+	sci_rnc->destination_state = SCIC_SDS_REMOTE_NODE_DESTINATION_STATE_FINAL;
+	sci_rnc->user_callback     = callback;
+	sci_rnc->user_cookie       = callback_parameter;
+}
+
+/**
+ *
+ * @sci_rnc:
+ * @callback:
+ *
+ * This method will continue to resume a remote node context.  This is used in
+ * the states where a resume is requested while a resume is in progress.
+ */
+static enum sci_status scic_sds_remote_node_context_continue_to_resume_handler(
+	struct scic_sds_remote_node_context *sci_rnc,
+	scics_sds_remote_node_context_callback callback,
+	void *callback_parameter)
+{
+	if (sci_rnc->destination_state == SCIC_SDS_REMOTE_NODE_DESTINATION_STATE_READY) {
+		sci_rnc->user_callback = callback;
+		sci_rnc->user_cookie   = callback_parameter;
+
+		return SCI_SUCCESS;
+	}
+
+	return SCI_FAILURE_INVALID_STATE;
+}
+
+/* --------------------------------------------------------------------------- */
+
+static enum sci_status scic_sds_remote_node_context_default_destruct_handler(
+	struct scic_sds_remote_node_context *sci_rnc,
+	scics_sds_remote_node_context_callback callback,
+	void *callback_parameter)
+{
+	dev_warn(scirdev_to_dev(rnc_to_dev(sci_rnc)),
+		 "%s: SCIC Remote Node Context 0x%p requested to stop while "
+		 "in unexpected state %d\n",
+		 __func__,
+		 sci_rnc,
+		 sci_base_state_machine_get_state(&sci_rnc->state_machine));
+
+	/*
+	 * We have decided that the destruct request on the remote node context can not fail
+	 * since it is either in the initial/destroyed state or is can be destroyed. */
+	return SCI_SUCCESS;
+}
+
+static enum sci_status scic_sds_remote_node_context_default_suspend_handler(
+	struct scic_sds_remote_node_context *sci_rnc,
+	u32 suspend_type,
+	scics_sds_remote_node_context_callback callback,
+	void *callback_parameter)
+{
+	dev_warn(scirdev_to_dev(rnc_to_dev(sci_rnc)),
+		 "%s: SCIC Remote Node Context 0x%p requested to suspend "
+		 "while in wrong state %d\n",
+		 __func__,
+		 sci_rnc,
+		 sci_base_state_machine_get_state(&sci_rnc->state_machine));
+
+	return SCI_FAILURE_INVALID_STATE;
+}
+
+static enum sci_status scic_sds_remote_node_context_default_resume_handler(
+	struct scic_sds_remote_node_context *sci_rnc,
+	scics_sds_remote_node_context_callback callback,
+	void *callback_parameter)
+{
+	dev_warn(scirdev_to_dev(rnc_to_dev(sci_rnc)),
+		 "%s: SCIC Remote Node Context 0x%p requested to resume "
+		 "while in wrong state %d\n",
+		 __func__,
+		 sci_rnc,
+		 sci_base_state_machine_get_state(&sci_rnc->state_machine));
+
+	return SCI_FAILURE_INVALID_STATE;
+}
+
+static enum sci_status scic_sds_remote_node_context_default_start_io_handler(
+	struct scic_sds_remote_node_context *sci_rnc,
+	struct scic_sds_request *sci_req)
+{
+	dev_warn(scirdev_to_dev(rnc_to_dev(sci_rnc)),
+		 "%s: SCIC Remote Node Context 0x%p requested to start io "
+		 "0x%p while in wrong state %d\n",
+		 __func__,
+		 sci_rnc,
+		 sci_req,
+		 sci_base_state_machine_get_state(&sci_rnc->state_machine));
+
+	return SCI_FAILURE_REMOTE_DEVICE_RESET_REQUIRED;
+}
+
+static enum sci_status scic_sds_remote_node_context_default_start_task_handler(
+	struct scic_sds_remote_node_context *sci_rnc,
+	struct scic_sds_request *sci_req)
+{
+	dev_warn(scirdev_to_dev(rnc_to_dev(sci_rnc)),
+		 "%s: SCIC Remote Node Context 0x%p requested to start "
+		 "task 0x%p while in wrong state %d\n",
+		 __func__,
+		 sci_rnc,
+		 sci_req,
+		 sci_base_state_machine_get_state(&sci_rnc->state_machine));
+
+	return SCI_FAILURE;
+}
+
+static enum sci_status scic_sds_remote_node_context_default_event_handler(
+	struct scic_sds_remote_node_context *sci_rnc,
+	u32 event_code)
+{
+	dev_warn(scirdev_to_dev(rnc_to_dev(sci_rnc)),
+		 "%s: SCIC Remote Node Context 0x%p requested to process "
+		 "event 0x%x while in wrong state %d\n",
+		 __func__,
+		 sci_rnc,
+		 event_code,
+		 sci_base_state_machine_get_state(&sci_rnc->state_machine));
+
+	return SCI_FAILURE_INVALID_STATE;
+}
+
+/**
+ *
+ * @sci_rnc: The rnc for which the task request is targeted.
+ * @sci_req: The request which is going to be started.
+ *
+ * This method determines if the task request can be started by the SCU
+ * hardware. When the RNC is in the ready state any task can be started.
+ * enum sci_status SCI_SUCCESS
+ */
+static enum sci_status scic_sds_remote_node_context_success_start_task_handler(
+	struct scic_sds_remote_node_context *sci_rnc,
+	struct scic_sds_request *sci_req)
+{
+	return SCI_SUCCESS;
+}
+
+/**
+ *
+ * @sci_rnc:
+ * @callback:
+ * @callback_parameter:
+ *
+ * This method handles destruct calls from the various state handlers.  The
+ * remote node context can be requested to destroy from any state. If there was
+ * a user callback it is always replaced with the request to destroy user
+ * callback. enum sci_status
+ */
+static enum sci_status scic_sds_remote_node_context_general_destruct_handler(
+	struct scic_sds_remote_node_context *sci_rnc,
+	scics_sds_remote_node_context_callback callback,
+	void *callback_parameter)
+{
+	scic_sds_remote_node_context_setup_to_destory(
+		sci_rnc, callback, callback_parameter
+		);
+
+	sci_base_state_machine_change_state(
+		&sci_rnc->state_machine,
+		SCIC_SDS_REMOTE_NODE_CONTEXT_INVALIDATING_STATE
+		);
+
+	return SCI_SUCCESS;
+}
+
+/* --------------------------------------------------------------------------- */
+
+static enum sci_status scic_sds_remote_node_context_initial_state_resume_handler(
+	struct scic_sds_remote_node_context *sci_rnc,
+	scics_sds_remote_node_context_callback callback,
+	void *callback_parameter)
+{
+	if (sci_rnc->remote_node_index != SCIC_SDS_REMOTE_NODE_CONTEXT_INVALID_INDEX) {
+		scic_sds_remote_node_context_setup_to_resume(
+			sci_rnc, callback, callback_parameter
+			);
+
+		scic_sds_remote_node_context_construct_buffer(sci_rnc);
+
+		sci_base_state_machine_change_state(
+			&sci_rnc->state_machine,
+			SCIC_SDS_REMOTE_NODE_CONTEXT_POSTING_STATE
+			);
+
+		return SCI_SUCCESS;
+	}
+
+	return SCI_FAILURE_INVALID_STATE;
+}
+
+/* --------------------------------------------------------------------------- */
+
+static enum sci_status scic_sds_remote_node_context_posting_state_event_handler(
+	struct scic_sds_remote_node_context *sci_rnc,
+	u32 event_code)
+{
+	enum sci_status status;
+
+	switch (scu_get_event_code(event_code)) {
+	case SCU_EVENT_POST_RNC_COMPLETE:
+		status = SCI_SUCCESS;
+
+		sci_base_state_machine_change_state(
+			&sci_rnc->state_machine,
+			SCIC_SDS_REMOTE_NODE_CONTEXT_READY_STATE
+			);
+		break;
+
+	default:
+		status = SCI_FAILURE;
+		dev_warn(scirdev_to_dev(rnc_to_dev(sci_rnc)),
+			 "%s: SCIC Remote Node Context 0x%p requested to "
+			 "process unexpected event 0x%x while in posting "
+			 "state\n",
+			 __func__,
+			 sci_rnc,
+			 event_code);
+		break;
+	}
+
+	return status;
+}
+
+/* --------------------------------------------------------------------------- */
+
+static enum sci_status scic_sds_remote_node_context_invalidating_state_destruct_handler(
+	struct scic_sds_remote_node_context *sci_rnc,
+	scics_sds_remote_node_context_callback callback,
+	void *callback_parameter)
+{
+	scic_sds_remote_node_context_setup_to_destory(
+		sci_rnc, callback, callback_parameter
+		);
+
+	return SCI_SUCCESS;
+}
+
+static enum sci_status scic_sds_remote_node_context_invalidating_state_event_handler(
+	struct scic_sds_remote_node_context *sci_rnc,
+	u32 event_code)
+{
+	enum sci_status status;
+
+	if (scu_get_event_code(event_code) == SCU_EVENT_POST_RNC_INVALIDATE_COMPLETE) {
+		status = SCI_SUCCESS;
+
+		if (sci_rnc->destination_state == SCIC_SDS_REMOTE_NODE_DESTINATION_STATE_FINAL) {
+			sci_base_state_machine_change_state(
+				&sci_rnc->state_machine,
+				SCIC_SDS_REMOTE_NODE_CONTEXT_INITIAL_STATE
+				);
+		} else {
+			sci_base_state_machine_change_state(
+				&sci_rnc->state_machine,
+				SCIC_SDS_REMOTE_NODE_CONTEXT_POSTING_STATE
+				);
+		}
+	} else {
+		switch (scu_get_event_type(event_code)) {
+		case SCU_EVENT_TYPE_RNC_SUSPEND_TX:
+		case SCU_EVENT_TYPE_RNC_SUSPEND_TX_RX:
+			/*
+			 * We really dont care if the hardware is going to suspend
+			 * the device since it's being invalidated anyway */
+			dev_dbg(scirdev_to_dev(rnc_to_dev(sci_rnc)),
+				"%s: SCIC Remote Node Context 0x%p was "
+				"suspeneded by hardware while being "
+				"invalidated.\n",
+				__func__,
+				sci_rnc);
+			status = SCI_SUCCESS;
+			break;
+
+		default:
+			dev_warn(scirdev_to_dev(rnc_to_dev(sci_rnc)),
+				 "%s: SCIC Remote Node Context 0x%p "
+				 "requested to process event 0x%x while "
+				 "in state %d.\n",
+				 __func__,
+				 sci_rnc,
+				 event_code,
+				 sci_base_state_machine_get_state(
+					 &sci_rnc->state_machine));
+			status = SCI_FAILURE;
+			break;
+		}
+	}
+
+	return status;
+}
+
+/* --------------------------------------------------------------------------- */
+
+
+static enum sci_status scic_sds_remote_node_context_resuming_state_event_handler(
+	struct scic_sds_remote_node_context *sci_rnc,
+	u32 event_code)
+{
+	enum sci_status status;
+
+	if (scu_get_event_code(event_code) == SCU_EVENT_POST_RCN_RELEASE) {
+		status = SCI_SUCCESS;
+
+		sci_base_state_machine_change_state(
+			&sci_rnc->state_machine,
+			SCIC_SDS_REMOTE_NODE_CONTEXT_READY_STATE
+			);
+	} else {
+		switch (scu_get_event_type(event_code)) {
+		case SCU_EVENT_TYPE_RNC_SUSPEND_TX:
+		case SCU_EVENT_TYPE_RNC_SUSPEND_TX_RX:
+			/*
+			 * We really dont care if the hardware is going to suspend
+			 * the device since it's being resumed anyway */
+			dev_dbg(scirdev_to_dev(rnc_to_dev(sci_rnc)),
+				"%s: SCIC Remote Node Context 0x%p was "
+				"suspeneded by hardware while being resumed.\n",
+				__func__,
+				sci_rnc);
+			status = SCI_SUCCESS;
+			break;
+
+		default:
+			dev_warn(scirdev_to_dev(rnc_to_dev(sci_rnc)),
+				 "%s: SCIC Remote Node Context 0x%p requested "
+				 "to process event 0x%x while in state %d.\n",
+				 __func__,
+				 sci_rnc,
+				 event_code,
+				 sci_base_state_machine_get_state(
+					 &sci_rnc->state_machine));
+			status = SCI_FAILURE;
+			break;
+		}
+	}
+
+	return status;
+}
+
+/* --------------------------------------------------------------------------- */
+
+/**
+ *
+ * @sci_rnc: The remote node context object being suspended.
+ * @callback: The callback when the suspension is complete.
+ * @callback_parameter: The parameter that is to be passed into the callback.
+ *
+ * This method will handle the suspend requests from the ready state.
+ * SCI_SUCCESS
+ */
+static enum sci_status scic_sds_remote_node_context_ready_state_suspend_handler(
+	struct scic_sds_remote_node_context *sci_rnc,
+	u32 suspend_type,
+	scics_sds_remote_node_context_callback callback,
+	void *callback_parameter)
+{
+	sci_rnc->user_callback   = callback;
+	sci_rnc->user_cookie     = callback_parameter;
+	sci_rnc->suspension_code = suspend_type;
+
+	if (suspend_type == SCI_SOFTWARE_SUSPENSION) {
+		scic_sds_remote_device_post_request(rnc_to_dev(sci_rnc),
+						    SCU_CONTEXT_COMMAND_POST_RNC_SUSPEND_TX);
+	}
+
+	sci_base_state_machine_change_state(
+		&sci_rnc->state_machine,
+		SCIC_SDS_REMOTE_NODE_CONTEXT_AWAIT_SUSPENSION_STATE
+		);
+
+	return SCI_SUCCESS;
+}
+
+/**
+ *
+ * @sci_rnc: The rnc for which the io request is targeted.
+ * @sci_req: The request which is going to be started.
+ *
+ * This method determines if the io request can be started by the SCU hardware.
+ * When the RNC is in the ready state any io request can be started. enum sci_status
+ * SCI_SUCCESS
+ */
+static enum sci_status scic_sds_remote_node_context_ready_state_start_io_handler(
+	struct scic_sds_remote_node_context *sci_rnc,
+	struct scic_sds_request *sci_req)
+{
+	return SCI_SUCCESS;
+}
+
+
+static enum sci_status scic_sds_remote_node_context_ready_state_event_handler(
+	struct scic_sds_remote_node_context *sci_rnc,
+	u32 event_code)
+{
+	enum sci_status status;
+
+	switch (scu_get_event_type(event_code)) {
+	case SCU_EVENT_TL_RNC_SUSPEND_TX:
+		sci_base_state_machine_change_state(
+			&sci_rnc->state_machine,
+			SCIC_SDS_REMOTE_NODE_CONTEXT_TX_SUSPENDED_STATE
+			);
+
+		sci_rnc->suspension_code = scu_get_event_specifier(event_code);
+		status = SCI_SUCCESS;
+		break;
+
+	case SCU_EVENT_TL_RNC_SUSPEND_TX_RX:
+		sci_base_state_machine_change_state(
+			&sci_rnc->state_machine,
+			SCIC_SDS_REMOTE_NODE_CONTEXT_TX_RX_SUSPENDED_STATE
+			);
+
+		sci_rnc->suspension_code = scu_get_event_specifier(event_code);
+		status = SCI_SUCCESS;
+		break;
+
+	default:
+		dev_warn(scirdev_to_dev(rnc_to_dev(sci_rnc)),
+			"%s: SCIC Remote Node Context 0x%p requested to "
+			"process event 0x%x while in state %d.\n",
+			__func__,
+			sci_rnc,
+			event_code,
+			sci_base_state_machine_get_state(
+				&sci_rnc->state_machine));
+
+		status = SCI_FAILURE;
+		break;
+	}
+
+	return status;
+}
+
+/* --------------------------------------------------------------------------- */
+
+static enum sci_status scic_sds_remote_node_context_tx_suspended_state_resume_handler(
+	struct scic_sds_remote_node_context *sci_rnc,
+	scics_sds_remote_node_context_callback callback,
+	void *callback_parameter)
+{
+	enum sci_status status;
+	struct smp_discover_response_protocols protocols;
+
+	scic_sds_remote_node_context_setup_to_resume(
+		sci_rnc, callback, callback_parameter
+		);
+
+	/* TODO: consider adding a resume action of NONE, INVALIDATE, WRITE_TLCR */
+
+	scic_remote_device_get_protocols(rnc_to_dev(sci_rnc), &protocols);
+
+	if (
+		(protocols.u.bits.attached_ssp_target == 1)
+		|| (protocols.u.bits.attached_smp_target == 1)
+		) {
+		sci_base_state_machine_change_state(
+			&sci_rnc->state_machine,
+			SCIC_SDS_REMOTE_NODE_CONTEXT_RESUMING_STATE
+			);
+
+		status = SCI_SUCCESS;
+	} else if (protocols.u.bits.attached_stp_target == 1) {
+		if (rnc_to_dev(sci_rnc)->is_direct_attached) {
+			/* @todo Fix this since I am being silly in writing to the STPTLDARNI register. */
+			sci_base_state_machine_change_state(
+				&sci_rnc->state_machine,
+				SCIC_SDS_REMOTE_NODE_CONTEXT_RESUMING_STATE
+				);
+		} else {
+			sci_base_state_machine_change_state(
+				&sci_rnc->state_machine,
+				SCIC_SDS_REMOTE_NODE_CONTEXT_INVALIDATING_STATE
+				);
+		}
+
+		status = SCI_SUCCESS;
+	} else {
+		status = SCI_FAILURE;
+	}
+
+	return status;
+}
+
+/**
+ *
+ * @sci_rnc: The remote node context which is to receive the task request.
+ * @sci_req: The task request to be transmitted to to the remote target
+ *    device.
+ *
+ * This method will report a success or failure attempt to start a new task
+ * request to the hardware.  Since all task requests are sent on the high
+ * priority queue they can be sent when the RCN is in a TX suspend state.
+ * enum sci_status SCI_SUCCESS
+ */
+static enum sci_status scic_sds_remote_node_context_suspended_start_task_handler(
+	struct scic_sds_remote_node_context *sci_rnc,
+	struct scic_sds_request *sci_req)
+{
+	scic_sds_remote_node_context_resume(sci_rnc, NULL, NULL);
+
+	return SCI_SUCCESS;
+}
+
+/* --------------------------------------------------------------------------- */
+
+static enum sci_status scic_sds_remote_node_context_tx_rx_suspended_state_resume_handler(
+	struct scic_sds_remote_node_context *sci_rnc,
+	scics_sds_remote_node_context_callback callback,
+	void *callback_parameter)
+{
+	scic_sds_remote_node_context_setup_to_resume(
+		sci_rnc, callback, callback_parameter
+		);
+
+	sci_base_state_machine_change_state(
+		&sci_rnc->state_machine,
+		SCIC_SDS_REMOTE_NODE_CONTEXT_RESUMING_STATE
+		);
+
+	return SCI_FAILURE_INVALID_STATE;
+}
+
+/* --------------------------------------------------------------------------- */
+
+/**
+ *
+ *
+ *
+ */
+static enum sci_status scic_sds_remote_node_context_await_suspension_state_resume_handler(
+	struct scic_sds_remote_node_context *sci_rnc,
+	scics_sds_remote_node_context_callback callback,
+	void *callback_parameter)
+{
+	scic_sds_remote_node_context_setup_to_resume(
+		sci_rnc, callback, callback_parameter
+		);
+
+	return SCI_SUCCESS;
+}
+
+/**
+ *
+ * @sci_rnc: The remote node context which is to receive the task request.
+ * @sci_req: The task request to be transmitted to to the remote target
+ *    device.
+ *
+ * This method will report a success or failure attempt to start a new task
+ * request to the hardware.  Since all task requests are sent on the high
+ * priority queue they can be sent when the RCN is in a TX suspend state.
+ * enum sci_status SCI_SUCCESS
+ */
+static enum sci_status scic_sds_remote_node_context_await_suspension_state_start_task_handler(
+	struct scic_sds_remote_node_context *sci_rnc,
+	struct scic_sds_request *sci_req)
+{
+	return SCI_SUCCESS;
+}
+
+static enum sci_status scic_sds_remote_node_context_await_suspension_state_event_handler(
+	struct scic_sds_remote_node_context *sci_rnc,
+	u32 event_code)
+{
+	enum sci_status status;
+
+	switch (scu_get_event_type(event_code)) {
+	case SCU_EVENT_TL_RNC_SUSPEND_TX:
+		sci_base_state_machine_change_state(
+			&sci_rnc->state_machine,
+			SCIC_SDS_REMOTE_NODE_CONTEXT_TX_SUSPENDED_STATE
+			);
+
+		sci_rnc->suspension_code = scu_get_event_specifier(event_code);
+		status = SCI_SUCCESS;
+		break;
+
+	case SCU_EVENT_TL_RNC_SUSPEND_TX_RX:
+		sci_base_state_machine_change_state(
+			&sci_rnc->state_machine,
+			SCIC_SDS_REMOTE_NODE_CONTEXT_TX_RX_SUSPENDED_STATE
+			);
+
+		sci_rnc->suspension_code = scu_get_event_specifier(event_code);
+		status = SCI_SUCCESS;
+		break;
+
+	default:
+		dev_warn(scirdev_to_dev(rnc_to_dev(sci_rnc)),
+			 "%s: SCIC Remote Node Context 0x%p requested to "
+			 "process event 0x%x while in state %d.\n",
+			 __func__,
+			 sci_rnc,
+			 event_code,
+			 sci_base_state_machine_get_state(
+				 &sci_rnc->state_machine));
+
+		status = SCI_FAILURE;
+		break;
+	}
+
+	return status;
+}
+
+/* --------------------------------------------------------------------------- */
+
+static struct scic_sds_remote_node_context_handlers
+scic_sds_remote_node_context_state_handler_table[
+	SCIC_SDS_REMOTE_NODE_CONTEXT_MAX_STATES] =
+{
+	/* SCIC_SDS_REMOTE_NODE_CONTEXT_INITIAL_STATE */
+	{
+		scic_sds_remote_node_context_default_destruct_handler,
+		scic_sds_remote_node_context_default_suspend_handler,
+		scic_sds_remote_node_context_initial_state_resume_handler,
+		scic_sds_remote_node_context_default_start_io_handler,
+		scic_sds_remote_node_context_default_start_task_handler,
+		scic_sds_remote_node_context_default_event_handler
+	},
+	/* SCIC_SDS_REMOTE_NODE_CONTEXT_POSTING_STATE */
+	{
+		scic_sds_remote_node_context_general_destruct_handler,
+		scic_sds_remote_node_context_default_suspend_handler,
+		scic_sds_remote_node_context_continue_to_resume_handler,
+		scic_sds_remote_node_context_default_start_io_handler,
+		scic_sds_remote_node_context_default_start_task_handler,
+		scic_sds_remote_node_context_posting_state_event_handler
+	},
+	/* SCIC_SDS_REMOTE_NODE_CONTEXT_INVALIDATING_STATE */
+	{
+		scic_sds_remote_node_context_invalidating_state_destruct_handler,
+		scic_sds_remote_node_context_default_suspend_handler,
+		scic_sds_remote_node_context_continue_to_resume_handler,
+		scic_sds_remote_node_context_default_start_io_handler,
+		scic_sds_remote_node_context_default_start_task_handler,
+		scic_sds_remote_node_context_invalidating_state_event_handler
+	},
+	/* SCIC_SDS_REMOTE_NODE_CONTEXT_RESUMING_STATE */
+	{
+		scic_sds_remote_node_context_general_destruct_handler,
+		scic_sds_remote_node_context_default_suspend_handler,
+		scic_sds_remote_node_context_continue_to_resume_handler,
+		scic_sds_remote_node_context_default_start_io_handler,
+		scic_sds_remote_node_context_success_start_task_handler,
+		scic_sds_remote_node_context_resuming_state_event_handler
+	},
+	/* SCIC_SDS_REMOTE_NODE_CONTEXT_READY_STATE */
+	{
+		scic_sds_remote_node_context_general_destruct_handler,
+		scic_sds_remote_node_context_ready_state_suspend_handler,
+		scic_sds_remote_node_context_default_resume_handler,
+		scic_sds_remote_node_context_ready_state_start_io_handler,
+		scic_sds_remote_node_context_success_start_task_handler,
+		scic_sds_remote_node_context_ready_state_event_handler
+	},
+	/* SCIC_SDS_REMOTE_NODE_CONTEXT_TX_SUSPENDED_STATE */
+	{
+		scic_sds_remote_node_context_general_destruct_handler,
+		scic_sds_remote_node_context_default_suspend_handler,
+		scic_sds_remote_node_context_tx_suspended_state_resume_handler,
+		scic_sds_remote_node_context_default_start_io_handler,
+		scic_sds_remote_node_context_suspended_start_task_handler,
+		scic_sds_remote_node_context_default_event_handler
+	},
+	/* SCIC_SDS_REMOTE_NODE_CONTEXT_TX_RX_SUSPENDED_STATE */
+	{
+		scic_sds_remote_node_context_general_destruct_handler,
+		scic_sds_remote_node_context_default_suspend_handler,
+		scic_sds_remote_node_context_tx_rx_suspended_state_resume_handler,
+		scic_sds_remote_node_context_default_start_io_handler,
+		scic_sds_remote_node_context_suspended_start_task_handler,
+		scic_sds_remote_node_context_default_event_handler
+	},
+	/* SCIC_SDS_REMOTE_NODE_CONTEXT_AWAIT_SUSPENSION_STATE */
+	{
+		scic_sds_remote_node_context_general_destruct_handler,
+		scic_sds_remote_node_context_default_suspend_handler,
+		scic_sds_remote_node_context_await_suspension_state_resume_handler,
+		scic_sds_remote_node_context_default_start_io_handler,
+		scic_sds_remote_node_context_await_suspension_state_start_task_handler,
+		scic_sds_remote_node_context_await_suspension_state_event_handler
+	}
+};
+
+/*
+ * *****************************************************************************
+ * * REMOTE NODE CONTEXT PRIVATE METHODS
+ * ***************************************************************************** */
+
+/**
+ *
+ *
+ * This method just calls the user callback function and then resets the
+ * callback.
+ */
+static void scic_sds_remote_node_context_notify_user(
+	struct scic_sds_remote_node_context *rnc)
+{
+	if (rnc->user_callback != NULL) {
+		(*rnc->user_callback)(rnc->user_cookie);
+
+		rnc->user_callback = NULL;
+		rnc->user_cookie = NULL;
+	}
+}
+
+/**
+ *
+ *
+ * This method will continue the remote node context state machine by
+ * requesting to resume the remote node context state machine from its current
+ * state.
+ */
+static void scic_sds_remote_node_context_continue_state_transitions(
+	struct scic_sds_remote_node_context *rnc)
+{
+	if (rnc->destination_state == SCIC_SDS_REMOTE_NODE_DESTINATION_STATE_READY) {
+		rnc->state_handlers->resume_handler(
+			rnc, rnc->user_callback, rnc->user_cookie
+			);
+	}
+}
+
+/**
+ *
+ * @sci_rnc: The remote node context object that is to be validated.
+ *
+ * This method will mark the rnc buffer as being valid and post the request to
+ * the hardware. none
+ */
+static void scic_sds_remote_node_context_validate_context_buffer(
+	struct scic_sds_remote_node_context *sci_rnc)
+{
+	struct scic_sds_remote_device *sci_dev = rnc_to_dev(sci_rnc);
+	union scu_remote_node_context *rnc_buffer;
+
+	rnc_buffer = scic_sds_controller_get_remote_node_context_buffer(
+		scic_sds_remote_device_get_controller(sci_dev),
+		sci_rnc->remote_node_index
+		);
+
+	rnc_buffer->ssp.is_valid = true;
+
+	if (!sci_dev->is_direct_attached &&
+	    sci_dev->target_protocols.u.bits.attached_stp_target) {
+		scic_sds_remote_device_post_request(sci_dev,
+						    SCU_CONTEXT_COMMAND_POST_RNC_96);
+	} else {
+		scic_sds_remote_device_post_request(sci_dev, SCU_CONTEXT_COMMAND_POST_RNC_32);
+
+		if (sci_dev->is_direct_attached) {
+			scic_sds_port_setup_transports(sci_dev->owning_port,
+						       sci_rnc->remote_node_index);
+		}
+	}
+}
+
+/**
+ *
+ * @sci_rnc: The remote node context object that is to be invalidated.
+ *
+ * This method will update the RNC buffer and post the invalidate request. none
+ */
+static void scic_sds_remote_node_context_invalidate_context_buffer(
+	struct scic_sds_remote_node_context *sci_rnc)
+{
+	union scu_remote_node_context *rnc_buffer;
+
+	rnc_buffer = scic_sds_controller_get_remote_node_context_buffer(
+		scic_sds_remote_device_get_controller(rnc_to_dev(sci_rnc)),
+		sci_rnc->remote_node_index);
+
+	rnc_buffer->ssp.is_valid = false;
+
+	scic_sds_remote_device_post_request(rnc_to_dev(sci_rnc),
+					    SCU_CONTEXT_COMMAND_POST_RNC_INVALIDATE);
+}
+
+/*
+ * *****************************************************************************
+ * * REMOTE NODE CONTEXT STATE ENTER AND EXIT METHODS
+ * ***************************************************************************** */
+
+/**
+ *
+ *
+ *
+ */
+static void scic_sds_remote_node_context_initial_state_enter(
+	struct sci_base_object *object)
+{
+	struct scic_sds_remote_node_context *rnc;
+
+	rnc = (struct scic_sds_remote_node_context *)object;
+
+	SET_STATE_HANDLER(
+		rnc,
+		scic_sds_remote_node_context_state_handler_table,
+		SCIC_SDS_REMOTE_NODE_CONTEXT_INITIAL_STATE
+		);
+
+	/*
+	 * Check to see if we have gotten back to the initial state because someone
+	 * requested to destroy the remote node context object. */
+	if (
+		rnc->state_machine.previous_state_id
+		== SCIC_SDS_REMOTE_NODE_CONTEXT_INVALIDATING_STATE
+		) {
+		rnc->destination_state = SCIC_SDS_REMOTE_NODE_DESTINATION_STATE_UNSPECIFIED;
+
+		scic_sds_remote_node_context_notify_user(rnc);
+	}
+}
+
+/**
+ *
+ *
+ *
+ */
+static void scic_sds_remote_node_context_posting_state_enter(
+	struct sci_base_object *object)
+{
+	struct scic_sds_remote_node_context *sci_rnc;
+
+	sci_rnc = (struct scic_sds_remote_node_context *)object;
+
+	SET_STATE_HANDLER(
+		sci_rnc,
+		scic_sds_remote_node_context_state_handler_table,
+		SCIC_SDS_REMOTE_NODE_CONTEXT_POSTING_STATE
+		);
+
+	scic_sds_remote_node_context_validate_context_buffer(sci_rnc);
+}
+
+/**
+ *
+ *
+ *
+ */
+static void scic_sds_remote_node_context_invalidating_state_enter(
+	struct sci_base_object *object)
+{
+	struct scic_sds_remote_node_context *rnc;
+
+	rnc = (struct scic_sds_remote_node_context *)object;
+
+	SET_STATE_HANDLER(
+		rnc,
+		scic_sds_remote_node_context_state_handler_table,
+		SCIC_SDS_REMOTE_NODE_CONTEXT_INVALIDATING_STATE
+		);
+
+	scic_sds_remote_node_context_invalidate_context_buffer(rnc);
+}
+
+/**
+ *
+ *
+ *
+ */
+static void scic_sds_remote_node_context_resuming_state_enter(
+	struct sci_base_object *object)
+{
+	struct scic_sds_remote_node_context *rnc;
+	struct smp_discover_response_protocols protocols;
+	struct scic_sds_remote_device *sci_dev;
+
+	rnc = (struct scic_sds_remote_node_context *)object;
+	sci_dev = rnc_to_dev(rnc);
+
+	SET_STATE_HANDLER(
+		rnc,
+		scic_sds_remote_node_context_state_handler_table,
+		SCIC_SDS_REMOTE_NODE_CONTEXT_RESUMING_STATE
+		);
+
+	/*
+	 * For direct attached SATA devices we need to clear the TLCR
+	 * NCQ to TCi tag mapping on the phy and in cases where we
+	 * resume because of a target reset we also need to update
+	 * the STPTLDARNI register with the RNi of the device
+	 */
+	scic_remote_device_get_protocols(sci_dev, &protocols);
+
+	if (protocols.u.bits.attached_stp_target == 1 &&
+	    sci_dev->is_direct_attached) {
+		scic_sds_port_setup_transports(sci_dev->owning_port,
+					       rnc->remote_node_index);
+	}
+
+	scic_sds_remote_device_post_request(sci_dev, SCU_CONTEXT_COMMAND_POST_RNC_RESUME);
+}
+
+/**
+ *
+ *
+ *
+ */
+static void scic_sds_remote_node_context_ready_state_enter(
+	struct sci_base_object *object)
+{
+	struct scic_sds_remote_node_context *rnc;
+
+	rnc = (struct scic_sds_remote_node_context *)object;
+
+	SET_STATE_HANDLER(
+		rnc,
+		scic_sds_remote_node_context_state_handler_table,
+		SCIC_SDS_REMOTE_NODE_CONTEXT_READY_STATE
+		);
+
+	rnc->destination_state = SCIC_SDS_REMOTE_NODE_DESTINATION_STATE_UNSPECIFIED;
+
+	if (rnc->user_callback != NULL) {
+		scic_sds_remote_node_context_notify_user(rnc);
+	}
+}
+
+/**
+ *
+ *
+ *
+ */
+static void scic_sds_remote_node_context_tx_suspended_state_enter(
+	struct sci_base_object *object)
+{
+	struct scic_sds_remote_node_context *rnc;
+
+	rnc = (struct scic_sds_remote_node_context *)object;
+
+	SET_STATE_HANDLER(
+		rnc,
+		scic_sds_remote_node_context_state_handler_table,
+		SCIC_SDS_REMOTE_NODE_CONTEXT_TX_SUSPENDED_STATE
+		);
+
+	scic_sds_remote_node_context_continue_state_transitions(rnc);
+}
+
+/**
+ *
+ *
+ *
+ */
+static void scic_sds_remote_node_context_tx_rx_suspended_state_enter(
+	struct sci_base_object *object)
+{
+	struct scic_sds_remote_node_context *rnc;
+
+	rnc = (struct scic_sds_remote_node_context *)object;
+
+	SET_STATE_HANDLER(
+		rnc,
+		scic_sds_remote_node_context_state_handler_table,
+		SCIC_SDS_REMOTE_NODE_CONTEXT_TX_RX_SUSPENDED_STATE
+		);
+
+	scic_sds_remote_node_context_continue_state_transitions(rnc);
+}
+
+/**
+ *
+ *
+ *
+ */
+static void scic_sds_remote_node_context_await_suspension_state_enter(
+	struct sci_base_object *object)
+{
+	struct scic_sds_remote_node_context *rnc;
+
+	rnc = (struct scic_sds_remote_node_context *)object;
+
+	SET_STATE_HANDLER(
+		rnc,
+		scic_sds_remote_node_context_state_handler_table,
+		SCIC_SDS_REMOTE_NODE_CONTEXT_AWAIT_SUSPENSION_STATE
+		);
+}
+
+/* --------------------------------------------------------------------------- */
+
+static const struct sci_base_state scic_sds_remote_node_context_state_table[] = {
+	[SCIC_SDS_REMOTE_NODE_CONTEXT_INITIAL_STATE] = {
+		.enter_state = scic_sds_remote_node_context_initial_state_enter,
+	},
+	[SCIC_SDS_REMOTE_NODE_CONTEXT_POSTING_STATE] = {
+		.enter_state = scic_sds_remote_node_context_posting_state_enter,
+	},
+	[SCIC_SDS_REMOTE_NODE_CONTEXT_INVALIDATING_STATE] = {
+		.enter_state = scic_sds_remote_node_context_invalidating_state_enter,
+	},
+	[SCIC_SDS_REMOTE_NODE_CONTEXT_RESUMING_STATE] = {
+		.enter_state = scic_sds_remote_node_context_resuming_state_enter,
+	},
+	[SCIC_SDS_REMOTE_NODE_CONTEXT_READY_STATE] = {
+		.enter_state = scic_sds_remote_node_context_ready_state_enter,
+	},
+	[SCIC_SDS_REMOTE_NODE_CONTEXT_TX_SUSPENDED_STATE] = {
+		.enter_state = scic_sds_remote_node_context_tx_suspended_state_enter,
+	},
+	[SCIC_SDS_REMOTE_NODE_CONTEXT_TX_RX_SUSPENDED_STATE] = {
+		.enter_state = scic_sds_remote_node_context_tx_rx_suspended_state_enter,
+	},
+	[SCIC_SDS_REMOTE_NODE_CONTEXT_AWAIT_SUSPENSION_STATE] = {
+		.enter_state = scic_sds_remote_node_context_await_suspension_state_enter,
+	},
+};
+
+void scic_sds_remote_node_context_construct(struct scic_sds_remote_node_context *rnc,
+					    u16 remote_node_index)
+{
+	memset(rnc, 0, sizeof(struct scic_sds_remote_node_context));
+
+	rnc->remote_node_index = remote_node_index;
+	rnc->destination_state = SCIC_SDS_REMOTE_NODE_DESTINATION_STATE_UNSPECIFIED;
+
+	sci_base_state_machine_construct(
+		&rnc->state_machine,
+		&rnc->parent,
+		scic_sds_remote_node_context_state_table,
+		SCIC_SDS_REMOTE_NODE_CONTEXT_INITIAL_STATE
+		);
+
+	sci_base_state_machine_start(&rnc->state_machine);
+}
