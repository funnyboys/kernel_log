commit 1125c70a92383be7fc9f4b4413a6b269288e1b24
Author: Geert Uytterhoeven <geert+renesas@glider.be>
Date:   Thu Oct 24 17:26:33 2019 +0200

    scsi: Fix various misspellings of "connect"
    
    Fix misspellings of "disonnect", "reconnect", "connection", "connected",
    and "disconnection".
    
    Link: https://lore.kernel.org/r/20191024152633.30404-1-geert+renesas@glider.be
    Signed-off-by: Geert Uytterhoeven <geert+renesas@glider.be>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/isci/remote_device.c b/drivers/scsi/isci/remote_device.c
index 49aa4e657c44..cd1e4b4d95bb 100644
--- a/drivers/scsi/isci/remote_device.c
+++ b/drivers/scsi/isci/remote_device.c
@@ -1504,7 +1504,7 @@ static enum sci_status isci_remote_device_construct(struct isci_port *iport,
  * This function builds the isci_remote_device when a libsas dev_found message
  *    is received.
  * @isci_host: This parameter specifies the isci host object.
- * @port: This parameter specifies the isci_port conected to this device.
+ * @port: This parameter specifies the isci_port connected to this device.
  *
  * pointer to new isci_remote_device.
  */

commit 924a3541eab0d28101baf0831e4315593f06ba4a
Author: John Garry <john.garry@huawei.com>
Date:   Mon Jun 10 20:41:41 2019 +0800

    scsi: libsas: aic94xx: hisi_sas: mvsas: pm8001: Use dev_is_expander()
    
    Many times in libsas, and in LLDDs which use libsas, the check for an
    expander device is re-implemented or open coded.
    
    Use dev_is_expander() instead. We rename this from
    sas_dev_type_is_expander() to not spill so many lines in referencing.
    
    Signed-off-by: John Garry <john.garry@huawei.com>
    Reviewed-by: Jason Yan <yanaijie@huawei.com>
    Reviewed-by: Jack Wang <jinpu.wang@cloud.ionos.com>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/isci/remote_device.c b/drivers/scsi/isci/remote_device.c
index 9d29edb9f590..49aa4e657c44 100644
--- a/drivers/scsi/isci/remote_device.c
+++ b/drivers/scsi/isci/remote_device.c
@@ -1087,7 +1087,7 @@ static void sci_remote_device_ready_state_enter(struct sci_base_state_machine *s
 
 	if (dev->dev_type == SAS_SATA_DEV || (dev->tproto & SAS_PROTOCOL_SATA)) {
 		sci_change_state(&idev->sm, SCI_STP_DEV_IDLE);
-	} else if (dev_is_expander(dev)) {
+	} else if (dev_is_expander(dev->dev_type)) {
 		sci_change_state(&idev->sm, SCI_SMP_DEV_IDLE);
 	} else
 		isci_remote_device_ready(ihost, idev);
@@ -1478,7 +1478,7 @@ static enum sci_status isci_remote_device_construct(struct isci_port *iport,
 	struct domain_device *dev = idev->domain_dev;
 	enum sci_status status;
 
-	if (dev->parent && dev_is_expander(dev->parent))
+	if (dev->parent && dev_is_expander(dev->parent->dev_type))
 		status = sci_remote_device_ea_construct(iport, idev);
 	else
 		status = sci_remote_device_da_construct(iport, idev);

commit 4f09ac9d96ceea2a0532e17b614b9b2835041c17
Author: Gustavo A. R. Silva <gustavo@embeddedor.com>
Date:   Tue Nov 27 22:30:01 2018 -0600

    scsi: isci: remote_device: Mark expected switch fall-throughs
    
    In preparation to enabling -Wimplicit-fallthrough, mark switch cases where
    we are expecting to fall through.
    
    Notice that, in this particular case, a dash is added as a token in order
    to separate the "fall through" annotations from the rest of the comment on
    the same line, which is what GCC is expecting to find.
    
    Signed-off-by: Gustavo A. R. Silva <gustavo@embeddedor.com>
    Acked-by: Artur Paszkiewicz <artur.paszkiewicz@intel.com>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/isci/remote_device.c b/drivers/scsi/isci/remote_device.c
index cc51f38b116d..9d29edb9f590 100644
--- a/drivers/scsi/isci/remote_device.c
+++ b/drivers/scsi/isci/remote_device.c
@@ -310,7 +310,7 @@ static void isci_remote_device_not_ready(struct isci_host *ihost,
 		/* Kill all outstanding requests for the device. */
 		sci_remote_device_terminate_requests(idev);
 
-		/* Fall through into the default case... */
+		/* Fall through - into the default case... */
 	default:
 		clear_bit(IDEV_IO_READY, &idev->flags);
 		break;
@@ -593,7 +593,7 @@ enum sci_status sci_remote_device_event_handler(struct isci_remote_device *idev,
 
 			break;
 		}
-	/* Else, fall through and treat as unhandled... */
+		/* fall through - and treat as unhandled... */
 	default:
 		dev_dbg(scirdev_to_dev(idev),
 			"%s: device: %p event code: %x: %s\n",

commit 4e857c58efeb99393cba5a5d0d8ec7117183137c
Author: Peter Zijlstra <peterz@infradead.org>
Date:   Mon Mar 17 18:06:10 2014 +0100

    arch: Mass conversion of smp_mb__*()
    
    Mostly scripted conversion of the smp_mb__* barriers.
    
    Signed-off-by: Peter Zijlstra <peterz@infradead.org>
    Acked-by: Paul E. McKenney <paulmck@linux.vnet.ibm.com>
    Link: http://lkml.kernel.org/n/tip-55dhyhocezdw1dg7u19hmh1u@git.kernel.org
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: linux-arch@vger.kernel.org
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/drivers/scsi/isci/remote_device.c b/drivers/scsi/isci/remote_device.c
index 96a26f454673..cc51f38b116d 100644
--- a/drivers/scsi/isci/remote_device.c
+++ b/drivers/scsi/isci/remote_device.c
@@ -1541,7 +1541,7 @@ void isci_remote_device_release(struct kref *kref)
 	clear_bit(IDEV_STOP_PENDING, &idev->flags);
 	clear_bit(IDEV_IO_READY, &idev->flags);
 	clear_bit(IDEV_GONE, &idev->flags);
-	smp_mb__before_clear_bit();
+	smp_mb__before_atomic();
 	clear_bit(IDEV_ALLOCATED, &idev->flags);
 	wake_up(&ihost->eventq);
 }

commit aa9f8328fc51460e15da129caf622b6560fa8c99
Author: James Bottomley <JBottomley@Parallels.com>
Date:   Tue May 7 14:44:06 2013 -0700

    [SCSI] sas: unify the pointlessly separated enums sas_dev_type and sas_device_type
    
    These enums have been separate since the dawn of SAS, mainly because the
    latter is a procotol only enum and the former includes additional state
    for libsas.  The dichotomy causes endless confusion about which one you
    should use where and leads to pointless warnings like this:
    
    drivers/scsi/mvsas/mv_sas.c: In function 'mvs_update_phyinfo':
    drivers/scsi/mvsas/mv_sas.c:1162:34: warning: comparison between 'enum sas_device_type' and 'enum sas_dev_type' [-Wenum-compare]
    
    Fix by eliminating one of them.  The one kept is effectively the sas.h
    one, but call it sas_device_type and make sure the enums are all
    properly namespaced with the SAS_ prefix.
    
    Signed-off-by: James Bottomley <JBottomley@Parallels.com>

diff --git a/drivers/scsi/isci/remote_device.c b/drivers/scsi/isci/remote_device.c
index c3aa6c5457b9..96a26f454673 100644
--- a/drivers/scsi/isci/remote_device.c
+++ b/drivers/scsi/isci/remote_device.c
@@ -1085,7 +1085,7 @@ static void sci_remote_device_ready_state_enter(struct sci_base_state_machine *s
 	struct isci_host *ihost = idev->owning_port->owning_controller;
 	struct domain_device *dev = idev->domain_dev;
 
-	if (dev->dev_type == SATA_DEV || (dev->tproto & SAS_PROTOCOL_SATA)) {
+	if (dev->dev_type == SAS_SATA_DEV || (dev->tproto & SAS_PROTOCOL_SATA)) {
 		sci_change_state(&idev->sm, SCI_STP_DEV_IDLE);
 	} else if (dev_is_expander(dev)) {
 		sci_change_state(&idev->sm, SCI_SMP_DEV_IDLE);
@@ -1098,7 +1098,7 @@ static void sci_remote_device_ready_state_exit(struct sci_base_state_machine *sm
 	struct isci_remote_device *idev = container_of(sm, typeof(*idev), sm);
 	struct domain_device *dev = idev->domain_dev;
 
-	if (dev->dev_type == SAS_END_DEV) {
+	if (dev->dev_type == SAS_END_DEVICE) {
 		struct isci_host *ihost = idev->owning_port->owning_controller;
 
 		isci_remote_device_not_ready(ihost, idev,

commit de2eb4d5c5c25e8fb75d1e19092f24b83cb7d8d5
Author: Jeff Skirvin <jeffrey.d.skirvin@intel.com>
Date:   Tue Mar 13 17:15:11 2012 -0700

    isci: End the RNC resumption wait when the RNC is destroyed.
    
    While the RNC is suspended for I/O cleanup, the remote device can be
    stopped and the RNC setup for destruction.  These changes accomodate that
    case in the abort path.
    
    Signed-off-by: Jeff Skirvin <jeffrey.d.skirvin@intel.com>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/drivers/scsi/isci/remote_device.c b/drivers/scsi/isci/remote_device.c
index a3a6487264ea..c3aa6c5457b9 100644
--- a/drivers/scsi/isci/remote_device.c
+++ b/drivers/scsi/isci/remote_device.c
@@ -1368,27 +1368,40 @@ static void isci_remote_device_resume_from_abort_complete(void *cbparam)
 	wake_up(&ihost->eventq);
 }
 
+static bool isci_remote_device_test_resume_done(
+	struct isci_host *ihost,
+	struct isci_remote_device *idev)
+{
+	unsigned long flags;
+	bool done;
+
+	spin_lock_irqsave(&ihost->scic_lock, flags);
+	done = !test_bit(IDEV_ABORT_PATH_RESUME_PENDING, &idev->flags)
+		|| test_bit(IDEV_STOP_PENDING, &idev->flags)
+		|| sci_remote_node_context_is_being_destroyed(&idev->rnc);
+	spin_unlock_irqrestore(&ihost->scic_lock, flags);
+
+	return done;
+}
 
 void isci_remote_device_wait_for_resume_from_abort(
 	struct isci_host *ihost,
 	struct isci_remote_device *idev)
 {
-	dev_dbg(scirdev_to_dev(idev), "%s: starting resume wait: %p\n",
+	dev_dbg(&ihost->pdev->dev, "%s: starting resume wait: %p\n",
 		 __func__, idev);
 
 	#define MAX_RESUME_MSECS 10000
 	if (!wait_event_timeout(ihost->eventq,
-			       (!test_bit(IDEV_ABORT_PATH_RESUME_PENDING,
-					  &idev->flags)
-				|| test_bit(IDEV_STOP_PENDING, &idev->flags)),
-			       msecs_to_jiffies(MAX_RESUME_MSECS))) {
+				isci_remote_device_test_resume_done(ihost, idev),
+				msecs_to_jiffies(MAX_RESUME_MSECS))) {
 
-		dev_warn(scirdev_to_dev(idev), "%s: #### Timeout waiting for "
+		dev_warn(&ihost->pdev->dev, "%s: #### Timeout waiting for "
 			 "resume: %p\n", __func__, idev);
 	}
 	clear_bit(IDEV_ABORT_PATH_RESUME_PENDING, &idev->flags);
 
-	dev_dbg(scirdev_to_dev(idev), "%s: resume wait done: %p\n",
+	dev_dbg(&ihost->pdev->dev, "%s: resume wait done: %p\n",
 		 __func__, idev);
 }
 
@@ -1414,7 +1427,7 @@ enum sci_status isci_remote_device_resume_from_abort(
 			idev, isci_remote_device_resume_from_abort_complete,
 			idev);
 	spin_unlock_irqrestore(&ihost->scic_lock, flags);
-	if (!destroyed)
+	if (!destroyed && (status == SCI_SUCCESS))
 		isci_remote_device_wait_for_resume_from_abort(ihost, idev);
 	else
 		clear_bit(IDEV_ABORT_PATH_RESUME_PENDING, &idev->flags);

commit 3ef768c6c0caa83b9fe66f19a18898ed0315ac36
Author: Jeff Skirvin <jeffrey.d.skirvin@intel.com>
Date:   Mon Mar 12 17:29:51 2012 -0700

    isci: Manage the IREQ_NO_AUTO_FREE_TAG under scic_lock.
    
    Since there is a possibilty of a timeout waiting for the RNC suspension,
    handle the exit case from the task termination under scic_lock, and leave
    the tag allocated if the termination timed-out.
    
    Signed-off-by: Jeff Skirvin <jeffrey.d.skirvin@intel.com>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/drivers/scsi/isci/remote_device.c b/drivers/scsi/isci/remote_device.c
index 48765aa84328..a3a6487264ea 100644
--- a/drivers/scsi/isci/remote_device.c
+++ b/drivers/scsi/isci/remote_device.c
@@ -243,8 +243,11 @@ enum sci_status isci_remote_device_terminate_requests(
 					 idev->rnc.destination_state,
 					 ireq, ireq->flags);
 			}
+			spin_lock_irqsave(&ihost->scic_lock, flags);
 			clear_bit(IREQ_NO_AUTO_FREE_TAG, &ireq->flags);
-			isci_free_tag(ihost, ireq->io_tag);
+			if (!test_bit(IREQ_ABORT_PATH_ACTIVE, &ireq->flags))
+				isci_free_tag(ihost, ireq->io_tag);
+			spin_unlock_irqrestore(&ihost->scic_lock, flags);
 		} else {
 			/* Terminate all TCs. */
 			sci_remote_device_terminate_requests(idev);

commit 87805162b6af20d2ad386a49aec13b753cca523a
Author: Jeff Skirvin <jeffrey.d.skirvin@intel.com>
Date:   Thu Mar 8 22:42:09 2012 -0800

    isci: Restore the ATAPI device RNC management code.
    
    The ATAPI specific and STP general RNC suspension code had been
    incorrectly removed from the remote device code.
    
    Signed-off-by: Jeff Skirvin <jeffrey.d.skirvin@intel.com>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/drivers/scsi/isci/remote_device.c b/drivers/scsi/isci/remote_device.c
index 68ab4fb9032e..48765aa84328 100644
--- a/drivers/scsi/isci/remote_device.c
+++ b/drivers/scsi/isci/remote_device.c
@@ -72,8 +72,8 @@ const char *dev_state_name(enum sci_remote_device_states state)
 }
 #undef C
 
-static enum sci_status sci_remote_device_suspend(struct isci_remote_device *idev,
-						 enum sci_remote_node_suspension_reasons reason)
+enum sci_status sci_remote_device_suspend(struct isci_remote_device *idev,
+					  enum sci_remote_node_suspension_reasons reason)
 {
 	return sci_remote_node_context_suspend(&idev->rnc, reason,
 					       SCI_SOFTWARE_SUSPEND_EXPECTED_EVENT);
@@ -565,6 +565,8 @@ enum sci_status sci_remote_device_event_handler(struct isci_remote_device *idev,
 						     u32 event_code)
 {
 	enum sci_status status;
+	struct sci_base_state_machine *sm = &idev->sm;
+	enum sci_remote_device_states state = sm->current_state_id;
 
 	switch (scu_get_event_type(event_code)) {
 	case SCU_EVENT_TYPE_RNC_OPS_MISC:
@@ -603,6 +605,30 @@ enum sci_status sci_remote_device_event_handler(struct isci_remote_device *idev,
 	if (status != SCI_SUCCESS)
 		return status;
 
+	/* Decode device-specific states that may require an RNC resume during
+	 * normal operation.  When the abort path is active, these resumes are
+	 * managed when the abort path exits.
+	 */
+	if (state == SCI_STP_DEV_ATAPI_ERROR) {
+		/* For ATAPI error state resume the RNC right away. */
+		if (scu_get_event_type(event_code) == SCU_EVENT_TYPE_RNC_SUSPEND_TX ||
+		    scu_get_event_type(event_code) == SCU_EVENT_TYPE_RNC_SUSPEND_TX_RX) {
+			return sci_remote_node_context_resume(&idev->rnc,
+							      atapi_remote_device_resume_done,
+							      idev);
+		}
+	}
+
+	if (state == SCI_STP_DEV_IDLE) {
+
+		/* We pick up suspension events to handle specifically to this
+		 * state. We resume the RNC right away.
+		 */
+		if (scu_get_event_type(event_code) == SCU_EVENT_TYPE_RNC_SUSPEND_TX ||
+		    scu_get_event_type(event_code) == SCU_EVENT_TYPE_RNC_SUSPEND_TX_RX)
+			status = sci_remote_node_context_resume(&idev->rnc, NULL, NULL);
+	}
+
 	return status;
 }
 
@@ -1137,21 +1163,6 @@ static void sci_stp_remote_device_ready_ncq_error_substate_enter(struct sci_base
 					     idev->not_ready_reason);
 }
 
-static void sci_stp_remote_device_atapi_error_substate_enter(
-	struct sci_base_state_machine *sm)
-{
-	struct isci_remote_device *idev = container_of(sm, typeof(*idev), sm);
-
-	/* This state is entered when an I/O is decoded with an error
-	 * condition.  By this point the RNC expected suspension state is set.
-	 * The error conditions suspend the device, so unsuspend here if
-	 * possible.
-	 */
-	sci_remote_node_context_resume(&idev->rnc,
-				       atapi_remote_device_resume_done,
-				       idev);
-}
-
 static void sci_smp_remote_device_ready_idle_substate_enter(struct sci_base_state_machine *sm)
 {
 	struct isci_remote_device *idev = container_of(sm, typeof(*idev), sm);
@@ -1202,9 +1213,7 @@ static const struct sci_base_state sci_remote_device_state_table[] = {
 	[SCI_STP_DEV_NCQ_ERROR] = {
 		.enter_state = sci_stp_remote_device_ready_ncq_error_substate_enter,
 	},
-	[SCI_STP_DEV_ATAPI_ERROR] = {
-		.enter_state = sci_stp_remote_device_atapi_error_substate_enter,
-	},
+	[SCI_STP_DEV_ATAPI_ERROR] = { },
 	[SCI_STP_DEV_AWAIT_RESET] = { },
 	[SCI_SMP_DEV_IDLE] = {
 		.enter_state = sci_smp_remote_device_ready_idle_substate_enter,

commit 1f05388933cb6e57ed9e51768c194ff145002f3b
Author: Jeff Skirvin <jeffrey.d.skirvin@intel.com>
Date:   Thu Mar 8 22:42:08 2012 -0800

    isci: Don't wait for an RNC suspend if it's being destroyed.
    
    Make sure that the wait for suspend can handle the RNC destruction case.
    
    Signed-off-by: Jeff Skirvin <jeffrey.d.skirvin@intel.com>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/drivers/scsi/isci/remote_device.c b/drivers/scsi/isci/remote_device.c
index be9f0e0be4ff..68ab4fb9032e 100644
--- a/drivers/scsi/isci/remote_device.c
+++ b/drivers/scsi/isci/remote_device.c
@@ -142,7 +142,12 @@ static bool isci_compare_suspendcount(
 	u32 localcount)
 {
 	smp_rmb();
-	return localcount != idev->rnc.suspend_count;
+
+	/* Check for a change in the suspend count, or the RNC
+	 * being destroyed.
+	 */
+	return (localcount != idev->rnc.suspend_count)
+	    || sci_remote_node_context_is_being_destroyed(&idev->rnc);
 }
 
 static bool isci_check_reqterm(
@@ -1380,7 +1385,8 @@ enum sci_status isci_remote_device_resume_from_abort(
 	struct isci_remote_device *idev)
 {
 	unsigned long flags;
-	enum sci_status status;
+	enum sci_status status = SCI_SUCCESS;
+	int destroyed;
 
 	spin_lock_irqsave(&ihost->scic_lock, flags);
 	/* Preserve any current resume callbacks, for instance from other
@@ -1390,11 +1396,17 @@ enum sci_status isci_remote_device_resume_from_abort(
 	idev->abort_resume_cbparam = idev->rnc.user_cookie;
 	set_bit(IDEV_ABORT_PATH_RESUME_PENDING, &idev->flags);
 	clear_bit(IDEV_ABORT_PATH_ACTIVE, &idev->flags);
-	status = sci_remote_device_resume(
+	destroyed = sci_remote_node_context_is_being_destroyed(&idev->rnc);
+	if (!destroyed)
+		status = sci_remote_device_resume(
 			idev, isci_remote_device_resume_from_abort_complete,
 			idev);
 	spin_unlock_irqrestore(&ihost->scic_lock, flags);
-	isci_remote_device_wait_for_resume_from_abort(ihost, idev);
+	if (!destroyed)
+		isci_remote_device_wait_for_resume_from_abort(ihost, idev);
+	else
+		clear_bit(IDEV_ABORT_PATH_RESUME_PENDING, &idev->flags);
+
 	return status;
 }
 

commit 8c731888bf1be8d15d587ab1b4da80553302e653
Author: Jeff Skirvin <jeffrey.d.skirvin@intel.com>
Date:   Thu Mar 8 22:42:06 2012 -0800

    isci: Added timeouts to RNC suspensions in the abort path.
    
    This change adds timeouts to the RNC suspension wait.  It makes the
    suspend and resume timeouts the same.
    
    The previous resume timeout of 5 ms was too short, and timeouts were
    seen in resumptions of devices in the abort task/LUN reset path - which
    would receive an RNC resumed message within a tenth of a second later.
    
    Signed-off-by: Jeff Skirvin <jeffrey.d.skirvin@intel.com>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/drivers/scsi/isci/remote_device.c b/drivers/scsi/isci/remote_device.c
index 37e9bdead6f6..be9f0e0be4ff 100644
--- a/drivers/scsi/isci/remote_device.c
+++ b/drivers/scsi/isci/remote_device.c
@@ -207,23 +207,67 @@ enum sci_status isci_remote_device_terminate_requests(
 				"about to wait\n",
 			__func__, idev, ireq, idev->started_request_count,
 			rnc_suspend_count, idev->rnc.suspend_count);
+
+		#define MAX_SUSPEND_MSECS 10000
 		if (ireq) {
 			/* Terminate a specific TC. */
 			set_bit(IREQ_NO_AUTO_FREE_TAG, &ireq->flags);
 			sci_remote_device_terminate_req(ihost, idev, 0, ireq);
 			spin_unlock_irqrestore(&ihost->scic_lock, flags);
-			wait_event(ihost->eventq,
-				   isci_check_reqterm(ihost, idev, ireq,
-						      rnc_suspend_count));
+			if (!wait_event_timeout(ihost->eventq,
+						isci_check_reqterm(ihost, idev, ireq,
+								   rnc_suspend_count),
+						msecs_to_jiffies(MAX_SUSPEND_MSECS))) {
+
+				dev_warn(&ihost->pdev->dev, "%s host%d timeout single\n",
+					 __func__, ihost->id);
+				dev_dbg(&ihost->pdev->dev,
+					 "%s: ******* Timeout waiting for "
+					 "suspend; idev=%p, current state %s; "
+					 "started_request_count=%d, flags=%lx\n\t"
+					 "rnc_suspend_count=%d, rnc.suspend_count=%d "
+					 "RNC: current state %s, current "
+					 "suspend_type %x dest state %d;\n"
+					 "ireq=%p, ireq->flags = %lx\n",
+					 __func__, idev,
+					 dev_state_name(idev->sm.current_state_id),
+					 idev->started_request_count, idev->flags,
+					 rnc_suspend_count, idev->rnc.suspend_count,
+					 rnc_state_name(idev->rnc.sm.current_state_id),
+					 idev->rnc.suspend_type,
+					 idev->rnc.destination_state,
+					 ireq, ireq->flags);
+			}
 			clear_bit(IREQ_NO_AUTO_FREE_TAG, &ireq->flags);
 			isci_free_tag(ihost, ireq->io_tag);
 		} else {
 			/* Terminate all TCs. */
 			sci_remote_device_terminate_requests(idev);
 			spin_unlock_irqrestore(&ihost->scic_lock, flags);
-			wait_event(ihost->eventq,
-				   isci_check_devempty(ihost, idev,
-						       rnc_suspend_count));
+			if (!wait_event_timeout(ihost->eventq,
+						isci_check_devempty(ihost, idev,
+								    rnc_suspend_count),
+						msecs_to_jiffies(MAX_SUSPEND_MSECS))) {
+
+				dev_warn(&ihost->pdev->dev, "%s host%d timeout all\n",
+					 __func__, ihost->id);
+				dev_dbg(&ihost->pdev->dev,
+					"%s: ******* Timeout waiting for "
+					"suspend; idev=%p, current state %s; "
+					"started_request_count=%d, flags=%lx\n\t"
+					"rnc_suspend_count=%d, "
+					"RNC: current state %s, "
+					"rnc.suspend_count=%d, current "
+					"suspend_type %x dest state %d\n",
+					__func__, idev,
+					dev_state_name(idev->sm.current_state_id),
+					idev->started_request_count, idev->flags,
+					rnc_suspend_count,
+					rnc_state_name(idev->rnc.sm.current_state_id),
+					idev->rnc.suspend_count,
+					idev->rnc.suspend_type,
+					idev->rnc.destination_state);
+			}
 		}
 		dev_dbg(&ihost->pdev->dev, "%s: idev=%p, wait done\n",
 			__func__, idev);
@@ -1315,7 +1359,7 @@ void isci_remote_device_wait_for_resume_from_abort(
 	dev_dbg(scirdev_to_dev(idev), "%s: starting resume wait: %p\n",
 		 __func__, idev);
 
-	#define MAX_RESUME_MSECS 5
+	#define MAX_RESUME_MSECS 10000
 	if (!wait_event_timeout(ihost->eventq,
 			       (!test_bit(IDEV_ABORT_PATH_RESUME_PENDING,
 					  &idev->flags)

commit 0cce165e2814bc8c08ab229db5e17013971dced7
Author: Jeff Skirvin <jeffrey.d.skirvin@intel.com>
Date:   Thu Mar 8 22:42:04 2012 -0800

    isci: Wait for RNC resumption before leaving the abort path.
    
    In the case of TMF execution, or device resets, wait for the RNC to fully
    resume before returning to the caller.  This ensures that the remote
    device will not fail I/O requests while waiting for the RNC resumption to
    complete.
    
    Signed-off-by: Jeff Skirvin <jeffrey.d.skirvin@intel.com>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/drivers/scsi/isci/remote_device.c b/drivers/scsi/isci/remote_device.c
index adeda64e512a..37e9bdead6f6 100644
--- a/drivers/scsi/isci/remote_device.c
+++ b/drivers/scsi/isci/remote_device.c
@@ -1289,6 +1289,48 @@ enum sci_status sci_remote_device_resume(
 	return status;
 }
 
+static void isci_remote_device_resume_from_abort_complete(void *cbparam)
+{
+	struct isci_remote_device *idev = cbparam;
+	struct isci_host *ihost = idev->owning_port->owning_controller;
+	scics_sds_remote_node_context_callback abort_resume_cb =
+		idev->abort_resume_cb;
+
+	dev_dbg(scirdev_to_dev(idev), "%s: passing-along resume: %p\n",
+		__func__, abort_resume_cb);
+
+	if (abort_resume_cb != NULL) {
+		idev->abort_resume_cb = NULL;
+		abort_resume_cb(idev->abort_resume_cbparam);
+	}
+	clear_bit(IDEV_ABORT_PATH_RESUME_PENDING, &idev->flags);
+	wake_up(&ihost->eventq);
+}
+
+
+void isci_remote_device_wait_for_resume_from_abort(
+	struct isci_host *ihost,
+	struct isci_remote_device *idev)
+{
+	dev_dbg(scirdev_to_dev(idev), "%s: starting resume wait: %p\n",
+		 __func__, idev);
+
+	#define MAX_RESUME_MSECS 5
+	if (!wait_event_timeout(ihost->eventq,
+			       (!test_bit(IDEV_ABORT_PATH_RESUME_PENDING,
+					  &idev->flags)
+				|| test_bit(IDEV_STOP_PENDING, &idev->flags)),
+			       msecs_to_jiffies(MAX_RESUME_MSECS))) {
+
+		dev_warn(scirdev_to_dev(idev), "%s: #### Timeout waiting for "
+			 "resume: %p\n", __func__, idev);
+	}
+	clear_bit(IDEV_ABORT_PATH_RESUME_PENDING, &idev->flags);
+
+	dev_dbg(scirdev_to_dev(idev), "%s: resume wait done: %p\n",
+		 __func__, idev);
+}
+
 enum sci_status isci_remote_device_resume_from_abort(
 	struct isci_host *ihost,
 	struct isci_remote_device *idev)
@@ -1300,12 +1342,18 @@ enum sci_status isci_remote_device_resume_from_abort(
 	/* Preserve any current resume callbacks, for instance from other
 	 * resumptions.
 	 */
+	idev->abort_resume_cb = idev->rnc.user_callback;
+	idev->abort_resume_cbparam = idev->rnc.user_cookie;
+	set_bit(IDEV_ABORT_PATH_RESUME_PENDING, &idev->flags);
 	clear_bit(IDEV_ABORT_PATH_ACTIVE, &idev->flags);
-	status = sci_remote_device_resume(idev, idev->rnc.user_callback,
-					  idev->rnc.user_cookie);
+	status = sci_remote_device_resume(
+			idev, isci_remote_device_resume_from_abort_complete,
+			idev);
 	spin_unlock_irqrestore(&ihost->scic_lock, flags);
+	isci_remote_device_wait_for_resume_from_abort(ihost, idev);
 	return status;
 }
+
 /**
  * sci_remote_device_start() - This method will start the supplied remote
  *    device.  This method enables normal IO requests to flow through to the

commit 621120ca56850249554996c94efe75f8200a2cc0
Author: Jeff Skirvin <jeffrey.d.skirvin@intel.com>
Date:   Thu Mar 8 22:42:03 2012 -0800

    isci: Manage tag releases differently when aborting tasks.
    
    When an individual request is being terminated, the request's tag
    is managed in the terminate function.
    
    Signed-off-by: Jeff Skirvin <jeffrey.d.skirvin@intel.com>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/drivers/scsi/isci/remote_device.c b/drivers/scsi/isci/remote_device.c
index 21a9800a9bec..adeda64e512a 100644
--- a/drivers/scsi/isci/remote_device.c
+++ b/drivers/scsi/isci/remote_device.c
@@ -104,15 +104,15 @@ static enum sci_status sci_remote_device_terminate_req(
 	int check_abort,
 	struct isci_request *ireq)
 {
-	dev_dbg(&ihost->pdev->dev,
-		"%s: idev=%p; flags=%lx; req=%p; req target=%p\n",
-		__func__, idev, idev->flags, ireq, ireq->target_device);
-
 	if (!test_bit(IREQ_ACTIVE, &ireq->flags) ||
 	    (ireq->target_device != idev) ||
 	    (check_abort && !test_bit(IREQ_PENDING_ABORT, &ireq->flags)))
 		return SCI_SUCCESS;
 
+	dev_dbg(&ihost->pdev->dev,
+		"%s: idev=%p; flags=%lx; req=%p; req target=%p\n",
+		__func__, idev, idev->flags, ireq, ireq->target_device);
+
 	set_bit(IREQ_ABORT_PATH_ACTIVE, &ireq->flags);
 
 	return sci_controller_terminate_request(ihost, idev, ireq);
@@ -209,11 +209,14 @@ enum sci_status isci_remote_device_terminate_requests(
 			rnc_suspend_count, idev->rnc.suspend_count);
 		if (ireq) {
 			/* Terminate a specific TC. */
+			set_bit(IREQ_NO_AUTO_FREE_TAG, &ireq->flags);
 			sci_remote_device_terminate_req(ihost, idev, 0, ireq);
 			spin_unlock_irqrestore(&ihost->scic_lock, flags);
 			wait_event(ihost->eventq,
 				   isci_check_reqterm(ihost, idev, ireq,
 						      rnc_suspend_count));
+			clear_bit(IREQ_NO_AUTO_FREE_TAG, &ireq->flags);
+			isci_free_tag(ihost, ireq->io_tag);
 		} else {
 			/* Terminate all TCs. */
 			sci_remote_device_terminate_requests(idev);

commit 033d19d298b4245da2d3d6c795ea97e419f9ac61
Author: Jeff Skirvin <jeffrey.d.skirvin@intel.com>
Date:   Thu Mar 8 22:42:03 2012 -0800

    isci: Callbacks to libsas occur under scic_lock and are synchronized.
    
    This patch changes the callback mechanism to libsas to only occur while
    the scic_lock is held; the abort path cleanup of I/Os also checks to make
    sure IREQ_ABORT_PATH_ACTIVE is clear before proceding.
    
    Signed-off-by: Jeff Skirvin <jeffrey.d.skirvin@intel.com>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/drivers/scsi/isci/remote_device.c b/drivers/scsi/isci/remote_device.c
index d1c2a2294a32..21a9800a9bec 100644
--- a/drivers/scsi/isci/remote_device.c
+++ b/drivers/scsi/isci/remote_device.c
@@ -145,6 +145,39 @@ static bool isci_compare_suspendcount(
 	return localcount != idev->rnc.suspend_count;
 }
 
+static bool isci_check_reqterm(
+	struct isci_host *ihost,
+	struct isci_remote_device *idev,
+	struct isci_request *ireq,
+	u32 localcount)
+{
+	unsigned long flags;
+	bool res;
+
+	spin_lock_irqsave(&ihost->scic_lock, flags);
+	res = isci_compare_suspendcount(idev, localcount)
+		&& !test_bit(IREQ_ABORT_PATH_ACTIVE, &ireq->flags);
+	spin_unlock_irqrestore(&ihost->scic_lock, flags);
+
+	return res;
+}
+
+static bool isci_check_devempty(
+	struct isci_host *ihost,
+	struct isci_remote_device *idev,
+	u32 localcount)
+{
+	unsigned long flags;
+	bool res;
+
+	spin_lock_irqsave(&ihost->scic_lock, flags);
+	res = isci_compare_suspendcount(idev, localcount)
+		&& idev->started_request_count == 0;
+	spin_unlock_irqrestore(&ihost->scic_lock, flags);
+
+	return res;
+}
+
 enum sci_status isci_remote_device_terminate_requests(
 	struct isci_host *ihost,
 	struct isci_remote_device *idev,
@@ -179,17 +212,15 @@ enum sci_status isci_remote_device_terminate_requests(
 			sci_remote_device_terminate_req(ihost, idev, 0, ireq);
 			spin_unlock_irqrestore(&ihost->scic_lock, flags);
 			wait_event(ihost->eventq,
-				   (isci_compare_suspendcount(idev,
-							      rnc_suspend_count)
-				    && !test_bit(IREQ_ACTIVE, &ireq->flags)));
+				   isci_check_reqterm(ihost, idev, ireq,
+						      rnc_suspend_count));
 		} else {
 			/* Terminate all TCs. */
 			sci_remote_device_terminate_requests(idev);
 			spin_unlock_irqrestore(&ihost->scic_lock, flags);
 			wait_event(ihost->eventq,
-				   (isci_compare_suspendcount(idev,
-							      rnc_suspend_count)
-				    && idev->started_request_count == 0));
+				   isci_check_devempty(ihost, idev,
+						       rnc_suspend_count));
 		}
 		dev_dbg(&ihost->pdev->dev, "%s: idev=%p, wait done\n",
 			__func__, idev);

commit 0c3ce38f1bc8b6a6d8df0959e3c0dece31f9350c
Author: Jeff Skirvin <jeffrey.d.skirvin@intel.com>
Date:   Thu Mar 8 22:42:02 2012 -0800

    isci: When in the abort path, defeat other resume calls until done.
    
    Completion of I/Os during the one of the abort path interface calls
    from libsas can drive remote device state changes and the resumption
    of the device RNC.  This is a problem when the abort path is
    attempting to cleanup outstanding I/O at the same time - the resumption
    can prevent the termination from occuring correctly.
    
    Signed-off-by: Jeff Skirvin <jeffrey.d.skirvin@intel.com>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/drivers/scsi/isci/remote_device.c b/drivers/scsi/isci/remote_device.c
index acc94a454a1f..d1c2a2294a32 100644
--- a/drivers/scsi/isci/remote_device.c
+++ b/drivers/scsi/isci/remote_device.c
@@ -1266,6 +1266,7 @@ enum sci_status isci_remote_device_resume_from_abort(
 	/* Preserve any current resume callbacks, for instance from other
 	 * resumptions.
 	 */
+	clear_bit(IDEV_ABORT_PATH_ACTIVE, &idev->flags);
 	status = sci_remote_device_resume(idev, idev->rnc.user_callback,
 					  idev->rnc.user_cookie);
 	spin_unlock_irqrestore(&ihost->scic_lock, flags);
@@ -1501,6 +1502,7 @@ enum sci_status isci_remote_device_suspend_terminate(
 
 	/* Put the device into suspension. */
 	spin_lock_irqsave(&ihost->scic_lock, flags);
+	set_bit(IDEV_ABORT_PATH_ACTIVE, &idev->flags);
 	sci_remote_device_suspend(idev, SCI_SW_SUSPEND_LINKHANG_DETECT);
 	spin_unlock_irqrestore(&ihost->scic_lock, flags);
 

commit 31a38ef0a5ad12dbe262ca55d0a905657be55a8d
Author: Jeff Skirvin <jeffrey.d.skirvin@intel.com>
Date:   Thu Mar 8 22:42:01 2012 -0800

    isci: Implement waiting for suspend in the abort path.
    
    In order to prevent a device from receiving an I/O request while still
    in an RNC suspending or resuming state (and therefore failing that
    I/O back to libsas with a reset required status) wait for the RNC state
    change before proceding in the abort path.
    
    Signed-off-by: Jeff Skirvin <jeffrey.d.skirvin@intel.com>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/drivers/scsi/isci/remote_device.c b/drivers/scsi/isci/remote_device.c
index 86aca11120f3..acc94a454a1f 100644
--- a/drivers/scsi/isci/remote_device.c
+++ b/drivers/scsi/isci/remote_device.c
@@ -137,6 +137,14 @@ static enum sci_status sci_remote_device_terminate_reqs_checkabort(
 	return status;
 }
 
+static bool isci_compare_suspendcount(
+	struct isci_remote_device *idev,
+	u32 localcount)
+{
+	smp_rmb();
+	return localcount != idev->rnc.suspend_count;
+}
+
 enum sci_status isci_remote_device_terminate_requests(
 	struct isci_host *ihost,
 	struct isci_remote_device *idev,
@@ -144,31 +152,44 @@ enum sci_status isci_remote_device_terminate_requests(
 {
 	enum sci_status status = SCI_SUCCESS;
 	unsigned long flags;
+	u32 rnc_suspend_count;
 
 	spin_lock_irqsave(&ihost->scic_lock, flags);
+
 	if (isci_get_device(idev) == NULL) {
 		dev_dbg(&ihost->pdev->dev, "%s: failed isci_get_device(idev=%p)\n",
 			__func__, idev);
 		spin_unlock_irqrestore(&ihost->scic_lock, flags);
 		status = SCI_FAILURE;
 	} else {
+		/* If already suspended, don't wait for another suspension. */
+		smp_rmb();
+		rnc_suspend_count
+			= sci_remote_node_context_is_suspended(&idev->rnc)
+				? 0 : idev->rnc.suspend_count;
+
 		dev_dbg(&ihost->pdev->dev,
 			"%s: idev=%p, ireq=%p; started_request_count=%d, "
+				"rnc_suspend_count=%d, rnc.suspend_count=%d"
 				"about to wait\n",
-			__func__, idev, ireq, idev->started_request_count);
+			__func__, idev, ireq, idev->started_request_count,
+			rnc_suspend_count, idev->rnc.suspend_count);
 		if (ireq) {
 			/* Terminate a specific TC. */
 			sci_remote_device_terminate_req(ihost, idev, 0, ireq);
 			spin_unlock_irqrestore(&ihost->scic_lock, flags);
-			wait_event(ihost->eventq, !test_bit(IREQ_ACTIVE,
-							    &ireq->flags));
-
+			wait_event(ihost->eventq,
+				   (isci_compare_suspendcount(idev,
+							      rnc_suspend_count)
+				    && !test_bit(IREQ_ACTIVE, &ireq->flags)));
 		} else {
 			/* Terminate all TCs. */
 			sci_remote_device_terminate_requests(idev);
 			spin_unlock_irqrestore(&ihost->scic_lock, flags);
 			wait_event(ihost->eventq,
-				   idev->started_request_count == 0);
+				   (isci_compare_suspendcount(idev,
+							      rnc_suspend_count)
+				    && idev->started_request_count == 0));
 		}
 		dev_dbg(&ihost->pdev->dev, "%s: idev=%p, wait done\n",
 			__func__, idev);
@@ -1234,19 +1255,20 @@ enum sci_status sci_remote_device_resume(
 	return status;
 }
 
-enum sci_status isci_remote_device_resume(
+enum sci_status isci_remote_device_resume_from_abort(
 	struct isci_host *ihost,
-	struct isci_remote_device *idev,
-	scics_sds_remote_node_context_callback cb_fn,
-	void *cb_p)
+	struct isci_remote_device *idev)
 {
 	unsigned long flags;
 	enum sci_status status;
 
 	spin_lock_irqsave(&ihost->scic_lock, flags);
-	status = sci_remote_device_resume(idev, cb_fn, cb_p);
+	/* Preserve any current resume callbacks, for instance from other
+	 * resumptions.
+	 */
+	status = sci_remote_device_resume(idev, idev->rnc.user_callback,
+					  idev->rnc.user_cookie);
 	spin_unlock_irqrestore(&ihost->scic_lock, flags);
-
 	return status;
 }
 /**

commit 9608b6408e637abeec101abb6aebd3343f0ebac4
Author: Jeff Skirvin <jeffrey.d.skirvin@intel.com>
Date:   Thu Mar 8 22:42:00 2012 -0800

    isci: Manage the LLHANG timer enable/disable per-device.
    
    The LLHANG timer should be enabled once per device.  This patch corrects
    both the timer enable and the timer disable for the remote device.
    
    Signed-off-by: Jeff Skirvin <jeffrey.d.skirvin@intel.com>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/drivers/scsi/isci/remote_device.c b/drivers/scsi/isci/remote_device.c
index 1a85e9edef6a..86aca11120f3 100644
--- a/drivers/scsi/isci/remote_device.c
+++ b/drivers/scsi/isci/remote_device.c
@@ -1520,3 +1520,20 @@ enum sci_status isci_remote_device_reset_complete(
 	return status;
 }
 
+void isci_dev_set_hang_detection_timeout(
+	struct isci_remote_device *idev,
+	u32 timeout)
+{
+	if (dev_is_sata(idev->domain_dev)) {
+		if (timeout) {
+			if (test_and_set_bit(IDEV_RNC_LLHANG_ENABLED,
+					     &idev->flags))
+				return;  /* Already enabled. */
+		} else if (!test_and_clear_bit(IDEV_RNC_LLHANG_ENABLED,
+					       &idev->flags))
+			return;  /* Not enabled. */
+
+		sci_port_set_hang_detection_timeout(idev->owning_port,
+						    timeout);
+	}
+}

commit 447bfbcee070a0b43dd6abc743063d7a02fe65ca
Author: Jeff Skirvin <jeffrey.d.skirvin@intel.com>
Date:   Thu Mar 8 22:41:59 2012 -0800

    isci: Save the suspension hint for upcoming suspensions.
    
    In the case of a suspend call while in SCI_RNC_POSTING or INVALIDATING
    states, the LLHANG detect needed to be saved so the upcoming suspension
    would enable it correctly.  The unused suspend callback parameters were
    removed.
    
    Signed-off-by: Jeff Skirvin <jeffrey.d.skirvin@intel.com>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/drivers/scsi/isci/remote_device.c b/drivers/scsi/isci/remote_device.c
index cc8ab69a2022..1a85e9edef6a 100644
--- a/drivers/scsi/isci/remote_device.c
+++ b/drivers/scsi/isci/remote_device.c
@@ -75,10 +75,8 @@ const char *dev_state_name(enum sci_remote_device_states state)
 static enum sci_status sci_remote_device_suspend(struct isci_remote_device *idev,
 						 enum sci_remote_node_suspension_reasons reason)
 {
-	return sci_remote_node_context_suspend(&idev->rnc,
-					       reason,
-					       SCI_SOFTWARE_SUSPEND_EXPECTED_EVENT,
-					       NULL, NULL);
+	return sci_remote_node_context_suspend(&idev->rnc, reason,
+					       SCI_SOFTWARE_SUSPEND_EXPECTED_EVENT);
 }
 
 /**

commit c94fc1ad25de885e1c59f714f19bc726e7a21caf
Author: Jeff Skirvin <jeffrey.d.skirvin@intel.com>
Date:   Thu Mar 8 22:41:58 2012 -0800

    isci: Distinguish between remote device suspension cases
    
    For NCQ error conditions among others, there is no need to enable
    the link layer hang detect timer.
    
    Signed-off-by: Jeff Skirvin <jeffrey.d.skirvin@intel.com>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/drivers/scsi/isci/remote_device.c b/drivers/scsi/isci/remote_device.c
index b14eff3c76d0..cc8ab69a2022 100644
--- a/drivers/scsi/isci/remote_device.c
+++ b/drivers/scsi/isci/remote_device.c
@@ -72,10 +72,11 @@ const char *dev_state_name(enum sci_remote_device_states state)
 }
 #undef C
 
-static enum sci_status sci_remote_device_suspend(struct isci_remote_device *idev)
+static enum sci_status sci_remote_device_suspend(struct isci_remote_device *idev,
+						 enum sci_remote_node_suspension_reasons reason)
 {
 	return sci_remote_node_context_suspend(&idev->rnc,
-					       SCI_SOFTWARE_SUSPENSION,
+					       reason,
 					       SCI_SOFTWARE_SUSPEND_EXPECTED_EVENT,
 					       NULL, NULL);
 }
@@ -199,7 +200,7 @@ static void isci_remote_device_not_ready(struct isci_host *ihost,
 		set_bit(IDEV_IO_NCQERROR, &idev->flags);
 
 		/* Suspend the remote device so the I/O can be terminated. */
-		sci_remote_device_suspend(idev);
+		sci_remote_device_suspend(idev, SCI_SW_SUSPEND_NORMAL);
 
 		/* Kill all outstanding requests for the device. */
 		sci_remote_device_terminate_requests(idev);
@@ -268,7 +269,8 @@ enum sci_status sci_remote_device_stop(struct isci_remote_device *idev,
 							 rnc_destruct_done,
 							 idev);
 		else {
-			sci_remote_device_suspend(idev);
+			sci_remote_device_suspend(
+				idev, SCI_SW_SUSPEND_LINKHANG_DETECT);
 			sci_remote_device_terminate_requests(idev);
 		}
 		return SCI_SUCCESS;
@@ -473,11 +475,7 @@ enum sci_status sci_remote_device_event_handler(struct isci_remote_device *idev,
 			status = SCI_SUCCESS;
 
 			/* Suspend the associated RNC */
-			sci_remote_node_context_suspend(
-				&idev->rnc,
-				SCI_SOFTWARE_SUSPENSION,
-				SCI_SOFTWARE_SUSPEND_EXPECTED_EVENT,
-				NULL, NULL);
+			sci_remote_device_suspend(idev, SCI_SW_SUSPEND_NORMAL);
 
 			dev_dbg(scirdev_to_dev(idev),
 				"%s: device: %p event code: %x: %s\n",
@@ -789,9 +787,8 @@ enum sci_status sci_remote_device_start_task(struct isci_host *ihost,
 		 * the correct action when the remote node context is suspended
 		 * and later resumed.
 		 */
-		sci_remote_node_context_suspend(
-			&idev->rnc, SCI_SOFTWARE_SUSPENSION,
-			SCI_SOFTWARE_SUSPEND_EXPECTED_EVENT, NULL, NULL);
+		sci_remote_device_suspend(idev,
+					  SCI_SW_SUSPEND_LINKHANG_DETECT);
 
 		status = sci_remote_node_context_start_task(&idev->rnc, ireq,
 				sci_remote_device_continue_request, idev);
@@ -986,9 +983,7 @@ static void sci_remote_device_resetting_state_enter(struct sci_base_state_machin
 	dev_dbg(&ihost->pdev->dev,
 		"%s: isci_device = %p\n", __func__, idev);
 
-	sci_remote_node_context_suspend(
-		&idev->rnc, SCI_SOFTWARE_SUSPENSION,
-		SCI_SOFTWARE_SUSPEND_EXPECTED_EVENT, NULL, NULL);
+	sci_remote_device_suspend(idev, SCI_SW_SUSPEND_LINKHANG_DETECT);
 }
 
 static void sci_remote_device_resetting_state_exit(struct sci_base_state_machine *sm)
@@ -1486,7 +1481,7 @@ enum sci_status isci_remote_device_suspend_terminate(
 
 	/* Put the device into suspension. */
 	spin_lock_irqsave(&ihost->scic_lock, flags);
-	sci_remote_device_suspend(idev);
+	sci_remote_device_suspend(idev, SCI_SW_SUSPEND_LINKHANG_DETECT);
 	spin_unlock_irqrestore(&ihost->scic_lock, flags);
 
 	/* Terminate and wait for the completions. */

commit d6b2a0e4a066ea51322e16e66b25028cb0b4ca7e
Author: Jeff Skirvin <jeffrey.d.skirvin@intel.com>
Date:   Thu Mar 8 22:41:57 2012 -0800

    isci: Remove isci_device reqs_in_process and dev_node from isci_device.
    
    Signed-off-by: Jeff Skirvin <jeffrey.d.skirvin@intel.com>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/drivers/scsi/isci/remote_device.c b/drivers/scsi/isci/remote_device.c
index b26ab05107dd..b14eff3c76d0 100644
--- a/drivers/scsi/isci/remote_device.c
+++ b/drivers/scsi/isci/remote_device.c
@@ -919,7 +919,7 @@ static void isci_remote_device_deconstruct(struct isci_host *ihost, struct isci_
 	 * here should go through isci_remote_device_nuke_requests.
 	 * If we hit this condition, we will need a way to complete
 	 * io requests in process */
-	BUG_ON(!list_empty(&idev->reqs_in_process));
+	BUG_ON(idev->started_request_count > 0);
 
 	sci_remote_device_destruct(idev);
 	list_del_init(&idev->node);
@@ -1345,10 +1345,6 @@ isci_remote_device_alloc(struct isci_host *ihost, struct isci_port *iport)
 		dev_warn(&ihost->pdev->dev, "%s: failed\n", __func__);
 		return NULL;
 	}
-
-	if (WARN_ONCE(!list_empty(&idev->reqs_in_process), "found requests in process\n"))
-		return NULL;
-
 	if (WARN_ONCE(!list_empty(&idev->node), "found non-idle remote device\n"))
 		return NULL;
 

commit 033751f6643adf616b85ac5eea7ce784bdde1b50
Author: Jeff Skirvin <jeffrey.d.skirvin@intel.com>
Date:   Thu Mar 8 22:41:56 2012 -0800

    isci: Only set IDEV_GONE in the device stop path.
    
    Signed-off-by: Jeff Skirvin <jeffrey.d.skirvin@intel.com>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/drivers/scsi/isci/remote_device.c b/drivers/scsi/isci/remote_device.c
index cf5d554e5056..b26ab05107dd 100644
--- a/drivers/scsi/isci/remote_device.c
+++ b/drivers/scsi/isci/remote_device.c
@@ -195,9 +195,6 @@ static void isci_remote_device_not_ready(struct isci_host *ihost,
 		"%s: isci_device = %p; reason = %d\n", __func__, idev, reason);
 
 	switch (reason) {
-	case SCIC_REMOTE_DEVICE_NOT_READY_STOP_REQUESTED:
-		set_bit(IDEV_GONE, &idev->flags);
-		break;
 	case SCIC_REMOTE_DEVICE_NOT_READY_SATA_SDB_ERROR_FIS_RECEIVED:
 		set_bit(IDEV_IO_NCQERROR, &idev->flags);
 

commit 59e35396436c564b5019e1a70073900bc3e19f4f
Author: Jeff Skirvin <jeffrey.d.skirvin@intel.com>
Date:   Thu Mar 8 22:41:54 2012 -0800

    isci: Add suspension cases for RNC INVALIDATING, POSTING states.
    
    The RNC can be any of the states in the loop from suspended to
    ready when the API "suspend" or "resume" are called.  This change
    adds destination states parameters that control the suspension /
    resumption action of the RNC statemachine for those transition states.
    
    Signed-off-by: Jeff Skirvin <jeffrey.d.skirvin@intel.com>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/drivers/scsi/isci/remote_device.c b/drivers/scsi/isci/remote_device.c
index c47304cea45d..cf5d554e5056 100644
--- a/drivers/scsi/isci/remote_device.c
+++ b/drivers/scsi/isci/remote_device.c
@@ -192,7 +192,7 @@ static void isci_remote_device_not_ready(struct isci_host *ihost,
 					 u32 reason)
 {
 	dev_dbg(&ihost->pdev->dev,
-		"%s: isci_device = %p\n", __func__, idev);
+		"%s: isci_device = %p; reason = %d\n", __func__, idev, reason);
 
 	switch (reason) {
 	case SCIC_REMOTE_DEVICE_NOT_READY_STOP_REQUESTED:

commit 14aaa9f0a318bd04cbb9d822524b817e95d8b343
Author: Jeff Skirvin <jeffrey.d.skirvin@intel.com>
Date:   Thu Mar 8 22:41:54 2012 -0800

    isci: Redesign device suspension, abort, cleanup.
    
    This commit changes the means by which outstanding I/Os are handled
    for cleanup.
    The likelihood is that this commit will be broken into smaller pieces,
    however that will be a later revision.  Among the changes:
    
    - All completion structures have been removed from the tmf and
    abort paths.
    - Now using one completed I/O list, with the I/O completed in host bit being
    used to select error or normal callback paths.
    
    Signed-off-by: Jeff Skirvin <jeffrey.d.skirvin@intel.com>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/drivers/scsi/isci/remote_device.c b/drivers/scsi/isci/remote_device.c
index 3048e02aeb7b..c47304cea45d 100644
--- a/drivers/scsi/isci/remote_device.c
+++ b/drivers/scsi/isci/remote_device.c
@@ -80,49 +80,6 @@ static enum sci_status sci_remote_device_suspend(struct isci_remote_device *idev
 					       NULL, NULL);
 }
 
-/**
- * isci_remote_device_not_ready() - This function is called by the ihost when
- *    the remote device is not ready. We mark the isci device as ready (not
- *    "ready_for_io") and signal the waiting proccess.
- * @isci_host: This parameter specifies the isci host object.
- * @isci_device: This parameter specifies the remote device
- *
- * sci_lock is held on entrance to this function.
- */
-static void isci_remote_device_not_ready(struct isci_host *ihost,
-				  struct isci_remote_device *idev, u32 reason)
-{
-	struct isci_request *ireq;
-
-	dev_dbg(&ihost->pdev->dev,
-		"%s: isci_device = %p\n", __func__, idev);
-
-	switch (reason) {
-	case SCIC_REMOTE_DEVICE_NOT_READY_STOP_REQUESTED:
-		set_bit(IDEV_GONE, &idev->flags);
-		break;
-	case SCIC_REMOTE_DEVICE_NOT_READY_SATA_SDB_ERROR_FIS_RECEIVED:
-		set_bit(IDEV_IO_NCQERROR, &idev->flags);
-
-		/* Suspend the remote device so the I/O can be terminated. */
-		sci_remote_device_suspend(idev);
-
-		/* Kill all outstanding requests for the device. */
-		list_for_each_entry(ireq, &idev->reqs_in_process, dev_node) {
-
-			dev_dbg(&ihost->pdev->dev,
-				"%s: isci_device = %p request = %p\n",
-				__func__, idev, ireq);
-
-			sci_controller_terminate_request(ihost, idev, ireq);
-		}
-		/* Fall through into the default case... */
-	default:
-		clear_bit(IDEV_IO_READY, &idev->flags);
-		break;
-	}
-}
-
 /**
  * isci_remote_device_ready() - This function is called by the ihost when the
  *    remote device is ready. We mark the isci device as ready and signal the
@@ -142,49 +99,121 @@ static void isci_remote_device_ready(struct isci_host *ihost, struct isci_remote
 		wake_up(&ihost->eventq);
 }
 
-static int isci_remote_device_suspendcheck(struct isci_remote_device *idev)
+static enum sci_status sci_remote_device_terminate_req(
+	struct isci_host *ihost,
+	struct isci_remote_device *idev,
+	int check_abort,
+	struct isci_request *ireq)
+{
+	dev_dbg(&ihost->pdev->dev,
+		"%s: idev=%p; flags=%lx; req=%p; req target=%p\n",
+		__func__, idev, idev->flags, ireq, ireq->target_device);
+
+	if (!test_bit(IREQ_ACTIVE, &ireq->flags) ||
+	    (ireq->target_device != idev) ||
+	    (check_abort && !test_bit(IREQ_PENDING_ABORT, &ireq->flags)))
+		return SCI_SUCCESS;
+
+	set_bit(IREQ_ABORT_PATH_ACTIVE, &ireq->flags);
+
+	return sci_controller_terminate_request(ihost, idev, ireq);
+}
+
+static enum sci_status sci_remote_device_terminate_reqs_checkabort(
+	struct isci_remote_device *idev,
+	int chk)
 {
-	return test_bit(IDEV_TXRX_SUSPENDED, &idev->flags)
-	    || !test_bit(IDEV_ALLOCATED, &idev->flags);
+	struct isci_host *ihost = idev->owning_port->owning_controller;
+	enum sci_status status  = SCI_SUCCESS;
+	u32 i;
+
+	for (i = 0; i < SCI_MAX_IO_REQUESTS; i++) {
+		struct isci_request *ireq = ihost->reqs[i];
+		enum sci_status s;
+
+		s = sci_remote_device_terminate_req(ihost, idev, chk, ireq);
+		if (s != SCI_SUCCESS)
+			status = s;
+	}
+	return status;
 }
 
-enum sci_status isci_remote_device_suspend(
+enum sci_status isci_remote_device_terminate_requests(
 	struct isci_host *ihost,
-	struct isci_remote_device *idev)
+	struct isci_remote_device *idev,
+	struct isci_request *ireq)
 {
-	enum sci_status status;
+	enum sci_status status = SCI_SUCCESS;
 	unsigned long flags;
 
 	spin_lock_irqsave(&ihost->scic_lock, flags);
-	if (isci_get_device(idev->domain_dev) == NULL) {
+	if (isci_get_device(idev) == NULL) {
+		dev_dbg(&ihost->pdev->dev, "%s: failed isci_get_device(idev=%p)\n",
+			__func__, idev);
 		spin_unlock_irqrestore(&ihost->scic_lock, flags);
 		status = SCI_FAILURE;
 	} else {
-		status = sci_remote_device_suspend(idev);
-		spin_unlock_irqrestore(&ihost->scic_lock, flags);
-		if (status == SCI_SUCCESS) {
-			dev_dbg(&ihost->pdev->dev,
-				"%s: idev=%p, about to wait\n",
-				__func__, idev);
-			wait_event(ihost->eventq,
-				   isci_remote_device_suspendcheck(idev));
-			status = test_bit(IDEV_TXRX_SUSPENDED, &idev->flags)
-					? SCI_SUCCESS : SCI_FAILURE;
-			dev_dbg(&ihost->pdev->dev,
-				"%s: idev=%p, wait done, device is %s\n",
-				__func__, idev,
-				test_bit(IDEV_TXRX_SUSPENDED, &idev->flags)
-					? "<suspended>" : "<deallocated!>");
+		dev_dbg(&ihost->pdev->dev,
+			"%s: idev=%p, ireq=%p; started_request_count=%d, "
+				"about to wait\n",
+			__func__, idev, ireq, idev->started_request_count);
+		if (ireq) {
+			/* Terminate a specific TC. */
+			sci_remote_device_terminate_req(ihost, idev, 0, ireq);
+			spin_unlock_irqrestore(&ihost->scic_lock, flags);
+			wait_event(ihost->eventq, !test_bit(IREQ_ACTIVE,
+							    &ireq->flags));
 
-		} else
-			dev_dbg(scirdev_to_dev(idev),
-				 "%s: sci_remote_device_suspend failed, "
-				 "status = %d\n", __func__, status);
+		} else {
+			/* Terminate all TCs. */
+			sci_remote_device_terminate_requests(idev);
+			spin_unlock_irqrestore(&ihost->scic_lock, flags);
+			wait_event(ihost->eventq,
+				   idev->started_request_count == 0);
+		}
+		dev_dbg(&ihost->pdev->dev, "%s: idev=%p, wait done\n",
+			__func__, idev);
 		isci_put_device(idev);
 	}
 	return status;
 }
 
+/**
+* isci_remote_device_not_ready() - This function is called by the ihost when
+*    the remote device is not ready. We mark the isci device as ready (not
+*    "ready_for_io") and signal the waiting proccess.
+* @isci_host: This parameter specifies the isci host object.
+* @isci_device: This parameter specifies the remote device
+*
+* sci_lock is held on entrance to this function.
+*/
+static void isci_remote_device_not_ready(struct isci_host *ihost,
+					 struct isci_remote_device *idev,
+					 u32 reason)
+{
+	dev_dbg(&ihost->pdev->dev,
+		"%s: isci_device = %p\n", __func__, idev);
+
+	switch (reason) {
+	case SCIC_REMOTE_DEVICE_NOT_READY_STOP_REQUESTED:
+		set_bit(IDEV_GONE, &idev->flags);
+		break;
+	case SCIC_REMOTE_DEVICE_NOT_READY_SATA_SDB_ERROR_FIS_RECEIVED:
+		set_bit(IDEV_IO_NCQERROR, &idev->flags);
+
+		/* Suspend the remote device so the I/O can be terminated. */
+		sci_remote_device_suspend(idev);
+
+		/* Kill all outstanding requests for the device. */
+		sci_remote_device_terminate_requests(idev);
+
+		/* Fall through into the default case... */
+	default:
+		clear_bit(IDEV_IO_READY, &idev->flags);
+		break;
+	}
+}
+
 /* called once the remote node context is ready to be freed.
  * The remote device can now report that its stop operation is complete. none
  */
@@ -196,36 +225,10 @@ static void rnc_destruct_done(void *_dev)
 	sci_change_state(&idev->sm, SCI_DEV_STOPPED);
 }
 
-static enum sci_status sci_remote_device_terminate_requests_checkabort(
-	struct isci_remote_device *idev,
-	int check_abort_pending)
-{
-	struct isci_host *ihost = idev->owning_port->owning_controller;
-	enum sci_status status  = SCI_SUCCESS;
-	u32 i;
-
-	for (i = 0; i < SCI_MAX_IO_REQUESTS; i++) {
-		struct isci_request *ireq = ihost->reqs[i];
-		enum sci_status s;
-
-		if (!test_bit(IREQ_ACTIVE, &ireq->flags) ||
-		    (ireq->target_device != idev) ||
-		    (check_abort_pending && !test_bit(IREQ_PENDING_ABORT,
-						      &ireq->flags)))
-			continue;
-
-		s = sci_controller_terminate_request(ihost, idev, ireq);
-		if (s != SCI_SUCCESS)
-			status = s;
-	}
-
-	return status;
-}
-
 enum sci_status sci_remote_device_terminate_requests(
 	struct isci_remote_device *idev)
 {
-	return sci_remote_device_terminate_requests_checkabort(idev, 0);
+	return sci_remote_device_terminate_reqs_checkabort(idev, 0);
 }
 
 enum sci_status sci_remote_device_stop(struct isci_remote_device *idev,
@@ -771,10 +774,6 @@ enum sci_status sci_remote_device_start_task(struct isci_host *ihost,
 		if (status != SCI_SUCCESS)
 			return status;
 
-		status = sci_remote_node_context_start_task(&idev->rnc, ireq);
-		if (status != SCI_SUCCESS)
-			goto out;
-
 		status = sci_request_start(ireq);
 		if (status != SCI_SUCCESS)
 			goto out;
@@ -796,8 +795,9 @@ enum sci_status sci_remote_device_start_task(struct isci_host *ihost,
 		sci_remote_node_context_suspend(
 			&idev->rnc, SCI_SOFTWARE_SUSPENSION,
 			SCI_SOFTWARE_SUSPEND_EXPECTED_EVENT, NULL, NULL);
-		sci_remote_node_context_resume(
-			&idev->rnc, sci_remote_device_continue_request, idev);
+
+		status = sci_remote_node_context_start_task(&idev->rnc, ireq,
+				sci_remote_device_continue_request, idev);
 
 	out:
 		sci_remote_device_start_request(idev, ireq, status);
@@ -811,7 +811,9 @@ enum sci_status sci_remote_device_start_task(struct isci_host *ihost,
 		if (status != SCI_SUCCESS)
 			return status;
 
-		status = sci_remote_node_context_start_task(&idev->rnc, ireq);
+		/* Resume the RNC as needed: */
+		status = sci_remote_node_context_start_task(&idev->rnc, ireq,
+							    NULL, NULL);
 		if (status != SCI_SUCCESS)
 			break;
 
@@ -1322,20 +1324,6 @@ static enum sci_status isci_remote_device_construct(struct isci_port *iport,
 	return status;
 }
 
-void isci_remote_device_nuke_requests(struct isci_host *ihost, struct isci_remote_device *idev)
-{
-	DECLARE_COMPLETION_ONSTACK(aborted_task_completion);
-
-	dev_dbg(&ihost->pdev->dev,
-		"%s: idev = %p\n", __func__, idev);
-
-	/* Cleanup all requests pending for this device. */
-	isci_terminate_pending_requests(ihost, idev);
-
-	dev_dbg(&ihost->pdev->dev,
-		"%s: idev = %p, done\n", __func__, idev);
-}
-
 /**
  * This function builds the isci_remote_device when a libsas dev_found message
  *    is received.
@@ -1495,32 +1483,28 @@ int isci_remote_device_found(struct domain_device *dev)
 	return status == SCI_SUCCESS ? 0 : -ENODEV;
 }
 
-enum sci_status isci_remote_device_reset(
+enum sci_status isci_remote_device_suspend_terminate(
 	struct isci_host *ihost,
-	struct isci_remote_device *idev)
+	struct isci_remote_device *idev,
+	struct isci_request *ireq)
 {
 	unsigned long flags;
 	enum sci_status status;
 
-	/* Put the device into a reset state so the suspension will not
-	 * automatically resume.
-	 */
+	/* Put the device into suspension. */
 	spin_lock_irqsave(&ihost->scic_lock, flags);
-	status = sci_remote_device_reset(idev);
+	sci_remote_device_suspend(idev);
 	spin_unlock_irqrestore(&ihost->scic_lock, flags);
-	if (status != SCI_SUCCESS) {
-		dev_dbg(&ihost->pdev->dev,
-			"%s: sci_remote_device_reset(%p) returned %d!\n",
-			__func__, idev, status);
-		return status;
-	}
-	/* Wait for the device suspend. */
-	status = isci_remote_device_suspend(ihost, idev);
-	if (status != SCI_SUCCESS) {
+
+	/* Terminate and wait for the completions. */
+	status = isci_remote_device_terminate_requests(ihost, idev, ireq);
+	if (status != SCI_SUCCESS)
 		dev_dbg(&ihost->pdev->dev,
-			"%s: isci_remote_device_suspend(%p) returned %d!\n",
+			"%s: isci_remote_device_terminate_requests(%p) "
+				"returned %d!\n",
 			__func__, idev, status);
-	}
+
+	/* NOTE: RNC resumption is left to the caller! */
 	return status;
 }
 
@@ -1533,7 +1517,7 @@ int isci_remote_device_is_safe_to_abort(
 enum sci_status sci_remote_device_abort_requests_pending_abort(
 	struct isci_remote_device *idev)
 {
-	return sci_remote_device_terminate_requests_checkabort(idev, 1);
+	return sci_remote_device_terminate_reqs_checkabort(idev, 1);
 }
 
 enum sci_status isci_remote_device_reset_complete(
@@ -1545,7 +1529,6 @@ enum sci_status isci_remote_device_reset_complete(
 
 	spin_lock_irqsave(&ihost->scic_lock, flags);
 	status = sci_remote_device_reset_complete(idev);
-	sci_remote_device_resume(idev, NULL, NULL);
 	spin_unlock_irqrestore(&ihost->scic_lock, flags);
 
 	return status;

commit 83884014eaaa68834ced39d1c75f1bc20d618ec0
Author: Jeff Skirvin <jeffrey.d.skirvin@intel.com>
Date:   Thu Mar 8 22:41:52 2012 -0800

    isci: Remote device stop also suspends the RNC and terminates I/O.
    
    Fixing the remote device state machine to suspend and terminate
    all outstanding I/O before the device stopped state is reached.
    
    Signed-off-by: Jeff Skirvin <jeffrey.d.skirvin@intel.com>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/drivers/scsi/isci/remote_device.c b/drivers/scsi/isci/remote_device.c
index f40d429d2cc0..3048e02aeb7b 100644
--- a/drivers/scsi/isci/remote_device.c
+++ b/drivers/scsi/isci/remote_device.c
@@ -263,13 +263,15 @@ enum sci_status sci_remote_device_stop(struct isci_remote_device *idev,
 	case SCI_SMP_DEV_IDLE:
 	case SCI_SMP_DEV_CMD:
 		sci_change_state(sm, SCI_DEV_STOPPING);
-		if (idev->started_request_count == 0) {
+		if (idev->started_request_count == 0)
 			sci_remote_node_context_destruct(&idev->rnc,
-							      rnc_destruct_done, idev);
-			return SCI_SUCCESS;
-		} else
-			return sci_remote_device_terminate_requests(idev);
-		break;
+							 rnc_destruct_done,
+							 idev);
+		else {
+			sci_remote_device_suspend(idev);
+			sci_remote_device_terminate_requests(idev);
+		}
+		return SCI_SUCCESS;
 	case SCI_DEV_STOPPING:
 		/* All requests should have been terminated, but if there is an
 		 * attempt to stop a device already in the stopping state, then
@@ -1403,14 +1405,8 @@ enum sci_status isci_remote_device_stop(struct isci_host *ihost, struct isci_rem
 	spin_lock_irqsave(&ihost->scic_lock, flags);
 	idev->domain_dev->lldd_dev = NULL; /* disable new lookups */
 	set_bit(IDEV_GONE, &idev->flags);
-	spin_unlock_irqrestore(&ihost->scic_lock, flags);
-
-	/* Kill all outstanding requests. */
-	isci_remote_device_nuke_requests(ihost, idev);
 
 	set_bit(IDEV_STOP_PENDING, &idev->flags);
-
-	spin_lock_irqsave(&ihost->scic_lock, flags);
 	status = sci_remote_device_stop(idev, 50);
 	spin_unlock_irqrestore(&ihost->scic_lock, flags);
 
@@ -1420,6 +1416,9 @@ enum sci_status isci_remote_device_stop(struct isci_host *ihost, struct isci_rem
 	else
 		wait_for_device_stop(ihost, idev);
 
+	dev_dbg(&ihost->pdev->dev,
+		"%s: isci_device = %p, waiting done.\n", __func__, idev);
+
 	return status;
 }
 

commit 23ec2aa947e83d0a172220f361166b8224875221
Author: Jeff Skirvin <jeffrey.d.skirvin@intel.com>
Date:   Thu Mar 8 22:41:52 2012 -0800

    isci: Remote device must be suspended for NCQ cleanup.
    
    When the remote device enters the NCQ error state, the device must
    be suspended so that the I/O terminations can take place.
    
    Signed-off-by: Jeff Skirvin <jeffrey.d.skirvin@intel.com>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/drivers/scsi/isci/remote_device.c b/drivers/scsi/isci/remote_device.c
index 4f76dcd1cec2..f40d429d2cc0 100644
--- a/drivers/scsi/isci/remote_device.c
+++ b/drivers/scsi/isci/remote_device.c
@@ -72,6 +72,14 @@ const char *dev_state_name(enum sci_remote_device_states state)
 }
 #undef C
 
+static enum sci_status sci_remote_device_suspend(struct isci_remote_device *idev)
+{
+	return sci_remote_node_context_suspend(&idev->rnc,
+					       SCI_SOFTWARE_SUSPENSION,
+					       SCI_SOFTWARE_SUSPEND_EXPECTED_EVENT,
+					       NULL, NULL);
+}
+
 /**
  * isci_remote_device_not_ready() - This function is called by the ihost when
  *    the remote device is not ready. We mark the isci device as ready (not
@@ -96,6 +104,9 @@ static void isci_remote_device_not_ready(struct isci_host *ihost,
 	case SCIC_REMOTE_DEVICE_NOT_READY_SATA_SDB_ERROR_FIS_RECEIVED:
 		set_bit(IDEV_IO_NCQERROR, &idev->flags);
 
+		/* Suspend the remote device so the I/O can be terminated. */
+		sci_remote_device_suspend(idev);
+
 		/* Kill all outstanding requests for the device. */
 		list_for_each_entry(ireq, &idev->reqs_in_process, dev_node) {
 
@@ -103,9 +114,7 @@ static void isci_remote_device_not_ready(struct isci_host *ihost,
 				"%s: isci_device = %p request = %p\n",
 				__func__, idev, ireq);
 
-			sci_controller_terminate_request(ihost,
-							  idev,
-							  ireq);
+			sci_controller_terminate_request(ihost, idev, ireq);
 		}
 		/* Fall through into the default case... */
 	default:
@@ -133,16 +142,6 @@ static void isci_remote_device_ready(struct isci_host *ihost, struct isci_remote
 		wake_up(&ihost->eventq);
 }
 
-static enum sci_status sci_remote_device_suspend(
-	struct isci_remote_device *idev)
-{
-	return sci_remote_node_context_suspend(
-		&idev->rnc,
-		SCI_SOFTWARE_SUSPENSION,
-		SCI_SOFTWARE_SUSPEND_EXPECTED_EVENT,
-		NULL, NULL);
-}
-
 static int isci_remote_device_suspendcheck(struct isci_remote_device *idev)
 {
 	return test_bit(IDEV_TXRX_SUSPENDED, &idev->flags)

commit 5b6bf225e7fc249c703e19bf2c983d1a59178874
Author: Jeff Skirvin <jeffrey.d.skirvin@intel.com>
Date:   Thu Mar 8 22:41:51 2012 -0800

    isci: Manage device suspensions during TC terminations.
    
    TCs must be terminated only while the RNC is suspended.  This commit
    adds remote device suspensions and resumptions in the abort, reset and
    termination paths.
    
    Signed-off-by: Jeff Skirvin <jeffrey.d.skirvin@intel.com>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/drivers/scsi/isci/remote_device.c b/drivers/scsi/isci/remote_device.c
index 9f03877534d2..4f76dcd1cec2 100644
--- a/drivers/scsi/isci/remote_device.c
+++ b/drivers/scsi/isci/remote_device.c
@@ -143,6 +143,12 @@ static enum sci_status sci_remote_device_suspend(
 		NULL, NULL);
 }
 
+static int isci_remote_device_suspendcheck(struct isci_remote_device *idev)
+{
+	return test_bit(IDEV_TXRX_SUSPENDED, &idev->flags)
+	    || !test_bit(IDEV_ALLOCATED, &idev->flags);
+}
+
 enum sci_status isci_remote_device_suspend(
 	struct isci_host *ihost,
 	struct isci_remote_device *idev)
@@ -151,18 +157,18 @@ enum sci_status isci_remote_device_suspend(
 	unsigned long flags;
 
 	spin_lock_irqsave(&ihost->scic_lock, flags);
-
-	if (isci_lookup_device(idev->domain_dev) == NULL) {
+	if (isci_get_device(idev->domain_dev) == NULL) {
 		spin_unlock_irqrestore(&ihost->scic_lock, flags);
 		status = SCI_FAILURE;
 	} else {
 		status = sci_remote_device_suspend(idev);
 		spin_unlock_irqrestore(&ihost->scic_lock, flags);
 		if (status == SCI_SUCCESS) {
+			dev_dbg(&ihost->pdev->dev,
+				"%s: idev=%p, about to wait\n",
+				__func__, idev);
 			wait_event(ihost->eventq,
-				   test_bit(IDEV_TXRX_SUSPENDED, &idev->flags)
-				|| !test_bit(IDEV_ALLOCATED, &idev->flags));
-
+				   isci_remote_device_suspendcheck(idev));
 			status = test_bit(IDEV_TXRX_SUSPENDED, &idev->flags)
 					? SCI_SUCCESS : SCI_FAILURE;
 			dev_dbg(&ihost->pdev->dev,
@@ -171,7 +177,10 @@ enum sci_status isci_remote_device_suspend(
 				test_bit(IDEV_TXRX_SUSPENDED, &idev->flags)
 					? "<suspended>" : "<deallocated!>");
 
-		}
+		} else
+			dev_dbg(scirdev_to_dev(idev),
+				 "%s: sci_remote_device_suspend failed, "
+				 "status = %d\n", __func__, status);
 		isci_put_device(idev);
 	}
 	return status;
@@ -1218,6 +1227,35 @@ static enum sci_status sci_remote_device_ea_construct(struct isci_port *iport,
 	return SCI_SUCCESS;
 }
 
+enum sci_status sci_remote_device_resume(
+	struct isci_remote_device *idev,
+	scics_sds_remote_node_context_callback cb_fn,
+	void *cb_p)
+{
+	enum sci_status status;
+
+	status = sci_remote_node_context_resume(&idev->rnc, cb_fn, cb_p);
+	if (status != SCI_SUCCESS)
+		dev_dbg(scirdev_to_dev(idev), "%s: failed to resume: %d\n",
+			__func__, status);
+	return status;
+}
+
+enum sci_status isci_remote_device_resume(
+	struct isci_host *ihost,
+	struct isci_remote_device *idev,
+	scics_sds_remote_node_context_callback cb_fn,
+	void *cb_p)
+{
+	unsigned long flags;
+	enum sci_status status;
+
+	spin_lock_irqsave(&ihost->scic_lock, flags);
+	status = sci_remote_device_resume(idev, cb_fn, cb_p);
+	spin_unlock_irqrestore(&ihost->scic_lock, flags);
+
+	return status;
+}
 /**
  * sci_remote_device_start() - This method will start the supplied remote
  *    device.  This method enables normal IO requests to flow through to the
@@ -1244,9 +1282,8 @@ static enum sci_status sci_remote_device_start(struct isci_remote_device *idev,
 		return SCI_FAILURE_INVALID_STATE;
 	}
 
-	status = sci_remote_node_context_resume(&idev->rnc,
-						     remote_device_resume_done,
-						     idev);
+	status = sci_remote_device_resume(idev, remote_device_resume_done,
+					  idev);
 	if (status != SCI_SUCCESS)
 		return status;
 
@@ -1461,26 +1498,29 @@ int isci_remote_device_found(struct domain_device *dev)
 }
 
 enum sci_status isci_remote_device_reset(
+	struct isci_host *ihost,
 	struct isci_remote_device *idev)
 {
-	struct isci_host *ihost = dev_to_ihost(idev->domain_dev);
 	unsigned long flags;
 	enum sci_status status;
 
-	/* Wait for the device suspend. */
-	status = isci_remote_device_suspend(ihost, idev);
+	/* Put the device into a reset state so the suspension will not
+	 * automatically resume.
+	 */
+	spin_lock_irqsave(&ihost->scic_lock, flags);
+	status = sci_remote_device_reset(idev);
+	spin_unlock_irqrestore(&ihost->scic_lock, flags);
 	if (status != SCI_SUCCESS) {
 		dev_dbg(&ihost->pdev->dev,
-			"%s: isci_remote_device_suspend(%p) returned %d!\n",
+			"%s: sci_remote_device_reset(%p) returned %d!\n",
 			__func__, idev, status);
 		return status;
 	}
-	spin_lock_irqsave(&ihost->scic_lock, flags);
-	status = sci_remote_device_reset(idev);
-	spin_unlock_irqrestore(&ihost->scic_lock, flags);
+	/* Wait for the device suspend. */
+	status = isci_remote_device_suspend(ihost, idev);
 	if (status != SCI_SUCCESS) {
 		dev_dbg(&ihost->pdev->dev,
-			"%s: sci_remote_device_reset(%p) returned %d!\n",
+			"%s: isci_remote_device_suspend(%p) returned %d!\n",
 			__func__, idev, status);
 	}
 	return status;
@@ -1497,3 +1537,19 @@ enum sci_status sci_remote_device_abort_requests_pending_abort(
 {
 	return sci_remote_device_terminate_requests_checkabort(idev, 1);
 }
+
+enum sci_status isci_remote_device_reset_complete(
+	struct isci_host *ihost,
+	struct isci_remote_device *idev)
+{
+	unsigned long flags;
+	enum sci_status status;
+
+	spin_lock_irqsave(&ihost->scic_lock, flags);
+	status = sci_remote_device_reset_complete(idev);
+	sci_remote_device_resume(idev, NULL, NULL);
+	spin_unlock_irqrestore(&ihost->scic_lock, flags);
+
+	return status;
+}
+

commit 726980d56908f2e230624394f03743689db3110c
Author: Jeff Skirvin <jeffrey.d.skirvin@intel.com>
Date:   Thu Mar 8 22:41:50 2012 -0800

    isci: Terminate outstanding TCs on TX/RX RNC suspensions.
    
    TCs must only be terminated when RNCs are suspended.
    
    Signed-off-by: Jeff Skirvin <jeffrey.d.skirvin@intel.com>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/drivers/scsi/isci/remote_device.c b/drivers/scsi/isci/remote_device.c
index b1a8000a5ef8..9f03877534d2 100644
--- a/drivers/scsi/isci/remote_device.c
+++ b/drivers/scsi/isci/remote_device.c
@@ -133,6 +133,50 @@ static void isci_remote_device_ready(struct isci_host *ihost, struct isci_remote
 		wake_up(&ihost->eventq);
 }
 
+static enum sci_status sci_remote_device_suspend(
+	struct isci_remote_device *idev)
+{
+	return sci_remote_node_context_suspend(
+		&idev->rnc,
+		SCI_SOFTWARE_SUSPENSION,
+		SCI_SOFTWARE_SUSPEND_EXPECTED_EVENT,
+		NULL, NULL);
+}
+
+enum sci_status isci_remote_device_suspend(
+	struct isci_host *ihost,
+	struct isci_remote_device *idev)
+{
+	enum sci_status status;
+	unsigned long flags;
+
+	spin_lock_irqsave(&ihost->scic_lock, flags);
+
+	if (isci_lookup_device(idev->domain_dev) == NULL) {
+		spin_unlock_irqrestore(&ihost->scic_lock, flags);
+		status = SCI_FAILURE;
+	} else {
+		status = sci_remote_device_suspend(idev);
+		spin_unlock_irqrestore(&ihost->scic_lock, flags);
+		if (status == SCI_SUCCESS) {
+			wait_event(ihost->eventq,
+				   test_bit(IDEV_TXRX_SUSPENDED, &idev->flags)
+				|| !test_bit(IDEV_ALLOCATED, &idev->flags));
+
+			status = test_bit(IDEV_TXRX_SUSPENDED, &idev->flags)
+					? SCI_SUCCESS : SCI_FAILURE;
+			dev_dbg(&ihost->pdev->dev,
+				"%s: idev=%p, wait done, device is %s\n",
+				__func__, idev,
+				test_bit(IDEV_TXRX_SUSPENDED, &idev->flags)
+					? "<suspended>" : "<deallocated!>");
+
+		}
+		isci_put_device(idev);
+	}
+	return status;
+}
+
 /* called once the remote node context is ready to be freed.
  * The remote device can now report that its stop operation is complete. none
  */
@@ -144,7 +188,9 @@ static void rnc_destruct_done(void *_dev)
 	sci_change_state(&idev->sm, SCI_DEV_STOPPED);
 }
 
-static enum sci_status sci_remote_device_terminate_requests(struct isci_remote_device *idev)
+static enum sci_status sci_remote_device_terminate_requests_checkabort(
+	struct isci_remote_device *idev,
+	int check_abort_pending)
 {
 	struct isci_host *ihost = idev->owning_port->owning_controller;
 	enum sci_status status  = SCI_SUCCESS;
@@ -155,7 +201,9 @@ static enum sci_status sci_remote_device_terminate_requests(struct isci_remote_d
 		enum sci_status s;
 
 		if (!test_bit(IREQ_ACTIVE, &ireq->flags) ||
-		    ireq->target_device != idev)
+		    (ireq->target_device != idev) ||
+		    (check_abort_pending && !test_bit(IREQ_PENDING_ABORT,
+						      &ireq->flags)))
 			continue;
 
 		s = sci_controller_terminate_request(ihost, idev, ireq);
@@ -166,6 +214,12 @@ static enum sci_status sci_remote_device_terminate_requests(struct isci_remote_d
 	return status;
 }
 
+enum sci_status sci_remote_device_terminate_requests(
+	struct isci_remote_device *idev)
+{
+	return sci_remote_device_terminate_requests_checkabort(idev, 0);
+}
+
 enum sci_status sci_remote_device_stop(struct isci_remote_device *idev,
 					u32 timeout)
 {
@@ -265,14 +319,6 @@ enum sci_status sci_remote_device_reset_complete(struct isci_remote_device *idev
 	return SCI_SUCCESS;
 }
 
-enum sci_status sci_remote_device_suspend(struct isci_remote_device *idev)
-{
-	return sci_remote_node_context_suspend(&idev->rnc,
-					       SCI_SOFTWARE_SUSPENSION,
-					       SCI_SOFTWARE_SUSPEND_EXPECTED_EVENT,
-					       NULL, NULL);
-}
-
 enum sci_status sci_remote_device_frame_handler(struct isci_remote_device *idev,
 						     u32 frame_index)
 {
@@ -1186,7 +1232,7 @@ static enum sci_status sci_remote_device_ea_construct(struct isci_port *iport,
  * the device when there have been no phys added to it.
  */
 static enum sci_status sci_remote_device_start(struct isci_remote_device *idev,
-						u32 timeout)
+					       u32 timeout)
 {
 	struct sci_base_state_machine *sm = &idev->sm;
 	enum sci_remote_device_states state = sm->current_state_id;
@@ -1413,3 +1459,41 @@ int isci_remote_device_found(struct domain_device *dev)
 
 	return status == SCI_SUCCESS ? 0 : -ENODEV;
 }
+
+enum sci_status isci_remote_device_reset(
+	struct isci_remote_device *idev)
+{
+	struct isci_host *ihost = dev_to_ihost(idev->domain_dev);
+	unsigned long flags;
+	enum sci_status status;
+
+	/* Wait for the device suspend. */
+	status = isci_remote_device_suspend(ihost, idev);
+	if (status != SCI_SUCCESS) {
+		dev_dbg(&ihost->pdev->dev,
+			"%s: isci_remote_device_suspend(%p) returned %d!\n",
+			__func__, idev, status);
+		return status;
+	}
+	spin_lock_irqsave(&ihost->scic_lock, flags);
+	status = sci_remote_device_reset(idev);
+	spin_unlock_irqrestore(&ihost->scic_lock, flags);
+	if (status != SCI_SUCCESS) {
+		dev_dbg(&ihost->pdev->dev,
+			"%s: sci_remote_device_reset(%p) returned %d!\n",
+			__func__, idev, status);
+	}
+	return status;
+}
+
+int isci_remote_device_is_safe_to_abort(
+	struct isci_remote_device *idev)
+{
+	return sci_remote_node_context_is_safe_to_abort(&idev->rnc);
+}
+
+enum sci_status sci_remote_device_abort_requests_pending_abort(
+	struct isci_remote_device *idev)
+{
+	return sci_remote_device_terminate_requests_checkabort(idev, 1);
+}

commit ac78ed0f78eae5c3c918e132b5e2029cdc4fdedc
Author: Jeff Skirvin <jeffrey.d.skirvin@intel.com>
Date:   Thu Mar 8 22:41:50 2012 -0800

    isci: Handle all suspending TC completions
    
    Add comprehensive decode for all TC completions that generate RNC
    suspensions.
    
    Note that this commit also removes unconditional resumptions of ATAPI
    devices when in the SCI_STP_DEV_ATAPI_ERROR state, and STP devices
    when in the SCI_STP_DEV_IDLE state. This is because the SCI_STP_DEV_IDLE
    and SCI_STP_DEV_ATAPI state entry functions manage the RNC resumption.
    
    Signed-off-by: Jeff Skirvin <jeffrey.d.skirvin@intel.com>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/drivers/scsi/isci/remote_device.c b/drivers/scsi/isci/remote_device.c
index 71f509064737..b1a8000a5ef8 100644
--- a/drivers/scsi/isci/remote_device.c
+++ b/drivers/scsi/isci/remote_device.c
@@ -265,20 +265,12 @@ enum sci_status sci_remote_device_reset_complete(struct isci_remote_device *idev
 	return SCI_SUCCESS;
 }
 
-enum sci_status sci_remote_device_suspend(struct isci_remote_device *idev,
-					       u32 suspend_type)
+enum sci_status sci_remote_device_suspend(struct isci_remote_device *idev)
 {
-	struct sci_base_state_machine *sm = &idev->sm;
-	enum sci_remote_device_states state = sm->current_state_id;
-
-	if (state != SCI_STP_DEV_CMD) {
-		dev_warn(scirdev_to_dev(idev), "%s: in wrong state: %s\n",
-			 __func__, dev_state_name(state));
-		return SCI_FAILURE_INVALID_STATE;
-	}
-
 	return sci_remote_node_context_suspend(&idev->rnc,
-						    suspend_type, NULL, NULL);
+					       SCI_SOFTWARE_SUSPENSION,
+					       SCI_SOFTWARE_SUSPEND_EXPECTED_EVENT,
+					       NULL, NULL);
 }
 
 enum sci_status sci_remote_device_frame_handler(struct isci_remote_device *idev,
@@ -412,8 +404,6 @@ static void atapi_remote_device_resume_done(void *_dev)
 enum sci_status sci_remote_device_event_handler(struct isci_remote_device *idev,
 						     u32 event_code)
 {
-	struct sci_base_state_machine *sm = &idev->sm;
-	enum sci_remote_device_states state = sm->current_state_id;
 	enum sci_status status;
 
 	switch (scu_get_event_type(event_code)) {
@@ -427,9 +417,11 @@ enum sci_status sci_remote_device_event_handler(struct isci_remote_device *idev,
 			status = SCI_SUCCESS;
 
 			/* Suspend the associated RNC */
-			sci_remote_node_context_suspend(&idev->rnc,
-							      SCI_SOFTWARE_SUSPENSION,
-							      NULL, NULL);
+			sci_remote_node_context_suspend(
+				&idev->rnc,
+				SCI_SOFTWARE_SUSPENSION,
+				SCI_SOFTWARE_SUSPEND_EXPECTED_EVENT,
+				NULL, NULL);
 
 			dev_dbg(scirdev_to_dev(idev),
 				"%s: device: %p event code: %x: %s\n",
@@ -455,26 +447,6 @@ enum sci_status sci_remote_device_event_handler(struct isci_remote_device *idev,
 	if (status != SCI_SUCCESS)
 		return status;
 
-	if (state == SCI_STP_DEV_ATAPI_ERROR) {
-		/* For ATAPI error state resume the RNC right away. */
-		if (scu_get_event_type(event_code) == SCU_EVENT_TYPE_RNC_SUSPEND_TX ||
-		    scu_get_event_type(event_code) == SCU_EVENT_TYPE_RNC_SUSPEND_TX_RX) {
-			return sci_remote_node_context_resume(&idev->rnc,
-							      atapi_remote_device_resume_done,
-							      idev);
-		}
-	}
-
-	if (state == SCI_STP_DEV_IDLE) {
-
-		/* We pick up suspension events to handle specifically to this
-		 * state. We resume the RNC right away.
-		 */
-		if (scu_get_event_type(event_code) == SCU_EVENT_TYPE_RNC_SUSPEND_TX ||
-		    scu_get_event_type(event_code) == SCU_EVENT_TYPE_RNC_SUSPEND_TX_RX)
-			status = sci_remote_node_context_resume(&idev->rnc, NULL, NULL);
-	}
-
 	return status;
 }
 
@@ -765,11 +737,11 @@ enum sci_status sci_remote_device_start_task(struct isci_host *ihost,
 		 * the correct action when the remote node context is suspended
 		 * and later resumed.
 		 */
-		sci_remote_node_context_suspend(&idev->rnc,
-				SCI_SOFTWARE_SUSPENSION, NULL, NULL);
-		sci_remote_node_context_resume(&idev->rnc,
-				sci_remote_device_continue_request,
-						    idev);
+		sci_remote_node_context_suspend(
+			&idev->rnc, SCI_SOFTWARE_SUSPENSION,
+			SCI_SOFTWARE_SUSPEND_EXPECTED_EVENT, NULL, NULL);
+		sci_remote_node_context_resume(
+			&idev->rnc, sci_remote_device_continue_request, idev);
 
 	out:
 		sci_remote_device_start_request(idev, ireq, status);
@@ -954,14 +926,23 @@ static void sci_remote_device_ready_state_exit(struct sci_base_state_machine *sm
 static void sci_remote_device_resetting_state_enter(struct sci_base_state_machine *sm)
 {
 	struct isci_remote_device *idev = container_of(sm, typeof(*idev), sm);
+	struct isci_host *ihost = idev->owning_port->owning_controller;
+
+	dev_dbg(&ihost->pdev->dev,
+		"%s: isci_device = %p\n", __func__, idev);
 
 	sci_remote_node_context_suspend(
-		&idev->rnc, SCI_SOFTWARE_SUSPENSION, NULL, NULL);
+		&idev->rnc, SCI_SOFTWARE_SUSPENSION,
+		SCI_SOFTWARE_SUSPEND_EXPECTED_EVENT, NULL, NULL);
 }
 
 static void sci_remote_device_resetting_state_exit(struct sci_base_state_machine *sm)
 {
 	struct isci_remote_device *idev = container_of(sm, typeof(*idev), sm);
+	struct isci_host *ihost = idev->owning_port->owning_controller;
+
+	dev_dbg(&ihost->pdev->dev,
+		"%s: isci_device = %p\n", __func__, idev);
 
 	sci_remote_node_context_resume(&idev->rnc, NULL, NULL);
 }
@@ -1004,6 +985,21 @@ static void sci_stp_remote_device_ready_ncq_error_substate_enter(struct sci_base
 					     idev->not_ready_reason);
 }
 
+static void sci_stp_remote_device_atapi_error_substate_enter(
+	struct sci_base_state_machine *sm)
+{
+	struct isci_remote_device *idev = container_of(sm, typeof(*idev), sm);
+
+	/* This state is entered when an I/O is decoded with an error
+	 * condition.  By this point the RNC expected suspension state is set.
+	 * The error conditions suspend the device, so unsuspend here if
+	 * possible.
+	 */
+	sci_remote_node_context_resume(&idev->rnc,
+				       atapi_remote_device_resume_done,
+				       idev);
+}
+
 static void sci_smp_remote_device_ready_idle_substate_enter(struct sci_base_state_machine *sm)
 {
 	struct isci_remote_device *idev = container_of(sm, typeof(*idev), sm);
@@ -1054,7 +1050,9 @@ static const struct sci_base_state sci_remote_device_state_table[] = {
 	[SCI_STP_DEV_NCQ_ERROR] = {
 		.enter_state = sci_stp_remote_device_ready_ncq_error_substate_enter,
 	},
-	[SCI_STP_DEV_ATAPI_ERROR] = { },
+	[SCI_STP_DEV_ATAPI_ERROR] = {
+		.enter_state = sci_stp_remote_device_atapi_error_substate_enter,
+	},
 	[SCI_STP_DEV_AWAIT_RESET] = { },
 	[SCI_SMP_DEV_IDLE] = {
 		.enter_state = sci_smp_remote_device_ready_idle_substate_enter,

commit 11cc51835af0e6fbb2da9cb012bdaaa036497b7f
Author: Dan Williams <dan.j.williams@intel.com>
Date:   Wed Feb 1 00:23:10 2012 -0800

    isci: kill ->is_direct_attached
    
    domain_device ->parent conveys the same information.
    
    Occurrences of ->is_direct_attached appear next to incomplete open-coded
    versions of dev_is_sata(), clean those up as well.
    
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/drivers/scsi/isci/remote_device.c b/drivers/scsi/isci/remote_device.c
index 8f501b0a81d6..71f509064737 100644
--- a/drivers/scsi/isci/remote_device.c
+++ b/drivers/scsi/isci/remote_device.c
@@ -1113,33 +1113,20 @@ static enum sci_status sci_remote_device_da_construct(struct isci_port *iport,
 {
 	enum sci_status status;
 	struct sci_port_properties properties;
-	struct domain_device *dev = idev->domain_dev;
 
 	sci_remote_device_construct(iport, idev);
 
-	/*
-	 * This information is request to determine how many remote node context
-	 * entries will be needed to store the remote node.
-	 */
-	idev->is_direct_attached = true;
-
 	sci_port_get_properties(iport, &properties);
 	/* Get accurate port width from port's phy mask for a DA device. */
 	idev->device_port_width = hweight32(properties.phy_mask);
 
 	status = sci_controller_allocate_remote_node_context(iport->owning_controller,
-								  idev,
-								  &idev->rnc.remote_node_index);
+							     idev,
+							     &idev->rnc.remote_node_index);
 
 	if (status != SCI_SUCCESS)
 		return status;
 
-	if (dev->dev_type == SAS_END_DEV || dev->dev_type == SATA_DEV ||
-	    (dev->tproto & SAS_PROTOCOL_STP) || dev_is_expander(dev))
-		/* pass */;
-	else
-		return SCI_FAILURE_UNSUPPORTED_PROTOCOL;
-
 	idev->connection_rate = sci_port_get_max_allowed_speed(iport);
 
 	return SCI_SUCCESS;
@@ -1171,19 +1158,13 @@ static enum sci_status sci_remote_device_ea_construct(struct isci_port *iport,
 	if (status != SCI_SUCCESS)
 		return status;
 
-	if (dev->dev_type == SAS_END_DEV || dev->dev_type == SATA_DEV ||
-	    (dev->tproto & SAS_PROTOCOL_STP) || dev_is_expander(dev))
-		/* pass */;
-	else
-		return SCI_FAILURE_UNSUPPORTED_PROTOCOL;
-
-	/*
-	 * For SAS-2 the physical link rate is actually a logical link
+	/* For SAS-2 the physical link rate is actually a logical link
 	 * rate that incorporates multiplexing.  The SCU doesn't
 	 * incorporate multiplexing and for the purposes of the
 	 * connection the logical link rate is that same as the
 	 * physical.  Furthermore, the SAS-2 and SAS-1.1 fields overlay
-	 * one another, so this code works for both situations. */
+	 * one another, so this code works for both situations.
+	 */
 	idev->connection_rate = min_t(u16, sci_port_get_max_allowed_speed(iport),
 					 dev->linkrate);
 

commit d7a0ccdd9bd78b5b74d2963ec7ab67c9d896902a
Author: Dan Williams <dan.j.williams@intel.com>
Date:   Fri Feb 10 01:18:44 2012 -0800

    [SCSI] isci: debug, provide state-enum-to-string conversions
    
    Debugging the driver requires tracing the state transtions and tracing
    state names is less work than decoding numbers.
    
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>
    Signed-off-by: James Bottomley <JBottomley@Parallels.com>

diff --git a/drivers/scsi/isci/remote_device.c b/drivers/scsi/isci/remote_device.c
index 934d21ea14e7..8f501b0a81d6 100644
--- a/drivers/scsi/isci/remote_device.c
+++ b/drivers/scsi/isci/remote_device.c
@@ -62,6 +62,16 @@
 #include "scu_event_codes.h"
 #include "task.h"
 
+#undef C
+#define C(a) (#a)
+const char *dev_state_name(enum sci_remote_device_states state)
+{
+	static const char * const strings[] = REMOTE_DEV_STATES;
+
+	return strings[state];
+}
+#undef C
+
 /**
  * isci_remote_device_not_ready() - This function is called by the ihost when
  *    the remote device is not ready. We mark the isci device as ready (not
@@ -167,8 +177,8 @@ enum sci_status sci_remote_device_stop(struct isci_remote_device *idev,
 	case SCI_DEV_FAILED:
 	case SCI_DEV_FINAL:
 	default:
-		dev_warn(scirdev_to_dev(idev), "%s: in wrong state: %d\n",
-			 __func__, state);
+		dev_warn(scirdev_to_dev(idev), "%s: in wrong state: %s\n",
+			 __func__, dev_state_name(state));
 		return SCI_FAILURE_INVALID_STATE;
 	case SCI_DEV_STOPPED:
 		return SCI_SUCCESS;
@@ -226,8 +236,8 @@ enum sci_status sci_remote_device_reset(struct isci_remote_device *idev)
 	case SCI_DEV_RESETTING:
 	case SCI_DEV_FINAL:
 	default:
-		dev_warn(scirdev_to_dev(idev), "%s: in wrong state: %d\n",
-			 __func__, state);
+		dev_warn(scirdev_to_dev(idev), "%s: in wrong state: %s\n",
+			 __func__, dev_state_name(state));
 		return SCI_FAILURE_INVALID_STATE;
 	case SCI_DEV_READY:
 	case SCI_STP_DEV_IDLE:
@@ -246,8 +256,8 @@ enum sci_status sci_remote_device_reset_complete(struct isci_remote_device *idev
 	enum sci_remote_device_states state = sm->current_state_id;
 
 	if (state != SCI_DEV_RESETTING) {
-		dev_warn(scirdev_to_dev(idev), "%s: in wrong state: %d\n",
-			 __func__, state);
+		dev_warn(scirdev_to_dev(idev), "%s: in wrong state: %s\n",
+			 __func__, dev_state_name(state));
 		return SCI_FAILURE_INVALID_STATE;
 	}
 
@@ -262,8 +272,8 @@ enum sci_status sci_remote_device_suspend(struct isci_remote_device *idev,
 	enum sci_remote_device_states state = sm->current_state_id;
 
 	if (state != SCI_STP_DEV_CMD) {
-		dev_warn(scirdev_to_dev(idev), "%s: in wrong state: %d\n",
-			 __func__, state);
+		dev_warn(scirdev_to_dev(idev), "%s: in wrong state: %s\n",
+			 __func__, dev_state_name(state));
 		return SCI_FAILURE_INVALID_STATE;
 	}
 
@@ -287,8 +297,8 @@ enum sci_status sci_remote_device_frame_handler(struct isci_remote_device *idev,
 	case SCI_SMP_DEV_IDLE:
 	case SCI_DEV_FINAL:
 	default:
-		dev_warn(scirdev_to_dev(idev), "%s: in wrong state: %d\n",
-			 __func__, state);
+		dev_warn(scirdev_to_dev(idev), "%s: in wrong state: %s\n",
+			 __func__, dev_state_name(state));
 		/* Return the frame back to the controller */
 		sci_controller_release_frame(ihost, frame_index);
 		return SCI_FAILURE_INVALID_STATE;
@@ -502,8 +512,8 @@ enum sci_status sci_remote_device_start_io(struct isci_host *ihost,
 	case SCI_DEV_RESETTING:
 	case SCI_DEV_FINAL:
 	default:
-		dev_warn(scirdev_to_dev(idev), "%s: in wrong state: %d\n",
-			 __func__, state);
+		dev_warn(scirdev_to_dev(idev), "%s: in wrong state: %s\n",
+			 __func__, dev_state_name(state));
 		return SCI_FAILURE_INVALID_STATE;
 	case SCI_DEV_READY:
 		/* attempt to start an io request for this device object. The remote
@@ -637,8 +647,8 @@ enum sci_status sci_remote_device_complete_io(struct isci_host *ihost,
 	case SCI_DEV_FAILED:
 	case SCI_DEV_FINAL:
 	default:
-		dev_warn(scirdev_to_dev(idev), "%s: in wrong state: %d\n",
-			 __func__, state);
+		dev_warn(scirdev_to_dev(idev), "%s: in wrong state: %s\n",
+			 __func__, dev_state_name(state));
 		return SCI_FAILURE_INVALID_STATE;
 	case SCI_DEV_READY:
 	case SCI_STP_DEV_AWAIT_RESET:
@@ -721,8 +731,8 @@ enum sci_status sci_remote_device_start_task(struct isci_host *ihost,
 	case SCI_DEV_RESETTING:
 	case SCI_DEV_FINAL:
 	default:
-		dev_warn(scirdev_to_dev(idev), "%s: in wrong state: %d\n",
-			 __func__, state);
+		dev_warn(scirdev_to_dev(idev), "%s: in wrong state: %s\n",
+			 __func__, dev_state_name(state));
 		return SCI_FAILURE_INVALID_STATE;
 	case SCI_STP_DEV_IDLE:
 	case SCI_STP_DEV_CMD:
@@ -853,8 +863,8 @@ static enum sci_status sci_remote_device_destruct(struct isci_remote_device *ide
 	struct isci_host *ihost;
 
 	if (state != SCI_DEV_STOPPED) {
-		dev_warn(scirdev_to_dev(idev), "%s: in wrong state: %d\n",
-			 __func__, state);
+		dev_warn(scirdev_to_dev(idev), "%s: in wrong state: %s\n",
+			 __func__, dev_state_name(state));
 		return SCI_FAILURE_INVALID_STATE;
 	}
 
@@ -1204,8 +1214,8 @@ static enum sci_status sci_remote_device_start(struct isci_remote_device *idev,
 	enum sci_status status;
 
 	if (state != SCI_DEV_STOPPED) {
-		dev_warn(scirdev_to_dev(idev), "%s: in wrong state: %d\n",
-			 __func__, state);
+		dev_warn(scirdev_to_dev(idev), "%s: in wrong state: %s\n",
+			 __func__, dev_state_name(state));
 		return SCI_FAILURE_INVALID_STATE;
 	}
 

commit 5a998328296cb16cb8b0307a402a0f2feab533c5
Author: Dan Williams <dan.j.williams@intel.com>
Date:   Mon Dec 12 20:32:09 2011 -0800

    [SCSI] isci: remove IDEV_EH hack to disable "discovery-time" ata resets
    
    Prior to commit 61aaff49 "isci: filter broadcast change notifications
    during SMP phy resets" we borrowed the MVS_DEV_EH approach from the
    mvsas driver for preventing ->lldd_I_T_nexus_reset() events during ata
    discovery.  This hack was protecting against the old ->phy_reset() in
    ata_bus_probe(), but since the conversion to the new error handling this
    hack is preventing resets from reaching ata devices.
    
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>
    Signed-off-by: James Bottomley <JBottomley@Parallels.com>

diff --git a/drivers/scsi/isci/remote_device.c b/drivers/scsi/isci/remote_device.c
index 108238d4510d..934d21ea14e7 100644
--- a/drivers/scsi/isci/remote_device.c
+++ b/drivers/scsi/isci/remote_device.c
@@ -1308,7 +1308,6 @@ void isci_remote_device_release(struct kref *kref)
 	clear_bit(IDEV_STOP_PENDING, &idev->flags);
 	clear_bit(IDEV_IO_READY, &idev->flags);
 	clear_bit(IDEV_GONE, &idev->flags);
-	clear_bit(IDEV_EH, &idev->flags);
 	smp_mb__before_clear_bit();
 	clear_bit(IDEV_ALLOCATED, &idev->flags);
 	wake_up(&ihost->eventq);

commit fca4ecbdc440337b3c257b38c2f4cc8d0ca0286c
Author: Dan Williams <dan.j.williams@intel.com>
Date:   Tue Jan 3 23:26:15 2012 -0800

    [SCSI] isci: kill isci_port->status
    
    It only tracks whether the port is stopping in order to gate new devices
    being discovered while the port is stopping.  However, since the check
    and subsequent handling is unlocked there is nothing to stop the port
    from going down immediately after the check.
    
    Driver is already prepared to handle devices arriving on stale ports,
    and those will be cleaned up by an eventual ->lldd_dev_gone()
    notification.
    
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>
    Signed-off-by: James Bottomley <JBottomley@Parallels.com>

diff --git a/drivers/scsi/isci/remote_device.c b/drivers/scsi/isci/remote_device.c
index cff684fc1efc..108238d4510d 100644
--- a/drivers/scsi/isci/remote_device.c
+++ b/drivers/scsi/isci/remote_device.c
@@ -1394,10 +1394,6 @@ int isci_remote_device_found(struct domain_device *dev)
 	if (!isci_port)
 		return -ENODEV;
 
-	if ((isci_stopping == isci_port_get_state(isci_port)) ||
-	    (isci_stopped == isci_port_get_state(isci_port)))
-		return -ENODEV;
-
 	isci_device = isci_remote_device_alloc(isci_host, isci_port);
 	if (!isci_device)
 		return -ENODEV;

commit c132f692085ac624d7c8123df781846c8dcb3166
Author: Dan Williams <dan.j.williams@intel.com>
Date:   Tue Jan 3 23:26:08 2012 -0800

    [SCSI] isci: kill iphy->isci_port lookups
    
    This field is a holdover from the OS abstraction conversion.  The stable
    phy to port lookups are done via iphy->ownining_port under scic_lock.
    After this conversion to use port->lldd_port the only volatile lookup is
    the initial lookup in isci_port_formed().  After that point any lookup
    via a successfully notified domain_device is guaranteed to be valid
    until the domain_device is destroyed.
    
    Delete ->start_complete as it is only set once and is set as a
    consequence of the port going link up, by definition of getting a port
    formed event the port is "ready".
    
    While we are correcting port lookups also move the asd_sas_port table
    out from under the isci_port.  This is to preclude any temptation to use
    container_of() to convert an asd_sas_port to an isci_port, the
    association is dynamic and under libsas control.
    
    Tested-by: Maciej Trela <maciej.trela@intel.com>
    [dmilburn@redhat.com: fix i686 compile error]
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>
    Signed-off-by: James Bottomley <JBottomley@Parallels.com>

diff --git a/drivers/scsi/isci/remote_device.c b/drivers/scsi/isci/remote_device.c
index dd74b6ceeb82..cff684fc1efc 100644
--- a/drivers/scsi/isci/remote_device.c
+++ b/drivers/scsi/isci/remote_device.c
@@ -1381,31 +1381,18 @@ void isci_remote_device_gone(struct domain_device *dev)
  *
  * status, zero indicates success.
  */
-int isci_remote_device_found(struct domain_device *domain_dev)
+int isci_remote_device_found(struct domain_device *dev)
 {
-	struct isci_host *isci_host = dev_to_ihost(domain_dev);
-	struct isci_port *isci_port;
-	struct isci_phy *isci_phy;
-	struct asd_sas_port *sas_port;
-	struct asd_sas_phy *sas_phy;
+	struct isci_host *isci_host = dev_to_ihost(dev);
+	struct isci_port *isci_port = dev->port->lldd_port;
 	struct isci_remote_device *isci_device;
 	enum sci_status status;
 
 	dev_dbg(&isci_host->pdev->dev,
-		"%s: domain_device = %p\n", __func__, domain_dev);
+		"%s: domain_device = %p\n", __func__, dev);
 
-	wait_for_start(isci_host);
-
-	sas_port = domain_dev->port;
-	sas_phy = list_first_entry(&sas_port->phy_list, struct asd_sas_phy,
-				   port_phy_el);
-	isci_phy = to_iphy(sas_phy);
-	isci_port = isci_phy->isci_port;
-
-	/* we are being called for a device on this port,
-	 * so it has to come up eventually
-	 */
-	wait_for_completion(&isci_port->start_complete);
+	if (!isci_port)
+		return -ENODEV;
 
 	if ((isci_stopping == isci_port_get_state(isci_port)) ||
 	    (isci_stopped == isci_port_get_state(isci_port)))
@@ -1419,7 +1406,7 @@ int isci_remote_device_found(struct domain_device *domain_dev)
 	INIT_LIST_HEAD(&isci_device->node);
 
 	spin_lock_irq(&isci_host->scic_lock);
-	isci_device->domain_dev = domain_dev;
+	isci_device->domain_dev = dev;
 	isci_device->isci_port = isci_port;
 	list_add_tail(&isci_device->node, &isci_port->remote_dev_list);
 
@@ -1432,7 +1419,7 @@ int isci_remote_device_found(struct domain_device *domain_dev)
 
 	if (status == SCI_SUCCESS) {
 		/* device came up, advertise it to the world */
-		domain_dev->lldd_dev = isci_device;
+		dev->lldd_dev = isci_device;
 	} else
 		isci_put_device(isci_device);
 	spin_unlock_irq(&isci_host->scic_lock);

commit 7e629841b8f8f7bc84d74de994d748b0a3282225
Author: Bartek Nowakowski <bartek.nowakowski@intel.com>
Date:   Wed Jan 4 01:33:20 2012 -0800

    [SCSI] isci: enable wide port targets
    
    Arrange for task_contexts prepared for the wide targets to account for
    all the attached phys in the port.
    
    Signed-off-by: Bartek Nowakowski <bartek.nowakowski@intel.com>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>
    Signed-off-by: James Bottomley <JBottomley@Parallels.com>

diff --git a/drivers/scsi/isci/remote_device.c b/drivers/scsi/isci/remote_device.c
index b207cd3b15a0..dd74b6ceeb82 100644
--- a/drivers/scsi/isci/remote_device.c
+++ b/drivers/scsi/isci/remote_device.c
@@ -53,6 +53,7 @@
  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
 #include <scsi/sas.h>
+#include <linux/bitops.h>
 #include "isci.h"
 #include "port.h"
 #include "remote_device.h"
@@ -1101,6 +1102,7 @@ static enum sci_status sci_remote_device_da_construct(struct isci_port *iport,
 						       struct isci_remote_device *idev)
 {
 	enum sci_status status;
+	struct sci_port_properties properties;
 	struct domain_device *dev = idev->domain_dev;
 
 	sci_remote_device_construct(iport, idev);
@@ -1110,6 +1112,11 @@ static enum sci_status sci_remote_device_da_construct(struct isci_port *iport,
 	 * entries will be needed to store the remote node.
 	 */
 	idev->is_direct_attached = true;
+
+	sci_port_get_properties(iport, &properties);
+	/* Get accurate port width from port's phy mask for a DA device. */
+	idev->device_port_width = hweight32(properties.phy_mask);
+
 	status = sci_controller_allocate_remote_node_context(iport->owning_controller,
 								  idev,
 								  &idev->rnc.remote_node_index);
@@ -1125,9 +1132,6 @@ static enum sci_status sci_remote_device_da_construct(struct isci_port *iport,
 
 	idev->connection_rate = sci_port_get_max_allowed_speed(iport);
 
-	/* / @todo Should I assign the port width by reading all of the phys on the port? */
-	idev->device_port_width = 1;
-
 	return SCI_SUCCESS;
 }
 

commit 5412e25c55fc0b08041a451d8bee6f2b291099c2
Author: Jeff Skirvin <jeffrey.d.skirvin@intel.com>
Date:   Thu Oct 27 15:05:27 2011 -0700

    [SCSI] isci: No need to manage the pending reset bit on pending requests.
    
    The lldd does not need to look at or manage the pending device
    reset bit in pending sas_tasks.
    
    Signed-off-by: Jeff Skirvin <jeffrey.d.skirvin@intel.com>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>
    Signed-off-by: James Bottomley <JBottomley@Parallels.com>

diff --git a/drivers/scsi/isci/remote_device.c b/drivers/scsi/isci/remote_device.c
index 9d9e33d2ed51..b207cd3b15a0 100644
--- a/drivers/scsi/isci/remote_device.c
+++ b/drivers/scsi/isci/remote_device.c
@@ -1438,38 +1438,3 @@ int isci_remote_device_found(struct domain_device *domain_dev)
 
 	return status == SCI_SUCCESS ? 0 : -ENODEV;
 }
-
-/**
- * isci_device_clear_reset_pending() - This function will clear if any pending
- *    reset condition flags on the device.
- * @request: This parameter is the isci_device object.
- *
- * true if there is a reset pending for the device.
- */
-void isci_device_clear_reset_pending(struct isci_host *ihost, struct isci_remote_device *idev)
-{
-	struct isci_request *isci_request;
-	struct isci_request *tmp_req;
-	unsigned long flags = 0;
-
-	dev_dbg(&ihost->pdev->dev, "%s: idev=%p, ihost=%p\n",
-		 __func__, idev, ihost);
-
-	spin_lock_irqsave(&ihost->scic_lock, flags);
-
-	/* Clear reset pending on all pending requests. */
-	list_for_each_entry_safe(isci_request, tmp_req,
-				 &idev->reqs_in_process, dev_node) {
-		dev_dbg(&ihost->pdev->dev, "%s: idev = %p request = %p\n",
-			 __func__, idev, isci_request);
-
-		if (!test_bit(IREQ_TMF, &isci_request->flags)) {
-			struct sas_task *task = isci_request_access_task(isci_request);
-
-			spin_lock(&task->task_state_lock);
-			task->task_state_flags &= ~SAS_TASK_NEED_DEV_RESET;
-			spin_unlock(&task->task_state_lock);
-		}
-	}
-	spin_unlock_irqrestore(&ihost->scic_lock, flags);
-}

commit 3b34c169f8197e02529fa3ec703703c2ce418c57
Author: Jeff Skirvin <jeffrey.d.skirvin@intel.com>
Date:   Thu Oct 27 15:05:22 2011 -0700

    [SCSI] isci: Remove redundant isci_request.ttype field.
    
    Use the existing IREQ_TMF flag as a request type indicator.
    
    Signed-off-by: Jeff Skirvin <jeffrey.d.skirvin@intel.com>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>
    Signed-off-by: James Bottomley <JBottomley@Parallels.com>

diff --git a/drivers/scsi/isci/remote_device.c b/drivers/scsi/isci/remote_device.c
index 20c77edd4711..9d9e33d2ed51 100644
--- a/drivers/scsi/isci/remote_device.c
+++ b/drivers/scsi/isci/remote_device.c
@@ -1463,15 +1463,12 @@ void isci_device_clear_reset_pending(struct isci_host *ihost, struct isci_remote
 		dev_dbg(&ihost->pdev->dev, "%s: idev = %p request = %p\n",
 			 __func__, idev, isci_request);
 
-		if (isci_request->ttype == io_task) {
+		if (!test_bit(IREQ_TMF, &isci_request->flags)) {
+			struct sas_task *task = isci_request_access_task(isci_request);
 
-			unsigned long flags2;
-			struct sas_task *task = isci_request_access_task(
-				isci_request);
-
-			spin_lock_irqsave(&task->task_state_lock, flags2);
+			spin_lock(&task->task_state_lock);
 			task->task_state_flags &= ~SAS_TASK_NEED_DEV_RESET;
-			spin_unlock_irqrestore(&task->task_state_lock, flags2);
+			spin_unlock(&task->task_state_lock);
 		}
 	}
 	spin_unlock_irqrestore(&ihost->scic_lock, flags);

commit 98145cb722b51ccc3ba27166c9803545accba950
Author: Jeff Skirvin <jeffrey.d.skirvin@intel.com>
Date:   Thu Oct 27 15:05:16 2011 -0700

    [SCSI] isci: Fix task management for SMP, SATA and on dev remove.
    
    libsas uses the LLDD abort task interface to handle I/O timeouts
    in the SATA/STP and SMP discovery paths, so this change will terminate
    STP/SMP requests. Also, if the device is gone, the lldd will prevent
    libsas from further escalations in the error handler.
    
    Signed-off-by: Jeff Skirvin <jeffrey.d.skirvin@intel.com>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>
    Signed-off-by: James Bottomley <JBottomley@Parallels.com>

diff --git a/drivers/scsi/isci/remote_device.c b/drivers/scsi/isci/remote_device.c
index fbf9ce28c3f5..20c77edd4711 100644
--- a/drivers/scsi/isci/remote_device.c
+++ b/drivers/scsi/isci/remote_device.c
@@ -1438,53 +1438,6 @@ int isci_remote_device_found(struct domain_device *domain_dev)
 
 	return status == SCI_SUCCESS ? 0 : -ENODEV;
 }
-/**
- * isci_device_is_reset_pending() - This function will check if there is any
- *    pending reset condition on the device.
- * @request: This parameter is the isci_device object.
- *
- * true if there is a reset pending for the device.
- */
-bool isci_device_is_reset_pending(
-	struct isci_host *isci_host,
-	struct isci_remote_device *isci_device)
-{
-	struct isci_request *isci_request;
-	struct isci_request *tmp_req;
-	bool reset_is_pending = false;
-	unsigned long flags;
-
-	dev_dbg(&isci_host->pdev->dev,
-		"%s: isci_device = %p\n", __func__, isci_device);
-
-	spin_lock_irqsave(&isci_host->scic_lock, flags);
-
-	/* Check for reset on all pending requests. */
-	list_for_each_entry_safe(isci_request, tmp_req,
-				 &isci_device->reqs_in_process, dev_node) {
-		dev_dbg(&isci_host->pdev->dev,
-			"%s: isci_device = %p request = %p\n",
-			__func__, isci_device, isci_request);
-
-		if (isci_request->ttype == io_task) {
-			struct sas_task *task = isci_request_access_task(
-				isci_request);
-
-			spin_lock(&task->task_state_lock);
-			if (task->task_state_flags & SAS_TASK_NEED_DEV_RESET)
-				reset_is_pending = true;
-			spin_unlock(&task->task_state_lock);
-		}
-	}
-
-	spin_unlock_irqrestore(&isci_host->scic_lock, flags);
-
-	dev_dbg(&isci_host->pdev->dev,
-		"%s: isci_device = %p reset_is_pending = %d\n",
-		__func__, isci_device, reset_is_pending);
-
-	return reset_is_pending;
-}
 
 /**
  * isci_device_clear_reset_pending() - This function will clear if any pending

commit b50102d3e9a43a75379407c2080f696f61cb286b
Author: Dan Williams <dan.j.williams@intel.com>
Date:   Fri Sep 30 18:52:19 2011 -0700

    [SCSI] isci: atapi support
    
    Based on original implementation from Jiangbi Liu and Maciej Trela.
    
    ATAPI transfers happen in two-to-three stages.  The two stage atapi
    commands are those that include a dma data transfer.  The data transfer
    portion of these operations is handled by the hardware packet-dma
    acceleration.  The three-stage commands do not have a data transfer and
    are handled without hardware assistance in raw frame mode.
    
    stage1: transmit host-to-device fis to notify the device of an incoming
    atapi cdb.  Upon reception of the pio-setup-fis repost the task_context
    to perform the dma transfer of the cdb+data (go to stage3), or repost
    the task_context to transmit the cdb as a raw frame (go to stage 2).
    
    stage2: wait for hardware notification of the cdb transmission and then
    go to stage 3.
    
    stage3: wait for the arrival of the terminating device-to-host fis and
    terminate the command.
    
    To keep the implementation simple we only support ATAPI packet-dma
    protocol (for commands with data) to avoid needing to handle the data
    transfer manually (like we do for SATA-PIO).  This may affect
    compatibility for a small number of devices (see
    ATA_HORKAGE_ATAPI_MOD16_DMA).
    
    If the data-transfer underruns, or encounters an error the
    device-to-host fis is expected to arrive in the unsolicited frame queue
    to pass to libata for disposition.  However, in the DONE_UNEXP_FIS (data
    underrun) case it appears we need to craft a response.  In the
    DONE_REG_ERR case we do receive the UF and propagate it to libsas.
    
    Signed-off-by: Maciej Trela <maciej.trela@intel.com>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>
    Signed-off-by: James Bottomley <JBottomley@Parallels.com>

diff --git a/drivers/scsi/isci/remote_device.c b/drivers/scsi/isci/remote_device.c
index b6e6368c2665..fbf9ce28c3f5 100644
--- a/drivers/scsi/isci/remote_device.c
+++ b/drivers/scsi/isci/remote_device.c
@@ -386,6 +386,18 @@ static bool is_remote_device_ready(struct isci_remote_device *idev)
 	}
 }
 
+/*
+ * called once the remote node context has transisitioned to a ready
+ * state (after suspending RX and/or TX due to early D2H fis)
+ */
+static void atapi_remote_device_resume_done(void *_dev)
+{
+	struct isci_remote_device *idev = _dev;
+	struct isci_request *ireq = idev->working_request;
+
+	sci_change_state(&ireq->sm, SCI_REQ_COMPLETED);
+}
+
 enum sci_status sci_remote_device_event_handler(struct isci_remote_device *idev,
 						     u32 event_code)
 {
@@ -432,6 +444,16 @@ enum sci_status sci_remote_device_event_handler(struct isci_remote_device *idev,
 	if (status != SCI_SUCCESS)
 		return status;
 
+	if (state == SCI_STP_DEV_ATAPI_ERROR) {
+		/* For ATAPI error state resume the RNC right away. */
+		if (scu_get_event_type(event_code) == SCU_EVENT_TYPE_RNC_SUSPEND_TX ||
+		    scu_get_event_type(event_code) == SCU_EVENT_TYPE_RNC_SUSPEND_TX_RX) {
+			return sci_remote_node_context_resume(&idev->rnc,
+							      atapi_remote_device_resume_done,
+							      idev);
+		}
+	}
+
 	if (state == SCI_STP_DEV_IDLE) {
 
 		/* We pick up suspension events to handle specifically to this
@@ -625,6 +647,7 @@ enum sci_status sci_remote_device_complete_io(struct isci_host *ihost,
 	case SCI_STP_DEV_CMD:
 	case SCI_STP_DEV_NCQ:
 	case SCI_STP_DEV_NCQ_ERROR:
+	case SCI_STP_DEV_ATAPI_ERROR:
 		status = common_complete_io(iport, idev, ireq);
 		if (status != SCI_SUCCESS)
 			break;
@@ -1020,6 +1043,7 @@ static const struct sci_base_state sci_remote_device_state_table[] = {
 	[SCI_STP_DEV_NCQ_ERROR] = {
 		.enter_state = sci_stp_remote_device_ready_ncq_error_substate_enter,
 	},
+	[SCI_STP_DEV_ATAPI_ERROR] = { },
 	[SCI_STP_DEV_AWAIT_RESET] = { },
 	[SCI_SMP_DEV_IDLE] = {
 		.enter_state = sci_smp_remote_device_ready_idle_substate_enter,

commit a5ec7f86dc5432c44d8407a144e7617ec65da770
Author: James Bottomley <James.Bottomley@HansenPartnership.com>
Date:   Sun Jul 3 14:14:45 2011 -0500

    [SCSI] isci: fix checkpatch errors
    
    Signed-off-by: James Bottomley <JBottomley@Parallels.com>

diff --git a/drivers/scsi/isci/remote_device.c b/drivers/scsi/isci/remote_device.c
index 85e54f542075..b6e6368c2665 100644
--- a/drivers/scsi/isci/remote_device.c
+++ b/drivers/scsi/isci/remote_device.c
@@ -73,7 +73,7 @@
 static void isci_remote_device_not_ready(struct isci_host *ihost,
 				  struct isci_remote_device *idev, u32 reason)
 {
-	struct isci_request * ireq;
+	struct isci_request *ireq;
 
 	dev_dbg(&ihost->pdev->dev,
 		"%s: isci_device = %p\n", __func__, idev);

commit 34a991587a5cc9f78960c2c9beea217866458c41
Author: Dan Williams <dan.j.williams@intel.com>
Date:   Fri Jul 1 02:25:15 2011 -0700

    isci: kill 'get/set' macros
    
    Most of these simple dereference macros are longer than their open coded
    equivalent.  Deleting enum sci_controller_mode is thrown in for good
    measure.
    
    Reported-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/drivers/scsi/isci/remote_device.c b/drivers/scsi/isci/remote_device.c
index 8c752abb4331..85e54f542075 100644
--- a/drivers/scsi/isci/remote_device.c
+++ b/drivers/scsi/isci/remote_device.c
@@ -456,7 +456,7 @@ static void sci_remote_device_start_request(struct isci_remote_device *idev,
 		sci_port_complete_io(iport, idev, ireq);
 	else {
 		kref_get(&idev->kref);
-		sci_remote_device_increment_request_count(idev);
+		idev->started_request_count++;
 	}
 }
 
@@ -636,7 +636,7 @@ enum sci_status sci_remote_device_complete_io(struct isci_host *ihost,
 			 * status of "DEVICE_RESET_REQUIRED", instead of "INVALID STATE".
 			 */
 			sci_change_state(sm, SCI_STP_DEV_AWAIT_RESET);
-		} else if (sci_remote_device_get_request_count(idev) == 0)
+		} else if (idev->started_request_count == 0)
 			sci_change_state(sm, SCI_STP_DEV_IDLE);
 		break;
 	case SCI_SMP_DEV_CMD:
@@ -650,10 +650,10 @@ enum sci_status sci_remote_device_complete_io(struct isci_host *ihost,
 		if (status != SCI_SUCCESS)
 			break;
 
-		if (sci_remote_device_get_request_count(idev) == 0)
+		if (idev->started_request_count == 0)
 			sci_remote_node_context_destruct(&idev->rnc,
-							      rnc_destruct_done,
-							      idev);
+							 rnc_destruct_done,
+							 idev);
 		break;
 	}
 
@@ -761,26 +761,17 @@ enum sci_status sci_remote_device_start_task(struct isci_host *ihost,
 	return status;
 }
 
-/**
- *
- * @sci_dev:
- * @request:
- *
- * This method takes the request and bulids an appropriate SCU context for the
- * request and then requests the controller to post the request. none
- */
-void sci_remote_device_post_request(
-	struct isci_remote_device *idev,
-	u32 request)
+void sci_remote_device_post_request(struct isci_remote_device *idev, u32 request)
 {
+	struct isci_port *iport = idev->owning_port;
 	u32 context;
 
-	context = sci_remote_device_build_command_context(idev, request);
+	context = request |
+		  (ISCI_PEG << SCU_CONTEXT_COMMAND_PROTOCOL_ENGINE_GROUP_SHIFT) |
+		  (iport->physical_port_index << SCU_CONTEXT_COMMAND_LOGICAL_PORT_SHIFT) |
+		  idev->rnc.remote_node_index;
 
-	sci_controller_post_request(
-		sci_remote_device_get_controller(idev),
-		context
-		);
+	sci_controller_post_request(iport->owning_controller, context);
 }
 
 /* called once the remote node context has transisitioned to a
@@ -893,7 +884,7 @@ static void sci_remote_device_stopped_state_enter(struct sci_base_state_machine
 static void sci_remote_device_starting_state_enter(struct sci_base_state_machine *sm)
 {
 	struct isci_remote_device *idev = container_of(sm, typeof(*idev), sm);
-	struct isci_host *ihost = sci_remote_device_get_controller(idev);
+	struct isci_host *ihost = idev->owning_port->owning_controller;
 
 	isci_remote_device_not_ready(ihost, idev,
 				     SCIC_REMOTE_DEVICE_NOT_READY_START_REQUESTED);
@@ -961,7 +952,7 @@ static void sci_stp_remote_device_ready_idle_substate_enter(struct sci_base_stat
 static void sci_stp_remote_device_ready_cmd_substate_enter(struct sci_base_state_machine *sm)
 {
 	struct isci_remote_device *idev = container_of(sm, typeof(*idev), sm);
-	struct isci_host *ihost = sci_remote_device_get_controller(idev);
+	struct isci_host *ihost = idev->owning_port->owning_controller;
 
 	BUG_ON(idev->working_request == NULL);
 
@@ -972,7 +963,7 @@ static void sci_stp_remote_device_ready_cmd_substate_enter(struct sci_base_state
 static void sci_stp_remote_device_ready_ncq_error_substate_enter(struct sci_base_state_machine *sm)
 {
 	struct isci_remote_device *idev = container_of(sm, typeof(*idev), sm);
-	struct isci_host *ihost = sci_remote_device_get_controller(idev);
+	struct isci_host *ihost = idev->owning_port->owning_controller;
 
 	if (idev->not_ready_reason == SCIC_REMOTE_DEVICE_NOT_READY_SATA_SDB_ERROR_FIS_RECEIVED)
 		isci_remote_device_not_ready(ihost, idev,
@@ -982,7 +973,7 @@ static void sci_stp_remote_device_ready_ncq_error_substate_enter(struct sci_base
 static void sci_smp_remote_device_ready_idle_substate_enter(struct sci_base_state_machine *sm)
 {
 	struct isci_remote_device *idev = container_of(sm, typeof(*idev), sm);
-	struct isci_host *ihost = sci_remote_device_get_controller(idev);
+	struct isci_host *ihost = idev->owning_port->owning_controller;
 
 	isci_remote_device_ready(ihost, idev);
 }
@@ -990,7 +981,7 @@ static void sci_smp_remote_device_ready_idle_substate_enter(struct sci_base_stat
 static void sci_smp_remote_device_ready_cmd_substate_enter(struct sci_base_state_machine *sm)
 {
 	struct isci_remote_device *idev = container_of(sm, typeof(*idev), sm);
-	struct isci_host *ihost = sci_remote_device_get_controller(idev);
+	struct isci_host *ihost = idev->owning_port->owning_controller;
 
 	BUG_ON(idev->working_request == NULL);
 

commit 89a7301f21fb00e753089671eb9e4132aab8ea08
Author: Dan Williams <dan.j.williams@intel.com>
Date:   Thu Jun 30 19:14:33 2011 -0700

    isci: retire scic_sds_ and scic_ prefixes
    
    The distinction between scic_sds_ scic_ and sci_ are no longer relevant
    so just unify the prefixes on sci_.  The distinction between isci_ and
    sci_ is historically significant, and useful for comparing the old
    'core' to the current Linux driver. 'sci_' represents the former core as
    well as the routines that are closer to the hardware and protocol than
    their 'isci_' brethren. sci == sas controller interface.
    
    Also unwind the 'sds1' out of the parameter structs.
    
    Reported-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/drivers/scsi/isci/remote_device.c b/drivers/scsi/isci/remote_device.c
index 9043b458c999..8c752abb4331 100644
--- a/drivers/scsi/isci/remote_device.c
+++ b/drivers/scsi/isci/remote_device.c
@@ -68,7 +68,7 @@
  * @isci_host: This parameter specifies the isci host object.
  * @isci_device: This parameter specifies the remote device
  *
- * scic_lock is held on entrance to this function.
+ * sci_lock is held on entrance to this function.
  */
 static void isci_remote_device_not_ready(struct isci_host *ihost,
 				  struct isci_remote_device *idev, u32 reason)
@@ -92,7 +92,7 @@ static void isci_remote_device_not_ready(struct isci_host *ihost,
 				"%s: isci_device = %p request = %p\n",
 				__func__, idev, ireq);
 
-			scic_controller_terminate_request(ihost,
+			sci_controller_terminate_request(ihost,
 							  idev,
 							  ireq);
 		}
@@ -133,7 +133,7 @@ static void rnc_destruct_done(void *_dev)
 	sci_change_state(&idev->sm, SCI_DEV_STOPPED);
 }
 
-static enum sci_status scic_sds_remote_device_terminate_requests(struct isci_remote_device *idev)
+static enum sci_status sci_remote_device_terminate_requests(struct isci_remote_device *idev)
 {
 	struct isci_host *ihost = idev->owning_port->owning_controller;
 	enum sci_status status  = SCI_SUCCESS;
@@ -147,7 +147,7 @@ static enum sci_status scic_sds_remote_device_terminate_requests(struct isci_rem
 		    ireq->target_device != idev)
 			continue;
 
-		s = scic_controller_terminate_request(ihost, idev, ireq);
+		s = sci_controller_terminate_request(ihost, idev, ireq);
 		if (s != SCI_SUCCESS)
 			status = s;
 	}
@@ -155,11 +155,11 @@ static enum sci_status scic_sds_remote_device_terminate_requests(struct isci_rem
 	return status;
 }
 
-enum sci_status scic_remote_device_stop(struct isci_remote_device *idev,
+enum sci_status sci_remote_device_stop(struct isci_remote_device *idev,
 					u32 timeout)
 {
 	struct sci_base_state_machine *sm = &idev->sm;
-	enum scic_sds_remote_device_states state = sm->current_state_id;
+	enum sci_remote_device_states state = sm->current_state_id;
 
 	switch (state) {
 	case SCI_DEV_INITIAL:
@@ -174,7 +174,7 @@ enum sci_status scic_remote_device_stop(struct isci_remote_device *idev,
 	case SCI_DEV_STARTING:
 		/* device not started so there had better be no requests */
 		BUG_ON(idev->started_request_count != 0);
-		scic_sds_remote_node_context_destruct(&idev->rnc,
+		sci_remote_node_context_destruct(&idev->rnc,
 						      rnc_destruct_done, idev);
 		/* Transition to the stopping state and wait for the
 		 * remote node to complete being posted and invalidated.
@@ -191,28 +191,28 @@ enum sci_status scic_remote_device_stop(struct isci_remote_device *idev,
 	case SCI_SMP_DEV_CMD:
 		sci_change_state(sm, SCI_DEV_STOPPING);
 		if (idev->started_request_count == 0) {
-			scic_sds_remote_node_context_destruct(&idev->rnc,
+			sci_remote_node_context_destruct(&idev->rnc,
 							      rnc_destruct_done, idev);
 			return SCI_SUCCESS;
 		} else
-			return scic_sds_remote_device_terminate_requests(idev);
+			return sci_remote_device_terminate_requests(idev);
 		break;
 	case SCI_DEV_STOPPING:
 		/* All requests should have been terminated, but if there is an
 		 * attempt to stop a device already in the stopping state, then
 		 * try again to terminate.
 		 */
-		return scic_sds_remote_device_terminate_requests(idev);
+		return sci_remote_device_terminate_requests(idev);
 	case SCI_DEV_RESETTING:
 		sci_change_state(sm, SCI_DEV_STOPPING);
 		return SCI_SUCCESS;
 	}
 }
 
-enum sci_status scic_remote_device_reset(struct isci_remote_device *idev)
+enum sci_status sci_remote_device_reset(struct isci_remote_device *idev)
 {
 	struct sci_base_state_machine *sm = &idev->sm;
-	enum scic_sds_remote_device_states state = sm->current_state_id;
+	enum sci_remote_device_states state = sm->current_state_id;
 
 	switch (state) {
 	case SCI_DEV_INITIAL:
@@ -239,10 +239,10 @@ enum sci_status scic_remote_device_reset(struct isci_remote_device *idev)
 	}
 }
 
-enum sci_status scic_remote_device_reset_complete(struct isci_remote_device *idev)
+enum sci_status sci_remote_device_reset_complete(struct isci_remote_device *idev)
 {
 	struct sci_base_state_machine *sm = &idev->sm;
-	enum scic_sds_remote_device_states state = sm->current_state_id;
+	enum sci_remote_device_states state = sm->current_state_id;
 
 	if (state != SCI_DEV_RESETTING) {
 		dev_warn(scirdev_to_dev(idev), "%s: in wrong state: %d\n",
@@ -254,11 +254,11 @@ enum sci_status scic_remote_device_reset_complete(struct isci_remote_device *ide
 	return SCI_SUCCESS;
 }
 
-enum sci_status scic_sds_remote_device_suspend(struct isci_remote_device *idev,
+enum sci_status sci_remote_device_suspend(struct isci_remote_device *idev,
 					       u32 suspend_type)
 {
 	struct sci_base_state_machine *sm = &idev->sm;
-	enum scic_sds_remote_device_states state = sm->current_state_id;
+	enum sci_remote_device_states state = sm->current_state_id;
 
 	if (state != SCI_STP_DEV_CMD) {
 		dev_warn(scirdev_to_dev(idev), "%s: in wrong state: %d\n",
@@ -266,15 +266,15 @@ enum sci_status scic_sds_remote_device_suspend(struct isci_remote_device *idev,
 		return SCI_FAILURE_INVALID_STATE;
 	}
 
-	return scic_sds_remote_node_context_suspend(&idev->rnc,
+	return sci_remote_node_context_suspend(&idev->rnc,
 						    suspend_type, NULL, NULL);
 }
 
-enum sci_status scic_sds_remote_device_frame_handler(struct isci_remote_device *idev,
+enum sci_status sci_remote_device_frame_handler(struct isci_remote_device *idev,
 						     u32 frame_index)
 {
 	struct sci_base_state_machine *sm = &idev->sm;
-	enum scic_sds_remote_device_states state = sm->current_state_id;
+	enum sci_remote_device_states state = sm->current_state_id;
 	struct isci_host *ihost = idev->owning_port->owning_controller;
 	enum sci_status status;
 
@@ -289,7 +289,7 @@ enum sci_status scic_sds_remote_device_frame_handler(struct isci_remote_device *
 		dev_warn(scirdev_to_dev(idev), "%s: in wrong state: %d\n",
 			 __func__, state);
 		/* Return the frame back to the controller */
-		scic_sds_controller_release_frame(ihost, frame_index);
+		sci_controller_release_frame(ihost, frame_index);
 		return SCI_FAILURE_INVALID_STATE;
 	case SCI_DEV_READY:
 	case SCI_STP_DEV_NCQ_ERROR:
@@ -302,7 +302,7 @@ enum sci_status scic_sds_remote_device_frame_handler(struct isci_remote_device *
 		void *frame_header;
 		ssize_t word_cnt;
 
-		status = scic_sds_unsolicited_frame_control_get_header(&ihost->uf_control,
+		status = sci_unsolicited_frame_control_get_header(&ihost->uf_control,
 								       frame_index,
 								       &frame_header);
 		if (status != SCI_SUCCESS)
@@ -311,22 +311,22 @@ enum sci_status scic_sds_remote_device_frame_handler(struct isci_remote_device *
 		word_cnt = sizeof(hdr) / sizeof(u32);
 		sci_swab32_cpy(&hdr, frame_header, word_cnt);
 
-		ireq = scic_request_by_tag(ihost, be16_to_cpu(hdr.tag));
+		ireq = sci_request_by_tag(ihost, be16_to_cpu(hdr.tag));
 		if (ireq && ireq->target_device == idev) {
 			/* The IO request is now in charge of releasing the frame */
-			status = scic_sds_io_request_frame_handler(ireq, frame_index);
+			status = sci_io_request_frame_handler(ireq, frame_index);
 		} else {
 			/* We could not map this tag to a valid IO
 			 * request Just toss the frame and continue
 			 */
-			scic_sds_controller_release_frame(ihost, frame_index);
+			sci_controller_release_frame(ihost, frame_index);
 		}
 		break;
 	}
 	case SCI_STP_DEV_NCQ: {
 		struct dev_to_host_fis *hdr;
 
-		status = scic_sds_unsolicited_frame_control_get_header(&ihost->uf_control,
+		status = sci_unsolicited_frame_control_get_header(&ihost->uf_control,
 								       frame_index,
 								       (void **)&hdr);
 		if (status != SCI_SUCCESS)
@@ -349,7 +349,7 @@ enum sci_status scic_sds_remote_device_frame_handler(struct isci_remote_device *
 		} else
 			status = SCI_FAILURE;
 
-		scic_sds_controller_release_frame(ihost, frame_index);
+		sci_controller_release_frame(ihost, frame_index);
 		break;
 	}
 	case SCI_STP_DEV_CMD:
@@ -358,7 +358,7 @@ enum sci_status scic_sds_remote_device_frame_handler(struct isci_remote_device *
 		 * in this state.  All unsolicited frames are forwarded to the io request
 		 * object.
 		 */
-		status = scic_sds_io_request_frame_handler(idev->working_request, frame_index);
+		status = sci_io_request_frame_handler(idev->working_request, frame_index);
 		break;
 	}
 
@@ -369,7 +369,7 @@ static bool is_remote_device_ready(struct isci_remote_device *idev)
 {
 
 	struct sci_base_state_machine *sm = &idev->sm;
-	enum scic_sds_remote_device_states state = sm->current_state_id;
+	enum sci_remote_device_states state = sm->current_state_id;
 
 	switch (state) {
 	case SCI_DEV_READY:
@@ -386,25 +386,25 @@ static bool is_remote_device_ready(struct isci_remote_device *idev)
 	}
 }
 
-enum sci_status scic_sds_remote_device_event_handler(struct isci_remote_device *idev,
+enum sci_status sci_remote_device_event_handler(struct isci_remote_device *idev,
 						     u32 event_code)
 {
 	struct sci_base_state_machine *sm = &idev->sm;
-	enum scic_sds_remote_device_states state = sm->current_state_id;
+	enum sci_remote_device_states state = sm->current_state_id;
 	enum sci_status status;
 
 	switch (scu_get_event_type(event_code)) {
 	case SCU_EVENT_TYPE_RNC_OPS_MISC:
 	case SCU_EVENT_TYPE_RNC_SUSPEND_TX:
 	case SCU_EVENT_TYPE_RNC_SUSPEND_TX_RX:
-		status = scic_sds_remote_node_context_event_handler(&idev->rnc, event_code);
+		status = sci_remote_node_context_event_handler(&idev->rnc, event_code);
 		break;
 	case SCU_EVENT_TYPE_PTX_SCHEDULE_EVENT:
 		if (scu_get_event_code(event_code) == SCU_EVENT_IT_NEXUS_TIMEOUT) {
 			status = SCI_SUCCESS;
 
 			/* Suspend the associated RNC */
-			scic_sds_remote_node_context_suspend(&idev->rnc,
+			sci_remote_node_context_suspend(&idev->rnc,
 							      SCI_SOFTWARE_SUSPENSION,
 							      NULL, NULL);
 
@@ -439,13 +439,13 @@ enum sci_status scic_sds_remote_device_event_handler(struct isci_remote_device *
 		 */
 		if (scu_get_event_type(event_code) == SCU_EVENT_TYPE_RNC_SUSPEND_TX ||
 		    scu_get_event_type(event_code) == SCU_EVENT_TYPE_RNC_SUSPEND_TX_RX)
-			status = scic_sds_remote_node_context_resume(&idev->rnc, NULL, NULL);
+			status = sci_remote_node_context_resume(&idev->rnc, NULL, NULL);
 	}
 
 	return status;
 }
 
-static void scic_sds_remote_device_start_request(struct isci_remote_device *idev,
+static void sci_remote_device_start_request(struct isci_remote_device *idev,
 						 struct isci_request *ireq,
 						 enum sci_status status)
 {
@@ -453,19 +453,19 @@ static void scic_sds_remote_device_start_request(struct isci_remote_device *idev
 
 	/* cleanup requests that failed after starting on the port */
 	if (status != SCI_SUCCESS)
-		scic_sds_port_complete_io(iport, idev, ireq);
+		sci_port_complete_io(iport, idev, ireq);
 	else {
 		kref_get(&idev->kref);
-		scic_sds_remote_device_increment_request_count(idev);
+		sci_remote_device_increment_request_count(idev);
 	}
 }
 
-enum sci_status scic_sds_remote_device_start_io(struct isci_host *ihost,
+enum sci_status sci_remote_device_start_io(struct isci_host *ihost,
 						struct isci_remote_device *idev,
 						struct isci_request *ireq)
 {
 	struct sci_base_state_machine *sm = &idev->sm;
-	enum scic_sds_remote_device_states state = sm->current_state_id;
+	enum sci_remote_device_states state = sm->current_state_id;
 	struct isci_port *iport = idev->owning_port;
 	enum sci_status status;
 
@@ -488,15 +488,15 @@ enum sci_status scic_sds_remote_device_start_io(struct isci_host *ihost,
 		 * successful it will start the request for the port object then
 		 * increment its own request count.
 		 */
-		status = scic_sds_port_start_io(iport, idev, ireq);
+		status = sci_port_start_io(iport, idev, ireq);
 		if (status != SCI_SUCCESS)
 			return status;
 
-		status = scic_sds_remote_node_context_start_io(&idev->rnc, ireq);
+		status = sci_remote_node_context_start_io(&idev->rnc, ireq);
 		if (status != SCI_SUCCESS)
 			break;
 
-		status = scic_sds_request_start(ireq);
+		status = sci_request_start(ireq);
 		break;
 	case SCI_STP_DEV_IDLE: {
 		/* handle the start io operation for a sata device that is in
@@ -507,18 +507,18 @@ enum sci_status scic_sds_remote_device_start_io(struct isci_host *ihost,
 		 * If this is a softreset we may want to have a different
 		 * substate.
 		 */
-		enum scic_sds_remote_device_states new_state;
+		enum sci_remote_device_states new_state;
 		struct sas_task *task = isci_request_access_task(ireq);
 
-		status = scic_sds_port_start_io(iport, idev, ireq);
+		status = sci_port_start_io(iport, idev, ireq);
 		if (status != SCI_SUCCESS)
 			return status;
 
-		status = scic_sds_remote_node_context_start_io(&idev->rnc, ireq);
+		status = sci_remote_node_context_start_io(&idev->rnc, ireq);
 		if (status != SCI_SUCCESS)
 			break;
 
-		status = scic_sds_request_start(ireq);
+		status = sci_request_start(ireq);
 		if (status != SCI_SUCCESS)
 			break;
 
@@ -535,15 +535,15 @@ enum sci_status scic_sds_remote_device_start_io(struct isci_host *ihost,
 		struct sas_task *task = isci_request_access_task(ireq);
 
 		if (task->ata_task.use_ncq) {
-			status = scic_sds_port_start_io(iport, idev, ireq);
+			status = sci_port_start_io(iport, idev, ireq);
 			if (status != SCI_SUCCESS)
 				return status;
 
-			status = scic_sds_remote_node_context_start_io(&idev->rnc, ireq);
+			status = sci_remote_node_context_start_io(&idev->rnc, ireq);
 			if (status != SCI_SUCCESS)
 				break;
 
-			status = scic_sds_request_start(ireq);
+			status = sci_request_start(ireq);
 		} else
 			return SCI_FAILURE_INVALID_STATE;
 		break;
@@ -551,15 +551,15 @@ enum sci_status scic_sds_remote_device_start_io(struct isci_host *ihost,
 	case SCI_STP_DEV_AWAIT_RESET:
 		return SCI_FAILURE_REMOTE_DEVICE_RESET_REQUIRED;
 	case SCI_SMP_DEV_IDLE:
-		status = scic_sds_port_start_io(iport, idev, ireq);
+		status = sci_port_start_io(iport, idev, ireq);
 		if (status != SCI_SUCCESS)
 			return status;
 
-		status = scic_sds_remote_node_context_start_io(&idev->rnc, ireq);
+		status = sci_remote_node_context_start_io(&idev->rnc, ireq);
 		if (status != SCI_SUCCESS)
 			break;
 
-		status = scic_sds_request_start(ireq);
+		status = sci_request_start(ireq);
 		if (status != SCI_SUCCESS)
 			break;
 
@@ -574,7 +574,7 @@ enum sci_status scic_sds_remote_device_start_io(struct isci_host *ihost,
 		return SCI_FAILURE_INVALID_STATE;
 	}
 
-	scic_sds_remote_device_start_request(idev, ireq, status);
+	sci_remote_device_start_request(idev, ireq, status);
 	return status;
 }
 
@@ -584,24 +584,24 @@ static enum sci_status common_complete_io(struct isci_port *iport,
 {
 	enum sci_status status;
 
-	status = scic_sds_request_complete(ireq);
+	status = sci_request_complete(ireq);
 	if (status != SCI_SUCCESS)
 		return status;
 
-	status = scic_sds_port_complete_io(iport, idev, ireq);
+	status = sci_port_complete_io(iport, idev, ireq);
 	if (status != SCI_SUCCESS)
 		return status;
 
-	scic_sds_remote_device_decrement_request_count(idev);
+	sci_remote_device_decrement_request_count(idev);
 	return status;
 }
 
-enum sci_status scic_sds_remote_device_complete_io(struct isci_host *ihost,
+enum sci_status sci_remote_device_complete_io(struct isci_host *ihost,
 						   struct isci_remote_device *idev,
 						   struct isci_request *ireq)
 {
 	struct sci_base_state_machine *sm = &idev->sm;
-	enum scic_sds_remote_device_states state = sm->current_state_id;
+	enum sci_remote_device_states state = sm->current_state_id;
 	struct isci_port *iport = idev->owning_port;
 	enum sci_status status;
 
@@ -636,7 +636,7 @@ enum sci_status scic_sds_remote_device_complete_io(struct isci_host *ihost,
 			 * status of "DEVICE_RESET_REQUIRED", instead of "INVALID STATE".
 			 */
 			sci_change_state(sm, SCI_STP_DEV_AWAIT_RESET);
-		} else if (scic_sds_remote_device_get_request_count(idev) == 0)
+		} else if (sci_remote_device_get_request_count(idev) == 0)
 			sci_change_state(sm, SCI_STP_DEV_IDLE);
 		break;
 	case SCI_SMP_DEV_CMD:
@@ -650,8 +650,8 @@ enum sci_status scic_sds_remote_device_complete_io(struct isci_host *ihost,
 		if (status != SCI_SUCCESS)
 			break;
 
-		if (scic_sds_remote_device_get_request_count(idev) == 0)
-			scic_sds_remote_node_context_destruct(&idev->rnc,
+		if (sci_remote_device_get_request_count(idev) == 0)
+			sci_remote_node_context_destruct(&idev->rnc,
 							      rnc_destruct_done,
 							      idev);
 		break;
@@ -668,21 +668,21 @@ enum sci_status scic_sds_remote_device_complete_io(struct isci_host *ihost,
 	return status;
 }
 
-static void scic_sds_remote_device_continue_request(void *dev)
+static void sci_remote_device_continue_request(void *dev)
 {
 	struct isci_remote_device *idev = dev;
 
 	/* we need to check if this request is still valid to continue. */
 	if (idev->working_request)
-		scic_controller_continue_io(idev->working_request);
+		sci_controller_continue_io(idev->working_request);
 }
 
-enum sci_status scic_sds_remote_device_start_task(struct isci_host *ihost,
+enum sci_status sci_remote_device_start_task(struct isci_host *ihost,
 						  struct isci_remote_device *idev,
 						  struct isci_request *ireq)
 {
 	struct sci_base_state_machine *sm = &idev->sm;
-	enum scic_sds_remote_device_states state = sm->current_state_id;
+	enum sci_remote_device_states state = sm->current_state_id;
 	struct isci_port *iport = idev->owning_port;
 	enum sci_status status;
 
@@ -705,15 +705,15 @@ enum sci_status scic_sds_remote_device_start_task(struct isci_host *ihost,
 	case SCI_STP_DEV_NCQ:
 	case SCI_STP_DEV_NCQ_ERROR:
 	case SCI_STP_DEV_AWAIT_RESET:
-		status = scic_sds_port_start_io(iport, idev, ireq);
+		status = sci_port_start_io(iport, idev, ireq);
 		if (status != SCI_SUCCESS)
 			return status;
 
-		status = scic_sds_remote_node_context_start_task(&idev->rnc, ireq);
+		status = sci_remote_node_context_start_task(&idev->rnc, ireq);
 		if (status != SCI_SUCCESS)
 			goto out;
 
-		status = scic_sds_request_start(ireq);
+		status = sci_request_start(ireq);
 		if (status != SCI_SUCCESS)
 			goto out;
 
@@ -731,32 +731,32 @@ enum sci_status scic_sds_remote_device_start_task(struct isci_host *ihost,
 		 * the correct action when the remote node context is suspended
 		 * and later resumed.
 		 */
-		scic_sds_remote_node_context_suspend(&idev->rnc,
+		sci_remote_node_context_suspend(&idev->rnc,
 				SCI_SOFTWARE_SUSPENSION, NULL, NULL);
-		scic_sds_remote_node_context_resume(&idev->rnc,
-				scic_sds_remote_device_continue_request,
+		sci_remote_node_context_resume(&idev->rnc,
+				sci_remote_device_continue_request,
 						    idev);
 
 	out:
-		scic_sds_remote_device_start_request(idev, ireq, status);
+		sci_remote_device_start_request(idev, ireq, status);
 		/* We need to let the controller start request handler know that
 		 * it can't post TC yet. We will provide a callback function to
 		 * post TC when RNC gets resumed.
 		 */
 		return SCI_FAILURE_RESET_DEVICE_PARTIAL_SUCCESS;
 	case SCI_DEV_READY:
-		status = scic_sds_port_start_io(iport, idev, ireq);
+		status = sci_port_start_io(iport, idev, ireq);
 		if (status != SCI_SUCCESS)
 			return status;
 
-		status = scic_sds_remote_node_context_start_task(&idev->rnc, ireq);
+		status = sci_remote_node_context_start_task(&idev->rnc, ireq);
 		if (status != SCI_SUCCESS)
 			break;
 
-		status = scic_sds_request_start(ireq);
+		status = sci_request_start(ireq);
 		break;
 	}
-	scic_sds_remote_device_start_request(idev, ireq, status);
+	sci_remote_device_start_request(idev, ireq, status);
 
 	return status;
 }
@@ -769,16 +769,16 @@ enum sci_status scic_sds_remote_device_start_task(struct isci_host *ihost,
  * This method takes the request and bulids an appropriate SCU context for the
  * request and then requests the controller to post the request. none
  */
-void scic_sds_remote_device_post_request(
+void sci_remote_device_post_request(
 	struct isci_remote_device *idev,
 	u32 request)
 {
 	u32 context;
 
-	context = scic_sds_remote_device_build_command_context(idev, request);
+	context = sci_remote_device_build_command_context(idev, request);
 
-	scic_sds_controller_post_request(
-		scic_sds_remote_device_get_controller(idev),
+	sci_controller_post_request(
+		sci_remote_device_get_controller(idev),
 		context
 		);
 }
@@ -798,7 +798,7 @@ static void remote_device_resume_done(void *_dev)
 	sci_change_state(&idev->sm, SCI_DEV_READY);
 }
 
-static void scic_sds_stp_remote_device_ready_idle_substate_resume_complete_handler(void *_dev)
+static void sci_stp_remote_device_ready_idle_substate_resume_complete_handler(void *_dev)
 {
 	struct isci_remote_device *idev = _dev;
 	struct isci_host *ihost = idev->owning_port->owning_controller;
@@ -810,7 +810,7 @@ static void scic_sds_stp_remote_device_ready_idle_substate_resume_complete_handl
 		isci_remote_device_ready(ihost, idev);
 }
 
-static void scic_sds_remote_device_initial_state_enter(struct sci_base_state_machine *sm)
+static void sci_remote_device_initial_state_enter(struct sci_base_state_machine *sm)
 {
 	struct isci_remote_device *idev = container_of(sm, typeof(*idev), sm);
 
@@ -819,7 +819,7 @@ static void scic_sds_remote_device_initial_state_enter(struct sci_base_state_mac
 }
 
 /**
- * scic_remote_device_destruct() - free remote node context and destruct
+ * sci_remote_device_destruct() - free remote node context and destruct
  * @remote_device: This parameter specifies the remote device to be destructed.
  *
  * Remote device objects are a limited resource.  As such, they must be
@@ -831,10 +831,10 @@ static void scic_sds_remote_device_initial_state_enter(struct sci_base_state_mac
  * device isn't valid (e.g. it's already been destoryed, the handle isn't
  * valid, etc.).
  */
-static enum sci_status scic_remote_device_destruct(struct isci_remote_device *idev)
+static enum sci_status sci_remote_device_destruct(struct isci_remote_device *idev)
 {
 	struct sci_base_state_machine *sm = &idev->sm;
-	enum scic_sds_remote_device_states state = sm->current_state_id;
+	enum sci_remote_device_states state = sm->current_state_id;
 	struct isci_host *ihost;
 
 	if (state != SCI_DEV_STOPPED) {
@@ -844,7 +844,7 @@ static enum sci_status scic_remote_device_destruct(struct isci_remote_device *id
 	}
 
 	ihost = idev->owning_port->owning_controller;
-	scic_sds_controller_free_remote_node_context(ihost, idev,
+	sci_controller_free_remote_node_context(ihost, idev,
 						     idev->rnc.remote_node_index);
 	idev->rnc.remote_node_index = SCIC_SDS_REMOTE_NODE_CONTEXT_INVALID_INDEX;
 	sci_change_state(sm, SCI_DEV_FINAL);
@@ -869,12 +869,12 @@ static void isci_remote_device_deconstruct(struct isci_host *ihost, struct isci_
 	 * io requests in process */
 	BUG_ON(!list_empty(&idev->reqs_in_process));
 
-	scic_remote_device_destruct(idev);
+	sci_remote_device_destruct(idev);
 	list_del_init(&idev->node);
 	isci_put_device(idev);
 }
 
-static void scic_sds_remote_device_stopped_state_enter(struct sci_base_state_machine *sm)
+static void sci_remote_device_stopped_state_enter(struct sci_base_state_machine *sm)
 {
 	struct isci_remote_device *idev = container_of(sm, typeof(*idev), sm);
 	struct isci_host *ihost = idev->owning_port->owning_controller;
@@ -887,19 +887,19 @@ static void scic_sds_remote_device_stopped_state_enter(struct sci_base_state_mac
 	if (prev_state == SCI_DEV_STOPPING)
 		isci_remote_device_deconstruct(ihost, idev);
 
-	scic_sds_controller_remote_device_stopped(ihost, idev);
+	sci_controller_remote_device_stopped(ihost, idev);
 }
 
-static void scic_sds_remote_device_starting_state_enter(struct sci_base_state_machine *sm)
+static void sci_remote_device_starting_state_enter(struct sci_base_state_machine *sm)
 {
 	struct isci_remote_device *idev = container_of(sm, typeof(*idev), sm);
-	struct isci_host *ihost = scic_sds_remote_device_get_controller(idev);
+	struct isci_host *ihost = sci_remote_device_get_controller(idev);
 
 	isci_remote_device_not_ready(ihost, idev,
 				     SCIC_REMOTE_DEVICE_NOT_READY_START_REQUESTED);
 }
 
-static void scic_sds_remote_device_ready_state_enter(struct sci_base_state_machine *sm)
+static void sci_remote_device_ready_state_enter(struct sci_base_state_machine *sm)
 {
 	struct isci_remote_device *idev = container_of(sm, typeof(*idev), sm);
 	struct isci_host *ihost = idev->owning_port->owning_controller;
@@ -913,7 +913,7 @@ static void scic_sds_remote_device_ready_state_enter(struct sci_base_state_machi
 		isci_remote_device_ready(ihost, idev);
 }
 
-static void scic_sds_remote_device_ready_state_exit(struct sci_base_state_machine *sm)
+static void sci_remote_device_ready_state_exit(struct sci_base_state_machine *sm)
 {
 	struct isci_remote_device *idev = container_of(sm, typeof(*idev), sm);
 	struct domain_device *dev = idev->domain_dev;
@@ -926,42 +926,42 @@ static void scic_sds_remote_device_ready_state_exit(struct sci_base_state_machin
 	}
 }
 
-static void scic_sds_remote_device_resetting_state_enter(struct sci_base_state_machine *sm)
+static void sci_remote_device_resetting_state_enter(struct sci_base_state_machine *sm)
 {
 	struct isci_remote_device *idev = container_of(sm, typeof(*idev), sm);
 
-	scic_sds_remote_node_context_suspend(
+	sci_remote_node_context_suspend(
 		&idev->rnc, SCI_SOFTWARE_SUSPENSION, NULL, NULL);
 }
 
-static void scic_sds_remote_device_resetting_state_exit(struct sci_base_state_machine *sm)
+static void sci_remote_device_resetting_state_exit(struct sci_base_state_machine *sm)
 {
 	struct isci_remote_device *idev = container_of(sm, typeof(*idev), sm);
 
-	scic_sds_remote_node_context_resume(&idev->rnc, NULL, NULL);
+	sci_remote_node_context_resume(&idev->rnc, NULL, NULL);
 }
 
-static void scic_sds_stp_remote_device_ready_idle_substate_enter(struct sci_base_state_machine *sm)
+static void sci_stp_remote_device_ready_idle_substate_enter(struct sci_base_state_machine *sm)
 {
 	struct isci_remote_device *idev = container_of(sm, typeof(*idev), sm);
 
 	idev->working_request = NULL;
-	if (scic_sds_remote_node_context_is_ready(&idev->rnc)) {
+	if (sci_remote_node_context_is_ready(&idev->rnc)) {
 		/*
 		 * Since the RNC is ready, it's alright to finish completion
 		 * processing (e.g. signal the remote device is ready). */
-		scic_sds_stp_remote_device_ready_idle_substate_resume_complete_handler(idev);
+		sci_stp_remote_device_ready_idle_substate_resume_complete_handler(idev);
 	} else {
-		scic_sds_remote_node_context_resume(&idev->rnc,
-			scic_sds_stp_remote_device_ready_idle_substate_resume_complete_handler,
+		sci_remote_node_context_resume(&idev->rnc,
+			sci_stp_remote_device_ready_idle_substate_resume_complete_handler,
 			idev);
 	}
 }
 
-static void scic_sds_stp_remote_device_ready_cmd_substate_enter(struct sci_base_state_machine *sm)
+static void sci_stp_remote_device_ready_cmd_substate_enter(struct sci_base_state_machine *sm)
 {
 	struct isci_remote_device *idev = container_of(sm, typeof(*idev), sm);
-	struct isci_host *ihost = scic_sds_remote_device_get_controller(idev);
+	struct isci_host *ihost = sci_remote_device_get_controller(idev);
 
 	BUG_ON(idev->working_request == NULL);
 
@@ -969,28 +969,28 @@ static void scic_sds_stp_remote_device_ready_cmd_substate_enter(struct sci_base_
 				     SCIC_REMOTE_DEVICE_NOT_READY_SATA_REQUEST_STARTED);
 }
 
-static void scic_sds_stp_remote_device_ready_ncq_error_substate_enter(struct sci_base_state_machine *sm)
+static void sci_stp_remote_device_ready_ncq_error_substate_enter(struct sci_base_state_machine *sm)
 {
 	struct isci_remote_device *idev = container_of(sm, typeof(*idev), sm);
-	struct isci_host *ihost = scic_sds_remote_device_get_controller(idev);
+	struct isci_host *ihost = sci_remote_device_get_controller(idev);
 
 	if (idev->not_ready_reason == SCIC_REMOTE_DEVICE_NOT_READY_SATA_SDB_ERROR_FIS_RECEIVED)
 		isci_remote_device_not_ready(ihost, idev,
 					     idev->not_ready_reason);
 }
 
-static void scic_sds_smp_remote_device_ready_idle_substate_enter(struct sci_base_state_machine *sm)
+static void sci_smp_remote_device_ready_idle_substate_enter(struct sci_base_state_machine *sm)
 {
 	struct isci_remote_device *idev = container_of(sm, typeof(*idev), sm);
-	struct isci_host *ihost = scic_sds_remote_device_get_controller(idev);
+	struct isci_host *ihost = sci_remote_device_get_controller(idev);
 
 	isci_remote_device_ready(ihost, idev);
 }
 
-static void scic_sds_smp_remote_device_ready_cmd_substate_enter(struct sci_base_state_machine *sm)
+static void sci_smp_remote_device_ready_cmd_substate_enter(struct sci_base_state_machine *sm)
 {
 	struct isci_remote_device *idev = container_of(sm, typeof(*idev), sm);
-	struct isci_host *ihost = scic_sds_remote_device_get_controller(idev);
+	struct isci_host *ihost = sci_remote_device_get_controller(idev);
 
 	BUG_ON(idev->working_request == NULL);
 
@@ -998,83 +998,83 @@ static void scic_sds_smp_remote_device_ready_cmd_substate_enter(struct sci_base_
 				     SCIC_REMOTE_DEVICE_NOT_READY_SMP_REQUEST_STARTED);
 }
 
-static void scic_sds_smp_remote_device_ready_cmd_substate_exit(struct sci_base_state_machine *sm)
+static void sci_smp_remote_device_ready_cmd_substate_exit(struct sci_base_state_machine *sm)
 {
 	struct isci_remote_device *idev = container_of(sm, typeof(*idev), sm);
 
 	idev->working_request = NULL;
 }
 
-static const struct sci_base_state scic_sds_remote_device_state_table[] = {
+static const struct sci_base_state sci_remote_device_state_table[] = {
 	[SCI_DEV_INITIAL] = {
-		.enter_state = scic_sds_remote_device_initial_state_enter,
+		.enter_state = sci_remote_device_initial_state_enter,
 	},
 	[SCI_DEV_STOPPED] = {
-		.enter_state = scic_sds_remote_device_stopped_state_enter,
+		.enter_state = sci_remote_device_stopped_state_enter,
 	},
 	[SCI_DEV_STARTING] = {
-		.enter_state = scic_sds_remote_device_starting_state_enter,
+		.enter_state = sci_remote_device_starting_state_enter,
 	},
 	[SCI_DEV_READY] = {
-		.enter_state = scic_sds_remote_device_ready_state_enter,
-		.exit_state  = scic_sds_remote_device_ready_state_exit
+		.enter_state = sci_remote_device_ready_state_enter,
+		.exit_state  = sci_remote_device_ready_state_exit
 	},
 	[SCI_STP_DEV_IDLE] = {
-		.enter_state = scic_sds_stp_remote_device_ready_idle_substate_enter,
+		.enter_state = sci_stp_remote_device_ready_idle_substate_enter,
 	},
 	[SCI_STP_DEV_CMD] = {
-		.enter_state = scic_sds_stp_remote_device_ready_cmd_substate_enter,
+		.enter_state = sci_stp_remote_device_ready_cmd_substate_enter,
 	},
 	[SCI_STP_DEV_NCQ] = { },
 	[SCI_STP_DEV_NCQ_ERROR] = {
-		.enter_state = scic_sds_stp_remote_device_ready_ncq_error_substate_enter,
+		.enter_state = sci_stp_remote_device_ready_ncq_error_substate_enter,
 	},
 	[SCI_STP_DEV_AWAIT_RESET] = { },
 	[SCI_SMP_DEV_IDLE] = {
-		.enter_state = scic_sds_smp_remote_device_ready_idle_substate_enter,
+		.enter_state = sci_smp_remote_device_ready_idle_substate_enter,
 	},
 	[SCI_SMP_DEV_CMD] = {
-		.enter_state = scic_sds_smp_remote_device_ready_cmd_substate_enter,
-		.exit_state  = scic_sds_smp_remote_device_ready_cmd_substate_exit,
+		.enter_state = sci_smp_remote_device_ready_cmd_substate_enter,
+		.exit_state  = sci_smp_remote_device_ready_cmd_substate_exit,
 	},
 	[SCI_DEV_STOPPING] = { },
 	[SCI_DEV_FAILED] = { },
 	[SCI_DEV_RESETTING] = {
-		.enter_state = scic_sds_remote_device_resetting_state_enter,
-		.exit_state  = scic_sds_remote_device_resetting_state_exit
+		.enter_state = sci_remote_device_resetting_state_enter,
+		.exit_state  = sci_remote_device_resetting_state_exit
 	},
 	[SCI_DEV_FINAL] = { },
 };
 
 /**
- * scic_remote_device_construct() - common construction
+ * sci_remote_device_construct() - common construction
  * @sci_port: SAS/SATA port through which this device is accessed.
  * @sci_dev: remote device to construct
  *
  * This routine just performs benign initialization and does not
  * allocate the remote_node_context which is left to
- * scic_remote_device_[de]a_construct().  scic_remote_device_destruct()
+ * sci_remote_device_[de]a_construct().  sci_remote_device_destruct()
  * frees the remote_node_context(s) for the device.
  */
-static void scic_remote_device_construct(struct isci_port *iport,
+static void sci_remote_device_construct(struct isci_port *iport,
 				  struct isci_remote_device *idev)
 {
 	idev->owning_port = iport;
 	idev->started_request_count = 0;
 
-	sci_init_sm(&idev->sm, scic_sds_remote_device_state_table, SCI_DEV_INITIAL);
+	sci_init_sm(&idev->sm, sci_remote_device_state_table, SCI_DEV_INITIAL);
 
-	scic_sds_remote_node_context_construct(&idev->rnc,
+	sci_remote_node_context_construct(&idev->rnc,
 					       SCIC_SDS_REMOTE_NODE_CONTEXT_INVALID_INDEX);
 }
 
 /**
- * scic_remote_device_da_construct() - construct direct attached device.
+ * sci_remote_device_da_construct() - construct direct attached device.
  *
  * The information (e.g. IAF, Signature FIS, etc.) necessary to build
  * the device is known to the SCI Core since it is contained in the
- * scic_phy object.  Remote node context(s) is/are a global resource
- * allocated by this routine, freed by scic_remote_device_destruct().
+ * sci_phy object.  Remote node context(s) is/are a global resource
+ * allocated by this routine, freed by sci_remote_device_destruct().
  *
  * Returns:
  * SCI_FAILURE_DEVICE_EXISTS - device has already been constructed.
@@ -1082,20 +1082,20 @@ static void scic_remote_device_construct(struct isci_port *iport,
  * sata-only controller instance.
  * SCI_FAILURE_INSUFFICIENT_RESOURCES - remote node contexts exhausted.
  */
-static enum sci_status scic_remote_device_da_construct(struct isci_port *iport,
+static enum sci_status sci_remote_device_da_construct(struct isci_port *iport,
 						       struct isci_remote_device *idev)
 {
 	enum sci_status status;
 	struct domain_device *dev = idev->domain_dev;
 
-	scic_remote_device_construct(iport, idev);
+	sci_remote_device_construct(iport, idev);
 
 	/*
 	 * This information is request to determine how many remote node context
 	 * entries will be needed to store the remote node.
 	 */
 	idev->is_direct_attached = true;
-	status = scic_sds_controller_allocate_remote_node_context(iport->owning_controller,
+	status = sci_controller_allocate_remote_node_context(iport->owning_controller,
 								  idev,
 								  &idev->rnc.remote_node_index);
 
@@ -1108,7 +1108,7 @@ static enum sci_status scic_remote_device_da_construct(struct isci_port *iport,
 	else
 		return SCI_FAILURE_UNSUPPORTED_PROTOCOL;
 
-	idev->connection_rate = scic_sds_port_get_max_allowed_speed(iport);
+	idev->connection_rate = sci_port_get_max_allowed_speed(iport);
 
 	/* / @todo Should I assign the port width by reading all of the phys on the port? */
 	idev->device_port_width = 1;
@@ -1117,10 +1117,10 @@ static enum sci_status scic_remote_device_da_construct(struct isci_port *iport,
 }
 
 /**
- * scic_remote_device_ea_construct() - construct expander attached device
+ * sci_remote_device_ea_construct() - construct expander attached device
  *
  * Remote node context(s) is/are a global resource allocated by this
- * routine, freed by scic_remote_device_destruct().
+ * routine, freed by sci_remote_device_destruct().
  *
  * Returns:
  * SCI_FAILURE_DEVICE_EXISTS - device has already been constructed.
@@ -1128,15 +1128,15 @@ static enum sci_status scic_remote_device_da_construct(struct isci_port *iport,
  * sata-only controller instance.
  * SCI_FAILURE_INSUFFICIENT_RESOURCES - remote node contexts exhausted.
  */
-static enum sci_status scic_remote_device_ea_construct(struct isci_port *iport,
+static enum sci_status sci_remote_device_ea_construct(struct isci_port *iport,
 						       struct isci_remote_device *idev)
 {
 	struct domain_device *dev = idev->domain_dev;
 	enum sci_status status;
 
-	scic_remote_device_construct(iport, idev);
+	sci_remote_device_construct(iport, idev);
 
-	status = scic_sds_controller_allocate_remote_node_context(iport->owning_controller,
+	status = sci_controller_allocate_remote_node_context(iport->owning_controller,
 								  idev,
 								  &idev->rnc.remote_node_index);
 	if (status != SCI_SUCCESS)
@@ -1155,7 +1155,7 @@ static enum sci_status scic_remote_device_ea_construct(struct isci_port *iport,
 	 * connection the logical link rate is that same as the
 	 * physical.  Furthermore, the SAS-2 and SAS-1.1 fields overlay
 	 * one another, so this code works for both situations. */
-	idev->connection_rate = min_t(u16, scic_sds_port_get_max_allowed_speed(iport),
+	idev->connection_rate = min_t(u16, sci_port_get_max_allowed_speed(iport),
 					 dev->linkrate);
 
 	/* / @todo Should I assign the port width by reading all of the phys on the port? */
@@ -1165,7 +1165,7 @@ static enum sci_status scic_remote_device_ea_construct(struct isci_port *iport,
 }
 
 /**
- * scic_remote_device_start() - This method will start the supplied remote
+ * sci_remote_device_start() - This method will start the supplied remote
  *    device.  This method enables normal IO requests to flow through to the
  *    remote device.
  * @remote_device: This parameter specifies the device to be started.
@@ -1177,11 +1177,11 @@ static enum sci_status scic_remote_device_ea_construct(struct isci_port *iport,
  * SCI_FAILURE_INVALID_PHY This value is returned if the user attempts to start
  * the device when there have been no phys added to it.
  */
-static enum sci_status scic_remote_device_start(struct isci_remote_device *idev,
+static enum sci_status sci_remote_device_start(struct isci_remote_device *idev,
 						u32 timeout)
 {
 	struct sci_base_state_machine *sm = &idev->sm;
-	enum scic_sds_remote_device_states state = sm->current_state_id;
+	enum sci_remote_device_states state = sm->current_state_id;
 	enum sci_status status;
 
 	if (state != SCI_DEV_STOPPED) {
@@ -1190,7 +1190,7 @@ static enum sci_status scic_remote_device_start(struct isci_remote_device *idev,
 		return SCI_FAILURE_INVALID_STATE;
 	}
 
-	status = scic_sds_remote_node_context_resume(&idev->rnc,
+	status = sci_remote_node_context_resume(&idev->rnc,
 						     remote_device_resume_done,
 						     idev);
 	if (status != SCI_SUCCESS)
@@ -1209,9 +1209,9 @@ static enum sci_status isci_remote_device_construct(struct isci_port *iport,
 	enum sci_status status;
 
 	if (dev->parent && dev_is_expander(dev->parent))
-		status = scic_remote_device_ea_construct(iport, idev);
+		status = sci_remote_device_ea_construct(iport, idev);
 	else
-		status = scic_remote_device_da_construct(iport, idev);
+		status = sci_remote_device_da_construct(iport, idev);
 
 	if (status != SCI_SUCCESS) {
 		dev_dbg(&ihost->pdev->dev, "%s: construct failed: %d\n",
@@ -1221,7 +1221,7 @@ static enum sci_status isci_remote_device_construct(struct isci_port *iport,
 	}
 
 	/* start the device. */
-	status = scic_remote_device_start(idev, ISCI_REMOTE_DEVICE_START_TIMEOUT);
+	status = sci_remote_device_start(idev, ISCI_REMOTE_DEVICE_START_TIMEOUT);
 
 	if (status != SCI_SUCCESS)
 		dev_warn(&ihost->pdev->dev, "remote device start failed: %d\n",
@@ -1322,7 +1322,7 @@ enum sci_status isci_remote_device_stop(struct isci_host *ihost, struct isci_rem
 	set_bit(IDEV_STOP_PENDING, &idev->flags);
 
 	spin_lock_irqsave(&ihost->scic_lock, flags);
-	status = scic_remote_device_stop(idev, 50);
+	status = sci_remote_device_stop(idev, 50);
 	spin_unlock_irqrestore(&ihost->scic_lock, flags);
 
 	/* Wait for the stop complete callback. */

commit d9dcb4ba791de2a06b19ac47cd61601cf3d4e208
Author: Dan Williams <dan.j.williams@intel.com>
Date:   Thu Jun 30 17:38:32 2011 -0700

    isci: unify isci_host and scic_sds_controller
    
    Remove the distinction between these two implementations and unify on
    isci_host (local instances named ihost).  Hmmm, we had two
    'oem_parameters' instances, one was unused... nice.
    
    Reported-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/drivers/scsi/isci/remote_device.c b/drivers/scsi/isci/remote_device.c
index 3b0234049a3d..9043b458c999 100644
--- a/drivers/scsi/isci/remote_device.c
+++ b/drivers/scsi/isci/remote_device.c
@@ -62,7 +62,7 @@
 #include "task.h"
 
 /**
- * isci_remote_device_not_ready() - This function is called by the scic when
+ * isci_remote_device_not_ready() - This function is called by the ihost when
  *    the remote device is not ready. We mark the isci device as ready (not
  *    "ready_for_io") and signal the waiting proccess.
  * @isci_host: This parameter specifies the isci host object.
@@ -92,7 +92,7 @@ static void isci_remote_device_not_ready(struct isci_host *ihost,
 				"%s: isci_device = %p request = %p\n",
 				__func__, idev, ireq);
 
-			scic_controller_terminate_request(&ihost->sci,
+			scic_controller_terminate_request(ihost,
 							  idev,
 							  ireq);
 		}
@@ -104,7 +104,7 @@ static void isci_remote_device_not_ready(struct isci_host *ihost,
 }
 
 /**
- * isci_remote_device_ready() - This function is called by the scic when the
+ * isci_remote_device_ready() - This function is called by the ihost when the
  *    remote device is ready. We mark the isci device as ready and signal the
  *    waiting proccess.
  * @ihost: our valid isci_host
@@ -135,8 +135,7 @@ static void rnc_destruct_done(void *_dev)
 
 static enum sci_status scic_sds_remote_device_terminate_requests(struct isci_remote_device *idev)
 {
-	struct scic_sds_controller *scic = idev->owning_port->owning_controller;
-	struct isci_host *ihost = scic_to_ihost(scic);
+	struct isci_host *ihost = idev->owning_port->owning_controller;
 	enum sci_status status  = SCI_SUCCESS;
 	u32 i;
 
@@ -148,7 +147,7 @@ static enum sci_status scic_sds_remote_device_terminate_requests(struct isci_rem
 		    ireq->target_device != idev)
 			continue;
 
-		s = scic_controller_terminate_request(scic, idev, ireq);
+		s = scic_controller_terminate_request(ihost, idev, ireq);
 		if (s != SCI_SUCCESS)
 			status = s;
 	}
@@ -276,7 +275,7 @@ enum sci_status scic_sds_remote_device_frame_handler(struct isci_remote_device *
 {
 	struct sci_base_state_machine *sm = &idev->sm;
 	enum scic_sds_remote_device_states state = sm->current_state_id;
-	struct scic_sds_controller *scic = idev->owning_port->owning_controller;
+	struct isci_host *ihost = idev->owning_port->owning_controller;
 	enum sci_status status;
 
 	switch (state) {
@@ -290,7 +289,7 @@ enum sci_status scic_sds_remote_device_frame_handler(struct isci_remote_device *
 		dev_warn(scirdev_to_dev(idev), "%s: in wrong state: %d\n",
 			 __func__, state);
 		/* Return the frame back to the controller */
-		scic_sds_controller_release_frame(scic, frame_index);
+		scic_sds_controller_release_frame(ihost, frame_index);
 		return SCI_FAILURE_INVALID_STATE;
 	case SCI_DEV_READY:
 	case SCI_STP_DEV_NCQ_ERROR:
@@ -303,7 +302,7 @@ enum sci_status scic_sds_remote_device_frame_handler(struct isci_remote_device *
 		void *frame_header;
 		ssize_t word_cnt;
 
-		status = scic_sds_unsolicited_frame_control_get_header(&scic->uf_control,
+		status = scic_sds_unsolicited_frame_control_get_header(&ihost->uf_control,
 								       frame_index,
 								       &frame_header);
 		if (status != SCI_SUCCESS)
@@ -312,7 +311,7 @@ enum sci_status scic_sds_remote_device_frame_handler(struct isci_remote_device *
 		word_cnt = sizeof(hdr) / sizeof(u32);
 		sci_swab32_cpy(&hdr, frame_header, word_cnt);
 
-		ireq = scic_request_by_tag(scic, be16_to_cpu(hdr.tag));
+		ireq = scic_request_by_tag(ihost, be16_to_cpu(hdr.tag));
 		if (ireq && ireq->target_device == idev) {
 			/* The IO request is now in charge of releasing the frame */
 			status = scic_sds_io_request_frame_handler(ireq, frame_index);
@@ -320,14 +319,14 @@ enum sci_status scic_sds_remote_device_frame_handler(struct isci_remote_device *
 			/* We could not map this tag to a valid IO
 			 * request Just toss the frame and continue
 			 */
-			scic_sds_controller_release_frame(scic, frame_index);
+			scic_sds_controller_release_frame(ihost, frame_index);
 		}
 		break;
 	}
 	case SCI_STP_DEV_NCQ: {
 		struct dev_to_host_fis *hdr;
 
-		status = scic_sds_unsolicited_frame_control_get_header(&scic->uf_control,
+		status = scic_sds_unsolicited_frame_control_get_header(&ihost->uf_control,
 								       frame_index,
 								       (void **)&hdr);
 		if (status != SCI_SUCCESS)
@@ -350,7 +349,7 @@ enum sci_status scic_sds_remote_device_frame_handler(struct isci_remote_device *
 		} else
 			status = SCI_FAILURE;
 
-		scic_sds_controller_release_frame(scic, frame_index);
+		scic_sds_controller_release_frame(ihost, frame_index);
 		break;
 	}
 	case SCI_STP_DEV_CMD:
@@ -461,7 +460,7 @@ static void scic_sds_remote_device_start_request(struct isci_remote_device *idev
 	}
 }
 
-enum sci_status scic_sds_remote_device_start_io(struct scic_sds_controller *scic,
+enum sci_status scic_sds_remote_device_start_io(struct isci_host *ihost,
 						struct isci_remote_device *idev,
 						struct isci_request *ireq)
 {
@@ -597,7 +596,7 @@ static enum sci_status common_complete_io(struct isci_port *iport,
 	return status;
 }
 
-enum sci_status scic_sds_remote_device_complete_io(struct scic_sds_controller *scic,
+enum sci_status scic_sds_remote_device_complete_io(struct isci_host *ihost,
 						   struct isci_remote_device *idev,
 						   struct isci_request *ireq)
 {
@@ -678,7 +677,7 @@ static void scic_sds_remote_device_continue_request(void *dev)
 		scic_controller_continue_io(idev->working_request);
 }
 
-enum sci_status scic_sds_remote_device_start_task(struct scic_sds_controller *scic,
+enum sci_status scic_sds_remote_device_start_task(struct isci_host *ihost,
 						  struct isci_remote_device *idev,
 						  struct isci_request *ireq)
 {
@@ -802,13 +801,13 @@ static void remote_device_resume_done(void *_dev)
 static void scic_sds_stp_remote_device_ready_idle_substate_resume_complete_handler(void *_dev)
 {
 	struct isci_remote_device *idev = _dev;
-	struct scic_sds_controller *scic = idev->owning_port->owning_controller;
+	struct isci_host *ihost = idev->owning_port->owning_controller;
 
 	/* For NCQ operation we do not issue a isci_remote_device_not_ready().
 	 * As a result, avoid sending the ready notification.
 	 */
 	if (idev->sm.previous_state_id != SCI_STP_DEV_NCQ)
-		isci_remote_device_ready(scic_to_ihost(scic), idev);
+		isci_remote_device_ready(ihost, idev);
 }
 
 static void scic_sds_remote_device_initial_state_enter(struct sci_base_state_machine *sm)
@@ -836,7 +835,7 @@ static enum sci_status scic_remote_device_destruct(struct isci_remote_device *id
 {
 	struct sci_base_state_machine *sm = &idev->sm;
 	enum scic_sds_remote_device_states state = sm->current_state_id;
-	struct scic_sds_controller *scic;
+	struct isci_host *ihost;
 
 	if (state != SCI_DEV_STOPPED) {
 		dev_warn(scirdev_to_dev(idev), "%s: in wrong state: %d\n",
@@ -844,8 +843,8 @@ static enum sci_status scic_remote_device_destruct(struct isci_remote_device *id
 		return SCI_FAILURE_INVALID_STATE;
 	}
 
-	scic = idev->owning_port->owning_controller;
-	scic_sds_controller_free_remote_node_context(scic, idev,
+	ihost = idev->owning_port->owning_controller;
+	scic_sds_controller_free_remote_node_context(ihost, idev,
 						     idev->rnc.remote_node_index);
 	idev->rnc.remote_node_index = SCIC_SDS_REMOTE_NODE_CONTEXT_INVALID_INDEX;
 	sci_change_state(sm, SCI_DEV_FINAL);
@@ -878,7 +877,7 @@ static void isci_remote_device_deconstruct(struct isci_host *ihost, struct isci_
 static void scic_sds_remote_device_stopped_state_enter(struct sci_base_state_machine *sm)
 {
 	struct isci_remote_device *idev = container_of(sm, typeof(*idev), sm);
-	struct scic_sds_controller *scic = idev->owning_port->owning_controller;
+	struct isci_host *ihost = idev->owning_port->owning_controller;
 	u32 prev_state;
 
 	/* If we are entering from the stopping state let the SCI User know that
@@ -886,16 +885,15 @@ static void scic_sds_remote_device_stopped_state_enter(struct sci_base_state_mac
 	 */
 	prev_state = idev->sm.previous_state_id;
 	if (prev_state == SCI_DEV_STOPPING)
-		isci_remote_device_deconstruct(scic_to_ihost(scic), idev);
+		isci_remote_device_deconstruct(ihost, idev);
 
-	scic_sds_controller_remote_device_stopped(scic, idev);
+	scic_sds_controller_remote_device_stopped(ihost, idev);
 }
 
 static void scic_sds_remote_device_starting_state_enter(struct sci_base_state_machine *sm)
 {
 	struct isci_remote_device *idev = container_of(sm, typeof(*idev), sm);
-	struct scic_sds_controller *scic = scic_sds_remote_device_get_controller(idev);
-	struct isci_host *ihost = scic_to_ihost(scic);
+	struct isci_host *ihost = scic_sds_remote_device_get_controller(idev);
 
 	isci_remote_device_not_ready(ihost, idev,
 				     SCIC_REMOTE_DEVICE_NOT_READY_START_REQUESTED);
@@ -904,7 +902,7 @@ static void scic_sds_remote_device_starting_state_enter(struct sci_base_state_ma
 static void scic_sds_remote_device_ready_state_enter(struct sci_base_state_machine *sm)
 {
 	struct isci_remote_device *idev = container_of(sm, typeof(*idev), sm);
-	struct scic_sds_controller *scic = idev->owning_port->owning_controller;
+	struct isci_host *ihost = idev->owning_port->owning_controller;
 	struct domain_device *dev = idev->domain_dev;
 
 	if (dev->dev_type == SATA_DEV || (dev->tproto & SAS_PROTOCOL_SATA)) {
@@ -912,7 +910,7 @@ static void scic_sds_remote_device_ready_state_enter(struct sci_base_state_machi
 	} else if (dev_is_expander(dev)) {
 		sci_change_state(&idev->sm, SCI_SMP_DEV_IDLE);
 	} else
-		isci_remote_device_ready(scic_to_ihost(scic), idev);
+		isci_remote_device_ready(ihost, idev);
 }
 
 static void scic_sds_remote_device_ready_state_exit(struct sci_base_state_machine *sm)
@@ -921,9 +919,9 @@ static void scic_sds_remote_device_ready_state_exit(struct sci_base_state_machin
 	struct domain_device *dev = idev->domain_dev;
 
 	if (dev->dev_type == SAS_END_DEV) {
-		struct scic_sds_controller *scic = idev->owning_port->owning_controller;
+		struct isci_host *ihost = idev->owning_port->owning_controller;
 
-		isci_remote_device_not_ready(scic_to_ihost(scic), idev,
+		isci_remote_device_not_ready(ihost, idev,
 					     SCIC_REMOTE_DEVICE_NOT_READY_STOP_REQUESTED);
 	}
 }
@@ -963,40 +961,40 @@ static void scic_sds_stp_remote_device_ready_idle_substate_enter(struct sci_base
 static void scic_sds_stp_remote_device_ready_cmd_substate_enter(struct sci_base_state_machine *sm)
 {
 	struct isci_remote_device *idev = container_of(sm, typeof(*idev), sm);
-	struct scic_sds_controller *scic = scic_sds_remote_device_get_controller(idev);
+	struct isci_host *ihost = scic_sds_remote_device_get_controller(idev);
 
 	BUG_ON(idev->working_request == NULL);
 
-	isci_remote_device_not_ready(scic_to_ihost(scic), idev,
+	isci_remote_device_not_ready(ihost, idev,
 				     SCIC_REMOTE_DEVICE_NOT_READY_SATA_REQUEST_STARTED);
 }
 
 static void scic_sds_stp_remote_device_ready_ncq_error_substate_enter(struct sci_base_state_machine *sm)
 {
 	struct isci_remote_device *idev = container_of(sm, typeof(*idev), sm);
-	struct scic_sds_controller *scic = scic_sds_remote_device_get_controller(idev);
+	struct isci_host *ihost = scic_sds_remote_device_get_controller(idev);
 
 	if (idev->not_ready_reason == SCIC_REMOTE_DEVICE_NOT_READY_SATA_SDB_ERROR_FIS_RECEIVED)
-		isci_remote_device_not_ready(scic_to_ihost(scic), idev,
+		isci_remote_device_not_ready(ihost, idev,
 					     idev->not_ready_reason);
 }
 
 static void scic_sds_smp_remote_device_ready_idle_substate_enter(struct sci_base_state_machine *sm)
 {
 	struct isci_remote_device *idev = container_of(sm, typeof(*idev), sm);
-	struct scic_sds_controller *scic = scic_sds_remote_device_get_controller(idev);
+	struct isci_host *ihost = scic_sds_remote_device_get_controller(idev);
 
-	isci_remote_device_ready(scic_to_ihost(scic), idev);
+	isci_remote_device_ready(ihost, idev);
 }
 
 static void scic_sds_smp_remote_device_ready_cmd_substate_enter(struct sci_base_state_machine *sm)
 {
 	struct isci_remote_device *idev = container_of(sm, typeof(*idev), sm);
-	struct scic_sds_controller *scic = scic_sds_remote_device_get_controller(idev);
+	struct isci_host *ihost = scic_sds_remote_device_get_controller(idev);
 
 	BUG_ON(idev->working_request == NULL);
 
-	isci_remote_device_not_ready(scic_to_ihost(scic), idev,
+	isci_remote_device_not_ready(ihost, idev,
 				     SCIC_REMOTE_DEVICE_NOT_READY_SMP_REQUEST_STARTED);
 }
 
@@ -1303,7 +1301,7 @@ void isci_remote_device_release(struct kref *kref)
  * @isci_host: This parameter specifies the isci host object.
  * @isci_device: This parameter specifies the remote device.
  *
- * The status of the scic request to stop.
+ * The status of the ihost request to stop.
  */
 enum sci_status isci_remote_device_stop(struct isci_host *ihost, struct isci_remote_device *idev)
 {

commit 78a6f06e0e82125787d7aa308fe28c2c8381540c
Author: Dan Williams <dan.j.williams@intel.com>
Date:   Thu Jun 30 16:31:37 2011 -0700

    isci: unify isci_remote_device and scic_sds_remote_device
    
    Remove the distinction between these two implementations and unify on
    isci_remote_device (local instances named idev).
    
    Reported-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/drivers/scsi/isci/remote_device.c b/drivers/scsi/isci/remote_device.c
index 627cf731bad8..3b0234049a3d 100644
--- a/drivers/scsi/isci/remote_device.c
+++ b/drivers/scsi/isci/remote_device.c
@@ -93,7 +93,7 @@ static void isci_remote_device_not_ready(struct isci_host *ihost,
 				__func__, idev, ireq);
 
 			scic_controller_terminate_request(&ihost->sci,
-							  &idev->sci,
+							  idev,
 							  ireq);
 		}
 		/* Fall through into the default case... */
@@ -127,15 +127,15 @@ static void isci_remote_device_ready(struct isci_host *ihost, struct isci_remote
  */
 static void rnc_destruct_done(void *_dev)
 {
-	struct scic_sds_remote_device *sci_dev = _dev;
+	struct isci_remote_device *idev = _dev;
 
-	BUG_ON(sci_dev->started_request_count != 0);
-	sci_change_state(&sci_dev->sm, SCI_DEV_STOPPED);
+	BUG_ON(idev->started_request_count != 0);
+	sci_change_state(&idev->sm, SCI_DEV_STOPPED);
 }
 
-static enum sci_status scic_sds_remote_device_terminate_requests(struct scic_sds_remote_device *sci_dev)
+static enum sci_status scic_sds_remote_device_terminate_requests(struct isci_remote_device *idev)
 {
-	struct scic_sds_controller *scic = sci_dev->owning_port->owning_controller;
+	struct scic_sds_controller *scic = idev->owning_port->owning_controller;
 	struct isci_host *ihost = scic_to_ihost(scic);
 	enum sci_status status  = SCI_SUCCESS;
 	u32 i;
@@ -145,10 +145,10 @@ static enum sci_status scic_sds_remote_device_terminate_requests(struct scic_sds
 		enum sci_status s;
 
 		if (!test_bit(IREQ_ACTIVE, &ireq->flags) ||
-		    ireq->target_device != sci_dev)
+		    ireq->target_device != idev)
 			continue;
 
-		s = scic_controller_terminate_request(scic, sci_dev, ireq);
+		s = scic_controller_terminate_request(scic, idev, ireq);
 		if (s != SCI_SUCCESS)
 			status = s;
 	}
@@ -156,10 +156,10 @@ static enum sci_status scic_sds_remote_device_terminate_requests(struct scic_sds
 	return status;
 }
 
-enum sci_status scic_remote_device_stop(struct scic_sds_remote_device *sci_dev,
+enum sci_status scic_remote_device_stop(struct isci_remote_device *idev,
 					u32 timeout)
 {
-	struct sci_base_state_machine *sm = &sci_dev->sm;
+	struct sci_base_state_machine *sm = &idev->sm;
 	enum scic_sds_remote_device_states state = sm->current_state_id;
 
 	switch (state) {
@@ -167,16 +167,16 @@ enum sci_status scic_remote_device_stop(struct scic_sds_remote_device *sci_dev,
 	case SCI_DEV_FAILED:
 	case SCI_DEV_FINAL:
 	default:
-		dev_warn(scirdev_to_dev(sci_dev), "%s: in wrong state: %d\n",
+		dev_warn(scirdev_to_dev(idev), "%s: in wrong state: %d\n",
 			 __func__, state);
 		return SCI_FAILURE_INVALID_STATE;
 	case SCI_DEV_STOPPED:
 		return SCI_SUCCESS;
 	case SCI_DEV_STARTING:
 		/* device not started so there had better be no requests */
-		BUG_ON(sci_dev->started_request_count != 0);
-		scic_sds_remote_node_context_destruct(&sci_dev->rnc,
-						      rnc_destruct_done, sci_dev);
+		BUG_ON(idev->started_request_count != 0);
+		scic_sds_remote_node_context_destruct(&idev->rnc,
+						      rnc_destruct_done, idev);
 		/* Transition to the stopping state and wait for the
 		 * remote node to complete being posted and invalidated.
 		 */
@@ -191,28 +191,28 @@ enum sci_status scic_remote_device_stop(struct scic_sds_remote_device *sci_dev,
 	case SCI_SMP_DEV_IDLE:
 	case SCI_SMP_DEV_CMD:
 		sci_change_state(sm, SCI_DEV_STOPPING);
-		if (sci_dev->started_request_count == 0) {
-			scic_sds_remote_node_context_destruct(&sci_dev->rnc,
-							      rnc_destruct_done, sci_dev);
+		if (idev->started_request_count == 0) {
+			scic_sds_remote_node_context_destruct(&idev->rnc,
+							      rnc_destruct_done, idev);
 			return SCI_SUCCESS;
 		} else
-			return scic_sds_remote_device_terminate_requests(sci_dev);
+			return scic_sds_remote_device_terminate_requests(idev);
 		break;
 	case SCI_DEV_STOPPING:
 		/* All requests should have been terminated, but if there is an
 		 * attempt to stop a device already in the stopping state, then
 		 * try again to terminate.
 		 */
-		return scic_sds_remote_device_terminate_requests(sci_dev);
+		return scic_sds_remote_device_terminate_requests(idev);
 	case SCI_DEV_RESETTING:
 		sci_change_state(sm, SCI_DEV_STOPPING);
 		return SCI_SUCCESS;
 	}
 }
 
-enum sci_status scic_remote_device_reset(struct scic_sds_remote_device *sci_dev)
+enum sci_status scic_remote_device_reset(struct isci_remote_device *idev)
 {
-	struct sci_base_state_machine *sm = &sci_dev->sm;
+	struct sci_base_state_machine *sm = &idev->sm;
 	enum scic_sds_remote_device_states state = sm->current_state_id;
 
 	switch (state) {
@@ -226,7 +226,7 @@ enum sci_status scic_remote_device_reset(struct scic_sds_remote_device *sci_dev)
 	case SCI_DEV_RESETTING:
 	case SCI_DEV_FINAL:
 	default:
-		dev_warn(scirdev_to_dev(sci_dev), "%s: in wrong state: %d\n",
+		dev_warn(scirdev_to_dev(idev), "%s: in wrong state: %d\n",
 			 __func__, state);
 		return SCI_FAILURE_INVALID_STATE;
 	case SCI_DEV_READY:
@@ -240,13 +240,13 @@ enum sci_status scic_remote_device_reset(struct scic_sds_remote_device *sci_dev)
 	}
 }
 
-enum sci_status scic_remote_device_reset_complete(struct scic_sds_remote_device *sci_dev)
+enum sci_status scic_remote_device_reset_complete(struct isci_remote_device *idev)
 {
-	struct sci_base_state_machine *sm = &sci_dev->sm;
+	struct sci_base_state_machine *sm = &idev->sm;
 	enum scic_sds_remote_device_states state = sm->current_state_id;
 
 	if (state != SCI_DEV_RESETTING) {
-		dev_warn(scirdev_to_dev(sci_dev), "%s: in wrong state: %d\n",
+		dev_warn(scirdev_to_dev(idev), "%s: in wrong state: %d\n",
 			 __func__, state);
 		return SCI_FAILURE_INVALID_STATE;
 	}
@@ -255,28 +255,28 @@ enum sci_status scic_remote_device_reset_complete(struct scic_sds_remote_device
 	return SCI_SUCCESS;
 }
 
-enum sci_status scic_sds_remote_device_suspend(struct scic_sds_remote_device *sci_dev,
+enum sci_status scic_sds_remote_device_suspend(struct isci_remote_device *idev,
 					       u32 suspend_type)
 {
-	struct sci_base_state_machine *sm = &sci_dev->sm;
+	struct sci_base_state_machine *sm = &idev->sm;
 	enum scic_sds_remote_device_states state = sm->current_state_id;
 
 	if (state != SCI_STP_DEV_CMD) {
-		dev_warn(scirdev_to_dev(sci_dev), "%s: in wrong state: %d\n",
+		dev_warn(scirdev_to_dev(idev), "%s: in wrong state: %d\n",
 			 __func__, state);
 		return SCI_FAILURE_INVALID_STATE;
 	}
 
-	return scic_sds_remote_node_context_suspend(&sci_dev->rnc,
+	return scic_sds_remote_node_context_suspend(&idev->rnc,
 						    suspend_type, NULL, NULL);
 }
 
-enum sci_status scic_sds_remote_device_frame_handler(struct scic_sds_remote_device *sci_dev,
+enum sci_status scic_sds_remote_device_frame_handler(struct isci_remote_device *idev,
 						     u32 frame_index)
 {
-	struct sci_base_state_machine *sm = &sci_dev->sm;
+	struct sci_base_state_machine *sm = &idev->sm;
 	enum scic_sds_remote_device_states state = sm->current_state_id;
-	struct scic_sds_controller *scic = sci_dev->owning_port->owning_controller;
+	struct scic_sds_controller *scic = idev->owning_port->owning_controller;
 	enum sci_status status;
 
 	switch (state) {
@@ -287,7 +287,7 @@ enum sci_status scic_sds_remote_device_frame_handler(struct scic_sds_remote_devi
 	case SCI_SMP_DEV_IDLE:
 	case SCI_DEV_FINAL:
 	default:
-		dev_warn(scirdev_to_dev(sci_dev), "%s: in wrong state: %d\n",
+		dev_warn(scirdev_to_dev(idev), "%s: in wrong state: %d\n",
 			 __func__, state);
 		/* Return the frame back to the controller */
 		scic_sds_controller_release_frame(scic, frame_index);
@@ -313,7 +313,7 @@ enum sci_status scic_sds_remote_device_frame_handler(struct scic_sds_remote_devi
 		sci_swab32_cpy(&hdr, frame_header, word_cnt);
 
 		ireq = scic_request_by_tag(scic, be16_to_cpu(hdr.tag));
-		if (ireq && ireq->target_device == sci_dev) {
+		if (ireq && ireq->target_device == idev) {
 			/* The IO request is now in charge of releasing the frame */
 			status = scic_sds_io_request_frame_handler(ireq, frame_index);
 		} else {
@@ -335,7 +335,7 @@ enum sci_status scic_sds_remote_device_frame_handler(struct scic_sds_remote_devi
 
 		if (hdr->fis_type == FIS_SETDEVBITS &&
 		    (hdr->status & ATA_ERR)) {
-			sci_dev->not_ready_reason = SCIC_REMOTE_DEVICE_NOT_READY_SATA_SDB_ERROR_FIS_RECEIVED;
+			idev->not_ready_reason = SCIC_REMOTE_DEVICE_NOT_READY_SATA_SDB_ERROR_FIS_RECEIVED;
 
 			/* TODO Check sactive and complete associated IO if any. */
 			sci_change_state(sm, SCI_STP_DEV_NCQ_ERROR);
@@ -345,8 +345,8 @@ enum sci_status scic_sds_remote_device_frame_handler(struct scic_sds_remote_devi
 			 * Some devices return D2H FIS when an NCQ error is detected.
 			 * Treat this like an SDB error FIS ready reason.
 			 */
-			sci_dev->not_ready_reason = SCIC_REMOTE_DEVICE_NOT_READY_SATA_SDB_ERROR_FIS_RECEIVED;
-			sci_change_state(&sci_dev->sm, SCI_STP_DEV_NCQ_ERROR);
+			idev->not_ready_reason = SCIC_REMOTE_DEVICE_NOT_READY_SATA_SDB_ERROR_FIS_RECEIVED;
+			sci_change_state(&idev->sm, SCI_STP_DEV_NCQ_ERROR);
 		} else
 			status = SCI_FAILURE;
 
@@ -359,17 +359,17 @@ enum sci_status scic_sds_remote_device_frame_handler(struct scic_sds_remote_devi
 		 * in this state.  All unsolicited frames are forwarded to the io request
 		 * object.
 		 */
-		status = scic_sds_io_request_frame_handler(sci_dev->working_request, frame_index);
+		status = scic_sds_io_request_frame_handler(idev->working_request, frame_index);
 		break;
 	}
 
 	return status;
 }
 
-static bool is_remote_device_ready(struct scic_sds_remote_device *sci_dev)
+static bool is_remote_device_ready(struct isci_remote_device *idev)
 {
 
-	struct sci_base_state_machine *sm = &sci_dev->sm;
+	struct sci_base_state_machine *sm = &idev->sm;
 	enum scic_sds_remote_device_states state = sm->current_state_id;
 
 	switch (state) {
@@ -387,10 +387,10 @@ static bool is_remote_device_ready(struct scic_sds_remote_device *sci_dev)
 	}
 }
 
-enum sci_status scic_sds_remote_device_event_handler(struct scic_sds_remote_device *sci_dev,
+enum sci_status scic_sds_remote_device_event_handler(struct isci_remote_device *idev,
 						     u32 event_code)
 {
-	struct sci_base_state_machine *sm = &sci_dev->sm;
+	struct sci_base_state_machine *sm = &idev->sm;
 	enum scic_sds_remote_device_states state = sm->current_state_id;
 	enum sci_status status;
 
@@ -398,21 +398,21 @@ enum sci_status scic_sds_remote_device_event_handler(struct scic_sds_remote_devi
 	case SCU_EVENT_TYPE_RNC_OPS_MISC:
 	case SCU_EVENT_TYPE_RNC_SUSPEND_TX:
 	case SCU_EVENT_TYPE_RNC_SUSPEND_TX_RX:
-		status = scic_sds_remote_node_context_event_handler(&sci_dev->rnc, event_code);
+		status = scic_sds_remote_node_context_event_handler(&idev->rnc, event_code);
 		break;
 	case SCU_EVENT_TYPE_PTX_SCHEDULE_EVENT:
 		if (scu_get_event_code(event_code) == SCU_EVENT_IT_NEXUS_TIMEOUT) {
 			status = SCI_SUCCESS;
 
 			/* Suspend the associated RNC */
-			scic_sds_remote_node_context_suspend(&sci_dev->rnc,
+			scic_sds_remote_node_context_suspend(&idev->rnc,
 							      SCI_SOFTWARE_SUSPENSION,
 							      NULL, NULL);
 
-			dev_dbg(scirdev_to_dev(sci_dev),
+			dev_dbg(scirdev_to_dev(idev),
 				"%s: device: %p event code: %x: %s\n",
-				__func__, sci_dev, event_code,
-				is_remote_device_ready(sci_dev)
+				__func__, idev, event_code,
+				is_remote_device_ready(idev)
 				? "I_T_Nexus_Timeout event"
 				: "I_T_Nexus_Timeout event in wrong state");
 
@@ -420,10 +420,10 @@ enum sci_status scic_sds_remote_device_event_handler(struct scic_sds_remote_devi
 		}
 	/* Else, fall through and treat as unhandled... */
 	default:
-		dev_dbg(scirdev_to_dev(sci_dev),
+		dev_dbg(scirdev_to_dev(idev),
 			"%s: device: %p event code: %x: %s\n",
-			__func__, sci_dev, event_code,
-			is_remote_device_ready(sci_dev)
+			__func__, idev, event_code,
+			is_remote_device_ready(idev)
 			? "unexpected event"
 			: "unexpected event in wrong state");
 		status = SCI_FAILURE_INVALID_STATE;
@@ -440,34 +440,34 @@ enum sci_status scic_sds_remote_device_event_handler(struct scic_sds_remote_devi
 		 */
 		if (scu_get_event_type(event_code) == SCU_EVENT_TYPE_RNC_SUSPEND_TX ||
 		    scu_get_event_type(event_code) == SCU_EVENT_TYPE_RNC_SUSPEND_TX_RX)
-			status = scic_sds_remote_node_context_resume(&sci_dev->rnc, NULL, NULL);
+			status = scic_sds_remote_node_context_resume(&idev->rnc, NULL, NULL);
 	}
 
 	return status;
 }
 
-static void scic_sds_remote_device_start_request(struct scic_sds_remote_device *sci_dev,
+static void scic_sds_remote_device_start_request(struct isci_remote_device *idev,
 						 struct isci_request *ireq,
 						 enum sci_status status)
 {
-	struct isci_port *iport = sci_dev->owning_port;
+	struct isci_port *iport = idev->owning_port;
 
 	/* cleanup requests that failed after starting on the port */
 	if (status != SCI_SUCCESS)
-		scic_sds_port_complete_io(iport, sci_dev, ireq);
+		scic_sds_port_complete_io(iport, idev, ireq);
 	else {
-		kref_get(&sci_dev_to_idev(sci_dev)->kref);
-		scic_sds_remote_device_increment_request_count(sci_dev);
+		kref_get(&idev->kref);
+		scic_sds_remote_device_increment_request_count(idev);
 	}
 }
 
 enum sci_status scic_sds_remote_device_start_io(struct scic_sds_controller *scic,
-						struct scic_sds_remote_device *sci_dev,
+						struct isci_remote_device *idev,
 						struct isci_request *ireq)
 {
-	struct sci_base_state_machine *sm = &sci_dev->sm;
+	struct sci_base_state_machine *sm = &idev->sm;
 	enum scic_sds_remote_device_states state = sm->current_state_id;
-	struct isci_port *iport = sci_dev->owning_port;
+	struct isci_port *iport = idev->owning_port;
 	enum sci_status status;
 
 	switch (state) {
@@ -480,7 +480,7 @@ enum sci_status scic_sds_remote_device_start_io(struct scic_sds_controller *scic
 	case SCI_DEV_RESETTING:
 	case SCI_DEV_FINAL:
 	default:
-		dev_warn(scirdev_to_dev(sci_dev), "%s: in wrong state: %d\n",
+		dev_warn(scirdev_to_dev(idev), "%s: in wrong state: %d\n",
 			 __func__, state);
 		return SCI_FAILURE_INVALID_STATE;
 	case SCI_DEV_READY:
@@ -489,11 +489,11 @@ enum sci_status scic_sds_remote_device_start_io(struct scic_sds_controller *scic
 		 * successful it will start the request for the port object then
 		 * increment its own request count.
 		 */
-		status = scic_sds_port_start_io(iport, sci_dev, ireq);
+		status = scic_sds_port_start_io(iport, idev, ireq);
 		if (status != SCI_SUCCESS)
 			return status;
 
-		status = scic_sds_remote_node_context_start_io(&sci_dev->rnc, ireq);
+		status = scic_sds_remote_node_context_start_io(&idev->rnc, ireq);
 		if (status != SCI_SUCCESS)
 			break;
 
@@ -511,11 +511,11 @@ enum sci_status scic_sds_remote_device_start_io(struct scic_sds_controller *scic
 		enum scic_sds_remote_device_states new_state;
 		struct sas_task *task = isci_request_access_task(ireq);
 
-		status = scic_sds_port_start_io(iport, sci_dev, ireq);
+		status = scic_sds_port_start_io(iport, idev, ireq);
 		if (status != SCI_SUCCESS)
 			return status;
 
-		status = scic_sds_remote_node_context_start_io(&sci_dev->rnc, ireq);
+		status = scic_sds_remote_node_context_start_io(&idev->rnc, ireq);
 		if (status != SCI_SUCCESS)
 			break;
 
@@ -526,7 +526,7 @@ enum sci_status scic_sds_remote_device_start_io(struct scic_sds_controller *scic
 		if (task->ata_task.use_ncq)
 			new_state = SCI_STP_DEV_NCQ;
 		else {
-			sci_dev->working_request = ireq;
+			idev->working_request = ireq;
 			new_state = SCI_STP_DEV_CMD;
 		}
 		sci_change_state(sm, new_state);
@@ -536,11 +536,11 @@ enum sci_status scic_sds_remote_device_start_io(struct scic_sds_controller *scic
 		struct sas_task *task = isci_request_access_task(ireq);
 
 		if (task->ata_task.use_ncq) {
-			status = scic_sds_port_start_io(iport, sci_dev, ireq);
+			status = scic_sds_port_start_io(iport, idev, ireq);
 			if (status != SCI_SUCCESS)
 				return status;
 
-			status = scic_sds_remote_node_context_start_io(&sci_dev->rnc, ireq);
+			status = scic_sds_remote_node_context_start_io(&idev->rnc, ireq);
 			if (status != SCI_SUCCESS)
 				break;
 
@@ -552,11 +552,11 @@ enum sci_status scic_sds_remote_device_start_io(struct scic_sds_controller *scic
 	case SCI_STP_DEV_AWAIT_RESET:
 		return SCI_FAILURE_REMOTE_DEVICE_RESET_REQUIRED;
 	case SCI_SMP_DEV_IDLE:
-		status = scic_sds_port_start_io(iport, sci_dev, ireq);
+		status = scic_sds_port_start_io(iport, idev, ireq);
 		if (status != SCI_SUCCESS)
 			return status;
 
-		status = scic_sds_remote_node_context_start_io(&sci_dev->rnc, ireq);
+		status = scic_sds_remote_node_context_start_io(&idev->rnc, ireq);
 		if (status != SCI_SUCCESS)
 			break;
 
@@ -564,8 +564,8 @@ enum sci_status scic_sds_remote_device_start_io(struct scic_sds_controller *scic
 		if (status != SCI_SUCCESS)
 			break;
 
-		sci_dev->working_request = ireq;
-		sci_change_state(&sci_dev->sm, SCI_SMP_DEV_CMD);
+		idev->working_request = ireq;
+		sci_change_state(&idev->sm, SCI_SMP_DEV_CMD);
 		break;
 	case SCI_STP_DEV_CMD:
 	case SCI_SMP_DEV_CMD:
@@ -575,12 +575,12 @@ enum sci_status scic_sds_remote_device_start_io(struct scic_sds_controller *scic
 		return SCI_FAILURE_INVALID_STATE;
 	}
 
-	scic_sds_remote_device_start_request(sci_dev, ireq, status);
+	scic_sds_remote_device_start_request(idev, ireq, status);
 	return status;
 }
 
 static enum sci_status common_complete_io(struct isci_port *iport,
-					  struct scic_sds_remote_device *sci_dev,
+					  struct isci_remote_device *idev,
 					  struct isci_request *ireq)
 {
 	enum sci_status status;
@@ -589,21 +589,21 @@ static enum sci_status common_complete_io(struct isci_port *iport,
 	if (status != SCI_SUCCESS)
 		return status;
 
-	status = scic_sds_port_complete_io(iport, sci_dev, ireq);
+	status = scic_sds_port_complete_io(iport, idev, ireq);
 	if (status != SCI_SUCCESS)
 		return status;
 
-	scic_sds_remote_device_decrement_request_count(sci_dev);
+	scic_sds_remote_device_decrement_request_count(idev);
 	return status;
 }
 
 enum sci_status scic_sds_remote_device_complete_io(struct scic_sds_controller *scic,
-						   struct scic_sds_remote_device *sci_dev,
+						   struct isci_remote_device *idev,
 						   struct isci_request *ireq)
 {
-	struct sci_base_state_machine *sm = &sci_dev->sm;
+	struct sci_base_state_machine *sm = &idev->sm;
 	enum scic_sds_remote_device_states state = sm->current_state_id;
-	struct isci_port *iport = sci_dev->owning_port;
+	struct isci_port *iport = idev->owning_port;
 	enum sci_status status;
 
 	switch (state) {
@@ -615,18 +615,18 @@ enum sci_status scic_sds_remote_device_complete_io(struct scic_sds_controller *s
 	case SCI_DEV_FAILED:
 	case SCI_DEV_FINAL:
 	default:
-		dev_warn(scirdev_to_dev(sci_dev), "%s: in wrong state: %d\n",
+		dev_warn(scirdev_to_dev(idev), "%s: in wrong state: %d\n",
 			 __func__, state);
 		return SCI_FAILURE_INVALID_STATE;
 	case SCI_DEV_READY:
 	case SCI_STP_DEV_AWAIT_RESET:
 	case SCI_DEV_RESETTING:
-		status = common_complete_io(iport, sci_dev, ireq);
+		status = common_complete_io(iport, idev, ireq);
 		break;
 	case SCI_STP_DEV_CMD:
 	case SCI_STP_DEV_NCQ:
 	case SCI_STP_DEV_NCQ_ERROR:
-		status = common_complete_io(iport, sci_dev, ireq);
+		status = common_complete_io(iport, idev, ireq);
 		if (status != SCI_SUCCESS)
 			break;
 
@@ -637,54 +637,54 @@ enum sci_status scic_sds_remote_device_complete_io(struct scic_sds_controller *s
 			 * status of "DEVICE_RESET_REQUIRED", instead of "INVALID STATE".
 			 */
 			sci_change_state(sm, SCI_STP_DEV_AWAIT_RESET);
-		} else if (scic_sds_remote_device_get_request_count(sci_dev) == 0)
+		} else if (scic_sds_remote_device_get_request_count(idev) == 0)
 			sci_change_state(sm, SCI_STP_DEV_IDLE);
 		break;
 	case SCI_SMP_DEV_CMD:
-		status = common_complete_io(iport, sci_dev, ireq);
+		status = common_complete_io(iport, idev, ireq);
 		if (status != SCI_SUCCESS)
 			break;
 		sci_change_state(sm, SCI_SMP_DEV_IDLE);
 		break;
 	case SCI_DEV_STOPPING:
-		status = common_complete_io(iport, sci_dev, ireq);
+		status = common_complete_io(iport, idev, ireq);
 		if (status != SCI_SUCCESS)
 			break;
 
-		if (scic_sds_remote_device_get_request_count(sci_dev) == 0)
-			scic_sds_remote_node_context_destruct(&sci_dev->rnc,
+		if (scic_sds_remote_device_get_request_count(idev) == 0)
+			scic_sds_remote_node_context_destruct(&idev->rnc,
 							      rnc_destruct_done,
-							      sci_dev);
+							      idev);
 		break;
 	}
 
 	if (status != SCI_SUCCESS)
-		dev_err(scirdev_to_dev(sci_dev),
+		dev_err(scirdev_to_dev(idev),
 			"%s: Port:0x%p Device:0x%p Request:0x%p Status:0x%x "
 			"could not complete\n", __func__, iport,
-			sci_dev, ireq, status);
+			idev, ireq, status);
 	else
-		isci_put_device(sci_dev_to_idev(sci_dev));
+		isci_put_device(idev);
 
 	return status;
 }
 
 static void scic_sds_remote_device_continue_request(void *dev)
 {
-	struct scic_sds_remote_device *sci_dev = dev;
+	struct isci_remote_device *idev = dev;
 
 	/* we need to check if this request is still valid to continue. */
-	if (sci_dev->working_request)
-		scic_controller_continue_io(sci_dev->working_request);
+	if (idev->working_request)
+		scic_controller_continue_io(idev->working_request);
 }
 
 enum sci_status scic_sds_remote_device_start_task(struct scic_sds_controller *scic,
-						  struct scic_sds_remote_device *sci_dev,
+						  struct isci_remote_device *idev,
 						  struct isci_request *ireq)
 {
-	struct sci_base_state_machine *sm = &sci_dev->sm;
+	struct sci_base_state_machine *sm = &idev->sm;
 	enum scic_sds_remote_device_states state = sm->current_state_id;
-	struct isci_port *iport = sci_dev->owning_port;
+	struct isci_port *iport = idev->owning_port;
 	enum sci_status status;
 
 	switch (state) {
@@ -698,7 +698,7 @@ enum sci_status scic_sds_remote_device_start_task(struct scic_sds_controller *sc
 	case SCI_DEV_RESETTING:
 	case SCI_DEV_FINAL:
 	default:
-		dev_warn(scirdev_to_dev(sci_dev), "%s: in wrong state: %d\n",
+		dev_warn(scirdev_to_dev(idev), "%s: in wrong state: %d\n",
 			 __func__, state);
 		return SCI_FAILURE_INVALID_STATE;
 	case SCI_STP_DEV_IDLE:
@@ -706,11 +706,11 @@ enum sci_status scic_sds_remote_device_start_task(struct scic_sds_controller *sc
 	case SCI_STP_DEV_NCQ:
 	case SCI_STP_DEV_NCQ_ERROR:
 	case SCI_STP_DEV_AWAIT_RESET:
-		status = scic_sds_port_start_io(iport, sci_dev, ireq);
+		status = scic_sds_port_start_io(iport, idev, ireq);
 		if (status != SCI_SUCCESS)
 			return status;
 
-		status = scic_sds_remote_node_context_start_task(&sci_dev->rnc, ireq);
+		status = scic_sds_remote_node_context_start_task(&idev->rnc, ireq);
 		if (status != SCI_SUCCESS)
 			goto out;
 
@@ -722,7 +722,7 @@ enum sci_status scic_sds_remote_device_start_task(struct scic_sds_controller *sc
 		 * replace the request that probably resulted in the task
 		 * management request.
 		 */
-		sci_dev->working_request = ireq;
+		idev->working_request = ireq;
 		sci_change_state(sm, SCI_STP_DEV_CMD);
 
 		/* The remote node context must cleanup the TCi to NCQ mapping
@@ -732,32 +732,32 @@ enum sci_status scic_sds_remote_device_start_task(struct scic_sds_controller *sc
 		 * the correct action when the remote node context is suspended
 		 * and later resumed.
 		 */
-		scic_sds_remote_node_context_suspend(&sci_dev->rnc,
+		scic_sds_remote_node_context_suspend(&idev->rnc,
 				SCI_SOFTWARE_SUSPENSION, NULL, NULL);
-		scic_sds_remote_node_context_resume(&sci_dev->rnc,
+		scic_sds_remote_node_context_resume(&idev->rnc,
 				scic_sds_remote_device_continue_request,
-						    sci_dev);
+						    idev);
 
 	out:
-		scic_sds_remote_device_start_request(sci_dev, ireq, status);
+		scic_sds_remote_device_start_request(idev, ireq, status);
 		/* We need to let the controller start request handler know that
 		 * it can't post TC yet. We will provide a callback function to
 		 * post TC when RNC gets resumed.
 		 */
 		return SCI_FAILURE_RESET_DEVICE_PARTIAL_SUCCESS;
 	case SCI_DEV_READY:
-		status = scic_sds_port_start_io(iport, sci_dev, ireq);
+		status = scic_sds_port_start_io(iport, idev, ireq);
 		if (status != SCI_SUCCESS)
 			return status;
 
-		status = scic_sds_remote_node_context_start_task(&sci_dev->rnc, ireq);
+		status = scic_sds_remote_node_context_start_task(&idev->rnc, ireq);
 		if (status != SCI_SUCCESS)
 			break;
 
 		status = scic_sds_request_start(ireq);
 		break;
 	}
-	scic_sds_remote_device_start_request(sci_dev, ireq, status);
+	scic_sds_remote_device_start_request(idev, ireq, status);
 
 	return status;
 }
@@ -771,15 +771,15 @@ enum sci_status scic_sds_remote_device_start_task(struct scic_sds_controller *sc
  * request and then requests the controller to post the request. none
  */
 void scic_sds_remote_device_post_request(
-	struct scic_sds_remote_device *sci_dev,
+	struct isci_remote_device *idev,
 	u32 request)
 {
 	u32 context;
 
-	context = scic_sds_remote_device_build_command_context(sci_dev, request);
+	context = scic_sds_remote_device_build_command_context(idev, request);
 
 	scic_sds_controller_post_request(
-		scic_sds_remote_device_get_controller(sci_dev),
+		scic_sds_remote_device_get_controller(idev),
 		context
 		);
 }
@@ -790,34 +790,33 @@ void scic_sds_remote_device_post_request(
  */
 static void remote_device_resume_done(void *_dev)
 {
-	struct scic_sds_remote_device *sci_dev = _dev;
+	struct isci_remote_device *idev = _dev;
 
-	if (is_remote_device_ready(sci_dev))
+	if (is_remote_device_ready(idev))
 		return;
 
 	/* go 'ready' if we are not already in a ready state */
-	sci_change_state(&sci_dev->sm, SCI_DEV_READY);
+	sci_change_state(&idev->sm, SCI_DEV_READY);
 }
 
 static void scic_sds_stp_remote_device_ready_idle_substate_resume_complete_handler(void *_dev)
 {
-	struct scic_sds_remote_device *sci_dev = _dev;
-	struct isci_remote_device *idev = sci_dev_to_idev(sci_dev);
-	struct scic_sds_controller *scic = sci_dev->owning_port->owning_controller;
+	struct isci_remote_device *idev = _dev;
+	struct scic_sds_controller *scic = idev->owning_port->owning_controller;
 
 	/* For NCQ operation we do not issue a isci_remote_device_not_ready().
 	 * As a result, avoid sending the ready notification.
 	 */
-	if (sci_dev->sm.previous_state_id != SCI_STP_DEV_NCQ)
+	if (idev->sm.previous_state_id != SCI_STP_DEV_NCQ)
 		isci_remote_device_ready(scic_to_ihost(scic), idev);
 }
 
 static void scic_sds_remote_device_initial_state_enter(struct sci_base_state_machine *sm)
 {
-	struct scic_sds_remote_device *sci_dev = container_of(sm, typeof(*sci_dev), sm);
+	struct isci_remote_device *idev = container_of(sm, typeof(*idev), sm);
 
 	/* Initial state is a transitional state to the stopped state */
-	sci_change_state(&sci_dev->sm, SCI_DEV_STOPPED);
+	sci_change_state(&idev->sm, SCI_DEV_STOPPED);
 }
 
 /**
@@ -833,22 +832,22 @@ static void scic_sds_remote_device_initial_state_enter(struct sci_base_state_mac
  * device isn't valid (e.g. it's already been destoryed, the handle isn't
  * valid, etc.).
  */
-static enum sci_status scic_remote_device_destruct(struct scic_sds_remote_device *sci_dev)
+static enum sci_status scic_remote_device_destruct(struct isci_remote_device *idev)
 {
-	struct sci_base_state_machine *sm = &sci_dev->sm;
+	struct sci_base_state_machine *sm = &idev->sm;
 	enum scic_sds_remote_device_states state = sm->current_state_id;
 	struct scic_sds_controller *scic;
 
 	if (state != SCI_DEV_STOPPED) {
-		dev_warn(scirdev_to_dev(sci_dev), "%s: in wrong state: %d\n",
+		dev_warn(scirdev_to_dev(idev), "%s: in wrong state: %d\n",
 			 __func__, state);
 		return SCI_FAILURE_INVALID_STATE;
 	}
 
-	scic = sci_dev->owning_port->owning_controller;
-	scic_sds_controller_free_remote_node_context(scic, sci_dev,
-						     sci_dev->rnc.remote_node_index);
-	sci_dev->rnc.remote_node_index = SCIC_SDS_REMOTE_NODE_CONTEXT_INVALID_INDEX;
+	scic = idev->owning_port->owning_controller;
+	scic_sds_controller_free_remote_node_context(scic, idev,
+						     idev->rnc.remote_node_index);
+	idev->rnc.remote_node_index = SCIC_SDS_REMOTE_NODE_CONTEXT_INVALID_INDEX;
 	sci_change_state(sm, SCI_DEV_FINAL);
 
 	return SCI_SUCCESS;
@@ -871,34 +870,32 @@ static void isci_remote_device_deconstruct(struct isci_host *ihost, struct isci_
 	 * io requests in process */
 	BUG_ON(!list_empty(&idev->reqs_in_process));
 
-	scic_remote_device_destruct(&idev->sci);
+	scic_remote_device_destruct(idev);
 	list_del_init(&idev->node);
 	isci_put_device(idev);
 }
 
 static void scic_sds_remote_device_stopped_state_enter(struct sci_base_state_machine *sm)
 {
-	struct scic_sds_remote_device *sci_dev = container_of(sm, typeof(*sci_dev), sm);
-	struct scic_sds_controller *scic = sci_dev->owning_port->owning_controller;
-	struct isci_remote_device *idev = sci_dev_to_idev(sci_dev);
+	struct isci_remote_device *idev = container_of(sm, typeof(*idev), sm);
+	struct scic_sds_controller *scic = idev->owning_port->owning_controller;
 	u32 prev_state;
 
 	/* If we are entering from the stopping state let the SCI User know that
 	 * the stop operation has completed.
 	 */
-	prev_state = sci_dev->sm.previous_state_id;
+	prev_state = idev->sm.previous_state_id;
 	if (prev_state == SCI_DEV_STOPPING)
 		isci_remote_device_deconstruct(scic_to_ihost(scic), idev);
 
-	scic_sds_controller_remote_device_stopped(scic, sci_dev);
+	scic_sds_controller_remote_device_stopped(scic, idev);
 }
 
 static void scic_sds_remote_device_starting_state_enter(struct sci_base_state_machine *sm)
 {
-	struct scic_sds_remote_device *sci_dev = container_of(sm, typeof(*sci_dev), sm);
-	struct scic_sds_controller *scic = scic_sds_remote_device_get_controller(sci_dev);
+	struct isci_remote_device *idev = container_of(sm, typeof(*idev), sm);
+	struct scic_sds_controller *scic = scic_sds_remote_device_get_controller(idev);
 	struct isci_host *ihost = scic_to_ihost(scic);
-	struct isci_remote_device *idev = sci_dev_to_idev(sci_dev);
 
 	isci_remote_device_not_ready(ihost, idev,
 				     SCIC_REMOTE_DEVICE_NOT_READY_START_REQUESTED);
@@ -906,27 +903,25 @@ static void scic_sds_remote_device_starting_state_enter(struct sci_base_state_ma
 
 static void scic_sds_remote_device_ready_state_enter(struct sci_base_state_machine *sm)
 {
-	struct scic_sds_remote_device *sci_dev = container_of(sm, typeof(*sci_dev), sm);
-	struct scic_sds_controller *scic = sci_dev->owning_port->owning_controller;
-	struct isci_remote_device *idev = sci_dev_to_idev(sci_dev);
+	struct isci_remote_device *idev = container_of(sm, typeof(*idev), sm);
+	struct scic_sds_controller *scic = idev->owning_port->owning_controller;
 	struct domain_device *dev = idev->domain_dev;
 
 	if (dev->dev_type == SATA_DEV || (dev->tproto & SAS_PROTOCOL_SATA)) {
-		sci_change_state(&sci_dev->sm, SCI_STP_DEV_IDLE);
+		sci_change_state(&idev->sm, SCI_STP_DEV_IDLE);
 	} else if (dev_is_expander(dev)) {
-		sci_change_state(&sci_dev->sm, SCI_SMP_DEV_IDLE);
+		sci_change_state(&idev->sm, SCI_SMP_DEV_IDLE);
 	} else
 		isci_remote_device_ready(scic_to_ihost(scic), idev);
 }
 
 static void scic_sds_remote_device_ready_state_exit(struct sci_base_state_machine *sm)
 {
-	struct scic_sds_remote_device *sci_dev = container_of(sm, typeof(*sci_dev), sm);
-	struct domain_device *dev = sci_dev_to_domain(sci_dev);
+	struct isci_remote_device *idev = container_of(sm, typeof(*idev), sm);
+	struct domain_device *dev = idev->domain_dev;
 
 	if (dev->dev_type == SAS_END_DEV) {
-		struct scic_sds_controller *scic = sci_dev->owning_port->owning_controller;
-		struct isci_remote_device *idev = sci_dev_to_idev(sci_dev);
+		struct scic_sds_controller *scic = idev->owning_port->owning_controller;
 
 		isci_remote_device_not_ready(scic_to_ihost(scic), idev,
 					     SCIC_REMOTE_DEVICE_NOT_READY_STOP_REQUESTED);
@@ -935,82 +930,81 @@ static void scic_sds_remote_device_ready_state_exit(struct sci_base_state_machin
 
 static void scic_sds_remote_device_resetting_state_enter(struct sci_base_state_machine *sm)
 {
-	struct scic_sds_remote_device *sci_dev = container_of(sm, typeof(*sci_dev), sm);
+	struct isci_remote_device *idev = container_of(sm, typeof(*idev), sm);
 
 	scic_sds_remote_node_context_suspend(
-		&sci_dev->rnc, SCI_SOFTWARE_SUSPENSION, NULL, NULL);
+		&idev->rnc, SCI_SOFTWARE_SUSPENSION, NULL, NULL);
 }
 
 static void scic_sds_remote_device_resetting_state_exit(struct sci_base_state_machine *sm)
 {
-	struct scic_sds_remote_device *sci_dev = container_of(sm, typeof(*sci_dev), sm);
+	struct isci_remote_device *idev = container_of(sm, typeof(*idev), sm);
 
-	scic_sds_remote_node_context_resume(&sci_dev->rnc, NULL, NULL);
+	scic_sds_remote_node_context_resume(&idev->rnc, NULL, NULL);
 }
 
 static void scic_sds_stp_remote_device_ready_idle_substate_enter(struct sci_base_state_machine *sm)
 {
-	struct scic_sds_remote_device *sci_dev = container_of(sm, typeof(*sci_dev), sm);
+	struct isci_remote_device *idev = container_of(sm, typeof(*idev), sm);
 
-	sci_dev->working_request = NULL;
-	if (scic_sds_remote_node_context_is_ready(&sci_dev->rnc)) {
+	idev->working_request = NULL;
+	if (scic_sds_remote_node_context_is_ready(&idev->rnc)) {
 		/*
 		 * Since the RNC is ready, it's alright to finish completion
 		 * processing (e.g. signal the remote device is ready). */
-		scic_sds_stp_remote_device_ready_idle_substate_resume_complete_handler(sci_dev);
+		scic_sds_stp_remote_device_ready_idle_substate_resume_complete_handler(idev);
 	} else {
-		scic_sds_remote_node_context_resume(&sci_dev->rnc,
+		scic_sds_remote_node_context_resume(&idev->rnc,
 			scic_sds_stp_remote_device_ready_idle_substate_resume_complete_handler,
-			sci_dev);
+			idev);
 	}
 }
 
 static void scic_sds_stp_remote_device_ready_cmd_substate_enter(struct sci_base_state_machine *sm)
 {
-	struct scic_sds_remote_device *sci_dev = container_of(sm, typeof(*sci_dev), sm);
-	struct scic_sds_controller *scic = scic_sds_remote_device_get_controller(sci_dev);
+	struct isci_remote_device *idev = container_of(sm, typeof(*idev), sm);
+	struct scic_sds_controller *scic = scic_sds_remote_device_get_controller(idev);
 
-	BUG_ON(sci_dev->working_request == NULL);
+	BUG_ON(idev->working_request == NULL);
 
-	isci_remote_device_not_ready(scic_to_ihost(scic), sci_dev_to_idev(sci_dev),
+	isci_remote_device_not_ready(scic_to_ihost(scic), idev,
 				     SCIC_REMOTE_DEVICE_NOT_READY_SATA_REQUEST_STARTED);
 }
 
 static void scic_sds_stp_remote_device_ready_ncq_error_substate_enter(struct sci_base_state_machine *sm)
 {
-	struct scic_sds_remote_device *sci_dev = container_of(sm, typeof(*sci_dev), sm);
-	struct scic_sds_controller *scic = scic_sds_remote_device_get_controller(sci_dev);
-	struct isci_remote_device *idev = sci_dev_to_idev(sci_dev);
+	struct isci_remote_device *idev = container_of(sm, typeof(*idev), sm);
+	struct scic_sds_controller *scic = scic_sds_remote_device_get_controller(idev);
 
-	if (sci_dev->not_ready_reason == SCIC_REMOTE_DEVICE_NOT_READY_SATA_SDB_ERROR_FIS_RECEIVED)
+	if (idev->not_ready_reason == SCIC_REMOTE_DEVICE_NOT_READY_SATA_SDB_ERROR_FIS_RECEIVED)
 		isci_remote_device_not_ready(scic_to_ihost(scic), idev,
-					     sci_dev->not_ready_reason);
+					     idev->not_ready_reason);
 }
 
 static void scic_sds_smp_remote_device_ready_idle_substate_enter(struct sci_base_state_machine *sm)
 {
-	struct scic_sds_remote_device *sci_dev = container_of(sm, typeof(*sci_dev), sm);
-	struct scic_sds_controller *scic = scic_sds_remote_device_get_controller(sci_dev);
+	struct isci_remote_device *idev = container_of(sm, typeof(*idev), sm);
+	struct scic_sds_controller *scic = scic_sds_remote_device_get_controller(idev);
 
-	isci_remote_device_ready(scic_to_ihost(scic), sci_dev_to_idev(sci_dev));
+	isci_remote_device_ready(scic_to_ihost(scic), idev);
 }
 
 static void scic_sds_smp_remote_device_ready_cmd_substate_enter(struct sci_base_state_machine *sm)
 {
-	struct scic_sds_remote_device *sci_dev = container_of(sm, typeof(*sci_dev), sm);
-	struct scic_sds_controller *scic = scic_sds_remote_device_get_controller(sci_dev);
+	struct isci_remote_device *idev = container_of(sm, typeof(*idev), sm);
+	struct scic_sds_controller *scic = scic_sds_remote_device_get_controller(idev);
 
-	BUG_ON(sci_dev->working_request == NULL);
+	BUG_ON(idev->working_request == NULL);
 
-	isci_remote_device_not_ready(scic_to_ihost(scic), sci_dev_to_idev(sci_dev),
+	isci_remote_device_not_ready(scic_to_ihost(scic), idev,
 				     SCIC_REMOTE_DEVICE_NOT_READY_SMP_REQUEST_STARTED);
 }
 
 static void scic_sds_smp_remote_device_ready_cmd_substate_exit(struct sci_base_state_machine *sm)
 {
-	struct scic_sds_remote_device *sci_dev = container_of(sm, typeof(*sci_dev), sm);
+	struct isci_remote_device *idev = container_of(sm, typeof(*idev), sm);
 
-	sci_dev->working_request = NULL;
+	idev->working_request = NULL;
 }
 
 static const struct sci_base_state scic_sds_remote_device_state_table[] = {
@@ -1065,14 +1059,14 @@ static const struct sci_base_state scic_sds_remote_device_state_table[] = {
  * frees the remote_node_context(s) for the device.
  */
 static void scic_remote_device_construct(struct isci_port *iport,
-				  struct scic_sds_remote_device *sci_dev)
+				  struct isci_remote_device *idev)
 {
-	sci_dev->owning_port = iport;
-	sci_dev->started_request_count = 0;
+	idev->owning_port = iport;
+	idev->started_request_count = 0;
 
-	sci_init_sm(&sci_dev->sm, scic_sds_remote_device_state_table, SCI_DEV_INITIAL);
+	sci_init_sm(&idev->sm, scic_sds_remote_device_state_table, SCI_DEV_INITIAL);
 
-	scic_sds_remote_node_context_construct(&sci_dev->rnc,
+	scic_sds_remote_node_context_construct(&idev->rnc,
 					       SCIC_SDS_REMOTE_NODE_CONTEXT_INVALID_INDEX);
 }
 
@@ -1091,21 +1085,21 @@ static void scic_remote_device_construct(struct isci_port *iport,
  * SCI_FAILURE_INSUFFICIENT_RESOURCES - remote node contexts exhausted.
  */
 static enum sci_status scic_remote_device_da_construct(struct isci_port *iport,
-						       struct scic_sds_remote_device *sci_dev)
+						       struct isci_remote_device *idev)
 {
 	enum sci_status status;
-	struct domain_device *dev = sci_dev_to_domain(sci_dev);
+	struct domain_device *dev = idev->domain_dev;
 
-	scic_remote_device_construct(iport, sci_dev);
+	scic_remote_device_construct(iport, idev);
 
 	/*
 	 * This information is request to determine how many remote node context
 	 * entries will be needed to store the remote node.
 	 */
-	sci_dev->is_direct_attached = true;
+	idev->is_direct_attached = true;
 	status = scic_sds_controller_allocate_remote_node_context(iport->owning_controller,
-								  sci_dev,
-								  &sci_dev->rnc.remote_node_index);
+								  idev,
+								  &idev->rnc.remote_node_index);
 
 	if (status != SCI_SUCCESS)
 		return status;
@@ -1116,10 +1110,10 @@ static enum sci_status scic_remote_device_da_construct(struct isci_port *iport,
 	else
 		return SCI_FAILURE_UNSUPPORTED_PROTOCOL;
 
-	sci_dev->connection_rate = scic_sds_port_get_max_allowed_speed(iport);
+	idev->connection_rate = scic_sds_port_get_max_allowed_speed(iport);
 
 	/* / @todo Should I assign the port width by reading all of the phys on the port? */
-	sci_dev->device_port_width = 1;
+	idev->device_port_width = 1;
 
 	return SCI_SUCCESS;
 }
@@ -1137,16 +1131,16 @@ static enum sci_status scic_remote_device_da_construct(struct isci_port *iport,
  * SCI_FAILURE_INSUFFICIENT_RESOURCES - remote node contexts exhausted.
  */
 static enum sci_status scic_remote_device_ea_construct(struct isci_port *iport,
-						       struct scic_sds_remote_device *sci_dev)
+						       struct isci_remote_device *idev)
 {
-	struct domain_device *dev = sci_dev_to_domain(sci_dev);
+	struct domain_device *dev = idev->domain_dev;
 	enum sci_status status;
 
-	scic_remote_device_construct(iport, sci_dev);
+	scic_remote_device_construct(iport, idev);
 
 	status = scic_sds_controller_allocate_remote_node_context(iport->owning_controller,
-								  sci_dev,
-								  &sci_dev->rnc.remote_node_index);
+								  idev,
+								  &idev->rnc.remote_node_index);
 	if (status != SCI_SUCCESS)
 		return status;
 
@@ -1163,11 +1157,11 @@ static enum sci_status scic_remote_device_ea_construct(struct isci_port *iport,
 	 * connection the logical link rate is that same as the
 	 * physical.  Furthermore, the SAS-2 and SAS-1.1 fields overlay
 	 * one another, so this code works for both situations. */
-	sci_dev->connection_rate = min_t(u16, scic_sds_port_get_max_allowed_speed(iport),
+	idev->connection_rate = min_t(u16, scic_sds_port_get_max_allowed_speed(iport),
 					 dev->linkrate);
 
 	/* / @todo Should I assign the port width by reading all of the phys on the port? */
-	sci_dev->device_port_width = 1;
+	idev->device_port_width = 1;
 
 	return SCI_SUCCESS;
 }
@@ -1185,22 +1179,22 @@ static enum sci_status scic_remote_device_ea_construct(struct isci_port *iport,
  * SCI_FAILURE_INVALID_PHY This value is returned if the user attempts to start
  * the device when there have been no phys added to it.
  */
-static enum sci_status scic_remote_device_start(struct scic_sds_remote_device *sci_dev,
+static enum sci_status scic_remote_device_start(struct isci_remote_device *idev,
 						u32 timeout)
 {
-	struct sci_base_state_machine *sm = &sci_dev->sm;
+	struct sci_base_state_machine *sm = &idev->sm;
 	enum scic_sds_remote_device_states state = sm->current_state_id;
 	enum sci_status status;
 
 	if (state != SCI_DEV_STOPPED) {
-		dev_warn(scirdev_to_dev(sci_dev), "%s: in wrong state: %d\n",
+		dev_warn(scirdev_to_dev(idev), "%s: in wrong state: %d\n",
 			 __func__, state);
 		return SCI_FAILURE_INVALID_STATE;
 	}
 
-	status = scic_sds_remote_node_context_resume(&sci_dev->rnc,
+	status = scic_sds_remote_node_context_resume(&idev->rnc,
 						     remote_device_resume_done,
-						     sci_dev);
+						     idev);
 	if (status != SCI_SUCCESS)
 		return status;
 
@@ -1217,9 +1211,9 @@ static enum sci_status isci_remote_device_construct(struct isci_port *iport,
 	enum sci_status status;
 
 	if (dev->parent && dev_is_expander(dev->parent))
-		status = scic_remote_device_ea_construct(iport, &idev->sci);
+		status = scic_remote_device_ea_construct(iport, idev);
 	else
-		status = scic_remote_device_da_construct(iport, &idev->sci);
+		status = scic_remote_device_da_construct(iport, idev);
 
 	if (status != SCI_SUCCESS) {
 		dev_dbg(&ihost->pdev->dev, "%s: construct failed: %d\n",
@@ -1229,7 +1223,7 @@ static enum sci_status isci_remote_device_construct(struct isci_port *iport,
 	}
 
 	/* start the device. */
-	status = scic_remote_device_start(&idev->sci, ISCI_REMOTE_DEVICE_START_TIMEOUT);
+	status = scic_remote_device_start(idev, ISCI_REMOTE_DEVICE_START_TIMEOUT);
 
 	if (status != SCI_SUCCESS)
 		dev_warn(&ihost->pdev->dev, "remote device start failed: %d\n",
@@ -1330,7 +1324,7 @@ enum sci_status isci_remote_device_stop(struct isci_host *ihost, struct isci_rem
 	set_bit(IDEV_STOP_PENDING, &idev->flags);
 
 	spin_lock_irqsave(&ihost->scic_lock, flags);
-	status = scic_remote_device_stop(&idev->sci, 50);
+	status = scic_remote_device_stop(idev, 50);
 	spin_unlock_irqrestore(&ihost->scic_lock, flags);
 
 	/* Wait for the stop complete callback. */

commit ffe191c92ff195d73f9130b1490045ca2dd4c5e0
Author: Dan Williams <dan.j.williams@intel.com>
Date:   Wed Jun 29 13:09:25 2011 -0700

    isci: unify isci_port and scic_sds_port
    
    Remove the distinction between these two implementations and unify on
    isci_port (local instances named iport).  The duplicate '->owning_port' and
    '->isci_port' in both isci_phy and isci_remote_device will be fixed in a later
    patch... this is just the straightforward rename/unification.
    
    Reported-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/drivers/scsi/isci/remote_device.c b/drivers/scsi/isci/remote_device.c
index 71ab9081fe24..627cf731bad8 100644
--- a/drivers/scsi/isci/remote_device.c
+++ b/drivers/scsi/isci/remote_device.c
@@ -450,11 +450,11 @@ static void scic_sds_remote_device_start_request(struct scic_sds_remote_device *
 						 struct isci_request *ireq,
 						 enum sci_status status)
 {
-	struct scic_sds_port *sci_port = sci_dev->owning_port;
+	struct isci_port *iport = sci_dev->owning_port;
 
 	/* cleanup requests that failed after starting on the port */
 	if (status != SCI_SUCCESS)
-		scic_sds_port_complete_io(sci_port, sci_dev, ireq);
+		scic_sds_port_complete_io(iport, sci_dev, ireq);
 	else {
 		kref_get(&sci_dev_to_idev(sci_dev)->kref);
 		scic_sds_remote_device_increment_request_count(sci_dev);
@@ -467,7 +467,7 @@ enum sci_status scic_sds_remote_device_start_io(struct scic_sds_controller *scic
 {
 	struct sci_base_state_machine *sm = &sci_dev->sm;
 	enum scic_sds_remote_device_states state = sm->current_state_id;
-	struct scic_sds_port *sci_port = sci_dev->owning_port;
+	struct isci_port *iport = sci_dev->owning_port;
 	enum sci_status status;
 
 	switch (state) {
@@ -489,7 +489,7 @@ enum sci_status scic_sds_remote_device_start_io(struct scic_sds_controller *scic
 		 * successful it will start the request for the port object then
 		 * increment its own request count.
 		 */
-		status = scic_sds_port_start_io(sci_port, sci_dev, ireq);
+		status = scic_sds_port_start_io(iport, sci_dev, ireq);
 		if (status != SCI_SUCCESS)
 			return status;
 
@@ -511,7 +511,7 @@ enum sci_status scic_sds_remote_device_start_io(struct scic_sds_controller *scic
 		enum scic_sds_remote_device_states new_state;
 		struct sas_task *task = isci_request_access_task(ireq);
 
-		status = scic_sds_port_start_io(sci_port, sci_dev, ireq);
+		status = scic_sds_port_start_io(iport, sci_dev, ireq);
 		if (status != SCI_SUCCESS)
 			return status;
 
@@ -536,7 +536,7 @@ enum sci_status scic_sds_remote_device_start_io(struct scic_sds_controller *scic
 		struct sas_task *task = isci_request_access_task(ireq);
 
 		if (task->ata_task.use_ncq) {
-			status = scic_sds_port_start_io(sci_port, sci_dev, ireq);
+			status = scic_sds_port_start_io(iport, sci_dev, ireq);
 			if (status != SCI_SUCCESS)
 				return status;
 
@@ -552,7 +552,7 @@ enum sci_status scic_sds_remote_device_start_io(struct scic_sds_controller *scic
 	case SCI_STP_DEV_AWAIT_RESET:
 		return SCI_FAILURE_REMOTE_DEVICE_RESET_REQUIRED;
 	case SCI_SMP_DEV_IDLE:
-		status = scic_sds_port_start_io(sci_port, sci_dev, ireq);
+		status = scic_sds_port_start_io(iport, sci_dev, ireq);
 		if (status != SCI_SUCCESS)
 			return status;
 
@@ -579,7 +579,7 @@ enum sci_status scic_sds_remote_device_start_io(struct scic_sds_controller *scic
 	return status;
 }
 
-static enum sci_status common_complete_io(struct scic_sds_port *sci_port,
+static enum sci_status common_complete_io(struct isci_port *iport,
 					  struct scic_sds_remote_device *sci_dev,
 					  struct isci_request *ireq)
 {
@@ -589,7 +589,7 @@ static enum sci_status common_complete_io(struct scic_sds_port *sci_port,
 	if (status != SCI_SUCCESS)
 		return status;
 
-	status = scic_sds_port_complete_io(sci_port, sci_dev, ireq);
+	status = scic_sds_port_complete_io(iport, sci_dev, ireq);
 	if (status != SCI_SUCCESS)
 		return status;
 
@@ -603,7 +603,7 @@ enum sci_status scic_sds_remote_device_complete_io(struct scic_sds_controller *s
 {
 	struct sci_base_state_machine *sm = &sci_dev->sm;
 	enum scic_sds_remote_device_states state = sm->current_state_id;
-	struct scic_sds_port *sci_port = sci_dev->owning_port;
+	struct isci_port *iport = sci_dev->owning_port;
 	enum sci_status status;
 
 	switch (state) {
@@ -621,12 +621,12 @@ enum sci_status scic_sds_remote_device_complete_io(struct scic_sds_controller *s
 	case SCI_DEV_READY:
 	case SCI_STP_DEV_AWAIT_RESET:
 	case SCI_DEV_RESETTING:
-		status = common_complete_io(sci_port, sci_dev, ireq);
+		status = common_complete_io(iport, sci_dev, ireq);
 		break;
 	case SCI_STP_DEV_CMD:
 	case SCI_STP_DEV_NCQ:
 	case SCI_STP_DEV_NCQ_ERROR:
-		status = common_complete_io(sci_port, sci_dev, ireq);
+		status = common_complete_io(iport, sci_dev, ireq);
 		if (status != SCI_SUCCESS)
 			break;
 
@@ -641,13 +641,13 @@ enum sci_status scic_sds_remote_device_complete_io(struct scic_sds_controller *s
 			sci_change_state(sm, SCI_STP_DEV_IDLE);
 		break;
 	case SCI_SMP_DEV_CMD:
-		status = common_complete_io(sci_port, sci_dev, ireq);
+		status = common_complete_io(iport, sci_dev, ireq);
 		if (status != SCI_SUCCESS)
 			break;
 		sci_change_state(sm, SCI_SMP_DEV_IDLE);
 		break;
 	case SCI_DEV_STOPPING:
-		status = common_complete_io(sci_port, sci_dev, ireq);
+		status = common_complete_io(iport, sci_dev, ireq);
 		if (status != SCI_SUCCESS)
 			break;
 
@@ -661,7 +661,7 @@ enum sci_status scic_sds_remote_device_complete_io(struct scic_sds_controller *s
 	if (status != SCI_SUCCESS)
 		dev_err(scirdev_to_dev(sci_dev),
 			"%s: Port:0x%p Device:0x%p Request:0x%p Status:0x%x "
-			"could not complete\n", __func__, sci_port,
+			"could not complete\n", __func__, iport,
 			sci_dev, ireq, status);
 	else
 		isci_put_device(sci_dev_to_idev(sci_dev));
@@ -684,7 +684,7 @@ enum sci_status scic_sds_remote_device_start_task(struct scic_sds_controller *sc
 {
 	struct sci_base_state_machine *sm = &sci_dev->sm;
 	enum scic_sds_remote_device_states state = sm->current_state_id;
-	struct scic_sds_port *sci_port = sci_dev->owning_port;
+	struct isci_port *iport = sci_dev->owning_port;
 	enum sci_status status;
 
 	switch (state) {
@@ -706,7 +706,7 @@ enum sci_status scic_sds_remote_device_start_task(struct scic_sds_controller *sc
 	case SCI_STP_DEV_NCQ:
 	case SCI_STP_DEV_NCQ_ERROR:
 	case SCI_STP_DEV_AWAIT_RESET:
-		status = scic_sds_port_start_io(sci_port, sci_dev, ireq);
+		status = scic_sds_port_start_io(iport, sci_dev, ireq);
 		if (status != SCI_SUCCESS)
 			return status;
 
@@ -746,7 +746,7 @@ enum sci_status scic_sds_remote_device_start_task(struct scic_sds_controller *sc
 		 */
 		return SCI_FAILURE_RESET_DEVICE_PARTIAL_SUCCESS;
 	case SCI_DEV_READY:
-		status = scic_sds_port_start_io(sci_port, sci_dev, ireq);
+		status = scic_sds_port_start_io(iport, sci_dev, ireq);
 		if (status != SCI_SUCCESS)
 			return status;
 
@@ -1064,10 +1064,10 @@ static const struct sci_base_state scic_sds_remote_device_state_table[] = {
  * scic_remote_device_[de]a_construct().  scic_remote_device_destruct()
  * frees the remote_node_context(s) for the device.
  */
-static void scic_remote_device_construct(struct scic_sds_port *sci_port,
+static void scic_remote_device_construct(struct isci_port *iport,
 				  struct scic_sds_remote_device *sci_dev)
 {
-	sci_dev->owning_port = sci_port;
+	sci_dev->owning_port = iport;
 	sci_dev->started_request_count = 0;
 
 	sci_init_sm(&sci_dev->sm, scic_sds_remote_device_state_table, SCI_DEV_INITIAL);
@@ -1090,20 +1090,20 @@ static void scic_remote_device_construct(struct scic_sds_port *sci_port,
  * sata-only controller instance.
  * SCI_FAILURE_INSUFFICIENT_RESOURCES - remote node contexts exhausted.
  */
-static enum sci_status scic_remote_device_da_construct(struct scic_sds_port *sci_port,
+static enum sci_status scic_remote_device_da_construct(struct isci_port *iport,
 						       struct scic_sds_remote_device *sci_dev)
 {
 	enum sci_status status;
 	struct domain_device *dev = sci_dev_to_domain(sci_dev);
 
-	scic_remote_device_construct(sci_port, sci_dev);
+	scic_remote_device_construct(iport, sci_dev);
 
 	/*
 	 * This information is request to determine how many remote node context
 	 * entries will be needed to store the remote node.
 	 */
 	sci_dev->is_direct_attached = true;
-	status = scic_sds_controller_allocate_remote_node_context(sci_port->owning_controller,
+	status = scic_sds_controller_allocate_remote_node_context(iport->owning_controller,
 								  sci_dev,
 								  &sci_dev->rnc.remote_node_index);
 
@@ -1116,7 +1116,7 @@ static enum sci_status scic_remote_device_da_construct(struct scic_sds_port *sci
 	else
 		return SCI_FAILURE_UNSUPPORTED_PROTOCOL;
 
-	sci_dev->connection_rate = scic_sds_port_get_max_allowed_speed(sci_port);
+	sci_dev->connection_rate = scic_sds_port_get_max_allowed_speed(iport);
 
 	/* / @todo Should I assign the port width by reading all of the phys on the port? */
 	sci_dev->device_port_width = 1;
@@ -1136,15 +1136,15 @@ static enum sci_status scic_remote_device_da_construct(struct scic_sds_port *sci
  * sata-only controller instance.
  * SCI_FAILURE_INSUFFICIENT_RESOURCES - remote node contexts exhausted.
  */
-static enum sci_status scic_remote_device_ea_construct(struct scic_sds_port *sci_port,
+static enum sci_status scic_remote_device_ea_construct(struct isci_port *iport,
 						       struct scic_sds_remote_device *sci_dev)
 {
 	struct domain_device *dev = sci_dev_to_domain(sci_dev);
 	enum sci_status status;
 
-	scic_remote_device_construct(sci_port, sci_dev);
+	scic_remote_device_construct(iport, sci_dev);
 
-	status = scic_sds_controller_allocate_remote_node_context(sci_port->owning_controller,
+	status = scic_sds_controller_allocate_remote_node_context(iport->owning_controller,
 								  sci_dev,
 								  &sci_dev->rnc.remote_node_index);
 	if (status != SCI_SUCCESS)
@@ -1163,7 +1163,7 @@ static enum sci_status scic_remote_device_ea_construct(struct scic_sds_port *sci
 	 * connection the logical link rate is that same as the
 	 * physical.  Furthermore, the SAS-2 and SAS-1.1 fields overlay
 	 * one another, so this code works for both situations. */
-	sci_dev->connection_rate = min_t(u16, scic_sds_port_get_max_allowed_speed(sci_port),
+	sci_dev->connection_rate = min_t(u16, scic_sds_port_get_max_allowed_speed(iport),
 					 dev->linkrate);
 
 	/* / @todo Should I assign the port width by reading all of the phys on the port? */
@@ -1212,15 +1212,14 @@ static enum sci_status scic_remote_device_start(struct scic_sds_remote_device *s
 static enum sci_status isci_remote_device_construct(struct isci_port *iport,
 						    struct isci_remote_device *idev)
 {
-	struct scic_sds_port *sci_port = &iport->sci;
 	struct isci_host *ihost = iport->isci_host;
 	struct domain_device *dev = idev->domain_dev;
 	enum sci_status status;
 
 	if (dev->parent && dev_is_expander(dev->parent))
-		status = scic_remote_device_ea_construct(sci_port, &idev->sci);
+		status = scic_remote_device_ea_construct(iport, &idev->sci);
 	else
-		status = scic_remote_device_da_construct(sci_port, &idev->sci);
+		status = scic_remote_device_da_construct(iport, &idev->sci);
 
 	if (status != SCI_SUCCESS) {
 		dev_dbg(&ihost->pdev->dev, "%s: construct failed: %d\n",

commit 76802ce6756d605fbd7a9a43c196e9a471b3e57c
Author: Dan Williams <dan.j.williams@intel.com>
Date:   Wed Jun 29 09:45:48 2011 -0700

    isci: fix scic_sds_remote_device_terminate_requests
    
    Commit 0815632 "isci: unify remote_device stop_handlers" introduced the
    possibility that not all requests get terminated if we reach the
    request_count.  Now that we properly reference count devices we don't
    need this self-defense and can do the straightforward scan of all active
    requests.
    
    Reported-by: Jeff Skirvin <jeffrey.d.skirvin@intel.com>
    Acked-by: Jeff Skirvin <jeffrey.d.skirvin@intel.com>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/drivers/scsi/isci/remote_device.c b/drivers/scsi/isci/remote_device.c
index a81a864d35c4..71ab9081fe24 100644
--- a/drivers/scsi/isci/remote_device.c
+++ b/drivers/scsi/isci/remote_device.c
@@ -137,10 +137,10 @@ static enum sci_status scic_sds_remote_device_terminate_requests(struct scic_sds
 {
 	struct scic_sds_controller *scic = sci_dev->owning_port->owning_controller;
 	struct isci_host *ihost = scic_to_ihost(scic);
-	u32 i, request_count = sci_dev->started_request_count;
 	enum sci_status status  = SCI_SUCCESS;
+	u32 i;
 
-	for (i = 0; i < SCI_MAX_IO_REQUESTS && i < request_count; i++) {
+	for (i = 0; i < SCI_MAX_IO_REQUESTS; i++) {
 		struct isci_request *ireq = ihost->reqs[i];
 		enum sci_status s;
 

commit 852809559e4680ba4768262a6c3d21454fcd460e
Author: Dan Williams <dan.j.williams@intel.com>
Date:   Tue Jun 28 15:05:53 2011 -0700

    isci: unify isci_phy and scic_sds_phy
    
    They are one in the same object so remove the distinction.  The near
    duplicate fields (owning_port, and isci_port) will be cleaned up
    after the scic_sds_port isci_port unification.
    
    Reported-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/drivers/scsi/isci/remote_device.c b/drivers/scsi/isci/remote_device.c
index c7cb0c54df57..a81a864d35c4 100644
--- a/drivers/scsi/isci/remote_device.c
+++ b/drivers/scsi/isci/remote_device.c
@@ -1389,7 +1389,7 @@ int isci_remote_device_found(struct domain_device *domain_dev)
 	sas_port = domain_dev->port;
 	sas_phy = list_first_entry(&sas_port->phy_list, struct asd_sas_phy,
 				   port_phy_el);
-	isci_phy = to_isci_phy(sas_phy);
+	isci_phy = to_iphy(sas_phy);
 	isci_port = isci_phy->isci_port;
 
 	/* we are being called for a device on this port,

commit 5076a1a97e2fa61c847a5fdd4b1991faf7716da6
Author: Dan Williams <dan.j.williams@intel.com>
Date:   Mon Jun 27 14:57:03 2011 -0700

    isci: unify isci_request and scic_sds_request
    
    They are one in the same object so remove the distinction.  The near
    duplicate fields (owning_controller, and isci_host) will be cleaned up
    after the scic_sds_contoller isci_host unification.
    
    Reported-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/drivers/scsi/isci/remote_device.c b/drivers/scsi/isci/remote_device.c
index 5a86bb1e96df..c7cb0c54df57 100644
--- a/drivers/scsi/isci/remote_device.c
+++ b/drivers/scsi/isci/remote_device.c
@@ -94,7 +94,7 @@ static void isci_remote_device_not_ready(struct isci_host *ihost,
 
 			scic_controller_terminate_request(&ihost->sci,
 							  &idev->sci,
-							  &ireq->sci);
+							  ireq);
 		}
 		/* Fall through into the default case... */
 	default:
@@ -142,14 +142,13 @@ static enum sci_status scic_sds_remote_device_terminate_requests(struct scic_sds
 
 	for (i = 0; i < SCI_MAX_IO_REQUESTS && i < request_count; i++) {
 		struct isci_request *ireq = ihost->reqs[i];
-		struct scic_sds_request *sci_req = &ireq->sci;
 		enum sci_status s;
 
 		if (!test_bit(IREQ_ACTIVE, &ireq->flags) ||
-		    sci_req->target_device != sci_dev)
+		    ireq->target_device != sci_dev)
 			continue;
 
-		s = scic_controller_terminate_request(scic, sci_dev, sci_req);
+		s = scic_controller_terminate_request(scic, sci_dev, ireq);
 		if (s != SCI_SUCCESS)
 			status = s;
 	}
@@ -299,7 +298,7 @@ enum sci_status scic_sds_remote_device_frame_handler(struct scic_sds_remote_devi
 	case SCI_DEV_STOPPING:
 	case SCI_DEV_FAILED:
 	case SCI_DEV_RESETTING: {
-		struct scic_sds_request *sci_req;
+		struct isci_request *ireq;
 		struct ssp_frame_hdr hdr;
 		void *frame_header;
 		ssize_t word_cnt;
@@ -313,10 +312,10 @@ enum sci_status scic_sds_remote_device_frame_handler(struct scic_sds_remote_devi
 		word_cnt = sizeof(hdr) / sizeof(u32);
 		sci_swab32_cpy(&hdr, frame_header, word_cnt);
 
-		sci_req = scic_request_by_tag(scic, be16_to_cpu(hdr.tag));
-		if (sci_req && sci_req->target_device == sci_dev) {
+		ireq = scic_request_by_tag(scic, be16_to_cpu(hdr.tag));
+		if (ireq && ireq->target_device == sci_dev) {
 			/* The IO request is now in charge of releasing the frame */
-			status = scic_sds_io_request_frame_handler(sci_req, frame_index);
+			status = scic_sds_io_request_frame_handler(ireq, frame_index);
 		} else {
 			/* We could not map this tag to a valid IO
 			 * request Just toss the frame and continue
@@ -448,14 +447,14 @@ enum sci_status scic_sds_remote_device_event_handler(struct scic_sds_remote_devi
 }
 
 static void scic_sds_remote_device_start_request(struct scic_sds_remote_device *sci_dev,
-						 struct scic_sds_request *sci_req,
+						 struct isci_request *ireq,
 						 enum sci_status status)
 {
 	struct scic_sds_port *sci_port = sci_dev->owning_port;
 
 	/* cleanup requests that failed after starting on the port */
 	if (status != SCI_SUCCESS)
-		scic_sds_port_complete_io(sci_port, sci_dev, sci_req);
+		scic_sds_port_complete_io(sci_port, sci_dev, ireq);
 	else {
 		kref_get(&sci_dev_to_idev(sci_dev)->kref);
 		scic_sds_remote_device_increment_request_count(sci_dev);
@@ -464,12 +463,11 @@ static void scic_sds_remote_device_start_request(struct scic_sds_remote_device *
 
 enum sci_status scic_sds_remote_device_start_io(struct scic_sds_controller *scic,
 						struct scic_sds_remote_device *sci_dev,
-						struct scic_sds_request *sci_req)
+						struct isci_request *ireq)
 {
 	struct sci_base_state_machine *sm = &sci_dev->sm;
 	enum scic_sds_remote_device_states state = sm->current_state_id;
 	struct scic_sds_port *sci_port = sci_dev->owning_port;
-	struct isci_request *ireq = sci_req_to_ireq(sci_req);
 	enum sci_status status;
 
 	switch (state) {
@@ -491,15 +489,15 @@ enum sci_status scic_sds_remote_device_start_io(struct scic_sds_controller *scic
 		 * successful it will start the request for the port object then
 		 * increment its own request count.
 		 */
-		status = scic_sds_port_start_io(sci_port, sci_dev, sci_req);
+		status = scic_sds_port_start_io(sci_port, sci_dev, ireq);
 		if (status != SCI_SUCCESS)
 			return status;
 
-		status = scic_sds_remote_node_context_start_io(&sci_dev->rnc, sci_req);
+		status = scic_sds_remote_node_context_start_io(&sci_dev->rnc, ireq);
 		if (status != SCI_SUCCESS)
 			break;
 
-		status = scic_sds_request_start(sci_req);
+		status = scic_sds_request_start(ireq);
 		break;
 	case SCI_STP_DEV_IDLE: {
 		/* handle the start io operation for a sata device that is in
@@ -513,22 +511,22 @@ enum sci_status scic_sds_remote_device_start_io(struct scic_sds_controller *scic
 		enum scic_sds_remote_device_states new_state;
 		struct sas_task *task = isci_request_access_task(ireq);
 
-		status = scic_sds_port_start_io(sci_port, sci_dev, sci_req);
+		status = scic_sds_port_start_io(sci_port, sci_dev, ireq);
 		if (status != SCI_SUCCESS)
 			return status;
 
-		status = scic_sds_remote_node_context_start_io(&sci_dev->rnc, sci_req);
+		status = scic_sds_remote_node_context_start_io(&sci_dev->rnc, ireq);
 		if (status != SCI_SUCCESS)
 			break;
 
-		status = scic_sds_request_start(sci_req);
+		status = scic_sds_request_start(ireq);
 		if (status != SCI_SUCCESS)
 			break;
 
 		if (task->ata_task.use_ncq)
 			new_state = SCI_STP_DEV_NCQ;
 		else {
-			sci_dev->working_request = sci_req;
+			sci_dev->working_request = ireq;
 			new_state = SCI_STP_DEV_CMD;
 		}
 		sci_change_state(sm, new_state);
@@ -538,15 +536,15 @@ enum sci_status scic_sds_remote_device_start_io(struct scic_sds_controller *scic
 		struct sas_task *task = isci_request_access_task(ireq);
 
 		if (task->ata_task.use_ncq) {
-			status = scic_sds_port_start_io(sci_port, sci_dev, sci_req);
+			status = scic_sds_port_start_io(sci_port, sci_dev, ireq);
 			if (status != SCI_SUCCESS)
 				return status;
 
-			status = scic_sds_remote_node_context_start_io(&sci_dev->rnc, sci_req);
+			status = scic_sds_remote_node_context_start_io(&sci_dev->rnc, ireq);
 			if (status != SCI_SUCCESS)
 				break;
 
-			status = scic_sds_request_start(sci_req);
+			status = scic_sds_request_start(ireq);
 		} else
 			return SCI_FAILURE_INVALID_STATE;
 		break;
@@ -554,19 +552,19 @@ enum sci_status scic_sds_remote_device_start_io(struct scic_sds_controller *scic
 	case SCI_STP_DEV_AWAIT_RESET:
 		return SCI_FAILURE_REMOTE_DEVICE_RESET_REQUIRED;
 	case SCI_SMP_DEV_IDLE:
-		status = scic_sds_port_start_io(sci_port, sci_dev, sci_req);
+		status = scic_sds_port_start_io(sci_port, sci_dev, ireq);
 		if (status != SCI_SUCCESS)
 			return status;
 
-		status = scic_sds_remote_node_context_start_io(&sci_dev->rnc, sci_req);
+		status = scic_sds_remote_node_context_start_io(&sci_dev->rnc, ireq);
 		if (status != SCI_SUCCESS)
 			break;
 
-		status = scic_sds_request_start(sci_req);
+		status = scic_sds_request_start(ireq);
 		if (status != SCI_SUCCESS)
 			break;
 
-		sci_dev->working_request = sci_req;
+		sci_dev->working_request = ireq;
 		sci_change_state(&sci_dev->sm, SCI_SMP_DEV_CMD);
 		break;
 	case SCI_STP_DEV_CMD:
@@ -577,21 +575,21 @@ enum sci_status scic_sds_remote_device_start_io(struct scic_sds_controller *scic
 		return SCI_FAILURE_INVALID_STATE;
 	}
 
-	scic_sds_remote_device_start_request(sci_dev, sci_req, status);
+	scic_sds_remote_device_start_request(sci_dev, ireq, status);
 	return status;
 }
 
 static enum sci_status common_complete_io(struct scic_sds_port *sci_port,
 					  struct scic_sds_remote_device *sci_dev,
-					  struct scic_sds_request *sci_req)
+					  struct isci_request *ireq)
 {
 	enum sci_status status;
 
-	status = scic_sds_request_complete(sci_req);
+	status = scic_sds_request_complete(ireq);
 	if (status != SCI_SUCCESS)
 		return status;
 
-	status = scic_sds_port_complete_io(sci_port, sci_dev, sci_req);
+	status = scic_sds_port_complete_io(sci_port, sci_dev, ireq);
 	if (status != SCI_SUCCESS)
 		return status;
 
@@ -601,7 +599,7 @@ static enum sci_status common_complete_io(struct scic_sds_port *sci_port,
 
 enum sci_status scic_sds_remote_device_complete_io(struct scic_sds_controller *scic,
 						   struct scic_sds_remote_device *sci_dev,
-						   struct scic_sds_request *sci_req)
+						   struct isci_request *ireq)
 {
 	struct sci_base_state_machine *sm = &sci_dev->sm;
 	enum scic_sds_remote_device_states state = sm->current_state_id;
@@ -623,16 +621,16 @@ enum sci_status scic_sds_remote_device_complete_io(struct scic_sds_controller *s
 	case SCI_DEV_READY:
 	case SCI_STP_DEV_AWAIT_RESET:
 	case SCI_DEV_RESETTING:
-		status = common_complete_io(sci_port, sci_dev, sci_req);
+		status = common_complete_io(sci_port, sci_dev, ireq);
 		break;
 	case SCI_STP_DEV_CMD:
 	case SCI_STP_DEV_NCQ:
 	case SCI_STP_DEV_NCQ_ERROR:
-		status = common_complete_io(sci_port, sci_dev, sci_req);
+		status = common_complete_io(sci_port, sci_dev, ireq);
 		if (status != SCI_SUCCESS)
 			break;
 
-		if (sci_req->sci_status == SCI_FAILURE_REMOTE_DEVICE_RESET_REQUIRED) {
+		if (ireq->sci_status == SCI_FAILURE_REMOTE_DEVICE_RESET_REQUIRED) {
 			/* This request causes hardware error, device needs to be Lun Reset.
 			 * So here we force the state machine to IDLE state so the rest IOs
 			 * can reach RNC state handler, these IOs will be completed by RNC with
@@ -643,13 +641,13 @@ enum sci_status scic_sds_remote_device_complete_io(struct scic_sds_controller *s
 			sci_change_state(sm, SCI_STP_DEV_IDLE);
 		break;
 	case SCI_SMP_DEV_CMD:
-		status = common_complete_io(sci_port, sci_dev, sci_req);
+		status = common_complete_io(sci_port, sci_dev, ireq);
 		if (status != SCI_SUCCESS)
 			break;
 		sci_change_state(sm, SCI_SMP_DEV_IDLE);
 		break;
 	case SCI_DEV_STOPPING:
-		status = common_complete_io(sci_port, sci_dev, sci_req);
+		status = common_complete_io(sci_port, sci_dev, ireq);
 		if (status != SCI_SUCCESS)
 			break;
 
@@ -664,7 +662,7 @@ enum sci_status scic_sds_remote_device_complete_io(struct scic_sds_controller *s
 		dev_err(scirdev_to_dev(sci_dev),
 			"%s: Port:0x%p Device:0x%p Request:0x%p Status:0x%x "
 			"could not complete\n", __func__, sci_port,
-			sci_dev, sci_req, status);
+			sci_dev, ireq, status);
 	else
 		isci_put_device(sci_dev_to_idev(sci_dev));
 
@@ -682,7 +680,7 @@ static void scic_sds_remote_device_continue_request(void *dev)
 
 enum sci_status scic_sds_remote_device_start_task(struct scic_sds_controller *scic,
 						  struct scic_sds_remote_device *sci_dev,
-						  struct scic_sds_request *sci_req)
+						  struct isci_request *ireq)
 {
 	struct sci_base_state_machine *sm = &sci_dev->sm;
 	enum scic_sds_remote_device_states state = sm->current_state_id;
@@ -708,15 +706,15 @@ enum sci_status scic_sds_remote_device_start_task(struct scic_sds_controller *sc
 	case SCI_STP_DEV_NCQ:
 	case SCI_STP_DEV_NCQ_ERROR:
 	case SCI_STP_DEV_AWAIT_RESET:
-		status = scic_sds_port_start_io(sci_port, sci_dev, sci_req);
+		status = scic_sds_port_start_io(sci_port, sci_dev, ireq);
 		if (status != SCI_SUCCESS)
 			return status;
 
-		status = scic_sds_remote_node_context_start_task(&sci_dev->rnc, sci_req);
+		status = scic_sds_remote_node_context_start_task(&sci_dev->rnc, ireq);
 		if (status != SCI_SUCCESS)
 			goto out;
 
-		status = scic_sds_request_start(sci_req);
+		status = scic_sds_request_start(ireq);
 		if (status != SCI_SUCCESS)
 			goto out;
 
@@ -724,7 +722,7 @@ enum sci_status scic_sds_remote_device_start_task(struct scic_sds_controller *sc
 		 * replace the request that probably resulted in the task
 		 * management request.
 		 */
-		sci_dev->working_request = sci_req;
+		sci_dev->working_request = ireq;
 		sci_change_state(sm, SCI_STP_DEV_CMD);
 
 		/* The remote node context must cleanup the TCi to NCQ mapping
@@ -741,25 +739,25 @@ enum sci_status scic_sds_remote_device_start_task(struct scic_sds_controller *sc
 						    sci_dev);
 
 	out:
-		scic_sds_remote_device_start_request(sci_dev, sci_req, status);
+		scic_sds_remote_device_start_request(sci_dev, ireq, status);
 		/* We need to let the controller start request handler know that
 		 * it can't post TC yet. We will provide a callback function to
 		 * post TC when RNC gets resumed.
 		 */
 		return SCI_FAILURE_RESET_DEVICE_PARTIAL_SUCCESS;
 	case SCI_DEV_READY:
-		status = scic_sds_port_start_io(sci_port, sci_dev, sci_req);
+		status = scic_sds_port_start_io(sci_port, sci_dev, ireq);
 		if (status != SCI_SUCCESS)
 			return status;
 
-		status = scic_sds_remote_node_context_start_task(&sci_dev->rnc, sci_req);
+		status = scic_sds_remote_node_context_start_task(&sci_dev->rnc, ireq);
 		if (status != SCI_SUCCESS)
 			break;
 
-		status = scic_sds_request_start(sci_req);
+		status = scic_sds_request_start(ireq);
 		break;
 	}
-	scic_sds_remote_device_start_request(sci_dev, sci_req, status);
+	scic_sds_remote_device_start_request(sci_dev, ireq, status);
 
 	return status;
 }

commit db0562509800a2d4cb5cb14a66413c30484f165c
Author: Dan Williams <dan.j.williams@intel.com>
Date:   Fri Jun 17 14:18:39 2011 -0700

    isci: preallocate requests
    
    the dma_pool interface is optimized for object_size << page_size which
    is not the case with isci_request objects and the dma_pool routines show
    up in the top of the profile.
    
    The old io_request_table which tracked whether tci slots were in-flight
    or not is replaced with an IREQ_ACTIVE flag per request.
    
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/drivers/scsi/isci/remote_device.c b/drivers/scsi/isci/remote_device.c
index c5ce0f0f3645..5a86bb1e96df 100644
--- a/drivers/scsi/isci/remote_device.c
+++ b/drivers/scsi/isci/remote_device.c
@@ -136,16 +136,19 @@ static void rnc_destruct_done(void *_dev)
 static enum sci_status scic_sds_remote_device_terminate_requests(struct scic_sds_remote_device *sci_dev)
 {
 	struct scic_sds_controller *scic = sci_dev->owning_port->owning_controller;
+	struct isci_host *ihost = scic_to_ihost(scic);
 	u32 i, request_count = sci_dev->started_request_count;
 	enum sci_status status  = SCI_SUCCESS;
 
 	for (i = 0; i < SCI_MAX_IO_REQUESTS && i < request_count; i++) {
-		struct scic_sds_request *sci_req;
+		struct isci_request *ireq = ihost->reqs[i];
+		struct scic_sds_request *sci_req = &ireq->sci;
 		enum sci_status s;
 
-		sci_req = scic->io_request_table[i];
-		if (!sci_req || sci_req->target_device != sci_dev)
+		if (!test_bit(IREQ_ACTIVE, &ireq->flags) ||
+		    sci_req->target_device != sci_dev)
 			continue;
+
 		s = scic_controller_terminate_request(scic, sci_dev, sci_req);
 		if (s != SCI_SUCCESS)
 			status = s;

commit 9274f45ea551421cd3bf329de9dd8d1e6208285a
Author: Jeff Skirvin <jeffrey.d.skirvin@intel.com>
Date:   Thu Jun 23 17:09:02 2011 -0700

    isci: Terminate dev requests on FIS err bit rx in NCQ
    
    When the remote device transitions to a not-ready state because of
    an NCQ error condition, all outstanding requests to that device
    are terminated and completed to libsas on the normal path.  The
    device then waits for a READ LOG EXT command to issue on the task
    management path.
    
    Signed-off-by: Jeff Skirvin <jeffrey.d.skirvin@intel.com>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/drivers/scsi/isci/remote_device.c b/drivers/scsi/isci/remote_device.c
index 9f45c2ba7307..c5ce0f0f3645 100644
--- a/drivers/scsi/isci/remote_device.c
+++ b/drivers/scsi/isci/remote_device.c
@@ -68,17 +68,39 @@
  * @isci_host: This parameter specifies the isci host object.
  * @isci_device: This parameter specifies the remote device
  *
+ * scic_lock is held on entrance to this function.
  */
 static void isci_remote_device_not_ready(struct isci_host *ihost,
 				  struct isci_remote_device *idev, u32 reason)
 {
+	struct isci_request * ireq;
+
 	dev_dbg(&ihost->pdev->dev,
 		"%s: isci_device = %p\n", __func__, idev);
 
-	if (reason == SCIC_REMOTE_DEVICE_NOT_READY_STOP_REQUESTED)
+	switch (reason) {
+	case SCIC_REMOTE_DEVICE_NOT_READY_STOP_REQUESTED:
 		set_bit(IDEV_GONE, &idev->flags);
-	else
+		break;
+	case SCIC_REMOTE_DEVICE_NOT_READY_SATA_SDB_ERROR_FIS_RECEIVED:
+		set_bit(IDEV_IO_NCQERROR, &idev->flags);
+
+		/* Kill all outstanding requests for the device. */
+		list_for_each_entry(ireq, &idev->reqs_in_process, dev_node) {
+
+			dev_dbg(&ihost->pdev->dev,
+				"%s: isci_device = %p request = %p\n",
+				__func__, idev, ireq);
+
+			scic_controller_terminate_request(&ihost->sci,
+							  &idev->sci,
+							  &ireq->sci);
+		}
+		/* Fall through into the default case... */
+	default:
 		clear_bit(IDEV_IO_READY, &idev->flags);
+		break;
+	}
 }
 
 /**
@@ -94,6 +116,7 @@ static void isci_remote_device_ready(struct isci_host *ihost, struct isci_remote
 	dev_dbg(&ihost->pdev->dev,
 		"%s: idev = %p\n", __func__, idev);
 
+	clear_bit(IDEV_IO_NCQERROR, &idev->flags);
 	set_bit(IDEV_IO_READY, &idev->flags);
 	if (test_and_clear_bit(IDEV_START_PENDING, &idev->flags))
 		wake_up(&ihost->eventq);

commit ff60639dc9a461883db9192d2da0674a00339f12
Author: Dan Williams <dan.j.williams@intel.com>
Date:   Fri Jun 17 13:34:43 2011 -0700

    isci: kill device_sequence
    
    Now that we have upleveled device reassignment protection to the
    isci_remote_device reference count we no longer need this level of
    self-defense.
    
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/drivers/scsi/isci/remote_device.c b/drivers/scsi/isci/remote_device.c
index c2e5c05be0cb..9f45c2ba7307 100644
--- a/drivers/scsi/isci/remote_device.c
+++ b/drivers/scsi/isci/remote_device.c
@@ -887,8 +887,6 @@ static void scic_sds_remote_device_ready_state_enter(struct sci_base_state_machi
 	struct isci_remote_device *idev = sci_dev_to_idev(sci_dev);
 	struct domain_device *dev = idev->domain_dev;
 
-	scic->remote_device_sequence[sci_dev->rnc.remote_node_index]++;
-
 	if (dev->dev_type == SATA_DEV || (dev->tproto & SAS_PROTOCOL_SATA)) {
 		sci_change_state(&sci_dev->sm, SCI_STP_DEV_IDLE);
 	} else if (dev_is_expander(dev)) {

commit f2088267514b39af1a94409168101527769a911c
Author: Dan Williams <dan.j.williams@intel.com>
Date:   Thu Jun 16 11:26:12 2011 -0700

    isci: kill isci_remote_device_change_state()
    
    Now that "stopping/stopped" are one in the same and signalled by a NULL device
    pointer the rest of the device status infrastructure can be removed (->status
    and ->state_lock).  The "not ready for i/o state" is replaced with a state
    flag, and is evaluated under scic_lock so that we don't see transients from
    taking the device reference to submitting the i/o.
    
    This also fixes a potential leakage of can_queue slots in the rare case that
    SAS_TASK_ABORTED is set at submission.
    
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/drivers/scsi/isci/remote_device.c b/drivers/scsi/isci/remote_device.c
index ab5f9868e4ef..c2e5c05be0cb 100644
--- a/drivers/scsi/isci/remote_device.c
+++ b/drivers/scsi/isci/remote_device.c
@@ -61,24 +61,6 @@
 #include "scu_event_codes.h"
 #include "task.h"
 
-/**
- * isci_remote_device_change_state() - This function gets the status of the
- *    remote_device object.
- * @isci_device: This parameter points to the isci_remote_device object
- *
- * status of the object as a isci_status enum.
- */
-void isci_remote_device_change_state(
-	struct isci_remote_device *isci_device,
-	enum isci_status status)
-{
-	unsigned long flags;
-
-	spin_lock_irqsave(&isci_device->state_lock, flags);
-	isci_device->status = status;
-	spin_unlock_irqrestore(&isci_device->state_lock, flags);
-}
-
 /**
  * isci_remote_device_not_ready() - This function is called by the scic when
  *    the remote device is not ready. We mark the isci device as ready (not
@@ -96,8 +78,7 @@ static void isci_remote_device_not_ready(struct isci_host *ihost,
 	if (reason == SCIC_REMOTE_DEVICE_NOT_READY_STOP_REQUESTED)
 		set_bit(IDEV_GONE, &idev->flags);
 	else
-		/* device ready is actually a "not ready for io" state. */
-		isci_remote_device_change_state(idev, isci_ready);
+		clear_bit(IDEV_IO_READY, &idev->flags);
 }
 
 /**
@@ -113,7 +94,7 @@ static void isci_remote_device_ready(struct isci_host *ihost, struct isci_remote
 	dev_dbg(&ihost->pdev->dev,
 		"%s: idev = %p\n", __func__, idev);
 
-	isci_remote_device_change_state(idev, isci_ready_for_io);
+	set_bit(IDEV_IO_READY, &idev->flags);
 	if (test_and_clear_bit(IDEV_START_PENDING, &idev->flags))
 		wake_up(&ihost->eventq);
 }
@@ -871,26 +852,6 @@ static void isci_remote_device_deconstruct(struct isci_host *ihost, struct isci_
 	isci_put_device(idev);
 }
 
-/**
- * isci_remote_device_stop_complete() - This function is called by the scic
- *    when the remote device stop has completed. We mark the isci device as not
- *    ready and remove the isci remote device.
- * @ihost: This parameter specifies the isci host object.
- * @idev: This parameter specifies the remote device.
- * @status: This parameter specifies status of the completion.
- *
- */
-static void isci_remote_device_stop_complete(struct isci_host *ihost,
-					     struct isci_remote_device *idev)
-{
-	dev_dbg(&ihost->pdev->dev, "%s: complete idev = %p\n", __func__, idev);
-
-	isci_remote_device_change_state(idev, isci_stopped);
-
-	/* after stop, we can tear down resources. */
-	isci_remote_device_deconstruct(ihost, idev);
-}
-
 static void scic_sds_remote_device_stopped_state_enter(struct sci_base_state_machine *sm)
 {
 	struct scic_sds_remote_device *sci_dev = container_of(sm, typeof(*sci_dev), sm);
@@ -903,7 +864,7 @@ static void scic_sds_remote_device_stopped_state_enter(struct sci_base_state_mac
 	 */
 	prev_state = sci_dev->sm.previous_state_id;
 	if (prev_state == SCI_DEV_STOPPING)
-		isci_remote_device_stop_complete(scic_to_ihost(scic), idev);
+		isci_remote_device_deconstruct(scic_to_ihost(scic), idev);
 
 	scic_sds_controller_remote_device_stopped(scic, sci_dev);
 }
@@ -1301,8 +1262,6 @@ isci_remote_device_alloc(struct isci_host *ihost, struct isci_port *iport)
 	if (WARN_ONCE(!list_empty(&idev->node), "found non-idle remote device\n"))
 		return NULL;
 
-	isci_remote_device_change_state(idev, isci_freed);
-
 	return idev;
 }
 
@@ -1315,6 +1274,7 @@ void isci_remote_device_release(struct kref *kref)
 	idev->isci_port = NULL;
 	clear_bit(IDEV_START_PENDING, &idev->flags);
 	clear_bit(IDEV_STOP_PENDING, &idev->flags);
+	clear_bit(IDEV_IO_READY, &idev->flags);
 	clear_bit(IDEV_GONE, &idev->flags);
 	clear_bit(IDEV_EH, &idev->flags);
 	smp_mb__before_clear_bit();
@@ -1341,7 +1301,6 @@ enum sci_status isci_remote_device_stop(struct isci_host *ihost, struct isci_rem
 	spin_lock_irqsave(&ihost->scic_lock, flags);
 	idev->domain_dev->lldd_dev = NULL; /* disable new lookups */
 	set_bit(IDEV_GONE, &idev->flags);
-	isci_remote_device_change_state(idev, isci_stopping);
 	spin_unlock_irqrestore(&ihost->scic_lock, flags);
 
 	/* Kill all outstanding requests. */
@@ -1430,7 +1389,6 @@ int isci_remote_device_found(struct domain_device *domain_dev)
 	spin_lock_irq(&isci_host->scic_lock);
 	isci_device->domain_dev = domain_dev;
 	isci_device->isci_port = isci_port;
-	isci_remote_device_change_state(isci_device, isci_starting);
 	list_add_tail(&isci_device->node, &isci_port->remote_dev_list);
 
 	set_bit(IDEV_START_PENDING, &isci_device->flags);

commit 209fae14fabfd48525e5630bebbbd4ca15090c60
Author: Dan Williams <dan.j.williams@intel.com>
Date:   Mon Jun 13 17:39:44 2011 -0700

    isci: atomic device lookup and reference counting
    
    We have unsafe references to remote devices that are notified to
    disappear at lldd_dev_gone.  In order to clean this up we need a single
    canonical source for device lookups and stable references once a lookup
    succeeds.  Towards that end guarantee that domain_device.lldd_dev is
    NULL as soon as we start the process of stopping a device.  Any code
    path that wants to safely lookup a remote device must do so through
    task->dev->lldd_dev (isci_lookup_device()).
    
    For in-flight references outside of scic_lock we need reference counting
    to ensure that the device is not recycled before we are done with it.
    Simplify device back references to just scic_sds_request.target_device
    which is now the only permissible internal reference that is maintained
    relative to the reference count.
    
    There were two occasions where we wanted new i/o's to be treated as
    SAS_TASK_UNDELIVERED but where the domain_dev->lldd_dev link is still
    intact.  Introduce a 'gone' flag to prevent i/o while waiting for libsas
    to take action on the port down event.
    
    One 'core' leftover is that we currently call
    scic_remote_device_destruct() from isci_remote_device_deconstruct()
    which is called when the 'core' says the device is stopped.  It would be
    more natural for the final put to trigger
    isci_remote_device_deconstruct() but this implementation is deferred as
    it requires other changes.
    
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/drivers/scsi/isci/remote_device.c b/drivers/scsi/isci/remote_device.c
index 45592ad33c3b..ab5f9868e4ef 100644
--- a/drivers/scsi/isci/remote_device.c
+++ b/drivers/scsi/isci/remote_device.c
@@ -94,7 +94,7 @@ static void isci_remote_device_not_ready(struct isci_host *ihost,
 		"%s: isci_device = %p\n", __func__, idev);
 
 	if (reason == SCIC_REMOTE_DEVICE_NOT_READY_STOP_REQUESTED)
-		isci_remote_device_change_state(idev, isci_stopping);
+		set_bit(IDEV_GONE, &idev->flags);
 	else
 		/* device ready is actually a "not ready for io" state. */
 		isci_remote_device_change_state(idev, isci_ready);
@@ -449,8 +449,10 @@ static void scic_sds_remote_device_start_request(struct scic_sds_remote_device *
 	/* cleanup requests that failed after starting on the port */
 	if (status != SCI_SUCCESS)
 		scic_sds_port_complete_io(sci_port, sci_dev, sci_req);
-	else
+	else {
+		kref_get(&sci_dev_to_idev(sci_dev)->kref);
 		scic_sds_remote_device_increment_request_count(sci_dev);
+	}
 }
 
 enum sci_status scic_sds_remote_device_start_io(struct scic_sds_controller *scic,
@@ -656,6 +658,8 @@ enum sci_status scic_sds_remote_device_complete_io(struct scic_sds_controller *s
 			"%s: Port:0x%p Device:0x%p Request:0x%p Status:0x%x "
 			"could not complete\n", __func__, sci_port,
 			sci_dev, sci_req, status);
+	else
+		isci_put_device(sci_dev_to_idev(sci_dev));
 
 	return status;
 }
@@ -860,23 +864,11 @@ static void isci_remote_device_deconstruct(struct isci_host *ihost, struct isci_
 	 * here should go through isci_remote_device_nuke_requests.
 	 * If we hit this condition, we will need a way to complete
 	 * io requests in process */
-	while (!list_empty(&idev->reqs_in_process)) {
-
-		dev_err(&ihost->pdev->dev,
-			"%s: ** request list not empty! **\n", __func__);
-		BUG();
-	}
+	BUG_ON(!list_empty(&idev->reqs_in_process));
 
 	scic_remote_device_destruct(&idev->sci);
-	idev->domain_dev->lldd_dev = NULL;
-	idev->domain_dev = NULL;
-	idev->isci_port = NULL;
 	list_del_init(&idev->node);
-
-	clear_bit(IDEV_START_PENDING, &idev->flags);
-	clear_bit(IDEV_STOP_PENDING, &idev->flags);
-	clear_bit(IDEV_EH, &idev->flags);
-	wake_up(&ihost->eventq);
+	isci_put_device(idev);
 }
 
 /**
@@ -1314,6 +1306,22 @@ isci_remote_device_alloc(struct isci_host *ihost, struct isci_port *iport)
 	return idev;
 }
 
+void isci_remote_device_release(struct kref *kref)
+{
+	struct isci_remote_device *idev = container_of(kref, typeof(*idev), kref);
+	struct isci_host *ihost = idev->isci_port->isci_host;
+
+	idev->domain_dev = NULL;
+	idev->isci_port = NULL;
+	clear_bit(IDEV_START_PENDING, &idev->flags);
+	clear_bit(IDEV_STOP_PENDING, &idev->flags);
+	clear_bit(IDEV_GONE, &idev->flags);
+	clear_bit(IDEV_EH, &idev->flags);
+	smp_mb__before_clear_bit();
+	clear_bit(IDEV_ALLOCATED, &idev->flags);
+	wake_up(&ihost->eventq);
+}
+
 /**
  * isci_remote_device_stop() - This function is called internally to stop the
  *    remote device.
@@ -1330,7 +1338,11 @@ enum sci_status isci_remote_device_stop(struct isci_host *ihost, struct isci_rem
 	dev_dbg(&ihost->pdev->dev,
 		"%s: isci_device = %p\n", __func__, idev);
 
+	spin_lock_irqsave(&ihost->scic_lock, flags);
+	idev->domain_dev->lldd_dev = NULL; /* disable new lookups */
+	set_bit(IDEV_GONE, &idev->flags);
 	isci_remote_device_change_state(idev, isci_stopping);
+	spin_unlock_irqrestore(&ihost->scic_lock, flags);
 
 	/* Kill all outstanding requests. */
 	isci_remote_device_nuke_requests(ihost, idev);
@@ -1342,14 +1354,10 @@ enum sci_status isci_remote_device_stop(struct isci_host *ihost, struct isci_rem
 	spin_unlock_irqrestore(&ihost->scic_lock, flags);
 
 	/* Wait for the stop complete callback. */
-	if (status == SCI_SUCCESS) {
+	if (WARN_ONCE(status != SCI_SUCCESS, "failed to stop device\n"))
+		/* nothing to wait for */;
+	else
 		wait_for_device_stop(ihost, idev);
-		clear_bit(IDEV_ALLOCATED, &idev->flags);
-	}
-
-	dev_dbg(&ihost->pdev->dev,
-		"%s: idev = %p - after completion wait\n",
-		__func__, idev);
 
 	return status;
 }
@@ -1416,39 +1424,33 @@ int isci_remote_device_found(struct domain_device *domain_dev)
 	if (!isci_device)
 		return -ENODEV;
 
+	kref_init(&isci_device->kref);
 	INIT_LIST_HEAD(&isci_device->node);
-	domain_dev->lldd_dev = isci_device;
+
+	spin_lock_irq(&isci_host->scic_lock);
 	isci_device->domain_dev = domain_dev;
 	isci_device->isci_port = isci_port;
 	isci_remote_device_change_state(isci_device, isci_starting);
-
-
-	spin_lock_irq(&isci_host->scic_lock);
 	list_add_tail(&isci_device->node, &isci_port->remote_dev_list);
 
 	set_bit(IDEV_START_PENDING, &isci_device->flags);
 	status = isci_remote_device_construct(isci_port, isci_device);
-	spin_unlock_irq(&isci_host->scic_lock);
 
 	dev_dbg(&isci_host->pdev->dev,
 		"%s: isci_device = %p\n",
 		__func__, isci_device);
 
-	if (status != SCI_SUCCESS) {
-
-		spin_lock_irq(&isci_host->scic_lock);
-		isci_remote_device_deconstruct(
-			isci_host,
-			isci_device
-			);
-		spin_unlock_irq(&isci_host->scic_lock);
-		return -ENODEV;
-	}
+	if (status == SCI_SUCCESS) {
+		/* device came up, advertise it to the world */
+		domain_dev->lldd_dev = isci_device;
+	} else
+		isci_put_device(isci_device);
+	spin_unlock_irq(&isci_host->scic_lock);
 
 	/* wait for the device ready callback. */
 	wait_for_device_start(isci_host, isci_device);
 
-	return 0;
+	return status == SCI_SUCCESS ? 0 : -ENODEV;
 }
 /**
  * isci_device_is_reset_pending() - This function will check if there is any

commit 980d3aeb3828b0fdf2a0b2e893d238130b014575
Author: Dan Williams <dan.j.williams@intel.com>
Date:   Mon Jun 20 15:11:22 2011 -0700

    isci: fix isci_terminate_pending() list management
    
    Walk through the list of pending requests being careful to consider that
    multiple requests can be terminated when the lock is dropped (i.e.
    invalidating the 'next' reference established by
    list_for_each_entry_safe).
    
    Also noticed that all callers to isci_terminate_pending_requests()
    specifying terminating, so just drop the parameter.
    
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/drivers/scsi/isci/remote_device.c b/drivers/scsi/isci/remote_device.c
index 3b555dcbe569..45592ad33c3b 100644
--- a/drivers/scsi/isci/remote_device.c
+++ b/drivers/scsi/isci/remote_device.c
@@ -1272,7 +1272,7 @@ void isci_remote_device_nuke_requests(struct isci_host *ihost, struct isci_remot
 		"%s: idev = %p\n", __func__, idev);
 
 	/* Cleanup all requests pending for this device. */
-	isci_terminate_pending_requests(ihost, idev, terminating);
+	isci_terminate_pending_requests(ihost, idev);
 
 	dev_dbg(&ihost->pdev->dev,
 		"%s: idev = %p, done\n", __func__, idev);

commit 12ef65444de9d387a383b9991960848bed5bbe74
Author: Edmund Nadolski <edmund.nadolski@intel.com>
Date:   Thu Jun 2 00:10:50 2011 +0000

    isci: additional state machine cleanup
    
    Additional state machine cleanups:
    
     o Remove static functions sci_state_machine_exit_state() and
       sci_state_machine_enter_state()
     o Combines sci_base_state_machine_construct() and
       sci_base_state_machine_start() into a single function,
       sci_init_sm()
     o Remove sci_base_state_machine_stop() which is unused.
     o Kill state_machine.[ch]
    
    Signed-off-by: Edmund Nadolski <edmund.nadolski@intel.com>
    [fixed too large to inline functions]
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/drivers/scsi/isci/remote_device.c b/drivers/scsi/isci/remote_device.c
index 6c93f20f3dd3..3b555dcbe569 100644
--- a/drivers/scsi/isci/remote_device.c
+++ b/drivers/scsi/isci/remote_device.c
@@ -1095,11 +1095,7 @@ static void scic_remote_device_construct(struct scic_sds_port *sci_port,
 	sci_dev->owning_port = sci_port;
 	sci_dev->started_request_count = 0;
 
-	sci_base_state_machine_construct(&sci_dev->sm,
-					 scic_sds_remote_device_state_table,
-					 SCI_DEV_INITIAL);
-
-	sci_base_state_machine_start(&sci_dev->sm);
+	sci_init_sm(&sci_dev->sm, scic_sds_remote_device_state_table, SCI_DEV_INITIAL);
 
 	scic_sds_remote_node_context_construct(&sci_dev->rnc,
 					       SCIC_SDS_REMOTE_NODE_CONTEXT_INVALID_INDEX);

commit e301370ac553a9a0ac0d1d25e769b86cf60395b3
Author: Edmund Nadolski <edmund.nadolski@intel.com>
Date:   Thu Jun 2 00:10:43 2011 +0000

    isci: state machine cleanup
    
    This cleans up several areas of the state machine mechanism:
    
     o Rename sci_base_state_machine_change_state to sci_change_state
     o Remove sci_base_state_machine_get_state function
     o Rename 'state_machine' struct member to 'sm' in client structs
     o Shorten the name of request states
     o Shorten state machine state names as follows:
            SCI_BASE_CONTROLLER_STATE_xxx to SCIC_xxx
            SCI_BASE_PHY_STATE_xxx to SCI_PHY_xxx
            SCIC_SDS_PHY_STARTING_SUBSTATE_xxx to SCI_PHY_SUB_xxx
            SCI_BASE_PORT_STATE_xxx to SCI_PORT_xxx and
            SCIC_SDS_PORT_READY_SUBSTATE_xxx to SCI_PORT_SUB_xxx
            SCI_BASE_REMOTE_DEVICE_STATE_xxx to SCI_DEV_xxx
            SCIC_SDS_STP_REMOTE_DEVICE_READY_SUBSTATE_xxx to SCI_STP_DEV_xxx
            SCIC_SDS_SMP_REMOTE_DEVICE_READY_SUBSTATE_xxx to SCI_SMP_DEV_xxx
            SCIC_SDS_REMOTE_NODE_CONTEXT_xxx_STATE to SCI_RNC_xxx
    
    Signed-off-by: Edmund Nadolski <edmund.nadolski@intel.com>
    Signed-off-by: Dave Jiang <dave.jiang@intel.com>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/drivers/scsi/isci/remote_device.c b/drivers/scsi/isci/remote_device.c
index 68b63b04be19..6c93f20f3dd3 100644
--- a/drivers/scsi/isci/remote_device.c
+++ b/drivers/scsi/isci/remote_device.c
@@ -126,8 +126,7 @@ static void rnc_destruct_done(void *_dev)
 	struct scic_sds_remote_device *sci_dev = _dev;
 
 	BUG_ON(sci_dev->started_request_count != 0);
-	sci_base_state_machine_change_state(&sci_dev->state_machine,
-					    SCI_BASE_REMOTE_DEVICE_STATE_STOPPED);
+	sci_change_state(&sci_dev->sm, SCI_DEV_STOPPED);
 }
 
 static enum sci_status scic_sds_remote_device_terminate_requests(struct scic_sds_remote_device *sci_dev)
@@ -154,20 +153,20 @@ static enum sci_status scic_sds_remote_device_terminate_requests(struct scic_sds
 enum sci_status scic_remote_device_stop(struct scic_sds_remote_device *sci_dev,
 					u32 timeout)
 {
-	struct sci_base_state_machine *sm = &sci_dev->state_machine;
+	struct sci_base_state_machine *sm = &sci_dev->sm;
 	enum scic_sds_remote_device_states state = sm->current_state_id;
 
 	switch (state) {
-	case SCI_BASE_REMOTE_DEVICE_STATE_INITIAL:
-	case SCI_BASE_REMOTE_DEVICE_STATE_FAILED:
-	case SCI_BASE_REMOTE_DEVICE_STATE_FINAL:
+	case SCI_DEV_INITIAL:
+	case SCI_DEV_FAILED:
+	case SCI_DEV_FINAL:
 	default:
 		dev_warn(scirdev_to_dev(sci_dev), "%s: in wrong state: %d\n",
 			 __func__, state);
 		return SCI_FAILURE_INVALID_STATE;
-	case SCI_BASE_REMOTE_DEVICE_STATE_STOPPED:
+	case SCI_DEV_STOPPED:
 		return SCI_SUCCESS;
-	case SCI_BASE_REMOTE_DEVICE_STATE_STARTING:
+	case SCI_DEV_STARTING:
 		/* device not started so there had better be no requests */
 		BUG_ON(sci_dev->started_request_count != 0);
 		scic_sds_remote_node_context_destruct(&sci_dev->rnc,
@@ -175,17 +174,17 @@ enum sci_status scic_remote_device_stop(struct scic_sds_remote_device *sci_dev,
 		/* Transition to the stopping state and wait for the
 		 * remote node to complete being posted and invalidated.
 		 */
-		sci_base_state_machine_change_state(sm, SCI_BASE_REMOTE_DEVICE_STATE_STOPPING);
+		sci_change_state(sm, SCI_DEV_STOPPING);
 		return SCI_SUCCESS;
-	case SCI_BASE_REMOTE_DEVICE_STATE_READY:
-	case SCIC_SDS_STP_REMOTE_DEVICE_READY_SUBSTATE_IDLE:
-	case SCIC_SDS_STP_REMOTE_DEVICE_READY_SUBSTATE_CMD:
-	case SCIC_SDS_STP_REMOTE_DEVICE_READY_SUBSTATE_NCQ:
-	case SCIC_SDS_STP_REMOTE_DEVICE_READY_SUBSTATE_NCQ_ERROR:
-	case SCIC_SDS_STP_REMOTE_DEVICE_READY_SUBSTATE_AWAIT_RESET:
-	case SCIC_SDS_SMP_REMOTE_DEVICE_READY_SUBSTATE_IDLE:
-	case SCIC_SDS_SMP_REMOTE_DEVICE_READY_SUBSTATE_CMD:
-		sci_base_state_machine_change_state(sm, SCI_BASE_REMOTE_DEVICE_STATE_STOPPING);
+	case SCI_DEV_READY:
+	case SCI_STP_DEV_IDLE:
+	case SCI_STP_DEV_CMD:
+	case SCI_STP_DEV_NCQ:
+	case SCI_STP_DEV_NCQ_ERROR:
+	case SCI_STP_DEV_AWAIT_RESET:
+	case SCI_SMP_DEV_IDLE:
+	case SCI_SMP_DEV_CMD:
+		sci_change_state(sm, SCI_DEV_STOPPING);
 		if (sci_dev->started_request_count == 0) {
 			scic_sds_remote_node_context_destruct(&sci_dev->rnc,
 							      rnc_destruct_done, sci_dev);
@@ -193,70 +192,70 @@ enum sci_status scic_remote_device_stop(struct scic_sds_remote_device *sci_dev,
 		} else
 			return scic_sds_remote_device_terminate_requests(sci_dev);
 		break;
-	case SCI_BASE_REMOTE_DEVICE_STATE_STOPPING:
+	case SCI_DEV_STOPPING:
 		/* All requests should have been terminated, but if there is an
 		 * attempt to stop a device already in the stopping state, then
 		 * try again to terminate.
 		 */
 		return scic_sds_remote_device_terminate_requests(sci_dev);
-	case SCI_BASE_REMOTE_DEVICE_STATE_RESETTING:
-		sci_base_state_machine_change_state(sm, SCI_BASE_REMOTE_DEVICE_STATE_STOPPING);
+	case SCI_DEV_RESETTING:
+		sci_change_state(sm, SCI_DEV_STOPPING);
 		return SCI_SUCCESS;
 	}
 }
 
 enum sci_status scic_remote_device_reset(struct scic_sds_remote_device *sci_dev)
 {
-	struct sci_base_state_machine *sm = &sci_dev->state_machine;
+	struct sci_base_state_machine *sm = &sci_dev->sm;
 	enum scic_sds_remote_device_states state = sm->current_state_id;
 
 	switch (state) {
-	case SCI_BASE_REMOTE_DEVICE_STATE_INITIAL:
-	case SCI_BASE_REMOTE_DEVICE_STATE_STOPPED:
-	case SCI_BASE_REMOTE_DEVICE_STATE_STARTING:
-	case SCIC_SDS_SMP_REMOTE_DEVICE_READY_SUBSTATE_IDLE:
-	case SCIC_SDS_SMP_REMOTE_DEVICE_READY_SUBSTATE_CMD:
-	case SCI_BASE_REMOTE_DEVICE_STATE_STOPPING:
-	case SCI_BASE_REMOTE_DEVICE_STATE_FAILED:
-	case SCI_BASE_REMOTE_DEVICE_STATE_RESETTING:
-	case SCI_BASE_REMOTE_DEVICE_STATE_FINAL:
+	case SCI_DEV_INITIAL:
+	case SCI_DEV_STOPPED:
+	case SCI_DEV_STARTING:
+	case SCI_SMP_DEV_IDLE:
+	case SCI_SMP_DEV_CMD:
+	case SCI_DEV_STOPPING:
+	case SCI_DEV_FAILED:
+	case SCI_DEV_RESETTING:
+	case SCI_DEV_FINAL:
 	default:
 		dev_warn(scirdev_to_dev(sci_dev), "%s: in wrong state: %d\n",
 			 __func__, state);
 		return SCI_FAILURE_INVALID_STATE;
-	case SCI_BASE_REMOTE_DEVICE_STATE_READY:
-	case SCIC_SDS_STP_REMOTE_DEVICE_READY_SUBSTATE_IDLE:
-	case SCIC_SDS_STP_REMOTE_DEVICE_READY_SUBSTATE_CMD:
-	case SCIC_SDS_STP_REMOTE_DEVICE_READY_SUBSTATE_NCQ:
-	case SCIC_SDS_STP_REMOTE_DEVICE_READY_SUBSTATE_NCQ_ERROR:
-	case SCIC_SDS_STP_REMOTE_DEVICE_READY_SUBSTATE_AWAIT_RESET:
-		sci_base_state_machine_change_state(sm, SCI_BASE_REMOTE_DEVICE_STATE_RESETTING);
+	case SCI_DEV_READY:
+	case SCI_STP_DEV_IDLE:
+	case SCI_STP_DEV_CMD:
+	case SCI_STP_DEV_NCQ:
+	case SCI_STP_DEV_NCQ_ERROR:
+	case SCI_STP_DEV_AWAIT_RESET:
+		sci_change_state(sm, SCI_DEV_RESETTING);
 		return SCI_SUCCESS;
 	}
 }
 
 enum sci_status scic_remote_device_reset_complete(struct scic_sds_remote_device *sci_dev)
 {
-	struct sci_base_state_machine *sm = &sci_dev->state_machine;
+	struct sci_base_state_machine *sm = &sci_dev->sm;
 	enum scic_sds_remote_device_states state = sm->current_state_id;
 
-	if (state != SCI_BASE_REMOTE_DEVICE_STATE_RESETTING) {
+	if (state != SCI_DEV_RESETTING) {
 		dev_warn(scirdev_to_dev(sci_dev), "%s: in wrong state: %d\n",
 			 __func__, state);
 		return SCI_FAILURE_INVALID_STATE;
 	}
 
-	sci_base_state_machine_change_state(sm, SCI_BASE_REMOTE_DEVICE_STATE_READY);
+	sci_change_state(sm, SCI_DEV_READY);
 	return SCI_SUCCESS;
 }
 
 enum sci_status scic_sds_remote_device_suspend(struct scic_sds_remote_device *sci_dev,
 					       u32 suspend_type)
 {
-	struct sci_base_state_machine *sm = &sci_dev->state_machine;
+	struct sci_base_state_machine *sm = &sci_dev->sm;
 	enum scic_sds_remote_device_states state = sm->current_state_id;
 
-	if (state != SCIC_SDS_STP_REMOTE_DEVICE_READY_SUBSTATE_CMD) {
+	if (state != SCI_STP_DEV_CMD) {
 		dev_warn(scirdev_to_dev(sci_dev), "%s: in wrong state: %d\n",
 			 __func__, state);
 		return SCI_FAILURE_INVALID_STATE;
@@ -269,30 +268,30 @@ enum sci_status scic_sds_remote_device_suspend(struct scic_sds_remote_device *sc
 enum sci_status scic_sds_remote_device_frame_handler(struct scic_sds_remote_device *sci_dev,
 						     u32 frame_index)
 {
-	struct sci_base_state_machine *sm = &sci_dev->state_machine;
+	struct sci_base_state_machine *sm = &sci_dev->sm;
 	enum scic_sds_remote_device_states state = sm->current_state_id;
 	struct scic_sds_controller *scic = sci_dev->owning_port->owning_controller;
 	enum sci_status status;
 
 	switch (state) {
-	case SCI_BASE_REMOTE_DEVICE_STATE_INITIAL:
-	case SCI_BASE_REMOTE_DEVICE_STATE_STOPPED:
-	case SCI_BASE_REMOTE_DEVICE_STATE_STARTING:
-	case SCIC_SDS_STP_REMOTE_DEVICE_READY_SUBSTATE_IDLE:
-	case SCIC_SDS_SMP_REMOTE_DEVICE_READY_SUBSTATE_IDLE:
-	case SCI_BASE_REMOTE_DEVICE_STATE_FINAL:
+	case SCI_DEV_INITIAL:
+	case SCI_DEV_STOPPED:
+	case SCI_DEV_STARTING:
+	case SCI_STP_DEV_IDLE:
+	case SCI_SMP_DEV_IDLE:
+	case SCI_DEV_FINAL:
 	default:
 		dev_warn(scirdev_to_dev(sci_dev), "%s: in wrong state: %d\n",
 			 __func__, state);
 		/* Return the frame back to the controller */
 		scic_sds_controller_release_frame(scic, frame_index);
 		return SCI_FAILURE_INVALID_STATE;
-	case SCI_BASE_REMOTE_DEVICE_STATE_READY:
-	case SCIC_SDS_STP_REMOTE_DEVICE_READY_SUBSTATE_NCQ_ERROR:
-	case SCIC_SDS_STP_REMOTE_DEVICE_READY_SUBSTATE_AWAIT_RESET:
-	case SCI_BASE_REMOTE_DEVICE_STATE_STOPPING:
-	case SCI_BASE_REMOTE_DEVICE_STATE_FAILED:
-	case SCI_BASE_REMOTE_DEVICE_STATE_RESETTING: {
+	case SCI_DEV_READY:
+	case SCI_STP_DEV_NCQ_ERROR:
+	case SCI_STP_DEV_AWAIT_RESET:
+	case SCI_DEV_STOPPING:
+	case SCI_DEV_FAILED:
+	case SCI_DEV_RESETTING: {
 		struct scic_sds_request *sci_req;
 		struct ssp_frame_hdr hdr;
 		void *frame_header;
@@ -319,7 +318,7 @@ enum sci_status scic_sds_remote_device_frame_handler(struct scic_sds_remote_devi
 		}
 		break;
 	}
-	case SCIC_SDS_STP_REMOTE_DEVICE_READY_SUBSTATE_NCQ: {
+	case SCI_STP_DEV_NCQ: {
 		struct dev_to_host_fis *hdr;
 
 		status = scic_sds_unsolicited_frame_control_get_header(&scic->uf_control,
@@ -333,7 +332,7 @@ enum sci_status scic_sds_remote_device_frame_handler(struct scic_sds_remote_devi
 			sci_dev->not_ready_reason = SCIC_REMOTE_DEVICE_NOT_READY_SATA_SDB_ERROR_FIS_RECEIVED;
 
 			/* TODO Check sactive and complete associated IO if any. */
-			sci_base_state_machine_change_state(sm, SCIC_SDS_STP_REMOTE_DEVICE_READY_SUBSTATE_NCQ_ERROR);
+			sci_change_state(sm, SCI_STP_DEV_NCQ_ERROR);
 		} else if (hdr->fis_type == FIS_REGD2H &&
 			   (hdr->status & ATA_ERR)) {
 			/*
@@ -341,16 +340,15 @@ enum sci_status scic_sds_remote_device_frame_handler(struct scic_sds_remote_devi
 			 * Treat this like an SDB error FIS ready reason.
 			 */
 			sci_dev->not_ready_reason = SCIC_REMOTE_DEVICE_NOT_READY_SATA_SDB_ERROR_FIS_RECEIVED;
-			sci_base_state_machine_change_state(&sci_dev->state_machine,
-							    SCIC_SDS_STP_REMOTE_DEVICE_READY_SUBSTATE_NCQ_ERROR);
+			sci_change_state(&sci_dev->sm, SCI_STP_DEV_NCQ_ERROR);
 		} else
 			status = SCI_FAILURE;
 
 		scic_sds_controller_release_frame(scic, frame_index);
 		break;
 	}
-	case SCIC_SDS_STP_REMOTE_DEVICE_READY_SUBSTATE_CMD:
-	case SCIC_SDS_SMP_REMOTE_DEVICE_READY_SUBSTATE_CMD:
+	case SCI_STP_DEV_CMD:
+	case SCI_SMP_DEV_CMD:
 		/* The device does not process any UF received from the hardware while
 		 * in this state.  All unsolicited frames are forwarded to the io request
 		 * object.
@@ -365,18 +363,18 @@ enum sci_status scic_sds_remote_device_frame_handler(struct scic_sds_remote_devi
 static bool is_remote_device_ready(struct scic_sds_remote_device *sci_dev)
 {
 
-	struct sci_base_state_machine *sm = &sci_dev->state_machine;
+	struct sci_base_state_machine *sm = &sci_dev->sm;
 	enum scic_sds_remote_device_states state = sm->current_state_id;
 
 	switch (state) {
-	case SCI_BASE_REMOTE_DEVICE_STATE_READY:
-	case SCIC_SDS_STP_REMOTE_DEVICE_READY_SUBSTATE_IDLE:
-	case SCIC_SDS_STP_REMOTE_DEVICE_READY_SUBSTATE_CMD:
-	case SCIC_SDS_STP_REMOTE_DEVICE_READY_SUBSTATE_NCQ:
-	case SCIC_SDS_STP_REMOTE_DEVICE_READY_SUBSTATE_NCQ_ERROR:
-	case SCIC_SDS_STP_REMOTE_DEVICE_READY_SUBSTATE_AWAIT_RESET:
-	case SCIC_SDS_SMP_REMOTE_DEVICE_READY_SUBSTATE_IDLE:
-	case SCIC_SDS_SMP_REMOTE_DEVICE_READY_SUBSTATE_CMD:
+	case SCI_DEV_READY:
+	case SCI_STP_DEV_IDLE:
+	case SCI_STP_DEV_CMD:
+	case SCI_STP_DEV_NCQ:
+	case SCI_STP_DEV_NCQ_ERROR:
+	case SCI_STP_DEV_AWAIT_RESET:
+	case SCI_SMP_DEV_IDLE:
+	case SCI_SMP_DEV_CMD:
 		return true;
 	default:
 		return false;
@@ -386,7 +384,7 @@ static bool is_remote_device_ready(struct scic_sds_remote_device *sci_dev)
 enum sci_status scic_sds_remote_device_event_handler(struct scic_sds_remote_device *sci_dev,
 						     u32 event_code)
 {
-	struct sci_base_state_machine *sm = &sci_dev->state_machine;
+	struct sci_base_state_machine *sm = &sci_dev->sm;
 	enum scic_sds_remote_device_states state = sm->current_state_id;
 	enum sci_status status;
 
@@ -429,7 +427,7 @@ enum sci_status scic_sds_remote_device_event_handler(struct scic_sds_remote_devi
 	if (status != SCI_SUCCESS)
 		return status;
 
-	if (state == SCIC_SDS_STP_REMOTE_DEVICE_READY_SUBSTATE_IDLE) {
+	if (state == SCI_STP_DEV_IDLE) {
 
 		/* We pick up suspension events to handle specifically to this
 		 * state. We resume the RNC right away.
@@ -459,26 +457,26 @@ enum sci_status scic_sds_remote_device_start_io(struct scic_sds_controller *scic
 						struct scic_sds_remote_device *sci_dev,
 						struct scic_sds_request *sci_req)
 {
-	struct sci_base_state_machine *sm = &sci_dev->state_machine;
+	struct sci_base_state_machine *sm = &sci_dev->sm;
 	enum scic_sds_remote_device_states state = sm->current_state_id;
 	struct scic_sds_port *sci_port = sci_dev->owning_port;
 	struct isci_request *ireq = sci_req_to_ireq(sci_req);
 	enum sci_status status;
 
 	switch (state) {
-	case SCI_BASE_REMOTE_DEVICE_STATE_INITIAL:
-	case SCI_BASE_REMOTE_DEVICE_STATE_STOPPED:
-	case SCI_BASE_REMOTE_DEVICE_STATE_STARTING:
-	case SCIC_SDS_STP_REMOTE_DEVICE_READY_SUBSTATE_NCQ_ERROR:
-	case SCI_BASE_REMOTE_DEVICE_STATE_STOPPING:
-	case SCI_BASE_REMOTE_DEVICE_STATE_FAILED:
-	case SCI_BASE_REMOTE_DEVICE_STATE_RESETTING:
-	case SCI_BASE_REMOTE_DEVICE_STATE_FINAL:
+	case SCI_DEV_INITIAL:
+	case SCI_DEV_STOPPED:
+	case SCI_DEV_STARTING:
+	case SCI_STP_DEV_NCQ_ERROR:
+	case SCI_DEV_STOPPING:
+	case SCI_DEV_FAILED:
+	case SCI_DEV_RESETTING:
+	case SCI_DEV_FINAL:
 	default:
 		dev_warn(scirdev_to_dev(sci_dev), "%s: in wrong state: %d\n",
 			 __func__, state);
 		return SCI_FAILURE_INVALID_STATE;
-	case SCI_BASE_REMOTE_DEVICE_STATE_READY:
+	case SCI_DEV_READY:
 		/* attempt to start an io request for this device object. The remote
 		 * device object will issue the start request for the io and if
 		 * successful it will start the request for the port object then
@@ -494,7 +492,7 @@ enum sci_status scic_sds_remote_device_start_io(struct scic_sds_controller *scic
 
 		status = scic_sds_request_start(sci_req);
 		break;
-	case SCIC_SDS_STP_REMOTE_DEVICE_READY_SUBSTATE_IDLE: {
+	case SCI_STP_DEV_IDLE: {
 		/* handle the start io operation for a sata device that is in
 		 * the command idle state. - Evalute the type of IO request to
 		 * be started - If its an NCQ request change to NCQ substate -
@@ -519,15 +517,15 @@ enum sci_status scic_sds_remote_device_start_io(struct scic_sds_controller *scic
 			break;
 
 		if (task->ata_task.use_ncq)
-			new_state = SCIC_SDS_STP_REMOTE_DEVICE_READY_SUBSTATE_NCQ;
+			new_state = SCI_STP_DEV_NCQ;
 		else {
 			sci_dev->working_request = sci_req;
-			new_state = SCIC_SDS_STP_REMOTE_DEVICE_READY_SUBSTATE_CMD;
+			new_state = SCI_STP_DEV_CMD;
 		}
-		sci_base_state_machine_change_state(sm, new_state);
+		sci_change_state(sm, new_state);
 		break;
 	}
-	case SCIC_SDS_STP_REMOTE_DEVICE_READY_SUBSTATE_NCQ: {
+	case SCI_STP_DEV_NCQ: {
 		struct sas_task *task = isci_request_access_task(ireq);
 
 		if (task->ata_task.use_ncq) {
@@ -544,9 +542,9 @@ enum sci_status scic_sds_remote_device_start_io(struct scic_sds_controller *scic
 			return SCI_FAILURE_INVALID_STATE;
 		break;
 	}
-	case SCIC_SDS_STP_REMOTE_DEVICE_READY_SUBSTATE_AWAIT_RESET:
+	case SCI_STP_DEV_AWAIT_RESET:
 		return SCI_FAILURE_REMOTE_DEVICE_RESET_REQUIRED;
-	case SCIC_SDS_SMP_REMOTE_DEVICE_READY_SUBSTATE_IDLE:
+	case SCI_SMP_DEV_IDLE:
 		status = scic_sds_port_start_io(sci_port, sci_dev, sci_req);
 		if (status != SCI_SUCCESS)
 			return status;
@@ -560,11 +558,10 @@ enum sci_status scic_sds_remote_device_start_io(struct scic_sds_controller *scic
 			break;
 
 		sci_dev->working_request = sci_req;
-		sci_base_state_machine_change_state(&sci_dev->state_machine,
-						    SCIC_SDS_SMP_REMOTE_DEVICE_READY_SUBSTATE_CMD);
+		sci_change_state(&sci_dev->sm, SCI_SMP_DEV_CMD);
 		break;
-	case SCIC_SDS_STP_REMOTE_DEVICE_READY_SUBSTATE_CMD:
-	case SCIC_SDS_SMP_REMOTE_DEVICE_READY_SUBSTATE_CMD:
+	case SCI_STP_DEV_CMD:
+	case SCI_SMP_DEV_CMD:
 		/* device is already handling a command it can not accept new commands
 		 * until this one is complete.
 		 */
@@ -597,31 +594,31 @@ enum sci_status scic_sds_remote_device_complete_io(struct scic_sds_controller *s
 						   struct scic_sds_remote_device *sci_dev,
 						   struct scic_sds_request *sci_req)
 {
-	struct sci_base_state_machine *sm = &sci_dev->state_machine;
+	struct sci_base_state_machine *sm = &sci_dev->sm;
 	enum scic_sds_remote_device_states state = sm->current_state_id;
 	struct scic_sds_port *sci_port = sci_dev->owning_port;
 	enum sci_status status;
 
 	switch (state) {
-	case SCI_BASE_REMOTE_DEVICE_STATE_INITIAL:
-	case SCI_BASE_REMOTE_DEVICE_STATE_STOPPED:
-	case SCI_BASE_REMOTE_DEVICE_STATE_STARTING:
-	case SCIC_SDS_STP_REMOTE_DEVICE_READY_SUBSTATE_IDLE:
-	case SCIC_SDS_SMP_REMOTE_DEVICE_READY_SUBSTATE_IDLE:
-	case SCI_BASE_REMOTE_DEVICE_STATE_FAILED:
-	case SCI_BASE_REMOTE_DEVICE_STATE_FINAL:
+	case SCI_DEV_INITIAL:
+	case SCI_DEV_STOPPED:
+	case SCI_DEV_STARTING:
+	case SCI_STP_DEV_IDLE:
+	case SCI_SMP_DEV_IDLE:
+	case SCI_DEV_FAILED:
+	case SCI_DEV_FINAL:
 	default:
 		dev_warn(scirdev_to_dev(sci_dev), "%s: in wrong state: %d\n",
 			 __func__, state);
 		return SCI_FAILURE_INVALID_STATE;
-	case SCI_BASE_REMOTE_DEVICE_STATE_READY:
-	case SCIC_SDS_STP_REMOTE_DEVICE_READY_SUBSTATE_AWAIT_RESET:
-	case SCI_BASE_REMOTE_DEVICE_STATE_RESETTING:
+	case SCI_DEV_READY:
+	case SCI_STP_DEV_AWAIT_RESET:
+	case SCI_DEV_RESETTING:
 		status = common_complete_io(sci_port, sci_dev, sci_req);
 		break;
-	case SCIC_SDS_STP_REMOTE_DEVICE_READY_SUBSTATE_CMD:
-	case SCIC_SDS_STP_REMOTE_DEVICE_READY_SUBSTATE_NCQ:
-	case SCIC_SDS_STP_REMOTE_DEVICE_READY_SUBSTATE_NCQ_ERROR:
+	case SCI_STP_DEV_CMD:
+	case SCI_STP_DEV_NCQ:
+	case SCI_STP_DEV_NCQ_ERROR:
 		status = common_complete_io(sci_port, sci_dev, sci_req);
 		if (status != SCI_SUCCESS)
 			break;
@@ -632,17 +629,17 @@ enum sci_status scic_sds_remote_device_complete_io(struct scic_sds_controller *s
 			 * can reach RNC state handler, these IOs will be completed by RNC with
 			 * status of "DEVICE_RESET_REQUIRED", instead of "INVALID STATE".
 			 */
-			sci_base_state_machine_change_state(sm, SCIC_SDS_STP_REMOTE_DEVICE_READY_SUBSTATE_AWAIT_RESET);
+			sci_change_state(sm, SCI_STP_DEV_AWAIT_RESET);
 		} else if (scic_sds_remote_device_get_request_count(sci_dev) == 0)
-			sci_base_state_machine_change_state(sm, SCIC_SDS_STP_REMOTE_DEVICE_READY_SUBSTATE_IDLE);
+			sci_change_state(sm, SCI_STP_DEV_IDLE);
 		break;
-	case SCIC_SDS_SMP_REMOTE_DEVICE_READY_SUBSTATE_CMD:
+	case SCI_SMP_DEV_CMD:
 		status = common_complete_io(sci_port, sci_dev, sci_req);
 		if (status != SCI_SUCCESS)
 			break;
-		sci_base_state_machine_change_state(sm, SCIC_SDS_SMP_REMOTE_DEVICE_READY_SUBSTATE_IDLE);
+		sci_change_state(sm, SCI_SMP_DEV_IDLE);
 		break;
-	case SCI_BASE_REMOTE_DEVICE_STATE_STOPPING:
+	case SCI_DEV_STOPPING:
 		status = common_complete_io(sci_port, sci_dev, sci_req);
 		if (status != SCI_SUCCESS)
 			break;
@@ -676,30 +673,30 @@ enum sci_status scic_sds_remote_device_start_task(struct scic_sds_controller *sc
 						  struct scic_sds_remote_device *sci_dev,
 						  struct scic_sds_request *sci_req)
 {
-	struct sci_base_state_machine *sm = &sci_dev->state_machine;
+	struct sci_base_state_machine *sm = &sci_dev->sm;
 	enum scic_sds_remote_device_states state = sm->current_state_id;
 	struct scic_sds_port *sci_port = sci_dev->owning_port;
 	enum sci_status status;
 
 	switch (state) {
-	case SCI_BASE_REMOTE_DEVICE_STATE_INITIAL:
-	case SCI_BASE_REMOTE_DEVICE_STATE_STOPPED:
-	case SCI_BASE_REMOTE_DEVICE_STATE_STARTING:
-	case SCIC_SDS_SMP_REMOTE_DEVICE_READY_SUBSTATE_IDLE:
-	case SCIC_SDS_SMP_REMOTE_DEVICE_READY_SUBSTATE_CMD:
-	case SCI_BASE_REMOTE_DEVICE_STATE_STOPPING:
-	case SCI_BASE_REMOTE_DEVICE_STATE_FAILED:
-	case SCI_BASE_REMOTE_DEVICE_STATE_RESETTING:
-	case SCI_BASE_REMOTE_DEVICE_STATE_FINAL:
+	case SCI_DEV_INITIAL:
+	case SCI_DEV_STOPPED:
+	case SCI_DEV_STARTING:
+	case SCI_SMP_DEV_IDLE:
+	case SCI_SMP_DEV_CMD:
+	case SCI_DEV_STOPPING:
+	case SCI_DEV_FAILED:
+	case SCI_DEV_RESETTING:
+	case SCI_DEV_FINAL:
 	default:
 		dev_warn(scirdev_to_dev(sci_dev), "%s: in wrong state: %d\n",
 			 __func__, state);
 		return SCI_FAILURE_INVALID_STATE;
-	case SCIC_SDS_STP_REMOTE_DEVICE_READY_SUBSTATE_IDLE:
-	case SCIC_SDS_STP_REMOTE_DEVICE_READY_SUBSTATE_CMD:
-	case SCIC_SDS_STP_REMOTE_DEVICE_READY_SUBSTATE_NCQ:
-	case SCIC_SDS_STP_REMOTE_DEVICE_READY_SUBSTATE_NCQ_ERROR:
-	case SCIC_SDS_STP_REMOTE_DEVICE_READY_SUBSTATE_AWAIT_RESET:
+	case SCI_STP_DEV_IDLE:
+	case SCI_STP_DEV_CMD:
+	case SCI_STP_DEV_NCQ:
+	case SCI_STP_DEV_NCQ_ERROR:
+	case SCI_STP_DEV_AWAIT_RESET:
 		status = scic_sds_port_start_io(sci_port, sci_dev, sci_req);
 		if (status != SCI_SUCCESS)
 			return status;
@@ -717,7 +714,7 @@ enum sci_status scic_sds_remote_device_start_task(struct scic_sds_controller *sc
 		 * management request.
 		 */
 		sci_dev->working_request = sci_req;
-		sci_base_state_machine_change_state(sm, SCIC_SDS_STP_REMOTE_DEVICE_READY_SUBSTATE_CMD);
+		sci_change_state(sm, SCI_STP_DEV_CMD);
 
 		/* The remote node context must cleanup the TCi to NCQ mapping
 		 * table.  The only way to do this correctly is to either write
@@ -739,7 +736,7 @@ enum sci_status scic_sds_remote_device_start_task(struct scic_sds_controller *sc
 		 * post TC when RNC gets resumed.
 		 */
 		return SCI_FAILURE_RESET_DEVICE_PARTIAL_SUCCESS;
-	case SCI_BASE_REMOTE_DEVICE_STATE_READY:
+	case SCI_DEV_READY:
 		status = scic_sds_port_start_io(sci_port, sci_dev, sci_req);
 		if (status != SCI_SUCCESS)
 			return status;
@@ -790,8 +787,7 @@ static void remote_device_resume_done(void *_dev)
 		return;
 
 	/* go 'ready' if we are not already in a ready state */
-	sci_base_state_machine_change_state(&sci_dev->state_machine,
-					    SCI_BASE_REMOTE_DEVICE_STATE_READY);
+	sci_change_state(&sci_dev->sm, SCI_DEV_READY);
 }
 
 static void scic_sds_stp_remote_device_ready_idle_substate_resume_complete_handler(void *_dev)
@@ -803,17 +799,16 @@ static void scic_sds_stp_remote_device_ready_idle_substate_resume_complete_handl
 	/* For NCQ operation we do not issue a isci_remote_device_not_ready().
 	 * As a result, avoid sending the ready notification.
 	 */
-	if (sci_dev->state_machine.previous_state_id != SCIC_SDS_STP_REMOTE_DEVICE_READY_SUBSTATE_NCQ)
+	if (sci_dev->sm.previous_state_id != SCI_STP_DEV_NCQ)
 		isci_remote_device_ready(scic_to_ihost(scic), idev);
 }
 
 static void scic_sds_remote_device_initial_state_enter(struct sci_base_state_machine *sm)
 {
-	struct scic_sds_remote_device *sci_dev = container_of(sm, typeof(*sci_dev), state_machine);
+	struct scic_sds_remote_device *sci_dev = container_of(sm, typeof(*sci_dev), sm);
 
 	/* Initial state is a transitional state to the stopped state */
-	sci_base_state_machine_change_state(&sci_dev->state_machine,
-					    SCI_BASE_REMOTE_DEVICE_STATE_STOPPED);
+	sci_change_state(&sci_dev->sm, SCI_DEV_STOPPED);
 }
 
 /**
@@ -831,11 +826,11 @@ static void scic_sds_remote_device_initial_state_enter(struct sci_base_state_mac
  */
 static enum sci_status scic_remote_device_destruct(struct scic_sds_remote_device *sci_dev)
 {
-	struct sci_base_state_machine *sm = &sci_dev->state_machine;
+	struct sci_base_state_machine *sm = &sci_dev->sm;
 	enum scic_sds_remote_device_states state = sm->current_state_id;
 	struct scic_sds_controller *scic;
 
-	if (state != SCI_BASE_REMOTE_DEVICE_STATE_STOPPED) {
+	if (state != SCI_DEV_STOPPED) {
 		dev_warn(scirdev_to_dev(sci_dev), "%s: in wrong state: %d\n",
 			 __func__, state);
 		return SCI_FAILURE_INVALID_STATE;
@@ -845,7 +840,7 @@ static enum sci_status scic_remote_device_destruct(struct scic_sds_remote_device
 	scic_sds_controller_free_remote_node_context(scic, sci_dev,
 						     sci_dev->rnc.remote_node_index);
 	sci_dev->rnc.remote_node_index = SCIC_SDS_REMOTE_NODE_CONTEXT_INVALID_INDEX;
-	sci_base_state_machine_change_state(sm, SCI_BASE_REMOTE_DEVICE_STATE_FINAL);
+	sci_change_state(sm, SCI_DEV_FINAL);
 
 	return SCI_SUCCESS;
 }
@@ -906,7 +901,7 @@ static void isci_remote_device_stop_complete(struct isci_host *ihost,
 
 static void scic_sds_remote_device_stopped_state_enter(struct sci_base_state_machine *sm)
 {
-	struct scic_sds_remote_device *sci_dev = container_of(sm, typeof(*sci_dev), state_machine);
+	struct scic_sds_remote_device *sci_dev = container_of(sm, typeof(*sci_dev), sm);
 	struct scic_sds_controller *scic = sci_dev->owning_port->owning_controller;
 	struct isci_remote_device *idev = sci_dev_to_idev(sci_dev);
 	u32 prev_state;
@@ -914,8 +909,8 @@ static void scic_sds_remote_device_stopped_state_enter(struct sci_base_state_mac
 	/* If we are entering from the stopping state let the SCI User know that
 	 * the stop operation has completed.
 	 */
-	prev_state = sci_dev->state_machine.previous_state_id;
-	if (prev_state == SCI_BASE_REMOTE_DEVICE_STATE_STOPPING)
+	prev_state = sci_dev->sm.previous_state_id;
+	if (prev_state == SCI_DEV_STOPPING)
 		isci_remote_device_stop_complete(scic_to_ihost(scic), idev);
 
 	scic_sds_controller_remote_device_stopped(scic, sci_dev);
@@ -923,7 +918,7 @@ static void scic_sds_remote_device_stopped_state_enter(struct sci_base_state_mac
 
 static void scic_sds_remote_device_starting_state_enter(struct sci_base_state_machine *sm)
 {
-	struct scic_sds_remote_device *sci_dev = container_of(sm, typeof(*sci_dev), state_machine);
+	struct scic_sds_remote_device *sci_dev = container_of(sm, typeof(*sci_dev), sm);
 	struct scic_sds_controller *scic = scic_sds_remote_device_get_controller(sci_dev);
 	struct isci_host *ihost = scic_to_ihost(scic);
 	struct isci_remote_device *idev = sci_dev_to_idev(sci_dev);
@@ -934,7 +929,7 @@ static void scic_sds_remote_device_starting_state_enter(struct sci_base_state_ma
 
 static void scic_sds_remote_device_ready_state_enter(struct sci_base_state_machine *sm)
 {
-	struct scic_sds_remote_device *sci_dev = container_of(sm, typeof(*sci_dev), state_machine);
+	struct scic_sds_remote_device *sci_dev = container_of(sm, typeof(*sci_dev), sm);
 	struct scic_sds_controller *scic = sci_dev->owning_port->owning_controller;
 	struct isci_remote_device *idev = sci_dev_to_idev(sci_dev);
 	struct domain_device *dev = idev->domain_dev;
@@ -942,18 +937,16 @@ static void scic_sds_remote_device_ready_state_enter(struct sci_base_state_machi
 	scic->remote_device_sequence[sci_dev->rnc.remote_node_index]++;
 
 	if (dev->dev_type == SATA_DEV || (dev->tproto & SAS_PROTOCOL_SATA)) {
-		sci_base_state_machine_change_state(&sci_dev->state_machine,
-						    SCIC_SDS_STP_REMOTE_DEVICE_READY_SUBSTATE_IDLE);
+		sci_change_state(&sci_dev->sm, SCI_STP_DEV_IDLE);
 	} else if (dev_is_expander(dev)) {
-		sci_base_state_machine_change_state(&sci_dev->state_machine,
-						    SCIC_SDS_SMP_REMOTE_DEVICE_READY_SUBSTATE_IDLE);
+		sci_change_state(&sci_dev->sm, SCI_SMP_DEV_IDLE);
 	} else
 		isci_remote_device_ready(scic_to_ihost(scic), idev);
 }
 
 static void scic_sds_remote_device_ready_state_exit(struct sci_base_state_machine *sm)
 {
-	struct scic_sds_remote_device *sci_dev = container_of(sm, typeof(*sci_dev), state_machine);
+	struct scic_sds_remote_device *sci_dev = container_of(sm, typeof(*sci_dev), sm);
 	struct domain_device *dev = sci_dev_to_domain(sci_dev);
 
 	if (dev->dev_type == SAS_END_DEV) {
@@ -967,7 +960,7 @@ static void scic_sds_remote_device_ready_state_exit(struct sci_base_state_machin
 
 static void scic_sds_remote_device_resetting_state_enter(struct sci_base_state_machine *sm)
 {
-	struct scic_sds_remote_device *sci_dev = container_of(sm, typeof(*sci_dev), state_machine);
+	struct scic_sds_remote_device *sci_dev = container_of(sm, typeof(*sci_dev), sm);
 
 	scic_sds_remote_node_context_suspend(
 		&sci_dev->rnc, SCI_SOFTWARE_SUSPENSION, NULL, NULL);
@@ -975,14 +968,14 @@ static void scic_sds_remote_device_resetting_state_enter(struct sci_base_state_m
 
 static void scic_sds_remote_device_resetting_state_exit(struct sci_base_state_machine *sm)
 {
-	struct scic_sds_remote_device *sci_dev = container_of(sm, typeof(*sci_dev), state_machine);
+	struct scic_sds_remote_device *sci_dev = container_of(sm, typeof(*sci_dev), sm);
 
 	scic_sds_remote_node_context_resume(&sci_dev->rnc, NULL, NULL);
 }
 
 static void scic_sds_stp_remote_device_ready_idle_substate_enter(struct sci_base_state_machine *sm)
 {
-	struct scic_sds_remote_device *sci_dev = container_of(sm, typeof(*sci_dev), state_machine);
+	struct scic_sds_remote_device *sci_dev = container_of(sm, typeof(*sci_dev), sm);
 
 	sci_dev->working_request = NULL;
 	if (scic_sds_remote_node_context_is_ready(&sci_dev->rnc)) {
@@ -999,7 +992,7 @@ static void scic_sds_stp_remote_device_ready_idle_substate_enter(struct sci_base
 
 static void scic_sds_stp_remote_device_ready_cmd_substate_enter(struct sci_base_state_machine *sm)
 {
-	struct scic_sds_remote_device *sci_dev = container_of(sm, typeof(*sci_dev), state_machine);
+	struct scic_sds_remote_device *sci_dev = container_of(sm, typeof(*sci_dev), sm);
 	struct scic_sds_controller *scic = scic_sds_remote_device_get_controller(sci_dev);
 
 	BUG_ON(sci_dev->working_request == NULL);
@@ -1010,7 +1003,7 @@ static void scic_sds_stp_remote_device_ready_cmd_substate_enter(struct sci_base_
 
 static void scic_sds_stp_remote_device_ready_ncq_error_substate_enter(struct sci_base_state_machine *sm)
 {
-	struct scic_sds_remote_device *sci_dev = container_of(sm, typeof(*sci_dev), state_machine);
+	struct scic_sds_remote_device *sci_dev = container_of(sm, typeof(*sci_dev), sm);
 	struct scic_sds_controller *scic = scic_sds_remote_device_get_controller(sci_dev);
 	struct isci_remote_device *idev = sci_dev_to_idev(sci_dev);
 
@@ -1021,7 +1014,7 @@ static void scic_sds_stp_remote_device_ready_ncq_error_substate_enter(struct sci
 
 static void scic_sds_smp_remote_device_ready_idle_substate_enter(struct sci_base_state_machine *sm)
 {
-	struct scic_sds_remote_device *sci_dev = container_of(sm, typeof(*sci_dev), state_machine);
+	struct scic_sds_remote_device *sci_dev = container_of(sm, typeof(*sci_dev), sm);
 	struct scic_sds_controller *scic = scic_sds_remote_device_get_controller(sci_dev);
 
 	isci_remote_device_ready(scic_to_ihost(scic), sci_dev_to_idev(sci_dev));
@@ -1029,7 +1022,7 @@ static void scic_sds_smp_remote_device_ready_idle_substate_enter(struct sci_base
 
 static void scic_sds_smp_remote_device_ready_cmd_substate_enter(struct sci_base_state_machine *sm)
 {
-	struct scic_sds_remote_device *sci_dev = container_of(sm, typeof(*sci_dev), state_machine);
+	struct scic_sds_remote_device *sci_dev = container_of(sm, typeof(*sci_dev), sm);
 	struct scic_sds_controller *scic = scic_sds_remote_device_get_controller(sci_dev);
 
 	BUG_ON(sci_dev->working_request == NULL);
@@ -1040,50 +1033,50 @@ static void scic_sds_smp_remote_device_ready_cmd_substate_enter(struct sci_base_
 
 static void scic_sds_smp_remote_device_ready_cmd_substate_exit(struct sci_base_state_machine *sm)
 {
-	struct scic_sds_remote_device *sci_dev = container_of(sm, typeof(*sci_dev), state_machine);
+	struct scic_sds_remote_device *sci_dev = container_of(sm, typeof(*sci_dev), sm);
 
 	sci_dev->working_request = NULL;
 }
 
 static const struct sci_base_state scic_sds_remote_device_state_table[] = {
-	[SCI_BASE_REMOTE_DEVICE_STATE_INITIAL] = {
+	[SCI_DEV_INITIAL] = {
 		.enter_state = scic_sds_remote_device_initial_state_enter,
 	},
-	[SCI_BASE_REMOTE_DEVICE_STATE_STOPPED] = {
+	[SCI_DEV_STOPPED] = {
 		.enter_state = scic_sds_remote_device_stopped_state_enter,
 	},
-	[SCI_BASE_REMOTE_DEVICE_STATE_STARTING] = {
+	[SCI_DEV_STARTING] = {
 		.enter_state = scic_sds_remote_device_starting_state_enter,
 	},
-	[SCI_BASE_REMOTE_DEVICE_STATE_READY] = {
+	[SCI_DEV_READY] = {
 		.enter_state = scic_sds_remote_device_ready_state_enter,
 		.exit_state  = scic_sds_remote_device_ready_state_exit
 	},
-	[SCIC_SDS_STP_REMOTE_DEVICE_READY_SUBSTATE_IDLE] = {
+	[SCI_STP_DEV_IDLE] = {
 		.enter_state = scic_sds_stp_remote_device_ready_idle_substate_enter,
 	},
-	[SCIC_SDS_STP_REMOTE_DEVICE_READY_SUBSTATE_CMD] = {
+	[SCI_STP_DEV_CMD] = {
 		.enter_state = scic_sds_stp_remote_device_ready_cmd_substate_enter,
 	},
-	[SCIC_SDS_STP_REMOTE_DEVICE_READY_SUBSTATE_NCQ] = { },
-	[SCIC_SDS_STP_REMOTE_DEVICE_READY_SUBSTATE_NCQ_ERROR] = {
+	[SCI_STP_DEV_NCQ] = { },
+	[SCI_STP_DEV_NCQ_ERROR] = {
 		.enter_state = scic_sds_stp_remote_device_ready_ncq_error_substate_enter,
 	},
-	[SCIC_SDS_STP_REMOTE_DEVICE_READY_SUBSTATE_AWAIT_RESET] = { },
-	[SCIC_SDS_SMP_REMOTE_DEVICE_READY_SUBSTATE_IDLE] = {
+	[SCI_STP_DEV_AWAIT_RESET] = { },
+	[SCI_SMP_DEV_IDLE] = {
 		.enter_state = scic_sds_smp_remote_device_ready_idle_substate_enter,
 	},
-	[SCIC_SDS_SMP_REMOTE_DEVICE_READY_SUBSTATE_CMD] = {
+	[SCI_SMP_DEV_CMD] = {
 		.enter_state = scic_sds_smp_remote_device_ready_cmd_substate_enter,
 		.exit_state  = scic_sds_smp_remote_device_ready_cmd_substate_exit,
 	},
-	[SCI_BASE_REMOTE_DEVICE_STATE_STOPPING] = { },
-	[SCI_BASE_REMOTE_DEVICE_STATE_FAILED] = { },
-	[SCI_BASE_REMOTE_DEVICE_STATE_RESETTING] = {
+	[SCI_DEV_STOPPING] = { },
+	[SCI_DEV_FAILED] = { },
+	[SCI_DEV_RESETTING] = {
 		.enter_state = scic_sds_remote_device_resetting_state_enter,
 		.exit_state  = scic_sds_remote_device_resetting_state_exit
 	},
-	[SCI_BASE_REMOTE_DEVICE_STATE_FINAL] = { },
+	[SCI_DEV_FINAL] = { },
 };
 
 /**
@@ -1102,11 +1095,11 @@ static void scic_remote_device_construct(struct scic_sds_port *sci_port,
 	sci_dev->owning_port = sci_port;
 	sci_dev->started_request_count = 0;
 
-	sci_base_state_machine_construct(&sci_dev->state_machine,
+	sci_base_state_machine_construct(&sci_dev->sm,
 					 scic_sds_remote_device_state_table,
-					 SCI_BASE_REMOTE_DEVICE_STATE_INITIAL);
+					 SCI_DEV_INITIAL);
 
-	sci_base_state_machine_start(&sci_dev->state_machine);
+	sci_base_state_machine_start(&sci_dev->sm);
 
 	scic_sds_remote_node_context_construct(&sci_dev->rnc,
 					       SCIC_SDS_REMOTE_NODE_CONTEXT_INVALID_INDEX);
@@ -1224,11 +1217,11 @@ static enum sci_status scic_remote_device_ea_construct(struct scic_sds_port *sci
 static enum sci_status scic_remote_device_start(struct scic_sds_remote_device *sci_dev,
 						u32 timeout)
 {
-	struct sci_base_state_machine *sm = &sci_dev->state_machine;
+	struct sci_base_state_machine *sm = &sci_dev->sm;
 	enum scic_sds_remote_device_states state = sm->current_state_id;
 	enum sci_status status;
 
-	if (state != SCI_BASE_REMOTE_DEVICE_STATE_STOPPED) {
+	if (state != SCI_DEV_STOPPED) {
 		dev_warn(scirdev_to_dev(sci_dev), "%s: in wrong state: %d\n",
 			 __func__, state);
 		return SCI_FAILURE_INVALID_STATE;
@@ -1240,7 +1233,7 @@ static enum sci_status scic_remote_device_start(struct scic_sds_remote_device *s
 	if (status != SCI_SUCCESS)
 		return status;
 
-	sci_base_state_machine_change_state(sm, SCI_BASE_REMOTE_DEVICE_STATE_STARTING);
+	sci_change_state(sm, SCI_DEV_STARTING);
 
 	return SCI_SUCCESS;
 }

commit 9269e0e898594c65dee6b20d4ed48e33dbbd4eeb
Author: Dan Williams <dan.j.williams@intel.com>
Date:   Thu May 12 07:42:17 2011 -0700

    isci: add some type safety to the state machine interface
    
    Now that any given object type only has one state_machine we can use
    container_of() to get back to the given state machine owner.
    
    Reported-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/drivers/scsi/isci/remote_device.c b/drivers/scsi/isci/remote_device.c
index b900e2c1b63e..68b63b04be19 100644
--- a/drivers/scsi/isci/remote_device.c
+++ b/drivers/scsi/isci/remote_device.c
@@ -807,9 +807,9 @@ static void scic_sds_stp_remote_device_ready_idle_substate_resume_complete_handl
 		isci_remote_device_ready(scic_to_ihost(scic), idev);
 }
 
-static void scic_sds_remote_device_initial_state_enter(void *object)
+static void scic_sds_remote_device_initial_state_enter(struct sci_base_state_machine *sm)
 {
-	struct scic_sds_remote_device *sci_dev = object;
+	struct scic_sds_remote_device *sci_dev = container_of(sm, typeof(*sci_dev), state_machine);
 
 	/* Initial state is a transitional state to the stopped state */
 	sci_base_state_machine_change_state(&sci_dev->state_machine,
@@ -904,9 +904,9 @@ static void isci_remote_device_stop_complete(struct isci_host *ihost,
 	isci_remote_device_deconstruct(ihost, idev);
 }
 
-static void scic_sds_remote_device_stopped_state_enter(void *object)
+static void scic_sds_remote_device_stopped_state_enter(struct sci_base_state_machine *sm)
 {
-	struct scic_sds_remote_device *sci_dev = object;
+	struct scic_sds_remote_device *sci_dev = container_of(sm, typeof(*sci_dev), state_machine);
 	struct scic_sds_controller *scic = sci_dev->owning_port->owning_controller;
 	struct isci_remote_device *idev = sci_dev_to_idev(sci_dev);
 	u32 prev_state;
@@ -921,9 +921,9 @@ static void scic_sds_remote_device_stopped_state_enter(void *object)
 	scic_sds_controller_remote_device_stopped(scic, sci_dev);
 }
 
-static void scic_sds_remote_device_starting_state_enter(void *object)
+static void scic_sds_remote_device_starting_state_enter(struct sci_base_state_machine *sm)
 {
-	struct scic_sds_remote_device *sci_dev = object;
+	struct scic_sds_remote_device *sci_dev = container_of(sm, typeof(*sci_dev), state_machine);
 	struct scic_sds_controller *scic = scic_sds_remote_device_get_controller(sci_dev);
 	struct isci_host *ihost = scic_to_ihost(scic);
 	struct isci_remote_device *idev = sci_dev_to_idev(sci_dev);
@@ -932,9 +932,9 @@ static void scic_sds_remote_device_starting_state_enter(void *object)
 				     SCIC_REMOTE_DEVICE_NOT_READY_START_REQUESTED);
 }
 
-static void scic_sds_remote_device_ready_state_enter(void *object)
+static void scic_sds_remote_device_ready_state_enter(struct sci_base_state_machine *sm)
 {
-	struct scic_sds_remote_device *sci_dev = object;
+	struct scic_sds_remote_device *sci_dev = container_of(sm, typeof(*sci_dev), state_machine);
 	struct scic_sds_controller *scic = sci_dev->owning_port->owning_controller;
 	struct isci_remote_device *idev = sci_dev_to_idev(sci_dev);
 	struct domain_device *dev = idev->domain_dev;
@@ -951,9 +951,9 @@ static void scic_sds_remote_device_ready_state_enter(void *object)
 		isci_remote_device_ready(scic_to_ihost(scic), idev);
 }
 
-static void scic_sds_remote_device_ready_state_exit(void *object)
+static void scic_sds_remote_device_ready_state_exit(struct sci_base_state_machine *sm)
 {
-	struct scic_sds_remote_device *sci_dev = object;
+	struct scic_sds_remote_device *sci_dev = container_of(sm, typeof(*sci_dev), state_machine);
 	struct domain_device *dev = sci_dev_to_domain(sci_dev);
 
 	if (dev->dev_type == SAS_END_DEV) {
@@ -965,24 +965,24 @@ static void scic_sds_remote_device_ready_state_exit(void *object)
 	}
 }
 
-static void scic_sds_remote_device_resetting_state_enter(void *object)
+static void scic_sds_remote_device_resetting_state_enter(struct sci_base_state_machine *sm)
 {
-	struct scic_sds_remote_device *sci_dev = object;
+	struct scic_sds_remote_device *sci_dev = container_of(sm, typeof(*sci_dev), state_machine);
 
 	scic_sds_remote_node_context_suspend(
 		&sci_dev->rnc, SCI_SOFTWARE_SUSPENSION, NULL, NULL);
 }
 
-static void scic_sds_remote_device_resetting_state_exit(void *object)
+static void scic_sds_remote_device_resetting_state_exit(struct sci_base_state_machine *sm)
 {
-	struct scic_sds_remote_device *sci_dev = object;
+	struct scic_sds_remote_device *sci_dev = container_of(sm, typeof(*sci_dev), state_machine);
 
 	scic_sds_remote_node_context_resume(&sci_dev->rnc, NULL, NULL);
 }
 
-static void scic_sds_stp_remote_device_ready_idle_substate_enter(void *object)
+static void scic_sds_stp_remote_device_ready_idle_substate_enter(struct sci_base_state_machine *sm)
 {
-	struct scic_sds_remote_device *sci_dev = object;
+	struct scic_sds_remote_device *sci_dev = container_of(sm, typeof(*sci_dev), state_machine);
 
 	sci_dev->working_request = NULL;
 	if (scic_sds_remote_node_context_is_ready(&sci_dev->rnc)) {
@@ -997,9 +997,9 @@ static void scic_sds_stp_remote_device_ready_idle_substate_enter(void *object)
 	}
 }
 
-static void scic_sds_stp_remote_device_ready_cmd_substate_enter(void *object)
+static void scic_sds_stp_remote_device_ready_cmd_substate_enter(struct sci_base_state_machine *sm)
 {
-	struct scic_sds_remote_device *sci_dev = object;
+	struct scic_sds_remote_device *sci_dev = container_of(sm, typeof(*sci_dev), state_machine);
 	struct scic_sds_controller *scic = scic_sds_remote_device_get_controller(sci_dev);
 
 	BUG_ON(sci_dev->working_request == NULL);
@@ -1008,9 +1008,9 @@ static void scic_sds_stp_remote_device_ready_cmd_substate_enter(void *object)
 				     SCIC_REMOTE_DEVICE_NOT_READY_SATA_REQUEST_STARTED);
 }
 
-static void scic_sds_stp_remote_device_ready_ncq_error_substate_enter(void *object)
+static void scic_sds_stp_remote_device_ready_ncq_error_substate_enter(struct sci_base_state_machine *sm)
 {
-	struct scic_sds_remote_device *sci_dev = object;
+	struct scic_sds_remote_device *sci_dev = container_of(sm, typeof(*sci_dev), state_machine);
 	struct scic_sds_controller *scic = scic_sds_remote_device_get_controller(sci_dev);
 	struct isci_remote_device *idev = sci_dev_to_idev(sci_dev);
 
@@ -1019,17 +1019,17 @@ static void scic_sds_stp_remote_device_ready_ncq_error_substate_enter(void *obje
 					     sci_dev->not_ready_reason);
 }
 
-static void scic_sds_smp_remote_device_ready_idle_substate_enter(void *object)
+static void scic_sds_smp_remote_device_ready_idle_substate_enter(struct sci_base_state_machine *sm)
 {
-	struct scic_sds_remote_device *sci_dev = object;
+	struct scic_sds_remote_device *sci_dev = container_of(sm, typeof(*sci_dev), state_machine);
 	struct scic_sds_controller *scic = scic_sds_remote_device_get_controller(sci_dev);
 
 	isci_remote_device_ready(scic_to_ihost(scic), sci_dev_to_idev(sci_dev));
 }
 
-static void scic_sds_smp_remote_device_ready_cmd_substate_enter(void *object)
+static void scic_sds_smp_remote_device_ready_cmd_substate_enter(struct sci_base_state_machine *sm)
 {
-	struct scic_sds_remote_device *sci_dev = object;
+	struct scic_sds_remote_device *sci_dev = container_of(sm, typeof(*sci_dev), state_machine);
 	struct scic_sds_controller *scic = scic_sds_remote_device_get_controller(sci_dev);
 
 	BUG_ON(sci_dev->working_request == NULL);
@@ -1038,9 +1038,9 @@ static void scic_sds_smp_remote_device_ready_cmd_substate_enter(void *object)
 				     SCIC_REMOTE_DEVICE_NOT_READY_SMP_REQUEST_STARTED);
 }
 
-static void scic_sds_smp_remote_device_ready_cmd_substate_exit(void *object)
+static void scic_sds_smp_remote_device_ready_cmd_substate_exit(struct sci_base_state_machine *sm)
 {
-	struct scic_sds_remote_device *sci_dev = object;
+	struct scic_sds_remote_device *sci_dev = container_of(sm, typeof(*sci_dev), state_machine);
 
 	sci_dev->working_request = NULL;
 }
@@ -1102,16 +1102,11 @@ static void scic_remote_device_construct(struct scic_sds_port *sci_port,
 	sci_dev->owning_port = sci_port;
 	sci_dev->started_request_count = 0;
 
-	sci_base_state_machine_construct(
-		&sci_dev->state_machine,
-		sci_dev,
-		scic_sds_remote_device_state_table,
-		SCI_BASE_REMOTE_DEVICE_STATE_INITIAL
-		);
+	sci_base_state_machine_construct(&sci_dev->state_machine,
+					 scic_sds_remote_device_state_table,
+					 SCI_BASE_REMOTE_DEVICE_STATE_INITIAL);
 
-	sci_base_state_machine_start(
-		&sci_dev->state_machine
-		);
+	sci_base_state_machine_start(&sci_dev->state_machine);
 
 	scic_sds_remote_node_context_construct(&sci_dev->rnc,
 					       SCIC_SDS_REMOTE_NODE_CONTEXT_INVALID_INDEX);

commit d1c637c35b33ddd2b405956e04b50939bb10ed2a
Author: Dan Williams <dan.j.williams@intel.com>
Date:   Wed May 11 08:27:47 2011 -0700

    isci: unify request frame handlers
    
    Unify the implementation in scic_sds_io_request_frame_handler and kill
    the state handler.
    
    Reported-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/drivers/scsi/isci/remote_device.c b/drivers/scsi/isci/remote_device.c
index 606ee2be154e..b900e2c1b63e 100644
--- a/drivers/scsi/isci/remote_device.c
+++ b/drivers/scsi/isci/remote_device.c
@@ -310,8 +310,7 @@ enum sci_status scic_sds_remote_device_frame_handler(struct scic_sds_remote_devi
 		sci_req = scic_request_by_tag(scic, be16_to_cpu(hdr.tag));
 		if (sci_req && sci_req->target_device == sci_dev) {
 			/* The IO request is now in charge of releasing the frame */
-			status = sci_req->state_handlers->frame_handler(sci_req,
-									frame_index);
+			status = scic_sds_io_request_frame_handler(sci_req, frame_index);
 		} else {
 			/* We could not map this tag to a valid IO
 			 * request Just toss the frame and continue

commit f4636a7b2ab8288466b83a8459d47c43143a70dc
Author: Piotr Sawicki <piotr.sawicki@intel.com>
Date:   Tue May 10 23:50:32 2011 +0000

    isci: unify request start handlers
    
    Unify the implementation in scic_sds_request_start and kill the state
    handler.
    
    Reported-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Piotr Sawicki <piotr.sawicki@intel.com>
    [remove scic_sds_request_constructed_state_start_handler]
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/drivers/scsi/isci/remote_device.c b/drivers/scsi/isci/remote_device.c
index 0bb639dfbada..606ee2be154e 100644
--- a/drivers/scsi/isci/remote_device.c
+++ b/drivers/scsi/isci/remote_device.c
@@ -515,7 +515,7 @@ enum sci_status scic_sds_remote_device_start_io(struct scic_sds_controller *scic
 		if (status != SCI_SUCCESS)
 			break;
 
-		status = sci_req->state_handlers->start_handler(sci_req);
+		status = scic_sds_request_start(sci_req);
 		if (status != SCI_SUCCESS)
 			break;
 
@@ -540,7 +540,7 @@ enum sci_status scic_sds_remote_device_start_io(struct scic_sds_controller *scic
 			if (status != SCI_SUCCESS)
 				break;
 
-			status = sci_req->state_handlers->start_handler(sci_req);
+			status = scic_sds_request_start(sci_req);
 		} else
 			return SCI_FAILURE_INVALID_STATE;
 		break;
@@ -709,7 +709,7 @@ enum sci_status scic_sds_remote_device_start_task(struct scic_sds_controller *sc
 		if (status != SCI_SUCCESS)
 			goto out;
 
-		status = sci_req->state_handlers->start_handler(sci_req);
+		status = scic_sds_request_start(sci_req);
 		if (status != SCI_SUCCESS)
 			goto out;
 

commit e2f8db509fdd354bb7a68c86515e9d2d8909ccc9
Author: Dan Williams <dan.j.williams@intel.com>
Date:   Tue May 10 02:28:46 2011 -0700

    isci: uplevel port infrastructure
    
    * Move port configuration agent implementation
    * Merge core/scic_sds_port.[ch] into port.[ch]
    
    Reported-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/drivers/scsi/isci/remote_device.c b/drivers/scsi/isci/remote_device.c
index 2baa215cb275..0bb639dfbada 100644
--- a/drivers/scsi/isci/remote_device.c
+++ b/drivers/scsi/isci/remote_device.c
@@ -57,8 +57,6 @@
 #include "port.h"
 #include "remote_device.h"
 #include "request.h"
-#include "scic_port.h"
-#include "scic_sds_port.h"
 #include "remote_node_context.h"
 #include "scu_event_codes.h"
 #include "task.h"

commit d35bc1bd18ab9e986cfb67c5a281a70cfd717f05
Author: Dan Williams <dan.j.williams@intel.com>
Date:   Tue May 10 02:28:45 2011 -0700

    isci: uplevel phy infrastructure
    
    Merge core/scic_sds_phy.[ch] into phy.[ch]
    
    Reported-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/drivers/scsi/isci/remote_device.c b/drivers/scsi/isci/remote_device.c
index 23390102514f..2baa215cb275 100644
--- a/drivers/scsi/isci/remote_device.c
+++ b/drivers/scsi/isci/remote_device.c
@@ -57,9 +57,7 @@
 #include "port.h"
 #include "remote_device.h"
 #include "request.h"
-#include "scic_phy.h"
 #include "scic_port.h"
-#include "scic_sds_phy.h"
 #include "scic_sds_port.h"
 #include "remote_node_context.h"
 #include "scu_event_codes.h"

commit f1f52e75939b56c40b3d153ae99faf2720250242
Author: Dan Williams <dan.j.williams@intel.com>
Date:   Tue May 10 02:28:45 2011 -0700

    isci: uplevel request infrastructure
    
    * Consolidate tiny header files
    * Move files out of core/ (drop core/scic_sds_ prefix)
    * Merge core/scic_sds_request.[ch] into request.[ch]
    * Cleanup request.c namespace (clean forward declarations and global
      namespace pollution)
    
    Reported-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/drivers/scsi/isci/remote_device.c b/drivers/scsi/isci/remote_device.c
index 00334b9ccd80..23390102514f 100644
--- a/drivers/scsi/isci/remote_device.c
+++ b/drivers/scsi/isci/remote_device.c
@@ -57,14 +57,11 @@
 #include "port.h"
 #include "remote_device.h"
 #include "request.h"
-#include "scic_io_request.h"
 #include "scic_phy.h"
 #include "scic_port.h"
 #include "scic_sds_phy.h"
 #include "scic_sds_port.h"
 #include "remote_node_context.h"
-#include "scic_sds_request.h"
-#include "sci_util.h"
 #include "scu_event_codes.h"
 #include "task.h"
 

commit cc9203bf381a465cd115762b9cf7c9a313c874bc
Author: Dan Williams <dan.j.williams@intel.com>
Date:   Sun May 8 17:34:44 2011 -0700

    isci: move core/controller to host
    
    Now that the data structures are unified unify the implementation in
    host.[ch] and cleanup namespace pollution.
    
    Reported-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/drivers/scsi/isci/remote_device.c b/drivers/scsi/isci/remote_device.c
index 8b1ef19a6732..00334b9ccd80 100644
--- a/drivers/scsi/isci/remote_device.c
+++ b/drivers/scsi/isci/remote_device.c
@@ -57,16 +57,13 @@
 #include "port.h"
 #include "remote_device.h"
 #include "request.h"
-#include "scic_controller.h"
 #include "scic_io_request.h"
 #include "scic_phy.h"
 #include "scic_port.h"
-#include "scic_sds_controller.h"
 #include "scic_sds_phy.h"
 #include "scic_sds_port.h"
 #include "remote_node_context.h"
 #include "scic_sds_request.h"
-#include "sci_environment.h"
 #include "sci_util.h"
 #include "scu_event_codes.h"
 #include "task.h"

commit 67ea838d17acdad3331aeae848683c768df96aaa
Author: Dan Williams <dan.j.williams@intel.com>
Date:   Sun May 8 11:47:15 2011 -0700

    isci: unify request data structures
    
    Make scic_sds_request a proper member of isci_request.  Also let's us
    get rid of the dma pool object size tracking since we now know that all
    requests are sizeof(isci_request).  While cleaning up the construct
    routine incidentally replaced SCI_FIELD_OFFSET with offsetof.
    
    Reported-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/drivers/scsi/isci/remote_device.c b/drivers/scsi/isci/remote_device.c
index a441c23b6859..8b1ef19a6732 100644
--- a/drivers/scsi/isci/remote_device.c
+++ b/drivers/scsi/isci/remote_device.c
@@ -473,7 +473,7 @@ enum sci_status scic_sds_remote_device_start_io(struct scic_sds_controller *scic
 	struct sci_base_state_machine *sm = &sci_dev->state_machine;
 	enum scic_sds_remote_device_states state = sm->current_state_id;
 	struct scic_sds_port *sci_port = sci_dev->owning_port;
-	struct isci_request *ireq = sci_req->ireq;
+	struct isci_request *ireq = sci_req_to_ireq(sci_req);
 	enum sci_status status;
 
 	switch (state) {

commit e531381e2f8a68b8737c63c7bb890ad80b2470bd
Author: Dan Williams <dan.j.williams@intel.com>
Date:   Sat May 7 10:11:43 2011 -0700

    isci: unify port data structures
    
    Make scic_sds_port a member of isci_port and merge their lifetimes which
    means removing the port table from scic_sds_controller in favor of the
    one at the isci_host level.  Merge ihost->sas_ports into ihost->ports.
    _
    Reported-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/drivers/scsi/isci/remote_device.c b/drivers/scsi/isci/remote_device.c
index 734d028448b0..a441c23b6859 100644
--- a/drivers/scsi/isci/remote_device.c
+++ b/drivers/scsi/isci/remote_device.c
@@ -1264,7 +1264,7 @@ static enum sci_status scic_remote_device_start(struct scic_sds_remote_device *s
 static enum sci_status isci_remote_device_construct(struct isci_port *iport,
 						    struct isci_remote_device *idev)
 {
-	struct scic_sds_port *sci_port = iport->sci_port_handle;
+	struct scic_sds_port *sci_port = &iport->sci;
 	struct isci_host *ihost = iport->isci_host;
 	struct domain_device *dev = idev->domain_dev;
 	enum sci_status status;

commit cc3dbd0a9178865d4444f8e28b51715808e9ac85
Author: Artur Wojcik <artur.wojcik@intel.com>
Date:   Wed May 4 07:58:16 2011 +0000

    isci: unify isci_host data structures
    
    Make it explicit that isci_host and scic_sds_controller are one in the same
    object.
    
    Signed-off-by: Artur Wojcik <artur.wojcik@intel.com>
    [removed ->ihost back pointer]
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/drivers/scsi/isci/remote_device.c b/drivers/scsi/isci/remote_device.c
index ee6fe1db8f99..734d028448b0 100644
--- a/drivers/scsi/isci/remote_device.c
+++ b/drivers/scsi/isci/remote_device.c
@@ -815,7 +815,7 @@ static void scic_sds_stp_remote_device_ready_idle_substate_resume_complete_handl
 	 * As a result, avoid sending the ready notification.
 	 */
 	if (sci_dev->state_machine.previous_state_id != SCIC_SDS_STP_REMOTE_DEVICE_READY_SUBSTATE_NCQ)
-		isci_remote_device_ready(scic->ihost, idev);
+		isci_remote_device_ready(scic_to_ihost(scic), idev);
 }
 
 static void scic_sds_remote_device_initial_state_enter(void *object)
@@ -918,21 +918,16 @@ static void isci_remote_device_stop_complete(struct isci_host *ihost,
 static void scic_sds_remote_device_stopped_state_enter(void *object)
 {
 	struct scic_sds_remote_device *sci_dev = object;
-	struct scic_sds_controller *scic;
-	struct isci_remote_device *idev;
-	struct isci_host *ihost;
+	struct scic_sds_controller *scic = sci_dev->owning_port->owning_controller;
+	struct isci_remote_device *idev = sci_dev_to_idev(sci_dev);
 	u32 prev_state;
 
-	scic = scic_sds_remote_device_get_controller(sci_dev);
-	ihost = scic->ihost;
-	idev = sci_dev_to_idev(sci_dev);
-
 	/* If we are entering from the stopping state let the SCI User know that
 	 * the stop operation has completed.
 	 */
 	prev_state = sci_dev->state_machine.previous_state_id;
 	if (prev_state == SCI_BASE_REMOTE_DEVICE_STATE_STOPPING)
-		isci_remote_device_stop_complete(ihost, idev);
+		isci_remote_device_stop_complete(scic_to_ihost(scic), idev);
 
 	scic_sds_controller_remote_device_stopped(scic, sci_dev);
 }
@@ -941,7 +936,7 @@ static void scic_sds_remote_device_starting_state_enter(void *object)
 {
 	struct scic_sds_remote_device *sci_dev = object;
 	struct scic_sds_controller *scic = scic_sds_remote_device_get_controller(sci_dev);
-	struct isci_host *ihost = scic->ihost;
+	struct isci_host *ihost = scic_to_ihost(scic);
 	struct isci_remote_device *idev = sci_dev_to_idev(sci_dev);
 
 	isci_remote_device_not_ready(ihost, idev,
@@ -952,7 +947,8 @@ static void scic_sds_remote_device_ready_state_enter(void *object)
 {
 	struct scic_sds_remote_device *sci_dev = object;
 	struct scic_sds_controller *scic = sci_dev->owning_port->owning_controller;
-	struct domain_device *dev = sci_dev_to_domain(sci_dev);
+	struct isci_remote_device *idev = sci_dev_to_idev(sci_dev);
+	struct domain_device *dev = idev->domain_dev;
 
 	scic->remote_device_sequence[sci_dev->rnc.remote_node_index]++;
 
@@ -963,7 +959,7 @@ static void scic_sds_remote_device_ready_state_enter(void *object)
 		sci_base_state_machine_change_state(&sci_dev->state_machine,
 						    SCIC_SDS_SMP_REMOTE_DEVICE_READY_SUBSTATE_IDLE);
 	} else
-		isci_remote_device_ready(scic->ihost, sci_dev_to_idev(sci_dev));
+		isci_remote_device_ready(scic_to_ihost(scic), idev);
 }
 
 static void scic_sds_remote_device_ready_state_exit(void *object)
@@ -975,7 +971,7 @@ static void scic_sds_remote_device_ready_state_exit(void *object)
 		struct scic_sds_controller *scic = sci_dev->owning_port->owning_controller;
 		struct isci_remote_device *idev = sci_dev_to_idev(sci_dev);
 
-		isci_remote_device_not_ready(scic->ihost, idev,
+		isci_remote_device_not_ready(scic_to_ihost(scic), idev,
 					     SCIC_REMOTE_DEVICE_NOT_READY_STOP_REQUESTED);
 	}
 }
@@ -1019,7 +1015,7 @@ static void scic_sds_stp_remote_device_ready_cmd_substate_enter(void *object)
 
 	BUG_ON(sci_dev->working_request == NULL);
 
-	isci_remote_device_not_ready(scic->ihost, sci_dev_to_idev(sci_dev),
+	isci_remote_device_not_ready(scic_to_ihost(scic), sci_dev_to_idev(sci_dev),
 				     SCIC_REMOTE_DEVICE_NOT_READY_SATA_REQUEST_STARTED);
 }
 
@@ -1030,7 +1026,7 @@ static void scic_sds_stp_remote_device_ready_ncq_error_substate_enter(void *obje
 	struct isci_remote_device *idev = sci_dev_to_idev(sci_dev);
 
 	if (sci_dev->not_ready_reason == SCIC_REMOTE_DEVICE_NOT_READY_SATA_SDB_ERROR_FIS_RECEIVED)
-		isci_remote_device_not_ready(scic->ihost, idev,
+		isci_remote_device_not_ready(scic_to_ihost(scic), idev,
 					     sci_dev->not_ready_reason);
 }
 
@@ -1039,7 +1035,7 @@ static void scic_sds_smp_remote_device_ready_idle_substate_enter(void *object)
 	struct scic_sds_remote_device *sci_dev = object;
 	struct scic_sds_controller *scic = scic_sds_remote_device_get_controller(sci_dev);
 
-	isci_remote_device_ready(scic->ihost, sci_dev_to_idev(sci_dev));
+	isci_remote_device_ready(scic_to_ihost(scic), sci_dev_to_idev(sci_dev));
 }
 
 static void scic_sds_smp_remote_device_ready_cmd_substate_enter(void *object)
@@ -1049,7 +1045,7 @@ static void scic_sds_smp_remote_device_ready_cmd_substate_enter(void *object)
 
 	BUG_ON(sci_dev->working_request == NULL);
 
-	isci_remote_device_not_ready(scic->ihost, sci_dev_to_idev(sci_dev),
+	isci_remote_device_not_ready(scic_to_ihost(scic), sci_dev_to_idev(sci_dev),
 				     SCIC_REMOTE_DEVICE_NOT_READY_SMP_REQUEST_STARTED);
 }
 

commit d06b487b78f28a02efdcdcc9ec295bf230b9d0e8
Author: Dan Williams <dan.j.williams@intel.com>
Date:   Mon May 2 13:59:25 2011 -0700

    isci: implement I_T_nexus_reset
    
    This is a requirement for 2.6.39's new libata eh.
    
    Still some questions about lldd_dev_gone racing against dev->lldd_dev
    lookups, but we are at least no more broken than mvsas in this regard.
    
    We also short-circuit I_T_nexus_reset invocations from the device
    discovery path (IDEV_EH similar to MVS_DEV_EH) to filter out the
    resulting domain rediscoveries triggered by the reset.
    
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/drivers/scsi/isci/remote_device.c b/drivers/scsi/isci/remote_device.c
index 15c1e6c3b223..ee6fe1db8f99 100644
--- a/drivers/scsi/isci/remote_device.c
+++ b/drivers/scsi/isci/remote_device.c
@@ -891,6 +891,7 @@ static void isci_remote_device_deconstruct(struct isci_host *ihost, struct isci_
 
 	clear_bit(IDEV_START_PENDING, &idev->flags);
 	clear_bit(IDEV_STOP_PENDING, &idev->flags);
+	clear_bit(IDEV_EH, &idev->flags);
 	wake_up(&ihost->eventq);
 }
 

commit 8694e79287ad92e351feceededeb6804babb6d9a
Author: Dave Jiang <dave.jiang@intel.com>
Date:   Wed May 4 19:01:01 2011 -0700

    isci: removing intel_*.h headers
    
    Signed-off-by: Dave Jiang <dave.jiang@intel.com>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/drivers/scsi/isci/remote_device.c b/drivers/scsi/isci/remote_device.c
index 89cdd0a05abc..15c1e6c3b223 100644
--- a/drivers/scsi/isci/remote_device.c
+++ b/drivers/scsi/isci/remote_device.c
@@ -53,8 +53,6 @@
  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
 #include <scsi/sas.h>
-#include "intel_sas.h"
-#include "sas.h"
 #include "isci.h"
 #include "port.h"
 #include "remote_device.h"

commit 2d9c2240e0bad47e8d08091016b537287a263976
Author: Dave Jiang <dave.jiang@intel.com>
Date:   Wed May 4 18:45:05 2011 -0700

    isci: Using Linux SSP frame header
    
    Removing of struct sci_ssp_frame_header and migrate to struct ssp_frame_hdr.
    
    Signed-off-by: Dave Jiang <dave.jiang@intel.com>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/drivers/scsi/isci/remote_device.c b/drivers/scsi/isci/remote_device.c
index e766b27bdc19..89cdd0a05abc 100644
--- a/drivers/scsi/isci/remote_device.c
+++ b/drivers/scsi/isci/remote_device.c
@@ -52,6 +52,7 @@
  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
+#include <scsi/sas.h>
 #include "intel_sas.h"
 #include "sas.h"
 #include "isci.h"
@@ -305,15 +306,20 @@ enum sci_status scic_sds_remote_device_frame_handler(struct scic_sds_remote_devi
 	case SCI_BASE_REMOTE_DEVICE_STATE_FAILED:
 	case SCI_BASE_REMOTE_DEVICE_STATE_RESETTING: {
 		struct scic_sds_request *sci_req;
-		struct sci_ssp_frame_header *hdr;
+		struct ssp_frame_hdr hdr;
+		void *frame_header;
+		ssize_t word_cnt;
 
 		status = scic_sds_unsolicited_frame_control_get_header(&scic->uf_control,
 								       frame_index,
-								       (void **)&hdr);
+								       &frame_header);
 		if (status != SCI_SUCCESS)
 			return status;
 
-		sci_req = scic_sds_controller_get_io_request_from_tag(scic, hdr->tag);
+		word_cnt = sizeof(hdr) / sizeof(u32);
+		sci_swab32_cpy(&hdr, frame_header, word_cnt);
+
+		sci_req = scic_request_by_tag(scic, be16_to_cpu(hdr.tag));
 		if (sci_req && sci_req->target_device == sci_dev) {
 			/* The IO request is now in charge of releasing the frame */
 			status = sci_req->state_handlers->frame_handler(sci_req,

commit e76d6180da436edf2cc3538cbed1f5b02b614613
Author: Dave Jiang <dave.jiang@intel.com>
Date:   Wed May 4 15:02:03 2011 -0700

    isci: Convert ATA defines to Linux native defines
    
    * Removing all intel_sata and intel_ata defines
    * Removing the usage of SAT_PROTOCOL_*. We can get everything from sas_task
    * Moved SATA FIS types to local sas.h. These defines will have to go
      into include/scsi/sas.h eventually.
    * Added offsets for SATA FIS header in order to grab the values
    
    Signed-off-by: Dave Jiang <dave.jiang@intel.com>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/drivers/scsi/isci/remote_device.c b/drivers/scsi/isci/remote_device.c
index a23ebe85773e..e766b27bdc19 100644
--- a/drivers/scsi/isci/remote_device.c
+++ b/drivers/scsi/isci/remote_device.c
@@ -53,7 +53,7 @@
  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
 #include "intel_sas.h"
-#include "intel_ata.h"
+#include "sas.h"
 #include "isci.h"
 #include "port.h"
 #include "remote_device.h"
@@ -327,7 +327,7 @@ enum sci_status scic_sds_remote_device_frame_handler(struct scic_sds_remote_devi
 		break;
 	}
 	case SCIC_SDS_STP_REMOTE_DEVICE_READY_SUBSTATE_NCQ: {
-		struct sata_fis_header *hdr;
+		struct dev_to_host_fis *hdr;
 
 		status = scic_sds_unsolicited_frame_control_get_header(&scic->uf_control,
 								       frame_index,
@@ -335,14 +335,14 @@ enum sci_status scic_sds_remote_device_frame_handler(struct scic_sds_remote_devi
 		if (status != SCI_SUCCESS)
 			return status;
 
-		if (hdr->fis_type == SATA_FIS_TYPE_SETDEVBITS &&
-		    (hdr->status & ATA_STATUS_REG_ERROR_BIT)) {
+		if (hdr->fis_type == FIS_SETDEVBITS &&
+		    (hdr->status & ATA_ERR)) {
 			sci_dev->not_ready_reason = SCIC_REMOTE_DEVICE_NOT_READY_SATA_SDB_ERROR_FIS_RECEIVED;
 
 			/* TODO Check sactive and complete associated IO if any. */
 			sci_base_state_machine_change_state(sm, SCIC_SDS_STP_REMOTE_DEVICE_READY_SUBSTATE_NCQ_ERROR);
-		} else if (hdr->fis_type == SATA_FIS_TYPE_REGD2H &&
-			   (hdr->status & ATA_STATUS_REG_ERROR_BIT)) {
+		} else if (hdr->fis_type == FIS_REGD2H &&
+			   (hdr->status & ATA_ERR)) {
 			/*
 			 * Some devices return D2H FIS when an NCQ error is detected.
 			 * Treat this like an SDB error FIS ready reason.
@@ -469,6 +469,7 @@ enum sci_status scic_sds_remote_device_start_io(struct scic_sds_controller *scic
 	struct sci_base_state_machine *sm = &sci_dev->state_machine;
 	enum scic_sds_remote_device_states state = sm->current_state_id;
 	struct scic_sds_port *sci_port = sci_dev->owning_port;
+	struct isci_request *ireq = sci_req->ireq;
 	enum sci_status status;
 
 	switch (state) {
@@ -510,6 +511,7 @@ enum sci_status scic_sds_remote_device_start_io(struct scic_sds_controller *scic
 		 * substate.
 		 */
 		enum scic_sds_remote_device_states new_state;
+		struct sas_task *task = isci_request_access_task(ireq);
 
 		status = scic_sds_port_start_io(sci_port, sci_dev, sci_req);
 		if (status != SCI_SUCCESS)
@@ -523,7 +525,7 @@ enum sci_status scic_sds_remote_device_start_io(struct scic_sds_controller *scic
 		if (status != SCI_SUCCESS)
 			break;
 
-		if (isci_sata_get_sat_protocol(sci_req->ireq) == SAT_PROTOCOL_FPDMA)
+		if (task->ata_task.use_ncq)
 			new_state = SCIC_SDS_STP_REMOTE_DEVICE_READY_SUBSTATE_NCQ;
 		else {
 			sci_dev->working_request = sci_req;
@@ -532,8 +534,10 @@ enum sci_status scic_sds_remote_device_start_io(struct scic_sds_controller *scic
 		sci_base_state_machine_change_state(sm, new_state);
 		break;
 	}
-	case SCIC_SDS_STP_REMOTE_DEVICE_READY_SUBSTATE_NCQ:
-		if (isci_sata_get_sat_protocol(sci_req->ireq) == SAT_PROTOCOL_FPDMA) {
+	case SCIC_SDS_STP_REMOTE_DEVICE_READY_SUBSTATE_NCQ: {
+		struct sas_task *task = isci_request_access_task(ireq);
+
+		if (task->ata_task.use_ncq) {
 			status = scic_sds_port_start_io(sci_port, sci_dev, sci_req);
 			if (status != SCI_SUCCESS)
 				return status;
@@ -546,6 +550,7 @@ enum sci_status scic_sds_remote_device_start_io(struct scic_sds_controller *scic
 		} else
 			return SCI_FAILURE_INVALID_STATE;
 		break;
+	}
 	case SCIC_SDS_STP_REMOTE_DEVICE_READY_SUBSTATE_AWAIT_RESET:
 		return SCI_FAILURE_REMOTE_DEVICE_RESET_REQUIRED;
 	case SCIC_SDS_SMP_REMOTE_DEVICE_READY_SUBSTATE_IDLE:

commit 971cc2ff90875a4ca28b7da5b91a408cc8151fdc
Author: Dan Williams <dan.j.williams@intel.com>
Date:   Sun May 1 16:58:46 2011 -0700

    isci: kill scic_sds_remote_device.state_handlers
    
    Remove the now unused state_handler infrastructure for remote_devices.
    
    Reported-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/drivers/scsi/isci/remote_device.c b/drivers/scsi/isci/remote_device.c
index 0295349b40e5..a23ebe85773e 100644
--- a/drivers/scsi/isci/remote_device.c
+++ b/drivers/scsi/isci/remote_device.c
@@ -809,46 +809,10 @@ static void scic_sds_stp_remote_device_ready_idle_substate_resume_complete_handl
 		isci_remote_device_ready(scic->ihost, idev);
 }
 
-static const struct scic_sds_remote_device_state_handler scic_sds_remote_device_state_handler_table[] = {
-	[SCI_BASE_REMOTE_DEVICE_STATE_INITIAL] = {
-	},
-	[SCI_BASE_REMOTE_DEVICE_STATE_STOPPED] = {
-	},
-	[SCI_BASE_REMOTE_DEVICE_STATE_STARTING] = {
-	},
-	[SCI_BASE_REMOTE_DEVICE_STATE_READY] = {
-	},
-	[SCIC_SDS_STP_REMOTE_DEVICE_READY_SUBSTATE_IDLE] = {
-	},
-	[SCIC_SDS_STP_REMOTE_DEVICE_READY_SUBSTATE_CMD] = {
-	},
-	[SCIC_SDS_STP_REMOTE_DEVICE_READY_SUBSTATE_NCQ] = {
-	},
-	[SCIC_SDS_STP_REMOTE_DEVICE_READY_SUBSTATE_NCQ_ERROR] = {
-	},
-	[SCIC_SDS_STP_REMOTE_DEVICE_READY_SUBSTATE_AWAIT_RESET] = {
-	},
-	[SCIC_SDS_SMP_REMOTE_DEVICE_READY_SUBSTATE_IDLE] = {
-	},
-	[SCIC_SDS_SMP_REMOTE_DEVICE_READY_SUBSTATE_CMD] = {
-	},
-	[SCI_BASE_REMOTE_DEVICE_STATE_STOPPING] = {
-	},
-	[SCI_BASE_REMOTE_DEVICE_STATE_FAILED] = {
-	},
-	[SCI_BASE_REMOTE_DEVICE_STATE_RESETTING] = {
-	},
-	[SCI_BASE_REMOTE_DEVICE_STATE_FINAL] = {
-	}
-};
-
 static void scic_sds_remote_device_initial_state_enter(void *object)
 {
 	struct scic_sds_remote_device *sci_dev = object;
 
-	SET_STATE_HANDLER(sci_dev, scic_sds_remote_device_state_handler_table,
-			  SCI_BASE_REMOTE_DEVICE_STATE_INITIAL);
-
 	/* Initial state is a transitional state to the stopped state */
 	sci_base_state_machine_change_state(&sci_dev->state_machine,
 					    SCI_BASE_REMOTE_DEVICE_STATE_STOPPED);
@@ -953,9 +917,6 @@ static void scic_sds_remote_device_stopped_state_enter(void *object)
 	ihost = scic->ihost;
 	idev = sci_dev_to_idev(sci_dev);
 
-	SET_STATE_HANDLER(sci_dev, scic_sds_remote_device_state_handler_table,
-			  SCI_BASE_REMOTE_DEVICE_STATE_STOPPED);
-
 	/* If we are entering from the stopping state let the SCI User know that
 	 * the stop operation has completed.
 	 */
@@ -973,9 +934,6 @@ static void scic_sds_remote_device_starting_state_enter(void *object)
 	struct isci_host *ihost = scic->ihost;
 	struct isci_remote_device *idev = sci_dev_to_idev(sci_dev);
 
-	SET_STATE_HANDLER(sci_dev, scic_sds_remote_device_state_handler_table,
-			  SCI_BASE_REMOTE_DEVICE_STATE_STARTING);
-
 	isci_remote_device_not_ready(ihost, idev,
 				     SCIC_REMOTE_DEVICE_NOT_READY_START_REQUESTED);
 }
@@ -986,10 +944,6 @@ static void scic_sds_remote_device_ready_state_enter(void *object)
 	struct scic_sds_controller *scic = sci_dev->owning_port->owning_controller;
 	struct domain_device *dev = sci_dev_to_domain(sci_dev);
 
-	SET_STATE_HANDLER(sci_dev,
-			  scic_sds_remote_device_state_handler_table,
-			  SCI_BASE_REMOTE_DEVICE_STATE_READY);
-
 	scic->remote_device_sequence[sci_dev->rnc.remote_node_index]++;
 
 	if (dev->dev_type == SATA_DEV || (dev->tproto & SAS_PROTOCOL_SATA)) {
@@ -1016,38 +970,10 @@ static void scic_sds_remote_device_ready_state_exit(void *object)
 	}
 }
 
-static void scic_sds_remote_device_stopping_state_enter(void *object)
-{
-	struct scic_sds_remote_device *sci_dev = object;
-
-	SET_STATE_HANDLER(
-		sci_dev,
-		scic_sds_remote_device_state_handler_table,
-		SCI_BASE_REMOTE_DEVICE_STATE_STOPPING
-		);
-}
-
-static void scic_sds_remote_device_failed_state_enter(void *object)
-{
-	struct scic_sds_remote_device *sci_dev = object;
-
-	SET_STATE_HANDLER(
-		sci_dev,
-		scic_sds_remote_device_state_handler_table,
-		SCI_BASE_REMOTE_DEVICE_STATE_FAILED
-		);
-}
-
 static void scic_sds_remote_device_resetting_state_enter(void *object)
 {
 	struct scic_sds_remote_device *sci_dev = object;
 
-	SET_STATE_HANDLER(
-		sci_dev,
-		scic_sds_remote_device_state_handler_table,
-		SCI_BASE_REMOTE_DEVICE_STATE_RESETTING
-		);
-
 	scic_sds_remote_node_context_suspend(
 		&sci_dev->rnc, SCI_SOFTWARE_SUSPENSION, NULL, NULL);
 }
@@ -1059,24 +985,10 @@ static void scic_sds_remote_device_resetting_state_exit(void *object)
 	scic_sds_remote_node_context_resume(&sci_dev->rnc, NULL, NULL);
 }
 
-static void scic_sds_remote_device_final_state_enter(void *object)
-{
-	struct scic_sds_remote_device *sci_dev = object;
-
-	SET_STATE_HANDLER(
-		sci_dev,
-		scic_sds_remote_device_state_handler_table,
-		SCI_BASE_REMOTE_DEVICE_STATE_FINAL
-		);
-}
-
 static void scic_sds_stp_remote_device_ready_idle_substate_enter(void *object)
 {
 	struct scic_sds_remote_device *sci_dev = object;
 
-	SET_STATE_HANDLER(sci_dev, scic_sds_remote_device_state_handler_table,
-			  SCIC_SDS_STP_REMOTE_DEVICE_READY_SUBSTATE_IDLE);
-
 	sci_dev->working_request = NULL;
 	if (scic_sds_remote_node_context_is_ready(&sci_dev->rnc)) {
 		/*
@@ -1097,51 +1009,26 @@ static void scic_sds_stp_remote_device_ready_cmd_substate_enter(void *object)
 
 	BUG_ON(sci_dev->working_request == NULL);
 
-	SET_STATE_HANDLER(sci_dev, scic_sds_remote_device_state_handler_table,
-			  SCIC_SDS_STP_REMOTE_DEVICE_READY_SUBSTATE_CMD);
-
 	isci_remote_device_not_ready(scic->ihost, sci_dev_to_idev(sci_dev),
 				     SCIC_REMOTE_DEVICE_NOT_READY_SATA_REQUEST_STARTED);
 }
 
-static void scic_sds_stp_remote_device_ready_ncq_substate_enter(void *object)
-{
-	struct scic_sds_remote_device *sci_dev = object;
-
-	SET_STATE_HANDLER(sci_dev, scic_sds_remote_device_state_handler_table,
-			  SCIC_SDS_STP_REMOTE_DEVICE_READY_SUBSTATE_NCQ);
-}
-
 static void scic_sds_stp_remote_device_ready_ncq_error_substate_enter(void *object)
 {
 	struct scic_sds_remote_device *sci_dev = object;
 	struct scic_sds_controller *scic = scic_sds_remote_device_get_controller(sci_dev);
 	struct isci_remote_device *idev = sci_dev_to_idev(sci_dev);
 
-	SET_STATE_HANDLER(sci_dev, scic_sds_remote_device_state_handler_table,
-			  SCIC_SDS_STP_REMOTE_DEVICE_READY_SUBSTATE_NCQ_ERROR);
-
 	if (sci_dev->not_ready_reason == SCIC_REMOTE_DEVICE_NOT_READY_SATA_SDB_ERROR_FIS_RECEIVED)
 		isci_remote_device_not_ready(scic->ihost, idev,
 					     sci_dev->not_ready_reason);
 }
 
-static void scic_sds_stp_remote_device_ready_await_reset_substate_enter(void *object)
-{
-	struct scic_sds_remote_device *sci_dev = object;
-
-	SET_STATE_HANDLER(sci_dev, scic_sds_remote_device_state_handler_table,
-		SCIC_SDS_STP_REMOTE_DEVICE_READY_SUBSTATE_AWAIT_RESET);
-}
-
 static void scic_sds_smp_remote_device_ready_idle_substate_enter(void *object)
 {
 	struct scic_sds_remote_device *sci_dev = object;
 	struct scic_sds_controller *scic = scic_sds_remote_device_get_controller(sci_dev);
 
-	SET_STATE_HANDLER(sci_dev, scic_sds_remote_device_state_handler_table,
-			  SCIC_SDS_SMP_REMOTE_DEVICE_READY_SUBSTATE_IDLE);
-
 	isci_remote_device_ready(scic->ihost, sci_dev_to_idev(sci_dev));
 }
 
@@ -1152,9 +1039,6 @@ static void scic_sds_smp_remote_device_ready_cmd_substate_enter(void *object)
 
 	BUG_ON(sci_dev->working_request == NULL);
 
-	SET_STATE_HANDLER(sci_dev, scic_sds_remote_device_state_handler_table,
-			  SCIC_SDS_SMP_REMOTE_DEVICE_READY_SUBSTATE_CMD);
-
 	isci_remote_device_not_ready(scic->ihost, sci_dev_to_idev(sci_dev),
 				     SCIC_REMOTE_DEVICE_NOT_READY_SMP_REQUEST_STARTED);
 }
@@ -1186,15 +1070,11 @@ static const struct sci_base_state scic_sds_remote_device_state_table[] = {
 	[SCIC_SDS_STP_REMOTE_DEVICE_READY_SUBSTATE_CMD] = {
 		.enter_state = scic_sds_stp_remote_device_ready_cmd_substate_enter,
 	},
-	[SCIC_SDS_STP_REMOTE_DEVICE_READY_SUBSTATE_NCQ] = {
-		.enter_state = scic_sds_stp_remote_device_ready_ncq_substate_enter,
-	},
+	[SCIC_SDS_STP_REMOTE_DEVICE_READY_SUBSTATE_NCQ] = { },
 	[SCIC_SDS_STP_REMOTE_DEVICE_READY_SUBSTATE_NCQ_ERROR] = {
 		.enter_state = scic_sds_stp_remote_device_ready_ncq_error_substate_enter,
 	},
-	[SCIC_SDS_STP_REMOTE_DEVICE_READY_SUBSTATE_AWAIT_RESET] = {
-		.enter_state = scic_sds_stp_remote_device_ready_await_reset_substate_enter,
-	},
+	[SCIC_SDS_STP_REMOTE_DEVICE_READY_SUBSTATE_AWAIT_RESET] = { },
 	[SCIC_SDS_SMP_REMOTE_DEVICE_READY_SUBSTATE_IDLE] = {
 		.enter_state = scic_sds_smp_remote_device_ready_idle_substate_enter,
 	},
@@ -1202,19 +1082,13 @@ static const struct sci_base_state scic_sds_remote_device_state_table[] = {
 		.enter_state = scic_sds_smp_remote_device_ready_cmd_substate_enter,
 		.exit_state  = scic_sds_smp_remote_device_ready_cmd_substate_exit,
 	},
-	[SCI_BASE_REMOTE_DEVICE_STATE_STOPPING] = {
-		.enter_state = scic_sds_remote_device_stopping_state_enter,
-	},
-	[SCI_BASE_REMOTE_DEVICE_STATE_FAILED] = {
-		.enter_state = scic_sds_remote_device_failed_state_enter,
-	},
+	[SCI_BASE_REMOTE_DEVICE_STATE_STOPPING] = { },
+	[SCI_BASE_REMOTE_DEVICE_STATE_FAILED] = { },
 	[SCI_BASE_REMOTE_DEVICE_STATE_RESETTING] = {
 		.enter_state = scic_sds_remote_device_resetting_state_enter,
 		.exit_state  = scic_sds_remote_device_resetting_state_exit
 	},
-	[SCI_BASE_REMOTE_DEVICE_STATE_FINAL] = {
-		.enter_state = scic_sds_remote_device_final_state_enter,
-	},
+	[SCI_BASE_REMOTE_DEVICE_STATE_FINAL] = { },
 };
 
 /**

commit 01bec7788db9d1bb2c594d1f1916096ce6299f38
Author: Dan Williams <dan.j.williams@intel.com>
Date:   Sun May 1 16:51:11 2011 -0700

    isci: unify remote_device frame_handlers
    
    Implement all states in scic_sds_remote_device_frame() and delete
    the state handler.
    
    Reported-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/drivers/scsi/isci/remote_device.c b/drivers/scsi/isci/remote_device.c
index 53f4ecfddce4..0295349b40e5 100644
--- a/drivers/scsi/isci/remote_device.c
+++ b/drivers/scsi/isci/remote_device.c
@@ -277,20 +277,96 @@ enum sci_status scic_sds_remote_device_suspend(struct scic_sds_remote_device *sc
 						    suspend_type, NULL, NULL);
 }
 
-/**
- *
- * @sci_dev: The remote device for which the event handling is being
- *    requested.
- * @frame_index: This is the frame index that is being processed.
- *
- * This method invokes the frame handler for the remote device state machine
- * enum sci_status
- */
-enum sci_status scic_sds_remote_device_frame_handler(
-	struct scic_sds_remote_device *sci_dev,
-	u32 frame_index)
+enum sci_status scic_sds_remote_device_frame_handler(struct scic_sds_remote_device *sci_dev,
+						     u32 frame_index)
 {
-	return sci_dev->state_handlers->frame_handler(sci_dev, frame_index);
+	struct sci_base_state_machine *sm = &sci_dev->state_machine;
+	enum scic_sds_remote_device_states state = sm->current_state_id;
+	struct scic_sds_controller *scic = sci_dev->owning_port->owning_controller;
+	enum sci_status status;
+
+	switch (state) {
+	case SCI_BASE_REMOTE_DEVICE_STATE_INITIAL:
+	case SCI_BASE_REMOTE_DEVICE_STATE_STOPPED:
+	case SCI_BASE_REMOTE_DEVICE_STATE_STARTING:
+	case SCIC_SDS_STP_REMOTE_DEVICE_READY_SUBSTATE_IDLE:
+	case SCIC_SDS_SMP_REMOTE_DEVICE_READY_SUBSTATE_IDLE:
+	case SCI_BASE_REMOTE_DEVICE_STATE_FINAL:
+	default:
+		dev_warn(scirdev_to_dev(sci_dev), "%s: in wrong state: %d\n",
+			 __func__, state);
+		/* Return the frame back to the controller */
+		scic_sds_controller_release_frame(scic, frame_index);
+		return SCI_FAILURE_INVALID_STATE;
+	case SCI_BASE_REMOTE_DEVICE_STATE_READY:
+	case SCIC_SDS_STP_REMOTE_DEVICE_READY_SUBSTATE_NCQ_ERROR:
+	case SCIC_SDS_STP_REMOTE_DEVICE_READY_SUBSTATE_AWAIT_RESET:
+	case SCI_BASE_REMOTE_DEVICE_STATE_STOPPING:
+	case SCI_BASE_REMOTE_DEVICE_STATE_FAILED:
+	case SCI_BASE_REMOTE_DEVICE_STATE_RESETTING: {
+		struct scic_sds_request *sci_req;
+		struct sci_ssp_frame_header *hdr;
+
+		status = scic_sds_unsolicited_frame_control_get_header(&scic->uf_control,
+								       frame_index,
+								       (void **)&hdr);
+		if (status != SCI_SUCCESS)
+			return status;
+
+		sci_req = scic_sds_controller_get_io_request_from_tag(scic, hdr->tag);
+		if (sci_req && sci_req->target_device == sci_dev) {
+			/* The IO request is now in charge of releasing the frame */
+			status = sci_req->state_handlers->frame_handler(sci_req,
+									frame_index);
+		} else {
+			/* We could not map this tag to a valid IO
+			 * request Just toss the frame and continue
+			 */
+			scic_sds_controller_release_frame(scic, frame_index);
+		}
+		break;
+	}
+	case SCIC_SDS_STP_REMOTE_DEVICE_READY_SUBSTATE_NCQ: {
+		struct sata_fis_header *hdr;
+
+		status = scic_sds_unsolicited_frame_control_get_header(&scic->uf_control,
+								       frame_index,
+								       (void **)&hdr);
+		if (status != SCI_SUCCESS)
+			return status;
+
+		if (hdr->fis_type == SATA_FIS_TYPE_SETDEVBITS &&
+		    (hdr->status & ATA_STATUS_REG_ERROR_BIT)) {
+			sci_dev->not_ready_reason = SCIC_REMOTE_DEVICE_NOT_READY_SATA_SDB_ERROR_FIS_RECEIVED;
+
+			/* TODO Check sactive and complete associated IO if any. */
+			sci_base_state_machine_change_state(sm, SCIC_SDS_STP_REMOTE_DEVICE_READY_SUBSTATE_NCQ_ERROR);
+		} else if (hdr->fis_type == SATA_FIS_TYPE_REGD2H &&
+			   (hdr->status & ATA_STATUS_REG_ERROR_BIT)) {
+			/*
+			 * Some devices return D2H FIS when an NCQ error is detected.
+			 * Treat this like an SDB error FIS ready reason.
+			 */
+			sci_dev->not_ready_reason = SCIC_REMOTE_DEVICE_NOT_READY_SATA_SDB_ERROR_FIS_RECEIVED;
+			sci_base_state_machine_change_state(&sci_dev->state_machine,
+							    SCIC_SDS_STP_REMOTE_DEVICE_READY_SUBSTATE_NCQ_ERROR);
+		} else
+			status = SCI_FAILURE;
+
+		scic_sds_controller_release_frame(scic, frame_index);
+		break;
+	}
+	case SCIC_SDS_STP_REMOTE_DEVICE_READY_SUBSTATE_CMD:
+	case SCIC_SDS_SMP_REMOTE_DEVICE_READY_SUBSTATE_CMD:
+		/* The device does not process any UF received from the hardware while
+		 * in this state.  All unsolicited frames are forwarded to the io request
+		 * object.
+		 */
+		status = scic_sds_io_request_frame_handler(sci_dev->working_request, frame_index);
+		break;
+	}
+
+	return status;
 }
 
 static bool is_remote_device_ready(struct scic_sds_remote_device *sci_dev)
@@ -720,136 +796,6 @@ static void remote_device_resume_done(void *_dev)
 					    SCI_BASE_REMOTE_DEVICE_STATE_READY);
 }
 
-/**
- *
- * @device: The struct scic_sds_remote_device which is then cast into a
- *    struct scic_sds_remote_device.
- * @frame_index: The frame index for which the struct scic_sds_controller wants this
- *    device object to process.
- *
- * This method is the default unsolicited frame handler.  It logs a warning,
- * releases the frame and returns a failure. enum sci_status
- * SCI_FAILURE_INVALID_STATE
- */
-static enum sci_status scic_sds_remote_device_default_frame_handler(
-	struct scic_sds_remote_device *sci_dev,
-	u32 frame_index)
-{
-	dev_warn(scirdev_to_dev(sci_dev),
-		 "%s: SCIC Remote Device requested to handle frame %x "
-		 "while in wrong state %d\n",
-		 __func__,
-		 frame_index,
-		 sci_base_state_machine_get_state(
-			 &sci_dev->state_machine));
-
-	/* Return the frame back to the controller */
-	scic_sds_controller_release_frame(
-		scic_sds_remote_device_get_controller(sci_dev), frame_index
-		);
-
-	return SCI_FAILURE_INVALID_STATE;
-}
-
-/**
- *
- * @device: The struct scic_sds_remote_device which is then cast into a
- *    struct scic_sds_remote_device.
- * @frame_index: The frame index for which the struct scic_sds_controller wants this
- *    device object to process.
- *
- * This method is a general ssp frame handler.  In most cases the device object
- * needs to route the unsolicited frame processing to the io request object.
- * This method decodes the tag for the io request object and routes the
- * unsolicited frame to that object. enum sci_status SCI_FAILURE_INVALID_STATE
- */
-static enum sci_status scic_sds_remote_device_general_frame_handler(
-	struct scic_sds_remote_device *sci_dev,
-	u32 frame_index)
-{
-	enum sci_status result;
-	struct sci_ssp_frame_header *frame_header;
-	struct scic_sds_request *io_request;
-
-	result = scic_sds_unsolicited_frame_control_get_header(
-		&(scic_sds_remote_device_get_controller(sci_dev)->uf_control),
-		frame_index,
-		(void **)&frame_header
-		);
-
-	if (SCI_SUCCESS == result) {
-		io_request = scic_sds_controller_get_io_request_from_tag(
-			scic_sds_remote_device_get_controller(sci_dev), frame_header->tag);
-
-		if ((io_request == NULL)
-		    || (io_request->target_device != sci_dev)) {
-			/*
-			 * We could not map this tag to a valid IO request
-			 * Just toss the frame and continue */
-			scic_sds_controller_release_frame(
-				scic_sds_remote_device_get_controller(sci_dev), frame_index
-				);
-		} else {
-			/* The IO request is now in charge of releasing the frame */
-			result = io_request->state_handlers->frame_handler(
-				io_request, frame_index);
-		}
-	}
-
-	return result;
-}
-
-static enum sci_status scic_sds_stp_remote_device_ready_ncq_substate_frame_handler(struct scic_sds_remote_device *sci_dev,
-										   u32 frame_index)
-{
-	enum sci_status status;
-	struct sata_fis_header *frame_header;
-	struct scic_sds_controller *scic = sci_dev->owning_port->owning_controller;
-
-	status = scic_sds_unsolicited_frame_control_get_header(&scic->uf_control,
-							       frame_index,
-							       (void **)&frame_header);
-	if (status != SCI_SUCCESS)
-		return status;
-
-	if (frame_header->fis_type == SATA_FIS_TYPE_SETDEVBITS &&
-	    (frame_header->status & ATA_STATUS_REG_ERROR_BIT)) {
-		sci_dev->not_ready_reason = SCIC_REMOTE_DEVICE_NOT_READY_SATA_SDB_ERROR_FIS_RECEIVED;
-
-		/* TODO Check sactive and complete associated IO if any. */
-
-		sci_base_state_machine_change_state(&sci_dev->state_machine,
-						    SCIC_SDS_STP_REMOTE_DEVICE_READY_SUBSTATE_NCQ_ERROR);
-	} else if (frame_header->fis_type == SATA_FIS_TYPE_REGD2H &&
-		   (frame_header->status & ATA_STATUS_REG_ERROR_BIT)) {
-		/*
-		 * Some devices return D2H FIS when an NCQ error is detected.
-		 * Treat this like an SDB error FIS ready reason.
-		 */
-		sci_dev->not_ready_reason = SCIC_REMOTE_DEVICE_NOT_READY_SATA_SDB_ERROR_FIS_RECEIVED;
-
-		sci_base_state_machine_change_state(&sci_dev->state_machine,
-						    SCIC_SDS_STP_REMOTE_DEVICE_READY_SUBSTATE_NCQ_ERROR);
-	} else
-		status = SCI_FAILURE;
-
-	scic_sds_controller_release_frame(scic, frame_index);
-
-	return status;
-}
-
-static enum sci_status scic_sds_stp_remote_device_ready_cmd_substate_frame_handler(
-	struct scic_sds_remote_device *sci_dev,
-	u32 frame_index)
-{
-	/* The device doe not process any UF received from the hardware while
-	 * in this state.  All unsolicited frames are forwarded to the io
-	 * request object.
-	 */
-	return scic_sds_io_request_frame_handler(sci_dev->working_request,
-						 frame_index);
-}
-
 static void scic_sds_stp_remote_device_ready_idle_substate_resume_complete_handler(void *_dev)
 {
 	struct scic_sds_remote_device *sci_dev = _dev;
@@ -863,69 +809,36 @@ static void scic_sds_stp_remote_device_ready_idle_substate_resume_complete_handl
 		isci_remote_device_ready(scic->ihost, idev);
 }
 
-static enum sci_status scic_sds_smp_remote_device_ready_cmd_substate_frame_handler(
-	struct scic_sds_remote_device *sci_dev,
-	u32 frame_index)
-{
-	enum sci_status status;
-
-	/* The device does not process any UF received from the hardware while
-	 * in this state.  All unsolicited frames are forwarded to the io request
-	 * object.
-	 */
-	status = scic_sds_io_request_frame_handler(
-		sci_dev->working_request,
-		frame_index
-		);
-
-	return status;
-}
-
 static const struct scic_sds_remote_device_state_handler scic_sds_remote_device_state_handler_table[] = {
 	[SCI_BASE_REMOTE_DEVICE_STATE_INITIAL] = {
-		.frame_handler		= scic_sds_remote_device_default_frame_handler
 	},
 	[SCI_BASE_REMOTE_DEVICE_STATE_STOPPED] = {
-		.frame_handler		= scic_sds_remote_device_default_frame_handler
 	},
 	[SCI_BASE_REMOTE_DEVICE_STATE_STARTING] = {
-		.frame_handler		= scic_sds_remote_device_default_frame_handler
 	},
 	[SCI_BASE_REMOTE_DEVICE_STATE_READY] = {
-		.frame_handler		= scic_sds_remote_device_general_frame_handler,
 	},
 	[SCIC_SDS_STP_REMOTE_DEVICE_READY_SUBSTATE_IDLE] = {
-		.frame_handler			= scic_sds_remote_device_default_frame_handler
 	},
 	[SCIC_SDS_STP_REMOTE_DEVICE_READY_SUBSTATE_CMD] = {
-		.frame_handler			= scic_sds_stp_remote_device_ready_cmd_substate_frame_handler
 	},
 	[SCIC_SDS_STP_REMOTE_DEVICE_READY_SUBSTATE_NCQ] = {
-		.frame_handler			= scic_sds_stp_remote_device_ready_ncq_substate_frame_handler
 	},
 	[SCIC_SDS_STP_REMOTE_DEVICE_READY_SUBSTATE_NCQ_ERROR] = {
-		.frame_handler			= scic_sds_remote_device_general_frame_handler
 	},
 	[SCIC_SDS_STP_REMOTE_DEVICE_READY_SUBSTATE_AWAIT_RESET] = {
-		.frame_handler			= scic_sds_remote_device_general_frame_handler
 	},
 	[SCIC_SDS_SMP_REMOTE_DEVICE_READY_SUBSTATE_IDLE] = {
-		.frame_handler		= scic_sds_remote_device_default_frame_handler
 	},
 	[SCIC_SDS_SMP_REMOTE_DEVICE_READY_SUBSTATE_CMD] = {
-		.frame_handler		= scic_sds_smp_remote_device_ready_cmd_substate_frame_handler
 	},
 	[SCI_BASE_REMOTE_DEVICE_STATE_STOPPING] = {
-		.frame_handler		= scic_sds_remote_device_general_frame_handler
 	},
 	[SCI_BASE_REMOTE_DEVICE_STATE_FAILED] = {
-		.frame_handler		= scic_sds_remote_device_general_frame_handler
 	},
 	[SCI_BASE_REMOTE_DEVICE_STATE_RESETTING] = {
-		.frame_handler		= scic_sds_remote_device_general_frame_handler
 	},
 	[SCI_BASE_REMOTE_DEVICE_STATE_FINAL] = {
-		.frame_handler		= scic_sds_remote_device_default_frame_handler
 	}
 };
 

commit e622571f0f05986b23eba566b73b3abeb5d847d3
Author: Dan Williams <dan.j.williams@intel.com>
Date:   Sun May 1 16:26:09 2011 -0700

    isci: unify remote_device event_handlers
    
    Implement all states in scic_sds_remote_device_event() and delete
    the state handler.
    
    Reported-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/drivers/scsi/isci/remote_device.c b/drivers/scsi/isci/remote_device.c
index 26c5253530ea..53f4ecfddce4 100644
--- a/drivers/scsi/isci/remote_device.c
+++ b/drivers/scsi/isci/remote_device.c
@@ -293,19 +293,84 @@ enum sci_status scic_sds_remote_device_frame_handler(
 	return sci_dev->state_handlers->frame_handler(sci_dev, frame_index);
 }
 
-/**
- *
- * @sci_dev: The remote device for which the event handling is being
- *    requested.
- * @event_code: This is the event code that is to be processed.
- *
- * This method invokes the remote device event handler. enum sci_status
- */
-enum sci_status scic_sds_remote_device_event_handler(
-	struct scic_sds_remote_device *sci_dev,
-	u32 event_code)
+static bool is_remote_device_ready(struct scic_sds_remote_device *sci_dev)
 {
-	return sci_dev->state_handlers->event_handler(sci_dev, event_code);
+
+	struct sci_base_state_machine *sm = &sci_dev->state_machine;
+	enum scic_sds_remote_device_states state = sm->current_state_id;
+
+	switch (state) {
+	case SCI_BASE_REMOTE_DEVICE_STATE_READY:
+	case SCIC_SDS_STP_REMOTE_DEVICE_READY_SUBSTATE_IDLE:
+	case SCIC_SDS_STP_REMOTE_DEVICE_READY_SUBSTATE_CMD:
+	case SCIC_SDS_STP_REMOTE_DEVICE_READY_SUBSTATE_NCQ:
+	case SCIC_SDS_STP_REMOTE_DEVICE_READY_SUBSTATE_NCQ_ERROR:
+	case SCIC_SDS_STP_REMOTE_DEVICE_READY_SUBSTATE_AWAIT_RESET:
+	case SCIC_SDS_SMP_REMOTE_DEVICE_READY_SUBSTATE_IDLE:
+	case SCIC_SDS_SMP_REMOTE_DEVICE_READY_SUBSTATE_CMD:
+		return true;
+	default:
+		return false;
+	}
+}
+
+enum sci_status scic_sds_remote_device_event_handler(struct scic_sds_remote_device *sci_dev,
+						     u32 event_code)
+{
+	struct sci_base_state_machine *sm = &sci_dev->state_machine;
+	enum scic_sds_remote_device_states state = sm->current_state_id;
+	enum sci_status status;
+
+	switch (scu_get_event_type(event_code)) {
+	case SCU_EVENT_TYPE_RNC_OPS_MISC:
+	case SCU_EVENT_TYPE_RNC_SUSPEND_TX:
+	case SCU_EVENT_TYPE_RNC_SUSPEND_TX_RX:
+		status = scic_sds_remote_node_context_event_handler(&sci_dev->rnc, event_code);
+		break;
+	case SCU_EVENT_TYPE_PTX_SCHEDULE_EVENT:
+		if (scu_get_event_code(event_code) == SCU_EVENT_IT_NEXUS_TIMEOUT) {
+			status = SCI_SUCCESS;
+
+			/* Suspend the associated RNC */
+			scic_sds_remote_node_context_suspend(&sci_dev->rnc,
+							      SCI_SOFTWARE_SUSPENSION,
+							      NULL, NULL);
+
+			dev_dbg(scirdev_to_dev(sci_dev),
+				"%s: device: %p event code: %x: %s\n",
+				__func__, sci_dev, event_code,
+				is_remote_device_ready(sci_dev)
+				? "I_T_Nexus_Timeout event"
+				: "I_T_Nexus_Timeout event in wrong state");
+
+			break;
+		}
+	/* Else, fall through and treat as unhandled... */
+	default:
+		dev_dbg(scirdev_to_dev(sci_dev),
+			"%s: device: %p event code: %x: %s\n",
+			__func__, sci_dev, event_code,
+			is_remote_device_ready(sci_dev)
+			? "unexpected event"
+			: "unexpected event in wrong state");
+		status = SCI_FAILURE_INVALID_STATE;
+		break;
+	}
+
+	if (status != SCI_SUCCESS)
+		return status;
+
+	if (state == SCIC_SDS_STP_REMOTE_DEVICE_READY_SUBSTATE_IDLE) {
+
+		/* We pick up suspension events to handle specifically to this
+		 * state. We resume the RNC right away.
+		 */
+		if (scu_get_event_type(event_code) == SCU_EVENT_TYPE_RNC_SUSPEND_TX ||
+		    scu_get_event_type(event_code) == SCU_EVENT_TYPE_RNC_SUSPEND_TX_RX)
+			status = scic_sds_remote_node_context_resume(&sci_dev->rnc, NULL, NULL);
+	}
+
+	return status;
 }
 
 static void scic_sds_remote_device_start_request(struct scic_sds_remote_device *sci_dev,
@@ -646,103 +711,13 @@ void scic_sds_remote_device_post_request(
 static void remote_device_resume_done(void *_dev)
 {
 	struct scic_sds_remote_device *sci_dev = _dev;
-	enum scic_sds_remote_device_states state;
 
-	state = sci_dev->state_machine.current_state_id;
-	switch (state) {
-	case SCI_BASE_REMOTE_DEVICE_STATE_READY:
-	case SCIC_SDS_STP_REMOTE_DEVICE_READY_SUBSTATE_IDLE:
-	case SCIC_SDS_STP_REMOTE_DEVICE_READY_SUBSTATE_CMD:
-	case SCIC_SDS_STP_REMOTE_DEVICE_READY_SUBSTATE_NCQ:
-	case SCIC_SDS_STP_REMOTE_DEVICE_READY_SUBSTATE_NCQ_ERROR:
-	case SCIC_SDS_STP_REMOTE_DEVICE_READY_SUBSTATE_AWAIT_RESET:
-	case SCIC_SDS_SMP_REMOTE_DEVICE_READY_SUBSTATE_IDLE:
-	case SCIC_SDS_SMP_REMOTE_DEVICE_READY_SUBSTATE_CMD:
-		break;
-	default:
-		/* go 'ready' if we are not already in a ready state */
-		sci_base_state_machine_change_state(&sci_dev->state_machine,
-						    SCI_BASE_REMOTE_DEVICE_STATE_READY);
-		break;
-	}
-}
+	if (is_remote_device_ready(sci_dev))
+		return;
 
-/**
- *
- * @device: The struct scic_sds_remote_device which is then cast into a
- *    struct scic_sds_remote_device.
- * @event_code: The event code that the struct scic_sds_controller wants the device
- *    object to process.
- *
- * This method is the default event handler.  It will call the RNC state
- * machine handler for any RNC events otherwise it will log a warning and
- * returns a failure. enum sci_status SCI_FAILURE_INVALID_STATE
- */
-static enum sci_status  scic_sds_remote_device_core_event_handler(
-	struct scic_sds_remote_device *sci_dev,
-	u32 event_code,
-	bool is_ready_state)
-{
-	enum sci_status status;
-
-	switch (scu_get_event_type(event_code)) {
-	case SCU_EVENT_TYPE_RNC_OPS_MISC:
-	case SCU_EVENT_TYPE_RNC_SUSPEND_TX:
-	case SCU_EVENT_TYPE_RNC_SUSPEND_TX_RX:
-		status = scic_sds_remote_node_context_event_handler(&sci_dev->rnc, event_code);
-		break;
-	case SCU_EVENT_TYPE_PTX_SCHEDULE_EVENT:
-
-		if (scu_get_event_code(event_code) == SCU_EVENT_IT_NEXUS_TIMEOUT) {
-			status = SCI_SUCCESS;
-
-			/* Suspend the associated RNC */
-			scic_sds_remote_node_context_suspend(&sci_dev->rnc,
-							      SCI_SOFTWARE_SUSPENSION,
-							      NULL, NULL);
-
-			dev_dbg(scirdev_to_dev(sci_dev),
-				"%s: device: %p event code: %x: %s\n",
-				__func__, sci_dev, event_code,
-				(is_ready_state)
-				? "I_T_Nexus_Timeout event"
-				: "I_T_Nexus_Timeout event in wrong state");
-
-			break;
-		}
-	/* Else, fall through and treat as unhandled... */
-
-	default:
-		dev_dbg(scirdev_to_dev(sci_dev),
-			"%s: device: %p event code: %x: %s\n",
-			__func__, sci_dev, event_code,
-			(is_ready_state)
-			? "unexpected event"
-			: "unexpected event in wrong state");
-		status = SCI_FAILURE_INVALID_STATE;
-		break;
-	}
-
-	return status;
-}
-/**
- *
- * @device: The struct scic_sds_remote_device which is then cast into a
- *    struct scic_sds_remote_device.
- * @event_code: The event code that the struct scic_sds_controller wants the device
- *    object to process.
- *
- * This method is the default event handler.  It will call the RNC state
- * machine handler for any RNC events otherwise it will log a warning and
- * returns a failure. enum sci_status SCI_FAILURE_INVALID_STATE
- */
-static enum sci_status  scic_sds_remote_device_default_event_handler(
-	struct scic_sds_remote_device *sci_dev,
-	u32 event_code)
-{
-	return scic_sds_remote_device_core_event_handler(sci_dev,
-							  event_code,
-							  false);
+	/* go 'ready' if we are not already in a ready state */
+	sci_base_state_machine_change_state(&sci_dev->state_machine,
+					    SCI_BASE_REMOTE_DEVICE_STATE_READY);
 }
 
 /**
@@ -824,43 +799,6 @@ static enum sci_status scic_sds_remote_device_general_frame_handler(
 	return result;
 }
 
-/**
- *
- * @[in]: sci_dev This is the device object that is receiving the event.
- * @[in]: event_code The event code to process.
- *
- * This is a common method for handling events reported to the remote device
- * from the controller object. enum sci_status
- */
-static enum sci_status scic_sds_remote_device_general_event_handler(
-	struct scic_sds_remote_device *sci_dev,
-	u32 event_code)
-{
-	return scic_sds_remote_device_core_event_handler(sci_dev,
-							  event_code,
-							  true);
-}
-
-static enum sci_status scic_sds_stp_remote_device_ready_idle_substate_event_handler(
-	struct scic_sds_remote_device *sci_dev,
-	u32 event_code)
-{
-	enum sci_status status;
-
-	status = scic_sds_remote_device_general_event_handler(sci_dev, event_code);
-	if (status != SCI_SUCCESS)
-		return status;
-
-	/* We pick up suspension events to handle specifically to this state. We
-	 * resume the RNC right away. enum sci_status
-	 */
-	if (scu_get_event_type(event_code) == SCU_EVENT_TYPE_RNC_SUSPEND_TX ||
-	    scu_get_event_type(event_code) == SCU_EVENT_TYPE_RNC_SUSPEND_TX_RX)
-		status = scic_sds_remote_node_context_resume(&sci_dev->rnc, NULL, NULL);
-
-	return status;
-}
-
 static enum sci_status scic_sds_stp_remote_device_ready_ncq_substate_frame_handler(struct scic_sds_remote_device *sci_dev,
 										   u32 frame_index)
 {
@@ -945,63 +883,48 @@ static enum sci_status scic_sds_smp_remote_device_ready_cmd_substate_frame_handl
 
 static const struct scic_sds_remote_device_state_handler scic_sds_remote_device_state_handler_table[] = {
 	[SCI_BASE_REMOTE_DEVICE_STATE_INITIAL] = {
-		.event_handler		= scic_sds_remote_device_default_event_handler,
 		.frame_handler		= scic_sds_remote_device_default_frame_handler
 	},
 	[SCI_BASE_REMOTE_DEVICE_STATE_STOPPED] = {
-		.event_handler		= scic_sds_remote_device_default_event_handler,
 		.frame_handler		= scic_sds_remote_device_default_frame_handler
 	},
 	[SCI_BASE_REMOTE_DEVICE_STATE_STARTING] = {
-		.event_handler		= scic_sds_remote_device_general_event_handler,
 		.frame_handler		= scic_sds_remote_device_default_frame_handler
 	},
 	[SCI_BASE_REMOTE_DEVICE_STATE_READY] = {
-		.event_handler		= scic_sds_remote_device_general_event_handler,
 		.frame_handler		= scic_sds_remote_device_general_frame_handler,
 	},
 	[SCIC_SDS_STP_REMOTE_DEVICE_READY_SUBSTATE_IDLE] = {
-		.event_handler			= scic_sds_stp_remote_device_ready_idle_substate_event_handler,
 		.frame_handler			= scic_sds_remote_device_default_frame_handler
 	},
 	[SCIC_SDS_STP_REMOTE_DEVICE_READY_SUBSTATE_CMD] = {
-		.event_handler			= scic_sds_remote_device_general_event_handler,
 		.frame_handler			= scic_sds_stp_remote_device_ready_cmd_substate_frame_handler
 	},
 	[SCIC_SDS_STP_REMOTE_DEVICE_READY_SUBSTATE_NCQ] = {
-		.event_handler			= scic_sds_remote_device_general_event_handler,
 		.frame_handler			= scic_sds_stp_remote_device_ready_ncq_substate_frame_handler
 	},
 	[SCIC_SDS_STP_REMOTE_DEVICE_READY_SUBSTATE_NCQ_ERROR] = {
-		.event_handler			= scic_sds_remote_device_general_event_handler,
 		.frame_handler			= scic_sds_remote_device_general_frame_handler
 	},
 	[SCIC_SDS_STP_REMOTE_DEVICE_READY_SUBSTATE_AWAIT_RESET] = {
-		.event_handler			= scic_sds_remote_device_general_event_handler,
 		.frame_handler			= scic_sds_remote_device_general_frame_handler
 	},
 	[SCIC_SDS_SMP_REMOTE_DEVICE_READY_SUBSTATE_IDLE] = {
-		.event_handler		= scic_sds_remote_device_general_event_handler,
 		.frame_handler		= scic_sds_remote_device_default_frame_handler
 	},
 	[SCIC_SDS_SMP_REMOTE_DEVICE_READY_SUBSTATE_CMD] = {
-		.event_handler		= scic_sds_remote_device_general_event_handler,
 		.frame_handler		= scic_sds_smp_remote_device_ready_cmd_substate_frame_handler
 	},
 	[SCI_BASE_REMOTE_DEVICE_STATE_STOPPING] = {
-		.event_handler		= scic_sds_remote_device_general_event_handler,
 		.frame_handler		= scic_sds_remote_device_general_frame_handler
 	},
 	[SCI_BASE_REMOTE_DEVICE_STATE_FAILED] = {
-		.event_handler		= scic_sds_remote_device_default_event_handler,
 		.frame_handler		= scic_sds_remote_device_general_frame_handler
 	},
 	[SCI_BASE_REMOTE_DEVICE_STATE_RESETTING] = {
-		.event_handler		= scic_sds_remote_device_default_event_handler,
 		.frame_handler		= scic_sds_remote_device_general_frame_handler
 	},
 	[SCI_BASE_REMOTE_DEVICE_STATE_FINAL] = {
-		.event_handler		= scic_sds_remote_device_default_event_handler,
 		.frame_handler		= scic_sds_remote_device_default_frame_handler
 	}
 };

commit 978edfef46415badd28974a3e85119e2b764d236
Author: Dan Williams <dan.j.williams@intel.com>
Date:   Sun May 1 16:20:54 2011 -0700

    isci: kill remote_device resume_handler
    
    This is unused infrastructure.
    
    Reported-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/drivers/scsi/isci/remote_device.c b/drivers/scsi/isci/remote_device.c
index 97ea8748335d..26c5253530ea 100644
--- a/drivers/scsi/isci/remote_device.c
+++ b/drivers/scsi/isci/remote_device.c
@@ -667,22 +667,6 @@ static void remote_device_resume_done(void *_dev)
 	}
 }
 
-static enum sci_status
-default_device_handler(struct scic_sds_remote_device *sci_dev,
-		       const char *func)
-{
-	dev_warn(scirdev_to_dev(sci_dev),
-		 "%s: in wrong state: %d\n", func,
-		 sci_base_state_machine_get_state(&sci_dev->state_machine));
-	return SCI_FAILURE_INVALID_STATE;
-}
-
-static enum sci_status scic_sds_remote_device_default_resume_handler(
-	struct scic_sds_remote_device *sci_dev)
-{
-	return default_device_handler(sci_dev, __func__);
-}
-
 /**
  *
  * @device: The struct scic_sds_remote_device which is then cast into a
@@ -961,77 +945,62 @@ static enum sci_status scic_sds_smp_remote_device_ready_cmd_substate_frame_handl
 
 static const struct scic_sds_remote_device_state_handler scic_sds_remote_device_state_handler_table[] = {
 	[SCI_BASE_REMOTE_DEVICE_STATE_INITIAL] = {
-		.resume_handler		= scic_sds_remote_device_default_resume_handler,
 		.event_handler		= scic_sds_remote_device_default_event_handler,
 		.frame_handler		= scic_sds_remote_device_default_frame_handler
 	},
 	[SCI_BASE_REMOTE_DEVICE_STATE_STOPPED] = {
-		.resume_handler		= scic_sds_remote_device_default_resume_handler,
 		.event_handler		= scic_sds_remote_device_default_event_handler,
 		.frame_handler		= scic_sds_remote_device_default_frame_handler
 	},
 	[SCI_BASE_REMOTE_DEVICE_STATE_STARTING] = {
-		.resume_handler		= scic_sds_remote_device_default_resume_handler,
 		.event_handler		= scic_sds_remote_device_general_event_handler,
 		.frame_handler		= scic_sds_remote_device_default_frame_handler
 	},
 	[SCI_BASE_REMOTE_DEVICE_STATE_READY] = {
-		.resume_handler		= scic_sds_remote_device_default_resume_handler,
 		.event_handler		= scic_sds_remote_device_general_event_handler,
 		.frame_handler		= scic_sds_remote_device_general_frame_handler,
 	},
 	[SCIC_SDS_STP_REMOTE_DEVICE_READY_SUBSTATE_IDLE] = {
-		.resume_handler			= scic_sds_remote_device_default_resume_handler,
 		.event_handler			= scic_sds_stp_remote_device_ready_idle_substate_event_handler,
 		.frame_handler			= scic_sds_remote_device_default_frame_handler
 	},
 	[SCIC_SDS_STP_REMOTE_DEVICE_READY_SUBSTATE_CMD] = {
-		.resume_handler			= scic_sds_remote_device_default_resume_handler,
 		.event_handler			= scic_sds_remote_device_general_event_handler,
 		.frame_handler			= scic_sds_stp_remote_device_ready_cmd_substate_frame_handler
 	},
 	[SCIC_SDS_STP_REMOTE_DEVICE_READY_SUBSTATE_NCQ] = {
-		.resume_handler			= scic_sds_remote_device_default_resume_handler,
 		.event_handler			= scic_sds_remote_device_general_event_handler,
 		.frame_handler			= scic_sds_stp_remote_device_ready_ncq_substate_frame_handler
 	},
 	[SCIC_SDS_STP_REMOTE_DEVICE_READY_SUBSTATE_NCQ_ERROR] = {
-		.resume_handler			= scic_sds_remote_device_default_resume_handler,
 		.event_handler			= scic_sds_remote_device_general_event_handler,
 		.frame_handler			= scic_sds_remote_device_general_frame_handler
 	},
 	[SCIC_SDS_STP_REMOTE_DEVICE_READY_SUBSTATE_AWAIT_RESET] = {
-		.resume_handler			= scic_sds_remote_device_default_resume_handler,
 		.event_handler			= scic_sds_remote_device_general_event_handler,
 		.frame_handler			= scic_sds_remote_device_general_frame_handler
 	},
 	[SCIC_SDS_SMP_REMOTE_DEVICE_READY_SUBSTATE_IDLE] = {
-		.resume_handler		= scic_sds_remote_device_default_resume_handler,
 		.event_handler		= scic_sds_remote_device_general_event_handler,
 		.frame_handler		= scic_sds_remote_device_default_frame_handler
 	},
 	[SCIC_SDS_SMP_REMOTE_DEVICE_READY_SUBSTATE_CMD] = {
-		.resume_handler		= scic_sds_remote_device_default_resume_handler,
 		.event_handler		= scic_sds_remote_device_general_event_handler,
 		.frame_handler		= scic_sds_smp_remote_device_ready_cmd_substate_frame_handler
 	},
 	[SCI_BASE_REMOTE_DEVICE_STATE_STOPPING] = {
-		.resume_handler		= scic_sds_remote_device_default_resume_handler,
 		.event_handler		= scic_sds_remote_device_general_event_handler,
 		.frame_handler		= scic_sds_remote_device_general_frame_handler
 	},
 	[SCI_BASE_REMOTE_DEVICE_STATE_FAILED] = {
-		.resume_handler		= scic_sds_remote_device_default_resume_handler,
 		.event_handler		= scic_sds_remote_device_default_event_handler,
 		.frame_handler		= scic_sds_remote_device_general_frame_handler
 	},
 	[SCI_BASE_REMOTE_DEVICE_STATE_RESETTING] = {
-		.resume_handler		= scic_sds_remote_device_default_resume_handler,
 		.event_handler		= scic_sds_remote_device_default_event_handler,
 		.frame_handler		= scic_sds_remote_device_general_frame_handler
 	},
 	[SCI_BASE_REMOTE_DEVICE_STATE_FINAL] = {
-		.resume_handler		= scic_sds_remote_device_default_resume_handler,
 		.event_handler		= scic_sds_remote_device_default_event_handler,
 		.frame_handler		= scic_sds_remote_device_default_frame_handler
 	}

commit 323f0ec0fc72670f71210ba89611f6a1ec234394
Author: Dan Williams <dan.j.williams@intel.com>
Date:   Sun May 1 16:15:47 2011 -0700

    isci: unify remote_device suspend_handlers
    
    Implement all states in scic_sds_remote_device_suspend() and delete
    the state handler.
    
    Reported-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/drivers/scsi/isci/remote_device.c b/drivers/scsi/isci/remote_device.c
index 3344f38355cd..97ea8748335d 100644
--- a/drivers/scsi/isci/remote_device.c
+++ b/drivers/scsi/isci/remote_device.c
@@ -261,17 +261,20 @@ enum sci_status scic_remote_device_reset_complete(struct scic_sds_remote_device
 	return SCI_SUCCESS;
 }
 
-/**
- *
- * @sci_dev: The remote device for which the suspend is being requested.
- *
- * This method invokes the remote device suspend state handler. enum sci_status
- */
-enum sci_status scic_sds_remote_device_suspend(
-	struct scic_sds_remote_device *sci_dev,
-	u32 suspend_type)
+enum sci_status scic_sds_remote_device_suspend(struct scic_sds_remote_device *sci_dev,
+					       u32 suspend_type)
 {
-	return sci_dev->state_handlers->suspend_handler(sci_dev, suspend_type);
+	struct sci_base_state_machine *sm = &sci_dev->state_machine;
+	enum scic_sds_remote_device_states state = sm->current_state_id;
+
+	if (state != SCIC_SDS_STP_REMOTE_DEVICE_READY_SUBSTATE_CMD) {
+		dev_warn(scirdev_to_dev(sci_dev), "%s: in wrong state: %d\n",
+			 __func__, state);
+		return SCI_FAILURE_INVALID_STATE;
+	}
+
+	return scic_sds_remote_node_context_suspend(&sci_dev->rnc,
+						    suspend_type, NULL, NULL);
 }
 
 /**
@@ -674,12 +677,6 @@ default_device_handler(struct scic_sds_remote_device *sci_dev,
 	return SCI_FAILURE_INVALID_STATE;
 }
 
-static enum sci_status scic_sds_remote_device_default_suspend_handler(
-	struct scic_sds_remote_device *sci_dev, u32 suspend_type)
-{
-	return default_device_handler(sci_dev, __func__);
-}
-
 static enum sci_status scic_sds_remote_device_default_resume_handler(
 	struct scic_sds_remote_device *sci_dev)
 {
@@ -919,18 +916,6 @@ static enum sci_status scic_sds_stp_remote_device_ready_ncq_substate_frame_handl
 	return status;
 }
 
-static enum sci_status scic_sds_stp_remote_device_ready_cmd_substate_suspend_handler(
-	struct scic_sds_remote_device *sci_dev,
-	u32 suspend_type)
-{
-	enum sci_status status;
-
-	status = scic_sds_remote_node_context_suspend(&sci_dev->rnc,
-						      suspend_type, NULL, NULL);
-
-	return status;
-}
-
 static enum sci_status scic_sds_stp_remote_device_ready_cmd_substate_frame_handler(
 	struct scic_sds_remote_device *sci_dev,
 	u32 frame_index)
@@ -976,91 +961,76 @@ static enum sci_status scic_sds_smp_remote_device_ready_cmd_substate_frame_handl
 
 static const struct scic_sds_remote_device_state_handler scic_sds_remote_device_state_handler_table[] = {
 	[SCI_BASE_REMOTE_DEVICE_STATE_INITIAL] = {
-		.suspend_handler	= scic_sds_remote_device_default_suspend_handler,
 		.resume_handler		= scic_sds_remote_device_default_resume_handler,
 		.event_handler		= scic_sds_remote_device_default_event_handler,
 		.frame_handler		= scic_sds_remote_device_default_frame_handler
 	},
 	[SCI_BASE_REMOTE_DEVICE_STATE_STOPPED] = {
-		.suspend_handler	= scic_sds_remote_device_default_suspend_handler,
 		.resume_handler		= scic_sds_remote_device_default_resume_handler,
 		.event_handler		= scic_sds_remote_device_default_event_handler,
 		.frame_handler		= scic_sds_remote_device_default_frame_handler
 	},
 	[SCI_BASE_REMOTE_DEVICE_STATE_STARTING] = {
-		.suspend_handler	= scic_sds_remote_device_default_suspend_handler,
 		.resume_handler		= scic_sds_remote_device_default_resume_handler,
 		.event_handler		= scic_sds_remote_device_general_event_handler,
 		.frame_handler		= scic_sds_remote_device_default_frame_handler
 	},
 	[SCI_BASE_REMOTE_DEVICE_STATE_READY] = {
-		.suspend_handler	= scic_sds_remote_device_default_suspend_handler,
 		.resume_handler		= scic_sds_remote_device_default_resume_handler,
 		.event_handler		= scic_sds_remote_device_general_event_handler,
 		.frame_handler		= scic_sds_remote_device_general_frame_handler,
 	},
 	[SCIC_SDS_STP_REMOTE_DEVICE_READY_SUBSTATE_IDLE] = {
-		.suspend_handler		= scic_sds_remote_device_default_suspend_handler,
 		.resume_handler			= scic_sds_remote_device_default_resume_handler,
 		.event_handler			= scic_sds_stp_remote_device_ready_idle_substate_event_handler,
 		.frame_handler			= scic_sds_remote_device_default_frame_handler
 	},
 	[SCIC_SDS_STP_REMOTE_DEVICE_READY_SUBSTATE_CMD] = {
-		.suspend_handler		= scic_sds_stp_remote_device_ready_cmd_substate_suspend_handler,
 		.resume_handler			= scic_sds_remote_device_default_resume_handler,
 		.event_handler			= scic_sds_remote_device_general_event_handler,
 		.frame_handler			= scic_sds_stp_remote_device_ready_cmd_substate_frame_handler
 	},
 	[SCIC_SDS_STP_REMOTE_DEVICE_READY_SUBSTATE_NCQ] = {
-		.suspend_handler		= scic_sds_remote_device_default_suspend_handler,
 		.resume_handler			= scic_sds_remote_device_default_resume_handler,
 		.event_handler			= scic_sds_remote_device_general_event_handler,
 		.frame_handler			= scic_sds_stp_remote_device_ready_ncq_substate_frame_handler
 	},
 	[SCIC_SDS_STP_REMOTE_DEVICE_READY_SUBSTATE_NCQ_ERROR] = {
-		.suspend_handler		= scic_sds_remote_device_default_suspend_handler,
 		.resume_handler			= scic_sds_remote_device_default_resume_handler,
 		.event_handler			= scic_sds_remote_device_general_event_handler,
 		.frame_handler			= scic_sds_remote_device_general_frame_handler
 	},
 	[SCIC_SDS_STP_REMOTE_DEVICE_READY_SUBSTATE_AWAIT_RESET] = {
-		.suspend_handler		= scic_sds_remote_device_default_suspend_handler,
 		.resume_handler			= scic_sds_remote_device_default_resume_handler,
 		.event_handler			= scic_sds_remote_device_general_event_handler,
 		.frame_handler			= scic_sds_remote_device_general_frame_handler
 	},
 	[SCIC_SDS_SMP_REMOTE_DEVICE_READY_SUBSTATE_IDLE] = {
-		.suspend_handler	= scic_sds_remote_device_default_suspend_handler,
 		.resume_handler		= scic_sds_remote_device_default_resume_handler,
 		.event_handler		= scic_sds_remote_device_general_event_handler,
 		.frame_handler		= scic_sds_remote_device_default_frame_handler
 	},
 	[SCIC_SDS_SMP_REMOTE_DEVICE_READY_SUBSTATE_CMD] = {
-		.suspend_handler	= scic_sds_remote_device_default_suspend_handler,
 		.resume_handler		= scic_sds_remote_device_default_resume_handler,
 		.event_handler		= scic_sds_remote_device_general_event_handler,
 		.frame_handler		= scic_sds_smp_remote_device_ready_cmd_substate_frame_handler
 	},
 	[SCI_BASE_REMOTE_DEVICE_STATE_STOPPING] = {
-		.suspend_handler	= scic_sds_remote_device_default_suspend_handler,
 		.resume_handler		= scic_sds_remote_device_default_resume_handler,
 		.event_handler		= scic_sds_remote_device_general_event_handler,
 		.frame_handler		= scic_sds_remote_device_general_frame_handler
 	},
 	[SCI_BASE_REMOTE_DEVICE_STATE_FAILED] = {
-		.suspend_handler	= scic_sds_remote_device_default_suspend_handler,
 		.resume_handler		= scic_sds_remote_device_default_resume_handler,
 		.event_handler		= scic_sds_remote_device_default_event_handler,
 		.frame_handler		= scic_sds_remote_device_general_frame_handler
 	},
 	[SCI_BASE_REMOTE_DEVICE_STATE_RESETTING] = {
-		.suspend_handler	= scic_sds_remote_device_default_suspend_handler,
 		.resume_handler		= scic_sds_remote_device_default_resume_handler,
 		.event_handler		= scic_sds_remote_device_default_event_handler,
 		.frame_handler		= scic_sds_remote_device_general_frame_handler
 	},
 	[SCI_BASE_REMOTE_DEVICE_STATE_FINAL] = {
-		.suspend_handler	= scic_sds_remote_device_default_suspend_handler,
 		.resume_handler		= scic_sds_remote_device_default_resume_handler,
 		.event_handler		= scic_sds_remote_device_default_event_handler,
 		.frame_handler		= scic_sds_remote_device_default_frame_handler

commit e4a867bb4a7617dc1067e1c41627782f3c6c284c
Author: Dan Williams <dan.j.williams@intel.com>
Date:   Sun May 1 16:01:05 2011 -0700

    isci: kill remote_device complete_task_handler
    
    This is unused infrastructure.
    
    Reported-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/drivers/scsi/isci/remote_device.c b/drivers/scsi/isci/remote_device.c
index 3e7e95200a1e..3344f38355cd 100644
--- a/drivers/scsi/isci/remote_device.c
+++ b/drivers/scsi/isci/remote_device.c
@@ -795,13 +795,6 @@ static enum sci_status scic_sds_remote_device_default_frame_handler(
 	return SCI_FAILURE_INVALID_STATE;
 }
 
-static enum sci_status scic_sds_remote_device_default_complete_request_handler(
-	struct scic_sds_remote_device *sci_dev,
-	struct scic_sds_request *request)
-{
-	return default_device_handler(sci_dev, __func__);
-}
-
 /**
  *
  * @device: The struct scic_sds_remote_device which is then cast into a
@@ -867,136 +860,6 @@ static enum sci_status scic_sds_remote_device_general_event_handler(
 							  true);
 }
 
-/*
- * This method will complete the request for the remote device object.  The
- * method will call the completion handler for the request object and if
- * successful it will complete the request on the port object then decrement
- * its own started_request_count. enum sci_status
- */
-static enum sci_status scic_sds_remote_device_ready_state_complete_request_handler(
-	struct scic_sds_remote_device *sci_dev,
-	struct scic_sds_request *request)
-{
-	enum sci_status result;
-
-	result = scic_sds_request_complete(request);
-
-	if (result != SCI_SUCCESS)
-		return result;
-
-	/* See if the port is in a state
-	 * where we can start the IO request */
-	result = scic_sds_port_complete_io(
-			scic_sds_remote_device_get_port(sci_dev),
-			sci_dev, request);
-
-	if (result == SCI_SUCCESS)
-		scic_sds_remote_device_decrement_request_count(sci_dev);
-
-	return result;
-}
-
-/**
- *
- * @device: The device object for which the request is completing.
- * @request: The task request that is being completed.
- *
- * This method completes requests for this struct scic_sds_remote_device while it is
- * in the SCI_BASE_REMOTE_DEVICE_STATE_STOPPING state. This method calls the
- * complete method for the request object and if that is successful the port
- * object is called to complete the task request. Then the device object itself
- * completes the task request. If struct scic_sds_remote_device started_request_count
- * goes to 0 and the invalidate RNC request has completed the device object can
- * transition to the SCI_BASE_REMOTE_DEVICE_STATE_STOPPED. enum sci_status
- */
-static enum sci_status scic_sds_remote_device_stopping_state_complete_request_handler(
-	struct scic_sds_remote_device *sci_dev,
-	struct scic_sds_request *request)
-{
-	enum sci_status status = SCI_SUCCESS;
-
-	status = scic_sds_request_complete(request);
-
-	if (status != SCI_SUCCESS)
-		return status;
-
-	status = scic_sds_port_complete_io(scic_sds_remote_device_get_port(sci_dev),
-					   sci_dev, request);
-	if (status != SCI_SUCCESS)
-		return status;
-
-	scic_sds_remote_device_decrement_request_count(sci_dev);
-
-	if (scic_sds_remote_device_get_request_count(sci_dev) == 0)
-		scic_sds_remote_node_context_destruct(&sci_dev->rnc,
-						      rnc_destruct_done, sci_dev);
-	return SCI_SUCCESS;
-}
-
-/* complete requests for this device while it is in the
- * SCI_BASE_REMOTE_DEVICE_STATE_RESETTING state. This method calls the complete
- * method for the request object and if that is successful the port object is
- * called to complete the task request. Then the device object itself completes
- * the task request. enum sci_status
- */
-static enum sci_status scic_sds_remote_device_resetting_state_complete_request_handler(
-	struct scic_sds_remote_device *sci_dev,
-	struct scic_sds_request *request)
-{
-	enum sci_status status = SCI_SUCCESS;
-
-	status = scic_sds_request_complete(request);
-
-	if (status == SCI_SUCCESS) {
-		status = scic_sds_port_complete_io(
-				scic_sds_remote_device_get_port(sci_dev),
-				sci_dev, request);
-
-		if (status == SCI_SUCCESS) {
-			scic_sds_remote_device_decrement_request_count(sci_dev);
-		}
-	}
-
-	return status;
-}
-
-static enum sci_status scic_sds_stp_remote_device_complete_request(struct scic_sds_remote_device *sci_dev,
-								   struct scic_sds_request *sci_req)
-{
-	enum sci_status status;
-
-	status = scic_sds_io_request_complete(sci_req);
-	if (status != SCI_SUCCESS)
-		goto out;
-
-	status = scic_sds_port_complete_io(sci_dev->owning_port, sci_dev, sci_req);
-	if (status != SCI_SUCCESS)
-		goto out;
-
-	scic_sds_remote_device_decrement_request_count(sci_dev);
-	if (sci_req->sci_status == SCI_FAILURE_REMOTE_DEVICE_RESET_REQUIRED) {
-		/* This request causes hardware error, device needs to be Lun Reset.
-		 * So here we force the state machine to IDLE state so the rest IOs
-		 * can reach RNC state handler, these IOs will be completed by RNC with
-		 * status of "DEVICE_RESET_REQUIRED", instead of "INVALID STATE".
-		 */
-		sci_base_state_machine_change_state(&sci_dev->state_machine,
-						    SCIC_SDS_STP_REMOTE_DEVICE_READY_SUBSTATE_AWAIT_RESET);
-	} else if (scic_sds_remote_device_get_request_count(sci_dev) == 0)
-		sci_base_state_machine_change_state(&sci_dev->state_machine,
-						    SCIC_SDS_STP_REMOTE_DEVICE_READY_SUBSTATE_IDLE);
-
-
- out:
-	if (status != SCI_SUCCESS)
-		dev_err(scirdev_to_dev(sci_dev),
-			"%s: Port:0x%p Device:0x%p Request:0x%p Status:0x%x "
-			"could not complete\n", __func__, sci_dev->owning_port,
-			sci_dev, sci_req, status);
-
-	return status;
-}
-
 static enum sci_status scic_sds_stp_remote_device_ready_idle_substate_event_handler(
 	struct scic_sds_remote_device *sci_dev,
 	u32 event_code)
@@ -1113,105 +976,90 @@ static enum sci_status scic_sds_smp_remote_device_ready_cmd_substate_frame_handl
 
 static const struct scic_sds_remote_device_state_handler scic_sds_remote_device_state_handler_table[] = {
 	[SCI_BASE_REMOTE_DEVICE_STATE_INITIAL] = {
-		.complete_task_handler	= scic_sds_remote_device_default_complete_request_handler,
 		.suspend_handler	= scic_sds_remote_device_default_suspend_handler,
 		.resume_handler		= scic_sds_remote_device_default_resume_handler,
 		.event_handler		= scic_sds_remote_device_default_event_handler,
 		.frame_handler		= scic_sds_remote_device_default_frame_handler
 	},
 	[SCI_BASE_REMOTE_DEVICE_STATE_STOPPED] = {
-		.complete_task_handler	= scic_sds_remote_device_default_complete_request_handler,
 		.suspend_handler	= scic_sds_remote_device_default_suspend_handler,
 		.resume_handler		= scic_sds_remote_device_default_resume_handler,
 		.event_handler		= scic_sds_remote_device_default_event_handler,
 		.frame_handler		= scic_sds_remote_device_default_frame_handler
 	},
 	[SCI_BASE_REMOTE_DEVICE_STATE_STARTING] = {
-		.complete_task_handler	= scic_sds_remote_device_default_complete_request_handler,
 		.suspend_handler	= scic_sds_remote_device_default_suspend_handler,
 		.resume_handler		= scic_sds_remote_device_default_resume_handler,
 		.event_handler		= scic_sds_remote_device_general_event_handler,
 		.frame_handler		= scic_sds_remote_device_default_frame_handler
 	},
 	[SCI_BASE_REMOTE_DEVICE_STATE_READY] = {
-		.complete_task_handler	= scic_sds_remote_device_ready_state_complete_request_handler,
 		.suspend_handler	= scic_sds_remote_device_default_suspend_handler,
 		.resume_handler		= scic_sds_remote_device_default_resume_handler,
 		.event_handler		= scic_sds_remote_device_general_event_handler,
 		.frame_handler		= scic_sds_remote_device_general_frame_handler,
 	},
 	[SCIC_SDS_STP_REMOTE_DEVICE_READY_SUBSTATE_IDLE] = {
-		.complete_task_handler	= scic_sds_remote_device_default_complete_request_handler,
 		.suspend_handler		= scic_sds_remote_device_default_suspend_handler,
 		.resume_handler			= scic_sds_remote_device_default_resume_handler,
 		.event_handler			= scic_sds_stp_remote_device_ready_idle_substate_event_handler,
 		.frame_handler			= scic_sds_remote_device_default_frame_handler
 	},
 	[SCIC_SDS_STP_REMOTE_DEVICE_READY_SUBSTATE_CMD] = {
-		.complete_task_handler	= scic_sds_stp_remote_device_complete_request,
 		.suspend_handler		= scic_sds_stp_remote_device_ready_cmd_substate_suspend_handler,
 		.resume_handler			= scic_sds_remote_device_default_resume_handler,
 		.event_handler			= scic_sds_remote_device_general_event_handler,
 		.frame_handler			= scic_sds_stp_remote_device_ready_cmd_substate_frame_handler
 	},
 	[SCIC_SDS_STP_REMOTE_DEVICE_READY_SUBSTATE_NCQ] = {
-		.complete_task_handler	= scic_sds_stp_remote_device_complete_request,
 		.suspend_handler		= scic_sds_remote_device_default_suspend_handler,
 		.resume_handler			= scic_sds_remote_device_default_resume_handler,
 		.event_handler			= scic_sds_remote_device_general_event_handler,
 		.frame_handler			= scic_sds_stp_remote_device_ready_ncq_substate_frame_handler
 	},
 	[SCIC_SDS_STP_REMOTE_DEVICE_READY_SUBSTATE_NCQ_ERROR] = {
-		.complete_task_handler	= scic_sds_stp_remote_device_complete_request,
 		.suspend_handler		= scic_sds_remote_device_default_suspend_handler,
 		.resume_handler			= scic_sds_remote_device_default_resume_handler,
 		.event_handler			= scic_sds_remote_device_general_event_handler,
 		.frame_handler			= scic_sds_remote_device_general_frame_handler
 	},
 	[SCIC_SDS_STP_REMOTE_DEVICE_READY_SUBSTATE_AWAIT_RESET] = {
-		.complete_task_handler	= scic_sds_stp_remote_device_complete_request,
 		.suspend_handler		= scic_sds_remote_device_default_suspend_handler,
 		.resume_handler			= scic_sds_remote_device_default_resume_handler,
 		.event_handler			= scic_sds_remote_device_general_event_handler,
 		.frame_handler			= scic_sds_remote_device_general_frame_handler
 	},
 	[SCIC_SDS_SMP_REMOTE_DEVICE_READY_SUBSTATE_IDLE] = {
-		.complete_task_handler	= scic_sds_remote_device_default_complete_request_handler,
 		.suspend_handler	= scic_sds_remote_device_default_suspend_handler,
 		.resume_handler		= scic_sds_remote_device_default_resume_handler,
 		.event_handler		= scic_sds_remote_device_general_event_handler,
 		.frame_handler		= scic_sds_remote_device_default_frame_handler
 	},
 	[SCIC_SDS_SMP_REMOTE_DEVICE_READY_SUBSTATE_CMD] = {
-		.complete_task_handler	= scic_sds_remote_device_default_complete_request_handler,
 		.suspend_handler	= scic_sds_remote_device_default_suspend_handler,
 		.resume_handler		= scic_sds_remote_device_default_resume_handler,
 		.event_handler		= scic_sds_remote_device_general_event_handler,
 		.frame_handler		= scic_sds_smp_remote_device_ready_cmd_substate_frame_handler
 	},
 	[SCI_BASE_REMOTE_DEVICE_STATE_STOPPING] = {
-		.complete_task_handler	= scic_sds_remote_device_stopping_state_complete_request_handler,
 		.suspend_handler	= scic_sds_remote_device_default_suspend_handler,
 		.resume_handler		= scic_sds_remote_device_default_resume_handler,
 		.event_handler		= scic_sds_remote_device_general_event_handler,
 		.frame_handler		= scic_sds_remote_device_general_frame_handler
 	},
 	[SCI_BASE_REMOTE_DEVICE_STATE_FAILED] = {
-		.complete_task_handler	= scic_sds_remote_device_default_complete_request_handler,
 		.suspend_handler	= scic_sds_remote_device_default_suspend_handler,
 		.resume_handler		= scic_sds_remote_device_default_resume_handler,
 		.event_handler		= scic_sds_remote_device_default_event_handler,
 		.frame_handler		= scic_sds_remote_device_general_frame_handler
 	},
 	[SCI_BASE_REMOTE_DEVICE_STATE_RESETTING] = {
-		.complete_task_handler	= scic_sds_remote_device_resetting_state_complete_request_handler,
 		.suspend_handler	= scic_sds_remote_device_default_suspend_handler,
 		.resume_handler		= scic_sds_remote_device_default_resume_handler,
 		.event_handler		= scic_sds_remote_device_default_event_handler,
 		.frame_handler		= scic_sds_remote_device_general_frame_handler
 	},
 	[SCI_BASE_REMOTE_DEVICE_STATE_FINAL] = {
-		.complete_task_handler	= scic_sds_remote_device_default_complete_request_handler,
 		.suspend_handler	= scic_sds_remote_device_default_suspend_handler,
 		.resume_handler		= scic_sds_remote_device_default_resume_handler,
 		.event_handler		= scic_sds_remote_device_default_event_handler,

commit 84b9b029bc4121c43294e27aeaa0350a6d07450c
Author: Dan Williams <dan.j.williams@intel.com>
Date:   Sun May 1 15:53:25 2011 -0700

    isci: unify remote_device start_task_handlers
    
    Implement all states in scic_sds_remote_device_start_task() and delete
    the state handler.
    
    Reported-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/drivers/scsi/isci/remote_device.c b/drivers/scsi/isci/remote_device.c
index 3580c0a5a719..3e7e95200a1e 100644
--- a/drivers/scsi/isci/remote_device.c
+++ b/drivers/scsi/isci/remote_device.c
@@ -521,22 +521,97 @@ enum sci_status scic_sds_remote_device_complete_io(struct scic_sds_controller *s
 	return status;
 }
 
-/**
- *
- * @controller: The controller that is starting the task request.
- * @sci_dev: The remote device for which the start task handling is being
- *    requested.
- * @io_request: The task request that is being started.
- *
- * This method invokes the remote device start task handler. enum sci_status
- */
-enum sci_status scic_sds_remote_device_start_task(
-	struct scic_sds_controller *controller,
-	struct scic_sds_remote_device *sci_dev,
-	struct scic_sds_request *io_request)
+static void scic_sds_remote_device_continue_request(void *dev)
+{
+	struct scic_sds_remote_device *sci_dev = dev;
+
+	/* we need to check if this request is still valid to continue. */
+	if (sci_dev->working_request)
+		scic_controller_continue_io(sci_dev->working_request);
+}
+
+enum sci_status scic_sds_remote_device_start_task(struct scic_sds_controller *scic,
+						  struct scic_sds_remote_device *sci_dev,
+						  struct scic_sds_request *sci_req)
 {
-	return sci_dev->state_handlers->start_task_handler(
-		       sci_dev, io_request);
+	struct sci_base_state_machine *sm = &sci_dev->state_machine;
+	enum scic_sds_remote_device_states state = sm->current_state_id;
+	struct scic_sds_port *sci_port = sci_dev->owning_port;
+	enum sci_status status;
+
+	switch (state) {
+	case SCI_BASE_REMOTE_DEVICE_STATE_INITIAL:
+	case SCI_BASE_REMOTE_DEVICE_STATE_STOPPED:
+	case SCI_BASE_REMOTE_DEVICE_STATE_STARTING:
+	case SCIC_SDS_SMP_REMOTE_DEVICE_READY_SUBSTATE_IDLE:
+	case SCIC_SDS_SMP_REMOTE_DEVICE_READY_SUBSTATE_CMD:
+	case SCI_BASE_REMOTE_DEVICE_STATE_STOPPING:
+	case SCI_BASE_REMOTE_DEVICE_STATE_FAILED:
+	case SCI_BASE_REMOTE_DEVICE_STATE_RESETTING:
+	case SCI_BASE_REMOTE_DEVICE_STATE_FINAL:
+	default:
+		dev_warn(scirdev_to_dev(sci_dev), "%s: in wrong state: %d\n",
+			 __func__, state);
+		return SCI_FAILURE_INVALID_STATE;
+	case SCIC_SDS_STP_REMOTE_DEVICE_READY_SUBSTATE_IDLE:
+	case SCIC_SDS_STP_REMOTE_DEVICE_READY_SUBSTATE_CMD:
+	case SCIC_SDS_STP_REMOTE_DEVICE_READY_SUBSTATE_NCQ:
+	case SCIC_SDS_STP_REMOTE_DEVICE_READY_SUBSTATE_NCQ_ERROR:
+	case SCIC_SDS_STP_REMOTE_DEVICE_READY_SUBSTATE_AWAIT_RESET:
+		status = scic_sds_port_start_io(sci_port, sci_dev, sci_req);
+		if (status != SCI_SUCCESS)
+			return status;
+
+		status = scic_sds_remote_node_context_start_task(&sci_dev->rnc, sci_req);
+		if (status != SCI_SUCCESS)
+			goto out;
+
+		status = sci_req->state_handlers->start_handler(sci_req);
+		if (status != SCI_SUCCESS)
+			goto out;
+
+		/* Note: If the remote device state is not IDLE this will
+		 * replace the request that probably resulted in the task
+		 * management request.
+		 */
+		sci_dev->working_request = sci_req;
+		sci_base_state_machine_change_state(sm, SCIC_SDS_STP_REMOTE_DEVICE_READY_SUBSTATE_CMD);
+
+		/* The remote node context must cleanup the TCi to NCQ mapping
+		 * table.  The only way to do this correctly is to either write
+		 * to the TLCR register or to invalidate and repost the RNC. In
+		 * either case the remote node context state machine will take
+		 * the correct action when the remote node context is suspended
+		 * and later resumed.
+		 */
+		scic_sds_remote_node_context_suspend(&sci_dev->rnc,
+				SCI_SOFTWARE_SUSPENSION, NULL, NULL);
+		scic_sds_remote_node_context_resume(&sci_dev->rnc,
+				scic_sds_remote_device_continue_request,
+						    sci_dev);
+
+	out:
+		scic_sds_remote_device_start_request(sci_dev, sci_req, status);
+		/* We need to let the controller start request handler know that
+		 * it can't post TC yet. We will provide a callback function to
+		 * post TC when RNC gets resumed.
+		 */
+		return SCI_FAILURE_RESET_DEVICE_PARTIAL_SUCCESS;
+	case SCI_BASE_REMOTE_DEVICE_STATE_READY:
+		status = scic_sds_port_start_io(sci_port, sci_dev, sci_req);
+		if (status != SCI_SUCCESS)
+			return status;
+
+		status = scic_sds_remote_node_context_start_task(&sci_dev->rnc, sci_req);
+		if (status != SCI_SUCCESS)
+			break;
+
+		status = scic_sds_request_start(sci_req);
+		break;
+	}
+	scic_sds_remote_device_start_request(sci_dev, sci_req, status);
+
+	return status;
 }
 
 /**
@@ -589,23 +664,6 @@ static void remote_device_resume_done(void *_dev)
 	}
 }
 
-/**
- *
- * @request: This parameter specifies the request being continued.
- *
- * This method will continue to post tc for a STP request. This method usually
- * serves as a callback when RNC gets resumed during a task management
- * sequence. none
- */
-static void scic_sds_remote_device_continue_request(void *dev)
-{
-	struct scic_sds_remote_device *sci_dev = dev;
-
-	/* we need to check if this request is still valid to continue. */
-	if (sci_dev->working_request)
-		scic_controller_continue_io(sci_dev->working_request);
-}
-
 static enum sci_status
 default_device_handler(struct scic_sds_remote_device *sci_dev,
 		       const char *func)
@@ -737,13 +795,6 @@ static enum sci_status scic_sds_remote_device_default_frame_handler(
 	return SCI_FAILURE_INVALID_STATE;
 }
 
-static enum sci_status scic_sds_remote_device_default_start_request_handler(
-	struct scic_sds_remote_device *sci_dev,
-	struct scic_sds_request *request)
-{
-	return default_device_handler(sci_dev, __func__);
-}
-
 static enum sci_status scic_sds_remote_device_default_complete_request_handler(
 	struct scic_sds_remote_device *sci_dev,
 	struct scic_sds_request *request)
@@ -816,36 +867,6 @@ static enum sci_status scic_sds_remote_device_general_event_handler(
 							  true);
 }
 
-/*
- * This method will attempt to start a task request for this device object. The
- * remote device object will issue the start request for the task and if
- * successful it will start the request for the port object then increment its
- * own requet count. enum sci_status SCI_SUCCESS if the task request is started for
- * this device object. SCI_FAILURE_INSUFFICIENT_RESOURCES if the io request
- * object could not get the resources to start.
- */
-static enum sci_status scic_sds_remote_device_ready_state_start_task_handler(
-	struct scic_sds_remote_device *sci_dev,
-	struct scic_sds_request *request)
-{
-	enum sci_status result;
-
-	/* See if the port is in a state where we can start the IO request */
-	result = scic_sds_port_start_io(
-		scic_sds_remote_device_get_port(sci_dev), sci_dev, request);
-
-	if (result == SCI_SUCCESS) {
-		result = scic_sds_remote_node_context_start_task(&sci_dev->rnc,
-								 request);
-		if (result == SCI_SUCCESS)
-			result = scic_sds_request_start(request);
-
-		scic_sds_remote_device_start_request(sci_dev, request, result);
-	}
-
-	return result;
-}
-
 /*
  * This method will complete the request for the remote device object.  The
  * method will call the completion handler for the request object and if
@@ -976,68 +997,6 @@ static enum sci_status scic_sds_stp_remote_device_complete_request(struct scic_s
 	return status;
 }
 
-/* scic_sds_stp_remote_device_ready_substate_start_request_handler - start stp
- * @device: The target device a task management request towards to.
- * @request: The task request.
- *
- * This is the READY NCQ substate handler to start task management request. In
- * this routine, we suspend and resume the RNC.  enum sci_status Always return
- * SCI_FAILURE_RESET_DEVICE_PARTIAL_SUCCESS status to let
- * controller_start_task_handler know that the controller can't post TC for
- * task request yet, instead, when RNC gets resumed, a controller_continue_task
- * callback will be called.
- */
-static enum sci_status scic_sds_stp_remote_device_ready_substate_start_request_handler(
-	struct scic_sds_remote_device *device,
-	struct scic_sds_request *request)
-{
-	enum sci_status status;
-
-	/* Will the port allow the io request to start? */
-	status = device->owning_port->state_handlers->start_io_handler(
-		device->owning_port, device, request);
-	if (status != SCI_SUCCESS)
-		return status;
-
-	status = scic_sds_remote_node_context_start_task(&device->rnc, request);
-	if (status != SCI_SUCCESS)
-		goto out;
-
-	status = request->state_handlers->start_handler(request);
-	if (status != SCI_SUCCESS)
-		goto out;
-
-	/*
-	 * Note: If the remote device state is not IDLE this will replace
-	 * the request that probably resulted in the task management request.
-	 */
-	device->working_request = request;
-	sci_base_state_machine_change_state(&device->state_machine,
-			SCIC_SDS_STP_REMOTE_DEVICE_READY_SUBSTATE_CMD);
-
-	/*
-	 * The remote node context must cleanup the TCi to NCQ mapping table.
-	 * The only way to do this correctly is to either write to the TLCR
-	 * register or to invalidate and repost the RNC. In either case the
-	 * remote node context state machine will take the correct action when
-	 * the remote node context is suspended and later resumed.
-	 */
-	scic_sds_remote_node_context_suspend(&device->rnc,
-			SCI_SOFTWARE_SUSPENSION, NULL, NULL);
-	scic_sds_remote_node_context_resume(&device->rnc,
-			scic_sds_remote_device_continue_request,
-			device);
-
-out:
-	scic_sds_remote_device_start_request(device, request, status);
-	/*
-	 * We need to let the controller start request handler know that it can't
-	 * post TC yet. We will provide a callback function to post TC when RNC gets
-	 * resumed.
-	 */
-	return SCI_FAILURE_RESET_DEVICE_PARTIAL_SUCCESS;
-}
-
 static enum sci_status scic_sds_stp_remote_device_ready_idle_substate_event_handler(
 	struct scic_sds_remote_device *sci_dev,
 	u32 event_code)
@@ -1154,7 +1113,6 @@ static enum sci_status scic_sds_smp_remote_device_ready_cmd_substate_frame_handl
 
 static const struct scic_sds_remote_device_state_handler scic_sds_remote_device_state_handler_table[] = {
 	[SCI_BASE_REMOTE_DEVICE_STATE_INITIAL] = {
-		.start_task_handler	= scic_sds_remote_device_default_start_request_handler,
 		.complete_task_handler	= scic_sds_remote_device_default_complete_request_handler,
 		.suspend_handler	= scic_sds_remote_device_default_suspend_handler,
 		.resume_handler		= scic_sds_remote_device_default_resume_handler,
@@ -1162,7 +1120,6 @@ static const struct scic_sds_remote_device_state_handler scic_sds_remote_device_
 		.frame_handler		= scic_sds_remote_device_default_frame_handler
 	},
 	[SCI_BASE_REMOTE_DEVICE_STATE_STOPPED] = {
-		.start_task_handler	= scic_sds_remote_device_default_start_request_handler,
 		.complete_task_handler	= scic_sds_remote_device_default_complete_request_handler,
 		.suspend_handler	= scic_sds_remote_device_default_suspend_handler,
 		.resume_handler		= scic_sds_remote_device_default_resume_handler,
@@ -1170,7 +1127,6 @@ static const struct scic_sds_remote_device_state_handler scic_sds_remote_device_
 		.frame_handler		= scic_sds_remote_device_default_frame_handler
 	},
 	[SCI_BASE_REMOTE_DEVICE_STATE_STARTING] = {
-		.start_task_handler	= scic_sds_remote_device_default_start_request_handler,
 		.complete_task_handler	= scic_sds_remote_device_default_complete_request_handler,
 		.suspend_handler	= scic_sds_remote_device_default_suspend_handler,
 		.resume_handler		= scic_sds_remote_device_default_resume_handler,
@@ -1178,7 +1134,6 @@ static const struct scic_sds_remote_device_state_handler scic_sds_remote_device_
 		.frame_handler		= scic_sds_remote_device_default_frame_handler
 	},
 	[SCI_BASE_REMOTE_DEVICE_STATE_READY] = {
-		.start_task_handler	= scic_sds_remote_device_ready_state_start_task_handler,
 		.complete_task_handler	= scic_sds_remote_device_ready_state_complete_request_handler,
 		.suspend_handler	= scic_sds_remote_device_default_suspend_handler,
 		.resume_handler		= scic_sds_remote_device_default_resume_handler,
@@ -1186,7 +1141,6 @@ static const struct scic_sds_remote_device_state_handler scic_sds_remote_device_
 		.frame_handler		= scic_sds_remote_device_general_frame_handler,
 	},
 	[SCIC_SDS_STP_REMOTE_DEVICE_READY_SUBSTATE_IDLE] = {
-		.start_task_handler	= scic_sds_stp_remote_device_ready_substate_start_request_handler,
 		.complete_task_handler	= scic_sds_remote_device_default_complete_request_handler,
 		.suspend_handler		= scic_sds_remote_device_default_suspend_handler,
 		.resume_handler			= scic_sds_remote_device_default_resume_handler,
@@ -1194,7 +1148,6 @@ static const struct scic_sds_remote_device_state_handler scic_sds_remote_device_
 		.frame_handler			= scic_sds_remote_device_default_frame_handler
 	},
 	[SCIC_SDS_STP_REMOTE_DEVICE_READY_SUBSTATE_CMD] = {
-		.start_task_handler	= scic_sds_stp_remote_device_ready_substate_start_request_handler,
 		.complete_task_handler	= scic_sds_stp_remote_device_complete_request,
 		.suspend_handler		= scic_sds_stp_remote_device_ready_cmd_substate_suspend_handler,
 		.resume_handler			= scic_sds_remote_device_default_resume_handler,
@@ -1202,7 +1155,6 @@ static const struct scic_sds_remote_device_state_handler scic_sds_remote_device_
 		.frame_handler			= scic_sds_stp_remote_device_ready_cmd_substate_frame_handler
 	},
 	[SCIC_SDS_STP_REMOTE_DEVICE_READY_SUBSTATE_NCQ] = {
-		.start_task_handler	= scic_sds_stp_remote_device_ready_substate_start_request_handler,
 		.complete_task_handler	= scic_sds_stp_remote_device_complete_request,
 		.suspend_handler		= scic_sds_remote_device_default_suspend_handler,
 		.resume_handler			= scic_sds_remote_device_default_resume_handler,
@@ -1210,7 +1162,6 @@ static const struct scic_sds_remote_device_state_handler scic_sds_remote_device_
 		.frame_handler			= scic_sds_stp_remote_device_ready_ncq_substate_frame_handler
 	},
 	[SCIC_SDS_STP_REMOTE_DEVICE_READY_SUBSTATE_NCQ_ERROR] = {
-		.start_task_handler	= scic_sds_stp_remote_device_ready_substate_start_request_handler,
 		.complete_task_handler	= scic_sds_stp_remote_device_complete_request,
 		.suspend_handler		= scic_sds_remote_device_default_suspend_handler,
 		.resume_handler			= scic_sds_remote_device_default_resume_handler,
@@ -1218,7 +1169,6 @@ static const struct scic_sds_remote_device_state_handler scic_sds_remote_device_
 		.frame_handler			= scic_sds_remote_device_general_frame_handler
 	},
 	[SCIC_SDS_STP_REMOTE_DEVICE_READY_SUBSTATE_AWAIT_RESET] = {
-		.start_task_handler	= scic_sds_stp_remote_device_ready_substate_start_request_handler,
 		.complete_task_handler	= scic_sds_stp_remote_device_complete_request,
 		.suspend_handler		= scic_sds_remote_device_default_suspend_handler,
 		.resume_handler			= scic_sds_remote_device_default_resume_handler,
@@ -1226,7 +1176,6 @@ static const struct scic_sds_remote_device_state_handler scic_sds_remote_device_
 		.frame_handler			= scic_sds_remote_device_general_frame_handler
 	},
 	[SCIC_SDS_SMP_REMOTE_DEVICE_READY_SUBSTATE_IDLE] = {
-		.start_task_handler	= scic_sds_remote_device_default_start_request_handler,
 		.complete_task_handler	= scic_sds_remote_device_default_complete_request_handler,
 		.suspend_handler	= scic_sds_remote_device_default_suspend_handler,
 		.resume_handler		= scic_sds_remote_device_default_resume_handler,
@@ -1234,7 +1183,6 @@ static const struct scic_sds_remote_device_state_handler scic_sds_remote_device_
 		.frame_handler		= scic_sds_remote_device_default_frame_handler
 	},
 	[SCIC_SDS_SMP_REMOTE_DEVICE_READY_SUBSTATE_CMD] = {
-		.start_task_handler	= scic_sds_remote_device_default_start_request_handler,
 		.complete_task_handler	= scic_sds_remote_device_default_complete_request_handler,
 		.suspend_handler	= scic_sds_remote_device_default_suspend_handler,
 		.resume_handler		= scic_sds_remote_device_default_resume_handler,
@@ -1242,7 +1190,6 @@ static const struct scic_sds_remote_device_state_handler scic_sds_remote_device_
 		.frame_handler		= scic_sds_smp_remote_device_ready_cmd_substate_frame_handler
 	},
 	[SCI_BASE_REMOTE_DEVICE_STATE_STOPPING] = {
-		.start_task_handler	= scic_sds_remote_device_default_start_request_handler,
 		.complete_task_handler	= scic_sds_remote_device_stopping_state_complete_request_handler,
 		.suspend_handler	= scic_sds_remote_device_default_suspend_handler,
 		.resume_handler		= scic_sds_remote_device_default_resume_handler,
@@ -1250,7 +1197,6 @@ static const struct scic_sds_remote_device_state_handler scic_sds_remote_device_
 		.frame_handler		= scic_sds_remote_device_general_frame_handler
 	},
 	[SCI_BASE_REMOTE_DEVICE_STATE_FAILED] = {
-		.start_task_handler	= scic_sds_remote_device_default_start_request_handler,
 		.complete_task_handler	= scic_sds_remote_device_default_complete_request_handler,
 		.suspend_handler	= scic_sds_remote_device_default_suspend_handler,
 		.resume_handler		= scic_sds_remote_device_default_resume_handler,
@@ -1258,7 +1204,6 @@ static const struct scic_sds_remote_device_state_handler scic_sds_remote_device_
 		.frame_handler		= scic_sds_remote_device_general_frame_handler
 	},
 	[SCI_BASE_REMOTE_DEVICE_STATE_RESETTING] = {
-		.start_task_handler	= scic_sds_remote_device_default_start_request_handler,
 		.complete_task_handler	= scic_sds_remote_device_resetting_state_complete_request_handler,
 		.suspend_handler	= scic_sds_remote_device_default_suspend_handler,
 		.resume_handler		= scic_sds_remote_device_default_resume_handler,
@@ -1266,7 +1211,6 @@ static const struct scic_sds_remote_device_state_handler scic_sds_remote_device_
 		.frame_handler		= scic_sds_remote_device_general_frame_handler
 	},
 	[SCI_BASE_REMOTE_DEVICE_STATE_FINAL] = {
-		.start_task_handler	= scic_sds_remote_device_default_start_request_handler,
 		.complete_task_handler	= scic_sds_remote_device_default_complete_request_handler,
 		.suspend_handler	= scic_sds_remote_device_default_suspend_handler,
 		.resume_handler		= scic_sds_remote_device_default_resume_handler,

commit c027a20bf3fa831fed70b1662e526be04447ab07
Author: Dan Williams <dan.j.williams@intel.com>
Date:   Sun May 1 15:46:18 2011 -0700

    isci: kill remote_device continue_io_handler
    
    This is unused infrastructure.
    
    Reported-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/drivers/scsi/isci/remote_device.c b/drivers/scsi/isci/remote_device.c
index a6247675c5c7..3580c0a5a719 100644
--- a/drivers/scsi/isci/remote_device.c
+++ b/drivers/scsi/isci/remote_device.c
@@ -751,13 +751,6 @@ static enum sci_status scic_sds_remote_device_default_complete_request_handler(
 	return default_device_handler(sci_dev, __func__);
 }
 
-static enum sci_status scic_sds_remote_device_default_continue_request_handler(
-	struct scic_sds_remote_device *sci_dev,
-	struct scic_sds_request *request)
-{
-	return default_device_handler(sci_dev, __func__);
-}
-
 /**
  *
  * @device: The struct scic_sds_remote_device which is then cast into a
@@ -1161,7 +1154,6 @@ static enum sci_status scic_sds_smp_remote_device_ready_cmd_substate_frame_handl
 
 static const struct scic_sds_remote_device_state_handler scic_sds_remote_device_state_handler_table[] = {
 	[SCI_BASE_REMOTE_DEVICE_STATE_INITIAL] = {
-		.continue_io_handler	= scic_sds_remote_device_default_continue_request_handler,
 		.start_task_handler	= scic_sds_remote_device_default_start_request_handler,
 		.complete_task_handler	= scic_sds_remote_device_default_complete_request_handler,
 		.suspend_handler	= scic_sds_remote_device_default_suspend_handler,
@@ -1170,7 +1162,6 @@ static const struct scic_sds_remote_device_state_handler scic_sds_remote_device_
 		.frame_handler		= scic_sds_remote_device_default_frame_handler
 	},
 	[SCI_BASE_REMOTE_DEVICE_STATE_STOPPED] = {
-		.continue_io_handler	= scic_sds_remote_device_default_continue_request_handler,
 		.start_task_handler	= scic_sds_remote_device_default_start_request_handler,
 		.complete_task_handler	= scic_sds_remote_device_default_complete_request_handler,
 		.suspend_handler	= scic_sds_remote_device_default_suspend_handler,
@@ -1179,7 +1170,6 @@ static const struct scic_sds_remote_device_state_handler scic_sds_remote_device_
 		.frame_handler		= scic_sds_remote_device_default_frame_handler
 	},
 	[SCI_BASE_REMOTE_DEVICE_STATE_STARTING] = {
-		.continue_io_handler	= scic_sds_remote_device_default_continue_request_handler,
 		.start_task_handler	= scic_sds_remote_device_default_start_request_handler,
 		.complete_task_handler	= scic_sds_remote_device_default_complete_request_handler,
 		.suspend_handler	= scic_sds_remote_device_default_suspend_handler,
@@ -1188,7 +1178,6 @@ static const struct scic_sds_remote_device_state_handler scic_sds_remote_device_
 		.frame_handler		= scic_sds_remote_device_default_frame_handler
 	},
 	[SCI_BASE_REMOTE_DEVICE_STATE_READY] = {
-		.continue_io_handler	= scic_sds_remote_device_default_continue_request_handler,
 		.start_task_handler	= scic_sds_remote_device_ready_state_start_task_handler,
 		.complete_task_handler	= scic_sds_remote_device_ready_state_complete_request_handler,
 		.suspend_handler	= scic_sds_remote_device_default_suspend_handler,
@@ -1197,7 +1186,6 @@ static const struct scic_sds_remote_device_state_handler scic_sds_remote_device_
 		.frame_handler		= scic_sds_remote_device_general_frame_handler,
 	},
 	[SCIC_SDS_STP_REMOTE_DEVICE_READY_SUBSTATE_IDLE] = {
-		.continue_io_handler	= scic_sds_remote_device_default_continue_request_handler,
 		.start_task_handler	= scic_sds_stp_remote_device_ready_substate_start_request_handler,
 		.complete_task_handler	= scic_sds_remote_device_default_complete_request_handler,
 		.suspend_handler		= scic_sds_remote_device_default_suspend_handler,
@@ -1206,7 +1194,6 @@ static const struct scic_sds_remote_device_state_handler scic_sds_remote_device_
 		.frame_handler			= scic_sds_remote_device_default_frame_handler
 	},
 	[SCIC_SDS_STP_REMOTE_DEVICE_READY_SUBSTATE_CMD] = {
-		.continue_io_handler	= scic_sds_remote_device_default_continue_request_handler,
 		.start_task_handler	= scic_sds_stp_remote_device_ready_substate_start_request_handler,
 		.complete_task_handler	= scic_sds_stp_remote_device_complete_request,
 		.suspend_handler		= scic_sds_stp_remote_device_ready_cmd_substate_suspend_handler,
@@ -1215,7 +1202,6 @@ static const struct scic_sds_remote_device_state_handler scic_sds_remote_device_
 		.frame_handler			= scic_sds_stp_remote_device_ready_cmd_substate_frame_handler
 	},
 	[SCIC_SDS_STP_REMOTE_DEVICE_READY_SUBSTATE_NCQ] = {
-		.continue_io_handler	= scic_sds_remote_device_default_continue_request_handler,
 		.start_task_handler	= scic_sds_stp_remote_device_ready_substate_start_request_handler,
 		.complete_task_handler	= scic_sds_stp_remote_device_complete_request,
 		.suspend_handler		= scic_sds_remote_device_default_suspend_handler,
@@ -1224,7 +1210,6 @@ static const struct scic_sds_remote_device_state_handler scic_sds_remote_device_
 		.frame_handler			= scic_sds_stp_remote_device_ready_ncq_substate_frame_handler
 	},
 	[SCIC_SDS_STP_REMOTE_DEVICE_READY_SUBSTATE_NCQ_ERROR] = {
-		.continue_io_handler	= scic_sds_remote_device_default_continue_request_handler,
 		.start_task_handler	= scic_sds_stp_remote_device_ready_substate_start_request_handler,
 		.complete_task_handler	= scic_sds_stp_remote_device_complete_request,
 		.suspend_handler		= scic_sds_remote_device_default_suspend_handler,
@@ -1233,7 +1218,6 @@ static const struct scic_sds_remote_device_state_handler scic_sds_remote_device_
 		.frame_handler			= scic_sds_remote_device_general_frame_handler
 	},
 	[SCIC_SDS_STP_REMOTE_DEVICE_READY_SUBSTATE_AWAIT_RESET] = {
-		.continue_io_handler	= scic_sds_remote_device_default_continue_request_handler,
 		.start_task_handler	= scic_sds_stp_remote_device_ready_substate_start_request_handler,
 		.complete_task_handler	= scic_sds_stp_remote_device_complete_request,
 		.suspend_handler		= scic_sds_remote_device_default_suspend_handler,
@@ -1242,7 +1226,6 @@ static const struct scic_sds_remote_device_state_handler scic_sds_remote_device_
 		.frame_handler			= scic_sds_remote_device_general_frame_handler
 	},
 	[SCIC_SDS_SMP_REMOTE_DEVICE_READY_SUBSTATE_IDLE] = {
-		.continue_io_handler	= scic_sds_remote_device_default_continue_request_handler,
 		.start_task_handler	= scic_sds_remote_device_default_start_request_handler,
 		.complete_task_handler	= scic_sds_remote_device_default_complete_request_handler,
 		.suspend_handler	= scic_sds_remote_device_default_suspend_handler,
@@ -1251,7 +1234,6 @@ static const struct scic_sds_remote_device_state_handler scic_sds_remote_device_
 		.frame_handler		= scic_sds_remote_device_default_frame_handler
 	},
 	[SCIC_SDS_SMP_REMOTE_DEVICE_READY_SUBSTATE_CMD] = {
-		.continue_io_handler	= scic_sds_remote_device_default_continue_request_handler,
 		.start_task_handler	= scic_sds_remote_device_default_start_request_handler,
 		.complete_task_handler	= scic_sds_remote_device_default_complete_request_handler,
 		.suspend_handler	= scic_sds_remote_device_default_suspend_handler,
@@ -1260,7 +1242,6 @@ static const struct scic_sds_remote_device_state_handler scic_sds_remote_device_
 		.frame_handler		= scic_sds_smp_remote_device_ready_cmd_substate_frame_handler
 	},
 	[SCI_BASE_REMOTE_DEVICE_STATE_STOPPING] = {
-		.continue_io_handler	= scic_sds_remote_device_default_continue_request_handler,
 		.start_task_handler	= scic_sds_remote_device_default_start_request_handler,
 		.complete_task_handler	= scic_sds_remote_device_stopping_state_complete_request_handler,
 		.suspend_handler	= scic_sds_remote_device_default_suspend_handler,
@@ -1269,7 +1250,6 @@ static const struct scic_sds_remote_device_state_handler scic_sds_remote_device_
 		.frame_handler		= scic_sds_remote_device_general_frame_handler
 	},
 	[SCI_BASE_REMOTE_DEVICE_STATE_FAILED] = {
-		.continue_io_handler	= scic_sds_remote_device_default_continue_request_handler,
 		.start_task_handler	= scic_sds_remote_device_default_start_request_handler,
 		.complete_task_handler	= scic_sds_remote_device_default_complete_request_handler,
 		.suspend_handler	= scic_sds_remote_device_default_suspend_handler,
@@ -1278,7 +1258,6 @@ static const struct scic_sds_remote_device_state_handler scic_sds_remote_device_
 		.frame_handler		= scic_sds_remote_device_general_frame_handler
 	},
 	[SCI_BASE_REMOTE_DEVICE_STATE_RESETTING] = {
-		.continue_io_handler	= scic_sds_remote_device_default_continue_request_handler,
 		.start_task_handler	= scic_sds_remote_device_default_start_request_handler,
 		.complete_task_handler	= scic_sds_remote_device_resetting_state_complete_request_handler,
 		.suspend_handler	= scic_sds_remote_device_default_suspend_handler,
@@ -1287,7 +1266,6 @@ static const struct scic_sds_remote_device_state_handler scic_sds_remote_device_
 		.frame_handler		= scic_sds_remote_device_general_frame_handler
 	},
 	[SCI_BASE_REMOTE_DEVICE_STATE_FINAL] = {
-		.continue_io_handler	= scic_sds_remote_device_default_continue_request_handler,
 		.start_task_handler	= scic_sds_remote_device_default_start_request_handler,
 		.complete_task_handler	= scic_sds_remote_device_default_complete_request_handler,
 		.suspend_handler	= scic_sds_remote_device_default_suspend_handler,

commit 10a09e64be2580ceef8539629fb953b7d94fa35f
Author: Dan Williams <dan.j.williams@intel.com>
Date:   Sun May 1 15:33:43 2011 -0700

    isci: unify remote_device complete_io_handlers
    
    Implement all states in scic_sds_remote_device_complete_io() and delete
    the state handler.
    
    Reported-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/drivers/scsi/isci/remote_device.c b/drivers/scsi/isci/remote_device.c
index f4ba5be00c03..a6247675c5c7 100644
--- a/drivers/scsi/isci/remote_device.c
+++ b/drivers/scsi/isci/remote_device.c
@@ -433,22 +433,92 @@ enum sci_status scic_sds_remote_device_start_io(struct scic_sds_controller *scic
 	return status;
 }
 
-/**
- *
- * @controller: The controller that is completing the io request.
- * @sci_dev: The remote device for which the complete io handling is being
- *    requested.
- * @io_request: The io request that is being completed.
- *
- * This method invokes the remote device complete io handler. enum sci_status
- */
-enum sci_status scic_sds_remote_device_complete_io(
-	struct scic_sds_controller *controller,
-	struct scic_sds_remote_device *sci_dev,
-	struct scic_sds_request *io_request)
+static enum sci_status common_complete_io(struct scic_sds_port *sci_port,
+					  struct scic_sds_remote_device *sci_dev,
+					  struct scic_sds_request *sci_req)
 {
-	return sci_dev->state_handlers->complete_io_handler(
-		       sci_dev, io_request);
+	enum sci_status status;
+
+	status = scic_sds_request_complete(sci_req);
+	if (status != SCI_SUCCESS)
+		return status;
+
+	status = scic_sds_port_complete_io(sci_port, sci_dev, sci_req);
+	if (status != SCI_SUCCESS)
+		return status;
+
+	scic_sds_remote_device_decrement_request_count(sci_dev);
+	return status;
+}
+
+enum sci_status scic_sds_remote_device_complete_io(struct scic_sds_controller *scic,
+						   struct scic_sds_remote_device *sci_dev,
+						   struct scic_sds_request *sci_req)
+{
+	struct sci_base_state_machine *sm = &sci_dev->state_machine;
+	enum scic_sds_remote_device_states state = sm->current_state_id;
+	struct scic_sds_port *sci_port = sci_dev->owning_port;
+	enum sci_status status;
+
+	switch (state) {
+	case SCI_BASE_REMOTE_DEVICE_STATE_INITIAL:
+	case SCI_BASE_REMOTE_DEVICE_STATE_STOPPED:
+	case SCI_BASE_REMOTE_DEVICE_STATE_STARTING:
+	case SCIC_SDS_STP_REMOTE_DEVICE_READY_SUBSTATE_IDLE:
+	case SCIC_SDS_SMP_REMOTE_DEVICE_READY_SUBSTATE_IDLE:
+	case SCI_BASE_REMOTE_DEVICE_STATE_FAILED:
+	case SCI_BASE_REMOTE_DEVICE_STATE_FINAL:
+	default:
+		dev_warn(scirdev_to_dev(sci_dev), "%s: in wrong state: %d\n",
+			 __func__, state);
+		return SCI_FAILURE_INVALID_STATE;
+	case SCI_BASE_REMOTE_DEVICE_STATE_READY:
+	case SCIC_SDS_STP_REMOTE_DEVICE_READY_SUBSTATE_AWAIT_RESET:
+	case SCI_BASE_REMOTE_DEVICE_STATE_RESETTING:
+		status = common_complete_io(sci_port, sci_dev, sci_req);
+		break;
+	case SCIC_SDS_STP_REMOTE_DEVICE_READY_SUBSTATE_CMD:
+	case SCIC_SDS_STP_REMOTE_DEVICE_READY_SUBSTATE_NCQ:
+	case SCIC_SDS_STP_REMOTE_DEVICE_READY_SUBSTATE_NCQ_ERROR:
+		status = common_complete_io(sci_port, sci_dev, sci_req);
+		if (status != SCI_SUCCESS)
+			break;
+
+		if (sci_req->sci_status == SCI_FAILURE_REMOTE_DEVICE_RESET_REQUIRED) {
+			/* This request causes hardware error, device needs to be Lun Reset.
+			 * So here we force the state machine to IDLE state so the rest IOs
+			 * can reach RNC state handler, these IOs will be completed by RNC with
+			 * status of "DEVICE_RESET_REQUIRED", instead of "INVALID STATE".
+			 */
+			sci_base_state_machine_change_state(sm, SCIC_SDS_STP_REMOTE_DEVICE_READY_SUBSTATE_AWAIT_RESET);
+		} else if (scic_sds_remote_device_get_request_count(sci_dev) == 0)
+			sci_base_state_machine_change_state(sm, SCIC_SDS_STP_REMOTE_DEVICE_READY_SUBSTATE_IDLE);
+		break;
+	case SCIC_SDS_SMP_REMOTE_DEVICE_READY_SUBSTATE_CMD:
+		status = common_complete_io(sci_port, sci_dev, sci_req);
+		if (status != SCI_SUCCESS)
+			break;
+		sci_base_state_machine_change_state(sm, SCIC_SDS_SMP_REMOTE_DEVICE_READY_SUBSTATE_IDLE);
+		break;
+	case SCI_BASE_REMOTE_DEVICE_STATE_STOPPING:
+		status = common_complete_io(sci_port, sci_dev, sci_req);
+		if (status != SCI_SUCCESS)
+			break;
+
+		if (scic_sds_remote_device_get_request_count(sci_dev) == 0)
+			scic_sds_remote_node_context_destruct(&sci_dev->rnc,
+							      rnc_destruct_done,
+							      sci_dev);
+		break;
+	}
+
+	if (status != SCI_SUCCESS)
+		dev_err(scirdev_to_dev(sci_dev),
+			"%s: Port:0x%p Device:0x%p Request:0x%p Status:0x%x "
+			"could not complete\n", __func__, sci_port,
+			sci_dev, sci_req, status);
+
+	return status;
 }
 
 /**
@@ -1058,32 +1128,6 @@ static enum sci_status scic_sds_stp_remote_device_ready_cmd_substate_frame_handl
 						 frame_index);
 }
 
-static enum sci_status scic_sds_stp_remote_device_ready_await_reset_substate_complete_request_handler(
-	struct scic_sds_remote_device *device,
-	struct scic_sds_request *request)
-{
-	struct scic_sds_request *sci_req = request;
-	enum sci_status status;
-
-	status = scic_sds_io_request_complete(sci_req);
-	if (status != SCI_SUCCESS)
-		goto out;
-
-	status = scic_sds_port_complete_io(device->owning_port, device, sci_req);
-	if (status != SCI_SUCCESS)
-		goto out;
-
-	scic_sds_remote_device_decrement_request_count(device);
- out:
-	if (status != SCI_SUCCESS)
-		dev_err(scirdev_to_dev(device),
-			"%s: Port:0x%p Device:0x%p Request:0x%p Status:0x%x "
-			"could not complete\n",
-			__func__, device->owning_port, device, sci_req, status);
-
-	return status;
-}
-
 static void scic_sds_stp_remote_device_ready_idle_substate_resume_complete_handler(void *_dev)
 {
 	struct scic_sds_remote_device *sci_dev = _dev;
@@ -1097,33 +1141,6 @@ static void scic_sds_stp_remote_device_ready_idle_substate_resume_complete_handl
 		isci_remote_device_ready(scic->ihost, idev);
 }
 
-static enum sci_status
-scic_sds_smp_remote_device_ready_cmd_substate_complete_io_handler(struct scic_sds_remote_device *sci_dev,
-								  struct scic_sds_request *sci_req)
-{
-	enum sci_status status;
-
-	status = scic_sds_io_request_complete(sci_req);
-	if (status != SCI_SUCCESS)
-		return status;
-
-	status = scic_sds_port_complete_io(sci_dev->owning_port, sci_dev, sci_req);
-	if (status != SCI_SUCCESS) {
-		dev_err(scirdev_to_dev(sci_dev),
-			"%s: SCIC SDS Remote Device 0x%p io request "
-			"0x%p could not be completd on the port 0x%p "
-			"failed with status %d.\n", __func__, sci_dev, sci_req,
-			sci_dev->owning_port, status);
-		return status;
-	}
-
-	scic_sds_remote_device_decrement_request_count(sci_dev);
-	sci_base_state_machine_change_state(&sci_dev->state_machine,
-					    SCIC_SDS_SMP_REMOTE_DEVICE_READY_SUBSTATE_IDLE);
-
-	return status;
-}
-
 static enum sci_status scic_sds_smp_remote_device_ready_cmd_substate_frame_handler(
 	struct scic_sds_remote_device *sci_dev,
 	u32 frame_index)
@@ -1144,7 +1161,6 @@ static enum sci_status scic_sds_smp_remote_device_ready_cmd_substate_frame_handl
 
 static const struct scic_sds_remote_device_state_handler scic_sds_remote_device_state_handler_table[] = {
 	[SCI_BASE_REMOTE_DEVICE_STATE_INITIAL] = {
-		.complete_io_handler	= scic_sds_remote_device_default_complete_request_handler,
 		.continue_io_handler	= scic_sds_remote_device_default_continue_request_handler,
 		.start_task_handler	= scic_sds_remote_device_default_start_request_handler,
 		.complete_task_handler	= scic_sds_remote_device_default_complete_request_handler,
@@ -1154,7 +1170,6 @@ static const struct scic_sds_remote_device_state_handler scic_sds_remote_device_
 		.frame_handler		= scic_sds_remote_device_default_frame_handler
 	},
 	[SCI_BASE_REMOTE_DEVICE_STATE_STOPPED] = {
-		.complete_io_handler	= scic_sds_remote_device_default_complete_request_handler,
 		.continue_io_handler	= scic_sds_remote_device_default_continue_request_handler,
 		.start_task_handler	= scic_sds_remote_device_default_start_request_handler,
 		.complete_task_handler	= scic_sds_remote_device_default_complete_request_handler,
@@ -1164,7 +1179,6 @@ static const struct scic_sds_remote_device_state_handler scic_sds_remote_device_
 		.frame_handler		= scic_sds_remote_device_default_frame_handler
 	},
 	[SCI_BASE_REMOTE_DEVICE_STATE_STARTING] = {
-		.complete_io_handler	= scic_sds_remote_device_default_complete_request_handler,
 		.continue_io_handler	= scic_sds_remote_device_default_continue_request_handler,
 		.start_task_handler	= scic_sds_remote_device_default_start_request_handler,
 		.complete_task_handler	= scic_sds_remote_device_default_complete_request_handler,
@@ -1174,7 +1188,6 @@ static const struct scic_sds_remote_device_state_handler scic_sds_remote_device_
 		.frame_handler		= scic_sds_remote_device_default_frame_handler
 	},
 	[SCI_BASE_REMOTE_DEVICE_STATE_READY] = {
-		.complete_io_handler	= scic_sds_remote_device_ready_state_complete_request_handler,
 		.continue_io_handler	= scic_sds_remote_device_default_continue_request_handler,
 		.start_task_handler	= scic_sds_remote_device_ready_state_start_task_handler,
 		.complete_task_handler	= scic_sds_remote_device_ready_state_complete_request_handler,
@@ -1184,7 +1197,6 @@ static const struct scic_sds_remote_device_state_handler scic_sds_remote_device_
 		.frame_handler		= scic_sds_remote_device_general_frame_handler,
 	},
 	[SCIC_SDS_STP_REMOTE_DEVICE_READY_SUBSTATE_IDLE] = {
-		.complete_io_handler	= scic_sds_remote_device_default_complete_request_handler,
 		.continue_io_handler	= scic_sds_remote_device_default_continue_request_handler,
 		.start_task_handler	= scic_sds_stp_remote_device_ready_substate_start_request_handler,
 		.complete_task_handler	= scic_sds_remote_device_default_complete_request_handler,
@@ -1194,7 +1206,6 @@ static const struct scic_sds_remote_device_state_handler scic_sds_remote_device_
 		.frame_handler			= scic_sds_remote_device_default_frame_handler
 	},
 	[SCIC_SDS_STP_REMOTE_DEVICE_READY_SUBSTATE_CMD] = {
-		.complete_io_handler	= scic_sds_stp_remote_device_complete_request,
 		.continue_io_handler	= scic_sds_remote_device_default_continue_request_handler,
 		.start_task_handler	= scic_sds_stp_remote_device_ready_substate_start_request_handler,
 		.complete_task_handler	= scic_sds_stp_remote_device_complete_request,
@@ -1204,7 +1215,6 @@ static const struct scic_sds_remote_device_state_handler scic_sds_remote_device_
 		.frame_handler			= scic_sds_stp_remote_device_ready_cmd_substate_frame_handler
 	},
 	[SCIC_SDS_STP_REMOTE_DEVICE_READY_SUBSTATE_NCQ] = {
-		.complete_io_handler	= scic_sds_stp_remote_device_complete_request,
 		.continue_io_handler	= scic_sds_remote_device_default_continue_request_handler,
 		.start_task_handler	= scic_sds_stp_remote_device_ready_substate_start_request_handler,
 		.complete_task_handler	= scic_sds_stp_remote_device_complete_request,
@@ -1214,7 +1224,6 @@ static const struct scic_sds_remote_device_state_handler scic_sds_remote_device_
 		.frame_handler			= scic_sds_stp_remote_device_ready_ncq_substate_frame_handler
 	},
 	[SCIC_SDS_STP_REMOTE_DEVICE_READY_SUBSTATE_NCQ_ERROR] = {
-		.complete_io_handler	= scic_sds_stp_remote_device_complete_request,
 		.continue_io_handler	= scic_sds_remote_device_default_continue_request_handler,
 		.start_task_handler	= scic_sds_stp_remote_device_ready_substate_start_request_handler,
 		.complete_task_handler	= scic_sds_stp_remote_device_complete_request,
@@ -1224,7 +1233,6 @@ static const struct scic_sds_remote_device_state_handler scic_sds_remote_device_
 		.frame_handler			= scic_sds_remote_device_general_frame_handler
 	},
 	[SCIC_SDS_STP_REMOTE_DEVICE_READY_SUBSTATE_AWAIT_RESET] = {
-		.complete_io_handler	= scic_sds_stp_remote_device_ready_await_reset_substate_complete_request_handler,
 		.continue_io_handler	= scic_sds_remote_device_default_continue_request_handler,
 		.start_task_handler	= scic_sds_stp_remote_device_ready_substate_start_request_handler,
 		.complete_task_handler	= scic_sds_stp_remote_device_complete_request,
@@ -1234,7 +1242,6 @@ static const struct scic_sds_remote_device_state_handler scic_sds_remote_device_
 		.frame_handler			= scic_sds_remote_device_general_frame_handler
 	},
 	[SCIC_SDS_SMP_REMOTE_DEVICE_READY_SUBSTATE_IDLE] = {
-		.complete_io_handler	= scic_sds_remote_device_default_complete_request_handler,
 		.continue_io_handler	= scic_sds_remote_device_default_continue_request_handler,
 		.start_task_handler	= scic_sds_remote_device_default_start_request_handler,
 		.complete_task_handler	= scic_sds_remote_device_default_complete_request_handler,
@@ -1244,7 +1251,6 @@ static const struct scic_sds_remote_device_state_handler scic_sds_remote_device_
 		.frame_handler		= scic_sds_remote_device_default_frame_handler
 	},
 	[SCIC_SDS_SMP_REMOTE_DEVICE_READY_SUBSTATE_CMD] = {
-		.complete_io_handler	= scic_sds_smp_remote_device_ready_cmd_substate_complete_io_handler,
 		.continue_io_handler	= scic_sds_remote_device_default_continue_request_handler,
 		.start_task_handler	= scic_sds_remote_device_default_start_request_handler,
 		.complete_task_handler	= scic_sds_remote_device_default_complete_request_handler,
@@ -1254,7 +1260,6 @@ static const struct scic_sds_remote_device_state_handler scic_sds_remote_device_
 		.frame_handler		= scic_sds_smp_remote_device_ready_cmd_substate_frame_handler
 	},
 	[SCI_BASE_REMOTE_DEVICE_STATE_STOPPING] = {
-		.complete_io_handler	= scic_sds_remote_device_stopping_state_complete_request_handler,
 		.continue_io_handler	= scic_sds_remote_device_default_continue_request_handler,
 		.start_task_handler	= scic_sds_remote_device_default_start_request_handler,
 		.complete_task_handler	= scic_sds_remote_device_stopping_state_complete_request_handler,
@@ -1264,7 +1269,6 @@ static const struct scic_sds_remote_device_state_handler scic_sds_remote_device_
 		.frame_handler		= scic_sds_remote_device_general_frame_handler
 	},
 	[SCI_BASE_REMOTE_DEVICE_STATE_FAILED] = {
-		.complete_io_handler	= scic_sds_remote_device_default_complete_request_handler,
 		.continue_io_handler	= scic_sds_remote_device_default_continue_request_handler,
 		.start_task_handler	= scic_sds_remote_device_default_start_request_handler,
 		.complete_task_handler	= scic_sds_remote_device_default_complete_request_handler,
@@ -1274,7 +1278,6 @@ static const struct scic_sds_remote_device_state_handler scic_sds_remote_device_
 		.frame_handler		= scic_sds_remote_device_general_frame_handler
 	},
 	[SCI_BASE_REMOTE_DEVICE_STATE_RESETTING] = {
-		.complete_io_handler	= scic_sds_remote_device_resetting_state_complete_request_handler,
 		.continue_io_handler	= scic_sds_remote_device_default_continue_request_handler,
 		.start_task_handler	= scic_sds_remote_device_default_start_request_handler,
 		.complete_task_handler	= scic_sds_remote_device_resetting_state_complete_request_handler,
@@ -1284,7 +1287,6 @@ static const struct scic_sds_remote_device_state_handler scic_sds_remote_device_
 		.frame_handler		= scic_sds_remote_device_general_frame_handler
 	},
 	[SCI_BASE_REMOTE_DEVICE_STATE_FINAL] = {
-		.complete_io_handler	= scic_sds_remote_device_default_complete_request_handler,
 		.continue_io_handler	= scic_sds_remote_device_default_continue_request_handler,
 		.start_task_handler	= scic_sds_remote_device_default_start_request_handler,
 		.complete_task_handler	= scic_sds_remote_device_default_complete_request_handler,

commit 1860655706ee5a7e3f3adeebd4927fed98860462
Author: Dan Williams <dan.j.williams@intel.com>
Date:   Sun May 1 14:57:11 2011 -0700

    isci: unify remote_device start_io_handlers
    
    Implement all states in scic_sds_remote_device_start_io() and delete the
    state handler.
    
    Reported-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/drivers/scsi/isci/remote_device.c b/drivers/scsi/isci/remote_device.c
index 658781dd65e6..f4ba5be00c03 100644
--- a/drivers/scsi/isci/remote_device.c
+++ b/drivers/scsi/isci/remote_device.c
@@ -305,22 +305,132 @@ enum sci_status scic_sds_remote_device_event_handler(
 	return sci_dev->state_handlers->event_handler(sci_dev, event_code);
 }
 
-/**
- *
- * @controller: The controller that is starting the io request.
- * @sci_dev: The remote device for which the start io handling is being
- *    requested.
- * @io_request: The io request that is being started.
- *
- * This method invokes the remote device start io handler. enum sci_status
- */
-enum sci_status scic_sds_remote_device_start_io(
-	struct scic_sds_controller *controller,
-	struct scic_sds_remote_device *sci_dev,
-	struct scic_sds_request *io_request)
+static void scic_sds_remote_device_start_request(struct scic_sds_remote_device *sci_dev,
+						 struct scic_sds_request *sci_req,
+						 enum sci_status status)
 {
-	return sci_dev->state_handlers->start_io_handler(
-		       sci_dev, io_request);
+	struct scic_sds_port *sci_port = sci_dev->owning_port;
+
+	/* cleanup requests that failed after starting on the port */
+	if (status != SCI_SUCCESS)
+		scic_sds_port_complete_io(sci_port, sci_dev, sci_req);
+	else
+		scic_sds_remote_device_increment_request_count(sci_dev);
+}
+
+enum sci_status scic_sds_remote_device_start_io(struct scic_sds_controller *scic,
+						struct scic_sds_remote_device *sci_dev,
+						struct scic_sds_request *sci_req)
+{
+	struct sci_base_state_machine *sm = &sci_dev->state_machine;
+	enum scic_sds_remote_device_states state = sm->current_state_id;
+	struct scic_sds_port *sci_port = sci_dev->owning_port;
+	enum sci_status status;
+
+	switch (state) {
+	case SCI_BASE_REMOTE_DEVICE_STATE_INITIAL:
+	case SCI_BASE_REMOTE_DEVICE_STATE_STOPPED:
+	case SCI_BASE_REMOTE_DEVICE_STATE_STARTING:
+	case SCIC_SDS_STP_REMOTE_DEVICE_READY_SUBSTATE_NCQ_ERROR:
+	case SCI_BASE_REMOTE_DEVICE_STATE_STOPPING:
+	case SCI_BASE_REMOTE_DEVICE_STATE_FAILED:
+	case SCI_BASE_REMOTE_DEVICE_STATE_RESETTING:
+	case SCI_BASE_REMOTE_DEVICE_STATE_FINAL:
+	default:
+		dev_warn(scirdev_to_dev(sci_dev), "%s: in wrong state: %d\n",
+			 __func__, state);
+		return SCI_FAILURE_INVALID_STATE;
+	case SCI_BASE_REMOTE_DEVICE_STATE_READY:
+		/* attempt to start an io request for this device object. The remote
+		 * device object will issue the start request for the io and if
+		 * successful it will start the request for the port object then
+		 * increment its own request count.
+		 */
+		status = scic_sds_port_start_io(sci_port, sci_dev, sci_req);
+		if (status != SCI_SUCCESS)
+			return status;
+
+		status = scic_sds_remote_node_context_start_io(&sci_dev->rnc, sci_req);
+		if (status != SCI_SUCCESS)
+			break;
+
+		status = scic_sds_request_start(sci_req);
+		break;
+	case SCIC_SDS_STP_REMOTE_DEVICE_READY_SUBSTATE_IDLE: {
+		/* handle the start io operation for a sata device that is in
+		 * the command idle state. - Evalute the type of IO request to
+		 * be started - If its an NCQ request change to NCQ substate -
+		 * If its any other command change to the CMD substate
+		 *
+		 * If this is a softreset we may want to have a different
+		 * substate.
+		 */
+		enum scic_sds_remote_device_states new_state;
+
+		status = scic_sds_port_start_io(sci_port, sci_dev, sci_req);
+		if (status != SCI_SUCCESS)
+			return status;
+
+		status = scic_sds_remote_node_context_start_io(&sci_dev->rnc, sci_req);
+		if (status != SCI_SUCCESS)
+			break;
+
+		status = sci_req->state_handlers->start_handler(sci_req);
+		if (status != SCI_SUCCESS)
+			break;
+
+		if (isci_sata_get_sat_protocol(sci_req->ireq) == SAT_PROTOCOL_FPDMA)
+			new_state = SCIC_SDS_STP_REMOTE_DEVICE_READY_SUBSTATE_NCQ;
+		else {
+			sci_dev->working_request = sci_req;
+			new_state = SCIC_SDS_STP_REMOTE_DEVICE_READY_SUBSTATE_CMD;
+		}
+		sci_base_state_machine_change_state(sm, new_state);
+		break;
+	}
+	case SCIC_SDS_STP_REMOTE_DEVICE_READY_SUBSTATE_NCQ:
+		if (isci_sata_get_sat_protocol(sci_req->ireq) == SAT_PROTOCOL_FPDMA) {
+			status = scic_sds_port_start_io(sci_port, sci_dev, sci_req);
+			if (status != SCI_SUCCESS)
+				return status;
+
+			status = scic_sds_remote_node_context_start_io(&sci_dev->rnc, sci_req);
+			if (status != SCI_SUCCESS)
+				break;
+
+			status = sci_req->state_handlers->start_handler(sci_req);
+		} else
+			return SCI_FAILURE_INVALID_STATE;
+		break;
+	case SCIC_SDS_STP_REMOTE_DEVICE_READY_SUBSTATE_AWAIT_RESET:
+		return SCI_FAILURE_REMOTE_DEVICE_RESET_REQUIRED;
+	case SCIC_SDS_SMP_REMOTE_DEVICE_READY_SUBSTATE_IDLE:
+		status = scic_sds_port_start_io(sci_port, sci_dev, sci_req);
+		if (status != SCI_SUCCESS)
+			return status;
+
+		status = scic_sds_remote_node_context_start_io(&sci_dev->rnc, sci_req);
+		if (status != SCI_SUCCESS)
+			break;
+
+		status = scic_sds_request_start(sci_req);
+		if (status != SCI_SUCCESS)
+			break;
+
+		sci_dev->working_request = sci_req;
+		sci_base_state_machine_change_state(&sci_dev->state_machine,
+						    SCIC_SDS_SMP_REMOTE_DEVICE_READY_SUBSTATE_CMD);
+		break;
+	case SCIC_SDS_STP_REMOTE_DEVICE_READY_SUBSTATE_CMD:
+	case SCIC_SDS_SMP_REMOTE_DEVICE_READY_SUBSTATE_CMD:
+		/* device is already handling a command it can not accept new commands
+		 * until this one is complete.
+		 */
+		return SCI_FAILURE_INVALID_STATE;
+	}
+
+	scic_sds_remote_device_start_request(sci_dev, sci_req, status);
+	return status;
 }
 
 /**
@@ -409,32 +519,6 @@ static void remote_device_resume_done(void *_dev)
 	}
 }
 
-/**
- *
- * @device: This parameter specifies the device for which the request is being
- *    started.
- * @request: This parameter specifies the request being started.
- * @status: This parameter specifies the current start operation status.
- *
- * This method will perform the STP request start processing common to IO
- * requests and task requests of all types. none
- */
-static void scic_sds_remote_device_start_request(
-	struct scic_sds_remote_device *sci_dev,
-	struct scic_sds_request *sci_req,
-	enum sci_status status)
-{
-	/* We still have a fault in starting the io complete it on the port */
-	if (status == SCI_SUCCESS)
-		scic_sds_remote_device_increment_request_count(sci_dev);
-	else{
-		sci_dev->owning_port->state_handlers->complete_io_handler(
-			sci_dev->owning_port, sci_dev, sci_req
-			);
-	}
-}
-
-
 /**
  *
  * @request: This parameter specifies the request being continued.
@@ -699,35 +783,6 @@ static enum sci_status scic_sds_remote_device_ready_state_start_task_handler(
 	return result;
 }
 
-/*
- * This method will attempt to start an io request for this device object. The
- * remote device object will issue the start request for the io and if
- * successful it will start the request for the port object then increment its
- * own requet count. enum sci_status SCI_SUCCESS if the io request is started for
- * this device object. SCI_FAILURE_INSUFFICIENT_RESOURCES if the io request
- * object could not get the resources to start.
- */
-static enum sci_status scic_sds_remote_device_ready_state_start_io_handler(
-	struct scic_sds_remote_device *sci_dev,
-	struct scic_sds_request *request)
-{
-	enum sci_status result;
-
-	/* See if the port is in a state where we can start the IO request */
-	result = scic_sds_port_start_io(
-		scic_sds_remote_device_get_port(sci_dev), sci_dev, request);
-
-	if (result == SCI_SUCCESS) {
-		result = scic_sds_remote_node_context_start_io(&sci_dev->rnc, request);
-		if (result == SCI_SUCCESS)
-			result = scic_sds_request_start(request);
-
-		scic_sds_remote_device_start_request(sci_dev, request, result);
-	}
-
-	return result;
-}
-
 /*
  * This method will complete the request for the remote device object.  The
  * method will call the completion handler for the request object and if
@@ -920,48 +975,6 @@ static enum sci_status scic_sds_stp_remote_device_ready_substate_start_request_h
 	return SCI_FAILURE_RESET_DEVICE_PARTIAL_SUCCESS;
 }
 
-/* handle the start io operation for a sata device that is in the command idle
- * state. - Evalute the type of IO request to be started - If its an NCQ
- * request change to NCQ substate - If its any other command change to the CMD
- * substate
- *
- * If this is a softreset we may want to have a different substate.
- */
-static enum sci_status scic_sds_stp_remote_device_ready_idle_substate_start_io_handler(
-	struct scic_sds_remote_device *sci_dev,
-	struct scic_sds_request *request)
-{
-	enum sci_status status;
-	struct isci_request *isci_request = request->ireq;
-	enum scic_sds_remote_device_states new_state;
-
-	/* Will the port allow the io request to start? */
-	status = sci_dev->owning_port->state_handlers->start_io_handler(
-			sci_dev->owning_port, sci_dev, request);
-	if (status != SCI_SUCCESS)
-		return status;
-
-	status = scic_sds_remote_node_context_start_io(&sci_dev->rnc, request);
-	if (status != SCI_SUCCESS)
-		goto out;
-
-	status = request->state_handlers->start_handler(request);
-	if (status != SCI_SUCCESS)
-		goto out;
-
-	if (isci_sata_get_sat_protocol(isci_request) == SAT_PROTOCOL_FPDMA)
-		new_state = SCIC_SDS_STP_REMOTE_DEVICE_READY_SUBSTATE_NCQ;
-	else {
-		sci_dev->working_request = request;
-		new_state = SCIC_SDS_STP_REMOTE_DEVICE_READY_SUBSTATE_CMD;
-	}
-	sci_base_state_machine_change_state(&sci_dev->state_machine, new_state);
-out:
-	scic_sds_remote_device_start_request(sci_dev, request, status);
-	return status;
-}
-
-
 static enum sci_status scic_sds_stp_remote_device_ready_idle_substate_event_handler(
 	struct scic_sds_remote_device *sci_dev,
 	u32 event_code)
@@ -982,31 +995,6 @@ static enum sci_status scic_sds_stp_remote_device_ready_idle_substate_event_hand
 	return status;
 }
 
-static enum sci_status scic_sds_stp_remote_device_ready_ncq_substate_start_io_handler(
-	struct scic_sds_remote_device *sci_dev,
-	struct scic_sds_request *request)
-{
-	enum sci_status status;
-	struct isci_request *isci_request = request->ireq;
-	scic_sds_port_io_request_handler_t start_io;
-
-	if (isci_sata_get_sat_protocol(isci_request) == SAT_PROTOCOL_FPDMA) {
-		start_io = sci_dev->owning_port->state_handlers->start_io_handler;
-		status = start_io(sci_dev->owning_port, sci_dev, request);
-		if (status != SCI_SUCCESS)
-			return status;
-
-		status = scic_sds_remote_node_context_start_io(&sci_dev->rnc, request);
-		if (status == SCI_SUCCESS)
-			status = request->state_handlers->start_handler(request);
-
-		scic_sds_remote_device_start_request(sci_dev, request, status);
-	} else
-		status = SCI_FAILURE_INVALID_STATE;
-
-	return status;
-}
-
 static enum sci_status scic_sds_stp_remote_device_ready_ncq_substate_frame_handler(struct scic_sds_remote_device *sci_dev,
 										   u32 frame_index)
 {
@@ -1046,16 +1034,6 @@ static enum sci_status scic_sds_stp_remote_device_ready_ncq_substate_frame_handl
 	return status;
 }
 
-static enum sci_status scic_sds_stp_remote_device_ready_cmd_substate_start_io_handler(
-	struct scic_sds_remote_device *device,
-	struct scic_sds_request *request)
-{
-	/* device is already handling a command it can not accept new commands
-	 * until this one is complete.
-	 */
-	return SCI_FAILURE_INVALID_STATE;
-}
-
 static enum sci_status scic_sds_stp_remote_device_ready_cmd_substate_suspend_handler(
 	struct scic_sds_remote_device *sci_dev,
 	u32 suspend_type)
@@ -1080,13 +1058,6 @@ static enum sci_status scic_sds_stp_remote_device_ready_cmd_substate_frame_handl
 						 frame_index);
 }
 
-static enum sci_status scic_sds_stp_remote_device_ready_await_reset_substate_start_io_handler(
-	struct scic_sds_remote_device *device,
-	struct scic_sds_request *request)
-{
-	return SCI_FAILURE_REMOTE_DEVICE_RESET_REQUIRED;
-}
-
 static enum sci_status scic_sds_stp_remote_device_ready_await_reset_substate_complete_request_handler(
 	struct scic_sds_remote_device *device,
 	struct scic_sds_request *request)
@@ -1126,46 +1097,6 @@ static void scic_sds_stp_remote_device_ready_idle_substate_resume_complete_handl
 		isci_remote_device_ready(scic->ihost, idev);
 }
 
-static enum sci_status scic_sds_smp_remote_device_ready_idle_substate_start_io_handler(
-	struct scic_sds_remote_device *sci_dev,
-	struct scic_sds_request *sci_req)
-{
-	enum sci_status status;
-
-	/* Will the port allow the io request to start? */
-	status = sci_dev->owning_port->state_handlers->start_io_handler(
-			sci_dev->owning_port, sci_dev, sci_req);
-	if (status != SCI_SUCCESS)
-		return status;
-
-	status = scic_sds_remote_node_context_start_io(&sci_dev->rnc, sci_req);
-	if (status != SCI_SUCCESS)
-		goto out;
-
-	status = scic_sds_request_start(sci_req);
-	if (status != SCI_SUCCESS)
-		goto out;
-
-	sci_dev->working_request = sci_req;
-	sci_base_state_machine_change_state(&sci_dev->state_machine,
-					    SCIC_SDS_SMP_REMOTE_DEVICE_READY_SUBSTATE_CMD);
-
- out:
-	scic_sds_remote_device_start_request(sci_dev, sci_req, status);
-
-	return status;
-}
-
-static enum sci_status scic_sds_smp_remote_device_ready_cmd_substate_start_io_handler(
-	struct scic_sds_remote_device *device,
-	struct scic_sds_request *request)
-{
-	/* device is already handling a command it can not accept new commands
-	 * until this one is complete.
-	 */
-	return SCI_FAILURE_INVALID_STATE;
-}
-
 static enum sci_status
 scic_sds_smp_remote_device_ready_cmd_substate_complete_io_handler(struct scic_sds_remote_device *sci_dev,
 								  struct scic_sds_request *sci_req)
@@ -1213,7 +1144,6 @@ static enum sci_status scic_sds_smp_remote_device_ready_cmd_substate_frame_handl
 
 static const struct scic_sds_remote_device_state_handler scic_sds_remote_device_state_handler_table[] = {
 	[SCI_BASE_REMOTE_DEVICE_STATE_INITIAL] = {
-		.start_io_handler	= scic_sds_remote_device_default_start_request_handler,
 		.complete_io_handler	= scic_sds_remote_device_default_complete_request_handler,
 		.continue_io_handler	= scic_sds_remote_device_default_continue_request_handler,
 		.start_task_handler	= scic_sds_remote_device_default_start_request_handler,
@@ -1224,7 +1154,6 @@ static const struct scic_sds_remote_device_state_handler scic_sds_remote_device_
 		.frame_handler		= scic_sds_remote_device_default_frame_handler
 	},
 	[SCI_BASE_REMOTE_DEVICE_STATE_STOPPED] = {
-		.start_io_handler	= scic_sds_remote_device_default_start_request_handler,
 		.complete_io_handler	= scic_sds_remote_device_default_complete_request_handler,
 		.continue_io_handler	= scic_sds_remote_device_default_continue_request_handler,
 		.start_task_handler	= scic_sds_remote_device_default_start_request_handler,
@@ -1235,7 +1164,6 @@ static const struct scic_sds_remote_device_state_handler scic_sds_remote_device_
 		.frame_handler		= scic_sds_remote_device_default_frame_handler
 	},
 	[SCI_BASE_REMOTE_DEVICE_STATE_STARTING] = {
-		.start_io_handler	= scic_sds_remote_device_default_start_request_handler,
 		.complete_io_handler	= scic_sds_remote_device_default_complete_request_handler,
 		.continue_io_handler	= scic_sds_remote_device_default_continue_request_handler,
 		.start_task_handler	= scic_sds_remote_device_default_start_request_handler,
@@ -1246,7 +1174,6 @@ static const struct scic_sds_remote_device_state_handler scic_sds_remote_device_
 		.frame_handler		= scic_sds_remote_device_default_frame_handler
 	},
 	[SCI_BASE_REMOTE_DEVICE_STATE_READY] = {
-		.start_io_handler	= scic_sds_remote_device_ready_state_start_io_handler,
 		.complete_io_handler	= scic_sds_remote_device_ready_state_complete_request_handler,
 		.continue_io_handler	= scic_sds_remote_device_default_continue_request_handler,
 		.start_task_handler	= scic_sds_remote_device_ready_state_start_task_handler,
@@ -1257,7 +1184,6 @@ static const struct scic_sds_remote_device_state_handler scic_sds_remote_device_
 		.frame_handler		= scic_sds_remote_device_general_frame_handler,
 	},
 	[SCIC_SDS_STP_REMOTE_DEVICE_READY_SUBSTATE_IDLE] = {
-		.start_io_handler	= scic_sds_stp_remote_device_ready_idle_substate_start_io_handler,
 		.complete_io_handler	= scic_sds_remote_device_default_complete_request_handler,
 		.continue_io_handler	= scic_sds_remote_device_default_continue_request_handler,
 		.start_task_handler	= scic_sds_stp_remote_device_ready_substate_start_request_handler,
@@ -1268,7 +1194,6 @@ static const struct scic_sds_remote_device_state_handler scic_sds_remote_device_
 		.frame_handler			= scic_sds_remote_device_default_frame_handler
 	},
 	[SCIC_SDS_STP_REMOTE_DEVICE_READY_SUBSTATE_CMD] = {
-		.start_io_handler	= scic_sds_stp_remote_device_ready_cmd_substate_start_io_handler,
 		.complete_io_handler	= scic_sds_stp_remote_device_complete_request,
 		.continue_io_handler	= scic_sds_remote_device_default_continue_request_handler,
 		.start_task_handler	= scic_sds_stp_remote_device_ready_substate_start_request_handler,
@@ -1279,7 +1204,6 @@ static const struct scic_sds_remote_device_state_handler scic_sds_remote_device_
 		.frame_handler			= scic_sds_stp_remote_device_ready_cmd_substate_frame_handler
 	},
 	[SCIC_SDS_STP_REMOTE_DEVICE_READY_SUBSTATE_NCQ] = {
-		.start_io_handler	= scic_sds_stp_remote_device_ready_ncq_substate_start_io_handler,
 		.complete_io_handler	= scic_sds_stp_remote_device_complete_request,
 		.continue_io_handler	= scic_sds_remote_device_default_continue_request_handler,
 		.start_task_handler	= scic_sds_stp_remote_device_ready_substate_start_request_handler,
@@ -1290,7 +1214,6 @@ static const struct scic_sds_remote_device_state_handler scic_sds_remote_device_
 		.frame_handler			= scic_sds_stp_remote_device_ready_ncq_substate_frame_handler
 	},
 	[SCIC_SDS_STP_REMOTE_DEVICE_READY_SUBSTATE_NCQ_ERROR] = {
-		.start_io_handler	= scic_sds_remote_device_default_start_request_handler,
 		.complete_io_handler	= scic_sds_stp_remote_device_complete_request,
 		.continue_io_handler	= scic_sds_remote_device_default_continue_request_handler,
 		.start_task_handler	= scic_sds_stp_remote_device_ready_substate_start_request_handler,
@@ -1301,7 +1224,6 @@ static const struct scic_sds_remote_device_state_handler scic_sds_remote_device_
 		.frame_handler			= scic_sds_remote_device_general_frame_handler
 	},
 	[SCIC_SDS_STP_REMOTE_DEVICE_READY_SUBSTATE_AWAIT_RESET] = {
-		.start_io_handler	= scic_sds_stp_remote_device_ready_await_reset_substate_start_io_handler,
 		.complete_io_handler	= scic_sds_stp_remote_device_ready_await_reset_substate_complete_request_handler,
 		.continue_io_handler	= scic_sds_remote_device_default_continue_request_handler,
 		.start_task_handler	= scic_sds_stp_remote_device_ready_substate_start_request_handler,
@@ -1312,7 +1234,6 @@ static const struct scic_sds_remote_device_state_handler scic_sds_remote_device_
 		.frame_handler			= scic_sds_remote_device_general_frame_handler
 	},
 	[SCIC_SDS_SMP_REMOTE_DEVICE_READY_SUBSTATE_IDLE] = {
-		.start_io_handler	= scic_sds_smp_remote_device_ready_idle_substate_start_io_handler,
 		.complete_io_handler	= scic_sds_remote_device_default_complete_request_handler,
 		.continue_io_handler	= scic_sds_remote_device_default_continue_request_handler,
 		.start_task_handler	= scic_sds_remote_device_default_start_request_handler,
@@ -1323,7 +1244,6 @@ static const struct scic_sds_remote_device_state_handler scic_sds_remote_device_
 		.frame_handler		= scic_sds_remote_device_default_frame_handler
 	},
 	[SCIC_SDS_SMP_REMOTE_DEVICE_READY_SUBSTATE_CMD] = {
-		.start_io_handler	= scic_sds_smp_remote_device_ready_cmd_substate_start_io_handler,
 		.complete_io_handler	= scic_sds_smp_remote_device_ready_cmd_substate_complete_io_handler,
 		.continue_io_handler	= scic_sds_remote_device_default_continue_request_handler,
 		.start_task_handler	= scic_sds_remote_device_default_start_request_handler,
@@ -1334,7 +1254,6 @@ static const struct scic_sds_remote_device_state_handler scic_sds_remote_device_
 		.frame_handler		= scic_sds_smp_remote_device_ready_cmd_substate_frame_handler
 	},
 	[SCI_BASE_REMOTE_DEVICE_STATE_STOPPING] = {
-		.start_io_handler	= scic_sds_remote_device_default_start_request_handler,
 		.complete_io_handler	= scic_sds_remote_device_stopping_state_complete_request_handler,
 		.continue_io_handler	= scic_sds_remote_device_default_continue_request_handler,
 		.start_task_handler	= scic_sds_remote_device_default_start_request_handler,
@@ -1345,7 +1264,6 @@ static const struct scic_sds_remote_device_state_handler scic_sds_remote_device_
 		.frame_handler		= scic_sds_remote_device_general_frame_handler
 	},
 	[SCI_BASE_REMOTE_DEVICE_STATE_FAILED] = {
-		.start_io_handler	= scic_sds_remote_device_default_start_request_handler,
 		.complete_io_handler	= scic_sds_remote_device_default_complete_request_handler,
 		.continue_io_handler	= scic_sds_remote_device_default_continue_request_handler,
 		.start_task_handler	= scic_sds_remote_device_default_start_request_handler,
@@ -1356,7 +1274,6 @@ static const struct scic_sds_remote_device_state_handler scic_sds_remote_device_
 		.frame_handler		= scic_sds_remote_device_general_frame_handler
 	},
 	[SCI_BASE_REMOTE_DEVICE_STATE_RESETTING] = {
-		.start_io_handler	= scic_sds_remote_device_default_start_request_handler,
 		.complete_io_handler	= scic_sds_remote_device_resetting_state_complete_request_handler,
 		.continue_io_handler	= scic_sds_remote_device_default_continue_request_handler,
 		.start_task_handler	= scic_sds_remote_device_default_start_request_handler,
@@ -1367,7 +1284,6 @@ static const struct scic_sds_remote_device_state_handler scic_sds_remote_device_
 		.frame_handler		= scic_sds_remote_device_general_frame_handler
 	},
 	[SCI_BASE_REMOTE_DEVICE_STATE_FINAL] = {
-		.start_io_handler	= scic_sds_remote_device_default_start_request_handler,
 		.complete_io_handler	= scic_sds_remote_device_default_complete_request_handler,
 		.continue_io_handler	= scic_sds_remote_device_default_continue_request_handler,
 		.start_task_handler	= scic_sds_remote_device_default_start_request_handler,

commit 815151826553f875846ebba9696777a424ee62e5
Author: Dan Williams <dan.j.williams@intel.com>
Date:   Sun May 1 14:53:00 2011 -0700

    isci: unify remote_device reset_complete_handlers
    
    Implement all states in scic_remote_device_reset_complete() and delete the
    state handler.
    
    Reported-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/drivers/scsi/isci/remote_device.c b/drivers/scsi/isci/remote_device.c
index d8968f32ad9a..658781dd65e6 100644
--- a/drivers/scsi/isci/remote_device.c
+++ b/drivers/scsi/isci/remote_device.c
@@ -246,15 +246,20 @@ enum sci_status scic_remote_device_reset(struct scic_sds_remote_device *sci_dev)
 	}
 }
 
-
-enum sci_status scic_remote_device_reset_complete(
-	struct scic_sds_remote_device *sci_dev)
+enum sci_status scic_remote_device_reset_complete(struct scic_sds_remote_device *sci_dev)
 {
-	return sci_dev->state_handlers->reset_complete_handler(sci_dev);
-}
+	struct sci_base_state_machine *sm = &sci_dev->state_machine;
+	enum scic_sds_remote_device_states state = sm->current_state_id;
+
+	if (state != SCI_BASE_REMOTE_DEVICE_STATE_RESETTING) {
+		dev_warn(scirdev_to_dev(sci_dev), "%s: in wrong state: %d\n",
+			 __func__, state);
+		return SCI_FAILURE_INVALID_STATE;
+	}
 
-#define SCIC_SDS_REMOTE_DEVICE_MINIMUM_TIMER_COUNT (0)
-#define SCIC_SDS_REMOTE_DEVICE_MAXIMUM_TIMER_COUNT (SCI_MAX_REMOTE_DEVICES)
+	sci_base_state_machine_change_state(sm, SCI_BASE_REMOTE_DEVICE_STATE_READY);
+	return SCI_SUCCESS;
+}
 
 /**
  *
@@ -457,12 +462,6 @@ default_device_handler(struct scic_sds_remote_device *sci_dev,
 	return SCI_FAILURE_INVALID_STATE;
 }
 
-static enum sci_status scic_sds_remote_device_default_reset_complete_handler(
-	struct scic_sds_remote_device *sci_dev)
-{
-	return default_device_handler(sci_dev, __func__);
-}
-
 static enum sci_status scic_sds_remote_device_default_suspend_handler(
 	struct scic_sds_remote_device *sci_dev, u32 suspend_type)
 {
@@ -795,15 +794,6 @@ static enum sci_status scic_sds_remote_device_stopping_state_complete_request_ha
 	return SCI_SUCCESS;
 }
 
-static enum sci_status scic_sds_remote_device_resetting_state_reset_complete_handler(
-	struct scic_sds_remote_device *sci_dev)
-{
-	sci_base_state_machine_change_state(&sci_dev->state_machine,
-					    SCI_BASE_REMOTE_DEVICE_STATE_READY);
-
-	return SCI_SUCCESS;
-}
-
 /* complete requests for this device while it is in the
  * SCI_BASE_REMOTE_DEVICE_STATE_RESETTING state. This method calls the complete
  * method for the request object and if that is successful the port object is
@@ -1223,7 +1213,6 @@ static enum sci_status scic_sds_smp_remote_device_ready_cmd_substate_frame_handl
 
 static const struct scic_sds_remote_device_state_handler scic_sds_remote_device_state_handler_table[] = {
 	[SCI_BASE_REMOTE_DEVICE_STATE_INITIAL] = {
-		.reset_complete_handler	= scic_sds_remote_device_default_reset_complete_handler,
 		.start_io_handler	= scic_sds_remote_device_default_start_request_handler,
 		.complete_io_handler	= scic_sds_remote_device_default_complete_request_handler,
 		.continue_io_handler	= scic_sds_remote_device_default_continue_request_handler,
@@ -1235,7 +1224,6 @@ static const struct scic_sds_remote_device_state_handler scic_sds_remote_device_
 		.frame_handler		= scic_sds_remote_device_default_frame_handler
 	},
 	[SCI_BASE_REMOTE_DEVICE_STATE_STOPPED] = {
-		.reset_complete_handler	= scic_sds_remote_device_default_reset_complete_handler,
 		.start_io_handler	= scic_sds_remote_device_default_start_request_handler,
 		.complete_io_handler	= scic_sds_remote_device_default_complete_request_handler,
 		.continue_io_handler	= scic_sds_remote_device_default_continue_request_handler,
@@ -1247,7 +1235,6 @@ static const struct scic_sds_remote_device_state_handler scic_sds_remote_device_
 		.frame_handler		= scic_sds_remote_device_default_frame_handler
 	},
 	[SCI_BASE_REMOTE_DEVICE_STATE_STARTING] = {
-		.reset_complete_handler	= scic_sds_remote_device_default_reset_complete_handler,
 		.start_io_handler	= scic_sds_remote_device_default_start_request_handler,
 		.complete_io_handler	= scic_sds_remote_device_default_complete_request_handler,
 		.continue_io_handler	= scic_sds_remote_device_default_continue_request_handler,
@@ -1259,7 +1246,6 @@ static const struct scic_sds_remote_device_state_handler scic_sds_remote_device_
 		.frame_handler		= scic_sds_remote_device_default_frame_handler
 	},
 	[SCI_BASE_REMOTE_DEVICE_STATE_READY] = {
-		.reset_complete_handler	= scic_sds_remote_device_default_reset_complete_handler,
 		.start_io_handler	= scic_sds_remote_device_ready_state_start_io_handler,
 		.complete_io_handler	= scic_sds_remote_device_ready_state_complete_request_handler,
 		.continue_io_handler	= scic_sds_remote_device_default_continue_request_handler,
@@ -1271,7 +1257,6 @@ static const struct scic_sds_remote_device_state_handler scic_sds_remote_device_
 		.frame_handler		= scic_sds_remote_device_general_frame_handler,
 	},
 	[SCIC_SDS_STP_REMOTE_DEVICE_READY_SUBSTATE_IDLE] = {
-		.reset_complete_handler	= scic_sds_remote_device_default_reset_complete_handler,
 		.start_io_handler	= scic_sds_stp_remote_device_ready_idle_substate_start_io_handler,
 		.complete_io_handler	= scic_sds_remote_device_default_complete_request_handler,
 		.continue_io_handler	= scic_sds_remote_device_default_continue_request_handler,
@@ -1283,7 +1268,6 @@ static const struct scic_sds_remote_device_state_handler scic_sds_remote_device_
 		.frame_handler			= scic_sds_remote_device_default_frame_handler
 	},
 	[SCIC_SDS_STP_REMOTE_DEVICE_READY_SUBSTATE_CMD] = {
-		.reset_complete_handler	= scic_sds_remote_device_default_reset_complete_handler,
 		.start_io_handler	= scic_sds_stp_remote_device_ready_cmd_substate_start_io_handler,
 		.complete_io_handler	= scic_sds_stp_remote_device_complete_request,
 		.continue_io_handler	= scic_sds_remote_device_default_continue_request_handler,
@@ -1295,7 +1279,6 @@ static const struct scic_sds_remote_device_state_handler scic_sds_remote_device_
 		.frame_handler			= scic_sds_stp_remote_device_ready_cmd_substate_frame_handler
 	},
 	[SCIC_SDS_STP_REMOTE_DEVICE_READY_SUBSTATE_NCQ] = {
-		.reset_complete_handler	= scic_sds_remote_device_default_reset_complete_handler,
 		.start_io_handler	= scic_sds_stp_remote_device_ready_ncq_substate_start_io_handler,
 		.complete_io_handler	= scic_sds_stp_remote_device_complete_request,
 		.continue_io_handler	= scic_sds_remote_device_default_continue_request_handler,
@@ -1307,7 +1290,6 @@ static const struct scic_sds_remote_device_state_handler scic_sds_remote_device_
 		.frame_handler			= scic_sds_stp_remote_device_ready_ncq_substate_frame_handler
 	},
 	[SCIC_SDS_STP_REMOTE_DEVICE_READY_SUBSTATE_NCQ_ERROR] = {
-		.reset_complete_handler	= scic_sds_remote_device_default_reset_complete_handler,
 		.start_io_handler	= scic_sds_remote_device_default_start_request_handler,
 		.complete_io_handler	= scic_sds_stp_remote_device_complete_request,
 		.continue_io_handler	= scic_sds_remote_device_default_continue_request_handler,
@@ -1319,7 +1301,6 @@ static const struct scic_sds_remote_device_state_handler scic_sds_remote_device_
 		.frame_handler			= scic_sds_remote_device_general_frame_handler
 	},
 	[SCIC_SDS_STP_REMOTE_DEVICE_READY_SUBSTATE_AWAIT_RESET] = {
-		.reset_complete_handler	= scic_sds_remote_device_default_reset_complete_handler,
 		.start_io_handler	= scic_sds_stp_remote_device_ready_await_reset_substate_start_io_handler,
 		.complete_io_handler	= scic_sds_stp_remote_device_ready_await_reset_substate_complete_request_handler,
 		.continue_io_handler	= scic_sds_remote_device_default_continue_request_handler,
@@ -1331,7 +1312,6 @@ static const struct scic_sds_remote_device_state_handler scic_sds_remote_device_
 		.frame_handler			= scic_sds_remote_device_general_frame_handler
 	},
 	[SCIC_SDS_SMP_REMOTE_DEVICE_READY_SUBSTATE_IDLE] = {
-		.reset_complete_handler	= scic_sds_remote_device_default_reset_complete_handler,
 		.start_io_handler	= scic_sds_smp_remote_device_ready_idle_substate_start_io_handler,
 		.complete_io_handler	= scic_sds_remote_device_default_complete_request_handler,
 		.continue_io_handler	= scic_sds_remote_device_default_continue_request_handler,
@@ -1343,7 +1323,6 @@ static const struct scic_sds_remote_device_state_handler scic_sds_remote_device_
 		.frame_handler		= scic_sds_remote_device_default_frame_handler
 	},
 	[SCIC_SDS_SMP_REMOTE_DEVICE_READY_SUBSTATE_CMD] = {
-		.reset_complete_handler	= scic_sds_remote_device_default_reset_complete_handler,
 		.start_io_handler	= scic_sds_smp_remote_device_ready_cmd_substate_start_io_handler,
 		.complete_io_handler	= scic_sds_smp_remote_device_ready_cmd_substate_complete_io_handler,
 		.continue_io_handler	= scic_sds_remote_device_default_continue_request_handler,
@@ -1355,7 +1334,6 @@ static const struct scic_sds_remote_device_state_handler scic_sds_remote_device_
 		.frame_handler		= scic_sds_smp_remote_device_ready_cmd_substate_frame_handler
 	},
 	[SCI_BASE_REMOTE_DEVICE_STATE_STOPPING] = {
-		.reset_complete_handler	= scic_sds_remote_device_default_reset_complete_handler,
 		.start_io_handler	= scic_sds_remote_device_default_start_request_handler,
 		.complete_io_handler	= scic_sds_remote_device_stopping_state_complete_request_handler,
 		.continue_io_handler	= scic_sds_remote_device_default_continue_request_handler,
@@ -1367,7 +1345,6 @@ static const struct scic_sds_remote_device_state_handler scic_sds_remote_device_
 		.frame_handler		= scic_sds_remote_device_general_frame_handler
 	},
 	[SCI_BASE_REMOTE_DEVICE_STATE_FAILED] = {
-		.reset_complete_handler	= scic_sds_remote_device_default_reset_complete_handler,
 		.start_io_handler	= scic_sds_remote_device_default_start_request_handler,
 		.complete_io_handler	= scic_sds_remote_device_default_complete_request_handler,
 		.continue_io_handler	= scic_sds_remote_device_default_continue_request_handler,
@@ -1379,7 +1356,6 @@ static const struct scic_sds_remote_device_state_handler scic_sds_remote_device_
 		.frame_handler		= scic_sds_remote_device_general_frame_handler
 	},
 	[SCI_BASE_REMOTE_DEVICE_STATE_RESETTING] = {
-		.reset_complete_handler	= scic_sds_remote_device_resetting_state_reset_complete_handler,
 		.start_io_handler	= scic_sds_remote_device_default_start_request_handler,
 		.complete_io_handler	= scic_sds_remote_device_resetting_state_complete_request_handler,
 		.continue_io_handler	= scic_sds_remote_device_default_continue_request_handler,
@@ -1391,7 +1367,6 @@ static const struct scic_sds_remote_device_state_handler scic_sds_remote_device_
 		.frame_handler		= scic_sds_remote_device_general_frame_handler
 	},
 	[SCI_BASE_REMOTE_DEVICE_STATE_FINAL] = {
-		.reset_complete_handler	= scic_sds_remote_device_default_reset_complete_handler,
 		.start_io_handler	= scic_sds_remote_device_default_start_request_handler,
 		.complete_io_handler	= scic_sds_remote_device_default_complete_request_handler,
 		.continue_io_handler	= scic_sds_remote_device_default_continue_request_handler,

commit 4fd0d2e9bf5152456952ad7c5b6f3d8565de7737
Author: Dan Williams <dan.j.williams@intel.com>
Date:   Sun May 1 14:48:54 2011 -0700

    isci: unify remote_device reset_handlers
    
    Implement all states in scic_remote_device_reset() and delete the state
    handler.
    
    Reported-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/drivers/scsi/isci/remote_device.c b/drivers/scsi/isci/remote_device.c
index dd66c0e8ac27..d8968f32ad9a 100644
--- a/drivers/scsi/isci/remote_device.c
+++ b/drivers/scsi/isci/remote_device.c
@@ -216,11 +216,34 @@ enum sci_status scic_remote_device_stop(struct scic_sds_remote_device *sci_dev,
 	}
 }
 
-
-enum sci_status scic_remote_device_reset(
-	struct scic_sds_remote_device *sci_dev)
+enum sci_status scic_remote_device_reset(struct scic_sds_remote_device *sci_dev)
 {
-	return sci_dev->state_handlers->reset_handler(sci_dev);
+	struct sci_base_state_machine *sm = &sci_dev->state_machine;
+	enum scic_sds_remote_device_states state = sm->current_state_id;
+
+	switch (state) {
+	case SCI_BASE_REMOTE_DEVICE_STATE_INITIAL:
+	case SCI_BASE_REMOTE_DEVICE_STATE_STOPPED:
+	case SCI_BASE_REMOTE_DEVICE_STATE_STARTING:
+	case SCIC_SDS_SMP_REMOTE_DEVICE_READY_SUBSTATE_IDLE:
+	case SCIC_SDS_SMP_REMOTE_DEVICE_READY_SUBSTATE_CMD:
+	case SCI_BASE_REMOTE_DEVICE_STATE_STOPPING:
+	case SCI_BASE_REMOTE_DEVICE_STATE_FAILED:
+	case SCI_BASE_REMOTE_DEVICE_STATE_RESETTING:
+	case SCI_BASE_REMOTE_DEVICE_STATE_FINAL:
+	default:
+		dev_warn(scirdev_to_dev(sci_dev), "%s: in wrong state: %d\n",
+			 __func__, state);
+		return SCI_FAILURE_INVALID_STATE;
+	case SCI_BASE_REMOTE_DEVICE_STATE_READY:
+	case SCIC_SDS_STP_REMOTE_DEVICE_READY_SUBSTATE_IDLE:
+	case SCIC_SDS_STP_REMOTE_DEVICE_READY_SUBSTATE_CMD:
+	case SCIC_SDS_STP_REMOTE_DEVICE_READY_SUBSTATE_NCQ:
+	case SCIC_SDS_STP_REMOTE_DEVICE_READY_SUBSTATE_NCQ_ERROR:
+	case SCIC_SDS_STP_REMOTE_DEVICE_READY_SUBSTATE_AWAIT_RESET:
+		sci_base_state_machine_change_state(sm, SCI_BASE_REMOTE_DEVICE_STATE_RESETTING);
+		return SCI_SUCCESS;
+	}
 }
 
 
@@ -434,12 +457,6 @@ default_device_handler(struct scic_sds_remote_device *sci_dev,
 	return SCI_FAILURE_INVALID_STATE;
 }
 
-static enum sci_status scic_sds_remote_device_default_reset_handler(
-	struct scic_sds_remote_device *sci_dev)
-{
-	return default_device_handler(sci_dev, __func__);
-}
-
 static enum sci_status scic_sds_remote_device_default_reset_complete_handler(
 	struct scic_sds_remote_device *sci_dev)
 {
@@ -653,23 +670,6 @@ static enum sci_status scic_sds_remote_device_general_event_handler(
 							  true);
 }
 
-/**
- *
- * @device: The struct scic_sds_remote_device object which is cast to a
- *    struct scic_sds_remote_device object.
- *
- * This is the ready state device reset handler enum sci_status
- */
-static enum sci_status scic_sds_remote_device_ready_state_reset_handler(
-	struct scic_sds_remote_device *sci_dev)
-{
-	/* Request the parent state machine to transition to the stopping state */
-	sci_base_state_machine_change_state(&sci_dev->state_machine,
-					    SCI_BASE_REMOTE_DEVICE_STATE_RESETTING);
-
-	return SCI_SUCCESS;
-}
-
 /*
  * This method will attempt to start a task request for this device object. The
  * remote device object will issue the start request for the task and if
@@ -1223,7 +1223,6 @@ static enum sci_status scic_sds_smp_remote_device_ready_cmd_substate_frame_handl
 
 static const struct scic_sds_remote_device_state_handler scic_sds_remote_device_state_handler_table[] = {
 	[SCI_BASE_REMOTE_DEVICE_STATE_INITIAL] = {
-		.reset_handler		= scic_sds_remote_device_default_reset_handler,
 		.reset_complete_handler	= scic_sds_remote_device_default_reset_complete_handler,
 		.start_io_handler	= scic_sds_remote_device_default_start_request_handler,
 		.complete_io_handler	= scic_sds_remote_device_default_complete_request_handler,
@@ -1236,7 +1235,6 @@ static const struct scic_sds_remote_device_state_handler scic_sds_remote_device_
 		.frame_handler		= scic_sds_remote_device_default_frame_handler
 	},
 	[SCI_BASE_REMOTE_DEVICE_STATE_STOPPED] = {
-		.reset_handler		= scic_sds_remote_device_default_reset_handler,
 		.reset_complete_handler	= scic_sds_remote_device_default_reset_complete_handler,
 		.start_io_handler	= scic_sds_remote_device_default_start_request_handler,
 		.complete_io_handler	= scic_sds_remote_device_default_complete_request_handler,
@@ -1249,7 +1247,6 @@ static const struct scic_sds_remote_device_state_handler scic_sds_remote_device_
 		.frame_handler		= scic_sds_remote_device_default_frame_handler
 	},
 	[SCI_BASE_REMOTE_DEVICE_STATE_STARTING] = {
-		.reset_handler		= scic_sds_remote_device_default_reset_handler,
 		.reset_complete_handler	= scic_sds_remote_device_default_reset_complete_handler,
 		.start_io_handler	= scic_sds_remote_device_default_start_request_handler,
 		.complete_io_handler	= scic_sds_remote_device_default_complete_request_handler,
@@ -1262,7 +1259,6 @@ static const struct scic_sds_remote_device_state_handler scic_sds_remote_device_
 		.frame_handler		= scic_sds_remote_device_default_frame_handler
 	},
 	[SCI_BASE_REMOTE_DEVICE_STATE_READY] = {
-		.reset_handler		= scic_sds_remote_device_ready_state_reset_handler,
 		.reset_complete_handler	= scic_sds_remote_device_default_reset_complete_handler,
 		.start_io_handler	= scic_sds_remote_device_ready_state_start_io_handler,
 		.complete_io_handler	= scic_sds_remote_device_ready_state_complete_request_handler,
@@ -1275,7 +1271,6 @@ static const struct scic_sds_remote_device_state_handler scic_sds_remote_device_
 		.frame_handler		= scic_sds_remote_device_general_frame_handler,
 	},
 	[SCIC_SDS_STP_REMOTE_DEVICE_READY_SUBSTATE_IDLE] = {
-		.reset_handler		= scic_sds_remote_device_ready_state_reset_handler,
 		.reset_complete_handler	= scic_sds_remote_device_default_reset_complete_handler,
 		.start_io_handler	= scic_sds_stp_remote_device_ready_idle_substate_start_io_handler,
 		.complete_io_handler	= scic_sds_remote_device_default_complete_request_handler,
@@ -1288,7 +1283,6 @@ static const struct scic_sds_remote_device_state_handler scic_sds_remote_device_
 		.frame_handler			= scic_sds_remote_device_default_frame_handler
 	},
 	[SCIC_SDS_STP_REMOTE_DEVICE_READY_SUBSTATE_CMD] = {
-		.reset_handler		= scic_sds_remote_device_ready_state_reset_handler,
 		.reset_complete_handler	= scic_sds_remote_device_default_reset_complete_handler,
 		.start_io_handler	= scic_sds_stp_remote_device_ready_cmd_substate_start_io_handler,
 		.complete_io_handler	= scic_sds_stp_remote_device_complete_request,
@@ -1301,7 +1295,6 @@ static const struct scic_sds_remote_device_state_handler scic_sds_remote_device_
 		.frame_handler			= scic_sds_stp_remote_device_ready_cmd_substate_frame_handler
 	},
 	[SCIC_SDS_STP_REMOTE_DEVICE_READY_SUBSTATE_NCQ] = {
-		.reset_handler		= scic_sds_remote_device_ready_state_reset_handler,
 		.reset_complete_handler	= scic_sds_remote_device_default_reset_complete_handler,
 		.start_io_handler	= scic_sds_stp_remote_device_ready_ncq_substate_start_io_handler,
 		.complete_io_handler	= scic_sds_stp_remote_device_complete_request,
@@ -1314,7 +1307,6 @@ static const struct scic_sds_remote_device_state_handler scic_sds_remote_device_
 		.frame_handler			= scic_sds_stp_remote_device_ready_ncq_substate_frame_handler
 	},
 	[SCIC_SDS_STP_REMOTE_DEVICE_READY_SUBSTATE_NCQ_ERROR] = {
-		.reset_handler		= scic_sds_remote_device_ready_state_reset_handler,
 		.reset_complete_handler	= scic_sds_remote_device_default_reset_complete_handler,
 		.start_io_handler	= scic_sds_remote_device_default_start_request_handler,
 		.complete_io_handler	= scic_sds_stp_remote_device_complete_request,
@@ -1327,7 +1319,6 @@ static const struct scic_sds_remote_device_state_handler scic_sds_remote_device_
 		.frame_handler			= scic_sds_remote_device_general_frame_handler
 	},
 	[SCIC_SDS_STP_REMOTE_DEVICE_READY_SUBSTATE_AWAIT_RESET] = {
-		.reset_handler		= scic_sds_remote_device_ready_state_reset_handler,
 		.reset_complete_handler	= scic_sds_remote_device_default_reset_complete_handler,
 		.start_io_handler	= scic_sds_stp_remote_device_ready_await_reset_substate_start_io_handler,
 		.complete_io_handler	= scic_sds_stp_remote_device_ready_await_reset_substate_complete_request_handler,
@@ -1340,7 +1331,6 @@ static const struct scic_sds_remote_device_state_handler scic_sds_remote_device_
 		.frame_handler			= scic_sds_remote_device_general_frame_handler
 	},
 	[SCIC_SDS_SMP_REMOTE_DEVICE_READY_SUBSTATE_IDLE] = {
-		.reset_handler		= scic_sds_remote_device_default_reset_handler,
 		.reset_complete_handler	= scic_sds_remote_device_default_reset_complete_handler,
 		.start_io_handler	= scic_sds_smp_remote_device_ready_idle_substate_start_io_handler,
 		.complete_io_handler	= scic_sds_remote_device_default_complete_request_handler,
@@ -1353,7 +1343,6 @@ static const struct scic_sds_remote_device_state_handler scic_sds_remote_device_
 		.frame_handler		= scic_sds_remote_device_default_frame_handler
 	},
 	[SCIC_SDS_SMP_REMOTE_DEVICE_READY_SUBSTATE_CMD] = {
-		.reset_handler		= scic_sds_remote_device_default_reset_handler,
 		.reset_complete_handler	= scic_sds_remote_device_default_reset_complete_handler,
 		.start_io_handler	= scic_sds_smp_remote_device_ready_cmd_substate_start_io_handler,
 		.complete_io_handler	= scic_sds_smp_remote_device_ready_cmd_substate_complete_io_handler,
@@ -1366,7 +1355,6 @@ static const struct scic_sds_remote_device_state_handler scic_sds_remote_device_
 		.frame_handler		= scic_sds_smp_remote_device_ready_cmd_substate_frame_handler
 	},
 	[SCI_BASE_REMOTE_DEVICE_STATE_STOPPING] = {
-		.reset_handler		= scic_sds_remote_device_default_reset_handler,
 		.reset_complete_handler	= scic_sds_remote_device_default_reset_complete_handler,
 		.start_io_handler	= scic_sds_remote_device_default_start_request_handler,
 		.complete_io_handler	= scic_sds_remote_device_stopping_state_complete_request_handler,
@@ -1379,7 +1367,6 @@ static const struct scic_sds_remote_device_state_handler scic_sds_remote_device_
 		.frame_handler		= scic_sds_remote_device_general_frame_handler
 	},
 	[SCI_BASE_REMOTE_DEVICE_STATE_FAILED] = {
-		.reset_handler		= scic_sds_remote_device_default_reset_handler,
 		.reset_complete_handler	= scic_sds_remote_device_default_reset_complete_handler,
 		.start_io_handler	= scic_sds_remote_device_default_start_request_handler,
 		.complete_io_handler	= scic_sds_remote_device_default_complete_request_handler,
@@ -1392,7 +1379,6 @@ static const struct scic_sds_remote_device_state_handler scic_sds_remote_device_
 		.frame_handler		= scic_sds_remote_device_general_frame_handler
 	},
 	[SCI_BASE_REMOTE_DEVICE_STATE_RESETTING] = {
-		.reset_handler		= scic_sds_remote_device_default_reset_handler,
 		.reset_complete_handler	= scic_sds_remote_device_resetting_state_reset_complete_handler,
 		.start_io_handler	= scic_sds_remote_device_default_start_request_handler,
 		.complete_io_handler	= scic_sds_remote_device_resetting_state_complete_request_handler,
@@ -1405,7 +1391,6 @@ static const struct scic_sds_remote_device_state_handler scic_sds_remote_device_
 		.frame_handler		= scic_sds_remote_device_general_frame_handler
 	},
 	[SCI_BASE_REMOTE_DEVICE_STATE_FINAL] = {
-		.reset_handler		= scic_sds_remote_device_default_reset_handler,
 		.reset_complete_handler	= scic_sds_remote_device_default_reset_complete_handler,
 		.start_io_handler	= scic_sds_remote_device_default_start_request_handler,
 		.complete_io_handler	= scic_sds_remote_device_default_complete_request_handler,

commit b8d82f6cdd0f04ddfa877d8d886e56ebd8526d25
Author: Dan Williams <dan.j.williams@intel.com>
Date:   Sun May 1 14:38:26 2011 -0700

    isci: unify remote_device destruct_handlers
    
    Implement all states in scic_remote_device_destruct() and delete the state
    handler.
    
    Reported-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/drivers/scsi/isci/remote_device.c b/drivers/scsi/isci/remote_device.c
index 5141a924149c..dd66c0e8ac27 100644
--- a/drivers/scsi/isci/remote_device.c
+++ b/drivers/scsi/isci/remote_device.c
@@ -434,12 +434,6 @@ default_device_handler(struct scic_sds_remote_device *sci_dev,
 	return SCI_FAILURE_INVALID_STATE;
 }
 
-static enum sci_status scic_sds_remote_device_default_destruct_handler(
-	struct scic_sds_remote_device *sci_dev)
-{
-	return default_device_handler(sci_dev, __func__);
-}
-
 static enum sci_status scic_sds_remote_device_default_reset_handler(
 	struct scic_sds_remote_device *sci_dev)
 {
@@ -659,33 +653,6 @@ static enum sci_status scic_sds_remote_device_general_event_handler(
 							  true);
 }
 
-/**
- *
- * @sci_dev: The struct scic_sds_remote_device which is cast into a
- *    struct scic_sds_remote_device.
- *
- * This method will destruct a struct scic_sds_remote_device that is in a stopped
- * state.  This is the only state from which a destruct request will succeed.
- * The RNi for this struct scic_sds_remote_device is returned to the free pool and the
- * device object transitions to the SCI_BASE_REMOTE_DEVICE_STATE_FINAL.
- * enum sci_status SCI_SUCCESS
- */
-static enum sci_status scic_sds_remote_device_stopped_state_destruct_handler(
-	struct scic_sds_remote_device *sci_dev)
-{
-	struct scic_sds_controller *scic;
-
-	scic = scic_sds_remote_device_get_controller(sci_dev);
-	scic_sds_controller_free_remote_node_context(scic, sci_dev,
-						     sci_dev->rnc.remote_node_index);
-	sci_dev->rnc.remote_node_index = SCIC_SDS_REMOTE_NODE_CONTEXT_INVALID_INDEX;
-
-	sci_base_state_machine_change_state(&sci_dev->state_machine,
-					    SCI_BASE_REMOTE_DEVICE_STATE_FINAL);
-
-	return SCI_SUCCESS;
-}
-
 /**
  *
  * @device: The struct scic_sds_remote_device object which is cast to a
@@ -1256,7 +1223,6 @@ static enum sci_status scic_sds_smp_remote_device_ready_cmd_substate_frame_handl
 
 static const struct scic_sds_remote_device_state_handler scic_sds_remote_device_state_handler_table[] = {
 	[SCI_BASE_REMOTE_DEVICE_STATE_INITIAL] = {
-		.destruct_handler	= scic_sds_remote_device_default_destruct_handler,
 		.reset_handler		= scic_sds_remote_device_default_reset_handler,
 		.reset_complete_handler	= scic_sds_remote_device_default_reset_complete_handler,
 		.start_io_handler	= scic_sds_remote_device_default_start_request_handler,
@@ -1270,7 +1236,6 @@ static const struct scic_sds_remote_device_state_handler scic_sds_remote_device_
 		.frame_handler		= scic_sds_remote_device_default_frame_handler
 	},
 	[SCI_BASE_REMOTE_DEVICE_STATE_STOPPED] = {
-		.destruct_handler	= scic_sds_remote_device_stopped_state_destruct_handler,
 		.reset_handler		= scic_sds_remote_device_default_reset_handler,
 		.reset_complete_handler	= scic_sds_remote_device_default_reset_complete_handler,
 		.start_io_handler	= scic_sds_remote_device_default_start_request_handler,
@@ -1284,7 +1249,6 @@ static const struct scic_sds_remote_device_state_handler scic_sds_remote_device_
 		.frame_handler		= scic_sds_remote_device_default_frame_handler
 	},
 	[SCI_BASE_REMOTE_DEVICE_STATE_STARTING] = {
-		.destruct_handler	= scic_sds_remote_device_default_destruct_handler,
 		.reset_handler		= scic_sds_remote_device_default_reset_handler,
 		.reset_complete_handler	= scic_sds_remote_device_default_reset_complete_handler,
 		.start_io_handler	= scic_sds_remote_device_default_start_request_handler,
@@ -1298,7 +1262,6 @@ static const struct scic_sds_remote_device_state_handler scic_sds_remote_device_
 		.frame_handler		= scic_sds_remote_device_default_frame_handler
 	},
 	[SCI_BASE_REMOTE_DEVICE_STATE_READY] = {
-		.destruct_handler	= scic_sds_remote_device_default_destruct_handler,
 		.reset_handler		= scic_sds_remote_device_ready_state_reset_handler,
 		.reset_complete_handler	= scic_sds_remote_device_default_reset_complete_handler,
 		.start_io_handler	= scic_sds_remote_device_ready_state_start_io_handler,
@@ -1312,7 +1275,6 @@ static const struct scic_sds_remote_device_state_handler scic_sds_remote_device_
 		.frame_handler		= scic_sds_remote_device_general_frame_handler,
 	},
 	[SCIC_SDS_STP_REMOTE_DEVICE_READY_SUBSTATE_IDLE] = {
-		.destruct_handler	= scic_sds_remote_device_default_destruct_handler,
 		.reset_handler		= scic_sds_remote_device_ready_state_reset_handler,
 		.reset_complete_handler	= scic_sds_remote_device_default_reset_complete_handler,
 		.start_io_handler	= scic_sds_stp_remote_device_ready_idle_substate_start_io_handler,
@@ -1326,7 +1288,6 @@ static const struct scic_sds_remote_device_state_handler scic_sds_remote_device_
 		.frame_handler			= scic_sds_remote_device_default_frame_handler
 	},
 	[SCIC_SDS_STP_REMOTE_DEVICE_READY_SUBSTATE_CMD] = {
-		.destruct_handler	= scic_sds_remote_device_default_destruct_handler,
 		.reset_handler		= scic_sds_remote_device_ready_state_reset_handler,
 		.reset_complete_handler	= scic_sds_remote_device_default_reset_complete_handler,
 		.start_io_handler	= scic_sds_stp_remote_device_ready_cmd_substate_start_io_handler,
@@ -1340,7 +1301,6 @@ static const struct scic_sds_remote_device_state_handler scic_sds_remote_device_
 		.frame_handler			= scic_sds_stp_remote_device_ready_cmd_substate_frame_handler
 	},
 	[SCIC_SDS_STP_REMOTE_DEVICE_READY_SUBSTATE_NCQ] = {
-		.destruct_handler	= scic_sds_remote_device_default_destruct_handler,
 		.reset_handler		= scic_sds_remote_device_ready_state_reset_handler,
 		.reset_complete_handler	= scic_sds_remote_device_default_reset_complete_handler,
 		.start_io_handler	= scic_sds_stp_remote_device_ready_ncq_substate_start_io_handler,
@@ -1354,7 +1314,6 @@ static const struct scic_sds_remote_device_state_handler scic_sds_remote_device_
 		.frame_handler			= scic_sds_stp_remote_device_ready_ncq_substate_frame_handler
 	},
 	[SCIC_SDS_STP_REMOTE_DEVICE_READY_SUBSTATE_NCQ_ERROR] = {
-		.destruct_handler	= scic_sds_remote_device_default_destruct_handler,
 		.reset_handler		= scic_sds_remote_device_ready_state_reset_handler,
 		.reset_complete_handler	= scic_sds_remote_device_default_reset_complete_handler,
 		.start_io_handler	= scic_sds_remote_device_default_start_request_handler,
@@ -1368,7 +1327,6 @@ static const struct scic_sds_remote_device_state_handler scic_sds_remote_device_
 		.frame_handler			= scic_sds_remote_device_general_frame_handler
 	},
 	[SCIC_SDS_STP_REMOTE_DEVICE_READY_SUBSTATE_AWAIT_RESET] = {
-		.destruct_handler	= scic_sds_remote_device_default_destruct_handler,
 		.reset_handler		= scic_sds_remote_device_ready_state_reset_handler,
 		.reset_complete_handler	= scic_sds_remote_device_default_reset_complete_handler,
 		.start_io_handler	= scic_sds_stp_remote_device_ready_await_reset_substate_start_io_handler,
@@ -1382,7 +1340,6 @@ static const struct scic_sds_remote_device_state_handler scic_sds_remote_device_
 		.frame_handler			= scic_sds_remote_device_general_frame_handler
 	},
 	[SCIC_SDS_SMP_REMOTE_DEVICE_READY_SUBSTATE_IDLE] = {
-		.destruct_handler	= scic_sds_remote_device_default_destruct_handler,
 		.reset_handler		= scic_sds_remote_device_default_reset_handler,
 		.reset_complete_handler	= scic_sds_remote_device_default_reset_complete_handler,
 		.start_io_handler	= scic_sds_smp_remote_device_ready_idle_substate_start_io_handler,
@@ -1396,7 +1353,6 @@ static const struct scic_sds_remote_device_state_handler scic_sds_remote_device_
 		.frame_handler		= scic_sds_remote_device_default_frame_handler
 	},
 	[SCIC_SDS_SMP_REMOTE_DEVICE_READY_SUBSTATE_CMD] = {
-		.destruct_handler	= scic_sds_remote_device_default_destruct_handler,
 		.reset_handler		= scic_sds_remote_device_default_reset_handler,
 		.reset_complete_handler	= scic_sds_remote_device_default_reset_complete_handler,
 		.start_io_handler	= scic_sds_smp_remote_device_ready_cmd_substate_start_io_handler,
@@ -1410,7 +1366,6 @@ static const struct scic_sds_remote_device_state_handler scic_sds_remote_device_
 		.frame_handler		= scic_sds_smp_remote_device_ready_cmd_substate_frame_handler
 	},
 	[SCI_BASE_REMOTE_DEVICE_STATE_STOPPING] = {
-		.destruct_handler	= scic_sds_remote_device_default_destruct_handler,
 		.reset_handler		= scic_sds_remote_device_default_reset_handler,
 		.reset_complete_handler	= scic_sds_remote_device_default_reset_complete_handler,
 		.start_io_handler	= scic_sds_remote_device_default_start_request_handler,
@@ -1424,7 +1379,6 @@ static const struct scic_sds_remote_device_state_handler scic_sds_remote_device_
 		.frame_handler		= scic_sds_remote_device_general_frame_handler
 	},
 	[SCI_BASE_REMOTE_DEVICE_STATE_FAILED] = {
-		.destruct_handler	= scic_sds_remote_device_default_destruct_handler,
 		.reset_handler		= scic_sds_remote_device_default_reset_handler,
 		.reset_complete_handler	= scic_sds_remote_device_default_reset_complete_handler,
 		.start_io_handler	= scic_sds_remote_device_default_start_request_handler,
@@ -1438,7 +1392,6 @@ static const struct scic_sds_remote_device_state_handler scic_sds_remote_device_
 		.frame_handler		= scic_sds_remote_device_general_frame_handler
 	},
 	[SCI_BASE_REMOTE_DEVICE_STATE_RESETTING] = {
-		.destruct_handler	= scic_sds_remote_device_default_destruct_handler,
 		.reset_handler		= scic_sds_remote_device_default_reset_handler,
 		.reset_complete_handler	= scic_sds_remote_device_resetting_state_reset_complete_handler,
 		.start_io_handler	= scic_sds_remote_device_default_start_request_handler,
@@ -1452,7 +1405,6 @@ static const struct scic_sds_remote_device_state_handler scic_sds_remote_device_
 		.frame_handler		= scic_sds_remote_device_general_frame_handler
 	},
 	[SCI_BASE_REMOTE_DEVICE_STATE_FINAL] = {
-		.destruct_handler	= scic_sds_remote_device_default_destruct_handler,
 		.reset_handler		= scic_sds_remote_device_default_reset_handler,
 		.reset_complete_handler	= scic_sds_remote_device_default_reset_complete_handler,
 		.start_io_handler	= scic_sds_remote_device_default_start_request_handler,
@@ -1494,7 +1446,23 @@ static void scic_sds_remote_device_initial_state_enter(void *object)
  */
 static enum sci_status scic_remote_device_destruct(struct scic_sds_remote_device *sci_dev)
 {
-	return sci_dev->state_handlers->destruct_handler(sci_dev);
+	struct sci_base_state_machine *sm = &sci_dev->state_machine;
+	enum scic_sds_remote_device_states state = sm->current_state_id;
+	struct scic_sds_controller *scic;
+
+	if (state != SCI_BASE_REMOTE_DEVICE_STATE_STOPPED) {
+		dev_warn(scirdev_to_dev(sci_dev), "%s: in wrong state: %d\n",
+			 __func__, state);
+		return SCI_FAILURE_INVALID_STATE;
+	}
+
+	scic = sci_dev->owning_port->owning_controller;
+	scic_sds_controller_free_remote_node_context(scic, sci_dev,
+						     sci_dev->rnc.remote_node_index);
+	sci_dev->rnc.remote_node_index = SCIC_SDS_REMOTE_NODE_CONTEXT_INVALID_INDEX;
+	sci_base_state_machine_change_state(sm, SCI_BASE_REMOTE_DEVICE_STATE_FINAL);
+
+	return SCI_SUCCESS;
 }
 
 /**

commit 1a6de2562b38e1e0e74c468554111ac54c062928
Author: Dan Williams <dan.j.williams@intel.com>
Date:   Sun May 1 14:35:43 2011 -0700

    isci: kill remote_device fail_handler
    
    This is just unused infrastructure.
    
    Reported-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/drivers/scsi/isci/remote_device.c b/drivers/scsi/isci/remote_device.c
index d779939a6175..5141a924149c 100644
--- a/drivers/scsi/isci/remote_device.c
+++ b/drivers/scsi/isci/remote_device.c
@@ -434,12 +434,6 @@ default_device_handler(struct scic_sds_remote_device *sci_dev,
 	return SCI_FAILURE_INVALID_STATE;
 }
 
-static enum sci_status scic_sds_remote_device_default_fail_handler(
-	struct scic_sds_remote_device *sci_dev)
-{
-	return default_device_handler(sci_dev, __func__);
-}
-
 static enum sci_status scic_sds_remote_device_default_destruct_handler(
 	struct scic_sds_remote_device *sci_dev)
 {
@@ -1262,7 +1256,6 @@ static enum sci_status scic_sds_smp_remote_device_ready_cmd_substate_frame_handl
 
 static const struct scic_sds_remote_device_state_handler scic_sds_remote_device_state_handler_table[] = {
 	[SCI_BASE_REMOTE_DEVICE_STATE_INITIAL] = {
-		.fail_handler		= scic_sds_remote_device_default_fail_handler,
 		.destruct_handler	= scic_sds_remote_device_default_destruct_handler,
 		.reset_handler		= scic_sds_remote_device_default_reset_handler,
 		.reset_complete_handler	= scic_sds_remote_device_default_reset_complete_handler,
@@ -1277,7 +1270,6 @@ static const struct scic_sds_remote_device_state_handler scic_sds_remote_device_
 		.frame_handler		= scic_sds_remote_device_default_frame_handler
 	},
 	[SCI_BASE_REMOTE_DEVICE_STATE_STOPPED] = {
-		.fail_handler		= scic_sds_remote_device_default_fail_handler,
 		.destruct_handler	= scic_sds_remote_device_stopped_state_destruct_handler,
 		.reset_handler		= scic_sds_remote_device_default_reset_handler,
 		.reset_complete_handler	= scic_sds_remote_device_default_reset_complete_handler,
@@ -1292,7 +1284,6 @@ static const struct scic_sds_remote_device_state_handler scic_sds_remote_device_
 		.frame_handler		= scic_sds_remote_device_default_frame_handler
 	},
 	[SCI_BASE_REMOTE_DEVICE_STATE_STARTING] = {
-		.fail_handler		= scic_sds_remote_device_default_fail_handler,
 		.destruct_handler	= scic_sds_remote_device_default_destruct_handler,
 		.reset_handler		= scic_sds_remote_device_default_reset_handler,
 		.reset_complete_handler	= scic_sds_remote_device_default_reset_complete_handler,
@@ -1307,7 +1298,6 @@ static const struct scic_sds_remote_device_state_handler scic_sds_remote_device_
 		.frame_handler		= scic_sds_remote_device_default_frame_handler
 	},
 	[SCI_BASE_REMOTE_DEVICE_STATE_READY] = {
-		.fail_handler		= scic_sds_remote_device_default_fail_handler,
 		.destruct_handler	= scic_sds_remote_device_default_destruct_handler,
 		.reset_handler		= scic_sds_remote_device_ready_state_reset_handler,
 		.reset_complete_handler	= scic_sds_remote_device_default_reset_complete_handler,
@@ -1322,7 +1312,6 @@ static const struct scic_sds_remote_device_state_handler scic_sds_remote_device_
 		.frame_handler		= scic_sds_remote_device_general_frame_handler,
 	},
 	[SCIC_SDS_STP_REMOTE_DEVICE_READY_SUBSTATE_IDLE] = {
-		.fail_handler		= scic_sds_remote_device_default_fail_handler,
 		.destruct_handler	= scic_sds_remote_device_default_destruct_handler,
 		.reset_handler		= scic_sds_remote_device_ready_state_reset_handler,
 		.reset_complete_handler	= scic_sds_remote_device_default_reset_complete_handler,
@@ -1337,7 +1326,6 @@ static const struct scic_sds_remote_device_state_handler scic_sds_remote_device_
 		.frame_handler			= scic_sds_remote_device_default_frame_handler
 	},
 	[SCIC_SDS_STP_REMOTE_DEVICE_READY_SUBSTATE_CMD] = {
-		.fail_handler		= scic_sds_remote_device_default_fail_handler,
 		.destruct_handler	= scic_sds_remote_device_default_destruct_handler,
 		.reset_handler		= scic_sds_remote_device_ready_state_reset_handler,
 		.reset_complete_handler	= scic_sds_remote_device_default_reset_complete_handler,
@@ -1352,7 +1340,6 @@ static const struct scic_sds_remote_device_state_handler scic_sds_remote_device_
 		.frame_handler			= scic_sds_stp_remote_device_ready_cmd_substate_frame_handler
 	},
 	[SCIC_SDS_STP_REMOTE_DEVICE_READY_SUBSTATE_NCQ] = {
-		.fail_handler		= scic_sds_remote_device_default_fail_handler,
 		.destruct_handler	= scic_sds_remote_device_default_destruct_handler,
 		.reset_handler		= scic_sds_remote_device_ready_state_reset_handler,
 		.reset_complete_handler	= scic_sds_remote_device_default_reset_complete_handler,
@@ -1367,7 +1354,6 @@ static const struct scic_sds_remote_device_state_handler scic_sds_remote_device_
 		.frame_handler			= scic_sds_stp_remote_device_ready_ncq_substate_frame_handler
 	},
 	[SCIC_SDS_STP_REMOTE_DEVICE_READY_SUBSTATE_NCQ_ERROR] = {
-		.fail_handler		= scic_sds_remote_device_default_fail_handler,
 		.destruct_handler	= scic_sds_remote_device_default_destruct_handler,
 		.reset_handler		= scic_sds_remote_device_ready_state_reset_handler,
 		.reset_complete_handler	= scic_sds_remote_device_default_reset_complete_handler,
@@ -1382,7 +1368,6 @@ static const struct scic_sds_remote_device_state_handler scic_sds_remote_device_
 		.frame_handler			= scic_sds_remote_device_general_frame_handler
 	},
 	[SCIC_SDS_STP_REMOTE_DEVICE_READY_SUBSTATE_AWAIT_RESET] = {
-		.fail_handler		= scic_sds_remote_device_default_fail_handler,
 		.destruct_handler	= scic_sds_remote_device_default_destruct_handler,
 		.reset_handler		= scic_sds_remote_device_ready_state_reset_handler,
 		.reset_complete_handler	= scic_sds_remote_device_default_reset_complete_handler,
@@ -1397,7 +1382,6 @@ static const struct scic_sds_remote_device_state_handler scic_sds_remote_device_
 		.frame_handler			= scic_sds_remote_device_general_frame_handler
 	},
 	[SCIC_SDS_SMP_REMOTE_DEVICE_READY_SUBSTATE_IDLE] = {
-		.fail_handler		= scic_sds_remote_device_default_fail_handler,
 		.destruct_handler	= scic_sds_remote_device_default_destruct_handler,
 		.reset_handler		= scic_sds_remote_device_default_reset_handler,
 		.reset_complete_handler	= scic_sds_remote_device_default_reset_complete_handler,
@@ -1412,7 +1396,6 @@ static const struct scic_sds_remote_device_state_handler scic_sds_remote_device_
 		.frame_handler		= scic_sds_remote_device_default_frame_handler
 	},
 	[SCIC_SDS_SMP_REMOTE_DEVICE_READY_SUBSTATE_CMD] = {
-		.fail_handler		= scic_sds_remote_device_default_fail_handler,
 		.destruct_handler	= scic_sds_remote_device_default_destruct_handler,
 		.reset_handler		= scic_sds_remote_device_default_reset_handler,
 		.reset_complete_handler	= scic_sds_remote_device_default_reset_complete_handler,
@@ -1427,7 +1410,6 @@ static const struct scic_sds_remote_device_state_handler scic_sds_remote_device_
 		.frame_handler		= scic_sds_smp_remote_device_ready_cmd_substate_frame_handler
 	},
 	[SCI_BASE_REMOTE_DEVICE_STATE_STOPPING] = {
-		.fail_handler		= scic_sds_remote_device_default_fail_handler,
 		.destruct_handler	= scic_sds_remote_device_default_destruct_handler,
 		.reset_handler		= scic_sds_remote_device_default_reset_handler,
 		.reset_complete_handler	= scic_sds_remote_device_default_reset_complete_handler,
@@ -1442,7 +1424,6 @@ static const struct scic_sds_remote_device_state_handler scic_sds_remote_device_
 		.frame_handler		= scic_sds_remote_device_general_frame_handler
 	},
 	[SCI_BASE_REMOTE_DEVICE_STATE_FAILED] = {
-		.fail_handler		= scic_sds_remote_device_default_fail_handler,
 		.destruct_handler	= scic_sds_remote_device_default_destruct_handler,
 		.reset_handler		= scic_sds_remote_device_default_reset_handler,
 		.reset_complete_handler	= scic_sds_remote_device_default_reset_complete_handler,
@@ -1457,7 +1438,6 @@ static const struct scic_sds_remote_device_state_handler scic_sds_remote_device_
 		.frame_handler		= scic_sds_remote_device_general_frame_handler
 	},
 	[SCI_BASE_REMOTE_DEVICE_STATE_RESETTING] = {
-		.fail_handler		= scic_sds_remote_device_default_fail_handler,
 		.destruct_handler	= scic_sds_remote_device_default_destruct_handler,
 		.reset_handler		= scic_sds_remote_device_default_reset_handler,
 		.reset_complete_handler	= scic_sds_remote_device_resetting_state_reset_complete_handler,
@@ -1472,7 +1452,6 @@ static const struct scic_sds_remote_device_state_handler scic_sds_remote_device_
 		.frame_handler		= scic_sds_remote_device_general_frame_handler
 	},
 	[SCI_BASE_REMOTE_DEVICE_STATE_FINAL] = {
-		.fail_handler		= scic_sds_remote_device_default_fail_handler,
 		.destruct_handler	= scic_sds_remote_device_default_destruct_handler,
 		.reset_handler		= scic_sds_remote_device_default_reset_handler,
 		.reset_complete_handler	= scic_sds_remote_device_default_reset_complete_handler,

commit ec5756699b705c179a0680985e3d18a093f93fae
Author: Dan Williams <dan.j.williams@intel.com>
Date:   Sun May 1 14:19:25 2011 -0700

    isci: unify remote_device stop_handlers
    
    Implement all states in scic_remote_device_stop() and delete the state
    handlers.
    
    Reported-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/drivers/scsi/isci/remote_device.c b/drivers/scsi/isci/remote_device.c
index 80eccdc1090f..d779939a6175 100644
--- a/drivers/scsi/isci/remote_device.c
+++ b/drivers/scsi/isci/remote_device.c
@@ -129,13 +129,91 @@ static void isci_remote_device_ready(struct isci_host *ihost, struct isci_remote
 		wake_up(&ihost->eventq);
 }
 
+/* called once the remote node context is ready to be freed.
+ * The remote device can now report that its stop operation is complete. none
+ */
+static void rnc_destruct_done(void *_dev)
+{
+	struct scic_sds_remote_device *sci_dev = _dev;
 
+	BUG_ON(sci_dev->started_request_count != 0);
+	sci_base_state_machine_change_state(&sci_dev->state_machine,
+					    SCI_BASE_REMOTE_DEVICE_STATE_STOPPED);
+}
 
-enum sci_status scic_remote_device_stop(
-	struct scic_sds_remote_device *sci_dev,
-	u32 timeout)
+static enum sci_status scic_sds_remote_device_terminate_requests(struct scic_sds_remote_device *sci_dev)
 {
-	return sci_dev->state_handlers->stop_handler(sci_dev);
+	struct scic_sds_controller *scic = sci_dev->owning_port->owning_controller;
+	u32 i, request_count = sci_dev->started_request_count;
+	enum sci_status status  = SCI_SUCCESS;
+
+	for (i = 0; i < SCI_MAX_IO_REQUESTS && i < request_count; i++) {
+		struct scic_sds_request *sci_req;
+		enum sci_status s;
+
+		sci_req = scic->io_request_table[i];
+		if (!sci_req || sci_req->target_device != sci_dev)
+			continue;
+		s = scic_controller_terminate_request(scic, sci_dev, sci_req);
+		if (s != SCI_SUCCESS)
+			status = s;
+	}
+
+	return status;
+}
+
+enum sci_status scic_remote_device_stop(struct scic_sds_remote_device *sci_dev,
+					u32 timeout)
+{
+	struct sci_base_state_machine *sm = &sci_dev->state_machine;
+	enum scic_sds_remote_device_states state = sm->current_state_id;
+
+	switch (state) {
+	case SCI_BASE_REMOTE_DEVICE_STATE_INITIAL:
+	case SCI_BASE_REMOTE_DEVICE_STATE_FAILED:
+	case SCI_BASE_REMOTE_DEVICE_STATE_FINAL:
+	default:
+		dev_warn(scirdev_to_dev(sci_dev), "%s: in wrong state: %d\n",
+			 __func__, state);
+		return SCI_FAILURE_INVALID_STATE;
+	case SCI_BASE_REMOTE_DEVICE_STATE_STOPPED:
+		return SCI_SUCCESS;
+	case SCI_BASE_REMOTE_DEVICE_STATE_STARTING:
+		/* device not started so there had better be no requests */
+		BUG_ON(sci_dev->started_request_count != 0);
+		scic_sds_remote_node_context_destruct(&sci_dev->rnc,
+						      rnc_destruct_done, sci_dev);
+		/* Transition to the stopping state and wait for the
+		 * remote node to complete being posted and invalidated.
+		 */
+		sci_base_state_machine_change_state(sm, SCI_BASE_REMOTE_DEVICE_STATE_STOPPING);
+		return SCI_SUCCESS;
+	case SCI_BASE_REMOTE_DEVICE_STATE_READY:
+	case SCIC_SDS_STP_REMOTE_DEVICE_READY_SUBSTATE_IDLE:
+	case SCIC_SDS_STP_REMOTE_DEVICE_READY_SUBSTATE_CMD:
+	case SCIC_SDS_STP_REMOTE_DEVICE_READY_SUBSTATE_NCQ:
+	case SCIC_SDS_STP_REMOTE_DEVICE_READY_SUBSTATE_NCQ_ERROR:
+	case SCIC_SDS_STP_REMOTE_DEVICE_READY_SUBSTATE_AWAIT_RESET:
+	case SCIC_SDS_SMP_REMOTE_DEVICE_READY_SUBSTATE_IDLE:
+	case SCIC_SDS_SMP_REMOTE_DEVICE_READY_SUBSTATE_CMD:
+		sci_base_state_machine_change_state(sm, SCI_BASE_REMOTE_DEVICE_STATE_STOPPING);
+		if (sci_dev->started_request_count == 0) {
+			scic_sds_remote_node_context_destruct(&sci_dev->rnc,
+							      rnc_destruct_done, sci_dev);
+			return SCI_SUCCESS;
+		} else
+			return scic_sds_remote_device_terminate_requests(sci_dev);
+		break;
+	case SCI_BASE_REMOTE_DEVICE_STATE_STOPPING:
+		/* All requests should have been terminated, but if there is an
+		 * attempt to stop a device already in the stopping state, then
+		 * try again to terminate.
+		 */
+		return scic_sds_remote_device_terminate_requests(sci_dev);
+	case SCI_BASE_REMOTE_DEVICE_STATE_RESETTING:
+		sci_base_state_machine_change_state(sm, SCI_BASE_REMOTE_DEVICE_STATE_STOPPING);
+		return SCI_SUCCESS;
+	}
 }
 
 
@@ -275,18 +353,6 @@ void scic_sds_remote_device_post_request(
 		);
 }
 
-/* called once the remote node context is ready to be freed.
- * The remote device can now report that its stop operation is complete. none
- */
-static void scic_sds_cb_remote_device_rnc_destruct_complete(void *_dev)
-{
-	struct scic_sds_remote_device *sci_dev = _dev;
-
-	BUG_ON(sci_dev->started_request_count != 0);
-	sci_base_state_machine_change_state(&sci_dev->state_machine,
-					    SCI_BASE_REMOTE_DEVICE_STATE_STOPPED);
-}
-
 /* called once the remote node context has transisitioned to a
  * ready state.  This is the indication that the remote device object can also
  * transition to ready.
@@ -358,47 +424,6 @@ static void scic_sds_remote_device_continue_request(void *dev)
 		scic_controller_continue_io(sci_dev->working_request);
 }
 
-/**
- * This method will terminate all of the IO requests in the controllers IO
- *    request table that were targeted for this device.
- * @sci_dev: This parameter specifies the remote device for which to
- *    attempt to terminate all requests.
- *
- * This method returns an indication as to whether all requests were
- * successfully terminated.  If a single request fails to be terminated, then
- * this method will return the failure.
- */
-static enum sci_status scic_sds_remote_device_terminate_requests(
-	struct scic_sds_remote_device *sci_dev)
-{
-	enum sci_status status           = SCI_SUCCESS;
-	enum sci_status terminate_status = SCI_SUCCESS;
-	struct scic_sds_request *sci_req;
-	u32 index;
-	u32 request_count    = sci_dev->started_request_count;
-
-	for (index = 0;
-	     (index < SCI_MAX_IO_REQUESTS) && (request_count > 0);
-	     index++) {
-		sci_req = sci_dev->owning_port->owning_controller->io_request_table[index];
-
-		if ((sci_req != NULL) && (sci_req->target_device == sci_dev)) {
-			terminate_status = scic_controller_terminate_request(
-				sci_dev->owning_port->owning_controller,
-				sci_dev,
-				sci_req
-				);
-
-			if (terminate_status != SCI_SUCCESS)
-				status = terminate_status;
-
-			request_count--;
-		}
-	}
-
-	return status;
-}
-
 static enum sci_status
 default_device_handler(struct scic_sds_remote_device *sci_dev,
 		       const char *func)
@@ -409,12 +434,6 @@ default_device_handler(struct scic_sds_remote_device *sci_dev,
 	return SCI_FAILURE_INVALID_STATE;
 }
 
-static enum sci_status scic_sds_remote_device_default_stop_handler(
-	struct scic_sds_remote_device *sci_dev)
-{
-	return default_device_handler(sci_dev, __func__);
-}
-
 static enum sci_status scic_sds_remote_device_default_fail_handler(
 	struct scic_sds_remote_device *sci_dev)
 {
@@ -646,12 +665,6 @@ static enum sci_status scic_sds_remote_device_general_event_handler(
 							  true);
 }
 
-static enum sci_status scic_sds_remote_device_stopped_state_stop_handler(
-	struct scic_sds_remote_device *sci_dev)
-{
-	return SCI_SUCCESS;
-}
-
 /**
  *
  * @sci_dev: The struct scic_sds_remote_device which is cast into a
@@ -679,54 +692,6 @@ static enum sci_status scic_sds_remote_device_stopped_state_destruct_handler(
 	return SCI_SUCCESS;
 }
 
-/*
- * *****************************************************************************
- * *  STARTING STATE HANDLERS
- * ***************************************************************************** */
-
-static enum sci_status scic_sds_remote_device_starting_state_stop_handler(
-	struct scic_sds_remote_device *sci_dev)
-{
-	/*
-	 * This device has not yet started so there had better be no IO requests
-	 */
-	BUG_ON(sci_dev->started_request_count != 0);
-
-	/*
-	 * Destroy the remote node context
-	 */
-	scic_sds_remote_node_context_destruct(&sci_dev->rnc,
-		scic_sds_cb_remote_device_rnc_destruct_complete, sci_dev);
-
-	/*
-	 * Transition to the stopping state and wait for the remote node to
-	 * complete being posted and invalidated.
-	 */
-	sci_base_state_machine_change_state(&sci_dev->state_machine,
-					    SCI_BASE_REMOTE_DEVICE_STATE_STOPPING);
-
-	return SCI_SUCCESS;
-}
-
-static enum sci_status scic_sds_remote_device_ready_state_stop_handler(
-	struct scic_sds_remote_device *sci_dev)
-{
-	enum sci_status status = SCI_SUCCESS;
-
-	/* Request the parent state machine to transition to the stopping state */
-	sci_base_state_machine_change_state(&sci_dev->state_machine,
-					    SCI_BASE_REMOTE_DEVICE_STATE_STOPPING);
-
-	if (sci_dev->started_request_count == 0) {
-		scic_sds_remote_node_context_destruct(&sci_dev->rnc,
-			scic_sds_cb_remote_device_rnc_destruct_complete,
-			sci_dev);
-	} else
-		status = scic_sds_remote_device_terminate_requests(sci_dev);
-
-	return status;
-}
-
 /**
  *
  * @device: The struct scic_sds_remote_device object which is cast to a
@@ -832,32 +797,6 @@ static enum sci_status scic_sds_remote_device_ready_state_complete_request_handl
 	return result;
 }
 
-/*
- * *****************************************************************************
- * *  STOPPING STATE HANDLERS
- * ***************************************************************************** */
-
-/**
- *
- * @sci_dev: The struct scic_sds_remote_device which is cast into a
- *    struct scic_sds_remote_device.
- *
- * This method will stop a struct scic_sds_remote_device that is already in the
- * SCI_BASE_REMOTE_DEVICE_STATE_STOPPING state. This is not considered an error
- * since we allow a stop request on a device that is alreay stopping or
- * stopped. enum sci_status SCI_SUCCESS
- */
-static enum sci_status scic_sds_remote_device_stopping_state_stop_handler(
-	struct scic_sds_remote_device *device)
-{
-	/*
-	 * All requests should have been terminated, but if there is an
-	 * attempt to stop a device already in the stopping state, then
-	 * try again to terminate. */
-	return scic_sds_remote_device_terminate_requests(device);
-}
-
-
 /**
  *
  * @device: The device object for which the request is completing.
@@ -891,8 +830,7 @@ static enum sci_status scic_sds_remote_device_stopping_state_complete_request_ha
 
 	if (scic_sds_remote_device_get_request_count(sci_dev) == 0)
 		scic_sds_remote_node_context_destruct(&sci_dev->rnc,
-						      scic_sds_cb_remote_device_rnc_destruct_complete,
-						      sci_dev);
+						      rnc_destruct_done, sci_dev);
 	return SCI_SUCCESS;
 }
 
@@ -905,17 +843,6 @@ static enum sci_status scic_sds_remote_device_resetting_state_reset_complete_han
 	return SCI_SUCCESS;
 }
 
-static enum sci_status scic_sds_remote_device_resetting_state_stop_handler(
-	struct scic_sds_remote_device *sci_dev)
-{
-	sci_base_state_machine_change_state(
-		&sci_dev->state_machine,
-		SCI_BASE_REMOTE_DEVICE_STATE_STOPPING
-		);
-
-	return SCI_SUCCESS;
-}
-
 /* complete requests for this device while it is in the
  * SCI_BASE_REMOTE_DEVICE_STATE_RESETTING state. This method calls the complete
  * method for the request object and if that is successful the port object is
@@ -1335,7 +1262,6 @@ static enum sci_status scic_sds_smp_remote_device_ready_cmd_substate_frame_handl
 
 static const struct scic_sds_remote_device_state_handler scic_sds_remote_device_state_handler_table[] = {
 	[SCI_BASE_REMOTE_DEVICE_STATE_INITIAL] = {
-		.stop_handler		= scic_sds_remote_device_default_stop_handler,
 		.fail_handler		= scic_sds_remote_device_default_fail_handler,
 		.destruct_handler	= scic_sds_remote_device_default_destruct_handler,
 		.reset_handler		= scic_sds_remote_device_default_reset_handler,
@@ -1351,7 +1277,6 @@ static const struct scic_sds_remote_device_state_handler scic_sds_remote_device_
 		.frame_handler		= scic_sds_remote_device_default_frame_handler
 	},
 	[SCI_BASE_REMOTE_DEVICE_STATE_STOPPED] = {
-		.stop_handler		= scic_sds_remote_device_stopped_state_stop_handler,
 		.fail_handler		= scic_sds_remote_device_default_fail_handler,
 		.destruct_handler	= scic_sds_remote_device_stopped_state_destruct_handler,
 		.reset_handler		= scic_sds_remote_device_default_reset_handler,
@@ -1367,7 +1292,6 @@ static const struct scic_sds_remote_device_state_handler scic_sds_remote_device_
 		.frame_handler		= scic_sds_remote_device_default_frame_handler
 	},
 	[SCI_BASE_REMOTE_DEVICE_STATE_STARTING] = {
-		.stop_handler		= scic_sds_remote_device_starting_state_stop_handler,
 		.fail_handler		= scic_sds_remote_device_default_fail_handler,
 		.destruct_handler	= scic_sds_remote_device_default_destruct_handler,
 		.reset_handler		= scic_sds_remote_device_default_reset_handler,
@@ -1383,7 +1307,6 @@ static const struct scic_sds_remote_device_state_handler scic_sds_remote_device_
 		.frame_handler		= scic_sds_remote_device_default_frame_handler
 	},
 	[SCI_BASE_REMOTE_DEVICE_STATE_READY] = {
-		.stop_handler		= scic_sds_remote_device_ready_state_stop_handler,
 		.fail_handler		= scic_sds_remote_device_default_fail_handler,
 		.destruct_handler	= scic_sds_remote_device_default_destruct_handler,
 		.reset_handler		= scic_sds_remote_device_ready_state_reset_handler,
@@ -1399,7 +1322,6 @@ static const struct scic_sds_remote_device_state_handler scic_sds_remote_device_
 		.frame_handler		= scic_sds_remote_device_general_frame_handler,
 	},
 	[SCIC_SDS_STP_REMOTE_DEVICE_READY_SUBSTATE_IDLE] = {
-		.stop_handler		= scic_sds_remote_device_ready_state_stop_handler,
 		.fail_handler		= scic_sds_remote_device_default_fail_handler,
 		.destruct_handler	= scic_sds_remote_device_default_destruct_handler,
 		.reset_handler		= scic_sds_remote_device_ready_state_reset_handler,
@@ -1415,7 +1337,6 @@ static const struct scic_sds_remote_device_state_handler scic_sds_remote_device_
 		.frame_handler			= scic_sds_remote_device_default_frame_handler
 	},
 	[SCIC_SDS_STP_REMOTE_DEVICE_READY_SUBSTATE_CMD] = {
-		.stop_handler		= scic_sds_remote_device_ready_state_stop_handler,
 		.fail_handler		= scic_sds_remote_device_default_fail_handler,
 		.destruct_handler	= scic_sds_remote_device_default_destruct_handler,
 		.reset_handler		= scic_sds_remote_device_ready_state_reset_handler,
@@ -1431,7 +1352,6 @@ static const struct scic_sds_remote_device_state_handler scic_sds_remote_device_
 		.frame_handler			= scic_sds_stp_remote_device_ready_cmd_substate_frame_handler
 	},
 	[SCIC_SDS_STP_REMOTE_DEVICE_READY_SUBSTATE_NCQ] = {
-		.stop_handler		= scic_sds_remote_device_ready_state_stop_handler,
 		.fail_handler		= scic_sds_remote_device_default_fail_handler,
 		.destruct_handler	= scic_sds_remote_device_default_destruct_handler,
 		.reset_handler		= scic_sds_remote_device_ready_state_reset_handler,
@@ -1447,7 +1367,6 @@ static const struct scic_sds_remote_device_state_handler scic_sds_remote_device_
 		.frame_handler			= scic_sds_stp_remote_device_ready_ncq_substate_frame_handler
 	},
 	[SCIC_SDS_STP_REMOTE_DEVICE_READY_SUBSTATE_NCQ_ERROR] = {
-		.stop_handler		= scic_sds_remote_device_ready_state_stop_handler,
 		.fail_handler		= scic_sds_remote_device_default_fail_handler,
 		.destruct_handler	= scic_sds_remote_device_default_destruct_handler,
 		.reset_handler		= scic_sds_remote_device_ready_state_reset_handler,
@@ -1463,7 +1382,6 @@ static const struct scic_sds_remote_device_state_handler scic_sds_remote_device_
 		.frame_handler			= scic_sds_remote_device_general_frame_handler
 	},
 	[SCIC_SDS_STP_REMOTE_DEVICE_READY_SUBSTATE_AWAIT_RESET] = {
-		.stop_handler		= scic_sds_remote_device_ready_state_stop_handler,
 		.fail_handler		= scic_sds_remote_device_default_fail_handler,
 		.destruct_handler	= scic_sds_remote_device_default_destruct_handler,
 		.reset_handler		= scic_sds_remote_device_ready_state_reset_handler,
@@ -1479,7 +1397,6 @@ static const struct scic_sds_remote_device_state_handler scic_sds_remote_device_
 		.frame_handler			= scic_sds_remote_device_general_frame_handler
 	},
 	[SCIC_SDS_SMP_REMOTE_DEVICE_READY_SUBSTATE_IDLE] = {
-		.stop_handler		= scic_sds_remote_device_ready_state_stop_handler,
 		.fail_handler		= scic_sds_remote_device_default_fail_handler,
 		.destruct_handler	= scic_sds_remote_device_default_destruct_handler,
 		.reset_handler		= scic_sds_remote_device_default_reset_handler,
@@ -1495,7 +1412,6 @@ static const struct scic_sds_remote_device_state_handler scic_sds_remote_device_
 		.frame_handler		= scic_sds_remote_device_default_frame_handler
 	},
 	[SCIC_SDS_SMP_REMOTE_DEVICE_READY_SUBSTATE_CMD] = {
-		.stop_handler		= scic_sds_remote_device_ready_state_stop_handler,
 		.fail_handler		= scic_sds_remote_device_default_fail_handler,
 		.destruct_handler	= scic_sds_remote_device_default_destruct_handler,
 		.reset_handler		= scic_sds_remote_device_default_reset_handler,
@@ -1511,7 +1427,6 @@ static const struct scic_sds_remote_device_state_handler scic_sds_remote_device_
 		.frame_handler		= scic_sds_smp_remote_device_ready_cmd_substate_frame_handler
 	},
 	[SCI_BASE_REMOTE_DEVICE_STATE_STOPPING] = {
-		.stop_handler		= scic_sds_remote_device_stopping_state_stop_handler,
 		.fail_handler		= scic_sds_remote_device_default_fail_handler,
 		.destruct_handler	= scic_sds_remote_device_default_destruct_handler,
 		.reset_handler		= scic_sds_remote_device_default_reset_handler,
@@ -1527,7 +1442,6 @@ static const struct scic_sds_remote_device_state_handler scic_sds_remote_device_
 		.frame_handler		= scic_sds_remote_device_general_frame_handler
 	},
 	[SCI_BASE_REMOTE_DEVICE_STATE_FAILED] = {
-		.stop_handler		= scic_sds_remote_device_default_stop_handler,
 		.fail_handler		= scic_sds_remote_device_default_fail_handler,
 		.destruct_handler	= scic_sds_remote_device_default_destruct_handler,
 		.reset_handler		= scic_sds_remote_device_default_reset_handler,
@@ -1543,7 +1457,6 @@ static const struct scic_sds_remote_device_state_handler scic_sds_remote_device_
 		.frame_handler		= scic_sds_remote_device_general_frame_handler
 	},
 	[SCI_BASE_REMOTE_DEVICE_STATE_RESETTING] = {
-		.stop_handler		= scic_sds_remote_device_resetting_state_stop_handler,
 		.fail_handler		= scic_sds_remote_device_default_fail_handler,
 		.destruct_handler	= scic_sds_remote_device_default_destruct_handler,
 		.reset_handler		= scic_sds_remote_device_default_reset_handler,
@@ -1559,7 +1472,6 @@ static const struct scic_sds_remote_device_state_handler scic_sds_remote_device_
 		.frame_handler		= scic_sds_remote_device_general_frame_handler
 	},
 	[SCI_BASE_REMOTE_DEVICE_STATE_FINAL] = {
-		.stop_handler		= scic_sds_remote_device_default_stop_handler,
 		.fail_handler		= scic_sds_remote_device_default_fail_handler,
 		.destruct_handler	= scic_sds_remote_device_default_destruct_handler,
 		.reset_handler		= scic_sds_remote_device_default_reset_handler,

commit eb229671b1310c996dba7b78e21a9a9474edccdc
Author: Dan Williams <dan.j.williams@intel.com>
Date:   Sun May 1 14:05:57 2011 -0700

    isci: unify remote_device start_handlers
    
    Implement all states in scic_remote_device_start() and delete the state
    handler.
    
    Reported-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/drivers/scsi/isci/remote_device.c b/drivers/scsi/isci/remote_device.c
index 3e567bf84c74..80eccdc1090f 100644
--- a/drivers/scsi/isci/remote_device.c
+++ b/drivers/scsi/isci/remote_device.c
@@ -291,7 +291,7 @@ static void scic_sds_cb_remote_device_rnc_destruct_complete(void *_dev)
  * ready state.  This is the indication that the remote device object can also
  * transition to ready.
  */
-static void scic_sds_remote_device_resume_complete_handler(void *_dev)
+static void remote_device_resume_done(void *_dev)
 {
 	struct scic_sds_remote_device *sci_dev = _dev;
 	enum scic_sds_remote_device_states state;
@@ -409,12 +409,6 @@ default_device_handler(struct scic_sds_remote_device *sci_dev,
 	return SCI_FAILURE_INVALID_STATE;
 }
 
-static enum sci_status scic_sds_remote_device_default_start_handler(
-	struct scic_sds_remote_device *sci_dev)
-{
-	return default_device_handler(sci_dev, __func__);
-}
-
 static enum sci_status scic_sds_remote_device_default_stop_handler(
 	struct scic_sds_remote_device *sci_dev)
 {
@@ -652,38 +646,6 @@ static enum sci_status scic_sds_remote_device_general_event_handler(
 							  true);
 }
 
-/*
- * *****************************************************************************
- * *  STOPPED STATE HANDLERS
- * ***************************************************************************** */
-
-/**
- *
- * @device:
- *
- * This method takes the struct scic_sds_remote_device from a stopped state and
- * attempts to start it.   The RNC buffer for the device is constructed and the
- * device state machine is transitioned to the
- * SCIC_BASE_REMOTE_DEVICE_STATE_STARTING. enum sci_status SCI_SUCCESS if there is
- * an RNC buffer available to construct the remote device.
- * SCI_FAILURE_INSUFFICIENT_RESOURCES if there is no RNC buffer available in
- * which to construct the remote device.
- */
-static enum sci_status scic_sds_remote_device_stopped_state_start_handler(
-	struct scic_sds_remote_device *sci_dev)
-{
-	enum sci_status status;
-
-	status = scic_sds_remote_node_context_resume(&sci_dev->rnc,
-			scic_sds_remote_device_resume_complete_handler, sci_dev);
-
-	if (status == SCI_SUCCESS)
-		sci_base_state_machine_change_state(&sci_dev->state_machine,
-						    SCI_BASE_REMOTE_DEVICE_STATE_STARTING);
-
-	return status;
-}
-
 static enum sci_status scic_sds_remote_device_stopped_state_stop_handler(
 	struct scic_sds_remote_device *sci_dev)
 {
@@ -1373,7 +1335,6 @@ static enum sci_status scic_sds_smp_remote_device_ready_cmd_substate_frame_handl
 
 static const struct scic_sds_remote_device_state_handler scic_sds_remote_device_state_handler_table[] = {
 	[SCI_BASE_REMOTE_DEVICE_STATE_INITIAL] = {
-		.start_handler		= scic_sds_remote_device_default_start_handler,
 		.stop_handler		= scic_sds_remote_device_default_stop_handler,
 		.fail_handler		= scic_sds_remote_device_default_fail_handler,
 		.destruct_handler	= scic_sds_remote_device_default_destruct_handler,
@@ -1390,7 +1351,6 @@ static const struct scic_sds_remote_device_state_handler scic_sds_remote_device_
 		.frame_handler		= scic_sds_remote_device_default_frame_handler
 	},
 	[SCI_BASE_REMOTE_DEVICE_STATE_STOPPED] = {
-		.start_handler		= scic_sds_remote_device_stopped_state_start_handler,
 		.stop_handler		= scic_sds_remote_device_stopped_state_stop_handler,
 		.fail_handler		= scic_sds_remote_device_default_fail_handler,
 		.destruct_handler	= scic_sds_remote_device_stopped_state_destruct_handler,
@@ -1407,7 +1367,6 @@ static const struct scic_sds_remote_device_state_handler scic_sds_remote_device_
 		.frame_handler		= scic_sds_remote_device_default_frame_handler
 	},
 	[SCI_BASE_REMOTE_DEVICE_STATE_STARTING] = {
-		.start_handler		= scic_sds_remote_device_default_start_handler,
 		.stop_handler		= scic_sds_remote_device_starting_state_stop_handler,
 		.fail_handler		= scic_sds_remote_device_default_fail_handler,
 		.destruct_handler	= scic_sds_remote_device_default_destruct_handler,
@@ -1424,7 +1383,6 @@ static const struct scic_sds_remote_device_state_handler scic_sds_remote_device_
 		.frame_handler		= scic_sds_remote_device_default_frame_handler
 	},
 	[SCI_BASE_REMOTE_DEVICE_STATE_READY] = {
-		.start_handler		= scic_sds_remote_device_default_start_handler,
 		.stop_handler		= scic_sds_remote_device_ready_state_stop_handler,
 		.fail_handler		= scic_sds_remote_device_default_fail_handler,
 		.destruct_handler	= scic_sds_remote_device_default_destruct_handler,
@@ -1441,7 +1399,6 @@ static const struct scic_sds_remote_device_state_handler scic_sds_remote_device_
 		.frame_handler		= scic_sds_remote_device_general_frame_handler,
 	},
 	[SCIC_SDS_STP_REMOTE_DEVICE_READY_SUBSTATE_IDLE] = {
-		.start_handler		= scic_sds_remote_device_default_start_handler,
 		.stop_handler		= scic_sds_remote_device_ready_state_stop_handler,
 		.fail_handler		= scic_sds_remote_device_default_fail_handler,
 		.destruct_handler	= scic_sds_remote_device_default_destruct_handler,
@@ -1458,7 +1415,6 @@ static const struct scic_sds_remote_device_state_handler scic_sds_remote_device_
 		.frame_handler			= scic_sds_remote_device_default_frame_handler
 	},
 	[SCIC_SDS_STP_REMOTE_DEVICE_READY_SUBSTATE_CMD] = {
-		.start_handler		= scic_sds_remote_device_default_start_handler,
 		.stop_handler		= scic_sds_remote_device_ready_state_stop_handler,
 		.fail_handler		= scic_sds_remote_device_default_fail_handler,
 		.destruct_handler	= scic_sds_remote_device_default_destruct_handler,
@@ -1475,7 +1431,6 @@ static const struct scic_sds_remote_device_state_handler scic_sds_remote_device_
 		.frame_handler			= scic_sds_stp_remote_device_ready_cmd_substate_frame_handler
 	},
 	[SCIC_SDS_STP_REMOTE_DEVICE_READY_SUBSTATE_NCQ] = {
-		.start_handler		= scic_sds_remote_device_default_start_handler,
 		.stop_handler		= scic_sds_remote_device_ready_state_stop_handler,
 		.fail_handler		= scic_sds_remote_device_default_fail_handler,
 		.destruct_handler	= scic_sds_remote_device_default_destruct_handler,
@@ -1492,7 +1447,6 @@ static const struct scic_sds_remote_device_state_handler scic_sds_remote_device_
 		.frame_handler			= scic_sds_stp_remote_device_ready_ncq_substate_frame_handler
 	},
 	[SCIC_SDS_STP_REMOTE_DEVICE_READY_SUBSTATE_NCQ_ERROR] = {
-		.start_handler		= scic_sds_remote_device_default_start_handler,
 		.stop_handler		= scic_sds_remote_device_ready_state_stop_handler,
 		.fail_handler		= scic_sds_remote_device_default_fail_handler,
 		.destruct_handler	= scic_sds_remote_device_default_destruct_handler,
@@ -1509,7 +1463,6 @@ static const struct scic_sds_remote_device_state_handler scic_sds_remote_device_
 		.frame_handler			= scic_sds_remote_device_general_frame_handler
 	},
 	[SCIC_SDS_STP_REMOTE_DEVICE_READY_SUBSTATE_AWAIT_RESET] = {
-		.start_handler		= scic_sds_remote_device_default_start_handler,
 		.stop_handler		= scic_sds_remote_device_ready_state_stop_handler,
 		.fail_handler		= scic_sds_remote_device_default_fail_handler,
 		.destruct_handler	= scic_sds_remote_device_default_destruct_handler,
@@ -1526,7 +1479,6 @@ static const struct scic_sds_remote_device_state_handler scic_sds_remote_device_
 		.frame_handler			= scic_sds_remote_device_general_frame_handler
 	},
 	[SCIC_SDS_SMP_REMOTE_DEVICE_READY_SUBSTATE_IDLE] = {
-		.start_handler		= scic_sds_remote_device_default_start_handler,
 		.stop_handler		= scic_sds_remote_device_ready_state_stop_handler,
 		.fail_handler		= scic_sds_remote_device_default_fail_handler,
 		.destruct_handler	= scic_sds_remote_device_default_destruct_handler,
@@ -1543,7 +1495,6 @@ static const struct scic_sds_remote_device_state_handler scic_sds_remote_device_
 		.frame_handler		= scic_sds_remote_device_default_frame_handler
 	},
 	[SCIC_SDS_SMP_REMOTE_DEVICE_READY_SUBSTATE_CMD] = {
-		.start_handler		= scic_sds_remote_device_default_start_handler,
 		.stop_handler		= scic_sds_remote_device_ready_state_stop_handler,
 		.fail_handler		= scic_sds_remote_device_default_fail_handler,
 		.destruct_handler	= scic_sds_remote_device_default_destruct_handler,
@@ -1560,7 +1511,6 @@ static const struct scic_sds_remote_device_state_handler scic_sds_remote_device_
 		.frame_handler		= scic_sds_smp_remote_device_ready_cmd_substate_frame_handler
 	},
 	[SCI_BASE_REMOTE_DEVICE_STATE_STOPPING] = {
-		.start_handler		= scic_sds_remote_device_default_start_handler,
 		.stop_handler		= scic_sds_remote_device_stopping_state_stop_handler,
 		.fail_handler		= scic_sds_remote_device_default_fail_handler,
 		.destruct_handler	= scic_sds_remote_device_default_destruct_handler,
@@ -1577,7 +1527,6 @@ static const struct scic_sds_remote_device_state_handler scic_sds_remote_device_
 		.frame_handler		= scic_sds_remote_device_general_frame_handler
 	},
 	[SCI_BASE_REMOTE_DEVICE_STATE_FAILED] = {
-		.start_handler		= scic_sds_remote_device_default_start_handler,
 		.stop_handler		= scic_sds_remote_device_default_stop_handler,
 		.fail_handler		= scic_sds_remote_device_default_fail_handler,
 		.destruct_handler	= scic_sds_remote_device_default_destruct_handler,
@@ -1594,7 +1543,6 @@ static const struct scic_sds_remote_device_state_handler scic_sds_remote_device_
 		.frame_handler		= scic_sds_remote_device_general_frame_handler
 	},
 	[SCI_BASE_REMOTE_DEVICE_STATE_RESETTING] = {
-		.start_handler		= scic_sds_remote_device_default_start_handler,
 		.stop_handler		= scic_sds_remote_device_resetting_state_stop_handler,
 		.fail_handler		= scic_sds_remote_device_default_fail_handler,
 		.destruct_handler	= scic_sds_remote_device_default_destruct_handler,
@@ -1611,7 +1559,6 @@ static const struct scic_sds_remote_device_state_handler scic_sds_remote_device_
 		.frame_handler		= scic_sds_remote_device_general_frame_handler
 	},
 	[SCI_BASE_REMOTE_DEVICE_STATE_FINAL] = {
-		.start_handler		= scic_sds_remote_device_default_start_handler,
 		.stop_handler		= scic_sds_remote_device_default_stop_handler,
 		.fail_handler		= scic_sds_remote_device_default_fail_handler,
 		.destruct_handler	= scic_sds_remote_device_default_destruct_handler,
@@ -2129,9 +2076,27 @@ static enum sci_status scic_remote_device_ea_construct(struct scic_sds_port *sci
  * the device when there have been no phys added to it.
  */
 static enum sci_status scic_remote_device_start(struct scic_sds_remote_device *sci_dev,
-					 u32 timeout)
+						u32 timeout)
 {
-	return sci_dev->state_handlers->start_handler(sci_dev);
+	struct sci_base_state_machine *sm = &sci_dev->state_machine;
+	enum scic_sds_remote_device_states state = sm->current_state_id;
+	enum sci_status status;
+
+	if (state != SCI_BASE_REMOTE_DEVICE_STATE_STOPPED) {
+		dev_warn(scirdev_to_dev(sci_dev), "%s: in wrong state: %d\n",
+			 __func__, state);
+		return SCI_FAILURE_INVALID_STATE;
+	}
+
+	status = scic_sds_remote_node_context_resume(&sci_dev->rnc,
+						     remote_device_resume_done,
+						     sci_dev);
+	if (status != SCI_SUCCESS)
+		return status;
+
+	sci_base_state_machine_change_state(sm, SCI_BASE_REMOTE_DEVICE_STATE_STARTING);
+
+	return SCI_SUCCESS;
 }
 
 static enum sci_status isci_remote_device_construct(struct isci_port *iport,

commit f619fffb4070a577524fd9eb68cea484d86d2b97
Author: Dan Williams <dan.j.williams@intel.com>
Date:   Sun May 1 10:13:04 2011 -0700

    isci: fix remote_device start_io regressions
    
    While reducing indentation commits 7ab92c9e "isci: make a
    remote_node_context a proper member of a remote_device", 0879e6a6 "isci:
    merge remote_device substates into a single state machine" broke
    handling of situations where i/o's successfully started at the port
    level need to terminated when the remote_node declines to start the i/o.
    
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/drivers/scsi/isci/remote_device.c b/drivers/scsi/isci/remote_device.c
index 834a3feaca63..3e567bf84c74 100644
--- a/drivers/scsi/isci/remote_device.c
+++ b/drivers/scsi/isci/remote_device.c
@@ -1157,10 +1157,8 @@ static enum sci_status scic_sds_stp_remote_device_ready_ncq_substate_start_io_ha
 			return status;
 
 		status = scic_sds_remote_node_context_start_io(&sci_dev->rnc, request);
-		if (status != SCI_SUCCESS)
-			return status;
-
-		status = request->state_handlers->start_handler(request);
+		if (status == SCI_SUCCESS)
+			status = request->state_handlers->start_handler(request);
 
 		scic_sds_remote_device_start_request(sci_dev, request, status);
 	} else
@@ -1302,16 +1300,17 @@ static enum sci_status scic_sds_smp_remote_device_ready_idle_substate_start_io_h
 
 	status = scic_sds_remote_node_context_start_io(&sci_dev->rnc, sci_req);
 	if (status != SCI_SUCCESS)
-		return status;
+		goto out;
 
 	status = scic_sds_request_start(sci_req);
 	if (status != SCI_SUCCESS)
-		return status;
+		goto out;
 
 	sci_dev->working_request = sci_req;
 	sci_base_state_machine_change_state(&sci_dev->state_machine,
 					    SCIC_SDS_SMP_REMOTE_DEVICE_READY_SUBSTATE_CMD);
 
+ out:
 	scic_sds_remote_device_start_request(sci_dev, sci_req, status);
 
 	return status;

commit 8f304c36ee415600c6bbc5de300e6fa3dbe59d6d
Author: Dan Williams <dan.j.williams@intel.com>
Date:   Fri Apr 29 13:20:30 2011 -0700

    isci: kill scic_remote_device_get_connection_rate
    
    A function call to dereference a pointer is a tad much.
    
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/drivers/scsi/isci/remote_device.c b/drivers/scsi/isci/remote_device.c
index f6da85e3f2af..834a3feaca63 100644
--- a/drivers/scsi/isci/remote_device.c
+++ b/drivers/scsi/isci/remote_device.c
@@ -152,22 +152,9 @@ enum sci_status scic_remote_device_reset_complete(
 	return sci_dev->state_handlers->reset_complete_handler(sci_dev);
 }
 
-
-enum sas_linkrate scic_remote_device_get_connection_rate(
-	struct scic_sds_remote_device *sci_dev)
-{
-	return sci_dev->connection_rate;
-}
-
-/**
- *
- *
- * Remote device timer requirements
- */
 #define SCIC_SDS_REMOTE_DEVICE_MINIMUM_TIMER_COUNT (0)
 #define SCIC_SDS_REMOTE_DEVICE_MAXIMUM_TIMER_COUNT (SCI_MAX_REMOTE_DEVICES)
 
-
 /**
  *
  * @sci_dev: The remote device for which the suspend is being requested.

commit ab2e8f7d07f577ee39228fb3454b9f29eab0f312
Author: Dan Williams <dan.j.williams@intel.com>
Date:   Wed Apr 27 16:32:45 2011 -0700

    isci: merge remote_device substates into a single state machine
    
    A substate is just a state, so uplevel the smp and stp device substates.
    Three tricks at work here:
    
    1/ scic_sds_remote_device_ready_state_enter: needs to know the the device type
       so it can immediately transition to a stp or smp ready substate.
    
    2/ scic_sds_remote_device_ready_state_exit: needs to know the device type. In
       the ssp case the device is no longer ready, in the stp, and smp case we have
       simply exited to a ready "substate".
    
    3/ scic_sds_remote_device_resume_complete_handler: The one location
       where we directly check the current state against
       SCI_BASE_REMOTE_DEVICE_STATE_READY needed to comprehend the possible ready
       substates.
    
    Reported-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/drivers/scsi/isci/remote_device.c b/drivers/scsi/isci/remote_device.c
index 2bbc7c20c400..f6da85e3f2af 100644
--- a/drivers/scsi/isci/remote_device.c
+++ b/drivers/scsi/isci/remote_device.c
@@ -53,6 +53,7 @@
  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
 #include "intel_sas.h"
+#include "intel_ata.h"
 #include "isci.h"
 #include "port.h"
 #include "remote_device.h"
@@ -71,6 +72,65 @@
 #include "scu_event_codes.h"
 #include "task.h"
 
+/**
+ * isci_remote_device_change_state() - This function gets the status of the
+ *    remote_device object.
+ * @isci_device: This parameter points to the isci_remote_device object
+ *
+ * status of the object as a isci_status enum.
+ */
+void isci_remote_device_change_state(
+	struct isci_remote_device *isci_device,
+	enum isci_status status)
+{
+	unsigned long flags;
+
+	spin_lock_irqsave(&isci_device->state_lock, flags);
+	isci_device->status = status;
+	spin_unlock_irqrestore(&isci_device->state_lock, flags);
+}
+
+/**
+ * isci_remote_device_not_ready() - This function is called by the scic when
+ *    the remote device is not ready. We mark the isci device as ready (not
+ *    "ready_for_io") and signal the waiting proccess.
+ * @isci_host: This parameter specifies the isci host object.
+ * @isci_device: This parameter specifies the remote device
+ *
+ */
+static void isci_remote_device_not_ready(struct isci_host *ihost,
+				  struct isci_remote_device *idev, u32 reason)
+{
+	dev_dbg(&ihost->pdev->dev,
+		"%s: isci_device = %p\n", __func__, idev);
+
+	if (reason == SCIC_REMOTE_DEVICE_NOT_READY_STOP_REQUESTED)
+		isci_remote_device_change_state(idev, isci_stopping);
+	else
+		/* device ready is actually a "not ready for io" state. */
+		isci_remote_device_change_state(idev, isci_ready);
+}
+
+/**
+ * isci_remote_device_ready() - This function is called by the scic when the
+ *    remote device is ready. We mark the isci device as ready and signal the
+ *    waiting proccess.
+ * @ihost: our valid isci_host
+ * @idev: remote device
+ *
+ */
+static void isci_remote_device_ready(struct isci_host *ihost, struct isci_remote_device *idev)
+{
+	dev_dbg(&ihost->pdev->dev,
+		"%s: idev = %p\n", __func__, idev);
+
+	isci_remote_device_change_state(idev, isci_ready_for_io);
+	if (test_and_clear_bit(IDEV_START_PENDING, &idev->flags))
+		wake_up(&ihost->eventq);
+}
+
+
+
 enum sci_status scic_remote_device_stop(
 	struct scic_sds_remote_device *sci_dev,
 	u32 timeout)
@@ -228,49 +288,43 @@ void scic_sds_remote_device_post_request(
 		);
 }
 
-/**
- *
- * @user_parameter: This is cast to a remote device object.
- *
- * This method is called once the remote node context is ready to be freed.
+/* called once the remote node context is ready to be freed.
  * The remote device can now report that its stop operation is complete. none
  */
-static void scic_sds_cb_remote_device_rnc_destruct_complete(
-	void *user_parameter)
+static void scic_sds_cb_remote_device_rnc_destruct_complete(void *_dev)
 {
-	struct scic_sds_remote_device *sci_dev;
-
-	sci_dev = (struct scic_sds_remote_device *)user_parameter;
+	struct scic_sds_remote_device *sci_dev = _dev;
 
 	BUG_ON(sci_dev->started_request_count != 0);
-
 	sci_base_state_machine_change_state(&sci_dev->state_machine,
 					    SCI_BASE_REMOTE_DEVICE_STATE_STOPPED);
 }
 
-/**
- *
- * @user_parameter: This is cast to a remote device object.
- *
- * This method is called once the remote node context has transisitioned to a
+/* called once the remote node context has transisitioned to a
  * ready state.  This is the indication that the remote device object can also
- * transition to ready. none
+ * transition to ready.
  */
-static void scic_sds_remote_device_resume_complete_handler(
-	void *user_parameter)
-{
-	struct scic_sds_remote_device *sci_dev;
-
-	sci_dev = (struct scic_sds_remote_device *)user_parameter;
-
-	if (
-		sci_base_state_machine_get_state(&sci_dev->state_machine)
-		!= SCI_BASE_REMOTE_DEVICE_STATE_READY
-		) {
-		sci_base_state_machine_change_state(
-			&sci_dev->state_machine,
-			SCI_BASE_REMOTE_DEVICE_STATE_READY
-			);
+static void scic_sds_remote_device_resume_complete_handler(void *_dev)
+{
+	struct scic_sds_remote_device *sci_dev = _dev;
+	enum scic_sds_remote_device_states state;
+
+	state = sci_dev->state_machine.current_state_id;
+	switch (state) {
+	case SCI_BASE_REMOTE_DEVICE_STATE_READY:
+	case SCIC_SDS_STP_REMOTE_DEVICE_READY_SUBSTATE_IDLE:
+	case SCIC_SDS_STP_REMOTE_DEVICE_READY_SUBSTATE_CMD:
+	case SCIC_SDS_STP_REMOTE_DEVICE_READY_SUBSTATE_NCQ:
+	case SCIC_SDS_STP_REMOTE_DEVICE_READY_SUBSTATE_NCQ_ERROR:
+	case SCIC_SDS_STP_REMOTE_DEVICE_READY_SUBSTATE_AWAIT_RESET:
+	case SCIC_SDS_SMP_REMOTE_DEVICE_READY_SUBSTATE_IDLE:
+	case SCIC_SDS_SMP_REMOTE_DEVICE_READY_SUBSTATE_CMD:
+		break;
+	default:
+		/* go 'ready' if we are not already in a ready state */
+		sci_base_state_machine_change_state(&sci_dev->state_machine,
+						    SCI_BASE_REMOTE_DEVICE_STATE_READY);
+		break;
 	}
 }
 
@@ -284,7 +338,7 @@ static void scic_sds_remote_device_resume_complete_handler(
  * This method will perform the STP request start processing common to IO
  * requests and task requests of all types. none
  */
-void scic_sds_remote_device_start_request(
+static void scic_sds_remote_device_start_request(
 	struct scic_sds_remote_device *sci_dev,
 	struct scic_sds_request *sci_req,
 	enum sci_status status)
@@ -308,7 +362,7 @@ void scic_sds_remote_device_start_request(
  * serves as a callback when RNC gets resumed during a task management
  * sequence. none
  */
-void scic_sds_remote_device_continue_request(void *dev)
+static void scic_sds_remote_device_continue_request(void *dev)
 {
 	struct scic_sds_remote_device *sci_dev = dev;
 
@@ -368,7 +422,7 @@ default_device_handler(struct scic_sds_remote_device *sci_dev,
 	return SCI_FAILURE_INVALID_STATE;
 }
 
-enum sci_status scic_sds_remote_device_default_start_handler(
+static enum sci_status scic_sds_remote_device_default_start_handler(
 	struct scic_sds_remote_device *sci_dev)
 {
 	return default_device_handler(sci_dev, __func__);
@@ -380,37 +434,37 @@ static enum sci_status scic_sds_remote_device_default_stop_handler(
 	return default_device_handler(sci_dev, __func__);
 }
 
-enum sci_status scic_sds_remote_device_default_fail_handler(
+static enum sci_status scic_sds_remote_device_default_fail_handler(
 	struct scic_sds_remote_device *sci_dev)
 {
 	return default_device_handler(sci_dev, __func__);
 }
 
-enum sci_status scic_sds_remote_device_default_destruct_handler(
+static enum sci_status scic_sds_remote_device_default_destruct_handler(
 	struct scic_sds_remote_device *sci_dev)
 {
 	return default_device_handler(sci_dev, __func__);
 }
 
-enum sci_status scic_sds_remote_device_default_reset_handler(
+static enum sci_status scic_sds_remote_device_default_reset_handler(
 	struct scic_sds_remote_device *sci_dev)
 {
 	return default_device_handler(sci_dev, __func__);
 }
 
-enum sci_status scic_sds_remote_device_default_reset_complete_handler(
+static enum sci_status scic_sds_remote_device_default_reset_complete_handler(
 	struct scic_sds_remote_device *sci_dev)
 {
 	return default_device_handler(sci_dev, __func__);
 }
 
-enum sci_status scic_sds_remote_device_default_suspend_handler(
+static enum sci_status scic_sds_remote_device_default_suspend_handler(
 	struct scic_sds_remote_device *sci_dev, u32 suspend_type)
 {
 	return default_device_handler(sci_dev, __func__);
 }
 
-enum sci_status scic_sds_remote_device_default_resume_handler(
+static enum sci_status scic_sds_remote_device_default_resume_handler(
 	struct scic_sds_remote_device *sci_dev)
 {
 	return default_device_handler(sci_dev, __func__);
@@ -505,7 +559,7 @@ static enum sci_status  scic_sds_remote_device_default_event_handler(
  * releases the frame and returns a failure. enum sci_status
  * SCI_FAILURE_INVALID_STATE
  */
-enum sci_status scic_sds_remote_device_default_frame_handler(
+static enum sci_status scic_sds_remote_device_default_frame_handler(
 	struct scic_sds_remote_device *sci_dev,
 	u32 frame_index)
 {
@@ -525,21 +579,21 @@ enum sci_status scic_sds_remote_device_default_frame_handler(
 	return SCI_FAILURE_INVALID_STATE;
 }
 
-enum sci_status scic_sds_remote_device_default_start_request_handler(
+static enum sci_status scic_sds_remote_device_default_start_request_handler(
 	struct scic_sds_remote_device *sci_dev,
 	struct scic_sds_request *request)
 {
 	return default_device_handler(sci_dev, __func__);
 }
 
-enum sci_status scic_sds_remote_device_default_complete_request_handler(
+static enum sci_status scic_sds_remote_device_default_complete_request_handler(
 	struct scic_sds_remote_device *sci_dev,
 	struct scic_sds_request *request)
 {
 	return default_device_handler(sci_dev, __func__);
 }
 
-enum sci_status scic_sds_remote_device_default_continue_request_handler(
+static enum sci_status scic_sds_remote_device_default_continue_request_handler(
 	struct scic_sds_remote_device *sci_dev,
 	struct scic_sds_request *request)
 {
@@ -558,7 +612,7 @@ enum sci_status scic_sds_remote_device_default_continue_request_handler(
  * This method decodes the tag for the io request object and routes the
  * unsolicited frame to that object. enum sci_status SCI_FAILURE_INVALID_STATE
  */
-enum sci_status scic_sds_remote_device_general_frame_handler(
+static enum sci_status scic_sds_remote_device_general_frame_handler(
 	struct scic_sds_remote_device *sci_dev,
 	u32 frame_index)
 {
@@ -602,7 +656,7 @@ enum sci_status scic_sds_remote_device_general_frame_handler(
  * This is a common method for handling events reported to the remote device
  * from the controller object. enum sci_status
  */
-enum sci_status scic_sds_remote_device_general_event_handler(
+static enum sci_status scic_sds_remote_device_general_event_handler(
 	struct scic_sds_remote_device *sci_dev,
 	u32 event_code)
 {
@@ -705,7 +759,7 @@ static enum sci_status scic_sds_remote_device_starting_state_stop_handler(
 	return SCI_SUCCESS;
 }
 
-enum sci_status scic_sds_remote_device_ready_state_stop_handler(
+static enum sci_status scic_sds_remote_device_ready_state_stop_handler(
 	struct scic_sds_remote_device *sci_dev)
 {
 	enum sci_status status = SCI_SUCCESS;
@@ -731,7 +785,7 @@ enum sci_status scic_sds_remote_device_ready_state_stop_handler(
  *
  * This is the ready state device reset handler enum sci_status
  */
-enum sci_status scic_sds_remote_device_ready_state_reset_handler(
+static enum sci_status scic_sds_remote_device_ready_state_reset_handler(
 	struct scic_sds_remote_device *sci_dev)
 {
 	/* Request the parent state machine to transition to the stopping state */
@@ -893,34 +947,15 @@ static enum sci_status scic_sds_remote_device_stopping_state_complete_request_ha
 	return SCI_SUCCESS;
 }
 
-/**
- *
- * @device: The struct scic_sds_remote_device which is to be cast into a
- *    struct scic_sds_remote_device object.
- *
- * This method will complete the reset operation when the device is in the
- * resetting state. enum sci_status
- */
 static enum sci_status scic_sds_remote_device_resetting_state_reset_complete_handler(
 	struct scic_sds_remote_device *sci_dev)
 {
-
-	sci_base_state_machine_change_state(
-		&sci_dev->state_machine,
-		SCI_BASE_REMOTE_DEVICE_STATE_READY
-		);
+	sci_base_state_machine_change_state(&sci_dev->state_machine,
+					    SCI_BASE_REMOTE_DEVICE_STATE_READY);
 
 	return SCI_SUCCESS;
 }
 
-/**
- *
- * @device: The struct scic_sds_remote_device which is to be cast into a
- *    struct scic_sds_remote_device object.
- *
- * This method will stop the remote device while in the resetting state.
- * enum sci_status
- */
 static enum sci_status scic_sds_remote_device_resetting_state_stop_handler(
 	struct scic_sds_remote_device *sci_dev)
 {
@@ -932,12 +967,11 @@ static enum sci_status scic_sds_remote_device_resetting_state_stop_handler(
 	return SCI_SUCCESS;
 }
 
-/*
- * This method completes requests for this struct scic_sds_remote_device while it is
- * in the SCI_BASE_REMOTE_DEVICE_STATE_RESETTING state. This method calls the
- * complete method for the request object and if that is successful the port
- * object is called to complete the task request. Then the device object itself
- * completes the task request. enum sci_status
+/* complete requests for this device while it is in the
+ * SCI_BASE_REMOTE_DEVICE_STATE_RESETTING state. This method calls the complete
+ * method for the request object and if that is successful the port object is
+ * called to complete the task request. Then the device object itself completes
+ * the task request. enum sci_status
  */
 static enum sci_status scic_sds_remote_device_resetting_state_complete_request_handler(
 	struct scic_sds_remote_device *sci_dev,
@@ -960,173 +994,665 @@ static enum sci_status scic_sds_remote_device_resetting_state_complete_request_h
 	return status;
 }
 
-static const struct scic_sds_remote_device_state_handler scic_sds_remote_device_state_handler_table[] = {
-	[SCI_BASE_REMOTE_DEVICE_STATE_INITIAL] = {
-		.start_handler		= scic_sds_remote_device_default_start_handler,
-		.stop_handler		= scic_sds_remote_device_default_stop_handler,
-		.fail_handler		= scic_sds_remote_device_default_fail_handler,
-		.destruct_handler	= scic_sds_remote_device_default_destruct_handler,
-		.reset_handler		= scic_sds_remote_device_default_reset_handler,
-		.reset_complete_handler	= scic_sds_remote_device_default_reset_complete_handler,
-		.start_io_handler	= scic_sds_remote_device_default_start_request_handler,
-		.complete_io_handler	= scic_sds_remote_device_default_complete_request_handler,
-		.continue_io_handler	= scic_sds_remote_device_default_continue_request_handler,
-		.start_task_handler	= scic_sds_remote_device_default_start_request_handler,
-		.complete_task_handler	= scic_sds_remote_device_default_complete_request_handler,
-		.suspend_handler	= scic_sds_remote_device_default_suspend_handler,
-		.resume_handler		= scic_sds_remote_device_default_resume_handler,
-		.event_handler		= scic_sds_remote_device_default_event_handler,
-		.frame_handler		= scic_sds_remote_device_default_frame_handler
-	},
-	[SCI_BASE_REMOTE_DEVICE_STATE_STOPPED] = {
-		.start_handler		= scic_sds_remote_device_stopped_state_start_handler,
-		.stop_handler		= scic_sds_remote_device_stopped_state_stop_handler,
-		.fail_handler		= scic_sds_remote_device_default_fail_handler,
-		.destruct_handler	= scic_sds_remote_device_stopped_state_destruct_handler,
-		.reset_handler		= scic_sds_remote_device_default_reset_handler,
-		.reset_complete_handler	= scic_sds_remote_device_default_reset_complete_handler,
-		.start_io_handler	= scic_sds_remote_device_default_start_request_handler,
-		.complete_io_handler	= scic_sds_remote_device_default_complete_request_handler,
-		.continue_io_handler	= scic_sds_remote_device_default_continue_request_handler,
-		.start_task_handler	= scic_sds_remote_device_default_start_request_handler,
-		.complete_task_handler	= scic_sds_remote_device_default_complete_request_handler,
-		.suspend_handler	= scic_sds_remote_device_default_suspend_handler,
-		.resume_handler		= scic_sds_remote_device_default_resume_handler,
-		.event_handler		= scic_sds_remote_device_default_event_handler,
-		.frame_handler		= scic_sds_remote_device_default_frame_handler
-	},
-	[SCI_BASE_REMOTE_DEVICE_STATE_STARTING] = {
-		.start_handler		= scic_sds_remote_device_default_start_handler,
-		.stop_handler		= scic_sds_remote_device_starting_state_stop_handler,
-		.fail_handler		= scic_sds_remote_device_default_fail_handler,
-		.destruct_handler	= scic_sds_remote_device_default_destruct_handler,
-		.reset_handler		= scic_sds_remote_device_default_reset_handler,
-		.reset_complete_handler	= scic_sds_remote_device_default_reset_complete_handler,
-		.start_io_handler	= scic_sds_remote_device_default_start_request_handler,
-		.complete_io_handler	= scic_sds_remote_device_default_complete_request_handler,
-		.continue_io_handler	= scic_sds_remote_device_default_continue_request_handler,
-		.start_task_handler	= scic_sds_remote_device_default_start_request_handler,
-		.complete_task_handler	= scic_sds_remote_device_default_complete_request_handler,
-		.suspend_handler	= scic_sds_remote_device_default_suspend_handler,
-		.resume_handler		= scic_sds_remote_device_default_resume_handler,
-		.event_handler		= scic_sds_remote_device_general_event_handler,
-		.frame_handler		= scic_sds_remote_device_default_frame_handler
-	},
-	[SCI_BASE_REMOTE_DEVICE_STATE_READY] = {
-		.start_handler		= scic_sds_remote_device_default_start_handler,
-		.stop_handler		= scic_sds_remote_device_ready_state_stop_handler,
-		.fail_handler		= scic_sds_remote_device_default_fail_handler,
-		.destruct_handler	= scic_sds_remote_device_default_destruct_handler,
-		.reset_handler		= scic_sds_remote_device_ready_state_reset_handler,
-		.reset_complete_handler	= scic_sds_remote_device_default_reset_complete_handler,
-		.start_io_handler	= scic_sds_remote_device_ready_state_start_io_handler,
-		.complete_io_handler	= scic_sds_remote_device_ready_state_complete_request_handler,
-		.continue_io_handler	= scic_sds_remote_device_default_continue_request_handler,
-		.start_task_handler	= scic_sds_remote_device_ready_state_start_task_handler,
-		.complete_task_handler	= scic_sds_remote_device_ready_state_complete_request_handler,
-		.suspend_handler	= scic_sds_remote_device_default_suspend_handler,
-		.resume_handler		= scic_sds_remote_device_default_resume_handler,
-		.event_handler		= scic_sds_remote_device_general_event_handler,
-		.frame_handler		= scic_sds_remote_device_general_frame_handler,
-	},
-	[SCI_BASE_REMOTE_DEVICE_STATE_STOPPING] = {
-		.start_handler		= scic_sds_remote_device_default_start_handler,
-		.stop_handler		= scic_sds_remote_device_stopping_state_stop_handler,
-		.fail_handler		= scic_sds_remote_device_default_fail_handler,
-		.destruct_handler	= scic_sds_remote_device_default_destruct_handler,
-		.reset_handler		= scic_sds_remote_device_default_reset_handler,
-		.reset_complete_handler	= scic_sds_remote_device_default_reset_complete_handler,
-		.start_io_handler	= scic_sds_remote_device_default_start_request_handler,
-		.complete_io_handler	= scic_sds_remote_device_stopping_state_complete_request_handler,
-		.continue_io_handler	= scic_sds_remote_device_default_continue_request_handler,
-		.start_task_handler	= scic_sds_remote_device_default_start_request_handler,
-		.complete_task_handler	= scic_sds_remote_device_stopping_state_complete_request_handler,
-		.suspend_handler	= scic_sds_remote_device_default_suspend_handler,
-		.resume_handler		= scic_sds_remote_device_default_resume_handler,
-		.event_handler		= scic_sds_remote_device_general_event_handler,
-		.frame_handler		= scic_sds_remote_device_general_frame_handler
-	},
-	[SCI_BASE_REMOTE_DEVICE_STATE_FAILED] = {
-		.start_handler		= scic_sds_remote_device_default_start_handler,
-		.stop_handler		= scic_sds_remote_device_default_stop_handler,
-		.fail_handler		= scic_sds_remote_device_default_fail_handler,
-		.destruct_handler	= scic_sds_remote_device_default_destruct_handler,
-		.reset_handler		= scic_sds_remote_device_default_reset_handler,
-		.reset_complete_handler	= scic_sds_remote_device_default_reset_complete_handler,
-		.start_io_handler	= scic_sds_remote_device_default_start_request_handler,
-		.complete_io_handler	= scic_sds_remote_device_default_complete_request_handler,
-		.continue_io_handler	= scic_sds_remote_device_default_continue_request_handler,
-		.start_task_handler	= scic_sds_remote_device_default_start_request_handler,
-		.complete_task_handler	= scic_sds_remote_device_default_complete_request_handler,
-		.suspend_handler	= scic_sds_remote_device_default_suspend_handler,
-		.resume_handler		= scic_sds_remote_device_default_resume_handler,
-		.event_handler		= scic_sds_remote_device_default_event_handler,
-		.frame_handler		= scic_sds_remote_device_general_frame_handler
-	},
-	[SCI_BASE_REMOTE_DEVICE_STATE_RESETTING] = {
-		.start_handler		= scic_sds_remote_device_default_start_handler,
-		.stop_handler		= scic_sds_remote_device_resetting_state_stop_handler,
-		.fail_handler		= scic_sds_remote_device_default_fail_handler,
-		.destruct_handler	= scic_sds_remote_device_default_destruct_handler,
-		.reset_handler		= scic_sds_remote_device_default_reset_handler,
-		.reset_complete_handler	= scic_sds_remote_device_resetting_state_reset_complete_handler,
-		.start_io_handler	= scic_sds_remote_device_default_start_request_handler,
-		.complete_io_handler	= scic_sds_remote_device_resetting_state_complete_request_handler,
-		.continue_io_handler	= scic_sds_remote_device_default_continue_request_handler,
-		.start_task_handler	= scic_sds_remote_device_default_start_request_handler,
-		.complete_task_handler	= scic_sds_remote_device_resetting_state_complete_request_handler,
-		.suspend_handler	= scic_sds_remote_device_default_suspend_handler,
-		.resume_handler		= scic_sds_remote_device_default_resume_handler,
-		.event_handler		= scic_sds_remote_device_default_event_handler,
-		.frame_handler		= scic_sds_remote_device_general_frame_handler
-	},
-	[SCI_BASE_REMOTE_DEVICE_STATE_FINAL] = {
-		.start_handler		= scic_sds_remote_device_default_start_handler,
-		.stop_handler		= scic_sds_remote_device_default_stop_handler,
-		.fail_handler		= scic_sds_remote_device_default_fail_handler,
-		.destruct_handler	= scic_sds_remote_device_default_destruct_handler,
-		.reset_handler		= scic_sds_remote_device_default_reset_handler,
-		.reset_complete_handler	= scic_sds_remote_device_default_reset_complete_handler,
-		.start_io_handler	= scic_sds_remote_device_default_start_request_handler,
-		.complete_io_handler	= scic_sds_remote_device_default_complete_request_handler,
-		.continue_io_handler	= scic_sds_remote_device_default_continue_request_handler,
-		.start_task_handler	= scic_sds_remote_device_default_start_request_handler,
-		.complete_task_handler	= scic_sds_remote_device_default_complete_request_handler,
-		.suspend_handler	= scic_sds_remote_device_default_suspend_handler,
-		.resume_handler		= scic_sds_remote_device_default_resume_handler,
-		.event_handler		= scic_sds_remote_device_default_event_handler,
-		.frame_handler		= scic_sds_remote_device_default_frame_handler
-	}
-};
-
-static void scic_sds_remote_device_initial_state_enter(void *object)
+static enum sci_status scic_sds_stp_remote_device_complete_request(struct scic_sds_remote_device *sci_dev,
+								   struct scic_sds_request *sci_req)
 {
-	struct scic_sds_remote_device *sci_dev = object;
+	enum sci_status status;
 
-	SET_STATE_HANDLER(sci_dev, scic_sds_remote_device_state_handler_table,
-			  SCI_BASE_REMOTE_DEVICE_STATE_INITIAL);
+	status = scic_sds_io_request_complete(sci_req);
+	if (status != SCI_SUCCESS)
+		goto out;
 
-	/* Initial state is a transitional state to the stopped state */
-	sci_base_state_machine_change_state(&sci_dev->state_machine,
-					    SCI_BASE_REMOTE_DEVICE_STATE_STOPPED);
+	status = scic_sds_port_complete_io(sci_dev->owning_port, sci_dev, sci_req);
+	if (status != SCI_SUCCESS)
+		goto out;
+
+	scic_sds_remote_device_decrement_request_count(sci_dev);
+	if (sci_req->sci_status == SCI_FAILURE_REMOTE_DEVICE_RESET_REQUIRED) {
+		/* This request causes hardware error, device needs to be Lun Reset.
+		 * So here we force the state machine to IDLE state so the rest IOs
+		 * can reach RNC state handler, these IOs will be completed by RNC with
+		 * status of "DEVICE_RESET_REQUIRED", instead of "INVALID STATE".
+		 */
+		sci_base_state_machine_change_state(&sci_dev->state_machine,
+						    SCIC_SDS_STP_REMOTE_DEVICE_READY_SUBSTATE_AWAIT_RESET);
+	} else if (scic_sds_remote_device_get_request_count(sci_dev) == 0)
+		sci_base_state_machine_change_state(&sci_dev->state_machine,
+						    SCIC_SDS_STP_REMOTE_DEVICE_READY_SUBSTATE_IDLE);
+
+
+ out:
+	if (status != SCI_SUCCESS)
+		dev_err(scirdev_to_dev(sci_dev),
+			"%s: Port:0x%p Device:0x%p Request:0x%p Status:0x%x "
+			"could not complete\n", __func__, sci_dev->owning_port,
+			sci_dev, sci_req, status);
+
+	return status;
 }
 
-/**
- * isci_remote_device_change_state() - This function gets the status of the
- *    remote_device object.
- * @isci_device: This parameter points to the isci_remote_device object
+/* scic_sds_stp_remote_device_ready_substate_start_request_handler - start stp
+ * @device: The target device a task management request towards to.
+ * @request: The task request.
  *
- * status of the object as a isci_status enum.
+ * This is the READY NCQ substate handler to start task management request. In
+ * this routine, we suspend and resume the RNC.  enum sci_status Always return
+ * SCI_FAILURE_RESET_DEVICE_PARTIAL_SUCCESS status to let
+ * controller_start_task_handler know that the controller can't post TC for
+ * task request yet, instead, when RNC gets resumed, a controller_continue_task
+ * callback will be called.
  */
-void isci_remote_device_change_state(
-	struct isci_remote_device *isci_device,
-	enum isci_status status)
+static enum sci_status scic_sds_stp_remote_device_ready_substate_start_request_handler(
+	struct scic_sds_remote_device *device,
+	struct scic_sds_request *request)
+{
+	enum sci_status status;
+
+	/* Will the port allow the io request to start? */
+	status = device->owning_port->state_handlers->start_io_handler(
+		device->owning_port, device, request);
+	if (status != SCI_SUCCESS)
+		return status;
+
+	status = scic_sds_remote_node_context_start_task(&device->rnc, request);
+	if (status != SCI_SUCCESS)
+		goto out;
+
+	status = request->state_handlers->start_handler(request);
+	if (status != SCI_SUCCESS)
+		goto out;
+
+	/*
+	 * Note: If the remote device state is not IDLE this will replace
+	 * the request that probably resulted in the task management request.
+	 */
+	device->working_request = request;
+	sci_base_state_machine_change_state(&device->state_machine,
+			SCIC_SDS_STP_REMOTE_DEVICE_READY_SUBSTATE_CMD);
+
+	/*
+	 * The remote node context must cleanup the TCi to NCQ mapping table.
+	 * The only way to do this correctly is to either write to the TLCR
+	 * register or to invalidate and repost the RNC. In either case the
+	 * remote node context state machine will take the correct action when
+	 * the remote node context is suspended and later resumed.
+	 */
+	scic_sds_remote_node_context_suspend(&device->rnc,
+			SCI_SOFTWARE_SUSPENSION, NULL, NULL);
+	scic_sds_remote_node_context_resume(&device->rnc,
+			scic_sds_remote_device_continue_request,
+			device);
+
+out:
+	scic_sds_remote_device_start_request(device, request, status);
+	/*
+	 * We need to let the controller start request handler know that it can't
+	 * post TC yet. We will provide a callback function to post TC when RNC gets
+	 * resumed.
+	 */
+	return SCI_FAILURE_RESET_DEVICE_PARTIAL_SUCCESS;
+}
+
+/* handle the start io operation for a sata device that is in the command idle
+ * state. - Evalute the type of IO request to be started - If its an NCQ
+ * request change to NCQ substate - If its any other command change to the CMD
+ * substate
+ *
+ * If this is a softreset we may want to have a different substate.
+ */
+static enum sci_status scic_sds_stp_remote_device_ready_idle_substate_start_io_handler(
+	struct scic_sds_remote_device *sci_dev,
+	struct scic_sds_request *request)
+{
+	enum sci_status status;
+	struct isci_request *isci_request = request->ireq;
+	enum scic_sds_remote_device_states new_state;
+
+	/* Will the port allow the io request to start? */
+	status = sci_dev->owning_port->state_handlers->start_io_handler(
+			sci_dev->owning_port, sci_dev, request);
+	if (status != SCI_SUCCESS)
+		return status;
+
+	status = scic_sds_remote_node_context_start_io(&sci_dev->rnc, request);
+	if (status != SCI_SUCCESS)
+		goto out;
+
+	status = request->state_handlers->start_handler(request);
+	if (status != SCI_SUCCESS)
+		goto out;
+
+	if (isci_sata_get_sat_protocol(isci_request) == SAT_PROTOCOL_FPDMA)
+		new_state = SCIC_SDS_STP_REMOTE_DEVICE_READY_SUBSTATE_NCQ;
+	else {
+		sci_dev->working_request = request;
+		new_state = SCIC_SDS_STP_REMOTE_DEVICE_READY_SUBSTATE_CMD;
+	}
+	sci_base_state_machine_change_state(&sci_dev->state_machine, new_state);
+out:
+	scic_sds_remote_device_start_request(sci_dev, request, status);
+	return status;
+}
+
+
+static enum sci_status scic_sds_stp_remote_device_ready_idle_substate_event_handler(
+	struct scic_sds_remote_device *sci_dev,
+	u32 event_code)
+{
+	enum sci_status status;
+
+	status = scic_sds_remote_device_general_event_handler(sci_dev, event_code);
+	if (status != SCI_SUCCESS)
+		return status;
+
+	/* We pick up suspension events to handle specifically to this state. We
+	 * resume the RNC right away. enum sci_status
+	 */
+	if (scu_get_event_type(event_code) == SCU_EVENT_TYPE_RNC_SUSPEND_TX ||
+	    scu_get_event_type(event_code) == SCU_EVENT_TYPE_RNC_SUSPEND_TX_RX)
+		status = scic_sds_remote_node_context_resume(&sci_dev->rnc, NULL, NULL);
+
+	return status;
+}
+
+static enum sci_status scic_sds_stp_remote_device_ready_ncq_substate_start_io_handler(
+	struct scic_sds_remote_device *sci_dev,
+	struct scic_sds_request *request)
+{
+	enum sci_status status;
+	struct isci_request *isci_request = request->ireq;
+	scic_sds_port_io_request_handler_t start_io;
+
+	if (isci_sata_get_sat_protocol(isci_request) == SAT_PROTOCOL_FPDMA) {
+		start_io = sci_dev->owning_port->state_handlers->start_io_handler;
+		status = start_io(sci_dev->owning_port, sci_dev, request);
+		if (status != SCI_SUCCESS)
+			return status;
+
+		status = scic_sds_remote_node_context_start_io(&sci_dev->rnc, request);
+		if (status != SCI_SUCCESS)
+			return status;
+
+		status = request->state_handlers->start_handler(request);
+
+		scic_sds_remote_device_start_request(sci_dev, request, status);
+	} else
+		status = SCI_FAILURE_INVALID_STATE;
+
+	return status;
+}
+
+static enum sci_status scic_sds_stp_remote_device_ready_ncq_substate_frame_handler(struct scic_sds_remote_device *sci_dev,
+										   u32 frame_index)
+{
+	enum sci_status status;
+	struct sata_fis_header *frame_header;
+	struct scic_sds_controller *scic = sci_dev->owning_port->owning_controller;
+
+	status = scic_sds_unsolicited_frame_control_get_header(&scic->uf_control,
+							       frame_index,
+							       (void **)&frame_header);
+	if (status != SCI_SUCCESS)
+		return status;
+
+	if (frame_header->fis_type == SATA_FIS_TYPE_SETDEVBITS &&
+	    (frame_header->status & ATA_STATUS_REG_ERROR_BIT)) {
+		sci_dev->not_ready_reason = SCIC_REMOTE_DEVICE_NOT_READY_SATA_SDB_ERROR_FIS_RECEIVED;
+
+		/* TODO Check sactive and complete associated IO if any. */
+
+		sci_base_state_machine_change_state(&sci_dev->state_machine,
+						    SCIC_SDS_STP_REMOTE_DEVICE_READY_SUBSTATE_NCQ_ERROR);
+	} else if (frame_header->fis_type == SATA_FIS_TYPE_REGD2H &&
+		   (frame_header->status & ATA_STATUS_REG_ERROR_BIT)) {
+		/*
+		 * Some devices return D2H FIS when an NCQ error is detected.
+		 * Treat this like an SDB error FIS ready reason.
+		 */
+		sci_dev->not_ready_reason = SCIC_REMOTE_DEVICE_NOT_READY_SATA_SDB_ERROR_FIS_RECEIVED;
+
+		sci_base_state_machine_change_state(&sci_dev->state_machine,
+						    SCIC_SDS_STP_REMOTE_DEVICE_READY_SUBSTATE_NCQ_ERROR);
+	} else
+		status = SCI_FAILURE;
+
+	scic_sds_controller_release_frame(scic, frame_index);
+
+	return status;
+}
+
+static enum sci_status scic_sds_stp_remote_device_ready_cmd_substate_start_io_handler(
+	struct scic_sds_remote_device *device,
+	struct scic_sds_request *request)
+{
+	/* device is already handling a command it can not accept new commands
+	 * until this one is complete.
+	 */
+	return SCI_FAILURE_INVALID_STATE;
+}
+
+static enum sci_status scic_sds_stp_remote_device_ready_cmd_substate_suspend_handler(
+	struct scic_sds_remote_device *sci_dev,
+	u32 suspend_type)
+{
+	enum sci_status status;
+
+	status = scic_sds_remote_node_context_suspend(&sci_dev->rnc,
+						      suspend_type, NULL, NULL);
+
+	return status;
+}
+
+static enum sci_status scic_sds_stp_remote_device_ready_cmd_substate_frame_handler(
+	struct scic_sds_remote_device *sci_dev,
+	u32 frame_index)
+{
+	/* The device doe not process any UF received from the hardware while
+	 * in this state.  All unsolicited frames are forwarded to the io
+	 * request object.
+	 */
+	return scic_sds_io_request_frame_handler(sci_dev->working_request,
+						 frame_index);
+}
+
+static enum sci_status scic_sds_stp_remote_device_ready_await_reset_substate_start_io_handler(
+	struct scic_sds_remote_device *device,
+	struct scic_sds_request *request)
+{
+	return SCI_FAILURE_REMOTE_DEVICE_RESET_REQUIRED;
+}
+
+static enum sci_status scic_sds_stp_remote_device_ready_await_reset_substate_complete_request_handler(
+	struct scic_sds_remote_device *device,
+	struct scic_sds_request *request)
+{
+	struct scic_sds_request *sci_req = request;
+	enum sci_status status;
+
+	status = scic_sds_io_request_complete(sci_req);
+	if (status != SCI_SUCCESS)
+		goto out;
+
+	status = scic_sds_port_complete_io(device->owning_port, device, sci_req);
+	if (status != SCI_SUCCESS)
+		goto out;
+
+	scic_sds_remote_device_decrement_request_count(device);
+ out:
+	if (status != SCI_SUCCESS)
+		dev_err(scirdev_to_dev(device),
+			"%s: Port:0x%p Device:0x%p Request:0x%p Status:0x%x "
+			"could not complete\n",
+			__func__, device->owning_port, device, sci_req, status);
+
+	return status;
+}
+
+static void scic_sds_stp_remote_device_ready_idle_substate_resume_complete_handler(void *_dev)
+{
+	struct scic_sds_remote_device *sci_dev = _dev;
+	struct isci_remote_device *idev = sci_dev_to_idev(sci_dev);
+	struct scic_sds_controller *scic = sci_dev->owning_port->owning_controller;
+
+	/* For NCQ operation we do not issue a isci_remote_device_not_ready().
+	 * As a result, avoid sending the ready notification.
+	 */
+	if (sci_dev->state_machine.previous_state_id != SCIC_SDS_STP_REMOTE_DEVICE_READY_SUBSTATE_NCQ)
+		isci_remote_device_ready(scic->ihost, idev);
+}
+
+static enum sci_status scic_sds_smp_remote_device_ready_idle_substate_start_io_handler(
+	struct scic_sds_remote_device *sci_dev,
+	struct scic_sds_request *sci_req)
+{
+	enum sci_status status;
+
+	/* Will the port allow the io request to start? */
+	status = sci_dev->owning_port->state_handlers->start_io_handler(
+			sci_dev->owning_port, sci_dev, sci_req);
+	if (status != SCI_SUCCESS)
+		return status;
+
+	status = scic_sds_remote_node_context_start_io(&sci_dev->rnc, sci_req);
+	if (status != SCI_SUCCESS)
+		return status;
+
+	status = scic_sds_request_start(sci_req);
+	if (status != SCI_SUCCESS)
+		return status;
+
+	sci_dev->working_request = sci_req;
+	sci_base_state_machine_change_state(&sci_dev->state_machine,
+					    SCIC_SDS_SMP_REMOTE_DEVICE_READY_SUBSTATE_CMD);
+
+	scic_sds_remote_device_start_request(sci_dev, sci_req, status);
+
+	return status;
+}
+
+static enum sci_status scic_sds_smp_remote_device_ready_cmd_substate_start_io_handler(
+	struct scic_sds_remote_device *device,
+	struct scic_sds_request *request)
+{
+	/* device is already handling a command it can not accept new commands
+	 * until this one is complete.
+	 */
+	return SCI_FAILURE_INVALID_STATE;
+}
+
+static enum sci_status
+scic_sds_smp_remote_device_ready_cmd_substate_complete_io_handler(struct scic_sds_remote_device *sci_dev,
+								  struct scic_sds_request *sci_req)
+{
+	enum sci_status status;
+
+	status = scic_sds_io_request_complete(sci_req);
+	if (status != SCI_SUCCESS)
+		return status;
+
+	status = scic_sds_port_complete_io(sci_dev->owning_port, sci_dev, sci_req);
+	if (status != SCI_SUCCESS) {
+		dev_err(scirdev_to_dev(sci_dev),
+			"%s: SCIC SDS Remote Device 0x%p io request "
+			"0x%p could not be completd on the port 0x%p "
+			"failed with status %d.\n", __func__, sci_dev, sci_req,
+			sci_dev->owning_port, status);
+		return status;
+	}
+
+	scic_sds_remote_device_decrement_request_count(sci_dev);
+	sci_base_state_machine_change_state(&sci_dev->state_machine,
+					    SCIC_SDS_SMP_REMOTE_DEVICE_READY_SUBSTATE_IDLE);
+
+	return status;
+}
+
+static enum sci_status scic_sds_smp_remote_device_ready_cmd_substate_frame_handler(
+	struct scic_sds_remote_device *sci_dev,
+	u32 frame_index)
+{
+	enum sci_status status;
+
+	/* The device does not process any UF received from the hardware while
+	 * in this state.  All unsolicited frames are forwarded to the io request
+	 * object.
+	 */
+	status = scic_sds_io_request_frame_handler(
+		sci_dev->working_request,
+		frame_index
+		);
+
+	return status;
+}
+
+static const struct scic_sds_remote_device_state_handler scic_sds_remote_device_state_handler_table[] = {
+	[SCI_BASE_REMOTE_DEVICE_STATE_INITIAL] = {
+		.start_handler		= scic_sds_remote_device_default_start_handler,
+		.stop_handler		= scic_sds_remote_device_default_stop_handler,
+		.fail_handler		= scic_sds_remote_device_default_fail_handler,
+		.destruct_handler	= scic_sds_remote_device_default_destruct_handler,
+		.reset_handler		= scic_sds_remote_device_default_reset_handler,
+		.reset_complete_handler	= scic_sds_remote_device_default_reset_complete_handler,
+		.start_io_handler	= scic_sds_remote_device_default_start_request_handler,
+		.complete_io_handler	= scic_sds_remote_device_default_complete_request_handler,
+		.continue_io_handler	= scic_sds_remote_device_default_continue_request_handler,
+		.start_task_handler	= scic_sds_remote_device_default_start_request_handler,
+		.complete_task_handler	= scic_sds_remote_device_default_complete_request_handler,
+		.suspend_handler	= scic_sds_remote_device_default_suspend_handler,
+		.resume_handler		= scic_sds_remote_device_default_resume_handler,
+		.event_handler		= scic_sds_remote_device_default_event_handler,
+		.frame_handler		= scic_sds_remote_device_default_frame_handler
+	},
+	[SCI_BASE_REMOTE_DEVICE_STATE_STOPPED] = {
+		.start_handler		= scic_sds_remote_device_stopped_state_start_handler,
+		.stop_handler		= scic_sds_remote_device_stopped_state_stop_handler,
+		.fail_handler		= scic_sds_remote_device_default_fail_handler,
+		.destruct_handler	= scic_sds_remote_device_stopped_state_destruct_handler,
+		.reset_handler		= scic_sds_remote_device_default_reset_handler,
+		.reset_complete_handler	= scic_sds_remote_device_default_reset_complete_handler,
+		.start_io_handler	= scic_sds_remote_device_default_start_request_handler,
+		.complete_io_handler	= scic_sds_remote_device_default_complete_request_handler,
+		.continue_io_handler	= scic_sds_remote_device_default_continue_request_handler,
+		.start_task_handler	= scic_sds_remote_device_default_start_request_handler,
+		.complete_task_handler	= scic_sds_remote_device_default_complete_request_handler,
+		.suspend_handler	= scic_sds_remote_device_default_suspend_handler,
+		.resume_handler		= scic_sds_remote_device_default_resume_handler,
+		.event_handler		= scic_sds_remote_device_default_event_handler,
+		.frame_handler		= scic_sds_remote_device_default_frame_handler
+	},
+	[SCI_BASE_REMOTE_DEVICE_STATE_STARTING] = {
+		.start_handler		= scic_sds_remote_device_default_start_handler,
+		.stop_handler		= scic_sds_remote_device_starting_state_stop_handler,
+		.fail_handler		= scic_sds_remote_device_default_fail_handler,
+		.destruct_handler	= scic_sds_remote_device_default_destruct_handler,
+		.reset_handler		= scic_sds_remote_device_default_reset_handler,
+		.reset_complete_handler	= scic_sds_remote_device_default_reset_complete_handler,
+		.start_io_handler	= scic_sds_remote_device_default_start_request_handler,
+		.complete_io_handler	= scic_sds_remote_device_default_complete_request_handler,
+		.continue_io_handler	= scic_sds_remote_device_default_continue_request_handler,
+		.start_task_handler	= scic_sds_remote_device_default_start_request_handler,
+		.complete_task_handler	= scic_sds_remote_device_default_complete_request_handler,
+		.suspend_handler	= scic_sds_remote_device_default_suspend_handler,
+		.resume_handler		= scic_sds_remote_device_default_resume_handler,
+		.event_handler		= scic_sds_remote_device_general_event_handler,
+		.frame_handler		= scic_sds_remote_device_default_frame_handler
+	},
+	[SCI_BASE_REMOTE_DEVICE_STATE_READY] = {
+		.start_handler		= scic_sds_remote_device_default_start_handler,
+		.stop_handler		= scic_sds_remote_device_ready_state_stop_handler,
+		.fail_handler		= scic_sds_remote_device_default_fail_handler,
+		.destruct_handler	= scic_sds_remote_device_default_destruct_handler,
+		.reset_handler		= scic_sds_remote_device_ready_state_reset_handler,
+		.reset_complete_handler	= scic_sds_remote_device_default_reset_complete_handler,
+		.start_io_handler	= scic_sds_remote_device_ready_state_start_io_handler,
+		.complete_io_handler	= scic_sds_remote_device_ready_state_complete_request_handler,
+		.continue_io_handler	= scic_sds_remote_device_default_continue_request_handler,
+		.start_task_handler	= scic_sds_remote_device_ready_state_start_task_handler,
+		.complete_task_handler	= scic_sds_remote_device_ready_state_complete_request_handler,
+		.suspend_handler	= scic_sds_remote_device_default_suspend_handler,
+		.resume_handler		= scic_sds_remote_device_default_resume_handler,
+		.event_handler		= scic_sds_remote_device_general_event_handler,
+		.frame_handler		= scic_sds_remote_device_general_frame_handler,
+	},
+	[SCIC_SDS_STP_REMOTE_DEVICE_READY_SUBSTATE_IDLE] = {
+		.start_handler		= scic_sds_remote_device_default_start_handler,
+		.stop_handler		= scic_sds_remote_device_ready_state_stop_handler,
+		.fail_handler		= scic_sds_remote_device_default_fail_handler,
+		.destruct_handler	= scic_sds_remote_device_default_destruct_handler,
+		.reset_handler		= scic_sds_remote_device_ready_state_reset_handler,
+		.reset_complete_handler	= scic_sds_remote_device_default_reset_complete_handler,
+		.start_io_handler	= scic_sds_stp_remote_device_ready_idle_substate_start_io_handler,
+		.complete_io_handler	= scic_sds_remote_device_default_complete_request_handler,
+		.continue_io_handler	= scic_sds_remote_device_default_continue_request_handler,
+		.start_task_handler	= scic_sds_stp_remote_device_ready_substate_start_request_handler,
+		.complete_task_handler	= scic_sds_remote_device_default_complete_request_handler,
+		.suspend_handler		= scic_sds_remote_device_default_suspend_handler,
+		.resume_handler			= scic_sds_remote_device_default_resume_handler,
+		.event_handler			= scic_sds_stp_remote_device_ready_idle_substate_event_handler,
+		.frame_handler			= scic_sds_remote_device_default_frame_handler
+	},
+	[SCIC_SDS_STP_REMOTE_DEVICE_READY_SUBSTATE_CMD] = {
+		.start_handler		= scic_sds_remote_device_default_start_handler,
+		.stop_handler		= scic_sds_remote_device_ready_state_stop_handler,
+		.fail_handler		= scic_sds_remote_device_default_fail_handler,
+		.destruct_handler	= scic_sds_remote_device_default_destruct_handler,
+		.reset_handler		= scic_sds_remote_device_ready_state_reset_handler,
+		.reset_complete_handler	= scic_sds_remote_device_default_reset_complete_handler,
+		.start_io_handler	= scic_sds_stp_remote_device_ready_cmd_substate_start_io_handler,
+		.complete_io_handler	= scic_sds_stp_remote_device_complete_request,
+		.continue_io_handler	= scic_sds_remote_device_default_continue_request_handler,
+		.start_task_handler	= scic_sds_stp_remote_device_ready_substate_start_request_handler,
+		.complete_task_handler	= scic_sds_stp_remote_device_complete_request,
+		.suspend_handler		= scic_sds_stp_remote_device_ready_cmd_substate_suspend_handler,
+		.resume_handler			= scic_sds_remote_device_default_resume_handler,
+		.event_handler			= scic_sds_remote_device_general_event_handler,
+		.frame_handler			= scic_sds_stp_remote_device_ready_cmd_substate_frame_handler
+	},
+	[SCIC_SDS_STP_REMOTE_DEVICE_READY_SUBSTATE_NCQ] = {
+		.start_handler		= scic_sds_remote_device_default_start_handler,
+		.stop_handler		= scic_sds_remote_device_ready_state_stop_handler,
+		.fail_handler		= scic_sds_remote_device_default_fail_handler,
+		.destruct_handler	= scic_sds_remote_device_default_destruct_handler,
+		.reset_handler		= scic_sds_remote_device_ready_state_reset_handler,
+		.reset_complete_handler	= scic_sds_remote_device_default_reset_complete_handler,
+		.start_io_handler	= scic_sds_stp_remote_device_ready_ncq_substate_start_io_handler,
+		.complete_io_handler	= scic_sds_stp_remote_device_complete_request,
+		.continue_io_handler	= scic_sds_remote_device_default_continue_request_handler,
+		.start_task_handler	= scic_sds_stp_remote_device_ready_substate_start_request_handler,
+		.complete_task_handler	= scic_sds_stp_remote_device_complete_request,
+		.suspend_handler		= scic_sds_remote_device_default_suspend_handler,
+		.resume_handler			= scic_sds_remote_device_default_resume_handler,
+		.event_handler			= scic_sds_remote_device_general_event_handler,
+		.frame_handler			= scic_sds_stp_remote_device_ready_ncq_substate_frame_handler
+	},
+	[SCIC_SDS_STP_REMOTE_DEVICE_READY_SUBSTATE_NCQ_ERROR] = {
+		.start_handler		= scic_sds_remote_device_default_start_handler,
+		.stop_handler		= scic_sds_remote_device_ready_state_stop_handler,
+		.fail_handler		= scic_sds_remote_device_default_fail_handler,
+		.destruct_handler	= scic_sds_remote_device_default_destruct_handler,
+		.reset_handler		= scic_sds_remote_device_ready_state_reset_handler,
+		.reset_complete_handler	= scic_sds_remote_device_default_reset_complete_handler,
+		.start_io_handler	= scic_sds_remote_device_default_start_request_handler,
+		.complete_io_handler	= scic_sds_stp_remote_device_complete_request,
+		.continue_io_handler	= scic_sds_remote_device_default_continue_request_handler,
+		.start_task_handler	= scic_sds_stp_remote_device_ready_substate_start_request_handler,
+		.complete_task_handler	= scic_sds_stp_remote_device_complete_request,
+		.suspend_handler		= scic_sds_remote_device_default_suspend_handler,
+		.resume_handler			= scic_sds_remote_device_default_resume_handler,
+		.event_handler			= scic_sds_remote_device_general_event_handler,
+		.frame_handler			= scic_sds_remote_device_general_frame_handler
+	},
+	[SCIC_SDS_STP_REMOTE_DEVICE_READY_SUBSTATE_AWAIT_RESET] = {
+		.start_handler		= scic_sds_remote_device_default_start_handler,
+		.stop_handler		= scic_sds_remote_device_ready_state_stop_handler,
+		.fail_handler		= scic_sds_remote_device_default_fail_handler,
+		.destruct_handler	= scic_sds_remote_device_default_destruct_handler,
+		.reset_handler		= scic_sds_remote_device_ready_state_reset_handler,
+		.reset_complete_handler	= scic_sds_remote_device_default_reset_complete_handler,
+		.start_io_handler	= scic_sds_stp_remote_device_ready_await_reset_substate_start_io_handler,
+		.complete_io_handler	= scic_sds_stp_remote_device_ready_await_reset_substate_complete_request_handler,
+		.continue_io_handler	= scic_sds_remote_device_default_continue_request_handler,
+		.start_task_handler	= scic_sds_stp_remote_device_ready_substate_start_request_handler,
+		.complete_task_handler	= scic_sds_stp_remote_device_complete_request,
+		.suspend_handler		= scic_sds_remote_device_default_suspend_handler,
+		.resume_handler			= scic_sds_remote_device_default_resume_handler,
+		.event_handler			= scic_sds_remote_device_general_event_handler,
+		.frame_handler			= scic_sds_remote_device_general_frame_handler
+	},
+	[SCIC_SDS_SMP_REMOTE_DEVICE_READY_SUBSTATE_IDLE] = {
+		.start_handler		= scic_sds_remote_device_default_start_handler,
+		.stop_handler		= scic_sds_remote_device_ready_state_stop_handler,
+		.fail_handler		= scic_sds_remote_device_default_fail_handler,
+		.destruct_handler	= scic_sds_remote_device_default_destruct_handler,
+		.reset_handler		= scic_sds_remote_device_default_reset_handler,
+		.reset_complete_handler	= scic_sds_remote_device_default_reset_complete_handler,
+		.start_io_handler	= scic_sds_smp_remote_device_ready_idle_substate_start_io_handler,
+		.complete_io_handler	= scic_sds_remote_device_default_complete_request_handler,
+		.continue_io_handler	= scic_sds_remote_device_default_continue_request_handler,
+		.start_task_handler	= scic_sds_remote_device_default_start_request_handler,
+		.complete_task_handler	= scic_sds_remote_device_default_complete_request_handler,
+		.suspend_handler	= scic_sds_remote_device_default_suspend_handler,
+		.resume_handler		= scic_sds_remote_device_default_resume_handler,
+		.event_handler		= scic_sds_remote_device_general_event_handler,
+		.frame_handler		= scic_sds_remote_device_default_frame_handler
+	},
+	[SCIC_SDS_SMP_REMOTE_DEVICE_READY_SUBSTATE_CMD] = {
+		.start_handler		= scic_sds_remote_device_default_start_handler,
+		.stop_handler		= scic_sds_remote_device_ready_state_stop_handler,
+		.fail_handler		= scic_sds_remote_device_default_fail_handler,
+		.destruct_handler	= scic_sds_remote_device_default_destruct_handler,
+		.reset_handler		= scic_sds_remote_device_default_reset_handler,
+		.reset_complete_handler	= scic_sds_remote_device_default_reset_complete_handler,
+		.start_io_handler	= scic_sds_smp_remote_device_ready_cmd_substate_start_io_handler,
+		.complete_io_handler	= scic_sds_smp_remote_device_ready_cmd_substate_complete_io_handler,
+		.continue_io_handler	= scic_sds_remote_device_default_continue_request_handler,
+		.start_task_handler	= scic_sds_remote_device_default_start_request_handler,
+		.complete_task_handler	= scic_sds_remote_device_default_complete_request_handler,
+		.suspend_handler	= scic_sds_remote_device_default_suspend_handler,
+		.resume_handler		= scic_sds_remote_device_default_resume_handler,
+		.event_handler		= scic_sds_remote_device_general_event_handler,
+		.frame_handler		= scic_sds_smp_remote_device_ready_cmd_substate_frame_handler
+	},
+	[SCI_BASE_REMOTE_DEVICE_STATE_STOPPING] = {
+		.start_handler		= scic_sds_remote_device_default_start_handler,
+		.stop_handler		= scic_sds_remote_device_stopping_state_stop_handler,
+		.fail_handler		= scic_sds_remote_device_default_fail_handler,
+		.destruct_handler	= scic_sds_remote_device_default_destruct_handler,
+		.reset_handler		= scic_sds_remote_device_default_reset_handler,
+		.reset_complete_handler	= scic_sds_remote_device_default_reset_complete_handler,
+		.start_io_handler	= scic_sds_remote_device_default_start_request_handler,
+		.complete_io_handler	= scic_sds_remote_device_stopping_state_complete_request_handler,
+		.continue_io_handler	= scic_sds_remote_device_default_continue_request_handler,
+		.start_task_handler	= scic_sds_remote_device_default_start_request_handler,
+		.complete_task_handler	= scic_sds_remote_device_stopping_state_complete_request_handler,
+		.suspend_handler	= scic_sds_remote_device_default_suspend_handler,
+		.resume_handler		= scic_sds_remote_device_default_resume_handler,
+		.event_handler		= scic_sds_remote_device_general_event_handler,
+		.frame_handler		= scic_sds_remote_device_general_frame_handler
+	},
+	[SCI_BASE_REMOTE_DEVICE_STATE_FAILED] = {
+		.start_handler		= scic_sds_remote_device_default_start_handler,
+		.stop_handler		= scic_sds_remote_device_default_stop_handler,
+		.fail_handler		= scic_sds_remote_device_default_fail_handler,
+		.destruct_handler	= scic_sds_remote_device_default_destruct_handler,
+		.reset_handler		= scic_sds_remote_device_default_reset_handler,
+		.reset_complete_handler	= scic_sds_remote_device_default_reset_complete_handler,
+		.start_io_handler	= scic_sds_remote_device_default_start_request_handler,
+		.complete_io_handler	= scic_sds_remote_device_default_complete_request_handler,
+		.continue_io_handler	= scic_sds_remote_device_default_continue_request_handler,
+		.start_task_handler	= scic_sds_remote_device_default_start_request_handler,
+		.complete_task_handler	= scic_sds_remote_device_default_complete_request_handler,
+		.suspend_handler	= scic_sds_remote_device_default_suspend_handler,
+		.resume_handler		= scic_sds_remote_device_default_resume_handler,
+		.event_handler		= scic_sds_remote_device_default_event_handler,
+		.frame_handler		= scic_sds_remote_device_general_frame_handler
+	},
+	[SCI_BASE_REMOTE_DEVICE_STATE_RESETTING] = {
+		.start_handler		= scic_sds_remote_device_default_start_handler,
+		.stop_handler		= scic_sds_remote_device_resetting_state_stop_handler,
+		.fail_handler		= scic_sds_remote_device_default_fail_handler,
+		.destruct_handler	= scic_sds_remote_device_default_destruct_handler,
+		.reset_handler		= scic_sds_remote_device_default_reset_handler,
+		.reset_complete_handler	= scic_sds_remote_device_resetting_state_reset_complete_handler,
+		.start_io_handler	= scic_sds_remote_device_default_start_request_handler,
+		.complete_io_handler	= scic_sds_remote_device_resetting_state_complete_request_handler,
+		.continue_io_handler	= scic_sds_remote_device_default_continue_request_handler,
+		.start_task_handler	= scic_sds_remote_device_default_start_request_handler,
+		.complete_task_handler	= scic_sds_remote_device_resetting_state_complete_request_handler,
+		.suspend_handler	= scic_sds_remote_device_default_suspend_handler,
+		.resume_handler		= scic_sds_remote_device_default_resume_handler,
+		.event_handler		= scic_sds_remote_device_default_event_handler,
+		.frame_handler		= scic_sds_remote_device_general_frame_handler
+	},
+	[SCI_BASE_REMOTE_DEVICE_STATE_FINAL] = {
+		.start_handler		= scic_sds_remote_device_default_start_handler,
+		.stop_handler		= scic_sds_remote_device_default_stop_handler,
+		.fail_handler		= scic_sds_remote_device_default_fail_handler,
+		.destruct_handler	= scic_sds_remote_device_default_destruct_handler,
+		.reset_handler		= scic_sds_remote_device_default_reset_handler,
+		.reset_complete_handler	= scic_sds_remote_device_default_reset_complete_handler,
+		.start_io_handler	= scic_sds_remote_device_default_start_request_handler,
+		.complete_io_handler	= scic_sds_remote_device_default_complete_request_handler,
+		.continue_io_handler	= scic_sds_remote_device_default_continue_request_handler,
+		.start_task_handler	= scic_sds_remote_device_default_start_request_handler,
+		.complete_task_handler	= scic_sds_remote_device_default_complete_request_handler,
+		.suspend_handler	= scic_sds_remote_device_default_suspend_handler,
+		.resume_handler		= scic_sds_remote_device_default_resume_handler,
+		.event_handler		= scic_sds_remote_device_default_event_handler,
+		.frame_handler		= scic_sds_remote_device_default_frame_handler
+	}
+};
+
+static void scic_sds_remote_device_initial_state_enter(void *object)
 {
-	unsigned long flags;
+	struct scic_sds_remote_device *sci_dev = object;
 
-	spin_lock_irqsave(&isci_device->state_lock, flags);
-	isci_device->status = status;
-	spin_unlock_irqrestore(&isci_device->state_lock, flags);
+	SET_STATE_HANDLER(sci_dev, scic_sds_remote_device_state_handler_table,
+			  SCI_BASE_REMOTE_DEVICE_STATE_INITIAL);
+
+	/* Initial state is a transitional state to the stopped state */
+	sci_base_state_machine_change_state(&sci_dev->state_machine,
+					    SCI_BASE_REMOTE_DEVICE_STATE_STOPPED);
 }
 
 /**
@@ -1242,9 +1768,8 @@ static void scic_sds_remote_device_starting_state_enter(void *object)
 static void scic_sds_remote_device_ready_state_enter(void *object)
 {
 	struct scic_sds_remote_device *sci_dev = object;
-	struct scic_sds_controller *scic = scic_sds_remote_device_get_controller(sci_dev);
-	struct isci_host *ihost = scic->ihost;
-	struct isci_remote_device *idev = sci_dev_to_idev(sci_dev);
+	struct scic_sds_controller *scic = sci_dev->owning_port->owning_controller;
+	struct domain_device *dev = sci_dev_to_domain(sci_dev);
 
 	SET_STATE_HANDLER(sci_dev,
 			  scic_sds_remote_device_state_handler_table,
@@ -1252,23 +1777,26 @@ static void scic_sds_remote_device_ready_state_enter(void *object)
 
 	scic->remote_device_sequence[sci_dev->rnc.remote_node_index]++;
 
-	if (sci_dev->has_ready_substate_machine)
-		sci_base_state_machine_start(&sci_dev->ready_substate_machine);
-	else
-		isci_remote_device_ready(ihost, idev);
+	if (dev->dev_type == SATA_DEV || (dev->tproto & SAS_PROTOCOL_SATA)) {
+		sci_base_state_machine_change_state(&sci_dev->state_machine,
+						    SCIC_SDS_STP_REMOTE_DEVICE_READY_SUBSTATE_IDLE);
+	} else if (dev_is_expander(dev)) {
+		sci_base_state_machine_change_state(&sci_dev->state_machine,
+						    SCIC_SDS_SMP_REMOTE_DEVICE_READY_SUBSTATE_IDLE);
+	} else
+		isci_remote_device_ready(scic->ihost, sci_dev_to_idev(sci_dev));
 }
 
 static void scic_sds_remote_device_ready_state_exit(void *object)
 {
 	struct scic_sds_remote_device *sci_dev = object;
-	if (sci_dev->has_ready_substate_machine)
-		sci_base_state_machine_stop(&sci_dev->ready_substate_machine);
-	else {
-		struct scic_sds_controller *scic = scic_sds_remote_device_get_controller(sci_dev);
-		struct isci_host *ihost = scic->ihost;
+	struct domain_device *dev = sci_dev_to_domain(sci_dev);
+
+	if (dev->dev_type == SAS_END_DEV) {
+		struct scic_sds_controller *scic = sci_dev->owning_port->owning_controller;
 		struct isci_remote_device *idev = sci_dev_to_idev(sci_dev);
 
-		isci_remote_device_not_ready(ihost, idev,
+		isci_remote_device_not_ready(scic->ihost, idev,
 					     SCIC_REMOTE_DEVICE_NOT_READY_STOP_REQUESTED);
 	}
 }
@@ -1327,6 +1855,101 @@ static void scic_sds_remote_device_final_state_enter(void *object)
 		);
 }
 
+static void scic_sds_stp_remote_device_ready_idle_substate_enter(void *object)
+{
+	struct scic_sds_remote_device *sci_dev = object;
+
+	SET_STATE_HANDLER(sci_dev, scic_sds_remote_device_state_handler_table,
+			  SCIC_SDS_STP_REMOTE_DEVICE_READY_SUBSTATE_IDLE);
+
+	sci_dev->working_request = NULL;
+	if (scic_sds_remote_node_context_is_ready(&sci_dev->rnc)) {
+		/*
+		 * Since the RNC is ready, it's alright to finish completion
+		 * processing (e.g. signal the remote device is ready). */
+		scic_sds_stp_remote_device_ready_idle_substate_resume_complete_handler(sci_dev);
+	} else {
+		scic_sds_remote_node_context_resume(&sci_dev->rnc,
+			scic_sds_stp_remote_device_ready_idle_substate_resume_complete_handler,
+			sci_dev);
+	}
+}
+
+static void scic_sds_stp_remote_device_ready_cmd_substate_enter(void *object)
+{
+	struct scic_sds_remote_device *sci_dev = object;
+	struct scic_sds_controller *scic = scic_sds_remote_device_get_controller(sci_dev);
+
+	BUG_ON(sci_dev->working_request == NULL);
+
+	SET_STATE_HANDLER(sci_dev, scic_sds_remote_device_state_handler_table,
+			  SCIC_SDS_STP_REMOTE_DEVICE_READY_SUBSTATE_CMD);
+
+	isci_remote_device_not_ready(scic->ihost, sci_dev_to_idev(sci_dev),
+				     SCIC_REMOTE_DEVICE_NOT_READY_SATA_REQUEST_STARTED);
+}
+
+static void scic_sds_stp_remote_device_ready_ncq_substate_enter(void *object)
+{
+	struct scic_sds_remote_device *sci_dev = object;
+
+	SET_STATE_HANDLER(sci_dev, scic_sds_remote_device_state_handler_table,
+			  SCIC_SDS_STP_REMOTE_DEVICE_READY_SUBSTATE_NCQ);
+}
+
+static void scic_sds_stp_remote_device_ready_ncq_error_substate_enter(void *object)
+{
+	struct scic_sds_remote_device *sci_dev = object;
+	struct scic_sds_controller *scic = scic_sds_remote_device_get_controller(sci_dev);
+	struct isci_remote_device *idev = sci_dev_to_idev(sci_dev);
+
+	SET_STATE_HANDLER(sci_dev, scic_sds_remote_device_state_handler_table,
+			  SCIC_SDS_STP_REMOTE_DEVICE_READY_SUBSTATE_NCQ_ERROR);
+
+	if (sci_dev->not_ready_reason == SCIC_REMOTE_DEVICE_NOT_READY_SATA_SDB_ERROR_FIS_RECEIVED)
+		isci_remote_device_not_ready(scic->ihost, idev,
+					     sci_dev->not_ready_reason);
+}
+
+static void scic_sds_stp_remote_device_ready_await_reset_substate_enter(void *object)
+{
+	struct scic_sds_remote_device *sci_dev = object;
+
+	SET_STATE_HANDLER(sci_dev, scic_sds_remote_device_state_handler_table,
+		SCIC_SDS_STP_REMOTE_DEVICE_READY_SUBSTATE_AWAIT_RESET);
+}
+
+static void scic_sds_smp_remote_device_ready_idle_substate_enter(void *object)
+{
+	struct scic_sds_remote_device *sci_dev = object;
+	struct scic_sds_controller *scic = scic_sds_remote_device_get_controller(sci_dev);
+
+	SET_STATE_HANDLER(sci_dev, scic_sds_remote_device_state_handler_table,
+			  SCIC_SDS_SMP_REMOTE_DEVICE_READY_SUBSTATE_IDLE);
+
+	isci_remote_device_ready(scic->ihost, sci_dev_to_idev(sci_dev));
+}
+
+static void scic_sds_smp_remote_device_ready_cmd_substate_enter(void *object)
+{
+	struct scic_sds_remote_device *sci_dev = object;
+	struct scic_sds_controller *scic = scic_sds_remote_device_get_controller(sci_dev);
+
+	BUG_ON(sci_dev->working_request == NULL);
+
+	SET_STATE_HANDLER(sci_dev, scic_sds_remote_device_state_handler_table,
+			  SCIC_SDS_SMP_REMOTE_DEVICE_READY_SUBSTATE_CMD);
+
+	isci_remote_device_not_ready(scic->ihost, sci_dev_to_idev(sci_dev),
+				     SCIC_REMOTE_DEVICE_NOT_READY_SMP_REQUEST_STARTED);
+}
+
+static void scic_sds_smp_remote_device_ready_cmd_substate_exit(void *object)
+{
+	struct scic_sds_remote_device *sci_dev = object;
+
+	sci_dev->working_request = NULL;
+}
 
 static const struct sci_base_state scic_sds_remote_device_state_table[] = {
 	[SCI_BASE_REMOTE_DEVICE_STATE_INITIAL] = {
@@ -1342,6 +1965,28 @@ static const struct sci_base_state scic_sds_remote_device_state_table[] = {
 		.enter_state = scic_sds_remote_device_ready_state_enter,
 		.exit_state  = scic_sds_remote_device_ready_state_exit
 	},
+	[SCIC_SDS_STP_REMOTE_DEVICE_READY_SUBSTATE_IDLE] = {
+		.enter_state = scic_sds_stp_remote_device_ready_idle_substate_enter,
+	},
+	[SCIC_SDS_STP_REMOTE_DEVICE_READY_SUBSTATE_CMD] = {
+		.enter_state = scic_sds_stp_remote_device_ready_cmd_substate_enter,
+	},
+	[SCIC_SDS_STP_REMOTE_DEVICE_READY_SUBSTATE_NCQ] = {
+		.enter_state = scic_sds_stp_remote_device_ready_ncq_substate_enter,
+	},
+	[SCIC_SDS_STP_REMOTE_DEVICE_READY_SUBSTATE_NCQ_ERROR] = {
+		.enter_state = scic_sds_stp_remote_device_ready_ncq_error_substate_enter,
+	},
+	[SCIC_SDS_STP_REMOTE_DEVICE_READY_SUBSTATE_AWAIT_RESET] = {
+		.enter_state = scic_sds_stp_remote_device_ready_await_reset_substate_enter,
+	},
+	[SCIC_SDS_SMP_REMOTE_DEVICE_READY_SUBSTATE_IDLE] = {
+		.enter_state = scic_sds_smp_remote_device_ready_idle_substate_enter,
+	},
+	[SCIC_SDS_SMP_REMOTE_DEVICE_READY_SUBSTATE_CMD] = {
+		.enter_state = scic_sds_smp_remote_device_ready_cmd_substate_enter,
+		.exit_state  = scic_sds_smp_remote_device_ready_cmd_substate_exit,
+	},
 	[SCI_BASE_REMOTE_DEVICE_STATE_STOPPING] = {
 		.enter_state = scic_sds_remote_device_stopping_state_enter,
 	},
@@ -1406,7 +2051,6 @@ static enum sci_status scic_remote_device_da_construct(struct scic_sds_port *sci
 						       struct scic_sds_remote_device *sci_dev)
 {
 	enum sci_status status;
-	u16 remote_node_index;
 	struct domain_device *dev = sci_dev_to_domain(sci_dev);
 
 	scic_remote_device_construct(sci_port, sci_dev);
@@ -1418,33 +2062,15 @@ static enum sci_status scic_remote_device_da_construct(struct scic_sds_port *sci
 	sci_dev->is_direct_attached = true;
 	status = scic_sds_controller_allocate_remote_node_context(sci_port->owning_controller,
 								  sci_dev,
-								  &remote_node_index);
+								  &sci_dev->rnc.remote_node_index);
 
 	if (status != SCI_SUCCESS)
 		return status;
 
-	sci_dev->rnc.remote_node_index = remote_node_index;
-
-	if (dev->dev_type == SAS_END_DEV)
-		sci_dev->has_ready_substate_machine = false;
-	else if (dev->dev_type == SATA_DEV || (dev->tproto & SAS_PROTOCOL_STP)) {
-		sci_dev->has_ready_substate_machine = true;
-
-		sci_base_state_machine_construct(
-				&sci_dev->ready_substate_machine,
-				sci_dev,
-				scic_sds_stp_remote_device_ready_substate_table,
-				SCIC_SDS_STP_REMOTE_DEVICE_READY_SUBSTATE_IDLE);
-	} else if (dev_is_expander(dev)) {
-		sci_dev->has_ready_substate_machine = true;
-
-		/* add the SMP ready substate machine construction here */
-		sci_base_state_machine_construct(
-				&sci_dev->ready_substate_machine,
-				sci_dev,
-				scic_sds_smp_remote_device_ready_substate_table,
-				SCIC_SDS_SMP_REMOTE_DEVICE_READY_SUBSTATE_IDLE);
-	} else
+	if (dev->dev_type == SAS_END_DEV || dev->dev_type == SATA_DEV ||
+	    (dev->tproto & SAS_PROTOCOL_STP) || dev_is_expander(dev))
+		/* pass */;
+	else
 		return SCI_FAILURE_UNSUPPORTED_PROTOCOL;
 
 	sci_dev->connection_rate = scic_sds_port_get_max_allowed_speed(sci_port);
@@ -1470,37 +2096,22 @@ static enum sci_status scic_remote_device_da_construct(struct scic_sds_port *sci
 static enum sci_status scic_remote_device_ea_construct(struct scic_sds_port *sci_port,
 						       struct scic_sds_remote_device *sci_dev)
 {
-	struct scic_sds_controller *scic = sci_port->owning_controller;
 	struct domain_device *dev = sci_dev_to_domain(sci_dev);
 	enum sci_status status;
 
 	scic_remote_device_construct(sci_port, sci_dev);
 
-	status = scic_sds_controller_allocate_remote_node_context(
-		scic, sci_dev, &sci_dev->rnc.remote_node_index);
+	status = scic_sds_controller_allocate_remote_node_context(sci_port->owning_controller,
+								  sci_dev,
+								  &sci_dev->rnc.remote_node_index);
 	if (status != SCI_SUCCESS)
 		return status;
 
-	if (dev->dev_type == SAS_END_DEV)
-		sci_dev->has_ready_substate_machine = false;
-	else if (dev_is_expander(dev)) {
-		sci_dev->has_ready_substate_machine = true;
-
-		/* add the SMP ready substate machine construction here */
-		sci_base_state_machine_construct(
-				&sci_dev->ready_substate_machine,
-				sci_dev,
-				scic_sds_smp_remote_device_ready_substate_table,
-				SCIC_SDS_SMP_REMOTE_DEVICE_READY_SUBSTATE_IDLE);
-	} else if (dev->dev_type == SATA_DEV || (dev->tproto & SAS_PROTOCOL_STP)) {
-		sci_dev->has_ready_substate_machine = true;
-
-		sci_base_state_machine_construct(
-				&sci_dev->ready_substate_machine,
-				sci_dev,
-				scic_sds_stp_remote_device_ready_substate_table,
-				SCIC_SDS_STP_REMOTE_DEVICE_READY_SUBSTATE_IDLE);
-	}
+	if (dev->dev_type == SAS_END_DEV || dev->dev_type == SATA_DEV ||
+	    (dev->tproto & SAS_PROTOCOL_STP) || dev_is_expander(dev))
+		/* pass */;
+	else
+		return SCI_FAILURE_UNSUPPORTED_PROTOCOL;
 
 	/*
 	 * For SAS-2 the physical link rate is actually a logical link
@@ -1515,7 +2126,7 @@ static enum sci_status scic_remote_device_ea_construct(struct scic_sds_port *sci
 	/* / @todo Should I assign the port width by reading all of the phys on the port? */
 	sci_dev->device_port_width = 1;
 
-	return status;
+	return SCI_SUCCESS;
 }
 
 /**
@@ -1617,45 +2228,6 @@ isci_remote_device_alloc(struct isci_host *ihost, struct isci_port *iport)
 	return idev;
 }
 
-/**
- * isci_remote_device_ready() - This function is called by the scic when the
- *    remote device is ready. We mark the isci device as ready and signal the
- *    waiting proccess.
- * @ihost: our valid isci_host
- * @idev: remote device
- *
- */
-void isci_remote_device_ready(struct isci_host *ihost, struct isci_remote_device *idev)
-{
-	dev_dbg(&ihost->pdev->dev,
-		"%s: idev = %p\n", __func__, idev);
-
-	isci_remote_device_change_state(idev, isci_ready_for_io);
-	if (test_and_clear_bit(IDEV_START_PENDING, &idev->flags))
-		wake_up(&ihost->eventq);
-}
-
-/**
- * isci_remote_device_not_ready() - This function is called by the scic when
- *    the remote device is not ready. We mark the isci device as ready (not
- *    "ready_for_io") and signal the waiting proccess.
- * @isci_host: This parameter specifies the isci host object.
- * @isci_device: This parameter specifies the remote device
- *
- */
-void isci_remote_device_not_ready(struct isci_host *ihost,
-				  struct isci_remote_device *idev, u32 reason)
-{
-	dev_dbg(&ihost->pdev->dev,
-		"%s: isci_device = %p\n", __func__, idev);
-
-	if (reason == SCIC_REMOTE_DEVICE_NOT_READY_STOP_REQUESTED)
-		isci_remote_device_change_state(idev, isci_stopping);
-	else
-		/* device ready is actually a "not ready for io" state. */
-		isci_remote_device_change_state(idev, isci_ready);
-}
-
 /**
  * isci_remote_device_stop() - This function is called internally to stop the
  *    remote device.

commit af23e85737253624cde84704008be40355ff6922
Author: Maciej Patelczyk <maciej.patelczyk@intel.com>
Date:   Thu Apr 28 22:06:26 2011 +0000

    isci: Removed sci_base_object from scic_sds_remote_node_context.
    
    The 'struct sci_base_object' was removed from the struct
    scic_sds_remote_node_context.
    
    Signed-off-by: Maciej Patelczyk <maciej.patelczyk@intel.com>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/drivers/scsi/isci/remote_device.c b/drivers/scsi/isci/remote_device.c
index 3fc66b2a5992..2bbc7c20c400 100644
--- a/drivers/scsi/isci/remote_device.c
+++ b/drivers/scsi/isci/remote_device.c
@@ -1386,8 +1386,6 @@ static void scic_remote_device_construct(struct scic_sds_port *sci_port,
 
 	scic_sds_remote_node_context_construct(&sci_dev->rnc,
 					       SCIC_SDS_REMOTE_NODE_CONTEXT_INVALID_INDEX);
-
-	sci_object_set_association(&sci_dev->rnc, sci_dev);
 }
 
 /**

commit 5d937e966d383c4012c19b0e47dc196ba505eb19
Author: Maciej Patelczyk <maciej.patelczyk@intel.com>
Date:   Thu Apr 28 22:06:21 2011 +0000

    isci: Removed sci_base_object from scic_sds_remote_device.
    
    The 'struct sci_base_object' was removed from the struct
    scic_sds_remote_device.
    
    Signed-off-by: Maciej Patelczyk <maciej.patelczyk@intel.com>
    [cleaned up sci_dev_to_idev]
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/drivers/scsi/isci/remote_device.c b/drivers/scsi/isci/remote_device.c
index bb696cf11f2c..3fc66b2a5992 100644
--- a/drivers/scsi/isci/remote_device.c
+++ b/drivers/scsi/isci/remote_device.c
@@ -1101,9 +1101,8 @@ static const struct scic_sds_remote_device_state_handler scic_sds_remote_device_
 
 static void scic_sds_remote_device_initial_state_enter(void *object)
 {
-	struct scic_sds_remote_device *sci_dev = (struct scic_sds_remote_device *)object;
+	struct scic_sds_remote_device *sci_dev = object;
 
-	sci_dev = container_of(object, typeof(*sci_dev), parent);
 	SET_STATE_HANDLER(sci_dev, scic_sds_remote_device_state_handler_table,
 			  SCI_BASE_REMOTE_DEVICE_STATE_INITIAL);
 
@@ -1203,16 +1202,15 @@ static void isci_remote_device_stop_complete(struct isci_host *ihost,
 
 static void scic_sds_remote_device_stopped_state_enter(void *object)
 {
-	struct scic_sds_remote_device *sci_dev;
+	struct scic_sds_remote_device *sci_dev = object;
 	struct scic_sds_controller *scic;
 	struct isci_remote_device *idev;
 	struct isci_host *ihost;
 	u32 prev_state;
 
-	sci_dev = container_of(object, typeof(*sci_dev), parent);
 	scic = scic_sds_remote_device_get_controller(sci_dev);
 	ihost = scic->ihost;
-	idev = sci_object_get_association(sci_dev);
+	idev = sci_dev_to_idev(sci_dev);
 
 	SET_STATE_HANDLER(sci_dev, scic_sds_remote_device_state_handler_table,
 			  SCI_BASE_REMOTE_DEVICE_STATE_STOPPED);
@@ -1229,11 +1227,10 @@ static void scic_sds_remote_device_stopped_state_enter(void *object)
 
 static void scic_sds_remote_device_starting_state_enter(void *object)
 {
-	struct scic_sds_remote_device *sci_dev = container_of(object, typeof(*sci_dev),
-							      parent);
+	struct scic_sds_remote_device *sci_dev = object;
 	struct scic_sds_controller *scic = scic_sds_remote_device_get_controller(sci_dev);
 	struct isci_host *ihost = scic->ihost;
-	struct isci_remote_device *idev = sci_object_get_association(sci_dev);
+	struct isci_remote_device *idev = sci_dev_to_idev(sci_dev);
 
 	SET_STATE_HANDLER(sci_dev, scic_sds_remote_device_state_handler_table,
 			  SCI_BASE_REMOTE_DEVICE_STATE_STARTING);
@@ -1244,11 +1241,10 @@ static void scic_sds_remote_device_starting_state_enter(void *object)
 
 static void scic_sds_remote_device_ready_state_enter(void *object)
 {
-	struct scic_sds_remote_device *sci_dev = container_of(object, typeof(*sci_dev),
-							      parent);
+	struct scic_sds_remote_device *sci_dev = object;
 	struct scic_sds_controller *scic = scic_sds_remote_device_get_controller(sci_dev);
 	struct isci_host *ihost = scic->ihost;
-	struct isci_remote_device *idev = sci_object_get_association(sci_dev);
+	struct isci_remote_device *idev = sci_dev_to_idev(sci_dev);
 
 	SET_STATE_HANDLER(sci_dev,
 			  scic_sds_remote_device_state_handler_table,
@@ -1264,14 +1260,13 @@ static void scic_sds_remote_device_ready_state_enter(void *object)
 
 static void scic_sds_remote_device_ready_state_exit(void *object)
 {
-	struct scic_sds_remote_device *sci_dev = container_of(object, typeof(*sci_dev),
-							      parent);
+	struct scic_sds_remote_device *sci_dev = object;
 	if (sci_dev->has_ready_substate_machine)
 		sci_base_state_machine_stop(&sci_dev->ready_substate_machine);
 	else {
 		struct scic_sds_controller *scic = scic_sds_remote_device_get_controller(sci_dev);
 		struct isci_host *ihost = scic->ihost;
-		struct isci_remote_device *idev = sci_object_get_association(sci_dev);
+		struct isci_remote_device *idev = sci_dev_to_idev(sci_dev);
 
 		isci_remote_device_not_ready(ihost, idev,
 					     SCIC_REMOTE_DEVICE_NOT_READY_STOP_REQUESTED);
@@ -1280,7 +1275,7 @@ static void scic_sds_remote_device_ready_state_exit(void *object)
 
 static void scic_sds_remote_device_stopping_state_enter(void *object)
 {
-	struct scic_sds_remote_device *sci_dev = (struct scic_sds_remote_device *)object;
+	struct scic_sds_remote_device *sci_dev = object;
 
 	SET_STATE_HANDLER(
 		sci_dev,
@@ -1291,7 +1286,7 @@ static void scic_sds_remote_device_stopping_state_enter(void *object)
 
 static void scic_sds_remote_device_failed_state_enter(void *object)
 {
-	struct scic_sds_remote_device *sci_dev = (struct scic_sds_remote_device *)object;
+	struct scic_sds_remote_device *sci_dev = object;
 
 	SET_STATE_HANDLER(
 		sci_dev,
@@ -1302,7 +1297,7 @@ static void scic_sds_remote_device_failed_state_enter(void *object)
 
 static void scic_sds_remote_device_resetting_state_enter(void *object)
 {
-	struct scic_sds_remote_device *sci_dev = (struct scic_sds_remote_device *)object;
+	struct scic_sds_remote_device *sci_dev = object;
 
 	SET_STATE_HANDLER(
 		sci_dev,
@@ -1316,14 +1311,14 @@ static void scic_sds_remote_device_resetting_state_enter(void *object)
 
 static void scic_sds_remote_device_resetting_state_exit(void *object)
 {
-	struct scic_sds_remote_device *sci_dev = (struct scic_sds_remote_device *)object;
+	struct scic_sds_remote_device *sci_dev = object;
 
 	scic_sds_remote_node_context_resume(&sci_dev->rnc, NULL, NULL);
 }
 
 static void scic_sds_remote_device_final_state_enter(void *object)
 {
-	struct scic_sds_remote_device *sci_dev = (struct scic_sds_remote_device *)object;
+	struct scic_sds_remote_device *sci_dev = object;
 
 	SET_STATE_HANDLER(
 		sci_dev,
@@ -1377,11 +1372,10 @@ static void scic_remote_device_construct(struct scic_sds_port *sci_port,
 {
 	sci_dev->owning_port = sci_port;
 	sci_dev->started_request_count = 0;
-	sci_dev->parent.private = NULL;
 
 	sci_base_state_machine_construct(
 		&sci_dev->state_machine,
-		&sci_dev->parent,
+		sci_dev,
 		scic_sds_remote_device_state_table,
 		SCI_BASE_REMOTE_DEVICE_STATE_INITIAL
 		);
@@ -1440,7 +1434,7 @@ static enum sci_status scic_remote_device_da_construct(struct scic_sds_port *sci
 
 		sci_base_state_machine_construct(
 				&sci_dev->ready_substate_machine,
-				&sci_dev->parent,
+				sci_dev,
 				scic_sds_stp_remote_device_ready_substate_table,
 				SCIC_SDS_STP_REMOTE_DEVICE_READY_SUBSTATE_IDLE);
 	} else if (dev_is_expander(dev)) {
@@ -1449,7 +1443,7 @@ static enum sci_status scic_remote_device_da_construct(struct scic_sds_port *sci
 		/* add the SMP ready substate machine construction here */
 		sci_base_state_machine_construct(
 				&sci_dev->ready_substate_machine,
-				&sci_dev->parent,
+				sci_dev,
 				scic_sds_smp_remote_device_ready_substate_table,
 				SCIC_SDS_SMP_REMOTE_DEVICE_READY_SUBSTATE_IDLE);
 	} else
@@ -1497,7 +1491,7 @@ static enum sci_status scic_remote_device_ea_construct(struct scic_sds_port *sci
 		/* add the SMP ready substate machine construction here */
 		sci_base_state_machine_construct(
 				&sci_dev->ready_substate_machine,
-				&sci_dev->parent,
+				sci_dev,
 				scic_sds_smp_remote_device_ready_substate_table,
 				SCIC_SDS_SMP_REMOTE_DEVICE_READY_SUBSTATE_IDLE);
 	} else if (dev->dev_type == SATA_DEV || (dev->tproto & SAS_PROTOCOL_STP)) {
@@ -1505,7 +1499,7 @@ static enum sci_status scic_remote_device_ea_construct(struct scic_sds_port *sci
 
 		sci_base_state_machine_construct(
 				&sci_dev->ready_substate_machine,
-				&sci_dev->parent,
+				sci_dev,
 				scic_sds_stp_remote_device_ready_substate_table,
 				SCIC_SDS_STP_REMOTE_DEVICE_READY_SUBSTATE_IDLE);
 	}
@@ -1565,9 +1559,6 @@ static enum sci_status isci_remote_device_construct(struct isci_port *iport,
 		return status;
 	}
 
-	/* XXX will be killed with sci_base_object removal */
-	sci_object_set_association(&idev->sci, idev);
-
 	/* start the device. */
 	status = scic_remote_device_start(&idev->sci, ISCI_REMOTE_DEVICE_START_TIMEOUT);
 

commit d3757c3aeb75259e0b86a872e98841a2ea4cb5e8
Author: Maciej Patelczyk <maciej.patelczyk@intel.com>
Date:   Thu Apr 28 22:06:06 2011 +0000

    isci: Removed sci_base_object from scic_sds_controller.
    
    The 'struct sci_base_object' was removed from the struct
    scic_sds_controller and was replaced by a pointer to
    struct isci_host.
    
    Signed-off-by: Maciej Patelczyk <maciej.patelczyk@intel.com>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/drivers/scsi/isci/remote_device.c b/drivers/scsi/isci/remote_device.c
index b23f9a5a085d..bb696cf11f2c 100644
--- a/drivers/scsi/isci/remote_device.c
+++ b/drivers/scsi/isci/remote_device.c
@@ -1211,7 +1211,7 @@ static void scic_sds_remote_device_stopped_state_enter(void *object)
 
 	sci_dev = container_of(object, typeof(*sci_dev), parent);
 	scic = scic_sds_remote_device_get_controller(sci_dev);
-	ihost = sci_object_get_association(scic);
+	ihost = scic->ihost;
 	idev = sci_object_get_association(sci_dev);
 
 	SET_STATE_HANDLER(sci_dev, scic_sds_remote_device_state_handler_table,
@@ -1232,7 +1232,7 @@ static void scic_sds_remote_device_starting_state_enter(void *object)
 	struct scic_sds_remote_device *sci_dev = container_of(object, typeof(*sci_dev),
 							      parent);
 	struct scic_sds_controller *scic = scic_sds_remote_device_get_controller(sci_dev);
-	struct isci_host *ihost = sci_object_get_association(scic);
+	struct isci_host *ihost = scic->ihost;
 	struct isci_remote_device *idev = sci_object_get_association(sci_dev);
 
 	SET_STATE_HANDLER(sci_dev, scic_sds_remote_device_state_handler_table,
@@ -1247,7 +1247,7 @@ static void scic_sds_remote_device_ready_state_enter(void *object)
 	struct scic_sds_remote_device *sci_dev = container_of(object, typeof(*sci_dev),
 							      parent);
 	struct scic_sds_controller *scic = scic_sds_remote_device_get_controller(sci_dev);
-	struct isci_host *ihost = sci_object_get_association(scic);
+	struct isci_host *ihost = scic->ihost;
 	struct isci_remote_device *idev = sci_object_get_association(sci_dev);
 
 	SET_STATE_HANDLER(sci_dev,
@@ -1270,7 +1270,7 @@ static void scic_sds_remote_device_ready_state_exit(void *object)
 		sci_base_state_machine_stop(&sci_dev->ready_substate_machine);
 	else {
 		struct scic_sds_controller *scic = scic_sds_remote_device_get_controller(sci_dev);
-		struct isci_host *ihost = sci_object_get_association(scic);
+		struct isci_host *ihost = scic->ihost;
 		struct isci_remote_device *idev = sci_object_get_association(sci_dev);
 
 		isci_remote_device_not_ready(ihost, idev,

commit 9a0fff7bf0ffd4f57fc71d8075a92008b606eb61
Author: Maciej Patelczyk <maciej.patelczyk@intel.com>
Date:   Thu Apr 28 22:06:01 2011 +0000

    isci: Removed struct sci_base_object from state machine.
    
    Changed any occurrence of struct sci_base_object into void.
    
    Signed-off-by: Maciej Patelczyk <maciej.patelczyk@intel.com>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/drivers/scsi/isci/remote_device.c b/drivers/scsi/isci/remote_device.c
index 6d5ab728ccd1..b23f9a5a085d 100644
--- a/drivers/scsi/isci/remote_device.c
+++ b/drivers/scsi/isci/remote_device.c
@@ -1099,8 +1099,7 @@ static const struct scic_sds_remote_device_state_handler scic_sds_remote_device_
 	}
 };
 
-static void scic_sds_remote_device_initial_state_enter(
-	struct sci_base_object *object)
+static void scic_sds_remote_device_initial_state_enter(void *object)
 {
 	struct scic_sds_remote_device *sci_dev = (struct scic_sds_remote_device *)object;
 
@@ -1202,8 +1201,7 @@ static void isci_remote_device_stop_complete(struct isci_host *ihost,
 	isci_remote_device_deconstruct(ihost, idev);
 }
 
-static void scic_sds_remote_device_stopped_state_enter(
-	struct sci_base_object *object)
+static void scic_sds_remote_device_stopped_state_enter(void *object)
 {
 	struct scic_sds_remote_device *sci_dev;
 	struct scic_sds_controller *scic;
@@ -1229,7 +1227,7 @@ static void scic_sds_remote_device_stopped_state_enter(
 	scic_sds_controller_remote_device_stopped(scic, sci_dev);
 }
 
-static void scic_sds_remote_device_starting_state_enter(struct sci_base_object *object)
+static void scic_sds_remote_device_starting_state_enter(void *object)
 {
 	struct scic_sds_remote_device *sci_dev = container_of(object, typeof(*sci_dev),
 							      parent);
@@ -1244,7 +1242,7 @@ static void scic_sds_remote_device_starting_state_enter(struct sci_base_object *
 				     SCIC_REMOTE_DEVICE_NOT_READY_START_REQUESTED);
 }
 
-static void scic_sds_remote_device_ready_state_enter(struct sci_base_object *object)
+static void scic_sds_remote_device_ready_state_enter(void *object)
 {
 	struct scic_sds_remote_device *sci_dev = container_of(object, typeof(*sci_dev),
 							      parent);
@@ -1264,8 +1262,7 @@ static void scic_sds_remote_device_ready_state_enter(struct sci_base_object *obj
 		isci_remote_device_ready(ihost, idev);
 }
 
-static void scic_sds_remote_device_ready_state_exit(
-	struct sci_base_object *object)
+static void scic_sds_remote_device_ready_state_exit(void *object)
 {
 	struct scic_sds_remote_device *sci_dev = container_of(object, typeof(*sci_dev),
 							      parent);
@@ -1281,8 +1278,7 @@ static void scic_sds_remote_device_ready_state_exit(
 	}
 }
 
-static void scic_sds_remote_device_stopping_state_enter(
-	struct sci_base_object *object)
+static void scic_sds_remote_device_stopping_state_enter(void *object)
 {
 	struct scic_sds_remote_device *sci_dev = (struct scic_sds_remote_device *)object;
 
@@ -1293,8 +1289,7 @@ static void scic_sds_remote_device_stopping_state_enter(
 		);
 }
 
-static void scic_sds_remote_device_failed_state_enter(
-	struct sci_base_object *object)
+static void scic_sds_remote_device_failed_state_enter(void *object)
 {
 	struct scic_sds_remote_device *sci_dev = (struct scic_sds_remote_device *)object;
 
@@ -1305,8 +1300,7 @@ static void scic_sds_remote_device_failed_state_enter(
 		);
 }
 
-static void scic_sds_remote_device_resetting_state_enter(
-	struct sci_base_object *object)
+static void scic_sds_remote_device_resetting_state_enter(void *object)
 {
 	struct scic_sds_remote_device *sci_dev = (struct scic_sds_remote_device *)object;
 
@@ -1320,16 +1314,14 @@ static void scic_sds_remote_device_resetting_state_enter(
 		&sci_dev->rnc, SCI_SOFTWARE_SUSPENSION, NULL, NULL);
 }
 
-static void scic_sds_remote_device_resetting_state_exit(
-	struct sci_base_object *object)
+static void scic_sds_remote_device_resetting_state_exit(void *object)
 {
 	struct scic_sds_remote_device *sci_dev = (struct scic_sds_remote_device *)object;
 
 	scic_sds_remote_node_context_resume(&sci_dev->rnc, NULL, NULL);
 }
 
-static void scic_sds_remote_device_final_state_enter(
-	struct sci_base_object *object)
+static void scic_sds_remote_device_final_state_enter(void *object)
 {
 	struct scic_sds_remote_device *sci_dev = (struct scic_sds_remote_device *)object;
 

commit 3d6e428c0cd8d234bab0ac93aff9ccffacc8bc7e
Author: Dave Jiang <dave.jiang@intel.com>
Date:   Tue Apr 26 12:31:37 2011 -0700

    isci: removing non-working ATAPI code
    
    Removing not used / bit-rotten ATAPI code. This needs to go back
    and debugged at a later date.
    
    Signed-off-by: Dave Jiang <dave.jiang@intel.com>
    [reflow against devel, delete dead sati headers]
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/drivers/scsi/isci/remote_device.c b/drivers/scsi/isci/remote_device.c
index 1e9e2227820a..6d5ab728ccd1 100644
--- a/drivers/scsi/isci/remote_device.c
+++ b/drivers/scsi/isci/remote_device.c
@@ -99,15 +99,6 @@ enum sas_linkrate scic_remote_device_get_connection_rate(
 	return sci_dev->connection_rate;
 }
 
-
-#if !defined(DISABLE_ATAPI)
-bool scic_remote_device_is_atapi(struct scic_sds_remote_device *sci_dev)
-{
-	return sci_dev->is_atapi;
-}
-#endif
-
-
 /**
  *
  *
@@ -215,16 +206,6 @@ enum sci_status scic_sds_remote_device_start_task(
 		       sci_dev, io_request);
 }
 
-/**
- *
- * @controller: The controller that is completing the task request.
- * @sci_dev: The remote device for which the complete task handling is
- *    being requested.
- * @io_request: The task request that is being completed.
- *
- * This method invokes the remote device complete task handler. enum sci_status
- */
-
 /**
  *
  * @sci_dev:
@@ -247,47 +228,6 @@ void scic_sds_remote_device_post_request(
 		);
 }
 
-#if !defined(DISABLE_ATAPI)
-/**
- *
- * @sci_dev: The device to be checked.
- *
- * This method check the signature fis of a stp device to decide whether a
- * device is atapi or not. true if a device is atapi device. False if a device
- * is not atapi.
- */
-bool scic_sds_remote_device_is_atapi(
-	struct scic_sds_remote_device *sci_dev)
-{
-	if (!sci_dev->target_protocols.u.bits.attached_stp_target)
-		return false;
-	else if (sci_dev->is_direct_attached) {
-		struct scic_sds_phy *phy;
-		struct scic_sata_phy_properties properties;
-		struct sata_fis_reg_d2h *signature_fis;
-		phy = scic_sds_port_get_a_connected_phy(sci_dev->owning_port);
-		scic_sata_phy_get_properties(phy, &properties);
-
-		/* decode the signature fis. */
-		signature_fis = &(properties.signature_fis);
-
-		if ((signature_fis->sector_count  == 0x01)
-		    && (signature_fis->lba_low       == 0x01)
-		    && (signature_fis->lba_mid       == 0x14)
-		    && (signature_fis->lba_high      == 0xEB)
-		    && ((signature_fis->device & 0x5F) == 0x00)
-		    ) {
-			/* An ATA device supporting the PACKET command set. */
-			return true;
-		} else
-			return false;
-	} else {
-		/* Expander supported ATAPI device is not currently supported. */
-		return false;
-	}
-}
-#endif
-
 /**
  *
  * @user_parameter: This is cast to a remote device object.

commit a3d568f0dfbb6bc786df04ad13e0b401f80e614c
Author: Dan Williams <dan.j.williams@intel.com>
Date:   Tue Apr 26 09:41:52 2011 -0700

    isci: remove usage of sci_sas_address in scic_sds_remote_device
    
    The sas address can be retrieved from the domain device and then
    converted to the always little-endian format in the remote node context.
    
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/drivers/scsi/isci/remote_device.c b/drivers/scsi/isci/remote_device.c
index 5ba3b5dca4d5..1e9e2227820a 100644
--- a/drivers/scsi/isci/remote_device.c
+++ b/drivers/scsi/isci/remote_device.c
@@ -1501,8 +1501,6 @@ static enum sci_status scic_remote_device_da_construct(struct scic_sds_port *sci
 
 	sci_dev->rnc.remote_node_index = remote_node_index;
 
-	scic_sds_port_get_attached_sas_address(sci_port, &sci_dev->device_address);
-
 	if (dev->dev_type == SAS_END_DEV)
 		sci_dev->has_ready_substate_machine = false;
 	else if (dev->dev_type == SATA_DEV || (dev->tproto & SAS_PROTOCOL_STP)) {
@@ -1553,7 +1551,6 @@ static enum sci_status scic_remote_device_ea_construct(struct scic_sds_port *sci
 	enum sci_status status;
 
 	scic_remote_device_construct(sci_port, sci_dev);
-	memcpy(&sci_dev->device_address, dev->sas_addr, SAS_ADDR_SIZE);
 
 	status = scic_sds_controller_allocate_remote_node_context(
 		scic, sci_dev, &sci_dev->rnc.remote_node_index);

commit 00d680ef84570bc7aea023772d27e85b0052004c
Author: Dan Williams <dan.j.williams@intel.com>
Date:   Mon Apr 25 14:29:29 2011 -0700

    isci: kill smp_discover_response
    
    An lldd need never look at the contents of an smp_discover_response frame.
    Kill the remaining locations where isci is looking at it:
    
    1/ covering for expanders that do not set the stp_attached bit (already
       handled by sas_ex_discover_end_dev)
    2/ an overkill method to notifiy the rest of the driver about remote_device
       sas addresses
    
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/drivers/scsi/isci/remote_device.c b/drivers/scsi/isci/remote_device.c
index fc79a5b47f72..5ba3b5dca4d5 100644
--- a/drivers/scsi/isci/remote_device.c
+++ b/drivers/scsi/isci/remote_device.c
@@ -1533,21 +1533,8 @@ static enum sci_status scic_remote_device_da_construct(struct scic_sds_port *sci
 	return SCI_SUCCESS;
 }
 
-static void scic_sds_remote_device_get_info_from_smp_discover_response(
-	struct scic_sds_remote_device *sci_dev,
-	struct smp_response_discover *discover_response)
-{
-	/* decode discover_response to set sas_address to sci_dev. */
-	sci_dev->device_address.high =
-		discover_response->attached_sas_address.high;
-
-	sci_dev->device_address.low =
-		discover_response->attached_sas_address.low;
-}
-
 /**
  * scic_remote_device_ea_construct() - construct expander attached device
- * @discover_response: data to build remote device
  *
  * Remote node context(s) is/are a global resource allocated by this
  * routine, freed by scic_remote_device_destruct().
@@ -1559,17 +1546,14 @@ static void scic_sds_remote_device_get_info_from_smp_discover_response(
  * SCI_FAILURE_INSUFFICIENT_RESOURCES - remote node contexts exhausted.
  */
 static enum sci_status scic_remote_device_ea_construct(struct scic_sds_port *sci_port,
-						       struct scic_sds_remote_device *sci_dev,
-						       struct smp_response_discover *discover_response)
+						       struct scic_sds_remote_device *sci_dev)
 {
 	struct scic_sds_controller *scic = sci_port->owning_controller;
 	struct domain_device *dev = sci_dev_to_domain(sci_dev);
 	enum sci_status status;
 
 	scic_remote_device_construct(sci_port, sci_dev);
-
-	scic_sds_remote_device_get_info_from_smp_discover_response(
-		sci_dev, discover_response);
+	memcpy(&sci_dev->device_address, dev->sas_addr, SAS_ADDR_SIZE);
 
 	status = scic_sds_controller_allocate_remote_node_context(
 		scic, sci_dev, &sci_dev->rnc.remote_node_index);
@@ -1605,7 +1589,7 @@ static enum sci_status scic_remote_device_ea_construct(struct scic_sds_port *sci
 	 * physical.  Furthermore, the SAS-2 and SAS-1.1 fields overlay
 	 * one another, so this code works for both situations. */
 	sci_dev->connection_rate = min_t(u16, scic_sds_port_get_max_allowed_speed(sci_port),
-			discover_response->u2.sas1_1.negotiated_physical_link_rate);
+					 dev->linkrate);
 
 	/* / @todo Should I assign the port width by reading all of the phys on the port? */
 	sci_dev->device_port_width = 1;
@@ -1632,117 +1616,35 @@ static enum sci_status scic_remote_device_start(struct scic_sds_remote_device *s
 	return sci_dev->state_handlers->start_handler(sci_dev);
 }
 
-/**
- * isci_remote_device_construct() - This function calls the scic remote device
- *    construct and start functions, it waits on the remote device start
- *    completion.
- * @port: This parameter specifies the isci port with the remote device.
- * @isci_device: This parameter specifies the isci remote device
- *
- * status from the scic calls, the caller to this function should clean up
- * resources as appropriate.
- */
-static enum sci_status isci_remote_device_construct(
-	struct isci_port *port,
-	struct isci_remote_device *isci_device)
+static enum sci_status isci_remote_device_construct(struct isci_port *iport,
+						    struct isci_remote_device *idev)
 {
-	enum sci_status status = SCI_SUCCESS;
-
-	if (isci_device->domain_dev->parent &&
-	    dev_is_expander(isci_device->domain_dev->parent)) {
-		int i;
-
-		/* struct smp_response_discover discover_response; */
-		struct discover_resp discover_response;
-		struct domain_device *parent =
-			isci_device->domain_dev->parent;
-
-		struct expander_device *parent_ex = &parent->ex_dev;
-
-		for (i = 0; i < parent_ex->num_phys; i++) {
-
-			struct ex_phy *phy = &parent_ex->ex_phy[i];
-
-			if ((phy->phy_state == PHY_VACANT) ||
-			    (phy->phy_state == PHY_NOT_PRESENT))
-				continue;
-
-			if (SAS_ADDR(phy->attached_sas_addr)
-			    == SAS_ADDR(isci_device->domain_dev->sas_addr)) {
-
-				discover_response.attached_dev_type
-					= phy->attached_dev_type;
-				discover_response.linkrate
-					= phy->linkrate;
-				discover_response.attached_sata_host
-					= phy->attached_sata_host;
-				discover_response.attached_sata_dev
-					= phy->attached_sata_dev;
-				discover_response.attached_sata_ps
-					= phy->attached_sata_ps;
-				discover_response.iproto
-					= phy->attached_iproto >> 1;
-				discover_response.tproto
-					= phy->attached_tproto >> 1;
-				memcpy(
-					discover_response.attached_sas_addr,
-					phy->attached_sas_addr,
-					SAS_ADDR_SIZE
-					);
-				discover_response.attached_phy_id
-					= phy->attached_phy_id;
-				discover_response.change_count
-					= phy->phy_change_count;
-				discover_response.routing_attr
-					= phy->routing_attr;
-				discover_response.hmin_linkrate
-					= phy->phy->minimum_linkrate_hw;
-				discover_response.hmax_linkrate
-					= phy->phy->maximum_linkrate_hw;
-				discover_response.pmin_linkrate
-					= phy->phy->minimum_linkrate;
-				discover_response.pmax_linkrate
-					= phy->phy->maximum_linkrate;
-			}
-		}
-
-
-		dev_dbg(&port->isci_host->pdev->dev,
-			"%s: parent->dev_type = EDGE_DEV\n",
-			__func__);
-
-		status = scic_remote_device_ea_construct(port->sci_port_handle,
-							 &isci_device->sci,
-				(struct smp_response_discover *)&discover_response);
-
-	} else
-		status = scic_remote_device_da_construct(port->sci_port_handle,
-							 &isci_device->sci);
+	struct scic_sds_port *sci_port = iport->sci_port_handle;
+	struct isci_host *ihost = iport->isci_host;
+	struct domain_device *dev = idev->domain_dev;
+	enum sci_status status;
 
+	if (dev->parent && dev_is_expander(dev->parent))
+		status = scic_remote_device_ea_construct(sci_port, &idev->sci);
+	else
+		status = scic_remote_device_da_construct(sci_port, &idev->sci);
 
 	if (status != SCI_SUCCESS) {
-		dev_dbg(&port->isci_host->pdev->dev,
-			"%s: scic_remote_device_da_construct failed - "
-			"isci_device = %p\n",
-			__func__,
-			isci_device);
+		dev_dbg(&ihost->pdev->dev, "%s: construct failed: %d\n",
+			__func__, status);
 
 		return status;
 	}
 
 	/* XXX will be killed with sci_base_object removal */
-	sci_object_set_association(&isci_device->sci, isci_device);
+	sci_object_set_association(&idev->sci, idev);
 
 	/* start the device. */
-	status = scic_remote_device_start(&isci_device->sci,
-					  ISCI_REMOTE_DEVICE_START_TIMEOUT);
+	status = scic_remote_device_start(&idev->sci, ISCI_REMOTE_DEVICE_START_TIMEOUT);
 
-	if (status != SCI_SUCCESS) {
-		dev_warn(&port->isci_host->pdev->dev,
-			 "%s: scic_remote_device_start failed\n",
-			 __func__);
-		return status;
-	}
+	if (status != SCI_SUCCESS)
+		dev_warn(&ihost->pdev->dev, "remote device start failed: %d\n",
+			 status);
 
 	return status;
 }

commit a1a113b0a1ea437daf099b44f8a39e93a02a3f47
Author: Dan Williams <dan.j.williams@intel.com>
Date:   Thu Apr 21 18:44:45 2011 -0700

    isci: kill smp_discover_response_protocols in favor of domain_device.dev_type
    
    This is step 1 of removing the contortions to:
    1/ unparse expander phy data into a smp discover frame
    2/ open-code-parse the smp discover fram into a domain_device.dev_type equivalent
    
    libsas has already spent cycles determining the dev_type, so now that
    scic_sds_remote_device is unified with isci_remote_device we can
    directly reference dev_type.
    
    This might also change multi-level expander detection as we previously only
    looked at dev_type == EDGE_DEV and we did not consider the FANOUT_DEV case.
    
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/drivers/scsi/isci/remote_device.c b/drivers/scsi/isci/remote_device.c
index 70641818f602..fc79a5b47f72 100644
--- a/drivers/scsi/isci/remote_device.c
+++ b/drivers/scsi/isci/remote_device.c
@@ -100,13 +100,6 @@ enum sas_linkrate scic_remote_device_get_connection_rate(
 }
 
 
-void scic_remote_device_get_protocols(
-	struct scic_sds_remote_device *sci_dev,
-	struct smp_discover_response_protocols *pr)
-{
-	pr->u.all = sci_dev->target_protocols.u.all;
-}
-
 #if !defined(DISABLE_ATAPI)
 bool scic_remote_device_is_atapi(struct scic_sds_remote_device *sci_dev)
 {
@@ -1490,7 +1483,7 @@ static enum sci_status scic_remote_device_da_construct(struct scic_sds_port *sci
 {
 	enum sci_status status;
 	u16 remote_node_index;
-	struct sci_sas_identify_address_frame_protocols protocols;
+	struct domain_device *dev = sci_dev_to_domain(sci_dev);
 
 	scic_remote_device_construct(sci_port, sci_dev);
 
@@ -1498,53 +1491,46 @@ static enum sci_status scic_remote_device_da_construct(struct scic_sds_port *sci
 	 * This information is request to determine how many remote node context
 	 * entries will be needed to store the remote node.
 	 */
-	scic_sds_port_get_attached_protocols(sci_dev->owning_port, &protocols);
-	sci_dev->target_protocols.u.all = protocols.u.all;
 	sci_dev->is_direct_attached = true;
-#if !defined(DISABLE_ATAPI)
-	sci_dev->is_atapi = scic_sds_remote_device_is_atapi(sci_dev);
-#endif
+	status = scic_sds_controller_allocate_remote_node_context(sci_port->owning_controller,
+								  sci_dev,
+								  &remote_node_index);
 
-	status = scic_sds_controller_allocate_remote_node_context(
-		sci_dev->owning_port->owning_controller,
-		sci_dev,
-		&remote_node_index);
+	if (status != SCI_SUCCESS)
+		return status;
 
-	if (status == SCI_SUCCESS) {
-		sci_dev->rnc.remote_node_index = remote_node_index;
+	sci_dev->rnc.remote_node_index = remote_node_index;
 
-		scic_sds_port_get_attached_sas_address(
-			sci_dev->owning_port, &sci_dev->device_address);
+	scic_sds_port_get_attached_sas_address(sci_port, &sci_dev->device_address);
 
-		if (sci_dev->target_protocols.u.bits.attached_ssp_target) {
-			sci_dev->has_ready_substate_machine = false;
-		} else if (sci_dev->target_protocols.u.bits.attached_stp_target) {
-			sci_dev->has_ready_substate_machine = true;
+	if (dev->dev_type == SAS_END_DEV)
+		sci_dev->has_ready_substate_machine = false;
+	else if (dev->dev_type == SATA_DEV || (dev->tproto & SAS_PROTOCOL_STP)) {
+		sci_dev->has_ready_substate_machine = true;
 
-			sci_base_state_machine_construct(
+		sci_base_state_machine_construct(
 				&sci_dev->ready_substate_machine,
 				&sci_dev->parent,
 				scic_sds_stp_remote_device_ready_substate_table,
 				SCIC_SDS_STP_REMOTE_DEVICE_READY_SUBSTATE_IDLE);
-		} else if (sci_dev->target_protocols.u.bits.attached_smp_target) {
-			sci_dev->has_ready_substate_machine = true;
+	} else if (dev_is_expander(dev)) {
+		sci_dev->has_ready_substate_machine = true;
 
-			/* add the SMP ready substate machine construction here */
-			sci_base_state_machine_construct(
+		/* add the SMP ready substate machine construction here */
+		sci_base_state_machine_construct(
 				&sci_dev->ready_substate_machine,
 				&sci_dev->parent,
 				scic_sds_smp_remote_device_ready_substate_table,
 				SCIC_SDS_SMP_REMOTE_DEVICE_READY_SUBSTATE_IDLE);
-		}
+	} else
+		return SCI_FAILURE_UNSUPPORTED_PROTOCOL;
 
-		sci_dev->connection_rate = scic_sds_port_get_max_allowed_speed(
-			sci_dev->owning_port);
+	sci_dev->connection_rate = scic_sds_port_get_max_allowed_speed(sci_port);
 
-		/* / @todo Should I assign the port width by reading all of the phys on the port? */
-		sci_dev->device_port_width = 1;
-	}
+	/* / @todo Should I assign the port width by reading all of the phys on the port? */
+	sci_dev->device_port_width = 1;
 
-	return status;
+	return SCI_SUCCESS;
 }
 
 static void scic_sds_remote_device_get_info_from_smp_discover_response(
@@ -1557,8 +1543,6 @@ static void scic_sds_remote_device_get_info_from_smp_discover_response(
 
 	sci_dev->device_address.low =
 		discover_response->attached_sas_address.low;
-
-	sci_dev->target_protocols.u.all = discover_response->protocols.u.all;
 }
 
 /**
@@ -1579,6 +1563,7 @@ static enum sci_status scic_remote_device_ea_construct(struct scic_sds_port *sci
 						       struct smp_response_discover *discover_response)
 {
 	struct scic_sds_controller *scic = sci_port->owning_controller;
+	struct domain_device *dev = sci_dev_to_domain(sci_dev);
 	enum sci_status status;
 
 	scic_remote_device_construct(sci_port, sci_dev);
@@ -1588,43 +1573,42 @@ static enum sci_status scic_remote_device_ea_construct(struct scic_sds_port *sci
 
 	status = scic_sds_controller_allocate_remote_node_context(
 		scic, sci_dev, &sci_dev->rnc.remote_node_index);
+	if (status != SCI_SUCCESS)
+		return status;
 
-	if (status == SCI_SUCCESS) {
-		if (sci_dev->target_protocols.u.bits.attached_ssp_target) {
-			sci_dev->has_ready_substate_machine = false;
-		} else if (sci_dev->target_protocols.u.bits.attached_smp_target) {
-			sci_dev->has_ready_substate_machine = true;
+	if (dev->dev_type == SAS_END_DEV)
+		sci_dev->has_ready_substate_machine = false;
+	else if (dev_is_expander(dev)) {
+		sci_dev->has_ready_substate_machine = true;
 
-			/* add the SMP ready substate machine construction here */
-			sci_base_state_machine_construct(
+		/* add the SMP ready substate machine construction here */
+		sci_base_state_machine_construct(
 				&sci_dev->ready_substate_machine,
 				&sci_dev->parent,
 				scic_sds_smp_remote_device_ready_substate_table,
 				SCIC_SDS_SMP_REMOTE_DEVICE_READY_SUBSTATE_IDLE);
-		} else if (sci_dev->target_protocols.u.bits.attached_stp_target) {
-			sci_dev->has_ready_substate_machine = true;
+	} else if (dev->dev_type == SATA_DEV || (dev->tproto & SAS_PROTOCOL_STP)) {
+		sci_dev->has_ready_substate_machine = true;
 
-			sci_base_state_machine_construct(
+		sci_base_state_machine_construct(
 				&sci_dev->ready_substate_machine,
 				&sci_dev->parent,
 				scic_sds_stp_remote_device_ready_substate_table,
 				SCIC_SDS_STP_REMOTE_DEVICE_READY_SUBSTATE_IDLE);
-		}
+	}
 
-		/*
-		 * For SAS-2 the physical link rate is actually a logical link
-		 * rate that incorporates multiplexing.  The SCU doesn't
-		 * incorporate multiplexing and for the purposes of the
-		 * connection the logical link rate is that same as the
-		 * physical.  Furthermore, the SAS-2 and SAS-1.1 fields overlay
-		 * one another, so this code works for both situations. */
-		sci_dev->connection_rate = min_t(u16,
-			scic_sds_port_get_max_allowed_speed(sci_port),
+	/*
+	 * For SAS-2 the physical link rate is actually a logical link
+	 * rate that incorporates multiplexing.  The SCU doesn't
+	 * incorporate multiplexing and for the purposes of the
+	 * connection the logical link rate is that same as the
+	 * physical.  Furthermore, the SAS-2 and SAS-1.1 fields overlay
+	 * one another, so this code works for both situations. */
+	sci_dev->connection_rate = min_t(u16, scic_sds_port_get_max_allowed_speed(sci_port),
 			discover_response->u2.sas1_1.negotiated_physical_link_rate);
 
-		/* / @todo Should I assign the port width by reading all of the phys on the port? */
-		sci_dev->device_port_width = 1;
-	}
+	/* / @todo Should I assign the port width by reading all of the phys on the port? */
+	sci_dev->device_port_width = 1;
 
 	return status;
 }
@@ -1665,7 +1649,7 @@ static enum sci_status isci_remote_device_construct(
 	enum sci_status status = SCI_SUCCESS;
 
 	if (isci_device->domain_dev->parent &&
-	    (isci_device->domain_dev->parent->dev_type == EDGE_DEV)) {
+	    dev_is_expander(isci_device->domain_dev->parent)) {
 		int i;
 
 		/* struct smp_response_discover discover_response; */

commit b87ee3075b090e1dd0bdf40b295142b606d55e64
Author: Dan Williams <dan.j.williams@intel.com>
Date:   Mon Apr 25 11:48:29 2011 -0700

    isci: cleanup remote device construction and comments
    
    The construction routines scic_remote_device_[de]a_construct both reference
    the need to call scic_remote_device_construct first.  Delete that comment and
    just have them call it explicitly, also:
    * move the comments from header to source
    * delete dead references to scic_[de]a_remote_device_add_phy
    
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/drivers/scsi/isci/remote_device.c b/drivers/scsi/isci/remote_device.c
index 6b9ea9022843..70641818f602 100644
--- a/drivers/scsi/isci/remote_device.c
+++ b/drivers/scsi/isci/remote_device.c
@@ -1438,15 +1438,14 @@ static const struct sci_base_state scic_sds_remote_device_state_table[] = {
 };
 
 /**
- * scic_remote_device_construct() - This method will perform the construction
- *    common to all remote device objects.
+ * scic_remote_device_construct() - common construction
  * @sci_port: SAS/SATA port through which this device is accessed.
  * @sci_dev: remote device to construct
  *
- * It isn't necessary to call scic_remote_device_destruct() for device objects
- * that have only called this method for construction. Once subsequent
- * construction methods have been invoked (e.g.
- * scic_remote_device_da_construct()), then destruction should occur. none
+ * This routine just performs benign initialization and does not
+ * allocate the remote_node_context which is left to
+ * scic_remote_device_[de]a_construct().  scic_remote_device_destruct()
+ * frees the remote_node_context(s) for the device.
  */
 static void scic_remote_device_construct(struct scic_sds_port *sci_port,
 				  struct scic_sds_remote_device *sci_dev)
@@ -1473,32 +1472,28 @@ static void scic_remote_device_construct(struct scic_sds_port *sci_port,
 }
 
 /**
- * scic_remote_device_da_construct() - This method will construct a
- *    SCIC_REMOTE_DEVICE object for a direct attached (da) device.  The
- *    information (e.g. IAF, Signature FIS, etc.) necessary to build the device
- *    is known to the SCI Core since it is contained in the scic_phy object.
- * @remote_device: This parameter specifies the remote device to be destructed.
- *
- * The user must have previously called scic_remote_device_construct() Remote
- * device objects are a limited resource.  As such, they must be protected.
- * Thus calls to construct and destruct are mutually exclusive and
- * non-reentrant. Indicate if the remote device was successfully constructed.
- * SCI_SUCCESS Returned if the device was successfully constructed.
- * SCI_FAILURE_DEVICE_EXISTS Returned if the device has already been
- * constructed.  If it's an additional phy for the target, then call
- * scic_remote_device_da_add_phy(). SCI_FAILURE_UNSUPPORTED_PROTOCOL Returned
- * if the supplied parameters necessitate creation of a remote device for which
- * the protocol is not supported by the underlying controller hardware.
- * SCI_FAILURE_INSUFFICIENT_RESOURCES This value is returned if the core
- * controller associated with the supplied parameters is unable to support
- * additional remote devices.
+ * scic_remote_device_da_construct() - construct direct attached device.
+ *
+ * The information (e.g. IAF, Signature FIS, etc.) necessary to build
+ * the device is known to the SCI Core since it is contained in the
+ * scic_phy object.  Remote node context(s) is/are a global resource
+ * allocated by this routine, freed by scic_remote_device_destruct().
+ *
+ * Returns:
+ * SCI_FAILURE_DEVICE_EXISTS - device has already been constructed.
+ * SCI_FAILURE_UNSUPPORTED_PROTOCOL - e.g. sas device attached to
+ * sata-only controller instance.
+ * SCI_FAILURE_INSUFFICIENT_RESOURCES - remote node contexts exhausted.
  */
-static enum sci_status scic_remote_device_da_construct(struct scic_sds_remote_device *sci_dev)
+static enum sci_status scic_remote_device_da_construct(struct scic_sds_port *sci_port,
+						       struct scic_sds_remote_device *sci_dev)
 {
 	enum sci_status status;
 	u16 remote_node_index;
 	struct sci_sas_identify_address_frame_protocols protocols;
 
+	scic_remote_device_construct(sci_port, sci_dev);
+
 	/*
 	 * This information is request to determine how many remote node context
 	 * entries will be needed to store the remote node.
@@ -1567,34 +1562,26 @@ static void scic_sds_remote_device_get_info_from_smp_discover_response(
 }
 
 /**
- * scic_remote_device_ea_construct() - This method will construct an
- *    SCIC_REMOTE_DEVICE object for an expander attached (ea) device from an
- *    SMP Discover Response.
- * @remote_device: This parameter specifies the remote device to be destructed.
- * @discover_response: This parameter specifies the SMP Discovery Response to
- *    be used in device creation.
- *
- * The user must have previously called scic_remote_device_construct() Remote
- * device objects are a limited resource.  As such, they must be protected.
- * Thus calls to construct and destruct are mutually exclusive and
- * non-reentrant. Indicate if the remote device was successfully constructed.
- * SCI_SUCCESS Returned if the device was successfully constructed.
- * SCI_FAILURE_DEVICE_EXISTS Returned if the device has already been
- * constructed.  If it's an additional phy for the target, then call
- * scic_ea_remote_device_add_phy(). SCI_FAILURE_UNSUPPORTED_PROTOCOL Returned
- * if the supplied parameters necessitate creation of a remote device for which
- * the protocol is not supported by the underlying controller hardware.
- * SCI_FAILURE_INSUFFICIENT_RESOURCES This value is returned if the core
- * controller associated with the supplied parameters is unable to support
- * additional remote devices.
+ * scic_remote_device_ea_construct() - construct expander attached device
+ * @discover_response: data to build remote device
+ *
+ * Remote node context(s) is/are a global resource allocated by this
+ * routine, freed by scic_remote_device_destruct().
+ *
+ * Returns:
+ * SCI_FAILURE_DEVICE_EXISTS - device has already been constructed.
+ * SCI_FAILURE_UNSUPPORTED_PROTOCOL - e.g. sas device attached to
+ * sata-only controller instance.
+ * SCI_FAILURE_INSUFFICIENT_RESOURCES - remote node contexts exhausted.
  */
-static enum sci_status scic_remote_device_ea_construct(struct scic_sds_remote_device *sci_dev,
+static enum sci_status scic_remote_device_ea_construct(struct scic_sds_port *sci_port,
+						       struct scic_sds_remote_device *sci_dev,
 						       struct smp_response_discover *discover_response)
 {
+	struct scic_sds_controller *scic = sci_port->owning_controller;
 	enum sci_status status;
-	struct scic_sds_controller *scic;
 
-	scic = scic_sds_port_get_controller(sci_dev->owning_port);
+	scic_remote_device_construct(sci_port, sci_dev);
 
 	scic_sds_remote_device_get_info_from_smp_discover_response(
 		sci_dev, discover_response);
@@ -1632,9 +1619,8 @@ static enum sci_status scic_remote_device_ea_construct(struct scic_sds_remote_de
 		 * physical.  Furthermore, the SAS-2 and SAS-1.1 fields overlay
 		 * one another, so this code works for both situations. */
 		sci_dev->connection_rate = min_t(u16,
-			scic_sds_port_get_max_allowed_speed(sci_dev->owning_port),
-			discover_response->u2.sas1_1.negotiated_physical_link_rate
-			);
+			scic_sds_port_get_max_allowed_speed(sci_port),
+			discover_response->u2.sas1_1.negotiated_physical_link_rate);
 
 		/* / @todo Should I assign the port width by reading all of the phys on the port? */
 		sci_dev->device_port_width = 1;
@@ -1678,11 +1664,6 @@ static enum sci_status isci_remote_device_construct(
 {
 	enum sci_status status = SCI_SUCCESS;
 
-	/* let the core do it's common constuction. */
-	scic_remote_device_construct(port->sci_port_handle,
-				     &isci_device->sci);
-
-	/* let the core do it's device specific constuction. */
 	if (isci_device->domain_dev->parent &&
 	    (isci_device->domain_dev->parent->dev_type == EDGE_DEV)) {
 		int i;
@@ -1746,11 +1727,13 @@ static enum sci_status isci_remote_device_construct(
 			"%s: parent->dev_type = EDGE_DEV\n",
 			__func__);
 
-		status = scic_remote_device_ea_construct(&isci_device->sci,
+		status = scic_remote_device_ea_construct(port->sci_port_handle,
+							 &isci_device->sci,
 				(struct smp_response_discover *)&discover_response);
 
 	} else
-		status = scic_remote_device_da_construct(&isci_device->sci);
+		status = scic_remote_device_da_construct(port->sci_port_handle,
+							 &isci_device->sci);
 
 
 	if (status != SCI_SUCCESS) {

commit 88f3b62ac131e2549b6c262cacbd47e8cca42d6e
Author: Dan Williams <dan.j.williams@intel.com>
Date:   Fri Apr 22 19:18:03 2011 -0700

    isci: move remote_device handling out of the core
    
    Now that the core/lldd remote_device data structures are nominally unified
    merge the corresponding sources into the top-level directory.  Also move the
    remote_node_context infrastructure which has no analog at the lldd level.
    
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/drivers/scsi/isci/remote_device.c b/drivers/scsi/isci/remote_device.c
index 1553221fe4d7..6b9ea9022843 100644
--- a/drivers/scsi/isci/remote_device.c
+++ b/drivers/scsi/isci/remote_device.c
@@ -52,18 +52,1169 @@
  * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
+#include "intel_sas.h"
+#include "isci.h"
+#include "port.h"
+#include "remote_device.h"
+#include "request.h"
+#include "scic_controller.h"
+#include "scic_io_request.h"
+#include "scic_phy.h"
+#include "scic_port.h"
+#include "scic_sds_controller.h"
+#include "scic_sds_phy.h"
+#include "scic_sds_port.h"
+#include "remote_node_context.h"
+#include "scic_sds_request.h"
+#include "sci_environment.h"
+#include "sci_util.h"
+#include "scu_event_codes.h"
+#include "task.h"
+
+enum sci_status scic_remote_device_stop(
+	struct scic_sds_remote_device *sci_dev,
+	u32 timeout)
+{
+	return sci_dev->state_handlers->stop_handler(sci_dev);
+}
+
+
+enum sci_status scic_remote_device_reset(
+	struct scic_sds_remote_device *sci_dev)
+{
+	return sci_dev->state_handlers->reset_handler(sci_dev);
+}
+
+
+enum sci_status scic_remote_device_reset_complete(
+	struct scic_sds_remote_device *sci_dev)
+{
+	return sci_dev->state_handlers->reset_complete_handler(sci_dev);
+}
+
+
+enum sas_linkrate scic_remote_device_get_connection_rate(
+	struct scic_sds_remote_device *sci_dev)
+{
+	return sci_dev->connection_rate;
+}
+
+
+void scic_remote_device_get_protocols(
+	struct scic_sds_remote_device *sci_dev,
+	struct smp_discover_response_protocols *pr)
+{
+	pr->u.all = sci_dev->target_protocols.u.all;
+}
+
+#if !defined(DISABLE_ATAPI)
+bool scic_remote_device_is_atapi(struct scic_sds_remote_device *sci_dev)
+{
+	return sci_dev->is_atapi;
+}
+#endif
+
+
+/**
+ *
+ *
+ * Remote device timer requirements
+ */
+#define SCIC_SDS_REMOTE_DEVICE_MINIMUM_TIMER_COUNT (0)
+#define SCIC_SDS_REMOTE_DEVICE_MAXIMUM_TIMER_COUNT (SCI_MAX_REMOTE_DEVICES)
+
+
+/**
+ *
+ * @sci_dev: The remote device for which the suspend is being requested.
+ *
+ * This method invokes the remote device suspend state handler. enum sci_status
+ */
+enum sci_status scic_sds_remote_device_suspend(
+	struct scic_sds_remote_device *sci_dev,
+	u32 suspend_type)
+{
+	return sci_dev->state_handlers->suspend_handler(sci_dev, suspend_type);
+}
+
+/**
+ *
+ * @sci_dev: The remote device for which the event handling is being
+ *    requested.
+ * @frame_index: This is the frame index that is being processed.
+ *
+ * This method invokes the frame handler for the remote device state machine
+ * enum sci_status
+ */
+enum sci_status scic_sds_remote_device_frame_handler(
+	struct scic_sds_remote_device *sci_dev,
+	u32 frame_index)
+{
+	return sci_dev->state_handlers->frame_handler(sci_dev, frame_index);
+}
+
+/**
+ *
+ * @sci_dev: The remote device for which the event handling is being
+ *    requested.
+ * @event_code: This is the event code that is to be processed.
+ *
+ * This method invokes the remote device event handler. enum sci_status
+ */
+enum sci_status scic_sds_remote_device_event_handler(
+	struct scic_sds_remote_device *sci_dev,
+	u32 event_code)
+{
+	return sci_dev->state_handlers->event_handler(sci_dev, event_code);
+}
+
+/**
+ *
+ * @controller: The controller that is starting the io request.
+ * @sci_dev: The remote device for which the start io handling is being
+ *    requested.
+ * @io_request: The io request that is being started.
+ *
+ * This method invokes the remote device start io handler. enum sci_status
+ */
+enum sci_status scic_sds_remote_device_start_io(
+	struct scic_sds_controller *controller,
+	struct scic_sds_remote_device *sci_dev,
+	struct scic_sds_request *io_request)
+{
+	return sci_dev->state_handlers->start_io_handler(
+		       sci_dev, io_request);
+}
+
+/**
+ *
+ * @controller: The controller that is completing the io request.
+ * @sci_dev: The remote device for which the complete io handling is being
+ *    requested.
+ * @io_request: The io request that is being completed.
+ *
+ * This method invokes the remote device complete io handler. enum sci_status
+ */
+enum sci_status scic_sds_remote_device_complete_io(
+	struct scic_sds_controller *controller,
+	struct scic_sds_remote_device *sci_dev,
+	struct scic_sds_request *io_request)
+{
+	return sci_dev->state_handlers->complete_io_handler(
+		       sci_dev, io_request);
+}
+
+/**
+ *
+ * @controller: The controller that is starting the task request.
+ * @sci_dev: The remote device for which the start task handling is being
+ *    requested.
+ * @io_request: The task request that is being started.
+ *
+ * This method invokes the remote device start task handler. enum sci_status
+ */
+enum sci_status scic_sds_remote_device_start_task(
+	struct scic_sds_controller *controller,
+	struct scic_sds_remote_device *sci_dev,
+	struct scic_sds_request *io_request)
+{
+	return sci_dev->state_handlers->start_task_handler(
+		       sci_dev, io_request);
+}
+
+/**
+ *
+ * @controller: The controller that is completing the task request.
+ * @sci_dev: The remote device for which the complete task handling is
+ *    being requested.
+ * @io_request: The task request that is being completed.
+ *
+ * This method invokes the remote device complete task handler. enum sci_status
+ */
+
+/**
+ *
+ * @sci_dev:
+ * @request:
+ *
+ * This method takes the request and bulids an appropriate SCU context for the
+ * request and then requests the controller to post the request. none
+ */
+void scic_sds_remote_device_post_request(
+	struct scic_sds_remote_device *sci_dev,
+	u32 request)
+{
+	u32 context;
+
+	context = scic_sds_remote_device_build_command_context(sci_dev, request);
+
+	scic_sds_controller_post_request(
+		scic_sds_remote_device_get_controller(sci_dev),
+		context
+		);
+}
+
+#if !defined(DISABLE_ATAPI)
+/**
+ *
+ * @sci_dev: The device to be checked.
+ *
+ * This method check the signature fis of a stp device to decide whether a
+ * device is atapi or not. true if a device is atapi device. False if a device
+ * is not atapi.
+ */
+bool scic_sds_remote_device_is_atapi(
+	struct scic_sds_remote_device *sci_dev)
+{
+	if (!sci_dev->target_protocols.u.bits.attached_stp_target)
+		return false;
+	else if (sci_dev->is_direct_attached) {
+		struct scic_sds_phy *phy;
+		struct scic_sata_phy_properties properties;
+		struct sata_fis_reg_d2h *signature_fis;
+		phy = scic_sds_port_get_a_connected_phy(sci_dev->owning_port);
+		scic_sata_phy_get_properties(phy, &properties);
+
+		/* decode the signature fis. */
+		signature_fis = &(properties.signature_fis);
+
+		if ((signature_fis->sector_count  == 0x01)
+		    && (signature_fis->lba_low       == 0x01)
+		    && (signature_fis->lba_mid       == 0x14)
+		    && (signature_fis->lba_high      == 0xEB)
+		    && ((signature_fis->device & 0x5F) == 0x00)
+		    ) {
+			/* An ATA device supporting the PACKET command set. */
+			return true;
+		} else
+			return false;
+	} else {
+		/* Expander supported ATAPI device is not currently supported. */
+		return false;
+	}
+}
+#endif
+
+/**
+ *
+ * @user_parameter: This is cast to a remote device object.
+ *
+ * This method is called once the remote node context is ready to be freed.
+ * The remote device can now report that its stop operation is complete. none
+ */
+static void scic_sds_cb_remote_device_rnc_destruct_complete(
+	void *user_parameter)
+{
+	struct scic_sds_remote_device *sci_dev;
+
+	sci_dev = (struct scic_sds_remote_device *)user_parameter;
+
+	BUG_ON(sci_dev->started_request_count != 0);
+
+	sci_base_state_machine_change_state(&sci_dev->state_machine,
+					    SCI_BASE_REMOTE_DEVICE_STATE_STOPPED);
+}
+
+/**
+ *
+ * @user_parameter: This is cast to a remote device object.
+ *
+ * This method is called once the remote node context has transisitioned to a
+ * ready state.  This is the indication that the remote device object can also
+ * transition to ready. none
+ */
+static void scic_sds_remote_device_resume_complete_handler(
+	void *user_parameter)
+{
+	struct scic_sds_remote_device *sci_dev;
+
+	sci_dev = (struct scic_sds_remote_device *)user_parameter;
+
+	if (
+		sci_base_state_machine_get_state(&sci_dev->state_machine)
+		!= SCI_BASE_REMOTE_DEVICE_STATE_READY
+		) {
+		sci_base_state_machine_change_state(
+			&sci_dev->state_machine,
+			SCI_BASE_REMOTE_DEVICE_STATE_READY
+			);
+	}
+}
+
+/**
+ *
+ * @device: This parameter specifies the device for which the request is being
+ *    started.
+ * @request: This parameter specifies the request being started.
+ * @status: This parameter specifies the current start operation status.
+ *
+ * This method will perform the STP request start processing common to IO
+ * requests and task requests of all types. none
+ */
+void scic_sds_remote_device_start_request(
+	struct scic_sds_remote_device *sci_dev,
+	struct scic_sds_request *sci_req,
+	enum sci_status status)
+{
+	/* We still have a fault in starting the io complete it on the port */
+	if (status == SCI_SUCCESS)
+		scic_sds_remote_device_increment_request_count(sci_dev);
+	else{
+		sci_dev->owning_port->state_handlers->complete_io_handler(
+			sci_dev->owning_port, sci_dev, sci_req
+			);
+	}
+}
+
+
+/**
+ *
+ * @request: This parameter specifies the request being continued.
+ *
+ * This method will continue to post tc for a STP request. This method usually
+ * serves as a callback when RNC gets resumed during a task management
+ * sequence. none
+ */
+void scic_sds_remote_device_continue_request(void *dev)
+{
+	struct scic_sds_remote_device *sci_dev = dev;
+
+	/* we need to check if this request is still valid to continue. */
+	if (sci_dev->working_request)
+		scic_controller_continue_io(sci_dev->working_request);
+}
+
+/**
+ * This method will terminate all of the IO requests in the controllers IO
+ *    request table that were targeted for this device.
+ * @sci_dev: This parameter specifies the remote device for which to
+ *    attempt to terminate all requests.
+ *
+ * This method returns an indication as to whether all requests were
+ * successfully terminated.  If a single request fails to be terminated, then
+ * this method will return the failure.
+ */
+static enum sci_status scic_sds_remote_device_terminate_requests(
+	struct scic_sds_remote_device *sci_dev)
+{
+	enum sci_status status           = SCI_SUCCESS;
+	enum sci_status terminate_status = SCI_SUCCESS;
+	struct scic_sds_request *sci_req;
+	u32 index;
+	u32 request_count    = sci_dev->started_request_count;
+
+	for (index = 0;
+	     (index < SCI_MAX_IO_REQUESTS) && (request_count > 0);
+	     index++) {
+		sci_req = sci_dev->owning_port->owning_controller->io_request_table[index];
+
+		if ((sci_req != NULL) && (sci_req->target_device == sci_dev)) {
+			terminate_status = scic_controller_terminate_request(
+				sci_dev->owning_port->owning_controller,
+				sci_dev,
+				sci_req
+				);
+
+			if (terminate_status != SCI_SUCCESS)
+				status = terminate_status;
+
+			request_count--;
+		}
+	}
+
+	return status;
+}
+
+static enum sci_status
+default_device_handler(struct scic_sds_remote_device *sci_dev,
+		       const char *func)
+{
+	dev_warn(scirdev_to_dev(sci_dev),
+		 "%s: in wrong state: %d\n", func,
+		 sci_base_state_machine_get_state(&sci_dev->state_machine));
+	return SCI_FAILURE_INVALID_STATE;
+}
+
+enum sci_status scic_sds_remote_device_default_start_handler(
+	struct scic_sds_remote_device *sci_dev)
+{
+	return default_device_handler(sci_dev, __func__);
+}
+
+static enum sci_status scic_sds_remote_device_default_stop_handler(
+	struct scic_sds_remote_device *sci_dev)
+{
+	return default_device_handler(sci_dev, __func__);
+}
+
+enum sci_status scic_sds_remote_device_default_fail_handler(
+	struct scic_sds_remote_device *sci_dev)
+{
+	return default_device_handler(sci_dev, __func__);
+}
+
+enum sci_status scic_sds_remote_device_default_destruct_handler(
+	struct scic_sds_remote_device *sci_dev)
+{
+	return default_device_handler(sci_dev, __func__);
+}
+
+enum sci_status scic_sds_remote_device_default_reset_handler(
+	struct scic_sds_remote_device *sci_dev)
+{
+	return default_device_handler(sci_dev, __func__);
+}
+
+enum sci_status scic_sds_remote_device_default_reset_complete_handler(
+	struct scic_sds_remote_device *sci_dev)
+{
+	return default_device_handler(sci_dev, __func__);
+}
+
+enum sci_status scic_sds_remote_device_default_suspend_handler(
+	struct scic_sds_remote_device *sci_dev, u32 suspend_type)
+{
+	return default_device_handler(sci_dev, __func__);
+}
+
+enum sci_status scic_sds_remote_device_default_resume_handler(
+	struct scic_sds_remote_device *sci_dev)
+{
+	return default_device_handler(sci_dev, __func__);
+}
+
+/**
+ *
+ * @device: The struct scic_sds_remote_device which is then cast into a
+ *    struct scic_sds_remote_device.
+ * @event_code: The event code that the struct scic_sds_controller wants the device
+ *    object to process.
+ *
+ * This method is the default event handler.  It will call the RNC state
+ * machine handler for any RNC events otherwise it will log a warning and
+ * returns a failure. enum sci_status SCI_FAILURE_INVALID_STATE
+ */
+static enum sci_status  scic_sds_remote_device_core_event_handler(
+	struct scic_sds_remote_device *sci_dev,
+	u32 event_code,
+	bool is_ready_state)
+{
+	enum sci_status status;
+
+	switch (scu_get_event_type(event_code)) {
+	case SCU_EVENT_TYPE_RNC_OPS_MISC:
+	case SCU_EVENT_TYPE_RNC_SUSPEND_TX:
+	case SCU_EVENT_TYPE_RNC_SUSPEND_TX_RX:
+		status = scic_sds_remote_node_context_event_handler(&sci_dev->rnc, event_code);
+		break;
+	case SCU_EVENT_TYPE_PTX_SCHEDULE_EVENT:
+
+		if (scu_get_event_code(event_code) == SCU_EVENT_IT_NEXUS_TIMEOUT) {
+			status = SCI_SUCCESS;
+
+			/* Suspend the associated RNC */
+			scic_sds_remote_node_context_suspend(&sci_dev->rnc,
+							      SCI_SOFTWARE_SUSPENSION,
+							      NULL, NULL);
+
+			dev_dbg(scirdev_to_dev(sci_dev),
+				"%s: device: %p event code: %x: %s\n",
+				__func__, sci_dev, event_code,
+				(is_ready_state)
+				? "I_T_Nexus_Timeout event"
+				: "I_T_Nexus_Timeout event in wrong state");
+
+			break;
+		}
+	/* Else, fall through and treat as unhandled... */
+
+	default:
+		dev_dbg(scirdev_to_dev(sci_dev),
+			"%s: device: %p event code: %x: %s\n",
+			__func__, sci_dev, event_code,
+			(is_ready_state)
+			? "unexpected event"
+			: "unexpected event in wrong state");
+		status = SCI_FAILURE_INVALID_STATE;
+		break;
+	}
+
+	return status;
+}
+/**
+ *
+ * @device: The struct scic_sds_remote_device which is then cast into a
+ *    struct scic_sds_remote_device.
+ * @event_code: The event code that the struct scic_sds_controller wants the device
+ *    object to process.
+ *
+ * This method is the default event handler.  It will call the RNC state
+ * machine handler for any RNC events otherwise it will log a warning and
+ * returns a failure. enum sci_status SCI_FAILURE_INVALID_STATE
+ */
+static enum sci_status  scic_sds_remote_device_default_event_handler(
+	struct scic_sds_remote_device *sci_dev,
+	u32 event_code)
+{
+	return scic_sds_remote_device_core_event_handler(sci_dev,
+							  event_code,
+							  false);
+}
+
+/**
+ *
+ * @device: The struct scic_sds_remote_device which is then cast into a
+ *    struct scic_sds_remote_device.
+ * @frame_index: The frame index for which the struct scic_sds_controller wants this
+ *    device object to process.
+ *
+ * This method is the default unsolicited frame handler.  It logs a warning,
+ * releases the frame and returns a failure. enum sci_status
+ * SCI_FAILURE_INVALID_STATE
+ */
+enum sci_status scic_sds_remote_device_default_frame_handler(
+	struct scic_sds_remote_device *sci_dev,
+	u32 frame_index)
+{
+	dev_warn(scirdev_to_dev(sci_dev),
+		 "%s: SCIC Remote Device requested to handle frame %x "
+		 "while in wrong state %d\n",
+		 __func__,
+		 frame_index,
+		 sci_base_state_machine_get_state(
+			 &sci_dev->state_machine));
+
+	/* Return the frame back to the controller */
+	scic_sds_controller_release_frame(
+		scic_sds_remote_device_get_controller(sci_dev), frame_index
+		);
+
+	return SCI_FAILURE_INVALID_STATE;
+}
+
+enum sci_status scic_sds_remote_device_default_start_request_handler(
+	struct scic_sds_remote_device *sci_dev,
+	struct scic_sds_request *request)
+{
+	return default_device_handler(sci_dev, __func__);
+}
+
+enum sci_status scic_sds_remote_device_default_complete_request_handler(
+	struct scic_sds_remote_device *sci_dev,
+	struct scic_sds_request *request)
+{
+	return default_device_handler(sci_dev, __func__);
+}
+
+enum sci_status scic_sds_remote_device_default_continue_request_handler(
+	struct scic_sds_remote_device *sci_dev,
+	struct scic_sds_request *request)
+{
+	return default_device_handler(sci_dev, __func__);
+}
+
+/**
+ *
+ * @device: The struct scic_sds_remote_device which is then cast into a
+ *    struct scic_sds_remote_device.
+ * @frame_index: The frame index for which the struct scic_sds_controller wants this
+ *    device object to process.
+ *
+ * This method is a general ssp frame handler.  In most cases the device object
+ * needs to route the unsolicited frame processing to the io request object.
+ * This method decodes the tag for the io request object and routes the
+ * unsolicited frame to that object. enum sci_status SCI_FAILURE_INVALID_STATE
+ */
+enum sci_status scic_sds_remote_device_general_frame_handler(
+	struct scic_sds_remote_device *sci_dev,
+	u32 frame_index)
+{
+	enum sci_status result;
+	struct sci_ssp_frame_header *frame_header;
+	struct scic_sds_request *io_request;
+
+	result = scic_sds_unsolicited_frame_control_get_header(
+		&(scic_sds_remote_device_get_controller(sci_dev)->uf_control),
+		frame_index,
+		(void **)&frame_header
+		);
+
+	if (SCI_SUCCESS == result) {
+		io_request = scic_sds_controller_get_io_request_from_tag(
+			scic_sds_remote_device_get_controller(sci_dev), frame_header->tag);
+
+		if ((io_request == NULL)
+		    || (io_request->target_device != sci_dev)) {
+			/*
+			 * We could not map this tag to a valid IO request
+			 * Just toss the frame and continue */
+			scic_sds_controller_release_frame(
+				scic_sds_remote_device_get_controller(sci_dev), frame_index
+				);
+		} else {
+			/* The IO request is now in charge of releasing the frame */
+			result = io_request->state_handlers->frame_handler(
+				io_request, frame_index);
+		}
+	}
+
+	return result;
+}
+
+/**
+ *
+ * @[in]: sci_dev This is the device object that is receiving the event.
+ * @[in]: event_code The event code to process.
+ *
+ * This is a common method for handling events reported to the remote device
+ * from the controller object. enum sci_status
+ */
+enum sci_status scic_sds_remote_device_general_event_handler(
+	struct scic_sds_remote_device *sci_dev,
+	u32 event_code)
+{
+	return scic_sds_remote_device_core_event_handler(sci_dev,
+							  event_code,
+							  true);
+}
+
+/*
+ * *****************************************************************************
+ * *  STOPPED STATE HANDLERS
+ * ***************************************************************************** */
+
+/**
+ *
+ * @device:
+ *
+ * This method takes the struct scic_sds_remote_device from a stopped state and
+ * attempts to start it.   The RNC buffer for the device is constructed and the
+ * device state machine is transitioned to the
+ * SCIC_BASE_REMOTE_DEVICE_STATE_STARTING. enum sci_status SCI_SUCCESS if there is
+ * an RNC buffer available to construct the remote device.
+ * SCI_FAILURE_INSUFFICIENT_RESOURCES if there is no RNC buffer available in
+ * which to construct the remote device.
+ */
+static enum sci_status scic_sds_remote_device_stopped_state_start_handler(
+	struct scic_sds_remote_device *sci_dev)
+{
+	enum sci_status status;
+
+	status = scic_sds_remote_node_context_resume(&sci_dev->rnc,
+			scic_sds_remote_device_resume_complete_handler, sci_dev);
+
+	if (status == SCI_SUCCESS)
+		sci_base_state_machine_change_state(&sci_dev->state_machine,
+						    SCI_BASE_REMOTE_DEVICE_STATE_STARTING);
+
+	return status;
+}
+
+static enum sci_status scic_sds_remote_device_stopped_state_stop_handler(
+	struct scic_sds_remote_device *sci_dev)
+{
+	return SCI_SUCCESS;
+}
+
+/**
+ *
+ * @sci_dev: The struct scic_sds_remote_device which is cast into a
+ *    struct scic_sds_remote_device.
+ *
+ * This method will destruct a struct scic_sds_remote_device that is in a stopped
+ * state.  This is the only state from which a destruct request will succeed.
+ * The RNi for this struct scic_sds_remote_device is returned to the free pool and the
+ * device object transitions to the SCI_BASE_REMOTE_DEVICE_STATE_FINAL.
+ * enum sci_status SCI_SUCCESS
+ */
+static enum sci_status scic_sds_remote_device_stopped_state_destruct_handler(
+	struct scic_sds_remote_device *sci_dev)
+{
+	struct scic_sds_controller *scic;
+
+	scic = scic_sds_remote_device_get_controller(sci_dev);
+	scic_sds_controller_free_remote_node_context(scic, sci_dev,
+						     sci_dev->rnc.remote_node_index);
+	sci_dev->rnc.remote_node_index = SCIC_SDS_REMOTE_NODE_CONTEXT_INVALID_INDEX;
+
+	sci_base_state_machine_change_state(&sci_dev->state_machine,
+					    SCI_BASE_REMOTE_DEVICE_STATE_FINAL);
+
+	return SCI_SUCCESS;
+}
+
+/*
+ * *****************************************************************************
+ * *  STARTING STATE HANDLERS
+ * ***************************************************************************** */
+
+static enum sci_status scic_sds_remote_device_starting_state_stop_handler(
+	struct scic_sds_remote_device *sci_dev)
+{
+	/*
+	 * This device has not yet started so there had better be no IO requests
+	 */
+	BUG_ON(sci_dev->started_request_count != 0);
+
+	/*
+	 * Destroy the remote node context
+	 */
+	scic_sds_remote_node_context_destruct(&sci_dev->rnc,
+		scic_sds_cb_remote_device_rnc_destruct_complete, sci_dev);
+
+	/*
+	 * Transition to the stopping state and wait for the remote node to
+	 * complete being posted and invalidated.
+	 */
+	sci_base_state_machine_change_state(&sci_dev->state_machine,
+					    SCI_BASE_REMOTE_DEVICE_STATE_STOPPING);
+
+	return SCI_SUCCESS;
+}
+
+enum sci_status scic_sds_remote_device_ready_state_stop_handler(
+	struct scic_sds_remote_device *sci_dev)
+{
+	enum sci_status status = SCI_SUCCESS;
+
+	/* Request the parent state machine to transition to the stopping state */
+	sci_base_state_machine_change_state(&sci_dev->state_machine,
+					    SCI_BASE_REMOTE_DEVICE_STATE_STOPPING);
+
+	if (sci_dev->started_request_count == 0) {
+		scic_sds_remote_node_context_destruct(&sci_dev->rnc,
+			scic_sds_cb_remote_device_rnc_destruct_complete,
+			sci_dev);
+	} else
+		status = scic_sds_remote_device_terminate_requests(sci_dev);
+
+	return status;
+}
+
+/**
+ *
+ * @device: The struct scic_sds_remote_device object which is cast to a
+ *    struct scic_sds_remote_device object.
+ *
+ * This is the ready state device reset handler enum sci_status
+ */
+enum sci_status scic_sds_remote_device_ready_state_reset_handler(
+	struct scic_sds_remote_device *sci_dev)
+{
+	/* Request the parent state machine to transition to the stopping state */
+	sci_base_state_machine_change_state(&sci_dev->state_machine,
+					    SCI_BASE_REMOTE_DEVICE_STATE_RESETTING);
+
+	return SCI_SUCCESS;
+}
+
+/*
+ * This method will attempt to start a task request for this device object. The
+ * remote device object will issue the start request for the task and if
+ * successful it will start the request for the port object then increment its
+ * own requet count. enum sci_status SCI_SUCCESS if the task request is started for
+ * this device object. SCI_FAILURE_INSUFFICIENT_RESOURCES if the io request
+ * object could not get the resources to start.
+ */
+static enum sci_status scic_sds_remote_device_ready_state_start_task_handler(
+	struct scic_sds_remote_device *sci_dev,
+	struct scic_sds_request *request)
+{
+	enum sci_status result;
+
+	/* See if the port is in a state where we can start the IO request */
+	result = scic_sds_port_start_io(
+		scic_sds_remote_device_get_port(sci_dev), sci_dev, request);
+
+	if (result == SCI_SUCCESS) {
+		result = scic_sds_remote_node_context_start_task(&sci_dev->rnc,
+								 request);
+		if (result == SCI_SUCCESS)
+			result = scic_sds_request_start(request);
+
+		scic_sds_remote_device_start_request(sci_dev, request, result);
+	}
+
+	return result;
+}
+
+/*
+ * This method will attempt to start an io request for this device object. The
+ * remote device object will issue the start request for the io and if
+ * successful it will start the request for the port object then increment its
+ * own requet count. enum sci_status SCI_SUCCESS if the io request is started for
+ * this device object. SCI_FAILURE_INSUFFICIENT_RESOURCES if the io request
+ * object could not get the resources to start.
+ */
+static enum sci_status scic_sds_remote_device_ready_state_start_io_handler(
+	struct scic_sds_remote_device *sci_dev,
+	struct scic_sds_request *request)
+{
+	enum sci_status result;
+
+	/* See if the port is in a state where we can start the IO request */
+	result = scic_sds_port_start_io(
+		scic_sds_remote_device_get_port(sci_dev), sci_dev, request);
+
+	if (result == SCI_SUCCESS) {
+		result = scic_sds_remote_node_context_start_io(&sci_dev->rnc, request);
+		if (result == SCI_SUCCESS)
+			result = scic_sds_request_start(request);
+
+		scic_sds_remote_device_start_request(sci_dev, request, result);
+	}
+
+	return result;
+}
+
+/*
+ * This method will complete the request for the remote device object.  The
+ * method will call the completion handler for the request object and if
+ * successful it will complete the request on the port object then decrement
+ * its own started_request_count. enum sci_status
+ */
+static enum sci_status scic_sds_remote_device_ready_state_complete_request_handler(
+	struct scic_sds_remote_device *sci_dev,
+	struct scic_sds_request *request)
+{
+	enum sci_status result;
+
+	result = scic_sds_request_complete(request);
+
+	if (result != SCI_SUCCESS)
+		return result;
+
+	/* See if the port is in a state
+	 * where we can start the IO request */
+	result = scic_sds_port_complete_io(
+			scic_sds_remote_device_get_port(sci_dev),
+			sci_dev, request);
+
+	if (result == SCI_SUCCESS)
+		scic_sds_remote_device_decrement_request_count(sci_dev);
+
+	return result;
+}
+
+/*
+ * *****************************************************************************
+ * *  STOPPING STATE HANDLERS
+ * ***************************************************************************** */
+
+/**
+ *
+ * @sci_dev: The struct scic_sds_remote_device which is cast into a
+ *    struct scic_sds_remote_device.
+ *
+ * This method will stop a struct scic_sds_remote_device that is already in the
+ * SCI_BASE_REMOTE_DEVICE_STATE_STOPPING state. This is not considered an error
+ * since we allow a stop request on a device that is alreay stopping or
+ * stopped. enum sci_status SCI_SUCCESS
+ */
+static enum sci_status scic_sds_remote_device_stopping_state_stop_handler(
+	struct scic_sds_remote_device *device)
+{
+	/*
+	 * All requests should have been terminated, but if there is an
+	 * attempt to stop a device already in the stopping state, then
+	 * try again to terminate. */
+	return scic_sds_remote_device_terminate_requests(device);
+}
 
-#include "isci.h"
-#include "scic_io_request.h"
-#include "scic_remote_device.h"
-#include "scic_phy.h"
-#include "scic_port.h"
-#include "port.h"
-#include "remote_device.h"
-#include "request.h"
-#include "task.h"
 
+/**
+ *
+ * @device: The device object for which the request is completing.
+ * @request: The task request that is being completed.
+ *
+ * This method completes requests for this struct scic_sds_remote_device while it is
+ * in the SCI_BASE_REMOTE_DEVICE_STATE_STOPPING state. This method calls the
+ * complete method for the request object and if that is successful the port
+ * object is called to complete the task request. Then the device object itself
+ * completes the task request. If struct scic_sds_remote_device started_request_count
+ * goes to 0 and the invalidate RNC request has completed the device object can
+ * transition to the SCI_BASE_REMOTE_DEVICE_STATE_STOPPED. enum sci_status
+ */
+static enum sci_status scic_sds_remote_device_stopping_state_complete_request_handler(
+	struct scic_sds_remote_device *sci_dev,
+	struct scic_sds_request *request)
+{
+	enum sci_status status = SCI_SUCCESS;
+
+	status = scic_sds_request_complete(request);
+
+	if (status != SCI_SUCCESS)
+		return status;
+
+	status = scic_sds_port_complete_io(scic_sds_remote_device_get_port(sci_dev),
+					   sci_dev, request);
+	if (status != SCI_SUCCESS)
+		return status;
+
+	scic_sds_remote_device_decrement_request_count(sci_dev);
+
+	if (scic_sds_remote_device_get_request_count(sci_dev) == 0)
+		scic_sds_remote_node_context_destruct(&sci_dev->rnc,
+						      scic_sds_cb_remote_device_rnc_destruct_complete,
+						      sci_dev);
+	return SCI_SUCCESS;
+}
+
+/**
+ *
+ * @device: The struct scic_sds_remote_device which is to be cast into a
+ *    struct scic_sds_remote_device object.
+ *
+ * This method will complete the reset operation when the device is in the
+ * resetting state. enum sci_status
+ */
+static enum sci_status scic_sds_remote_device_resetting_state_reset_complete_handler(
+	struct scic_sds_remote_device *sci_dev)
+{
+
+	sci_base_state_machine_change_state(
+		&sci_dev->state_machine,
+		SCI_BASE_REMOTE_DEVICE_STATE_READY
+		);
+
+	return SCI_SUCCESS;
+}
+
+/**
+ *
+ * @device: The struct scic_sds_remote_device which is to be cast into a
+ *    struct scic_sds_remote_device object.
+ *
+ * This method will stop the remote device while in the resetting state.
+ * enum sci_status
+ */
+static enum sci_status scic_sds_remote_device_resetting_state_stop_handler(
+	struct scic_sds_remote_device *sci_dev)
+{
+	sci_base_state_machine_change_state(
+		&sci_dev->state_machine,
+		SCI_BASE_REMOTE_DEVICE_STATE_STOPPING
+		);
+
+	return SCI_SUCCESS;
+}
+
+/*
+ * This method completes requests for this struct scic_sds_remote_device while it is
+ * in the SCI_BASE_REMOTE_DEVICE_STATE_RESETTING state. This method calls the
+ * complete method for the request object and if that is successful the port
+ * object is called to complete the task request. Then the device object itself
+ * completes the task request. enum sci_status
+ */
+static enum sci_status scic_sds_remote_device_resetting_state_complete_request_handler(
+	struct scic_sds_remote_device *sci_dev,
+	struct scic_sds_request *request)
+{
+	enum sci_status status = SCI_SUCCESS;
+
+	status = scic_sds_request_complete(request);
+
+	if (status == SCI_SUCCESS) {
+		status = scic_sds_port_complete_io(
+				scic_sds_remote_device_get_port(sci_dev),
+				sci_dev, request);
+
+		if (status == SCI_SUCCESS) {
+			scic_sds_remote_device_decrement_request_count(sci_dev);
+		}
+	}
+
+	return status;
+}
+
+static const struct scic_sds_remote_device_state_handler scic_sds_remote_device_state_handler_table[] = {
+	[SCI_BASE_REMOTE_DEVICE_STATE_INITIAL] = {
+		.start_handler		= scic_sds_remote_device_default_start_handler,
+		.stop_handler		= scic_sds_remote_device_default_stop_handler,
+		.fail_handler		= scic_sds_remote_device_default_fail_handler,
+		.destruct_handler	= scic_sds_remote_device_default_destruct_handler,
+		.reset_handler		= scic_sds_remote_device_default_reset_handler,
+		.reset_complete_handler	= scic_sds_remote_device_default_reset_complete_handler,
+		.start_io_handler	= scic_sds_remote_device_default_start_request_handler,
+		.complete_io_handler	= scic_sds_remote_device_default_complete_request_handler,
+		.continue_io_handler	= scic_sds_remote_device_default_continue_request_handler,
+		.start_task_handler	= scic_sds_remote_device_default_start_request_handler,
+		.complete_task_handler	= scic_sds_remote_device_default_complete_request_handler,
+		.suspend_handler	= scic_sds_remote_device_default_suspend_handler,
+		.resume_handler		= scic_sds_remote_device_default_resume_handler,
+		.event_handler		= scic_sds_remote_device_default_event_handler,
+		.frame_handler		= scic_sds_remote_device_default_frame_handler
+	},
+	[SCI_BASE_REMOTE_DEVICE_STATE_STOPPED] = {
+		.start_handler		= scic_sds_remote_device_stopped_state_start_handler,
+		.stop_handler		= scic_sds_remote_device_stopped_state_stop_handler,
+		.fail_handler		= scic_sds_remote_device_default_fail_handler,
+		.destruct_handler	= scic_sds_remote_device_stopped_state_destruct_handler,
+		.reset_handler		= scic_sds_remote_device_default_reset_handler,
+		.reset_complete_handler	= scic_sds_remote_device_default_reset_complete_handler,
+		.start_io_handler	= scic_sds_remote_device_default_start_request_handler,
+		.complete_io_handler	= scic_sds_remote_device_default_complete_request_handler,
+		.continue_io_handler	= scic_sds_remote_device_default_continue_request_handler,
+		.start_task_handler	= scic_sds_remote_device_default_start_request_handler,
+		.complete_task_handler	= scic_sds_remote_device_default_complete_request_handler,
+		.suspend_handler	= scic_sds_remote_device_default_suspend_handler,
+		.resume_handler		= scic_sds_remote_device_default_resume_handler,
+		.event_handler		= scic_sds_remote_device_default_event_handler,
+		.frame_handler		= scic_sds_remote_device_default_frame_handler
+	},
+	[SCI_BASE_REMOTE_DEVICE_STATE_STARTING] = {
+		.start_handler		= scic_sds_remote_device_default_start_handler,
+		.stop_handler		= scic_sds_remote_device_starting_state_stop_handler,
+		.fail_handler		= scic_sds_remote_device_default_fail_handler,
+		.destruct_handler	= scic_sds_remote_device_default_destruct_handler,
+		.reset_handler		= scic_sds_remote_device_default_reset_handler,
+		.reset_complete_handler	= scic_sds_remote_device_default_reset_complete_handler,
+		.start_io_handler	= scic_sds_remote_device_default_start_request_handler,
+		.complete_io_handler	= scic_sds_remote_device_default_complete_request_handler,
+		.continue_io_handler	= scic_sds_remote_device_default_continue_request_handler,
+		.start_task_handler	= scic_sds_remote_device_default_start_request_handler,
+		.complete_task_handler	= scic_sds_remote_device_default_complete_request_handler,
+		.suspend_handler	= scic_sds_remote_device_default_suspend_handler,
+		.resume_handler		= scic_sds_remote_device_default_resume_handler,
+		.event_handler		= scic_sds_remote_device_general_event_handler,
+		.frame_handler		= scic_sds_remote_device_default_frame_handler
+	},
+	[SCI_BASE_REMOTE_DEVICE_STATE_READY] = {
+		.start_handler		= scic_sds_remote_device_default_start_handler,
+		.stop_handler		= scic_sds_remote_device_ready_state_stop_handler,
+		.fail_handler		= scic_sds_remote_device_default_fail_handler,
+		.destruct_handler	= scic_sds_remote_device_default_destruct_handler,
+		.reset_handler		= scic_sds_remote_device_ready_state_reset_handler,
+		.reset_complete_handler	= scic_sds_remote_device_default_reset_complete_handler,
+		.start_io_handler	= scic_sds_remote_device_ready_state_start_io_handler,
+		.complete_io_handler	= scic_sds_remote_device_ready_state_complete_request_handler,
+		.continue_io_handler	= scic_sds_remote_device_default_continue_request_handler,
+		.start_task_handler	= scic_sds_remote_device_ready_state_start_task_handler,
+		.complete_task_handler	= scic_sds_remote_device_ready_state_complete_request_handler,
+		.suspend_handler	= scic_sds_remote_device_default_suspend_handler,
+		.resume_handler		= scic_sds_remote_device_default_resume_handler,
+		.event_handler		= scic_sds_remote_device_general_event_handler,
+		.frame_handler		= scic_sds_remote_device_general_frame_handler,
+	},
+	[SCI_BASE_REMOTE_DEVICE_STATE_STOPPING] = {
+		.start_handler		= scic_sds_remote_device_default_start_handler,
+		.stop_handler		= scic_sds_remote_device_stopping_state_stop_handler,
+		.fail_handler		= scic_sds_remote_device_default_fail_handler,
+		.destruct_handler	= scic_sds_remote_device_default_destruct_handler,
+		.reset_handler		= scic_sds_remote_device_default_reset_handler,
+		.reset_complete_handler	= scic_sds_remote_device_default_reset_complete_handler,
+		.start_io_handler	= scic_sds_remote_device_default_start_request_handler,
+		.complete_io_handler	= scic_sds_remote_device_stopping_state_complete_request_handler,
+		.continue_io_handler	= scic_sds_remote_device_default_continue_request_handler,
+		.start_task_handler	= scic_sds_remote_device_default_start_request_handler,
+		.complete_task_handler	= scic_sds_remote_device_stopping_state_complete_request_handler,
+		.suspend_handler	= scic_sds_remote_device_default_suspend_handler,
+		.resume_handler		= scic_sds_remote_device_default_resume_handler,
+		.event_handler		= scic_sds_remote_device_general_event_handler,
+		.frame_handler		= scic_sds_remote_device_general_frame_handler
+	},
+	[SCI_BASE_REMOTE_DEVICE_STATE_FAILED] = {
+		.start_handler		= scic_sds_remote_device_default_start_handler,
+		.stop_handler		= scic_sds_remote_device_default_stop_handler,
+		.fail_handler		= scic_sds_remote_device_default_fail_handler,
+		.destruct_handler	= scic_sds_remote_device_default_destruct_handler,
+		.reset_handler		= scic_sds_remote_device_default_reset_handler,
+		.reset_complete_handler	= scic_sds_remote_device_default_reset_complete_handler,
+		.start_io_handler	= scic_sds_remote_device_default_start_request_handler,
+		.complete_io_handler	= scic_sds_remote_device_default_complete_request_handler,
+		.continue_io_handler	= scic_sds_remote_device_default_continue_request_handler,
+		.start_task_handler	= scic_sds_remote_device_default_start_request_handler,
+		.complete_task_handler	= scic_sds_remote_device_default_complete_request_handler,
+		.suspend_handler	= scic_sds_remote_device_default_suspend_handler,
+		.resume_handler		= scic_sds_remote_device_default_resume_handler,
+		.event_handler		= scic_sds_remote_device_default_event_handler,
+		.frame_handler		= scic_sds_remote_device_general_frame_handler
+	},
+	[SCI_BASE_REMOTE_DEVICE_STATE_RESETTING] = {
+		.start_handler		= scic_sds_remote_device_default_start_handler,
+		.stop_handler		= scic_sds_remote_device_resetting_state_stop_handler,
+		.fail_handler		= scic_sds_remote_device_default_fail_handler,
+		.destruct_handler	= scic_sds_remote_device_default_destruct_handler,
+		.reset_handler		= scic_sds_remote_device_default_reset_handler,
+		.reset_complete_handler	= scic_sds_remote_device_resetting_state_reset_complete_handler,
+		.start_io_handler	= scic_sds_remote_device_default_start_request_handler,
+		.complete_io_handler	= scic_sds_remote_device_resetting_state_complete_request_handler,
+		.continue_io_handler	= scic_sds_remote_device_default_continue_request_handler,
+		.start_task_handler	= scic_sds_remote_device_default_start_request_handler,
+		.complete_task_handler	= scic_sds_remote_device_resetting_state_complete_request_handler,
+		.suspend_handler	= scic_sds_remote_device_default_suspend_handler,
+		.resume_handler		= scic_sds_remote_device_default_resume_handler,
+		.event_handler		= scic_sds_remote_device_default_event_handler,
+		.frame_handler		= scic_sds_remote_device_general_frame_handler
+	},
+	[SCI_BASE_REMOTE_DEVICE_STATE_FINAL] = {
+		.start_handler		= scic_sds_remote_device_default_start_handler,
+		.stop_handler		= scic_sds_remote_device_default_stop_handler,
+		.fail_handler		= scic_sds_remote_device_default_fail_handler,
+		.destruct_handler	= scic_sds_remote_device_default_destruct_handler,
+		.reset_handler		= scic_sds_remote_device_default_reset_handler,
+		.reset_complete_handler	= scic_sds_remote_device_default_reset_complete_handler,
+		.start_io_handler	= scic_sds_remote_device_default_start_request_handler,
+		.complete_io_handler	= scic_sds_remote_device_default_complete_request_handler,
+		.continue_io_handler	= scic_sds_remote_device_default_continue_request_handler,
+		.start_task_handler	= scic_sds_remote_device_default_start_request_handler,
+		.complete_task_handler	= scic_sds_remote_device_default_complete_request_handler,
+		.suspend_handler	= scic_sds_remote_device_default_suspend_handler,
+		.resume_handler		= scic_sds_remote_device_default_resume_handler,
+		.event_handler		= scic_sds_remote_device_default_event_handler,
+		.frame_handler		= scic_sds_remote_device_default_frame_handler
+	}
+};
+
+static void scic_sds_remote_device_initial_state_enter(
+	struct sci_base_object *object)
+{
+	struct scic_sds_remote_device *sci_dev = (struct scic_sds_remote_device *)object;
+
+	sci_dev = container_of(object, typeof(*sci_dev), parent);
+	SET_STATE_HANDLER(sci_dev, scic_sds_remote_device_state_handler_table,
+			  SCI_BASE_REMOTE_DEVICE_STATE_INITIAL);
+
+	/* Initial state is a transitional state to the stopped state */
+	sci_base_state_machine_change_state(&sci_dev->state_machine,
+					    SCI_BASE_REMOTE_DEVICE_STATE_STOPPED);
+}
+
+/**
+ * isci_remote_device_change_state() - This function gets the status of the
+ *    remote_device object.
+ * @isci_device: This parameter points to the isci_remote_device object
+ *
+ * status of the object as a isci_status enum.
+ */
+void isci_remote_device_change_state(
+	struct isci_remote_device *isci_device,
+	enum isci_status status)
+{
+	unsigned long flags;
+
+	spin_lock_irqsave(&isci_device->state_lock, flags);
+	isci_device->status = status;
+	spin_unlock_irqrestore(&isci_device->state_lock, flags);
+}
 
+/**
+ * scic_remote_device_destruct() - free remote node context and destruct
+ * @remote_device: This parameter specifies the remote device to be destructed.
+ *
+ * Remote device objects are a limited resource.  As such, they must be
+ * protected.  Thus calls to construct and destruct are mutually exclusive and
+ * non-reentrant. The return value shall indicate if the device was
+ * successfully destructed or if some failure occurred. enum sci_status This value
+ * is returned if the device is successfully destructed.
+ * SCI_FAILURE_INVALID_REMOTE_DEVICE This value is returned if the supplied
+ * device isn't valid (e.g. it's already been destoryed, the handle isn't
+ * valid, etc.).
+ */
+static enum sci_status scic_remote_device_destruct(struct scic_sds_remote_device *sci_dev)
+{
+	return sci_dev->state_handlers->destruct_handler(sci_dev);
+}
 
 /**
  * isci_remote_device_deconstruct() - This function frees an isci_remote_device.
@@ -98,6 +1249,418 @@ static void isci_remote_device_deconstruct(struct isci_host *ihost, struct isci_
 	wake_up(&ihost->eventq);
 }
 
+/**
+ * isci_remote_device_stop_complete() - This function is called by the scic
+ *    when the remote device stop has completed. We mark the isci device as not
+ *    ready and remove the isci remote device.
+ * @ihost: This parameter specifies the isci host object.
+ * @idev: This parameter specifies the remote device.
+ * @status: This parameter specifies status of the completion.
+ *
+ */
+static void isci_remote_device_stop_complete(struct isci_host *ihost,
+					     struct isci_remote_device *idev)
+{
+	dev_dbg(&ihost->pdev->dev, "%s: complete idev = %p\n", __func__, idev);
+
+	isci_remote_device_change_state(idev, isci_stopped);
+
+	/* after stop, we can tear down resources. */
+	isci_remote_device_deconstruct(ihost, idev);
+}
+
+static void scic_sds_remote_device_stopped_state_enter(
+	struct sci_base_object *object)
+{
+	struct scic_sds_remote_device *sci_dev;
+	struct scic_sds_controller *scic;
+	struct isci_remote_device *idev;
+	struct isci_host *ihost;
+	u32 prev_state;
+
+	sci_dev = container_of(object, typeof(*sci_dev), parent);
+	scic = scic_sds_remote_device_get_controller(sci_dev);
+	ihost = sci_object_get_association(scic);
+	idev = sci_object_get_association(sci_dev);
+
+	SET_STATE_HANDLER(sci_dev, scic_sds_remote_device_state_handler_table,
+			  SCI_BASE_REMOTE_DEVICE_STATE_STOPPED);
+
+	/* If we are entering from the stopping state let the SCI User know that
+	 * the stop operation has completed.
+	 */
+	prev_state = sci_dev->state_machine.previous_state_id;
+	if (prev_state == SCI_BASE_REMOTE_DEVICE_STATE_STOPPING)
+		isci_remote_device_stop_complete(ihost, idev);
+
+	scic_sds_controller_remote_device_stopped(scic, sci_dev);
+}
+
+static void scic_sds_remote_device_starting_state_enter(struct sci_base_object *object)
+{
+	struct scic_sds_remote_device *sci_dev = container_of(object, typeof(*sci_dev),
+							      parent);
+	struct scic_sds_controller *scic = scic_sds_remote_device_get_controller(sci_dev);
+	struct isci_host *ihost = sci_object_get_association(scic);
+	struct isci_remote_device *idev = sci_object_get_association(sci_dev);
+
+	SET_STATE_HANDLER(sci_dev, scic_sds_remote_device_state_handler_table,
+			  SCI_BASE_REMOTE_DEVICE_STATE_STARTING);
+
+	isci_remote_device_not_ready(ihost, idev,
+				     SCIC_REMOTE_DEVICE_NOT_READY_START_REQUESTED);
+}
+
+static void scic_sds_remote_device_ready_state_enter(struct sci_base_object *object)
+{
+	struct scic_sds_remote_device *sci_dev = container_of(object, typeof(*sci_dev),
+							      parent);
+	struct scic_sds_controller *scic = scic_sds_remote_device_get_controller(sci_dev);
+	struct isci_host *ihost = sci_object_get_association(scic);
+	struct isci_remote_device *idev = sci_object_get_association(sci_dev);
+
+	SET_STATE_HANDLER(sci_dev,
+			  scic_sds_remote_device_state_handler_table,
+			  SCI_BASE_REMOTE_DEVICE_STATE_READY);
+
+	scic->remote_device_sequence[sci_dev->rnc.remote_node_index]++;
+
+	if (sci_dev->has_ready_substate_machine)
+		sci_base_state_machine_start(&sci_dev->ready_substate_machine);
+	else
+		isci_remote_device_ready(ihost, idev);
+}
+
+static void scic_sds_remote_device_ready_state_exit(
+	struct sci_base_object *object)
+{
+	struct scic_sds_remote_device *sci_dev = container_of(object, typeof(*sci_dev),
+							      parent);
+	if (sci_dev->has_ready_substate_machine)
+		sci_base_state_machine_stop(&sci_dev->ready_substate_machine);
+	else {
+		struct scic_sds_controller *scic = scic_sds_remote_device_get_controller(sci_dev);
+		struct isci_host *ihost = sci_object_get_association(scic);
+		struct isci_remote_device *idev = sci_object_get_association(sci_dev);
+
+		isci_remote_device_not_ready(ihost, idev,
+					     SCIC_REMOTE_DEVICE_NOT_READY_STOP_REQUESTED);
+	}
+}
+
+static void scic_sds_remote_device_stopping_state_enter(
+	struct sci_base_object *object)
+{
+	struct scic_sds_remote_device *sci_dev = (struct scic_sds_remote_device *)object;
+
+	SET_STATE_HANDLER(
+		sci_dev,
+		scic_sds_remote_device_state_handler_table,
+		SCI_BASE_REMOTE_DEVICE_STATE_STOPPING
+		);
+}
+
+static void scic_sds_remote_device_failed_state_enter(
+	struct sci_base_object *object)
+{
+	struct scic_sds_remote_device *sci_dev = (struct scic_sds_remote_device *)object;
+
+	SET_STATE_HANDLER(
+		sci_dev,
+		scic_sds_remote_device_state_handler_table,
+		SCI_BASE_REMOTE_DEVICE_STATE_FAILED
+		);
+}
+
+static void scic_sds_remote_device_resetting_state_enter(
+	struct sci_base_object *object)
+{
+	struct scic_sds_remote_device *sci_dev = (struct scic_sds_remote_device *)object;
+
+	SET_STATE_HANDLER(
+		sci_dev,
+		scic_sds_remote_device_state_handler_table,
+		SCI_BASE_REMOTE_DEVICE_STATE_RESETTING
+		);
+
+	scic_sds_remote_node_context_suspend(
+		&sci_dev->rnc, SCI_SOFTWARE_SUSPENSION, NULL, NULL);
+}
+
+static void scic_sds_remote_device_resetting_state_exit(
+	struct sci_base_object *object)
+{
+	struct scic_sds_remote_device *sci_dev = (struct scic_sds_remote_device *)object;
+
+	scic_sds_remote_node_context_resume(&sci_dev->rnc, NULL, NULL);
+}
+
+static void scic_sds_remote_device_final_state_enter(
+	struct sci_base_object *object)
+{
+	struct scic_sds_remote_device *sci_dev = (struct scic_sds_remote_device *)object;
+
+	SET_STATE_HANDLER(
+		sci_dev,
+		scic_sds_remote_device_state_handler_table,
+		SCI_BASE_REMOTE_DEVICE_STATE_FINAL
+		);
+}
+
+
+static const struct sci_base_state scic_sds_remote_device_state_table[] = {
+	[SCI_BASE_REMOTE_DEVICE_STATE_INITIAL] = {
+		.enter_state = scic_sds_remote_device_initial_state_enter,
+	},
+	[SCI_BASE_REMOTE_DEVICE_STATE_STOPPED] = {
+		.enter_state = scic_sds_remote_device_stopped_state_enter,
+	},
+	[SCI_BASE_REMOTE_DEVICE_STATE_STARTING] = {
+		.enter_state = scic_sds_remote_device_starting_state_enter,
+	},
+	[SCI_BASE_REMOTE_DEVICE_STATE_READY] = {
+		.enter_state = scic_sds_remote_device_ready_state_enter,
+		.exit_state  = scic_sds_remote_device_ready_state_exit
+	},
+	[SCI_BASE_REMOTE_DEVICE_STATE_STOPPING] = {
+		.enter_state = scic_sds_remote_device_stopping_state_enter,
+	},
+	[SCI_BASE_REMOTE_DEVICE_STATE_FAILED] = {
+		.enter_state = scic_sds_remote_device_failed_state_enter,
+	},
+	[SCI_BASE_REMOTE_DEVICE_STATE_RESETTING] = {
+		.enter_state = scic_sds_remote_device_resetting_state_enter,
+		.exit_state  = scic_sds_remote_device_resetting_state_exit
+	},
+	[SCI_BASE_REMOTE_DEVICE_STATE_FINAL] = {
+		.enter_state = scic_sds_remote_device_final_state_enter,
+	},
+};
+
+/**
+ * scic_remote_device_construct() - This method will perform the construction
+ *    common to all remote device objects.
+ * @sci_port: SAS/SATA port through which this device is accessed.
+ * @sci_dev: remote device to construct
+ *
+ * It isn't necessary to call scic_remote_device_destruct() for device objects
+ * that have only called this method for construction. Once subsequent
+ * construction methods have been invoked (e.g.
+ * scic_remote_device_da_construct()), then destruction should occur. none
+ */
+static void scic_remote_device_construct(struct scic_sds_port *sci_port,
+				  struct scic_sds_remote_device *sci_dev)
+{
+	sci_dev->owning_port = sci_port;
+	sci_dev->started_request_count = 0;
+	sci_dev->parent.private = NULL;
+
+	sci_base_state_machine_construct(
+		&sci_dev->state_machine,
+		&sci_dev->parent,
+		scic_sds_remote_device_state_table,
+		SCI_BASE_REMOTE_DEVICE_STATE_INITIAL
+		);
+
+	sci_base_state_machine_start(
+		&sci_dev->state_machine
+		);
+
+	scic_sds_remote_node_context_construct(&sci_dev->rnc,
+					       SCIC_SDS_REMOTE_NODE_CONTEXT_INVALID_INDEX);
+
+	sci_object_set_association(&sci_dev->rnc, sci_dev);
+}
+
+/**
+ * scic_remote_device_da_construct() - This method will construct a
+ *    SCIC_REMOTE_DEVICE object for a direct attached (da) device.  The
+ *    information (e.g. IAF, Signature FIS, etc.) necessary to build the device
+ *    is known to the SCI Core since it is contained in the scic_phy object.
+ * @remote_device: This parameter specifies the remote device to be destructed.
+ *
+ * The user must have previously called scic_remote_device_construct() Remote
+ * device objects are a limited resource.  As such, they must be protected.
+ * Thus calls to construct and destruct are mutually exclusive and
+ * non-reentrant. Indicate if the remote device was successfully constructed.
+ * SCI_SUCCESS Returned if the device was successfully constructed.
+ * SCI_FAILURE_DEVICE_EXISTS Returned if the device has already been
+ * constructed.  If it's an additional phy for the target, then call
+ * scic_remote_device_da_add_phy(). SCI_FAILURE_UNSUPPORTED_PROTOCOL Returned
+ * if the supplied parameters necessitate creation of a remote device for which
+ * the protocol is not supported by the underlying controller hardware.
+ * SCI_FAILURE_INSUFFICIENT_RESOURCES This value is returned if the core
+ * controller associated with the supplied parameters is unable to support
+ * additional remote devices.
+ */
+static enum sci_status scic_remote_device_da_construct(struct scic_sds_remote_device *sci_dev)
+{
+	enum sci_status status;
+	u16 remote_node_index;
+	struct sci_sas_identify_address_frame_protocols protocols;
+
+	/*
+	 * This information is request to determine how many remote node context
+	 * entries will be needed to store the remote node.
+	 */
+	scic_sds_port_get_attached_protocols(sci_dev->owning_port, &protocols);
+	sci_dev->target_protocols.u.all = protocols.u.all;
+	sci_dev->is_direct_attached = true;
+#if !defined(DISABLE_ATAPI)
+	sci_dev->is_atapi = scic_sds_remote_device_is_atapi(sci_dev);
+#endif
+
+	status = scic_sds_controller_allocate_remote_node_context(
+		sci_dev->owning_port->owning_controller,
+		sci_dev,
+		&remote_node_index);
+
+	if (status == SCI_SUCCESS) {
+		sci_dev->rnc.remote_node_index = remote_node_index;
+
+		scic_sds_port_get_attached_sas_address(
+			sci_dev->owning_port, &sci_dev->device_address);
+
+		if (sci_dev->target_protocols.u.bits.attached_ssp_target) {
+			sci_dev->has_ready_substate_machine = false;
+		} else if (sci_dev->target_protocols.u.bits.attached_stp_target) {
+			sci_dev->has_ready_substate_machine = true;
+
+			sci_base_state_machine_construct(
+				&sci_dev->ready_substate_machine,
+				&sci_dev->parent,
+				scic_sds_stp_remote_device_ready_substate_table,
+				SCIC_SDS_STP_REMOTE_DEVICE_READY_SUBSTATE_IDLE);
+		} else if (sci_dev->target_protocols.u.bits.attached_smp_target) {
+			sci_dev->has_ready_substate_machine = true;
+
+			/* add the SMP ready substate machine construction here */
+			sci_base_state_machine_construct(
+				&sci_dev->ready_substate_machine,
+				&sci_dev->parent,
+				scic_sds_smp_remote_device_ready_substate_table,
+				SCIC_SDS_SMP_REMOTE_DEVICE_READY_SUBSTATE_IDLE);
+		}
+
+		sci_dev->connection_rate = scic_sds_port_get_max_allowed_speed(
+			sci_dev->owning_port);
+
+		/* / @todo Should I assign the port width by reading all of the phys on the port? */
+		sci_dev->device_port_width = 1;
+	}
+
+	return status;
+}
+
+static void scic_sds_remote_device_get_info_from_smp_discover_response(
+	struct scic_sds_remote_device *sci_dev,
+	struct smp_response_discover *discover_response)
+{
+	/* decode discover_response to set sas_address to sci_dev. */
+	sci_dev->device_address.high =
+		discover_response->attached_sas_address.high;
+
+	sci_dev->device_address.low =
+		discover_response->attached_sas_address.low;
+
+	sci_dev->target_protocols.u.all = discover_response->protocols.u.all;
+}
+
+/**
+ * scic_remote_device_ea_construct() - This method will construct an
+ *    SCIC_REMOTE_DEVICE object for an expander attached (ea) device from an
+ *    SMP Discover Response.
+ * @remote_device: This parameter specifies the remote device to be destructed.
+ * @discover_response: This parameter specifies the SMP Discovery Response to
+ *    be used in device creation.
+ *
+ * The user must have previously called scic_remote_device_construct() Remote
+ * device objects are a limited resource.  As such, they must be protected.
+ * Thus calls to construct and destruct are mutually exclusive and
+ * non-reentrant. Indicate if the remote device was successfully constructed.
+ * SCI_SUCCESS Returned if the device was successfully constructed.
+ * SCI_FAILURE_DEVICE_EXISTS Returned if the device has already been
+ * constructed.  If it's an additional phy for the target, then call
+ * scic_ea_remote_device_add_phy(). SCI_FAILURE_UNSUPPORTED_PROTOCOL Returned
+ * if the supplied parameters necessitate creation of a remote device for which
+ * the protocol is not supported by the underlying controller hardware.
+ * SCI_FAILURE_INSUFFICIENT_RESOURCES This value is returned if the core
+ * controller associated with the supplied parameters is unable to support
+ * additional remote devices.
+ */
+static enum sci_status scic_remote_device_ea_construct(struct scic_sds_remote_device *sci_dev,
+						       struct smp_response_discover *discover_response)
+{
+	enum sci_status status;
+	struct scic_sds_controller *scic;
+
+	scic = scic_sds_port_get_controller(sci_dev->owning_port);
+
+	scic_sds_remote_device_get_info_from_smp_discover_response(
+		sci_dev, discover_response);
+
+	status = scic_sds_controller_allocate_remote_node_context(
+		scic, sci_dev, &sci_dev->rnc.remote_node_index);
+
+	if (status == SCI_SUCCESS) {
+		if (sci_dev->target_protocols.u.bits.attached_ssp_target) {
+			sci_dev->has_ready_substate_machine = false;
+		} else if (sci_dev->target_protocols.u.bits.attached_smp_target) {
+			sci_dev->has_ready_substate_machine = true;
+
+			/* add the SMP ready substate machine construction here */
+			sci_base_state_machine_construct(
+				&sci_dev->ready_substate_machine,
+				&sci_dev->parent,
+				scic_sds_smp_remote_device_ready_substate_table,
+				SCIC_SDS_SMP_REMOTE_DEVICE_READY_SUBSTATE_IDLE);
+		} else if (sci_dev->target_protocols.u.bits.attached_stp_target) {
+			sci_dev->has_ready_substate_machine = true;
+
+			sci_base_state_machine_construct(
+				&sci_dev->ready_substate_machine,
+				&sci_dev->parent,
+				scic_sds_stp_remote_device_ready_substate_table,
+				SCIC_SDS_STP_REMOTE_DEVICE_READY_SUBSTATE_IDLE);
+		}
+
+		/*
+		 * For SAS-2 the physical link rate is actually a logical link
+		 * rate that incorporates multiplexing.  The SCU doesn't
+		 * incorporate multiplexing and for the purposes of the
+		 * connection the logical link rate is that same as the
+		 * physical.  Furthermore, the SAS-2 and SAS-1.1 fields overlay
+		 * one another, so this code works for both situations. */
+		sci_dev->connection_rate = min_t(u16,
+			scic_sds_port_get_max_allowed_speed(sci_dev->owning_port),
+			discover_response->u2.sas1_1.negotiated_physical_link_rate
+			);
+
+		/* / @todo Should I assign the port width by reading all of the phys on the port? */
+		sci_dev->device_port_width = 1;
+	}
+
+	return status;
+}
+
+/**
+ * scic_remote_device_start() - This method will start the supplied remote
+ *    device.  This method enables normal IO requests to flow through to the
+ *    remote device.
+ * @remote_device: This parameter specifies the device to be started.
+ * @timeout: This parameter specifies the number of milliseconds in which the
+ *    start operation should complete.
+ *
+ * An indication of whether the device was successfully started. SCI_SUCCESS
+ * This value is returned if the device was successfully started.
+ * SCI_FAILURE_INVALID_PHY This value is returned if the user attempts to start
+ * the device when there have been no phys added to it.
+ */
+static enum sci_status scic_remote_device_start(struct scic_sds_remote_device *sci_dev,
+					 u32 timeout)
+{
+	return sci_dev->state_handlers->start_handler(sci_dev);
+}
 
 /**
  * isci_remote_device_construct() - This function calls the scic remote device
@@ -306,51 +1869,6 @@ void isci_remote_device_not_ready(struct isci_host *ihost,
 		isci_remote_device_change_state(idev, isci_ready);
 }
 
-/**
- * isci_remote_device_stop_complete() - This function is called by the scic
- *    when the remote device stop has completed. We mark the isci device as not
- *    ready and remove the isci remote device.
- * @isci_host: This parameter specifies the isci host object.
- * @isci_device: This parameter specifies the remote device.
- * @status: This parameter specifies status of the completion.
- *
- */
-void isci_remote_device_stop_complete(
-	struct isci_host *isci_host,
-	struct isci_remote_device *isci_device,
-	enum sci_status status)
-{
-	dev_dbg(&isci_host->pdev->dev,
-		"%s: complete isci_device = %p, status = 0x%x\n",
-		__func__,
-		isci_device,
-		status);
-
-	isci_remote_device_change_state(isci_device, isci_stopped);
-
-	/* after stop, we can tear down resources. */
-	isci_remote_device_deconstruct(isci_host, isci_device);
-
-}
-
-/**
- * isci_remote_device_start_complete() - This function is called by the scic
- *    when the remote device start has completed
- * @isci_host: This parameter specifies the isci host object.
- * @isci_device: This parameter specifies the remote device.
- * @status: This parameter specifies status of the completion.
- *
- */
-void isci_remote_device_start_complete(
-	struct isci_host *isci_host,
-	struct isci_remote_device *isci_device,
-	enum sci_status status)
-{
-
-
-}
-
-
 /**
  * isci_remote_device_stop() - This function is called internally to stop the
  *    remote device.
@@ -572,21 +2090,3 @@ void isci_device_clear_reset_pending(struct isci_host *ihost, struct isci_remote
 	}
 	spin_unlock_irqrestore(&ihost->scic_lock, flags);
 }
-
-/**
- * isci_remote_device_change_state() - This function gets the status of the
- *    remote_device object.
- * @isci_device: This parameter points to the isci_remote_device object
- *
- * status of the object as a isci_status enum.
- */
-void isci_remote_device_change_state(
-	struct isci_remote_device *isci_device,
-	enum isci_status status)
-{
-	unsigned long flags;
-
-	spin_lock_irqsave(&isci_device->state_lock, flags);
-	isci_device->status = status;
-	spin_unlock_irqrestore(&isci_device->state_lock, flags);
-}

commit 57f20f4ed6fb702339be2ef4dea9d15e6a7d0d07
Author: Dan Williams <dan.j.williams@intel.com>
Date:   Thu Apr 21 18:14:45 2011 -0700

    isci: unify remote_device data structures
    
    Make it explicit that isci_remote_device and scic_sds_remote_device are
    one in the same object.
    
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/drivers/scsi/isci/remote_device.c b/drivers/scsi/isci/remote_device.c
index 9301e25dff31..1553221fe4d7 100644
--- a/drivers/scsi/isci/remote_device.c
+++ b/drivers/scsi/isci/remote_device.c
@@ -87,7 +87,7 @@ static void isci_remote_device_deconstruct(struct isci_host *ihost, struct isci_
 		BUG();
 	}
 
-	scic_remote_device_destruct(to_sci_dev(idev));
+	scic_remote_device_destruct(&idev->sci);
 	idev->domain_dev->lldd_dev = NULL;
 	idev->domain_dev = NULL;
 	idev->isci_port = NULL;
@@ -117,7 +117,7 @@ static enum sci_status isci_remote_device_construct(
 
 	/* let the core do it's common constuction. */
 	scic_remote_device_construct(port->sci_port_handle,
-				     to_sci_dev(isci_device));
+				     &isci_device->sci);
 
 	/* let the core do it's device specific constuction. */
 	if (isci_device->domain_dev->parent &&
@@ -183,11 +183,11 @@ static enum sci_status isci_remote_device_construct(
 			"%s: parent->dev_type = EDGE_DEV\n",
 			__func__);
 
-		status = scic_remote_device_ea_construct(to_sci_dev(isci_device),
+		status = scic_remote_device_ea_construct(&isci_device->sci,
 				(struct smp_response_discover *)&discover_response);
 
 	} else
-		status = scic_remote_device_da_construct(to_sci_dev(isci_device));
+		status = scic_remote_device_da_construct(&isci_device->sci);
 
 
 	if (status != SCI_SUCCESS) {
@@ -200,10 +200,11 @@ static enum sci_status isci_remote_device_construct(
 		return status;
 	}
 
-	sci_object_set_association(to_sci_dev(isci_device), isci_device);
+	/* XXX will be killed with sci_base_object removal */
+	sci_object_set_association(&isci_device->sci, isci_device);
 
 	/* start the device. */
-	status = scic_remote_device_start(to_sci_dev(isci_device),
+	status = scic_remote_device_start(&isci_device->sci,
 					  ISCI_REMOTE_DEVICE_START_TIMEOUT);
 
 	if (status != SCI_SUCCESS) {
@@ -245,7 +246,7 @@ isci_remote_device_alloc(struct isci_host *ihost, struct isci_port *iport)
 	int i;
 
 	for (i = 0; i < SCI_MAX_REMOTE_DEVICES; i++) {
-		idev = idev_by_id(ihost, i);
+		idev = &ihost->devices[i];
 		if (!test_and_set_bit(IDEV_ALLOCATED, &idev->flags))
 			break;
 	}
@@ -374,7 +375,7 @@ enum sci_status isci_remote_device_stop(struct isci_host *ihost, struct isci_rem
 	set_bit(IDEV_STOP_PENDING, &idev->flags);
 
 	spin_lock_irqsave(&ihost->scic_lock, flags);
-	status = scic_remote_device_stop(to_sci_dev(idev), 50);
+	status = scic_remote_device_stop(&idev->sci, 50);
 	spin_unlock_irqrestore(&ihost->scic_lock, flags);
 
 	/* Wait for the stop complete callback. */

commit 6cb4d6b382be6345c2d0c4b1b90dfdf9af32da7e
Author: Bartosz Barcinski <Bartosz.Barcinski@intel.com>
Date:   Tue Apr 12 17:28:43 2011 -0700

    isci: audit usage of BUG_ON macro in isci driver
    
    Removes unnecessary usage of BUG_ON macro, excluding core directory.
    In some cases macro is unnecesary, check is done in caller function.
    In other cases macro is replaced by if construction with
    appropriate warning.
    
    Signed-off-by: Maciej Patelczyk <maciej.patelczyk@intel.com>
    [changed some survivable bug conditions to WARN_ONCE]
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/drivers/scsi/isci/remote_device.c b/drivers/scsi/isci/remote_device.c
index 320850cf46f2..9301e25dff31 100644
--- a/drivers/scsi/isci/remote_device.c
+++ b/drivers/scsi/isci/remote_device.c
@@ -202,8 +202,6 @@ static enum sci_status isci_remote_device_construct(
 
 	sci_object_set_association(to_sci_dev(isci_device), isci_device);
 
-	BUG_ON(port->isci_host == NULL);
-
 	/* start the device. */
 	status = scic_remote_device_start(to_sci_dev(isci_device),
 					  ISCI_REMOTE_DEVICE_START_TIMEOUT);
@@ -257,8 +255,12 @@ isci_remote_device_alloc(struct isci_host *ihost, struct isci_port *iport)
 		return NULL;
 	}
 
-	BUG_ON(!list_empty(&idev->reqs_in_process));
-	BUG_ON(!list_empty(&idev->node));
+	if (WARN_ONCE(!list_empty(&idev->reqs_in_process), "found requests in process\n"))
+		return NULL;
+
+	if (WARN_ONCE(!list_empty(&idev->node), "found non-idle remote device\n"))
+		return NULL;
+
 	isci_remote_device_change_state(idev, isci_freed);
 
 	return idev;

commit 467e855a0331f619f41fbf7391bc29ec0ca923a0
Author: Bartosz Barcinski <Bartosz.Barcinski@intel.com>
Date:   Tue Apr 12 17:28:41 2011 -0700

    isci: sparse warnings cleanup
    
    Clean warnings and errors reported by sparse tool.
    
    request.c:430:50: warning: mixing different enum types
    remote_device.c:534:39: warning: symbol 'flags' shadows an earlier one
    task.c:495:44: warning: mixing different enum types
    scic_sds_controller.c:2155:24: warning: mixing different enum types
    scic_sds_controller.c:2272:36: warning: mixing different enum types
    scic_sds_controller.c:2911:38: warning: incorrect type in initializer (different address spaces)
    scic_sds_controller.c:2913:25: warning: incorrect type in argument 2 (different address spaces)
    scic_sds_request.c:875:34: warning: cast removes address space of expression
    scic_sds_request.c:876:123: warning: incorrect type in argument 2 (different address spaces)
    scic_sds_port.c:585:51: warning: incorrect type in assignment (different address spaces)
    scic_sds_port.c:712:9: warning: incorrect type in argument 2 (different address spaces)
    scic_sds_port.c:1770:25: warning: incorrect type in argument 2 (different address spaces)
    
    Signed-off-by: Bartosz Barcinski <Bartosz.Barcinski@intel.com>
    Signed-off-by: Maciej Patelczyk <maciej.patelczyk@intel.com>
    [fixed up some false positives and misconversions]
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/drivers/scsi/isci/remote_device.c b/drivers/scsi/isci/remote_device.c
index ab638ec5881c..320850cf46f2 100644
--- a/drivers/scsi/isci/remote_device.c
+++ b/drivers/scsi/isci/remote_device.c
@@ -513,15 +513,13 @@ bool isci_device_is_reset_pending(
 			__func__, isci_device, isci_request);
 
 		if (isci_request->ttype == io_task) {
-
-			unsigned long flags;
 			struct sas_task *task = isci_request_access_task(
 				isci_request);
 
-			spin_lock_irqsave(&task->task_state_lock, flags);
+			spin_lock(&task->task_state_lock);
 			if (task->task_state_flags & SAS_TASK_NEED_DEV_RESET)
 				reset_is_pending = true;
-			spin_unlock_irqrestore(&task->task_state_lock, flags);
+			spin_unlock(&task->task_state_lock);
 		}
 	}
 

commit 4393aa4e6b9517a666f0ef6b774fd421a9dc4c68
Author: Dan Williams <dan.j.williams@intel.com>
Date:   Thu Mar 31 13:10:44 2011 -0700

    isci: fix fragile/conditional isci_host lookups
    
    A domain_device can always reference back to ->lldd_ha unlike local lldd
    structures.  Fix up cases where the driver uses local objects to look up the
    isci_host.  This also changes the calling conventions of some routines to
    expect a valid isci_host parameter rather than re-lookup the pointer on entry.
    
    Incidentally cleans up some macros that are longer to type than the open-coded
    equivalent:
      isci_host_from_sas_ha
      isci_dev_from_domain_dev
    
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/drivers/scsi/isci/remote_device.c b/drivers/scsi/isci/remote_device.c
index 0fdaa6d62c1b..ab638ec5881c 100644
--- a/drivers/scsi/isci/remote_device.c
+++ b/drivers/scsi/isci/remote_device.c
@@ -218,33 +218,20 @@ static enum sci_status isci_remote_device_construct(
 	return status;
 }
 
-
-/**
- * isci_remote_device_nuke_requests() - This function terminates all requests
- *    for a given remote device.
- * @isci_device: This parameter specifies the remote device
- *
- */
-void isci_remote_device_nuke_requests(
-	struct isci_remote_device *isci_device)
+void isci_remote_device_nuke_requests(struct isci_host *ihost, struct isci_remote_device *idev)
 {
 	DECLARE_COMPLETION_ONSTACK(aborted_task_completion);
-	struct isci_host *isci_host;
 
-	isci_host = isci_device->isci_port->isci_host;
-
-	dev_dbg(&isci_host->pdev->dev,
-		"%s: isci_device = %p\n", __func__, isci_device);
+	dev_dbg(&ihost->pdev->dev,
+		"%s: idev = %p\n", __func__, idev);
 
 	/* Cleanup all requests pending for this device. */
-	isci_terminate_pending_requests(isci_host, isci_device, terminating);
+	isci_terminate_pending_requests(ihost, idev, terminating);
 
-	dev_dbg(&isci_host->pdev->dev,
-		"%s: isci_device = %p, done\n", __func__, isci_device);
+	dev_dbg(&ihost->pdev->dev,
+		"%s: idev = %p, done\n", __func__, idev);
 }
 
-
-
 /**
  * This function builds the isci_remote_device when a libsas dev_found message
  *    is received.
@@ -380,7 +367,7 @@ enum sci_status isci_remote_device_stop(struct isci_host *ihost, struct isci_rem
 	isci_remote_device_change_state(idev, isci_stopping);
 
 	/* Kill all outstanding requests. */
-	isci_remote_device_nuke_requests(idev);
+	isci_remote_device_nuke_requests(ihost, idev);
 
 	set_bit(IDEV_STOP_PENDING, &idev->flags);
 
@@ -409,7 +396,7 @@ enum sci_status isci_remote_device_stop(struct isci_host *ihost, struct isci_rem
  */
 void isci_remote_device_gone(struct domain_device *dev)
 {
-	struct isci_host *ihost = dev->port->ha->lldd_ha;
+	struct isci_host *ihost = dev_to_ihost(dev);
 	struct isci_remote_device *idev = dev->lldd_dev;
 
 	dev_dbg(&ihost->pdev->dev,
@@ -431,7 +418,7 @@ void isci_remote_device_gone(struct domain_device *dev)
  */
 int isci_remote_device_found(struct domain_device *domain_dev)
 {
-	struct isci_host *isci_host;
+	struct isci_host *isci_host = dev_to_ihost(domain_dev);
 	struct isci_port *isci_port;
 	struct isci_phy *isci_phy;
 	struct asd_sas_port *sas_port;
@@ -439,8 +426,6 @@ int isci_remote_device_found(struct domain_device *domain_dev)
 	struct isci_remote_device *isci_device;
 	enum sci_status status;
 
-	isci_host = isci_host_from_sas_ha(domain_dev->port->ha);
-
 	dev_dbg(&isci_host->pdev->dev,
 		"%s: domain_device = %p\n", __func__, domain_dev);
 
@@ -556,41 +541,22 @@ bool isci_device_is_reset_pending(
  *
  * true if there is a reset pending for the device.
  */
-void isci_device_clear_reset_pending(struct isci_remote_device *isci_device)
+void isci_device_clear_reset_pending(struct isci_host *ihost, struct isci_remote_device *idev)
 {
 	struct isci_request *isci_request;
 	struct isci_request *tmp_req;
-	struct isci_host *isci_host = NULL;
 	unsigned long flags = 0;
 
-	/* FIXME more port gone confusion, and this time it makes the
-	 * locking "fun"
-	 */
-	if (isci_device->isci_port != NULL)
-		isci_host = isci_device->isci_port->isci_host;
-
-	/*
-	 * FIXME when the isci_host gets sorted out
-	 * use dev_dbg()
-	 */
-	pr_debug("%s: isci_device=%p, isci_host=%p\n",
-		 __func__, isci_device, isci_host);
+	dev_dbg(&ihost->pdev->dev, "%s: idev=%p, ihost=%p\n",
+		 __func__, idev, ihost);
 
-	if (isci_host != NULL)
-		spin_lock_irqsave(&isci_host->scic_lock, flags);
-	else
-		pr_err("%s: isci_device %p; isci_host == NULL!\n",
-		       __func__, isci_device);
+	spin_lock_irqsave(&ihost->scic_lock, flags);
 
 	/* Clear reset pending on all pending requests. */
 	list_for_each_entry_safe(isci_request, tmp_req,
-				 &isci_device->reqs_in_process, dev_node) {
-		/*
-		 * FIXME when the conditional spinlock is gone
-		 * change to dev_dbg()
-		 */
-		pr_debug("%s: isci_device = %p request = %p\n",
-			 __func__, isci_device, isci_request);
+				 &idev->reqs_in_process, dev_node) {
+		dev_dbg(&ihost->pdev->dev, "%s: idev = %p request = %p\n",
+			 __func__, idev, isci_request);
 
 		if (isci_request->ttype == io_task) {
 
@@ -603,9 +569,7 @@ void isci_device_clear_reset_pending(struct isci_remote_device *isci_device)
 			spin_unlock_irqrestore(&task->task_state_lock, flags2);
 		}
 	}
-
-	if (isci_host != NULL)
-		spin_unlock_irqrestore(&isci_host->scic_lock, flags);
+	spin_unlock_irqrestore(&ihost->scic_lock, flags);
 }
 
 /**

commit 037afc7812e2b202fbc18218e6c0eff34dad36ed
Author: Dan Williams <dan.j.williams@intel.com>
Date:   Thu Mar 31 13:10:42 2011 -0700

    isci: cleanup isci_remote_device[_not]_ready interface
    
    Require a valid isci_host in support of the general cleanup to not
    re-lookup the host via potentially fragile methods when more robust
    methods are available.  Also cleans up some more casting that should be
    using container_of() to up-cast a base structure in a more type-safe
    manner.
    
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/drivers/scsi/isci/remote_device.c b/drivers/scsi/isci/remote_device.c
index 6fe6815e4b74..0fdaa6d62c1b 100644
--- a/drivers/scsi/isci/remote_device.c
+++ b/drivers/scsi/isci/remote_device.c
@@ -281,13 +281,12 @@ isci_remote_device_alloc(struct isci_host *ihost, struct isci_port *iport)
  * isci_remote_device_ready() - This function is called by the scic when the
  *    remote device is ready. We mark the isci device as ready and signal the
  *    waiting proccess.
- * @idev: This parameter specifies the remote device
+ * @ihost: our valid isci_host
+ * @idev: remote device
  *
  */
-void isci_remote_device_ready(struct isci_remote_device *idev)
+void isci_remote_device_ready(struct isci_host *ihost, struct isci_remote_device *idev)
 {
-	struct isci_host *ihost = idev->isci_port->isci_host;
-
 	dev_dbg(&ihost->pdev->dev,
 		"%s: idev = %p\n", __func__, idev);
 
@@ -304,18 +303,17 @@ void isci_remote_device_ready(struct isci_remote_device *idev)
  * @isci_device: This parameter specifies the remote device
  *
  */
-void isci_remote_device_not_ready(
-	struct isci_remote_device *isci_device,
-	u32 reason_code)
+void isci_remote_device_not_ready(struct isci_host *ihost,
+				  struct isci_remote_device *idev, u32 reason)
 {
-	dev_dbg(&isci_device->isci_port->isci_host->pdev->dev,
-		"%s: isci_device = %p\n", __func__, isci_device);
+	dev_dbg(&ihost->pdev->dev,
+		"%s: isci_device = %p\n", __func__, idev);
 
-	if (reason_code == SCIC_REMOTE_DEVICE_NOT_READY_STOP_REQUESTED)
-		isci_remote_device_change_state(isci_device, isci_stopping);
+	if (reason == SCIC_REMOTE_DEVICE_NOT_READY_STOP_REQUESTED)
+		isci_remote_device_change_state(idev, isci_stopping);
 	else
 		/* device ready is actually a "not ready for io" state. */
-		isci_remote_device_change_state(isci_device, isci_ready);
+		isci_remote_device_change_state(idev, isci_ready);
 }
 
 /**

commit 6e2802a7fc246b53f919efbf1c011da2d0a4ff30
Author: Jeff Skirvin <jeffrey.d.skirvin@intel.com>
Date:   Tue Mar 8 20:32:16 2011 -0700

    isci: All pending requests are terminated before stopping the device.
    
    Make sure all pending I/O including any in the libsas error handler
    process is cleaned-up.
    
    Signed-off-by: Jeff Skirvin <jeffrey.d.skirvin@intel.com>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/drivers/scsi/isci/remote_device.c b/drivers/scsi/isci/remote_device.c
index 1dae2184b9e9..6fe6815e4b74 100644
--- a/drivers/scsi/isci/remote_device.c
+++ b/drivers/scsi/isci/remote_device.c
@@ -380,6 +380,10 @@ enum sci_status isci_remote_device_stop(struct isci_host *ihost, struct isci_rem
 		"%s: isci_device = %p\n", __func__, idev);
 
 	isci_remote_device_change_state(idev, isci_stopping);
+
+	/* Kill all outstanding requests. */
+	isci_remote_device_nuke_requests(idev);
+
 	set_bit(IDEV_STOP_PENDING, &idev->flags);
 
 	spin_lock_irqsave(&ihost->scic_lock, flags);

commit 1a38045ba88ed3bee6c57444670fb639c8b61be7
Author: Dan Williams <dan.j.williams@intel.com>
Date:   Thu Mar 3 18:01:43 2011 -0800

    isci: replace remote_device_lock  with scic_lock
    
    The remote_device_lock is currently used to protect a controller global
    resource (RNCs), but the remote_device_lock is per-port.
    
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/drivers/scsi/isci/remote_device.c b/drivers/scsi/isci/remote_device.c
index 48556e47bb9d..1dae2184b9e9 100644
--- a/drivers/scsi/isci/remote_device.c
+++ b/drivers/scsi/isci/remote_device.c
@@ -287,16 +287,13 @@ isci_remote_device_alloc(struct isci_host *ihost, struct isci_port *iport)
 void isci_remote_device_ready(struct isci_remote_device *idev)
 {
 	struct isci_host *ihost = idev->isci_port->isci_host;
-	unsigned long flags;
 
 	dev_dbg(&ihost->pdev->dev,
-		"%s: isci_device = %p\n", __func__, idev);
+		"%s: idev = %p\n", __func__, idev);
 
-	spin_lock_irqsave(&idev->isci_port->remote_device_lock, flags);
 	isci_remote_device_change_state(idev, isci_ready_for_io);
 	if (test_and_clear_bit(IDEV_START_PENDING, &idev->flags))
 		wake_up(&ihost->eventq);
-	spin_unlock_irqrestore(&idev->isci_port->remote_device_lock, flags);
 }
 
 /**
@@ -432,7 +429,6 @@ void isci_remote_device_gone(struct domain_device *dev)
  */
 int isci_remote_device_found(struct domain_device *domain_dev)
 {
-	unsigned long flags;
 	struct isci_host *isci_host;
 	struct isci_port *isci_port;
 	struct isci_phy *isci_phy;
@@ -474,12 +470,12 @@ int isci_remote_device_found(struct domain_device *domain_dev)
 	isci_remote_device_change_state(isci_device, isci_starting);
 
 
-	spin_lock_irqsave(&isci_port->remote_device_lock, flags);
+	spin_lock_irq(&isci_host->scic_lock);
 	list_add_tail(&isci_device->node, &isci_port->remote_dev_list);
 
 	set_bit(IDEV_START_PENDING, &isci_device->flags);
 	status = isci_remote_device_construct(isci_port, isci_device);
-	spin_unlock_irqrestore(&isci_port->remote_device_lock, flags);
+	spin_unlock_irq(&isci_host->scic_lock);
 
 	dev_dbg(&isci_host->pdev->dev,
 		"%s: isci_device = %p\n",
@@ -487,12 +483,12 @@ int isci_remote_device_found(struct domain_device *domain_dev)
 
 	if (status != SCI_SUCCESS) {
 
-		spin_lock_irqsave(&isci_port->remote_device_lock, flags);
+		spin_lock_irq(&isci_host->scic_lock);
 		isci_remote_device_deconstruct(
 			isci_host,
 			isci_device
 			);
-		spin_unlock_irqrestore(&isci_port->remote_device_lock, flags);
+		spin_unlock_irq(&isci_host->scic_lock);
 		return -ENODEV;
 	}
 

commit d9c37390c4f02153188a64a7a89fa6798dc3ffc2
Author: Dan Williams <dan.j.williams@intel.com>
Date:   Thu Mar 3 17:59:32 2011 -0800

    isci: preallocate remote devices
    
    Until we synchronize against device removal this limits the damage of
    use after free bugs to the driver's own objects.  Unless we implement
    reference counting we need to ensure at least a subset of a remote
    device is valid at all times.  We follow the lead of other libsas
    drivers that also preallocate devices.
    
    This also enforces maximum remote device accounting at the lldd layer,
    but the core may still run out of RNC's before we hit this limit.
    
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/drivers/scsi/isci/remote_device.c b/drivers/scsi/isci/remote_device.c
index db2259ce003f..48556e47bb9d 100644
--- a/drivers/scsi/isci/remote_device.c
+++ b/drivers/scsi/isci/remote_device.c
@@ -67,40 +67,35 @@
 
 /**
  * isci_remote_device_deconstruct() - This function frees an isci_remote_device.
- * @isci_host: This parameter specifies the isci host object.
- * @isci_device: This parameter specifies the remote device to be freed.
+ * @ihost: This parameter specifies the isci host object.
+ * @idev: This parameter specifies the remote device to be freed.
  *
  */
-static void isci_remote_device_deconstruct(
-	struct isci_host *isci_host,
-	struct isci_remote_device *isci_device)
+static void isci_remote_device_deconstruct(struct isci_host *ihost, struct isci_remote_device *idev)
 {
-	dev_dbg(&isci_host->pdev->dev,
-		"%s: isci_device = %p\n", __func__, isci_device);
+	dev_dbg(&ihost->pdev->dev,
+		"%s: isci_device = %p\n", __func__, idev);
 
 	/* There should not be any outstanding io's. All paths to
 	 * here should go through isci_remote_device_nuke_requests.
 	 * If we hit this condition, we will need a way to complete
 	 * io requests in process */
-	while (!list_empty(&isci_device->reqs_in_process)) {
+	while (!list_empty(&idev->reqs_in_process)) {
 
-		dev_err(&isci_host->pdev->dev,
+		dev_err(&ihost->pdev->dev,
 			"%s: ** request list not empty! **\n", __func__);
 		BUG();
 	}
 
-	/* Remove all related references to this device and free
-	 * the cache object.
-	 */
-	scic_remote_device_destruct(to_sci_dev(isci_device));
-	isci_device->domain_dev->lldd_dev = NULL;
-	list_del(&isci_device->node);
-
-	clear_bit(IDEV_STOP_PENDING, &isci_device->flags);
-	clear_bit(IDEV_START_PENDING, &isci_device->flags);
-	wake_up(&isci_host->eventq);
-	complete(isci_device->cmp);
-	kmem_cache_free(isci_kmem_cache, isci_device);
+	scic_remote_device_destruct(to_sci_dev(idev));
+	idev->domain_dev->lldd_dev = NULL;
+	idev->domain_dev = NULL;
+	idev->isci_port = NULL;
+	list_del_init(&idev->node);
+
+	clear_bit(IDEV_START_PENDING, &idev->flags);
+	clear_bit(IDEV_STOP_PENDING, &idev->flags);
+	wake_up(&ihost->eventq);
 }
 
 
@@ -259,25 +254,27 @@ void isci_remote_device_nuke_requests(
  * pointer to new isci_remote_device.
  */
 static struct isci_remote_device *
-isci_remote_device_alloc(struct isci_host *isci_host, struct isci_port *port)
+isci_remote_device_alloc(struct isci_host *ihost, struct isci_port *iport)
 {
-	struct isci_remote_device *isci_device;
+	struct isci_remote_device *idev;
+	int i;
 
-	isci_device = kmem_cache_zalloc(isci_kmem_cache, GFP_KERNEL);
+	for (i = 0; i < SCI_MAX_REMOTE_DEVICES; i++) {
+		idev = idev_by_id(ihost, i);
+		if (!test_and_set_bit(IDEV_ALLOCATED, &idev->flags))
+			break;
+	}
 
-	if (!isci_device) {
-		dev_warn(&isci_host->pdev->dev, "%s: failed\n", __func__);
+	if (i >= SCI_MAX_REMOTE_DEVICES) {
+		dev_warn(&ihost->pdev->dev, "%s: failed\n", __func__);
 		return NULL;
 	}
 
-	INIT_LIST_HEAD(&isci_device->reqs_in_process);
-	INIT_LIST_HEAD(&isci_device->node);
-
-	spin_lock_init(&isci_device->state_lock);
-	isci_remote_device_change_state(isci_device, isci_freed);
-
-	return isci_device;
+	BUG_ON(!list_empty(&idev->reqs_in_process));
+	BUG_ON(!list_empty(&idev->node));
+	isci_remote_device_change_state(idev, isci_freed);
 
+	return idev;
 }
 
 /**
@@ -381,24 +378,22 @@ enum sci_status isci_remote_device_stop(struct isci_host *ihost, struct isci_rem
 {
 	enum sci_status status;
 	unsigned long flags;
-	DECLARE_COMPLETION_ONSTACK(completion);
 
 	dev_dbg(&ihost->pdev->dev,
 		"%s: isci_device = %p\n", __func__, idev);
 
 	isci_remote_device_change_state(idev, isci_stopping);
 	set_bit(IDEV_STOP_PENDING, &idev->flags);
-	idev->cmp = &completion;
 
 	spin_lock_irqsave(&ihost->scic_lock, flags);
-
 	status = scic_remote_device_stop(to_sci_dev(idev), 50);
-
 	spin_unlock_irqrestore(&ihost->scic_lock, flags);
 
 	/* Wait for the stop complete callback. */
-	if (status == SCI_SUCCESS)
+	if (status == SCI_SUCCESS) {
 		wait_for_device_stop(ihost, idev);
+		clear_bit(IDEV_ALLOCATED, &idev->flags);
+	}
 
 	dev_dbg(&ihost->pdev->dev,
 		"%s: idev = %p - after completion wait\n",
@@ -469,6 +464,8 @@ int isci_remote_device_found(struct domain_device *domain_dev)
 		return -ENODEV;
 
 	isci_device = isci_remote_device_alloc(isci_host, isci_port);
+	if (!isci_device)
+		return -ENODEV;
 
 	INIT_LIST_HEAD(&isci_device->node);
 	domain_dev->lldd_dev = isci_device;

commit 6ad31fec306d532031b2f778f8656385df1b9d8f
Author: Dan Williams <dan.j.williams@intel.com>
Date:   Fri Mar 4 12:10:29 2011 -0800

    isci: replace isci_remote_device completion with event queue
    
    Replace the device completion infrastructure with the controller wide
    event queue.  There was a potential for the stop and ready notifications
    to corrupt each other, now that cannot happen.
    
    The stop pending flag cannot be used until devices are statically
    allocated.  We temporarily need to maintain a completion to handle
    waiting for an object that has disappeared, but we can at least stop
    scribbling on freed memory.
    
    A future change will also get rid of the "stopping" state as it should
    not be exposed to the rest of the driver.
    
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/drivers/scsi/isci/remote_device.c b/drivers/scsi/isci/remote_device.c
index fc1f24449170..db2259ce003f 100644
--- a/drivers/scsi/isci/remote_device.c
+++ b/drivers/scsi/isci/remote_device.c
@@ -95,6 +95,11 @@ static void isci_remote_device_deconstruct(
 	scic_remote_device_destruct(to_sci_dev(isci_device));
 	isci_device->domain_dev->lldd_dev = NULL;
 	list_del(&isci_device->node);
+
+	clear_bit(IDEV_STOP_PENDING, &isci_device->flags);
+	clear_bit(IDEV_START_PENDING, &isci_device->flags);
+	wake_up(&isci_host->eventq);
+	complete(isci_device->cmp);
 	kmem_cache_free(isci_kmem_cache, isci_device);
 }
 
@@ -279,30 +284,22 @@ isci_remote_device_alloc(struct isci_host *isci_host, struct isci_port *port)
  * isci_remote_device_ready() - This function is called by the scic when the
  *    remote device is ready. We mark the isci device as ready and signal the
  *    waiting proccess.
- * @isci_host: This parameter specifies the isci host object.
- * @isci_device: This parameter specifies the remote device
+ * @idev: This parameter specifies the remote device
  *
  */
-void isci_remote_device_ready(struct isci_remote_device *isci_device)
+void isci_remote_device_ready(struct isci_remote_device *idev)
 {
+	struct isci_host *ihost = idev->isci_port->isci_host;
 	unsigned long flags;
 
-	dev_dbg(&isci_device->isci_port->isci_host->pdev->dev,
-		"%s: isci_device = %p\n", __func__, isci_device);
-
-	/* device ready is actually a "ready for io" state. */
-	if (isci_device->status == isci_starting ||
-	    isci_device->status == isci_ready) {
-		spin_lock_irqsave(&isci_device->isci_port->remote_device_lock,
-				  flags);
-		isci_remote_device_change_state(isci_device, isci_ready_for_io);
-		if (isci_device->completion)
-			complete(isci_device->completion);
-		spin_unlock_irqrestore(
-				&isci_device->isci_port->remote_device_lock,
-				flags);
-	}
+	dev_dbg(&ihost->pdev->dev,
+		"%s: isci_device = %p\n", __func__, idev);
 
+	spin_lock_irqsave(&idev->isci_port->remote_device_lock, flags);
+	isci_remote_device_change_state(idev, isci_ready_for_io);
+	if (test_and_clear_bit(IDEV_START_PENDING, &idev->flags))
+		wake_up(&ihost->eventq);
+	spin_unlock_irqrestore(&idev->isci_port->remote_device_lock, flags);
 }
 
 /**
@@ -341,8 +338,6 @@ void isci_remote_device_stop_complete(
 	struct isci_remote_device *isci_device,
 	enum sci_status status)
 {
-	struct completion *completion = isci_device->completion;
-
 	dev_dbg(&isci_host->pdev->dev,
 		"%s: complete isci_device = %p, status = 0x%x\n",
 		__func__,
@@ -354,9 +349,6 @@ void isci_remote_device_stop_complete(
 	/* after stop, we can tear down resources. */
 	isci_remote_device_deconstruct(isci_host, isci_device);
 
-	/* notify interested parties. */
-	if (completion)
-		complete(completion);
 }
 
 /**
@@ -385,40 +377,33 @@ void isci_remote_device_start_complete(
  *
  * The status of the scic request to stop.
  */
-enum sci_status isci_remote_device_stop(
-	struct isci_remote_device *isci_device)
+enum sci_status isci_remote_device_stop(struct isci_host *ihost, struct isci_remote_device *idev)
 {
 	enum sci_status status;
 	unsigned long flags;
-
 	DECLARE_COMPLETION_ONSTACK(completion);
 
-	dev_dbg(&isci_device->isci_port->isci_host->pdev->dev,
-		"%s: isci_device = %p\n", __func__, isci_device);
-
-	isci_remote_device_change_state(isci_device, isci_stopping);
-
-	/* We need comfirmation that stop completed. */
-	isci_device->completion = &completion;
+	dev_dbg(&ihost->pdev->dev,
+		"%s: isci_device = %p\n", __func__, idev);
 
-	BUG_ON(isci_device->isci_port == NULL);
-	BUG_ON(isci_device->isci_port->isci_host == NULL);
+	isci_remote_device_change_state(idev, isci_stopping);
+	set_bit(IDEV_STOP_PENDING, &idev->flags);
+	idev->cmp = &completion;
 
-	spin_lock_irqsave(&isci_device->isci_port->isci_host->scic_lock, flags);
+	spin_lock_irqsave(&ihost->scic_lock, flags);
 
-	status = scic_remote_device_stop(to_sci_dev(isci_device), 50);
+	status = scic_remote_device_stop(to_sci_dev(idev), 50);
 
-	spin_unlock_irqrestore(&isci_device->isci_port->isci_host->scic_lock, flags);
+	spin_unlock_irqrestore(&ihost->scic_lock, flags);
 
 	/* Wait for the stop complete callback. */
 	if (status == SCI_SUCCESS)
-		wait_for_completion(&completion);
+		wait_for_device_stop(ihost, idev);
 
-	dev_dbg(&isci_device->isci_port->isci_host->pdev->dev,
-		"%s: isci_device = %p - after completion wait\n",
-		__func__, isci_device);
+	dev_dbg(&ihost->pdev->dev,
+		"%s: idev = %p - after completion wait\n",
+		__func__, idev);
 
-	isci_device->completion = NULL;
 	return status;
 }
 
@@ -428,18 +413,16 @@ enum sci_status isci_remote_device_stop(
  * @domain_device: This parameter specifies the libsas domain device.
  *
  */
-void isci_remote_device_gone(
-	struct domain_device *domain_dev)
+void isci_remote_device_gone(struct domain_device *dev)
 {
-	struct isci_remote_device *isci_device = isci_dev_from_domain_dev(
-		domain_dev);
+	struct isci_host *ihost = dev->port->ha->lldd_ha;
+	struct isci_remote_device *idev = dev->lldd_dev;
 
-	dev_dbg(&isci_device->isci_port->isci_host->pdev->dev,
+	dev_dbg(&ihost->pdev->dev,
 		"%s: domain_device = %p, isci_device = %p, isci_port = %p\n",
-		__func__, domain_dev, isci_device, isci_device->isci_port);
+		__func__, dev, idev, idev->isci_port);
 
-	if (isci_device != NULL)
-		isci_remote_device_stop(isci_device);
+	isci_remote_device_stop(ihost, idev);
 }
 
 
@@ -462,7 +445,6 @@ int isci_remote_device_found(struct domain_device *domain_dev)
 	struct asd_sas_phy *sas_phy;
 	struct isci_remote_device *isci_device;
 	enum sci_status status;
-	DECLARE_COMPLETION_ONSTACK(completion);
 
 	isci_host = isci_host_from_sas_ha(domain_dev->port->ha);
 
@@ -498,17 +480,10 @@ int isci_remote_device_found(struct domain_device *domain_dev)
 	spin_lock_irqsave(&isci_port->remote_device_lock, flags);
 	list_add_tail(&isci_device->node, &isci_port->remote_dev_list);
 
-	/* for the device ready event. */
-	isci_device->completion = &completion;
-
+	set_bit(IDEV_START_PENDING, &isci_device->flags);
 	status = isci_remote_device_construct(isci_port, isci_device);
-
 	spin_unlock_irqrestore(&isci_port->remote_device_lock, flags);
 
-	/* wait for the device ready callback. */
-	wait_for_completion(isci_device->completion);
-	isci_device->completion = NULL;
-
 	dev_dbg(&isci_host->pdev->dev,
 		"%s: isci_device = %p\n",
 		__func__, isci_device);
@@ -524,6 +499,9 @@ int isci_remote_device_found(struct domain_device *domain_dev)
 		return -ENODEV;
 	}
 
+	/* wait for the device ready callback. */
+	wait_for_device_start(isci_host, isci_device);
+
 	return 0;
 }
 /**

commit 8acaec1593526f922ff46812d99abf9aab5c8b43
Author: Dan Williams <dan.j.williams@intel.com>
Date:   Mon Mar 7 14:47:35 2011 -0800

    isci: kill "host quiesce" mechanism
    
    The midlayer is already throttling i/o in the places where host_quiesce
    was trying to prevent further i/o to the device.  It's also problematic
    in that it holds a lock over GFP_KERNEL allocations.
    
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/drivers/scsi/isci/remote_device.c b/drivers/scsi/isci/remote_device.c
index 0eb5c7330fac..fc1f24449170 100644
--- a/drivers/scsi/isci/remote_device.c
+++ b/drivers/scsi/isci/remote_device.c
@@ -267,36 +267,13 @@ isci_remote_device_alloc(struct isci_host *isci_host, struct isci_port *port)
 
 	INIT_LIST_HEAD(&isci_device->reqs_in_process);
 	INIT_LIST_HEAD(&isci_device->node);
-	isci_device->host_quiesce          = false;
 
 	spin_lock_init(&isci_device->state_lock);
-	spin_lock_init(&isci_device->host_quiesce_lock);
 	isci_remote_device_change_state(isci_device, isci_freed);
 
 	return isci_device;
 
 }
-/**
- * isci_device_set_host_quiesce_lock_state() - This function sets the host I/O
- *    quiesce lock state for the remote_device object.
- * @isci_device,: This parameter points to the isci_remote_device object
- * @isci_device: This parameter specifies the new quiesce state.
- *
- */
-void isci_device_set_host_quiesce_lock_state(
-	struct isci_remote_device *isci_device,
-	bool lock_state)
-{
-	unsigned long flags;
-
-	dev_dbg(&isci_device->isci_port->isci_host->pdev->dev,
-		"%s: isci_device=%p, lock_state=%d\n",
-		__func__, isci_device, lock_state);
-
-	spin_lock_irqsave(&isci_device->host_quiesce_lock, flags);
-	isci_device->host_quiesce = lock_state;
-	spin_unlock_irqrestore(&isci_device->host_quiesce_lock, flags);
-}
 
 /**
  * isci_remote_device_ready() - This function is called by the scic when the
@@ -314,8 +291,8 @@ void isci_remote_device_ready(struct isci_remote_device *isci_device)
 		"%s: isci_device = %p\n", __func__, isci_device);
 
 	/* device ready is actually a "ready for io" state. */
-	if ((isci_starting == isci_remote_device_get_state(isci_device)) ||
-	    (isci_ready == isci_remote_device_get_state(isci_device))) {
+	if (isci_device->status == isci_starting ||
+	    isci_device->status == isci_ready) {
 		spin_lock_irqsave(&isci_device->isci_port->remote_device_lock,
 				  flags);
 		isci_remote_device_change_state(isci_device, isci_ready_for_io);

commit 3a97eec6d7876c541950e23811efd40e0bcd04a0
Author: Dan Williams <dan.j.williams@intel.com>
Date:   Fri Mar 4 11:51:43 2011 -0800

    isci: remove sci_device_handle
    
    It belies the fact that isci_remote_device and scic_sds_remote_device
    are one in same object with the same lifetime rules.
    
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/drivers/scsi/isci/remote_device.c b/drivers/scsi/isci/remote_device.c
index e684a053189e..0eb5c7330fac 100644
--- a/drivers/scsi/isci/remote_device.c
+++ b/drivers/scsi/isci/remote_device.c
@@ -92,7 +92,7 @@ static void isci_remote_device_deconstruct(
 	/* Remove all related references to this device and free
 	 * the cache object.
 	 */
-	scic_remote_device_destruct(isci_device->sci_device_handle);
+	scic_remote_device_destruct(to_sci_dev(isci_device));
 	isci_device->domain_dev->lldd_dev = NULL;
 	list_del(&isci_device->node);
 	kmem_cache_free(isci_kmem_cache, isci_device);
@@ -117,7 +117,7 @@ static enum sci_status isci_remote_device_construct(
 
 	/* let the core do it's common constuction. */
 	scic_remote_device_construct(port->sci_port_handle,
-				     isci_device->sci_device_handle);
+				     to_sci_dev(isci_device));
 
 	/* let the core do it's device specific constuction. */
 	if (isci_device->domain_dev->parent &&
@@ -183,15 +183,11 @@ static enum sci_status isci_remote_device_construct(
 			"%s: parent->dev_type = EDGE_DEV\n",
 			__func__);
 
-		status = scic_remote_device_ea_construct(
-			isci_device->sci_device_handle,
-			(struct smp_response_discover *)&discover_response
-			);
+		status = scic_remote_device_ea_construct(to_sci_dev(isci_device),
+				(struct smp_response_discover *)&discover_response);
 
 	} else
-		status = scic_remote_device_da_construct(
-			isci_device->sci_device_handle
-			);
+		status = scic_remote_device_da_construct(to_sci_dev(isci_device));
 
 
 	if (status != SCI_SUCCESS) {
@@ -204,18 +200,13 @@ static enum sci_status isci_remote_device_construct(
 		return status;
 	}
 
-	sci_object_set_association(
-		isci_device->sci_device_handle,
-		isci_device
-		);
+	sci_object_set_association(to_sci_dev(isci_device), isci_device);
 
 	BUG_ON(port->isci_host == NULL);
 
 	/* start the device. */
-	status = scic_remote_device_start(
-		isci_device->sci_device_handle,
-		ISCI_REMOTE_DEVICE_START_TIMEOUT
-		);
+	status = scic_remote_device_start(to_sci_dev(isci_device),
+					  ISCI_REMOTE_DEVICE_START_TIMEOUT);
 
 	if (status != SCI_SUCCESS) {
 		dev_warn(&port->isci_host->pdev->dev,
@@ -266,7 +257,6 @@ static struct isci_remote_device *
 isci_remote_device_alloc(struct isci_host *isci_host, struct isci_port *port)
 {
 	struct isci_remote_device *isci_device;
-	struct scic_sds_remote_device *sci_dev;
 
 	isci_device = kmem_cache_zalloc(isci_kmem_cache, GFP_KERNEL);
 
@@ -275,8 +265,6 @@ isci_remote_device_alloc(struct isci_host *isci_host, struct isci_port *port)
 		return NULL;
 	}
 
-	sci_dev = (struct scic_sds_remote_device *) &isci_device[1];
-	isci_device->sci_device_handle = sci_dev;
 	INIT_LIST_HEAD(&isci_device->reqs_in_process);
 	INIT_LIST_HEAD(&isci_device->node);
 	isci_device->host_quiesce          = false;
@@ -441,10 +429,7 @@ enum sci_status isci_remote_device_stop(
 
 	spin_lock_irqsave(&isci_device->isci_port->isci_host->scic_lock, flags);
 
-	status = scic_remote_device_stop(
-		isci_device->sci_device_handle,
-		50
-		);
+	status = scic_remote_device_stop(to_sci_dev(isci_device), 50);
 
 	spin_unlock_irqrestore(&isci_device->isci_port->isci_host->scic_lock, flags);
 

commit d7628d052242d634dc1e2584c422e690578918a3
Author: Dave Jiang <dave.jiang@intel.com>
Date:   Wed Mar 2 13:10:45 2011 -0800

    isci: Cleanup warning messages for phy resets
    
    Moving some of the chattiness of warning messages to debug so only the Linux
    system messages are shown.
    
    Signed-off-by: Dave Jiang <dave.jiang@intel.com>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/drivers/scsi/isci/remote_device.c b/drivers/scsi/isci/remote_device.c
index dec9033d674d..e684a053189e 100644
--- a/drivers/scsi/isci/remote_device.c
+++ b/drivers/scsi/isci/remote_device.c
@@ -472,7 +472,7 @@ void isci_remote_device_gone(
 	struct isci_remote_device *isci_device = isci_dev_from_domain_dev(
 		domain_dev);
 
-	dev_err(&isci_device->isci_port->isci_host->pdev->dev,
+	dev_dbg(&isci_device->isci_port->isci_host->pdev->dev,
 		"%s: domain_device = %p, isci_device = %p, isci_port = %p\n",
 		__func__, domain_dev, isci_device, isci_device->isci_port);
 

commit 83f5eeef59581faed6f002432bafe24da8cbf401
Author: Dan Williams <dan.j.williams@intel.com>
Date:   Fri Feb 18 09:25:15 2011 -0800

    isci: debug fixes
    
    Some of the chain walks to get back to our dev are invalid.
    
    isci_remote_device_change_state: delete rather than adding conditional deref
    chain walking
    isci_request_change_state: fix, it was being called too early
    isci_request_ssp_io_request_get_lun: fix compile breakage hidden by ifdef DEBUG
    
    Signed-off-by: Maciej Trela <maciej.trela@intel.com>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/drivers/scsi/isci/remote_device.c b/drivers/scsi/isci/remote_device.c
index 936f22957e5b..dec9033d674d 100644
--- a/drivers/scsi/isci/remote_device.c
+++ b/drivers/scsi/isci/remote_device.c
@@ -686,12 +686,6 @@ void isci_remote_device_change_state(
 {
 	unsigned long flags;
 
-	dev_dbg(&isci_device->isci_port->isci_host->pdev->dev,
-		"%s: isci_device = %p, state = 0x%x",
-		__func__,
-		isci_device,
-		status);
-
 	spin_lock_irqsave(&isci_device->state_lock, flags);
 	isci_device->status = status;
 	spin_unlock_irqrestore(&isci_device->state_lock, flags);

commit 0cf89d1d27c1bdd0abf1714096f98ea44704dcff
Author: Dan Williams <dan.j.williams@intel.com>
Date:   Fri Feb 18 09:25:07 2011 -0800

    isci: cleanup "starting" state handling
    
    The lldd actively disallows requests in the "starting" state.  Retrying
    or holding off commands in this state is sub-optimal:
    1/ it adds another state check to the fast path
    2/ retrying can cause libsas to give up
    
    However, isci's ->lldd_dev_found() routine already waits for controller
    start to complete before allowing further progress.  Checking the
    "starting" state in isci_task_execute_task and the isr is redundant and
    misleading.  Clean this up and introduce a controller-wide event queue
    to start reeling in "completion" proliferation in the driver.
    
    The "stopping" state cleanups are in a similar vein, rely on the the isr
    and other paths being precluded from occurring rather than implementing
    state checking logic.
    
    Reported-by: Christoph Hellwig <hch@infradead.org>
    Cc: Jeff Garzik <jeff@garzik.org>
    Signed-off-by: Edmund Nadolski <edmund.nadolski@intel.com>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/drivers/scsi/isci/remote_device.c b/drivers/scsi/isci/remote_device.c
index dbf3c82f6195..936f22957e5b 100644
--- a/drivers/scsi/isci/remote_device.c
+++ b/drivers/scsi/isci/remote_device.c
@@ -507,6 +507,8 @@ int isci_remote_device_found(struct domain_device *domain_dev)
 	dev_dbg(&isci_host->pdev->dev,
 		"%s: domain_device = %p\n", __func__, domain_dev);
 
+	wait_for_start(isci_host);
+
 	sas_port = domain_dev->port;
 	sas_phy = list_first_entry(&sas_port->phy_list, struct asd_sas_phy,
 				   port_phy_el);
@@ -560,8 +562,6 @@ int isci_remote_device_found(struct domain_device *domain_dev)
 		return -ENODEV;
 	}
 
-	wait_for_completion(&isci_host->start_complete);
-
 	return 0;
 }
 /**

commit 6f231dda68080759f1aed3769896e94c73099f0f
Author: Dan Williams <dan.j.williams@intel.com>
Date:   Sat Jul 2 22:56:22 2011 -0700

    isci: Intel(R) C600 Series Chipset Storage Control Unit Driver
    
    Support for the up to 2x4-port 6Gb/s SAS controllers embedded in the
    chipset.
    
    This is a snapshot of the first publicly available version of the driver,
    commit 4c1db2d0 in the 'historical' branch.
    
       git://git.kernel.org/pub/scm/linux/kernel/git/djbw/isci.git historical
    
    Signed-off-by: Maciej Trela <maciej.trela@intel.com>
    Signed-off-by: Dave Jiang <dave.jiang@intel.com>
    Signed-off-by: Edmund Nadolski <edmund.nadolski@intel.com>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/drivers/scsi/isci/remote_device.c b/drivers/scsi/isci/remote_device.c
new file mode 100644
index 000000000000..dbf3c82f6195
--- /dev/null
+++ b/drivers/scsi/isci/remote_device.c
@@ -0,0 +1,698 @@
+/*
+ * This file is provided under a dual BSD/GPLv2 license.  When using or
+ * redistributing this file, you may do so under either license.
+ *
+ * GPL LICENSE SUMMARY
+ *
+ * Copyright(c) 2008 - 2011 Intel Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
+ * The full GNU General Public License is included in this distribution
+ * in the file called LICENSE.GPL.
+ *
+ * BSD LICENSE
+ *
+ * Copyright(c) 2008 - 2011 Intel Corporation. All rights reserved.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ *   * Redistributions of source code must retain the above copyright
+ *     notice, this list of conditions and the following disclaimer.
+ *   * Redistributions in binary form must reproduce the above copyright
+ *     notice, this list of conditions and the following disclaimer in
+ *     the documentation and/or other materials provided with the
+ *     distribution.
+ *   * Neither the name of Intel Corporation nor the names of its
+ *     contributors may be used to endorse or promote products derived
+ *     from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include "isci.h"
+#include "scic_io_request.h"
+#include "scic_remote_device.h"
+#include "scic_phy.h"
+#include "scic_port.h"
+#include "port.h"
+#include "remote_device.h"
+#include "request.h"
+#include "task.h"
+
+
+
+/**
+ * isci_remote_device_deconstruct() - This function frees an isci_remote_device.
+ * @isci_host: This parameter specifies the isci host object.
+ * @isci_device: This parameter specifies the remote device to be freed.
+ *
+ */
+static void isci_remote_device_deconstruct(
+	struct isci_host *isci_host,
+	struct isci_remote_device *isci_device)
+{
+	dev_dbg(&isci_host->pdev->dev,
+		"%s: isci_device = %p\n", __func__, isci_device);
+
+	/* There should not be any outstanding io's. All paths to
+	 * here should go through isci_remote_device_nuke_requests.
+	 * If we hit this condition, we will need a way to complete
+	 * io requests in process */
+	while (!list_empty(&isci_device->reqs_in_process)) {
+
+		dev_err(&isci_host->pdev->dev,
+			"%s: ** request list not empty! **\n", __func__);
+		BUG();
+	}
+
+	/* Remove all related references to this device and free
+	 * the cache object.
+	 */
+	scic_remote_device_destruct(isci_device->sci_device_handle);
+	isci_device->domain_dev->lldd_dev = NULL;
+	list_del(&isci_device->node);
+	kmem_cache_free(isci_kmem_cache, isci_device);
+}
+
+
+/**
+ * isci_remote_device_construct() - This function calls the scic remote device
+ *    construct and start functions, it waits on the remote device start
+ *    completion.
+ * @port: This parameter specifies the isci port with the remote device.
+ * @isci_device: This parameter specifies the isci remote device
+ *
+ * status from the scic calls, the caller to this function should clean up
+ * resources as appropriate.
+ */
+static enum sci_status isci_remote_device_construct(
+	struct isci_port *port,
+	struct isci_remote_device *isci_device)
+{
+	enum sci_status status = SCI_SUCCESS;
+
+	/* let the core do it's common constuction. */
+	scic_remote_device_construct(port->sci_port_handle,
+				     isci_device->sci_device_handle);
+
+	/* let the core do it's device specific constuction. */
+	if (isci_device->domain_dev->parent &&
+	    (isci_device->domain_dev->parent->dev_type == EDGE_DEV)) {
+		int i;
+
+		/* struct smp_response_discover discover_response; */
+		struct discover_resp discover_response;
+		struct domain_device *parent =
+			isci_device->domain_dev->parent;
+
+		struct expander_device *parent_ex = &parent->ex_dev;
+
+		for (i = 0; i < parent_ex->num_phys; i++) {
+
+			struct ex_phy *phy = &parent_ex->ex_phy[i];
+
+			if ((phy->phy_state == PHY_VACANT) ||
+			    (phy->phy_state == PHY_NOT_PRESENT))
+				continue;
+
+			if (SAS_ADDR(phy->attached_sas_addr)
+			    == SAS_ADDR(isci_device->domain_dev->sas_addr)) {
+
+				discover_response.attached_dev_type
+					= phy->attached_dev_type;
+				discover_response.linkrate
+					= phy->linkrate;
+				discover_response.attached_sata_host
+					= phy->attached_sata_host;
+				discover_response.attached_sata_dev
+					= phy->attached_sata_dev;
+				discover_response.attached_sata_ps
+					= phy->attached_sata_ps;
+				discover_response.iproto
+					= phy->attached_iproto >> 1;
+				discover_response.tproto
+					= phy->attached_tproto >> 1;
+				memcpy(
+					discover_response.attached_sas_addr,
+					phy->attached_sas_addr,
+					SAS_ADDR_SIZE
+					);
+				discover_response.attached_phy_id
+					= phy->attached_phy_id;
+				discover_response.change_count
+					= phy->phy_change_count;
+				discover_response.routing_attr
+					= phy->routing_attr;
+				discover_response.hmin_linkrate
+					= phy->phy->minimum_linkrate_hw;
+				discover_response.hmax_linkrate
+					= phy->phy->maximum_linkrate_hw;
+				discover_response.pmin_linkrate
+					= phy->phy->minimum_linkrate;
+				discover_response.pmax_linkrate
+					= phy->phy->maximum_linkrate;
+			}
+		}
+
+
+		dev_dbg(&port->isci_host->pdev->dev,
+			"%s: parent->dev_type = EDGE_DEV\n",
+			__func__);
+
+		status = scic_remote_device_ea_construct(
+			isci_device->sci_device_handle,
+			(struct smp_response_discover *)&discover_response
+			);
+
+	} else
+		status = scic_remote_device_da_construct(
+			isci_device->sci_device_handle
+			);
+
+
+	if (status != SCI_SUCCESS) {
+		dev_dbg(&port->isci_host->pdev->dev,
+			"%s: scic_remote_device_da_construct failed - "
+			"isci_device = %p\n",
+			__func__,
+			isci_device);
+
+		return status;
+	}
+
+	sci_object_set_association(
+		isci_device->sci_device_handle,
+		isci_device
+		);
+
+	BUG_ON(port->isci_host == NULL);
+
+	/* start the device. */
+	status = scic_remote_device_start(
+		isci_device->sci_device_handle,
+		ISCI_REMOTE_DEVICE_START_TIMEOUT
+		);
+
+	if (status != SCI_SUCCESS) {
+		dev_warn(&port->isci_host->pdev->dev,
+			 "%s: scic_remote_device_start failed\n",
+			 __func__);
+		return status;
+	}
+
+	return status;
+}
+
+
+/**
+ * isci_remote_device_nuke_requests() - This function terminates all requests
+ *    for a given remote device.
+ * @isci_device: This parameter specifies the remote device
+ *
+ */
+void isci_remote_device_nuke_requests(
+	struct isci_remote_device *isci_device)
+{
+	DECLARE_COMPLETION_ONSTACK(aborted_task_completion);
+	struct isci_host *isci_host;
+
+	isci_host = isci_device->isci_port->isci_host;
+
+	dev_dbg(&isci_host->pdev->dev,
+		"%s: isci_device = %p\n", __func__, isci_device);
+
+	/* Cleanup all requests pending for this device. */
+	isci_terminate_pending_requests(isci_host, isci_device, terminating);
+
+	dev_dbg(&isci_host->pdev->dev,
+		"%s: isci_device = %p, done\n", __func__, isci_device);
+}
+
+
+
+/**
+ * This function builds the isci_remote_device when a libsas dev_found message
+ *    is received.
+ * @isci_host: This parameter specifies the isci host object.
+ * @port: This parameter specifies the isci_port conected to this device.
+ *
+ * pointer to new isci_remote_device.
+ */
+static struct isci_remote_device *
+isci_remote_device_alloc(struct isci_host *isci_host, struct isci_port *port)
+{
+	struct isci_remote_device *isci_device;
+	struct scic_sds_remote_device *sci_dev;
+
+	isci_device = kmem_cache_zalloc(isci_kmem_cache, GFP_KERNEL);
+
+	if (!isci_device) {
+		dev_warn(&isci_host->pdev->dev, "%s: failed\n", __func__);
+		return NULL;
+	}
+
+	sci_dev = (struct scic_sds_remote_device *) &isci_device[1];
+	isci_device->sci_device_handle = sci_dev;
+	INIT_LIST_HEAD(&isci_device->reqs_in_process);
+	INIT_LIST_HEAD(&isci_device->node);
+	isci_device->host_quiesce          = false;
+
+	spin_lock_init(&isci_device->state_lock);
+	spin_lock_init(&isci_device->host_quiesce_lock);
+	isci_remote_device_change_state(isci_device, isci_freed);
+
+	return isci_device;
+
+}
+/**
+ * isci_device_set_host_quiesce_lock_state() - This function sets the host I/O
+ *    quiesce lock state for the remote_device object.
+ * @isci_device,: This parameter points to the isci_remote_device object
+ * @isci_device: This parameter specifies the new quiesce state.
+ *
+ */
+void isci_device_set_host_quiesce_lock_state(
+	struct isci_remote_device *isci_device,
+	bool lock_state)
+{
+	unsigned long flags;
+
+	dev_dbg(&isci_device->isci_port->isci_host->pdev->dev,
+		"%s: isci_device=%p, lock_state=%d\n",
+		__func__, isci_device, lock_state);
+
+	spin_lock_irqsave(&isci_device->host_quiesce_lock, flags);
+	isci_device->host_quiesce = lock_state;
+	spin_unlock_irqrestore(&isci_device->host_quiesce_lock, flags);
+}
+
+/**
+ * isci_remote_device_ready() - This function is called by the scic when the
+ *    remote device is ready. We mark the isci device as ready and signal the
+ *    waiting proccess.
+ * @isci_host: This parameter specifies the isci host object.
+ * @isci_device: This parameter specifies the remote device
+ *
+ */
+void isci_remote_device_ready(struct isci_remote_device *isci_device)
+{
+	unsigned long flags;
+
+	dev_dbg(&isci_device->isci_port->isci_host->pdev->dev,
+		"%s: isci_device = %p\n", __func__, isci_device);
+
+	/* device ready is actually a "ready for io" state. */
+	if ((isci_starting == isci_remote_device_get_state(isci_device)) ||
+	    (isci_ready == isci_remote_device_get_state(isci_device))) {
+		spin_lock_irqsave(&isci_device->isci_port->remote_device_lock,
+				  flags);
+		isci_remote_device_change_state(isci_device, isci_ready_for_io);
+		if (isci_device->completion)
+			complete(isci_device->completion);
+		spin_unlock_irqrestore(
+				&isci_device->isci_port->remote_device_lock,
+				flags);
+	}
+
+}
+
+/**
+ * isci_remote_device_not_ready() - This function is called by the scic when
+ *    the remote device is not ready. We mark the isci device as ready (not
+ *    "ready_for_io") and signal the waiting proccess.
+ * @isci_host: This parameter specifies the isci host object.
+ * @isci_device: This parameter specifies the remote device
+ *
+ */
+void isci_remote_device_not_ready(
+	struct isci_remote_device *isci_device,
+	u32 reason_code)
+{
+	dev_dbg(&isci_device->isci_port->isci_host->pdev->dev,
+		"%s: isci_device = %p\n", __func__, isci_device);
+
+	if (reason_code == SCIC_REMOTE_DEVICE_NOT_READY_STOP_REQUESTED)
+		isci_remote_device_change_state(isci_device, isci_stopping);
+	else
+		/* device ready is actually a "not ready for io" state. */
+		isci_remote_device_change_state(isci_device, isci_ready);
+}
+
+/**
+ * isci_remote_device_stop_complete() - This function is called by the scic
+ *    when the remote device stop has completed. We mark the isci device as not
+ *    ready and remove the isci remote device.
+ * @isci_host: This parameter specifies the isci host object.
+ * @isci_device: This parameter specifies the remote device.
+ * @status: This parameter specifies status of the completion.
+ *
+ */
+void isci_remote_device_stop_complete(
+	struct isci_host *isci_host,
+	struct isci_remote_device *isci_device,
+	enum sci_status status)
+{
+	struct completion *completion = isci_device->completion;
+
+	dev_dbg(&isci_host->pdev->dev,
+		"%s: complete isci_device = %p, status = 0x%x\n",
+		__func__,
+		isci_device,
+		status);
+
+	isci_remote_device_change_state(isci_device, isci_stopped);
+
+	/* after stop, we can tear down resources. */
+	isci_remote_device_deconstruct(isci_host, isci_device);
+
+	/* notify interested parties. */
+	if (completion)
+		complete(completion);
+}
+
+/**
+ * isci_remote_device_start_complete() - This function is called by the scic
+ *    when the remote device start has completed
+ * @isci_host: This parameter specifies the isci host object.
+ * @isci_device: This parameter specifies the remote device.
+ * @status: This parameter specifies status of the completion.
+ *
+ */
+void isci_remote_device_start_complete(
+	struct isci_host *isci_host,
+	struct isci_remote_device *isci_device,
+	enum sci_status status)
+{
+
+
+}
+
+
+/**
+ * isci_remote_device_stop() - This function is called internally to stop the
+ *    remote device.
+ * @isci_host: This parameter specifies the isci host object.
+ * @isci_device: This parameter specifies the remote device.
+ *
+ * The status of the scic request to stop.
+ */
+enum sci_status isci_remote_device_stop(
+	struct isci_remote_device *isci_device)
+{
+	enum sci_status status;
+	unsigned long flags;
+
+	DECLARE_COMPLETION_ONSTACK(completion);
+
+	dev_dbg(&isci_device->isci_port->isci_host->pdev->dev,
+		"%s: isci_device = %p\n", __func__, isci_device);
+
+	isci_remote_device_change_state(isci_device, isci_stopping);
+
+	/* We need comfirmation that stop completed. */
+	isci_device->completion = &completion;
+
+	BUG_ON(isci_device->isci_port == NULL);
+	BUG_ON(isci_device->isci_port->isci_host == NULL);
+
+	spin_lock_irqsave(&isci_device->isci_port->isci_host->scic_lock, flags);
+
+	status = scic_remote_device_stop(
+		isci_device->sci_device_handle,
+		50
+		);
+
+	spin_unlock_irqrestore(&isci_device->isci_port->isci_host->scic_lock, flags);
+
+	/* Wait for the stop complete callback. */
+	if (status == SCI_SUCCESS)
+		wait_for_completion(&completion);
+
+	dev_dbg(&isci_device->isci_port->isci_host->pdev->dev,
+		"%s: isci_device = %p - after completion wait\n",
+		__func__, isci_device);
+
+	isci_device->completion = NULL;
+	return status;
+}
+
+/**
+ * isci_remote_device_gone() - This function is called by libsas when a domain
+ *    device is removed.
+ * @domain_device: This parameter specifies the libsas domain device.
+ *
+ */
+void isci_remote_device_gone(
+	struct domain_device *domain_dev)
+{
+	struct isci_remote_device *isci_device = isci_dev_from_domain_dev(
+		domain_dev);
+
+	dev_err(&isci_device->isci_port->isci_host->pdev->dev,
+		"%s: domain_device = %p, isci_device = %p, isci_port = %p\n",
+		__func__, domain_dev, isci_device, isci_device->isci_port);
+
+	if (isci_device != NULL)
+		isci_remote_device_stop(isci_device);
+}
+
+
+/**
+ * isci_remote_device_found() - This function is called by libsas when a remote
+ *    device is discovered. A remote device object is created and started. the
+ *    function then sleeps until the sci core device started message is
+ *    received.
+ * @domain_device: This parameter specifies the libsas domain device.
+ *
+ * status, zero indicates success.
+ */
+int isci_remote_device_found(struct domain_device *domain_dev)
+{
+	unsigned long flags;
+	struct isci_host *isci_host;
+	struct isci_port *isci_port;
+	struct isci_phy *isci_phy;
+	struct asd_sas_port *sas_port;
+	struct asd_sas_phy *sas_phy;
+	struct isci_remote_device *isci_device;
+	enum sci_status status;
+	DECLARE_COMPLETION_ONSTACK(completion);
+
+	isci_host = isci_host_from_sas_ha(domain_dev->port->ha);
+
+	dev_dbg(&isci_host->pdev->dev,
+		"%s: domain_device = %p\n", __func__, domain_dev);
+
+	sas_port = domain_dev->port;
+	sas_phy = list_first_entry(&sas_port->phy_list, struct asd_sas_phy,
+				   port_phy_el);
+	isci_phy = to_isci_phy(sas_phy);
+	isci_port = isci_phy->isci_port;
+
+	/* we are being called for a device on this port,
+	 * so it has to come up eventually
+	 */
+	wait_for_completion(&isci_port->start_complete);
+
+	if ((isci_stopping == isci_port_get_state(isci_port)) ||
+	    (isci_stopped == isci_port_get_state(isci_port)))
+		return -ENODEV;
+
+	isci_device = isci_remote_device_alloc(isci_host, isci_port);
+
+	INIT_LIST_HEAD(&isci_device->node);
+	domain_dev->lldd_dev = isci_device;
+	isci_device->domain_dev = domain_dev;
+	isci_device->isci_port = isci_port;
+	isci_remote_device_change_state(isci_device, isci_starting);
+
+
+	spin_lock_irqsave(&isci_port->remote_device_lock, flags);
+	list_add_tail(&isci_device->node, &isci_port->remote_dev_list);
+
+	/* for the device ready event. */
+	isci_device->completion = &completion;
+
+	status = isci_remote_device_construct(isci_port, isci_device);
+
+	spin_unlock_irqrestore(&isci_port->remote_device_lock, flags);
+
+	/* wait for the device ready callback. */
+	wait_for_completion(isci_device->completion);
+	isci_device->completion = NULL;
+
+	dev_dbg(&isci_host->pdev->dev,
+		"%s: isci_device = %p\n",
+		__func__, isci_device);
+
+	if (status != SCI_SUCCESS) {
+
+		spin_lock_irqsave(&isci_port->remote_device_lock, flags);
+		isci_remote_device_deconstruct(
+			isci_host,
+			isci_device
+			);
+		spin_unlock_irqrestore(&isci_port->remote_device_lock, flags);
+		return -ENODEV;
+	}
+
+	wait_for_completion(&isci_host->start_complete);
+
+	return 0;
+}
+/**
+ * isci_device_is_reset_pending() - This function will check if there is any
+ *    pending reset condition on the device.
+ * @request: This parameter is the isci_device object.
+ *
+ * true if there is a reset pending for the device.
+ */
+bool isci_device_is_reset_pending(
+	struct isci_host *isci_host,
+	struct isci_remote_device *isci_device)
+{
+	struct isci_request *isci_request;
+	struct isci_request *tmp_req;
+	bool reset_is_pending = false;
+	unsigned long flags;
+
+	dev_dbg(&isci_host->pdev->dev,
+		"%s: isci_device = %p\n", __func__, isci_device);
+
+	spin_lock_irqsave(&isci_host->scic_lock, flags);
+
+	/* Check for reset on all pending requests. */
+	list_for_each_entry_safe(isci_request, tmp_req,
+				 &isci_device->reqs_in_process, dev_node) {
+		dev_dbg(&isci_host->pdev->dev,
+			"%s: isci_device = %p request = %p\n",
+			__func__, isci_device, isci_request);
+
+		if (isci_request->ttype == io_task) {
+
+			unsigned long flags;
+			struct sas_task *task = isci_request_access_task(
+				isci_request);
+
+			spin_lock_irqsave(&task->task_state_lock, flags);
+			if (task->task_state_flags & SAS_TASK_NEED_DEV_RESET)
+				reset_is_pending = true;
+			spin_unlock_irqrestore(&task->task_state_lock, flags);
+		}
+	}
+
+	spin_unlock_irqrestore(&isci_host->scic_lock, flags);
+
+	dev_dbg(&isci_host->pdev->dev,
+		"%s: isci_device = %p reset_is_pending = %d\n",
+		__func__, isci_device, reset_is_pending);
+
+	return reset_is_pending;
+}
+
+/**
+ * isci_device_clear_reset_pending() - This function will clear if any pending
+ *    reset condition flags on the device.
+ * @request: This parameter is the isci_device object.
+ *
+ * true if there is a reset pending for the device.
+ */
+void isci_device_clear_reset_pending(struct isci_remote_device *isci_device)
+{
+	struct isci_request *isci_request;
+	struct isci_request *tmp_req;
+	struct isci_host *isci_host = NULL;
+	unsigned long flags = 0;
+
+	/* FIXME more port gone confusion, and this time it makes the
+	 * locking "fun"
+	 */
+	if (isci_device->isci_port != NULL)
+		isci_host = isci_device->isci_port->isci_host;
+
+	/*
+	 * FIXME when the isci_host gets sorted out
+	 * use dev_dbg()
+	 */
+	pr_debug("%s: isci_device=%p, isci_host=%p\n",
+		 __func__, isci_device, isci_host);
+
+	if (isci_host != NULL)
+		spin_lock_irqsave(&isci_host->scic_lock, flags);
+	else
+		pr_err("%s: isci_device %p; isci_host == NULL!\n",
+		       __func__, isci_device);
+
+	/* Clear reset pending on all pending requests. */
+	list_for_each_entry_safe(isci_request, tmp_req,
+				 &isci_device->reqs_in_process, dev_node) {
+		/*
+		 * FIXME when the conditional spinlock is gone
+		 * change to dev_dbg()
+		 */
+		pr_debug("%s: isci_device = %p request = %p\n",
+			 __func__, isci_device, isci_request);
+
+		if (isci_request->ttype == io_task) {
+
+			unsigned long flags2;
+			struct sas_task *task = isci_request_access_task(
+				isci_request);
+
+			spin_lock_irqsave(&task->task_state_lock, flags2);
+			task->task_state_flags &= ~SAS_TASK_NEED_DEV_RESET;
+			spin_unlock_irqrestore(&task->task_state_lock, flags2);
+		}
+	}
+
+	if (isci_host != NULL)
+		spin_unlock_irqrestore(&isci_host->scic_lock, flags);
+}
+
+/**
+ * isci_remote_device_change_state() - This function gets the status of the
+ *    remote_device object.
+ * @isci_device: This parameter points to the isci_remote_device object
+ *
+ * status of the object as a isci_status enum.
+ */
+void isci_remote_device_change_state(
+	struct isci_remote_device *isci_device,
+	enum isci_status status)
+{
+	unsigned long flags;
+
+	dev_dbg(&isci_device->isci_port->isci_host->pdev->dev,
+		"%s: isci_device = %p, state = 0x%x",
+		__func__,
+		isci_device,
+		status);
+
+	spin_lock_irqsave(&isci_device->state_lock, flags);
+	isci_device->status = status;
+	spin_unlock_irqrestore(&isci_device->state_lock, flags);
+}
