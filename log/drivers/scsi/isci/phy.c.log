commit 1aba50b880e1834a6f2f1cb0df23ccce3e84b8a8
Author: Gustavo A. R. Silva <gustavo@embeddedor.com>
Date:   Tue Nov 27 22:29:55 2018 -0600

    scsi: isci: phy: Mark expected switch fall-through
    
    In preparation to enabling -Wimplicit-fallthrough, mark switch cases where
    we are expecting to fall through.
    
    Addresses-Coverity-ID: 703127 ("Missing break in switch")
    Signed-off-by: Gustavo A. R. Silva <gustavo@embeddedor.com>
    Acked-by: Artur Paszkiewicz <artur.paszkiewicz@intel.com>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/isci/phy.c b/drivers/scsi/isci/phy.c
index 1deca8c5a94f..7f9b3f20e5e4 100644
--- a/drivers/scsi/isci/phy.c
+++ b/drivers/scsi/isci/phy.c
@@ -778,6 +778,7 @@ enum sci_status sci_phy_event_handler(struct isci_phy *iphy, u32 event_code)
 			break;
 		case SCU_EVENT_LINK_FAILURE:
 			scu_link_layer_set_txcomsas_timeout(iphy, SCU_SAS_LINK_LAYER_TXCOMSAS_NEGTIME_DEFAULT);
+			/* fall through */
 		case SCU_EVENT_HARD_RESET_RECEIVED:
 			/* Start the oob/sn state machine over again */
 			sci_change_state(&iphy->sm, SCI_PHY_STARTING);

commit b0a2dc66152aa409860e02804169b0007244ebd7
Author: Kees Cook <keescook@chromium.org>
Date:   Fri Sep 1 23:21:24 2017 -0700

    scsi: isci: Convert timers to use timer_setup()
    
    In preparation for unconditionally passing the struct timer_list pointer to
    all timer callbacks, switch to using the new timer_setup() and from_timer()
    to pass the timer pointer explicitly.
    
    Cc: Intel SCU Linux support <intel-linux-scu@intel.com>
    Cc: Artur Paszkiewicz <artur.paszkiewicz@intel.com>
    Cc: "James E.J. Bottomley" <jejb@linux.vnet.ibm.com>
    Cc: "Martin K. Petersen" <martin.petersen@oracle.com>
    Cc: linux-scsi@vger.kernel.org
    Signed-off-by: Kees Cook <keescook@chromium.org>
    Reviewed-by: Artur Paszkiewicz <artur.paszkiewicz@intel.com>

diff --git a/drivers/scsi/isci/phy.c b/drivers/scsi/isci/phy.c
index cb87b2ef7c92..1deca8c5a94f 100644
--- a/drivers/scsi/isci/phy.c
+++ b/drivers/scsi/isci/phy.c
@@ -315,9 +315,9 @@ sci_phy_link_layer_initialization(struct isci_phy *iphy,
 	return SCI_SUCCESS;
 }
 
-static void phy_sata_timeout(unsigned long data)
+static void phy_sata_timeout(struct timer_list *t)
 {
-	struct sci_timer *tmr = (struct sci_timer *)data;
+	struct sci_timer *tmr = from_timer(tmr, t, timer);
 	struct isci_phy *iphy = container_of(tmr, typeof(*iphy), sata_timer);
 	struct isci_host *ihost = iphy->owning_port->owning_controller;
 	unsigned long flags;

commit 6734092e66011def7875bd67beef889d0fee1cc9
Author: Dan Carpenter <dan.carpenter@oracle.com>
Date:   Wed Jun 27 12:05:21 2012 +0300

    isci: add a couple __iomem annotations
    
    These are __iomem.  Sparse complains if we don't have that.
    
    drivers/scsi/isci/phy.c +149 70: warning:
            incorrect type in initializer (different address spaces)
    
    Signed-off-by: Dan Carpenter <dan.carpenter@oracle.com>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/drivers/scsi/isci/phy.c b/drivers/scsi/isci/phy.c
index ebb8f530f708..cb87b2ef7c92 100644
--- a/drivers/scsi/isci/phy.c
+++ b/drivers/scsi/isci/phy.c
@@ -169,7 +169,7 @@ sci_phy_link_layer_initialization(struct isci_phy *iphy,
 	phy_cap.gen1_no_ssc = 1;
 	if (ihost->oem_parameters.controller.do_enable_ssc) {
 		struct scu_afe_registers __iomem *afe = &ihost->scu_registers->afe;
-		struct scu_afe_transceiver *xcvr = &afe->scu_afe_xcvr[phy_idx];
+		struct scu_afe_transceiver __iomem *xcvr = &afe->scu_afe_xcvr[phy_idx];
 		struct isci_pci_info *pci_info = to_pci_info(ihost->pdev);
 		bool en_sas = false;
 		bool en_sata = false;

commit a90037560588e51b3e98b49537799137cbfda17d
Author: Dave Maurer <david.c.maurer@intel.com>
Date:   Fri Jun 22 06:45:33 2012 +0000

    isci: fix COMSAS negation timout workaround for WD SAS drives
    
    The following patch is a fix for the WD workaround
    COMSAS negation timeout change. This patch disables the
    OOB SM when the OOB is placed in reset, which allows
    the updated COMSAS negation timeout value to take
    effect.
    
    Cc: Dan Thompson <daniel.j.thompson@intel.com>
    Reported-by: Dan Thompson <daniel.j.thompson@intel.com>
    Signed-off-by: Dave Maurer <david.c.maurer@intel.com>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/drivers/scsi/isci/phy.c b/drivers/scsi/isci/phy.c
index 18f43d4c30ba..ebb8f530f708 100644
--- a/drivers/scsi/isci/phy.c
+++ b/drivers/scsi/isci/phy.c
@@ -1205,6 +1205,7 @@ static void scu_link_layer_start_oob(struct isci_phy *iphy)
 	/** Reset OOB sequence - start */
 	val = readl(&ll->phy_configuration);
 	val &= ~(SCU_SAS_PCFG_GEN_BIT(OOB_RESET) |
+		 SCU_SAS_PCFG_GEN_BIT(OOB_ENABLE) |
 		 SCU_SAS_PCFG_GEN_BIT(HARD_RESET));
 	writel(val, &ll->phy_configuration);
 	readl(&ll->phy_configuration); /* flush */
@@ -1236,6 +1237,7 @@ static void scu_link_layer_tx_hard_reset(
 	 * to the starting state. */
 	phy_configuration_value =
 		readl(&iphy->link_layer_registers->phy_configuration);
+	phy_configuration_value &= ~(SCU_SAS_PCFG_GEN_BIT(OOB_ENABLE));
 	phy_configuration_value |=
 		(SCU_SAS_PCFG_GEN_BIT(HARD_RESET) |
 		 SCU_SAS_PCFG_GEN_BIT(OOB_RESET));

commit c5457a82a404db3c447df22e6425c5c140c4bee1
Author: Jeff Skirvin <jeffrey.d.skirvin@intel.com>
Date:   Thu Mar 8 22:42:07 2012 -0800

    isci: Change the phy control and link reset interface for HW reasons.
    
    There is an apparent HW lockup caused when the PE is disabled while there
    is an outstanding TC in progress.  This change puts the link into OOB to
    force the TC to end before the PE is disabled.
    
    Signed-off-by: Jeff Skirvin <jeffrey.d.skirvin@intel.com>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/drivers/scsi/isci/phy.c b/drivers/scsi/isci/phy.c
index 85b26ac9074c..18f43d4c30ba 100644
--- a/drivers/scsi/isci/phy.c
+++ b/drivers/scsi/isci/phy.c
@@ -1442,12 +1442,14 @@ int isci_phy_control(struct asd_sas_phy *sas_phy,
 	switch (func) {
 	case PHY_FUNC_DISABLE:
 		spin_lock_irqsave(&ihost->scic_lock, flags);
+		scu_link_layer_start_oob(iphy);
 		sci_phy_stop(iphy);
 		spin_unlock_irqrestore(&ihost->scic_lock, flags);
 		break;
 
 	case PHY_FUNC_LINK_RESET:
 		spin_lock_irqsave(&ihost->scic_lock, flags);
+		scu_link_layer_start_oob(iphy);
 		sci_phy_stop(iphy);
 		sci_phy_start(iphy);
 		spin_unlock_irqrestore(&ihost->scic_lock, flags);

commit 6119908f0fe3737bba2f64eff70599c3e41d522e
Author: Andrzej Jakowski <andrzej.jakowski@intel.com>
Date:   Thu Mar 8 19:38:50 2012 +0000

    isci: Changes in COMSAS timings enabling ISCI to detect buggy disc drives.
    
    This patch extends timings in COMSAS signaling, so ISCI can detect disc
    drives having issues to send COMSAS in correct time frame.
    
    Signed-off-by: Andrzej Jakowski <andrzej.jakowski@intel.com>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/drivers/scsi/isci/phy.c b/drivers/scsi/isci/phy.c
index 474330fdbe1c..85b26ac9074c 100644
--- a/drivers/scsi/isci/phy.c
+++ b/drivers/scsi/isci/phy.c
@@ -668,6 +668,19 @@ static const char *phy_event_name(u32 event_code)
 		phy_to_host(iphy)->id, iphy->phy_index, \
 		phy_state_name(state), phy_event_name(code), code)
 
+
+void scu_link_layer_set_txcomsas_timeout(struct isci_phy *iphy, u32 timeout)
+{
+	u32 val;
+
+	/* Extend timeout */
+	val = readl(&iphy->link_layer_registers->transmit_comsas_signal);
+	val &= ~SCU_SAS_LLTXCOMSAS_GEN_VAL(NEGTIME, SCU_SAS_LINK_LAYER_TXCOMSAS_NEGTIME_MASK);
+	val |= SCU_SAS_LLTXCOMSAS_GEN_VAL(NEGTIME, timeout);
+
+	writel(val, &iphy->link_layer_registers->transmit_comsas_signal);
+}
+
 enum sci_status sci_phy_event_handler(struct isci_phy *iphy, u32 event_code)
 {
 	enum sci_phy_states state = iphy->sm.current_state_id;
@@ -683,6 +696,13 @@ enum sci_status sci_phy_event_handler(struct isci_phy *iphy, u32 event_code)
 			sci_phy_start_sata_link_training(iphy);
 			iphy->is_in_link_training = true;
 			break;
+		case SCU_EVENT_RECEIVED_IDENTIFY_TIMEOUT:
+		       /* Extend timeout value */
+		       scu_link_layer_set_txcomsas_timeout(iphy, SCU_SAS_LINK_LAYER_TXCOMSAS_NEGTIME_EXTENDED);
+
+		       /* Start the oob/sn state machine over again */
+		       sci_change_state(&iphy->sm, SCI_PHY_STARTING);
+		       break;
 		default:
 			phy_event_dbg(iphy, state, event_code);
 			return SCI_FAILURE;
@@ -717,9 +737,19 @@ enum sci_status sci_phy_event_handler(struct isci_phy *iphy, u32 event_code)
 			sci_phy_start_sata_link_training(iphy);
 			break;
 		case SCU_EVENT_LINK_FAILURE:
+			/* Change the timeout value to default */
+			scu_link_layer_set_txcomsas_timeout(iphy, SCU_SAS_LINK_LAYER_TXCOMSAS_NEGTIME_DEFAULT);
+
 			/* Link failure change state back to the starting state */
 			sci_change_state(&iphy->sm, SCI_PHY_STARTING);
 			break;
+		case SCU_EVENT_RECEIVED_IDENTIFY_TIMEOUT:
+		       /* Extend the timeout value */
+		       scu_link_layer_set_txcomsas_timeout(iphy, SCU_SAS_LINK_LAYER_TXCOMSAS_NEGTIME_EXTENDED);
+
+		       /* Start the oob/sn state machine over again */
+		       sci_change_state(&iphy->sm, SCI_PHY_STARTING);
+		       break;
 		default:
 			phy_event_warn(iphy, state, event_code);
 			return SCI_FAILURE;
@@ -740,7 +770,14 @@ enum sci_status sci_phy_event_handler(struct isci_phy *iphy, u32 event_code)
 			sci_phy_start_sata_link_training(iphy);
 			break;
 		case SCU_EVENT_RECEIVED_IDENTIFY_TIMEOUT:
+			/* Extend the timeout value */
+			scu_link_layer_set_txcomsas_timeout(iphy, SCU_SAS_LINK_LAYER_TXCOMSAS_NEGTIME_EXTENDED);
+
+			/* Start the oob/sn state machine over again */
+			sci_change_state(&iphy->sm, SCI_PHY_STARTING);
+			break;
 		case SCU_EVENT_LINK_FAILURE:
+			scu_link_layer_set_txcomsas_timeout(iphy, SCU_SAS_LINK_LAYER_TXCOMSAS_NEGTIME_DEFAULT);
 		case SCU_EVENT_HARD_RESET_RECEIVED:
 			/* Start the oob/sn state machine over again */
 			sci_change_state(&iphy->sm, SCI_PHY_STARTING);
@@ -753,6 +790,9 @@ enum sci_status sci_phy_event_handler(struct isci_phy *iphy, u32 event_code)
 	case SCI_PHY_SUB_AWAIT_SAS_POWER:
 		switch (scu_get_event_code(event_code)) {
 		case SCU_EVENT_LINK_FAILURE:
+			/* Change the timeout value to default */
+			scu_link_layer_set_txcomsas_timeout(iphy, SCU_SAS_LINK_LAYER_TXCOMSAS_NEGTIME_DEFAULT);
+
 			/* Link failure change state back to the starting state */
 			sci_change_state(&iphy->sm, SCI_PHY_STARTING);
 			break;
@@ -764,6 +804,9 @@ enum sci_status sci_phy_event_handler(struct isci_phy *iphy, u32 event_code)
 	case SCI_PHY_SUB_AWAIT_SATA_POWER:
 		switch (scu_get_event_code(event_code)) {
 		case SCU_EVENT_LINK_FAILURE:
+			/* Change the timeout value to default */
+			scu_link_layer_set_txcomsas_timeout(iphy, SCU_SAS_LINK_LAYER_TXCOMSAS_NEGTIME_DEFAULT);
+
 			/* Link failure change state back to the starting state */
 			sci_change_state(&iphy->sm, SCI_PHY_STARTING);
 			break;
@@ -788,6 +831,9 @@ enum sci_status sci_phy_event_handler(struct isci_phy *iphy, u32 event_code)
 	case SCI_PHY_SUB_AWAIT_SATA_PHY_EN:
 		switch (scu_get_event_code(event_code)) {
 		case SCU_EVENT_LINK_FAILURE:
+			/* Change the timeout value to default */
+			scu_link_layer_set_txcomsas_timeout(iphy, SCU_SAS_LINK_LAYER_TXCOMSAS_NEGTIME_DEFAULT);
+
 			/* Link failure change state back to the starting state */
 			sci_change_state(&iphy->sm, SCI_PHY_STARTING);
 			break;
@@ -836,6 +882,9 @@ enum sci_status sci_phy_event_handler(struct isci_phy *iphy, u32 event_code)
 						       SCI_PHY_SUB_AWAIT_SIG_FIS_UF);
 			break;
 		case SCU_EVENT_LINK_FAILURE:
+			/* Change the timeout value to default */
+			scu_link_layer_set_txcomsas_timeout(iphy, SCU_SAS_LINK_LAYER_TXCOMSAS_NEGTIME_DEFAULT);
+
 			/* Link failure change state back to the starting state */
 			sci_change_state(&iphy->sm, SCI_PHY_STARTING);
 			break;
@@ -859,6 +908,9 @@ enum sci_status sci_phy_event_handler(struct isci_phy *iphy, u32 event_code)
 			break;
 
 		case SCU_EVENT_LINK_FAILURE:
+			/* Change the timeout value to default */
+			scu_link_layer_set_txcomsas_timeout(iphy, SCU_SAS_LINK_LAYER_TXCOMSAS_NEGTIME_DEFAULT);
+
 			/* Link failure change state back to the starting state */
 			sci_change_state(&iphy->sm, SCI_PHY_STARTING);
 			break;
@@ -871,6 +923,9 @@ enum sci_status sci_phy_event_handler(struct isci_phy *iphy, u32 event_code)
 	case SCI_PHY_READY:
 		switch (scu_get_event_code(event_code)) {
 		case SCU_EVENT_LINK_FAILURE:
+			/* Set default timeout */
+			scu_link_layer_set_txcomsas_timeout(iphy, SCU_SAS_LINK_LAYER_TXCOMSAS_NEGTIME_DEFAULT);
+
 			/* Link failure change state back to the starting state */
 			sci_change_state(&iphy->sm, SCI_PHY_STARTING);
 			break;

commit 944b787d0a469a376f4d6699eb01138823197513
Author: Tom Jackson <thomas.p.jackson@intel.com>
Date:   Fri Feb 24 09:38:49 2012 +0000

    isci: Don't filter BROADCAST CHANGE primitives
    
    Per the SAS spec, several types of BROADCAST CHANGE primitives
    must cause re-discovery of the originating expander.
    Only the standard BROADCAST CHANGE primitive was being
    sent to the LIBSAS layer.  The other BC primitives have been
    added to the sci_phy_event_handler()
    
    Signed-off-by: Tom Jackson <thomas.p.jackson@intel.com>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/drivers/scsi/isci/phy.c b/drivers/scsi/isci/phy.c
index c685ab04532f..474330fdbe1c 100644
--- a/drivers/scsi/isci/phy.c
+++ b/drivers/scsi/isci/phy.c
@@ -875,12 +875,19 @@ enum sci_status sci_phy_event_handler(struct isci_phy *iphy, u32 event_code)
 			sci_change_state(&iphy->sm, SCI_PHY_STARTING);
 			break;
 		case SCU_EVENT_BROADCAST_CHANGE:
+		case SCU_EVENT_BROADCAST_SES:
+		case SCU_EVENT_BROADCAST_RESERVED0:
+		case SCU_EVENT_BROADCAST_RESERVED1:
+		case SCU_EVENT_BROADCAST_EXPANDER:
+		case SCU_EVENT_BROADCAST_AEN:
 			/* Broadcast change received. Notify the port. */
 			if (phy_get_non_dummy_port(iphy) != NULL)
 				sci_port_broadcast_change_received(iphy->owning_port, iphy);
 			else
 				iphy->bcn_received_while_port_unassigned = true;
 			break;
+		case SCU_EVENT_BROADCAST_RESERVED3:
+		case SCU_EVENT_BROADCAST_RESERVED4:
 		default:
 			phy_event_warn(iphy, state, event_code);
 			return SCI_FAILURE_INVALID_STATE;

commit c79dd80d73017a88a2c2ae46e7d5303cba6a32e0
Author: Dan Williams <dan.j.williams@intel.com>
Date:   Wed Feb 1 00:44:14 2012 -0800

    isci: kill sci_phy_protocol and sci_request_protocol
    
    Holdovers from the initial driver cleanup, replace with enum sas_protocol.
    
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/drivers/scsi/isci/phy.c b/drivers/scsi/isci/phy.c
index fab3586840b5..c685ab04532f 100644
--- a/drivers/scsi/isci/phy.c
+++ b/drivers/scsi/isci/phy.c
@@ -580,7 +580,7 @@ static void sci_phy_start_sas_link_training(struct isci_phy *iphy)
 
 	sci_change_state(&iphy->sm, SCI_PHY_SUB_AWAIT_SAS_SPEED_EN);
 
-	iphy->protocol = SCIC_SDS_PHY_PROTOCOL_SAS;
+	iphy->protocol = SAS_PROTOCOL_SSP;
 }
 
 static void sci_phy_start_sata_link_training(struct isci_phy *iphy)
@@ -591,7 +591,7 @@ static void sci_phy_start_sata_link_training(struct isci_phy *iphy)
 	 */
 	sci_change_state(&iphy->sm, SCI_PHY_SUB_AWAIT_SATA_POWER);
 
-	iphy->protocol = SCIC_SDS_PHY_PROTOCOL_SATA;
+	iphy->protocol = SAS_PROTOCOL_SATA;
 }
 
 /**
@@ -797,7 +797,7 @@ enum sci_status sci_phy_event_handler(struct isci_phy *iphy, u32 event_code)
 			 */
 			break;
 		case SCU_EVENT_SATA_PHY_DETECTED:
-			iphy->protocol = SCIC_SDS_PHY_PROTOCOL_SATA;
+			iphy->protocol = SAS_PROTOCOL_SATA;
 
 			/* We have received the SATA PHY notification change state */
 			sci_change_state(&iphy->sm, SCI_PHY_SUB_AWAIT_SATA_SPEED_EN);
@@ -1215,7 +1215,7 @@ static void sci_phy_starting_state_enter(struct sci_base_state_machine *sm)
 	scu_link_layer_start_oob(iphy);
 
 	/* We don't know what kind of phy we are going to be just yet */
-	iphy->protocol = SCIC_SDS_PHY_PROTOCOL_UNKNOWN;
+	iphy->protocol = SAS_PROTOCOL_NONE;
 	iphy->bcn_received_while_port_unassigned = false;
 
 	if (iphy->sm.previous_state_id == SCI_PHY_READY)
@@ -1250,7 +1250,7 @@ static void sci_phy_resetting_state_enter(struct sci_base_state_machine *sm)
 	 */
 	sci_port_deactivate_phy(iphy->owning_port, iphy, false);
 
-	if (iphy->protocol == SCIC_SDS_PHY_PROTOCOL_SAS) {
+	if (iphy->protocol == SAS_PROTOCOL_SSP) {
 		scu_link_layer_tx_hard_reset(iphy);
 	} else {
 		/* The SCU does not need to have a discrete reset state so
@@ -1316,7 +1316,7 @@ void sci_phy_construct(struct isci_phy *iphy,
 	iphy->owning_port = iport;
 	iphy->phy_index = phy_index;
 	iphy->bcn_received_while_port_unassigned = false;
-	iphy->protocol = SCIC_SDS_PHY_PROTOCOL_UNKNOWN;
+	iphy->protocol = SAS_PROTOCOL_NONE;
 	iphy->link_layer_registers = NULL;
 	iphy->max_negotiated_speed = SAS_LINK_RATE_UNKNOWN;
 

commit e462116afb1e436d4045167e7fe979405ae33d2b
Author: Dan Williams <dan.j.williams@intel.com>
Date:   Fri Feb 10 01:18:49 2012 -0800

    [SCSI] isci: improve phy event warnings
    
    isci occasionally spews messages like:
    
    isci 0000:03:00.0: sci_phy_event_handler: PHY starting substate machine received unexpected event_code b3940000
    
    ...which is not very helpful, since we don't know which controller,
    which phy, the exact state, or a decode of the event.
    
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>
    Signed-off-by: James Bottomley <JBottomley@Parallels.com>

diff --git a/drivers/scsi/isci/phy.c b/drivers/scsi/isci/phy.c
index 87064f13f8fa..fab3586840b5 100644
--- a/drivers/scsi/isci/phy.c
+++ b/drivers/scsi/isci/phy.c
@@ -77,12 +77,17 @@ enum sas_linkrate sci_phy_linkrate(struct isci_phy *iphy)
 	return iphy->max_negotiated_speed;
 }
 
-static struct device *sciphy_to_dev(struct isci_phy *iphy)
+static struct isci_host *phy_to_host(struct isci_phy *iphy)
 {
 	struct isci_phy *table = iphy - iphy->phy_index;
 	struct isci_host *ihost = container_of(table, typeof(*ihost), phys[0]);
 
-	return &ihost->pdev->dev;
+	return ihost;
+}
+
+static struct device *sciphy_to_dev(struct isci_phy *iphy)
+{
+	return &phy_to_host(iphy)->pdev->dev;
 }
 
 static enum sci_status
@@ -609,6 +614,60 @@ static void sci_phy_complete_link_training(struct isci_phy *iphy,
 	sci_change_state(&iphy->sm, next_state);
 }
 
+static const char *phy_event_name(u32 event_code)
+{
+	switch (scu_get_event_code(event_code)) {
+	case SCU_EVENT_PORT_SELECTOR_DETECTED:
+		return "port selector";
+	case SCU_EVENT_SENT_PORT_SELECTION:
+		return "port selection";
+	case SCU_EVENT_HARD_RESET_TRANSMITTED:
+		return "tx hard reset";
+	case SCU_EVENT_HARD_RESET_RECEIVED:
+		return "rx hard reset";
+	case SCU_EVENT_RECEIVED_IDENTIFY_TIMEOUT:
+		return "identify timeout";
+	case SCU_EVENT_LINK_FAILURE:
+		return "link fail";
+	case SCU_EVENT_SATA_SPINUP_HOLD:
+		return "sata spinup hold";
+	case SCU_EVENT_SAS_15_SSC:
+	case SCU_EVENT_SAS_15:
+		return "sas 1.5";
+	case SCU_EVENT_SAS_30_SSC:
+	case SCU_EVENT_SAS_30:
+		return "sas 3.0";
+	case SCU_EVENT_SAS_60_SSC:
+	case SCU_EVENT_SAS_60:
+		return "sas 6.0";
+	case SCU_EVENT_SATA_15_SSC:
+	case SCU_EVENT_SATA_15:
+		return "sata 1.5";
+	case SCU_EVENT_SATA_30_SSC:
+	case SCU_EVENT_SATA_30:
+		return "sata 3.0";
+	case SCU_EVENT_SATA_60_SSC:
+	case SCU_EVENT_SATA_60:
+		return "sata 6.0";
+	case SCU_EVENT_SAS_PHY_DETECTED:
+		return "sas detect";
+	case SCU_EVENT_SATA_PHY_DETECTED:
+		return "sata detect";
+	default:
+		return "unknown";
+	}
+}
+
+#define phy_event_dbg(iphy, state, code) \
+	dev_dbg(sciphy_to_dev(iphy), "phy-%d:%d: %s event: %s (%x)\n", \
+		phy_to_host(iphy)->id, iphy->phy_index, \
+		phy_state_name(state), phy_event_name(code), code)
+
+#define phy_event_warn(iphy, state, code) \
+	dev_warn(sciphy_to_dev(iphy), "phy-%d:%d: %s event: %s (%x)\n", \
+		phy_to_host(iphy)->id, iphy->phy_index, \
+		phy_state_name(state), phy_event_name(code), code)
+
 enum sci_status sci_phy_event_handler(struct isci_phy *iphy, u32 event_code)
 {
 	enum sci_phy_states state = iphy->sm.current_state_id;
@@ -625,11 +684,7 @@ enum sci_status sci_phy_event_handler(struct isci_phy *iphy, u32 event_code)
 			iphy->is_in_link_training = true;
 			break;
 		default:
-			dev_dbg(sciphy_to_dev(iphy),
-				"%s: PHY starting substate machine received "
-				"unexpected event_code %x\n",
-				__func__,
-				event_code);
+			phy_event_dbg(iphy, state, event_code);
 			return SCI_FAILURE;
 		}
 		return SCI_SUCCESS;
@@ -666,11 +721,7 @@ enum sci_status sci_phy_event_handler(struct isci_phy *iphy, u32 event_code)
 			sci_change_state(&iphy->sm, SCI_PHY_STARTING);
 			break;
 		default:
-			dev_warn(sciphy_to_dev(iphy),
-				 "%s: PHY starting substate machine received "
-				 "unexpected event_code %x\n",
-				 __func__, event_code);
-
+			phy_event_warn(iphy, state, event_code);
 			return SCI_FAILURE;
 			break;
 		}
@@ -695,10 +746,7 @@ enum sci_status sci_phy_event_handler(struct isci_phy *iphy, u32 event_code)
 			sci_change_state(&iphy->sm, SCI_PHY_STARTING);
 			break;
 		default:
-			dev_warn(sciphy_to_dev(iphy),
-				 "%s: PHY starting substate machine received "
-				 "unexpected event_code %x\n",
-				 __func__, event_code);
+			phy_event_warn(iphy, state, event_code);
 			return SCI_FAILURE;
 		}
 		return SCI_SUCCESS;
@@ -709,11 +757,7 @@ enum sci_status sci_phy_event_handler(struct isci_phy *iphy, u32 event_code)
 			sci_change_state(&iphy->sm, SCI_PHY_STARTING);
 			break;
 		default:
-			dev_warn(sciphy_to_dev(iphy),
-				"%s: PHY starting substate machine received unexpected "
-				"event_code %x\n",
-				__func__,
-				event_code);
+			phy_event_warn(iphy, state, event_code);
 			return SCI_FAILURE;
 		}
 		return SCI_SUCCESS;
@@ -737,11 +781,7 @@ enum sci_status sci_phy_event_handler(struct isci_phy *iphy, u32 event_code)
 			break;
 
 		default:
-			dev_warn(sciphy_to_dev(iphy),
-				 "%s: PHY starting substate machine received "
-				 "unexpected event_code %x\n",
-				 __func__, event_code);
-
+			phy_event_warn(iphy, state, event_code);
 			return SCI_FAILURE;
 		}
 		return SCI_SUCCESS;
@@ -769,12 +809,7 @@ enum sci_status sci_phy_event_handler(struct isci_phy *iphy, u32 event_code)
 			sci_phy_start_sas_link_training(iphy);
 			break;
 		default:
-			dev_warn(sciphy_to_dev(iphy),
-				 "%s: PHY starting substate machine received "
-				 "unexpected event_code %x\n",
-				 __func__,
-				 event_code);
-
+			phy_event_warn(iphy, state, event_code);
 			return SCI_FAILURE;
 		}
 		return SCI_SUCCESS;
@@ -811,11 +846,7 @@ enum sci_status sci_phy_event_handler(struct isci_phy *iphy, u32 event_code)
 			sci_phy_start_sas_link_training(iphy);
 			break;
 		default:
-			dev_warn(sciphy_to_dev(iphy),
-				 "%s: PHY starting substate machine received "
-				 "unexpected event_code %x\n",
-				 __func__, event_code);
-
+			phy_event_warn(iphy, state, event_code);
 			return SCI_FAILURE;
 		}
 
@@ -833,12 +864,7 @@ enum sci_status sci_phy_event_handler(struct isci_phy *iphy, u32 event_code)
 			break;
 
 		default:
-			dev_warn(sciphy_to_dev(iphy),
-				 "%s: PHY starting substate machine received "
-				 "unexpected event_code %x\n",
-				 __func__,
-				 event_code);
-
+			phy_event_warn(iphy, state, event_code);
 			return SCI_FAILURE;
 		}
 		return SCI_SUCCESS;
@@ -856,10 +882,7 @@ enum sci_status sci_phy_event_handler(struct isci_phy *iphy, u32 event_code)
 				iphy->bcn_received_while_port_unassigned = true;
 			break;
 		default:
-			dev_warn(sciphy_to_dev(iphy),
-				 "%sP SCIC PHY 0x%p ready state machine received "
-				 "unexpected event_code %x\n",
-				 __func__, iphy, event_code);
+			phy_event_warn(iphy, state, event_code);
 			return SCI_FAILURE_INVALID_STATE;
 		}
 		return SCI_SUCCESS;
@@ -870,11 +893,7 @@ enum sci_status sci_phy_event_handler(struct isci_phy *iphy, u32 event_code)
 			sci_change_state(&iphy->sm, SCI_PHY_STARTING);
 			break;
 		default:
-			dev_warn(sciphy_to_dev(iphy),
-				 "%s: SCIC PHY 0x%p resetting state machine received "
-				 "unexpected event_code %x\n",
-				 __func__, iphy, event_code);
-
+			phy_event_warn(iphy, state, event_code);
 			return SCI_FAILURE_INVALID_STATE;
 			break;
 		}

commit d7a0ccdd9bd78b5b74d2963ec7ab67c9d896902a
Author: Dan Williams <dan.j.williams@intel.com>
Date:   Fri Feb 10 01:18:44 2012 -0800

    [SCSI] isci: debug, provide state-enum-to-string conversions
    
    Debugging the driver requires tracing the state transtions and tracing
    state names is less work than decoding numbers.
    
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>
    Signed-off-by: James Bottomley <JBottomley@Parallels.com>

diff --git a/drivers/scsi/isci/phy.c b/drivers/scsi/isci/phy.c
index 8d412ca689ad..87064f13f8fa 100644
--- a/drivers/scsi/isci/phy.c
+++ b/drivers/scsi/isci/phy.c
@@ -59,6 +59,16 @@
 #include "scu_event_codes.h"
 #include "probe_roms.h"
 
+#undef C
+#define C(a) (#a)
+static const char *phy_state_name(enum sci_phy_states state)
+{
+	static const char * const strings[] = PHY_STATES;
+
+	return strings[state];
+}
+#undef C
+
 /* Maximum arbitration wait time in micro-seconds */
 #define SCIC_SDS_PHY_MAX_ARBITRATION_WAIT_TIME  (700)
 
@@ -454,8 +464,8 @@ enum sci_status sci_phy_start(struct isci_phy *iphy)
 	enum sci_phy_states state = iphy->sm.current_state_id;
 
 	if (state != SCI_PHY_STOPPED) {
-		dev_dbg(sciphy_to_dev(iphy),
-			 "%s: in wrong state: %d\n", __func__, state);
+		dev_dbg(sciphy_to_dev(iphy), "%s: in wrong state: %s\n",
+			__func__, phy_state_name(state));
 		return SCI_FAILURE_INVALID_STATE;
 	}
 
@@ -480,8 +490,8 @@ enum sci_status sci_phy_stop(struct isci_phy *iphy)
 	case SCI_PHY_READY:
 		break;
 	default:
-		dev_dbg(sciphy_to_dev(iphy),
-			"%s: in wrong state: %d\n", __func__, state);
+		dev_dbg(sciphy_to_dev(iphy), "%s: in wrong state: %s\n",
+			__func__, phy_state_name(state));
 		return SCI_FAILURE_INVALID_STATE;
 	}
 
@@ -494,8 +504,8 @@ enum sci_status sci_phy_reset(struct isci_phy *iphy)
 	enum sci_phy_states state = iphy->sm.current_state_id;
 
 	if (state != SCI_PHY_READY) {
-		dev_dbg(sciphy_to_dev(iphy),
-			"%s: in wrong state: %d\n", __func__, state);
+		dev_dbg(sciphy_to_dev(iphy), "%s: in wrong state: %s\n",
+			__func__, phy_state_name(state));
 		return SCI_FAILURE_INVALID_STATE;
 	}
 
@@ -544,8 +554,8 @@ enum sci_status sci_phy_consume_power_handler(struct isci_phy *iphy)
 		return SCI_SUCCESS;
 	}
 	default:
-		dev_dbg(sciphy_to_dev(iphy),
-			"%s: in wrong state: %d\n", __func__, state);
+		dev_dbg(sciphy_to_dev(iphy), "%s: in wrong state: %s\n",
+			__func__, phy_state_name(state));
 		return SCI_FAILURE_INVALID_STATE;
 	}
 }
@@ -870,8 +880,8 @@ enum sci_status sci_phy_event_handler(struct isci_phy *iphy, u32 event_code)
 		}
 		return SCI_SUCCESS;
 	default:
-		dev_dbg(sciphy_to_dev(iphy),
-			"%s: in wrong state: %d\n", __func__, state);
+		dev_dbg(sciphy_to_dev(iphy), "%s: in wrong state: %s\n",
+			__func__, phy_state_name(state));
 		return SCI_FAILURE_INVALID_STATE;
 	}
 }
@@ -964,8 +974,8 @@ enum sci_status sci_phy_frame_handler(struct isci_phy *iphy, u32 frame_index)
 		return result;
 	}
 	default:
-		dev_dbg(sciphy_to_dev(iphy),
-			"%s: in wrong state: %d\n", __func__, state);
+		dev_dbg(sciphy_to_dev(iphy), "%s: in wrong state: %s\n",
+			__func__, phy_state_name(state));
 		return SCI_FAILURE_INVALID_STATE;
 	}
 

commit c132f692085ac624d7c8123df781846c8dcb3166
Author: Dan Williams <dan.j.williams@intel.com>
Date:   Tue Jan 3 23:26:08 2012 -0800

    [SCSI] isci: kill iphy->isci_port lookups
    
    This field is a holdover from the OS abstraction conversion.  The stable
    phy to port lookups are done via iphy->ownining_port under scic_lock.
    After this conversion to use port->lldd_port the only volatile lookup is
    the initial lookup in isci_port_formed().  After that point any lookup
    via a successfully notified domain_device is guaranteed to be valid
    until the domain_device is destroyed.
    
    Delete ->start_complete as it is only set once and is set as a
    consequence of the port going link up, by definition of getting a port
    formed event the port is "ready".
    
    While we are correcting port lookups also move the asd_sas_port table
    out from under the isci_port.  This is to preclude any temptation to use
    container_of() to convert an asd_sas_port to an isci_port, the
    association is dynamic and under libsas control.
    
    Tested-by: Maciej Trela <maciej.trela@intel.com>
    [dmilburn@redhat.com: fix i686 compile error]
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>
    Signed-off-by: James Bottomley <JBottomley@Parallels.com>

diff --git a/drivers/scsi/isci/phy.c b/drivers/scsi/isci/phy.c
index fe18acfd6eb3..8d412ca689ad 100644
--- a/drivers/scsi/isci/phy.c
+++ b/drivers/scsi/isci/phy.c
@@ -67,6 +67,14 @@ enum sas_linkrate sci_phy_linkrate(struct isci_phy *iphy)
 	return iphy->max_negotiated_speed;
 }
 
+static struct device *sciphy_to_dev(struct isci_phy *iphy)
+{
+	struct isci_phy *table = iphy - iphy->phy_index;
+	struct isci_host *ihost = container_of(table, typeof(*ihost), phys[0]);
+
+	return &ihost->pdev->dev;
+}
+
 static enum sci_status
 sci_phy_transport_layer_initialization(struct isci_phy *iphy,
 				       struct scu_transport_layer_registers __iomem *reg)
@@ -1299,7 +1307,6 @@ void isci_phy_init(struct isci_phy *iphy, struct isci_host *ihost, int index)
 	sas_addr = cpu_to_be64(sci_sas_addr);
 	memcpy(iphy->sas_addr, &sas_addr, sizeof(sas_addr));
 
-	iphy->isci_port = NULL;
 	iphy->sas_phy.enabled = 0;
 	iphy->sas_phy.id = index;
 	iphy->sas_phy.sas_addr = &iphy->sas_addr[0];
@@ -1333,13 +1340,13 @@ int isci_phy_control(struct asd_sas_phy *sas_phy,
 {
 	int ret = 0;
 	struct isci_phy *iphy = sas_phy->lldd_phy;
-	struct isci_port *iport = iphy->isci_port;
+	struct asd_sas_port *port = sas_phy->port;
 	struct isci_host *ihost = sas_phy->ha->lldd_ha;
 	unsigned long flags;
 
 	dev_dbg(&ihost->pdev->dev,
 		"%s: phy %p; func %d; buf %p; isci phy %p, port %p\n",
-		__func__, sas_phy, func, buf, iphy, iport);
+		__func__, sas_phy, func, buf, iphy, port);
 
 	switch (func) {
 	case PHY_FUNC_DISABLE:
@@ -1356,11 +1363,10 @@ int isci_phy_control(struct asd_sas_phy *sas_phy,
 		break;
 
 	case PHY_FUNC_HARD_RESET:
-		if (!iport)
+		if (!port)
 			return -ENODEV;
 
-		/* Perform the port reset. */
-		ret = isci_port_perform_hard_reset(ihost, iport, iphy);
+		ret = isci_port_perform_hard_reset(ihost, port->lldd_port, iphy);
 
 		break;
 	case PHY_FUNC_GET_EVENTS: {

commit 0953dbea1d9a84c8443b5f5bb45229a6c9d7f9f3
Author: Marcin Tomczak <marcin.tomczak@intel.com>
Date:   Wed Jan 4 01:33:36 2012 -0800

    [SCSI] isci: fix start OOB
    
    Split scu_link_layer_start_oob function to reset and enable and
    add flush after all steps.
    
    Signed-off-by: Marcin Tomczak <marcin.tomczak@intel.com>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>
    Signed-off-by: James Bottomley <JBottomley@Parallels.com>

diff --git a/drivers/scsi/isci/phy.c b/drivers/scsi/isci/phy.c
index 61000cde84c7..fe18acfd6eb3 100644
--- a/drivers/scsi/isci/phy.c
+++ b/drivers/scsi/isci/phy.c
@@ -1098,24 +1098,25 @@ static void scu_link_layer_stop_protocol_engine(
 	writel(enable_spinup_value, &iphy->link_layer_registers->notify_enable_spinup_control);
 }
 
-/**
- *
- *
- * This method will start the OOB/SN state machine for this struct isci_phy object.
- */
-static void scu_link_layer_start_oob(
-	struct isci_phy *iphy)
+static void scu_link_layer_start_oob(struct isci_phy *iphy)
 {
-	u32 scu_sas_pcfg_value;
-
-	scu_sas_pcfg_value =
-		readl(&iphy->link_layer_registers->phy_configuration);
-	scu_sas_pcfg_value |= SCU_SAS_PCFG_GEN_BIT(OOB_ENABLE);
-	scu_sas_pcfg_value &=
-		~(SCU_SAS_PCFG_GEN_BIT(OOB_RESET) |
-		SCU_SAS_PCFG_GEN_BIT(HARD_RESET));
-	writel(scu_sas_pcfg_value,
-	       &iphy->link_layer_registers->phy_configuration);
+	struct scu_link_layer_registers __iomem *ll = iphy->link_layer_registers;
+	u32 val;
+
+	/** Reset OOB sequence - start */
+	val = readl(&ll->phy_configuration);
+	val &= ~(SCU_SAS_PCFG_GEN_BIT(OOB_RESET) |
+		 SCU_SAS_PCFG_GEN_BIT(HARD_RESET));
+	writel(val, &ll->phy_configuration);
+	readl(&ll->phy_configuration); /* flush */
+	/** Reset OOB sequence - end */
+
+	/** Start OOB sequence - start */
+	val = readl(&ll->phy_configuration);
+	val |= SCU_SAS_PCFG_GEN_BIT(OOB_ENABLE);
+	writel(val, &ll->phy_configuration);
+	readl(&ll->phy_configuration); /* flush */
+	/** Start OOB sequence - end */
 }
 
 /**

commit 594e566ae5985e0cc3185ac21509a86e90aad577
Author: Dave Jiang <dave.jiang@intel.com>
Date:   Wed Jan 4 01:32:44 2012 -0800

    [SCSI] isci: oem parameter format v1.1 (ssc select)
    
    v1.1 allows finer grained tuning of the SSC (spread-spectrum-clocking)
    settings for SAS and SATA.  See notes in probe_roms.h
    
    Signed-off-by: Dave Jiang <dave.jiang@intel.com>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>
    Signed-off-by: James Bottomley <JBottomley@Parallels.com>

diff --git a/drivers/scsi/isci/phy.c b/drivers/scsi/isci/phy.c
index c650d3003c22..61000cde84c7 100644
--- a/drivers/scsi/isci/phy.c
+++ b/drivers/scsi/isci/phy.c
@@ -144,10 +144,59 @@ sci_phy_link_layer_initialization(struct isci_phy *iphy,
 	phy_cap.gen3_no_ssc = 1;
 	phy_cap.gen2_no_ssc = 1;
 	phy_cap.gen1_no_ssc = 1;
-	if (ihost->oem_parameters.controller.do_enable_ssc == true) {
+	if (ihost->oem_parameters.controller.do_enable_ssc) {
+		struct scu_afe_registers __iomem *afe = &ihost->scu_registers->afe;
+		struct scu_afe_transceiver *xcvr = &afe->scu_afe_xcvr[phy_idx];
+		struct isci_pci_info *pci_info = to_pci_info(ihost->pdev);
+		bool en_sas = false;
+		bool en_sata = false;
+		u32 sas_type = 0;
+		u32 sata_spread = 0x2;
+		u32 sas_spread = 0x2;
+
 		phy_cap.gen3_ssc = 1;
 		phy_cap.gen2_ssc = 1;
 		phy_cap.gen1_ssc = 1;
+
+		if (pci_info->orom->hdr.version < ISCI_ROM_VER_1_1)
+			en_sas = en_sata = true;
+		else {
+			sata_spread = ihost->oem_parameters.controller.ssc_sata_tx_spread_level;
+			sas_spread = ihost->oem_parameters.controller.ssc_sas_tx_spread_level;
+
+			if (sata_spread)
+				en_sata = true;
+
+			if (sas_spread) {
+				en_sas = true;
+				sas_type = ihost->oem_parameters.controller.ssc_sas_tx_type;
+			}
+
+		}
+
+		if (en_sas) {
+			u32 reg;
+
+			reg = readl(&xcvr->afe_xcvr_control0);
+			reg |= (0x00100000 | (sas_type << 19));
+			writel(reg, &xcvr->afe_xcvr_control0);
+
+			reg = readl(&xcvr->afe_tx_ssc_control);
+			reg |= sas_spread << 8;
+			writel(reg, &xcvr->afe_tx_ssc_control);
+		}
+
+		if (en_sata) {
+			u32 reg;
+
+			reg = readl(&xcvr->afe_tx_ssc_control);
+			reg |= sata_spread;
+			writel(reg, &xcvr->afe_tx_ssc_control);
+
+			reg = readl(&llr->stp_control);
+			reg |= 1 << 12;
+			writel(reg, &llr->stp_control);
+		}
 	}
 
 	/* The SAS specification indicates that the phy_capabilities that

commit afd13a1f2b05157c7621d87dfe89ea6ea9061bd8
Author: Jeff Skirvin <jeffrey.d.skirvin@intel.com>
Date:   Wed Jan 4 01:32:39 2012 -0800

    [SCSI] isci: update afe (analog-front-end) recipe for C1
    
    C1 silicon requires updates to the phy tuning recipe and also support
    for user provided cable selects (per-phy) for short, medium, and long
    cables.  Default to 'short' awaiting support for selecting the cable via
    oem parameters.
    
    Reviewed-by: Jiangbi Liu <jiangbi.liu@intel.com>
    Signed-off-by: Marcin Tomczak <marcin.tomczak@intel.com>
    Signed-off-by: Jeff Skirvin <jeffrey.d.skirvin@intel.com>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>
    Signed-off-by: James Bottomley <JBottomley@Parallels.com>

diff --git a/drivers/scsi/isci/phy.c b/drivers/scsi/isci/phy.c
index 0ae0990b39dd..c650d3003c22 100644
--- a/drivers/scsi/isci/phy.c
+++ b/drivers/scsi/isci/phy.c
@@ -186,8 +186,11 @@ sci_phy_link_layer_initialization(struct isci_phy *iphy,
 
 	writel(clksm_value, &llr->clock_skew_management);
 
-	/* @todo Provide a way to write this register correctly */
-	writel(0x02108421, &llr->afe_lookup_table_control);
+	if (is_c0(ihost->pdev) || is_c1(ihost->pdev)) {
+		writel(0x04210400, &llr->afe_lookup_table_control);
+		writel(0x020A7C05, &llr->sas_primitive_timeout);
+	} else
+		writel(0x02108421, &llr->afe_lookup_table_control);
 
 	llctl = SCU_SAS_LLCTL_GEN_VAL(NO_OUTBOUND_TASK_TIMEOUT,
 		(u8)ihost->user_parameters.no_outbound_task_timeout);

commit 2e5da889d44a3a9629f895de3488306e7f5ddf16
Author: Dan Williams <dan.j.williams@intel.com>
Date:   Wed Jan 4 01:32:34 2012 -0800

    [SCSI] isci: cleanup oem parameter and recipe handling
    
    Before updating the code to support the latest platform updates and
    silicon revision cleanup some of the long deref chains.
    
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>
    Signed-off-by: James Bottomley <JBottomley@Parallels.com>

diff --git a/drivers/scsi/isci/phy.c b/drivers/scsi/isci/phy.c
index 35f50c2183e1..0ae0990b39dd 100644
--- a/drivers/scsi/isci/phy.c
+++ b/drivers/scsi/isci/phy.c
@@ -91,22 +91,23 @@ sci_phy_transport_layer_initialization(struct isci_phy *iphy,
 
 static enum sci_status
 sci_phy_link_layer_initialization(struct isci_phy *iphy,
-				  struct scu_link_layer_registers __iomem *reg)
+				  struct scu_link_layer_registers __iomem *llr)
 {
 	struct isci_host *ihost = iphy->owning_port->owning_controller;
+	struct sci_phy_user_params *phy_user;
+	struct sci_phy_oem_params *phy_oem;
 	int phy_idx = iphy->phy_index;
-	struct sci_phy_user_params *phy_user = &ihost->user_parameters.phys[phy_idx];
-	struct sci_phy_oem_params *phy_oem =
-		&ihost->oem_parameters.phys[phy_idx];
-	u32 phy_configuration;
 	struct sci_phy_cap phy_cap;
+	u32 phy_configuration;
 	u32 parity_check = 0;
 	u32 parity_count = 0;
 	u32 llctl, link_rate;
 	u32 clksm_value = 0;
 	u32 sp_timeouts = 0;
 
-	iphy->link_layer_registers = reg;
+	phy_user = &ihost->user_parameters.phys[phy_idx];
+	phy_oem = &ihost->oem_parameters.phys[phy_idx];
+	iphy->link_layer_registers = llr;
 
 	/* Set our IDENTIFY frame data */
 	#define SCI_END_DEVICE 0x01
@@ -116,32 +117,26 @@ sci_phy_link_layer_initialization(struct isci_phy *iphy,
 	       SCU_SAS_TIID_GEN_BIT(STP_INITIATOR) |
 	       SCU_SAS_TIID_GEN_BIT(DA_SATA_HOST) |
 	       SCU_SAS_TIID_GEN_VAL(DEVICE_TYPE, SCI_END_DEVICE),
-	       &iphy->link_layer_registers->transmit_identification);
+	       &llr->transmit_identification);
 
 	/* Write the device SAS Address */
-	writel(0xFEDCBA98,
-	       &iphy->link_layer_registers->sas_device_name_high);
-	writel(phy_idx, &iphy->link_layer_registers->sas_device_name_low);
+	writel(0xFEDCBA98, &llr->sas_device_name_high);
+	writel(phy_idx, &llr->sas_device_name_low);
 
 	/* Write the source SAS Address */
-	writel(phy_oem->sas_address.high,
-		&iphy->link_layer_registers->source_sas_address_high);
-	writel(phy_oem->sas_address.low,
-		&iphy->link_layer_registers->source_sas_address_low);
+	writel(phy_oem->sas_address.high, &llr->source_sas_address_high);
+	writel(phy_oem->sas_address.low, &llr->source_sas_address_low);
 
 	/* Clear and Set the PHY Identifier */
-	writel(0, &iphy->link_layer_registers->identify_frame_phy_id);
-	writel(SCU_SAS_TIPID_GEN_VALUE(ID, phy_idx),
-		&iphy->link_layer_registers->identify_frame_phy_id);
+	writel(0, &llr->identify_frame_phy_id);
+	writel(SCU_SAS_TIPID_GEN_VALUE(ID, phy_idx), &llr->identify_frame_phy_id);
 
 	/* Change the initial state of the phy configuration register */
-	phy_configuration =
-		readl(&iphy->link_layer_registers->phy_configuration);
+	phy_configuration = readl(&llr->phy_configuration);
 
 	/* Hold OOB state machine in reset */
 	phy_configuration |=  SCU_SAS_PCFG_GEN_BIT(OOB_RESET);
-	writel(phy_configuration,
-		&iphy->link_layer_registers->phy_configuration);
+	writel(phy_configuration, &llr->phy_configuration);
 
 	/* Configure the SNW capabilities */
 	phy_cap.all = 0;
@@ -155,9 +150,9 @@ sci_phy_link_layer_initialization(struct isci_phy *iphy,
 		phy_cap.gen1_ssc = 1;
 	}
 
-	/*
-	 * The SAS specification indicates that the phy_capabilities that
-	 * are transmitted shall have an even parity.  Calculate the parity. */
+	/* The SAS specification indicates that the phy_capabilities that
+	 * are transmitted shall have an even parity.  Calculate the parity.
+	 */
 	parity_check = phy_cap.all;
 	while (parity_check != 0) {
 		if (parity_check & 0x1)
@@ -165,20 +160,20 @@ sci_phy_link_layer_initialization(struct isci_phy *iphy,
 		parity_check >>= 1;
 	}
 
-	/*
-	 * If parity indicates there are an odd number of bits set, then
-	 * set the parity bit to 1 in the phy capabilities. */
+	/* If parity indicates there are an odd number of bits set, then
+	 * set the parity bit to 1 in the phy capabilities.
+	 */
 	if ((parity_count % 2) != 0)
 		phy_cap.parity = 1;
 
-	writel(phy_cap.all, &iphy->link_layer_registers->phy_capabilities);
+	writel(phy_cap.all, &llr->phy_capabilities);
 
 	/* Set the enable spinup period but disable the ability to send
 	 * notify enable spinup
 	 */
 	writel(SCU_ENSPINUP_GEN_VAL(COUNT,
 			phy_user->notify_enable_spin_up_insertion_frequency),
-		&iphy->link_layer_registers->notify_enable_spinup_control);
+		&llr->notify_enable_spinup_control);
 
 	/* Write the ALIGN Insertion Ferequency for connected phy and
 	 * inpendent of connected state
@@ -189,11 +184,10 @@ sci_phy_link_layer_initialization(struct isci_phy *iphy,
 	clksm_value |= SCU_ALIGN_INSERTION_FREQUENCY_GEN_VAL(GENERAL,
 			phy_user->align_insertion_frequency);
 
-	writel(clksm_value, &iphy->link_layer_registers->clock_skew_management);
+	writel(clksm_value, &llr->clock_skew_management);
 
 	/* @todo Provide a way to write this register correctly */
-	writel(0x02108421,
-		&iphy->link_layer_registers->afe_lookup_table_control);
+	writel(0x02108421, &llr->afe_lookup_table_control);
 
 	llctl = SCU_SAS_LLCTL_GEN_VAL(NO_OUTBOUND_TASK_TIMEOUT,
 		(u8)ihost->user_parameters.no_outbound_task_timeout);
@@ -210,9 +204,9 @@ sci_phy_link_layer_initialization(struct isci_phy *iphy,
 		break;
 	}
 	llctl |= SCU_SAS_LLCTL_GEN_VAL(MAX_LINK_RATE, link_rate);
-	writel(llctl, &iphy->link_layer_registers->link_layer_control);
+	writel(llctl, &llr->link_layer_control);
 
-	sp_timeouts = readl(&iphy->link_layer_registers->sas_phy_timeouts);
+	sp_timeouts = readl(&llr->sas_phy_timeouts);
 
 	/* Clear the default 0x36 (54us) RATE_CHANGE timeout value. */
 	sp_timeouts &= ~SCU_SAS_PHYTOV_GEN_VAL(RATE_CHANGE, 0xFF);
@@ -222,20 +216,23 @@ sci_phy_link_layer_initialization(struct isci_phy *iphy,
 	 */
 	sp_timeouts |= SCU_SAS_PHYTOV_GEN_VAL(RATE_CHANGE, 0x3B);
 
-	writel(sp_timeouts, &iphy->link_layer_registers->sas_phy_timeouts);
+	writel(sp_timeouts, &llr->sas_phy_timeouts);
 
 	if (is_a2(ihost->pdev)) {
-		/* Program the max ARB time for the PHY to 700us so we inter-operate with
-		 * the PMC expander which shuts down PHYs if the expander PHY generates too
-		 * many breaks.  This time value will guarantee that the initiator PHY will
-		 * generate the break.
+		/* Program the max ARB time for the PHY to 700us so we
+		 * inter-operate with the PMC expander which shuts down
+		 * PHYs if the expander PHY generates too many breaks.
+		 * This time value will guarantee that the initiator PHY
+		 * will generate the break.
 		 */
 		writel(SCIC_SDS_PHY_MAX_ARBITRATION_WAIT_TIME,
-			&iphy->link_layer_registers->maximum_arbitration_wait_timer_timeout);
+		       &llr->maximum_arbitration_wait_timer_timeout);
 	}
 
-	/* Disable link layer hang detection, rely on the OS timeout for I/O timeouts. */
-	writel(0, &iphy->link_layer_registers->link_layer_hang_detection_timeout);
+	/* Disable link layer hang detection, rely on the OS timeout for
+	 * I/O timeouts.
+	 */
+	writel(0, &llr->link_layer_hang_detection_timeout);
 
 	/* We can exit the initial state to the stopped state */
 	sci_change_state(&iphy->sm, SCI_PHY_STOPPED);

commit ec7ae517537ae5c7b0b2cd7f562dfa3e7a05b954
Merge: 97d2eb13a019 590134fa78fb
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Fri Oct 28 16:44:18 2011 -0700

    Merge git://git.kernel.org/pub/scm/linux/kernel/git/jejb/scsi-misc-2.6
    
    * git://git.kernel.org/pub/scm/linux/kernel/git/jejb/scsi-misc-2.6: (204 commits)
      [SCSI] qla4xxx: export address/port of connection (fix udev disk names)
      [SCSI] ipr: Fix BUG on adapter dump timeout
      [SCSI] megaraid_sas: Fix instance access in megasas_reset_timer
      [SCSI] hpsa: change confusing message to be more clear
      [SCSI] iscsi class: fix vlan configuration
      [SCSI] qla4xxx: fix data alignment and use nl helpers
      [SCSI] iscsi class: fix link local mispelling
      [SCSI] iscsi class: Replace iscsi_get_next_target_id with IDA
      [SCSI] aacraid: use lower snprintf() limit
      [SCSI] lpfc 8.3.27: Change driver version to 8.3.27
      [SCSI] lpfc 8.3.27: T10 additions for SLI4
      [SCSI] lpfc 8.3.27: Fix queue allocation failure recovery
      [SCSI] lpfc 8.3.27: Change algorithm for getting physical port name
      [SCSI] lpfc 8.3.27: Changed worst case mailbox timeout
      [SCSI] lpfc 8.3.27: Miscellanous logic and interface fixes
      [SCSI] megaraid_sas: Changelog and version update
      [SCSI] megaraid_sas: Add driver workaround for PERC5/1068 kdump kernel panic
      [SCSI] megaraid_sas: Add multiple MSI-X vector/multiple reply queue support
      [SCSI] megaraid_sas: Add support for MegaRAID 9360/9380 12GB/s controllers
      [SCSI] megaraid_sas: Clear FUSION_IN_RESET before enabling interrupts
      ...

commit ac013ed1cb7b1b36113548ce83881a1b5f757b58
Author: Dan Williams <dan.j.williams@intel.com>
Date:   Wed Sep 28 18:48:02 2011 -0700

    [SCSI] isci: export phy events via ->lldd_control_phy()
    
    Allow the sas-transport-class to update events for local phys via a new
    PHY_FUNC_GET_EVENTS command to ->lldd_control_phy().  Fixup drivers that
    are not prepared for new enum phy_func values, and unify
    ->lldd_control_phy() error codes.
    
    These are the SAS defined phy events that are reported in a
    smp-report-phy-error-log command:
     * /sys/class/sas_phy/<phyX>/invalid_dword_count
     * /sys/class/sas_phy/<phyX>/running_disparity_error_count
     * /sys/class/sas_phy/<phyX>/loss_of_dword_sync_count
     * /sys/class/sas_phy/<phyX>/phy_reset_problem_count
    
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>
    Signed-off-by: James Bottomley <JBottomley@Parallels.com>

diff --git a/drivers/scsi/isci/phy.c b/drivers/scsi/isci/phy.c
index 430fc8ff014a..ab48bb11eab0 100644
--- a/drivers/scsi/isci/phy.c
+++ b/drivers/scsi/isci/phy.c
@@ -1313,6 +1313,17 @@ int isci_phy_control(struct asd_sas_phy *sas_phy,
 		ret = isci_port_perform_hard_reset(ihost, iport, iphy);
 
 		break;
+	case PHY_FUNC_GET_EVENTS: {
+		struct scu_link_layer_registers __iomem *r;
+		struct sas_phy *phy = sas_phy->phy;
+
+		r = iphy->link_layer_registers;
+		phy->running_disparity_error_count = readl(&r->running_disparity_error_count);
+		phy->loss_of_dword_sync_count = readl(&r->loss_of_sync_error_count);
+		phy->phy_reset_problem_count = readl(&r->phy_reset_problem_count);
+		phy->invalid_dword_count = readl(&r->invalid_dword_counter);
+		break;
+	}
 
 	default:
 		dev_dbg(&ihost->pdev->dev,

commit e060c38434b2caa78efe7cedaff4191040b65a15
Merge: 10e4ac572eef cc39c6a9bbde
Author: Jiri Kosina <jkosina@suse.cz>
Date:   Thu Sep 15 15:08:05 2011 +0200

    Merge branch 'master' into for-next
    
    Fast-forward merge with Linus to be able to merge patches
    based on more recent version of the tree.

commit 699324871fcc3650f2023c5e36cb119a92d7894b
Author: Justin P. Mattock <justinmattock@gmail.com>
Date:   Tue Jul 26 23:06:29 2011 -0700

    treewide: remove extra semicolons from various parts of the kernel
    
    This is a resend from the original, changing the title from PATCH to
    RFC(since this is a review for commit, and I should have put that the first go around).
    and also removing some of the commit's with ia64 and bash since it is significant.
    let me know if I might have missed anything etc..
    
    Signed-off-by: Justin P. Mattock <justinmattock@gmail.com>
    Signed-off-by: Jiri Kosina <jkosina@suse.cz>

diff --git a/drivers/scsi/isci/phy.c b/drivers/scsi/isci/phy.c
index 79313a7a2356..8d9192d49f4a 100644
--- a/drivers/scsi/isci/phy.c
+++ b/drivers/scsi/isci/phy.c
@@ -695,7 +695,7 @@ enum sci_status sci_phy_event_handler(struct isci_phy *iphy, u32 event_code)
 				 __func__,
 				 event_code);
 
-			return SCI_FAILURE;;
+			return SCI_FAILURE;
 		}
 		return SCI_SUCCESS;
 	case SCI_PHY_SUB_AWAIT_SATA_SPEED_EN:

commit 985af6f70dbb8a33b3af8a7c7df508d924650e37
Author: Marcin Tomczak <marcin.tomczak@intel.com>
Date:   Fri Jul 29 17:16:50 2011 -0700

    [SCSI] isci: change sas phy timeouts from 54us to 59us
    
    Need the following workaround in the driver for interoperability with
    the older Intel SSD drives and any other SATA drive that may exhibit the
    same behavior. This is a corner case where SCU speed is limited to
    either 3G or 1.5G and the drive has a period of DC idle when it switches
    speed during SATA speed negotiation. Workaround :change PHYTOV[31:24]
    from 0x36 to 0x3B.
    
    Signed-off-by: Marcin Tomczak <marcin.tomczak@intel.com>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>
    Signed-off-by: James Bottomley <JBottomley@Parallels.com>

diff --git a/drivers/scsi/isci/phy.c b/drivers/scsi/isci/phy.c
index 79313a7a2356..430fc8ff014a 100644
--- a/drivers/scsi/isci/phy.c
+++ b/drivers/scsi/isci/phy.c
@@ -104,6 +104,7 @@ sci_phy_link_layer_initialization(struct isci_phy *iphy,
 	u32 parity_count = 0;
 	u32 llctl, link_rate;
 	u32 clksm_value = 0;
+	u32 sp_timeouts = 0;
 
 	iphy->link_layer_registers = reg;
 
@@ -211,6 +212,18 @@ sci_phy_link_layer_initialization(struct isci_phy *iphy,
 	llctl |= SCU_SAS_LLCTL_GEN_VAL(MAX_LINK_RATE, link_rate);
 	writel(llctl, &iphy->link_layer_registers->link_layer_control);
 
+	sp_timeouts = readl(&iphy->link_layer_registers->sas_phy_timeouts);
+
+	/* Clear the default 0x36 (54us) RATE_CHANGE timeout value. */
+	sp_timeouts &= ~SCU_SAS_PHYTOV_GEN_VAL(RATE_CHANGE, 0xFF);
+
+	/* Set RATE_CHANGE timeout value to 0x3B (59us).  This ensures SCU can
+	 * lock with 3Gb drive when SCU max rate is set to 1.5Gb.
+	 */
+	sp_timeouts |= SCU_SAS_PHYTOV_GEN_VAL(RATE_CHANGE, 0x3B);
+
+	writel(sp_timeouts, &iphy->link_layer_registers->sas_phy_timeouts);
+
 	if (is_a2(ihost->pdev)) {
 		/* Program the max ARB time for the PHY to 700us so we inter-operate with
 		 * the PMC expander which shuts down PHYs if the expander PHY generates too

commit a5ec7f86dc5432c44d8407a144e7617ec65da770
Author: James Bottomley <James.Bottomley@HansenPartnership.com>
Date:   Sun Jul 3 14:14:45 2011 -0500

    [SCSI] isci: fix checkpatch errors
    
    Signed-off-by: James Bottomley <JBottomley@Parallels.com>

diff --git a/drivers/scsi/isci/phy.c b/drivers/scsi/isci/phy.c
index d8f893ee7d03..79313a7a2356 100644
--- a/drivers/scsi/isci/phy.c
+++ b/drivers/scsi/isci/phy.c
@@ -197,7 +197,7 @@ sci_phy_link_layer_initialization(struct isci_phy *iphy,
 	llctl = SCU_SAS_LLCTL_GEN_VAL(NO_OUTBOUND_TASK_TIMEOUT,
 		(u8)ihost->user_parameters.no_outbound_task_timeout);
 
-	switch(phy_user->max_speed_generation) {
+	switch (phy_user->max_speed_generation) {
 	case SCIC_SDS_PARM_GEN3_SPEED:
 		link_rate = SCU_SAS_LINK_LAYER_CONTROL_MAX_LINK_RATE_GEN3;
 		break;

commit dc00c8b6940aa10ab1ce6a4d10b1bfe7b848781b
Author: Dan Williams <dan.j.williams@intel.com>
Date:   Fri Jul 1 11:41:21 2011 -0700

    isci: cleanup silicon revision detection
    
    Perform checking per-pci device (even though all systems will only have
    1 pci device in this generation), and delete support for silicon that
    does not report a proper revision (i.e. A0).
    
    Reported-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/drivers/scsi/isci/phy.c b/drivers/scsi/isci/phy.c
index e56080af78f4..d8f893ee7d03 100644
--- a/drivers/scsi/isci/phy.c
+++ b/drivers/scsi/isci/phy.c
@@ -211,7 +211,7 @@ sci_phy_link_layer_initialization(struct isci_phy *iphy,
 	llctl |= SCU_SAS_LLCTL_GEN_VAL(MAX_LINK_RATE, link_rate);
 	writel(llctl, &iphy->link_layer_registers->link_layer_control);
 
-	if (is_a0() || is_a2()) {
+	if (is_a2(ihost->pdev)) {
 		/* Program the max ARB time for the PHY to 700us so we inter-operate with
 		 * the PMC expander which shuts down PHYs if the expander PHY generates too
 		 * many breaks.  This time value will guarantee that the initiator PHY will

commit 34a991587a5cc9f78960c2c9beea217866458c41
Author: Dan Williams <dan.j.williams@intel.com>
Date:   Fri Jul 1 02:25:15 2011 -0700

    isci: kill 'get/set' macros
    
    Most of these simple dereference macros are longer than their open coded
    equivalent.  Deleting enum sci_controller_mode is thrown in for good
    measure.
    
    Reported-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/drivers/scsi/isci/phy.c b/drivers/scsi/isci/phy.c
index 0df9f713f487..e56080af78f4 100644
--- a/drivers/scsi/isci/phy.c
+++ b/drivers/scsi/isci/phy.c
@@ -265,10 +265,11 @@ static void phy_sata_timeout(unsigned long data)
  * port (i.e. it's contained in the dummy port). !NULL All other
  * values indicate a handle/pointer to the port containing the phy.
  */
-struct isci_port *phy_get_non_dummy_port(
-	struct isci_phy *iphy)
+struct isci_port *phy_get_non_dummy_port(struct isci_phy *iphy)
 {
-	if (sci_port_get_index(iphy->owning_port) == SCIC_SDS_DUMMY_PORT)
+	struct isci_port *iport = iphy->owning_port;
+
+	if (iport->physical_port_index == SCIC_SDS_DUMMY_PORT)
 		return NULL;
 
 	return iphy->owning_port;
@@ -858,10 +859,9 @@ enum sci_status sci_phy_frame_handler(struct isci_phy *iphy, u32 frame_index)
 		struct dev_to_host_fis *frame_header;
 		u32 *fis_frame_data;
 
-		result = sci_unsolicited_frame_control_get_header(
-			&(sci_phy_get_controller(iphy)->uf_control),
-			frame_index,
-			(void **)&frame_header);
+		result = sci_unsolicited_frame_control_get_header(&ihost->uf_control,
+								  frame_index,
+								  (void **)&frame_header);
 
 		if (result != SCI_SUCCESS)
 			return result;
@@ -1090,6 +1090,8 @@ static void scu_link_layer_tx_hard_reset(
 static void sci_phy_stopped_state_enter(struct sci_base_state_machine *sm)
 {
 	struct isci_phy *iphy = container_of(sm, typeof(*iphy), sm);
+	struct isci_port *iport = iphy->owning_port;
+	struct isci_host *ihost = iport->owning_controller;
 
 	/*
 	 * @todo We need to get to the controller to place this PE in a
@@ -1100,14 +1102,14 @@ static void sci_phy_stopped_state_enter(struct sci_base_state_machine *sm)
 	scu_link_layer_stop_protocol_engine(iphy);
 
 	if (iphy->sm.previous_state_id != SCI_PHY_INITIAL)
-		sci_controller_link_down(sci_phy_get_controller(iphy),
-					      phy_get_non_dummy_port(iphy),
-					      iphy);
+		sci_controller_link_down(ihost, phy_get_non_dummy_port(iphy), iphy);
 }
 
 static void sci_phy_starting_state_enter(struct sci_base_state_machine *sm)
 {
 	struct isci_phy *iphy = container_of(sm, typeof(*iphy), sm);
+	struct isci_port *iport = iphy->owning_port;
+	struct isci_host *ihost = iport->owning_controller;
 
 	scu_link_layer_stop_protocol_engine(iphy);
 	scu_link_layer_start_oob(iphy);
@@ -1117,9 +1119,7 @@ static void sci_phy_starting_state_enter(struct sci_base_state_machine *sm)
 	iphy->bcn_received_while_port_unassigned = false;
 
 	if (iphy->sm.previous_state_id == SCI_PHY_READY)
-		sci_controller_link_down(sci_phy_get_controller(iphy),
-					      phy_get_non_dummy_port(iphy),
-					      iphy);
+		sci_controller_link_down(ihost, phy_get_non_dummy_port(iphy), iphy);
 
 	sci_change_state(&iphy->sm, SCI_PHY_SUB_INITIAL);
 }
@@ -1127,11 +1127,10 @@ static void sci_phy_starting_state_enter(struct sci_base_state_machine *sm)
 static void sci_phy_ready_state_enter(struct sci_base_state_machine *sm)
 {
 	struct isci_phy *iphy = container_of(sm, typeof(*iphy), sm);
+	struct isci_port *iport = iphy->owning_port;
+	struct isci_host *ihost = iport->owning_controller;
 
-	sci_controller_link_up(sci_phy_get_controller(iphy),
-				    phy_get_non_dummy_port(iphy),
-				    iphy);
-
+	sci_controller_link_up(ihost, phy_get_non_dummy_port(iphy), iphy);
 }
 
 static void sci_phy_ready_state_exit(struct sci_base_state_machine *sm)

commit 89a7301f21fb00e753089671eb9e4132aab8ea08
Author: Dan Williams <dan.j.williams@intel.com>
Date:   Thu Jun 30 19:14:33 2011 -0700

    isci: retire scic_sds_ and scic_ prefixes
    
    The distinction between scic_sds_ scic_ and sci_ are no longer relevant
    so just unify the prefixes on sci_.  The distinction between isci_ and
    sci_ is historically significant, and useful for comparing the old
    'core' to the current Linux driver. 'sci_' represents the former core as
    well as the routines that are closer to the hardware and protocol than
    their 'isci_' brethren. sci == sas controller interface.
    
    Also unwind the 'sds1' out of the parameter structs.
    
    Reported-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/drivers/scsi/isci/phy.c b/drivers/scsi/isci/phy.c
index ca96b5ad0d52..0df9f713f487 100644
--- a/drivers/scsi/isci/phy.c
+++ b/drivers/scsi/isci/phy.c
@@ -67,25 +67,13 @@ enum sas_linkrate sci_phy_linkrate(struct isci_phy *iphy)
 	return iphy->max_negotiated_speed;
 }
 
-/*
- * *****************************************************************************
- * * SCIC SDS PHY Internal Methods
- * ***************************************************************************** */
-
-/**
- * This method will initialize the phy transport layer registers
- * @sci_phy:
- * @transport_layer_registers
- *
- * enum sci_status
- */
-static enum sci_status scic_sds_phy_transport_layer_initialization(
-	struct isci_phy *iphy,
-	struct scu_transport_layer_registers __iomem *transport_layer_registers)
+static enum sci_status
+sci_phy_transport_layer_initialization(struct isci_phy *iphy,
+				       struct scu_transport_layer_registers __iomem *reg)
 {
 	u32 tl_control;
 
-	iphy->transport_layer_registers = transport_layer_registers;
+	iphy->transport_layer_registers = reg;
 
 	writel(SCIC_SDS_REMOTE_NODE_CONTEXT_INVALID_INDEX,
 		&iphy->transport_layer_registers->stp_rni);
@@ -101,32 +89,23 @@ static enum sci_status scic_sds_phy_transport_layer_initialization(
 	return SCI_SUCCESS;
 }
 
-/**
- * This method will initialize the phy link layer registers
- * @sci_phy:
- * @link_layer_registers:
- *
- * enum sci_status
- */
 static enum sci_status
-scic_sds_phy_link_layer_initialization(struct isci_phy *iphy,
-				       struct scu_link_layer_registers __iomem *link_layer_registers)
+sci_phy_link_layer_initialization(struct isci_phy *iphy,
+				  struct scu_link_layer_registers __iomem *reg)
 {
-	struct isci_host *ihost =
-		iphy->owning_port->owning_controller;
+	struct isci_host *ihost = iphy->owning_port->owning_controller;
 	int phy_idx = iphy->phy_index;
-	struct sci_phy_user_params *phy_user =
-		&ihost->user_parameters.sds1.phys[phy_idx];
+	struct sci_phy_user_params *phy_user = &ihost->user_parameters.phys[phy_idx];
 	struct sci_phy_oem_params *phy_oem =
-		&ihost->oem_parameters.sds1.phys[phy_idx];
+		&ihost->oem_parameters.phys[phy_idx];
 	u32 phy_configuration;
-	struct scic_phy_cap phy_cap;
+	struct sci_phy_cap phy_cap;
 	u32 parity_check = 0;
 	u32 parity_count = 0;
 	u32 llctl, link_rate;
 	u32 clksm_value = 0;
 
-	iphy->link_layer_registers = link_layer_registers;
+	iphy->link_layer_registers = reg;
 
 	/* Set our IDENTIFY frame data */
 	#define SCI_END_DEVICE 0x01
@@ -169,7 +148,7 @@ scic_sds_phy_link_layer_initialization(struct isci_phy *iphy,
 	phy_cap.gen3_no_ssc = 1;
 	phy_cap.gen2_no_ssc = 1;
 	phy_cap.gen1_no_ssc = 1;
-	if (ihost->oem_parameters.sds1.controller.do_enable_ssc == true) {
+	if (ihost->oem_parameters.controller.do_enable_ssc == true) {
 		phy_cap.gen3_ssc = 1;
 		phy_cap.gen2_ssc = 1;
 		phy_cap.gen1_ssc = 1;
@@ -216,7 +195,7 @@ scic_sds_phy_link_layer_initialization(struct isci_phy *iphy,
 		&iphy->link_layer_registers->afe_lookup_table_control);
 
 	llctl = SCU_SAS_LLCTL_GEN_VAL(NO_OUTBOUND_TASK_TIMEOUT,
-		(u8)ihost->user_parameters.sds1.no_outbound_task_timeout);
+		(u8)ihost->user_parameters.no_outbound_task_timeout);
 
 	switch(phy_user->max_speed_generation) {
 	case SCIC_SDS_PARM_GEN3_SPEED:
@@ -289,7 +268,7 @@ static void phy_sata_timeout(unsigned long data)
 struct isci_port *phy_get_non_dummy_port(
 	struct isci_phy *iphy)
 {
-	if (scic_sds_port_get_index(iphy->owning_port) == SCIC_SDS_DUMMY_PORT)
+	if (sci_port_get_index(iphy->owning_port) == SCIC_SDS_DUMMY_PORT)
 		return NULL;
 
 	return iphy->owning_port;
@@ -302,7 +281,7 @@ struct isci_port *phy_get_non_dummy_port(
  *
  *
  */
-void scic_sds_phy_set_port(
+void sci_phy_set_port(
 	struct isci_phy *iphy,
 	struct isci_port *iport)
 {
@@ -310,33 +289,23 @@ void scic_sds_phy_set_port(
 
 	if (iphy->bcn_received_while_port_unassigned) {
 		iphy->bcn_received_while_port_unassigned = false;
-		scic_sds_port_broadcast_change_received(iphy->owning_port, iphy);
+		sci_port_broadcast_change_received(iphy->owning_port, iphy);
 	}
 }
 
-/**
- * This method will initialize the constructed phy
- * @sci_phy:
- * @link_layer_registers:
- *
- * enum sci_status
- */
-enum sci_status scic_sds_phy_initialize(
-	struct isci_phy *iphy,
-	struct scu_transport_layer_registers __iomem *transport_layer_registers,
-	struct scu_link_layer_registers __iomem *link_layer_registers)
+enum sci_status sci_phy_initialize(struct isci_phy *iphy,
+				   struct scu_transport_layer_registers __iomem *tl,
+				   struct scu_link_layer_registers __iomem *ll)
 {
 	/* Perfrom the initialization of the TL hardware */
-	scic_sds_phy_transport_layer_initialization(
-			iphy,
-			transport_layer_registers);
+	sci_phy_transport_layer_initialization(iphy, tl);
 
 	/* Perofrm the initialization of the PE hardware */
-	scic_sds_phy_link_layer_initialization(iphy, link_layer_registers);
+	sci_phy_link_layer_initialization(iphy, ll);
 
-	/*
-	 * There is nothing that needs to be done in this state just
-	 * transition to the stopped state. */
+	/* There is nothing that needs to be done in this state just
+	 * transition to the stopped state
+	 */
 	sci_change_state(&iphy->sm, SCI_PHY_STOPPED);
 
 	return SCI_SUCCESS;
@@ -351,9 +320,7 @@ enum sci_status scic_sds_phy_initialize(
  *       This will either be the RNi for the device or an invalid RNi if there
  *       is no current device assigned to the phy.
  */
-void scic_sds_phy_setup_transport(
-	struct isci_phy *iphy,
-	u32 device_id)
+void sci_phy_setup_transport(struct isci_phy *iphy, u32 device_id)
 {
 	u32 tl_control;
 
@@ -368,15 +335,7 @@ void scic_sds_phy_setup_transport(
 	writel(tl_control, &iphy->transport_layer_registers->control);
 }
 
-/**
- *
- * @sci_phy: The phy object to be suspended.
- *
- * This function will perform the register reads/writes to suspend the SCU
- * hardware protocol engine. none
- */
-static void scic_sds_phy_suspend(
-	struct isci_phy *iphy)
+static void sci_phy_suspend(struct isci_phy *iphy)
 {
 	u32 scu_sas_pcfg_value;
 
@@ -386,12 +345,10 @@ static void scic_sds_phy_suspend(
 	writel(scu_sas_pcfg_value,
 		&iphy->link_layer_registers->phy_configuration);
 
-	scic_sds_phy_setup_transport(
-			iphy,
-			SCIC_SDS_REMOTE_NODE_CONTEXT_INVALID_INDEX);
+	sci_phy_setup_transport(iphy, SCIC_SDS_REMOTE_NODE_CONTEXT_INVALID_INDEX);
 }
 
-void scic_sds_phy_resume(struct isci_phy *iphy)
+void sci_phy_resume(struct isci_phy *iphy)
 {
 	u32 scu_sas_pcfg_value;
 
@@ -402,34 +359,28 @@ void scic_sds_phy_resume(struct isci_phy *iphy)
 		&iphy->link_layer_registers->phy_configuration);
 }
 
-void scic_sds_phy_get_sas_address(struct isci_phy *iphy,
-				  struct sci_sas_address *sas_address)
+void sci_phy_get_sas_address(struct isci_phy *iphy, struct sci_sas_address *sas)
 {
-	sas_address->high = readl(&iphy->link_layer_registers->source_sas_address_high);
-	sas_address->low = readl(&iphy->link_layer_registers->source_sas_address_low);
+	sas->high = readl(&iphy->link_layer_registers->source_sas_address_high);
+	sas->low = readl(&iphy->link_layer_registers->source_sas_address_low);
 }
 
-void scic_sds_phy_get_attached_sas_address(struct isci_phy *iphy,
-					   struct sci_sas_address *sas_address)
+void sci_phy_get_attached_sas_address(struct isci_phy *iphy, struct sci_sas_address *sas)
 {
 	struct sas_identify_frame *iaf;
 
 	iaf = &iphy->frame_rcvd.iaf;
-	memcpy(sas_address, iaf->sas_addr, SAS_ADDR_SIZE);
+	memcpy(sas, iaf->sas_addr, SAS_ADDR_SIZE);
 }
 
-void scic_sds_phy_get_protocols(struct isci_phy *iphy,
-				struct scic_phy_proto *protocols)
+void sci_phy_get_protocols(struct isci_phy *iphy, struct sci_phy_proto *proto)
 {
-	protocols->all =
-		(u16)(readl(&iphy->
-			link_layer_registers->transmit_identification) &
-				0x0000FFFF);
+	proto->all = readl(&iphy->link_layer_registers->transmit_identification);
 }
 
-enum sci_status scic_sds_phy_start(struct isci_phy *iphy)
+enum sci_status sci_phy_start(struct isci_phy *iphy)
 {
-	enum scic_sds_phy_states state = iphy->sm.current_state_id;
+	enum sci_phy_states state = iphy->sm.current_state_id;
 
 	if (state != SCI_PHY_STOPPED) {
 		dev_dbg(sciphy_to_dev(iphy),
@@ -441,9 +392,9 @@ enum sci_status scic_sds_phy_start(struct isci_phy *iphy)
 	return SCI_SUCCESS;
 }
 
-enum sci_status scic_sds_phy_stop(struct isci_phy *iphy)
+enum sci_status sci_phy_stop(struct isci_phy *iphy)
 {
-	enum scic_sds_phy_states state = iphy->sm.current_state_id;
+	enum sci_phy_states state = iphy->sm.current_state_id;
 
 	switch (state) {
 	case SCI_PHY_SUB_INITIAL:
@@ -467,9 +418,9 @@ enum sci_status scic_sds_phy_stop(struct isci_phy *iphy)
 	return SCI_SUCCESS;
 }
 
-enum sci_status scic_sds_phy_reset(struct isci_phy *iphy)
+enum sci_status sci_phy_reset(struct isci_phy *iphy)
 {
-	enum scic_sds_phy_states state = iphy->sm.current_state_id;
+	enum sci_phy_states state = iphy->sm.current_state_id;
 
 	if (state != SCI_PHY_READY) {
 		dev_dbg(sciphy_to_dev(iphy),
@@ -481,9 +432,9 @@ enum sci_status scic_sds_phy_reset(struct isci_phy *iphy)
 	return SCI_SUCCESS;
 }
 
-enum sci_status scic_sds_phy_consume_power_handler(struct isci_phy *iphy)
+enum sci_status sci_phy_consume_power_handler(struct isci_phy *iphy)
 {
-	enum scic_sds_phy_states state = iphy->sm.current_state_id;
+	enum sci_phy_states state = iphy->sm.current_state_id;
 
 	switch (state) {
 	case SCI_PHY_SUB_AWAIT_SAS_POWER: {
@@ -528,55 +479,37 @@ enum sci_status scic_sds_phy_consume_power_handler(struct isci_phy *iphy)
 	}
 }
 
-/*
- * *****************************************************************************
- * * SCIC SDS PHY HELPER FUNCTIONS
- * ***************************************************************************** */
-
-
-/**
- *
- * @sci_phy: The phy object that received SAS PHY DETECTED.
- *
- * This method continues the link training for the phy as if it were a SAS PHY
- * instead of a SATA PHY. This is done because the completion queue had a SAS
- * PHY DETECTED event when the state machine was expecting a SATA PHY event.
- * none
- */
-static void scic_sds_phy_start_sas_link_training(
-	struct isci_phy *iphy)
+static void sci_phy_start_sas_link_training(struct isci_phy *iphy)
 {
+	/* continue the link training for the phy as if it were a SAS PHY
+	 * instead of a SATA PHY. This is done because the completion queue had a SAS
+	 * PHY DETECTED event when the state machine was expecting a SATA PHY event.
+	 */
 	u32 phy_control;
 
-	phy_control =
-		readl(&iphy->link_layer_registers->phy_configuration);
+	phy_control = readl(&iphy->link_layer_registers->phy_configuration);
 	phy_control |= SCU_SAS_PCFG_GEN_BIT(SATA_SPINUP_HOLD);
 	writel(phy_control,
-		&iphy->link_layer_registers->phy_configuration);
+	       &iphy->link_layer_registers->phy_configuration);
 
 	sci_change_state(&iphy->sm, SCI_PHY_SUB_AWAIT_SAS_SPEED_EN);
 
 	iphy->protocol = SCIC_SDS_PHY_PROTOCOL_SAS;
 }
 
-/**
- *
- * @sci_phy: The phy object that received a SATA SPINUP HOLD event
- *
- * This method continues the link training for the phy as if it were a SATA PHY
- * instead of a SAS PHY.  This is done because the completion queue had a SATA
- * SPINUP HOLD event when the state machine was expecting a SAS PHY event. none
- */
-static void scic_sds_phy_start_sata_link_training(
-	struct isci_phy *iphy)
+static void sci_phy_start_sata_link_training(struct isci_phy *iphy)
 {
+	/* This method continues the link training for the phy as if it were a SATA PHY
+	 * instead of a SAS PHY.  This is done because the completion queue had a SATA
+	 * SPINUP HOLD event when the state machine was expecting a SAS PHY event. none
+	 */
 	sci_change_state(&iphy->sm, SCI_PHY_SUB_AWAIT_SATA_POWER);
 
 	iphy->protocol = SCIC_SDS_PHY_PROTOCOL_SATA;
 }
 
 /**
- * scic_sds_phy_complete_link_training - perform processing common to
+ * sci_phy_complete_link_training - perform processing common to
  *    all protocols upon completion of link training.
  * @sci_phy: This parameter specifies the phy object for which link training
  *    has completed.
@@ -586,30 +519,28 @@ static void scic_sds_phy_start_sata_link_training(
  *    sub-state machine.
  *
  */
-static void scic_sds_phy_complete_link_training(
-	struct isci_phy *iphy,
-	enum sas_linkrate max_link_rate,
-	u32 next_state)
+static void sci_phy_complete_link_training(struct isci_phy *iphy,
+					   enum sas_linkrate max_link_rate,
+					   u32 next_state)
 {
 	iphy->max_negotiated_speed = max_link_rate;
 
 	sci_change_state(&iphy->sm, next_state);
 }
 
-enum sci_status scic_sds_phy_event_handler(struct isci_phy *iphy,
-					   u32 event_code)
+enum sci_status sci_phy_event_handler(struct isci_phy *iphy, u32 event_code)
 {
-	enum scic_sds_phy_states state = iphy->sm.current_state_id;
+	enum sci_phy_states state = iphy->sm.current_state_id;
 
 	switch (state) {
 	case SCI_PHY_SUB_AWAIT_OSSP_EN:
 		switch (scu_get_event_code(event_code)) {
 		case SCU_EVENT_SAS_PHY_DETECTED:
-			scic_sds_phy_start_sas_link_training(iphy);
+			sci_phy_start_sas_link_training(iphy);
 			iphy->is_in_link_training = true;
 			break;
 		case SCU_EVENT_SATA_SPINUP_HOLD:
-			scic_sds_phy_start_sata_link_training(iphy);
+			sci_phy_start_sata_link_training(iphy);
 			iphy->is_in_link_training = true;
 			break;
 		default:
@@ -630,30 +561,24 @@ enum sci_status scic_sds_phy_event_handler(struct isci_phy *iphy,
 			break;
 		case SCU_EVENT_SAS_15:
 		case SCU_EVENT_SAS_15_SSC:
-			scic_sds_phy_complete_link_training(
-				iphy,
-				SAS_LINK_RATE_1_5_GBPS,
-				SCI_PHY_SUB_AWAIT_IAF_UF);
+			sci_phy_complete_link_training(iphy, SAS_LINK_RATE_1_5_GBPS,
+						       SCI_PHY_SUB_AWAIT_IAF_UF);
 			break;
 		case SCU_EVENT_SAS_30:
 		case SCU_EVENT_SAS_30_SSC:
-			scic_sds_phy_complete_link_training(
-				iphy,
-				SAS_LINK_RATE_3_0_GBPS,
-				SCI_PHY_SUB_AWAIT_IAF_UF);
+			sci_phy_complete_link_training(iphy, SAS_LINK_RATE_3_0_GBPS,
+						       SCI_PHY_SUB_AWAIT_IAF_UF);
 			break;
 		case SCU_EVENT_SAS_60:
 		case SCU_EVENT_SAS_60_SSC:
-			scic_sds_phy_complete_link_training(
-				iphy,
-				SAS_LINK_RATE_6_0_GBPS,
-				SCI_PHY_SUB_AWAIT_IAF_UF);
+			sci_phy_complete_link_training(iphy, SAS_LINK_RATE_6_0_GBPS,
+						       SCI_PHY_SUB_AWAIT_IAF_UF);
 			break;
 		case SCU_EVENT_SATA_SPINUP_HOLD:
 			/*
 			 * We were doing SAS PHY link training and received a SATA PHY event
 			 * continue OOB/SN as if this were a SATA PHY */
-			scic_sds_phy_start_sata_link_training(iphy);
+			sci_phy_start_sata_link_training(iphy);
 			break;
 		case SCU_EVENT_LINK_FAILURE:
 			/* Link failure change state back to the starting state */
@@ -673,14 +598,14 @@ enum sci_status scic_sds_phy_event_handler(struct isci_phy *iphy,
 		switch (scu_get_event_code(event_code)) {
 		case SCU_EVENT_SAS_PHY_DETECTED:
 			/* Backup the state machine */
-			scic_sds_phy_start_sas_link_training(iphy);
+			sci_phy_start_sas_link_training(iphy);
 			break;
 		case SCU_EVENT_SATA_SPINUP_HOLD:
 			/* We were doing SAS PHY link training and received a
 			 * SATA PHY event continue OOB/SN as if this were a
 			 * SATA PHY
 			 */
-			scic_sds_phy_start_sata_link_training(iphy);
+			sci_phy_start_sata_link_training(iphy);
 			break;
 		case SCU_EVENT_RECEIVED_IDENTIFY_TIMEOUT:
 		case SCU_EVENT_LINK_FAILURE:
@@ -727,7 +652,7 @@ enum sci_status scic_sds_phy_event_handler(struct isci_phy *iphy,
 			/* There has been a change in the phy type before OOB/SN for the
 			 * SATA finished start down the SAS link traning path.
 			 */
-			scic_sds_phy_start_sas_link_training(iphy);
+			sci_phy_start_sas_link_training(iphy);
 			break;
 
 		default:
@@ -760,7 +685,7 @@ enum sci_status scic_sds_phy_event_handler(struct isci_phy *iphy,
 			/* There has been a change in the phy type before OOB/SN for the
 			 * SATA finished start down the SAS link traning path.
 			 */
-			scic_sds_phy_start_sas_link_training(iphy);
+			sci_phy_start_sas_link_training(iphy);
 			break;
 		default:
 			dev_warn(sciphy_to_dev(iphy),
@@ -781,24 +706,18 @@ enum sci_status scic_sds_phy_event_handler(struct isci_phy *iphy,
 			break;
 		case SCU_EVENT_SATA_15:
 		case SCU_EVENT_SATA_15_SSC:
-			scic_sds_phy_complete_link_training(
-				iphy,
-				SAS_LINK_RATE_1_5_GBPS,
-				SCI_PHY_SUB_AWAIT_SIG_FIS_UF);
+			sci_phy_complete_link_training(iphy, SAS_LINK_RATE_1_5_GBPS,
+						       SCI_PHY_SUB_AWAIT_SIG_FIS_UF);
 			break;
 		case SCU_EVENT_SATA_30:
 		case SCU_EVENT_SATA_30_SSC:
-			scic_sds_phy_complete_link_training(
-				iphy,
-				SAS_LINK_RATE_3_0_GBPS,
-				SCI_PHY_SUB_AWAIT_SIG_FIS_UF);
+			sci_phy_complete_link_training(iphy, SAS_LINK_RATE_3_0_GBPS,
+						       SCI_PHY_SUB_AWAIT_SIG_FIS_UF);
 			break;
 		case SCU_EVENT_SATA_60:
 		case SCU_EVENT_SATA_60_SSC:
-			scic_sds_phy_complete_link_training(
-				iphy,
-				SAS_LINK_RATE_6_0_GBPS,
-				SCI_PHY_SUB_AWAIT_SIG_FIS_UF);
+			sci_phy_complete_link_training(iphy, SAS_LINK_RATE_6_0_GBPS,
+						       SCI_PHY_SUB_AWAIT_SIG_FIS_UF);
 			break;
 		case SCU_EVENT_LINK_FAILURE:
 			/* Link failure change state back to the starting state */
@@ -808,7 +727,7 @@ enum sci_status scic_sds_phy_event_handler(struct isci_phy *iphy,
 			/*
 			 * There has been a change in the phy type before OOB/SN for the
 			 * SATA finished start down the SAS link traning path. */
-			scic_sds_phy_start_sas_link_training(iphy);
+			sci_phy_start_sas_link_training(iphy);
 			break;
 		default:
 			dev_warn(sciphy_to_dev(iphy),
@@ -851,7 +770,7 @@ enum sci_status scic_sds_phy_event_handler(struct isci_phy *iphy,
 		case SCU_EVENT_BROADCAST_CHANGE:
 			/* Broadcast change received. Notify the port. */
 			if (phy_get_non_dummy_port(iphy) != NULL)
-				scic_sds_port_broadcast_change_received(iphy->owning_port, iphy);
+				sci_port_broadcast_change_received(iphy->owning_port, iphy);
 			else
 				iphy->bcn_received_while_port_unassigned = true;
 			break;
@@ -886,10 +805,9 @@ enum sci_status scic_sds_phy_event_handler(struct isci_phy *iphy,
 	}
 }
 
-enum sci_status scic_sds_phy_frame_handler(struct isci_phy *iphy,
-					   u32 frame_index)
+enum sci_status sci_phy_frame_handler(struct isci_phy *iphy, u32 frame_index)
 {
-	enum scic_sds_phy_states state = iphy->sm.current_state_id;
+	enum sci_phy_states state = iphy->sm.current_state_id;
 	struct isci_host *ihost = iphy->owning_port->owning_controller;
 	enum sci_status result;
 	unsigned long flags;
@@ -899,9 +817,9 @@ enum sci_status scic_sds_phy_frame_handler(struct isci_phy *iphy,
 		u32 *frame_words;
 		struct sas_identify_frame iaf;
 
-		result = scic_sds_unsolicited_frame_control_get_header(&ihost->uf_control,
-								       frame_index,
-								       (void **)&frame_words);
+		result = sci_unsolicited_frame_control_get_header(&ihost->uf_control,
+								  frame_index,
+								  (void **)&frame_words);
 
 		if (result != SCI_SUCCESS)
 			return result;
@@ -933,15 +851,15 @@ enum sci_status scic_sds_phy_frame_handler(struct isci_phy *iphy,
 				"unexpected frame id %x\n",
 				__func__, frame_index);
 
-		scic_sds_controller_release_frame(ihost, frame_index);
+		sci_controller_release_frame(ihost, frame_index);
 		return result;
 	}
 	case SCI_PHY_SUB_AWAIT_SIG_FIS_UF: {
 		struct dev_to_host_fis *frame_header;
 		u32 *fis_frame_data;
 
-		result = scic_sds_unsolicited_frame_control_get_header(
-			&(scic_sds_phy_get_controller(iphy)->uf_control),
+		result = sci_unsolicited_frame_control_get_header(
+			&(sci_phy_get_controller(iphy)->uf_control),
 			frame_index,
 			(void **)&frame_header);
 
@@ -950,14 +868,14 @@ enum sci_status scic_sds_phy_frame_handler(struct isci_phy *iphy,
 
 		if ((frame_header->fis_type == FIS_REGD2H) &&
 		    !(frame_header->status & ATA_BUSY)) {
-			scic_sds_unsolicited_frame_control_get_buffer(&ihost->uf_control,
-								      frame_index,
-								      (void **)&fis_frame_data);
+			sci_unsolicited_frame_control_get_buffer(&ihost->uf_control,
+								 frame_index,
+								 (void **)&fis_frame_data);
 
 			spin_lock_irqsave(&iphy->sas_phy.frame_rcvd_lock, flags);
-			scic_sds_controller_copy_sata_response(&iphy->frame_rcvd.fis,
-							       frame_header,
-							       fis_frame_data);
+			sci_controller_copy_sata_response(&iphy->frame_rcvd.fis,
+							  frame_header,
+							  fis_frame_data);
 			spin_unlock_irqrestore(&iphy->sas_phy.frame_rcvd_lock, flags);
 
 			/* got IAF we can now go to the await spinup semaphore state */
@@ -971,7 +889,7 @@ enum sci_status scic_sds_phy_frame_handler(struct isci_phy *iphy,
 				 __func__, frame_index);
 
 		/* Regardless of the result we are done with this frame with it */
-		scic_sds_controller_release_frame(ihost, frame_index);
+		sci_controller_release_frame(ihost, frame_index);
 
 		return result;
 	}
@@ -983,7 +901,7 @@ enum sci_status scic_sds_phy_frame_handler(struct isci_phy *iphy,
 
 }
 
-static void scic_sds_phy_starting_initial_substate_enter(struct sci_base_state_machine *sm)
+static void sci_phy_starting_initial_substate_enter(struct sci_base_state_machine *sm)
 {
 	struct isci_phy *iphy = container_of(sm, typeof(*iphy), sm);
 
@@ -991,71 +909,71 @@ static void scic_sds_phy_starting_initial_substate_enter(struct sci_base_state_m
 	sci_change_state(&iphy->sm, SCI_PHY_SUB_AWAIT_OSSP_EN);
 }
 
-static void scic_sds_phy_starting_await_sas_power_substate_enter(struct sci_base_state_machine *sm)
+static void sci_phy_starting_await_sas_power_substate_enter(struct sci_base_state_machine *sm)
 {
 	struct isci_phy *iphy = container_of(sm, typeof(*iphy), sm);
 	struct isci_host *ihost = iphy->owning_port->owning_controller;
 
-	scic_sds_controller_power_control_queue_insert(ihost, iphy);
+	sci_controller_power_control_queue_insert(ihost, iphy);
 }
 
-static void scic_sds_phy_starting_await_sas_power_substate_exit(struct sci_base_state_machine *sm)
+static void sci_phy_starting_await_sas_power_substate_exit(struct sci_base_state_machine *sm)
 {
 	struct isci_phy *iphy = container_of(sm, typeof(*iphy), sm);
 	struct isci_host *ihost = iphy->owning_port->owning_controller;
 
-	scic_sds_controller_power_control_queue_remove(ihost, iphy);
+	sci_controller_power_control_queue_remove(ihost, iphy);
 }
 
-static void scic_sds_phy_starting_await_sata_power_substate_enter(struct sci_base_state_machine *sm)
+static void sci_phy_starting_await_sata_power_substate_enter(struct sci_base_state_machine *sm)
 {
 	struct isci_phy *iphy = container_of(sm, typeof(*iphy), sm);
 	struct isci_host *ihost = iphy->owning_port->owning_controller;
 
-	scic_sds_controller_power_control_queue_insert(ihost, iphy);
+	sci_controller_power_control_queue_insert(ihost, iphy);
 }
 
-static void scic_sds_phy_starting_await_sata_power_substate_exit(struct sci_base_state_machine *sm)
+static void sci_phy_starting_await_sata_power_substate_exit(struct sci_base_state_machine *sm)
 {
 	struct isci_phy *iphy = container_of(sm, typeof(*iphy), sm);
 	struct isci_host *ihost = iphy->owning_port->owning_controller;
 
-	scic_sds_controller_power_control_queue_remove(ihost, iphy);
+	sci_controller_power_control_queue_remove(ihost, iphy);
 }
 
-static void scic_sds_phy_starting_await_sata_phy_substate_enter(struct sci_base_state_machine *sm)
+static void sci_phy_starting_await_sata_phy_substate_enter(struct sci_base_state_machine *sm)
 {
 	struct isci_phy *iphy = container_of(sm, typeof(*iphy), sm);
 
 	sci_mod_timer(&iphy->sata_timer, SCIC_SDS_SATA_LINK_TRAINING_TIMEOUT);
 }
 
-static void scic_sds_phy_starting_await_sata_phy_substate_exit(struct sci_base_state_machine *sm)
+static void sci_phy_starting_await_sata_phy_substate_exit(struct sci_base_state_machine *sm)
 {
 	struct isci_phy *iphy = container_of(sm, typeof(*iphy), sm);
 
 	sci_del_timer(&iphy->sata_timer);
 }
 
-static void scic_sds_phy_starting_await_sata_speed_substate_enter(struct sci_base_state_machine *sm)
+static void sci_phy_starting_await_sata_speed_substate_enter(struct sci_base_state_machine *sm)
 {
 	struct isci_phy *iphy = container_of(sm, typeof(*iphy), sm);
 
 	sci_mod_timer(&iphy->sata_timer, SCIC_SDS_SATA_LINK_TRAINING_TIMEOUT);
 }
 
-static void scic_sds_phy_starting_await_sata_speed_substate_exit(struct sci_base_state_machine *sm)
+static void sci_phy_starting_await_sata_speed_substate_exit(struct sci_base_state_machine *sm)
 {
 	struct isci_phy *iphy = container_of(sm, typeof(*iphy), sm);
 
 	sci_del_timer(&iphy->sata_timer);
 }
 
-static void scic_sds_phy_starting_await_sig_fis_uf_substate_enter(struct sci_base_state_machine *sm)
+static void sci_phy_starting_await_sig_fis_uf_substate_enter(struct sci_base_state_machine *sm)
 {
 	struct isci_phy *iphy = container_of(sm, typeof(*iphy), sm);
 
-	if (scic_sds_port_link_detected(iphy->owning_port, iphy)) {
+	if (sci_port_link_detected(iphy->owning_port, iphy)) {
 
 		/*
 		 * Clear the PE suspend condition so we can actually
@@ -1063,7 +981,7 @@ static void scic_sds_phy_starting_await_sig_fis_uf_substate_enter(struct sci_bas
 		 * The hardware will not respond to the XRDY until the PE
 		 * suspend condition is cleared.
 		 */
-		scic_sds_phy_resume(iphy);
+		sci_phy_resume(iphy);
 
 		sci_mod_timer(&iphy->sata_timer,
 			      SCIC_SDS_SIGNATURE_FIS_TIMEOUT);
@@ -1071,14 +989,14 @@ static void scic_sds_phy_starting_await_sig_fis_uf_substate_enter(struct sci_bas
 		iphy->is_in_link_training = false;
 }
 
-static void scic_sds_phy_starting_await_sig_fis_uf_substate_exit(struct sci_base_state_machine *sm)
+static void sci_phy_starting_await_sig_fis_uf_substate_exit(struct sci_base_state_machine *sm)
 {
 	struct isci_phy *iphy = container_of(sm, typeof(*iphy), sm);
 
 	sci_del_timer(&iphy->sata_timer);
 }
 
-static void scic_sds_phy_starting_final_substate_enter(struct sci_base_state_machine *sm)
+static void sci_phy_starting_final_substate_enter(struct sci_base_state_machine *sm)
 {
 	struct isci_phy *iphy = container_of(sm, typeof(*iphy), sm);
 
@@ -1169,7 +1087,7 @@ static void scu_link_layer_tx_hard_reset(
 	       &iphy->link_layer_registers->phy_configuration);
 }
 
-static void scic_sds_phy_stopped_state_enter(struct sci_base_state_machine *sm)
+static void sci_phy_stopped_state_enter(struct sci_base_state_machine *sm)
 {
 	struct isci_phy *iphy = container_of(sm, typeof(*iphy), sm);
 
@@ -1182,12 +1100,12 @@ static void scic_sds_phy_stopped_state_enter(struct sci_base_state_machine *sm)
 	scu_link_layer_stop_protocol_engine(iphy);
 
 	if (iphy->sm.previous_state_id != SCI_PHY_INITIAL)
-		scic_sds_controller_link_down(scic_sds_phy_get_controller(iphy),
+		sci_controller_link_down(sci_phy_get_controller(iphy),
 					      phy_get_non_dummy_port(iphy),
 					      iphy);
 }
 
-static void scic_sds_phy_starting_state_enter(struct sci_base_state_machine *sm)
+static void sci_phy_starting_state_enter(struct sci_base_state_machine *sm)
 {
 	struct isci_phy *iphy = container_of(sm, typeof(*iphy), sm);
 
@@ -1199,31 +1117,31 @@ static void scic_sds_phy_starting_state_enter(struct sci_base_state_machine *sm)
 	iphy->bcn_received_while_port_unassigned = false;
 
 	if (iphy->sm.previous_state_id == SCI_PHY_READY)
-		scic_sds_controller_link_down(scic_sds_phy_get_controller(iphy),
+		sci_controller_link_down(sci_phy_get_controller(iphy),
 					      phy_get_non_dummy_port(iphy),
 					      iphy);
 
 	sci_change_state(&iphy->sm, SCI_PHY_SUB_INITIAL);
 }
 
-static void scic_sds_phy_ready_state_enter(struct sci_base_state_machine *sm)
+static void sci_phy_ready_state_enter(struct sci_base_state_machine *sm)
 {
 	struct isci_phy *iphy = container_of(sm, typeof(*iphy), sm);
 
-	scic_sds_controller_link_up(scic_sds_phy_get_controller(iphy),
+	sci_controller_link_up(sci_phy_get_controller(iphy),
 				    phy_get_non_dummy_port(iphy),
 				    iphy);
 
 }
 
-static void scic_sds_phy_ready_state_exit(struct sci_base_state_machine *sm)
+static void sci_phy_ready_state_exit(struct sci_base_state_machine *sm)
 {
 	struct isci_phy *iphy = container_of(sm, typeof(*iphy), sm);
 
-	scic_sds_phy_suspend(iphy);
+	sci_phy_suspend(iphy);
 }
 
-static void scic_sds_phy_resetting_state_enter(struct sci_base_state_machine *sm)
+static void sci_phy_resetting_state_enter(struct sci_base_state_machine *sm)
 {
 	struct isci_phy *iphy = container_of(sm, typeof(*iphy), sm);
 
@@ -1231,7 +1149,7 @@ static void scic_sds_phy_resetting_state_enter(struct sci_base_state_machine *sm
 	 * the resetting state we don't notify the user regarding link up and
 	 * link down notifications
 	 */
-	scic_sds_port_deactivate_phy(iphy->owning_port, iphy, false);
+	sci_port_deactivate_phy(iphy->owning_port, iphy, false);
 
 	if (iphy->protocol == SCIC_SDS_PHY_PROTOCOL_SAS) {
 		scu_link_layer_tx_hard_reset(iphy);
@@ -1243,57 +1161,57 @@ static void scic_sds_phy_resetting_state_enter(struct sci_base_state_machine *sm
 	}
 }
 
-static const struct sci_base_state scic_sds_phy_state_table[] = {
+static const struct sci_base_state sci_phy_state_table[] = {
 	[SCI_PHY_INITIAL] = { },
 	[SCI_PHY_STOPPED] = {
-		.enter_state = scic_sds_phy_stopped_state_enter,
+		.enter_state = sci_phy_stopped_state_enter,
 	},
 	[SCI_PHY_STARTING] = {
-		.enter_state = scic_sds_phy_starting_state_enter,
+		.enter_state = sci_phy_starting_state_enter,
 	},
 	[SCI_PHY_SUB_INITIAL] = {
-		.enter_state = scic_sds_phy_starting_initial_substate_enter,
+		.enter_state = sci_phy_starting_initial_substate_enter,
 	},
 	[SCI_PHY_SUB_AWAIT_OSSP_EN] = { },
 	[SCI_PHY_SUB_AWAIT_SAS_SPEED_EN] = { },
 	[SCI_PHY_SUB_AWAIT_IAF_UF] = { },
 	[SCI_PHY_SUB_AWAIT_SAS_POWER] = {
-		.enter_state = scic_sds_phy_starting_await_sas_power_substate_enter,
-		.exit_state  = scic_sds_phy_starting_await_sas_power_substate_exit,
+		.enter_state = sci_phy_starting_await_sas_power_substate_enter,
+		.exit_state  = sci_phy_starting_await_sas_power_substate_exit,
 	},
 	[SCI_PHY_SUB_AWAIT_SATA_POWER] = {
-		.enter_state = scic_sds_phy_starting_await_sata_power_substate_enter,
-		.exit_state  = scic_sds_phy_starting_await_sata_power_substate_exit
+		.enter_state = sci_phy_starting_await_sata_power_substate_enter,
+		.exit_state  = sci_phy_starting_await_sata_power_substate_exit
 	},
 	[SCI_PHY_SUB_AWAIT_SATA_PHY_EN] = {
-		.enter_state = scic_sds_phy_starting_await_sata_phy_substate_enter,
-		.exit_state  = scic_sds_phy_starting_await_sata_phy_substate_exit
+		.enter_state = sci_phy_starting_await_sata_phy_substate_enter,
+		.exit_state  = sci_phy_starting_await_sata_phy_substate_exit
 	},
 	[SCI_PHY_SUB_AWAIT_SATA_SPEED_EN] = {
-		.enter_state = scic_sds_phy_starting_await_sata_speed_substate_enter,
-		.exit_state  = scic_sds_phy_starting_await_sata_speed_substate_exit
+		.enter_state = sci_phy_starting_await_sata_speed_substate_enter,
+		.exit_state  = sci_phy_starting_await_sata_speed_substate_exit
 	},
 	[SCI_PHY_SUB_AWAIT_SIG_FIS_UF] = {
-		.enter_state = scic_sds_phy_starting_await_sig_fis_uf_substate_enter,
-		.exit_state  = scic_sds_phy_starting_await_sig_fis_uf_substate_exit
+		.enter_state = sci_phy_starting_await_sig_fis_uf_substate_enter,
+		.exit_state  = sci_phy_starting_await_sig_fis_uf_substate_exit
 	},
 	[SCI_PHY_SUB_FINAL] = {
-		.enter_state = scic_sds_phy_starting_final_substate_enter,
+		.enter_state = sci_phy_starting_final_substate_enter,
 	},
 	[SCI_PHY_READY] = {
-		.enter_state = scic_sds_phy_ready_state_enter,
-		.exit_state = scic_sds_phy_ready_state_exit,
+		.enter_state = sci_phy_ready_state_enter,
+		.exit_state = sci_phy_ready_state_exit,
 	},
 	[SCI_PHY_RESETTING] = {
-		.enter_state = scic_sds_phy_resetting_state_enter,
+		.enter_state = sci_phy_resetting_state_enter,
 	},
 	[SCI_PHY_FINAL] = { },
 };
 
-void scic_sds_phy_construct(struct isci_phy *iphy,
+void sci_phy_construct(struct isci_phy *iphy,
 			    struct isci_port *iport, u8 phy_index)
 {
-	sci_init_sm(&iphy->sm, scic_sds_phy_state_table, SCI_PHY_INITIAL);
+	sci_init_sm(&iphy->sm, sci_phy_state_table, SCI_PHY_INITIAL);
 
 	/* Copy the rest of the input data to our locals */
 	iphy->owning_port = iport;
@@ -1309,14 +1227,13 @@ void scic_sds_phy_construct(struct isci_phy *iphy,
 
 void isci_phy_init(struct isci_phy *iphy, struct isci_host *ihost, int index)
 {
-	union scic_oem_parameters oem;
+	struct sci_oem_params *oem = &ihost->oem_parameters;
 	u64 sci_sas_addr;
 	__be64 sas_addr;
 
-	scic_oem_parameters_get(ihost, &oem);
-	sci_sas_addr = oem.sds1.phys[index].sas_address.high;
+	sci_sas_addr = oem->phys[index].sas_address.high;
 	sci_sas_addr <<= 32;
-	sci_sas_addr |= oem.sds1.phys[index].sas_address.low;
+	sci_sas_addr |= oem->phys[index].sas_address.low;
 	sas_addr = cpu_to_be64(sci_sas_addr);
 	memcpy(iphy->sas_addr, &sas_addr, sizeof(sas_addr));
 
@@ -1365,14 +1282,14 @@ int isci_phy_control(struct asd_sas_phy *sas_phy,
 	switch (func) {
 	case PHY_FUNC_DISABLE:
 		spin_lock_irqsave(&ihost->scic_lock, flags);
-		scic_sds_phy_stop(iphy);
+		sci_phy_stop(iphy);
 		spin_unlock_irqrestore(&ihost->scic_lock, flags);
 		break;
 
 	case PHY_FUNC_LINK_RESET:
 		spin_lock_irqsave(&ihost->scic_lock, flags);
-		scic_sds_phy_stop(iphy);
-		scic_sds_phy_start(iphy);
+		sci_phy_stop(iphy);
+		sci_phy_start(iphy);
 		spin_unlock_irqrestore(&ihost->scic_lock, flags);
 		break;
 

commit d9dcb4ba791de2a06b19ac47cd61601cf3d4e208
Author: Dan Williams <dan.j.williams@intel.com>
Date:   Thu Jun 30 17:38:32 2011 -0700

    isci: unify isci_host and scic_sds_controller
    
    Remove the distinction between these two implementations and unify on
    isci_host (local instances named ihost).  Hmmm, we had two
    'oem_parameters' instances, one was unused... nice.
    
    Reported-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/drivers/scsi/isci/phy.c b/drivers/scsi/isci/phy.c
index fd0e9734e5d0..ca96b5ad0d52 100644
--- a/drivers/scsi/isci/phy.c
+++ b/drivers/scsi/isci/phy.c
@@ -112,13 +112,13 @@ static enum sci_status
 scic_sds_phy_link_layer_initialization(struct isci_phy *iphy,
 				       struct scu_link_layer_registers __iomem *link_layer_registers)
 {
-	struct scic_sds_controller *scic =
+	struct isci_host *ihost =
 		iphy->owning_port->owning_controller;
 	int phy_idx = iphy->phy_index;
 	struct sci_phy_user_params *phy_user =
-		&scic->user_parameters.sds1.phys[phy_idx];
+		&ihost->user_parameters.sds1.phys[phy_idx];
 	struct sci_phy_oem_params *phy_oem =
-		&scic->oem_parameters.sds1.phys[phy_idx];
+		&ihost->oem_parameters.sds1.phys[phy_idx];
 	u32 phy_configuration;
 	struct scic_phy_cap phy_cap;
 	u32 parity_check = 0;
@@ -169,7 +169,7 @@ scic_sds_phy_link_layer_initialization(struct isci_phy *iphy,
 	phy_cap.gen3_no_ssc = 1;
 	phy_cap.gen2_no_ssc = 1;
 	phy_cap.gen1_no_ssc = 1;
-	if (scic->oem_parameters.sds1.controller.do_enable_ssc == true) {
+	if (ihost->oem_parameters.sds1.controller.do_enable_ssc == true) {
 		phy_cap.gen3_ssc = 1;
 		phy_cap.gen2_ssc = 1;
 		phy_cap.gen1_ssc = 1;
@@ -216,7 +216,7 @@ scic_sds_phy_link_layer_initialization(struct isci_phy *iphy,
 		&iphy->link_layer_registers->afe_lookup_table_control);
 
 	llctl = SCU_SAS_LLCTL_GEN_VAL(NO_OUTBOUND_TASK_TIMEOUT,
-		(u8)scic->user_parameters.sds1.no_outbound_task_timeout);
+		(u8)ihost->user_parameters.sds1.no_outbound_task_timeout);
 
 	switch(phy_user->max_speed_generation) {
 	case SCIC_SDS_PARM_GEN3_SPEED:
@@ -255,7 +255,7 @@ static void phy_sata_timeout(unsigned long data)
 {
 	struct sci_timer *tmr = (struct sci_timer *)data;
 	struct isci_phy *iphy = container_of(tmr, typeof(*iphy), sata_timer);
-	struct isci_host *ihost = scic_to_ihost(iphy->owning_port->owning_controller);
+	struct isci_host *ihost = iphy->owning_port->owning_controller;
 	unsigned long flags;
 
 	spin_lock_irqsave(&ihost->scic_lock, flags);
@@ -890,7 +890,7 @@ enum sci_status scic_sds_phy_frame_handler(struct isci_phy *iphy,
 					   u32 frame_index)
 {
 	enum scic_sds_phy_states state = iphy->sm.current_state_id;
-	struct scic_sds_controller *scic = iphy->owning_port->owning_controller;
+	struct isci_host *ihost = iphy->owning_port->owning_controller;
 	enum sci_status result;
 	unsigned long flags;
 
@@ -899,7 +899,7 @@ enum sci_status scic_sds_phy_frame_handler(struct isci_phy *iphy,
 		u32 *frame_words;
 		struct sas_identify_frame iaf;
 
-		result = scic_sds_unsolicited_frame_control_get_header(&scic->uf_control,
+		result = scic_sds_unsolicited_frame_control_get_header(&ihost->uf_control,
 								       frame_index,
 								       (void **)&frame_words);
 
@@ -933,7 +933,7 @@ enum sci_status scic_sds_phy_frame_handler(struct isci_phy *iphy,
 				"unexpected frame id %x\n",
 				__func__, frame_index);
 
-		scic_sds_controller_release_frame(scic, frame_index);
+		scic_sds_controller_release_frame(ihost, frame_index);
 		return result;
 	}
 	case SCI_PHY_SUB_AWAIT_SIG_FIS_UF: {
@@ -950,7 +950,7 @@ enum sci_status scic_sds_phy_frame_handler(struct isci_phy *iphy,
 
 		if ((frame_header->fis_type == FIS_REGD2H) &&
 		    !(frame_header->status & ATA_BUSY)) {
-			scic_sds_unsolicited_frame_control_get_buffer(&scic->uf_control,
+			scic_sds_unsolicited_frame_control_get_buffer(&ihost->uf_control,
 								      frame_index,
 								      (void **)&fis_frame_data);
 
@@ -971,7 +971,7 @@ enum sci_status scic_sds_phy_frame_handler(struct isci_phy *iphy,
 				 __func__, frame_index);
 
 		/* Regardless of the result we are done with this frame with it */
-		scic_sds_controller_release_frame(scic, frame_index);
+		scic_sds_controller_release_frame(ihost, frame_index);
 
 		return result;
 	}
@@ -994,33 +994,33 @@ static void scic_sds_phy_starting_initial_substate_enter(struct sci_base_state_m
 static void scic_sds_phy_starting_await_sas_power_substate_enter(struct sci_base_state_machine *sm)
 {
 	struct isci_phy *iphy = container_of(sm, typeof(*iphy), sm);
-	struct scic_sds_controller *scic = iphy->owning_port->owning_controller;
+	struct isci_host *ihost = iphy->owning_port->owning_controller;
 
-	scic_sds_controller_power_control_queue_insert(scic, iphy);
+	scic_sds_controller_power_control_queue_insert(ihost, iphy);
 }
 
 static void scic_sds_phy_starting_await_sas_power_substate_exit(struct sci_base_state_machine *sm)
 {
 	struct isci_phy *iphy = container_of(sm, typeof(*iphy), sm);
-	struct scic_sds_controller *scic = iphy->owning_port->owning_controller;
+	struct isci_host *ihost = iphy->owning_port->owning_controller;
 
-	scic_sds_controller_power_control_queue_remove(scic, iphy);
+	scic_sds_controller_power_control_queue_remove(ihost, iphy);
 }
 
 static void scic_sds_phy_starting_await_sata_power_substate_enter(struct sci_base_state_machine *sm)
 {
 	struct isci_phy *iphy = container_of(sm, typeof(*iphy), sm);
-	struct scic_sds_controller *scic = iphy->owning_port->owning_controller;
+	struct isci_host *ihost = iphy->owning_port->owning_controller;
 
-	scic_sds_controller_power_control_queue_insert(scic, iphy);
+	scic_sds_controller_power_control_queue_insert(ihost, iphy);
 }
 
 static void scic_sds_phy_starting_await_sata_power_substate_exit(struct sci_base_state_machine *sm)
 {
 	struct isci_phy *iphy = container_of(sm, typeof(*iphy), sm);
-	struct scic_sds_controller *scic = iphy->owning_port->owning_controller;
+	struct isci_host *ihost = iphy->owning_port->owning_controller;
 
-	scic_sds_controller_power_control_queue_remove(scic, iphy);
+	scic_sds_controller_power_control_queue_remove(ihost, iphy);
 }
 
 static void scic_sds_phy_starting_await_sata_phy_substate_enter(struct sci_base_state_machine *sm)
@@ -1313,7 +1313,7 @@ void isci_phy_init(struct isci_phy *iphy, struct isci_host *ihost, int index)
 	u64 sci_sas_addr;
 	__be64 sas_addr;
 
-	scic_oem_parameters_get(&ihost->sci, &oem);
+	scic_oem_parameters_get(ihost, &oem);
 	sci_sas_addr = oem.sds1.phys[index].sas_address.high;
 	sci_sas_addr <<= 32;
 	sci_sas_addr |= oem.sds1.phys[index].sas_address.low;

commit ffe191c92ff195d73f9130b1490045ca2dd4c5e0
Author: Dan Williams <dan.j.williams@intel.com>
Date:   Wed Jun 29 13:09:25 2011 -0700

    isci: unify isci_port and scic_sds_port
    
    Remove the distinction between these two implementations and unify on
    isci_port (local instances named iport).  The duplicate '->owning_port' and
    '->isci_port' in both isci_phy and isci_remote_device will be fixed in a later
    patch... this is just the straightforward rename/unification.
    
    Reported-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/drivers/scsi/isci/phy.c b/drivers/scsi/isci/phy.c
index 0e60fb7bc1ab..fd0e9734e5d0 100644
--- a/drivers/scsi/isci/phy.c
+++ b/drivers/scsi/isci/phy.c
@@ -286,7 +286,7 @@ static void phy_sata_timeout(unsigned long data)
  * port (i.e. it's contained in the dummy port). !NULL All other
  * values indicate a handle/pointer to the port containing the phy.
  */
-struct scic_sds_port *phy_get_non_dummy_port(
+struct isci_port *phy_get_non_dummy_port(
 	struct isci_phy *iphy)
 {
 	if (scic_sds_port_get_index(iphy->owning_port) == SCIC_SDS_DUMMY_PORT)
@@ -304,9 +304,9 @@ struct scic_sds_port *phy_get_non_dummy_port(
  */
 void scic_sds_phy_set_port(
 	struct isci_phy *iphy,
-	struct scic_sds_port *sci_port)
+	struct isci_port *iport)
 {
-	iphy->owning_port = sci_port;
+	iphy->owning_port = iport;
 
 	if (iphy->bcn_received_while_port_unassigned) {
 		iphy->bcn_received_while_port_unassigned = false;
@@ -1291,12 +1291,12 @@ static const struct sci_base_state scic_sds_phy_state_table[] = {
 };
 
 void scic_sds_phy_construct(struct isci_phy *iphy,
-			    struct scic_sds_port *owning_port, u8 phy_index)
+			    struct isci_port *iport, u8 phy_index)
 {
 	sci_init_sm(&iphy->sm, scic_sds_phy_state_table, SCI_PHY_INITIAL);
 
 	/* Copy the rest of the input data to our locals */
-	iphy->owning_port = owning_port;
+	iphy->owning_port = iport;
 	iphy->phy_index = phy_index;
 	iphy->bcn_received_while_port_unassigned = false;
 	iphy->protocol = SCIC_SDS_PHY_PROTOCOL_UNKNOWN;

commit 852809559e4680ba4768262a6c3d21454fcd460e
Author: Dan Williams <dan.j.williams@intel.com>
Date:   Tue Jun 28 15:05:53 2011 -0700

    isci: unify isci_phy and scic_sds_phy
    
    They are one in the same object so remove the distinction.  The near
    duplicate fields (owning_port, and isci_port) will be cleaned up
    after the scic_sds_port isci_port unification.
    
    Reported-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/drivers/scsi/isci/phy.c b/drivers/scsi/isci/phy.c
index 98d93aeea75d..0e60fb7bc1ab 100644
--- a/drivers/scsi/isci/phy.c
+++ b/drivers/scsi/isci/phy.c
@@ -62,9 +62,9 @@
 /* Maximum arbitration wait time in micro-seconds */
 #define SCIC_SDS_PHY_MAX_ARBITRATION_WAIT_TIME  (700)
 
-enum sas_linkrate sci_phy_linkrate(struct scic_sds_phy *sci_phy)
+enum sas_linkrate sci_phy_linkrate(struct isci_phy *iphy)
 {
-	return sci_phy->max_negotiated_speed;
+	return iphy->max_negotiated_speed;
 }
 
 /*
@@ -80,23 +80,23 @@ enum sas_linkrate sci_phy_linkrate(struct scic_sds_phy *sci_phy)
  * enum sci_status
  */
 static enum sci_status scic_sds_phy_transport_layer_initialization(
-	struct scic_sds_phy *sci_phy,
+	struct isci_phy *iphy,
 	struct scu_transport_layer_registers __iomem *transport_layer_registers)
 {
 	u32 tl_control;
 
-	sci_phy->transport_layer_registers = transport_layer_registers;
+	iphy->transport_layer_registers = transport_layer_registers;
 
 	writel(SCIC_SDS_REMOTE_NODE_CONTEXT_INVALID_INDEX,
-		&sci_phy->transport_layer_registers->stp_rni);
+		&iphy->transport_layer_registers->stp_rni);
 
 	/*
 	 * Hardware team recommends that we enable the STP prefetch for all
 	 * transports
 	 */
-	tl_control = readl(&sci_phy->transport_layer_registers->control);
+	tl_control = readl(&iphy->transport_layer_registers->control);
 	tl_control |= SCU_TLCR_GEN_BIT(STP_WRITE_DATA_PREFETCH);
-	writel(tl_control, &sci_phy->transport_layer_registers->control);
+	writel(tl_control, &iphy->transport_layer_registers->control);
 
 	return SCI_SUCCESS;
 }
@@ -109,12 +109,12 @@ static enum sci_status scic_sds_phy_transport_layer_initialization(
  * enum sci_status
  */
 static enum sci_status
-scic_sds_phy_link_layer_initialization(struct scic_sds_phy *sci_phy,
+scic_sds_phy_link_layer_initialization(struct isci_phy *iphy,
 				       struct scu_link_layer_registers __iomem *link_layer_registers)
 {
 	struct scic_sds_controller *scic =
-		sci_phy->owning_port->owning_controller;
-	int phy_idx = sci_phy->phy_index;
+		iphy->owning_port->owning_controller;
+	int phy_idx = iphy->phy_index;
 	struct sci_phy_user_params *phy_user =
 		&scic->user_parameters.sds1.phys[phy_idx];
 	struct sci_phy_oem_params *phy_oem =
@@ -126,7 +126,7 @@ scic_sds_phy_link_layer_initialization(struct scic_sds_phy *sci_phy,
 	u32 llctl, link_rate;
 	u32 clksm_value = 0;
 
-	sci_phy->link_layer_registers = link_layer_registers;
+	iphy->link_layer_registers = link_layer_registers;
 
 	/* Set our IDENTIFY frame data */
 	#define SCI_END_DEVICE 0x01
@@ -136,32 +136,32 @@ scic_sds_phy_link_layer_initialization(struct scic_sds_phy *sci_phy,
 	       SCU_SAS_TIID_GEN_BIT(STP_INITIATOR) |
 	       SCU_SAS_TIID_GEN_BIT(DA_SATA_HOST) |
 	       SCU_SAS_TIID_GEN_VAL(DEVICE_TYPE, SCI_END_DEVICE),
-	       &sci_phy->link_layer_registers->transmit_identification);
+	       &iphy->link_layer_registers->transmit_identification);
 
 	/* Write the device SAS Address */
 	writel(0xFEDCBA98,
-	       &sci_phy->link_layer_registers->sas_device_name_high);
-	writel(phy_idx, &sci_phy->link_layer_registers->sas_device_name_low);
+	       &iphy->link_layer_registers->sas_device_name_high);
+	writel(phy_idx, &iphy->link_layer_registers->sas_device_name_low);
 
 	/* Write the source SAS Address */
 	writel(phy_oem->sas_address.high,
-		&sci_phy->link_layer_registers->source_sas_address_high);
+		&iphy->link_layer_registers->source_sas_address_high);
 	writel(phy_oem->sas_address.low,
-		&sci_phy->link_layer_registers->source_sas_address_low);
+		&iphy->link_layer_registers->source_sas_address_low);
 
 	/* Clear and Set the PHY Identifier */
-	writel(0, &sci_phy->link_layer_registers->identify_frame_phy_id);
+	writel(0, &iphy->link_layer_registers->identify_frame_phy_id);
 	writel(SCU_SAS_TIPID_GEN_VALUE(ID, phy_idx),
-		&sci_phy->link_layer_registers->identify_frame_phy_id);
+		&iphy->link_layer_registers->identify_frame_phy_id);
 
 	/* Change the initial state of the phy configuration register */
 	phy_configuration =
-		readl(&sci_phy->link_layer_registers->phy_configuration);
+		readl(&iphy->link_layer_registers->phy_configuration);
 
 	/* Hold OOB state machine in reset */
 	phy_configuration |=  SCU_SAS_PCFG_GEN_BIT(OOB_RESET);
 	writel(phy_configuration,
-		&sci_phy->link_layer_registers->phy_configuration);
+		&iphy->link_layer_registers->phy_configuration);
 
 	/* Configure the SNW capabilities */
 	phy_cap.all = 0;
@@ -191,14 +191,14 @@ scic_sds_phy_link_layer_initialization(struct scic_sds_phy *sci_phy,
 	if ((parity_count % 2) != 0)
 		phy_cap.parity = 1;
 
-	writel(phy_cap.all, &sci_phy->link_layer_registers->phy_capabilities);
+	writel(phy_cap.all, &iphy->link_layer_registers->phy_capabilities);
 
 	/* Set the enable spinup period but disable the ability to send
 	 * notify enable spinup
 	 */
 	writel(SCU_ENSPINUP_GEN_VAL(COUNT,
 			phy_user->notify_enable_spin_up_insertion_frequency),
-		&sci_phy->link_layer_registers->notify_enable_spinup_control);
+		&iphy->link_layer_registers->notify_enable_spinup_control);
 
 	/* Write the ALIGN Insertion Ferequency for connected phy and
 	 * inpendent of connected state
@@ -209,11 +209,11 @@ scic_sds_phy_link_layer_initialization(struct scic_sds_phy *sci_phy,
 	clksm_value |= SCU_ALIGN_INSERTION_FREQUENCY_GEN_VAL(GENERAL,
 			phy_user->align_insertion_frequency);
 
-	writel(clksm_value, &sci_phy->link_layer_registers->clock_skew_management);
+	writel(clksm_value, &iphy->link_layer_registers->clock_skew_management);
 
 	/* @todo Provide a way to write this register correctly */
 	writel(0x02108421,
-		&sci_phy->link_layer_registers->afe_lookup_table_control);
+		&iphy->link_layer_registers->afe_lookup_table_control);
 
 	llctl = SCU_SAS_LLCTL_GEN_VAL(NO_OUTBOUND_TASK_TIMEOUT,
 		(u8)scic->user_parameters.sds1.no_outbound_task_timeout);
@@ -230,7 +230,7 @@ scic_sds_phy_link_layer_initialization(struct scic_sds_phy *sci_phy,
 		break;
 	}
 	llctl |= SCU_SAS_LLCTL_GEN_VAL(MAX_LINK_RATE, link_rate);
-	writel(llctl, &sci_phy->link_layer_registers->link_layer_control);
+	writel(llctl, &iphy->link_layer_registers->link_layer_control);
 
 	if (is_a0() || is_a2()) {
 		/* Program the max ARB time for the PHY to 700us so we inter-operate with
@@ -239,14 +239,14 @@ scic_sds_phy_link_layer_initialization(struct scic_sds_phy *sci_phy,
 		 * generate the break.
 		 */
 		writel(SCIC_SDS_PHY_MAX_ARBITRATION_WAIT_TIME,
-			&sci_phy->link_layer_registers->maximum_arbitration_wait_timer_timeout);
+			&iphy->link_layer_registers->maximum_arbitration_wait_timer_timeout);
 	}
 
 	/* Disable link layer hang detection, rely on the OS timeout for I/O timeouts. */
-	writel(0, &sci_phy->link_layer_registers->link_layer_hang_detection_timeout);
+	writel(0, &iphy->link_layer_registers->link_layer_hang_detection_timeout);
 
 	/* We can exit the initial state to the stopped state */
-	sci_change_state(&sci_phy->sm, SCI_PHY_STOPPED);
+	sci_change_state(&iphy->sm, SCI_PHY_STOPPED);
 
 	return SCI_SUCCESS;
 }
@@ -254,8 +254,8 @@ scic_sds_phy_link_layer_initialization(struct scic_sds_phy *sci_phy,
 static void phy_sata_timeout(unsigned long data)
 {
 	struct sci_timer *tmr = (struct sci_timer *)data;
-	struct scic_sds_phy *sci_phy = container_of(tmr, typeof(*sci_phy), sata_timer);
-	struct isci_host *ihost = scic_to_ihost(sci_phy->owning_port->owning_controller);
+	struct isci_phy *iphy = container_of(tmr, typeof(*iphy), sata_timer);
+	struct isci_host *ihost = scic_to_ihost(iphy->owning_port->owning_controller);
 	unsigned long flags;
 
 	spin_lock_irqsave(&ihost->scic_lock, flags);
@@ -263,13 +263,13 @@ static void phy_sata_timeout(unsigned long data)
 	if (tmr->cancel)
 		goto done;
 
-	dev_dbg(sciphy_to_dev(sci_phy),
+	dev_dbg(sciphy_to_dev(iphy),
 		 "%s: SCIC SDS Phy 0x%p did not receive signature fis before "
 		 "timeout.\n",
 		 __func__,
-		 sci_phy);
+		 iphy);
 
-	sci_change_state(&sci_phy->sm, SCI_PHY_STARTING);
+	sci_change_state(&iphy->sm, SCI_PHY_STARTING);
 done:
 	spin_unlock_irqrestore(&ihost->scic_lock, flags);
 }
@@ -287,30 +287,30 @@ static void phy_sata_timeout(unsigned long data)
  * values indicate a handle/pointer to the port containing the phy.
  */
 struct scic_sds_port *phy_get_non_dummy_port(
-	struct scic_sds_phy *sci_phy)
+	struct isci_phy *iphy)
 {
-	if (scic_sds_port_get_index(sci_phy->owning_port) == SCIC_SDS_DUMMY_PORT)
+	if (scic_sds_port_get_index(iphy->owning_port) == SCIC_SDS_DUMMY_PORT)
 		return NULL;
 
-	return sci_phy->owning_port;
+	return iphy->owning_port;
 }
 
 /**
  * This method will assign a port to the phy object.
- * @out]: sci_phy This parameter specifies the phy for which to assign a port
+ * @out]: iphy This parameter specifies the phy for which to assign a port
  *    object.
  *
  *
  */
 void scic_sds_phy_set_port(
-	struct scic_sds_phy *sci_phy,
+	struct isci_phy *iphy,
 	struct scic_sds_port *sci_port)
 {
-	sci_phy->owning_port = sci_port;
+	iphy->owning_port = sci_port;
 
-	if (sci_phy->bcn_received_while_port_unassigned) {
-		sci_phy->bcn_received_while_port_unassigned = false;
-		scic_sds_port_broadcast_change_received(sci_phy->owning_port, sci_phy);
+	if (iphy->bcn_received_while_port_unassigned) {
+		iphy->bcn_received_while_port_unassigned = false;
+		scic_sds_port_broadcast_change_received(iphy->owning_port, iphy);
 	}
 }
 
@@ -322,22 +322,22 @@ void scic_sds_phy_set_port(
  * enum sci_status
  */
 enum sci_status scic_sds_phy_initialize(
-	struct scic_sds_phy *sci_phy,
+	struct isci_phy *iphy,
 	struct scu_transport_layer_registers __iomem *transport_layer_registers,
 	struct scu_link_layer_registers __iomem *link_layer_registers)
 {
 	/* Perfrom the initialization of the TL hardware */
 	scic_sds_phy_transport_layer_initialization(
-			sci_phy,
+			iphy,
 			transport_layer_registers);
 
 	/* Perofrm the initialization of the PE hardware */
-	scic_sds_phy_link_layer_initialization(sci_phy, link_layer_registers);
+	scic_sds_phy_link_layer_initialization(iphy, link_layer_registers);
 
 	/*
 	 * There is nothing that needs to be done in this state just
 	 * transition to the stopped state. */
-	sci_change_state(&sci_phy->sm, SCI_PHY_STOPPED);
+	sci_change_state(&iphy->sm, SCI_PHY_STOPPED);
 
 	return SCI_SUCCESS;
 }
@@ -345,27 +345,27 @@ enum sci_status scic_sds_phy_initialize(
 /**
  * This method assigns the direct attached device ID for this phy.
  *
- * @sci_phy The phy for which the direct attached device id is to
+ * @iphy The phy for which the direct attached device id is to
  *       be assigned.
  * @device_id The direct attached device ID to assign to the phy.
  *       This will either be the RNi for the device or an invalid RNi if there
  *       is no current device assigned to the phy.
  */
 void scic_sds_phy_setup_transport(
-	struct scic_sds_phy *sci_phy,
+	struct isci_phy *iphy,
 	u32 device_id)
 {
 	u32 tl_control;
 
-	writel(device_id, &sci_phy->transport_layer_registers->stp_rni);
+	writel(device_id, &iphy->transport_layer_registers->stp_rni);
 
 	/*
 	 * The read should guarantee that the first write gets posted
 	 * before the next write
 	 */
-	tl_control = readl(&sci_phy->transport_layer_registers->control);
+	tl_control = readl(&iphy->transport_layer_registers->control);
 	tl_control |= SCU_TLCR_GEN_BIT(CLEAR_TCI_NCQ_MAPPING_TABLE);
-	writel(tl_control, &sci_phy->transport_layer_registers->control);
+	writel(tl_control, &iphy->transport_layer_registers->control);
 }
 
 /**
@@ -376,75 +376,74 @@ void scic_sds_phy_setup_transport(
  * hardware protocol engine. none
  */
 static void scic_sds_phy_suspend(
-	struct scic_sds_phy *sci_phy)
+	struct isci_phy *iphy)
 {
 	u32 scu_sas_pcfg_value;
 
 	scu_sas_pcfg_value =
-		readl(&sci_phy->link_layer_registers->phy_configuration);
+		readl(&iphy->link_layer_registers->phy_configuration);
 	scu_sas_pcfg_value |= SCU_SAS_PCFG_GEN_BIT(SUSPEND_PROTOCOL_ENGINE);
 	writel(scu_sas_pcfg_value,
-		&sci_phy->link_layer_registers->phy_configuration);
+		&iphy->link_layer_registers->phy_configuration);
 
 	scic_sds_phy_setup_transport(
-			sci_phy,
+			iphy,
 			SCIC_SDS_REMOTE_NODE_CONTEXT_INVALID_INDEX);
 }
 
-void scic_sds_phy_resume(struct scic_sds_phy *sci_phy)
+void scic_sds_phy_resume(struct isci_phy *iphy)
 {
 	u32 scu_sas_pcfg_value;
 
 	scu_sas_pcfg_value =
-		readl(&sci_phy->link_layer_registers->phy_configuration);
+		readl(&iphy->link_layer_registers->phy_configuration);
 	scu_sas_pcfg_value &= ~SCU_SAS_PCFG_GEN_BIT(SUSPEND_PROTOCOL_ENGINE);
 	writel(scu_sas_pcfg_value,
-		&sci_phy->link_layer_registers->phy_configuration);
+		&iphy->link_layer_registers->phy_configuration);
 }
 
-void scic_sds_phy_get_sas_address(struct scic_sds_phy *sci_phy,
+void scic_sds_phy_get_sas_address(struct isci_phy *iphy,
 				  struct sci_sas_address *sas_address)
 {
-	sas_address->high = readl(&sci_phy->link_layer_registers->source_sas_address_high);
-	sas_address->low = readl(&sci_phy->link_layer_registers->source_sas_address_low);
+	sas_address->high = readl(&iphy->link_layer_registers->source_sas_address_high);
+	sas_address->low = readl(&iphy->link_layer_registers->source_sas_address_low);
 }
 
-void scic_sds_phy_get_attached_sas_address(struct scic_sds_phy *sci_phy,
+void scic_sds_phy_get_attached_sas_address(struct isci_phy *iphy,
 					   struct sci_sas_address *sas_address)
 {
 	struct sas_identify_frame *iaf;
-	struct isci_phy *iphy = sci_phy_to_iphy(sci_phy);
 
 	iaf = &iphy->frame_rcvd.iaf;
 	memcpy(sas_address, iaf->sas_addr, SAS_ADDR_SIZE);
 }
 
-void scic_sds_phy_get_protocols(struct scic_sds_phy *sci_phy,
+void scic_sds_phy_get_protocols(struct isci_phy *iphy,
 				struct scic_phy_proto *protocols)
 {
 	protocols->all =
-		(u16)(readl(&sci_phy->
+		(u16)(readl(&iphy->
 			link_layer_registers->transmit_identification) &
 				0x0000FFFF);
 }
 
-enum sci_status scic_sds_phy_start(struct scic_sds_phy *sci_phy)
+enum sci_status scic_sds_phy_start(struct isci_phy *iphy)
 {
-	enum scic_sds_phy_states state = sci_phy->sm.current_state_id;
+	enum scic_sds_phy_states state = iphy->sm.current_state_id;
 
 	if (state != SCI_PHY_STOPPED) {
-		dev_dbg(sciphy_to_dev(sci_phy),
+		dev_dbg(sciphy_to_dev(iphy),
 			 "%s: in wrong state: %d\n", __func__, state);
 		return SCI_FAILURE_INVALID_STATE;
 	}
 
-	sci_change_state(&sci_phy->sm, SCI_PHY_STARTING);
+	sci_change_state(&iphy->sm, SCI_PHY_STARTING);
 	return SCI_SUCCESS;
 }
 
-enum sci_status scic_sds_phy_stop(struct scic_sds_phy *sci_phy)
+enum sci_status scic_sds_phy_stop(struct isci_phy *iphy)
 {
-	enum scic_sds_phy_states state = sci_phy->sm.current_state_id;
+	enum scic_sds_phy_states state = iphy->sm.current_state_id;
 
 	switch (state) {
 	case SCI_PHY_SUB_INITIAL:
@@ -459,43 +458,43 @@ enum sci_status scic_sds_phy_stop(struct scic_sds_phy *sci_phy)
 	case SCI_PHY_READY:
 		break;
 	default:
-		dev_dbg(sciphy_to_dev(sci_phy),
+		dev_dbg(sciphy_to_dev(iphy),
 			"%s: in wrong state: %d\n", __func__, state);
 		return SCI_FAILURE_INVALID_STATE;
 	}
 
-	sci_change_state(&sci_phy->sm, SCI_PHY_STOPPED);
+	sci_change_state(&iphy->sm, SCI_PHY_STOPPED);
 	return SCI_SUCCESS;
 }
 
-enum sci_status scic_sds_phy_reset(struct scic_sds_phy *sci_phy)
+enum sci_status scic_sds_phy_reset(struct isci_phy *iphy)
 {
-	enum scic_sds_phy_states state = sci_phy->sm.current_state_id;
+	enum scic_sds_phy_states state = iphy->sm.current_state_id;
 
 	if (state != SCI_PHY_READY) {
-		dev_dbg(sciphy_to_dev(sci_phy),
+		dev_dbg(sciphy_to_dev(iphy),
 			"%s: in wrong state: %d\n", __func__, state);
 		return SCI_FAILURE_INVALID_STATE;
 	}
 
-	sci_change_state(&sci_phy->sm, SCI_PHY_RESETTING);
+	sci_change_state(&iphy->sm, SCI_PHY_RESETTING);
 	return SCI_SUCCESS;
 }
 
-enum sci_status scic_sds_phy_consume_power_handler(struct scic_sds_phy *sci_phy)
+enum sci_status scic_sds_phy_consume_power_handler(struct isci_phy *iphy)
 {
-	enum scic_sds_phy_states state = sci_phy->sm.current_state_id;
+	enum scic_sds_phy_states state = iphy->sm.current_state_id;
 
 	switch (state) {
 	case SCI_PHY_SUB_AWAIT_SAS_POWER: {
 		u32 enable_spinup;
 
-		enable_spinup = readl(&sci_phy->link_layer_registers->notify_enable_spinup_control);
+		enable_spinup = readl(&iphy->link_layer_registers->notify_enable_spinup_control);
 		enable_spinup |= SCU_ENSPINUP_GEN_BIT(ENABLE);
-		writel(enable_spinup, &sci_phy->link_layer_registers->notify_enable_spinup_control);
+		writel(enable_spinup, &iphy->link_layer_registers->notify_enable_spinup_control);
 
 		/* Change state to the final state this substate machine has run to completion */
-		sci_change_state(&sci_phy->sm, SCI_PHY_SUB_FINAL);
+		sci_change_state(&iphy->sm, SCI_PHY_SUB_FINAL);
 
 		return SCI_SUCCESS;
 	}
@@ -504,26 +503,26 @@ enum sci_status scic_sds_phy_consume_power_handler(struct scic_sds_phy *sci_phy)
 
 		/* Release the spinup hold state and reset the OOB state machine */
 		scu_sas_pcfg_value =
-			readl(&sci_phy->link_layer_registers->phy_configuration);
+			readl(&iphy->link_layer_registers->phy_configuration);
 		scu_sas_pcfg_value &=
 			~(SCU_SAS_PCFG_GEN_BIT(SATA_SPINUP_HOLD) | SCU_SAS_PCFG_GEN_BIT(OOB_ENABLE));
 		scu_sas_pcfg_value |= SCU_SAS_PCFG_GEN_BIT(OOB_RESET);
 		writel(scu_sas_pcfg_value,
-			&sci_phy->link_layer_registers->phy_configuration);
+			&iphy->link_layer_registers->phy_configuration);
 
 		/* Now restart the OOB operation */
 		scu_sas_pcfg_value &= ~SCU_SAS_PCFG_GEN_BIT(OOB_RESET);
 		scu_sas_pcfg_value |= SCU_SAS_PCFG_GEN_BIT(OOB_ENABLE);
 		writel(scu_sas_pcfg_value,
-			&sci_phy->link_layer_registers->phy_configuration);
+			&iphy->link_layer_registers->phy_configuration);
 
 		/* Change state to the final state this substate machine has run to completion */
-		sci_change_state(&sci_phy->sm, SCI_PHY_SUB_AWAIT_SATA_PHY_EN);
+		sci_change_state(&iphy->sm, SCI_PHY_SUB_AWAIT_SATA_PHY_EN);
 
 		return SCI_SUCCESS;
 	}
 	default:
-		dev_dbg(sciphy_to_dev(sci_phy),
+		dev_dbg(sciphy_to_dev(iphy),
 			"%s: in wrong state: %d\n", __func__, state);
 		return SCI_FAILURE_INVALID_STATE;
 	}
@@ -545,19 +544,19 @@ enum sci_status scic_sds_phy_consume_power_handler(struct scic_sds_phy *sci_phy)
  * none
  */
 static void scic_sds_phy_start_sas_link_training(
-	struct scic_sds_phy *sci_phy)
+	struct isci_phy *iphy)
 {
 	u32 phy_control;
 
 	phy_control =
-		readl(&sci_phy->link_layer_registers->phy_configuration);
+		readl(&iphy->link_layer_registers->phy_configuration);
 	phy_control |= SCU_SAS_PCFG_GEN_BIT(SATA_SPINUP_HOLD);
 	writel(phy_control,
-		&sci_phy->link_layer_registers->phy_configuration);
+		&iphy->link_layer_registers->phy_configuration);
 
-	sci_change_state(&sci_phy->sm, SCI_PHY_SUB_AWAIT_SAS_SPEED_EN);
+	sci_change_state(&iphy->sm, SCI_PHY_SUB_AWAIT_SAS_SPEED_EN);
 
-	sci_phy->protocol = SCIC_SDS_PHY_PROTOCOL_SAS;
+	iphy->protocol = SCIC_SDS_PHY_PROTOCOL_SAS;
 }
 
 /**
@@ -569,11 +568,11 @@ static void scic_sds_phy_start_sas_link_training(
  * SPINUP HOLD event when the state machine was expecting a SAS PHY event. none
  */
 static void scic_sds_phy_start_sata_link_training(
-	struct scic_sds_phy *sci_phy)
+	struct isci_phy *iphy)
 {
-	sci_change_state(&sci_phy->sm, SCI_PHY_SUB_AWAIT_SATA_POWER);
+	sci_change_state(&iphy->sm, SCI_PHY_SUB_AWAIT_SATA_POWER);
 
-	sci_phy->protocol = SCIC_SDS_PHY_PROTOCOL_SATA;
+	iphy->protocol = SCIC_SDS_PHY_PROTOCOL_SATA;
 }
 
 /**
@@ -588,33 +587,33 @@ static void scic_sds_phy_start_sata_link_training(
  *
  */
 static void scic_sds_phy_complete_link_training(
-	struct scic_sds_phy *sci_phy,
+	struct isci_phy *iphy,
 	enum sas_linkrate max_link_rate,
 	u32 next_state)
 {
-	sci_phy->max_negotiated_speed = max_link_rate;
+	iphy->max_negotiated_speed = max_link_rate;
 
-	sci_change_state(&sci_phy->sm, next_state);
+	sci_change_state(&iphy->sm, next_state);
 }
 
-enum sci_status scic_sds_phy_event_handler(struct scic_sds_phy *sci_phy,
+enum sci_status scic_sds_phy_event_handler(struct isci_phy *iphy,
 					   u32 event_code)
 {
-	enum scic_sds_phy_states state = sci_phy->sm.current_state_id;
+	enum scic_sds_phy_states state = iphy->sm.current_state_id;
 
 	switch (state) {
 	case SCI_PHY_SUB_AWAIT_OSSP_EN:
 		switch (scu_get_event_code(event_code)) {
 		case SCU_EVENT_SAS_PHY_DETECTED:
-			scic_sds_phy_start_sas_link_training(sci_phy);
-			sci_phy->is_in_link_training = true;
+			scic_sds_phy_start_sas_link_training(iphy);
+			iphy->is_in_link_training = true;
 			break;
 		case SCU_EVENT_SATA_SPINUP_HOLD:
-			scic_sds_phy_start_sata_link_training(sci_phy);
-			sci_phy->is_in_link_training = true;
+			scic_sds_phy_start_sata_link_training(iphy);
+			iphy->is_in_link_training = true;
 			break;
 		default:
-			dev_dbg(sciphy_to_dev(sci_phy),
+			dev_dbg(sciphy_to_dev(iphy),
 				"%s: PHY starting substate machine received "
 				"unexpected event_code %x\n",
 				__func__,
@@ -632,21 +631,21 @@ enum sci_status scic_sds_phy_event_handler(struct scic_sds_phy *sci_phy,
 		case SCU_EVENT_SAS_15:
 		case SCU_EVENT_SAS_15_SSC:
 			scic_sds_phy_complete_link_training(
-				sci_phy,
+				iphy,
 				SAS_LINK_RATE_1_5_GBPS,
 				SCI_PHY_SUB_AWAIT_IAF_UF);
 			break;
 		case SCU_EVENT_SAS_30:
 		case SCU_EVENT_SAS_30_SSC:
 			scic_sds_phy_complete_link_training(
-				sci_phy,
+				iphy,
 				SAS_LINK_RATE_3_0_GBPS,
 				SCI_PHY_SUB_AWAIT_IAF_UF);
 			break;
 		case SCU_EVENT_SAS_60:
 		case SCU_EVENT_SAS_60_SSC:
 			scic_sds_phy_complete_link_training(
-				sci_phy,
+				iphy,
 				SAS_LINK_RATE_6_0_GBPS,
 				SCI_PHY_SUB_AWAIT_IAF_UF);
 			break;
@@ -654,14 +653,14 @@ enum sci_status scic_sds_phy_event_handler(struct scic_sds_phy *sci_phy,
 			/*
 			 * We were doing SAS PHY link training and received a SATA PHY event
 			 * continue OOB/SN as if this were a SATA PHY */
-			scic_sds_phy_start_sata_link_training(sci_phy);
+			scic_sds_phy_start_sata_link_training(iphy);
 			break;
 		case SCU_EVENT_LINK_FAILURE:
 			/* Link failure change state back to the starting state */
-			sci_change_state(&sci_phy->sm, SCI_PHY_STARTING);
+			sci_change_state(&iphy->sm, SCI_PHY_STARTING);
 			break;
 		default:
-			dev_warn(sciphy_to_dev(sci_phy),
+			dev_warn(sciphy_to_dev(iphy),
 				 "%s: PHY starting substate machine received "
 				 "unexpected event_code %x\n",
 				 __func__, event_code);
@@ -674,23 +673,23 @@ enum sci_status scic_sds_phy_event_handler(struct scic_sds_phy *sci_phy,
 		switch (scu_get_event_code(event_code)) {
 		case SCU_EVENT_SAS_PHY_DETECTED:
 			/* Backup the state machine */
-			scic_sds_phy_start_sas_link_training(sci_phy);
+			scic_sds_phy_start_sas_link_training(iphy);
 			break;
 		case SCU_EVENT_SATA_SPINUP_HOLD:
 			/* We were doing SAS PHY link training and received a
 			 * SATA PHY event continue OOB/SN as if this were a
 			 * SATA PHY
 			 */
-			scic_sds_phy_start_sata_link_training(sci_phy);
+			scic_sds_phy_start_sata_link_training(iphy);
 			break;
 		case SCU_EVENT_RECEIVED_IDENTIFY_TIMEOUT:
 		case SCU_EVENT_LINK_FAILURE:
 		case SCU_EVENT_HARD_RESET_RECEIVED:
 			/* Start the oob/sn state machine over again */
-			sci_change_state(&sci_phy->sm, SCI_PHY_STARTING);
+			sci_change_state(&iphy->sm, SCI_PHY_STARTING);
 			break;
 		default:
-			dev_warn(sciphy_to_dev(sci_phy),
+			dev_warn(sciphy_to_dev(iphy),
 				 "%s: PHY starting substate machine received "
 				 "unexpected event_code %x\n",
 				 __func__, event_code);
@@ -701,10 +700,10 @@ enum sci_status scic_sds_phy_event_handler(struct scic_sds_phy *sci_phy,
 		switch (scu_get_event_code(event_code)) {
 		case SCU_EVENT_LINK_FAILURE:
 			/* Link failure change state back to the starting state */
-			sci_change_state(&sci_phy->sm, SCI_PHY_STARTING);
+			sci_change_state(&iphy->sm, SCI_PHY_STARTING);
 			break;
 		default:
-			dev_warn(sciphy_to_dev(sci_phy),
+			dev_warn(sciphy_to_dev(iphy),
 				"%s: PHY starting substate machine received unexpected "
 				"event_code %x\n",
 				__func__,
@@ -716,7 +715,7 @@ enum sci_status scic_sds_phy_event_handler(struct scic_sds_phy *sci_phy,
 		switch (scu_get_event_code(event_code)) {
 		case SCU_EVENT_LINK_FAILURE:
 			/* Link failure change state back to the starting state */
-			sci_change_state(&sci_phy->sm, SCI_PHY_STARTING);
+			sci_change_state(&iphy->sm, SCI_PHY_STARTING);
 			break;
 		case SCU_EVENT_SATA_SPINUP_HOLD:
 			/* These events are received every 10ms and are
@@ -728,11 +727,11 @@ enum sci_status scic_sds_phy_event_handler(struct scic_sds_phy *sci_phy,
 			/* There has been a change in the phy type before OOB/SN for the
 			 * SATA finished start down the SAS link traning path.
 			 */
-			scic_sds_phy_start_sas_link_training(sci_phy);
+			scic_sds_phy_start_sas_link_training(iphy);
 			break;
 
 		default:
-			dev_warn(sciphy_to_dev(sci_phy),
+			dev_warn(sciphy_to_dev(iphy),
 				 "%s: PHY starting substate machine received "
 				 "unexpected event_code %x\n",
 				 __func__, event_code);
@@ -744,7 +743,7 @@ enum sci_status scic_sds_phy_event_handler(struct scic_sds_phy *sci_phy,
 		switch (scu_get_event_code(event_code)) {
 		case SCU_EVENT_LINK_FAILURE:
 			/* Link failure change state back to the starting state */
-			sci_change_state(&sci_phy->sm, SCI_PHY_STARTING);
+			sci_change_state(&iphy->sm, SCI_PHY_STARTING);
 			break;
 		case SCU_EVENT_SATA_SPINUP_HOLD:
 			/* These events might be received since we dont know how many may be in
@@ -752,19 +751,19 @@ enum sci_status scic_sds_phy_event_handler(struct scic_sds_phy *sci_phy,
 			 */
 			break;
 		case SCU_EVENT_SATA_PHY_DETECTED:
-			sci_phy->protocol = SCIC_SDS_PHY_PROTOCOL_SATA;
+			iphy->protocol = SCIC_SDS_PHY_PROTOCOL_SATA;
 
 			/* We have received the SATA PHY notification change state */
-			sci_change_state(&sci_phy->sm, SCI_PHY_SUB_AWAIT_SATA_SPEED_EN);
+			sci_change_state(&iphy->sm, SCI_PHY_SUB_AWAIT_SATA_SPEED_EN);
 			break;
 		case SCU_EVENT_SAS_PHY_DETECTED:
 			/* There has been a change in the phy type before OOB/SN for the
 			 * SATA finished start down the SAS link traning path.
 			 */
-			scic_sds_phy_start_sas_link_training(sci_phy);
+			scic_sds_phy_start_sas_link_training(iphy);
 			break;
 		default:
-			dev_warn(sciphy_to_dev(sci_phy),
+			dev_warn(sciphy_to_dev(iphy),
 				 "%s: PHY starting substate machine received "
 				 "unexpected event_code %x\n",
 				 __func__,
@@ -783,36 +782,36 @@ enum sci_status scic_sds_phy_event_handler(struct scic_sds_phy *sci_phy,
 		case SCU_EVENT_SATA_15:
 		case SCU_EVENT_SATA_15_SSC:
 			scic_sds_phy_complete_link_training(
-				sci_phy,
+				iphy,
 				SAS_LINK_RATE_1_5_GBPS,
 				SCI_PHY_SUB_AWAIT_SIG_FIS_UF);
 			break;
 		case SCU_EVENT_SATA_30:
 		case SCU_EVENT_SATA_30_SSC:
 			scic_sds_phy_complete_link_training(
-				sci_phy,
+				iphy,
 				SAS_LINK_RATE_3_0_GBPS,
 				SCI_PHY_SUB_AWAIT_SIG_FIS_UF);
 			break;
 		case SCU_EVENT_SATA_60:
 		case SCU_EVENT_SATA_60_SSC:
 			scic_sds_phy_complete_link_training(
-				sci_phy,
+				iphy,
 				SAS_LINK_RATE_6_0_GBPS,
 				SCI_PHY_SUB_AWAIT_SIG_FIS_UF);
 			break;
 		case SCU_EVENT_LINK_FAILURE:
 			/* Link failure change state back to the starting state */
-			sci_change_state(&sci_phy->sm, SCI_PHY_STARTING);
+			sci_change_state(&iphy->sm, SCI_PHY_STARTING);
 			break;
 		case SCU_EVENT_SAS_PHY_DETECTED:
 			/*
 			 * There has been a change in the phy type before OOB/SN for the
 			 * SATA finished start down the SAS link traning path. */
-			scic_sds_phy_start_sas_link_training(sci_phy);
+			scic_sds_phy_start_sas_link_training(iphy);
 			break;
 		default:
-			dev_warn(sciphy_to_dev(sci_phy),
+			dev_warn(sciphy_to_dev(iphy),
 				 "%s: PHY starting substate machine received "
 				 "unexpected event_code %x\n",
 				 __func__, event_code);
@@ -825,16 +824,16 @@ enum sci_status scic_sds_phy_event_handler(struct scic_sds_phy *sci_phy,
 		switch (scu_get_event_code(event_code)) {
 		case SCU_EVENT_SATA_PHY_DETECTED:
 			/* Backup the state machine */
-			sci_change_state(&sci_phy->sm, SCI_PHY_SUB_AWAIT_SATA_SPEED_EN);
+			sci_change_state(&iphy->sm, SCI_PHY_SUB_AWAIT_SATA_SPEED_EN);
 			break;
 
 		case SCU_EVENT_LINK_FAILURE:
 			/* Link failure change state back to the starting state */
-			sci_change_state(&sci_phy->sm, SCI_PHY_STARTING);
+			sci_change_state(&iphy->sm, SCI_PHY_STARTING);
 			break;
 
 		default:
-			dev_warn(sciphy_to_dev(sci_phy),
+			dev_warn(sciphy_to_dev(iphy),
 				 "%s: PHY starting substate machine received "
 				 "unexpected event_code %x\n",
 				 __func__,
@@ -847,20 +846,20 @@ enum sci_status scic_sds_phy_event_handler(struct scic_sds_phy *sci_phy,
 		switch (scu_get_event_code(event_code)) {
 		case SCU_EVENT_LINK_FAILURE:
 			/* Link failure change state back to the starting state */
-			sci_change_state(&sci_phy->sm, SCI_PHY_STARTING);
+			sci_change_state(&iphy->sm, SCI_PHY_STARTING);
 			break;
 		case SCU_EVENT_BROADCAST_CHANGE:
 			/* Broadcast change received. Notify the port. */
-			if (phy_get_non_dummy_port(sci_phy) != NULL)
-				scic_sds_port_broadcast_change_received(sci_phy->owning_port, sci_phy);
+			if (phy_get_non_dummy_port(iphy) != NULL)
+				scic_sds_port_broadcast_change_received(iphy->owning_port, iphy);
 			else
-				sci_phy->bcn_received_while_port_unassigned = true;
+				iphy->bcn_received_while_port_unassigned = true;
 			break;
 		default:
-			dev_warn(sciphy_to_dev(sci_phy),
+			dev_warn(sciphy_to_dev(iphy),
 				 "%sP SCIC PHY 0x%p ready state machine received "
 				 "unexpected event_code %x\n",
-				 __func__, sci_phy, event_code);
+				 __func__, iphy, event_code);
 			return SCI_FAILURE_INVALID_STATE;
 		}
 		return SCI_SUCCESS;
@@ -868,30 +867,30 @@ enum sci_status scic_sds_phy_event_handler(struct scic_sds_phy *sci_phy,
 		switch (scu_get_event_code(event_code)) {
 		case SCU_EVENT_HARD_RESET_TRANSMITTED:
 			/* Link failure change state back to the starting state */
-			sci_change_state(&sci_phy->sm, SCI_PHY_STARTING);
+			sci_change_state(&iphy->sm, SCI_PHY_STARTING);
 			break;
 		default:
-			dev_warn(sciphy_to_dev(sci_phy),
+			dev_warn(sciphy_to_dev(iphy),
 				 "%s: SCIC PHY 0x%p resetting state machine received "
 				 "unexpected event_code %x\n",
-				 __func__, sci_phy, event_code);
+				 __func__, iphy, event_code);
 
 			return SCI_FAILURE_INVALID_STATE;
 			break;
 		}
 		return SCI_SUCCESS;
 	default:
-		dev_dbg(sciphy_to_dev(sci_phy),
+		dev_dbg(sciphy_to_dev(iphy),
 			"%s: in wrong state: %d\n", __func__, state);
 		return SCI_FAILURE_INVALID_STATE;
 	}
 }
 
-enum sci_status scic_sds_phy_frame_handler(struct scic_sds_phy *sci_phy,
+enum sci_status scic_sds_phy_frame_handler(struct isci_phy *iphy,
 					   u32 frame_index)
 {
-	enum scic_sds_phy_states state = sci_phy->sm.current_state_id;
-	struct scic_sds_controller *scic = sci_phy->owning_port->owning_controller;
+	enum scic_sds_phy_states state = iphy->sm.current_state_id;
+	struct scic_sds_controller *scic = iphy->owning_port->owning_controller;
 	enum sci_status result;
 	unsigned long flags;
 
@@ -899,7 +898,6 @@ enum sci_status scic_sds_phy_frame_handler(struct scic_sds_phy *sci_phy,
 	case SCI_PHY_SUB_AWAIT_IAF_UF: {
 		u32 *frame_words;
 		struct sas_identify_frame iaf;
-		struct isci_phy *iphy = sci_phy_to_iphy(sci_phy);
 
 		result = scic_sds_unsolicited_frame_control_get_header(&scic->uf_control,
 								       frame_index,
@@ -927,10 +925,10 @@ enum sci_status scic_sds_phy_frame_handler(struct scic_sds_phy *sci_phy,
 				 */
 				state = SCI_PHY_SUB_AWAIT_SAS_POWER;
 			}
-			sci_change_state(&sci_phy->sm, state);
+			sci_change_state(&iphy->sm, state);
 			result = SCI_SUCCESS;
 		} else
-			dev_warn(sciphy_to_dev(sci_phy),
+			dev_warn(sciphy_to_dev(iphy),
 				"%s: PHY starting substate machine received "
 				"unexpected frame id %x\n",
 				__func__, frame_index);
@@ -941,10 +939,9 @@ enum sci_status scic_sds_phy_frame_handler(struct scic_sds_phy *sci_phy,
 	case SCI_PHY_SUB_AWAIT_SIG_FIS_UF: {
 		struct dev_to_host_fis *frame_header;
 		u32 *fis_frame_data;
-		struct isci_phy *iphy = sci_phy_to_iphy(sci_phy);
 
 		result = scic_sds_unsolicited_frame_control_get_header(
-			&(scic_sds_phy_get_controller(sci_phy)->uf_control),
+			&(scic_sds_phy_get_controller(iphy)->uf_control),
 			frame_index,
 			(void **)&frame_header);
 
@@ -964,11 +961,11 @@ enum sci_status scic_sds_phy_frame_handler(struct scic_sds_phy *sci_phy,
 			spin_unlock_irqrestore(&iphy->sas_phy.frame_rcvd_lock, flags);
 
 			/* got IAF we can now go to the await spinup semaphore state */
-			sci_change_state(&sci_phy->sm, SCI_PHY_SUB_FINAL);
+			sci_change_state(&iphy->sm, SCI_PHY_SUB_FINAL);
 
 			result = SCI_SUCCESS;
 		} else
-			dev_warn(sciphy_to_dev(sci_phy),
+			dev_warn(sciphy_to_dev(iphy),
 				 "%s: PHY starting substate machine received "
 				 "unexpected frame id %x\n",
 				 __func__, frame_index);
@@ -979,7 +976,7 @@ enum sci_status scic_sds_phy_frame_handler(struct scic_sds_phy *sci_phy,
 		return result;
 	}
 	default:
-		dev_dbg(sciphy_to_dev(sci_phy),
+		dev_dbg(sciphy_to_dev(iphy),
 			"%s: in wrong state: %d\n", __func__, state);
 		return SCI_FAILURE_INVALID_STATE;
 	}
@@ -988,77 +985,77 @@ enum sci_status scic_sds_phy_frame_handler(struct scic_sds_phy *sci_phy,
 
 static void scic_sds_phy_starting_initial_substate_enter(struct sci_base_state_machine *sm)
 {
-	struct scic_sds_phy *sci_phy = container_of(sm, typeof(*sci_phy), sm);
+	struct isci_phy *iphy = container_of(sm, typeof(*iphy), sm);
 
 	/* This is just an temporary state go off to the starting state */
-	sci_change_state(&sci_phy->sm, SCI_PHY_SUB_AWAIT_OSSP_EN);
+	sci_change_state(&iphy->sm, SCI_PHY_SUB_AWAIT_OSSP_EN);
 }
 
 static void scic_sds_phy_starting_await_sas_power_substate_enter(struct sci_base_state_machine *sm)
 {
-	struct scic_sds_phy *sci_phy = container_of(sm, typeof(*sci_phy), sm);
-	struct scic_sds_controller *scic = sci_phy->owning_port->owning_controller;
+	struct isci_phy *iphy = container_of(sm, typeof(*iphy), sm);
+	struct scic_sds_controller *scic = iphy->owning_port->owning_controller;
 
-	scic_sds_controller_power_control_queue_insert(scic, sci_phy);
+	scic_sds_controller_power_control_queue_insert(scic, iphy);
 }
 
 static void scic_sds_phy_starting_await_sas_power_substate_exit(struct sci_base_state_machine *sm)
 {
-	struct scic_sds_phy *sci_phy = container_of(sm, typeof(*sci_phy), sm);
-	struct scic_sds_controller *scic = sci_phy->owning_port->owning_controller;
+	struct isci_phy *iphy = container_of(sm, typeof(*iphy), sm);
+	struct scic_sds_controller *scic = iphy->owning_port->owning_controller;
 
-	scic_sds_controller_power_control_queue_remove(scic, sci_phy);
+	scic_sds_controller_power_control_queue_remove(scic, iphy);
 }
 
 static void scic_sds_phy_starting_await_sata_power_substate_enter(struct sci_base_state_machine *sm)
 {
-	struct scic_sds_phy *sci_phy = container_of(sm, typeof(*sci_phy), sm);
-	struct scic_sds_controller *scic = sci_phy->owning_port->owning_controller;
+	struct isci_phy *iphy = container_of(sm, typeof(*iphy), sm);
+	struct scic_sds_controller *scic = iphy->owning_port->owning_controller;
 
-	scic_sds_controller_power_control_queue_insert(scic, sci_phy);
+	scic_sds_controller_power_control_queue_insert(scic, iphy);
 }
 
 static void scic_sds_phy_starting_await_sata_power_substate_exit(struct sci_base_state_machine *sm)
 {
-	struct scic_sds_phy *sci_phy = container_of(sm, typeof(*sci_phy), sm);
-	struct scic_sds_controller *scic = sci_phy->owning_port->owning_controller;
+	struct isci_phy *iphy = container_of(sm, typeof(*iphy), sm);
+	struct scic_sds_controller *scic = iphy->owning_port->owning_controller;
 
-	scic_sds_controller_power_control_queue_remove(scic, sci_phy);
+	scic_sds_controller_power_control_queue_remove(scic, iphy);
 }
 
 static void scic_sds_phy_starting_await_sata_phy_substate_enter(struct sci_base_state_machine *sm)
 {
-	struct scic_sds_phy *sci_phy = container_of(sm, typeof(*sci_phy), sm);
+	struct isci_phy *iphy = container_of(sm, typeof(*iphy), sm);
 
-	sci_mod_timer(&sci_phy->sata_timer, SCIC_SDS_SATA_LINK_TRAINING_TIMEOUT);
+	sci_mod_timer(&iphy->sata_timer, SCIC_SDS_SATA_LINK_TRAINING_TIMEOUT);
 }
 
 static void scic_sds_phy_starting_await_sata_phy_substate_exit(struct sci_base_state_machine *sm)
 {
-	struct scic_sds_phy *sci_phy = container_of(sm, typeof(*sci_phy), sm);
+	struct isci_phy *iphy = container_of(sm, typeof(*iphy), sm);
 
-	sci_del_timer(&sci_phy->sata_timer);
+	sci_del_timer(&iphy->sata_timer);
 }
 
 static void scic_sds_phy_starting_await_sata_speed_substate_enter(struct sci_base_state_machine *sm)
 {
-	struct scic_sds_phy *sci_phy = container_of(sm, typeof(*sci_phy), sm);
+	struct isci_phy *iphy = container_of(sm, typeof(*iphy), sm);
 
-	sci_mod_timer(&sci_phy->sata_timer, SCIC_SDS_SATA_LINK_TRAINING_TIMEOUT);
+	sci_mod_timer(&iphy->sata_timer, SCIC_SDS_SATA_LINK_TRAINING_TIMEOUT);
 }
 
 static void scic_sds_phy_starting_await_sata_speed_substate_exit(struct sci_base_state_machine *sm)
 {
-	struct scic_sds_phy *sci_phy = container_of(sm, typeof(*sci_phy), sm);
+	struct isci_phy *iphy = container_of(sm, typeof(*iphy), sm);
 
-	sci_del_timer(&sci_phy->sata_timer);
+	sci_del_timer(&iphy->sata_timer);
 }
 
 static void scic_sds_phy_starting_await_sig_fis_uf_substate_enter(struct sci_base_state_machine *sm)
 {
-	struct scic_sds_phy *sci_phy = container_of(sm, typeof(*sci_phy), sm);
+	struct isci_phy *iphy = container_of(sm, typeof(*iphy), sm);
 
-	if (scic_sds_port_link_detected(sci_phy->owning_port, sci_phy)) {
+	if (scic_sds_port_link_detected(iphy->owning_port, iphy)) {
 
 		/*
 		 * Clear the PE suspend condition so we can actually
@@ -1066,79 +1063,79 @@ static void scic_sds_phy_starting_await_sig_fis_uf_substate_enter(struct sci_bas
 		 * The hardware will not respond to the XRDY until the PE
 		 * suspend condition is cleared.
 		 */
-		scic_sds_phy_resume(sci_phy);
+		scic_sds_phy_resume(iphy);
 
-		sci_mod_timer(&sci_phy->sata_timer,
+		sci_mod_timer(&iphy->sata_timer,
 			      SCIC_SDS_SIGNATURE_FIS_TIMEOUT);
 	} else
-		sci_phy->is_in_link_training = false;
+		iphy->is_in_link_training = false;
 }
 
 static void scic_sds_phy_starting_await_sig_fis_uf_substate_exit(struct sci_base_state_machine *sm)
 {
-	struct scic_sds_phy *sci_phy = container_of(sm, typeof(*sci_phy), sm);
+	struct isci_phy *iphy = container_of(sm, typeof(*iphy), sm);
 
-	sci_del_timer(&sci_phy->sata_timer);
+	sci_del_timer(&iphy->sata_timer);
 }
 
 static void scic_sds_phy_starting_final_substate_enter(struct sci_base_state_machine *sm)
 {
-	struct scic_sds_phy *sci_phy = container_of(sm, typeof(*sci_phy), sm);
+	struct isci_phy *iphy = container_of(sm, typeof(*iphy), sm);
 
 	/* State machine has run to completion so exit out and change
 	 * the base state machine to the ready state
 	 */
-	sci_change_state(&sci_phy->sm, SCI_PHY_READY);
+	sci_change_state(&iphy->sm, SCI_PHY_READY);
 }
 
 /**
  *
- * @sci_phy: This is the struct scic_sds_phy object to stop.
+ * @sci_phy: This is the struct isci_phy object to stop.
  *
- * This method will stop the struct scic_sds_phy object. This does not reset the
+ * This method will stop the struct isci_phy object. This does not reset the
  * protocol engine it just suspends it and places it in a state where it will
  * not cause the end device to power up. none
  */
 static void scu_link_layer_stop_protocol_engine(
-	struct scic_sds_phy *sci_phy)
+	struct isci_phy *iphy)
 {
 	u32 scu_sas_pcfg_value;
 	u32 enable_spinup_value;
 
 	/* Suspend the protocol engine and place it in a sata spinup hold state */
 	scu_sas_pcfg_value =
-		readl(&sci_phy->link_layer_registers->phy_configuration);
+		readl(&iphy->link_layer_registers->phy_configuration);
 	scu_sas_pcfg_value |=
 		(SCU_SAS_PCFG_GEN_BIT(OOB_RESET) |
 		 SCU_SAS_PCFG_GEN_BIT(SUSPEND_PROTOCOL_ENGINE) |
 		 SCU_SAS_PCFG_GEN_BIT(SATA_SPINUP_HOLD));
 	writel(scu_sas_pcfg_value,
-	       &sci_phy->link_layer_registers->phy_configuration);
+	       &iphy->link_layer_registers->phy_configuration);
 
 	/* Disable the notify enable spinup primitives */
-	enable_spinup_value = readl(&sci_phy->link_layer_registers->notify_enable_spinup_control);
+	enable_spinup_value = readl(&iphy->link_layer_registers->notify_enable_spinup_control);
 	enable_spinup_value &= ~SCU_ENSPINUP_GEN_BIT(ENABLE);
-	writel(enable_spinup_value, &sci_phy->link_layer_registers->notify_enable_spinup_control);
+	writel(enable_spinup_value, &iphy->link_layer_registers->notify_enable_spinup_control);
 }
 
 /**
  *
  *
- * This method will start the OOB/SN state machine for this struct scic_sds_phy object.
+ * This method will start the OOB/SN state machine for this struct isci_phy object.
  */
 static void scu_link_layer_start_oob(
-	struct scic_sds_phy *sci_phy)
+	struct isci_phy *iphy)
 {
 	u32 scu_sas_pcfg_value;
 
 	scu_sas_pcfg_value =
-		readl(&sci_phy->link_layer_registers->phy_configuration);
+		readl(&iphy->link_layer_registers->phy_configuration);
 	scu_sas_pcfg_value |= SCU_SAS_PCFG_GEN_BIT(OOB_ENABLE);
 	scu_sas_pcfg_value &=
 		~(SCU_SAS_PCFG_GEN_BIT(OOB_RESET) |
 		SCU_SAS_PCFG_GEN_BIT(HARD_RESET));
 	writel(scu_sas_pcfg_value,
-	       &sci_phy->link_layer_registers->phy_configuration);
+	       &iphy->link_layer_registers->phy_configuration);
 }
 
 /**
@@ -1150,7 +1147,7 @@ static void scu_link_layer_start_oob(
  * hard reset bit set.
  */
 static void scu_link_layer_tx_hard_reset(
-	struct scic_sds_phy *sci_phy)
+	struct isci_phy *iphy)
 {
 	u32 phy_configuration_value;
 
@@ -1158,91 +1155,91 @@ static void scu_link_layer_tx_hard_reset(
 	 * SAS Phys must wait for the HARD_RESET_TX event notification to transition
 	 * to the starting state. */
 	phy_configuration_value =
-		readl(&sci_phy->link_layer_registers->phy_configuration);
+		readl(&iphy->link_layer_registers->phy_configuration);
 	phy_configuration_value |=
 		(SCU_SAS_PCFG_GEN_BIT(HARD_RESET) |
 		 SCU_SAS_PCFG_GEN_BIT(OOB_RESET));
 	writel(phy_configuration_value,
-	       &sci_phy->link_layer_registers->phy_configuration);
+	       &iphy->link_layer_registers->phy_configuration);
 
 	/* Now take the OOB state machine out of reset */
 	phy_configuration_value |= SCU_SAS_PCFG_GEN_BIT(OOB_ENABLE);
 	phy_configuration_value &= ~SCU_SAS_PCFG_GEN_BIT(OOB_RESET);
 	writel(phy_configuration_value,
-	       &sci_phy->link_layer_registers->phy_configuration);
+	       &iphy->link_layer_registers->phy_configuration);
 }
 
 static void scic_sds_phy_stopped_state_enter(struct sci_base_state_machine *sm)
 {
-	struct scic_sds_phy *sci_phy = container_of(sm, typeof(*sci_phy), sm);
+	struct isci_phy *iphy = container_of(sm, typeof(*iphy), sm);
 
 	/*
 	 * @todo We need to get to the controller to place this PE in a
 	 * reset state
 	 */
-	sci_del_timer(&sci_phy->sata_timer);
+	sci_del_timer(&iphy->sata_timer);
 
-	scu_link_layer_stop_protocol_engine(sci_phy);
+	scu_link_layer_stop_protocol_engine(iphy);
 
-	if (sci_phy->sm.previous_state_id != SCI_PHY_INITIAL)
-		scic_sds_controller_link_down(scic_sds_phy_get_controller(sci_phy),
-					      phy_get_non_dummy_port(sci_phy),
-					      sci_phy);
+	if (iphy->sm.previous_state_id != SCI_PHY_INITIAL)
+		scic_sds_controller_link_down(scic_sds_phy_get_controller(iphy),
+					      phy_get_non_dummy_port(iphy),
+					      iphy);
 }
 
 static void scic_sds_phy_starting_state_enter(struct sci_base_state_machine *sm)
 {
-	struct scic_sds_phy *sci_phy = container_of(sm, typeof(*sci_phy), sm);
+	struct isci_phy *iphy = container_of(sm, typeof(*iphy), sm);
 
-	scu_link_layer_stop_protocol_engine(sci_phy);
-	scu_link_layer_start_oob(sci_phy);
+	scu_link_layer_stop_protocol_engine(iphy);
+	scu_link_layer_start_oob(iphy);
 
 	/* We don't know what kind of phy we are going to be just yet */
-	sci_phy->protocol = SCIC_SDS_PHY_PROTOCOL_UNKNOWN;
-	sci_phy->bcn_received_while_port_unassigned = false;
+	iphy->protocol = SCIC_SDS_PHY_PROTOCOL_UNKNOWN;
+	iphy->bcn_received_while_port_unassigned = false;
 
-	if (sci_phy->sm.previous_state_id == SCI_PHY_READY)
-		scic_sds_controller_link_down(scic_sds_phy_get_controller(sci_phy),
-					      phy_get_non_dummy_port(sci_phy),
-					      sci_phy);
+	if (iphy->sm.previous_state_id == SCI_PHY_READY)
+		scic_sds_controller_link_down(scic_sds_phy_get_controller(iphy),
+					      phy_get_non_dummy_port(iphy),
+					      iphy);
 
-	sci_change_state(&sci_phy->sm, SCI_PHY_SUB_INITIAL);
+	sci_change_state(&iphy->sm, SCI_PHY_SUB_INITIAL);
 }
 
 static void scic_sds_phy_ready_state_enter(struct sci_base_state_machine *sm)
 {
-	struct scic_sds_phy *sci_phy = container_of(sm, typeof(*sci_phy), sm);
+	struct isci_phy *iphy = container_of(sm, typeof(*iphy), sm);
 
-	scic_sds_controller_link_up(scic_sds_phy_get_controller(sci_phy),
-				    phy_get_non_dummy_port(sci_phy),
-				    sci_phy);
+	scic_sds_controller_link_up(scic_sds_phy_get_controller(iphy),
+				    phy_get_non_dummy_port(iphy),
+				    iphy);
 
 }
 
 static void scic_sds_phy_ready_state_exit(struct sci_base_state_machine *sm)
 {
-	struct scic_sds_phy *sci_phy = container_of(sm, typeof(*sci_phy), sm);
+	struct isci_phy *iphy = container_of(sm, typeof(*iphy), sm);
 
-	scic_sds_phy_suspend(sci_phy);
+	scic_sds_phy_suspend(iphy);
 }
 
 static void scic_sds_phy_resetting_state_enter(struct sci_base_state_machine *sm)
 {
-	struct scic_sds_phy *sci_phy = container_of(sm, typeof(*sci_phy), sm);
+	struct isci_phy *iphy = container_of(sm, typeof(*iphy), sm);
 
 	/* The phy is being reset, therefore deactivate it from the port.  In
 	 * the resetting state we don't notify the user regarding link up and
 	 * link down notifications
 	 */
-	scic_sds_port_deactivate_phy(sci_phy->owning_port, sci_phy, false);
+	scic_sds_port_deactivate_phy(iphy->owning_port, iphy, false);
 
-	if (sci_phy->protocol == SCIC_SDS_PHY_PROTOCOL_SAS) {
-		scu_link_layer_tx_hard_reset(sci_phy);
+	if (iphy->protocol == SCIC_SDS_PHY_PROTOCOL_SAS) {
+		scu_link_layer_tx_hard_reset(iphy);
 	} else {
 		/* The SCU does not need to have a discrete reset state so
 		 * just go back to the starting state.
 		 */
-		sci_change_state(&sci_phy->sm, SCI_PHY_STARTING);
+		sci_change_state(&iphy->sm, SCI_PHY_STARTING);
 	}
 }
 
@@ -1293,21 +1290,21 @@ static const struct sci_base_state scic_sds_phy_state_table[] = {
 	[SCI_PHY_FINAL] = { },
 };
 
-void scic_sds_phy_construct(struct scic_sds_phy *sci_phy,
+void scic_sds_phy_construct(struct isci_phy *iphy,
 			    struct scic_sds_port *owning_port, u8 phy_index)
 {
-	sci_init_sm(&sci_phy->sm, scic_sds_phy_state_table, SCI_PHY_INITIAL);
+	sci_init_sm(&iphy->sm, scic_sds_phy_state_table, SCI_PHY_INITIAL);
 
 	/* Copy the rest of the input data to our locals */
-	sci_phy->owning_port = owning_port;
-	sci_phy->phy_index = phy_index;
-	sci_phy->bcn_received_while_port_unassigned = false;
-	sci_phy->protocol = SCIC_SDS_PHY_PROTOCOL_UNKNOWN;
-	sci_phy->link_layer_registers = NULL;
-	sci_phy->max_negotiated_speed = SAS_LINK_RATE_UNKNOWN;
+	iphy->owning_port = owning_port;
+	iphy->phy_index = phy_index;
+	iphy->bcn_received_while_port_unassigned = false;
+	iphy->protocol = SCIC_SDS_PHY_PROTOCOL_UNKNOWN;
+	iphy->link_layer_registers = NULL;
+	iphy->max_negotiated_speed = SAS_LINK_RATE_UNKNOWN;
 
 	/* Create the SIGNATURE FIS Timeout timer for this phy */
-	sci_init_timer(&sci_phy->sata_timer, phy_sata_timeout);
+	sci_init_timer(&iphy->sata_timer, phy_sata_timeout);
 }
 
 void isci_phy_init(struct isci_phy *iphy, struct isci_host *ihost, int index)
@@ -1368,14 +1365,14 @@ int isci_phy_control(struct asd_sas_phy *sas_phy,
 	switch (func) {
 	case PHY_FUNC_DISABLE:
 		spin_lock_irqsave(&ihost->scic_lock, flags);
-		scic_sds_phy_stop(&iphy->sci);
+		scic_sds_phy_stop(iphy);
 		spin_unlock_irqrestore(&ihost->scic_lock, flags);
 		break;
 
 	case PHY_FUNC_LINK_RESET:
 		spin_lock_irqsave(&ihost->scic_lock, flags);
-		scic_sds_phy_stop(&iphy->sci);
-		scic_sds_phy_start(&iphy->sci);
+		scic_sds_phy_stop(iphy);
+		scic_sds_phy_start(iphy);
 		spin_unlock_irqrestore(&ihost->scic_lock, flags);
 		break;
 

commit 5076a1a97e2fa61c847a5fdd4b1991faf7716da6
Author: Dan Williams <dan.j.williams@intel.com>
Date:   Mon Jun 27 14:57:03 2011 -0700

    isci: unify isci_request and scic_sds_request
    
    They are one in the same object so remove the distinction.  The near
    duplicate fields (owning_controller, and isci_host) will be cleaned up
    after the scic_sds_contoller isci_host unification.
    
    Reported-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/drivers/scsi/isci/phy.c b/drivers/scsi/isci/phy.c
index c01d76210aa2..98d93aeea75d 100644
--- a/drivers/scsi/isci/phy.c
+++ b/drivers/scsi/isci/phy.c
@@ -983,7 +983,7 @@ enum sci_status scic_sds_phy_frame_handler(struct scic_sds_phy *sci_phy,
 			"%s: in wrong state: %d\n", __func__, state);
 		return SCI_FAILURE_INVALID_STATE;
 	}
-	
+
 }
 
 static void scic_sds_phy_starting_initial_substate_enter(struct sci_base_state_machine *sm)

commit 4cffe13e0dfd00f90c86b0153c751dab61a1bf1d
Author: Dan Williams <dan.j.williams@intel.com>
Date:   Thu Jun 23 23:44:52 2011 -0700

    isci: fix frame received locking
    
    Updates to the frame_rcvd before need to be atomic with respect to when
    they are evaluated by libsas.
    
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/drivers/scsi/isci/phy.c b/drivers/scsi/isci/phy.c
index 93a401dfbd30..c01d76210aa2 100644
--- a/drivers/scsi/isci/phy.c
+++ b/drivers/scsi/isci/phy.c
@@ -893,6 +893,7 @@ enum sci_status scic_sds_phy_frame_handler(struct scic_sds_phy *sci_phy,
 	enum scic_sds_phy_states state = sci_phy->sm.current_state_id;
 	struct scic_sds_controller *scic = sci_phy->owning_port->owning_controller;
 	enum sci_status result;
+	unsigned long flags;
 
 	switch (state) {
 	case SCI_PHY_SUB_AWAIT_IAF_UF: {
@@ -911,7 +912,9 @@ enum sci_status scic_sds_phy_frame_handler(struct scic_sds_phy *sci_phy,
 		if (iaf.frame_type == 0) {
 			u32 state;
 
+			spin_lock_irqsave(&iphy->sas_phy.frame_rcvd_lock, flags);
 			memcpy(&iphy->frame_rcvd.iaf, &iaf, sizeof(iaf));
+			spin_unlock_irqrestore(&iphy->sas_phy.frame_rcvd_lock, flags);
 			if (iaf.smp_tport) {
 				/* We got the IAF for an expander PHY go to the final
 				 * state since there are no power requirements for
@@ -954,9 +957,11 @@ enum sci_status scic_sds_phy_frame_handler(struct scic_sds_phy *sci_phy,
 								      frame_index,
 								      (void **)&fis_frame_data);
 
+			spin_lock_irqsave(&iphy->sas_phy.frame_rcvd_lock, flags);
 			scic_sds_controller_copy_sata_response(&iphy->frame_rcvd.fis,
 							       frame_header,
 							       fis_frame_data);
+			spin_unlock_irqrestore(&iphy->sas_phy.frame_rcvd_lock, flags);
 
 			/* got IAF we can now go to the await spinup semaphore state */
 			sci_change_state(&sci_phy->sm, SCI_PHY_SUB_FINAL);

commit 9b917987fd16d0687afe550a02f68099419f5d43
Author: Jeff Skirvin <jeffrey.d.skirvin@intel.com>
Date:   Mon Jun 20 14:09:31 2011 -0700

    isci: Disable link layer hang detection
    
    Some targets exceed the hang detect timer.  Use the OS timeout to
    catch hung tasks.
    
    Signed-off-by: Jeff Skirvin <jeffrey.d.skirvin@intel.com>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/drivers/scsi/isci/phy.c b/drivers/scsi/isci/phy.c
index 784c9a71333a..93a401dfbd30 100644
--- a/drivers/scsi/isci/phy.c
+++ b/drivers/scsi/isci/phy.c
@@ -242,11 +242,8 @@ scic_sds_phy_link_layer_initialization(struct scic_sds_phy *sci_phy,
 			&sci_phy->link_layer_registers->maximum_arbitration_wait_timer_timeout);
 	}
 
-	/*
-	 * Set the link layer hang detection to 500ms (0x1F4) from its default
-	 * value of 128ms.  Max value is 511 ms.
-	 */
-	writel(0x1F4, &sci_phy->link_layer_registers->link_layer_hang_detection_timeout);
+	/* Disable link layer hang detection, rely on the OS timeout for I/O timeouts. */
+	writel(0, &sci_phy->link_layer_registers->link_layer_hang_detection_timeout);
 
 	/* We can exit the initial state to the stopped state */
 	sci_change_state(&sci_phy->sm, SCI_PHY_STOPPED);

commit 12ef65444de9d387a383b9991960848bed5bbe74
Author: Edmund Nadolski <edmund.nadolski@intel.com>
Date:   Thu Jun 2 00:10:50 2011 +0000

    isci: additional state machine cleanup
    
    Additional state machine cleanups:
    
     o Remove static functions sci_state_machine_exit_state() and
       sci_state_machine_enter_state()
     o Combines sci_base_state_machine_construct() and
       sci_base_state_machine_start() into a single function,
       sci_init_sm()
     o Remove sci_base_state_machine_stop() which is unused.
     o Kill state_machine.[ch]
    
    Signed-off-by: Edmund Nadolski <edmund.nadolski@intel.com>
    [fixed too large to inline functions]
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/drivers/scsi/isci/phy.c b/drivers/scsi/isci/phy.c
index 9de21c719351..784c9a71333a 100644
--- a/drivers/scsi/isci/phy.c
+++ b/drivers/scsi/isci/phy.c
@@ -1294,11 +1294,7 @@ static const struct sci_base_state scic_sds_phy_state_table[] = {
 void scic_sds_phy_construct(struct scic_sds_phy *sci_phy,
 			    struct scic_sds_port *owning_port, u8 phy_index)
 {
-	sci_base_state_machine_construct(&sci_phy->sm,
-					 scic_sds_phy_state_table,
-					 SCI_PHY_INITIAL);
-
-	sci_base_state_machine_start(&sci_phy->sm);
+	sci_init_sm(&sci_phy->sm, scic_sds_phy_state_table, SCI_PHY_INITIAL);
 
 	/* Copy the rest of the input data to our locals */
 	sci_phy->owning_port = owning_port;

commit e301370ac553a9a0ac0d1d25e769b86cf60395b3
Author: Edmund Nadolski <edmund.nadolski@intel.com>
Date:   Thu Jun 2 00:10:43 2011 +0000

    isci: state machine cleanup
    
    This cleans up several areas of the state machine mechanism:
    
     o Rename sci_base_state_machine_change_state to sci_change_state
     o Remove sci_base_state_machine_get_state function
     o Rename 'state_machine' struct member to 'sm' in client structs
     o Shorten the name of request states
     o Shorten state machine state names as follows:
            SCI_BASE_CONTROLLER_STATE_xxx to SCIC_xxx
            SCI_BASE_PHY_STATE_xxx to SCI_PHY_xxx
            SCIC_SDS_PHY_STARTING_SUBSTATE_xxx to SCI_PHY_SUB_xxx
            SCI_BASE_PORT_STATE_xxx to SCI_PORT_xxx and
            SCIC_SDS_PORT_READY_SUBSTATE_xxx to SCI_PORT_SUB_xxx
            SCI_BASE_REMOTE_DEVICE_STATE_xxx to SCI_DEV_xxx
            SCIC_SDS_STP_REMOTE_DEVICE_READY_SUBSTATE_xxx to SCI_STP_DEV_xxx
            SCIC_SDS_SMP_REMOTE_DEVICE_READY_SUBSTATE_xxx to SCI_SMP_DEV_xxx
            SCIC_SDS_REMOTE_NODE_CONTEXT_xxx_STATE to SCI_RNC_xxx
    
    Signed-off-by: Edmund Nadolski <edmund.nadolski@intel.com>
    Signed-off-by: Dave Jiang <dave.jiang@intel.com>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/drivers/scsi/isci/phy.c b/drivers/scsi/isci/phy.c
index fc196e389ffb..9de21c719351 100644
--- a/drivers/scsi/isci/phy.c
+++ b/drivers/scsi/isci/phy.c
@@ -249,8 +249,7 @@ scic_sds_phy_link_layer_initialization(struct scic_sds_phy *sci_phy,
 	writel(0x1F4, &sci_phy->link_layer_registers->link_layer_hang_detection_timeout);
 
 	/* We can exit the initial state to the stopped state */
-	sci_base_state_machine_change_state(&sci_phy->state_machine,
-					    SCI_BASE_PHY_STATE_STOPPED);
+	sci_change_state(&sci_phy->sm, SCI_PHY_STOPPED);
 
 	return SCI_SUCCESS;
 }
@@ -273,8 +272,7 @@ static void phy_sata_timeout(unsigned long data)
 		 __func__,
 		 sci_phy);
 
-	sci_base_state_machine_change_state(&sci_phy->state_machine,
-					    SCI_BASE_PHY_STATE_STARTING);
+	sci_change_state(&sci_phy->sm, SCI_PHY_STARTING);
 done:
 	spin_unlock_irqrestore(&ihost->scic_lock, flags);
 }
@@ -342,8 +340,7 @@ enum sci_status scic_sds_phy_initialize(
 	/*
 	 * There is nothing that needs to be done in this state just
 	 * transition to the stopped state. */
-	sci_base_state_machine_change_state(&sci_phy->state_machine,
-					    SCI_BASE_PHY_STATE_STOPPED);
+	sci_change_state(&sci_phy->sm, SCI_PHY_STOPPED);
 
 	return SCI_SUCCESS;
 }
@@ -436,34 +433,33 @@ void scic_sds_phy_get_protocols(struct scic_sds_phy *sci_phy,
 
 enum sci_status scic_sds_phy_start(struct scic_sds_phy *sci_phy)
 {
-	enum scic_sds_phy_states state = sci_phy->state_machine.current_state_id;
+	enum scic_sds_phy_states state = sci_phy->sm.current_state_id;
 
-	if (state != SCI_BASE_PHY_STATE_STOPPED) {
+	if (state != SCI_PHY_STOPPED) {
 		dev_dbg(sciphy_to_dev(sci_phy),
 			 "%s: in wrong state: %d\n", __func__, state);
 		return SCI_FAILURE_INVALID_STATE;
 	}
 
-	sci_base_state_machine_change_state(&sci_phy->state_machine,
-					    SCI_BASE_PHY_STATE_STARTING);
+	sci_change_state(&sci_phy->sm, SCI_PHY_STARTING);
 	return SCI_SUCCESS;
 }
 
 enum sci_status scic_sds_phy_stop(struct scic_sds_phy *sci_phy)
 {
-	enum scic_sds_phy_states state = sci_phy->state_machine.current_state_id;
+	enum scic_sds_phy_states state = sci_phy->sm.current_state_id;
 
 	switch (state) {
-	case SCIC_SDS_PHY_STARTING_SUBSTATE_INITIAL:
-	case SCIC_SDS_PHY_STARTING_SUBSTATE_AWAIT_OSSP_EN:
-	case SCIC_SDS_PHY_STARTING_SUBSTATE_AWAIT_SAS_SPEED_EN:
-	case SCIC_SDS_PHY_STARTING_SUBSTATE_AWAIT_SAS_POWER:
-	case SCIC_SDS_PHY_STARTING_SUBSTATE_AWAIT_SATA_POWER:
-	case SCIC_SDS_PHY_STARTING_SUBSTATE_AWAIT_SATA_PHY_EN:
-	case SCIC_SDS_PHY_STARTING_SUBSTATE_AWAIT_SATA_SPEED_EN:
-	case SCIC_SDS_PHY_STARTING_SUBSTATE_AWAIT_SIG_FIS_UF:
-	case SCIC_SDS_PHY_STARTING_SUBSTATE_FINAL:
-	case SCI_BASE_PHY_STATE_READY:
+	case SCI_PHY_SUB_INITIAL:
+	case SCI_PHY_SUB_AWAIT_OSSP_EN:
+	case SCI_PHY_SUB_AWAIT_SAS_SPEED_EN:
+	case SCI_PHY_SUB_AWAIT_SAS_POWER:
+	case SCI_PHY_SUB_AWAIT_SATA_POWER:
+	case SCI_PHY_SUB_AWAIT_SATA_PHY_EN:
+	case SCI_PHY_SUB_AWAIT_SATA_SPEED_EN:
+	case SCI_PHY_SUB_AWAIT_SIG_FIS_UF:
+	case SCI_PHY_SUB_FINAL:
+	case SCI_PHY_READY:
 		break;
 	default:
 		dev_dbg(sciphy_to_dev(sci_phy),
@@ -471,32 +467,30 @@ enum sci_status scic_sds_phy_stop(struct scic_sds_phy *sci_phy)
 		return SCI_FAILURE_INVALID_STATE;
 	}
 
-	sci_base_state_machine_change_state(&sci_phy->state_machine,
-					    SCI_BASE_PHY_STATE_STOPPED);
+	sci_change_state(&sci_phy->sm, SCI_PHY_STOPPED);
 	return SCI_SUCCESS;
 }
 
 enum sci_status scic_sds_phy_reset(struct scic_sds_phy *sci_phy)
 {
-	enum scic_sds_phy_states state = sci_phy->state_machine.current_state_id;
+	enum scic_sds_phy_states state = sci_phy->sm.current_state_id;
 
-	if (state != SCI_BASE_PHY_STATE_READY) {
+	if (state != SCI_PHY_READY) {
 		dev_dbg(sciphy_to_dev(sci_phy),
 			"%s: in wrong state: %d\n", __func__, state);
 		return SCI_FAILURE_INVALID_STATE;
 	}
 
-	sci_base_state_machine_change_state(&sci_phy->state_machine,
-					    SCI_BASE_PHY_STATE_RESETTING);
+	sci_change_state(&sci_phy->sm, SCI_PHY_RESETTING);
 	return SCI_SUCCESS;
 }
 
 enum sci_status scic_sds_phy_consume_power_handler(struct scic_sds_phy *sci_phy)
 {
-	enum scic_sds_phy_states state = sci_phy->state_machine.current_state_id;
+	enum scic_sds_phy_states state = sci_phy->sm.current_state_id;
 
 	switch (state) {
-	case SCIC_SDS_PHY_STARTING_SUBSTATE_AWAIT_SAS_POWER: {
+	case SCI_PHY_SUB_AWAIT_SAS_POWER: {
 		u32 enable_spinup;
 
 		enable_spinup = readl(&sci_phy->link_layer_registers->notify_enable_spinup_control);
@@ -504,12 +498,11 @@ enum sci_status scic_sds_phy_consume_power_handler(struct scic_sds_phy *sci_phy)
 		writel(enable_spinup, &sci_phy->link_layer_registers->notify_enable_spinup_control);
 
 		/* Change state to the final state this substate machine has run to completion */
-		sci_base_state_machine_change_state(&sci_phy->state_machine,
-						    SCIC_SDS_PHY_STARTING_SUBSTATE_FINAL);
+		sci_change_state(&sci_phy->sm, SCI_PHY_SUB_FINAL);
 
 		return SCI_SUCCESS;
 	}
-	case SCIC_SDS_PHY_STARTING_SUBSTATE_AWAIT_SATA_POWER: {
+	case SCI_PHY_SUB_AWAIT_SATA_POWER: {
 		u32 scu_sas_pcfg_value;
 
 		/* Release the spinup hold state and reset the OOB state machine */
@@ -528,8 +521,7 @@ enum sci_status scic_sds_phy_consume_power_handler(struct scic_sds_phy *sci_phy)
 			&sci_phy->link_layer_registers->phy_configuration);
 
 		/* Change state to the final state this substate machine has run to completion */
-		sci_base_state_machine_change_state(&sci_phy->state_machine,
-						    SCIC_SDS_PHY_STARTING_SUBSTATE_AWAIT_SATA_PHY_EN);
+		sci_change_state(&sci_phy->sm, SCI_PHY_SUB_AWAIT_SATA_PHY_EN);
 
 		return SCI_SUCCESS;
 	}
@@ -566,10 +558,7 @@ static void scic_sds_phy_start_sas_link_training(
 	writel(phy_control,
 		&sci_phy->link_layer_registers->phy_configuration);
 
-	sci_base_state_machine_change_state(
-		&sci_phy->state_machine,
-		SCIC_SDS_PHY_STARTING_SUBSTATE_AWAIT_SAS_SPEED_EN
-		);
+	sci_change_state(&sci_phy->sm, SCI_PHY_SUB_AWAIT_SAS_SPEED_EN);
 
 	sci_phy->protocol = SCIC_SDS_PHY_PROTOCOL_SAS;
 }
@@ -585,10 +574,7 @@ static void scic_sds_phy_start_sas_link_training(
 static void scic_sds_phy_start_sata_link_training(
 	struct scic_sds_phy *sci_phy)
 {
-	sci_base_state_machine_change_state(
-		&sci_phy->state_machine,
-		SCIC_SDS_PHY_STARTING_SUBSTATE_AWAIT_SATA_POWER
-		);
+	sci_change_state(&sci_phy->sm, SCI_PHY_SUB_AWAIT_SATA_POWER);
 
 	sci_phy->protocol = SCIC_SDS_PHY_PROTOCOL_SATA;
 }
@@ -611,17 +597,16 @@ static void scic_sds_phy_complete_link_training(
 {
 	sci_phy->max_negotiated_speed = max_link_rate;
 
-	sci_base_state_machine_change_state(&sci_phy->state_machine,
-					    next_state);
+	sci_change_state(&sci_phy->sm, next_state);
 }
 
 enum sci_status scic_sds_phy_event_handler(struct scic_sds_phy *sci_phy,
 					   u32 event_code)
 {
-	enum scic_sds_phy_states state = sci_phy->state_machine.current_state_id;
+	enum scic_sds_phy_states state = sci_phy->sm.current_state_id;
 
 	switch (state) {
-	case SCIC_SDS_PHY_STARTING_SUBSTATE_AWAIT_OSSP_EN:
+	case SCI_PHY_SUB_AWAIT_OSSP_EN:
 		switch (scu_get_event_code(event_code)) {
 		case SCU_EVENT_SAS_PHY_DETECTED:
 			scic_sds_phy_start_sas_link_training(sci_phy);
@@ -640,7 +625,7 @@ enum sci_status scic_sds_phy_event_handler(struct scic_sds_phy *sci_phy,
 			return SCI_FAILURE;
 		}
 		return SCI_SUCCESS;
-	case SCIC_SDS_PHY_STARTING_SUBSTATE_AWAIT_SAS_SPEED_EN:
+	case SCI_PHY_SUB_AWAIT_SAS_SPEED_EN:
 		switch (scu_get_event_code(event_code)) {
 		case SCU_EVENT_SAS_PHY_DETECTED:
 			/*
@@ -652,21 +637,21 @@ enum sci_status scic_sds_phy_event_handler(struct scic_sds_phy *sci_phy,
 			scic_sds_phy_complete_link_training(
 				sci_phy,
 				SAS_LINK_RATE_1_5_GBPS,
-				SCIC_SDS_PHY_STARTING_SUBSTATE_AWAIT_IAF_UF);
+				SCI_PHY_SUB_AWAIT_IAF_UF);
 			break;
 		case SCU_EVENT_SAS_30:
 		case SCU_EVENT_SAS_30_SSC:
 			scic_sds_phy_complete_link_training(
 				sci_phy,
 				SAS_LINK_RATE_3_0_GBPS,
-				SCIC_SDS_PHY_STARTING_SUBSTATE_AWAIT_IAF_UF);
+				SCI_PHY_SUB_AWAIT_IAF_UF);
 			break;
 		case SCU_EVENT_SAS_60:
 		case SCU_EVENT_SAS_60_SSC:
 			scic_sds_phy_complete_link_training(
 				sci_phy,
 				SAS_LINK_RATE_6_0_GBPS,
-				SCIC_SDS_PHY_STARTING_SUBSTATE_AWAIT_IAF_UF);
+				SCI_PHY_SUB_AWAIT_IAF_UF);
 			break;
 		case SCU_EVENT_SATA_SPINUP_HOLD:
 			/*
@@ -676,8 +661,7 @@ enum sci_status scic_sds_phy_event_handler(struct scic_sds_phy *sci_phy,
 			break;
 		case SCU_EVENT_LINK_FAILURE:
 			/* Link failure change state back to the starting state */
-			sci_base_state_machine_change_state(&sci_phy->state_machine,
-							    SCI_BASE_PHY_STATE_STARTING);
+			sci_change_state(&sci_phy->sm, SCI_PHY_STARTING);
 			break;
 		default:
 			dev_warn(sciphy_to_dev(sci_phy),
@@ -689,7 +673,7 @@ enum sci_status scic_sds_phy_event_handler(struct scic_sds_phy *sci_phy,
 			break;
 		}
 		return SCI_SUCCESS;
-	case SCIC_SDS_PHY_STARTING_SUBSTATE_AWAIT_IAF_UF:
+	case SCI_PHY_SUB_AWAIT_IAF_UF:
 		switch (scu_get_event_code(event_code)) {
 		case SCU_EVENT_SAS_PHY_DETECTED:
 			/* Backup the state machine */
@@ -706,8 +690,7 @@ enum sci_status scic_sds_phy_event_handler(struct scic_sds_phy *sci_phy,
 		case SCU_EVENT_LINK_FAILURE:
 		case SCU_EVENT_HARD_RESET_RECEIVED:
 			/* Start the oob/sn state machine over again */
-			sci_base_state_machine_change_state(&sci_phy->state_machine,
-							    SCI_BASE_PHY_STATE_STARTING);
+			sci_change_state(&sci_phy->sm, SCI_PHY_STARTING);
 			break;
 		default:
 			dev_warn(sciphy_to_dev(sci_phy),
@@ -717,12 +700,11 @@ enum sci_status scic_sds_phy_event_handler(struct scic_sds_phy *sci_phy,
 			return SCI_FAILURE;
 		}
 		return SCI_SUCCESS;
-	case SCIC_SDS_PHY_STARTING_SUBSTATE_AWAIT_SAS_POWER:
+	case SCI_PHY_SUB_AWAIT_SAS_POWER:
 		switch (scu_get_event_code(event_code)) {
 		case SCU_EVENT_LINK_FAILURE:
 			/* Link failure change state back to the starting state */
-			sci_base_state_machine_change_state(&sci_phy->state_machine,
-							    SCI_BASE_PHY_STATE_STARTING);
+			sci_change_state(&sci_phy->sm, SCI_PHY_STARTING);
 			break;
 		default:
 			dev_warn(sciphy_to_dev(sci_phy),
@@ -733,12 +715,11 @@ enum sci_status scic_sds_phy_event_handler(struct scic_sds_phy *sci_phy,
 			return SCI_FAILURE;
 		}
 		return SCI_SUCCESS;
-	case SCIC_SDS_PHY_STARTING_SUBSTATE_AWAIT_SATA_POWER:
+	case SCI_PHY_SUB_AWAIT_SATA_POWER:
 		switch (scu_get_event_code(event_code)) {
 		case SCU_EVENT_LINK_FAILURE:
 			/* Link failure change state back to the starting state */
-			sci_base_state_machine_change_state(&sci_phy->state_machine,
-							    SCI_BASE_PHY_STATE_STARTING);
+			sci_change_state(&sci_phy->sm, SCI_PHY_STARTING);
 			break;
 		case SCU_EVENT_SATA_SPINUP_HOLD:
 			/* These events are received every 10ms and are
@@ -762,12 +743,11 @@ enum sci_status scic_sds_phy_event_handler(struct scic_sds_phy *sci_phy,
 			return SCI_FAILURE;
 		}
 		return SCI_SUCCESS;
-	case SCIC_SDS_PHY_STARTING_SUBSTATE_AWAIT_SATA_PHY_EN:
+	case SCI_PHY_SUB_AWAIT_SATA_PHY_EN:
 		switch (scu_get_event_code(event_code)) {
 		case SCU_EVENT_LINK_FAILURE:
 			/* Link failure change state back to the starting state */
-			sci_base_state_machine_change_state(&sci_phy->state_machine,
-							    SCI_BASE_PHY_STATE_STARTING);
+			sci_change_state(&sci_phy->sm, SCI_PHY_STARTING);
 			break;
 		case SCU_EVENT_SATA_SPINUP_HOLD:
 			/* These events might be received since we dont know how many may be in
@@ -778,8 +758,7 @@ enum sci_status scic_sds_phy_event_handler(struct scic_sds_phy *sci_phy,
 			sci_phy->protocol = SCIC_SDS_PHY_PROTOCOL_SATA;
 
 			/* We have received the SATA PHY notification change state */
-			sci_base_state_machine_change_state(&sci_phy->state_machine,
-							    SCIC_SDS_PHY_STARTING_SUBSTATE_AWAIT_SATA_SPEED_EN);
+			sci_change_state(&sci_phy->sm, SCI_PHY_SUB_AWAIT_SATA_SPEED_EN);
 			break;
 		case SCU_EVENT_SAS_PHY_DETECTED:
 			/* There has been a change in the phy type before OOB/SN for the
@@ -797,7 +776,7 @@ enum sci_status scic_sds_phy_event_handler(struct scic_sds_phy *sci_phy,
 			return SCI_FAILURE;;
 		}
 		return SCI_SUCCESS;
-	case SCIC_SDS_PHY_STARTING_SUBSTATE_AWAIT_SATA_SPEED_EN:
+	case SCI_PHY_SUB_AWAIT_SATA_SPEED_EN:
 		switch (scu_get_event_code(event_code)) {
 		case SCU_EVENT_SATA_PHY_DETECTED:
 			/*
@@ -809,26 +788,25 @@ enum sci_status scic_sds_phy_event_handler(struct scic_sds_phy *sci_phy,
 			scic_sds_phy_complete_link_training(
 				sci_phy,
 				SAS_LINK_RATE_1_5_GBPS,
-				SCIC_SDS_PHY_STARTING_SUBSTATE_AWAIT_SIG_FIS_UF);
+				SCI_PHY_SUB_AWAIT_SIG_FIS_UF);
 			break;
 		case SCU_EVENT_SATA_30:
 		case SCU_EVENT_SATA_30_SSC:
 			scic_sds_phy_complete_link_training(
 				sci_phy,
 				SAS_LINK_RATE_3_0_GBPS,
-				SCIC_SDS_PHY_STARTING_SUBSTATE_AWAIT_SIG_FIS_UF);
+				SCI_PHY_SUB_AWAIT_SIG_FIS_UF);
 			break;
 		case SCU_EVENT_SATA_60:
 		case SCU_EVENT_SATA_60_SSC:
 			scic_sds_phy_complete_link_training(
 				sci_phy,
 				SAS_LINK_RATE_6_0_GBPS,
-				SCIC_SDS_PHY_STARTING_SUBSTATE_AWAIT_SIG_FIS_UF);
+				SCI_PHY_SUB_AWAIT_SIG_FIS_UF);
 			break;
 		case SCU_EVENT_LINK_FAILURE:
 			/* Link failure change state back to the starting state */
-			sci_base_state_machine_change_state(&sci_phy->state_machine,
-							    SCI_BASE_PHY_STATE_STARTING);
+			sci_change_state(&sci_phy->sm, SCI_PHY_STARTING);
 			break;
 		case SCU_EVENT_SAS_PHY_DETECTED:
 			/*
@@ -846,18 +824,16 @@ enum sci_status scic_sds_phy_event_handler(struct scic_sds_phy *sci_phy,
 		}
 
 		return SCI_SUCCESS;
-	case SCIC_SDS_PHY_STARTING_SUBSTATE_AWAIT_SIG_FIS_UF:
+	case SCI_PHY_SUB_AWAIT_SIG_FIS_UF:
 		switch (scu_get_event_code(event_code)) {
 		case SCU_EVENT_SATA_PHY_DETECTED:
 			/* Backup the state machine */
-			sci_base_state_machine_change_state(&sci_phy->state_machine,
-							    SCIC_SDS_PHY_STARTING_SUBSTATE_AWAIT_SATA_SPEED_EN);
+			sci_change_state(&sci_phy->sm, SCI_PHY_SUB_AWAIT_SATA_SPEED_EN);
 			break;
 
 		case SCU_EVENT_LINK_FAILURE:
 			/* Link failure change state back to the starting state */
-			sci_base_state_machine_change_state(&sci_phy->state_machine,
-							    SCI_BASE_PHY_STATE_STARTING);
+			sci_change_state(&sci_phy->sm, SCI_PHY_STARTING);
 			break;
 
 		default:
@@ -870,12 +846,11 @@ enum sci_status scic_sds_phy_event_handler(struct scic_sds_phy *sci_phy,
 			return SCI_FAILURE;
 		}
 		return SCI_SUCCESS;
-	case SCI_BASE_PHY_STATE_READY:
+	case SCI_PHY_READY:
 		switch (scu_get_event_code(event_code)) {
 		case SCU_EVENT_LINK_FAILURE:
 			/* Link failure change state back to the starting state */
-			sci_base_state_machine_change_state(&sci_phy->state_machine,
-							    SCI_BASE_PHY_STATE_STARTING);
+			sci_change_state(&sci_phy->sm, SCI_PHY_STARTING);
 			break;
 		case SCU_EVENT_BROADCAST_CHANGE:
 			/* Broadcast change received. Notify the port. */
@@ -892,12 +867,11 @@ enum sci_status scic_sds_phy_event_handler(struct scic_sds_phy *sci_phy,
 			return SCI_FAILURE_INVALID_STATE;
 		}
 		return SCI_SUCCESS;
-	case SCI_BASE_PHY_STATE_RESETTING:
+	case SCI_PHY_RESETTING:
 		switch (scu_get_event_code(event_code)) {
 		case SCU_EVENT_HARD_RESET_TRANSMITTED:
 			/* Link failure change state back to the starting state */
-			sci_base_state_machine_change_state(&sci_phy->state_machine,
-							    SCI_BASE_PHY_STATE_STARTING);
+			sci_change_state(&sci_phy->sm, SCI_PHY_STARTING);
 			break;
 		default:
 			dev_warn(sciphy_to_dev(sci_phy),
@@ -919,12 +893,12 @@ enum sci_status scic_sds_phy_event_handler(struct scic_sds_phy *sci_phy,
 enum sci_status scic_sds_phy_frame_handler(struct scic_sds_phy *sci_phy,
 					   u32 frame_index)
 {
-	enum scic_sds_phy_states state = sci_phy->state_machine.current_state_id;
+	enum scic_sds_phy_states state = sci_phy->sm.current_state_id;
 	struct scic_sds_controller *scic = sci_phy->owning_port->owning_controller;
 	enum sci_status result;
 
 	switch (state) {
-	case SCIC_SDS_PHY_STARTING_SUBSTATE_AWAIT_IAF_UF: {
+	case SCI_PHY_SUB_AWAIT_IAF_UF: {
 		u32 *frame_words;
 		struct sas_identify_frame iaf;
 		struct isci_phy *iphy = sci_phy_to_iphy(sci_phy);
@@ -946,15 +920,14 @@ enum sci_status scic_sds_phy_frame_handler(struct scic_sds_phy *sci_phy,
 				 * state since there are no power requirements for
 				 * expander phys.
 				 */
-				state = SCIC_SDS_PHY_STARTING_SUBSTATE_FINAL;
+				state = SCI_PHY_SUB_FINAL;
 			} else {
 				/* We got the IAF we can now go to the await spinup
 				 * semaphore state
 				 */
-				state = SCIC_SDS_PHY_STARTING_SUBSTATE_AWAIT_SAS_POWER;
+				state = SCI_PHY_SUB_AWAIT_SAS_POWER;
 			}
-			sci_base_state_machine_change_state(&sci_phy->state_machine,
-							    state);
+			sci_change_state(&sci_phy->sm, state);
 			result = SCI_SUCCESS;
 		} else
 			dev_warn(sciphy_to_dev(sci_phy),
@@ -965,7 +938,7 @@ enum sci_status scic_sds_phy_frame_handler(struct scic_sds_phy *sci_phy,
 		scic_sds_controller_release_frame(scic, frame_index);
 		return result;
 	}
-	case SCIC_SDS_PHY_STARTING_SUBSTATE_AWAIT_SIG_FIS_UF: {
+	case SCI_PHY_SUB_AWAIT_SIG_FIS_UF: {
 		struct dev_to_host_fis *frame_header;
 		u32 *fis_frame_data;
 		struct isci_phy *iphy = sci_phy_to_iphy(sci_phy);
@@ -989,8 +962,7 @@ enum sci_status scic_sds_phy_frame_handler(struct scic_sds_phy *sci_phy,
 							       fis_frame_data);
 
 			/* got IAF we can now go to the await spinup semaphore state */
-			sci_base_state_machine_change_state(&sci_phy->state_machine,
-							    SCIC_SDS_PHY_STARTING_SUBSTATE_FINAL);
+			sci_change_state(&sci_phy->sm, SCI_PHY_SUB_FINAL);
 
 			result = SCI_SUCCESS;
 		} else
@@ -1014,16 +986,15 @@ enum sci_status scic_sds_phy_frame_handler(struct scic_sds_phy *sci_phy,
 
 static void scic_sds_phy_starting_initial_substate_enter(struct sci_base_state_machine *sm)
 {
-	struct scic_sds_phy *sci_phy = container_of(sm, typeof(*sci_phy), state_machine);
+	struct scic_sds_phy *sci_phy = container_of(sm, typeof(*sci_phy), sm);
 
 	/* This is just an temporary state go off to the starting state */
-	sci_base_state_machine_change_state(&sci_phy->state_machine,
-					    SCIC_SDS_PHY_STARTING_SUBSTATE_AWAIT_OSSP_EN);
+	sci_change_state(&sci_phy->sm, SCI_PHY_SUB_AWAIT_OSSP_EN);
 }
 
 static void scic_sds_phy_starting_await_sas_power_substate_enter(struct sci_base_state_machine *sm)
 {
-	struct scic_sds_phy *sci_phy = container_of(sm, typeof(*sci_phy), state_machine);
+	struct scic_sds_phy *sci_phy = container_of(sm, typeof(*sci_phy), sm);
 	struct scic_sds_controller *scic = sci_phy->owning_port->owning_controller;
 
 	scic_sds_controller_power_control_queue_insert(scic, sci_phy);
@@ -1031,7 +1002,7 @@ static void scic_sds_phy_starting_await_sas_power_substate_enter(struct sci_base
 
 static void scic_sds_phy_starting_await_sas_power_substate_exit(struct sci_base_state_machine *sm)
 {
-	struct scic_sds_phy *sci_phy = container_of(sm, typeof(*sci_phy), state_machine);
+	struct scic_sds_phy *sci_phy = container_of(sm, typeof(*sci_phy), sm);
 	struct scic_sds_controller *scic = sci_phy->owning_port->owning_controller;
 
 	scic_sds_controller_power_control_queue_remove(scic, sci_phy);
@@ -1039,7 +1010,7 @@ static void scic_sds_phy_starting_await_sas_power_substate_exit(struct sci_base_
 
 static void scic_sds_phy_starting_await_sata_power_substate_enter(struct sci_base_state_machine *sm)
 {
-	struct scic_sds_phy *sci_phy = container_of(sm, typeof(*sci_phy), state_machine);
+	struct scic_sds_phy *sci_phy = container_of(sm, typeof(*sci_phy), sm);
 	struct scic_sds_controller *scic = sci_phy->owning_port->owning_controller;
 
 	scic_sds_controller_power_control_queue_insert(scic, sci_phy);
@@ -1047,7 +1018,7 @@ static void scic_sds_phy_starting_await_sata_power_substate_enter(struct sci_bas
 
 static void scic_sds_phy_starting_await_sata_power_substate_exit(struct sci_base_state_machine *sm)
 {
-	struct scic_sds_phy *sci_phy = container_of(sm, typeof(*sci_phy), state_machine);
+	struct scic_sds_phy *sci_phy = container_of(sm, typeof(*sci_phy), sm);
 	struct scic_sds_controller *scic = sci_phy->owning_port->owning_controller;
 
 	scic_sds_controller_power_control_queue_remove(scic, sci_phy);
@@ -1055,35 +1026,35 @@ static void scic_sds_phy_starting_await_sata_power_substate_exit(struct sci_base
 
 static void scic_sds_phy_starting_await_sata_phy_substate_enter(struct sci_base_state_machine *sm)
 {
-	struct scic_sds_phy *sci_phy = container_of(sm, typeof(*sci_phy), state_machine);
+	struct scic_sds_phy *sci_phy = container_of(sm, typeof(*sci_phy), sm);
 
 	sci_mod_timer(&sci_phy->sata_timer, SCIC_SDS_SATA_LINK_TRAINING_TIMEOUT);
 }
 
 static void scic_sds_phy_starting_await_sata_phy_substate_exit(struct sci_base_state_machine *sm)
 {
-	struct scic_sds_phy *sci_phy = container_of(sm, typeof(*sci_phy), state_machine);
+	struct scic_sds_phy *sci_phy = container_of(sm, typeof(*sci_phy), sm);
 
 	sci_del_timer(&sci_phy->sata_timer);
 }
 
 static void scic_sds_phy_starting_await_sata_speed_substate_enter(struct sci_base_state_machine *sm)
 {
-	struct scic_sds_phy *sci_phy = container_of(sm, typeof(*sci_phy), state_machine);
+	struct scic_sds_phy *sci_phy = container_of(sm, typeof(*sci_phy), sm);
 
 	sci_mod_timer(&sci_phy->sata_timer, SCIC_SDS_SATA_LINK_TRAINING_TIMEOUT);
 }
 
 static void scic_sds_phy_starting_await_sata_speed_substate_exit(struct sci_base_state_machine *sm)
 {
-	struct scic_sds_phy *sci_phy = container_of(sm, typeof(*sci_phy), state_machine);
+	struct scic_sds_phy *sci_phy = container_of(sm, typeof(*sci_phy), sm);
 
 	sci_del_timer(&sci_phy->sata_timer);
 }
 
 static void scic_sds_phy_starting_await_sig_fis_uf_substate_enter(struct sci_base_state_machine *sm)
 {
-	struct scic_sds_phy *sci_phy = container_of(sm, typeof(*sci_phy), state_machine);
+	struct scic_sds_phy *sci_phy = container_of(sm, typeof(*sci_phy), sm);
 
 	if (scic_sds_port_link_detected(sci_phy->owning_port, sci_phy)) {
 
@@ -1103,20 +1074,19 @@ static void scic_sds_phy_starting_await_sig_fis_uf_substate_enter(struct sci_bas
 
 static void scic_sds_phy_starting_await_sig_fis_uf_substate_exit(struct sci_base_state_machine *sm)
 {
-	struct scic_sds_phy *sci_phy = container_of(sm, typeof(*sci_phy), state_machine);
+	struct scic_sds_phy *sci_phy = container_of(sm, typeof(*sci_phy), sm);
 
 	sci_del_timer(&sci_phy->sata_timer);
 }
 
 static void scic_sds_phy_starting_final_substate_enter(struct sci_base_state_machine *sm)
 {
-	struct scic_sds_phy *sci_phy = container_of(sm, typeof(*sci_phy), state_machine);
+	struct scic_sds_phy *sci_phy = container_of(sm, typeof(*sci_phy), sm);
 
 	/* State machine has run to completion so exit out and change
 	 * the base state machine to the ready state
 	 */
-	sci_base_state_machine_change_state(&sci_phy->state_machine,
-					    SCI_BASE_PHY_STATE_READY);
+	sci_change_state(&sci_phy->sm, SCI_PHY_READY);
 }
 
 /**
@@ -1202,7 +1172,7 @@ static void scu_link_layer_tx_hard_reset(
 
 static void scic_sds_phy_stopped_state_enter(struct sci_base_state_machine *sm)
 {
-	struct scic_sds_phy *sci_phy = container_of(sm, typeof(*sci_phy), state_machine);
+	struct scic_sds_phy *sci_phy = container_of(sm, typeof(*sci_phy), sm);
 
 	/*
 	 * @todo We need to get to the controller to place this PE in a
@@ -1212,7 +1182,7 @@ static void scic_sds_phy_stopped_state_enter(struct sci_base_state_machine *sm)
 
 	scu_link_layer_stop_protocol_engine(sci_phy);
 
-	if (sci_phy->state_machine.previous_state_id != SCI_BASE_PHY_STATE_INITIAL)
+	if (sci_phy->sm.previous_state_id != SCI_PHY_INITIAL)
 		scic_sds_controller_link_down(scic_sds_phy_get_controller(sci_phy),
 					      phy_get_non_dummy_port(sci_phy),
 					      sci_phy);
@@ -1220,7 +1190,7 @@ static void scic_sds_phy_stopped_state_enter(struct sci_base_state_machine *sm)
 
 static void scic_sds_phy_starting_state_enter(struct sci_base_state_machine *sm)
 {
-	struct scic_sds_phy *sci_phy = container_of(sm, typeof(*sci_phy), state_machine);
+	struct scic_sds_phy *sci_phy = container_of(sm, typeof(*sci_phy), sm);
 
 	scu_link_layer_stop_protocol_engine(sci_phy);
 	scu_link_layer_start_oob(sci_phy);
@@ -1229,18 +1199,17 @@ static void scic_sds_phy_starting_state_enter(struct sci_base_state_machine *sm)
 	sci_phy->protocol = SCIC_SDS_PHY_PROTOCOL_UNKNOWN;
 	sci_phy->bcn_received_while_port_unassigned = false;
 
-	if (sci_phy->state_machine.previous_state_id == SCI_BASE_PHY_STATE_READY)
+	if (sci_phy->sm.previous_state_id == SCI_PHY_READY)
 		scic_sds_controller_link_down(scic_sds_phy_get_controller(sci_phy),
 					      phy_get_non_dummy_port(sci_phy),
 					      sci_phy);
 
-	sci_base_state_machine_change_state(&sci_phy->state_machine,
-					    SCIC_SDS_PHY_STARTING_SUBSTATE_INITIAL);
+	sci_change_state(&sci_phy->sm, SCI_PHY_SUB_INITIAL);
 }
 
 static void scic_sds_phy_ready_state_enter(struct sci_base_state_machine *sm)
 {
-	struct scic_sds_phy *sci_phy = container_of(sm, typeof(*sci_phy), state_machine);
+	struct scic_sds_phy *sci_phy = container_of(sm, typeof(*sci_phy), sm);
 
 	scic_sds_controller_link_up(scic_sds_phy_get_controller(sci_phy),
 				    phy_get_non_dummy_port(sci_phy),
@@ -1250,14 +1219,14 @@ static void scic_sds_phy_ready_state_enter(struct sci_base_state_machine *sm)
 
 static void scic_sds_phy_ready_state_exit(struct sci_base_state_machine *sm)
 {
-	struct scic_sds_phy *sci_phy = container_of(sm, typeof(*sci_phy), state_machine);
+	struct scic_sds_phy *sci_phy = container_of(sm, typeof(*sci_phy), sm);
 
 	scic_sds_phy_suspend(sci_phy);
 }
 
 static void scic_sds_phy_resetting_state_enter(struct sci_base_state_machine *sm)
 {
-	struct scic_sds_phy *sci_phy = container_of(sm, typeof(*sci_phy), state_machine);
+	struct scic_sds_phy *sci_phy = container_of(sm, typeof(*sci_phy), sm);
 
 	/* The phy is being reset, therefore deactivate it from the port.  In
 	 * the resetting state we don't notify the user regarding link up and
@@ -1271,66 +1240,65 @@ static void scic_sds_phy_resetting_state_enter(struct sci_base_state_machine *sm
 		/* The SCU does not need to have a discrete reset state so
 		 * just go back to the starting state.
 		 */
-		sci_base_state_machine_change_state(&sci_phy->state_machine,
-						    SCI_BASE_PHY_STATE_STARTING);
+		sci_change_state(&sci_phy->sm, SCI_PHY_STARTING);
 	}
 }
 
 static const struct sci_base_state scic_sds_phy_state_table[] = {
-	[SCI_BASE_PHY_STATE_INITIAL] = { },
-	[SCI_BASE_PHY_STATE_STOPPED] = {
+	[SCI_PHY_INITIAL] = { },
+	[SCI_PHY_STOPPED] = {
 		.enter_state = scic_sds_phy_stopped_state_enter,
 	},
-	[SCI_BASE_PHY_STATE_STARTING] = {
+	[SCI_PHY_STARTING] = {
 		.enter_state = scic_sds_phy_starting_state_enter,
 	},
-	[SCIC_SDS_PHY_STARTING_SUBSTATE_INITIAL] = {
+	[SCI_PHY_SUB_INITIAL] = {
 		.enter_state = scic_sds_phy_starting_initial_substate_enter,
 	},
-	[SCIC_SDS_PHY_STARTING_SUBSTATE_AWAIT_OSSP_EN] = { },
-	[SCIC_SDS_PHY_STARTING_SUBSTATE_AWAIT_SAS_SPEED_EN] = { },
-	[SCIC_SDS_PHY_STARTING_SUBSTATE_AWAIT_IAF_UF] = { },
-	[SCIC_SDS_PHY_STARTING_SUBSTATE_AWAIT_SAS_POWER] = {
+	[SCI_PHY_SUB_AWAIT_OSSP_EN] = { },
+	[SCI_PHY_SUB_AWAIT_SAS_SPEED_EN] = { },
+	[SCI_PHY_SUB_AWAIT_IAF_UF] = { },
+	[SCI_PHY_SUB_AWAIT_SAS_POWER] = {
 		.enter_state = scic_sds_phy_starting_await_sas_power_substate_enter,
 		.exit_state  = scic_sds_phy_starting_await_sas_power_substate_exit,
 	},
-	[SCIC_SDS_PHY_STARTING_SUBSTATE_AWAIT_SATA_POWER] = {
+	[SCI_PHY_SUB_AWAIT_SATA_POWER] = {
 		.enter_state = scic_sds_phy_starting_await_sata_power_substate_enter,
 		.exit_state  = scic_sds_phy_starting_await_sata_power_substate_exit
 	},
-	[SCIC_SDS_PHY_STARTING_SUBSTATE_AWAIT_SATA_PHY_EN] = {
+	[SCI_PHY_SUB_AWAIT_SATA_PHY_EN] = {
 		.enter_state = scic_sds_phy_starting_await_sata_phy_substate_enter,
 		.exit_state  = scic_sds_phy_starting_await_sata_phy_substate_exit
 	},
-	[SCIC_SDS_PHY_STARTING_SUBSTATE_AWAIT_SATA_SPEED_EN] = {
+	[SCI_PHY_SUB_AWAIT_SATA_SPEED_EN] = {
 		.enter_state = scic_sds_phy_starting_await_sata_speed_substate_enter,
 		.exit_state  = scic_sds_phy_starting_await_sata_speed_substate_exit
 	},
-	[SCIC_SDS_PHY_STARTING_SUBSTATE_AWAIT_SIG_FIS_UF] = {
+	[SCI_PHY_SUB_AWAIT_SIG_FIS_UF] = {
 		.enter_state = scic_sds_phy_starting_await_sig_fis_uf_substate_enter,
 		.exit_state  = scic_sds_phy_starting_await_sig_fis_uf_substate_exit
 	},
-	[SCIC_SDS_PHY_STARTING_SUBSTATE_FINAL] = {
+	[SCI_PHY_SUB_FINAL] = {
 		.enter_state = scic_sds_phy_starting_final_substate_enter,
 	},
-	[SCI_BASE_PHY_STATE_READY] = {
+	[SCI_PHY_READY] = {
 		.enter_state = scic_sds_phy_ready_state_enter,
 		.exit_state = scic_sds_phy_ready_state_exit,
 	},
-	[SCI_BASE_PHY_STATE_RESETTING] = {
+	[SCI_PHY_RESETTING] = {
 		.enter_state = scic_sds_phy_resetting_state_enter,
 	},
-	[SCI_BASE_PHY_STATE_FINAL] = { },
+	[SCI_PHY_FINAL] = { },
 };
 
 void scic_sds_phy_construct(struct scic_sds_phy *sci_phy,
 			    struct scic_sds_port *owning_port, u8 phy_index)
 {
-	sci_base_state_machine_construct(&sci_phy->state_machine,
+	sci_base_state_machine_construct(&sci_phy->sm,
 					 scic_sds_phy_state_table,
-					 SCI_BASE_PHY_STATE_INITIAL);
+					 SCI_PHY_INITIAL);
 
-	sci_base_state_machine_start(&sci_phy->state_machine);
+	sci_base_state_machine_start(&sci_phy->sm);
 
 	/* Copy the rest of the input data to our locals */
 	sci_phy->owning_port = owning_port;

commit 8db02da52895285e99d7eb2fa825fd393e61d9c5
Author: Edmund Nadolski <edmund.nadolski@intel.com>
Date:   Thu May 19 12:00:22 2011 +0000

    isci: remove isci_timer interface
    
    Delete code which is no longer used.
    
    Signed-off-by: Edmund Nadolski <edmund.nadolski@intel.com>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/drivers/scsi/isci/phy.c b/drivers/scsi/isci/phy.c
index b663bbdd4e59..fc196e389ffb 100644
--- a/drivers/scsi/isci/phy.c
+++ b/drivers/scsi/isci/phy.c
@@ -57,7 +57,6 @@
 #include "host.h"
 #include "phy.h"
 #include "scu_event_codes.h"
-#include "timers.h"
 #include "probe_roms.h"
 
 /* Maximum arbitration wait time in micro-seconds */

commit a628d478570d71fb8751ad09b8017139c5056002
Author: Edmund Nadolski <edmund.nadolski@intel.com>
Date:   Thu May 19 11:59:36 2011 +0000

    isci: convert phy sata_timeout_timer to sci_timer
    
    Convert the sata_timeout_timer in the scic_sds_phy struct to
    use a struct sci_timer
    
    Signed-off-by: Edmund Nadolski <edmund.nadolski@intel.com>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/drivers/scsi/isci/phy.c b/drivers/scsi/isci/phy.c
index f21e10e2888c..b663bbdd4e59 100644
--- a/drivers/scsi/isci/phy.c
+++ b/drivers/scsi/isci/phy.c
@@ -256,14 +256,17 @@ scic_sds_phy_link_layer_initialization(struct scic_sds_phy *sci_phy,
 	return SCI_SUCCESS;
 }
 
-/**
- * This function will handle the sata SIGNATURE FIS timeout condition.  It will
- * restart the starting substate machine since we dont know what has actually
- * happening.
- */
-static void scic_sds_phy_sata_timeout(void *phy)
+static void phy_sata_timeout(unsigned long data)
 {
-	struct scic_sds_phy *sci_phy = phy;
+	struct sci_timer *tmr = (struct sci_timer *)data;
+	struct scic_sds_phy *sci_phy = container_of(tmr, typeof(*sci_phy), sata_timer);
+	struct isci_host *ihost = scic_to_ihost(sci_phy->owning_port->owning_controller);
+	unsigned long flags;
+
+	spin_lock_irqsave(&ihost->scic_lock, flags);
+
+	if (tmr->cancel)
+		goto done;
 
 	dev_dbg(sciphy_to_dev(sci_phy),
 		 "%s: SCIC SDS Phy 0x%p did not receive signature fis before "
@@ -273,6 +276,8 @@ static void scic_sds_phy_sata_timeout(void *phy)
 
 	sci_base_state_machine_change_state(&sci_phy->state_machine,
 					    SCI_BASE_PHY_STATE_STARTING);
+done:
+	spin_unlock_irqrestore(&ihost->scic_lock, flags);
 }
 
 /**
@@ -327,16 +332,6 @@ enum sci_status scic_sds_phy_initialize(
 	struct scu_transport_layer_registers __iomem *transport_layer_registers,
 	struct scu_link_layer_registers __iomem *link_layer_registers)
 {
-	struct scic_sds_controller *scic = scic_sds_phy_get_controller(sci_phy);
-	struct isci_host *ihost = scic_to_ihost(scic);
-
-	/* Create the SIGNATURE FIS Timeout timer for this phy */
-	sci_phy->sata_timeout_timer =
-		isci_timer_create(
-			ihost,
-			sci_phy,
-			scic_sds_phy_sata_timeout);
-
 	/* Perfrom the initialization of the TL hardware */
 	scic_sds_phy_transport_layer_initialization(
 			sci_phy,
@@ -442,9 +437,7 @@ void scic_sds_phy_get_protocols(struct scic_sds_phy *sci_phy,
 
 enum sci_status scic_sds_phy_start(struct scic_sds_phy *sci_phy)
 {
-	struct scic_sds_controller *scic = sci_phy->owning_port->owning_controller;
 	enum scic_sds_phy_states state = sci_phy->state_machine.current_state_id;
-	struct isci_host *ihost = scic_to_ihost(scic);
 
 	if (state != SCI_BASE_PHY_STATE_STOPPED) {
 		dev_dbg(sciphy_to_dev(sci_phy),
@@ -452,14 +445,8 @@ enum sci_status scic_sds_phy_start(struct scic_sds_phy *sci_phy)
 		return SCI_FAILURE_INVALID_STATE;
 	}
 
-	/* Create the SIGNATURE FIS Timeout timer for this phy */
-	sci_phy->sata_timeout_timer = isci_timer_create(ihost, sci_phy,
-							scic_sds_phy_sata_timeout);
-
-	if (sci_phy->sata_timeout_timer)
-		sci_base_state_machine_change_state(&sci_phy->state_machine,
-						    SCI_BASE_PHY_STATE_STARTING);
-
+	sci_base_state_machine_change_state(&sci_phy->state_machine,
+					    SCI_BASE_PHY_STATE_STARTING);
 	return SCI_SUCCESS;
 }
 
@@ -1071,30 +1058,28 @@ static void scic_sds_phy_starting_await_sata_phy_substate_enter(struct sci_base_
 {
 	struct scic_sds_phy *sci_phy = container_of(sm, typeof(*sci_phy), state_machine);
 
-	isci_timer_start(sci_phy->sata_timeout_timer,
-			 SCIC_SDS_SATA_LINK_TRAINING_TIMEOUT);
+	sci_mod_timer(&sci_phy->sata_timer, SCIC_SDS_SATA_LINK_TRAINING_TIMEOUT);
 }
 
 static void scic_sds_phy_starting_await_sata_phy_substate_exit(struct sci_base_state_machine *sm)
 {
 	struct scic_sds_phy *sci_phy = container_of(sm, typeof(*sci_phy), state_machine);
 
-	isci_timer_stop(sci_phy->sata_timeout_timer);
+	sci_del_timer(&sci_phy->sata_timer);
 }
 
 static void scic_sds_phy_starting_await_sata_speed_substate_enter(struct sci_base_state_machine *sm)
 {
 	struct scic_sds_phy *sci_phy = container_of(sm, typeof(*sci_phy), state_machine);
 
-	isci_timer_start(sci_phy->sata_timeout_timer,
-			 SCIC_SDS_SATA_LINK_TRAINING_TIMEOUT);
+	sci_mod_timer(&sci_phy->sata_timer, SCIC_SDS_SATA_LINK_TRAINING_TIMEOUT);
 }
 
 static void scic_sds_phy_starting_await_sata_speed_substate_exit(struct sci_base_state_machine *sm)
 {
 	struct scic_sds_phy *sci_phy = container_of(sm, typeof(*sci_phy), state_machine);
 
-	isci_timer_stop(sci_phy->sata_timeout_timer);
+	sci_del_timer(&sci_phy->sata_timer);
 }
 
 static void scic_sds_phy_starting_await_sig_fis_uf_substate_enter(struct sci_base_state_machine *sm)
@@ -1111,8 +1096,8 @@ static void scic_sds_phy_starting_await_sig_fis_uf_substate_enter(struct sci_bas
 		 */
 		scic_sds_phy_resume(sci_phy);
 
-		isci_timer_start(sci_phy->sata_timeout_timer,
-				 SCIC_SDS_SIGNATURE_FIS_TIMEOUT);
+		sci_mod_timer(&sci_phy->sata_timer,
+			      SCIC_SDS_SIGNATURE_FIS_TIMEOUT);
 	} else
 		sci_phy->is_in_link_training = false;
 }
@@ -1121,7 +1106,7 @@ static void scic_sds_phy_starting_await_sig_fis_uf_substate_exit(struct sci_base
 {
 	struct scic_sds_phy *sci_phy = container_of(sm, typeof(*sci_phy), state_machine);
 
-	isci_timer_stop(sci_phy->sata_timeout_timer);
+	sci_del_timer(&sci_phy->sata_timer);
 }
 
 static void scic_sds_phy_starting_final_substate_enter(struct sci_base_state_machine *sm)
@@ -1219,19 +1204,12 @@ static void scu_link_layer_tx_hard_reset(
 static void scic_sds_phy_stopped_state_enter(struct sci_base_state_machine *sm)
 {
 	struct scic_sds_phy *sci_phy = container_of(sm, typeof(*sci_phy), state_machine);
-	struct scic_sds_port *sci_port = sci_phy->owning_port;
-	struct scic_sds_controller *scic = sci_port->owning_controller;
-	struct isci_host *ihost = scic_to_ihost(scic);
 
 	/*
 	 * @todo We need to get to the controller to place this PE in a
 	 * reset state
 	 */
-	if (sci_phy->sata_timeout_timer != NULL) {
-		isci_del_timer(ihost, sci_phy->sata_timeout_timer);
-
-		sci_phy->sata_timeout_timer = NULL;
-	}
+	sci_del_timer(&sci_phy->sata_timer);
 
 	scu_link_layer_stop_protocol_engine(sci_phy);
 
@@ -1362,7 +1340,9 @@ void scic_sds_phy_construct(struct scic_sds_phy *sci_phy,
 	sci_phy->protocol = SCIC_SDS_PHY_PROTOCOL_UNKNOWN;
 	sci_phy->link_layer_registers = NULL;
 	sci_phy->max_negotiated_speed = SAS_LINK_RATE_UNKNOWN;
-	sci_phy->sata_timeout_timer = NULL;
+
+	/* Create the SIGNATURE FIS Timeout timer for this phy */
+	sci_init_timer(&sci_phy->sata_timer, phy_sata_timeout);
 }
 
 void isci_phy_init(struct isci_phy *iphy, struct isci_host *ihost, int index)

commit 9269e0e898594c65dee6b20d4ed48e33dbbd4eeb
Author: Dan Williams <dan.j.williams@intel.com>
Date:   Thu May 12 07:42:17 2011 -0700

    isci: add some type safety to the state machine interface
    
    Now that any given object type only has one state_machine we can use
    container_of() to get back to the given state machine owner.
    
    Reported-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/drivers/scsi/isci/phy.c b/drivers/scsi/isci/phy.c
index 8bd1a85f621e..f21e10e2888c 100644
--- a/drivers/scsi/isci/phy.c
+++ b/drivers/scsi/isci/phy.c
@@ -1026,81 +1026,80 @@ enum sci_status scic_sds_phy_frame_handler(struct scic_sds_phy *sci_phy,
 	
 }
 
-static void scic_sds_phy_starting_initial_substate_enter(void *object)
+static void scic_sds_phy_starting_initial_substate_enter(struct sci_base_state_machine *sm)
 {
-	struct scic_sds_phy *sci_phy = object;
+	struct scic_sds_phy *sci_phy = container_of(sm, typeof(*sci_phy), state_machine);
 
 	/* This is just an temporary state go off to the starting state */
 	sci_base_state_machine_change_state(&sci_phy->state_machine,
 					    SCIC_SDS_PHY_STARTING_SUBSTATE_AWAIT_OSSP_EN);
 }
 
-static void scic_sds_phy_starting_await_sas_power_substate_enter(void *object)
+static void scic_sds_phy_starting_await_sas_power_substate_enter(struct sci_base_state_machine *sm)
 {
-	struct scic_sds_phy *sci_phy = object;
+	struct scic_sds_phy *sci_phy = container_of(sm, typeof(*sci_phy), state_machine);
 	struct scic_sds_controller *scic = sci_phy->owning_port->owning_controller;
 
 	scic_sds_controller_power_control_queue_insert(scic, sci_phy);
 }
 
-static void scic_sds_phy_starting_await_sas_power_substate_exit(void *object)
+static void scic_sds_phy_starting_await_sas_power_substate_exit(struct sci_base_state_machine *sm)
 {
-	struct scic_sds_phy *sci_phy = object;
+	struct scic_sds_phy *sci_phy = container_of(sm, typeof(*sci_phy), state_machine);
 	struct scic_sds_controller *scic = sci_phy->owning_port->owning_controller;
 
 	scic_sds_controller_power_control_queue_remove(scic, sci_phy);
 }
 
-static void scic_sds_phy_starting_await_sata_power_substate_enter(void *object)
+static void scic_sds_phy_starting_await_sata_power_substate_enter(struct sci_base_state_machine *sm)
 {
-	struct scic_sds_phy *sci_phy = object;
+	struct scic_sds_phy *sci_phy = container_of(sm, typeof(*sci_phy), state_machine);
 	struct scic_sds_controller *scic = sci_phy->owning_port->owning_controller;
 
 	scic_sds_controller_power_control_queue_insert(scic, sci_phy);
 }
 
-static void scic_sds_phy_starting_await_sata_power_substate_exit(void *object)
+static void scic_sds_phy_starting_await_sata_power_substate_exit(struct sci_base_state_machine *sm)
 {
-	struct scic_sds_phy *sci_phy = object;
+	struct scic_sds_phy *sci_phy = container_of(sm, typeof(*sci_phy), state_machine);
 	struct scic_sds_controller *scic = sci_phy->owning_port->owning_controller;
 
 	scic_sds_controller_power_control_queue_remove(scic, sci_phy);
 }
 
-static void scic_sds_phy_starting_await_sata_phy_substate_enter(void *object)
+static void scic_sds_phy_starting_await_sata_phy_substate_enter(struct sci_base_state_machine *sm)
 {
-	struct scic_sds_phy *sci_phy = object;
+	struct scic_sds_phy *sci_phy = container_of(sm, typeof(*sci_phy), state_machine);
 
 	isci_timer_start(sci_phy->sata_timeout_timer,
 			 SCIC_SDS_SATA_LINK_TRAINING_TIMEOUT);
 }
 
-static void scic_sds_phy_starting_await_sata_phy_substate_exit(void *object)
+static void scic_sds_phy_starting_await_sata_phy_substate_exit(struct sci_base_state_machine *sm)
 {
-	struct scic_sds_phy *sci_phy = object;
+	struct scic_sds_phy *sci_phy = container_of(sm, typeof(*sci_phy), state_machine);
 
 	isci_timer_stop(sci_phy->sata_timeout_timer);
 }
 
-static void scic_sds_phy_starting_await_sata_speed_substate_enter(void *object)
+static void scic_sds_phy_starting_await_sata_speed_substate_enter(struct sci_base_state_machine *sm)
 {
-	struct scic_sds_phy *sci_phy = object;
+	struct scic_sds_phy *sci_phy = container_of(sm, typeof(*sci_phy), state_machine);
 
 	isci_timer_start(sci_phy->sata_timeout_timer,
 			 SCIC_SDS_SATA_LINK_TRAINING_TIMEOUT);
 }
 
-static void scic_sds_phy_starting_await_sata_speed_substate_exit(
-	void *object)
+static void scic_sds_phy_starting_await_sata_speed_substate_exit(struct sci_base_state_machine *sm)
 {
-	struct scic_sds_phy *sci_phy = object;
+	struct scic_sds_phy *sci_phy = container_of(sm, typeof(*sci_phy), state_machine);
 
 	isci_timer_stop(sci_phy->sata_timeout_timer);
 }
 
-static void scic_sds_phy_starting_await_sig_fis_uf_substate_enter(void *object)
+static void scic_sds_phy_starting_await_sig_fis_uf_substate_enter(struct sci_base_state_machine *sm)
 {
-	struct scic_sds_phy *sci_phy = object;
+	struct scic_sds_phy *sci_phy = container_of(sm, typeof(*sci_phy), state_machine);
 
 	if (scic_sds_port_link_detected(sci_phy->owning_port, sci_phy)) {
 
@@ -1118,16 +1117,16 @@ static void scic_sds_phy_starting_await_sig_fis_uf_substate_enter(void *object)
 		sci_phy->is_in_link_training = false;
 }
 
-static void scic_sds_phy_starting_await_sig_fis_uf_substate_exit(void *object)
+static void scic_sds_phy_starting_await_sig_fis_uf_substate_exit(struct sci_base_state_machine *sm)
 {
-	struct scic_sds_phy *sci_phy = object;
+	struct scic_sds_phy *sci_phy = container_of(sm, typeof(*sci_phy), state_machine);
 
 	isci_timer_stop(sci_phy->sata_timeout_timer);
 }
 
-static void scic_sds_phy_starting_final_substate_enter(void *object)
+static void scic_sds_phy_starting_final_substate_enter(struct sci_base_state_machine *sm)
 {
-	struct scic_sds_phy *sci_phy = object;
+	struct scic_sds_phy *sci_phy = container_of(sm, typeof(*sci_phy), state_machine);
 
 	/* State machine has run to completion so exit out and change
 	 * the base state machine to the ready state
@@ -1217,9 +1216,9 @@ static void scu_link_layer_tx_hard_reset(
 	       &sci_phy->link_layer_registers->phy_configuration);
 }
 
-static void scic_sds_phy_stopped_state_enter(void *object)
+static void scic_sds_phy_stopped_state_enter(struct sci_base_state_machine *sm)
 {
-	struct scic_sds_phy *sci_phy = object;
+	struct scic_sds_phy *sci_phy = container_of(sm, typeof(*sci_phy), state_machine);
 	struct scic_sds_port *sci_port = sci_phy->owning_port;
 	struct scic_sds_controller *scic = sci_port->owning_controller;
 	struct isci_host *ihost = scic_to_ihost(scic);
@@ -1242,9 +1241,9 @@ static void scic_sds_phy_stopped_state_enter(void *object)
 					      sci_phy);
 }
 
-static void scic_sds_phy_starting_state_enter(void *object)
+static void scic_sds_phy_starting_state_enter(struct sci_base_state_machine *sm)
 {
-	struct scic_sds_phy *sci_phy = object;
+	struct scic_sds_phy *sci_phy = container_of(sm, typeof(*sci_phy), state_machine);
 
 	scu_link_layer_stop_protocol_engine(sci_phy);
 	scu_link_layer_start_oob(sci_phy);
@@ -1262,9 +1261,9 @@ static void scic_sds_phy_starting_state_enter(void *object)
 					    SCIC_SDS_PHY_STARTING_SUBSTATE_INITIAL);
 }
 
-static void scic_sds_phy_ready_state_enter(void *object)
+static void scic_sds_phy_ready_state_enter(struct sci_base_state_machine *sm)
 {
-	struct scic_sds_phy *sci_phy = object;
+	struct scic_sds_phy *sci_phy = container_of(sm, typeof(*sci_phy), state_machine);
 
 	scic_sds_controller_link_up(scic_sds_phy_get_controller(sci_phy),
 				    phy_get_non_dummy_port(sci_phy),
@@ -1272,16 +1271,16 @@ static void scic_sds_phy_ready_state_enter(void *object)
 
 }
 
-static void scic_sds_phy_ready_state_exit(void *object)
+static void scic_sds_phy_ready_state_exit(struct sci_base_state_machine *sm)
 {
-	struct scic_sds_phy *sci_phy = object;
+	struct scic_sds_phy *sci_phy = container_of(sm, typeof(*sci_phy), state_machine);
 
 	scic_sds_phy_suspend(sci_phy);
 }
 
-static void scic_sds_phy_resetting_state_enter(void *object)
+static void scic_sds_phy_resetting_state_enter(struct sci_base_state_machine *sm)
 {
-	struct scic_sds_phy *sci_phy = object;
+	struct scic_sds_phy *sci_phy = container_of(sm, typeof(*sci_phy), state_machine);
 
 	/* The phy is being reset, therefore deactivate it from the port.  In
 	 * the resetting state we don't notify the user regarding link up and
@@ -1351,7 +1350,6 @@ void scic_sds_phy_construct(struct scic_sds_phy *sci_phy,
 			    struct scic_sds_port *owning_port, u8 phy_index)
 {
 	sci_base_state_machine_construct(&sci_phy->state_machine,
-					 sci_phy,
 					 scic_sds_phy_state_table,
 					 SCI_BASE_PHY_STATE_INITIAL);
 

commit 4f20ef4f57aa52fd3356c143a8f3d2bd18dc61fc
Author: Dan Williams <dan.j.williams@intel.com>
Date:   Thu May 12 06:00:31 2011 -0700

    isci: clarify phy to port lookups
    
    While cleaning up the driver it is very tempting to convert scic_sds_get_*
    macros to their open coded equivalent.  They are all just pointer dereferences
    *except* scic_sds_phy_get_port() which returns NULL if the phy is assigned to
    the dummy port.  Clarify this by renaming it to phy_get_non_dummy_port().
    
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/drivers/scsi/isci/phy.c b/drivers/scsi/isci/phy.c
index 9a5ec375f767..8bd1a85f621e 100644
--- a/drivers/scsi/isci/phy.c
+++ b/drivers/scsi/isci/phy.c
@@ -287,7 +287,7 @@ static void scic_sds_phy_sata_timeout(void *phy)
  * port (i.e. it's contained in the dummy port). !NULL All other
  * values indicate a handle/pointer to the port containing the phy.
  */
-struct scic_sds_port *scic_sds_phy_get_port(
+struct scic_sds_port *phy_get_non_dummy_port(
 	struct scic_sds_phy *sci_phy)
 {
 	if (scic_sds_port_get_index(sci_phy->owning_port) == SCIC_SDS_DUMMY_PORT)
@@ -893,7 +893,7 @@ enum sci_status scic_sds_phy_event_handler(struct scic_sds_phy *sci_phy,
 			break;
 		case SCU_EVENT_BROADCAST_CHANGE:
 			/* Broadcast change received. Notify the port. */
-			if (scic_sds_phy_get_port(sci_phy) != NULL)
+			if (phy_get_non_dummy_port(sci_phy) != NULL)
 				scic_sds_port_broadcast_change_received(sci_phy->owning_port, sci_phy);
 			else
 				sci_phy->bcn_received_while_port_unassigned = true;
@@ -1238,7 +1238,7 @@ static void scic_sds_phy_stopped_state_enter(void *object)
 
 	if (sci_phy->state_machine.previous_state_id != SCI_BASE_PHY_STATE_INITIAL)
 		scic_sds_controller_link_down(scic_sds_phy_get_controller(sci_phy),
-					      scic_sds_phy_get_port(sci_phy),
+					      phy_get_non_dummy_port(sci_phy),
 					      sci_phy);
 }
 
@@ -1255,7 +1255,7 @@ static void scic_sds_phy_starting_state_enter(void *object)
 
 	if (sci_phy->state_machine.previous_state_id == SCI_BASE_PHY_STATE_READY)
 		scic_sds_controller_link_down(scic_sds_phy_get_controller(sci_phy),
-					      scic_sds_phy_get_port(sci_phy),
+					      phy_get_non_dummy_port(sci_phy),
 					      sci_phy);
 
 	sci_base_state_machine_change_state(&sci_phy->state_machine,
@@ -1267,7 +1267,7 @@ static void scic_sds_phy_ready_state_enter(void *object)
 	struct scic_sds_phy *sci_phy = object;
 
 	scic_sds_controller_link_up(scic_sds_phy_get_controller(sci_phy),
-				    scic_sds_phy_get_port(sci_phy),
+				    phy_get_non_dummy_port(sci_phy),
 				    sci_phy);
 
 }

commit 5b1d4af25186f5d23dae7a538d8472dacd9486c8
Author: Dan Williams <dan.j.williams@intel.com>
Date:   Thu May 12 04:51:41 2011 -0700

    isci: unify phy consume_power handlers
    
    Unify the implementations in scic_sds_phy_consume_power_handler(), and kill
    the state handler plus infrastructure.
    
    Reported-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/drivers/scsi/isci/phy.c b/drivers/scsi/isci/phy.c
index 0ffb5d5a860e..9a5ec375f767 100644
--- a/drivers/scsi/isci/phy.c
+++ b/drivers/scsi/isci/phy.c
@@ -505,16 +505,53 @@ enum sci_status scic_sds_phy_reset(struct scic_sds_phy *sci_phy)
 	return SCI_SUCCESS;
 }
 
-/**
- * This method will give the phy permission to consume power
- * @sci_phy:
- *
- * enum sci_status
- */
-enum sci_status scic_sds_phy_consume_power_handler(
-	struct scic_sds_phy *sci_phy)
+enum sci_status scic_sds_phy_consume_power_handler(struct scic_sds_phy *sci_phy)
 {
-	return sci_phy->state_handlers->consume_power_handler(sci_phy);
+	enum scic_sds_phy_states state = sci_phy->state_machine.current_state_id;
+
+	switch (state) {
+	case SCIC_SDS_PHY_STARTING_SUBSTATE_AWAIT_SAS_POWER: {
+		u32 enable_spinup;
+
+		enable_spinup = readl(&sci_phy->link_layer_registers->notify_enable_spinup_control);
+		enable_spinup |= SCU_ENSPINUP_GEN_BIT(ENABLE);
+		writel(enable_spinup, &sci_phy->link_layer_registers->notify_enable_spinup_control);
+
+		/* Change state to the final state this substate machine has run to completion */
+		sci_base_state_machine_change_state(&sci_phy->state_machine,
+						    SCIC_SDS_PHY_STARTING_SUBSTATE_FINAL);
+
+		return SCI_SUCCESS;
+	}
+	case SCIC_SDS_PHY_STARTING_SUBSTATE_AWAIT_SATA_POWER: {
+		u32 scu_sas_pcfg_value;
+
+		/* Release the spinup hold state and reset the OOB state machine */
+		scu_sas_pcfg_value =
+			readl(&sci_phy->link_layer_registers->phy_configuration);
+		scu_sas_pcfg_value &=
+			~(SCU_SAS_PCFG_GEN_BIT(SATA_SPINUP_HOLD) | SCU_SAS_PCFG_GEN_BIT(OOB_ENABLE));
+		scu_sas_pcfg_value |= SCU_SAS_PCFG_GEN_BIT(OOB_RESET);
+		writel(scu_sas_pcfg_value,
+			&sci_phy->link_layer_registers->phy_configuration);
+
+		/* Now restart the OOB operation */
+		scu_sas_pcfg_value &= ~SCU_SAS_PCFG_GEN_BIT(OOB_RESET);
+		scu_sas_pcfg_value |= SCU_SAS_PCFG_GEN_BIT(OOB_ENABLE);
+		writel(scu_sas_pcfg_value,
+			&sci_phy->link_layer_registers->phy_configuration);
+
+		/* Change state to the final state this substate machine has run to completion */
+		sci_base_state_machine_change_state(&sci_phy->state_machine,
+						    SCIC_SDS_PHY_STARTING_SUBSTATE_AWAIT_SATA_PHY_EN);
+
+		return SCI_SUCCESS;
+	}
+	default:
+		dev_dbg(sciphy_to_dev(sci_phy),
+			"%s: in wrong state: %d\n", __func__, state);
+		return SCI_FAILURE_INVALID_STATE;
+	}
 }
 
 /*
@@ -592,76 +629,6 @@ static void scic_sds_phy_complete_link_training(
 					    next_state);
 }
 
-/*
- * This method is called by the struct scic_sds_controller when the phy object is
- * granted power. - The notify enable spinups are turned on for this phy object
- * - The phy state machine is transitioned to the
- * SCIC_SDS_PHY_STARTING_SUBSTATE_FINAL. enum sci_status SCI_SUCCESS
- */
-static enum sci_status scic_sds_phy_starting_substate_await_sas_power_consume_power_handler(
-	struct scic_sds_phy *sci_phy)
-{
-	u32 enable_spinup;
-
-	enable_spinup = readl(&sci_phy->link_layer_registers->notify_enable_spinup_control);
-	enable_spinup |= SCU_ENSPINUP_GEN_BIT(ENABLE);
-	writel(enable_spinup, &sci_phy->link_layer_registers->notify_enable_spinup_control);
-
-	/* Change state to the final state this substate machine has run to completion */
-	sci_base_state_machine_change_state(&sci_phy->state_machine,
-					    SCIC_SDS_PHY_STARTING_SUBSTATE_FINAL);
-
-	return SCI_SUCCESS;
-}
-
-/*
- * This method is called by the struct scic_sds_controller when the phy object is
- * granted power. - The phy state machine is transitioned to the
- * SCIC_SDS_PHY_STARTING_SUBSTATE_AWAIT_SATA_PHY_EN. enum sci_status SCI_SUCCESS
- */
-static enum sci_status scic_sds_phy_starting_substate_await_sata_power_consume_power_handler(
-	struct scic_sds_phy *sci_phy)
-{
-	u32 scu_sas_pcfg_value;
-
-	/* Release the spinup hold state and reset the OOB state machine */
-	scu_sas_pcfg_value =
-		readl(&sci_phy->link_layer_registers->phy_configuration);
-	scu_sas_pcfg_value &=
-		~(SCU_SAS_PCFG_GEN_BIT(SATA_SPINUP_HOLD) | SCU_SAS_PCFG_GEN_BIT(OOB_ENABLE));
-	scu_sas_pcfg_value |= SCU_SAS_PCFG_GEN_BIT(OOB_RESET);
-	writel(scu_sas_pcfg_value,
-		&sci_phy->link_layer_registers->phy_configuration);
-
-	/* Now restart the OOB operation */
-	scu_sas_pcfg_value &= ~SCU_SAS_PCFG_GEN_BIT(OOB_RESET);
-	scu_sas_pcfg_value |= SCU_SAS_PCFG_GEN_BIT(OOB_ENABLE);
-	writel(scu_sas_pcfg_value,
-		&sci_phy->link_layer_registers->phy_configuration);
-
-	/* Change state to the final state this substate machine has run to completion */
-	sci_base_state_machine_change_state(&sci_phy->state_machine,
-					    SCIC_SDS_PHY_STARTING_SUBSTATE_AWAIT_SATA_PHY_EN);
-
-	return SCI_SUCCESS;
-}
-
-static enum sci_status default_phy_handler(struct scic_sds_phy *sci_phy,
-					   const char *func)
-{
-	dev_dbg(sciphy_to_dev(sci_phy),
-		 "%s: in wrong state: %d\n", func,
-		 sci_base_state_machine_get_state(&sci_phy->state_machine));
-	return SCI_FAILURE_INVALID_STATE;
-}
-
-static enum sci_status
-scic_sds_phy_default_consume_power_handler(struct scic_sds_phy *sci_phy)
-{
-	return default_phy_handler(sci_phy, __func__);
-}
-
-
 enum sci_status scic_sds_phy_event_handler(struct scic_sds_phy *sci_phy,
 					   u32 event_code)
 {
@@ -1059,287 +1026,71 @@ enum sci_status scic_sds_phy_frame_handler(struct scic_sds_phy *sci_phy,
 	
 }
 
-
-
-/* --------------------------------------------------------------------------- */
-
-static const struct scic_sds_phy_state_handler scic_sds_phy_state_handler_table[] = {
-	[SCI_BASE_PHY_STATE_INITIAL] = {
-		.consume_power_handler	 = scic_sds_phy_default_consume_power_handler
-	},
-	[SCI_BASE_PHY_STATE_STOPPED]  = {
-		.consume_power_handler	 = scic_sds_phy_default_consume_power_handler
-	},
-	[SCI_BASE_PHY_STATE_STARTING] = {
-		.consume_power_handler	 = scic_sds_phy_default_consume_power_handler
-	},
-	[SCIC_SDS_PHY_STARTING_SUBSTATE_INITIAL] = {
-		.consume_power_handler	= scic_sds_phy_default_consume_power_handler
-	},
-	[SCIC_SDS_PHY_STARTING_SUBSTATE_AWAIT_OSSP_EN] = {
-		.consume_power_handler	= scic_sds_phy_default_consume_power_handler
-	},
-	[SCIC_SDS_PHY_STARTING_SUBSTATE_AWAIT_SAS_SPEED_EN] = {
-		.consume_power_handler	= scic_sds_phy_default_consume_power_handler
-	},
-	[SCIC_SDS_PHY_STARTING_SUBSTATE_AWAIT_IAF_UF] = {
-		.consume_power_handler	= scic_sds_phy_default_consume_power_handler
-	},
-	[SCIC_SDS_PHY_STARTING_SUBSTATE_AWAIT_SAS_POWER] = {
-		.consume_power_handler	= scic_sds_phy_starting_substate_await_sas_power_consume_power_handler
-	},
-	[SCIC_SDS_PHY_STARTING_SUBSTATE_AWAIT_SATA_POWER] = {
-		.consume_power_handler	= scic_sds_phy_starting_substate_await_sata_power_consume_power_handler
-	},
-	[SCIC_SDS_PHY_STARTING_SUBSTATE_AWAIT_SATA_PHY_EN] = {
-		.consume_power_handler	= scic_sds_phy_default_consume_power_handler
-	},
-	[SCIC_SDS_PHY_STARTING_SUBSTATE_AWAIT_SATA_SPEED_EN] = {
-		.consume_power_handler	= scic_sds_phy_default_consume_power_handler
-	},
-	[SCIC_SDS_PHY_STARTING_SUBSTATE_AWAIT_SIG_FIS_UF] = {
-		.consume_power_handler	= scic_sds_phy_default_consume_power_handler
-	},
-	[SCIC_SDS_PHY_STARTING_SUBSTATE_FINAL] = {
-		.consume_power_handler	 = scic_sds_phy_default_consume_power_handler
-	},
-	[SCI_BASE_PHY_STATE_READY] = {
-		.consume_power_handler	 = scic_sds_phy_default_consume_power_handler
-	},
-	[SCI_BASE_PHY_STATE_RESETTING] = {
-		.consume_power_handler	 = scic_sds_phy_default_consume_power_handler
-	},
-	[SCI_BASE_PHY_STATE_FINAL] = {
-		.consume_power_handler	 = scic_sds_phy_default_consume_power_handler
-	}
-};
-
-/*
- * ****************************************************************************
- * *  PHY STARTING SUBSTATE METHODS
- * **************************************************************************** */
-
-/**
- * scic_sds_phy_starting_initial_substate_enter -
- * @object: This is the object which is cast to a struct scic_sds_phy object.
- *
- * This method will perform the actions required by the struct scic_sds_phy on
- * entering the SCIC_SDS_PHY_STARTING_SUBSTATE_INITIAL. - The initial state
- * handlers are put in place for the struct scic_sds_phy object. - The state is
- * changed to the wait phy type event notification. none
- */
 static void scic_sds_phy_starting_initial_substate_enter(void *object)
 {
 	struct scic_sds_phy *sci_phy = object;
 
-	scic_sds_phy_set_base_state_handlers(
-		sci_phy, SCIC_SDS_PHY_STARTING_SUBSTATE_INITIAL);
-
 	/* This is just an temporary state go off to the starting state */
 	sci_base_state_machine_change_state(&sci_phy->state_machine,
 					    SCIC_SDS_PHY_STARTING_SUBSTATE_AWAIT_OSSP_EN);
 }
 
-/**
- *
- * @object: This is the object which is cast to a struct scic_sds_phy object.
- *
- * This method will perform the actions required by the struct scic_sds_phy on
- * entering the SCIC_SDS_PHY_STARTING_SUBSTATE_AWAIT_PHY_TYPE_EN. - Set the
- * struct scic_sds_phy object state handlers for this state. none
- */
-static void scic_sds_phy_starting_await_ossp_en_substate_enter(void *object)
-{
-	struct scic_sds_phy *sci_phy = object;
-
-	scic_sds_phy_set_base_state_handlers(
-		sci_phy, SCIC_SDS_PHY_STARTING_SUBSTATE_AWAIT_OSSP_EN
-		);
-}
-
-/**
- *
- * @object: This is the object which is cast to a struct scic_sds_phy object.
- *
- * This method will perform the actions required by the struct scic_sds_phy on
- * entering the SCIC_SDS_PHY_STARTING_SUBSTATE_AWAIT_SPEED_EN. - Set the
- * struct scic_sds_phy object state handlers for this state. none
- */
-static void scic_sds_phy_starting_await_sas_speed_en_substate_enter(
-		void *object)
-{
-	struct scic_sds_phy *sci_phy = object;
-
-	scic_sds_phy_set_base_state_handlers(
-		sci_phy, SCIC_SDS_PHY_STARTING_SUBSTATE_AWAIT_SAS_SPEED_EN
-		);
-}
-
-/**
- *
- * @object: This is the object which is cast to a struct scic_sds_phy object.
- *
- * This method will perform the actions required by the struct scic_sds_phy on
- * entering the SCIC_SDS_PHY_STARTING_SUBSTATE_AWAIT_IAF_UF. - Set the
- * struct scic_sds_phy object state handlers for this state. none
- */
-static void scic_sds_phy_starting_await_iaf_uf_substate_enter(void *object)
-{
-	struct scic_sds_phy *sci_phy = object;
-
-	scic_sds_phy_set_base_state_handlers(
-		sci_phy, SCIC_SDS_PHY_STARTING_SUBSTATE_AWAIT_IAF_UF
-		);
-}
-
-/**
- *
- * @object: This is the object which is cast to a struct scic_sds_phy object.
- *
- * This method will perform the actions required by the struct scic_sds_phy on
- * entering the SCIC_SDS_PHY_STARTING_SUBSTATE_AWAIT_SAS_POWER. - Set the
- * struct scic_sds_phy object state handlers for this state. - Add this phy object to
- * the power control queue none
- */
 static void scic_sds_phy_starting_await_sas_power_substate_enter(void *object)
 {
 	struct scic_sds_phy *sci_phy = object;
+	struct scic_sds_controller *scic = sci_phy->owning_port->owning_controller;
 
-	scic_sds_phy_set_base_state_handlers(
-		sci_phy, SCIC_SDS_PHY_STARTING_SUBSTATE_AWAIT_SAS_POWER
-		);
-
-	scic_sds_controller_power_control_queue_insert(
-		scic_sds_phy_get_controller(sci_phy),
-		sci_phy
-		);
+	scic_sds_controller_power_control_queue_insert(scic, sci_phy);
 }
 
-/**
- *
- * @object: This is the object which is cast to a struct scic_sds_phy object.
- *
- * This method will perform the actions required by the struct scic_sds_phy on exiting
- * the SCIC_SDS_PHY_STARTING_SUBSTATE_AWAIT_SAS_POWER. - Remove the
- * struct scic_sds_phy object from the power control queue. none
- */
 static void scic_sds_phy_starting_await_sas_power_substate_exit(void *object)
 {
 	struct scic_sds_phy *sci_phy = object;
+	struct scic_sds_controller *scic = sci_phy->owning_port->owning_controller;
 
-	scic_sds_controller_power_control_queue_remove(
-		scic_sds_phy_get_controller(sci_phy), sci_phy
-		);
+	scic_sds_controller_power_control_queue_remove(scic, sci_phy);
 }
 
-/**
- *
- * @object: This is the object which is cast to a struct scic_sds_phy object.
- *
- * This method will perform the actions required by the struct scic_sds_phy on
- * entering the SCIC_SDS_PHY_STARTING_SUBSTATE_AWAIT_SATA_POWER. - Set the
- * struct scic_sds_phy object state handlers for this state. - Add this phy object to
- * the power control queue none
- */
 static void scic_sds_phy_starting_await_sata_power_substate_enter(void *object)
 {
 	struct scic_sds_phy *sci_phy = object;
+	struct scic_sds_controller *scic = sci_phy->owning_port->owning_controller;
 
-	scic_sds_phy_set_base_state_handlers(
-		sci_phy, SCIC_SDS_PHY_STARTING_SUBSTATE_AWAIT_SATA_POWER
-		);
-
-	scic_sds_controller_power_control_queue_insert(
-		scic_sds_phy_get_controller(sci_phy),
-		sci_phy
-		);
+	scic_sds_controller_power_control_queue_insert(scic, sci_phy);
 }
 
-/**
- *
- * @object: This is the object which is cast to a struct scic_sds_phy object.
- *
- * This method will perform the actions required by the struct scic_sds_phy on exiting
- * the SCIC_SDS_PHY_STARTING_SUBSTATE_AWAIT_SATA_POWER. - Remove the
- * struct scic_sds_phy object from the power control queue. none
- */
 static void scic_sds_phy_starting_await_sata_power_substate_exit(void *object)
 {
 	struct scic_sds_phy *sci_phy = object;
+	struct scic_sds_controller *scic = sci_phy->owning_port->owning_controller;
 
-	scic_sds_controller_power_control_queue_remove(
-		scic_sds_phy_get_controller(sci_phy),
-		sci_phy
-		);
+	scic_sds_controller_power_control_queue_remove(scic, sci_phy);
 }
 
-/**
- *
- * @object: This is the object which is cast to a struct scic_sds_phy object.
- *
- * This function will perform the actions required by the struct scic_sds_phy on
- * entering the SCIC_SDS_PHY_STARTING_SUBSTATE_AWAIT_SATA_PHY_EN. - Set the
- * struct scic_sds_phy object state handlers for this state. none
- */
 static void scic_sds_phy_starting_await_sata_phy_substate_enter(void *object)
 {
 	struct scic_sds_phy *sci_phy = object;
 
-	scic_sds_phy_set_base_state_handlers(
-			sci_phy,
-			SCIC_SDS_PHY_STARTING_SUBSTATE_AWAIT_SATA_PHY_EN);
-
 	isci_timer_start(sci_phy->sata_timeout_timer,
 			 SCIC_SDS_SATA_LINK_TRAINING_TIMEOUT);
 }
 
-/**
- *
- * @object: This is the object which is cast to a struct scic_sds_phy object.
- *
- * This method will perform the actions required by the struct scic_sds_phy
- * on exiting
- * the SCIC_SDS_PHY_STARTING_SUBSTATE_AWAIT_SATA_SPEED_EN. - stop the timer
- * that was started on entry to await sata phy event notification none
- */
-static inline void scic_sds_phy_starting_await_sata_phy_substate_exit(
-		void *object)
+static void scic_sds_phy_starting_await_sata_phy_substate_exit(void *object)
 {
 	struct scic_sds_phy *sci_phy = object;
 
 	isci_timer_stop(sci_phy->sata_timeout_timer);
 }
 
-/**
- *
- * @object: This is the object which is cast to a struct scic_sds_phy object.
- *
- * This method will perform the actions required by the struct scic_sds_phy on
- * entering the SCIC_SDS_PHY_STARTING_SUBSTATE_AWAIT_SATA_SPEED_EN. - Set the
- * struct scic_sds_phy object state handlers for this state. none
- */
 static void scic_sds_phy_starting_await_sata_speed_substate_enter(void *object)
 {
 	struct scic_sds_phy *sci_phy = object;
 
-	scic_sds_phy_set_base_state_handlers(
-			sci_phy,
-			SCIC_SDS_PHY_STARTING_SUBSTATE_AWAIT_SATA_SPEED_EN);
-
 	isci_timer_start(sci_phy->sata_timeout_timer,
 			 SCIC_SDS_SATA_LINK_TRAINING_TIMEOUT);
 }
 
-/**
- *
- * @object: This is the object which is cast to a struct scic_sds_phy object.
- *
- * This function will perform the actions required by the
- * struct scic_sds_phy on exiting
- * the SCIC_SDS_PHY_STARTING_SUBSTATE_AWAIT_SATA_SPEED_EN. - stop the timer
- * that was started on entry to await sata phy event notification none
- */
-static inline void scic_sds_phy_starting_await_sata_speed_substate_exit(
+static void scic_sds_phy_starting_await_sata_speed_substate_exit(
 	void *object)
 {
 	struct scic_sds_phy *sci_phy = object;
@@ -1347,30 +1098,12 @@ static inline void scic_sds_phy_starting_await_sata_speed_substate_exit(
 	isci_timer_stop(sci_phy->sata_timeout_timer);
 }
 
-/**
- *
- * @object: This is the object which is cast to a struct scic_sds_phy object.
- *
- * This function will perform the actions required by the struct scic_sds_phy on
- * entering the SCIC_SDS_PHY_STARTING_SUBSTATE_AWAIT_SIG_FIS_UF. - Set the
- * struct scic_sds_phy object state handlers for this state.
- * - Start the SIGNATURE FIS
- * timeout timer none
- */
 static void scic_sds_phy_starting_await_sig_fis_uf_substate_enter(void *object)
 {
-	bool continue_to_ready_state;
 	struct scic_sds_phy *sci_phy = object;
 
-	scic_sds_phy_set_base_state_handlers(
-			sci_phy,
-			SCIC_SDS_PHY_STARTING_SUBSTATE_AWAIT_SIG_FIS_UF);
-
-	continue_to_ready_state = scic_sds_port_link_detected(
-		sci_phy->owning_port,
-		sci_phy);
+	if (scic_sds_port_link_detected(sci_phy->owning_port, sci_phy)) {
 
-	if (continue_to_ready_state) {
 		/*
 		 * Clear the PE suspend condition so we can actually
 		 * receive SIG FIS
@@ -1385,39 +1118,17 @@ static void scic_sds_phy_starting_await_sig_fis_uf_substate_enter(void *object)
 		sci_phy->is_in_link_training = false;
 }
 
-/**
- *
- * @object: This is the object which is cast to a struct scic_sds_phy object.
- *
- * This function will perform the actions required by the
- * struct scic_sds_phy on exiting
- * the SCIC_SDS_PHY_STARTING_SUBSTATE_AWAIT_SIG_FIS_UF. - Stop the SIGNATURE
- * FIS timeout timer. none
- */
-static inline void scic_sds_phy_starting_await_sig_fis_uf_substate_exit(
-	void *object)
+static void scic_sds_phy_starting_await_sig_fis_uf_substate_exit(void *object)
 {
 	struct scic_sds_phy *sci_phy = object;
 
 	isci_timer_stop(sci_phy->sata_timeout_timer);
 }
 
-/**
- *
- * @object: This is the object which is cast to a struct scic_sds_phy object.
- *
- * This method will perform the actions required by the struct scic_sds_phy on
- * entering the SCIC_SDS_PHY_STARTING_SUBSTATE_FINAL. - Set the struct scic_sds_phy
- * object state handlers for this state. - Change base state machine to the
- * ready state. none
- */
 static void scic_sds_phy_starting_final_substate_enter(void *object)
 {
 	struct scic_sds_phy *sci_phy = object;
 
-	scic_sds_phy_set_base_state_handlers(sci_phy,
-						    SCIC_SDS_PHY_STARTING_SUBSTATE_FINAL);
-
 	/* State machine has run to completion so exit out and change
 	 * the base state machine to the ready state
 	 */
@@ -1425,11 +1136,6 @@ static void scic_sds_phy_starting_final_substate_enter(void *object)
 					    SCI_BASE_PHY_STATE_READY);
 }
 
-/*
- * ****************************************************************************
- * *  PHY STATE PRIVATE METHODS
- * **************************************************************************** */
-
 /**
  *
  * @sci_phy: This is the struct scic_sds_phy object to stop.
@@ -1511,49 +1217,17 @@ static void scu_link_layer_tx_hard_reset(
 	       &sci_phy->link_layer_registers->phy_configuration);
 }
 
-/*
- * ****************************************************************************
- * *  PHY BASE STATE METHODS
- * **************************************************************************** */
-
-/**
- *
- * @object: This is the object which is cast to a struct scic_sds_phy object.
- *
- * This method will perform the actions required by the struct scic_sds_phy on
- * entering the SCI_BASE_PHY_STATE_INITIAL. - This function sets the state
- * handlers for the phy object base state machine initial state. none
- */
-static void scic_sds_phy_initial_state_enter(void *object)
-{
-	struct scic_sds_phy *sci_phy = object;
-
-	scic_sds_phy_set_base_state_handlers(sci_phy, SCI_BASE_PHY_STATE_INITIAL);
-}
-
-/**
- *
- * @object: This is the object which is cast to a struct scic_sds_phy object.
- *
- * This function will perform the actions required by the struct scic_sds_phy on
- * entering the SCI_BASE_PHY_STATE_INITIAL. - This function sets the state
- * handlers for the phy object base state machine initial state. - The SCU
- * hardware is requested to stop the protocol engine. none
- */
 static void scic_sds_phy_stopped_state_enter(void *object)
 {
 	struct scic_sds_phy *sci_phy = object;
-	struct scic_sds_controller *scic = scic_sds_phy_get_controller(sci_phy);
+	struct scic_sds_port *sci_port = sci_phy->owning_port;
+	struct scic_sds_controller *scic = sci_port->owning_controller;
 	struct isci_host *ihost = scic_to_ihost(scic);
 
 	/*
 	 * @todo We need to get to the controller to place this PE in a
 	 * reset state
 	 */
-
-	scic_sds_phy_set_base_state_handlers(sci_phy,
-					     SCI_BASE_PHY_STATE_STOPPED);
-
 	if (sci_phy->sata_timeout_timer != NULL) {
 		isci_del_timer(ihost, sci_phy->sata_timeout_timer);
 
@@ -1562,32 +1236,16 @@ static void scic_sds_phy_stopped_state_enter(void *object)
 
 	scu_link_layer_stop_protocol_engine(sci_phy);
 
-	if (sci_phy->state_machine.previous_state_id !=
-			SCI_BASE_PHY_STATE_INITIAL)
-		scic_sds_controller_link_down(
-				scic_sds_phy_get_controller(sci_phy),
-				scic_sds_phy_get_port(sci_phy),
-				sci_phy);
+	if (sci_phy->state_machine.previous_state_id != SCI_BASE_PHY_STATE_INITIAL)
+		scic_sds_controller_link_down(scic_sds_phy_get_controller(sci_phy),
+					      scic_sds_phy_get_port(sci_phy),
+					      sci_phy);
 }
 
-/**
- *
- * @object: This is the object which is cast to a struct scic_sds_phy object.
- *
- * This method will perform the actions required by the struct scic_sds_phy on
- * entering the SCI_BASE_PHY_STATE_STARTING. - This function sets the state
- * handlers for the phy object base state machine starting state. - The SCU
- * hardware is requested to start OOB/SN on this protocl engine. - The phy
- * starting substate machine is started. - If the previous state was the ready
- * state then the struct scic_sds_controller is informed that the phy has gone link
- * down. none
- */
 static void scic_sds_phy_starting_state_enter(void *object)
 {
 	struct scic_sds_phy *sci_phy = object;
 
-	scic_sds_phy_set_base_state_handlers(sci_phy, SCI_BASE_PHY_STATE_STARTING);
-
 	scu_link_layer_stop_protocol_engine(sci_phy);
 	scu_link_layer_start_oob(sci_phy);
 
@@ -1595,50 +1253,25 @@ static void scic_sds_phy_starting_state_enter(void *object)
 	sci_phy->protocol = SCIC_SDS_PHY_PROTOCOL_UNKNOWN;
 	sci_phy->bcn_received_while_port_unassigned = false;
 
-	if (sci_phy->state_machine.previous_state_id
-	    == SCI_BASE_PHY_STATE_READY) {
-		scic_sds_controller_link_down(
-			scic_sds_phy_get_controller(sci_phy),
-			scic_sds_phy_get_port(sci_phy),
-			sci_phy
-			);
-	}
+	if (sci_phy->state_machine.previous_state_id == SCI_BASE_PHY_STATE_READY)
+		scic_sds_controller_link_down(scic_sds_phy_get_controller(sci_phy),
+					      scic_sds_phy_get_port(sci_phy),
+					      sci_phy);
 
 	sci_base_state_machine_change_state(&sci_phy->state_machine,
 					    SCIC_SDS_PHY_STARTING_SUBSTATE_INITIAL);
 }
 
-/**
- *
- * @object: This is the object which is cast to a struct scic_sds_phy object.
- *
- * This method will perform the actions required by the struct scic_sds_phy on
- * entering the SCI_BASE_PHY_STATE_READY. - This function sets the state
- * handlers for the phy object base state machine ready state. - The SCU
- * hardware protocol engine is resumed. - The struct scic_sds_controller is informed
- * that the phy object has gone link up. none
- */
 static void scic_sds_phy_ready_state_enter(void *object)
 {
 	struct scic_sds_phy *sci_phy = object;
 
-	scic_sds_phy_set_base_state_handlers(sci_phy, SCI_BASE_PHY_STATE_READY);
+	scic_sds_controller_link_up(scic_sds_phy_get_controller(sci_phy),
+				    scic_sds_phy_get_port(sci_phy),
+				    sci_phy);
 
-	scic_sds_controller_link_up(
-		scic_sds_phy_get_controller(sci_phy),
-		scic_sds_phy_get_port(sci_phy),
-		sci_phy
-		);
 }
 
-/**
- *
- * @object: This is the object which is cast to a struct scic_sds_phy object.
- *
- * This method will perform the actions required by the struct scic_sds_phy on exiting
- * the SCI_BASE_PHY_STATE_INITIAL. This function suspends the SCU hardware
- * protocol engine represented by this struct scic_sds_phy object. none
- */
 static void scic_sds_phy_ready_state_exit(void *object)
 {
 	struct scic_sds_phy *sci_phy = object;
@@ -1646,62 +1279,29 @@ static void scic_sds_phy_ready_state_exit(void *object)
 	scic_sds_phy_suspend(sci_phy);
 }
 
-/**
- *
- * @object: This is the object which is cast to a struct scic_sds_phy object.
- *
- * This method will perform the actions required by the struct scic_sds_phy on
- * entering the SCI_BASE_PHY_STATE_RESETTING. - This function sets the state
- * handlers for the phy object base state machine resetting state. none
- */
 static void scic_sds_phy_resetting_state_enter(void *object)
 {
 	struct scic_sds_phy *sci_phy = object;
 
-	scic_sds_phy_set_base_state_handlers(sci_phy, SCI_BASE_PHY_STATE_RESETTING);
-
-	/*
-	 * The phy is being reset, therefore deactivate it from the port.
-	 * In the resetting state we don't notify the user regarding
-	 * link up and link down notifications. */
+	/* The phy is being reset, therefore deactivate it from the port.  In
+	 * the resetting state we don't notify the user regarding link up and
+	 * link down notifications
+	 */
 	scic_sds_port_deactivate_phy(sci_phy->owning_port, sci_phy, false);
 
 	if (sci_phy->protocol == SCIC_SDS_PHY_PROTOCOL_SAS) {
 		scu_link_layer_tx_hard_reset(sci_phy);
 	} else {
-		/*
-		 * The SCU does not need to have a discrete reset state so
+		/* The SCU does not need to have a discrete reset state so
 		 * just go back to the starting state.
 		 */
-		sci_base_state_machine_change_state(
-				&sci_phy->state_machine,
-				SCI_BASE_PHY_STATE_STARTING);
+		sci_base_state_machine_change_state(&sci_phy->state_machine,
+						    SCI_BASE_PHY_STATE_STARTING);
 	}
 }
 
-/**
- *
- * @object: This is the object which is cast to a struct scic_sds_phy object.
- *
- * This method will perform the actions required by the struct scic_sds_phy on
- * entering the SCI_BASE_PHY_STATE_FINAL. - This function sets the state
- * handlers for the phy object base state machine final state. none
- */
-static void scic_sds_phy_final_state_enter(void *object)
-{
-	struct scic_sds_phy *sci_phy = object;
-
-	scic_sds_phy_set_base_state_handlers(sci_phy, SCI_BASE_PHY_STATE_FINAL);
-
-	/* Nothing to do here */
-}
-
-/* --------------------------------------------------------------------------- */
-
 static const struct sci_base_state scic_sds_phy_state_table[] = {
-	[SCI_BASE_PHY_STATE_INITIAL] = {
-		.enter_state = scic_sds_phy_initial_state_enter,
-	},
+	[SCI_BASE_PHY_STATE_INITIAL] = { },
 	[SCI_BASE_PHY_STATE_STOPPED] = {
 		.enter_state = scic_sds_phy_stopped_state_enter,
 	},
@@ -1711,15 +1311,9 @@ static const struct sci_base_state scic_sds_phy_state_table[] = {
 	[SCIC_SDS_PHY_STARTING_SUBSTATE_INITIAL] = {
 		.enter_state = scic_sds_phy_starting_initial_substate_enter,
 	},
-	[SCIC_SDS_PHY_STARTING_SUBSTATE_AWAIT_OSSP_EN] = {
-		.enter_state = scic_sds_phy_starting_await_ossp_en_substate_enter,
-	},
-	[SCIC_SDS_PHY_STARTING_SUBSTATE_AWAIT_SAS_SPEED_EN] = {
-		.enter_state = scic_sds_phy_starting_await_sas_speed_en_substate_enter,
-	},
-	[SCIC_SDS_PHY_STARTING_SUBSTATE_AWAIT_IAF_UF] = {
-		.enter_state = scic_sds_phy_starting_await_iaf_uf_substate_enter,
-	},
+	[SCIC_SDS_PHY_STARTING_SUBSTATE_AWAIT_OSSP_EN] = { },
+	[SCIC_SDS_PHY_STARTING_SUBSTATE_AWAIT_SAS_SPEED_EN] = { },
+	[SCIC_SDS_PHY_STARTING_SUBSTATE_AWAIT_IAF_UF] = { },
 	[SCIC_SDS_PHY_STARTING_SUBSTATE_AWAIT_SAS_POWER] = {
 		.enter_state = scic_sds_phy_starting_await_sas_power_substate_enter,
 		.exit_state  = scic_sds_phy_starting_await_sas_power_substate_exit,
@@ -1750,9 +1344,7 @@ static const struct sci_base_state scic_sds_phy_state_table[] = {
 	[SCI_BASE_PHY_STATE_RESETTING] = {
 		.enter_state = scic_sds_phy_resetting_state_enter,
 	},
-	[SCI_BASE_PHY_STATE_FINAL] = {
-		.enter_state = scic_sds_phy_final_state_enter,
-	},
+	[SCI_BASE_PHY_STATE_FINAL] = { },
 };
 
 void scic_sds_phy_construct(struct scic_sds_phy *sci_phy,

commit 23506a69e2ee761824c266f6e2cd541a7287c2a5
Author: Dan Williams <dan.j.williams@intel.com>
Date:   Thu May 12 04:27:29 2011 -0700

    isci: unify phy event handlers
    
    Unify the implementations in scic_sds_phy_event_handler(), and kill the state handler
    
    Reported-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/drivers/scsi/isci/phy.c b/drivers/scsi/isci/phy.c
index 433ea605f70b..0ffb5d5a860e 100644
--- a/drivers/scsi/isci/phy.c
+++ b/drivers/scsi/isci/phy.c
@@ -505,116 +505,6 @@ enum sci_status scic_sds_phy_reset(struct scic_sds_phy *sci_phy)
 	return SCI_SUCCESS;
 }
 
-/**
- * This method will process the event code received.
- * @sci_phy:
- * @event_code:
- *
- * enum sci_status
- */
-enum sci_status scic_sds_phy_event_handler(
-	struct scic_sds_phy *sci_phy,
-	u32 event_code)
-{
-	return sci_phy->state_handlers->event_handler(sci_phy, event_code);
-}
-
-enum sci_status scic_sds_phy_frame_handler(struct scic_sds_phy *sci_phy,
-					   u32 frame_index)
-{
-	enum scic_sds_phy_states state = sci_phy->state_machine.current_state_id;
-	struct scic_sds_controller *scic = sci_phy->owning_port->owning_controller;
-	enum sci_status result;
-
-	switch (state) {
-	case SCIC_SDS_PHY_STARTING_SUBSTATE_AWAIT_IAF_UF: {
-		u32 *frame_words;
-		struct sas_identify_frame iaf;
-		struct isci_phy *iphy = sci_phy_to_iphy(sci_phy);
-
-		result = scic_sds_unsolicited_frame_control_get_header(&scic->uf_control,
-								       frame_index,
-								       (void **)&frame_words);
-
-		if (result != SCI_SUCCESS)
-			return result;
-
-		sci_swab32_cpy(&iaf, frame_words, sizeof(iaf) / sizeof(u32));
-		if (iaf.frame_type == 0) {
-			u32 state;
-
-			memcpy(&iphy->frame_rcvd.iaf, &iaf, sizeof(iaf));
-			if (iaf.smp_tport) {
-				/* We got the IAF for an expander PHY go to the final
-				 * state since there are no power requirements for
-				 * expander phys.
-				 */
-				state = SCIC_SDS_PHY_STARTING_SUBSTATE_FINAL;
-			} else {
-				/* We got the IAF we can now go to the await spinup
-				 * semaphore state
-				 */
-				state = SCIC_SDS_PHY_STARTING_SUBSTATE_AWAIT_SAS_POWER;
-			}
-			sci_base_state_machine_change_state(&sci_phy->state_machine,
-							    state);
-			result = SCI_SUCCESS;
-		} else
-			dev_warn(sciphy_to_dev(sci_phy),
-				"%s: PHY starting substate machine received "
-				"unexpected frame id %x\n",
-				__func__, frame_index);
-
-		scic_sds_controller_release_frame(scic, frame_index);
-		return result;
-	}
-	case SCIC_SDS_PHY_STARTING_SUBSTATE_AWAIT_SIG_FIS_UF: {
-		struct dev_to_host_fis *frame_header;
-		u32 *fis_frame_data;
-		struct isci_phy *iphy = sci_phy_to_iphy(sci_phy);
-
-		result = scic_sds_unsolicited_frame_control_get_header(
-			&(scic_sds_phy_get_controller(sci_phy)->uf_control),
-			frame_index,
-			(void **)&frame_header);
-
-		if (result != SCI_SUCCESS)
-			return result;
-
-		if ((frame_header->fis_type == FIS_REGD2H) &&
-		    !(frame_header->status & ATA_BUSY)) {
-			scic_sds_unsolicited_frame_control_get_buffer(&scic->uf_control,
-								      frame_index,
-								      (void **)&fis_frame_data);
-
-			scic_sds_controller_copy_sata_response(&iphy->frame_rcvd.fis,
-							       frame_header,
-							       fis_frame_data);
-
-			/* got IAF we can now go to the await spinup semaphore state */
-			sci_base_state_machine_change_state(&sci_phy->state_machine,
-							    SCIC_SDS_PHY_STARTING_SUBSTATE_FINAL);
-
-			result = SCI_SUCCESS;
-		} else
-			dev_warn(sciphy_to_dev(sci_phy),
-				 "%s: PHY starting substate machine received "
-				 "unexpected frame id %x\n",
-				 __func__, frame_index);
-
-		/* Regardless of the result we are done with this frame with it */
-		scic_sds_controller_release_frame(scic, frame_index);
-
-		return result;
-	}
-	default:
-		dev_dbg(sciphy_to_dev(sci_phy),
-			"%s: in wrong state: %d\n", __func__, state);
-		return SCI_FAILURE_INVALID_STATE;
-	}
-	
-}
-
 /**
  * This method will give the phy permission to consume power
  * @sci_phy:
@@ -702,455 +592,6 @@ static void scic_sds_phy_complete_link_training(
 					    next_state);
 }
 
-static void scic_sds_phy_restart_starting_state(
-	struct scic_sds_phy *sci_phy)
-{
-	/* Re-enter the base state machine starting state */
-	sci_base_state_machine_change_state(&sci_phy->state_machine,
-					    SCI_BASE_PHY_STATE_STARTING);
-}
-
-/**
- *
- * @phy: This struct scic_sds_phy object which has received an event.
- * @event_code: This is the event code which the phy object is to decode.
- *
- * This method is called when an event notification is received for the phy
- * object when in the state SCIC_SDS_PHY_STARTING_SUBSTATE_AWAIT_SPEED_EN. -
- * decode the event - sas phy detected causes a state transition to the wait
- * for speed event notification. - any other events log a warning message and
- * set a failure status enum sci_status SCI_SUCCESS on any valid event notification
- * SCI_FAILURE on any unexpected event notifation
- */
-static enum sci_status scic_sds_phy_starting_substate_await_ossp_event_handler(
-	struct scic_sds_phy *sci_phy,
-	u32 event_code)
-{
-	u32 result = SCI_SUCCESS;
-
-	switch (scu_get_event_code(event_code)) {
-	case SCU_EVENT_SAS_PHY_DETECTED:
-		scic_sds_phy_start_sas_link_training(sci_phy);
-		sci_phy->is_in_link_training = true;
-		break;
-
-	case SCU_EVENT_SATA_SPINUP_HOLD:
-		scic_sds_phy_start_sata_link_training(sci_phy);
-		sci_phy->is_in_link_training = true;
-		break;
-
-	default:
-		dev_dbg(sciphy_to_dev(sci_phy),
-			"%s: PHY starting substate machine received "
-			"unexpected event_code %x\n",
-			__func__,
-			event_code);
-
-		result = SCI_FAILURE;
-		break;
-	}
-
-	return result;
-}
-
-/**
- *
- * @phy: This struct scic_sds_phy object which has received an event.
- * @event_code: This is the event code which the phy object is to decode.
- *
- * This method is called when an event notification is received for the phy
- * object when in the state SCIC_SDS_PHY_STARTING_SUBSTATE_AWAIT_SPEED_EN. -
- * decode the event - sas phy detected returns us back to this state. - speed
- * event detected causes a state transition to the wait for iaf. - identify
- * timeout is an un-expected event and the state machine is restarted. - link
- * failure events restart the starting state machine - any other events log a
- * warning message and set a failure status enum sci_status SCI_SUCCESS on any valid
- * event notification SCI_FAILURE on any unexpected event notifation
- */
-static enum sci_status scic_sds_phy_starting_substate_await_sas_phy_speed_event_handler(
-	struct scic_sds_phy *sci_phy,
-	u32 event_code)
-{
-	u32 result = SCI_SUCCESS;
-
-	switch (scu_get_event_code(event_code)) {
-	case SCU_EVENT_SAS_PHY_DETECTED:
-		/*
-		 * Why is this being reported again by the controller?
-		 * We would re-enter this state so just stay here */
-		break;
-
-	case SCU_EVENT_SAS_15:
-	case SCU_EVENT_SAS_15_SSC:
-		scic_sds_phy_complete_link_training(
-			sci_phy,
-			SAS_LINK_RATE_1_5_GBPS,
-			SCIC_SDS_PHY_STARTING_SUBSTATE_AWAIT_IAF_UF);
-		break;
-
-	case SCU_EVENT_SAS_30:
-	case SCU_EVENT_SAS_30_SSC:
-		scic_sds_phy_complete_link_training(
-			sci_phy,
-			SAS_LINK_RATE_3_0_GBPS,
-			SCIC_SDS_PHY_STARTING_SUBSTATE_AWAIT_IAF_UF);
-		break;
-
-	case SCU_EVENT_SAS_60:
-	case SCU_EVENT_SAS_60_SSC:
-		scic_sds_phy_complete_link_training(
-			sci_phy,
-			SAS_LINK_RATE_6_0_GBPS,
-			SCIC_SDS_PHY_STARTING_SUBSTATE_AWAIT_IAF_UF);
-		break;
-
-	case SCU_EVENT_SATA_SPINUP_HOLD:
-		/*
-		 * We were doing SAS PHY link training and received a SATA PHY event
-		 * continue OOB/SN as if this were a SATA PHY */
-		scic_sds_phy_start_sata_link_training(sci_phy);
-		break;
-
-	case SCU_EVENT_LINK_FAILURE:
-		/* Link failure change state back to the starting state */
-		scic_sds_phy_restart_starting_state(sci_phy);
-		break;
-
-	default:
-		dev_warn(sciphy_to_dev(sci_phy),
-			 "%s: PHY starting substate machine received "
-			 "unexpected event_code %x\n",
-			 __func__,
-			 event_code);
-
-		result = SCI_FAILURE;
-		break;
-	}
-
-	return result;
-}
-
-/**
- *
- * @phy: This struct scic_sds_phy object which has received an event.
- * @event_code: This is the event code which the phy object is to decode.
- *
- * This method is called when an event notification is received for the phy
- * object when in the state SCIC_SDS_PHY_STARTING_SUBSTATE_AWAIT_IAF_UF. -
- * decode the event - sas phy detected event backs up the state machine to the
- * await speed notification. - identify timeout is an un-expected event and the
- * state machine is restarted. - link failure events restart the starting state
- * machine - any other events log a warning message and set a failure status
- * enum sci_status SCI_SUCCESS on any valid event notification SCI_FAILURE on any
- * unexpected event notifation
- */
-static enum sci_status scic_sds_phy_starting_substate_await_iaf_uf_event_handler(
-	struct scic_sds_phy *sci_phy,
-	u32 event_code)
-{
-	u32 result = SCI_SUCCESS;
-
-	switch (scu_get_event_code(event_code)) {
-	case SCU_EVENT_SAS_PHY_DETECTED:
-		/* Backup the state machine */
-		scic_sds_phy_start_sas_link_training(sci_phy);
-		break;
-
-	case SCU_EVENT_SATA_SPINUP_HOLD:
-		/*
-		 * We were doing SAS PHY link training and received a SATA PHY event
-		 * continue OOB/SN as if this were a SATA PHY */
-		scic_sds_phy_start_sata_link_training(sci_phy);
-		break;
-
-	case SCU_EVENT_RECEIVED_IDENTIFY_TIMEOUT:
-	case SCU_EVENT_LINK_FAILURE:
-	case SCU_EVENT_HARD_RESET_RECEIVED:
-		/* Start the oob/sn state machine over again */
-		scic_sds_phy_restart_starting_state(sci_phy);
-		break;
-
-	default:
-		dev_warn(sciphy_to_dev(sci_phy),
-			 "%s: PHY starting substate machine received "
-			 "unexpected event_code %x\n",
-			 __func__,
-			 event_code);
-
-		result = SCI_FAILURE;
-		break;
-	}
-
-	return result;
-}
-
-/**
- *
- * @phy: This struct scic_sds_phy object which has received an event.
- * @event_code: This is the event code which the phy object is to decode.
- *
- * This method is called when an event notification is received for the phy
- * object when in the state SCIC_SDS_PHY_STARTING_SUBSTATE_AWAIT_POWER. -
- * decode the event - link failure events restart the starting state machine -
- * any other events log a warning message and set a failure status enum sci_status
- * SCI_SUCCESS on a link failure event SCI_FAILURE on any unexpected event
- * notifation
- */
-static enum sci_status scic_sds_phy_starting_substate_await_sas_power_event_handler(
-	struct scic_sds_phy *sci_phy,
-	u32 event_code)
-{
-	u32 result = SCI_SUCCESS;
-
-	switch (scu_get_event_code(event_code)) {
-	case SCU_EVENT_LINK_FAILURE:
-		/* Link failure change state back to the starting state */
-		scic_sds_phy_restart_starting_state(sci_phy);
-		break;
-
-	default:
-		dev_warn(sciphy_to_dev(sci_phy),
-			"%s: PHY starting substate machine received unexpected "
-			"event_code %x\n",
-			__func__,
-			event_code);
-
-		result = SCI_FAILURE;
-		break;
-	}
-
-	return result;
-}
-
-/**
- *
- * @phy: This struct scic_sds_phy object which has received an event.
- * @event_code: This is the event code which the phy object is to decode.
- *
- * This method is called when an event notification is received for the phy
- * object when in the state SCIC_SDS_PHY_STARTING_SUBSTATE_AWAIT_SATA_POWER. -
- * decode the event - link failure events restart the starting state machine -
- * sata spinup hold events are ignored since they are expected - any other
- * events log a warning message and set a failure status enum sci_status SCI_SUCCESS
- * on a link failure event SCI_FAILURE on any unexpected event notifation
- */
-static enum sci_status scic_sds_phy_starting_substate_await_sata_power_event_handler(
-	struct scic_sds_phy *sci_phy,
-	u32 event_code)
-{
-	u32 result = SCI_SUCCESS;
-
-	switch (scu_get_event_code(event_code)) {
-	case SCU_EVENT_LINK_FAILURE:
-		/* Link failure change state back to the starting state */
-		scic_sds_phy_restart_starting_state(sci_phy);
-		break;
-
-	case SCU_EVENT_SATA_SPINUP_HOLD:
-		/* These events are received every 10ms and are expected while in this state */
-		break;
-
-	case SCU_EVENT_SAS_PHY_DETECTED:
-		/*
-		 * There has been a change in the phy type before OOB/SN for the
-		 * SATA finished start down the SAS link traning path. */
-		scic_sds_phy_start_sas_link_training(sci_phy);
-		break;
-
-	default:
-		dev_warn(sciphy_to_dev(sci_phy),
-			 "%s: PHY starting substate machine received "
-			 "unexpected event_code %x\n",
-			 __func__,
-			 event_code);
-
-		result = SCI_FAILURE;
-		break;
-	}
-
-	return result;
-}
-
-/**
- * scic_sds_phy_starting_substate_await_sata_phy_event_handler -
- * @phy: This struct scic_sds_phy object which has received an event.
- * @event_code: This is the event code which the phy object is to decode.
- *
- * This method is called when an event notification is received for the phy
- * object when in the state SCIC_SDS_PHY_STARTING_SUBSTATE_AWAIT_SATA_PHY_EN. -
- * decode the event - link failure events restart the starting state machine -
- * sata spinup hold events are ignored since they are expected - sata phy
- * detected event change to the wait speed event - any other events log a
- * warning message and set a failure status enum sci_status SCI_SUCCESS on a link
- * failure event SCI_FAILURE on any unexpected event notifation
- */
-static enum sci_status scic_sds_phy_starting_substate_await_sata_phy_event_handler(
-	struct scic_sds_phy *sci_phy, u32 event_code)
-{
-	u32 result = SCI_SUCCESS;
-
-	switch (scu_get_event_code(event_code)) {
-	case SCU_EVENT_LINK_FAILURE:
-		/* Link failure change state back to the starting state */
-		scic_sds_phy_restart_starting_state(sci_phy);
-		break;
-
-	case SCU_EVENT_SATA_SPINUP_HOLD:
-		/* These events might be received since we dont know how many may be in
-		 * the completion queue while waiting for power
-		 */
-		break;
-
-	case SCU_EVENT_SATA_PHY_DETECTED:
-		sci_phy->protocol = SCIC_SDS_PHY_PROTOCOL_SATA;
-
-		/* We have received the SATA PHY notification change state */
-		sci_base_state_machine_change_state(&sci_phy->state_machine,
-						    SCIC_SDS_PHY_STARTING_SUBSTATE_AWAIT_SATA_SPEED_EN);
-		break;
-
-	case SCU_EVENT_SAS_PHY_DETECTED:
-		/* There has been a change in the phy type before OOB/SN for the
-		 * SATA finished start down the SAS link traning path.
-		 */
-		scic_sds_phy_start_sas_link_training(sci_phy);
-		break;
-
-	default:
-		dev_warn(sciphy_to_dev(sci_phy),
-			 "%s: PHY starting substate machine received "
-			 "unexpected event_code %x\n",
-			 __func__,
-			 event_code);
-
-		result = SCI_FAILURE;
-		break;
-	}
-
-	return result;
-}
-
-/**
- *
- * @phy: This struct scic_sds_phy object which has received an event.
- * @event_code: This is the event code which the phy object is to decode.
- *
- * This method is called when an event notification is received for the phy
- * object when in the state SCIC_SDS_PHY_STARTING_SUBSTATE_AWAIT_SATA_SPEED_EN.
- * - decode the event - sata phy detected returns us back to this state. -
- * speed event detected causes a state transition to the wait for signature. -
- * link failure events restart the starting state machine - any other events
- * log a warning message and set a failure status enum sci_status SCI_SUCCESS on any
- * valid event notification SCI_FAILURE on any unexpected event notifation
- */
-static enum sci_status scic_sds_phy_starting_substate_await_sata_speed_event_handler(
-	struct scic_sds_phy *sci_phy,
-	u32 event_code)
-{
-	u32 result = SCI_SUCCESS;
-
-	switch (scu_get_event_code(event_code)) {
-	case SCU_EVENT_SATA_PHY_DETECTED:
-		/*
-		 * The hardware reports multiple SATA PHY detected events
-		 * ignore the extras */
-		break;
-
-	case SCU_EVENT_SATA_15:
-	case SCU_EVENT_SATA_15_SSC:
-		scic_sds_phy_complete_link_training(
-			sci_phy,
-			SAS_LINK_RATE_1_5_GBPS,
-			SCIC_SDS_PHY_STARTING_SUBSTATE_AWAIT_SIG_FIS_UF);
-		break;
-
-	case SCU_EVENT_SATA_30:
-	case SCU_EVENT_SATA_30_SSC:
-		scic_sds_phy_complete_link_training(
-			sci_phy,
-			SAS_LINK_RATE_3_0_GBPS,
-			SCIC_SDS_PHY_STARTING_SUBSTATE_AWAIT_SIG_FIS_UF);
-		break;
-
-	case SCU_EVENT_SATA_60:
-	case SCU_EVENT_SATA_60_SSC:
-		scic_sds_phy_complete_link_training(
-			sci_phy,
-			SAS_LINK_RATE_6_0_GBPS,
-			SCIC_SDS_PHY_STARTING_SUBSTATE_AWAIT_SIG_FIS_UF);
-		break;
-
-	case SCU_EVENT_LINK_FAILURE:
-		/* Link failure change state back to the starting state */
-		scic_sds_phy_restart_starting_state(sci_phy);
-		break;
-
-	case SCU_EVENT_SAS_PHY_DETECTED:
-		/*
-		 * There has been a change in the phy type before OOB/SN for the
-		 * SATA finished start down the SAS link traning path. */
-		scic_sds_phy_start_sas_link_training(sci_phy);
-		break;
-
-	default:
-		dev_warn(sciphy_to_dev(sci_phy),
-			 "%s: PHY starting substate machine received "
-			 "unexpected event_code %x\n",
-			 __func__,
-			 event_code);
-
-		result = SCI_FAILURE;
-		break;
-	}
-
-	return result;
-}
-
-/**
- * scic_sds_phy_starting_substate_await_sig_fis_event_handler -
- * @phy: This struct scic_sds_phy object which has received an event.
- * @event_code: This is the event code which the phy object is to decode.
- *
- * This method is called when an event notification is received for the phy
- * object when in the state SCIC_SDS_PHY_STARTING_SUBSTATE_AWAIT_SIG_FIS_UF. -
- * decode the event - sas phy detected event backs up the state machine to the
- * await speed notification. - identify timeout is an un-expected event and the
- * state machine is restarted. - link failure events restart the starting state
- * machine - any other events log a warning message and set a failure status
- * enum sci_status SCI_SUCCESS on any valid event notification SCI_FAILURE on any
- * unexpected event notifation
- */
-static enum sci_status scic_sds_phy_starting_substate_await_sig_fis_event_handler(
-	struct scic_sds_phy *sci_phy, u32 event_code)
-{
-	u32 result = SCI_SUCCESS;
-
-	switch (scu_get_event_code(event_code)) {
-	case SCU_EVENT_SATA_PHY_DETECTED:
-		/* Backup the state machine */
-		sci_base_state_machine_change_state(&sci_phy->state_machine,
-						    SCIC_SDS_PHY_STARTING_SUBSTATE_AWAIT_SATA_SPEED_EN);
-		break;
-
-	case SCU_EVENT_LINK_FAILURE:
-		/* Link failure change state back to the starting state */
-		scic_sds_phy_restart_starting_state(sci_phy);
-		break;
-
-	default:
-		dev_warn(sciphy_to_dev(sci_phy),
-			 "%s: PHY starting substate machine received "
-			 "unexpected event_code %x\n",
-			 __func__,
-			 event_code);
-
-		result = SCI_FAILURE;
-		break;
-	}
-
-	return result;
-}
-
 /*
  * This method is called by the struct scic_sds_controller when the phy object is
  * granted power. - The notify enable spinups are turned on for this phy object
@@ -1214,155 +655,461 @@ static enum sci_status default_phy_handler(struct scic_sds_phy *sci_phy,
 	return SCI_FAILURE_INVALID_STATE;
 }
 
-static enum sci_status
-scic_sds_phy_default_event_handler(struct scic_sds_phy *sci_phy,
-				   u32 event_code)
-{
-	return default_phy_handler(sci_phy, __func__);
-}
-
 static enum sci_status
 scic_sds_phy_default_consume_power_handler(struct scic_sds_phy *sci_phy)
 {
 	return default_phy_handler(sci_phy, __func__);
 }
 
-/**
- * scic_sds_phy_ready_state_event_handler -
- * @phy: This is the struct scic_sds_phy object which has received the event.
- *
- * This method request the struct scic_sds_phy handle the received event.  The only
- * event that we are interested in while in the ready state is the link failure
- * event. - decoded event is a link failure - transition the struct scic_sds_phy back
- * to the SCI_BASE_PHY_STATE_STARTING state. - any other event received will
- * report a warning message enum sci_status SCI_SUCCESS if the event received is a
- * link failure SCI_FAILURE_INVALID_STATE for any other event received.
- */
-static enum sci_status scic_sds_phy_ready_state_event_handler(struct scic_sds_phy *sci_phy,
-							      u32 event_code)
+
+enum sci_status scic_sds_phy_event_handler(struct scic_sds_phy *sci_phy,
+					   u32 event_code)
 {
-	enum sci_status result = SCI_FAILURE;
+	enum scic_sds_phy_states state = sci_phy->state_machine.current_state_id;
 
-	switch (scu_get_event_code(event_code)) {
-	case SCU_EVENT_LINK_FAILURE:
-		/* Link failure change state back to the starting state */
-		sci_base_state_machine_change_state(&sci_phy->state_machine,
-						    SCI_BASE_PHY_STATE_STARTING);
-		result = SCI_SUCCESS;
-		break;
+	switch (state) {
+	case SCIC_SDS_PHY_STARTING_SUBSTATE_AWAIT_OSSP_EN:
+		switch (scu_get_event_code(event_code)) {
+		case SCU_EVENT_SAS_PHY_DETECTED:
+			scic_sds_phy_start_sas_link_training(sci_phy);
+			sci_phy->is_in_link_training = true;
+			break;
+		case SCU_EVENT_SATA_SPINUP_HOLD:
+			scic_sds_phy_start_sata_link_training(sci_phy);
+			sci_phy->is_in_link_training = true;
+			break;
+		default:
+			dev_dbg(sciphy_to_dev(sci_phy),
+				"%s: PHY starting substate machine received "
+				"unexpected event_code %x\n",
+				__func__,
+				event_code);
+			return SCI_FAILURE;
+		}
+		return SCI_SUCCESS;
+	case SCIC_SDS_PHY_STARTING_SUBSTATE_AWAIT_SAS_SPEED_EN:
+		switch (scu_get_event_code(event_code)) {
+		case SCU_EVENT_SAS_PHY_DETECTED:
+			/*
+			 * Why is this being reported again by the controller?
+			 * We would re-enter this state so just stay here */
+			break;
+		case SCU_EVENT_SAS_15:
+		case SCU_EVENT_SAS_15_SSC:
+			scic_sds_phy_complete_link_training(
+				sci_phy,
+				SAS_LINK_RATE_1_5_GBPS,
+				SCIC_SDS_PHY_STARTING_SUBSTATE_AWAIT_IAF_UF);
+			break;
+		case SCU_EVENT_SAS_30:
+		case SCU_EVENT_SAS_30_SSC:
+			scic_sds_phy_complete_link_training(
+				sci_phy,
+				SAS_LINK_RATE_3_0_GBPS,
+				SCIC_SDS_PHY_STARTING_SUBSTATE_AWAIT_IAF_UF);
+			break;
+		case SCU_EVENT_SAS_60:
+		case SCU_EVENT_SAS_60_SSC:
+			scic_sds_phy_complete_link_training(
+				sci_phy,
+				SAS_LINK_RATE_6_0_GBPS,
+				SCIC_SDS_PHY_STARTING_SUBSTATE_AWAIT_IAF_UF);
+			break;
+		case SCU_EVENT_SATA_SPINUP_HOLD:
+			/*
+			 * We were doing SAS PHY link training and received a SATA PHY event
+			 * continue OOB/SN as if this were a SATA PHY */
+			scic_sds_phy_start_sata_link_training(sci_phy);
+			break;
+		case SCU_EVENT_LINK_FAILURE:
+			/* Link failure change state back to the starting state */
+			sci_base_state_machine_change_state(&sci_phy->state_machine,
+							    SCI_BASE_PHY_STATE_STARTING);
+			break;
+		default:
+			dev_warn(sciphy_to_dev(sci_phy),
+				 "%s: PHY starting substate machine received "
+				 "unexpected event_code %x\n",
+				 __func__, event_code);
+
+			return SCI_FAILURE;
+			break;
+		}
+		return SCI_SUCCESS;
+	case SCIC_SDS_PHY_STARTING_SUBSTATE_AWAIT_IAF_UF:
+		switch (scu_get_event_code(event_code)) {
+		case SCU_EVENT_SAS_PHY_DETECTED:
+			/* Backup the state machine */
+			scic_sds_phy_start_sas_link_training(sci_phy);
+			break;
+		case SCU_EVENT_SATA_SPINUP_HOLD:
+			/* We were doing SAS PHY link training and received a
+			 * SATA PHY event continue OOB/SN as if this were a
+			 * SATA PHY
+			 */
+			scic_sds_phy_start_sata_link_training(sci_phy);
+			break;
+		case SCU_EVENT_RECEIVED_IDENTIFY_TIMEOUT:
+		case SCU_EVENT_LINK_FAILURE:
+		case SCU_EVENT_HARD_RESET_RECEIVED:
+			/* Start the oob/sn state machine over again */
+			sci_base_state_machine_change_state(&sci_phy->state_machine,
+							    SCI_BASE_PHY_STATE_STARTING);
+			break;
+		default:
+			dev_warn(sciphy_to_dev(sci_phy),
+				 "%s: PHY starting substate machine received "
+				 "unexpected event_code %x\n",
+				 __func__, event_code);
+			return SCI_FAILURE;
+		}
+		return SCI_SUCCESS;
+	case SCIC_SDS_PHY_STARTING_SUBSTATE_AWAIT_SAS_POWER:
+		switch (scu_get_event_code(event_code)) {
+		case SCU_EVENT_LINK_FAILURE:
+			/* Link failure change state back to the starting state */
+			sci_base_state_machine_change_state(&sci_phy->state_machine,
+							    SCI_BASE_PHY_STATE_STARTING);
+			break;
+		default:
+			dev_warn(sciphy_to_dev(sci_phy),
+				"%s: PHY starting substate machine received unexpected "
+				"event_code %x\n",
+				__func__,
+				event_code);
+			return SCI_FAILURE;
+		}
+		return SCI_SUCCESS;
+	case SCIC_SDS_PHY_STARTING_SUBSTATE_AWAIT_SATA_POWER:
+		switch (scu_get_event_code(event_code)) {
+		case SCU_EVENT_LINK_FAILURE:
+			/* Link failure change state back to the starting state */
+			sci_base_state_machine_change_state(&sci_phy->state_machine,
+							    SCI_BASE_PHY_STATE_STARTING);
+			break;
+		case SCU_EVENT_SATA_SPINUP_HOLD:
+			/* These events are received every 10ms and are
+			 * expected while in this state
+			 */
+			break;
+
+		case SCU_EVENT_SAS_PHY_DETECTED:
+			/* There has been a change in the phy type before OOB/SN for the
+			 * SATA finished start down the SAS link traning path.
+			 */
+			scic_sds_phy_start_sas_link_training(sci_phy);
+			break;
+
+		default:
+			dev_warn(sciphy_to_dev(sci_phy),
+				 "%s: PHY starting substate machine received "
+				 "unexpected event_code %x\n",
+				 __func__, event_code);
 
-	case SCU_EVENT_BROADCAST_CHANGE:
-		/* Broadcast change received. Notify the port. */
-		if (scic_sds_phy_get_port(sci_phy) != NULL)
-			scic_sds_port_broadcast_change_received(sci_phy->owning_port, sci_phy);
-		else
-			sci_phy->bcn_received_while_port_unassigned = true;
-		break;
+			return SCI_FAILURE;
+		}
+		return SCI_SUCCESS;
+	case SCIC_SDS_PHY_STARTING_SUBSTATE_AWAIT_SATA_PHY_EN:
+		switch (scu_get_event_code(event_code)) {
+		case SCU_EVENT_LINK_FAILURE:
+			/* Link failure change state back to the starting state */
+			sci_base_state_machine_change_state(&sci_phy->state_machine,
+							    SCI_BASE_PHY_STATE_STARTING);
+			break;
+		case SCU_EVENT_SATA_SPINUP_HOLD:
+			/* These events might be received since we dont know how many may be in
+			 * the completion queue while waiting for power
+			 */
+			break;
+		case SCU_EVENT_SATA_PHY_DETECTED:
+			sci_phy->protocol = SCIC_SDS_PHY_PROTOCOL_SATA;
+
+			/* We have received the SATA PHY notification change state */
+			sci_base_state_machine_change_state(&sci_phy->state_machine,
+							    SCIC_SDS_PHY_STARTING_SUBSTATE_AWAIT_SATA_SPEED_EN);
+			break;
+		case SCU_EVENT_SAS_PHY_DETECTED:
+			/* There has been a change in the phy type before OOB/SN for the
+			 * SATA finished start down the SAS link traning path.
+			 */
+			scic_sds_phy_start_sas_link_training(sci_phy);
+			break;
+		default:
+			dev_warn(sciphy_to_dev(sci_phy),
+				 "%s: PHY starting substate machine received "
+				 "unexpected event_code %x\n",
+				 __func__,
+				 event_code);
 
-	default:
-		dev_warn(sciphy_to_dev(sci_phy),
-			 "%sP SCIC PHY 0x%p ready state machine received "
-			 "unexpected event_code %x\n",
-			 __func__, sci_phy, event_code);
+			return SCI_FAILURE;;
+		}
+		return SCI_SUCCESS;
+	case SCIC_SDS_PHY_STARTING_SUBSTATE_AWAIT_SATA_SPEED_EN:
+		switch (scu_get_event_code(event_code)) {
+		case SCU_EVENT_SATA_PHY_DETECTED:
+			/*
+			 * The hardware reports multiple SATA PHY detected events
+			 * ignore the extras */
+			break;
+		case SCU_EVENT_SATA_15:
+		case SCU_EVENT_SATA_15_SSC:
+			scic_sds_phy_complete_link_training(
+				sci_phy,
+				SAS_LINK_RATE_1_5_GBPS,
+				SCIC_SDS_PHY_STARTING_SUBSTATE_AWAIT_SIG_FIS_UF);
+			break;
+		case SCU_EVENT_SATA_30:
+		case SCU_EVENT_SATA_30_SSC:
+			scic_sds_phy_complete_link_training(
+				sci_phy,
+				SAS_LINK_RATE_3_0_GBPS,
+				SCIC_SDS_PHY_STARTING_SUBSTATE_AWAIT_SIG_FIS_UF);
+			break;
+		case SCU_EVENT_SATA_60:
+		case SCU_EVENT_SATA_60_SSC:
+			scic_sds_phy_complete_link_training(
+				sci_phy,
+				SAS_LINK_RATE_6_0_GBPS,
+				SCIC_SDS_PHY_STARTING_SUBSTATE_AWAIT_SIG_FIS_UF);
+			break;
+		case SCU_EVENT_LINK_FAILURE:
+			/* Link failure change state back to the starting state */
+			sci_base_state_machine_change_state(&sci_phy->state_machine,
+							    SCI_BASE_PHY_STATE_STARTING);
+			break;
+		case SCU_EVENT_SAS_PHY_DETECTED:
+			/*
+			 * There has been a change in the phy type before OOB/SN for the
+			 * SATA finished start down the SAS link traning path. */
+			scic_sds_phy_start_sas_link_training(sci_phy);
+			break;
+		default:
+			dev_warn(sciphy_to_dev(sci_phy),
+				 "%s: PHY starting substate machine received "
+				 "unexpected event_code %x\n",
+				 __func__, event_code);
 
-		result = SCI_FAILURE_INVALID_STATE;
-		break;
-	}
+			return SCI_FAILURE;
+		}
+
+		return SCI_SUCCESS;
+	case SCIC_SDS_PHY_STARTING_SUBSTATE_AWAIT_SIG_FIS_UF:
+		switch (scu_get_event_code(event_code)) {
+		case SCU_EVENT_SATA_PHY_DETECTED:
+			/* Backup the state machine */
+			sci_base_state_machine_change_state(&sci_phy->state_machine,
+							    SCIC_SDS_PHY_STARTING_SUBSTATE_AWAIT_SATA_SPEED_EN);
+			break;
+
+		case SCU_EVENT_LINK_FAILURE:
+			/* Link failure change state back to the starting state */
+			sci_base_state_machine_change_state(&sci_phy->state_machine,
+							    SCI_BASE_PHY_STATE_STARTING);
+			break;
 
-	return result;
+		default:
+			dev_warn(sciphy_to_dev(sci_phy),
+				 "%s: PHY starting substate machine received "
+				 "unexpected event_code %x\n",
+				 __func__,
+				 event_code);
+
+			return SCI_FAILURE;
+		}
+		return SCI_SUCCESS;
+	case SCI_BASE_PHY_STATE_READY:
+		switch (scu_get_event_code(event_code)) {
+		case SCU_EVENT_LINK_FAILURE:
+			/* Link failure change state back to the starting state */
+			sci_base_state_machine_change_state(&sci_phy->state_machine,
+							    SCI_BASE_PHY_STATE_STARTING);
+			break;
+		case SCU_EVENT_BROADCAST_CHANGE:
+			/* Broadcast change received. Notify the port. */
+			if (scic_sds_phy_get_port(sci_phy) != NULL)
+				scic_sds_port_broadcast_change_received(sci_phy->owning_port, sci_phy);
+			else
+				sci_phy->bcn_received_while_port_unassigned = true;
+			break;
+		default:
+			dev_warn(sciphy_to_dev(sci_phy),
+				 "%sP SCIC PHY 0x%p ready state machine received "
+				 "unexpected event_code %x\n",
+				 __func__, sci_phy, event_code);
+			return SCI_FAILURE_INVALID_STATE;
+		}
+		return SCI_SUCCESS;
+	case SCI_BASE_PHY_STATE_RESETTING:
+		switch (scu_get_event_code(event_code)) {
+		case SCU_EVENT_HARD_RESET_TRANSMITTED:
+			/* Link failure change state back to the starting state */
+			sci_base_state_machine_change_state(&sci_phy->state_machine,
+							    SCI_BASE_PHY_STATE_STARTING);
+			break;
+		default:
+			dev_warn(sciphy_to_dev(sci_phy),
+				 "%s: SCIC PHY 0x%p resetting state machine received "
+				 "unexpected event_code %x\n",
+				 __func__, sci_phy, event_code);
+
+			return SCI_FAILURE_INVALID_STATE;
+			break;
+		}
+		return SCI_SUCCESS;
+	default:
+		dev_dbg(sciphy_to_dev(sci_phy),
+			"%s: in wrong state: %d\n", __func__, state);
+		return SCI_FAILURE_INVALID_STATE;
+	}
 }
 
-static enum sci_status scic_sds_phy_resetting_state_event_handler(struct scic_sds_phy *sci_phy,
-								  u32 event_code)
+enum sci_status scic_sds_phy_frame_handler(struct scic_sds_phy *sci_phy,
+					   u32 frame_index)
 {
-	enum sci_status result = SCI_FAILURE;
+	enum scic_sds_phy_states state = sci_phy->state_machine.current_state_id;
+	struct scic_sds_controller *scic = sci_phy->owning_port->owning_controller;
+	enum sci_status result;
 
-	switch (scu_get_event_code(event_code)) {
-	case SCU_EVENT_HARD_RESET_TRANSMITTED:
-		/* Link failure change state back to the starting state */
-		sci_base_state_machine_change_state(&sci_phy->state_machine,
-						    SCI_BASE_PHY_STATE_STARTING);
-		result = SCI_SUCCESS;
-		break;
+	switch (state) {
+	case SCIC_SDS_PHY_STARTING_SUBSTATE_AWAIT_IAF_UF: {
+		u32 *frame_words;
+		struct sas_identify_frame iaf;
+		struct isci_phy *iphy = sci_phy_to_iphy(sci_phy);
 
-	default:
-		dev_warn(sciphy_to_dev(sci_phy),
-			 "%s: SCIC PHY 0x%p resetting state machine received "
-			 "unexpected event_code %x\n",
-			 __func__, sci_phy, event_code);
+		result = scic_sds_unsolicited_frame_control_get_header(&scic->uf_control,
+								       frame_index,
+								       (void **)&frame_words);
 
-		result = SCI_FAILURE_INVALID_STATE;
-		break;
+		if (result != SCI_SUCCESS)
+			return result;
+
+		sci_swab32_cpy(&iaf, frame_words, sizeof(iaf) / sizeof(u32));
+		if (iaf.frame_type == 0) {
+			u32 state;
+
+			memcpy(&iphy->frame_rcvd.iaf, &iaf, sizeof(iaf));
+			if (iaf.smp_tport) {
+				/* We got the IAF for an expander PHY go to the final
+				 * state since there are no power requirements for
+				 * expander phys.
+				 */
+				state = SCIC_SDS_PHY_STARTING_SUBSTATE_FINAL;
+			} else {
+				/* We got the IAF we can now go to the await spinup
+				 * semaphore state
+				 */
+				state = SCIC_SDS_PHY_STARTING_SUBSTATE_AWAIT_SAS_POWER;
+			}
+			sci_base_state_machine_change_state(&sci_phy->state_machine,
+							    state);
+			result = SCI_SUCCESS;
+		} else
+			dev_warn(sciphy_to_dev(sci_phy),
+				"%s: PHY starting substate machine received "
+				"unexpected frame id %x\n",
+				__func__, frame_index);
+
+		scic_sds_controller_release_frame(scic, frame_index);
+		return result;
 	}
+	case SCIC_SDS_PHY_STARTING_SUBSTATE_AWAIT_SIG_FIS_UF: {
+		struct dev_to_host_fis *frame_header;
+		u32 *fis_frame_data;
+		struct isci_phy *iphy = sci_phy_to_iphy(sci_phy);
+
+		result = scic_sds_unsolicited_frame_control_get_header(
+			&(scic_sds_phy_get_controller(sci_phy)->uf_control),
+			frame_index,
+			(void **)&frame_header);
+
+		if (result != SCI_SUCCESS)
+			return result;
 
-	return result;
+		if ((frame_header->fis_type == FIS_REGD2H) &&
+		    !(frame_header->status & ATA_BUSY)) {
+			scic_sds_unsolicited_frame_control_get_buffer(&scic->uf_control,
+								      frame_index,
+								      (void **)&fis_frame_data);
+
+			scic_sds_controller_copy_sata_response(&iphy->frame_rcvd.fis,
+							       frame_header,
+							       fis_frame_data);
+
+			/* got IAF we can now go to the await spinup semaphore state */
+			sci_base_state_machine_change_state(&sci_phy->state_machine,
+							    SCIC_SDS_PHY_STARTING_SUBSTATE_FINAL);
+
+			result = SCI_SUCCESS;
+		} else
+			dev_warn(sciphy_to_dev(sci_phy),
+				 "%s: PHY starting substate machine received "
+				 "unexpected frame id %x\n",
+				 __func__, frame_index);
+
+		/* Regardless of the result we are done with this frame with it */
+		scic_sds_controller_release_frame(scic, frame_index);
+
+		return result;
+	}
+	default:
+		dev_dbg(sciphy_to_dev(sci_phy),
+			"%s: in wrong state: %d\n", __func__, state);
+		return SCI_FAILURE_INVALID_STATE;
+	}
+	
 }
 
+
+
 /* --------------------------------------------------------------------------- */
 
 static const struct scic_sds_phy_state_handler scic_sds_phy_state_handler_table[] = {
 	[SCI_BASE_PHY_STATE_INITIAL] = {
-		.event_handler		 = scic_sds_phy_default_event_handler,
 		.consume_power_handler	 = scic_sds_phy_default_consume_power_handler
 	},
 	[SCI_BASE_PHY_STATE_STOPPED]  = {
-		.event_handler		 = scic_sds_phy_default_event_handler,
 		.consume_power_handler	 = scic_sds_phy_default_consume_power_handler
 	},
 	[SCI_BASE_PHY_STATE_STARTING] = {
-		.event_handler		 = scic_sds_phy_default_event_handler,
 		.consume_power_handler	 = scic_sds_phy_default_consume_power_handler
 	},
 	[SCIC_SDS_PHY_STARTING_SUBSTATE_INITIAL] = {
-		.event_handler		= scic_sds_phy_default_event_handler,
 		.consume_power_handler	= scic_sds_phy_default_consume_power_handler
 	},
 	[SCIC_SDS_PHY_STARTING_SUBSTATE_AWAIT_OSSP_EN] = {
-		.event_handler		= scic_sds_phy_starting_substate_await_ossp_event_handler,
 		.consume_power_handler	= scic_sds_phy_default_consume_power_handler
 	},
 	[SCIC_SDS_PHY_STARTING_SUBSTATE_AWAIT_SAS_SPEED_EN] = {
-		.event_handler		= scic_sds_phy_starting_substate_await_sas_phy_speed_event_handler,
 		.consume_power_handler	= scic_sds_phy_default_consume_power_handler
 	},
 	[SCIC_SDS_PHY_STARTING_SUBSTATE_AWAIT_IAF_UF] = {
-		.event_handler		= scic_sds_phy_starting_substate_await_iaf_uf_event_handler,
 		.consume_power_handler	= scic_sds_phy_default_consume_power_handler
 	},
 	[SCIC_SDS_PHY_STARTING_SUBSTATE_AWAIT_SAS_POWER] = {
-		.event_handler		= scic_sds_phy_starting_substate_await_sas_power_event_handler,
 		.consume_power_handler	= scic_sds_phy_starting_substate_await_sas_power_consume_power_handler
 	},
 	[SCIC_SDS_PHY_STARTING_SUBSTATE_AWAIT_SATA_POWER] = {
-		.event_handler		= scic_sds_phy_starting_substate_await_sata_power_event_handler,
 		.consume_power_handler	= scic_sds_phy_starting_substate_await_sata_power_consume_power_handler
 	},
 	[SCIC_SDS_PHY_STARTING_SUBSTATE_AWAIT_SATA_PHY_EN] = {
-		.event_handler		= scic_sds_phy_starting_substate_await_sata_phy_event_handler,
 		.consume_power_handler	= scic_sds_phy_default_consume_power_handler
 	},
 	[SCIC_SDS_PHY_STARTING_SUBSTATE_AWAIT_SATA_SPEED_EN] = {
-		.event_handler		= scic_sds_phy_starting_substate_await_sata_speed_event_handler,
 		.consume_power_handler	= scic_sds_phy_default_consume_power_handler
 	},
 	[SCIC_SDS_PHY_STARTING_SUBSTATE_AWAIT_SIG_FIS_UF] = {
-		.event_handler		= scic_sds_phy_starting_substate_await_sig_fis_event_handler,
 		.consume_power_handler	= scic_sds_phy_default_consume_power_handler
 	},
 	[SCIC_SDS_PHY_STARTING_SUBSTATE_FINAL] = {
-		.event_handler		 = scic_sds_phy_default_event_handler,
 		.consume_power_handler	 = scic_sds_phy_default_consume_power_handler
 	},
 	[SCI_BASE_PHY_STATE_READY] = {
-		.event_handler		 = scic_sds_phy_ready_state_event_handler,
 		.consume_power_handler	 = scic_sds_phy_default_consume_power_handler
 	},
 	[SCI_BASE_PHY_STATE_RESETTING] = {
-		.event_handler		 = scic_sds_phy_resetting_state_event_handler,
 		.consume_power_handler	 = scic_sds_phy_default_consume_power_handler
 	},
 	[SCI_BASE_PHY_STATE_FINAL] = {
-		.event_handler		 = scic_sds_phy_default_event_handler,
 		.consume_power_handler	 = scic_sds_phy_default_consume_power_handler
 	}
 };

commit c4441abc25a33ab259f01dce4b4d63721013f86d
Author: Dan Williams <dan.j.williams@intel.com>
Date:   Thu May 12 04:17:51 2011 -0700

    isci: unify phy frame handlers
    
    Unify the implementations in scic_sds_phy_frame_handler(), and kill the state handler
    
    Reported-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/drivers/scsi/isci/phy.c b/drivers/scsi/isci/phy.c
index 8beea40697da..433ea605f70b 100644
--- a/drivers/scsi/isci/phy.c
+++ b/drivers/scsi/isci/phy.c
@@ -519,18 +519,100 @@ enum sci_status scic_sds_phy_event_handler(
 	return sci_phy->state_handlers->event_handler(sci_phy, event_code);
 }
 
-/**
- * This method will process the frame index received.
- * @sci_phy:
- * @frame_index:
- *
- * enum sci_status
- */
-enum sci_status scic_sds_phy_frame_handler(
-	struct scic_sds_phy *sci_phy,
-	u32 frame_index)
+enum sci_status scic_sds_phy_frame_handler(struct scic_sds_phy *sci_phy,
+					   u32 frame_index)
 {
-	return sci_phy->state_handlers->frame_handler(sci_phy, frame_index);
+	enum scic_sds_phy_states state = sci_phy->state_machine.current_state_id;
+	struct scic_sds_controller *scic = sci_phy->owning_port->owning_controller;
+	enum sci_status result;
+
+	switch (state) {
+	case SCIC_SDS_PHY_STARTING_SUBSTATE_AWAIT_IAF_UF: {
+		u32 *frame_words;
+		struct sas_identify_frame iaf;
+		struct isci_phy *iphy = sci_phy_to_iphy(sci_phy);
+
+		result = scic_sds_unsolicited_frame_control_get_header(&scic->uf_control,
+								       frame_index,
+								       (void **)&frame_words);
+
+		if (result != SCI_SUCCESS)
+			return result;
+
+		sci_swab32_cpy(&iaf, frame_words, sizeof(iaf) / sizeof(u32));
+		if (iaf.frame_type == 0) {
+			u32 state;
+
+			memcpy(&iphy->frame_rcvd.iaf, &iaf, sizeof(iaf));
+			if (iaf.smp_tport) {
+				/* We got the IAF for an expander PHY go to the final
+				 * state since there are no power requirements for
+				 * expander phys.
+				 */
+				state = SCIC_SDS_PHY_STARTING_SUBSTATE_FINAL;
+			} else {
+				/* We got the IAF we can now go to the await spinup
+				 * semaphore state
+				 */
+				state = SCIC_SDS_PHY_STARTING_SUBSTATE_AWAIT_SAS_POWER;
+			}
+			sci_base_state_machine_change_state(&sci_phy->state_machine,
+							    state);
+			result = SCI_SUCCESS;
+		} else
+			dev_warn(sciphy_to_dev(sci_phy),
+				"%s: PHY starting substate machine received "
+				"unexpected frame id %x\n",
+				__func__, frame_index);
+
+		scic_sds_controller_release_frame(scic, frame_index);
+		return result;
+	}
+	case SCIC_SDS_PHY_STARTING_SUBSTATE_AWAIT_SIG_FIS_UF: {
+		struct dev_to_host_fis *frame_header;
+		u32 *fis_frame_data;
+		struct isci_phy *iphy = sci_phy_to_iphy(sci_phy);
+
+		result = scic_sds_unsolicited_frame_control_get_header(
+			&(scic_sds_phy_get_controller(sci_phy)->uf_control),
+			frame_index,
+			(void **)&frame_header);
+
+		if (result != SCI_SUCCESS)
+			return result;
+
+		if ((frame_header->fis_type == FIS_REGD2H) &&
+		    !(frame_header->status & ATA_BUSY)) {
+			scic_sds_unsolicited_frame_control_get_buffer(&scic->uf_control,
+								      frame_index,
+								      (void **)&fis_frame_data);
+
+			scic_sds_controller_copy_sata_response(&iphy->frame_rcvd.fis,
+							       frame_header,
+							       fis_frame_data);
+
+			/* got IAF we can now go to the await spinup semaphore state */
+			sci_base_state_machine_change_state(&sci_phy->state_machine,
+							    SCIC_SDS_PHY_STARTING_SUBSTATE_FINAL);
+
+			result = SCI_SUCCESS;
+		} else
+			dev_warn(sciphy_to_dev(sci_phy),
+				 "%s: PHY starting substate machine received "
+				 "unexpected frame id %x\n",
+				 __func__, frame_index);
+
+		/* Regardless of the result we are done with this frame with it */
+		scic_sds_controller_release_frame(scic, frame_index);
+
+		return result;
+	}
+	default:
+		dev_dbg(sciphy_to_dev(sci_phy),
+			"%s: in wrong state: %d\n", __func__, state);
+		return SCI_FAILURE_INVALID_STATE;
+	}
+	
 }
 
 /**
@@ -1069,141 +1151,6 @@ static enum sci_status scic_sds_phy_starting_substate_await_sig_fis_event_handle
 	return result;
 }
 
-
-/*
- * *****************************************************************************
- * *  SCIC SDS PHY FRAME_HANDLERS
- * ***************************************************************************** */
-
-/**
- *
- * @phy: This is struct scic_sds_phy object which is being requested to decode the
- *    frame data.
- * @frame_index: This is the index of the unsolicited frame which was received
- *    for this phy.
- *
- * This method decodes the unsolicited frame when the struct scic_sds_phy is in the
- * SCIC_SDS_PHY_STARTING_SUBSTATE_AWAIT_IAF_UF. - Get the UF Header - If the UF
- * is an IAF - Copy IAF data to local phy object IAF data buffer. - Change
- * starting substate to wait power. - else - log warning message of unexpected
- * unsolicted frame - release frame buffer enum sci_status SCI_SUCCESS
- */
-static enum sci_status scic_sds_phy_starting_substate_await_iaf_uf_frame_handler(
-	struct scic_sds_phy *sci_phy, u32 frame_index)
-{
-	enum sci_status result;
-	u32 *frame_words;
-	struct sas_identify_frame iaf;
-	struct isci_phy *iphy = sci_phy_to_iphy(sci_phy);
-
-	result = scic_sds_unsolicited_frame_control_get_header(
-		&(scic_sds_phy_get_controller(sci_phy)->uf_control),
-		frame_index,
-		(void **)&frame_words);
-
-	if (result != SCI_SUCCESS)
-		return result;
-
-	sci_swab32_cpy(&iaf, frame_words, sizeof(iaf) / sizeof(u32));
-	if (iaf.frame_type == 0) {
-		u32 state;
-
-		memcpy(&iphy->frame_rcvd.iaf, &iaf, sizeof(iaf));
-		if (iaf.smp_tport) {
-			/* We got the IAF for an expander PHY go to the final
-			 * state since there are no power requirements for
-			 * expander phys.
-			 */
-			state = SCIC_SDS_PHY_STARTING_SUBSTATE_FINAL;
-		} else {
-			/* We got the IAF we can now go to the await spinup
-			 * semaphore state
-			 */
-			state = SCIC_SDS_PHY_STARTING_SUBSTATE_AWAIT_SAS_POWER;
-		}
-		sci_base_state_machine_change_state(
-				&sci_phy->state_machine,
-				state);
-		result = SCI_SUCCESS;
-	} else
-		dev_warn(sciphy_to_dev(sci_phy),
-			"%s: PHY starting substate machine received "
-			"unexpected frame id %x\n",
-			__func__,
-			frame_index);
-
-	scic_sds_controller_release_frame(scic_sds_phy_get_controller(sci_phy),
-					  frame_index);
-
-	return result;
-}
-
-/**
- *
- * @phy: This is struct scic_sds_phy object which is being requested to decode the
- *    frame data.
- * @frame_index: This is the index of the unsolicited frame which was received
- *    for this phy.
- *
- * This method decodes the unsolicited frame when the struct scic_sds_phy is in the
- * SCIC_SDS_PHY_STARTING_SUBSTATE_AWAIT_SIG_FIS_UF. - Get the UF Header - If
- * the UF is an SIGNATURE FIS - Copy IAF data to local phy object SIGNATURE FIS
- * data buffer. - else - log warning message of unexpected unsolicted frame -
- * release frame buffer enum sci_status SCI_SUCCESS Must decode the SIGNATURE FIS
- * data
- */
-static enum sci_status scic_sds_phy_starting_substate_await_sig_fis_frame_handler(
-	struct scic_sds_phy *sci_phy,
-	u32 frame_index)
-{
-	enum sci_status result;
-	struct dev_to_host_fis *frame_header;
-	u32 *fis_frame_data;
-	struct isci_phy *iphy = sci_phy_to_iphy(sci_phy);
-
-	result = scic_sds_unsolicited_frame_control_get_header(
-		&(scic_sds_phy_get_controller(sci_phy)->uf_control),
-		frame_index,
-		(void **)&frame_header);
-
-	if (result != SCI_SUCCESS)
-		return result;
-
-	if ((frame_header->fis_type == FIS_REGD2H) &&
-	    !(frame_header->status & ATA_BUSY)) {
-		scic_sds_unsolicited_frame_control_get_buffer(
-			&(scic_sds_phy_get_controller(sci_phy)->uf_control),
-			frame_index,
-			(void **)&fis_frame_data);
-
-		scic_sds_controller_copy_sata_response(&iphy->frame_rcvd.fis,
-						       frame_header,
-						       fis_frame_data);
-
-		/* got IAF we can now go to the await spinup semaphore state */
-		sci_base_state_machine_change_state(&sci_phy->state_machine,
-						    SCIC_SDS_PHY_STARTING_SUBSTATE_FINAL);
-
-		result = SCI_SUCCESS;
-	} else
-		dev_warn(sciphy_to_dev(sci_phy),
-			 "%s: PHY starting substate machine received "
-			 "unexpected frame id %x\n",
-			 __func__,
-			 frame_index);
-
-	/* Regardless of the result we are done with this frame with it */
-	scic_sds_controller_release_frame(scic_sds_phy_get_controller(sci_phy),
-					  frame_index);
-
-	return result;
-}
-
-/*
- * *****************************************************************************
- * * SCIC SDS PHY POWER_HANDLERS
- * ***************************************************************************** */
-
 /*
  * This method is called by the struct scic_sds_controller when the phy object is
  * granted power. - The notify enable spinups are turned on for this phy object
@@ -1267,18 +1214,6 @@ static enum sci_status default_phy_handler(struct scic_sds_phy *sci_phy,
 	return SCI_FAILURE_INVALID_STATE;
 }
 
-static enum sci_status
-scic_sds_phy_default_frame_handler(struct scic_sds_phy *sci_phy,
-				   u32 frame_index)
-{
-	struct scic_sds_controller *scic = scic_sds_phy_get_controller(sci_phy);
-
-	default_phy_handler(sci_phy, __func__);
-	scic_sds_controller_release_frame(scic, frame_index);
-
-	return SCI_FAILURE_INVALID_STATE;
-}
-
 static enum sci_status
 scic_sds_phy_default_event_handler(struct scic_sds_phy *sci_phy,
 				   u32 event_code)
@@ -1367,82 +1302,66 @@ static enum sci_status scic_sds_phy_resetting_state_event_handler(struct scic_sd
 
 static const struct scic_sds_phy_state_handler scic_sds_phy_state_handler_table[] = {
 	[SCI_BASE_PHY_STATE_INITIAL] = {
-		.frame_handler		 = scic_sds_phy_default_frame_handler,
 		.event_handler		 = scic_sds_phy_default_event_handler,
 		.consume_power_handler	 = scic_sds_phy_default_consume_power_handler
 	},
 	[SCI_BASE_PHY_STATE_STOPPED]  = {
-		.frame_handler		 = scic_sds_phy_default_frame_handler,
 		.event_handler		 = scic_sds_phy_default_event_handler,
 		.consume_power_handler	 = scic_sds_phy_default_consume_power_handler
 	},
 	[SCI_BASE_PHY_STATE_STARTING] = {
-		.frame_handler		 = scic_sds_phy_default_frame_handler,
 		.event_handler		 = scic_sds_phy_default_event_handler,
 		.consume_power_handler	 = scic_sds_phy_default_consume_power_handler
 	},
 	[SCIC_SDS_PHY_STARTING_SUBSTATE_INITIAL] = {
-		.frame_handler		= scic_sds_phy_default_frame_handler,
 		.event_handler		= scic_sds_phy_default_event_handler,
 		.consume_power_handler	= scic_sds_phy_default_consume_power_handler
 	},
 	[SCIC_SDS_PHY_STARTING_SUBSTATE_AWAIT_OSSP_EN] = {
-		.frame_handler		= scic_sds_phy_default_frame_handler,
 		.event_handler		= scic_sds_phy_starting_substate_await_ossp_event_handler,
 		.consume_power_handler	= scic_sds_phy_default_consume_power_handler
 	},
 	[SCIC_SDS_PHY_STARTING_SUBSTATE_AWAIT_SAS_SPEED_EN] = {
-		.frame_handler		= scic_sds_phy_default_frame_handler,
 		.event_handler		= scic_sds_phy_starting_substate_await_sas_phy_speed_event_handler,
 		.consume_power_handler	= scic_sds_phy_default_consume_power_handler
 	},
 	[SCIC_SDS_PHY_STARTING_SUBSTATE_AWAIT_IAF_UF] = {
-		.frame_handler		= scic_sds_phy_starting_substate_await_iaf_uf_frame_handler,
 		.event_handler		= scic_sds_phy_starting_substate_await_iaf_uf_event_handler,
 		.consume_power_handler	= scic_sds_phy_default_consume_power_handler
 	},
 	[SCIC_SDS_PHY_STARTING_SUBSTATE_AWAIT_SAS_POWER] = {
-		.frame_handler		= scic_sds_phy_default_frame_handler,
 		.event_handler		= scic_sds_phy_starting_substate_await_sas_power_event_handler,
 		.consume_power_handler	= scic_sds_phy_starting_substate_await_sas_power_consume_power_handler
 	},
 	[SCIC_SDS_PHY_STARTING_SUBSTATE_AWAIT_SATA_POWER] = {
-		.frame_handler		= scic_sds_phy_default_frame_handler,
 		.event_handler		= scic_sds_phy_starting_substate_await_sata_power_event_handler,
 		.consume_power_handler	= scic_sds_phy_starting_substate_await_sata_power_consume_power_handler
 	},
 	[SCIC_SDS_PHY_STARTING_SUBSTATE_AWAIT_SATA_PHY_EN] = {
-		.frame_handler		= scic_sds_phy_default_frame_handler,
 		.event_handler		= scic_sds_phy_starting_substate_await_sata_phy_event_handler,
 		.consume_power_handler	= scic_sds_phy_default_consume_power_handler
 	},
 	[SCIC_SDS_PHY_STARTING_SUBSTATE_AWAIT_SATA_SPEED_EN] = {
-		.frame_handler		= scic_sds_phy_default_frame_handler,
 		.event_handler		= scic_sds_phy_starting_substate_await_sata_speed_event_handler,
 		.consume_power_handler	= scic_sds_phy_default_consume_power_handler
 	},
 	[SCIC_SDS_PHY_STARTING_SUBSTATE_AWAIT_SIG_FIS_UF] = {
-		.frame_handler		= scic_sds_phy_starting_substate_await_sig_fis_frame_handler,
 		.event_handler		= scic_sds_phy_starting_substate_await_sig_fis_event_handler,
 		.consume_power_handler	= scic_sds_phy_default_consume_power_handler
 	},
 	[SCIC_SDS_PHY_STARTING_SUBSTATE_FINAL] = {
-		.frame_handler		 = scic_sds_phy_default_frame_handler,
 		.event_handler		 = scic_sds_phy_default_event_handler,
 		.consume_power_handler	 = scic_sds_phy_default_consume_power_handler
 	},
 	[SCI_BASE_PHY_STATE_READY] = {
-		.frame_handler		 = scic_sds_phy_default_frame_handler,
 		.event_handler		 = scic_sds_phy_ready_state_event_handler,
 		.consume_power_handler	 = scic_sds_phy_default_consume_power_handler
 	},
 	[SCI_BASE_PHY_STATE_RESETTING] = {
-		.frame_handler		 = scic_sds_phy_default_frame_handler,
 		.event_handler		 = scic_sds_phy_resetting_state_event_handler,
 		.consume_power_handler	 = scic_sds_phy_default_consume_power_handler
 	},
 	[SCI_BASE_PHY_STATE_FINAL] = {
-		.frame_handler		 = scic_sds_phy_default_frame_handler,
 		.event_handler		 = scic_sds_phy_default_event_handler,
 		.consume_power_handler	 = scic_sds_phy_default_consume_power_handler
 	}

commit 35b317bec511b4a5f87a637bf78b6d1d635c617d
Author: Dan Williams <dan.j.williams@intel.com>
Date:   Thu May 12 04:10:41 2011 -0700

    isci: remove phy destruct handlers
    
    Unused infrastructure.
    
    Reported-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/drivers/scsi/isci/phy.c b/drivers/scsi/isci/phy.c
index b606e2f317d5..8beea40697da 100644
--- a/drivers/scsi/isci/phy.c
+++ b/drivers/scsi/isci/phy.c
@@ -1267,12 +1267,6 @@ static enum sci_status default_phy_handler(struct scic_sds_phy *sci_phy,
 	return SCI_FAILURE_INVALID_STATE;
 }
 
-static enum sci_status
-scic_sds_phy_default_destroy_handler(struct scic_sds_phy *sci_phy)
-{
-	return default_phy_handler(sci_phy, __func__);
-}
-
 static enum sci_status
 scic_sds_phy_default_frame_handler(struct scic_sds_phy *sci_phy,
 				   u32 frame_index)
@@ -1298,12 +1292,6 @@ scic_sds_phy_default_consume_power_handler(struct scic_sds_phy *sci_phy)
 	return default_phy_handler(sci_phy, __func__);
 }
 
-static enum sci_status
-scic_sds_phy_stopped_state_destroy_handler(struct scic_sds_phy *sci_phy)
-{
-	return SCI_SUCCESS;
-}
-
 /**
  * scic_sds_phy_ready_state_event_handler -
  * @phy: This is the struct scic_sds_phy object which has received the event.
@@ -1379,97 +1367,81 @@ static enum sci_status scic_sds_phy_resetting_state_event_handler(struct scic_sd
 
 static const struct scic_sds_phy_state_handler scic_sds_phy_state_handler_table[] = {
 	[SCI_BASE_PHY_STATE_INITIAL] = {
-		.destruct_handler = scic_sds_phy_default_destroy_handler,
 		.frame_handler		 = scic_sds_phy_default_frame_handler,
 		.event_handler		 = scic_sds_phy_default_event_handler,
 		.consume_power_handler	 = scic_sds_phy_default_consume_power_handler
 	},
 	[SCI_BASE_PHY_STATE_STOPPED]  = {
-		.destruct_handler = scic_sds_phy_stopped_state_destroy_handler,
 		.frame_handler		 = scic_sds_phy_default_frame_handler,
 		.event_handler		 = scic_sds_phy_default_event_handler,
 		.consume_power_handler	 = scic_sds_phy_default_consume_power_handler
 	},
 	[SCI_BASE_PHY_STATE_STARTING] = {
-		.destruct_handler = scic_sds_phy_default_destroy_handler,
 		.frame_handler		 = scic_sds_phy_default_frame_handler,
 		.event_handler		 = scic_sds_phy_default_event_handler,
 		.consume_power_handler	 = scic_sds_phy_default_consume_power_handler
 	},
 	[SCIC_SDS_PHY_STARTING_SUBSTATE_INITIAL] = {
-		.destruct_handler	= scic_sds_phy_default_destroy_handler,
 		.frame_handler		= scic_sds_phy_default_frame_handler,
 		.event_handler		= scic_sds_phy_default_event_handler,
 		.consume_power_handler	= scic_sds_phy_default_consume_power_handler
 	},
 	[SCIC_SDS_PHY_STARTING_SUBSTATE_AWAIT_OSSP_EN] = {
-		.destruct_handler	= scic_sds_phy_default_destroy_handler,
 		.frame_handler		= scic_sds_phy_default_frame_handler,
 		.event_handler		= scic_sds_phy_starting_substate_await_ossp_event_handler,
 		.consume_power_handler	= scic_sds_phy_default_consume_power_handler
 	},
 	[SCIC_SDS_PHY_STARTING_SUBSTATE_AWAIT_SAS_SPEED_EN] = {
-		.destruct_handler	= scic_sds_phy_default_destroy_handler,
 		.frame_handler		= scic_sds_phy_default_frame_handler,
 		.event_handler		= scic_sds_phy_starting_substate_await_sas_phy_speed_event_handler,
 		.consume_power_handler	= scic_sds_phy_default_consume_power_handler
 	},
 	[SCIC_SDS_PHY_STARTING_SUBSTATE_AWAIT_IAF_UF] = {
-		.destruct_handler	= scic_sds_phy_default_destroy_handler,
 		.frame_handler		= scic_sds_phy_starting_substate_await_iaf_uf_frame_handler,
 		.event_handler		= scic_sds_phy_starting_substate_await_iaf_uf_event_handler,
 		.consume_power_handler	= scic_sds_phy_default_consume_power_handler
 	},
 	[SCIC_SDS_PHY_STARTING_SUBSTATE_AWAIT_SAS_POWER] = {
-		.destruct_handler	= scic_sds_phy_default_destroy_handler,
 		.frame_handler		= scic_sds_phy_default_frame_handler,
 		.event_handler		= scic_sds_phy_starting_substate_await_sas_power_event_handler,
 		.consume_power_handler	= scic_sds_phy_starting_substate_await_sas_power_consume_power_handler
 	},
 	[SCIC_SDS_PHY_STARTING_SUBSTATE_AWAIT_SATA_POWER] = {
-		.destruct_handler	= scic_sds_phy_default_destroy_handler,
 		.frame_handler		= scic_sds_phy_default_frame_handler,
 		.event_handler		= scic_sds_phy_starting_substate_await_sata_power_event_handler,
 		.consume_power_handler	= scic_sds_phy_starting_substate_await_sata_power_consume_power_handler
 	},
 	[SCIC_SDS_PHY_STARTING_SUBSTATE_AWAIT_SATA_PHY_EN] = {
-		.destruct_handler	= scic_sds_phy_default_destroy_handler,
 		.frame_handler		= scic_sds_phy_default_frame_handler,
 		.event_handler		= scic_sds_phy_starting_substate_await_sata_phy_event_handler,
 		.consume_power_handler	= scic_sds_phy_default_consume_power_handler
 	},
 	[SCIC_SDS_PHY_STARTING_SUBSTATE_AWAIT_SATA_SPEED_EN] = {
-		.destruct_handler	= scic_sds_phy_default_destroy_handler,
 		.frame_handler		= scic_sds_phy_default_frame_handler,
 		.event_handler		= scic_sds_phy_starting_substate_await_sata_speed_event_handler,
 		.consume_power_handler	= scic_sds_phy_default_consume_power_handler
 	},
 	[SCIC_SDS_PHY_STARTING_SUBSTATE_AWAIT_SIG_FIS_UF] = {
-		.destruct_handler	= scic_sds_phy_default_destroy_handler,
 		.frame_handler		= scic_sds_phy_starting_substate_await_sig_fis_frame_handler,
 		.event_handler		= scic_sds_phy_starting_substate_await_sig_fis_event_handler,
 		.consume_power_handler	= scic_sds_phy_default_consume_power_handler
 	},
 	[SCIC_SDS_PHY_STARTING_SUBSTATE_FINAL] = {
-		.destruct_handler	= scic_sds_phy_default_destroy_handler,
 		.frame_handler		 = scic_sds_phy_default_frame_handler,
 		.event_handler		 = scic_sds_phy_default_event_handler,
 		.consume_power_handler	 = scic_sds_phy_default_consume_power_handler
 	},
 	[SCI_BASE_PHY_STATE_READY] = {
-		.destruct_handler = scic_sds_phy_default_destroy_handler,
 		.frame_handler		 = scic_sds_phy_default_frame_handler,
 		.event_handler		 = scic_sds_phy_ready_state_event_handler,
 		.consume_power_handler	 = scic_sds_phy_default_consume_power_handler
 	},
 	[SCI_BASE_PHY_STATE_RESETTING] = {
-		.destruct_handler = scic_sds_phy_default_destroy_handler,
 		.frame_handler		 = scic_sds_phy_default_frame_handler,
 		.event_handler		 = scic_sds_phy_resetting_state_event_handler,
 		.consume_power_handler	 = scic_sds_phy_default_consume_power_handler
 	},
 	[SCI_BASE_PHY_STATE_FINAL] = {
-		.destruct_handler = scic_sds_phy_default_destroy_handler,
 		.frame_handler		 = scic_sds_phy_default_frame_handler,
 		.event_handler		 = scic_sds_phy_default_event_handler,
 		.consume_power_handler	 = scic_sds_phy_default_consume_power_handler

commit 0cf36fa9f1197e669ac6f5efc51d0587bcc95e6e
Author: Dan Williams <dan.j.williams@intel.com>
Date:   Thu May 12 04:02:07 2011 -0700

    isci: unify phy reset handlers
    
    Unify the implementations in scic_sds_phy_reset(), and kill the state handler
    
    Reported-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/drivers/scsi/isci/phy.c b/drivers/scsi/isci/phy.c
index cf8f2e9f6b25..b606e2f317d5 100644
--- a/drivers/scsi/isci/phy.c
+++ b/drivers/scsi/isci/phy.c
@@ -490,17 +490,19 @@ enum sci_status scic_sds_phy_stop(struct scic_sds_phy *sci_phy)
 	return SCI_SUCCESS;
 }
 
-/**
- * This method will attempt to reset the phy.  This request is only valid when
- *    the phy is in an ready state
- * @sci_phy:
- *
- * enum sci_status
- */
-enum sci_status scic_sds_phy_reset(
-	struct scic_sds_phy *sci_phy)
+enum sci_status scic_sds_phy_reset(struct scic_sds_phy *sci_phy)
 {
-	return sci_phy->state_handlers->reset_handler(sci_phy);
+	enum scic_sds_phy_states state = sci_phy->state_machine.current_state_id;
+
+	if (state != SCI_BASE_PHY_STATE_READY) {
+		dev_dbg(sciphy_to_dev(sci_phy),
+			"%s: in wrong state: %d\n", __func__, state);
+		return SCI_FAILURE_INVALID_STATE;
+	}
+
+	sci_base_state_machine_change_state(&sci_phy->state_machine,
+					    SCI_BASE_PHY_STATE_RESETTING);
+	return SCI_SUCCESS;
 }
 
 /**
@@ -1265,12 +1267,6 @@ static enum sci_status default_phy_handler(struct scic_sds_phy *sci_phy,
 	return SCI_FAILURE_INVALID_STATE;
 }
 
-static enum sci_status
-scic_sds_phy_default_reset_handler(struct scic_sds_phy *sci_phy)
-{
-	return default_phy_handler(sci_phy, __func__);
-}
-
 static enum sci_status
 scic_sds_phy_default_destroy_handler(struct scic_sds_phy *sci_phy)
 {
@@ -1308,15 +1304,6 @@ scic_sds_phy_stopped_state_destroy_handler(struct scic_sds_phy *sci_phy)
 	return SCI_SUCCESS;
 }
 
-static enum sci_status
-scic_sds_phy_ready_state_reset_handler(struct scic_sds_phy *sci_phy)
-{
-	sci_base_state_machine_change_state(&sci_phy->state_machine,
-					    SCI_BASE_PHY_STATE_RESETTING);
-
-	return SCI_SUCCESS;
-}
-
 /**
  * scic_sds_phy_ready_state_event_handler -
  * @phy: This is the struct scic_sds_phy object which has received the event.
@@ -1392,112 +1379,96 @@ static enum sci_status scic_sds_phy_resetting_state_event_handler(struct scic_sd
 
 static const struct scic_sds_phy_state_handler scic_sds_phy_state_handler_table[] = {
 	[SCI_BASE_PHY_STATE_INITIAL] = {
-		.reset_handler = scic_sds_phy_default_reset_handler,
 		.destruct_handler = scic_sds_phy_default_destroy_handler,
 		.frame_handler		 = scic_sds_phy_default_frame_handler,
 		.event_handler		 = scic_sds_phy_default_event_handler,
 		.consume_power_handler	 = scic_sds_phy_default_consume_power_handler
 	},
 	[SCI_BASE_PHY_STATE_STOPPED]  = {
-		.reset_handler = scic_sds_phy_default_reset_handler,
 		.destruct_handler = scic_sds_phy_stopped_state_destroy_handler,
 		.frame_handler		 = scic_sds_phy_default_frame_handler,
 		.event_handler		 = scic_sds_phy_default_event_handler,
 		.consume_power_handler	 = scic_sds_phy_default_consume_power_handler
 	},
 	[SCI_BASE_PHY_STATE_STARTING] = {
-		.reset_handler = scic_sds_phy_default_reset_handler,
 		.destruct_handler = scic_sds_phy_default_destroy_handler,
 		.frame_handler		 = scic_sds_phy_default_frame_handler,
 		.event_handler		 = scic_sds_phy_default_event_handler,
 		.consume_power_handler	 = scic_sds_phy_default_consume_power_handler
 	},
 	[SCIC_SDS_PHY_STARTING_SUBSTATE_INITIAL] = {
-		.reset_handler		= scic_sds_phy_default_reset_handler,
 		.destruct_handler	= scic_sds_phy_default_destroy_handler,
 		.frame_handler		= scic_sds_phy_default_frame_handler,
 		.event_handler		= scic_sds_phy_default_event_handler,
 		.consume_power_handler	= scic_sds_phy_default_consume_power_handler
 	},
 	[SCIC_SDS_PHY_STARTING_SUBSTATE_AWAIT_OSSP_EN] = {
-		.reset_handler		= scic_sds_phy_default_reset_handler,
 		.destruct_handler	= scic_sds_phy_default_destroy_handler,
 		.frame_handler		= scic_sds_phy_default_frame_handler,
 		.event_handler		= scic_sds_phy_starting_substate_await_ossp_event_handler,
 		.consume_power_handler	= scic_sds_phy_default_consume_power_handler
 	},
 	[SCIC_SDS_PHY_STARTING_SUBSTATE_AWAIT_SAS_SPEED_EN] = {
-		.reset_handler		= scic_sds_phy_default_reset_handler,
 		.destruct_handler	= scic_sds_phy_default_destroy_handler,
 		.frame_handler		= scic_sds_phy_default_frame_handler,
 		.event_handler		= scic_sds_phy_starting_substate_await_sas_phy_speed_event_handler,
 		.consume_power_handler	= scic_sds_phy_default_consume_power_handler
 	},
 	[SCIC_SDS_PHY_STARTING_SUBSTATE_AWAIT_IAF_UF] = {
-		.reset_handler		= scic_sds_phy_default_reset_handler,
 		.destruct_handler	= scic_sds_phy_default_destroy_handler,
 		.frame_handler		= scic_sds_phy_starting_substate_await_iaf_uf_frame_handler,
 		.event_handler		= scic_sds_phy_starting_substate_await_iaf_uf_event_handler,
 		.consume_power_handler	= scic_sds_phy_default_consume_power_handler
 	},
 	[SCIC_SDS_PHY_STARTING_SUBSTATE_AWAIT_SAS_POWER] = {
-		.reset_handler		= scic_sds_phy_default_reset_handler,
 		.destruct_handler	= scic_sds_phy_default_destroy_handler,
 		.frame_handler		= scic_sds_phy_default_frame_handler,
 		.event_handler		= scic_sds_phy_starting_substate_await_sas_power_event_handler,
 		.consume_power_handler	= scic_sds_phy_starting_substate_await_sas_power_consume_power_handler
 	},
 	[SCIC_SDS_PHY_STARTING_SUBSTATE_AWAIT_SATA_POWER] = {
-		.reset_handler		= scic_sds_phy_default_reset_handler,
 		.destruct_handler	= scic_sds_phy_default_destroy_handler,
 		.frame_handler		= scic_sds_phy_default_frame_handler,
 		.event_handler		= scic_sds_phy_starting_substate_await_sata_power_event_handler,
 		.consume_power_handler	= scic_sds_phy_starting_substate_await_sata_power_consume_power_handler
 	},
 	[SCIC_SDS_PHY_STARTING_SUBSTATE_AWAIT_SATA_PHY_EN] = {
-		.reset_handler		= scic_sds_phy_default_reset_handler,
 		.destruct_handler	= scic_sds_phy_default_destroy_handler,
 		.frame_handler		= scic_sds_phy_default_frame_handler,
 		.event_handler		= scic_sds_phy_starting_substate_await_sata_phy_event_handler,
 		.consume_power_handler	= scic_sds_phy_default_consume_power_handler
 	},
 	[SCIC_SDS_PHY_STARTING_SUBSTATE_AWAIT_SATA_SPEED_EN] = {
-		.reset_handler		= scic_sds_phy_default_reset_handler,
 		.destruct_handler	= scic_sds_phy_default_destroy_handler,
 		.frame_handler		= scic_sds_phy_default_frame_handler,
 		.event_handler		= scic_sds_phy_starting_substate_await_sata_speed_event_handler,
 		.consume_power_handler	= scic_sds_phy_default_consume_power_handler
 	},
 	[SCIC_SDS_PHY_STARTING_SUBSTATE_AWAIT_SIG_FIS_UF] = {
-		.reset_handler		= scic_sds_phy_default_reset_handler,
 		.destruct_handler	= scic_sds_phy_default_destroy_handler,
 		.frame_handler		= scic_sds_phy_starting_substate_await_sig_fis_frame_handler,
 		.event_handler		= scic_sds_phy_starting_substate_await_sig_fis_event_handler,
 		.consume_power_handler	= scic_sds_phy_default_consume_power_handler
 	},
 	[SCIC_SDS_PHY_STARTING_SUBSTATE_FINAL] = {
-		.reset_handler		= scic_sds_phy_default_reset_handler,
 		.destruct_handler	= scic_sds_phy_default_destroy_handler,
 		.frame_handler		 = scic_sds_phy_default_frame_handler,
 		.event_handler		 = scic_sds_phy_default_event_handler,
 		.consume_power_handler	 = scic_sds_phy_default_consume_power_handler
 	},
 	[SCI_BASE_PHY_STATE_READY] = {
-		.reset_handler = scic_sds_phy_ready_state_reset_handler,
 		.destruct_handler = scic_sds_phy_default_destroy_handler,
 		.frame_handler		 = scic_sds_phy_default_frame_handler,
 		.event_handler		 = scic_sds_phy_ready_state_event_handler,
 		.consume_power_handler	 = scic_sds_phy_default_consume_power_handler
 	},
 	[SCI_BASE_PHY_STATE_RESETTING] = {
-		.reset_handler = scic_sds_phy_default_reset_handler,
 		.destruct_handler = scic_sds_phy_default_destroy_handler,
 		.frame_handler		 = scic_sds_phy_default_frame_handler,
 		.event_handler		 = scic_sds_phy_resetting_state_event_handler,
 		.consume_power_handler	 = scic_sds_phy_default_consume_power_handler
 	},
 	[SCI_BASE_PHY_STATE_FINAL] = {
-		.reset_handler = scic_sds_phy_default_reset_handler,
 		.destruct_handler = scic_sds_phy_default_destroy_handler,
 		.frame_handler		 = scic_sds_phy_default_frame_handler,
 		.event_handler		 = scic_sds_phy_default_event_handler,

commit 931532364e7966f61683bdf40fa1698d6707f523
Author: Dan Williams <dan.j.williams@intel.com>
Date:   Thu May 12 04:01:03 2011 -0700

    isci: unify phy stop handlers
    
    Merge all implementations in scic_sds_phy_stop(), and kill the state handler
    
    Reported-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/drivers/scsi/isci/phy.c b/drivers/scsi/isci/phy.c
index 7cae192a2a30..cf8f2e9f6b25 100644
--- a/drivers/scsi/isci/phy.c
+++ b/drivers/scsi/isci/phy.c
@@ -463,16 +463,31 @@ enum sci_status scic_sds_phy_start(struct scic_sds_phy *sci_phy)
 	return SCI_SUCCESS;
 }
 
-/**
- * This method will attempt to stop the phy object.
- * @sci_phy:
- *
- * enum sci_status SCI_SUCCESS if the phy is going to stop SCI_INVALID_STATE
- * if the phy is not in a valid state to stop
- */
 enum sci_status scic_sds_phy_stop(struct scic_sds_phy *sci_phy)
 {
-	return sci_phy->state_handlers->stop_handler(sci_phy);
+	enum scic_sds_phy_states state = sci_phy->state_machine.current_state_id;
+
+	switch (state) {
+	case SCIC_SDS_PHY_STARTING_SUBSTATE_INITIAL:
+	case SCIC_SDS_PHY_STARTING_SUBSTATE_AWAIT_OSSP_EN:
+	case SCIC_SDS_PHY_STARTING_SUBSTATE_AWAIT_SAS_SPEED_EN:
+	case SCIC_SDS_PHY_STARTING_SUBSTATE_AWAIT_SAS_POWER:
+	case SCIC_SDS_PHY_STARTING_SUBSTATE_AWAIT_SATA_POWER:
+	case SCIC_SDS_PHY_STARTING_SUBSTATE_AWAIT_SATA_PHY_EN:
+	case SCIC_SDS_PHY_STARTING_SUBSTATE_AWAIT_SATA_SPEED_EN:
+	case SCIC_SDS_PHY_STARTING_SUBSTATE_AWAIT_SIG_FIS_UF:
+	case SCIC_SDS_PHY_STARTING_SUBSTATE_FINAL:
+	case SCI_BASE_PHY_STATE_READY:
+		break;
+	default:
+		dev_dbg(sciphy_to_dev(sci_phy),
+			"%s: in wrong state: %d\n", __func__, state);
+		return SCI_FAILURE_INVALID_STATE;
+	}
+
+	sci_base_state_machine_change_state(&sci_phy->state_machine,
+					    SCI_BASE_PHY_STATE_STOPPED);
+	return SCI_SUCCESS;
 }
 
 /**
@@ -611,23 +626,6 @@ static void scic_sds_phy_restart_starting_state(
 					    SCI_BASE_PHY_STATE_STARTING);
 }
 
-/* ****************************************************************************
-   * SCIC SDS PHY general handlers
-   ************************************************************************** */
-static enum sci_status scic_sds_phy_starting_substate_general_stop_handler(
-	struct scic_sds_phy *phy)
-{
-	sci_base_state_machine_change_state(&phy->state_machine,
-						 SCI_BASE_PHY_STATE_STOPPED);
-
-	return SCI_SUCCESS;
-}
-
-/*
- * *****************************************************************************
- * * SCIC SDS PHY EVENT_HANDLERS
- * ***************************************************************************** */
-
 /**
  *
  * @phy: This struct scic_sds_phy object which has received an event.
@@ -1267,12 +1265,6 @@ static enum sci_status default_phy_handler(struct scic_sds_phy *sci_phy,
 	return SCI_FAILURE_INVALID_STATE;
 }
 
-static enum sci_status
-scic_sds_phy_default_stop_handler(struct scic_sds_phy *sci_phy)
-{
-	return default_phy_handler(sci_phy, __func__);
-}
-
 static enum sci_status
 scic_sds_phy_default_reset_handler(struct scic_sds_phy *sci_phy)
 {
@@ -1316,15 +1308,6 @@ scic_sds_phy_stopped_state_destroy_handler(struct scic_sds_phy *sci_phy)
 	return SCI_SUCCESS;
 }
 
-static enum sci_status
-scic_sds_phy_ready_state_stop_handler(struct scic_sds_phy *sci_phy)
-{
-	sci_base_state_machine_change_state(&sci_phy->state_machine,
-					    SCI_BASE_PHY_STATE_STOPPED);
-
-	return SCI_SUCCESS;
-}
-
 static enum sci_status
 scic_sds_phy_ready_state_reset_handler(struct scic_sds_phy *sci_phy)
 {
@@ -1409,7 +1392,6 @@ static enum sci_status scic_sds_phy_resetting_state_event_handler(struct scic_sd
 
 static const struct scic_sds_phy_state_handler scic_sds_phy_state_handler_table[] = {
 	[SCI_BASE_PHY_STATE_INITIAL] = {
-		.stop_handler  = scic_sds_phy_default_stop_handler,
 		.reset_handler = scic_sds_phy_default_reset_handler,
 		.destruct_handler = scic_sds_phy_default_destroy_handler,
 		.frame_handler		 = scic_sds_phy_default_frame_handler,
@@ -1417,7 +1399,6 @@ static const struct scic_sds_phy_state_handler scic_sds_phy_state_handler_table[
 		.consume_power_handler	 = scic_sds_phy_default_consume_power_handler
 	},
 	[SCI_BASE_PHY_STATE_STOPPED]  = {
-		.stop_handler  = scic_sds_phy_default_stop_handler,
 		.reset_handler = scic_sds_phy_default_reset_handler,
 		.destruct_handler = scic_sds_phy_stopped_state_destroy_handler,
 		.frame_handler		 = scic_sds_phy_default_frame_handler,
@@ -1425,7 +1406,6 @@ static const struct scic_sds_phy_state_handler scic_sds_phy_state_handler_table[
 		.consume_power_handler	 = scic_sds_phy_default_consume_power_handler
 	},
 	[SCI_BASE_PHY_STATE_STARTING] = {
-		.stop_handler  = scic_sds_phy_default_stop_handler,
 		.reset_handler = scic_sds_phy_default_reset_handler,
 		.destruct_handler = scic_sds_phy_default_destroy_handler,
 		.frame_handler		 = scic_sds_phy_default_frame_handler,
@@ -1433,7 +1413,6 @@ static const struct scic_sds_phy_state_handler scic_sds_phy_state_handler_table[
 		.consume_power_handler	 = scic_sds_phy_default_consume_power_handler
 	},
 	[SCIC_SDS_PHY_STARTING_SUBSTATE_INITIAL] = {
-		.stop_handler		= scic_sds_phy_starting_substate_general_stop_handler,
 		.reset_handler		= scic_sds_phy_default_reset_handler,
 		.destruct_handler	= scic_sds_phy_default_destroy_handler,
 		.frame_handler		= scic_sds_phy_default_frame_handler,
@@ -1441,7 +1420,6 @@ static const struct scic_sds_phy_state_handler scic_sds_phy_state_handler_table[
 		.consume_power_handler	= scic_sds_phy_default_consume_power_handler
 	},
 	[SCIC_SDS_PHY_STARTING_SUBSTATE_AWAIT_OSSP_EN] = {
-		.stop_handler		= scic_sds_phy_starting_substate_general_stop_handler,
 		.reset_handler		= scic_sds_phy_default_reset_handler,
 		.destruct_handler	= scic_sds_phy_default_destroy_handler,
 		.frame_handler		= scic_sds_phy_default_frame_handler,
@@ -1449,7 +1427,6 @@ static const struct scic_sds_phy_state_handler scic_sds_phy_state_handler_table[
 		.consume_power_handler	= scic_sds_phy_default_consume_power_handler
 	},
 	[SCIC_SDS_PHY_STARTING_SUBSTATE_AWAIT_SAS_SPEED_EN] = {
-		.stop_handler		= scic_sds_phy_starting_substate_general_stop_handler,
 		.reset_handler		= scic_sds_phy_default_reset_handler,
 		.destruct_handler	= scic_sds_phy_default_destroy_handler,
 		.frame_handler		= scic_sds_phy_default_frame_handler,
@@ -1457,7 +1434,6 @@ static const struct scic_sds_phy_state_handler scic_sds_phy_state_handler_table[
 		.consume_power_handler	= scic_sds_phy_default_consume_power_handler
 	},
 	[SCIC_SDS_PHY_STARTING_SUBSTATE_AWAIT_IAF_UF] = {
-		.stop_handler		= scic_sds_phy_default_stop_handler,
 		.reset_handler		= scic_sds_phy_default_reset_handler,
 		.destruct_handler	= scic_sds_phy_default_destroy_handler,
 		.frame_handler		= scic_sds_phy_starting_substate_await_iaf_uf_frame_handler,
@@ -1465,7 +1441,6 @@ static const struct scic_sds_phy_state_handler scic_sds_phy_state_handler_table[
 		.consume_power_handler	= scic_sds_phy_default_consume_power_handler
 	},
 	[SCIC_SDS_PHY_STARTING_SUBSTATE_AWAIT_SAS_POWER] = {
-		.stop_handler		= scic_sds_phy_starting_substate_general_stop_handler,
 		.reset_handler		= scic_sds_phy_default_reset_handler,
 		.destruct_handler	= scic_sds_phy_default_destroy_handler,
 		.frame_handler		= scic_sds_phy_default_frame_handler,
@@ -1473,7 +1448,6 @@ static const struct scic_sds_phy_state_handler scic_sds_phy_state_handler_table[
 		.consume_power_handler	= scic_sds_phy_starting_substate_await_sas_power_consume_power_handler
 	},
 	[SCIC_SDS_PHY_STARTING_SUBSTATE_AWAIT_SATA_POWER] = {
-		.stop_handler		= scic_sds_phy_starting_substate_general_stop_handler,
 		.reset_handler		= scic_sds_phy_default_reset_handler,
 		.destruct_handler	= scic_sds_phy_default_destroy_handler,
 		.frame_handler		= scic_sds_phy_default_frame_handler,
@@ -1481,7 +1455,6 @@ static const struct scic_sds_phy_state_handler scic_sds_phy_state_handler_table[
 		.consume_power_handler	= scic_sds_phy_starting_substate_await_sata_power_consume_power_handler
 	},
 	[SCIC_SDS_PHY_STARTING_SUBSTATE_AWAIT_SATA_PHY_EN] = {
-		.stop_handler		= scic_sds_phy_starting_substate_general_stop_handler,
 		.reset_handler		= scic_sds_phy_default_reset_handler,
 		.destruct_handler	= scic_sds_phy_default_destroy_handler,
 		.frame_handler		= scic_sds_phy_default_frame_handler,
@@ -1489,7 +1462,6 @@ static const struct scic_sds_phy_state_handler scic_sds_phy_state_handler_table[
 		.consume_power_handler	= scic_sds_phy_default_consume_power_handler
 	},
 	[SCIC_SDS_PHY_STARTING_SUBSTATE_AWAIT_SATA_SPEED_EN] = {
-		.stop_handler		= scic_sds_phy_starting_substate_general_stop_handler,
 		.reset_handler		= scic_sds_phy_default_reset_handler,
 		.destruct_handler	= scic_sds_phy_default_destroy_handler,
 		.frame_handler		= scic_sds_phy_default_frame_handler,
@@ -1497,7 +1469,6 @@ static const struct scic_sds_phy_state_handler scic_sds_phy_state_handler_table[
 		.consume_power_handler	= scic_sds_phy_default_consume_power_handler
 	},
 	[SCIC_SDS_PHY_STARTING_SUBSTATE_AWAIT_SIG_FIS_UF] = {
-		.stop_handler		= scic_sds_phy_starting_substate_general_stop_handler,
 		.reset_handler		= scic_sds_phy_default_reset_handler,
 		.destruct_handler	= scic_sds_phy_default_destroy_handler,
 		.frame_handler		= scic_sds_phy_starting_substate_await_sig_fis_frame_handler,
@@ -1505,7 +1476,6 @@ static const struct scic_sds_phy_state_handler scic_sds_phy_state_handler_table[
 		.consume_power_handler	= scic_sds_phy_default_consume_power_handler
 	},
 	[SCIC_SDS_PHY_STARTING_SUBSTATE_FINAL] = {
-		.stop_handler		= scic_sds_phy_starting_substate_general_stop_handler,
 		.reset_handler		= scic_sds_phy_default_reset_handler,
 		.destruct_handler	= scic_sds_phy_default_destroy_handler,
 		.frame_handler		 = scic_sds_phy_default_frame_handler,
@@ -1513,7 +1483,6 @@ static const struct scic_sds_phy_state_handler scic_sds_phy_state_handler_table[
 		.consume_power_handler	 = scic_sds_phy_default_consume_power_handler
 	},
 	[SCI_BASE_PHY_STATE_READY] = {
-		.stop_handler  = scic_sds_phy_ready_state_stop_handler,
 		.reset_handler = scic_sds_phy_ready_state_reset_handler,
 		.destruct_handler = scic_sds_phy_default_destroy_handler,
 		.frame_handler		 = scic_sds_phy_default_frame_handler,
@@ -1521,7 +1490,6 @@ static const struct scic_sds_phy_state_handler scic_sds_phy_state_handler_table[
 		.consume_power_handler	 = scic_sds_phy_default_consume_power_handler
 	},
 	[SCI_BASE_PHY_STATE_RESETTING] = {
-		.stop_handler  = scic_sds_phy_default_stop_handler,
 		.reset_handler = scic_sds_phy_default_reset_handler,
 		.destruct_handler = scic_sds_phy_default_destroy_handler,
 		.frame_handler		 = scic_sds_phy_default_frame_handler,
@@ -1529,7 +1497,6 @@ static const struct scic_sds_phy_state_handler scic_sds_phy_state_handler_table[
 		.consume_power_handler	 = scic_sds_phy_default_consume_power_handler
 	},
 	[SCI_BASE_PHY_STATE_FINAL] = {
-		.stop_handler  = scic_sds_phy_default_stop_handler,
 		.reset_handler = scic_sds_phy_default_reset_handler,
 		.destruct_handler = scic_sds_phy_default_destroy_handler,
 		.frame_handler		 = scic_sds_phy_default_frame_handler,

commit 966699b50c61940e06ff39fb1085bea813f9a51d
Author: Dan Williams <dan.j.williams@intel.com>
Date:   Thu May 12 03:44:24 2011 -0700

    isci: unify phy start handlers
    
    Implement all handlers in scic_sds_phy_start(), and kill the state handler
    
    Reported-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/drivers/scsi/isci/phy.c b/drivers/scsi/isci/phy.c
index e5ae676926f2..7cae192a2a30 100644
--- a/drivers/scsi/isci/phy.c
+++ b/drivers/scsi/isci/phy.c
@@ -440,16 +440,27 @@ void scic_sds_phy_get_protocols(struct scic_sds_phy *sci_phy,
 				0x0000FFFF);
 }
 
-/**
- * This method will attempt to start the phy object. This request is only valid
- *    when the phy is in the stopped state
- * @sci_phy:
- *
- * enum sci_status
- */
 enum sci_status scic_sds_phy_start(struct scic_sds_phy *sci_phy)
 {
-	return sci_phy->state_handlers->start_handler(sci_phy);
+	struct scic_sds_controller *scic = sci_phy->owning_port->owning_controller;
+	enum scic_sds_phy_states state = sci_phy->state_machine.current_state_id;
+	struct isci_host *ihost = scic_to_ihost(scic);
+
+	if (state != SCI_BASE_PHY_STATE_STOPPED) {
+		dev_dbg(sciphy_to_dev(sci_phy),
+			 "%s: in wrong state: %d\n", __func__, state);
+		return SCI_FAILURE_INVALID_STATE;
+	}
+
+	/* Create the SIGNATURE FIS Timeout timer for this phy */
+	sci_phy->sata_timeout_timer = isci_timer_create(ihost, sci_phy,
+							scic_sds_phy_sata_timeout);
+
+	if (sci_phy->sata_timeout_timer)
+		sci_base_state_machine_change_state(&sci_phy->state_machine,
+						    SCI_BASE_PHY_STATE_STARTING);
+
+	return SCI_SUCCESS;
 }
 
 /**
@@ -1256,12 +1267,6 @@ static enum sci_status default_phy_handler(struct scic_sds_phy *sci_phy,
 	return SCI_FAILURE_INVALID_STATE;
 }
 
-static enum sci_status
-scic_sds_phy_default_start_handler(struct scic_sds_phy *sci_phy)
-{
-	return default_phy_handler(sci_phy, __func__);
-}
-
 static enum sci_status
 scic_sds_phy_default_stop_handler(struct scic_sds_phy *sci_phy)
 {
@@ -1305,31 +1310,6 @@ scic_sds_phy_default_consume_power_handler(struct scic_sds_phy *sci_phy)
 	return default_phy_handler(sci_phy, __func__);
 }
 
-/*
- * This method takes the struct scic_sds_phy from a stopped state and
- * attempts to start it. - The phy state machine is transitioned to the
- * SCI_BASE_PHY_STATE_STARTING. enum sci_status SCI_SUCCESS
- */
-static enum sci_status
-scic_sds_phy_stopped_state_start_handler(struct scic_sds_phy *sci_phy)
-{
-	struct isci_host *ihost;
-	struct scic_sds_controller *scic;
-
-	scic = scic_sds_phy_get_controller(sci_phy),
-	ihost = scic_to_ihost(scic);
-
-	/* Create the SIGNATURE FIS Timeout timer for this phy */
-	sci_phy->sata_timeout_timer = isci_timer_create(ihost, sci_phy,
-							scic_sds_phy_sata_timeout);
-
-	if (sci_phy->sata_timeout_timer)
-		sci_base_state_machine_change_state(&sci_phy->state_machine,
-						    SCI_BASE_PHY_STATE_STARTING);
-
-	return SCI_SUCCESS;
-}
-
 static enum sci_status
 scic_sds_phy_stopped_state_destroy_handler(struct scic_sds_phy *sci_phy)
 {
@@ -1429,7 +1409,6 @@ static enum sci_status scic_sds_phy_resetting_state_event_handler(struct scic_sd
 
 static const struct scic_sds_phy_state_handler scic_sds_phy_state_handler_table[] = {
 	[SCI_BASE_PHY_STATE_INITIAL] = {
-		.start_handler = scic_sds_phy_default_start_handler,
 		.stop_handler  = scic_sds_phy_default_stop_handler,
 		.reset_handler = scic_sds_phy_default_reset_handler,
 		.destruct_handler = scic_sds_phy_default_destroy_handler,
@@ -1438,7 +1417,6 @@ static const struct scic_sds_phy_state_handler scic_sds_phy_state_handler_table[
 		.consume_power_handler	 = scic_sds_phy_default_consume_power_handler
 	},
 	[SCI_BASE_PHY_STATE_STOPPED]  = {
-		.start_handler = scic_sds_phy_stopped_state_start_handler,
 		.stop_handler  = scic_sds_phy_default_stop_handler,
 		.reset_handler = scic_sds_phy_default_reset_handler,
 		.destruct_handler = scic_sds_phy_stopped_state_destroy_handler,
@@ -1447,7 +1425,6 @@ static const struct scic_sds_phy_state_handler scic_sds_phy_state_handler_table[
 		.consume_power_handler	 = scic_sds_phy_default_consume_power_handler
 	},
 	[SCI_BASE_PHY_STATE_STARTING] = {
-		.start_handler = scic_sds_phy_default_start_handler,
 		.stop_handler  = scic_sds_phy_default_stop_handler,
 		.reset_handler = scic_sds_phy_default_reset_handler,
 		.destruct_handler = scic_sds_phy_default_destroy_handler,
@@ -1456,7 +1433,6 @@ static const struct scic_sds_phy_state_handler scic_sds_phy_state_handler_table[
 		.consume_power_handler	 = scic_sds_phy_default_consume_power_handler
 	},
 	[SCIC_SDS_PHY_STARTING_SUBSTATE_INITIAL] = {
-		.start_handler		= scic_sds_phy_default_start_handler,
 		.stop_handler		= scic_sds_phy_starting_substate_general_stop_handler,
 		.reset_handler		= scic_sds_phy_default_reset_handler,
 		.destruct_handler	= scic_sds_phy_default_destroy_handler,
@@ -1465,7 +1441,6 @@ static const struct scic_sds_phy_state_handler scic_sds_phy_state_handler_table[
 		.consume_power_handler	= scic_sds_phy_default_consume_power_handler
 	},
 	[SCIC_SDS_PHY_STARTING_SUBSTATE_AWAIT_OSSP_EN] = {
-		.start_handler		= scic_sds_phy_default_start_handler,
 		.stop_handler		= scic_sds_phy_starting_substate_general_stop_handler,
 		.reset_handler		= scic_sds_phy_default_reset_handler,
 		.destruct_handler	= scic_sds_phy_default_destroy_handler,
@@ -1474,7 +1449,6 @@ static const struct scic_sds_phy_state_handler scic_sds_phy_state_handler_table[
 		.consume_power_handler	= scic_sds_phy_default_consume_power_handler
 	},
 	[SCIC_SDS_PHY_STARTING_SUBSTATE_AWAIT_SAS_SPEED_EN] = {
-		.start_handler		= scic_sds_phy_default_start_handler,
 		.stop_handler		= scic_sds_phy_starting_substate_general_stop_handler,
 		.reset_handler		= scic_sds_phy_default_reset_handler,
 		.destruct_handler	= scic_sds_phy_default_destroy_handler,
@@ -1483,7 +1457,6 @@ static const struct scic_sds_phy_state_handler scic_sds_phy_state_handler_table[
 		.consume_power_handler	= scic_sds_phy_default_consume_power_handler
 	},
 	[SCIC_SDS_PHY_STARTING_SUBSTATE_AWAIT_IAF_UF] = {
-		.start_handler		= scic_sds_phy_default_start_handler,
 		.stop_handler		= scic_sds_phy_default_stop_handler,
 		.reset_handler		= scic_sds_phy_default_reset_handler,
 		.destruct_handler	= scic_sds_phy_default_destroy_handler,
@@ -1492,7 +1465,6 @@ static const struct scic_sds_phy_state_handler scic_sds_phy_state_handler_table[
 		.consume_power_handler	= scic_sds_phy_default_consume_power_handler
 	},
 	[SCIC_SDS_PHY_STARTING_SUBSTATE_AWAIT_SAS_POWER] = {
-		.start_handler		= scic_sds_phy_default_start_handler,
 		.stop_handler		= scic_sds_phy_starting_substate_general_stop_handler,
 		.reset_handler		= scic_sds_phy_default_reset_handler,
 		.destruct_handler	= scic_sds_phy_default_destroy_handler,
@@ -1501,7 +1473,6 @@ static const struct scic_sds_phy_state_handler scic_sds_phy_state_handler_table[
 		.consume_power_handler	= scic_sds_phy_starting_substate_await_sas_power_consume_power_handler
 	},
 	[SCIC_SDS_PHY_STARTING_SUBSTATE_AWAIT_SATA_POWER] = {
-		.start_handler		= scic_sds_phy_default_start_handler,
 		.stop_handler		= scic_sds_phy_starting_substate_general_stop_handler,
 		.reset_handler		= scic_sds_phy_default_reset_handler,
 		.destruct_handler	= scic_sds_phy_default_destroy_handler,
@@ -1510,7 +1481,6 @@ static const struct scic_sds_phy_state_handler scic_sds_phy_state_handler_table[
 		.consume_power_handler	= scic_sds_phy_starting_substate_await_sata_power_consume_power_handler
 	},
 	[SCIC_SDS_PHY_STARTING_SUBSTATE_AWAIT_SATA_PHY_EN] = {
-		.start_handler		= scic_sds_phy_default_start_handler,
 		.stop_handler		= scic_sds_phy_starting_substate_general_stop_handler,
 		.reset_handler		= scic_sds_phy_default_reset_handler,
 		.destruct_handler	= scic_sds_phy_default_destroy_handler,
@@ -1519,7 +1489,6 @@ static const struct scic_sds_phy_state_handler scic_sds_phy_state_handler_table[
 		.consume_power_handler	= scic_sds_phy_default_consume_power_handler
 	},
 	[SCIC_SDS_PHY_STARTING_SUBSTATE_AWAIT_SATA_SPEED_EN] = {
-		.start_handler		= scic_sds_phy_default_start_handler,
 		.stop_handler		= scic_sds_phy_starting_substate_general_stop_handler,
 		.reset_handler		= scic_sds_phy_default_reset_handler,
 		.destruct_handler	= scic_sds_phy_default_destroy_handler,
@@ -1528,7 +1497,6 @@ static const struct scic_sds_phy_state_handler scic_sds_phy_state_handler_table[
 		.consume_power_handler	= scic_sds_phy_default_consume_power_handler
 	},
 	[SCIC_SDS_PHY_STARTING_SUBSTATE_AWAIT_SIG_FIS_UF] = {
-		.start_handler		= scic_sds_phy_default_start_handler,
 		.stop_handler		= scic_sds_phy_starting_substate_general_stop_handler,
 		.reset_handler		= scic_sds_phy_default_reset_handler,
 		.destruct_handler	= scic_sds_phy_default_destroy_handler,
@@ -1537,7 +1505,6 @@ static const struct scic_sds_phy_state_handler scic_sds_phy_state_handler_table[
 		.consume_power_handler	= scic_sds_phy_default_consume_power_handler
 	},
 	[SCIC_SDS_PHY_STARTING_SUBSTATE_FINAL] = {
-		.start_handler		= scic_sds_phy_default_start_handler,
 		.stop_handler		= scic_sds_phy_starting_substate_general_stop_handler,
 		.reset_handler		= scic_sds_phy_default_reset_handler,
 		.destruct_handler	= scic_sds_phy_default_destroy_handler,
@@ -1546,7 +1513,6 @@ static const struct scic_sds_phy_state_handler scic_sds_phy_state_handler_table[
 		.consume_power_handler	 = scic_sds_phy_default_consume_power_handler
 	},
 	[SCI_BASE_PHY_STATE_READY] = {
-		.start_handler = scic_sds_phy_default_start_handler,
 		.stop_handler  = scic_sds_phy_ready_state_stop_handler,
 		.reset_handler = scic_sds_phy_ready_state_reset_handler,
 		.destruct_handler = scic_sds_phy_default_destroy_handler,
@@ -1555,7 +1521,6 @@ static const struct scic_sds_phy_state_handler scic_sds_phy_state_handler_table[
 		.consume_power_handler	 = scic_sds_phy_default_consume_power_handler
 	},
 	[SCI_BASE_PHY_STATE_RESETTING] = {
-		.start_handler = scic_sds_phy_default_start_handler,
 		.stop_handler  = scic_sds_phy_default_stop_handler,
 		.reset_handler = scic_sds_phy_default_reset_handler,
 		.destruct_handler = scic_sds_phy_default_destroy_handler,
@@ -1564,7 +1529,6 @@ static const struct scic_sds_phy_state_handler scic_sds_phy_state_handler_table[
 		.consume_power_handler	 = scic_sds_phy_default_consume_power_handler
 	},
 	[SCI_BASE_PHY_STATE_FINAL] = {
-		.start_handler = scic_sds_phy_default_start_handler,
 		.stop_handler  = scic_sds_phy_default_stop_handler,
 		.reset_handler = scic_sds_phy_default_reset_handler,
 		.destruct_handler = scic_sds_phy_default_destroy_handler,

commit 4a33c525f0e94b57602abd1e43644cbf6f5418f4
Author: Adam Gruchala <adam.gruchala@intel.com>
Date:   Tue May 10 23:54:23 2011 +0000

    isci: merge phy substates
    
    Merged states and substates into one state machine, as we always
    unconditionally transitioned to the substate machine it was straightforward to
    enter that substate from the starting state.
    
    Reported-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Adam Gruchala <adam.gruchala@intel.com>
    [fixed construction, starting_state_enter, and starting check]
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/drivers/scsi/isci/phy.c b/drivers/scsi/isci/phy.c
index 0f64605200ff..e5ae676926f2 100644
--- a/drivers/scsi/isci/phy.c
+++ b/drivers/scsi/isci/phy.c
@@ -271,8 +271,6 @@ static void scic_sds_phy_sata_timeout(void *phy)
 		 __func__,
 		 sci_phy);
 
-	sci_base_state_machine_stop(&sci_phy->starting_substate_machine);
-
 	sci_base_state_machine_change_state(&sci_phy->state_machine,
 					    SCI_BASE_PHY_STATE_STARTING);
 }
@@ -546,7 +544,7 @@ static void scic_sds_phy_start_sas_link_training(
 		&sci_phy->link_layer_registers->phy_configuration);
 
 	sci_base_state_machine_change_state(
-		&sci_phy->starting_substate_machine,
+		&sci_phy->state_machine,
 		SCIC_SDS_PHY_STARTING_SUBSTATE_AWAIT_SAS_SPEED_EN
 		);
 
@@ -565,7 +563,7 @@ static void scic_sds_phy_start_sata_link_training(
 	struct scic_sds_phy *sci_phy)
 {
 	sci_base_state_machine_change_state(
-		&sci_phy->starting_substate_machine,
+		&sci_phy->state_machine,
 		SCIC_SDS_PHY_STARTING_SUBSTATE_AWAIT_SATA_POWER
 		);
 
@@ -590,16 +588,13 @@ static void scic_sds_phy_complete_link_training(
 {
 	sci_phy->max_negotiated_speed = max_link_rate;
 
-	sci_base_state_machine_change_state(&sci_phy->starting_substate_machine,
+	sci_base_state_machine_change_state(&sci_phy->state_machine,
 					    next_state);
 }
 
 static void scic_sds_phy_restart_starting_state(
 	struct scic_sds_phy *sci_phy)
 {
-	/* Stop the current substate machine */
-	sci_base_state_machine_stop(&sci_phy->starting_substate_machine);
-
 	/* Re-enter the base state machine starting state */
 	sci_base_state_machine_change_state(&sci_phy->state_machine,
 					    SCI_BASE_PHY_STATE_STARTING);
@@ -611,8 +606,6 @@ static void scic_sds_phy_restart_starting_state(
 static enum sci_status scic_sds_phy_starting_substate_general_stop_handler(
 	struct scic_sds_phy *phy)
 {
-	sci_base_state_machine_stop(&phy->starting_substate_machine);
-
 	sci_base_state_machine_change_state(&phy->state_machine,
 						 SCI_BASE_PHY_STATE_STOPPED);
 
@@ -919,7 +912,7 @@ static enum sci_status scic_sds_phy_starting_substate_await_sata_phy_event_handl
 		sci_phy->protocol = SCIC_SDS_PHY_PROTOCOL_SATA;
 
 		/* We have received the SATA PHY notification change state */
-		sci_base_state_machine_change_state(&sci_phy->starting_substate_machine,
+		sci_base_state_machine_change_state(&sci_phy->state_machine,
 						    SCIC_SDS_PHY_STARTING_SUBSTATE_AWAIT_SATA_SPEED_EN);
 		break;
 
@@ -1042,7 +1035,7 @@ static enum sci_status scic_sds_phy_starting_substate_await_sig_fis_event_handle
 	switch (scu_get_event_code(event_code)) {
 	case SCU_EVENT_SATA_PHY_DETECTED:
 		/* Backup the state machine */
-		sci_base_state_machine_change_state(&sci_phy->starting_substate_machine,
+		sci_base_state_machine_change_state(&sci_phy->state_machine,
 						    SCIC_SDS_PHY_STARTING_SUBSTATE_AWAIT_SATA_SPEED_EN);
 		break;
 
@@ -1118,7 +1111,7 @@ static enum sci_status scic_sds_phy_starting_substate_await_iaf_uf_frame_handler
 			state = SCIC_SDS_PHY_STARTING_SUBSTATE_AWAIT_SAS_POWER;
 		}
 		sci_base_state_machine_change_state(
-				&sci_phy->starting_substate_machine,
+				&sci_phy->state_machine,
 				state);
 		result = SCI_SUCCESS;
 	} else
@@ -1177,7 +1170,7 @@ static enum sci_status scic_sds_phy_starting_substate_await_sig_fis_frame_handle
 						       fis_frame_data);
 
 		/* got IAF we can now go to the await spinup semaphore state */
-		sci_base_state_machine_change_state(&sci_phy->starting_substate_machine,
+		sci_base_state_machine_change_state(&sci_phy->state_machine,
 						    SCIC_SDS_PHY_STARTING_SUBSTATE_FINAL);
 
 		result = SCI_SUCCESS;
@@ -1216,7 +1209,7 @@ static enum sci_status scic_sds_phy_starting_substate_await_sas_power_consume_po
 	writel(enable_spinup, &sci_phy->link_layer_registers->notify_enable_spinup_control);
 
 	/* Change state to the final state this substate machine has run to completion */
-	sci_base_state_machine_change_state(&sci_phy->starting_substate_machine,
+	sci_base_state_machine_change_state(&sci_phy->state_machine,
 					    SCIC_SDS_PHY_STARTING_SUBSTATE_FINAL);
 
 	return SCI_SUCCESS;
@@ -1248,7 +1241,7 @@ static enum sci_status scic_sds_phy_starting_substate_await_sata_power_consume_p
 		&sci_phy->link_layer_registers->phy_configuration);
 
 	/* Change state to the final state this substate machine has run to completion */
-	sci_base_state_machine_change_state(&sci_phy->starting_substate_machine,
+	sci_base_state_machine_change_state(&sci_phy->state_machine,
 					    SCIC_SDS_PHY_STARTING_SUBSTATE_AWAIT_SATA_PHY_EN);
 
 	return SCI_SUCCESS;
@@ -1312,9 +1305,156 @@ scic_sds_phy_default_consume_power_handler(struct scic_sds_phy *sci_phy)
 	return default_phy_handler(sci_phy, __func__);
 }
 
+/*
+ * This method takes the struct scic_sds_phy from a stopped state and
+ * attempts to start it. - The phy state machine is transitioned to the
+ * SCI_BASE_PHY_STATE_STARTING. enum sci_status SCI_SUCCESS
+ */
+static enum sci_status
+scic_sds_phy_stopped_state_start_handler(struct scic_sds_phy *sci_phy)
+{
+	struct isci_host *ihost;
+	struct scic_sds_controller *scic;
+
+	scic = scic_sds_phy_get_controller(sci_phy),
+	ihost = scic_to_ihost(scic);
 
+	/* Create the SIGNATURE FIS Timeout timer for this phy */
+	sci_phy->sata_timeout_timer = isci_timer_create(ihost, sci_phy,
+							scic_sds_phy_sata_timeout);
+
+	if (sci_phy->sata_timeout_timer)
+		sci_base_state_machine_change_state(&sci_phy->state_machine,
+						    SCI_BASE_PHY_STATE_STARTING);
+
+	return SCI_SUCCESS;
+}
+
+static enum sci_status
+scic_sds_phy_stopped_state_destroy_handler(struct scic_sds_phy *sci_phy)
+{
+	return SCI_SUCCESS;
+}
+
+static enum sci_status
+scic_sds_phy_ready_state_stop_handler(struct scic_sds_phy *sci_phy)
+{
+	sci_base_state_machine_change_state(&sci_phy->state_machine,
+					    SCI_BASE_PHY_STATE_STOPPED);
+
+	return SCI_SUCCESS;
+}
+
+static enum sci_status
+scic_sds_phy_ready_state_reset_handler(struct scic_sds_phy *sci_phy)
+{
+	sci_base_state_machine_change_state(&sci_phy->state_machine,
+					    SCI_BASE_PHY_STATE_RESETTING);
+
+	return SCI_SUCCESS;
+}
 
-static const struct scic_sds_phy_state_handler scic_sds_phy_starting_substate_handler_table[] = {
+/**
+ * scic_sds_phy_ready_state_event_handler -
+ * @phy: This is the struct scic_sds_phy object which has received the event.
+ *
+ * This method request the struct scic_sds_phy handle the received event.  The only
+ * event that we are interested in while in the ready state is the link failure
+ * event. - decoded event is a link failure - transition the struct scic_sds_phy back
+ * to the SCI_BASE_PHY_STATE_STARTING state. - any other event received will
+ * report a warning message enum sci_status SCI_SUCCESS if the event received is a
+ * link failure SCI_FAILURE_INVALID_STATE for any other event received.
+ */
+static enum sci_status scic_sds_phy_ready_state_event_handler(struct scic_sds_phy *sci_phy,
+							      u32 event_code)
+{
+	enum sci_status result = SCI_FAILURE;
+
+	switch (scu_get_event_code(event_code)) {
+	case SCU_EVENT_LINK_FAILURE:
+		/* Link failure change state back to the starting state */
+		sci_base_state_machine_change_state(&sci_phy->state_machine,
+						    SCI_BASE_PHY_STATE_STARTING);
+		result = SCI_SUCCESS;
+		break;
+
+	case SCU_EVENT_BROADCAST_CHANGE:
+		/* Broadcast change received. Notify the port. */
+		if (scic_sds_phy_get_port(sci_phy) != NULL)
+			scic_sds_port_broadcast_change_received(sci_phy->owning_port, sci_phy);
+		else
+			sci_phy->bcn_received_while_port_unassigned = true;
+		break;
+
+	default:
+		dev_warn(sciphy_to_dev(sci_phy),
+			 "%sP SCIC PHY 0x%p ready state machine received "
+			 "unexpected event_code %x\n",
+			 __func__, sci_phy, event_code);
+
+		result = SCI_FAILURE_INVALID_STATE;
+		break;
+	}
+
+	return result;
+}
+
+static enum sci_status scic_sds_phy_resetting_state_event_handler(struct scic_sds_phy *sci_phy,
+								  u32 event_code)
+{
+	enum sci_status result = SCI_FAILURE;
+
+	switch (scu_get_event_code(event_code)) {
+	case SCU_EVENT_HARD_RESET_TRANSMITTED:
+		/* Link failure change state back to the starting state */
+		sci_base_state_machine_change_state(&sci_phy->state_machine,
+						    SCI_BASE_PHY_STATE_STARTING);
+		result = SCI_SUCCESS;
+		break;
+
+	default:
+		dev_warn(sciphy_to_dev(sci_phy),
+			 "%s: SCIC PHY 0x%p resetting state machine received "
+			 "unexpected event_code %x\n",
+			 __func__, sci_phy, event_code);
+
+		result = SCI_FAILURE_INVALID_STATE;
+		break;
+	}
+
+	return result;
+}
+
+/* --------------------------------------------------------------------------- */
+
+static const struct scic_sds_phy_state_handler scic_sds_phy_state_handler_table[] = {
+	[SCI_BASE_PHY_STATE_INITIAL] = {
+		.start_handler = scic_sds_phy_default_start_handler,
+		.stop_handler  = scic_sds_phy_default_stop_handler,
+		.reset_handler = scic_sds_phy_default_reset_handler,
+		.destruct_handler = scic_sds_phy_default_destroy_handler,
+		.frame_handler		 = scic_sds_phy_default_frame_handler,
+		.event_handler		 = scic_sds_phy_default_event_handler,
+		.consume_power_handler	 = scic_sds_phy_default_consume_power_handler
+	},
+	[SCI_BASE_PHY_STATE_STOPPED]  = {
+		.start_handler = scic_sds_phy_stopped_state_start_handler,
+		.stop_handler  = scic_sds_phy_default_stop_handler,
+		.reset_handler = scic_sds_phy_default_reset_handler,
+		.destruct_handler = scic_sds_phy_stopped_state_destroy_handler,
+		.frame_handler		 = scic_sds_phy_default_frame_handler,
+		.event_handler		 = scic_sds_phy_default_event_handler,
+		.consume_power_handler	 = scic_sds_phy_default_consume_power_handler
+	},
+	[SCI_BASE_PHY_STATE_STARTING] = {
+		.start_handler = scic_sds_phy_default_start_handler,
+		.stop_handler  = scic_sds_phy_default_stop_handler,
+		.reset_handler = scic_sds_phy_default_reset_handler,
+		.destruct_handler = scic_sds_phy_default_destroy_handler,
+		.frame_handler		 = scic_sds_phy_default_frame_handler,
+		.event_handler		 = scic_sds_phy_default_event_handler,
+		.consume_power_handler	 = scic_sds_phy_default_consume_power_handler
+	},
 	[SCIC_SDS_PHY_STARTING_SUBSTATE_INITIAL] = {
 		.start_handler		= scic_sds_phy_default_start_handler,
 		.stop_handler		= scic_sds_phy_starting_substate_general_stop_handler,
@@ -1404,20 +1544,36 @@ static const struct scic_sds_phy_state_handler scic_sds_phy_starting_substate_ha
 		.frame_handler		 = scic_sds_phy_default_frame_handler,
 		.event_handler		 = scic_sds_phy_default_event_handler,
 		.consume_power_handler	 = scic_sds_phy_default_consume_power_handler
+	},
+	[SCI_BASE_PHY_STATE_READY] = {
+		.start_handler = scic_sds_phy_default_start_handler,
+		.stop_handler  = scic_sds_phy_ready_state_stop_handler,
+		.reset_handler = scic_sds_phy_ready_state_reset_handler,
+		.destruct_handler = scic_sds_phy_default_destroy_handler,
+		.frame_handler		 = scic_sds_phy_default_frame_handler,
+		.event_handler		 = scic_sds_phy_ready_state_event_handler,
+		.consume_power_handler	 = scic_sds_phy_default_consume_power_handler
+	},
+	[SCI_BASE_PHY_STATE_RESETTING] = {
+		.start_handler = scic_sds_phy_default_start_handler,
+		.stop_handler  = scic_sds_phy_default_stop_handler,
+		.reset_handler = scic_sds_phy_default_reset_handler,
+		.destruct_handler = scic_sds_phy_default_destroy_handler,
+		.frame_handler		 = scic_sds_phy_default_frame_handler,
+		.event_handler		 = scic_sds_phy_resetting_state_event_handler,
+		.consume_power_handler	 = scic_sds_phy_default_consume_power_handler
+	},
+	[SCI_BASE_PHY_STATE_FINAL] = {
+		.start_handler = scic_sds_phy_default_start_handler,
+		.stop_handler  = scic_sds_phy_default_stop_handler,
+		.reset_handler = scic_sds_phy_default_reset_handler,
+		.destruct_handler = scic_sds_phy_default_destroy_handler,
+		.frame_handler		 = scic_sds_phy_default_frame_handler,
+		.event_handler		 = scic_sds_phy_default_event_handler,
+		.consume_power_handler	 = scic_sds_phy_default_consume_power_handler
 	}
 };
 
-/**
- * scic_sds_phy_set_starting_substate_handlers() -
- *
- * This macro sets the starting substate handlers by state_id
- */
-#define scic_sds_phy_set_starting_substate_handlers(phy, state_id) \
-	scic_sds_phy_set_state_handlers(\
-		(phy), \
-		&scic_sds_phy_starting_substate_handler_table[(state_id)] \
-		)
-
 /*
  * ****************************************************************************
  * *  PHY STARTING SUBSTATE METHODS
@@ -1436,11 +1592,11 @@ static void scic_sds_phy_starting_initial_substate_enter(void *object)
 {
 	struct scic_sds_phy *sci_phy = object;
 
-	scic_sds_phy_set_starting_substate_handlers(
+	scic_sds_phy_set_base_state_handlers(
 		sci_phy, SCIC_SDS_PHY_STARTING_SUBSTATE_INITIAL);
 
 	/* This is just an temporary state go off to the starting state */
-	sci_base_state_machine_change_state(&sci_phy->starting_substate_machine,
+	sci_base_state_machine_change_state(&sci_phy->state_machine,
 					    SCIC_SDS_PHY_STARTING_SUBSTATE_AWAIT_OSSP_EN);
 }
 
@@ -1456,7 +1612,7 @@ static void scic_sds_phy_starting_await_ossp_en_substate_enter(void *object)
 {
 	struct scic_sds_phy *sci_phy = object;
 
-	scic_sds_phy_set_starting_substate_handlers(
+	scic_sds_phy_set_base_state_handlers(
 		sci_phy, SCIC_SDS_PHY_STARTING_SUBSTATE_AWAIT_OSSP_EN
 		);
 }
@@ -1474,7 +1630,7 @@ static void scic_sds_phy_starting_await_sas_speed_en_substate_enter(
 {
 	struct scic_sds_phy *sci_phy = object;
 
-	scic_sds_phy_set_starting_substate_handlers(
+	scic_sds_phy_set_base_state_handlers(
 		sci_phy, SCIC_SDS_PHY_STARTING_SUBSTATE_AWAIT_SAS_SPEED_EN
 		);
 }
@@ -1491,7 +1647,7 @@ static void scic_sds_phy_starting_await_iaf_uf_substate_enter(void *object)
 {
 	struct scic_sds_phy *sci_phy = object;
 
-	scic_sds_phy_set_starting_substate_handlers(
+	scic_sds_phy_set_base_state_handlers(
 		sci_phy, SCIC_SDS_PHY_STARTING_SUBSTATE_AWAIT_IAF_UF
 		);
 }
@@ -1509,7 +1665,7 @@ static void scic_sds_phy_starting_await_sas_power_substate_enter(void *object)
 {
 	struct scic_sds_phy *sci_phy = object;
 
-	scic_sds_phy_set_starting_substate_handlers(
+	scic_sds_phy_set_base_state_handlers(
 		sci_phy, SCIC_SDS_PHY_STARTING_SUBSTATE_AWAIT_SAS_POWER
 		);
 
@@ -1549,7 +1705,7 @@ static void scic_sds_phy_starting_await_sata_power_substate_enter(void *object)
 {
 	struct scic_sds_phy *sci_phy = object;
 
-	scic_sds_phy_set_starting_substate_handlers(
+	scic_sds_phy_set_base_state_handlers(
 		sci_phy, SCIC_SDS_PHY_STARTING_SUBSTATE_AWAIT_SATA_POWER
 		);
 
@@ -1589,7 +1745,7 @@ static void scic_sds_phy_starting_await_sata_phy_substate_enter(void *object)
 {
 	struct scic_sds_phy *sci_phy = object;
 
-	scic_sds_phy_set_starting_substate_handlers(
+	scic_sds_phy_set_base_state_handlers(
 			sci_phy,
 			SCIC_SDS_PHY_STARTING_SUBSTATE_AWAIT_SATA_PHY_EN);
 
@@ -1626,7 +1782,7 @@ static void scic_sds_phy_starting_await_sata_speed_substate_enter(void *object)
 {
 	struct scic_sds_phy *sci_phy = object;
 
-	scic_sds_phy_set_starting_substate_handlers(
+	scic_sds_phy_set_base_state_handlers(
 			sci_phy,
 			SCIC_SDS_PHY_STARTING_SUBSTATE_AWAIT_SATA_SPEED_EN);
 
@@ -1666,7 +1822,7 @@ static void scic_sds_phy_starting_await_sig_fis_uf_substate_enter(void *object)
 	bool continue_to_ready_state;
 	struct scic_sds_phy *sci_phy = object;
 
-	scic_sds_phy_set_starting_substate_handlers(
+	scic_sds_phy_set_base_state_handlers(
 			sci_phy,
 			SCIC_SDS_PHY_STARTING_SUBSTATE_AWAIT_SIG_FIS_UF);
 
@@ -1719,7 +1875,7 @@ static void scic_sds_phy_starting_final_substate_enter(void *object)
 {
 	struct scic_sds_phy *sci_phy = object;
 
-	scic_sds_phy_set_starting_substate_handlers(sci_phy,
+	scic_sds_phy_set_base_state_handlers(sci_phy,
 						    SCIC_SDS_PHY_STARTING_SUBSTATE_FINAL);
 
 	/* State machine has run to completion so exit out and change
@@ -1729,225 +1885,6 @@ static void scic_sds_phy_starting_final_substate_enter(void *object)
 					    SCI_BASE_PHY_STATE_READY);
 }
 
-/* --------------------------------------------------------------------------- */
-
-static const struct sci_base_state scic_sds_phy_starting_substates[] = {
-	[SCIC_SDS_PHY_STARTING_SUBSTATE_INITIAL] = {
-		.enter_state = scic_sds_phy_starting_initial_substate_enter,
-	},
-	[SCIC_SDS_PHY_STARTING_SUBSTATE_AWAIT_OSSP_EN] = {
-		.enter_state = scic_sds_phy_starting_await_ossp_en_substate_enter,
-	},
-	[SCIC_SDS_PHY_STARTING_SUBSTATE_AWAIT_SAS_SPEED_EN] = {
-		.enter_state = scic_sds_phy_starting_await_sas_speed_en_substate_enter,
-	},
-	[SCIC_SDS_PHY_STARTING_SUBSTATE_AWAIT_IAF_UF] = {
-		.enter_state = scic_sds_phy_starting_await_iaf_uf_substate_enter,
-	},
-	[SCIC_SDS_PHY_STARTING_SUBSTATE_AWAIT_SAS_POWER] = {
-		.enter_state = scic_sds_phy_starting_await_sas_power_substate_enter,
-		.exit_state  = scic_sds_phy_starting_await_sas_power_substate_exit,
-	},
-	[SCIC_SDS_PHY_STARTING_SUBSTATE_AWAIT_SATA_POWER] = {
-		.enter_state = scic_sds_phy_starting_await_sata_power_substate_enter,
-		.exit_state  = scic_sds_phy_starting_await_sata_power_substate_exit
-	},
-	[SCIC_SDS_PHY_STARTING_SUBSTATE_AWAIT_SATA_PHY_EN] = {
-		.enter_state = scic_sds_phy_starting_await_sata_phy_substate_enter,
-		.exit_state  = scic_sds_phy_starting_await_sata_phy_substate_exit
-	},
-	[SCIC_SDS_PHY_STARTING_SUBSTATE_AWAIT_SATA_SPEED_EN] = {
-		.enter_state = scic_sds_phy_starting_await_sata_speed_substate_enter,
-		.exit_state  = scic_sds_phy_starting_await_sata_speed_substate_exit
-	},
-	[SCIC_SDS_PHY_STARTING_SUBSTATE_AWAIT_SIG_FIS_UF] = {
-		.enter_state = scic_sds_phy_starting_await_sig_fis_uf_substate_enter,
-		.exit_state  = scic_sds_phy_starting_await_sig_fis_uf_substate_exit
-	},
-	[SCIC_SDS_PHY_STARTING_SUBSTATE_FINAL] = {
-		.enter_state = scic_sds_phy_starting_final_substate_enter,
-	}
-};
-
-/*
- * This method takes the struct scic_sds_phy from a stopped state and
- * attempts to start it. - The phy state machine is transitioned to the
- * SCI_BASE_PHY_STATE_STARTING. enum sci_status SCI_SUCCESS
- */
-static enum sci_status
-scic_sds_phy_stopped_state_start_handler(struct scic_sds_phy *sci_phy)
-{
-	struct isci_host *ihost;
-	struct scic_sds_controller *scic;
-
-	scic = scic_sds_phy_get_controller(sci_phy),
-	ihost = scic_to_ihost(scic);
-
-	/* Create the SIGNATURE FIS Timeout timer for this phy */
-	sci_phy->sata_timeout_timer = isci_timer_create(ihost, sci_phy,
-							scic_sds_phy_sata_timeout);
-
-	if (sci_phy->sata_timeout_timer)
-		sci_base_state_machine_change_state(&sci_phy->state_machine,
-						    SCI_BASE_PHY_STATE_STARTING);
-
-	return SCI_SUCCESS;
-}
-
-static enum sci_status
-scic_sds_phy_stopped_state_destroy_handler(struct scic_sds_phy *sci_phy)
-{
-	return SCI_SUCCESS;
-}
-
-static enum sci_status
-scic_sds_phy_ready_state_stop_handler(struct scic_sds_phy *sci_phy)
-{
-	sci_base_state_machine_change_state(&sci_phy->state_machine,
-					    SCI_BASE_PHY_STATE_STOPPED);
-
-	return SCI_SUCCESS;
-}
-
-static enum sci_status
-scic_sds_phy_ready_state_reset_handler(struct scic_sds_phy *sci_phy)
-{
-	sci_base_state_machine_change_state(&sci_phy->state_machine,
-					    SCI_BASE_PHY_STATE_RESETTING);
-
-	return SCI_SUCCESS;
-}
-
-/**
- * scic_sds_phy_ready_state_event_handler -
- * @phy: This is the struct scic_sds_phy object which has received the event.
- *
- * This method request the struct scic_sds_phy handle the received event.  The only
- * event that we are interested in while in the ready state is the link failure
- * event. - decoded event is a link failure - transition the struct scic_sds_phy back
- * to the SCI_BASE_PHY_STATE_STARTING state. - any other event received will
- * report a warning message enum sci_status SCI_SUCCESS if the event received is a
- * link failure SCI_FAILURE_INVALID_STATE for any other event received.
- */
-static enum sci_status scic_sds_phy_ready_state_event_handler(struct scic_sds_phy *sci_phy,
-							      u32 event_code)
-{
-	enum sci_status result = SCI_FAILURE;
-
-	switch (scu_get_event_code(event_code)) {
-	case SCU_EVENT_LINK_FAILURE:
-		/* Link failure change state back to the starting state */
-		sci_base_state_machine_change_state(&sci_phy->state_machine,
-						    SCI_BASE_PHY_STATE_STARTING);
-		result = SCI_SUCCESS;
-		break;
-
-	case SCU_EVENT_BROADCAST_CHANGE:
-		/* Broadcast change received. Notify the port. */
-		if (scic_sds_phy_get_port(sci_phy) != NULL)
-			scic_sds_port_broadcast_change_received(sci_phy->owning_port, sci_phy);
-		else
-			sci_phy->bcn_received_while_port_unassigned = true;
-		break;
-
-	default:
-		dev_warn(sciphy_to_dev(sci_phy),
-			 "%sP SCIC PHY 0x%p ready state machine received "
-			 "unexpected event_code %x\n",
-			 __func__, sci_phy, event_code);
-
-		result = SCI_FAILURE_INVALID_STATE;
-		break;
-	}
-
-	return result;
-}
-
-static enum sci_status scic_sds_phy_resetting_state_event_handler(struct scic_sds_phy *sci_phy,
-								  u32 event_code)
-{
-	enum sci_status result = SCI_FAILURE;
-
-	switch (scu_get_event_code(event_code)) {
-	case SCU_EVENT_HARD_RESET_TRANSMITTED:
-		/* Link failure change state back to the starting state */
-		sci_base_state_machine_change_state(&sci_phy->state_machine,
-						    SCI_BASE_PHY_STATE_STARTING);
-		result = SCI_SUCCESS;
-		break;
-
-	default:
-		dev_warn(sciphy_to_dev(sci_phy),
-			 "%s: SCIC PHY 0x%p resetting state machine received "
-			 "unexpected event_code %x\n",
-			 __func__, sci_phy, event_code);
-
-		result = SCI_FAILURE_INVALID_STATE;
-		break;
-	}
-
-	return result;
-}
-
-/* --------------------------------------------------------------------------- */
-
-static const struct scic_sds_phy_state_handler scic_sds_phy_state_handler_table[] = {
-	[SCI_BASE_PHY_STATE_INITIAL] = {
-		.start_handler = scic_sds_phy_default_start_handler,
-		.stop_handler  = scic_sds_phy_default_stop_handler,
-		.reset_handler = scic_sds_phy_default_reset_handler,
-		.destruct_handler = scic_sds_phy_default_destroy_handler,
-		.frame_handler		 = scic_sds_phy_default_frame_handler,
-		.event_handler		 = scic_sds_phy_default_event_handler,
-		.consume_power_handler	 = scic_sds_phy_default_consume_power_handler
-	},
-	[SCI_BASE_PHY_STATE_STOPPED]  = {
-		.start_handler = scic_sds_phy_stopped_state_start_handler,
-		.stop_handler  = scic_sds_phy_default_stop_handler,
-		.reset_handler = scic_sds_phy_default_reset_handler,
-		.destruct_handler = scic_sds_phy_stopped_state_destroy_handler,
-		.frame_handler		 = scic_sds_phy_default_frame_handler,
-		.event_handler		 = scic_sds_phy_default_event_handler,
-		.consume_power_handler	 = scic_sds_phy_default_consume_power_handler
-	},
-	[SCI_BASE_PHY_STATE_STARTING] = {
-		.start_handler = scic_sds_phy_default_start_handler,
-		.stop_handler  = scic_sds_phy_default_stop_handler,
-		.reset_handler = scic_sds_phy_default_reset_handler,
-		.destruct_handler = scic_sds_phy_default_destroy_handler,
-		.frame_handler		 = scic_sds_phy_default_frame_handler,
-		.event_handler		 = scic_sds_phy_default_event_handler,
-		.consume_power_handler	 = scic_sds_phy_default_consume_power_handler
-	},
-	[SCI_BASE_PHY_STATE_READY] = {
-		.start_handler = scic_sds_phy_default_start_handler,
-		.stop_handler  = scic_sds_phy_ready_state_stop_handler,
-		.reset_handler = scic_sds_phy_ready_state_reset_handler,
-		.destruct_handler = scic_sds_phy_default_destroy_handler,
-		.frame_handler		 = scic_sds_phy_default_frame_handler,
-		.event_handler		 = scic_sds_phy_ready_state_event_handler,
-		.consume_power_handler	 = scic_sds_phy_default_consume_power_handler
-	},
-	[SCI_BASE_PHY_STATE_RESETTING] = {
-		.start_handler = scic_sds_phy_default_start_handler,
-		.stop_handler  = scic_sds_phy_default_stop_handler,
-		.reset_handler = scic_sds_phy_default_reset_handler,
-		.destruct_handler = scic_sds_phy_default_destroy_handler,
-		.frame_handler		 = scic_sds_phy_default_frame_handler,
-		.event_handler		 = scic_sds_phy_resetting_state_event_handler,
-		.consume_power_handler	 = scic_sds_phy_default_consume_power_handler
-	},
-	[SCI_BASE_PHY_STATE_FINAL] = {
-		.start_handler = scic_sds_phy_default_start_handler,
-		.stop_handler  = scic_sds_phy_default_stop_handler,
-		.reset_handler = scic_sds_phy_default_reset_handler,
-		.destruct_handler = scic_sds_phy_default_destroy_handler,
-		.frame_handler		 = scic_sds_phy_default_frame_handler,
-		.event_handler		 = scic_sds_phy_default_event_handler,
-		.consume_power_handler	 = scic_sds_phy_default_consume_power_handler
-	}
-};
-
 /*
  * ****************************************************************************
  * *  PHY STATE PRIVATE METHODS
@@ -2118,9 +2055,6 @@ static void scic_sds_phy_starting_state_enter(void *object)
 	sci_phy->protocol = SCIC_SDS_PHY_PROTOCOL_UNKNOWN;
 	sci_phy->bcn_received_while_port_unassigned = false;
 
-	/* Change over to the starting substate machine to continue */
-	sci_base_state_machine_start(&sci_phy->starting_substate_machine);
-
 	if (sci_phy->state_machine.previous_state_id
 	    == SCI_BASE_PHY_STATE_READY) {
 		scic_sds_controller_link_down(
@@ -2129,6 +2063,9 @@ static void scic_sds_phy_starting_state_enter(void *object)
 			sci_phy
 			);
 	}
+
+	sci_base_state_machine_change_state(&sci_phy->state_machine,
+					    SCIC_SDS_PHY_STARTING_SUBSTATE_INITIAL);
 }
 
 /**
@@ -2231,6 +2168,41 @@ static const struct sci_base_state scic_sds_phy_state_table[] = {
 	[SCI_BASE_PHY_STATE_STARTING] = {
 		.enter_state = scic_sds_phy_starting_state_enter,
 	},
+	[SCIC_SDS_PHY_STARTING_SUBSTATE_INITIAL] = {
+		.enter_state = scic_sds_phy_starting_initial_substate_enter,
+	},
+	[SCIC_SDS_PHY_STARTING_SUBSTATE_AWAIT_OSSP_EN] = {
+		.enter_state = scic_sds_phy_starting_await_ossp_en_substate_enter,
+	},
+	[SCIC_SDS_PHY_STARTING_SUBSTATE_AWAIT_SAS_SPEED_EN] = {
+		.enter_state = scic_sds_phy_starting_await_sas_speed_en_substate_enter,
+	},
+	[SCIC_SDS_PHY_STARTING_SUBSTATE_AWAIT_IAF_UF] = {
+		.enter_state = scic_sds_phy_starting_await_iaf_uf_substate_enter,
+	},
+	[SCIC_SDS_PHY_STARTING_SUBSTATE_AWAIT_SAS_POWER] = {
+		.enter_state = scic_sds_phy_starting_await_sas_power_substate_enter,
+		.exit_state  = scic_sds_phy_starting_await_sas_power_substate_exit,
+	},
+	[SCIC_SDS_PHY_STARTING_SUBSTATE_AWAIT_SATA_POWER] = {
+		.enter_state = scic_sds_phy_starting_await_sata_power_substate_enter,
+		.exit_state  = scic_sds_phy_starting_await_sata_power_substate_exit
+	},
+	[SCIC_SDS_PHY_STARTING_SUBSTATE_AWAIT_SATA_PHY_EN] = {
+		.enter_state = scic_sds_phy_starting_await_sata_phy_substate_enter,
+		.exit_state  = scic_sds_phy_starting_await_sata_phy_substate_exit
+	},
+	[SCIC_SDS_PHY_STARTING_SUBSTATE_AWAIT_SATA_SPEED_EN] = {
+		.enter_state = scic_sds_phy_starting_await_sata_speed_substate_enter,
+		.exit_state  = scic_sds_phy_starting_await_sata_speed_substate_exit
+	},
+	[SCIC_SDS_PHY_STARTING_SUBSTATE_AWAIT_SIG_FIS_UF] = {
+		.enter_state = scic_sds_phy_starting_await_sig_fis_uf_substate_enter,
+		.exit_state  = scic_sds_phy_starting_await_sig_fis_uf_substate_exit
+	},
+	[SCIC_SDS_PHY_STARTING_SUBSTATE_FINAL] = {
+		.enter_state = scic_sds_phy_starting_final_substate_enter,
+	},
 	[SCI_BASE_PHY_STATE_READY] = {
 		.enter_state = scic_sds_phy_ready_state_enter,
 		.exit_state = scic_sds_phy_ready_state_exit,
@@ -2261,12 +2233,6 @@ void scic_sds_phy_construct(struct scic_sds_phy *sci_phy,
 	sci_phy->link_layer_registers = NULL;
 	sci_phy->max_negotiated_speed = SAS_LINK_RATE_UNKNOWN;
 	sci_phy->sata_timeout_timer = NULL;
-
-	/* Initialize the the substate machines */
-	sci_base_state_machine_construct(&sci_phy->starting_substate_machine,
-					 sci_phy,
-					 scic_sds_phy_starting_substates,
-					 SCIC_SDS_PHY_STARTING_SUBSTATE_INITIAL);
 }
 
 void isci_phy_init(struct isci_phy *iphy, struct isci_host *ihost, int index)

commit e2f8db509fdd354bb7a68c86515e9d2d8909ccc9
Author: Dan Williams <dan.j.williams@intel.com>
Date:   Tue May 10 02:28:46 2011 -0700

    isci: uplevel port infrastructure
    
    * Move port configuration agent implementation
    * Merge core/scic_sds_port.[ch] into port.[ch]
    
    Reported-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/drivers/scsi/isci/phy.c b/drivers/scsi/isci/phy.c
index b92d51f25481..0f64605200ff 100644
--- a/drivers/scsi/isci/phy.c
+++ b/drivers/scsi/isci/phy.c
@@ -57,9 +57,8 @@
 #include "host.h"
 #include "phy.h"
 #include "scu_event_codes.h"
-#include "scic_port.h"
-#include "scic_config_parameters.h"
 #include "timers.h"
+#include "probe_roms.h"
 
 /* Maximum arbitration wait time in micro-seconds */
 #define SCIC_SDS_PHY_MAX_ARBITRATION_WAIT_TIME  (700)

commit d35bc1bd18ab9e986cfb67c5a281a70cfd717f05
Author: Dan Williams <dan.j.williams@intel.com>
Date:   Tue May 10 02:28:45 2011 -0700

    isci: uplevel phy infrastructure
    
    Merge core/scic_sds_phy.[ch] into phy.[ch]
    
    Reported-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/drivers/scsi/isci/phy.c b/drivers/scsi/isci/phy.c
index 1134395c970e..b92d51f25481 100644
--- a/drivers/scsi/isci/phy.c
+++ b/drivers/scsi/isci/phy.c
@@ -56,12 +56,2219 @@
 #include "isci.h"
 #include "host.h"
 #include "phy.h"
+#include "scu_event_codes.h"
 #include "scic_port.h"
 #include "scic_config_parameters.h"
+#include "timers.h"
 
-struct scic_sds_phy;
-extern enum sci_status scic_sds_phy_start(struct scic_sds_phy *sci_phy);
-extern enum sci_status scic_sds_phy_stop(struct scic_sds_phy *sci_phy);
+/* Maximum arbitration wait time in micro-seconds */
+#define SCIC_SDS_PHY_MAX_ARBITRATION_WAIT_TIME  (700)
+
+enum sas_linkrate sci_phy_linkrate(struct scic_sds_phy *sci_phy)
+{
+	return sci_phy->max_negotiated_speed;
+}
+
+/*
+ * *****************************************************************************
+ * * SCIC SDS PHY Internal Methods
+ * ***************************************************************************** */
+
+/**
+ * This method will initialize the phy transport layer registers
+ * @sci_phy:
+ * @transport_layer_registers
+ *
+ * enum sci_status
+ */
+static enum sci_status scic_sds_phy_transport_layer_initialization(
+	struct scic_sds_phy *sci_phy,
+	struct scu_transport_layer_registers __iomem *transport_layer_registers)
+{
+	u32 tl_control;
+
+	sci_phy->transport_layer_registers = transport_layer_registers;
+
+	writel(SCIC_SDS_REMOTE_NODE_CONTEXT_INVALID_INDEX,
+		&sci_phy->transport_layer_registers->stp_rni);
+
+	/*
+	 * Hardware team recommends that we enable the STP prefetch for all
+	 * transports
+	 */
+	tl_control = readl(&sci_phy->transport_layer_registers->control);
+	tl_control |= SCU_TLCR_GEN_BIT(STP_WRITE_DATA_PREFETCH);
+	writel(tl_control, &sci_phy->transport_layer_registers->control);
+
+	return SCI_SUCCESS;
+}
+
+/**
+ * This method will initialize the phy link layer registers
+ * @sci_phy:
+ * @link_layer_registers:
+ *
+ * enum sci_status
+ */
+static enum sci_status
+scic_sds_phy_link_layer_initialization(struct scic_sds_phy *sci_phy,
+				       struct scu_link_layer_registers __iomem *link_layer_registers)
+{
+	struct scic_sds_controller *scic =
+		sci_phy->owning_port->owning_controller;
+	int phy_idx = sci_phy->phy_index;
+	struct sci_phy_user_params *phy_user =
+		&scic->user_parameters.sds1.phys[phy_idx];
+	struct sci_phy_oem_params *phy_oem =
+		&scic->oem_parameters.sds1.phys[phy_idx];
+	u32 phy_configuration;
+	struct scic_phy_cap phy_cap;
+	u32 parity_check = 0;
+	u32 parity_count = 0;
+	u32 llctl, link_rate;
+	u32 clksm_value = 0;
+
+	sci_phy->link_layer_registers = link_layer_registers;
+
+	/* Set our IDENTIFY frame data */
+	#define SCI_END_DEVICE 0x01
+
+	writel(SCU_SAS_TIID_GEN_BIT(SMP_INITIATOR) |
+	       SCU_SAS_TIID_GEN_BIT(SSP_INITIATOR) |
+	       SCU_SAS_TIID_GEN_BIT(STP_INITIATOR) |
+	       SCU_SAS_TIID_GEN_BIT(DA_SATA_HOST) |
+	       SCU_SAS_TIID_GEN_VAL(DEVICE_TYPE, SCI_END_DEVICE),
+	       &sci_phy->link_layer_registers->transmit_identification);
+
+	/* Write the device SAS Address */
+	writel(0xFEDCBA98,
+	       &sci_phy->link_layer_registers->sas_device_name_high);
+	writel(phy_idx, &sci_phy->link_layer_registers->sas_device_name_low);
+
+	/* Write the source SAS Address */
+	writel(phy_oem->sas_address.high,
+		&sci_phy->link_layer_registers->source_sas_address_high);
+	writel(phy_oem->sas_address.low,
+		&sci_phy->link_layer_registers->source_sas_address_low);
+
+	/* Clear and Set the PHY Identifier */
+	writel(0, &sci_phy->link_layer_registers->identify_frame_phy_id);
+	writel(SCU_SAS_TIPID_GEN_VALUE(ID, phy_idx),
+		&sci_phy->link_layer_registers->identify_frame_phy_id);
+
+	/* Change the initial state of the phy configuration register */
+	phy_configuration =
+		readl(&sci_phy->link_layer_registers->phy_configuration);
+
+	/* Hold OOB state machine in reset */
+	phy_configuration |=  SCU_SAS_PCFG_GEN_BIT(OOB_RESET);
+	writel(phy_configuration,
+		&sci_phy->link_layer_registers->phy_configuration);
+
+	/* Configure the SNW capabilities */
+	phy_cap.all = 0;
+	phy_cap.start = 1;
+	phy_cap.gen3_no_ssc = 1;
+	phy_cap.gen2_no_ssc = 1;
+	phy_cap.gen1_no_ssc = 1;
+	if (scic->oem_parameters.sds1.controller.do_enable_ssc == true) {
+		phy_cap.gen3_ssc = 1;
+		phy_cap.gen2_ssc = 1;
+		phy_cap.gen1_ssc = 1;
+	}
+
+	/*
+	 * The SAS specification indicates that the phy_capabilities that
+	 * are transmitted shall have an even parity.  Calculate the parity. */
+	parity_check = phy_cap.all;
+	while (parity_check != 0) {
+		if (parity_check & 0x1)
+			parity_count++;
+		parity_check >>= 1;
+	}
+
+	/*
+	 * If parity indicates there are an odd number of bits set, then
+	 * set the parity bit to 1 in the phy capabilities. */
+	if ((parity_count % 2) != 0)
+		phy_cap.parity = 1;
+
+	writel(phy_cap.all, &sci_phy->link_layer_registers->phy_capabilities);
+
+	/* Set the enable spinup period but disable the ability to send
+	 * notify enable spinup
+	 */
+	writel(SCU_ENSPINUP_GEN_VAL(COUNT,
+			phy_user->notify_enable_spin_up_insertion_frequency),
+		&sci_phy->link_layer_registers->notify_enable_spinup_control);
+
+	/* Write the ALIGN Insertion Ferequency for connected phy and
+	 * inpendent of connected state
+	 */
+	clksm_value = SCU_ALIGN_INSERTION_FREQUENCY_GEN_VAL(CONNECTED,
+			phy_user->in_connection_align_insertion_frequency);
+
+	clksm_value |= SCU_ALIGN_INSERTION_FREQUENCY_GEN_VAL(GENERAL,
+			phy_user->align_insertion_frequency);
+
+	writel(clksm_value, &sci_phy->link_layer_registers->clock_skew_management);
+
+	/* @todo Provide a way to write this register correctly */
+	writel(0x02108421,
+		&sci_phy->link_layer_registers->afe_lookup_table_control);
+
+	llctl = SCU_SAS_LLCTL_GEN_VAL(NO_OUTBOUND_TASK_TIMEOUT,
+		(u8)scic->user_parameters.sds1.no_outbound_task_timeout);
+
+	switch(phy_user->max_speed_generation) {
+	case SCIC_SDS_PARM_GEN3_SPEED:
+		link_rate = SCU_SAS_LINK_LAYER_CONTROL_MAX_LINK_RATE_GEN3;
+		break;
+	case SCIC_SDS_PARM_GEN2_SPEED:
+		link_rate = SCU_SAS_LINK_LAYER_CONTROL_MAX_LINK_RATE_GEN2;
+		break;
+	default:
+		link_rate = SCU_SAS_LINK_LAYER_CONTROL_MAX_LINK_RATE_GEN1;
+		break;
+	}
+	llctl |= SCU_SAS_LLCTL_GEN_VAL(MAX_LINK_RATE, link_rate);
+	writel(llctl, &sci_phy->link_layer_registers->link_layer_control);
+
+	if (is_a0() || is_a2()) {
+		/* Program the max ARB time for the PHY to 700us so we inter-operate with
+		 * the PMC expander which shuts down PHYs if the expander PHY generates too
+		 * many breaks.  This time value will guarantee that the initiator PHY will
+		 * generate the break.
+		 */
+		writel(SCIC_SDS_PHY_MAX_ARBITRATION_WAIT_TIME,
+			&sci_phy->link_layer_registers->maximum_arbitration_wait_timer_timeout);
+	}
+
+	/*
+	 * Set the link layer hang detection to 500ms (0x1F4) from its default
+	 * value of 128ms.  Max value is 511 ms.
+	 */
+	writel(0x1F4, &sci_phy->link_layer_registers->link_layer_hang_detection_timeout);
+
+	/* We can exit the initial state to the stopped state */
+	sci_base_state_machine_change_state(&sci_phy->state_machine,
+					    SCI_BASE_PHY_STATE_STOPPED);
+
+	return SCI_SUCCESS;
+}
+
+/**
+ * This function will handle the sata SIGNATURE FIS timeout condition.  It will
+ * restart the starting substate machine since we dont know what has actually
+ * happening.
+ */
+static void scic_sds_phy_sata_timeout(void *phy)
+{
+	struct scic_sds_phy *sci_phy = phy;
+
+	dev_dbg(sciphy_to_dev(sci_phy),
+		 "%s: SCIC SDS Phy 0x%p did not receive signature fis before "
+		 "timeout.\n",
+		 __func__,
+		 sci_phy);
+
+	sci_base_state_machine_stop(&sci_phy->starting_substate_machine);
+
+	sci_base_state_machine_change_state(&sci_phy->state_machine,
+					    SCI_BASE_PHY_STATE_STARTING);
+}
+
+/**
+ * This method returns the port currently containing this phy. If the phy is
+ *    currently contained by the dummy port, then the phy is considered to not
+ *    be part of a port.
+ * @sci_phy: This parameter specifies the phy for which to retrieve the
+ *    containing port.
+ *
+ * This method returns a handle to a port that contains the supplied phy.
+ * NULL This value is returned if the phy is not part of a real
+ * port (i.e. it's contained in the dummy port). !NULL All other
+ * values indicate a handle/pointer to the port containing the phy.
+ */
+struct scic_sds_port *scic_sds_phy_get_port(
+	struct scic_sds_phy *sci_phy)
+{
+	if (scic_sds_port_get_index(sci_phy->owning_port) == SCIC_SDS_DUMMY_PORT)
+		return NULL;
+
+	return sci_phy->owning_port;
+}
+
+/**
+ * This method will assign a port to the phy object.
+ * @out]: sci_phy This parameter specifies the phy for which to assign a port
+ *    object.
+ *
+ *
+ */
+void scic_sds_phy_set_port(
+	struct scic_sds_phy *sci_phy,
+	struct scic_sds_port *sci_port)
+{
+	sci_phy->owning_port = sci_port;
+
+	if (sci_phy->bcn_received_while_port_unassigned) {
+		sci_phy->bcn_received_while_port_unassigned = false;
+		scic_sds_port_broadcast_change_received(sci_phy->owning_port, sci_phy);
+	}
+}
+
+/**
+ * This method will initialize the constructed phy
+ * @sci_phy:
+ * @link_layer_registers:
+ *
+ * enum sci_status
+ */
+enum sci_status scic_sds_phy_initialize(
+	struct scic_sds_phy *sci_phy,
+	struct scu_transport_layer_registers __iomem *transport_layer_registers,
+	struct scu_link_layer_registers __iomem *link_layer_registers)
+{
+	struct scic_sds_controller *scic = scic_sds_phy_get_controller(sci_phy);
+	struct isci_host *ihost = scic_to_ihost(scic);
+
+	/* Create the SIGNATURE FIS Timeout timer for this phy */
+	sci_phy->sata_timeout_timer =
+		isci_timer_create(
+			ihost,
+			sci_phy,
+			scic_sds_phy_sata_timeout);
+
+	/* Perfrom the initialization of the TL hardware */
+	scic_sds_phy_transport_layer_initialization(
+			sci_phy,
+			transport_layer_registers);
+
+	/* Perofrm the initialization of the PE hardware */
+	scic_sds_phy_link_layer_initialization(sci_phy, link_layer_registers);
+
+	/*
+	 * There is nothing that needs to be done in this state just
+	 * transition to the stopped state. */
+	sci_base_state_machine_change_state(&sci_phy->state_machine,
+					    SCI_BASE_PHY_STATE_STOPPED);
+
+	return SCI_SUCCESS;
+}
+
+/**
+ * This method assigns the direct attached device ID for this phy.
+ *
+ * @sci_phy The phy for which the direct attached device id is to
+ *       be assigned.
+ * @device_id The direct attached device ID to assign to the phy.
+ *       This will either be the RNi for the device or an invalid RNi if there
+ *       is no current device assigned to the phy.
+ */
+void scic_sds_phy_setup_transport(
+	struct scic_sds_phy *sci_phy,
+	u32 device_id)
+{
+	u32 tl_control;
+
+	writel(device_id, &sci_phy->transport_layer_registers->stp_rni);
+
+	/*
+	 * The read should guarantee that the first write gets posted
+	 * before the next write
+	 */
+	tl_control = readl(&sci_phy->transport_layer_registers->control);
+	tl_control |= SCU_TLCR_GEN_BIT(CLEAR_TCI_NCQ_MAPPING_TABLE);
+	writel(tl_control, &sci_phy->transport_layer_registers->control);
+}
+
+/**
+ *
+ * @sci_phy: The phy object to be suspended.
+ *
+ * This function will perform the register reads/writes to suspend the SCU
+ * hardware protocol engine. none
+ */
+static void scic_sds_phy_suspend(
+	struct scic_sds_phy *sci_phy)
+{
+	u32 scu_sas_pcfg_value;
+
+	scu_sas_pcfg_value =
+		readl(&sci_phy->link_layer_registers->phy_configuration);
+	scu_sas_pcfg_value |= SCU_SAS_PCFG_GEN_BIT(SUSPEND_PROTOCOL_ENGINE);
+	writel(scu_sas_pcfg_value,
+		&sci_phy->link_layer_registers->phy_configuration);
+
+	scic_sds_phy_setup_transport(
+			sci_phy,
+			SCIC_SDS_REMOTE_NODE_CONTEXT_INVALID_INDEX);
+}
+
+void scic_sds_phy_resume(struct scic_sds_phy *sci_phy)
+{
+	u32 scu_sas_pcfg_value;
+
+	scu_sas_pcfg_value =
+		readl(&sci_phy->link_layer_registers->phy_configuration);
+	scu_sas_pcfg_value &= ~SCU_SAS_PCFG_GEN_BIT(SUSPEND_PROTOCOL_ENGINE);
+	writel(scu_sas_pcfg_value,
+		&sci_phy->link_layer_registers->phy_configuration);
+}
+
+void scic_sds_phy_get_sas_address(struct scic_sds_phy *sci_phy,
+				  struct sci_sas_address *sas_address)
+{
+	sas_address->high = readl(&sci_phy->link_layer_registers->source_sas_address_high);
+	sas_address->low = readl(&sci_phy->link_layer_registers->source_sas_address_low);
+}
+
+void scic_sds_phy_get_attached_sas_address(struct scic_sds_phy *sci_phy,
+					   struct sci_sas_address *sas_address)
+{
+	struct sas_identify_frame *iaf;
+	struct isci_phy *iphy = sci_phy_to_iphy(sci_phy);
+
+	iaf = &iphy->frame_rcvd.iaf;
+	memcpy(sas_address, iaf->sas_addr, SAS_ADDR_SIZE);
+}
+
+void scic_sds_phy_get_protocols(struct scic_sds_phy *sci_phy,
+				struct scic_phy_proto *protocols)
+{
+	protocols->all =
+		(u16)(readl(&sci_phy->
+			link_layer_registers->transmit_identification) &
+				0x0000FFFF);
+}
+
+/**
+ * This method will attempt to start the phy object. This request is only valid
+ *    when the phy is in the stopped state
+ * @sci_phy:
+ *
+ * enum sci_status
+ */
+enum sci_status scic_sds_phy_start(struct scic_sds_phy *sci_phy)
+{
+	return sci_phy->state_handlers->start_handler(sci_phy);
+}
+
+/**
+ * This method will attempt to stop the phy object.
+ * @sci_phy:
+ *
+ * enum sci_status SCI_SUCCESS if the phy is going to stop SCI_INVALID_STATE
+ * if the phy is not in a valid state to stop
+ */
+enum sci_status scic_sds_phy_stop(struct scic_sds_phy *sci_phy)
+{
+	return sci_phy->state_handlers->stop_handler(sci_phy);
+}
+
+/**
+ * This method will attempt to reset the phy.  This request is only valid when
+ *    the phy is in an ready state
+ * @sci_phy:
+ *
+ * enum sci_status
+ */
+enum sci_status scic_sds_phy_reset(
+	struct scic_sds_phy *sci_phy)
+{
+	return sci_phy->state_handlers->reset_handler(sci_phy);
+}
+
+/**
+ * This method will process the event code received.
+ * @sci_phy:
+ * @event_code:
+ *
+ * enum sci_status
+ */
+enum sci_status scic_sds_phy_event_handler(
+	struct scic_sds_phy *sci_phy,
+	u32 event_code)
+{
+	return sci_phy->state_handlers->event_handler(sci_phy, event_code);
+}
+
+/**
+ * This method will process the frame index received.
+ * @sci_phy:
+ * @frame_index:
+ *
+ * enum sci_status
+ */
+enum sci_status scic_sds_phy_frame_handler(
+	struct scic_sds_phy *sci_phy,
+	u32 frame_index)
+{
+	return sci_phy->state_handlers->frame_handler(sci_phy, frame_index);
+}
+
+/**
+ * This method will give the phy permission to consume power
+ * @sci_phy:
+ *
+ * enum sci_status
+ */
+enum sci_status scic_sds_phy_consume_power_handler(
+	struct scic_sds_phy *sci_phy)
+{
+	return sci_phy->state_handlers->consume_power_handler(sci_phy);
+}
+
+/*
+ * *****************************************************************************
+ * * SCIC SDS PHY HELPER FUNCTIONS
+ * ***************************************************************************** */
+
+
+/**
+ *
+ * @sci_phy: The phy object that received SAS PHY DETECTED.
+ *
+ * This method continues the link training for the phy as if it were a SAS PHY
+ * instead of a SATA PHY. This is done because the completion queue had a SAS
+ * PHY DETECTED event when the state machine was expecting a SATA PHY event.
+ * none
+ */
+static void scic_sds_phy_start_sas_link_training(
+	struct scic_sds_phy *sci_phy)
+{
+	u32 phy_control;
+
+	phy_control =
+		readl(&sci_phy->link_layer_registers->phy_configuration);
+	phy_control |= SCU_SAS_PCFG_GEN_BIT(SATA_SPINUP_HOLD);
+	writel(phy_control,
+		&sci_phy->link_layer_registers->phy_configuration);
+
+	sci_base_state_machine_change_state(
+		&sci_phy->starting_substate_machine,
+		SCIC_SDS_PHY_STARTING_SUBSTATE_AWAIT_SAS_SPEED_EN
+		);
+
+	sci_phy->protocol = SCIC_SDS_PHY_PROTOCOL_SAS;
+}
+
+/**
+ *
+ * @sci_phy: The phy object that received a SATA SPINUP HOLD event
+ *
+ * This method continues the link training for the phy as if it were a SATA PHY
+ * instead of a SAS PHY.  This is done because the completion queue had a SATA
+ * SPINUP HOLD event when the state machine was expecting a SAS PHY event. none
+ */
+static void scic_sds_phy_start_sata_link_training(
+	struct scic_sds_phy *sci_phy)
+{
+	sci_base_state_machine_change_state(
+		&sci_phy->starting_substate_machine,
+		SCIC_SDS_PHY_STARTING_SUBSTATE_AWAIT_SATA_POWER
+		);
+
+	sci_phy->protocol = SCIC_SDS_PHY_PROTOCOL_SATA;
+}
+
+/**
+ * scic_sds_phy_complete_link_training - perform processing common to
+ *    all protocols upon completion of link training.
+ * @sci_phy: This parameter specifies the phy object for which link training
+ *    has completed.
+ * @max_link_rate: This parameter specifies the maximum link rate to be
+ *    associated with this phy.
+ * @next_state: This parameter specifies the next state for the phy's starting
+ *    sub-state machine.
+ *
+ */
+static void scic_sds_phy_complete_link_training(
+	struct scic_sds_phy *sci_phy,
+	enum sas_linkrate max_link_rate,
+	u32 next_state)
+{
+	sci_phy->max_negotiated_speed = max_link_rate;
+
+	sci_base_state_machine_change_state(&sci_phy->starting_substate_machine,
+					    next_state);
+}
+
+static void scic_sds_phy_restart_starting_state(
+	struct scic_sds_phy *sci_phy)
+{
+	/* Stop the current substate machine */
+	sci_base_state_machine_stop(&sci_phy->starting_substate_machine);
+
+	/* Re-enter the base state machine starting state */
+	sci_base_state_machine_change_state(&sci_phy->state_machine,
+					    SCI_BASE_PHY_STATE_STARTING);
+}
+
+/* ****************************************************************************
+   * SCIC SDS PHY general handlers
+   ************************************************************************** */
+static enum sci_status scic_sds_phy_starting_substate_general_stop_handler(
+	struct scic_sds_phy *phy)
+{
+	sci_base_state_machine_stop(&phy->starting_substate_machine);
+
+	sci_base_state_machine_change_state(&phy->state_machine,
+						 SCI_BASE_PHY_STATE_STOPPED);
+
+	return SCI_SUCCESS;
+}
+
+/*
+ * *****************************************************************************
+ * * SCIC SDS PHY EVENT_HANDLERS
+ * ***************************************************************************** */
+
+/**
+ *
+ * @phy: This struct scic_sds_phy object which has received an event.
+ * @event_code: This is the event code which the phy object is to decode.
+ *
+ * This method is called when an event notification is received for the phy
+ * object when in the state SCIC_SDS_PHY_STARTING_SUBSTATE_AWAIT_SPEED_EN. -
+ * decode the event - sas phy detected causes a state transition to the wait
+ * for speed event notification. - any other events log a warning message and
+ * set a failure status enum sci_status SCI_SUCCESS on any valid event notification
+ * SCI_FAILURE on any unexpected event notifation
+ */
+static enum sci_status scic_sds_phy_starting_substate_await_ossp_event_handler(
+	struct scic_sds_phy *sci_phy,
+	u32 event_code)
+{
+	u32 result = SCI_SUCCESS;
+
+	switch (scu_get_event_code(event_code)) {
+	case SCU_EVENT_SAS_PHY_DETECTED:
+		scic_sds_phy_start_sas_link_training(sci_phy);
+		sci_phy->is_in_link_training = true;
+		break;
+
+	case SCU_EVENT_SATA_SPINUP_HOLD:
+		scic_sds_phy_start_sata_link_training(sci_phy);
+		sci_phy->is_in_link_training = true;
+		break;
+
+	default:
+		dev_dbg(sciphy_to_dev(sci_phy),
+			"%s: PHY starting substate machine received "
+			"unexpected event_code %x\n",
+			__func__,
+			event_code);
+
+		result = SCI_FAILURE;
+		break;
+	}
+
+	return result;
+}
+
+/**
+ *
+ * @phy: This struct scic_sds_phy object which has received an event.
+ * @event_code: This is the event code which the phy object is to decode.
+ *
+ * This method is called when an event notification is received for the phy
+ * object when in the state SCIC_SDS_PHY_STARTING_SUBSTATE_AWAIT_SPEED_EN. -
+ * decode the event - sas phy detected returns us back to this state. - speed
+ * event detected causes a state transition to the wait for iaf. - identify
+ * timeout is an un-expected event and the state machine is restarted. - link
+ * failure events restart the starting state machine - any other events log a
+ * warning message and set a failure status enum sci_status SCI_SUCCESS on any valid
+ * event notification SCI_FAILURE on any unexpected event notifation
+ */
+static enum sci_status scic_sds_phy_starting_substate_await_sas_phy_speed_event_handler(
+	struct scic_sds_phy *sci_phy,
+	u32 event_code)
+{
+	u32 result = SCI_SUCCESS;
+
+	switch (scu_get_event_code(event_code)) {
+	case SCU_EVENT_SAS_PHY_DETECTED:
+		/*
+		 * Why is this being reported again by the controller?
+		 * We would re-enter this state so just stay here */
+		break;
+
+	case SCU_EVENT_SAS_15:
+	case SCU_EVENT_SAS_15_SSC:
+		scic_sds_phy_complete_link_training(
+			sci_phy,
+			SAS_LINK_RATE_1_5_GBPS,
+			SCIC_SDS_PHY_STARTING_SUBSTATE_AWAIT_IAF_UF);
+		break;
+
+	case SCU_EVENT_SAS_30:
+	case SCU_EVENT_SAS_30_SSC:
+		scic_sds_phy_complete_link_training(
+			sci_phy,
+			SAS_LINK_RATE_3_0_GBPS,
+			SCIC_SDS_PHY_STARTING_SUBSTATE_AWAIT_IAF_UF);
+		break;
+
+	case SCU_EVENT_SAS_60:
+	case SCU_EVENT_SAS_60_SSC:
+		scic_sds_phy_complete_link_training(
+			sci_phy,
+			SAS_LINK_RATE_6_0_GBPS,
+			SCIC_SDS_PHY_STARTING_SUBSTATE_AWAIT_IAF_UF);
+		break;
+
+	case SCU_EVENT_SATA_SPINUP_HOLD:
+		/*
+		 * We were doing SAS PHY link training and received a SATA PHY event
+		 * continue OOB/SN as if this were a SATA PHY */
+		scic_sds_phy_start_sata_link_training(sci_phy);
+		break;
+
+	case SCU_EVENT_LINK_FAILURE:
+		/* Link failure change state back to the starting state */
+		scic_sds_phy_restart_starting_state(sci_phy);
+		break;
+
+	default:
+		dev_warn(sciphy_to_dev(sci_phy),
+			 "%s: PHY starting substate machine received "
+			 "unexpected event_code %x\n",
+			 __func__,
+			 event_code);
+
+		result = SCI_FAILURE;
+		break;
+	}
+
+	return result;
+}
+
+/**
+ *
+ * @phy: This struct scic_sds_phy object which has received an event.
+ * @event_code: This is the event code which the phy object is to decode.
+ *
+ * This method is called when an event notification is received for the phy
+ * object when in the state SCIC_SDS_PHY_STARTING_SUBSTATE_AWAIT_IAF_UF. -
+ * decode the event - sas phy detected event backs up the state machine to the
+ * await speed notification. - identify timeout is an un-expected event and the
+ * state machine is restarted. - link failure events restart the starting state
+ * machine - any other events log a warning message and set a failure status
+ * enum sci_status SCI_SUCCESS on any valid event notification SCI_FAILURE on any
+ * unexpected event notifation
+ */
+static enum sci_status scic_sds_phy_starting_substate_await_iaf_uf_event_handler(
+	struct scic_sds_phy *sci_phy,
+	u32 event_code)
+{
+	u32 result = SCI_SUCCESS;
+
+	switch (scu_get_event_code(event_code)) {
+	case SCU_EVENT_SAS_PHY_DETECTED:
+		/* Backup the state machine */
+		scic_sds_phy_start_sas_link_training(sci_phy);
+		break;
+
+	case SCU_EVENT_SATA_SPINUP_HOLD:
+		/*
+		 * We were doing SAS PHY link training and received a SATA PHY event
+		 * continue OOB/SN as if this were a SATA PHY */
+		scic_sds_phy_start_sata_link_training(sci_phy);
+		break;
+
+	case SCU_EVENT_RECEIVED_IDENTIFY_TIMEOUT:
+	case SCU_EVENT_LINK_FAILURE:
+	case SCU_EVENT_HARD_RESET_RECEIVED:
+		/* Start the oob/sn state machine over again */
+		scic_sds_phy_restart_starting_state(sci_phy);
+		break;
+
+	default:
+		dev_warn(sciphy_to_dev(sci_phy),
+			 "%s: PHY starting substate machine received "
+			 "unexpected event_code %x\n",
+			 __func__,
+			 event_code);
+
+		result = SCI_FAILURE;
+		break;
+	}
+
+	return result;
+}
+
+/**
+ *
+ * @phy: This struct scic_sds_phy object which has received an event.
+ * @event_code: This is the event code which the phy object is to decode.
+ *
+ * This method is called when an event notification is received for the phy
+ * object when in the state SCIC_SDS_PHY_STARTING_SUBSTATE_AWAIT_POWER. -
+ * decode the event - link failure events restart the starting state machine -
+ * any other events log a warning message and set a failure status enum sci_status
+ * SCI_SUCCESS on a link failure event SCI_FAILURE on any unexpected event
+ * notifation
+ */
+static enum sci_status scic_sds_phy_starting_substate_await_sas_power_event_handler(
+	struct scic_sds_phy *sci_phy,
+	u32 event_code)
+{
+	u32 result = SCI_SUCCESS;
+
+	switch (scu_get_event_code(event_code)) {
+	case SCU_EVENT_LINK_FAILURE:
+		/* Link failure change state back to the starting state */
+		scic_sds_phy_restart_starting_state(sci_phy);
+		break;
+
+	default:
+		dev_warn(sciphy_to_dev(sci_phy),
+			"%s: PHY starting substate machine received unexpected "
+			"event_code %x\n",
+			__func__,
+			event_code);
+
+		result = SCI_FAILURE;
+		break;
+	}
+
+	return result;
+}
+
+/**
+ *
+ * @phy: This struct scic_sds_phy object which has received an event.
+ * @event_code: This is the event code which the phy object is to decode.
+ *
+ * This method is called when an event notification is received for the phy
+ * object when in the state SCIC_SDS_PHY_STARTING_SUBSTATE_AWAIT_SATA_POWER. -
+ * decode the event - link failure events restart the starting state machine -
+ * sata spinup hold events are ignored since they are expected - any other
+ * events log a warning message and set a failure status enum sci_status SCI_SUCCESS
+ * on a link failure event SCI_FAILURE on any unexpected event notifation
+ */
+static enum sci_status scic_sds_phy_starting_substate_await_sata_power_event_handler(
+	struct scic_sds_phy *sci_phy,
+	u32 event_code)
+{
+	u32 result = SCI_SUCCESS;
+
+	switch (scu_get_event_code(event_code)) {
+	case SCU_EVENT_LINK_FAILURE:
+		/* Link failure change state back to the starting state */
+		scic_sds_phy_restart_starting_state(sci_phy);
+		break;
+
+	case SCU_EVENT_SATA_SPINUP_HOLD:
+		/* These events are received every 10ms and are expected while in this state */
+		break;
+
+	case SCU_EVENT_SAS_PHY_DETECTED:
+		/*
+		 * There has been a change in the phy type before OOB/SN for the
+		 * SATA finished start down the SAS link traning path. */
+		scic_sds_phy_start_sas_link_training(sci_phy);
+		break;
+
+	default:
+		dev_warn(sciphy_to_dev(sci_phy),
+			 "%s: PHY starting substate machine received "
+			 "unexpected event_code %x\n",
+			 __func__,
+			 event_code);
+
+		result = SCI_FAILURE;
+		break;
+	}
+
+	return result;
+}
+
+/**
+ * scic_sds_phy_starting_substate_await_sata_phy_event_handler -
+ * @phy: This struct scic_sds_phy object which has received an event.
+ * @event_code: This is the event code which the phy object is to decode.
+ *
+ * This method is called when an event notification is received for the phy
+ * object when in the state SCIC_SDS_PHY_STARTING_SUBSTATE_AWAIT_SATA_PHY_EN. -
+ * decode the event - link failure events restart the starting state machine -
+ * sata spinup hold events are ignored since they are expected - sata phy
+ * detected event change to the wait speed event - any other events log a
+ * warning message and set a failure status enum sci_status SCI_SUCCESS on a link
+ * failure event SCI_FAILURE on any unexpected event notifation
+ */
+static enum sci_status scic_sds_phy_starting_substate_await_sata_phy_event_handler(
+	struct scic_sds_phy *sci_phy, u32 event_code)
+{
+	u32 result = SCI_SUCCESS;
+
+	switch (scu_get_event_code(event_code)) {
+	case SCU_EVENT_LINK_FAILURE:
+		/* Link failure change state back to the starting state */
+		scic_sds_phy_restart_starting_state(sci_phy);
+		break;
+
+	case SCU_EVENT_SATA_SPINUP_HOLD:
+		/* These events might be received since we dont know how many may be in
+		 * the completion queue while waiting for power
+		 */
+		break;
+
+	case SCU_EVENT_SATA_PHY_DETECTED:
+		sci_phy->protocol = SCIC_SDS_PHY_PROTOCOL_SATA;
+
+		/* We have received the SATA PHY notification change state */
+		sci_base_state_machine_change_state(&sci_phy->starting_substate_machine,
+						    SCIC_SDS_PHY_STARTING_SUBSTATE_AWAIT_SATA_SPEED_EN);
+		break;
+
+	case SCU_EVENT_SAS_PHY_DETECTED:
+		/* There has been a change in the phy type before OOB/SN for the
+		 * SATA finished start down the SAS link traning path.
+		 */
+		scic_sds_phy_start_sas_link_training(sci_phy);
+		break;
+
+	default:
+		dev_warn(sciphy_to_dev(sci_phy),
+			 "%s: PHY starting substate machine received "
+			 "unexpected event_code %x\n",
+			 __func__,
+			 event_code);
+
+		result = SCI_FAILURE;
+		break;
+	}
+
+	return result;
+}
+
+/**
+ *
+ * @phy: This struct scic_sds_phy object which has received an event.
+ * @event_code: This is the event code which the phy object is to decode.
+ *
+ * This method is called when an event notification is received for the phy
+ * object when in the state SCIC_SDS_PHY_STARTING_SUBSTATE_AWAIT_SATA_SPEED_EN.
+ * - decode the event - sata phy detected returns us back to this state. -
+ * speed event detected causes a state transition to the wait for signature. -
+ * link failure events restart the starting state machine - any other events
+ * log a warning message and set a failure status enum sci_status SCI_SUCCESS on any
+ * valid event notification SCI_FAILURE on any unexpected event notifation
+ */
+static enum sci_status scic_sds_phy_starting_substate_await_sata_speed_event_handler(
+	struct scic_sds_phy *sci_phy,
+	u32 event_code)
+{
+	u32 result = SCI_SUCCESS;
+
+	switch (scu_get_event_code(event_code)) {
+	case SCU_EVENT_SATA_PHY_DETECTED:
+		/*
+		 * The hardware reports multiple SATA PHY detected events
+		 * ignore the extras */
+		break;
+
+	case SCU_EVENT_SATA_15:
+	case SCU_EVENT_SATA_15_SSC:
+		scic_sds_phy_complete_link_training(
+			sci_phy,
+			SAS_LINK_RATE_1_5_GBPS,
+			SCIC_SDS_PHY_STARTING_SUBSTATE_AWAIT_SIG_FIS_UF);
+		break;
+
+	case SCU_EVENT_SATA_30:
+	case SCU_EVENT_SATA_30_SSC:
+		scic_sds_phy_complete_link_training(
+			sci_phy,
+			SAS_LINK_RATE_3_0_GBPS,
+			SCIC_SDS_PHY_STARTING_SUBSTATE_AWAIT_SIG_FIS_UF);
+		break;
+
+	case SCU_EVENT_SATA_60:
+	case SCU_EVENT_SATA_60_SSC:
+		scic_sds_phy_complete_link_training(
+			sci_phy,
+			SAS_LINK_RATE_6_0_GBPS,
+			SCIC_SDS_PHY_STARTING_SUBSTATE_AWAIT_SIG_FIS_UF);
+		break;
+
+	case SCU_EVENT_LINK_FAILURE:
+		/* Link failure change state back to the starting state */
+		scic_sds_phy_restart_starting_state(sci_phy);
+		break;
+
+	case SCU_EVENT_SAS_PHY_DETECTED:
+		/*
+		 * There has been a change in the phy type before OOB/SN for the
+		 * SATA finished start down the SAS link traning path. */
+		scic_sds_phy_start_sas_link_training(sci_phy);
+		break;
+
+	default:
+		dev_warn(sciphy_to_dev(sci_phy),
+			 "%s: PHY starting substate machine received "
+			 "unexpected event_code %x\n",
+			 __func__,
+			 event_code);
+
+		result = SCI_FAILURE;
+		break;
+	}
+
+	return result;
+}
+
+/**
+ * scic_sds_phy_starting_substate_await_sig_fis_event_handler -
+ * @phy: This struct scic_sds_phy object which has received an event.
+ * @event_code: This is the event code which the phy object is to decode.
+ *
+ * This method is called when an event notification is received for the phy
+ * object when in the state SCIC_SDS_PHY_STARTING_SUBSTATE_AWAIT_SIG_FIS_UF. -
+ * decode the event - sas phy detected event backs up the state machine to the
+ * await speed notification. - identify timeout is an un-expected event and the
+ * state machine is restarted. - link failure events restart the starting state
+ * machine - any other events log a warning message and set a failure status
+ * enum sci_status SCI_SUCCESS on any valid event notification SCI_FAILURE on any
+ * unexpected event notifation
+ */
+static enum sci_status scic_sds_phy_starting_substate_await_sig_fis_event_handler(
+	struct scic_sds_phy *sci_phy, u32 event_code)
+{
+	u32 result = SCI_SUCCESS;
+
+	switch (scu_get_event_code(event_code)) {
+	case SCU_EVENT_SATA_PHY_DETECTED:
+		/* Backup the state machine */
+		sci_base_state_machine_change_state(&sci_phy->starting_substate_machine,
+						    SCIC_SDS_PHY_STARTING_SUBSTATE_AWAIT_SATA_SPEED_EN);
+		break;
+
+	case SCU_EVENT_LINK_FAILURE:
+		/* Link failure change state back to the starting state */
+		scic_sds_phy_restart_starting_state(sci_phy);
+		break;
+
+	default:
+		dev_warn(sciphy_to_dev(sci_phy),
+			 "%s: PHY starting substate machine received "
+			 "unexpected event_code %x\n",
+			 __func__,
+			 event_code);
+
+		result = SCI_FAILURE;
+		break;
+	}
+
+	return result;
+}
+
+
+/*
+ * *****************************************************************************
+ * *  SCIC SDS PHY FRAME_HANDLERS
+ * ***************************************************************************** */
+
+/**
+ *
+ * @phy: This is struct scic_sds_phy object which is being requested to decode the
+ *    frame data.
+ * @frame_index: This is the index of the unsolicited frame which was received
+ *    for this phy.
+ *
+ * This method decodes the unsolicited frame when the struct scic_sds_phy is in the
+ * SCIC_SDS_PHY_STARTING_SUBSTATE_AWAIT_IAF_UF. - Get the UF Header - If the UF
+ * is an IAF - Copy IAF data to local phy object IAF data buffer. - Change
+ * starting substate to wait power. - else - log warning message of unexpected
+ * unsolicted frame - release frame buffer enum sci_status SCI_SUCCESS
+ */
+static enum sci_status scic_sds_phy_starting_substate_await_iaf_uf_frame_handler(
+	struct scic_sds_phy *sci_phy, u32 frame_index)
+{
+	enum sci_status result;
+	u32 *frame_words;
+	struct sas_identify_frame iaf;
+	struct isci_phy *iphy = sci_phy_to_iphy(sci_phy);
+
+	result = scic_sds_unsolicited_frame_control_get_header(
+		&(scic_sds_phy_get_controller(sci_phy)->uf_control),
+		frame_index,
+		(void **)&frame_words);
+
+	if (result != SCI_SUCCESS)
+		return result;
+
+	sci_swab32_cpy(&iaf, frame_words, sizeof(iaf) / sizeof(u32));
+	if (iaf.frame_type == 0) {
+		u32 state;
+
+		memcpy(&iphy->frame_rcvd.iaf, &iaf, sizeof(iaf));
+		if (iaf.smp_tport) {
+			/* We got the IAF for an expander PHY go to the final
+			 * state since there are no power requirements for
+			 * expander phys.
+			 */
+			state = SCIC_SDS_PHY_STARTING_SUBSTATE_FINAL;
+		} else {
+			/* We got the IAF we can now go to the await spinup
+			 * semaphore state
+			 */
+			state = SCIC_SDS_PHY_STARTING_SUBSTATE_AWAIT_SAS_POWER;
+		}
+		sci_base_state_machine_change_state(
+				&sci_phy->starting_substate_machine,
+				state);
+		result = SCI_SUCCESS;
+	} else
+		dev_warn(sciphy_to_dev(sci_phy),
+			"%s: PHY starting substate machine received "
+			"unexpected frame id %x\n",
+			__func__,
+			frame_index);
+
+	scic_sds_controller_release_frame(scic_sds_phy_get_controller(sci_phy),
+					  frame_index);
+
+	return result;
+}
+
+/**
+ *
+ * @phy: This is struct scic_sds_phy object which is being requested to decode the
+ *    frame data.
+ * @frame_index: This is the index of the unsolicited frame which was received
+ *    for this phy.
+ *
+ * This method decodes the unsolicited frame when the struct scic_sds_phy is in the
+ * SCIC_SDS_PHY_STARTING_SUBSTATE_AWAIT_SIG_FIS_UF. - Get the UF Header - If
+ * the UF is an SIGNATURE FIS - Copy IAF data to local phy object SIGNATURE FIS
+ * data buffer. - else - log warning message of unexpected unsolicted frame -
+ * release frame buffer enum sci_status SCI_SUCCESS Must decode the SIGNATURE FIS
+ * data
+ */
+static enum sci_status scic_sds_phy_starting_substate_await_sig_fis_frame_handler(
+	struct scic_sds_phy *sci_phy,
+	u32 frame_index)
+{
+	enum sci_status result;
+	struct dev_to_host_fis *frame_header;
+	u32 *fis_frame_data;
+	struct isci_phy *iphy = sci_phy_to_iphy(sci_phy);
+
+	result = scic_sds_unsolicited_frame_control_get_header(
+		&(scic_sds_phy_get_controller(sci_phy)->uf_control),
+		frame_index,
+		(void **)&frame_header);
+
+	if (result != SCI_SUCCESS)
+		return result;
+
+	if ((frame_header->fis_type == FIS_REGD2H) &&
+	    !(frame_header->status & ATA_BUSY)) {
+		scic_sds_unsolicited_frame_control_get_buffer(
+			&(scic_sds_phy_get_controller(sci_phy)->uf_control),
+			frame_index,
+			(void **)&fis_frame_data);
+
+		scic_sds_controller_copy_sata_response(&iphy->frame_rcvd.fis,
+						       frame_header,
+						       fis_frame_data);
+
+		/* got IAF we can now go to the await spinup semaphore state */
+		sci_base_state_machine_change_state(&sci_phy->starting_substate_machine,
+						    SCIC_SDS_PHY_STARTING_SUBSTATE_FINAL);
+
+		result = SCI_SUCCESS;
+	} else
+		dev_warn(sciphy_to_dev(sci_phy),
+			 "%s: PHY starting substate machine received "
+			 "unexpected frame id %x\n",
+			 __func__,
+			 frame_index);
+
+	/* Regardless of the result we are done with this frame with it */
+	scic_sds_controller_release_frame(scic_sds_phy_get_controller(sci_phy),
+					  frame_index);
+
+	return result;
+}
+
+/*
+ * *****************************************************************************
+ * * SCIC SDS PHY POWER_HANDLERS
+ * ***************************************************************************** */
+
+/*
+ * This method is called by the struct scic_sds_controller when the phy object is
+ * granted power. - The notify enable spinups are turned on for this phy object
+ * - The phy state machine is transitioned to the
+ * SCIC_SDS_PHY_STARTING_SUBSTATE_FINAL. enum sci_status SCI_SUCCESS
+ */
+static enum sci_status scic_sds_phy_starting_substate_await_sas_power_consume_power_handler(
+	struct scic_sds_phy *sci_phy)
+{
+	u32 enable_spinup;
+
+	enable_spinup = readl(&sci_phy->link_layer_registers->notify_enable_spinup_control);
+	enable_spinup |= SCU_ENSPINUP_GEN_BIT(ENABLE);
+	writel(enable_spinup, &sci_phy->link_layer_registers->notify_enable_spinup_control);
+
+	/* Change state to the final state this substate machine has run to completion */
+	sci_base_state_machine_change_state(&sci_phy->starting_substate_machine,
+					    SCIC_SDS_PHY_STARTING_SUBSTATE_FINAL);
+
+	return SCI_SUCCESS;
+}
+
+/*
+ * This method is called by the struct scic_sds_controller when the phy object is
+ * granted power. - The phy state machine is transitioned to the
+ * SCIC_SDS_PHY_STARTING_SUBSTATE_AWAIT_SATA_PHY_EN. enum sci_status SCI_SUCCESS
+ */
+static enum sci_status scic_sds_phy_starting_substate_await_sata_power_consume_power_handler(
+	struct scic_sds_phy *sci_phy)
+{
+	u32 scu_sas_pcfg_value;
+
+	/* Release the spinup hold state and reset the OOB state machine */
+	scu_sas_pcfg_value =
+		readl(&sci_phy->link_layer_registers->phy_configuration);
+	scu_sas_pcfg_value &=
+		~(SCU_SAS_PCFG_GEN_BIT(SATA_SPINUP_HOLD) | SCU_SAS_PCFG_GEN_BIT(OOB_ENABLE));
+	scu_sas_pcfg_value |= SCU_SAS_PCFG_GEN_BIT(OOB_RESET);
+	writel(scu_sas_pcfg_value,
+		&sci_phy->link_layer_registers->phy_configuration);
+
+	/* Now restart the OOB operation */
+	scu_sas_pcfg_value &= ~SCU_SAS_PCFG_GEN_BIT(OOB_RESET);
+	scu_sas_pcfg_value |= SCU_SAS_PCFG_GEN_BIT(OOB_ENABLE);
+	writel(scu_sas_pcfg_value,
+		&sci_phy->link_layer_registers->phy_configuration);
+
+	/* Change state to the final state this substate machine has run to completion */
+	sci_base_state_machine_change_state(&sci_phy->starting_substate_machine,
+					    SCIC_SDS_PHY_STARTING_SUBSTATE_AWAIT_SATA_PHY_EN);
+
+	return SCI_SUCCESS;
+}
+
+static enum sci_status default_phy_handler(struct scic_sds_phy *sci_phy,
+					   const char *func)
+{
+	dev_dbg(sciphy_to_dev(sci_phy),
+		 "%s: in wrong state: %d\n", func,
+		 sci_base_state_machine_get_state(&sci_phy->state_machine));
+	return SCI_FAILURE_INVALID_STATE;
+}
+
+static enum sci_status
+scic_sds_phy_default_start_handler(struct scic_sds_phy *sci_phy)
+{
+	return default_phy_handler(sci_phy, __func__);
+}
+
+static enum sci_status
+scic_sds_phy_default_stop_handler(struct scic_sds_phy *sci_phy)
+{
+	return default_phy_handler(sci_phy, __func__);
+}
+
+static enum sci_status
+scic_sds_phy_default_reset_handler(struct scic_sds_phy *sci_phy)
+{
+	return default_phy_handler(sci_phy, __func__);
+}
+
+static enum sci_status
+scic_sds_phy_default_destroy_handler(struct scic_sds_phy *sci_phy)
+{
+	return default_phy_handler(sci_phy, __func__);
+}
+
+static enum sci_status
+scic_sds_phy_default_frame_handler(struct scic_sds_phy *sci_phy,
+				   u32 frame_index)
+{
+	struct scic_sds_controller *scic = scic_sds_phy_get_controller(sci_phy);
+
+	default_phy_handler(sci_phy, __func__);
+	scic_sds_controller_release_frame(scic, frame_index);
+
+	return SCI_FAILURE_INVALID_STATE;
+}
+
+static enum sci_status
+scic_sds_phy_default_event_handler(struct scic_sds_phy *sci_phy,
+				   u32 event_code)
+{
+	return default_phy_handler(sci_phy, __func__);
+}
+
+static enum sci_status
+scic_sds_phy_default_consume_power_handler(struct scic_sds_phy *sci_phy)
+{
+	return default_phy_handler(sci_phy, __func__);
+}
+
+
+
+static const struct scic_sds_phy_state_handler scic_sds_phy_starting_substate_handler_table[] = {
+	[SCIC_SDS_PHY_STARTING_SUBSTATE_INITIAL] = {
+		.start_handler		= scic_sds_phy_default_start_handler,
+		.stop_handler		= scic_sds_phy_starting_substate_general_stop_handler,
+		.reset_handler		= scic_sds_phy_default_reset_handler,
+		.destruct_handler	= scic_sds_phy_default_destroy_handler,
+		.frame_handler		= scic_sds_phy_default_frame_handler,
+		.event_handler		= scic_sds_phy_default_event_handler,
+		.consume_power_handler	= scic_sds_phy_default_consume_power_handler
+	},
+	[SCIC_SDS_PHY_STARTING_SUBSTATE_AWAIT_OSSP_EN] = {
+		.start_handler		= scic_sds_phy_default_start_handler,
+		.stop_handler		= scic_sds_phy_starting_substate_general_stop_handler,
+		.reset_handler		= scic_sds_phy_default_reset_handler,
+		.destruct_handler	= scic_sds_phy_default_destroy_handler,
+		.frame_handler		= scic_sds_phy_default_frame_handler,
+		.event_handler		= scic_sds_phy_starting_substate_await_ossp_event_handler,
+		.consume_power_handler	= scic_sds_phy_default_consume_power_handler
+	},
+	[SCIC_SDS_PHY_STARTING_SUBSTATE_AWAIT_SAS_SPEED_EN] = {
+		.start_handler		= scic_sds_phy_default_start_handler,
+		.stop_handler		= scic_sds_phy_starting_substate_general_stop_handler,
+		.reset_handler		= scic_sds_phy_default_reset_handler,
+		.destruct_handler	= scic_sds_phy_default_destroy_handler,
+		.frame_handler		= scic_sds_phy_default_frame_handler,
+		.event_handler		= scic_sds_phy_starting_substate_await_sas_phy_speed_event_handler,
+		.consume_power_handler	= scic_sds_phy_default_consume_power_handler
+	},
+	[SCIC_SDS_PHY_STARTING_SUBSTATE_AWAIT_IAF_UF] = {
+		.start_handler		= scic_sds_phy_default_start_handler,
+		.stop_handler		= scic_sds_phy_default_stop_handler,
+		.reset_handler		= scic_sds_phy_default_reset_handler,
+		.destruct_handler	= scic_sds_phy_default_destroy_handler,
+		.frame_handler		= scic_sds_phy_starting_substate_await_iaf_uf_frame_handler,
+		.event_handler		= scic_sds_phy_starting_substate_await_iaf_uf_event_handler,
+		.consume_power_handler	= scic_sds_phy_default_consume_power_handler
+	},
+	[SCIC_SDS_PHY_STARTING_SUBSTATE_AWAIT_SAS_POWER] = {
+		.start_handler		= scic_sds_phy_default_start_handler,
+		.stop_handler		= scic_sds_phy_starting_substate_general_stop_handler,
+		.reset_handler		= scic_sds_phy_default_reset_handler,
+		.destruct_handler	= scic_sds_phy_default_destroy_handler,
+		.frame_handler		= scic_sds_phy_default_frame_handler,
+		.event_handler		= scic_sds_phy_starting_substate_await_sas_power_event_handler,
+		.consume_power_handler	= scic_sds_phy_starting_substate_await_sas_power_consume_power_handler
+	},
+	[SCIC_SDS_PHY_STARTING_SUBSTATE_AWAIT_SATA_POWER] = {
+		.start_handler		= scic_sds_phy_default_start_handler,
+		.stop_handler		= scic_sds_phy_starting_substate_general_stop_handler,
+		.reset_handler		= scic_sds_phy_default_reset_handler,
+		.destruct_handler	= scic_sds_phy_default_destroy_handler,
+		.frame_handler		= scic_sds_phy_default_frame_handler,
+		.event_handler		= scic_sds_phy_starting_substate_await_sata_power_event_handler,
+		.consume_power_handler	= scic_sds_phy_starting_substate_await_sata_power_consume_power_handler
+	},
+	[SCIC_SDS_PHY_STARTING_SUBSTATE_AWAIT_SATA_PHY_EN] = {
+		.start_handler		= scic_sds_phy_default_start_handler,
+		.stop_handler		= scic_sds_phy_starting_substate_general_stop_handler,
+		.reset_handler		= scic_sds_phy_default_reset_handler,
+		.destruct_handler	= scic_sds_phy_default_destroy_handler,
+		.frame_handler		= scic_sds_phy_default_frame_handler,
+		.event_handler		= scic_sds_phy_starting_substate_await_sata_phy_event_handler,
+		.consume_power_handler	= scic_sds_phy_default_consume_power_handler
+	},
+	[SCIC_SDS_PHY_STARTING_SUBSTATE_AWAIT_SATA_SPEED_EN] = {
+		.start_handler		= scic_sds_phy_default_start_handler,
+		.stop_handler		= scic_sds_phy_starting_substate_general_stop_handler,
+		.reset_handler		= scic_sds_phy_default_reset_handler,
+		.destruct_handler	= scic_sds_phy_default_destroy_handler,
+		.frame_handler		= scic_sds_phy_default_frame_handler,
+		.event_handler		= scic_sds_phy_starting_substate_await_sata_speed_event_handler,
+		.consume_power_handler	= scic_sds_phy_default_consume_power_handler
+	},
+	[SCIC_SDS_PHY_STARTING_SUBSTATE_AWAIT_SIG_FIS_UF] = {
+		.start_handler		= scic_sds_phy_default_start_handler,
+		.stop_handler		= scic_sds_phy_starting_substate_general_stop_handler,
+		.reset_handler		= scic_sds_phy_default_reset_handler,
+		.destruct_handler	= scic_sds_phy_default_destroy_handler,
+		.frame_handler		= scic_sds_phy_starting_substate_await_sig_fis_frame_handler,
+		.event_handler		= scic_sds_phy_starting_substate_await_sig_fis_event_handler,
+		.consume_power_handler	= scic_sds_phy_default_consume_power_handler
+	},
+	[SCIC_SDS_PHY_STARTING_SUBSTATE_FINAL] = {
+		.start_handler		= scic_sds_phy_default_start_handler,
+		.stop_handler		= scic_sds_phy_starting_substate_general_stop_handler,
+		.reset_handler		= scic_sds_phy_default_reset_handler,
+		.destruct_handler	= scic_sds_phy_default_destroy_handler,
+		.frame_handler		 = scic_sds_phy_default_frame_handler,
+		.event_handler		 = scic_sds_phy_default_event_handler,
+		.consume_power_handler	 = scic_sds_phy_default_consume_power_handler
+	}
+};
+
+/**
+ * scic_sds_phy_set_starting_substate_handlers() -
+ *
+ * This macro sets the starting substate handlers by state_id
+ */
+#define scic_sds_phy_set_starting_substate_handlers(phy, state_id) \
+	scic_sds_phy_set_state_handlers(\
+		(phy), \
+		&scic_sds_phy_starting_substate_handler_table[(state_id)] \
+		)
+
+/*
+ * ****************************************************************************
+ * *  PHY STARTING SUBSTATE METHODS
+ * **************************************************************************** */
+
+/**
+ * scic_sds_phy_starting_initial_substate_enter -
+ * @object: This is the object which is cast to a struct scic_sds_phy object.
+ *
+ * This method will perform the actions required by the struct scic_sds_phy on
+ * entering the SCIC_SDS_PHY_STARTING_SUBSTATE_INITIAL. - The initial state
+ * handlers are put in place for the struct scic_sds_phy object. - The state is
+ * changed to the wait phy type event notification. none
+ */
+static void scic_sds_phy_starting_initial_substate_enter(void *object)
+{
+	struct scic_sds_phy *sci_phy = object;
+
+	scic_sds_phy_set_starting_substate_handlers(
+		sci_phy, SCIC_SDS_PHY_STARTING_SUBSTATE_INITIAL);
+
+	/* This is just an temporary state go off to the starting state */
+	sci_base_state_machine_change_state(&sci_phy->starting_substate_machine,
+					    SCIC_SDS_PHY_STARTING_SUBSTATE_AWAIT_OSSP_EN);
+}
+
+/**
+ *
+ * @object: This is the object which is cast to a struct scic_sds_phy object.
+ *
+ * This method will perform the actions required by the struct scic_sds_phy on
+ * entering the SCIC_SDS_PHY_STARTING_SUBSTATE_AWAIT_PHY_TYPE_EN. - Set the
+ * struct scic_sds_phy object state handlers for this state. none
+ */
+static void scic_sds_phy_starting_await_ossp_en_substate_enter(void *object)
+{
+	struct scic_sds_phy *sci_phy = object;
+
+	scic_sds_phy_set_starting_substate_handlers(
+		sci_phy, SCIC_SDS_PHY_STARTING_SUBSTATE_AWAIT_OSSP_EN
+		);
+}
+
+/**
+ *
+ * @object: This is the object which is cast to a struct scic_sds_phy object.
+ *
+ * This method will perform the actions required by the struct scic_sds_phy on
+ * entering the SCIC_SDS_PHY_STARTING_SUBSTATE_AWAIT_SPEED_EN. - Set the
+ * struct scic_sds_phy object state handlers for this state. none
+ */
+static void scic_sds_phy_starting_await_sas_speed_en_substate_enter(
+		void *object)
+{
+	struct scic_sds_phy *sci_phy = object;
+
+	scic_sds_phy_set_starting_substate_handlers(
+		sci_phy, SCIC_SDS_PHY_STARTING_SUBSTATE_AWAIT_SAS_SPEED_EN
+		);
+}
+
+/**
+ *
+ * @object: This is the object which is cast to a struct scic_sds_phy object.
+ *
+ * This method will perform the actions required by the struct scic_sds_phy on
+ * entering the SCIC_SDS_PHY_STARTING_SUBSTATE_AWAIT_IAF_UF. - Set the
+ * struct scic_sds_phy object state handlers for this state. none
+ */
+static void scic_sds_phy_starting_await_iaf_uf_substate_enter(void *object)
+{
+	struct scic_sds_phy *sci_phy = object;
+
+	scic_sds_phy_set_starting_substate_handlers(
+		sci_phy, SCIC_SDS_PHY_STARTING_SUBSTATE_AWAIT_IAF_UF
+		);
+}
+
+/**
+ *
+ * @object: This is the object which is cast to a struct scic_sds_phy object.
+ *
+ * This method will perform the actions required by the struct scic_sds_phy on
+ * entering the SCIC_SDS_PHY_STARTING_SUBSTATE_AWAIT_SAS_POWER. - Set the
+ * struct scic_sds_phy object state handlers for this state. - Add this phy object to
+ * the power control queue none
+ */
+static void scic_sds_phy_starting_await_sas_power_substate_enter(void *object)
+{
+	struct scic_sds_phy *sci_phy = object;
+
+	scic_sds_phy_set_starting_substate_handlers(
+		sci_phy, SCIC_SDS_PHY_STARTING_SUBSTATE_AWAIT_SAS_POWER
+		);
+
+	scic_sds_controller_power_control_queue_insert(
+		scic_sds_phy_get_controller(sci_phy),
+		sci_phy
+		);
+}
+
+/**
+ *
+ * @object: This is the object which is cast to a struct scic_sds_phy object.
+ *
+ * This method will perform the actions required by the struct scic_sds_phy on exiting
+ * the SCIC_SDS_PHY_STARTING_SUBSTATE_AWAIT_SAS_POWER. - Remove the
+ * struct scic_sds_phy object from the power control queue. none
+ */
+static void scic_sds_phy_starting_await_sas_power_substate_exit(void *object)
+{
+	struct scic_sds_phy *sci_phy = object;
+
+	scic_sds_controller_power_control_queue_remove(
+		scic_sds_phy_get_controller(sci_phy), sci_phy
+		);
+}
+
+/**
+ *
+ * @object: This is the object which is cast to a struct scic_sds_phy object.
+ *
+ * This method will perform the actions required by the struct scic_sds_phy on
+ * entering the SCIC_SDS_PHY_STARTING_SUBSTATE_AWAIT_SATA_POWER. - Set the
+ * struct scic_sds_phy object state handlers for this state. - Add this phy object to
+ * the power control queue none
+ */
+static void scic_sds_phy_starting_await_sata_power_substate_enter(void *object)
+{
+	struct scic_sds_phy *sci_phy = object;
+
+	scic_sds_phy_set_starting_substate_handlers(
+		sci_phy, SCIC_SDS_PHY_STARTING_SUBSTATE_AWAIT_SATA_POWER
+		);
+
+	scic_sds_controller_power_control_queue_insert(
+		scic_sds_phy_get_controller(sci_phy),
+		sci_phy
+		);
+}
+
+/**
+ *
+ * @object: This is the object which is cast to a struct scic_sds_phy object.
+ *
+ * This method will perform the actions required by the struct scic_sds_phy on exiting
+ * the SCIC_SDS_PHY_STARTING_SUBSTATE_AWAIT_SATA_POWER. - Remove the
+ * struct scic_sds_phy object from the power control queue. none
+ */
+static void scic_sds_phy_starting_await_sata_power_substate_exit(void *object)
+{
+	struct scic_sds_phy *sci_phy = object;
+
+	scic_sds_controller_power_control_queue_remove(
+		scic_sds_phy_get_controller(sci_phy),
+		sci_phy
+		);
+}
+
+/**
+ *
+ * @object: This is the object which is cast to a struct scic_sds_phy object.
+ *
+ * This function will perform the actions required by the struct scic_sds_phy on
+ * entering the SCIC_SDS_PHY_STARTING_SUBSTATE_AWAIT_SATA_PHY_EN. - Set the
+ * struct scic_sds_phy object state handlers for this state. none
+ */
+static void scic_sds_phy_starting_await_sata_phy_substate_enter(void *object)
+{
+	struct scic_sds_phy *sci_phy = object;
+
+	scic_sds_phy_set_starting_substate_handlers(
+			sci_phy,
+			SCIC_SDS_PHY_STARTING_SUBSTATE_AWAIT_SATA_PHY_EN);
+
+	isci_timer_start(sci_phy->sata_timeout_timer,
+			 SCIC_SDS_SATA_LINK_TRAINING_TIMEOUT);
+}
+
+/**
+ *
+ * @object: This is the object which is cast to a struct scic_sds_phy object.
+ *
+ * This method will perform the actions required by the struct scic_sds_phy
+ * on exiting
+ * the SCIC_SDS_PHY_STARTING_SUBSTATE_AWAIT_SATA_SPEED_EN. - stop the timer
+ * that was started on entry to await sata phy event notification none
+ */
+static inline void scic_sds_phy_starting_await_sata_phy_substate_exit(
+		void *object)
+{
+	struct scic_sds_phy *sci_phy = object;
+
+	isci_timer_stop(sci_phy->sata_timeout_timer);
+}
+
+/**
+ *
+ * @object: This is the object which is cast to a struct scic_sds_phy object.
+ *
+ * This method will perform the actions required by the struct scic_sds_phy on
+ * entering the SCIC_SDS_PHY_STARTING_SUBSTATE_AWAIT_SATA_SPEED_EN. - Set the
+ * struct scic_sds_phy object state handlers for this state. none
+ */
+static void scic_sds_phy_starting_await_sata_speed_substate_enter(void *object)
+{
+	struct scic_sds_phy *sci_phy = object;
+
+	scic_sds_phy_set_starting_substate_handlers(
+			sci_phy,
+			SCIC_SDS_PHY_STARTING_SUBSTATE_AWAIT_SATA_SPEED_EN);
+
+	isci_timer_start(sci_phy->sata_timeout_timer,
+			 SCIC_SDS_SATA_LINK_TRAINING_TIMEOUT);
+}
+
+/**
+ *
+ * @object: This is the object which is cast to a struct scic_sds_phy object.
+ *
+ * This function will perform the actions required by the
+ * struct scic_sds_phy on exiting
+ * the SCIC_SDS_PHY_STARTING_SUBSTATE_AWAIT_SATA_SPEED_EN. - stop the timer
+ * that was started on entry to await sata phy event notification none
+ */
+static inline void scic_sds_phy_starting_await_sata_speed_substate_exit(
+	void *object)
+{
+	struct scic_sds_phy *sci_phy = object;
+
+	isci_timer_stop(sci_phy->sata_timeout_timer);
+}
+
+/**
+ *
+ * @object: This is the object which is cast to a struct scic_sds_phy object.
+ *
+ * This function will perform the actions required by the struct scic_sds_phy on
+ * entering the SCIC_SDS_PHY_STARTING_SUBSTATE_AWAIT_SIG_FIS_UF. - Set the
+ * struct scic_sds_phy object state handlers for this state.
+ * - Start the SIGNATURE FIS
+ * timeout timer none
+ */
+static void scic_sds_phy_starting_await_sig_fis_uf_substate_enter(void *object)
+{
+	bool continue_to_ready_state;
+	struct scic_sds_phy *sci_phy = object;
+
+	scic_sds_phy_set_starting_substate_handlers(
+			sci_phy,
+			SCIC_SDS_PHY_STARTING_SUBSTATE_AWAIT_SIG_FIS_UF);
+
+	continue_to_ready_state = scic_sds_port_link_detected(
+		sci_phy->owning_port,
+		sci_phy);
+
+	if (continue_to_ready_state) {
+		/*
+		 * Clear the PE suspend condition so we can actually
+		 * receive SIG FIS
+		 * The hardware will not respond to the XRDY until the PE
+		 * suspend condition is cleared.
+		 */
+		scic_sds_phy_resume(sci_phy);
+
+		isci_timer_start(sci_phy->sata_timeout_timer,
+				 SCIC_SDS_SIGNATURE_FIS_TIMEOUT);
+	} else
+		sci_phy->is_in_link_training = false;
+}
+
+/**
+ *
+ * @object: This is the object which is cast to a struct scic_sds_phy object.
+ *
+ * This function will perform the actions required by the
+ * struct scic_sds_phy on exiting
+ * the SCIC_SDS_PHY_STARTING_SUBSTATE_AWAIT_SIG_FIS_UF. - Stop the SIGNATURE
+ * FIS timeout timer. none
+ */
+static inline void scic_sds_phy_starting_await_sig_fis_uf_substate_exit(
+	void *object)
+{
+	struct scic_sds_phy *sci_phy = object;
+
+	isci_timer_stop(sci_phy->sata_timeout_timer);
+}
+
+/**
+ *
+ * @object: This is the object which is cast to a struct scic_sds_phy object.
+ *
+ * This method will perform the actions required by the struct scic_sds_phy on
+ * entering the SCIC_SDS_PHY_STARTING_SUBSTATE_FINAL. - Set the struct scic_sds_phy
+ * object state handlers for this state. - Change base state machine to the
+ * ready state. none
+ */
+static void scic_sds_phy_starting_final_substate_enter(void *object)
+{
+	struct scic_sds_phy *sci_phy = object;
+
+	scic_sds_phy_set_starting_substate_handlers(sci_phy,
+						    SCIC_SDS_PHY_STARTING_SUBSTATE_FINAL);
+
+	/* State machine has run to completion so exit out and change
+	 * the base state machine to the ready state
+	 */
+	sci_base_state_machine_change_state(&sci_phy->state_machine,
+					    SCI_BASE_PHY_STATE_READY);
+}
+
+/* --------------------------------------------------------------------------- */
+
+static const struct sci_base_state scic_sds_phy_starting_substates[] = {
+	[SCIC_SDS_PHY_STARTING_SUBSTATE_INITIAL] = {
+		.enter_state = scic_sds_phy_starting_initial_substate_enter,
+	},
+	[SCIC_SDS_PHY_STARTING_SUBSTATE_AWAIT_OSSP_EN] = {
+		.enter_state = scic_sds_phy_starting_await_ossp_en_substate_enter,
+	},
+	[SCIC_SDS_PHY_STARTING_SUBSTATE_AWAIT_SAS_SPEED_EN] = {
+		.enter_state = scic_sds_phy_starting_await_sas_speed_en_substate_enter,
+	},
+	[SCIC_SDS_PHY_STARTING_SUBSTATE_AWAIT_IAF_UF] = {
+		.enter_state = scic_sds_phy_starting_await_iaf_uf_substate_enter,
+	},
+	[SCIC_SDS_PHY_STARTING_SUBSTATE_AWAIT_SAS_POWER] = {
+		.enter_state = scic_sds_phy_starting_await_sas_power_substate_enter,
+		.exit_state  = scic_sds_phy_starting_await_sas_power_substate_exit,
+	},
+	[SCIC_SDS_PHY_STARTING_SUBSTATE_AWAIT_SATA_POWER] = {
+		.enter_state = scic_sds_phy_starting_await_sata_power_substate_enter,
+		.exit_state  = scic_sds_phy_starting_await_sata_power_substate_exit
+	},
+	[SCIC_SDS_PHY_STARTING_SUBSTATE_AWAIT_SATA_PHY_EN] = {
+		.enter_state = scic_sds_phy_starting_await_sata_phy_substate_enter,
+		.exit_state  = scic_sds_phy_starting_await_sata_phy_substate_exit
+	},
+	[SCIC_SDS_PHY_STARTING_SUBSTATE_AWAIT_SATA_SPEED_EN] = {
+		.enter_state = scic_sds_phy_starting_await_sata_speed_substate_enter,
+		.exit_state  = scic_sds_phy_starting_await_sata_speed_substate_exit
+	},
+	[SCIC_SDS_PHY_STARTING_SUBSTATE_AWAIT_SIG_FIS_UF] = {
+		.enter_state = scic_sds_phy_starting_await_sig_fis_uf_substate_enter,
+		.exit_state  = scic_sds_phy_starting_await_sig_fis_uf_substate_exit
+	},
+	[SCIC_SDS_PHY_STARTING_SUBSTATE_FINAL] = {
+		.enter_state = scic_sds_phy_starting_final_substate_enter,
+	}
+};
+
+/*
+ * This method takes the struct scic_sds_phy from a stopped state and
+ * attempts to start it. - The phy state machine is transitioned to the
+ * SCI_BASE_PHY_STATE_STARTING. enum sci_status SCI_SUCCESS
+ */
+static enum sci_status
+scic_sds_phy_stopped_state_start_handler(struct scic_sds_phy *sci_phy)
+{
+	struct isci_host *ihost;
+	struct scic_sds_controller *scic;
+
+	scic = scic_sds_phy_get_controller(sci_phy),
+	ihost = scic_to_ihost(scic);
+
+	/* Create the SIGNATURE FIS Timeout timer for this phy */
+	sci_phy->sata_timeout_timer = isci_timer_create(ihost, sci_phy,
+							scic_sds_phy_sata_timeout);
+
+	if (sci_phy->sata_timeout_timer)
+		sci_base_state_machine_change_state(&sci_phy->state_machine,
+						    SCI_BASE_PHY_STATE_STARTING);
+
+	return SCI_SUCCESS;
+}
+
+static enum sci_status
+scic_sds_phy_stopped_state_destroy_handler(struct scic_sds_phy *sci_phy)
+{
+	return SCI_SUCCESS;
+}
+
+static enum sci_status
+scic_sds_phy_ready_state_stop_handler(struct scic_sds_phy *sci_phy)
+{
+	sci_base_state_machine_change_state(&sci_phy->state_machine,
+					    SCI_BASE_PHY_STATE_STOPPED);
+
+	return SCI_SUCCESS;
+}
+
+static enum sci_status
+scic_sds_phy_ready_state_reset_handler(struct scic_sds_phy *sci_phy)
+{
+	sci_base_state_machine_change_state(&sci_phy->state_machine,
+					    SCI_BASE_PHY_STATE_RESETTING);
+
+	return SCI_SUCCESS;
+}
+
+/**
+ * scic_sds_phy_ready_state_event_handler -
+ * @phy: This is the struct scic_sds_phy object which has received the event.
+ *
+ * This method request the struct scic_sds_phy handle the received event.  The only
+ * event that we are interested in while in the ready state is the link failure
+ * event. - decoded event is a link failure - transition the struct scic_sds_phy back
+ * to the SCI_BASE_PHY_STATE_STARTING state. - any other event received will
+ * report a warning message enum sci_status SCI_SUCCESS if the event received is a
+ * link failure SCI_FAILURE_INVALID_STATE for any other event received.
+ */
+static enum sci_status scic_sds_phy_ready_state_event_handler(struct scic_sds_phy *sci_phy,
+							      u32 event_code)
+{
+	enum sci_status result = SCI_FAILURE;
+
+	switch (scu_get_event_code(event_code)) {
+	case SCU_EVENT_LINK_FAILURE:
+		/* Link failure change state back to the starting state */
+		sci_base_state_machine_change_state(&sci_phy->state_machine,
+						    SCI_BASE_PHY_STATE_STARTING);
+		result = SCI_SUCCESS;
+		break;
+
+	case SCU_EVENT_BROADCAST_CHANGE:
+		/* Broadcast change received. Notify the port. */
+		if (scic_sds_phy_get_port(sci_phy) != NULL)
+			scic_sds_port_broadcast_change_received(sci_phy->owning_port, sci_phy);
+		else
+			sci_phy->bcn_received_while_port_unassigned = true;
+		break;
+
+	default:
+		dev_warn(sciphy_to_dev(sci_phy),
+			 "%sP SCIC PHY 0x%p ready state machine received "
+			 "unexpected event_code %x\n",
+			 __func__, sci_phy, event_code);
+
+		result = SCI_FAILURE_INVALID_STATE;
+		break;
+	}
+
+	return result;
+}
+
+static enum sci_status scic_sds_phy_resetting_state_event_handler(struct scic_sds_phy *sci_phy,
+								  u32 event_code)
+{
+	enum sci_status result = SCI_FAILURE;
+
+	switch (scu_get_event_code(event_code)) {
+	case SCU_EVENT_HARD_RESET_TRANSMITTED:
+		/* Link failure change state back to the starting state */
+		sci_base_state_machine_change_state(&sci_phy->state_machine,
+						    SCI_BASE_PHY_STATE_STARTING);
+		result = SCI_SUCCESS;
+		break;
+
+	default:
+		dev_warn(sciphy_to_dev(sci_phy),
+			 "%s: SCIC PHY 0x%p resetting state machine received "
+			 "unexpected event_code %x\n",
+			 __func__, sci_phy, event_code);
+
+		result = SCI_FAILURE_INVALID_STATE;
+		break;
+	}
+
+	return result;
+}
+
+/* --------------------------------------------------------------------------- */
+
+static const struct scic_sds_phy_state_handler scic_sds_phy_state_handler_table[] = {
+	[SCI_BASE_PHY_STATE_INITIAL] = {
+		.start_handler = scic_sds_phy_default_start_handler,
+		.stop_handler  = scic_sds_phy_default_stop_handler,
+		.reset_handler = scic_sds_phy_default_reset_handler,
+		.destruct_handler = scic_sds_phy_default_destroy_handler,
+		.frame_handler		 = scic_sds_phy_default_frame_handler,
+		.event_handler		 = scic_sds_phy_default_event_handler,
+		.consume_power_handler	 = scic_sds_phy_default_consume_power_handler
+	},
+	[SCI_BASE_PHY_STATE_STOPPED]  = {
+		.start_handler = scic_sds_phy_stopped_state_start_handler,
+		.stop_handler  = scic_sds_phy_default_stop_handler,
+		.reset_handler = scic_sds_phy_default_reset_handler,
+		.destruct_handler = scic_sds_phy_stopped_state_destroy_handler,
+		.frame_handler		 = scic_sds_phy_default_frame_handler,
+		.event_handler		 = scic_sds_phy_default_event_handler,
+		.consume_power_handler	 = scic_sds_phy_default_consume_power_handler
+	},
+	[SCI_BASE_PHY_STATE_STARTING] = {
+		.start_handler = scic_sds_phy_default_start_handler,
+		.stop_handler  = scic_sds_phy_default_stop_handler,
+		.reset_handler = scic_sds_phy_default_reset_handler,
+		.destruct_handler = scic_sds_phy_default_destroy_handler,
+		.frame_handler		 = scic_sds_phy_default_frame_handler,
+		.event_handler		 = scic_sds_phy_default_event_handler,
+		.consume_power_handler	 = scic_sds_phy_default_consume_power_handler
+	},
+	[SCI_BASE_PHY_STATE_READY] = {
+		.start_handler = scic_sds_phy_default_start_handler,
+		.stop_handler  = scic_sds_phy_ready_state_stop_handler,
+		.reset_handler = scic_sds_phy_ready_state_reset_handler,
+		.destruct_handler = scic_sds_phy_default_destroy_handler,
+		.frame_handler		 = scic_sds_phy_default_frame_handler,
+		.event_handler		 = scic_sds_phy_ready_state_event_handler,
+		.consume_power_handler	 = scic_sds_phy_default_consume_power_handler
+	},
+	[SCI_BASE_PHY_STATE_RESETTING] = {
+		.start_handler = scic_sds_phy_default_start_handler,
+		.stop_handler  = scic_sds_phy_default_stop_handler,
+		.reset_handler = scic_sds_phy_default_reset_handler,
+		.destruct_handler = scic_sds_phy_default_destroy_handler,
+		.frame_handler		 = scic_sds_phy_default_frame_handler,
+		.event_handler		 = scic_sds_phy_resetting_state_event_handler,
+		.consume_power_handler	 = scic_sds_phy_default_consume_power_handler
+	},
+	[SCI_BASE_PHY_STATE_FINAL] = {
+		.start_handler = scic_sds_phy_default_start_handler,
+		.stop_handler  = scic_sds_phy_default_stop_handler,
+		.reset_handler = scic_sds_phy_default_reset_handler,
+		.destruct_handler = scic_sds_phy_default_destroy_handler,
+		.frame_handler		 = scic_sds_phy_default_frame_handler,
+		.event_handler		 = scic_sds_phy_default_event_handler,
+		.consume_power_handler	 = scic_sds_phy_default_consume_power_handler
+	}
+};
+
+/*
+ * ****************************************************************************
+ * *  PHY STATE PRIVATE METHODS
+ * **************************************************************************** */
+
+/**
+ *
+ * @sci_phy: This is the struct scic_sds_phy object to stop.
+ *
+ * This method will stop the struct scic_sds_phy object. This does not reset the
+ * protocol engine it just suspends it and places it in a state where it will
+ * not cause the end device to power up. none
+ */
+static void scu_link_layer_stop_protocol_engine(
+	struct scic_sds_phy *sci_phy)
+{
+	u32 scu_sas_pcfg_value;
+	u32 enable_spinup_value;
+
+	/* Suspend the protocol engine and place it in a sata spinup hold state */
+	scu_sas_pcfg_value =
+		readl(&sci_phy->link_layer_registers->phy_configuration);
+	scu_sas_pcfg_value |=
+		(SCU_SAS_PCFG_GEN_BIT(OOB_RESET) |
+		 SCU_SAS_PCFG_GEN_BIT(SUSPEND_PROTOCOL_ENGINE) |
+		 SCU_SAS_PCFG_GEN_BIT(SATA_SPINUP_HOLD));
+	writel(scu_sas_pcfg_value,
+	       &sci_phy->link_layer_registers->phy_configuration);
+
+	/* Disable the notify enable spinup primitives */
+	enable_spinup_value = readl(&sci_phy->link_layer_registers->notify_enable_spinup_control);
+	enable_spinup_value &= ~SCU_ENSPINUP_GEN_BIT(ENABLE);
+	writel(enable_spinup_value, &sci_phy->link_layer_registers->notify_enable_spinup_control);
+}
+
+/**
+ *
+ *
+ * This method will start the OOB/SN state machine for this struct scic_sds_phy object.
+ */
+static void scu_link_layer_start_oob(
+	struct scic_sds_phy *sci_phy)
+{
+	u32 scu_sas_pcfg_value;
+
+	scu_sas_pcfg_value =
+		readl(&sci_phy->link_layer_registers->phy_configuration);
+	scu_sas_pcfg_value |= SCU_SAS_PCFG_GEN_BIT(OOB_ENABLE);
+	scu_sas_pcfg_value &=
+		~(SCU_SAS_PCFG_GEN_BIT(OOB_RESET) |
+		SCU_SAS_PCFG_GEN_BIT(HARD_RESET));
+	writel(scu_sas_pcfg_value,
+	       &sci_phy->link_layer_registers->phy_configuration);
+}
+
+/**
+ *
+ *
+ * This method will transmit a hard reset request on the specified phy. The SCU
+ * hardware requires that we reset the OOB state machine and set the hard reset
+ * bit in the phy configuration register. We then must start OOB over with the
+ * hard reset bit set.
+ */
+static void scu_link_layer_tx_hard_reset(
+	struct scic_sds_phy *sci_phy)
+{
+	u32 phy_configuration_value;
+
+	/*
+	 * SAS Phys must wait for the HARD_RESET_TX event notification to transition
+	 * to the starting state. */
+	phy_configuration_value =
+		readl(&sci_phy->link_layer_registers->phy_configuration);
+	phy_configuration_value |=
+		(SCU_SAS_PCFG_GEN_BIT(HARD_RESET) |
+		 SCU_SAS_PCFG_GEN_BIT(OOB_RESET));
+	writel(phy_configuration_value,
+	       &sci_phy->link_layer_registers->phy_configuration);
+
+	/* Now take the OOB state machine out of reset */
+	phy_configuration_value |= SCU_SAS_PCFG_GEN_BIT(OOB_ENABLE);
+	phy_configuration_value &= ~SCU_SAS_PCFG_GEN_BIT(OOB_RESET);
+	writel(phy_configuration_value,
+	       &sci_phy->link_layer_registers->phy_configuration);
+}
+
+/*
+ * ****************************************************************************
+ * *  PHY BASE STATE METHODS
+ * **************************************************************************** */
+
+/**
+ *
+ * @object: This is the object which is cast to a struct scic_sds_phy object.
+ *
+ * This method will perform the actions required by the struct scic_sds_phy on
+ * entering the SCI_BASE_PHY_STATE_INITIAL. - This function sets the state
+ * handlers for the phy object base state machine initial state. none
+ */
+static void scic_sds_phy_initial_state_enter(void *object)
+{
+	struct scic_sds_phy *sci_phy = object;
+
+	scic_sds_phy_set_base_state_handlers(sci_phy, SCI_BASE_PHY_STATE_INITIAL);
+}
+
+/**
+ *
+ * @object: This is the object which is cast to a struct scic_sds_phy object.
+ *
+ * This function will perform the actions required by the struct scic_sds_phy on
+ * entering the SCI_BASE_PHY_STATE_INITIAL. - This function sets the state
+ * handlers for the phy object base state machine initial state. - The SCU
+ * hardware is requested to stop the protocol engine. none
+ */
+static void scic_sds_phy_stopped_state_enter(void *object)
+{
+	struct scic_sds_phy *sci_phy = object;
+	struct scic_sds_controller *scic = scic_sds_phy_get_controller(sci_phy);
+	struct isci_host *ihost = scic_to_ihost(scic);
+
+	/*
+	 * @todo We need to get to the controller to place this PE in a
+	 * reset state
+	 */
+
+	scic_sds_phy_set_base_state_handlers(sci_phy,
+					     SCI_BASE_PHY_STATE_STOPPED);
+
+	if (sci_phy->sata_timeout_timer != NULL) {
+		isci_del_timer(ihost, sci_phy->sata_timeout_timer);
+
+		sci_phy->sata_timeout_timer = NULL;
+	}
+
+	scu_link_layer_stop_protocol_engine(sci_phy);
+
+	if (sci_phy->state_machine.previous_state_id !=
+			SCI_BASE_PHY_STATE_INITIAL)
+		scic_sds_controller_link_down(
+				scic_sds_phy_get_controller(sci_phy),
+				scic_sds_phy_get_port(sci_phy),
+				sci_phy);
+}
+
+/**
+ *
+ * @object: This is the object which is cast to a struct scic_sds_phy object.
+ *
+ * This method will perform the actions required by the struct scic_sds_phy on
+ * entering the SCI_BASE_PHY_STATE_STARTING. - This function sets the state
+ * handlers for the phy object base state machine starting state. - The SCU
+ * hardware is requested to start OOB/SN on this protocl engine. - The phy
+ * starting substate machine is started. - If the previous state was the ready
+ * state then the struct scic_sds_controller is informed that the phy has gone link
+ * down. none
+ */
+static void scic_sds_phy_starting_state_enter(void *object)
+{
+	struct scic_sds_phy *sci_phy = object;
+
+	scic_sds_phy_set_base_state_handlers(sci_phy, SCI_BASE_PHY_STATE_STARTING);
+
+	scu_link_layer_stop_protocol_engine(sci_phy);
+	scu_link_layer_start_oob(sci_phy);
+
+	/* We don't know what kind of phy we are going to be just yet */
+	sci_phy->protocol = SCIC_SDS_PHY_PROTOCOL_UNKNOWN;
+	sci_phy->bcn_received_while_port_unassigned = false;
+
+	/* Change over to the starting substate machine to continue */
+	sci_base_state_machine_start(&sci_phy->starting_substate_machine);
+
+	if (sci_phy->state_machine.previous_state_id
+	    == SCI_BASE_PHY_STATE_READY) {
+		scic_sds_controller_link_down(
+			scic_sds_phy_get_controller(sci_phy),
+			scic_sds_phy_get_port(sci_phy),
+			sci_phy
+			);
+	}
+}
+
+/**
+ *
+ * @object: This is the object which is cast to a struct scic_sds_phy object.
+ *
+ * This method will perform the actions required by the struct scic_sds_phy on
+ * entering the SCI_BASE_PHY_STATE_READY. - This function sets the state
+ * handlers for the phy object base state machine ready state. - The SCU
+ * hardware protocol engine is resumed. - The struct scic_sds_controller is informed
+ * that the phy object has gone link up. none
+ */
+static void scic_sds_phy_ready_state_enter(void *object)
+{
+	struct scic_sds_phy *sci_phy = object;
+
+	scic_sds_phy_set_base_state_handlers(sci_phy, SCI_BASE_PHY_STATE_READY);
+
+	scic_sds_controller_link_up(
+		scic_sds_phy_get_controller(sci_phy),
+		scic_sds_phy_get_port(sci_phy),
+		sci_phy
+		);
+}
+
+/**
+ *
+ * @object: This is the object which is cast to a struct scic_sds_phy object.
+ *
+ * This method will perform the actions required by the struct scic_sds_phy on exiting
+ * the SCI_BASE_PHY_STATE_INITIAL. This function suspends the SCU hardware
+ * protocol engine represented by this struct scic_sds_phy object. none
+ */
+static void scic_sds_phy_ready_state_exit(void *object)
+{
+	struct scic_sds_phy *sci_phy = object;
+
+	scic_sds_phy_suspend(sci_phy);
+}
+
+/**
+ *
+ * @object: This is the object which is cast to a struct scic_sds_phy object.
+ *
+ * This method will perform the actions required by the struct scic_sds_phy on
+ * entering the SCI_BASE_PHY_STATE_RESETTING. - This function sets the state
+ * handlers for the phy object base state machine resetting state. none
+ */
+static void scic_sds_phy_resetting_state_enter(void *object)
+{
+	struct scic_sds_phy *sci_phy = object;
+
+	scic_sds_phy_set_base_state_handlers(sci_phy, SCI_BASE_PHY_STATE_RESETTING);
+
+	/*
+	 * The phy is being reset, therefore deactivate it from the port.
+	 * In the resetting state we don't notify the user regarding
+	 * link up and link down notifications. */
+	scic_sds_port_deactivate_phy(sci_phy->owning_port, sci_phy, false);
+
+	if (sci_phy->protocol == SCIC_SDS_PHY_PROTOCOL_SAS) {
+		scu_link_layer_tx_hard_reset(sci_phy);
+	} else {
+		/*
+		 * The SCU does not need to have a discrete reset state so
+		 * just go back to the starting state.
+		 */
+		sci_base_state_machine_change_state(
+				&sci_phy->state_machine,
+				SCI_BASE_PHY_STATE_STARTING);
+	}
+}
+
+/**
+ *
+ * @object: This is the object which is cast to a struct scic_sds_phy object.
+ *
+ * This method will perform the actions required by the struct scic_sds_phy on
+ * entering the SCI_BASE_PHY_STATE_FINAL. - This function sets the state
+ * handlers for the phy object base state machine final state. none
+ */
+static void scic_sds_phy_final_state_enter(void *object)
+{
+	struct scic_sds_phy *sci_phy = object;
+
+	scic_sds_phy_set_base_state_handlers(sci_phy, SCI_BASE_PHY_STATE_FINAL);
+
+	/* Nothing to do here */
+}
+
+/* --------------------------------------------------------------------------- */
+
+static const struct sci_base_state scic_sds_phy_state_table[] = {
+	[SCI_BASE_PHY_STATE_INITIAL] = {
+		.enter_state = scic_sds_phy_initial_state_enter,
+	},
+	[SCI_BASE_PHY_STATE_STOPPED] = {
+		.enter_state = scic_sds_phy_stopped_state_enter,
+	},
+	[SCI_BASE_PHY_STATE_STARTING] = {
+		.enter_state = scic_sds_phy_starting_state_enter,
+	},
+	[SCI_BASE_PHY_STATE_READY] = {
+		.enter_state = scic_sds_phy_ready_state_enter,
+		.exit_state = scic_sds_phy_ready_state_exit,
+	},
+	[SCI_BASE_PHY_STATE_RESETTING] = {
+		.enter_state = scic_sds_phy_resetting_state_enter,
+	},
+	[SCI_BASE_PHY_STATE_FINAL] = {
+		.enter_state = scic_sds_phy_final_state_enter,
+	},
+};
+
+void scic_sds_phy_construct(struct scic_sds_phy *sci_phy,
+			    struct scic_sds_port *owning_port, u8 phy_index)
+{
+	sci_base_state_machine_construct(&sci_phy->state_machine,
+					 sci_phy,
+					 scic_sds_phy_state_table,
+					 SCI_BASE_PHY_STATE_INITIAL);
+
+	sci_base_state_machine_start(&sci_phy->state_machine);
+
+	/* Copy the rest of the input data to our locals */
+	sci_phy->owning_port = owning_port;
+	sci_phy->phy_index = phy_index;
+	sci_phy->bcn_received_while_port_unassigned = false;
+	sci_phy->protocol = SCIC_SDS_PHY_PROTOCOL_UNKNOWN;
+	sci_phy->link_layer_registers = NULL;
+	sci_phy->max_negotiated_speed = SAS_LINK_RATE_UNKNOWN;
+	sci_phy->sata_timeout_timer = NULL;
+
+	/* Initialize the the substate machines */
+	sci_base_state_machine_construct(&sci_phy->starting_substate_machine,
+					 sci_phy,
+					 scic_sds_phy_starting_substates,
+					 SCIC_SDS_PHY_STARTING_SUBSTATE_INITIAL);
+}
 
 void isci_phy_init(struct isci_phy *iphy, struct isci_host *ihost, int index)
 {

commit ce2b3261b6765c3b80fda95426c73e8d3bb1b035
Author: Dan Williams <dan.j.williams@intel.com>
Date:   Sun May 8 15:49:15 2011 -0700

    isci: unify constants
    
    cross driver constants are spread out over multiple header files, consolidate
    them into isci.h, and push some includes out to the source files that need
    them.
    
    TODO: remove SCI_MODE_SIZE infrastructure.
    TODO: task.h is full of inlines that are too large
    
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/drivers/scsi/isci/phy.c b/drivers/scsi/isci/phy.c
index 328004918329..1134395c970e 100644
--- a/drivers/scsi/isci/phy.c
+++ b/drivers/scsi/isci/phy.c
@@ -54,10 +54,10 @@
  */
 
 #include "isci.h"
+#include "host.h"
 #include "phy.h"
 #include "scic_port.h"
 #include "scic_config_parameters.h"
-#include "core/scic_sds_phy.h"
 
 struct scic_sds_phy;
 extern enum sci_status scic_sds_phy_start(struct scic_sds_phy *sci_phy);

commit 4b33981ade7cf723f3f32809e34192376c9a10f8
Author: Dan Williams <dan.j.williams@intel.com>
Date:   Fri May 6 17:36:38 2011 -0700

    isci: unify phy data structures
    
    Make scic_sds_phy a member of isci_phy and merge their lifetimes which
    means removing the phy table from scic_sds_controller in favor of the
    one at that isci_host level.
    
    Reported-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/drivers/scsi/isci/phy.c b/drivers/scsi/isci/phy.c
index 160790a0de0e..328004918329 100644
--- a/drivers/scsi/isci/phy.c
+++ b/drivers/scsi/isci/phy.c
@@ -63,61 +63,35 @@ struct scic_sds_phy;
 extern enum sci_status scic_sds_phy_start(struct scic_sds_phy *sci_phy);
 extern enum sci_status scic_sds_phy_stop(struct scic_sds_phy *sci_phy);
 
-/**
- * isci_phy_init() - This function is called by the probe function to
- *    initialize the phy objects. This func assumes that the isci_port objects
- *    associated with the SCU have been initialized.
- * @isci_phy: This parameter specifies the isci_phy object to initialize
- * @isci_host: This parameter specifies the parent SCU host object for this
- *    isci_phy
- * @index: This parameter specifies which SCU phy associates with this
- *    isci_phy. Generally, SCU phy 0 relates isci_phy 0, etc.
- *
- */
-void isci_phy_init(
-	struct isci_phy *phy,
-	struct isci_host *isci_host,
-	int index)
+void isci_phy_init(struct isci_phy *iphy, struct isci_host *ihost, int index)
 {
-	struct scic_sds_phy *scic_phy;
 	union scic_oem_parameters oem;
-	enum sci_status status = SCI_SUCCESS;
-	u64 sas_addr;
-
-	/*--------------- SCU_Phy Initialization Stuff -----------------------*/
-
-	status = scic_controller_get_phy_handle(&isci_host->sci, index, &scic_phy);
-	if (status == SCI_SUCCESS) {
-		phy->sci_phy_handle = scic_phy;
-		scic_phy->iphy = phy;
-	} else
-		dev_err(&isci_host->pdev->dev,
-			"failed scic_controller_get_phy_handle\n");
-
-	scic_oem_parameters_get(&isci_host->sci, &oem);
-	sas_addr = oem.sds1.phys[index].sas_address.high;
-	sas_addr <<= 32;
-	sas_addr |= oem.sds1.phys[index].sas_address.low;
-	swab64s(&sas_addr);
-
-	memcpy(phy->sas_addr, &sas_addr, sizeof(sas_addr));
-
-	phy->isci_port = NULL;
-	phy->sas_phy.enabled = 0;
-	phy->sas_phy.id = index;
-	phy->sas_phy.sas_addr = &phy->sas_addr[0];
-	phy->sas_phy.frame_rcvd = (u8 *)&phy->frame_rcvd;
-	phy->sas_phy.ha = &isci_host->sas_ha;
-	phy->sas_phy.lldd_phy = phy;
-	phy->sas_phy.enabled = 1;
-	phy->sas_phy.class = SAS;
-	phy->sas_phy.iproto = SAS_PROTOCOL_ALL;
-	phy->sas_phy.tproto = 0;
-	phy->sas_phy.type = PHY_TYPE_PHYSICAL;
-	phy->sas_phy.role = PHY_ROLE_INITIATOR;
-	phy->sas_phy.oob_mode = OOB_NOT_CONNECTED;
-	phy->sas_phy.linkrate = SAS_LINK_RATE_UNKNOWN;
-	memset((u8 *)&phy->frame_rcvd, 0, sizeof(phy->frame_rcvd));
+	u64 sci_sas_addr;
+	__be64 sas_addr;
+
+	scic_oem_parameters_get(&ihost->sci, &oem);
+	sci_sas_addr = oem.sds1.phys[index].sas_address.high;
+	sci_sas_addr <<= 32;
+	sci_sas_addr |= oem.sds1.phys[index].sas_address.low;
+	sas_addr = cpu_to_be64(sci_sas_addr);
+	memcpy(iphy->sas_addr, &sas_addr, sizeof(sas_addr));
+
+	iphy->isci_port = NULL;
+	iphy->sas_phy.enabled = 0;
+	iphy->sas_phy.id = index;
+	iphy->sas_phy.sas_addr = &iphy->sas_addr[0];
+	iphy->sas_phy.frame_rcvd = (u8 *)&iphy->frame_rcvd;
+	iphy->sas_phy.ha = &ihost->sas_ha;
+	iphy->sas_phy.lldd_phy = iphy;
+	iphy->sas_phy.enabled = 1;
+	iphy->sas_phy.class = SAS;
+	iphy->sas_phy.iproto = SAS_PROTOCOL_ALL;
+	iphy->sas_phy.tproto = 0;
+	iphy->sas_phy.type = PHY_TYPE_PHYSICAL;
+	iphy->sas_phy.role = PHY_ROLE_INITIATOR;
+	iphy->sas_phy.oob_mode = OOB_NOT_CONNECTED;
+	iphy->sas_phy.linkrate = SAS_LINK_RATE_UNKNOWN;
+	memset(&iphy->frame_rcvd, 0, sizeof(iphy->frame_rcvd));
 }
 
 
@@ -147,14 +121,14 @@ int isci_phy_control(struct asd_sas_phy *sas_phy,
 	switch (func) {
 	case PHY_FUNC_DISABLE:
 		spin_lock_irqsave(&ihost->scic_lock, flags);
-		scic_sds_phy_stop(iphy->sci_phy_handle);
+		scic_sds_phy_stop(&iphy->sci);
 		spin_unlock_irqrestore(&ihost->scic_lock, flags);
 		break;
 
 	case PHY_FUNC_LINK_RESET:
 		spin_lock_irqsave(&ihost->scic_lock, flags);
-		scic_sds_phy_stop(iphy->sci_phy_handle);
-		scic_sds_phy_start(iphy->sci_phy_handle);
+		scic_sds_phy_stop(&iphy->sci);
+		scic_sds_phy_start(&iphy->sci);
 		spin_unlock_irqrestore(&ihost->scic_lock, flags);
 		break;
 

commit cc3dbd0a9178865d4444f8e28b51715808e9ac85
Author: Artur Wojcik <artur.wojcik@intel.com>
Date:   Wed May 4 07:58:16 2011 +0000

    isci: unify isci_host data structures
    
    Make it explicit that isci_host and scic_sds_controller are one in the same
    object.
    
    Signed-off-by: Artur Wojcik <artur.wojcik@intel.com>
    [removed ->ihost back pointer]
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/drivers/scsi/isci/phy.c b/drivers/scsi/isci/phy.c
index a690b6b664f7..160790a0de0e 100644
--- a/drivers/scsi/isci/phy.c
+++ b/drivers/scsi/isci/phy.c
@@ -79,7 +79,6 @@ void isci_phy_init(
 	struct isci_host *isci_host,
 	int index)
 {
-	struct scic_sds_controller *scic = isci_host->core_controller;
 	struct scic_sds_phy *scic_phy;
 	union scic_oem_parameters oem;
 	enum sci_status status = SCI_SUCCESS;
@@ -87,7 +86,7 @@ void isci_phy_init(
 
 	/*--------------- SCU_Phy Initialization Stuff -----------------------*/
 
-	status = scic_controller_get_phy_handle(scic, index, &scic_phy);
+	status = scic_controller_get_phy_handle(&isci_host->sci, index, &scic_phy);
 	if (status == SCI_SUCCESS) {
 		phy->sci_phy_handle = scic_phy;
 		scic_phy->iphy = phy;
@@ -95,7 +94,7 @@ void isci_phy_init(
 		dev_err(&isci_host->pdev->dev,
 			"failed scic_controller_get_phy_handle\n");
 
-	scic_oem_parameters_get(scic, &oem);
+	scic_oem_parameters_get(&isci_host->sci, &oem);
 	sas_addr = oem.sds1.phys[index].sas_address.high;
 	sas_addr <<= 32;
 	sas_addr |= oem.sds1.phys[index].sas_address.low;

commit e1e72a00dd9db0cd2b7d106916645626f53c0382
Author: Maciej Patelczyk <maciej.patelczyk@intel.com>
Date:   Thu Apr 28 22:06:11 2011 +0000

    isci: Removed sci_base_object from scic_sds_phy.
    
    The 'struct sci_base_object' was removed from the struct
    scic_sds_phy and was replaced by a pointer to
    struct isci_phy.
    
    Signed-off-by: Maciej Patelczyk <maciej.patelczyk@intel.com>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/drivers/scsi/isci/phy.c b/drivers/scsi/isci/phy.c
index 9e081a4c8a3c..a690b6b664f7 100644
--- a/drivers/scsi/isci/phy.c
+++ b/drivers/scsi/isci/phy.c
@@ -57,6 +57,7 @@
 #include "phy.h"
 #include "scic_port.h"
 #include "scic_config_parameters.h"
+#include "core/scic_sds_phy.h"
 
 struct scic_sds_phy;
 extern enum sci_status scic_sds_phy_start(struct scic_sds_phy *sci_phy);
@@ -88,8 +89,8 @@ void isci_phy_init(
 
 	status = scic_controller_get_phy_handle(scic, index, &scic_phy);
 	if (status == SCI_SUCCESS) {
-		sci_object_set_association(scic_phy, (void *)phy);
 		phy->sci_phy_handle = scic_phy;
+		scic_phy->iphy = phy;
 	} else
 		dev_err(&isci_host->pdev->dev,
 			"failed scic_controller_get_phy_handle\n");

commit 4393aa4e6b9517a666f0ef6b774fd421a9dc4c68
Author: Dan Williams <dan.j.williams@intel.com>
Date:   Thu Mar 31 13:10:44 2011 -0700

    isci: fix fragile/conditional isci_host lookups
    
    A domain_device can always reference back to ->lldd_ha unlike local lldd
    structures.  Fix up cases where the driver uses local objects to look up the
    isci_host.  This also changes the calling conventions of some routines to
    expect a valid isci_host parameter rather than re-lookup the pointer on entry.
    
    Incidentally cleans up some macros that are longer to type than the open-coded
    equivalent:
      isci_host_from_sas_ha
      isci_dev_from_domain_dev
    
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/drivers/scsi/isci/phy.c b/drivers/scsi/isci/phy.c
index decc0c05a3dd..9e081a4c8a3c 100644
--- a/drivers/scsi/isci/phy.c
+++ b/drivers/scsi/isci/phy.c
@@ -163,7 +163,7 @@ int isci_phy_control(struct asd_sas_phy *sas_phy,
 			return -ENODEV;
 
 		/* Perform the port reset. */
-		ret = isci_port_perform_hard_reset(iport, iphy);
+		ret = isci_port_perform_hard_reset(ihost, iport, iphy);
 
 		break;
 

commit 4d07f7f367f2c2d5547684893e61a7a796c1547f
Author: Dave Jiang <dave.jiang@intel.com>
Date:   Wed Mar 2 12:31:24 2011 -0800

    isci: Adding support for phy enable and disable
    
    Adding support for PHY_FUNC_LINK_RESET and PHY_FUNC_DISABLE. This allow the
    sysfs knob enable (both 0 and 1) and link_reset to work properly.
    
    Signed-off-by: Dave Jiang <dave.jiang@intel.com>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/drivers/scsi/isci/phy.c b/drivers/scsi/isci/phy.c
index 1eefaaeb1141..decc0c05a3dd 100644
--- a/drivers/scsi/isci/phy.c
+++ b/drivers/scsi/isci/phy.c
@@ -58,6 +58,9 @@
 #include "scic_port.h"
 #include "scic_config_parameters.h"
 
+struct scic_sds_phy;
+extern enum sci_status scic_sds_phy_start(struct scic_sds_phy *sci_phy);
+extern enum sci_status scic_sds_phy_stop(struct scic_sds_phy *sci_phy);
 
 /**
  * isci_phy_init() - This function is called by the probe function to
@@ -127,42 +130,48 @@ void isci_phy_init(
  *
  * status, zero indicates success.
  */
-int isci_phy_control(
-	struct asd_sas_phy *phy,
-	enum phy_func func,
-	void *buf)
+int isci_phy_control(struct asd_sas_phy *sas_phy,
+		     enum phy_func func,
+		     void *buf)
 {
-	int ret            = TMF_RESP_FUNC_COMPLETE;
-	struct isci_phy *isci_phy_ptr  = (struct isci_phy *)phy->lldd_phy;
-	struct isci_port *isci_port_ptr = NULL;
-
-	if (isci_phy_ptr != NULL)
-		isci_port_ptr = isci_phy_ptr->isci_port;
-
-	if ((isci_phy_ptr == NULL) || (isci_port_ptr == NULL)) {
-		pr_err("%s: asd_sas_phy %p: lldd_phy %p or "
-		       "isci_port %p == NULL!\n",
-		       __func__, phy, isci_phy_ptr, isci_port_ptr);
-		return TMF_RESP_FUNC_FAILED;
-	}
+	int ret = 0;
+	struct isci_phy *iphy = sas_phy->lldd_phy;
+	struct isci_port *iport = iphy->isci_port;
+	struct isci_host *ihost = sas_phy->ha->lldd_ha;
+	unsigned long flags;
 
-	pr_debug("%s: phy %p; func %d; buf %p; isci phy %p, port %p\n",
-		 __func__, phy, func, buf, isci_phy_ptr, isci_port_ptr);
+	dev_dbg(&ihost->pdev->dev,
+		"%s: phy %p; func %d; buf %p; isci phy %p, port %p\n",
+		__func__, sas_phy, func, buf, iphy, iport);
 
 	switch (func) {
-	case PHY_FUNC_HARD_RESET:
+	case PHY_FUNC_DISABLE:
+		spin_lock_irqsave(&ihost->scic_lock, flags);
+		scic_sds_phy_stop(iphy->sci_phy_handle);
+		spin_unlock_irqrestore(&ihost->scic_lock, flags);
+		break;
+
 	case PHY_FUNC_LINK_RESET:
+		spin_lock_irqsave(&ihost->scic_lock, flags);
+		scic_sds_phy_stop(iphy->sci_phy_handle);
+		scic_sds_phy_start(iphy->sci_phy_handle);
+		spin_unlock_irqrestore(&ihost->scic_lock, flags);
+		break;
+
+	case PHY_FUNC_HARD_RESET:
+		if (!iport)
+			return -ENODEV;
 
 		/* Perform the port reset. */
-		ret = isci_port_perform_hard_reset(isci_port_ptr, isci_phy_ptr);
+		ret = isci_port_perform_hard_reset(iport, iphy);
 
 		break;
 
-	case PHY_FUNC_DISABLE:
 	default:
-		pr_debug("%s: phy %p; func %d NOT IMPLEMENTED!\n",
-			 __func__, phy, func);
-		ret = TMF_RESP_FUNC_FAILED;
+		dev_dbg(&ihost->pdev->dev,
+			   "%s: phy %p; func %d NOT IMPLEMENTED!\n",
+			   __func__, sas_phy, func);
+		ret = -ENOSYS;
 		break;
 	}
 	return ret;

commit 150fc6fc725055b400a8865e6785dc8dd0a2225d
Author: Dan Williams <dan.j.williams@intel.com>
Date:   Fri Feb 25 10:25:21 2011 -0800

    isci: fix sas address reporting
    
    Undo the open coded and incorrect translation of the oem parameter sas
    address to its libsas expected format.
    
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/drivers/scsi/isci/phy.c b/drivers/scsi/isci/phy.c
index fbda570d25e1..1eefaaeb1141 100644
--- a/drivers/scsi/isci/phy.c
+++ b/drivers/scsi/isci/phy.c
@@ -75,14 +75,15 @@ void isci_phy_init(
 	struct isci_host *isci_host,
 	int index)
 {
-	struct scic_sds_controller *controller = isci_host->core_controller;
+	struct scic_sds_controller *scic = isci_host->core_controller;
 	struct scic_sds_phy *scic_phy;
-	union scic_oem_parameters oem_parameters;
+	union scic_oem_parameters oem;
 	enum sci_status status = SCI_SUCCESS;
+	u64 sas_addr;
 
 	/*--------------- SCU_Phy Initialization Stuff -----------------------*/
 
-	status = scic_controller_get_phy_handle(controller, index, &scic_phy);
+	status = scic_controller_get_phy_handle(scic, index, &scic_phy);
 	if (status == SCI_SUCCESS) {
 		sci_object_set_association(scic_phy, (void *)phy);
 		phy->sci_phy_handle = scic_phy;
@@ -90,24 +91,13 @@ void isci_phy_init(
 		dev_err(&isci_host->pdev->dev,
 			"failed scic_controller_get_phy_handle\n");
 
-	scic_oem_parameters_get(controller, &oem_parameters);
-
-	phy->sas_addr[0] =  oem_parameters.sds1.phys[index].sas_address.low
-			   & 0xFF;
-	phy->sas_addr[1] = (oem_parameters.sds1.phys[index].sas_address.low
-			    >> 8)   & 0xFF;
-	phy->sas_addr[2] = (oem_parameters.sds1.phys[index].sas_address.low
-			    >> 16)  & 0xFF;
-	phy->sas_addr[3] = (oem_parameters.sds1.phys[index].sas_address.low
-			    >> 24)  & 0xFF;
-	phy->sas_addr[4] =  oem_parameters.sds1.phys[index].sas_address.high
-			   & 0xFF;
-	phy->sas_addr[5] = (oem_parameters.sds1.phys[index].sas_address.high
-			    >> 8)  & 0xFF;
-	phy->sas_addr[6] = (oem_parameters.sds1.phys[index].sas_address.high
-			    >> 16) & 0xFF;
-	phy->sas_addr[7] = (oem_parameters.sds1.phys[index].sas_address.high
-			    >> 24) & 0xFF;
+	scic_oem_parameters_get(scic, &oem);
+	sas_addr = oem.sds1.phys[index].sas_address.high;
+	sas_addr <<= 32;
+	sas_addr |= oem.sds1.phys[index].sas_address.low;
+	swab64s(&sas_addr);
+
+	memcpy(phy->sas_addr, &sas_addr, sizeof(sas_addr));
 
 	phy->isci_port = NULL;
 	phy->sas_phy.enabled = 0;

commit 6f231dda68080759f1aed3769896e94c73099f0f
Author: Dan Williams <dan.j.williams@intel.com>
Date:   Sat Jul 2 22:56:22 2011 -0700

    isci: Intel(R) C600 Series Chipset Storage Control Unit Driver
    
    Support for the up to 2x4-port 6Gb/s SAS controllers embedded in the
    chipset.
    
    This is a snapshot of the first publicly available version of the driver,
    commit 4c1db2d0 in the 'historical' branch.
    
       git://git.kernel.org/pub/scm/linux/kernel/git/djbw/isci.git historical
    
    Signed-off-by: Maciej Trela <maciej.trela@intel.com>
    Signed-off-by: Dave Jiang <dave.jiang@intel.com>
    Signed-off-by: Edmund Nadolski <edmund.nadolski@intel.com>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/drivers/scsi/isci/phy.c b/drivers/scsi/isci/phy.c
new file mode 100644
index 000000000000..fbda570d25e1
--- /dev/null
+++ b/drivers/scsi/isci/phy.c
@@ -0,0 +1,179 @@
+/*
+ * This file is provided under a dual BSD/GPLv2 license.  When using or
+ * redistributing this file, you may do so under either license.
+ *
+ * GPL LICENSE SUMMARY
+ *
+ * Copyright(c) 2008 - 2011 Intel Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
+ * The full GNU General Public License is included in this distribution
+ * in the file called LICENSE.GPL.
+ *
+ * BSD LICENSE
+ *
+ * Copyright(c) 2008 - 2011 Intel Corporation. All rights reserved.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ *   * Redistributions of source code must retain the above copyright
+ *     notice, this list of conditions and the following disclaimer.
+ *   * Redistributions in binary form must reproduce the above copyright
+ *     notice, this list of conditions and the following disclaimer in
+ *     the documentation and/or other materials provided with the
+ *     distribution.
+ *   * Neither the name of Intel Corporation nor the names of its
+ *     contributors may be used to endorse or promote products derived
+ *     from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include "isci.h"
+#include "phy.h"
+#include "scic_port.h"
+#include "scic_config_parameters.h"
+
+
+/**
+ * isci_phy_init() - This function is called by the probe function to
+ *    initialize the phy objects. This func assumes that the isci_port objects
+ *    associated with the SCU have been initialized.
+ * @isci_phy: This parameter specifies the isci_phy object to initialize
+ * @isci_host: This parameter specifies the parent SCU host object for this
+ *    isci_phy
+ * @index: This parameter specifies which SCU phy associates with this
+ *    isci_phy. Generally, SCU phy 0 relates isci_phy 0, etc.
+ *
+ */
+void isci_phy_init(
+	struct isci_phy *phy,
+	struct isci_host *isci_host,
+	int index)
+{
+	struct scic_sds_controller *controller = isci_host->core_controller;
+	struct scic_sds_phy *scic_phy;
+	union scic_oem_parameters oem_parameters;
+	enum sci_status status = SCI_SUCCESS;
+
+	/*--------------- SCU_Phy Initialization Stuff -----------------------*/
+
+	status = scic_controller_get_phy_handle(controller, index, &scic_phy);
+	if (status == SCI_SUCCESS) {
+		sci_object_set_association(scic_phy, (void *)phy);
+		phy->sci_phy_handle = scic_phy;
+	} else
+		dev_err(&isci_host->pdev->dev,
+			"failed scic_controller_get_phy_handle\n");
+
+	scic_oem_parameters_get(controller, &oem_parameters);
+
+	phy->sas_addr[0] =  oem_parameters.sds1.phys[index].sas_address.low
+			   & 0xFF;
+	phy->sas_addr[1] = (oem_parameters.sds1.phys[index].sas_address.low
+			    >> 8)   & 0xFF;
+	phy->sas_addr[2] = (oem_parameters.sds1.phys[index].sas_address.low
+			    >> 16)  & 0xFF;
+	phy->sas_addr[3] = (oem_parameters.sds1.phys[index].sas_address.low
+			    >> 24)  & 0xFF;
+	phy->sas_addr[4] =  oem_parameters.sds1.phys[index].sas_address.high
+			   & 0xFF;
+	phy->sas_addr[5] = (oem_parameters.sds1.phys[index].sas_address.high
+			    >> 8)  & 0xFF;
+	phy->sas_addr[6] = (oem_parameters.sds1.phys[index].sas_address.high
+			    >> 16) & 0xFF;
+	phy->sas_addr[7] = (oem_parameters.sds1.phys[index].sas_address.high
+			    >> 24) & 0xFF;
+
+	phy->isci_port = NULL;
+	phy->sas_phy.enabled = 0;
+	phy->sas_phy.id = index;
+	phy->sas_phy.sas_addr = &phy->sas_addr[0];
+	phy->sas_phy.frame_rcvd = (u8 *)&phy->frame_rcvd;
+	phy->sas_phy.ha = &isci_host->sas_ha;
+	phy->sas_phy.lldd_phy = phy;
+	phy->sas_phy.enabled = 1;
+	phy->sas_phy.class = SAS;
+	phy->sas_phy.iproto = SAS_PROTOCOL_ALL;
+	phy->sas_phy.tproto = 0;
+	phy->sas_phy.type = PHY_TYPE_PHYSICAL;
+	phy->sas_phy.role = PHY_ROLE_INITIATOR;
+	phy->sas_phy.oob_mode = OOB_NOT_CONNECTED;
+	phy->sas_phy.linkrate = SAS_LINK_RATE_UNKNOWN;
+	memset((u8 *)&phy->frame_rcvd, 0, sizeof(phy->frame_rcvd));
+}
+
+
+/**
+ * isci_phy_control() - This function is one of the SAS Domain Template
+ *    functions. This is a phy management function.
+ * @phy: This parameter specifies the sphy being controlled.
+ * @func: This parameter specifies the phy control function being invoked.
+ * @buf: This parameter is specific to the phy function being invoked.
+ *
+ * status, zero indicates success.
+ */
+int isci_phy_control(
+	struct asd_sas_phy *phy,
+	enum phy_func func,
+	void *buf)
+{
+	int ret            = TMF_RESP_FUNC_COMPLETE;
+	struct isci_phy *isci_phy_ptr  = (struct isci_phy *)phy->lldd_phy;
+	struct isci_port *isci_port_ptr = NULL;
+
+	if (isci_phy_ptr != NULL)
+		isci_port_ptr = isci_phy_ptr->isci_port;
+
+	if ((isci_phy_ptr == NULL) || (isci_port_ptr == NULL)) {
+		pr_err("%s: asd_sas_phy %p: lldd_phy %p or "
+		       "isci_port %p == NULL!\n",
+		       __func__, phy, isci_phy_ptr, isci_port_ptr);
+		return TMF_RESP_FUNC_FAILED;
+	}
+
+	pr_debug("%s: phy %p; func %d; buf %p; isci phy %p, port %p\n",
+		 __func__, phy, func, buf, isci_phy_ptr, isci_port_ptr);
+
+	switch (func) {
+	case PHY_FUNC_HARD_RESET:
+	case PHY_FUNC_LINK_RESET:
+
+		/* Perform the port reset. */
+		ret = isci_port_perform_hard_reset(isci_port_ptr, isci_phy_ptr);
+
+		break;
+
+	case PHY_FUNC_DISABLE:
+	default:
+		pr_debug("%s: phy %p; func %d NOT IMPLEMENTED!\n",
+			 __func__, phy, func);
+		ret = TMF_RESP_FUNC_FAILED;
+		break;
+	}
+	return ret;
+}
