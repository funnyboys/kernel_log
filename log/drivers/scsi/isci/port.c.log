commit b0a2dc66152aa409860e02804169b0007244ebd7
Author: Kees Cook <keescook@chromium.org>
Date:   Fri Sep 1 23:21:24 2017 -0700

    scsi: isci: Convert timers to use timer_setup()
    
    In preparation for unconditionally passing the struct timer_list pointer to
    all timer callbacks, switch to using the new timer_setup() and from_timer()
    to pass the timer pointer explicitly.
    
    Cc: Intel SCU Linux support <intel-linux-scu@intel.com>
    Cc: Artur Paszkiewicz <artur.paszkiewicz@intel.com>
    Cc: "James E.J. Bottomley" <jejb@linux.vnet.ibm.com>
    Cc: "Martin K. Petersen" <martin.petersen@oracle.com>
    Cc: linux-scsi@vger.kernel.org
    Signed-off-by: Kees Cook <keescook@chromium.org>
    Reviewed-by: Artur Paszkiewicz <artur.paszkiewicz@intel.com>

diff --git a/drivers/scsi/isci/port.c b/drivers/scsi/isci/port.c
index a4dd5c91508c..1df45f028ea7 100644
--- a/drivers/scsi/isci/port.c
+++ b/drivers/scsi/isci/port.c
@@ -769,9 +769,9 @@ bool sci_port_link_detected(struct isci_port *iport, struct isci_phy *iphy)
 	return true;
 }
 
-static void port_timeout(unsigned long data)
+static void port_timeout(struct timer_list *t)
 {
-	struct sci_timer *tmr = (struct sci_timer *)data;
+	struct sci_timer *tmr = from_timer(tmr, t, timer);
 	struct isci_port *iport = container_of(tmr, typeof(*iport), timer);
 	struct isci_host *ihost = iport->owning_controller;
 	unsigned long flags;

commit c19ca6cb4c0891049009d48a0da79d9e8c475462
Author: Masanari Iida <standby24x7@gmail.com>
Date:   Mon Feb 8 20:53:12 2016 +0900

    treewide: Fix typos in printk
    
    This patch fix spelling typos found in printk
    within various part of the kernel sources.
    
    Signed-off-by: Masanari Iida <standby24x7@gmail.com>
    Acked-by: Randy Dunlap <rdunlap@infradead.org>
    Signed-off-by: Jiri Kosina <jkosina@suse.cz>

diff --git a/drivers/scsi/isci/port.c b/drivers/scsi/isci/port.c
index 13098b09a824..a4dd5c91508c 100644
--- a/drivers/scsi/isci/port.c
+++ b/drivers/scsi/isci/port.c
@@ -794,7 +794,7 @@ static void port_timeout(unsigned long data)
 		 * case stay in the stopped state.
 		 */
 		dev_err(sciport_to_dev(iport),
-			"%s: SCIC Port 0x%p failed to stop before tiemout.\n",
+			"%s: SCIC Port 0x%p failed to stop before timeout.\n",
 			__func__,
 			iport);
 	} else if (current_state == SCI_PORT_STOPPING) {

commit 59e13d48334c38a73aec1759fe9a13eb4e476bf6
Author: Masanari Iida <standby24x7@gmail.com>
Date:   Wed Apr 25 00:24:16 2012 +0900

    scsi: fix various printk and comment typos
    
    Correct spelling typo within drivers/scsi
    
    Signed-off-by: Masanari Iida <standby24x7@gmail.com>
    Signed-off-by: Jiri Kosina <jkosina@suse.cz>

diff --git a/drivers/scsi/isci/port.c b/drivers/scsi/isci/port.c
index 2fb85bf75449..13098b09a824 100644
--- a/drivers/scsi/isci/port.c
+++ b/drivers/scsi/isci/port.c
@@ -212,7 +212,7 @@ static void isci_port_link_up(struct isci_host *isci_host,
 		memcpy(iphy->sas_phy.attached_sas_addr,
 		       iphy->frame_rcvd.iaf.sas_addr, SAS_ADDR_SIZE);
 	} else {
-		dev_err(&isci_host->pdev->dev, "%s: unkown target\n", __func__);
+		dev_err(&isci_host->pdev->dev, "%s: unknown target\n", __func__);
 		success = false;
 	}
 

commit 397497dd61948b0d59d1d21812b93c97b0eeb2dd
Author: Jeff Skirvin <jeffrey.d.skirvin@intel.com>
Date:   Sat Mar 10 05:46:46 2012 +0000

    isci: Check IDEV_GONE before performing abort path operations.
    
    In the link fail path, set IDEV_GONE for every device on the domain
    when the last link in the port fails.
    
    In the abort path functions like isci_reset_device, make sure that
    there has not already been a detected domain failure with the device
    by checking IDEV_GONE, before performing any kind of hard reset, SMP
    phy control, or TMF operation.
    
    The check for IDEV_GONE makes sure that the device in the abort path
    really has control of the port with which it is associated.  This
    prevents starting hard resets at incorrect times and scheduling
    unnecessary LUN resets for SATA devices.
    
    Signed-off-by: Jeff Skirvin <jeffrey.d.skirvin@intel.com>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/drivers/scsi/isci/port.c b/drivers/scsi/isci/port.c
index da0c4e1b9b30..2fb85bf75449 100644
--- a/drivers/scsi/isci/port.c
+++ b/drivers/scsi/isci/port.c
@@ -240,9 +240,32 @@ static void isci_port_link_down(struct isci_host *isci_host,
 				struct isci_phy *isci_phy,
 				struct isci_port *isci_port)
 {
+	struct isci_remote_device *isci_device;
+
 	dev_dbg(&isci_host->pdev->dev,
 		"%s: isci_port = %p\n", __func__, isci_port);
 
+	if (isci_port) {
+
+		/* check to see if this is the last phy on this port. */
+		if (isci_phy->sas_phy.port &&
+		    isci_phy->sas_phy.port->num_phys == 1) {
+			/* change the state for all devices on this port.  The
+			* next task sent to this device will be returned as
+			* SAS_TASK_UNDELIVERED, and the scsi mid layer will
+			* remove the target
+			*/
+			list_for_each_entry(isci_device,
+					    &isci_port->remote_dev_list,
+					    node) {
+				dev_dbg(&isci_host->pdev->dev,
+					"%s: isci_device = %p\n",
+					__func__, isci_device);
+				set_bit(IDEV_GONE, &isci_device->flags);
+			}
+		}
+	}
+
 	/* Notify libsas of the borken link, this will trigger calls to our
 	 * isci_port_deformed and isci_dev_gone functions.
 	 */

commit 033751f6643adf616b85ac5eea7ce784bdde1b50
Author: Jeff Skirvin <jeffrey.d.skirvin@intel.com>
Date:   Thu Mar 8 22:41:56 2012 -0800

    isci: Only set IDEV_GONE in the device stop path.
    
    Signed-off-by: Jeff Skirvin <jeffrey.d.skirvin@intel.com>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/drivers/scsi/isci/port.c b/drivers/scsi/isci/port.c
index f1866b0dc195..da0c4e1b9b30 100644
--- a/drivers/scsi/isci/port.c
+++ b/drivers/scsi/isci/port.c
@@ -240,32 +240,9 @@ static void isci_port_link_down(struct isci_host *isci_host,
 				struct isci_phy *isci_phy,
 				struct isci_port *isci_port)
 {
-	struct isci_remote_device *isci_device;
-
 	dev_dbg(&isci_host->pdev->dev,
 		"%s: isci_port = %p\n", __func__, isci_port);
 
-	if (isci_port) {
-
-		/* check to see if this is the last phy on this port. */
-		if (isci_phy->sas_phy.port &&
-		    isci_phy->sas_phy.port->num_phys == 1) {
-			/* change the state for all devices on this port.  The
-			 * next task sent to this device will be returned as
-			 * SAS_TASK_UNDELIVERED, and the scsi mid layer will
-			 * remove the target
-			 */
-			list_for_each_entry(isci_device,
-					    &isci_port->remote_dev_list,
-					    node) {
-				dev_dbg(&isci_host->pdev->dev,
-					"%s: isci_device = %p\n",
-					__func__, isci_device);
-				set_bit(IDEV_GONE, &isci_device->flags);
-			}
-		}
-	}
-
 	/* Notify libsas of the borken link, this will trigger calls to our
 	 * isci_port_deformed and isci_dev_gone functions.
 	 */

commit 59e35396436c564b5019e1a70073900bc3e19f4f
Author: Jeff Skirvin <jeffrey.d.skirvin@intel.com>
Date:   Thu Mar 8 22:41:54 2012 -0800

    isci: Add suspension cases for RNC INVALIDATING, POSTING states.
    
    The RNC can be any of the states in the loop from suspended to
    ready when the API "suspend" or "resume" are called.  This change
    adds destination states parameters that control the suspension /
    resumption action of the RNC statemachine for those transition states.
    
    Signed-off-by: Jeff Skirvin <jeffrey.d.skirvin@intel.com>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/drivers/scsi/isci/port.c b/drivers/scsi/isci/port.c
index ed206c5a00a6..f1866b0dc195 100644
--- a/drivers/scsi/isci/port.c
+++ b/drivers/scsi/isci/port.c
@@ -1688,17 +1688,6 @@ int isci_port_perform_hard_reset(struct isci_host *ihost, struct isci_port *ipor
 			__func__, iport, status);
 
 	}
-
-	/* If the hard reset for the port has failed, consider this
-	 * the same as link failures on all phys in the port.
-	 */
-	if (ret != TMF_RESP_FUNC_COMPLETE) {
-
-		dev_err(&ihost->pdev->dev,
-			"%s: iport = %p; hard reset failed "
-			"(0x%x) - driving explicit link fail for all phys\n",
-			__func__, iport, iport->hard_reset_status);
-	}
 	return ret;
 }
 

commit 6f48844e3f16b7d8a1f9a1a11bd9a11089a5292f
Author: Jeff Skirvin <jeffrey.d.skirvin@intel.com>
Date:   Thu Mar 8 22:41:48 2012 -0800

    isci: Manage the link layer hang detect timer for RNC suspensions.
    
    For STP devices under certain protocol conditions, an RNC will not
    suspend until the current transfer state is broken with a SYNC/ESC
    sequence from the SCU.  The SYNC/ESC driven by expiration of the
    SCU link layer hang detect timer, which has too small a dynamic
    range to support slow SATA devices, so normally it is disabled.
    
    This change enables the timer with the minimum period at the point
    when the suspension is requested.
    
    Note that there is potential collateral damage to other open
    connections to slow SATA devices on the same port, since there
    is no alternative but to enable the LLHANG timer on every phy in
    the port for the current suspension request - there is no way to
    tell on which phy the RNC in question is currently active.
    
    Signed-off-by: Jeff Skirvin <jeffrey.d.skirvin@intel.com>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/drivers/scsi/isci/port.c b/drivers/scsi/isci/port.c
index 0a3aec118097..ed206c5a00a6 100644
--- a/drivers/scsi/isci/port.c
+++ b/drivers/scsi/isci/port.c
@@ -1548,6 +1548,29 @@ static void sci_port_failed_state_enter(struct sci_base_state_machine *sm)
 	isci_port_hard_reset_complete(iport, SCI_FAILURE_TIMEOUT);
 }
 
+void sci_port_set_hang_detection_timeout(struct isci_port *iport, u32 timeout)
+{
+	int phy_index;
+	u32 phy_mask = iport->active_phy_mask;
+
+	if (timeout)
+		++iport->hang_detect_users;
+	else if (iport->hang_detect_users > 1)
+		--iport->hang_detect_users;
+	else
+		iport->hang_detect_users = 0;
+
+	if (timeout || (iport->hang_detect_users == 0)) {
+		for (phy_index = 0; phy_index < SCI_MAX_PHYS; phy_index++) {
+			if ((phy_mask >> phy_index) & 1) {
+				writel(timeout,
+				       &iport->phy_table[phy_index]
+					  ->link_layer_registers
+					  ->link_layer_hang_detection_timeout);
+			}
+		}
+	}
+}
 /* --------------------------------------------------------------------------- */
 
 static const struct sci_base_state sci_port_state_table[] = {
@@ -1596,6 +1619,7 @@ void sci_port_construct(struct isci_port *iport, u8 index,
 
 	iport->started_request_count = 0;
 	iport->assigned_device_count = 0;
+	iport->hang_detect_users = 0;
 
 	iport->reserved_rni = SCU_DUMMY_INDEX;
 	iport->reserved_tag = SCI_CONTROLLER_INVALID_IO_TAG;
@@ -1733,7 +1757,7 @@ void isci_port_formed(struct asd_sas_phy *phy)
 	struct isci_host *ihost = phy->ha->lldd_ha;
 	struct isci_phy *iphy = to_iphy(phy);
 	struct asd_sas_port *port = phy->port;
-	struct isci_port *iport;
+	struct isci_port *iport = NULL;
 	unsigned long flags;
 	int i;
 

commit 08e73be56b6b2e5459638481a54b755ed562ada8
Author: Maciej Trela <maciej.trela@intel.com>
Date:   Mon Mar 12 23:29:30 2012 +0000

    isci: enable BCN in sci_port_add_phy()
    
    Ensure we enable receiving BCN's from the
    hardware when adding phy to isci_port.
    Otherwise if we get BCN before the port is
    created we won't see any BCN
    
    Signed-off-by: Maciej Trela <maciej.trela@intel.com>
    Reported-by: Richard Boyd <richard.g.boyd@intel.com>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/drivers/scsi/isci/port.c b/drivers/scsi/isci/port.c
index 6ef4bd910f33..0a3aec118097 100644
--- a/drivers/scsi/isci/port.c
+++ b/drivers/scsi/isci/port.c
@@ -1199,6 +1199,8 @@ enum sci_status sci_port_add_phy(struct isci_port *iport,
 	enum sci_status status;
 	enum sci_port_states state;
 
+	sci_port_bcn_enable(iport);
+
 	state = iport->sm.current_state_id;
 	switch (state) {
 	case SCI_PORT_STOPPED: {

commit ae904d15cf344bcb426f63982016f6bacc45825b
Author: Dan Williams <dan.j.williams@intel.com>
Date:   Fri Feb 17 16:30:47 2012 -0800

    isci: kill isci_port.domain_dev_list
    
    Another unused field, and isci_port_init is overkill.
    
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/drivers/scsi/isci/port.c b/drivers/scsi/isci/port.c
index 923579fa0292..6ef4bd910f33 100644
--- a/drivers/scsi/isci/port.c
+++ b/drivers/scsi/isci/port.c
@@ -1606,13 +1606,6 @@ void sci_port_construct(struct isci_port *iport, u8 index,
 		iport->phy_table[index] = NULL;
 }
 
-void isci_port_init(struct isci_port *iport, struct isci_host *ihost, int index)
-{
-	INIT_LIST_HEAD(&iport->remote_dev_list);
-	INIT_LIST_HEAD(&iport->domain_dev_list);
-	iport->isci_host = ihost;
-}
-
 void sci_port_broadcast_change_received(struct isci_port *iport, struct isci_phy *iphy)
 {
 	struct isci_host *ihost = iport->owning_controller;

commit c79dd80d73017a88a2c2ae46e7d5303cba6a32e0
Author: Dan Williams <dan.j.williams@intel.com>
Date:   Wed Feb 1 00:44:14 2012 -0800

    isci: kill sci_phy_protocol and sci_request_protocol
    
    Holdovers from the initial driver cleanup, replace with enum sas_protocol.
    
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/drivers/scsi/isci/port.c b/drivers/scsi/isci/port.c
index 5fada73b71ff..923579fa0292 100644
--- a/drivers/scsi/isci/port.c
+++ b/drivers/scsi/isci/port.c
@@ -184,7 +184,7 @@ static void isci_port_link_up(struct isci_host *isci_host,
 
 	sci_port_get_properties(iport, &properties);
 
-	if (iphy->protocol == SCIC_SDS_PHY_PROTOCOL_SATA) {
+	if (iphy->protocol == SAS_PROTOCOL_SATA) {
 		u64 attached_sas_address;
 
 		iphy->sas_phy.oob_mode = SATA_OOB_MODE;
@@ -204,7 +204,7 @@ static void isci_port_link_up(struct isci_host *isci_host,
 
 		memcpy(&iphy->sas_phy.attached_sas_addr,
 		       &attached_sas_address, sizeof(attached_sas_address));
-	} else if (iphy->protocol == SCIC_SDS_PHY_PROTOCOL_SAS) {
+	} else if (iphy->protocol == SAS_PROTOCOL_SSP) {
 		iphy->sas_phy.oob_mode = SAS_OOB_MODE;
 		iphy->sas_phy.frame_rcvd_size = sizeof(struct sas_identify_frame);
 
@@ -517,7 +517,7 @@ void sci_port_get_attached_sas_address(struct isci_port *iport, struct sci_sas_a
 	 */
 	iphy = sci_port_get_a_connected_phy(iport);
 	if (iphy) {
-		if (iphy->protocol != SCIC_SDS_PHY_PROTOCOL_SATA) {
+		if (iphy->protocol != SAS_PROTOCOL_SATA) {
 			sci_phy_get_attached_sas_address(iphy, sas);
 		} else {
 			sci_phy_get_sas_address(iphy, sas);
@@ -624,7 +624,7 @@ static void sci_port_activate_phy(struct isci_port *iport,
 {
 	struct isci_host *ihost = iport->owning_controller;
 
-	if (iphy->protocol != SCIC_SDS_PHY_PROTOCOL_SATA && (flags & PF_RESUME))
+	if (iphy->protocol != SAS_PROTOCOL_SATA && (flags & PF_RESUME))
 		sci_phy_resume(iphy);
 
 	iport->active_phy_mask |= 1 << iphy->phy_index;
@@ -751,12 +751,10 @@ static bool sci_port_is_wide(struct isci_port *iport)
  * wide ports and direct attached phys.  Since there are no wide ported SATA
  * devices this could become an invalid port configuration.
  */
-bool sci_port_link_detected(
-	struct isci_port *iport,
-	struct isci_phy *iphy)
+bool sci_port_link_detected(struct isci_port *iport, struct isci_phy *iphy)
 {
 	if ((iport->logical_port_index != SCIC_SDS_DUMMY_PORT) &&
-	    (iphy->protocol == SCIC_SDS_PHY_PROTOCOL_SATA)) {
+	    (iphy->protocol == SAS_PROTOCOL_SATA)) {
 		if (sci_port_is_wide(iport)) {
 			sci_port_invalid_link_up(iport, iphy);
 			return false;

commit d7a0ccdd9bd78b5b74d2963ec7ab67c9d896902a
Author: Dan Williams <dan.j.williams@intel.com>
Date:   Fri Feb 10 01:18:44 2012 -0800

    [SCSI] isci: debug, provide state-enum-to-string conversions
    
    Debugging the driver requires tracing the state transtions and tracing
    state names is less work than decoding numbers.
    
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>
    Signed-off-by: James Bottomley <JBottomley@Parallels.com>

diff --git a/drivers/scsi/isci/port.c b/drivers/scsi/isci/port.c
index c5ae94dbef48..5fada73b71ff 100644
--- a/drivers/scsi/isci/port.c
+++ b/drivers/scsi/isci/port.c
@@ -60,6 +60,16 @@
 #define SCIC_SDS_PORT_HARD_RESET_TIMEOUT  (1000)
 #define SCU_DUMMY_INDEX    (0xFFFF)
 
+#undef C
+#define C(a) (#a)
+const char *port_state_name(enum sci_port_states state)
+{
+	static const char * const strings[] = PORT_STATES;
+
+	return strings[state];
+}
+#undef C
+
 static struct device *sciport_to_dev(struct isci_port *iport)
 {
 	int i = iport->physical_port_index;
@@ -1054,8 +1064,8 @@ enum sci_status sci_port_start(struct isci_port *iport)
 
 	state = iport->sm.current_state_id;
 	if (state != SCI_PORT_STOPPED) {
-		dev_warn(sciport_to_dev(iport),
-			 "%s: in wrong state: %d\n", __func__, state);
+		dev_warn(sciport_to_dev(iport), "%s: in wrong state: %s\n",
+			 __func__, port_state_name(state));
 		return SCI_FAILURE_INVALID_STATE;
 	}
 
@@ -1129,8 +1139,8 @@ enum sci_status sci_port_stop(struct isci_port *iport)
 					  SCI_PORT_STOPPING);
 		return SCI_SUCCESS;
 	default:
-		dev_warn(sciport_to_dev(iport),
-			 "%s: in wrong state: %d\n", __func__, state);
+		dev_warn(sciport_to_dev(iport), "%s: in wrong state: %s\n",
+			 __func__, port_state_name(state));
 		return SCI_FAILURE_INVALID_STATE;
 	}
 }
@@ -1144,8 +1154,8 @@ static enum sci_status sci_port_hard_reset(struct isci_port *iport, u32 timeout)
 
 	state = iport->sm.current_state_id;
 	if (state != SCI_PORT_SUB_OPERATIONAL) {
-		dev_warn(sciport_to_dev(iport),
-			 "%s: in wrong state: %d\n", __func__, state);
+		dev_warn(sciport_to_dev(iport), "%s: in wrong state: %s\n",
+			 __func__, port_state_name(state));
 		return SCI_FAILURE_INVALID_STATE;
 	}
 
@@ -1239,8 +1249,8 @@ enum sci_status sci_port_add_phy(struct isci_port *iport,
 					  SCI_PORT_SUB_CONFIGURING);
 		return SCI_SUCCESS;
 	default:
-		dev_warn(sciport_to_dev(iport),
-			 "%s: in wrong state: %d\n", __func__, state);
+		dev_warn(sciport_to_dev(iport), "%s: in wrong state: %s\n",
+			 __func__, port_state_name(state));
 		return SCI_FAILURE_INVALID_STATE;
 	}
 }
@@ -1289,8 +1299,8 @@ enum sci_status sci_port_remove_phy(struct isci_port *iport,
 					  SCI_PORT_SUB_CONFIGURING);
 		return SCI_SUCCESS;
 	default:
-		dev_warn(sciport_to_dev(iport),
-			 "%s: in wrong state: %d\n", __func__, state);
+		dev_warn(sciport_to_dev(iport), "%s: in wrong state: %s\n",
+			 __func__, port_state_name(state));
 		return SCI_FAILURE_INVALID_STATE;
 	}
 }
@@ -1332,8 +1342,8 @@ enum sci_status sci_port_link_up(struct isci_port *iport,
 		sci_port_general_link_up_handler(iport, iphy, PF_RESUME);
 		return SCI_SUCCESS;
 	default:
-		dev_warn(sciport_to_dev(iport),
-			 "%s: in wrong state: %d\n", __func__, state);
+		dev_warn(sciport_to_dev(iport), "%s: in wrong state: %s\n",
+			 __func__, port_state_name(state));
 		return SCI_FAILURE_INVALID_STATE;
 	}
 }
@@ -1362,8 +1372,8 @@ enum sci_status sci_port_link_down(struct isci_port *iport,
 		sci_port_deactivate_phy(iport, iphy, false);
 		return SCI_SUCCESS;
 	default:
-		dev_warn(sciport_to_dev(iport),
-			 "%s: in wrong state: %d\n", __func__, state);
+		dev_warn(sciport_to_dev(iport), "%s: in wrong state: %s\n",
+			 __func__, port_state_name(state));
 		return SCI_FAILURE_INVALID_STATE;
 	}
 }
@@ -1382,8 +1392,8 @@ enum sci_status sci_port_start_io(struct isci_port *iport,
 		iport->started_request_count++;
 		return SCI_SUCCESS;
 	default:
-		dev_warn(sciport_to_dev(iport),
-			 "%s: in wrong state: %d\n", __func__, state);
+		dev_warn(sciport_to_dev(iport), "%s: in wrong state: %s\n",
+			 __func__, port_state_name(state));
 		return SCI_FAILURE_INVALID_STATE;
 	}
 }
@@ -1397,8 +1407,8 @@ enum sci_status sci_port_complete_io(struct isci_port *iport,
 	state = iport->sm.current_state_id;
 	switch (state) {
 	case SCI_PORT_STOPPED:
-		dev_warn(sciport_to_dev(iport),
-			 "%s: in wrong state: %d\n", __func__, state);
+		dev_warn(sciport_to_dev(iport), "%s: in wrong state: %s\n",
+			 __func__, port_state_name(state));
 		return SCI_FAILURE_INVALID_STATE;
 	case SCI_PORT_STOPPING:
 		sci_port_decrement_request_count(iport);

commit 687833a03baae8308900486fa6499ef955fd07a9
Author: Dan Williams <dan.j.williams@intel.com>
Date:   Thu Nov 17 18:01:38 2011 -0800

    [SCSI] isci: ->lldd_ata_check_ready handler
    
    Report to libata whether the link to the given domain_device is up and the
    signature fis has been received.
    
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>
    Signed-off-by: James Bottomley <JBottomley@Parallels.com>

diff --git a/drivers/scsi/isci/port.c b/drivers/scsi/isci/port.c
index e55ef65f5212..c5ae94dbef48 100644
--- a/drivers/scsi/isci/port.c
+++ b/drivers/scsi/isci/port.c
@@ -1675,6 +1675,31 @@ int isci_port_perform_hard_reset(struct isci_host *ihost, struct isci_port *ipor
 	return ret;
 }
 
+int isci_ata_check_ready(struct domain_device *dev)
+{
+	struct isci_port *iport = dev->port->lldd_port;
+	struct isci_host *ihost = dev_to_ihost(dev);
+	struct isci_remote_device *idev;
+	unsigned long flags;
+	int rc = 0;
+
+	spin_lock_irqsave(&ihost->scic_lock, flags);
+	idev = isci_lookup_device(dev);
+	spin_unlock_irqrestore(&ihost->scic_lock, flags);
+
+	if (!idev)
+		goto out;
+
+	if (test_bit(IPORT_RESET_PENDING, &iport->state))
+		goto out;
+
+	rc = !!iport->active_phy_mask;
+ out:
+	isci_put_device(idev);
+
+	return rc;
+}
+
 void isci_port_deformed(struct asd_sas_phy *phy)
 {
 	struct isci_host *ihost = phy->ha->lldd_ha;

commit 9277699121b81891e303ada0a53fa1d04b7ffe72
Author: Dan Williams <dan.j.williams@intel.com>
Date:   Wed Nov 30 11:57:34 2011 -0800

    [SCSI] isci: fix interpretation of "hard" reset
    
    A hard reset to isci in the direct-attached case is one where the driver
    internally manages debouncing the link.  In the sas-expander-attached
    case a hard reset is one that clears affiliations.  The driver should
    not be prematurely dropping affiliations at run time, that decision (to
    force expander hard resets to ata devices) is left to userspace to
    manage.  So, arrange for I_T_nexus resets to be sas-link-resets in the
    expander-attached case and isci-hard-resets in the direct-attached case.
    
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>
    Signed-off-by: James Bottomley <JBottomley@Parallels.com>

diff --git a/drivers/scsi/isci/port.c b/drivers/scsi/isci/port.c
index f9d20c1e63ca..e55ef65f5212 100644
--- a/drivers/scsi/isci/port.c
+++ b/drivers/scsi/isci/port.c
@@ -305,7 +305,9 @@ static void port_state_machine_change(struct isci_port *iport,
 static void isci_port_hard_reset_complete(struct isci_port *isci_port,
 					  enum sci_status completion_status)
 {
-	dev_dbg(&isci_port->isci_host->pdev->dev,
+	struct isci_host *ihost = isci_port->owning_controller;
+
+	dev_dbg(&ihost->pdev->dev,
 		"%s: isci_port = %p, completion_status=%x\n",
 		     __func__, isci_port, completion_status);
 
@@ -316,23 +318,24 @@ static void isci_port_hard_reset_complete(struct isci_port *isci_port,
 
 		/* The reset failed.  The port state is now SCI_PORT_FAILED. */
 		if (isci_port->active_phy_mask == 0) {
+			int phy_idx = isci_port->last_active_phy;
+			struct isci_phy *iphy = &ihost->phys[phy_idx];
 
 			/* Generate the link down now to the host, since it
 			 * was intercepted by the hard reset state machine when
 			 * it really happened.
 			 */
-			isci_port_link_down(isci_port->isci_host,
-					    &isci_port->isci_host->phys[
-						   isci_port->last_active_phy],
-					    isci_port);
+			isci_port_link_down(ihost, iphy, isci_port);
 		}
 		/* Advance the port state so that link state changes will be
-		* noticed.
-		*/
+		 * noticed.
+		 */
 		port_state_machine_change(isci_port, SCI_PORT_SUB_WAITING);
 
 	}
-	complete_all(&isci_port->hard_reset_complete);
+	clear_bit(IPORT_RESET_PENDING, &isci_port->state);
+	wake_up(&ihost->eventq);
+
 }
 
 /* This method will return a true value if the specified phy can be assigned to
@@ -1610,6 +1613,11 @@ void sci_port_broadcast_change_received(struct isci_port *iport, struct isci_phy
 	isci_port_bc_change_received(ihost, iport, iphy);
 }
 
+static void wait_port_reset(struct isci_host *ihost, struct isci_port *iport)
+{
+	wait_event(ihost->eventq, !test_bit(IPORT_RESET_PENDING, &iport->state));
+}
+
 int isci_port_perform_hard_reset(struct isci_host *ihost, struct isci_port *iport,
 				 struct isci_phy *iphy)
 {
@@ -1620,9 +1628,8 @@ int isci_port_perform_hard_reset(struct isci_host *ihost, struct isci_port *ipor
 	dev_dbg(&ihost->pdev->dev, "%s: iport = %p\n",
 		__func__, iport);
 
-	init_completion(&iport->hard_reset_complete);
-
 	spin_lock_irqsave(&ihost->scic_lock, flags);
+	set_bit(IPORT_RESET_PENDING, &iport->state);
 
 	#define ISCI_PORT_RESET_TIMEOUT SCIC_SDS_SIGNATURE_FIS_TIMEOUT
 	status = sci_port_hard_reset(iport, ISCI_PORT_RESET_TIMEOUT);
@@ -1630,7 +1637,7 @@ int isci_port_perform_hard_reset(struct isci_host *ihost, struct isci_port *ipor
 	spin_unlock_irqrestore(&ihost->scic_lock, flags);
 
 	if (status == SCI_SUCCESS) {
-		wait_for_completion(&iport->hard_reset_complete);
+		wait_port_reset(ihost, iport);
 
 		dev_dbg(&ihost->pdev->dev,
 			"%s: iport = %p; hard reset completion\n",
@@ -1644,6 +1651,8 @@ int isci_port_perform_hard_reset(struct isci_host *ihost, struct isci_port *ipor
 				__func__, iport, iport->hard_reset_status);
 		}
 	} else {
+		clear_bit(IPORT_RESET_PENDING, &iport->state);
+		wake_up(&ihost->eventq);
 		ret = TMF_RESP_FUNC_FAILED;
 
 		dev_err(&ihost->pdev->dev,

commit fca4ecbdc440337b3c257b38c2f4cc8d0ca0286c
Author: Dan Williams <dan.j.williams@intel.com>
Date:   Tue Jan 3 23:26:15 2012 -0800

    [SCSI] isci: kill isci_port->status
    
    It only tracks whether the port is stopping in order to gate new devices
    being discovered while the port is stopping.  However, since the check
    and subsequent handling is unlocked there is nothing to stop the port
    from going down immediately after the check.
    
    Driver is already prepared to handle devices arriving on stale ports,
    and those will be cleaned up by an eventual ->lldd_dev_gone()
    notification.
    
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>
    Signed-off-by: James Bottomley <JBottomley@Parallels.com>

diff --git a/drivers/scsi/isci/port.c b/drivers/scsi/isci/port.c
index a28c9e6e2806..f9d20c1e63ca 100644
--- a/drivers/scsi/isci/port.c
+++ b/drivers/scsi/isci/port.c
@@ -75,20 +75,6 @@ static struct device *sciport_to_dev(struct isci_port *iport)
 	return &ihost->pdev->dev;
 }
 
-static void isci_port_change_state(struct isci_port *iport, enum isci_status status)
-{
-	unsigned long flags;
-
-	dev_dbg(&iport->isci_host->pdev->dev,
-		"%s: iport = %p, state = 0x%x\n",
-		__func__, iport, status);
-
-	/* XXX pointless lock */
-	spin_lock_irqsave(&iport->state_lock, flags);
-	iport->status = status;
-	spin_unlock_irqrestore(&iport->state_lock, flags);
-}
-
 static void sci_port_get_protocols(struct isci_port *iport, struct sci_phy_proto *proto)
 {
 	u8 index;
@@ -186,8 +172,6 @@ static void isci_port_link_up(struct isci_host *isci_host,
 
 	spin_lock_irqsave(&iphy->sas_phy.frame_rcvd_lock, flags);
 
-	isci_port_change_state(iport, isci_starting);
-
 	sci_port_get_properties(iport, &properties);
 
 	if (iphy->protocol == SCIC_SDS_PHY_PROTOCOL_SATA) {
@@ -269,7 +253,6 @@ static void isci_port_link_down(struct isci_host *isci_host,
 					__func__, isci_device);
 				set_bit(IDEV_GONE, &isci_device->flags);
 			}
-			isci_port_change_state(isci_port, isci_stopping);
 		}
 	}
 
@@ -284,45 +267,6 @@ static void isci_port_link_down(struct isci_host *isci_host,
 		"%s: isci_port = %p - Done\n", __func__, isci_port);
 }
 
-
-/**
- * isci_port_ready() - This function is called by the sci core when a link
- *    becomes ready.
- * @isci_host: This parameter specifies the isci host object.
- * @port: This parameter specifies the sci port with the active link.
- *
- */
-static void isci_port_ready(struct isci_host *isci_host, struct isci_port *isci_port)
-{
-	dev_dbg(&isci_host->pdev->dev,
-		"%s: isci_port = %p\n", __func__, isci_port);
-
-	isci_port_change_state(isci_port, isci_ready);
-	return;
-}
-
-/**
- * isci_port_not_ready() - This function is called by the sci core when a link
- *    is not ready. All remote devices on this link will be removed if they are
- *    in the stopping state.
- * @isci_host: This parameter specifies the isci host object.
- * @port: This parameter specifies the sci port with the active link.
- *
- */
-static void isci_port_not_ready(struct isci_host *isci_host, struct isci_port *isci_port)
-{
-	dev_dbg(&isci_host->pdev->dev,
-		"%s: isci_port = %p\n", __func__, isci_port);
-}
-
-static void isci_port_stop_complete(struct isci_host *ihost,
-				    struct isci_port *iport,
-				    enum sci_status completion_status)
-{
-	dev_dbg(&ihost->pdev->dev, "Port stop complete\n");
-}
-
-
 static bool is_port_ready_state(enum sci_port_states state)
 {
 	switch (state) {
@@ -843,10 +787,9 @@ static void port_timeout(unsigned long data)
 			__func__,
 			iport);
 	} else if (current_state == SCI_PORT_STOPPING) {
-		/* if the port is still stopping then the stop has not completed */
-		isci_port_stop_complete(iport->owning_controller,
-					iport,
-					SCI_FAILURE_TIMEOUT);
+		dev_dbg(sciport_to_dev(iport),
+			"%s: port%d: stop complete timeout\n",
+			__func__, iport->physical_port_index);
 	} else {
 		/* The port is in the ready state and we have a timer
 		 * reporting a timeout this should not happen.
@@ -1011,7 +954,8 @@ static void sci_port_ready_substate_operational_enter(struct sci_base_state_mach
 	struct isci_port *iport = container_of(sm, typeof(*iport), sm);
 	struct isci_host *ihost = iport->owning_controller;
 
-	isci_port_ready(ihost, iport);
+	dev_dbg(&ihost->pdev->dev, "%s: port%d ready\n",
+		__func__, iport->physical_port_index);
 
 	for (index = 0; index < SCI_MAX_PHYS; index++) {
 		if (iport->phy_table[index]) {
@@ -1077,7 +1021,8 @@ static void sci_port_ready_substate_operational_exit(struct sci_base_state_machi
 	 */
 	sci_port_abort_dummy_request(iport);
 
-	isci_port_not_ready(ihost, iport);
+	dev_dbg(&ihost->pdev->dev, "%s: port%d !ready\n",
+		__func__, iport->physical_port_index);
 
 	if (iport->ready_exit)
 		sci_port_invalidate_dummy_remote_node(iport);
@@ -1089,7 +1034,8 @@ static void sci_port_ready_substate_configuring_enter(struct sci_base_state_mach
 	struct isci_host *ihost = iport->owning_controller;
 
 	if (iport->active_phy_mask == 0) {
-		isci_port_not_ready(ihost, iport);
+		dev_dbg(&ihost->pdev->dev, "%s: port%d !ready\n",
+			__func__, iport->physical_port_index);
 
 		port_state_machine_change(iport, SCI_PORT_SUB_WAITING);
 	} else
@@ -1555,7 +1501,8 @@ static void sci_port_ready_state_enter(struct sci_base_state_machine *sm)
 	if (prev_state  == SCI_PORT_RESETTING)
 		isci_port_hard_reset_complete(iport, SCI_SUCCESS);
 	else
-		isci_port_not_ready(ihost, iport);
+		dev_dbg(&ihost->pdev->dev, "%s: port%d !ready\n",
+			__func__, iport->physical_port_index);
 
 	/* Post and suspend the dummy remote node context for this port. */
 	sci_port_post_dummy_remote_node(iport);
@@ -1652,21 +1599,7 @@ void isci_port_init(struct isci_port *iport, struct isci_host *ihost, int index)
 {
 	INIT_LIST_HEAD(&iport->remote_dev_list);
 	INIT_LIST_HEAD(&iport->domain_dev_list);
-	spin_lock_init(&iport->state_lock);
 	iport->isci_host = ihost;
-	isci_port_change_state(iport, isci_freed);
-}
-
-/**
- * isci_port_get_state() - This function gets the status of the port object.
- * @isci_port: This parameter points to the isci_port object
- *
- * status of the object as a isci_status enum.
- */
-enum isci_status isci_port_get_state(
-	struct isci_port *isci_port)
-{
-	return isci_port->status;
 }
 
 void sci_port_broadcast_change_received(struct isci_port *iport, struct isci_phy *iphy)

commit c132f692085ac624d7c8123df781846c8dcb3166
Author: Dan Williams <dan.j.williams@intel.com>
Date:   Tue Jan 3 23:26:08 2012 -0800

    [SCSI] isci: kill iphy->isci_port lookups
    
    This field is a holdover from the OS abstraction conversion.  The stable
    phy to port lookups are done via iphy->ownining_port under scic_lock.
    After this conversion to use port->lldd_port the only volatile lookup is
    the initial lookup in isci_port_formed().  After that point any lookup
    via a successfully notified domain_device is guaranteed to be valid
    until the domain_device is destroyed.
    
    Delete ->start_complete as it is only set once and is set as a
    consequence of the port going link up, by definition of getting a port
    formed event the port is "ready".
    
    While we are correcting port lookups also move the asd_sas_port table
    out from under the isci_port.  This is to preclude any temptation to use
    container_of() to convert an asd_sas_port to an isci_port, the
    association is dynamic and under libsas control.
    
    Tested-by: Maciej Trela <maciej.trela@intel.com>
    [dmilburn@redhat.com: fix i686 compile error]
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>
    Signed-off-by: James Bottomley <JBottomley@Parallels.com>

diff --git a/drivers/scsi/isci/port.c b/drivers/scsi/isci/port.c
index 7c6ac58a5c4c..a28c9e6e2806 100644
--- a/drivers/scsi/isci/port.c
+++ b/drivers/scsi/isci/port.c
@@ -60,6 +60,21 @@
 #define SCIC_SDS_PORT_HARD_RESET_TIMEOUT  (1000)
 #define SCU_DUMMY_INDEX    (0xFFFF)
 
+static struct device *sciport_to_dev(struct isci_port *iport)
+{
+	int i = iport->physical_port_index;
+	struct isci_port *table;
+	struct isci_host *ihost;
+
+	if (i == SCIC_SDS_DUMMY_PORT)
+		i = SCI_MAX_PORTS+1;
+
+	table = iport - i;
+	ihost = container_of(table, typeof(*ihost), ports[0]);
+
+	return &ihost->pdev->dev;
+}
+
 static void isci_port_change_state(struct isci_port *iport, enum isci_status status)
 {
 	unsigned long flags;
@@ -165,17 +180,13 @@ static void isci_port_link_up(struct isci_host *isci_host,
 	struct sci_port_properties properties;
 	unsigned long success = true;
 
-	BUG_ON(iphy->isci_port != NULL);
-
-	iphy->isci_port = iport;
-
 	dev_dbg(&isci_host->pdev->dev,
 		"%s: isci_port = %p\n",
 		__func__, iport);
 
 	spin_lock_irqsave(&iphy->sas_phy.frame_rcvd_lock, flags);
 
-	isci_port_change_state(iphy->isci_port, isci_starting);
+	isci_port_change_state(iport, isci_starting);
 
 	sci_port_get_properties(iport, &properties);
 
@@ -269,8 +280,6 @@ static void isci_port_link_down(struct isci_host *isci_host,
 	isci_host->sas_ha.notify_phy_event(&isci_phy->sas_phy,
 					   PHYE_LOSS_OF_SIGNAL);
 
-	isci_phy->isci_port = NULL;
-
 	dev_dbg(&isci_host->pdev->dev,
 		"%s: isci_port = %p - Done\n", __func__, isci_port);
 }
@@ -288,7 +297,6 @@ static void isci_port_ready(struct isci_host *isci_host, struct isci_port *isci_
 	dev_dbg(&isci_host->pdev->dev,
 		"%s: isci_port = %p\n", __func__, isci_port);
 
-	complete_all(&isci_port->start_complete);
 	isci_port_change_state(isci_port, isci_ready);
 	return;
 }
@@ -1645,7 +1653,6 @@ void isci_port_init(struct isci_port *iport, struct isci_host *ihost, int index)
 	INIT_LIST_HEAD(&iport->remote_dev_list);
 	INIT_LIST_HEAD(&iport->domain_dev_list);
 	spin_lock_init(&iport->state_lock);
-	init_completion(&iport->start_complete);
 	iport->isci_host = ihost;
 	isci_port_change_state(iport, isci_freed);
 }
@@ -1726,24 +1733,55 @@ int isci_port_perform_hard_reset(struct isci_host *ihost, struct isci_port *ipor
 	return ret;
 }
 
-/**
- * isci_port_deformed() - This function is called by libsas when a port becomes
- *    inactive.
- * @phy: This parameter specifies the libsas phy with the inactive port.
- *
- */
 void isci_port_deformed(struct asd_sas_phy *phy)
 {
-	pr_debug("%s: sas_phy = %p\n", __func__, phy);
+	struct isci_host *ihost = phy->ha->lldd_ha;
+	struct isci_port *iport = phy->port->lldd_port;
+	unsigned long flags;
+	int i;
+
+	/* we got a port notification on a port that was subsequently
+	 * torn down and libsas is just now catching up
+	 */
+	if (!iport)
+		return;
+
+	spin_lock_irqsave(&ihost->scic_lock, flags);
+	for (i = 0; i < SCI_MAX_PHYS; i++) {
+		if (iport->active_phy_mask & 1 << i)
+			break;
+	}
+	spin_unlock_irqrestore(&ihost->scic_lock, flags);
+
+	if (i >= SCI_MAX_PHYS)
+		dev_dbg(&ihost->pdev->dev, "%s: port: %ld\n",
+			__func__, (long) (iport - &ihost->ports[0]));
 }
 
-/**
- * isci_port_formed() - This function is called by libsas when a port becomes
- *    active.
- * @phy: This parameter specifies the libsas phy with the active port.
- *
- */
 void isci_port_formed(struct asd_sas_phy *phy)
 {
-	pr_debug("%s: sas_phy = %p, sas_port = %p\n", __func__, phy, phy->port);
+	struct isci_host *ihost = phy->ha->lldd_ha;
+	struct isci_phy *iphy = to_iphy(phy);
+	struct asd_sas_port *port = phy->port;
+	struct isci_port *iport;
+	unsigned long flags;
+	int i;
+
+	/* initial ports are formed as the driver is still initializing,
+	 * wait for that process to complete
+	 */
+	wait_for_start(ihost);
+
+	spin_lock_irqsave(&ihost->scic_lock, flags);
+	for (i = 0; i < SCI_MAX_PORTS; i++) {
+		iport = &ihost->ports[i];
+		if (iport->active_phy_mask & 1 << iphy->phy_index)
+			break;
+	}
+	spin_unlock_irqrestore(&ihost->scic_lock, flags);
+
+	if (i >= SCI_MAX_PORTS)
+		iport = NULL;
+
+	port->lldd_port = iport;
 }

commit 05b080fc933bb068b32fa119db00e8efcc10e3bd
Author: Marcin Tomczak <marcin.tomczak@intel.com>
Date:   Wed Jan 4 01:33:41 2012 -0800

    [SCSI] isci: fix, prevent port from getting stuck in the 'configuring' state
    
    When expander connected in x2 or x4 mode and with IO runnning, if
    a cable from wideport is plugged out from the phy, IO's start failing
    on all the targets.
    
    Observed that when cable is pulled with IO running, cominit is
    happening on all the links and IO's start dropping to 0 and eventually
    the whole IO fails. Second observation, target is trying to open and
    SCU is responding with "Open reject no destination".
    
    A cause of the problem is when the port went from the "ready
    configuring substate" back to "ready configuring substate" as a result
    of phy being pulled off, scic suspended the port task scheduler
    register. As a result no IO was allowed and in the "substate
    configuring enter" routine the IO never goes back to 0. As a result
    the port never comes out of "ready substate configuring".
    
    The patch adds a mechanism of activate and deactivate phy when a port
    link up, which fixes the problem.
    
    Signed-off-by: Bartek Nowakowski <bartek.nowakowski@intel.com>
    Signed-off-by: Maciej Trela <maciej.trela@intel.com>
    Signed-off-by: Marcin Tomczak <marcin.tomczak@intel.com>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>
    Signed-off-by: James Bottomley <JBottomley@Parallels.com>

diff --git a/drivers/scsi/isci/port.c b/drivers/scsi/isci/port.c
index 49e8a72d1c5b..7c6ac58a5c4c 100644
--- a/drivers/scsi/isci/port.c
+++ b/drivers/scsi/isci/port.c
@@ -647,19 +647,26 @@ void sci_port_setup_transports(struct isci_port *iport, u32 device_id)
 	}
 }
 
-static void sci_port_activate_phy(struct isci_port *iport, struct isci_phy *iphy,
-				  bool do_notify_user)
+static void sci_port_resume_phy(struct isci_port *iport, struct isci_phy *iphy)
+{
+	sci_phy_resume(iphy);
+	iport->enabled_phy_mask |= 1 << iphy->phy_index;
+}
+
+static void sci_port_activate_phy(struct isci_port *iport,
+				  struct isci_phy *iphy,
+				  u8 flags)
 {
 	struct isci_host *ihost = iport->owning_controller;
 
-	if (iphy->protocol != SCIC_SDS_PHY_PROTOCOL_SATA)
+	if (iphy->protocol != SCIC_SDS_PHY_PROTOCOL_SATA && (flags & PF_RESUME))
 		sci_phy_resume(iphy);
 
 	iport->active_phy_mask |= 1 << iphy->phy_index;
 
 	sci_controller_clear_invalid_phy(ihost, iphy);
 
-	if (do_notify_user == true)
+	if (flags & PF_NOTIFY)
 		isci_port_link_up(ihost, iport, iphy);
 }
 
@@ -669,6 +676,7 @@ void sci_port_deactivate_phy(struct isci_port *iport, struct isci_phy *iphy,
 	struct isci_host *ihost = iport->owning_controller;
 
 	iport->active_phy_mask &= ~(1 << iphy->phy_index);
+	iport->enabled_phy_mask &= ~(1 << iphy->phy_index);
 	if (!iport->active_phy_mask)
 		iport->last_active_phy = iphy->phy_index;
 
@@ -705,18 +713,16 @@ static void sci_port_invalid_link_up(struct isci_port *iport, struct isci_phy *i
  * sci_port_general_link_up_handler - phy can be assigned to port?
  * @sci_port: sci_port object for which has a phy that has gone link up.
  * @sci_phy: This is the struct isci_phy object that has gone link up.
- * @do_notify_user: This parameter specifies whether to inform the user (via
- *    sci_port_link_up()) as to the fact that a new phy as become ready.
+ * @flags: PF_RESUME, PF_NOTIFY to sci_port_activate_phy
  *
- * Determine if this phy can be assigned to this
- * port . If the phy is not a valid PHY for
- * this port then the function will notify the user. A PHY can only be
- * part of a port if it's attached SAS ADDRESS is the same as all other PHYs in
- * the same port. none
+ * Determine if this phy can be assigned to this port . If the phy is
+ * not a valid PHY for this port then the function will notify the user.
+ * A PHY can only be part of a port if it's attached SAS ADDRESS is the
+ * same as all other PHYs in the same port.
  */
 static void sci_port_general_link_up_handler(struct isci_port *iport,
-						  struct isci_phy *iphy,
-						  bool do_notify_user)
+					     struct isci_phy *iphy,
+					     u8 flags)
 {
 	struct sci_sas_address port_sas_address;
 	struct sci_sas_address phy_sas_address;
@@ -734,7 +740,7 @@ static void sci_port_general_link_up_handler(struct isci_port *iport,
 	    iport->active_phy_mask == 0) {
 		struct sci_base_state_machine *sm = &iport->sm;
 
-		sci_port_activate_phy(iport, iphy, do_notify_user);
+		sci_port_activate_phy(iport, iphy, flags);
 		if (sm->current_state_id == SCI_PORT_RESETTING)
 			port_state_machine_change(iport, SCI_PORT_READY);
 	} else
@@ -785,11 +791,16 @@ bool sci_port_link_detected(
 	struct isci_phy *iphy)
 {
 	if ((iport->logical_port_index != SCIC_SDS_DUMMY_PORT) &&
-	    (iphy->protocol == SCIC_SDS_PHY_PROTOCOL_SATA) &&
-	    sci_port_is_wide(iport)) {
-		sci_port_invalid_link_up(iport, iphy);
-
-		return false;
+	    (iphy->protocol == SCIC_SDS_PHY_PROTOCOL_SATA)) {
+		if (sci_port_is_wide(iport)) {
+			sci_port_invalid_link_up(iport, iphy);
+			return false;
+		} else {
+			struct isci_host *ihost = iport->owning_controller;
+			struct isci_port *dst_port = &(ihost->ports[iphy->phy_index]);
+			writel(iphy->phy_index,
+			       &dst_port->port_pe_configuration_register[iphy->phy_index]);
+		}
 	}
 
 	return true;
@@ -979,6 +990,13 @@ static void sci_port_ready_substate_waiting_enter(struct sci_base_state_machine
 	}
 }
 
+static void scic_sds_port_ready_substate_waiting_exit(
+					struct sci_base_state_machine *sm)
+{
+	struct isci_port *iport = container_of(sm, typeof(*iport), sm);
+	sci_port_resume_port_task_scheduler(iport);
+}
+
 static void sci_port_ready_substate_operational_enter(struct sci_base_state_machine *sm)
 {
 	u32 index;
@@ -992,13 +1010,13 @@ static void sci_port_ready_substate_operational_enter(struct sci_base_state_mach
 			writel(iport->physical_port_index,
 				&iport->port_pe_configuration_register[
 					iport->phy_table[index]->phy_index]);
+			if (((iport->active_phy_mask^iport->enabled_phy_mask) & (1 << index)) != 0)
+				sci_port_resume_phy(iport, iport->phy_table[index]);
 		}
 	}
 
 	sci_port_update_viit_entry(iport);
 
-	sci_port_resume_port_task_scheduler(iport);
-
 	/*
 	 * Post the dummy task for the port so the hardware can schedule
 	 * io correctly
@@ -1065,20 +1083,9 @@ static void sci_port_ready_substate_configuring_enter(struct sci_base_state_mach
 	if (iport->active_phy_mask == 0) {
 		isci_port_not_ready(ihost, iport);
 
-		port_state_machine_change(iport,
-					  SCI_PORT_SUB_WAITING);
-	} else if (iport->started_request_count == 0)
-		port_state_machine_change(iport,
-					  SCI_PORT_SUB_OPERATIONAL);
-}
-
-static void sci_port_ready_substate_configuring_exit(struct sci_base_state_machine *sm)
-{
-	struct isci_port *iport = container_of(sm, typeof(*iport), sm);
-
-	sci_port_suspend_port_task_scheduler(iport);
-	if (iport->ready_exit)
-		sci_port_invalidate_dummy_remote_node(iport);
+		port_state_machine_change(iport, SCI_PORT_SUB_WAITING);
+	} else
+		port_state_machine_change(iport, SCI_PORT_SUB_OPERATIONAL);
 }
 
 enum sci_status sci_port_start(struct isci_port *iport)
@@ -1256,7 +1263,7 @@ enum sci_status sci_port_add_phy(struct isci_port *iport,
 		if (status != SCI_SUCCESS)
 			return status;
 
-		sci_port_general_link_up_handler(iport, iphy, true);
+		sci_port_general_link_up_handler(iport, iphy, PF_NOTIFY|PF_RESUME);
 		iport->not_ready_reason = SCIC_PORT_NOT_READY_RECONFIGURING;
 		port_state_machine_change(iport, SCI_PORT_SUB_CONFIGURING);
 
@@ -1266,7 +1273,7 @@ enum sci_status sci_port_add_phy(struct isci_port *iport,
 
 		if (status != SCI_SUCCESS)
 			return status;
-		sci_port_general_link_up_handler(iport, iphy, true);
+		sci_port_general_link_up_handler(iport, iphy, PF_NOTIFY);
 
 		/* Re-enter the configuring state since this may be the last phy in
 		 * the port.
@@ -1342,13 +1349,13 @@ enum sci_status sci_port_link_up(struct isci_port *iport,
 		/* Since this is the first phy going link up for the port we
 		 * can just enable it and continue
 		 */
-		sci_port_activate_phy(iport, iphy, true);
+		sci_port_activate_phy(iport, iphy, PF_NOTIFY|PF_RESUME);
 
 		port_state_machine_change(iport,
 					  SCI_PORT_SUB_OPERATIONAL);
 		return SCI_SUCCESS;
 	case SCI_PORT_SUB_OPERATIONAL:
-		sci_port_general_link_up_handler(iport, iphy, true);
+		sci_port_general_link_up_handler(iport, iphy, PF_NOTIFY|PF_RESUME);
 		return SCI_SUCCESS;
 	case SCI_PORT_RESETTING:
 		/* TODO We should  make  sure  that  the phy  that  has gone
@@ -1365,7 +1372,7 @@ enum sci_status sci_port_link_up(struct isci_port *iport,
 		/* In the resetting state we don't notify the user regarding
 		 * link up and link down notifications.
 		 */
-		sci_port_general_link_up_handler(iport, iphy, false);
+		sci_port_general_link_up_handler(iport, iphy, PF_RESUME);
 		return SCI_SUCCESS;
 	default:
 		dev_warn(sciport_to_dev(iport),
@@ -1588,14 +1595,14 @@ static const struct sci_base_state sci_port_state_table[] = {
 	},
 	[SCI_PORT_SUB_WAITING] = {
 		.enter_state = sci_port_ready_substate_waiting_enter,
+		.exit_state  = scic_sds_port_ready_substate_waiting_exit,
 	},
 	[SCI_PORT_SUB_OPERATIONAL] = {
 		.enter_state = sci_port_ready_substate_operational_enter,
 		.exit_state  = sci_port_ready_substate_operational_exit
 	},
 	[SCI_PORT_SUB_CONFIGURING] = {
-		.enter_state = sci_port_ready_substate_configuring_enter,
-		.exit_state  = sci_port_ready_substate_configuring_exit
+		.enter_state = sci_port_ready_substate_configuring_enter
 	},
 	[SCI_PORT_RESETTING] = {
 		.exit_state  = sci_port_resetting_state_exit
@@ -1613,6 +1620,7 @@ void sci_port_construct(struct isci_port *iport, u8 index,
 	iport->logical_port_index  = SCIC_SDS_DUMMY_PORT;
 	iport->physical_port_index = index;
 	iport->active_phy_mask     = 0;
+	iport->enabled_phy_mask    = 0;
 	iport->last_active_phy     = 0;
 	iport->ready_exit	   = false;
 

commit 7e629841b8f8f7bc84d74de994d748b0a3282225
Author: Bartek Nowakowski <bartek.nowakowski@intel.com>
Date:   Wed Jan 4 01:33:20 2012 -0800

    [SCSI] isci: enable wide port targets
    
    Arrange for task_contexts prepared for the wide targets to account for
    all the attached phys in the port.
    
    Signed-off-by: Bartek Nowakowski <bartek.nowakowski@intel.com>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>
    Signed-off-by: James Bottomley <JBottomley@Parallels.com>

diff --git a/drivers/scsi/isci/port.c b/drivers/scsi/isci/port.c
index 4cb071d825bb..49e8a72d1c5b 100644
--- a/drivers/scsi/isci/port.c
+++ b/drivers/scsi/isci/port.c
@@ -114,7 +114,7 @@ static u32 sci_port_get_phys(struct isci_port *iport)
  * value is returned if the specified port is not valid.  When this value is
  * returned, no data is copied to the properties output parameter.
  */
-static enum sci_status sci_port_get_properties(struct isci_port *iport,
+enum sci_status sci_port_get_properties(struct isci_port *iport,
 						struct sci_port_properties *prop)
 {
 	if (!iport || iport->logical_port_index == SCIC_SDS_DUMMY_PORT)

commit d4ec1cf61fb081a9dde0c0e0b2d0201f4005f937
Author: Marcin Tomczak <marcin.tomczak@intel.com>
Date:   Wed Jan 4 01:33:15 2012 -0800

    [SCSI] isci: Fix IO fails when pull cable from phy in x4 wideport in MPC mode.
    
    Failure seen pulling a cable from a x4 port configured in manual port
    configuration (MPC) mode (MPC mode is set by the the OEM paramaters
    provided by the platform or isci_firmware.bin).  While IO running to
    devices behind and expander, plugging out the cable from phy is causing
    IO failures and IO drops on disks and never recover.
    
    It happens because during link up/down the phy were being taken out of
    the port.
    
    Fix: during link down the phy is kept in the same logical port.
    
    Signed-off-by: Marcin Tomczak <marcin.tomczak@intel.com>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>
    Signed-off-by: James Bottomley <JBottomley@Parallels.com>

diff --git a/drivers/scsi/isci/port.c b/drivers/scsi/isci/port.c
index ac7f27749f97..4cb071d825bb 100644
--- a/drivers/scsi/isci/port.c
+++ b/drivers/scsi/isci/port.c
@@ -674,9 +674,13 @@ void sci_port_deactivate_phy(struct isci_port *iport, struct isci_phy *iphy,
 
 	iphy->max_negotiated_speed = SAS_LINK_RATE_UNKNOWN;
 
-	/* Re-assign the phy back to the LP as if it were a narrow port */
-	writel(iphy->phy_index,
-		&iport->port_pe_configuration_register[iphy->phy_index]);
+	/* Re-assign the phy back to the LP as if it were a narrow port for APC
+	 * mode. For MPC mode, the phy will remain in the port.
+	 */
+	if (iport->owning_controller->oem_parameters.controller.mode_type ==
+		SCIC_PORT_AUTOMATIC_CONFIGURATION_MODE)
+		writel(iphy->phy_index,
+			&iport->port_pe_configuration_register[iphy->phy_index]);
 
 	if (do_notify_user == true)
 		isci_port_link_down(ihost, iphy, iport);

commit 52d74634335dfc0984ed955ed3c6ad6488495f96
Author: Dan Williams <dan.j.williams@intel.com>
Date:   Thu Oct 27 15:05:37 2011 -0700

    [SCSI] isci: revert bcn filtering
    
    The initial bcn filtering implementation was validated on a kernel
    baseline that predated the switch to new libata error handling.  Also,
    prior to that conversion we borrowed the mvsas MVS_DEV_EH approach to
    prevent the unwanted extra ap->ops->phy_reset(ap) that occurred in the
    ata_bus_probe() path.
    
    After the conversion to new libata eh resets at discovery are more
    frequent and get filtered prematurely by IDEV_EH.  The result is that
    our bcn filtering has been blocked from running and at discovery and it
    appears to stall discovery completion to the point of triggering hung
    task timeouts.  So, revert the implementation for now.  When it returns
    it will go into libsas proper.
    
    The domain rediscovery that takes place due to ->lldd_I_T_nexus_reset()
    events should now be properly waited for by the ata_port_wait_eh() call
    in ata_port_probe().  So the hard coded delay in the isci
    ->lldd_I_T_nexus_reset() and other libsas drivers should help debounce
    the libsas thread from seeing temporary device removals.
    
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>
    Signed-off-by: James Bottomley <JBottomley@Parallels.com>

diff --git a/drivers/scsi/isci/port.c b/drivers/scsi/isci/port.c
index bfeb87905aaf..ac7f27749f97 100644
--- a/drivers/scsi/isci/port.c
+++ b/drivers/scsi/isci/port.c
@@ -145,48 +145,15 @@ static void sci_port_bcn_enable(struct isci_port *iport)
 	}
 }
 
-/* called under sci_lock to stabilize phy:port associations */
-void isci_port_bcn_enable(struct isci_host *ihost, struct isci_port *iport)
-{
-	int i;
-
-	clear_bit(IPORT_BCN_BLOCKED, &iport->flags);
-	wake_up(&ihost->eventq);
-
-	if (!test_and_clear_bit(IPORT_BCN_PENDING, &iport->flags))
-		return;
-
-	for (i = 0; i < ARRAY_SIZE(iport->phy_table); i++) {
-		struct isci_phy *iphy = iport->phy_table[i];
-
-		if (!iphy)
-			continue;
-
-		ihost->sas_ha.notify_port_event(&iphy->sas_phy,
-						PORTE_BROADCAST_RCVD);
-		break;
-	}
-}
-
 static void isci_port_bc_change_received(struct isci_host *ihost,
 					 struct isci_port *iport,
 					 struct isci_phy *iphy)
 {
-	if (iport && test_bit(IPORT_BCN_BLOCKED, &iport->flags)) {
-		dev_dbg(&ihost->pdev->dev,
-			"%s: disabled BCN; isci_phy = %p, sas_phy = %p\n",
-			__func__, iphy, &iphy->sas_phy);
-		set_bit(IPORT_BCN_PENDING, &iport->flags);
-		atomic_inc(&iport->event);
-		wake_up(&ihost->eventq);
-	} else {
-		dev_dbg(&ihost->pdev->dev,
-			"%s: isci_phy = %p, sas_phy = %p\n",
-			__func__, iphy, &iphy->sas_phy);
+	dev_dbg(&ihost->pdev->dev,
+		"%s: isci_phy = %p, sas_phy = %p\n",
+		__func__, iphy, &iphy->sas_phy);
 
-		ihost->sas_ha.notify_port_event(&iphy->sas_phy,
-						PORTE_BROADCAST_RCVD);
-	}
+	ihost->sas_ha.notify_port_event(&iphy->sas_phy, PORTE_BROADCAST_RCVD);
 	sci_port_bcn_enable(iport);
 }
 
@@ -278,9 +245,6 @@ static void isci_port_link_down(struct isci_host *isci_host,
 		/* check to see if this is the last phy on this port. */
 		if (isci_phy->sas_phy.port &&
 		    isci_phy->sas_phy.port->num_phys == 1) {
-			atomic_inc(&isci_port->event);
-			isci_port_bcn_enable(isci_host, isci_port);
-
 			/* change the state for all devices on this port.  The
 			 * next task sent to this device will be returned as
 			 * SAS_TASK_UNDELIVERED, and the scsi mid layer will
@@ -1672,7 +1636,6 @@ void isci_port_init(struct isci_port *iport, struct isci_host *ihost, int index)
 	init_completion(&iport->start_complete);
 	iport->isci_host = ihost;
 	isci_port_change_state(iport, isci_freed);
-	atomic_set(&iport->event, 0);
 }
 
 /**

commit 8e35a1398c5db981cd1a2d7635de9c15dd648527
Author: Jeff Skirvin <jeffrey.d.skirvin@intel.com>
Date:   Thu Oct 27 15:05:32 2011 -0700

    [SCSI] isci: Fix hard reset timeout conditions.
    
    A hard reset can timeout before or after the last phy in the
    port goes away.  If after, then notify the OS that the last
    phy has failed.
    
    The recovery for the failed hard reset has been removed.
    This recovery code was unecessary in that the link would
    recover from the failure normally by a new link reset sequence
    or hotplug of the remote device.
    
    Signed-off-by: Jeff Skirvin <jeffrey.d.skirvin@intel.com>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>
    Signed-off-by: James Bottomley <JBottomley@Parallels.com>

diff --git a/drivers/scsi/isci/port.c b/drivers/scsi/isci/port.c
index 8e59c8865dcd..bfeb87905aaf 100644
--- a/drivers/scsi/isci/port.c
+++ b/drivers/scsi/isci/port.c
@@ -350,6 +350,34 @@ static void isci_port_stop_complete(struct isci_host *ihost,
 	dev_dbg(&ihost->pdev->dev, "Port stop complete\n");
 }
 
+
+static bool is_port_ready_state(enum sci_port_states state)
+{
+	switch (state) {
+	case SCI_PORT_READY:
+	case SCI_PORT_SUB_WAITING:
+	case SCI_PORT_SUB_OPERATIONAL:
+	case SCI_PORT_SUB_CONFIGURING:
+		return true;
+	default:
+		return false;
+	}
+}
+
+/* flag dummy rnc hanling when exiting a ready state */
+static void port_state_machine_change(struct isci_port *iport,
+				      enum sci_port_states state)
+{
+	struct sci_base_state_machine *sm = &iport->sm;
+	enum sci_port_states old_state = sm->current_state_id;
+
+	if (is_port_ready_state(old_state) && !is_port_ready_state(state))
+		iport->ready_exit = true;
+
+	sci_change_state(sm, state);
+	iport->ready_exit = false;
+}
+
 /**
  * isci_port_hard_reset_complete() - This function is called by the sci core
  *    when the hard reset complete notification has been received.
@@ -368,6 +396,26 @@ static void isci_port_hard_reset_complete(struct isci_port *isci_port,
 	/* Save the status of the hard reset from the port. */
 	isci_port->hard_reset_status = completion_status;
 
+	if (completion_status != SCI_SUCCESS) {
+
+		/* The reset failed.  The port state is now SCI_PORT_FAILED. */
+		if (isci_port->active_phy_mask == 0) {
+
+			/* Generate the link down now to the host, since it
+			 * was intercepted by the hard reset state machine when
+			 * it really happened.
+			 */
+			isci_port_link_down(isci_port->isci_host,
+					    &isci_port->isci_host->phys[
+						   isci_port->last_active_phy],
+					    isci_port);
+		}
+		/* Advance the port state so that link state changes will be
+		* noticed.
+		*/
+		port_state_machine_change(isci_port, SCI_PORT_SUB_WAITING);
+
+	}
 	complete_all(&isci_port->hard_reset_complete);
 }
 
@@ -657,6 +705,8 @@ void sci_port_deactivate_phy(struct isci_port *iport, struct isci_phy *iphy,
 	struct isci_host *ihost = iport->owning_controller;
 
 	iport->active_phy_mask &= ~(1 << iphy->phy_index);
+	if (!iport->active_phy_mask)
+		iport->last_active_phy = iphy->phy_index;
 
 	iphy->max_negotiated_speed = SAS_LINK_RATE_UNKNOWN;
 
@@ -683,33 +733,6 @@ static void sci_port_invalid_link_up(struct isci_port *iport, struct isci_phy *i
 	}
 }
 
-static bool is_port_ready_state(enum sci_port_states state)
-{
-	switch (state) {
-	case SCI_PORT_READY:
-	case SCI_PORT_SUB_WAITING:
-	case SCI_PORT_SUB_OPERATIONAL:
-	case SCI_PORT_SUB_CONFIGURING:
-		return true;
-	default:
-		return false;
-	}
-}
-
-/* flag dummy rnc hanling when exiting a ready state */
-static void port_state_machine_change(struct isci_port *iport,
-				      enum sci_port_states state)
-{
-	struct sci_base_state_machine *sm = &iport->sm;
-	enum sci_port_states old_state = sm->current_state_id;
-
-	if (is_port_ready_state(old_state) && !is_port_ready_state(state))
-		iport->ready_exit = true;
-
-	sci_change_state(sm, state);
-	iport->ready_exit = false;
-}
-
 /**
  * sci_port_general_link_up_handler - phy can be assigned to port?
  * @sci_port: sci_port object for which has a phy that has gone link up.
@@ -1622,7 +1645,8 @@ void sci_port_construct(struct isci_port *iport, u8 index,
 	iport->logical_port_index  = SCIC_SDS_DUMMY_PORT;
 	iport->physical_port_index = index;
 	iport->active_phy_mask     = 0;
-	iport->ready_exit	      = false;
+	iport->last_active_phy     = 0;
+	iport->ready_exit	   = false;
 
 	iport->owning_controller = ihost;
 
@@ -1676,7 +1700,7 @@ int isci_port_perform_hard_reset(struct isci_host *ihost, struct isci_port *ipor
 {
 	unsigned long flags;
 	enum sci_status status;
-	int idx, ret = TMF_RESP_FUNC_COMPLETE;
+	int ret = TMF_RESP_FUNC_COMPLETE;
 
 	dev_dbg(&ihost->pdev->dev, "%s: iport = %p\n",
 		__func__, iport);
@@ -1697,8 +1721,13 @@ int isci_port_perform_hard_reset(struct isci_host *ihost, struct isci_port *ipor
 			"%s: iport = %p; hard reset completion\n",
 			__func__, iport);
 
-		if (iport->hard_reset_status != SCI_SUCCESS)
+		if (iport->hard_reset_status != SCI_SUCCESS) {
 			ret = TMF_RESP_FUNC_FAILED;
+
+			dev_err(&ihost->pdev->dev,
+				"%s: iport = %p; hard reset failed (0x%x)\n",
+				__func__, iport, iport->hard_reset_status);
+		}
 	} else {
 		ret = TMF_RESP_FUNC_FAILED;
 
@@ -1718,18 +1747,6 @@ int isci_port_perform_hard_reset(struct isci_host *ihost, struct isci_port *ipor
 			"%s: iport = %p; hard reset failed "
 			"(0x%x) - driving explicit link fail for all phys\n",
 			__func__, iport, iport->hard_reset_status);
-
-		/* Down all phys in the port. */
-		spin_lock_irqsave(&ihost->scic_lock, flags);
-		for (idx = 0; idx < SCI_MAX_PHYS; ++idx) {
-			struct isci_phy *iphy = iport->phy_table[idx];
-
-			if (!iphy)
-				continue;
-			sci_phy_stop(iphy);
-			sci_phy_start(iphy);
-		}
-		spin_unlock_irqrestore(&ihost->scic_lock, flags);
 	}
 	return ret;
 }

commit cdd05f05b4adefccfa9fce7d0e10c50f38f8a4bd
Author: Jeff Skirvin <jeffrey.d.skirvin@intel.com>
Date:   Wed Sep 28 18:47:56 2011 -0700

    [SCSI] isci: The port state should be set to stopping on the last phy.
    
    Fixes a bug where any phy removed from the port set the port
    state to "stopping" - do this only when the last phy removed
    from the port.
    
    Signed-off-by: Jeff Skirvin <jeffrey.d.skirvin@intel.com>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>
    Signed-off-by: James Bottomley <JBottomley@Parallels.com>

diff --git a/drivers/scsi/isci/port.c b/drivers/scsi/isci/port.c
index 8f6f9b77e41a..8e59c8865dcd 100644
--- a/drivers/scsi/isci/port.c
+++ b/drivers/scsi/isci/port.c
@@ -294,8 +294,8 @@ static void isci_port_link_down(struct isci_host *isci_host,
 					__func__, isci_device);
 				set_bit(IDEV_GONE, &isci_device->flags);
 			}
+			isci_port_change_state(isci_port, isci_stopping);
 		}
-		isci_port_change_state(isci_port, isci_stopping);
 	}
 
 	/* Notify libsas of the borken link, this will trigger calls to our

commit 34a991587a5cc9f78960c2c9beea217866458c41
Author: Dan Williams <dan.j.williams@intel.com>
Date:   Fri Jul 1 02:25:15 2011 -0700

    isci: kill 'get/set' macros
    
    Most of these simple dereference macros are longer than their open coded
    equivalent.  Deleting enum sci_controller_mode is thrown in for good
    measure.
    
    Reported-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/drivers/scsi/isci/port.c b/drivers/scsi/isci/port.c
index 1822ed68409e..8f6f9b77e41a 100644
--- a/drivers/scsi/isci/port.c
+++ b/drivers/scsi/isci/port.c
@@ -654,7 +654,7 @@ static void sci_port_activate_phy(struct isci_port *iport, struct isci_phy *iphy
 void sci_port_deactivate_phy(struct isci_port *iport, struct isci_phy *iphy,
 			     bool do_notify_user)
 {
-	struct isci_host *ihost = sci_port_get_controller(iport);
+	struct isci_host *ihost = iport->owning_controller;
 
 	iport->active_phy_mask &= ~(1 << iphy->phy_index);
 
@@ -678,7 +678,7 @@ static void sci_port_invalid_link_up(struct isci_port *iport, struct isci_phy *i
 	 * invalid link.
 	 */
 	if ((ihost->invalid_phy_mask & (1 << iphy->phy_index)) == 0) {
-		sci_controller_set_invalid_phy(ihost, iphy);
+		ihost->invalid_phy_mask |= 1 << iphy->phy_index;
 		dev_warn(&ihost->pdev->dev, "Invalid link up!\n");
 	}
 }

commit 89a7301f21fb00e753089671eb9e4132aab8ea08
Author: Dan Williams <dan.j.williams@intel.com>
Date:   Thu Jun 30 19:14:33 2011 -0700

    isci: retire scic_sds_ and scic_ prefixes
    
    The distinction between scic_sds_ scic_ and sci_ are no longer relevant
    so just unify the prefixes on sci_.  The distinction between isci_ and
    sci_ is historically significant, and useful for comparing the old
    'core' to the current Linux driver. 'sci_' represents the former core as
    well as the routines that are closer to the hardware and protocol than
    their 'isci_' brethren. sci == sas controller interface.
    
    Also unwind the 'sds1' out of the parameter structs.
    
    Reported-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/drivers/scsi/isci/port.c b/drivers/scsi/isci/port.c
index c434d5a0effa..1822ed68409e 100644
--- a/drivers/scsi/isci/port.c
+++ b/drivers/scsi/isci/port.c
@@ -74,57 +74,35 @@ static void isci_port_change_state(struct isci_port *iport, enum isci_status sta
 	spin_unlock_irqrestore(&iport->state_lock, flags);
 }
 
-/*
- * This function will indicate which protocols are supported by this port.
- * @sci_port: a handle corresponding to the SAS port for which to return the
- *    supported protocols.
- * @protocols: This parameter specifies a pointer to a data structure
- *    which the core will copy the protocol values for the port from the
- *    transmit_identification register.
- */
-static void
-scic_sds_port_get_protocols(struct isci_port *iport,
-			    struct scic_phy_proto *protocols)
+static void sci_port_get_protocols(struct isci_port *iport, struct sci_phy_proto *proto)
 {
 	u8 index;
 
-	protocols->all = 0;
-
+	proto->all = 0;
 	for (index = 0; index < SCI_MAX_PHYS; index++) {
-		if (iport->phy_table[index] != NULL) {
-			scic_sds_phy_get_protocols(iport->phy_table[index],
-						   protocols);
-		}
+		struct isci_phy *iphy = iport->phy_table[index];
+
+		if (!iphy)
+			continue;
+		sci_phy_get_protocols(iphy, proto);
 	}
 }
 
-/**
- * This method requests a list (mask) of the phys contained in the supplied SAS
- *    port.
- * @sci_port: a handle corresponding to the SAS port for which to return the
- *    phy mask.
- *
- * Return a bit mask indicating which phys are a part of this port. Each bit
- * corresponds to a phy identifier (e.g. bit 0 = phy id 0).
- */
-static u32 scic_sds_port_get_phys(struct isci_port *iport)
+static u32 sci_port_get_phys(struct isci_port *iport)
 {
 	u32 index;
 	u32 mask;
 
 	mask = 0;
-
-	for (index = 0; index < SCI_MAX_PHYS; index++) {
-		if (iport->phy_table[index] != NULL) {
+	for (index = 0; index < SCI_MAX_PHYS; index++)
+		if (iport->phy_table[index])
 			mask |= (1 << index);
-		}
-	}
 
 	return mask;
 }
 
 /**
- * scic_port_get_properties() - This method simply returns the properties
+ * sci_port_get_properties() - This method simply returns the properties
  *    regarding the port, such as: physical index, protocols, sas address, etc.
  * @port: this parameter specifies the port for which to retrieve the physical
  *    index.
@@ -136,22 +114,22 @@ static u32 scic_sds_port_get_phys(struct isci_port *iport)
  * value is returned if the specified port is not valid.  When this value is
  * returned, no data is copied to the properties output parameter.
  */
-static enum sci_status scic_port_get_properties(struct isci_port *iport,
-						struct scic_port_properties *prop)
+static enum sci_status sci_port_get_properties(struct isci_port *iport,
+						struct sci_port_properties *prop)
 {
 	if (!iport || iport->logical_port_index == SCIC_SDS_DUMMY_PORT)
 		return SCI_FAILURE_INVALID_PORT;
 
-	prop->index    = iport->logical_port_index;
-	prop->phy_mask = scic_sds_port_get_phys(iport);
-	scic_sds_port_get_sas_address(iport, &prop->local.sas_address);
-	scic_sds_port_get_protocols(iport, &prop->local.protocols);
-	scic_sds_port_get_attached_sas_address(iport, &prop->remote.sas_address);
+	prop->index = iport->logical_port_index;
+	prop->phy_mask = sci_port_get_phys(iport);
+	sci_port_get_sas_address(iport, &prop->local.sas_address);
+	sci_port_get_protocols(iport, &prop->local.protocols);
+	sci_port_get_attached_sas_address(iport, &prop->remote.sas_address);
 
 	return SCI_SUCCESS;
 }
 
-static void scic_port_bcn_enable(struct isci_port *iport)
+static void sci_port_bcn_enable(struct isci_port *iport)
 {
 	struct isci_phy *iphy;
 	u32 val;
@@ -167,7 +145,7 @@ static void scic_port_bcn_enable(struct isci_port *iport)
 	}
 }
 
-/* called under scic_lock to stabilize phy:port associations */
+/* called under sci_lock to stabilize phy:port associations */
 void isci_port_bcn_enable(struct isci_host *ihost, struct isci_port *iport)
 {
 	int i;
@@ -209,7 +187,7 @@ static void isci_port_bc_change_received(struct isci_host *ihost,
 		ihost->sas_ha.notify_port_event(&iphy->sas_phy,
 						PORTE_BROADCAST_RCVD);
 	}
-	scic_port_bcn_enable(iport);
+	sci_port_bcn_enable(iport);
 }
 
 static void isci_port_link_up(struct isci_host *isci_host,
@@ -217,7 +195,7 @@ static void isci_port_link_up(struct isci_host *isci_host,
 			      struct isci_phy *iphy)
 {
 	unsigned long flags;
-	struct scic_port_properties properties;
+	struct sci_port_properties properties;
 	unsigned long success = true;
 
 	BUG_ON(iphy->isci_port != NULL);
@@ -232,7 +210,7 @@ static void isci_port_link_up(struct isci_host *isci_host,
 
 	isci_port_change_state(iphy->isci_port, isci_starting);
 
-	scic_port_get_properties(iport, &properties);
+	sci_port_get_properties(iport, &properties);
 
 	if (iphy->protocol == SCIC_SDS_PHY_PROTOCOL_SATA) {
 		u64 attached_sas_address;
@@ -245,7 +223,7 @@ static void isci_port_link_up(struct isci_host *isci_host,
 		 * automagically assign a SAS address to the end device
 		 * for the purpose of creating a port. This SAS address
 		 * will not be the same as assigned to the PHY and needs
-		 * to be obtained from struct scic_port_properties properties.
+		 * to be obtained from struct sci_port_properties properties.
 		 */
 		attached_sas_address = properties.remote.sas_address.high;
 		attached_sas_address <<= 32;
@@ -399,50 +377,40 @@ static void isci_port_hard_reset_complete(struct isci_port *isci_port,
  * doesn't preclude all configurations.  It merely ensures that a phy is part
  * of the allowable set of phy identifiers for that port.  For example, one
  * could assign phy 3 to port 0 and no other phys.  Please refer to
- * scic_sds_port_is_phy_mask_valid() for information regarding whether the
+ * sci_port_is_phy_mask_valid() for information regarding whether the
  * phy_mask for a port can be supported. bool true if this is a valid phy
  * assignment for the port false if this is not a valid phy assignment for the
  * port
  */
-bool scic_sds_port_is_valid_phy_assignment(struct isci_port *iport,
-					   u32 phy_index)
+bool sci_port_is_valid_phy_assignment(struct isci_port *iport, u32 phy_index)
 {
+	struct isci_host *ihost = iport->owning_controller;
+	struct sci_user_parameters *user = &ihost->user_parameters;
+
 	/* Initialize to invalid value. */
 	u32 existing_phy_index = SCI_MAX_PHYS;
 	u32 index;
 
-	if ((iport->physical_port_index == 1) && (phy_index != 1)) {
+	if ((iport->physical_port_index == 1) && (phy_index != 1))
 		return false;
-	}
 
-	if (iport->physical_port_index == 3 && phy_index != 3) {
+	if (iport->physical_port_index == 3 && phy_index != 3)
 		return false;
-	}
 
-	if (
-		(iport->physical_port_index == 2)
-		&& ((phy_index == 0) || (phy_index == 1))
-		) {
+	if (iport->physical_port_index == 2 &&
+	    (phy_index == 0 || phy_index == 1))
 		return false;
-	}
 
-	for (index = 0; index < SCI_MAX_PHYS; index++) {
-		if ((iport->phy_table[index] != NULL)
-		    && (index != phy_index)) {
+	for (index = 0; index < SCI_MAX_PHYS; index++)
+		if (iport->phy_table[index] && index != phy_index)
 			existing_phy_index = index;
-		}
-	}
 
-	/*
-	 * Ensure that all of the phys in the port are capable of
-	 * operating at the same maximum link rate. */
-	if (
-		(existing_phy_index < SCI_MAX_PHYS)
-		&& (iport->owning_controller->user_parameters.sds1.phys[
-			    phy_index].max_speed_generation !=
-		    iport->owning_controller->user_parameters.sds1.phys[
-			    existing_phy_index].max_speed_generation)
-		)
+	/* Ensure that all of the phys in the port are capable of
+	 * operating at the same maximum link rate.
+	 */
+	if (existing_phy_index < SCI_MAX_PHYS &&
+	    user->phys[phy_index].max_speed_generation !=
+	    user->phys[existing_phy_index].max_speed_generation)
 		return false;
 
 	return true;
@@ -460,7 +428,7 @@ bool scic_sds_port_is_valid_phy_assignment(struct isci_port *iport,
  * phy mask can be supported. true if this is a valid phy assignment for the
  * port false if this is not a valid phy assignment for the port
  */
-static bool scic_sds_port_is_phy_mask_valid(
+static bool sci_port_is_phy_mask_valid(
 	struct isci_port *iport,
 	u32 phy_mask)
 {
@@ -493,10 +461,10 @@ static bool scic_sds_port_is_phy_mask_valid(
  * the port.  Currently, the lowest order phy that is connected is returned.
  * This method returns a pointer to a SCIS_SDS_PHY object. NULL This value is
  * returned if there are no currently active (i.e. connected to a remote end
- * point) phys contained in the port. All other values specify a struct scic_sds_phy
+ * point) phys contained in the port. All other values specify a struct sci_phy
  * object that is active in the port.
  */
-static struct isci_phy *scic_sds_port_get_a_connected_phy(struct isci_port *iport)
+static struct isci_phy *sci_port_get_a_connected_phy(struct isci_port *iport)
 {
 	u32 index;
 	struct isci_phy *iphy;
@@ -506,14 +474,14 @@ static struct isci_phy *scic_sds_port_get_a_connected_phy(struct isci_port *ipor
 		 * connected to the remote end-point.
 		 */
 		iphy = iport->phy_table[index];
-		if (iphy && scic_sds_port_active_phy(iport, iphy))
+		if (iphy && sci_port_active_phy(iport, iphy))
 			return iphy;
 	}
 
 	return NULL;
 }
 
-static enum sci_status scic_sds_port_set_phy(struct isci_port *iport, struct isci_phy *iphy)
+static enum sci_status sci_port_set_phy(struct isci_port *iport, struct isci_phy *iphy)
 {
 	/* Check to see if we can add this phy to a port
 	 * that means that the phy is not part of a port and that the port does
@@ -521,13 +489,13 @@ static enum sci_status scic_sds_port_set_phy(struct isci_port *iport, struct isc
 	 */
 	if (!iport->phy_table[iphy->phy_index] &&
 	    !phy_get_non_dummy_port(iphy) &&
-	    scic_sds_port_is_valid_phy_assignment(iport, iphy->phy_index)) {
+	    sci_port_is_valid_phy_assignment(iport, iphy->phy_index)) {
 		/* Phy is being added in the stopped state so we are in MPC mode
 		 * make logical port index = physical port index
 		 */
 		iport->logical_port_index = iport->physical_port_index;
 		iport->phy_table[iphy->phy_index] = iphy;
-		scic_sds_phy_set_port(iphy, iport);
+		sci_phy_set_port(iphy, iport);
 
 		return SCI_SUCCESS;
 	}
@@ -535,8 +503,7 @@ static enum sci_status scic_sds_port_set_phy(struct isci_port *iport, struct isc
 	return SCI_FAILURE;
 }
 
-static enum sci_status scic_sds_port_clear_phy(struct isci_port *iport,
-					       struct isci_phy *iphy)
+static enum sci_status sci_port_clear_phy(struct isci_port *iport, struct isci_phy *iphy)
 {
 	/* Make sure that this phy is part of this port */
 	if (iport->phy_table[iphy->phy_index] == iphy &&
@@ -544,7 +511,7 @@ static enum sci_status scic_sds_port_clear_phy(struct isci_port *iport,
 		struct isci_host *ihost = iport->owning_controller;
 
 		/* Yep it is assigned to this port so remove it */
-		scic_sds_phy_set_port(iphy, &ihost->ports[SCI_MAX_PORTS]);
+		sci_phy_set_port(iphy, &ihost->ports[SCI_MAX_PORTS]);
 		iport->phy_table[iphy->phy_index] = NULL;
 		return SCI_SUCCESS;
 	}
@@ -552,45 +519,18 @@ static enum sci_status scic_sds_port_clear_phy(struct isci_port *iport,
 	return SCI_FAILURE;
 }
 
-
-/**
- * This method requests the SAS address for the supplied SAS port from the SCI
- *    implementation.
- * @sci_port: a handle corresponding to the SAS port for which to return the
- *    SAS address.
- * @sas_address: This parameter specifies a pointer to a SAS address structure
- *    into which the core will copy the SAS address for the port.
- *
- */
-void scic_sds_port_get_sas_address(
-	struct isci_port *iport,
-	struct sci_sas_address *sas_address)
+void sci_port_get_sas_address(struct isci_port *iport, struct sci_sas_address *sas)
 {
 	u32 index;
 
-	sas_address->high = 0;
-	sas_address->low  = 0;
-
-	for (index = 0; index < SCI_MAX_PHYS; index++) {
-		if (iport->phy_table[index] != NULL) {
-			scic_sds_phy_get_sas_address(iport->phy_table[index], sas_address);
-		}
-	}
+	sas->high = 0;
+	sas->low  = 0;
+	for (index = 0; index < SCI_MAX_PHYS; index++)
+		if (iport->phy_table[index])
+			sci_phy_get_sas_address(iport->phy_table[index], sas);
 }
 
-/*
- * This function requests the SAS address for the device directly attached to
- *    this SAS port.
- * @sci_port: a handle corresponding to the SAS port for which to return the
- *    SAS address.
- * @sas_address: This parameter specifies a pointer to a SAS address structure
- *    into which the core will copy the SAS address for the device directly
- *    attached to the port.
- *
- */
-void scic_sds_port_get_attached_sas_address(
-	struct isci_port *iport,
-	struct sci_sas_address *sas_address)
+void sci_port_get_attached_sas_address(struct isci_port *iport, struct sci_sas_address *sas)
 {
 	struct isci_phy *iphy;
 
@@ -598,23 +538,22 @@ void scic_sds_port_get_attached_sas_address(
 	 * Ensure that the phy is both part of the port and currently
 	 * connected to the remote end-point.
 	 */
-	iphy = scic_sds_port_get_a_connected_phy(iport);
+	iphy = sci_port_get_a_connected_phy(iport);
 	if (iphy) {
 		if (iphy->protocol != SCIC_SDS_PHY_PROTOCOL_SATA) {
-			scic_sds_phy_get_attached_sas_address(iphy,
-							      sas_address);
+			sci_phy_get_attached_sas_address(iphy, sas);
 		} else {
-			scic_sds_phy_get_sas_address(iphy, sas_address);
-			sas_address->low += iphy->phy_index;
+			sci_phy_get_sas_address(iphy, sas);
+			sas->low += iphy->phy_index;
 		}
 	} else {
-		sas_address->high = 0;
-		sas_address->low  = 0;
+		sas->high = 0;
+		sas->low  = 0;
 	}
 }
 
 /**
- * scic_sds_port_construct_dummy_rnc() - create dummy rnc for si workaround
+ * sci_port_construct_dummy_rnc() - create dummy rnc for si workaround
  *
  * @sci_port: logical port on which we need to create the remote node context
  * @rni: remote node index for this remote node context.
@@ -623,7 +562,7 @@ void scic_sds_port_get_attached_sas_address(
  * This structure will be posted to the hardware to work around a scheduler
  * error in the hardware.
  */
-static void scic_sds_port_construct_dummy_rnc(struct isci_port *iport, u16 rni)
+static void sci_port_construct_dummy_rnc(struct isci_port *iport, u16 rni)
 {
 	union scu_remote_node_context *rnc;
 
@@ -651,7 +590,7 @@ static void scic_sds_port_construct_dummy_rnc(struct isci_port *iport, u16 rni)
  * structure will be posted to the hardwre to work around a scheduler error
  * in the hardware.
  */
-static void scic_sds_port_construct_dummy_task(struct isci_port *iport, u16 tag)
+static void sci_port_construct_dummy_task(struct isci_port *iport, u16 tag)
 {
 	struct isci_host *ihost = iport->owning_controller;
 	struct scu_task_context *task_context;
@@ -671,7 +610,7 @@ static void scic_sds_port_construct_dummy_task(struct isci_port *iport, u16 tag)
 	task_context->task_phase = 0x01;
 }
 
-static void scic_sds_port_destroy_dummy_resources(struct isci_port *iport)
+static void sci_port_destroy_dummy_resources(struct isci_port *iport)
 {
 	struct isci_host *ihost = iport->owning_controller;
 
@@ -679,93 +618,43 @@ static void scic_sds_port_destroy_dummy_resources(struct isci_port *iport)
 		isci_free_tag(ihost, iport->reserved_tag);
 
 	if (iport->reserved_rni != SCU_DUMMY_INDEX)
-		scic_sds_remote_node_table_release_remote_node_index(&ihost->available_remote_nodes,
+		sci_remote_node_table_release_remote_node_index(&ihost->available_remote_nodes,
 								     1, iport->reserved_rni);
 
 	iport->reserved_rni = SCU_DUMMY_INDEX;
 	iport->reserved_tag = SCI_CONTROLLER_INVALID_IO_TAG;
 }
 
-/**
- * This method performs initialization of the supplied port. Initialization
- *    includes: - state machine initialization - member variable initialization
- *    - configuring the phy_mask
- * @sci_port:
- * @transport_layer_registers:
- * @port_task_scheduler_registers:
- * @port_configuration_regsiter:
- *
- * enum sci_status SCI_FAILURE_UNSUPPORTED_PORT_CONFIGURATION This value is returned
- * if the phy being added to the port
- */
-enum sci_status scic_sds_port_initialize(
-	struct isci_port *iport,
-	void __iomem *port_task_scheduler_registers,
-	void __iomem *port_configuration_regsiter,
-	void __iomem *viit_registers)
-{
-	iport->port_task_scheduler_registers  = port_task_scheduler_registers;
-	iport->port_pe_configuration_register = port_configuration_regsiter;
-	iport->viit_registers                 = viit_registers;
-
-	return SCI_SUCCESS;
-}
-
-
-/**
- * This method assigns the direct attached device ID for this port.
- *
- * @param[in] iport The port for which the direct attached device id is to
- *       be assigned.
- * @param[in] device_id The direct attached device ID to assign to the port.
- *       This will be the RNi for the device
- */
-void scic_sds_port_setup_transports(
-	struct isci_port *iport,
-	u32 device_id)
+void sci_port_setup_transports(struct isci_port *iport, u32 device_id)
 {
 	u8 index;
 
 	for (index = 0; index < SCI_MAX_PHYS; index++) {
 		if (iport->active_phy_mask & (1 << index))
-			scic_sds_phy_setup_transport(iport->phy_table[index], device_id);
+			sci_phy_setup_transport(iport->phy_table[index], device_id);
 	}
 }
 
-/**
- *
- * @sci_port: This is the port on which the phy should be enabled.
- * @sci_phy: This is the specific phy which to enable.
- * @do_notify_user: This parameter specifies whether to inform the user (via
- *    scic_cb_port_link_up()) as to the fact that a new phy as become ready.
- *
- * This function will activate the phy in the port.
- * Activation includes: - adding
- * the phy to the port - enabling the Protocol Engine in the silicon. -
- * notifying the user that the link is up. none
- */
-static void scic_sds_port_activate_phy(struct isci_port *iport,
-				       struct isci_phy *iphy,
-				       bool do_notify_user)
+static void sci_port_activate_phy(struct isci_port *iport, struct isci_phy *iphy,
+				  bool do_notify_user)
 {
 	struct isci_host *ihost = iport->owning_controller;
 
 	if (iphy->protocol != SCIC_SDS_PHY_PROTOCOL_SATA)
-		scic_sds_phy_resume(iphy);
+		sci_phy_resume(iphy);
 
 	iport->active_phy_mask |= 1 << iphy->phy_index;
 
-	scic_sds_controller_clear_invalid_phy(ihost, iphy);
+	sci_controller_clear_invalid_phy(ihost, iphy);
 
 	if (do_notify_user == true)
 		isci_port_link_up(ihost, iport, iphy);
 }
 
-void scic_sds_port_deactivate_phy(struct isci_port *iport,
-				  struct isci_phy *iphy,
-				  bool do_notify_user)
+void sci_port_deactivate_phy(struct isci_port *iport, struct isci_phy *iphy,
+			     bool do_notify_user)
 {
-	struct isci_host *ihost = scic_sds_port_get_controller(iport);
+	struct isci_host *ihost = sci_port_get_controller(iport);
 
 	iport->active_phy_mask &= ~(1 << iphy->phy_index);
 
@@ -779,16 +668,7 @@ void scic_sds_port_deactivate_phy(struct isci_port *iport,
 		isci_port_link_down(ihost, iphy, iport);
 }
 
-/**
- *
- * @sci_port: This is the port on which the phy should be disabled.
- * @sci_phy: This is the specific phy which to disabled.
- *
- * This function will disable the phy and report that the phy is not valid for
- * this port object. None
- */
-static void scic_sds_port_invalid_link_up(struct isci_port *iport,
-					  struct isci_phy *iphy)
+static void sci_port_invalid_link_up(struct isci_port *iport, struct isci_phy *iphy)
 {
 	struct isci_host *ihost = iport->owning_controller;
 
@@ -798,12 +678,12 @@ static void scic_sds_port_invalid_link_up(struct isci_port *iport,
 	 * invalid link.
 	 */
 	if ((ihost->invalid_phy_mask & (1 << iphy->phy_index)) == 0) {
-		scic_sds_controller_set_invalid_phy(ihost, iphy);
+		sci_controller_set_invalid_phy(ihost, iphy);
 		dev_warn(&ihost->pdev->dev, "Invalid link up!\n");
 	}
 }
 
-static bool is_port_ready_state(enum scic_sds_port_states state)
+static bool is_port_ready_state(enum sci_port_states state)
 {
 	switch (state) {
 	case SCI_PORT_READY:
@@ -818,10 +698,10 @@ static bool is_port_ready_state(enum scic_sds_port_states state)
 
 /* flag dummy rnc hanling when exiting a ready state */
 static void port_state_machine_change(struct isci_port *iport,
-				      enum scic_sds_port_states state)
+				      enum sci_port_states state)
 {
 	struct sci_base_state_machine *sm = &iport->sm;
-	enum scic_sds_port_states old_state = sm->current_state_id;
+	enum sci_port_states old_state = sm->current_state_id;
 
 	if (is_port_ready_state(old_state) && !is_port_ready_state(state))
 		iport->ready_exit = true;
@@ -831,11 +711,11 @@ static void port_state_machine_change(struct isci_port *iport,
 }
 
 /**
- * scic_sds_port_general_link_up_handler - phy can be assigned to port?
- * @sci_port: scic_sds_port object for which has a phy that has gone link up.
+ * sci_port_general_link_up_handler - phy can be assigned to port?
+ * @sci_port: sci_port object for which has a phy that has gone link up.
  * @sci_phy: This is the struct isci_phy object that has gone link up.
  * @do_notify_user: This parameter specifies whether to inform the user (via
- *    scic_cb_port_link_up()) as to the fact that a new phy as become ready.
+ *    sci_port_link_up()) as to the fact that a new phy as become ready.
  *
  * Determine if this phy can be assigned to this
  * port . If the phy is not a valid PHY for
@@ -843,15 +723,15 @@ static void port_state_machine_change(struct isci_port *iport,
  * part of a port if it's attached SAS ADDRESS is the same as all other PHYs in
  * the same port. none
  */
-static void scic_sds_port_general_link_up_handler(struct isci_port *iport,
+static void sci_port_general_link_up_handler(struct isci_port *iport,
 						  struct isci_phy *iphy,
 						  bool do_notify_user)
 {
 	struct sci_sas_address port_sas_address;
 	struct sci_sas_address phy_sas_address;
 
-	scic_sds_port_get_attached_sas_address(iport, &port_sas_address);
-	scic_sds_phy_get_attached_sas_address(iphy, &phy_sas_address);
+	sci_port_get_attached_sas_address(iport, &port_sas_address);
+	sci_phy_get_attached_sas_address(iphy, &phy_sas_address);
 
 	/* If the SAS address of the new phy matches the SAS address of
 	 * other phys in the port OR this is the first phy in the port,
@@ -863,11 +743,11 @@ static void scic_sds_port_general_link_up_handler(struct isci_port *iport,
 	    iport->active_phy_mask == 0) {
 		struct sci_base_state_machine *sm = &iport->sm;
 
-		scic_sds_port_activate_phy(iport, iphy, do_notify_user);
+		sci_port_activate_phy(iport, iphy, do_notify_user);
 		if (sm->current_state_id == SCI_PORT_RESETTING)
 			port_state_machine_change(iport, SCI_PORT_READY);
 	} else
-		scic_sds_port_invalid_link_up(iport, iphy);
+		sci_port_invalid_link_up(iport, iphy);
 }
 
 
@@ -881,7 +761,7 @@ static void scic_sds_port_general_link_up_handler(struct isci_port *iport,
  * bool true Is returned if this is a wide ported port. false Is returned if
  * this is a narrow port.
  */
-static bool scic_sds_port_is_wide(struct isci_port *iport)
+static bool sci_port_is_wide(struct isci_port *iport)
 {
 	u32 index;
 	u32 phy_count = 0;
@@ -909,14 +789,14 @@ static bool scic_sds_port_is_wide(struct isci_port *iport)
  * wide ports and direct attached phys.  Since there are no wide ported SATA
  * devices this could become an invalid port configuration.
  */
-bool scic_sds_port_link_detected(
+bool sci_port_link_detected(
 	struct isci_port *iport,
 	struct isci_phy *iphy)
 {
 	if ((iport->logical_port_index != SCIC_SDS_DUMMY_PORT) &&
 	    (iphy->protocol == SCIC_SDS_PHY_PROTOCOL_SATA) &&
-	    scic_sds_port_is_wide(iport)) {
-		scic_sds_port_invalid_link_up(iport, iphy);
+	    sci_port_is_wide(iport)) {
+		sci_port_invalid_link_up(iport, iphy);
 
 		return false;
 	}
@@ -977,11 +857,11 @@ static void port_timeout(unsigned long data)
  *
  *
  */
-static void scic_sds_port_update_viit_entry(struct isci_port *iport)
+static void sci_port_update_viit_entry(struct isci_port *iport)
 {
 	struct sci_sas_address sas_address;
 
-	scic_sds_port_get_sas_address(iport, &sas_address);
+	sci_port_get_sas_address(iport, &sas_address);
 
 	writel(sas_address.high,
 		&iport->viit_registers->initiator_sas_address_hi);
@@ -999,7 +879,7 @@ static void scic_sds_port_update_viit_entry(struct isci_port *iport)
 	       &iport->viit_registers->status);
 }
 
-enum sas_linkrate scic_sds_port_get_max_allowed_speed(struct isci_port *iport)
+enum sas_linkrate sci_port_get_max_allowed_speed(struct isci_port *iport)
 {
 	u16 index;
 	struct isci_phy *iphy;
@@ -1010,7 +890,7 @@ enum sas_linkrate scic_sds_port_get_max_allowed_speed(struct isci_port *iport)
 	 * lowest maximum link rate. */
 	for (index = 0; index < SCI_MAX_PHYS; index++) {
 		iphy = iport->phy_table[index];
-		if (iphy && scic_sds_port_active_phy(iport, iphy) &&
+		if (iphy && sci_port_active_phy(iport, iphy) &&
 		    iphy->max_negotiated_speed < max_allowed_speed)
 			max_allowed_speed = iphy->max_negotiated_speed;
 	}
@@ -1018,7 +898,7 @@ enum sas_linkrate scic_sds_port_get_max_allowed_speed(struct isci_port *iport)
 	return max_allowed_speed;
 }
 
-static void scic_sds_port_suspend_port_task_scheduler(struct isci_port *iport)
+static void sci_port_suspend_port_task_scheduler(struct isci_port *iport)
 {
 	u32 pts_control_value;
 
@@ -1028,7 +908,7 @@ static void scic_sds_port_suspend_port_task_scheduler(struct isci_port *iport)
 }
 
 /**
- * scic_sds_port_post_dummy_request() - post dummy/workaround request
+ * sci_port_post_dummy_request() - post dummy/workaround request
  * @sci_port: port to post task
  *
  * Prevent the hardware scheduler from posting new requests to the front
@@ -1036,7 +916,7 @@ static void scic_sds_port_suspend_port_task_scheduler(struct isci_port *iport)
  * ongoing requests.
  *
  */
-static void scic_sds_port_post_dummy_request(struct isci_port *iport)
+static void sci_port_post_dummy_request(struct isci_port *iport)
 {
 	struct isci_host *ihost = iport->owning_controller;
 	u16 tag = iport->reserved_tag;
@@ -1050,7 +930,7 @@ static void scic_sds_port_post_dummy_request(struct isci_port *iport)
 		  iport->physical_port_index << SCU_CONTEXT_COMMAND_LOGICAL_PORT_SHIFT |
 		  ISCI_TAG_TCI(tag);
 
-	scic_sds_controller_post_request(ihost, command);
+	sci_controller_post_request(ihost, command);
 }
 
 /**
@@ -1060,7 +940,7 @@ static void scic_sds_port_post_dummy_request(struct isci_port *iport)
  * @sci_port: The port on which the task must be aborted.
  *
  */
-static void scic_sds_port_abort_dummy_request(struct isci_port *iport)
+static void sci_port_abort_dummy_request(struct isci_port *iport)
 {
 	struct isci_host *ihost = iport->owning_controller;
 	u16 tag = iport->reserved_tag;
@@ -1074,7 +954,7 @@ static void scic_sds_port_abort_dummy_request(struct isci_port *iport)
 		  iport->physical_port_index << SCU_CONTEXT_COMMAND_LOGICAL_PORT_SHIFT |
 		  ISCI_TAG_TCI(tag);
 
-	scic_sds_controller_post_request(ihost, command);
+	sci_controller_post_request(ihost, command);
 }
 
 /**
@@ -1084,7 +964,7 @@ static void scic_sds_port_abort_dummy_request(struct isci_port *iport)
  * This method will resume the port task scheduler for this port object. none
  */
 static void
-scic_sds_port_resume_port_task_scheduler(struct isci_port *iport)
+sci_port_resume_port_task_scheduler(struct isci_port *iport)
 {
 	u32 pts_control_value;
 
@@ -1093,11 +973,11 @@ scic_sds_port_resume_port_task_scheduler(struct isci_port *iport)
 	writel(pts_control_value, &iport->port_task_scheduler_registers->control);
 }
 
-static void scic_sds_port_ready_substate_waiting_enter(struct sci_base_state_machine *sm)
+static void sci_port_ready_substate_waiting_enter(struct sci_base_state_machine *sm)
 {
 	struct isci_port *iport = container_of(sm, typeof(*iport), sm);
 
-	scic_sds_port_suspend_port_task_scheduler(iport);
+	sci_port_suspend_port_task_scheduler(iport);
 
 	iport->not_ready_reason = SCIC_PORT_NOT_READY_NO_ACTIVE_PHYS;
 
@@ -1108,7 +988,7 @@ static void scic_sds_port_ready_substate_waiting_enter(struct sci_base_state_mac
 	}
 }
 
-static void scic_sds_port_ready_substate_operational_enter(struct sci_base_state_machine *sm)
+static void sci_port_ready_substate_operational_enter(struct sci_base_state_machine *sm)
 {
 	u32 index;
 	struct isci_port *iport = container_of(sm, typeof(*iport), sm);
@@ -1124,18 +1004,18 @@ static void scic_sds_port_ready_substate_operational_enter(struct sci_base_state
 		}
 	}
 
-	scic_sds_port_update_viit_entry(iport);
+	sci_port_update_viit_entry(iport);
 
-	scic_sds_port_resume_port_task_scheduler(iport);
+	sci_port_resume_port_task_scheduler(iport);
 
 	/*
 	 * Post the dummy task for the port so the hardware can schedule
 	 * io correctly
 	 */
-	scic_sds_port_post_dummy_request(iport);
+	sci_port_post_dummy_request(iport);
 }
 
-static void scic_sds_port_invalidate_dummy_remote_node(struct isci_port *iport)
+static void sci_port_invalidate_dummy_remote_node(struct isci_port *iport)
 {
 	struct isci_host *ihost = iport->owning_controller;
 	u8 phys_index = iport->physical_port_index;
@@ -1157,7 +1037,7 @@ static void scic_sds_port_invalidate_dummy_remote_node(struct isci_port *iport)
 	command = SCU_CONTEXT_COMMAND_POST_RNC_INVALIDATE |
 		  phys_index << SCU_CONTEXT_COMMAND_LOGICAL_PORT_SHIFT | rni;
 
-	scic_sds_controller_post_request(ihost, command);
+	sci_controller_post_request(ihost, command);
 }
 
 /**
@@ -1168,7 +1048,7 @@ static void scic_sds_port_invalidate_dummy_remote_node(struct isci_port *iport)
  * exiting the SCI_PORT_SUB_OPERATIONAL. This function reports
  * the port not ready and suspends the port task scheduler. none
  */
-static void scic_sds_port_ready_substate_operational_exit(struct sci_base_state_machine *sm)
+static void sci_port_ready_substate_operational_exit(struct sci_base_state_machine *sm)
 {
 	struct isci_port *iport = container_of(sm, typeof(*iport), sm);
 	struct isci_host *ihost = iport->owning_controller;
@@ -1178,15 +1058,15 @@ static void scic_sds_port_ready_substate_operational_exit(struct sci_base_state_
 	 * the hardware will treat this as a NOP and just return abort
 	 * complete.
 	 */
-	scic_sds_port_abort_dummy_request(iport);
+	sci_port_abort_dummy_request(iport);
 
 	isci_port_not_ready(ihost, iport);
 
 	if (iport->ready_exit)
-		scic_sds_port_invalidate_dummy_remote_node(iport);
+		sci_port_invalidate_dummy_remote_node(iport);
 }
 
-static void scic_sds_port_ready_substate_configuring_enter(struct sci_base_state_machine *sm)
+static void sci_port_ready_substate_configuring_enter(struct sci_base_state_machine *sm)
 {
 	struct isci_port *iport = container_of(sm, typeof(*iport), sm);
 	struct isci_host *ihost = iport->owning_controller;
@@ -1201,20 +1081,20 @@ static void scic_sds_port_ready_substate_configuring_enter(struct sci_base_state
 					  SCI_PORT_SUB_OPERATIONAL);
 }
 
-static void scic_sds_port_ready_substate_configuring_exit(struct sci_base_state_machine *sm)
+static void sci_port_ready_substate_configuring_exit(struct sci_base_state_machine *sm)
 {
 	struct isci_port *iport = container_of(sm, typeof(*iport), sm);
 
-	scic_sds_port_suspend_port_task_scheduler(iport);
+	sci_port_suspend_port_task_scheduler(iport);
 	if (iport->ready_exit)
-		scic_sds_port_invalidate_dummy_remote_node(iport);
+		sci_port_invalidate_dummy_remote_node(iport);
 }
 
-enum sci_status scic_sds_port_start(struct isci_port *iport)
+enum sci_status sci_port_start(struct isci_port *iport)
 {
 	struct isci_host *ihost = iport->owning_controller;
 	enum sci_status status = SCI_SUCCESS;
-	enum scic_sds_port_states state;
+	enum sci_port_states state;
 	u32 phy_mask;
 
 	state = iport->sm.current_state_id;
@@ -1234,11 +1114,11 @@ enum sci_status scic_sds_port_start(struct isci_port *iport)
 	}
 
 	if (iport->reserved_rni == SCU_DUMMY_INDEX) {
-		u16 rni = scic_sds_remote_node_table_allocate_remote_node(
+		u16 rni = sci_remote_node_table_allocate_remote_node(
 				&ihost->available_remote_nodes, 1);
 
 		if (rni != SCU_DUMMY_INDEX)
-			scic_sds_port_construct_dummy_rnc(iport, rni);
+			sci_port_construct_dummy_rnc(iport, rni);
 		else
 			status = SCI_FAILURE_INSUFFICIENT_RESOURCES;
 		iport->reserved_rni = rni;
@@ -1251,19 +1131,19 @@ enum sci_status scic_sds_port_start(struct isci_port *iport)
 		if (tag == SCI_CONTROLLER_INVALID_IO_TAG)
 			status = SCI_FAILURE_INSUFFICIENT_RESOURCES;
 		else
-			scic_sds_port_construct_dummy_task(iport, tag);
+			sci_port_construct_dummy_task(iport, tag);
 		iport->reserved_tag = tag;
 	}
 
 	if (status == SCI_SUCCESS) {
-		phy_mask = scic_sds_port_get_phys(iport);
+		phy_mask = sci_port_get_phys(iport);
 
 		/*
 		 * There are one or more phys assigned to this port.  Make sure
 		 * the port's phy mask is in fact legal and supported by the
 		 * silicon.
 		 */
-		if (scic_sds_port_is_phy_mask_valid(iport, phy_mask) == true) {
+		if (sci_port_is_phy_mask_valid(iport, phy_mask) == true) {
 			port_state_machine_change(iport,
 						  SCI_PORT_READY);
 
@@ -1273,14 +1153,14 @@ enum sci_status scic_sds_port_start(struct isci_port *iport)
 	}
 
 	if (status != SCI_SUCCESS)
-		scic_sds_port_destroy_dummy_resources(iport);
+		sci_port_destroy_dummy_resources(iport);
 
 	return status;
 }
 
-enum sci_status scic_sds_port_stop(struct isci_port *iport)
+enum sci_status sci_port_stop(struct isci_port *iport)
 {
-	enum scic_sds_port_states state;
+	enum sci_port_states state;
 
 	state = iport->sm.current_state_id;
 	switch (state) {
@@ -1300,11 +1180,11 @@ enum sci_status scic_sds_port_stop(struct isci_port *iport)
 	}
 }
 
-static enum sci_status scic_port_hard_reset(struct isci_port *iport, u32 timeout)
+static enum sci_status sci_port_hard_reset(struct isci_port *iport, u32 timeout)
 {
 	enum sci_status status = SCI_FAILURE_INVALID_PHY;
 	struct isci_phy *iphy = NULL;
-	enum scic_sds_port_states state;
+	enum sci_port_states state;
 	u32 phy_index;
 
 	state = iport->sm.current_state_id;
@@ -1317,7 +1197,7 @@ static enum sci_status scic_port_hard_reset(struct isci_port *iport, u32 timeout
 	/* Select a phy on which we can send the hard reset request. */
 	for (phy_index = 0; phy_index < SCI_MAX_PHYS && !iphy; phy_index++) {
 		iphy = iport->phy_table[phy_index];
-		if (iphy && !scic_sds_port_active_phy(iport, iphy)) {
+		if (iphy && !sci_port_active_phy(iport, iphy)) {
 			/*
 			 * We found a phy but it is not ready select
 			 * different phy
@@ -1329,7 +1209,7 @@ static enum sci_status scic_port_hard_reset(struct isci_port *iport, u32 timeout
 	/* If we have a phy then go ahead and start the reset procedure */
 	if (!iphy)
 		return status;
-	status = scic_sds_phy_reset(iphy);
+	status = sci_phy_reset(iphy);
 
 	if (status != SCI_SUCCESS)
 		return status;
@@ -1342,7 +1222,7 @@ static enum sci_status scic_port_hard_reset(struct isci_port *iport, u32 timeout
 }
 
 /**
- * scic_sds_port_add_phy() -
+ * sci_port_add_phy() -
  * @sci_port: This parameter specifies the port in which the phy will be added.
  * @sci_phy: This parameter is the phy which is to be added to the port.
  *
@@ -1350,11 +1230,11 @@ static enum sci_status scic_port_hard_reset(struct isci_port *iport, u32 timeout
  * enum sci_status. SCI_SUCCESS the phy has been added to the port. Any other
  * status is a failure to add the phy to the port.
  */
-enum sci_status scic_sds_port_add_phy(struct isci_port *iport,
+enum sci_status sci_port_add_phy(struct isci_port *iport,
 				      struct isci_phy *iphy)
 {
 	enum sci_status status;
-	enum scic_sds_port_states state;
+	enum sci_port_states state;
 
 	state = iport->sm.current_state_id;
 	switch (state) {
@@ -1362,7 +1242,7 @@ enum sci_status scic_sds_port_add_phy(struct isci_port *iport,
 		struct sci_sas_address port_sas_address;
 
 		/* Read the port assigned SAS Address if there is one */
-		scic_sds_port_get_sas_address(iport, &port_sas_address);
+		sci_port_get_sas_address(iport, &port_sas_address);
 
 		if (port_sas_address.high != 0 && port_sas_address.low != 0) {
 			struct sci_sas_address phy_sas_address;
@@ -1370,32 +1250,32 @@ enum sci_status scic_sds_port_add_phy(struct isci_port *iport,
 			/* Make sure that the PHY SAS Address matches the SAS Address
 			 * for this port
 			 */
-			scic_sds_phy_get_sas_address(iphy, &phy_sas_address);
+			sci_phy_get_sas_address(iphy, &phy_sas_address);
 
 			if (port_sas_address.high != phy_sas_address.high ||
 			    port_sas_address.low  != phy_sas_address.low)
 				return SCI_FAILURE_UNSUPPORTED_PORT_CONFIGURATION;
 		}
-		return scic_sds_port_set_phy(iport, iphy);
+		return sci_port_set_phy(iport, iphy);
 	}
 	case SCI_PORT_SUB_WAITING:
 	case SCI_PORT_SUB_OPERATIONAL:
-		status = scic_sds_port_set_phy(iport, iphy);
+		status = sci_port_set_phy(iport, iphy);
 
 		if (status != SCI_SUCCESS)
 			return status;
 
-		scic_sds_port_general_link_up_handler(iport, iphy, true);
+		sci_port_general_link_up_handler(iport, iphy, true);
 		iport->not_ready_reason = SCIC_PORT_NOT_READY_RECONFIGURING;
 		port_state_machine_change(iport, SCI_PORT_SUB_CONFIGURING);
 
 		return status;
 	case SCI_PORT_SUB_CONFIGURING:
-		status = scic_sds_port_set_phy(iport, iphy);
+		status = sci_port_set_phy(iport, iphy);
 
 		if (status != SCI_SUCCESS)
 			return status;
-		scic_sds_port_general_link_up_handler(iport, iphy, true);
+		sci_port_general_link_up_handler(iport, iphy, true);
 
 		/* Re-enter the configuring state since this may be the last phy in
 		 * the port.
@@ -1411,7 +1291,7 @@ enum sci_status scic_sds_port_add_phy(struct isci_port *iport,
 }
 
 /**
- * scic_sds_port_remove_phy() -
+ * sci_port_remove_phy() -
  * @sci_port: This parameter specifies the port in which the phy will be added.
  * @sci_phy: This parameter is the phy which is to be added to the port.
  *
@@ -1419,33 +1299,33 @@ enum sci_status scic_sds_port_add_phy(struct isci_port *iport,
  * an enum sci_status. SCI_SUCCESS the phy has been removed from the port. Any
  * other status is a failure to add the phy to the port.
  */
-enum sci_status scic_sds_port_remove_phy(struct isci_port *iport,
+enum sci_status sci_port_remove_phy(struct isci_port *iport,
 					 struct isci_phy *iphy)
 {
 	enum sci_status status;
-	enum scic_sds_port_states state;
+	enum sci_port_states state;
 
 	state = iport->sm.current_state_id;
 
 	switch (state) {
 	case SCI_PORT_STOPPED:
-		return scic_sds_port_clear_phy(iport, iphy);
+		return sci_port_clear_phy(iport, iphy);
 	case SCI_PORT_SUB_OPERATIONAL:
-		status = scic_sds_port_clear_phy(iport, iphy);
+		status = sci_port_clear_phy(iport, iphy);
 		if (status != SCI_SUCCESS)
 			return status;
 
-		scic_sds_port_deactivate_phy(iport, iphy, true);
+		sci_port_deactivate_phy(iport, iphy, true);
 		iport->not_ready_reason = SCIC_PORT_NOT_READY_RECONFIGURING;
 		port_state_machine_change(iport,
 					  SCI_PORT_SUB_CONFIGURING);
 		return SCI_SUCCESS;
 	case SCI_PORT_SUB_CONFIGURING:
-		status = scic_sds_port_clear_phy(iport, iphy);
+		status = sci_port_clear_phy(iport, iphy);
 
 		if (status != SCI_SUCCESS)
 			return status;
-		scic_sds_port_deactivate_phy(iport, iphy, true);
+		sci_port_deactivate_phy(iport, iphy, true);
 
 		/* Re-enter the configuring state since this may be the last phy in
 		 * the port
@@ -1460,10 +1340,10 @@ enum sci_status scic_sds_port_remove_phy(struct isci_port *iport,
 	}
 }
 
-enum sci_status scic_sds_port_link_up(struct isci_port *iport,
+enum sci_status sci_port_link_up(struct isci_port *iport,
 				      struct isci_phy *iphy)
 {
-	enum scic_sds_port_states state;
+	enum sci_port_states state;
 
 	state = iport->sm.current_state_id;
 	switch (state) {
@@ -1471,13 +1351,13 @@ enum sci_status scic_sds_port_link_up(struct isci_port *iport,
 		/* Since this is the first phy going link up for the port we
 		 * can just enable it and continue
 		 */
-		scic_sds_port_activate_phy(iport, iphy, true);
+		sci_port_activate_phy(iport, iphy, true);
 
 		port_state_machine_change(iport,
 					  SCI_PORT_SUB_OPERATIONAL);
 		return SCI_SUCCESS;
 	case SCI_PORT_SUB_OPERATIONAL:
-		scic_sds_port_general_link_up_handler(iport, iphy, true);
+		sci_port_general_link_up_handler(iport, iphy, true);
 		return SCI_SUCCESS;
 	case SCI_PORT_RESETTING:
 		/* TODO We should  make  sure  that  the phy  that  has gone
@@ -1494,7 +1374,7 @@ enum sci_status scic_sds_port_link_up(struct isci_port *iport,
 		/* In the resetting state we don't notify the user regarding
 		 * link up and link down notifications.
 		 */
-		scic_sds_port_general_link_up_handler(iport, iphy, false);
+		sci_port_general_link_up_handler(iport, iphy, false);
 		return SCI_SUCCESS;
 	default:
 		dev_warn(sciport_to_dev(iport),
@@ -1503,15 +1383,15 @@ enum sci_status scic_sds_port_link_up(struct isci_port *iport,
 	}
 }
 
-enum sci_status scic_sds_port_link_down(struct isci_port *iport,
+enum sci_status sci_port_link_down(struct isci_port *iport,
 					struct isci_phy *iphy)
 {
-	enum scic_sds_port_states state;
+	enum sci_port_states state;
 
 	state = iport->sm.current_state_id;
 	switch (state) {
 	case SCI_PORT_SUB_OPERATIONAL:
-		scic_sds_port_deactivate_phy(iport, iphy, true);
+		sci_port_deactivate_phy(iport, iphy, true);
 
 		/* If there are no active phys left in the port, then
 		 * transition the port to the WAITING state until such time
@@ -1524,7 +1404,7 @@ enum sci_status scic_sds_port_link_down(struct isci_port *iport,
 	case SCI_PORT_RESETTING:
 		/* In the resetting state we don't notify the user regarding
 		 * link up and link down notifications. */
-		scic_sds_port_deactivate_phy(iport, iphy, false);
+		sci_port_deactivate_phy(iport, iphy, false);
 		return SCI_SUCCESS;
 	default:
 		dev_warn(sciport_to_dev(iport),
@@ -1533,11 +1413,11 @@ enum sci_status scic_sds_port_link_down(struct isci_port *iport,
 	}
 }
 
-enum sci_status scic_sds_port_start_io(struct isci_port *iport,
-				       struct isci_remote_device *idev,
-				       struct isci_request *ireq)
+enum sci_status sci_port_start_io(struct isci_port *iport,
+				  struct isci_remote_device *idev,
+				  struct isci_request *ireq)
 {
-	enum scic_sds_port_states state;
+	enum sci_port_states state;
 
 	state = iport->sm.current_state_id;
 	switch (state) {
@@ -1553,11 +1433,11 @@ enum sci_status scic_sds_port_start_io(struct isci_port *iport,
 	}
 }
 
-enum sci_status scic_sds_port_complete_io(struct isci_port *iport,
-					  struct isci_remote_device *idev,
-					  struct isci_request *ireq)
+enum sci_status sci_port_complete_io(struct isci_port *iport,
+				     struct isci_remote_device *idev,
+				     struct isci_request *ireq)
 {
-	enum scic_sds_port_states state;
+	enum sci_port_states state;
 
 	state = iport->sm.current_state_id;
 	switch (state) {
@@ -1566,7 +1446,7 @@ enum sci_status scic_sds_port_complete_io(struct isci_port *iport,
 			 "%s: in wrong state: %d\n", __func__, state);
 		return SCI_FAILURE_INVALID_STATE;
 	case SCI_PORT_STOPPING:
-		scic_sds_port_decrement_request_count(iport);
+		sci_port_decrement_request_count(iport);
 
 		if (iport->started_request_count == 0)
 			port_state_machine_change(iport,
@@ -1577,10 +1457,10 @@ enum sci_status scic_sds_port_complete_io(struct isci_port *iport,
 	case SCI_PORT_FAILED:
 	case SCI_PORT_SUB_WAITING:
 	case SCI_PORT_SUB_OPERATIONAL:
-		scic_sds_port_decrement_request_count(iport);
+		sci_port_decrement_request_count(iport);
 		break;
 	case SCI_PORT_SUB_CONFIGURING:
-		scic_sds_port_decrement_request_count(iport);
+		sci_port_decrement_request_count(iport);
 		if (iport->started_request_count == 0) {
 			port_state_machine_change(iport,
 						  SCI_PORT_SUB_OPERATIONAL);
@@ -1590,32 +1470,17 @@ enum sci_status scic_sds_port_complete_io(struct isci_port *iport,
 	return SCI_SUCCESS;
 }
 
-/**
- *
- * @sci_port: This is the port object which to suspend.
- *
- * This method will enable the SCU Port Task Scheduler for this port object but
- * will leave the port task scheduler in a suspended state. none
- */
-static void
-scic_sds_port_enable_port_task_scheduler(struct isci_port *iport)
+static void sci_port_enable_port_task_scheduler(struct isci_port *iport)
 {
 	u32 pts_control_value;
 
+	 /* enable the port task scheduler in a suspended state */
 	pts_control_value = readl(&iport->port_task_scheduler_registers->control);
 	pts_control_value |= SCU_PTSxCR_GEN_BIT(ENABLE) | SCU_PTSxCR_GEN_BIT(SUSPEND);
 	writel(pts_control_value, &iport->port_task_scheduler_registers->control);
 }
 
-/**
- *
- * @sci_port: This is the port object which to resume.
- *
- * This method will disable the SCU port task scheduler for this port object.
- * none
- */
-static void
-scic_sds_port_disable_port_task_scheduler(struct isci_port *iport)
+static void sci_port_disable_port_task_scheduler(struct isci_port *iport)
 {
 	u32 pts_control_value;
 
@@ -1625,7 +1490,7 @@ scic_sds_port_disable_port_task_scheduler(struct isci_port *iport)
 	writel(pts_control_value, &iport->port_task_scheduler_registers->control);
 }
 
-static void scic_sds_port_post_dummy_remote_node(struct isci_port *iport)
+static void sci_port_post_dummy_remote_node(struct isci_port *iport)
 {
 	struct isci_host *ihost = iport->owning_controller;
 	u8 phys_index = iport->physical_port_index;
@@ -1639,7 +1504,7 @@ static void scic_sds_port_post_dummy_remote_node(struct isci_port *iport)
 	command = SCU_CONTEXT_COMMAND_POST_RNC_32 |
 		  phys_index << SCU_CONTEXT_COMMAND_LOGICAL_PORT_SHIFT | rni;
 
-	scic_sds_controller_post_request(ihost, command);
+	sci_controller_post_request(ihost, command);
 
 	/* ensure hardware has seen the post rnc command and give it
 	 * ample time to act before sending the suspend
@@ -1650,10 +1515,10 @@ static void scic_sds_port_post_dummy_remote_node(struct isci_port *iport)
 	command = SCU_CONTEXT_COMMAND_POST_RNC_SUSPEND_TX_RX |
 		  phys_index << SCU_CONTEXT_COMMAND_LOGICAL_PORT_SHIFT | rni;
 
-	scic_sds_controller_post_request(ihost, command);
+	sci_controller_post_request(ihost, command);
 }
 
-static void scic_sds_port_stopped_state_enter(struct sci_base_state_machine *sm)
+static void sci_port_stopped_state_enter(struct sci_base_state_machine *sm)
 {
 	struct isci_port *iport = container_of(sm, typeof(*iport), sm);
 
@@ -1662,19 +1527,19 @@ static void scic_sds_port_stopped_state_enter(struct sci_base_state_machine *sm)
 		 * If we enter this state becasuse of a request to stop
 		 * the port then we want to disable the hardwares port
 		 * task scheduler. */
-		scic_sds_port_disable_port_task_scheduler(iport);
+		sci_port_disable_port_task_scheduler(iport);
 	}
 }
 
-static void scic_sds_port_stopped_state_exit(struct sci_base_state_machine *sm)
+static void sci_port_stopped_state_exit(struct sci_base_state_machine *sm)
 {
 	struct isci_port *iport = container_of(sm, typeof(*iport), sm);
 
 	/* Enable and suspend the port task scheduler */
-	scic_sds_port_enable_port_task_scheduler(iport);
+	sci_port_enable_port_task_scheduler(iport);
 }
 
-static void scic_sds_port_ready_state_enter(struct sci_base_state_machine *sm)
+static void sci_port_ready_state_enter(struct sci_base_state_machine *sm)
 {
 	struct isci_port *iport = container_of(sm, typeof(*iport), sm);
 	struct isci_host *ihost = iport->owning_controller;
@@ -1687,30 +1552,30 @@ static void scic_sds_port_ready_state_enter(struct sci_base_state_machine *sm)
 		isci_port_not_ready(ihost, iport);
 
 	/* Post and suspend the dummy remote node context for this port. */
-	scic_sds_port_post_dummy_remote_node(iport);
+	sci_port_post_dummy_remote_node(iport);
 
 	/* Start the ready substate machine */
 	port_state_machine_change(iport,
 				  SCI_PORT_SUB_WAITING);
 }
 
-static void scic_sds_port_resetting_state_exit(struct sci_base_state_machine *sm)
+static void sci_port_resetting_state_exit(struct sci_base_state_machine *sm)
 {
 	struct isci_port *iport = container_of(sm, typeof(*iport), sm);
 
 	sci_del_timer(&iport->timer);
 }
 
-static void scic_sds_port_stopping_state_exit(struct sci_base_state_machine *sm)
+static void sci_port_stopping_state_exit(struct sci_base_state_machine *sm)
 {
 	struct isci_port *iport = container_of(sm, typeof(*iport), sm);
 
 	sci_del_timer(&iport->timer);
 
-	scic_sds_port_destroy_dummy_resources(iport);
+	sci_port_destroy_dummy_resources(iport);
 }
 
-static void scic_sds_port_failed_state_enter(struct sci_base_state_machine *sm)
+static void sci_port_failed_state_enter(struct sci_base_state_machine *sm)
 {
 	struct isci_port *iport = container_of(sm, typeof(*iport), sm);
 
@@ -1719,40 +1584,40 @@ static void scic_sds_port_failed_state_enter(struct sci_base_state_machine *sm)
 
 /* --------------------------------------------------------------------------- */
 
-static const struct sci_base_state scic_sds_port_state_table[] = {
+static const struct sci_base_state sci_port_state_table[] = {
 	[SCI_PORT_STOPPED] = {
-		.enter_state = scic_sds_port_stopped_state_enter,
-		.exit_state  = scic_sds_port_stopped_state_exit
+		.enter_state = sci_port_stopped_state_enter,
+		.exit_state  = sci_port_stopped_state_exit
 	},
 	[SCI_PORT_STOPPING] = {
-		.exit_state  = scic_sds_port_stopping_state_exit
+		.exit_state  = sci_port_stopping_state_exit
 	},
 	[SCI_PORT_READY] = {
-		.enter_state = scic_sds_port_ready_state_enter,
+		.enter_state = sci_port_ready_state_enter,
 	},
 	[SCI_PORT_SUB_WAITING] = {
-		.enter_state = scic_sds_port_ready_substate_waiting_enter,
+		.enter_state = sci_port_ready_substate_waiting_enter,
 	},
 	[SCI_PORT_SUB_OPERATIONAL] = {
-		.enter_state = scic_sds_port_ready_substate_operational_enter,
-		.exit_state  = scic_sds_port_ready_substate_operational_exit
+		.enter_state = sci_port_ready_substate_operational_enter,
+		.exit_state  = sci_port_ready_substate_operational_exit
 	},
 	[SCI_PORT_SUB_CONFIGURING] = {
-		.enter_state = scic_sds_port_ready_substate_configuring_enter,
-		.exit_state  = scic_sds_port_ready_substate_configuring_exit
+		.enter_state = sci_port_ready_substate_configuring_enter,
+		.exit_state  = sci_port_ready_substate_configuring_exit
 	},
 	[SCI_PORT_RESETTING] = {
-		.exit_state  = scic_sds_port_resetting_state_exit
+		.exit_state  = sci_port_resetting_state_exit
 	},
 	[SCI_PORT_FAILED] = {
-		.enter_state = scic_sds_port_failed_state_enter,
+		.enter_state = sci_port_failed_state_enter,
 	}
 };
 
-void scic_sds_port_construct(struct isci_port *iport, u8 index,
+void sci_port_construct(struct isci_port *iport, u8 index,
 			     struct isci_host *ihost)
 {
-	sci_init_sm(&iport->sm, scic_sds_port_state_table, SCI_PORT_STOPPED);
+	sci_init_sm(&iport->sm, sci_port_state_table, SCI_PORT_STOPPED);
 
 	iport->logical_port_index  = SCIC_SDS_DUMMY_PORT;
 	iport->physical_port_index = index;
@@ -1798,9 +1663,7 @@ enum isci_status isci_port_get_state(
 	return isci_port->status;
 }
 
-void scic_sds_port_broadcast_change_received(
-	struct isci_port *iport,
-	struct isci_phy *iphy)
+void sci_port_broadcast_change_received(struct isci_port *iport, struct isci_phy *iphy)
 {
 	struct isci_host *ihost = iport->owning_controller;
 
@@ -1823,7 +1686,7 @@ int isci_port_perform_hard_reset(struct isci_host *ihost, struct isci_port *ipor
 	spin_lock_irqsave(&ihost->scic_lock, flags);
 
 	#define ISCI_PORT_RESET_TIMEOUT SCIC_SDS_SIGNATURE_FIS_TIMEOUT
-	status = scic_port_hard_reset(iport, ISCI_PORT_RESET_TIMEOUT);
+	status = sci_port_hard_reset(iport, ISCI_PORT_RESET_TIMEOUT);
 
 	spin_unlock_irqrestore(&ihost->scic_lock, flags);
 
@@ -1840,7 +1703,7 @@ int isci_port_perform_hard_reset(struct isci_host *ihost, struct isci_port *ipor
 		ret = TMF_RESP_FUNC_FAILED;
 
 		dev_err(&ihost->pdev->dev,
-			"%s: iport = %p; scic_port_hard_reset call"
+			"%s: iport = %p; sci_port_hard_reset call"
 			" failed 0x%x\n",
 			__func__, iport, status);
 
@@ -1863,8 +1726,8 @@ int isci_port_perform_hard_reset(struct isci_host *ihost, struct isci_port *ipor
 
 			if (!iphy)
 				continue;
-			scic_sds_phy_stop(iphy);
-			scic_sds_phy_start(iphy);
+			sci_phy_stop(iphy);
+			sci_phy_start(iphy);
 		}
 		spin_unlock_irqrestore(&ihost->scic_lock, flags);
 	}

commit d9dcb4ba791de2a06b19ac47cd61601cf3d4e208
Author: Dan Williams <dan.j.williams@intel.com>
Date:   Thu Jun 30 17:38:32 2011 -0700

    isci: unify isci_host and scic_sds_controller
    
    Remove the distinction between these two implementations and unify on
    isci_host (local instances named ihost).  Hmmm, we had two
    'oem_parameters' instances, one was unused... nice.
    
    Reported-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/drivers/scsi/isci/port.c b/drivers/scsi/isci/port.c
index df37b1bf7d11..c434d5a0effa 100644
--- a/drivers/scsi/isci/port.c
+++ b/drivers/scsi/isci/port.c
@@ -365,11 +365,11 @@ static void isci_port_not_ready(struct isci_host *isci_host, struct isci_port *i
 		"%s: isci_port = %p\n", __func__, isci_port);
 }
 
-static void isci_port_stop_complete(struct scic_sds_controller *scic,
+static void isci_port_stop_complete(struct isci_host *ihost,
 				    struct isci_port *iport,
 				    enum sci_status completion_status)
 {
-	dev_dbg(&scic_to_ihost(scic)->pdev->dev, "Port stop complete\n");
+	dev_dbg(&ihost->pdev->dev, "Port stop complete\n");
 }
 
 /**
@@ -541,8 +541,7 @@ static enum sci_status scic_sds_port_clear_phy(struct isci_port *iport,
 	/* Make sure that this phy is part of this port */
 	if (iport->phy_table[iphy->phy_index] == iphy &&
 	    phy_get_non_dummy_port(iphy) == iport) {
-		struct scic_sds_controller *scic = iport->owning_controller;
-		struct isci_host *ihost = scic_to_ihost(scic);
+		struct isci_host *ihost = iport->owning_controller;
 
 		/* Yep it is assigned to this port so remove it */
 		scic_sds_phy_set_port(iphy, &ihost->ports[SCI_MAX_PORTS]);
@@ -654,10 +653,10 @@ static void scic_sds_port_construct_dummy_rnc(struct isci_port *iport, u16 rni)
  */
 static void scic_sds_port_construct_dummy_task(struct isci_port *iport, u16 tag)
 {
-	struct scic_sds_controller *scic = iport->owning_controller;
+	struct isci_host *ihost = iport->owning_controller;
 	struct scu_task_context *task_context;
 
-	task_context = &scic->task_context_table[ISCI_TAG_TCI(tag)];
+	task_context = &ihost->task_context_table[ISCI_TAG_TCI(tag)];
 	memset(task_context, 0, sizeof(struct scu_task_context));
 
 	task_context->initiator_request = 1;
@@ -674,13 +673,13 @@ static void scic_sds_port_construct_dummy_task(struct isci_port *iport, u16 tag)
 
 static void scic_sds_port_destroy_dummy_resources(struct isci_port *iport)
 {
-	struct scic_sds_controller *scic = iport->owning_controller;
+	struct isci_host *ihost = iport->owning_controller;
 
 	if (iport->reserved_tag != SCI_CONTROLLER_INVALID_IO_TAG)
-		isci_free_tag(scic_to_ihost(scic), iport->reserved_tag);
+		isci_free_tag(ihost, iport->reserved_tag);
 
 	if (iport->reserved_rni != SCU_DUMMY_INDEX)
-		scic_sds_remote_node_table_release_remote_node_index(&scic->available_remote_nodes,
+		scic_sds_remote_node_table_release_remote_node_index(&ihost->available_remote_nodes,
 								     1, iport->reserved_rni);
 
 	iport->reserved_rni = SCU_DUMMY_INDEX;
@@ -749,15 +748,14 @@ static void scic_sds_port_activate_phy(struct isci_port *iport,
 				       struct isci_phy *iphy,
 				       bool do_notify_user)
 {
-	struct scic_sds_controller *scic = iport->owning_controller;
-	struct isci_host *ihost = scic_to_ihost(scic);
+	struct isci_host *ihost = iport->owning_controller;
 
 	if (iphy->protocol != SCIC_SDS_PHY_PROTOCOL_SATA)
 		scic_sds_phy_resume(iphy);
 
 	iport->active_phy_mask |= 1 << iphy->phy_index;
 
-	scic_sds_controller_clear_invalid_phy(scic, iphy);
+	scic_sds_controller_clear_invalid_phy(ihost, iphy);
 
 	if (do_notify_user == true)
 		isci_port_link_up(ihost, iport, iphy);
@@ -767,8 +765,7 @@ void scic_sds_port_deactivate_phy(struct isci_port *iport,
 				  struct isci_phy *iphy,
 				  bool do_notify_user)
 {
-	struct scic_sds_controller *scic = scic_sds_port_get_controller(iport);
-	struct isci_host *ihost = scic_to_ihost(scic);
+	struct isci_host *ihost = scic_sds_port_get_controller(iport);
 
 	iport->active_phy_mask &= ~(1 << iphy->phy_index);
 
@@ -793,16 +790,16 @@ void scic_sds_port_deactivate_phy(struct isci_port *iport,
 static void scic_sds_port_invalid_link_up(struct isci_port *iport,
 					  struct isci_phy *iphy)
 {
-	struct scic_sds_controller *scic = iport->owning_controller;
+	struct isci_host *ihost = iport->owning_controller;
 
 	/*
 	 * Check to see if we have alreay reported this link as bad and if
 	 * not go ahead and tell the SCI_USER that we have discovered an
 	 * invalid link.
 	 */
-	if ((scic->invalid_phy_mask & (1 << iphy->phy_index)) == 0) {
-		scic_sds_controller_set_invalid_phy(scic, iphy);
-		dev_warn(&scic_to_ihost(scic)->pdev->dev, "Invalid link up!\n");
+	if ((ihost->invalid_phy_mask & (1 << iphy->phy_index)) == 0) {
+		scic_sds_controller_set_invalid_phy(ihost, iphy);
+		dev_warn(&ihost->pdev->dev, "Invalid link up!\n");
 	}
 }
 
@@ -931,7 +928,7 @@ static void port_timeout(unsigned long data)
 {
 	struct sci_timer *tmr = (struct sci_timer *)data;
 	struct isci_port *iport = container_of(tmr, typeof(*iport), timer);
-	struct isci_host *ihost = scic_to_ihost(iport->owning_controller);
+	struct isci_host *ihost = iport->owning_controller;
 	unsigned long flags;
 	u32 current_state;
 
@@ -1041,19 +1038,19 @@ static void scic_sds_port_suspend_port_task_scheduler(struct isci_port *iport)
  */
 static void scic_sds_port_post_dummy_request(struct isci_port *iport)
 {
-	struct scic_sds_controller *scic = iport->owning_controller;
+	struct isci_host *ihost = iport->owning_controller;
 	u16 tag = iport->reserved_tag;
 	struct scu_task_context *tc;
 	u32 command;
 
-	tc = &scic->task_context_table[ISCI_TAG_TCI(tag)];
+	tc = &ihost->task_context_table[ISCI_TAG_TCI(tag)];
 	tc->abort = 0;
 
 	command = SCU_CONTEXT_COMMAND_REQUEST_TYPE_POST_TC |
 		  iport->physical_port_index << SCU_CONTEXT_COMMAND_LOGICAL_PORT_SHIFT |
 		  ISCI_TAG_TCI(tag);
 
-	scic_sds_controller_post_request(scic, command);
+	scic_sds_controller_post_request(ihost, command);
 }
 
 /**
@@ -1065,19 +1062,19 @@ static void scic_sds_port_post_dummy_request(struct isci_port *iport)
  */
 static void scic_sds_port_abort_dummy_request(struct isci_port *iport)
 {
-	struct scic_sds_controller *scic = iport->owning_controller;
+	struct isci_host *ihost = iport->owning_controller;
 	u16 tag = iport->reserved_tag;
 	struct scu_task_context *tc;
 	u32 command;
 
-	tc = &scic->task_context_table[ISCI_TAG_TCI(tag)];
+	tc = &ihost->task_context_table[ISCI_TAG_TCI(tag)];
 	tc->abort = 1;
 
 	command = SCU_CONTEXT_COMMAND_REQUEST_POST_TC_ABORT |
 		  iport->physical_port_index << SCU_CONTEXT_COMMAND_LOGICAL_PORT_SHIFT |
 		  ISCI_TAG_TCI(tag);
 
-	scic_sds_controller_post_request(scic, command);
+	scic_sds_controller_post_request(ihost, command);
 }
 
 /**
@@ -1115,8 +1112,7 @@ static void scic_sds_port_ready_substate_operational_enter(struct sci_base_state
 {
 	u32 index;
 	struct isci_port *iport = container_of(sm, typeof(*iport), sm);
-	struct scic_sds_controller *scic = iport->owning_controller;
-	struct isci_host *ihost = scic_to_ihost(scic);
+	struct isci_host *ihost = iport->owning_controller;
 
 	isci_port_ready(ihost, iport);
 
@@ -1141,13 +1137,13 @@ static void scic_sds_port_ready_substate_operational_enter(struct sci_base_state
 
 static void scic_sds_port_invalidate_dummy_remote_node(struct isci_port *iport)
 {
-	struct scic_sds_controller *scic = iport->owning_controller;
+	struct isci_host *ihost = iport->owning_controller;
 	u8 phys_index = iport->physical_port_index;
 	union scu_remote_node_context *rnc;
 	u16 rni = iport->reserved_rni;
 	u32 command;
 
-	rnc = &scic->remote_node_context_table[rni];
+	rnc = &ihost->remote_node_context_table[rni];
 
 	rnc->ssp.is_valid = false;
 
@@ -1155,13 +1151,13 @@ static void scic_sds_port_invalidate_dummy_remote_node(struct isci_port *iport)
 	 * controller and give it ample time to act before posting the rnc
 	 * invalidate
 	 */
-	readl(&scic->smu_registers->interrupt_status); /* flush */
+	readl(&ihost->smu_registers->interrupt_status); /* flush */
 	udelay(10);
 
 	command = SCU_CONTEXT_COMMAND_POST_RNC_INVALIDATE |
 		  phys_index << SCU_CONTEXT_COMMAND_LOGICAL_PORT_SHIFT | rni;
 
-	scic_sds_controller_post_request(scic, command);
+	scic_sds_controller_post_request(ihost, command);
 }
 
 /**
@@ -1175,8 +1171,7 @@ static void scic_sds_port_invalidate_dummy_remote_node(struct isci_port *iport)
 static void scic_sds_port_ready_substate_operational_exit(struct sci_base_state_machine *sm)
 {
 	struct isci_port *iport = container_of(sm, typeof(*iport), sm);
-	struct scic_sds_controller *scic = iport->owning_controller;
-	struct isci_host *ihost = scic_to_ihost(scic);
+	struct isci_host *ihost = iport->owning_controller;
 
 	/*
 	 * Kill the dummy task for this port if it has not yet posted
@@ -1194,8 +1189,7 @@ static void scic_sds_port_ready_substate_operational_exit(struct sci_base_state_
 static void scic_sds_port_ready_substate_configuring_enter(struct sci_base_state_machine *sm)
 {
 	struct isci_port *iport = container_of(sm, typeof(*iport), sm);
-	struct scic_sds_controller *scic = iport->owning_controller;
-	struct isci_host *ihost = scic_to_ihost(scic);
+	struct isci_host *ihost = iport->owning_controller;
 
 	if (iport->active_phy_mask == 0) {
 		isci_port_not_ready(ihost, iport);
@@ -1218,7 +1212,7 @@ static void scic_sds_port_ready_substate_configuring_exit(struct sci_base_state_
 
 enum sci_status scic_sds_port_start(struct isci_port *iport)
 {
-	struct scic_sds_controller *scic = iport->owning_controller;
+	struct isci_host *ihost = iport->owning_controller;
 	enum sci_status status = SCI_SUCCESS;
 	enum scic_sds_port_states state;
 	u32 phy_mask;
@@ -1241,7 +1235,7 @@ enum sci_status scic_sds_port_start(struct isci_port *iport)
 
 	if (iport->reserved_rni == SCU_DUMMY_INDEX) {
 		u16 rni = scic_sds_remote_node_table_allocate_remote_node(
-				&scic->available_remote_nodes, 1);
+				&ihost->available_remote_nodes, 1);
 
 		if (rni != SCU_DUMMY_INDEX)
 			scic_sds_port_construct_dummy_rnc(iport, rni);
@@ -1251,7 +1245,6 @@ enum sci_status scic_sds_port_start(struct isci_port *iport)
 	}
 
 	if (iport->reserved_tag == SCI_CONTROLLER_INVALID_IO_TAG) {
-		struct isci_host *ihost = scic_to_ihost(scic);
 		u16 tag;
 
 		tag = isci_alloc_tag(ihost);
@@ -1634,30 +1627,30 @@ scic_sds_port_disable_port_task_scheduler(struct isci_port *iport)
 
 static void scic_sds_port_post_dummy_remote_node(struct isci_port *iport)
 {
-	struct scic_sds_controller *scic = iport->owning_controller;
+	struct isci_host *ihost = iport->owning_controller;
 	u8 phys_index = iport->physical_port_index;
 	union scu_remote_node_context *rnc;
 	u16 rni = iport->reserved_rni;
 	u32 command;
 
-	rnc = &scic->remote_node_context_table[rni];
+	rnc = &ihost->remote_node_context_table[rni];
 	rnc->ssp.is_valid = true;
 
 	command = SCU_CONTEXT_COMMAND_POST_RNC_32 |
 		  phys_index << SCU_CONTEXT_COMMAND_LOGICAL_PORT_SHIFT | rni;
 
-	scic_sds_controller_post_request(scic, command);
+	scic_sds_controller_post_request(ihost, command);
 
 	/* ensure hardware has seen the post rnc command and give it
 	 * ample time to act before sending the suspend
 	 */
-	readl(&scic->smu_registers->interrupt_status); /* flush */
+	readl(&ihost->smu_registers->interrupt_status); /* flush */
 	udelay(10);
 
 	command = SCU_CONTEXT_COMMAND_POST_RNC_SUSPEND_TX_RX |
 		  phys_index << SCU_CONTEXT_COMMAND_LOGICAL_PORT_SHIFT | rni;
 
-	scic_sds_controller_post_request(scic, command);
+	scic_sds_controller_post_request(ihost, command);
 }
 
 static void scic_sds_port_stopped_state_enter(struct sci_base_state_machine *sm)
@@ -1684,8 +1677,7 @@ static void scic_sds_port_stopped_state_exit(struct sci_base_state_machine *sm)
 static void scic_sds_port_ready_state_enter(struct sci_base_state_machine *sm)
 {
 	struct isci_port *iport = container_of(sm, typeof(*iport), sm);
-	struct scic_sds_controller *scic = iport->owning_controller;
-	struct isci_host *ihost = scic_to_ihost(scic);
+	struct isci_host *ihost = iport->owning_controller;
 	u32 prev_state;
 
 	prev_state = iport->sm.previous_state_id;
@@ -1758,7 +1750,7 @@ static const struct sci_base_state scic_sds_port_state_table[] = {
 };
 
 void scic_sds_port_construct(struct isci_port *iport, u8 index,
-			     struct scic_sds_controller *scic)
+			     struct isci_host *ihost)
 {
 	sci_init_sm(&iport->sm, scic_sds_port_state_table, SCI_PORT_STOPPED);
 
@@ -1767,7 +1759,7 @@ void scic_sds_port_construct(struct isci_port *iport, u8 index,
 	iport->active_phy_mask     = 0;
 	iport->ready_exit	      = false;
 
-	iport->owning_controller = scic;
+	iport->owning_controller = ihost;
 
 	iport->started_request_count = 0;
 	iport->assigned_device_count = 0;
@@ -1810,8 +1802,7 @@ void scic_sds_port_broadcast_change_received(
 	struct isci_port *iport,
 	struct isci_phy *iphy)
 {
-	struct scic_sds_controller *scic = iport->owning_controller;
-	struct isci_host *ihost = scic_to_ihost(scic);
+	struct isci_host *ihost = iport->owning_controller;
 
 	/* notify the user. */
 	isci_port_bc_change_received(ihost, iport, iphy);

commit 78a6f06e0e82125787d7aa308fe28c2c8381540c
Author: Dan Williams <dan.j.williams@intel.com>
Date:   Thu Jun 30 16:31:37 2011 -0700

    isci: unify isci_remote_device and scic_sds_remote_device
    
    Remove the distinction between these two implementations and unify on
    isci_remote_device (local instances named idev).
    
    Reported-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/drivers/scsi/isci/port.c b/drivers/scsi/isci/port.c
index 04591882ee77..df37b1bf7d11 100644
--- a/drivers/scsi/isci/port.c
+++ b/drivers/scsi/isci/port.c
@@ -1541,7 +1541,7 @@ enum sci_status scic_sds_port_link_down(struct isci_port *iport,
 }
 
 enum sci_status scic_sds_port_start_io(struct isci_port *iport,
-				       struct scic_sds_remote_device *sci_dev,
+				       struct isci_remote_device *idev,
 				       struct isci_request *ireq)
 {
 	enum scic_sds_port_states state;
@@ -1561,7 +1561,7 @@ enum sci_status scic_sds_port_start_io(struct isci_port *iport,
 }
 
 enum sci_status scic_sds_port_complete_io(struct isci_port *iport,
-					  struct scic_sds_remote_device *sci_dev,
+					  struct isci_remote_device *idev,
 					  struct isci_request *ireq)
 {
 	enum scic_sds_port_states state;

commit ffe191c92ff195d73f9130b1490045ca2dd4c5e0
Author: Dan Williams <dan.j.williams@intel.com>
Date:   Wed Jun 29 13:09:25 2011 -0700

    isci: unify isci_port and scic_sds_port
    
    Remove the distinction between these two implementations and unify on
    isci_port (local instances named iport).  The duplicate '->owning_port' and
    '->isci_port' in both isci_phy and isci_remote_device will be fixed in a later
    patch... this is just the straightforward rename/unification.
    
    Reported-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/drivers/scsi/isci/port.c b/drivers/scsi/isci/port.c
index d53c0b1748e7..04591882ee77 100644
--- a/drivers/scsi/isci/port.c
+++ b/drivers/scsi/isci/port.c
@@ -83,7 +83,7 @@ static void isci_port_change_state(struct isci_port *iport, enum isci_status sta
  *    transmit_identification register.
  */
 static void
-scic_sds_port_get_protocols(struct scic_sds_port *sci_port,
+scic_sds_port_get_protocols(struct isci_port *iport,
 			    struct scic_phy_proto *protocols)
 {
 	u8 index;
@@ -91,8 +91,8 @@ scic_sds_port_get_protocols(struct scic_sds_port *sci_port,
 	protocols->all = 0;
 
 	for (index = 0; index < SCI_MAX_PHYS; index++) {
-		if (sci_port->phy_table[index] != NULL) {
-			scic_sds_phy_get_protocols(sci_port->phy_table[index],
+		if (iport->phy_table[index] != NULL) {
+			scic_sds_phy_get_protocols(iport->phy_table[index],
 						   protocols);
 		}
 	}
@@ -107,7 +107,7 @@ scic_sds_port_get_protocols(struct scic_sds_port *sci_port,
  * Return a bit mask indicating which phys are a part of this port. Each bit
  * corresponds to a phy identifier (e.g. bit 0 = phy id 0).
  */
-static u32 scic_sds_port_get_phys(struct scic_sds_port *sci_port)
+static u32 scic_sds_port_get_phys(struct isci_port *iport)
 {
 	u32 index;
 	u32 mask;
@@ -115,7 +115,7 @@ static u32 scic_sds_port_get_phys(struct scic_sds_port *sci_port)
 	mask = 0;
 
 	for (index = 0; index < SCI_MAX_PHYS; index++) {
-		if (sci_port->phy_table[index] != NULL) {
+		if (iport->phy_table[index] != NULL) {
 			mask |= (1 << index);
 		}
 	}
@@ -136,30 +136,29 @@ static u32 scic_sds_port_get_phys(struct scic_sds_port *sci_port)
  * value is returned if the specified port is not valid.  When this value is
  * returned, no data is copied to the properties output parameter.
  */
-static enum sci_status scic_port_get_properties(struct scic_sds_port *port,
+static enum sci_status scic_port_get_properties(struct isci_port *iport,
 						struct scic_port_properties *prop)
 {
-	if ((port == NULL) ||
-	    (port->logical_port_index == SCIC_SDS_DUMMY_PORT))
+	if (!iport || iport->logical_port_index == SCIC_SDS_DUMMY_PORT)
 		return SCI_FAILURE_INVALID_PORT;
 
-	prop->index    = port->logical_port_index;
-	prop->phy_mask = scic_sds_port_get_phys(port);
-	scic_sds_port_get_sas_address(port, &prop->local.sas_address);
-	scic_sds_port_get_protocols(port, &prop->local.protocols);
-	scic_sds_port_get_attached_sas_address(port, &prop->remote.sas_address);
+	prop->index    = iport->logical_port_index;
+	prop->phy_mask = scic_sds_port_get_phys(iport);
+	scic_sds_port_get_sas_address(iport, &prop->local.sas_address);
+	scic_sds_port_get_protocols(iport, &prop->local.protocols);
+	scic_sds_port_get_attached_sas_address(iport, &prop->remote.sas_address);
 
 	return SCI_SUCCESS;
 }
 
-static void scic_port_bcn_enable(struct scic_sds_port *sci_port)
+static void scic_port_bcn_enable(struct isci_port *iport)
 {
 	struct isci_phy *iphy;
 	u32 val;
 	int i;
 
-	for (i = 0; i < ARRAY_SIZE(sci_port->phy_table); i++) {
-		iphy = sci_port->phy_table[i];
+	for (i = 0; i < ARRAY_SIZE(iport->phy_table); i++) {
+		iphy = iport->phy_table[i];
 		if (!iphy)
 			continue;
 		val = readl(&iphy->link_layer_registers->link_layer_control);
@@ -179,8 +178,8 @@ void isci_port_bcn_enable(struct isci_host *ihost, struct isci_port *iport)
 	if (!test_and_clear_bit(IPORT_BCN_PENDING, &iport->flags))
 		return;
 
-	for (i = 0; i < ARRAY_SIZE(iport->sci.phy_table); i++) {
-		struct isci_phy *iphy = iport->sci.phy_table[i];
+	for (i = 0; i < ARRAY_SIZE(iport->phy_table); i++) {
+		struct isci_phy *iphy = iport->phy_table[i];
 
 		if (!iphy)
 			continue;
@@ -191,12 +190,10 @@ void isci_port_bcn_enable(struct isci_host *ihost, struct isci_port *iport)
 	}
 }
 
-void isci_port_bc_change_received(struct isci_host *ihost,
-				  struct scic_sds_port *sci_port,
-				  struct isci_phy *iphy)
+static void isci_port_bc_change_received(struct isci_host *ihost,
+					 struct isci_port *iport,
+					 struct isci_phy *iphy)
 {
-	struct isci_port *iport = iphy->isci_port;
-
 	if (iport && test_bit(IPORT_BCN_BLOCKED, &iport->flags)) {
 		dev_dbg(&ihost->pdev->dev,
 			"%s: disabled BCN; isci_phy = %p, sas_phy = %p\n",
@@ -212,31 +209,30 @@ void isci_port_bc_change_received(struct isci_host *ihost,
 		ihost->sas_ha.notify_port_event(&iphy->sas_phy,
 						PORTE_BROADCAST_RCVD);
 	}
-	scic_port_bcn_enable(sci_port);
+	scic_port_bcn_enable(iport);
 }
 
 static void isci_port_link_up(struct isci_host *isci_host,
-			      struct scic_sds_port *port,
+			      struct isci_port *iport,
 			      struct isci_phy *iphy)
 {
 	unsigned long flags;
 	struct scic_port_properties properties;
-	struct isci_port *isci_port = sci_port_to_iport(port);
 	unsigned long success = true;
 
 	BUG_ON(iphy->isci_port != NULL);
 
-	iphy->isci_port = isci_port;
+	iphy->isci_port = iport;
 
 	dev_dbg(&isci_host->pdev->dev,
 		"%s: isci_port = %p\n",
-		__func__, isci_port);
+		__func__, iport);
 
 	spin_lock_irqsave(&iphy->sas_phy.frame_rcvd_lock, flags);
 
 	isci_port_change_state(iphy->isci_port, isci_starting);
 
-	scic_port_get_properties(port, &properties);
+	scic_port_get_properties(iport, &properties);
 
 	if (iphy->protocol == SCIC_SDS_PHY_PROTOCOL_SATA) {
 		u64 attached_sas_address;
@@ -370,7 +366,7 @@ static void isci_port_not_ready(struct isci_host *isci_host, struct isci_port *i
 }
 
 static void isci_port_stop_complete(struct scic_sds_controller *scic,
-				    struct scic_sds_port *sci_port,
+				    struct isci_port *iport,
 				    enum sci_status completion_status)
 {
 	dev_dbg(&scic_to_ihost(scic)->pdev->dev, "Port stop complete\n");
@@ -408,30 +404,30 @@ static void isci_port_hard_reset_complete(struct isci_port *isci_port,
  * assignment for the port false if this is not a valid phy assignment for the
  * port
  */
-bool scic_sds_port_is_valid_phy_assignment(struct scic_sds_port *sci_port,
+bool scic_sds_port_is_valid_phy_assignment(struct isci_port *iport,
 					   u32 phy_index)
 {
 	/* Initialize to invalid value. */
 	u32 existing_phy_index = SCI_MAX_PHYS;
 	u32 index;
 
-	if ((sci_port->physical_port_index == 1) && (phy_index != 1)) {
+	if ((iport->physical_port_index == 1) && (phy_index != 1)) {
 		return false;
 	}
 
-	if (sci_port->physical_port_index == 3 && phy_index != 3) {
+	if (iport->physical_port_index == 3 && phy_index != 3) {
 		return false;
 	}
 
 	if (
-		(sci_port->physical_port_index == 2)
+		(iport->physical_port_index == 2)
 		&& ((phy_index == 0) || (phy_index == 1))
 		) {
 		return false;
 	}
 
 	for (index = 0; index < SCI_MAX_PHYS; index++) {
-		if ((sci_port->phy_table[index] != NULL)
+		if ((iport->phy_table[index] != NULL)
 		    && (index != phy_index)) {
 			existing_phy_index = index;
 		}
@@ -442,9 +438,9 @@ bool scic_sds_port_is_valid_phy_assignment(struct scic_sds_port *sci_port,
 	 * operating at the same maximum link rate. */
 	if (
 		(existing_phy_index < SCI_MAX_PHYS)
-		&& (sci_port->owning_controller->user_parameters.sds1.phys[
+		&& (iport->owning_controller->user_parameters.sds1.phys[
 			    phy_index].max_speed_generation !=
-		    sci_port->owning_controller->user_parameters.sds1.phys[
+		    iport->owning_controller->user_parameters.sds1.phys[
 			    existing_phy_index].max_speed_generation)
 		)
 		return false;
@@ -465,25 +461,25 @@ bool scic_sds_port_is_valid_phy_assignment(struct scic_sds_port *sci_port,
  * port false if this is not a valid phy assignment for the port
  */
 static bool scic_sds_port_is_phy_mask_valid(
-	struct scic_sds_port *sci_port,
+	struct isci_port *iport,
 	u32 phy_mask)
 {
-	if (sci_port->physical_port_index == 0) {
+	if (iport->physical_port_index == 0) {
 		if (((phy_mask & 0x0F) == 0x0F)
 		    || ((phy_mask & 0x03) == 0x03)
 		    || ((phy_mask & 0x01) == 0x01)
 		    || (phy_mask == 0))
 			return true;
-	} else if (sci_port->physical_port_index == 1) {
+	} else if (iport->physical_port_index == 1) {
 		if (((phy_mask & 0x02) == 0x02)
 		    || (phy_mask == 0))
 			return true;
-	} else if (sci_port->physical_port_index == 2) {
+	} else if (iport->physical_port_index == 2) {
 		if (((phy_mask & 0x0C) == 0x0C)
 		    || ((phy_mask & 0x04) == 0x04)
 		    || (phy_mask == 0))
 			return true;
-	} else if (sci_port->physical_port_index == 3) {
+	} else if (iport->physical_port_index == 3) {
 		if (((phy_mask & 0x08) == 0x08)
 		    || (phy_mask == 0))
 			return true;
@@ -500,7 +496,7 @@ static bool scic_sds_port_is_phy_mask_valid(
  * point) phys contained in the port. All other values specify a struct scic_sds_phy
  * object that is active in the port.
  */
-static struct isci_phy *scic_sds_port_get_a_connected_phy(struct scic_sds_port *sci_port)
+static struct isci_phy *scic_sds_port_get_a_connected_phy(struct isci_port *iport)
 {
 	u32 index;
 	struct isci_phy *iphy;
@@ -509,29 +505,29 @@ static struct isci_phy *scic_sds_port_get_a_connected_phy(struct scic_sds_port *
 		/* Ensure that the phy is both part of the port and currently
 		 * connected to the remote end-point.
 		 */
-		iphy = sci_port->phy_table[index];
-		if (iphy && scic_sds_port_active_phy(sci_port, iphy))
+		iphy = iport->phy_table[index];
+		if (iphy && scic_sds_port_active_phy(iport, iphy))
 			return iphy;
 	}
 
 	return NULL;
 }
 
-static enum sci_status scic_sds_port_set_phy(struct scic_sds_port *port, struct isci_phy *iphy)
+static enum sci_status scic_sds_port_set_phy(struct isci_port *iport, struct isci_phy *iphy)
 {
 	/* Check to see if we can add this phy to a port
 	 * that means that the phy is not part of a port and that the port does
 	 * not already have a phy assinged to the phy index.
 	 */
-	if (!port->phy_table[iphy->phy_index] &&
+	if (!iport->phy_table[iphy->phy_index] &&
 	    !phy_get_non_dummy_port(iphy) &&
-	    scic_sds_port_is_valid_phy_assignment(port, iphy->phy_index)) {
+	    scic_sds_port_is_valid_phy_assignment(iport, iphy->phy_index)) {
 		/* Phy is being added in the stopped state so we are in MPC mode
 		 * make logical port index = physical port index
 		 */
-		port->logical_port_index = port->physical_port_index;
-		port->phy_table[iphy->phy_index] = iphy;
-		scic_sds_phy_set_port(iphy, port);
+		iport->logical_port_index = iport->physical_port_index;
+		iport->phy_table[iphy->phy_index] = iphy;
+		scic_sds_phy_set_port(iphy, iport);
 
 		return SCI_SUCCESS;
 	}
@@ -539,18 +535,18 @@ static enum sci_status scic_sds_port_set_phy(struct scic_sds_port *port, struct
 	return SCI_FAILURE;
 }
 
-static enum sci_status scic_sds_port_clear_phy(struct scic_sds_port *port,
+static enum sci_status scic_sds_port_clear_phy(struct isci_port *iport,
 					       struct isci_phy *iphy)
 {
 	/* Make sure that this phy is part of this port */
-	if (port->phy_table[iphy->phy_index] == iphy &&
-	    phy_get_non_dummy_port(iphy) == port) {
-		struct scic_sds_controller *scic = port->owning_controller;
+	if (iport->phy_table[iphy->phy_index] == iphy &&
+	    phy_get_non_dummy_port(iphy) == iport) {
+		struct scic_sds_controller *scic = iport->owning_controller;
 		struct isci_host *ihost = scic_to_ihost(scic);
 
 		/* Yep it is assigned to this port so remove it */
-		scic_sds_phy_set_port(iphy, &ihost->ports[SCI_MAX_PORTS].sci);
-		port->phy_table[iphy->phy_index] = NULL;
+		scic_sds_phy_set_port(iphy, &ihost->ports[SCI_MAX_PORTS]);
+		iport->phy_table[iphy->phy_index] = NULL;
 		return SCI_SUCCESS;
 	}
 
@@ -568,7 +564,7 @@ static enum sci_status scic_sds_port_clear_phy(struct scic_sds_port *port,
  *
  */
 void scic_sds_port_get_sas_address(
-	struct scic_sds_port *sci_port,
+	struct isci_port *iport,
 	struct sci_sas_address *sas_address)
 {
 	u32 index;
@@ -577,8 +573,8 @@ void scic_sds_port_get_sas_address(
 	sas_address->low  = 0;
 
 	for (index = 0; index < SCI_MAX_PHYS; index++) {
-		if (sci_port->phy_table[index] != NULL) {
-			scic_sds_phy_get_sas_address(sci_port->phy_table[index], sas_address);
+		if (iport->phy_table[index] != NULL) {
+			scic_sds_phy_get_sas_address(iport->phy_table[index], sas_address);
 		}
 	}
 }
@@ -594,7 +590,7 @@ void scic_sds_port_get_sas_address(
  *
  */
 void scic_sds_port_get_attached_sas_address(
-	struct scic_sds_port *sci_port,
+	struct isci_port *iport,
 	struct sci_sas_address *sas_address)
 {
 	struct isci_phy *iphy;
@@ -603,7 +599,7 @@ void scic_sds_port_get_attached_sas_address(
 	 * Ensure that the phy is both part of the port and currently
 	 * connected to the remote end-point.
 	 */
-	iphy = scic_sds_port_get_a_connected_phy(sci_port);
+	iphy = scic_sds_port_get_a_connected_phy(iport);
 	if (iphy) {
 		if (iphy->protocol != SCIC_SDS_PHY_PROTOCOL_SATA) {
 			scic_sds_phy_get_attached_sas_address(iphy,
@@ -628,11 +624,11 @@ void scic_sds_port_get_attached_sas_address(
  * This structure will be posted to the hardware to work around a scheduler
  * error in the hardware.
  */
-static void scic_sds_port_construct_dummy_rnc(struct scic_sds_port *sci_port, u16 rni)
+static void scic_sds_port_construct_dummy_rnc(struct isci_port *iport, u16 rni)
 {
 	union scu_remote_node_context *rnc;
 
-	rnc = &sci_port->owning_controller->remote_node_context_table[rni];
+	rnc = &iport->owning_controller->remote_node_context_table[rni];
 
 	memset(rnc, 0, sizeof(union scu_remote_node_context));
 
@@ -641,7 +637,7 @@ static void scic_sds_port_construct_dummy_rnc(struct scic_sds_port *sci_port, u1
 
 	rnc->ssp.remote_node_index = rni;
 	rnc->ssp.remote_node_port_width = 1;
-	rnc->ssp.logical_port_index = sci_port->physical_port_index;
+	rnc->ssp.logical_port_index = iport->physical_port_index;
 
 	rnc->ssp.nexus_loss_timer_enable = false;
 	rnc->ssp.check_bit = false;
@@ -656,9 +652,9 @@ static void scic_sds_port_construct_dummy_rnc(struct scic_sds_port *sci_port, u1
  * structure will be posted to the hardwre to work around a scheduler error
  * in the hardware.
  */
-static void scic_sds_port_construct_dummy_task(struct scic_sds_port *sci_port, u16 tag)
+static void scic_sds_port_construct_dummy_task(struct isci_port *iport, u16 tag)
 {
-	struct scic_sds_controller *scic = sci_port->owning_controller;
+	struct scic_sds_controller *scic = iport->owning_controller;
 	struct scu_task_context *task_context;
 
 	task_context = &scic->task_context_table[ISCI_TAG_TCI(tag)];
@@ -666,29 +662,29 @@ static void scic_sds_port_construct_dummy_task(struct scic_sds_port *sci_port, u
 
 	task_context->initiator_request = 1;
 	task_context->connection_rate = 1;
-	task_context->logical_port_index = sci_port->physical_port_index;
+	task_context->logical_port_index = iport->physical_port_index;
 	task_context->protocol_type = SCU_TASK_CONTEXT_PROTOCOL_SSP;
 	task_context->task_index = ISCI_TAG_TCI(tag);
 	task_context->valid = SCU_TASK_CONTEXT_VALID;
 	task_context->context_type = SCU_TASK_CONTEXT_TYPE;
-	task_context->remote_node_index = sci_port->reserved_rni;
+	task_context->remote_node_index = iport->reserved_rni;
 	task_context->do_not_dma_ssp_good_response = 1;
 	task_context->task_phase = 0x01;
 }
 
-static void scic_sds_port_destroy_dummy_resources(struct scic_sds_port *sci_port)
+static void scic_sds_port_destroy_dummy_resources(struct isci_port *iport)
 {
-	struct scic_sds_controller *scic = sci_port->owning_controller;
+	struct scic_sds_controller *scic = iport->owning_controller;
 
-	if (sci_port->reserved_tag != SCI_CONTROLLER_INVALID_IO_TAG)
-		isci_free_tag(scic_to_ihost(scic), sci_port->reserved_tag);
+	if (iport->reserved_tag != SCI_CONTROLLER_INVALID_IO_TAG)
+		isci_free_tag(scic_to_ihost(scic), iport->reserved_tag);
 
-	if (sci_port->reserved_rni != SCU_DUMMY_INDEX)
+	if (iport->reserved_rni != SCU_DUMMY_INDEX)
 		scic_sds_remote_node_table_release_remote_node_index(&scic->available_remote_nodes,
-								     1, sci_port->reserved_rni);
+								     1, iport->reserved_rni);
 
-	sci_port->reserved_rni = SCU_DUMMY_INDEX;
-	sci_port->reserved_tag = SCI_CONTROLLER_INVALID_IO_TAG;
+	iport->reserved_rni = SCU_DUMMY_INDEX;
+	iport->reserved_tag = SCI_CONTROLLER_INVALID_IO_TAG;
 }
 
 /**
@@ -704,14 +700,14 @@ static void scic_sds_port_destroy_dummy_resources(struct scic_sds_port *sci_port
  * if the phy being added to the port
  */
 enum sci_status scic_sds_port_initialize(
-	struct scic_sds_port *sci_port,
+	struct isci_port *iport,
 	void __iomem *port_task_scheduler_registers,
 	void __iomem *port_configuration_regsiter,
 	void __iomem *viit_registers)
 {
-	sci_port->port_task_scheduler_registers  = port_task_scheduler_registers;
-	sci_port->port_pe_configuration_register = port_configuration_regsiter;
-	sci_port->viit_registers                 = viit_registers;
+	iport->port_task_scheduler_registers  = port_task_scheduler_registers;
+	iport->port_pe_configuration_register = port_configuration_regsiter;
+	iport->viit_registers                 = viit_registers;
 
 	return SCI_SUCCESS;
 }
@@ -720,20 +716,20 @@ enum sci_status scic_sds_port_initialize(
 /**
  * This method assigns the direct attached device ID for this port.
  *
- * @param[in] sci_port The port for which the direct attached device id is to
+ * @param[in] iport The port for which the direct attached device id is to
  *       be assigned.
  * @param[in] device_id The direct attached device ID to assign to the port.
  *       This will be the RNi for the device
  */
 void scic_sds_port_setup_transports(
-	struct scic_sds_port *sci_port,
+	struct isci_port *iport,
 	u32 device_id)
 {
 	u8 index;
 
 	for (index = 0; index < SCI_MAX_PHYS; index++) {
-		if (sci_port->active_phy_mask & (1 << index))
-			scic_sds_phy_setup_transport(sci_port->phy_table[index], device_id);
+		if (iport->active_phy_mask & (1 << index))
+			scic_sds_phy_setup_transport(iport->phy_table[index], device_id);
 	}
 }
 
@@ -749,39 +745,38 @@ void scic_sds_port_setup_transports(
  * the phy to the port - enabling the Protocol Engine in the silicon. -
  * notifying the user that the link is up. none
  */
-static void scic_sds_port_activate_phy(struct scic_sds_port *sci_port,
+static void scic_sds_port_activate_phy(struct isci_port *iport,
 				       struct isci_phy *iphy,
 				       bool do_notify_user)
 {
-	struct scic_sds_controller *scic = sci_port->owning_controller;
+	struct scic_sds_controller *scic = iport->owning_controller;
 	struct isci_host *ihost = scic_to_ihost(scic);
 
 	if (iphy->protocol != SCIC_SDS_PHY_PROTOCOL_SATA)
 		scic_sds_phy_resume(iphy);
 
-	sci_port->active_phy_mask |= 1 << iphy->phy_index;
+	iport->active_phy_mask |= 1 << iphy->phy_index;
 
 	scic_sds_controller_clear_invalid_phy(scic, iphy);
 
 	if (do_notify_user == true)
-		isci_port_link_up(ihost, sci_port, iphy);
+		isci_port_link_up(ihost, iport, iphy);
 }
 
-void scic_sds_port_deactivate_phy(struct scic_sds_port *sci_port,
+void scic_sds_port_deactivate_phy(struct isci_port *iport,
 				  struct isci_phy *iphy,
 				  bool do_notify_user)
 {
-	struct scic_sds_controller *scic = scic_sds_port_get_controller(sci_port);
-	struct isci_port *iport = sci_port_to_iport(sci_port);
+	struct scic_sds_controller *scic = scic_sds_port_get_controller(iport);
 	struct isci_host *ihost = scic_to_ihost(scic);
 
-	sci_port->active_phy_mask &= ~(1 << iphy->phy_index);
+	iport->active_phy_mask &= ~(1 << iphy->phy_index);
 
 	iphy->max_negotiated_speed = SAS_LINK_RATE_UNKNOWN;
 
 	/* Re-assign the phy back to the LP as if it were a narrow port */
 	writel(iphy->phy_index,
-		&sci_port->port_pe_configuration_register[iphy->phy_index]);
+		&iport->port_pe_configuration_register[iphy->phy_index]);
 
 	if (do_notify_user == true)
 		isci_port_link_down(ihost, iphy, iport);
@@ -795,10 +790,10 @@ void scic_sds_port_deactivate_phy(struct scic_sds_port *sci_port,
  * This function will disable the phy and report that the phy is not valid for
  * this port object. None
  */
-static void scic_sds_port_invalid_link_up(struct scic_sds_port *sci_port,
+static void scic_sds_port_invalid_link_up(struct isci_port *iport,
 					  struct isci_phy *iphy)
 {
-	struct scic_sds_controller *scic = sci_port->owning_controller;
+	struct scic_sds_controller *scic = iport->owning_controller;
 
 	/*
 	 * Check to see if we have alreay reported this link as bad and if
@@ -825,17 +820,17 @@ static bool is_port_ready_state(enum scic_sds_port_states state)
 }
 
 /* flag dummy rnc hanling when exiting a ready state */
-static void port_state_machine_change(struct scic_sds_port *sci_port,
+static void port_state_machine_change(struct isci_port *iport,
 				      enum scic_sds_port_states state)
 {
-	struct sci_base_state_machine *sm = &sci_port->sm;
+	struct sci_base_state_machine *sm = &iport->sm;
 	enum scic_sds_port_states old_state = sm->current_state_id;
 
 	if (is_port_ready_state(old_state) && !is_port_ready_state(state))
-		sci_port->ready_exit = true;
+		iport->ready_exit = true;
 
 	sci_change_state(sm, state);
-	sci_port->ready_exit = false;
+	iport->ready_exit = false;
 }
 
 /**
@@ -851,14 +846,14 @@ static void port_state_machine_change(struct scic_sds_port *sci_port,
  * part of a port if it's attached SAS ADDRESS is the same as all other PHYs in
  * the same port. none
  */
-static void scic_sds_port_general_link_up_handler(struct scic_sds_port *sci_port,
+static void scic_sds_port_general_link_up_handler(struct isci_port *iport,
 						  struct isci_phy *iphy,
 						  bool do_notify_user)
 {
 	struct sci_sas_address port_sas_address;
 	struct sci_sas_address phy_sas_address;
 
-	scic_sds_port_get_attached_sas_address(sci_port, &port_sas_address);
+	scic_sds_port_get_attached_sas_address(iport, &port_sas_address);
 	scic_sds_phy_get_attached_sas_address(iphy, &phy_sas_address);
 
 	/* If the SAS address of the new phy matches the SAS address of
@@ -868,14 +863,14 @@ static void scic_sds_port_general_link_up_handler(struct scic_sds_port *sci_port
 	 */
 	if ((phy_sas_address.high == port_sas_address.high &&
 	     phy_sas_address.low  == port_sas_address.low) ||
-	    sci_port->active_phy_mask == 0) {
-		struct sci_base_state_machine *sm = &sci_port->sm;
+	    iport->active_phy_mask == 0) {
+		struct sci_base_state_machine *sm = &iport->sm;
 
-		scic_sds_port_activate_phy(sci_port, iphy, do_notify_user);
+		scic_sds_port_activate_phy(iport, iphy, do_notify_user);
 		if (sm->current_state_id == SCI_PORT_RESETTING)
-			port_state_machine_change(sci_port, SCI_PORT_READY);
+			port_state_machine_change(iport, SCI_PORT_READY);
 	} else
-		scic_sds_port_invalid_link_up(sci_port, iphy);
+		scic_sds_port_invalid_link_up(iport, iphy);
 }
 
 
@@ -889,13 +884,13 @@ static void scic_sds_port_general_link_up_handler(struct scic_sds_port *sci_port
  * bool true Is returned if this is a wide ported port. false Is returned if
  * this is a narrow port.
  */
-static bool scic_sds_port_is_wide(struct scic_sds_port *sci_port)
+static bool scic_sds_port_is_wide(struct isci_port *iport)
 {
 	u32 index;
 	u32 phy_count = 0;
 
 	for (index = 0; index < SCI_MAX_PHYS; index++) {
-		if (sci_port->phy_table[index] != NULL) {
+		if (iport->phy_table[index] != NULL) {
 			phy_count++;
 		}
 	}
@@ -918,13 +913,13 @@ static bool scic_sds_port_is_wide(struct scic_sds_port *sci_port)
  * devices this could become an invalid port configuration.
  */
 bool scic_sds_port_link_detected(
-	struct scic_sds_port *sci_port,
+	struct isci_port *iport,
 	struct isci_phy *iphy)
 {
-	if ((sci_port->logical_port_index != SCIC_SDS_DUMMY_PORT) &&
+	if ((iport->logical_port_index != SCIC_SDS_DUMMY_PORT) &&
 	    (iphy->protocol == SCIC_SDS_PHY_PROTOCOL_SATA) &&
-	    scic_sds_port_is_wide(sci_port)) {
-		scic_sds_port_invalid_link_up(sci_port, iphy);
+	    scic_sds_port_is_wide(iport)) {
+		scic_sds_port_invalid_link_up(iport, iphy);
 
 		return false;
 	}
@@ -935,8 +930,8 @@ bool scic_sds_port_link_detected(
 static void port_timeout(unsigned long data)
 {
 	struct sci_timer *tmr = (struct sci_timer *)data;
-	struct scic_sds_port *sci_port = container_of(tmr, typeof(*sci_port), timer);
-	struct isci_host *ihost = scic_to_ihost(sci_port->owning_controller);
+	struct isci_port *iport = container_of(tmr, typeof(*iport), timer);
+	struct isci_host *ihost = scic_to_ihost(iport->owning_controller);
 	unsigned long flags;
 	u32 current_state;
 
@@ -945,33 +940,33 @@ static void port_timeout(unsigned long data)
 	if (tmr->cancel)
 		goto done;
 
-	current_state = sci_port->sm.current_state_id;
+	current_state = iport->sm.current_state_id;
 
 	if (current_state == SCI_PORT_RESETTING) {
 		/* if the port is still in the resetting state then the timeout
 		 * fired before the reset completed.
 		 */
-		port_state_machine_change(sci_port, SCI_PORT_FAILED);
+		port_state_machine_change(iport, SCI_PORT_FAILED);
 	} else if (current_state == SCI_PORT_STOPPED) {
 		/* if the port is stopped then the start request failed In this
 		 * case stay in the stopped state.
 		 */
-		dev_err(sciport_to_dev(sci_port),
+		dev_err(sciport_to_dev(iport),
 			"%s: SCIC Port 0x%p failed to stop before tiemout.\n",
 			__func__,
-			sci_port);
+			iport);
 	} else if (current_state == SCI_PORT_STOPPING) {
 		/* if the port is still stopping then the stop has not completed */
-		isci_port_stop_complete(sci_port->owning_controller,
-					sci_port,
+		isci_port_stop_complete(iport->owning_controller,
+					iport,
 					SCI_FAILURE_TIMEOUT);
 	} else {
 		/* The port is in the ready state and we have a timer
 		 * reporting a timeout this should not happen.
 		 */
-		dev_err(sciport_to_dev(sci_port),
+		dev_err(sciport_to_dev(iport),
 			"%s: SCIC Port 0x%p is processing a timeout operation "
-			"in state %d.\n", __func__, sci_port, current_state);
+			"in state %d.\n", __func__, iport, current_state);
 	}
 
 done:
@@ -985,29 +980,29 @@ static void port_timeout(unsigned long data)
  *
  *
  */
-static void scic_sds_port_update_viit_entry(struct scic_sds_port *sci_port)
+static void scic_sds_port_update_viit_entry(struct isci_port *iport)
 {
 	struct sci_sas_address sas_address;
 
-	scic_sds_port_get_sas_address(sci_port, &sas_address);
+	scic_sds_port_get_sas_address(iport, &sas_address);
 
 	writel(sas_address.high,
-		&sci_port->viit_registers->initiator_sas_address_hi);
+		&iport->viit_registers->initiator_sas_address_hi);
 	writel(sas_address.low,
-		&sci_port->viit_registers->initiator_sas_address_lo);
+		&iport->viit_registers->initiator_sas_address_lo);
 
 	/* This value get cleared just in case its not already cleared */
-	writel(0, &sci_port->viit_registers->reserved);
+	writel(0, &iport->viit_registers->reserved);
 
 	/* We are required to update the status register last */
 	writel(SCU_VIIT_ENTRY_ID_VIIT |
 	       SCU_VIIT_IPPT_INITIATOR |
-	       ((1 << sci_port->physical_port_index) << SCU_VIIT_ENTRY_LPVIE_SHIFT) |
+	       ((1 << iport->physical_port_index) << SCU_VIIT_ENTRY_LPVIE_SHIFT) |
 	       SCU_VIIT_STATUS_ALL_VALID,
-	       &sci_port->viit_registers->status);
+	       &iport->viit_registers->status);
 }
 
-enum sas_linkrate scic_sds_port_get_max_allowed_speed(struct scic_sds_port *sci_port)
+enum sas_linkrate scic_sds_port_get_max_allowed_speed(struct isci_port *iport)
 {
 	u16 index;
 	struct isci_phy *iphy;
@@ -1017,8 +1012,8 @@ enum sas_linkrate scic_sds_port_get_max_allowed_speed(struct scic_sds_port *sci_
 	 * Loop through all of the phys in this port and find the phy with the
 	 * lowest maximum link rate. */
 	for (index = 0; index < SCI_MAX_PHYS; index++) {
-		iphy = sci_port->phy_table[index];
-		if (iphy && scic_sds_port_active_phy(sci_port, iphy) &&
+		iphy = iport->phy_table[index];
+		if (iphy && scic_sds_port_active_phy(iport, iphy) &&
 		    iphy->max_negotiated_speed < max_allowed_speed)
 			max_allowed_speed = iphy->max_negotiated_speed;
 	}
@@ -1026,13 +1021,13 @@ enum sas_linkrate scic_sds_port_get_max_allowed_speed(struct scic_sds_port *sci_
 	return max_allowed_speed;
 }
 
-static void scic_sds_port_suspend_port_task_scheduler(struct scic_sds_port *port)
+static void scic_sds_port_suspend_port_task_scheduler(struct isci_port *iport)
 {
 	u32 pts_control_value;
 
-	pts_control_value = readl(&port->port_task_scheduler_registers->control);
+	pts_control_value = readl(&iport->port_task_scheduler_registers->control);
 	pts_control_value |= SCU_PTSxCR_GEN_BIT(SUSPEND);
-	writel(pts_control_value, &port->port_task_scheduler_registers->control);
+	writel(pts_control_value, &iport->port_task_scheduler_registers->control);
 }
 
 /**
@@ -1044,10 +1039,10 @@ static void scic_sds_port_suspend_port_task_scheduler(struct scic_sds_port *port
  * ongoing requests.
  *
  */
-static void scic_sds_port_post_dummy_request(struct scic_sds_port *sci_port)
+static void scic_sds_port_post_dummy_request(struct isci_port *iport)
 {
-	struct scic_sds_controller *scic = sci_port->owning_controller;
-	u16 tag = sci_port->reserved_tag;
+	struct scic_sds_controller *scic = iport->owning_controller;
+	u16 tag = iport->reserved_tag;
 	struct scu_task_context *tc;
 	u32 command;
 
@@ -1055,7 +1050,7 @@ static void scic_sds_port_post_dummy_request(struct scic_sds_port *sci_port)
 	tc->abort = 0;
 
 	command = SCU_CONTEXT_COMMAND_REQUEST_TYPE_POST_TC |
-		  sci_port->physical_port_index << SCU_CONTEXT_COMMAND_LOGICAL_PORT_SHIFT |
+		  iport->physical_port_index << SCU_CONTEXT_COMMAND_LOGICAL_PORT_SHIFT |
 		  ISCI_TAG_TCI(tag);
 
 	scic_sds_controller_post_request(scic, command);
@@ -1068,10 +1063,10 @@ static void scic_sds_port_post_dummy_request(struct scic_sds_port *sci_port)
  * @sci_port: The port on which the task must be aborted.
  *
  */
-static void scic_sds_port_abort_dummy_request(struct scic_sds_port *sci_port)
+static void scic_sds_port_abort_dummy_request(struct isci_port *iport)
 {
-	struct scic_sds_controller *scic = sci_port->owning_controller;
-	u16 tag = sci_port->reserved_tag;
+	struct scic_sds_controller *scic = iport->owning_controller;
+	u16 tag = iport->reserved_tag;
 	struct scu_task_context *tc;
 	u32 command;
 
@@ -1079,7 +1074,7 @@ static void scic_sds_port_abort_dummy_request(struct scic_sds_port *sci_port)
 	tc->abort = 1;
 
 	command = SCU_CONTEXT_COMMAND_REQUEST_POST_TC_ABORT |
-		  sci_port->physical_port_index << SCU_CONTEXT_COMMAND_LOGICAL_PORT_SHIFT |
+		  iport->physical_port_index << SCU_CONTEXT_COMMAND_LOGICAL_PORT_SHIFT |
 		  ISCI_TAG_TCI(tag);
 
 	scic_sds_controller_post_request(scic, command);
@@ -1087,31 +1082,31 @@ static void scic_sds_port_abort_dummy_request(struct scic_sds_port *sci_port)
 
 /**
  *
- * @sci_port: This is the struct scic_sds_port object to resume.
+ * @sci_port: This is the struct isci_port object to resume.
  *
  * This method will resume the port task scheduler for this port object. none
  */
 static void
-scic_sds_port_resume_port_task_scheduler(struct scic_sds_port *port)
+scic_sds_port_resume_port_task_scheduler(struct isci_port *iport)
 {
 	u32 pts_control_value;
 
-	pts_control_value = readl(&port->port_task_scheduler_registers->control);
+	pts_control_value = readl(&iport->port_task_scheduler_registers->control);
 	pts_control_value &= ~SCU_PTSxCR_GEN_BIT(SUSPEND);
-	writel(pts_control_value, &port->port_task_scheduler_registers->control);
+	writel(pts_control_value, &iport->port_task_scheduler_registers->control);
 }
 
 static void scic_sds_port_ready_substate_waiting_enter(struct sci_base_state_machine *sm)
 {
-	struct scic_sds_port *sci_port = container_of(sm, typeof(*sci_port), sm);
+	struct isci_port *iport = container_of(sm, typeof(*iport), sm);
 
-	scic_sds_port_suspend_port_task_scheduler(sci_port);
+	scic_sds_port_suspend_port_task_scheduler(iport);
 
-	sci_port->not_ready_reason = SCIC_PORT_NOT_READY_NO_ACTIVE_PHYS;
+	iport->not_ready_reason = SCIC_PORT_NOT_READY_NO_ACTIVE_PHYS;
 
-	if (sci_port->active_phy_mask != 0) {
+	if (iport->active_phy_mask != 0) {
 		/* At least one of the phys on the port is ready */
-		port_state_machine_change(sci_port,
+		port_state_machine_change(iport,
 					  SCI_PORT_SUB_OPERATIONAL);
 	}
 }
@@ -1119,38 +1114,37 @@ static void scic_sds_port_ready_substate_waiting_enter(struct sci_base_state_mac
 static void scic_sds_port_ready_substate_operational_enter(struct sci_base_state_machine *sm)
 {
 	u32 index;
-	struct scic_sds_port *sci_port = container_of(sm, typeof(*sci_port), sm);
-	struct scic_sds_controller *scic = sci_port->owning_controller;
+	struct isci_port *iport = container_of(sm, typeof(*iport), sm);
+	struct scic_sds_controller *scic = iport->owning_controller;
 	struct isci_host *ihost = scic_to_ihost(scic);
-	struct isci_port *iport = sci_port_to_iport(sci_port);
 
 	isci_port_ready(ihost, iport);
 
 	for (index = 0; index < SCI_MAX_PHYS; index++) {
-		if (sci_port->phy_table[index]) {
-			writel(sci_port->physical_port_index,
-				&sci_port->port_pe_configuration_register[
-					sci_port->phy_table[index]->phy_index]);
+		if (iport->phy_table[index]) {
+			writel(iport->physical_port_index,
+				&iport->port_pe_configuration_register[
+					iport->phy_table[index]->phy_index]);
 		}
 	}
 
-	scic_sds_port_update_viit_entry(sci_port);
+	scic_sds_port_update_viit_entry(iport);
 
-	scic_sds_port_resume_port_task_scheduler(sci_port);
+	scic_sds_port_resume_port_task_scheduler(iport);
 
 	/*
 	 * Post the dummy task for the port so the hardware can schedule
 	 * io correctly
 	 */
-	scic_sds_port_post_dummy_request(sci_port);
+	scic_sds_port_post_dummy_request(iport);
 }
 
-static void scic_sds_port_invalidate_dummy_remote_node(struct scic_sds_port *sci_port)
+static void scic_sds_port_invalidate_dummy_remote_node(struct isci_port *iport)
 {
-	struct scic_sds_controller *scic = sci_port->owning_controller;
-	u8 phys_index = sci_port->physical_port_index;
+	struct scic_sds_controller *scic = iport->owning_controller;
+	u8 phys_index = iport->physical_port_index;
 	union scu_remote_node_context *rnc;
-	u16 rni = sci_port->reserved_rni;
+	u16 rni = iport->reserved_rni;
 	u32 command;
 
 	rnc = &scic->remote_node_context_table[rni];
@@ -1172,73 +1166,71 @@ static void scic_sds_port_invalidate_dummy_remote_node(struct scic_sds_port *sci
 
 /**
  *
- * @object: This is the object which is cast to a struct scic_sds_port object.
+ * @object: This is the object which is cast to a struct isci_port object.
  *
- * This method will perform the actions required by the struct scic_sds_port on
+ * This method will perform the actions required by the struct isci_port on
  * exiting the SCI_PORT_SUB_OPERATIONAL. This function reports
  * the port not ready and suspends the port task scheduler. none
  */
 static void scic_sds_port_ready_substate_operational_exit(struct sci_base_state_machine *sm)
 {
-	struct scic_sds_port *sci_port = container_of(sm, typeof(*sci_port), sm);
-	struct scic_sds_controller *scic = sci_port->owning_controller;
+	struct isci_port *iport = container_of(sm, typeof(*iport), sm);
+	struct scic_sds_controller *scic = iport->owning_controller;
 	struct isci_host *ihost = scic_to_ihost(scic);
-	struct isci_port *iport = sci_port_to_iport(sci_port);
 
 	/*
 	 * Kill the dummy task for this port if it has not yet posted
 	 * the hardware will treat this as a NOP and just return abort
 	 * complete.
 	 */
-	scic_sds_port_abort_dummy_request(sci_port);
+	scic_sds_port_abort_dummy_request(iport);
 
 	isci_port_not_ready(ihost, iport);
 
-	if (sci_port->ready_exit)
-		scic_sds_port_invalidate_dummy_remote_node(sci_port);
+	if (iport->ready_exit)
+		scic_sds_port_invalidate_dummy_remote_node(iport);
 }
 
 static void scic_sds_port_ready_substate_configuring_enter(struct sci_base_state_machine *sm)
 {
-	struct scic_sds_port *sci_port = container_of(sm, typeof(*sci_port), sm);
-	struct scic_sds_controller *scic = sci_port->owning_controller;
+	struct isci_port *iport = container_of(sm, typeof(*iport), sm);
+	struct scic_sds_controller *scic = iport->owning_controller;
 	struct isci_host *ihost = scic_to_ihost(scic);
-	struct isci_port *iport = sci_port_to_iport(sci_port);
 
-	if (sci_port->active_phy_mask == 0) {
+	if (iport->active_phy_mask == 0) {
 		isci_port_not_ready(ihost, iport);
 
-		port_state_machine_change(sci_port,
+		port_state_machine_change(iport,
 					  SCI_PORT_SUB_WAITING);
-	} else if (sci_port->started_request_count == 0)
-		port_state_machine_change(sci_port,
+	} else if (iport->started_request_count == 0)
+		port_state_machine_change(iport,
 					  SCI_PORT_SUB_OPERATIONAL);
 }
 
 static void scic_sds_port_ready_substate_configuring_exit(struct sci_base_state_machine *sm)
 {
-	struct scic_sds_port *sci_port = container_of(sm, typeof(*sci_port), sm);
+	struct isci_port *iport = container_of(sm, typeof(*iport), sm);
 
-	scic_sds_port_suspend_port_task_scheduler(sci_port);
-	if (sci_port->ready_exit)
-		scic_sds_port_invalidate_dummy_remote_node(sci_port);
+	scic_sds_port_suspend_port_task_scheduler(iport);
+	if (iport->ready_exit)
+		scic_sds_port_invalidate_dummy_remote_node(iport);
 }
 
-enum sci_status scic_sds_port_start(struct scic_sds_port *sci_port)
+enum sci_status scic_sds_port_start(struct isci_port *iport)
 {
-	struct scic_sds_controller *scic = sci_port->owning_controller;
+	struct scic_sds_controller *scic = iport->owning_controller;
 	enum sci_status status = SCI_SUCCESS;
 	enum scic_sds_port_states state;
 	u32 phy_mask;
 
-	state = sci_port->sm.current_state_id;
+	state = iport->sm.current_state_id;
 	if (state != SCI_PORT_STOPPED) {
-		dev_warn(sciport_to_dev(sci_port),
+		dev_warn(sciport_to_dev(iport),
 			 "%s: in wrong state: %d\n", __func__, state);
 		return SCI_FAILURE_INVALID_STATE;
 	}
 
-	if (sci_port->assigned_device_count > 0) {
+	if (iport->assigned_device_count > 0) {
 		/* TODO This is a start failure operation because
 		 * there are still devices assigned to this port.
 		 * There must be no devices assigned to a port on a
@@ -1247,18 +1239,18 @@ enum sci_status scic_sds_port_start(struct scic_sds_port *sci_port)
 		return SCI_FAILURE_UNSUPPORTED_PORT_CONFIGURATION;
 	}
 
-	if (sci_port->reserved_rni == SCU_DUMMY_INDEX) {
+	if (iport->reserved_rni == SCU_DUMMY_INDEX) {
 		u16 rni = scic_sds_remote_node_table_allocate_remote_node(
 				&scic->available_remote_nodes, 1);
 
 		if (rni != SCU_DUMMY_INDEX)
-			scic_sds_port_construct_dummy_rnc(sci_port, rni);
+			scic_sds_port_construct_dummy_rnc(iport, rni);
 		else
 			status = SCI_FAILURE_INSUFFICIENT_RESOURCES;
-		sci_port->reserved_rni = rni;
+		iport->reserved_rni = rni;
 	}
 
-	if (sci_port->reserved_tag == SCI_CONTROLLER_INVALID_IO_TAG) {
+	if (iport->reserved_tag == SCI_CONTROLLER_INVALID_IO_TAG) {
 		struct isci_host *ihost = scic_to_ihost(scic);
 		u16 tag;
 
@@ -1266,20 +1258,20 @@ enum sci_status scic_sds_port_start(struct scic_sds_port *sci_port)
 		if (tag == SCI_CONTROLLER_INVALID_IO_TAG)
 			status = SCI_FAILURE_INSUFFICIENT_RESOURCES;
 		else
-			scic_sds_port_construct_dummy_task(sci_port, tag);
-		sci_port->reserved_tag = tag;
+			scic_sds_port_construct_dummy_task(iport, tag);
+		iport->reserved_tag = tag;
 	}
 
 	if (status == SCI_SUCCESS) {
-		phy_mask = scic_sds_port_get_phys(sci_port);
+		phy_mask = scic_sds_port_get_phys(iport);
 
 		/*
 		 * There are one or more phys assigned to this port.  Make sure
 		 * the port's phy mask is in fact legal and supported by the
 		 * silicon.
 		 */
-		if (scic_sds_port_is_phy_mask_valid(sci_port, phy_mask) == true) {
-			port_state_machine_change(sci_port,
+		if (scic_sds_port_is_phy_mask_valid(iport, phy_mask) == true) {
+			port_state_machine_change(iport,
 						  SCI_PORT_READY);
 
 			return SCI_SUCCESS;
@@ -1288,16 +1280,16 @@ enum sci_status scic_sds_port_start(struct scic_sds_port *sci_port)
 	}
 
 	if (status != SCI_SUCCESS)
-		scic_sds_port_destroy_dummy_resources(sci_port);
+		scic_sds_port_destroy_dummy_resources(iport);
 
 	return status;
 }
 
-enum sci_status scic_sds_port_stop(struct scic_sds_port *sci_port)
+enum sci_status scic_sds_port_stop(struct isci_port *iport)
 {
 	enum scic_sds_port_states state;
 
-	state = sci_port->sm.current_state_id;
+	state = iport->sm.current_state_id;
 	switch (state) {
 	case SCI_PORT_STOPPED:
 		return SCI_SUCCESS;
@@ -1305,34 +1297,34 @@ enum sci_status scic_sds_port_stop(struct scic_sds_port *sci_port)
 	case SCI_PORT_SUB_OPERATIONAL:
 	case SCI_PORT_SUB_CONFIGURING:
 	case SCI_PORT_RESETTING:
-		port_state_machine_change(sci_port,
+		port_state_machine_change(iport,
 					  SCI_PORT_STOPPING);
 		return SCI_SUCCESS;
 	default:
-		dev_warn(sciport_to_dev(sci_port),
+		dev_warn(sciport_to_dev(iport),
 			 "%s: in wrong state: %d\n", __func__, state);
 		return SCI_FAILURE_INVALID_STATE;
 	}
 }
 
-static enum sci_status scic_port_hard_reset(struct scic_sds_port *sci_port, u32 timeout)
+static enum sci_status scic_port_hard_reset(struct isci_port *iport, u32 timeout)
 {
 	enum sci_status status = SCI_FAILURE_INVALID_PHY;
 	struct isci_phy *iphy = NULL;
 	enum scic_sds_port_states state;
 	u32 phy_index;
 
-	state = sci_port->sm.current_state_id;
+	state = iport->sm.current_state_id;
 	if (state != SCI_PORT_SUB_OPERATIONAL) {
-		dev_warn(sciport_to_dev(sci_port),
+		dev_warn(sciport_to_dev(iport),
 			 "%s: in wrong state: %d\n", __func__, state);
 		return SCI_FAILURE_INVALID_STATE;
 	}
 
 	/* Select a phy on which we can send the hard reset request. */
 	for (phy_index = 0; phy_index < SCI_MAX_PHYS && !iphy; phy_index++) {
-		iphy = sci_port->phy_table[phy_index];
-		if (iphy && !scic_sds_port_active_phy(sci_port, iphy)) {
+		iphy = iport->phy_table[phy_index];
+		if (iphy && !scic_sds_port_active_phy(iport, iphy)) {
 			/*
 			 * We found a phy but it is not ready select
 			 * different phy
@@ -1349,10 +1341,10 @@ static enum sci_status scic_port_hard_reset(struct scic_sds_port *sci_port, u32
 	if (status != SCI_SUCCESS)
 		return status;
 
-	sci_mod_timer(&sci_port->timer, timeout);
-	sci_port->not_ready_reason = SCIC_PORT_NOT_READY_HARD_RESET_REQUESTED;
+	sci_mod_timer(&iport->timer, timeout);
+	iport->not_ready_reason = SCIC_PORT_NOT_READY_HARD_RESET_REQUESTED;
 
-	port_state_machine_change(sci_port, SCI_PORT_RESETTING);
+	port_state_machine_change(iport, SCI_PORT_RESETTING);
 	return SCI_SUCCESS;
 }
 
@@ -1365,19 +1357,19 @@ static enum sci_status scic_port_hard_reset(struct scic_sds_port *sci_port, u32
  * enum sci_status. SCI_SUCCESS the phy has been added to the port. Any other
  * status is a failure to add the phy to the port.
  */
-enum sci_status scic_sds_port_add_phy(struct scic_sds_port *sci_port,
+enum sci_status scic_sds_port_add_phy(struct isci_port *iport,
 				      struct isci_phy *iphy)
 {
 	enum sci_status status;
 	enum scic_sds_port_states state;
 
-	state = sci_port->sm.current_state_id;
+	state = iport->sm.current_state_id;
 	switch (state) {
 	case SCI_PORT_STOPPED: {
 		struct sci_sas_address port_sas_address;
 
 		/* Read the port assigned SAS Address if there is one */
-		scic_sds_port_get_sas_address(sci_port, &port_sas_address);
+		scic_sds_port_get_sas_address(iport, &port_sas_address);
 
 		if (port_sas_address.high != 0 && port_sas_address.low != 0) {
 			struct sci_sas_address phy_sas_address;
@@ -1391,35 +1383,35 @@ enum sci_status scic_sds_port_add_phy(struct scic_sds_port *sci_port,
 			    port_sas_address.low  != phy_sas_address.low)
 				return SCI_FAILURE_UNSUPPORTED_PORT_CONFIGURATION;
 		}
-		return scic_sds_port_set_phy(sci_port, iphy);
+		return scic_sds_port_set_phy(iport, iphy);
 	}
 	case SCI_PORT_SUB_WAITING:
 	case SCI_PORT_SUB_OPERATIONAL:
-		status = scic_sds_port_set_phy(sci_port, iphy);
+		status = scic_sds_port_set_phy(iport, iphy);
 
 		if (status != SCI_SUCCESS)
 			return status;
 
-		scic_sds_port_general_link_up_handler(sci_port, iphy, true);
-		sci_port->not_ready_reason = SCIC_PORT_NOT_READY_RECONFIGURING;
-		port_state_machine_change(sci_port, SCI_PORT_SUB_CONFIGURING);
+		scic_sds_port_general_link_up_handler(iport, iphy, true);
+		iport->not_ready_reason = SCIC_PORT_NOT_READY_RECONFIGURING;
+		port_state_machine_change(iport, SCI_PORT_SUB_CONFIGURING);
 
 		return status;
 	case SCI_PORT_SUB_CONFIGURING:
-		status = scic_sds_port_set_phy(sci_port, iphy);
+		status = scic_sds_port_set_phy(iport, iphy);
 
 		if (status != SCI_SUCCESS)
 			return status;
-		scic_sds_port_general_link_up_handler(sci_port, iphy, true);
+		scic_sds_port_general_link_up_handler(iport, iphy, true);
 
 		/* Re-enter the configuring state since this may be the last phy in
 		 * the port.
 		 */
-		port_state_machine_change(sci_port,
+		port_state_machine_change(iport,
 					  SCI_PORT_SUB_CONFIGURING);
 		return SCI_SUCCESS;
 	default:
-		dev_warn(sciport_to_dev(sci_port),
+		dev_warn(sciport_to_dev(iport),
 			 "%s: in wrong state: %d\n", __func__, state);
 		return SCI_FAILURE_INVALID_STATE;
 	}
@@ -1434,65 +1426,65 @@ enum sci_status scic_sds_port_add_phy(struct scic_sds_port *sci_port,
  * an enum sci_status. SCI_SUCCESS the phy has been removed from the port. Any
  * other status is a failure to add the phy to the port.
  */
-enum sci_status scic_sds_port_remove_phy(struct scic_sds_port *sci_port,
+enum sci_status scic_sds_port_remove_phy(struct isci_port *iport,
 					 struct isci_phy *iphy)
 {
 	enum sci_status status;
 	enum scic_sds_port_states state;
 
-	state = sci_port->sm.current_state_id;
+	state = iport->sm.current_state_id;
 
 	switch (state) {
 	case SCI_PORT_STOPPED:
-		return scic_sds_port_clear_phy(sci_port, iphy);
+		return scic_sds_port_clear_phy(iport, iphy);
 	case SCI_PORT_SUB_OPERATIONAL:
-		status = scic_sds_port_clear_phy(sci_port, iphy);
+		status = scic_sds_port_clear_phy(iport, iphy);
 		if (status != SCI_SUCCESS)
 			return status;
 
-		scic_sds_port_deactivate_phy(sci_port, iphy, true);
-		sci_port->not_ready_reason = SCIC_PORT_NOT_READY_RECONFIGURING;
-		port_state_machine_change(sci_port,
+		scic_sds_port_deactivate_phy(iport, iphy, true);
+		iport->not_ready_reason = SCIC_PORT_NOT_READY_RECONFIGURING;
+		port_state_machine_change(iport,
 					  SCI_PORT_SUB_CONFIGURING);
 		return SCI_SUCCESS;
 	case SCI_PORT_SUB_CONFIGURING:
-		status = scic_sds_port_clear_phy(sci_port, iphy);
+		status = scic_sds_port_clear_phy(iport, iphy);
 
 		if (status != SCI_SUCCESS)
 			return status;
-		scic_sds_port_deactivate_phy(sci_port, iphy, true);
+		scic_sds_port_deactivate_phy(iport, iphy, true);
 
 		/* Re-enter the configuring state since this may be the last phy in
 		 * the port
 		 */
-		port_state_machine_change(sci_port,
+		port_state_machine_change(iport,
 					  SCI_PORT_SUB_CONFIGURING);
 		return SCI_SUCCESS;
 	default:
-		dev_warn(sciport_to_dev(sci_port),
+		dev_warn(sciport_to_dev(iport),
 			 "%s: in wrong state: %d\n", __func__, state);
 		return SCI_FAILURE_INVALID_STATE;
 	}
 }
 
-enum sci_status scic_sds_port_link_up(struct scic_sds_port *sci_port,
+enum sci_status scic_sds_port_link_up(struct isci_port *iport,
 				      struct isci_phy *iphy)
 {
 	enum scic_sds_port_states state;
 
-	state = sci_port->sm.current_state_id;
+	state = iport->sm.current_state_id;
 	switch (state) {
 	case SCI_PORT_SUB_WAITING:
 		/* Since this is the first phy going link up for the port we
 		 * can just enable it and continue
 		 */
-		scic_sds_port_activate_phy(sci_port, iphy, true);
+		scic_sds_port_activate_phy(iport, iphy, true);
 
-		port_state_machine_change(sci_port,
+		port_state_machine_change(iport,
 					  SCI_PORT_SUB_OPERATIONAL);
 		return SCI_SUCCESS;
 	case SCI_PORT_SUB_OPERATIONAL:
-		scic_sds_port_general_link_up_handler(sci_port, iphy, true);
+		scic_sds_port_general_link_up_handler(iport, iphy, true);
 		return SCI_SUCCESS;
 	case SCI_PORT_RESETTING:
 		/* TODO We should  make  sure  that  the phy  that  has gone
@@ -1509,82 +1501,82 @@ enum sci_status scic_sds_port_link_up(struct scic_sds_port *sci_port,
 		/* In the resetting state we don't notify the user regarding
 		 * link up and link down notifications.
 		 */
-		scic_sds_port_general_link_up_handler(sci_port, iphy, false);
+		scic_sds_port_general_link_up_handler(iport, iphy, false);
 		return SCI_SUCCESS;
 	default:
-		dev_warn(sciport_to_dev(sci_port),
+		dev_warn(sciport_to_dev(iport),
 			 "%s: in wrong state: %d\n", __func__, state);
 		return SCI_FAILURE_INVALID_STATE;
 	}
 }
 
-enum sci_status scic_sds_port_link_down(struct scic_sds_port *sci_port,
+enum sci_status scic_sds_port_link_down(struct isci_port *iport,
 					struct isci_phy *iphy)
 {
 	enum scic_sds_port_states state;
 
-	state = sci_port->sm.current_state_id;
+	state = iport->sm.current_state_id;
 	switch (state) {
 	case SCI_PORT_SUB_OPERATIONAL:
-		scic_sds_port_deactivate_phy(sci_port, iphy, true);
+		scic_sds_port_deactivate_phy(iport, iphy, true);
 
 		/* If there are no active phys left in the port, then
 		 * transition the port to the WAITING state until such time
 		 * as a phy goes link up
 		 */
-		if (sci_port->active_phy_mask == 0)
-			port_state_machine_change(sci_port,
+		if (iport->active_phy_mask == 0)
+			port_state_machine_change(iport,
 						  SCI_PORT_SUB_WAITING);
 		return SCI_SUCCESS;
 	case SCI_PORT_RESETTING:
 		/* In the resetting state we don't notify the user regarding
 		 * link up and link down notifications. */
-		scic_sds_port_deactivate_phy(sci_port, iphy, false);
+		scic_sds_port_deactivate_phy(iport, iphy, false);
 		return SCI_SUCCESS;
 	default:
-		dev_warn(sciport_to_dev(sci_port),
+		dev_warn(sciport_to_dev(iport),
 			 "%s: in wrong state: %d\n", __func__, state);
 		return SCI_FAILURE_INVALID_STATE;
 	}
 }
 
-enum sci_status scic_sds_port_start_io(struct scic_sds_port *sci_port,
+enum sci_status scic_sds_port_start_io(struct isci_port *iport,
 				       struct scic_sds_remote_device *sci_dev,
 				       struct isci_request *ireq)
 {
 	enum scic_sds_port_states state;
 
-	state = sci_port->sm.current_state_id;
+	state = iport->sm.current_state_id;
 	switch (state) {
 	case SCI_PORT_SUB_WAITING:
 		return SCI_FAILURE_INVALID_STATE;
 	case SCI_PORT_SUB_OPERATIONAL:
-		sci_port->started_request_count++;
+		iport->started_request_count++;
 		return SCI_SUCCESS;
 	default:
-		dev_warn(sciport_to_dev(sci_port),
+		dev_warn(sciport_to_dev(iport),
 			 "%s: in wrong state: %d\n", __func__, state);
 		return SCI_FAILURE_INVALID_STATE;
 	}
 }
 
-enum sci_status scic_sds_port_complete_io(struct scic_sds_port *sci_port,
+enum sci_status scic_sds_port_complete_io(struct isci_port *iport,
 					  struct scic_sds_remote_device *sci_dev,
 					  struct isci_request *ireq)
 {
 	enum scic_sds_port_states state;
 
-	state = sci_port->sm.current_state_id;
+	state = iport->sm.current_state_id;
 	switch (state) {
 	case SCI_PORT_STOPPED:
-		dev_warn(sciport_to_dev(sci_port),
+		dev_warn(sciport_to_dev(iport),
 			 "%s: in wrong state: %d\n", __func__, state);
 		return SCI_FAILURE_INVALID_STATE;
 	case SCI_PORT_STOPPING:
-		scic_sds_port_decrement_request_count(sci_port);
+		scic_sds_port_decrement_request_count(iport);
 
-		if (sci_port->started_request_count == 0)
-			port_state_machine_change(sci_port,
+		if (iport->started_request_count == 0)
+			port_state_machine_change(iport,
 						  SCI_PORT_STOPPED);
 		break;
 	case SCI_PORT_READY:
@@ -1592,12 +1584,12 @@ enum sci_status scic_sds_port_complete_io(struct scic_sds_port *sci_port,
 	case SCI_PORT_FAILED:
 	case SCI_PORT_SUB_WAITING:
 	case SCI_PORT_SUB_OPERATIONAL:
-		scic_sds_port_decrement_request_count(sci_port);
+		scic_sds_port_decrement_request_count(iport);
 		break;
 	case SCI_PORT_SUB_CONFIGURING:
-		scic_sds_port_decrement_request_count(sci_port);
-		if (sci_port->started_request_count == 0) {
-			port_state_machine_change(sci_port,
+		scic_sds_port_decrement_request_count(iport);
+		if (iport->started_request_count == 0) {
+			port_state_machine_change(iport,
 						  SCI_PORT_SUB_OPERATIONAL);
 		}
 		break;
@@ -1613,13 +1605,13 @@ enum sci_status scic_sds_port_complete_io(struct scic_sds_port *sci_port,
  * will leave the port task scheduler in a suspended state. none
  */
 static void
-scic_sds_port_enable_port_task_scheduler(struct scic_sds_port *port)
+scic_sds_port_enable_port_task_scheduler(struct isci_port *iport)
 {
 	u32 pts_control_value;
 
-	pts_control_value = readl(&port->port_task_scheduler_registers->control);
+	pts_control_value = readl(&iport->port_task_scheduler_registers->control);
 	pts_control_value |= SCU_PTSxCR_GEN_BIT(ENABLE) | SCU_PTSxCR_GEN_BIT(SUSPEND);
-	writel(pts_control_value, &port->port_task_scheduler_registers->control);
+	writel(pts_control_value, &iport->port_task_scheduler_registers->control);
 }
 
 /**
@@ -1630,22 +1622,22 @@ scic_sds_port_enable_port_task_scheduler(struct scic_sds_port *port)
  * none
  */
 static void
-scic_sds_port_disable_port_task_scheduler(struct scic_sds_port *port)
+scic_sds_port_disable_port_task_scheduler(struct isci_port *iport)
 {
 	u32 pts_control_value;
 
-	pts_control_value = readl(&port->port_task_scheduler_registers->control);
+	pts_control_value = readl(&iport->port_task_scheduler_registers->control);
 	pts_control_value &=
 		~(SCU_PTSxCR_GEN_BIT(ENABLE) | SCU_PTSxCR_GEN_BIT(SUSPEND));
-	writel(pts_control_value, &port->port_task_scheduler_registers->control);
+	writel(pts_control_value, &iport->port_task_scheduler_registers->control);
 }
 
-static void scic_sds_port_post_dummy_remote_node(struct scic_sds_port *sci_port)
+static void scic_sds_port_post_dummy_remote_node(struct isci_port *iport)
 {
-	struct scic_sds_controller *scic = sci_port->owning_controller;
-	u8 phys_index = sci_port->physical_port_index;
+	struct scic_sds_controller *scic = iport->owning_controller;
+	u8 phys_index = iport->physical_port_index;
 	union scu_remote_node_context *rnc;
-	u16 rni = sci_port->reserved_rni;
+	u16 rni = iport->reserved_rni;
 	u32 command;
 
 	rnc = &scic->remote_node_context_table[rni];
@@ -1670,67 +1662,65 @@ static void scic_sds_port_post_dummy_remote_node(struct scic_sds_port *sci_port)
 
 static void scic_sds_port_stopped_state_enter(struct sci_base_state_machine *sm)
 {
-	struct scic_sds_port *sci_port = container_of(sm, typeof(*sci_port), sm);
+	struct isci_port *iport = container_of(sm, typeof(*iport), sm);
 
-	if (sci_port->sm.previous_state_id == SCI_PORT_STOPPING) {
+	if (iport->sm.previous_state_id == SCI_PORT_STOPPING) {
 		/*
 		 * If we enter this state becasuse of a request to stop
 		 * the port then we want to disable the hardwares port
 		 * task scheduler. */
-		scic_sds_port_disable_port_task_scheduler(sci_port);
+		scic_sds_port_disable_port_task_scheduler(iport);
 	}
 }
 
 static void scic_sds_port_stopped_state_exit(struct sci_base_state_machine *sm)
 {
-	struct scic_sds_port *sci_port = container_of(sm, typeof(*sci_port), sm);
+	struct isci_port *iport = container_of(sm, typeof(*iport), sm);
 
 	/* Enable and suspend the port task scheduler */
-	scic_sds_port_enable_port_task_scheduler(sci_port);
+	scic_sds_port_enable_port_task_scheduler(iport);
 }
 
 static void scic_sds_port_ready_state_enter(struct sci_base_state_machine *sm)
 {
-	struct scic_sds_port *sci_port = container_of(sm, typeof(*sci_port), sm);
-	struct scic_sds_controller *scic = sci_port->owning_controller;
+	struct isci_port *iport = container_of(sm, typeof(*iport), sm);
+	struct scic_sds_controller *scic = iport->owning_controller;
 	struct isci_host *ihost = scic_to_ihost(scic);
-	struct isci_port *iport = sci_port_to_iport(sci_port);
 	u32 prev_state;
 
-	prev_state = sci_port->sm.previous_state_id;
+	prev_state = iport->sm.previous_state_id;
 	if (prev_state  == SCI_PORT_RESETTING)
 		isci_port_hard_reset_complete(iport, SCI_SUCCESS);
 	else
 		isci_port_not_ready(ihost, iport);
 
 	/* Post and suspend the dummy remote node context for this port. */
-	scic_sds_port_post_dummy_remote_node(sci_port);
+	scic_sds_port_post_dummy_remote_node(iport);
 
 	/* Start the ready substate machine */
-	port_state_machine_change(sci_port,
+	port_state_machine_change(iport,
 				  SCI_PORT_SUB_WAITING);
 }
 
 static void scic_sds_port_resetting_state_exit(struct sci_base_state_machine *sm)
 {
-	struct scic_sds_port *sci_port = container_of(sm, typeof(*sci_port), sm);
+	struct isci_port *iport = container_of(sm, typeof(*iport), sm);
 
-	sci_del_timer(&sci_port->timer);
+	sci_del_timer(&iport->timer);
 }
 
 static void scic_sds_port_stopping_state_exit(struct sci_base_state_machine *sm)
 {
-	struct scic_sds_port *sci_port = container_of(sm, typeof(*sci_port), sm);
+	struct isci_port *iport = container_of(sm, typeof(*iport), sm);
 
-	sci_del_timer(&sci_port->timer);
+	sci_del_timer(&iport->timer);
 
-	scic_sds_port_destroy_dummy_resources(sci_port);
+	scic_sds_port_destroy_dummy_resources(iport);
 }
 
 static void scic_sds_port_failed_state_enter(struct sci_base_state_machine *sm)
 {
-	struct scic_sds_port *sci_port = container_of(sm, typeof(*sci_port), sm);
-	struct isci_port *iport = sci_port_to_iport(sci_port);
+	struct isci_port *iport = container_of(sm, typeof(*iport), sm);
 
 	isci_port_hard_reset_complete(iport, SCI_FAILURE_TIMEOUT);
 }
@@ -1767,30 +1757,30 @@ static const struct sci_base_state scic_sds_port_state_table[] = {
 	}
 };
 
-void scic_sds_port_construct(struct scic_sds_port *sci_port, u8 index,
+void scic_sds_port_construct(struct isci_port *iport, u8 index,
 			     struct scic_sds_controller *scic)
 {
-	sci_init_sm(&sci_port->sm, scic_sds_port_state_table, SCI_PORT_STOPPED);
+	sci_init_sm(&iport->sm, scic_sds_port_state_table, SCI_PORT_STOPPED);
 
-	sci_port->logical_port_index  = SCIC_SDS_DUMMY_PORT;
-	sci_port->physical_port_index = index;
-	sci_port->active_phy_mask     = 0;
-	sci_port->ready_exit	      = false;
+	iport->logical_port_index  = SCIC_SDS_DUMMY_PORT;
+	iport->physical_port_index = index;
+	iport->active_phy_mask     = 0;
+	iport->ready_exit	      = false;
 
-	sci_port->owning_controller = scic;
+	iport->owning_controller = scic;
 
-	sci_port->started_request_count = 0;
-	sci_port->assigned_device_count = 0;
+	iport->started_request_count = 0;
+	iport->assigned_device_count = 0;
 
-	sci_port->reserved_rni = SCU_DUMMY_INDEX;
-	sci_port->reserved_tag = SCI_CONTROLLER_INVALID_IO_TAG;
+	iport->reserved_rni = SCU_DUMMY_INDEX;
+	iport->reserved_tag = SCI_CONTROLLER_INVALID_IO_TAG;
 
-	sci_init_timer(&sci_port->timer, port_timeout);
+	sci_init_timer(&iport->timer, port_timeout);
 
-	sci_port->port_task_scheduler_registers = NULL;
+	iport->port_task_scheduler_registers = NULL;
 
 	for (index = 0; index < SCI_MAX_PHYS; index++)
-		sci_port->phy_table[index] = NULL;
+		iport->phy_table[index] = NULL;
 }
 
 void isci_port_init(struct isci_port *iport, struct isci_host *ihost, int index)
@@ -1817,14 +1807,14 @@ enum isci_status isci_port_get_state(
 }
 
 void scic_sds_port_broadcast_change_received(
-	struct scic_sds_port *sci_port,
+	struct isci_port *iport,
 	struct isci_phy *iphy)
 {
-	struct scic_sds_controller *scic = sci_port->owning_controller;
+	struct scic_sds_controller *scic = iport->owning_controller;
 	struct isci_host *ihost = scic_to_ihost(scic);
 
 	/* notify the user. */
-	isci_port_bc_change_received(ihost, sci_port, iphy);
+	isci_port_bc_change_received(ihost, iport, iphy);
 }
 
 int isci_port_perform_hard_reset(struct isci_host *ihost, struct isci_port *iport,
@@ -1842,7 +1832,7 @@ int isci_port_perform_hard_reset(struct isci_host *ihost, struct isci_port *ipor
 	spin_lock_irqsave(&ihost->scic_lock, flags);
 
 	#define ISCI_PORT_RESET_TIMEOUT SCIC_SDS_SIGNATURE_FIS_TIMEOUT
-	status = scic_port_hard_reset(&iport->sci, ISCI_PORT_RESET_TIMEOUT);
+	status = scic_port_hard_reset(iport, ISCI_PORT_RESET_TIMEOUT);
 
 	spin_unlock_irqrestore(&ihost->scic_lock, flags);
 
@@ -1878,14 +1868,12 @@ int isci_port_perform_hard_reset(struct isci_host *ihost, struct isci_port *ipor
 		/* Down all phys in the port. */
 		spin_lock_irqsave(&ihost->scic_lock, flags);
 		for (idx = 0; idx < SCI_MAX_PHYS; ++idx) {
+			struct isci_phy *iphy = iport->phy_table[idx];
 
-			if (iport->sci.phy_table[idx] != NULL) {
-
-				scic_sds_phy_stop(
-					iport->sci.phy_table[idx]);
-				scic_sds_phy_start(
-					iport->sci.phy_table[idx]);
-			}
+			if (!iphy)
+				continue;
+			scic_sds_phy_stop(iphy);
+			scic_sds_phy_start(iphy);
 		}
 		spin_unlock_irqrestore(&ihost->scic_lock, flags);
 	}

commit 852809559e4680ba4768262a6c3d21454fcd460e
Author: Dan Williams <dan.j.williams@intel.com>
Date:   Tue Jun 28 15:05:53 2011 -0700

    isci: unify isci_phy and scic_sds_phy
    
    They are one in the same object so remove the distinction.  The near
    duplicate fields (owning_port, and isci_port) will be cleaned up
    after the scic_sds_port isci_port unification.
    
    Reported-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/drivers/scsi/isci/port.c b/drivers/scsi/isci/port.c
index bd091549b4f7..d53c0b1748e7 100644
--- a/drivers/scsi/isci/port.c
+++ b/drivers/scsi/isci/port.c
@@ -154,17 +154,17 @@ static enum sci_status scic_port_get_properties(struct scic_sds_port *port,
 
 static void scic_port_bcn_enable(struct scic_sds_port *sci_port)
 {
-	struct scic_sds_phy *sci_phy;
+	struct isci_phy *iphy;
 	u32 val;
 	int i;
 
 	for (i = 0; i < ARRAY_SIZE(sci_port->phy_table); i++) {
-		sci_phy = sci_port->phy_table[i];
-		if (!sci_phy)
+		iphy = sci_port->phy_table[i];
+		if (!iphy)
 			continue;
-		val = readl(&sci_phy->link_layer_registers->link_layer_control);
+		val = readl(&iphy->link_layer_registers->link_layer_control);
 		/* clear the bit by writing 1. */
-		writel(val, &sci_phy->link_layer_registers->link_layer_control);
+		writel(val, &iphy->link_layer_registers->link_layer_control);
 	}
 }
 
@@ -180,10 +180,9 @@ void isci_port_bcn_enable(struct isci_host *ihost, struct isci_port *iport)
 		return;
 
 	for (i = 0; i < ARRAY_SIZE(iport->sci.phy_table); i++) {
-		struct scic_sds_phy *sci_phy = iport->sci.phy_table[i];
-		struct isci_phy *iphy = sci_phy_to_iphy(sci_phy);
+		struct isci_phy *iphy = iport->sci.phy_table[i];
 
-		if (!sci_phy)
+		if (!iphy)
 			continue;
 
 		ihost->sas_ha.notify_port_event(&iphy->sas_phy,
@@ -194,9 +193,8 @@ void isci_port_bcn_enable(struct isci_host *ihost, struct isci_port *iport)
 
 void isci_port_bc_change_received(struct isci_host *ihost,
 				  struct scic_sds_port *sci_port,
-				  struct scic_sds_phy *sci_phy)
+				  struct isci_phy *iphy)
 {
-	struct isci_phy *iphy = sci_phy_to_iphy(sci_phy);
 	struct isci_port *iport = iphy->isci_port;
 
 	if (iport && test_bit(IPORT_BCN_BLOCKED, &iport->flags)) {
@@ -219,33 +217,32 @@ void isci_port_bc_change_received(struct isci_host *ihost,
 
 static void isci_port_link_up(struct isci_host *isci_host,
 			      struct scic_sds_port *port,
-			      struct scic_sds_phy *phy)
+			      struct isci_phy *iphy)
 {
 	unsigned long flags;
 	struct scic_port_properties properties;
-	struct isci_phy *isci_phy = sci_phy_to_iphy(phy);
 	struct isci_port *isci_port = sci_port_to_iport(port);
 	unsigned long success = true;
 
-	BUG_ON(isci_phy->isci_port != NULL);
+	BUG_ON(iphy->isci_port != NULL);
 
-	isci_phy->isci_port = isci_port;
+	iphy->isci_port = isci_port;
 
 	dev_dbg(&isci_host->pdev->dev,
 		"%s: isci_port = %p\n",
 		__func__, isci_port);
 
-	spin_lock_irqsave(&isci_phy->sas_phy.frame_rcvd_lock, flags);
+	spin_lock_irqsave(&iphy->sas_phy.frame_rcvd_lock, flags);
 
-	isci_port_change_state(isci_phy->isci_port, isci_starting);
+	isci_port_change_state(iphy->isci_port, isci_starting);
 
 	scic_port_get_properties(port, &properties);
 
-	if (phy->protocol == SCIC_SDS_PHY_PROTOCOL_SATA) {
+	if (iphy->protocol == SCIC_SDS_PHY_PROTOCOL_SATA) {
 		u64 attached_sas_address;
 
-		isci_phy->sas_phy.oob_mode = SATA_OOB_MODE;
-		isci_phy->sas_phy.frame_rcvd_size = sizeof(struct dev_to_host_fis);
+		iphy->sas_phy.oob_mode = SATA_OOB_MODE;
+		iphy->sas_phy.frame_rcvd_size = sizeof(struct dev_to_host_fis);
 
 		/*
 		 * For direct-attached SATA devices, the SCI core will
@@ -259,28 +256,28 @@ static void isci_port_link_up(struct isci_host *isci_host,
 		attached_sas_address |= properties.remote.sas_address.low;
 		swab64s(&attached_sas_address);
 
-		memcpy(&isci_phy->sas_phy.attached_sas_addr,
+		memcpy(&iphy->sas_phy.attached_sas_addr,
 		       &attached_sas_address, sizeof(attached_sas_address));
-	} else if (phy->protocol == SCIC_SDS_PHY_PROTOCOL_SAS) {
-		isci_phy->sas_phy.oob_mode = SAS_OOB_MODE;
-		isci_phy->sas_phy.frame_rcvd_size = sizeof(struct sas_identify_frame);
+	} else if (iphy->protocol == SCIC_SDS_PHY_PROTOCOL_SAS) {
+		iphy->sas_phy.oob_mode = SAS_OOB_MODE;
+		iphy->sas_phy.frame_rcvd_size = sizeof(struct sas_identify_frame);
 
 		/* Copy the attached SAS address from the IAF */
-		memcpy(isci_phy->sas_phy.attached_sas_addr,
-		       isci_phy->frame_rcvd.iaf.sas_addr, SAS_ADDR_SIZE);
+		memcpy(iphy->sas_phy.attached_sas_addr,
+		       iphy->frame_rcvd.iaf.sas_addr, SAS_ADDR_SIZE);
 	} else {
 		dev_err(&isci_host->pdev->dev, "%s: unkown target\n", __func__);
 		success = false;
 	}
 
-	isci_phy->sas_phy.phy->negotiated_linkrate = sci_phy_linkrate(phy);
+	iphy->sas_phy.phy->negotiated_linkrate = sci_phy_linkrate(iphy);
 
-	spin_unlock_irqrestore(&isci_phy->sas_phy.frame_rcvd_lock, flags);
+	spin_unlock_irqrestore(&iphy->sas_phy.frame_rcvd_lock, flags);
 
 	/* Notify libsas that we have an address frame, if indeed
 	 * we've found an SSP, SMP, or STP target */
 	if (success)
-		isci_host->sas_ha.notify_port_event(&isci_phy->sas_phy,
+		isci_host->sas_ha.notify_port_event(&iphy->sas_phy,
 						    PORTE_BYTES_DMAED);
 }
 
@@ -495,11 +492,7 @@ static bool scic_sds_port_is_phy_mask_valid(
 	return false;
 }
 
-/**
- *
- * @sci_port: This parameter specifies the port from which to return a
- *    connected phy.
- *
+/*
  * This method retrieves a currently active (i.e. connected) phy contained in
  * the port.  Currently, the lowest order phy that is connected is returned.
  * This method returns a pointer to a SCIS_SDS_PHY object. NULL This value is
@@ -507,58 +500,38 @@ static bool scic_sds_port_is_phy_mask_valid(
  * point) phys contained in the port. All other values specify a struct scic_sds_phy
  * object that is active in the port.
  */
-static struct scic_sds_phy *scic_sds_port_get_a_connected_phy(
-	struct scic_sds_port *sci_port
-	) {
+static struct isci_phy *scic_sds_port_get_a_connected_phy(struct scic_sds_port *sci_port)
+{
 	u32 index;
-	struct scic_sds_phy *phy;
+	struct isci_phy *iphy;
 
 	for (index = 0; index < SCI_MAX_PHYS; index++) {
-		/*
-		 * Ensure that the phy is both part of the port and currently
-		 * connected to the remote end-point. */
-		phy = sci_port->phy_table[index];
-		if (
-			(phy != NULL)
-			&& scic_sds_port_active_phy(sci_port, phy)
-			) {
-			return phy;
-		}
+		/* Ensure that the phy is both part of the port and currently
+		 * connected to the remote end-point.
+		 */
+		iphy = sci_port->phy_table[index];
+		if (iphy && scic_sds_port_active_phy(sci_port, iphy))
+			return iphy;
 	}
 
 	return NULL;
 }
 
-/**
- * scic_sds_port_set_phy() -
- * @out]: port The port object to which the phy assignement is being made.
- * @out]: phy The phy which is being assigned to the port.
- *
- * This method attempts to make the assignment of the phy to the port. If
- * successful the phy is assigned to the ports phy table. bool true if the phy
- * assignment can be made. false if the phy assignement can not be made. This
- * is a functional test that only fails if the phy is currently assigned to a
- * different port.
- */
-static enum sci_status scic_sds_port_set_phy(
-	struct scic_sds_port *port,
-	struct scic_sds_phy *phy)
+static enum sci_status scic_sds_port_set_phy(struct scic_sds_port *port, struct isci_phy *iphy)
 {
-	/*
-	 * Check to see if we can add this phy to a port
+	/* Check to see if we can add this phy to a port
 	 * that means that the phy is not part of a port and that the port does
-	 * not already have a phy assinged to the phy index. */
-	if (
-		(port->phy_table[phy->phy_index] == NULL)
-		&& (phy_get_non_dummy_port(phy) == NULL)
-		&& scic_sds_port_is_valid_phy_assignment(port, phy->phy_index)
-		) {
-		/*
-		 * Phy is being added in the stopped state so we are in MPC mode
-		 * make logical port index = physical port index */
+	 * not already have a phy assinged to the phy index.
+	 */
+	if (!port->phy_table[iphy->phy_index] &&
+	    !phy_get_non_dummy_port(iphy) &&
+	    scic_sds_port_is_valid_phy_assignment(port, iphy->phy_index)) {
+		/* Phy is being added in the stopped state so we are in MPC mode
+		 * make logical port index = physical port index
+		 */
 		port->logical_port_index = port->physical_port_index;
-		port->phy_table[phy->phy_index] = phy;
-		scic_sds_phy_set_port(phy, port);
+		port->phy_table[iphy->phy_index] = iphy;
+		scic_sds_phy_set_port(iphy, port);
 
 		return SCI_SUCCESS;
 	}
@@ -566,28 +539,18 @@ static enum sci_status scic_sds_port_set_phy(
 	return SCI_FAILURE;
 }
 
-/**
- * scic_sds_port_clear_phy() -
- * @out]: port The port from which the phy is being cleared.
- * @out]: phy The phy being cleared from the port.
- *
- * This method will clear the phy assigned to this port.  This method fails if
- * this phy is not currently assinged to this port. bool true if the phy is
- * removed from the port. false if this phy is not assined to this port.
- */
-static enum sci_status scic_sds_port_clear_phy(
-	struct scic_sds_port *port,
-	struct scic_sds_phy *phy)
+static enum sci_status scic_sds_port_clear_phy(struct scic_sds_port *port,
+					       struct isci_phy *iphy)
 {
 	/* Make sure that this phy is part of this port */
-	if (port->phy_table[phy->phy_index] == phy &&
-	    phy_get_non_dummy_port(phy) == port) {
+	if (port->phy_table[iphy->phy_index] == iphy &&
+	    phy_get_non_dummy_port(iphy) == port) {
 		struct scic_sds_controller *scic = port->owning_controller;
 		struct isci_host *ihost = scic_to_ihost(scic);
 
 		/* Yep it is assigned to this port so remove it */
-		scic_sds_phy_set_port(phy, &ihost->ports[SCI_MAX_PORTS].sci);
-		port->phy_table[phy->phy_index] = NULL;
+		scic_sds_phy_set_port(iphy, &ihost->ports[SCI_MAX_PORTS].sci);
+		port->phy_table[iphy->phy_index] = NULL;
 		return SCI_SUCCESS;
 	}
 
@@ -634,20 +597,20 @@ void scic_sds_port_get_attached_sas_address(
 	struct scic_sds_port *sci_port,
 	struct sci_sas_address *sas_address)
 {
-	struct scic_sds_phy *sci_phy;
+	struct isci_phy *iphy;
 
 	/*
 	 * Ensure that the phy is both part of the port and currently
 	 * connected to the remote end-point.
 	 */
-	sci_phy = scic_sds_port_get_a_connected_phy(sci_port);
-	if (sci_phy) {
-		if (sci_phy->protocol != SCIC_SDS_PHY_PROTOCOL_SATA) {
-			scic_sds_phy_get_attached_sas_address(sci_phy,
+	iphy = scic_sds_port_get_a_connected_phy(sci_port);
+	if (iphy) {
+		if (iphy->protocol != SCIC_SDS_PHY_PROTOCOL_SATA) {
+			scic_sds_phy_get_attached_sas_address(iphy,
 							      sas_address);
 		} else {
-			scic_sds_phy_get_sas_address(sci_phy, sas_address);
-			sas_address->low += sci_phy->phy_index;
+			scic_sds_phy_get_sas_address(iphy, sas_address);
+			sas_address->low += iphy->phy_index;
 		}
 	} else {
 		sas_address->high = 0;
@@ -787,39 +750,38 @@ void scic_sds_port_setup_transports(
  * notifying the user that the link is up. none
  */
 static void scic_sds_port_activate_phy(struct scic_sds_port *sci_port,
-				       struct scic_sds_phy *sci_phy,
+				       struct isci_phy *iphy,
 				       bool do_notify_user)
 {
 	struct scic_sds_controller *scic = sci_port->owning_controller;
 	struct isci_host *ihost = scic_to_ihost(scic);
 
-	if (sci_phy->protocol != SCIC_SDS_PHY_PROTOCOL_SATA)
-		scic_sds_phy_resume(sci_phy);
+	if (iphy->protocol != SCIC_SDS_PHY_PROTOCOL_SATA)
+		scic_sds_phy_resume(iphy);
 
-	sci_port->active_phy_mask |= 1 << sci_phy->phy_index;
+	sci_port->active_phy_mask |= 1 << iphy->phy_index;
 
-	scic_sds_controller_clear_invalid_phy(scic, sci_phy);
+	scic_sds_controller_clear_invalid_phy(scic, iphy);
 
 	if (do_notify_user == true)
-		isci_port_link_up(ihost, sci_port, sci_phy);
+		isci_port_link_up(ihost, sci_port, iphy);
 }
 
 void scic_sds_port_deactivate_phy(struct scic_sds_port *sci_port,
-				  struct scic_sds_phy *sci_phy,
+				  struct isci_phy *iphy,
 				  bool do_notify_user)
 {
 	struct scic_sds_controller *scic = scic_sds_port_get_controller(sci_port);
 	struct isci_port *iport = sci_port_to_iport(sci_port);
 	struct isci_host *ihost = scic_to_ihost(scic);
-	struct isci_phy *iphy = sci_phy_to_iphy(sci_phy);
 
-	sci_port->active_phy_mask &= ~(1 << sci_phy->phy_index);
+	sci_port->active_phy_mask &= ~(1 << iphy->phy_index);
 
-	sci_phy->max_negotiated_speed = SAS_LINK_RATE_UNKNOWN;
+	iphy->max_negotiated_speed = SAS_LINK_RATE_UNKNOWN;
 
 	/* Re-assign the phy back to the LP as if it were a narrow port */
-	writel(sci_phy->phy_index,
-		&sci_port->port_pe_configuration_register[sci_phy->phy_index]);
+	writel(iphy->phy_index,
+		&sci_port->port_pe_configuration_register[iphy->phy_index]);
 
 	if (do_notify_user == true)
 		isci_port_link_down(ihost, iphy, iport);
@@ -834,7 +796,7 @@ void scic_sds_port_deactivate_phy(struct scic_sds_port *sci_port,
  * this port object. None
  */
 static void scic_sds_port_invalid_link_up(struct scic_sds_port *sci_port,
-					  struct scic_sds_phy *sci_phy)
+					  struct isci_phy *iphy)
 {
 	struct scic_sds_controller *scic = sci_port->owning_controller;
 
@@ -843,8 +805,8 @@ static void scic_sds_port_invalid_link_up(struct scic_sds_port *sci_port,
 	 * not go ahead and tell the SCI_USER that we have discovered an
 	 * invalid link.
 	 */
-	if ((scic->invalid_phy_mask & (1 << sci_phy->phy_index)) == 0) {
-		scic_sds_controller_set_invalid_phy(scic, sci_phy);
+	if ((scic->invalid_phy_mask & (1 << iphy->phy_index)) == 0) {
+		scic_sds_controller_set_invalid_phy(scic, iphy);
 		dev_warn(&scic_to_ihost(scic)->pdev->dev, "Invalid link up!\n");
 	}
 }
@@ -879,7 +841,7 @@ static void port_state_machine_change(struct scic_sds_port *sci_port,
 /**
  * scic_sds_port_general_link_up_handler - phy can be assigned to port?
  * @sci_port: scic_sds_port object for which has a phy that has gone link up.
- * @sci_phy: This is the struct scic_sds_phy object that has gone link up.
+ * @sci_phy: This is the struct isci_phy object that has gone link up.
  * @do_notify_user: This parameter specifies whether to inform the user (via
  *    scic_cb_port_link_up()) as to the fact that a new phy as become ready.
  *
@@ -890,14 +852,14 @@ static void port_state_machine_change(struct scic_sds_port *sci_port,
  * the same port. none
  */
 static void scic_sds_port_general_link_up_handler(struct scic_sds_port *sci_port,
-						  struct scic_sds_phy *sci_phy,
+						  struct isci_phy *iphy,
 						  bool do_notify_user)
 {
 	struct sci_sas_address port_sas_address;
 	struct sci_sas_address phy_sas_address;
 
 	scic_sds_port_get_attached_sas_address(sci_port, &port_sas_address);
-	scic_sds_phy_get_attached_sas_address(sci_phy, &phy_sas_address);
+	scic_sds_phy_get_attached_sas_address(iphy, &phy_sas_address);
 
 	/* If the SAS address of the new phy matches the SAS address of
 	 * other phys in the port OR this is the first phy in the port,
@@ -909,11 +871,11 @@ static void scic_sds_port_general_link_up_handler(struct scic_sds_port *sci_port
 	    sci_port->active_phy_mask == 0) {
 		struct sci_base_state_machine *sm = &sci_port->sm;
 
-		scic_sds_port_activate_phy(sci_port, sci_phy, do_notify_user);
+		scic_sds_port_activate_phy(sci_port, iphy, do_notify_user);
 		if (sm->current_state_id == SCI_PORT_RESETTING)
 			port_state_machine_change(sci_port, SCI_PORT_READY);
 	} else
-		scic_sds_port_invalid_link_up(sci_port, sci_phy);
+		scic_sds_port_invalid_link_up(sci_port, iphy);
 }
 
 
@@ -957,12 +919,12 @@ static bool scic_sds_port_is_wide(struct scic_sds_port *sci_port)
  */
 bool scic_sds_port_link_detected(
 	struct scic_sds_port *sci_port,
-	struct scic_sds_phy *sci_phy)
+	struct isci_phy *iphy)
 {
 	if ((sci_port->logical_port_index != SCIC_SDS_DUMMY_PORT) &&
-	    (sci_phy->protocol == SCIC_SDS_PHY_PROTOCOL_SATA) &&
+	    (iphy->protocol == SCIC_SDS_PHY_PROTOCOL_SATA) &&
 	    scic_sds_port_is_wide(sci_port)) {
-		scic_sds_port_invalid_link_up(sci_port, sci_phy);
+		scic_sds_port_invalid_link_up(sci_port, iphy);
 
 		return false;
 	}
@@ -1045,47 +1007,26 @@ static void scic_sds_port_update_viit_entry(struct scic_sds_port *sci_port)
 	       &sci_port->viit_registers->status);
 }
 
-/**
- * This method returns the maximum allowed speed for data transfers on this
- *    port.  This maximum allowed speed evaluates to the maximum speed of the
- *    slowest phy in the port.
- * @sci_port: This parameter specifies the port for which to retrieve the
- *    maximum allowed speed.
- *
- * This method returns the maximum negotiated speed of the slowest phy in the
- * port.
- */
-enum sas_linkrate scic_sds_port_get_max_allowed_speed(
-	struct scic_sds_port *sci_port)
+enum sas_linkrate scic_sds_port_get_max_allowed_speed(struct scic_sds_port *sci_port)
 {
 	u16 index;
+	struct isci_phy *iphy;
 	enum sas_linkrate max_allowed_speed = SAS_LINK_RATE_6_0_GBPS;
-	struct scic_sds_phy *phy = NULL;
 
 	/*
 	 * Loop through all of the phys in this port and find the phy with the
 	 * lowest maximum link rate. */
 	for (index = 0; index < SCI_MAX_PHYS; index++) {
-		phy = sci_port->phy_table[index];
-		if (
-			(phy != NULL)
-			&& (scic_sds_port_active_phy(sci_port, phy) == true)
-			&& (phy->max_negotiated_speed < max_allowed_speed)
-			)
-			max_allowed_speed = phy->max_negotiated_speed;
+		iphy = sci_port->phy_table[index];
+		if (iphy && scic_sds_port_active_phy(sci_port, iphy) &&
+		    iphy->max_negotiated_speed < max_allowed_speed)
+			max_allowed_speed = iphy->max_negotiated_speed;
 	}
 
 	return max_allowed_speed;
 }
 
-/**
- *
- * @sci_port: This is the struct scic_sds_port object to suspend.
- *
- * This method will susped the port task scheduler for this port object. none
- */
-static void
-scic_sds_port_suspend_port_task_scheduler(struct scic_sds_port *port)
+static void scic_sds_port_suspend_port_task_scheduler(struct scic_sds_port *port)
 {
 	u32 pts_control_value;
 
@@ -1377,7 +1318,7 @@ enum sci_status scic_sds_port_stop(struct scic_sds_port *sci_port)
 static enum sci_status scic_port_hard_reset(struct scic_sds_port *sci_port, u32 timeout)
 {
 	enum sci_status status = SCI_FAILURE_INVALID_PHY;
-	struct scic_sds_phy *selected_phy = NULL;
+	struct isci_phy *iphy = NULL;
 	enum scic_sds_port_states state;
 	u32 phy_index;
 
@@ -1389,22 +1330,21 @@ static enum sci_status scic_port_hard_reset(struct scic_sds_port *sci_port, u32
 	}
 
 	/* Select a phy on which we can send the hard reset request. */
-	for (phy_index = 0; phy_index < SCI_MAX_PHYS && !selected_phy; phy_index++) {
-		selected_phy = sci_port->phy_table[phy_index];
-		if (selected_phy &&
-		    !scic_sds_port_active_phy(sci_port, selected_phy)) {
+	for (phy_index = 0; phy_index < SCI_MAX_PHYS && !iphy; phy_index++) {
+		iphy = sci_port->phy_table[phy_index];
+		if (iphy && !scic_sds_port_active_phy(sci_port, iphy)) {
 			/*
 			 * We found a phy but it is not ready select
 			 * different phy
 			 */
-			selected_phy = NULL;
+			iphy = NULL;
 		}
 	}
 
 	/* If we have a phy then go ahead and start the reset procedure */
-	if (!selected_phy)
+	if (!iphy)
 		return status;
-	status = scic_sds_phy_reset(selected_phy);
+	status = scic_sds_phy_reset(iphy);
 
 	if (status != SCI_SUCCESS)
 		return status;
@@ -1412,8 +1352,7 @@ static enum sci_status scic_port_hard_reset(struct scic_sds_port *sci_port, u32
 	sci_mod_timer(&sci_port->timer, timeout);
 	sci_port->not_ready_reason = SCIC_PORT_NOT_READY_HARD_RESET_REQUESTED;
 
-	port_state_machine_change(sci_port,
-				  SCI_PORT_RESETTING);
+	port_state_machine_change(sci_port, SCI_PORT_RESETTING);
 	return SCI_SUCCESS;
 }
 
@@ -1427,7 +1366,7 @@ static enum sci_status scic_port_hard_reset(struct scic_sds_port *sci_port, u32
  * status is a failure to add the phy to the port.
  */
 enum sci_status scic_sds_port_add_phy(struct scic_sds_port *sci_port,
-				      struct scic_sds_phy *sci_phy)
+				      struct isci_phy *iphy)
 {
 	enum sci_status status;
 	enum scic_sds_port_states state;
@@ -1446,32 +1385,32 @@ enum sci_status scic_sds_port_add_phy(struct scic_sds_port *sci_port,
 			/* Make sure that the PHY SAS Address matches the SAS Address
 			 * for this port
 			 */
-			scic_sds_phy_get_sas_address(sci_phy, &phy_sas_address);
+			scic_sds_phy_get_sas_address(iphy, &phy_sas_address);
 
 			if (port_sas_address.high != phy_sas_address.high ||
 			    port_sas_address.low  != phy_sas_address.low)
 				return SCI_FAILURE_UNSUPPORTED_PORT_CONFIGURATION;
 		}
-		return scic_sds_port_set_phy(sci_port, sci_phy);
+		return scic_sds_port_set_phy(sci_port, iphy);
 	}
 	case SCI_PORT_SUB_WAITING:
 	case SCI_PORT_SUB_OPERATIONAL:
-		status = scic_sds_port_set_phy(sci_port, sci_phy);
+		status = scic_sds_port_set_phy(sci_port, iphy);
 
 		if (status != SCI_SUCCESS)
 			return status;
 
-		scic_sds_port_general_link_up_handler(sci_port, sci_phy, true);
+		scic_sds_port_general_link_up_handler(sci_port, iphy, true);
 		sci_port->not_ready_reason = SCIC_PORT_NOT_READY_RECONFIGURING;
 		port_state_machine_change(sci_port, SCI_PORT_SUB_CONFIGURING);
 
 		return status;
 	case SCI_PORT_SUB_CONFIGURING:
-		status = scic_sds_port_set_phy(sci_port, sci_phy);
+		status = scic_sds_port_set_phy(sci_port, iphy);
 
 		if (status != SCI_SUCCESS)
 			return status;
-		scic_sds_port_general_link_up_handler(sci_port, sci_phy, true);
+		scic_sds_port_general_link_up_handler(sci_port, iphy, true);
 
 		/* Re-enter the configuring state since this may be the last phy in
 		 * the port.
@@ -1496,7 +1435,7 @@ enum sci_status scic_sds_port_add_phy(struct scic_sds_port *sci_port,
  * other status is a failure to add the phy to the port.
  */
 enum sci_status scic_sds_port_remove_phy(struct scic_sds_port *sci_port,
-					 struct scic_sds_phy *sci_phy)
+					 struct isci_phy *iphy)
 {
 	enum sci_status status;
 	enum scic_sds_port_states state;
@@ -1505,23 +1444,23 @@ enum sci_status scic_sds_port_remove_phy(struct scic_sds_port *sci_port,
 
 	switch (state) {
 	case SCI_PORT_STOPPED:
-		return scic_sds_port_clear_phy(sci_port, sci_phy);
+		return scic_sds_port_clear_phy(sci_port, iphy);
 	case SCI_PORT_SUB_OPERATIONAL:
-		status = scic_sds_port_clear_phy(sci_port, sci_phy);
+		status = scic_sds_port_clear_phy(sci_port, iphy);
 		if (status != SCI_SUCCESS)
 			return status;
 
-		scic_sds_port_deactivate_phy(sci_port, sci_phy, true);
+		scic_sds_port_deactivate_phy(sci_port, iphy, true);
 		sci_port->not_ready_reason = SCIC_PORT_NOT_READY_RECONFIGURING;
 		port_state_machine_change(sci_port,
 					  SCI_PORT_SUB_CONFIGURING);
 		return SCI_SUCCESS;
 	case SCI_PORT_SUB_CONFIGURING:
-		status = scic_sds_port_clear_phy(sci_port, sci_phy);
+		status = scic_sds_port_clear_phy(sci_port, iphy);
 
 		if (status != SCI_SUCCESS)
 			return status;
-		scic_sds_port_deactivate_phy(sci_port, sci_phy, true);
+		scic_sds_port_deactivate_phy(sci_port, iphy, true);
 
 		/* Re-enter the configuring state since this may be the last phy in
 		 * the port
@@ -1537,7 +1476,7 @@ enum sci_status scic_sds_port_remove_phy(struct scic_sds_port *sci_port,
 }
 
 enum sci_status scic_sds_port_link_up(struct scic_sds_port *sci_port,
-				      struct scic_sds_phy *sci_phy)
+				      struct isci_phy *iphy)
 {
 	enum scic_sds_port_states state;
 
@@ -1547,13 +1486,13 @@ enum sci_status scic_sds_port_link_up(struct scic_sds_port *sci_port,
 		/* Since this is the first phy going link up for the port we
 		 * can just enable it and continue
 		 */
-		scic_sds_port_activate_phy(sci_port, sci_phy, true);
+		scic_sds_port_activate_phy(sci_port, iphy, true);
 
 		port_state_machine_change(sci_port,
 					  SCI_PORT_SUB_OPERATIONAL);
 		return SCI_SUCCESS;
 	case SCI_PORT_SUB_OPERATIONAL:
-		scic_sds_port_general_link_up_handler(sci_port, sci_phy, true);
+		scic_sds_port_general_link_up_handler(sci_port, iphy, true);
 		return SCI_SUCCESS;
 	case SCI_PORT_RESETTING:
 		/* TODO We should  make  sure  that  the phy  that  has gone
@@ -1570,7 +1509,7 @@ enum sci_status scic_sds_port_link_up(struct scic_sds_port *sci_port,
 		/* In the resetting state we don't notify the user regarding
 		 * link up and link down notifications.
 		 */
-		scic_sds_port_general_link_up_handler(sci_port, sci_phy, false);
+		scic_sds_port_general_link_up_handler(sci_port, iphy, false);
 		return SCI_SUCCESS;
 	default:
 		dev_warn(sciport_to_dev(sci_port),
@@ -1580,14 +1519,14 @@ enum sci_status scic_sds_port_link_up(struct scic_sds_port *sci_port,
 }
 
 enum sci_status scic_sds_port_link_down(struct scic_sds_port *sci_port,
-					struct scic_sds_phy *sci_phy)
+					struct isci_phy *iphy)
 {
 	enum scic_sds_port_states state;
 
 	state = sci_port->sm.current_state_id;
 	switch (state) {
 	case SCI_PORT_SUB_OPERATIONAL:
-		scic_sds_port_deactivate_phy(sci_port, sci_phy, true);
+		scic_sds_port_deactivate_phy(sci_port, iphy, true);
 
 		/* If there are no active phys left in the port, then
 		 * transition the port to the WAITING state until such time
@@ -1600,7 +1539,7 @@ enum sci_status scic_sds_port_link_down(struct scic_sds_port *sci_port,
 	case SCI_PORT_RESETTING:
 		/* In the resetting state we don't notify the user regarding
 		 * link up and link down notifications. */
-		scic_sds_port_deactivate_phy(sci_port, sci_phy, false);
+		scic_sds_port_deactivate_phy(sci_port, iphy, false);
 		return SCI_SUCCESS;
 	default:
 		dev_warn(sciport_to_dev(sci_port),
@@ -1879,13 +1818,13 @@ enum isci_status isci_port_get_state(
 
 void scic_sds_port_broadcast_change_received(
 	struct scic_sds_port *sci_port,
-	struct scic_sds_phy *sci_phy)
+	struct isci_phy *iphy)
 {
 	struct scic_sds_controller *scic = sci_port->owning_controller;
 	struct isci_host *ihost = scic_to_ihost(scic);
 
 	/* notify the user. */
-	isci_port_bc_change_received(ihost, sci_port, sci_phy);
+	isci_port_bc_change_received(ihost, sci_port, iphy);
 }
 
 int isci_port_perform_hard_reset(struct isci_host *ihost, struct isci_port *iport,

commit 5076a1a97e2fa61c847a5fdd4b1991faf7716da6
Author: Dan Williams <dan.j.williams@intel.com>
Date:   Mon Jun 27 14:57:03 2011 -0700

    isci: unify isci_request and scic_sds_request
    
    They are one in the same object so remove the distinction.  The near
    duplicate fields (owning_controller, and isci_host) will be cleaned up
    after the scic_sds_contoller isci_host unification.
    
    Reported-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/drivers/scsi/isci/port.c b/drivers/scsi/isci/port.c
index 0e84e29335dd..bd091549b4f7 100644
--- a/drivers/scsi/isci/port.c
+++ b/drivers/scsi/isci/port.c
@@ -1611,7 +1611,7 @@ enum sci_status scic_sds_port_link_down(struct scic_sds_port *sci_port,
 
 enum sci_status scic_sds_port_start_io(struct scic_sds_port *sci_port,
 				       struct scic_sds_remote_device *sci_dev,
-				       struct scic_sds_request *sci_req)
+				       struct isci_request *ireq)
 {
 	enum scic_sds_port_states state;
 
@@ -1631,7 +1631,7 @@ enum sci_status scic_sds_port_start_io(struct scic_sds_port *sci_port,
 
 enum sci_status scic_sds_port_complete_io(struct scic_sds_port *sci_port,
 					  struct scic_sds_remote_device *sci_dev,
-					  struct scic_sds_request *sci_req)
+					  struct isci_request *ireq)
 {
 	enum scic_sds_port_states state;
 

commit 312e0c2455c18716cf640d4336dcb1e9e5053818
Author: Dan Williams <dan.j.williams@intel.com>
Date:   Tue Jun 28 13:47:09 2011 -0700

    isci: unify can_queue tracking on the tci_pool, uplevel tag assignment
    
    The tci_pool tracks our outstanding command slots which are also the 'index'
    portion of our tags.  Grabbing the tag early in ->lldd_execute_task let's us
    drop the isci_host_can_queue() and ->was_tag_assigned_by_user infrastructure.
    ->was_tag_assigned_by_user required the task context to be duplicated in
    request-local buffer.  With the tci established early we can build the
    task_context directly into its final location and skip a memcpy.
    
    With the task context buffer at a known address at request construction we
    have the opportunity/obligation to also fix sgl handling.  This rework feels
    like it belongs in another patch but the sgl handling and task_context are too
    intertwined.
    1/ fix the 'ab' pair embedded in the task context to point to the 'cd' pair in
       the task context (previously we were prematurely linking to the staging
       buffer).
    2/ fix the broken iteration of pio sgls that assumes all sgls are relative to
       the request, and does a dangerous looking reverse lookup of physical
       address to virtual address.
    
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/drivers/scsi/isci/port.c b/drivers/scsi/isci/port.c
index 5f4a4e3954db..0e84e29335dd 100644
--- a/drivers/scsi/isci/port.c
+++ b/drivers/scsi/isci/port.c
@@ -695,35 +695,21 @@ static void scic_sds_port_construct_dummy_rnc(struct scic_sds_port *sci_port, u1
  */
 static void scic_sds_port_construct_dummy_task(struct scic_sds_port *sci_port, u16 tag)
 {
+	struct scic_sds_controller *scic = sci_port->owning_controller;
 	struct scu_task_context *task_context;
 
-	task_context = scic_sds_controller_get_task_context_buffer(sci_port->owning_controller, tag);
-
+	task_context = &scic->task_context_table[ISCI_TAG_TCI(tag)];
 	memset(task_context, 0, sizeof(struct scu_task_context));
 
-	task_context->abort = 0;
-	task_context->priority = 0;
 	task_context->initiator_request = 1;
 	task_context->connection_rate = 1;
-	task_context->protocol_engine_index = 0;
 	task_context->logical_port_index = sci_port->physical_port_index;
 	task_context->protocol_type = SCU_TASK_CONTEXT_PROTOCOL_SSP;
 	task_context->task_index = ISCI_TAG_TCI(tag);
 	task_context->valid = SCU_TASK_CONTEXT_VALID;
 	task_context->context_type = SCU_TASK_CONTEXT_TYPE;
-
 	task_context->remote_node_index = sci_port->reserved_rni;
-	task_context->command_code = 0;
-
-	task_context->link_layer_control = 0;
 	task_context->do_not_dma_ssp_good_response = 1;
-	task_context->strict_ordering = 0;
-	task_context->control_frame = 0;
-	task_context->timeout_enable = 0;
-	task_context->block_guard_enable = 0;
-
-	task_context->address_modifier = 0;
-
 	task_context->task_phase = 0x01;
 }
 
@@ -731,15 +717,15 @@ static void scic_sds_port_destroy_dummy_resources(struct scic_sds_port *sci_port
 {
 	struct scic_sds_controller *scic = sci_port->owning_controller;
 
-	if (sci_port->reserved_tci != SCU_DUMMY_INDEX)
-		scic_controller_free_io_tag(scic, sci_port->reserved_tci);
+	if (sci_port->reserved_tag != SCI_CONTROLLER_INVALID_IO_TAG)
+		isci_free_tag(scic_to_ihost(scic), sci_port->reserved_tag);
 
 	if (sci_port->reserved_rni != SCU_DUMMY_INDEX)
 		scic_sds_remote_node_table_release_remote_node_index(&scic->available_remote_nodes,
 								     1, sci_port->reserved_rni);
 
 	sci_port->reserved_rni = SCU_DUMMY_INDEX;
-	sci_port->reserved_tci = SCU_DUMMY_INDEX;
+	sci_port->reserved_tag = SCI_CONTROLLER_INVALID_IO_TAG;
 }
 
 /**
@@ -1119,18 +1105,17 @@ scic_sds_port_suspend_port_task_scheduler(struct scic_sds_port *port)
  */
 static void scic_sds_port_post_dummy_request(struct scic_sds_port *sci_port)
 {
-	u32 command;
-	struct scu_task_context *task_context;
 	struct scic_sds_controller *scic = sci_port->owning_controller;
-	u16 tci = sci_port->reserved_tci;
-
-	task_context = scic_sds_controller_get_task_context_buffer(scic, tci);
+	u16 tag = sci_port->reserved_tag;
+	struct scu_task_context *tc;
+	u32 command;
 
-	task_context->abort = 0;
+	tc = &scic->task_context_table[ISCI_TAG_TCI(tag)];
+	tc->abort = 0;
 
 	command = SCU_CONTEXT_COMMAND_REQUEST_TYPE_POST_TC |
 		  sci_port->physical_port_index << SCU_CONTEXT_COMMAND_LOGICAL_PORT_SHIFT |
-		  tci;
+		  ISCI_TAG_TCI(tag);
 
 	scic_sds_controller_post_request(scic, command);
 }
@@ -1145,17 +1130,16 @@ static void scic_sds_port_post_dummy_request(struct scic_sds_port *sci_port)
 static void scic_sds_port_abort_dummy_request(struct scic_sds_port *sci_port)
 {
 	struct scic_sds_controller *scic = sci_port->owning_controller;
-	u16 tci = sci_port->reserved_tci;
+	u16 tag = sci_port->reserved_tag;
 	struct scu_task_context *tc;
 	u32 command;
 
-	tc = scic_sds_controller_get_task_context_buffer(scic, tci);
-
+	tc = &scic->task_context_table[ISCI_TAG_TCI(tag)];
 	tc->abort = 1;
 
 	command = SCU_CONTEXT_COMMAND_REQUEST_POST_TC_ABORT |
 		  sci_port->physical_port_index << SCU_CONTEXT_COMMAND_LOGICAL_PORT_SHIFT |
-		  tci;
+		  ISCI_TAG_TCI(tag);
 
 	scic_sds_controller_post_request(scic, command);
 }
@@ -1333,15 +1317,16 @@ enum sci_status scic_sds_port_start(struct scic_sds_port *sci_port)
 		sci_port->reserved_rni = rni;
 	}
 
-	if (sci_port->reserved_tci == SCU_DUMMY_INDEX) {
-		/* Allocate a TCI and remove the sequence nibble */
-		u16 tci = scic_controller_allocate_io_tag(scic);
+	if (sci_port->reserved_tag == SCI_CONTROLLER_INVALID_IO_TAG) {
+		struct isci_host *ihost = scic_to_ihost(scic);
+		u16 tag;
 
-		if (tci != SCU_DUMMY_INDEX)
-			scic_sds_port_construct_dummy_task(sci_port, tci);
-		else
+		tag = isci_alloc_tag(ihost);
+		if (tag == SCI_CONTROLLER_INVALID_IO_TAG)
 			status = SCI_FAILURE_INSUFFICIENT_RESOURCES;
-		sci_port->reserved_tci = tci;
+		else
+			scic_sds_port_construct_dummy_task(sci_port, tag);
+		sci_port->reserved_tag = tag;
 	}
 
 	if (status == SCI_SUCCESS) {
@@ -1859,7 +1844,7 @@ void scic_sds_port_construct(struct scic_sds_port *sci_port, u8 index,
 	sci_port->assigned_device_count = 0;
 
 	sci_port->reserved_rni = SCU_DUMMY_INDEX;
-	sci_port->reserved_tci = SCU_DUMMY_INDEX;
+	sci_port->reserved_tag = SCI_CONTROLLER_INVALID_IO_TAG;
 
 	sci_init_timer(&sci_port->timer, port_timeout);
 

commit 209fae14fabfd48525e5630bebbbd4ca15090c60
Author: Dan Williams <dan.j.williams@intel.com>
Date:   Mon Jun 13 17:39:44 2011 -0700

    isci: atomic device lookup and reference counting
    
    We have unsafe references to remote devices that are notified to
    disappear at lldd_dev_gone.  In order to clean this up we need a single
    canonical source for device lookups and stable references once a lookup
    succeeds.  Towards that end guarantee that domain_device.lldd_dev is
    NULL as soon as we start the process of stopping a device.  Any code
    path that wants to safely lookup a remote device must do so through
    task->dev->lldd_dev (isci_lookup_device()).
    
    For in-flight references outside of scic_lock we need reference counting
    to ensure that the device is not recycled before we are done with it.
    Simplify device back references to just scic_sds_request.target_device
    which is now the only permissible internal reference that is maintained
    relative to the reference count.
    
    There were two occasions where we wanted new i/o's to be treated as
    SAS_TASK_UNDELIVERED but where the domain_dev->lldd_dev link is still
    intact.  Introduce a 'gone' flag to prevent i/o while waiting for libsas
    to take action on the port down event.
    
    One 'core' leftover is that we currently call
    scic_remote_device_destruct() from isci_remote_device_deconstruct()
    which is called when the 'core' says the device is stopped.  It would be
    more natural for the final put to trigger
    isci_remote_device_deconstruct() but this implementation is deferred as
    it requires other changes.
    
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/drivers/scsi/isci/port.c b/drivers/scsi/isci/port.c
index fb66e30da075..5f4a4e3954db 100644
--- a/drivers/scsi/isci/port.c
+++ b/drivers/scsi/isci/port.c
@@ -321,8 +321,7 @@ static void isci_port_link_down(struct isci_host *isci_host,
 				dev_dbg(&isci_host->pdev->dev,
 					"%s: isci_device = %p\n",
 					__func__, isci_device);
-				isci_remote_device_change_state(isci_device,
-								isci_stopping);
+				set_bit(IDEV_GONE, &isci_device->flags);
 			}
 		}
 		isci_port_change_state(isci_port, isci_stopping);

commit dd047c8e2bca22856050dbe0378a37cf44eecc97
Author: Dan Williams <dan.j.williams@intel.com>
Date:   Thu Jun 9 11:06:58 2011 -0700

    isci: cleanup tag macros
    
    A tag is a 16 bit number where the upper four bits is a sequence number
    and the remainder is the task context index (tci).  Sanitize the macro
    names and shave 256-bytes out of scic_sds_controller by reducing the size of
    io_request_sequence.
    
    scic_sds_io_tag_construct --> ISCI_TAG
    scic_sds_io_tag_get_sequence --> ISCI_TAG_SEQ
    scic_sds_io_tag_get_index() --> ISCI_TAG_TCI
    scic_sds_io_sequence_increment() [delete / open code]
    
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/drivers/scsi/isci/port.c b/drivers/scsi/isci/port.c
index e540281ebd49..fb66e30da075 100644
--- a/drivers/scsi/isci/port.c
+++ b/drivers/scsi/isci/port.c
@@ -689,23 +689,16 @@ static void scic_sds_port_construct_dummy_rnc(struct scic_sds_port *sci_port, u1
 	rnc->ssp.arbitration_wait_time = 0;
 }
 
-/**
- * scic_sds_port_construct_dummy_task() - create dummy task for si workaround
- * @sci_port The logical port on which we need to create the
- *            remote node context.
- *            context.
- * @tci The remote node index for this remote node context.
- *
- * This routine will construct a dummy task context data structure.  This
+/*
+ * construct a dummy task context data structure.  This
  * structure will be posted to the hardwre to work around a scheduler error
  * in the hardware.
- *
  */
-static void scic_sds_port_construct_dummy_task(struct scic_sds_port *sci_port, u16 tci)
+static void scic_sds_port_construct_dummy_task(struct scic_sds_port *sci_port, u16 tag)
 {
 	struct scu_task_context *task_context;
 
-	task_context = scic_sds_controller_get_task_context_buffer(sci_port->owning_controller, tci);
+	task_context = scic_sds_controller_get_task_context_buffer(sci_port->owning_controller, tag);
 
 	memset(task_context, 0, sizeof(struct scu_task_context));
 
@@ -716,7 +709,7 @@ static void scic_sds_port_construct_dummy_task(struct scic_sds_port *sci_port, u
 	task_context->protocol_engine_index = 0;
 	task_context->logical_port_index = sci_port->physical_port_index;
 	task_context->protocol_type = SCU_TASK_CONTEXT_PROTOCOL_SSP;
-	task_context->task_index = scic_sds_io_tag_get_index(tci);
+	task_context->task_index = ISCI_TAG_TCI(tag);
 	task_context->valid = SCU_TASK_CONTEXT_VALID;
 	task_context->context_type = SCU_TASK_CONTEXT_TYPE;
 

commit fd0527ab15bfd96f04b084b1b2550f80cf151b60
Author: Jeff Skirvin <jeffrey.d.skirvin@intel.com>
Date:   Mon Jun 20 14:09:26 2011 -0700

    isci: Hard reset failure will link reset all phys in the port
    
    In the case where the hard reset process fails, each link in
    the port is put through a link reset sequence.
    
    Signed-off-by: Jeff Skirvin <jeffrey.d.skirvin@intel.com>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/drivers/scsi/isci/port.c b/drivers/scsi/isci/port.c
index 2946eee8e702..e540281ebd49 100644
--- a/drivers/scsi/isci/port.c
+++ b/drivers/scsi/isci/port.c
@@ -1916,7 +1916,7 @@ int isci_port_perform_hard_reset(struct isci_host *ihost, struct isci_port *ipor
 {
 	unsigned long flags;
 	enum sci_status status;
-	int ret = TMF_RESP_FUNC_COMPLETE;
+	int idx, ret = TMF_RESP_FUNC_COMPLETE;
 
 	dev_dbg(&ihost->pdev->dev, "%s: iport = %p\n",
 		__func__, iport);
@@ -1953,14 +1953,26 @@ int isci_port_perform_hard_reset(struct isci_host *ihost, struct isci_port *ipor
 	 * the same as link failures on all phys in the port.
 	 */
 	if (ret != TMF_RESP_FUNC_COMPLETE) {
+
 		dev_err(&ihost->pdev->dev,
 			"%s: iport = %p; hard reset failed "
-			"(0x%x) - sending link down to libsas for phy %p\n",
-			__func__, iport, iport->hard_reset_status, iphy);
+			"(0x%x) - driving explicit link fail for all phys\n",
+			__func__, iport, iport->hard_reset_status);
 
-		isci_port_link_down(ihost, iphy, iport);
-	}
+		/* Down all phys in the port. */
+		spin_lock_irqsave(&ihost->scic_lock, flags);
+		for (idx = 0; idx < SCI_MAX_PHYS; ++idx) {
+
+			if (iport->sci.phy_table[idx] != NULL) {
 
+				scic_sds_phy_stop(
+					iport->sci.phy_table[idx]);
+				scic_sds_phy_start(
+					iport->sci.phy_table[idx]);
+			}
+		}
+		spin_unlock_irqrestore(&ihost->scic_lock, flags);
+	}
 	return ret;
 }
 

commit 61aaff49e20fdb700f1300a49962bc76effc77fc
Author: Jeff Skirvin <jeffrey.d.skirvin@intel.com>
Date:   Tue Jun 21 12:16:33 2011 -0700

    isci: filter broadcast change notifications during SMP phy resets
    
    When resetting a sata device in the domain we have seen occasions where
    libsas prematurely marks a device gone in the time it takes for the
    device to re-establish the link.  This plays badly with software raid
    arrays.  Other libsas drivers have non-uniform delays in their reset
    handlers to try to cover this condition, but not sufficient to close the
    hole.  Given that a sata device can take many seconds to recover we
    filter bcns and poll for the device reattach state before notifying
    libsas that the port needs the domain to be rediscovered.  Once this has
    been proven out at the lldd level we can think about uplevelling this
    feature to a common implementation in libsas.
    
    Signed-off-by: Jeff Skirvin <jeffrey.d.skirvin@intel.com>
    [ use kzalloc instead of kmem_cache ]
    Signed-off-by: Dave Jiang <dave.jiang@intel.com>
    [ use eventq and time macros ]
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/drivers/scsi/isci/port.c b/drivers/scsi/isci/port.c
index 74f06f3c0735..2946eee8e702 100644
--- a/drivers/scsi/isci/port.c
+++ b/drivers/scsi/isci/port.c
@@ -152,6 +152,71 @@ static enum sci_status scic_port_get_properties(struct scic_sds_port *port,
 	return SCI_SUCCESS;
 }
 
+static void scic_port_bcn_enable(struct scic_sds_port *sci_port)
+{
+	struct scic_sds_phy *sci_phy;
+	u32 val;
+	int i;
+
+	for (i = 0; i < ARRAY_SIZE(sci_port->phy_table); i++) {
+		sci_phy = sci_port->phy_table[i];
+		if (!sci_phy)
+			continue;
+		val = readl(&sci_phy->link_layer_registers->link_layer_control);
+		/* clear the bit by writing 1. */
+		writel(val, &sci_phy->link_layer_registers->link_layer_control);
+	}
+}
+
+/* called under scic_lock to stabilize phy:port associations */
+void isci_port_bcn_enable(struct isci_host *ihost, struct isci_port *iport)
+{
+	int i;
+
+	clear_bit(IPORT_BCN_BLOCKED, &iport->flags);
+	wake_up(&ihost->eventq);
+
+	if (!test_and_clear_bit(IPORT_BCN_PENDING, &iport->flags))
+		return;
+
+	for (i = 0; i < ARRAY_SIZE(iport->sci.phy_table); i++) {
+		struct scic_sds_phy *sci_phy = iport->sci.phy_table[i];
+		struct isci_phy *iphy = sci_phy_to_iphy(sci_phy);
+
+		if (!sci_phy)
+			continue;
+
+		ihost->sas_ha.notify_port_event(&iphy->sas_phy,
+						PORTE_BROADCAST_RCVD);
+		break;
+	}
+}
+
+void isci_port_bc_change_received(struct isci_host *ihost,
+				  struct scic_sds_port *sci_port,
+				  struct scic_sds_phy *sci_phy)
+{
+	struct isci_phy *iphy = sci_phy_to_iphy(sci_phy);
+	struct isci_port *iport = iphy->isci_port;
+
+	if (iport && test_bit(IPORT_BCN_BLOCKED, &iport->flags)) {
+		dev_dbg(&ihost->pdev->dev,
+			"%s: disabled BCN; isci_phy = %p, sas_phy = %p\n",
+			__func__, iphy, &iphy->sas_phy);
+		set_bit(IPORT_BCN_PENDING, &iport->flags);
+		atomic_inc(&iport->event);
+		wake_up(&ihost->eventq);
+	} else {
+		dev_dbg(&ihost->pdev->dev,
+			"%s: isci_phy = %p, sas_phy = %p\n",
+			__func__, iphy, &iphy->sas_phy);
+
+		ihost->sas_ha.notify_port_event(&iphy->sas_phy,
+						PORTE_BROADCAST_RCVD);
+	}
+	scic_port_bcn_enable(sci_port);
+}
+
 static void isci_port_link_up(struct isci_host *isci_host,
 			      struct scic_sds_port *port,
 			      struct scic_sds_phy *phy)
@@ -240,13 +305,15 @@ static void isci_port_link_down(struct isci_host *isci_host,
 	if (isci_port) {
 
 		/* check to see if this is the last phy on this port. */
-		if (isci_phy->sas_phy.port
-		    && isci_phy->sas_phy.port->num_phys == 1) {
-
-			/* change the state for all devices on this port.
-			 * The next task sent to this device will be returned
-			 * as SAS_TASK_UNDELIVERED, and the scsi mid layer
-			 * will remove the target
+		if (isci_phy->sas_phy.port &&
+		    isci_phy->sas_phy.port->num_phys == 1) {
+			atomic_inc(&isci_port->event);
+			isci_port_bcn_enable(isci_host, isci_port);
+
+			/* change the state for all devices on this port.  The
+			 * next task sent to this device will be returned as
+			 * SAS_TASK_UNDELIVERED, and the scsi mid layer will
+			 * remove the target
 			 */
 			list_for_each_entry(isci_device,
 					    &isci_port->remote_dev_list,
@@ -1033,26 +1100,6 @@ enum sas_linkrate scic_sds_port_get_max_allowed_speed(
 	return max_allowed_speed;
 }
 
-static void scic_port_enable_broadcast_change_notification(struct scic_sds_port *port)
-{
-	struct scic_sds_phy *phy;
-	u32 register_value;
-	u8 index;
-
-	/* Loop through all of the phys to enable BCN. */
-	for (index = 0; index < SCI_MAX_PHYS; index++) {
-		phy = port->phy_table[index];
-		if (phy != NULL) {
-			register_value =
-				readl(&phy->link_layer_registers->link_layer_control);
-
-			/* clear the bit by writing 1. */
-			writel(register_value,
-				&phy->link_layer_registers->link_layer_control);
-		}
-	}
-}
-
 /**
  *
  * @sci_port: This is the struct scic_sds_port object to suspend.
@@ -1838,6 +1885,7 @@ void isci_port_init(struct isci_port *iport, struct isci_host *ihost, int index)
 	init_completion(&iport->start_complete);
 	iport->isci_host = ihost;
 	isci_port_change_state(iport, isci_freed);
+	atomic_set(&iport->event, 0);
 }
 
 /**
@@ -1852,19 +1900,6 @@ enum isci_status isci_port_get_state(
 	return isci_port->status;
 }
 
-static void isci_port_bc_change_received(struct isci_host *ihost,
-					 struct scic_sds_port *sci_port,
-					 struct scic_sds_phy *sci_phy)
-{
-	struct isci_phy *iphy = sci_phy_to_iphy(sci_phy);
-
-	dev_dbg(&ihost->pdev->dev, "%s: iphy = %p, sas_phy = %p\n",
-		__func__, iphy, &iphy->sas_phy);
-
-	ihost->sas_ha.notify_port_event(&iphy->sas_phy, PORTE_BROADCAST_RCVD);
-	scic_port_enable_broadcast_change_notification(sci_port);
-}
-
 void scic_sds_port_broadcast_change_received(
 	struct scic_sds_port *sci_port,
 	struct scic_sds_phy *sci_phy)

commit 12ef65444de9d387a383b9991960848bed5bbe74
Author: Edmund Nadolski <edmund.nadolski@intel.com>
Date:   Thu Jun 2 00:10:50 2011 +0000

    isci: additional state machine cleanup
    
    Additional state machine cleanups:
    
     o Remove static functions sci_state_machine_exit_state() and
       sci_state_machine_enter_state()
     o Combines sci_base_state_machine_construct() and
       sci_base_state_machine_start() into a single function,
       sci_init_sm()
     o Remove sci_base_state_machine_stop() which is unused.
     o Kill state_machine.[ch]
    
    Signed-off-by: Edmund Nadolski <edmund.nadolski@intel.com>
    [fixed too large to inline functions]
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/drivers/scsi/isci/port.c b/drivers/scsi/isci/port.c
index 6370b93bd6ae..74f06f3c0735 100644
--- a/drivers/scsi/isci/port.c
+++ b/drivers/scsi/isci/port.c
@@ -1807,11 +1807,7 @@ static const struct sci_base_state scic_sds_port_state_table[] = {
 void scic_sds_port_construct(struct scic_sds_port *sci_port, u8 index,
 			     struct scic_sds_controller *scic)
 {
-	sci_base_state_machine_construct(&sci_port->sm,
-					 scic_sds_port_state_table,
-					 SCI_PORT_STOPPED);
-
-	sci_base_state_machine_start(&sci_port->sm);
+	sci_init_sm(&sci_port->sm, scic_sds_port_state_table, SCI_PORT_STOPPED);
 
 	sci_port->logical_port_index  = SCIC_SDS_DUMMY_PORT;
 	sci_port->physical_port_index = index;

commit e301370ac553a9a0ac0d1d25e769b86cf60395b3
Author: Edmund Nadolski <edmund.nadolski@intel.com>
Date:   Thu Jun 2 00:10:43 2011 +0000

    isci: state machine cleanup
    
    This cleans up several areas of the state machine mechanism:
    
     o Rename sci_base_state_machine_change_state to sci_change_state
     o Remove sci_base_state_machine_get_state function
     o Rename 'state_machine' struct member to 'sm' in client structs
     o Shorten the name of request states
     o Shorten state machine state names as follows:
            SCI_BASE_CONTROLLER_STATE_xxx to SCIC_xxx
            SCI_BASE_PHY_STATE_xxx to SCI_PHY_xxx
            SCIC_SDS_PHY_STARTING_SUBSTATE_xxx to SCI_PHY_SUB_xxx
            SCI_BASE_PORT_STATE_xxx to SCI_PORT_xxx and
            SCIC_SDS_PORT_READY_SUBSTATE_xxx to SCI_PORT_SUB_xxx
            SCI_BASE_REMOTE_DEVICE_STATE_xxx to SCI_DEV_xxx
            SCIC_SDS_STP_REMOTE_DEVICE_READY_SUBSTATE_xxx to SCI_STP_DEV_xxx
            SCIC_SDS_SMP_REMOTE_DEVICE_READY_SUBSTATE_xxx to SCI_SMP_DEV_xxx
            SCIC_SDS_REMOTE_NODE_CONTEXT_xxx_STATE to SCI_RNC_xxx
    
    Signed-off-by: Edmund Nadolski <edmund.nadolski@intel.com>
    Signed-off-by: Dave Jiang <dave.jiang@intel.com>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/drivers/scsi/isci/port.c b/drivers/scsi/isci/port.c
index 8d88ca21a51c..6370b93bd6ae 100644
--- a/drivers/scsi/isci/port.c
+++ b/drivers/scsi/isci/port.c
@@ -807,10 +807,10 @@ static void scic_sds_port_invalid_link_up(struct scic_sds_port *sci_port,
 static bool is_port_ready_state(enum scic_sds_port_states state)
 {
 	switch (state) {
-	case SCI_BASE_PORT_STATE_READY:
-	case SCIC_SDS_PORT_READY_SUBSTATE_WAITING:
-	case SCIC_SDS_PORT_READY_SUBSTATE_OPERATIONAL:
-	case SCIC_SDS_PORT_READY_SUBSTATE_CONFIGURING:
+	case SCI_PORT_READY:
+	case SCI_PORT_SUB_WAITING:
+	case SCI_PORT_SUB_OPERATIONAL:
+	case SCI_PORT_SUB_CONFIGURING:
 		return true;
 	default:
 		return false;
@@ -821,13 +821,13 @@ static bool is_port_ready_state(enum scic_sds_port_states state)
 static void port_state_machine_change(struct scic_sds_port *sci_port,
 				      enum scic_sds_port_states state)
 {
-	struct sci_base_state_machine *sm = &sci_port->state_machine;
+	struct sci_base_state_machine *sm = &sci_port->sm;
 	enum scic_sds_port_states old_state = sm->current_state_id;
 
 	if (is_port_ready_state(old_state) && !is_port_ready_state(state))
 		sci_port->ready_exit = true;
 
-	sci_base_state_machine_change_state(sm, state);
+	sci_change_state(sm, state);
 	sci_port->ready_exit = false;
 }
 
@@ -862,11 +862,11 @@ static void scic_sds_port_general_link_up_handler(struct scic_sds_port *sci_port
 	if ((phy_sas_address.high == port_sas_address.high &&
 	     phy_sas_address.low  == port_sas_address.low) ||
 	    sci_port->active_phy_mask == 0) {
-		struct sci_base_state_machine *sm = &sci_port->state_machine;
+		struct sci_base_state_machine *sm = &sci_port->sm;
 
 		scic_sds_port_activate_phy(sci_port, sci_phy, do_notify_user);
-		if (sm->current_state_id == SCI_BASE_PORT_STATE_RESETTING)
-			port_state_machine_change(sci_port, SCI_BASE_PORT_STATE_READY);
+		if (sm->current_state_id == SCI_PORT_RESETTING)
+			port_state_machine_change(sci_port, SCI_PORT_READY);
 	} else
 		scic_sds_port_invalid_link_up(sci_port, sci_phy);
 }
@@ -938,14 +938,14 @@ static void port_timeout(unsigned long data)
 	if (tmr->cancel)
 		goto done;
 
-	current_state = sci_base_state_machine_get_state(&sci_port->state_machine);
+	current_state = sci_port->sm.current_state_id;
 
-	if (current_state == SCI_BASE_PORT_STATE_RESETTING) {
+	if (current_state == SCI_PORT_RESETTING) {
 		/* if the port is still in the resetting state then the timeout
 		 * fired before the reset completed.
 		 */
-		port_state_machine_change(sci_port, SCI_BASE_PORT_STATE_FAILED);
-	} else if (current_state == SCI_BASE_PORT_STATE_STOPPED) {
+		port_state_machine_change(sci_port, SCI_PORT_FAILED);
+	} else if (current_state == SCI_PORT_STOPPED) {
 		/* if the port is stopped then the start request failed In this
 		 * case stay in the stopped state.
 		 */
@@ -953,7 +953,7 @@ static void port_timeout(unsigned long data)
 			"%s: SCIC Port 0x%p failed to stop before tiemout.\n",
 			__func__,
 			sci_port);
-	} else if (current_state == SCI_BASE_PORT_STATE_STOPPING) {
+	} else if (current_state == SCI_PORT_STOPPING) {
 		/* if the port is still stopping then the stop has not completed */
 		isci_port_stop_complete(sci_port->owning_controller,
 					sci_port,
@@ -1139,7 +1139,7 @@ scic_sds_port_resume_port_task_scheduler(struct scic_sds_port *port)
 
 static void scic_sds_port_ready_substate_waiting_enter(struct sci_base_state_machine *sm)
 {
-	struct scic_sds_port *sci_port = container_of(sm, typeof(*sci_port), state_machine);
+	struct scic_sds_port *sci_port = container_of(sm, typeof(*sci_port), sm);
 
 	scic_sds_port_suspend_port_task_scheduler(sci_port);
 
@@ -1148,14 +1148,14 @@ static void scic_sds_port_ready_substate_waiting_enter(struct sci_base_state_mac
 	if (sci_port->active_phy_mask != 0) {
 		/* At least one of the phys on the port is ready */
 		port_state_machine_change(sci_port,
-					  SCIC_SDS_PORT_READY_SUBSTATE_OPERATIONAL);
+					  SCI_PORT_SUB_OPERATIONAL);
 	}
 }
 
 static void scic_sds_port_ready_substate_operational_enter(struct sci_base_state_machine *sm)
 {
 	u32 index;
-	struct scic_sds_port *sci_port = container_of(sm, typeof(*sci_port), state_machine);
+	struct scic_sds_port *sci_port = container_of(sm, typeof(*sci_port), sm);
 	struct scic_sds_controller *scic = sci_port->owning_controller;
 	struct isci_host *ihost = scic_to_ihost(scic);
 	struct isci_port *iport = sci_port_to_iport(sci_port);
@@ -1211,12 +1211,12 @@ static void scic_sds_port_invalidate_dummy_remote_node(struct scic_sds_port *sci
  * @object: This is the object which is cast to a struct scic_sds_port object.
  *
  * This method will perform the actions required by the struct scic_sds_port on
- * exiting the SCIC_SDS_PORT_READY_SUBSTATE_OPERATIONAL. This function reports
+ * exiting the SCI_PORT_SUB_OPERATIONAL. This function reports
  * the port not ready and suspends the port task scheduler. none
  */
 static void scic_sds_port_ready_substate_operational_exit(struct sci_base_state_machine *sm)
 {
-	struct scic_sds_port *sci_port = container_of(sm, typeof(*sci_port), state_machine);
+	struct scic_sds_port *sci_port = container_of(sm, typeof(*sci_port), sm);
 	struct scic_sds_controller *scic = sci_port->owning_controller;
 	struct isci_host *ihost = scic_to_ihost(scic);
 	struct isci_port *iport = sci_port_to_iport(sci_port);
@@ -1236,7 +1236,7 @@ static void scic_sds_port_ready_substate_operational_exit(struct sci_base_state_
 
 static void scic_sds_port_ready_substate_configuring_enter(struct sci_base_state_machine *sm)
 {
-	struct scic_sds_port *sci_port = container_of(sm, typeof(*sci_port), state_machine);
+	struct scic_sds_port *sci_port = container_of(sm, typeof(*sci_port), sm);
 	struct scic_sds_controller *scic = sci_port->owning_controller;
 	struct isci_host *ihost = scic_to_ihost(scic);
 	struct isci_port *iport = sci_port_to_iport(sci_port);
@@ -1245,15 +1245,15 @@ static void scic_sds_port_ready_substate_configuring_enter(struct sci_base_state
 		isci_port_not_ready(ihost, iport);
 
 		port_state_machine_change(sci_port,
-					  SCIC_SDS_PORT_READY_SUBSTATE_WAITING);
+					  SCI_PORT_SUB_WAITING);
 	} else if (sci_port->started_request_count == 0)
 		port_state_machine_change(sci_port,
-					  SCIC_SDS_PORT_READY_SUBSTATE_OPERATIONAL);
+					  SCI_PORT_SUB_OPERATIONAL);
 }
 
 static void scic_sds_port_ready_substate_configuring_exit(struct sci_base_state_machine *sm)
 {
-	struct scic_sds_port *sci_port = container_of(sm, typeof(*sci_port), state_machine);
+	struct scic_sds_port *sci_port = container_of(sm, typeof(*sci_port), sm);
 
 	scic_sds_port_suspend_port_task_scheduler(sci_port);
 	if (sci_port->ready_exit)
@@ -1267,8 +1267,8 @@ enum sci_status scic_sds_port_start(struct scic_sds_port *sci_port)
 	enum scic_sds_port_states state;
 	u32 phy_mask;
 
-	state = sci_port->state_machine.current_state_id;
-	if (state != SCI_BASE_PORT_STATE_STOPPED) {
+	state = sci_port->sm.current_state_id;
+	if (state != SCI_PORT_STOPPED) {
 		dev_warn(sciport_to_dev(sci_port),
 			 "%s: in wrong state: %d\n", __func__, state);
 		return SCI_FAILURE_INVALID_STATE;
@@ -1315,7 +1315,7 @@ enum sci_status scic_sds_port_start(struct scic_sds_port *sci_port)
 		 */
 		if (scic_sds_port_is_phy_mask_valid(sci_port, phy_mask) == true) {
 			port_state_machine_change(sci_port,
-						  SCI_BASE_PORT_STATE_READY);
+						  SCI_PORT_READY);
 
 			return SCI_SUCCESS;
 		}
@@ -1332,16 +1332,16 @@ enum sci_status scic_sds_port_stop(struct scic_sds_port *sci_port)
 {
 	enum scic_sds_port_states state;
 
-	state = sci_port->state_machine.current_state_id;
+	state = sci_port->sm.current_state_id;
 	switch (state) {
-	case SCI_BASE_PORT_STATE_STOPPED:
+	case SCI_PORT_STOPPED:
 		return SCI_SUCCESS;
-	case SCIC_SDS_PORT_READY_SUBSTATE_WAITING:
-	case SCIC_SDS_PORT_READY_SUBSTATE_OPERATIONAL:
-	case SCIC_SDS_PORT_READY_SUBSTATE_CONFIGURING:
-	case SCI_BASE_PORT_STATE_RESETTING:
+	case SCI_PORT_SUB_WAITING:
+	case SCI_PORT_SUB_OPERATIONAL:
+	case SCI_PORT_SUB_CONFIGURING:
+	case SCI_PORT_RESETTING:
 		port_state_machine_change(sci_port,
-					  SCI_BASE_PORT_STATE_STOPPING);
+					  SCI_PORT_STOPPING);
 		return SCI_SUCCESS;
 	default:
 		dev_warn(sciport_to_dev(sci_port),
@@ -1357,8 +1357,8 @@ static enum sci_status scic_port_hard_reset(struct scic_sds_port *sci_port, u32
 	enum scic_sds_port_states state;
 	u32 phy_index;
 
-	state = sci_port->state_machine.current_state_id;
-	if (state != SCIC_SDS_PORT_READY_SUBSTATE_OPERATIONAL) {
+	state = sci_port->sm.current_state_id;
+	if (state != SCI_PORT_SUB_OPERATIONAL) {
 		dev_warn(sciport_to_dev(sci_port),
 			 "%s: in wrong state: %d\n", __func__, state);
 		return SCI_FAILURE_INVALID_STATE;
@@ -1389,7 +1389,7 @@ static enum sci_status scic_port_hard_reset(struct scic_sds_port *sci_port, u32
 	sci_port->not_ready_reason = SCIC_PORT_NOT_READY_HARD_RESET_REQUESTED;
 
 	port_state_machine_change(sci_port,
-				  SCI_BASE_PORT_STATE_RESETTING);
+				  SCI_PORT_RESETTING);
 	return SCI_SUCCESS;
 }
 
@@ -1408,9 +1408,9 @@ enum sci_status scic_sds_port_add_phy(struct scic_sds_port *sci_port,
 	enum sci_status status;
 	enum scic_sds_port_states state;
 
-	state = sci_port->state_machine.current_state_id;
+	state = sci_port->sm.current_state_id;
 	switch (state) {
-	case SCI_BASE_PORT_STATE_STOPPED: {
+	case SCI_PORT_STOPPED: {
 		struct sci_sas_address port_sas_address;
 
 		/* Read the port assigned SAS Address if there is one */
@@ -1430,8 +1430,8 @@ enum sci_status scic_sds_port_add_phy(struct scic_sds_port *sci_port,
 		}
 		return scic_sds_port_set_phy(sci_port, sci_phy);
 	}
-	case SCIC_SDS_PORT_READY_SUBSTATE_WAITING:
-	case SCIC_SDS_PORT_READY_SUBSTATE_OPERATIONAL:
+	case SCI_PORT_SUB_WAITING:
+	case SCI_PORT_SUB_OPERATIONAL:
 		status = scic_sds_port_set_phy(sci_port, sci_phy);
 
 		if (status != SCI_SUCCESS)
@@ -1439,10 +1439,10 @@ enum sci_status scic_sds_port_add_phy(struct scic_sds_port *sci_port,
 
 		scic_sds_port_general_link_up_handler(sci_port, sci_phy, true);
 		sci_port->not_ready_reason = SCIC_PORT_NOT_READY_RECONFIGURING;
-		port_state_machine_change(sci_port, SCIC_SDS_PORT_READY_SUBSTATE_CONFIGURING);
+		port_state_machine_change(sci_port, SCI_PORT_SUB_CONFIGURING);
 
 		return status;
-	case SCIC_SDS_PORT_READY_SUBSTATE_CONFIGURING:
+	case SCI_PORT_SUB_CONFIGURING:
 		status = scic_sds_port_set_phy(sci_port, sci_phy);
 
 		if (status != SCI_SUCCESS)
@@ -1453,7 +1453,7 @@ enum sci_status scic_sds_port_add_phy(struct scic_sds_port *sci_port,
 		 * the port.
 		 */
 		port_state_machine_change(sci_port,
-					  SCIC_SDS_PORT_READY_SUBSTATE_CONFIGURING);
+					  SCI_PORT_SUB_CONFIGURING);
 		return SCI_SUCCESS;
 	default:
 		dev_warn(sciport_to_dev(sci_port),
@@ -1477,12 +1477,12 @@ enum sci_status scic_sds_port_remove_phy(struct scic_sds_port *sci_port,
 	enum sci_status status;
 	enum scic_sds_port_states state;
 
-	state = sci_port->state_machine.current_state_id;
+	state = sci_port->sm.current_state_id;
 
 	switch (state) {
-	case SCI_BASE_PORT_STATE_STOPPED:
+	case SCI_PORT_STOPPED:
 		return scic_sds_port_clear_phy(sci_port, sci_phy);
-	case SCIC_SDS_PORT_READY_SUBSTATE_OPERATIONAL:
+	case SCI_PORT_SUB_OPERATIONAL:
 		status = scic_sds_port_clear_phy(sci_port, sci_phy);
 		if (status != SCI_SUCCESS)
 			return status;
@@ -1490,9 +1490,9 @@ enum sci_status scic_sds_port_remove_phy(struct scic_sds_port *sci_port,
 		scic_sds_port_deactivate_phy(sci_port, sci_phy, true);
 		sci_port->not_ready_reason = SCIC_PORT_NOT_READY_RECONFIGURING;
 		port_state_machine_change(sci_port,
-					  SCIC_SDS_PORT_READY_SUBSTATE_CONFIGURING);
+					  SCI_PORT_SUB_CONFIGURING);
 		return SCI_SUCCESS;
-	case SCIC_SDS_PORT_READY_SUBSTATE_CONFIGURING:
+	case SCI_PORT_SUB_CONFIGURING:
 		status = scic_sds_port_clear_phy(sci_port, sci_phy);
 
 		if (status != SCI_SUCCESS)
@@ -1503,7 +1503,7 @@ enum sci_status scic_sds_port_remove_phy(struct scic_sds_port *sci_port,
 		 * the port
 		 */
 		port_state_machine_change(sci_port,
-					  SCIC_SDS_PORT_READY_SUBSTATE_CONFIGURING);
+					  SCI_PORT_SUB_CONFIGURING);
 		return SCI_SUCCESS;
 	default:
 		dev_warn(sciport_to_dev(sci_port),
@@ -1517,21 +1517,21 @@ enum sci_status scic_sds_port_link_up(struct scic_sds_port *sci_port,
 {
 	enum scic_sds_port_states state;
 
-	state = sci_port->state_machine.current_state_id;
+	state = sci_port->sm.current_state_id;
 	switch (state) {
-	case SCIC_SDS_PORT_READY_SUBSTATE_WAITING:
+	case SCI_PORT_SUB_WAITING:
 		/* Since this is the first phy going link up for the port we
 		 * can just enable it and continue
 		 */
 		scic_sds_port_activate_phy(sci_port, sci_phy, true);
 
 		port_state_machine_change(sci_port,
-					  SCIC_SDS_PORT_READY_SUBSTATE_OPERATIONAL);
+					  SCI_PORT_SUB_OPERATIONAL);
 		return SCI_SUCCESS;
-	case SCIC_SDS_PORT_READY_SUBSTATE_OPERATIONAL:
+	case SCI_PORT_SUB_OPERATIONAL:
 		scic_sds_port_general_link_up_handler(sci_port, sci_phy, true);
 		return SCI_SUCCESS;
-	case SCI_BASE_PORT_STATE_RESETTING:
+	case SCI_PORT_RESETTING:
 		/* TODO We should  make  sure  that  the phy  that  has gone
 		 * link up is the same one on which we sent the reset.  It is
 		 * possible that the phy on which we sent  the reset is not the
@@ -1560,9 +1560,9 @@ enum sci_status scic_sds_port_link_down(struct scic_sds_port *sci_port,
 {
 	enum scic_sds_port_states state;
 
-	state = sci_port->state_machine.current_state_id;
+	state = sci_port->sm.current_state_id;
 	switch (state) {
-	case SCIC_SDS_PORT_READY_SUBSTATE_OPERATIONAL:
+	case SCI_PORT_SUB_OPERATIONAL:
 		scic_sds_port_deactivate_phy(sci_port, sci_phy, true);
 
 		/* If there are no active phys left in the port, then
@@ -1571,9 +1571,9 @@ enum sci_status scic_sds_port_link_down(struct scic_sds_port *sci_port,
 		 */
 		if (sci_port->active_phy_mask == 0)
 			port_state_machine_change(sci_port,
-						  SCIC_SDS_PORT_READY_SUBSTATE_WAITING);
+						  SCI_PORT_SUB_WAITING);
 		return SCI_SUCCESS;
-	case SCI_BASE_PORT_STATE_RESETTING:
+	case SCI_PORT_RESETTING:
 		/* In the resetting state we don't notify the user regarding
 		 * link up and link down notifications. */
 		scic_sds_port_deactivate_phy(sci_port, sci_phy, false);
@@ -1591,11 +1591,11 @@ enum sci_status scic_sds_port_start_io(struct scic_sds_port *sci_port,
 {
 	enum scic_sds_port_states state;
 
-	state = sci_port->state_machine.current_state_id;
+	state = sci_port->sm.current_state_id;
 	switch (state) {
-	case SCIC_SDS_PORT_READY_SUBSTATE_WAITING:
+	case SCI_PORT_SUB_WAITING:
 		return SCI_FAILURE_INVALID_STATE;
-	case SCIC_SDS_PORT_READY_SUBSTATE_OPERATIONAL:
+	case SCI_PORT_SUB_OPERATIONAL:
 		sci_port->started_request_count++;
 		return SCI_SUCCESS;
 	default:
@@ -1611,31 +1611,31 @@ enum sci_status scic_sds_port_complete_io(struct scic_sds_port *sci_port,
 {
 	enum scic_sds_port_states state;
 
-	state = sci_port->state_machine.current_state_id;
+	state = sci_port->sm.current_state_id;
 	switch (state) {
-	case SCI_BASE_PORT_STATE_STOPPED:
+	case SCI_PORT_STOPPED:
 		dev_warn(sciport_to_dev(sci_port),
 			 "%s: in wrong state: %d\n", __func__, state);
 		return SCI_FAILURE_INVALID_STATE;
-	case SCI_BASE_PORT_STATE_STOPPING:
+	case SCI_PORT_STOPPING:
 		scic_sds_port_decrement_request_count(sci_port);
 
 		if (sci_port->started_request_count == 0)
 			port_state_machine_change(sci_port,
-						  SCI_BASE_PORT_STATE_STOPPED);
+						  SCI_PORT_STOPPED);
 		break;
-	case SCI_BASE_PORT_STATE_READY:
-	case SCI_BASE_PORT_STATE_RESETTING:
-	case SCI_BASE_PORT_STATE_FAILED:
-	case SCIC_SDS_PORT_READY_SUBSTATE_WAITING:
-	case SCIC_SDS_PORT_READY_SUBSTATE_OPERATIONAL:
+	case SCI_PORT_READY:
+	case SCI_PORT_RESETTING:
+	case SCI_PORT_FAILED:
+	case SCI_PORT_SUB_WAITING:
+	case SCI_PORT_SUB_OPERATIONAL:
 		scic_sds_port_decrement_request_count(sci_port);
 		break;
-	case SCIC_SDS_PORT_READY_SUBSTATE_CONFIGURING:
+	case SCI_PORT_SUB_CONFIGURING:
 		scic_sds_port_decrement_request_count(sci_port);
 		if (sci_port->started_request_count == 0) {
 			port_state_machine_change(sci_port,
-						  SCIC_SDS_PORT_READY_SUBSTATE_OPERATIONAL);
+						  SCI_PORT_SUB_OPERATIONAL);
 		}
 		break;
 	}
@@ -1707,9 +1707,9 @@ static void scic_sds_port_post_dummy_remote_node(struct scic_sds_port *sci_port)
 
 static void scic_sds_port_stopped_state_enter(struct sci_base_state_machine *sm)
 {
-	struct scic_sds_port *sci_port = container_of(sm, typeof(*sci_port), state_machine);
+	struct scic_sds_port *sci_port = container_of(sm, typeof(*sci_port), sm);
 
-	if (sci_port->state_machine.previous_state_id == SCI_BASE_PORT_STATE_STOPPING) {
+	if (sci_port->sm.previous_state_id == SCI_PORT_STOPPING) {
 		/*
 		 * If we enter this state becasuse of a request to stop
 		 * the port then we want to disable the hardwares port
@@ -1720,7 +1720,7 @@ static void scic_sds_port_stopped_state_enter(struct sci_base_state_machine *sm)
 
 static void scic_sds_port_stopped_state_exit(struct sci_base_state_machine *sm)
 {
-	struct scic_sds_port *sci_port = container_of(sm, typeof(*sci_port), state_machine);
+	struct scic_sds_port *sci_port = container_of(sm, typeof(*sci_port), sm);
 
 	/* Enable and suspend the port task scheduler */
 	scic_sds_port_enable_port_task_scheduler(sci_port);
@@ -1728,14 +1728,14 @@ static void scic_sds_port_stopped_state_exit(struct sci_base_state_machine *sm)
 
 static void scic_sds_port_ready_state_enter(struct sci_base_state_machine *sm)
 {
-	struct scic_sds_port *sci_port = container_of(sm, typeof(*sci_port), state_machine);
+	struct scic_sds_port *sci_port = container_of(sm, typeof(*sci_port), sm);
 	struct scic_sds_controller *scic = sci_port->owning_controller;
 	struct isci_host *ihost = scic_to_ihost(scic);
 	struct isci_port *iport = sci_port_to_iport(sci_port);
 	u32 prev_state;
 
-	prev_state = sci_port->state_machine.previous_state_id;
-	if (prev_state  == SCI_BASE_PORT_STATE_RESETTING)
+	prev_state = sci_port->sm.previous_state_id;
+	if (prev_state  == SCI_PORT_RESETTING)
 		isci_port_hard_reset_complete(iport, SCI_SUCCESS);
 	else
 		isci_port_not_ready(ihost, iport);
@@ -1745,19 +1745,19 @@ static void scic_sds_port_ready_state_enter(struct sci_base_state_machine *sm)
 
 	/* Start the ready substate machine */
 	port_state_machine_change(sci_port,
-				  SCIC_SDS_PORT_READY_SUBSTATE_WAITING);
+				  SCI_PORT_SUB_WAITING);
 }
 
 static void scic_sds_port_resetting_state_exit(struct sci_base_state_machine *sm)
 {
-	struct scic_sds_port *sci_port = container_of(sm, typeof(*sci_port), state_machine);
+	struct scic_sds_port *sci_port = container_of(sm, typeof(*sci_port), sm);
 
 	sci_del_timer(&sci_port->timer);
 }
 
 static void scic_sds_port_stopping_state_exit(struct sci_base_state_machine *sm)
 {
-	struct scic_sds_port *sci_port = container_of(sm, typeof(*sci_port), state_machine);
+	struct scic_sds_port *sci_port = container_of(sm, typeof(*sci_port), sm);
 
 	sci_del_timer(&sci_port->timer);
 
@@ -1766,7 +1766,7 @@ static void scic_sds_port_stopping_state_exit(struct sci_base_state_machine *sm)
 
 static void scic_sds_port_failed_state_enter(struct sci_base_state_machine *sm)
 {
-	struct scic_sds_port *sci_port = container_of(sm, typeof(*sci_port), state_machine);
+	struct scic_sds_port *sci_port = container_of(sm, typeof(*sci_port), sm);
 	struct isci_port *iport = sci_port_to_iport(sci_port);
 
 	isci_port_hard_reset_complete(iport, SCI_FAILURE_TIMEOUT);
@@ -1775,31 +1775,31 @@ static void scic_sds_port_failed_state_enter(struct sci_base_state_machine *sm)
 /* --------------------------------------------------------------------------- */
 
 static const struct sci_base_state scic_sds_port_state_table[] = {
-	[SCI_BASE_PORT_STATE_STOPPED] = {
+	[SCI_PORT_STOPPED] = {
 		.enter_state = scic_sds_port_stopped_state_enter,
 		.exit_state  = scic_sds_port_stopped_state_exit
 	},
-	[SCI_BASE_PORT_STATE_STOPPING] = {
+	[SCI_PORT_STOPPING] = {
 		.exit_state  = scic_sds_port_stopping_state_exit
 	},
-	[SCI_BASE_PORT_STATE_READY] = {
+	[SCI_PORT_READY] = {
 		.enter_state = scic_sds_port_ready_state_enter,
 	},
-	[SCIC_SDS_PORT_READY_SUBSTATE_WAITING] = {
+	[SCI_PORT_SUB_WAITING] = {
 		.enter_state = scic_sds_port_ready_substate_waiting_enter,
 	},
-	[SCIC_SDS_PORT_READY_SUBSTATE_OPERATIONAL] = {
+	[SCI_PORT_SUB_OPERATIONAL] = {
 		.enter_state = scic_sds_port_ready_substate_operational_enter,
 		.exit_state  = scic_sds_port_ready_substate_operational_exit
 	},
-	[SCIC_SDS_PORT_READY_SUBSTATE_CONFIGURING] = {
+	[SCI_PORT_SUB_CONFIGURING] = {
 		.enter_state = scic_sds_port_ready_substate_configuring_enter,
 		.exit_state  = scic_sds_port_ready_substate_configuring_exit
 	},
-	[SCI_BASE_PORT_STATE_RESETTING] = {
+	[SCI_PORT_RESETTING] = {
 		.exit_state  = scic_sds_port_resetting_state_exit
 	},
-	[SCI_BASE_PORT_STATE_FAILED] = {
+	[SCI_PORT_FAILED] = {
 		.enter_state = scic_sds_port_failed_state_enter,
 	}
 };
@@ -1807,11 +1807,11 @@ static const struct sci_base_state scic_sds_port_state_table[] = {
 void scic_sds_port_construct(struct scic_sds_port *sci_port, u8 index,
 			     struct scic_sds_controller *scic)
 {
-	sci_base_state_machine_construct(&sci_port->state_machine,
+	sci_base_state_machine_construct(&sci_port->sm,
 					 scic_sds_port_state_table,
-					 SCI_BASE_PORT_STATE_STOPPED);
+					 SCI_PORT_STOPPED);
 
-	sci_base_state_machine_start(&sci_port->state_machine);
+	sci_base_state_machine_start(&sci_port->sm);
 
 	sci_port->logical_port_index  = SCIC_SDS_DUMMY_PORT;
 	sci_port->physical_port_index = index;

commit 8db02da52895285e99d7eb2fa825fd393e61d9c5
Author: Edmund Nadolski <edmund.nadolski@intel.com>
Date:   Thu May 19 12:00:22 2011 +0000

    isci: remove isci_timer interface
    
    Delete code which is no longer used.
    
    Signed-off-by: Edmund Nadolski <edmund.nadolski@intel.com>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/drivers/scsi/isci/port.c b/drivers/scsi/isci/port.c
index 3da9048b45b7..8d88ca21a51c 100644
--- a/drivers/scsi/isci/port.c
+++ b/drivers/scsi/isci/port.c
@@ -56,7 +56,6 @@
 #include "isci.h"
 #include "port.h"
 #include "request.h"
-#include "timers.h"
 
 #define SCIC_SDS_PORT_HARD_RESET_TIMEOUT  (1000)
 #define SCU_DUMMY_INDEX    (0xFFFF)

commit 5553ba2be0f3e3741e1a885a33d2b89921f9fd48
Author: Edmund Nadolski <edmund.nadolski@intel.com>
Date:   Thu May 19 11:59:10 2011 +0000

    isci: replace isci_timer list with proper embedded timers
    
    Rather than preallocating a list of timers and doling them out at runtime,
    embed a struct timerlist in each object that needs one.  A struct sci_timer
    interface is introduced to manage the timer cancellation semantics which
    currently need to guarantee the timer is cancelled while holding
    spin_lock(ihost->scic_lock).  Since the timeout functions also need to acquire
    the lock it currently prevents the driver from using del_timer_sync() for
    runtime cancellations.
    
    del_timer_sync() is used however before the objects go out of scope.
    
    Signed-off-by: Edmund Nadolski <edmund.nadolski@intel.com>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/drivers/scsi/isci/port.c b/drivers/scsi/isci/port.c
index 3050415e228d..3da9048b45b7 100644
--- a/drivers/scsi/isci/port.c
+++ b/drivers/scsi/isci/port.c
@@ -926,17 +926,19 @@ bool scic_sds_port_link_detected(
 	return true;
 }
 
-/**
- * This method is provided to timeout requests for port operations. Mostly its
- *    for the port reset operation.
- *
- *
- */
-static void scic_sds_port_timeout_handler(void *port)
+static void port_timeout(unsigned long data)
 {
-	struct scic_sds_port *sci_port = port;
+	struct sci_timer *tmr = (struct sci_timer *)data;
+	struct scic_sds_port *sci_port = container_of(tmr, typeof(*sci_port), timer);
+	struct isci_host *ihost = scic_to_ihost(sci_port->owning_controller);
+	unsigned long flags;
 	u32 current_state;
 
+	spin_lock_irqsave(&ihost->scic_lock, flags);
+
+	if (tmr->cancel)
+		goto done;
+
 	current_state = sci_base_state_machine_get_state(&sci_port->state_machine);
 
 	if (current_state == SCI_BASE_PORT_STATE_RESETTING) {
@@ -965,6 +967,9 @@ static void scic_sds_port_timeout_handler(void *port)
 			"%s: SCIC Port 0x%p is processing a timeout operation "
 			"in state %d.\n", __func__, sci_port, current_state);
 	}
+
+done:
+	spin_unlock_irqrestore(&ihost->scic_lock, flags);
 }
 
 /* --------------------------------------------------------------------------- */
@@ -1259,7 +1264,6 @@ static void scic_sds_port_ready_substate_configuring_exit(struct sci_base_state_
 enum sci_status scic_sds_port_start(struct scic_sds_port *sci_port)
 {
 	struct scic_sds_controller *scic = sci_port->owning_controller;
-	struct isci_host *ihost = scic_to_ihost(scic);
 	enum sci_status status = SCI_SUCCESS;
 	enum scic_sds_port_states state;
 	u32 phy_mask;
@@ -1280,14 +1284,6 @@ enum sci_status scic_sds_port_start(struct scic_sds_port *sci_port)
 		return SCI_FAILURE_UNSUPPORTED_PORT_CONFIGURATION;
 	}
 
-	sci_port->timer_handle =
-		isci_timer_create(ihost,
-				  sci_port,
-				  scic_sds_port_timeout_handler);
-
-	if (!sci_port->timer_handle)
-		return SCI_FAILURE_INSUFFICIENT_RESOURCES;
-
 	if (sci_port->reserved_rni == SCU_DUMMY_INDEX) {
 		u16 rni = scic_sds_remote_node_table_allocate_remote_node(
 				&scic->available_remote_nodes, 1);
@@ -1390,7 +1386,7 @@ static enum sci_status scic_port_hard_reset(struct scic_sds_port *sci_port, u32
 	if (status != SCI_SUCCESS)
 		return status;
 
-	isci_timer_start(sci_port->timer_handle, timeout);
+	sci_mod_timer(&sci_port->timer, timeout);
 	sci_port->not_ready_reason = SCIC_PORT_NOT_READY_HARD_RESET_REQUESTED;
 
 	port_state_machine_change(sci_port,
@@ -1757,14 +1753,14 @@ static void scic_sds_port_resetting_state_exit(struct sci_base_state_machine *sm
 {
 	struct scic_sds_port *sci_port = container_of(sm, typeof(*sci_port), state_machine);
 
-	isci_timer_stop(sci_port->timer_handle);
+	sci_del_timer(&sci_port->timer);
 }
 
 static void scic_sds_port_stopping_state_exit(struct sci_base_state_machine *sm)
 {
 	struct scic_sds_port *sci_port = container_of(sm, typeof(*sci_port), state_machine);
 
-	isci_timer_stop(sci_port->timer_handle);
+	sci_del_timer(&sci_port->timer);
 
 	scic_sds_port_destroy_dummy_resources(sci_port);
 }
@@ -1831,7 +1827,8 @@ void scic_sds_port_construct(struct scic_sds_port *sci_port, u8 index,
 	sci_port->reserved_rni = SCU_DUMMY_INDEX;
 	sci_port->reserved_tci = SCU_DUMMY_INDEX;
 
-	sci_port->timer_handle = NULL;
+	sci_init_timer(&sci_port->timer, port_timeout);
+
 	sci_port->port_task_scheduler_registers = NULL;
 
 	for (index = 0; index < SCI_MAX_PHYS; index++)

commit 9269e0e898594c65dee6b20d4ed48e33dbbd4eeb
Author: Dan Williams <dan.j.williams@intel.com>
Date:   Thu May 12 07:42:17 2011 -0700

    isci: add some type safety to the state machine interface
    
    Now that any given object type only has one state_machine we can use
    container_of() to get back to the given state machine owner.
    
    Reported-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/drivers/scsi/isci/port.c b/drivers/scsi/isci/port.c
index f43c1f6c9669..3050415e228d 100644
--- a/drivers/scsi/isci/port.c
+++ b/drivers/scsi/isci/port.c
@@ -1133,9 +1133,9 @@ scic_sds_port_resume_port_task_scheduler(struct scic_sds_port *port)
 	writel(pts_control_value, &port->port_task_scheduler_registers->control);
 }
 
-static void scic_sds_port_ready_substate_waiting_enter(void *object)
+static void scic_sds_port_ready_substate_waiting_enter(struct sci_base_state_machine *sm)
 {
-	struct scic_sds_port *sci_port = object;
+	struct scic_sds_port *sci_port = container_of(sm, typeof(*sci_port), state_machine);
 
 	scic_sds_port_suspend_port_task_scheduler(sci_port);
 
@@ -1148,10 +1148,10 @@ static void scic_sds_port_ready_substate_waiting_enter(void *object)
 	}
 }
 
-static void scic_sds_port_ready_substate_operational_enter(void *object)
+static void scic_sds_port_ready_substate_operational_enter(struct sci_base_state_machine *sm)
 {
 	u32 index;
-	struct scic_sds_port *sci_port = object;
+	struct scic_sds_port *sci_port = container_of(sm, typeof(*sci_port), state_machine);
 	struct scic_sds_controller *scic = sci_port->owning_controller;
 	struct isci_host *ihost = scic_to_ihost(scic);
 	struct isci_port *iport = sci_port_to_iport(sci_port);
@@ -1210,9 +1210,9 @@ static void scic_sds_port_invalidate_dummy_remote_node(struct scic_sds_port *sci
  * exiting the SCIC_SDS_PORT_READY_SUBSTATE_OPERATIONAL. This function reports
  * the port not ready and suspends the port task scheduler. none
  */
-static void scic_sds_port_ready_substate_operational_exit(void *object)
+static void scic_sds_port_ready_substate_operational_exit(struct sci_base_state_machine *sm)
 {
-	struct scic_sds_port *sci_port = object;
+	struct scic_sds_port *sci_port = container_of(sm, typeof(*sci_port), state_machine);
 	struct scic_sds_controller *scic = sci_port->owning_controller;
 	struct isci_host *ihost = scic_to_ihost(scic);
 	struct isci_port *iport = sci_port_to_iport(sci_port);
@@ -1230,9 +1230,9 @@ static void scic_sds_port_ready_substate_operational_exit(void *object)
 		scic_sds_port_invalidate_dummy_remote_node(sci_port);
 }
 
-static void scic_sds_port_ready_substate_configuring_enter(void *object)
+static void scic_sds_port_ready_substate_configuring_enter(struct sci_base_state_machine *sm)
 {
-	struct scic_sds_port *sci_port = object;
+	struct scic_sds_port *sci_port = container_of(sm, typeof(*sci_port), state_machine);
 	struct scic_sds_controller *scic = sci_port->owning_controller;
 	struct isci_host *ihost = scic_to_ihost(scic);
 	struct isci_port *iport = sci_port_to_iport(sci_port);
@@ -1247,9 +1247,9 @@ static void scic_sds_port_ready_substate_configuring_enter(void *object)
 					  SCIC_SDS_PORT_READY_SUBSTATE_OPERATIONAL);
 }
 
-static void scic_sds_port_ready_substate_configuring_exit(void *object)
+static void scic_sds_port_ready_substate_configuring_exit(struct sci_base_state_machine *sm)
 {
-	struct scic_sds_port *sci_port = object;
+	struct scic_sds_port *sci_port = container_of(sm, typeof(*sci_port), state_machine);
 
 	scic_sds_port_suspend_port_task_scheduler(sci_port);
 	if (sci_port->ready_exit)
@@ -1710,9 +1710,9 @@ static void scic_sds_port_post_dummy_remote_node(struct scic_sds_port *sci_port)
 	scic_sds_controller_post_request(scic, command);
 }
 
-static void scic_sds_port_stopped_state_enter(void *object)
+static void scic_sds_port_stopped_state_enter(struct sci_base_state_machine *sm)
 {
-	struct scic_sds_port *sci_port = object;
+	struct scic_sds_port *sci_port = container_of(sm, typeof(*sci_port), state_machine);
 
 	if (sci_port->state_machine.previous_state_id == SCI_BASE_PORT_STATE_STOPPING) {
 		/*
@@ -1723,17 +1723,17 @@ static void scic_sds_port_stopped_state_enter(void *object)
 	}
 }
 
-static void scic_sds_port_stopped_state_exit(void *object)
+static void scic_sds_port_stopped_state_exit(struct sci_base_state_machine *sm)
 {
-	struct scic_sds_port *sci_port = object;
+	struct scic_sds_port *sci_port = container_of(sm, typeof(*sci_port), state_machine);
 
 	/* Enable and suspend the port task scheduler */
 	scic_sds_port_enable_port_task_scheduler(sci_port);
 }
 
-static void scic_sds_port_ready_state_enter(void *object)
+static void scic_sds_port_ready_state_enter(struct sci_base_state_machine *sm)
 {
-	struct scic_sds_port *sci_port = object;
+	struct scic_sds_port *sci_port = container_of(sm, typeof(*sci_port), state_machine);
 	struct scic_sds_controller *scic = sci_port->owning_controller;
 	struct isci_host *ihost = scic_to_ihost(scic);
 	struct isci_port *iport = sci_port_to_iport(sci_port);
@@ -1753,25 +1753,25 @@ static void scic_sds_port_ready_state_enter(void *object)
 				  SCIC_SDS_PORT_READY_SUBSTATE_WAITING);
 }
 
-static void scic_sds_port_resetting_state_exit(void *object)
+static void scic_sds_port_resetting_state_exit(struct sci_base_state_machine *sm)
 {
-	struct scic_sds_port *sci_port = object;
+	struct scic_sds_port *sci_port = container_of(sm, typeof(*sci_port), state_machine);
 
 	isci_timer_stop(sci_port->timer_handle);
 }
 
-static void scic_sds_port_stopping_state_exit(void *object)
+static void scic_sds_port_stopping_state_exit(struct sci_base_state_machine *sm)
 {
-	struct scic_sds_port *sci_port = object;
+	struct scic_sds_port *sci_port = container_of(sm, typeof(*sci_port), state_machine);
 
 	isci_timer_stop(sci_port->timer_handle);
 
 	scic_sds_port_destroy_dummy_resources(sci_port);
 }
 
-static void scic_sds_port_failed_state_enter(void *object)
+static void scic_sds_port_failed_state_enter(struct sci_base_state_machine *sm)
 {
-	struct scic_sds_port *sci_port = object;
+	struct scic_sds_port *sci_port = container_of(sm, typeof(*sci_port), state_machine);
 	struct isci_port *iport = sci_port_to_iport(sci_port);
 
 	isci_port_hard_reset_complete(iport, SCI_FAILURE_TIMEOUT);
@@ -1813,7 +1813,6 @@ void scic_sds_port_construct(struct scic_sds_port *sci_port, u8 index,
 			     struct scic_sds_controller *scic)
 {
 	sci_base_state_machine_construct(&sci_port->state_machine,
-					 sci_port,
 					 scic_sds_port_state_table,
 					 SCI_BASE_PORT_STATE_STOPPED);
 

commit 6813820c7b892e1a5c2306808a5ccc8a27b7946d
Author: Dan Williams <dan.j.williams@intel.com>
Date:   Thu May 12 07:16:06 2011 -0700

    isci: unify port start_io and complete_io handlers
    
    Unify the handlers and kill the state handler infrastructure.
    
    Reported-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/drivers/scsi/isci/port.c b/drivers/scsi/isci/port.c
index 61ba37da437d..f43c1f6c9669 100644
--- a/drivers/scsi/isci/port.c
+++ b/drivers/scsi/isci/port.c
@@ -61,8 +61,6 @@
 #define SCIC_SDS_PORT_HARD_RESET_TIMEOUT  (1000)
 #define SCU_DUMMY_INDEX    (0xFFFF)
 
-static struct scic_sds_port_state_handler scic_sds_port_state_handler_table[];
-
 static void isci_port_change_state(struct isci_port *iport, enum isci_status status)
 {
 	unsigned long flags;
@@ -928,40 +926,6 @@ bool scic_sds_port_link_detected(
 	return true;
 }
 
-/**
- * This method is called to start an IO request on this port.
- * @sci_port:
- * @sci_dev:
- * @sci_req:
- *
- * enum sci_status
- */
-enum sci_status scic_sds_port_start_io(
-	struct scic_sds_port *sci_port,
-	struct scic_sds_remote_device *sci_dev,
-	struct scic_sds_request *sci_req)
-{
-	return sci_port->state_handlers->start_io_handler(
-		       sci_port, sci_dev, sci_req);
-}
-
-/**
- * This method is called to complete an IO request to the port.
- * @sci_port:
- * @sci_dev:
- * @sci_req:
- *
- * enum sci_status
- */
-enum sci_status scic_sds_port_complete_io(
-	struct scic_sds_port *sci_port,
-	struct scic_sds_remote_device *sci_dev,
-	struct scic_sds_request *sci_req)
-{
-	return sci_port->state_handlers->complete_io_handler(
-		       sci_port, sci_dev, sci_req);
-}
-
 /**
  * This method is provided to timeout requests for port operations. Mostly its
  *    for the port reset operation.
@@ -1085,106 +1049,6 @@ static void scic_port_enable_broadcast_change_notification(struct scic_sds_port
 	}
 }
 
-/*
- * ****************************************************************************
- * *  READY SUBSTATE HANDLERS
- * **************************************************************************** */
-
-/*
- * This method is the general ready substate complete io handler for the
- * struct scic_sds_port object.  This function decrments the outstanding request count
- * for this port object. enum sci_status SCI_SUCCESS
- */
-static enum sci_status scic_sds_port_ready_substate_complete_io_handler(
-	struct scic_sds_port *port,
-	struct scic_sds_remote_device *device,
-	struct scic_sds_request *io_request)
-{
-	scic_sds_port_decrement_request_count(port);
-
-	return SCI_SUCCESS;
-}
-
-/*
- * This method is the ready waiting substate start io handler for the
- * struct scic_sds_port object. The port object can not accept new requests so the
- * request is failed. enum sci_status SCI_FAILURE_INVALID_STATE
- */
-static enum sci_status scic_sds_port_ready_waiting_substate_start_io_handler(
-	struct scic_sds_port *port,
-	struct scic_sds_remote_device *device,
-	struct scic_sds_request *io_request)
-{
-	return SCI_FAILURE_INVALID_STATE;
-}
-
-/*
- * This method is the ready operational substate start io handler for the
- * struct scic_sds_port object.  This function incremetns the outstanding request
- * count for this port object. enum sci_status SCI_SUCCESS
- */
-static enum sci_status scic_sds_port_ready_operational_substate_start_io_handler(
-	struct scic_sds_port *port,
-	struct scic_sds_remote_device *device,
-	struct scic_sds_request *io_request)
-{
-	port->started_request_count++;
-	return SCI_SUCCESS;
-}
-
-/**
- * scic_sds_port_ready_configuring_substate_complete_io_handler() -
- * @port: This is the port that is being requested to complete the io request.
- * @device: This is the device on which the io is completing.
- *
- * This method will decrement the outstanding request count for this port. If
- * the request count goes to 0 then the port can be reprogrammed with its new
- * phy data.
- */
-static enum sci_status
-scic_sds_port_ready_configuring_substate_complete_io_handler(
-	struct scic_sds_port *port,
-	struct scic_sds_remote_device *device,
-	struct scic_sds_request *io_request)
-{
-	scic_sds_port_decrement_request_count(port);
-
-	if (port->started_request_count == 0) {
-		port_state_machine_change(port,
-					  SCIC_SDS_PORT_READY_SUBSTATE_OPERATIONAL);
-	}
-
-	return SCI_SUCCESS;
-}
-
-static enum sci_status default_port_handler(struct scic_sds_port *sci_port,
-					    const char *func)
-{
-	dev_warn(sciport_to_dev(sci_port),
-		 "%s: in wrong state: %d\n", func,
-		 sci_base_state_machine_get_state(&sci_port->state_machine));
-	return SCI_FAILURE_INVALID_STATE;
-}
-
-static enum sci_status scic_sds_port_default_start_io_handler(struct scic_sds_port *sci_port,
-						       struct scic_sds_remote_device *sci_dev,
-						       struct scic_sds_request *sci_req)
-{
-	return default_port_handler(sci_port, __func__);
-}
-
-static enum sci_status scic_sds_port_default_complete_io_handler(struct scic_sds_port *sci_port,
-								 struct scic_sds_remote_device *sci_dev,
-								 struct scic_sds_request *sci_req)
-{
-	return default_port_handler(sci_port, __func__);
-}
-
-/*
- * ******************************************************************************
- * *  PORT STATE PRIVATE METHODS
- * ****************************************************************************** */
-
 /**
  *
  * @sci_port: This is the struct scic_sds_port object to suspend.
@@ -1269,28 +1133,10 @@ scic_sds_port_resume_port_task_scheduler(struct scic_sds_port *port)
 	writel(pts_control_value, &port->port_task_scheduler_registers->control);
 }
 
-/*
- * ******************************************************************************
- * *  PORT READY SUBSTATE METHODS
- * ****************************************************************************** */
-
-/**
- *
- * @object: This is the object which is cast to a struct scic_sds_port object.
- *
- * This method will perform the actions required by the struct scic_sds_port on
- * entering the SCIC_SDS_PORT_READY_SUBSTATE_WAITING. This function checks the
- * port for any ready phys.  If there is at least one phy in a ready state then
- * the port transitions to the ready operational substate. none
- */
 static void scic_sds_port_ready_substate_waiting_enter(void *object)
 {
 	struct scic_sds_port *sci_port = object;
 
-	scic_sds_port_set_base_state_handlers(
-		sci_port, SCIC_SDS_PORT_READY_SUBSTATE_WAITING
-		);
-
 	scic_sds_port_suspend_port_task_scheduler(sci_port);
 
 	sci_port->not_ready_reason = SCIC_PORT_NOT_READY_NO_ACTIVE_PHYS;
@@ -1302,15 +1148,6 @@ static void scic_sds_port_ready_substate_waiting_enter(void *object)
 	}
 }
 
-/**
- *
- * @object: This is the object which is cast to a struct scic_sds_port object.
- *
- * This function will perform the actions required by the struct scic_sds_port
- * on entering the SCIC_SDS_PORT_READY_SUBSTATE_OPERATIONAL. This function sets
- * the state handlers for the port object, notifies the SCI User that the port
- * is ready, and resumes port operations. none
- */
 static void scic_sds_port_ready_substate_operational_enter(void *object)
 {
 	u32 index;
@@ -1319,10 +1156,6 @@ static void scic_sds_port_ready_substate_operational_enter(void *object)
 	struct isci_host *ihost = scic_to_ihost(scic);
 	struct isci_port *iport = sci_port_to_iport(sci_port);
 
-	scic_sds_port_set_base_state_handlers(
-			sci_port,
-			SCIC_SDS_PORT_READY_SUBSTATE_OPERATIONAL);
-
 	isci_port_ready(ihost, iport);
 
 	for (index = 0; index < SCI_MAX_PHYS; index++) {
@@ -1397,19 +1230,6 @@ static void scic_sds_port_ready_substate_operational_exit(void *object)
 		scic_sds_port_invalidate_dummy_remote_node(sci_port);
 }
 
-/*
- * ******************************************************************************
- * *  PORT READY CONFIGURING METHODS
- * ****************************************************************************** */
-
-/**
- * scic_sds_port_ready_substate_configuring_enter() -
- * @object: This is the object which is cast to a struct scic_sds_port object.
- *
- * This method will perform the actions required by the struct scic_sds_port on
- * exiting the SCIC_SDS_PORT_READY_SUBSTATE_OPERATIONAL. This function reports
- * the port not ready and suspends the port task scheduler. none
- */
 static void scic_sds_port_ready_substate_configuring_enter(void *object)
 {
 	struct scic_sds_port *sci_port = object;
@@ -1417,10 +1237,6 @@ static void scic_sds_port_ready_substate_configuring_enter(void *object)
 	struct isci_host *ihost = scic_to_ihost(scic);
 	struct isci_port *iport = sci_port_to_iport(sci_port);
 
-	scic_sds_port_set_base_state_handlers(
-			sci_port,
-			SCIC_SDS_PORT_READY_SUBSTATE_CONFIGURING);
-
 	if (sci_port->active_phy_mask == 0) {
 		isci_port_not_ready(ihost, iport);
 
@@ -1440,50 +1256,6 @@ static void scic_sds_port_ready_substate_configuring_exit(void *object)
 		scic_sds_port_invalidate_dummy_remote_node(sci_port);
 }
 
-/* --------------------------------------------------------------------------- */
-
-/**
- *
- * @port: This is the struct scic_sds_port object on which the io request count will
- *    be decremented.
- * @device: This is the struct scic_sds_remote_device object to which the io request
- *    is being directed.  This parameter is not required to complete this
- *    operation.
- * @io_request: This is the request that is being completed on this port
- *    object.  This parameter is not required to complete this operation.
- *
- * This is a general complete io request handler for the struct scic_sds_port object.
- * enum sci_status SCI_SUCCESS
- */
-static enum sci_status scic_sds_port_general_complete_io_handler(
-	struct scic_sds_port *port,
-	struct scic_sds_remote_device *device,
-	struct scic_sds_request *io_request)
-{
-	scic_sds_port_decrement_request_count(port);
-
-	return SCI_SUCCESS;
-}
-
-/*
- * This method takes the struct scic_sds_port that is in a stopping state and handles
- * the complete io request. Should the request count reach 0 then the port
- * object will transition to the stopped state. enum sci_status SCI_SUCCESS
- */
-static enum sci_status scic_sds_port_stopping_state_complete_io_handler(
-	struct scic_sds_port *sci_port,
-	struct scic_sds_remote_device *device,
-	struct scic_sds_request *io_request)
-{
-	scic_sds_port_decrement_request_count(sci_port);
-
-	if (sci_port->started_request_count == 0)
-		port_state_machine_change(sci_port,
-					  SCI_BASE_PORT_STATE_STOPPED);
-
-	return SCI_SUCCESS;
-}
-
 enum sci_status scic_sds_port_start(struct scic_sds_port *sci_port)
 {
 	struct scic_sds_controller *scic = sci_port->owning_controller;
@@ -1818,45 +1590,62 @@ enum sci_status scic_sds_port_link_down(struct scic_sds_port *sci_port,
 	}
 }
 
-static struct scic_sds_port_state_handler scic_sds_port_state_handler_table[] = {
-	[SCI_BASE_PORT_STATE_STOPPED] = {
-		.start_io_handler 	= scic_sds_port_default_start_io_handler,
-		.complete_io_handler 	= scic_sds_port_default_complete_io_handler
-	},
-	[SCI_BASE_PORT_STATE_STOPPING] = {
-		.start_io_handler 	= scic_sds_port_default_start_io_handler,
-		.complete_io_handler 	= scic_sds_port_stopping_state_complete_io_handler
-	},
-	[SCI_BASE_PORT_STATE_READY] = {
-		.start_io_handler 	= scic_sds_port_default_start_io_handler,
-		.complete_io_handler 	= scic_sds_port_general_complete_io_handler
-	},
-	[SCIC_SDS_PORT_READY_SUBSTATE_WAITING] = {
-		.start_io_handler	= scic_sds_port_ready_waiting_substate_start_io_handler,
-		.complete_io_handler	= scic_sds_port_ready_substate_complete_io_handler,
-	},
-	[SCIC_SDS_PORT_READY_SUBSTATE_OPERATIONAL] = {
-		.start_io_handler	= scic_sds_port_ready_operational_substate_start_io_handler,
-		.complete_io_handler	= scic_sds_port_ready_substate_complete_io_handler,
-	},
-	[SCIC_SDS_PORT_READY_SUBSTATE_CONFIGURING] = {
-		.start_io_handler	= scic_sds_port_default_start_io_handler,
-		.complete_io_handler	= scic_sds_port_ready_configuring_substate_complete_io_handler
-	},
-	[SCI_BASE_PORT_STATE_RESETTING] = {
-		.start_io_handler	= scic_sds_port_default_start_io_handler,
-		.complete_io_handler	= scic_sds_port_general_complete_io_handler
-	},
-	[SCI_BASE_PORT_STATE_FAILED] = {
-		.start_io_handler	= scic_sds_port_default_start_io_handler,
-		.complete_io_handler	= scic_sds_port_general_complete_io_handler
+enum sci_status scic_sds_port_start_io(struct scic_sds_port *sci_port,
+				       struct scic_sds_remote_device *sci_dev,
+				       struct scic_sds_request *sci_req)
+{
+	enum scic_sds_port_states state;
+
+	state = sci_port->state_machine.current_state_id;
+	switch (state) {
+	case SCIC_SDS_PORT_READY_SUBSTATE_WAITING:
+		return SCI_FAILURE_INVALID_STATE;
+	case SCIC_SDS_PORT_READY_SUBSTATE_OPERATIONAL:
+		sci_port->started_request_count++;
+		return SCI_SUCCESS;
+	default:
+		dev_warn(sciport_to_dev(sci_port),
+			 "%s: in wrong state: %d\n", __func__, state);
+		return SCI_FAILURE_INVALID_STATE;
 	}
-};
+}
 
-/*
- * ******************************************************************************
- * *  PORT STATE PRIVATE METHODS
- * ****************************************************************************** */
+enum sci_status scic_sds_port_complete_io(struct scic_sds_port *sci_port,
+					  struct scic_sds_remote_device *sci_dev,
+					  struct scic_sds_request *sci_req)
+{
+	enum scic_sds_port_states state;
+
+	state = sci_port->state_machine.current_state_id;
+	switch (state) {
+	case SCI_BASE_PORT_STATE_STOPPED:
+		dev_warn(sciport_to_dev(sci_port),
+			 "%s: in wrong state: %d\n", __func__, state);
+		return SCI_FAILURE_INVALID_STATE;
+	case SCI_BASE_PORT_STATE_STOPPING:
+		scic_sds_port_decrement_request_count(sci_port);
+
+		if (sci_port->started_request_count == 0)
+			port_state_machine_change(sci_port,
+						  SCI_BASE_PORT_STATE_STOPPED);
+		break;
+	case SCI_BASE_PORT_STATE_READY:
+	case SCI_BASE_PORT_STATE_RESETTING:
+	case SCI_BASE_PORT_STATE_FAILED:
+	case SCIC_SDS_PORT_READY_SUBSTATE_WAITING:
+	case SCIC_SDS_PORT_READY_SUBSTATE_OPERATIONAL:
+		scic_sds_port_decrement_request_count(sci_port);
+		break;
+	case SCIC_SDS_PORT_READY_SUBSTATE_CONFIGURING:
+		scic_sds_port_decrement_request_count(sci_port);
+		if (sci_port->started_request_count == 0) {
+			port_state_machine_change(sci_port,
+						  SCIC_SDS_PORT_READY_SUBSTATE_OPERATIONAL);
+		}
+		break;
+	}
+	return SCI_SUCCESS;
+}
 
 /**
  *
@@ -1921,32 +1710,11 @@ static void scic_sds_port_post_dummy_remote_node(struct scic_sds_port *sci_port)
 	scic_sds_controller_post_request(scic, command);
 }
 
-/*
- * ******************************************************************************
- * *  PORT STATE METHODS
- * ****************************************************************************** */
-
-/**
- *
- * @object: This is the object which is cast to a struct scic_sds_port object.
- *
- * This method will perform the actions required by the struct scic_sds_port on
- * entering the SCI_BASE_PORT_STATE_STOPPED. This function sets the stopped
- * state handlers for the struct scic_sds_port object and disables the port task
- * scheduler in the hardware. none
- */
 static void scic_sds_port_stopped_state_enter(void *object)
 {
 	struct scic_sds_port *sci_port = object;
 
-	scic_sds_port_set_base_state_handlers(
-		sci_port, SCI_BASE_PORT_STATE_STOPPED
-		);
-
-	if (
-		SCI_BASE_PORT_STATE_STOPPING
-		== sci_port->state_machine.previous_state_id
-		) {
+	if (sci_port->state_machine.previous_state_id == SCI_BASE_PORT_STATE_STOPPING) {
 		/*
 		 * If we enter this state becasuse of a request to stop
 		 * the port then we want to disable the hardwares port
@@ -1955,14 +1723,6 @@ static void scic_sds_port_stopped_state_enter(void *object)
 	}
 }
 
-/**
- *
- * @object: This is the object which is cast to a struct scic_sds_port object.
- *
- * This method will perform the actions required by the struct scic_sds_port on
- * exiting the SCI_BASE_STATE_STOPPED. This function enables the SCU hardware
- * port task scheduler. none
- */
 static void scic_sds_port_stopped_state_exit(void *object)
 {
 	struct scic_sds_port *sci_port = object;
@@ -1971,15 +1731,6 @@ static void scic_sds_port_stopped_state_exit(void *object)
 	scic_sds_port_enable_port_task_scheduler(sci_port);
 }
 
-/**
- * scic_sds_port_ready_state_enter -
- * @object: This is the object which is cast to a struct scic_sds_port object.
- *
- * This method will perform the actions required by the struct scic_sds_port on
- * entering the SCI_BASE_PORT_STATE_READY. This function sets the ready state
- * handlers for the struct scic_sds_port object, reports the port object as
- * not ready and starts the ready substate machine. none
- */
 static void scic_sds_port_ready_state_enter(void *object)
 {
 	struct scic_sds_port *sci_port = object;
@@ -1988,9 +1739,6 @@ static void scic_sds_port_ready_state_enter(void *object)
 	struct isci_port *iport = sci_port_to_iport(sci_port);
 	u32 prev_state;
 
-	/* Put the ready state handlers in place though they will not be there long */
-	scic_sds_port_set_base_state_handlers(sci_port, SCI_BASE_PORT_STATE_READY);
-
 	prev_state = sci_port->state_machine.previous_state_id;
 	if (prev_state  == SCI_BASE_PORT_STATE_RESETTING)
 		isci_port_hard_reset_complete(iport, SCI_SUCCESS);
@@ -2005,66 +1753,14 @@ static void scic_sds_port_ready_state_enter(void *object)
 				  SCIC_SDS_PORT_READY_SUBSTATE_WAITING);
 }
 
-/**
- *
- * @object: This is the object which is cast to a struct scic_sds_port object.
- *
- * This method will perform the actions required by the struct scic_sds_port on
- * entering the SCI_BASE_PORT_STATE_RESETTING. This function sets the resetting
- * state handlers for the struct scic_sds_port object. none
- */
-static void scic_sds_port_resetting_state_enter(void *object)
-{
-	struct scic_sds_port *sci_port = object;
-
-	scic_sds_port_set_base_state_handlers(
-		sci_port, SCI_BASE_PORT_STATE_RESETTING
-		);
-}
-
-/**
- *
- * @object: This is the object which is cast to a struct scic_sds_port object.
- *
- * This function will perform the actions required by the
- * struct scic_sds_port on
- * exiting the SCI_BASE_STATE_RESETTING. This function does nothing. none
- */
-static inline void scic_sds_port_resetting_state_exit(void *object)
+static void scic_sds_port_resetting_state_exit(void *object)
 {
 	struct scic_sds_port *sci_port = object;
 
 	isci_timer_stop(sci_port->timer_handle);
 }
 
-/**
- *
- * @object: This is the void object which is cast to a
- * struct scic_sds_port object.
- *
- * This method will perform the actions required by the struct scic_sds_port on
- * entering the SCI_BASE_PORT_STATE_STOPPING. This function sets the stopping
- * state handlers for the struct scic_sds_port object. none
- */
-static void scic_sds_port_stopping_state_enter(void *object)
-{
-	struct scic_sds_port *sci_port = object;
-
-	scic_sds_port_set_base_state_handlers(
-		sci_port, SCI_BASE_PORT_STATE_STOPPING
-		);
-}
-
-/**
- *
- * @object: This is the object which is cast to a struct scic_sds_port object.
- *
- * This function will perform the actions required by the
- * struct scic_sds_port on
- * exiting the SCI_BASE_STATE_STOPPING. This function does nothing. none
- */
-static inline void
-scic_sds_port_stopping_state_exit(void *object)
+static void scic_sds_port_stopping_state_exit(void *object)
 {
 	struct scic_sds_port *sci_port = object;
 
@@ -2073,23 +1769,11 @@ scic_sds_port_stopping_state_exit(void *object)
 	scic_sds_port_destroy_dummy_resources(sci_port);
 }
 
-/**
- *
- * @object: This is the object which is cast to a struct scic_sds_port object.
- *
- * This function will perform the actions required by the
- * struct scic_sds_port on
- * entering the SCI_BASE_PORT_STATE_STOPPING. This function sets the stopping
- * state handlers for the struct scic_sds_port object. none
- */
 static void scic_sds_port_failed_state_enter(void *object)
 {
 	struct scic_sds_port *sci_port = object;
 	struct isci_port *iport = sci_port_to_iport(sci_port);
 
-	scic_sds_port_set_base_state_handlers(sci_port,
-					      SCI_BASE_PORT_STATE_FAILED);
-
 	isci_port_hard_reset_complete(iport, SCI_FAILURE_TIMEOUT);
 }
 
@@ -2101,7 +1785,6 @@ static const struct sci_base_state scic_sds_port_state_table[] = {
 		.exit_state  = scic_sds_port_stopped_state_exit
 	},
 	[SCI_BASE_PORT_STATE_STOPPING] = {
-		.enter_state = scic_sds_port_stopping_state_enter,
 		.exit_state  = scic_sds_port_stopping_state_exit
 	},
 	[SCI_BASE_PORT_STATE_READY] = {
@@ -2119,7 +1802,6 @@ static const struct sci_base_state scic_sds_port_state_table[] = {
 		.exit_state  = scic_sds_port_ready_substate_configuring_exit
 	},
 	[SCI_BASE_PORT_STATE_RESETTING] = {
-		.enter_state = scic_sds_port_resetting_state_enter,
 		.exit_state  = scic_sds_port_resetting_state_exit
 	},
 	[SCI_BASE_PORT_STATE_FAILED] = {

commit 051266caaeb15719553c5316e3d43b533d3cd5a0
Author: Piotr Sawicki <piotr.sawicki@intel.com>
Date:   Thu May 12 19:10:14 2011 +0000

    isci: unify port link_up and link_down handlers
    
    Unify the handlers and kill the state handler implementations.
    
    Reported-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Piotr Sawicki <piotr.sawicki@intel.com>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/drivers/scsi/isci/port.c b/drivers/scsi/isci/port.c
index d58001cb0bcf..61ba37da437d 100644
--- a/drivers/scsi/isci/port.c
+++ b/drivers/scsi/isci/port.c
@@ -928,36 +928,6 @@ bool scic_sds_port_link_detected(
 	return true;
 }
 
-/**
- * This method is the entry point for the phy to inform the port that it is now
- *    in a ready state
- * @sci_port:
- *
- *
- */
-void scic_sds_port_link_up(
-	struct scic_sds_port *sci_port,
-	struct scic_sds_phy *sci_phy)
-{
-	sci_phy->is_in_link_training = false;
-
-	sci_port->state_handlers->link_up_handler(sci_port, sci_phy);
-}
-
-/**
- * This method is the entry point for the phy to inform the port that it is no
- *    longer in a ready state
- * @sci_port:
- *
- *
- */
-void scic_sds_port_link_down(
-	struct scic_sds_port *sci_port,
-	struct scic_sds_phy *sci_phy)
-{
-	sci_port->state_handlers->link_down_handler(sci_port, sci_phy);
-}
-
 /**
  * This method is called to start an IO request on this port.
  * @sci_port:
@@ -1135,29 +1105,6 @@ static enum sci_status scic_sds_port_ready_substate_complete_io_handler(
 	return SCI_SUCCESS;
 }
 
-/**
- *
- * @sci_port: This is the struct scic_sds_port object that which has a phy that has
- *    gone link up.
- * @sci_phy: This is the struct scic_sds_phy object that has gone link up.
- *
- * This method is the ready waiting substate link up handler for the
- * struct scic_sds_port object.  This methos will report the link up condition for
- * this port and will transition to the ready operational substate. none
- */
-static void scic_sds_port_ready_waiting_substate_link_up_handler(
-	struct scic_sds_port *sci_port,
-	struct scic_sds_phy *sci_phy)
-{
-	/*
-	 * Since this is the first phy going link up for the port we can just enable
-	 * it and continue. */
-	scic_sds_port_activate_phy(sci_port, sci_phy, true);
-
-	port_state_machine_change(sci_port,
-				  SCIC_SDS_PORT_READY_SUBSTATE_OPERATIONAL);
-}
-
 /*
  * This method is the ready waiting substate start io handler for the
  * struct scic_sds_port object. The port object can not accept new requests so the
@@ -1171,49 +1118,6 @@ static enum sci_status scic_sds_port_ready_waiting_substate_start_io_handler(
 	return SCI_FAILURE_INVALID_STATE;
 }
 
-/**
- * scic_sds_port_ready_operational_substate_link_up_handler() -
- * @sci_port: This is the struct scic_sds_port object that which has a phy that has
- *    gone link up.
- * @sci_phy: This is the struct scic_sds_phy object that has gone link up.
- *
- * This method is the ready operational substate link up handler for the
- * struct scic_sds_port object. This function notifies the SCI User that the phy has
- * gone link up. none
- */
-static void scic_sds_port_ready_operational_substate_link_up_handler(
-	struct scic_sds_port *sci_port,
-	struct scic_sds_phy *sci_phy)
-{
-	scic_sds_port_general_link_up_handler(sci_port, sci_phy, true);
-}
-
-/**
- * scic_sds_port_ready_operational_substate_link_down_handler() -
- * @sci_port: This is the struct scic_sds_port object that which has a phy that has
- *    gone link down.
- * @sci_phy: This is the struct scic_sds_phy object that has gone link down.
- *
- * This method is the ready operational substate link down handler for the
- * struct scic_sds_port object. This function notifies the SCI User that the phy has
- * gone link down and if this is the last phy in the port the port will change
- * state to the ready waiting substate. none
- */
-static void scic_sds_port_ready_operational_substate_link_down_handler(
-	struct scic_sds_port *sci_port,
-	struct scic_sds_phy *sci_phy)
-{
-	scic_sds_port_deactivate_phy(sci_port, sci_phy, true);
-
-	/*
-	 * If there are no active phys left in the port, then transition
-	 * the port to the WAITING state until such time as a phy goes
-	 * link up. */
-	if (sci_port->active_phy_mask == 0)
-		port_state_machine_change(sci_port,
-				          SCIC_SDS_PORT_READY_SUBSTATE_WAITING);
-}
-
 /*
  * This method is the ready operational substate start io handler for the
  * struct scic_sds_port object.  This function incremetns the outstanding request
@@ -1262,18 +1166,6 @@ static enum sci_status default_port_handler(struct scic_sds_port *sci_port,
 	return SCI_FAILURE_INVALID_STATE;
 }
 
-static void scic_sds_port_default_link_up_handler(struct scic_sds_port *sci_port,
-					   struct scic_sds_phy *sci_phy)
-{
-	default_port_handler(sci_port, __func__);
-}
-
-static void scic_sds_port_default_link_down_handler(struct scic_sds_port *sci_port,
-					     struct scic_sds_phy *sci_phy)
-{
-	default_port_handler(sci_port, __func__);
-}
-
 static enum sci_status scic_sds_port_default_start_io_handler(struct scic_sds_port *sci_port,
 						       struct scic_sds_remote_device *sci_dev,
 						       struct scic_sds_request *sci_req)
@@ -1592,51 +1484,6 @@ static enum sci_status scic_sds_port_stopping_state_complete_io_handler(
 	return SCI_SUCCESS;
 }
 
-/*
- * ****************************************************************************
- * *  RESETTING STATE HANDLERS
- * **************************************************************************** */
-
-/*
- * This method will transition a failed port to its ready state.  The port
- * failed because a hard reset request timed out but at some time later one or
- * more phys in the port became ready. enum sci_status SCI_SUCCESS
- */
-static void scic_sds_port_reset_state_link_up_handler(
-	struct scic_sds_port *port,
-	struct scic_sds_phy *phy)
-{
-	/*
-	 * / @todo We should make sure that the phy that has gone link up is the same
-	 * /       one on which we sent the reset.  It is possible that the phy on
-	 * /       which we sent the reset is not the one that has gone link up and we
-	 * /       want to make sure that phy being reset comes back.  Consider the
-	 * /       case where a reset is sent but before the hardware processes the
-	 * /       reset it get a link up on the port because of a hot plug event.
-	 * /       because of the reset request this phy will go link down almost
-	 * /       immediately. */
-
-	/*
-	 * In the resetting state we don't notify the user regarding
-	 * link up and link down notifications. */
-	scic_sds_port_general_link_up_handler(port, phy, false);
-}
-
-/*
- * This method process link down notifications that occur during a port reset
- * operation. Link downs can occur during the reset operation. enum sci_status
- * SCI_SUCCESS
- */
-static void scic_sds_port_reset_state_link_down_handler(
-	struct scic_sds_port *port,
-	struct scic_sds_phy *phy)
-{
-	/*
-	 * In the resetting state we don't notify the user regarding
-	 * link up and link down notifications. */
-	scic_sds_port_deactivate_phy(port, phy, false);
-}
-
 enum sci_status scic_sds_port_start(struct scic_sds_port *sci_port)
 {
 	struct scic_sds_controller *scic = sci_port->owning_controller;
@@ -1890,7 +1737,79 @@ enum sci_status scic_sds_port_remove_phy(struct scic_sds_port *sci_port,
 		 */
 		port_state_machine_change(sci_port,
 					  SCIC_SDS_PORT_READY_SUBSTATE_CONFIGURING);
+		return SCI_SUCCESS;
+	default:
+		dev_warn(sciport_to_dev(sci_port),
+			 "%s: in wrong state: %d\n", __func__, state);
+		return SCI_FAILURE_INVALID_STATE;
+	}
+}
 
+enum sci_status scic_sds_port_link_up(struct scic_sds_port *sci_port,
+				      struct scic_sds_phy *sci_phy)
+{
+	enum scic_sds_port_states state;
+
+	state = sci_port->state_machine.current_state_id;
+	switch (state) {
+	case SCIC_SDS_PORT_READY_SUBSTATE_WAITING:
+		/* Since this is the first phy going link up for the port we
+		 * can just enable it and continue
+		 */
+		scic_sds_port_activate_phy(sci_port, sci_phy, true);
+
+		port_state_machine_change(sci_port,
+					  SCIC_SDS_PORT_READY_SUBSTATE_OPERATIONAL);
+		return SCI_SUCCESS;
+	case SCIC_SDS_PORT_READY_SUBSTATE_OPERATIONAL:
+		scic_sds_port_general_link_up_handler(sci_port, sci_phy, true);
+		return SCI_SUCCESS;
+	case SCI_BASE_PORT_STATE_RESETTING:
+		/* TODO We should  make  sure  that  the phy  that  has gone
+		 * link up is the same one on which we sent the reset.  It is
+		 * possible that the phy on which we sent  the reset is not the
+		 * one that has  gone  link up  and we  want to make sure that
+		 * phy being reset  comes  back.  Consider the case where a
+		 * reset is sent but before the hardware processes the reset it
+		 * get a link up on  the  port because of a hot plug event.
+		 * because  of  the reset request this phy will go link down
+		 * almost immediately.
+		 */
+
+		/* In the resetting state we don't notify the user regarding
+		 * link up and link down notifications.
+		 */
+		scic_sds_port_general_link_up_handler(sci_port, sci_phy, false);
+		return SCI_SUCCESS;
+	default:
+		dev_warn(sciport_to_dev(sci_port),
+			 "%s: in wrong state: %d\n", __func__, state);
+		return SCI_FAILURE_INVALID_STATE;
+	}
+}
+
+enum sci_status scic_sds_port_link_down(struct scic_sds_port *sci_port,
+					struct scic_sds_phy *sci_phy)
+{
+	enum scic_sds_port_states state;
+
+	state = sci_port->state_machine.current_state_id;
+	switch (state) {
+	case SCIC_SDS_PORT_READY_SUBSTATE_OPERATIONAL:
+		scic_sds_port_deactivate_phy(sci_port, sci_phy, true);
+
+		/* If there are no active phys left in the port, then
+		 * transition the port to the WAITING state until such time
+		 * as a phy goes link up
+		 */
+		if (sci_port->active_phy_mask == 0)
+			port_state_machine_change(sci_port,
+						  SCIC_SDS_PORT_READY_SUBSTATE_WAITING);
+		return SCI_SUCCESS;
+	case SCI_BASE_PORT_STATE_RESETTING:
+		/* In the resetting state we don't notify the user regarding
+		 * link up and link down notifications. */
+		scic_sds_port_deactivate_phy(sci_port, sci_phy, false);
 		return SCI_SUCCESS;
 	default:
 		dev_warn(sciport_to_dev(sci_port),
@@ -1901,50 +1820,34 @@ enum sci_status scic_sds_port_remove_phy(struct scic_sds_port *sci_port,
 
 static struct scic_sds_port_state_handler scic_sds_port_state_handler_table[] = {
 	[SCI_BASE_PORT_STATE_STOPPED] = {
-		.link_up_handler        = scic_sds_port_default_link_up_handler,
-		.link_down_handler 	= scic_sds_port_default_link_down_handler,
 		.start_io_handler 	= scic_sds_port_default_start_io_handler,
 		.complete_io_handler 	= scic_sds_port_default_complete_io_handler
 	},
 	[SCI_BASE_PORT_STATE_STOPPING] = {
-		.link_up_handler        = scic_sds_port_default_link_up_handler,
-		.link_down_handler 	= scic_sds_port_default_link_down_handler,
 		.start_io_handler 	= scic_sds_port_default_start_io_handler,
 		.complete_io_handler 	= scic_sds_port_stopping_state_complete_io_handler
 	},
 	[SCI_BASE_PORT_STATE_READY] = {
-		.link_up_handler 	= scic_sds_port_default_link_up_handler,
-		.link_down_handler 	= scic_sds_port_default_link_down_handler,
 		.start_io_handler 	= scic_sds_port_default_start_io_handler,
 		.complete_io_handler 	= scic_sds_port_general_complete_io_handler
 	},
 	[SCIC_SDS_PORT_READY_SUBSTATE_WAITING] = {
-		.link_up_handler	= scic_sds_port_ready_waiting_substate_link_up_handler,
-		.link_down_handler	= scic_sds_port_default_link_down_handler,
 		.start_io_handler	= scic_sds_port_ready_waiting_substate_start_io_handler,
 		.complete_io_handler	= scic_sds_port_ready_substate_complete_io_handler,
 	},
 	[SCIC_SDS_PORT_READY_SUBSTATE_OPERATIONAL] = {
-		.link_up_handler	= scic_sds_port_ready_operational_substate_link_up_handler,
-		.link_down_handler	= scic_sds_port_ready_operational_substate_link_down_handler,
 		.start_io_handler	= scic_sds_port_ready_operational_substate_start_io_handler,
 		.complete_io_handler	= scic_sds_port_ready_substate_complete_io_handler,
 	},
 	[SCIC_SDS_PORT_READY_SUBSTATE_CONFIGURING] = {
-		.link_up_handler	= scic_sds_port_default_link_up_handler,
-		.link_down_handler	= scic_sds_port_default_link_down_handler,
 		.start_io_handler	= scic_sds_port_default_start_io_handler,
 		.complete_io_handler	= scic_sds_port_ready_configuring_substate_complete_io_handler
 	},
 	[SCI_BASE_PORT_STATE_RESETTING] = {
-		.link_up_handler	= scic_sds_port_reset_state_link_up_handler,
-		.link_down_handler	= scic_sds_port_reset_state_link_down_handler,
 		.start_io_handler	= scic_sds_port_default_start_io_handler,
 		.complete_io_handler	= scic_sds_port_general_complete_io_handler
 	},
 	[SCI_BASE_PORT_STATE_FAILED] = {
-		.link_up_handler	= scic_sds_port_default_link_up_handler,
-		.link_down_handler	= scic_sds_port_default_link_down_handler,
 		.start_io_handler	= scic_sds_port_default_start_io_handler,
 		.complete_io_handler	= scic_sds_port_general_complete_io_handler
 	}

commit 13721e186fd31cd8475e635a89383853871fdbf1
Author: Piotr Sawicki <piotr.sawicki@intel.com>
Date:   Thu May 12 19:10:08 2011 +0000

    isci: remove port frame and event handlers
    
    Unused infrastructure.
    
    Reported-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Piotr Sawicki <piotr.sawicki@intel.com>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/drivers/scsi/isci/port.c b/drivers/scsi/isci/port.c
index 5501e14c8d93..d58001cb0bcf 100644
--- a/drivers/scsi/isci/port.c
+++ b/drivers/scsi/isci/port.c
@@ -1262,30 +1262,6 @@ static enum sci_status default_port_handler(struct scic_sds_port *sci_port,
 	return SCI_FAILURE_INVALID_STATE;
 }
 
-/*
- * This is the default method for a port unsolicited frame request.  It will
- * report a warning and exit. enum sci_status SCI_FAILURE_INVALID_STATE Is it even
- * possible to receive an unsolicited frame directed to a port object?  It
- * seems possible if we implementing virtual functions but until then?
- */
-static enum sci_status
-scic_sds_port_default_frame_handler(struct scic_sds_port *sci_port,
-				    u32 frame_index)
-{
-	struct scic_sds_controller *scic = scic_sds_port_get_controller(sci_port);
-
-	default_port_handler(sci_port, __func__);
-	scic_sds_controller_release_frame(scic, frame_index);
-
-	return SCI_FAILURE_INVALID_STATE;
-}
-
-static enum sci_status scic_sds_port_default_event_handler(struct scic_sds_port *sci_port,
-						    u32 event_code)
-{
-	return default_port_handler(sci_port, __func__);
-}
-
 static void scic_sds_port_default_link_up_handler(struct scic_sds_port *sci_port,
 					   struct scic_sds_phy *sci_phy)
 {
@@ -1925,64 +1901,48 @@ enum sci_status scic_sds_port_remove_phy(struct scic_sds_port *sci_port,
 
 static struct scic_sds_port_state_handler scic_sds_port_state_handler_table[] = {
 	[SCI_BASE_PORT_STATE_STOPPED] = {
-		.frame_handler  	= scic_sds_port_default_frame_handler,
-		.event_handler  	= scic_sds_port_default_event_handler,
 		.link_up_handler        = scic_sds_port_default_link_up_handler,
 		.link_down_handler 	= scic_sds_port_default_link_down_handler,
 		.start_io_handler 	= scic_sds_port_default_start_io_handler,
 		.complete_io_handler 	= scic_sds_port_default_complete_io_handler
 	},
 	[SCI_BASE_PORT_STATE_STOPPING] = {
-		.frame_handler  	= scic_sds_port_default_frame_handler,
-		.event_handler  	= scic_sds_port_default_event_handler,
 		.link_up_handler        = scic_sds_port_default_link_up_handler,
 		.link_down_handler 	= scic_sds_port_default_link_down_handler,
 		.start_io_handler 	= scic_sds_port_default_start_io_handler,
 		.complete_io_handler 	= scic_sds_port_stopping_state_complete_io_handler
 	},
 	[SCI_BASE_PORT_STATE_READY] = {
-		.frame_handler   	= scic_sds_port_default_frame_handler,
-		.event_handler   	= scic_sds_port_default_event_handler,
 		.link_up_handler 	= scic_sds_port_default_link_up_handler,
 		.link_down_handler 	= scic_sds_port_default_link_down_handler,
 		.start_io_handler 	= scic_sds_port_default_start_io_handler,
 		.complete_io_handler 	= scic_sds_port_general_complete_io_handler
 	},
 	[SCIC_SDS_PORT_READY_SUBSTATE_WAITING] = {
-		.frame_handler		= scic_sds_port_default_frame_handler,
-		.event_handler		= scic_sds_port_default_event_handler,
 		.link_up_handler	= scic_sds_port_ready_waiting_substate_link_up_handler,
 		.link_down_handler	= scic_sds_port_default_link_down_handler,
 		.start_io_handler	= scic_sds_port_ready_waiting_substate_start_io_handler,
 		.complete_io_handler	= scic_sds_port_ready_substate_complete_io_handler,
 	},
 	[SCIC_SDS_PORT_READY_SUBSTATE_OPERATIONAL] = {
-		.frame_handler		= scic_sds_port_default_frame_handler,
-		.event_handler		= scic_sds_port_default_event_handler,
 		.link_up_handler	= scic_sds_port_ready_operational_substate_link_up_handler,
 		.link_down_handler	= scic_sds_port_ready_operational_substate_link_down_handler,
 		.start_io_handler	= scic_sds_port_ready_operational_substate_start_io_handler,
 		.complete_io_handler	= scic_sds_port_ready_substate_complete_io_handler,
 	},
 	[SCIC_SDS_PORT_READY_SUBSTATE_CONFIGURING] = {
-		.frame_handler		= scic_sds_port_default_frame_handler,
-		.event_handler		= scic_sds_port_default_event_handler,
 		.link_up_handler	= scic_sds_port_default_link_up_handler,
 		.link_down_handler	= scic_sds_port_default_link_down_handler,
 		.start_io_handler	= scic_sds_port_default_start_io_handler,
 		.complete_io_handler	= scic_sds_port_ready_configuring_substate_complete_io_handler
 	},
 	[SCI_BASE_PORT_STATE_RESETTING] = {
-		.frame_handler		= scic_sds_port_default_frame_handler,
-		.event_handler		= scic_sds_port_default_event_handler,
 		.link_up_handler	= scic_sds_port_reset_state_link_up_handler,
 		.link_down_handler	= scic_sds_port_reset_state_link_down_handler,
 		.start_io_handler	= scic_sds_port_default_start_io_handler,
 		.complete_io_handler	= scic_sds_port_general_complete_io_handler
 	},
 	[SCI_BASE_PORT_STATE_FAILED] = {
-		.frame_handler		= scic_sds_port_default_frame_handler,
-		.event_handler		= scic_sds_port_default_event_handler,
 		.link_up_handler	= scic_sds_port_default_link_up_handler,
 		.link_down_handler	= scic_sds_port_default_link_down_handler,
 		.start_io_handler	= scic_sds_port_default_start_io_handler,

commit bd6713b416bbfc7d7180114f7cc543b152cc1725
Author: Piotr Sawicki <piotr.sawicki@intel.com>
Date:   Thu May 12 19:10:03 2011 +0000

    isci: unify port reset, add_phy, and remove_phy handlers
    
    Unify the implementations and remove the state handlers.
    
    Reported-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Piotr Sawicki <piotr.sawicki@intel.com>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/drivers/scsi/isci/port.c b/drivers/scsi/isci/port.c
index 1a058a27ebc1..5501e14c8d93 100644
--- a/drivers/scsi/isci/port.c
+++ b/drivers/scsi/isci/port.c
@@ -531,40 +531,6 @@ static enum sci_status scic_sds_port_clear_phy(
 	return SCI_FAILURE;
 }
 
-/**
- * scic_sds_port_add_phy() -
- * @sci_port: This parameter specifies the port in which the phy will be added.
- * @sci_phy: This parameter is the phy which is to be added to the port.
- *
- * This method will add a PHY to the selected port. This method returns an
- * enum sci_status. SCI_SUCCESS the phy has been added to the port. Any other status
- * is failre to add the phy to the port.
- */
-enum sci_status scic_sds_port_add_phy(
-	struct scic_sds_port *sci_port,
-	struct scic_sds_phy *sci_phy)
-{
-	return sci_port->state_handlers->add_phy_handler(
-		       sci_port, sci_phy);
-}
-
-
-/**
- * scic_sds_port_remove_phy() -
- * @sci_port: This parameter specifies the port in which the phy will be added.
- * @sci_phy: This parameter is the phy which is to be added to the port.
- *
- * This method will remove the PHY from the selected PORT. This method returns
- * an enum sci_status. SCI_SUCCESS the phy has been removed from the port. Any other
- * status is failre to add the phy to the port.
- */
-enum sci_status scic_sds_port_remove_phy(
-	struct scic_sds_port *sci_port,
-	struct scic_sds_phy *sci_phy)
-{
-	return sci_port->state_handlers->remove_phy_handler(
-		       sci_port, sci_phy);
-}
 
 /**
  * This method requests the SAS address for the supplied SAS port from the SCI
@@ -745,23 +711,6 @@ enum sci_status scic_sds_port_initialize(
 	return SCI_SUCCESS;
 }
 
-/**
- * scic_port_hard_reset() - perform port hard reset
- * @port: a handle corresponding to the SAS port to be hard reset.
- * @reset_timeout: This parameter specifies the number of milliseconds in which
- *    the port reset operation should complete.
- *
- * The SCI User callback in scic_user_callbacks_t will only be called once for
- * each phy in the SAS Port at completion of the hard reset sequence. Return a
- * status indicating whether the hard reset started successfully. SCI_SUCCESS
- * This value is returned if the hard reset operation started successfully.
- */
-static enum sci_status scic_port_hard_reset(struct scic_sds_port *port,
-					    u32 reset_timeout)
-{
-	return port->state_handlers->reset_handler(
-		       port, reset_timeout);
-}
 
 /**
  * This method assigns the direct attached device ID for this port.
@@ -1186,48 +1135,6 @@ static enum sci_status scic_sds_port_ready_substate_complete_io_handler(
 	return SCI_SUCCESS;
 }
 
-static enum sci_status scic_sds_port_ready_substate_add_phy_handler(struct scic_sds_port *sci_port,
-								    struct scic_sds_phy *sci_phy)
-{
-	enum sci_status status;
-
-	status = scic_sds_port_set_phy(sci_port, sci_phy);
-
-	if (status != SCI_SUCCESS)
-		return status;
-
-	scic_sds_port_general_link_up_handler(sci_port, sci_phy, true);
-	sci_port->not_ready_reason = SCIC_PORT_NOT_READY_RECONFIGURING;
-	port_state_machine_change(sci_port, SCIC_SDS_PORT_READY_SUBSTATE_CONFIGURING);
-
-	return status;
-}
-
-
-static enum sci_status scic_sds_port_ready_substate_remove_phy_handler(struct scic_sds_port *port,
-								       struct scic_sds_phy *phy)
-{
-	enum sci_status status;
-
-	status = scic_sds_port_clear_phy(port, phy);
-
-	if (status != SCI_SUCCESS)
-		return status;
-
-	scic_sds_port_deactivate_phy(port, phy, true);
-
-	port->not_ready_reason = SCIC_PORT_NOT_READY_RECONFIGURING;
-
-	port_state_machine_change(port,
-				  SCIC_SDS_PORT_READY_SUBSTATE_CONFIGURING);
-	return status;
-}
-
-/*
- * ****************************************************************************
- * *  READY SUBSTATE WAITING HANDLERS
- * **************************************************************************** */
-
 /**
  *
  * @sci_port: This is the struct scic_sds_port object that which has a phy that has
@@ -1264,57 +1171,6 @@ static enum sci_status scic_sds_port_ready_waiting_substate_start_io_handler(
 	return SCI_FAILURE_INVALID_STATE;
 }
 
-/*
- * ****************************************************************************
- * *  READY SUBSTATE OPERATIONAL HANDLERS
- * **************************************************************************** */
-
-/*
- * This method will casue the port to reset. enum sci_status SCI_SUCCESS
- */
-static enum
-sci_status scic_sds_port_ready_operational_substate_reset_handler(
-		struct scic_sds_port *port,
-		u32 timeout)
-{
-	enum sci_status status = SCI_FAILURE_INVALID_PHY;
-	u32 phy_index;
-	struct scic_sds_phy *selected_phy = NULL;
-
-
-	/* Select a phy on which we can send the hard reset request. */
-	for (phy_index = 0;
-	     (phy_index < SCI_MAX_PHYS) && (selected_phy == NULL);
-	     phy_index++) {
-		selected_phy = port->phy_table[phy_index];
-
-		if ((selected_phy != NULL) &&
-		    !scic_sds_port_active_phy(port, selected_phy)) {
-			/*
-			 * We found a phy but it is not ready select
-			 * different phy
-			 */
-			selected_phy = NULL;
-		}
-	}
-
-	/* If we have a phy then go ahead and start the reset procedure */
-	if (selected_phy != NULL) {
-		status = scic_sds_phy_reset(selected_phy);
-
-		if (status == SCI_SUCCESS) {
-			isci_timer_start(port->timer_handle, timeout);
-			port->not_ready_reason =
-				SCIC_PORT_NOT_READY_HARD_RESET_REQUESTED;
-
-			port_state_machine_change(port,
-						  SCI_BASE_PORT_STATE_RESETTING);
-		}
-	}
-
-	return status;
-}
-
 /**
  * scic_sds_port_ready_operational_substate_link_up_handler() -
  * @sci_port: This is the struct scic_sds_port object that which has a phy that has
@@ -1372,61 +1228,6 @@ static enum sci_status scic_sds_port_ready_operational_substate_start_io_handler
 	return SCI_SUCCESS;
 }
 
-/*
- * ****************************************************************************
- * *  READY SUBSTATE OPERATIONAL HANDLERS
- * **************************************************************************** */
-
-/*
- * This is the default method for a port add phy request.  It will report a
- * warning and exit. enum sci_status SCI_FAILURE_INVALID_STATE
- */
-static enum sci_status scic_sds_port_ready_configuring_substate_add_phy_handler(
-	struct scic_sds_port *port,
-	struct scic_sds_phy *phy)
-{
-	enum sci_status status;
-
-	status = scic_sds_port_set_phy(port, phy);
-
-	if (status == SCI_SUCCESS) {
-		scic_sds_port_general_link_up_handler(port, phy, true);
-
-		/*
-		 * Re-enter the configuring state since this may be the last phy in
-		 * the port. */
-		port_state_machine_change(port,
-					  SCIC_SDS_PORT_READY_SUBSTATE_CONFIGURING);
-	}
-
-	return status;
-}
-
-/*
- * This is the default method for a port remove phy request.  It will report a
- * warning and exit. enum sci_status SCI_FAILURE_INVALID_STATE
- */
-static enum sci_status scic_sds_port_ready_configuring_substate_remove_phy_handler(
-	struct scic_sds_port *port,
-	struct scic_sds_phy *phy)
-{
-	enum sci_status status;
-
-	status = scic_sds_port_clear_phy(port, phy);
-
-	if (status != SCI_SUCCESS)
-		return status;
-	scic_sds_port_deactivate_phy(port, phy, true);
-
-	/* Re-enter the configuring state since this may be the last phy in
-	 * the port
-	 */
-	port_state_machine_change(port,
-				  SCIC_SDS_PORT_READY_SUBSTATE_CONFIGURING);
-
-	return status;
-}
-
 /**
  * scic_sds_port_ready_configuring_substate_complete_io_handler() -
  * @port: This is the port that is being requested to complete the io request.
@@ -1461,27 +1262,6 @@ static enum sci_status default_port_handler(struct scic_sds_port *sci_port,
 	return SCI_FAILURE_INVALID_STATE;
 }
 
-static enum sci_status
-scic_sds_port_default_reset_handler(struct scic_sds_port *sci_port,
-				    u32 timeout)
-{
-	return default_port_handler(sci_port, __func__);
-}
-
-static enum sci_status
-scic_sds_port_default_add_phy_handler(struct scic_sds_port *sci_port,
-				      struct scic_sds_phy *base_phy)
-{
-	return default_port_handler(sci_port, __func__);
-}
-
-static enum sci_status
-scic_sds_port_default_remove_phy_handler(struct scic_sds_port *sci_port,
-					 struct scic_sds_phy *base_phy)
-{
-	return default_port_handler(sci_port, __func__);
-}
-
 /*
  * This is the default method for a port unsolicited frame request.  It will
  * report a warning and exit. enum sci_status SCI_FAILURE_INVALID_STATE Is it even
@@ -1817,70 +1597,6 @@ static enum sci_status scic_sds_port_general_complete_io_handler(
 	return SCI_SUCCESS;
 }
 
-/*
- * This method takes the struct scic_sds_port that is in a stopped state and handles
- * the add phy request.  In MPC mode the only time a phy can be added to a port
- * is in the SCI_BASE_PORT_STATE_STOPPED. enum sci_status
- * SCI_FAILURE_UNSUPPORTED_PORT_CONFIGURATION is returned when the phy can not
- * be added to the port. SCI_SUCCESS if the phy is added to the port.
- */
-static enum sci_status scic_sds_port_stopped_state_add_phy_handler(
-	struct scic_sds_port *port,
-	struct scic_sds_phy *phy)
-{
-	struct sci_sas_address port_sas_address;
-
-	/* Read the port assigned SAS Address if there is one */
-	scic_sds_port_get_sas_address(port, &port_sas_address);
-
-	if (port_sas_address.high != 0 && port_sas_address.low != 0) {
-		struct sci_sas_address phy_sas_address;
-
-		/*
-		 * Make sure that the PHY SAS Address matches the SAS Address
-		 * for this port. */
-		scic_sds_phy_get_sas_address(phy, &phy_sas_address);
-
-		if (
-			(port_sas_address.high != phy_sas_address.high)
-			|| (port_sas_address.low  != phy_sas_address.low)
-			) {
-			return SCI_FAILURE_UNSUPPORTED_PORT_CONFIGURATION;
-		}
-	}
-
-	return scic_sds_port_set_phy(port, phy);
-}
-
-/*
- * This method takes the struct scic_sds_port that is in a stopped state and handles
- * the remove phy request.  In MPC mode the only time a phy can be removed from
- * a port is in the SCI_BASE_PORT_STATE_STOPPED. enum sci_status
- * SCI_FAILURE_UNSUPPORTED_PORT_CONFIGURATION is returned when the phy can not
- * be added to the port. SCI_SUCCESS if the phy is added to the port.
- */
-static enum sci_status scic_sds_port_stopped_state_remove_phy_handler(
-	struct scic_sds_port *port,
-	struct scic_sds_phy *phy)
-{
-	return scic_sds_port_clear_phy(port, phy);
-}
-
-/*
- * ****************************************************************************
- * *  READY STATE HANDLERS
- * **************************************************************************** */
-
-/*
- * ****************************************************************************
- * *  RESETTING STATE HANDLERS
- * **************************************************************************** */
-
-/*
- * ****************************************************************************
- * *  STOPPING STATE HANDLERS
- * **************************************************************************** */
-
 /*
  * This method takes the struct scic_sds_port that is in a stopping state and handles
  * the complete io request. Should the request count reach 0 then the port
@@ -2044,11 +1760,171 @@ enum sci_status scic_sds_port_stop(struct scic_sds_port *sci_port)
 	}
 }
 
+static enum sci_status scic_port_hard_reset(struct scic_sds_port *sci_port, u32 timeout)
+{
+	enum sci_status status = SCI_FAILURE_INVALID_PHY;
+	struct scic_sds_phy *selected_phy = NULL;
+	enum scic_sds_port_states state;
+	u32 phy_index;
+
+	state = sci_port->state_machine.current_state_id;
+	if (state != SCIC_SDS_PORT_READY_SUBSTATE_OPERATIONAL) {
+		dev_warn(sciport_to_dev(sci_port),
+			 "%s: in wrong state: %d\n", __func__, state);
+		return SCI_FAILURE_INVALID_STATE;
+	}
+
+	/* Select a phy on which we can send the hard reset request. */
+	for (phy_index = 0; phy_index < SCI_MAX_PHYS && !selected_phy; phy_index++) {
+		selected_phy = sci_port->phy_table[phy_index];
+		if (selected_phy &&
+		    !scic_sds_port_active_phy(sci_port, selected_phy)) {
+			/*
+			 * We found a phy but it is not ready select
+			 * different phy
+			 */
+			selected_phy = NULL;
+		}
+	}
+
+	/* If we have a phy then go ahead and start the reset procedure */
+	if (!selected_phy)
+		return status;
+	status = scic_sds_phy_reset(selected_phy);
+
+	if (status != SCI_SUCCESS)
+		return status;
+
+	isci_timer_start(sci_port->timer_handle, timeout);
+	sci_port->not_ready_reason = SCIC_PORT_NOT_READY_HARD_RESET_REQUESTED;
+
+	port_state_machine_change(sci_port,
+				  SCI_BASE_PORT_STATE_RESETTING);
+	return SCI_SUCCESS;
+}
+
+/**
+ * scic_sds_port_add_phy() -
+ * @sci_port: This parameter specifies the port in which the phy will be added.
+ * @sci_phy: This parameter is the phy which is to be added to the port.
+ *
+ * This method will add a PHY to the selected port. This method returns an
+ * enum sci_status. SCI_SUCCESS the phy has been added to the port. Any other
+ * status is a failure to add the phy to the port.
+ */
+enum sci_status scic_sds_port_add_phy(struct scic_sds_port *sci_port,
+				      struct scic_sds_phy *sci_phy)
+{
+	enum sci_status status;
+	enum scic_sds_port_states state;
+
+	state = sci_port->state_machine.current_state_id;
+	switch (state) {
+	case SCI_BASE_PORT_STATE_STOPPED: {
+		struct sci_sas_address port_sas_address;
+
+		/* Read the port assigned SAS Address if there is one */
+		scic_sds_port_get_sas_address(sci_port, &port_sas_address);
+
+		if (port_sas_address.high != 0 && port_sas_address.low != 0) {
+			struct sci_sas_address phy_sas_address;
+
+			/* Make sure that the PHY SAS Address matches the SAS Address
+			 * for this port
+			 */
+			scic_sds_phy_get_sas_address(sci_phy, &phy_sas_address);
+
+			if (port_sas_address.high != phy_sas_address.high ||
+			    port_sas_address.low  != phy_sas_address.low)
+				return SCI_FAILURE_UNSUPPORTED_PORT_CONFIGURATION;
+		}
+		return scic_sds_port_set_phy(sci_port, sci_phy);
+	}
+	case SCIC_SDS_PORT_READY_SUBSTATE_WAITING:
+	case SCIC_SDS_PORT_READY_SUBSTATE_OPERATIONAL:
+		status = scic_sds_port_set_phy(sci_port, sci_phy);
+
+		if (status != SCI_SUCCESS)
+			return status;
+
+		scic_sds_port_general_link_up_handler(sci_port, sci_phy, true);
+		sci_port->not_ready_reason = SCIC_PORT_NOT_READY_RECONFIGURING;
+		port_state_machine_change(sci_port, SCIC_SDS_PORT_READY_SUBSTATE_CONFIGURING);
+
+		return status;
+	case SCIC_SDS_PORT_READY_SUBSTATE_CONFIGURING:
+		status = scic_sds_port_set_phy(sci_port, sci_phy);
+
+		if (status != SCI_SUCCESS)
+			return status;
+		scic_sds_port_general_link_up_handler(sci_port, sci_phy, true);
+
+		/* Re-enter the configuring state since this may be the last phy in
+		 * the port.
+		 */
+		port_state_machine_change(sci_port,
+					  SCIC_SDS_PORT_READY_SUBSTATE_CONFIGURING);
+		return SCI_SUCCESS;
+	default:
+		dev_warn(sciport_to_dev(sci_port),
+			 "%s: in wrong state: %d\n", __func__, state);
+		return SCI_FAILURE_INVALID_STATE;
+	}
+}
+
+/**
+ * scic_sds_port_remove_phy() -
+ * @sci_port: This parameter specifies the port in which the phy will be added.
+ * @sci_phy: This parameter is the phy which is to be added to the port.
+ *
+ * This method will remove the PHY from the selected PORT. This method returns
+ * an enum sci_status. SCI_SUCCESS the phy has been removed from the port. Any
+ * other status is a failure to add the phy to the port.
+ */
+enum sci_status scic_sds_port_remove_phy(struct scic_sds_port *sci_port,
+					 struct scic_sds_phy *sci_phy)
+{
+	enum sci_status status;
+	enum scic_sds_port_states state;
+
+	state = sci_port->state_machine.current_state_id;
+
+	switch (state) {
+	case SCI_BASE_PORT_STATE_STOPPED:
+		return scic_sds_port_clear_phy(sci_port, sci_phy);
+	case SCIC_SDS_PORT_READY_SUBSTATE_OPERATIONAL:
+		status = scic_sds_port_clear_phy(sci_port, sci_phy);
+		if (status != SCI_SUCCESS)
+			return status;
+
+		scic_sds_port_deactivate_phy(sci_port, sci_phy, true);
+		sci_port->not_ready_reason = SCIC_PORT_NOT_READY_RECONFIGURING;
+		port_state_machine_change(sci_port,
+					  SCIC_SDS_PORT_READY_SUBSTATE_CONFIGURING);
+		return SCI_SUCCESS;
+	case SCIC_SDS_PORT_READY_SUBSTATE_CONFIGURING:
+		status = scic_sds_port_clear_phy(sci_port, sci_phy);
+
+		if (status != SCI_SUCCESS)
+			return status;
+		scic_sds_port_deactivate_phy(sci_port, sci_phy, true);
+
+		/* Re-enter the configuring state since this may be the last phy in
+		 * the port
+		 */
+		port_state_machine_change(sci_port,
+					  SCIC_SDS_PORT_READY_SUBSTATE_CONFIGURING);
+
+		return SCI_SUCCESS;
+	default:
+		dev_warn(sciport_to_dev(sci_port),
+			 "%s: in wrong state: %d\n", __func__, state);
+		return SCI_FAILURE_INVALID_STATE;
+	}
+}
+
 static struct scic_sds_port_state_handler scic_sds_port_state_handler_table[] = {
 	[SCI_BASE_PORT_STATE_STOPPED] = {
-		.reset_handler  	= scic_sds_port_default_reset_handler,
-		.add_phy_handler 	= scic_sds_port_stopped_state_add_phy_handler,
-		.remove_phy_handler 	= scic_sds_port_stopped_state_remove_phy_handler,
 		.frame_handler  	= scic_sds_port_default_frame_handler,
 		.event_handler  	= scic_sds_port_default_event_handler,
 		.link_up_handler        = scic_sds_port_default_link_up_handler,
@@ -2057,9 +1933,6 @@ static struct scic_sds_port_state_handler scic_sds_port_state_handler_table[] =
 		.complete_io_handler 	= scic_sds_port_default_complete_io_handler
 	},
 	[SCI_BASE_PORT_STATE_STOPPING] = {
-		.reset_handler  	= scic_sds_port_default_reset_handler,
-		.add_phy_handler 	= scic_sds_port_default_add_phy_handler,
-		.remove_phy_handler 	= scic_sds_port_default_remove_phy_handler,
 		.frame_handler  	= scic_sds_port_default_frame_handler,
 		.event_handler  	= scic_sds_port_default_event_handler,
 		.link_up_handler        = scic_sds_port_default_link_up_handler,
@@ -2068,9 +1941,6 @@ static struct scic_sds_port_state_handler scic_sds_port_state_handler_table[] =
 		.complete_io_handler 	= scic_sds_port_stopping_state_complete_io_handler
 	},
 	[SCI_BASE_PORT_STATE_READY] = {
-		.reset_handler   	= scic_sds_port_default_reset_handler,
-		.add_phy_handler 	= scic_sds_port_default_add_phy_handler,
-		.remove_phy_handler 	= scic_sds_port_default_remove_phy_handler,
 		.frame_handler   	= scic_sds_port_default_frame_handler,
 		.event_handler   	= scic_sds_port_default_event_handler,
 		.link_up_handler 	= scic_sds_port_default_link_up_handler,
@@ -2079,9 +1949,6 @@ static struct scic_sds_port_state_handler scic_sds_port_state_handler_table[] =
 		.complete_io_handler 	= scic_sds_port_general_complete_io_handler
 	},
 	[SCIC_SDS_PORT_READY_SUBSTATE_WAITING] = {
-		.reset_handler		= scic_sds_port_default_reset_handler,
-		.add_phy_handler	= scic_sds_port_ready_substate_add_phy_handler,
-		.remove_phy_handler	= scic_sds_port_default_remove_phy_handler,
 		.frame_handler		= scic_sds_port_default_frame_handler,
 		.event_handler		= scic_sds_port_default_event_handler,
 		.link_up_handler	= scic_sds_port_ready_waiting_substate_link_up_handler,
@@ -2090,9 +1957,6 @@ static struct scic_sds_port_state_handler scic_sds_port_state_handler_table[] =
 		.complete_io_handler	= scic_sds_port_ready_substate_complete_io_handler,
 	},
 	[SCIC_SDS_PORT_READY_SUBSTATE_OPERATIONAL] = {
-		.reset_handler		= scic_sds_port_ready_operational_substate_reset_handler,
-		.add_phy_handler	= scic_sds_port_ready_substate_add_phy_handler,
-		.remove_phy_handler	= scic_sds_port_ready_substate_remove_phy_handler,
 		.frame_handler		= scic_sds_port_default_frame_handler,
 		.event_handler		= scic_sds_port_default_event_handler,
 		.link_up_handler	= scic_sds_port_ready_operational_substate_link_up_handler,
@@ -2101,9 +1965,6 @@ static struct scic_sds_port_state_handler scic_sds_port_state_handler_table[] =
 		.complete_io_handler	= scic_sds_port_ready_substate_complete_io_handler,
 	},
 	[SCIC_SDS_PORT_READY_SUBSTATE_CONFIGURING] = {
-		.reset_handler		= scic_sds_port_default_reset_handler,
-		.add_phy_handler	= scic_sds_port_ready_configuring_substate_add_phy_handler,
-		.remove_phy_handler	= scic_sds_port_ready_configuring_substate_remove_phy_handler,
 		.frame_handler		= scic_sds_port_default_frame_handler,
 		.event_handler		= scic_sds_port_default_event_handler,
 		.link_up_handler	= scic_sds_port_default_link_up_handler,
@@ -2112,9 +1973,6 @@ static struct scic_sds_port_state_handler scic_sds_port_state_handler_table[] =
 		.complete_io_handler	= scic_sds_port_ready_configuring_substate_complete_io_handler
 	},
 	[SCI_BASE_PORT_STATE_RESETTING] = {
-		.reset_handler		= scic_sds_port_default_reset_handler,
-		.add_phy_handler	= scic_sds_port_default_add_phy_handler,
-		.remove_phy_handler	= scic_sds_port_default_remove_phy_handler,
 		.frame_handler		= scic_sds_port_default_frame_handler,
 		.event_handler		= scic_sds_port_default_event_handler,
 		.link_up_handler	= scic_sds_port_reset_state_link_up_handler,
@@ -2123,9 +1981,6 @@ static struct scic_sds_port_state_handler scic_sds_port_state_handler_table[] =
 		.complete_io_handler	= scic_sds_port_general_complete_io_handler
 	},
 	[SCI_BASE_PORT_STATE_FAILED] = {
-		.reset_handler		= scic_sds_port_default_reset_handler,
-		.add_phy_handler	= scic_sds_port_default_add_phy_handler,
-		.remove_phy_handler	= scic_sds_port_default_remove_phy_handler,
 		.frame_handler		= scic_sds_port_default_frame_handler,
 		.event_handler		= scic_sds_port_default_event_handler,
 		.link_up_handler	= scic_sds_port_default_link_up_handler,

commit e6ec5afde9794f50e60788bd10760fcd0d609252
Author: Piotr Sawicki <piotr.sawicki@intel.com>
Date:   Wed May 11 23:52:37 2011 +0000

    isci: remove port destruct handler
    
    The handler was never used.
    
    Signed-off-by: Piotr Sawicki <piotr.sawicki@intel.com>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/drivers/scsi/isci/port.c b/drivers/scsi/isci/port.c
index 62e9785acfb0..1a058a27ebc1 100644
--- a/drivers/scsi/isci/port.c
+++ b/drivers/scsi/isci/port.c
@@ -885,13 +885,6 @@ static void port_state_machine_change(struct scic_sds_port *sci_port,
 	sci_port->ready_exit = false;
 }
 
-static void port_state_machine_stop(struct scic_sds_port *sci_port)
-{
-	sci_port->ready_exit = true;
-	sci_base_state_machine_stop(&sci_port->state_machine);
-	sci_port->ready_exit = false;
-}
-
 /**
  * scic_sds_port_general_link_up_handler - phy can be assigned to port?
  * @sci_port: scic_sds_port object for which has a phy that has gone link up.
@@ -1468,12 +1461,6 @@ static enum sci_status default_port_handler(struct scic_sds_port *sci_port,
 	return SCI_FAILURE_INVALID_STATE;
 }
 
-static enum sci_status
-scic_sds_port_default_destruct_handler(struct scic_sds_port *sci_port)
-{
-	return default_port_handler(sci_port, __func__);
-}
-
 static enum sci_status
 scic_sds_port_default_reset_handler(struct scic_sds_port *sci_port,
 				    u32 timeout)
@@ -1830,19 +1817,6 @@ static enum sci_status scic_sds_port_general_complete_io_handler(
 	return SCI_SUCCESS;
 }
 
-/*
- * This method takes the struct scic_sds_port that is in a stopped state and handles
- * the destruct request.  The stopped state is the only state in which the
- * struct scic_sds_port can be destroyed.  This function causes the port object to
- * transition to the SCI_BASE_PORT_STATE_FINAL. enum sci_status SCI_SUCCESS
- */
-static enum sci_status scic_sds_port_stopped_state_destruct_handler(struct scic_sds_port *port)
-{
-	port_state_machine_stop(port);
-
-	return SCI_SUCCESS;
-}
-
 /*
  * This method takes the struct scic_sds_port that is in a stopped state and handles
  * the add phy request.  In MPC mode the only time a phy can be added to a port
@@ -2072,7 +2046,6 @@ enum sci_status scic_sds_port_stop(struct scic_sds_port *sci_port)
 
 static struct scic_sds_port_state_handler scic_sds_port_state_handler_table[] = {
 	[SCI_BASE_PORT_STATE_STOPPED] = {
-		.destruct_handler 	= scic_sds_port_stopped_state_destruct_handler,
 		.reset_handler  	= scic_sds_port_default_reset_handler,
 		.add_phy_handler 	= scic_sds_port_stopped_state_add_phy_handler,
 		.remove_phy_handler 	= scic_sds_port_stopped_state_remove_phy_handler,
@@ -2084,7 +2057,6 @@ static struct scic_sds_port_state_handler scic_sds_port_state_handler_table[] =
 		.complete_io_handler 	= scic_sds_port_default_complete_io_handler
 	},
 	[SCI_BASE_PORT_STATE_STOPPING] = {
-		.destruct_handler 	= scic_sds_port_default_destruct_handler,
 		.reset_handler  	= scic_sds_port_default_reset_handler,
 		.add_phy_handler 	= scic_sds_port_default_add_phy_handler,
 		.remove_phy_handler 	= scic_sds_port_default_remove_phy_handler,
@@ -2096,7 +2068,6 @@ static struct scic_sds_port_state_handler scic_sds_port_state_handler_table[] =
 		.complete_io_handler 	= scic_sds_port_stopping_state_complete_io_handler
 	},
 	[SCI_BASE_PORT_STATE_READY] = {
-		.destruct_handler 	= scic_sds_port_default_destruct_handler,
 		.reset_handler   	= scic_sds_port_default_reset_handler,
 		.add_phy_handler 	= scic_sds_port_default_add_phy_handler,
 		.remove_phy_handler 	= scic_sds_port_default_remove_phy_handler,
@@ -2108,7 +2079,6 @@ static struct scic_sds_port_state_handler scic_sds_port_state_handler_table[] =
 		.complete_io_handler 	= scic_sds_port_general_complete_io_handler
 	},
 	[SCIC_SDS_PORT_READY_SUBSTATE_WAITING] = {
-		.destruct_handler	= scic_sds_port_default_destruct_handler,
 		.reset_handler		= scic_sds_port_default_reset_handler,
 		.add_phy_handler	= scic_sds_port_ready_substate_add_phy_handler,
 		.remove_phy_handler	= scic_sds_port_default_remove_phy_handler,
@@ -2120,7 +2090,6 @@ static struct scic_sds_port_state_handler scic_sds_port_state_handler_table[] =
 		.complete_io_handler	= scic_sds_port_ready_substate_complete_io_handler,
 	},
 	[SCIC_SDS_PORT_READY_SUBSTATE_OPERATIONAL] = {
-		.destruct_handler	= scic_sds_port_default_destruct_handler,
 		.reset_handler		= scic_sds_port_ready_operational_substate_reset_handler,
 		.add_phy_handler	= scic_sds_port_ready_substate_add_phy_handler,
 		.remove_phy_handler	= scic_sds_port_ready_substate_remove_phy_handler,
@@ -2132,7 +2101,6 @@ static struct scic_sds_port_state_handler scic_sds_port_state_handler_table[] =
 		.complete_io_handler	= scic_sds_port_ready_substate_complete_io_handler,
 	},
 	[SCIC_SDS_PORT_READY_SUBSTATE_CONFIGURING] = {
-		.destruct_handler	= scic_sds_port_default_destruct_handler,
 		.reset_handler		= scic_sds_port_default_reset_handler,
 		.add_phy_handler	= scic_sds_port_ready_configuring_substate_add_phy_handler,
 		.remove_phy_handler	= scic_sds_port_ready_configuring_substate_remove_phy_handler,
@@ -2144,7 +2112,6 @@ static struct scic_sds_port_state_handler scic_sds_port_state_handler_table[] =
 		.complete_io_handler	= scic_sds_port_ready_configuring_substate_complete_io_handler
 	},
 	[SCI_BASE_PORT_STATE_RESETTING] = {
-		.destruct_handler	= scic_sds_port_default_destruct_handler,
 		.reset_handler		= scic_sds_port_default_reset_handler,
 		.add_phy_handler	= scic_sds_port_default_add_phy_handler,
 		.remove_phy_handler	= scic_sds_port_default_remove_phy_handler,
@@ -2156,7 +2123,6 @@ static struct scic_sds_port_state_handler scic_sds_port_state_handler_table[] =
 		.complete_io_handler	= scic_sds_port_general_complete_io_handler
 	},
 	[SCI_BASE_PORT_STATE_FAILED] = {
-		.destruct_handler	= scic_sds_port_default_destruct_handler,
 		.reset_handler		= scic_sds_port_default_reset_handler,
 		.add_phy_handler	= scic_sds_port_default_add_phy_handler,
 		.remove_phy_handler	= scic_sds_port_default_remove_phy_handler,

commit 8bc80d303063d9540493be623df1c9a8dee9ccb8
Author: Piotr Sawicki <piotr.sawicki@intel.com>
Date:   Wed May 11 23:52:31 2011 +0000

    isci: unify port stop handlers
    
    Implement the stop handlers directly in scic_sds_port_stop()
    
    Reported-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Piotr Sawicki <piotr.sawicki@intel.com>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/drivers/scsi/isci/port.c b/drivers/scsi/isci/port.c
index 64559e8e568d..62e9785acfb0 100644
--- a/drivers/scsi/isci/port.c
+++ b/drivers/scsi/isci/port.c
@@ -1178,17 +1178,6 @@ static void scic_port_enable_broadcast_change_notification(struct scic_sds_port
  * *  READY SUBSTATE HANDLERS
  * **************************************************************************** */
 
-/*
- * This method is the general ready state stop handler for the struct scic_sds_port
- * object.  This function will transition the ready substate machine to its
- * final state. enum sci_status SCI_SUCCESS
- */
-static enum sci_status scic_sds_port_ready_substate_stop_handler(struct scic_sds_port *sci_port)
-{
-	port_state_machine_change(sci_port, SCI_BASE_PORT_STATE_STOPPING);
-	return SCI_SUCCESS;
-}
-
 /*
  * This method is the general ready substate complete io handler for the
  * struct scic_sds_port object.  This function decrments the outstanding request count
@@ -1479,12 +1468,6 @@ static enum sci_status default_port_handler(struct scic_sds_port *sci_port,
 	return SCI_FAILURE_INVALID_STATE;
 }
 
-static enum sci_status
-scic_sds_port_default_stop_handler(struct scic_sds_port *sci_port)
-{
-	return default_port_handler(sci_port, __func__);
-}
-
 static enum sci_status
 scic_sds_port_default_destruct_handler(struct scic_sds_port *sci_port)
 {
@@ -1847,18 +1830,6 @@ static enum sci_status scic_sds_port_general_complete_io_handler(
 	return SCI_SUCCESS;
 }
 
-/*
- * This method takes the struct scic_sds_port that is in a stopped state and handles a
- * stop request.  This function takes no action. enum sci_status SCI_SUCCESS the
- * stop request is successful as the struct scic_sds_port object is already stopped.
- */
-static enum sci_status scic_sds_port_stopped_state_stop_handler(
-	struct scic_sds_port *port)
-{
-	/* We are already stopped so there is nothing to do here */
-	return SCI_SUCCESS;
-}
-
 /*
  * This method takes the struct scic_sds_port that is in a stopped state and handles
  * the destruct request.  The stopped state is the only state in which the
@@ -1960,22 +1931,6 @@ static enum sci_status scic_sds_port_stopping_state_complete_io_handler(
  * *  RESETTING STATE HANDLERS
  * **************************************************************************** */
 
-/**
- *
- * @port: This is the port object which is being requested to stop.
- *
- * This method will stop a failed port.  This causes a transition to the
- * stopping state. enum sci_status SCI_SUCCESS
- */
-static enum sci_status scic_sds_port_reset_state_stop_handler(
-	struct scic_sds_port *port)
-{
-	port_state_machine_change(port,
-				  SCI_BASE_PORT_STATE_STOPPING);
-
-	return SCI_SUCCESS;
-}
-
 /*
  * This method will transition a failed port to its ready state.  The port
  * failed because a hard reset request timed out but at some time later one or
@@ -2093,9 +2048,30 @@ enum sci_status scic_sds_port_start(struct scic_sds_port *sci_port)
 	return status;
 }
 
+enum sci_status scic_sds_port_stop(struct scic_sds_port *sci_port)
+{
+	enum scic_sds_port_states state;
+
+	state = sci_port->state_machine.current_state_id;
+	switch (state) {
+	case SCI_BASE_PORT_STATE_STOPPED:
+		return SCI_SUCCESS;
+	case SCIC_SDS_PORT_READY_SUBSTATE_WAITING:
+	case SCIC_SDS_PORT_READY_SUBSTATE_OPERATIONAL:
+	case SCIC_SDS_PORT_READY_SUBSTATE_CONFIGURING:
+	case SCI_BASE_PORT_STATE_RESETTING:
+		port_state_machine_change(sci_port,
+					  SCI_BASE_PORT_STATE_STOPPING);
+		return SCI_SUCCESS;
+	default:
+		dev_warn(sciport_to_dev(sci_port),
+			 "%s: in wrong state: %d\n", __func__, state);
+		return SCI_FAILURE_INVALID_STATE;
+	}
+}
+
 static struct scic_sds_port_state_handler scic_sds_port_state_handler_table[] = {
 	[SCI_BASE_PORT_STATE_STOPPED] = {
-		.stop_handler   	= scic_sds_port_stopped_state_stop_handler,
 		.destruct_handler 	= scic_sds_port_stopped_state_destruct_handler,
 		.reset_handler  	= scic_sds_port_default_reset_handler,
 		.add_phy_handler 	= scic_sds_port_stopped_state_add_phy_handler,
@@ -2108,7 +2084,6 @@ static struct scic_sds_port_state_handler scic_sds_port_state_handler_table[] =
 		.complete_io_handler 	= scic_sds_port_default_complete_io_handler
 	},
 	[SCI_BASE_PORT_STATE_STOPPING] = {
-		.stop_handler   	= scic_sds_port_default_stop_handler,
 		.destruct_handler 	= scic_sds_port_default_destruct_handler,
 		.reset_handler  	= scic_sds_port_default_reset_handler,
 		.add_phy_handler 	= scic_sds_port_default_add_phy_handler,
@@ -2121,7 +2096,6 @@ static struct scic_sds_port_state_handler scic_sds_port_state_handler_table[] =
 		.complete_io_handler 	= scic_sds_port_stopping_state_complete_io_handler
 	},
 	[SCI_BASE_PORT_STATE_READY] = {
-		.stop_handler    	= scic_sds_port_default_stop_handler,
 		.destruct_handler 	= scic_sds_port_default_destruct_handler,
 		.reset_handler   	= scic_sds_port_default_reset_handler,
 		.add_phy_handler 	= scic_sds_port_default_add_phy_handler,
@@ -2134,7 +2108,6 @@ static struct scic_sds_port_state_handler scic_sds_port_state_handler_table[] =
 		.complete_io_handler 	= scic_sds_port_general_complete_io_handler
 	},
 	[SCIC_SDS_PORT_READY_SUBSTATE_WAITING] = {
-		.stop_handler		= scic_sds_port_ready_substate_stop_handler,
 		.destruct_handler	= scic_sds_port_default_destruct_handler,
 		.reset_handler		= scic_sds_port_default_reset_handler,
 		.add_phy_handler	= scic_sds_port_ready_substate_add_phy_handler,
@@ -2147,7 +2120,6 @@ static struct scic_sds_port_state_handler scic_sds_port_state_handler_table[] =
 		.complete_io_handler	= scic_sds_port_ready_substate_complete_io_handler,
 	},
 	[SCIC_SDS_PORT_READY_SUBSTATE_OPERATIONAL] = {
-		.stop_handler		= scic_sds_port_ready_substate_stop_handler,
 		.destruct_handler	= scic_sds_port_default_destruct_handler,
 		.reset_handler		= scic_sds_port_ready_operational_substate_reset_handler,
 		.add_phy_handler	= scic_sds_port_ready_substate_add_phy_handler,
@@ -2160,7 +2132,6 @@ static struct scic_sds_port_state_handler scic_sds_port_state_handler_table[] =
 		.complete_io_handler	= scic_sds_port_ready_substate_complete_io_handler,
 	},
 	[SCIC_SDS_PORT_READY_SUBSTATE_CONFIGURING] = {
-		.stop_handler		= scic_sds_port_ready_substate_stop_handler,
 		.destruct_handler	= scic_sds_port_default_destruct_handler,
 		.reset_handler		= scic_sds_port_default_reset_handler,
 		.add_phy_handler	= scic_sds_port_ready_configuring_substate_add_phy_handler,
@@ -2173,7 +2144,6 @@ static struct scic_sds_port_state_handler scic_sds_port_state_handler_table[] =
 		.complete_io_handler	= scic_sds_port_ready_configuring_substate_complete_io_handler
 	},
 	[SCI_BASE_PORT_STATE_RESETTING] = {
-		.stop_handler		= scic_sds_port_reset_state_stop_handler,
 		.destruct_handler	= scic_sds_port_default_destruct_handler,
 		.reset_handler		= scic_sds_port_default_reset_handler,
 		.add_phy_handler	= scic_sds_port_default_add_phy_handler,
@@ -2186,7 +2156,6 @@ static struct scic_sds_port_state_handler scic_sds_port_state_handler_table[] =
 		.complete_io_handler	= scic_sds_port_general_complete_io_handler
 	},
 	[SCI_BASE_PORT_STATE_FAILED] = {
-		.stop_handler		= scic_sds_port_default_stop_handler,
 		.destruct_handler	= scic_sds_port_default_destruct_handler,
 		.reset_handler		= scic_sds_port_default_reset_handler,
 		.add_phy_handler	= scic_sds_port_default_add_phy_handler,

commit d76f71d988ef48384593ad97ebc762d9257d96a8
Author: Piotr Sawicki <piotr.sawicki@intel.com>
Date:   Wed May 11 23:52:26 2011 +0000

    isci: remove port start handler
    
    remove the handler from the port state handler table and implement the
    logic directly in scic_sds_port_start().
    
    Signed-off-by: Piotr Sawicki <piotr.sawicki@intel.com>
    [remove a level of indirection]
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/drivers/scsi/isci/port.c b/drivers/scsi/isci/port.c
index 2ea3d0fe091d..64559e8e568d 100644
--- a/drivers/scsi/isci/port.c
+++ b/drivers/scsi/isci/port.c
@@ -1479,12 +1479,6 @@ static enum sci_status default_port_handler(struct scic_sds_port *sci_port,
 	return SCI_FAILURE_INVALID_STATE;
 }
 
-static enum sci_status
-scic_sds_port_default_start_handler(struct scic_sds_port *sci_port)
-{
-	return default_port_handler(sci_port, __func__);
-}
-
 static enum sci_status
 scic_sds_port_default_stop_handler(struct scic_sds_port *sci_port)
 {
@@ -1853,95 +1847,6 @@ static enum sci_status scic_sds_port_general_complete_io_handler(
 	return SCI_SUCCESS;
 }
 
-/**
- * scic_sds_port_stopped_state_start_handler() - stop a port from "started"
- *
- * @port: This is the struct scic_sds_port object which is cast into a
- * struct scic_sds_port object.
- *
- * This function takes the struct scic_sds_port from a stopped state and
- * attempts to start it.  To start a port it must have no assiged devices and
- * it must have at least one phy assigned to it.  If those conditions are
- * met then the port can transition to the ready state.
- * enum sci_status
- * SCI_FAILURE_UNSUPPORTED_PORT_CONFIGURATION
- * This struct scic_sds_port object could not be started because the port
- * configuration is not valid.
- * SCI_SUCCESS
- * the start request is successful and the struct scic_sds_port object
- * has transitioned to the SCI_BASE_PORT_STATE_READY.
- */
-static enum sci_status
-scic_sds_port_stopped_state_start_handler(struct scic_sds_port *sci_port)
-{
-	struct scic_sds_controller *scic = sci_port->owning_controller;
-	struct isci_host *ihost = scic_to_ihost(scic);
-	enum sci_status status = SCI_SUCCESS;
-	u32 phy_mask;
-
-	if (sci_port->assigned_device_count > 0) {
-		/*
-		 * @todo This is a start failure operation because
-		 * there are still devices assigned to this port.
-		 * There must be no devices assigned to a port on a
-		 * start operation.
-		 */
-		return SCI_FAILURE_UNSUPPORTED_PORT_CONFIGURATION;
-	}
-
-	sci_port->timer_handle =
-		isci_timer_create(ihost,
-				  sci_port,
-				  scic_sds_port_timeout_handler);
-
-	if (!sci_port->timer_handle)
-		return SCI_FAILURE_INSUFFICIENT_RESOURCES;
-
-	if (sci_port->reserved_rni == SCU_DUMMY_INDEX) {
-		u16 rni = scic_sds_remote_node_table_allocate_remote_node(
-				&scic->available_remote_nodes, 1);
-
-		if (rni != SCU_DUMMY_INDEX)
-			scic_sds_port_construct_dummy_rnc(sci_port, rni);
-		else
-			status = SCI_FAILURE_INSUFFICIENT_RESOURCES;
-		sci_port->reserved_rni = rni;
-	}
-
-	if (sci_port->reserved_tci == SCU_DUMMY_INDEX) {
-		/* Allocate a TCI and remove the sequence nibble */
-		u16 tci = scic_controller_allocate_io_tag(scic);
-
-		if (tci != SCU_DUMMY_INDEX)
-			scic_sds_port_construct_dummy_task(sci_port, tci);
-		else
-			status = SCI_FAILURE_INSUFFICIENT_RESOURCES;
-		sci_port->reserved_tci = tci;
-	}
-
-	if (status == SCI_SUCCESS) {
-		phy_mask = scic_sds_port_get_phys(sci_port);
-
-		/*
-		 * There are one or more phys assigned to this port.  Make sure
-		 * the port's phy mask is in fact legal and supported by the
-		 * silicon.
-		 */
-		if (scic_sds_port_is_phy_mask_valid(sci_port, phy_mask) == true) {
-			port_state_machine_change(sci_port,
-						  SCI_BASE_PORT_STATE_READY);
-
-			return SCI_SUCCESS;
-		} else
-			status = SCI_FAILURE;
-	}
-
-	if (status != SCI_SUCCESS)
-		scic_sds_port_destroy_dummy_resources(sci_port);
-
-	return status;
-}
-
 /*
  * This method takes the struct scic_sds_port that is in a stopped state and handles a
  * stop request.  This function takes no action. enum sci_status SCI_SUCCESS the
@@ -2111,9 +2016,85 @@ static void scic_sds_port_reset_state_link_down_handler(
 	scic_sds_port_deactivate_phy(port, phy, false);
 }
 
+enum sci_status scic_sds_port_start(struct scic_sds_port *sci_port)
+{
+	struct scic_sds_controller *scic = sci_port->owning_controller;
+	struct isci_host *ihost = scic_to_ihost(scic);
+	enum sci_status status = SCI_SUCCESS;
+	enum scic_sds_port_states state;
+	u32 phy_mask;
+
+	state = sci_port->state_machine.current_state_id;
+	if (state != SCI_BASE_PORT_STATE_STOPPED) {
+		dev_warn(sciport_to_dev(sci_port),
+			 "%s: in wrong state: %d\n", __func__, state);
+		return SCI_FAILURE_INVALID_STATE;
+	}
+
+	if (sci_port->assigned_device_count > 0) {
+		/* TODO This is a start failure operation because
+		 * there are still devices assigned to this port.
+		 * There must be no devices assigned to a port on a
+		 * start operation.
+		 */
+		return SCI_FAILURE_UNSUPPORTED_PORT_CONFIGURATION;
+	}
+
+	sci_port->timer_handle =
+		isci_timer_create(ihost,
+				  sci_port,
+				  scic_sds_port_timeout_handler);
+
+	if (!sci_port->timer_handle)
+		return SCI_FAILURE_INSUFFICIENT_RESOURCES;
+
+	if (sci_port->reserved_rni == SCU_DUMMY_INDEX) {
+		u16 rni = scic_sds_remote_node_table_allocate_remote_node(
+				&scic->available_remote_nodes, 1);
+
+		if (rni != SCU_DUMMY_INDEX)
+			scic_sds_port_construct_dummy_rnc(sci_port, rni);
+		else
+			status = SCI_FAILURE_INSUFFICIENT_RESOURCES;
+		sci_port->reserved_rni = rni;
+	}
+
+	if (sci_port->reserved_tci == SCU_DUMMY_INDEX) {
+		/* Allocate a TCI and remove the sequence nibble */
+		u16 tci = scic_controller_allocate_io_tag(scic);
+
+		if (tci != SCU_DUMMY_INDEX)
+			scic_sds_port_construct_dummy_task(sci_port, tci);
+		else
+			status = SCI_FAILURE_INSUFFICIENT_RESOURCES;
+		sci_port->reserved_tci = tci;
+	}
+
+	if (status == SCI_SUCCESS) {
+		phy_mask = scic_sds_port_get_phys(sci_port);
+
+		/*
+		 * There are one or more phys assigned to this port.  Make sure
+		 * the port's phy mask is in fact legal and supported by the
+		 * silicon.
+		 */
+		if (scic_sds_port_is_phy_mask_valid(sci_port, phy_mask) == true) {
+			port_state_machine_change(sci_port,
+						  SCI_BASE_PORT_STATE_READY);
+
+			return SCI_SUCCESS;
+		}
+		status = SCI_FAILURE;
+	}
+
+	if (status != SCI_SUCCESS)
+		scic_sds_port_destroy_dummy_resources(sci_port);
+
+	return status;
+}
+
 static struct scic_sds_port_state_handler scic_sds_port_state_handler_table[] = {
 	[SCI_BASE_PORT_STATE_STOPPED] = {
-		.start_handler  	= scic_sds_port_stopped_state_start_handler,
 		.stop_handler   	= scic_sds_port_stopped_state_stop_handler,
 		.destruct_handler 	= scic_sds_port_stopped_state_destruct_handler,
 		.reset_handler  	= scic_sds_port_default_reset_handler,
@@ -2127,7 +2108,6 @@ static struct scic_sds_port_state_handler scic_sds_port_state_handler_table[] =
 		.complete_io_handler 	= scic_sds_port_default_complete_io_handler
 	},
 	[SCI_BASE_PORT_STATE_STOPPING] = {
-		.start_handler  	= scic_sds_port_default_start_handler,
 		.stop_handler   	= scic_sds_port_default_stop_handler,
 		.destruct_handler 	= scic_sds_port_default_destruct_handler,
 		.reset_handler  	= scic_sds_port_default_reset_handler,
@@ -2141,7 +2121,6 @@ static struct scic_sds_port_state_handler scic_sds_port_state_handler_table[] =
 		.complete_io_handler 	= scic_sds_port_stopping_state_complete_io_handler
 	},
 	[SCI_BASE_PORT_STATE_READY] = {
-		.start_handler		= scic_sds_port_default_start_handler,
 		.stop_handler    	= scic_sds_port_default_stop_handler,
 		.destruct_handler 	= scic_sds_port_default_destruct_handler,
 		.reset_handler   	= scic_sds_port_default_reset_handler,
@@ -2155,7 +2134,6 @@ static struct scic_sds_port_state_handler scic_sds_port_state_handler_table[] =
 		.complete_io_handler 	= scic_sds_port_general_complete_io_handler
 	},
 	[SCIC_SDS_PORT_READY_SUBSTATE_WAITING] = {
-		.start_handler		= scic_sds_port_default_start_handler,
 		.stop_handler		= scic_sds_port_ready_substate_stop_handler,
 		.destruct_handler	= scic_sds_port_default_destruct_handler,
 		.reset_handler		= scic_sds_port_default_reset_handler,
@@ -2169,7 +2147,6 @@ static struct scic_sds_port_state_handler scic_sds_port_state_handler_table[] =
 		.complete_io_handler	= scic_sds_port_ready_substate_complete_io_handler,
 	},
 	[SCIC_SDS_PORT_READY_SUBSTATE_OPERATIONAL] = {
-		.start_handler		= scic_sds_port_default_start_handler,
 		.stop_handler		= scic_sds_port_ready_substate_stop_handler,
 		.destruct_handler	= scic_sds_port_default_destruct_handler,
 		.reset_handler		= scic_sds_port_ready_operational_substate_reset_handler,
@@ -2183,7 +2160,6 @@ static struct scic_sds_port_state_handler scic_sds_port_state_handler_table[] =
 		.complete_io_handler	= scic_sds_port_ready_substate_complete_io_handler,
 	},
 	[SCIC_SDS_PORT_READY_SUBSTATE_CONFIGURING] = {
-		.start_handler		= scic_sds_port_default_start_handler,
 		.stop_handler		= scic_sds_port_ready_substate_stop_handler,
 		.destruct_handler	= scic_sds_port_default_destruct_handler,
 		.reset_handler		= scic_sds_port_default_reset_handler,
@@ -2197,7 +2173,6 @@ static struct scic_sds_port_state_handler scic_sds_port_state_handler_table[] =
 		.complete_io_handler	= scic_sds_port_ready_configuring_substate_complete_io_handler
 	},
 	[SCI_BASE_PORT_STATE_RESETTING] = {
-		.start_handler		= scic_sds_port_default_start_handler,
 		.stop_handler		= scic_sds_port_reset_state_stop_handler,
 		.destruct_handler	= scic_sds_port_default_destruct_handler,
 		.reset_handler		= scic_sds_port_default_reset_handler,
@@ -2211,7 +2186,6 @@ static struct scic_sds_port_state_handler scic_sds_port_state_handler_table[] =
 		.complete_io_handler	= scic_sds_port_general_complete_io_handler
 	},
 	[SCI_BASE_PORT_STATE_FAILED] = {
-		.start_handler		= scic_sds_port_default_start_handler,
 		.stop_handler		= scic_sds_port_default_stop_handler,
 		.destruct_handler	= scic_sds_port_default_destruct_handler,
 		.reset_handler		= scic_sds_port_default_reset_handler,

commit e91f41ef809a2d1b8cdba52ac380aecd706c93dd
Author: Piotr Sawicki <piotr.sawicki@intel.com>
Date:   Wed May 11 23:52:21 2011 +0000

    isci: merge port ready substates into primary state machine
    
    This conversion was complicated by the fact that the ready state exit routine
    took unconditional action beyond just stopping the substate machine (like in
    previous conversions).  In order to ensure identical behaviour every state
    transition needs to be instrumented to catch ready-->!ready transitions and
    execute scic_sds_port_invalidate_dummy_remote_node()
    
    Reported-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Piotr Sawicki <piotr.sawicki@intel.com>
    [fix ready state exit handling]
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/drivers/scsi/isci/port.c b/drivers/scsi/isci/port.c
index e386066825b2..2ea3d0fe091d 100644
--- a/drivers/scsi/isci/port.c
+++ b/drivers/scsi/isci/port.c
@@ -61,6 +61,8 @@
 #define SCIC_SDS_PORT_HARD_RESET_TIMEOUT  (1000)
 #define SCU_DUMMY_INDEX    (0xFFFF)
 
+static struct scic_sds_port_state_handler scic_sds_port_state_handler_table[];
+
 static void isci_port_change_state(struct isci_port *iport, enum isci_status status)
 {
 	unsigned long flags;
@@ -856,6 +858,40 @@ static void scic_sds_port_invalid_link_up(struct scic_sds_port *sci_port,
 	}
 }
 
+static bool is_port_ready_state(enum scic_sds_port_states state)
+{
+	switch (state) {
+	case SCI_BASE_PORT_STATE_READY:
+	case SCIC_SDS_PORT_READY_SUBSTATE_WAITING:
+	case SCIC_SDS_PORT_READY_SUBSTATE_OPERATIONAL:
+	case SCIC_SDS_PORT_READY_SUBSTATE_CONFIGURING:
+		return true;
+	default:
+		return false;
+	}
+}
+
+/* flag dummy rnc hanling when exiting a ready state */
+static void port_state_machine_change(struct scic_sds_port *sci_port,
+				      enum scic_sds_port_states state)
+{
+	struct sci_base_state_machine *sm = &sci_port->state_machine;
+	enum scic_sds_port_states old_state = sm->current_state_id;
+
+	if (is_port_ready_state(old_state) && !is_port_ready_state(state))
+		sci_port->ready_exit = true;
+
+	sci_base_state_machine_change_state(sm, state);
+	sci_port->ready_exit = false;
+}
+
+static void port_state_machine_stop(struct scic_sds_port *sci_port)
+{
+	sci_port->ready_exit = true;
+	sci_base_state_machine_stop(&sci_port->state_machine);
+	sci_port->ready_exit = false;
+}
+
 /**
  * scic_sds_port_general_link_up_handler - phy can be assigned to port?
  * @sci_port: scic_sds_port object for which has a phy that has gone link up.
@@ -891,7 +927,7 @@ static void scic_sds_port_general_link_up_handler(struct scic_sds_port *sci_port
 
 		scic_sds_port_activate_phy(sci_port, sci_phy, do_notify_user);
 		if (sm->current_state_id == SCI_BASE_PORT_STATE_RESETTING)
-			sci_base_state_machine_change_state(sm, SCI_BASE_PORT_STATE_READY);
+			port_state_machine_change(sci_port, SCI_BASE_PORT_STATE_READY);
 	} else
 		scic_sds_port_invalid_link_up(sci_port, sci_phy);
 }
@@ -1025,46 +1061,33 @@ static void scic_sds_port_timeout_handler(void *port)
 	struct scic_sds_port *sci_port = port;
 	u32 current_state;
 
-	current_state = sci_base_state_machine_get_state(
-		&sci_port->state_machine);
+	current_state = sci_base_state_machine_get_state(&sci_port->state_machine);
 
 	if (current_state == SCI_BASE_PORT_STATE_RESETTING) {
-		/*
-		 * if the port is still in the resetting state then the
-		 * timeout fired before the reset completed.
+		/* if the port is still in the resetting state then the timeout
+		 * fired before the reset completed.
 		 */
-		sci_base_state_machine_change_state(
-			&sci_port->state_machine,
-			SCI_BASE_PORT_STATE_FAILED);
+		port_state_machine_change(sci_port, SCI_BASE_PORT_STATE_FAILED);
 	} else if (current_state == SCI_BASE_PORT_STATE_STOPPED) {
-		/*
-		 * if the port is stopped then the start request failed
-		 * In this case stay in the stopped state.
+		/* if the port is stopped then the start request failed In this
+		 * case stay in the stopped state.
 		 */
 		dev_err(sciport_to_dev(sci_port),
 			"%s: SCIC Port 0x%p failed to stop before tiemout.\n",
 			__func__,
 			sci_port);
 	} else if (current_state == SCI_BASE_PORT_STATE_STOPPING) {
-		/*
-		 * if the port is still stopping then the stop has not
-		 * completed
-		 */
-		isci_port_stop_complete(
-				scic_sds_port_get_controller(sci_port),
-				sci_port,
-				SCI_FAILURE_TIMEOUT);
+		/* if the port is still stopping then the stop has not completed */
+		isci_port_stop_complete(sci_port->owning_controller,
+					sci_port,
+					SCI_FAILURE_TIMEOUT);
 	} else {
-		/*
-		 * The port is in the ready state and we have a timer
+		/* The port is in the ready state and we have a timer
 		 * reporting a timeout this should not happen.
 		 */
 		dev_err(sciport_to_dev(sci_port),
 			"%s: SCIC Port 0x%p is processing a timeout operation "
-			"in state %d.\n",
-			__func__,
-			sci_port,
-			current_state);
+			"in state %d.\n", __func__, sci_port, current_state);
 	}
 }
 
@@ -1160,14 +1183,9 @@ static void scic_port_enable_broadcast_change_notification(struct scic_sds_port
  * object.  This function will transition the ready substate machine to its
  * final state. enum sci_status SCI_SUCCESS
  */
-static enum sci_status scic_sds_port_ready_substate_stop_handler(
-	struct scic_sds_port *port)
+static enum sci_status scic_sds_port_ready_substate_stop_handler(struct scic_sds_port *sci_port)
 {
-	sci_base_state_machine_change_state(
-		&port->state_machine,
-		SCI_BASE_PORT_STATE_STOPPING
-		);
-
+	port_state_machine_change(sci_port, SCI_BASE_PORT_STATE_STOPPING);
 	return SCI_SUCCESS;
 }
 
@@ -1186,48 +1204,40 @@ static enum sci_status scic_sds_port_ready_substate_complete_io_handler(
 	return SCI_SUCCESS;
 }
 
-static enum sci_status scic_sds_port_ready_substate_add_phy_handler(
-	struct scic_sds_port *port,
-	struct scic_sds_phy *phy)
+static enum sci_status scic_sds_port_ready_substate_add_phy_handler(struct scic_sds_port *sci_port,
+								    struct scic_sds_phy *sci_phy)
 {
 	enum sci_status status;
 
-	status = scic_sds_port_set_phy(port, phy);
+	status = scic_sds_port_set_phy(sci_port, sci_phy);
 
-	if (status == SCI_SUCCESS) {
-		scic_sds_port_general_link_up_handler(port, phy, true);
-
-		port->not_ready_reason = SCIC_PORT_NOT_READY_RECONFIGURING;
+	if (status != SCI_SUCCESS)
+		return status;
 
-		sci_base_state_machine_change_state(
-			&port->ready_substate_machine,
-			SCIC_SDS_PORT_READY_SUBSTATE_CONFIGURING
-			);
-	}
+	scic_sds_port_general_link_up_handler(sci_port, sci_phy, true);
+	sci_port->not_ready_reason = SCIC_PORT_NOT_READY_RECONFIGURING;
+	port_state_machine_change(sci_port, SCIC_SDS_PORT_READY_SUBSTATE_CONFIGURING);
 
 	return status;
 }
 
 
-static enum sci_status scic_sds_port_ready_substate_remove_phy_handler(
-	struct scic_sds_port *port,
-	struct scic_sds_phy *phy)
+static enum sci_status scic_sds_port_ready_substate_remove_phy_handler(struct scic_sds_port *port,
+								       struct scic_sds_phy *phy)
 {
 	enum sci_status status;
 
 	status = scic_sds_port_clear_phy(port, phy);
 
-	if (status == SCI_SUCCESS) {
-		scic_sds_port_deactivate_phy(port, phy, true);
+	if (status != SCI_SUCCESS)
+		return status;
 
-		port->not_ready_reason = SCIC_PORT_NOT_READY_RECONFIGURING;
+	scic_sds_port_deactivate_phy(port, phy, true);
 
-		sci_base_state_machine_change_state(
-			&port->ready_substate_machine,
-			SCIC_SDS_PORT_READY_SUBSTATE_CONFIGURING
-			);
-	}
+	port->not_ready_reason = SCIC_PORT_NOT_READY_RECONFIGURING;
 
+	port_state_machine_change(port,
+				  SCIC_SDS_PORT_READY_SUBSTATE_CONFIGURING);
 	return status;
 }
 
@@ -1255,10 +1265,8 @@ static void scic_sds_port_ready_waiting_substate_link_up_handler(
 	 * it and continue. */
 	scic_sds_port_activate_phy(sci_port, sci_phy, true);
 
-	sci_base_state_machine_change_state(
-		&sci_port->ready_substate_machine,
-		SCIC_SDS_PORT_READY_SUBSTATE_OPERATIONAL
-		);
+	port_state_machine_change(sci_port,
+				  SCIC_SDS_PORT_READY_SUBSTATE_OPERATIONAL);
 }
 
 /*
@@ -1317,9 +1325,8 @@ sci_status scic_sds_port_ready_operational_substate_reset_handler(
 			port->not_ready_reason =
 				SCIC_PORT_NOT_READY_HARD_RESET_REQUESTED;
 
-			sci_base_state_machine_change_state(
-					&port->state_machine,
-					SCI_BASE_PORT_STATE_RESETTING);
+			port_state_machine_change(port,
+						  SCI_BASE_PORT_STATE_RESETTING);
 		}
 	}
 
@@ -1365,8 +1372,8 @@ static void scic_sds_port_ready_operational_substate_link_down_handler(
 	 * the port to the WAITING state until such time as a phy goes
 	 * link up. */
 	if (sci_port->active_phy_mask == 0)
-		sci_base_state_machine_change_state(&sci_port->ready_substate_machine,
-						    SCIC_SDS_PORT_READY_SUBSTATE_WAITING);
+		port_state_machine_change(sci_port,
+				          SCIC_SDS_PORT_READY_SUBSTATE_WAITING);
 }
 
 /*
@@ -1406,10 +1413,8 @@ static enum sci_status scic_sds_port_ready_configuring_substate_add_phy_handler(
 		/*
 		 * Re-enter the configuring state since this may be the last phy in
 		 * the port. */
-		sci_base_state_machine_change_state(
-			&port->ready_substate_machine,
-			SCIC_SDS_PORT_READY_SUBSTATE_CONFIGURING
-			);
+		port_state_machine_change(port,
+					  SCIC_SDS_PORT_READY_SUBSTATE_CONFIGURING);
 	}
 
 	return status;
@@ -1427,17 +1432,15 @@ static enum sci_status scic_sds_port_ready_configuring_substate_remove_phy_handl
 
 	status = scic_sds_port_clear_phy(port, phy);
 
-	if (status == SCI_SUCCESS) {
-		scic_sds_port_deactivate_phy(port, phy, true);
+	if (status != SCI_SUCCESS)
+		return status;
+	scic_sds_port_deactivate_phy(port, phy, true);
 
-		/*
-		 * Re-enter the configuring state since this may be the last phy in
-		 * the port. */
-		sci_base_state_machine_change_state(
-			&port->ready_substate_machine,
-			SCIC_SDS_PORT_READY_SUBSTATE_CONFIGURING
-			);
-	}
+	/* Re-enter the configuring state since this may be the last phy in
+	 * the port
+	 */
+	port_state_machine_change(port,
+				  SCIC_SDS_PORT_READY_SUBSTATE_CONFIGURING);
 
 	return status;
 }
@@ -1460,10 +1463,8 @@ scic_sds_port_ready_configuring_substate_complete_io_handler(
 	scic_sds_port_decrement_request_count(port);
 
 	if (port->started_request_count == 0) {
-		sci_base_state_machine_change_state(
-			&port->ready_substate_machine,
-			SCIC_SDS_PORT_READY_SUBSTATE_OPERATIONAL
-			);
+		port_state_machine_change(port,
+					  SCIC_SDS_PORT_READY_SUBSTATE_OPERATIONAL);
 	}
 
 	return SCI_SUCCESS;
@@ -1567,61 +1568,6 @@ static enum sci_status scic_sds_port_default_complete_io_handler(struct scic_sds
 	return default_port_handler(sci_port, __func__);
 }
 
-static struct scic_sds_port_state_handler scic_sds_port_ready_substate_handler_table[] = {
-	[SCIC_SDS_PORT_READY_SUBSTATE_WAITING] = {
-		.start_handler		= scic_sds_port_default_start_handler,
-		.stop_handler		= scic_sds_port_ready_substate_stop_handler,
-		.destruct_handler	= scic_sds_port_default_destruct_handler,
-		.reset_handler		= scic_sds_port_default_reset_handler,
-		.add_phy_handler	= scic_sds_port_ready_substate_add_phy_handler,
-		.remove_phy_handler	= scic_sds_port_default_remove_phy_handler,
-		.frame_handler		= scic_sds_port_default_frame_handler,
-		.event_handler		= scic_sds_port_default_event_handler,
-		.link_up_handler	= scic_sds_port_ready_waiting_substate_link_up_handler,
-		.link_down_handler	= scic_sds_port_default_link_down_handler,
-		.start_io_handler	= scic_sds_port_ready_waiting_substate_start_io_handler,
-		.complete_io_handler	= scic_sds_port_ready_substate_complete_io_handler,
-	},
-	[SCIC_SDS_PORT_READY_SUBSTATE_OPERATIONAL] = {
-		.start_handler		= scic_sds_port_default_start_handler,
-		.stop_handler		= scic_sds_port_ready_substate_stop_handler,
-		.destruct_handler	= scic_sds_port_default_destruct_handler,
-		.reset_handler		= scic_sds_port_ready_operational_substate_reset_handler,
-		.add_phy_handler	= scic_sds_port_ready_substate_add_phy_handler,
-		.remove_phy_handler	= scic_sds_port_ready_substate_remove_phy_handler,
-		.frame_handler		= scic_sds_port_default_frame_handler,
-		.event_handler		= scic_sds_port_default_event_handler,
-		.link_up_handler	= scic_sds_port_ready_operational_substate_link_up_handler,
-		.link_down_handler	= scic_sds_port_ready_operational_substate_link_down_handler,
-		.start_io_handler	= scic_sds_port_ready_operational_substate_start_io_handler,
-		.complete_io_handler	= scic_sds_port_ready_substate_complete_io_handler,
-	},
-	[SCIC_SDS_PORT_READY_SUBSTATE_CONFIGURING] = {
-		.start_handler		= scic_sds_port_default_start_handler,
-		.stop_handler		= scic_sds_port_ready_substate_stop_handler,
-		.destruct_handler	= scic_sds_port_default_destruct_handler,
-		.reset_handler		= scic_sds_port_default_reset_handler,
-		.add_phy_handler	= scic_sds_port_ready_configuring_substate_add_phy_handler,
-		.remove_phy_handler	= scic_sds_port_ready_configuring_substate_remove_phy_handler,
-		.frame_handler		= scic_sds_port_default_frame_handler,
-		.event_handler		= scic_sds_port_default_event_handler,
-		.link_up_handler	= scic_sds_port_default_link_up_handler,
-		.link_down_handler	= scic_sds_port_default_link_down_handler,
-		.start_io_handler	= scic_sds_port_default_start_io_handler,
-		.complete_io_handler	= scic_sds_port_ready_configuring_substate_complete_io_handler
-	}
-};
-
-/**
- * scic_sds_port_set_ready_state_handlers() -
- *
- * This macro sets the port ready substate handlers.
- */
-#define scic_sds_port_set_ready_state_handlers(port, state_id) \
-	scic_sds_port_set_state_handlers(\
-		port, &scic_sds_port_ready_substate_handler_table[(state_id)] \
-		)
-
 /*
  * ******************************************************************************
  * *  PORT STATE PRIVATE METHODS
@@ -1729,7 +1675,7 @@ static void scic_sds_port_ready_substate_waiting_enter(void *object)
 {
 	struct scic_sds_port *sci_port = object;
 
-	scic_sds_port_set_ready_state_handlers(
+	scic_sds_port_set_base_state_handlers(
 		sci_port, SCIC_SDS_PORT_READY_SUBSTATE_WAITING
 		);
 
@@ -1739,10 +1685,8 @@ static void scic_sds_port_ready_substate_waiting_enter(void *object)
 
 	if (sci_port->active_phy_mask != 0) {
 		/* At least one of the phys on the port is ready */
-		sci_base_state_machine_change_state(
-			&sci_port->ready_substate_machine,
-			SCIC_SDS_PORT_READY_SUBSTATE_OPERATIONAL
-			);
+		port_state_machine_change(sci_port,
+					  SCIC_SDS_PORT_READY_SUBSTATE_OPERATIONAL);
 	}
 }
 
@@ -1763,7 +1707,7 @@ static void scic_sds_port_ready_substate_operational_enter(void *object)
 	struct isci_host *ihost = scic_to_ihost(scic);
 	struct isci_port *iport = sci_port_to_iport(sci_port);
 
-	scic_sds_port_set_ready_state_handlers(
+	scic_sds_port_set_base_state_handlers(
 			sci_port,
 			SCIC_SDS_PORT_READY_SUBSTATE_OPERATIONAL);
 
@@ -1788,6 +1732,31 @@ static void scic_sds_port_ready_substate_operational_enter(void *object)
 	scic_sds_port_post_dummy_request(sci_port);
 }
 
+static void scic_sds_port_invalidate_dummy_remote_node(struct scic_sds_port *sci_port)
+{
+	struct scic_sds_controller *scic = sci_port->owning_controller;
+	u8 phys_index = sci_port->physical_port_index;
+	union scu_remote_node_context *rnc;
+	u16 rni = sci_port->reserved_rni;
+	u32 command;
+
+	rnc = &scic->remote_node_context_table[rni];
+
+	rnc->ssp.is_valid = false;
+
+	/* ensure the preceding tc abort request has reached the
+	 * controller and give it ample time to act before posting the rnc
+	 * invalidate
+	 */
+	readl(&scic->smu_registers->interrupt_status); /* flush */
+	udelay(10);
+
+	command = SCU_CONTEXT_COMMAND_POST_RNC_INVALIDATE |
+		  phys_index << SCU_CONTEXT_COMMAND_LOGICAL_PORT_SHIFT | rni;
+
+	scic_sds_controller_post_request(scic, command);
+}
+
 /**
  *
  * @object: This is the object which is cast to a struct scic_sds_port object.
@@ -1811,6 +1780,9 @@ static void scic_sds_port_ready_substate_operational_exit(void *object)
 	scic_sds_port_abort_dummy_request(sci_port);
 
 	isci_port_not_ready(ihost, iport);
+
+	if (sci_port->ready_exit)
+		scic_sds_port_invalidate_dummy_remote_node(sci_port);
 }
 
 /*
@@ -1833,20 +1805,18 @@ static void scic_sds_port_ready_substate_configuring_enter(void *object)
 	struct isci_host *ihost = scic_to_ihost(scic);
 	struct isci_port *iport = sci_port_to_iport(sci_port);
 
-	scic_sds_port_set_ready_state_handlers(
+	scic_sds_port_set_base_state_handlers(
 			sci_port,
 			SCIC_SDS_PORT_READY_SUBSTATE_CONFIGURING);
 
 	if (sci_port->active_phy_mask == 0) {
 		isci_port_not_ready(ihost, iport);
 
-		sci_base_state_machine_change_state(
-				&sci_port->ready_substate_machine,
-				SCIC_SDS_PORT_READY_SUBSTATE_WAITING);
+		port_state_machine_change(sci_port,
+					  SCIC_SDS_PORT_READY_SUBSTATE_WAITING);
 	} else if (sci_port->started_request_count == 0)
-		sci_base_state_machine_change_state(
-				&sci_port->ready_substate_machine,
-				SCIC_SDS_PORT_READY_SUBSTATE_OPERATIONAL);
+		port_state_machine_change(sci_port,
+					  SCIC_SDS_PORT_READY_SUBSTATE_OPERATIONAL);
 }
 
 static void scic_sds_port_ready_substate_configuring_exit(void *object)
@@ -1854,24 +1824,12 @@ static void scic_sds_port_ready_substate_configuring_exit(void *object)
 	struct scic_sds_port *sci_port = object;
 
 	scic_sds_port_suspend_port_task_scheduler(sci_port);
+	if (sci_port->ready_exit)
+		scic_sds_port_invalidate_dummy_remote_node(sci_port);
 }
 
 /* --------------------------------------------------------------------------- */
 
-static const struct sci_base_state scic_sds_port_ready_substate_table[] = {
-	[SCIC_SDS_PORT_READY_SUBSTATE_WAITING] = {
-		.enter_state = scic_sds_port_ready_substate_waiting_enter,
-	},
-	[SCIC_SDS_PORT_READY_SUBSTATE_OPERATIONAL] = {
-		.enter_state = scic_sds_port_ready_substate_operational_enter,
-		.exit_state  = scic_sds_port_ready_substate_operational_exit
-	},
-	[SCIC_SDS_PORT_READY_SUBSTATE_CONFIGURING] = {
-		.enter_state = scic_sds_port_ready_substate_configuring_enter,
-		.exit_state  = scic_sds_port_ready_substate_configuring_exit
-	},
-};
-
 /**
  *
  * @port: This is the struct scic_sds_port object on which the io request count will
@@ -1970,9 +1928,8 @@ scic_sds_port_stopped_state_start_handler(struct scic_sds_port *sci_port)
 		 * silicon.
 		 */
 		if (scic_sds_port_is_phy_mask_valid(sci_port, phy_mask) == true) {
-			sci_base_state_machine_change_state(
-				&sci_port->state_machine,
-				SCI_BASE_PORT_STATE_READY);
+			port_state_machine_change(sci_port,
+						  SCI_BASE_PORT_STATE_READY);
 
 			return SCI_SUCCESS;
 		} else
@@ -2003,10 +1960,9 @@ static enum sci_status scic_sds_port_stopped_state_stop_handler(
  * struct scic_sds_port can be destroyed.  This function causes the port object to
  * transition to the SCI_BASE_PORT_STATE_FINAL. enum sci_status SCI_SUCCESS
  */
-static enum sci_status scic_sds_port_stopped_state_destruct_handler(
-	struct scic_sds_port *port)
+static enum sci_status scic_sds_port_stopped_state_destruct_handler(struct scic_sds_port *port)
 {
-	sci_base_state_machine_stop(&port->state_machine);
+	port_state_machine_stop(port);
 
 	return SCI_SUCCESS;
 }
@@ -2087,10 +2043,9 @@ static enum sci_status scic_sds_port_stopping_state_complete_io_handler(
 {
 	scic_sds_port_decrement_request_count(sci_port);
 
-	if (sci_port->started_request_count == 0) {
-		sci_base_state_machine_change_state(&sci_port->state_machine,
-						    SCI_BASE_PORT_STATE_STOPPED);
-	}
+	if (sci_port->started_request_count == 0)
+		port_state_machine_change(sci_port,
+					  SCI_BASE_PORT_STATE_STOPPED);
 
 	return SCI_SUCCESS;
 }
@@ -2110,10 +2065,8 @@ static enum sci_status scic_sds_port_stopping_state_complete_io_handler(
 static enum sci_status scic_sds_port_reset_state_stop_handler(
 	struct scic_sds_port *port)
 {
-	sci_base_state_machine_change_state(
-		&port->state_machine,
-		SCI_BASE_PORT_STATE_STOPPING
-		);
+	port_state_machine_change(port,
+				  SCI_BASE_PORT_STATE_STOPPING);
 
 	return SCI_SUCCESS;
 }
@@ -2201,6 +2154,48 @@ static struct scic_sds_port_state_handler scic_sds_port_state_handler_table[] =
 		.start_io_handler 	= scic_sds_port_default_start_io_handler,
 		.complete_io_handler 	= scic_sds_port_general_complete_io_handler
 	},
+	[SCIC_SDS_PORT_READY_SUBSTATE_WAITING] = {
+		.start_handler		= scic_sds_port_default_start_handler,
+		.stop_handler		= scic_sds_port_ready_substate_stop_handler,
+		.destruct_handler	= scic_sds_port_default_destruct_handler,
+		.reset_handler		= scic_sds_port_default_reset_handler,
+		.add_phy_handler	= scic_sds_port_ready_substate_add_phy_handler,
+		.remove_phy_handler	= scic_sds_port_default_remove_phy_handler,
+		.frame_handler		= scic_sds_port_default_frame_handler,
+		.event_handler		= scic_sds_port_default_event_handler,
+		.link_up_handler	= scic_sds_port_ready_waiting_substate_link_up_handler,
+		.link_down_handler	= scic_sds_port_default_link_down_handler,
+		.start_io_handler	= scic_sds_port_ready_waiting_substate_start_io_handler,
+		.complete_io_handler	= scic_sds_port_ready_substate_complete_io_handler,
+	},
+	[SCIC_SDS_PORT_READY_SUBSTATE_OPERATIONAL] = {
+		.start_handler		= scic_sds_port_default_start_handler,
+		.stop_handler		= scic_sds_port_ready_substate_stop_handler,
+		.destruct_handler	= scic_sds_port_default_destruct_handler,
+		.reset_handler		= scic_sds_port_ready_operational_substate_reset_handler,
+		.add_phy_handler	= scic_sds_port_ready_substate_add_phy_handler,
+		.remove_phy_handler	= scic_sds_port_ready_substate_remove_phy_handler,
+		.frame_handler		= scic_sds_port_default_frame_handler,
+		.event_handler		= scic_sds_port_default_event_handler,
+		.link_up_handler	= scic_sds_port_ready_operational_substate_link_up_handler,
+		.link_down_handler	= scic_sds_port_ready_operational_substate_link_down_handler,
+		.start_io_handler	= scic_sds_port_ready_operational_substate_start_io_handler,
+		.complete_io_handler	= scic_sds_port_ready_substate_complete_io_handler,
+	},
+	[SCIC_SDS_PORT_READY_SUBSTATE_CONFIGURING] = {
+		.start_handler		= scic_sds_port_default_start_handler,
+		.stop_handler		= scic_sds_port_ready_substate_stop_handler,
+		.destruct_handler	= scic_sds_port_default_destruct_handler,
+		.reset_handler		= scic_sds_port_default_reset_handler,
+		.add_phy_handler	= scic_sds_port_ready_configuring_substate_add_phy_handler,
+		.remove_phy_handler	= scic_sds_port_ready_configuring_substate_remove_phy_handler,
+		.frame_handler		= scic_sds_port_default_frame_handler,
+		.event_handler		= scic_sds_port_default_event_handler,
+		.link_up_handler	= scic_sds_port_default_link_up_handler,
+		.link_down_handler	= scic_sds_port_default_link_down_handler,
+		.start_io_handler	= scic_sds_port_default_start_io_handler,
+		.complete_io_handler	= scic_sds_port_ready_configuring_substate_complete_io_handler
+	},
 	[SCI_BASE_PORT_STATE_RESETTING] = {
 		.start_handler		= scic_sds_port_default_start_handler,
 		.stop_handler		= scic_sds_port_reset_state_stop_handler,
@@ -2299,31 +2294,6 @@ static void scic_sds_port_post_dummy_remote_node(struct scic_sds_port *sci_port)
 	scic_sds_controller_post_request(scic, command);
 }
 
-static void scic_sds_port_invalidate_dummy_remote_node(struct scic_sds_port *sci_port)
-{
-	struct scic_sds_controller *scic = sci_port->owning_controller;
-	u8 phys_index = sci_port->physical_port_index;
-	union scu_remote_node_context *rnc;
-	u16 rni = sci_port->reserved_rni;
-	u32 command;
-
-	rnc = &scic->remote_node_context_table[rni];
-
-	rnc->ssp.is_valid = false;
-
-	/* ensure the preceding tc abort request has reached the
-	 * controller and give it ample time to act before posting the rnc
-	 * invalidate
-	 */
-	readl(&scic->smu_registers->interrupt_status); /* flush */
-	udelay(10);
-
-	command = SCU_CONTEXT_COMMAND_POST_RNC_INVALIDATE |
-		  phys_index << SCU_CONTEXT_COMMAND_LOGICAL_PORT_SHIFT | rni;
-
-	scic_sds_controller_post_request(scic, command);
-}
-
 /*
  * ******************************************************************************
  * *  PORT STATE METHODS
@@ -2404,15 +2374,8 @@ static void scic_sds_port_ready_state_enter(void *object)
 	scic_sds_port_post_dummy_remote_node(sci_port);
 
 	/* Start the ready substate machine */
-	sci_base_state_machine_start(&sci_port->ready_substate_machine);
-}
-
-static void scic_sds_port_ready_state_exit(void *object)
-{
-	struct scic_sds_port *sci_port = object;
-
-	sci_base_state_machine_stop(&sci_port->ready_substate_machine);
-	scic_sds_port_invalidate_dummy_remote_node(sci_port);
+	port_state_machine_change(sci_port,
+				  SCIC_SDS_PORT_READY_SUBSTATE_WAITING);
 }
 
 /**
@@ -2516,7 +2479,17 @@ static const struct sci_base_state scic_sds_port_state_table[] = {
 	},
 	[SCI_BASE_PORT_STATE_READY] = {
 		.enter_state = scic_sds_port_ready_state_enter,
-		.exit_state  = scic_sds_port_ready_state_exit
+	},
+	[SCIC_SDS_PORT_READY_SUBSTATE_WAITING] = {
+		.enter_state = scic_sds_port_ready_substate_waiting_enter,
+	},
+	[SCIC_SDS_PORT_READY_SUBSTATE_OPERATIONAL] = {
+		.enter_state = scic_sds_port_ready_substate_operational_enter,
+		.exit_state  = scic_sds_port_ready_substate_operational_exit
+	},
+	[SCIC_SDS_PORT_READY_SUBSTATE_CONFIGURING] = {
+		.enter_state = scic_sds_port_ready_substate_configuring_enter,
+		.exit_state  = scic_sds_port_ready_substate_configuring_exit
 	},
 	[SCI_BASE_PORT_STATE_RESETTING] = {
 		.enter_state = scic_sds_port_resetting_state_enter,
@@ -2537,14 +2510,10 @@ void scic_sds_port_construct(struct scic_sds_port *sci_port, u8 index,
 
 	sci_base_state_machine_start(&sci_port->state_machine);
 
-	sci_base_state_machine_construct(&sci_port->ready_substate_machine,
-					 sci_port,
-					 scic_sds_port_ready_substate_table,
-					 SCIC_SDS_PORT_READY_SUBSTATE_WAITING);
-
 	sci_port->logical_port_index  = SCIC_SDS_DUMMY_PORT;
 	sci_port->physical_port_index = index;
 	sci_port->active_phy_mask     = 0;
+	sci_port->ready_exit	      = false;
 
 	sci_port->owning_controller = scic;
 

commit c777c26ca2a06164e1b8c8ccf4cd76cd645a9bbb
Author: Piotr Sawicki <piotr.sawicki@intel.com>
Date:   Wed May 11 23:52:16 2011 +0000

    isci: c99 port state handlers
    
    Name the table fields for consistancy and clarity.
    
    Signed-off-by: Piotr Sawicki <piotr.sawicki@intel.com>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/drivers/scsi/isci/port.c b/drivers/scsi/isci/port.c
index 6d2633051adc..e386066825b2 100644
--- a/drivers/scsi/isci/port.c
+++ b/drivers/scsi/isci/port.c
@@ -1567,56 +1567,48 @@ static enum sci_status scic_sds_port_default_complete_io_handler(struct scic_sds
 	return default_port_handler(sci_port, __func__);
 }
 
-
-
-static struct scic_sds_port_state_handler
-scic_sds_port_ready_substate_handler_table[SCIC_SDS_PORT_READY_MAX_SUBSTATES] = {
-	{
-		/* SCIC_SDS_PORT_READY_SUBSTATE_WAITING */
-		scic_sds_port_default_start_handler,
-		scic_sds_port_ready_substate_stop_handler,
-		scic_sds_port_default_destruct_handler,
-		scic_sds_port_default_reset_handler,
-		scic_sds_port_ready_substate_add_phy_handler,
-		scic_sds_port_default_remove_phy_handler,
-		scic_sds_port_default_frame_handler,
-		scic_sds_port_default_event_handler,
-		scic_sds_port_ready_waiting_substate_link_up_handler,
-		scic_sds_port_default_link_down_handler,
-		scic_sds_port_ready_waiting_substate_start_io_handler,
-		scic_sds_port_ready_substate_complete_io_handler,
+static struct scic_sds_port_state_handler scic_sds_port_ready_substate_handler_table[] = {
+	[SCIC_SDS_PORT_READY_SUBSTATE_WAITING] = {
+		.start_handler		= scic_sds_port_default_start_handler,
+		.stop_handler		= scic_sds_port_ready_substate_stop_handler,
+		.destruct_handler	= scic_sds_port_default_destruct_handler,
+		.reset_handler		= scic_sds_port_default_reset_handler,
+		.add_phy_handler	= scic_sds_port_ready_substate_add_phy_handler,
+		.remove_phy_handler	= scic_sds_port_default_remove_phy_handler,
+		.frame_handler		= scic_sds_port_default_frame_handler,
+		.event_handler		= scic_sds_port_default_event_handler,
+		.link_up_handler	= scic_sds_port_ready_waiting_substate_link_up_handler,
+		.link_down_handler	= scic_sds_port_default_link_down_handler,
+		.start_io_handler	= scic_sds_port_ready_waiting_substate_start_io_handler,
+		.complete_io_handler	= scic_sds_port_ready_substate_complete_io_handler,
 	},
-
-	{
-		/* SCIC_SDS_PORT_READY_SUBSTATE_OPERATIONAL */
-		scic_sds_port_default_start_handler,
-		scic_sds_port_ready_substate_stop_handler,
-		scic_sds_port_default_destruct_handler,
-		scic_sds_port_ready_operational_substate_reset_handler,
-		scic_sds_port_ready_substate_add_phy_handler,
-		scic_sds_port_ready_substate_remove_phy_handler,
-		scic_sds_port_default_frame_handler,
-		scic_sds_port_default_event_handler,
-		scic_sds_port_ready_operational_substate_link_up_handler,
-		scic_sds_port_ready_operational_substate_link_down_handler,
-		scic_sds_port_ready_operational_substate_start_io_handler,
-		scic_sds_port_ready_substate_complete_io_handler,
+	[SCIC_SDS_PORT_READY_SUBSTATE_OPERATIONAL] = {
+		.start_handler		= scic_sds_port_default_start_handler,
+		.stop_handler		= scic_sds_port_ready_substate_stop_handler,
+		.destruct_handler	= scic_sds_port_default_destruct_handler,
+		.reset_handler		= scic_sds_port_ready_operational_substate_reset_handler,
+		.add_phy_handler	= scic_sds_port_ready_substate_add_phy_handler,
+		.remove_phy_handler	= scic_sds_port_ready_substate_remove_phy_handler,
+		.frame_handler		= scic_sds_port_default_frame_handler,
+		.event_handler		= scic_sds_port_default_event_handler,
+		.link_up_handler	= scic_sds_port_ready_operational_substate_link_up_handler,
+		.link_down_handler	= scic_sds_port_ready_operational_substate_link_down_handler,
+		.start_io_handler	= scic_sds_port_ready_operational_substate_start_io_handler,
+		.complete_io_handler	= scic_sds_port_ready_substate_complete_io_handler,
 	},
-
-	{
-		/* SCIC_SDS_PORT_READY_SUBSTATE_CONFIGURING */
-		scic_sds_port_default_start_handler,
-		scic_sds_port_ready_substate_stop_handler,
-		scic_sds_port_default_destruct_handler,
-		scic_sds_port_default_reset_handler,
-		scic_sds_port_ready_configuring_substate_add_phy_handler,
-		scic_sds_port_ready_configuring_substate_remove_phy_handler,
-		scic_sds_port_default_frame_handler,
-		scic_sds_port_default_event_handler,
-		scic_sds_port_default_link_up_handler,
-		scic_sds_port_default_link_down_handler,
-		scic_sds_port_default_start_io_handler,
-		scic_sds_port_ready_configuring_substate_complete_io_handler
+	[SCIC_SDS_PORT_READY_SUBSTATE_CONFIGURING] = {
+		.start_handler		= scic_sds_port_default_start_handler,
+		.stop_handler		= scic_sds_port_ready_substate_stop_handler,
+		.destruct_handler	= scic_sds_port_default_destruct_handler,
+		.reset_handler		= scic_sds_port_default_reset_handler,
+		.add_phy_handler	= scic_sds_port_ready_configuring_substate_add_phy_handler,
+		.remove_phy_handler	= scic_sds_port_ready_configuring_substate_remove_phy_handler,
+		.frame_handler		= scic_sds_port_default_frame_handler,
+		.event_handler		= scic_sds_port_default_event_handler,
+		.link_up_handler	= scic_sds_port_default_link_up_handler,
+		.link_down_handler	= scic_sds_port_default_link_down_handler,
+		.start_io_handler	= scic_sds_port_default_start_io_handler,
+		.complete_io_handler	= scic_sds_port_ready_configuring_substate_complete_io_handler
 	}
 };
 
@@ -2166,83 +2158,76 @@ static void scic_sds_port_reset_state_link_down_handler(
 	scic_sds_port_deactivate_phy(port, phy, false);
 }
 
-static struct scic_sds_port_state_handler
-scic_sds_port_state_handler_table[SCI_BASE_PORT_MAX_STATES] =
-{
-	/* SCI_BASE_PORT_STATE_STOPPED */
-	{
-		scic_sds_port_stopped_state_start_handler,
-		scic_sds_port_stopped_state_stop_handler,
-		scic_sds_port_stopped_state_destruct_handler,
-		scic_sds_port_default_reset_handler,
-		scic_sds_port_stopped_state_add_phy_handler,
-		scic_sds_port_stopped_state_remove_phy_handler,
-		scic_sds_port_default_frame_handler,
-		scic_sds_port_default_event_handler,
-		scic_sds_port_default_link_up_handler,
-		scic_sds_port_default_link_down_handler,
-		scic_sds_port_default_start_io_handler,
-		scic_sds_port_default_complete_io_handler
+static struct scic_sds_port_state_handler scic_sds_port_state_handler_table[] = {
+	[SCI_BASE_PORT_STATE_STOPPED] = {
+		.start_handler  	= scic_sds_port_stopped_state_start_handler,
+		.stop_handler   	= scic_sds_port_stopped_state_stop_handler,
+		.destruct_handler 	= scic_sds_port_stopped_state_destruct_handler,
+		.reset_handler  	= scic_sds_port_default_reset_handler,
+		.add_phy_handler 	= scic_sds_port_stopped_state_add_phy_handler,
+		.remove_phy_handler 	= scic_sds_port_stopped_state_remove_phy_handler,
+		.frame_handler  	= scic_sds_port_default_frame_handler,
+		.event_handler  	= scic_sds_port_default_event_handler,
+		.link_up_handler        = scic_sds_port_default_link_up_handler,
+		.link_down_handler 	= scic_sds_port_default_link_down_handler,
+		.start_io_handler 	= scic_sds_port_default_start_io_handler,
+		.complete_io_handler 	= scic_sds_port_default_complete_io_handler
 	},
-	/* SCI_BASE_PORT_STATE_STOPPING */
-	{
-		scic_sds_port_default_start_handler,
-		scic_sds_port_default_stop_handler,
-		scic_sds_port_default_destruct_handler,
-		scic_sds_port_default_reset_handler,
-		scic_sds_port_default_add_phy_handler,
-		scic_sds_port_default_remove_phy_handler,
-		scic_sds_port_default_frame_handler,
-		scic_sds_port_default_event_handler,
-		scic_sds_port_default_link_up_handler,
-		scic_sds_port_default_link_down_handler,
-		scic_sds_port_default_start_io_handler,
-		scic_sds_port_stopping_state_complete_io_handler
+	[SCI_BASE_PORT_STATE_STOPPING] = {
+		.start_handler  	= scic_sds_port_default_start_handler,
+		.stop_handler   	= scic_sds_port_default_stop_handler,
+		.destruct_handler 	= scic_sds_port_default_destruct_handler,
+		.reset_handler  	= scic_sds_port_default_reset_handler,
+		.add_phy_handler 	= scic_sds_port_default_add_phy_handler,
+		.remove_phy_handler 	= scic_sds_port_default_remove_phy_handler,
+		.frame_handler  	= scic_sds_port_default_frame_handler,
+		.event_handler  	= scic_sds_port_default_event_handler,
+		.link_up_handler        = scic_sds_port_default_link_up_handler,
+		.link_down_handler 	= scic_sds_port_default_link_down_handler,
+		.start_io_handler 	= scic_sds_port_default_start_io_handler,
+		.complete_io_handler 	= scic_sds_port_stopping_state_complete_io_handler
 	},
-	/* SCI_BASE_PORT_STATE_READY */
-	{
-		scic_sds_port_default_start_handler,
-		scic_sds_port_default_stop_handler,
-		scic_sds_port_default_destruct_handler,
-		scic_sds_port_default_reset_handler,
-		scic_sds_port_default_add_phy_handler,
-		scic_sds_port_default_remove_phy_handler,
-		scic_sds_port_default_frame_handler,
-		scic_sds_port_default_event_handler,
-		scic_sds_port_default_link_up_handler,
-		scic_sds_port_default_link_down_handler,
-		scic_sds_port_default_start_io_handler,
-		scic_sds_port_general_complete_io_handler
+	[SCI_BASE_PORT_STATE_READY] = {
+		.start_handler		= scic_sds_port_default_start_handler,
+		.stop_handler    	= scic_sds_port_default_stop_handler,
+		.destruct_handler 	= scic_sds_port_default_destruct_handler,
+		.reset_handler   	= scic_sds_port_default_reset_handler,
+		.add_phy_handler 	= scic_sds_port_default_add_phy_handler,
+		.remove_phy_handler 	= scic_sds_port_default_remove_phy_handler,
+		.frame_handler   	= scic_sds_port_default_frame_handler,
+		.event_handler   	= scic_sds_port_default_event_handler,
+		.link_up_handler 	= scic_sds_port_default_link_up_handler,
+		.link_down_handler 	= scic_sds_port_default_link_down_handler,
+		.start_io_handler 	= scic_sds_port_default_start_io_handler,
+		.complete_io_handler 	= scic_sds_port_general_complete_io_handler
 	},
-	/* SCI_BASE_PORT_STATE_RESETTING */
-	{
-		scic_sds_port_default_start_handler,
-		scic_sds_port_reset_state_stop_handler,
-		scic_sds_port_default_destruct_handler,
-		scic_sds_port_default_reset_handler,
-		scic_sds_port_default_add_phy_handler,
-		scic_sds_port_default_remove_phy_handler,
-		scic_sds_port_default_frame_handler,
-		scic_sds_port_default_event_handler,
-		scic_sds_port_reset_state_link_up_handler,
-		scic_sds_port_reset_state_link_down_handler,
-		scic_sds_port_default_start_io_handler,
-		scic_sds_port_general_complete_io_handler
+	[SCI_BASE_PORT_STATE_RESETTING] = {
+		.start_handler		= scic_sds_port_default_start_handler,
+		.stop_handler		= scic_sds_port_reset_state_stop_handler,
+		.destruct_handler	= scic_sds_port_default_destruct_handler,
+		.reset_handler		= scic_sds_port_default_reset_handler,
+		.add_phy_handler	= scic_sds_port_default_add_phy_handler,
+		.remove_phy_handler	= scic_sds_port_default_remove_phy_handler,
+		.frame_handler		= scic_sds_port_default_frame_handler,
+		.event_handler		= scic_sds_port_default_event_handler,
+		.link_up_handler	= scic_sds_port_reset_state_link_up_handler,
+		.link_down_handler	= scic_sds_port_reset_state_link_down_handler,
+		.start_io_handler	= scic_sds_port_default_start_io_handler,
+		.complete_io_handler	= scic_sds_port_general_complete_io_handler
 	},
-	/* SCI_BASE_PORT_STATE_FAILED */
-	{
-		scic_sds_port_default_start_handler,
-		scic_sds_port_default_stop_handler,
-		scic_sds_port_default_destruct_handler,
-		scic_sds_port_default_reset_handler,
-		scic_sds_port_default_add_phy_handler,
-		scic_sds_port_default_remove_phy_handler,
-		scic_sds_port_default_frame_handler,
-		scic_sds_port_default_event_handler,
-		scic_sds_port_default_link_up_handler,
-		scic_sds_port_default_link_down_handler,
-		scic_sds_port_default_start_io_handler,
-		scic_sds_port_general_complete_io_handler
+	[SCI_BASE_PORT_STATE_FAILED] = {
+		.start_handler		= scic_sds_port_default_start_handler,
+		.stop_handler		= scic_sds_port_default_stop_handler,
+		.destruct_handler	= scic_sds_port_default_destruct_handler,
+		.reset_handler		= scic_sds_port_default_reset_handler,
+		.add_phy_handler	= scic_sds_port_default_add_phy_handler,
+		.remove_phy_handler	= scic_sds_port_default_remove_phy_handler,
+		.frame_handler		= scic_sds_port_default_frame_handler,
+		.event_handler		= scic_sds_port_default_event_handler,
+		.link_up_handler	= scic_sds_port_default_link_up_handler,
+		.link_down_handler	= scic_sds_port_default_link_down_handler,
+		.start_io_handler	= scic_sds_port_default_start_io_handler,
+		.complete_io_handler	= scic_sds_port_general_complete_io_handler
 	}
 };
 

commit 4f20ef4f57aa52fd3356c143a8f3d2bd18dc61fc
Author: Dan Williams <dan.j.williams@intel.com>
Date:   Thu May 12 06:00:31 2011 -0700

    isci: clarify phy to port lookups
    
    While cleaning up the driver it is very tempting to convert scic_sds_get_*
    macros to their open coded equivalent.  They are all just pointer dereferences
    *except* scic_sds_phy_get_port() which returns NULL if the phy is assigned to
    the dummy port.  Clarify this by renaming it to phy_get_non_dummy_port().
    
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/drivers/scsi/isci/port.c b/drivers/scsi/isci/port.c
index dbff28396dd8..6d2633051adc 100644
--- a/drivers/scsi/isci/port.c
+++ b/drivers/scsi/isci/port.c
@@ -485,7 +485,7 @@ static enum sci_status scic_sds_port_set_phy(
 	 * not already have a phy assinged to the phy index. */
 	if (
 		(port->phy_table[phy->phy_index] == NULL)
-		&& (scic_sds_phy_get_port(phy) == NULL)
+		&& (phy_get_non_dummy_port(phy) == NULL)
 		&& scic_sds_port_is_valid_phy_assignment(port, phy->phy_index)
 		) {
 		/*
@@ -516,7 +516,7 @@ static enum sci_status scic_sds_port_clear_phy(
 {
 	/* Make sure that this phy is part of this port */
 	if (port->phy_table[phy->phy_index] == phy &&
-	    scic_sds_phy_get_port(phy) == port) {
+	    phy_get_non_dummy_port(phy) == port) {
 		struct scic_sds_controller *scic = port->owning_controller;
 		struct isci_host *ihost = scic_to_ihost(scic);
 

commit e2f8db509fdd354bb7a68c86515e9d2d8909ccc9
Author: Dan Williams <dan.j.williams@intel.com>
Date:   Tue May 10 02:28:46 2011 -0700

    isci: uplevel port infrastructure
    
    * Move port configuration agent implementation
    * Merge core/scic_sds_port.[ch] into port.[ch]
    
    Reported-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/drivers/scsi/isci/port.c b/drivers/scsi/isci/port.c
index 321935d9560b..dbff28396dd8 100644
--- a/drivers/scsi/isci/port.c
+++ b/drivers/scsi/isci/port.c
@@ -53,11 +53,13 @@
  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
 
-#include <linux/workqueue.h>
 #include "isci.h"
-#include "scic_port.h"
 #include "port.h"
 #include "request.h"
+#include "timers.h"
+
+#define SCIC_SDS_PORT_HARD_RESET_TIMEOUT  (1000)
+#define SCU_DUMMY_INDEX    (0xFFFF)
 
 static void isci_port_change_state(struct isci_port *iport, enum isci_status status)
 {
@@ -73,44 +75,87 @@ static void isci_port_change_state(struct isci_port *iport, enum isci_status sta
 	spin_unlock_irqrestore(&iport->state_lock, flags);
 }
 
-void isci_port_init(struct isci_port *iport, struct isci_host *ihost, int index)
+/*
+ * This function will indicate which protocols are supported by this port.
+ * @sci_port: a handle corresponding to the SAS port for which to return the
+ *    supported protocols.
+ * @protocols: This parameter specifies a pointer to a data structure
+ *    which the core will copy the protocol values for the port from the
+ *    transmit_identification register.
+ */
+static void
+scic_sds_port_get_protocols(struct scic_sds_port *sci_port,
+			    struct scic_phy_proto *protocols)
 {
-	INIT_LIST_HEAD(&iport->remote_dev_list);
-	INIT_LIST_HEAD(&iport->domain_dev_list);
-	spin_lock_init(&iport->state_lock);
-	init_completion(&iport->start_complete);
-	iport->isci_host = ihost;
-	isci_port_change_state(iport, isci_freed);
+	u8 index;
+
+	protocols->all = 0;
+
+	for (index = 0; index < SCI_MAX_PHYS; index++) {
+		if (sci_port->phy_table[index] != NULL) {
+			scic_sds_phy_get_protocols(sci_port->phy_table[index],
+						   protocols);
+		}
+	}
 }
 
 /**
- * isci_port_get_state() - This function gets the status of the port object.
- * @isci_port: This parameter points to the isci_port object
+ * This method requests a list (mask) of the phys contained in the supplied SAS
+ *    port.
+ * @sci_port: a handle corresponding to the SAS port for which to return the
+ *    phy mask.
  *
- * status of the object as a isci_status enum.
+ * Return a bit mask indicating which phys are a part of this port. Each bit
+ * corresponds to a phy identifier (e.g. bit 0 = phy id 0).
  */
-enum isci_status isci_port_get_state(
-	struct isci_port *isci_port)
+static u32 scic_sds_port_get_phys(struct scic_sds_port *sci_port)
 {
-	return isci_port->status;
+	u32 index;
+	u32 mask;
+
+	mask = 0;
+
+	for (index = 0; index < SCI_MAX_PHYS; index++) {
+		if (sci_port->phy_table[index] != NULL) {
+			mask |= (1 << index);
+		}
+	}
+
+	return mask;
 }
 
-void isci_port_bc_change_received(struct isci_host *ihost,
-				  struct scic_sds_port *sci_port,
-				  struct scic_sds_phy *sci_phy)
+/**
+ * scic_port_get_properties() - This method simply returns the properties
+ *    regarding the port, such as: physical index, protocols, sas address, etc.
+ * @port: this parameter specifies the port for which to retrieve the physical
+ *    index.
+ * @properties: This parameter specifies the properties structure into which to
+ *    copy the requested information.
+ *
+ * Indicate if the user specified a valid port. SCI_SUCCESS This value is
+ * returned if the specified port was valid. SCI_FAILURE_INVALID_PORT This
+ * value is returned if the specified port is not valid.  When this value is
+ * returned, no data is copied to the properties output parameter.
+ */
+static enum sci_status scic_port_get_properties(struct scic_sds_port *port,
+						struct scic_port_properties *prop)
 {
-	struct isci_phy *iphy = sci_phy_to_iphy(sci_phy);
+	if ((port == NULL) ||
+	    (port->logical_port_index == SCIC_SDS_DUMMY_PORT))
+		return SCI_FAILURE_INVALID_PORT;
 
-	dev_dbg(&ihost->pdev->dev, "%s: iphy = %p, sas_phy = %p\n",
-		__func__, iphy, &iphy->sas_phy);
+	prop->index    = port->logical_port_index;
+	prop->phy_mask = scic_sds_port_get_phys(port);
+	scic_sds_port_get_sas_address(port, &prop->local.sas_address);
+	scic_sds_port_get_protocols(port, &prop->local.protocols);
+	scic_sds_port_get_attached_sas_address(port, &prop->remote.sas_address);
 
-	ihost->sas_ha.notify_port_event(&iphy->sas_phy, PORTE_BROADCAST_RCVD);
-	scic_port_enable_broadcast_change_notification(sci_port);
+	return SCI_SUCCESS;
 }
 
-void isci_port_link_up(struct isci_host *isci_host,
-		       struct scic_sds_port *port,
-		       struct scic_sds_phy *phy)
+static void isci_port_link_up(struct isci_host *isci_host,
+			      struct scic_sds_port *port,
+			      struct scic_sds_phy *phy)
 {
 	unsigned long flags;
 	struct scic_port_properties properties;
@@ -184,8 +229,9 @@ void isci_port_link_up(struct isci_host *isci_host,
  * @port: This parameter specifies the isci port with the active link.
  *
  */
-void isci_port_link_down(struct isci_host *isci_host, struct isci_phy *isci_phy,
-			 struct isci_port *isci_port)
+static void isci_port_link_down(struct isci_host *isci_host,
+				struct isci_phy *isci_phy,
+				struct isci_port *isci_port)
 {
 	struct isci_remote_device *isci_device;
 
@@ -230,30 +276,6 @@ void isci_port_link_down(struct isci_host *isci_host, struct isci_phy *isci_phy,
 }
 
 
-/**
- * isci_port_deformed() - This function is called by libsas when a port becomes
- *    inactive.
- * @phy: This parameter specifies the libsas phy with the inactive port.
- *
- */
-void isci_port_deformed(
-	struct asd_sas_phy *phy)
-{
-	pr_debug("%s: sas_phy = %p\n", __func__, phy);
-}
-
-/**
- * isci_port_formed() - This function is called by libsas when a port becomes
- *    active.
- * @phy: This parameter specifies the libsas phy with the active port.
- *
- */
-void isci_port_formed(
-	struct asd_sas_phy *phy)
-{
-	pr_debug("%s: sas_phy = %p, sas_port = %p\n", __func__, phy, phy->port);
-}
-
 /**
  * isci_port_ready() - This function is called by the sci core when a link
  *    becomes ready.
@@ -261,7 +283,7 @@ void isci_port_formed(
  * @port: This parameter specifies the sci port with the active link.
  *
  */
-void isci_port_ready(struct isci_host *isci_host, struct isci_port *isci_port)
+static void isci_port_ready(struct isci_host *isci_host, struct isci_port *isci_port)
 {
 	dev_dbg(&isci_host->pdev->dev,
 		"%s: isci_port = %p\n", __func__, isci_port);
@@ -279,12 +301,19 @@ void isci_port_ready(struct isci_host *isci_host, struct isci_port *isci_port)
  * @port: This parameter specifies the sci port with the active link.
  *
  */
-void isci_port_not_ready(struct isci_host *isci_host, struct isci_port *isci_port)
+static void isci_port_not_ready(struct isci_host *isci_host, struct isci_port *isci_port)
 {
 	dev_dbg(&isci_host->pdev->dev,
 		"%s: isci_port = %p\n", __func__, isci_port);
 }
 
+static void isci_port_stop_complete(struct scic_sds_controller *scic,
+				    struct scic_sds_port *sci_port,
+				    enum sci_status completion_status)
+{
+	dev_dbg(&scic_to_ihost(scic)->pdev->dev, "Port stop complete\n");
+}
+
 /**
  * isci_port_hard_reset_complete() - This function is called by the sci core
  *    when the hard reset complete notification has been received.
@@ -293,8 +322,8 @@ void isci_port_not_ready(struct isci_host *isci_host, struct isci_port *isci_por
  *    process.
  *
  */
-void isci_port_hard_reset_complete(struct isci_port *isci_port,
-				   enum sci_status completion_status)
+static void isci_port_hard_reset_complete(struct isci_port *isci_port,
+					  enum sci_status completion_status)
 {
 	dev_dbg(&isci_port->isci_host->pdev->dev,
 		"%s: isci_port = %p, completion_status=%x\n",
@@ -306,62 +335,2364 @@ void isci_port_hard_reset_complete(struct isci_port *isci_port,
 	complete_all(&isci_port->hard_reset_complete);
 }
 
-int isci_port_perform_hard_reset(struct isci_host *ihost, struct isci_port *iport,
-				 struct isci_phy *iphy)
+/* This method will return a true value if the specified phy can be assigned to
+ * this port The following is a list of phys for each port that are allowed: -
+ * Port 0 - 3 2 1 0 - Port 1 -     1 - Port 2 - 3 2 - Port 3 - 3 This method
+ * doesn't preclude all configurations.  It merely ensures that a phy is part
+ * of the allowable set of phy identifiers for that port.  For example, one
+ * could assign phy 3 to port 0 and no other phys.  Please refer to
+ * scic_sds_port_is_phy_mask_valid() for information regarding whether the
+ * phy_mask for a port can be supported. bool true if this is a valid phy
+ * assignment for the port false if this is not a valid phy assignment for the
+ * port
+ */
+bool scic_sds_port_is_valid_phy_assignment(struct scic_sds_port *sci_port,
+					   u32 phy_index)
 {
-	unsigned long flags;
-	enum sci_status status;
-	int ret = TMF_RESP_FUNC_COMPLETE;
+	/* Initialize to invalid value. */
+	u32 existing_phy_index = SCI_MAX_PHYS;
+	u32 index;
 
-	dev_dbg(&ihost->pdev->dev, "%s: iport = %p\n",
-		__func__, iport);
+	if ((sci_port->physical_port_index == 1) && (phy_index != 1)) {
+		return false;
+	}
 
-	init_completion(&iport->hard_reset_complete);
+	if (sci_port->physical_port_index == 3 && phy_index != 3) {
+		return false;
+	}
 
-	spin_lock_irqsave(&ihost->scic_lock, flags);
+	if (
+		(sci_port->physical_port_index == 2)
+		&& ((phy_index == 0) || (phy_index == 1))
+		) {
+		return false;
+	}
 
-	#define ISCI_PORT_RESET_TIMEOUT SCIC_SDS_SIGNATURE_FIS_TIMEOUT
-	status = scic_port_hard_reset(&iport->sci, ISCI_PORT_RESET_TIMEOUT);
+	for (index = 0; index < SCI_MAX_PHYS; index++) {
+		if ((sci_port->phy_table[index] != NULL)
+		    && (index != phy_index)) {
+			existing_phy_index = index;
+		}
+	}
 
-	spin_unlock_irqrestore(&ihost->scic_lock, flags);
+	/*
+	 * Ensure that all of the phys in the port are capable of
+	 * operating at the same maximum link rate. */
+	if (
+		(existing_phy_index < SCI_MAX_PHYS)
+		&& (sci_port->owning_controller->user_parameters.sds1.phys[
+			    phy_index].max_speed_generation !=
+		    sci_port->owning_controller->user_parameters.sds1.phys[
+			    existing_phy_index].max_speed_generation)
+		)
+		return false;
 
-	if (status == SCI_SUCCESS) {
-		wait_for_completion(&iport->hard_reset_complete);
+	return true;
+}
 
-		dev_dbg(&ihost->pdev->dev,
-			"%s: iport = %p; hard reset completion\n",
-			__func__, iport);
+/**
+ *
+ * @sci_port: This is the port object for which to determine if the phy mask
+ *    can be supported.
+ *
+ * This method will return a true value if the port's phy mask can be supported
+ * by the SCU. The following is a list of valid PHY mask configurations for
+ * each port: - Port 0 - [[3  2] 1] 0 - Port 1 -        [1] - Port 2 - [[3] 2]
+ * - Port 3 -  [3] This method returns a boolean indication specifying if the
+ * phy mask can be supported. true if this is a valid phy assignment for the
+ * port false if this is not a valid phy assignment for the port
+ */
+static bool scic_sds_port_is_phy_mask_valid(
+	struct scic_sds_port *sci_port,
+	u32 phy_mask)
+{
+	if (sci_port->physical_port_index == 0) {
+		if (((phy_mask & 0x0F) == 0x0F)
+		    || ((phy_mask & 0x03) == 0x03)
+		    || ((phy_mask & 0x01) == 0x01)
+		    || (phy_mask == 0))
+			return true;
+	} else if (sci_port->physical_port_index == 1) {
+		if (((phy_mask & 0x02) == 0x02)
+		    || (phy_mask == 0))
+			return true;
+	} else if (sci_port->physical_port_index == 2) {
+		if (((phy_mask & 0x0C) == 0x0C)
+		    || ((phy_mask & 0x04) == 0x04)
+		    || (phy_mask == 0))
+			return true;
+	} else if (sci_port->physical_port_index == 3) {
+		if (((phy_mask & 0x08) == 0x08)
+		    || (phy_mask == 0))
+			return true;
+	}
 
-		if (iport->hard_reset_status != SCI_SUCCESS)
-			ret = TMF_RESP_FUNC_FAILED;
-	} else {
-		ret = TMF_RESP_FUNC_FAILED;
+	return false;
+}
 
-		dev_err(&ihost->pdev->dev,
-			"%s: iport = %p; scic_port_hard_reset call"
-			" failed 0x%x\n",
-			__func__, iport, status);
+/**
+ *
+ * @sci_port: This parameter specifies the port from which to return a
+ *    connected phy.
+ *
+ * This method retrieves a currently active (i.e. connected) phy contained in
+ * the port.  Currently, the lowest order phy that is connected is returned.
+ * This method returns a pointer to a SCIS_SDS_PHY object. NULL This value is
+ * returned if there are no currently active (i.e. connected to a remote end
+ * point) phys contained in the port. All other values specify a struct scic_sds_phy
+ * object that is active in the port.
+ */
+static struct scic_sds_phy *scic_sds_port_get_a_connected_phy(
+	struct scic_sds_port *sci_port
+	) {
+	u32 index;
+	struct scic_sds_phy *phy;
 
+	for (index = 0; index < SCI_MAX_PHYS; index++) {
+		/*
+		 * Ensure that the phy is both part of the port and currently
+		 * connected to the remote end-point. */
+		phy = sci_port->phy_table[index];
+		if (
+			(phy != NULL)
+			&& scic_sds_port_active_phy(sci_port, phy)
+			) {
+			return phy;
+		}
 	}
 
-	/* If the hard reset for the port has failed, consider this
-	 * the same as link failures on all phys in the port.
+	return NULL;
+}
+
+/**
+ * scic_sds_port_set_phy() -
+ * @out]: port The port object to which the phy assignement is being made.
+ * @out]: phy The phy which is being assigned to the port.
+ *
+ * This method attempts to make the assignment of the phy to the port. If
+ * successful the phy is assigned to the ports phy table. bool true if the phy
+ * assignment can be made. false if the phy assignement can not be made. This
+ * is a functional test that only fails if the phy is currently assigned to a
+ * different port.
+ */
+static enum sci_status scic_sds_port_set_phy(
+	struct scic_sds_port *port,
+	struct scic_sds_phy *phy)
+{
+	/*
+	 * Check to see if we can add this phy to a port
+	 * that means that the phy is not part of a port and that the port does
+	 * not already have a phy assinged to the phy index. */
+	if (
+		(port->phy_table[phy->phy_index] == NULL)
+		&& (scic_sds_phy_get_port(phy) == NULL)
+		&& scic_sds_port_is_valid_phy_assignment(port, phy->phy_index)
+		) {
+		/*
+		 * Phy is being added in the stopped state so we are in MPC mode
+		 * make logical port index = physical port index */
+		port->logical_port_index = port->physical_port_index;
+		port->phy_table[phy->phy_index] = phy;
+		scic_sds_phy_set_port(phy, port);
+
+		return SCI_SUCCESS;
+	}
+
+	return SCI_FAILURE;
+}
+
+/**
+ * scic_sds_port_clear_phy() -
+ * @out]: port The port from which the phy is being cleared.
+ * @out]: phy The phy being cleared from the port.
+ *
+ * This method will clear the phy assigned to this port.  This method fails if
+ * this phy is not currently assinged to this port. bool true if the phy is
+ * removed from the port. false if this phy is not assined to this port.
+ */
+static enum sci_status scic_sds_port_clear_phy(
+	struct scic_sds_port *port,
+	struct scic_sds_phy *phy)
+{
+	/* Make sure that this phy is part of this port */
+	if (port->phy_table[phy->phy_index] == phy &&
+	    scic_sds_phy_get_port(phy) == port) {
+		struct scic_sds_controller *scic = port->owning_controller;
+		struct isci_host *ihost = scic_to_ihost(scic);
+
+		/* Yep it is assigned to this port so remove it */
+		scic_sds_phy_set_port(phy, &ihost->ports[SCI_MAX_PORTS].sci);
+		port->phy_table[phy->phy_index] = NULL;
+		return SCI_SUCCESS;
+	}
+
+	return SCI_FAILURE;
+}
+
+/**
+ * scic_sds_port_add_phy() -
+ * @sci_port: This parameter specifies the port in which the phy will be added.
+ * @sci_phy: This parameter is the phy which is to be added to the port.
+ *
+ * This method will add a PHY to the selected port. This method returns an
+ * enum sci_status. SCI_SUCCESS the phy has been added to the port. Any other status
+ * is failre to add the phy to the port.
+ */
+enum sci_status scic_sds_port_add_phy(
+	struct scic_sds_port *sci_port,
+	struct scic_sds_phy *sci_phy)
+{
+	return sci_port->state_handlers->add_phy_handler(
+		       sci_port, sci_phy);
+}
+
+
+/**
+ * scic_sds_port_remove_phy() -
+ * @sci_port: This parameter specifies the port in which the phy will be added.
+ * @sci_phy: This parameter is the phy which is to be added to the port.
+ *
+ * This method will remove the PHY from the selected PORT. This method returns
+ * an enum sci_status. SCI_SUCCESS the phy has been removed from the port. Any other
+ * status is failre to add the phy to the port.
+ */
+enum sci_status scic_sds_port_remove_phy(
+	struct scic_sds_port *sci_port,
+	struct scic_sds_phy *sci_phy)
+{
+	return sci_port->state_handlers->remove_phy_handler(
+		       sci_port, sci_phy);
+}
+
+/**
+ * This method requests the SAS address for the supplied SAS port from the SCI
+ *    implementation.
+ * @sci_port: a handle corresponding to the SAS port for which to return the
+ *    SAS address.
+ * @sas_address: This parameter specifies a pointer to a SAS address structure
+ *    into which the core will copy the SAS address for the port.
+ *
+ */
+void scic_sds_port_get_sas_address(
+	struct scic_sds_port *sci_port,
+	struct sci_sas_address *sas_address)
+{
+	u32 index;
+
+	sas_address->high = 0;
+	sas_address->low  = 0;
+
+	for (index = 0; index < SCI_MAX_PHYS; index++) {
+		if (sci_port->phy_table[index] != NULL) {
+			scic_sds_phy_get_sas_address(sci_port->phy_table[index], sas_address);
+		}
+	}
+}
+
+/*
+ * This function requests the SAS address for the device directly attached to
+ *    this SAS port.
+ * @sci_port: a handle corresponding to the SAS port for which to return the
+ *    SAS address.
+ * @sas_address: This parameter specifies a pointer to a SAS address structure
+ *    into which the core will copy the SAS address for the device directly
+ *    attached to the port.
+ *
+ */
+void scic_sds_port_get_attached_sas_address(
+	struct scic_sds_port *sci_port,
+	struct sci_sas_address *sas_address)
+{
+	struct scic_sds_phy *sci_phy;
+
+	/*
+	 * Ensure that the phy is both part of the port and currently
+	 * connected to the remote end-point.
 	 */
-	if (ret != TMF_RESP_FUNC_COMPLETE) {
-		dev_err(&ihost->pdev->dev,
-			"%s: iport = %p; hard reset failed "
-			"(0x%x) - sending link down to libsas for phy %p\n",
-			__func__, iport, iport->hard_reset_status, iphy);
+	sci_phy = scic_sds_port_get_a_connected_phy(sci_port);
+	if (sci_phy) {
+		if (sci_phy->protocol != SCIC_SDS_PHY_PROTOCOL_SATA) {
+			scic_sds_phy_get_attached_sas_address(sci_phy,
+							      sas_address);
+		} else {
+			scic_sds_phy_get_sas_address(sci_phy, sas_address);
+			sas_address->low += sci_phy->phy_index;
+		}
+	} else {
+		sas_address->high = 0;
+		sas_address->low  = 0;
+	}
+}
 
-		isci_port_link_down(ihost, iphy, iport);
+/**
+ * scic_sds_port_construct_dummy_rnc() - create dummy rnc for si workaround
+ *
+ * @sci_port: logical port on which we need to create the remote node context
+ * @rni: remote node index for this remote node context.
+ *
+ * This routine will construct a dummy remote node context data structure
+ * This structure will be posted to the hardware to work around a scheduler
+ * error in the hardware.
+ */
+static void scic_sds_port_construct_dummy_rnc(struct scic_sds_port *sci_port, u16 rni)
+{
+	union scu_remote_node_context *rnc;
+
+	rnc = &sci_port->owning_controller->remote_node_context_table[rni];
+
+	memset(rnc, 0, sizeof(union scu_remote_node_context));
+
+	rnc->ssp.remote_sas_address_hi = 0;
+	rnc->ssp.remote_sas_address_lo = 0;
+
+	rnc->ssp.remote_node_index = rni;
+	rnc->ssp.remote_node_port_width = 1;
+	rnc->ssp.logical_port_index = sci_port->physical_port_index;
+
+	rnc->ssp.nexus_loss_timer_enable = false;
+	rnc->ssp.check_bit = false;
+	rnc->ssp.is_valid = true;
+	rnc->ssp.is_remote_node_context = true;
+	rnc->ssp.function_number = 0;
+	rnc->ssp.arbitration_wait_time = 0;
+}
+
+/**
+ * scic_sds_port_construct_dummy_task() - create dummy task for si workaround
+ * @sci_port The logical port on which we need to create the
+ *            remote node context.
+ *            context.
+ * @tci The remote node index for this remote node context.
+ *
+ * This routine will construct a dummy task context data structure.  This
+ * structure will be posted to the hardwre to work around a scheduler error
+ * in the hardware.
+ *
+ */
+static void scic_sds_port_construct_dummy_task(struct scic_sds_port *sci_port, u16 tci)
+{
+	struct scu_task_context *task_context;
+
+	task_context = scic_sds_controller_get_task_context_buffer(sci_port->owning_controller, tci);
+
+	memset(task_context, 0, sizeof(struct scu_task_context));
+
+	task_context->abort = 0;
+	task_context->priority = 0;
+	task_context->initiator_request = 1;
+	task_context->connection_rate = 1;
+	task_context->protocol_engine_index = 0;
+	task_context->logical_port_index = sci_port->physical_port_index;
+	task_context->protocol_type = SCU_TASK_CONTEXT_PROTOCOL_SSP;
+	task_context->task_index = scic_sds_io_tag_get_index(tci);
+	task_context->valid = SCU_TASK_CONTEXT_VALID;
+	task_context->context_type = SCU_TASK_CONTEXT_TYPE;
+
+	task_context->remote_node_index = sci_port->reserved_rni;
+	task_context->command_code = 0;
+
+	task_context->link_layer_control = 0;
+	task_context->do_not_dma_ssp_good_response = 1;
+	task_context->strict_ordering = 0;
+	task_context->control_frame = 0;
+	task_context->timeout_enable = 0;
+	task_context->block_guard_enable = 0;
+
+	task_context->address_modifier = 0;
+
+	task_context->task_phase = 0x01;
+}
+
+static void scic_sds_port_destroy_dummy_resources(struct scic_sds_port *sci_port)
+{
+	struct scic_sds_controller *scic = sci_port->owning_controller;
+
+	if (sci_port->reserved_tci != SCU_DUMMY_INDEX)
+		scic_controller_free_io_tag(scic, sci_port->reserved_tci);
+
+	if (sci_port->reserved_rni != SCU_DUMMY_INDEX)
+		scic_sds_remote_node_table_release_remote_node_index(&scic->available_remote_nodes,
+								     1, sci_port->reserved_rni);
+
+	sci_port->reserved_rni = SCU_DUMMY_INDEX;
+	sci_port->reserved_tci = SCU_DUMMY_INDEX;
+}
+
+/**
+ * This method performs initialization of the supplied port. Initialization
+ *    includes: - state machine initialization - member variable initialization
+ *    - configuring the phy_mask
+ * @sci_port:
+ * @transport_layer_registers:
+ * @port_task_scheduler_registers:
+ * @port_configuration_regsiter:
+ *
+ * enum sci_status SCI_FAILURE_UNSUPPORTED_PORT_CONFIGURATION This value is returned
+ * if the phy being added to the port
+ */
+enum sci_status scic_sds_port_initialize(
+	struct scic_sds_port *sci_port,
+	void __iomem *port_task_scheduler_registers,
+	void __iomem *port_configuration_regsiter,
+	void __iomem *viit_registers)
+{
+	sci_port->port_task_scheduler_registers  = port_task_scheduler_registers;
+	sci_port->port_pe_configuration_register = port_configuration_regsiter;
+	sci_port->viit_registers                 = viit_registers;
+
+	return SCI_SUCCESS;
+}
+
+/**
+ * scic_port_hard_reset() - perform port hard reset
+ * @port: a handle corresponding to the SAS port to be hard reset.
+ * @reset_timeout: This parameter specifies the number of milliseconds in which
+ *    the port reset operation should complete.
+ *
+ * The SCI User callback in scic_user_callbacks_t will only be called once for
+ * each phy in the SAS Port at completion of the hard reset sequence. Return a
+ * status indicating whether the hard reset started successfully. SCI_SUCCESS
+ * This value is returned if the hard reset operation started successfully.
+ */
+static enum sci_status scic_port_hard_reset(struct scic_sds_port *port,
+					    u32 reset_timeout)
+{
+	return port->state_handlers->reset_handler(
+		       port, reset_timeout);
+}
+
+/**
+ * This method assigns the direct attached device ID for this port.
+ *
+ * @param[in] sci_port The port for which the direct attached device id is to
+ *       be assigned.
+ * @param[in] device_id The direct attached device ID to assign to the port.
+ *       This will be the RNi for the device
+ */
+void scic_sds_port_setup_transports(
+	struct scic_sds_port *sci_port,
+	u32 device_id)
+{
+	u8 index;
+
+	for (index = 0; index < SCI_MAX_PHYS; index++) {
+		if (sci_port->active_phy_mask & (1 << index))
+			scic_sds_phy_setup_transport(sci_port->phy_table[index], device_id);
 	}
+}
 
-	return ret;
+/**
+ *
+ * @sci_port: This is the port on which the phy should be enabled.
+ * @sci_phy: This is the specific phy which to enable.
+ * @do_notify_user: This parameter specifies whether to inform the user (via
+ *    scic_cb_port_link_up()) as to the fact that a new phy as become ready.
+ *
+ * This function will activate the phy in the port.
+ * Activation includes: - adding
+ * the phy to the port - enabling the Protocol Engine in the silicon. -
+ * notifying the user that the link is up. none
+ */
+static void scic_sds_port_activate_phy(struct scic_sds_port *sci_port,
+				       struct scic_sds_phy *sci_phy,
+				       bool do_notify_user)
+{
+	struct scic_sds_controller *scic = sci_port->owning_controller;
+	struct isci_host *ihost = scic_to_ihost(scic);
+
+	if (sci_phy->protocol != SCIC_SDS_PHY_PROTOCOL_SATA)
+		scic_sds_phy_resume(sci_phy);
+
+	sci_port->active_phy_mask |= 1 << sci_phy->phy_index;
+
+	scic_sds_controller_clear_invalid_phy(scic, sci_phy);
+
+	if (do_notify_user == true)
+		isci_port_link_up(ihost, sci_port, sci_phy);
 }
 
-void isci_port_stop_complete(struct scic_sds_controller *scic,
-					  struct scic_sds_port *sci_port,
-					  enum sci_status completion_status)
+void scic_sds_port_deactivate_phy(struct scic_sds_port *sci_port,
+				  struct scic_sds_phy *sci_phy,
+				  bool do_notify_user)
 {
-	dev_dbg(&scic_to_ihost(scic)->pdev->dev, "Port stop complete\n");
+	struct scic_sds_controller *scic = scic_sds_port_get_controller(sci_port);
+	struct isci_port *iport = sci_port_to_iport(sci_port);
+	struct isci_host *ihost = scic_to_ihost(scic);
+	struct isci_phy *iphy = sci_phy_to_iphy(sci_phy);
+
+	sci_port->active_phy_mask &= ~(1 << sci_phy->phy_index);
+
+	sci_phy->max_negotiated_speed = SAS_LINK_RATE_UNKNOWN;
+
+	/* Re-assign the phy back to the LP as if it were a narrow port */
+	writel(sci_phy->phy_index,
+		&sci_port->port_pe_configuration_register[sci_phy->phy_index]);
+
+	if (do_notify_user == true)
+		isci_port_link_down(ihost, iphy, iport);
+}
+
+/**
+ *
+ * @sci_port: This is the port on which the phy should be disabled.
+ * @sci_phy: This is the specific phy which to disabled.
+ *
+ * This function will disable the phy and report that the phy is not valid for
+ * this port object. None
+ */
+static void scic_sds_port_invalid_link_up(struct scic_sds_port *sci_port,
+					  struct scic_sds_phy *sci_phy)
+{
+	struct scic_sds_controller *scic = sci_port->owning_controller;
+
+	/*
+	 * Check to see if we have alreay reported this link as bad and if
+	 * not go ahead and tell the SCI_USER that we have discovered an
+	 * invalid link.
+	 */
+	if ((scic->invalid_phy_mask & (1 << sci_phy->phy_index)) == 0) {
+		scic_sds_controller_set_invalid_phy(scic, sci_phy);
+		dev_warn(&scic_to_ihost(scic)->pdev->dev, "Invalid link up!\n");
+	}
+}
+
+/**
+ * scic_sds_port_general_link_up_handler - phy can be assigned to port?
+ * @sci_port: scic_sds_port object for which has a phy that has gone link up.
+ * @sci_phy: This is the struct scic_sds_phy object that has gone link up.
+ * @do_notify_user: This parameter specifies whether to inform the user (via
+ *    scic_cb_port_link_up()) as to the fact that a new phy as become ready.
+ *
+ * Determine if this phy can be assigned to this
+ * port . If the phy is not a valid PHY for
+ * this port then the function will notify the user. A PHY can only be
+ * part of a port if it's attached SAS ADDRESS is the same as all other PHYs in
+ * the same port. none
+ */
+static void scic_sds_port_general_link_up_handler(struct scic_sds_port *sci_port,
+						  struct scic_sds_phy *sci_phy,
+						  bool do_notify_user)
+{
+	struct sci_sas_address port_sas_address;
+	struct sci_sas_address phy_sas_address;
+
+	scic_sds_port_get_attached_sas_address(sci_port, &port_sas_address);
+	scic_sds_phy_get_attached_sas_address(sci_phy, &phy_sas_address);
+
+	/* If the SAS address of the new phy matches the SAS address of
+	 * other phys in the port OR this is the first phy in the port,
+	 * then activate the phy and allow it to be used for operations
+	 * in this port.
+	 */
+	if ((phy_sas_address.high == port_sas_address.high &&
+	     phy_sas_address.low  == port_sas_address.low) ||
+	    sci_port->active_phy_mask == 0) {
+		struct sci_base_state_machine *sm = &sci_port->state_machine;
+
+		scic_sds_port_activate_phy(sci_port, sci_phy, do_notify_user);
+		if (sm->current_state_id == SCI_BASE_PORT_STATE_RESETTING)
+			sci_base_state_machine_change_state(sm, SCI_BASE_PORT_STATE_READY);
+	} else
+		scic_sds_port_invalid_link_up(sci_port, sci_phy);
+}
+
+
+
+/**
+ * This method returns false if the port only has a single phy object assigned.
+ *     If there are no phys or more than one phy then the method will return
+ *    true.
+ * @sci_port: The port for which the wide port condition is to be checked.
+ *
+ * bool true Is returned if this is a wide ported port. false Is returned if
+ * this is a narrow port.
+ */
+static bool scic_sds_port_is_wide(struct scic_sds_port *sci_port)
+{
+	u32 index;
+	u32 phy_count = 0;
+
+	for (index = 0; index < SCI_MAX_PHYS; index++) {
+		if (sci_port->phy_table[index] != NULL) {
+			phy_count++;
+		}
+	}
+
+	return phy_count != 1;
+}
+
+/**
+ * This method is called by the PHY object when the link is detected. if the
+ *    port wants the PHY to continue on to the link up state then the port
+ *    layer must return true.  If the port object returns false the phy object
+ *    must halt its attempt to go link up.
+ * @sci_port: The port associated with the phy object.
+ * @sci_phy: The phy object that is trying to go link up.
+ *
+ * true if the phy object can continue to the link up condition. true Is
+ * returned if this phy can continue to the ready state. false Is returned if
+ * can not continue on to the ready state. This notification is in place for
+ * wide ports and direct attached phys.  Since there are no wide ported SATA
+ * devices this could become an invalid port configuration.
+ */
+bool scic_sds_port_link_detected(
+	struct scic_sds_port *sci_port,
+	struct scic_sds_phy *sci_phy)
+{
+	if ((sci_port->logical_port_index != SCIC_SDS_DUMMY_PORT) &&
+	    (sci_phy->protocol == SCIC_SDS_PHY_PROTOCOL_SATA) &&
+	    scic_sds_port_is_wide(sci_port)) {
+		scic_sds_port_invalid_link_up(sci_port, sci_phy);
+
+		return false;
+	}
+
+	return true;
+}
+
+/**
+ * This method is the entry point for the phy to inform the port that it is now
+ *    in a ready state
+ * @sci_port:
+ *
+ *
+ */
+void scic_sds_port_link_up(
+	struct scic_sds_port *sci_port,
+	struct scic_sds_phy *sci_phy)
+{
+	sci_phy->is_in_link_training = false;
+
+	sci_port->state_handlers->link_up_handler(sci_port, sci_phy);
+}
+
+/**
+ * This method is the entry point for the phy to inform the port that it is no
+ *    longer in a ready state
+ * @sci_port:
+ *
+ *
+ */
+void scic_sds_port_link_down(
+	struct scic_sds_port *sci_port,
+	struct scic_sds_phy *sci_phy)
+{
+	sci_port->state_handlers->link_down_handler(sci_port, sci_phy);
+}
+
+/**
+ * This method is called to start an IO request on this port.
+ * @sci_port:
+ * @sci_dev:
+ * @sci_req:
+ *
+ * enum sci_status
+ */
+enum sci_status scic_sds_port_start_io(
+	struct scic_sds_port *sci_port,
+	struct scic_sds_remote_device *sci_dev,
+	struct scic_sds_request *sci_req)
+{
+	return sci_port->state_handlers->start_io_handler(
+		       sci_port, sci_dev, sci_req);
+}
+
+/**
+ * This method is called to complete an IO request to the port.
+ * @sci_port:
+ * @sci_dev:
+ * @sci_req:
+ *
+ * enum sci_status
+ */
+enum sci_status scic_sds_port_complete_io(
+	struct scic_sds_port *sci_port,
+	struct scic_sds_remote_device *sci_dev,
+	struct scic_sds_request *sci_req)
+{
+	return sci_port->state_handlers->complete_io_handler(
+		       sci_port, sci_dev, sci_req);
+}
+
+/**
+ * This method is provided to timeout requests for port operations. Mostly its
+ *    for the port reset operation.
+ *
+ *
+ */
+static void scic_sds_port_timeout_handler(void *port)
+{
+	struct scic_sds_port *sci_port = port;
+	u32 current_state;
+
+	current_state = sci_base_state_machine_get_state(
+		&sci_port->state_machine);
+
+	if (current_state == SCI_BASE_PORT_STATE_RESETTING) {
+		/*
+		 * if the port is still in the resetting state then the
+		 * timeout fired before the reset completed.
+		 */
+		sci_base_state_machine_change_state(
+			&sci_port->state_machine,
+			SCI_BASE_PORT_STATE_FAILED);
+	} else if (current_state == SCI_BASE_PORT_STATE_STOPPED) {
+		/*
+		 * if the port is stopped then the start request failed
+		 * In this case stay in the stopped state.
+		 */
+		dev_err(sciport_to_dev(sci_port),
+			"%s: SCIC Port 0x%p failed to stop before tiemout.\n",
+			__func__,
+			sci_port);
+	} else if (current_state == SCI_BASE_PORT_STATE_STOPPING) {
+		/*
+		 * if the port is still stopping then the stop has not
+		 * completed
+		 */
+		isci_port_stop_complete(
+				scic_sds_port_get_controller(sci_port),
+				sci_port,
+				SCI_FAILURE_TIMEOUT);
+	} else {
+		/*
+		 * The port is in the ready state and we have a timer
+		 * reporting a timeout this should not happen.
+		 */
+		dev_err(sciport_to_dev(sci_port),
+			"%s: SCIC Port 0x%p is processing a timeout operation "
+			"in state %d.\n",
+			__func__,
+			sci_port,
+			current_state);
+	}
+}
+
+/* --------------------------------------------------------------------------- */
+
+/**
+ * This function updates the hardwares VIIT entry for this port.
+ *
+ *
+ */
+static void scic_sds_port_update_viit_entry(struct scic_sds_port *sci_port)
+{
+	struct sci_sas_address sas_address;
+
+	scic_sds_port_get_sas_address(sci_port, &sas_address);
+
+	writel(sas_address.high,
+		&sci_port->viit_registers->initiator_sas_address_hi);
+	writel(sas_address.low,
+		&sci_port->viit_registers->initiator_sas_address_lo);
+
+	/* This value get cleared just in case its not already cleared */
+	writel(0, &sci_port->viit_registers->reserved);
+
+	/* We are required to update the status register last */
+	writel(SCU_VIIT_ENTRY_ID_VIIT |
+	       SCU_VIIT_IPPT_INITIATOR |
+	       ((1 << sci_port->physical_port_index) << SCU_VIIT_ENTRY_LPVIE_SHIFT) |
+	       SCU_VIIT_STATUS_ALL_VALID,
+	       &sci_port->viit_registers->status);
+}
+
+/**
+ * This method returns the maximum allowed speed for data transfers on this
+ *    port.  This maximum allowed speed evaluates to the maximum speed of the
+ *    slowest phy in the port.
+ * @sci_port: This parameter specifies the port for which to retrieve the
+ *    maximum allowed speed.
+ *
+ * This method returns the maximum negotiated speed of the slowest phy in the
+ * port.
+ */
+enum sas_linkrate scic_sds_port_get_max_allowed_speed(
+	struct scic_sds_port *sci_port)
+{
+	u16 index;
+	enum sas_linkrate max_allowed_speed = SAS_LINK_RATE_6_0_GBPS;
+	struct scic_sds_phy *phy = NULL;
+
+	/*
+	 * Loop through all of the phys in this port and find the phy with the
+	 * lowest maximum link rate. */
+	for (index = 0; index < SCI_MAX_PHYS; index++) {
+		phy = sci_port->phy_table[index];
+		if (
+			(phy != NULL)
+			&& (scic_sds_port_active_phy(sci_port, phy) == true)
+			&& (phy->max_negotiated_speed < max_allowed_speed)
+			)
+			max_allowed_speed = phy->max_negotiated_speed;
+	}
+
+	return max_allowed_speed;
+}
+
+static void scic_port_enable_broadcast_change_notification(struct scic_sds_port *port)
+{
+	struct scic_sds_phy *phy;
+	u32 register_value;
+	u8 index;
+
+	/* Loop through all of the phys to enable BCN. */
+	for (index = 0; index < SCI_MAX_PHYS; index++) {
+		phy = port->phy_table[index];
+		if (phy != NULL) {
+			register_value =
+				readl(&phy->link_layer_registers->link_layer_control);
+
+			/* clear the bit by writing 1. */
+			writel(register_value,
+				&phy->link_layer_registers->link_layer_control);
+		}
+	}
+}
+
+/*
+ * ****************************************************************************
+ * *  READY SUBSTATE HANDLERS
+ * **************************************************************************** */
+
+/*
+ * This method is the general ready state stop handler for the struct scic_sds_port
+ * object.  This function will transition the ready substate machine to its
+ * final state. enum sci_status SCI_SUCCESS
+ */
+static enum sci_status scic_sds_port_ready_substate_stop_handler(
+	struct scic_sds_port *port)
+{
+	sci_base_state_machine_change_state(
+		&port->state_machine,
+		SCI_BASE_PORT_STATE_STOPPING
+		);
+
+	return SCI_SUCCESS;
+}
+
+/*
+ * This method is the general ready substate complete io handler for the
+ * struct scic_sds_port object.  This function decrments the outstanding request count
+ * for this port object. enum sci_status SCI_SUCCESS
+ */
+static enum sci_status scic_sds_port_ready_substate_complete_io_handler(
+	struct scic_sds_port *port,
+	struct scic_sds_remote_device *device,
+	struct scic_sds_request *io_request)
+{
+	scic_sds_port_decrement_request_count(port);
+
+	return SCI_SUCCESS;
+}
+
+static enum sci_status scic_sds_port_ready_substate_add_phy_handler(
+	struct scic_sds_port *port,
+	struct scic_sds_phy *phy)
+{
+	enum sci_status status;
+
+	status = scic_sds_port_set_phy(port, phy);
+
+	if (status == SCI_SUCCESS) {
+		scic_sds_port_general_link_up_handler(port, phy, true);
+
+		port->not_ready_reason = SCIC_PORT_NOT_READY_RECONFIGURING;
+
+		sci_base_state_machine_change_state(
+			&port->ready_substate_machine,
+			SCIC_SDS_PORT_READY_SUBSTATE_CONFIGURING
+			);
+	}
+
+	return status;
+}
+
+
+static enum sci_status scic_sds_port_ready_substate_remove_phy_handler(
+	struct scic_sds_port *port,
+	struct scic_sds_phy *phy)
+{
+	enum sci_status status;
+
+	status = scic_sds_port_clear_phy(port, phy);
+
+	if (status == SCI_SUCCESS) {
+		scic_sds_port_deactivate_phy(port, phy, true);
+
+		port->not_ready_reason = SCIC_PORT_NOT_READY_RECONFIGURING;
+
+		sci_base_state_machine_change_state(
+			&port->ready_substate_machine,
+			SCIC_SDS_PORT_READY_SUBSTATE_CONFIGURING
+			);
+	}
+
+	return status;
+}
+
+/*
+ * ****************************************************************************
+ * *  READY SUBSTATE WAITING HANDLERS
+ * **************************************************************************** */
+
+/**
+ *
+ * @sci_port: This is the struct scic_sds_port object that which has a phy that has
+ *    gone link up.
+ * @sci_phy: This is the struct scic_sds_phy object that has gone link up.
+ *
+ * This method is the ready waiting substate link up handler for the
+ * struct scic_sds_port object.  This methos will report the link up condition for
+ * this port and will transition to the ready operational substate. none
+ */
+static void scic_sds_port_ready_waiting_substate_link_up_handler(
+	struct scic_sds_port *sci_port,
+	struct scic_sds_phy *sci_phy)
+{
+	/*
+	 * Since this is the first phy going link up for the port we can just enable
+	 * it and continue. */
+	scic_sds_port_activate_phy(sci_port, sci_phy, true);
+
+	sci_base_state_machine_change_state(
+		&sci_port->ready_substate_machine,
+		SCIC_SDS_PORT_READY_SUBSTATE_OPERATIONAL
+		);
+}
+
+/*
+ * This method is the ready waiting substate start io handler for the
+ * struct scic_sds_port object. The port object can not accept new requests so the
+ * request is failed. enum sci_status SCI_FAILURE_INVALID_STATE
+ */
+static enum sci_status scic_sds_port_ready_waiting_substate_start_io_handler(
+	struct scic_sds_port *port,
+	struct scic_sds_remote_device *device,
+	struct scic_sds_request *io_request)
+{
+	return SCI_FAILURE_INVALID_STATE;
+}
+
+/*
+ * ****************************************************************************
+ * *  READY SUBSTATE OPERATIONAL HANDLERS
+ * **************************************************************************** */
+
+/*
+ * This method will casue the port to reset. enum sci_status SCI_SUCCESS
+ */
+static enum
+sci_status scic_sds_port_ready_operational_substate_reset_handler(
+		struct scic_sds_port *port,
+		u32 timeout)
+{
+	enum sci_status status = SCI_FAILURE_INVALID_PHY;
+	u32 phy_index;
+	struct scic_sds_phy *selected_phy = NULL;
+
+
+	/* Select a phy on which we can send the hard reset request. */
+	for (phy_index = 0;
+	     (phy_index < SCI_MAX_PHYS) && (selected_phy == NULL);
+	     phy_index++) {
+		selected_phy = port->phy_table[phy_index];
+
+		if ((selected_phy != NULL) &&
+		    !scic_sds_port_active_phy(port, selected_phy)) {
+			/*
+			 * We found a phy but it is not ready select
+			 * different phy
+			 */
+			selected_phy = NULL;
+		}
+	}
+
+	/* If we have a phy then go ahead and start the reset procedure */
+	if (selected_phy != NULL) {
+		status = scic_sds_phy_reset(selected_phy);
+
+		if (status == SCI_SUCCESS) {
+			isci_timer_start(port->timer_handle, timeout);
+			port->not_ready_reason =
+				SCIC_PORT_NOT_READY_HARD_RESET_REQUESTED;
+
+			sci_base_state_machine_change_state(
+					&port->state_machine,
+					SCI_BASE_PORT_STATE_RESETTING);
+		}
+	}
+
+	return status;
+}
+
+/**
+ * scic_sds_port_ready_operational_substate_link_up_handler() -
+ * @sci_port: This is the struct scic_sds_port object that which has a phy that has
+ *    gone link up.
+ * @sci_phy: This is the struct scic_sds_phy object that has gone link up.
+ *
+ * This method is the ready operational substate link up handler for the
+ * struct scic_sds_port object. This function notifies the SCI User that the phy has
+ * gone link up. none
+ */
+static void scic_sds_port_ready_operational_substate_link_up_handler(
+	struct scic_sds_port *sci_port,
+	struct scic_sds_phy *sci_phy)
+{
+	scic_sds_port_general_link_up_handler(sci_port, sci_phy, true);
+}
+
+/**
+ * scic_sds_port_ready_operational_substate_link_down_handler() -
+ * @sci_port: This is the struct scic_sds_port object that which has a phy that has
+ *    gone link down.
+ * @sci_phy: This is the struct scic_sds_phy object that has gone link down.
+ *
+ * This method is the ready operational substate link down handler for the
+ * struct scic_sds_port object. This function notifies the SCI User that the phy has
+ * gone link down and if this is the last phy in the port the port will change
+ * state to the ready waiting substate. none
+ */
+static void scic_sds_port_ready_operational_substate_link_down_handler(
+	struct scic_sds_port *sci_port,
+	struct scic_sds_phy *sci_phy)
+{
+	scic_sds_port_deactivate_phy(sci_port, sci_phy, true);
+
+	/*
+	 * If there are no active phys left in the port, then transition
+	 * the port to the WAITING state until such time as a phy goes
+	 * link up. */
+	if (sci_port->active_phy_mask == 0)
+		sci_base_state_machine_change_state(&sci_port->ready_substate_machine,
+						    SCIC_SDS_PORT_READY_SUBSTATE_WAITING);
+}
+
+/*
+ * This method is the ready operational substate start io handler for the
+ * struct scic_sds_port object.  This function incremetns the outstanding request
+ * count for this port object. enum sci_status SCI_SUCCESS
+ */
+static enum sci_status scic_sds_port_ready_operational_substate_start_io_handler(
+	struct scic_sds_port *port,
+	struct scic_sds_remote_device *device,
+	struct scic_sds_request *io_request)
+{
+	port->started_request_count++;
+	return SCI_SUCCESS;
+}
+
+/*
+ * ****************************************************************************
+ * *  READY SUBSTATE OPERATIONAL HANDLERS
+ * **************************************************************************** */
+
+/*
+ * This is the default method for a port add phy request.  It will report a
+ * warning and exit. enum sci_status SCI_FAILURE_INVALID_STATE
+ */
+static enum sci_status scic_sds_port_ready_configuring_substate_add_phy_handler(
+	struct scic_sds_port *port,
+	struct scic_sds_phy *phy)
+{
+	enum sci_status status;
+
+	status = scic_sds_port_set_phy(port, phy);
+
+	if (status == SCI_SUCCESS) {
+		scic_sds_port_general_link_up_handler(port, phy, true);
+
+		/*
+		 * Re-enter the configuring state since this may be the last phy in
+		 * the port. */
+		sci_base_state_machine_change_state(
+			&port->ready_substate_machine,
+			SCIC_SDS_PORT_READY_SUBSTATE_CONFIGURING
+			);
+	}
+
+	return status;
+}
+
+/*
+ * This is the default method for a port remove phy request.  It will report a
+ * warning and exit. enum sci_status SCI_FAILURE_INVALID_STATE
+ */
+static enum sci_status scic_sds_port_ready_configuring_substate_remove_phy_handler(
+	struct scic_sds_port *port,
+	struct scic_sds_phy *phy)
+{
+	enum sci_status status;
+
+	status = scic_sds_port_clear_phy(port, phy);
+
+	if (status == SCI_SUCCESS) {
+		scic_sds_port_deactivate_phy(port, phy, true);
+
+		/*
+		 * Re-enter the configuring state since this may be the last phy in
+		 * the port. */
+		sci_base_state_machine_change_state(
+			&port->ready_substate_machine,
+			SCIC_SDS_PORT_READY_SUBSTATE_CONFIGURING
+			);
+	}
+
+	return status;
+}
+
+/**
+ * scic_sds_port_ready_configuring_substate_complete_io_handler() -
+ * @port: This is the port that is being requested to complete the io request.
+ * @device: This is the device on which the io is completing.
+ *
+ * This method will decrement the outstanding request count for this port. If
+ * the request count goes to 0 then the port can be reprogrammed with its new
+ * phy data.
+ */
+static enum sci_status
+scic_sds_port_ready_configuring_substate_complete_io_handler(
+	struct scic_sds_port *port,
+	struct scic_sds_remote_device *device,
+	struct scic_sds_request *io_request)
+{
+	scic_sds_port_decrement_request_count(port);
+
+	if (port->started_request_count == 0) {
+		sci_base_state_machine_change_state(
+			&port->ready_substate_machine,
+			SCIC_SDS_PORT_READY_SUBSTATE_OPERATIONAL
+			);
+	}
+
+	return SCI_SUCCESS;
+}
+
+static enum sci_status default_port_handler(struct scic_sds_port *sci_port,
+					    const char *func)
+{
+	dev_warn(sciport_to_dev(sci_port),
+		 "%s: in wrong state: %d\n", func,
+		 sci_base_state_machine_get_state(&sci_port->state_machine));
+	return SCI_FAILURE_INVALID_STATE;
+}
+
+static enum sci_status
+scic_sds_port_default_start_handler(struct scic_sds_port *sci_port)
+{
+	return default_port_handler(sci_port, __func__);
+}
+
+static enum sci_status
+scic_sds_port_default_stop_handler(struct scic_sds_port *sci_port)
+{
+	return default_port_handler(sci_port, __func__);
+}
+
+static enum sci_status
+scic_sds_port_default_destruct_handler(struct scic_sds_port *sci_port)
+{
+	return default_port_handler(sci_port, __func__);
+}
+
+static enum sci_status
+scic_sds_port_default_reset_handler(struct scic_sds_port *sci_port,
+				    u32 timeout)
+{
+	return default_port_handler(sci_port, __func__);
+}
+
+static enum sci_status
+scic_sds_port_default_add_phy_handler(struct scic_sds_port *sci_port,
+				      struct scic_sds_phy *base_phy)
+{
+	return default_port_handler(sci_port, __func__);
+}
+
+static enum sci_status
+scic_sds_port_default_remove_phy_handler(struct scic_sds_port *sci_port,
+					 struct scic_sds_phy *base_phy)
+{
+	return default_port_handler(sci_port, __func__);
+}
+
+/*
+ * This is the default method for a port unsolicited frame request.  It will
+ * report a warning and exit. enum sci_status SCI_FAILURE_INVALID_STATE Is it even
+ * possible to receive an unsolicited frame directed to a port object?  It
+ * seems possible if we implementing virtual functions but until then?
+ */
+static enum sci_status
+scic_sds_port_default_frame_handler(struct scic_sds_port *sci_port,
+				    u32 frame_index)
+{
+	struct scic_sds_controller *scic = scic_sds_port_get_controller(sci_port);
+
+	default_port_handler(sci_port, __func__);
+	scic_sds_controller_release_frame(scic, frame_index);
+
+	return SCI_FAILURE_INVALID_STATE;
+}
+
+static enum sci_status scic_sds_port_default_event_handler(struct scic_sds_port *sci_port,
+						    u32 event_code)
+{
+	return default_port_handler(sci_port, __func__);
+}
+
+static void scic_sds_port_default_link_up_handler(struct scic_sds_port *sci_port,
+					   struct scic_sds_phy *sci_phy)
+{
+	default_port_handler(sci_port, __func__);
+}
+
+static void scic_sds_port_default_link_down_handler(struct scic_sds_port *sci_port,
+					     struct scic_sds_phy *sci_phy)
+{
+	default_port_handler(sci_port, __func__);
+}
+
+static enum sci_status scic_sds_port_default_start_io_handler(struct scic_sds_port *sci_port,
+						       struct scic_sds_remote_device *sci_dev,
+						       struct scic_sds_request *sci_req)
+{
+	return default_port_handler(sci_port, __func__);
+}
+
+static enum sci_status scic_sds_port_default_complete_io_handler(struct scic_sds_port *sci_port,
+								 struct scic_sds_remote_device *sci_dev,
+								 struct scic_sds_request *sci_req)
+{
+	return default_port_handler(sci_port, __func__);
+}
+
+
+
+static struct scic_sds_port_state_handler
+scic_sds_port_ready_substate_handler_table[SCIC_SDS_PORT_READY_MAX_SUBSTATES] = {
+	{
+		/* SCIC_SDS_PORT_READY_SUBSTATE_WAITING */
+		scic_sds_port_default_start_handler,
+		scic_sds_port_ready_substate_stop_handler,
+		scic_sds_port_default_destruct_handler,
+		scic_sds_port_default_reset_handler,
+		scic_sds_port_ready_substate_add_phy_handler,
+		scic_sds_port_default_remove_phy_handler,
+		scic_sds_port_default_frame_handler,
+		scic_sds_port_default_event_handler,
+		scic_sds_port_ready_waiting_substate_link_up_handler,
+		scic_sds_port_default_link_down_handler,
+		scic_sds_port_ready_waiting_substate_start_io_handler,
+		scic_sds_port_ready_substate_complete_io_handler,
+	},
+
+	{
+		/* SCIC_SDS_PORT_READY_SUBSTATE_OPERATIONAL */
+		scic_sds_port_default_start_handler,
+		scic_sds_port_ready_substate_stop_handler,
+		scic_sds_port_default_destruct_handler,
+		scic_sds_port_ready_operational_substate_reset_handler,
+		scic_sds_port_ready_substate_add_phy_handler,
+		scic_sds_port_ready_substate_remove_phy_handler,
+		scic_sds_port_default_frame_handler,
+		scic_sds_port_default_event_handler,
+		scic_sds_port_ready_operational_substate_link_up_handler,
+		scic_sds_port_ready_operational_substate_link_down_handler,
+		scic_sds_port_ready_operational_substate_start_io_handler,
+		scic_sds_port_ready_substate_complete_io_handler,
+	},
+
+	{
+		/* SCIC_SDS_PORT_READY_SUBSTATE_CONFIGURING */
+		scic_sds_port_default_start_handler,
+		scic_sds_port_ready_substate_stop_handler,
+		scic_sds_port_default_destruct_handler,
+		scic_sds_port_default_reset_handler,
+		scic_sds_port_ready_configuring_substate_add_phy_handler,
+		scic_sds_port_ready_configuring_substate_remove_phy_handler,
+		scic_sds_port_default_frame_handler,
+		scic_sds_port_default_event_handler,
+		scic_sds_port_default_link_up_handler,
+		scic_sds_port_default_link_down_handler,
+		scic_sds_port_default_start_io_handler,
+		scic_sds_port_ready_configuring_substate_complete_io_handler
+	}
+};
+
+/**
+ * scic_sds_port_set_ready_state_handlers() -
+ *
+ * This macro sets the port ready substate handlers.
+ */
+#define scic_sds_port_set_ready_state_handlers(port, state_id) \
+	scic_sds_port_set_state_handlers(\
+		port, &scic_sds_port_ready_substate_handler_table[(state_id)] \
+		)
+
+/*
+ * ******************************************************************************
+ * *  PORT STATE PRIVATE METHODS
+ * ****************************************************************************** */
+
+/**
+ *
+ * @sci_port: This is the struct scic_sds_port object to suspend.
+ *
+ * This method will susped the port task scheduler for this port object. none
+ */
+static void
+scic_sds_port_suspend_port_task_scheduler(struct scic_sds_port *port)
+{
+	u32 pts_control_value;
+
+	pts_control_value = readl(&port->port_task_scheduler_registers->control);
+	pts_control_value |= SCU_PTSxCR_GEN_BIT(SUSPEND);
+	writel(pts_control_value, &port->port_task_scheduler_registers->control);
+}
+
+/**
+ * scic_sds_port_post_dummy_request() - post dummy/workaround request
+ * @sci_port: port to post task
+ *
+ * Prevent the hardware scheduler from posting new requests to the front
+ * of the scheduler queue causing a starvation problem for currently
+ * ongoing requests.
+ *
+ */
+static void scic_sds_port_post_dummy_request(struct scic_sds_port *sci_port)
+{
+	u32 command;
+	struct scu_task_context *task_context;
+	struct scic_sds_controller *scic = sci_port->owning_controller;
+	u16 tci = sci_port->reserved_tci;
+
+	task_context = scic_sds_controller_get_task_context_buffer(scic, tci);
+
+	task_context->abort = 0;
+
+	command = SCU_CONTEXT_COMMAND_REQUEST_TYPE_POST_TC |
+		  sci_port->physical_port_index << SCU_CONTEXT_COMMAND_LOGICAL_PORT_SHIFT |
+		  tci;
+
+	scic_sds_controller_post_request(scic, command);
+}
+
+/**
+ * This routine will abort the dummy request.  This will alow the hardware to
+ * power down parts of the silicon to save power.
+ *
+ * @sci_port: The port on which the task must be aborted.
+ *
+ */
+static void scic_sds_port_abort_dummy_request(struct scic_sds_port *sci_port)
+{
+	struct scic_sds_controller *scic = sci_port->owning_controller;
+	u16 tci = sci_port->reserved_tci;
+	struct scu_task_context *tc;
+	u32 command;
+
+	tc = scic_sds_controller_get_task_context_buffer(scic, tci);
+
+	tc->abort = 1;
+
+	command = SCU_CONTEXT_COMMAND_REQUEST_POST_TC_ABORT |
+		  sci_port->physical_port_index << SCU_CONTEXT_COMMAND_LOGICAL_PORT_SHIFT |
+		  tci;
+
+	scic_sds_controller_post_request(scic, command);
+}
+
+/**
+ *
+ * @sci_port: This is the struct scic_sds_port object to resume.
+ *
+ * This method will resume the port task scheduler for this port object. none
+ */
+static void
+scic_sds_port_resume_port_task_scheduler(struct scic_sds_port *port)
+{
+	u32 pts_control_value;
+
+	pts_control_value = readl(&port->port_task_scheduler_registers->control);
+	pts_control_value &= ~SCU_PTSxCR_GEN_BIT(SUSPEND);
+	writel(pts_control_value, &port->port_task_scheduler_registers->control);
+}
+
+/*
+ * ******************************************************************************
+ * *  PORT READY SUBSTATE METHODS
+ * ****************************************************************************** */
+
+/**
+ *
+ * @object: This is the object which is cast to a struct scic_sds_port object.
+ *
+ * This method will perform the actions required by the struct scic_sds_port on
+ * entering the SCIC_SDS_PORT_READY_SUBSTATE_WAITING. This function checks the
+ * port for any ready phys.  If there is at least one phy in a ready state then
+ * the port transitions to the ready operational substate. none
+ */
+static void scic_sds_port_ready_substate_waiting_enter(void *object)
+{
+	struct scic_sds_port *sci_port = object;
+
+	scic_sds_port_set_ready_state_handlers(
+		sci_port, SCIC_SDS_PORT_READY_SUBSTATE_WAITING
+		);
+
+	scic_sds_port_suspend_port_task_scheduler(sci_port);
+
+	sci_port->not_ready_reason = SCIC_PORT_NOT_READY_NO_ACTIVE_PHYS;
+
+	if (sci_port->active_phy_mask != 0) {
+		/* At least one of the phys on the port is ready */
+		sci_base_state_machine_change_state(
+			&sci_port->ready_substate_machine,
+			SCIC_SDS_PORT_READY_SUBSTATE_OPERATIONAL
+			);
+	}
+}
+
+/**
+ *
+ * @object: This is the object which is cast to a struct scic_sds_port object.
+ *
+ * This function will perform the actions required by the struct scic_sds_port
+ * on entering the SCIC_SDS_PORT_READY_SUBSTATE_OPERATIONAL. This function sets
+ * the state handlers for the port object, notifies the SCI User that the port
+ * is ready, and resumes port operations. none
+ */
+static void scic_sds_port_ready_substate_operational_enter(void *object)
+{
+	u32 index;
+	struct scic_sds_port *sci_port = object;
+	struct scic_sds_controller *scic = sci_port->owning_controller;
+	struct isci_host *ihost = scic_to_ihost(scic);
+	struct isci_port *iport = sci_port_to_iport(sci_port);
+
+	scic_sds_port_set_ready_state_handlers(
+			sci_port,
+			SCIC_SDS_PORT_READY_SUBSTATE_OPERATIONAL);
+
+	isci_port_ready(ihost, iport);
+
+	for (index = 0; index < SCI_MAX_PHYS; index++) {
+		if (sci_port->phy_table[index]) {
+			writel(sci_port->physical_port_index,
+				&sci_port->port_pe_configuration_register[
+					sci_port->phy_table[index]->phy_index]);
+		}
+	}
+
+	scic_sds_port_update_viit_entry(sci_port);
+
+	scic_sds_port_resume_port_task_scheduler(sci_port);
+
+	/*
+	 * Post the dummy task for the port so the hardware can schedule
+	 * io correctly
+	 */
+	scic_sds_port_post_dummy_request(sci_port);
+}
+
+/**
+ *
+ * @object: This is the object which is cast to a struct scic_sds_port object.
+ *
+ * This method will perform the actions required by the struct scic_sds_port on
+ * exiting the SCIC_SDS_PORT_READY_SUBSTATE_OPERATIONAL. This function reports
+ * the port not ready and suspends the port task scheduler. none
+ */
+static void scic_sds_port_ready_substate_operational_exit(void *object)
+{
+	struct scic_sds_port *sci_port = object;
+	struct scic_sds_controller *scic = sci_port->owning_controller;
+	struct isci_host *ihost = scic_to_ihost(scic);
+	struct isci_port *iport = sci_port_to_iport(sci_port);
+
+	/*
+	 * Kill the dummy task for this port if it has not yet posted
+	 * the hardware will treat this as a NOP and just return abort
+	 * complete.
+	 */
+	scic_sds_port_abort_dummy_request(sci_port);
+
+	isci_port_not_ready(ihost, iport);
+}
+
+/*
+ * ******************************************************************************
+ * *  PORT READY CONFIGURING METHODS
+ * ****************************************************************************** */
+
+/**
+ * scic_sds_port_ready_substate_configuring_enter() -
+ * @object: This is the object which is cast to a struct scic_sds_port object.
+ *
+ * This method will perform the actions required by the struct scic_sds_port on
+ * exiting the SCIC_SDS_PORT_READY_SUBSTATE_OPERATIONAL. This function reports
+ * the port not ready and suspends the port task scheduler. none
+ */
+static void scic_sds_port_ready_substate_configuring_enter(void *object)
+{
+	struct scic_sds_port *sci_port = object;
+	struct scic_sds_controller *scic = sci_port->owning_controller;
+	struct isci_host *ihost = scic_to_ihost(scic);
+	struct isci_port *iport = sci_port_to_iport(sci_port);
+
+	scic_sds_port_set_ready_state_handlers(
+			sci_port,
+			SCIC_SDS_PORT_READY_SUBSTATE_CONFIGURING);
+
+	if (sci_port->active_phy_mask == 0) {
+		isci_port_not_ready(ihost, iport);
+
+		sci_base_state_machine_change_state(
+				&sci_port->ready_substate_machine,
+				SCIC_SDS_PORT_READY_SUBSTATE_WAITING);
+	} else if (sci_port->started_request_count == 0)
+		sci_base_state_machine_change_state(
+				&sci_port->ready_substate_machine,
+				SCIC_SDS_PORT_READY_SUBSTATE_OPERATIONAL);
+}
+
+static void scic_sds_port_ready_substate_configuring_exit(void *object)
+{
+	struct scic_sds_port *sci_port = object;
+
+	scic_sds_port_suspend_port_task_scheduler(sci_port);
+}
+
+/* --------------------------------------------------------------------------- */
+
+static const struct sci_base_state scic_sds_port_ready_substate_table[] = {
+	[SCIC_SDS_PORT_READY_SUBSTATE_WAITING] = {
+		.enter_state = scic_sds_port_ready_substate_waiting_enter,
+	},
+	[SCIC_SDS_PORT_READY_SUBSTATE_OPERATIONAL] = {
+		.enter_state = scic_sds_port_ready_substate_operational_enter,
+		.exit_state  = scic_sds_port_ready_substate_operational_exit
+	},
+	[SCIC_SDS_PORT_READY_SUBSTATE_CONFIGURING] = {
+		.enter_state = scic_sds_port_ready_substate_configuring_enter,
+		.exit_state  = scic_sds_port_ready_substate_configuring_exit
+	},
+};
+
+/**
+ *
+ * @port: This is the struct scic_sds_port object on which the io request count will
+ *    be decremented.
+ * @device: This is the struct scic_sds_remote_device object to which the io request
+ *    is being directed.  This parameter is not required to complete this
+ *    operation.
+ * @io_request: This is the request that is being completed on this port
+ *    object.  This parameter is not required to complete this operation.
+ *
+ * This is a general complete io request handler for the struct scic_sds_port object.
+ * enum sci_status SCI_SUCCESS
+ */
+static enum sci_status scic_sds_port_general_complete_io_handler(
+	struct scic_sds_port *port,
+	struct scic_sds_remote_device *device,
+	struct scic_sds_request *io_request)
+{
+	scic_sds_port_decrement_request_count(port);
+
+	return SCI_SUCCESS;
+}
+
+/**
+ * scic_sds_port_stopped_state_start_handler() - stop a port from "started"
+ *
+ * @port: This is the struct scic_sds_port object which is cast into a
+ * struct scic_sds_port object.
+ *
+ * This function takes the struct scic_sds_port from a stopped state and
+ * attempts to start it.  To start a port it must have no assiged devices and
+ * it must have at least one phy assigned to it.  If those conditions are
+ * met then the port can transition to the ready state.
+ * enum sci_status
+ * SCI_FAILURE_UNSUPPORTED_PORT_CONFIGURATION
+ * This struct scic_sds_port object could not be started because the port
+ * configuration is not valid.
+ * SCI_SUCCESS
+ * the start request is successful and the struct scic_sds_port object
+ * has transitioned to the SCI_BASE_PORT_STATE_READY.
+ */
+static enum sci_status
+scic_sds_port_stopped_state_start_handler(struct scic_sds_port *sci_port)
+{
+	struct scic_sds_controller *scic = sci_port->owning_controller;
+	struct isci_host *ihost = scic_to_ihost(scic);
+	enum sci_status status = SCI_SUCCESS;
+	u32 phy_mask;
+
+	if (sci_port->assigned_device_count > 0) {
+		/*
+		 * @todo This is a start failure operation because
+		 * there are still devices assigned to this port.
+		 * There must be no devices assigned to a port on a
+		 * start operation.
+		 */
+		return SCI_FAILURE_UNSUPPORTED_PORT_CONFIGURATION;
+	}
+
+	sci_port->timer_handle =
+		isci_timer_create(ihost,
+				  sci_port,
+				  scic_sds_port_timeout_handler);
+
+	if (!sci_port->timer_handle)
+		return SCI_FAILURE_INSUFFICIENT_RESOURCES;
+
+	if (sci_port->reserved_rni == SCU_DUMMY_INDEX) {
+		u16 rni = scic_sds_remote_node_table_allocate_remote_node(
+				&scic->available_remote_nodes, 1);
+
+		if (rni != SCU_DUMMY_INDEX)
+			scic_sds_port_construct_dummy_rnc(sci_port, rni);
+		else
+			status = SCI_FAILURE_INSUFFICIENT_RESOURCES;
+		sci_port->reserved_rni = rni;
+	}
+
+	if (sci_port->reserved_tci == SCU_DUMMY_INDEX) {
+		/* Allocate a TCI and remove the sequence nibble */
+		u16 tci = scic_controller_allocate_io_tag(scic);
+
+		if (tci != SCU_DUMMY_INDEX)
+			scic_sds_port_construct_dummy_task(sci_port, tci);
+		else
+			status = SCI_FAILURE_INSUFFICIENT_RESOURCES;
+		sci_port->reserved_tci = tci;
+	}
+
+	if (status == SCI_SUCCESS) {
+		phy_mask = scic_sds_port_get_phys(sci_port);
+
+		/*
+		 * There are one or more phys assigned to this port.  Make sure
+		 * the port's phy mask is in fact legal and supported by the
+		 * silicon.
+		 */
+		if (scic_sds_port_is_phy_mask_valid(sci_port, phy_mask) == true) {
+			sci_base_state_machine_change_state(
+				&sci_port->state_machine,
+				SCI_BASE_PORT_STATE_READY);
+
+			return SCI_SUCCESS;
+		} else
+			status = SCI_FAILURE;
+	}
+
+	if (status != SCI_SUCCESS)
+		scic_sds_port_destroy_dummy_resources(sci_port);
+
+	return status;
+}
+
+/*
+ * This method takes the struct scic_sds_port that is in a stopped state and handles a
+ * stop request.  This function takes no action. enum sci_status SCI_SUCCESS the
+ * stop request is successful as the struct scic_sds_port object is already stopped.
+ */
+static enum sci_status scic_sds_port_stopped_state_stop_handler(
+	struct scic_sds_port *port)
+{
+	/* We are already stopped so there is nothing to do here */
+	return SCI_SUCCESS;
+}
+
+/*
+ * This method takes the struct scic_sds_port that is in a stopped state and handles
+ * the destruct request.  The stopped state is the only state in which the
+ * struct scic_sds_port can be destroyed.  This function causes the port object to
+ * transition to the SCI_BASE_PORT_STATE_FINAL. enum sci_status SCI_SUCCESS
+ */
+static enum sci_status scic_sds_port_stopped_state_destruct_handler(
+	struct scic_sds_port *port)
+{
+	sci_base_state_machine_stop(&port->state_machine);
+
+	return SCI_SUCCESS;
+}
+
+/*
+ * This method takes the struct scic_sds_port that is in a stopped state and handles
+ * the add phy request.  In MPC mode the only time a phy can be added to a port
+ * is in the SCI_BASE_PORT_STATE_STOPPED. enum sci_status
+ * SCI_FAILURE_UNSUPPORTED_PORT_CONFIGURATION is returned when the phy can not
+ * be added to the port. SCI_SUCCESS if the phy is added to the port.
+ */
+static enum sci_status scic_sds_port_stopped_state_add_phy_handler(
+	struct scic_sds_port *port,
+	struct scic_sds_phy *phy)
+{
+	struct sci_sas_address port_sas_address;
+
+	/* Read the port assigned SAS Address if there is one */
+	scic_sds_port_get_sas_address(port, &port_sas_address);
+
+	if (port_sas_address.high != 0 && port_sas_address.low != 0) {
+		struct sci_sas_address phy_sas_address;
+
+		/*
+		 * Make sure that the PHY SAS Address matches the SAS Address
+		 * for this port. */
+		scic_sds_phy_get_sas_address(phy, &phy_sas_address);
+
+		if (
+			(port_sas_address.high != phy_sas_address.high)
+			|| (port_sas_address.low  != phy_sas_address.low)
+			) {
+			return SCI_FAILURE_UNSUPPORTED_PORT_CONFIGURATION;
+		}
+	}
+
+	return scic_sds_port_set_phy(port, phy);
+}
+
+/*
+ * This method takes the struct scic_sds_port that is in a stopped state and handles
+ * the remove phy request.  In MPC mode the only time a phy can be removed from
+ * a port is in the SCI_BASE_PORT_STATE_STOPPED. enum sci_status
+ * SCI_FAILURE_UNSUPPORTED_PORT_CONFIGURATION is returned when the phy can not
+ * be added to the port. SCI_SUCCESS if the phy is added to the port.
+ */
+static enum sci_status scic_sds_port_stopped_state_remove_phy_handler(
+	struct scic_sds_port *port,
+	struct scic_sds_phy *phy)
+{
+	return scic_sds_port_clear_phy(port, phy);
+}
+
+/*
+ * ****************************************************************************
+ * *  READY STATE HANDLERS
+ * **************************************************************************** */
+
+/*
+ * ****************************************************************************
+ * *  RESETTING STATE HANDLERS
+ * **************************************************************************** */
+
+/*
+ * ****************************************************************************
+ * *  STOPPING STATE HANDLERS
+ * **************************************************************************** */
+
+/*
+ * This method takes the struct scic_sds_port that is in a stopping state and handles
+ * the complete io request. Should the request count reach 0 then the port
+ * object will transition to the stopped state. enum sci_status SCI_SUCCESS
+ */
+static enum sci_status scic_sds_port_stopping_state_complete_io_handler(
+	struct scic_sds_port *sci_port,
+	struct scic_sds_remote_device *device,
+	struct scic_sds_request *io_request)
+{
+	scic_sds_port_decrement_request_count(sci_port);
+
+	if (sci_port->started_request_count == 0) {
+		sci_base_state_machine_change_state(&sci_port->state_machine,
+						    SCI_BASE_PORT_STATE_STOPPED);
+	}
+
+	return SCI_SUCCESS;
+}
+
+/*
+ * ****************************************************************************
+ * *  RESETTING STATE HANDLERS
+ * **************************************************************************** */
+
+/**
+ *
+ * @port: This is the port object which is being requested to stop.
+ *
+ * This method will stop a failed port.  This causes a transition to the
+ * stopping state. enum sci_status SCI_SUCCESS
+ */
+static enum sci_status scic_sds_port_reset_state_stop_handler(
+	struct scic_sds_port *port)
+{
+	sci_base_state_machine_change_state(
+		&port->state_machine,
+		SCI_BASE_PORT_STATE_STOPPING
+		);
+
+	return SCI_SUCCESS;
+}
+
+/*
+ * This method will transition a failed port to its ready state.  The port
+ * failed because a hard reset request timed out but at some time later one or
+ * more phys in the port became ready. enum sci_status SCI_SUCCESS
+ */
+static void scic_sds_port_reset_state_link_up_handler(
+	struct scic_sds_port *port,
+	struct scic_sds_phy *phy)
+{
+	/*
+	 * / @todo We should make sure that the phy that has gone link up is the same
+	 * /       one on which we sent the reset.  It is possible that the phy on
+	 * /       which we sent the reset is not the one that has gone link up and we
+	 * /       want to make sure that phy being reset comes back.  Consider the
+	 * /       case where a reset is sent but before the hardware processes the
+	 * /       reset it get a link up on the port because of a hot plug event.
+	 * /       because of the reset request this phy will go link down almost
+	 * /       immediately. */
+
+	/*
+	 * In the resetting state we don't notify the user regarding
+	 * link up and link down notifications. */
+	scic_sds_port_general_link_up_handler(port, phy, false);
+}
+
+/*
+ * This method process link down notifications that occur during a port reset
+ * operation. Link downs can occur during the reset operation. enum sci_status
+ * SCI_SUCCESS
+ */
+static void scic_sds_port_reset_state_link_down_handler(
+	struct scic_sds_port *port,
+	struct scic_sds_phy *phy)
+{
+	/*
+	 * In the resetting state we don't notify the user regarding
+	 * link up and link down notifications. */
+	scic_sds_port_deactivate_phy(port, phy, false);
+}
+
+static struct scic_sds_port_state_handler
+scic_sds_port_state_handler_table[SCI_BASE_PORT_MAX_STATES] =
+{
+	/* SCI_BASE_PORT_STATE_STOPPED */
+	{
+		scic_sds_port_stopped_state_start_handler,
+		scic_sds_port_stopped_state_stop_handler,
+		scic_sds_port_stopped_state_destruct_handler,
+		scic_sds_port_default_reset_handler,
+		scic_sds_port_stopped_state_add_phy_handler,
+		scic_sds_port_stopped_state_remove_phy_handler,
+		scic_sds_port_default_frame_handler,
+		scic_sds_port_default_event_handler,
+		scic_sds_port_default_link_up_handler,
+		scic_sds_port_default_link_down_handler,
+		scic_sds_port_default_start_io_handler,
+		scic_sds_port_default_complete_io_handler
+	},
+	/* SCI_BASE_PORT_STATE_STOPPING */
+	{
+		scic_sds_port_default_start_handler,
+		scic_sds_port_default_stop_handler,
+		scic_sds_port_default_destruct_handler,
+		scic_sds_port_default_reset_handler,
+		scic_sds_port_default_add_phy_handler,
+		scic_sds_port_default_remove_phy_handler,
+		scic_sds_port_default_frame_handler,
+		scic_sds_port_default_event_handler,
+		scic_sds_port_default_link_up_handler,
+		scic_sds_port_default_link_down_handler,
+		scic_sds_port_default_start_io_handler,
+		scic_sds_port_stopping_state_complete_io_handler
+	},
+	/* SCI_BASE_PORT_STATE_READY */
+	{
+		scic_sds_port_default_start_handler,
+		scic_sds_port_default_stop_handler,
+		scic_sds_port_default_destruct_handler,
+		scic_sds_port_default_reset_handler,
+		scic_sds_port_default_add_phy_handler,
+		scic_sds_port_default_remove_phy_handler,
+		scic_sds_port_default_frame_handler,
+		scic_sds_port_default_event_handler,
+		scic_sds_port_default_link_up_handler,
+		scic_sds_port_default_link_down_handler,
+		scic_sds_port_default_start_io_handler,
+		scic_sds_port_general_complete_io_handler
+	},
+	/* SCI_BASE_PORT_STATE_RESETTING */
+	{
+		scic_sds_port_default_start_handler,
+		scic_sds_port_reset_state_stop_handler,
+		scic_sds_port_default_destruct_handler,
+		scic_sds_port_default_reset_handler,
+		scic_sds_port_default_add_phy_handler,
+		scic_sds_port_default_remove_phy_handler,
+		scic_sds_port_default_frame_handler,
+		scic_sds_port_default_event_handler,
+		scic_sds_port_reset_state_link_up_handler,
+		scic_sds_port_reset_state_link_down_handler,
+		scic_sds_port_default_start_io_handler,
+		scic_sds_port_general_complete_io_handler
+	},
+	/* SCI_BASE_PORT_STATE_FAILED */
+	{
+		scic_sds_port_default_start_handler,
+		scic_sds_port_default_stop_handler,
+		scic_sds_port_default_destruct_handler,
+		scic_sds_port_default_reset_handler,
+		scic_sds_port_default_add_phy_handler,
+		scic_sds_port_default_remove_phy_handler,
+		scic_sds_port_default_frame_handler,
+		scic_sds_port_default_event_handler,
+		scic_sds_port_default_link_up_handler,
+		scic_sds_port_default_link_down_handler,
+		scic_sds_port_default_start_io_handler,
+		scic_sds_port_general_complete_io_handler
+	}
+};
+
+/*
+ * ******************************************************************************
+ * *  PORT STATE PRIVATE METHODS
+ * ****************************************************************************** */
+
+/**
+ *
+ * @sci_port: This is the port object which to suspend.
+ *
+ * This method will enable the SCU Port Task Scheduler for this port object but
+ * will leave the port task scheduler in a suspended state. none
+ */
+static void
+scic_sds_port_enable_port_task_scheduler(struct scic_sds_port *port)
+{
+	u32 pts_control_value;
+
+	pts_control_value = readl(&port->port_task_scheduler_registers->control);
+	pts_control_value |= SCU_PTSxCR_GEN_BIT(ENABLE) | SCU_PTSxCR_GEN_BIT(SUSPEND);
+	writel(pts_control_value, &port->port_task_scheduler_registers->control);
+}
+
+/**
+ *
+ * @sci_port: This is the port object which to resume.
+ *
+ * This method will disable the SCU port task scheduler for this port object.
+ * none
+ */
+static void
+scic_sds_port_disable_port_task_scheduler(struct scic_sds_port *port)
+{
+	u32 pts_control_value;
+
+	pts_control_value = readl(&port->port_task_scheduler_registers->control);
+	pts_control_value &=
+		~(SCU_PTSxCR_GEN_BIT(ENABLE) | SCU_PTSxCR_GEN_BIT(SUSPEND));
+	writel(pts_control_value, &port->port_task_scheduler_registers->control);
+}
+
+static void scic_sds_port_post_dummy_remote_node(struct scic_sds_port *sci_port)
+{
+	struct scic_sds_controller *scic = sci_port->owning_controller;
+	u8 phys_index = sci_port->physical_port_index;
+	union scu_remote_node_context *rnc;
+	u16 rni = sci_port->reserved_rni;
+	u32 command;
+
+	rnc = &scic->remote_node_context_table[rni];
+	rnc->ssp.is_valid = true;
+
+	command = SCU_CONTEXT_COMMAND_POST_RNC_32 |
+		  phys_index << SCU_CONTEXT_COMMAND_LOGICAL_PORT_SHIFT | rni;
+
+	scic_sds_controller_post_request(scic, command);
+
+	/* ensure hardware has seen the post rnc command and give it
+	 * ample time to act before sending the suspend
+	 */
+	readl(&scic->smu_registers->interrupt_status); /* flush */
+	udelay(10);
+
+	command = SCU_CONTEXT_COMMAND_POST_RNC_SUSPEND_TX_RX |
+		  phys_index << SCU_CONTEXT_COMMAND_LOGICAL_PORT_SHIFT | rni;
+
+	scic_sds_controller_post_request(scic, command);
+}
+
+static void scic_sds_port_invalidate_dummy_remote_node(struct scic_sds_port *sci_port)
+{
+	struct scic_sds_controller *scic = sci_port->owning_controller;
+	u8 phys_index = sci_port->physical_port_index;
+	union scu_remote_node_context *rnc;
+	u16 rni = sci_port->reserved_rni;
+	u32 command;
+
+	rnc = &scic->remote_node_context_table[rni];
+
+	rnc->ssp.is_valid = false;
+
+	/* ensure the preceding tc abort request has reached the
+	 * controller and give it ample time to act before posting the rnc
+	 * invalidate
+	 */
+	readl(&scic->smu_registers->interrupt_status); /* flush */
+	udelay(10);
+
+	command = SCU_CONTEXT_COMMAND_POST_RNC_INVALIDATE |
+		  phys_index << SCU_CONTEXT_COMMAND_LOGICAL_PORT_SHIFT | rni;
+
+	scic_sds_controller_post_request(scic, command);
+}
+
+/*
+ * ******************************************************************************
+ * *  PORT STATE METHODS
+ * ****************************************************************************** */
+
+/**
+ *
+ * @object: This is the object which is cast to a struct scic_sds_port object.
+ *
+ * This method will perform the actions required by the struct scic_sds_port on
+ * entering the SCI_BASE_PORT_STATE_STOPPED. This function sets the stopped
+ * state handlers for the struct scic_sds_port object and disables the port task
+ * scheduler in the hardware. none
+ */
+static void scic_sds_port_stopped_state_enter(void *object)
+{
+	struct scic_sds_port *sci_port = object;
+
+	scic_sds_port_set_base_state_handlers(
+		sci_port, SCI_BASE_PORT_STATE_STOPPED
+		);
+
+	if (
+		SCI_BASE_PORT_STATE_STOPPING
+		== sci_port->state_machine.previous_state_id
+		) {
+		/*
+		 * If we enter this state becasuse of a request to stop
+		 * the port then we want to disable the hardwares port
+		 * task scheduler. */
+		scic_sds_port_disable_port_task_scheduler(sci_port);
+	}
+}
+
+/**
+ *
+ * @object: This is the object which is cast to a struct scic_sds_port object.
+ *
+ * This method will perform the actions required by the struct scic_sds_port on
+ * exiting the SCI_BASE_STATE_STOPPED. This function enables the SCU hardware
+ * port task scheduler. none
+ */
+static void scic_sds_port_stopped_state_exit(void *object)
+{
+	struct scic_sds_port *sci_port = object;
+
+	/* Enable and suspend the port task scheduler */
+	scic_sds_port_enable_port_task_scheduler(sci_port);
+}
+
+/**
+ * scic_sds_port_ready_state_enter -
+ * @object: This is the object which is cast to a struct scic_sds_port object.
+ *
+ * This method will perform the actions required by the struct scic_sds_port on
+ * entering the SCI_BASE_PORT_STATE_READY. This function sets the ready state
+ * handlers for the struct scic_sds_port object, reports the port object as
+ * not ready and starts the ready substate machine. none
+ */
+static void scic_sds_port_ready_state_enter(void *object)
+{
+	struct scic_sds_port *sci_port = object;
+	struct scic_sds_controller *scic = sci_port->owning_controller;
+	struct isci_host *ihost = scic_to_ihost(scic);
+	struct isci_port *iport = sci_port_to_iport(sci_port);
+	u32 prev_state;
+
+	/* Put the ready state handlers in place though they will not be there long */
+	scic_sds_port_set_base_state_handlers(sci_port, SCI_BASE_PORT_STATE_READY);
+
+	prev_state = sci_port->state_machine.previous_state_id;
+	if (prev_state  == SCI_BASE_PORT_STATE_RESETTING)
+		isci_port_hard_reset_complete(iport, SCI_SUCCESS);
+	else
+		isci_port_not_ready(ihost, iport);
+
+	/* Post and suspend the dummy remote node context for this port. */
+	scic_sds_port_post_dummy_remote_node(sci_port);
+
+	/* Start the ready substate machine */
+	sci_base_state_machine_start(&sci_port->ready_substate_machine);
+}
+
+static void scic_sds_port_ready_state_exit(void *object)
+{
+	struct scic_sds_port *sci_port = object;
+
+	sci_base_state_machine_stop(&sci_port->ready_substate_machine);
+	scic_sds_port_invalidate_dummy_remote_node(sci_port);
+}
+
+/**
+ *
+ * @object: This is the object which is cast to a struct scic_sds_port object.
+ *
+ * This method will perform the actions required by the struct scic_sds_port on
+ * entering the SCI_BASE_PORT_STATE_RESETTING. This function sets the resetting
+ * state handlers for the struct scic_sds_port object. none
+ */
+static void scic_sds_port_resetting_state_enter(void *object)
+{
+	struct scic_sds_port *sci_port = object;
+
+	scic_sds_port_set_base_state_handlers(
+		sci_port, SCI_BASE_PORT_STATE_RESETTING
+		);
+}
+
+/**
+ *
+ * @object: This is the object which is cast to a struct scic_sds_port object.
+ *
+ * This function will perform the actions required by the
+ * struct scic_sds_port on
+ * exiting the SCI_BASE_STATE_RESETTING. This function does nothing. none
+ */
+static inline void scic_sds_port_resetting_state_exit(void *object)
+{
+	struct scic_sds_port *sci_port = object;
+
+	isci_timer_stop(sci_port->timer_handle);
+}
+
+/**
+ *
+ * @object: This is the void object which is cast to a
+ * struct scic_sds_port object.
+ *
+ * This method will perform the actions required by the struct scic_sds_port on
+ * entering the SCI_BASE_PORT_STATE_STOPPING. This function sets the stopping
+ * state handlers for the struct scic_sds_port object. none
+ */
+static void scic_sds_port_stopping_state_enter(void *object)
+{
+	struct scic_sds_port *sci_port = object;
+
+	scic_sds_port_set_base_state_handlers(
+		sci_port, SCI_BASE_PORT_STATE_STOPPING
+		);
+}
+
+/**
+ *
+ * @object: This is the object which is cast to a struct scic_sds_port object.
+ *
+ * This function will perform the actions required by the
+ * struct scic_sds_port on
+ * exiting the SCI_BASE_STATE_STOPPING. This function does nothing. none
+ */
+static inline void
+scic_sds_port_stopping_state_exit(void *object)
+{
+	struct scic_sds_port *sci_port = object;
+
+	isci_timer_stop(sci_port->timer_handle);
+
+	scic_sds_port_destroy_dummy_resources(sci_port);
+}
+
+/**
+ *
+ * @object: This is the object which is cast to a struct scic_sds_port object.
+ *
+ * This function will perform the actions required by the
+ * struct scic_sds_port on
+ * entering the SCI_BASE_PORT_STATE_STOPPING. This function sets the stopping
+ * state handlers for the struct scic_sds_port object. none
+ */
+static void scic_sds_port_failed_state_enter(void *object)
+{
+	struct scic_sds_port *sci_port = object;
+	struct isci_port *iport = sci_port_to_iport(sci_port);
+
+	scic_sds_port_set_base_state_handlers(sci_port,
+					      SCI_BASE_PORT_STATE_FAILED);
+
+	isci_port_hard_reset_complete(iport, SCI_FAILURE_TIMEOUT);
+}
+
+/* --------------------------------------------------------------------------- */
+
+static const struct sci_base_state scic_sds_port_state_table[] = {
+	[SCI_BASE_PORT_STATE_STOPPED] = {
+		.enter_state = scic_sds_port_stopped_state_enter,
+		.exit_state  = scic_sds_port_stopped_state_exit
+	},
+	[SCI_BASE_PORT_STATE_STOPPING] = {
+		.enter_state = scic_sds_port_stopping_state_enter,
+		.exit_state  = scic_sds_port_stopping_state_exit
+	},
+	[SCI_BASE_PORT_STATE_READY] = {
+		.enter_state = scic_sds_port_ready_state_enter,
+		.exit_state  = scic_sds_port_ready_state_exit
+	},
+	[SCI_BASE_PORT_STATE_RESETTING] = {
+		.enter_state = scic_sds_port_resetting_state_enter,
+		.exit_state  = scic_sds_port_resetting_state_exit
+	},
+	[SCI_BASE_PORT_STATE_FAILED] = {
+		.enter_state = scic_sds_port_failed_state_enter,
+	}
+};
+
+void scic_sds_port_construct(struct scic_sds_port *sci_port, u8 index,
+			     struct scic_sds_controller *scic)
+{
+	sci_base_state_machine_construct(&sci_port->state_machine,
+					 sci_port,
+					 scic_sds_port_state_table,
+					 SCI_BASE_PORT_STATE_STOPPED);
+
+	sci_base_state_machine_start(&sci_port->state_machine);
+
+	sci_base_state_machine_construct(&sci_port->ready_substate_machine,
+					 sci_port,
+					 scic_sds_port_ready_substate_table,
+					 SCIC_SDS_PORT_READY_SUBSTATE_WAITING);
+
+	sci_port->logical_port_index  = SCIC_SDS_DUMMY_PORT;
+	sci_port->physical_port_index = index;
+	sci_port->active_phy_mask     = 0;
+
+	sci_port->owning_controller = scic;
+
+	sci_port->started_request_count = 0;
+	sci_port->assigned_device_count = 0;
+
+	sci_port->reserved_rni = SCU_DUMMY_INDEX;
+	sci_port->reserved_tci = SCU_DUMMY_INDEX;
+
+	sci_port->timer_handle = NULL;
+	sci_port->port_task_scheduler_registers = NULL;
+
+	for (index = 0; index < SCI_MAX_PHYS; index++)
+		sci_port->phy_table[index] = NULL;
+}
+
+void isci_port_init(struct isci_port *iport, struct isci_host *ihost, int index)
+{
+	INIT_LIST_HEAD(&iport->remote_dev_list);
+	INIT_LIST_HEAD(&iport->domain_dev_list);
+	spin_lock_init(&iport->state_lock);
+	init_completion(&iport->start_complete);
+	iport->isci_host = ihost;
+	isci_port_change_state(iport, isci_freed);
+}
+
+/**
+ * isci_port_get_state() - This function gets the status of the port object.
+ * @isci_port: This parameter points to the isci_port object
+ *
+ * status of the object as a isci_status enum.
+ */
+enum isci_status isci_port_get_state(
+	struct isci_port *isci_port)
+{
+	return isci_port->status;
+}
+
+static void isci_port_bc_change_received(struct isci_host *ihost,
+					 struct scic_sds_port *sci_port,
+					 struct scic_sds_phy *sci_phy)
+{
+	struct isci_phy *iphy = sci_phy_to_iphy(sci_phy);
+
+	dev_dbg(&ihost->pdev->dev, "%s: iphy = %p, sas_phy = %p\n",
+		__func__, iphy, &iphy->sas_phy);
+
+	ihost->sas_ha.notify_port_event(&iphy->sas_phy, PORTE_BROADCAST_RCVD);
+	scic_port_enable_broadcast_change_notification(sci_port);
+}
+
+void scic_sds_port_broadcast_change_received(
+	struct scic_sds_port *sci_port,
+	struct scic_sds_phy *sci_phy)
+{
+	struct scic_sds_controller *scic = sci_port->owning_controller;
+	struct isci_host *ihost = scic_to_ihost(scic);
+
+	/* notify the user. */
+	isci_port_bc_change_received(ihost, sci_port, sci_phy);
+}
+
+int isci_port_perform_hard_reset(struct isci_host *ihost, struct isci_port *iport,
+				 struct isci_phy *iphy)
+{
+	unsigned long flags;
+	enum sci_status status;
+	int ret = TMF_RESP_FUNC_COMPLETE;
+
+	dev_dbg(&ihost->pdev->dev, "%s: iport = %p\n",
+		__func__, iport);
+
+	init_completion(&iport->hard_reset_complete);
+
+	spin_lock_irqsave(&ihost->scic_lock, flags);
+
+	#define ISCI_PORT_RESET_TIMEOUT SCIC_SDS_SIGNATURE_FIS_TIMEOUT
+	status = scic_port_hard_reset(&iport->sci, ISCI_PORT_RESET_TIMEOUT);
+
+	spin_unlock_irqrestore(&ihost->scic_lock, flags);
+
+	if (status == SCI_SUCCESS) {
+		wait_for_completion(&iport->hard_reset_complete);
+
+		dev_dbg(&ihost->pdev->dev,
+			"%s: iport = %p; hard reset completion\n",
+			__func__, iport);
+
+		if (iport->hard_reset_status != SCI_SUCCESS)
+			ret = TMF_RESP_FUNC_FAILED;
+	} else {
+		ret = TMF_RESP_FUNC_FAILED;
+
+		dev_err(&ihost->pdev->dev,
+			"%s: iport = %p; scic_port_hard_reset call"
+			" failed 0x%x\n",
+			__func__, iport, status);
+
+	}
+
+	/* If the hard reset for the port has failed, consider this
+	 * the same as link failures on all phys in the port.
+	 */
+	if (ret != TMF_RESP_FUNC_COMPLETE) {
+		dev_err(&ihost->pdev->dev,
+			"%s: iport = %p; hard reset failed "
+			"(0x%x) - sending link down to libsas for phy %p\n",
+			__func__, iport, iport->hard_reset_status, iphy);
+
+		isci_port_link_down(ihost, iphy, iport);
+	}
+
+	return ret;
+}
+
+/**
+ * isci_port_deformed() - This function is called by libsas when a port becomes
+ *    inactive.
+ * @phy: This parameter specifies the libsas phy with the inactive port.
+ *
+ */
+void isci_port_deformed(struct asd_sas_phy *phy)
+{
+	pr_debug("%s: sas_phy = %p\n", __func__, phy);
+}
+
+/**
+ * isci_port_formed() - This function is called by libsas when a port becomes
+ *    active.
+ * @phy: This parameter specifies the libsas phy with the active port.
+ *
+ */
+void isci_port_formed(struct asd_sas_phy *phy)
+{
+	pr_debug("%s: sas_phy = %p, sas_port = %p\n", __func__, phy, phy->port);
 }

commit d35bc1bd18ab9e986cfb67c5a281a70cfd717f05
Author: Dan Williams <dan.j.williams@intel.com>
Date:   Tue May 10 02:28:45 2011 -0700

    isci: uplevel phy infrastructure
    
    Merge core/scic_sds_phy.[ch] into phy.[ch]
    
    Reported-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/drivers/scsi/isci/port.c b/drivers/scsi/isci/port.c
index d4bf6d2d8c9b..321935d9560b 100644
--- a/drivers/scsi/isci/port.c
+++ b/drivers/scsi/isci/port.c
@@ -55,8 +55,6 @@
 
 #include <linux/workqueue.h>
 #include "isci.h"
-#include "scic_phy.h"
-#include "scic_sds_phy.h"
 #include "scic_port.h"
 #include "port.h"
 #include "request.h"

commit f1f52e75939b56c40b3d153ae99faf2720250242
Author: Dan Williams <dan.j.williams@intel.com>
Date:   Tue May 10 02:28:45 2011 -0700

    isci: uplevel request infrastructure
    
    * Consolidate tiny header files
    * Move files out of core/ (drop core/scic_sds_ prefix)
    * Merge core/scic_sds_request.[ch] into request.[ch]
    * Cleanup request.c namespace (clean forward declarations and global
      namespace pollution)
    
    Reported-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/drivers/scsi/isci/port.c b/drivers/scsi/isci/port.c
index f44fa20cad96..d4bf6d2d8c9b 100644
--- a/drivers/scsi/isci/port.c
+++ b/drivers/scsi/isci/port.c
@@ -55,7 +55,6 @@
 
 #include <linux/workqueue.h>
 #include "isci.h"
-#include "scic_io_request.h"
 #include "scic_phy.h"
 #include "scic_sds_phy.h"
 #include "scic_port.h"

commit cc9203bf381a465cd115762b9cf7c9a313c874bc
Author: Dan Williams <dan.j.williams@intel.com>
Date:   Sun May 8 17:34:44 2011 -0700

    isci: move core/controller to host
    
    Now that the data structures are unified unify the implementation in
    host.[ch] and cleanup namespace pollution.
    
    Reported-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/drivers/scsi/isci/port.c b/drivers/scsi/isci/port.c
index 35e2e517f671..f44fa20cad96 100644
--- a/drivers/scsi/isci/port.c
+++ b/drivers/scsi/isci/port.c
@@ -53,13 +53,6 @@
  * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  */
 
-/**
- * This file contains the isci port implementation.
- *
- *
- */
-
-
 #include <linux/workqueue.h>
 #include "isci.h"
 #include "scic_io_request.h"
@@ -68,7 +61,6 @@
 #include "scic_port.h"
 #include "port.h"
 #include "request.h"
-#include "core/scic_sds_controller.h"
 
 static void isci_port_change_state(struct isci_port *iport, enum isci_status status)
 {

commit e531381e2f8a68b8737c63c7bb890ad80b2470bd
Author: Dan Williams <dan.j.williams@intel.com>
Date:   Sat May 7 10:11:43 2011 -0700

    isci: unify port data structures
    
    Make scic_sds_port a member of isci_port and merge their lifetimes which
    means removing the port table from scic_sds_controller in favor of the
    one at the isci_host level.  Merge ihost->sas_ports into ihost->ports.
    _
    Reported-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/drivers/scsi/isci/port.c b/drivers/scsi/isci/port.c
index 5e87fedb5676..35e2e517f671 100644
--- a/drivers/scsi/isci/port.c
+++ b/drivers/scsi/isci/port.c
@@ -70,29 +70,30 @@
 #include "request.h"
 #include "core/scic_sds_controller.h"
 
-static void isci_port_change_state(
-	struct isci_port *isci_port,
-	enum isci_status status);
+static void isci_port_change_state(struct isci_port *iport, enum isci_status status)
+{
+	unsigned long flags;
 
+	dev_dbg(&iport->isci_host->pdev->dev,
+		"%s: iport = %p, state = 0x%x\n",
+		__func__, iport, status);
 
+	/* XXX pointless lock */
+	spin_lock_irqsave(&iport->state_lock, flags);
+	iport->status = status;
+	spin_unlock_irqrestore(&iport->state_lock, flags);
+}
 
 void isci_port_init(struct isci_port *iport, struct isci_host *ihost, int index)
 {
-	struct scic_sds_port *sci_port;
-
 	INIT_LIST_HEAD(&iport->remote_dev_list);
 	INIT_LIST_HEAD(&iport->domain_dev_list);
 	spin_lock_init(&iport->state_lock);
 	init_completion(&iport->start_complete);
 	iport->isci_host = ihost;
 	isci_port_change_state(iport, isci_freed);
-
-	sci_port = &ihost->sci.port_table[index];
-	iport->sci_port_handle = sci_port;
-	sci_port->iport = iport;
 }
 
-
 /**
  * isci_port_get_state() - This function gets the status of the port object.
  * @isci_port: This parameter points to the isci_port object
@@ -105,21 +106,6 @@ enum isci_status isci_port_get_state(
 	return isci_port->status;
 }
 
-static void isci_port_change_state(
-	struct isci_port *isci_port,
-	enum isci_status status)
-{
-	unsigned long flags;
-
-	dev_dbg(&isci_port->isci_host->pdev->dev,
-		"%s: isci_port = %p, state = 0x%x\n",
-		__func__, isci_port, status);
-
-	spin_lock_irqsave(&isci_port->state_lock, flags);
-	isci_port->status = status;
-	spin_unlock_irqrestore(&isci_port->state_lock, flags);
-}
-
 void isci_port_bc_change_received(struct isci_host *ihost,
 				  struct scic_sds_port *sci_port,
 				  struct scic_sds_phy *sci_phy)
@@ -140,7 +126,7 @@ void isci_port_link_up(struct isci_host *isci_host,
 	unsigned long flags;
 	struct scic_port_properties properties;
 	struct isci_phy *isci_phy = sci_phy_to_iphy(phy);
-	struct isci_port *isci_port = port->iport;
+	struct isci_port *isci_port = sci_port_to_iport(port);
 	unsigned long success = true;
 
 	BUG_ON(isci_phy->isci_port != NULL);
@@ -346,8 +332,7 @@ int isci_port_perform_hard_reset(struct isci_host *ihost, struct isci_port *ipor
 	spin_lock_irqsave(&ihost->scic_lock, flags);
 
 	#define ISCI_PORT_RESET_TIMEOUT SCIC_SDS_SIGNATURE_FIS_TIMEOUT
-	status = scic_port_hard_reset(iport->sci_port_handle,
-				      ISCI_PORT_RESET_TIMEOUT);
+	status = scic_port_hard_reset(&iport->sci, ISCI_PORT_RESET_TIMEOUT);
 
 	spin_unlock_irqrestore(&ihost->scic_lock, flags);
 

commit 4b33981ade7cf723f3f32809e34192376c9a10f8
Author: Dan Williams <dan.j.williams@intel.com>
Date:   Fri May 6 17:36:38 2011 -0700

    isci: unify phy data structures
    
    Make scic_sds_phy a member of isci_phy and merge their lifetimes which
    means removing the phy table from scic_sds_controller in favor of the
    one at that isci_host level.
    
    Reported-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/drivers/scsi/isci/port.c b/drivers/scsi/isci/port.c
index 6110306e8e23..5e87fedb5676 100644
--- a/drivers/scsi/isci/port.c
+++ b/drivers/scsi/isci/port.c
@@ -120,44 +120,26 @@ static void isci_port_change_state(
 	spin_unlock_irqrestore(&isci_port->state_lock, flags);
 }
 
-void isci_port_bc_change_received(
-	struct isci_host *isci_host,
-	struct scic_sds_port *port,
-	struct scic_sds_phy *phy)
+void isci_port_bc_change_received(struct isci_host *ihost,
+				  struct scic_sds_port *sci_port,
+				  struct scic_sds_phy *sci_phy)
 {
-	struct isci_phy *isci_phy = phy->iphy;
+	struct isci_phy *iphy = sci_phy_to_iphy(sci_phy);
 
-	dev_dbg(&isci_host->pdev->dev,
-		"%s: isci_phy = %p, sas_phy = %p\n",
-		__func__,
-		isci_phy,
-		&isci_phy->sas_phy);
-
-	isci_host->sas_ha.notify_port_event(
-		&isci_phy->sas_phy,
-		PORTE_BROADCAST_RCVD
-		);
+	dev_dbg(&ihost->pdev->dev, "%s: iphy = %p, sas_phy = %p\n",
+		__func__, iphy, &iphy->sas_phy);
 
-	scic_port_enable_broadcast_change_notification(port);
+	ihost->sas_ha.notify_port_event(&iphy->sas_phy, PORTE_BROADCAST_RCVD);
+	scic_port_enable_broadcast_change_notification(sci_port);
 }
 
-/**
- * isci_port_link_up() - This function is called by the sci core when a link
- *    becomes active. the identify address frame is retrieved from the core and
- *    a notify port event is sent to libsas.
- * @isci_host: This parameter specifies the isci host object.
- * @port: This parameter specifies the sci port with the active link.
- * @phy: This parameter specifies the sci phy with the active link.
- *
- */
-void isci_port_link_up(
-	struct isci_host *isci_host,
-	struct scic_sds_port *port,
-	struct scic_sds_phy *phy)
+void isci_port_link_up(struct isci_host *isci_host,
+		       struct scic_sds_port *port,
+		       struct scic_sds_phy *phy)
 {
 	unsigned long flags;
 	struct scic_port_properties properties;
-	struct isci_phy *isci_phy = phy->iphy;
+	struct isci_phy *isci_phy = sci_phy_to_iphy(phy);
 	struct isci_port *isci_port = port->iport;
 	unsigned long success = true;
 

commit ed30c275dd9fc5c603081144db5df3110f258534
Author: Edmund Nadolski <edmund.nadolski@intel.com>
Date:   Thu May 5 01:11:43 2011 +0000

    isci: kill scic_controller_get_port_handle function
    
    This function is just overkill and its usage is inconsistent. Replace
    with inlined code.
    
    Signed-off-by: Edmund Nadolski <edmund.nadolski@intel.com>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/drivers/scsi/isci/port.c b/drivers/scsi/isci/port.c
index 8d96a10341b1..6110306e8e23 100644
--- a/drivers/scsi/isci/port.c
+++ b/drivers/scsi/isci/port.c
@@ -76,31 +76,20 @@ static void isci_port_change_state(
 
 
 
-/**
- * isci_port_init() - This function initializes the given isci_port object.
- * @isci_port: This parameter specifies the port object to be initialized.
- * @isci_host: This parameter specifies parent controller object for the port.
- * @index: This parameter specifies which SCU port the isci_port associates
- *    with. Generally, SCU port 0 relates to isci_port 0, etc.
- *
- */
-void isci_port_init(
-	struct isci_port *isci_port,
-	struct isci_host *isci_host,
-	int index)
+void isci_port_init(struct isci_port *iport, struct isci_host *ihost, int index)
 {
-	struct scic_sds_port *scic_port;
-
-	INIT_LIST_HEAD(&isci_port->remote_dev_list);
-	INIT_LIST_HEAD(&isci_port->domain_dev_list);
-	spin_lock_init(&isci_port->state_lock);
-	init_completion(&isci_port->start_complete);
-	isci_port->isci_host = isci_host;
-	isci_port_change_state(isci_port, isci_freed);
-
-	(void)scic_controller_get_port_handle(&isci_host->sci, index, &scic_port);
-	isci_port->sci_port_handle = scic_port;
-	scic_port->iport = isci_port;
+	struct scic_sds_port *sci_port;
+
+	INIT_LIST_HEAD(&iport->remote_dev_list);
+	INIT_LIST_HEAD(&iport->domain_dev_list);
+	spin_lock_init(&iport->state_lock);
+	init_completion(&iport->start_complete);
+	iport->isci_host = ihost;
+	isci_port_change_state(iport, isci_freed);
+
+	sci_port = &ihost->sci.port_table[index];
+	iport->sci_port_handle = sci_port;
+	sci_port->iport = iport;
 }
 
 

commit cc3dbd0a9178865d4444f8e28b51715808e9ac85
Author: Artur Wojcik <artur.wojcik@intel.com>
Date:   Wed May 4 07:58:16 2011 +0000

    isci: unify isci_host data structures
    
    Make it explicit that isci_host and scic_sds_controller are one in the same
    object.
    
    Signed-off-by: Artur Wojcik <artur.wojcik@intel.com>
    [removed ->ihost back pointer]
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/drivers/scsi/isci/port.c b/drivers/scsi/isci/port.c
index 2decafbeb968..8d96a10341b1 100644
--- a/drivers/scsi/isci/port.c
+++ b/drivers/scsi/isci/port.c
@@ -90,7 +90,6 @@ void isci_port_init(
 	int index)
 {
 	struct scic_sds_port *scic_port;
-	struct scic_sds_controller *controller = isci_host->core_controller;
 
 	INIT_LIST_HEAD(&isci_port->remote_dev_list);
 	INIT_LIST_HEAD(&isci_port->domain_dev_list);
@@ -99,7 +98,7 @@ void isci_port_init(
 	isci_port->isci_host = isci_host;
 	isci_port_change_state(isci_port, isci_freed);
 
-	(void)scic_controller_get_port_handle(controller, index, &scic_port);
+	(void)scic_controller_get_port_handle(&isci_host->sci, index, &scic_port);
 	isci_port->sci_port_handle = scic_port;
 	scic_port->iport = isci_port;
 }
@@ -415,33 +414,9 @@ int isci_port_perform_hard_reset(struct isci_host *ihost, struct isci_port *ipor
 	return ret;
 }
 
-/**
- * isci_port_invalid_link_up() - This function informs the SCI Core user that
- *    a phy/link became ready, but the phy is not allowed in the port.  In some
- *    situations the underlying hardware only allows for certain phy to port
- *    mappings.  If these mappings are violated, then this API is invoked.
- * @controller: This parameter represents the controller which contains the
- *    port.
- * @port: This parameter specifies the SCI port object for which the callback
- *    is being invoked.
- * @phy: This parameter specifies the phy that came ready, but the phy can't be
- *    a valid member of the port.
- *
- */
-void isci_port_invalid_link_up(struct scic_sds_controller *scic,
-				      struct scic_sds_port *sci_port,
-				      struct scic_sds_phy *phy)
-{
-	struct isci_host *ihost = scic->ihost;
-
-	dev_warn(&ihost->pdev->dev, "Invalid link up!\n");
-}
-
 void isci_port_stop_complete(struct scic_sds_controller *scic,
 					  struct scic_sds_port *sci_port,
 					  enum sci_status completion_status)
 {
-	struct isci_host *ihost = scic->ihost;
-
-	dev_dbg(&ihost->pdev->dev, "Port stop complete\n");
+	dev_dbg(&scic_to_ihost(scic)->pdev->dev, "Port stop complete\n");
 }

commit d7b90fc3436fa6d5b5251eec3128386af1a4d7b8
Author: Dave Jiang <dave.jiang@intel.com>
Date:   Wed May 4 18:22:33 2011 -0700

    isci: fixup SAS iaf protocols data structure
    
    Moved the actual data structure that's read from the phy register to phy
    header.  Removed the parsing of identify address frame protocol bits as
    that seemed not necessary and we can use existing information.
    
    Signed-off-by: Dave Jiang <dave.jiang@intel.com>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/drivers/scsi/isci/port.c b/drivers/scsi/isci/port.c
index 96a2002dadea..2decafbeb968 100644
--- a/drivers/scsi/isci/port.c
+++ b/drivers/scsi/isci/port.c
@@ -187,7 +187,7 @@ void isci_port_link_up(
 
 	scic_port_get_properties(port, &properties);
 
-	if (properties.remote.protocols.u.bits.stp_target) {
+	if (phy->protocol == SCIC_SDS_PHY_PROTOCOL_SATA) {
 		u64 attached_sas_address;
 
 		isci_phy->sas_phy.oob_mode = SATA_OOB_MODE;
@@ -207,9 +207,7 @@ void isci_port_link_up(
 
 		memcpy(&isci_phy->sas_phy.attached_sas_addr,
 		       &attached_sas_address, sizeof(attached_sas_address));
-
-	} else if (properties.remote.protocols.u.bits.ssp_target ||
-		   properties.remote.protocols.u.bits.smp_target) {
+	} else if (phy->protocol == SCIC_SDS_PHY_PROTOCOL_SAS) {
 		isci_phy->sas_phy.oob_mode = SAS_OOB_MODE;
 		isci_phy->sas_phy.frame_rcvd_size = sizeof(struct sas_identify_frame);
 

commit f700ad4331d55df729a36b2602c4abe2d855036f
Author: Dave Jiang <dave.jiang@intel.com>
Date:   Wed May 4 18:08:35 2011 -0700

    isci: remove redundant copies of IAF
    
    We need to remove the extra copies of identify address frame that's
    being kept around. We only need the one copy that libsas is using.
    
    Signed-off-by: Dave Jiang <dave.jiang@intel.com>
    [further cleanups]
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/drivers/scsi/isci/port.c b/drivers/scsi/isci/port.c
index 0a1577327d61..96a2002dadea 100644
--- a/drivers/scsi/isci/port.c
+++ b/drivers/scsi/isci/port.c
@@ -171,7 +171,6 @@ void isci_port_link_up(
 	struct scic_port_properties properties;
 	struct isci_phy *isci_phy = phy->iphy;
 	struct isci_port *isci_port = port->iport;
-	enum sci_status call_status;
 	unsigned long success = true;
 
 	BUG_ON(isci_phy->isci_port != NULL);
@@ -191,21 +190,7 @@ void isci_port_link_up(
 	if (properties.remote.protocols.u.bits.stp_target) {
 		u64 attached_sas_address;
 
-		struct scic_sata_phy_properties sata_phy_properties;
-
 		isci_phy->sas_phy.oob_mode = SATA_OOB_MODE;
-
-		/* Get a copy of the signature fis for libsas */
-		call_status = scic_sata_phy_get_properties(phy,
-							   &sata_phy_properties);
-
-		/*
-		 * XXX I am concerned about this "assert". shouldn't we
-		 * handle the return appropriately?
-		 */
-		BUG_ON(call_status != SCI_SUCCESS);
-
-		isci_phy->frame_rcvd.fis = sata_phy_properties.signature_fis;
 		isci_phy->sas_phy.frame_rcvd_size = sizeof(struct dev_to_host_fis);
 
 		/*
@@ -225,24 +210,12 @@ void isci_port_link_up(
 
 	} else if (properties.remote.protocols.u.bits.ssp_target ||
 		   properties.remote.protocols.u.bits.smp_target) {
-
-		struct scic_sas_phy_properties sas_phy_properties;
-
 		isci_phy->sas_phy.oob_mode = SAS_OOB_MODE;
-
-		/* Get a copy of the identify address frame for libsas */
-		call_status = scic_sas_phy_get_properties(phy,
-							  &sas_phy_properties);
-
-		BUG_ON(call_status != SCI_SUCCESS);
-
-		isci_phy->frame_rcvd.iaf = sas_phy_properties.rcvd_iaf;
 		isci_phy->sas_phy.frame_rcvd_size = sizeof(struct sas_identify_frame);
 
 		/* Copy the attached SAS address from the IAF */
 		memcpy(isci_phy->sas_phy.attached_sas_addr,
 		       isci_phy->frame_rcvd.iaf.sas_addr, SAS_ADDR_SIZE);
-
 	} else {
 		dev_err(&isci_host->pdev->dev, "%s: unkown target\n", __func__);
 		success = false;

commit 4b7ebd05fc074ac2ffdc803232d83f3593d4f548
Author: Dave Jiang <dave.jiang@intel.com>
Date:   Wed May 4 15:37:52 2011 -0700

    isci: Convert SAS identify address frame to Linux Native format
    
    Convert struct sci_sas_identify_address_frame to struct sas_identify_frame
    
    Signed-off-by: Dave Jiang <dave.jiang@intel.com>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/drivers/scsi/isci/port.c b/drivers/scsi/isci/port.c
index 5b38f2f963e0..0a1577327d61 100644
--- a/drivers/scsi/isci/port.c
+++ b/drivers/scsi/isci/port.c
@@ -236,18 +236,12 @@ void isci_port_link_up(
 
 		BUG_ON(call_status != SCI_SUCCESS);
 
-		memcpy(isci_phy->frame_rcvd.aif,
-		       &(sas_phy_properties.received_iaf),
-		       sizeof(struct sci_sas_identify_address_frame));
-
-		isci_phy->sas_phy.frame_rcvd_size
-			= sizeof(struct sci_sas_identify_address_frame);
+		isci_phy->frame_rcvd.iaf = sas_phy_properties.rcvd_iaf;
+		isci_phy->sas_phy.frame_rcvd_size = sizeof(struct sas_identify_frame);
 
 		/* Copy the attached SAS address from the IAF */
 		memcpy(isci_phy->sas_phy.attached_sas_addr,
-		       ((struct sas_identify_frame *)
-			(&isci_phy->frame_rcvd.aif))->sas_addr,
-		       SAS_ADDR_SIZE);
+		       isci_phy->frame_rcvd.iaf.sas_addr, SAS_ADDR_SIZE);
 
 	} else {
 		dev_err(&isci_host->pdev->dev, "%s: unkown target\n", __func__);

commit f2f300806fe186a6c45020a444667755edcce672
Author: Dave Jiang <dave.jiang@intel.com>
Date:   Wed May 4 15:02:02 2011 -0700

    isci: Convert SATA fis data structures to Linux native
    
    Converting of sata_fis_reg_d2h to dev_to_host_fis
    Converting of sata_fis_reg_h2d to host_to_dev_fis
    
    Signed-off-by: Dave Jiang <dave.jiang@intel.com>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/drivers/scsi/isci/port.c b/drivers/scsi/isci/port.c
index 30d6ad895ccf..5b38f2f963e0 100644
--- a/drivers/scsi/isci/port.c
+++ b/drivers/scsi/isci/port.c
@@ -205,11 +205,8 @@ void isci_port_link_up(
 		 */
 		BUG_ON(call_status != SCI_SUCCESS);
 
-		memcpy(isci_phy->frame_rcvd.fis,
-		       &sata_phy_properties.signature_fis,
-		       sizeof(struct sata_fis_reg_d2h));
-
-		isci_phy->sas_phy.frame_rcvd_size = sizeof(struct sata_fis_reg_d2h);
+		isci_phy->frame_rcvd.fis = sata_phy_properties.signature_fis;
+		isci_phy->sas_phy.frame_rcvd_size = sizeof(struct dev_to_host_fis);
 
 		/*
 		 * For direct-attached SATA devices, the SCI core will

commit 115bd1f9e8ee11744818e6eb5351d05ab6a8402e
Author: Maciej Patelczyk <maciej.patelczyk@intel.com>
Date:   Thu Apr 28 22:06:16 2011 +0000

    isci: Removed sci_base_object from scic_sds_port.
    
    The 'struct sci_base_object' was removed from the struct
    scic_sds_port and was replaced by a pointer to
    struct isci_port.
    
    Signed-off-by: Maciej Patelczyk <maciej.patelczyk@intel.com>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/drivers/scsi/isci/port.c b/drivers/scsi/isci/port.c
index d600b09192e7..30d6ad895ccf 100644
--- a/drivers/scsi/isci/port.c
+++ b/drivers/scsi/isci/port.c
@@ -100,8 +100,8 @@ void isci_port_init(
 	isci_port_change_state(isci_port, isci_freed);
 
 	(void)scic_controller_get_port_handle(controller, index, &scic_port);
-	sci_object_set_association(scic_port, isci_port);
 	isci_port->sci_port_handle = scic_port;
+	scic_port->iport = isci_port;
 }
 
 
@@ -169,9 +169,8 @@ void isci_port_link_up(
 {
 	unsigned long flags;
 	struct scic_port_properties properties;
-	struct isci_port *isci_port
-		= (struct isci_port *)sci_object_get_association(port);
 	struct isci_phy *isci_phy = phy->iphy;
+	struct isci_port *isci_port = port->iport;
 	enum sci_status call_status;
 	unsigned long success = true;
 

commit e1e72a00dd9db0cd2b7d106916645626f53c0382
Author: Maciej Patelczyk <maciej.patelczyk@intel.com>
Date:   Thu Apr 28 22:06:11 2011 +0000

    isci: Removed sci_base_object from scic_sds_phy.
    
    The 'struct sci_base_object' was removed from the struct
    scic_sds_phy and was replaced by a pointer to
    struct isci_phy.
    
    Signed-off-by: Maciej Patelczyk <maciej.patelczyk@intel.com>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/drivers/scsi/isci/port.c b/drivers/scsi/isci/port.c
index c0916b199b70..d600b09192e7 100644
--- a/drivers/scsi/isci/port.c
+++ b/drivers/scsi/isci/port.c
@@ -137,8 +137,7 @@ void isci_port_bc_change_received(
 	struct scic_sds_port *port,
 	struct scic_sds_phy *phy)
 {
-	struct isci_phy *isci_phy =
-		(struct isci_phy *)sci_object_get_association(phy);
+	struct isci_phy *isci_phy = phy->iphy;
 
 	dev_dbg(&isci_host->pdev->dev,
 		"%s: isci_phy = %p, sas_phy = %p\n",
@@ -170,10 +169,9 @@ void isci_port_link_up(
 {
 	unsigned long flags;
 	struct scic_port_properties properties;
-	struct isci_phy *isci_phy
-		= (struct isci_phy *)sci_object_get_association(phy);
 	struct isci_port *isci_port
 		= (struct isci_port *)sci_object_get_association(port);
+	struct isci_phy *isci_phy = phy->iphy;
 	enum sci_status call_status;
 	unsigned long success = true;
 

commit d3757c3aeb75259e0b86a872e98841a2ea4cb5e8
Author: Maciej Patelczyk <maciej.patelczyk@intel.com>
Date:   Thu Apr 28 22:06:06 2011 +0000

    isci: Removed sci_base_object from scic_sds_controller.
    
    The 'struct sci_base_object' was removed from the struct
    scic_sds_controller and was replaced by a pointer to
    struct isci_host.
    
    Signed-off-by: Maciej Patelczyk <maciej.patelczyk@intel.com>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/drivers/scsi/isci/port.c b/drivers/scsi/isci/port.c
index 430b29ed6c7e..c0916b199b70 100644
--- a/drivers/scsi/isci/port.c
+++ b/drivers/scsi/isci/port.c
@@ -68,6 +68,7 @@
 #include "scic_port.h"
 #include "port.h"
 #include "request.h"
+#include "core/scic_sds_controller.h"
 
 static void isci_port_change_state(
 	struct isci_port *isci_port,
@@ -472,7 +473,7 @@ void isci_port_invalid_link_up(struct scic_sds_controller *scic,
 				      struct scic_sds_port *sci_port,
 				      struct scic_sds_phy *phy)
 {
-	struct isci_host *ihost = sci_object_get_association(scic);
+	struct isci_host *ihost = scic->ihost;
 
 	dev_warn(&ihost->pdev->dev, "Invalid link up!\n");
 }
@@ -481,7 +482,7 @@ void isci_port_stop_complete(struct scic_sds_controller *scic,
 					  struct scic_sds_port *sci_port,
 					  enum sci_status completion_status)
 {
-	struct isci_host *ihost = sci_object_get_association(scic);
+	struct isci_host *ihost = scic->ihost;
 
 	dev_dbg(&ihost->pdev->dev, "Port stop complete\n");
 }

commit 88f3b62ac131e2549b6c262cacbd47e8cca42d6e
Author: Dan Williams <dan.j.williams@intel.com>
Date:   Fri Apr 22 19:18:03 2011 -0700

    isci: move remote_device handling out of the core
    
    Now that the core/lldd remote_device data structures are nominally unified
    merge the corresponding sources into the top-level directory.  Also move the
    remote_node_context infrastructure which has no analog at the lldd level.
    
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/drivers/scsi/isci/port.c b/drivers/scsi/isci/port.c
index cf78cf0a6749..430b29ed6c7e 100644
--- a/drivers/scsi/isci/port.c
+++ b/drivers/scsi/isci/port.c
@@ -63,7 +63,6 @@
 #include <linux/workqueue.h>
 #include "isci.h"
 #include "scic_io_request.h"
-#include "scic_remote_device.h"
 #include "scic_phy.h"
 #include "scic_sds_phy.h"
 #include "scic_port.h"

commit 6cb4d6b382be6345c2d0c4b1b90dfdf9af32da7e
Author: Bartosz Barcinski <Bartosz.Barcinski@intel.com>
Date:   Tue Apr 12 17:28:43 2011 -0700

    isci: audit usage of BUG_ON macro in isci driver
    
    Removes unnecessary usage of BUG_ON macro, excluding core directory.
    In some cases macro is unnecesary, check is done in caller function.
    In other cases macro is replaced by if construction with
    appropriate warning.
    
    Signed-off-by: Maciej Patelczyk <maciej.patelczyk@intel.com>
    [changed some survivable bug conditions to WARN_ONCE]
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/drivers/scsi/isci/port.c b/drivers/scsi/isci/port.c
index b675a94f4a73..cf78cf0a6749 100644
--- a/drivers/scsi/isci/port.c
+++ b/drivers/scsi/isci/port.c
@@ -178,6 +178,7 @@ void isci_port_link_up(
 	unsigned long success = true;
 
 	BUG_ON(isci_phy->isci_port != NULL);
+
 	isci_phy->isci_port = isci_port;
 
 	dev_dbg(&isci_host->pdev->dev,

commit 4393aa4e6b9517a666f0ef6b774fd421a9dc4c68
Author: Dan Williams <dan.j.williams@intel.com>
Date:   Thu Mar 31 13:10:44 2011 -0700

    isci: fix fragile/conditional isci_host lookups
    
    A domain_device can always reference back to ->lldd_ha unlike local lldd
    structures.  Fix up cases where the driver uses local objects to look up the
    isci_host.  This also changes the calling conventions of some routines to
    expect a valid isci_host parameter rather than re-lookup the pointer on entry.
    
    Incidentally cleans up some macros that are longer to type than the open-coded
    equivalent:
      isci_host_from_sas_ha
      isci_dev_from_domain_dev
    
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/drivers/scsi/isci/port.c b/drivers/scsi/isci/port.c
index 74dc96dc6b17..b675a94f4a73 100644
--- a/drivers/scsi/isci/port.c
+++ b/drivers/scsi/isci/port.c
@@ -400,55 +400,43 @@ void isci_port_hard_reset_complete(struct isci_port *isci_port,
 
 	complete_all(&isci_port->hard_reset_complete);
 }
-/**
- * isci_port_perform_hard_reset() - This function is one of the SAS Domain
- *    Template functions. This is a phy management function.
- * @isci_port:
- * @isci_phy:
- *
- * status, TMF_RESP_FUNC_COMPLETE indicates success.
- */
-int isci_port_perform_hard_reset(
-	struct isci_port *isci_port,
-	struct isci_phy *isci_phy)
+
+int isci_port_perform_hard_reset(struct isci_host *ihost, struct isci_port *iport,
+				 struct isci_phy *iphy)
 {
+	unsigned long flags;
 	enum sci_status status;
 	int ret = TMF_RESP_FUNC_COMPLETE;
-	unsigned long flags;
 
+	dev_dbg(&ihost->pdev->dev, "%s: iport = %p\n",
+		__func__, iport);
 
-	dev_dbg(&isci_port->isci_host->pdev->dev,
-		"%s: isci_port = %p\n",
-		__func__, isci_port);
-
-	BUG_ON(isci_port == NULL);
-
-	init_completion(&isci_port->hard_reset_complete);
+	init_completion(&iport->hard_reset_complete);
 
-	spin_lock_irqsave(&isci_port->isci_host->scic_lock, flags);
+	spin_lock_irqsave(&ihost->scic_lock, flags);
 
 	#define ISCI_PORT_RESET_TIMEOUT SCIC_SDS_SIGNATURE_FIS_TIMEOUT
-	status = scic_port_hard_reset(isci_port->sci_port_handle,
+	status = scic_port_hard_reset(iport->sci_port_handle,
 				      ISCI_PORT_RESET_TIMEOUT);
 
-	spin_unlock_irqrestore(&isci_port->isci_host->scic_lock, flags);
+	spin_unlock_irqrestore(&ihost->scic_lock, flags);
 
 	if (status == SCI_SUCCESS) {
-		wait_for_completion(&isci_port->hard_reset_complete);
+		wait_for_completion(&iport->hard_reset_complete);
 
-		dev_dbg(&isci_port->isci_host->pdev->dev,
-			"%s: isci_port = %p; hard reset completion\n",
-			__func__, isci_port);
+		dev_dbg(&ihost->pdev->dev,
+			"%s: iport = %p; hard reset completion\n",
+			__func__, iport);
 
-		if (isci_port->hard_reset_status != SCI_SUCCESS)
+		if (iport->hard_reset_status != SCI_SUCCESS)
 			ret = TMF_RESP_FUNC_FAILED;
 	} else {
 		ret = TMF_RESP_FUNC_FAILED;
 
-		dev_err(&isci_port->isci_host->pdev->dev,
-			"%s: isci_port = %p; scic_port_hard_reset call"
+		dev_err(&ihost->pdev->dev,
+			"%s: iport = %p; scic_port_hard_reset call"
 			" failed 0x%x\n",
-			__func__, isci_port, status);
+			__func__, iport, status);
 
 	}
 
@@ -456,19 +444,12 @@ int isci_port_perform_hard_reset(
 	 * the same as link failures on all phys in the port.
 	 */
 	if (ret != TMF_RESP_FUNC_COMPLETE) {
-		BUG_ON(isci_port->isci_host == NULL);
-
-		dev_err(&isci_port->isci_host->pdev->dev,
-			"%s: isci_port = %p; hard reset failed "
+		dev_err(&ihost->pdev->dev,
+			"%s: iport = %p; hard reset failed "
 			"(0x%x) - sending link down to libsas for phy %p\n",
-			__func__,
-			isci_port,
-			isci_port->hard_reset_status,
-			isci_phy);
-
-		isci_port_link_down(isci_port->isci_host,
-				    isci_phy,
-				    isci_port);
+			__func__, iport, iport->hard_reset_status, iphy);
+
+		isci_port_link_down(ihost, iphy, iport);
 	}
 
 	return ret;
@@ -491,8 +472,7 @@ void isci_port_invalid_link_up(struct scic_sds_controller *scic,
 				      struct scic_sds_port *sci_port,
 				      struct scic_sds_phy *phy)
 {
-	struct isci_host *ihost =
-		(struct isci_host *)sci_object_get_association(scic);
+	struct isci_host *ihost = sci_object_get_association(scic);
 
 	dev_warn(&ihost->pdev->dev, "Invalid link up!\n");
 }

commit 35173d579a08c0d145b3020039d3ba33fbf2c184
Author: Dan Williams <dan.j.williams@intel.com>
Date:   Sat Mar 26 16:43:01 2011 -0700

    isci: namespacecheck cleanups
    
    * mark needlessly global routines static
    * delete unused functions
    * move kernel-doc blocks from header files to source
    * reorder some functions to delete declarations
    * more default handler cleanups phy
    
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/drivers/scsi/isci/port.c b/drivers/scsi/isci/port.c
index 666076a2834e..74dc96dc6b17 100644
--- a/drivers/scsi/isci/port.c
+++ b/drivers/scsi/isci/port.c
@@ -201,7 +201,7 @@ void isci_port_link_up(
 		call_status = scic_sata_phy_get_properties(phy,
 							   &sata_phy_properties);
 
-		/* 
+		/*
 		 * XXX I am concerned about this "assert". shouldn't we
 		 * handle the return appropriately?
 		 */

commit 09d7da135b34bc74a7996b5db373521557ddf3d4
Author: Dave Jiang <dave.jiang@intel.com>
Date:   Sat Mar 26 16:11:51 2011 -0700

    isci: Remove event_* calls as they are just wrappers
    
    Removed isci_event_* calls and call those functions directly.
    
    Reported-by: Christoph Hellwig <hch@infradead.org>
    Signed-off-by: Dave Jiang <dave.jiang@intel.com>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/drivers/scsi/isci/port.c b/drivers/scsi/isci/port.c
index a5b2565ac5af..666076a2834e 100644
--- a/drivers/scsi/isci/port.c
+++ b/drivers/scsi/isci/port.c
@@ -279,10 +279,8 @@ void isci_port_link_up(
  * @port: This parameter specifies the isci port with the active link.
  *
  */
-void isci_port_link_down(
-	struct isci_host *isci_host,
-	struct isci_phy *isci_phy,
-	struct isci_port *isci_port)
+void isci_port_link_down(struct isci_host *isci_host, struct isci_phy *isci_phy,
+			 struct isci_port *isci_port)
 {
 	struct isci_remote_device *isci_device;
 
@@ -358,9 +356,7 @@ void isci_port_formed(
  * @port: This parameter specifies the sci port with the active link.
  *
  */
-void isci_port_ready(
-	struct isci_host *isci_host,
-	struct isci_port *isci_port)
+void isci_port_ready(struct isci_host *isci_host, struct isci_port *isci_port)
 {
 	dev_dbg(&isci_host->pdev->dev,
 		"%s: isci_port = %p\n", __func__, isci_port);
@@ -378,9 +374,7 @@ void isci_port_ready(
  * @port: This parameter specifies the sci port with the active link.
  *
  */
-void isci_port_not_ready(
-	struct isci_host *isci_host,
-	struct isci_port *isci_port)
+void isci_port_not_ready(struct isci_host *isci_host, struct isci_port *isci_port)
 {
 	dev_dbg(&isci_host->pdev->dev,
 		"%s: isci_port = %p\n", __func__, isci_port);
@@ -394,9 +388,8 @@ void isci_port_not_ready(
  *    process.
  *
  */
-void isci_port_hard_reset_complete(
-	struct isci_port *isci_port,
-	enum sci_status completion_status)
+void isci_port_hard_reset_complete(struct isci_port *isci_port,
+				   enum sci_status completion_status)
 {
 	dev_dbg(&isci_port->isci_host->pdev->dev,
 		"%s: isci_port = %p, completion_status=%x\n",
@@ -480,3 +473,35 @@ int isci_port_perform_hard_reset(
 
 	return ret;
 }
+
+/**
+ * isci_port_invalid_link_up() - This function informs the SCI Core user that
+ *    a phy/link became ready, but the phy is not allowed in the port.  In some
+ *    situations the underlying hardware only allows for certain phy to port
+ *    mappings.  If these mappings are violated, then this API is invoked.
+ * @controller: This parameter represents the controller which contains the
+ *    port.
+ * @port: This parameter specifies the SCI port object for which the callback
+ *    is being invoked.
+ * @phy: This parameter specifies the phy that came ready, but the phy can't be
+ *    a valid member of the port.
+ *
+ */
+void isci_port_invalid_link_up(struct scic_sds_controller *scic,
+				      struct scic_sds_port *sci_port,
+				      struct scic_sds_phy *phy)
+{
+	struct isci_host *ihost =
+		(struct isci_host *)sci_object_get_association(scic);
+
+	dev_warn(&ihost->pdev->dev, "Invalid link up!\n");
+}
+
+void isci_port_stop_complete(struct scic_sds_controller *scic,
+					  struct scic_sds_port *sci_port,
+					  enum sci_status completion_status)
+{
+	struct isci_host *ihost = sci_object_get_association(scic);
+
+	dev_dbg(&ihost->pdev->dev, "Port stop complete\n");
+}

commit 1a38045ba88ed3bee6c57444670fb639c8b61be7
Author: Dan Williams <dan.j.williams@intel.com>
Date:   Thu Mar 3 18:01:43 2011 -0800

    isci: replace remote_device_lock  with scic_lock
    
    The remote_device_lock is currently used to protect a controller global
    resource (RNCs), but the remote_device_lock is per-port.
    
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/drivers/scsi/isci/port.c b/drivers/scsi/isci/port.c
index 30da3ec703e3..a5b2565ac5af 100644
--- a/drivers/scsi/isci/port.c
+++ b/drivers/scsi/isci/port.c
@@ -94,7 +94,6 @@ void isci_port_init(
 
 	INIT_LIST_HEAD(&isci_port->remote_dev_list);
 	INIT_LIST_HEAD(&isci_port->domain_dev_list);
-	spin_lock_init(&isci_port->remote_device_lock);
 	spin_lock_init(&isci_port->state_lock);
 	init_completion(&isci_port->start_complete);
 	isci_port->isci_host = isci_host;

commit 150fc6fc725055b400a8865e6785dc8dd0a2225d
Author: Dan Williams <dan.j.williams@intel.com>
Date:   Fri Feb 25 10:25:21 2011 -0800

    isci: fix sas address reporting
    
    Undo the open coded and incorrect translation of the oem parameter sas
    address to its libsas expected format.
    
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/drivers/scsi/isci/port.c b/drivers/scsi/isci/port.c
index 446da20521c9..30da3ec703e3 100644
--- a/drivers/scsi/isci/port.c
+++ b/drivers/scsi/isci/port.c
@@ -192,6 +192,7 @@ void isci_port_link_up(
 	scic_port_get_properties(port, &properties);
 
 	if (properties.remote.protocols.u.bits.stp_target) {
+		u64 attached_sas_address;
 
 		struct scic_sata_phy_properties sata_phy_properties;
 
@@ -220,17 +221,13 @@ void isci_port_link_up(
 		 * will not be the same as assigned to the PHY and needs
 		 * to be obtained from struct scic_port_properties properties.
 		 */
+		attached_sas_address = properties.remote.sas_address.high;
+		attached_sas_address <<= 32;
+		attached_sas_address |= properties.remote.sas_address.low;
+		swab64s(&attached_sas_address);
 
-		BUG_ON(((size_t)SAS_ADDR_SIZE / 2)
-		       != sizeof(properties.remote.sas_address.low));
-
-		memcpy(&isci_phy->sas_phy.attached_sas_addr[0],
-		       &properties.remote.sas_address.low,
-		       SAS_ADDR_SIZE / 2);
-
-		memcpy(&isci_phy->sas_phy.attached_sas_addr[4],
-		       &properties.remote.sas_address.high,
-		       SAS_ADDR_SIZE / 2);
+		memcpy(&isci_phy->sas_phy.attached_sas_addr,
+		       &attached_sas_address, sizeof(attached_sas_address));
 
 	} else if (properties.remote.protocols.u.bits.ssp_target ||
 		   properties.remote.protocols.u.bits.smp_target) {

commit 83e514301ec73b16fb258618c9f9b443cca3744a
Author: Dan Williams <dan.j.williams@intel.com>
Date:   Fri Feb 18 09:25:13 2011 -0800

    isci: advertise linkrate
    
    Inform libsas of the linkrate of direct attached links.
    
    Reported-by: Haavard Skinnemoen <hskinnemoen@gmail.com>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/drivers/scsi/isci/port.c b/drivers/scsi/isci/port.c
index 2343f6556428..446da20521c9 100644
--- a/drivers/scsi/isci/port.c
+++ b/drivers/scsi/isci/port.c
@@ -263,6 +263,8 @@ void isci_port_link_up(
 		success = false;
 	}
 
+	isci_phy->sas_phy.phy->negotiated_linkrate = sci_phy_linkrate(phy);
+
 	spin_unlock_irqrestore(&isci_phy->sas_phy.frame_rcvd_lock, flags);
 
 	/* Notify libsas that we have an address frame, if indeed

commit 6f231dda68080759f1aed3769896e94c73099f0f
Author: Dan Williams <dan.j.williams@intel.com>
Date:   Sat Jul 2 22:56:22 2011 -0700

    isci: Intel(R) C600 Series Chipset Storage Control Unit Driver
    
    Support for the up to 2x4-port 6Gb/s SAS controllers embedded in the
    chipset.
    
    This is a snapshot of the first publicly available version of the driver,
    commit 4c1db2d0 in the 'historical' branch.
    
       git://git.kernel.org/pub/scm/linux/kernel/git/djbw/isci.git historical
    
    Signed-off-by: Maciej Trela <maciej.trela@intel.com>
    Signed-off-by: Dave Jiang <dave.jiang@intel.com>
    Signed-off-by: Edmund Nadolski <edmund.nadolski@intel.com>
    Signed-off-by: Dan Williams <dan.j.williams@intel.com>

diff --git a/drivers/scsi/isci/port.c b/drivers/scsi/isci/port.c
new file mode 100644
index 000000000000..2343f6556428
--- /dev/null
+++ b/drivers/scsi/isci/port.c
@@ -0,0 +1,484 @@
+/*
+ * This file is provided under a dual BSD/GPLv2 license.  When using or
+ * redistributing this file, you may do so under either license.
+ *
+ * GPL LICENSE SUMMARY
+ *
+ * Copyright(c) 2008 - 2011 Intel Corporation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of version 2 of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St - Fifth Floor, Boston, MA 02110-1301 USA.
+ * The full GNU General Public License is included in this distribution
+ * in the file called LICENSE.GPL.
+ *
+ * BSD LICENSE
+ *
+ * Copyright(c) 2008 - 2011 Intel Corporation. All rights reserved.
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ *   * Redistributions of source code must retain the above copyright
+ *     notice, this list of conditions and the following disclaimer.
+ *   * Redistributions in binary form must reproduce the above copyright
+ *     notice, this list of conditions and the following disclaimer in
+ *     the documentation and/or other materials provided with the
+ *     distribution.
+ *   * Neither the name of Intel Corporation nor the names of its
+ *     contributors may be used to endorse or promote products derived
+ *     from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+ * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+ * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+ * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+ * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+ * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+ * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+ * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+ * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+ * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/**
+ * This file contains the isci port implementation.
+ *
+ *
+ */
+
+
+#include <linux/workqueue.h>
+#include "isci.h"
+#include "scic_io_request.h"
+#include "scic_remote_device.h"
+#include "scic_phy.h"
+#include "scic_sds_phy.h"
+#include "scic_port.h"
+#include "port.h"
+#include "request.h"
+
+static void isci_port_change_state(
+	struct isci_port *isci_port,
+	enum isci_status status);
+
+
+
+/**
+ * isci_port_init() - This function initializes the given isci_port object.
+ * @isci_port: This parameter specifies the port object to be initialized.
+ * @isci_host: This parameter specifies parent controller object for the port.
+ * @index: This parameter specifies which SCU port the isci_port associates
+ *    with. Generally, SCU port 0 relates to isci_port 0, etc.
+ *
+ */
+void isci_port_init(
+	struct isci_port *isci_port,
+	struct isci_host *isci_host,
+	int index)
+{
+	struct scic_sds_port *scic_port;
+	struct scic_sds_controller *controller = isci_host->core_controller;
+
+	INIT_LIST_HEAD(&isci_port->remote_dev_list);
+	INIT_LIST_HEAD(&isci_port->domain_dev_list);
+	spin_lock_init(&isci_port->remote_device_lock);
+	spin_lock_init(&isci_port->state_lock);
+	init_completion(&isci_port->start_complete);
+	isci_port->isci_host = isci_host;
+	isci_port_change_state(isci_port, isci_freed);
+
+	(void)scic_controller_get_port_handle(controller, index, &scic_port);
+	sci_object_set_association(scic_port, isci_port);
+	isci_port->sci_port_handle = scic_port;
+}
+
+
+/**
+ * isci_port_get_state() - This function gets the status of the port object.
+ * @isci_port: This parameter points to the isci_port object
+ *
+ * status of the object as a isci_status enum.
+ */
+enum isci_status isci_port_get_state(
+	struct isci_port *isci_port)
+{
+	return isci_port->status;
+}
+
+static void isci_port_change_state(
+	struct isci_port *isci_port,
+	enum isci_status status)
+{
+	unsigned long flags;
+
+	dev_dbg(&isci_port->isci_host->pdev->dev,
+		"%s: isci_port = %p, state = 0x%x\n",
+		__func__, isci_port, status);
+
+	spin_lock_irqsave(&isci_port->state_lock, flags);
+	isci_port->status = status;
+	spin_unlock_irqrestore(&isci_port->state_lock, flags);
+}
+
+void isci_port_bc_change_received(
+	struct isci_host *isci_host,
+	struct scic_sds_port *port,
+	struct scic_sds_phy *phy)
+{
+	struct isci_phy *isci_phy =
+		(struct isci_phy *)sci_object_get_association(phy);
+
+	dev_dbg(&isci_host->pdev->dev,
+		"%s: isci_phy = %p, sas_phy = %p\n",
+		__func__,
+		isci_phy,
+		&isci_phy->sas_phy);
+
+	isci_host->sas_ha.notify_port_event(
+		&isci_phy->sas_phy,
+		PORTE_BROADCAST_RCVD
+		);
+
+	scic_port_enable_broadcast_change_notification(port);
+}
+
+/**
+ * isci_port_link_up() - This function is called by the sci core when a link
+ *    becomes active. the identify address frame is retrieved from the core and
+ *    a notify port event is sent to libsas.
+ * @isci_host: This parameter specifies the isci host object.
+ * @port: This parameter specifies the sci port with the active link.
+ * @phy: This parameter specifies the sci phy with the active link.
+ *
+ */
+void isci_port_link_up(
+	struct isci_host *isci_host,
+	struct scic_sds_port *port,
+	struct scic_sds_phy *phy)
+{
+	unsigned long flags;
+	struct scic_port_properties properties;
+	struct isci_phy *isci_phy
+		= (struct isci_phy *)sci_object_get_association(phy);
+	struct isci_port *isci_port
+		= (struct isci_port *)sci_object_get_association(port);
+	enum sci_status call_status;
+	unsigned long success = true;
+
+	BUG_ON(isci_phy->isci_port != NULL);
+	isci_phy->isci_port = isci_port;
+
+	dev_dbg(&isci_host->pdev->dev,
+		"%s: isci_port = %p\n",
+		__func__, isci_port);
+
+	spin_lock_irqsave(&isci_phy->sas_phy.frame_rcvd_lock, flags);
+
+	isci_port_change_state(isci_phy->isci_port, isci_starting);
+
+	scic_port_get_properties(port, &properties);
+
+	if (properties.remote.protocols.u.bits.stp_target) {
+
+		struct scic_sata_phy_properties sata_phy_properties;
+
+		isci_phy->sas_phy.oob_mode = SATA_OOB_MODE;
+
+		/* Get a copy of the signature fis for libsas */
+		call_status = scic_sata_phy_get_properties(phy,
+							   &sata_phy_properties);
+
+		/* 
+		 * XXX I am concerned about this "assert". shouldn't we
+		 * handle the return appropriately?
+		 */
+		BUG_ON(call_status != SCI_SUCCESS);
+
+		memcpy(isci_phy->frame_rcvd.fis,
+		       &sata_phy_properties.signature_fis,
+		       sizeof(struct sata_fis_reg_d2h));
+
+		isci_phy->sas_phy.frame_rcvd_size = sizeof(struct sata_fis_reg_d2h);
+
+		/*
+		 * For direct-attached SATA devices, the SCI core will
+		 * automagically assign a SAS address to the end device
+		 * for the purpose of creating a port. This SAS address
+		 * will not be the same as assigned to the PHY and needs
+		 * to be obtained from struct scic_port_properties properties.
+		 */
+
+		BUG_ON(((size_t)SAS_ADDR_SIZE / 2)
+		       != sizeof(properties.remote.sas_address.low));
+
+		memcpy(&isci_phy->sas_phy.attached_sas_addr[0],
+		       &properties.remote.sas_address.low,
+		       SAS_ADDR_SIZE / 2);
+
+		memcpy(&isci_phy->sas_phy.attached_sas_addr[4],
+		       &properties.remote.sas_address.high,
+		       SAS_ADDR_SIZE / 2);
+
+	} else if (properties.remote.protocols.u.bits.ssp_target ||
+		   properties.remote.protocols.u.bits.smp_target) {
+
+		struct scic_sas_phy_properties sas_phy_properties;
+
+		isci_phy->sas_phy.oob_mode = SAS_OOB_MODE;
+
+		/* Get a copy of the identify address frame for libsas */
+		call_status = scic_sas_phy_get_properties(phy,
+							  &sas_phy_properties);
+
+		BUG_ON(call_status != SCI_SUCCESS);
+
+		memcpy(isci_phy->frame_rcvd.aif,
+		       &(sas_phy_properties.received_iaf),
+		       sizeof(struct sci_sas_identify_address_frame));
+
+		isci_phy->sas_phy.frame_rcvd_size
+			= sizeof(struct sci_sas_identify_address_frame);
+
+		/* Copy the attached SAS address from the IAF */
+		memcpy(isci_phy->sas_phy.attached_sas_addr,
+		       ((struct sas_identify_frame *)
+			(&isci_phy->frame_rcvd.aif))->sas_addr,
+		       SAS_ADDR_SIZE);
+
+	} else {
+		dev_err(&isci_host->pdev->dev, "%s: unkown target\n", __func__);
+		success = false;
+	}
+
+	spin_unlock_irqrestore(&isci_phy->sas_phy.frame_rcvd_lock, flags);
+
+	/* Notify libsas that we have an address frame, if indeed
+	 * we've found an SSP, SMP, or STP target */
+	if (success)
+		isci_host->sas_ha.notify_port_event(&isci_phy->sas_phy,
+						    PORTE_BYTES_DMAED);
+}
+
+
+/**
+ * isci_port_link_down() - This function is called by the sci core when a link
+ *    becomes inactive.
+ * @isci_host: This parameter specifies the isci host object.
+ * @phy: This parameter specifies the isci phy with the active link.
+ * @port: This parameter specifies the isci port with the active link.
+ *
+ */
+void isci_port_link_down(
+	struct isci_host *isci_host,
+	struct isci_phy *isci_phy,
+	struct isci_port *isci_port)
+{
+	struct isci_remote_device *isci_device;
+
+	dev_dbg(&isci_host->pdev->dev,
+		"%s: isci_port = %p\n", __func__, isci_port);
+
+	if (isci_port) {
+
+		/* check to see if this is the last phy on this port. */
+		if (isci_phy->sas_phy.port
+		    && isci_phy->sas_phy.port->num_phys == 1) {
+
+			/* change the state for all devices on this port.
+			 * The next task sent to this device will be returned
+			 * as SAS_TASK_UNDELIVERED, and the scsi mid layer
+			 * will remove the target
+			 */
+			list_for_each_entry(isci_device,
+					    &isci_port->remote_dev_list,
+					    node) {
+				dev_dbg(&isci_host->pdev->dev,
+					"%s: isci_device = %p\n",
+					__func__, isci_device);
+				isci_remote_device_change_state(isci_device,
+								isci_stopping);
+			}
+		}
+		isci_port_change_state(isci_port, isci_stopping);
+	}
+
+	/* Notify libsas of the borken link, this will trigger calls to our
+	 * isci_port_deformed and isci_dev_gone functions.
+	 */
+	sas_phy_disconnected(&isci_phy->sas_phy);
+	isci_host->sas_ha.notify_phy_event(&isci_phy->sas_phy,
+					   PHYE_LOSS_OF_SIGNAL);
+
+	isci_phy->isci_port = NULL;
+
+	dev_dbg(&isci_host->pdev->dev,
+		"%s: isci_port = %p - Done\n", __func__, isci_port);
+}
+
+
+/**
+ * isci_port_deformed() - This function is called by libsas when a port becomes
+ *    inactive.
+ * @phy: This parameter specifies the libsas phy with the inactive port.
+ *
+ */
+void isci_port_deformed(
+	struct asd_sas_phy *phy)
+{
+	pr_debug("%s: sas_phy = %p\n", __func__, phy);
+}
+
+/**
+ * isci_port_formed() - This function is called by libsas when a port becomes
+ *    active.
+ * @phy: This parameter specifies the libsas phy with the active port.
+ *
+ */
+void isci_port_formed(
+	struct asd_sas_phy *phy)
+{
+	pr_debug("%s: sas_phy = %p, sas_port = %p\n", __func__, phy, phy->port);
+}
+
+/**
+ * isci_port_ready() - This function is called by the sci core when a link
+ *    becomes ready.
+ * @isci_host: This parameter specifies the isci host object.
+ * @port: This parameter specifies the sci port with the active link.
+ *
+ */
+void isci_port_ready(
+	struct isci_host *isci_host,
+	struct isci_port *isci_port)
+{
+	dev_dbg(&isci_host->pdev->dev,
+		"%s: isci_port = %p\n", __func__, isci_port);
+
+	complete_all(&isci_port->start_complete);
+	isci_port_change_state(isci_port, isci_ready);
+	return;
+}
+
+/**
+ * isci_port_not_ready() - This function is called by the sci core when a link
+ *    is not ready. All remote devices on this link will be removed if they are
+ *    in the stopping state.
+ * @isci_host: This parameter specifies the isci host object.
+ * @port: This parameter specifies the sci port with the active link.
+ *
+ */
+void isci_port_not_ready(
+	struct isci_host *isci_host,
+	struct isci_port *isci_port)
+{
+	dev_dbg(&isci_host->pdev->dev,
+		"%s: isci_port = %p\n", __func__, isci_port);
+}
+
+/**
+ * isci_port_hard_reset_complete() - This function is called by the sci core
+ *    when the hard reset complete notification has been received.
+ * @port: This parameter specifies the sci port with the active link.
+ * @completion_status: This parameter specifies the core status for the reset
+ *    process.
+ *
+ */
+void isci_port_hard_reset_complete(
+	struct isci_port *isci_port,
+	enum sci_status completion_status)
+{
+	dev_dbg(&isci_port->isci_host->pdev->dev,
+		"%s: isci_port = %p, completion_status=%x\n",
+		     __func__, isci_port, completion_status);
+
+	/* Save the status of the hard reset from the port. */
+	isci_port->hard_reset_status = completion_status;
+
+	complete_all(&isci_port->hard_reset_complete);
+}
+/**
+ * isci_port_perform_hard_reset() - This function is one of the SAS Domain
+ *    Template functions. This is a phy management function.
+ * @isci_port:
+ * @isci_phy:
+ *
+ * status, TMF_RESP_FUNC_COMPLETE indicates success.
+ */
+int isci_port_perform_hard_reset(
+	struct isci_port *isci_port,
+	struct isci_phy *isci_phy)
+{
+	enum sci_status status;
+	int ret = TMF_RESP_FUNC_COMPLETE;
+	unsigned long flags;
+
+
+	dev_dbg(&isci_port->isci_host->pdev->dev,
+		"%s: isci_port = %p\n",
+		__func__, isci_port);
+
+	BUG_ON(isci_port == NULL);
+
+	init_completion(&isci_port->hard_reset_complete);
+
+	spin_lock_irqsave(&isci_port->isci_host->scic_lock, flags);
+
+	#define ISCI_PORT_RESET_TIMEOUT SCIC_SDS_SIGNATURE_FIS_TIMEOUT
+	status = scic_port_hard_reset(isci_port->sci_port_handle,
+				      ISCI_PORT_RESET_TIMEOUT);
+
+	spin_unlock_irqrestore(&isci_port->isci_host->scic_lock, flags);
+
+	if (status == SCI_SUCCESS) {
+		wait_for_completion(&isci_port->hard_reset_complete);
+
+		dev_dbg(&isci_port->isci_host->pdev->dev,
+			"%s: isci_port = %p; hard reset completion\n",
+			__func__, isci_port);
+
+		if (isci_port->hard_reset_status != SCI_SUCCESS)
+			ret = TMF_RESP_FUNC_FAILED;
+	} else {
+		ret = TMF_RESP_FUNC_FAILED;
+
+		dev_err(&isci_port->isci_host->pdev->dev,
+			"%s: isci_port = %p; scic_port_hard_reset call"
+			" failed 0x%x\n",
+			__func__, isci_port, status);
+
+	}
+
+	/* If the hard reset for the port has failed, consider this
+	 * the same as link failures on all phys in the port.
+	 */
+	if (ret != TMF_RESP_FUNC_COMPLETE) {
+		BUG_ON(isci_port->isci_host == NULL);
+
+		dev_err(&isci_port->isci_host->pdev->dev,
+			"%s: isci_port = %p; hard reset failed "
+			"(0x%x) - sending link down to libsas for phy %p\n",
+			__func__,
+			isci_port,
+			isci_port->hard_reset_status,
+			isci_phy);
+
+		isci_port_link_down(isci_port->isci_host,
+				    isci_phy,
+				    isci_port);
+	}
+
+	return ret;
+}
