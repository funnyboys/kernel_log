commit f371d53453772bcbb9ac2201029b66281f713c07
Author: Jason Yan <yanaijie@huawei.com>
Date:   Tue Apr 21 11:40:29 2020 +0800

    scsi: sgiwd93: Remove unneeded semicolon in sgiwd93.c
    
    Fix the following coccicheck warning:
    
    drivers/scsi/sgiwd93.c:190:2-3: Unneeded semicolon
    
    Link: https://lore.kernel.org/r/20200421034029.28030-1-yanaijie@huawei.com
    Signed-off-by: Jason Yan <yanaijie@huawei.com>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/sgiwd93.c b/drivers/scsi/sgiwd93.c
index 713bce998b0e..3bdf0deb8f15 100644
--- a/drivers/scsi/sgiwd93.c
+++ b/drivers/scsi/sgiwd93.c
@@ -187,7 +187,7 @@ static inline void init_hpc_chain(struct ip22_hostdata *hdata)
 		hcp++;
 		dma += sizeof(struct hpc_chunk);
 		start += sizeof(struct hpc_chunk);
-	};
+	}
 	hcp--;
 	hcp->desc.pnext = hdata->dma;
 }

commit 4af14d113bcf95c12d1462ba623b7e7117bd3fb3
Author: Christoph Hellwig <hch@lst.de>
Date:   Thu Dec 13 16:17:09 2018 +0100

    scsi: remove the use_clustering flag
    
    The same effects can be achieved by setting the dma_boundary to
    PAGE_SIZE - 1 and the max_segment_size to PAGE_SIZE, so shift those
    settings into the drivers.  Note that in many cases the setting might
    be bogus, but this keeps the status quo.
    
    [mkp: fix myrs and myrb]
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/sgiwd93.c b/drivers/scsi/sgiwd93.c
index 5ed696dc9bbd..713bce998b0e 100644
--- a/drivers/scsi/sgiwd93.c
+++ b/drivers/scsi/sgiwd93.c
@@ -208,7 +208,7 @@ static struct scsi_host_template sgiwd93_template = {
 	.this_id		= 7,
 	.sg_tablesize		= SG_ALL,
 	.cmd_per_lun		= 8,
-	.use_clustering		= DISABLE_CLUSTERING,
+	.dma_boundary		= PAGE_SIZE - 1,
 };
 
 static int sgiwd93_probe(struct platform_device *pdev)

commit ec05e23896910380ccb6d64f1b95a2310fa0c868
Author: Hannes Reinecke <hare@suse.de>
Date:   Fri Aug 25 13:57:06 2017 +0200

    scsi: drop bus reset for wd33c93-compatible boards
    
    The bus reset function is just a wrapper calling host reset under the
    host lock. So move taking of the host lock into the host reset function
    and drop bus reset.
    
    Signed-off-by: Hannes Reinecke <hare@suse.com>
    Reviewed-by: Christoph Hellwig <hch@lst.de>
    Reviewed-by: Johannes Thumshirn <jthumshirn@suse.de>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/sgiwd93.c b/drivers/scsi/sgiwd93.c
index 80cfa93e407c..5ed696dc9bbd 100644
--- a/drivers/scsi/sgiwd93.c
+++ b/drivers/scsi/sgiwd93.c
@@ -192,20 +192,6 @@ static inline void init_hpc_chain(struct ip22_hostdata *hdata)
 	hcp->desc.pnext = hdata->dma;
 }
 
-static int sgiwd93_bus_reset(struct scsi_cmnd *cmd)
-{
-	/* FIXME perform bus-specific reset */
-
-	/* FIXME 2: kill this function, and let midlayer fallback
-	   to the same result, calling wd33c93_host_reset() */
-
-	spin_lock_irq(cmd->device->host->host_lock);
-	wd33c93_host_reset(cmd);
-	spin_unlock_irq(cmd->device->host->host_lock);
-
-	return SUCCESS;
-}
-
 /*
  * Kludge alert - the SCSI code calls the abort and reset method with int
  * arguments not with pointers.  So this is going to blow up beautyfully
@@ -217,7 +203,6 @@ static struct scsi_host_template sgiwd93_template = {
 	.name			= "SGI WD93",
 	.queuecommand		= wd33c93_queuecommand,
 	.eh_abort_handler	= wd33c93_abort,
-	.eh_bus_reset_handler	= sgiwd93_bus_reset,
 	.eh_host_reset_handler	= wd33c93_host_reset,
 	.can_queue		= 16,
 	.this_id		= 7,

commit d31b77911505bbd0cd06403bd5eff26d691ad62d
Author: Christoph Hellwig <hch@lst.de>
Date:   Fri Jun 16 09:17:11 2017 +0200

    scsi: sgiwd93: switch to dma_alloc_attrs
    
    Use dma_alloc_attrs directly instead of the dma_alloc_noncoherent
    wrapper.
    
    [mkp: fixed driver name]
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/sgiwd93.c b/drivers/scsi/sgiwd93.c
index 71b4b91d2215..80cfa93e407c 100644
--- a/drivers/scsi/sgiwd93.c
+++ b/drivers/scsi/sgiwd93.c
@@ -249,8 +249,8 @@ static int sgiwd93_probe(struct platform_device *pdev)
 
 	hdata = host_to_hostdata(host);
 	hdata->dev = &pdev->dev;
-	hdata->cpu = dma_alloc_noncoherent(&pdev->dev, HPC_DMA_SIZE,
-					   &hdata->dma, GFP_KERNEL);
+	hdata->cpu = dma_alloc_attrs(&pdev->dev, HPC_DMA_SIZE, &hdata->dma,
+				     GFP_KERNEL, DMA_ATTR_NON_CONSISTENT);
 	if (!hdata->cpu) {
 		printk(KERN_WARNING "sgiwd93: Could not allocate memory for "
 		       "host %d buffer.\n", unit);
@@ -289,7 +289,8 @@ static int sgiwd93_probe(struct platform_device *pdev)
 out_irq:
 	free_irq(irq, host);
 out_free:
-	dma_free_noncoherent(&pdev->dev, HPC_DMA_SIZE, hdata->cpu, hdata->dma);
+	dma_free_attrs(&pdev->dev, HPC_DMA_SIZE, hdata->cpu, hdata->dma,
+		       DMA_ATTR_NON_CONSISTENT);
 out_put:
 	scsi_host_put(host);
 out:
@@ -305,7 +306,8 @@ static int sgiwd93_remove(struct platform_device *pdev)
 
 	scsi_remove_host(host);
 	free_irq(pd->irq, host);
-	dma_free_noncoherent(&pdev->dev, HPC_DMA_SIZE, hdata->cpu, hdata->dma);
+	dma_free_attrs(&pdev->dev, HPC_DMA_SIZE, hdata->cpu, hdata->dma,
+		       DMA_ATTR_NON_CONSISTENT);
 	scsi_host_put(host);
 	return 0;
 }

commit ba21222d00a450ce3bfced0e047f52470372634d
Author: Dmitry Torokhov <dmitry.torokhov@gmail.com>
Date:   Wed Mar 1 17:38:38 2017 -0800

    scsi: remove incorrect __exit markups
    
    Even if bus is not hot-pluggable, devices can be unbound from the driver
    via sysfs, so we should not be using __exit annotations on remove()
    methods. The only exception is drivers registered with
    platform_driver_probe() which specifically disables sysfs bind/unbind
    attributes.
    
    Signed-off-by: Dmitry Torokhov <dmitry.torokhov@gmail.com>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/sgiwd93.c b/drivers/scsi/sgiwd93.c
index 6d215e2fb46d..71b4b91d2215 100644
--- a/drivers/scsi/sgiwd93.c
+++ b/drivers/scsi/sgiwd93.c
@@ -297,7 +297,7 @@ static int sgiwd93_probe(struct platform_device *pdev)
 	return err;
 }
 
-static int __exit sgiwd93_remove(struct platform_device *pdev)
+static int sgiwd93_remove(struct platform_device *pdev)
 {
 	struct Scsi_Host *host = platform_get_drvdata(pdev);
 	struct ip22_hostdata *hdata = (struct ip22_hostdata *) host->hostdata;

commit b36069c833d9440774d5daab143ec15ea026f34a
Author: Wolfram Sang <wsa@the-dreams.de>
Date:   Mon Oct 20 16:21:33 2014 +0200

    scsi: drop owner assignment from platform_drivers
    
    A platform_driver does not need to set an owner, it will be populated by the
    driver core.
    
    Signed-off-by: Wolfram Sang <wsa@the-dreams.de>

diff --git a/drivers/scsi/sgiwd93.c b/drivers/scsi/sgiwd93.c
index a464d959f66e..6d215e2fb46d 100644
--- a/drivers/scsi/sgiwd93.c
+++ b/drivers/scsi/sgiwd93.c
@@ -315,7 +315,6 @@ static struct platform_driver sgiwd93_driver = {
 	.remove = sgiwd93_remove,
 	.driver = {
 		.name   = "sgiwd93",
-		.owner	= THIS_MODULE,
 	}
 };
 

commit 6f039790510fd630ff348efe8c4802dbaa041fba
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Fri Dec 21 13:08:55 2012 -0800

    Drivers: scsi: remove __dev* attributes.
    
    CONFIG_HOTPLUG is going away as an option.  As a result, the __dev*
    markings need to be removed.
    
    This change removes the use of __devinit, __devexit_p, __devinitdata,
    __devinitconst, and __devexit from these drivers.
    
    Based on patches originally written by Bill Pemberton, but redone by me
    in order to handle some of the coding style issues better, by hand.
    
    Cc: Bill Pemberton <wfp5p@virginia.edu>
    Cc: Adam Radford <linuxraid@lsi.com>
    Cc: "James E.J. Bottomley" <JBottomley@parallels.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/scsi/sgiwd93.c b/drivers/scsi/sgiwd93.c
index 3a9d85ca6047..a464d959f66e 100644
--- a/drivers/scsi/sgiwd93.c
+++ b/drivers/scsi/sgiwd93.c
@@ -226,7 +226,7 @@ static struct scsi_host_template sgiwd93_template = {
 	.use_clustering		= DISABLE_CLUSTERING,
 };
 
-static int __devinit sgiwd93_probe(struct platform_device *pdev)
+static int sgiwd93_probe(struct platform_device *pdev)
 {
 	struct sgiwd93_platform_data *pd = pdev->dev.platform_data;
 	unsigned char *wdregs = pd->wdregs;
@@ -312,7 +312,7 @@ static int __exit sgiwd93_remove(struct platform_device *pdev)
 
 static struct platform_driver sgiwd93_driver = {
 	.probe  = sgiwd93_probe,
-	.remove = __devexit_p(sgiwd93_remove),
+	.remove = sgiwd93_remove,
 	.driver = {
 		.name   = "sgiwd93",
 		.owner	= THIS_MODULE,

commit 79add6277396b91c638f16eb2f1338badc47760d
Author: Justin P. Mattock <justinmattock@gmail.com>
Date:   Mon Apr 4 14:15:29 2011 -0700

    update David Miller's old email address
    
    Signed-off-by: Justin P. Mattock <justinmattock@gmail.com>
    Acked-by: David S. Miller <davem@davemloft.net>
    Signed-off-by: Jiri Kosina <jkosina@suse.cz>

diff --git a/drivers/scsi/sgiwd93.c b/drivers/scsi/sgiwd93.c
index fef0e3c75b16..3a9d85ca6047 100644
--- a/drivers/scsi/sgiwd93.c
+++ b/drivers/scsi/sgiwd93.c
@@ -3,7 +3,7 @@
  * License.  See the file "COPYING" in the main directory of this archive
  * for more details.
  *
- * Copyright (C) 1996 David S. Miller (dm@engr.sgi.com)
+ * Copyright (C) 1996 David S. Miller (davem@davemloft.net)
  * Copyright (C) 1999 Andrew R. Baker (andrewb@uab.edu)
  * Copyright (C) 2001 Florian Lohoff (flo@rfc822.org)
  * Copyright (C) 2003, 07 Ralf Baechle (ralf@linux-mips.org)

commit 1b07193b34c1bc1c184e2d53a62633a73ea9b0a0
Author: Uwe Kleine-König <u.kleine-koenig@pengutronix.de>
Date:   Thu Feb 4 20:56:50 2010 +0100

    platform-drivers: move probe to .devinit.text in drivers/scsi
    
    A pointer to a probe callback is passed to the core via
    platform_driver_register and so the function must not disappear when the
    .init sections are discarded.  Otherwise (if also having HOTPLUG=y)
    unbinding and binding a device to the driver via sysfs will result in an
    oops as does a device being registered late.
    
    An alternative to this patch is using platform_driver_probe instead of
    platform_driver_register plus removing the pointer to the probe function
    from the struct platform_driver.
    
    Signed-off-by: Uwe Kleine-König <u.kleine-koenig@pengutronix.de>
    Cc: Andrew Morton <akpm@linux-foundation.org>
    Cc: David Brownell <dbrownell@users.sourceforge.net>
    Cc: Dmitri Vorobiev <dmitri.vorobiev@movial.fi>
    Cc: Henrik Kretzschmar <henne@nachtwindheim.de>
    Cc: James Bottomley <James.Bottomley@HansenPartnership.com>
    Cc: Kay Sievers <kay.sievers@vrfy.org>
    Cc: peter fuerst <post@pfrst.de>
    Cc: Thomas Bogendoerfer <tsbogend@alpha.franken.de>
    Acked-by: Ralf Baechle <ralf@linux-mips.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/scsi/sgiwd93.c b/drivers/scsi/sgiwd93.c
index 0807b260268b..fef0e3c75b16 100644
--- a/drivers/scsi/sgiwd93.c
+++ b/drivers/scsi/sgiwd93.c
@@ -226,7 +226,7 @@ static struct scsi_host_template sgiwd93_template = {
 	.use_clustering		= DISABLE_CLUSTERING,
 };
 
-static int __init sgiwd93_probe(struct platform_device *pdev)
+static int __devinit sgiwd93_probe(struct platform_device *pdev)
 {
 	struct sgiwd93_platform_data *pd = pdev->dev.platform_data;
 	unsigned char *wdregs = pd->wdregs;

commit b99b4c67db9b6dde67955b3746666505a48ec7ee
Author: Dmitri Vorobiev <dmitri.vorobiev@movial.fi>
Date:   Tue Dec 16 15:04:44 2008 +0200

    [SCSI] sgiwd93: Fix compilation warning
    
    The remove() callback in platform drivers should return int in
    accordance to the definition of the platform_driver structure.
    However, the SGI-specific WD93 SCSI controller driver defines
    the callback as a void function, which causes the following
    compilation warning:
    
    drivers/scsi/sgiwd93.c:314: warning: initialization from
    incompatible pointer type
    
    This patch fixes the warning by changing the return type of
    the remove() callback to what the core driver code requires.
    
    Signed-off-by: Dmitri Vorobiev <dmitri.vorobiev@movial.fi>
    Signed-off-by: James Bottomley <James.Bottomley@HansenPartnership.com>

diff --git a/drivers/scsi/sgiwd93.c b/drivers/scsi/sgiwd93.c
index 31fe6051c799..0807b260268b 100644
--- a/drivers/scsi/sgiwd93.c
+++ b/drivers/scsi/sgiwd93.c
@@ -297,7 +297,7 @@ static int __init sgiwd93_probe(struct platform_device *pdev)
 	return err;
 }
 
-static void __exit sgiwd93_remove(struct platform_device *pdev)
+static int __exit sgiwd93_remove(struct platform_device *pdev)
 {
 	struct Scsi_Host *host = platform_get_drvdata(pdev);
 	struct ip22_hostdata *hdata = (struct ip22_hostdata *) host->hostdata;
@@ -307,6 +307,7 @@ static void __exit sgiwd93_remove(struct platform_device *pdev)
 	free_irq(pd->irq, host);
 	dma_free_noncoherent(&pdev->dev, HPC_DMA_SIZE, hdata->cpu, hdata->dma);
 	scsi_host_put(host);
+	return 0;
 }
 
 static struct platform_driver sgiwd93_driver = {

commit ecc1241e80a0bdc854b1602a44be3ad106753d4f
Author: Kay Sievers <kay.sievers@vrfy.org>
Date:   Fri Apr 18 13:57:19 2008 -0700

    [SCSI] jazz_esp, sgiwd93, sni_53c710, sun3x_esp: fix platform driver hotplug/coldplug
    
    Since
    
    commit 43cc71eed1250755986da4c0f9898f9a635cb3bf
    Author: Kay Sievers <kay.sievers@vrfy.org>
    Date:   Sat Aug 18 04:40:39 2007 +0200
    
        platform: prefix MODALIAS with "platform:"
    
    the platform modalias is prefixed with "platform:". Add MODULE_ALIAS()
    to the hotpluggable SCSI platform drivers, to re-enable auto loading.
    
    [dbrownell@users.sourceforge.net: more drivers, registration fixes]
    [akpm@linux-foundation.org: fix sgiwd93.c]
    Signed-off-by: Kay Sievers <kay.sievers@vrfy.org>
    Signed-off-by: David Brownell <dbrownell@users.sourceforge.net>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: James Bottomley <James.Bottomley@HansenPartnership.com>

diff --git a/drivers/scsi/sgiwd93.c b/drivers/scsi/sgiwd93.c
index 03e359670506..31fe6051c799 100644
--- a/drivers/scsi/sgiwd93.c
+++ b/drivers/scsi/sgiwd93.c
@@ -313,7 +313,8 @@ static struct platform_driver sgiwd93_driver = {
 	.probe  = sgiwd93_probe,
 	.remove = __devexit_p(sgiwd93_remove),
 	.driver = {
-		.name   = "sgiwd93"
+		.name   = "sgiwd93",
+		.owner	= THIS_MODULE,
 	}
 };
 
@@ -333,3 +334,4 @@ module_exit(sgiwd93_module_exit);
 MODULE_DESCRIPTION("SGI WD33C93 driver");
 MODULE_AUTHOR("Ralf Baechle <ralf@linux-mips.org>");
 MODULE_LICENSE("GPL");
+MODULE_ALIAS("platform:sgiwd93");

commit be3cb3d84bb8dffecb7c5570355866075caa7e95
Author: Thomas Bogendoerfer <tsbogend@alpha.franken.de>
Date:   Fri Mar 21 22:25:43 2008 +0100

    [SCSI] WD33C93: let platform stub override no_sync/fast/dma_mode
    
    SGI machines with WD33C93 allow usage of burst mode DMA, which increases
    performance noticable. To make this selectable by the sgiwd93 stub,
    setting the values for no_sync, fast and dma_mode has been moved to the
    individual platform stubs.
    
    Signed-off-by: Thomas Bogendoerfer <tsbogend@alpha.franken.de>
    Acked-by: Ralf Baechle <ralf@linux-mips.org>
    Signed-off-by: James Bottomley <James.Bottomley@HansenPartnership.com>

diff --git a/drivers/scsi/sgiwd93.c b/drivers/scsi/sgiwd93.c
index 26cfc56c7091..03e359670506 100644
--- a/drivers/scsi/sgiwd93.c
+++ b/drivers/scsi/sgiwd93.c
@@ -263,10 +263,11 @@ static int __init sgiwd93_probe(struct platform_device *pdev)
 	regs.SASR = wdregs + 3;
 	regs.SCMD = wdregs + 7;
 
-	wd33c93_init(host, regs, dma_setup, dma_stop, WD33C93_FS_MHZ(20));
+	hdata->wh.no_sync = 0;
+	hdata->wh.fast = 1;
+	hdata->wh.dma_mode = CTRL_BURST;
 
-	if (hdata->wh.no_sync == 0xff)
-		hdata->wh.no_sync = 0;
+	wd33c93_init(host, regs, dma_setup, dma_stop, WD33C93_FS_MHZ(20));
 
 	err = request_irq(irq, sgiwd93_intr, 0, "SGI WD93", host);
 	if (err) {

commit 2adbfa333ad2c365bd27f3cf21ae464501d9619d
Author: Thomas Bogendoerfer <tsbogend@alpha.franken.de>
Date:   Sun Jan 27 00:25:53 2008 +0100

    [SCSI] sgiwd93: use cached memory access to make driver work on IP28
    
    SGI IP28 machines would need special treatment (enable adding addtional
    wait states) when accessing memory uncached. To avoid this pain I
    changed the driver to use only cached access to memory.
    
    Signed-off-by: Thomas Bogendoerfer <tsbogend@alpha.franken.de>
    Signed-off-by: James Bottomley <James.Bottomley@HansenPartnership.com>

diff --git a/drivers/scsi/sgiwd93.c b/drivers/scsi/sgiwd93.c
index d4ebe8c67ba9..26cfc56c7091 100644
--- a/drivers/scsi/sgiwd93.c
+++ b/drivers/scsi/sgiwd93.c
@@ -33,10 +33,9 @@
 
 struct ip22_hostdata {
 	struct WD33C93_hostdata wh;
-	struct hpc_data {
-		dma_addr_t      dma;
-		void		*cpu;
-	} hd;
+	dma_addr_t dma;
+	void *cpu;
+	struct device *dev;
 };
 
 #define host_to_hostdata(host) ((struct ip22_hostdata *)((host)->hostdata))
@@ -46,6 +45,11 @@ struct hpc_chunk {
 	u32 _padding;	/* align to quadword boundary */
 };
 
+/* space for hpc dma descriptors */
+#define HPC_DMA_SIZE   PAGE_SIZE
+
+#define DMA_DIR(d)   ((d == DATA_OUT_DIR) ? DMA_TO_DEVICE : DMA_FROM_DEVICE)
+
 static irqreturn_t sgiwd93_intr(int irq, void *dev_id)
 {
 	struct Scsi_Host * host = dev_id;
@@ -59,15 +63,17 @@ static irqreturn_t sgiwd93_intr(int irq, void *dev_id)
 }
 
 static inline
-void fill_hpc_entries(struct hpc_chunk *hcp, struct scsi_cmnd *cmd, int datainp)
+void fill_hpc_entries(struct ip22_hostdata *hd, struct scsi_cmnd *cmd, int din)
 {
 	unsigned long len = cmd->SCp.this_residual;
 	void *addr = cmd->SCp.ptr;
 	dma_addr_t physaddr;
 	unsigned long count;
+	struct hpc_chunk *hcp;
 
-	physaddr = dma_map_single(NULL, addr, len, cmd->sc_data_direction);
+	physaddr = dma_map_single(hd->dev, addr, len, DMA_DIR(din));
 	cmd->SCp.dma_handle = physaddr;
+	hcp = hd->cpu;
 
 	while (len) {
 		/*
@@ -89,6 +95,9 @@ void fill_hpc_entries(struct hpc_chunk *hcp, struct scsi_cmnd *cmd, int datainp)
 	 */
 	hcp->desc.pbuf = 0;
 	hcp->desc.cntinfo = HPCDMA_EOX;
+	dma_cache_sync(hd->dev, hd->cpu,
+		       (unsigned long)(hcp + 1) - (unsigned long)hd->cpu,
+		       DMA_TO_DEVICE);
 }
 
 static int dma_setup(struct scsi_cmnd *cmd, int datainp)
@@ -96,9 +105,8 @@ static int dma_setup(struct scsi_cmnd *cmd, int datainp)
 	struct ip22_hostdata *hdata = host_to_hostdata(cmd->device->host);
 	struct hpc3_scsiregs *hregs =
 		(struct hpc3_scsiregs *) cmd->device->host->base;
-	struct hpc_chunk *hcp = (struct hpc_chunk *) hdata->hd.cpu;
 
-	pr_debug("dma_setup: datainp<%d> hcp<%p> ", datainp, hcp);
+	pr_debug("dma_setup: datainp<%d> hcp<%p> ", datainp, hdata->cpu);
 
 	hdata->wh.dma_dir = datainp;
 
@@ -111,12 +119,12 @@ static int dma_setup(struct scsi_cmnd *cmd, int datainp)
 	if (cmd->SCp.ptr == NULL || cmd->SCp.this_residual == 0)
 		return 1;
 
-	fill_hpc_entries(hcp, cmd, datainp);
+	fill_hpc_entries(hdata, cmd, datainp);
 
 	pr_debug(" HPCGO\n");
 
 	/* Start up the HPC. */
-	hregs->ndptr = hdata->hd.dma;
+	hregs->ndptr = hdata->dma;
 	if (datainp)
 		hregs->ctrl = HPC3_SCTRL_ACTIVE;
 	else
@@ -134,6 +142,9 @@ static void dma_stop(struct Scsi_Host *instance, struct scsi_cmnd *SCpnt,
 	if (!SCpnt)
 		return;
 
+	if (SCpnt->SCp.ptr == NULL || SCpnt->SCp.this_residual == 0)
+		return;
+
 	hregs = (struct hpc3_scsiregs *) SCpnt->device->host->base;
 
 	pr_debug("dma_stop: status<%d> ", status);
@@ -145,8 +156,9 @@ static void dma_stop(struct Scsi_Host *instance, struct scsi_cmnd *SCpnt,
 			barrier();
 	}
 	hregs->ctrl = 0;
-	dma_unmap_single(NULL, SCpnt->SCp.dma_handle, SCpnt->SCp.this_residual,
-	                 SCpnt->sc_data_direction);
+	dma_unmap_single(hdata->dev, SCpnt->SCp.dma_handle,
+			 SCpnt->SCp.this_residual,
+			 DMA_DIR(hdata->wh.dma_dir));
 
 	pr_debug("\n");
 }
@@ -161,22 +173,23 @@ void sgiwd93_reset(unsigned long base)
 }
 EXPORT_SYMBOL_GPL(sgiwd93_reset);
 
-static inline void init_hpc_chain(struct hpc_data *hd)
+static inline void init_hpc_chain(struct ip22_hostdata *hdata)
 {
-	struct hpc_chunk *hcp = (struct hpc_chunk *) hd->cpu;
-	struct hpc_chunk *dma = (struct hpc_chunk *) hd->dma;
+	struct hpc_chunk *hcp = (struct hpc_chunk *)hdata->cpu;
+	dma_addr_t dma = hdata->dma;
 	unsigned long start, end;
 
 	start = (unsigned long) hcp;
-	end = start + PAGE_SIZE;
+	end = start + HPC_DMA_SIZE;
 	while (start < end) {
-		hcp->desc.pnext = (u32) (dma + 1);
+		hcp->desc.pnext = (u32) (dma + sizeof(struct hpc_chunk));
 		hcp->desc.cntinfo = HPCDMA_EOX;
-		hcp++; dma++;
+		hcp++;
+		dma += sizeof(struct hpc_chunk);
 		start += sizeof(struct hpc_chunk);
 	};
 	hcp--;
-	hcp->desc.pnext = hd->dma;
+	hcp->desc.pnext = hdata->dma;
 }
 
 static int sgiwd93_bus_reset(struct scsi_cmnd *cmd)
@@ -235,16 +248,17 @@ static int __init sgiwd93_probe(struct platform_device *pdev)
 	host->irq = irq;
 
 	hdata = host_to_hostdata(host);
-	hdata->hd.cpu = dma_alloc_coherent(&pdev->dev, PAGE_SIZE,
-	                                   &hdata->hd.dma, GFP_KERNEL);
-	if (!hdata->hd.cpu) {
+	hdata->dev = &pdev->dev;
+	hdata->cpu = dma_alloc_noncoherent(&pdev->dev, HPC_DMA_SIZE,
+					   &hdata->dma, GFP_KERNEL);
+	if (!hdata->cpu) {
 		printk(KERN_WARNING "sgiwd93: Could not allocate memory for "
 		       "host %d buffer.\n", unit);
 		err = -ENOMEM;
 		goto out_put;
 	}
 
-	init_hpc_chain(&hdata->hd);
+	init_hpc_chain(hdata);
 
 	regs.SASR = wdregs + 3;
 	regs.SCMD = wdregs + 7;
@@ -274,7 +288,7 @@ static int __init sgiwd93_probe(struct platform_device *pdev)
 out_irq:
 	free_irq(irq, host);
 out_free:
-	dma_free_coherent(NULL, PAGE_SIZE, hdata->hd.cpu, hdata->hd.dma);
+	dma_free_noncoherent(&pdev->dev, HPC_DMA_SIZE, hdata->cpu, hdata->dma);
 out_put:
 	scsi_host_put(host);
 out:
@@ -290,7 +304,7 @@ static void __exit sgiwd93_remove(struct platform_device *pdev)
 
 	scsi_remove_host(host);
 	free_irq(pd->irq, host);
-	dma_free_coherent(&pdev->dev, PAGE_SIZE, hdata->hd.cpu, hdata->hd.dma);
+	dma_free_noncoherent(&pdev->dev, HPC_DMA_SIZE, hdata->cpu, hdata->dma);
 	scsi_host_put(host);
 }
 

commit fc9b5118823e84b4ed0acddd99c1e453298e103d
Author: Andrew Morton <akpm@linux-foundation.org>
Date:   Thu Dec 13 16:14:23 2007 -0800

    [SCSI] sgiwd93: export sgiwd93_reset()
    
    mips allmodconfig:
    
    ERROR: "sgiwd93_reset" [drivers/scsi/wd33c93.ko] undefined!
    
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: James Bottomley <James.Bottomley@HansenPartnership.com>

diff --git a/drivers/scsi/sgiwd93.c b/drivers/scsi/sgiwd93.c
index eef82758d047..d4ebe8c67ba9 100644
--- a/drivers/scsi/sgiwd93.c
+++ b/drivers/scsi/sgiwd93.c
@@ -159,6 +159,7 @@ void sgiwd93_reset(unsigned long base)
 	udelay(50);
 	hregs->ctrl = 0;
 }
+EXPORT_SYMBOL_GPL(sgiwd93_reset);
 
 static inline void init_hpc_chain(struct hpc_data *hd)
 {

commit df9f54084f1faf611cedd846d38b0631f9d4e9a5
Author: Ralf Baechle <ralf@linux-mips.org>
Date:   Fri May 11 15:48:58 2007 +0100

    Convert SGI IP22 and specific drivers to platform_device.
    
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>

diff --git a/drivers/scsi/sgiwd93.c b/drivers/scsi/sgiwd93.c
index a15752b37990..eef82758d047 100644
--- a/drivers/scsi/sgiwd93.c
+++ b/drivers/scsi/sgiwd93.c
@@ -6,87 +6,49 @@
  * Copyright (C) 1996 David S. Miller (dm@engr.sgi.com)
  * Copyright (C) 1999 Andrew R. Baker (andrewb@uab.edu)
  * Copyright (C) 2001 Florian Lohoff (flo@rfc822.org)
- * Copyright (C) 2003 Ralf Baechle (ralf@linux-mips.org)
+ * Copyright (C) 2003, 07 Ralf Baechle (ralf@linux-mips.org)
  * 
  * (In all truth, Jed Schimmel wrote all this code.)
  */
-#include <linux/init.h>
-#include <linux/interrupt.h>
-#include <linux/types.h>
-#include <linux/mm.h>
-#include <linux/blkdev.h>
+
+#undef DEBUG
+
 #include <linux/delay.h>
 #include <linux/dma-mapping.h>
+#include <linux/gfp.h>
+#include <linux/interrupt.h>
+#include <linux/init.h>
+#include <linux/kernel.h>
+#include <linux/types.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
 #include <linux/spinlock.h>
 
-#include <asm/page.h>
-#include <asm/pgtable.h>
-#include <asm/sgialib.h>
-#include <asm/sgi/sgi.h>
-#include <asm/sgi/mc.h>
 #include <asm/sgi/hpc3.h>
 #include <asm/sgi/ip22.h>
-#include <asm/irq.h>
-#include <asm/io.h>
+#include <asm/sgi/wd.h>
 
 #include "scsi.h"
-#include <scsi/scsi_host.h>
 #include "wd33c93.h"
 
-#include <linux/stat.h>
-
-#if 0
-#define DPRINTK(args...)	printk(args)
-#else
-#define DPRINTK(args...)
-#endif
-
-#define HDATA(ptr) ((struct ip22_hostdata *)((ptr)->hostdata))
-
 struct ip22_hostdata {
 	struct WD33C93_hostdata wh;
 	struct hpc_data {
 		dma_addr_t      dma;
-		void            * cpu;
+		void		*cpu;
 	} hd;
 };
 
+#define host_to_hostdata(host) ((struct ip22_hostdata *)((host)->hostdata))
+
 struct hpc_chunk {
 	struct hpc_dma_desc desc;
 	u32 _padding;	/* align to quadword boundary */
 };
 
-struct Scsi_Host *sgiwd93_host;
-struct Scsi_Host *sgiwd93_host1;
-
-/* Wuff wuff, wuff, wd33c93.c, wuff wuff, object oriented, bow wow. */
-static inline void write_wd33c93_count(const wd33c93_regs regs,
-                                      unsigned long value)
-{
-	*regs.SASR = WD_TRANSFER_COUNT_MSB;
-	mb();
-	*regs.SCMD = ((value >> 16) & 0xff);
-	*regs.SCMD = ((value >>  8) & 0xff);
-	*regs.SCMD = ((value >>  0) & 0xff);
-	mb();
-}
-
-static inline unsigned long read_wd33c93_count(const wd33c93_regs regs)
-{
-	unsigned long value;
-
-	*regs.SASR = WD_TRANSFER_COUNT_MSB;
-	mb();
-	value =  ((*regs.SCMD & 0xff) << 16);
-	value |= ((*regs.SCMD & 0xff) <<  8);
-	value |= ((*regs.SCMD & 0xff) <<  0);
-	mb();
-	return value;
-}
-
 static irqreturn_t sgiwd93_intr(int irq, void *dev_id)
 {
-	struct Scsi_Host * host = (struct Scsi_Host *) dev_id;
+	struct Scsi_Host * host = dev_id;
 	unsigned long flags;
 
 	spin_lock_irqsave(host->host_lock, flags);
@@ -131,12 +93,12 @@ void fill_hpc_entries(struct hpc_chunk *hcp, struct scsi_cmnd *cmd, int datainp)
 
 static int dma_setup(struct scsi_cmnd *cmd, int datainp)
 {
-	struct ip22_hostdata *hdata = HDATA(cmd->device->host);
+	struct ip22_hostdata *hdata = host_to_hostdata(cmd->device->host);
 	struct hpc3_scsiregs *hregs =
 		(struct hpc3_scsiregs *) cmd->device->host->base;
 	struct hpc_chunk *hcp = (struct hpc_chunk *) hdata->hd.cpu;
 
-	DPRINTK("dma_setup: datainp<%d> hcp<%p> ", datainp, hcp);
+	pr_debug("dma_setup: datainp<%d> hcp<%p> ", datainp, hcp);
 
 	hdata->wh.dma_dir = datainp;
 
@@ -151,7 +113,7 @@ static int dma_setup(struct scsi_cmnd *cmd, int datainp)
 
 	fill_hpc_entries(hcp, cmd, datainp);
 
-	DPRINTK(" HPCGO\n");
+	pr_debug(" HPCGO\n");
 
 	/* Start up the HPC. */
 	hregs->ndptr = hdata->hd.dma;
@@ -166,7 +128,7 @@ static int dma_setup(struct scsi_cmnd *cmd, int datainp)
 static void dma_stop(struct Scsi_Host *instance, struct scsi_cmnd *SCpnt,
 		     int status)
 {
-	struct ip22_hostdata *hdata = HDATA(instance);
+	struct ip22_hostdata *hdata = host_to_hostdata(instance);
 	struct hpc3_scsiregs *hregs;
 
 	if (!SCpnt)
@@ -174,7 +136,7 @@ static void dma_stop(struct Scsi_Host *instance, struct scsi_cmnd *SCpnt,
 
 	hregs = (struct hpc3_scsiregs *) SCpnt->device->host->base;
 
-	DPRINTK("dma_stop: status<%d> ", status);
+	pr_debug("dma_stop: status<%d> ", status);
 
 	/* First stop the HPC and flush it's FIFO. */
 	if (hdata->wh.dma_dir) {
@@ -186,7 +148,7 @@ static void dma_stop(struct Scsi_Host *instance, struct scsi_cmnd *SCpnt,
 	dma_unmap_single(NULL, SCpnt->SCp.dma_handle, SCpnt->SCp.this_residual,
 	                 SCpnt->sc_data_direction);
 
-	DPRINTK("\n");
+	pr_debug("\n");
 }
 
 void sgiwd93_reset(unsigned long base)
@@ -216,29 +178,71 @@ static inline void init_hpc_chain(struct hpc_data *hd)
 	hcp->desc.pnext = hd->dma;
 }
 
-static struct Scsi_Host * __init sgiwd93_setup_scsi(
-	struct scsi_host_template *SGIblows, int unit, int irq,
-	struct hpc3_scsiregs *hregs, unsigned char *wdregs)
+static int sgiwd93_bus_reset(struct scsi_cmnd *cmd)
+{
+	/* FIXME perform bus-specific reset */
+
+	/* FIXME 2: kill this function, and let midlayer fallback
+	   to the same result, calling wd33c93_host_reset() */
+
+	spin_lock_irq(cmd->device->host->host_lock);
+	wd33c93_host_reset(cmd);
+	spin_unlock_irq(cmd->device->host->host_lock);
+
+	return SUCCESS;
+}
+
+/*
+ * Kludge alert - the SCSI code calls the abort and reset method with int
+ * arguments not with pointers.  So this is going to blow up beautyfully
+ * on 64-bit systems with memory outside the compat address spaces.
+ */
+static struct scsi_host_template sgiwd93_template = {
+	.module			= THIS_MODULE,
+	.proc_name		= "SGIWD93",
+	.name			= "SGI WD93",
+	.queuecommand		= wd33c93_queuecommand,
+	.eh_abort_handler	= wd33c93_abort,
+	.eh_bus_reset_handler	= sgiwd93_bus_reset,
+	.eh_host_reset_handler	= wd33c93_host_reset,
+	.can_queue		= 16,
+	.this_id		= 7,
+	.sg_tablesize		= SG_ALL,
+	.cmd_per_lun		= 8,
+	.use_clustering		= DISABLE_CLUSTERING,
+};
+
+static int __init sgiwd93_probe(struct platform_device *pdev)
 {
+	struct sgiwd93_platform_data *pd = pdev->dev.platform_data;
+	unsigned char *wdregs = pd->wdregs;
+	struct hpc3_scsiregs *hregs = pd->hregs;
 	struct ip22_hostdata *hdata;
 	struct Scsi_Host *host;
 	wd33c93_regs regs;
-
-	host = scsi_register(SGIblows, sizeof(struct ip22_hostdata));
-	if (!host)
-		return NULL;
+	unsigned int unit = pd->unit;
+	unsigned int irq = pd->irq;
+	int err;
+
+	host = scsi_host_alloc(&sgiwd93_template, sizeof(struct ip22_hostdata));
+	if (!host) {
+		err = -ENOMEM;
+		goto out;
+	}
 
 	host->base = (unsigned long) hregs;
 	host->irq = irq;
 
-	hdata = HDATA(host);
-	hdata->hd.cpu = dma_alloc_coherent(NULL, PAGE_SIZE, &hdata->hd.dma,
-	                                   GFP_KERNEL);
+	hdata = host_to_hostdata(host);
+	hdata->hd.cpu = dma_alloc_coherent(&pdev->dev, PAGE_SIZE,
+	                                   &hdata->hd.dma, GFP_KERNEL);
 	if (!hdata->hd.cpu) {
 		printk(KERN_WARNING "sgiwd93: Could not allocate memory for "
 		       "host %d buffer.\n", unit);
-		goto out_unregister;
+		err = -ENOMEM;
+		goto out_put;
 	}
+
 	init_hpc_chain(&hdata->hd);
 
 	regs.SASR = wdregs + 3;
@@ -249,95 +253,67 @@ static struct Scsi_Host * __init sgiwd93_setup_scsi(
 	if (hdata->wh.no_sync == 0xff)
 		hdata->wh.no_sync = 0;
 
-	if (request_irq(irq, sgiwd93_intr, 0, "SGI WD93", (void *) host)) {
+	err = request_irq(irq, sgiwd93_intr, 0, "SGI WD93", host);
+	if (err) {
 		printk(KERN_WARNING "sgiwd93: Could not register irq %d "
 		       "for host %d.\n", irq, unit);
 		goto out_free;
 	}
-	return host;
 
-out_free:
-	dma_free_coherent(NULL, PAGE_SIZE, hdata->hd.cpu, hdata->hd.dma);
-	wd33c93_release();
+	platform_set_drvdata(pdev, host);
 
-out_unregister:
-	scsi_unregister(host);
+	err = scsi_add_host(host, NULL);
+	if (err)
+		goto out_irq;
 
-	return NULL;
-}
-
-static int __init sgiwd93_detect(struct scsi_host_template *SGIblows)
-{
-	int found = 0;
-
-	SGIblows->proc_name = "SGIWD93";
-	sgiwd93_host = sgiwd93_setup_scsi(SGIblows, 0, SGI_WD93_0_IRQ,
-	                                  &hpc3c0->scsi_chan0,
-	                                  (unsigned char *)hpc3c0->scsi0_ext);
-	if (sgiwd93_host)
-		found++;
-
-	/* Set up second controller on the Indigo2 */
-	if (ip22_is_fullhouse()) {
-		sgiwd93_host1 = sgiwd93_setup_scsi(SGIblows, 1, SGI_WD93_1_IRQ,
-		                          &hpc3c0->scsi_chan1,
-		                          (unsigned char *)hpc3c0->scsi1_ext);
-		if (sgiwd93_host1)
-			found++;
-	}
-
-	return found;
-}
+	scsi_scan_host(host);
 
-static int sgiwd93_release(struct Scsi_Host *instance)
-{
-	struct ip22_hostdata *hdata = HDATA(instance);
-	int irq = 0;
-
-	if (sgiwd93_host && sgiwd93_host == instance)
-		irq = SGI_WD93_0_IRQ;
-	else if (sgiwd93_host1 && sgiwd93_host1 == instance)
-		irq = SGI_WD93_1_IRQ;
+	return 0;
 
-	free_irq(irq, sgiwd93_intr);
+out_irq:
+	free_irq(irq, host);
+out_free:
 	dma_free_coherent(NULL, PAGE_SIZE, hdata->hd.cpu, hdata->hd.dma);
-	wd33c93_release();
+out_put:
+	scsi_host_put(host);
+out:
 
-	return 1;
+	return err;
 }
 
-static int sgiwd93_bus_reset(struct scsi_cmnd *cmd)
+static void __exit sgiwd93_remove(struct platform_device *pdev)
 {
-	/* FIXME perform bus-specific reset */
+	struct Scsi_Host *host = platform_get_drvdata(pdev);
+	struct ip22_hostdata *hdata = (struct ip22_hostdata *) host->hostdata;
+	struct sgiwd93_platform_data *pd = pdev->dev.platform_data;
+
+	scsi_remove_host(host);
+	free_irq(pd->irq, host);
+	dma_free_coherent(&pdev->dev, PAGE_SIZE, hdata->hd.cpu, hdata->hd.dma);
+	scsi_host_put(host);
+}
 
-	/* FIXME 2: kill this function, and let midlayer fallback
-	   to the same result, calling wd33c93_host_reset() */
+static struct platform_driver sgiwd93_driver = {
+	.probe  = sgiwd93_probe,
+	.remove = __devexit_p(sgiwd93_remove),
+	.driver = {
+		.name   = "sgiwd93"
+	}
+};
 
-	spin_lock_irq(cmd->device->host->host_lock);
-	wd33c93_host_reset(cmd);
-	spin_unlock_irq(cmd->device->host->host_lock);
+static int __init sgiwd93_module_init(void)
+{
+	return platform_driver_register(&sgiwd93_driver);
+}
 
-	return SUCCESS;
+static void __exit sgiwd93_module_exit(void)
+{
+	return platform_driver_unregister(&sgiwd93_driver);
 }
 
-/*
- * Kludge alert - the SCSI code calls the abort and reset method with int
- * arguments not with pointers.  So this is going to blow up beautyfully
- * on 64-bit systems with memory outside the compat address spaces.
- */
-static struct scsi_host_template driver_template = {
-	.proc_name		= "SGIWD93",
-	.name			= "SGI WD93",
-	.detect			= sgiwd93_detect,
-	.release		= sgiwd93_release,
-	.queuecommand		= wd33c93_queuecommand,
-	.eh_abort_handler	= wd33c93_abort,
-	.eh_bus_reset_handler	= sgiwd93_bus_reset,
-	.eh_host_reset_handler	= wd33c93_host_reset,
-	.can_queue		= 16,
-	.this_id		= 7,
-	.sg_tablesize		= SG_ALL,
-	.cmd_per_lun		= 8,
-	.use_clustering		= DISABLE_CLUSTERING,
-};
-#include "scsi_module.c"
+module_init(sgiwd93_module_init);
+module_exit(sgiwd93_module_exit);
+
+MODULE_DESCRIPTION("SGI WD33C93 driver");
+MODULE_AUTHOR("Ralf Baechle <ralf@linux-mips.org>");
+MODULE_LICENSE("GPL");

commit 8f3334edae93f8b664417f4140d4d9dc9a003fe4
Author: peter fuerst <post@pfrst.de>
Date:   Mon Feb 12 15:27:17 2007 +0100

    [SCSI] sgiwd93: interfacing to wd33c93
    
    1) sgiwd93 used to switch off asynchronous mode on the wd33c93, discarding
       any "nosync"-requests from the commandline.
       But we need to allow "nosync"-requests for selected devices, for example
       the Pioneer DVD305S.
       (For the curious: this device accepts the SDTR from wd33c93 and success-
       fully sends inquiry data in sync mode, but after the data phase in the
       inquiry command does an unexpected disconnect, seemingly sending no
       "status" or "command complete". Forcing async transfers makes it work
       together flawlessly with the wd33c93. Of course, preferable would be, to
       implement wd33c93's "resume command" stuff, but that probably will not
       come soon.)
    
    2) Maximize benefit from the preceding Fast SCSI patch for wd33c93 by passing
       the higher input-clock frequency explicitely. To be applied after the
       mentioned wd33c93 patch.
    
    Signed-off-by: peter fuerst <post@pfrst.de>
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>

diff --git a/drivers/scsi/sgiwd93.c b/drivers/scsi/sgiwd93.c
index e81f97a35bc8..a15752b37990 100644
--- a/drivers/scsi/sgiwd93.c
+++ b/drivers/scsi/sgiwd93.c
@@ -244,9 +244,10 @@ static struct Scsi_Host * __init sgiwd93_setup_scsi(
 	regs.SASR = wdregs + 3;
 	regs.SCMD = wdregs + 7;
 
-	wd33c93_init(host, regs, dma_setup, dma_stop, WD33C93_FS_16_20);
+	wd33c93_init(host, regs, dma_setup, dma_stop, WD33C93_FS_MHZ(20));
 
-	hdata->wh.no_sync = 0;
+	if (hdata->wh.no_sync == 0xff)
+		hdata->wh.no_sync = 0;
 
 	if (request_irq(irq, sgiwd93_intr, 0, "SGI WD93", (void *) host)) {
 		printk(KERN_WARNING "sgiwd93: Could not register irq %d "

commit 7d12e780e003f93433d49ce78cfedf4b4c52adc5
Author: David Howells <dhowells@redhat.com>
Date:   Thu Oct 5 14:55:46 2006 +0100

    IRQ: Maintain regs pointer globally rather than passing to IRQ handlers
    
    Maintain a per-CPU global "struct pt_regs *" variable which can be used instead
    of passing regs around manually through all ~1800 interrupt handlers in the
    Linux kernel.
    
    The regs pointer is used in few places, but it potentially costs both stack
    space and code to pass it around.  On the FRV arch, removing the regs parameter
    from all the genirq function results in a 20% speed up of the IRQ exit path
    (ie: from leaving timer_interrupt() to leaving do_IRQ()).
    
    Where appropriate, an arch may override the generic storage facility and do
    something different with the variable.  On FRV, for instance, the address is
    maintained in GR28 at all times inside the kernel as part of general exception
    handling.
    
    Having looked over the code, it appears that the parameter may be handed down
    through up to twenty or so layers of functions.  Consider a USB character
    device attached to a USB hub, attached to a USB controller that posts its
    interrupts through a cascaded auxiliary interrupt controller.  A character
    device driver may want to pass regs to the sysrq handler through the input
    layer which adds another few layers of parameter passing.
    
    I've build this code with allyesconfig for x86_64 and i386.  I've runtested the
    main part of the code on FRV and i386, though I can't test most of the drivers.
    I've also done partial conversion for powerpc and MIPS - these at least compile
    with minimal configurations.
    
    This will affect all archs.  Mostly the changes should be relatively easy.
    Take do_IRQ(), store the regs pointer at the beginning, saving the old one:
    
            struct pt_regs *old_regs = set_irq_regs(regs);
    
    And put the old one back at the end:
    
            set_irq_regs(old_regs);
    
    Don't pass regs through to generic_handle_irq() or __do_IRQ().
    
    In timer_interrupt(), this sort of change will be necessary:
    
            -       update_process_times(user_mode(regs));
            -       profile_tick(CPU_PROFILING, regs);
            +       update_process_times(user_mode(get_irq_regs()));
            +       profile_tick(CPU_PROFILING);
    
    I'd like to move update_process_times()'s use of get_irq_regs() into itself,
    except that i386, alone of the archs, uses something other than user_mode().
    
    Some notes on the interrupt handling in the drivers:
    
     (*) input_dev() is now gone entirely.  The regs pointer is no longer stored in
         the input_dev struct.
    
     (*) finish_unlinks() in drivers/usb/host/ohci-q.c needs checking.  It does
         something different depending on whether it's been supplied with a regs
         pointer or not.
    
     (*) Various IRQ handler function pointers have been moved to type
         irq_handler_t.
    
    Signed-Off-By: David Howells <dhowells@redhat.com>
    (cherry picked from 1b16e7ac850969f38b375e511e3fa2f474a33867 commit)

diff --git a/drivers/scsi/sgiwd93.c b/drivers/scsi/sgiwd93.c
index 4f1db6f2aae8..e81f97a35bc8 100644
--- a/drivers/scsi/sgiwd93.c
+++ b/drivers/scsi/sgiwd93.c
@@ -84,7 +84,7 @@ static inline unsigned long read_wd33c93_count(const wd33c93_regs regs)
 	return value;
 }
 
-static irqreturn_t sgiwd93_intr(int irq, void *dev_id, struct pt_regs *regs)
+static irqreturn_t sgiwd93_intr(int irq, void *dev_id)
 {
 	struct Scsi_Host * host = (struct Scsi_Host *) dev_id;
 	unsigned long flags;

commit 65396410af63db90d6428c678ff84aa652c3c1ec
Author: Henrik Kretzschmar <henne@nachtwindheim.de>
Date:   Tue Sep 12 23:49:33 2006 +0200

    [SCSI] wd33c93: Scsi_Cmnd convertion
    
    Changes obsolete typedef'd Scsi_Cmnd to struct scsi_cmnd.
    
    Signed-off-by: Henrik Kretzschmar <henne@nachtwindheim.de>
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>

diff --git a/drivers/scsi/sgiwd93.c b/drivers/scsi/sgiwd93.c
index 7cd366fcc571..4f1db6f2aae8 100644
--- a/drivers/scsi/sgiwd93.c
+++ b/drivers/scsi/sgiwd93.c
@@ -97,7 +97,7 @@ static irqreturn_t sgiwd93_intr(int irq, void *dev_id, struct pt_regs *regs)
 }
 
 static inline
-void fill_hpc_entries(struct hpc_chunk *hcp, Scsi_Cmnd *cmd, int datainp)
+void fill_hpc_entries(struct hpc_chunk *hcp, struct scsi_cmnd *cmd, int datainp)
 {
 	unsigned long len = cmd->SCp.this_residual;
 	void *addr = cmd->SCp.ptr;
@@ -129,7 +129,7 @@ void fill_hpc_entries(struct hpc_chunk *hcp, Scsi_Cmnd *cmd, int datainp)
 	hcp->desc.cntinfo = HPCDMA_EOX;
 }
 
-static int dma_setup(Scsi_Cmnd *cmd, int datainp)
+static int dma_setup(struct scsi_cmnd *cmd, int datainp)
 {
 	struct ip22_hostdata *hdata = HDATA(cmd->device->host);
 	struct hpc3_scsiregs *hregs =
@@ -163,7 +163,7 @@ static int dma_setup(Scsi_Cmnd *cmd, int datainp)
 	return 0;
 }
 
-static void dma_stop(struct Scsi_Host *instance, Scsi_Cmnd *SCpnt,
+static void dma_stop(struct Scsi_Host *instance, struct scsi_cmnd *SCpnt,
 		     int status)
 {
 	struct ip22_hostdata *hdata = HDATA(instance);
@@ -305,7 +305,7 @@ static int sgiwd93_release(struct Scsi_Host *instance)
 	return 1;
 }
 
-static int sgiwd93_bus_reset(Scsi_Cmnd *cmd)
+static int sgiwd93_bus_reset(struct scsi_cmnd *cmd)
 {
 	/* FIXME perform bus-specific reset */
 

commit a0b6b6e5308d6ef70febfc3cfd5488717809b3e4
Author: Ralf Baechle <ralf@linux-mips.org>
Date:   Thu Mar 9 14:35:13 2006 +0000

    [SCSI] Make sgiwd93_detect and sgiwd93_detect static.
    
    Nothing outside sgiwd93.c references them.
    
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>

diff --git a/drivers/scsi/sgiwd93.c b/drivers/scsi/sgiwd93.c
index bf2ceb54354c..7cd366fcc571 100644
--- a/drivers/scsi/sgiwd93.c
+++ b/drivers/scsi/sgiwd93.c
@@ -265,7 +265,7 @@ static struct Scsi_Host * __init sgiwd93_setup_scsi(
 	return NULL;
 }
 
-int __init sgiwd93_detect(struct scsi_host_template *SGIblows)
+static int __init sgiwd93_detect(struct scsi_host_template *SGIblows)
 {
 	int found = 0;
 
@@ -288,7 +288,7 @@ int __init sgiwd93_detect(struct scsi_host_template *SGIblows)
 	return found;
 }
 
-int sgiwd93_release(struct Scsi_Host *instance)
+static int sgiwd93_release(struct Scsi_Host *instance)
 {
 	struct ip22_hostdata *hdata = HDATA(instance);
 	int irq = 0;

commit 8a87a0b6313109d2fea87b1271d497c954ce2ca8
Merge: e6a04466ba96 3b44f137b9a8
Author: James Bottomley <jejb@titanic.(none)>
Date:   Thu Nov 10 08:29:07 2005 -0600

    Merge by hand (whitespace conflicts in libata.h)
    
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>

commit d0be4a7d29ad0bd3ce2209dd9e46d410b632db59
Author: Christoph Hellwig <hch@lst.de>
Date:   Mon Oct 31 18:31:40 2005 +0100

    [SCSI] remove Scsi_Host_Template typedef
    
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>

diff --git a/drivers/scsi/sgiwd93.c b/drivers/scsi/sgiwd93.c
index 09fd203e4b86..0a0d8a908c74 100644
--- a/drivers/scsi/sgiwd93.c
+++ b/drivers/scsi/sgiwd93.c
@@ -218,7 +218,7 @@ static inline void init_hpc_chain(struct hpc_data *hd)
 }
 
 static struct Scsi_Host * __init sgiwd93_setup_scsi(
-	Scsi_Host_Template *SGIblows, int unit, int irq,
+	struct scsi_host_template *SGIblows, int unit, int irq,
 	struct hpc3_scsiregs *hregs, unsigned char *wdregs)
 {
 	struct ip22_hostdata *hdata;
@@ -266,7 +266,7 @@ static struct Scsi_Host * __init sgiwd93_setup_scsi(
 	return NULL;
 }
 
-int __init sgiwd93_detect(Scsi_Host_Template *SGIblows)
+int __init sgiwd93_detect(struct scsi_host_template *SGIblows)
 {
 	int found = 0;
 
@@ -325,7 +325,7 @@ static int sgiwd93_bus_reset(Scsi_Cmnd *cmd)
  * arguments not with pointers.  So this is going to blow up beautyfully
  * on 64-bit systems with memory outside the compat address spaces.
  */
-static Scsi_Host_Template driver_template = {
+static struct scsi_host_template driver_template = {
 	.proc_name		= "SGIWD93",
 	.name			= "SGI WD93",
 	.detect			= sgiwd93_detect,

commit 733482e445ca4450cf41381b1c95e2b8c7145114
Author: Olaf Hering <olh@suse.de>
Date:   Tue Nov 8 21:34:55 2005 -0800

    [PATCH] changing CONFIG_LOCALVERSION rebuilds too much, for no good reason
    
    This patch removes almost all inclusions of linux/version.h.  The 3
    #defines are unused in most of the touched files.
    
    A few drivers use the simple KERNEL_VERSION(a,b,c) macro, which is
    unfortunatly in linux/version.h.
    
    There are also lots of #ifdef for long obsolete kernels, this was not
    touched.  In a few places, the linux/version.h include was move to where
    the LINUX_VERSION_CODE was used.
    
    quilt vi `find * -type f -name "*.[ch]"|xargs grep -El '(UTS_RELEASE|LINUX_VERSION_CODE|KERNEL_VERSION|linux/version.h)'|grep -Ev '(/(boot|coda|drm)/|~$)'`
    
    search pattern:
    /UTS_RELEASE\|LINUX_VERSION_CODE\|KERNEL_VERSION\|linux\/\(utsname\|version\).h
    
    Signed-off-by: Olaf Hering <olh@suse.de>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/drivers/scsi/sgiwd93.c b/drivers/scsi/sgiwd93.c
index 09fd203e4b86..f37147f8f7bf 100644
--- a/drivers/scsi/sgiwd93.c
+++ b/drivers/scsi/sgiwd93.c
@@ -15,7 +15,6 @@
 #include <linux/types.h>
 #include <linux/mm.h>
 #include <linux/blkdev.h>
-#include <linux/version.h>
 #include <linux/delay.h>
 #include <linux/dma-mapping.h>
 #include <linux/spinlock.h>

commit d25cf1ced9d446dcd3fd399e15b518fea936f3ed
Author: Ralf Baechle <ralf@linux-mips.org>
Date:   Thu Oct 20 19:04:34 2005 +0100

    [SCSI] sgiwd93: small fixes
    
    Move the remaining bits of sgiwd93.h into sgiwd93.c; replace the use of
    CMD_PER_LUN and CAN_QUEUE by raw numbers.
    
    Signed-off-by: Thiemo Seufer <ths@networkno.de>
    Signed-off-by: Ralf Baechle <ralf@linux-mips.org>
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>

diff --git a/drivers/scsi/sgiwd93.c b/drivers/scsi/sgiwd93.c
index a5ba2c692752..09fd203e4b86 100644
--- a/drivers/scsi/sgiwd93.c
+++ b/drivers/scsi/sgiwd93.c
@@ -33,7 +33,6 @@
 #include "scsi.h"
 #include <scsi/scsi_host.h>
 #include "wd33c93.h"
-#include "sgiwd93.h"
 
 #include <linux/stat.h>
 
@@ -335,10 +334,10 @@ static Scsi_Host_Template driver_template = {
 	.eh_abort_handler	= wd33c93_abort,
 	.eh_bus_reset_handler	= sgiwd93_bus_reset,
 	.eh_host_reset_handler	= wd33c93_host_reset,
-	.can_queue		= CAN_QUEUE,
+	.can_queue		= 16,
 	.this_id		= 7,
 	.sg_tablesize		= SG_ALL,
-	.cmd_per_lun		= CMD_PER_LUN,
+	.cmd_per_lun		= 8,
 	.use_clustering		= DISABLE_CLUSTERING,
 };
 #include "scsi_module.c"

commit df0ae2497ddefd72a87f3a3b34ff32455d7d4ae0
Author: Jeff Garzik <jgarzik@pobox.com>
Date:   Sat May 28 07:57:14 2005 -0400

    [SCSI] allow sleeping in ->eh_host_reset_handler()
    
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>

diff --git a/drivers/scsi/sgiwd93.c b/drivers/scsi/sgiwd93.c
index ed66828705e1..a5ba2c692752 100644
--- a/drivers/scsi/sgiwd93.c
+++ b/drivers/scsi/sgiwd93.c
@@ -311,6 +311,9 @@ static int sgiwd93_bus_reset(Scsi_Cmnd *cmd)
 {
 	/* FIXME perform bus-specific reset */
 
+	/* FIXME 2: kill this function, and let midlayer fallback
+	   to the same result, calling wd33c93_host_reset() */
+
 	spin_lock_irq(cmd->device->host->host_lock);
 	wd33c93_host_reset(cmd);
 	spin_unlock_irq(cmd->device->host->host_lock);

commit 68b3aa7c9805aee9005a8ca53c5e99177961fbb9
Author: Jeff Garzik <jgarzik@pobox.com>
Date:   Sat May 28 07:56:31 2005 -0400

    [SCSI] allow sleeping in ->eh_bus_reset_handler()
    
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>

diff --git a/drivers/scsi/sgiwd93.c b/drivers/scsi/sgiwd93.c
index 270f2aa88faa..ed66828705e1 100644
--- a/drivers/scsi/sgiwd93.c
+++ b/drivers/scsi/sgiwd93.c
@@ -310,7 +310,11 @@ int sgiwd93_release(struct Scsi_Host *instance)
 static int sgiwd93_bus_reset(Scsi_Cmnd *cmd)
 {
 	/* FIXME perform bus-specific reset */
+
+	spin_lock_irq(cmd->device->host->host_lock);
 	wd33c93_host_reset(cmd);
+	spin_unlock_irq(cmd->device->host->host_lock);
+
 	return SUCCESS;
 }
 

commit 1da177e4c3f41524e886b7f1b8a0c1fc7321cac2
Author: Linus Torvalds <torvalds@ppc970.osdl.org>
Date:   Sat Apr 16 15:20:36 2005 -0700

    Linux-2.6.12-rc2
    
    Initial git repository build. I'm not bothering with the full history,
    even though we have it. We can create a separate "historical" git
    archive of that later if we want to, and in the meantime it's about
    3.2GB when imported into git - space that would just make the early
    git days unnecessarily complicated, when we don't have a lot of good
    infrastructure for it.
    
    Let it rip!

diff --git a/drivers/scsi/sgiwd93.c b/drivers/scsi/sgiwd93.c
new file mode 100644
index 000000000000..270f2aa88faa
--- /dev/null
+++ b/drivers/scsi/sgiwd93.c
@@ -0,0 +1,337 @@
+/*
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
+ *
+ * Copyright (C) 1996 David S. Miller (dm@engr.sgi.com)
+ * Copyright (C) 1999 Andrew R. Baker (andrewb@uab.edu)
+ * Copyright (C) 2001 Florian Lohoff (flo@rfc822.org)
+ * Copyright (C) 2003 Ralf Baechle (ralf@linux-mips.org)
+ * 
+ * (In all truth, Jed Schimmel wrote all this code.)
+ */
+#include <linux/init.h>
+#include <linux/interrupt.h>
+#include <linux/types.h>
+#include <linux/mm.h>
+#include <linux/blkdev.h>
+#include <linux/version.h>
+#include <linux/delay.h>
+#include <linux/dma-mapping.h>
+#include <linux/spinlock.h>
+
+#include <asm/page.h>
+#include <asm/pgtable.h>
+#include <asm/sgialib.h>
+#include <asm/sgi/sgi.h>
+#include <asm/sgi/mc.h>
+#include <asm/sgi/hpc3.h>
+#include <asm/sgi/ip22.h>
+#include <asm/irq.h>
+#include <asm/io.h>
+
+#include "scsi.h"
+#include <scsi/scsi_host.h>
+#include "wd33c93.h"
+#include "sgiwd93.h"
+
+#include <linux/stat.h>
+
+#if 0
+#define DPRINTK(args...)	printk(args)
+#else
+#define DPRINTK(args...)
+#endif
+
+#define HDATA(ptr) ((struct ip22_hostdata *)((ptr)->hostdata))
+
+struct ip22_hostdata {
+	struct WD33C93_hostdata wh;
+	struct hpc_data {
+		dma_addr_t      dma;
+		void            * cpu;
+	} hd;
+};
+
+struct hpc_chunk {
+	struct hpc_dma_desc desc;
+	u32 _padding;	/* align to quadword boundary */
+};
+
+struct Scsi_Host *sgiwd93_host;
+struct Scsi_Host *sgiwd93_host1;
+
+/* Wuff wuff, wuff, wd33c93.c, wuff wuff, object oriented, bow wow. */
+static inline void write_wd33c93_count(const wd33c93_regs regs,
+                                      unsigned long value)
+{
+	*regs.SASR = WD_TRANSFER_COUNT_MSB;
+	mb();
+	*regs.SCMD = ((value >> 16) & 0xff);
+	*regs.SCMD = ((value >>  8) & 0xff);
+	*regs.SCMD = ((value >>  0) & 0xff);
+	mb();
+}
+
+static inline unsigned long read_wd33c93_count(const wd33c93_regs regs)
+{
+	unsigned long value;
+
+	*regs.SASR = WD_TRANSFER_COUNT_MSB;
+	mb();
+	value =  ((*regs.SCMD & 0xff) << 16);
+	value |= ((*regs.SCMD & 0xff) <<  8);
+	value |= ((*regs.SCMD & 0xff) <<  0);
+	mb();
+	return value;
+}
+
+static irqreturn_t sgiwd93_intr(int irq, void *dev_id, struct pt_regs *regs)
+{
+	struct Scsi_Host * host = (struct Scsi_Host *) dev_id;
+	unsigned long flags;
+
+	spin_lock_irqsave(host->host_lock, flags);
+	wd33c93_intr(host);
+	spin_unlock_irqrestore(host->host_lock, flags);
+
+	return IRQ_HANDLED;
+}
+
+static inline
+void fill_hpc_entries(struct hpc_chunk *hcp, Scsi_Cmnd *cmd, int datainp)
+{
+	unsigned long len = cmd->SCp.this_residual;
+	void *addr = cmd->SCp.ptr;
+	dma_addr_t physaddr;
+	unsigned long count;
+
+	physaddr = dma_map_single(NULL, addr, len, cmd->sc_data_direction);
+	cmd->SCp.dma_handle = physaddr;
+
+	while (len) {
+		/*
+		 * even cntinfo could be up to 16383, without
+		 * magic only 8192 works correctly
+		 */
+		count = len > 8192 ? 8192 : len;
+		hcp->desc.pbuf = physaddr;
+		hcp->desc.cntinfo = count;
+		hcp++;
+		len -= count;
+		physaddr += count;
+	}
+
+	/*
+	 * To make sure, if we trip an HPC bug, that we transfer every single
+	 * byte, we tag on an extra zero length dma descriptor at the end of
+	 * the chain.
+	 */
+	hcp->desc.pbuf = 0;
+	hcp->desc.cntinfo = HPCDMA_EOX;
+}
+
+static int dma_setup(Scsi_Cmnd *cmd, int datainp)
+{
+	struct ip22_hostdata *hdata = HDATA(cmd->device->host);
+	struct hpc3_scsiregs *hregs =
+		(struct hpc3_scsiregs *) cmd->device->host->base;
+	struct hpc_chunk *hcp = (struct hpc_chunk *) hdata->hd.cpu;
+
+	DPRINTK("dma_setup: datainp<%d> hcp<%p> ", datainp, hcp);
+
+	hdata->wh.dma_dir = datainp;
+
+	/*
+	 * wd33c93 shouldn't pass us bogus dma_setups, but it does:-(  The
+	 * other wd33c93 drivers deal with it the same way (which isn't that
+	 * obvious).  IMHO a better fix would be, not to do these dma setups
+	 * in the first place.
+	 */
+	if (cmd->SCp.ptr == NULL || cmd->SCp.this_residual == 0)
+		return 1;
+
+	fill_hpc_entries(hcp, cmd, datainp);
+
+	DPRINTK(" HPCGO\n");
+
+	/* Start up the HPC. */
+	hregs->ndptr = hdata->hd.dma;
+	if (datainp)
+		hregs->ctrl = HPC3_SCTRL_ACTIVE;
+	else
+		hregs->ctrl = HPC3_SCTRL_ACTIVE | HPC3_SCTRL_DIR;
+
+	return 0;
+}
+
+static void dma_stop(struct Scsi_Host *instance, Scsi_Cmnd *SCpnt,
+		     int status)
+{
+	struct ip22_hostdata *hdata = HDATA(instance);
+	struct hpc3_scsiregs *hregs;
+
+	if (!SCpnt)
+		return;
+
+	hregs = (struct hpc3_scsiregs *) SCpnt->device->host->base;
+
+	DPRINTK("dma_stop: status<%d> ", status);
+
+	/* First stop the HPC and flush it's FIFO. */
+	if (hdata->wh.dma_dir) {
+		hregs->ctrl |= HPC3_SCTRL_FLUSH;
+		while (hregs->ctrl & HPC3_SCTRL_ACTIVE)
+			barrier();
+	}
+	hregs->ctrl = 0;
+	dma_unmap_single(NULL, SCpnt->SCp.dma_handle, SCpnt->SCp.this_residual,
+	                 SCpnt->sc_data_direction);
+
+	DPRINTK("\n");
+}
+
+void sgiwd93_reset(unsigned long base)
+{
+	struct hpc3_scsiregs *hregs = (struct hpc3_scsiregs *) base;
+
+	hregs->ctrl = HPC3_SCTRL_CRESET;
+	udelay(50);
+	hregs->ctrl = 0;
+}
+
+static inline void init_hpc_chain(struct hpc_data *hd)
+{
+	struct hpc_chunk *hcp = (struct hpc_chunk *) hd->cpu;
+	struct hpc_chunk *dma = (struct hpc_chunk *) hd->dma;
+	unsigned long start, end;
+
+	start = (unsigned long) hcp;
+	end = start + PAGE_SIZE;
+	while (start < end) {
+		hcp->desc.pnext = (u32) (dma + 1);
+		hcp->desc.cntinfo = HPCDMA_EOX;
+		hcp++; dma++;
+		start += sizeof(struct hpc_chunk);
+	};
+	hcp--;
+	hcp->desc.pnext = hd->dma;
+}
+
+static struct Scsi_Host * __init sgiwd93_setup_scsi(
+	Scsi_Host_Template *SGIblows, int unit, int irq,
+	struct hpc3_scsiregs *hregs, unsigned char *wdregs)
+{
+	struct ip22_hostdata *hdata;
+	struct Scsi_Host *host;
+	wd33c93_regs regs;
+
+	host = scsi_register(SGIblows, sizeof(struct ip22_hostdata));
+	if (!host)
+		return NULL;
+
+	host->base = (unsigned long) hregs;
+	host->irq = irq;
+
+	hdata = HDATA(host);
+	hdata->hd.cpu = dma_alloc_coherent(NULL, PAGE_SIZE, &hdata->hd.dma,
+	                                   GFP_KERNEL);
+	if (!hdata->hd.cpu) {
+		printk(KERN_WARNING "sgiwd93: Could not allocate memory for "
+		       "host %d buffer.\n", unit);
+		goto out_unregister;
+	}
+	init_hpc_chain(&hdata->hd);
+
+	regs.SASR = wdregs + 3;
+	regs.SCMD = wdregs + 7;
+
+	wd33c93_init(host, regs, dma_setup, dma_stop, WD33C93_FS_16_20);
+
+	hdata->wh.no_sync = 0;
+
+	if (request_irq(irq, sgiwd93_intr, 0, "SGI WD93", (void *) host)) {
+		printk(KERN_WARNING "sgiwd93: Could not register irq %d "
+		       "for host %d.\n", irq, unit);
+		goto out_free;
+	}
+	return host;
+
+out_free:
+	dma_free_coherent(NULL, PAGE_SIZE, hdata->hd.cpu, hdata->hd.dma);
+	wd33c93_release();
+
+out_unregister:
+	scsi_unregister(host);
+
+	return NULL;
+}
+
+int __init sgiwd93_detect(Scsi_Host_Template *SGIblows)
+{
+	int found = 0;
+
+	SGIblows->proc_name = "SGIWD93";
+	sgiwd93_host = sgiwd93_setup_scsi(SGIblows, 0, SGI_WD93_0_IRQ,
+	                                  &hpc3c0->scsi_chan0,
+	                                  (unsigned char *)hpc3c0->scsi0_ext);
+	if (sgiwd93_host)
+		found++;
+
+	/* Set up second controller on the Indigo2 */
+	if (ip22_is_fullhouse()) {
+		sgiwd93_host1 = sgiwd93_setup_scsi(SGIblows, 1, SGI_WD93_1_IRQ,
+		                          &hpc3c0->scsi_chan1,
+		                          (unsigned char *)hpc3c0->scsi1_ext);
+		if (sgiwd93_host1)
+			found++;
+	}
+
+	return found;
+}
+
+int sgiwd93_release(struct Scsi_Host *instance)
+{
+	struct ip22_hostdata *hdata = HDATA(instance);
+	int irq = 0;
+
+	if (sgiwd93_host && sgiwd93_host == instance)
+		irq = SGI_WD93_0_IRQ;
+	else if (sgiwd93_host1 && sgiwd93_host1 == instance)
+		irq = SGI_WD93_1_IRQ;
+
+	free_irq(irq, sgiwd93_intr);
+	dma_free_coherent(NULL, PAGE_SIZE, hdata->hd.cpu, hdata->hd.dma);
+	wd33c93_release();
+
+	return 1;
+}
+
+static int sgiwd93_bus_reset(Scsi_Cmnd *cmd)
+{
+	/* FIXME perform bus-specific reset */
+	wd33c93_host_reset(cmd);
+	return SUCCESS;
+}
+
+/*
+ * Kludge alert - the SCSI code calls the abort and reset method with int
+ * arguments not with pointers.  So this is going to blow up beautyfully
+ * on 64-bit systems with memory outside the compat address spaces.
+ */
+static Scsi_Host_Template driver_template = {
+	.proc_name		= "SGIWD93",
+	.name			= "SGI WD93",
+	.detect			= sgiwd93_detect,
+	.release		= sgiwd93_release,
+	.queuecommand		= wd33c93_queuecommand,
+	.eh_abort_handler	= wd33c93_abort,
+	.eh_bus_reset_handler	= sgiwd93_bus_reset,
+	.eh_host_reset_handler	= wd33c93_host_reset,
+	.can_queue		= CAN_QUEUE,
+	.this_id		= 7,
+	.sg_tablesize		= SG_ALL,
+	.cmd_per_lun		= CMD_PER_LUN,
+	.use_clustering		= DISABLE_CLUSTERING,
+};
+#include "scsi_module.c"
