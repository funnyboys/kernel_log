commit c5dfd106414f3e038fee5c6f0800fd55ed07b41d
Author: Don Brace <don.brace@microsemi.com>
Date:   Tue May 7 13:32:33 2019 -0500

    scsi: hpsa: correct device resets
    
    Correct a race condition that occurs between the reset handler and the
    completion handler. There are times when the wait_event condition is
    never met due to this race condition and the reset never completes.
    
    The reset_pending field is NULL initially.
    
      t  Reset Handler Thread     Completion Thread
      -- --------------------     -----------------
      t1                          if (c->reset_pending)
      t2 c->reset_pending = dev;     if (atomic_dev_and_test(counter))
      t3 atomic_inc(counter)             wait_up_all(event_sync_wait_queue)
      t4
      t5 wait_event(...counter == 0)
    
    Kernel.org Bugzilla:
               https://bugzilla.kernel.org/show_bug.cgi?id=1994350
               Bug 199435 - HPSA + P420i resetting logical Direct-Access
                            never complete
    
    Reviewed-by: Justin Lindley <justin.lindley@microsemi.com>
    Reviewed-by: David Carroll <david.carroll@microsemi.com>
    Reviewed-by: Scott Teel <scott.teel@microsemi.com>
    Signed-off-by: Don Brace <don.brace@microsemi.com>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/hpsa.h b/drivers/scsi/hpsa.h
index a013c16af5f1..f8c88fc7b80a 100644
--- a/drivers/scsi/hpsa.h
+++ b/drivers/scsi/hpsa.h
@@ -76,11 +76,12 @@ struct hpsa_scsi_dev_t {
 	unsigned char raid_level;	/* from inquiry page 0xC1 */
 	unsigned char volume_offline;	/* discovered via TUR or VPD */
 	u16 queue_depth;		/* max queue_depth for this device */
-	atomic_t reset_cmds_out;	/* Count of commands to-be affected */
+	atomic_t commands_outstanding;	/* track commands sent to device */
 	atomic_t ioaccel_cmds_out;	/* Only used for physical devices
 					 * counts commands sent to physical
 					 * device via "ioaccel" path.
 					 */
+	bool in_reset;
 	u32 ioaccel_handle;
 	u8 active_path_index;
 	u8 path_map;

commit 9e33f0d5788fe4aaa42b1abf6536d046c724a8cd
Author: Don Brace <don.brace@microsemi.com>
Date:   Tue May 7 13:32:26 2019 -0500

    scsi: hpsa: do-not-complete-cmds-for-deleted-devices
    
    Close up a rare multipath issue.
    
    Close up small hole where a command completes after a device has been
    removed from SML and before the device is re-added.
    
     - Mark device as removed in slave_destroy
    
     - Do not complete commands for deleted devices
    
    Reviewed-by: Justin Lindley <justin.lindley@microsemi.com>
    Reviewed-by: David Carroll <david.carroll@microsemi.com>
    Reviewed-by: Scott Teel <scott.teel@microsemi.com>
    Signed-off-by: Don Brace <don.brace@microsemi.com>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/hpsa.h b/drivers/scsi/hpsa.h
index 75210de71917..a013c16af5f1 100644
--- a/drivers/scsi/hpsa.h
+++ b/drivers/scsi/hpsa.h
@@ -65,6 +65,7 @@ struct hpsa_scsi_dev_t {
 	u8 physical_device : 1;
 	u8 expose_device;
 	u8 removed : 1;			/* device is marked for death */
+	u8 was_removed : 1;		/* device actually removed */
 #define RAID_CTLR_LUNID "\0\0\0\0\0\0\0\0"
 	unsigned char device_id[16];    /* from inquiry pg. 0x83 */
 	u64 sas_address;

commit 4770e68d162634b2134741d08c49185f858c90ee
Author: Don Brace <don.brace@microsemi.com>
Date:   Tue May 7 13:32:13 2019 -0500

    scsi: hpsa: check for tag collision
    
    Correct rare multipath issue where a device is deleted with an
    outstanding cmd which results in a tag collision.
    
    The cmd eventually completes. If a collision is detected wait until
    the command slot is cleared.
    
    Reviewed-by: Justin Lindley <justin.lindley@microsemi.com>
    Reviewed-by: David Carroll <david.carroll@microsemi.com>
    Reviewed-by: Scott Teel <scott.teel@microsemi.com>
    Signed-off-by: Don Brace <don.brace@microsemi.com>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/hpsa.h b/drivers/scsi/hpsa.h
index 7aa7378f70dd..75210de71917 100644
--- a/drivers/scsi/hpsa.h
+++ b/drivers/scsi/hpsa.h
@@ -174,6 +174,7 @@ struct ctlr_info {
 	struct CfgTable __iomem *cfgtable;
 	int	interrupts_enabled;
 	int 	max_commands;
+	int	last_collision_tag; /* tags are global */
 	atomic_t commands_outstanding;
 #	define PERF_MODE_INT	0
 #	define DOORBELL_INT	1

commit 0119208885b3faf2459de6d3fcc6d090580b906f
Author: Don Brace <don.brace@microsemi.com>
Date:   Tue May 7 13:32:07 2019 -0500

    scsi: hpsa: use local workqueues instead of system workqueues
    
    Avoid system stalls by switching to local workqueue.
    
    Reviewed-by: Justin Lindley <justin.lindley@microsemi.com>
    Reviewed-by: David Carroll <david.carroll@microsemi.com>
    Reviewed-by: Scott Teel <scott.teel@microsemi.com>
    Signed-off-by: Don Brace <don.brace@microsemi.com>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/hpsa.h b/drivers/scsi/hpsa.h
index 59e023696fff..7aa7378f70dd 100644
--- a/drivers/scsi/hpsa.h
+++ b/drivers/scsi/hpsa.h
@@ -300,6 +300,7 @@ struct ctlr_info {
 	int	needs_abort_tags_swizzled;
 	struct workqueue_struct *resubmit_wq;
 	struct workqueue_struct *rescan_ctlr_wq;
+	struct workqueue_struct *monitor_ctlr_wq;
 	atomic_t abort_cmds_available;
 	wait_queue_head_t event_sync_wait_queue;
 	struct mutex reset_mutex;

commit 01d0e789a14aa735ddcfddd468ef06d4f917e06d
Author: Don Brace <don.brace@microsemi.com>
Date:   Tue Jul 3 17:34:48 2018 -0500

    scsi: hpsa: correct enclosure sas address
    
    The original complaint was the lsscsi -t showed the same SAS address of the
    two enclosures (SEP devices). In fact the SAS address was being set to the
    Enclosure Logical Identifier (ELI).
    
    Reviewed-by: Scott Teel <scott.teel@microsemi.com>
    Reviewed-by: Kevin Barnett <kevin.barnett@microsemi.com>
    Signed-off-by: Don Brace <don.brace@microsemi.com>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/hpsa.h b/drivers/scsi/hpsa.h
index fb9f5e7f8209..59e023696fff 100644
--- a/drivers/scsi/hpsa.h
+++ b/drivers/scsi/hpsa.h
@@ -68,6 +68,7 @@ struct hpsa_scsi_dev_t {
 #define RAID_CTLR_LUNID "\0\0\0\0\0\0\0\0"
 	unsigned char device_id[16];    /* from inquiry pg. 0x83 */
 	u64 sas_address;
+	u64 eli;			/* from report diags. */
 	unsigned char vendor[8];        /* bytes 8-15 of inquiry data */
 	unsigned char model[16];        /* bytes 16-31 of inquiry data */
 	unsigned char rev;		/* byte 2 of inquiry data */

commit 8b834bff1b73dce46f4e9f5e84af6f73fed8b0ef
Author: Ming Lei <ming.lei@redhat.com>
Date:   Tue Mar 13 17:42:39 2018 +0800

    scsi: hpsa: fix selection of reply queue
    
    Since commit 84676c1f21e8 ("genirq/affinity: assign vectors to all
    possible CPUs") we could end up with an MSI-X vector that did not have
    any online CPUs mapped. This would lead to I/O hangs since there was no
    CPU to receive the completion.
    
    Retrieve IRQ affinity information using pci_irq_get_affinity() and use
    this mapping to choose a reply queue.
    
    [mkp: tweaked commit desc]
    
    Cc: Hannes Reinecke <hare@suse.de>
    Cc: "Martin K. Petersen" <martin.petersen@oracle.com>,
    Cc: James Bottomley <james.bottomley@hansenpartnership.com>,
    Cc: Christoph Hellwig <hch@lst.de>,
    Cc: Don Brace <don.brace@microsemi.com>
    Cc: Kashyap Desai <kashyap.desai@broadcom.com>
    Cc: Laurence Oberman <loberman@redhat.com>
    Cc: Meelis Roos <mroos@linux.ee>
    Cc: Artem Bityutskiy <artem.bityutskiy@intel.com>
    Cc: Mike Snitzer <snitzer@redhat.com>
    Fixes: 84676c1f21e8 ("genirq/affinity: assign vectors to all possible CPUs")
    Signed-off-by: Ming Lei <ming.lei@redhat.com>
    Tested-by: Laurence Oberman <loberman@redhat.com>
    Tested-by: Don Brace <don.brace@microsemi.com>
    Tested-by: Artem Bityutskiy <artem.bityutskiy@intel.com>
    Acked-by: Don Brace <don.brace@microsemi.com>
    Reviewed-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/hpsa.h b/drivers/scsi/hpsa.h
index 018f980a701c..fb9f5e7f8209 100644
--- a/drivers/scsi/hpsa.h
+++ b/drivers/scsi/hpsa.h
@@ -158,6 +158,7 @@ struct bmic_controller_parameters {
 #pragma pack()
 
 struct ctlr_info {
+	unsigned int *reply_map;
 	int	ctlr;
 	char	devname[8];
 	char    *product_name;

commit 135ae6edeb51979d0998daf1357f149a7d6ebb08
Author: Hannes Reinecke <hare@suse.de>
Date:   Tue Aug 15 08:58:04 2017 +0200

    scsi: hpsa: add support for legacy boards
    
    Add support for legacy boards, ensuring to enable the driver for
    those boards only when 'hpsa_allow_any' is set.
    The attribute 'legacy_board' is set to '1' if the device is
    a legacy board, and '0' otherwise.
    
    Signed-off-by: Hannes Reinecke <hare@suse.com>
    Acked-by: Don Brace <don.brace@microsemi.com>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/hpsa.h b/drivers/scsi/hpsa.h
index 1c49741bc639..018f980a701c 100644
--- a/drivers/scsi/hpsa.h
+++ b/drivers/scsi/hpsa.h
@@ -293,6 +293,7 @@ struct ctlr_info {
 	int	drv_req_rescan;
 	int	raid_offload_debug;
 	int     discovery_polling;
+	int     legacy_board;
 	struct  ReportLUNdata *lastlogicals;
 	int	needs_abort_tags_swizzled;
 	struct workqueue_struct *resubmit_wq;
@@ -447,6 +448,23 @@ static void SA5_intr_mask(struct ctlr_info *h, unsigned long val)
 	}
 }
 
+/*
+ *  Variant of the above; 0x04 turns interrupts off...
+ */
+static void SA5B_intr_mask(struct ctlr_info *h, unsigned long val)
+{
+	if (val) { /* Turn interrupts on */
+		h->interrupts_enabled = 1;
+		writel(0, h->vaddr + SA5_REPLY_INTR_MASK_OFFSET);
+		(void) readl(h->vaddr + SA5_REPLY_INTR_MASK_OFFSET);
+	} else { /* Turn them off */
+		h->interrupts_enabled = 0;
+		writel(SA5B_INTR_OFF,
+		       h->vaddr + SA5_REPLY_INTR_MASK_OFFSET);
+		(void) readl(h->vaddr + SA5_REPLY_INTR_MASK_OFFSET);
+	}
+}
+
 static void SA5_performant_intr_mask(struct ctlr_info *h, unsigned long val)
 {
 	if (val) { /* turn on interrupts */
@@ -549,6 +567,14 @@ static bool SA5_ioaccel_mode1_intr_pending(struct ctlr_info *h)
 		true : false;
 }
 
+/*
+ *      Returns true if an interrupt is pending..
+ */
+static bool SA5B_intr_pending(struct ctlr_info *h)
+{
+	return readl(h->vaddr + SA5_INTR_STATUS) & SA5B_INTR_PENDING;
+}
+
 #define IOACCEL_MODE1_REPLY_QUEUE_INDEX  0x1A0
 #define IOACCEL_MODE1_PRODUCER_INDEX     0x1B8
 #define IOACCEL_MODE1_CONSUMER_INDEX     0x1BC
@@ -581,38 +607,53 @@ static unsigned long SA5_ioaccel_mode1_completed(struct ctlr_info *h, u8 q)
 }
 
 static struct access_method SA5_access = {
-	.submit_command = SA5_submit_command,
-	.set_intr_mask = SA5_intr_mask,
-	.intr_pending = SA5_intr_pending,
-	.command_completed = SA5_completed,
+	.submit_command =	SA5_submit_command,
+	.set_intr_mask =	SA5_intr_mask,
+	.intr_pending =		SA5_intr_pending,
+	.command_completed =	SA5_completed,
+};
+
+/* Duplicate entry of the above to mark unsupported boards */
+static struct access_method SA5A_access = {
+	.submit_command =	SA5_submit_command,
+	.set_intr_mask =	SA5_intr_mask,
+	.intr_pending =		SA5_intr_pending,
+	.command_completed =	SA5_completed,
+};
+
+static struct access_method SA5B_access = {
+	.submit_command =	SA5_submit_command,
+	.set_intr_mask =	SA5B_intr_mask,
+	.intr_pending =		SA5B_intr_pending,
+	.command_completed =	SA5_completed,
 };
 
 static struct access_method SA5_ioaccel_mode1_access = {
-	.submit_command = SA5_submit_command,
-	.set_intr_mask = SA5_performant_intr_mask,
-	.intr_pending = SA5_ioaccel_mode1_intr_pending,
-	.command_completed = SA5_ioaccel_mode1_completed,
+	.submit_command =	SA5_submit_command,
+	.set_intr_mask =	SA5_performant_intr_mask,
+	.intr_pending =		SA5_ioaccel_mode1_intr_pending,
+	.command_completed =	SA5_ioaccel_mode1_completed,
 };
 
 static struct access_method SA5_ioaccel_mode2_access = {
-	.submit_command = SA5_submit_command_ioaccel2,
-	.set_intr_mask = SA5_performant_intr_mask,
-	.intr_pending = SA5_performant_intr_pending,
-	.command_completed = SA5_performant_completed,
+	.submit_command =	SA5_submit_command_ioaccel2,
+	.set_intr_mask =	SA5_performant_intr_mask,
+	.intr_pending =		SA5_performant_intr_pending,
+	.command_completed =	SA5_performant_completed,
 };
 
 static struct access_method SA5_performant_access = {
-	.submit_command = SA5_submit_command,
-	.set_intr_mask = SA5_performant_intr_mask,
-	.intr_pending = SA5_performant_intr_pending,
-	.command_completed = SA5_performant_completed,
+	.submit_command =	SA5_submit_command,
+	.set_intr_mask =	SA5_performant_intr_mask,
+	.intr_pending =		SA5_performant_intr_pending,
+	.command_completed =	SA5_performant_completed,
 };
 
 static struct access_method SA5_performant_access_no_read = {
-	.submit_command = SA5_submit_command_no_read,
-	.set_intr_mask = SA5_performant_intr_mask,
-	.intr_pending = SA5_performant_intr_pending,
-	.command_completed = SA5_performant_completed,
+	.submit_command =	SA5_submit_command_no_read,
+	.set_intr_mask =	SA5_performant_intr_mask,
+	.intr_pending =		SA5_performant_intr_pending,
+	.command_completed =	SA5_performant_completed,
 };
 
 struct board_type {

commit 08ec46f673369f65dfc6fc52fb7fadb39776e81f
Author: Don Brace <don.brace@microsemi.com>
Date:   Thu May 4 17:51:49 2017 -0500

    scsi: hpsa: remove abort handler
    
    - simplify the driver
    - there are a lot of quirky racy conditions not handled
    - causes more aborts/resets when the number of commands to be aborted is
      large, such as in multi-path fail-overs.
    - has been turned off in our internal driver since 8/31/2015
    
    Reviewed-by: Scott Benesh <scott.benesh@microsemi.com>
    Reviewed-by: Scott Teel <scott.teel@microsemi.com>
    Reviewed-by: Kevin Barnett <kevin.barnett@microsemi.com>
    Signed-off-by: Don Brace <don.brace@microsemi.com>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/hpsa.h b/drivers/scsi/hpsa.h
index c9c4927f5d0e..1c49741bc639 100644
--- a/drivers/scsi/hpsa.h
+++ b/drivers/scsi/hpsa.h
@@ -298,7 +298,6 @@ struct ctlr_info {
 	struct workqueue_struct *resubmit_wq;
 	struct workqueue_struct *rescan_ctlr_wq;
 	atomic_t abort_cmds_available;
-	wait_queue_head_t abort_cmd_wait_queue;
 	wait_queue_head_t event_sync_wait_queue;
 	struct mutex reset_mutex;
 	u8 reset_in_progress;

commit 3d38f00c4107cc007056db9f4ab14ecb17ed193f
Author: Scott Teel <scott.teel@microsemi.com>
Date:   Thu May 4 17:51:36 2017 -0500

    scsi: hpsa: separate monitor events from rescan worker
    
    create new worker thread to monitor controller events
     - both the rescan and event monitor workers can cause a rescan to occur
       however for multipath we have found that we need to respond faster
       than the normal scheduled rescan interval for path fail-overs.
     - getting controller events only involves reading a register, but the
       rescan worker can obtain an updated LUN list when there is a PTRAID
       device present.
     - move common code to a separate function.
    advantages:
     - detect controller events more frequently.
     - leave rescan thread interval at 30 seconds.
    
    Reviewed-by: Scott Benesh <scott.benesh@microsemi.com>
    Reviewed-by: Scott Teel <scott.teel@microsemi.com>
    Reviewed-by: Kevin Barnett <kevin.barnett@microsemi.com>
    Signed-off-by: Don Brace <don.brace@microsemi.com>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/hpsa.h b/drivers/scsi/hpsa.h
index 61dd54aa4d5d..c9c4927f5d0e 100644
--- a/drivers/scsi/hpsa.h
+++ b/drivers/scsi/hpsa.h
@@ -245,6 +245,7 @@ struct ctlr_info {
 	u32 __percpu *lockup_detected;
 	struct delayed_work monitor_ctlr_work;
 	struct delayed_work rescan_ctlr_work;
+	struct delayed_work event_monitor_work;
 	int remove_in_progress;
 	/* Address of h->q[x] is passed to intr handler to know which queue */
 	u8 q[MAX_REPLY_QUEUES];

commit 5086435e662c7b6ada6cb5f48a1215fc6f612153
Author: Don Brace <don.brace@microsemi.com>
Date:   Thu May 4 17:51:28 2017 -0500

    scsi: hpsa: correct queue depth for externals
    
    - queue depth assignment not in correct place, had no effect.
    
    Reviewed-by: Scott Benesh <scott.benesh@microsemi.com>
    Reviewed-by: Scott Teel <scott.teel@microsemi.com>
    Reviewed-by: Kevin Barnett <kevin.barnett@microsemi.com>
    Signed-off-by: Don Brace <don.brace@microsemi.com>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/hpsa.h b/drivers/scsi/hpsa.h
index 5352664a9f15..61dd54aa4d5d 100644
--- a/drivers/scsi/hpsa.h
+++ b/drivers/scsi/hpsa.h
@@ -57,6 +57,7 @@ struct hpsa_sas_phy {
 	bool added_to_port;
 };
 
+#define EXTERNAL_QD 7
 struct hpsa_scsi_dev_t {
 	unsigned int devtype;
 	int bus, target, lun;		/* as presented to the OS */

commit c59d04f30d4216af12930a4f5fdc35f490777171
Author: Don Brace <don.brace@microsemi.com>
Date:   Thu May 4 17:51:22 2017 -0500

    scsi: hpsa: cleanup reset handler
    
    - mark device state sooner.
    
    Reviewed-by: Scott Benesh <scott.benesh@microsemi.com>
    Reviewed-by: Scott Teel <scott.teel@microsemi.com>
    Reviewed-by: Kevin Barnett <kevin.barnett@microsemi.com>
    Signed-off-by: Don Brace <don.brace@microsemi.com>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/hpsa.h b/drivers/scsi/hpsa.h
index 6f04f2ad4125..5352664a9f15 100644
--- a/drivers/scsi/hpsa.h
+++ b/drivers/scsi/hpsa.h
@@ -301,6 +301,7 @@ struct ctlr_info {
 	struct mutex reset_mutex;
 	u8 reset_in_progress;
 	struct hpsa_sas_node *sas_host;
+	spinlock_t reset_lock;
 };
 
 struct offline_device_entry {

commit 87b9e6aa87d9411f1059aa245c0c79976bc557ac
Author: Don Brace <don.brace@microsemi.com>
Date:   Fri Mar 10 14:35:17 2017 -0600

    scsi: hpsa: limit outstanding rescans
    
    Avoid rescan storms. No need to queue another if one is pending.
    
    Reviewed-by: Scott Benesh <scott.benesh@microsemi.com>
    Reviewed-by: Scott Teel <scott.teel@microsemi.com>
    Reviewed-by: Tomas Henzl <thenzl@redhat.com>
    Signed-off-by: Don Brace <don.brace@microsemi.com>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/hpsa.h b/drivers/scsi/hpsa.h
index bf6cdc106654..6f04f2ad4125 100644
--- a/drivers/scsi/hpsa.h
+++ b/drivers/scsi/hpsa.h
@@ -201,6 +201,7 @@ struct ctlr_info {
 	dma_addr_t		errinfo_pool_dhandle;
 	unsigned long  		*cmd_pool_bits;
 	int			scan_finished;
+	u8			scan_waiting : 1;
 	spinlock_t		scan_lock;
 	wait_queue_head_t	scan_wait_queue;
 

commit 93380123fbb5357d3ea6935efc9226df3c59099d
Author: Kees Cook <keescook@chromium.org>
Date:   Fri Dec 16 17:04:49 2016 -0800

    scsi: hpsa: use designated initializers
    
    Prepare to mark sensitive kernel structures for randomization by making
    sure they're using designated initializers. These were identified during
    allyesconfig builds of x86, arm, and arm64, with most initializer fixes
    extracted from grsecurity.
    
    Signed-off-by: Kees Cook <keescook@chromium.org>
    Acked-by: Don Brace <don.brace@microsemi.com>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/hpsa.h b/drivers/scsi/hpsa.h
index 64e98295b707..bf6cdc106654 100644
--- a/drivers/scsi/hpsa.h
+++ b/drivers/scsi/hpsa.h
@@ -578,38 +578,38 @@ static unsigned long SA5_ioaccel_mode1_completed(struct ctlr_info *h, u8 q)
 }
 
 static struct access_method SA5_access = {
-	SA5_submit_command,
-	SA5_intr_mask,
-	SA5_intr_pending,
-	SA5_completed,
+	.submit_command = SA5_submit_command,
+	.set_intr_mask = SA5_intr_mask,
+	.intr_pending = SA5_intr_pending,
+	.command_completed = SA5_completed,
 };
 
 static struct access_method SA5_ioaccel_mode1_access = {
-	SA5_submit_command,
-	SA5_performant_intr_mask,
-	SA5_ioaccel_mode1_intr_pending,
-	SA5_ioaccel_mode1_completed,
+	.submit_command = SA5_submit_command,
+	.set_intr_mask = SA5_performant_intr_mask,
+	.intr_pending = SA5_ioaccel_mode1_intr_pending,
+	.command_completed = SA5_ioaccel_mode1_completed,
 };
 
 static struct access_method SA5_ioaccel_mode2_access = {
-	SA5_submit_command_ioaccel2,
-	SA5_performant_intr_mask,
-	SA5_performant_intr_pending,
-	SA5_performant_completed,
+	.submit_command = SA5_submit_command_ioaccel2,
+	.set_intr_mask = SA5_performant_intr_mask,
+	.intr_pending = SA5_performant_intr_pending,
+	.command_completed = SA5_performant_completed,
 };
 
 static struct access_method SA5_performant_access = {
-	SA5_submit_command,
-	SA5_performant_intr_mask,
-	SA5_performant_intr_pending,
-	SA5_performant_completed,
+	.submit_command = SA5_submit_command,
+	.set_intr_mask = SA5_performant_intr_mask,
+	.intr_pending = SA5_performant_intr_pending,
+	.command_completed = SA5_performant_completed,
 };
 
 static struct access_method SA5_performant_access_no_read = {
-	SA5_submit_command_no_read,
-	SA5_performant_intr_mask,
-	SA5_performant_intr_pending,
-	SA5_performant_completed,
+	.submit_command = SA5_submit_command_no_read,
+	.set_intr_mask = SA5_performant_intr_mask,
+	.intr_pending = SA5_performant_intr_pending,
+	.command_completed = SA5_performant_completed,
 };
 
 struct board_type {

commit a829a8445f09036404060f4d6489cb13433f4304
Merge: 84b607913442 f5b893c94715
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Wed Dec 14 10:49:33 2016 -0800

    Merge tag 'scsi-misc' of git://git.kernel.org/pub/scm/linux/kernel/git/jejb/scsi
    
    Pull SCSI updates from James Bottomley:
     "This update includes the usual round of major driver updates (ncr5380,
      lpfc, hisi_sas, megaraid_sas, ufs, ibmvscsis, mpt3sas).
    
      There's also an assortment of minor fixes, mostly in error legs or
      other not very user visible stuff. The major change is the
      pci_alloc_irq_vectors replacement for the old pci_msix_.. calls; this
      effectively makes IRQ mapping generic for the drivers and allows
      blk_mq to use the information"
    
    * tag 'scsi-misc' of git://git.kernel.org/pub/scm/linux/kernel/git/jejb/scsi: (256 commits)
      scsi: qla4xxx: switch to pci_alloc_irq_vectors
      scsi: hisi_sas: support deferred probe for v2 hw
      scsi: megaraid_sas: switch to pci_alloc_irq_vectors
      scsi: scsi_devinfo: remove synchronous ALUA for NETAPP devices
      scsi: be2iscsi: set errno on error path
      scsi: be2iscsi: set errno on error path
      scsi: hpsa: fallback to use legacy REPORT PHYS command
      scsi: scsi_dh_alua: Fix RCU annotations
      scsi: hpsa: use %phN for short hex dumps
      scsi: hisi_sas: fix free'ing in probe and remove
      scsi: isci: switch to pci_alloc_irq_vectors
      scsi: ipr: Fix runaway IRQs when falling back from MSI to LSI
      scsi: dpt_i2o: double free on error path
      scsi: cxlflash: Migrate scsi command pointer to AFU command
      scsi: cxlflash: Migrate IOARRIN specific routines to function pointers
      scsi: cxlflash: Cleanup queuecommand()
      scsi: cxlflash: Cleanup send_tmf()
      scsi: cxlflash: Remove AFU command lock
      scsi: cxlflash: Wait for active AFU commands to timeout upon tear down
      scsi: cxlflash: Remove private command pool
      ...

commit 7630b3a599e2c6d1c042945d32ff2debc855ad29
Author: Hannes Reinecke <hare@suse.de>
Date:   Thu Nov 17 12:15:56 2016 +0100

    scsi: hpsa: use bus '3' for legacy HBA devices
    
    Older controllers use SCSI target id '0' for the first internal disk. As
    the controllers are now placed on the same bus as the internal disks
    this leads to a clash with the SCSI target id of controller.  This patch
    checks the SCSI revision, and moves older controller to bus '3' to be
    compatible with older releases and avoid this problem.
    
    [mkp: fixed uninitialized variable]
    
    Fixes: 09371d623c9 ("hpsa: Change SAS transport devices to bus 0.")
    Cc: <stable@vger.kernel.org> # v4.5+
    Signed-off-by: Hannes Reinecke <hare@suse.com>
    Acked-by: Don Brace <don.brace@microsemi.com>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/hpsa.h b/drivers/scsi/hpsa.h
index 82cdfad874f3..9ea162de80dc 100644
--- a/drivers/scsi/hpsa.h
+++ b/drivers/scsi/hpsa.h
@@ -69,6 +69,7 @@ struct hpsa_scsi_dev_t {
 	u64 sas_address;
 	unsigned char vendor[8];        /* bytes 8-15 of inquiry data */
 	unsigned char model[16];        /* bytes 16-31 of inquiry data */
+	unsigned char rev;		/* byte 2 of inquiry data */
 	unsigned char raid_level;	/* from inquiry page 0xC1 */
 	unsigned char volume_offline;	/* discovered via TUR or VPD */
 	u16 queue_depth;		/* max queue_depth for this device */
@@ -402,6 +403,7 @@ struct offline_device_entry {
 #define HPSA_RAID_VOLUME_BUS		1
 #define HPSA_EXTERNAL_RAID_VOLUME_BUS	2
 #define HPSA_HBA_BUS			0
+#define HPSA_LEGACY_HBA_BUS		3
 
 /*
 	Send the command to the hardware

commit bc2bb1543e62a5d0ae51ccdfde697dc97957f2a1
Author: Christoph Hellwig <hch@lst.de>
Date:   Wed Nov 9 10:42:22 2016 -0800

    scsi: hpsa: use pci_alloc_irq_vectors and automatic irq affinity
    
    This patch converts over hpsa to use the pci_alloc_irq_vectors including
    the PCI_IRQ_AFFINITY flag that automatically assigns spread out irq
    affinity to the I/O queues.
    
    It also cleans up the per-ctrl interrupt state due to the use of the
    pci_irq_vector and pci_free_irq_vectors helpers that don't need to know
    the exact irq type.  Additionally it changes a little oddity in the
    existing code that was using different array indixes into the per-vector
    arrays depending on whether a controller is using a single INTx or
    single MSI irq.
    
    [mkp: fixed typo]
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Acked-by: Don Brace <don.brace@microsemi.com>
    Tested-by: Don Brace <don.brace@microsemi.com>
    Reviewed-by: Hannes Reinecke <hare@suse.com>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/hpsa.h b/drivers/scsi/hpsa.h
index 82cdfad874f3..3faf6cff95ee 100644
--- a/drivers/scsi/hpsa.h
+++ b/drivers/scsi/hpsa.h
@@ -175,9 +175,7 @@ struct ctlr_info {
 #	define DOORBELL_INT	1
 #	define SIMPLE_MODE_INT	2
 #	define MEMQ_MODE_INT	3
-	unsigned int intr[MAX_REPLY_QUEUES];
-	unsigned int msix_vector;
-	unsigned int msi_vector;
+	unsigned int msix_vectors;
 	int intr_mode; /* either PERF_MODE_INT or SIMPLE_MODE_INT */
 	struct access_method access;
 
@@ -464,7 +462,7 @@ static unsigned long SA5_performant_completed(struct ctlr_info *h, u8 q)
 	unsigned long register_value = FIFO_EMPTY;
 
 	/* msi auto clears the interrupt pending bit. */
-	if (unlikely(!(h->msi_vector || h->msix_vector))) {
+	if (unlikely(!(h->pdev->msi_enabled || h->msix_vectors))) {
 		/* flush the controller write of the reply queue by reading
 		 * outbound doorbell status register.
 		 */

commit b32ece0ff70c30e59f16e9a8ffd05acc27298ba3
Author: Don Brace <don.brace@microsemi.com>
Date:   Tue Sep 20 15:42:30 2016 -0500

    scsi: hpsa: correct call to hpsa_do_reset
    
    calling fill_cmd() using a MACRO definition not handled in switch
    statement causes BUG() to be called.
    
    Signed-off-by: Don Brace <don.brace@microsemi.com>
    Reviewed-by: Scott Teel <scott.teel@microsemi.com>
    Reviewed-by: Kevin Barnett <kevin.barnett@microsemi.com>
    Reviewed-by: Tomas Henzl <thenzl@redhat.com>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/hpsa.h b/drivers/scsi/hpsa.h
index a1487e67f7a1..82cdfad874f3 100644
--- a/drivers/scsi/hpsa.h
+++ b/drivers/scsi/hpsa.h
@@ -312,7 +312,6 @@ struct offline_device_entry {
 #define HPSA_DEVICE_RESET_MSG 1
 #define HPSA_RESET_TYPE_CONTROLLER 0x00
 #define HPSA_RESET_TYPE_BUS 0x01
-#define HPSA_RESET_TYPE_TARGET 0x03
 #define HPSA_RESET_TYPE_LUN 0x04
 #define HPSA_PHYS_TARGET_RESET 0x99 /* not defined by cciss spec */
 #define HPSA_MSG_SEND_RETRY_LIMIT 10

commit ba74fdc411b84064d7abe4b10d0708f6dad03eb2
Author: Don Brace <don.brace@microsemi.com>
Date:   Wed Apr 27 17:14:17 2016 -0500

    hpsa: correct handling of HBA device removal
    
    Need to report HBA device removal faster than the
    event handler polling interval.
    
    Stop I/O to the removed disk and wait for all
    I/O operations to flush before removing the device.
    
    Reviewed-by: Scott Teel <scott.teel@microsemi.com>
    Reviewed-by: Kevin Barnett <kevin.barnett@microsemi.com>
    Signed-off-by: Don Brace <don.brace@microsemi.com>
    Reviewed-by: Johannes Thumshirn <jthumshirn@suse.de>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/hpsa.h b/drivers/scsi/hpsa.h
index d06bb7417e36..a1487e67f7a1 100644
--- a/drivers/scsi/hpsa.h
+++ b/drivers/scsi/hpsa.h
@@ -63,6 +63,7 @@ struct hpsa_scsi_dev_t {
 	unsigned char scsi3addr[8];	/* as presented to the HW */
 	u8 physical_device : 1;
 	u8 expose_device;
+	u8 removed : 1;			/* device is marked for death */
 #define RAID_CTLR_LUNID "\0\0\0\0\0\0\0\0"
 	unsigned char device_id[16];    /* from inquiry pg. 0x83 */
 	u64 sas_address;

commit 94c7bc3194cdf4f4e16d08c623f9eab278770d93
Author: Don Brace <don.brace@microsemi.com>
Date:   Tue Feb 23 15:16:46 2016 -0600

    hpsa: update copyright information
    
    Reviewed-by: Justin Lindley <justin.lindley@microsemi.com>
    Reviewed-by: Kevin Barnett <kevin.barnett@microsemi.com>
    Reviewed-by: Matthew R. Ochs <mrochs@linux.vnet.ibm.com>
    Signed-off-by: Don Brace <don.brace@microsemi.com>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/hpsa.h b/drivers/scsi/hpsa.h
index fdd39fc0b199..d06bb7417e36 100644
--- a/drivers/scsi/hpsa.h
+++ b/drivers/scsi/hpsa.h
@@ -1,5 +1,6 @@
 /*
  *    Disk Array driver for HP Smart Array SAS controllers
+ *    Copyright 2016 Microsemi Corporation
  *    Copyright 2014-2015 PMC-Sierra, Inc.
  *    Copyright 2000,2009-2015 Hewlett-Packard Development Company, L.P.
  *
@@ -12,7 +13,7 @@
  *    MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE, GOOD TITLE or
  *    NON INFRINGEMENT.  See the GNU General Public License for more details.
  *
- *    Questions/Comments/Bugfixes to storagedev@pmcs.com
+ *    Questions/Comments/Bugfixes to esc.storagedev@microsemi.com
  *
  */
 #ifndef HPSA_H

commit 09371d623c9c3dc6ed7f53ec8ab01d25f0c6c697
Author: Don Brace <don.brace@pmcs.com>
Date:   Tue Dec 22 10:36:42 2015 -0600

    hpsa: Change SAS transport devices to bus 0.
    
    SAS transport places devices on bus 0 but driver was setting the bus to
    3.
    
    Reviewed-by: Justin Lindley <justin.lindley@pmcs.com>
    Reviewed-by: Kevin Barnett <kevin.barnett@pmcs.com>
    Reviewed-by: Scott Teel <scott.teel@pmcs.com>
    Reviewed-by: Matthew R. Ochs <mrochs@linux.vnet.ibm.com>
    Reviewed-by: Hannes Reinecke <hare@suse.com>
    Signed-off-by: Don Brace <don.brace@pmcs.com>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/hpsa.h b/drivers/scsi/hpsa.h
index ae5beda1bdb5..fdd39fc0b199 100644
--- a/drivers/scsi/hpsa.h
+++ b/drivers/scsi/hpsa.h
@@ -400,7 +400,7 @@ struct offline_device_entry {
 #define HPSA_PHYSICAL_DEVICE_BUS	0
 #define HPSA_RAID_VOLUME_BUS		1
 #define HPSA_EXTERNAL_RAID_VOLUME_BUS	2
-#define HPSA_HBA_BUS			3
+#define HPSA_HBA_BUS			0
 
 /*
 	Send the command to the hardware

commit d04e62b9d63a7498735761dc40eaed88b7fd9d80
Author: Kevin Barnett <kevin.barnett@pmcs.com>
Date:   Wed Nov 4 15:52:34 2015 -0600

    hpsa: add in sas transport class
    
    Reviewed-by: Scott Teel <scott.teel@pmcs.com>
    Reviewed-by: Justin Lindley <justin.lindley@pmcs.com>
    Reviewed-by: Kevin Barnett <kevin.barnett@pmcs.com>
    Reviewed-by: Hannes Reinecke <hare@suse.de>
    Reviewed-by: Tomas Henzl <thenzl@redhat.com>
    Reviewed-by: Matthew R. Ochs <mrochs@linux.vnet.ibm.com>
    Signed-off-by: Don Brace <don.brace@pmcs.com>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/hpsa.h b/drivers/scsi/hpsa.h
index 9c983a919307..ae5beda1bdb5 100644
--- a/drivers/scsi/hpsa.h
+++ b/drivers/scsi/hpsa.h
@@ -33,6 +33,29 @@ struct access_method {
 	unsigned long (*command_completed)(struct ctlr_info *h, u8 q);
 };
 
+/* for SAS hosts and SAS expanders */
+struct hpsa_sas_node {
+	struct device *parent_dev;
+	struct list_head port_list_head;
+};
+
+struct hpsa_sas_port {
+	struct list_head port_list_entry;
+	u64 sas_address;
+	struct sas_port *port;
+	int next_phy_index;
+	struct list_head phy_list_head;
+	struct hpsa_sas_node *parent_node;
+	struct sas_rphy *rphy;
+};
+
+struct hpsa_sas_phy {
+	struct list_head phy_list_entry;
+	struct sas_phy *phy;
+	struct hpsa_sas_port *parent_port;
+	bool added_to_port;
+};
+
 struct hpsa_scsi_dev_t {
 	unsigned int devtype;
 	int bus, target, lun;		/* as presented to the OS */
@@ -41,6 +64,7 @@ struct hpsa_scsi_dev_t {
 	u8 expose_device;
 #define RAID_CTLR_LUNID "\0\0\0\0\0\0\0\0"
 	unsigned char device_id[16];    /* from inquiry pg. 0x83 */
+	u64 sas_address;
 	unsigned char vendor[8];        /* bytes 8-15 of inquiry data */
 	unsigned char model[16];        /* bytes 16-31 of inquiry data */
 	unsigned char raid_level;	/* from inquiry page 0xC1 */
@@ -77,6 +101,7 @@ struct hpsa_scsi_dev_t {
 	struct hpsa_scsi_dev_t *phys_disk[RAID_MAP_MAX_ENTRIES];
 	int nphysical_disks;
 	int supports_aborts;
+	struct hpsa_sas_port *sas_port;
 	int external;   /* 1-from external array 0-not <0-unknown */
 };
 
@@ -134,6 +159,7 @@ struct ctlr_info {
 	char    *product_name;
 	struct pci_dev *pdev;
 	u32	board_id;
+	u64	sas_address;
 	void __iomem *vaddr;
 	unsigned long paddr;
 	int 	nr_cmds; /* Number of commands allowed on this controller */
@@ -272,6 +298,7 @@ struct ctlr_info {
 	wait_queue_head_t event_sync_wait_queue;
 	struct mutex reset_mutex;
 	u8 reset_in_progress;
+	struct hpsa_sas_node *sas_host;
 };
 
 struct offline_device_entry {

commit 34592254c13324add1972e6a7d5f6636d95ade33
Author: Scott Teel <scott.teel@pmcs.com>
Date:   Wed Nov 4 15:52:09 2015 -0600

    hpsa: add discovery polling for PT RAID devices.
    
    There are problems with getting configuration change notification
    in pass-through RAID environments.  So, activate flag
    h->discovery_polling when one of these devices is detected in
    update_scsi_devices.
    
    After discovery_polling is set, execute a report luns from
    rescan_controller_worker (every 30 seconds).
    
    If the data from report_luns is different than last
    time (binary compare), execute a full rescan via update_scsi_devices.
    
    Reviewed-by: Scott Teel <scott.teel@pmcs.com>
    Reviewed-by: Justin Lindley <justin.lindley@pmcs.com>
    Reviewed-by: Kevin Barnett <kevin.barnett@pmcs.com>
    Reviewed-by: Hannes Reinecke <hare@suse.de>
    Reviewed-by: Matthew R. Ochs <mrochs@linux.vnet.ibm.com>
    Signed-off-by: Don Brace <don.brace@pmcs.com>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/hpsa.h b/drivers/scsi/hpsa.h
index ffcd4cbd5efc..9c983a919307 100644
--- a/drivers/scsi/hpsa.h
+++ b/drivers/scsi/hpsa.h
@@ -262,6 +262,8 @@ struct ctlr_info {
 	int	acciopath_status;
 	int	drv_req_rescan;
 	int	raid_offload_debug;
+	int     discovery_polling;
+	struct  ReportLUNdata *lastlogicals;
 	int	needs_abort_tags_swizzled;
 	struct workqueue_struct *resubmit_wq;
 	struct workqueue_struct *rescan_ctlr_wq;

commit 66749d0d617a9cda967f168802f1fb1a6e598a92
Author: Scott Teel <scott.teel@pmcs.com>
Date:   Wed Nov 4 15:51:57 2015 -0600

    hpsa: generalize external arrays
    
    External array LUNs must use target and lun numbers assigned by the
    external array. So the driver must treat these differently from
    local LUNs when assigning lun/target.
    
    LUN's 'model' field has been used to detect Lun types that need
    special treatment, but the desire is to eliminate the need to reference
    specific array models, and support any external array.
    
    Pass-through RAID (PTRAID) luns are not luns of the local controller,
    so they are not reported in LUN count of command 'ID controller'.
    However, they ARE reported in "Report logical Luns" command.
    Local luns are listed first, then PTRAID LUNs.
    
    The number of luns from "Report LUNs" in excess of those reported by
    'ID controller' are therefore the PTRAID LUNS.
    
    We can now remove function is_ext_target, and the 'white list'
    array of supported model names.
    
    Reviewed-by: Scott Teel <scott.teel@pmcs.com>
    Reviewed-by: Justin Lindley <justin.lindley@pmcs.com>
    Reviewed-by: Kevin Barnett <kevin.barnett@pmcs.com>
    Signed-off-by: Don Brace <don.brace@pmcs.com>
    Reviewed-by: Matthew R. Ochs <mrochs@linux.vnet.ibm.com>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/hpsa.h b/drivers/scsi/hpsa.h
index a4cab12fc3b4..ffcd4cbd5efc 100644
--- a/drivers/scsi/hpsa.h
+++ b/drivers/scsi/hpsa.h
@@ -77,6 +77,7 @@ struct hpsa_scsi_dev_t {
 	struct hpsa_scsi_dev_t *phys_disk[RAID_MAP_MAX_ENTRIES];
 	int nphysical_disks;
 	int supports_aborts;
+	int external;   /* 1-from external array 0-not <0-unknown */
 };
 
 struct reply_queue_buffer {

commit c795505a742807fe6ba81d6c63b57c7d2737df3d
Author: Kevin Barnett <kevin.barnett@pmcs.com>
Date:   Wed Nov 4 15:51:45 2015 -0600

    hpsa: refactor hpsa_figure_bus_target_lun
    
    setup for sas transport. Need to set the
    bus and target accordingly.
    
    Reviewed-by: Scott Teel <scott.teel@pmcs.com>
    Reviewed-by: Justin Lindley <justin.lindley@pmcs.com>
    Reviewed-by: Kevin Barnett <kevin.barnett@pmcs.com>
    Reviewed-by: Hannes Reinecke <hare@suse.de>
    Signed-off-by: Don Brace <don.brace@pmcs.com>
    Reviewed-by: Matthew R. Ochs <mrochs@linux.vnet.ibm.com>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/hpsa.h b/drivers/scsi/hpsa.h
index 50e478087919..a4cab12fc3b4 100644
--- a/drivers/scsi/hpsa.h
+++ b/drivers/scsi/hpsa.h
@@ -367,6 +367,11 @@ struct offline_device_entry {
 #define IOACCEL2_INBOUND_POSTQ_64_LOW	0xd0
 #define IOACCEL2_INBOUND_POSTQ_64_HI	0xd4
 
+#define HPSA_PHYSICAL_DEVICE_BUS	0
+#define HPSA_RAID_VOLUME_BUS		1
+#define HPSA_EXTERNAL_RAID_VOLUME_BUS	2
+#define HPSA_HBA_BUS			3
+
 /*
 	Send the command to the hardware
 */

commit 04fa2f44461dd90a00b514cd75ce82f829924826
Author: Kevin Barnett <kevin.barnett@pmcs.com>
Date:   Wed Nov 4 15:51:27 2015 -0600

    hpsa: simplify update scsi devices
    
    remove repeated calculation that checks for physical
    or logical devices.
    
    Reviewed-by: Scott Teel <scott.teel@pmcs.com>
    Reviewed-by: Justin Lindley <justin.lindley@pmcs.com>
    Reviewed-by: Kevin Barnett <kevin.barnett@pmcs.com>
    Reviewed-by: Tomas Henzl <thenzl@redhat.com>
    Reviewed-by: Matthew R. Ochs <mrochs@linux.vnet.ibm.com>
    Reviewed-by: Hannes Reinecke <hare@suse.de>
    Signed-off-by: Don Brace <don.brace@pmcs.com>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/hpsa.h b/drivers/scsi/hpsa.h
index a6ead074da95..50e478087919 100644
--- a/drivers/scsi/hpsa.h
+++ b/drivers/scsi/hpsa.h
@@ -37,6 +37,7 @@ struct hpsa_scsi_dev_t {
 	unsigned int devtype;
 	int bus, target, lun;		/* as presented to the OS */
 	unsigned char scsi3addr[8];	/* as presented to the HW */
+	u8 physical_device : 1;
 	u8 expose_device;
 #define RAID_CTLR_LUNID "\0\0\0\0\0\0\0\0"
 	unsigned char device_id[16];    /* from inquiry pg. 0x83 */

commit 2a168208a35515b8ca54fbf1a17581ad2a852a3f
Author: Kevin Barnett <kevin.barnett@pmcs.com>
Date:   Wed Nov 4 15:51:21 2015 -0600

    hpsa: simplify check for device exposure
    
    remove macros and cleanup device exposure checking
    
    Reviewed-by: Scott Teel <scott.teel@pmcs.com>
    Reviewed-by: Justin Lindley <justin.lindley@pmcs.com>
    Reviewed-by: Kevin Barnett <kevin.barnett@pmcs.com>
    Reviewed-by: Tomas Henzl <thenzl@redhat.com>
    Reviewed-by: Hannes Reinecke <hare@suse.de>
    Signed-off-by: Don Brace <don.brace@pmcs.com>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/hpsa.h b/drivers/scsi/hpsa.h
index 04f98ebe24e9..a6ead074da95 100644
--- a/drivers/scsi/hpsa.h
+++ b/drivers/scsi/hpsa.h
@@ -37,6 +37,7 @@ struct hpsa_scsi_dev_t {
 	unsigned int devtype;
 	int bus, target, lun;		/* as presented to the OS */
 	unsigned char scsi3addr[8];	/* as presented to the HW */
+	u8 expose_device;
 #define RAID_CTLR_LUNID "\0\0\0\0\0\0\0\0"
 	unsigned char device_id[16];    /* from inquiry pg. 0x83 */
 	unsigned char vendor[8];        /* bytes 8-15 of inquiry data */
@@ -75,11 +76,6 @@ struct hpsa_scsi_dev_t {
 	struct hpsa_scsi_dev_t *phys_disk[RAID_MAP_MAX_ENTRIES];
 	int nphysical_disks;
 	int supports_aborts;
-#define HPSA_DO_NOT_EXPOSE	0x0
-#define HPSA_SG_ATTACH		0x1
-#define HPSA_ULD_ATTACH		0x2
-#define HPSA_SCSI_ADD		(HPSA_SG_ATTACH | HPSA_ULD_ATTACH)
-	u8 expose_state;
 };
 
 struct reply_queue_buffer {

commit 0b9b7b6eecad03e0ba4290af7145e2c5d1f8ff13
Author: Scott Teel <scott.teel@pmcs.com>
Date:   Wed Nov 4 15:51:02 2015 -0600

    hpsa: fix physical target reset
    
    Set reset type in device_reset_handler to do either
    logical unit reset for logical devices, or physical
    target reset, for physical devices.
    
    Reviewed-by: Scott Teel <scott.teel@pmcs.com>
    Reviewed-by: Justin Lindley <justin.lindley@pmcs.com>
    Reviewed-by: Kevin Barnett <kevin.barnett@pmcs.com>
    Reviewed-by: Tomas Henzl <thenzl@redhat.com>
    Reviewed-by: Hannes Reinecke <hare@suse.de>
    Signed-off-by: Don Brace <don.brace@pmcs.com>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/hpsa.h b/drivers/scsi/hpsa.h
index dc113c1a8b37..04f98ebe24e9 100644
--- a/drivers/scsi/hpsa.h
+++ b/drivers/scsi/hpsa.h
@@ -285,6 +285,7 @@ struct offline_device_entry {
 #define HPSA_RESET_TYPE_BUS 0x01
 #define HPSA_RESET_TYPE_TARGET 0x03
 #define HPSA_RESET_TYPE_LUN 0x04
+#define HPSA_PHYS_TARGET_RESET 0x99 /* not defined by cciss spec */
 #define HPSA_MSG_SEND_RETRY_LIMIT 10
 #define HPSA_MSG_SEND_RETRY_INTERVAL_MSECS (10000)
 

commit da03ded045b6249261e6c82d942e6d0298dabc9b
Author: Don Brace <don.brace@pmcs.com>
Date:   Wed Nov 4 15:50:56 2015 -0600

    hpsa: fix hpsa_adjust_hpsa_scsi_table
    
    Fix a NULL pointer issue in the driver when devices are removed
    during a reset.
    
    Signed-off-by: Don Brace <don.brace@pmcs.com>
    Reviewed-by: Hannes Reinecke <hare@suse.de>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/hpsa.h b/drivers/scsi/hpsa.h
index b173c0ee9262..dc113c1a8b37 100644
--- a/drivers/scsi/hpsa.h
+++ b/drivers/scsi/hpsa.h
@@ -271,6 +271,7 @@ struct ctlr_info {
 	wait_queue_head_t abort_cmd_wait_queue;
 	wait_queue_head_t event_sync_wait_queue;
 	struct mutex reset_mutex;
+	u8 reset_in_progress;
 };
 
 struct offline_device_entry {

commit 853633e85996cb661e7aed5b3ae8823b12f265cf
Author: Don Brace <don.brace@pmcs.com>
Date:   Wed Nov 4 15:50:37 2015 -0600

    hpsa: allow driver requested rescans
    
    Reviewed-by: Scott Teel <scott.teel@pmcs.com>
    Reviewed-by: Justin Lindley <justin.lindley@pmcs.com>
    Reviewed-by: Kevin Barnett <kevin.barnett@pmcs.com>
    Reviewed-by: Tomas Henzl <thenzl@redhat.com>
    Reviewed-by; Hannes Reinecke <hare@suse.de>
    Signed-off-by: Don Brace <don.brace@pmcs.com>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/hpsa.h b/drivers/scsi/hpsa.h
index d6c4ebf91547..b173c0ee9262 100644
--- a/drivers/scsi/hpsa.h
+++ b/drivers/scsi/hpsa.h
@@ -262,6 +262,7 @@ struct ctlr_info {
 	spinlock_t offline_device_lock;
 	struct list_head offline_device_list;
 	int	acciopath_status;
+	int	drv_req_rescan;
 	int	raid_offload_debug;
 	int	needs_abort_tags_swizzled;
 	struct workqueue_struct *resubmit_wq;

commit 3ad7de6b7d031165e8b2c0775986128de17c5a63
Author: Don Brace <don.brace@pmcs.com>
Date:   Wed Nov 4 15:50:19 2015 -0600

    hpsa: change devtype to unsigned
    
    This member is used in calls to scsi_device_type.
    It should be unsigned since the kernel checks for upper bounds
    and it should never be negative.
    
    Suggested-by: Tomas Henzl <thenzl@redhat.com>
    Suggested-by: Hannes Reinecke <hare@suse.de>
    Suggested-by: Matthew R. Ochs <mrochs@linux.vnet.ibm.com>
    Signed-off-by: Don Brace <don.brace@pmcs.com>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/hpsa.h b/drivers/scsi/hpsa.h
index 27debb363529..d6c4ebf91547 100644
--- a/drivers/scsi/hpsa.h
+++ b/drivers/scsi/hpsa.h
@@ -34,7 +34,7 @@ struct access_method {
 };
 
 struct hpsa_scsi_dev_t {
-	int devtype;
+	unsigned int devtype;
 	int bus, target, lun;		/* as presented to the OS */
 	unsigned char scsi3addr[8];	/* as presented to the HW */
 #define RAID_CTLR_LUNID "\0\0\0\0\0\0\0\0"

commit b9092b79ccaf4404509d6aeb2c76eb7cbfa57bf1
Author: Kevin Barnett <kevin.barnett@pmcs.com>
Date:   Sat Jul 18 11:12:59 2015 -0500

    Change how controllers in mixed mode are handled.
    
    Reviewed-by: Kevin Barnett <kevin.barnett@pmcs.com>
    Reviewed-by: Scott Teel <scott.teel@pmcs.com>
    Reviewed-by: Tomas Henzl <thenzl@redhat.com>
    Signed-off-by: Don Brace <don.brace@pmcs.com>
    Signed-off-by: James Bottomley <JBottomley@Odin.com>

diff --git a/drivers/scsi/hpsa.h b/drivers/scsi/hpsa.h
index ab014d3f3656..27debb363529 100644
--- a/drivers/scsi/hpsa.h
+++ b/drivers/scsi/hpsa.h
@@ -116,7 +116,6 @@ struct bmic_controller_parameters {
 	u8   automatic_drive_slamming;
 	u8   reserved1;
 	u8   nvram_flags;
-#define HBA_MODE_ENABLED_FLAG (1 << 3)
 	u8   cache_nvram_flags;
 	u8   drive_config_flags;
 	u16  reserved2;
@@ -155,7 +154,6 @@ struct ctlr_info {
 	unsigned int msi_vector;
 	int intr_mode; /* either PERF_MODE_INT or SIMPLE_MODE_INT */
 	struct access_method access;
-	char hba_mode_enabled;
 
 	/* queue and queue Info */
 	unsigned int Qdepth;

commit 8270b8624365887a716615294d0ac28af07c9287
Author: Joe Handzik <joseph.t.handzik@hp.com>
Date:   Sat Jul 18 11:12:43 2015 -0500

    hpsa: add sysfs entry path_info to show box and bay information
    
    host no, bus, target, lun, scsi_device_type
    for hba mode add: box and bay information
    
    report if the path is active/inactive
    
    Reviewed-by: Kevin Barnett <kevin.barnett@pmcs.com>
    Reviewed-by: Scott Teel <scott.teel@pmcs.com>
    Reviewed-by: Tomas Henzl <thenzl@redhat.com>
    Signed-off-by: Don Brace <don.brace@pmcs.com>
    Signed-off-by: James Bottomley <JBottomley@Odin.com>

diff --git a/drivers/scsi/hpsa.h b/drivers/scsi/hpsa.h
index 6f6084b39420..ab014d3f3656 100644
--- a/drivers/scsi/hpsa.h
+++ b/drivers/scsi/hpsa.h
@@ -50,6 +50,11 @@ struct hpsa_scsi_dev_t {
 					 * device via "ioaccel" path.
 					 */
 	u32 ioaccel_handle;
+	u8 active_path_index;
+	u8 path_map;
+	u8 bay;
+	u8 box[8];
+	u16 phys_connector[8];
 	int offload_config;		/* I/O accel RAID offload configured */
 	int offload_enabled;		/* I/O accel RAID offload enabled */
 	int offload_to_be_enabled;

commit 1358f6dc5875f5cef06eeeeb4532f382aaff8483
Author: Don Brace <don.brace@pmcs.com>
Date:   Sat Jul 18 11:12:38 2015 -0500

    hpsa: add PMC to copyright
    
    need to add PMC to copyright notice and update the Hewlett-Packard
    copyright notification.
    
    Reviewed-by: Scott Teel <scott.teel@pmcs.com>
    Reviewed-by: Kevin Barnett <kevin.barnett@pmcs.com>
    Reviewed-by: Justin Lindley <justin.lindley@pmcs.com>
    Signed-off-by: Don Brace <don.brace@pmcs.com>
    Signed-off-by: James Bottomley <JBottomley@Odin.com>

diff --git a/drivers/scsi/hpsa.h b/drivers/scsi/hpsa.h
index 6ee4da6b1153..6f6084b39420 100644
--- a/drivers/scsi/hpsa.h
+++ b/drivers/scsi/hpsa.h
@@ -1,6 +1,7 @@
 /*
  *    Disk Array driver for HP Smart Array SAS controllers
- *    Copyright 2000, 2014 Hewlett-Packard Development Company, L.P.
+ *    Copyright 2014-2015 PMC-Sierra, Inc.
+ *    Copyright 2000,2009-2015 Hewlett-Packard Development Company, L.P.
  *
  *    This program is free software; you can redistribute it and/or modify
  *    it under the terms of the GNU General Public License as published by
@@ -11,11 +12,7 @@
  *    MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE, GOOD TITLE or
  *    NON INFRINGEMENT.  See the GNU General Public License for more details.
  *
- *    You should have received a copy of the GNU General Public License
- *    along with this program; if not, write to the Free Software
- *    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
- *
- *    Questions/Comments/Bugfixes to iss_storagedev@hp.com
+ *    Questions/Comments/Bugfixes to storagedev@pmcs.com
  *
  */
 #ifndef HPSA_H

commit d604f5336aee7e67377bdbcd354ea6a7d3979dcb
Author: Webb Scales <webbnh@hp.com>
Date:   Thu Apr 23 09:35:22 2015 -0500

    hpsa: cleanup reset
    
    Synchronize completion the reset with completion of outstanding commands
    
    Extending the newly-added synchronous abort functionality,
    now also synchronize resets with the completion of outstanding commands.
    Rename the wait queue to reflect the fact that it's being used for both
    types of waits.  Also, don't complete commands which are terminated
    due to a reset operation.
    
    fix for controller lockup during reset
    
    Reviewed-by: Scott Teel <scott.teel@pmcs.com>
    Reviewed-by: Kevin Barnett <kevin.barnett@pmcs.com>
    Reviewed-by: Tomas Henzl <thenzl@redhat.com>
    Reviewed-by: Hannes Reinecke <hare@Suse.de>
    Signed-off-by: Webb Scales <webbnh@hp.com>
    Signed-off-by: Don Brace <don.brace@pmcs.com>
    Reviewed-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: James Bottomley <JBottomley@Odin.com>

diff --git a/drivers/scsi/hpsa.h b/drivers/scsi/hpsa.h
index 2536b67e854f..6ee4da6b1153 100644
--- a/drivers/scsi/hpsa.h
+++ b/drivers/scsi/hpsa.h
@@ -47,6 +47,7 @@ struct hpsa_scsi_dev_t {
 	unsigned char raid_level;	/* from inquiry page 0xC1 */
 	unsigned char volume_offline;	/* discovered via TUR or VPD */
 	u16 queue_depth;		/* max queue_depth for this device */
+	atomic_t reset_cmds_out;	/* Count of commands to-be affected */
 	atomic_t ioaccel_cmds_out;	/* Only used for physical devices
 					 * counts commands sent to physical
 					 * device via "ioaccel" path.
@@ -70,6 +71,7 @@ struct hpsa_scsi_dev_t {
 	 * devices in order to honor physical device queue depth limits.
 	 */
 	struct hpsa_scsi_dev_t *phys_disk[RAID_MAP_MAX_ENTRIES];
+	int nphysical_disks;
 	int supports_aborts;
 #define HPSA_DO_NOT_EXPOSE	0x0
 #define HPSA_SG_ATTACH		0x1
@@ -266,7 +268,8 @@ struct ctlr_info {
 	struct workqueue_struct *rescan_ctlr_wq;
 	atomic_t abort_cmds_available;
 	wait_queue_head_t abort_cmd_wait_queue;
-	wait_queue_head_t abort_sync_wait_queue;
+	wait_queue_head_t event_sync_wait_queue;
+	struct mutex reset_mutex;
 };
 
 struct offline_device_entry {

commit 73153fe533bc6209802521fc62d3e3648581a121
Author: Webb Scales <webbnh@hp.com>
Date:   Thu Apr 23 09:35:04 2015 -0500

    hpsa: use block layer tag for command allocation
    
    Rework slave allocation:
      - separate the tagging support setup from the hostdata setup
      - make the hostdata setup act consistently when the lookup fails
      - make the hostdata setup act consistently when the device is not added
      - set up the queue depth consistently across these scenarios
      - if the block layer mq support is not available, explicitly enable and
        activate the SCSI layer tcq support (and do this at allocation-time so
        that the tags will be available for INQUIRY commands)
    
    Tweak slave configuration so that devices which are masked are also
    not attached.
    
    Reviewed-by: Scott Teel <scott.teel@pmcs.com>
    Reviewed-by: Kevin Barnett <kevin.barnett@pmcs.com>
    Reviewed-by: Tomas Henzl <thenzl@redhat.com>
    Reviewed-by: Hannes Reinecke <hare@Suse.de>
    Signed-off-by: Webb Scales <webbnh@hp.com>
    Signed-off-by: Don Brace <don.brace@pmcs.com>
    Reviewed-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: James Bottomley <JBottomley@Odin.com>

diff --git a/drivers/scsi/hpsa.h b/drivers/scsi/hpsa.h
index 3ec8934f0c70..2536b67e854f 100644
--- a/drivers/scsi/hpsa.h
+++ b/drivers/scsi/hpsa.h
@@ -141,7 +141,6 @@ struct ctlr_info {
 	struct CfgTable __iomem *cfgtable;
 	int	interrupts_enabled;
 	int 	max_commands;
-	int last_allocation;
 	atomic_t commands_outstanding;
 #	define PERF_MODE_INT	0
 #	define DOORBELL_INT	1

commit 8b47004a55123b38ed6e8b0d4c8e6427f80a4a45
Author: Robert Elliott <elliott@hp.com>
Date:   Thu Apr 23 09:34:58 2015 -0500

    hpsa: add interrupt number to /proc/interrupts interrupt name
    
    Add the interrupt number to the interrupt names that
    appear in /proc/interrupts, so they are unique
    
    Also, delete the IRQ and DAC prints.  Other parts of the kernel
    already print the IRQ assignments, and dual-address-cycle support
    has not been interesting since the parallel PCI bus went from
    32 to 64 bits wide.
    
    Reviewed-by: Scott Teel <scott.teel@pmcs.com>
    Reviewed-by: Kevin Barnett <kevin.barnett@pmcs.com>
    Reviewed-by: Tomas Henzl <thenzl@redhat.com>
    Reviewed-by: Hannes Reinecke <hare@Suse.de>
    Signed-off-by: Robert Elliott <elliott@hp.com>
    Signed-off-by: Don Brace <don.brace@pmcs.com>
    Reviewed-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: James Bottomley <JBottomley@Odin.com>

diff --git a/drivers/scsi/hpsa.h b/drivers/scsi/hpsa.h
index 7cb8586dc192..3ec8934f0c70 100644
--- a/drivers/scsi/hpsa.h
+++ b/drivers/scsi/hpsa.h
@@ -220,6 +220,7 @@ struct ctlr_info {
 	int remove_in_progress;
 	/* Address of h->q[x] is passed to intr handler to know which queue */
 	u8 q[MAX_REPLY_QUEUES];
+	char intrname[MAX_REPLY_QUEUES][16];	/* "hpsa0-msix00" names */
 	u32 TMFSupportFlags; /* cache what task mgmt funcs are supported. */
 #define HPSATMF_BITS_SUPPORTED  (1 << 0)
 #define HPSATMF_PHYS_LUN_RESET  (1 << 1)

commit a58e7e53b410c8ed05f0b1b0f37411c76b8e253f
Author: Webb Scales <webbnh@hp.com>
Date:   Thu Apr 23 09:34:16 2015 -0500

    hpsa: don't return abort request until target is complete
    
    Don't return from the abort request until the target command is complete.
    Mark outstanding commands which have a pending abort, and do not send them
    to the host if we can avoid it.
    
    If the current command has been aborted, do not call the SCSI command
    completion routine from the I/O path: when the abort returns successfully,
    the SCSI mid-layer will handle the completion implicitly.
    
    The following race was possible in theory.
    
    1. LLD is requested to abort a scsi command
    2. scsi command completes
    3. The struct CommandList associated with 2 is made available.
    4. new io request to LLD to another LUN re-uses struct CommandList
    5. abort handler follows scsi_cmnd->host_scribble and
       finds struct CommandList and tries to aborts it.
    
    Now we have aborted the wrong command.
    
    Fix by resetting the scsi_cmd field of struct CommandList
    upon completion and making the abort handler check that
    the scsi_cmd pointer in the CommadList struct matches the
    scsi_cmnd that it has been asked to abort.
    
    Reviewed-by: Scott Teel <scott.teel@pmcs.com>
    Reviewed-by: Kevin Barnett <kevin.barnett@pmcs.com>
    Reviewed-by: Tomas Henzl <thenzl@redhat.com>
    Reviewed-by: Hannes Reinecke <hare@Suse.de>
    Signed-off-by: Webb Scales <webbnh@hp.com>
    Signed-off-by: Don Brace <don.brace@pmcs.com>
    Reviewed-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: James Bottomley <JBottomley@Odin.com>

diff --git a/drivers/scsi/hpsa.h b/drivers/scsi/hpsa.h
index 28b5d794d6c7..7cb8586dc192 100644
--- a/drivers/scsi/hpsa.h
+++ b/drivers/scsi/hpsa.h
@@ -266,6 +266,7 @@ struct ctlr_info {
 	struct workqueue_struct *rescan_ctlr_wq;
 	atomic_t abort_cmds_available;
 	wait_queue_head_t abort_cmd_wait_queue;
+	wait_queue_head_t abort_sync_wait_queue;
 };
 
 struct offline_device_entry {

commit 8be986cc57f1f802a8cd8542ac309a0e6ac24a4b
Author: Stephen Cameron <stephenmcameron@gmail.com>
Date:   Thu Apr 23 09:34:06 2015 -0500

    hpsa: add support sending aborts to physical devices via the ioaccel2 path
    
    add support for tmf when in ioaccel2 mode
    
    Reviewed-by: Scott Teel <scott.teel@pmcs.com>
    Reviewed-by: Kevin Barnett <kevin.barnett@pmcs.com>
    Reviewed-by: Tomas Henzl <thenzl@redhat.com>
    Reviewed-by: Hannes Reinecke <hare@Suse.de>
    Signed-off-by: Joe Handzik <joseph.t.handzik@hp.com>
    Signed-off-by: Don Brace <don.brace@pmcs.com>
    Reviewed-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: James Bottomley <JBottomley@Odin.com>

diff --git a/drivers/scsi/hpsa.h b/drivers/scsi/hpsa.h
index 3acacf67bd22..28b5d794d6c7 100644
--- a/drivers/scsi/hpsa.h
+++ b/drivers/scsi/hpsa.h
@@ -231,6 +231,7 @@ struct ctlr_info {
 #define HPSATMF_PHYS_QRY_TASK   (1 << 7)
 #define HPSATMF_PHYS_QRY_TSET   (1 << 8)
 #define HPSATMF_PHYS_QRY_ASYNC  (1 << 9)
+#define HPSATMF_IOACCEL_ENABLED (1 << 15)
 #define HPSATMF_MASK_SUPPORTED  (1 << 16)
 #define HPSATMF_LOG_LUN_RESET   (1 << 17)
 #define HPSATMF_LOG_NEX_RESET   (1 << 18)

commit d9a729f3e4d23d4fe8ca458d88d7b982ad3a1600
Author: Webb Scales <webbnh@hp.com>
Date:   Thu Apr 23 09:33:27 2015 -0500

    hpsa: add ioaccel sg chaining for the ioaccel2 path
    
    Increase the request size for ioaccel2 path.
    
    The error, if any, returned by hpsa_allocate_ioaccel2_sg_chain_blocks
    to hpsa_alloc_ioaccel2_cmd_and_bft should be returned upstream rather
    than assumed to be -ENOMEM.
    
    This differs slightly from hpsa_alloc_ioaccel1_cmd_and_bft,
    which does not call another hpsa_allocate function and only
    has -ENOMEM to return from some kmalloc calls.
    
    Reviewed-by: Scott Teel <scott.teel@pmcs.com>
    Reviewed-by: Kevin Barnett <kevin.barnett@pmcs.com>
    Signed-off-by: Robert Elliott <elliott@hp.com>
    Signed-off-by: Don Brace <don.brace@pmcs.com>
    Reviewed-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: James Bottomley <JBottomley@Odin.com>

diff --git a/drivers/scsi/hpsa.h b/drivers/scsi/hpsa.h
index 87a70b5fc5e2..3acacf67bd22 100644
--- a/drivers/scsi/hpsa.h
+++ b/drivers/scsi/hpsa.h
@@ -162,6 +162,7 @@ struct ctlr_info {
 	u8 max_cmd_sg_entries;
 	int chainsize;
 	struct SGDescriptor **cmd_sg_list;
+	struct ioaccel2_sg_element **ioaccel2_cmd_sg_list;
 
 	/* pointers to command and error info pool */
 	struct CommandList 	*cmd_pool;

commit a3144e0b7c2d09ec0a60ef4697c7c3c0bb299ecb
Author: Joe Handzik <joseph.t.handzik@hp.com>
Date:   Thu Apr 23 09:32:59 2015 -0500

    hpsa: use ioaccel2 path to submit IOs to physical drives in HBA mode.
    
    use ioaccel2 path to submit I/O to physical drives in HBA mode
    
    Reviewed-by: Scott Teel <scott.teel@pmcs.com>
    Reviewed-by: Kevin Barnett <kevin.barnett@pmcs.com>
    Reviewed-by: Tomas Henzl <thenzl@redhat.com>
    Reviewed-by: Hannes Reinecke <hare@Suse.de>
    Signed-off-by: Joe Handzik <joseph.t.handzik@hp.com>
    Signed-off-by: Don Brace <don.brace@pmcs.com>
    Reviewed-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: James Bottomley <JBottomley@Odin.com>

diff --git a/drivers/scsi/hpsa.h b/drivers/scsi/hpsa.h
index df2468cd72cf..87a70b5fc5e2 100644
--- a/drivers/scsi/hpsa.h
+++ b/drivers/scsi/hpsa.h
@@ -55,6 +55,7 @@ struct hpsa_scsi_dev_t {
 	int offload_config;		/* I/O accel RAID offload configured */
 	int offload_enabled;		/* I/O accel RAID offload enabled */
 	int offload_to_be_enabled;
+	int hba_ioaccel_enabled;
 	int offload_to_mirror;		/* Send next I/O accelerator RAID
 					 * offload request to mirror drive
 					 */

commit 9b5c48c28f5651f5e36150131bd7b29cc85a3512
Author: Stephen Cameron <stephenmcameron@gmail.com>
Date:   Thu Apr 23 09:32:06 2015 -0500

    hpsa: clean up aborts
    
    Do not send aborts to logical devices that do not support aborts
    
    Instead of relying on what the Smart Array claims for supporting logical
    drives, simply try an abort and see how it responds at device discovery
    time.  This way devices that do support aborts (e.g. MSA2000) can work
    and we do not waste time trying to send aborts to logical drives that do
    not support them (important for high IOPS devices.)
    
    While rescanning devices only test whether devices support aborts
    the first time we encounter a device rather than every time.
    
    Some Smart Arrays required aborts to be sent with tags in
    the wrong endian byte order.  To avoid having to know about
    this, we would send two aborts with tags with each endian order.
    On high IOPS devices, this turns out to be not such a hot idea.
    So we now have a list of the devices that got the tag backwards,
    and we only send it one way.
    
    If all available commands are outstanding and the abort handler
    is invoked, the abort handler may not be able to allocate a command
    and may busy-wait excessivly.  Reserve a small number of commands
    for the abort handler and limit the number of concurrent abort
    requests to the number of reserved commands.
    
    Reviewed-by: Scott Teel <scott.teel@pmcs.com>
    Reviewed-by: Kevin Barnett <kevin.barnett@pmcs.com>
    Reviewed-by: Tomas Henzl <thenzl@redhat.com>
    Reviewed-by: Hannes Reinecke <hare@Suse.de>
    Signed-off-by: Don Brace <don.brace@pmcs.com>
    Reviewed-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: James Bottomley <JBottomley@Odin.com>

diff --git a/drivers/scsi/hpsa.h b/drivers/scsi/hpsa.h
index 58f3315fc6a9..df2468cd72cf 100644
--- a/drivers/scsi/hpsa.h
+++ b/drivers/scsi/hpsa.h
@@ -69,6 +69,7 @@ struct hpsa_scsi_dev_t {
 	 * devices in order to honor physical device queue depth limits.
 	 */
 	struct hpsa_scsi_dev_t *phys_disk[RAID_MAP_MAX_ENTRIES];
+	int supports_aborts;
 #define HPSA_DO_NOT_EXPOSE	0x0
 #define HPSA_SG_ATTACH		0x1
 #define HPSA_ULD_ATTACH		0x2
@@ -257,8 +258,11 @@ struct ctlr_info {
 	struct list_head offline_device_list;
 	int	acciopath_status;
 	int	raid_offload_debug;
+	int	needs_abort_tags_swizzled;
 	struct workqueue_struct *resubmit_wq;
 	struct workqueue_struct *rescan_ctlr_wq;
+	atomic_t abort_cmds_available;
+	wait_queue_head_t abort_cmd_wait_queue;
 };
 
 struct offline_device_entry {

commit 41ce4c355765a5e0a8e1c8ff8d7257160bbae93d
Author: Stephen Cameron <stephenmcameron@gmail.com>
Date:   Thu Apr 23 09:31:47 2015 -0500

    hpsa: add masked physical devices into h->dev[] array
    
    Cache the ioaccel handle so that when we need to abort commands sent
    down the ioaccel2 path, we can look up the LUN ID in h->dev[] instead of
    having to do I/O to the controller.
    
    Add a field to elements in h->dev[] to keep track of how the device is exposed
    to the SCSI mid layer: Not at all, without an upper level driver
    (no_uld_attach) or normally exposed.
    
    Since masked physical devices are now present in h->dev[] array
    it would be perfectly possible to do
    
            echo scsi add-single-device 2 2 0 0 > /proc/scsi/scsi
    
    and bring them online.  This was previously not allowed for masked
    physical devices.
    
    Ensure that the mapping of physical disks to logical drives gets updated in a
    consistent way when a RAID migration occurs and is not touched until updates
    to it are complete.
    
    now instead of doing CISS_REPORT_PHYSICAL to get the LUNID for
    the physical disk in hpsa_get_pdisk_of_ioaccel2(), just get
    it out of h->dev[] where we already have it cached.
    
    do not touch phys_disk[] for ioaccel enabled logical drives during rescan
    
    Reviewed-by: Scott Teel <scott.teel@pmcs.com>
    Reviewed-by: Kevin Barnett <kevin.barnett@pmcs.com>
    Reviewed-by: Tomas Henzl <thenzl@redhat.com>
    Reviewed-by: Hannes Reinecke <hare@Suse.de>
    Signed-off-by: Don Brace <don.brace@pmcs.com>
    Reviewed-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: James Bottomley <JBottomley@Odin.com>

diff --git a/drivers/scsi/hpsa.h b/drivers/scsi/hpsa.h
index 657713050349..58f3315fc6a9 100644
--- a/drivers/scsi/hpsa.h
+++ b/drivers/scsi/hpsa.h
@@ -54,6 +54,7 @@ struct hpsa_scsi_dev_t {
 	u32 ioaccel_handle;
 	int offload_config;		/* I/O accel RAID offload configured */
 	int offload_enabled;		/* I/O accel RAID offload enabled */
+	int offload_to_be_enabled;
 	int offload_to_mirror;		/* Send next I/O accelerator RAID
 					 * offload request to mirror drive
 					 */
@@ -68,6 +69,11 @@ struct hpsa_scsi_dev_t {
 	 * devices in order to honor physical device queue depth limits.
 	 */
 	struct hpsa_scsi_dev_t *phys_disk[RAID_MAP_MAX_ENTRIES];
+#define HPSA_DO_NOT_EXPOSE	0x0
+#define HPSA_SG_ATTACH		0x1
+#define HPSA_ULD_ATTACH		0x2
+#define HPSA_SCSI_ADD		(HPSA_SG_ATTACH | HPSA_ULD_ATTACH)
+	u8 expose_state;
 };
 
 struct reply_queue_buffer {

commit 6636e7f455b33b957c5ee016daa6de46148026ab
Author: Don Brace <don.brace@pmcs.com>
Date:   Fri Jan 23 16:45:17 2015 -0600

    hpsa: Use local workqueues instead of system workqueues
    
    Suggested-by: Tomas Henzl <thenzl@redhat.com>
    Reviewed-by: Webb Scales <webbnh@hp.com>
    Reviewed-by: Kevin Barnett <Kevin.Barnett@pmcs.com>
    Signed-off-by: Don Brace <don.brace@pmcs.com>
    Signed-off-by: Christoph Hellwig <hch@lst.de>

diff --git a/drivers/scsi/hpsa.h b/drivers/scsi/hpsa.h
index 62c50c32070e..657713050349 100644
--- a/drivers/scsi/hpsa.h
+++ b/drivers/scsi/hpsa.h
@@ -207,6 +207,7 @@ struct ctlr_info {
 	atomic_t firmware_flash_in_progress;
 	u32 __percpu *lockup_detected;
 	struct delayed_work monitor_ctlr_work;
+	struct delayed_work rescan_ctlr_work;
 	int remove_in_progress;
 	/* Address of h->q[x] is passed to intr handler to know which queue */
 	u8 q[MAX_REPLY_QUEUES];
@@ -251,6 +252,7 @@ struct ctlr_info {
 	int	acciopath_status;
 	int	raid_offload_debug;
 	struct workqueue_struct *resubmit_wq;
+	struct workqueue_struct *rescan_ctlr_wq;
 };
 
 struct offline_device_entry {

commit c05e8866a17470a978b2c7cbc73d51891cd78f0e
Author: Stephen Cameron <stephenmcameron@gmail.com>
Date:   Fri Jan 23 16:44:40 2015 -0600

    hpsa: do not use function pointers in fast path command submission
    
    Performance tweak, avoid unnecessary function calls.
    
    Reviewed-by: Scott Teel <scott.teel@pmcs.com>
    Signed-off-by: Don Brace <don.brace@pmcs.com>
    Signed-off-by: Christoph Hellwig <hch@lst.de>

diff --git a/drivers/scsi/hpsa.h b/drivers/scsi/hpsa.h
index 239eceac8b60..62c50c32070e 100644
--- a/drivers/scsi/hpsa.h
+++ b/drivers/scsi/hpsa.h
@@ -367,10 +367,7 @@ static void SA5_submit_command_no_read(struct ctlr_info *h,
 static void SA5_submit_command_ioaccel2(struct ctlr_info *h,
 	struct CommandList *c)
 {
-	if (c->cmd_type == CMD_IOACCEL2)
-		writel(c->busaddr, h->vaddr + IOACCEL2_INBOUND_POSTQ_32);
-	else
-		writel(c->busaddr, h->vaddr + SA5_REQUEST_PORT_OFFSET);
+	writel(c->busaddr, h->vaddr + SA5_REQUEST_PORT_OFFSET);
 }
 
 /*

commit c2b0acde0608542add2bfc2a73c23b98f20eeec4
Author: Stephen Cameron <stephenmcameron@gmail.com>
Date:   Fri Jan 23 16:43:56 2015 -0600

    hpsa: do not check for msi(x) in interrupt_pending
    
    No need to check whether interrupt pending for MSI(X) and
    conversely, no need to check whether MSI(X) interrupts are
    being used when checking if interrupts are pending.
    
    Reviewed-by: Scott Teel <scott.teel@pmcs.com>
    Signed-off-by: Don Brace <don.brace@pmcs.com>
    Signed-off-by: Christoph Hellwig <hch@lst.de>

diff --git a/drivers/scsi/hpsa.h b/drivers/scsi/hpsa.h
index aa6cb0b0b427..239eceac8b60 100644
--- a/drivers/scsi/hpsa.h
+++ b/drivers/scsi/hpsa.h
@@ -479,9 +479,6 @@ static bool SA5_performant_intr_pending(struct ctlr_info *h)
 	if (!register_value)
 		return false;
 
-	if (h->msi_vector || h->msix_vector)
-		return true;
-
 	/* Read outbound doorbell to flush */
 	register_value = readl(h->vaddr + SA5_OUTDB_STATUS);
 	return register_value & SA5_OUTDB_STATUS_PERF_BIT;

commit bee266a6d572b231643a486bec11fc5ac370d779
Author: Don Brace <don.brace@pmcs.com>
Date:   Fri Jan 23 16:43:51 2015 -0600

    hpsa: slightly optimize SA5_performant_completed
    
    Reviewed-by: Scott Teel <scott.teel@pmcs.com>
    Signed-off-by: Don Brace <don.brace@pmcs.com>
    Signed-off-by: Christoph Hellwig <hch@lst.de>

diff --git a/drivers/scsi/hpsa.h b/drivers/scsi/hpsa.h
index 1856445f883a..aa6cb0b0b427 100644
--- a/drivers/scsi/hpsa.h
+++ b/drivers/scsi/hpsa.h
@@ -412,19 +412,19 @@ static unsigned long SA5_performant_completed(struct ctlr_info *h, u8 q)
 	unsigned long register_value = FIFO_EMPTY;
 
 	/* msi auto clears the interrupt pending bit. */
-	if (!(h->msi_vector || h->msix_vector)) {
+	if (unlikely(!(h->msi_vector || h->msix_vector))) {
 		/* flush the controller write of the reply queue by reading
 		 * outbound doorbell status register.
 		 */
-		register_value = readl(h->vaddr + SA5_OUTDB_STATUS);
+		(void) readl(h->vaddr + SA5_OUTDB_STATUS);
 		writel(SA5_OUTDB_CLEAR_PERF_BIT, h->vaddr + SA5_OUTDB_CLEAR);
 		/* Do a read in order to flush the write to the controller
 		 * (as per spec.)
 		 */
-		register_value = readl(h->vaddr + SA5_OUTDB_STATUS);
+		(void) readl(h->vaddr + SA5_OUTDB_STATUS);
 	}
 
-	if ((rq->head[rq->current_entry] & 1) == rq->wraparound) {
+	if ((((u32) rq->head[rq->current_entry]) & 1) == rq->wraparound) {
 		register_value = rq->head[rq->current_entry];
 		rq->current_entry++;
 		atomic_dec(&h->commands_outstanding);

commit 34f0c6277c686b191936cc321faebd15b28f9ece
Author: Don Brace <don.brace@pmcs.com>
Date:   Fri Jan 23 16:43:46 2015 -0600

    hpsa: count passthru cmds with atomics, not a spin locked int
    
    Performance enhancement. Remove spin_locks from the driver.
    
    Reviewed-by: Scott Teel <scott.teel@pmcs.com>
    Signed-off-by: Don Brace <don.brace@pmcs.com>
    Signed-off-by: Christoph Hellwig <hch@lst.de>

diff --git a/drivers/scsi/hpsa.h b/drivers/scsi/hpsa.h
index 981479a13935..1856445f883a 100644
--- a/drivers/scsi/hpsa.h
+++ b/drivers/scsi/hpsa.h
@@ -183,8 +183,7 @@ struct ctlr_info {
 
 	/* cap concurrent passthrus at some reasonable maximum */
 #define HPSA_MAX_CONCURRENT_PASSTHRUS (10)
-	spinlock_t passthru_count_lock; /* protects passthru_count */
-	int passthru_count;
+	atomic_t passthru_cmds_avail;
 
 	/*
 	 * Performant mode completion buffers

commit 33811026a0a4208dd5725183d37fc92d5e88b0a2
Author: Robert Elliott <elliott@hp.com>
Date:   Fri Jan 23 16:43:41 2015 -0600

    hpsa: optimize cmd_alloc function by remembering last allocation
    
    Empirically, this improves performance slightly (~2% max IOPS) by
    allowing cmd_alloc to remember where it left off searching for
    free commands between calls instead of always starting its search
    at command 0.
    
    Reviewed-by: Scott Teel <scott.teel@pmcs.com>
    Signed-off-by: Robert Elliott <elliott@hp.com>
    Signed-off-by: Don Brace <don.brace@pmcs.com>
    Signed-off-by: Christoph Hellwig <hch@lst.de>

diff --git a/drivers/scsi/hpsa.h b/drivers/scsi/hpsa.h
index 679e4d2272e0..981479a13935 100644
--- a/drivers/scsi/hpsa.h
+++ b/drivers/scsi/hpsa.h
@@ -133,6 +133,7 @@ struct ctlr_info {
 	struct CfgTable __iomem *cfgtable;
 	int	interrupts_enabled;
 	int 	max_commands;
+	int last_allocation;
 	atomic_t commands_outstanding;
 #	define PERF_MODE_INT	0
 #	define DOORBELL_INT	1

commit 281a7fd03ea37c979bbba4d8376595c0288e3252
Author: Webb Scales <webbnh@hp.com>
Date:   Fri Jan 23 16:43:35 2015 -0600

    hpsa: fix race between abort handler and main i/o path
    
    This means changing the allocator to reference count commands.
    The reference count is now the authoritative indicator of whether a
    command is allocated or not.  The h->cmd_pool_bits bitmap is now
    only a heuristic hint to speed up the allocation process, it is no
    longer the authoritative record of allocated commands.
    
    Since we changed the command allocator to use reference counting
    as the authoritative indicator of whether a command is allocated,
    fail_all_outstanding_cmds needs to use the reference count not
    h->cmd_pool_bits for this purpose.
    
    Fix hpsa_drain_accel_commands to use the reference count as the
    authoritative indicator of whether a command is allocated instead of
    the h->cmd_pool_bits bitmap.
    
    Reviewed-by: Scott Teel <scott.teel@pmcs.com>
    Signed-off-by: Don Brace <don.brace@pmcs.com>
    Signed-off-by: Christoph Hellwig <hch@lst.de>

diff --git a/drivers/scsi/hpsa.h b/drivers/scsi/hpsa.h
index d0fb854195ee..679e4d2272e0 100644
--- a/drivers/scsi/hpsa.h
+++ b/drivers/scsi/hpsa.h
@@ -309,6 +309,8 @@ struct offline_device_entry {
  */
 #define SA5_DOORBELL	0x20
 #define SA5_REQUEST_PORT_OFFSET	0x40
+#define SA5_REQUEST_PORT64_LO_OFFSET 0xC0
+#define SA5_REQUEST_PORT64_HI_OFFSET 0xC4
 #define SA5_REPLY_INTR_MASK_OFFSET	0x34
 #define SA5_REPLY_PORT_OFFSET		0x44
 #define SA5_INTR_STATUS		0x30

commit 03383736348bb73a45f8460afca3c5f5bd1be172
Author: Don Brace <don.brace@pmcs.com>
Date:   Fri Jan 23 16:43:30 2015 -0600

    hpsa: honor queue depth of physical devices
    
    When using the ioaccel submission methods, requests destined for RAID volumes
    are sometimes diverted to physical devices.  The OS has no or limited
    knowledge of these physical devices, so it is up to the driver to avoid
    pushing the device too hard.  It is better to honor the physical device queue
    limit rather than making the device spew zillions of TASK SET FULL responses.
    
    This is so that hpsa based devices support /sys/block/sdNN/device/queue_type
    of simple, which lets the SCSI midlayer automatically adjust the queue_depth
    based on TASK SET FULL and GOOD status.
    
    Adjust the queue depth for a new device after it is created based on the
    maximum queue depths of the physical devices that constitute the
    device. This drops the maximum queue depth from .can_queue of 1024 to
    something like 174 for single-drive RAID-0, 348 for two-drive RAID-1, etc.
    It also adjusts for the ratio of data to parity drives.
    
    Reviewed-by: Scott Teel <scott.teel@pmcs.com>
    Signed-off-by: Webb Scales <webbnh@hp.com>
    Signed-off-by: Don Brace <don.brace@pmcs.com>
    Signed-off-by: Christoph Hellwig <hch@lst.de>

diff --git a/drivers/scsi/hpsa.h b/drivers/scsi/hpsa.h
index a0f4268df457..d0fb854195ee 100644
--- a/drivers/scsi/hpsa.h
+++ b/drivers/scsi/hpsa.h
@@ -46,6 +46,11 @@ struct hpsa_scsi_dev_t {
 	unsigned char model[16];        /* bytes 16-31 of inquiry data */
 	unsigned char raid_level;	/* from inquiry page 0xC1 */
 	unsigned char volume_offline;	/* discovered via TUR or VPD */
+	u16 queue_depth;		/* max queue_depth for this device */
+	atomic_t ioaccel_cmds_out;	/* Only used for physical devices
+					 * counts commands sent to physical
+					 * device via "ioaccel" path.
+					 */
 	u32 ioaccel_handle;
 	int offload_config;		/* I/O accel RAID offload configured */
 	int offload_enabled;		/* I/O accel RAID offload enabled */
@@ -54,6 +59,15 @@ struct hpsa_scsi_dev_t {
 					 */
 	struct raid_map_data raid_map;	/* I/O accelerator RAID map */
 
+	/*
+	 * Pointers from logical drive map indices to the phys drives that
+	 * make those logical drives.  Note, multiple logical drives may
+	 * share physical drives.  You can have for instance 5 physical
+	 * drives with 3 logical drives each using those same 5 physical
+	 * disks. We need these pointers for counting i/o's out to physical
+	 * devices in order to honor physical device queue depth limits.
+	 */
+	struct hpsa_scsi_dev_t *phys_disk[RAID_MAP_MAX_ENTRIES];
 };
 
 struct reply_queue_buffer {

commit 080ef1cc7fdf5d0800775c8626718da807e7ba99
Author: Don Brace <don.brace@pmcs.com>
Date:   Fri Jan 23 16:43:25 2015 -0600

    hpsa: use workqueue to resubmit failed ioaccel commands
    
    Instead of kicking the commands all the way back to the mid
    layer, use a work queue.  This enables having a mechanism for
    the driver to be able to resubmit the commands down the "normal"
    raid path without turning off the ioaccel feature entirely
    whenever an error is encountered on the ioaccel path, and
    prevent excessive rescanning of devices.
    
    Reviewed-by: Scott Teel <scott.teel@pmcs.com>
    Signed-off-by: Don Brace <don.brace@pmcs.com>
    Signed-off-by: Christoph Hellwig <hch@lst.de>

diff --git a/drivers/scsi/hpsa.h b/drivers/scsi/hpsa.h
index 06a3e812ec38..a0f4268df457 100644
--- a/drivers/scsi/hpsa.h
+++ b/drivers/scsi/hpsa.h
@@ -236,6 +236,7 @@ struct ctlr_info {
 	struct list_head offline_device_list;
 	int	acciopath_status;
 	int	raid_offload_debug;
+	struct workqueue_struct *resubmit_wq;
 };
 
 struct offline_device_entry {

commit 7acf570ce51a5ebee55ef72e77916afdb4a351a7
Author: Stephen Cameron <stephenmcameron@gmail.com>
Date:   Fri Jan 23 16:43:14 2015 -0600

    hpsa: do not request device rescan on every ioaccel path error
    
    The original reasoning behind doing this was faulty.  An error
    of some sort would be encountered, accelerated i/o would be
    disabled for that logical drive, the command would be kicked
    back out to the SCSI midlayer for a retry, and since i/o accelerator
    mode was disabled, it would get retried down the RAID path.
    However, something needs to turn ioaccellerator mode back on,
    and this rescan request was what did that.  However, it was racy,
    and extremely bad for performance to rescan all devices, so,
    don't do that.
    
    Reviewed-by: Scott Teel <scott.teel@pmcs.com>
    Signed-off-by: Don Brace <don.brace@pmcs.com>
    Signed-off-by: Christoph Hellwig <hch@lst.de>

diff --git a/drivers/scsi/hpsa.h b/drivers/scsi/hpsa.h
index e7d7eaa864d1..06a3e812ec38 100644
--- a/drivers/scsi/hpsa.h
+++ b/drivers/scsi/hpsa.h
@@ -235,7 +235,6 @@ struct ctlr_info {
 	spinlock_t offline_device_lock;
 	struct list_head offline_device_list;
 	int	acciopath_status;
-	int	drv_req_rescan;	/* flag for driver to request rescan event */
 	int	raid_offload_debug;
 };
 

commit f2405db8b4605732c8f0224c33b9d206e37b68c5
Author: Don Brace <don.brace@pmcs.com>
Date:   Fri Jan 23 16:43:09 2015 -0600

    hpsa: do not queue commands internally in driver
    
    By not doing maintaining a list of queued commands, we can eliminate some spin
    locking in the main i/o path and gain significant improvement in IOPS.  Remove
    the queuing code and the code that calls it; remove now-unused interrupt code;
    remove DIRECT_LOOKUP_BIT.
    
    Now that the passthru commands share the same command pool as
    the main i/o path, and the total size of the pool is less than
    or equal to the number of commands that will fit in the hardware
    fifo, there is no need to check to see if we are exceeding the
    hardware fifo's depth.
    
    Reviewed-by: Scott Teel <scott.teel@pmcs.com>
    Reviewed-by: Robert Elliott <elliott@hp.com>
    Signed-off-by: Don Brace <don.brace@pmcs.com>
    Signed-off-by: Christoph Hellwig <hch@lst.de>

diff --git a/drivers/scsi/hpsa.h b/drivers/scsi/hpsa.h
index 06c9e430a64a..e7d7eaa864d1 100644
--- a/drivers/scsi/hpsa.h
+++ b/drivers/scsi/hpsa.h
@@ -32,7 +32,6 @@ struct access_method {
 	void (*submit_command)(struct ctlr_info *h,
 		struct CommandList *c);
 	void (*set_intr_mask)(struct ctlr_info *h, unsigned long val);
-	unsigned long (*fifo_full)(struct ctlr_info *h);
 	bool (*intr_pending)(struct ctlr_info *h);
 	unsigned long (*command_completed)(struct ctlr_info *h, u8 q);
 };
@@ -133,8 +132,6 @@ struct ctlr_info {
 	char hba_mode_enabled;
 
 	/* queue and queue Info */
-	struct list_head reqQ;
-	struct list_head cmpQ;
 	unsigned int Qdepth;
 	unsigned int maxSG;
 	spinlock_t lock;
@@ -197,7 +194,6 @@ struct ctlr_info {
 	u32 __percpu *lockup_detected;
 	struct delayed_work monitor_ctlr_work;
 	int remove_in_progress;
-	u32 fifo_recently_full;
 	/* Address of h->q[x] is passed to intr handler to know which queue */
 	u8 q[MAX_REPLY_QUEUES];
 	u32 TMFSupportFlags; /* cache what task mgmt funcs are supported. */
@@ -427,14 +423,6 @@ static unsigned long SA5_performant_completed(struct ctlr_info *h, u8 q)
 	return register_value;
 }
 
-/*
- *  Returns true if fifo is full.
- *
- */
-static unsigned long SA5_fifo_full(struct ctlr_info *h)
-{
-	return atomic_read(&h->commands_outstanding) >= h->max_commands;
-}
 /*
  *   returns value read from hardware.
  *     returns FIFO_EMPTY if there is nothing to read
@@ -527,7 +515,6 @@ static unsigned long SA5_ioaccel_mode1_completed(struct ctlr_info *h, u8 q)
 static struct access_method SA5_access = {
 	SA5_submit_command,
 	SA5_intr_mask,
-	SA5_fifo_full,
 	SA5_intr_pending,
 	SA5_completed,
 };
@@ -535,7 +522,6 @@ static struct access_method SA5_access = {
 static struct access_method SA5_ioaccel_mode1_access = {
 	SA5_submit_command,
 	SA5_performant_intr_mask,
-	SA5_fifo_full,
 	SA5_ioaccel_mode1_intr_pending,
 	SA5_ioaccel_mode1_completed,
 };
@@ -543,7 +529,6 @@ static struct access_method SA5_ioaccel_mode1_access = {
 static struct access_method SA5_ioaccel_mode2_access = {
 	SA5_submit_command_ioaccel2,
 	SA5_performant_intr_mask,
-	SA5_fifo_full,
 	SA5_performant_intr_pending,
 	SA5_performant_completed,
 };
@@ -551,7 +536,6 @@ static struct access_method SA5_ioaccel_mode2_access = {
 static struct access_method SA5_performant_access = {
 	SA5_submit_command,
 	SA5_performant_intr_mask,
-	SA5_fifo_full,
 	SA5_performant_intr_pending,
 	SA5_performant_completed,
 };
@@ -559,7 +543,6 @@ static struct access_method SA5_performant_access = {
 static struct access_method SA5_performant_access_no_read = {
 	SA5_submit_command_no_read,
 	SA5_performant_intr_mask,
-	SA5_fifo_full,
 	SA5_performant_intr_pending,
 	SA5_performant_completed,
 };

commit 45fcb86e4663122590d243a466eb21ae45890f03
Author: Stephen Cameron <stephenmcameron@gmail.com>
Date:   Fri Jan 23 16:43:04 2015 -0600

    hpsa: get rid of cmd_special_alloc and cmd_special_free
    
    We have commands reserved for internal use.
    
    This is laying the groundwork for removing the internal
    queue of commands from the driver so that the locks that
    protect that queue may be removed.
    
    Reviewed-by: Scott Teel <scott.teel@pmcs.com>
    Signed-off-by: Don Brace <don.brace@pmcs.com>
    Signed-off-by: Christoph Hellwig <hch@lst.de>

diff --git a/drivers/scsi/hpsa.h b/drivers/scsi/hpsa.h
index 5ee6c6a73b0c..06c9e430a64a 100644
--- a/drivers/scsi/hpsa.h
+++ b/drivers/scsi/hpsa.h
@@ -170,7 +170,7 @@ struct ctlr_info {
 	unsigned long transMethod;
 
 	/* cap concurrent passthrus at some reasonable maximum */
-#define HPSA_MAX_CONCURRENT_PASSTHRUS (20)
+#define HPSA_MAX_CONCURRENT_PASSTHRUS (10)
 	spinlock_t passthru_count_lock; /* protects passthru_count */
 	int passthru_count;
 

commit d54c5c24870ff4d581ce17f09d0c5fcb728c1d02
Author: Stephen Cameron <stephenmcameron@gmail.com>
Date:   Fri Jan 23 16:42:59 2015 -0600

    hpsa: reserve some commands for use by driver
    
    We need to reserve some commands for device rescans,
    aborts, and the pass through ioctls, etc. so we cannot
    give them all to the scsi mid layer.
    
    This is in preparation for removing cmd_special_alloc and
    cmd_special_free so that we can stop queuing commands internally
    in the driver so that we can remove the locks thta protect the
    queue that we will no longer have.
    
    Reviewed-by: Scott Teel <scott.teel@pmcs.com>
    Signed-off-by: Don Brace <don.brace@pmcs.com>
    Signed-off-by: Christoph Hellwig <hch@lst.de>

diff --git a/drivers/scsi/hpsa.h b/drivers/scsi/hpsa.h
index 8e06d9e280ec..5ee6c6a73b0c 100644
--- a/drivers/scsi/hpsa.h
+++ b/drivers/scsi/hpsa.h
@@ -115,6 +115,8 @@ struct ctlr_info {
 	void __iomem *vaddr;
 	unsigned long paddr;
 	int 	nr_cmds; /* Number of commands allowed on this controller */
+#define HPSA_CMDS_RESERVED_FOR_ABORTS 2
+#define HPSA_CMDS_RESERVED_FOR_DRIVER 1
 	struct CfgTable __iomem *cfgtable;
 	int	interrupts_enabled;
 	int 	max_commands;

commit 0cbf768ef834c810d1eab205f21a434b9356d329
Author: Stephen M. Cameron <stephenmcameron@gmail.com>
Date:   Fri Nov 14 17:27:09 2014 -0600

    hpsa: use atomics for commands_outstanding
    
    Use atomics for commands_outstanding instead of protecting with spin locks.
    
    Signed-off-by: Don Brace <don.brace@pmcs.com>
    Signed-off-by: Stephen M. Cameron <stephenmcameron@gmail.com>
    Reviewed-by: Joe Handzik <joseph.t.handzik@hp.com>
    Signed-off-by: Christoph Hellwig <hch@lst.de>

diff --git a/drivers/scsi/hpsa.h b/drivers/scsi/hpsa.h
index 80fa9a99b692..8e06d9e280ec 100644
--- a/drivers/scsi/hpsa.h
+++ b/drivers/scsi/hpsa.h
@@ -118,7 +118,7 @@ struct ctlr_info {
 	struct CfgTable __iomem *cfgtable;
 	int	interrupts_enabled;
 	int 	max_commands;
-	int	commands_outstanding;
+	atomic_t commands_outstanding;
 #	define PERF_MODE_INT	0
 #	define DOORBELL_INT	1
 #	define SIMPLE_MODE_INT	2
@@ -395,7 +395,7 @@ static void SA5_performant_intr_mask(struct ctlr_info *h, unsigned long val)
 static unsigned long SA5_performant_completed(struct ctlr_info *h, u8 q)
 {
 	struct reply_queue_buffer *rq = &h->reply_queue[q];
-	unsigned long flags, register_value = FIFO_EMPTY;
+	unsigned long register_value = FIFO_EMPTY;
 
 	/* msi auto clears the interrupt pending bit. */
 	if (!(h->msi_vector || h->msix_vector)) {
@@ -413,9 +413,7 @@ static unsigned long SA5_performant_completed(struct ctlr_info *h, u8 q)
 	if ((rq->head[rq->current_entry] & 1) == rq->wraparound) {
 		register_value = rq->head[rq->current_entry];
 		rq->current_entry++;
-		spin_lock_irqsave(&h->lock, flags);
-		h->commands_outstanding--;
-		spin_unlock_irqrestore(&h->lock, flags);
+		atomic_dec(&h->commands_outstanding);
 	} else {
 		register_value = FIFO_EMPTY;
 	}
@@ -433,11 +431,7 @@ static unsigned long SA5_performant_completed(struct ctlr_info *h, u8 q)
  */
 static unsigned long SA5_fifo_full(struct ctlr_info *h)
 {
-	if (h->commands_outstanding >= h->max_commands)
-		return 1;
-	else
-		return 0;
-
+	return atomic_read(&h->commands_outstanding) >= h->max_commands;
 }
 /*
  *   returns value read from hardware.
@@ -448,13 +442,9 @@ static unsigned long SA5_completed(struct ctlr_info *h,
 {
 	unsigned long register_value
 		= readl(h->vaddr + SA5_REPLY_PORT_OFFSET);
-	unsigned long flags;
 
-	if (register_value != FIFO_EMPTY) {
-		spin_lock_irqsave(&h->lock, flags);
-		h->commands_outstanding--;
-		spin_unlock_irqrestore(&h->lock, flags);
-	}
+	if (register_value != FIFO_EMPTY)
+		atomic_dec(&h->commands_outstanding);
 
 #ifdef HPSA_DEBUG
 	if (register_value != FIFO_EMPTY)
@@ -510,7 +500,6 @@ static unsigned long SA5_ioaccel_mode1_completed(struct ctlr_info *h, u8 q)
 {
 	u64 register_value;
 	struct reply_queue_buffer *rq = &h->reply_queue[q];
-	unsigned long flags;
 
 	BUG_ON(q >= h->nreply_queues);
 
@@ -528,9 +517,7 @@ static unsigned long SA5_ioaccel_mode1_completed(struct ctlr_info *h, u8 q)
 		wmb();
 		writel((q << 24) | rq->current_entry, h->vaddr +
 				IOACCEL_MODE1_CONSUMER_INDEX);
-		spin_lock_irqsave(&h->lock, flags);
-		h->commands_outstanding--;
-		spin_unlock_irqrestore(&h->lock, flags);
+		atomic_dec(&h->commands_outstanding);
 	}
 	return (unsigned long) register_value;
 }

commit 42a916415de106606a4fc479a4340b9ad178fb57
Author: Don Brace <don.brace@pmcs.com>
Date:   Fri Nov 14 17:26:27 2014 -0600

    hpsa: Clean up warnings from sparse.
    
    Clean up issues reported when running sparse.
    
    Signed-off-by: Don Brace <don.brace@pmcs.com>
    Reviewed-by: Webb Scales <webb.scales@hp.com>
    Signed-off-by: Christoph Hellwig <hch@lst.de>

diff --git a/drivers/scsi/hpsa.h b/drivers/scsi/hpsa.h
index 24472cec7de3..80fa9a99b692 100644
--- a/drivers/scsi/hpsa.h
+++ b/drivers/scsi/hpsa.h
@@ -164,7 +164,7 @@ struct ctlr_info {
 	 */
 	u32 trans_support;
 	u32 trans_offset;
-	struct TransTable_struct *transtable;
+	struct TransTable_struct __iomem *transtable;
 	unsigned long transMethod;
 
 	/* cap concurrent passthrus at some reasonable maximum */
@@ -181,7 +181,7 @@ struct ctlr_info {
 	u32 *blockFetchTable;
 	u32 *ioaccel1_blockFetchTable;
 	u32 *ioaccel2_blockFetchTable;
-	u32 *ioaccel2_bft2_regs;
+	u32 __iomem *ioaccel2_bft2_regs;
 	unsigned char *hba_inquiry_data;
 	u32 driver_support;
 	u32 fw_support;
@@ -192,7 +192,7 @@ struct ctlr_info {
 	u64 last_heartbeat_timestamp;
 	u32 heartbeat_sample_interval;
 	atomic_t firmware_flash_in_progress;
-	u32 *lockup_detected;
+	u32 __percpu *lockup_detected;
 	struct delayed_work monitor_ctlr_work;
 	int remove_in_progress;
 	u32 fifo_recently_full;

commit 7b2c46ee7259c52cf2c1f82ab100e9aaeb83f78a
Author: Stephen M. Cameron <scameron@beardog.cce.hp.com>
Date:   Thu May 29 10:53:44 2014 -0500

    hpsa: fix event filtering to prevent excessive rescans with old firmware
    
    CTLR_STATE_CHANGE_EVENT and CTLR_STATE_CHANGE_EVENT_REDUNDANT_CNTRL
    do not require rescans to be initiated.  Current firmware filters out
    these events already, but some out of date firmware doesn't, so the
    driver needs to filter them out too.  Without this change and with out
    of date firmware you may see the driver spending a lot of time
    scanning devices unnecessarily on some Smart Arrays.
    
    Signed-off-by: Stephen M. Cameron <scameron@beardog.cce.hp.com>
    Reviewed-by: Justin Lindley <justin.lindley@hp.com>
    Signed-off-by: Christoph Hellwig <hch@lst.de>

diff --git a/drivers/scsi/hpsa.h b/drivers/scsi/hpsa.h
index 0a5d91c4ded8..24472cec7de3 100644
--- a/drivers/scsi/hpsa.h
+++ b/drivers/scsi/hpsa.h
@@ -229,11 +229,9 @@ struct ctlr_info {
 #define CTLR_STATE_CHANGE_EVENT_AIO_CONFIG_CHANGE	(1 << 31)
 
 #define RESCAN_REQUIRED_EVENT_BITS \
-		(CTLR_STATE_CHANGE_EVENT | \
-		CTLR_ENCLOSURE_HOT_PLUG_EVENT | \
+		(CTLR_ENCLOSURE_HOT_PLUG_EVENT | \
 		CTLR_STATE_CHANGE_EVENT_PHYSICAL_DRV | \
 		CTLR_STATE_CHANGE_EVENT_LOGICAL_DRV | \
-		CTLR_STATE_CHANGE_EVENT_REDUNDANT_CNTRL | \
 		CTLR_STATE_CHANGE_EVENT_AIO_ENABLED_DISABLED | \
 		CTLR_STATE_CHANGE_EVENT_AIO_CONFIG_CHANGE)
 	spinlock_t offline_device_lock;

commit b3a52e791efd341a9a4e9065c667041c822661f0
Author: Stephen M. Cameron <scameron@beardog.cce.hp.com>
Date:   Thu May 29 10:53:23 2014 -0500

    hpsa: avoid unnecessary readl on every command submission
    
    for controllers which support either of the ioaccel transport methods.
    
    Signed-off-by: Stephen M. Cameron <scameron@beardog.cce.hp.com>
    Reviewed-by: Mike Miller <michael.miller@canonical.com>
    Reviewed-by: Joe Handzik <joseph.t.handzik@hp.com>
    Signed-off-by: Christoph Hellwig <hch@lst.de>

diff --git a/drivers/scsi/hpsa.h b/drivers/scsi/hpsa.h
index 6da9a9f4b749..0a5d91c4ded8 100644
--- a/drivers/scsi/hpsa.h
+++ b/drivers/scsi/hpsa.h
@@ -346,6 +346,12 @@ static void SA5_submit_command(struct ctlr_info *h,
 	(void) readl(h->vaddr + SA5_SCRATCHPAD_OFFSET);
 }
 
+static void SA5_submit_command_no_read(struct ctlr_info *h,
+	struct CommandList *c)
+{
+	writel(c->busaddr, h->vaddr + SA5_REQUEST_PORT_OFFSET);
+}
+
 static void SA5_submit_command_ioaccel2(struct ctlr_info *h,
 	struct CommandList *c)
 {
@@ -353,7 +359,6 @@ static void SA5_submit_command_ioaccel2(struct ctlr_info *h,
 		writel(c->busaddr, h->vaddr + IOACCEL2_INBOUND_POSTQ_32);
 	else
 		writel(c->busaddr, h->vaddr + SA5_REQUEST_PORT_OFFSET);
-	(void) readl(h->vaddr + SA5_SCRATCHPAD_OFFSET);
 }
 
 /*
@@ -564,6 +569,14 @@ static struct access_method SA5_performant_access = {
 	SA5_performant_completed,
 };
 
+static struct access_method SA5_performant_access_no_read = {
+	SA5_submit_command_no_read,
+	SA5_performant_intr_mask,
+	SA5_fifo_full,
+	SA5_performant_intr_pending,
+	SA5_performant_completed,
+};
+
 struct board_type {
 	u32	board_id;
 	char	*product_name;

commit 094963dad88c86f8f480c78992df03d916774c18
Author: Stephen M. Cameron <scameron@beardog.cce.hp.com>
Date:   Thu May 29 10:53:18 2014 -0500

    hpsa: use per-cpu variable for lockup_detected
    
    Avoid excessive locking by using per-cpu variable for lockup_detected
    
    Signed-off-by: Stephen M. Cameron <scameron@beardog.cce.hp.com>
    Reviewed-by: Scott Teel <scott.teel@hp.com>
    Signed-off-by: Christoph Hellwig <hch@lst.de>

diff --git a/drivers/scsi/hpsa.h b/drivers/scsi/hpsa.h
index 60d72fc3c180..6da9a9f4b749 100644
--- a/drivers/scsi/hpsa.h
+++ b/drivers/scsi/hpsa.h
@@ -192,7 +192,7 @@ struct ctlr_info {
 	u64 last_heartbeat_timestamp;
 	u32 heartbeat_sample_interval;
 	atomic_t firmware_flash_in_progress;
-	u32 lockup_detected;
+	u32 *lockup_detected;
 	struct delayed_work monitor_ctlr_work;
 	int remove_in_progress;
 	u32 fifo_recently_full;

commit 072b0518b0f75296443a0df9fe7f25e052e62652
Author: Stephen M. Cameron <scameron@beardog.cce.hp.com>
Date:   Thu May 29 10:53:07 2014 -0500

    hpsa: allocate reply queues individually
    
    Now that we can allocate more than 4 reply queues (up to 64)
    we shouldn't try to make them share the same allocation but
    should allocate them separately.
    
    Signed-off-by: Stephen M. Cameron <scameron@beardog.cce.hp.com>
    Reviewed-by: Mike Miller <michael.miller@canonical.com>
    Reviewed-by: Scott Teel <scott.teel@hp.com>
    Signed-off-by: Christoph Hellwig <hch@lst.de>

diff --git a/drivers/scsi/hpsa.h b/drivers/scsi/hpsa.h
index 5ee3e7a9126d..60d72fc3c180 100644
--- a/drivers/scsi/hpsa.h
+++ b/drivers/scsi/hpsa.h
@@ -57,11 +57,12 @@ struct hpsa_scsi_dev_t {
 
 };
 
-struct reply_pool {
+struct reply_queue_buffer {
 	u64 *head;
 	size_t size;
 	u8 wraparound;
 	u32 current_entry;
+	dma_addr_t busaddr;
 };
 
 #pragma pack(1)
@@ -174,11 +175,9 @@ struct ctlr_info {
 	/*
 	 * Performant mode completion buffers
 	 */
-	u64 *reply_pool;
-	size_t reply_pool_size;
-	struct reply_pool reply_queue[MAX_REPLY_QUEUES];
+	size_t reply_queue_size;
+	struct reply_queue_buffer reply_queue[MAX_REPLY_QUEUES];
 	u8 nreply_queues;
-	dma_addr_t reply_pool_dhandle;
 	u32 *blockFetchTable;
 	u32 *ioaccel1_blockFetchTable;
 	u32 *ioaccel2_blockFetchTable;
@@ -392,7 +391,7 @@ static void SA5_performant_intr_mask(struct ctlr_info *h, unsigned long val)
 
 static unsigned long SA5_performant_completed(struct ctlr_info *h, u8 q)
 {
-	struct reply_pool *rq = &h->reply_queue[q];
+	struct reply_queue_buffer *rq = &h->reply_queue[q];
 	unsigned long flags, register_value = FIFO_EMPTY;
 
 	/* msi auto clears the interrupt pending bit. */
@@ -507,7 +506,7 @@ static bool SA5_ioaccel_mode1_intr_pending(struct ctlr_info *h)
 static unsigned long SA5_ioaccel_mode1_completed(struct ctlr_info *h, u8 q)
 {
 	u64 register_value;
-	struct reply_pool *rq = &h->reply_queue[q];
+	struct reply_queue_buffer *rq = &h->reply_queue[q];
 	unsigned long flags;
 
 	BUG_ON(q >= h->nreply_queues);

commit 7b9235ee19aa7405d91f00a3e1668029cbf4a463
Author: Stephen M. Cameron <scameron@beardog.cce.hp.com>
Date:   Thu May 29 10:52:57 2014 -0500

    hpsa: remove dev_dbg() calls from hot paths
    
    They are not completely free of cost when disabled and
    when enabled emitting debug output for every command
    submitted produces far too much output to be useful.
    
    Signed-off-by: Stephen M. Cameron <scameron@beardog.cce.hp.com>
    Reviewed-by: Mike Miller <michael.miller@canonical.com>
    Reviewed-by: Webb Scales <webb.scales@hp.com>
    Signed-off-by: Christoph Hellwig <hch@lst.de>

diff --git a/drivers/scsi/hpsa.h b/drivers/scsi/hpsa.h
index 75414a0ac657..5ee3e7a9126d 100644
--- a/drivers/scsi/hpsa.h
+++ b/drivers/scsi/hpsa.h
@@ -343,8 +343,6 @@ struct offline_device_entry {
 static void SA5_submit_command(struct ctlr_info *h,
 	struct CommandList *c)
 {
-	dev_dbg(&h->pdev->dev, "Sending %x, tag = %x\n", c->busaddr,
-		c->Header.Tag.lower);
 	writel(c->busaddr, h->vaddr + SA5_REQUEST_PORT_OFFSET);
 	(void) readl(h->vaddr + SA5_SCRATCHPAD_OFFSET);
 }
@@ -352,8 +350,6 @@ static void SA5_submit_command(struct ctlr_info *h,
 static void SA5_submit_command_ioaccel2(struct ctlr_info *h,
 	struct CommandList *c)
 {
-	dev_dbg(&h->pdev->dev, "Sending %x, tag = %x\n", c->busaddr,
-		c->Header.Tag.lower);
 	if (c->cmd_type == CMD_IOACCEL2)
 		writel(c->busaddr, h->vaddr + IOACCEL2_INBOUND_POSTQ_32);
 	else
@@ -475,7 +471,6 @@ static bool SA5_intr_pending(struct ctlr_info *h)
 {
 	unsigned long register_value  =
 		readl(h->vaddr + SA5_INTR_STATUS);
-	dev_dbg(&h->pdev->dev, "intr_pending %lx\n", register_value);
 	return register_value & SA5_INTR_PENDING;
 }
 

commit 84ce1ee5bf0de5daec3d28d009d74099cee3cf46
Author: Stephen M. Cameron <scameron@beardog.cce.hp.com>
Date:   Thu May 29 10:52:31 2014 -0500

    hpsa: remove unused fields from struct ctlr_info
    
    The fields "major", "max_outstanding", and "usage_count"
    of struct ctlr_info were not used for anything.
    
    Signed-off-by: Stephen M. Cameron <scameron@beardog.cce.hp.com>
    Reviewed-by: Mike Miller <michael.miller@canonical.com>
    Reviewed-by: Webb Scales <webb.scales@hp.com>
    Signed-off-by: Christoph Hellwig <hch@lst.de>

diff --git a/drivers/scsi/hpsa.h b/drivers/scsi/hpsa.h
index 1e3cf33a82cf..75414a0ac657 100644
--- a/drivers/scsi/hpsa.h
+++ b/drivers/scsi/hpsa.h
@@ -116,11 +116,8 @@ struct ctlr_info {
 	int 	nr_cmds; /* Number of commands allowed on this controller */
 	struct CfgTable __iomem *cfgtable;
 	int	interrupts_enabled;
-	int	major;
 	int 	max_commands;
 	int	commands_outstanding;
-	int 	max_outstanding; /* Debug */
-	int	usage_count;  /* number of opens all all minor devices */
 #	define PERF_MODE_INT	0
 #	define DOORBELL_INT	1
 #	define SIMPLE_MODE_INT	2

commit 6e8e8088aa9d2f0108dda6943aea8930be6f8f22
Author: Joe Handzik <joseph.t.handzik@hp.com>
Date:   Thu May 15 15:44:42 2014 -0500

    hpsa: fix memory leak in hpsa_hba_mode_enabled
    
    And while we're at it fix a magic number
    
    Signed-off-by: Joe Handzik <joseph.t.handzik@hp.com>
    Signed-off-by: Stephen M. Cameron <scameron@beardog.cce.hp.com>
    Signed-off-by: Christoph Hellwig <hch@lst.de>

diff --git a/drivers/scsi/hpsa.h b/drivers/scsi/hpsa.h
index 44235a27e1b6..1e3cf33a82cf 100644
--- a/drivers/scsi/hpsa.h
+++ b/drivers/scsi/hpsa.h
@@ -90,6 +90,7 @@ struct bmic_controller_parameters {
 	u8   automatic_drive_slamming;
 	u8   reserved1;
 	u8   nvram_flags;
+#define HBA_MODE_ENABLED_FLAG (1 << 3)
 	u8   cache_nvram_flags;
 	u8   drive_config_flags;
 	u16  reserved2;

commit 316b221a37802b6abe26067f2c6f2d7bb79069e5
Author: Stephen M. Cameron <scameron@beardog.cce.hp.com>
Date:   Fri Feb 21 16:25:15 2014 -0600

    [SCSI] hpsa: Add hba mode to the hpsa driver
    
    This allows exposing physical disks behind Smart
    Array controllers to the OS (if the controller
    has the right firmware and is in "hba" mode)
    
    Signed-off-by: Joe Handzik <joseph.t.handzik@hp.com>
    Signed-off-by: Stephen M. Cameron <scameron@beardog.cce.hp.com>
    Signed-off-by: James Bottomley <JBottomley@Parallels.com>

diff --git a/drivers/scsi/hpsa.h b/drivers/scsi/hpsa.h
index ae8c592df8d3..44235a27e1b6 100644
--- a/drivers/scsi/hpsa.h
+++ b/drivers/scsi/hpsa.h
@@ -64,6 +64,46 @@ struct reply_pool {
 	u32 current_entry;
 };
 
+#pragma pack(1)
+struct bmic_controller_parameters {
+	u8   led_flags;
+	u8   enable_command_list_verification;
+	u8   backed_out_write_drives;
+	u16  stripes_for_parity;
+	u8   parity_distribution_mode_flags;
+	u16  max_driver_requests;
+	u16  elevator_trend_count;
+	u8   disable_elevator;
+	u8   force_scan_complete;
+	u8   scsi_transfer_mode;
+	u8   force_narrow;
+	u8   rebuild_priority;
+	u8   expand_priority;
+	u8   host_sdb_asic_fix;
+	u8   pdpi_burst_from_host_disabled;
+	char software_name[64];
+	char hardware_name[32];
+	u8   bridge_revision;
+	u8   snapshot_priority;
+	u32  os_specific;
+	u8   post_prompt_timeout;
+	u8   automatic_drive_slamming;
+	u8   reserved1;
+	u8   nvram_flags;
+	u8   cache_nvram_flags;
+	u8   drive_config_flags;
+	u16  reserved2;
+	u8   temp_warning_level;
+	u8   temp_shutdown_level;
+	u8   temp_condition_reset;
+	u8   max_coalesce_commands;
+	u32  max_coalesce_delay;
+	u8   orca_password[4];
+	u8   access_id[16];
+	u8   reserved[356];
+};
+#pragma pack()
+
 struct ctlr_info {
 	int	ctlr;
 	char	devname[8];
@@ -89,6 +129,7 @@ struct ctlr_info {
 	unsigned int msi_vector;
 	int intr_mode; /* either PERF_MODE_INT or SIMPLE_MODE_INT */
 	struct access_method access;
+	char hba_mode_enabled;
 
 	/* queue and queue Info */
 	struct list_head reqQ;

commit 9846590edadb3c961fed095d6b3c0af947230e69
Author: Stephen M. Cameron <scameron@beardog.cce.hp.com>
Date:   Fri Feb 21 16:25:00 2014 -0600

    [SCSI] hpsa: bring format-in-progress drives online when ready
    
    Do not expose drives that are undergoing a format immediately
    to the OS, instead wait until they are ready before bringing
    them online.  This is so that logical drives created with
    "rapid parity initialization" do not get immediately kicked
    off the system for being unresponsive.
    
    Signed-off-by: Stephen M. Cameron <scameron@beardog.cce.hp.com>
    Signed-off-by: James Bottomley <JBottomley@Parallels.com>

diff --git a/drivers/scsi/hpsa.h b/drivers/scsi/hpsa.h
index c4a81f095e27..ae8c592df8d3 100644
--- a/drivers/scsi/hpsa.h
+++ b/drivers/scsi/hpsa.h
@@ -46,6 +46,7 @@ struct hpsa_scsi_dev_t {
 	unsigned char vendor[8];        /* bytes 8-15 of inquiry data */
 	unsigned char model[16];        /* bytes 16-31 of inquiry data */
 	unsigned char raid_level;	/* from inquiry page 0xC1 */
+	unsigned char volume_offline;	/* discovered via TUR or VPD */
 	u32 ioaccel_handle;
 	int offload_config;		/* I/O accel RAID offload configured */
 	int offload_enabled;		/* I/O accel RAID offload enabled */
@@ -197,10 +198,18 @@ struct ctlr_info {
 		CTLR_STATE_CHANGE_EVENT_REDUNDANT_CNTRL | \
 		CTLR_STATE_CHANGE_EVENT_AIO_ENABLED_DISABLED | \
 		CTLR_STATE_CHANGE_EVENT_AIO_CONFIG_CHANGE)
+	spinlock_t offline_device_lock;
+	struct list_head offline_device_list;
 	int	acciopath_status;
 	int	drv_req_rescan;	/* flag for driver to request rescan event */
 	int	raid_offload_debug;
 };
+
+struct offline_device_entry {
+	unsigned char scsi3addr[8];
+	struct list_head offline_list;
+};
+
 #define HPSA_ABORT_MSG 0
 #define HPSA_DEVICE_RESET_MSG 1
 #define HPSA_RESET_TYPE_CONTROLLER 0x00

commit 2ba8bfc82e120dd68f11135d563bb8b86a4d935b
Author: Stephen M. Cameron <scameron@beardog.cce.hp.com>
Date:   Tue Feb 18 13:57:52 2014 -0600

    [SCSI] hpsa add sysfs debug switch for raid map debugging messages
    
    Signed-off-by: Scott Teel <scott.teel@hp.com>
    Signed-off-by: Stephen M. Cameron <scameron@beardog.cce.hp.com>
    Signed-off-by: James Bottomley <JBottomley@Parallels.com>

diff --git a/drivers/scsi/hpsa.h b/drivers/scsi/hpsa.h
index fe8d281afdae..c4a81f095e27 100644
--- a/drivers/scsi/hpsa.h
+++ b/drivers/scsi/hpsa.h
@@ -199,6 +199,7 @@ struct ctlr_info {
 		CTLR_STATE_CHANGE_EVENT_AIO_CONFIG_CHANGE)
 	int	acciopath_status;
 	int	drv_req_rescan;	/* flag for driver to request rescan event */
+	int	raid_offload_debug;
 };
 #define HPSA_ABORT_MSG 0
 #define HPSA_DEVICE_RESET_MSG 1

commit faff6ee05379ad1e27c6a77706f107734a00705e
Author: Stephen M. Cameron <scameron@beardog.cce.hp.com>
Date:   Tue Feb 18 13:57:42 2014 -0600

    [SCSI] hpsa: only do device rescan for certain events
    
    Do no rescan on every events -- way too many rescans are
    triggered if we don't filter the events.  Limit rescans
    to be triggered by the following set of events:
    
     * controller state change
     * enclosure hot plug
     * physical drive state change
     * logical drive state change
     * redundant controller state change
     * accelerated io enabled/disabled
     * accelerated io configuration change
    
    Signed-off-by: Stephen M. Cameron <scameron@beardog.cce.hp.com>
    Signed-off-by: James Bottomley <JBottomley@Parallels.com>

diff --git a/drivers/scsi/hpsa.h b/drivers/scsi/hpsa.h
index fe813e9aa50c..fe8d281afdae 100644
--- a/drivers/scsi/hpsa.h
+++ b/drivers/scsi/hpsa.h
@@ -181,6 +181,22 @@ struct ctlr_info {
 #define HPSATMF_LOG_QRY_TSET    (1 << 24)
 #define HPSATMF_LOG_QRY_ASYNC   (1 << 25)
 	u32 events;
+#define CTLR_STATE_CHANGE_EVENT				(1 << 0)
+#define CTLR_ENCLOSURE_HOT_PLUG_EVENT			(1 << 1)
+#define CTLR_STATE_CHANGE_EVENT_PHYSICAL_DRV		(1 << 4)
+#define CTLR_STATE_CHANGE_EVENT_LOGICAL_DRV		(1 << 5)
+#define CTLR_STATE_CHANGE_EVENT_REDUNDANT_CNTRL		(1 << 6)
+#define CTLR_STATE_CHANGE_EVENT_AIO_ENABLED_DISABLED	(1 << 30)
+#define CTLR_STATE_CHANGE_EVENT_AIO_CONFIG_CHANGE	(1 << 31)
+
+#define RESCAN_REQUIRED_EVENT_BITS \
+		(CTLR_STATE_CHANGE_EVENT | \
+		CTLR_ENCLOSURE_HOT_PLUG_EVENT | \
+		CTLR_STATE_CHANGE_EVENT_PHYSICAL_DRV | \
+		CTLR_STATE_CHANGE_EVENT_LOGICAL_DRV | \
+		CTLR_STATE_CHANGE_EVENT_REDUNDANT_CNTRL | \
+		CTLR_STATE_CHANGE_EVENT_AIO_ENABLED_DISABLED | \
+		CTLR_STATE_CHANGE_EVENT_AIO_CONFIG_CHANGE)
 	int	acciopath_status;
 	int	drv_req_rescan;	/* flag for driver to request rescan event */
 };

commit 51c35139e1f93f3b33e6598afb972b720d7e898c
Author: Scott Teel <scott.teel@hp.com>
Date:   Tue Feb 18 13:57:26 2014 -0600

    [SCSI] hpsa: update source file copyrights
    
    Signed-off-by: Scott Teel <scott.teel@hp.com>
    Signed-off-by: Stephen M. Cameron <scameron@beardog.cce.hp.com>
    Signed-off-by: James Bottomley <JBottomley@Parallels.com>

diff --git a/drivers/scsi/hpsa.h b/drivers/scsi/hpsa.h
index 2e7521fdc344..fe813e9aa50c 100644
--- a/drivers/scsi/hpsa.h
+++ b/drivers/scsi/hpsa.h
@@ -1,6 +1,6 @@
 /*
  *    Disk Array driver for HP Smart Array SAS controllers
- *    Copyright 2000, 2009 Hewlett-Packard Development Company, L.P.
+ *    Copyright 2000, 2014 Hewlett-Packard Development Company, L.P.
  *
  *    This program is free software; you can redistribute it and/or modify
  *    it under the terms of the GNU General Public License as published by

commit e863d68e4881b080267ea2a6f97dfc658f0ad4fb
Author: Scott Teel <scott.teel@hp.com>
Date:   Tue Feb 18 13:57:05 2014 -0600

    [SCSI] hpsa: rescan devices on ioaccel2 error
    
    Allow driver to schedule a rescan whenever a request fails on the ioaccel2 path.
    This eliminates the possibility of driver getting stuck in non-ioaccel mode.
    
    IOaccel mode (HP SSD Smart Path) is disabled by driver upon error detection.
    Driver relied on idea that request would be retried through normal path, and a
    subsequent error would occur on that path, and be processed by controller
    firmware.  As part of that process, controller disables ioaccel mode and later
    reinstates it, signalling driver to change modes.
    
    In some error cases, the error will not duplicate on the standard path,
    so the driver could get stuck in non-ioaccel mode.
    To avoid that, we allow driver to request a rescan during the next run of the
    rescan thread.
    
    Signed-off-by: Scott Teel <scott.teel@hp.com>
    Signed-off-by: Stephen M. Cameron <scameron@beardog.cce.hp.com>
    Signed-off-by: James Bottomley <JBottomley@Parallels.com>

diff --git a/drivers/scsi/hpsa.h b/drivers/scsi/hpsa.h
index 1d3340dbe310..2e7521fdc344 100644
--- a/drivers/scsi/hpsa.h
+++ b/drivers/scsi/hpsa.h
@@ -182,6 +182,7 @@ struct ctlr_info {
 #define HPSATMF_LOG_QRY_ASYNC   (1 << 25)
 	u32 events;
 	int	acciopath_status;
+	int	drv_req_rescan;	/* flag for driver to request rescan event */
 };
 #define HPSA_ABORT_MSG 0
 #define HPSA_DEVICE_RESET_MSG 1

commit da0697bd3075598f7990002dc46f208d722b6160
Author: Scott Teel <scott.teel@hp.com>
Date:   Tue Feb 18 13:57:00 2014 -0600

    [SCSI] hpsa: allow user to disable accelerated i/o path
    
    Allow SSD Smart Path for a controller to be disabled by
    the user, regardless of settings in controller firmware
    or array configuration.
    
    To disable:     echo 0 > /sys/class/scsi_host/host<id>/acciopath_status
    To re-enable:   echo 1 > /sys/class/scsi_host/host<id>/acciopath_status
    To check state: cat /sys/class/scsi_host/host<id>/acciopath_status
    
    Signed-off-by: Scott Teel <scott.teel@hp.com>
    Signed-off-by: Stephen M. Cameron <scameron@beardog.cce.hp.com>
    Signed-off-by: James Bottomley <JBottomley@Parallels.com>

diff --git a/drivers/scsi/hpsa.h b/drivers/scsi/hpsa.h
index 45bb1ea6835e..1d3340dbe310 100644
--- a/drivers/scsi/hpsa.h
+++ b/drivers/scsi/hpsa.h
@@ -181,6 +181,7 @@ struct ctlr_info {
 #define HPSATMF_LOG_QRY_TSET    (1 << 24)
 #define HPSATMF_LOG_QRY_ASYNC   (1 << 25)
 	u32 events;
+	int	acciopath_status;
 };
 #define HPSA_ABORT_MSG 0
 #define HPSA_DEVICE_RESET_MSG 1

commit c349775e4c53aade9942ef1010b23f84dbaf9ac9
Author: Scott Teel <scott.teel@hp.com>
Date:   Tue Feb 18 13:56:34 2014 -0600

    [SCSI] hpsa: get ioaccel mode 2 i/o working
    
    Signed-off-by: Scott Teel <scott.teel@hp.com>
    Signed-off-by: Joe Handzik <Joseph.T.Handzik@hp.com>
    Signed-off-by: Mike Miller <michael.miller@canonical.com>
    Signed-off-by: Stephen M. Cameron <scameron@beardog.cce.hp.com>
    Signed-off-by: James Bottomley <JBottomley@Parallels.com>

diff --git a/drivers/scsi/hpsa.h b/drivers/scsi/hpsa.h
index 0e14e9bf735a..45bb1ea6835e 100644
--- a/drivers/scsi/hpsa.h
+++ b/drivers/scsi/hpsa.h
@@ -282,6 +282,18 @@ static void SA5_submit_command(struct ctlr_info *h,
 	(void) readl(h->vaddr + SA5_SCRATCHPAD_OFFSET);
 }
 
+static void SA5_submit_command_ioaccel2(struct ctlr_info *h,
+	struct CommandList *c)
+{
+	dev_dbg(&h->pdev->dev, "Sending %x, tag = %x\n", c->busaddr,
+		c->Header.Tag.lower);
+	if (c->cmd_type == CMD_IOACCEL2)
+		writel(c->busaddr, h->vaddr + IOACCEL2_INBOUND_POSTQ_32);
+	else
+		writel(c->busaddr, h->vaddr + SA5_REQUEST_PORT_OFFSET);
+	(void) readl(h->vaddr + SA5_SCRATCHPAD_OFFSET);
+}
+
 /*
  *  This card is the opposite of the other cards.
  *   0 turns interrupts on...
@@ -475,6 +487,14 @@ static struct access_method SA5_ioaccel_mode1_access = {
 	SA5_ioaccel_mode1_completed,
 };
 
+static struct access_method SA5_ioaccel_mode2_access = {
+	SA5_submit_command_ioaccel2,
+	SA5_performant_intr_mask,
+	SA5_fifo_full,
+	SA5_performant_intr_pending,
+	SA5_performant_completed,
+};
+
 static struct access_method SA5_performant_access = {
 	SA5_submit_command,
 	SA5_performant_intr_mask,

commit b9af4937e6f5b55b6ffb2a92ec580e79e1401825
Author: Stephen M. Cameron <scameron@beardog.cce.hp.com>
Date:   Tue Feb 18 13:56:29 2014 -0600

    [SCSI] hpsa: initialize controller to perform io accelerator mode 2
    
    Signed-off-by: Stephen M. Cameron <scameron@beardog.cce.hp.com>
    Signed-off-by: Scott Teel <scott.teel@hp.com>
    Signed-off-by: James Bottomley <JBottomley@Parallels.com>

diff --git a/drivers/scsi/hpsa.h b/drivers/scsi/hpsa.h
index 2a4a0cb4f034..0e14e9bf735a 100644
--- a/drivers/scsi/hpsa.h
+++ b/drivers/scsi/hpsa.h
@@ -142,6 +142,7 @@ struct ctlr_info {
 	u32 *blockFetchTable;
 	u32 *ioaccel1_blockFetchTable;
 	u32 *ioaccel2_blockFetchTable;
+	u32 *ioaccel2_bft2_regs;
 	unsigned char *hba_inquiry_data;
 	u32 driver_support;
 	u32 fw_support;

commit aca9012a41fbc5b3697c14b34c964daabab6e740
Author: Stephen M. Cameron <scameron@beardog.cce.hp.com>
Date:   Tue Feb 18 13:56:14 2014 -0600

    [SCSI] hpsa: do ioaccel mode 2 resource allocations
    
    Signed-off-by: Mike Miller <michael.miller@canonical.com>
    Signed-off-by: Stephen M. Cameron <scameron@beardog.cce.hp.com>
    Signed-off-by: James Bottomley <JBottomley@Parallels.com>

diff --git a/drivers/scsi/hpsa.h b/drivers/scsi/hpsa.h
index 74eb22af4506..2a4a0cb4f034 100644
--- a/drivers/scsi/hpsa.h
+++ b/drivers/scsi/hpsa.h
@@ -105,6 +105,8 @@ struct ctlr_info {
 	dma_addr_t		cmd_pool_dhandle;
 	struct io_accel1_cmd	*ioaccel_cmd_pool;
 	dma_addr_t		ioaccel_cmd_pool_dhandle;
+	struct io_accel2_cmd	*ioaccel2_cmd_pool;
+	dma_addr_t		ioaccel2_cmd_pool_dhandle;
 	struct ErrorInfo 	*errinfo_pool;
 	dma_addr_t		errinfo_pool_dhandle;
 	unsigned long  		*cmd_pool_bits;
@@ -139,6 +141,7 @@ struct ctlr_info {
 	dma_addr_t reply_pool_dhandle;
 	u32 *blockFetchTable;
 	u32 *ioaccel1_blockFetchTable;
+	u32 *ioaccel2_blockFetchTable;
 	unsigned char *hba_inquiry_data;
 	u32 driver_support;
 	u32 fw_support;

commit b66cc250ee700ba019ae6801726588b8bf6d9144
Author: Mike Miller <mikem@beardog.cce.hp.com>
Date:   Tue Feb 18 13:56:04 2014 -0600

    [SCSI] hpsa: add ioaccel mode 2 structure definitions
    
    Signed-off-by: Mike Miller <michael.miller@canonical.com>
    Signed-off-by: Stephen M. Cameron <scameron@beardog.cce.hp.com>
    Signed-off-by: James Bottomley <JBottomley@Parallels.com>

diff --git a/drivers/scsi/hpsa.h b/drivers/scsi/hpsa.h
index df2f88df10be..74eb22af4506 100644
--- a/drivers/scsi/hpsa.h
+++ b/drivers/scsi/hpsa.h
@@ -258,6 +258,14 @@ struct ctlr_info {
 
 #define HPSA_INTR_ON 	1
 #define HPSA_INTR_OFF	0
+
+/*
+ * Inbound Post Queue offsets for IO Accelerator Mode 2
+ */
+#define IOACCEL2_INBOUND_POSTQ_32	0x48
+#define IOACCEL2_INBOUND_POSTQ_64_LOW	0xd0
+#define IOACCEL2_INBOUND_POSTQ_64_HI	0xd4
+
 /*
 	Send the command to the hardware
 */

commit 76438d087f18fc0ce0431bf22e5195ec3db1656c
Author: Stephen M. Cameron <scameron@beardog.cce.hp.com>
Date:   Tue Feb 18 13:55:43 2014 -0600

    [SCSI] hpsa: poll controller to detect device change event
    
    For shared SAS configurations, hosts need to poll Smart Arrays
    periodically in order to be able to detect configuration changes
    such as logical drives being added or removed from remote hosts.
    A register on the controller indicates when such events have
    occurred, and the driver polls the register via a workqueue
    and kicks off a rescan of devices if such an event is detected.
    Additionally, changes to logical drive raid offload eligibility
    are autodetected in this way.
    
    Signed-off-by: Stephen M. Cameron <scameron@beardog.cce.hp.com>
    Signed-off-by: Scott Teel <scott.teel@hp.com>
    Signed-off-by: James Bottomley <JBottomley@Parallels.com>

diff --git a/drivers/scsi/hpsa.h b/drivers/scsi/hpsa.h
index ae08f1c46272..df2f88df10be 100644
--- a/drivers/scsi/hpsa.h
+++ b/drivers/scsi/hpsa.h
@@ -176,6 +176,7 @@ struct ctlr_info {
 #define HPSATMF_LOG_QRY_TASK    (1 << 23)
 #define HPSATMF_LOG_QRY_TSET    (1 << 24)
 #define HPSATMF_LOG_QRY_ASYNC   (1 << 25)
+	u32 events;
 };
 #define HPSA_ABORT_MSG 0
 #define HPSA_DEVICE_RESET_MSG 1

commit 283b4a9b98b192ebc0e15351fd6fb60e1be78c5d
Author: Stephen M. Cameron <scameron@beardog.cce.hp.com>
Date:   Tue Feb 18 13:55:33 2014 -0600

    [SCSI] hpsa: add ioaccell mode 1 RAID offload support.
    
    This enables sending i/o's destined for RAID logical drives
    which can be serviced by a single physical disk down a different,
    faster i/o path directly to physical drives for certain logical
    volumes on SSDs bypassing the Smart Array RAID stack for a
    performance improvement.
    
    Signed-off-by: Matt Gates <matthew.gates@hp.com>
    Signed-off-by: Stephen M. Cameron <scameron@beardog.cce.hp.com>
    Signed-off-by: Scott Teel <scott.teel@hp.com>
    Signed-off-by: Mike Miller <michael.miller@canonical.com>
    Signed-off-by: Don Brace <brace@beardog.cce.hp.com>
    Signed-off-by: Joe Handzik <joseph.t.handzik@hp.com>
    Signed-off-by: James Bottomley <JBottomley@Parallels.com>

diff --git a/drivers/scsi/hpsa.h b/drivers/scsi/hpsa.h
index c7865f30ffd1..ae08f1c46272 100644
--- a/drivers/scsi/hpsa.h
+++ b/drivers/scsi/hpsa.h
@@ -47,6 +47,13 @@ struct hpsa_scsi_dev_t {
 	unsigned char model[16];        /* bytes 16-31 of inquiry data */
 	unsigned char raid_level;	/* from inquiry page 0xC1 */
 	u32 ioaccel_handle;
+	int offload_config;		/* I/O accel RAID offload configured */
+	int offload_enabled;		/* I/O accel RAID offload enabled */
+	int offload_to_mirror;		/* Send next I/O accelerator RAID
+					 * offload request to mirror drive
+					 */
+	struct raid_map_data raid_map;	/* I/O accelerator RAID map */
+
 };
 
 struct reply_pool {
@@ -133,6 +140,10 @@ struct ctlr_info {
 	u32 *blockFetchTable;
 	u32 *ioaccel1_blockFetchTable;
 	unsigned char *hba_inquiry_data;
+	u32 driver_support;
+	u32 fw_support;
+	int ioaccel_support;
+	int ioaccel_maxsg;
 	u64 last_intr_timestamp;
 	u32 last_heartbeat;
 	u64 last_heartbeat_timestamp;
@@ -406,8 +417,7 @@ static bool SA5_ioaccel_mode1_intr_pending(struct ctlr_info *h)
 #define IOACCEL_MODE1_CONSUMER_INDEX     0x1BC
 #define IOACCEL_MODE1_REPLY_UNUSED       0xFFFFFFFFFFFFFFFFULL
 
-static unsigned long SA5_ioaccel_mode1_completed(struct ctlr_info *h,
-							u8 q)
+static unsigned long SA5_ioaccel_mode1_completed(struct ctlr_info *h, u8 q)
 {
 	u64 register_value;
 	struct reply_pool *rq = &h->reply_queue[q];
@@ -420,12 +430,18 @@ static unsigned long SA5_ioaccel_mode1_completed(struct ctlr_info *h,
 		rq->head[rq->current_entry] = IOACCEL_MODE1_REPLY_UNUSED;
 		if (++rq->current_entry == rq->size)
 			rq->current_entry = 0;
+		/*
+		 * @todo
+		 *
+		 * Don't really need to write the new index after each command,
+		 * but with current driver design this is easiest.
+		 */
+		wmb();
+		writel((q << 24) | rq->current_entry, h->vaddr +
+				IOACCEL_MODE1_CONSUMER_INDEX);
 		spin_lock_irqsave(&h->lock, flags);
 		h->commands_outstanding--;
 		spin_unlock_irqrestore(&h->lock, flags);
-	} else {
-		writel((q << 24) | rq->current_entry,
-			h->vaddr + IOACCEL_MODE1_CONSUMER_INDEX);
 	}
 	return (unsigned long) register_value;
 }

commit e1f7de0cdd68d246d7008241cd9e443a54f880a8
Author: Matt Gates <matthew.gates@hp.com>
Date:   Tue Feb 18 13:55:17 2014 -0600

    [SCSI] hpsa: add support for 'fastpath' i/o
    
    For certain i/o's to certain devices (unmasked physical disks) we
    can bypass the RAID stack firmware and do the i/o to the device
    directly and it will be faster.
    
    Signed-off-by: Matt Gates <matthew.gates@hp.com>
    Signed-off-by: Stephen M. Cameron <scameron@beardog.cce.hp.com>
    Signed-off-by: James Bottomley <JBottomley@Parallels.com>

diff --git a/drivers/scsi/hpsa.h b/drivers/scsi/hpsa.h
index 01c328349c83..c7865f30ffd1 100644
--- a/drivers/scsi/hpsa.h
+++ b/drivers/scsi/hpsa.h
@@ -46,6 +46,7 @@ struct hpsa_scsi_dev_t {
 	unsigned char vendor[8];        /* bytes 8-15 of inquiry data */
 	unsigned char model[16];        /* bytes 16-31 of inquiry data */
 	unsigned char raid_level;	/* from inquiry page 0xC1 */
+	u32 ioaccel_handle;
 };
 
 struct reply_pool {
@@ -95,6 +96,8 @@ struct ctlr_info {
 	/* pointers to command and error info pool */
 	struct CommandList 	*cmd_pool;
 	dma_addr_t		cmd_pool_dhandle;
+	struct io_accel1_cmd	*ioaccel_cmd_pool;
+	dma_addr_t		ioaccel_cmd_pool_dhandle;
 	struct ErrorInfo 	*errinfo_pool;
 	dma_addr_t		errinfo_pool_dhandle;
 	unsigned long  		*cmd_pool_bits;
@@ -128,6 +131,7 @@ struct ctlr_info {
 	u8 nreply_queues;
 	dma_addr_t reply_pool_dhandle;
 	u32 *blockFetchTable;
+	u32 *ioaccel1_blockFetchTable;
 	unsigned char *hba_inquiry_data;
 	u64 last_intr_timestamp;
 	u32 last_heartbeat;
@@ -387,6 +391,45 @@ static bool SA5_performant_intr_pending(struct ctlr_info *h)
 	return register_value & SA5_OUTDB_STATUS_PERF_BIT;
 }
 
+#define SA5_IOACCEL_MODE1_INTR_STATUS_CMP_BIT    0x100
+
+static bool SA5_ioaccel_mode1_intr_pending(struct ctlr_info *h)
+{
+	unsigned long register_value = readl(h->vaddr + SA5_INTR_STATUS);
+
+	return (register_value & SA5_IOACCEL_MODE1_INTR_STATUS_CMP_BIT) ?
+		true : false;
+}
+
+#define IOACCEL_MODE1_REPLY_QUEUE_INDEX  0x1A0
+#define IOACCEL_MODE1_PRODUCER_INDEX     0x1B8
+#define IOACCEL_MODE1_CONSUMER_INDEX     0x1BC
+#define IOACCEL_MODE1_REPLY_UNUSED       0xFFFFFFFFFFFFFFFFULL
+
+static unsigned long SA5_ioaccel_mode1_completed(struct ctlr_info *h,
+							u8 q)
+{
+	u64 register_value;
+	struct reply_pool *rq = &h->reply_queue[q];
+	unsigned long flags;
+
+	BUG_ON(q >= h->nreply_queues);
+
+	register_value = rq->head[rq->current_entry];
+	if (register_value != IOACCEL_MODE1_REPLY_UNUSED) {
+		rq->head[rq->current_entry] = IOACCEL_MODE1_REPLY_UNUSED;
+		if (++rq->current_entry == rq->size)
+			rq->current_entry = 0;
+		spin_lock_irqsave(&h->lock, flags);
+		h->commands_outstanding--;
+		spin_unlock_irqrestore(&h->lock, flags);
+	} else {
+		writel((q << 24) | rq->current_entry,
+			h->vaddr + IOACCEL_MODE1_CONSUMER_INDEX);
+	}
+	return (unsigned long) register_value;
+}
+
 static struct access_method SA5_access = {
 	SA5_submit_command,
 	SA5_intr_mask,
@@ -395,6 +438,14 @@ static struct access_method SA5_access = {
 	SA5_completed,
 };
 
+static struct access_method SA5_ioaccel_mode1_access = {
+	SA5_submit_command,
+	SA5_performant_intr_mask,
+	SA5_fifo_full,
+	SA5_ioaccel_mode1_intr_pending,
+	SA5_ioaccel_mode1_completed,
+};
+
 static struct access_method SA5_performant_access = {
 	SA5_submit_command,
 	SA5_performant_intr_mask,

commit 8a98db7386b5fed82dc1df25c904b6d0ae32a2cb
Author: Stephen M. Cameron <scameron@beardog.cce.hp.com>
Date:   Wed Dec 4 17:10:07 2013 -0600

    [SCSI] hpsa: use workqueue instead of kernel thread for lockup detection
    
    Much simpler and avoids races starting/stopping the thread.
    
    Signed-off-by: Stephen M. Cameron <scameron@beardog.cce.hp.com>
    Signed-off-by: James Bottomley <JBottomley@Parallels.com>

diff --git a/drivers/scsi/hpsa.h b/drivers/scsi/hpsa.h
index 5f3f72f90bc9..01c328349c83 100644
--- a/drivers/scsi/hpsa.h
+++ b/drivers/scsi/hpsa.h
@@ -135,7 +135,8 @@ struct ctlr_info {
 	u32 heartbeat_sample_interval;
 	atomic_t firmware_flash_in_progress;
 	u32 lockup_detected;
-	struct list_head lockup_list;
+	struct delayed_work monitor_ctlr_work;
+	int remove_in_progress;
 	u32 fifo_recently_full;
 	/* Address of h->q[x] is passed to intr handler to know which queue */
 	u8 q[MAX_REPLY_QUEUES];

commit 396883e292ebe1e14ded99fd8b26be500926f055
Author: Stephen M. Cameron <scameron@beardog.cce.hp.com>
Date:   Mon Sep 23 13:34:17 2013 -0500

    [SCSI] hpsa: prevent stalled i/o
    
    If a fifo full condition is encountered, i/o requests will stack
    up in the h->reqQ queue.  The only thing which empties this queue
    is start_io, which only gets called when new i/o requests come in.
    If none are forthcoming, i/o in h->reqQ will be stalled.
    
    To fix this, whenever fifo full condition is encountered, this
    is recorded, and the interrupt handler examines this to see
    if a fifo full condition was recently encountered when a
    command completes and will call start_io to prevent i/o's in
    h->reqQ from getting stuck.
    
    I've only ever seen this problem occur when running specialized
    test programs that pound on the the CCISS_PASSTHRU ioctl.
    
    Signed-off-by: Stephen M. Cameron <scameron@beardog.cce.hp.com>
    Signed-off-by: James Bottomley <JBottomley@Parallels.com>

diff --git a/drivers/scsi/hpsa.h b/drivers/scsi/hpsa.h
index 6eabf08ca672..5f3f72f90bc9 100644
--- a/drivers/scsi/hpsa.h
+++ b/drivers/scsi/hpsa.h
@@ -136,6 +136,7 @@ struct ctlr_info {
 	atomic_t firmware_flash_in_progress;
 	u32 lockup_detected;
 	struct list_head lockup_list;
+	u32 fifo_recently_full;
 	/* Address of h->q[x] is passed to intr handler to know which queue */
 	u8 q[MAX_REPLY_QUEUES];
 	u32 TMFSupportFlags; /* cache what task mgmt funcs are supported. */

commit 0390f0c0dfb540149d7369276b17ec53caf506cb
Author: Stephen M. Cameron <scameron@beardog.cce.hp.com>
Date:   Mon Sep 23 13:34:12 2013 -0500

    [SCSI] hpsa: cap CCISS_PASSTHRU at 20 concurrent commands.
    
    Cap CCISS_BIG_PASSTHRU as well.  If an attempt is made
    to exceed this, ioctl() will return -1 with errno == EAGAIN.
    
    This is to prevent a userland program from exhausting all of
    pci_alloc_consistent memory.  I've only seen this problem when
    running a special test program designed to provoke it.  20
    concurrent commands via the passthru ioctls (not counting SG_IO)
    should be more than enough.
    
    Signed-off-by: Stephen M. Cameron <scameron@beardog.cce.hp.com>
    Signed-off-by: James Bottomley <JBottomley@Parallels.com>

diff --git a/drivers/scsi/hpsa.h b/drivers/scsi/hpsa.h
index bc85e7244f40..6eabf08ca672 100644
--- a/drivers/scsi/hpsa.h
+++ b/drivers/scsi/hpsa.h
@@ -114,6 +114,11 @@ struct ctlr_info {
 	struct TransTable_struct *transtable;
 	unsigned long transMethod;
 
+	/* cap concurrent passthrus at some reasonable maximum */
+#define HPSA_MAX_CONCURRENT_PASSTHRUS (20)
+	spinlock_t passthru_count_lock; /* protects passthru_count */
+	int passthru_count;
+
 	/*
 	 * Performant mode completion buffers
 	 */

commit 1cdd3cf838a23290d0468b03981caf84bce8740c
Author: Tomas Henzl <thenzl@redhat.com>
Date:   Thu Aug 1 15:14:52 2013 +0200

    [SCSI] hpsa: remove unneeded variable
    
    Signed-off-by: Tomas Henzl <thenzl@redhat.com>
    Acked-by: Stephen M. Cameron <scameron@beardog.cce.hp.com>
    Signed-off-by: James Bottomley <JBottomley@Parallels.com>

diff --git a/drivers/scsi/hpsa.h b/drivers/scsi/hpsa.h
index 981647989bfd..bc85e7244f40 100644
--- a/drivers/scsi/hpsa.h
+++ b/drivers/scsi/hpsa.h
@@ -98,8 +98,6 @@ struct ctlr_info {
 	struct ErrorInfo 	*errinfo_pool;
 	dma_addr_t		errinfo_pool_dhandle;
 	unsigned long  		*cmd_pool_bits;
-	int			nr_allocs;
-	int			nr_frees;
 	int			scan_finished;
 	spinlock_t		scan_lock;
 	wait_queue_head_t	scan_wait_queue;

commit e85c59746957fd6e3595d02cf614370056b5816e
Author: Stephen M. Cameron <scameron@beardog.cce.hp.com>
Date:   Tue May 1 11:43:42 2012 -0500

    [SCSI] hpsa: dial down lockup detection during firmware flash
    
    Dial back the aggressiveness of the controller lockup detection thread.
    Currently it will declare the controller to be locked up if it goes
    for 10 seconds with no interrupts and no change in the heartbeat
    register.  Dial back this to 30 seconds with no heartbeat change, and
    also snoop the ioctl path and if a firmware flash command is detected,
    dial it back further to 4 minutes until the firmware flash command
    completes.  The reason for this is that during the firmware flash
    operation, the controller apparently doesn't update the heartbeat
    register as frequently as it is supposed to, and we can get a false
    positive.
    
    Signed-off-by: Stephen M. Cameron <scameron@beardog.cce.hp.com>
    Signed-off-by: James Bottomley <JBottomley@Parallels.com>

diff --git a/drivers/scsi/hpsa.h b/drivers/scsi/hpsa.h
index fb51ef7d48cc..981647989bfd 100644
--- a/drivers/scsi/hpsa.h
+++ b/drivers/scsi/hpsa.h
@@ -129,6 +129,8 @@ struct ctlr_info {
 	u64 last_intr_timestamp;
 	u32 last_heartbeat;
 	u64 last_heartbeat_timestamp;
+	u32 heartbeat_sample_interval;
+	atomic_t firmware_flash_in_progress;
 	u32 lockup_detected;
 	struct list_head lockup_list;
 	/* Address of h->q[x] is passed to intr handler to know which queue */

commit 21334ea9086c31db38e76152a1e31001a0ed288a
Author: Stephen M. Cameron <scameron@beardog.cce.hp.com>
Date:   Tue May 1 11:43:37 2012 -0500

    [SCSI] hpsa: removed unused member maxQsinceinit
    
    Signed-off-by: Stephen M. Cameron <scameron@beardog.cce.hp.com>
    Signed-off-by: James Bottomley <JBottomley@Parallels.com>

diff --git a/drivers/scsi/hpsa.h b/drivers/scsi/hpsa.h
index 79c36aaa2a37..fb51ef7d48cc 100644
--- a/drivers/scsi/hpsa.h
+++ b/drivers/scsi/hpsa.h
@@ -85,7 +85,6 @@ struct ctlr_info {
 	struct list_head reqQ;
 	struct list_head cmpQ;
 	unsigned int Qdepth;
-	unsigned int maxQsinceinit;
 	unsigned int maxSG;
 	spinlock_t lock;
 	int maxsgentries;

commit e16a33adc0e59aa96a483fd2923d77e674f013c1
Author: Matt Gates <matthew.gates@hp.com>
Date:   Tue May 1 11:43:11 2012 -0500

    [SCSI] hpsa: refine interrupt handler locking for greater concurrency
    
    Use spinlocks with finer granularity in the submission and
    completion paths to allow concurrent execution for multiple
    reply queues.  In particular, do not hold a spin lock while
    submitting a request to the device, nor during most of the
    interrupt handler.
    
    Signed-off-by: Matt Gates <matthew.gates@hp.com>
    Signed-off-by: Stephen M. Cameron <scameron@beardog.cce.hp.com>
    Signed-off-by: James Bottomley <JBottomley@Parallels.com>

diff --git a/drivers/scsi/hpsa.h b/drivers/scsi/hpsa.h
index 486a7c099246..79c36aaa2a37 100644
--- a/drivers/scsi/hpsa.h
+++ b/drivers/scsi/hpsa.h
@@ -246,9 +246,6 @@ static void SA5_submit_command(struct ctlr_info *h,
 		c->Header.Tag.lower);
 	writel(c->busaddr, h->vaddr + SA5_REQUEST_PORT_OFFSET);
 	(void) readl(h->vaddr + SA5_SCRATCHPAD_OFFSET);
-	h->commands_outstanding++;
-	if (h->commands_outstanding > h->max_outstanding)
-		h->max_outstanding = h->commands_outstanding;
 }
 
 /*
@@ -287,7 +284,7 @@ static void SA5_performant_intr_mask(struct ctlr_info *h, unsigned long val)
 static unsigned long SA5_performant_completed(struct ctlr_info *h, u8 q)
 {
 	struct reply_pool *rq = &h->reply_queue[q];
-	unsigned long register_value = FIFO_EMPTY;
+	unsigned long flags, register_value = FIFO_EMPTY;
 
 	/* msi auto clears the interrupt pending bit. */
 	if (!(h->msi_vector || h->msix_vector)) {
@@ -305,7 +302,9 @@ static unsigned long SA5_performant_completed(struct ctlr_info *h, u8 q)
 	if ((rq->head[rq->current_entry] & 1) == rq->wraparound) {
 		register_value = rq->head[rq->current_entry];
 		rq->current_entry++;
+		spin_lock_irqsave(&h->lock, flags);
 		h->commands_outstanding--;
+		spin_unlock_irqrestore(&h->lock, flags);
 	} else {
 		register_value = FIFO_EMPTY;
 	}
@@ -338,9 +337,13 @@ static unsigned long SA5_completed(struct ctlr_info *h,
 {
 	unsigned long register_value
 		= readl(h->vaddr + SA5_REPLY_PORT_OFFSET);
+	unsigned long flags;
 
-	if (register_value != FIFO_EMPTY)
+	if (register_value != FIFO_EMPTY) {
+		spin_lock_irqsave(&h->lock, flags);
 		h->commands_outstanding--;
+		spin_unlock_irqrestore(&h->lock, flags);
+	}
 
 #ifdef HPSA_DEBUG
 	if (register_value != FIFO_EMPTY)

commit 254f796b9f22b1944c64caabc356a56caaa2facd
Author: Matt Gates <matthew.gates@hp.com>
Date:   Tue May 1 11:43:06 2012 -0500

    [SCSI] hpsa: use multiple reply queues
    
    Smart Arrays can support multiple reply queues onto which command
    completions may be deposited.  It can help performance quite a bit
    to arrange for command completions to be processed on the same CPU
    from which they were submitted to increase the likelihood of cache
    hits.
    
    Signed-off-by: Matt Gates <matthew.gates@hp.com>
    Signed-off-by: Stephen M. Cameron <scameron@beardog.cce.hp.com>
    Signed-off-by: James Bottomley <JBottomley@Parallels.com>

diff --git a/drivers/scsi/hpsa.h b/drivers/scsi/hpsa.h
index d8aa95c43f4d..486a7c099246 100644
--- a/drivers/scsi/hpsa.h
+++ b/drivers/scsi/hpsa.h
@@ -34,7 +34,7 @@ struct access_method {
 	void (*set_intr_mask)(struct ctlr_info *h, unsigned long val);
 	unsigned long (*fifo_full)(struct ctlr_info *h);
 	bool (*intr_pending)(struct ctlr_info *h);
-	unsigned long (*command_completed)(struct ctlr_info *h);
+	unsigned long (*command_completed)(struct ctlr_info *h, u8 q);
 };
 
 struct hpsa_scsi_dev_t {
@@ -48,6 +48,13 @@ struct hpsa_scsi_dev_t {
 	unsigned char raid_level;	/* from inquiry page 0xC1 */
 };
 
+struct reply_pool {
+	u64 *head;
+	size_t size;
+	u8 wraparound;
+	u32 current_entry;
+};
+
 struct ctlr_info {
 	int	ctlr;
 	char	devname[8];
@@ -68,7 +75,7 @@ struct ctlr_info {
 #	define DOORBELL_INT	1
 #	define SIMPLE_MODE_INT	2
 #	define MEMQ_MODE_INT	3
-	unsigned int intr[4];
+	unsigned int intr[MAX_REPLY_QUEUES];
 	unsigned int msix_vector;
 	unsigned int msi_vector;
 	int intr_mode; /* either PERF_MODE_INT or SIMPLE_MODE_INT */
@@ -111,13 +118,13 @@ struct ctlr_info {
 	unsigned long transMethod;
 
 	/*
-	 * Performant mode completion buffer
+	 * Performant mode completion buffers
 	 */
 	u64 *reply_pool;
-	dma_addr_t reply_pool_dhandle;
-	u64 *reply_pool_head;
 	size_t reply_pool_size;
-	unsigned char reply_pool_wraparound;
+	struct reply_pool reply_queue[MAX_REPLY_QUEUES];
+	u8 nreply_queues;
+	dma_addr_t reply_pool_dhandle;
 	u32 *blockFetchTable;
 	unsigned char *hba_inquiry_data;
 	u64 last_intr_timestamp;
@@ -125,6 +132,8 @@ struct ctlr_info {
 	u64 last_heartbeat_timestamp;
 	u32 lockup_detected;
 	struct list_head lockup_list;
+	/* Address of h->q[x] is passed to intr handler to know which queue */
+	u8 q[MAX_REPLY_QUEUES];
 	u32 TMFSupportFlags; /* cache what task mgmt funcs are supported. */
 #define HPSATMF_BITS_SUPPORTED  (1 << 0)
 #define HPSATMF_PHYS_LUN_RESET  (1 << 1)
@@ -275,8 +284,9 @@ static void SA5_performant_intr_mask(struct ctlr_info *h, unsigned long val)
 	}
 }
 
-static unsigned long SA5_performant_completed(struct ctlr_info *h)
+static unsigned long SA5_performant_completed(struct ctlr_info *h, u8 q)
 {
+	struct reply_pool *rq = &h->reply_queue[q];
 	unsigned long register_value = FIFO_EMPTY;
 
 	/* msi auto clears the interrupt pending bit. */
@@ -292,19 +302,18 @@ static unsigned long SA5_performant_completed(struct ctlr_info *h)
 		register_value = readl(h->vaddr + SA5_OUTDB_STATUS);
 	}
 
-	if ((*(h->reply_pool_head) & 1) == (h->reply_pool_wraparound)) {
-		register_value = *(h->reply_pool_head);
-		(h->reply_pool_head)++;
+	if ((rq->head[rq->current_entry] & 1) == rq->wraparound) {
+		register_value = rq->head[rq->current_entry];
+		rq->current_entry++;
 		h->commands_outstanding--;
 	} else {
 		register_value = FIFO_EMPTY;
 	}
 	/* Check for wraparound */
-	if (h->reply_pool_head == (h->reply_pool + h->max_commands)) {
-		h->reply_pool_head = h->reply_pool;
-		h->reply_pool_wraparound ^= 1;
+	if (rq->current_entry == h->max_commands) {
+		rq->current_entry = 0;
+		rq->wraparound ^= 1;
 	}
-
 	return register_value;
 }
 
@@ -324,7 +333,8 @@ static unsigned long SA5_fifo_full(struct ctlr_info *h)
  *   returns value read from hardware.
  *     returns FIFO_EMPTY if there is nothing to read
  */
-static unsigned long SA5_completed(struct ctlr_info *h)
+static unsigned long SA5_completed(struct ctlr_info *h,
+	__attribute__((unused)) u8 q)
 {
 	unsigned long register_value
 		= readl(h->vaddr + SA5_REPLY_PORT_OFFSET);

commit 75167d2cc7654f57b90497fe90b1f0ae946c22a6
Author: Stephen M. Cameron <scameron@beardog.cce.hp.com>
Date:   Tue May 1 11:42:51 2012 -0500

    [SCSI] hpsa: add abort error handler function
    
    Signed-off-by: Stephen M. Cameron <scameron@beardog.cce.hp.com>
    Signed-off-by: James Bottomley <JBottomley@Parallels.com>

diff --git a/drivers/scsi/hpsa.h b/drivers/scsi/hpsa.h
index 48f78123d1e6..d8aa95c43f4d 100644
--- a/drivers/scsi/hpsa.h
+++ b/drivers/scsi/hpsa.h
@@ -125,6 +125,27 @@ struct ctlr_info {
 	u64 last_heartbeat_timestamp;
 	u32 lockup_detected;
 	struct list_head lockup_list;
+	u32 TMFSupportFlags; /* cache what task mgmt funcs are supported. */
+#define HPSATMF_BITS_SUPPORTED  (1 << 0)
+#define HPSATMF_PHYS_LUN_RESET  (1 << 1)
+#define HPSATMF_PHYS_NEX_RESET  (1 << 2)
+#define HPSATMF_PHYS_TASK_ABORT (1 << 3)
+#define HPSATMF_PHYS_TSET_ABORT (1 << 4)
+#define HPSATMF_PHYS_CLEAR_ACA  (1 << 5)
+#define HPSATMF_PHYS_CLEAR_TSET (1 << 6)
+#define HPSATMF_PHYS_QRY_TASK   (1 << 7)
+#define HPSATMF_PHYS_QRY_TSET   (1 << 8)
+#define HPSATMF_PHYS_QRY_ASYNC  (1 << 9)
+#define HPSATMF_MASK_SUPPORTED  (1 << 16)
+#define HPSATMF_LOG_LUN_RESET   (1 << 17)
+#define HPSATMF_LOG_NEX_RESET   (1 << 18)
+#define HPSATMF_LOG_TASK_ABORT  (1 << 19)
+#define HPSATMF_LOG_TSET_ABORT  (1 << 20)
+#define HPSATMF_LOG_CLEAR_ACA   (1 << 21)
+#define HPSATMF_LOG_CLEAR_TSET  (1 << 22)
+#define HPSATMF_LOG_QRY_TASK    (1 << 23)
+#define HPSATMF_LOG_QRY_TSET    (1 << 24)
+#define HPSATMF_LOG_QRY_ASYNC   (1 << 25)
 };
 #define HPSA_ABORT_MSG 0
 #define HPSA_DEVICE_RESET_MSG 1

commit 2c17d2da8c9ef2c5be5077d3995041791e38094d
Author: Stephen M. Cameron <scameron@beardog.cce.hp.com>
Date:   Tue May 1 11:42:30 2012 -0500

    [SCSI] hpsa: do not read from controller unnecessarily in completion code
    
    MSI/MSI-X interrupts can't race the DMA completion they are communicating
    so no need to read from controller to flush the DMA to the host if
    MSI or MSI-X interrupts are being used.
    
    Signed-off-by: Stephen M. Cameron <scameron@beardog.cce.hp.com>
    Signed-off-by: James Bottomley <JBottomley@Parallels.com>

diff --git a/drivers/scsi/hpsa.h b/drivers/scsi/hpsa.h
index 7b28d54fa878..48f78123d1e6 100644
--- a/drivers/scsi/hpsa.h
+++ b/drivers/scsi/hpsa.h
@@ -258,12 +258,12 @@ static unsigned long SA5_performant_completed(struct ctlr_info *h)
 {
 	unsigned long register_value = FIFO_EMPTY;
 
-	/* flush the controller write of the reply queue by reading
-	 * outbound doorbell status register.
-	 */
-	register_value = readl(h->vaddr + SA5_OUTDB_STATUS);
 	/* msi auto clears the interrupt pending bit. */
 	if (!(h->msi_vector || h->msix_vector)) {
+		/* flush the controller write of the reply queue by reading
+		 * outbound doorbell status register.
+		 */
+		register_value = readl(h->vaddr + SA5_OUTDB_STATUS);
 		writel(SA5_OUTDB_CLEAR_PERF_BIT, h->vaddr + SA5_OUTDB_CLEAR);
 		/* Do a read in order to flush the write to the controller
 		 * (as per spec.)

commit f79cfec6b1906ab10ef70dccd601db25c97bae17
Author: Stephen M. Cameron <scameron@beardog.cce.hp.com>
Date:   Thu Jan 19 14:00:59 2012 -0600

    [SCSI] hpsa: factor out driver name
    
    Sometimes, for testing purposes (e.g. testing rmmod on a system
    that normally boots using hpsa) it's nice to rename the driver
    and split it into two drivers and restrict it to certain
    controllers.  This makes that easier.
    
    Signed-off-by: Stephen M. Cameron <scameron@beardog.cce.hp.com>
    Signed-off-by: James Bottomley <JBottomley@Parallels.com>

diff --git a/drivers/scsi/hpsa.h b/drivers/scsi/hpsa.h
index b4b97ebcb47a..7b28d54fa878 100644
--- a/drivers/scsi/hpsa.h
+++ b/drivers/scsi/hpsa.h
@@ -316,7 +316,7 @@ static unsigned long SA5_completed(struct ctlr_info *h)
 		dev_dbg(&h->pdev->dev, "Read %lx back from board\n",
 			register_value);
 	else
-		dev_dbg(&h->pdev->dev, "hpsa: FIFO Empty read\n");
+		dev_dbg(&h->pdev->dev, "FIFO Empty read\n");
 #endif
 
 	return register_value;

commit d66ae08bad182e9a87859e120e61cfd51e402ed8
Author: Stephen M. Cameron <scameron@beardog.cce.hp.com>
Date:   Thu Jan 19 14:00:48 2012 -0600

    [SCSI] hpsa: removed unneeded structure member max_sg_entries and fix badly named constant MAXSGENTRIES
    
    We had both h->max_sg_entries and h->maxsgentries in the per controller
    structure which is terribly confusing.  max_sg_entries was really
    just a constant, 32, which defines how big the "block fetch table"
    is, which is as large as the max number of SG elements embedded
    within a command (excluding SG elements in chain blocks).
    
    MAXSGENTRIES was the constant used to denote the max number of SG
    elements embedded within a command, also a poor name.
    
    So renamed MAXSGENTREIS to SG_ENTRIES_IN_CMD, and removed
    h->max_sg_entries and replaced it with SG_ENTRIES_IN_CMD.
    
    h->maxsgentries is unchanged, and is the maximum number of sg
    elements the controller will support in a command, including
    those in chain blocks, minus 1 for the chain block pointer..
    
    Signed-off-by: Stephen M. Cameron <scameron@beardog.cce.hp.com>
    Signed-off-by: James Bottomley <JBottomley@Parallels.com>

diff --git a/drivers/scsi/hpsa.h b/drivers/scsi/hpsa.h
index 91edafb8c7e6..b4b97ebcb47a 100644
--- a/drivers/scsi/hpsa.h
+++ b/drivers/scsi/hpsa.h
@@ -58,7 +58,6 @@ struct ctlr_info {
 	unsigned long paddr;
 	int 	nr_cmds; /* Number of commands allowed on this controller */
 	struct CfgTable __iomem *cfgtable;
-	int     max_sg_entries;
 	int	interrupts_enabled;
 	int	major;
 	int 	max_commands;

commit a0c124137a40fc22730ae87caf17e821f2dce1ed
Author: Stephen M. Cameron <scameron@beardog.cce.hp.com>
Date:   Wed Oct 26 16:22:04 2011 -0500

    [SCSI] hpsa: detect controller lockup
    
    When controller lockup condition is detected,
    we should fail all outstanding commands and disable
    the controller.  This will enable multipath solutions
    to recover gracefully.
    
    Signed-off-by: Stephen M. Cameron <scameron@beardog.cce.hp.com>
    Signed-off-by: James Bottomley <JBottomley@Parallels.com>

diff --git a/drivers/scsi/hpsa.h b/drivers/scsi/hpsa.h
index 73858bc22e57..91edafb8c7e6 100644
--- a/drivers/scsi/hpsa.h
+++ b/drivers/scsi/hpsa.h
@@ -121,6 +121,11 @@ struct ctlr_info {
 	unsigned char reply_pool_wraparound;
 	u32 *blockFetchTable;
 	unsigned char *hba_inquiry_data;
+	u64 last_intr_timestamp;
+	u32 last_heartbeat;
+	u64 last_heartbeat_timestamp;
+	u32 lockup_detected;
+	struct list_head lockup_list;
 };
 #define HPSA_ABORT_MSG 0
 #define HPSA_DEVICE_RESET_MSG 1

commit b7ec021fe6fe979dbd4e62604a4942f964b12864
Author: Scott Teel <scott.teel@hp.com>
Date:   Wed Oct 26 16:21:12 2011 -0500

    [SCSI] hpsa: fix potential array overflow in hpsa_update_scsi_devices
    
    The currentsd[] array in hpsa_update_scsi_devices had room for
    256 devices.  The code was iterating over however many physical
    and logical devices plus an additional number of possible external
    MSA2XXX controllers, which together could potentially exceed 256.
    
    We increased the size of the currentsd array to 1024 + 1024 + 32 + 1
    elements to reflect a reasonable maximum possible number of devices
    which might be encountered.  We also don't just walk off the end
    of the array if the array controller reports more devices than we
    are prepared to handle, we just ignore the excessive devices.
    
    Signed-off-by: Scott Teel <scott.teel@hp.com>
    Signed-off-by: Stephen M. Cameron <scameron@beardog.cce.hp.com>
    Signed-off-by: James Bottomley <JBottomley@Parallels.com>

diff --git a/drivers/scsi/hpsa.h b/drivers/scsi/hpsa.h
index 4de9f71d8bff..73858bc22e57 100644
--- a/drivers/scsi/hpsa.h
+++ b/drivers/scsi/hpsa.h
@@ -102,7 +102,6 @@ struct ctlr_info {
 	struct Scsi_Host *scsi_host;
 	spinlock_t devlock; /* to protect hba[ctlr]->dev[];  */
 	int ndevices; /* number of used elements in .dev[] array. */
-#define HPSA_MAX_DEVICES 256
 	struct hpsa_scsi_dev_t *dev[HPSA_MAX_DEVICES];
 	/*
 	 * Performant mode tables.

commit cfe5badcab2e993e71ebebbc07c21c270e5580c0
Author: Scott Teel <scott.teel@hp.com>
Date:   Wed Oct 26 16:21:07 2011 -0500

    [SCSI] hpsa: rename HPSA_MAX_SCSI_DEVS_PER_HBA
    
    Rename HPSA_MAX_SCSI_DEVS_PER_HBA to HPSA_MAX_DEVICES
    
    Signed-off-by: Scott Teel <scott.teel@hp.com>
    Signed-off-by: Stephen M. Cameron <scameron@beardog.cce.hp.com>
    Signed-off-by: James Bottomley <JBottomley@Parallels.com>

diff --git a/drivers/scsi/hpsa.h b/drivers/scsi/hpsa.h
index 111b79e32b2b..4de9f71d8bff 100644
--- a/drivers/scsi/hpsa.h
+++ b/drivers/scsi/hpsa.h
@@ -102,8 +102,8 @@ struct ctlr_info {
 	struct Scsi_Host *scsi_host;
 	spinlock_t devlock; /* to protect hba[ctlr]->dev[];  */
 	int ndevices; /* number of used elements in .dev[] array. */
-#define HPSA_MAX_SCSI_DEVS_PER_HBA 256
-	struct hpsa_scsi_dev_t *dev[HPSA_MAX_SCSI_DEVS_PER_HBA];
+#define HPSA_MAX_DEVICES 256
+	struct hpsa_scsi_dev_t *dev[HPSA_MAX_DEVICES];
 	/*
 	 * Performant mode tables.
 	 */

commit 03ab31f4c14f259bfa160543c83dbfd93d6fb3e2
Author: Stephen M. Cameron <scameron@beardog.cce.hp.com>
Date:   Wed Oct 26 16:20:58 2011 -0500

    [SCSI] hpsa: remove unused busy_initializing and busy_scanning
    
    Signed-off-by: Stephen M. Cameron <scameron@beardog.cce.hp.com>
    Signed-off-by: James Bottomley <JBottomley@Parallels.com>

diff --git a/drivers/scsi/hpsa.h b/drivers/scsi/hpsa.h
index 7f53ceaa7239..111b79e32b2b 100644
--- a/drivers/scsi/hpsa.h
+++ b/drivers/scsi/hpsa.h
@@ -95,8 +95,6 @@ struct ctlr_info {
 	unsigned long  		*cmd_pool_bits;
 	int			nr_allocs;
 	int			nr_frees;
-	int			busy_initializing;
-	int			busy_scanning;
 	int			scan_finished;
 	spinlock_t		scan_lock;
 	wait_queue_head_t	scan_wait_queue;

commit fec62c368b9c8b05d5124ca6c3b8336b537f26f3
Author: Stephen M. Cameron <scameron@beardog.cce.hp.com>
Date:   Thu Jul 21 13:16:05 2011 -0500

    [SCSI] hpsa: do not attempt to read from a write-only register
    
    Most smartarrays tolerate it, but a few new ones don't.
    Without this change some newer Smart Arrays will lock up
    and i/o will grind to a halt.
    
    Signed-off-by: Stephen M. Cameron <scameron@beardog.cce.hp.com>
    Cc: stable@kernel.org
    Signed-off-by: James Bottomley <JBottomley@Parallels.com>

diff --git a/drivers/scsi/hpsa.h b/drivers/scsi/hpsa.h
index 6d8dcd4dd06b..7f53ceaa7239 100644
--- a/drivers/scsi/hpsa.h
+++ b/drivers/scsi/hpsa.h
@@ -214,7 +214,7 @@ static void SA5_submit_command(struct ctlr_info *h,
 	dev_dbg(&h->pdev->dev, "Sending %x, tag = %x\n", c->busaddr,
 		c->Header.Tag.lower);
 	writel(c->busaddr, h->vaddr + SA5_REQUEST_PORT_OFFSET);
-	(void) readl(h->vaddr + SA5_REQUEST_PORT_OFFSET);
+	(void) readl(h->vaddr + SA5_SCRATCHPAD_OFFSET);
 	h->commands_outstanding++;
 	if (h->commands_outstanding > h->max_outstanding)
 		h->max_outstanding = h->commands_outstanding;

commit 64670ac8702ec37a00ad6e479f3cacbde0fd4efa
Author: Stephen M. Cameron <scameron@beardog.cce.hp.com>
Date:   Tue May 3 14:59:51 2011 -0500

    [SCSI] hpsa: do soft reset if hard reset is broken
    
    on driver load, if reset_devices is set, and the hard reset
    attempts fail, try to bring up the controller to the point that
    a command can be sent, and send it a soft reset command, then
    after the reset undo whatever driver initialization was done to get
    it to the point to take a command, and re-do it after the reset.
    
    This is to get kdump to work on all the "non-resettable" controllers
    (except 64xx controllers which can't be reset due to the potentially
    shared cache module.)
    
    Signed-off-by: Stephen M. Cameron <scameron@beardog.cce.hp.com>
    Signed-off-by: James Bottomley <jbottomley@parallels.com>
    Signed-off-by: James Bottomley <James.Bottomley@suse.de>

diff --git a/drivers/scsi/hpsa.h b/drivers/scsi/hpsa.h
index b1412a7f4514..6d8dcd4dd06b 100644
--- a/drivers/scsi/hpsa.h
+++ b/drivers/scsi/hpsa.h
@@ -127,8 +127,10 @@ struct ctlr_info {
 };
 #define HPSA_ABORT_MSG 0
 #define HPSA_DEVICE_RESET_MSG 1
-#define HPSA_BUS_RESET_MSG 2
-#define HPSA_HOST_RESET_MSG 3
+#define HPSA_RESET_TYPE_CONTROLLER 0x00
+#define HPSA_RESET_TYPE_BUS 0x01
+#define HPSA_RESET_TYPE_TARGET 0x03
+#define HPSA_RESET_TYPE_LUN 0x04
 #define HPSA_MSG_SEND_RETRY_LIMIT 10
 #define HPSA_MSG_SEND_RETRY_INTERVAL_MSECS (10000)
 

commit 2ed7127bceb10a6a7d5a38c30ab65176d4e4bc0f
Author: Stephen M. Cameron <scameron@beardog.cce.hp.com>
Date:   Tue May 3 14:59:31 2011 -0500

    [SCSI] hpsa: increase time to wait for board reset
    
    Signed-off-by: Stephen M. Cameron <scameron@beardog.cce.hp.com>
    Signed-off-by: James Bottomley <jbottomley@parallels.com>
    Signed-off-by: James Bottomley <James.Bottomley@suse.de>

diff --git a/drivers/scsi/hpsa.h b/drivers/scsi/hpsa.h
index 7a4ee7335a46..b1412a7f4514 100644
--- a/drivers/scsi/hpsa.h
+++ b/drivers/scsi/hpsa.h
@@ -155,7 +155,7 @@ struct ctlr_info {
  * HPSA_BOARD_READY_ITERATIONS are derived from those.
  */
 #define HPSA_BOARD_READY_WAIT_SECS (120)
-#define HPSA_BOARD_NOT_READY_WAIT_SECS (10)
+#define HPSA_BOARD_NOT_READY_WAIT_SECS (100)
 #define HPSA_BOARD_READY_POLL_INTERVAL_MSECS (100)
 #define HPSA_BOARD_READY_POLL_INTERVAL \
 	((HPSA_BOARD_READY_POLL_INTERVAL_MSECS * HZ) / 1000)

commit 516fda49e8596904a741693059c8746f11ce579c
Author: Stephen M. Cameron <scameron@beardog.cce.hp.com>
Date:   Tue May 3 14:59:15 2011 -0500

    [SCSI] hpsa: wait longer for no-op to complete after resetting controller
    
    This is to avoid the usual two or three messages about the command
    timing out.  We're obviously not waiting long enough.
    
    Signed-off-by: Stephen M. Cameron <scameron@beardog.cce.hp.com>
    Signed-off-by: James Bottomley <jbottomley@parallels.com>
    Signed-off-by: James Bottomley <James.Bottomley@suse.de>

diff --git a/drivers/scsi/hpsa.h b/drivers/scsi/hpsa.h
index 7eec39716dc7..7a4ee7335a46 100644
--- a/drivers/scsi/hpsa.h
+++ b/drivers/scsi/hpsa.h
@@ -130,7 +130,7 @@ struct ctlr_info {
 #define HPSA_BUS_RESET_MSG 2
 #define HPSA_HOST_RESET_MSG 3
 #define HPSA_MSG_SEND_RETRY_LIMIT 10
-#define HPSA_MSG_SEND_RETRY_INTERVAL_MSECS 1000
+#define HPSA_MSG_SEND_RETRY_INTERVAL_MSECS (10000)
 
 /* Maximum time in seconds driver will wait for command completions
  * when polling before giving up.

commit 8cd21da71c952843f9cc215436286cf7f991cc6e
Author: Stephen M. Cameron <scameron@beardog.cce.hp.com>
Date:   Tue May 3 14:58:55 2011 -0500

    [SCSI] hpsa: add readl after writel in interrupt mask setting code
    
    This is to ensure the board interrupts are really off when
    these functions return.
    
    Signed-off-by: Stephen M. Cameron <scameron@beardog.cce.hp.com>
    Signed-off-by: James Bottomley <jbottomley@parallels.com>
    Signed-off-by: James Bottomley <James.Bottomley@suse.de>

diff --git a/drivers/scsi/hpsa.h b/drivers/scsi/hpsa.h
index 98c97ca21223..7eec39716dc7 100644
--- a/drivers/scsi/hpsa.h
+++ b/drivers/scsi/hpsa.h
@@ -228,10 +228,12 @@ static void SA5_intr_mask(struct ctlr_info *h, unsigned long val)
 	if (val) { /* Turn interrupts on */
 		h->interrupts_enabled = 1;
 		writel(0, h->vaddr + SA5_REPLY_INTR_MASK_OFFSET);
+		(void) readl(h->vaddr + SA5_REPLY_INTR_MASK_OFFSET);
 	} else { /* Turn them off */
 		h->interrupts_enabled = 0;
 		writel(SA5_INTR_OFF,
 			h->vaddr + SA5_REPLY_INTR_MASK_OFFSET);
+		(void) readl(h->vaddr + SA5_REPLY_INTR_MASK_OFFSET);
 	}
 }
 
@@ -240,10 +242,12 @@ static void SA5_performant_intr_mask(struct ctlr_info *h, unsigned long val)
 	if (val) { /* turn on interrupts */
 		h->interrupts_enabled = 1;
 		writel(0, h->vaddr + SA5_REPLY_INTR_MASK_OFFSET);
+		(void) readl(h->vaddr + SA5_REPLY_INTR_MASK_OFFSET);
 	} else {
 		h->interrupts_enabled = 0;
 		writel(SA5_PERF_INTR_OFF,
 			h->vaddr + SA5_REPLY_INTR_MASK_OFFSET);
+		(void) readl(h->vaddr + SA5_REPLY_INTR_MASK_OFFSET);
 	}
 }
 

commit d0be5ec8693944c2e2fc0de70fda9dbc1b93bd7d
Author: Stephen M. Cameron <scameron@beardog.cce.hp.com>
Date:   Tue May 3 14:58:49 2011 -0500

    [SCSI] hpsa: do readl after writel in main i/o path to ensure commands don't get lost.
    
    Apparently we've been doin it rong for a decade, but only lately do we
    run into problems.
    
    Signed-off-by: Stephen M. Cameron <scameron@beardog.cce.hp.com>
    Signed-off-by: James Bottomley <jbottomley@parallels.com>
    Signed-off-by: James Bottomley <James.Bottomley@suse.de>

diff --git a/drivers/scsi/hpsa.h b/drivers/scsi/hpsa.h
index 621a1530054a..98c97ca21223 100644
--- a/drivers/scsi/hpsa.h
+++ b/drivers/scsi/hpsa.h
@@ -212,6 +212,7 @@ static void SA5_submit_command(struct ctlr_info *h,
 	dev_dbg(&h->pdev->dev, "Sending %x, tag = %x\n", c->busaddr,
 		c->Header.Tag.lower);
 	writel(c->busaddr, h->vaddr + SA5_REQUEST_PORT_OFFSET);
+	(void) readl(h->vaddr + SA5_REQUEST_PORT_OFFSET);
 	h->commands_outstanding++;
 	if (h->commands_outstanding > h->max_outstanding)
 		h->max_outstanding = h->commands_outstanding;

commit a9a3a2739a44fc05dcaba0d4d36e52dc444c294f
Author: Stephen M. Cameron <scameron@beardog.cce.hp.com>
Date:   Tue Feb 15 15:32:53 2011 -0600

    [SCSI] hpsa: make hpsa.hpsa_simple_mode=1 module parameter actually work
    
    It's not enough to simple avoid putting the board into performant
    mode, as we have to set up the interrupts differently, etc.  When
    I originally tested this module parameter, I tested it incorrectly
    without realizing it, and the driver was running in performant mode
    the whole time unbeknownst to me.
    
    Signed-off-by: Stephen M. Cameron <scameron@beardog.cce.hp.com>
    Signed-off-by: James Bottomley <James.Bottomley@suse.de>

diff --git a/drivers/scsi/hpsa.h b/drivers/scsi/hpsa.h
index e89819342364..621a1530054a 100644
--- a/drivers/scsi/hpsa.h
+++ b/drivers/scsi/hpsa.h
@@ -72,6 +72,7 @@ struct ctlr_info {
 	unsigned int intr[4];
 	unsigned int msix_vector;
 	unsigned int msi_vector;
+	int intr_mode; /* either PERF_MODE_INT or SIMPLE_MODE_INT */
 	struct access_method access;
 
 	/* queue and queue Info */

commit 9e0fc764eaec082cd2ffcf82568dfdd086935934
Author: Stephen M. Cameron <scameron@beardog.cce.hp.com>
Date:   Tue Feb 15 15:32:48 2011 -0600

    [SCSI] hpsa: do not re-order commands in internal queues
    
    Driver's internal queues should be FIFO, not LIFO.
    This is a port of an almost identical patch from cciss by Jens Axboe.
    
    Signed-off-by: Stephen M. Cameron <scameron@beardog.cce.hp.com>
    Signed-off-by: James Bottomley <James.Bottomley@suse.de>

diff --git a/drivers/scsi/hpsa.h b/drivers/scsi/hpsa.h
index 074d237f4497..e89819342364 100644
--- a/drivers/scsi/hpsa.h
+++ b/drivers/scsi/hpsa.h
@@ -75,8 +75,8 @@ struct ctlr_info {
 	struct access_method access;
 
 	/* queue and queue Info */
-	struct hlist_head reqQ;
-	struct hlist_head cmpQ;
+	struct list_head reqQ;
+	struct list_head cmpQ;
 	unsigned int Qdepth;
 	unsigned int maxQsinceinit;
 	unsigned int maxSG;

commit fe5389c87f13c16cd77d976801c93422d0c05a49
Author: Stephen M. Cameron <scameron@beardog.cce.hp.com>
Date:   Thu Jan 6 14:48:03 2011 -0600

    [SCSI] hpsa: fix board status waiting code
    
    After a reset, we should first wait for the board to become "not ready",
    and then wait for it to become "ready", instead of immediately
    waiting for it to become "ready", and do this waiting *after*
    restoring PCI config space registers.  Also, only wait 10 secs
    for board to become "not ready" after a reset (it should quickly
    become not ready.)
    
    Signed-off-by: Stephen M. Cameron <scameron@beardog.cce.hp.com>
    Signed-off-by: James Bottomley <James.Bottomley@suse.de>

diff --git a/drivers/scsi/hpsa.h b/drivers/scsi/hpsa.h
index 19586e189f0f..074d237f4497 100644
--- a/drivers/scsi/hpsa.h
+++ b/drivers/scsi/hpsa.h
@@ -154,12 +154,16 @@ struct ctlr_info {
  * HPSA_BOARD_READY_ITERATIONS are derived from those.
  */
 #define HPSA_BOARD_READY_WAIT_SECS (120)
+#define HPSA_BOARD_NOT_READY_WAIT_SECS (10)
 #define HPSA_BOARD_READY_POLL_INTERVAL_MSECS (100)
 #define HPSA_BOARD_READY_POLL_INTERVAL \
 	((HPSA_BOARD_READY_POLL_INTERVAL_MSECS * HZ) / 1000)
 #define HPSA_BOARD_READY_ITERATIONS \
 	((HPSA_BOARD_READY_WAIT_SECS * 1000) / \
 		HPSA_BOARD_READY_POLL_INTERVAL_MSECS)
+#define HPSA_BOARD_NOT_READY_ITERATIONS \
+	((HPSA_BOARD_NOT_READY_WAIT_SECS * 1000) / \
+		HPSA_BOARD_READY_POLL_INTERVAL_MSECS)
 #define HPSA_POST_RESET_PAUSE_MSECS (3000)
 #define HPSA_POST_RESET_NOOP_RETRIES (12)
 

commit a0b89872b305bd0f6f5af1dd26274a3f057a2303
Author: Stephen M. Cameron <scameron@beardog.cce.hp.com>
Date:   Thu Dec 16 13:00:58 2010 -0600

    [SCSI] hpsa: do not consider firmware revision when looking for device changes.
    
    The firmware may have been updated, in which case, it's the same device,
    and in that case, we do not want to remove and add the device, we want to
    let it continue as is.
    
    Signed-off-by: Stephen M. Cameron <scameron@beardog.cce.hp.com>
    Signed-off-by: James Bottomley <James.Bottomley@suse.de>

diff --git a/drivers/scsi/hpsa.h b/drivers/scsi/hpsa.h
index a203ef65cb50..19586e189f0f 100644
--- a/drivers/scsi/hpsa.h
+++ b/drivers/scsi/hpsa.h
@@ -45,7 +45,6 @@ struct hpsa_scsi_dev_t {
 	unsigned char device_id[16];    /* from inquiry pg. 0x83 */
 	unsigned char vendor[8];        /* bytes 8-15 of inquiry data */
 	unsigned char model[16];        /* bytes 16-31 of inquiry data */
-	unsigned char revision[4];      /* bytes 32-35 of inquiry data */
 	unsigned char raid_level;	/* from inquiry page 0xC1 */
 };
 

commit 873f339fc53750c1e715f5e1d2dfdb9869b7ea3f
Author: Stephen M. Cameron <scameron@beardog.cce.hp.com>
Date:   Thu May 27 15:14:24 2010 -0500

    [SCSI] hpsa: remove unused firm_ver member of the per-hba structure
    
    Signed-off-by: Stephen M. Cameron <scameron@beardog.cce.hp.com>
    Signed-off-by: James Bottomley <James.Bottomley@suse.de>

diff --git a/drivers/scsi/hpsa.h b/drivers/scsi/hpsa.h
index 1bb5233b09a0..a203ef65cb50 100644
--- a/drivers/scsi/hpsa.h
+++ b/drivers/scsi/hpsa.h
@@ -53,7 +53,6 @@ struct ctlr_info {
 	int	ctlr;
 	char	devname[8];
 	char    *product_name;
-	char	firm_ver[4]; /* Firmware version */
 	struct pci_dev *pdev;
 	u32	board_id;
 	void __iomem *vaddr;

commit 33a2ffce51d9598380d73c515a27fc6cff3bd9c4
Author: Stephen M. Cameron <scameron@beardog.cce.hp.com>
Date:   Thu Feb 25 14:03:27 2010 -0600

    [SCSI] hpsa: Increase the number of scatter gather elements supported.
    
    This uses the scatter-gather chaining feature of Smart Array
    controllers.  32 scatter-gather elements are embedded in the
    "command list", and the last element in the list may be marked
    as a "chain pointer", and point to an additional block of
    scatter gather elements.  The precise number of scatter gather
    elements supported is dependent on the particular kind of
    Smart Array, and is determined at runtime by querying the
    hardware.
    
    Signed-off-by: Stephen M. Cameron <scameron@beardog.cce.hp.com>
    Signed-off-by: James Bottomley <James.Bottomley@suse.de>

diff --git a/drivers/scsi/hpsa.h b/drivers/scsi/hpsa.h
index fc15215145d9..1bb5233b09a0 100644
--- a/drivers/scsi/hpsa.h
+++ b/drivers/scsi/hpsa.h
@@ -83,6 +83,10 @@ struct ctlr_info {
 	unsigned int maxQsinceinit;
 	unsigned int maxSG;
 	spinlock_t lock;
+	int maxsgentries;
+	u8 max_cmd_sg_entries;
+	int chainsize;
+	struct SGDescriptor **cmd_sg_list;
 
 	/* pointers to command and error info pool */
 	struct CommandList 	*cmd_pool;

commit 31468401ccf64322ca99fe05fbe64f1551240f57
Author: Mike Miller <mikem@beardog.cce.hp.com>
Date:   Thu Feb 25 14:03:12 2010 -0600

    [SCSI] hpsa: remove scan thread
    
    The intent of the scan thread was to allow a UNIT ATTENTION/LUN
    DATA CHANGED condition encountered in the interrupt handler
    to trigger a rescan of devices, which can't be done in interrupt
    context.  However, we weren't able to get this to work, due to
    multiple such UNIT ATTENTION conditions arriving during the rescan,
    during updating of the SCSI mid layer, etc.  There's no way to tell
    the devices, "stand still while I scan you!"  Since it doesn't work,
    there's no point in having the thread, as the rescan triggered via
    ioctl or sysfs can be done without such a thread.
    
    Signed-off-by: Mike Miller <mikem@beardog.cce.hp.com>
    Signed-off-by: Stephen M. Cameron <scameron@beardog.cce.hp.com>
    Signed-off-by: James Bottomley <James.Bottomley@suse.de>

diff --git a/drivers/scsi/hpsa.h b/drivers/scsi/hpsa.h
index a0502b3ac17e..fc15215145d9 100644
--- a/drivers/scsi/hpsa.h
+++ b/drivers/scsi/hpsa.h
@@ -97,9 +97,6 @@ struct ctlr_info {
 	int			scan_finished;
 	spinlock_t		scan_lock;
 	wait_queue_head_t	scan_wait_queue;
-	struct mutex		busy_shutting_down;
-	struct list_head	scan_list;
-	struct completion	scan_wait;
 
 	struct Scsi_Host *scsi_host;
 	spinlock_t devlock; /* to protect hba[ctlr]->dev[];  */

commit a08a8471b7aed3d50df8e9c852dc2baa08ec8b01
Author: Stephen M. Cameron <scameron@beardog.cce.hp.com>
Date:   Thu Feb 4 08:43:16 2010 -0600

    [SCSI] hpsa: use scan_start and scan_finished entry points for scanning
    
    use scan_start and scan_finished entry points for scanning and route
    the CCISS_REGNEWD ioctl and sysfs triggering of same functionality
    through hpsa_scan_start.
    
    Signed-off-by: Stephen M. Cameron <scameron@beardog.cce.hp.com>
    Signed-off-by: James Bottomley <James.Bottomley@suse.de>

diff --git a/drivers/scsi/hpsa.h b/drivers/scsi/hpsa.h
index 1ab0c1bbd27e..a0502b3ac17e 100644
--- a/drivers/scsi/hpsa.h
+++ b/drivers/scsi/hpsa.h
@@ -94,6 +94,9 @@ struct ctlr_info {
 	int			nr_frees;
 	int			busy_initializing;
 	int			busy_scanning;
+	int			scan_finished;
+	spinlock_t		scan_lock;
+	wait_queue_head_t	scan_wait_queue;
 	struct mutex		busy_shutting_down;
 	struct list_head	scan_list;
 	struct completion	scan_wait;

commit 339b2b14c634da58626eb742370d915591c2fb6d
Author: Stephen M. Cameron <scameron@beardog.cce.hp.com>
Date:   Thu Feb 4 08:42:50 2010 -0600

    [SCSI] hpsa: Fix p1210m LUN assignment.
    
    The p1210m responsds to SCSI report LUNs, unlike traditional Smart
    Array controllers.  This means that the bus, target, and lun
    assignments done by the driver cannot be arbitrary, but must match
    what SCSI REPORT LUNS returns.
    
    Signed-off-by: Stephen M. Cameron <scameron@beardog.cce.hp.com>
    Signed-off-by: James Bottomley <James.Bottomley@suse.de>

diff --git a/drivers/scsi/hpsa.h b/drivers/scsi/hpsa.h
index 0ba1aa3f4d4d..1ab0c1bbd27e 100644
--- a/drivers/scsi/hpsa.h
+++ b/drivers/scsi/hpsa.h
@@ -120,6 +120,7 @@ struct ctlr_info {
 	size_t reply_pool_size;
 	unsigned char reply_pool_wraparound;
 	u32 *blockFetchTable;
+	unsigned char *hba_inquiry_data;
 };
 #define HPSA_ABORT_MSG 0
 #define HPSA_DEVICE_RESET_MSG 1

commit 303932fd4ff63e8650d5d5da6cc286a8b5f8318d
Author: Don Brace <brace@beardog.cce.hp.com>
Date:   Thu Feb 4 08:42:40 2010 -0600

    [SCSI] hpsa: Allow multiple command completions per interrupt.
    
    This is done by adding support for the so-called "performant mode"
    (that's really what they called it).  Smart Array controllers
    have a mode which enables multiple command completions to be
    delivered with a single interrupt, "performant" mode.  We want to use
    that mode, as some newer controllers will be requiring this mode.
    
    Signed-off-by: Don Brace <brace@beardog.cce.hp.com>
    Signed-off-by: Stephen M. Cameron <scameron@beardog.cce.hp.com>
    Signed-off-by: Mike Miller <mikem@beardog.cce.hp.com>
    Signed-off-by: James Bottomley <James.Bottomley@suse.de>

diff --git a/drivers/scsi/hpsa.h b/drivers/scsi/hpsa.h
index 0eab386a03be..0ba1aa3f4d4d 100644
--- a/drivers/scsi/hpsa.h
+++ b/drivers/scsi/hpsa.h
@@ -60,14 +60,15 @@ struct ctlr_info {
 	unsigned long paddr;
 	int 	nr_cmds; /* Number of commands allowed on this controller */
 	struct CfgTable __iomem *cfgtable;
+	int     max_sg_entries;
 	int	interrupts_enabled;
 	int	major;
 	int 	max_commands;
 	int	commands_outstanding;
 	int 	max_outstanding; /* Debug */
 	int	usage_count;  /* number of opens all all minor devices */
-#	define DOORBELL_INT	0
-#	define PERF_MODE_INT	1
+#	define PERF_MODE_INT	0
+#	define DOORBELL_INT	1
 #	define SIMPLE_MODE_INT	2
 #	define MEMQ_MODE_INT	3
 	unsigned int intr[4];
@@ -102,6 +103,23 @@ struct ctlr_info {
 	int ndevices; /* number of used elements in .dev[] array. */
 #define HPSA_MAX_SCSI_DEVS_PER_HBA 256
 	struct hpsa_scsi_dev_t *dev[HPSA_MAX_SCSI_DEVS_PER_HBA];
+	/*
+	 * Performant mode tables.
+	 */
+	u32 trans_support;
+	u32 trans_offset;
+	struct TransTable_struct *transtable;
+	unsigned long transMethod;
+
+	/*
+	 * Performant mode completion buffer
+	 */
+	u64 *reply_pool;
+	dma_addr_t reply_pool_dhandle;
+	u64 *reply_pool_head;
+	size_t reply_pool_size;
+	unsigned char reply_pool_wraparound;
+	u32 *blockFetchTable;
 };
 #define HPSA_ABORT_MSG 0
 #define HPSA_DEVICE_RESET_MSG 1
@@ -165,6 +183,16 @@ struct ctlr_info {
 
 #define HPSA_ERROR_BIT		0x02
 
+/* Performant mode flags */
+#define SA5_PERF_INTR_PENDING   0x04
+#define SA5_PERF_INTR_OFF       0x05
+#define SA5_OUTDB_STATUS_PERF_BIT       0x01
+#define SA5_OUTDB_CLEAR_PERF_BIT        0x01
+#define SA5_OUTDB_CLEAR         0xA0
+#define SA5_OUTDB_CLEAR_PERF_BIT        0x01
+#define SA5_OUTDB_STATUS        0x9C
+
+
 #define HPSA_INTR_ON 	1
 #define HPSA_INTR_OFF	0
 /*
@@ -173,7 +201,8 @@ struct ctlr_info {
 static void SA5_submit_command(struct ctlr_info *h,
 	struct CommandList *c)
 {
-	dev_dbg(&h->pdev->dev, "Sending %x\n", c->busaddr);
+	dev_dbg(&h->pdev->dev, "Sending %x, tag = %x\n", c->busaddr,
+		c->Header.Tag.lower);
 	writel(c->busaddr, h->vaddr + SA5_REQUEST_PORT_OFFSET);
 	h->commands_outstanding++;
 	if (h->commands_outstanding > h->max_outstanding)
@@ -196,6 +225,52 @@ static void SA5_intr_mask(struct ctlr_info *h, unsigned long val)
 			h->vaddr + SA5_REPLY_INTR_MASK_OFFSET);
 	}
 }
+
+static void SA5_performant_intr_mask(struct ctlr_info *h, unsigned long val)
+{
+	if (val) { /* turn on interrupts */
+		h->interrupts_enabled = 1;
+		writel(0, h->vaddr + SA5_REPLY_INTR_MASK_OFFSET);
+	} else {
+		h->interrupts_enabled = 0;
+		writel(SA5_PERF_INTR_OFF,
+			h->vaddr + SA5_REPLY_INTR_MASK_OFFSET);
+	}
+}
+
+static unsigned long SA5_performant_completed(struct ctlr_info *h)
+{
+	unsigned long register_value = FIFO_EMPTY;
+
+	/* flush the controller write of the reply queue by reading
+	 * outbound doorbell status register.
+	 */
+	register_value = readl(h->vaddr + SA5_OUTDB_STATUS);
+	/* msi auto clears the interrupt pending bit. */
+	if (!(h->msi_vector || h->msix_vector)) {
+		writel(SA5_OUTDB_CLEAR_PERF_BIT, h->vaddr + SA5_OUTDB_CLEAR);
+		/* Do a read in order to flush the write to the controller
+		 * (as per spec.)
+		 */
+		register_value = readl(h->vaddr + SA5_OUTDB_STATUS);
+	}
+
+	if ((*(h->reply_pool_head) & 1) == (h->reply_pool_wraparound)) {
+		register_value = *(h->reply_pool_head);
+		(h->reply_pool_head)++;
+		h->commands_outstanding--;
+	} else {
+		register_value = FIFO_EMPTY;
+	}
+	/* Check for wraparound */
+	if (h->reply_pool_head == (h->reply_pool + h->max_commands)) {
+		h->reply_pool_head = h->reply_pool;
+		h->reply_pool_wraparound ^= 1;
+	}
+
+	return register_value;
+}
+
 /*
  *  Returns true if fifo is full.
  *
@@ -241,6 +316,20 @@ static bool SA5_intr_pending(struct ctlr_info *h)
 	return register_value & SA5_INTR_PENDING;
 }
 
+static bool SA5_performant_intr_pending(struct ctlr_info *h)
+{
+	unsigned long register_value = readl(h->vaddr + SA5_INTR_STATUS);
+
+	if (!register_value)
+		return false;
+
+	if (h->msi_vector || h->msix_vector)
+		return true;
+
+	/* Read outbound doorbell to flush */
+	register_value = readl(h->vaddr + SA5_OUTDB_STATUS);
+	return register_value & SA5_OUTDB_STATUS_PERF_BIT;
+}
 
 static struct access_method SA5_access = {
 	SA5_submit_command,
@@ -250,14 +339,19 @@ static struct access_method SA5_access = {
 	SA5_completed,
 };
 
+static struct access_method SA5_performant_access = {
+	SA5_submit_command,
+	SA5_performant_intr_mask,
+	SA5_fifo_full,
+	SA5_performant_intr_pending,
+	SA5_performant_completed,
+};
+
 struct board_type {
 	u32	board_id;
 	char	*product_name;
 	struct access_method *access;
 };
 
-
-/* end of old hpsa_scsi.h file */
-
 #endif /* HPSA_H */
 

commit 900c54404a9456b3ff10745e5e8f64b12c3a6ef7
Author: Stephen M. Cameron <scameron@beardog.cce.hp.com>
Date:   Thu Feb 4 08:42:35 2010 -0600

    [SCSI] hpsa: interrupt pending function should return bool not unsigned long
    
    Signed-off-by: Stephen M. Cameron <scameron@beardog.cce.hp.com>
    Signed-off-by: James Bottomley <James.Bottomley@suse.de>

diff --git a/drivers/scsi/hpsa.h b/drivers/scsi/hpsa.h
index cdac95b0e65f..0eab386a03be 100644
--- a/drivers/scsi/hpsa.h
+++ b/drivers/scsi/hpsa.h
@@ -33,7 +33,7 @@ struct access_method {
 		struct CommandList *c);
 	void (*set_intr_mask)(struct ctlr_info *h, unsigned long val);
 	unsigned long (*fifo_full)(struct ctlr_info *h);
-	unsigned long (*intr_pending)(struct ctlr_info *h);
+	bool (*intr_pending)(struct ctlr_info *h);
 	unsigned long (*command_completed)(struct ctlr_info *h);
 };
 
@@ -233,14 +233,12 @@ static unsigned long SA5_completed(struct ctlr_info *h)
 /*
  *	Returns true if an interrupt is pending..
  */
-static unsigned long SA5_intr_pending(struct ctlr_info *h)
+static bool SA5_intr_pending(struct ctlr_info *h)
 {
 	unsigned long register_value  =
 		readl(h->vaddr + SA5_INTR_STATUS);
 	dev_dbg(&h->pdev->dev, "intr_pending %lx\n", register_value);
-	if (register_value &  SA5_INTR_PENDING)
-		return  1;
-	return 0 ;
+	return register_value & SA5_INTR_PENDING;
 }
 
 

commit 84ca0be2a2cd9730683310b831db9d2fa60b3b0b
Author: Stephen M. Cameron <scameron@beardog.cce.hp.com>
Date:   Thu Feb 4 08:42:30 2010 -0600

    [SCSI] hpsa: fix some debug printks to use dev_dbg instead
    
    Signed-off-by: Stephen M. Cameron <scameron@beardog.cce.hp.com>
    Signed-off-by: James Bottomley <James.Bottomley@suse.de>

diff --git a/drivers/scsi/hpsa.h b/drivers/scsi/hpsa.h
index da8dd3e619cb..cdac95b0e65f 100644
--- a/drivers/scsi/hpsa.h
+++ b/drivers/scsi/hpsa.h
@@ -173,10 +173,7 @@ struct ctlr_info {
 static void SA5_submit_command(struct ctlr_info *h,
 	struct CommandList *c)
 {
-#ifdef HPSA_DEBUG
-	 printk(KERN_WARNING "hpsa: Sending %x - down to controller\n",
-		c->busaddr);
-#endif /* HPSA_DEBUG */
+	dev_dbg(&h->pdev->dev, "Sending %x\n", c->busaddr);
 	writel(c->busaddr, h->vaddr + SA5_REQUEST_PORT_OFFSET);
 	h->commands_outstanding++;
 	if (h->commands_outstanding > h->max_outstanding)
@@ -225,10 +222,10 @@ static unsigned long SA5_completed(struct ctlr_info *h)
 
 #ifdef HPSA_DEBUG
 	if (register_value != FIFO_EMPTY)
-		printk(KERN_INFO "hpsa:  Read %lx back from board\n",
+		dev_dbg(&h->pdev->dev, "Read %lx back from board\n",
 			register_value);
 	else
-		printk(KERN_INFO "hpsa:  FIFO Empty read\n");
+		dev_dbg(&h->pdev->dev, "hpsa: FIFO Empty read\n");
 #endif
 
 	return register_value;
@@ -240,9 +237,7 @@ static unsigned long SA5_intr_pending(struct ctlr_info *h)
 {
 	unsigned long register_value  =
 		readl(h->vaddr + SA5_INTR_STATUS);
-#ifdef HPSA_DEBUG
-	printk(KERN_INFO "hpsa: intr_pending %lx\n", register_value);
-#endif  /* HPSA_DEBUG */
+	dev_dbg(&h->pdev->dev, "intr_pending %lx\n", register_value);
 	if (register_value &  SA5_INTR_PENDING)
 		return  1;
 	return 0 ;

commit a104c99f386191706a11d39be81b8f03cd4f2719
Author: Stephen M. Cameron <scameron@beardog.cce.hp.com>
Date:   Thu Feb 4 08:42:24 2010 -0600

    [SCSI] hpsa: make tag macros into functions
    
    Signed-off-by: Stephen M. Cameron <scameron@beardog.cce.hp.com>
    Signed-off-by: James Bottomley <James.Bottomley@suse.de>

diff --git a/drivers/scsi/hpsa.h b/drivers/scsi/hpsa.h
index 194968e861c7..da8dd3e619cb 100644
--- a/drivers/scsi/hpsa.h
+++ b/drivers/scsi/hpsa.h
@@ -164,9 +164,6 @@ struct ctlr_info {
 #define HPSA_FIRMWARE_READY	0xffff0000 /* value in scratchpad register */
 
 #define HPSA_ERROR_BIT		0x02
-#define HPSA_TAG_CONTAINS_INDEX(tag) ((tag) & 0x04)
-#define HPSA_TAG_TO_INDEX(tag) ((tag) >> 3)
-#define HPSA_TAG_DISCARD_ERROR_BITS(tag) ((tag) & ~3)
 
 #define HPSA_INTR_ON 	1
 #define HPSA_INTR_OFF	0

commit 01a02ffcd55b74e3459bb7358140970e126d4731
Author: Stephen M. Cameron <scameron@beardog.cce.hp.com>
Date:   Thu Feb 4 08:41:33 2010 -0600

    [SCSI] hpsa: Use kernel integer types, not userland ones
    
    That is, use u64, u32, u16 and u8 rather than __u64, __u32, __u16 and __u8.
    
    Signed-off-by: Stephen M. Cameron <scameron@beardog.cce.hp.com>
    Signed-off-by: James Bottomley <James.Bottomley@suse.de>

diff --git a/drivers/scsi/hpsa.h b/drivers/scsi/hpsa.h
index 6bd1949144b5..194968e861c7 100644
--- a/drivers/scsi/hpsa.h
+++ b/drivers/scsi/hpsa.h
@@ -55,7 +55,7 @@ struct ctlr_info {
 	char    *product_name;
 	char	firm_ver[4]; /* Firmware version */
 	struct pci_dev *pdev;
-	__u32	board_id;
+	u32	board_id;
 	void __iomem *vaddr;
 	unsigned long paddr;
 	int 	nr_cmds; /* Number of commands allowed on this controller */
@@ -261,7 +261,7 @@ static struct access_method SA5_access = {
 };
 
 struct board_type {
-	__u32	board_id;
+	u32	board_id;
 	char	*product_name;
 	struct access_method *access;
 };

commit edd163687ea59f01d6b43c9e1fdaa0126fa30191
Author: Stephen M. Cameron <scameron@beardog.cce.hp.com>
Date:   Tue Dec 8 14:09:11 2009 -0800

    [SCSI] hpsa: add driver for HP Smart Array controllers.
    
    This driver supports a subset of HP Smart Array Controllers.
    It is a SCSI alternative to the cciss driver.
    
    [akpm@linux-foundation.org: avoid helpful cleanup patches]
    [achiang@hp.com: make device attrs static]
    [akpm@linux-foundation.org: msleep() does set_current_state() itself]
    Signed-off-by: Stephen M. Cameron <scameron@beardog.cce.hp.com>
    Signed-off-by: Mike Miller <mikem@beardog.cce.hp.com>
    Signed-off-by: Alex Chiang <achiang@hp.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: James Bottomley <James.Bottomley@suse.de>

diff --git a/drivers/scsi/hpsa.h b/drivers/scsi/hpsa.h
new file mode 100644
index 000000000000..6bd1949144b5
--- /dev/null
+++ b/drivers/scsi/hpsa.h
@@ -0,0 +1,273 @@
+/*
+ *    Disk Array driver for HP Smart Array SAS controllers
+ *    Copyright 2000, 2009 Hewlett-Packard Development Company, L.P.
+ *
+ *    This program is free software; you can redistribute it and/or modify
+ *    it under the terms of the GNU General Public License as published by
+ *    the Free Software Foundation; version 2 of the License.
+ *
+ *    This program is distributed in the hope that it will be useful,
+ *    but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *    MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE, GOOD TITLE or
+ *    NON INFRINGEMENT.  See the GNU General Public License for more details.
+ *
+ *    You should have received a copy of the GNU General Public License
+ *    along with this program; if not, write to the Free Software
+ *    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ *
+ *    Questions/Comments/Bugfixes to iss_storagedev@hp.com
+ *
+ */
+#ifndef HPSA_H
+#define HPSA_H
+
+#include <scsi/scsicam.h>
+
+#define IO_OK		0
+#define IO_ERROR	1
+
+struct ctlr_info;
+
+struct access_method {
+	void (*submit_command)(struct ctlr_info *h,
+		struct CommandList *c);
+	void (*set_intr_mask)(struct ctlr_info *h, unsigned long val);
+	unsigned long (*fifo_full)(struct ctlr_info *h);
+	unsigned long (*intr_pending)(struct ctlr_info *h);
+	unsigned long (*command_completed)(struct ctlr_info *h);
+};
+
+struct hpsa_scsi_dev_t {
+	int devtype;
+	int bus, target, lun;		/* as presented to the OS */
+	unsigned char scsi3addr[8];	/* as presented to the HW */
+#define RAID_CTLR_LUNID "\0\0\0\0\0\0\0\0"
+	unsigned char device_id[16];    /* from inquiry pg. 0x83 */
+	unsigned char vendor[8];        /* bytes 8-15 of inquiry data */
+	unsigned char model[16];        /* bytes 16-31 of inquiry data */
+	unsigned char revision[4];      /* bytes 32-35 of inquiry data */
+	unsigned char raid_level;	/* from inquiry page 0xC1 */
+};
+
+struct ctlr_info {
+	int	ctlr;
+	char	devname[8];
+	char    *product_name;
+	char	firm_ver[4]; /* Firmware version */
+	struct pci_dev *pdev;
+	__u32	board_id;
+	void __iomem *vaddr;
+	unsigned long paddr;
+	int 	nr_cmds; /* Number of commands allowed on this controller */
+	struct CfgTable __iomem *cfgtable;
+	int	interrupts_enabled;
+	int	major;
+	int 	max_commands;
+	int	commands_outstanding;
+	int 	max_outstanding; /* Debug */
+	int	usage_count;  /* number of opens all all minor devices */
+#	define DOORBELL_INT	0
+#	define PERF_MODE_INT	1
+#	define SIMPLE_MODE_INT	2
+#	define MEMQ_MODE_INT	3
+	unsigned int intr[4];
+	unsigned int msix_vector;
+	unsigned int msi_vector;
+	struct access_method access;
+
+	/* queue and queue Info */
+	struct hlist_head reqQ;
+	struct hlist_head cmpQ;
+	unsigned int Qdepth;
+	unsigned int maxQsinceinit;
+	unsigned int maxSG;
+	spinlock_t lock;
+
+	/* pointers to command and error info pool */
+	struct CommandList 	*cmd_pool;
+	dma_addr_t		cmd_pool_dhandle;
+	struct ErrorInfo 	*errinfo_pool;
+	dma_addr_t		errinfo_pool_dhandle;
+	unsigned long  		*cmd_pool_bits;
+	int			nr_allocs;
+	int			nr_frees;
+	int			busy_initializing;
+	int			busy_scanning;
+	struct mutex		busy_shutting_down;
+	struct list_head	scan_list;
+	struct completion	scan_wait;
+
+	struct Scsi_Host *scsi_host;
+	spinlock_t devlock; /* to protect hba[ctlr]->dev[];  */
+	int ndevices; /* number of used elements in .dev[] array. */
+#define HPSA_MAX_SCSI_DEVS_PER_HBA 256
+	struct hpsa_scsi_dev_t *dev[HPSA_MAX_SCSI_DEVS_PER_HBA];
+};
+#define HPSA_ABORT_MSG 0
+#define HPSA_DEVICE_RESET_MSG 1
+#define HPSA_BUS_RESET_MSG 2
+#define HPSA_HOST_RESET_MSG 3
+#define HPSA_MSG_SEND_RETRY_LIMIT 10
+#define HPSA_MSG_SEND_RETRY_INTERVAL_MSECS 1000
+
+/* Maximum time in seconds driver will wait for command completions
+ * when polling before giving up.
+ */
+#define HPSA_MAX_POLL_TIME_SECS (20)
+
+/* During SCSI error recovery, HPSA_TUR_RETRY_LIMIT defines
+ * how many times to retry TEST UNIT READY on a device
+ * while waiting for it to become ready before giving up.
+ * HPSA_MAX_WAIT_INTERVAL_SECS is the max wait interval
+ * between sending TURs while waiting for a device
+ * to become ready.
+ */
+#define HPSA_TUR_RETRY_LIMIT (20)
+#define HPSA_MAX_WAIT_INTERVAL_SECS (30)
+
+/* HPSA_BOARD_READY_WAIT_SECS is how long to wait for a board
+ * to become ready, in seconds, before giving up on it.
+ * HPSA_BOARD_READY_POLL_INTERVAL_MSECS * is how long to wait
+ * between polling the board to see if it is ready, in
+ * milliseconds.  HPSA_BOARD_READY_POLL_INTERVAL and
+ * HPSA_BOARD_READY_ITERATIONS are derived from those.
+ */
+#define HPSA_BOARD_READY_WAIT_SECS (120)
+#define HPSA_BOARD_READY_POLL_INTERVAL_MSECS (100)
+#define HPSA_BOARD_READY_POLL_INTERVAL \
+	((HPSA_BOARD_READY_POLL_INTERVAL_MSECS * HZ) / 1000)
+#define HPSA_BOARD_READY_ITERATIONS \
+	((HPSA_BOARD_READY_WAIT_SECS * 1000) / \
+		HPSA_BOARD_READY_POLL_INTERVAL_MSECS)
+#define HPSA_POST_RESET_PAUSE_MSECS (3000)
+#define HPSA_POST_RESET_NOOP_RETRIES (12)
+
+/*  Defining the diffent access_menthods */
+/*
+ * Memory mapped FIFO interface (SMART 53xx cards)
+ */
+#define SA5_DOORBELL	0x20
+#define SA5_REQUEST_PORT_OFFSET	0x40
+#define SA5_REPLY_INTR_MASK_OFFSET	0x34
+#define SA5_REPLY_PORT_OFFSET		0x44
+#define SA5_INTR_STATUS		0x30
+#define SA5_SCRATCHPAD_OFFSET	0xB0
+
+#define SA5_CTCFG_OFFSET	0xB4
+#define SA5_CTMEM_OFFSET	0xB8
+
+#define SA5_INTR_OFF		0x08
+#define SA5B_INTR_OFF		0x04
+#define SA5_INTR_PENDING	0x08
+#define SA5B_INTR_PENDING	0x04
+#define FIFO_EMPTY		0xffffffff
+#define HPSA_FIRMWARE_READY	0xffff0000 /* value in scratchpad register */
+
+#define HPSA_ERROR_BIT		0x02
+#define HPSA_TAG_CONTAINS_INDEX(tag) ((tag) & 0x04)
+#define HPSA_TAG_TO_INDEX(tag) ((tag) >> 3)
+#define HPSA_TAG_DISCARD_ERROR_BITS(tag) ((tag) & ~3)
+
+#define HPSA_INTR_ON 	1
+#define HPSA_INTR_OFF	0
+/*
+	Send the command to the hardware
+*/
+static void SA5_submit_command(struct ctlr_info *h,
+	struct CommandList *c)
+{
+#ifdef HPSA_DEBUG
+	 printk(KERN_WARNING "hpsa: Sending %x - down to controller\n",
+		c->busaddr);
+#endif /* HPSA_DEBUG */
+	writel(c->busaddr, h->vaddr + SA5_REQUEST_PORT_OFFSET);
+	h->commands_outstanding++;
+	if (h->commands_outstanding > h->max_outstanding)
+		h->max_outstanding = h->commands_outstanding;
+}
+
+/*
+ *  This card is the opposite of the other cards.
+ *   0 turns interrupts on...
+ *   0x08 turns them off...
+ */
+static void SA5_intr_mask(struct ctlr_info *h, unsigned long val)
+{
+	if (val) { /* Turn interrupts on */
+		h->interrupts_enabled = 1;
+		writel(0, h->vaddr + SA5_REPLY_INTR_MASK_OFFSET);
+	} else { /* Turn them off */
+		h->interrupts_enabled = 0;
+		writel(SA5_INTR_OFF,
+			h->vaddr + SA5_REPLY_INTR_MASK_OFFSET);
+	}
+}
+/*
+ *  Returns true if fifo is full.
+ *
+ */
+static unsigned long SA5_fifo_full(struct ctlr_info *h)
+{
+	if (h->commands_outstanding >= h->max_commands)
+		return 1;
+	else
+		return 0;
+
+}
+/*
+ *   returns value read from hardware.
+ *     returns FIFO_EMPTY if there is nothing to read
+ */
+static unsigned long SA5_completed(struct ctlr_info *h)
+{
+	unsigned long register_value
+		= readl(h->vaddr + SA5_REPLY_PORT_OFFSET);
+
+	if (register_value != FIFO_EMPTY)
+		h->commands_outstanding--;
+
+#ifdef HPSA_DEBUG
+	if (register_value != FIFO_EMPTY)
+		printk(KERN_INFO "hpsa:  Read %lx back from board\n",
+			register_value);
+	else
+		printk(KERN_INFO "hpsa:  FIFO Empty read\n");
+#endif
+
+	return register_value;
+}
+/*
+ *	Returns true if an interrupt is pending..
+ */
+static unsigned long SA5_intr_pending(struct ctlr_info *h)
+{
+	unsigned long register_value  =
+		readl(h->vaddr + SA5_INTR_STATUS);
+#ifdef HPSA_DEBUG
+	printk(KERN_INFO "hpsa: intr_pending %lx\n", register_value);
+#endif  /* HPSA_DEBUG */
+	if (register_value &  SA5_INTR_PENDING)
+		return  1;
+	return 0 ;
+}
+
+
+static struct access_method SA5_access = {
+	SA5_submit_command,
+	SA5_intr_mask,
+	SA5_fifo_full,
+	SA5_intr_pending,
+	SA5_completed,
+};
+
+struct board_type {
+	__u32	board_id;
+	char	*product_name;
+	struct access_method *access;
+};
+
+
+/* end of old hpsa_scsi.h file */
+
+#endif /* HPSA_H */
+
