commit 35c3363363ac7c8877b4984cdd8a2af377a4e92e
Author: Finn Thain <fthain@telegraphics.com.au>
Date:   Sat Nov 2 12:06:54 2019 +1100

    scsi: core: Clean up SG_NONE
    
    Remove SG_NONE and a related misleading comment. Update documentation.
    
    This patch does not affect behaviour as zero initialization is redundant.
    
    Cc: Jonathan Corbet <corbet@lwn.net>
    Cc: Bartlomiej Zolnierkiewicz <b.zolnierkie@samsung.com>
    Cc: Jens Axboe <axboe@kernel.dk>
    Cc: Viresh Kumar <vireshk@kernel.org>
    Cc: Oliver Neukum <oneukum@suse.com>
    Cc: Alan Stern <stern@rowland.harvard.edu>
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Cc: usb-storage@lists.one-eyed-alien.net
    Link: https://lore.kernel.org/r/b4779b7a6563f6bd8d259ee457871c1c463c420e.1572656814.git.fthain@telegraphics.com.au
    Signed-off-by: Finn Thain <fthain@telegraphics.com.au>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/atp870u.c b/drivers/scsi/atp870u.c
index e41f0bbdc9fd..c6a752309dda 100644
--- a/drivers/scsi/atp870u.c
+++ b/drivers/scsi/atp870u.c
@@ -1680,7 +1680,7 @@ static struct scsi_host_template atp870u_template = {
      .bios_param        	= atp870u_biosparam	/* biosparm */,
      .can_queue         	= qcnt			/* can_queue */,
      .this_id           	= 7			/* SCSI ID */,
-     .sg_tablesize      	= ATP870U_SCATTER	/*SG_ALL*/ /*SG_NONE*/,
+     .sg_tablesize      	= ATP870U_SCATTER	/*SG_ALL*/,
      .max_sectors		= ATP870U_MAX_SECTORS,
 };
 

commit 09c434b8a0047c69e48499de0107de312901e798
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Sun May 19 13:08:20 2019 +0100

    treewide: Add SPDX license identifier for more missed files
    
    Add SPDX license identifiers to all files which:
    
     - Have no license information of any form
    
     - Have MODULE_LICENCE("GPL*") inside which was used in the initial
       scan/conversion to ignore the file
    
    These files fall under the project license, GPL v2 only. The resulting SPDX
    license identifier is:
    
      GPL-2.0-only
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/scsi/atp870u.c b/drivers/scsi/atp870u.c
index 446a789cdaf5..e41f0bbdc9fd 100644
--- a/drivers/scsi/atp870u.c
+++ b/drivers/scsi/atp870u.c
@@ -1,3 +1,4 @@
+// SPDX-License-Identifier: GPL-2.0-only
 /* 
  *  Copyright (C) 1997	Wu Ching Chen
  *  2.1.x update (C) 1998  Krzysztof G. Baranowski

commit 22c0738b645246a90c423395372f25faf09b0625
Author: Colin Ian King <colin.king@canonical.com>
Date:   Tue Jan 22 15:10:30 2019 +0000

    scsi: atp870u: clean up code style and indentation issues
    
    Clean up { brace to fix cppcheck warning. Remove some trailing spaces at
    end of a statement.  Also clean up an indentation issue.
    
    Signed-off-by: Colin Ian King <colin.king@canonical.com>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/atp870u.c b/drivers/scsi/atp870u.c
index 1267200380f8..446a789cdaf5 100644
--- a/drivers/scsi/atp870u.c
+++ b/drivers/scsi/atp870u.c
@@ -194,12 +194,11 @@ static irqreturn_t atp870u_intr_handle(int irq, void *dev_id)
 				((unsigned char *) &adrcnt)[2] = atp_readb_io(dev, c, 0x12);
 				((unsigned char *) &adrcnt)[1] = atp_readb_io(dev, c, 0x13);
 				((unsigned char *) &adrcnt)[0] = atp_readb_io(dev, c, 0x14);
-				if (dev->id[c][target_id].last_len != adrcnt)
-				{
-			   		k = dev->id[c][target_id].last_len;
+				if (dev->id[c][target_id].last_len != adrcnt) {
+					k = dev->id[c][target_id].last_len;
 			   		k -= adrcnt;
 			   		dev->id[c][target_id].tran_len = k;			   
-			   	dev->id[c][target_id].last_len = adrcnt;			   
+					dev->id[c][target_id].last_len = adrcnt;
 				}
 #ifdef ED_DBGP
 				printk("dev->id[c][target_id].last_len = %d dev->id[c][target_id].tran_len = %d\n",dev->id[c][target_id].last_len,dev->id[c][target_id].tran_len);

commit 2a3d4eb8e228061c09d5ca8bf39e7f00c2091213
Author: Christoph Hellwig <hch@lst.de>
Date:   Thu Dec 13 16:17:02 2018 +0100

    scsi: flip the default on use_clustering
    
    Most SCSI drivers want to enable "clustering", that is merging of
    segments so that they might span more than a single page.  Remove the
    ENABLE_CLUSTERING define, and require drivers to explicitly set
    DISABLE_CLUSTERING to disable this feature.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/atp870u.c b/drivers/scsi/atp870u.c
index 802d15018ec0..1267200380f8 100644
--- a/drivers/scsi/atp870u.c
+++ b/drivers/scsi/atp870u.c
@@ -1681,7 +1681,6 @@ static struct scsi_host_template atp870u_template = {
      .can_queue         	= qcnt			/* can_queue */,
      .this_id           	= 7			/* SCSI ID */,
      .sg_tablesize      	= ATP870U_SCATTER	/*SG_ALL*/ /*SG_NONE*/,
-     .use_clustering    	= ENABLE_CLUSTERING,
      .max_sectors		= ATP870U_MAX_SECTORS,
 };
 

commit 48ecddb41b741d4e530d88903757d26058fce2a5
Author: Christoph Hellwig <hch@lst.de>
Date:   Wed Oct 10 18:14:14 2018 +0200

    scsi: atp870u: switch to generic DMA API
    
    Switch from the legacy PCI DMA API to the generic DMA API.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Reviewed-by: Johannes Thumshirn <jthumshirn@suse.de>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/atp870u.c b/drivers/scsi/atp870u.c
index 8996d2329e11..802d15018ec0 100644
--- a/drivers/scsi/atp870u.c
+++ b/drivers/scsi/atp870u.c
@@ -1193,7 +1193,7 @@ static void atp870u_free_tables(struct Scsi_Host *host)
 		for (k = 0; k < 16; k++) {
 			if (!atp_dev->id[j][k].prd_table)
 				continue;
-			pci_free_consistent(atp_dev->pdev, 1024, atp_dev->id[j][k].prd_table, atp_dev->id[j][k].prd_bus);
+			dma_free_coherent(&atp_dev->pdev->dev, 1024, atp_dev->id[j][k].prd_table, atp_dev->id[j][k].prd_bus);
 			atp_dev->id[j][k].prd_table = NULL;
 		}
 	}
@@ -1205,7 +1205,7 @@ static int atp870u_init_tables(struct Scsi_Host *host)
 	int c,k;
 	for(c=0;c < 2;c++) {
 	   	for(k=0;k<16;k++) {
-	   			atp_dev->id[c][k].prd_table = pci_alloc_consistent(atp_dev->pdev, 1024, &(atp_dev->id[c][k].prd_bus));
+				atp_dev->id[c][k].prd_table = dma_alloc_coherent(&atp_dev->pdev->dev, 1024, &(atp_dev->id[c][k].prd_bus), GFP_KERNEL);
 	   			if (!atp_dev->id[c][k].prd_table) {
 	   				printk("atp870u_init_tables fail\n");
 				atp870u_free_tables(host);
@@ -1509,7 +1509,7 @@ static int atp870u_probe(struct pci_dev *pdev, const struct pci_device_id *ent)
 	if (err)
 		goto fail;
 
-	if (pci_set_dma_mask(pdev, DMA_BIT_MASK(32))) {
+	if (dma_set_mask(&pdev->dev, DMA_BIT_MASK(32))) {
                 printk(KERN_ERR "atp870u: DMA mask required but not available.\n");
                 err = -EIO;
                 goto disable_device;

commit dcaa0c12661d862bc533239da22ddf2ed90595e7
Author: Jia-Ju Bai <baijiaju1990@gmail.com>
Date:   Fri Jul 27 17:13:17 2018 +0800

    scsi: atp870u: Replace mdelay() with msleep()
    
    tscam(), atp870_init(), atp880_init() and atp885_init() are never
    called in atomic context.
    They call mdelay() to busily wait, which is not necessary.
    mdelay() can be replaced with msleep().
    
    This is found by a static analysis tool named DCNS written by myself.
    
    Signed-off-by: Jia-Ju Bai <baijiaju1990@gmail.com>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/atp870u.c b/drivers/scsi/atp870u.c
index b46997cf77e2..8996d2329e11 100644
--- a/drivers/scsi/atp870u.c
+++ b/drivers/scsi/atp870u.c
@@ -1055,7 +1055,7 @@ static void tscam(struct Scsi_Host *host, bool wide_chip, u8 scam_on)
 	udelay(2);		/* 2 deskew delay(45ns*2=90ns) */
 	val &= 0x007f;		/* no bsy  */
 	atp_writew_io(dev, 0, 0x1c, val);
-	mdelay(128);
+	msleep(128);
 	val &= 0x00fb;		/* after 1ms no msg */
 	atp_writew_io(dev, 0, 0x1c, val);
 	while ((atp_readb_io(dev, 0, 0x1c) & 0x04) != 0)
@@ -1286,9 +1286,9 @@ static void atp870_init(struct Scsi_Host *shpnt)
 	k = (atp_readb_base(atpdev, 0x3a) & 0xf3) | 0x10;
 	atp_writeb_base(atpdev, 0x3a, k);
 	atp_writeb_base(atpdev, 0x3a, k & 0xdf);
-	mdelay(32);
+	msleep(32);
 	atp_writeb_base(atpdev, 0x3a, k);
-	mdelay(32);
+	msleep(32);
 	atp_set_host_id(atpdev, 0, host_id);
 
 	tscam(shpnt, wide_chip, scam_on);
@@ -1370,9 +1370,9 @@ static void atp880_init(struct Scsi_Host *shpnt)
 	k = atp_readb_base(atpdev, 0x38) & 0x80;
 	atp_writeb_base(atpdev, 0x38, k);
 	atp_writeb_base(atpdev, 0x3b, 0x20);
-	mdelay(32);
+	msleep(32);
 	atp_writeb_base(atpdev, 0x3b, 0);
-	mdelay(32);
+	msleep(32);
 	atp_readb_io(atpdev, 0, 0x1b);
 	atp_readb_io(atpdev, 0, 0x17);
 
@@ -1454,10 +1454,10 @@ static void atp885_init(struct Scsi_Host *shpnt)
 	atp_writeb_base(atpdev, 0x28, k);
 	atp_writeb_pci(atpdev, 0, 1, 0x80);
 	atp_writeb_pci(atpdev, 1, 1, 0x80);
-	mdelay(100);
+	msleep(100);
 	atp_writeb_pci(atpdev, 0, 1, 0);
 	atp_writeb_pci(atpdev, 1, 1, 0);
-	mdelay(1000);
+	msleep(1000);
 	atp_readb_io(atpdev, 0, 0x1b);
 	atp_readb_io(atpdev, 0, 0x17);
 	atp_readb_io(atpdev, 1, 0x1b);
@@ -1473,7 +1473,7 @@ static void atp885_init(struct Scsi_Host *shpnt)
 		k = (k & 0x07) | 0x40;
 	atp_set_host_id(atpdev, 1, k);
 
-	mdelay(600); /* this delay used to be called tscam_885() */
+	msleep(600); /* this delay used to be called tscam_885() */
 	dev_info(&pdev->dev, "Scanning Channel A SCSI Device ...\n");
 	atp_is(atpdev, 0, true, atp_readb_io(atpdev, 0, 0x1b) >> 7);
 	atp_writeb_io(atpdev, 0, 0x16, 0x80);

commit 29e79e0fa9b86535c2f1442d080c8cb5dec8606b
Author: Dan Carpenter <dan.carpenter@oracle.com>
Date:   Wed Feb 14 15:02:31 2018 +0300

    scsi: atp870u: 64 bit bug in atp885_init()
    
    On 64 bit CPUs there is a memory corruption bug on probe().  It should
    be a u32 pointer instead of an unsigned long pointer or we write past
    the end of the setupdata[] array.
    
    Signed-off-by: Dan Carpenter <dan.carpenter@oracle.com>
    Reviewed-by: Hannes Reinecke <hare@suse.com>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/atp870u.c b/drivers/scsi/atp870u.c
index 8b52a9dbb9cf..b46997cf77e2 100644
--- a/drivers/scsi/atp870u.c
+++ b/drivers/scsi/atp870u.c
@@ -1413,11 +1413,11 @@ static void atp885_init(struct Scsi_Host *shpnt)
 			atpdev->global_map[m] = 0;
 			for (k = 0; k < 4; k++) {
 				atp_writew_base(atpdev, 0x3c, n++);
-				((unsigned long *)&setupdata[m][0])[k] = atp_readl_base(atpdev, 0x38);
+				((u32 *)&setupdata[m][0])[k] = atp_readl_base(atpdev, 0x38);
 			}
 			for (k = 0; k < 4; k++) {
 				atp_writew_base(atpdev, 0x3c, n++);
-				((unsigned long *)&atpdev->sp[m][0])[k] = atp_readl_base(atpdev, 0x38);
+				((u32 *)&atpdev->sp[m][0])[k] = atp_readl_base(atpdev, 0x38);
 			}
 			n += 8;
 		}

commit 4190230edbbe8864f04610900249db3738e2f51c
Author: Ondrej Zary <linux@rainbow-software.org>
Date:   Tue Nov 17 19:24:28 2015 +0100

    atp870u: Introduce atp870_init()
    
    Move 870-specific init code to a separate function atp870_init()
    
    Signed-off-by: Ondrej Zary <linux@rainbow-software.org>
    Reviewed-by: Hannes Reinicke <hare@suse.de>
    Acked-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/atp870u.c b/drivers/scsi/atp870u.c
index 584b90f46212..8b52a9dbb9cf 100644
--- a/drivers/scsi/atp870u.c
+++ b/drivers/scsi/atp870u.c
@@ -1249,6 +1249,57 @@ static void atp_set_host_id(struct atp_unit *atp, u8 c, u8 host_id)
 	atp_writeb_io(atp, c, 0x11, 0x20);
 }
 
+static void atp870_init(struct Scsi_Host *shpnt)
+{
+	struct atp_unit *atpdev = shost_priv(shpnt);
+	struct pci_dev *pdev = atpdev->pdev;
+	unsigned char k, host_id;
+	u8 scam_on;
+	bool wide_chip =
+		(pdev->device == PCI_DEVICE_ID_ARTOP_AEC7610 &&
+		 pdev->revision == 4) ||
+		(pdev->device == PCI_DEVICE_ID_ARTOP_AEC7612UW) ||
+		(pdev->device == PCI_DEVICE_ID_ARTOP_AEC7612SUW);
+
+	pci_read_config_byte(pdev, 0x49, &host_id);
+
+	dev_info(&pdev->dev, "ACARD AEC-671X PCI Ultra/W SCSI-2/3 Host Adapter: IO:%lx, IRQ:%d.\n",
+		 shpnt->io_port, shpnt->irq);
+
+	atpdev->ioport[0] = shpnt->io_port;
+	atpdev->pciport[0] = shpnt->io_port + 0x20;
+	host_id &= 0x07;
+	atpdev->host_id[0] = host_id;
+	scam_on = atp_readb_pci(atpdev, 0, 2);
+	atpdev->global_map[0] = atp_readb_base(atpdev, 0x2d);
+	atpdev->ultra_map[0] = atp_readw_base(atpdev, 0x2e);
+
+	if (atpdev->ultra_map[0] == 0) {
+		scam_on = 0x00;
+		atpdev->global_map[0] = 0x20;
+		atpdev->ultra_map[0] = 0xffff;
+	}
+
+	if (pdev->revision > 0x07)	/* check if atp876 chip */
+		atp_writeb_base(atpdev, 0x3e, 0x00); /* enable terminator */
+
+	k = (atp_readb_base(atpdev, 0x3a) & 0xf3) | 0x10;
+	atp_writeb_base(atpdev, 0x3a, k);
+	atp_writeb_base(atpdev, 0x3a, k & 0xdf);
+	mdelay(32);
+	atp_writeb_base(atpdev, 0x3a, k);
+	mdelay(32);
+	atp_set_host_id(atpdev, 0, host_id);
+
+	tscam(shpnt, wide_chip, scam_on);
+	atp_writeb_base(atpdev, 0x3a, atp_readb_base(atpdev, 0x3a) | 0x10);
+	atp_is(atpdev, 0, wide_chip, 0);
+	atp_writeb_base(atpdev, 0x3a, atp_readb_base(atpdev, 0x3a) & 0xef);
+	atp_writeb_base(atpdev, 0x3b, atp_readb_base(atpdev, 0x3b) | 0x20);
+	shpnt->max_id = wide_chip ? 16 : 8;
+	shpnt->this_id = host_id;
+}
+
 static void atp880_init(struct Scsi_Host *shpnt)
 {
 	struct atp_unit *atpdev = shost_priv(shpnt);
@@ -1445,9 +1496,6 @@ static void atp885_init(struct Scsi_Host *shpnt)
 /* return non-zero on detection */
 static int atp870u_probe(struct pci_dev *pdev, const struct pci_device_id *ent)
 {
-	unsigned char k;
-	unsigned int error;
-	unsigned char host_id;
 	struct Scsi_Host *shpnt = NULL;
 	struct atp_unit *atpdev;
 	int err;
@@ -1500,53 +1548,9 @@ static int atp870u_probe(struct pci_dev *pdev, const struct pci_device_id *ent)
 		atp880_init(shpnt);
 	else if (is885(atpdev))
 		atp885_init(shpnt);
-	else {
-		u8 scam_on;
-		bool wide_chip =
-			(ent->device == PCI_DEVICE_ID_ARTOP_AEC7610 &&
-			 pdev->revision == 4) ||
-			(ent->device == PCI_DEVICE_ID_ARTOP_AEC7612UW) ||
-			(ent->device == PCI_DEVICE_ID_ARTOP_AEC7612SUW);
-		error = pci_read_config_byte(pdev, 0x49, &host_id);
-
-		printk(KERN_INFO "   ACARD AEC-671X PCI Ultra/W SCSI-2/3 Host Adapter: "
-			"IO:%lx, IRQ:%d.\n", shpnt->io_port, shpnt->irq);
-
-		atpdev->ioport[0] = shpnt->io_port;
-		atpdev->pciport[0] = shpnt->io_port + 0x20;
-		host_id &= 0x07;
-		atpdev->host_id[0] = host_id;
-		scam_on = atp_readb_pci(atpdev, 0, 2);
-		atpdev->global_map[0] = atp_readb_base(atpdev, 0x2d);
-		atpdev->ultra_map[0] = atp_readw_base(atpdev, 0x2e);
-
-		if (atpdev->ultra_map[0] == 0) {
-			scam_on = 0x00;
-			atpdev->global_map[0] = 0x20;
-			atpdev->ultra_map[0] = 0xffff;
-		}
-
-		if (pdev->revision > 0x07)	/* check if atp876 chip then enable terminator */
-			atp_writeb_base(atpdev, 0x3e, 0x00);
- 
-		k = (atp_readb_base(atpdev, 0x3a) & 0xf3) | 0x10;
-		atp_writeb_base(atpdev, 0x3a, k);
-		atp_writeb_base(atpdev, 0x3a, k & 0xdf);
-		mdelay(32);
-		atp_writeb_base(atpdev, 0x3a, k);
-		mdelay(32);
-		atp_set_host_id(atpdev, 0, host_id);
-
-
-		tscam(shpnt, wide_chip, scam_on);
-		atp_writeb_base(atpdev, 0x3a, atp_readb_base(atpdev, 0x3a) | 0x10);
-		atp_is(atpdev, 0, wide_chip, 0);
-		atp_writeb_base(atpdev, 0x3a, atp_readb_base(atpdev, 0x3a) & 0xef);
-		atp_writeb_base(atpdev, 0x3b, atp_readb_base(atpdev, 0x3b) | 0x20);
-		shpnt->max_id = wide_chip ? 16 : 8;
-		shpnt->this_id = host_id;
-
-	} 
+	else
+		atp870_init(shpnt);
+
 	err = request_irq(shpnt->irq, atp870u_intr_handle, IRQF_SHARED, "atp870u", shpnt);
 	if (err) {
 		dev_err(&pdev->dev, "Unable to allocate IRQ %d.\n", shpnt->irq);

commit ecc6ff95d1a84f0a025112e071be40dd905a5168
Author: Ondrej Zary <linux@rainbow-software.org>
Date:   Tue Nov 17 19:24:27 2015 +0100

    atp870u: Introduce atp885_init()
    
    Move 885-specific init code to a separate function atp885_init()
    
    Signed-off-by: Ondrej Zary <linux@rainbow-software.org>
    Reviewed-by: Hannes Reinicke <hare@suse.de>
    Acked-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/atp870u.c b/drivers/scsi/atp870u.c
index c1fd9fb8d40f..584b90f46212 100644
--- a/drivers/scsi/atp870u.c
+++ b/drivers/scsi/atp870u.c
@@ -1334,15 +1334,122 @@ static void atp880_init(struct Scsi_Host *shpnt)
 	shpnt->this_id = host_id;
 }
 
+static void atp885_init(struct Scsi_Host *shpnt)
+{
+	struct atp_unit *atpdev = shost_priv(shpnt);
+	struct pci_dev *pdev = atpdev->pdev;
+	unsigned char k, m, c;
+	unsigned int n;
+	unsigned char setupdata[2][16];
+
+	dev_info(&pdev->dev, "ACARD AEC-67162 PCI Ultra3 LVD Host Adapter: IO:%lx, IRQ:%d.\n",
+		 shpnt->io_port, shpnt->irq);
+
+	atpdev->ioport[0] = shpnt->io_port + 0x80;
+	atpdev->ioport[1] = shpnt->io_port + 0xc0;
+	atpdev->pciport[0] = shpnt->io_port + 0x40;
+	atpdev->pciport[1] = shpnt->io_port + 0x50;
+
+	c = atp_readb_base(atpdev, 0x29);
+	atp_writeb_base(atpdev, 0x29, c | 0x04);
+
+	n = 0x1f80;
+	while (n < 0x2000) {
+		atp_writew_base(atpdev, 0x3c, n);
+		if (atp_readl_base(atpdev, 0x38) == 0xffffffff)
+			break;
+		for (m = 0; m < 2; m++) {
+			atpdev->global_map[m] = 0;
+			for (k = 0; k < 4; k++) {
+				atp_writew_base(atpdev, 0x3c, n++);
+				((unsigned long *)&setupdata[m][0])[k] = atp_readl_base(atpdev, 0x38);
+			}
+			for (k = 0; k < 4; k++) {
+				atp_writew_base(atpdev, 0x3c, n++);
+				((unsigned long *)&atpdev->sp[m][0])[k] = atp_readl_base(atpdev, 0x38);
+			}
+			n += 8;
+		}
+	}
+	c = atp_readb_base(atpdev, 0x29);
+	atp_writeb_base(atpdev, 0x29, c & 0xfb);
+	for (c = 0; c < 2; c++) {
+		atpdev->ultra_map[c] = 0;
+		atpdev->async[c] = 0;
+		for (k = 0; k < 16; k++) {
+			n = 1 << k;
+			if (atpdev->sp[c][k] > 1)
+				atpdev->ultra_map[c] |= n;
+			else
+				if (atpdev->sp[c][k] == 0)
+					atpdev->async[c] |= n;
+		}
+		atpdev->async[c] = ~(atpdev->async[c]);
+
+		if (atpdev->global_map[c] == 0) {
+			k = setupdata[c][1];
+			if ((k & 0x40) != 0)
+				atpdev->global_map[c] |= 0x20;
+			k &= 0x07;
+			atpdev->global_map[c] |= k;
+			if ((setupdata[c][2] & 0x04) != 0)
+				atpdev->global_map[c] |= 0x08;
+			atpdev->host_id[c] = setupdata[c][0] & 0x07;
+		}
+	}
+
+	k = atp_readb_base(atpdev, 0x28) & 0x8f;
+	k |= 0x10;
+	atp_writeb_base(atpdev, 0x28, k);
+	atp_writeb_pci(atpdev, 0, 1, 0x80);
+	atp_writeb_pci(atpdev, 1, 1, 0x80);
+	mdelay(100);
+	atp_writeb_pci(atpdev, 0, 1, 0);
+	atp_writeb_pci(atpdev, 1, 1, 0);
+	mdelay(1000);
+	atp_readb_io(atpdev, 0, 0x1b);
+	atp_readb_io(atpdev, 0, 0x17);
+	atp_readb_io(atpdev, 1, 0x1b);
+	atp_readb_io(atpdev, 1, 0x17);
+
+	k = atpdev->host_id[0];
+	if (k > 7)
+		k = (k & 0x07) | 0x40;
+	atp_set_host_id(atpdev, 0, k);
+
+	k = atpdev->host_id[1];
+	if (k > 7)
+		k = (k & 0x07) | 0x40;
+	atp_set_host_id(atpdev, 1, k);
+
+	mdelay(600); /* this delay used to be called tscam_885() */
+	dev_info(&pdev->dev, "Scanning Channel A SCSI Device ...\n");
+	atp_is(atpdev, 0, true, atp_readb_io(atpdev, 0, 0x1b) >> 7);
+	atp_writeb_io(atpdev, 0, 0x16, 0x80);
+	dev_info(&pdev->dev, "Scanning Channel B SCSI Device ...\n");
+	atp_is(atpdev, 1, true, atp_readb_io(atpdev, 1, 0x1b) >> 7);
+	atp_writeb_io(atpdev, 1, 0x16, 0x80);
+	k = atp_readb_base(atpdev, 0x28) & 0xcf;
+	k |= 0xc0;
+	atp_writeb_base(atpdev, 0x28, k);
+	k = atp_readb_base(atpdev, 0x1f) | 0x80;
+	atp_writeb_base(atpdev, 0x1f, k);
+	k = atp_readb_base(atpdev, 0x29) | 0x01;
+	atp_writeb_base(atpdev, 0x29, k);
+	shpnt->max_id = 16;
+	shpnt->max_lun = (atpdev->global_map[0] & 0x07) + 1;
+	shpnt->max_channel = 1;
+	shpnt->this_id = atpdev->host_id[0];
+}
+
 /* return non-zero on detection */
 static int atp870u_probe(struct pci_dev *pdev, const struct pci_device_id *ent)
 {
-	unsigned char k, m, c;
-	unsigned int error,n;
+	unsigned char k;
+	unsigned int error;
 	unsigned char host_id;
 	struct Scsi_Host *shpnt = NULL;
 	struct atp_unit *atpdev;
-	unsigned char setupdata[2][16];
 	int err;
 
 	if (ent->device == PCI_DEVICE_ID_ARTOP_AEC7610 && pdev->revision < 2) {
@@ -1391,121 +1498,9 @@ static int atp870u_probe(struct pci_dev *pdev, const struct pci_device_id *ent)
 
 	if (is880(atpdev))
 		atp880_init(shpnt);
-	else if (is885(atpdev)) {
-			printk(KERN_INFO "   ACARD AEC-67162 PCI Ultra3 LVD Host Adapter:  IO:%lx, IRQ:%d.\n"
-			       , shpnt->io_port, shpnt->irq);
-        	
-		atpdev->pdev = pdev;
-		atpdev->ioport[0] = shpnt->io_port + 0x80;
-		atpdev->ioport[1] = shpnt->io_port + 0xc0;
-		atpdev->pciport[0] = shpnt->io_port + 0x40;
-		atpdev->pciport[1] = shpnt->io_port + 0x50;
-				
-		c = atp_readb_base(atpdev, 0x29);
-		atp_writeb_base(atpdev, 0x29, c | 0x04);
-        	
-		n=0x1f80;
-next_fblk_885:
-		if (n >= 0x2000) {
-		   goto flash_ok_885;
-		}
-		atp_writew_base(atpdev, 0x3c, n);
-		if (atp_readl_base(atpdev, 0x38) == 0xffffffff) {
-		   goto flash_ok_885;
-		}
-		for (m=0; m < 2; m++) {
-		    atpdev->global_map[m]= 0;
-		    for (k=0; k < 4; k++) {
-			atp_writew_base(atpdev, 0x3c, n++);
-			((unsigned long *)&setupdata[m][0])[k] = atp_readl_base(atpdev, 0x38);
-		    }
-		    for (k=0; k < 4; k++) {
-			atp_writew_base(atpdev, 0x3c, n++);
-			((unsigned long *)&atpdev->sp[m][0])[k] = atp_readl_base(atpdev, 0x38);
-		    }
-		    n += 8;
-		}
-		goto next_fblk_885;
-flash_ok_885:
-#ifdef ED_DBGP
-		printk( "Flash Read OK\n");
-#endif	
-		c = atp_readb_base(atpdev, 0x29);
-		atp_writeb_base(atpdev, 0x29, c & 0xfb);
-		for (c=0;c < 2;c++) {
-		    atpdev->ultra_map[c]=0;
-		    atpdev->async[c] = 0;
-		    for (k=0; k < 16; k++) {
-			n=1;
-			n = n << k;
-			if (atpdev->sp[c][k] > 1) {
-			   atpdev->ultra_map[c] |= n;
-			} else {
-			   if (atpdev->sp[c][k] == 0) {
-			      atpdev->async[c] |= n;
-			   }
-			}
-		    }
-		    atpdev->async[c] = ~(atpdev->async[c]);
-
-		    if (atpdev->global_map[c] == 0) {
-		       k=setupdata[c][1];
-		       if ((k & 0x40) != 0)
-			  atpdev->global_map[c] |= 0x20;
-		       k &= 0x07;
-		       atpdev->global_map[c] |= k;
-		       if ((setupdata[c][2] & 0x04) != 0)
-			  atpdev->global_map[c] |= 0x08;
-		       atpdev->host_id[c] = setupdata[c][0] & 0x07;
-		    }
-		}
-
-		k = atp_readb_base(atpdev, 0x28) & 0x8f;
-		k |= 0x10;
-		atp_writeb_base(atpdev, 0x28, k);
-		atp_writeb_pci(atpdev, 0, 1, 0x80);
-		atp_writeb_pci(atpdev, 1, 1, 0x80);
-		mdelay(100);
-		atp_writeb_pci(atpdev, 0, 1, 0);
-		atp_writeb_pci(atpdev, 1, 1, 0);
-		mdelay(1000);
-		atp_readb_io(atpdev, 0, 0x1b);
-		atp_readb_io(atpdev, 0, 0x17);
-		atp_readb_io(atpdev, 1, 0x1b);
-		atp_readb_io(atpdev, 1, 0x17);
-
-		k=atpdev->host_id[0];
-		if (k > 7)
-		   k = (k & 0x07) | 0x40;
-		atp_set_host_id(atpdev, 0, k);
-
-		k=atpdev->host_id[1];
-		if (k > 7)
-		   k = (k & 0x07) | 0x40;
-		atp_set_host_id(atpdev, 1, k);
-
-		mdelay(600); /* this delay used to be called tscam_885() */
-		printk(KERN_INFO "   Scanning Channel A SCSI Device ...\n");
-		atp_is(atpdev, 0, true, atp_readb_io(atpdev, 0, 0x1b) >> 7);
-		atp_writeb_io(atpdev, 0, 0x16, 0x80);
-		printk(KERN_INFO "   Scanning Channel B SCSI Device ...\n");
-		atp_is(atpdev, 1, true, atp_readb_io(atpdev, 1, 0x1b) >> 7);
-		atp_writeb_io(atpdev, 1, 0x16, 0x80);
-		k = atp_readb_base(atpdev, 0x28) & 0xcf;
-		k |= 0xc0;
-		atp_writeb_base(atpdev, 0x28, k);
-		k = atp_readb_base(atpdev, 0x1f) | 0x80;
-		atp_writeb_base(atpdev, 0x1f, k);
-		k = atp_readb_base(atpdev, 0x29) | 0x01;
-		atp_writeb_base(atpdev, 0x29, k);
-#ifdef ED_DBGP
-		//printk("atp885: atp_host[0] 0x%p\n", atp_host[0]);
-#endif		
-		shpnt->max_id = 16;
-		shpnt->max_lun = (atpdev->global_map[0] & 0x07) + 1;
-		shpnt->max_channel = 1;
-		shpnt->this_id = atpdev->host_id[0];
-	} else {
+	else if (is885(atpdev))
+		atp885_init(shpnt);
+	else {
 		u8 scam_on;
 		bool wide_chip =
 			(ent->device == PCI_DEVICE_ID_ARTOP_AEC7610 &&

commit c7e6a0298d56694d79189cd9127ac8ec1c2275ca
Author: Ondrej Zary <linux@rainbow-software.org>
Date:   Tue Nov 17 19:24:26 2015 +0100

    atp870u: Introduce atp880_init()
    
    Move 880-specific init code to a separate function atp880_init()
    
    Signed-off-by: Ondrej Zary <linux@rainbow-software.org>
    Reviewed-by: Hannes Reinicke <hare@suse.de>
    Acked-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/atp870u.c b/drivers/scsi/atp870u.c
index 3c66539e5781..c1fd9fb8d40f 100644
--- a/drivers/scsi/atp870u.c
+++ b/drivers/scsi/atp870u.c
@@ -1249,6 +1249,91 @@ static void atp_set_host_id(struct atp_unit *atp, u8 c, u8 host_id)
 	atp_writeb_io(atp, c, 0x11, 0x20);
 }
 
+static void atp880_init(struct Scsi_Host *shpnt)
+{
+	struct atp_unit *atpdev = shost_priv(shpnt);
+	struct pci_dev *pdev = atpdev->pdev;
+	unsigned char k, m, host_id;
+	unsigned int n;
+
+	pci_write_config_byte(pdev, PCI_LATENCY_TIMER, 0x80);
+
+	atpdev->ioport[0] = shpnt->io_port + 0x40;
+	atpdev->pciport[0] = shpnt->io_port + 0x28;
+
+	host_id = atp_readb_base(atpdev, 0x39) >> 4;
+
+	dev_info(&pdev->dev, "ACARD AEC-67160 PCI Ultra3 LVD Host Adapter: IO:%lx, IRQ:%d.\n",
+		 shpnt->io_port, shpnt->irq);
+	atpdev->host_id[0] = host_id;
+
+	atpdev->global_map[0] = atp_readb_base(atpdev, 0x35);
+	atpdev->ultra_map[0] = atp_readw_base(atpdev, 0x3c);
+
+	n = 0x3f09;
+	while (n < 0x4000) {
+		m = 0;
+		atp_writew_base(atpdev, 0x34, n);
+		n += 0x0002;
+		if (atp_readb_base(atpdev, 0x30) == 0xff)
+			break;
+
+		atpdev->sp[0][m++] = atp_readb_base(atpdev, 0x30);
+		atpdev->sp[0][m++] = atp_readb_base(atpdev, 0x31);
+		atpdev->sp[0][m++] = atp_readb_base(atpdev, 0x32);
+		atpdev->sp[0][m++] = atp_readb_base(atpdev, 0x33);
+		atp_writew_base(atpdev, 0x34, n);
+		n += 0x0002;
+		atpdev->sp[0][m++] = atp_readb_base(atpdev, 0x30);
+		atpdev->sp[0][m++] = atp_readb_base(atpdev, 0x31);
+		atpdev->sp[0][m++] = atp_readb_base(atpdev, 0x32);
+		atpdev->sp[0][m++] = atp_readb_base(atpdev, 0x33);
+		atp_writew_base(atpdev, 0x34, n);
+		n += 0x0002;
+		atpdev->sp[0][m++] = atp_readb_base(atpdev, 0x30);
+		atpdev->sp[0][m++] = atp_readb_base(atpdev, 0x31);
+		atpdev->sp[0][m++] = atp_readb_base(atpdev, 0x32);
+		atpdev->sp[0][m++] = atp_readb_base(atpdev, 0x33);
+		atp_writew_base(atpdev, 0x34, n);
+		n += 0x0002;
+		atpdev->sp[0][m++] = atp_readb_base(atpdev, 0x30);
+		atpdev->sp[0][m++] = atp_readb_base(atpdev, 0x31);
+		atpdev->sp[0][m++] = atp_readb_base(atpdev, 0x32);
+		atpdev->sp[0][m++] = atp_readb_base(atpdev, 0x33);
+		n += 0x0018;
+	}
+	atp_writew_base(atpdev, 0x34, 0);
+	atpdev->ultra_map[0] = 0;
+	atpdev->async[0] = 0;
+	for (k = 0; k < 16; k++) {
+		n = 1 << k;
+		if (atpdev->sp[0][k] > 1)
+			atpdev->ultra_map[0] |= n;
+		else
+			if (atpdev->sp[0][k] == 0)
+				atpdev->async[0] |= n;
+	}
+	atpdev->async[0] = ~(atpdev->async[0]);
+	atp_writeb_base(atpdev, 0x35, atpdev->global_map[0]);
+
+	k = atp_readb_base(atpdev, 0x38) & 0x80;
+	atp_writeb_base(atpdev, 0x38, k);
+	atp_writeb_base(atpdev, 0x3b, 0x20);
+	mdelay(32);
+	atp_writeb_base(atpdev, 0x3b, 0);
+	mdelay(32);
+	atp_readb_io(atpdev, 0, 0x1b);
+	atp_readb_io(atpdev, 0, 0x17);
+
+	atp_set_host_id(atpdev, 0, host_id);
+
+	tscam(shpnt, true, atp_readb_base(atpdev, 0x22));
+	atp_is(atpdev, 0, true, atp_readb_base(atpdev, 0x3f) & 0x40);
+	atp_writeb_base(atpdev, 0x38, 0xb0);
+	shpnt->max_id = 16;
+	shpnt->this_id = host_id;
+}
+
 /* return non-zero on detection */
 static int atp870u_probe(struct pci_dev *pdev, const struct pci_device_id *ent)
 {
@@ -1304,92 +1389,9 @@ static int atp870u_probe(struct pci_dev *pdev, const struct pci_device_id *ent)
 		goto unregister;
 	}
 
-	if (is880(atpdev)) {
-		pci_write_config_byte(pdev, PCI_LATENCY_TIMER, 0x80);//JCC082803
-
-		atpdev->ioport[0] = shpnt->io_port + 0x40;
-		atpdev->pciport[0] = shpnt->io_port + 0x28;
-
-		host_id = atp_readb_base(atpdev, 0x39);
-		host_id >>= 0x04;
-
-		printk(KERN_INFO "   ACARD AEC-67160 PCI Ultra3 LVD Host Adapter:"
-			"    IO:%lx, IRQ:%d.\n", shpnt->io_port, shpnt->irq);
-		atpdev->host_id[0] = host_id;
-
-		atpdev->global_map[0] = atp_readb_base(atpdev, 0x35);
-		atpdev->ultra_map[0] = atp_readw_base(atpdev, 0x3c);
-
-		n = 0x3f09;
-next_fblk_880:
-		if (n >= 0x4000)
-			goto flash_ok_880;
-
-		m = 0;
-		atp_writew_base(atpdev, 0x34, n);
-		n += 0x0002;
-		if (atp_readb_base(atpdev, 0x30) == 0xff)
-			goto flash_ok_880;
-
-		atpdev->sp[0][m++] = atp_readb_base(atpdev, 0x30);
-		atpdev->sp[0][m++] = atp_readb_base(atpdev, 0x31);
-		atpdev->sp[0][m++] = atp_readb_base(atpdev, 0x32);
-		atpdev->sp[0][m++] = atp_readb_base(atpdev, 0x33);
-		atp_writew_base(atpdev, 0x34, n);
-		n += 0x0002;
-		atpdev->sp[0][m++] = atp_readb_base(atpdev, 0x30);
-		atpdev->sp[0][m++] = atp_readb_base(atpdev, 0x31);
-		atpdev->sp[0][m++] = atp_readb_base(atpdev, 0x32);
-		atpdev->sp[0][m++] = atp_readb_base(atpdev, 0x33);
-		atp_writew_base(atpdev, 0x34, n);
-		n += 0x0002;
-		atpdev->sp[0][m++] = atp_readb_base(atpdev, 0x30);
-		atpdev->sp[0][m++] = atp_readb_base(atpdev, 0x31);
-		atpdev->sp[0][m++] = atp_readb_base(atpdev, 0x32);
-		atpdev->sp[0][m++] = atp_readb_base(atpdev, 0x33);
-		atp_writew_base(atpdev, 0x34, n);
-		n += 0x0002;
-		atpdev->sp[0][m++] = atp_readb_base(atpdev, 0x30);
-		atpdev->sp[0][m++] = atp_readb_base(atpdev, 0x31);
-		atpdev->sp[0][m++] = atp_readb_base(atpdev, 0x32);
-		atpdev->sp[0][m++] = atp_readb_base(atpdev, 0x33);
-		n += 0x0018;
-		goto next_fblk_880;
-flash_ok_880:
-		atp_writew_base(atpdev, 0x34, 0);
-		atpdev->ultra_map[0] = 0;
-		atpdev->async[0] = 0;
-		for (k = 0; k < 16; k++) {
-			n = 1;
-			n = n << k;
-			if (atpdev->sp[0][k] > 1) {
-				atpdev->ultra_map[0] |= n;
-			} else {
-				if (atpdev->sp[0][k] == 0)
-					atpdev->async[0] |= n;
- 			}
-	 	}
-		atpdev->async[0] = ~(atpdev->async[0]);
-		atp_writeb_base(atpdev, 0x35, atpdev->global_map[0]);
- 
-
-		k = atp_readb_base(atpdev, 0x38) & 0x80;
-		atp_writeb_base(atpdev, 0x38, k);
-		atp_writeb_base(atpdev, 0x3b, 0x20);
-		mdelay(32);
-		atp_writeb_base(atpdev, 0x3b, 0);
-		mdelay(32);
-		atp_readb_io(atpdev, 0, 0x1b);
-		atp_readb_io(atpdev, 0, 0x17);
-
-		atp_set_host_id(atpdev, 0, host_id);
-
-		tscam(shpnt, true, atp_readb_base(atpdev, 0x22));
-		atp_is(atpdev, 0, true, atp_readb_base(atpdev, 0x3f) & 0x40);
-		atp_writeb_base(atpdev, 0x38, 0xb0);
-		shpnt->max_id = 16;
-		shpnt->this_id = host_id;
-	} else if (is885(atpdev)) {
+	if (is880(atpdev))
+		atp880_init(shpnt);
+	else if (is885(atpdev)) {
 			printk(KERN_INFO "   ACARD AEC-67162 PCI Ultra3 LVD Host Adapter:  IO:%lx, IRQ:%d.\n"
 			       , shpnt->io_port, shpnt->irq);
         	

commit f5f53a38c2f8671f9fc249c711411ba44d76a618
Author: Ondrej Zary <linux@rainbow-software.org>
Date:   Tue Nov 17 19:24:25 2015 +0100

    atp870u: Initialize tables earlier
    
    Call _init_tables before chip-specific initialization. This avoids code
    duplication and fixes a bug(?) in 880 init where the values read from flash
    into atpdev->sp are then overwritten by calling init_tables.
    
    Signed-off-by: Ondrej Zary <linux@rainbow-software.org>
    Reviewed-by: Hannes Reinicke <hare@suse.de>
    Acked-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/atp870u.c b/drivers/scsi/atp870u.c
index dd0b520f7dd4..3c66539e5781 100644
--- a/drivers/scsi/atp870u.c
+++ b/drivers/scsi/atp870u.c
@@ -1298,6 +1298,12 @@ static int atp870u_probe(struct pci_dev *pdev, const struct pci_device_id *ent)
 	shpnt->unique_id = shpnt->io_port;
 	shpnt->irq = pdev->irq;
 
+	err = atp870u_init_tables(shpnt);
+	if (err) {
+		dev_err(&pdev->dev, "Unable to allocate tables for Acard controller\n");
+		goto unregister;
+	}
+
 	if (is880(atpdev)) {
 		pci_write_config_byte(pdev, PCI_LATENCY_TIMER, 0x80);//JCC082803
 
@@ -1366,11 +1372,6 @@ static int atp870u_probe(struct pci_dev *pdev, const struct pci_device_id *ent)
 		atpdev->async[0] = ~(atpdev->async[0]);
 		atp_writeb_base(atpdev, 0x35, atpdev->global_map[0]);
  
-		if (atp870u_init_tables(shpnt) < 0) {
-			printk(KERN_ERR "Unable to allocate tables for Acard controller\n");
-			err = -ENOMEM;
-			goto unregister;
-		}
 
 		k = atp_readb_base(atpdev, 0x38) & 0x80;
 		atp_writeb_base(atpdev, 0x38, k);
@@ -1398,11 +1399,6 @@ static int atp870u_probe(struct pci_dev *pdev, const struct pci_device_id *ent)
 		atpdev->pciport[0] = shpnt->io_port + 0x40;
 		atpdev->pciport[1] = shpnt->io_port + 0x50;
 				
-		if (atp870u_init_tables(shpnt) < 0) {
-			err = -ENOMEM;
-			goto unregister;
-		}
-			
 		c = atp_readb_base(atpdev, 0x29);
 		atp_writeb_base(atpdev, 0x29, c | 0x04);
         	
@@ -1533,12 +1529,6 @@ static int atp870u_probe(struct pci_dev *pdev, const struct pci_device_id *ent)
 			atpdev->ultra_map[0] = 0xffff;
 		}
 
-
-		if (atp870u_init_tables(shpnt) < 0) {
-			err = -ENOMEM;
-			goto unregister;
-		}
-
 		if (pdev->revision > 0x07)	/* check if atp876 chip then enable terminator */
 			atp_writeb_base(atpdev, 0x3e, 0x00);
  

commit 8177c507523e053011861cce08cb73a77d5896e3
Author: Ondrej Zary <linux@rainbow-software.org>
Date:   Tue Nov 17 19:24:24 2015 +0100

    atp870u: Remove scam_on from struct atp_unit
    
    scam_on is used only during probe, no need to keep it later.
    
    Signed-off-by: Ondrej Zary <linux@rainbow-software.org>
    Reviewed-by: Hannes Reinicke <hare@suse.de>
    Acked-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/atp870u.c b/drivers/scsi/atp870u.c
index 4719df4a2a06..dd0b520f7dd4 100644
--- a/drivers/scsi/atp870u.c
+++ b/drivers/scsi/atp870u.c
@@ -963,7 +963,7 @@ static unsigned char fun_scam(struct atp_unit *dev, unsigned short int *val)
 	return j;
 }
 
-static void tscam(struct Scsi_Host *host, bool wide_chip)
+static void tscam(struct Scsi_Host *host, bool wide_chip, u8 scam_on)
 {
 
 	unsigned char i, j, k;
@@ -986,7 +986,7 @@ static void tscam(struct Scsi_Host *host, bool wide_chip)
 	atp_writeb_io(dev, 0, 2, 0x7f);
 	atp_writeb_io(dev, 0, 0x11, 0x20);
 
-	if ((dev->scam_on & 0x40) == 0) {
+	if ((scam_on & 0x40) == 0) {
 		return;
 	}
 	m = 1;
@@ -1311,7 +1311,6 @@ static int atp870u_probe(struct pci_dev *pdev, const struct pci_device_id *ent)
 			"    IO:%lx, IRQ:%d.\n", shpnt->io_port, shpnt->irq);
 		atpdev->host_id[0] = host_id;
 
-		atpdev->scam_on = atp_readb_base(atpdev, 0x22);
 		atpdev->global_map[0] = atp_readb_base(atpdev, 0x35);
 		atpdev->ultra_map[0] = atp_readw_base(atpdev, 0x3c);
 
@@ -1384,7 +1383,7 @@ static int atp870u_probe(struct pci_dev *pdev, const struct pci_device_id *ent)
 
 		atp_set_host_id(atpdev, 0, host_id);
 
-		tscam(shpnt, true);
+		tscam(shpnt, true, atp_readb_base(atpdev, 0x22));
 		atp_is(atpdev, 0, true, atp_readb_base(atpdev, 0x3f) & 0x40);
 		atp_writeb_base(atpdev, 0x38, 0xb0);
 		shpnt->max_id = 16;
@@ -1509,6 +1508,7 @@ static int atp870u_probe(struct pci_dev *pdev, const struct pci_device_id *ent)
 		shpnt->max_channel = 1;
 		shpnt->this_id = atpdev->host_id[0];
 	} else {
+		u8 scam_on;
 		bool wide_chip =
 			(ent->device == PCI_DEVICE_ID_ARTOP_AEC7610 &&
 			 pdev->revision == 4) ||
@@ -1523,12 +1523,12 @@ static int atp870u_probe(struct pci_dev *pdev, const struct pci_device_id *ent)
 		atpdev->pciport[0] = shpnt->io_port + 0x20;
 		host_id &= 0x07;
 		atpdev->host_id[0] = host_id;
-		atpdev->scam_on = atp_readb_pci(atpdev, 0, 2);
+		scam_on = atp_readb_pci(atpdev, 0, 2);
 		atpdev->global_map[0] = atp_readb_base(atpdev, 0x2d);
 		atpdev->ultra_map[0] = atp_readw_base(atpdev, 0x2e);
 
 		if (atpdev->ultra_map[0] == 0) {
-			atpdev->scam_on = 0x00;
+			scam_on = 0x00;
 			atpdev->global_map[0] = 0x20;
 			atpdev->ultra_map[0] = 0xffff;
 		}
@@ -1551,7 +1551,7 @@ static int atp870u_probe(struct pci_dev *pdev, const struct pci_device_id *ent)
 		atp_set_host_id(atpdev, 0, host_id);
 
 
-		tscam(shpnt, wide_chip);
+		tscam(shpnt, wide_chip, scam_on);
 		atp_writeb_base(atpdev, 0x3a, atp_readb_base(atpdev, 0x3a) | 0x10);
 		atp_is(atpdev, 0, wide_chip, 0);
 		atp_writeb_base(atpdev, 0x3a, atp_readb_base(atpdev, 0x3a) & 0xef);

commit 1729c0d22bddfa949551c38301af3ce52d40c3b9
Author: Ondrej Zary <linux@rainbow-software.org>
Date:   Tue Nov 17 19:24:23 2015 +0100

    atp870u: Request IRQ later, remove weird locking
    
    Allocate IRQ later during probe to avoid code duplication and also
    remove the need for weird locking in _probe.
    (It was probably there to prevent race with the IRQ handler?)
    
    Signed-off-by: Ondrej Zary <linux@rainbow-software.org>
    Reviewed-by: Hannes Reinicke <hare@suse.de>
    Acked-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/atp870u.c b/drivers/scsi/atp870u.c
index 87dd8867106c..4719df4a2a06 100644
--- a/drivers/scsi/atp870u.c
+++ b/drivers/scsi/atp870u.c
@@ -1253,7 +1253,6 @@ static void atp_set_host_id(struct atp_unit *atp, u8 c, u8 host_id)
 static int atp870u_probe(struct pci_dev *pdev, const struct pci_device_id *ent)
 {
 	unsigned char k, m, c;
-	unsigned long flags;
 	unsigned int error,n;
 	unsigned char host_id;
 	struct Scsi_Host *shpnt = NULL;
@@ -1374,13 +1373,6 @@ static int atp870u_probe(struct pci_dev *pdev, const struct pci_device_id *ent)
 			goto unregister;
 		}
 
-		err = request_irq(shpnt->irq, atp870u_intr_handle, IRQF_SHARED, "atp880i", shpnt);
-		if (err) {
-			printk(KERN_ERR "Unable to allocate IRQ%d for Acard controller.\n", shpnt->irq);
-			goto free_tables;
-		}
-
-		spin_lock_irqsave(shpnt->host_lock, flags);
 		k = atp_readb_base(atpdev, 0x38) & 0x80;
 		atp_writeb_base(atpdev, 0x38, k);
 		atp_writeb_base(atpdev, 0x3b, 0x20);
@@ -1412,17 +1404,6 @@ static int atp870u_probe(struct pci_dev *pdev, const struct pci_device_id *ent)
 			goto unregister;
 		}
 			
-#ifdef ED_DBGP		
-	printk("request_irq() shpnt %p hostdata %p\n", shpnt, atpdev);
-#endif	        
-		err = request_irq(shpnt->irq, atp870u_intr_handle, IRQF_SHARED, "atp870u", shpnt);
-		if (err) {
-				printk(KERN_ERR "Unable to allocate IRQ for Acard controller.\n");
-			goto free_tables;
-		}
-		
-		spin_lock_irqsave(shpnt->host_lock, flags);        					
-        			
 		c = atp_readb_base(atpdev, 0x29);
 		atp_writeb_base(atpdev, 0x29, c | 0x04);
         	
@@ -1558,13 +1539,6 @@ static int atp870u_probe(struct pci_dev *pdev, const struct pci_device_id *ent)
 			goto unregister;
 		}
 
-		err = request_irq(shpnt->irq, atp870u_intr_handle, IRQF_SHARED, "atp870i", shpnt);
-		if (err) {
-			printk(KERN_ERR "Unable to allocate IRQ%d for Acard controller.\n", shpnt->irq);
-			goto free_tables;
-		}
-
-		spin_lock_irqsave(shpnt->host_lock, flags);
 		if (pdev->revision > 0x07)	/* check if atp876 chip then enable terminator */
 			atp_writeb_base(atpdev, 0x3e, 0x00);
  
@@ -1586,15 +1560,18 @@ static int atp870u_probe(struct pci_dev *pdev, const struct pci_device_id *ent)
 		shpnt->this_id = host_id;
 
 	} 
-		spin_unlock_irqrestore(shpnt->host_lock, flags);
-		err = scsi_add_host(shpnt, &pdev->dev);
-		if (err)
-			goto scsi_add_fail;
-		scsi_scan_host(shpnt);
-#ifdef ED_DBGP			
-		printk("atp870u_prob : exit\n");
-#endif		
-		return 0;
+	err = request_irq(shpnt->irq, atp870u_intr_handle, IRQF_SHARED, "atp870u", shpnt);
+	if (err) {
+		dev_err(&pdev->dev, "Unable to allocate IRQ %d.\n", shpnt->irq);
+		goto free_tables;
+	}
+
+	err = scsi_add_host(shpnt, &pdev->dev);
+	if (err)
+		goto scsi_add_fail;
+	scsi_scan_host(shpnt);
+
+	return 0;
 
 scsi_add_fail:
 	free_irq(shpnt->irq, shpnt);

commit 11ec131804e75b73f07ac04f94888efc65c5d4c4
Author: Ondrej Zary <linux@rainbow-software.org>
Date:   Tue Nov 17 19:24:22 2015 +0100

    atp870u: Use pci_request_regions
    
    Use pci_request_regions and do it before accessing the I/O ports.
    Also add missing pci_disable_device() call to atp870u_remove().
    
    Signed-off-by: Ondrej Zary <linux@rainbow-software.org>
    Reviewed-by: Hannes Reinicke <hare@suse.de>
    Acked-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/atp870u.c b/drivers/scsi/atp870u.c
index 4bb0f4fcd9df..87dd8867106c 100644
--- a/drivers/scsi/atp870u.c
+++ b/drivers/scsi/atp870u.c
@@ -1276,10 +1276,15 @@ static int atp870u_probe(struct pci_dev *pdev, const struct pci_device_id *ent)
                 goto disable_device;
         }
 
+	err = pci_request_regions(pdev, "atp870u");
+	if (err)
+		goto disable_device;
+	pci_set_master(pdev);
+
         err = -ENOMEM;
 	shpnt = scsi_host_alloc(&atp870u_template, sizeof(struct atp_unit));
 	if (!shpnt)
-		goto disable_device;
+		goto release_region;
 
 	atpdev = shost_priv(shpnt);
 
@@ -1582,10 +1587,6 @@ static int atp870u_probe(struct pci_dev *pdev, const struct pci_device_id *ent)
 
 	} 
 		spin_unlock_irqrestore(shpnt->host_lock, flags);
-		if (!request_region(shpnt->io_port, shpnt->n_io_port, "atp870u")) {
-			err = -EBUSY;
-			goto request_io_fail;
-		}
 		err = scsi_add_host(shpnt, &pdev->dev);
 		if (err)
 			goto scsi_add_fail;
@@ -1596,16 +1597,13 @@ static int atp870u_probe(struct pci_dev *pdev, const struct pci_device_id *ent)
 		return 0;
 
 scsi_add_fail:
-	printk("atp870u_prob:scsi_add_fail\n");
-	release_region(shpnt->io_port, shpnt->n_io_port);
-request_io_fail:
-	printk("atp870u_prob:request_io_fail\n");
 	free_irq(shpnt->irq, shpnt);
 free_tables:
-	printk("atp870u_prob:free_table\n");
 	atp870u_free_tables(shpnt);
 unregister:
 	scsi_host_put(shpnt);
+release_region:
+	pci_release_regions(pdev);
 disable_device:
 	pci_disable_device(pdev);
 fail:
@@ -1696,7 +1694,8 @@ static void atp870u_remove (struct pci_dev *pdev)
 	
 	scsi_remove_host(pshost);
 	free_irq(pshost->irq, pshost);
-	release_region(pshost->io_port, pshost->n_io_port);
+	pci_release_regions(pdev);
+	pci_disable_device(pdev);
 	atp870u_free_tables(pshost);
 	scsi_host_put(pshost);
 }

commit b922a44995a6e94560aa3eae0602bf92a4e7b084
Author: Ondrej Zary <linux@rainbow-software.org>
Date:   Tue Nov 17 19:24:21 2015 +0100

    atp870u: Introduce is880(), is885() and remove dev_id
    
    Introduce chip type inline functions to simplify code, allowing to delete
    dev_id from struct atp_unit.
    
    Signed-off-by: Ondrej Zary <linux@rainbow-software.org>
    Reviewed-by: Hannes Reinicke <hare@suse.de>
    Acked-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/atp870u.c b/drivers/scsi/atp870u.c
index 8af51a97185a..4bb0f4fcd9df 100644
--- a/drivers/scsi/atp870u.c
+++ b/drivers/scsi/atp870u.c
@@ -103,6 +103,17 @@ static inline u8 atp_readb_pci(struct atp_unit *atp, u8 channel, u8 reg)
 	return inb(atp->pciport[channel] + reg);
 }
 
+static inline bool is880(struct atp_unit *atp)
+{
+	return atp->pdev->device == ATP880_DEVID1 ||
+	       atp->pdev->device == ATP880_DEVID2;
+}
+
+static inline bool is885(struct atp_unit *atp)
+{
+	return atp->pdev->device == ATP885_DEVID;
+}
+
 static irqreturn_t atp870u_intr_handle(int irq, void *dev_id)
 {
 	unsigned long flags;
@@ -131,7 +142,7 @@ static irqreturn_t atp870u_intr_handle(int irq, void *dev_id)
 	dev->in_int[c] = 1;
 	cmdp = atp_readb_io(dev, c, 0x10);
 	if (dev->working[c] != 0) {
-		if (dev->dev_id == ATP885_DEVID) {
+		if (is885(dev)) {
 			if ((atp_readb_io(dev, c, 0x16) & 0x80) == 0)
 				atp_writeb_io(dev, c, 0x16, (atp_readb_io(dev, c, 0x16) | 0x80));
 		}		
@@ -148,7 +159,7 @@ static irqreturn_t atp870u_intr_handle(int irq, void *dev_id)
 		
 		i = atp_readb_io(dev, c, 0x17);
 		
-		if (dev->dev_id == ATP885_DEVID)
+		if (is885(dev))
 			atp_writeb_pci(dev, c, 2, 0x06);
 
 		target_id = atp_readb_io(dev, c, 0x15);
@@ -169,7 +180,7 @@ static irqreturn_t atp870u_intr_handle(int irq, void *dev_id)
 		     }
 		     dev->last_cmd[c] |= 0x40;
 		}
-		if (dev->dev_id == ATP885_DEVID) 
+		if (is885(dev))
 			dev->r1f[c][target_id] |= j;
 #ifdef ED_DBGP
 		printk("atp870u_intr_handle status = %x\n",i);
@@ -178,7 +189,7 @@ static irqreturn_t atp870u_intr_handle(int irq, void *dev_id)
 			if ((dev->last_cmd[c] & 0xf0) != 0x40) {
 			   dev->last_cmd[c] = 0xff;
 			}
-			if (dev->dev_id == ATP885_DEVID) {
+			if (is885(dev)) {
 				adrcnt = 0;
 				((unsigned char *) &adrcnt)[2] = atp_readb_io(dev, c, 0x12);
 				((unsigned char *) &adrcnt)[1] = atp_readb_io(dev, c, 0x13);
@@ -249,7 +260,7 @@ static irqreturn_t atp870u_intr_handle(int irq, void *dev_id)
 			return IRQ_HANDLED;
 		}
 
-		if (dev->dev_id == ATP885_DEVID) {
+		if (is885(dev)) {
 			if ((i == 0x4c) || (i == 0x4d) || (i == 0x8c) || (i == 0x8d)) {
 		   		if ((i == 0x4c) || (i == 0x8c)) 
 		      			i=0x48;
@@ -301,7 +312,7 @@ static irqreturn_t atp870u_intr_handle(int irq, void *dev_id)
 			if (dev->last_cmd[c] != 0xff) {
 			   dev->last_cmd[c] |= 0x40;
 			}
-			if (dev->dev_id == ATP885_DEVID) {
+			if (is885(dev)) {
 				j = atp_readb_base(dev, 0x29) & 0xfe;
 				atp_writeb_base(dev, 0x29, j);
 			} else
@@ -316,7 +327,7 @@ static irqreturn_t atp870u_intr_handle(int irq, void *dev_id)
 			} else {
 				target_id &= 0x07;
 			}
-			if (dev->dev_id == ATP885_DEVID)
+			if (is885(dev))
 				atp_writeb_io(dev, c, 0x10, 0x45);
 			workreq = dev->id[c][target_id].curr_req;
 #ifdef ED_DBGP			
@@ -348,15 +359,14 @@ static irqreturn_t atp870u_intr_handle(int irq, void *dev_id)
 			atp_writeb_io(dev, c, 0x16, 0x80);
 			
 			/* enable 32 bit fifo transfer */	
-			if (dev->dev_id == ATP885_DEVID) {
+			if (is885(dev)) {
 				i = atp_readb_pci(dev, c, 1) & 0xf3;
 				//j=workreq->cmnd[0];	    		    	
 				if ((workreq->cmnd[0] == 0x08) || (workreq->cmnd[0] == 0x28) || (workreq->cmnd[0] == 0x0a) || (workreq->cmnd[0] == 0x2a)) {
 				   i |= 0x0c;
 				}
 				atp_writeb_pci(dev, c, 1, i);
-			} else if ((dev->dev_id == ATP880_DEVID1) ||
-	    		    	   (dev->dev_id == ATP880_DEVID2) ) {
+			} else if (is880(dev)) {
 				if ((workreq->cmnd[0] == 0x08) || (workreq->cmnd[0] == 0x28) || (workreq->cmnd[0] == 0x0a) || (workreq->cmnd[0] == 0x2a))
 					atp_writeb_base(dev, 0x3b, (atp_readb_base(dev, 0x3b) & 0x3f) | 0xc0);
 				else
@@ -417,7 +427,7 @@ static irqreturn_t atp870u_intr_handle(int irq, void *dev_id)
 #ifdef ED_DBGP
 			printk("dev->id[%d][%d].prdaddr 0x%8x\n", c, target_id, dev->id[c][target_id].prdaddr);
 #endif
-			if (dev->dev_id != ATP885_DEVID) {
+			if (!is885(dev)) {
 				atp_writeb_pci(dev, c, 2, 0x06);
 				atp_writeb_pci(dev, c, 2, 0x00);
 			}
@@ -454,14 +464,14 @@ static irqreturn_t atp870u_intr_handle(int irq, void *dev_id)
 			}
 			if (i == 0x16) {
 				workreq->result = atp_readb_io(dev, c, 0x0f);
-				if (((dev->r1f[c][target_id] & 0x10) != 0)&&(dev->dev_id==ATP885_DEVID)) {
+				if (((dev->r1f[c][target_id] & 0x10) != 0) && is885(dev)) {
 					printk(KERN_WARNING "AEC67162 CRC ERROR !\n");
 					workreq->result = 0x02;
 				}
 			} else
 				workreq->result = 0x02;
 
-			if (dev->dev_id == ATP885_DEVID) {		
+			if (is885(dev)) {
 				j = atp_readb_base(dev, 0x29) | 0x01;
 				atp_writeb_base(dev, 0x29, j);
 			}
@@ -516,7 +526,7 @@ static irqreturn_t atp870u_intr_handle(int irq, void *dev_id)
 			atp_writeb_pci(dev, c, 2, 0x06);
 			atp_writeb_pci(dev, c, 2, 0x00);
 			atp_writeb_io(dev, c, 0x10, 0x41);
-			if (dev->dev_id == ATP885_DEVID) {
+			if (is885(dev)) {
 				k = dev->id[c][target_id].last_len;
 				atp_writeb_io(dev, c, 0x12, ((unsigned char *) (&k))[2]);
 				atp_writeb_io(dev, c, 0x13, ((unsigned char *) (&k))[1]);
@@ -535,7 +545,7 @@ static irqreturn_t atp870u_intr_handle(int irq, void *dev_id)
 			atp_writeb_pci(dev, c, 2, 0x06);
 			atp_writeb_pci(dev, c, 2, 0x00);
 			atp_writeb_io(dev, c, 0x10, 0x41);
-			if (dev->dev_id == ATP885_DEVID) {		
+			if (is885(dev)) {
 				k = dev->id[c][target_id].last_len;
 				atp_writeb_io(dev, c, 0x12, ((unsigned char *) (&k))[2]);
 				atp_writeb_io(dev, c, 0x13, ((unsigned char *) (&k))[1]);
@@ -737,7 +747,7 @@ static void send_s870(struct atp_unit *dev,unsigned char c)
 #endif	
 	l = scsi_bufflen(workreq);
 
-	if (dev->dev_id == ATP885_DEVID) {
+	if (is885(dev)) {
 		j = atp_readb_base(dev, 0x29) & 0xfe;
 		atp_writeb_base(dev, 0x29, j);
 		dev->r1f[c][scmd_id(workreq)] = 0;
@@ -775,7 +785,7 @@ static void send_s870(struct atp_unit *dev,unsigned char c)
 
 	atp_writeb_io(dev, c, 0x00, workreq->cmd_len);
 	atp_writeb_io(dev, c, 0x01, 0x2c);
-	if (dev->dev_id == ATP885_DEVID)
+	if (is885(dev))
 		atp_writeb_io(dev, c, 0x02, 0x7f);
 	else
 		atp_writeb_io(dev, c, 0x02, 0xcf);
@@ -873,15 +883,14 @@ static void send_s870(struct atp_unit *dev,unsigned char c)
 	atp_writel_pci(dev, c, 4, dev->id[c][target_id].prdaddr);
 	atp_writeb_pci(dev, c, 2, 0x06);
 	atp_writeb_pci(dev, c, 2, 0x00);
-	if (dev->dev_id == ATP885_DEVID) {
+	if (is885(dev)) {
 		j = atp_readb_pci(dev, c, 1) & 0xf3;
 		if ((workreq->cmnd[0] == 0x08) || (workreq->cmnd[0] == 0x28) ||
 	    	(workreq->cmnd[0] == 0x0a) || (workreq->cmnd[0] == 0x2a)) {
 	   		j |= 0x0c;
 		}
 		atp_writeb_pci(dev, c, 1, j);
-	} else if ((dev->dev_id == ATP880_DEVID1) ||
-	    	   (dev->dev_id == ATP880_DEVID2)) {
+	} else if (is880(dev)) {
 		if ((workreq->cmnd[0] == 0x08) || (workreq->cmnd[0] == 0x28) || (workreq->cmnd[0] == 0x0a) || (workreq->cmnd[0] == 0x2a))
 			atp_writeb_base(dev, 0x3b, (atp_readb_base(dev, 0x3b) & 0x3f) | 0xc0);
 		else
@@ -1285,7 +1294,7 @@ static int atp870u_probe(struct pci_dev *pdev, const struct pci_device_id *ent)
 	shpnt->unique_id = shpnt->io_port;
 	shpnt->irq = pdev->irq;
 
-	if ((ent->device == ATP880_DEVID1)||(ent->device == ATP880_DEVID2)) {
+	if (is880(atpdev)) {
 		pci_write_config_byte(pdev, PCI_LATENCY_TIMER, 0x80);//JCC082803
 
 		atpdev->ioport[0] = shpnt->io_port + 0x40;
@@ -1296,7 +1305,6 @@ static int atp870u_probe(struct pci_dev *pdev, const struct pci_device_id *ent)
 
 		printk(KERN_INFO "   ACARD AEC-67160 PCI Ultra3 LVD Host Adapter:"
 			"    IO:%lx, IRQ:%d.\n", shpnt->io_port, shpnt->irq);
-		atpdev->dev_id = ent->device;
 		atpdev->host_id[0] = host_id;
 
 		atpdev->scam_on = atp_readb_base(atpdev, 0x22);
@@ -1384,12 +1392,11 @@ static int atp870u_probe(struct pci_dev *pdev, const struct pci_device_id *ent)
 		atp_writeb_base(atpdev, 0x38, 0xb0);
 		shpnt->max_id = 16;
 		shpnt->this_id = host_id;
-	} else if (ent->device == ATP885_DEVID) {	
+	} else if (is885(atpdev)) {
 			printk(KERN_INFO "   ACARD AEC-67162 PCI Ultra3 LVD Host Adapter:  IO:%lx, IRQ:%d.\n"
 			       , shpnt->io_port, shpnt->irq);
         	
 		atpdev->pdev = pdev;
-		atpdev->dev_id  = ent->device;
 		atpdev->ioport[0] = shpnt->io_port + 0x80;
 		atpdev->ioport[1] = shpnt->io_port + 0xc0;
 		atpdev->pciport[0] = shpnt->io_port + 0x40;
@@ -1528,7 +1535,6 @@ static int atp870u_probe(struct pci_dev *pdev, const struct pci_device_id *ent)
 
 		atpdev->ioport[0] = shpnt->io_port;
 		atpdev->pciport[0] = shpnt->io_port + 0x20;
-		atpdev->dev_id = ent->device;
 		host_id &= 0x07;
 		atpdev->host_id[0] = host_id;
 		atpdev->scam_on = atp_readb_pci(atpdev, 0, 2);
@@ -1797,7 +1803,7 @@ static void atp_is(struct atp_unit *dev, unsigned char c, bool wide_chip, unsign
 		dev->active_id[c] |= m;
 
 		atp_writeb_io(dev, c, 0x10, 0x30);
-		if (dev->dev_id == ATP885_DEVID || dev->dev_id == ATP880_DEVID1 || dev->dev_id == ATP880_DEVID2)
+		if (is885(dev) || is880(dev))
 			atp_writeb_io(dev, c, 0x14, 0x00);
 		else /* result of is870() merge - is this a bug? */
 			atp_writeb_io(dev, c, 0x04, 0x00);
@@ -1877,7 +1883,7 @@ static void atp_is(struct atp_unit *dev, unsigned char c, bool wide_chip, unsign
 		if ((mbuf[7] & 0x60) == 0) {
 			goto not_wide;
 		}
-		if (dev->dev_id == ATP885_DEVID || dev->dev_id == ATP880_DEVID1 || dev->dev_id == ATP880_DEVID2) {
+		if (is885(dev) || is880(dev)) {
 			if ((i < 8) && ((dev->global_map[c] & 0x20) == 0))
 				goto not_wide;
 		} else { /* result of is870() merge - is this a bug? */
@@ -2146,7 +2152,7 @@ static void atp_is(struct atp_unit *dev, unsigned char c, bool wide_chip, unsign
 		}
 		continue;
 set_sync:
-		if ((dev->dev_id != ATP885_DEVID && dev->dev_id != ATP880_DEVID1 && dev->dev_id != ATP880_DEVID2) || (dev->sp[c][i] == 0x02)) {
+		if ((!is885(dev) && !is880(dev)) || (dev->sp[c][i] == 0x02)) {
 			synu[4] = 0x0c;
 			synuw[4] = 0x0c;
 		} else {
@@ -2190,7 +2196,7 @@ static void atp_is(struct atp_unit *dev, unsigned char c, bool wide_chip, unsign
 		while ((atp_readb_io(dev, c, 0x1f) & 0x80) == 0) {
 			if ((atp_readb_io(dev, c, 0x1f) & 0x01) != 0) {
 				if ((m & dev->wide_id[c]) != 0) {
-					if (dev->dev_id == ATP885_DEVID || dev->dev_id == ATP880_DEVID1 || dev->dev_id == ATP880_DEVID2) {
+					if (is885(dev) || is880(dev)) {
 						if ((m & dev->ultra_map[c]) != 0) {
 							atp_writeb_io(dev, c, 0x19, synuw[j++]);
 						} else {
@@ -2245,7 +2251,7 @@ static void atp_is(struct atp_unit *dev, unsigned char c, bool wide_chip, unsign
 		}
 		continue;
 phase_ins:
-		if (dev->dev_id == ATP885_DEVID || dev->dev_id == ATP880_DEVID1 || dev->dev_id == ATP880_DEVID2)
+		if (is885(dev) || is880(dev))
 			atp_writeb_io(dev, c, 0x14, 0x06);
 		else
 			atp_writeb_io(dev, c, 0x14, 0xff);
@@ -2303,7 +2309,7 @@ static void atp_is(struct atp_unit *dev, unsigned char c, bool wide_chip, unsign
 		if (mbuf[3] > 0x64) {
 			continue;
 		}
-		if (dev->dev_id == ATP885_DEVID || dev->dev_id == ATP880_DEVID1 || dev->dev_id == ATP880_DEVID2) {
+		if (is885(dev) || is880(dev)) {
 			if (mbuf[4] > 0x0e) {
 				mbuf[4] = 0x0e;
 			}
@@ -2313,7 +2319,7 @@ static void atp_is(struct atp_unit *dev, unsigned char c, bool wide_chip, unsign
 			}
 		}
 		dev->id[c][i].devsp = mbuf[4];
-		if (dev->dev_id == ATP885_DEVID || dev->dev_id == ATP880_DEVID1 || dev->dev_id == ATP880_DEVID2)
+		if (is885(dev) || is880(dev))
 			if (mbuf[3] < 0x0c) {
 				j = 0xb0;
 				goto set_syn_ok;

commit 6c9b9c554b2a369d2b46558975ef2eaa3a84c1c3
Author: Ondrej Zary <linux@rainbow-software.org>
Date:   Tue Nov 17 19:24:20 2015 +0100

    atp870u: Simplify _probe()
    
    Move shpnt common code to the top, remove base_io, use pci_resource_len.
    
    Signed-off-by: Ondrej Zary <linux@rainbow-software.org>
    Reviewed-by: Hannes Reinicke <hare@suse.de>
    Acked-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/atp870u.c b/drivers/scsi/atp870u.c
index f92eb008cb8c..8af51a97185a 100644
--- a/drivers/scsi/atp870u.c
+++ b/drivers/scsi/atp870u.c
@@ -1245,7 +1245,7 @@ static int atp870u_probe(struct pci_dev *pdev, const struct pci_device_id *ent)
 {
 	unsigned char k, m, c;
 	unsigned long flags;
-	unsigned int base_io, error,n;
+	unsigned int error,n;
 	unsigned char host_id;
 	struct Scsi_Host *shpnt = NULL;
 	struct atp_unit *atpdev;
@@ -1278,21 +1278,24 @@ static int atp870u_probe(struct pci_dev *pdev, const struct pci_device_id *ent)
 	atpdev->pdev = pdev;
 	pci_set_drvdata(pdev, atpdev);
 
-	base_io = pci_resource_start(pdev, 0);
-	base_io &= 0xfffffff8;
-	atpdev->baseport = base_io;
+	shpnt->io_port = pci_resource_start(pdev, 0);
+	shpnt->io_port &= 0xfffffff8;
+	shpnt->n_io_port = pci_resource_len(pdev, 0);
+	atpdev->baseport = shpnt->io_port;
+	shpnt->unique_id = shpnt->io_port;
+	shpnt->irq = pdev->irq;
 
 	if ((ent->device == ATP880_DEVID1)||(ent->device == ATP880_DEVID2)) {
 		pci_write_config_byte(pdev, PCI_LATENCY_TIMER, 0x80);//JCC082803
 
-		atpdev->ioport[0] = base_io + 0x40;
-		atpdev->pciport[0] = base_io + 0x28;
+		atpdev->ioport[0] = shpnt->io_port + 0x40;
+		atpdev->pciport[0] = shpnt->io_port + 0x28;
 
 		host_id = atp_readb_base(atpdev, 0x39);
 		host_id >>= 0x04;
 
 		printk(KERN_INFO "   ACARD AEC-67160 PCI Ultra3 LVD Host Adapter:"
-			"    IO:%x, IRQ:%d.\n", base_io, pdev->irq);
+			"    IO:%lx, IRQ:%d.\n", shpnt->io_port, shpnt->irq);
 		atpdev->dev_id = ent->device;
 		atpdev->host_id[0] = host_id;
 
@@ -1358,9 +1361,9 @@ static int atp870u_probe(struct pci_dev *pdev, const struct pci_device_id *ent)
 			goto unregister;
 		}
 
-		err = request_irq(pdev->irq, atp870u_intr_handle, IRQF_SHARED, "atp880i", shpnt);
+		err = request_irq(shpnt->irq, atp870u_intr_handle, IRQF_SHARED, "atp880i", shpnt);
 		if (err) {
- 			printk(KERN_ERR "Unable to allocate IRQ%d for Acard controller.\n", pdev->irq);
+			printk(KERN_ERR "Unable to allocate IRQ%d for Acard controller.\n", shpnt->irq);
 			goto free_tables;
 		}
 
@@ -1381,20 +1384,16 @@ static int atp870u_probe(struct pci_dev *pdev, const struct pci_device_id *ent)
 		atp_writeb_base(atpdev, 0x38, 0xb0);
 		shpnt->max_id = 16;
 		shpnt->this_id = host_id;
-		shpnt->unique_id = base_io;
-		shpnt->io_port = base_io;
-		shpnt->n_io_port = 0x60;	/* Number of bytes of I/O space used */
-		shpnt->irq = pdev->irq;			
 	} else if (ent->device == ATP885_DEVID) {	
-			printk(KERN_INFO "   ACARD AEC-67162 PCI Ultra3 LVD Host Adapter:  IO:%x, IRQ:%d.\n"
-			       , base_io, pdev->irq);
+			printk(KERN_INFO "   ACARD AEC-67162 PCI Ultra3 LVD Host Adapter:  IO:%lx, IRQ:%d.\n"
+			       , shpnt->io_port, shpnt->irq);
         	
 		atpdev->pdev = pdev;
 		atpdev->dev_id  = ent->device;
-		atpdev->ioport[0] = base_io + 0x80;
-		atpdev->ioport[1] = base_io + 0xc0;
-		atpdev->pciport[0] = base_io + 0x40;
-		atpdev->pciport[1] = base_io + 0x50;
+		atpdev->ioport[0] = shpnt->io_port + 0x80;
+		atpdev->ioport[1] = shpnt->io_port + 0xc0;
+		atpdev->pciport[0] = shpnt->io_port + 0x40;
+		atpdev->pciport[1] = shpnt->io_port + 0x50;
 				
 		if (atp870u_init_tables(shpnt) < 0) {
 			err = -ENOMEM;
@@ -1404,7 +1403,7 @@ static int atp870u_probe(struct pci_dev *pdev, const struct pci_device_id *ent)
 #ifdef ED_DBGP		
 	printk("request_irq() shpnt %p hostdata %p\n", shpnt, atpdev);
 #endif	        
-		err = request_irq(pdev->irq, atp870u_intr_handle, IRQF_SHARED, "atp870u", shpnt);
+		err = request_irq(shpnt->irq, atp870u_intr_handle, IRQF_SHARED, "atp870u", shpnt);
 		if (err) {
 				printk(KERN_ERR "Unable to allocate IRQ for Acard controller.\n");
 			goto free_tables;
@@ -1516,11 +1515,6 @@ static int atp870u_probe(struct pci_dev *pdev, const struct pci_device_id *ent)
 		shpnt->max_lun = (atpdev->global_map[0] & 0x07) + 1;
 		shpnt->max_channel = 1;
 		shpnt->this_id = atpdev->host_id[0];
-		shpnt->unique_id = base_io;
-		shpnt->io_port = base_io;
-		shpnt->n_io_port = 0xff;	/* Number of bytes of I/O space used */
-		shpnt->irq = pdev->irq;
-				
 	} else {
 		bool wide_chip =
 			(ent->device == PCI_DEVICE_ID_ARTOP_AEC7610 &&
@@ -1530,10 +1524,10 @@ static int atp870u_probe(struct pci_dev *pdev, const struct pci_device_id *ent)
 		error = pci_read_config_byte(pdev, 0x49, &host_id);
 
 		printk(KERN_INFO "   ACARD AEC-671X PCI Ultra/W SCSI-2/3 Host Adapter: "
-			"IO:%x, IRQ:%d.\n", base_io, pdev->irq);
+			"IO:%lx, IRQ:%d.\n", shpnt->io_port, shpnt->irq);
 
-		atpdev->ioport[0] = base_io;
-		atpdev->pciport[0] = base_io + 0x20;
+		atpdev->ioport[0] = shpnt->io_port;
+		atpdev->pciport[0] = shpnt->io_port + 0x20;
 		atpdev->dev_id = ent->device;
 		host_id &= 0x07;
 		atpdev->host_id[0] = host_id;
@@ -1553,9 +1547,9 @@ static int atp870u_probe(struct pci_dev *pdev, const struct pci_device_id *ent)
 			goto unregister;
 		}
 
-		err = request_irq(pdev->irq, atp870u_intr_handle, IRQF_SHARED, "atp870i", shpnt);
+		err = request_irq(shpnt->irq, atp870u_intr_handle, IRQF_SHARED, "atp870i", shpnt);
 		if (err) {
-			printk(KERN_ERR "Unable to allocate IRQ%d for Acard controller.\n", pdev->irq);
+			printk(KERN_ERR "Unable to allocate IRQ%d for Acard controller.\n", shpnt->irq);
 			goto free_tables;
 		}
 
@@ -1579,13 +1573,10 @@ static int atp870u_probe(struct pci_dev *pdev, const struct pci_device_id *ent)
 		atp_writeb_base(atpdev, 0x3b, atp_readb_base(atpdev, 0x3b) | 0x20);
 		shpnt->max_id = wide_chip ? 16 : 8;
 		shpnt->this_id = host_id;
-		shpnt->unique_id = base_io;
-		shpnt->io_port = base_io;
-		shpnt->n_io_port = 0x40;	/* Number of bytes of I/O space used */
-		shpnt->irq = pdev->irq;		
+
 	} 
 		spin_unlock_irqrestore(shpnt->host_lock, flags);
-		if (!request_region(base_io, shpnt->n_io_port, "atp870u")) {
+		if (!request_region(shpnt->io_port, shpnt->n_io_port, "atp870u")) {
 			err = -EBUSY;
 			goto request_io_fail;
 		}
@@ -1600,10 +1591,10 @@ static int atp870u_probe(struct pci_dev *pdev, const struct pci_device_id *ent)
 
 scsi_add_fail:
 	printk("atp870u_prob:scsi_add_fail\n");
-	release_region(base_io, shpnt->n_io_port);
+	release_region(shpnt->io_port, shpnt->n_io_port);
 request_io_fail:
 	printk("atp870u_prob:request_io_fail\n");
-	free_irq(pdev->irq, shpnt);
+	free_irq(shpnt->irq, shpnt);
 free_tables:
 	printk("atp870u_prob:free_table\n");
 	atp870u_free_tables(shpnt);

commit dd5a5f7951e253b81ac480a63dfd8b826a9ef61e
Author: Ondrej Zary <linux@rainbow-software.org>
Date:   Tue Nov 17 19:24:19 2015 +0100

    atp870u: Remove chip_ver from struct atp_unit
    
    chip_ver is used for wide chip detection only. Remove it and use a local
    variable instead (for 870; 880 and 885 are always wide).
    
    Signed-off-by: Ondrej Zary <linux@rainbow-software.org>
    Reviewed-by: Hannes Reinicke <hare@suse.de>
    Acked-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/atp870u.c b/drivers/scsi/atp870u.c
index 128613e88dfb..f92eb008cb8c 100644
--- a/drivers/scsi/atp870u.c
+++ b/drivers/scsi/atp870u.c
@@ -954,7 +954,7 @@ static unsigned char fun_scam(struct atp_unit *dev, unsigned short int *val)
 	return j;
 }
 
-static void tscam(struct Scsi_Host *host)
+static void tscam(struct Scsi_Host *host, bool wide_chip)
 {
 
 	unsigned char i, j, k;
@@ -983,7 +983,7 @@ static void tscam(struct Scsi_Host *host)
 	m = 1;
 	m <<= dev->host_id[0];
 	j = 16;
-	if (dev->chip_ver < 4) {
+	if (!wide_chip) {
 		m |= 0xff00;
 		j = 8;
 	}
@@ -1012,7 +1012,7 @@ static void tscam(struct Scsi_Host *host)
 			k = i;
 		}
 		atp_writeb_io(dev, 0, 0x15, k);
-		if (dev->chip_ver == 4)
+		if (wide_chip)
 			atp_writeb_io(dev, 0, 0x1b, 0x01);
 		else
 			atp_writeb_io(dev, 0, 0x1b, 0x00);
@@ -1278,25 +1278,11 @@ static int atp870u_probe(struct pci_dev *pdev, const struct pci_device_id *ent)
 	atpdev->pdev = pdev;
 	pci_set_drvdata(pdev, atpdev);
 
-	switch (ent->device) {
-	case PCI_DEVICE_ID_ARTOP_AEC7610:
-		atpdev->chip_ver = pdev->revision;
-		break;
-	case PCI_DEVICE_ID_ARTOP_AEC7612UW:
-	case PCI_DEVICE_ID_ARTOP_AEC7612SUW:
-	case ATP880_DEVID1:	
-	case ATP880_DEVID2:	
-	case ATP885_DEVID:	
-		atpdev->chip_ver = 0x04;
-	default:
-		break;
-	}
 	base_io = pci_resource_start(pdev, 0);
 	base_io &= 0xfffffff8;
 	atpdev->baseport = base_io;
 
 	if ((ent->device == ATP880_DEVID1)||(ent->device == ATP880_DEVID2)) {
-		atpdev->chip_ver = pdev->revision;
 		pci_write_config_byte(pdev, PCI_LATENCY_TIMER, 0x80);//JCC082803
 
 		atpdev->ioport[0] = base_io + 0x40;
@@ -1390,7 +1376,7 @@ static int atp870u_probe(struct pci_dev *pdev, const struct pci_device_id *ent)
 
 		atp_set_host_id(atpdev, 0, host_id);
 
-		tscam(shpnt);
+		tscam(shpnt, true);
 		atp_is(atpdev, 0, true, atp_readb_base(atpdev, 0x3f) & 0x40);
 		atp_writeb_base(atpdev, 0x38, 0xb0);
 		shpnt->max_id = 16;
@@ -1536,6 +1522,11 @@ static int atp870u_probe(struct pci_dev *pdev, const struct pci_device_id *ent)
 		shpnt->irq = pdev->irq;
 				
 	} else {
+		bool wide_chip =
+			(ent->device == PCI_DEVICE_ID_ARTOP_AEC7610 &&
+			 pdev->revision == 4) ||
+			(ent->device == PCI_DEVICE_ID_ARTOP_AEC7612UW) ||
+			(ent->device == PCI_DEVICE_ID_ARTOP_AEC7612SUW);
 		error = pci_read_config_byte(pdev, 0x49, &host_id);
 
 		printk(KERN_INFO "   ACARD AEC-671X PCI Ultra/W SCSI-2/3 Host Adapter: "
@@ -1569,7 +1560,7 @@ static int atp870u_probe(struct pci_dev *pdev, const struct pci_device_id *ent)
 		}
 
 		spin_lock_irqsave(shpnt->host_lock, flags);
-		if (atpdev->chip_ver > 0x07)	/* check if atp876 chip then enable terminator */
+		if (pdev->revision > 0x07)	/* check if atp876 chip then enable terminator */
 			atp_writeb_base(atpdev, 0x3e, 0x00);
  
 		k = (atp_readb_base(atpdev, 0x3a) & 0xf3) | 0x10;
@@ -1580,15 +1571,13 @@ static int atp870u_probe(struct pci_dev *pdev, const struct pci_device_id *ent)
 		mdelay(32);
 		atp_set_host_id(atpdev, 0, host_id);
 
-		tscam(shpnt);
+
+		tscam(shpnt, wide_chip);
 		atp_writeb_base(atpdev, 0x3a, atp_readb_base(atpdev, 0x3a) | 0x10);
-		atp_is(atpdev, 0, atpdev->chip_ver == 4, 0);
+		atp_is(atpdev, 0, wide_chip, 0);
 		atp_writeb_base(atpdev, 0x3a, atp_readb_base(atpdev, 0x3a) & 0xef);
 		atp_writeb_base(atpdev, 0x3b, atp_readb_base(atpdev, 0x3b) | 0x20);
-		if (atpdev->chip_ver == 4)
-			shpnt->max_id = 16;
-		else		
-			shpnt->max_id = 8;
+		shpnt->max_id = wide_chip ? 16 : 8;
 		shpnt->this_id = host_id;
 		shpnt->unique_id = base_io;
 		shpnt->io_port = base_io;

commit b1e850630b746e347f80cb3f70bdaa791c10b4f6
Author: Ondrej Zary <linux@rainbow-software.org>
Date:   Tue Nov 17 19:24:18 2015 +0100

    atp870u: Improve unsupported chip detection
    
    Signed-off-by: Ondrej Zary <linux@rainbow-software.org>
    Reviewed-by: Hannes Reinicke <hare@suse.de>
    Acked-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/atp870u.c b/drivers/scsi/atp870u.c
index d0119f173195..128613e88dfb 100644
--- a/drivers/scsi/atp870u.c
+++ b/drivers/scsi/atp870u.c
@@ -1252,6 +1252,11 @@ static int atp870u_probe(struct pci_dev *pdev, const struct pci_device_id *ent)
 	unsigned char setupdata[2][16];
 	int err;
 
+	if (ent->device == PCI_DEVICE_ID_ARTOP_AEC7610 && pdev->revision < 2) {
+		dev_err(&pdev->dev, "ATP850S chips (AEC6710L/F cards) are not supported.\n");
+		return -ENODEV;
+	}
+
 	err = pci_enable_device(pdev);
 	if (err)
 		goto fail;
@@ -1273,19 +1278,10 @@ static int atp870u_probe(struct pci_dev *pdev, const struct pci_device_id *ent)
 	atpdev->pdev = pdev;
 	pci_set_drvdata(pdev, atpdev);
 
-	/*
-	 * It's probably easier to weed out some revisions like
-	 * this than via the PCI device table
-	 */
-	if (ent->device == PCI_DEVICE_ID_ARTOP_AEC7610) {
-		atpdev->chip_ver = pdev->revision;
-		if (atpdev->chip_ver < 2) {
-			err = -ENODEV;
-			goto unregister;
-		}
-	}
-
 	switch (ent->device) {
+	case PCI_DEVICE_ID_ARTOP_AEC7610:
+		atpdev->chip_ver = pdev->revision;
+		break;
 	case PCI_DEVICE_ID_ARTOP_AEC7612UW:
 	case PCI_DEVICE_ID_ARTOP_AEC7612SUW:
 	case ATP880_DEVID1:	

commit bdd5ac4065dbc2bb1478ae0c9205a651487c7432
Author: Ondrej Zary <linux@rainbow-software.org>
Date:   Tue Nov 17 19:24:17 2015 +0100

    atp870u: Improve _probe()
    
    Move scsi_host_alloc() to the top of _probe() to remove code duplication,
    *p and unneeded atpdev (de)allocation and copying.  While at it, fix the
    error paths to return real error codes and also add missing
    pci_disble_device() call.
    
    Signed-off-by: Ondrej Zary <linux@rainbow-software.org>
    Reviewed-by: Hannes Reinicke <hare@suse.de>
    Acked-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/atp870u.c b/drivers/scsi/atp870u.c
index 0b349bc4e6e6..d0119f173195 100644
--- a/drivers/scsi/atp870u.c
+++ b/drivers/scsi/atp870u.c
@@ -1248,29 +1248,41 @@ static int atp870u_probe(struct pci_dev *pdev, const struct pci_device_id *ent)
 	unsigned int base_io, error,n;
 	unsigned char host_id;
 	struct Scsi_Host *shpnt = NULL;
-	struct atp_unit *atpdev, *p;
+	struct atp_unit *atpdev;
 	unsigned char setupdata[2][16];
+	int err;
 
-	atpdev = kzalloc(sizeof(*atpdev), GFP_KERNEL);
-	if (!atpdev)
-		return -ENOMEM;
-
-	if (pci_enable_device(pdev))
-		goto err_eio;
+	err = pci_enable_device(pdev);
+	if (err)
+		goto fail;
 
 	if (pci_set_dma_mask(pdev, DMA_BIT_MASK(32))) {
                 printk(KERN_ERR "atp870u: DMA mask required but not available.\n");
-		goto err_eio;
+                err = -EIO;
+                goto disable_device;
         }
 
+        err = -ENOMEM;
+	shpnt = scsi_host_alloc(&atp870u_template, sizeof(struct atp_unit));
+	if (!shpnt)
+		goto disable_device;
+
+	atpdev = shost_priv(shpnt);
+
+	atpdev->host = shpnt;
+	atpdev->pdev = pdev;
+	pci_set_drvdata(pdev, atpdev);
+
 	/*
 	 * It's probably easier to weed out some revisions like
 	 * this than via the PCI device table
 	 */
 	if (ent->device == PCI_DEVICE_ID_ARTOP_AEC7610) {
 		atpdev->chip_ver = pdev->revision;
-		if (atpdev->chip_ver < 2)
-			goto err_eio;
+		if (atpdev->chip_ver < 2) {
+			err = -ENODEV;
+			goto unregister;
+		}
 	}
 
 	switch (ent->device) {
@@ -1358,41 +1370,33 @@ static int atp870u_probe(struct pci_dev *pdev, const struct pci_device_id *ent)
 		atpdev->async[0] = ~(atpdev->async[0]);
 		atp_writeb_base(atpdev, 0x35, atpdev->global_map[0]);
  
-		shpnt = scsi_host_alloc(&atp870u_template, sizeof(struct atp_unit));
-		if (!shpnt)
-			goto err_nomem;
-
-		p = (struct atp_unit *)&shpnt->hostdata;
-
-		atpdev->host = shpnt;
-		atpdev->pdev = pdev;
-		pci_set_drvdata(pdev, p);
-		memcpy(p, atpdev, sizeof(*atpdev));
 		if (atp870u_init_tables(shpnt) < 0) {
 			printk(KERN_ERR "Unable to allocate tables for Acard controller\n");
+			err = -ENOMEM;
 			goto unregister;
 		}
 
-		if (request_irq(pdev->irq, atp870u_intr_handle, IRQF_SHARED, "atp880i", shpnt)) {
+		err = request_irq(pdev->irq, atp870u_intr_handle, IRQF_SHARED, "atp880i", shpnt);
+		if (err) {
  			printk(KERN_ERR "Unable to allocate IRQ%d for Acard controller.\n", pdev->irq);
 			goto free_tables;
 		}
 
 		spin_lock_irqsave(shpnt->host_lock, flags);
-		k = atp_readb_base(p, 0x38) & 0x80;
-		atp_writeb_base(p, 0x38, k);
-		atp_writeb_base(p, 0x3b, 0x20);
+		k = atp_readb_base(atpdev, 0x38) & 0x80;
+		atp_writeb_base(atpdev, 0x38, k);
+		atp_writeb_base(atpdev, 0x3b, 0x20);
 		mdelay(32);
-		atp_writeb_base(p, 0x3b, 0);
+		atp_writeb_base(atpdev, 0x3b, 0);
 		mdelay(32);
-		atp_readb_io(p, 0, 0x1b);
-		atp_readb_io(p, 0, 0x17);
+		atp_readb_io(atpdev, 0, 0x1b);
+		atp_readb_io(atpdev, 0, 0x17);
 
-		atp_set_host_id(p, 0, host_id);
+		atp_set_host_id(atpdev, 0, host_id);
 
 		tscam(shpnt);
-		atp_is(p, 0, true, atp_readb_base(p, 0x3f) & 0x40);
-		atp_writeb_base(p, 0x38, 0xb0);
+		atp_is(atpdev, 0, true, atp_readb_base(atpdev, 0x3f) & 0x40);
+		atp_writeb_base(atpdev, 0x38, 0xb0);
 		shpnt->max_id = 16;
 		shpnt->this_id = host_id;
 		shpnt->unique_id = base_io;
@@ -1410,50 +1414,43 @@ static int atp870u_probe(struct pci_dev *pdev, const struct pci_device_id *ent)
 		atpdev->pciport[0] = base_io + 0x40;
 		atpdev->pciport[1] = base_io + 0x50;
 				
-		shpnt = scsi_host_alloc(&atp870u_template, sizeof(struct atp_unit));
-		if (!shpnt)
-			goto err_nomem;
-        	
-		p = (struct atp_unit *)&shpnt->hostdata;
-        	
-		atpdev->host = shpnt;
-		atpdev->pdev = pdev;
-		pci_set_drvdata(pdev, p);
-		memcpy(p, atpdev, sizeof(struct atp_unit));
-		if (atp870u_init_tables(shpnt) < 0)
+		if (atp870u_init_tables(shpnt) < 0) {
+			err = -ENOMEM;
 			goto unregister;
+		}
 			
 #ifdef ED_DBGP		
-	printk("request_irq() shpnt %p hostdata %p\n", shpnt, p);
+	printk("request_irq() shpnt %p hostdata %p\n", shpnt, atpdev);
 #endif	        
-		if (request_irq(pdev->irq, atp870u_intr_handle, IRQF_SHARED, "atp870u", shpnt)) {
+		err = request_irq(pdev->irq, atp870u_intr_handle, IRQF_SHARED, "atp870u", shpnt);
+		if (err) {
 				printk(KERN_ERR "Unable to allocate IRQ for Acard controller.\n");
 			goto free_tables;
 		}
 		
 		spin_lock_irqsave(shpnt->host_lock, flags);        					
         			
-		c = atp_readb_base(p, 0x29);
-		atp_writeb_base(p, 0x29, c | 0x04);
+		c = atp_readb_base(atpdev, 0x29);
+		atp_writeb_base(atpdev, 0x29, c | 0x04);
         	
 		n=0x1f80;
 next_fblk_885:
 		if (n >= 0x2000) {
 		   goto flash_ok_885;
 		}
-		atp_writew_base(p, 0x3c, n);
-		if (atp_readl_base(p, 0x38) == 0xffffffff) {
+		atp_writew_base(atpdev, 0x3c, n);
+		if (atp_readl_base(atpdev, 0x38) == 0xffffffff) {
 		   goto flash_ok_885;
 		}
 		for (m=0; m < 2; m++) {
-		    p->global_map[m]= 0;
+		    atpdev->global_map[m]= 0;
 		    for (k=0; k < 4; k++) {
-			atp_writew_base(p, 0x3c, n++);
-			((unsigned long *)&setupdata[m][0])[k] = atp_readl_base(p, 0x38);
+			atp_writew_base(atpdev, 0x3c, n++);
+			((unsigned long *)&setupdata[m][0])[k] = atp_readl_base(atpdev, 0x38);
 		    }
 		    for (k=0; k < 4; k++) {
-			atp_writew_base(p, 0x3c, n++);
-			((unsigned long *)&p->sp[m][0])[k] = atp_readl_base(p, 0x38);
+			atp_writew_base(atpdev, 0x3c, n++);
+			((unsigned long *)&atpdev->sp[m][0])[k] = atp_readl_base(atpdev, 0x38);
 		    }
 		    n += 8;
 		}
@@ -1462,81 +1459,81 @@ static int atp870u_probe(struct pci_dev *pdev, const struct pci_device_id *ent)
 #ifdef ED_DBGP
 		printk( "Flash Read OK\n");
 #endif	
-		c = atp_readb_base(p, 0x29);
-		atp_writeb_base(p, 0x29, c & 0xfb);
+		c = atp_readb_base(atpdev, 0x29);
+		atp_writeb_base(atpdev, 0x29, c & 0xfb);
 		for (c=0;c < 2;c++) {
-		    p->ultra_map[c]=0;
-		    p->async[c] = 0;
+		    atpdev->ultra_map[c]=0;
+		    atpdev->async[c] = 0;
 		    for (k=0; k < 16; k++) {
 			n=1;
 			n = n << k;
-			if (p->sp[c][k] > 1) {
-			   p->ultra_map[c] |= n;
+			if (atpdev->sp[c][k] > 1) {
+			   atpdev->ultra_map[c] |= n;
 			} else {
-			   if (p->sp[c][k] == 0) {
-			      p->async[c] |= n;
+			   if (atpdev->sp[c][k] == 0) {
+			      atpdev->async[c] |= n;
 			   }
 			}
 		    }
-		    p->async[c] = ~(p->async[c]);
+		    atpdev->async[c] = ~(atpdev->async[c]);
 
-		    if (p->global_map[c] == 0) {
+		    if (atpdev->global_map[c] == 0) {
 		       k=setupdata[c][1];
 		       if ((k & 0x40) != 0)
-			  p->global_map[c] |= 0x20;
+			  atpdev->global_map[c] |= 0x20;
 		       k &= 0x07;
-		       p->global_map[c] |= k;
+		       atpdev->global_map[c] |= k;
 		       if ((setupdata[c][2] & 0x04) != 0)
-			  p->global_map[c] |= 0x08;
-		       p->host_id[c] = setupdata[c][0] & 0x07;
+			  atpdev->global_map[c] |= 0x08;
+		       atpdev->host_id[c] = setupdata[c][0] & 0x07;
 		    }
 		}
 
-		k = atp_readb_base(p, 0x28) & 0x8f;
+		k = atp_readb_base(atpdev, 0x28) & 0x8f;
 		k |= 0x10;
-		atp_writeb_base(p, 0x28, k);
-		atp_writeb_pci(p, 0, 1, 0x80);
-		atp_writeb_pci(p, 1, 1, 0x80);
+		atp_writeb_base(atpdev, 0x28, k);
+		atp_writeb_pci(atpdev, 0, 1, 0x80);
+		atp_writeb_pci(atpdev, 1, 1, 0x80);
 		mdelay(100);
-		atp_writeb_pci(p, 0, 1, 0);
-		atp_writeb_pci(p, 1, 1, 0);
+		atp_writeb_pci(atpdev, 0, 1, 0);
+		atp_writeb_pci(atpdev, 1, 1, 0);
 		mdelay(1000);
-		atp_readb_io(p, 0, 0x1b);
-		atp_readb_io(p, 0, 0x17);
-		atp_readb_io(p, 1, 0x1b);
-		atp_readb_io(p, 1, 0x17);
+		atp_readb_io(atpdev, 0, 0x1b);
+		atp_readb_io(atpdev, 0, 0x17);
+		atp_readb_io(atpdev, 1, 0x1b);
+		atp_readb_io(atpdev, 1, 0x17);
 
-		k=p->host_id[0];
+		k=atpdev->host_id[0];
 		if (k > 7)
 		   k = (k & 0x07) | 0x40;
-		atp_set_host_id(p, 0, k);
+		atp_set_host_id(atpdev, 0, k);
 
-		k=p->host_id[1];
+		k=atpdev->host_id[1];
 		if (k > 7)
 		   k = (k & 0x07) | 0x40;
-		atp_set_host_id(p, 1, k);
+		atp_set_host_id(atpdev, 1, k);
 
 		mdelay(600); /* this delay used to be called tscam_885() */
 		printk(KERN_INFO "   Scanning Channel A SCSI Device ...\n");
-		atp_is(p, 0, true, atp_readb_io(p, 0, 0x1b) >> 7);
-		atp_writeb_io(p, 0, 0x16, 0x80);
+		atp_is(atpdev, 0, true, atp_readb_io(atpdev, 0, 0x1b) >> 7);
+		atp_writeb_io(atpdev, 0, 0x16, 0x80);
 		printk(KERN_INFO "   Scanning Channel B SCSI Device ...\n");
-		atp_is(p, 1, true, atp_readb_io(p, 1, 0x1b) >> 7);
-		atp_writeb_io(p, 1, 0x16, 0x80);
-		k = atp_readb_base(p, 0x28) & 0xcf;
+		atp_is(atpdev, 1, true, atp_readb_io(atpdev, 1, 0x1b) >> 7);
+		atp_writeb_io(atpdev, 1, 0x16, 0x80);
+		k = atp_readb_base(atpdev, 0x28) & 0xcf;
 		k |= 0xc0;
-		atp_writeb_base(p, 0x28, k);
-		k = atp_readb_base(p, 0x1f) | 0x80;
-		atp_writeb_base(p, 0x1f, k);
-		k = atp_readb_base(p, 0x29) | 0x01;
-		atp_writeb_base(p, 0x29, k);
+		atp_writeb_base(atpdev, 0x28, k);
+		k = atp_readb_base(atpdev, 0x1f) | 0x80;
+		atp_writeb_base(atpdev, 0x1f, k);
+		k = atp_readb_base(atpdev, 0x29) | 0x01;
+		atp_writeb_base(atpdev, 0x29, k);
 #ifdef ED_DBGP
 		//printk("atp885: atp_host[0] 0x%p\n", atp_host[0]);
 #endif		
 		shpnt->max_id = 16;
-		shpnt->max_lun = (p->global_map[0] & 0x07) + 1;
+		shpnt->max_lun = (atpdev->global_map[0] & 0x07) + 1;
 		shpnt->max_channel = 1;
-		shpnt->this_id = p->host_id[0];
+		shpnt->this_id = atpdev->host_id[0];
 		shpnt->unique_id = base_io;
 		shpnt->io_port = base_io;
 		shpnt->n_io_port = 0xff;	/* Number of bytes of I/O space used */
@@ -1563,41 +1560,35 @@ static int atp870u_probe(struct pci_dev *pdev, const struct pci_device_id *ent)
 			atpdev->ultra_map[0] = 0xffff;
 		}
 
-		shpnt = scsi_host_alloc(&atp870u_template, sizeof(struct atp_unit));
-		if (!shpnt)
-			goto err_nomem;
 
-		p = (struct atp_unit *)&shpnt->hostdata;
-		
-		atpdev->host = shpnt;
-		atpdev->pdev = pdev;
-		pci_set_drvdata(pdev, p);
-		memcpy(p, atpdev, sizeof(*atpdev));
-		if (atp870u_init_tables(shpnt) < 0)
+		if (atp870u_init_tables(shpnt) < 0) {
+			err = -ENOMEM;
 			goto unregister;
+		}
 
-		if (request_irq(pdev->irq, atp870u_intr_handle, IRQF_SHARED, "atp870i", shpnt)) {
+		err = request_irq(pdev->irq, atp870u_intr_handle, IRQF_SHARED, "atp870i", shpnt);
+		if (err) {
 			printk(KERN_ERR "Unable to allocate IRQ%d for Acard controller.\n", pdev->irq);
 			goto free_tables;
 		}
 
 		spin_lock_irqsave(shpnt->host_lock, flags);
 		if (atpdev->chip_ver > 0x07)	/* check if atp876 chip then enable terminator */
-			atp_writeb_base(p, 0x3e, 0x00);
+			atp_writeb_base(atpdev, 0x3e, 0x00);
  
-		k = (atp_readb_base(p, 0x3a) & 0xf3) | 0x10;
-		atp_writeb_base(p, 0x3a, k);
-		atp_writeb_base(p, 0x3a, k & 0xdf);
+		k = (atp_readb_base(atpdev, 0x3a) & 0xf3) | 0x10;
+		atp_writeb_base(atpdev, 0x3a, k);
+		atp_writeb_base(atpdev, 0x3a, k & 0xdf);
 		mdelay(32);
-		atp_writeb_base(p, 0x3a, k);
+		atp_writeb_base(atpdev, 0x3a, k);
 		mdelay(32);
-		atp_set_host_id(p, 0, host_id);
+		atp_set_host_id(atpdev, 0, host_id);
 
 		tscam(shpnt);
-		atp_writeb_base(p, 0x3a, atp_readb_base(p, 0x3a) | 0x10);
-		atp_is(p, 0, p->chip_ver == 4, 0);
-		atp_writeb_base(p, 0x3a, atp_readb_base(p, 0x3a) & 0xef);
-		atp_writeb_base(p, 0x3b, atp_readb_base(p, 0x3b) | 0x20);
+		atp_writeb_base(atpdev, 0x3a, atp_readb_base(atpdev, 0x3a) | 0x10);
+		atp_is(atpdev, 0, atpdev->chip_ver == 4, 0);
+		atp_writeb_base(atpdev, 0x3a, atp_readb_base(atpdev, 0x3a) & 0xef);
+		atp_writeb_base(atpdev, 0x3b, atp_readb_base(atpdev, 0x3b) | 0x20);
 		if (atpdev->chip_ver == 4)
 			shpnt->max_id = 16;
 		else		
@@ -1609,9 +1600,12 @@ static int atp870u_probe(struct pci_dev *pdev, const struct pci_device_id *ent)
 		shpnt->irq = pdev->irq;		
 	} 
 		spin_unlock_irqrestore(shpnt->host_lock, flags);
-		if (!request_region(base_io, shpnt->n_io_port, "atp870u"))
+		if (!request_region(base_io, shpnt->n_io_port, "atp870u")) {
+			err = -EBUSY;
 			goto request_io_fail;
-		if (scsi_add_host(shpnt, &pdev->dev))
+		}
+		err = scsi_add_host(shpnt, &pdev->dev);
+		if (err)
 			goto scsi_add_fail;
 		scsi_scan_host(shpnt);
 #ifdef ED_DBGP			
@@ -1629,15 +1623,11 @@ static int atp870u_probe(struct pci_dev *pdev, const struct pci_device_id *ent)
 	printk("atp870u_prob:free_table\n");
 	atp870u_free_tables(shpnt);
 unregister:
-	printk("atp870u_prob:unregister\n");
 	scsi_host_put(shpnt);
-	return -1;		
-err_eio:
-	kfree(atpdev);
-	return -EIO;
-err_nomem:
-	kfree(atpdev);
-	return -ENOMEM;
+disable_device:
+	pci_disable_device(pdev);
+fail:
+	return err;
 }
 
 /* The abort command does not leave the device in a clean state where

commit c48442d1277a9b9e20ad38c29ca68485b921d4e9
Author: Ondrej Zary <linux@rainbow-software.org>
Date:   Tue Nov 17 19:24:15 2015 +0100

    atp870u: Remove useless and broken card counting
    
    Signed-off-by: Ondrej Zary <linux@rainbow-software.org>
    Reviewed-by: Hannes Reinicke <hare@suse.de>
    Acked-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/atp870u.c b/drivers/scsi/atp870u.c
index a06a0a4db71c..0b349bc4e6e6 100644
--- a/drivers/scsi/atp870u.c
+++ b/drivers/scsi/atp870u.c
@@ -1250,7 +1250,6 @@ static int atp870u_probe(struct pci_dev *pdev, const struct pci_device_id *ent)
 	struct Scsi_Host *shpnt = NULL;
 	struct atp_unit *atpdev, *p;
 	unsigned char setupdata[2][16];
-	int count = 0;
 
 	atpdev = kzalloc(sizeof(*atpdev), GFP_KERNEL);
 	if (!atpdev)
@@ -1298,8 +1297,8 @@ static int atp870u_probe(struct pci_dev *pdev, const struct pci_device_id *ent)
 		host_id = atp_readb_base(atpdev, 0x39);
 		host_id >>= 0x04;
 
-		printk(KERN_INFO "   ACARD AEC-67160 PCI Ultra3 LVD Host Adapter: %d"
-			"    IO:%x, IRQ:%d.\n", count, base_io, pdev->irq);
+		printk(KERN_INFO "   ACARD AEC-67160 PCI Ultra3 LVD Host Adapter:"
+			"    IO:%x, IRQ:%d.\n", base_io, pdev->irq);
 		atpdev->dev_id = ent->device;
 		atpdev->host_id[0] = host_id;
 
@@ -1546,8 +1545,8 @@ static int atp870u_probe(struct pci_dev *pdev, const struct pci_device_id *ent)
 	} else {
 		error = pci_read_config_byte(pdev, 0x49, &host_id);
 
-		printk(KERN_INFO "   ACARD AEC-671X PCI Ultra/W SCSI-2/3 Host Adapter: %d "
-			"IO:%x, IRQ:%d.\n", count, base_io, pdev->irq);
+		printk(KERN_INFO "   ACARD AEC-671X PCI Ultra/W SCSI-2/3 Host Adapter: "
+			"IO:%x, IRQ:%d.\n", base_io, pdev->irq);
 
 		atpdev->ioport[0] = base_io;
 		atpdev->pciport[0] = base_io + 0x20;
@@ -1612,7 +1611,6 @@ static int atp870u_probe(struct pci_dev *pdev, const struct pci_device_id *ent)
 		spin_unlock_irqrestore(shpnt->host_lock, flags);
 		if (!request_region(base_io, shpnt->n_io_port, "atp870u"))
 			goto request_io_fail;
-		count++;
 		if (scsi_add_host(shpnt, &pdev->dev))
 			goto scsi_add_fail;
 		scsi_scan_host(shpnt);

commit 30ebc7efcf5cf653ec2f5567d9fce2b4e1247ab7
Author: Ondrej Zary <linux@rainbow-software.org>
Date:   Tue Nov 17 19:24:14 2015 +0100

    atp870u: Use n_io_port in request_region and release_region
    
    Signed-off-by: Ondrej Zary <linux@rainbow-software.org>
    Reviewed-by: Hannes Reinicke <hare@suse.de>
    Acked-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/atp870u.c b/drivers/scsi/atp870u.c
index 7f53a50a0ab4..a06a0a4db71c 100644
--- a/drivers/scsi/atp870u.c
+++ b/drivers/scsi/atp870u.c
@@ -1610,16 +1610,8 @@ static int atp870u_probe(struct pci_dev *pdev, const struct pci_device_id *ent)
 		shpnt->irq = pdev->irq;		
 	} 
 		spin_unlock_irqrestore(shpnt->host_lock, flags);
-		if(ent->device==ATP885_DEVID) {
-			if(!request_region(base_io, 0xff, "atp870u")) /* Register the IO ports that we use */
-				goto request_io_fail;
-		} else if((ent->device==ATP880_DEVID1)||(ent->device==ATP880_DEVID2)) {
-			if(!request_region(base_io, 0x60, "atp870u")) /* Register the IO ports that we use */
-				goto request_io_fail;
-		} else {
-			if(!request_region(base_io, 0x40, "atp870u")) /* Register the IO ports that we use */
-				goto request_io_fail;
-		}				
+		if (!request_region(base_io, shpnt->n_io_port, "atp870u"))
+			goto request_io_fail;
 		count++;
 		if (scsi_add_host(shpnt, &pdev->dev))
 			goto scsi_add_fail;
@@ -1631,13 +1623,7 @@ static int atp870u_probe(struct pci_dev *pdev, const struct pci_device_id *ent)
 
 scsi_add_fail:
 	printk("atp870u_prob:scsi_add_fail\n");
-	if(ent->device==ATP885_DEVID) {
-		release_region(base_io, 0xff);
-	} else if((ent->device==ATP880_DEVID1)||(ent->device==ATP880_DEVID2)) {
-		release_region(base_io, 0x60);
-	} else {
-		release_region(base_io, 0x40);
-	}
+	release_region(base_io, shpnt->n_io_port);
 request_io_fail:
 	printk("atp870u_prob:request_io_fail\n");
 	free_irq(pdev->irq, shpnt);

commit 1ccd7d68fc3004e3ed111753e62385176fa28f40
Author: Ondrej Zary <linux@rainbow-software.org>
Date:   Tue Nov 17 19:24:13 2015 +0100

    atp870u: Use module_pci_driver
    
    Signed-off-by: Ondrej Zary <linux@rainbow-software.org>
    Reviewed-by: Hannes Reinicke <hare@suse.de>
    Acked-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/atp870u.c b/drivers/scsi/atp870u.c
index 2570919af0e0..7f53a50a0ab4 100644
--- a/drivers/scsi/atp870u.c
+++ b/drivers/scsi/atp870u.c
@@ -1785,21 +1785,7 @@ static struct pci_driver atp870u_driver = {
 	.remove		= atp870u_remove,
 };
 
-static int __init atp870u_init(void)
-{
-#ifdef ED_DBGP	
-	printk("atp870u_init: Entry\n");
-#endif	
-	return pci_register_driver(&atp870u_driver);
-}
-
-static void __exit atp870u_exit(void)
-{
-#ifdef ED_DBGP	
-	printk("atp870u_exit: Entry\n");
-#endif
-	pci_unregister_driver(&atp870u_driver);
-}
+module_pci_driver(atp870u_driver);
 
 static void atp_is(struct atp_unit *dev, unsigned char c, bool wide_chip, unsigned char lvdmode)
 {
@@ -2406,7 +2392,3 @@ static void atp_is(struct atp_unit *dev, unsigned char c, bool wide_chip, unsign
 #endif
 	}
 }
-
-module_init(atp870u_init);
-module_exit(atp870u_exit);
-

commit c4ad92bce06bf73946ea4bd5771b987685221e8a
Author: Ondrej Zary <linux@rainbow-software.org>
Date:   Tue Nov 17 19:24:12 2015 +0100

    atp870u: Remove empty tscam_885()
    
    tscam_885() is empty (except a delay) so remove it.
    
    Signed-off-by: Ondrej Zary <linux@rainbow-software.org>
    Reviewed-by: Hannes Reinicke <hare@suse.de>
    Acked-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/atp870u.c b/drivers/scsi/atp870u.c
index b662e395b5ea..2570919af0e0 100644
--- a/drivers/scsi/atp870u.c
+++ b/drivers/scsi/atp870u.c
@@ -42,7 +42,6 @@
 static struct scsi_host_template atp870u_template;
 static void send_s870(struct atp_unit *dev,unsigned char c);
 static void atp_is(struct atp_unit *dev, unsigned char c, bool wide_chip, unsigned char lvdmode);
-static void tscam_885(void);
 
 static inline void atp_writeb_base(struct atp_unit *atp, u8 reg, u8 val)
 {
@@ -1518,7 +1517,7 @@ static int atp870u_probe(struct pci_dev *pdev, const struct pci_device_id *ent)
 		   k = (k & 0x07) | 0x40;
 		atp_set_host_id(p, 1, k);
 
-		tscam_885();
+		mdelay(600); /* this delay used to be called tscam_885() */
 		printk(KERN_INFO "   Scanning Channel A SCSI Device ...\n");
 		atp_is(p, 0, true, atp_readb_io(p, 0, 0x1b) >> 7);
 		atp_writeb_io(p, 0, 0x16, 0x80);
@@ -1802,18 +1801,6 @@ static void __exit atp870u_exit(void)
 	pci_unregister_driver(&atp870u_driver);
 }
 
-static void tscam_885(void)
-{
-	unsigned char i;
-
-	for (i = 0; i < 0x2; i++) {
-		mdelay(300);
-	}
-	return;
-}
-
-
-
 static void atp_is(struct atp_unit *dev, unsigned char c, bool wide_chip, unsigned char lvdmode)
 {
 	unsigned char i, j, k, rmb, n;

commit 34a2c35d29a160b326bc63dfbff64ae38fe0a994
Author: Ondrej Zary <linux@rainbow-software.org>
Date:   Tue Nov 17 19:24:11 2015 +0100

    atp870u: Reduce log spam on module load/unload
    
    Signed-off-by: Ondrej Zary <linux@rainbow-software.org>
    Reviewed-by: Hannes Reinicke <hare@suse.de>
    Acked-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/atp870u.c b/drivers/scsi/atp870u.c
index 96214035b6d6..b662e395b5ea 100644
--- a/drivers/scsi/atp870u.c
+++ b/drivers/scsi/atp870u.c
@@ -1260,9 +1260,7 @@ static int atp870u_probe(struct pci_dev *pdev, const struct pci_device_id *ent)
 	if (pci_enable_device(pdev))
 		goto err_eio;
 
-        if (!pci_set_dma_mask(pdev, DMA_BIT_MASK(32))) {
-                printk(KERN_INFO "atp870u: use 32bit DMA mask.\n");
-        } else {
+	if (pci_set_dma_mask(pdev, DMA_BIT_MASK(32))) {
                 printk(KERN_ERR "atp870u: DMA mask required but not available.\n");
 		goto err_eio;
         }
@@ -1742,12 +1740,9 @@ static void atp870u_remove (struct pci_dev *pdev)
 	
 	
 	scsi_remove_host(pshost);
-	printk(KERN_INFO "free_irq : %d\n",pshost->irq);
 	free_irq(pshost->irq, pshost);
 	release_region(pshost->io_port, pshost->n_io_port);
-	printk(KERN_INFO "atp870u_free_tables : %p\n",pshost);
 	atp870u_free_tables(pshost);
-	printk(KERN_INFO "scsi_host_put : %p\n",pshost);
 	scsi_host_put(pshost);
 }
 MODULE_LICENSE("GPL");

commit 6a1961bc9c8916fc40423cc71e44fd8c59fef360
Author: Ondrej Zary <linux@rainbow-software.org>
Date:   Tue Nov 17 19:24:10 2015 +0100

    atp870u: Introduce atp_set_host_id
    
    The code for setting host adapter ID is the same for all chips.
    Move it to a common function.
    
    Signed-off-by: Ondrej Zary <linux@rainbow-software.org>
    Reviewed-by: Hannes Reinicke <hare@suse.de>
    Acked-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/atp870u.c b/drivers/scsi/atp870u.c
index 04b29d3e65d6..96214035b6d6 100644
--- a/drivers/scsi/atp870u.c
+++ b/drivers/scsi/atp870u.c
@@ -1229,6 +1229,18 @@ static int atp870u_init_tables(struct Scsi_Host *host)
 	return 0;
 }
 
+static void atp_set_host_id(struct atp_unit *atp, u8 c, u8 host_id)
+{
+	atp_writeb_io(atp, c, 0, host_id | 0x08);
+	atp_writeb_io(atp, c, 0x18, 0);
+	while ((atp_readb_io(atp, c, 0x1f) & 0x80) == 0)
+		mdelay(1);
+	atp_readb_io(atp, c, 0x17);
+	atp_writeb_io(atp, c, 1, 8);
+	atp_writeb_io(atp, c, 2, 0x7f);
+	atp_writeb_io(atp, c, 0x11, 0x20);
+}
+
 /* return non-zero on detection */
 static int atp870u_probe(struct pci_dev *pdev, const struct pci_device_id *ent)
 {
@@ -1379,14 +1391,8 @@ static int atp870u_probe(struct pci_dev *pdev, const struct pci_device_id *ent)
 		mdelay(32);
 		atp_readb_io(p, 0, 0x1b);
 		atp_readb_io(p, 0, 0x17);
-		atp_writeb_io(p, 0, 0, host_id | 0x08);
-		atp_writeb_io(p, 0, 0x18, 0);
-		while ((atp_readb_io(p, 0, 0x1f) & 0x80) == 0)
-			mdelay(1);
-		atp_readb_io(p, 0, 0x17);
-		atp_writeb_io(p, 0, 1, 8);
-		atp_writeb_io(p, 0, 2, 0x7f);
-		atp_writeb_io(p, 0, 0x11, 0x20);
+
+		atp_set_host_id(p, 0, host_id);
 
 		tscam(shpnt);
 		atp_is(p, 0, true, atp_readb_base(p, 0x3f) & 0x40);
@@ -1503,35 +1509,16 @@ static int atp870u_probe(struct pci_dev *pdev, const struct pci_device_id *ent)
 		atp_readb_io(p, 0, 0x17);
 		atp_readb_io(p, 1, 0x1b);
 		atp_readb_io(p, 1, 0x17);
+
 		k=p->host_id[0];
 		if (k > 7)
 		   k = (k & 0x07) | 0x40;
-		k |= 0x08;
-		atp_writeb_io(p, 0, 0, k);
-		atp_writeb_io(p, 0, 0x18, 0);
-
-		while ((atp_readb_io(p, 0, 0x1f) & 0x80) == 0)
-			cpu_relax();
-	
-		atp_readb_io(p, 0, 0x17);
-		atp_writeb_io(p, 0, 1, 8);
-		atp_writeb_io(p, 0, 2, 0x7f);
-		atp_writeb_io(p, 0, 0x11, 0x20);
+		atp_set_host_id(p, 0, k);
 
 		k=p->host_id[1];
 		if (k > 7)
 		   k = (k & 0x07) | 0x40;
-		k |= 0x08;
-		atp_writeb_io(p, 1, 0, k);
-		atp_writeb_io(p, 1, 0x18, 0);
-
-		while ((atp_readb_io(p, 1, 0x1f) & 0x80) == 0)
-			cpu_relax();
-
-		atp_readb_io(p, 1, 0x17);
-		atp_writeb_io(p, 1, 1, 8);
-		atp_writeb_io(p, 1, 2, 0x7f);
-		atp_writeb_io(p, 1, 0x11, 0x20);
+		atp_set_host_id(p, 1, k);
 
 		tscam_885();
 		printk(KERN_INFO "   Scanning Channel A SCSI Device ...\n");
@@ -1608,15 +1595,7 @@ static int atp870u_probe(struct pci_dev *pdev, const struct pci_device_id *ent)
 		mdelay(32);
 		atp_writeb_base(p, 0x3a, k);
 		mdelay(32);
-		atp_writeb_io(p, 0, 0, host_id | 0x08);
-		atp_writeb_io(p, 0, 0x18, 0);
-		while ((atp_readb_io(p, 0, 0x1f) & 0x80) == 0)
-			mdelay(1);
-
-		atp_readb_io(p, 0, 0x17);
-		atp_writeb_io(p, 0, 1, 8);
-		atp_writeb_io(p, 0, 2, 0x7f);
-		atp_writeb_io(p, 0, 0x11, 0x20);
+		atp_set_host_id(p, 0, host_id);
 
 		tscam(shpnt);
 		atp_writeb_base(p, 0x3a, atp_readb_base(p, 0x3a) | 0x10);

commit c751d9f1fce4187bf1c0848d7d3a5bf7644d7f9c
Author: Ondrej Zary <linux@rainbow-software.org>
Date:   Tue Nov 17 19:24:09 2015 +0100

    atp870u: Fix incorrect writeb_io access to register 0x3a
    
    The ioport region is 0x20 bytes long so accessing 0x3a register using
    writeb_io is incorrect. Use writeb_base instead.
    There's no change in behavior as 870 chips have ioport = baseport.
    
    Signed-off-by: Ondrej Zary <linux@rainbow-software.org>
    Reviewed-by: Hannes Reinicke <hare@suse.de>
    Acked-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/atp870u.c b/drivers/scsi/atp870u.c
index c4a59cc0821b..04b29d3e65d6 100644
--- a/drivers/scsi/atp870u.c
+++ b/drivers/scsi/atp870u.c
@@ -364,9 +364,9 @@ static irqreturn_t atp870u_intr_handle(int irq, void *dev_id)
 					atp_writeb_base(dev, 0x3b, atp_readb_base(dev, 0x3b) & 0x3f);
 			} else {				
 				if ((workreq->cmnd[0] == 0x08) || (workreq->cmnd[0] == 0x28) || (workreq->cmnd[0] == 0x0a) || (workreq->cmnd[0] == 0x2a))
-					atp_writeb_io(dev, c, 0x3a, (atp_readb_io(dev, c, 0x3a) & 0xf3) | 0x08);
+					atp_writeb_base(dev, 0x3a, (atp_readb_base(dev, 0x3a) & 0xf3) | 0x08);
 				else
-					atp_writeb_io(dev, c, 0x3a, atp_readb_io(dev, c, 0x3a) & 0xf3);
+					atp_writeb_base(dev, 0x3a, atp_readb_base(dev, 0x3a) & 0xf3);
 			}	
 			j = 0;
 			id = 1;
@@ -889,9 +889,9 @@ static void send_s870(struct atp_unit *dev,unsigned char c)
 			atp_writeb_base(dev, 0x3b, atp_readb_base(dev, 0x3b) & 0x3f);
 	} else {		
 		if ((workreq->cmnd[0] == 0x08) || (workreq->cmnd[0] == 0x28) || (workreq->cmnd[0] == 0x0a) || (workreq->cmnd[0] == 0x2a))
-			atp_writeb_io(dev, c, 0x3a, (atp_readb_io(dev, c, 0x3a) & 0xf3) | 0x08);
+			atp_writeb_base(dev, 0x3a, (atp_readb_base(dev, 0x3a) & 0xf3) | 0x08);
 		else
-			atp_writeb_io(dev, c, 0x3a, atp_readb_io(dev, c, 0x3a) & 0xf3);
+			atp_writeb_base(dev, 0x3a, atp_readb_base(dev, 0x3a) & 0xf3);
 	}	
 
 	if(workreq->sc_data_direction == DMA_TO_DEVICE) {

commit 2bbbac4571de7983f142ed22add59e5217674169
Author: Ondrej Zary <linux@rainbow-software.org>
Date:   Tue Nov 17 19:24:08 2015 +0100

    atp870u: Replace port 0x80 delay by udelay
    
    tscam() is using port 0x80 access for delays but that's x86-only.
    Use udelay(2) instead.
    
    Signed-off-by: Ondrej Zary <linux@rainbow-software.org>
    Reviewed-by: Hannes Reinicke <hare@suse.de>
    Acked-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/atp870u.c b/drivers/scsi/atp870u.c
index bccf872903e5..c4a59cc0821b 100644
--- a/drivers/scsi/atp870u.c
+++ b/drivers/scsi/atp870u.c
@@ -1036,7 +1036,7 @@ static void tscam(struct Scsi_Host *host)
 	atp_writeb_io(dev, 0, 0x02, 0x7f);
 	atp_writeb_io(dev, 0, 0x1b, 0x02);
 
-	outb(0, 0x80);
+	udelay(2);
 
 	val = 0x0080;		/* bsy  */
 	atp_writew_io(dev, 0, 0x1c, val);
@@ -1044,7 +1044,7 @@ static void tscam(struct Scsi_Host *host)
 	atp_writew_io(dev, 0, 0x1c, val);
 	val |= 0x0004;		/* msg  */
 	atp_writew_io(dev, 0, 0x1c, val);
-	inb(0x80);		/* 2 deskew delay(45ns*2=90ns) */
+	udelay(2);		/* 2 deskew delay(45ns*2=90ns) */
 	val &= 0x007f;		/* no bsy  */
 	atp_writew_io(dev, 0, 0x1c, val);
 	mdelay(128);
@@ -1052,7 +1052,7 @@ static void tscam(struct Scsi_Host *host)
 	atp_writew_io(dev, 0, 0x1c, val);
 	while ((atp_readb_io(dev, 0, 0x1c) & 0x04) != 0)
 		;
-	outb(1, 0x80);
+	udelay(2);
 	udelay(100);
 	for (n = 0; n < 0x30000; n++)
 		if ((atp_readb_io(dev, 0, 0x1c) & 0x80) != 0)	/* bsy ? */
@@ -1060,13 +1060,13 @@ static void tscam(struct Scsi_Host *host)
 	if (n < 0x30000)
 		for (n = 0; n < 0x30000; n++)
 			if ((atp_readb_io(dev, 0, 0x1c) & 0x81) == 0x0081) {
-				inb(0x80);
+				udelay(2);
 				val |= 0x8003;		/* io,cd,db7  */
 				atp_writew_io(dev, 0, 0x1c, val);
-				inb(0x80);
+				udelay(2);
 				val &= 0x00bf;		/* no sel     */
 				atp_writew_io(dev, 0, 0x1c, val);
-				outb(2, 0x80);
+				udelay(2);
 				break;
 			}
 	while (1) {
@@ -1093,18 +1093,18 @@ static void tscam(struct Scsi_Host *host)
 	val &= 0x00ff;		/* synchronization  */
 	val |= 0x3f00;
 	fun_scam(dev, &val);
-	outb(3, 0x80);
+	udelay(2);
 	val &= 0x00ff;		/* isolation        */
 	val |= 0x2000;
 	fun_scam(dev, &val);
-	outb(4, 0x80);
+	udelay(2);
 	i = 8;
 	j = 0;
 
 	while (1) {
 		if ((atp_readw_io(dev, 0, 0x1c) & 0x2000) == 0)
 			continue;
-		outb(5, 0x80);
+		udelay(2);
 		val &= 0x00ff;		/* get ID_STRING */
 		val |= 0x2000;
 		k = fun_scam(dev, &val);

commit d804bb255ce85b1fd7dfe447da5415952ba341c5
Author: Ondrej Zary <linux@rainbow-software.org>
Date:   Tue Nov 17 19:24:07 2015 +0100

    atp870u: Convert remaining in[bwl] and out[bwl] to wrappers
    
    Signed-off-by: Ondrej Zary <linux@rainbow-software.org>
    Reviewed-by: Hannes Reinicke <hare@suse.de>
    Acked-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/atp870u.c b/drivers/scsi/atp870u.c
index 0b7d3bd85408..bccf872903e5 100644
--- a/drivers/scsi/atp870u.c
+++ b/drivers/scsi/atp870u.c
@@ -49,6 +49,11 @@ static inline void atp_writeb_base(struct atp_unit *atp, u8 reg, u8 val)
 	outb(val, atp->baseport + reg);
 }
 
+static inline void atp_writew_base(struct atp_unit *atp, u8 reg, u16 val)
+{
+	outw(val, atp->baseport + reg);
+}
+
 static inline void atp_writeb_io(struct atp_unit *atp, u8 channel, u8 reg, u8 val)
 {
 	outb(val, atp->ioport[channel] + reg);
@@ -74,6 +79,16 @@ static inline u8 atp_readb_base(struct atp_unit *atp, u8 reg)
 	return inb(atp->baseport + reg);
 }
 
+static inline u16 atp_readw_base(struct atp_unit *atp, u8 reg)
+{
+	return inw(atp->baseport + reg);
+}
+
+static inline u32 atp_readl_base(struct atp_unit *atp, u8 reg)
+{
+	return inl(atp->baseport + reg);
+}
+
 static inline u8 atp_readb_io(struct atp_unit *atp, u8 channel, u8 reg)
 {
 	return inb(atp->ioport[channel] + reg);
@@ -1268,19 +1283,20 @@ static int atp870u_probe(struct pci_dev *pdev, const struct pci_device_id *ent)
 		atpdev->chip_ver = pdev->revision;
 		pci_write_config_byte(pdev, PCI_LATENCY_TIMER, 0x80);//JCC082803
 
-		host_id = inb(base_io + 0x39);
+		atpdev->ioport[0] = base_io + 0x40;
+		atpdev->pciport[0] = base_io + 0x28;
+
+		host_id = atp_readb_base(atpdev, 0x39);
 		host_id >>= 0x04;
 
 		printk(KERN_INFO "   ACARD AEC-67160 PCI Ultra3 LVD Host Adapter: %d"
 			"    IO:%x, IRQ:%d.\n", count, base_io, pdev->irq);
-		atpdev->ioport[0] = base_io + 0x40;
-		atpdev->pciport[0] = base_io + 0x28;
 		atpdev->dev_id = ent->device;
 		atpdev->host_id[0] = host_id;
 
-		atpdev->scam_on = inb(base_io + 0x22);
-		atpdev->global_map[0] = inb(base_io + 0x35);
-		atpdev->ultra_map[0] = inw(base_io + 0x3c);
+		atpdev->scam_on = atp_readb_base(atpdev, 0x22);
+		atpdev->global_map[0] = atp_readb_base(atpdev, 0x35);
+		atpdev->ultra_map[0] = atp_readw_base(atpdev, 0x3c);
 
 		n = 0x3f09;
 next_fblk_880:
@@ -1288,37 +1304,37 @@ static int atp870u_probe(struct pci_dev *pdev, const struct pci_device_id *ent)
 			goto flash_ok_880;
 
 		m = 0;
-		outw(n, base_io + 0x34);
+		atp_writew_base(atpdev, 0x34, n);
 		n += 0x0002;
-		if (inb(base_io + 0x30) == 0xff)
+		if (atp_readb_base(atpdev, 0x30) == 0xff)
 			goto flash_ok_880;
 
-		atpdev->sp[0][m++] = inb(base_io + 0x30);
-		atpdev->sp[0][m++] = inb(base_io + 0x31);
-		atpdev->sp[0][m++] = inb(base_io + 0x32);
-		atpdev->sp[0][m++] = inb(base_io + 0x33);
-		outw(n, base_io + 0x34);
+		atpdev->sp[0][m++] = atp_readb_base(atpdev, 0x30);
+		atpdev->sp[0][m++] = atp_readb_base(atpdev, 0x31);
+		atpdev->sp[0][m++] = atp_readb_base(atpdev, 0x32);
+		atpdev->sp[0][m++] = atp_readb_base(atpdev, 0x33);
+		atp_writew_base(atpdev, 0x34, n);
 		n += 0x0002;
-		atpdev->sp[0][m++] = inb(base_io + 0x30);
-		atpdev->sp[0][m++] = inb(base_io + 0x31);
-		atpdev->sp[0][m++] = inb(base_io + 0x32);
-		atpdev->sp[0][m++] = inb(base_io + 0x33);
-		outw(n, base_io + 0x34);
+		atpdev->sp[0][m++] = atp_readb_base(atpdev, 0x30);
+		atpdev->sp[0][m++] = atp_readb_base(atpdev, 0x31);
+		atpdev->sp[0][m++] = atp_readb_base(atpdev, 0x32);
+		atpdev->sp[0][m++] = atp_readb_base(atpdev, 0x33);
+		atp_writew_base(atpdev, 0x34, n);
 		n += 0x0002;
-		atpdev->sp[0][m++] = inb(base_io + 0x30);
-		atpdev->sp[0][m++] = inb(base_io + 0x31);
-		atpdev->sp[0][m++] = inb(base_io + 0x32);
-		atpdev->sp[0][m++] = inb(base_io + 0x33);
-		outw(n, base_io + 0x34);
+		atpdev->sp[0][m++] = atp_readb_base(atpdev, 0x30);
+		atpdev->sp[0][m++] = atp_readb_base(atpdev, 0x31);
+		atpdev->sp[0][m++] = atp_readb_base(atpdev, 0x32);
+		atpdev->sp[0][m++] = atp_readb_base(atpdev, 0x33);
+		atp_writew_base(atpdev, 0x34, n);
 		n += 0x0002;
-		atpdev->sp[0][m++] = inb(base_io + 0x30);
-		atpdev->sp[0][m++] = inb(base_io + 0x31);
-		atpdev->sp[0][m++] = inb(base_io + 0x32);
-		atpdev->sp[0][m++] = inb(base_io + 0x33);
+		atpdev->sp[0][m++] = atp_readb_base(atpdev, 0x30);
+		atpdev->sp[0][m++] = atp_readb_base(atpdev, 0x31);
+		atpdev->sp[0][m++] = atp_readb_base(atpdev, 0x32);
+		atpdev->sp[0][m++] = atp_readb_base(atpdev, 0x33);
 		n += 0x0018;
 		goto next_fblk_880;
 flash_ok_880:
-		outw(0, base_io + 0x34);
+		atp_writew_base(atpdev, 0x34, 0);
 		atpdev->ultra_map[0] = 0;
 		atpdev->async[0] = 0;
 		for (k = 0; k < 16; k++) {
@@ -1332,7 +1348,7 @@ static int atp870u_probe(struct pci_dev *pdev, const struct pci_device_id *ent)
  			}
 	 	}
 		atpdev->async[0] = ~(atpdev->async[0]);
-		outb(atpdev->global_map[0], base_io + 0x35);
+		atp_writeb_base(atpdev, 0x35, atpdev->global_map[0]);
  
 		shpnt = scsi_host_alloc(&atp870u_template, sizeof(struct atp_unit));
 		if (!shpnt)
@@ -1355,26 +1371,26 @@ static int atp870u_probe(struct pci_dev *pdev, const struct pci_device_id *ent)
 		}
 
 		spin_lock_irqsave(shpnt->host_lock, flags);
-		k = inb(base_io + 0x38) & 0x80;
-		outb(k, base_io + 0x38);
-		outb(0x20, base_io + 0x3b);
+		k = atp_readb_base(p, 0x38) & 0x80;
+		atp_writeb_base(p, 0x38, k);
+		atp_writeb_base(p, 0x3b, 0x20);
 		mdelay(32);
-		outb(0, base_io + 0x3b);
+		atp_writeb_base(p, 0x3b, 0);
 		mdelay(32);
-		inb(base_io + 0x5b);
-		inb(base_io + 0x57);
-		outb((host_id | 0x08), base_io + 0x40);
-		outb(0, base_io + 0x58);
-		while ((inb(base_io + 0x5f) & 0x80) == 0)
+		atp_readb_io(p, 0, 0x1b);
+		atp_readb_io(p, 0, 0x17);
+		atp_writeb_io(p, 0, 0, host_id | 0x08);
+		atp_writeb_io(p, 0, 0x18, 0);
+		while ((atp_readb_io(p, 0, 0x1f) & 0x80) == 0)
 			mdelay(1);
-		inb(base_io + 0x57);
-		outb(8, base_io + 0x41);
-		outb(0x7f, base_io + 0x42);
-		outb(0x20, base_io + 0x51);
+		atp_readb_io(p, 0, 0x17);
+		atp_writeb_io(p, 0, 1, 8);
+		atp_writeb_io(p, 0, 2, 0x7f);
+		atp_writeb_io(p, 0, 0x11, 0x20);
 
 		tscam(shpnt);
 		atp_is(p, 0, true, atp_readb_base(p, 0x3f) & 0x40);
-		outb(0xb0, base_io + 0x38);
+		atp_writeb_base(p, 0x38, 0xb0);
 		shpnt->max_id = 16;
 		shpnt->this_id = host_id;
 		shpnt->unique_id = base_io;
@@ -1415,27 +1431,27 @@ static int atp870u_probe(struct pci_dev *pdev, const struct pci_device_id *ent)
 		
 		spin_lock_irqsave(shpnt->host_lock, flags);        					
         			
-		c=inb(base_io + 0x29);
-		outb((c | 0x04),base_io + 0x29);
+		c = atp_readb_base(p, 0x29);
+		atp_writeb_base(p, 0x29, c | 0x04);
         	
 		n=0x1f80;
 next_fblk_885:
 		if (n >= 0x2000) {
 		   goto flash_ok_885;
 		}
-		outw(n,base_io + 0x3c);
-		if (inl(base_io + 0x38) == 0xffffffff) {
+		atp_writew_base(p, 0x3c, n);
+		if (atp_readl_base(p, 0x38) == 0xffffffff) {
 		   goto flash_ok_885;
 		}
 		for (m=0; m < 2; m++) {
 		    p->global_map[m]= 0;
 		    for (k=0; k < 4; k++) {
-			outw(n++,base_io + 0x3c);
-			((unsigned long *)&setupdata[m][0])[k]=inl(base_io + 0x38);
+			atp_writew_base(p, 0x3c, n++);
+			((unsigned long *)&setupdata[m][0])[k] = atp_readl_base(p, 0x38);
 		    }
 		    for (k=0; k < 4; k++) {
-			outw(n++,base_io + 0x3c);
-			((unsigned long *)&p->sp[m][0])[k]=inl(base_io + 0x38);
+			atp_writew_base(p, 0x3c, n++);
+			((unsigned long *)&p->sp[m][0])[k] = atp_readl_base(p, 0x38);
 		    }
 		    n += 8;
 		}
@@ -1444,8 +1460,8 @@ static int atp870u_probe(struct pci_dev *pdev, const struct pci_device_id *ent)
 #ifdef ED_DBGP
 		printk( "Flash Read OK\n");
 #endif	
-		c=inb(base_io + 0x29);
-		outb((c & 0xfb),base_io + 0x29);
+		c = atp_readb_base(p, 0x29);
+		atp_writeb_base(p, 0x29, c & 0xfb);
 		for (c=0;c < 2;c++) {
 		    p->ultra_map[c]=0;
 		    p->async[c] = 0;
@@ -1474,48 +1490,48 @@ static int atp870u_probe(struct pci_dev *pdev, const struct pci_device_id *ent)
 		    }
 		}
 
-		k = inb(base_io + 0x28) & 0x8f;
+		k = atp_readb_base(p, 0x28) & 0x8f;
 		k |= 0x10;
-		outb(k, base_io + 0x28);
-		outb(0x80, base_io + 0x41);
-		outb(0x80, base_io + 0x51);
+		atp_writeb_base(p, 0x28, k);
+		atp_writeb_pci(p, 0, 1, 0x80);
+		atp_writeb_pci(p, 1, 1, 0x80);
 		mdelay(100);
-		outb(0, base_io + 0x41);
-		outb(0, base_io + 0x51);
+		atp_writeb_pci(p, 0, 1, 0);
+		atp_writeb_pci(p, 1, 1, 0);
 		mdelay(1000);
-		inb(base_io + 0x9b);
-		inb(base_io + 0x97);
-		inb(base_io + 0xdb);
-		inb(base_io + 0xd7);
+		atp_readb_io(p, 0, 0x1b);
+		atp_readb_io(p, 0, 0x17);
+		atp_readb_io(p, 1, 0x1b);
+		atp_readb_io(p, 1, 0x17);
 		k=p->host_id[0];
 		if (k > 7)
 		   k = (k & 0x07) | 0x40;
 		k |= 0x08;
-		outb(k, base_io + 0x80);
-		outb(0, base_io + 0x98);
+		atp_writeb_io(p, 0, 0, k);
+		atp_writeb_io(p, 0, 0x18, 0);
 
-		while ((inb(base_io + 0x9f) & 0x80) == 0)
+		while ((atp_readb_io(p, 0, 0x1f) & 0x80) == 0)
 			cpu_relax();
 	
-		inb(base_io + 0x97);
-		outb(8, base_io + 0x81);
-		outb(0x7f, base_io + 0x82);
-		outb(0x20, base_io + 0x91);
+		atp_readb_io(p, 0, 0x17);
+		atp_writeb_io(p, 0, 1, 8);
+		atp_writeb_io(p, 0, 2, 0x7f);
+		atp_writeb_io(p, 0, 0x11, 0x20);
 
 		k=p->host_id[1];
 		if (k > 7)
 		   k = (k & 0x07) | 0x40;
 		k |= 0x08;
-		outb(k, base_io + 0xc0);
-		outb(0, base_io + 0xd8);
+		atp_writeb_io(p, 1, 0, k);
+		atp_writeb_io(p, 1, 0x18, 0);
 
-		while ((inb(base_io + 0xdf) & 0x80) == 0)
+		while ((atp_readb_io(p, 1, 0x1f) & 0x80) == 0)
 			cpu_relax();
 
-		inb(base_io + 0xd7);
-		outb(8, base_io + 0xc1);
-		outb(0x7f, base_io + 0xc2);
-		outb(0x20, base_io + 0xd1);
+		atp_readb_io(p, 1, 0x17);
+		atp_writeb_io(p, 1, 1, 8);
+		atp_writeb_io(p, 1, 2, 0x7f);
+		atp_writeb_io(p, 1, 0x11, 0x20);
 
 		tscam_885();
 		printk(KERN_INFO "   Scanning Channel A SCSI Device ...\n");
@@ -1524,13 +1540,13 @@ static int atp870u_probe(struct pci_dev *pdev, const struct pci_device_id *ent)
 		printk(KERN_INFO "   Scanning Channel B SCSI Device ...\n");
 		atp_is(p, 1, true, atp_readb_io(p, 1, 0x1b) >> 7);
 		atp_writeb_io(p, 1, 0x16, 0x80);
-		k = inb(base_io + 0x28) & 0xcf;
+		k = atp_readb_base(p, 0x28) & 0xcf;
 		k |= 0xc0;
-		outb(k, base_io + 0x28);
-		k = inb(base_io + 0x1f) | 0x80;
-		outb(k, base_io + 0x1f);
-		k = inb(base_io + 0x29) | 0x01;
-		outb(k, base_io + 0x29);
+		atp_writeb_base(p, 0x28, k);
+		k = atp_readb_base(p, 0x1f) | 0x80;
+		atp_writeb_base(p, 0x1f, k);
+		k = atp_readb_base(p, 0x29) | 0x01;
+		atp_writeb_base(p, 0x29, k);
 #ifdef ED_DBGP
 		//printk("atp885: atp_host[0] 0x%p\n", atp_host[0]);
 #endif		
@@ -1554,9 +1570,9 @@ static int atp870u_probe(struct pci_dev *pdev, const struct pci_device_id *ent)
 		atpdev->dev_id = ent->device;
 		host_id &= 0x07;
 		atpdev->host_id[0] = host_id;
-		atpdev->scam_on = inb(base_io + 0x22);
-		atpdev->global_map[0] = inb(base_io + 0x2d);
-		atpdev->ultra_map[0] = inw(base_io + 0x2e);
+		atpdev->scam_on = atp_readb_pci(atpdev, 0, 2);
+		atpdev->global_map[0] = atp_readb_base(atpdev, 0x2d);
+		atpdev->ultra_map[0] = atp_readw_base(atpdev, 0x2e);
 
 		if (atpdev->ultra_map[0] == 0) {
 			atpdev->scam_on = 0x00;
@@ -1583,32 +1599,30 @@ static int atp870u_probe(struct pci_dev *pdev, const struct pci_device_id *ent)
 		}
 
 		spin_lock_irqsave(shpnt->host_lock, flags);
-		if (atpdev->chip_ver > 0x07) {	/* check if atp876 chip then enable terminator */
-			outb(0x00, base_io + 0x3e);
-		}
+		if (atpdev->chip_ver > 0x07)	/* check if atp876 chip then enable terminator */
+			atp_writeb_base(p, 0x3e, 0x00);
  
-		k = (inb(base_io + 0x3a) & 0xf3) | 0x10;
-		outb(k, base_io + 0x3a);
-		outb((k & 0xdf), base_io + 0x3a);
+		k = (atp_readb_base(p, 0x3a) & 0xf3) | 0x10;
+		atp_writeb_base(p, 0x3a, k);
+		atp_writeb_base(p, 0x3a, k & 0xdf);
 		mdelay(32);
-		outb(k, base_io + 0x3a);
+		atp_writeb_base(p, 0x3a, k);
 		mdelay(32);
-		outb((host_id | 0x08), base_io + 0);
-		outb(0, base_io + 0x18);
-		while ((inb(base_io + 0x1f) & 0x80) == 0)
+		atp_writeb_io(p, 0, 0, host_id | 0x08);
+		atp_writeb_io(p, 0, 0x18, 0);
+		while ((atp_readb_io(p, 0, 0x1f) & 0x80) == 0)
 			mdelay(1);
 
-		inb(base_io + 0x17);
-		outb(8, base_io + 1);
-		outb(0x7f, base_io + 2);
-		outb(0x20, base_io + 0x11);
+		atp_readb_io(p, 0, 0x17);
+		atp_writeb_io(p, 0, 1, 8);
+		atp_writeb_io(p, 0, 2, 0x7f);
+		atp_writeb_io(p, 0, 0x11, 0x20);
 
 		tscam(shpnt);
-		atp_writeb_io(p, 0, 0x3a, atp_readb_io(p, 0, 0x3a) | 0x10);
+		atp_writeb_base(p, 0x3a, atp_readb_base(p, 0x3a) | 0x10);
 		atp_is(p, 0, p->chip_ver == 4, 0);
-		atp_writeb_io(p, 0, 0x3a, atp_readb_io(p, 0, 0x3a) & 0xef);
-		outb((inb(base_io + 0x3a) & 0xef), base_io + 0x3a);
-		outb((inb(base_io + 0x3b) | 0x20), base_io + 0x3b);
+		atp_writeb_base(p, 0x3a, atp_readb_base(p, 0x3a) & 0xef);
+		atp_writeb_base(p, 0x3b, atp_readb_base(p, 0x3b) | 0x20);
 		if (atpdev->chip_ver == 4)
 			shpnt->max_id = 16;
 		else		

commit 4192a40f49f0ab3028019deaba5cdc3b9db789dd
Author: Ondrej Zary <linux@rainbow-software.org>
Date:   Tue Nov 17 19:24:06 2015 +0100

    atp870u: Rename is885() to atp_is()
    
    Now that all the is* functions except is885() are gone, rename is885() to
    atp_is() to avoid confusion. Don't know what "is" means, though...
    
    Signed-off-by: Ondrej Zary <linux@rainbow-software.org>
    Reviewed-by: Hannes Reinicke <hare@suse.de>
    Acked-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/atp870u.c b/drivers/scsi/atp870u.c
index 918875bc92fe..0b7d3bd85408 100644
--- a/drivers/scsi/atp870u.c
+++ b/drivers/scsi/atp870u.c
@@ -41,7 +41,7 @@
 
 static struct scsi_host_template atp870u_template;
 static void send_s870(struct atp_unit *dev,unsigned char c);
-static void is885(struct atp_unit *dev, unsigned char c, bool wide_chip, unsigned char lvdmode);
+static void atp_is(struct atp_unit *dev, unsigned char c, bool wide_chip, unsigned char lvdmode);
 static void tscam_885(void);
 
 static inline void atp_writeb_base(struct atp_unit *atp, u8 reg, u8 val)
@@ -1373,7 +1373,7 @@ static int atp870u_probe(struct pci_dev *pdev, const struct pci_device_id *ent)
 		outb(0x20, base_io + 0x51);
 
 		tscam(shpnt);
-		is885(p, 0, true, atp_readb_base(p, 0x3f) & 0x40);
+		atp_is(p, 0, true, atp_readb_base(p, 0x3f) & 0x40);
 		outb(0xb0, base_io + 0x38);
 		shpnt->max_id = 16;
 		shpnt->this_id = host_id;
@@ -1519,10 +1519,10 @@ static int atp870u_probe(struct pci_dev *pdev, const struct pci_device_id *ent)
 
 		tscam_885();
 		printk(KERN_INFO "   Scanning Channel A SCSI Device ...\n");
-		is885(p, 0, true, atp_readb_io(p, 0, 0x1b) >> 7);
+		atp_is(p, 0, true, atp_readb_io(p, 0, 0x1b) >> 7);
 		atp_writeb_io(p, 0, 0x16, 0x80);
 		printk(KERN_INFO "   Scanning Channel B SCSI Device ...\n");
-		is885(p, 1, true, atp_readb_io(p, 1, 0x1b) >> 7);
+		atp_is(p, 1, true, atp_readb_io(p, 1, 0x1b) >> 7);
 		atp_writeb_io(p, 1, 0x16, 0x80);
 		k = inb(base_io + 0x28) & 0xcf;
 		k |= 0xc0;
@@ -1605,7 +1605,7 @@ static int atp870u_probe(struct pci_dev *pdev, const struct pci_device_id *ent)
 
 		tscam(shpnt);
 		atp_writeb_io(p, 0, 0x3a, atp_readb_io(p, 0, 0x3a) | 0x10);
-		is885(p, 0, p->chip_ver == 4, 0);
+		atp_is(p, 0, p->chip_ver == 4, 0);
 		atp_writeb_io(p, 0, 0x3a, atp_readb_io(p, 0, 0x3a) & 0xef);
 		outb((inb(base_io + 0x3a) & 0xef), base_io + 0x3a);
 		outb((inb(base_io + 0x3b) | 0x20), base_io + 0x3b);
@@ -1826,7 +1826,7 @@ static void tscam_885(void)
 
 
 
-static void is885(struct atp_unit *dev, unsigned char c, bool wide_chip, unsigned char lvdmode)
+static void atp_is(struct atp_unit *dev, unsigned char c, bool wide_chip, unsigned char lvdmode)
 {
 	unsigned char i, j, k, rmb, n;
 	unsigned short int m;

commit 851eb6618e6a27004e33c0422fdcf05b5b45c025
Author: Ondrej Zary <linux@rainbow-software.org>
Date:   Tue Nov 17 19:24:05 2015 +0100

    atp870u: Remove is870()
    
    Now that is885() supports everything from is870() and the rest of the code
    is almost identical, remove is870() and use is885() instead.
    
    Signed-off-by: Ondrej Zary <linux@rainbow-software.org>
    Reviewed-by: Hannes Reinicke <hare@suse.de>
    Acked-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/atp870u.c b/drivers/scsi/atp870u.c
index 6427f8737b7d..918875bc92fe 100644
--- a/drivers/scsi/atp870u.c
+++ b/drivers/scsi/atp870u.c
@@ -1162,431 +1162,6 @@ static void tscam(struct Scsi_Host *host)
 	}
 }
 
-static void is870(struct atp_unit *dev, unsigned char c, bool wide_chip)
-{
-	unsigned char i, j, k, rmb, n;
-	unsigned short int m;
-	static unsigned char mbuf[512];
-	static unsigned char satn[9] = { 0, 0, 0, 0, 0, 0, 0, 6, 6 };
-	static unsigned char inqd[9] = { 0x12, 0, 0, 0, 0x24, 0, 0, 0x24, 6 };
-	static unsigned char synn[6] = { 0x80, 1, 3, 1, 0x19, 0x0e };
-	static unsigned char synu[6] = { 0x80, 1, 3, 1, 0x0c, 0x0e };
-	static unsigned char synw[6] = { 0x80, 1, 3, 1, 0x0c, 0x07 };
-	static unsigned char wide[6] = { 0x80, 1, 2, 3, 1, 0 };
-
-	for (i = 0; i < 16; i++) {
-		if (!wide_chip && (i > 7))
-			break;
-		m = 1;
-		m = m << i;
-		if ((m & dev->active_id[c]) != 0) {
-			continue;
-		}
-		if (i == dev->host_id[c]) {
-			printk(KERN_INFO "         ID: %2d  Host Adapter\n", dev->host_id[c]);
-			continue;
-		}
-		atp_writeb_io(dev, c, 0x1b, wide_chip ? 0x01 : 0x00);
-		atp_writeb_io(dev, c, 1, 0x08);
-		atp_writeb_io(dev, c, 2, 0x7f);
-		atp_writeb_io(dev, c, 3, satn[0]);
-		atp_writeb_io(dev, c, 4, satn[1]);
-		atp_writeb_io(dev, c, 5, satn[2]);
-		atp_writeb_io(dev, c, 6, satn[3]);
-		atp_writeb_io(dev, c, 7, satn[4]);
-		atp_writeb_io(dev, c, 8, satn[5]);
-		atp_writeb_io(dev, c, 0x0f, 0);
-		atp_writeb_io(dev, c, 0x11, dev->id[c][i].devsp);
-		atp_writeb_io(dev, c, 0x12, 0);
-		atp_writeb_io(dev, c, 0x13, satn[6]);
-		atp_writeb_io(dev, c, 0x14, satn[7]);
-		j = i;
-		if ((j & 0x08) != 0) {
-			j = (j & 0x07) | 0x40;
-		}
-		atp_writeb_io(dev, c, 0x15, j);
-		atp_writeb_io(dev, c, 0x18, satn[8]);
-
-		while ((atp_readb_io(dev, c, 0x1f) & 0x80) == 0x00)
-			cpu_relax();
-
-		if (atp_readb_io(dev, c, 0x17) != 0x11 && atp_readb_io(dev, c, 0x17) != 0x8e)
-			continue;
-
-		while (atp_readb_io(dev, c, 0x17) != 0x8e)
-			cpu_relax();
-
-		dev->active_id[c] |= m;
-
-		atp_writeb_io(dev, c, 0x10, 0x30);
-		atp_writeb_io(dev, c, 0x04, 0x00);
-
-phase_cmd:
-		atp_writeb_io(dev, c, 0x18, 0x08);
-
-		while ((atp_readb_io(dev, c, 0x1f) & 0x80) == 0x00)
-			cpu_relax();
-
-		j = atp_readb_io(dev, c, 0x17);
-		if (j != 0x16) {
-			atp_writeb_io(dev, c, 0x10, 0x41);
-			goto phase_cmd;
-		}
-sel_ok:
-		atp_writeb_io(dev, c, 3, inqd[0]);
-		atp_writeb_io(dev, c, 4, inqd[1]);
-		atp_writeb_io(dev, c, 5, inqd[2]);
-		atp_writeb_io(dev, c, 6, inqd[3]);
-		atp_writeb_io(dev, c, 7, inqd[4]);
-		atp_writeb_io(dev, c, 8, inqd[5]);
-		atp_writeb_io(dev, c, 0x0f, 0);
-		atp_writeb_io(dev, c, 0x11, dev->id[c][i].devsp);
-		atp_writeb_io(dev, c, 0x12, 0);
-		atp_writeb_io(dev, c, 0x13, inqd[6]);
-		atp_writeb_io(dev, c, 0x14, inqd[7]);
-		atp_writeb_io(dev, c, 0x18, inqd[8]);
-
-		while ((atp_readb_io(dev, c, 0x1f) & 0x80) == 0x00)
-			cpu_relax();
-
-		if (atp_readb_io(dev, c, 0x17) != 0x11 && atp_readb_io(dev, c, 0x17) != 0x8e)
-			continue;
-
-		while (atp_readb_io(dev, c, 0x17) != 0x8e)
-			cpu_relax();
-
-		if (wide_chip)
-			atp_writeb_io(dev, c, 0x1b, 0x00);
-
-		atp_writeb_io(dev, c, 0x18, 0x08);
-		j = 0;
-rd_inq_data:
-		k = atp_readb_io(dev, c, 0x1f);
-		if ((k & 0x01) != 0) {
-			mbuf[j++] = atp_readb_io(dev, c, 0x19);
-			goto rd_inq_data;
-		}
-		if ((k & 0x80) == 0) {
-			goto rd_inq_data;
-		}
-		j = atp_readb_io(dev, c, 0x17);
-		if (j == 0x16) {
-			goto inq_ok;
-		}
-		atp_writeb_io(dev, c, 0x10, 0x46);
-		atp_writeb_io(dev, c, 0x12, 0);
-		atp_writeb_io(dev, c, 0x13, 0);
-		atp_writeb_io(dev, c, 0x14, 0);
-		atp_writeb_io(dev, c, 0x18, 0x08);
-
-		while ((atp_readb_io(dev, c, 0x1f) & 0x80) == 0x00)
-			cpu_relax();
-
-		if (atp_readb_io(dev, c, 0x17) != 0x16)
-			goto sel_ok;
-
-inq_ok:
-		mbuf[36] = 0;
-		printk(KERN_INFO "         ID: %2d  %s\n", i, &mbuf[8]);
-		dev->id[c][i].devtype = mbuf[0];
-		rmb = mbuf[1];
-		n = mbuf[7];
-		if (!wide_chip)
-			goto not_wide;
-		if ((mbuf[7] & 0x60) == 0) {
-			goto not_wide;
-		}
-		if ((dev->global_map[c] & 0x20) == 0) {
-			goto not_wide;
-		}
-		atp_writeb_io(dev, c, 0x1b, 0x01);
-		atp_writeb_io(dev, c, 3, satn[0]);
-		atp_writeb_io(dev, c, 4, satn[1]);
-		atp_writeb_io(dev, c, 5, satn[2]);
-		atp_writeb_io(dev, c, 6, satn[3]);
-		atp_writeb_io(dev, c, 7, satn[4]);
-		atp_writeb_io(dev, c, 8, satn[5]);
-		atp_writeb_io(dev, c, 0x0f, 0);
-		atp_writeb_io(dev, c, 0x11, dev->id[c][i].devsp);
-		atp_writeb_io(dev, c, 0x12, 0);
-		atp_writeb_io(dev, c, 0x13, satn[6]);
-		atp_writeb_io(dev, c, 0x14, satn[7]);
-		atp_writeb_io(dev, c, 0x18, satn[8]);
-
-		while ((atp_readb_io(dev, c, 0x1f) & 0x80) == 0x00)
-			cpu_relax();
-
-		if (atp_readb_io(dev, c, 0x17) != 0x11 && atp_readb_io(dev, c, 0x17) != 0x8e)
-			continue;
-
-		while (atp_readb_io(dev, c, 0x17) != 0x8e)
-			cpu_relax();
-
-try_wide:
-		j = 0;
-		atp_writeb_io(dev, c, 0x14, 0x05);
-		atp_writeb_io(dev, c, 0x18, 0x20);
-
-		while ((atp_readb_io(dev, c, 0x1f) & 0x80) == 0) {
-			if ((atp_readb_io(dev, c, 0x1f) & 0x01) != 0)
-				atp_writeb_io(dev, c, 0x19, wide[j++]);
-		}
-
-		while ((atp_readb_io(dev, c, 0x17) & 0x80) == 0x00)
-			cpu_relax();
-
-		j = atp_readb_io(dev, c, 0x17) & 0x0f;
-		if (j == 0x0f) {
-			goto widep_in;
-		}
-		if (j == 0x0a) {
-			goto widep_cmd;
-		}
-		if (j == 0x0e) {
-			goto try_wide;
-		}
-		continue;
-widep_out:
-		atp_writeb_io(dev, c, 0x18, 0x20);
-		while ((atp_readb_io(dev, c, 0x1f) & 0x80) == 0) {
-			if ((atp_readb_io(dev, c, 0x1f) & 0x01) != 0)
-				atp_writeb_io(dev, c, 0x19, 0);
-		}
-		j = atp_readb_io(dev, c, 0x17) & 0x0f;
-		if (j == 0x0f) {
-			goto widep_in;
-		}
-		if (j == 0x0a) {
-			goto widep_cmd;
-		}
-		if (j == 0x0e) {
-			goto widep_out;
-		}
-		continue;
-widep_in:
-		atp_writeb_io(dev, c, 0x14, 0xff);
-		atp_writeb_io(dev, c, 0x18, 0x20);
-		k = 0;
-widep_in1:
-		j = atp_readb_io(dev, c, 0x1f);
-		if ((j & 0x01) != 0) {
-			mbuf[k++] = atp_readb_io(dev, c, 0x19);
-			goto widep_in1;
-		}
-		if ((j & 0x80) == 0x00) {
-			goto widep_in1;
-		}
-		j = atp_readb_io(dev, c, 0x17) & 0x0f;
-		if (j == 0x0f) {
-			goto widep_in;
-		}
-		if (j == 0x0a) {
-			goto widep_cmd;
-		}
-		if (j == 0x0e) {
-			goto widep_out;
-		}
-		continue;
-widep_cmd:
-		atp_writeb_io(dev, c, 0x10, 0x30);
-		atp_writeb_io(dev, c, 0x14, 0x00);
-		atp_writeb_io(dev, c, 0x18, 0x08);
-
-		while ((atp_readb_io(dev, c, 0x1f) & 0x80) == 0x00)
-			cpu_relax();
-
-		j = atp_readb_io(dev, c, 0x17);
-		if (j != 0x16) {
-			if (j == 0x4e) {
-				goto widep_out;
-			}
-			continue;
-		}
-		if (mbuf[0] != 0x01) {
-			goto not_wide;
-		}
-		if (mbuf[1] != 0x02) {
-			goto not_wide;
-		}
-		if (mbuf[2] != 0x03) {
-			goto not_wide;
-		}
-		if (mbuf[3] != 0x01) {
-			goto not_wide;
-		}
-		m = 1;
-		m = m << i;
-		dev->wide_id[c] |= m;
-not_wide:
-		if ((dev->id[c][i].devtype == 0x00) || (dev->id[c][i].devtype == 0x07) || ((dev->id[c][i].devtype == 0x05) && ((n & 0x10) != 0))) {
-			goto set_sync;
-		}
-		continue;
-set_sync:
-		j = 0;
-		if ((m & dev->wide_id[c]) != 0) {
-			j |= 0x01;
-		}
-		atp_writeb_io(dev, c, 0x1b, j);
-		atp_writeb_io(dev, c, 3, satn[0]);
-		atp_writeb_io(dev, c, 4, satn[1]);
-		atp_writeb_io(dev, c, 5, satn[2]);
-		atp_writeb_io(dev, c, 6, satn[3]);
-		atp_writeb_io(dev, c, 7, satn[4]);
-		atp_writeb_io(dev, c, 8, satn[5]);
-		atp_writeb_io(dev, c, 0x0f, 0);
-		atp_writeb_io(dev, c, 0x11, dev->id[c][i].devsp);
-		atp_writeb_io(dev, c, 0x12, 0);
-		atp_writeb_io(dev, c, 0x13, satn[6]);
-		atp_writeb_io(dev, c, 0x14, satn[7]);
-		atp_writeb_io(dev, c, 0x18, satn[8]);
-
-		while ((atp_readb_io(dev, c, 0x1f) & 0x80) == 0x00)
-			cpu_relax();
-
-		if (atp_readb_io(dev, c, 0x17) != 0x11 && atp_readb_io(dev, c, 0x17) != 0x8e)
-			continue;
-
-		while (atp_readb_io(dev, c, 0x17) != 0x8e)
-			cpu_relax();
-
-try_sync:
-		j = 0;
-		atp_writeb_io(dev, c, 0x14, 0x06);
-		atp_writeb_io(dev, c, 0x18, 0x20);
-
-		while ((atp_readb_io(dev, c, 0x1f) & 0x80) == 0) {
-			if ((atp_readb_io(dev, c, 0x1f) & 0x01) != 0) {
-				if ((m & dev->wide_id[c]) != 0) {
-					atp_writeb_io(dev, c, 0x19, synw[j++]);
-				} else {
-					if ((m & dev->ultra_map[c]) != 0) {
-						atp_writeb_io(dev, c, 0x19, synu[j++]);
-					} else {
-						atp_writeb_io(dev, c, 0x19, synn[j++]);
-					}
-				}
-			}
-		}
-
-		while ((atp_readb_io(dev, c, 0x17) & 0x80) == 0x00)
-			cpu_relax();
-
-		j = atp_readb_io(dev, c, 0x17) & 0x0f;
-		if (j == 0x0f) {
-			goto phase_ins;
-		}
-		if (j == 0x0a) {
-			goto phase_cmds;
-		}
-		if (j == 0x0e) {
-			goto try_sync;
-		}
-		continue;
-phase_outs:
-		atp_writeb_io(dev, c, 0x18, 0x20);
-		while ((atp_readb_io(dev, c, 0x1f) & 0x80) == 0x00) {
-			if ((atp_readb_io(dev, c, 0x1f) & 0x01) != 0x00)
-				atp_writeb_io(dev, c, 0x19, 0x00);
-		}
-		j = atp_readb_io(dev, c, 0x17);
-		if (j == 0x85) {
-			goto tar_dcons;
-		}
-		j &= 0x0f;
-		if (j == 0x0f) {
-			goto phase_ins;
-		}
-		if (j == 0x0a) {
-			goto phase_cmds;
-		}
-		if (j == 0x0e) {
-			goto phase_outs;
-		}
-		continue;
-phase_ins:
-		atp_writeb_io(dev, c, 0x14, 0xff);
-		atp_writeb_io(dev, c, 0x18, 0x20);
-		k = 0;
-phase_ins1:
-		j = atp_readb_io(dev, c, 0x1f);
-		if ((j & 0x01) != 0x00) {
-			mbuf[k++] = atp_readb_io(dev, c, 0x19);
-			goto phase_ins1;
-		}
-		if ((j & 0x80) == 0x00) {
-			goto phase_ins1;
-		}
-
-		while ((atp_readb_io(dev, c, 0x17) & 0x80) == 0x00)
-			cpu_relax();
-
-		j = atp_readb_io(dev, c, 0x17);
-		if (j == 0x85) {
-			goto tar_dcons;
-		}
-		j &= 0x0f;
-		if (j == 0x0f) {
-			goto phase_ins;
-		}
-		if (j == 0x0a) {
-			goto phase_cmds;
-		}
-		if (j == 0x0e) {
-			goto phase_outs;
-		}
-		continue;
-phase_cmds:
-		atp_writeb_io(dev, c, 0x10, 0x30);
-tar_dcons:
-		atp_writeb_io(dev, c, 0x14, 0x00);
-		atp_writeb_io(dev, c, 0x18, 0x08);
-
-		while ((atp_readb_io(dev, c, 0x1f) & 0x80) == 0x00)
-			cpu_relax();
-
-		j = atp_readb_io(dev, c, 0x17);
-		if (j != 0x16) {
-			continue;
-		}
-		if (mbuf[0] != 0x01) {
-			continue;
-		}
-		if (mbuf[1] != 0x03) {
-			continue;
-		}
-		if (mbuf[4] == 0x00) {
-			continue;
-		}
-		if (mbuf[3] > 0x64) {
-			continue;
-		}
-		if (mbuf[4] > 0x0c) {
-			mbuf[4] = 0x0c;
-		}
-		dev->id[c][i].devsp = mbuf[4];
-		if ((mbuf[3] < 0x0d) && (rmb == 0)) {
-			j = 0xa0;
-			goto set_syn_ok;
-		}
-		if (mbuf[3] < 0x1a) {
-			j = 0x20;
-			goto set_syn_ok;
-		}
-		if (mbuf[3] < 0x33) {
-			j = 0x40;
-			goto set_syn_ok;
-		}
-		if (mbuf[3] < 0x4c) {
-			j = 0x50;
-			goto set_syn_ok;
-		}
-		j = 0x60;
-set_syn_ok:
-		dev->id[c][i].devsp = (dev->id[c][i].devsp & 0x0f) | j;
-	}
-}
-
 static void atp870u_free_tables(struct Scsi_Host *host)
 {
 	struct atp_unit *atp_dev = (struct atp_unit *)&host->hostdata;
@@ -2030,7 +1605,7 @@ static int atp870u_probe(struct pci_dev *pdev, const struct pci_device_id *ent)
 
 		tscam(shpnt);
 		atp_writeb_io(p, 0, 0x3a, atp_readb_io(p, 0, 0x3a) | 0x10);
-		is870(p, 0, p->chip_ver == 4);
+		is885(p, 0, p->chip_ver == 4, 0);
 		atp_writeb_io(p, 0, 0x3a, atp_readb_io(p, 0, 0x3a) & 0xef);
 		outb((inb(base_io + 0x3a) & 0xef), base_io + 0x3a);
 		outb((inb(base_io + 0x3b) | 0x20), base_io + 0x3b);

commit 95c1def50dd6b1de4ceb0d6950e37e74c301d9d2
Author: Ondrej Zary <linux@rainbow-software.org>
Date:   Tue Nov 17 19:24:04 2015 +0100

    atp870u: Move 870-specific code out of is870()
    
    Move few remaining 870-specific code lines out of is870()
    
    Signed-off-by: Ondrej Zary <linux@rainbow-software.org>
    Reviewed-by: Hannes Reinicke <hare@suse.de>
    Acked-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/atp870u.c b/drivers/scsi/atp870u.c
index d76d3869a06d..6427f8737b7d 100644
--- a/drivers/scsi/atp870u.c
+++ b/drivers/scsi/atp870u.c
@@ -1174,8 +1174,6 @@ static void is870(struct atp_unit *dev, unsigned char c, bool wide_chip)
 	static unsigned char synw[6] = { 0x80, 1, 3, 1, 0x0c, 0x07 };
 	static unsigned char wide[6] = { 0x80, 1, 2, 3, 1, 0 };
 
-	atp_writeb_io(dev, c, 0x3a, atp_readb_io(dev, c, 0x3a) | 0x10);
-
 	for (i = 0; i < 16; i++) {
 		if (!wide_chip && (i > 7))
 			break;
@@ -1587,7 +1585,6 @@ static void is870(struct atp_unit *dev, unsigned char c, bool wide_chip)
 set_syn_ok:
 		dev->id[c][i].devsp = (dev->id[c][i].devsp & 0x0f) | j;
 	}
-	atp_writeb_io(dev, c, 0x3a, atp_readb_io(dev, c, 0x3a) & 0xef);
 }
 
 static void atp870u_free_tables(struct Scsi_Host *host)
@@ -2032,7 +2029,9 @@ static int atp870u_probe(struct pci_dev *pdev, const struct pci_device_id *ent)
 		outb(0x20, base_io + 0x11);
 
 		tscam(shpnt);
+		atp_writeb_io(p, 0, 0x3a, atp_readb_io(p, 0, 0x3a) | 0x10);
 		is870(p, 0, p->chip_ver == 4);
+		atp_writeb_io(p, 0, 0x3a, atp_readb_io(p, 0, 0x3a) & 0xef);
 		outb((inb(base_io + 0x3a) & 0xef), base_io + 0x3a);
 		outb((inb(base_io + 0x3b) | 0x20), base_io + 0x3b);
 		if (atpdev->chip_ver == 4)

commit 460da918d46b075dcc9fdcf77281f8ebde169bd4
Author: Ondrej Zary <linux@rainbow-software.org>
Date:   Tue Nov 17 19:24:03 2015 +0100

    atp870u: Add remaining 870 support to is885()
    
    Add remaining 870 support to is885():
     - different synw, no synuw
     - synu[4] = 0x0c
     - atp_writeb_io(dev, c, 0x04, 0x00); instead of
       atp_writeb_io(dev, c, 0x14, 0x00); (isn't that a bug?)
     - atp_writeb_io(dev, c, 0x14, 0xff); instead of
       atp_writeb_io(dev, c, 0x14, 0x06);
     - different mbuf[3] and mbuf[4] checks
    
    Signed-off-by: Ondrej Zary <linux@rainbow-software.org>
    Reviewed-by: Hannes Reinicke <hare@suse.de>
    Acked-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/atp870u.c b/drivers/scsi/atp870u.c
index 0548d0750986..d76d3869a06d 100644
--- a/drivers/scsi/atp870u.c
+++ b/drivers/scsi/atp870u.c
@@ -2262,6 +2262,7 @@ static void is885(struct atp_unit *dev, unsigned char c, bool wide_chip, unsigne
 	static unsigned char synn[6] = { 0x80, 1, 3, 1, 0x19, 0x0e };
 	unsigned char synu[6] = { 0x80, 1, 3, 1, 0x0a, 0x0e };
 	static unsigned char synw[6] = { 0x80, 1, 3, 1, 0x19, 0x0e };
+	static unsigned char synw_870[6] = { 0x80, 1, 3, 1, 0x0c, 0x07 };
 	unsigned char synuw[6] = { 0x80, 1, 3, 1, 0x0a, 0x0e };
 	static unsigned char wide[6] = { 0x80, 1, 2, 3, 1, 0 };
 	static unsigned char u3[9] = { 0x80, 1, 6, 4, 0x09, 00, 0x0e, 0x01, 0x02 };
@@ -2311,7 +2312,10 @@ static void is885(struct atp_unit *dev, unsigned char c, bool wide_chip, unsigne
 		dev->active_id[c] |= m;
 
 		atp_writeb_io(dev, c, 0x10, 0x30);
-		atp_writeb_io(dev, c, 0x14, 0x00);
+		if (dev->dev_id == ATP885_DEVID || dev->dev_id == ATP880_DEVID1 || dev->dev_id == ATP880_DEVID2)
+			atp_writeb_io(dev, c, 0x14, 0x00);
+		else /* result of is870() merge - is this a bug? */
+			atp_writeb_io(dev, c, 0x04, 0x00);
 
 phase_cmd:
 		atp_writeb_io(dev, c, 0x18, 0x08);
@@ -2657,7 +2661,7 @@ static void is885(struct atp_unit *dev, unsigned char c, bool wide_chip, unsigne
 		}
 		continue;
 set_sync:
-		if (dev->sp[c][i] == 0x02) {
+		if ((dev->dev_id != ATP885_DEVID && dev->dev_id != ATP880_DEVID1 && dev->dev_id != ATP880_DEVID2) || (dev->sp[c][i] == 0x02)) {
 			synu[4] = 0x0c;
 			synuw[4] = 0x0c;
 		} else {
@@ -2701,11 +2705,14 @@ static void is885(struct atp_unit *dev, unsigned char c, bool wide_chip, unsigne
 		while ((atp_readb_io(dev, c, 0x1f) & 0x80) == 0) {
 			if ((atp_readb_io(dev, c, 0x1f) & 0x01) != 0) {
 				if ((m & dev->wide_id[c]) != 0) {
-					if ((m & dev->ultra_map[c]) != 0) {
-						atp_writeb_io(dev, c, 0x19, synuw[j++]);
-					} else {
-						atp_writeb_io(dev, c, 0x19, synw[j++]);
-					}
+					if (dev->dev_id == ATP885_DEVID || dev->dev_id == ATP880_DEVID1 || dev->dev_id == ATP880_DEVID2) {
+						if ((m & dev->ultra_map[c]) != 0) {
+							atp_writeb_io(dev, c, 0x19, synuw[j++]);
+						} else {
+							atp_writeb_io(dev, c, 0x19, synw[j++]);
+						}
+					} else
+						atp_writeb_io(dev, c, 0x19, synw_870[j++]);
 				} else {
 					if ((m & dev->ultra_map[c]) != 0) {
 						atp_writeb_io(dev, c, 0x19, synu[j++]);
@@ -2753,7 +2760,10 @@ static void is885(struct atp_unit *dev, unsigned char c, bool wide_chip, unsigne
 		}
 		continue;
 phase_ins:
-		atp_writeb_io(dev, c, 0x14, 0x06);
+		if (dev->dev_id == ATP885_DEVID || dev->dev_id == ATP880_DEVID1 || dev->dev_id == ATP880_DEVID2)
+			atp_writeb_io(dev, c, 0x14, 0x06);
+		else
+			atp_writeb_io(dev, c, 0x14, 0xff);
 		atp_writeb_io(dev, c, 0x18, 0x20);
 		k = 0;
 phase_ins1:
@@ -2808,14 +2818,21 @@ static void is885(struct atp_unit *dev, unsigned char c, bool wide_chip, unsigne
 		if (mbuf[3] > 0x64) {
 			continue;
 		}
-		if (mbuf[4] > 0x0e) {
-			mbuf[4] = 0x0e;
+		if (dev->dev_id == ATP885_DEVID || dev->dev_id == ATP880_DEVID1 || dev->dev_id == ATP880_DEVID2) {
+			if (mbuf[4] > 0x0e) {
+				mbuf[4] = 0x0e;
+			}
+		} else {
+			if (mbuf[4] > 0x0c) {
+				mbuf[4] = 0x0c;
+			}
 		}
 		dev->id[c][i].devsp = mbuf[4];
-		if (mbuf[3] < 0x0c) {
-			j = 0xb0;
-			goto set_syn_ok;
-		}
+		if (dev->dev_id == ATP885_DEVID || dev->dev_id == ATP880_DEVID1 || dev->dev_id == ATP880_DEVID2)
+			if (mbuf[3] < 0x0c) {
+				j = 0xb0;
+				goto set_syn_ok;
+			}
 		if ((mbuf[3] < 0x0d) && (rmb == 0)) {
 			j = 0xa0;
 			goto set_syn_ok;

commit 197fb8d85707d07eab68ac17d20e95c7104f1d5e
Author: Ondrej Zary <linux@rainbow-software.org>
Date:   Tue Nov 17 19:24:02 2015 +0100

    atp870u: Add wide_chip parameter to is870() and is885()
    
    Don't check chip_ver in is870() but add wide_chip parameter for that.
    Then add the non-wide support to is885().
    
    Signed-off-by: Ondrej Zary <linux@rainbow-software.org>
    Reviewed-by: Hannes Reinicke <hare@suse.de>
    Acked-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/atp870u.c b/drivers/scsi/atp870u.c
index d10026a734d7..0548d0750986 100644
--- a/drivers/scsi/atp870u.c
+++ b/drivers/scsi/atp870u.c
@@ -41,7 +41,7 @@
 
 static struct scsi_host_template atp870u_template;
 static void send_s870(struct atp_unit *dev,unsigned char c);
-static void is885(struct atp_unit *dev, unsigned char c, unsigned char lvdmode);
+static void is885(struct atp_unit *dev, unsigned char c, bool wide_chip, unsigned char lvdmode);
 static void tscam_885(void);
 
 static inline void atp_writeb_base(struct atp_unit *atp, u8 reg, u8 val)
@@ -1162,7 +1162,7 @@ static void tscam(struct Scsi_Host *host)
 	}
 }
 
-static void is870(struct atp_unit *dev, unsigned char c)
+static void is870(struct atp_unit *dev, unsigned char c, bool wide_chip)
 {
 	unsigned char i, j, k, rmb, n;
 	unsigned short int m;
@@ -1177,9 +1177,8 @@ static void is870(struct atp_unit *dev, unsigned char c)
 	atp_writeb_io(dev, c, 0x3a, atp_readb_io(dev, c, 0x3a) | 0x10);
 
 	for (i = 0; i < 16; i++) {
-		if ((dev->chip_ver != 4) && (i > 7)) {
+		if (!wide_chip && (i > 7))
 			break;
-		}
 		m = 1;
 		m = m << i;
 		if ((m & dev->active_id[c]) != 0) {
@@ -1189,11 +1188,7 @@ static void is870(struct atp_unit *dev, unsigned char c)
 			printk(KERN_INFO "         ID: %2d  Host Adapter\n", dev->host_id[c]);
 			continue;
 		}
-		if (dev->chip_ver == 4) {
-			atp_writeb_io(dev, c, 0x1b, 0x01);
-		} else {
-			atp_writeb_io(dev, c, 0x1b, 0x00);
-		}
+		atp_writeb_io(dev, c, 0x1b, wide_chip ? 0x01 : 0x00);
 		atp_writeb_io(dev, c, 1, 0x08);
 		atp_writeb_io(dev, c, 2, 0x7f);
 		atp_writeb_io(dev, c, 3, satn[0]);
@@ -1262,7 +1257,7 @@ static void is870(struct atp_unit *dev, unsigned char c)
 		while (atp_readb_io(dev, c, 0x17) != 0x8e)
 			cpu_relax();
 
-		if (dev->chip_ver == 4)
+		if (wide_chip)
 			atp_writeb_io(dev, c, 0x1b, 0x00);
 
 		atp_writeb_io(dev, c, 0x18, 0x08);
@@ -1298,9 +1293,8 @@ static void is870(struct atp_unit *dev, unsigned char c)
 		dev->id[c][i].devtype = mbuf[0];
 		rmb = mbuf[1];
 		n = mbuf[7];
-		if (dev->chip_ver != 4) {
+		if (!wide_chip)
 			goto not_wide;
-		}
 		if ((mbuf[7] & 0x60) == 0) {
 			goto not_wide;
 		}
@@ -1807,7 +1801,7 @@ static int atp870u_probe(struct pci_dev *pdev, const struct pci_device_id *ent)
 		outb(0x20, base_io + 0x51);
 
 		tscam(shpnt);
-		is885(p, 0, atp_readb_base(p, 0x3f) & 0x40);
+		is885(p, 0, true, atp_readb_base(p, 0x3f) & 0x40);
 		outb(0xb0, base_io + 0x38);
 		shpnt->max_id = 16;
 		shpnt->this_id = host_id;
@@ -1953,10 +1947,10 @@ static int atp870u_probe(struct pci_dev *pdev, const struct pci_device_id *ent)
 
 		tscam_885();
 		printk(KERN_INFO "   Scanning Channel A SCSI Device ...\n");
-		is885(p, 0, atp_readb_io(p, 0, 0x1b) >> 7);
+		is885(p, 0, true, atp_readb_io(p, 0, 0x1b) >> 7);
 		atp_writeb_io(p, 0, 0x16, 0x80);
 		printk(KERN_INFO "   Scanning Channel B SCSI Device ...\n");
-		is885(p, 1, atp_readb_io(p, 1, 0x1b) >> 7);
+		is885(p, 1, true, atp_readb_io(p, 1, 0x1b) >> 7);
 		atp_writeb_io(p, 1, 0x16, 0x80);
 		k = inb(base_io + 0x28) & 0xcf;
 		k |= 0xc0;
@@ -2038,7 +2032,7 @@ static int atp870u_probe(struct pci_dev *pdev, const struct pci_device_id *ent)
 		outb(0x20, base_io + 0x11);
 
 		tscam(shpnt);
-		is870(p, 0);
+		is870(p, 0, p->chip_ver == 4);
 		outb((inb(base_io + 0x3a) & 0xef), base_io + 0x3a);
 		outb((inb(base_io + 0x3b) | 0x20), base_io + 0x3b);
 		if (atpdev->chip_ver == 4)
@@ -2258,7 +2252,7 @@ static void tscam_885(void)
 
 
 
-static void is885(struct atp_unit *dev, unsigned char c, unsigned char lvdmode)
+static void is885(struct atp_unit *dev, unsigned char c, bool wide_chip, unsigned char lvdmode)
 {
 	unsigned char i, j, k, rmb, n;
 	unsigned short int m;
@@ -2273,6 +2267,8 @@ static void is885(struct atp_unit *dev, unsigned char c, unsigned char lvdmode)
 	static unsigned char u3[9] = { 0x80, 1, 6, 4, 0x09, 00, 0x0e, 0x01, 0x02 };
 
 	for (i = 0; i < 16; i++) {
+		if (!wide_chip && (i > 7))
+			break;
 		m = 1;
 		m = m << i;
 		if ((m & dev->active_id[c]) != 0) {
@@ -2282,7 +2278,7 @@ static void is885(struct atp_unit *dev, unsigned char c, unsigned char lvdmode)
 			printk(KERN_INFO "         ID: %2d  Host Adapter\n", dev->host_id[c]);
 			continue;
 		}
-		atp_writeb_io(dev, c, 0x1b, 0x01);
+		atp_writeb_io(dev, c, 0x1b, wide_chip ? 0x01 : 0x00);
 		atp_writeb_io(dev, c, 1, 0x08);
 		atp_writeb_io(dev, c, 2, 0x7f);
 		atp_writeb_io(dev, c, 3, satn[0]);
@@ -2351,7 +2347,9 @@ static void is885(struct atp_unit *dev, unsigned char c, unsigned char lvdmode)
 		while (atp_readb_io(dev, c, 0x17) != 0x8e)
 			cpu_relax();
 
-		atp_writeb_io(dev, c, 0x1b, 0x00);
+		if (wide_chip)
+			atp_writeb_io(dev, c, 0x1b, 0x00);
+
 		atp_writeb_io(dev, c, 0x18, 0x08);
 		j = 0;
 rd_inq_data:
@@ -2385,11 +2383,17 @@ static void is885(struct atp_unit *dev, unsigned char c, unsigned char lvdmode)
 		dev->id[c][i].devtype = mbuf[0];
 		rmb = mbuf[1];
 		n = mbuf[7];
+		if (!wide_chip)
+			goto not_wide;
 		if ((mbuf[7] & 0x60) == 0) {
 			goto not_wide;
 		}
-		if ((i < 8) && ((dev->global_map[c] & 0x20) == 0)) {
-			goto not_wide;
+		if (dev->dev_id == ATP885_DEVID || dev->dev_id == ATP880_DEVID1 || dev->dev_id == ATP880_DEVID2) {
+			if ((i < 8) && ((dev->global_map[c] & 0x20) == 0))
+				goto not_wide;
+		} else { /* result of is870() merge - is this a bug? */
+			if ((dev->global_map[c] & 0x20) == 0)
+				goto not_wide;
 		}
 		if (lvdmode == 0) {
 			goto chg_wide;

commit e7d6d140328cb8c92ad749ab8a614c9299269975
Author: Ondrej Zary <linux@rainbow-software.org>
Date:   Tue Nov 17 19:24:01 2015 +0100

    atp870u: Remove is880()
    
    Now that is880() and is885() are almost identical (except for some cpu_relax()
    calls and debug printks), remove is880() and use is885() instead.
    
    Signed-off-by: Ondrej Zary <linux@rainbow-software.org>
    Reviewed-by: Hannes Reinicke <hare@suse.de>
    Acked-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/atp870u.c b/drivers/scsi/atp870u.c
index 1c4b1f9f62b9..d10026a734d7 100644
--- a/drivers/scsi/atp870u.c
+++ b/drivers/scsi/atp870u.c
@@ -1596,576 +1596,6 @@ static void is870(struct atp_unit *dev, unsigned char c)
 	atp_writeb_io(dev, c, 0x3a, atp_readb_io(dev, c, 0x3a) & 0xef);
 }
 
-static void is880(struct atp_unit *dev, unsigned char c, unsigned char lvdmode)
-{
-	unsigned char i, j, k, rmb, n;
-	unsigned short int m;
-	static unsigned char mbuf[512];
-	static unsigned char satn[9] = { 0, 0, 0, 0, 0, 0, 0, 6, 6 };
-	static unsigned char inqd[9] = { 0x12, 0, 0, 0, 0x24, 0, 0, 0x24, 6 };
-	static unsigned char synn[6] = { 0x80, 1, 3, 1, 0x19, 0x0e };
-	unsigned char synu[6] = { 0x80, 1, 3, 1, 0x0a, 0x0e };
-	static unsigned char synw[6] = { 0x80, 1, 3, 1, 0x19, 0x0e };
-	unsigned char synuw[6] = { 0x80, 1, 3, 1, 0x0a, 0x0e };
-	static unsigned char wide[6] = { 0x80, 1, 2, 3, 1, 0 };
-	static unsigned char u3[9] = { 0x80, 1, 6, 4, 0x09, 00, 0x0e, 0x01, 0x02 };
-
-	for (i = 0; i < 16; i++) {
-		m = 1;
-		m = m << i;
-		if ((m & dev->active_id[c]) != 0) {
-			continue;
-		}
-		if (i == dev->host_id[c]) {
-			printk(KERN_INFO "         ID: %2d  Host Adapter\n", dev->host_id[c]);
-			continue;
-		}
-		atp_writeb_io(dev, c, 0x1b, 0x01);
-		atp_writeb_io(dev, c, 1, 0x08);
-		atp_writeb_io(dev, c, 2, 0x7f);
-		atp_writeb_io(dev, c, 3, satn[0]);
-		atp_writeb_io(dev, c, 4, satn[1]);
-		atp_writeb_io(dev, c, 5, satn[2]);
-		atp_writeb_io(dev, c, 6, satn[3]);
-		atp_writeb_io(dev, c, 7, satn[4]);
-		atp_writeb_io(dev, c, 8, satn[5]);
-		atp_writeb_io(dev, c, 0x0f, 0);
-		atp_writeb_io(dev, c, 0x11, dev->id[c][i].devsp);
-		atp_writeb_io(dev, c, 0x12, 0);
-		atp_writeb_io(dev, c, 0x13, satn[6]);
-		atp_writeb_io(dev, c, 0x14, satn[7]);
-		j = i;
-		if ((j & 0x08) != 0) {
-			j = (j & 0x07) | 0x40;
-		}
-		atp_writeb_io(dev, c, 0x15, j);
-		atp_writeb_io(dev, c, 0x18, satn[8]);
-
-		while ((atp_readb_io(dev, c, 0x1f) & 0x80) == 0x00)
-			cpu_relax();
-
-		if (atp_readb_io(dev, c, 0x17) != 0x11 && atp_readb_io(dev, c, 0x17) != 0x8e)
-			continue;
-
-		while (atp_readb_io(dev, c, 0x17) != 0x8e)
-			cpu_relax();
-
-		dev->active_id[c] |= m;
-
-		atp_writeb_io(dev, c, 0x10, 0x30);
-		atp_writeb_io(dev, c, 0x14, 0x00);
-
-phase_cmd:
-		atp_writeb_io(dev, c, 0x18, 0x08);
-
-		while ((atp_readb_io(dev, c, 0x1f) & 0x80) == 0x00)
-			cpu_relax();
-
-		j = atp_readb_io(dev, c, 0x17);
-		if (j != 0x16) {
-			atp_writeb_io(dev, c, 0x10, 0x41);
-			goto phase_cmd;
-		}
-sel_ok:
-		atp_writeb_io(dev, c, 3, inqd[0]);
-		atp_writeb_io(dev, c, 4, inqd[1]);
-		atp_writeb_io(dev, c, 5, inqd[2]);
-		atp_writeb_io(dev, c, 6, inqd[3]);
-		atp_writeb_io(dev, c, 7, inqd[4]);
-		atp_writeb_io(dev, c, 8, inqd[5]);
-		atp_writeb_io(dev, c, 0x0f, 0);
-		atp_writeb_io(dev, c, 0x11, dev->id[c][i].devsp);
-		atp_writeb_io(dev, c, 0x12, 0);
-		atp_writeb_io(dev, c, 0x13, inqd[6]);
-		atp_writeb_io(dev, c, 0x14, inqd[7]);
-		atp_writeb_io(dev, c, 0x18, inqd[8]);
-
-		while ((atp_readb_io(dev, c, 0x1f) & 0x80) == 0x00)
-			cpu_relax();
-
-		if (atp_readb_io(dev, c, 0x17) != 0x11 && atp_readb_io(dev, c, 0x17) != 0x8e)
-			continue;
-
-		while (atp_readb_io(dev, c, 0x17) != 0x8e)
-			cpu_relax();
-
-		atp_writeb_io(dev, c, 0x1b, 0x00);
-		atp_writeb_io(dev, c, 0x18, 0x08);
-		j = 0;
-rd_inq_data:
-		k = atp_readb_io(dev, c, 0x1f);
-		if ((k & 0x01) != 0) {
-			mbuf[j++] = atp_readb_io(dev, c, 0x19);
-			goto rd_inq_data;
-		}
-		if ((k & 0x80) == 0) {
-			goto rd_inq_data;
-		}
-		j = atp_readb_io(dev, c, 0x17);
-		if (j == 0x16) {
-			goto inq_ok;
-		}
-		atp_writeb_io(dev, c, 0x10, 0x46);
-		atp_writeb_io(dev, c, 0x12, 0);
-		atp_writeb_io(dev, c, 0x13, 0);
-		atp_writeb_io(dev, c, 0x14, 0);
-		atp_writeb_io(dev, c, 0x18, 0x08);
-
-		while ((atp_readb_io(dev, c, 0x1f) & 0x80) == 0x00)
-			cpu_relax();
-
-		if (atp_readb_io(dev, c, 0x17) != 0x16)
-			goto sel_ok;
-
-inq_ok:
-		mbuf[36] = 0;
-		printk(KERN_INFO "         ID: %2d  %s\n", i, &mbuf[8]);
-		dev->id[c][i].devtype = mbuf[0];
-		rmb = mbuf[1];
-		n = mbuf[7];
-		if ((mbuf[7] & 0x60) == 0) {
-			goto not_wide;
-		}
-		if ((i < 8) && ((dev->global_map[c] & 0x20) == 0)) {
-			goto not_wide;
-		}
-		if (lvdmode == 0) {
-			goto chg_wide;
-		}
-		if (dev->sp[c][i] != 0x04)	// force u2
-		{
-			goto chg_wide;
-		}
-
-		atp_writeb_io(dev, c, 0x1b, 0x01);
-		atp_writeb_io(dev, c, 3, satn[0]);
-		atp_writeb_io(dev, c, 4, satn[1]);
-		atp_writeb_io(dev, c, 5, satn[2]);
-		atp_writeb_io(dev, c, 6, satn[3]);
-		atp_writeb_io(dev, c, 7, satn[4]);
-		atp_writeb_io(dev, c, 8, satn[5]);
-		atp_writeb_io(dev, c, 0x0f, 0);
-		atp_writeb_io(dev, c, 0x11, dev->id[c][i].devsp);
-		atp_writeb_io(dev, c, 0x12, 0);
-		atp_writeb_io(dev, c, 0x13, satn[6]);
-		atp_writeb_io(dev, c, 0x14, satn[7]);
-		atp_writeb_io(dev, c, 0x18, satn[8]);
-
-		while ((atp_readb_io(dev, c, 0x1f) & 0x80) == 0x00)
-			cpu_relax();
-
-		if (atp_readb_io(dev, c, 0x17) != 0x11 && atp_readb_io(dev, c, 0x17) != 0x8e)
-			continue;
-
-		while (atp_readb_io(dev, c, 0x17) != 0x8e)
-			cpu_relax();
-
-try_u3:
-		j = 0;
-		atp_writeb_io(dev, c, 0x14, 0x09);
-		atp_writeb_io(dev, c, 0x18, 0x20);
-
-		while ((atp_readb_io(dev, c, 0x1f) & 0x80) == 0) {
-			if ((atp_readb_io(dev, c, 0x1f) & 0x01) != 0)
-				atp_writeb_io(dev, c, 0x19, u3[j++]);
-		}
-
-		while ((atp_readb_io(dev, c, 0x17) & 0x80) == 0x00)
-			cpu_relax();
-
-		j = atp_readb_io(dev, c, 0x17) & 0x0f;
-		if (j == 0x0f) {
-			goto u3p_in;
-		}
-		if (j == 0x0a) {
-			goto u3p_cmd;
-		}
-		if (j == 0x0e) {
-			goto try_u3;
-		}
-		continue;
-u3p_out:
-		atp_writeb_io(dev, c, 0x18, 0x20);
-		while ((atp_readb_io(dev, c, 0x1f) & 0x80) == 0) {
-			if ((atp_readb_io(dev, c, 0x1f) & 0x01) != 0)
-				atp_writeb_io(dev, c, 0x19, 0);
-		}
-		j = atp_readb_io(dev, c, 0x17) & 0x0f;
-		if (j == 0x0f) {
-			goto u3p_in;
-		}
-		if (j == 0x0a) {
-			goto u3p_cmd;
-		}
-		if (j == 0x0e) {
-			goto u3p_out;
-		}
-		continue;
-u3p_in:
-		atp_writeb_io(dev, c, 0x14, 0x09);
-		atp_writeb_io(dev, c, 0x18, 0x20);
-		k = 0;
-u3p_in1:
-		j = atp_readb_io(dev, c, 0x1f);
-		if ((j & 0x01) != 0) {
-			mbuf[k++] = atp_readb_io(dev, c, 0x19);
-			goto u3p_in1;
-		}
-		if ((j & 0x80) == 0x00) {
-			goto u3p_in1;
-		}
-		j = atp_readb_io(dev, c, 0x17) & 0x0f;
-		if (j == 0x0f) {
-			goto u3p_in;
-		}
-		if (j == 0x0a) {
-			goto u3p_cmd;
-		}
-		if (j == 0x0e) {
-			goto u3p_out;
-		}
-		continue;
-u3p_cmd:
-		atp_writeb_io(dev, c, 0x10, 0x30);
-		atp_writeb_io(dev, c, 0x14, 0x00);
-		atp_writeb_io(dev, c, 0x18, 0x08);
-
-		while ((atp_readb_io(dev, c, 0x1f) & 0x80) == 0x00)
-			cpu_relax();
-
-		j = atp_readb_io(dev, c, 0x17);
-		if (j != 0x16) {
-			if (j == 0x4e) {
-				goto u3p_out;
-			}
-			continue;
-		}
-		if (mbuf[0] != 0x01) {
-			goto chg_wide;
-		}
-		if (mbuf[1] != 0x06) {
-			goto chg_wide;
-		}
-		if (mbuf[2] != 0x04) {
-			goto chg_wide;
-		}
-		if (mbuf[3] == 0x09) {
-			m = 1;
-			m = m << i;
-			dev->wide_id[c] |= m;
-			dev->id[c][i].devsp = 0xce;
-			continue;
-		}
-chg_wide:
-		atp_writeb_io(dev, c, 0x1b, 0x01);
-		atp_writeb_io(dev, c, 3, satn[0]);
-		atp_writeb_io(dev, c, 4, satn[1]);
-		atp_writeb_io(dev, c, 5, satn[2]);
-		atp_writeb_io(dev, c, 6, satn[3]);
-		atp_writeb_io(dev, c, 7, satn[4]);
-		atp_writeb_io(dev, c, 8, satn[5]);
-		atp_writeb_io(dev, c, 0x0f, 0);
-		atp_writeb_io(dev, c, 0x11, dev->id[c][i].devsp);
-		atp_writeb_io(dev, c, 0x12, 0);
-		atp_writeb_io(dev, c, 0x13, satn[6]);
-		atp_writeb_io(dev, c, 0x14, satn[7]);
-		atp_writeb_io(dev, c, 0x18, satn[8]);
-
-		while ((atp_readb_io(dev, c, 0x1f) & 0x80) == 0x00)
-			cpu_relax();
-
-		if (atp_readb_io(dev, c, 0x17) != 0x11 && atp_readb_io(dev, c, 0x17) != 0x8e)
-			continue;
-
-		while (atp_readb_io(dev, c, 0x17) != 0x8e)
-			cpu_relax();
-
-try_wide:
-		j = 0;
-		atp_writeb_io(dev, c, 0x14, 0x05);
-		atp_writeb_io(dev, c, 0x18, 0x20);
-
-		while ((atp_readb_io(dev, c, 0x1f) & 0x80) == 0) {
-			if ((atp_readb_io(dev, c, 0x1f) & 0x01) != 0)
-				atp_writeb_io(dev, c, 0x19, wide[j++]);
-		}
-
-		while ((atp_readb_io(dev, c, 0x17) & 0x80) == 0x00)
-			cpu_relax();
-
-		j = atp_readb_io(dev, c, 0x17) & 0x0f;
-		if (j == 0x0f) {
-			goto widep_in;
-		}
-		if (j == 0x0a) {
-			goto widep_cmd;
-		}
-		if (j == 0x0e) {
-			goto try_wide;
-		}
-		continue;
-widep_out:
-		atp_writeb_io(dev, c, 0x18, 0x20);
-		while ((atp_readb_io(dev, c, 0x1f) & 0x80) == 0) {
-			if ((atp_readb_io(dev, c, 0x1f) & 0x01) != 0)
-				atp_writeb_io(dev, c, 0x19, 0);
-		}
-		j = atp_readb_io(dev, c, 0x17) & 0x0f;
-		if (j == 0x0f) {
-			goto widep_in;
-		}
-		if (j == 0x0a) {
-			goto widep_cmd;
-		}
-		if (j == 0x0e) {
-			goto widep_out;
-		}
-		continue;
-widep_in:
-		atp_writeb_io(dev, c, 0x14, 0xff);
-		atp_writeb_io(dev, c, 0x18, 0x20);
-		k = 0;
-widep_in1:
-		j = atp_readb_io(dev, c, 0x1f);
-		if ((j & 0x01) != 0) {
-			mbuf[k++] = atp_readb_io(dev, c, 0x19);
-			goto widep_in1;
-		}
-		if ((j & 0x80) == 0x00) {
-			goto widep_in1;
-		}
-		j = atp_readb_io(dev, c, 0x17) & 0x0f;
-		if (j == 0x0f) {
-			goto widep_in;
-		}
-		if (j == 0x0a) {
-			goto widep_cmd;
-		}
-		if (j == 0x0e) {
-			goto widep_out;
-		}
-		continue;
-widep_cmd:
-		atp_writeb_io(dev, c, 0x10, 0x30);
-		atp_writeb_io(dev, c, 0x14, 0x00);
-		atp_writeb_io(dev, c, 0x18, 0x08);
-
-		while ((atp_readb_io(dev, c, 0x1f) & 0x80) == 0x00)
-			cpu_relax();
-
-		j = atp_readb_io(dev, c, 0x17);
-		if (j != 0x16) {
-			if (j == 0x4e) {
-				goto widep_out;
-			}
-			continue;
-		}
-		if (mbuf[0] != 0x01) {
-			goto not_wide;
-		}
-		if (mbuf[1] != 0x02) {
-			goto not_wide;
-		}
-		if (mbuf[2] != 0x03) {
-			goto not_wide;
-		}
-		if (mbuf[3] != 0x01) {
-			goto not_wide;
-		}
-		m = 1;
-		m = m << i;
-		dev->wide_id[c] |= m;
-not_wide:
-		if ((dev->id[c][i].devtype == 0x00) || (dev->id[c][i].devtype == 0x07) || ((dev->id[c][i].devtype == 0x05) && ((n & 0x10) != 0))) {
-			m = 1;
-			m = m << i;
-			if ((dev->async[c] & m) != 0) {
-				goto set_sync;
-			}
-		}
-		continue;
-set_sync:
-		if (dev->sp[c][i] == 0x02) {
-			synu[4] = 0x0c;
-			synuw[4] = 0x0c;
-		} else {
-			if (dev->sp[c][i] >= 0x03) {
-				synu[4] = 0x0a;
-				synuw[4] = 0x0a;
-			}
-		}
-		j = 0;
-		if ((m & dev->wide_id[c]) != 0) {
-			j |= 0x01;
-		}
-		atp_writeb_io(dev, c, 0x1b, j);
-		atp_writeb_io(dev, c, 3, satn[0]);
-		atp_writeb_io(dev, c, 4, satn[1]);
-		atp_writeb_io(dev, c, 5, satn[2]);
-		atp_writeb_io(dev, c, 6, satn[3]);
-		atp_writeb_io(dev, c, 7, satn[4]);
-		atp_writeb_io(dev, c, 8, satn[5]);
-		atp_writeb_io(dev, c, 0x0f, 0);
-		atp_writeb_io(dev, c, 0x11, dev->id[c][i].devsp);
-		atp_writeb_io(dev, c, 0x12, 0);
-		atp_writeb_io(dev, c, 0x13, satn[6]);
-		atp_writeb_io(dev, c, 0x14, satn[7]);
-		atp_writeb_io(dev, c, 0x18, satn[8]);
-
-		while ((atp_readb_io(dev, c, 0x1f) & 0x80) == 0x00)
-			cpu_relax();
-
-		if (atp_readb_io(dev, c, 0x17) != 0x11 && atp_readb_io(dev, c, 0x17) != 0x8e)
-			continue;
-
-		while (atp_readb_io(dev, c, 0x17) != 0x8e)
-			cpu_relax();
-
-try_sync:
-		j = 0;
-		atp_writeb_io(dev, c, 0x14, 0x06);
-		atp_writeb_io(dev, c, 0x18, 0x20);
-
-		while ((atp_readb_io(dev, c, 0x1f) & 0x80) == 0) {
-			if ((atp_readb_io(dev, c, 0x1f) & 0x01) != 0) {
-				if ((m & dev->wide_id[c]) != 0) {
-					if ((m & dev->ultra_map[c]) != 0) {
-						atp_writeb_io(dev, c, 0x19, synuw[j++]);
-					} else {
-						atp_writeb_io(dev, c, 0x19, synw[j++]);
-					}
-				} else {
-					if ((m & dev->ultra_map[c]) != 0) {
-						atp_writeb_io(dev, c, 0x19, synu[j++]);
-					} else {
-						atp_writeb_io(dev, c, 0x19, synn[j++]);
-					}
-				}
-			}
-		}
-
-		while ((atp_readb_io(dev, c, 0x17) & 0x80) == 0x00)
-			cpu_relax();
-
-		j = atp_readb_io(dev, c, 0x17) & 0x0f;
-		if (j == 0x0f) {
-			goto phase_ins;
-		}
-		if (j == 0x0a) {
-			goto phase_cmds;
-		}
-		if (j == 0x0e) {
-			goto try_sync;
-		}
-		continue;
-phase_outs:
-		atp_writeb_io(dev, c, 0x18, 0x20);
-		while ((atp_readb_io(dev, c, 0x1f) & 0x80) == 0x00) {
-			if ((atp_readb_io(dev, c, 0x1f) & 0x01) != 0x00)
-				atp_writeb_io(dev, c, 0x19, 0x00);
-		}
-		j = atp_readb_io(dev, c, 0x17);
-		if (j == 0x85) {
-			goto tar_dcons;
-		}
-		j &= 0x0f;
-		if (j == 0x0f) {
-			goto phase_ins;
-		}
-		if (j == 0x0a) {
-			goto phase_cmds;
-		}
-		if (j == 0x0e) {
-			goto phase_outs;
-		}
-		continue;
-phase_ins:
-		atp_writeb_io(dev, c, 0x14, 0x06);
-		atp_writeb_io(dev, c, 0x18, 0x20);
-		k = 0;
-phase_ins1:
-		j = atp_readb_io(dev, c, 0x1f);
-		if ((j & 0x01) != 0x00) {
-			mbuf[k++] = atp_readb_io(dev, c, 0x19);
-			goto phase_ins1;
-		}
-		if ((j & 0x80) == 0x00) {
-			goto phase_ins1;
-		}
-
-		while ((atp_readb_io(dev, c, 0x17) & 0x80) == 0x00)
-			cpu_relax();
-
-		j = atp_readb_io(dev, c, 0x17);
-		if (j == 0x85) {
-			goto tar_dcons;
-		}
-		j &= 0x0f;
-		if (j == 0x0f) {
-			goto phase_ins;
-		}
-		if (j == 0x0a) {
-			goto phase_cmds;
-		}
-		if (j == 0x0e) {
-			goto phase_outs;
-		}
-		continue;
-phase_cmds:
-		atp_writeb_io(dev, c, 0x10, 0x30);
-tar_dcons:
-		atp_writeb_io(dev, c, 0x14, 0x00);
-		atp_writeb_io(dev, c, 0x18, 0x08);
-
-		while ((atp_readb_io(dev, c, 0x1f) & 0x80) == 0x00)
-			cpu_relax();
-
-		j = atp_readb_io(dev, c, 0x17);
-		if (j != 0x16) {
-			continue;
-		}
-		if (mbuf[0] != 0x01) {
-			continue;
-		}
-		if (mbuf[1] != 0x03) {
-			continue;
-		}
-		if (mbuf[4] == 0x00) {
-			continue;
-		}
-		if (mbuf[3] > 0x64) {
-			continue;
-		}
-		if (mbuf[4] > 0x0e) {
-			mbuf[4] = 0x0e;
-		}
-		dev->id[c][i].devsp = mbuf[4];
-		if (mbuf[3] < 0x0c) {
-			j = 0xb0;
-			goto set_syn_ok;
-		}
-		if ((mbuf[3] < 0x0d) && (rmb == 0)) {
-			j = 0xa0;
-			goto set_syn_ok;
-		}
-		if (mbuf[3] < 0x1a) {
-			j = 0x20;
-			goto set_syn_ok;
-		}
-		if (mbuf[3] < 0x33) {
-			j = 0x40;
-			goto set_syn_ok;
-		}
-		if (mbuf[3] < 0x4c) {
-			j = 0x50;
-			goto set_syn_ok;
-		}
-		j = 0x60;
-set_syn_ok:
-		dev->id[c][i].devsp = (dev->id[c][i].devsp & 0x0f) | j;
-	}
-}
-
 static void atp870u_free_tables(struct Scsi_Host *host)
 {
 	struct atp_unit *atp_dev = (struct atp_unit *)&host->hostdata;
@@ -2377,7 +1807,7 @@ static int atp870u_probe(struct pci_dev *pdev, const struct pci_device_id *ent)
 		outb(0x20, base_io + 0x51);
 
 		tscam(shpnt);
-		is880(p, 0, atp_readb_base(p, 0x3f) & 0x40);
+		is885(p, 0, atp_readb_base(p, 0x3f) & 0x40);
 		outb(0xb0, base_io + 0x38);
 		shpnt->max_id = 16;
 		shpnt->this_id = host_id;

commit fa50b30842d8cea02903d55caf64fe22c0c4c8e2
Author: Ondrej Zary <linux@rainbow-software.org>
Date:   Tue Nov 17 19:24:00 2015 +0100

    atp870u: Move chip-specific lines out of is880() and is885()
    
    Move few chip-specifis lines out of is880() and is885() so they become
    almost identical.
    
    Signed-off-by: Ondrej Zary <linux@rainbow-software.org>
    Reviewed-by: Hannes Reinicke <hare@suse.de>
    Acked-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/atp870u.c b/drivers/scsi/atp870u.c
index ec619022aa6e..1c4b1f9f62b9 100644
--- a/drivers/scsi/atp870u.c
+++ b/drivers/scsi/atp870u.c
@@ -41,7 +41,7 @@
 
 static struct scsi_host_template atp870u_template;
 static void send_s870(struct atp_unit *dev,unsigned char c);
-static void is885(struct atp_unit *dev, unsigned char c);
+static void is885(struct atp_unit *dev, unsigned char c, unsigned char lvdmode);
 static void tscam_885(void);
 
 static inline void atp_writeb_base(struct atp_unit *atp, u8 reg, u8 val)
@@ -1596,9 +1596,9 @@ static void is870(struct atp_unit *dev, unsigned char c)
 	atp_writeb_io(dev, c, 0x3a, atp_readb_io(dev, c, 0x3a) & 0xef);
 }
 
-static void is880(struct atp_unit *dev, unsigned char c)
+static void is880(struct atp_unit *dev, unsigned char c, unsigned char lvdmode)
 {
-	unsigned char i, j, k, rmb, n, lvdmode;
+	unsigned char i, j, k, rmb, n;
 	unsigned short int m;
 	static unsigned char mbuf[512];
 	static unsigned char satn[9] = { 0, 0, 0, 0, 0, 0, 0, 6, 6 };
@@ -1610,8 +1610,6 @@ static void is880(struct atp_unit *dev, unsigned char c)
 	static unsigned char wide[6] = { 0x80, 1, 2, 3, 1, 0 };
 	static unsigned char u3[9] = { 0x80, 1, 6, 4, 0x09, 00, 0x0e, 0x01, 0x02 };
 
-	lvdmode = atp_readb_base(dev, 0x3f) & 0x40;
-
 	for (i = 0; i < 16; i++) {
 		m = 1;
 		m = m << i;
@@ -2379,7 +2377,7 @@ static int atp870u_probe(struct pci_dev *pdev, const struct pci_device_id *ent)
 		outb(0x20, base_io + 0x51);
 
 		tscam(shpnt);
-		is880(p, 0);
+		is880(p, 0, atp_readb_base(p, 0x3f) & 0x40);
 		outb(0xb0, base_io + 0x38);
 		shpnt->max_id = 16;
 		shpnt->this_id = host_id;
@@ -2525,10 +2523,11 @@ static int atp870u_probe(struct pci_dev *pdev, const struct pci_device_id *ent)
 
 		tscam_885();
 		printk(KERN_INFO "   Scanning Channel A SCSI Device ...\n");
-		is885(p, 0);
+		is885(p, 0, atp_readb_io(p, 0, 0x1b) >> 7);
+		atp_writeb_io(p, 0, 0x16, 0x80);
 		printk(KERN_INFO "   Scanning Channel B SCSI Device ...\n");
-		is885(p, 1);
-
+		is885(p, 1, atp_readb_io(p, 1, 0x1b) >> 7);
+		atp_writeb_io(p, 1, 0x16, 0x80);
 		k = inb(base_io + 0x28) & 0xcf;
 		k |= 0xc0;
 		outb(k, base_io + 0x28);
@@ -2829,9 +2828,9 @@ static void tscam_885(void)
 
 
 
-static void is885(struct atp_unit *dev, unsigned char c)
+static void is885(struct atp_unit *dev, unsigned char c, unsigned char lvdmode)
 {
-	unsigned char i, j, k, rmb, n, lvdmode;
+	unsigned char i, j, k, rmb, n;
 	unsigned short int m;
 	static unsigned char mbuf[512];
 	static unsigned char satn[9] = { 0, 0, 0, 0, 0, 0, 0, 6, 6 };
@@ -2843,8 +2842,6 @@ static void is885(struct atp_unit *dev, unsigned char c)
 	static unsigned char wide[6] = { 0x80, 1, 2, 3, 1, 0 };
 	static unsigned char u3[9] = { 0x80, 1, 6, 4, 0x09, 00, 0x0e, 0x01, 0x02 };
 
-	lvdmode = atp_readb_io(dev, c, 0x1b) >> 7;
-
 	for (i = 0; i < 16; i++) {
 		m = 1;
 		m = m << i;
@@ -3408,7 +3405,6 @@ static void is885(struct atp_unit *dev, unsigned char c)
 		printk("dev->id[%2d][%2d].devsp = %2x\n",c,i,dev->id[c][i].devsp);
 #endif
 	}
-	atp_writeb_io(dev, c, 0x16, 0x80);
 }
 
 module_init(atp870u_init);

commit bdf8b62dc3fb2ef5df22d36d1d2ec1d38e081290
Author: Ondrej Zary <linux@rainbow-software.org>
Date:   Tue Nov 17 19:23:59 2015 +0100

    atp870u: Add channel parameter to is870() and is880()
    
    Add channel parameter to is870() and is880() functions to simplify comparing
    them with is885().
    
    Signed-off-by: Ondrej Zary <linux@rainbow-software.org>
    Reviewed-by: Hannes Reinicke <hare@suse.de>
    Acked-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/atp870u.c b/drivers/scsi/atp870u.c
index 595c5c54af99..ec619022aa6e 100644
--- a/drivers/scsi/atp870u.c
+++ b/drivers/scsi/atp870u.c
@@ -1162,7 +1162,7 @@ static void tscam(struct Scsi_Host *host)
 	}
 }
 
-static void is870(struct atp_unit *dev)
+static void is870(struct atp_unit *dev, unsigned char c)
 {
 	unsigned char i, j, k, rmb, n;
 	unsigned short int m;
@@ -1174,7 +1174,7 @@ static void is870(struct atp_unit *dev)
 	static unsigned char synw[6] = { 0x80, 1, 3, 1, 0x0c, 0x07 };
 	static unsigned char wide[6] = { 0x80, 1, 2, 3, 1, 0 };
 
-	atp_writeb_io(dev, 0, 0x3a, atp_readb_io(dev, 0, 0x3a) | 0x10);
+	atp_writeb_io(dev, c, 0x3a, atp_readb_io(dev, c, 0x3a) | 0x10);
 
 	for (i = 0; i < 16; i++) {
 		if ((dev->chip_ver != 4) && (i > 7)) {
@@ -1182,120 +1182,120 @@ static void is870(struct atp_unit *dev)
 		}
 		m = 1;
 		m = m << i;
-		if ((m & dev->active_id[0]) != 0) {
+		if ((m & dev->active_id[c]) != 0) {
 			continue;
 		}
-		if (i == dev->host_id[0]) {
-			printk(KERN_INFO "         ID: %2d  Host Adapter\n", dev->host_id[0]);
+		if (i == dev->host_id[c]) {
+			printk(KERN_INFO "         ID: %2d  Host Adapter\n", dev->host_id[c]);
 			continue;
 		}
 		if (dev->chip_ver == 4) {
-			atp_writeb_io(dev, 0, 0x1b, 0x01);
+			atp_writeb_io(dev, c, 0x1b, 0x01);
 		} else {
-			atp_writeb_io(dev, 0, 0x1b, 0x00);
+			atp_writeb_io(dev, c, 0x1b, 0x00);
 		}
-		atp_writeb_io(dev, 0, 1, 0x08);
-		atp_writeb_io(dev, 0, 2, 0x7f);
-		atp_writeb_io(dev, 0, 3, satn[0]);
-		atp_writeb_io(dev, 0, 4, satn[1]);
-		atp_writeb_io(dev, 0, 5, satn[2]);
-		atp_writeb_io(dev, 0, 6, satn[3]);
-		atp_writeb_io(dev, 0, 7, satn[4]);
-		atp_writeb_io(dev, 0, 8, satn[5]);
-		atp_writeb_io(dev, 0, 0x0f, 0);
-		atp_writeb_io(dev, 0, 0x11, dev->id[0][i].devsp);
-		atp_writeb_io(dev, 0, 0x12, 0);
-		atp_writeb_io(dev, 0, 0x13, satn[6]);
-		atp_writeb_io(dev, 0, 0x14, satn[7]);
+		atp_writeb_io(dev, c, 1, 0x08);
+		atp_writeb_io(dev, c, 2, 0x7f);
+		atp_writeb_io(dev, c, 3, satn[0]);
+		atp_writeb_io(dev, c, 4, satn[1]);
+		atp_writeb_io(dev, c, 5, satn[2]);
+		atp_writeb_io(dev, c, 6, satn[3]);
+		atp_writeb_io(dev, c, 7, satn[4]);
+		atp_writeb_io(dev, c, 8, satn[5]);
+		atp_writeb_io(dev, c, 0x0f, 0);
+		atp_writeb_io(dev, c, 0x11, dev->id[c][i].devsp);
+		atp_writeb_io(dev, c, 0x12, 0);
+		atp_writeb_io(dev, c, 0x13, satn[6]);
+		atp_writeb_io(dev, c, 0x14, satn[7]);
 		j = i;
 		if ((j & 0x08) != 0) {
 			j = (j & 0x07) | 0x40;
 		}
-		atp_writeb_io(dev, 0, 0x15, j);
-		atp_writeb_io(dev, 0, 0x18, satn[8]);
+		atp_writeb_io(dev, c, 0x15, j);
+		atp_writeb_io(dev, c, 0x18, satn[8]);
 
-		while ((atp_readb_io(dev, 0, 0x1f) & 0x80) == 0x00)
+		while ((atp_readb_io(dev, c, 0x1f) & 0x80) == 0x00)
 			cpu_relax();
 
-		if (atp_readb_io(dev, 0, 0x17) != 0x11 && atp_readb_io(dev, 0, 0x17) != 0x8e)
+		if (atp_readb_io(dev, c, 0x17) != 0x11 && atp_readb_io(dev, c, 0x17) != 0x8e)
 			continue;
 
-		while (atp_readb_io(dev, 0, 0x17) != 0x8e)
+		while (atp_readb_io(dev, c, 0x17) != 0x8e)
 			cpu_relax();
 
-		dev->active_id[0] |= m;
+		dev->active_id[c] |= m;
 
-		atp_writeb_io(dev, 0, 0x10, 0x30);
-		atp_writeb_io(dev, 0, 0x04, 0x00);
+		atp_writeb_io(dev, c, 0x10, 0x30);
+		atp_writeb_io(dev, c, 0x04, 0x00);
 
 phase_cmd:
-		atp_writeb_io(dev, 0, 0x18, 0x08);
+		atp_writeb_io(dev, c, 0x18, 0x08);
 
-		while ((atp_readb_io(dev, 0, 0x1f) & 0x80) == 0x00)
+		while ((atp_readb_io(dev, c, 0x1f) & 0x80) == 0x00)
 			cpu_relax();
 
-		j = atp_readb_io(dev, 0, 0x17);
+		j = atp_readb_io(dev, c, 0x17);
 		if (j != 0x16) {
-			atp_writeb_io(dev, 0, 0x10, 0x41);
+			atp_writeb_io(dev, c, 0x10, 0x41);
 			goto phase_cmd;
 		}
 sel_ok:
-		atp_writeb_io(dev, 0, 3, inqd[0]);
-		atp_writeb_io(dev, 0, 4, inqd[1]);
-		atp_writeb_io(dev, 0, 5, inqd[2]);
-		atp_writeb_io(dev, 0, 6, inqd[3]);
-		atp_writeb_io(dev, 0, 7, inqd[4]);
-		atp_writeb_io(dev, 0, 8, inqd[5]);
-		atp_writeb_io(dev, 0, 0x0f, 0);
-		atp_writeb_io(dev, 0, 0x11, dev->id[0][i].devsp);
-		atp_writeb_io(dev, 0, 0x12, 0);
-		atp_writeb_io(dev, 0, 0x13, inqd[6]);
-		atp_writeb_io(dev, 0, 0x14, inqd[7]);
-		atp_writeb_io(dev, 0, 0x18, inqd[8]);
+		atp_writeb_io(dev, c, 3, inqd[0]);
+		atp_writeb_io(dev, c, 4, inqd[1]);
+		atp_writeb_io(dev, c, 5, inqd[2]);
+		atp_writeb_io(dev, c, 6, inqd[3]);
+		atp_writeb_io(dev, c, 7, inqd[4]);
+		atp_writeb_io(dev, c, 8, inqd[5]);
+		atp_writeb_io(dev, c, 0x0f, 0);
+		atp_writeb_io(dev, c, 0x11, dev->id[c][i].devsp);
+		atp_writeb_io(dev, c, 0x12, 0);
+		atp_writeb_io(dev, c, 0x13, inqd[6]);
+		atp_writeb_io(dev, c, 0x14, inqd[7]);
+		atp_writeb_io(dev, c, 0x18, inqd[8]);
 
-		while ((atp_readb_io(dev, 0, 0x1f) & 0x80) == 0x00)
+		while ((atp_readb_io(dev, c, 0x1f) & 0x80) == 0x00)
 			cpu_relax();
 
-		if (atp_readb_io(dev, 0, 0x17) != 0x11 && atp_readb_io(dev, 0, 0x17) != 0x8e)
+		if (atp_readb_io(dev, c, 0x17) != 0x11 && atp_readb_io(dev, c, 0x17) != 0x8e)
 			continue;
 
-		while (atp_readb_io(dev, 0, 0x17) != 0x8e)
+		while (atp_readb_io(dev, c, 0x17) != 0x8e)
 			cpu_relax();
 
 		if (dev->chip_ver == 4)
-			atp_writeb_io(dev, 0, 0x1b, 0x00);
+			atp_writeb_io(dev, c, 0x1b, 0x00);
 
-		atp_writeb_io(dev, 0, 0x18, 0x08);
+		atp_writeb_io(dev, c, 0x18, 0x08);
 		j = 0;
 rd_inq_data:
-		k = atp_readb_io(dev, 0, 0x1f);
+		k = atp_readb_io(dev, c, 0x1f);
 		if ((k & 0x01) != 0) {
-			mbuf[j++] = atp_readb_io(dev, 0, 0x19);
+			mbuf[j++] = atp_readb_io(dev, c, 0x19);
 			goto rd_inq_data;
 		}
 		if ((k & 0x80) == 0) {
 			goto rd_inq_data;
 		}
-		j = atp_readb_io(dev, 0, 0x17);
+		j = atp_readb_io(dev, c, 0x17);
 		if (j == 0x16) {
 			goto inq_ok;
 		}
-		atp_writeb_io(dev, 0, 0x10, 0x46);
-		atp_writeb_io(dev, 0, 0x12, 0);
-		atp_writeb_io(dev, 0, 0x13, 0);
-		atp_writeb_io(dev, 0, 0x14, 0);
-		atp_writeb_io(dev, 0, 0x18, 0x08);
+		atp_writeb_io(dev, c, 0x10, 0x46);
+		atp_writeb_io(dev, c, 0x12, 0);
+		atp_writeb_io(dev, c, 0x13, 0);
+		atp_writeb_io(dev, c, 0x14, 0);
+		atp_writeb_io(dev, c, 0x18, 0x08);
 
-		while ((atp_readb_io(dev, 0, 0x1f) & 0x80) == 0x00)
+		while ((atp_readb_io(dev, c, 0x1f) & 0x80) == 0x00)
 			cpu_relax();
 
-		if (atp_readb_io(dev, 0, 0x17) != 0x16)
+		if (atp_readb_io(dev, c, 0x17) != 0x16)
 			goto sel_ok;
 
 inq_ok:
 		mbuf[36] = 0;
 		printk(KERN_INFO "         ID: %2d  %s\n", i, &mbuf[8]);
-		dev->id[0][i].devtype = mbuf[0];
+		dev->id[c][i].devtype = mbuf[0];
 		rmb = mbuf[1];
 		n = mbuf[7];
 		if (dev->chip_ver != 4) {
@@ -1304,46 +1304,46 @@ static void is870(struct atp_unit *dev)
 		if ((mbuf[7] & 0x60) == 0) {
 			goto not_wide;
 		}
-		if ((dev->global_map[0] & 0x20) == 0) {
+		if ((dev->global_map[c] & 0x20) == 0) {
 			goto not_wide;
 		}
-		atp_writeb_io(dev, 0, 0x1b, 0x01);
-		atp_writeb_io(dev, 0, 3, satn[0]);
-		atp_writeb_io(dev, 0, 4, satn[1]);
-		atp_writeb_io(dev, 0, 5, satn[2]);
-		atp_writeb_io(dev, 0, 6, satn[3]);
-		atp_writeb_io(dev, 0, 7, satn[4]);
-		atp_writeb_io(dev, 0, 8, satn[5]);
-		atp_writeb_io(dev, 0, 0x0f, 0);
-		atp_writeb_io(dev, 0, 0x11, dev->id[0][i].devsp);
-		atp_writeb_io(dev, 0, 0x12, 0);
-		atp_writeb_io(dev, 0, 0x13, satn[6]);
-		atp_writeb_io(dev, 0, 0x14, satn[7]);
-		atp_writeb_io(dev, 0, 0x18, satn[8]);
+		atp_writeb_io(dev, c, 0x1b, 0x01);
+		atp_writeb_io(dev, c, 3, satn[0]);
+		atp_writeb_io(dev, c, 4, satn[1]);
+		atp_writeb_io(dev, c, 5, satn[2]);
+		atp_writeb_io(dev, c, 6, satn[3]);
+		atp_writeb_io(dev, c, 7, satn[4]);
+		atp_writeb_io(dev, c, 8, satn[5]);
+		atp_writeb_io(dev, c, 0x0f, 0);
+		atp_writeb_io(dev, c, 0x11, dev->id[c][i].devsp);
+		atp_writeb_io(dev, c, 0x12, 0);
+		atp_writeb_io(dev, c, 0x13, satn[6]);
+		atp_writeb_io(dev, c, 0x14, satn[7]);
+		atp_writeb_io(dev, c, 0x18, satn[8]);
 
-		while ((atp_readb_io(dev, 0, 0x1f) & 0x80) == 0x00)
+		while ((atp_readb_io(dev, c, 0x1f) & 0x80) == 0x00)
 			cpu_relax();
 
-		if (atp_readb_io(dev, 0, 0x17) != 0x11 && atp_readb_io(dev, 0, 0x17) != 0x8e)
+		if (atp_readb_io(dev, c, 0x17) != 0x11 && atp_readb_io(dev, c, 0x17) != 0x8e)
 			continue;
 
-		while (atp_readb_io(dev, 0, 0x17) != 0x8e)
+		while (atp_readb_io(dev, c, 0x17) != 0x8e)
 			cpu_relax();
 
 try_wide:
 		j = 0;
-		atp_writeb_io(dev, 0, 0x14, 0x05);
-		atp_writeb_io(dev, 0, 0x18, 0x20);
+		atp_writeb_io(dev, c, 0x14, 0x05);
+		atp_writeb_io(dev, c, 0x18, 0x20);
 
-		while ((atp_readb_io(dev, 0, 0x1f) & 0x80) == 0) {
-			if ((atp_readb_io(dev, 0, 0x1f) & 0x01) != 0)
-				atp_writeb_io(dev, 0, 0x19, wide[j++]);
+		while ((atp_readb_io(dev, c, 0x1f) & 0x80) == 0) {
+			if ((atp_readb_io(dev, c, 0x1f) & 0x01) != 0)
+				atp_writeb_io(dev, c, 0x19, wide[j++]);
 		}
 
-		while ((atp_readb_io(dev, 0, 0x17) & 0x80) == 0x00)
+		while ((atp_readb_io(dev, c, 0x17) & 0x80) == 0x00)
 			cpu_relax();
 
-		j = atp_readb_io(dev, 0, 0x17) & 0x0f;
+		j = atp_readb_io(dev, c, 0x17) & 0x0f;
 		if (j == 0x0f) {
 			goto widep_in;
 		}
@@ -1355,12 +1355,12 @@ static void is870(struct atp_unit *dev)
 		}
 		continue;
 widep_out:
-		atp_writeb_io(dev, 0, 0x18, 0x20);
-		while ((atp_readb_io(dev, 0, 0x1f) & 0x80) == 0) {
-			if ((atp_readb_io(dev, 0, 0x1f) & 0x01) != 0)
-				atp_writeb_io(dev, 0, 0x19, 0);
+		atp_writeb_io(dev, c, 0x18, 0x20);
+		while ((atp_readb_io(dev, c, 0x1f) & 0x80) == 0) {
+			if ((atp_readb_io(dev, c, 0x1f) & 0x01) != 0)
+				atp_writeb_io(dev, c, 0x19, 0);
 		}
-		j = atp_readb_io(dev, 0, 0x17) & 0x0f;
+		j = atp_readb_io(dev, c, 0x17) & 0x0f;
 		if (j == 0x0f) {
 			goto widep_in;
 		}
@@ -1372,19 +1372,19 @@ static void is870(struct atp_unit *dev)
 		}
 		continue;
 widep_in:
-		atp_writeb_io(dev, 0, 0x14, 0xff);
-		atp_writeb_io(dev, 0, 0x18, 0x20);
+		atp_writeb_io(dev, c, 0x14, 0xff);
+		atp_writeb_io(dev, c, 0x18, 0x20);
 		k = 0;
 widep_in1:
-		j = atp_readb_io(dev, 0, 0x1f);
+		j = atp_readb_io(dev, c, 0x1f);
 		if ((j & 0x01) != 0) {
-			mbuf[k++] = atp_readb_io(dev, 0, 0x19);
+			mbuf[k++] = atp_readb_io(dev, c, 0x19);
 			goto widep_in1;
 		}
 		if ((j & 0x80) == 0x00) {
 			goto widep_in1;
 		}
-		j = atp_readb_io(dev, 0, 0x17) & 0x0f;
+		j = atp_readb_io(dev, c, 0x17) & 0x0f;
 		if (j == 0x0f) {
 			goto widep_in;
 		}
@@ -1396,14 +1396,14 @@ static void is870(struct atp_unit *dev)
 		}
 		continue;
 widep_cmd:
-		atp_writeb_io(dev, 0, 0x10, 0x30);
-		atp_writeb_io(dev, 0, 0x14, 0x00);
-		atp_writeb_io(dev, 0, 0x18, 0x08);
+		atp_writeb_io(dev, c, 0x10, 0x30);
+		atp_writeb_io(dev, c, 0x14, 0x00);
+		atp_writeb_io(dev, c, 0x18, 0x08);
 
-		while ((atp_readb_io(dev, 0, 0x1f) & 0x80) == 0x00)
+		while ((atp_readb_io(dev, c, 0x1f) & 0x80) == 0x00)
 			cpu_relax();
 
-		j = atp_readb_io(dev, 0, 0x17);
+		j = atp_readb_io(dev, c, 0x17);
 		if (j != 0x16) {
 			if (j == 0x4e) {
 				goto widep_out;
@@ -1424,63 +1424,63 @@ static void is870(struct atp_unit *dev)
 		}
 		m = 1;
 		m = m << i;
-		dev->wide_id[0] |= m;
+		dev->wide_id[c] |= m;
 not_wide:
-		if ((dev->id[0][i].devtype == 0x00) || (dev->id[0][i].devtype == 0x07) || ((dev->id[0][i].devtype == 0x05) && ((n & 0x10) != 0))) {
+		if ((dev->id[c][i].devtype == 0x00) || (dev->id[c][i].devtype == 0x07) || ((dev->id[c][i].devtype == 0x05) && ((n & 0x10) != 0))) {
 			goto set_sync;
 		}
 		continue;
 set_sync:
 		j = 0;
-		if ((m & dev->wide_id[0]) != 0) {
+		if ((m & dev->wide_id[c]) != 0) {
 			j |= 0x01;
 		}
-		atp_writeb_io(dev, 0, 0x1b, j);
-		atp_writeb_io(dev, 0, 3, satn[0]);
-		atp_writeb_io(dev, 0, 4, satn[1]);
-		atp_writeb_io(dev, 0, 5, satn[2]);
-		atp_writeb_io(dev, 0, 6, satn[3]);
-		atp_writeb_io(dev, 0, 7, satn[4]);
-		atp_writeb_io(dev, 0, 8, satn[5]);
-		atp_writeb_io(dev, 0, 0x0f, 0);
-		atp_writeb_io(dev, 0, 0x11, dev->id[0][i].devsp);
-		atp_writeb_io(dev, 0, 0x12, 0);
-		atp_writeb_io(dev, 0, 0x13, satn[6]);
-		atp_writeb_io(dev, 0, 0x14, satn[7]);
-		atp_writeb_io(dev, 0, 0x18, satn[8]);
+		atp_writeb_io(dev, c, 0x1b, j);
+		atp_writeb_io(dev, c, 3, satn[0]);
+		atp_writeb_io(dev, c, 4, satn[1]);
+		atp_writeb_io(dev, c, 5, satn[2]);
+		atp_writeb_io(dev, c, 6, satn[3]);
+		atp_writeb_io(dev, c, 7, satn[4]);
+		atp_writeb_io(dev, c, 8, satn[5]);
+		atp_writeb_io(dev, c, 0x0f, 0);
+		atp_writeb_io(dev, c, 0x11, dev->id[c][i].devsp);
+		atp_writeb_io(dev, c, 0x12, 0);
+		atp_writeb_io(dev, c, 0x13, satn[6]);
+		atp_writeb_io(dev, c, 0x14, satn[7]);
+		atp_writeb_io(dev, c, 0x18, satn[8]);
 
-		while ((atp_readb_io(dev, 0, 0x1f) & 0x80) == 0x00)
+		while ((atp_readb_io(dev, c, 0x1f) & 0x80) == 0x00)
 			cpu_relax();
 
-		if (atp_readb_io(dev, 0, 0x17) != 0x11 && atp_readb_io(dev, 0, 0x17) != 0x8e)
+		if (atp_readb_io(dev, c, 0x17) != 0x11 && atp_readb_io(dev, c, 0x17) != 0x8e)
 			continue;
 
-		while (atp_readb_io(dev, 0, 0x17) != 0x8e)
+		while (atp_readb_io(dev, c, 0x17) != 0x8e)
 			cpu_relax();
 
 try_sync:
 		j = 0;
-		atp_writeb_io(dev, 0, 0x14, 0x06);
-		atp_writeb_io(dev, 0, 0x18, 0x20);
+		atp_writeb_io(dev, c, 0x14, 0x06);
+		atp_writeb_io(dev, c, 0x18, 0x20);
 
-		while ((atp_readb_io(dev, 0, 0x1f) & 0x80) == 0) {
-			if ((atp_readb_io(dev, 0, 0x1f) & 0x01) != 0) {
-				if ((m & dev->wide_id[0]) != 0) {
-					atp_writeb_io(dev, 0, 0x19, synw[j++]);
+		while ((atp_readb_io(dev, c, 0x1f) & 0x80) == 0) {
+			if ((atp_readb_io(dev, c, 0x1f) & 0x01) != 0) {
+				if ((m & dev->wide_id[c]) != 0) {
+					atp_writeb_io(dev, c, 0x19, synw[j++]);
 				} else {
-					if ((m & dev->ultra_map[0]) != 0) {
-						atp_writeb_io(dev, 0, 0x19, synu[j++]);
+					if ((m & dev->ultra_map[c]) != 0) {
+						atp_writeb_io(dev, c, 0x19, synu[j++]);
 					} else {
-						atp_writeb_io(dev, 0, 0x19, synn[j++]);
+						atp_writeb_io(dev, c, 0x19, synn[j++]);
 					}
 				}
 			}
 		}
 
-		while ((atp_readb_io(dev, 0, 0x17) & 0x80) == 0x00)
+		while ((atp_readb_io(dev, c, 0x17) & 0x80) == 0x00)
 			cpu_relax();
 
-		j = atp_readb_io(dev, 0, 0x17) & 0x0f;
+		j = atp_readb_io(dev, c, 0x17) & 0x0f;
 		if (j == 0x0f) {
 			goto phase_ins;
 		}
@@ -1492,12 +1492,12 @@ static void is870(struct atp_unit *dev)
 		}
 		continue;
 phase_outs:
-		atp_writeb_io(dev, 0, 0x18, 0x20);
-		while ((atp_readb_io(dev, 0, 0x1f) & 0x80) == 0x00) {
-			if ((atp_readb_io(dev, 0, 0x1f) & 0x01) != 0x00)
-				atp_writeb_io(dev, 0, 0x19, 0x00);
+		atp_writeb_io(dev, c, 0x18, 0x20);
+		while ((atp_readb_io(dev, c, 0x1f) & 0x80) == 0x00) {
+			if ((atp_readb_io(dev, c, 0x1f) & 0x01) != 0x00)
+				atp_writeb_io(dev, c, 0x19, 0x00);
 		}
-		j = atp_readb_io(dev, 0, 0x17);
+		j = atp_readb_io(dev, c, 0x17);
 		if (j == 0x85) {
 			goto tar_dcons;
 		}
@@ -1513,23 +1513,23 @@ static void is870(struct atp_unit *dev)
 		}
 		continue;
 phase_ins:
-		atp_writeb_io(dev, 0, 0x14, 0xff);
-		atp_writeb_io(dev, 0, 0x18, 0x20);
+		atp_writeb_io(dev, c, 0x14, 0xff);
+		atp_writeb_io(dev, c, 0x18, 0x20);
 		k = 0;
 phase_ins1:
-		j = atp_readb_io(dev, 0, 0x1f);
+		j = atp_readb_io(dev, c, 0x1f);
 		if ((j & 0x01) != 0x00) {
-			mbuf[k++] = atp_readb_io(dev, 0, 0x19);
+			mbuf[k++] = atp_readb_io(dev, c, 0x19);
 			goto phase_ins1;
 		}
 		if ((j & 0x80) == 0x00) {
 			goto phase_ins1;
 		}
 
-		while ((atp_readb_io(dev, 0, 0x17) & 0x80) == 0x00)
+		while ((atp_readb_io(dev, c, 0x17) & 0x80) == 0x00)
 			cpu_relax();
 
-		j = atp_readb_io(dev, 0, 0x17);
+		j = atp_readb_io(dev, c, 0x17);
 		if (j == 0x85) {
 			goto tar_dcons;
 		}
@@ -1545,15 +1545,15 @@ static void is870(struct atp_unit *dev)
 		}
 		continue;
 phase_cmds:
-		atp_writeb_io(dev, 0, 0x10, 0x30);
+		atp_writeb_io(dev, c, 0x10, 0x30);
 tar_dcons:
-		atp_writeb_io(dev, 0, 0x14, 0x00);
-		atp_writeb_io(dev, 0, 0x18, 0x08);
+		atp_writeb_io(dev, c, 0x14, 0x00);
+		atp_writeb_io(dev, c, 0x18, 0x08);
 
-		while ((atp_readb_io(dev, 0, 0x1f) & 0x80) == 0x00)
+		while ((atp_readb_io(dev, c, 0x1f) & 0x80) == 0x00)
 			cpu_relax();
 
-		j = atp_readb_io(dev, 0, 0x17);
+		j = atp_readb_io(dev, c, 0x17);
 		if (j != 0x16) {
 			continue;
 		}
@@ -1572,7 +1572,7 @@ static void is870(struct atp_unit *dev)
 		if (mbuf[4] > 0x0c) {
 			mbuf[4] = 0x0c;
 		}
-		dev->id[0][i].devsp = mbuf[4];
+		dev->id[c][i].devsp = mbuf[4];
 		if ((mbuf[3] < 0x0d) && (rmb == 0)) {
 			j = 0xa0;
 			goto set_syn_ok;
@@ -1591,12 +1591,12 @@ static void is870(struct atp_unit *dev)
 		}
 		j = 0x60;
 set_syn_ok:
-		dev->id[0][i].devsp = (dev->id[0][i].devsp & 0x0f) | j;
+		dev->id[c][i].devsp = (dev->id[c][i].devsp & 0x0f) | j;
 	}
-	atp_writeb_io(dev, 0, 0x3a, atp_readb_io(dev, 0, 0x3a) & 0xef);
+	atp_writeb_io(dev, c, 0x3a, atp_readb_io(dev, c, 0x3a) & 0xef);
 }
 
-static void is880(struct atp_unit *dev)
+static void is880(struct atp_unit *dev, unsigned char c)
 {
 	unsigned char i, j, k, rmb, n, lvdmode;
 	unsigned short int m;
@@ -1615,167 +1615,167 @@ static void is880(struct atp_unit *dev)
 	for (i = 0; i < 16; i++) {
 		m = 1;
 		m = m << i;
-		if ((m & dev->active_id[0]) != 0) {
+		if ((m & dev->active_id[c]) != 0) {
 			continue;
 		}
-		if (i == dev->host_id[0]) {
-			printk(KERN_INFO "         ID: %2d  Host Adapter\n", dev->host_id[0]);
+		if (i == dev->host_id[c]) {
+			printk(KERN_INFO "         ID: %2d  Host Adapter\n", dev->host_id[c]);
 			continue;
 		}
-		atp_writeb_io(dev, 0, 0x1b, 0x01);
-		atp_writeb_io(dev, 0, 1, 0x08);
-		atp_writeb_io(dev, 0, 2, 0x7f);
-		atp_writeb_io(dev, 0, 3, satn[0]);
-		atp_writeb_io(dev, 0, 4, satn[1]);
-		atp_writeb_io(dev, 0, 5, satn[2]);
-		atp_writeb_io(dev, 0, 6, satn[3]);
-		atp_writeb_io(dev, 0, 7, satn[4]);
-		atp_writeb_io(dev, 0, 8, satn[5]);
-		atp_writeb_io(dev, 0, 0x0f, 0);
-		atp_writeb_io(dev, 0, 0x11, dev->id[0][i].devsp);
-		atp_writeb_io(dev, 0, 0x12, 0);
-		atp_writeb_io(dev, 0, 0x13, satn[6]);
-		atp_writeb_io(dev, 0, 0x14, satn[7]);
+		atp_writeb_io(dev, c, 0x1b, 0x01);
+		atp_writeb_io(dev, c, 1, 0x08);
+		atp_writeb_io(dev, c, 2, 0x7f);
+		atp_writeb_io(dev, c, 3, satn[0]);
+		atp_writeb_io(dev, c, 4, satn[1]);
+		atp_writeb_io(dev, c, 5, satn[2]);
+		atp_writeb_io(dev, c, 6, satn[3]);
+		atp_writeb_io(dev, c, 7, satn[4]);
+		atp_writeb_io(dev, c, 8, satn[5]);
+		atp_writeb_io(dev, c, 0x0f, 0);
+		atp_writeb_io(dev, c, 0x11, dev->id[c][i].devsp);
+		atp_writeb_io(dev, c, 0x12, 0);
+		atp_writeb_io(dev, c, 0x13, satn[6]);
+		atp_writeb_io(dev, c, 0x14, satn[7]);
 		j = i;
 		if ((j & 0x08) != 0) {
 			j = (j & 0x07) | 0x40;
 		}
-		atp_writeb_io(dev, 0, 0x15, j);
-		atp_writeb_io(dev, 0, 0x18, satn[8]);
+		atp_writeb_io(dev, c, 0x15, j);
+		atp_writeb_io(dev, c, 0x18, satn[8]);
 
-		while ((atp_readb_io(dev, 0, 0x1f) & 0x80) == 0x00)
+		while ((atp_readb_io(dev, c, 0x1f) & 0x80) == 0x00)
 			cpu_relax();
 
-		if (atp_readb_io(dev, 0, 0x17) != 0x11 && atp_readb_io(dev, 0, 0x17) != 0x8e)
+		if (atp_readb_io(dev, c, 0x17) != 0x11 && atp_readb_io(dev, c, 0x17) != 0x8e)
 			continue;
 
-		while (atp_readb_io(dev, 0, 0x17) != 0x8e)
+		while (atp_readb_io(dev, c, 0x17) != 0x8e)
 			cpu_relax();
 
-		dev->active_id[0] |= m;
+		dev->active_id[c] |= m;
 
-		atp_writeb_io(dev, 0, 0x10, 0x30);
-		atp_writeb_io(dev, 0, 0x14, 0x00);
+		atp_writeb_io(dev, c, 0x10, 0x30);
+		atp_writeb_io(dev, c, 0x14, 0x00);
 
 phase_cmd:
-		atp_writeb_io(dev, 0, 0x18, 0x08);
+		atp_writeb_io(dev, c, 0x18, 0x08);
 
-		while ((atp_readb_io(dev, 0, 0x1f) & 0x80) == 0x00)
+		while ((atp_readb_io(dev, c, 0x1f) & 0x80) == 0x00)
 			cpu_relax();
 
-		j = atp_readb_io(dev, 0, 0x17);
+		j = atp_readb_io(dev, c, 0x17);
 		if (j != 0x16) {
-			atp_writeb_io(dev, 0, 0x10, 0x41);
+			atp_writeb_io(dev, c, 0x10, 0x41);
 			goto phase_cmd;
 		}
 sel_ok:
-		atp_writeb_io(dev, 0, 3, inqd[0]);
-		atp_writeb_io(dev, 0, 4, inqd[1]);
-		atp_writeb_io(dev, 0, 5, inqd[2]);
-		atp_writeb_io(dev, 0, 6, inqd[3]);
-		atp_writeb_io(dev, 0, 7, inqd[4]);
-		atp_writeb_io(dev, 0, 8, inqd[5]);
-		atp_writeb_io(dev, 0, 0x0f, 0);
-		atp_writeb_io(dev, 0, 0x11, dev->id[0][i].devsp);
-		atp_writeb_io(dev, 0, 0x12, 0);
-		atp_writeb_io(dev, 0, 0x13, inqd[6]);
-		atp_writeb_io(dev, 0, 0x14, inqd[7]);
-		atp_writeb_io(dev, 0, 0x18, inqd[8]);
+		atp_writeb_io(dev, c, 3, inqd[0]);
+		atp_writeb_io(dev, c, 4, inqd[1]);
+		atp_writeb_io(dev, c, 5, inqd[2]);
+		atp_writeb_io(dev, c, 6, inqd[3]);
+		atp_writeb_io(dev, c, 7, inqd[4]);
+		atp_writeb_io(dev, c, 8, inqd[5]);
+		atp_writeb_io(dev, c, 0x0f, 0);
+		atp_writeb_io(dev, c, 0x11, dev->id[c][i].devsp);
+		atp_writeb_io(dev, c, 0x12, 0);
+		atp_writeb_io(dev, c, 0x13, inqd[6]);
+		atp_writeb_io(dev, c, 0x14, inqd[7]);
+		atp_writeb_io(dev, c, 0x18, inqd[8]);
 
-		while ((atp_readb_io(dev, 0, 0x1f) & 0x80) == 0x00)
+		while ((atp_readb_io(dev, c, 0x1f) & 0x80) == 0x00)
 			cpu_relax();
 
-		if (atp_readb_io(dev, 0, 0x17) != 0x11 && atp_readb_io(dev, 0, 0x17) != 0x8e)
+		if (atp_readb_io(dev, c, 0x17) != 0x11 && atp_readb_io(dev, c, 0x17) != 0x8e)
 			continue;
 
-		while (atp_readb_io(dev, 0, 0x17) != 0x8e)
+		while (atp_readb_io(dev, c, 0x17) != 0x8e)
 			cpu_relax();
 
-		atp_writeb_io(dev, 0, 0x1b, 0x00);
-		atp_writeb_io(dev, 0, 0x18, 0x08);
+		atp_writeb_io(dev, c, 0x1b, 0x00);
+		atp_writeb_io(dev, c, 0x18, 0x08);
 		j = 0;
 rd_inq_data:
-		k = atp_readb_io(dev, 0, 0x1f);
+		k = atp_readb_io(dev, c, 0x1f);
 		if ((k & 0x01) != 0) {
-			mbuf[j++] = atp_readb_io(dev, 0, 0x19);
+			mbuf[j++] = atp_readb_io(dev, c, 0x19);
 			goto rd_inq_data;
 		}
 		if ((k & 0x80) == 0) {
 			goto rd_inq_data;
 		}
-		j = atp_readb_io(dev, 0, 0x17);
+		j = atp_readb_io(dev, c, 0x17);
 		if (j == 0x16) {
 			goto inq_ok;
 		}
-		atp_writeb_io(dev, 0, 0x10, 0x46);
-		atp_writeb_io(dev, 0, 0x12, 0);
-		atp_writeb_io(dev, 0, 0x13, 0);
-		atp_writeb_io(dev, 0, 0x14, 0);
-		atp_writeb_io(dev, 0, 0x18, 0x08);
+		atp_writeb_io(dev, c, 0x10, 0x46);
+		atp_writeb_io(dev, c, 0x12, 0);
+		atp_writeb_io(dev, c, 0x13, 0);
+		atp_writeb_io(dev, c, 0x14, 0);
+		atp_writeb_io(dev, c, 0x18, 0x08);
 
-		while ((atp_readb_io(dev, 0, 0x1f) & 0x80) == 0x00)
+		while ((atp_readb_io(dev, c, 0x1f) & 0x80) == 0x00)
 			cpu_relax();
 
-		if (atp_readb_io(dev, 0, 0x17) != 0x16)
+		if (atp_readb_io(dev, c, 0x17) != 0x16)
 			goto sel_ok;
 
 inq_ok:
 		mbuf[36] = 0;
 		printk(KERN_INFO "         ID: %2d  %s\n", i, &mbuf[8]);
-		dev->id[0][i].devtype = mbuf[0];
+		dev->id[c][i].devtype = mbuf[0];
 		rmb = mbuf[1];
 		n = mbuf[7];
 		if ((mbuf[7] & 0x60) == 0) {
 			goto not_wide;
 		}
-		if ((i < 8) && ((dev->global_map[0] & 0x20) == 0)) {
+		if ((i < 8) && ((dev->global_map[c] & 0x20) == 0)) {
 			goto not_wide;
 		}
 		if (lvdmode == 0) {
 			goto chg_wide;
 		}
-		if (dev->sp[0][i] != 0x04)	// force u2
+		if (dev->sp[c][i] != 0x04)	// force u2
 		{
 			goto chg_wide;
 		}
 
-		atp_writeb_io(dev, 0, 0x1b, 0x01);
-		atp_writeb_io(dev, 0, 3, satn[0]);
-		atp_writeb_io(dev, 0, 4, satn[1]);
-		atp_writeb_io(dev, 0, 5, satn[2]);
-		atp_writeb_io(dev, 0, 6, satn[3]);
-		atp_writeb_io(dev, 0, 7, satn[4]);
-		atp_writeb_io(dev, 0, 8, satn[5]);
-		atp_writeb_io(dev, 0, 0x0f, 0);
-		atp_writeb_io(dev, 0, 0x11, dev->id[0][i].devsp);
-		atp_writeb_io(dev, 0, 0x12, 0);
-		atp_writeb_io(dev, 0, 0x13, satn[6]);
-		atp_writeb_io(dev, 0, 0x14, satn[7]);
-		atp_writeb_io(dev, 0, 0x18, satn[8]);
+		atp_writeb_io(dev, c, 0x1b, 0x01);
+		atp_writeb_io(dev, c, 3, satn[0]);
+		atp_writeb_io(dev, c, 4, satn[1]);
+		atp_writeb_io(dev, c, 5, satn[2]);
+		atp_writeb_io(dev, c, 6, satn[3]);
+		atp_writeb_io(dev, c, 7, satn[4]);
+		atp_writeb_io(dev, c, 8, satn[5]);
+		atp_writeb_io(dev, c, 0x0f, 0);
+		atp_writeb_io(dev, c, 0x11, dev->id[c][i].devsp);
+		atp_writeb_io(dev, c, 0x12, 0);
+		atp_writeb_io(dev, c, 0x13, satn[6]);
+		atp_writeb_io(dev, c, 0x14, satn[7]);
+		atp_writeb_io(dev, c, 0x18, satn[8]);
 
-		while ((atp_readb_io(dev, 0, 0x1f) & 0x80) == 0x00)
+		while ((atp_readb_io(dev, c, 0x1f) & 0x80) == 0x00)
 			cpu_relax();
 
-		if (atp_readb_io(dev, 0, 0x17) != 0x11 && atp_readb_io(dev, 0, 0x17) != 0x8e)
+		if (atp_readb_io(dev, c, 0x17) != 0x11 && atp_readb_io(dev, c, 0x17) != 0x8e)
 			continue;
 
-		while (atp_readb_io(dev, 0, 0x17) != 0x8e)
+		while (atp_readb_io(dev, c, 0x17) != 0x8e)
 			cpu_relax();
 
 try_u3:
 		j = 0;
-		atp_writeb_io(dev, 0, 0x14, 0x09);
-		atp_writeb_io(dev, 0, 0x18, 0x20);
+		atp_writeb_io(dev, c, 0x14, 0x09);
+		atp_writeb_io(dev, c, 0x18, 0x20);
 
-		while ((atp_readb_io(dev, 0, 0x1f) & 0x80) == 0) {
-			if ((atp_readb_io(dev, 0, 0x1f) & 0x01) != 0)
-				atp_writeb_io(dev, 0, 0x19, u3[j++]);
+		while ((atp_readb_io(dev, c, 0x1f) & 0x80) == 0) {
+			if ((atp_readb_io(dev, c, 0x1f) & 0x01) != 0)
+				atp_writeb_io(dev, c, 0x19, u3[j++]);
 		}
 
-		while ((atp_readb_io(dev, 0, 0x17) & 0x80) == 0x00)
+		while ((atp_readb_io(dev, c, 0x17) & 0x80) == 0x00)
 			cpu_relax();
 
-		j = atp_readb_io(dev, 0, 0x17) & 0x0f;
+		j = atp_readb_io(dev, c, 0x17) & 0x0f;
 		if (j == 0x0f) {
 			goto u3p_in;
 		}
@@ -1787,12 +1787,12 @@ static void is880(struct atp_unit *dev)
 		}
 		continue;
 u3p_out:
-		atp_writeb_io(dev, 0, 0x18, 0x20);
-		while ((atp_readb_io(dev, 0, 0x1f) & 0x80) == 0) {
-			if ((atp_readb_io(dev, 0, 0x1f) & 0x01) != 0)
-				atp_writeb_io(dev, 0, 0x19, 0);
+		atp_writeb_io(dev, c, 0x18, 0x20);
+		while ((atp_readb_io(dev, c, 0x1f) & 0x80) == 0) {
+			if ((atp_readb_io(dev, c, 0x1f) & 0x01) != 0)
+				atp_writeb_io(dev, c, 0x19, 0);
 		}
-		j = atp_readb_io(dev, 0, 0x17) & 0x0f;
+		j = atp_readb_io(dev, c, 0x17) & 0x0f;
 		if (j == 0x0f) {
 			goto u3p_in;
 		}
@@ -1804,19 +1804,19 @@ static void is880(struct atp_unit *dev)
 		}
 		continue;
 u3p_in:
-		atp_writeb_io(dev, 0, 0x14, 0x09);
-		atp_writeb_io(dev, 0, 0x18, 0x20);
+		atp_writeb_io(dev, c, 0x14, 0x09);
+		atp_writeb_io(dev, c, 0x18, 0x20);
 		k = 0;
 u3p_in1:
-		j = atp_readb_io(dev, 0, 0x1f);
+		j = atp_readb_io(dev, c, 0x1f);
 		if ((j & 0x01) != 0) {
-			mbuf[k++] = atp_readb_io(dev, 0, 0x19);
+			mbuf[k++] = atp_readb_io(dev, c, 0x19);
 			goto u3p_in1;
 		}
 		if ((j & 0x80) == 0x00) {
 			goto u3p_in1;
 		}
-		j = atp_readb_io(dev, 0, 0x17) & 0x0f;
+		j = atp_readb_io(dev, c, 0x17) & 0x0f;
 		if (j == 0x0f) {
 			goto u3p_in;
 		}
@@ -1828,14 +1828,14 @@ static void is880(struct atp_unit *dev)
 		}
 		continue;
 u3p_cmd:
-		atp_writeb_io(dev, 0, 0x10, 0x30);
-		atp_writeb_io(dev, 0, 0x14, 0x00);
-		atp_writeb_io(dev, 0, 0x18, 0x08);
+		atp_writeb_io(dev, c, 0x10, 0x30);
+		atp_writeb_io(dev, c, 0x14, 0x00);
+		atp_writeb_io(dev, c, 0x18, 0x08);
 
-		while ((atp_readb_io(dev, 0, 0x1f) & 0x80) == 0x00)
+		while ((atp_readb_io(dev, c, 0x1f) & 0x80) == 0x00)
 			cpu_relax();
 
-		j = atp_readb_io(dev, 0, 0x17);
+		j = atp_readb_io(dev, c, 0x17);
 		if (j != 0x16) {
 			if (j == 0x4e) {
 				goto u3p_out;
@@ -1854,48 +1854,48 @@ static void is880(struct atp_unit *dev)
 		if (mbuf[3] == 0x09) {
 			m = 1;
 			m = m << i;
-			dev->wide_id[0] |= m;
-			dev->id[0][i].devsp = 0xce;
+			dev->wide_id[c] |= m;
+			dev->id[c][i].devsp = 0xce;
 			continue;
 		}
 chg_wide:
-		atp_writeb_io(dev, 0, 0x1b, 0x01);
-		atp_writeb_io(dev, 0, 3, satn[0]);
-		atp_writeb_io(dev, 0, 4, satn[1]);
-		atp_writeb_io(dev, 0, 5, satn[2]);
-		atp_writeb_io(dev, 0, 6, satn[3]);
-		atp_writeb_io(dev, 0, 7, satn[4]);
-		atp_writeb_io(dev, 0, 8, satn[5]);
-		atp_writeb_io(dev, 0, 0x0f, 0);
-		atp_writeb_io(dev, 0, 0x11, dev->id[0][i].devsp);
-		atp_writeb_io(dev, 0, 0x12, 0);
-		atp_writeb_io(dev, 0, 0x13, satn[6]);
-		atp_writeb_io(dev, 0, 0x14, satn[7]);
-		atp_writeb_io(dev, 0, 0x18, satn[8]);
+		atp_writeb_io(dev, c, 0x1b, 0x01);
+		atp_writeb_io(dev, c, 3, satn[0]);
+		atp_writeb_io(dev, c, 4, satn[1]);
+		atp_writeb_io(dev, c, 5, satn[2]);
+		atp_writeb_io(dev, c, 6, satn[3]);
+		atp_writeb_io(dev, c, 7, satn[4]);
+		atp_writeb_io(dev, c, 8, satn[5]);
+		atp_writeb_io(dev, c, 0x0f, 0);
+		atp_writeb_io(dev, c, 0x11, dev->id[c][i].devsp);
+		atp_writeb_io(dev, c, 0x12, 0);
+		atp_writeb_io(dev, c, 0x13, satn[6]);
+		atp_writeb_io(dev, c, 0x14, satn[7]);
+		atp_writeb_io(dev, c, 0x18, satn[8]);
 
-		while ((atp_readb_io(dev, 0, 0x1f) & 0x80) == 0x00)
+		while ((atp_readb_io(dev, c, 0x1f) & 0x80) == 0x00)
 			cpu_relax();
 
-		if (atp_readb_io(dev, 0, 0x17) != 0x11 && atp_readb_io(dev, 0, 0x17) != 0x8e)
+		if (atp_readb_io(dev, c, 0x17) != 0x11 && atp_readb_io(dev, c, 0x17) != 0x8e)
 			continue;
 
-		while (atp_readb_io(dev, 0, 0x17) != 0x8e)
+		while (atp_readb_io(dev, c, 0x17) != 0x8e)
 			cpu_relax();
 
 try_wide:
 		j = 0;
-		atp_writeb_io(dev, 0, 0x14, 0x05);
-		atp_writeb_io(dev, 0, 0x18, 0x20);
+		atp_writeb_io(dev, c, 0x14, 0x05);
+		atp_writeb_io(dev, c, 0x18, 0x20);
 
-		while ((atp_readb_io(dev, 0, 0x1f) & 0x80) == 0) {
-			if ((atp_readb_io(dev, 0, 0x1f) & 0x01) != 0)
-				atp_writeb_io(dev, 0, 0x19, wide[j++]);
+		while ((atp_readb_io(dev, c, 0x1f) & 0x80) == 0) {
+			if ((atp_readb_io(dev, c, 0x1f) & 0x01) != 0)
+				atp_writeb_io(dev, c, 0x19, wide[j++]);
 		}
 
-		while ((atp_readb_io(dev, 0, 0x17) & 0x80) == 0x00)
+		while ((atp_readb_io(dev, c, 0x17) & 0x80) == 0x00)
 			cpu_relax();
 
-		j = atp_readb_io(dev, 0, 0x17) & 0x0f;
+		j = atp_readb_io(dev, c, 0x17) & 0x0f;
 		if (j == 0x0f) {
 			goto widep_in;
 		}
@@ -1907,12 +1907,12 @@ static void is880(struct atp_unit *dev)
 		}
 		continue;
 widep_out:
-		atp_writeb_io(dev, 0, 0x18, 0x20);
-		while ((atp_readb_io(dev, 0, 0x1f) & 0x80) == 0) {
-			if ((atp_readb_io(dev, 0, 0x1f) & 0x01) != 0)
-				atp_writeb_io(dev, 0, 0x19, 0);
+		atp_writeb_io(dev, c, 0x18, 0x20);
+		while ((atp_readb_io(dev, c, 0x1f) & 0x80) == 0) {
+			if ((atp_readb_io(dev, c, 0x1f) & 0x01) != 0)
+				atp_writeb_io(dev, c, 0x19, 0);
 		}
-		j = atp_readb_io(dev, 0, 0x17) & 0x0f;
+		j = atp_readb_io(dev, c, 0x17) & 0x0f;
 		if (j == 0x0f) {
 			goto widep_in;
 		}
@@ -1924,19 +1924,19 @@ static void is880(struct atp_unit *dev)
 		}
 		continue;
 widep_in:
-		atp_writeb_io(dev, 0, 0x14, 0xff);
-		atp_writeb_io(dev, 0, 0x18, 0x20);
+		atp_writeb_io(dev, c, 0x14, 0xff);
+		atp_writeb_io(dev, c, 0x18, 0x20);
 		k = 0;
 widep_in1:
-		j = atp_readb_io(dev, 0, 0x1f);
+		j = atp_readb_io(dev, c, 0x1f);
 		if ((j & 0x01) != 0) {
-			mbuf[k++] = atp_readb_io(dev, 0, 0x19);
+			mbuf[k++] = atp_readb_io(dev, c, 0x19);
 			goto widep_in1;
 		}
 		if ((j & 0x80) == 0x00) {
 			goto widep_in1;
 		}
-		j = atp_readb_io(dev, 0, 0x17) & 0x0f;
+		j = atp_readb_io(dev, c, 0x17) & 0x0f;
 		if (j == 0x0f) {
 			goto widep_in;
 		}
@@ -1948,14 +1948,14 @@ static void is880(struct atp_unit *dev)
 		}
 		continue;
 widep_cmd:
-		atp_writeb_io(dev, 0, 0x10, 0x30);
-		atp_writeb_io(dev, 0, 0x14, 0x00);
-		atp_writeb_io(dev, 0, 0x18, 0x08);
+		atp_writeb_io(dev, c, 0x10, 0x30);
+		atp_writeb_io(dev, c, 0x14, 0x00);
+		atp_writeb_io(dev, c, 0x18, 0x08);
 
-		while ((atp_readb_io(dev, 0, 0x1f) & 0x80) == 0x00)
+		while ((atp_readb_io(dev, c, 0x1f) & 0x80) == 0x00)
 			cpu_relax();
 
-		j = atp_readb_io(dev, 0, 0x17);
+		j = atp_readb_io(dev, c, 0x17);
 		if (j != 0x16) {
 			if (j == 0x4e) {
 				goto widep_out;
@@ -1976,80 +1976,80 @@ static void is880(struct atp_unit *dev)
 		}
 		m = 1;
 		m = m << i;
-		dev->wide_id[0] |= m;
+		dev->wide_id[c] |= m;
 not_wide:
-		if ((dev->id[0][i].devtype == 0x00) || (dev->id[0][i].devtype == 0x07) || ((dev->id[0][i].devtype == 0x05) && ((n & 0x10) != 0))) {
+		if ((dev->id[c][i].devtype == 0x00) || (dev->id[c][i].devtype == 0x07) || ((dev->id[c][i].devtype == 0x05) && ((n & 0x10) != 0))) {
 			m = 1;
 			m = m << i;
-			if ((dev->async[0] & m) != 0) {
+			if ((dev->async[c] & m) != 0) {
 				goto set_sync;
 			}
 		}
 		continue;
 set_sync:
-		if (dev->sp[0][i] == 0x02) {
+		if (dev->sp[c][i] == 0x02) {
 			synu[4] = 0x0c;
 			synuw[4] = 0x0c;
 		} else {
-			if (dev->sp[0][i] >= 0x03) {
+			if (dev->sp[c][i] >= 0x03) {
 				synu[4] = 0x0a;
 				synuw[4] = 0x0a;
 			}
 		}
 		j = 0;
-		if ((m & dev->wide_id[0]) != 0) {
+		if ((m & dev->wide_id[c]) != 0) {
 			j |= 0x01;
 		}
-		atp_writeb_io(dev, 0, 0x1b, j);
-		atp_writeb_io(dev, 0, 3, satn[0]);
-		atp_writeb_io(dev, 0, 4, satn[1]);
-		atp_writeb_io(dev, 0, 5, satn[2]);
-		atp_writeb_io(dev, 0, 6, satn[3]);
-		atp_writeb_io(dev, 0, 7, satn[4]);
-		atp_writeb_io(dev, 0, 8, satn[5]);
-		atp_writeb_io(dev, 0, 0x0f, 0);
-		atp_writeb_io(dev, 0, 0x11, dev->id[0][i].devsp);
-		atp_writeb_io(dev, 0, 0x12, 0);
-		atp_writeb_io(dev, 0, 0x13, satn[6]);
-		atp_writeb_io(dev, 0, 0x14, satn[7]);
-		atp_writeb_io(dev, 0, 0x18, satn[8]);
+		atp_writeb_io(dev, c, 0x1b, j);
+		atp_writeb_io(dev, c, 3, satn[0]);
+		atp_writeb_io(dev, c, 4, satn[1]);
+		atp_writeb_io(dev, c, 5, satn[2]);
+		atp_writeb_io(dev, c, 6, satn[3]);
+		atp_writeb_io(dev, c, 7, satn[4]);
+		atp_writeb_io(dev, c, 8, satn[5]);
+		atp_writeb_io(dev, c, 0x0f, 0);
+		atp_writeb_io(dev, c, 0x11, dev->id[c][i].devsp);
+		atp_writeb_io(dev, c, 0x12, 0);
+		atp_writeb_io(dev, c, 0x13, satn[6]);
+		atp_writeb_io(dev, c, 0x14, satn[7]);
+		atp_writeb_io(dev, c, 0x18, satn[8]);
 
-		while ((atp_readb_io(dev, 0, 0x1f) & 0x80) == 0x00)
+		while ((atp_readb_io(dev, c, 0x1f) & 0x80) == 0x00)
 			cpu_relax();
 
-		if (atp_readb_io(dev, 0, 0x17) != 0x11 && atp_readb_io(dev, 0, 0x17) != 0x8e)
+		if (atp_readb_io(dev, c, 0x17) != 0x11 && atp_readb_io(dev, c, 0x17) != 0x8e)
 			continue;
 
-		while (atp_readb_io(dev, 0, 0x17) != 0x8e)
+		while (atp_readb_io(dev, c, 0x17) != 0x8e)
 			cpu_relax();
 
 try_sync:
 		j = 0;
-		atp_writeb_io(dev, 0, 0x14, 0x06);
-		atp_writeb_io(dev, 0, 0x18, 0x20);
-
-		while ((atp_readb_io(dev, 0, 0x1f) & 0x80) == 0) {
-			if ((atp_readb_io(dev, 0, 0x1f) & 0x01) != 0) {
-				if ((m & dev->wide_id[0]) != 0) {
-					if ((m & dev->ultra_map[0]) != 0) {
-						atp_writeb_io(dev, 0, 0x19, synuw[j++]);
+		atp_writeb_io(dev, c, 0x14, 0x06);
+		atp_writeb_io(dev, c, 0x18, 0x20);
+
+		while ((atp_readb_io(dev, c, 0x1f) & 0x80) == 0) {
+			if ((atp_readb_io(dev, c, 0x1f) & 0x01) != 0) {
+				if ((m & dev->wide_id[c]) != 0) {
+					if ((m & dev->ultra_map[c]) != 0) {
+						atp_writeb_io(dev, c, 0x19, synuw[j++]);
 					} else {
-						atp_writeb_io(dev, 0, 0x19, synw[j++]);
+						atp_writeb_io(dev, c, 0x19, synw[j++]);
 					}
 				} else {
-					if ((m & dev->ultra_map[0]) != 0) {
-						atp_writeb_io(dev, 0, 0x19, synu[j++]);
+					if ((m & dev->ultra_map[c]) != 0) {
+						atp_writeb_io(dev, c, 0x19, synu[j++]);
 					} else {
-						atp_writeb_io(dev, 0, 0x19, synn[j++]);
+						atp_writeb_io(dev, c, 0x19, synn[j++]);
 					}
 				}
 			}
 		}
 
-		while ((atp_readb_io(dev, 0, 0x17) & 0x80) == 0x00)
+		while ((atp_readb_io(dev, c, 0x17) & 0x80) == 0x00)
 			cpu_relax();
 
-		j = atp_readb_io(dev, 0, 0x17) & 0x0f;
+		j = atp_readb_io(dev, c, 0x17) & 0x0f;
 		if (j == 0x0f) {
 			goto phase_ins;
 		}
@@ -2061,12 +2061,12 @@ static void is880(struct atp_unit *dev)
 		}
 		continue;
 phase_outs:
-		atp_writeb_io(dev, 0, 0x18, 0x20);
-		while ((atp_readb_io(dev, 0, 0x1f) & 0x80) == 0x00) {
-			if ((atp_readb_io(dev, 0, 0x1f) & 0x01) != 0x00)
-				atp_writeb_io(dev, 0, 0x19, 0x00);
+		atp_writeb_io(dev, c, 0x18, 0x20);
+		while ((atp_readb_io(dev, c, 0x1f) & 0x80) == 0x00) {
+			if ((atp_readb_io(dev, c, 0x1f) & 0x01) != 0x00)
+				atp_writeb_io(dev, c, 0x19, 0x00);
 		}
-		j = atp_readb_io(dev, 0, 0x17);
+		j = atp_readb_io(dev, c, 0x17);
 		if (j == 0x85) {
 			goto tar_dcons;
 		}
@@ -2082,23 +2082,23 @@ static void is880(struct atp_unit *dev)
 		}
 		continue;
 phase_ins:
-		atp_writeb_io(dev, 0, 0x14, 0x06);
-		atp_writeb_io(dev, 0, 0x18, 0x20);
+		atp_writeb_io(dev, c, 0x14, 0x06);
+		atp_writeb_io(dev, c, 0x18, 0x20);
 		k = 0;
 phase_ins1:
-		j = atp_readb_io(dev, 0, 0x1f);
+		j = atp_readb_io(dev, c, 0x1f);
 		if ((j & 0x01) != 0x00) {
-			mbuf[k++] = atp_readb_io(dev, 0, 0x19);
+			mbuf[k++] = atp_readb_io(dev, c, 0x19);
 			goto phase_ins1;
 		}
 		if ((j & 0x80) == 0x00) {
 			goto phase_ins1;
 		}
 
-		while ((atp_readb_io(dev, 0, 0x17) & 0x80) == 0x00)
+		while ((atp_readb_io(dev, c, 0x17) & 0x80) == 0x00)
 			cpu_relax();
 
-		j = atp_readb_io(dev, 0, 0x17);
+		j = atp_readb_io(dev, c, 0x17);
 		if (j == 0x85) {
 			goto tar_dcons;
 		}
@@ -2114,15 +2114,15 @@ static void is880(struct atp_unit *dev)
 		}
 		continue;
 phase_cmds:
-		atp_writeb_io(dev, 0, 0x10, 0x30);
+		atp_writeb_io(dev, c, 0x10, 0x30);
 tar_dcons:
-		atp_writeb_io(dev, 0, 0x14, 0x00);
-		atp_writeb_io(dev, 0, 0x18, 0x08);
+		atp_writeb_io(dev, c, 0x14, 0x00);
+		atp_writeb_io(dev, c, 0x18, 0x08);
 
-		while ((atp_readb_io(dev, 0, 0x1f) & 0x80) == 0x00)
+		while ((atp_readb_io(dev, c, 0x1f) & 0x80) == 0x00)
 			cpu_relax();
 
-		j = atp_readb_io(dev, 0, 0x17);
+		j = atp_readb_io(dev, c, 0x17);
 		if (j != 0x16) {
 			continue;
 		}
@@ -2141,7 +2141,7 @@ static void is880(struct atp_unit *dev)
 		if (mbuf[4] > 0x0e) {
 			mbuf[4] = 0x0e;
 		}
-		dev->id[0][i].devsp = mbuf[4];
+		dev->id[c][i].devsp = mbuf[4];
 		if (mbuf[3] < 0x0c) {
 			j = 0xb0;
 			goto set_syn_ok;
@@ -2164,7 +2164,7 @@ static void is880(struct atp_unit *dev)
 		}
 		j = 0x60;
 set_syn_ok:
-		dev->id[0][i].devsp = (dev->id[0][i].devsp & 0x0f) | j;
+		dev->id[c][i].devsp = (dev->id[c][i].devsp & 0x0f) | j;
 	}
 }
 
@@ -2379,7 +2379,7 @@ static int atp870u_probe(struct pci_dev *pdev, const struct pci_device_id *ent)
 		outb(0x20, base_io + 0x51);
 
 		tscam(shpnt);
-		is880(p);
+		is880(p, 0);
 		outb(0xb0, base_io + 0x38);
 		shpnt->max_id = 16;
 		shpnt->this_id = host_id;
@@ -2609,7 +2609,7 @@ static int atp870u_probe(struct pci_dev *pdev, const struct pci_device_id *ent)
 		outb(0x20, base_io + 0x11);
 
 		tscam(shpnt);
-		is870(p);
+		is870(p, 0);
 		outb((inb(base_io + 0x3a) & 0xef), base_io + 0x3a);
 		outb((inb(base_io + 0x3b) | 0x20), base_io + 0x3b);
 		if (atpdev->chip_ver == 4)

commit 80b52a7f8d2d432e21ba1bd47212bc1aa93b3647
Author: Ondrej Zary <linux@rainbow-software.org>
Date:   Tue Nov 17 19:23:58 2015 +0100

    atp870u: Unify code format in is870(), is880() and is885()
    
    Unify code formatting in is870(), is880() and is885() functions to simplify
    comparing them.
    
    Signed-off-by: Ondrej Zary <linux@rainbow-software.org>
    Reviewed-by: Hannes Reinicke <hare@suse.de>
    Acked-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/atp870u.c b/drivers/scsi/atp870u.c
index ad7af547fc90..595c5c54af99 100644
--- a/drivers/scsi/atp870u.c
+++ b/drivers/scsi/atp870u.c
@@ -1173,7 +1173,7 @@ static void is870(struct atp_unit *dev)
 	static unsigned char synu[6] = { 0x80, 1, 3, 1, 0x0c, 0x0e };
 	static unsigned char synw[6] = { 0x80, 1, 3, 1, 0x0c, 0x07 };
 	static unsigned char wide[6] = { 0x80, 1, 2, 3, 1, 0 };
-	
+
 	atp_writeb_io(dev, 0, 0x3a, atp_readb_io(dev, 0, 0x3a) | 0x10);
 
 	for (i = 0; i < 16; i++) {
@@ -1230,8 +1230,10 @@ static void is870(struct atp_unit *dev)
 
 phase_cmd:
 		atp_writeb_io(dev, 0, 0x18, 0x08);
+
 		while ((atp_readb_io(dev, 0, 0x1f) & 0x80) == 0x00)
 			cpu_relax();
+
 		j = atp_readb_io(dev, 0, 0x17);
 		if (j != 0x16) {
 			atp_writeb_io(dev, 0, 0x10, 0x41);
@@ -1253,13 +1255,13 @@ static void is870(struct atp_unit *dev)
 
 		while ((atp_readb_io(dev, 0, 0x1f) & 0x80) == 0x00)
 			cpu_relax();
-			
+
 		if (atp_readb_io(dev, 0, 0x17) != 0x11 && atp_readb_io(dev, 0, 0x17) != 0x8e)
 			continue;
 
 		while (atp_readb_io(dev, 0, 0x17) != 0x8e)
 			cpu_relax();
-			
+
 		if (dev->chip_ver == 4)
 			atp_writeb_io(dev, 0, 0x1b, 0x00);
 
@@ -1286,10 +1288,10 @@ static void is870(struct atp_unit *dev)
 
 		while ((atp_readb_io(dev, 0, 0x1f) & 0x80) == 0x00)
 			cpu_relax();
-			
-		if (atp_readb_io(dev, 0, 0x17) != 0x16) {
+
+		if (atp_readb_io(dev, 0, 0x17) != 0x16)
 			goto sel_ok;
-		}
+
 inq_ok:
 		mbuf[36] = 0;
 		printk(KERN_INFO "         ID: %2d  %s\n", i, &mbuf[8]);
@@ -1321,13 +1323,13 @@ static void is870(struct atp_unit *dev)
 
 		while ((atp_readb_io(dev, 0, 0x1f) & 0x80) == 0x00)
 			cpu_relax();
-			
+
 		if (atp_readb_io(dev, 0, 0x17) != 0x11 && atp_readb_io(dev, 0, 0x17) != 0x8e)
 			continue;
 
 		while (atp_readb_io(dev, 0, 0x17) != 0x8e)
 			cpu_relax();
-			
+
 try_wide:
 		j = 0;
 		atp_writeb_io(dev, 0, 0x14, 0x05);
@@ -1337,10 +1339,10 @@ static void is870(struct atp_unit *dev)
 			if ((atp_readb_io(dev, 0, 0x1f) & 0x01) != 0)
 				atp_writeb_io(dev, 0, 0x19, wide[j++]);
 		}
-		
+
 		while ((atp_readb_io(dev, 0, 0x17) & 0x80) == 0x00)
 			cpu_relax();
-			
+
 		j = atp_readb_io(dev, 0, 0x17) & 0x0f;
 		if (j == 0x0f) {
 			goto widep_in;
@@ -1449,13 +1451,13 @@ static void is870(struct atp_unit *dev)
 
 		while ((atp_readb_io(dev, 0, 0x1f) & 0x80) == 0x00)
 			cpu_relax();
-			
+
 		if (atp_readb_io(dev, 0, 0x17) != 0x11 && atp_readb_io(dev, 0, 0x17) != 0x8e)
 			continue;
 
 		while (atp_readb_io(dev, 0, 0x17) != 0x8e)
 			cpu_relax();
-			
+
 try_sync:
 		j = 0;
 		atp_writeb_io(dev, 0, 0x14, 0x06);
@@ -1474,10 +1476,10 @@ static void is870(struct atp_unit *dev)
 				}
 			}
 		}
-		
+
 		while ((atp_readb_io(dev, 0, 0x17) & 0x80) == 0x00)
 			cpu_relax();
-			
+
 		j = atp_readb_io(dev, 0, 0x17) & 0x0f;
 		if (j == 0x0f) {
 			goto phase_ins;
@@ -1526,7 +1528,7 @@ static void is870(struct atp_unit *dev)
 
 		while ((atp_readb_io(dev, 0, 0x17) & 0x80) == 0x00)
 			cpu_relax();
-			
+
 		j = atp_readb_io(dev, 0, 0x17);
 		if (j == 0x85) {
 			goto tar_dcons;
@@ -1547,10 +1549,10 @@ static void is870(struct atp_unit *dev)
 tar_dcons:
 		atp_writeb_io(dev, 0, 0x14, 0x00);
 		atp_writeb_io(dev, 0, 0x18, 0x08);
-		
+
 		while ((atp_readb_io(dev, 0, 0x1f) & 0x80) == 0x00)
 			cpu_relax();
-			
+
 		j = atp_readb_io(dev, 0, 0x17);
 		if (j != 0x16) {
 			continue;
@@ -1649,7 +1651,7 @@ static void is880(struct atp_unit *dev)
 
 		while (atp_readb_io(dev, 0, 0x17) != 0x8e)
 			cpu_relax();
-			
+
 		dev->active_id[0] |= m;
 
 		atp_writeb_io(dev, 0, 0x10, 0x30);
@@ -1657,7 +1659,7 @@ static void is880(struct atp_unit *dev)
 
 phase_cmd:
 		atp_writeb_io(dev, 0, 0x18, 0x08);
-		
+
 		while ((atp_readb_io(dev, 0, 0x1f) & 0x80) == 0x00)
 			cpu_relax();
 
@@ -1679,16 +1681,16 @@ static void is880(struct atp_unit *dev)
 		atp_writeb_io(dev, 0, 0x13, inqd[6]);
 		atp_writeb_io(dev, 0, 0x14, inqd[7]);
 		atp_writeb_io(dev, 0, 0x18, inqd[8]);
-		
+
 		while ((atp_readb_io(dev, 0, 0x1f) & 0x80) == 0x00)
 			cpu_relax();
-			
+
 		if (atp_readb_io(dev, 0, 0x17) != 0x11 && atp_readb_io(dev, 0, 0x17) != 0x8e)
 			continue;
 
 		while (atp_readb_io(dev, 0, 0x17) != 0x8e)
 			cpu_relax();
-			
+
 		atp_writeb_io(dev, 0, 0x1b, 0x00);
 		atp_writeb_io(dev, 0, 0x18, 0x08);
 		j = 0;
@@ -1710,9 +1712,10 @@ static void is880(struct atp_unit *dev)
 		atp_writeb_io(dev, 0, 0x13, 0);
 		atp_writeb_io(dev, 0, 0x14, 0);
 		atp_writeb_io(dev, 0, 0x18, 0x08);
+
 		while ((atp_readb_io(dev, 0, 0x1f) & 0x80) == 0x00)
 			cpu_relax();
-			
+
 		if (atp_readb_io(dev, 0, 0x17) != 0x16)
 			goto sel_ok;
 
@@ -1771,7 +1774,7 @@ static void is880(struct atp_unit *dev)
 
 		while ((atp_readb_io(dev, 0, 0x17) & 0x80) == 0x00)
 			cpu_relax();
-			
+
 		j = atp_readb_io(dev, 0, 0x17) & 0x0f;
 		if (j == 0x0f) {
 			goto u3p_in;
@@ -1828,10 +1831,10 @@ static void is880(struct atp_unit *dev)
 		atp_writeb_io(dev, 0, 0x10, 0x30);
 		atp_writeb_io(dev, 0, 0x14, 0x00);
 		atp_writeb_io(dev, 0, 0x18, 0x08);
-		
+
 		while ((atp_readb_io(dev, 0, 0x1f) & 0x80) == 0x00)
 			cpu_relax();
-			
+
 		j = atp_readb_io(dev, 0, 0x17);
 		if (j != 0x16) {
 			if (j == 0x4e) {
@@ -1872,13 +1875,13 @@ static void is880(struct atp_unit *dev)
 
 		while ((atp_readb_io(dev, 0, 0x1f) & 0x80) == 0x00)
 			cpu_relax();
-			
+
 		if (atp_readb_io(dev, 0, 0x17) != 0x11 && atp_readb_io(dev, 0, 0x17) != 0x8e)
 			continue;
 
 		while (atp_readb_io(dev, 0, 0x17) != 0x8e)
 			cpu_relax();
-			
+
 try_wide:
 		j = 0;
 		atp_writeb_io(dev, 0, 0x14, 0x05);
@@ -1888,9 +1891,10 @@ static void is880(struct atp_unit *dev)
 			if ((atp_readb_io(dev, 0, 0x1f) & 0x01) != 0)
 				atp_writeb_io(dev, 0, 0x19, wide[j++]);
 		}
+
 		while ((atp_readb_io(dev, 0, 0x17) & 0x80) == 0x00)
 			cpu_relax();
-			
+
 		j = atp_readb_io(dev, 0, 0x17) & 0x0f;
 		if (j == 0x0f) {
 			goto widep_in;
@@ -2013,9 +2017,9 @@ static void is880(struct atp_unit *dev)
 		while ((atp_readb_io(dev, 0, 0x1f) & 0x80) == 0x00)
 			cpu_relax();
 
-		if (atp_readb_io(dev, 0, 0x17) != 0x11 && atp_readb_io(dev, 0, 0x17) != 0x8e) {
+		if (atp_readb_io(dev, 0, 0x17) != 0x11 && atp_readb_io(dev, 0, 0x17) != 0x8e)
 			continue;
-		}
+
 		while (atp_readb_io(dev, 0, 0x17) != 0x8e)
 			cpu_relax();
 
@@ -2830,16 +2834,16 @@ static void is885(struct atp_unit *dev, unsigned char c)
 	unsigned char i, j, k, rmb, n, lvdmode;
 	unsigned short int m;
 	static unsigned char mbuf[512];
-	static unsigned char satn[9] =	{0, 0, 0, 0, 0, 0, 0, 6, 6};
-	static unsigned char inqd[9] =	{0x12, 0, 0, 0, 0x24, 0, 0, 0x24, 6};
-	static unsigned char synn[6] =	{0x80, 1, 3, 1, 0x19, 0x0e};
-	unsigned char synu[6] =  {0x80, 1, 3, 1, 0x0a, 0x0e};
-	static unsigned char synw[6] =	{0x80, 1, 3, 1, 0x19, 0x0e};
-	unsigned char synuw[6] =  {0x80, 1, 3, 1, 0x0a, 0x0e};
-	static unsigned char wide[6] =	{0x80, 1, 2, 3, 1, 0};
-	static unsigned char u3[9] = { 0x80,1,6,4,0x09,00,0x0e,0x01,0x02 };
+	static unsigned char satn[9] = { 0, 0, 0, 0, 0, 0, 0, 6, 6 };
+	static unsigned char inqd[9] = { 0x12, 0, 0, 0, 0x24, 0, 0, 0x24, 6 };
+	static unsigned char synn[6] = { 0x80, 1, 3, 1, 0x19, 0x0e };
+	unsigned char synu[6] = { 0x80, 1, 3, 1, 0x0a, 0x0e };
+	static unsigned char synw[6] = { 0x80, 1, 3, 1, 0x19, 0x0e };
+	unsigned char synuw[6] = { 0x80, 1, 3, 1, 0x0a, 0x0e };
+	static unsigned char wide[6] = { 0x80, 1, 2, 3, 1, 0 };
+	static unsigned char u3[9] = { 0x80, 1, 6, 4, 0x09, 00, 0x0e, 0x01, 0x02 };
 
-	lvdmode=atp_readb_io(dev, c, 0x1b) >> 7;
+	lvdmode = atp_readb_io(dev, c, 0x1b) >> 7;
 
 	for (i = 0; i < 16; i++) {
 		m = 1;
@@ -2862,7 +2866,6 @@ static void is885(struct atp_unit *dev, unsigned char c)
 		atp_writeb_io(dev, c, 8, satn[5]);
 		atp_writeb_io(dev, c, 0x0f, 0);
 		atp_writeb_io(dev, c, 0x11, dev->id[c][i].devsp);
-		
 		atp_writeb_io(dev, c, 0x12, 0);
 		atp_writeb_io(dev, c, 0x13, satn[6]);
 		atp_writeb_io(dev, c, 0x14, satn[7]);
@@ -2875,11 +2878,13 @@ static void is885(struct atp_unit *dev, unsigned char c)
 
 		while ((atp_readb_io(dev, c, 0x1f) & 0x80) == 0x00)
 			cpu_relax();
-		if ((atp_readb_io(dev, c, 0x17) != 0x11) && (atp_readb_io(dev, c, 0x17) != 0x8e)) {
+
+		if (atp_readb_io(dev, c, 0x17) != 0x11 && atp_readb_io(dev, c, 0x17) != 0x8e)
 			continue;
-		}
+
 		while (atp_readb_io(dev, c, 0x17) != 0x8e)
 			cpu_relax();
+
 		dev->active_id[c] |= m;
 
 		atp_writeb_io(dev, c, 0x10, 0x30);
@@ -2887,8 +2892,10 @@ static void is885(struct atp_unit *dev, unsigned char c)
 
 phase_cmd:
 		atp_writeb_io(dev, c, 0x18, 0x08);
+
 		while ((atp_readb_io(dev, c, 0x1f) & 0x80) == 0x00)
 			cpu_relax();
+
 		j = atp_readb_io(dev, c, 0x17);
 		if (j != 0x16) {
 			atp_writeb_io(dev, c, 0x10, 0x41);
@@ -2907,13 +2914,16 @@ static void is885(struct atp_unit *dev, unsigned char c)
 		atp_writeb_io(dev, c, 0x13, inqd[6]);
 		atp_writeb_io(dev, c, 0x14, inqd[7]);
 		atp_writeb_io(dev, c, 0x18, inqd[8]);
+
 		while ((atp_readb_io(dev, c, 0x1f) & 0x80) == 0x00)
 			cpu_relax();
-		if ((atp_readb_io(dev, c, 0x17) != 0x11) && (atp_readb_io(dev, c, 0x17) != 0x8e)) {
+
+		if (atp_readb_io(dev, c, 0x17) != 0x11 && atp_readb_io(dev, c, 0x17) != 0x8e)
 			continue;
-		}
+
 		while (atp_readb_io(dev, c, 0x17) != 0x8e)
 			cpu_relax();
+
 		atp_writeb_io(dev, c, 0x1b, 0x00);
 		atp_writeb_io(dev, c, 0x18, 0x08);
 		j = 0;
@@ -2935,14 +2945,16 @@ static void is885(struct atp_unit *dev, unsigned char c)
 		atp_writeb_io(dev, c, 0x13, 0);
 		atp_writeb_io(dev, c, 0x14, 0);
 		atp_writeb_io(dev, c, 0x18, 0x08);
+
 		while ((atp_readb_io(dev, c, 0x1f) & 0x80) == 0x00)
 			cpu_relax();
-		if (atp_readb_io(dev, c, 0x17) != 0x16) {
+
+		if (atp_readb_io(dev, c, 0x17) != 0x16)
 			goto sel_ok;
-		}
+
 inq_ok:
 		mbuf[36] = 0;
-		printk( KERN_INFO"         ID: %2d  %s\n", i, &mbuf[8]);
+		printk(KERN_INFO "         ID: %2d  %s\n", i, &mbuf[8]);
 		dev->id[c][i].devtype = mbuf[0];
 		rmb = mbuf[1];
 		n = mbuf[7];
@@ -2953,10 +2965,11 @@ static void is885(struct atp_unit *dev, unsigned char c)
 			goto not_wide;
 		}
 		if (lvdmode == 0) {
-		   goto chg_wide;
+			goto chg_wide;
 		}
-		if (dev->sp[c][i] != 0x04) {	// force u2
-		   goto chg_wide;
+		if (dev->sp[c][i] != 0x04)	// force u2
+		{
+			goto chg_wide;
 		}
 
 		atp_writeb_io(dev, c, 0x1b, 0x01);
@@ -2975,11 +2988,13 @@ static void is885(struct atp_unit *dev, unsigned char c)
 
 		while ((atp_readb_io(dev, c, 0x1f) & 0x80) == 0x00)
 			cpu_relax();
-		if ((atp_readb_io(dev, c, 0x17) != 0x11) && (atp_readb_io(dev, c, 0x17) != 0x8e)) {
+
+		if (atp_readb_io(dev, c, 0x17) != 0x11 && atp_readb_io(dev, c, 0x17) != 0x8e)
 			continue;
-		}
+
 		while (atp_readb_io(dev, c, 0x17) != 0x8e)
 			cpu_relax();
+
 try_u3:
 		j = 0;
 		atp_writeb_io(dev, c, 0x14, 0x09);
@@ -2990,8 +3005,10 @@ static void is885(struct atp_unit *dev, unsigned char c)
 				atp_writeb_io(dev, c, 0x19, u3[j++]);
 			cpu_relax();
 		}
+
 		while ((atp_readb_io(dev, c, 0x17) & 0x80) == 0x00)
 			cpu_relax();
+
 		j = atp_readb_io(dev, c, 0x17) & 0x0f;
 		if (j == 0x0f) {
 			goto u3p_in;
@@ -3049,7 +3066,9 @@ static void is885(struct atp_unit *dev, unsigned char c)
 		atp_writeb_io(dev, c, 0x10, 0x30);
 		atp_writeb_io(dev, c, 0x14, 0x00);
 		atp_writeb_io(dev, c, 0x18, 0x08);
+
 		while ((atp_readb_io(dev, c, 0x1f) & 0x80) == 0x00);
+
 		j = atp_readb_io(dev, c, 0x17);
 		if (j != 0x16) {
 			if (j == 0x4e) {
@@ -3093,11 +3112,13 @@ static void is885(struct atp_unit *dev, unsigned char c)
 
 		while ((atp_readb_io(dev, c, 0x1f) & 0x80) == 0x00)
 			cpu_relax();
-		if ((atp_readb_io(dev, c, 0x17) != 0x11) && (atp_readb_io(dev, c, 0x17) != 0x8e)) {
+
+		if (atp_readb_io(dev, c, 0x17) != 0x11 && atp_readb_io(dev, c, 0x17) != 0x8e)
 			continue;
-		}
+
 		while (atp_readb_io(dev, c, 0x17) != 0x8e)
 			cpu_relax();
+
 try_wide:
 		j = 0;
 		atp_writeb_io(dev, c, 0x14, 0x05);
@@ -3108,8 +3129,10 @@ static void is885(struct atp_unit *dev, unsigned char c)
 				atp_writeb_io(dev, c, 0x19, wide[j++]);
 			cpu_relax();
 		}
+
 		while ((atp_readb_io(dev, c, 0x17) & 0x80) == 0x00)
 			cpu_relax();
+
 		j = atp_readb_io(dev, c, 0x17) & 0x0f;
 		if (j == 0x0f) {
 			goto widep_in;
@@ -3167,8 +3190,10 @@ static void is885(struct atp_unit *dev, unsigned char c)
 		atp_writeb_io(dev, c, 0x10, 0x30);
 		atp_writeb_io(dev, c, 0x14, 0x00);
 		atp_writeb_io(dev, c, 0x18, 0x08);
+
 		while ((atp_readb_io(dev, c, 0x1f) & 0x80) == 0x00)
 			cpu_relax();
+
 		j = atp_readb_io(dev, c, 0x17);
 		if (j != 0x16) {
 			if (j == 0x4e) {
@@ -3192,24 +3217,23 @@ static void is885(struct atp_unit *dev, unsigned char c)
 		m = m << i;
 		dev->wide_id[c] |= m;
 not_wide:
-		if ((dev->id[c][i].devtype == 0x00) || (dev->id[c][i].devtype == 0x07) ||
-		    ((dev->id[c][i].devtype == 0x05) && ((n & 0x10) != 0))) {
+		if ((dev->id[c][i].devtype == 0x00) || (dev->id[c][i].devtype == 0x07) || ((dev->id[c][i].devtype == 0x05) && ((n & 0x10) != 0))) {
 			m = 1;
 			m = m << i;
 			if ((dev->async[c] & m) != 0) {
-			   goto set_sync;
+				goto set_sync;
 			}
 		}
 		continue;
 set_sync:
 		if (dev->sp[c][i] == 0x02) {
-		   synu[4]=0x0c;
-		   synuw[4]=0x0c;
+			synu[4] = 0x0c;
+			synuw[4] = 0x0c;
 		} else {
-		   if (dev->sp[c][i] >= 0x03) {
-		      synu[4]=0x0a;
-		      synuw[4]=0x0a;
-		   }
+			if (dev->sp[c][i] >= 0x03) {
+				synu[4] = 0x0a;
+				synuw[4] = 0x0a;
+			}
 		}
 		j = 0;
 		if ((m & dev->wide_id[c]) != 0) {
@@ -3231,11 +3255,13 @@ static void is885(struct atp_unit *dev, unsigned char c)
 
 		while ((atp_readb_io(dev, c, 0x1f) & 0x80) == 0x00)
 			cpu_relax();
-		if ((atp_readb_io(dev, c, 0x17) != 0x11) && (atp_readb_io(dev, c, 0x17) != 0x8e)) {
+
+		if (atp_readb_io(dev, c, 0x17) != 0x11 && atp_readb_io(dev, c, 0x17) != 0x8e)
 			continue;
-		}
+
 		while (atp_readb_io(dev, c, 0x17) != 0x8e)
 			cpu_relax();
+
 try_sync:
 		j = 0;
 		atp_writeb_io(dev, c, 0x14, 0x06);
@@ -3258,8 +3284,10 @@ static void is885(struct atp_unit *dev, unsigned char c)
 				}
 			}
 		}
+
 		while ((atp_readb_io(dev, c, 0x17) & 0x80) == 0x00)
 			cpu_relax();
+
 		j = atp_readb_io(dev, c, 0x17) & 0x0f;
 		if (j == 0x0f) {
 			goto phase_ins;
@@ -3306,7 +3334,9 @@ static void is885(struct atp_unit *dev, unsigned char c)
 		if ((j & 0x80) == 0x00) {
 			goto phase_ins1;
 		}
+
 		while ((atp_readb_io(dev, c, 0x17) & 0x80) == 0x00);
+
 		j = atp_readb_io(dev, c, 0x17);
 		if (j == 0x85) {
 			goto tar_dcons;
@@ -3327,8 +3357,10 @@ static void is885(struct atp_unit *dev, unsigned char c)
 tar_dcons:
 		atp_writeb_io(dev, c, 0x14, 0x00);
 		atp_writeb_io(dev, c, 0x18, 0x08);
+
 		while ((atp_readb_io(dev, c, 0x1f) & 0x80) == 0x00)
 			cpu_relax();
+
 		j = atp_readb_io(dev, c, 0x17);
 		if (j != 0x16) {
 			continue;
@@ -3349,7 +3381,7 @@ static void is885(struct atp_unit *dev, unsigned char c)
 			mbuf[4] = 0x0e;
 		}
 		dev->id[c][i].devsp = mbuf[4];
-		if (mbuf[3] < 0x0c){
+		if (mbuf[3] < 0x0c) {
 			j = 0xb0;
 			goto set_syn_ok;
 		}
@@ -3370,9 +3402,9 @@ static void is885(struct atp_unit *dev, unsigned char c)
 			goto set_syn_ok;
 		}
 		j = 0x60;
-	      set_syn_ok:
+set_syn_ok:
 		dev->id[c][i].devsp = (dev->id[c][i].devsp & 0x0f) | j;
-#ifdef ED_DBGP		
+#ifdef ED_DBGP
 		printk("dev->id[%2d][%2d].devsp = %2x\n",c,i,dev->id[c][i].devsp);
 #endif
 	}

commit 5d2a5a4f86616587a37e0c50dbef359d3078d9f5
Author: Ondrej Zary <linux@rainbow-software.org>
Date:   Tue Nov 17 19:23:57 2015 +0100

    atp870u: Convert is885() to use wrappers
    
    Signed-off-by: Ondrej Zary <linux@rainbow-software.org>
    Reviewed-by: Hannes Reinicke <hare@suse.de>
    Acked-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/atp870u.c b/drivers/scsi/atp870u.c
index 1b9276f61850..ad7af547fc90 100644
--- a/drivers/scsi/atp870u.c
+++ b/drivers/scsi/atp870u.c
@@ -41,7 +41,7 @@
 
 static struct scsi_host_template atp870u_template;
 static void send_s870(struct atp_unit *dev,unsigned char c);
-static void is885(struct atp_unit *dev, unsigned int wkport,unsigned char c);
+static void is885(struct atp_unit *dev, unsigned char c);
 static void tscam_885(void);
 
 static inline void atp_writeb_base(struct atp_unit *atp, u8 reg, u8 val)
@@ -2521,9 +2521,9 @@ static int atp870u_probe(struct pci_dev *pdev, const struct pci_device_id *ent)
 
 		tscam_885();
 		printk(KERN_INFO "   Scanning Channel A SCSI Device ...\n");
-		is885(p, base_io + 0x80, 0);
+		is885(p, 0);
 		printk(KERN_INFO "   Scanning Channel B SCSI Device ...\n");
-		is885(p, base_io + 0xc0, 1);
+		is885(p, 1);
 
 		k = inb(base_io + 0x28) & 0xcf;
 		k |= 0xc0;
@@ -2825,7 +2825,7 @@ static void tscam_885(void)
 
 
 
-static void is885(struct atp_unit *dev, unsigned int wkport,unsigned char c)
+static void is885(struct atp_unit *dev, unsigned char c)
 {
 	unsigned char i, j, k, rmb, n, lvdmode;
 	unsigned short int m;
@@ -2839,7 +2839,7 @@ static void is885(struct atp_unit *dev, unsigned int wkport,unsigned char c)
 	static unsigned char wide[6] =	{0x80, 1, 2, 3, 1, 0};
 	static unsigned char u3[9] = { 0x80,1,6,4,0x09,00,0x0e,0x01,0x02 };
 
-	lvdmode=inb(wkport + 0x1b) >> 7;
+	lvdmode=atp_readb_io(dev, c, 0x1b) >> 7;
 
 	for (i = 0; i < 16; i++) {
 		m = 1;
@@ -2851,93 +2851,93 @@ static void is885(struct atp_unit *dev, unsigned int wkport,unsigned char c)
 			printk(KERN_INFO "         ID: %2d  Host Adapter\n", dev->host_id[c]);
 			continue;
 		}
-		outb(0x01, wkport + 0x1b);
-		outb(0x08, wkport + 0x01);
-		outb(0x7f, wkport + 0x02);
-		outb(satn[0], wkport + 0x03);
-		outb(satn[1], wkport + 0x04);
-		outb(satn[2], wkport + 0x05);
-		outb(satn[3], wkport + 0x06);
-		outb(satn[4], wkport + 0x07);
-		outb(satn[5], wkport + 0x08);
-		outb(0, wkport + 0x0f);
-		outb(dev->id[c][i].devsp, wkport + 0x11);
+		atp_writeb_io(dev, c, 0x1b, 0x01);
+		atp_writeb_io(dev, c, 1, 0x08);
+		atp_writeb_io(dev, c, 2, 0x7f);
+		atp_writeb_io(dev, c, 3, satn[0]);
+		atp_writeb_io(dev, c, 4, satn[1]);
+		atp_writeb_io(dev, c, 5, satn[2]);
+		atp_writeb_io(dev, c, 6, satn[3]);
+		atp_writeb_io(dev, c, 7, satn[4]);
+		atp_writeb_io(dev, c, 8, satn[5]);
+		atp_writeb_io(dev, c, 0x0f, 0);
+		atp_writeb_io(dev, c, 0x11, dev->id[c][i].devsp);
 		
-		outb(0, wkport + 0x12);
-		outb(satn[6], wkport + 0x13);
-		outb(satn[7], wkport + 0x14);
+		atp_writeb_io(dev, c, 0x12, 0);
+		atp_writeb_io(dev, c, 0x13, satn[6]);
+		atp_writeb_io(dev, c, 0x14, satn[7]);
 		j = i;
 		if ((j & 0x08) != 0) {
 			j = (j & 0x07) | 0x40;
 		}
-		outb(j, wkport + 0x15);
-		outb(satn[8], wkport + 0x18);
+		atp_writeb_io(dev, c, 0x15, j);
+		atp_writeb_io(dev, c, 0x18, satn[8]);
 
-		while ((inb(wkport + 0x1f) & 0x80) == 0x00)
+		while ((atp_readb_io(dev, c, 0x1f) & 0x80) == 0x00)
 			cpu_relax();
-		if ((inb(wkport + 0x17) != 0x11) && (inb(wkport + 0x17) != 0x8e)) {
+		if ((atp_readb_io(dev, c, 0x17) != 0x11) && (atp_readb_io(dev, c, 0x17) != 0x8e)) {
 			continue;
 		}
-		while (inb(wkport + 0x17) != 0x8e)
+		while (atp_readb_io(dev, c, 0x17) != 0x8e)
 			cpu_relax();
 		dev->active_id[c] |= m;
 
-		outb(0x30, wkport + 0x10);
-		outb(0x00, wkport + 0x14);
+		atp_writeb_io(dev, c, 0x10, 0x30);
+		atp_writeb_io(dev, c, 0x14, 0x00);
 
 phase_cmd:
-		outb(0x08, wkport + 0x18);
-		while ((inb(wkport + 0x1f) & 0x80) == 0x00)
+		atp_writeb_io(dev, c, 0x18, 0x08);
+		while ((atp_readb_io(dev, c, 0x1f) & 0x80) == 0x00)
 			cpu_relax();
-		j = inb(wkport + 0x17);
+		j = atp_readb_io(dev, c, 0x17);
 		if (j != 0x16) {
-			outb(0x41, wkport + 0x10);
+			atp_writeb_io(dev, c, 0x10, 0x41);
 			goto phase_cmd;
 		}
 sel_ok:
-		outb(inqd[0], wkport + 0x03);
-		outb(inqd[1], wkport + 0x04);
-		outb(inqd[2], wkport + 0x05);
-		outb(inqd[3], wkport + 0x06);
-		outb(inqd[4], wkport + 0x07);
-		outb(inqd[5], wkport + 0x08);
-		outb(0, wkport + 0x0f);
-		outb(dev->id[c][i].devsp, wkport + 0x11);
-		outb(0, wkport + 0x12);
-		outb(inqd[6], wkport + 0x13);
-		outb(inqd[7], wkport + 0x14);
-		outb(inqd[8], wkport + 0x18);
-		while ((inb(wkport + 0x1f) & 0x80) == 0x00)
+		atp_writeb_io(dev, c, 3, inqd[0]);
+		atp_writeb_io(dev, c, 4, inqd[1]);
+		atp_writeb_io(dev, c, 5, inqd[2]);
+		atp_writeb_io(dev, c, 6, inqd[3]);
+		atp_writeb_io(dev, c, 7, inqd[4]);
+		atp_writeb_io(dev, c, 8, inqd[5]);
+		atp_writeb_io(dev, c, 0x0f, 0);
+		atp_writeb_io(dev, c, 0x11, dev->id[c][i].devsp);
+		atp_writeb_io(dev, c, 0x12, 0);
+		atp_writeb_io(dev, c, 0x13, inqd[6]);
+		atp_writeb_io(dev, c, 0x14, inqd[7]);
+		atp_writeb_io(dev, c, 0x18, inqd[8]);
+		while ((atp_readb_io(dev, c, 0x1f) & 0x80) == 0x00)
 			cpu_relax();
-		if ((inb(wkport + 0x17) != 0x11) && (inb(wkport + 0x17) != 0x8e)) {
+		if ((atp_readb_io(dev, c, 0x17) != 0x11) && (atp_readb_io(dev, c, 0x17) != 0x8e)) {
 			continue;
 		}
-		while (inb(wkport + 0x17) != 0x8e)
+		while (atp_readb_io(dev, c, 0x17) != 0x8e)
 			cpu_relax();
-		outb(0x00, wkport + 0x1b);
-		outb(0x08, wkport + 0x18);
+		atp_writeb_io(dev, c, 0x1b, 0x00);
+		atp_writeb_io(dev, c, 0x18, 0x08);
 		j = 0;
 rd_inq_data:
-		k = inb(wkport + 0x1f);
+		k = atp_readb_io(dev, c, 0x1f);
 		if ((k & 0x01) != 0) {
-			mbuf[j++] = inb(wkport + 0x19);
+			mbuf[j++] = atp_readb_io(dev, c, 0x19);
 			goto rd_inq_data;
 		}
 		if ((k & 0x80) == 0) {
 			goto rd_inq_data;
 		}
-		j = inb(wkport + 0x17);
+		j = atp_readb_io(dev, c, 0x17);
 		if (j == 0x16) {
 			goto inq_ok;
 		}
-		outb(0x46, wkport + 0x10);
-		outb(0, wkport + 0x12);
-		outb(0, wkport + 0x13);
-		outb(0, wkport + 0x14);
-		outb(0x08, wkport + 0x18);
-		while ((inb(wkport + 0x1f) & 0x80) == 0x00)
+		atp_writeb_io(dev, c, 0x10, 0x46);
+		atp_writeb_io(dev, c, 0x12, 0);
+		atp_writeb_io(dev, c, 0x13, 0);
+		atp_writeb_io(dev, c, 0x14, 0);
+		atp_writeb_io(dev, c, 0x18, 0x08);
+		while ((atp_readb_io(dev, c, 0x1f) & 0x80) == 0x00)
 			cpu_relax();
-		if (inb(wkport + 0x17) != 0x16) {
+		if (atp_readb_io(dev, c, 0x17) != 0x16) {
 			goto sel_ok;
 		}
 inq_ok:
@@ -2959,40 +2959,40 @@ static void is885(struct atp_unit *dev, unsigned int wkport,unsigned char c)
 		   goto chg_wide;
 		}
 
-		outb(0x01, wkport + 0x1b);
-		outb(satn[0], wkport + 0x03);
-		outb(satn[1], wkport + 0x04);
-		outb(satn[2], wkport + 0x05);
-		outb(satn[3], wkport + 0x06);
-		outb(satn[4], wkport + 0x07);
-		outb(satn[5], wkport + 0x08);
-		outb(0, wkport + 0x0f);
-		outb(dev->id[c][i].devsp, wkport + 0x11);
-		outb(0, wkport + 0x12);
-		outb(satn[6], wkport + 0x13);
-		outb(satn[7], wkport + 0x14);
-		outb(satn[8], wkport + 0x18);
-
-		while ((inb(wkport + 0x1f) & 0x80) == 0x00)
+		atp_writeb_io(dev, c, 0x1b, 0x01);
+		atp_writeb_io(dev, c, 3, satn[0]);
+		atp_writeb_io(dev, c, 4, satn[1]);
+		atp_writeb_io(dev, c, 5, satn[2]);
+		atp_writeb_io(dev, c, 6, satn[3]);
+		atp_writeb_io(dev, c, 7, satn[4]);
+		atp_writeb_io(dev, c, 8, satn[5]);
+		atp_writeb_io(dev, c, 0x0f, 0);
+		atp_writeb_io(dev, c, 0x11, dev->id[c][i].devsp);
+		atp_writeb_io(dev, c, 0x12, 0);
+		atp_writeb_io(dev, c, 0x13, satn[6]);
+		atp_writeb_io(dev, c, 0x14, satn[7]);
+		atp_writeb_io(dev, c, 0x18, satn[8]);
+
+		while ((atp_readb_io(dev, c, 0x1f) & 0x80) == 0x00)
 			cpu_relax();
-		if ((inb(wkport + 0x17) != 0x11) && (inb(wkport + 0x17) != 0x8e)) {
+		if ((atp_readb_io(dev, c, 0x17) != 0x11) && (atp_readb_io(dev, c, 0x17) != 0x8e)) {
 			continue;
 		}
-		while (inb(wkport + 0x17) != 0x8e)
+		while (atp_readb_io(dev, c, 0x17) != 0x8e)
 			cpu_relax();
 try_u3:
 		j = 0;
-		outb(0x09, wkport + 0x14);
-		outb(0x20, wkport + 0x18);
+		atp_writeb_io(dev, c, 0x14, 0x09);
+		atp_writeb_io(dev, c, 0x18, 0x20);
 
-		while ((inb(wkport + 0x1f) & 0x80) == 0) {
-			if ((inb(wkport + 0x1f) & 0x01) != 0)
-				outb(u3[j++], wkport + 0x19);
+		while ((atp_readb_io(dev, c, 0x1f) & 0x80) == 0) {
+			if ((atp_readb_io(dev, c, 0x1f) & 0x01) != 0)
+				atp_writeb_io(dev, c, 0x19, u3[j++]);
 			cpu_relax();
 		}
-		while ((inb(wkport + 0x17) & 0x80) == 0x00)
+		while ((atp_readb_io(dev, c, 0x17) & 0x80) == 0x00)
 			cpu_relax();
-		j = inb(wkport + 0x17) & 0x0f;
+		j = atp_readb_io(dev, c, 0x17) & 0x0f;
 		if (j == 0x0f) {
 			goto u3p_in;
 		}
@@ -3004,13 +3004,13 @@ static void is885(struct atp_unit *dev, unsigned int wkport,unsigned char c)
 		}
 		continue;
 u3p_out:
-		outb(0x20, wkport + 0x18);
-		while ((inb(wkport + 0x1f) & 0x80) == 0) {
-			if ((inb(wkport + 0x1f) & 0x01) != 0)
-				outb(0, wkport + 0x19);
+		atp_writeb_io(dev, c, 0x18, 0x20);
+		while ((atp_readb_io(dev, c, 0x1f) & 0x80) == 0) {
+			if ((atp_readb_io(dev, c, 0x1f) & 0x01) != 0)
+				atp_writeb_io(dev, c, 0x19, 0);
 			cpu_relax();
 		}
-		j = inb(wkport + 0x17) & 0x0f;
+		j = atp_readb_io(dev, c, 0x17) & 0x0f;
 		if (j == 0x0f) {
 			goto u3p_in;
 		}
@@ -3022,19 +3022,19 @@ static void is885(struct atp_unit *dev, unsigned int wkport,unsigned char c)
 		}
 		continue;
 u3p_in:
-		outb(0x09, wkport + 0x14);
-		outb(0x20, wkport + 0x18);
+		atp_writeb_io(dev, c, 0x14, 0x09);
+		atp_writeb_io(dev, c, 0x18, 0x20);
 		k = 0;
 u3p_in1:
-		j = inb(wkport + 0x1f);
+		j = atp_readb_io(dev, c, 0x1f);
 		if ((j & 0x01) != 0) {
-			mbuf[k++] = inb(wkport + 0x19);
+			mbuf[k++] = atp_readb_io(dev, c, 0x19);
 			goto u3p_in1;
 		}
 		if ((j & 0x80) == 0x00) {
 			goto u3p_in1;
 		}
-		j = inb(wkport + 0x17) & 0x0f;
+		j = atp_readb_io(dev, c, 0x17) & 0x0f;
 		if (j == 0x0f) {
 			goto u3p_in;
 		}
@@ -3046,11 +3046,11 @@ static void is885(struct atp_unit *dev, unsigned int wkport,unsigned char c)
 		}
 		continue;
 u3p_cmd:
-		outb(0x30, wkport + 0x10);
-		outb(0x00, wkport + 0x14);
-		outb(0x08, wkport + 0x18);
-		while ((inb(wkport + 0x1f) & 0x80) == 0x00);
-		j = inb(wkport + 0x17);
+		atp_writeb_io(dev, c, 0x10, 0x30);
+		atp_writeb_io(dev, c, 0x14, 0x00);
+		atp_writeb_io(dev, c, 0x18, 0x08);
+		while ((atp_readb_io(dev, c, 0x1f) & 0x80) == 0x00);
+		j = atp_readb_io(dev, c, 0x17);
 		if (j != 0x16) {
 			if (j == 0x4e) {
 				goto u3p_out;
@@ -3077,40 +3077,40 @@ static void is885(struct atp_unit *dev, unsigned int wkport,unsigned char c)
 			continue;
 		}
 chg_wide:
-		outb(0x01, wkport + 0x1b);
-		outb(satn[0], wkport + 0x03);
-		outb(satn[1], wkport + 0x04);
-		outb(satn[2], wkport + 0x05);
-		outb(satn[3], wkport + 0x06);
-		outb(satn[4], wkport + 0x07);
-		outb(satn[5], wkport + 0x08);
-		outb(0, wkport + 0x0f);
-		outb(dev->id[c][i].devsp, wkport + 0x11);
-		outb(0, wkport + 0x12);
-		outb(satn[6], wkport + 0x13);
-		outb(satn[7], wkport + 0x14);
-		outb(satn[8], wkport + 0x18);
-
-		while ((inb(wkport + 0x1f) & 0x80) == 0x00)
+		atp_writeb_io(dev, c, 0x1b, 0x01);
+		atp_writeb_io(dev, c, 3, satn[0]);
+		atp_writeb_io(dev, c, 4, satn[1]);
+		atp_writeb_io(dev, c, 5, satn[2]);
+		atp_writeb_io(dev, c, 6, satn[3]);
+		atp_writeb_io(dev, c, 7, satn[4]);
+		atp_writeb_io(dev, c, 8, satn[5]);
+		atp_writeb_io(dev, c, 0x0f, 0);
+		atp_writeb_io(dev, c, 0x11, dev->id[c][i].devsp);
+		atp_writeb_io(dev, c, 0x12, 0);
+		atp_writeb_io(dev, c, 0x13, satn[6]);
+		atp_writeb_io(dev, c, 0x14, satn[7]);
+		atp_writeb_io(dev, c, 0x18, satn[8]);
+
+		while ((atp_readb_io(dev, c, 0x1f) & 0x80) == 0x00)
 			cpu_relax();
-		if ((inb(wkport + 0x17) != 0x11) && (inb(wkport + 0x17) != 0x8e)) {
+		if ((atp_readb_io(dev, c, 0x17) != 0x11) && (atp_readb_io(dev, c, 0x17) != 0x8e)) {
 			continue;
 		}
-		while (inb(wkport + 0x17) != 0x8e)
+		while (atp_readb_io(dev, c, 0x17) != 0x8e)
 			cpu_relax();
 try_wide:
 		j = 0;
-		outb(0x05, wkport + 0x14);
-		outb(0x20, wkport + 0x18);
+		atp_writeb_io(dev, c, 0x14, 0x05);
+		atp_writeb_io(dev, c, 0x18, 0x20);
 
-		while ((inb(wkport + 0x1f) & 0x80) == 0) {
-			if ((inb(wkport + 0x1f) & 0x01) != 0)
-				outb(wide[j++], wkport + 0x19);
+		while ((atp_readb_io(dev, c, 0x1f) & 0x80) == 0) {
+			if ((atp_readb_io(dev, c, 0x1f) & 0x01) != 0)
+				atp_writeb_io(dev, c, 0x19, wide[j++]);
 			cpu_relax();
 		}
-		while ((inb(wkport + 0x17) & 0x80) == 0x00)
+		while ((atp_readb_io(dev, c, 0x17) & 0x80) == 0x00)
 			cpu_relax();
-		j = inb(wkport + 0x17) & 0x0f;
+		j = atp_readb_io(dev, c, 0x17) & 0x0f;
 		if (j == 0x0f) {
 			goto widep_in;
 		}
@@ -3122,13 +3122,13 @@ static void is885(struct atp_unit *dev, unsigned int wkport,unsigned char c)
 		}
 		continue;
 widep_out:
-		outb(0x20, wkport + 0x18);
-		while ((inb(wkport + 0x1f) & 0x80) == 0) {
-			if ((inb(wkport + 0x1f) & 0x01) != 0)
-				outb(0, wkport + 0x19);
+		atp_writeb_io(dev, c, 0x18, 0x20);
+		while ((atp_readb_io(dev, c, 0x1f) & 0x80) == 0) {
+			if ((atp_readb_io(dev, c, 0x1f) & 0x01) != 0)
+				atp_writeb_io(dev, c, 0x19, 0);
 			cpu_relax();
 		}
-		j = inb(wkport + 0x17) & 0x0f;
+		j = atp_readb_io(dev, c, 0x17) & 0x0f;
 		if (j == 0x0f) {
 			goto widep_in;
 		}
@@ -3140,19 +3140,19 @@ static void is885(struct atp_unit *dev, unsigned int wkport,unsigned char c)
 		}
 		continue;
 widep_in:
-		outb(0xff, wkport + 0x14);
-		outb(0x20, wkport + 0x18);
+		atp_writeb_io(dev, c, 0x14, 0xff);
+		atp_writeb_io(dev, c, 0x18, 0x20);
 		k = 0;
 widep_in1:
-		j = inb(wkport + 0x1f);
+		j = atp_readb_io(dev, c, 0x1f);
 		if ((j & 0x01) != 0) {
-			mbuf[k++] = inb(wkport + 0x19);
+			mbuf[k++] = atp_readb_io(dev, c, 0x19);
 			goto widep_in1;
 		}
 		if ((j & 0x80) == 0x00) {
 			goto widep_in1;
 		}
-		j = inb(wkport + 0x17) & 0x0f;
+		j = atp_readb_io(dev, c, 0x17) & 0x0f;
 		if (j == 0x0f) {
 			goto widep_in;
 		}
@@ -3164,12 +3164,12 @@ static void is885(struct atp_unit *dev, unsigned int wkport,unsigned char c)
 		}
 		continue;
 widep_cmd:
-		outb(0x30, wkport + 0x10);
-		outb(0x00, wkport + 0x14);
-		outb(0x08, wkport + 0x18);
-		while ((inb(wkport + 0x1f) & 0x80) == 0x00)
+		atp_writeb_io(dev, c, 0x10, 0x30);
+		atp_writeb_io(dev, c, 0x14, 0x00);
+		atp_writeb_io(dev, c, 0x18, 0x08);
+		while ((atp_readb_io(dev, c, 0x1f) & 0x80) == 0x00)
 			cpu_relax();
-		j = inb(wkport + 0x17);
+		j = atp_readb_io(dev, c, 0x17);
 		if (j != 0x16) {
 			if (j == 0x4e) {
 				goto widep_out;
@@ -3215,52 +3215,52 @@ static void is885(struct atp_unit *dev, unsigned int wkport,unsigned char c)
 		if ((m & dev->wide_id[c]) != 0) {
 			j |= 0x01;
 		}
-		outb(j, wkport + 0x1b);
-		outb(satn[0], wkport + 0x03);
-		outb(satn[1], wkport + 0x04);
-		outb(satn[2], wkport + 0x05);
-		outb(satn[3], wkport + 0x06);
-		outb(satn[4], wkport + 0x07);
-		outb(satn[5], wkport + 0x08);
-		outb(0, wkport + 0x0f);
-		outb(dev->id[c][i].devsp, wkport + 0x11);
-		outb(0, wkport + 0x12);
-		outb(satn[6], wkport + 0x13);
-		outb(satn[7], wkport + 0x14);
-		outb(satn[8], wkport + 0x18);
-
-		while ((inb(wkport + 0x1f) & 0x80) == 0x00)
+		atp_writeb_io(dev, c, 0x1b, j);
+		atp_writeb_io(dev, c, 3, satn[0]);
+		atp_writeb_io(dev, c, 4, satn[1]);
+		atp_writeb_io(dev, c, 5, satn[2]);
+		atp_writeb_io(dev, c, 6, satn[3]);
+		atp_writeb_io(dev, c, 7, satn[4]);
+		atp_writeb_io(dev, c, 8, satn[5]);
+		atp_writeb_io(dev, c, 0x0f, 0);
+		atp_writeb_io(dev, c, 0x11, dev->id[c][i].devsp);
+		atp_writeb_io(dev, c, 0x12, 0);
+		atp_writeb_io(dev, c, 0x13, satn[6]);
+		atp_writeb_io(dev, c, 0x14, satn[7]);
+		atp_writeb_io(dev, c, 0x18, satn[8]);
+
+		while ((atp_readb_io(dev, c, 0x1f) & 0x80) == 0x00)
 			cpu_relax();
-		if ((inb(wkport + 0x17) != 0x11) && (inb(wkport + 0x17) != 0x8e)) {
+		if ((atp_readb_io(dev, c, 0x17) != 0x11) && (atp_readb_io(dev, c, 0x17) != 0x8e)) {
 			continue;
 		}
-		while (inb(wkport + 0x17) != 0x8e)
+		while (atp_readb_io(dev, c, 0x17) != 0x8e)
 			cpu_relax();
 try_sync:
 		j = 0;
-		outb(0x06, wkport + 0x14);
-		outb(0x20, wkport + 0x18);
+		atp_writeb_io(dev, c, 0x14, 0x06);
+		atp_writeb_io(dev, c, 0x18, 0x20);
 
-		while ((inb(wkport + 0x1f) & 0x80) == 0) {
-			if ((inb(wkport + 0x1f) & 0x01) != 0) {
+		while ((atp_readb_io(dev, c, 0x1f) & 0x80) == 0) {
+			if ((atp_readb_io(dev, c, 0x1f) & 0x01) != 0) {
 				if ((m & dev->wide_id[c]) != 0) {
 					if ((m & dev->ultra_map[c]) != 0) {
-						outb(synuw[j++], wkport + 0x19);
+						atp_writeb_io(dev, c, 0x19, synuw[j++]);
 					} else {
-						outb(synw[j++], wkport + 0x19);
+						atp_writeb_io(dev, c, 0x19, synw[j++]);
 					}
 				} else {
 					if ((m & dev->ultra_map[c]) != 0) {
-						outb(synu[j++], wkport + 0x19);
+						atp_writeb_io(dev, c, 0x19, synu[j++]);
 					} else {
-						outb(synn[j++], wkport + 0x19);
+						atp_writeb_io(dev, c, 0x19, synn[j++]);
 					}
 				}
 			}
 		}
-		while ((inb(wkport + 0x17) & 0x80) == 0x00)
+		while ((atp_readb_io(dev, c, 0x17) & 0x80) == 0x00)
 			cpu_relax();
-		j = inb(wkport + 0x17) & 0x0f;
+		j = atp_readb_io(dev, c, 0x17) & 0x0f;
 		if (j == 0x0f) {
 			goto phase_ins;
 		}
@@ -3272,13 +3272,13 @@ static void is885(struct atp_unit *dev, unsigned int wkport,unsigned char c)
 		}
 		continue;
 phase_outs:
-		outb(0x20, wkport + 0x18);
-		while ((inb(wkport + 0x1f) & 0x80) == 0x00) {
-			if ((inb(wkport + 0x1f) & 0x01) != 0x00)
-				outb(0x00, wkport + 0x19);
+		atp_writeb_io(dev, c, 0x18, 0x20);
+		while ((atp_readb_io(dev, c, 0x1f) & 0x80) == 0x00) {
+			if ((atp_readb_io(dev, c, 0x1f) & 0x01) != 0x00)
+				atp_writeb_io(dev, c, 0x19, 0x00);
 			cpu_relax();
 		}
-		j = inb(wkport + 0x17);
+		j = atp_readb_io(dev, c, 0x17);
 		if (j == 0x85) {
 			goto tar_dcons;
 		}
@@ -3294,20 +3294,20 @@ static void is885(struct atp_unit *dev, unsigned int wkport,unsigned char c)
 		}
 		continue;
 phase_ins:
-		outb(0x06, wkport + 0x14);
-		outb(0x20, wkport + 0x18);
+		atp_writeb_io(dev, c, 0x14, 0x06);
+		atp_writeb_io(dev, c, 0x18, 0x20);
 		k = 0;
 phase_ins1:
-		j = inb(wkport + 0x1f);
+		j = atp_readb_io(dev, c, 0x1f);
 		if ((j & 0x01) != 0x00) {
-			mbuf[k++] = inb(wkport + 0x19);
+			mbuf[k++] = atp_readb_io(dev, c, 0x19);
 			goto phase_ins1;
 		}
 		if ((j & 0x80) == 0x00) {
 			goto phase_ins1;
 		}
-		while ((inb(wkport + 0x17) & 0x80) == 0x00);
-		j = inb(wkport + 0x17);
+		while ((atp_readb_io(dev, c, 0x17) & 0x80) == 0x00);
+		j = atp_readb_io(dev, c, 0x17);
 		if (j == 0x85) {
 			goto tar_dcons;
 		}
@@ -3323,13 +3323,13 @@ static void is885(struct atp_unit *dev, unsigned int wkport,unsigned char c)
 		}
 		continue;
 phase_cmds:
-		outb(0x30, wkport + 0x10);
+		atp_writeb_io(dev, c, 0x10, 0x30);
 tar_dcons:
-		outb(0x00, wkport + 0x14);
-		outb(0x08, wkport + 0x18);
-		while ((inb(wkport + 0x1f) & 0x80) == 0x00)
+		atp_writeb_io(dev, c, 0x14, 0x00);
+		atp_writeb_io(dev, c, 0x18, 0x08);
+		while ((atp_readb_io(dev, c, 0x1f) & 0x80) == 0x00)
 			cpu_relax();
-		j = inb(wkport + 0x17);
+		j = atp_readb_io(dev, c, 0x17);
 		if (j != 0x16) {
 			continue;
 		}
@@ -3376,7 +3376,7 @@ static void is885(struct atp_unit *dev, unsigned int wkport,unsigned char c)
 		printk("dev->id[%2d][%2d].devsp = %2x\n",c,i,dev->id[c][i].devsp);
 #endif
 	}
-	outb(0x80, wkport + 0x16);
+	atp_writeb_io(dev, c, 0x16, 0x80);
 }
 
 module_init(atp870u_init);

commit 485025606b5bbd1024c9b2781fb8909afbd1a64d
Author: Ondrej Zary <linux@rainbow-software.org>
Date:   Tue Nov 17 19:23:56 2015 +0100

    atp870u: Convert is880() to use wrappers
    
    Subtract 0x40 to use _io access wrappers.  Now it's obvious that is870()
    and is880() are very similar.
    
    Signed-off-by: Ondrej Zary <linux@rainbow-software.org>
    Reviewed-by: Hannes Reinicke <hare@suse.de>
    Acked-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/atp870u.c b/drivers/scsi/atp870u.c
index 305eda807e11..1b9276f61850 100644
--- a/drivers/scsi/atp870u.c
+++ b/drivers/scsi/atp870u.c
@@ -1594,7 +1594,7 @@ static void is870(struct atp_unit *dev)
 	atp_writeb_io(dev, 0, 0x3a, atp_readb_io(dev, 0, 0x3a) & 0xef);
 }
 
-static void is880(struct atp_unit *dev, unsigned int wkport)
+static void is880(struct atp_unit *dev)
 {
 	unsigned char i, j, k, rmb, n, lvdmode;
 	unsigned short int m;
@@ -1608,7 +1608,7 @@ static void is880(struct atp_unit *dev, unsigned int wkport)
 	static unsigned char wide[6] = { 0x80, 1, 2, 3, 1, 0 };
 	static unsigned char u3[9] = { 0x80, 1, 6, 4, 0x09, 00, 0x0e, 0x01, 0x02 };
 
-	lvdmode = inb(wkport + 0x3f) & 0x40;
+	lvdmode = atp_readb_base(dev, 0x3f) & 0x40;
 
 	for (i = 0; i < 16; i++) {
 		m = 1;
@@ -1620,100 +1620,100 @@ static void is880(struct atp_unit *dev, unsigned int wkport)
 			printk(KERN_INFO "         ID: %2d  Host Adapter\n", dev->host_id[0]);
 			continue;
 		}
-		outb(0x01, wkport + 0x5b);
-		outb(0x08, wkport + 0x41);
-		outb(0x7f, wkport + 0x42);
-		outb(satn[0], wkport + 0x43);
-		outb(satn[1], wkport + 0x44);
-		outb(satn[2], wkport + 0x45);
-		outb(satn[3], wkport + 0x46);
-		outb(satn[4], wkport + 0x47);
-		outb(satn[5], wkport + 0x48);
-		outb(0, wkport + 0x4f);
-		outb(dev->id[0][i].devsp, wkport + 0x51);
-		outb(0, wkport + 0x52);
-		outb(satn[6], wkport + 0x53);
-		outb(satn[7], wkport + 0x54);
+		atp_writeb_io(dev, 0, 0x1b, 0x01);
+		atp_writeb_io(dev, 0, 1, 0x08);
+		atp_writeb_io(dev, 0, 2, 0x7f);
+		atp_writeb_io(dev, 0, 3, satn[0]);
+		atp_writeb_io(dev, 0, 4, satn[1]);
+		atp_writeb_io(dev, 0, 5, satn[2]);
+		atp_writeb_io(dev, 0, 6, satn[3]);
+		atp_writeb_io(dev, 0, 7, satn[4]);
+		atp_writeb_io(dev, 0, 8, satn[5]);
+		atp_writeb_io(dev, 0, 0x0f, 0);
+		atp_writeb_io(dev, 0, 0x11, dev->id[0][i].devsp);
+		atp_writeb_io(dev, 0, 0x12, 0);
+		atp_writeb_io(dev, 0, 0x13, satn[6]);
+		atp_writeb_io(dev, 0, 0x14, satn[7]);
 		j = i;
 		if ((j & 0x08) != 0) {
 			j = (j & 0x07) | 0x40;
 		}
-		outb(j, wkport + 0x55);
-		outb(satn[8], wkport + 0x58);
+		atp_writeb_io(dev, 0, 0x15, j);
+		atp_writeb_io(dev, 0, 0x18, satn[8]);
 
-		while ((inb(wkport + 0x5f) & 0x80) == 0x00)
+		while ((atp_readb_io(dev, 0, 0x1f) & 0x80) == 0x00)
 			cpu_relax();
 
-		if (inb(wkport + 0x57) != 0x11 && inb(wkport + 0x57) != 0x8e)
+		if (atp_readb_io(dev, 0, 0x17) != 0x11 && atp_readb_io(dev, 0, 0x17) != 0x8e)
 			continue;
 
-		while (inb(wkport + 0x57) != 0x8e)
+		while (atp_readb_io(dev, 0, 0x17) != 0x8e)
 			cpu_relax();
 			
 		dev->active_id[0] |= m;
 
-		outb(0x30, wkport + 0x50);
-		outb(0x00, wkport + 0x54);
+		atp_writeb_io(dev, 0, 0x10, 0x30);
+		atp_writeb_io(dev, 0, 0x14, 0x00);
 
 phase_cmd:
-		outb(0x08, wkport + 0x58);
+		atp_writeb_io(dev, 0, 0x18, 0x08);
 		
-		while ((inb(wkport + 0x5f) & 0x80) == 0x00)
+		while ((atp_readb_io(dev, 0, 0x1f) & 0x80) == 0x00)
 			cpu_relax();
 
-		j = inb(wkport + 0x57);
+		j = atp_readb_io(dev, 0, 0x17);
 		if (j != 0x16) {
-			outb(0x41, wkport + 0x50);
+			atp_writeb_io(dev, 0, 0x10, 0x41);
 			goto phase_cmd;
 		}
 sel_ok:
-		outb(inqd[0], wkport + 0x43);
-		outb(inqd[1], wkport + 0x44);
-		outb(inqd[2], wkport + 0x45);
-		outb(inqd[3], wkport + 0x46);
-		outb(inqd[4], wkport + 0x47);
-		outb(inqd[5], wkport + 0x48);
-		outb(0, wkport + 0x4f);
-		outb(dev->id[0][i].devsp, wkport + 0x51);
-		outb(0, wkport + 0x52);
-		outb(inqd[6], wkport + 0x53);
-		outb(inqd[7], wkport + 0x54);
-		outb(inqd[8], wkport + 0x58);
+		atp_writeb_io(dev, 0, 3, inqd[0]);
+		atp_writeb_io(dev, 0, 4, inqd[1]);
+		atp_writeb_io(dev, 0, 5, inqd[2]);
+		atp_writeb_io(dev, 0, 6, inqd[3]);
+		atp_writeb_io(dev, 0, 7, inqd[4]);
+		atp_writeb_io(dev, 0, 8, inqd[5]);
+		atp_writeb_io(dev, 0, 0x0f, 0);
+		atp_writeb_io(dev, 0, 0x11, dev->id[0][i].devsp);
+		atp_writeb_io(dev, 0, 0x12, 0);
+		atp_writeb_io(dev, 0, 0x13, inqd[6]);
+		atp_writeb_io(dev, 0, 0x14, inqd[7]);
+		atp_writeb_io(dev, 0, 0x18, inqd[8]);
 		
-		while ((inb(wkport + 0x5f) & 0x80) == 0x00)
+		while ((atp_readb_io(dev, 0, 0x1f) & 0x80) == 0x00)
 			cpu_relax();
 			
-		if (inb(wkport + 0x57) != 0x11 && inb(wkport + 0x57) != 0x8e)
+		if (atp_readb_io(dev, 0, 0x17) != 0x11 && atp_readb_io(dev, 0, 0x17) != 0x8e)
 			continue;
 
-		while (inb(wkport + 0x57) != 0x8e)
+		while (atp_readb_io(dev, 0, 0x17) != 0x8e)
 			cpu_relax();
 			
-		outb(0x00, wkport + 0x5b);
-		outb(0x08, wkport + 0x58);
+		atp_writeb_io(dev, 0, 0x1b, 0x00);
+		atp_writeb_io(dev, 0, 0x18, 0x08);
 		j = 0;
 rd_inq_data:
-		k = inb(wkport + 0x5f);
+		k = atp_readb_io(dev, 0, 0x1f);
 		if ((k & 0x01) != 0) {
-			mbuf[j++] = inb(wkport + 0x59);
+			mbuf[j++] = atp_readb_io(dev, 0, 0x19);
 			goto rd_inq_data;
 		}
 		if ((k & 0x80) == 0) {
 			goto rd_inq_data;
 		}
-		j = inb(wkport + 0x57);
+		j = atp_readb_io(dev, 0, 0x17);
 		if (j == 0x16) {
 			goto inq_ok;
 		}
-		outb(0x46, wkport + 0x50);
-		outb(0, wkport + 0x52);
-		outb(0, wkport + 0x53);
-		outb(0, wkport + 0x54);
-		outb(0x08, wkport + 0x58);
-		while ((inb(wkport + 0x5f) & 0x80) == 0x00)
+		atp_writeb_io(dev, 0, 0x10, 0x46);
+		atp_writeb_io(dev, 0, 0x12, 0);
+		atp_writeb_io(dev, 0, 0x13, 0);
+		atp_writeb_io(dev, 0, 0x14, 0);
+		atp_writeb_io(dev, 0, 0x18, 0x08);
+		while ((atp_readb_io(dev, 0, 0x1f) & 0x80) == 0x00)
 			cpu_relax();
 			
-		if (inb(wkport + 0x57) != 0x16)
+		if (atp_readb_io(dev, 0, 0x17) != 0x16)
 			goto sel_ok;
 
 inq_ok:
@@ -1736,43 +1736,43 @@ static void is880(struct atp_unit *dev, unsigned int wkport)
 			goto chg_wide;
 		}
 
-		outb(0x01, wkport + 0x5b);
-		outb(satn[0], wkport + 0x43);
-		outb(satn[1], wkport + 0x44);
-		outb(satn[2], wkport + 0x45);
-		outb(satn[3], wkport + 0x46);
-		outb(satn[4], wkport + 0x47);
-		outb(satn[5], wkport + 0x48);
-		outb(0, wkport + 0x4f);
-		outb(dev->id[0][i].devsp, wkport + 0x51);
-		outb(0, wkport + 0x52);
-		outb(satn[6], wkport + 0x53);
-		outb(satn[7], wkport + 0x54);
-		outb(satn[8], wkport + 0x58);
-
-		while ((inb(wkport + 0x5f) & 0x80) == 0x00)
+		atp_writeb_io(dev, 0, 0x1b, 0x01);
+		atp_writeb_io(dev, 0, 3, satn[0]);
+		atp_writeb_io(dev, 0, 4, satn[1]);
+		atp_writeb_io(dev, 0, 5, satn[2]);
+		atp_writeb_io(dev, 0, 6, satn[3]);
+		atp_writeb_io(dev, 0, 7, satn[4]);
+		atp_writeb_io(dev, 0, 8, satn[5]);
+		atp_writeb_io(dev, 0, 0x0f, 0);
+		atp_writeb_io(dev, 0, 0x11, dev->id[0][i].devsp);
+		atp_writeb_io(dev, 0, 0x12, 0);
+		atp_writeb_io(dev, 0, 0x13, satn[6]);
+		atp_writeb_io(dev, 0, 0x14, satn[7]);
+		atp_writeb_io(dev, 0, 0x18, satn[8]);
+
+		while ((atp_readb_io(dev, 0, 0x1f) & 0x80) == 0x00)
 			cpu_relax();
 
-		if (inb(wkport + 0x57) != 0x11 && inb(wkport + 0x57) != 0x8e)
+		if (atp_readb_io(dev, 0, 0x17) != 0x11 && atp_readb_io(dev, 0, 0x17) != 0x8e)
 			continue;
 
-		while (inb(wkport + 0x57) != 0x8e)
+		while (atp_readb_io(dev, 0, 0x17) != 0x8e)
 			cpu_relax();
 
 try_u3:
 		j = 0;
-		outb(0x09, wkport + 0x54);
-		outb(0x20, wkport + 0x58);
+		atp_writeb_io(dev, 0, 0x14, 0x09);
+		atp_writeb_io(dev, 0, 0x18, 0x20);
 
-		while ((inb(wkport + 0x5f) & 0x80) == 0) {
-			if ((inb(wkport + 0x5f) & 0x01) != 0)
-				outb(u3[j++], wkport + 0x59);
+		while ((atp_readb_io(dev, 0, 0x1f) & 0x80) == 0) {
+			if ((atp_readb_io(dev, 0, 0x1f) & 0x01) != 0)
+				atp_writeb_io(dev, 0, 0x19, u3[j++]);
 		}
 
-		while ((inb(wkport + 0x57) & 0x80) == 0x00)
+		while ((atp_readb_io(dev, 0, 0x17) & 0x80) == 0x00)
 			cpu_relax();
 			
-		j = inb(wkport + 0x57) & 0x0f;
+		j = atp_readb_io(dev, 0, 0x17) & 0x0f;
 		if (j == 0x0f) {
 			goto u3p_in;
 		}
@@ -1784,12 +1784,12 @@ static void is880(struct atp_unit *dev, unsigned int wkport)
 		}
 		continue;
 u3p_out:
-		outb(0x20, wkport + 0x58);
-		while ((inb(wkport + 0x5f) & 0x80) == 0) {
-			if ((inb(wkport + 0x5f) & 0x01) != 0)
-				outb(0, wkport + 0x59);
+		atp_writeb_io(dev, 0, 0x18, 0x20);
+		while ((atp_readb_io(dev, 0, 0x1f) & 0x80) == 0) {
+			if ((atp_readb_io(dev, 0, 0x1f) & 0x01) != 0)
+				atp_writeb_io(dev, 0, 0x19, 0);
 		}
-		j = inb(wkport + 0x57) & 0x0f;
+		j = atp_readb_io(dev, 0, 0x17) & 0x0f;
 		if (j == 0x0f) {
 			goto u3p_in;
 		}
@@ -1801,19 +1801,19 @@ static void is880(struct atp_unit *dev, unsigned int wkport)
 		}
 		continue;
 u3p_in:
-		outb(0x09, wkport + 0x54);
-		outb(0x20, wkport + 0x58);
+		atp_writeb_io(dev, 0, 0x14, 0x09);
+		atp_writeb_io(dev, 0, 0x18, 0x20);
 		k = 0;
 u3p_in1:
-		j = inb(wkport + 0x5f);
+		j = atp_readb_io(dev, 0, 0x1f);
 		if ((j & 0x01) != 0) {
-			mbuf[k++] = inb(wkport + 0x59);
+			mbuf[k++] = atp_readb_io(dev, 0, 0x19);
 			goto u3p_in1;
 		}
 		if ((j & 0x80) == 0x00) {
 			goto u3p_in1;
 		}
-		j = inb(wkport + 0x57) & 0x0f;
+		j = atp_readb_io(dev, 0, 0x17) & 0x0f;
 		if (j == 0x0f) {
 			goto u3p_in;
 		}
@@ -1825,14 +1825,14 @@ static void is880(struct atp_unit *dev, unsigned int wkport)
 		}
 		continue;
 u3p_cmd:
-		outb(0x30, wkport + 0x50);
-		outb(0x00, wkport + 0x54);
-		outb(0x08, wkport + 0x58);
+		atp_writeb_io(dev, 0, 0x10, 0x30);
+		atp_writeb_io(dev, 0, 0x14, 0x00);
+		atp_writeb_io(dev, 0, 0x18, 0x08);
 		
-		while ((inb(wkport + 0x5f) & 0x80) == 0x00)
+		while ((atp_readb_io(dev, 0, 0x1f) & 0x80) == 0x00)
 			cpu_relax();
 			
-		j = inb(wkport + 0x57);
+		j = atp_readb_io(dev, 0, 0x17);
 		if (j != 0x16) {
 			if (j == 0x4e) {
 				goto u3p_out;
@@ -1856,42 +1856,42 @@ static void is880(struct atp_unit *dev, unsigned int wkport)
 			continue;
 		}
 chg_wide:
-		outb(0x01, wkport + 0x5b);
-		outb(satn[0], wkport + 0x43);
-		outb(satn[1], wkport + 0x44);
-		outb(satn[2], wkport + 0x45);
-		outb(satn[3], wkport + 0x46);
-		outb(satn[4], wkport + 0x47);
-		outb(satn[5], wkport + 0x48);
-		outb(0, wkport + 0x4f);
-		outb(dev->id[0][i].devsp, wkport + 0x51);
-		outb(0, wkport + 0x52);
-		outb(satn[6], wkport + 0x53);
-		outb(satn[7], wkport + 0x54);
-		outb(satn[8], wkport + 0x58);
-
-		while ((inb(wkport + 0x5f) & 0x80) == 0x00)
+		atp_writeb_io(dev, 0, 0x1b, 0x01);
+		atp_writeb_io(dev, 0, 3, satn[0]);
+		atp_writeb_io(dev, 0, 4, satn[1]);
+		atp_writeb_io(dev, 0, 5, satn[2]);
+		atp_writeb_io(dev, 0, 6, satn[3]);
+		atp_writeb_io(dev, 0, 7, satn[4]);
+		atp_writeb_io(dev, 0, 8, satn[5]);
+		atp_writeb_io(dev, 0, 0x0f, 0);
+		atp_writeb_io(dev, 0, 0x11, dev->id[0][i].devsp);
+		atp_writeb_io(dev, 0, 0x12, 0);
+		atp_writeb_io(dev, 0, 0x13, satn[6]);
+		atp_writeb_io(dev, 0, 0x14, satn[7]);
+		atp_writeb_io(dev, 0, 0x18, satn[8]);
+
+		while ((atp_readb_io(dev, 0, 0x1f) & 0x80) == 0x00)
 			cpu_relax();
 			
-		if (inb(wkport + 0x57) != 0x11 && inb(wkport + 0x57) != 0x8e)
+		if (atp_readb_io(dev, 0, 0x17) != 0x11 && atp_readb_io(dev, 0, 0x17) != 0x8e)
 			continue;
 
-		while (inb(wkport + 0x57) != 0x8e)
+		while (atp_readb_io(dev, 0, 0x17) != 0x8e)
 			cpu_relax();
 			
 try_wide:
 		j = 0;
-		outb(0x05, wkport + 0x54);
-		outb(0x20, wkport + 0x58);
+		atp_writeb_io(dev, 0, 0x14, 0x05);
+		atp_writeb_io(dev, 0, 0x18, 0x20);
 
-		while ((inb(wkport + 0x5f) & 0x80) == 0) {
-			if ((inb(wkport + 0x5f) & 0x01) != 0)
-				outb(wide[j++], wkport + 0x59);
+		while ((atp_readb_io(dev, 0, 0x1f) & 0x80) == 0) {
+			if ((atp_readb_io(dev, 0, 0x1f) & 0x01) != 0)
+				atp_writeb_io(dev, 0, 0x19, wide[j++]);
 		}
-		while ((inb(wkport + 0x57) & 0x80) == 0x00)
+		while ((atp_readb_io(dev, 0, 0x17) & 0x80) == 0x00)
 			cpu_relax();
 			
-		j = inb(wkport + 0x57) & 0x0f;
+		j = atp_readb_io(dev, 0, 0x17) & 0x0f;
 		if (j == 0x0f) {
 			goto widep_in;
 		}
@@ -1903,12 +1903,12 @@ static void is880(struct atp_unit *dev, unsigned int wkport)
 		}
 		continue;
 widep_out:
-		outb(0x20, wkport + 0x58);
-		while ((inb(wkport + 0x5f) & 0x80) == 0) {
-			if ((inb(wkport + 0x5f) & 0x01) != 0)
-				outb(0, wkport + 0x59);
+		atp_writeb_io(dev, 0, 0x18, 0x20);
+		while ((atp_readb_io(dev, 0, 0x1f) & 0x80) == 0) {
+			if ((atp_readb_io(dev, 0, 0x1f) & 0x01) != 0)
+				atp_writeb_io(dev, 0, 0x19, 0);
 		}
-		j = inb(wkport + 0x57) & 0x0f;
+		j = atp_readb_io(dev, 0, 0x17) & 0x0f;
 		if (j == 0x0f) {
 			goto widep_in;
 		}
@@ -1920,19 +1920,19 @@ static void is880(struct atp_unit *dev, unsigned int wkport)
 		}
 		continue;
 widep_in:
-		outb(0xff, wkport + 0x54);
-		outb(0x20, wkport + 0x58);
+		atp_writeb_io(dev, 0, 0x14, 0xff);
+		atp_writeb_io(dev, 0, 0x18, 0x20);
 		k = 0;
 widep_in1:
-		j = inb(wkport + 0x5f);
+		j = atp_readb_io(dev, 0, 0x1f);
 		if ((j & 0x01) != 0) {
-			mbuf[k++] = inb(wkport + 0x59);
+			mbuf[k++] = atp_readb_io(dev, 0, 0x19);
 			goto widep_in1;
 		}
 		if ((j & 0x80) == 0x00) {
 			goto widep_in1;
 		}
-		j = inb(wkport + 0x57) & 0x0f;
+		j = atp_readb_io(dev, 0, 0x17) & 0x0f;
 		if (j == 0x0f) {
 			goto widep_in;
 		}
@@ -1944,14 +1944,14 @@ static void is880(struct atp_unit *dev, unsigned int wkport)
 		}
 		continue;
 widep_cmd:
-		outb(0x30, wkport + 0x50);
-		outb(0x00, wkport + 0x54);
-		outb(0x08, wkport + 0x58);
+		atp_writeb_io(dev, 0, 0x10, 0x30);
+		atp_writeb_io(dev, 0, 0x14, 0x00);
+		atp_writeb_io(dev, 0, 0x18, 0x08);
 
-		while ((inb(wkport + 0x5f) & 0x80) == 0x00)
+		while ((atp_readb_io(dev, 0, 0x1f) & 0x80) == 0x00)
 			cpu_relax();
 
-		j = inb(wkport + 0x57);
+		j = atp_readb_io(dev, 0, 0x17);
 		if (j != 0x16) {
 			if (j == 0x4e) {
 				goto widep_out;
@@ -1996,56 +1996,56 @@ static void is880(struct atp_unit *dev, unsigned int wkport)
 		if ((m & dev->wide_id[0]) != 0) {
 			j |= 0x01;
 		}
-		outb(j, wkport + 0x5b);
-		outb(satn[0], wkport + 0x43);
-		outb(satn[1], wkport + 0x44);
-		outb(satn[2], wkport + 0x45);
-		outb(satn[3], wkport + 0x46);
-		outb(satn[4], wkport + 0x47);
-		outb(satn[5], wkport + 0x48);
-		outb(0, wkport + 0x4f);
-		outb(dev->id[0][i].devsp, wkport + 0x51);
-		outb(0, wkport + 0x52);
-		outb(satn[6], wkport + 0x53);
-		outb(satn[7], wkport + 0x54);
-		outb(satn[8], wkport + 0x58);
-
-		while ((inb(wkport + 0x5f) & 0x80) == 0x00)
+		atp_writeb_io(dev, 0, 0x1b, j);
+		atp_writeb_io(dev, 0, 3, satn[0]);
+		atp_writeb_io(dev, 0, 4, satn[1]);
+		atp_writeb_io(dev, 0, 5, satn[2]);
+		atp_writeb_io(dev, 0, 6, satn[3]);
+		atp_writeb_io(dev, 0, 7, satn[4]);
+		atp_writeb_io(dev, 0, 8, satn[5]);
+		atp_writeb_io(dev, 0, 0x0f, 0);
+		atp_writeb_io(dev, 0, 0x11, dev->id[0][i].devsp);
+		atp_writeb_io(dev, 0, 0x12, 0);
+		atp_writeb_io(dev, 0, 0x13, satn[6]);
+		atp_writeb_io(dev, 0, 0x14, satn[7]);
+		atp_writeb_io(dev, 0, 0x18, satn[8]);
+
+		while ((atp_readb_io(dev, 0, 0x1f) & 0x80) == 0x00)
 			cpu_relax();
 
-		if ((inb(wkport + 0x57) != 0x11) && (inb(wkport + 0x57) != 0x8e)) {
+		if (atp_readb_io(dev, 0, 0x17) != 0x11 && atp_readb_io(dev, 0, 0x17) != 0x8e) {
 			continue;
 		}
-		while (inb(wkport + 0x57) != 0x8e)
+		while (atp_readb_io(dev, 0, 0x17) != 0x8e)
 			cpu_relax();
 
 try_sync:
 		j = 0;
-		outb(0x06, wkport + 0x54);
-		outb(0x20, wkport + 0x58);
+		atp_writeb_io(dev, 0, 0x14, 0x06);
+		atp_writeb_io(dev, 0, 0x18, 0x20);
 
-		while ((inb(wkport + 0x5f) & 0x80) == 0) {
-			if ((inb(wkport + 0x5f) & 0x01) != 0) {
+		while ((atp_readb_io(dev, 0, 0x1f) & 0x80) == 0) {
+			if ((atp_readb_io(dev, 0, 0x1f) & 0x01) != 0) {
 				if ((m & dev->wide_id[0]) != 0) {
 					if ((m & dev->ultra_map[0]) != 0) {
-						outb(synuw[j++], wkport + 0x59);
+						atp_writeb_io(dev, 0, 0x19, synuw[j++]);
 					} else {
-						outb(synw[j++], wkport + 0x59);
+						atp_writeb_io(dev, 0, 0x19, synw[j++]);
 					}
 				} else {
 					if ((m & dev->ultra_map[0]) != 0) {
-						outb(synu[j++], wkport + 0x59);
+						atp_writeb_io(dev, 0, 0x19, synu[j++]);
 					} else {
-						outb(synn[j++], wkport + 0x59);
+						atp_writeb_io(dev, 0, 0x19, synn[j++]);
 					}
 				}
 			}
 		}
 
-		while ((inb(wkport + 0x57) & 0x80) == 0x00)
+		while ((atp_readb_io(dev, 0, 0x17) & 0x80) == 0x00)
 			cpu_relax();
 
-		j = inb(wkport + 0x57) & 0x0f;
+		j = atp_readb_io(dev, 0, 0x17) & 0x0f;
 		if (j == 0x0f) {
 			goto phase_ins;
 		}
@@ -2057,12 +2057,12 @@ static void is880(struct atp_unit *dev, unsigned int wkport)
 		}
 		continue;
 phase_outs:
-		outb(0x20, wkport + 0x58);
-		while ((inb(wkport + 0x5f) & 0x80) == 0x00) {
-			if ((inb(wkport + 0x5f) & 0x01) != 0x00)
-				outb(0x00, wkport + 0x59);
+		atp_writeb_io(dev, 0, 0x18, 0x20);
+		while ((atp_readb_io(dev, 0, 0x1f) & 0x80) == 0x00) {
+			if ((atp_readb_io(dev, 0, 0x1f) & 0x01) != 0x00)
+				atp_writeb_io(dev, 0, 0x19, 0x00);
 		}
-		j = inb(wkport + 0x57);
+		j = atp_readb_io(dev, 0, 0x17);
 		if (j == 0x85) {
 			goto tar_dcons;
 		}
@@ -2078,23 +2078,23 @@ static void is880(struct atp_unit *dev, unsigned int wkport)
 		}
 		continue;
 phase_ins:
-		outb(0x06, wkport + 0x54);
-		outb(0x20, wkport + 0x58);
+		atp_writeb_io(dev, 0, 0x14, 0x06);
+		atp_writeb_io(dev, 0, 0x18, 0x20);
 		k = 0;
 phase_ins1:
-		j = inb(wkport + 0x5f);
+		j = atp_readb_io(dev, 0, 0x1f);
 		if ((j & 0x01) != 0x00) {
-			mbuf[k++] = inb(wkport + 0x59);
+			mbuf[k++] = atp_readb_io(dev, 0, 0x19);
 			goto phase_ins1;
 		}
 		if ((j & 0x80) == 0x00) {
 			goto phase_ins1;
 		}
 
-		while ((inb(wkport + 0x57) & 0x80) == 0x00)
+		while ((atp_readb_io(dev, 0, 0x17) & 0x80) == 0x00)
 			cpu_relax();
 
-		j = inb(wkport + 0x57);
+		j = atp_readb_io(dev, 0, 0x17);
 		if (j == 0x85) {
 			goto tar_dcons;
 		}
@@ -2110,15 +2110,15 @@ static void is880(struct atp_unit *dev, unsigned int wkport)
 		}
 		continue;
 phase_cmds:
-		outb(0x30, wkport + 0x50);
+		atp_writeb_io(dev, 0, 0x10, 0x30);
 tar_dcons:
-		outb(0x00, wkport + 0x54);
-		outb(0x08, wkport + 0x58);
+		atp_writeb_io(dev, 0, 0x14, 0x00);
+		atp_writeb_io(dev, 0, 0x18, 0x08);
 
-		while ((inb(wkport + 0x5f) & 0x80) == 0x00)
+		while ((atp_readb_io(dev, 0, 0x1f) & 0x80) == 0x00)
 			cpu_relax();
 
-		j = inb(wkport + 0x57);
+		j = atp_readb_io(dev, 0, 0x17);
 		if (j != 0x16) {
 			continue;
 		}
@@ -2375,7 +2375,7 @@ static int atp870u_probe(struct pci_dev *pdev, const struct pci_device_id *ent)
 		outb(0x20, base_io + 0x51);
 
 		tscam(shpnt);
-		is880(p, base_io);
+		is880(p);
 		outb(0xb0, base_io + 0x38);
 		shpnt->max_id = 16;
 		shpnt->this_id = host_id;

commit 152c3ac5e18057dbec396db83c76fccfa44aa258
Author: Ondrej Zary <linux@rainbow-software.org>
Date:   Tue Nov 17 19:23:55 2015 +0100

    atp870u: Convert is870() to use wrappers
    
    Signed-off-by: Ondrej Zary <linux@rainbow-software.org>
    Reviewed-by: Hannes Reinicke <hare@suse.de>
    Acked-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/atp870u.c b/drivers/scsi/atp870u.c
index 07b50acf6b92..305eda807e11 100644
--- a/drivers/scsi/atp870u.c
+++ b/drivers/scsi/atp870u.c
@@ -1162,7 +1162,7 @@ static void tscam(struct Scsi_Host *host)
 	}
 }
 
-static void is870(struct atp_unit *dev, unsigned int wkport)
+static void is870(struct atp_unit *dev)
 {
 	unsigned char i, j, k, rmb, n;
 	unsigned short int m;
@@ -1174,7 +1174,7 @@ static void is870(struct atp_unit *dev, unsigned int wkport)
 	static unsigned char synw[6] = { 0x80, 1, 3, 1, 0x0c, 0x07 };
 	static unsigned char wide[6] = { 0x80, 1, 2, 3, 1, 0 };
 	
-	outb((unsigned char) (inb(wkport + 0x3a) | 0x10), wkport + 0x3a);
+	atp_writeb_io(dev, 0, 0x3a, atp_readb_io(dev, 0, 0x3a) | 0x10);
 
 	for (i = 0; i < 16; i++) {
 		if ((dev->chip_ver != 4) && (i > 7)) {
@@ -1190,104 +1190,104 @@ static void is870(struct atp_unit *dev, unsigned int wkport)
 			continue;
 		}
 		if (dev->chip_ver == 4) {
-			outb(0x01, wkport + 0x1b);
+			atp_writeb_io(dev, 0, 0x1b, 0x01);
 		} else {
-			outb(0x00, wkport + 0x1b);
-		}
-		outb(0x08, wkport + 1);
-		outb(0x7f, wkport + 2);
-		outb(satn[0], wkport + 3);
-		outb(satn[1], wkport + 4);
-		outb(satn[2], wkport + 5);
-		outb(satn[3], wkport + 6);
-		outb(satn[4], wkport + 7);
-		outb(satn[5], wkport + 8);
-		outb(0, wkport + 0x0f);
-		outb(dev->id[0][i].devsp, wkport + 0x11);
-		outb(0, wkport + 0x12);
-		outb(satn[6], wkport + 0x13);
-		outb(satn[7], wkport + 0x14);
+			atp_writeb_io(dev, 0, 0x1b, 0x00);
+		}
+		atp_writeb_io(dev, 0, 1, 0x08);
+		atp_writeb_io(dev, 0, 2, 0x7f);
+		atp_writeb_io(dev, 0, 3, satn[0]);
+		atp_writeb_io(dev, 0, 4, satn[1]);
+		atp_writeb_io(dev, 0, 5, satn[2]);
+		atp_writeb_io(dev, 0, 6, satn[3]);
+		atp_writeb_io(dev, 0, 7, satn[4]);
+		atp_writeb_io(dev, 0, 8, satn[5]);
+		atp_writeb_io(dev, 0, 0x0f, 0);
+		atp_writeb_io(dev, 0, 0x11, dev->id[0][i].devsp);
+		atp_writeb_io(dev, 0, 0x12, 0);
+		atp_writeb_io(dev, 0, 0x13, satn[6]);
+		atp_writeb_io(dev, 0, 0x14, satn[7]);
 		j = i;
 		if ((j & 0x08) != 0) {
 			j = (j & 0x07) | 0x40;
 		}
-		outb(j, wkport + 0x15);
-		outb(satn[8], wkport + 0x18);
+		atp_writeb_io(dev, 0, 0x15, j);
+		atp_writeb_io(dev, 0, 0x18, satn[8]);
 
-		while ((inb(wkport + 0x1f) & 0x80) == 0x00)
+		while ((atp_readb_io(dev, 0, 0x1f) & 0x80) == 0x00)
 			cpu_relax();
 
-		if (inb(wkport + 0x17) != 0x11 && inb(wkport + 0x17) != 0x8e)
+		if (atp_readb_io(dev, 0, 0x17) != 0x11 && atp_readb_io(dev, 0, 0x17) != 0x8e)
 			continue;
 
-		while (inb(wkport + 0x17) != 0x8e)
+		while (atp_readb_io(dev, 0, 0x17) != 0x8e)
 			cpu_relax();
 
 		dev->active_id[0] |= m;
 
-		outb(0x30, wkport + 0x10);
-		outb(0x00, wkport + 0x04);
+		atp_writeb_io(dev, 0, 0x10, 0x30);
+		atp_writeb_io(dev, 0, 0x04, 0x00);
 
 phase_cmd:
-		outb(0x08, wkport + 0x18);
-		while ((inb(wkport + 0x1f) & 0x80) == 0x00)
+		atp_writeb_io(dev, 0, 0x18, 0x08);
+		while ((atp_readb_io(dev, 0, 0x1f) & 0x80) == 0x00)
 			cpu_relax();
-		j = inb(wkport + 0x17);
+		j = atp_readb_io(dev, 0, 0x17);
 		if (j != 0x16) {
-			outb(0x41, wkport + 0x10);
+			atp_writeb_io(dev, 0, 0x10, 0x41);
 			goto phase_cmd;
 		}
 sel_ok:
-		outb(inqd[0], wkport + 3);
-		outb(inqd[1], wkport + 4);
-		outb(inqd[2], wkport + 5);
-		outb(inqd[3], wkport + 6);
-		outb(inqd[4], wkport + 7);
-		outb(inqd[5], wkport + 8);
-		outb(0, wkport + 0x0f);
-		outb(dev->id[0][i].devsp, wkport + 0x11);
-		outb(0, wkport + 0x12);
-		outb(inqd[6], wkport + 0x13);
-		outb(inqd[7], wkport + 0x14);
-		outb(inqd[8], wkport + 0x18);
+		atp_writeb_io(dev, 0, 3, inqd[0]);
+		atp_writeb_io(dev, 0, 4, inqd[1]);
+		atp_writeb_io(dev, 0, 5, inqd[2]);
+		atp_writeb_io(dev, 0, 6, inqd[3]);
+		atp_writeb_io(dev, 0, 7, inqd[4]);
+		atp_writeb_io(dev, 0, 8, inqd[5]);
+		atp_writeb_io(dev, 0, 0x0f, 0);
+		atp_writeb_io(dev, 0, 0x11, dev->id[0][i].devsp);
+		atp_writeb_io(dev, 0, 0x12, 0);
+		atp_writeb_io(dev, 0, 0x13, inqd[6]);
+		atp_writeb_io(dev, 0, 0x14, inqd[7]);
+		atp_writeb_io(dev, 0, 0x18, inqd[8]);
 
-		while ((inb(wkport + 0x1f) & 0x80) == 0x00)
+		while ((atp_readb_io(dev, 0, 0x1f) & 0x80) == 0x00)
 			cpu_relax();
 			
-		if (inb(wkport + 0x17) != 0x11 && inb(wkport + 0x17) != 0x8e)
+		if (atp_readb_io(dev, 0, 0x17) != 0x11 && atp_readb_io(dev, 0, 0x17) != 0x8e)
 			continue;
 
-		while (inb(wkport + 0x17) != 0x8e)
+		while (atp_readb_io(dev, 0, 0x17) != 0x8e)
 			cpu_relax();
 			
 		if (dev->chip_ver == 4)
-			outb(0x00, wkport + 0x1b);
+			atp_writeb_io(dev, 0, 0x1b, 0x00);
 
-		outb(0x08, wkport + 0x18);
+		atp_writeb_io(dev, 0, 0x18, 0x08);
 		j = 0;
 rd_inq_data:
-		k = inb(wkport + 0x1f);
+		k = atp_readb_io(dev, 0, 0x1f);
 		if ((k & 0x01) != 0) {
-			mbuf[j++] = inb(wkport + 0x19);
+			mbuf[j++] = atp_readb_io(dev, 0, 0x19);
 			goto rd_inq_data;
 		}
 		if ((k & 0x80) == 0) {
 			goto rd_inq_data;
 		}
-		j = inb(wkport + 0x17);
+		j = atp_readb_io(dev, 0, 0x17);
 		if (j == 0x16) {
 			goto inq_ok;
 		}
-		outb(0x46, wkport + 0x10);
-		outb(0, wkport + 0x12);
-		outb(0, wkport + 0x13);
-		outb(0, wkport + 0x14);
-		outb(0x08, wkport + 0x18);
+		atp_writeb_io(dev, 0, 0x10, 0x46);
+		atp_writeb_io(dev, 0, 0x12, 0);
+		atp_writeb_io(dev, 0, 0x13, 0);
+		atp_writeb_io(dev, 0, 0x14, 0);
+		atp_writeb_io(dev, 0, 0x18, 0x08);
 
-		while ((inb(wkport + 0x1f) & 0x80) == 0x00)
+		while ((atp_readb_io(dev, 0, 0x1f) & 0x80) == 0x00)
 			cpu_relax();
 			
-		if (inb(wkport + 0x17) != 0x16) {
+		if (atp_readb_io(dev, 0, 0x17) != 0x16) {
 			goto sel_ok;
 		}
 inq_ok:
@@ -1305,43 +1305,43 @@ static void is870(struct atp_unit *dev, unsigned int wkport)
 		if ((dev->global_map[0] & 0x20) == 0) {
 			goto not_wide;
 		}
-		outb(0x01, wkport + 0x1b);
-		outb(satn[0], wkport + 3);
-		outb(satn[1], wkport + 4);
-		outb(satn[2], wkport + 5);
-		outb(satn[3], wkport + 6);
-		outb(satn[4], wkport + 7);
-		outb(satn[5], wkport + 8);
-		outb(0, wkport + 0x0f);
-		outb(dev->id[0][i].devsp, wkport + 0x11);
-		outb(0, wkport + 0x12);
-		outb(satn[6], wkport + 0x13);
-		outb(satn[7], wkport + 0x14);
-		outb(satn[8], wkport + 0x18);
+		atp_writeb_io(dev, 0, 0x1b, 0x01);
+		atp_writeb_io(dev, 0, 3, satn[0]);
+		atp_writeb_io(dev, 0, 4, satn[1]);
+		atp_writeb_io(dev, 0, 5, satn[2]);
+		atp_writeb_io(dev, 0, 6, satn[3]);
+		atp_writeb_io(dev, 0, 7, satn[4]);
+		atp_writeb_io(dev, 0, 8, satn[5]);
+		atp_writeb_io(dev, 0, 0x0f, 0);
+		atp_writeb_io(dev, 0, 0x11, dev->id[0][i].devsp);
+		atp_writeb_io(dev, 0, 0x12, 0);
+		atp_writeb_io(dev, 0, 0x13, satn[6]);
+		atp_writeb_io(dev, 0, 0x14, satn[7]);
+		atp_writeb_io(dev, 0, 0x18, satn[8]);
 
-		while ((inb(wkport + 0x1f) & 0x80) == 0x00)
+		while ((atp_readb_io(dev, 0, 0x1f) & 0x80) == 0x00)
 			cpu_relax();
 			
-		if (inb(wkport + 0x17) != 0x11 && inb(wkport + 0x17) != 0x8e)
+		if (atp_readb_io(dev, 0, 0x17) != 0x11 && atp_readb_io(dev, 0, 0x17) != 0x8e)
 			continue;
 
-		while (inb(wkport + 0x17) != 0x8e)
+		while (atp_readb_io(dev, 0, 0x17) != 0x8e)
 			cpu_relax();
 			
 try_wide:
 		j = 0;
-		outb(0x05, wkport + 0x14);
-		outb(0x20, wkport + 0x18);
+		atp_writeb_io(dev, 0, 0x14, 0x05);
+		atp_writeb_io(dev, 0, 0x18, 0x20);
 
-		while ((inb(wkport + 0x1f) & 0x80) == 0) {
-			if ((inb(wkport + 0x1f) & 0x01) != 0)
-				outb(wide[j++], wkport + 0x19);
+		while ((atp_readb_io(dev, 0, 0x1f) & 0x80) == 0) {
+			if ((atp_readb_io(dev, 0, 0x1f) & 0x01) != 0)
+				atp_writeb_io(dev, 0, 0x19, wide[j++]);
 		}
 		
-		while ((inb(wkport + 0x17) & 0x80) == 0x00)
+		while ((atp_readb_io(dev, 0, 0x17) & 0x80) == 0x00)
 			cpu_relax();
 			
-		j = inb(wkport + 0x17) & 0x0f;
+		j = atp_readb_io(dev, 0, 0x17) & 0x0f;
 		if (j == 0x0f) {
 			goto widep_in;
 		}
@@ -1353,12 +1353,12 @@ static void is870(struct atp_unit *dev, unsigned int wkport)
 		}
 		continue;
 widep_out:
-		outb(0x20, wkport + 0x18);
-		while ((inb(wkport + 0x1f) & 0x80) == 0) {
-			if ((inb(wkport + 0x1f) & 0x01) != 0)
-				outb(0, wkport + 0x19);
+		atp_writeb_io(dev, 0, 0x18, 0x20);
+		while ((atp_readb_io(dev, 0, 0x1f) & 0x80) == 0) {
+			if ((atp_readb_io(dev, 0, 0x1f) & 0x01) != 0)
+				atp_writeb_io(dev, 0, 0x19, 0);
 		}
-		j = inb(wkport + 0x17) & 0x0f;
+		j = atp_readb_io(dev, 0, 0x17) & 0x0f;
 		if (j == 0x0f) {
 			goto widep_in;
 		}
@@ -1370,19 +1370,19 @@ static void is870(struct atp_unit *dev, unsigned int wkport)
 		}
 		continue;
 widep_in:
-		outb(0xff, wkport + 0x14);
-		outb(0x20, wkport + 0x18);
+		atp_writeb_io(dev, 0, 0x14, 0xff);
+		atp_writeb_io(dev, 0, 0x18, 0x20);
 		k = 0;
 widep_in1:
-		j = inb(wkport + 0x1f);
+		j = atp_readb_io(dev, 0, 0x1f);
 		if ((j & 0x01) != 0) {
-			mbuf[k++] = inb(wkport + 0x19);
+			mbuf[k++] = atp_readb_io(dev, 0, 0x19);
 			goto widep_in1;
 		}
 		if ((j & 0x80) == 0x00) {
 			goto widep_in1;
 		}
-		j = inb(wkport + 0x17) & 0x0f;
+		j = atp_readb_io(dev, 0, 0x17) & 0x0f;
 		if (j == 0x0f) {
 			goto widep_in;
 		}
@@ -1394,14 +1394,14 @@ static void is870(struct atp_unit *dev, unsigned int wkport)
 		}
 		continue;
 widep_cmd:
-		outb(0x30, wkport + 0x10);
-		outb(0x00, wkport + 0x14);
-		outb(0x08, wkport + 0x18);
-		
-		while ((inb(wkport + 0x1f) & 0x80) == 0x00)
+		atp_writeb_io(dev, 0, 0x10, 0x30);
+		atp_writeb_io(dev, 0, 0x14, 0x00);
+		atp_writeb_io(dev, 0, 0x18, 0x08);
+
+		while ((atp_readb_io(dev, 0, 0x1f) & 0x80) == 0x00)
 			cpu_relax();
 
-		j = inb(wkport + 0x17);
+		j = atp_readb_io(dev, 0, 0x17);
 		if (j != 0x16) {
 			if (j == 0x4e) {
 				goto widep_out;
@@ -1433,52 +1433,52 @@ static void is870(struct atp_unit *dev, unsigned int wkport)
 		if ((m & dev->wide_id[0]) != 0) {
 			j |= 0x01;
 		}
-		outb(j, wkport + 0x1b);
-		outb(satn[0], wkport + 3);
-		outb(satn[1], wkport + 4);
-		outb(satn[2], wkport + 5);
-		outb(satn[3], wkport + 6);
-		outb(satn[4], wkport + 7);
-		outb(satn[5], wkport + 8);
-		outb(0, wkport + 0x0f);
-		outb(dev->id[0][i].devsp, wkport + 0x11);
-		outb(0, wkport + 0x12);
-		outb(satn[6], wkport + 0x13);
-		outb(satn[7], wkport + 0x14);
-		outb(satn[8], wkport + 0x18);
+		atp_writeb_io(dev, 0, 0x1b, j);
+		atp_writeb_io(dev, 0, 3, satn[0]);
+		atp_writeb_io(dev, 0, 4, satn[1]);
+		atp_writeb_io(dev, 0, 5, satn[2]);
+		atp_writeb_io(dev, 0, 6, satn[3]);
+		atp_writeb_io(dev, 0, 7, satn[4]);
+		atp_writeb_io(dev, 0, 8, satn[5]);
+		atp_writeb_io(dev, 0, 0x0f, 0);
+		atp_writeb_io(dev, 0, 0x11, dev->id[0][i].devsp);
+		atp_writeb_io(dev, 0, 0x12, 0);
+		atp_writeb_io(dev, 0, 0x13, satn[6]);
+		atp_writeb_io(dev, 0, 0x14, satn[7]);
+		atp_writeb_io(dev, 0, 0x18, satn[8]);
 
-		while ((inb(wkport + 0x1f) & 0x80) == 0x00)
+		while ((atp_readb_io(dev, 0, 0x1f) & 0x80) == 0x00)
 			cpu_relax();
 			
-		if (inb(wkport + 0x17) != 0x11 && inb(wkport + 0x17) != 0x8e)
+		if (atp_readb_io(dev, 0, 0x17) != 0x11 && atp_readb_io(dev, 0, 0x17) != 0x8e)
 			continue;
 
-		while (inb(wkport + 0x17) != 0x8e)
+		while (atp_readb_io(dev, 0, 0x17) != 0x8e)
 			cpu_relax();
 			
 try_sync:
 		j = 0;
-		outb(0x06, wkport + 0x14);
-		outb(0x20, wkport + 0x18);
+		atp_writeb_io(dev, 0, 0x14, 0x06);
+		atp_writeb_io(dev, 0, 0x18, 0x20);
 
-		while ((inb(wkport + 0x1f) & 0x80) == 0) {
-			if ((inb(wkport + 0x1f) & 0x01) != 0) {
+		while ((atp_readb_io(dev, 0, 0x1f) & 0x80) == 0) {
+			if ((atp_readb_io(dev, 0, 0x1f) & 0x01) != 0) {
 				if ((m & dev->wide_id[0]) != 0) {
-					outb(synw[j++], wkport + 0x19);
+					atp_writeb_io(dev, 0, 0x19, synw[j++]);
 				} else {
 					if ((m & dev->ultra_map[0]) != 0) {
-						outb(synu[j++], wkport + 0x19);
+						atp_writeb_io(dev, 0, 0x19, synu[j++]);
 					} else {
-						outb(synn[j++], wkport + 0x19);
+						atp_writeb_io(dev, 0, 0x19, synn[j++]);
 					}
 				}
 			}
 		}
 		
-		while ((inb(wkport + 0x17) & 0x80) == 0x00)
+		while ((atp_readb_io(dev, 0, 0x17) & 0x80) == 0x00)
 			cpu_relax();
 			
-		j = inb(wkport + 0x17) & 0x0f;
+		j = atp_readb_io(dev, 0, 0x17) & 0x0f;
 		if (j == 0x0f) {
 			goto phase_ins;
 		}
@@ -1490,12 +1490,12 @@ static void is870(struct atp_unit *dev, unsigned int wkport)
 		}
 		continue;
 phase_outs:
-		outb(0x20, wkport + 0x18);
-		while ((inb(wkport + 0x1f) & 0x80) == 0x00) {
-			if ((inb(wkport + 0x1f) & 0x01) != 0x00)
-				outb(0x00, wkport + 0x19);
+		atp_writeb_io(dev, 0, 0x18, 0x20);
+		while ((atp_readb_io(dev, 0, 0x1f) & 0x80) == 0x00) {
+			if ((atp_readb_io(dev, 0, 0x1f) & 0x01) != 0x00)
+				atp_writeb_io(dev, 0, 0x19, 0x00);
 		}
-		j = inb(wkport + 0x17);
+		j = atp_readb_io(dev, 0, 0x17);
 		if (j == 0x85) {
 			goto tar_dcons;
 		}
@@ -1511,23 +1511,23 @@ static void is870(struct atp_unit *dev, unsigned int wkport)
 		}
 		continue;
 phase_ins:
-		outb(0xff, wkport + 0x14);
-		outb(0x20, wkport + 0x18);
+		atp_writeb_io(dev, 0, 0x14, 0xff);
+		atp_writeb_io(dev, 0, 0x18, 0x20);
 		k = 0;
 phase_ins1:
-		j = inb(wkport + 0x1f);
+		j = atp_readb_io(dev, 0, 0x1f);
 		if ((j & 0x01) != 0x00) {
-			mbuf[k++] = inb(wkport + 0x19);
+			mbuf[k++] = atp_readb_io(dev, 0, 0x19);
 			goto phase_ins1;
 		}
 		if ((j & 0x80) == 0x00) {
 			goto phase_ins1;
 		}
 
-		while ((inb(wkport + 0x17) & 0x80) == 0x00)
+		while ((atp_readb_io(dev, 0, 0x17) & 0x80) == 0x00)
 			cpu_relax();
 			
-		j = inb(wkport + 0x17);
+		j = atp_readb_io(dev, 0, 0x17);
 		if (j == 0x85) {
 			goto tar_dcons;
 		}
@@ -1543,15 +1543,15 @@ static void is870(struct atp_unit *dev, unsigned int wkport)
 		}
 		continue;
 phase_cmds:
-		outb(0x30, wkport + 0x10);
+		atp_writeb_io(dev, 0, 0x10, 0x30);
 tar_dcons:
-		outb(0x00, wkport + 0x14);
-		outb(0x08, wkport + 0x18);
+		atp_writeb_io(dev, 0, 0x14, 0x00);
+		atp_writeb_io(dev, 0, 0x18, 0x08);
 		
-		while ((inb(wkport + 0x1f) & 0x80) == 0x00)
+		while ((atp_readb_io(dev, 0, 0x1f) & 0x80) == 0x00)
 			cpu_relax();
 			
-		j = inb(wkport + 0x17);
+		j = atp_readb_io(dev, 0, 0x17);
 		if (j != 0x16) {
 			continue;
 		}
@@ -1591,7 +1591,7 @@ static void is870(struct atp_unit *dev, unsigned int wkport)
 set_syn_ok:
 		dev->id[0][i].devsp = (dev->id[0][i].devsp & 0x0f) | j;
 	}
-	outb((unsigned char) (inb(wkport + 0x3a) & 0xef), wkport + 0x3a);
+	atp_writeb_io(dev, 0, 0x3a, atp_readb_io(dev, 0, 0x3a) & 0xef);
 }
 
 static void is880(struct atp_unit *dev, unsigned int wkport)
@@ -2605,7 +2605,7 @@ static int atp870u_probe(struct pci_dev *pdev, const struct pci_device_id *ent)
 		outb(0x20, base_io + 0x11);
 
 		tscam(shpnt);
-		is870(p, base_io);
+		is870(p);
 		outb((inb(base_io + 0x3a) & 0xef), base_io + 0x3a);
 		outb((inb(base_io + 0x3b) | 0x20), base_io + 0x3b);
 		if (atpdev->chip_ver == 4)

commit 6a3cebb682190f878dcab60450cfdb2eddeceb69
Author: Ondrej Zary <linux@rainbow-software.org>
Date:   Tue Nov 17 19:23:54 2015 +0100

    atp870u: Introduce HW access wrappers
    
    Introduce *_read? and *_write? wrappers to improve code readability.
    Also make sure that baseport is always initialized, not only for ATP880.
    
    Signed-off-by: Ondrej Zary <linux@rainbow-software.org>
    Reviewed-by: Hannes Reinicke <hare@suse.de>
    Acked-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/atp870u.c b/drivers/scsi/atp870u.c
index fd2bb6f035da..07b50acf6b92 100644
--- a/drivers/scsi/atp870u.c
+++ b/drivers/scsi/atp870u.c
@@ -44,6 +44,51 @@ static void send_s870(struct atp_unit *dev,unsigned char c);
 static void is885(struct atp_unit *dev, unsigned int wkport,unsigned char c);
 static void tscam_885(void);
 
+static inline void atp_writeb_base(struct atp_unit *atp, u8 reg, u8 val)
+{
+	outb(val, atp->baseport + reg);
+}
+
+static inline void atp_writeb_io(struct atp_unit *atp, u8 channel, u8 reg, u8 val)
+{
+	outb(val, atp->ioport[channel] + reg);
+}
+
+static inline void atp_writew_io(struct atp_unit *atp, u8 channel, u8 reg, u16 val)
+{
+	outw(val, atp->ioport[channel] + reg);
+}
+
+static inline void atp_writeb_pci(struct atp_unit *atp, u8 channel, u8 reg, u8 val)
+{
+	outb(val, atp->pciport[channel] + reg);
+}
+
+static inline void atp_writel_pci(struct atp_unit *atp, u8 channel, u8 reg, u32 val)
+{
+	outl(val, atp->pciport[channel] + reg);
+}
+
+static inline u8 atp_readb_base(struct atp_unit *atp, u8 reg)
+{
+	return inb(atp->baseport + reg);
+}
+
+static inline u8 atp_readb_io(struct atp_unit *atp, u8 channel, u8 reg)
+{
+	return inb(atp->ioport[channel] + reg);
+}
+
+static inline u16 atp_readw_io(struct atp_unit *atp, u8 channel, u8 reg)
+{
+	return inw(atp->ioport[channel] + reg);
+}
+
+static inline u8 atp_readb_pci(struct atp_unit *atp, u8 channel, u8 reg)
+{
+	return inb(atp->pciport[channel] + reg);
+}
+
 static irqreturn_t atp870u_intr_handle(int irq, void *dev_id)
 {
 	unsigned long flags;
@@ -59,7 +104,7 @@ static irqreturn_t atp870u_intr_handle(int irq, void *dev_id)
 	struct atp_unit *dev = (struct atp_unit *)&host->hostdata;
 
 	for (c = 0; c < 2; c++) {
-		j = inb(dev->ioport[c] + 0x1f);
+		j = atp_readb_io(dev, c, 0x1f);
 		if ((j & 0x80) != 0)
 			break;
 		dev->in_int[c] = 0;
@@ -70,29 +115,29 @@ static irqreturn_t atp870u_intr_handle(int irq, void *dev_id)
 	printk("atp870u_intr_handle enter\n");
 #endif	
 	dev->in_int[c] = 1;
-	cmdp = inb(dev->ioport[c] + 0x10);
+	cmdp = atp_readb_io(dev, c, 0x10);
 	if (dev->working[c] != 0) {
 		if (dev->dev_id == ATP885_DEVID) {
-			if ((inb(dev->ioport[c] + 0x16) & 0x80) == 0)
-				outb((inb(dev->ioport[c] + 0x16) | 0x80), dev->ioport[c] + 0x16);
+			if ((atp_readb_io(dev, c, 0x16) & 0x80) == 0)
+				atp_writeb_io(dev, c, 0x16, (atp_readb_io(dev, c, 0x16) | 0x80));
 		}		
-		if ((inb(dev->pciport[c]) & 0x08) != 0)
+		if ((atp_readb_pci(dev, c, 0x00) & 0x08) != 0)
 		{
 			for (k=0; k < 1000; k++) {
-				if ((inb(dev->pciport[c] + 2) & 0x08) == 0)
+				if ((atp_readb_pci(dev, c, 2) & 0x08) == 0)
 					break;
-				if ((inb(dev->pciport[c] + 2) & 0x01) == 0)
+				if ((atp_readb_pci(dev, c, 2) & 0x01) == 0)
 					break;
 			}
 		}
-		outb(0x00, dev->pciport[c]);
+		atp_writeb_pci(dev, c, 0, 0x00);
 		
-		i = inb(dev->ioport[c] + 0x17);
+		i = atp_readb_io(dev, c, 0x17);
 		
 		if (dev->dev_id == ATP885_DEVID)
-			outb(0x06, dev->pciport[c] + 2);
+			atp_writeb_pci(dev, c, 2, 0x06);
 
-		target_id = inb(dev->ioport[c] + 0x15);
+		target_id = atp_readb_io(dev, c, 0x15);
 
 		/*
 		 *	Remap wide devices onto id numbers
@@ -121,9 +166,9 @@ static irqreturn_t atp870u_intr_handle(int irq, void *dev_id)
 			}
 			if (dev->dev_id == ATP885_DEVID) {
 				adrcnt = 0;
-				((unsigned char *) &adrcnt)[2] = inb(dev->ioport[c] + 0x12);
-				((unsigned char *) &adrcnt)[1] = inb(dev->ioport[c] + 0x13);
-				((unsigned char *) &adrcnt)[0] = inb(dev->ioport[c] + 0x14);
+				((unsigned char *) &adrcnt)[2] = atp_readb_io(dev, c, 0x12);
+				((unsigned char *) &adrcnt)[1] = atp_readb_io(dev, c, 0x13);
+				((unsigned char *) &adrcnt)[0] = atp_readb_io(dev, c, 0x14);
 				if (dev->id[c][target_id].last_len != adrcnt)
 				{
 			   		k = dev->id[c][target_id].last_len;
@@ -140,10 +185,9 @@ static irqreturn_t atp870u_intr_handle(int irq, void *dev_id)
 			 *      Flip wide
 			 */			
 			if (dev->wide_id[c] != 0) {
-				outb(0x01, dev->ioport[c] + 0x1b);
-				while ((inb(dev->ioport[c] + 0x1b) & 0x01) != 0x01) {
-					outb(0x01, dev->ioport[c] + 0x1b);
-				}
+				atp_writeb_io(dev, c, 0x1b, 0x01);
+				while ((atp_readb_io(dev, c, 0x1b) & 0x01) != 0x01)
+					atp_writeb_io(dev, c, 0x1b, 0x01);
 			}		
 			/*
 			 *	Issue more commands
@@ -178,15 +222,15 @@ static irqreturn_t atp870u_intr_handle(int irq, void *dev_id)
 			   dev->last_cmd[c] = 0xff;
 			}
 			adrcnt = 0;
-			((unsigned char *) &adrcnt)[2] = inb(dev->ioport[c] + 0x12);
-			((unsigned char *) &adrcnt)[1] = inb(dev->ioport[c] + 0x13);
-			((unsigned char *) &adrcnt)[0] = inb(dev->ioport[c] + 0x14);
+			((unsigned char *) &adrcnt)[2] = atp_readb_io(dev, c, 0x12);
+			((unsigned char *) &adrcnt)[1] = atp_readb_io(dev, c, 0x13);
+			((unsigned char *) &adrcnt)[0] = atp_readb_io(dev, c, 0x14);
 			k = dev->id[c][target_id].last_len;
 			k -= adrcnt;
 			dev->id[c][target_id].tran_len = k;
 			dev->id[c][target_id].last_len = adrcnt;
-			outb(0x41, dev->ioport[c] + 0x10);
-			outb(0x08, dev->ioport[c] + 0x18);
+			atp_writeb_io(dev, c, 0x10, 0x41);
+			atp_writeb_io(dev, c, 0x18, 0x08);
 			dev->in_int[c] = 0;
 			return IRQ_HANDLED;
 		}
@@ -205,9 +249,9 @@ static irqreturn_t atp870u_intr_handle(int irq, void *dev_id)
 			printk(KERN_DEBUG "Device reselect\n");
 #endif			
 			lun = 0;
-			if (cmdp == 0x44 || i==0x80) {
-				lun = inb(dev->ioport[c] + 0x1d) & 0x07;
-			} else {
+			if (cmdp == 0x44 || i == 0x80)
+				lun = atp_readb_io(dev, c, 0x1d) & 0x07;
+			else {
 				if ((dev->last_cmd[c] & 0xf0) != 0x40) {
 				   dev->last_cmd[c] = 0xff;
 				}
@@ -216,26 +260,26 @@ static irqreturn_t atp870u_intr_handle(int irq, void *dev_id)
 					printk("cmdp = 0x41\n");
 #endif						
 					adrcnt = 0;
-					((unsigned char *) &adrcnt)[2] = inb(dev->ioport[c] + 0x12);
-					((unsigned char *) &adrcnt)[1] = inb(dev->ioport[c] + 0x13);
-					((unsigned char *) &adrcnt)[0] = inb(dev->ioport[c] + 0x14);
+					((unsigned char *) &adrcnt)[2] = atp_readb_io(dev, c, 0x12);
+					((unsigned char *) &adrcnt)[1] = atp_readb_io(dev, c, 0x13);
+					((unsigned char *) &adrcnt)[0] = atp_readb_io(dev, c, 0x14);
 					k = dev->id[c][target_id].last_len;
 					k -= adrcnt;
 					dev->id[c][target_id].tran_len = k;
 					dev->id[c][target_id].last_len = adrcnt;
-					outb(0x08, dev->ioport[c] + 0x18);
+					atp_writeb_io(dev, c, 0x18, 0x08);
 					dev->in_int[c] = 0;
 					return IRQ_HANDLED;
 				} else {
 #ifdef ED_DBGP
 					printk("cmdp != 0x41\n");
 #endif						
-					outb(0x46, dev->ioport[c] + 0x10);
+					atp_writeb_io(dev, c, 0x10, 0x46);
 					dev->id[c][target_id].dirct = 0x00;
-					outb(0x00, dev->ioport[c] + 0x12);
-					outb(0x00, dev->ioport[c] + 0x13);
-					outb(0x00, dev->ioport[c] + 0x14);
-					outb(0x08, dev->ioport[c] + 0x18);
+					atp_writeb_io(dev, c, 0x12, 0x00);
+					atp_writeb_io(dev, c, 0x13, 0x00);
+					atp_writeb_io(dev, c, 0x14, 0x00);
+					atp_writeb_io(dev, c, 0x18, 0x08);
 					dev->in_int[c] = 0;
 					return IRQ_HANDLED;
 				}
@@ -244,12 +288,12 @@ static irqreturn_t atp870u_intr_handle(int irq, void *dev_id)
 			   dev->last_cmd[c] |= 0x40;
 			}
 			if (dev->dev_id == ATP885_DEVID) {
-				j = inb(dev->baseport + 0x29) & 0xfe;
-				outb(j, dev->baseport + 0x29);
+				j = atp_readb_base(dev, 0x29) & 0xfe;
+				atp_writeb_base(dev, 0x29, j);
 			} else
-				outb(0x45, dev->ioport[c] + 0x10);
+				atp_writeb_io(dev, c, 0x10, 0x45);
 
-			target_id = inb(dev->ioport[c] + 0x16);
+			target_id = atp_readb_io(dev, c, 0x16);
 			/*
 			 *	Remap wide identifiers
 			 */
@@ -259,7 +303,7 @@ static irqreturn_t atp870u_intr_handle(int irq, void *dev_id)
 				target_id &= 0x07;
 			}
 			if (dev->dev_id == ATP885_DEVID)
-				outb(0x45, dev->ioport[c] + 0x10);
+				atp_writeb_io(dev, c, 0x10, 0x45);
 			workreq = dev->id[c][target_id].curr_req;
 #ifdef ED_DBGP			
 			scmd_printk(KERN_DEBUG, workreq, "CDB");
@@ -268,16 +312,16 @@ static irqreturn_t atp870u_intr_handle(int irq, void *dev_id)
 			printk("\n");
 #endif	
 			
-			outb(lun, dev->ioport[c] + 0x0f);
-			outb(dev->id[c][target_id].devsp, dev->ioport[c] + 0x11);
+			atp_writeb_io(dev, c, 0x0f, lun);
+			atp_writeb_io(dev, c, 0x11, dev->id[c][target_id].devsp);
 			adrcnt = dev->id[c][target_id].tran_len;
 			k = dev->id[c][target_id].last_len;
 
-			outb(((unsigned char *) &k)[2], dev->ioport[c] + 0x12);
-			outb(((unsigned char *) &k)[1], dev->ioport[c] + 0x13);
-			outb(((unsigned char *) &k)[0], dev->ioport[c] + 0x14);
+			atp_writeb_io(dev, c, 0x12, ((unsigned char *) &k)[2]);
+			atp_writeb_io(dev, c, 0x13, ((unsigned char *) &k)[1]);
+			atp_writeb_io(dev, c, 0x14, ((unsigned char *) &k)[0]);
 #ifdef ED_DBGP			
-			printk("k %x, k[0] 0x%x k[1] 0x%x k[2] 0x%x\n", k, inb(dev->ioport[c] + 0x14), inb(dev->ioport[c] + 0x13), inb(dev->ioport[c] + 0x12));
+			printk("k %x, k[0] 0x%x k[1] 0x%x k[2] 0x%x\n", k, atp_readb_io(dev, c, 0x14), atp_readb_io(dev, c, 0x13), atp_readb_io(dev, c, 0x12));
 #endif			
 			/* Remap wide */
 			j = target_id;
@@ -286,30 +330,28 @@ static irqreturn_t atp870u_intr_handle(int irq, void *dev_id)
 			}
 			/* Add direction */
 			j |= dev->id[c][target_id].dirct;
-			outb(j, dev->ioport[c] + 0x15);
-			outb(0x80, dev->ioport[c] + 0x16);
+			atp_writeb_io(dev, c, 0x15, j);
+			atp_writeb_io(dev, c, 0x16, 0x80);
 			
 			/* enable 32 bit fifo transfer */	
 			if (dev->dev_id == ATP885_DEVID) {
-				i=inb(dev->pciport[c] + 1) & 0xf3;
+				i = atp_readb_pci(dev, c, 1) & 0xf3;
 				//j=workreq->cmnd[0];	    		    	
 				if ((workreq->cmnd[0] == 0x08) || (workreq->cmnd[0] == 0x28) || (workreq->cmnd[0] == 0x0a) || (workreq->cmnd[0] == 0x2a)) {
 				   i |= 0x0c;
 				}
-				outb(i, dev->pciport[c] + 1);
+				atp_writeb_pci(dev, c, 1, i);
 			} else if ((dev->dev_id == ATP880_DEVID1) ||
 	    		    	   (dev->dev_id == ATP880_DEVID2) ) {
-				if ((workreq->cmnd[0] == 0x08) || (workreq->cmnd[0] == 0x28) || (workreq->cmnd[0] == 0x0a) || (workreq->cmnd[0] == 0x2a)) {
-					outb((unsigned char) ((inb(dev->ioport[c] - 0x05) & 0x3f) | 0xc0), dev->ioport[c] - 0x05);///minus 0x05???
-				} else {
-					outb((unsigned char) (inb(dev->ioport[c] - 0x05) & 0x3f), dev->ioport[c] - 0x05);///minus 0x05???
-				}
+				if ((workreq->cmnd[0] == 0x08) || (workreq->cmnd[0] == 0x28) || (workreq->cmnd[0] == 0x0a) || (workreq->cmnd[0] == 0x2a))
+					atp_writeb_base(dev, 0x3b, (atp_readb_base(dev, 0x3b) & 0x3f) | 0xc0);
+				else
+					atp_writeb_base(dev, 0x3b, atp_readb_base(dev, 0x3b) & 0x3f);
 			} else {				
-				if ((workreq->cmnd[0] == 0x08) || (workreq->cmnd[0] == 0x28) || (workreq->cmnd[0] == 0x0a) || (workreq->cmnd[0] == 0x2a)) {
-					outb((unsigned char) ((inb(dev->ioport[c] + 0x3a) & 0xf3) | 0x08), dev->ioport[c] + 0x3a);
-				} else {
-					outb((unsigned char) (inb(dev->ioport[c] + 0x3a) & 0xf3), dev->ioport[c] + 0x3a);
-				}														
+				if ((workreq->cmnd[0] == 0x08) || (workreq->cmnd[0] == 0x28) || (workreq->cmnd[0] == 0x0a) || (workreq->cmnd[0] == 0x2a))
+					atp_writeb_io(dev, c, 0x3a, (atp_readb_io(dev, c, 0x3a) & 0xf3) | 0x08);
+				else
+					atp_writeb_io(dev, c, 0x3a, atp_readb_io(dev, c, 0x3a) & 0xf3);
 			}	
 			j = 0;
 			id = 1;
@@ -320,12 +362,11 @@ static irqreturn_t atp870u_intr_handle(int irq, void *dev_id)
 			if ((id & dev->wide_id[c]) != 0) {
 				j |= 0x01;
 			}
-			outb(j, dev->ioport[c] + 0x1b);
-			while ((inb(dev->ioport[c] + 0x1b) & 0x01) != j) {
-				outb(j,dev->ioport[c] + 0x1b);
-			}
+			atp_writeb_io(dev, c, 0x1b, j);
+			while ((atp_readb_io(dev, c, 0x1b) & 0x01) != j)
+				atp_writeb_io(dev, c, 0x1b, j);
 			if (dev->id[c][target_id].last_len == 0) {
-				outb(0x08, dev->ioport[c] + 0x18);
+				atp_writeb_io(dev, c, 0x18, 0x08);
 				dev->in_int[c] = 0;
 #ifdef ED_DBGP
 				printk("dev->id[c][target_id].last_len = 0\n");
@@ -358,28 +399,28 @@ static irqreturn_t atp870u_intr_handle(int irq, void *dev_id)
 					}
 				}				
 			}
-			outl(dev->id[c][target_id].prdaddr, dev->pciport[c] + 0x04);
+			atp_writel_pci(dev, c, 0x04, dev->id[c][target_id].prdaddr);
 #ifdef ED_DBGP
 			printk("dev->id[%d][%d].prdaddr 0x%8x\n", c, target_id, dev->id[c][target_id].prdaddr);
 #endif
 			if (dev->dev_id != ATP885_DEVID) {
-				outb(0x06, dev->pciport[c] + 2);
-				outb(0x00, dev->pciport[c] + 2);
+				atp_writeb_pci(dev, c, 2, 0x06);
+				atp_writeb_pci(dev, c, 2, 0x00);
 			}
 			/*
 			 *	Check transfer direction
 			 */
 			if (dev->id[c][target_id].dirct != 0) {
-				outb(0x08, dev->ioport[c] + 0x18);
-				outb(0x01, dev->pciport[c]);
+				atp_writeb_io(dev, c, 0x18, 0x08);
+				atp_writeb_pci(dev, c, 0, 0x01);
 				dev->in_int[c] = 0;
 #ifdef ED_DBGP
 				printk("status 0x80 return dirct != 0\n");
 #endif				
 				return IRQ_HANDLED;
 			}
-			outb(0x08, dev->ioport[c] + 0x18);
-			outb(0x09, dev->pciport[c]);
+			atp_writeb_io(dev, c, 0x18, 0x08);
+			atp_writeb_pci(dev, c, 0, 0x09);
 			dev->in_int[c] = 0;
 #ifdef ED_DBGP
 			printk("status 0x80 return dirct = 0\n");
@@ -398,7 +439,7 @@ static irqreturn_t atp870u_intr_handle(int irq, void *dev_id)
 			   dev->last_cmd[c] = 0xff;
 			}
 			if (i == 0x16) {
-				workreq->result = inb(dev->ioport[c] + 0x0f);
+				workreq->result = atp_readb_io(dev, c, 0x0f);
 				if (((dev->r1f[c][target_id] & 0x10) != 0)&&(dev->dev_id==ATP885_DEVID)) {
 					printk(KERN_WARNING "AEC67162 CRC ERROR !\n");
 					workreq->result = 0x02;
@@ -407,8 +448,8 @@ static irqreturn_t atp870u_intr_handle(int irq, void *dev_id)
 				workreq->result = 0x02;
 
 			if (dev->dev_id == ATP885_DEVID) {		
-				j = inb(dev->baseport + 0x29) | 0x01;
-				outb(j, dev->baseport + 0x29);
+				j = atp_readb_base(dev, 0x29) | 0x01;
+				atp_writeb_base(dev, 0x29, j);
 			}
 			/*
 			 *	Complete the command
@@ -430,10 +471,9 @@ static irqreturn_t atp870u_intr_handle(int irq, void *dev_id)
 			 *      Take it back wide
 			 */
 			if (dev->wide_id[c] != 0) {
-				outb(0x01, dev->ioport[c] + 0x1b);
-				while ((inb(dev->ioport[c] + 0x1b) & 0x01) != 0x01) {
-					outb(0x01, dev->ioport[c] + 0x1b);
-				}       
+				atp_writeb_io(dev, c, 0x1b, 0x01);
+				while ((atp_readb_io(dev, c, 0x1b) & 0x01) != 0x01)
+					atp_writeb_io(dev, c, 0x1b, 0x01);
 			} 
 			/*
 			 *	If there is stuff to send and nothing going then send it
@@ -458,52 +498,51 @@ static irqreturn_t atp870u_intr_handle(int irq, void *dev_id)
 		}
 		i &= 0x0f;
 		if (i == 0x09) {
-			outl(dev->id[c][target_id].prdaddr, dev->pciport[c] + 4);
-			outb(0x06, dev->pciport[c] + 2);
-			outb(0x00, dev->pciport[c] + 2);
-			outb(0x41, dev->ioport[c] + 0x10);
+			atp_writel_pci(dev, c, 4, dev->id[c][target_id].prdaddr);
+			atp_writeb_pci(dev, c, 2, 0x06);
+			atp_writeb_pci(dev, c, 2, 0x00);
+			atp_writeb_io(dev, c, 0x10, 0x41);
 			if (dev->dev_id == ATP885_DEVID) {
 				k = dev->id[c][target_id].last_len;
-				outb((unsigned char) (((unsigned char *) (&k))[2]), dev->ioport[c] + 0x12);
-				outb((unsigned char) (((unsigned char *) (&k))[1]), dev->ioport[c] + 0x13);
-				outb((unsigned char) (((unsigned char *) (&k))[0]), dev->ioport[c] + 0x14);
+				atp_writeb_io(dev, c, 0x12, ((unsigned char *) (&k))[2]);
+				atp_writeb_io(dev, c, 0x13, ((unsigned char *) (&k))[1]);
+				atp_writeb_io(dev, c, 0x14, ((unsigned char *) (&k))[0]);
 				dev->id[c][target_id].dirct = 0x00;
 			} else {
 				dev->id[c][target_id].dirct = 0x00;
 			}
-			outb(0x08, dev->ioport[c] + 0x18);
-			outb(0x09, dev->pciport[c]);
+			atp_writeb_io(dev, c, 0x18, 0x08);
+			atp_writeb_pci(dev, c, 0, 0x09);
 			dev->in_int[c] = 0;
 			return IRQ_HANDLED;
 		}
 		if (i == 0x08) {
-			outl(dev->id[c][target_id].prdaddr, dev->pciport[c] + 4);
-			outb(0x06, dev->pciport[c] + 2);
-			outb(0x00, dev->pciport[c] + 2);
-			outb(0x41, dev->ioport[c] + 0x10);
+			atp_writel_pci(dev, c, 4, dev->id[c][target_id].prdaddr);
+			atp_writeb_pci(dev, c, 2, 0x06);
+			atp_writeb_pci(dev, c, 2, 0x00);
+			atp_writeb_io(dev, c, 0x10, 0x41);
 			if (dev->dev_id == ATP885_DEVID) {		
 				k = dev->id[c][target_id].last_len;
-				outb((unsigned char) (((unsigned char *) (&k))[2]), dev->ioport[c] + 0x12);
-				outb((unsigned char) (((unsigned char *) (&k))[1]), dev->ioport[c] + 0x13);
-				outb((unsigned char) (((unsigned char *) (&k))[0]), dev->ioport[c] + 0x14);
+				atp_writeb_io(dev, c, 0x12, ((unsigned char *) (&k))[2]);
+				atp_writeb_io(dev, c, 0x13, ((unsigned char *) (&k))[1]);
+				atp_writeb_io(dev, c, 0x14, ((unsigned char *) (&k))[0]);
 			}
-			outb((unsigned char) (inb(dev->ioport[c] + 0x15) | 0x20), dev->ioport[c] + 0x15);
+			atp_writeb_io(dev, c, 0x15, atp_readb_io(dev, c, 0x15) | 0x20);
 			dev->id[c][target_id].dirct = 0x20;
-			outb(0x08, dev->ioport[c] + 0x18);
-			outb(0x01, dev->pciport[c]);
+			atp_writeb_io(dev, c, 0x18, 0x08);
+			atp_writeb_pci(dev, c, 0, 0x01);
 			dev->in_int[c] = 0;
 			return IRQ_HANDLED;
 		}
-		if (i == 0x0a) {
-			outb(0x30, dev->ioport[c] + 0x10);
-		} else {
-			outb(0x46, dev->ioport[c] + 0x10);
-		}
+		if (i == 0x0a)
+			atp_writeb_io(dev, c, 0x10, 0x30);
+		else
+			atp_writeb_io(dev, c, 0x10, 0x46);
 		dev->id[c][target_id].dirct = 0x00;
-		outb(0x00, dev->ioport[c] + 0x12);
-		outb(0x00, dev->ioport[c] + 0x13);
-		outb(0x00, dev->ioport[c] + 0x14);
-		outb(0x08, dev->ioport[c] + 0x18);
+		atp_writeb_io(dev, c, 0x12, 0x00);
+		atp_writeb_io(dev, c, 0x13, 0x00);
+		atp_writeb_io(dev, c, 0x14, 0x00);
+		atp_writeb_io(dev, c, 0x18, 0x08);
 	}
 	dev->in_int[c] = 0;
 
@@ -590,9 +629,9 @@ static int atp870u_queuecommand_lck(struct scsi_cmnd *req_p,
 	}
 	dev->quereq[c][dev->quend[c]] = req_p;
 #ifdef ED_DBGP	
-	printk("dev->ioport[c] = %x inb(dev->ioport[c] + 0x1c) = %x dev->in_int[%d] = %d dev->in_snd[%d] = %d\n",dev->ioport[c],inb(dev->ioport[c] + 0x1c),c,dev->in_int[c],c,dev->in_snd[c]);
+	printk("dev->ioport[c] = %x atp_readb_io(dev, c, 0x1c) = %x dev->in_int[%d] = %d dev->in_snd[%d] = %d\n",dev->ioport[c],atp_readb_io(dev, c, 0x1c),c,dev->in_int[c],c,dev->in_snd[c]);
 #endif
-	if ((inb(dev->ioport[c] + 0x1c) == 0) && (dev->in_int[c] == 0) && (dev->in_snd[c] == 0)) {
+	if ((atp_readb_io(dev, c, 0x1c) == 0) && (dev->in_int[c] == 0) && (dev->in_snd[c] == 0)) {
 #ifdef ED_DBGP
 		printk("Call sent_s870(atp870u_queuecommand)\n");
 #endif		
@@ -666,7 +705,7 @@ static void send_s870(struct atp_unit *dev,unsigned char c)
 		dev->id[c][scmd_id(workreq)].curr_req = workreq;
 		dev->last_cmd[c] = scmd_id(workreq);
 	}
-	if ((inb(dev->ioport[c] + 0x1f) & 0xb0) != 0 || inb(dev->ioport[c] + 0x1c) != 0) {
+	if ((atp_readb_io(dev, c, 0x1f) & 0xb0) != 0 || atp_readb_io(dev, c, 0x1c) != 0) {
 #ifdef ED_DBGP
 		printk("Abort to Send\n");
 #endif
@@ -685,8 +724,8 @@ static void send_s870(struct atp_unit *dev,unsigned char c)
 	l = scsi_bufflen(workreq);
 
 	if (dev->dev_id == ATP885_DEVID) {
-		j = inb(dev->baseport + 0x29) & 0xfe;
-		outb(j, dev->baseport + 0x29);
+		j = atp_readb_base(dev, 0x29) & 0xfe;
+		atp_writeb_base(dev, 0x29, j);
 		dev->r1f[c][scmd_id(workreq)] = 0;
 	}
 	
@@ -709,9 +748,9 @@ static void send_s870(struct atp_unit *dev,unsigned char c)
 	if ((w & dev->wide_id[c]) != 0) {
 		j |= 0x01;
 	}
-	outb(j, dev->ioport[c] + 0x1b);
-	while ((inb(dev->ioport[c] + 0x1b) & 0x01) != j) {
-		outb(j,dev->ioport[c] + 0x1b);
+	atp_writeb_io(dev, c, 0x1b, j);
+	while ((atp_readb_io(dev, c, 0x1b) & 0x01) != j) {
+		atp_writeb_pci(dev, c, 0x1b, j);
 #ifdef ED_DBGP
 		printk("send_s870 while loop 1\n");
 #endif
@@ -720,21 +759,19 @@ static void send_s870(struct atp_unit *dev,unsigned char c)
 	 *	Write the command
 	 */
 
-	outb(workreq->cmd_len, dev->ioport[c] + 0x00);
-	outb(0x2c, dev->ioport[c] + 0x01);
-	if (dev->dev_id == ATP885_DEVID) {
-		outb(0x7f, dev->ioport[c] + 0x02);
-	} else {
-		outb(0xcf, dev->ioport[c] + 0x02);
-	}	
-	for (i = 0; i < workreq->cmd_len; i++) {
-		outb(workreq->cmnd[i], dev->ioport[c] + 0x03 + i);
-	}
-	outb(workreq->device->lun, dev->ioport[c] + 0x0f);
+	atp_writeb_io(dev, c, 0x00, workreq->cmd_len);
+	atp_writeb_io(dev, c, 0x01, 0x2c);
+	if (dev->dev_id == ATP885_DEVID)
+		atp_writeb_io(dev, c, 0x02, 0x7f);
+	else
+		atp_writeb_io(dev, c, 0x02, 0xcf);
+	for (i = 0; i < workreq->cmd_len; i++)
+		atp_writeb_io(dev, c, 0x03 + i, workreq->cmnd[i]);
+	atp_writeb_io(dev, c, 0x0f, workreq->device->lun);
 	/*
 	 *	Write the target
 	 */
-	outb(dev->id[c][target_id].devsp, dev->ioport[c] + 0x11);
+	atp_writeb_io(dev, c, 0x11, dev->id[c][target_id].devsp);
 #ifdef ED_DBGP	
 	printk("dev->id[%d][%d].devsp = %2x\n",c,target_id,dev->id[c][target_id].devsp);
 #endif
@@ -743,9 +780,9 @@ static void send_s870(struct atp_unit *dev,unsigned char c)
 	/*
 	 *	Write transfer size
 	 */
-	outb((unsigned char) (((unsigned char *) (&l))[2]), dev->ioport[c] + 0x12);
-	outb((unsigned char) (((unsigned char *) (&l))[1]), dev->ioport[c] + 0x13);
-	outb((unsigned char) (((unsigned char *) (&l))[0]), dev->ioport[c] + 0x14);
+	atp_writeb_io(dev, c, 0x12, ((unsigned char *) (&l))[2]);
+	atp_writeb_io(dev, c, 0x13, ((unsigned char *) (&l))[1]);
+	atp_writeb_io(dev, c, 0x14, ((unsigned char *) (&l))[0]);
 	j = target_id;	
 	dev->id[c][j].last_len = l;
 	dev->id[c][j].tran_len = 0;
@@ -761,23 +798,21 @@ static void send_s870(struct atp_unit *dev,unsigned char c)
 	/*
 	 *	Check transfer direction
 	 */
-	if (workreq->sc_data_direction == DMA_TO_DEVICE) {
-		outb((unsigned char) (j | 0x20), dev->ioport[c] + 0x15);
-	} else {
-		outb(j, dev->ioport[c] + 0x15);
-	}
-	outb((unsigned char) (inb(dev->ioport[c] + 0x16) | 0x80), dev->ioport[c] + 0x16);
-	outb(0x80, dev->ioport[c] + 0x16);
+	if (workreq->sc_data_direction == DMA_TO_DEVICE)
+		atp_writeb_io(dev, c, 0x15, j | 0x20);
+	else
+		atp_writeb_io(dev, c, 0x15, j);
+	atp_writeb_io(dev, c, 0x16, atp_readb_io(dev, c, 0x16) | 0x80);
+	atp_writeb_io(dev, c, 0x16, 0x80);
 	dev->id[c][target_id].dirct = 0;
 	if (l == 0) {
-		if (inb(dev->ioport[c] + 0x1c) == 0) {
+		if (atp_readb_io(dev, c, 0x1c) == 0) {
 #ifdef ED_DBGP
 			printk("change SCSI_CMD_REG 0x08\n");	
 #endif				
-			outb(0x08, dev->ioport[c] + 0x18);
-		} else {
+			atp_writeb_io(dev, c, 0x18, 0x08);
+		} else
 			dev->last_cmd[c] |= 0x40;
-		}
 		dev->in_snd[c] = 0;
 		return;
 	}
@@ -821,36 +856,34 @@ static void send_s870(struct atp_unit *dev,unsigned char c)
 	printk("send_s870: prdaddr_2 0x%8x target_id %d\n", dev->id[c][target_id].prdaddr,target_id);
 #endif	
 	dev->id[c][target_id].prdaddr = dev->id[c][target_id].prd_bus;
-	outl(dev->id[c][target_id].prdaddr, dev->pciport[c] + 4);
-	outb(0x06, dev->pciport[c] + 2);
-	outb(0x00, dev->pciport[c] + 2);
+	atp_writel_pci(dev, c, 4, dev->id[c][target_id].prdaddr);
+	atp_writeb_pci(dev, c, 2, 0x06);
+	atp_writeb_pci(dev, c, 2, 0x00);
 	if (dev->dev_id == ATP885_DEVID) {
-		j = inb(dev->pciport[c] + 1) & 0xf3;
+		j = atp_readb_pci(dev, c, 1) & 0xf3;
 		if ((workreq->cmnd[0] == 0x08) || (workreq->cmnd[0] == 0x28) ||
 	    	(workreq->cmnd[0] == 0x0a) || (workreq->cmnd[0] == 0x2a)) {
 	   		j |= 0x0c;
 		}
-		outb(j, dev->pciport[c] + 1);
+		atp_writeb_pci(dev, c, 1, j);
 	} else if ((dev->dev_id == ATP880_DEVID1) ||
 	    	   (dev->dev_id == ATP880_DEVID2)) {
-		if ((workreq->cmnd[0] == 0x08) || (workreq->cmnd[0] == 0x28) || (workreq->cmnd[0] == 0x0a) || (workreq->cmnd[0] == 0x2a)) {
-			outb((unsigned char) ((inb(dev->ioport[c] - 0x05) & 0x3f) | 0xc0), dev->ioport[c] - 0x05);
-		} else {
-			outb((unsigned char) (inb(dev->ioport[c] - 0x05) & 0x3f), dev->ioport[c] - 0x05);
-		}		
+		if ((workreq->cmnd[0] == 0x08) || (workreq->cmnd[0] == 0x28) || (workreq->cmnd[0] == 0x0a) || (workreq->cmnd[0] == 0x2a))
+			atp_writeb_base(dev, 0x3b, (atp_readb_base(dev, 0x3b) & 0x3f) | 0xc0);
+		else
+			atp_writeb_base(dev, 0x3b, atp_readb_base(dev, 0x3b) & 0x3f);
 	} else {		
-		if ((workreq->cmnd[0] == 0x08) || (workreq->cmnd[0] == 0x28) || (workreq->cmnd[0] == 0x0a) || (workreq->cmnd[0] == 0x2a)) {
-			outb((inb(dev->ioport[c] + 0x3a) & 0xf3) | 0x08, dev->ioport[c] + 0x3a);
-		} else {
-			outb(inb(dev->ioport[c] + 0x3a) & 0xf3, dev->ioport[c] + 0x3a);
-		}		
+		if ((workreq->cmnd[0] == 0x08) || (workreq->cmnd[0] == 0x28) || (workreq->cmnd[0] == 0x0a) || (workreq->cmnd[0] == 0x2a))
+			atp_writeb_io(dev, c, 0x3a, (atp_readb_io(dev, c, 0x3a) & 0xf3) | 0x08);
+		else
+			atp_writeb_io(dev, c, 0x3a, atp_readb_io(dev, c, 0x3a) & 0xf3);
 	}	
 
 	if(workreq->sc_data_direction == DMA_TO_DEVICE) {
 		dev->id[c][target_id].dirct = 0x20;
-		if (inb(dev->ioport[c] + 0x1c) == 0) {
-			outb(0x08, dev->ioport[c] + 0x18);
-			outb(0x01, dev->pciport[c]);
+		if (atp_readb_io(dev, c, 0x1c) == 0) {
+			atp_writeb_io(dev, c, 0x18, 0x08);
+			atp_writeb_pci(dev, c, 0, 0x01);
 #ifdef ED_DBGP		
 		printk( "start DMA(to target)\n");
 #endif				
@@ -860,9 +893,9 @@ static void send_s870(struct atp_unit *dev,unsigned char c)
 		dev->in_snd[c] = 0;
 		return;
 	}
-	if (inb(dev->ioport[c] + 0x1c) == 0) {
-		outb(0x08, dev->ioport[c] + 0x18);
-		outb(0x09, dev->pciport[c]);
+	if (atp_readb_io(dev, c, 0x1c) == 0) {
+		atp_writeb_io(dev, c, 0x18, 0x08);
+		atp_writeb_pci(dev, c, 0, 0x09);
 #ifdef ED_DBGP		
 		printk( "start DMA(to host)\n");
 #endif			
@@ -879,28 +912,28 @@ static unsigned char fun_scam(struct atp_unit *dev, unsigned short int *val)
 	unsigned short int i, k;
 	unsigned char j;
 
-	outw(*val, dev->ioport[0] + 0x1c);
+	atp_writew_io(dev, 0, 0x1c, *val);
 	for (i = 0; i < 10; i++) {	/* stable >= bus settle delay(400 ns)  */
-		k = inw(dev->ioport[0] + 0x1c);
+		k = atp_readw_io(dev, 0, 0x1c);
 		j = (unsigned char) (k >> 8);
 		if ((k & 0x8000) != 0)	/* DB7 all release?    */
 			i = 0;
 	}
 	*val |= 0x4000;		/* assert DB6           */
-	outw(*val, dev->ioport[0] + 0x1c);
+	atp_writew_io(dev, 0, 0x1c, *val);
 	*val &= 0xdfff;		/* assert DB5           */
-	outw(*val, dev->ioport[0] + 0x1c);
+	atp_writew_io(dev, 0, 0x1c, *val);
 	for (i = 0; i < 10; i++) {	/* stable >= bus settle delay(400 ns) */
-		if ((inw(dev->ioport[0] + 0x1c) & 0x2000) != 0)	/* DB5 all release?       */
+		if ((atp_readw_io(dev, 0, 0x1c) & 0x2000) != 0)	/* DB5 all release?       */
 			i = 0;
 	}
 	*val |= 0x8000;		/* no DB4-0, assert DB7    */
 	*val &= 0xe0ff;
-	outw(*val, dev->ioport[0] + 0x1c);
+	atp_writew_io(dev, 0, 0x1c, *val);
 	*val &= 0xbfff;		/* release DB6             */
-	outw(*val, dev->ioport[0] + 0x1c);
+	atp_writew_io(dev, 0, 0x1c, *val);
 	for (i = 0; i < 10; i++) {	/* stable >= bus settle delay(400 ns)  */
-		if ((inw(dev->ioport[0] + 0x1c) & 0x4000) != 0)	/* DB6 all release?  */
+		if ((atp_readw_io(dev, 0, 0x1c) & 0x4000) != 0)	/* DB6 all release?  */
 			i = 0;
 	}
 
@@ -926,9 +959,9 @@ static void tscam(struct Scsi_Host *host)
 	}
  */
 
-	outb(0x08, dev->ioport[0] + 1);
-	outb(0x7f, dev->ioport[0] + 2);
-	outb(0x20, dev->ioport[0] + 0x11);
+	atp_writeb_io(dev, 0, 1, 0x08);
+	atp_writeb_io(dev, 0, 2, 0x7f);
+	atp_writeb_io(dev, 0, 0x11, 0x20);
 
 	if ((dev->scam_on & 0x40) == 0) {
 		return;
@@ -941,13 +974,13 @@ static void tscam(struct Scsi_Host *host)
 		j = 8;
 	}
 	assignid_map = m;
-	outb(0x02, dev->ioport[0] + 0x02);	/* 2*2=4ms,3EH 2/32*3E=3.9ms */
-	outb(0, dev->ioport[0] + 0x03);
-	outb(0, dev->ioport[0] + 0x04);
-	outb(0, dev->ioport[0] + 0x05);
-	outb(0, dev->ioport[0] + 0x06);
-	outb(0, dev->ioport[0] + 0x07);
-	outb(0, dev->ioport[0] + 0x08);
+	atp_writeb_io(dev, 0, 0x02, 0x02);	/* 2*2=4ms,3EH 2/32*3E=3.9ms */
+	atp_writeb_io(dev, 0, 0x03, 0);
+	atp_writeb_io(dev, 0, 0x04, 0);
+	atp_writeb_io(dev, 0, 0x05, 0);
+	atp_writeb_io(dev, 0, 0x06, 0);
+	atp_writeb_io(dev, 0, 0x07, 0);
+	atp_writeb_io(dev, 0, 0x08, 0);
 
 	for (i = 0; i < j; i++) {
 		m = 1;
@@ -955,70 +988,69 @@ static void tscam(struct Scsi_Host *host)
 		if ((m & assignid_map) != 0) {
 			continue;
 		}
-		outb(0, dev->ioport[0] + 0x0f);
-		outb(0, dev->ioport[0] + 0x12);
-		outb(0, dev->ioport[0] + 0x13);
-		outb(0, dev->ioport[0] + 0x14);
+		atp_writeb_io(dev, 0, 0x0f, 0);
+		atp_writeb_io(dev, 0, 0x12, 0);
+		atp_writeb_io(dev, 0, 0x13, 0);
+		atp_writeb_io(dev, 0, 0x14, 0);
 		if (i > 7) {
 			k = (i & 0x07) | 0x40;
 		} else {
 			k = i;
 		}
-		outb(k, dev->ioport[0] + 0x15);
-		if (dev->chip_ver == 4) {
-			outb(0x01, dev->ioport[0] + 0x1b);
-		} else {
-			outb(0x00, dev->ioport[0] + 0x1b);
-		}
+		atp_writeb_io(dev, 0, 0x15, k);
+		if (dev->chip_ver == 4)
+			atp_writeb_io(dev, 0, 0x1b, 0x01);
+		else
+			atp_writeb_io(dev, 0, 0x1b, 0x00);
 		do {
-			outb(0x09, dev->ioport[0] + 0x18);
+			atp_writeb_io(dev, 0, 0x18, 0x09);
 
-			while ((inb(dev->ioport[0] + 0x1f) & 0x80) == 0x00)
+			while ((atp_readb_io(dev, 0, 0x1f) & 0x80) == 0x00)
 				cpu_relax();
-			k = inb(dev->ioport[0] + 0x17);
+			k = atp_readb_io(dev, 0, 0x17);
 			if ((k == 0x85) || (k == 0x42))
 				break;
 			if (k != 0x16)
-				outb(0x41, dev->ioport[0] + 0x10);
+				atp_writeb_io(dev, 0, 0x10, 0x41);
 		} while (k != 0x16);
 		if ((k == 0x85) || (k == 0x42))
 			continue;
 		assignid_map |= m;
 
 	}
-	outb(0x7f, dev->ioport[0] + 0x02);
-	outb(0x02, dev->ioport[0] + 0x1b);
+	atp_writeb_io(dev, 0, 0x02, 0x7f);
+	atp_writeb_io(dev, 0, 0x1b, 0x02);
 
 	outb(0, 0x80);
 
 	val = 0x0080;		/* bsy  */
-	outw(val, dev->ioport[0] + 0x1c);
+	atp_writew_io(dev, 0, 0x1c, val);
 	val |= 0x0040;		/* sel  */
-	outw(val, dev->ioport[0] + 0x1c);
+	atp_writew_io(dev, 0, 0x1c, val);
 	val |= 0x0004;		/* msg  */
-	outw(val, dev->ioport[0] + 0x1c);
+	atp_writew_io(dev, 0, 0x1c, val);
 	inb(0x80);		/* 2 deskew delay(45ns*2=90ns) */
 	val &= 0x007f;		/* no bsy  */
-	outw(val, dev->ioport[0] + 0x1c);
+	atp_writew_io(dev, 0, 0x1c, val);
 	mdelay(128);
 	val &= 0x00fb;		/* after 1ms no msg */
-	outw(val, dev->ioport[0] + 0x1c);
-	while ((inb(dev->ioport[0] + 0x1c) & 0x04) != 0)
+	atp_writew_io(dev, 0, 0x1c, val);
+	while ((atp_readb_io(dev, 0, 0x1c) & 0x04) != 0)
 		;
 	outb(1, 0x80);
 	udelay(100);
 	for (n = 0; n < 0x30000; n++)
-		if ((inb(dev->ioport[0] + 0x1c) & 0x80) != 0)	/* bsy ? */
+		if ((atp_readb_io(dev, 0, 0x1c) & 0x80) != 0)	/* bsy ? */
 			break;
 	if (n < 0x30000)
 		for (n = 0; n < 0x30000; n++)
-			if ((inb(dev->ioport[0] + 0x1c) & 0x81) == 0x0081) {
+			if ((atp_readb_io(dev, 0, 0x1c) & 0x81) == 0x0081) {
 				inb(0x80);
 				val |= 0x8003;		/* io,cd,db7  */
-				outw(val, dev->ioport[0] + 0x1c);
+				atp_writew_io(dev, 0, 0x1c, val);
 				inb(0x80);
 				val &= 0x00bf;		/* no sel     */
-				outw(val, dev->ioport[0] + 0x1c);
+				atp_writew_io(dev, 0, 0x1c, val);
 				outb(2, 0x80);
 				break;
 			}
@@ -1033,14 +1065,14 @@ static void tscam(struct Scsi_Host *host)
 	 */
 	mdelay(2);
 	udelay(48);
-	if ((inb(dev->ioport[0] + 0x1c) & 0x80) == 0x00) {	/* bsy ? */
-		outw(0, dev->ioport[0] + 0x1c);
-		outb(0, dev->ioport[0] + 0x1b);
-		outb(0, dev->ioport[0] + 0x15);
-		outb(0x09, dev->ioport[0] + 0x18);
-		while ((inb(dev->ioport[0] + 0x1f) & 0x80) == 0)
+	if ((atp_readb_io(dev, 0, 0x1c) & 0x80) == 0x00) {	/* bsy ? */
+		atp_writew_io(dev, 0, 0x1c, 0);
+		atp_writeb_io(dev, 0, 0x1b, 0);
+		atp_writeb_io(dev, 0, 0x15, 0);
+		atp_writeb_io(dev, 0, 0x18, 0x09);
+		while ((atp_readb_io(dev, 0, 0x1f) & 0x80) == 0)
 			cpu_relax();
-		inb(dev->ioport[0] + 0x17);
+		atp_readb_io(dev, 0, 0x17);
 		return;
 	}
 	val &= 0x00ff;		/* synchronization  */
@@ -1055,7 +1087,7 @@ static void tscam(struct Scsi_Host *host)
 	j = 0;
 
 	while (1) {
-		if ((inw(dev->ioport[0] + 0x1c) & 0x2000) == 0)
+		if ((atp_readw_io(dev, 0, 0x1c) & 0x2000) == 0)
 			continue;
 		outb(5, 0x80);
 		val &= 0x00ff;		/* get ID_STRING */
@@ -2232,6 +2264,7 @@ static int atp870u_probe(struct pci_dev *pdev, const struct pci_device_id *ent)
 	}
 	base_io = pci_resource_start(pdev, 0);
 	base_io &= 0xfffffff8;
+	atpdev->baseport = base_io;
 
 	if ((ent->device == ATP880_DEVID1)||(ent->device == ATP880_DEVID2)) {
 		atpdev->chip_ver = pdev->revision;
@@ -2356,7 +2389,6 @@ static int atp870u_probe(struct pci_dev *pdev, const struct pci_device_id *ent)
         	
 		atpdev->pdev = pdev;
 		atpdev->dev_id  = ent->device;
-		atpdev->baseport = base_io;
 		atpdev->ioport[0] = base_io + 0x80;
 		atpdev->ioport[1] = base_io + 0xc0;
 		atpdev->pciport[0] = base_io + 0x40;
@@ -2651,12 +2683,12 @@ static int atp870u_abort(struct scsi_cmnd * SCpnt)
 	printk("working=%x last_cmd=%x ", dev->working[c], dev->last_cmd[c]);
 	printk(" quhdu=%x quendu=%x ", dev->quhd[c], dev->quend[c]);
 	for (j = 0; j < 0x18; j++) {
-		printk(" r%2x=%2x", j, inb(dev->ioport[c] + j));
+		printk(" r%2x=%2x", j, atp_readb_io(dev, c, j));
 	}
-	printk(" r1c=%2x", inb(dev->ioport[c] + 0x1c));
-	printk(" r1f=%2x in_snd=%2x ", inb(dev->ioport[c] + 0x1f), dev->in_snd[c]);
-	printk(" d00=%2x", inb(dev->pciport[c]));
-	printk(" d02=%2x", inb(dev->pciport[c] + 0x02));
+	printk(" r1c=%2x", atp_readb_io(dev, c, 0x1c));
+	printk(" r1f=%2x in_snd=%2x ", atp_readb_io(dev, c, 0x1f), dev->in_snd[c]);
+	printk(" d00=%2x", atp_readb_pci(dev, c, 0x00));
+	printk(" d02=%2x", atp_readb_pci(dev, c, 0x02));
 	for(j=0;j<16;j++) {
 	   if (dev->id[c][j].curr_req != NULL) {
 		workrequ = dev->id[c][j].curr_req;

commit c7fcc089b0e49dce9208277871f69e42d8fb1db0
Author: Ondrej Zary <linux@rainbow-software.org>
Date:   Tue Nov 17 19:23:53 2015 +0100

    atp870u: Remove ugly gotos #5
    
    Signed-off-by: Ondrej Zary <linux@rainbow-software.org>
    Reviewed-by: Hannes Reinicke <hare@suse.de>
    Acked-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/atp870u.c b/drivers/scsi/atp870u.c
index 68afe1125166..fd2bb6f035da 100644
--- a/drivers/scsi/atp870u.c
+++ b/drivers/scsi/atp870u.c
@@ -1007,28 +1007,22 @@ static void tscam(struct Scsi_Host *host)
 		;
 	outb(1, 0x80);
 	udelay(100);
-	for (n = 0; n < 0x30000; n++) {
-		if ((inb(dev->ioport[0] + 0x1c) & 0x80) != 0) {	/* bsy ? */
-			goto wait_io;
-		}
-	}
-	goto TCM_SYNC;
-wait_io:
-	for (n = 0; n < 0x30000; n++) {
-		if ((inb(dev->ioport[0] + 0x1c) & 0x81) == 0x0081) {
-			goto wait_io1;
-		}
-	}
-	goto TCM_SYNC;
-wait_io1:
-	inb(0x80);
-	val |= 0x8003;		/* io,cd,db7  */
-	outw(val, dev->ioport[0] + 0x1c);
-	inb(0x80);
-	val &= 0x00bf;		/* no sel     */
-	outw(val, dev->ioport[0] + 0x1c);
-	outb(2, 0x80);
-TCM_SYNC:
+	for (n = 0; n < 0x30000; n++)
+		if ((inb(dev->ioport[0] + 0x1c) & 0x80) != 0)	/* bsy ? */
+			break;
+	if (n < 0x30000)
+		for (n = 0; n < 0x30000; n++)
+			if ((inb(dev->ioport[0] + 0x1c) & 0x81) == 0x0081) {
+				inb(0x80);
+				val |= 0x8003;		/* io,cd,db7  */
+				outw(val, dev->ioport[0] + 0x1c);
+				inb(0x80);
+				val &= 0x00bf;		/* no sel     */
+				outw(val, dev->ioport[0] + 0x1c);
+				outb(2, 0x80);
+				break;
+			}
+	while (1) {
 	/*
 	 * The funny division into multiple delays is to accomodate
 	 * arches like ARM where udelay() multiplies its argument by
@@ -1059,31 +1053,28 @@ static void tscam(struct Scsi_Host *host)
 	outb(4, 0x80);
 	i = 8;
 	j = 0;
-TCM_ID:
-	if ((inw(dev->ioport[0] + 0x1c) & 0x2000) == 0) {
-		goto TCM_ID;
-	}
-	outb(5, 0x80);
-	val &= 0x00ff;		/* get ID_STRING */
-	val |= 0x2000;
-	k = fun_scam(dev, &val);
-	if ((k & 0x03) == 0) {
-		goto TCM_5;
-	}
-	mbuf[j] <<= 0x01;
-	mbuf[j] &= 0xfe;
-	if ((k & 0x02) != 0) {
-		mbuf[j] |= 0x01;
-	}
-	i--;
-	if (i > 0) {
-		goto TCM_ID;
+
+	while (1) {
+		if ((inw(dev->ioport[0] + 0x1c) & 0x2000) == 0)
+			continue;
+		outb(5, 0x80);
+		val &= 0x00ff;		/* get ID_STRING */
+		val |= 0x2000;
+		k = fun_scam(dev, &val);
+		if ((k & 0x03) == 0)
+			break;
+		mbuf[j] <<= 0x01;
+		mbuf[j] &= 0xfe;
+		if ((k & 0x02) != 0)
+			mbuf[j] |= 0x01;
+		i--;
+		if (i > 0)
+			continue;
+		j++;
+		i = 8;
 	}
-	j++;
-	i = 8;
-	goto TCM_ID;
 
-TCM_5:			/* isolation complete..  */
+	/* isolation complete..  */
 /*    mbuf[32]=0;
 	printk(" \n%x %x %x %s\n ",assignid_map,mbuf[0],mbuf[1],&mbuf[2]); */
 	i = 15;
@@ -1091,33 +1082,33 @@ static void tscam(struct Scsi_Host *host)
 	if ((j & 0x20) != 0) {	/* bit5=1:ID up to 7      */
 		i = 7;
 	}
-	if ((j & 0x06) == 0) {	/* IDvalid?             */
-		goto G2Q5;
-	}
-	k = mbuf[1];
-small_id:
-	m = 1;
-	m <<= k;
-	if ((m & assignid_map) == 0) {
-		goto G2Q_QUIN;
-	}
-	if (k > 0) {
-		k--;
-		goto small_id;
-	}
-G2Q5:			/* srch from max acceptable ID#  */
-	k = i;			/* max acceptable ID#            */
-G2Q_LP:
-	m = 1;
-	m <<= k;
-	if ((m & assignid_map) == 0) {
-		goto G2Q_QUIN;
+	if ((j & 0x06) != 0) {	/* IDvalid?             */
+		k = mbuf[1];
+		while (1) {
+			m = 1;
+			m <<= k;
+			if ((m & assignid_map) == 0)
+				break;
+			if (k > 0)
+				k--;
+			else
+				break;
+		}
 	}
-	if (k > 0) {
-		k--;
-		goto G2Q_LP;
+	if ((m & assignid_map) != 0) {	/* srch from max acceptable ID#  */
+		k = i;			/* max acceptable ID#            */
+		while (1) {
+			m = 1;
+			m <<= k;
+			if ((m & assignid_map) == 0)
+				break;
+			if (k > 0)
+				k--;
+			else
+				break;
+		}
 	}
-G2Q_QUIN:		/* k=binID#,       */
+	/* k=binID#,       */
 	assignid_map |= m;
 	if (k < 8) {
 		quintet[0] = 0x38;	/* 1st dft ID<8    */
@@ -1136,8 +1127,7 @@ static void tscam(struct Scsi_Host *host)
 	val |= m;
 	fun_scam(dev, &val);
 
-	goto TCM_SYNC;
-
+	}
 }
 
 static void is870(struct atp_unit *dev, unsigned int wkport)

commit 58c4d046b4d1d5b84875eb73115f3ef092abccce
Author: Ondrej Zary <linux@rainbow-software.org>
Date:   Tue Nov 17 19:23:52 2015 +0100

    atp870u: Remove ugly gotos #4
    
    Signed-off-by: Ondrej Zary <linux@rainbow-software.org>
    Reviewed-by: Hannes Reinicke <hare@suse.de>
    Acked-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/atp870u.c b/drivers/scsi/atp870u.c
index b3d4e9db3c10..68afe1125166 100644
--- a/drivers/scsi/atp870u.c
+++ b/drivers/scsi/atp870u.c
@@ -970,19 +970,19 @@ static void tscam(struct Scsi_Host *host)
 		} else {
 			outb(0x00, dev->ioport[0] + 0x1b);
 		}
-wait_rdyok:
-		outb(0x09, dev->ioport[0] + 0x18);
-
-		while ((inb(dev->ioport[0] + 0x1f) & 0x80) == 0x00)
-			cpu_relax();
-		k = inb(dev->ioport[0] + 0x17);
-		if (k != 0x16) {
-			if ((k == 0x85) || (k == 0x42)) {
-				continue;
-			}
-			outb(0x41, dev->ioport[0] + 0x10);
-			goto wait_rdyok;
-		}
+		do {
+			outb(0x09, dev->ioport[0] + 0x18);
+
+			while ((inb(dev->ioport[0] + 0x1f) & 0x80) == 0x00)
+				cpu_relax();
+			k = inb(dev->ioport[0] + 0x17);
+			if ((k == 0x85) || (k == 0x42))
+				break;
+			if (k != 0x16)
+				outb(0x41, dev->ioport[0] + 0x10);
+		} while (k != 0x16);
+		if ((k == 0x85) || (k == 0x42))
+			continue;
 		assignid_map |= m;
 
 	}
@@ -1003,10 +1003,8 @@ static void tscam(struct Scsi_Host *host)
 	mdelay(128);
 	val &= 0x00fb;		/* after 1ms no msg */
 	outw(val, dev->ioport[0] + 0x1c);
-wait_nomsg:
-	if ((inb(dev->ioport[0] + 0x1c) & 0x04) != 0) {
-		goto wait_nomsg;
-	}
+	while ((inb(dev->ioport[0] + 0x1c) & 0x04) != 0)
+		;
 	outb(1, 0x80);
 	udelay(100);
 	for (n = 0; n < 0x30000; n++) {

commit 832e9ac6de16ea07045ab3a18d7a64bc3fb1231c
Author: Ondrej Zary <linux@rainbow-software.org>
Date:   Tue Nov 17 19:23:51 2015 +0100

    atp870u: Remove ugly gotos #3
    
    Signed-off-by: Ondrej Zary <linux@rainbow-software.org>
    Reviewed-by: Hannes Reinicke <hare@suse.de>
    Acked-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/atp870u.c b/drivers/scsi/atp870u.c
index 999bf74c3a86..b3d4e9db3c10 100644
--- a/drivers/scsi/atp870u.c
+++ b/drivers/scsi/atp870u.c
@@ -880,34 +880,28 @@ static unsigned char fun_scam(struct atp_unit *dev, unsigned short int *val)
 	unsigned char j;
 
 	outw(*val, dev->ioport[0] + 0x1c);
-FUN_D7:
 	for (i = 0; i < 10; i++) {	/* stable >= bus settle delay(400 ns)  */
 		k = inw(dev->ioport[0] + 0x1c);
 		j = (unsigned char) (k >> 8);
-		if ((k & 0x8000) != 0) {	/* DB7 all release?    */
-			goto FUN_D7;
-		}
+		if ((k & 0x8000) != 0)	/* DB7 all release?    */
+			i = 0;
 	}
 	*val |= 0x4000;		/* assert DB6           */
 	outw(*val, dev->ioport[0] + 0x1c);
 	*val &= 0xdfff;		/* assert DB5           */
 	outw(*val, dev->ioport[0] + 0x1c);
-FUN_D5:
 	for (i = 0; i < 10; i++) {	/* stable >= bus settle delay(400 ns) */
-		if ((inw(dev->ioport[0] + 0x1c) & 0x2000) != 0) {	/* DB5 all release?       */
-			goto FUN_D5;
-		}
+		if ((inw(dev->ioport[0] + 0x1c) & 0x2000) != 0)	/* DB5 all release?       */
+			i = 0;
 	}
 	*val |= 0x8000;		/* no DB4-0, assert DB7    */
 	*val &= 0xe0ff;
 	outw(*val, dev->ioport[0] + 0x1c);
 	*val &= 0xbfff;		/* release DB6             */
 	outw(*val, dev->ioport[0] + 0x1c);
-FUN_D6:
 	for (i = 0; i < 10; i++) {	/* stable >= bus settle delay(400 ns)  */
-		if ((inw(dev->ioport[0] + 0x1c) & 0x4000) != 0) {	/* DB6 all release?  */
-			goto FUN_D6;
-		}
+		if ((inw(dev->ioport[0] + 0x1c) & 0x4000) != 0)	/* DB6 all release?  */
+			i = 0;
 	}
 
 	return j;

commit 468b8968157466996b70c610c080c41ae517c61c
Author: Ondrej Zary <linux@rainbow-software.org>
Date:   Tue Nov 17 19:23:50 2015 +0100

    atp870u: Remove ugly gotos #2
    
    Signed-off-by: Ondrej Zary <linux@rainbow-software.org>
    Reviewed-by: Hannes Reinicke <hare@suse.de>
    Acked-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/atp870u.c b/drivers/scsi/atp870u.c
index 886e54ba97ff..999bf74c3a86 100644
--- a/drivers/scsi/atp870u.c
+++ b/drivers/scsi/atp870u.c
@@ -617,7 +617,7 @@ static DEF_SCSI_QCMD(atp870u_queuecommand)
  */
 static void send_s870(struct atp_unit *dev,unsigned char c)
 {
-	struct scsi_cmnd *workreq;
+	struct scsi_cmnd *workreq = NULL;
 	unsigned int i;//,k;
 	unsigned char  j, target_id;
 	unsigned char *prd;
@@ -638,50 +638,42 @@ static void send_s870(struct atp_unit *dev,unsigned char c)
 	if ((dev->last_cmd[c] != 0xff) && ((dev->last_cmd[c] & 0x40) != 0)) {
 		dev->last_cmd[c] &= 0x0f;
 		workreq = dev->id[c][dev->last_cmd[c]].curr_req;
-		if (workreq != NULL) {	/* check NULL pointer */
-		   goto cmd_subp;
-		}
-		dev->last_cmd[c] = 0xff;	
-		if (dev->quhd[c] == dev->quend[c]) {
-		   	dev->in_snd[c] = 0;
-		   	return ;
+		if (!workreq) {
+			dev->last_cmd[c] = 0xff;
+			if (dev->quhd[c] == dev->quend[c]) {
+				dev->in_snd[c] = 0;
+				return;
+			}
 		}
 	}
-	if ((dev->last_cmd[c] != 0xff) && (dev->working[c] != 0)) {
-	     	dev->in_snd[c] = 0;
-	     	return ;
-	}
-	dev->working[c]++;
-	j = dev->quhd[c];
-	dev->quhd[c]++;
-	if (dev->quhd[c] >= qcnt) {
-		dev->quhd[c] = 0;
-	}
-	workreq = dev->quereq[c][dev->quhd[c]];
-	if (dev->id[c][scmd_id(workreq)].curr_req == NULL) {
+	if (!workreq) {
+		if ((dev->last_cmd[c] != 0xff) && (dev->working[c] != 0)) {
+			dev->in_snd[c] = 0;
+			return;
+		}
+		dev->working[c]++;
+		j = dev->quhd[c];
+		dev->quhd[c]++;
+		if (dev->quhd[c] >= qcnt)
+			dev->quhd[c] = 0;
+		workreq = dev->quereq[c][dev->quhd[c]];
+		if (dev->id[c][scmd_id(workreq)].curr_req != NULL) {
+			dev->quhd[c] = j;
+			dev->working[c]--;
+			dev->in_snd[c] = 0;
+			return;
+		}
 		dev->id[c][scmd_id(workreq)].curr_req = workreq;
 		dev->last_cmd[c] = scmd_id(workreq);
-		goto cmd_subp;
-	}	
-	dev->quhd[c] = j;
-	dev->working[c]--;
-	dev->in_snd[c] = 0;
-	return;
-cmd_subp:
-	if ((inb(dev->ioport[c] + 0x1f) & 0xb0) != 0) {
-		goto abortsnd;
-	}
-	if (inb(dev->ioport[c] + 0x1c) == 0) {
-		goto oktosend;
 	}
-abortsnd:
+	if ((inb(dev->ioport[c] + 0x1f) & 0xb0) != 0 || inb(dev->ioport[c] + 0x1c) != 0) {
 #ifdef ED_DBGP
-	printk("Abort to Send\n");
+		printk("Abort to Send\n");
 #endif
-	dev->last_cmd[c] |= 0x40;
-	dev->in_snd[c] = 0;
-	return;
-oktosend:
+		dev->last_cmd[c] |= 0x40;
+		dev->in_snd[c] = 0;
+		return;
+	}
 #ifdef ED_DBGP
 	printk("OK to Send\n");
 	scmd_printk(KERN_DEBUG, workreq, "CDB");

commit 78614ecdda717ac4afa2764bec622b50400a1dc3
Author: Ondrej Zary <linux@rainbow-software.org>
Date:   Tue Nov 17 19:23:49 2015 +0100

    atp870u: Remove ugly gotos
    
    Signed-off-by: Ondrej Zary <linux@rainbow-software.org>
    Reviewed-by: Hannes Reinicke <hare@suse.de>
    Acked-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/atp870u.c b/drivers/scsi/atp870u.c
index 4d840a59afa3..886e54ba97ff 100644
--- a/drivers/scsi/atp870u.c
+++ b/drivers/scsi/atp870u.c
@@ -55,20 +55,17 @@ static irqreturn_t atp870u_intr_handle(int irq, void *dev_id)
 #ifdef ED_DBGP
 	unsigned long l;
 #endif
-	int errstus;
 	struct Scsi_Host *host = dev_id;
 	struct atp_unit *dev = (struct atp_unit *)&host->hostdata;
 
 	for (c = 0; c < 2; c++) {
 		j = inb(dev->ioport[c] + 0x1f);
 		if ((j & 0x80) != 0)
-		{			
-	   		goto ch_sel;
-		}
+			break;
 		dev->in_int[c] = 0;
 	}
-	return IRQ_NONE;
-ch_sel:
+	if ((j & 0x80) == 0)
+		return IRQ_NONE;
 #ifdef ED_DBGP	
 	printk("atp870u_intr_handle enter\n");
 #endif	
@@ -82,15 +79,12 @@ static irqreturn_t atp870u_intr_handle(int irq, void *dev_id)
 		if ((inb(dev->pciport[c]) & 0x08) != 0)
 		{
 			for (k=0; k < 1000; k++) {
-				if ((inb(dev->pciport[c] + 2) & 0x08) == 0) {
-					goto stop_dma;
-				}
-				if ((inb(dev->pciport[c] + 2) & 0x01) == 0) {
-					goto stop_dma;
-				}
+				if ((inb(dev->pciport[c] + 2) & 0x08) == 0)
+					break;
+				if ((inb(dev->pciport[c] + 2) & 0x01) == 0)
+					break;
 			}
 		}
-stop_dma:
 		outb(0x00, dev->pciport[c]);
 		
 		i = inb(dev->ioport[c] + 0x17);
@@ -170,13 +164,13 @@ static irqreturn_t atp870u_intr_handle(int irq, void *dev_id)
 #ifdef ED_DBGP
 				printk("Status 0x85 return\n");
 #endif				
-			goto handled;
+			return IRQ_HANDLED;
 		}
 
 		if (i == 0x40) {
 		     dev->last_cmd[c] |= 0x40;
 		     dev->in_int[c] = 0;
-		     goto handled;
+		     return IRQ_HANDLED;
 		}
 
 		if (i == 0x21) {
@@ -194,7 +188,7 @@ static irqreturn_t atp870u_intr_handle(int irq, void *dev_id)
 			outb(0x41, dev->ioport[c] + 0x10);
 			outb(0x08, dev->ioport[c] + 0x18);
 			dev->in_int[c] = 0;
-			goto handled;
+			return IRQ_HANDLED;
 		}
 
 		if (dev->dev_id == ATP885_DEVID) {
@@ -231,7 +225,7 @@ static irqreturn_t atp870u_intr_handle(int irq, void *dev_id)
 					dev->id[c][target_id].last_len = adrcnt;
 					outb(0x08, dev->ioport[c] + 0x18);
 					dev->in_int[c] = 0;
-					goto handled;
+					return IRQ_HANDLED;
 				} else {
 #ifdef ED_DBGP
 					printk("cmdp != 0x41\n");
@@ -243,7 +237,7 @@ static irqreturn_t atp870u_intr_handle(int irq, void *dev_id)
 					outb(0x00, dev->ioport[c] + 0x14);
 					outb(0x08, dev->ioport[c] + 0x18);
 					dev->in_int[c] = 0;
-					goto handled;
+					return IRQ_HANDLED;
 				}
 			}
 			if (dev->last_cmd[c] != 0xff) {
@@ -336,7 +330,7 @@ static irqreturn_t atp870u_intr_handle(int irq, void *dev_id)
 #ifdef ED_DBGP
 				printk("dev->id[c][target_id].last_len = 0\n");
 #endif					
-				goto handled;
+				return IRQ_HANDLED;
 			}
 #ifdef ED_DBGP
 			printk("target_id = %d adrcnt = %d\n",target_id,adrcnt);
@@ -382,7 +376,7 @@ static irqreturn_t atp870u_intr_handle(int irq, void *dev_id)
 #ifdef ED_DBGP
 				printk("status 0x80 return dirct != 0\n");
 #endif				
-				goto handled;
+				return IRQ_HANDLED;
 			}
 			outb(0x08, dev->ioport[c] + 0x18);
 			outb(0x09, dev->pciport[c]);
@@ -390,7 +384,7 @@ static irqreturn_t atp870u_intr_handle(int irq, void *dev_id)
 #ifdef ED_DBGP
 			printk("status 0x80 return dirct = 0\n");
 #endif			
-			goto handled;
+			return IRQ_HANDLED;
 		}
 
 		/*
@@ -399,27 +393,19 @@ static irqreturn_t atp870u_intr_handle(int irq, void *dev_id)
 
 		workreq = dev->id[c][target_id].curr_req;
 
-		if (i == 0x42) {
-			if ((dev->last_cmd[c] & 0xf0) != 0x40)
-			{
-			   dev->last_cmd[c] = 0xff;
-			}
-			errstus = 0x02;
-			workreq->result = errstus;
-			goto go_42;
-		}
-		if (i == 0x16) {
+		if (i == 0x42 || i == 0x16) {
 			if ((dev->last_cmd[c] & 0xf0) != 0x40) {
 			   dev->last_cmd[c] = 0xff;
 			}
-			errstus = 0;
-			errstus = inb(dev->ioport[c] + 0x0f);
-			if (((dev->r1f[c][target_id] & 0x10) != 0)&&(dev->dev_id==ATP885_DEVID)) {
-			   printk(KERN_WARNING "AEC67162 CRC ERROR !\n");
-			   errstus = 0x02;
-			}
-			workreq->result = errstus;
-go_42:
+			if (i == 0x16) {
+				workreq->result = inb(dev->ioport[c] + 0x0f);
+				if (((dev->r1f[c][target_id] & 0x10) != 0)&&(dev->dev_id==ATP885_DEVID)) {
+					printk(KERN_WARNING "AEC67162 CRC ERROR !\n");
+					workreq->result = 0x02;
+				}
+			} else
+				workreq->result = 0x02;
+
 			if (dev->dev_id == ATP885_DEVID) {		
 				j = inb(dev->baseport + 0x29) | 0x01;
 				outb(j, dev->baseport + 0x29);
@@ -462,7 +448,7 @@ static irqreturn_t atp870u_intr_handle(int irq, void *dev_id)
 			}
 			spin_unlock_irqrestore(dev->host->host_lock, flags);
 			dev->in_int[c] = 0;
-			goto handled;
+			return IRQ_HANDLED;
 		}
 		if ((dev->last_cmd[c] & 0xf0) != 0x40) {
 		   dev->last_cmd[c] = 0xff;
@@ -488,7 +474,7 @@ static irqreturn_t atp870u_intr_handle(int irq, void *dev_id)
 			outb(0x08, dev->ioport[c] + 0x18);
 			outb(0x09, dev->pciport[c]);
 			dev->in_int[c] = 0;
-			goto handled;
+			return IRQ_HANDLED;
 		}
 		if (i == 0x08) {
 			outl(dev->id[c][target_id].prdaddr, dev->pciport[c] + 4);
@@ -506,7 +492,7 @@ static irqreturn_t atp870u_intr_handle(int irq, void *dev_id)
 			outb(0x08, dev->ioport[c] + 0x18);
 			outb(0x01, dev->pciport[c]);
 			dev->in_int[c] = 0;
-			goto handled;
+			return IRQ_HANDLED;
 		}
 		if (i == 0x0a) {
 			outb(0x30, dev->ioport[c] + 0x10);
@@ -518,19 +504,9 @@ static irqreturn_t atp870u_intr_handle(int irq, void *dev_id)
 		outb(0x00, dev->ioport[c] + 0x13);
 		outb(0x00, dev->ioport[c] + 0x14);
 		outb(0x08, dev->ioport[c] + 0x18);
-		dev->in_int[c] = 0;
-		goto handled;
-	} else {
-//		inb(dev->ioport[c] + 0x17);
-//		dev->working[c] = 0;
-		dev->in_int[c] = 0;
-		goto handled;
 	}
-	
-handled:
-#ifdef ED_DBGP
-	printk("atp870u_intr_handle exit\n");
-#endif			
+	dev->in_int[c] = 0;
+
 	return IRQ_HANDLED;
 }
 /**

commit c2bab4031b528b4a5a665a499fd87c2440758b00
Author: Ondrej Zary <linux@rainbow-software.org>
Date:   Tue Nov 17 19:23:48 2015 +0100

    atp870u: Untangle tmpcip #2
    
    Untangle the tmpcip crap so it becomes obvious what ports are accessed.
    
    Signed-off-by: Ondrej Zary <linux@rainbow-software.org>
    Reviewed-by: Hannes Reinicke <hare@suse.de>
    Acked-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/atp870u.c b/drivers/scsi/atp870u.c
index 32544bb5c88d..4d840a59afa3 100644
--- a/drivers/scsi/atp870u.c
+++ b/drivers/scsi/atp870u.c
@@ -645,7 +645,7 @@ static void send_s870(struct atp_unit *dev,unsigned char c)
 	unsigned int i;//,k;
 	unsigned char  j, target_id;
 	unsigned char *prd;
-	unsigned short int tmpcip, w;
+	unsigned short int w;
 	unsigned long l, bttl = 0;
 	unsigned long  sg_count;
 
@@ -813,7 +813,6 @@ static void send_s870(struct atp_unit *dev,unsigned char c)
 		dev->in_snd[c] = 0;
 		return;
 	}
-	tmpcip = dev->pciport[c];
 	prd = dev->id[c][target_id].prd_table;
 	dev->id[c][target_id].prd_pos = prd;
 
@@ -850,34 +849,28 @@ static void send_s870(struct atp_unit *dev,unsigned char c)
 		printk("2. bttl %x, l %x\n",bttl, l);
 #endif			
 	}
-	tmpcip += 4;
 #ifdef ED_DBGP		
-	printk("send_s870: prdaddr_2 0x%8x tmpcip %x target_id %d\n", dev->id[c][target_id].prdaddr,tmpcip,target_id);
+	printk("send_s870: prdaddr_2 0x%8x target_id %d\n", dev->id[c][target_id].prdaddr,target_id);
 #endif	
 	dev->id[c][target_id].prdaddr = dev->id[c][target_id].prd_bus;
-	outl(dev->id[c][target_id].prdaddr, tmpcip);
-	tmpcip = tmpcip - 2;
-	outb(0x06, tmpcip);
-	outb(0x00, tmpcip);
+	outl(dev->id[c][target_id].prdaddr, dev->pciport[c] + 4);
+	outb(0x06, dev->pciport[c] + 2);
+	outb(0x00, dev->pciport[c] + 2);
 	if (dev->dev_id == ATP885_DEVID) {
-		tmpcip--;
-		j=inb(tmpcip) & 0xf3;
+		j = inb(dev->pciport[c] + 1) & 0xf3;
 		if ((workreq->cmnd[0] == 0x08) || (workreq->cmnd[0] == 0x28) ||
 	    	(workreq->cmnd[0] == 0x0a) || (workreq->cmnd[0] == 0x2a)) {
 	   		j |= 0x0c;
 		}
-		outb(j,tmpcip);
-		tmpcip--;	    	
+		outb(j, dev->pciport[c] + 1);
 	} else if ((dev->dev_id == ATP880_DEVID1) ||
 	    	   (dev->dev_id == ATP880_DEVID2)) {
-		tmpcip =tmpcip -2;	
 		if ((workreq->cmnd[0] == 0x08) || (workreq->cmnd[0] == 0x28) || (workreq->cmnd[0] == 0x0a) || (workreq->cmnd[0] == 0x2a)) {
 			outb((unsigned char) ((inb(dev->ioport[c] - 0x05) & 0x3f) | 0xc0), dev->ioport[c] - 0x05);
 		} else {
 			outb((unsigned char) (inb(dev->ioport[c] - 0x05) & 0x3f), dev->ioport[c] - 0x05);
 		}		
 	} else {		
-		tmpcip =tmpcip -2;
 		if ((workreq->cmnd[0] == 0x08) || (workreq->cmnd[0] == 0x28) || (workreq->cmnd[0] == 0x0a) || (workreq->cmnd[0] == 0x2a)) {
 			outb((inb(dev->ioport[c] + 0x3a) & 0xf3) | 0x08, dev->ioport[c] + 0x3a);
 		} else {
@@ -889,7 +882,7 @@ static void send_s870(struct atp_unit *dev,unsigned char c)
 		dev->id[c][target_id].dirct = 0x20;
 		if (inb(dev->ioport[c] + 0x1c) == 0) {
 			outb(0x08, dev->ioport[c] + 0x18);
-			outb(0x01, tmpcip);
+			outb(0x01, dev->pciport[c]);
 #ifdef ED_DBGP		
 		printk( "start DMA(to target)\n");
 #endif				
@@ -901,7 +894,7 @@ static void send_s870(struct atp_unit *dev,unsigned char c)
 	}
 	if (inb(dev->ioport[c] + 0x1c) == 0) {
 		outb(0x08, dev->ioport[c] + 0x18);
-		outb(0x09, tmpcip);
+		outb(0x09, dev->pciport[c]);
 #ifdef ED_DBGP		
 		printk( "start DMA(to host)\n");
 #endif			

commit bc0fe4c91cdc7e211ca7dafd9039d3bf40a41e3b
Author: Ondrej Zary <linux@rainbow-software.org>
Date:   Tue Nov 17 19:23:47 2015 +0100

    atp870u: Untangle tmpcip
    
    Untangle the tmpcip crap so it becomes obvious what ports are accessed.
    
    Signed-off-by: Ondrej Zary <linux@rainbow-software.org>
    Reviewed-by: Hannes Reinicke <hare@suse.de>
    Acked-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/atp870u.c b/drivers/scsi/atp870u.c
index 993442d65a0e..32544bb5c88d 100644
--- a/drivers/scsi/atp870u.c
+++ b/drivers/scsi/atp870u.c
@@ -47,7 +47,7 @@ static void tscam_885(void);
 static irqreturn_t atp870u_intr_handle(int irq, void *dev_id)
 {
 	unsigned long flags;
-	unsigned short int tmpcip, id;
+	unsigned short int id;
 	unsigned char i, j, c, target_id, lun,cmdp;
 	unsigned char *prd;
 	struct scsi_cmnd *workreq;
@@ -79,30 +79,24 @@ static irqreturn_t atp870u_intr_handle(int irq, void *dev_id)
 			if ((inb(dev->ioport[c] + 0x16) & 0x80) == 0)
 				outb((inb(dev->ioport[c] + 0x16) | 0x80), dev->ioport[c] + 0x16);
 		}		
-		tmpcip = dev->pciport[c];
-		if ((inb(tmpcip) & 0x08) != 0)
+		if ((inb(dev->pciport[c]) & 0x08) != 0)
 		{
-			tmpcip += 0x2;
 			for (k=0; k < 1000; k++) {
-				if ((inb(tmpcip) & 0x08) == 0) {
+				if ((inb(dev->pciport[c] + 2) & 0x08) == 0) {
 					goto stop_dma;
 				}
-				if ((inb(tmpcip) & 0x01) == 0) {
+				if ((inb(dev->pciport[c] + 2) & 0x01) == 0) {
 					goto stop_dma;
 				}
 			}
 		}
 stop_dma:
-		tmpcip = dev->pciport[c];
-		outb(0x00, tmpcip);
+		outb(0x00, dev->pciport[c]);
 		
 		i = inb(dev->ioport[c] + 0x17);
 		
-		if (dev->dev_id == ATP885_DEVID) {
-			tmpcip += 2;
-			outb(0x06, tmpcip);
-			tmpcip -= 2;
-		}
+		if (dev->dev_id == ATP885_DEVID)
+			outb(0x06, dev->pciport[c] + 2);
 
 		target_id = inb(dev->ioport[c] + 0x15);
 
@@ -303,13 +297,12 @@ static irqreturn_t atp870u_intr_handle(int irq, void *dev_id)
 			
 			/* enable 32 bit fifo transfer */	
 			if (dev->dev_id == ATP885_DEVID) {
-				tmpcip = dev->pciport[c] + 1;
-				i=inb(tmpcip) & 0xf3;
+				i=inb(dev->pciport[c] + 1) & 0xf3;
 				//j=workreq->cmnd[0];	    		    	
 				if ((workreq->cmnd[0] == 0x08) || (workreq->cmnd[0] == 0x28) || (workreq->cmnd[0] == 0x0a) || (workreq->cmnd[0] == 0x2a)) {
 				   i |= 0x0c;
 				}
-				outb(i,tmpcip);		    		    		
+				outb(i, dev->pciport[c] + 1);
 			} else if ((dev->dev_id == ATP880_DEVID1) ||
 	    		    	   (dev->dev_id == ATP880_DEVID2) ) {
 				if ((workreq->cmnd[0] == 0x08) || (workreq->cmnd[0] == 0x28) || (workreq->cmnd[0] == 0x0a) || (workreq->cmnd[0] == 0x2a)) {
@@ -371,25 +364,20 @@ static irqreturn_t atp870u_intr_handle(int irq, void *dev_id)
 					}
 				}				
 			}
-			tmpcip = dev->pciport[c] + 0x04;
-			outl(dev->id[c][target_id].prdaddr, tmpcip);
+			outl(dev->id[c][target_id].prdaddr, dev->pciport[c] + 0x04);
 #ifdef ED_DBGP
 			printk("dev->id[%d][%d].prdaddr 0x%8x\n", c, target_id, dev->id[c][target_id].prdaddr);
 #endif
-			if (dev->dev_id == ATP885_DEVID) {
-				tmpcip -= 0x04;
-			} else {
-				tmpcip -= 0x02;
-				outb(0x06, tmpcip);
-				outb(0x00, tmpcip);
-				tmpcip -= 0x02;
+			if (dev->dev_id != ATP885_DEVID) {
+				outb(0x06, dev->pciport[c] + 2);
+				outb(0x00, dev->pciport[c] + 2);
 			}
 			/*
 			 *	Check transfer direction
 			 */
 			if (dev->id[c][target_id].dirct != 0) {
 				outb(0x08, dev->ioport[c] + 0x18);
-				outb(0x01, tmpcip);
+				outb(0x01, dev->pciport[c]);
 				dev->in_int[c] = 0;
 #ifdef ED_DBGP
 				printk("status 0x80 return dirct != 0\n");
@@ -397,7 +385,7 @@ static irqreturn_t atp870u_intr_handle(int irq, void *dev_id)
 				goto handled;
 			}
 			outb(0x08, dev->ioport[c] + 0x18);
-			outb(0x09, tmpcip);
+			outb(0x09, dev->pciport[c]);
 			dev->in_int[c] = 0;
 #ifdef ED_DBGP
 			printk("status 0x80 return dirct = 0\n");
@@ -484,12 +472,9 @@ static irqreturn_t atp870u_intr_handle(int irq, void *dev_id)
 		}
 		i &= 0x0f;
 		if (i == 0x09) {
-			tmpcip += 4;
-			outl(dev->id[c][target_id].prdaddr, tmpcip);
-			tmpcip = tmpcip - 2;
-			outb(0x06, tmpcip);
-			outb(0x00, tmpcip);
-			tmpcip = tmpcip - 2;
+			outl(dev->id[c][target_id].prdaddr, dev->pciport[c] + 4);
+			outb(0x06, dev->pciport[c] + 2);
+			outb(0x00, dev->pciport[c] + 2);
 			outb(0x41, dev->ioport[c] + 0x10);
 			if (dev->dev_id == ATP885_DEVID) {
 				k = dev->id[c][target_id].last_len;
@@ -501,17 +486,14 @@ static irqreturn_t atp870u_intr_handle(int irq, void *dev_id)
 				dev->id[c][target_id].dirct = 0x00;
 			}
 			outb(0x08, dev->ioport[c] + 0x18);
-			outb(0x09, tmpcip);
+			outb(0x09, dev->pciport[c]);
 			dev->in_int[c] = 0;
 			goto handled;
 		}
 		if (i == 0x08) {
-			tmpcip += 4;
-			outl(dev->id[c][target_id].prdaddr, tmpcip);
-			tmpcip = tmpcip - 2;
-			outb(0x06, tmpcip);
-			outb(0x00, tmpcip);
-			tmpcip = tmpcip - 2;
+			outl(dev->id[c][target_id].prdaddr, dev->pciport[c] + 4);
+			outb(0x06, dev->pciport[c] + 2);
+			outb(0x00, dev->pciport[c] + 2);
 			outb(0x41, dev->ioport[c] + 0x10);
 			if (dev->dev_id == ATP885_DEVID) {		
 				k = dev->id[c][target_id].last_len;
@@ -522,7 +504,7 @@ static irqreturn_t atp870u_intr_handle(int irq, void *dev_id)
 			outb((unsigned char) (inb(dev->ioport[c] + 0x15) | 0x20), dev->ioport[c] + 0x15);
 			dev->id[c][target_id].dirct = 0x20;
 			outb(0x08, dev->ioport[c] + 0x18);
-			outb(0x01, tmpcip);
+			outb(0x01, dev->pciport[c]);
 			dev->in_int[c] = 0;
 			goto handled;
 		}

commit e2c22b45cb8feb00f2b8296e277d98485882ed92
Author: Ondrej Zary <linux@rainbow-software.org>
Date:   Tue Nov 17 19:23:46 2015 +0100

    atp870u: Untangle tmport #8
    
    Untangle the tmport crap so it becomes obvious what ports are accessed.
    
    Signed-off-by: Ondrej Zary <linux@rainbow-software.org>
    Reviewed-by: Hannes Reinicke <hare@suse.de>
    Acked-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/atp870u.c b/drivers/scsi/atp870u.c
index f5a11f49bfad..993442d65a0e 100644
--- a/drivers/scsi/atp870u.c
+++ b/drivers/scsi/atp870u.c
@@ -2870,7 +2870,6 @@ static void tscam_885(void)
 
 static void is885(struct atp_unit *dev, unsigned int wkport,unsigned char c)
 {
-	unsigned int tmport;
 	unsigned char i, j, k, rmb, n, lvdmode;
 	unsigned short int m;
 	static unsigned char mbuf[512];
@@ -2895,123 +2894,93 @@ static void is885(struct atp_unit *dev, unsigned int wkport,unsigned char c)
 			printk(KERN_INFO "         ID: %2d  Host Adapter\n", dev->host_id[c]);
 			continue;
 		}
-		tmport = wkport + 0x1b;
-		outb(0x01, tmport);
-		tmport = wkport + 0x01;
-		outb(0x08, tmport++);
-		outb(0x7f, tmport++);
-		outb(satn[0], tmport++);
-		outb(satn[1], tmport++);
-		outb(satn[2], tmport++);
-		outb(satn[3], tmport++);
-		outb(satn[4], tmport++);
-		outb(satn[5], tmport++);
-		tmport += 0x06;
-		outb(0, tmport);
-		tmport += 0x02;
-		outb(dev->id[c][i].devsp, tmport++);
+		outb(0x01, wkport + 0x1b);
+		outb(0x08, wkport + 0x01);
+		outb(0x7f, wkport + 0x02);
+		outb(satn[0], wkport + 0x03);
+		outb(satn[1], wkport + 0x04);
+		outb(satn[2], wkport + 0x05);
+		outb(satn[3], wkport + 0x06);
+		outb(satn[4], wkport + 0x07);
+		outb(satn[5], wkport + 0x08);
+		outb(0, wkport + 0x0f);
+		outb(dev->id[c][i].devsp, wkport + 0x11);
 		
-		outb(0, tmport++);
-		outb(satn[6], tmport++);
-		outb(satn[7], tmport++);
+		outb(0, wkport + 0x12);
+		outb(satn[6], wkport + 0x13);
+		outb(satn[7], wkport + 0x14);
 		j = i;
 		if ((j & 0x08) != 0) {
 			j = (j & 0x07) | 0x40;
 		}
-		outb(j, tmport);
-		tmport += 0x03;
-		outb(satn[8], tmport);
-		tmport += 0x07;
+		outb(j, wkport + 0x15);
+		outb(satn[8], wkport + 0x18);
 
-		while ((inb(tmport) & 0x80) == 0x00)
+		while ((inb(wkport + 0x1f) & 0x80) == 0x00)
 			cpu_relax();
-		tmport -= 0x08;
-		if ((inb(tmport) != 0x11) && (inb(tmport) != 0x8e)) {
+		if ((inb(wkport + 0x17) != 0x11) && (inb(wkport + 0x17) != 0x8e)) {
 			continue;
 		}
-		while (inb(tmport) != 0x8e)
+		while (inb(wkport + 0x17) != 0x8e)
 			cpu_relax();
 		dev->active_id[c] |= m;
 
-		tmport = wkport + 0x10;
-		outb(0x30, tmport);
-		tmport = wkport + 0x14;
-		outb(0x00, tmport);
+		outb(0x30, wkport + 0x10);
+		outb(0x00, wkport + 0x14);
 
 phase_cmd:
-		tmport = wkport + 0x18;
-		outb(0x08, tmport);
-		tmport += 0x07;
-		while ((inb(tmport) & 0x80) == 0x00)
+		outb(0x08, wkport + 0x18);
+		while ((inb(wkport + 0x1f) & 0x80) == 0x00)
 			cpu_relax();
-		tmport -= 0x08;
-		j = inb(tmport);
+		j = inb(wkport + 0x17);
 		if (j != 0x16) {
-			tmport = wkport + 0x10;
-			outb(0x41, tmport);
+			outb(0x41, wkport + 0x10);
 			goto phase_cmd;
 		}
 sel_ok:
-		tmport = wkport + 0x03;
-		outb(inqd[0], tmport++);
-		outb(inqd[1], tmport++);
-		outb(inqd[2], tmport++);
-		outb(inqd[3], tmport++);
-		outb(inqd[4], tmport++);
-		outb(inqd[5], tmport);
-		tmport += 0x07;
-		outb(0, tmport);
-		tmport += 0x02;
-		outb(dev->id[c][i].devsp, tmport++);
-		outb(0, tmport++);
-		outb(inqd[6], tmport++);
-		outb(inqd[7], tmport++);
-		tmport += 0x03;
-		outb(inqd[8], tmport);
-		tmport += 0x07;
-		while ((inb(tmport) & 0x80) == 0x00)
+		outb(inqd[0], wkport + 0x03);
+		outb(inqd[1], wkport + 0x04);
+		outb(inqd[2], wkport + 0x05);
+		outb(inqd[3], wkport + 0x06);
+		outb(inqd[4], wkport + 0x07);
+		outb(inqd[5], wkport + 0x08);
+		outb(0, wkport + 0x0f);
+		outb(dev->id[c][i].devsp, wkport + 0x11);
+		outb(0, wkport + 0x12);
+		outb(inqd[6], wkport + 0x13);
+		outb(inqd[7], wkport + 0x14);
+		outb(inqd[8], wkport + 0x18);
+		while ((inb(wkport + 0x1f) & 0x80) == 0x00)
 			cpu_relax();
-		tmport -= 0x08;
-		if ((inb(tmport) != 0x11) && (inb(tmport) != 0x8e)) {
+		if ((inb(wkport + 0x17) != 0x11) && (inb(wkport + 0x17) != 0x8e)) {
 			continue;
 		}
-		while (inb(tmport) != 0x8e)
+		while (inb(wkport + 0x17) != 0x8e)
 			cpu_relax();
-		tmport = wkport + 0x1b;
-		outb(0x00, tmport);
-		tmport = wkport + 0x18;
-		outb(0x08, tmport);
-		tmport += 0x07;
+		outb(0x00, wkport + 0x1b);
+		outb(0x08, wkport + 0x18);
 		j = 0;
 rd_inq_data:
-		k = inb(tmport);
+		k = inb(wkport + 0x1f);
 		if ((k & 0x01) != 0) {
-			tmport -= 0x06;
-			mbuf[j++] = inb(tmport);
-			tmport += 0x06;
+			mbuf[j++] = inb(wkport + 0x19);
 			goto rd_inq_data;
 		}
 		if ((k & 0x80) == 0) {
 			goto rd_inq_data;
 		}
-		tmport -= 0x08;
-		j = inb(tmport);
+		j = inb(wkport + 0x17);
 		if (j == 0x16) {
 			goto inq_ok;
 		}
-		tmport = wkport + 0x10;
-		outb(0x46, tmport);
-		tmport += 0x02;
-		outb(0, tmport++);
-		outb(0, tmport++);
-		outb(0, tmport++);
-		tmport += 0x03;
-		outb(0x08, tmport);
-		tmport += 0x07;
-		while ((inb(tmport) & 0x80) == 0x00)
+		outb(0x46, wkport + 0x10);
+		outb(0, wkport + 0x12);
+		outb(0, wkport + 0x13);
+		outb(0, wkport + 0x14);
+		outb(0x08, wkport + 0x18);
+		while ((inb(wkport + 0x1f) & 0x80) == 0x00)
 			cpu_relax();
-		tmport -= 0x08;
-		if (inb(tmport) != 0x16) {
+		if (inb(wkport + 0x17) != 0x16) {
 			goto sel_ok;
 		}
 inq_ok:
@@ -3033,54 +3002,40 @@ static void is885(struct atp_unit *dev, unsigned int wkport,unsigned char c)
 		   goto chg_wide;
 		}
 
-		tmport = wkport + 0x1b;
-		outb(0x01, tmport);
-		tmport = wkport + 0x03;
-		outb(satn[0], tmport++);
-		outb(satn[1], tmport++);
-		outb(satn[2], tmport++);
-		outb(satn[3], tmport++);
-		outb(satn[4], tmport++);
-		outb(satn[5], tmport++);
-		tmport += 0x06;
-		outb(0, tmport);
-		tmport += 0x02;
-		outb(dev->id[c][i].devsp, tmport++);
-		outb(0, tmport++);
-		outb(satn[6], tmport++);
-		outb(satn[7], tmport++);
-		tmport += 0x03;
-		outb(satn[8], tmport);
-		tmport += 0x07;
-
-		while ((inb(tmport) & 0x80) == 0x00)
+		outb(0x01, wkport + 0x1b);
+		outb(satn[0], wkport + 0x03);
+		outb(satn[1], wkport + 0x04);
+		outb(satn[2], wkport + 0x05);
+		outb(satn[3], wkport + 0x06);
+		outb(satn[4], wkport + 0x07);
+		outb(satn[5], wkport + 0x08);
+		outb(0, wkport + 0x0f);
+		outb(dev->id[c][i].devsp, wkport + 0x11);
+		outb(0, wkport + 0x12);
+		outb(satn[6], wkport + 0x13);
+		outb(satn[7], wkport + 0x14);
+		outb(satn[8], wkport + 0x18);
+
+		while ((inb(wkport + 0x1f) & 0x80) == 0x00)
 			cpu_relax();
-		tmport -= 0x08;
-		if ((inb(tmport) != 0x11) && (inb(tmport) != 0x8e)) {
+		if ((inb(wkport + 0x17) != 0x11) && (inb(wkport + 0x17) != 0x8e)) {
 			continue;
 		}
-		while (inb(tmport) != 0x8e)
+		while (inb(wkport + 0x17) != 0x8e)
 			cpu_relax();
 try_u3:
 		j = 0;
-		tmport = wkport + 0x14;
-		outb(0x09, tmport);
-		tmport += 0x04;
-		outb(0x20, tmport);
-		tmport += 0x07;
-
-		while ((inb(tmport) & 0x80) == 0) {
-			if ((inb(tmport) & 0x01) != 0) {
-				tmport -= 0x06;
-				outb(u3[j++], tmport);
-				tmport += 0x06;
-			}
+		outb(0x09, wkport + 0x14);
+		outb(0x20, wkport + 0x18);
+
+		while ((inb(wkport + 0x1f) & 0x80) == 0) {
+			if ((inb(wkport + 0x1f) & 0x01) != 0)
+				outb(u3[j++], wkport + 0x19);
 			cpu_relax();
 		}
-		tmport -= 0x08;
-		while ((inb(tmport) & 0x80) == 0x00)
+		while ((inb(wkport + 0x17) & 0x80) == 0x00)
 			cpu_relax();
-		j = inb(tmport) & 0x0f;
+		j = inb(wkport + 0x17) & 0x0f;
 		if (j == 0x0f) {
 			goto u3p_in;
 		}
@@ -3092,19 +3047,13 @@ static void is885(struct atp_unit *dev, unsigned int wkport,unsigned char c)
 		}
 		continue;
 u3p_out:
-		tmport = wkport + 0x18;
-		outb(0x20, tmport);
-		tmport += 0x07;
-		while ((inb(tmport) & 0x80) == 0) {
-			if ((inb(tmport) & 0x01) != 0) {
-				tmport -= 0x06;
-				outb(0, tmport);
-				tmport += 0x06;
-			}
+		outb(0x20, wkport + 0x18);
+		while ((inb(wkport + 0x1f) & 0x80) == 0) {
+			if ((inb(wkport + 0x1f) & 0x01) != 0)
+				outb(0, wkport + 0x19);
 			cpu_relax();
 		}
-		tmport -= 0x08;
-		j = inb(tmport) & 0x0f;
+		j = inb(wkport + 0x17) & 0x0f;
 		if (j == 0x0f) {
 			goto u3p_in;
 		}
@@ -3116,25 +3065,19 @@ static void is885(struct atp_unit *dev, unsigned int wkport,unsigned char c)
 		}
 		continue;
 u3p_in:
-		tmport = wkport + 0x14;
-		outb(0x09, tmport);
-		tmport += 0x04;
-		outb(0x20, tmport);
-		tmport += 0x07;
+		outb(0x09, wkport + 0x14);
+		outb(0x20, wkport + 0x18);
 		k = 0;
 u3p_in1:
-		j = inb(tmport);
+		j = inb(wkport + 0x1f);
 		if ((j & 0x01) != 0) {
-			tmport -= 0x06;
-			mbuf[k++] = inb(tmport);
-			tmport += 0x06;
+			mbuf[k++] = inb(wkport + 0x19);
 			goto u3p_in1;
 		}
 		if ((j & 0x80) == 0x00) {
 			goto u3p_in1;
 		}
-		tmport -= 0x08;
-		j = inb(tmport) & 0x0f;
+		j = inb(wkport + 0x17) & 0x0f;
 		if (j == 0x0f) {
 			goto u3p_in;
 		}
@@ -3146,16 +3089,11 @@ static void is885(struct atp_unit *dev, unsigned int wkport,unsigned char c)
 		}
 		continue;
 u3p_cmd:
-		tmport = wkport + 0x10;
-		outb(0x30, tmport);
-		tmport = wkport + 0x14;
-		outb(0x00, tmport);
-		tmport += 0x04;
-		outb(0x08, tmport);
-		tmport += 0x07;
-		while ((inb(tmport) & 0x80) == 0x00);
-		tmport -= 0x08;
-		j = inb(tmport);
+		outb(0x30, wkport + 0x10);
+		outb(0x00, wkport + 0x14);
+		outb(0x08, wkport + 0x18);
+		while ((inb(wkport + 0x1f) & 0x80) == 0x00);
+		j = inb(wkport + 0x17);
 		if (j != 0x16) {
 			if (j == 0x4e) {
 				goto u3p_out;
@@ -3182,54 +3120,40 @@ static void is885(struct atp_unit *dev, unsigned int wkport,unsigned char c)
 			continue;
 		}
 chg_wide:
-		tmport = wkport + 0x1b;
-		outb(0x01, tmport);
-		tmport = wkport + 0x03;
-		outb(satn[0], tmport++);
-		outb(satn[1], tmport++);
-		outb(satn[2], tmport++);
-		outb(satn[3], tmport++);
-		outb(satn[4], tmport++);
-		outb(satn[5], tmport++);
-		tmport += 0x06;
-		outb(0, tmport);
-		tmport += 0x02;
-		outb(dev->id[c][i].devsp, tmport++);
-		outb(0, tmport++);
-		outb(satn[6], tmport++);
-		outb(satn[7], tmport++);
-		tmport += 0x03;
-		outb(satn[8], tmport);
-		tmport += 0x07;
-
-		while ((inb(tmport) & 0x80) == 0x00)
+		outb(0x01, wkport + 0x1b);
+		outb(satn[0], wkport + 0x03);
+		outb(satn[1], wkport + 0x04);
+		outb(satn[2], wkport + 0x05);
+		outb(satn[3], wkport + 0x06);
+		outb(satn[4], wkport + 0x07);
+		outb(satn[5], wkport + 0x08);
+		outb(0, wkport + 0x0f);
+		outb(dev->id[c][i].devsp, wkport + 0x11);
+		outb(0, wkport + 0x12);
+		outb(satn[6], wkport + 0x13);
+		outb(satn[7], wkport + 0x14);
+		outb(satn[8], wkport + 0x18);
+
+		while ((inb(wkport + 0x1f) & 0x80) == 0x00)
 			cpu_relax();
-		tmport -= 0x08;
-		if ((inb(tmport) != 0x11) && (inb(tmport) != 0x8e)) {
+		if ((inb(wkport + 0x17) != 0x11) && (inb(wkport + 0x17) != 0x8e)) {
 			continue;
 		}
-		while (inb(tmport) != 0x8e)
+		while (inb(wkport + 0x17) != 0x8e)
 			cpu_relax();
 try_wide:
 		j = 0;
-		tmport = wkport + 0x14;
-		outb(0x05, tmport);
-		tmport += 0x04;
-		outb(0x20, tmport);
-		tmport += 0x07;
-
-		while ((inb(tmport) & 0x80) == 0) {
-			if ((inb(tmport) & 0x01) != 0) {
-				tmport -= 0x06;
-				outb(wide[j++], tmport);
-				tmport += 0x06;
-			}
+		outb(0x05, wkport + 0x14);
+		outb(0x20, wkport + 0x18);
+
+		while ((inb(wkport + 0x1f) & 0x80) == 0) {
+			if ((inb(wkport + 0x1f) & 0x01) != 0)
+				outb(wide[j++], wkport + 0x19);
 			cpu_relax();
 		}
-		tmport -= 0x08;
-		while ((inb(tmport) & 0x80) == 0x00)
+		while ((inb(wkport + 0x17) & 0x80) == 0x00)
 			cpu_relax();
-		j = inb(tmport) & 0x0f;
+		j = inb(wkport + 0x17) & 0x0f;
 		if (j == 0x0f) {
 			goto widep_in;
 		}
@@ -3241,19 +3165,13 @@ static void is885(struct atp_unit *dev, unsigned int wkport,unsigned char c)
 		}
 		continue;
 widep_out:
-		tmport = wkport + 0x18;
-		outb(0x20, tmport);
-		tmport += 0x07;
-		while ((inb(tmport) & 0x80) == 0) {
-			if ((inb(tmport) & 0x01) != 0) {
-				tmport -= 0x06;
-				outb(0, tmport);
-				tmport += 0x06;
-			}
+		outb(0x20, wkport + 0x18);
+		while ((inb(wkport + 0x1f) & 0x80) == 0) {
+			if ((inb(wkport + 0x1f) & 0x01) != 0)
+				outb(0, wkport + 0x19);
 			cpu_relax();
 		}
-		tmport -= 0x08;
-		j = inb(tmport) & 0x0f;
+		j = inb(wkport + 0x17) & 0x0f;
 		if (j == 0x0f) {
 			goto widep_in;
 		}
@@ -3265,25 +3183,19 @@ static void is885(struct atp_unit *dev, unsigned int wkport,unsigned char c)
 		}
 		continue;
 widep_in:
-		tmport = wkport + 0x14;
-		outb(0xff, tmport);
-		tmport += 0x04;
-		outb(0x20, tmport);
-		tmport += 0x07;
+		outb(0xff, wkport + 0x14);
+		outb(0x20, wkport + 0x18);
 		k = 0;
 widep_in1:
-		j = inb(tmport);
+		j = inb(wkport + 0x1f);
 		if ((j & 0x01) != 0) {
-			tmport -= 0x06;
-			mbuf[k++] = inb(tmport);
-			tmport += 0x06;
+			mbuf[k++] = inb(wkport + 0x19);
 			goto widep_in1;
 		}
 		if ((j & 0x80) == 0x00) {
 			goto widep_in1;
 		}
-		tmport -= 0x08;
-		j = inb(tmport) & 0x0f;
+		j = inb(wkport + 0x17) & 0x0f;
 		if (j == 0x0f) {
 			goto widep_in;
 		}
@@ -3295,17 +3207,12 @@ static void is885(struct atp_unit *dev, unsigned int wkport,unsigned char c)
 		}
 		continue;
 widep_cmd:
-		tmport = wkport + 0x10;
-		outb(0x30, tmport);
-		tmport = wkport + 0x14;
-		outb(0x00, tmport);
-		tmport += 0x04;
-		outb(0x08, tmport);
-		tmport += 0x07;
-		while ((inb(tmport) & 0x80) == 0x00)
+		outb(0x30, wkport + 0x10);
+		outb(0x00, wkport + 0x14);
+		outb(0x08, wkport + 0x18);
+		while ((inb(wkport + 0x1f) & 0x80) == 0x00)
 			cpu_relax();
-		tmport -= 0x08;
-		j = inb(tmport);
+		j = inb(wkport + 0x17);
 		if (j != 0x16) {
 			if (j == 0x4e) {
 				goto widep_out;
@@ -3347,69 +3254,56 @@ static void is885(struct atp_unit *dev, unsigned int wkport,unsigned char c)
 		      synuw[4]=0x0a;
 		   }
 		}
-		tmport = wkport + 0x1b;
 		j = 0;
 		if ((m & dev->wide_id[c]) != 0) {
 			j |= 0x01;
 		}
-		outb(j, tmport);
-		tmport = wkport + 0x03;
-		outb(satn[0], tmport++);
-		outb(satn[1], tmport++);
-		outb(satn[2], tmport++);
-		outb(satn[3], tmport++);
-		outb(satn[4], tmport++);
-		outb(satn[5], tmport++);
-		tmport += 0x06;
-		outb(0, tmport);
-		tmport += 0x02;
-		outb(dev->id[c][i].devsp, tmport++);
-		outb(0, tmport++);
-		outb(satn[6], tmport++);
-		outb(satn[7], tmport++);
-		tmport += 0x03;
-		outb(satn[8], tmport);
-		tmport += 0x07;
-
-		while ((inb(tmport) & 0x80) == 0x00)
+		outb(j, wkport + 0x1b);
+		outb(satn[0], wkport + 0x03);
+		outb(satn[1], wkport + 0x04);
+		outb(satn[2], wkport + 0x05);
+		outb(satn[3], wkport + 0x06);
+		outb(satn[4], wkport + 0x07);
+		outb(satn[5], wkport + 0x08);
+		outb(0, wkport + 0x0f);
+		outb(dev->id[c][i].devsp, wkport + 0x11);
+		outb(0, wkport + 0x12);
+		outb(satn[6], wkport + 0x13);
+		outb(satn[7], wkport + 0x14);
+		outb(satn[8], wkport + 0x18);
+
+		while ((inb(wkport + 0x1f) & 0x80) == 0x00)
 			cpu_relax();
-		tmport -= 0x08;
-		if ((inb(tmport) != 0x11) && (inb(tmport) != 0x8e)) {
+		if ((inb(wkport + 0x17) != 0x11) && (inb(wkport + 0x17) != 0x8e)) {
 			continue;
 		}
-		while (inb(tmport) != 0x8e)
+		while (inb(wkport + 0x17) != 0x8e)
 			cpu_relax();
 try_sync:
 		j = 0;
-		tmport = wkport + 0x14;
-		outb(0x06, tmport);
-		tmport += 0x04;
-		outb(0x20, tmport);
-		tmport += 0x07;
-
-		while ((inb(tmport) & 0x80) == 0) {
-			if ((inb(tmport) & 0x01) != 0) {
-				tmport -= 0x06;
+		outb(0x06, wkport + 0x14);
+		outb(0x20, wkport + 0x18);
+
+		while ((inb(wkport + 0x1f) & 0x80) == 0) {
+			if ((inb(wkport + 0x1f) & 0x01) != 0) {
 				if ((m & dev->wide_id[c]) != 0) {
 					if ((m & dev->ultra_map[c]) != 0) {
-						outb(synuw[j++], tmport);
+						outb(synuw[j++], wkport + 0x19);
 					} else {
-						outb(synw[j++], tmport);
+						outb(synw[j++], wkport + 0x19);
 					}
 				} else {
 					if ((m & dev->ultra_map[c]) != 0) {
-						outb(synu[j++], tmport);
+						outb(synu[j++], wkport + 0x19);
 					} else {
-						outb(synn[j++], tmport);
+						outb(synn[j++], wkport + 0x19);
 					}
 				}
-				tmport += 0x06;
 			}
 		}
-		tmport -= 0x08;
-		while ((inb(tmport) & 0x80) == 0x00)
+		while ((inb(wkport + 0x17) & 0x80) == 0x00)
 			cpu_relax();
-		j = inb(tmport) & 0x0f;
+		j = inb(wkport + 0x17) & 0x0f;
 		if (j == 0x0f) {
 			goto phase_ins;
 		}
@@ -3421,19 +3315,13 @@ static void is885(struct atp_unit *dev, unsigned int wkport,unsigned char c)
 		}
 		continue;
 phase_outs:
-		tmport = wkport + 0x18;
-		outb(0x20, tmport);
-		tmport += 0x07;
-		while ((inb(tmport) & 0x80) == 0x00) {
-			if ((inb(tmport) & 0x01) != 0x00) {
-				tmport -= 0x06;
-				outb(0x00, tmport);
-				tmport += 0x06;
-			}
+		outb(0x20, wkport + 0x18);
+		while ((inb(wkport + 0x1f) & 0x80) == 0x00) {
+			if ((inb(wkport + 0x1f) & 0x01) != 0x00)
+				outb(0x00, wkport + 0x19);
 			cpu_relax();
 		}
-		tmport -= 0x08;
-		j = inb(tmport);
+		j = inb(wkport + 0x17);
 		if (j == 0x85) {
 			goto tar_dcons;
 		}
@@ -3449,26 +3337,20 @@ static void is885(struct atp_unit *dev, unsigned int wkport,unsigned char c)
 		}
 		continue;
 phase_ins:
-		tmport = wkport + 0x14;
-		outb(0x06, tmport);
-		tmport += 0x04;
-		outb(0x20, tmport);
-		tmport += 0x07;
+		outb(0x06, wkport + 0x14);
+		outb(0x20, wkport + 0x18);
 		k = 0;
 phase_ins1:
-		j = inb(tmport);
+		j = inb(wkport + 0x1f);
 		if ((j & 0x01) != 0x00) {
-			tmport -= 0x06;
-			mbuf[k++] = inb(tmport);
-			tmport += 0x06;
+			mbuf[k++] = inb(wkport + 0x19);
 			goto phase_ins1;
 		}
 		if ((j & 0x80) == 0x00) {
 			goto phase_ins1;
 		}
-		tmport -= 0x08;
-		while ((inb(tmport) & 0x80) == 0x00);
-		j = inb(tmport);
+		while ((inb(wkport + 0x17) & 0x80) == 0x00);
+		j = inb(wkport + 0x17);
 		if (j == 0x85) {
 			goto tar_dcons;
 		}
@@ -3484,18 +3366,13 @@ static void is885(struct atp_unit *dev, unsigned int wkport,unsigned char c)
 		}
 		continue;
 phase_cmds:
-		tmport = wkport + 0x10;
-		outb(0x30, tmport);
+		outb(0x30, wkport + 0x10);
 tar_dcons:
-		tmport = wkport + 0x14;
-		outb(0x00, tmport);
-		tmport += 0x04;
-		outb(0x08, tmport);
-		tmport += 0x07;
-		while ((inb(tmport) & 0x80) == 0x00)
+		outb(0x00, wkport + 0x14);
+		outb(0x08, wkport + 0x18);
+		while ((inb(wkport + 0x1f) & 0x80) == 0x00)
 			cpu_relax();
-		tmport -= 0x08;
-		j = inb(tmport);
+		j = inb(wkport + 0x17);
 		if (j != 0x16) {
 			continue;
 		}
@@ -3542,8 +3419,7 @@ static void is885(struct atp_unit *dev, unsigned int wkport,unsigned char c)
 		printk("dev->id[%2d][%2d].devsp = %2x\n",c,i,dev->id[c][i].devsp);
 #endif
 	}
-	tmport = wkport + 0x16;
-	outb(0x80, tmport);
+	outb(0x80, wkport + 0x16);
 }
 
 module_init(atp870u_init);

commit 2eabdf22ad667742258ef7c55a965e56366bf74d
Author: Ondrej Zary <linux@rainbow-software.org>
Date:   Tue Nov 17 19:23:45 2015 +0100

    atp870u: Untangle tmport #7
    
    Untangle the tmport crap so it becomes obvious what ports are accessed.
    
    Signed-off-by: Ondrej Zary <linux@rainbow-software.org>
    Reviewed-by: Hannes Reinicke <hare@suse.de>
    Acked-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/atp870u.c b/drivers/scsi/atp870u.c
index e398ea5ea8f1..f5a11f49bfad 100644
--- a/drivers/scsi/atp870u.c
+++ b/drivers/scsi/atp870u.c
@@ -2716,7 +2716,6 @@ static int atp870u_abort(struct scsi_cmnd * SCpnt)
 {
 	unsigned char  j, k, c;
 	struct scsi_cmnd *workrequ;
-	unsigned int tmport;
 	struct atp_unit *dev;	
 	struct Scsi_Host *host;
 	host = SCpnt->device->host;
@@ -2726,18 +2725,13 @@ static int atp870u_abort(struct scsi_cmnd * SCpnt)
 	printk(" atp870u: abort Channel = %x \n", c);
 	printk("working=%x last_cmd=%x ", dev->working[c], dev->last_cmd[c]);
 	printk(" quhdu=%x quendu=%x ", dev->quhd[c], dev->quend[c]);
-	tmport = dev->ioport[c];
 	for (j = 0; j < 0x18; j++) {
-		printk(" r%2x=%2x", j, inb(tmport++));
+		printk(" r%2x=%2x", j, inb(dev->ioport[c] + j));
 	}
-	tmport += 0x04;
-	printk(" r1c=%2x", inb(tmport));
-	tmport += 0x03;
-	printk(" r1f=%2x in_snd=%2x ", inb(tmport), dev->in_snd[c]);
-	tmport= dev->pciport[c];
-	printk(" d00=%2x", inb(tmport));
-	tmport += 0x02;
-	printk(" d02=%2x", inb(tmport));
+	printk(" r1c=%2x", inb(dev->ioport[c] + 0x1c));
+	printk(" r1f=%2x in_snd=%2x ", inb(dev->ioport[c] + 0x1f), dev->in_snd[c]);
+	printk(" d00=%2x", inb(dev->pciport[c]));
+	printk(" d02=%2x", inb(dev->pciport[c] + 0x02));
 	for(j=0;j<16;j++) {
 	   if (dev->id[c][j].curr_req != NULL) {
 		workrequ = dev->id[c][j].curr_req;

commit 493c5201933f39711569602dc938ac7054391b53
Author: Ondrej Zary <linux@rainbow-software.org>
Date:   Tue Nov 17 19:23:44 2015 +0100

    atp870u: Untangle tmport #6
    
    Untangle the tmport crap so it becomes obvious what ports are accessed.
    
    Signed-off-by: Ondrej Zary <linux@rainbow-software.org>
    Reviewed-by: Hannes Reinicke <hare@suse.de>
    Acked-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/atp870u.c b/drivers/scsi/atp870u.c
index 3bf01fcb4b49..e398ea5ea8f1 100644
--- a/drivers/scsi/atp870u.c
+++ b/drivers/scsi/atp870u.c
@@ -2264,7 +2264,7 @@ static int atp870u_probe(struct pci_dev *pdev, const struct pci_device_id *ent)
 {
 	unsigned char k, m, c;
 	unsigned long flags;
-	unsigned int base_io, tmport, error,n;
+	unsigned int base_io, error,n;
 	unsigned char host_id;
 	struct Scsi_Host *shpnt = NULL;
 	struct atp_unit *atpdev, *p;
@@ -2322,12 +2322,9 @@ static int atp870u_probe(struct pci_dev *pdev, const struct pci_device_id *ent)
 		atpdev->dev_id = ent->device;
 		atpdev->host_id[0] = host_id;
 
-		tmport = base_io + 0x22;
-		atpdev->scam_on = inb(tmport);
-		tmport += 0x13;
-		atpdev->global_map[0] = inb(tmport);
-		tmport += 0x07;
-		atpdev->ultra_map[0] = inw(tmport);
+		atpdev->scam_on = inb(base_io + 0x22);
+		atpdev->global_map[0] = inb(base_io + 0x35);
+		atpdev->ultra_map[0] = inw(base_io + 0x3c);
 
 		n = 0x3f09;
 next_fblk_880:
@@ -2402,37 +2399,26 @@ static int atp870u_probe(struct pci_dev *pdev, const struct pci_device_id *ent)
 		}
 
 		spin_lock_irqsave(shpnt->host_lock, flags);
-		tmport = base_io + 0x38;
-		k = inb(tmport) & 0x80;
-		outb(k, tmport);
-		tmport += 0x03;
-		outb(0x20, tmport);
+		k = inb(base_io + 0x38) & 0x80;
+		outb(k, base_io + 0x38);
+		outb(0x20, base_io + 0x3b);
 		mdelay(32);
-		outb(0, tmport);
+		outb(0, base_io + 0x3b);
 		mdelay(32);
-		tmport = base_io + 0x5b;
-		inb(tmport);
-		tmport -= 0x04;
-		inb(tmport);
-		tmport = base_io + 0x40;
-		outb((host_id | 0x08), tmport);
-		tmport += 0x18;
-		outb(0, tmport);
-		tmport += 0x07;
-		while ((inb(tmport) & 0x80) == 0)
+		inb(base_io + 0x5b);
+		inb(base_io + 0x57);
+		outb((host_id | 0x08), base_io + 0x40);
+		outb(0, base_io + 0x58);
+		while ((inb(base_io + 0x5f) & 0x80) == 0)
 			mdelay(1);
-		tmport -= 0x08;
-		inb(tmport);
-		tmport = base_io + 0x41;
-		outb(8, tmport++);
-		outb(0x7f, tmport);
-		tmport = base_io + 0x51;
-		outb(0x20, tmport);
+		inb(base_io + 0x57);
+		outb(8, base_io + 0x41);
+		outb(0x7f, base_io + 0x42);
+		outb(0x20, base_io + 0x51);
 
 		tscam(shpnt);
 		is880(p, base_io);
-		tmport = base_io + 0x38;
-		outb(0xb0, tmport);
+		outb(0xb0, base_io + 0x38);
 		shpnt->max_id = 16;
 		shpnt->this_id = host_id;
 		shpnt->unique_id = base_io;
@@ -2546,47 +2532,35 @@ static int atp870u_probe(struct pci_dev *pdev, const struct pci_device_id *ent)
 		inb(base_io + 0x97);
 		inb(base_io + 0xdb);
 		inb(base_io + 0xd7);
-		tmport = base_io + 0x80;
 		k=p->host_id[0];
 		if (k > 7)
 		   k = (k & 0x07) | 0x40;
 		k |= 0x08;
-		outb(k, tmport);
-		tmport += 0x18;
-		outb(0, tmport);
-		tmport += 0x07;
+		outb(k, base_io + 0x80);
+		outb(0, base_io + 0x98);
 
-		while ((inb(tmport) & 0x80) == 0)
+		while ((inb(base_io + 0x9f) & 0x80) == 0)
 			cpu_relax();
 	
-		tmport -= 0x08;
-		inb(tmport);
-		tmport = base_io + 0x81;
-		outb(8, tmport++);
-		outb(0x7f, tmport);
-		tmport = base_io + 0x91;
-		outb(0x20, tmport);
+		inb(base_io + 0x97);
+		outb(8, base_io + 0x81);
+		outb(0x7f, base_io + 0x82);
+		outb(0x20, base_io + 0x91);
 
-		tmport = base_io + 0xc0;
 		k=p->host_id[1];
 		if (k > 7)
 		   k = (k & 0x07) | 0x40;
 		k |= 0x08;
-		outb(k, tmport);
-		tmport += 0x18;
-		outb(0, tmport);
-		tmport += 0x07;
+		outb(k, base_io + 0xc0);
+		outb(0, base_io + 0xd8);
 
-		while ((inb(tmport) & 0x80) == 0)
+		while ((inb(base_io + 0xdf) & 0x80) == 0)
 			cpu_relax();
 
-		tmport -= 0x08;
-		inb(tmport);
-		tmport = base_io + 0xc1;
-		outb(8, tmport++);
-		outb(0x7f, tmport);
-		tmport = base_io + 0xd1;
-		outb(0x20, tmport);
+		inb(base_io + 0xd7);
+		outb(8, base_io + 0xc1);
+		outb(0x7f, base_io + 0xc2);
+		outb(0x20, base_io + 0xd1);
 
 		tscam_885();
 		printk(KERN_INFO "   Scanning Channel A SCSI Device ...\n");
@@ -2624,11 +2598,9 @@ static int atp870u_probe(struct pci_dev *pdev, const struct pci_device_id *ent)
 		atpdev->dev_id = ent->device;
 		host_id &= 0x07;
 		atpdev->host_id[0] = host_id;
-		tmport = base_io + 0x22;
-		atpdev->scam_on = inb(tmport);
-		tmport += 0x0b;
-		atpdev->global_map[0] = inb(tmport++);
-		atpdev->ultra_map[0] = inw(tmport);
+		atpdev->scam_on = inb(base_io + 0x22);
+		atpdev->global_map[0] = inb(base_io + 0x2d);
+		atpdev->ultra_map[0] = inw(base_io + 0x2e);
 
 		if (atpdev->ultra_map[0] == 0) {
 			atpdev->scam_on = 0x00;
@@ -2656,39 +2628,29 @@ static int atp870u_probe(struct pci_dev *pdev, const struct pci_device_id *ent)
 
 		spin_lock_irqsave(shpnt->host_lock, flags);
 		if (atpdev->chip_ver > 0x07) {	/* check if atp876 chip then enable terminator */
-			tmport = base_io + 0x3e;
-			outb(0x00, tmport);
+			outb(0x00, base_io + 0x3e);
 		}
  
-		tmport = base_io + 0x3a;
-		k = (inb(tmport) & 0xf3) | 0x10;
-		outb(k, tmport);
-		outb((k & 0xdf), tmport);
+		k = (inb(base_io + 0x3a) & 0xf3) | 0x10;
+		outb(k, base_io + 0x3a);
+		outb((k & 0xdf), base_io + 0x3a);
 		mdelay(32);
-		outb(k, tmport);
+		outb(k, base_io + 0x3a);
 		mdelay(32);
-		tmport = base_io;
-		outb((host_id | 0x08), tmport);
-		tmport += 0x18;
-		outb(0, tmport);
-		tmport += 0x07;
-		while ((inb(tmport) & 0x80) == 0)
+		outb((host_id | 0x08), base_io + 0);
+		outb(0, base_io + 0x18);
+		while ((inb(base_io + 0x1f) & 0x80) == 0)
 			mdelay(1);
 
-		tmport -= 0x08;
-		inb(tmport);
-		tmport = base_io + 1;
-		outb(8, tmport++);
-		outb(0x7f, tmport);
-		tmport = base_io + 0x11;
-		outb(0x20, tmport);
+		inb(base_io + 0x17);
+		outb(8, base_io + 1);
+		outb(0x7f, base_io + 2);
+		outb(0x20, base_io + 0x11);
 
 		tscam(shpnt);
 		is870(p, base_io);
-		tmport = base_io + 0x3a;
-		outb((inb(tmport) & 0xef), tmport);
-		tmport++;
-		outb((inb(tmport) | 0x20), tmport);
+		outb((inb(base_io + 0x3a) & 0xef), base_io + 0x3a);
+		outb((inb(base_io + 0x3b) | 0x20), base_io + 0x3b);
 		if (atpdev->chip_ver == 4)
 			shpnt->max_id = 16;
 		else		

commit 3b30acf6a8989dc1a98f959d3c7743790eab00df
Author: Ondrej Zary <linux@rainbow-software.org>
Date:   Tue Nov 17 19:23:43 2015 +0100

    atp870u: Untangle tmport #5
    
    Untangle the tmport crap so it becomes obvious what ports are accessed.
    
    Signed-off-by: Ondrej Zary <linux@rainbow-software.org>
    Reviewed-by: Hannes Reinicke <hare@suse.de>
    Acked-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/atp870u.c b/drivers/scsi/atp870u.c
index 3e3a68b2738d..3bf01fcb4b49 100644
--- a/drivers/scsi/atp870u.c
+++ b/drivers/scsi/atp870u.c
@@ -1639,7 +1639,6 @@ static void is870(struct atp_unit *dev, unsigned int wkport)
 
 static void is880(struct atp_unit *dev, unsigned int wkport)
 {
-	unsigned int tmport;
 	unsigned char i, j, k, rmb, n, lvdmode;
 	unsigned short int m;
 	static unsigned char mbuf[512];
@@ -1664,130 +1663,100 @@ static void is880(struct atp_unit *dev, unsigned int wkport)
 			printk(KERN_INFO "         ID: %2d  Host Adapter\n", dev->host_id[0]);
 			continue;
 		}
-		tmport = wkport + 0x5b;
-		outb(0x01, tmport);
-		tmport = wkport + 0x41;
-		outb(0x08, tmport++);
-		outb(0x7f, tmport++);
-		outb(satn[0], tmport++);
-		outb(satn[1], tmport++);
-		outb(satn[2], tmport++);
-		outb(satn[3], tmport++);
-		outb(satn[4], tmport++);
-		outb(satn[5], tmport++);
-		tmport += 0x06;
-		outb(0, tmport);
-		tmport += 0x02;
-		outb(dev->id[0][i].devsp, tmport++);
-		outb(0, tmport++);
-		outb(satn[6], tmport++);
-		outb(satn[7], tmport++);
+		outb(0x01, wkport + 0x5b);
+		outb(0x08, wkport + 0x41);
+		outb(0x7f, wkport + 0x42);
+		outb(satn[0], wkport + 0x43);
+		outb(satn[1], wkport + 0x44);
+		outb(satn[2], wkport + 0x45);
+		outb(satn[3], wkport + 0x46);
+		outb(satn[4], wkport + 0x47);
+		outb(satn[5], wkport + 0x48);
+		outb(0, wkport + 0x4f);
+		outb(dev->id[0][i].devsp, wkport + 0x51);
+		outb(0, wkport + 0x52);
+		outb(satn[6], wkport + 0x53);
+		outb(satn[7], wkport + 0x54);
 		j = i;
 		if ((j & 0x08) != 0) {
 			j = (j & 0x07) | 0x40;
 		}
-		outb(j, tmport);
-		tmport += 0x03;
-		outb(satn[8], tmport);
-		tmport += 0x07;
+		outb(j, wkport + 0x55);
+		outb(satn[8], wkport + 0x58);
 
-		while ((inb(tmport) & 0x80) == 0x00)
+		while ((inb(wkport + 0x5f) & 0x80) == 0x00)
 			cpu_relax();
 
-		tmport -= 0x08;
-		if (inb(tmport) != 0x11 && inb(tmport) != 0x8e)
+		if (inb(wkport + 0x57) != 0x11 && inb(wkport + 0x57) != 0x8e)
 			continue;
 
-		while (inb(tmport) != 0x8e)
+		while (inb(wkport + 0x57) != 0x8e)
 			cpu_relax();
 			
 		dev->active_id[0] |= m;
 
-		tmport = wkport + 0x50;
-		outb(0x30, tmport);
-		tmport = wkport + 0x54;
-		outb(0x00, tmport);
+		outb(0x30, wkport + 0x50);
+		outb(0x00, wkport + 0x54);
 
 phase_cmd:
-		tmport = wkport + 0x58;
-		outb(0x08, tmport);
-		tmport += 0x07;
+		outb(0x08, wkport + 0x58);
 		
-		while ((inb(tmport) & 0x80) == 0x00)
+		while ((inb(wkport + 0x5f) & 0x80) == 0x00)
 			cpu_relax();
 
-		tmport -= 0x08;
-		j = inb(tmport);
+		j = inb(wkport + 0x57);
 		if (j != 0x16) {
-			tmport = wkport + 0x50;
-			outb(0x41, tmport);
+			outb(0x41, wkport + 0x50);
 			goto phase_cmd;
 		}
 sel_ok:
-		tmport = wkport + 0x43;
-		outb(inqd[0], tmport++);
-		outb(inqd[1], tmport++);
-		outb(inqd[2], tmport++);
-		outb(inqd[3], tmport++);
-		outb(inqd[4], tmport++);
-		outb(inqd[5], tmport);
-		tmport += 0x07;
-		outb(0, tmport);
-		tmport += 0x02;
-		outb(dev->id[0][i].devsp, tmport++);
-		outb(0, tmport++);
-		outb(inqd[6], tmport++);
-		outb(inqd[7], tmport++);
-		tmport += 0x03;
-		outb(inqd[8], tmport);
-		tmport += 0x07;
+		outb(inqd[0], wkport + 0x43);
+		outb(inqd[1], wkport + 0x44);
+		outb(inqd[2], wkport + 0x45);
+		outb(inqd[3], wkport + 0x46);
+		outb(inqd[4], wkport + 0x47);
+		outb(inqd[5], wkport + 0x48);
+		outb(0, wkport + 0x4f);
+		outb(dev->id[0][i].devsp, wkport + 0x51);
+		outb(0, wkport + 0x52);
+		outb(inqd[6], wkport + 0x53);
+		outb(inqd[7], wkport + 0x54);
+		outb(inqd[8], wkport + 0x58);
 		
-		while ((inb(tmport) & 0x80) == 0x00)
+		while ((inb(wkport + 0x5f) & 0x80) == 0x00)
 			cpu_relax();
 			
-		tmport -= 0x08;
-		if (inb(tmport) != 0x11 && inb(tmport) != 0x8e)
+		if (inb(wkport + 0x57) != 0x11 && inb(wkport + 0x57) != 0x8e)
 			continue;
 
-		while (inb(tmport) != 0x8e)
+		while (inb(wkport + 0x57) != 0x8e)
 			cpu_relax();
 			
-		tmport = wkport + 0x5b;
-		outb(0x00, tmport);
-		tmport = wkport + 0x58;
-		outb(0x08, tmport);
-		tmport += 0x07;
+		outb(0x00, wkport + 0x5b);
+		outb(0x08, wkport + 0x58);
 		j = 0;
 rd_inq_data:
-		k = inb(tmport);
+		k = inb(wkport + 0x5f);
 		if ((k & 0x01) != 0) {
-			tmport -= 0x06;
-			mbuf[j++] = inb(tmport);
-			tmport += 0x06;
+			mbuf[j++] = inb(wkport + 0x59);
 			goto rd_inq_data;
 		}
 		if ((k & 0x80) == 0) {
 			goto rd_inq_data;
 		}
-		tmport -= 0x08;
-		j = inb(tmport);
+		j = inb(wkport + 0x57);
 		if (j == 0x16) {
 			goto inq_ok;
 		}
-		tmport = wkport + 0x50;
-		outb(0x46, tmport);
-		tmport += 0x02;
-		outb(0, tmport++);
-		outb(0, tmport++);
-		outb(0, tmport++);
-		tmport += 0x03;
-		outb(0x08, tmport);
-		tmport += 0x07;
-		while ((inb(tmport) & 0x80) == 0x00)
+		outb(0x46, wkport + 0x50);
+		outb(0, wkport + 0x52);
+		outb(0, wkport + 0x53);
+		outb(0, wkport + 0x54);
+		outb(0x08, wkport + 0x58);
+		while ((inb(wkport + 0x5f) & 0x80) == 0x00)
 			cpu_relax();
 			
-		tmport -= 0x08;
-		if (inb(tmport) != 0x16)
+		if (inb(wkport + 0x57) != 0x16)
 			goto sel_ok;
 
 inq_ok:
@@ -1810,58 +1779,43 @@ static void is880(struct atp_unit *dev, unsigned int wkport)
 			goto chg_wide;
 		}
 
-		tmport = wkport + 0x5b;
-		outb(0x01, tmport);
-		tmport = wkport + 0x43;
-		outb(satn[0], tmport++);
-		outb(satn[1], tmport++);
-		outb(satn[2], tmport++);
-		outb(satn[3], tmport++);
-		outb(satn[4], tmport++);
-		outb(satn[5], tmport++);
-		tmport += 0x06;
-		outb(0, tmport);
-		tmport += 0x02;
-		outb(dev->id[0][i].devsp, tmport++);
-		outb(0, tmport++);
-		outb(satn[6], tmport++);
-		outb(satn[7], tmport++);
-		tmport += 0x03;
-		outb(satn[8], tmport);
-		tmport += 0x07;
-
-		while ((inb(tmport) & 0x80) == 0x00)
+		outb(0x01, wkport + 0x5b);
+		outb(satn[0], wkport + 0x43);
+		outb(satn[1], wkport + 0x44);
+		outb(satn[2], wkport + 0x45);
+		outb(satn[3], wkport + 0x46);
+		outb(satn[4], wkport + 0x47);
+		outb(satn[5], wkport + 0x48);
+		outb(0, wkport + 0x4f);
+		outb(dev->id[0][i].devsp, wkport + 0x51);
+		outb(0, wkport + 0x52);
+		outb(satn[6], wkport + 0x53);
+		outb(satn[7], wkport + 0x54);
+		outb(satn[8], wkport + 0x58);
+
+		while ((inb(wkport + 0x5f) & 0x80) == 0x00)
 			cpu_relax();
 
-		tmport -= 0x08;
-
-		if (inb(tmport) != 0x11 && inb(tmport) != 0x8e)
+		if (inb(wkport + 0x57) != 0x11 && inb(wkport + 0x57) != 0x8e)
 			continue;
 
-		while (inb(tmport) != 0x8e)
+		while (inb(wkport + 0x57) != 0x8e)
 			cpu_relax();
 
 try_u3:
 		j = 0;
-		tmport = wkport + 0x54;
-		outb(0x09, tmport);
-		tmport += 0x04;
-		outb(0x20, tmport);
-		tmport += 0x07;
+		outb(0x09, wkport + 0x54);
+		outb(0x20, wkport + 0x58);
 
-		while ((inb(tmport) & 0x80) == 0) {
-			if ((inb(tmport) & 0x01) != 0) {
-				tmport -= 0x06;
-				outb(u3[j++], tmport);
-				tmport += 0x06;
-			}
+		while ((inb(wkport + 0x5f) & 0x80) == 0) {
+			if ((inb(wkport + 0x5f) & 0x01) != 0)
+				outb(u3[j++], wkport + 0x59);
 		}
-		tmport -= 0x08;
 
-		while ((inb(tmport) & 0x80) == 0x00)
+		while ((inb(wkport + 0x57) & 0x80) == 0x00)
 			cpu_relax();
 			
-		j = inb(tmport) & 0x0f;
+		j = inb(wkport + 0x57) & 0x0f;
 		if (j == 0x0f) {
 			goto u3p_in;
 		}
@@ -1873,18 +1827,12 @@ static void is880(struct atp_unit *dev, unsigned int wkport)
 		}
 		continue;
 u3p_out:
-		tmport = wkport + 0x58;
-		outb(0x20, tmport);
-		tmport += 0x07;
-		while ((inb(tmport) & 0x80) == 0) {
-			if ((inb(tmport) & 0x01) != 0) {
-				tmport -= 0x06;
-				outb(0, tmport);
-				tmport += 0x06;
-			}
+		outb(0x20, wkport + 0x58);
+		while ((inb(wkport + 0x5f) & 0x80) == 0) {
+			if ((inb(wkport + 0x5f) & 0x01) != 0)
+				outb(0, wkport + 0x59);
 		}
-		tmport -= 0x08;
-		j = inb(tmport) & 0x0f;
+		j = inb(wkport + 0x57) & 0x0f;
 		if (j == 0x0f) {
 			goto u3p_in;
 		}
@@ -1896,25 +1844,19 @@ static void is880(struct atp_unit *dev, unsigned int wkport)
 		}
 		continue;
 u3p_in:
-		tmport = wkport + 0x54;
-		outb(0x09, tmport);
-		tmport += 0x04;
-		outb(0x20, tmport);
-		tmport += 0x07;
+		outb(0x09, wkport + 0x54);
+		outb(0x20, wkport + 0x58);
 		k = 0;
 u3p_in1:
-		j = inb(tmport);
+		j = inb(wkport + 0x5f);
 		if ((j & 0x01) != 0) {
-			tmport -= 0x06;
-			mbuf[k++] = inb(tmport);
-			tmport += 0x06;
+			mbuf[k++] = inb(wkport + 0x59);
 			goto u3p_in1;
 		}
 		if ((j & 0x80) == 0x00) {
 			goto u3p_in1;
 		}
-		tmport -= 0x08;
-		j = inb(tmport) & 0x0f;
+		j = inb(wkport + 0x57) & 0x0f;
 		if (j == 0x0f) {
 			goto u3p_in;
 		}
@@ -1926,19 +1868,14 @@ static void is880(struct atp_unit *dev, unsigned int wkport)
 		}
 		continue;
 u3p_cmd:
-		tmport = wkport + 0x50;
-		outb(0x30, tmport);
-		tmport = wkport + 0x54;
-		outb(0x00, tmport);
-		tmport += 0x04;
-		outb(0x08, tmport);
-		tmport += 0x07;
+		outb(0x30, wkport + 0x50);
+		outb(0x00, wkport + 0x54);
+		outb(0x08, wkport + 0x58);
 		
-		while ((inb(tmport) & 0x80) == 0x00)
+		while ((inb(wkport + 0x5f) & 0x80) == 0x00)
 			cpu_relax();
 			
-		tmport -= 0x08;
-		j = inb(tmport);
+		j = inb(wkport + 0x57);
 		if (j != 0x16) {
 			if (j == 0x4e) {
 				goto u3p_out;
@@ -1962,56 +1899,42 @@ static void is880(struct atp_unit *dev, unsigned int wkport)
 			continue;
 		}
 chg_wide:
-		tmport = wkport + 0x5b;
-		outb(0x01, tmport);
-		tmport = wkport + 0x43;
-		outb(satn[0], tmport++);
-		outb(satn[1], tmport++);
-		outb(satn[2], tmport++);
-		outb(satn[3], tmport++);
-		outb(satn[4], tmport++);
-		outb(satn[5], tmport++);
-		tmport += 0x06;
-		outb(0, tmport);
-		tmport += 0x02;
-		outb(dev->id[0][i].devsp, tmport++);
-		outb(0, tmport++);
-		outb(satn[6], tmport++);
-		outb(satn[7], tmport++);
-		tmport += 0x03;
-		outb(satn[8], tmport);
-		tmport += 0x07;
-
-		while ((inb(tmport) & 0x80) == 0x00)
+		outb(0x01, wkport + 0x5b);
+		outb(satn[0], wkport + 0x43);
+		outb(satn[1], wkport + 0x44);
+		outb(satn[2], wkport + 0x45);
+		outb(satn[3], wkport + 0x46);
+		outb(satn[4], wkport + 0x47);
+		outb(satn[5], wkport + 0x48);
+		outb(0, wkport + 0x4f);
+		outb(dev->id[0][i].devsp, wkport + 0x51);
+		outb(0, wkport + 0x52);
+		outb(satn[6], wkport + 0x53);
+		outb(satn[7], wkport + 0x54);
+		outb(satn[8], wkport + 0x58);
+
+		while ((inb(wkport + 0x5f) & 0x80) == 0x00)
 			cpu_relax();
 			
-		tmport -= 0x08;
-		if (inb(tmport) != 0x11 && inb(tmport) != 0x8e)
+		if (inb(wkport + 0x57) != 0x11 && inb(wkport + 0x57) != 0x8e)
 			continue;
 
-		while (inb(tmport) != 0x8e)
+		while (inb(wkport + 0x57) != 0x8e)
 			cpu_relax();
 			
 try_wide:
 		j = 0;
-		tmport = wkport + 0x54;
-		outb(0x05, tmport);
-		tmport += 0x04;
-		outb(0x20, tmport);
-		tmport += 0x07;
+		outb(0x05, wkport + 0x54);
+		outb(0x20, wkport + 0x58);
 
-		while ((inb(tmport) & 0x80) == 0) {
-			if ((inb(tmport) & 0x01) != 0) {
-				tmport -= 0x06;
-				outb(wide[j++], tmport);
-				tmport += 0x06;
-			}
+		while ((inb(wkport + 0x5f) & 0x80) == 0) {
+			if ((inb(wkport + 0x5f) & 0x01) != 0)
+				outb(wide[j++], wkport + 0x59);
 		}
-		tmport -= 0x08;
-		while ((inb(tmport) & 0x80) == 0x00)
+		while ((inb(wkport + 0x57) & 0x80) == 0x00)
 			cpu_relax();
 			
-		j = inb(tmport) & 0x0f;
+		j = inb(wkport + 0x57) & 0x0f;
 		if (j == 0x0f) {
 			goto widep_in;
 		}
@@ -2023,18 +1946,12 @@ static void is880(struct atp_unit *dev, unsigned int wkport)
 		}
 		continue;
 widep_out:
-		tmport = wkport + 0x58;
-		outb(0x20, tmport);
-		tmport += 0x07;
-		while ((inb(tmport) & 0x80) == 0) {
-			if ((inb(tmport) & 0x01) != 0) {
-				tmport -= 0x06;
-				outb(0, tmport);
-				tmport += 0x06;
-			}
+		outb(0x20, wkport + 0x58);
+		while ((inb(wkport + 0x5f) & 0x80) == 0) {
+			if ((inb(wkport + 0x5f) & 0x01) != 0)
+				outb(0, wkport + 0x59);
 		}
-		tmport -= 0x08;
-		j = inb(tmport) & 0x0f;
+		j = inb(wkport + 0x57) & 0x0f;
 		if (j == 0x0f) {
 			goto widep_in;
 		}
@@ -2046,25 +1963,19 @@ static void is880(struct atp_unit *dev, unsigned int wkport)
 		}
 		continue;
 widep_in:
-		tmport = wkport + 0x54;
-		outb(0xff, tmport);
-		tmport += 0x04;
-		outb(0x20, tmport);
-		tmport += 0x07;
+		outb(0xff, wkport + 0x54);
+		outb(0x20, wkport + 0x58);
 		k = 0;
 widep_in1:
-		j = inb(tmport);
+		j = inb(wkport + 0x5f);
 		if ((j & 0x01) != 0) {
-			tmport -= 0x06;
-			mbuf[k++] = inb(tmport);
-			tmport += 0x06;
+			mbuf[k++] = inb(wkport + 0x59);
 			goto widep_in1;
 		}
 		if ((j & 0x80) == 0x00) {
 			goto widep_in1;
 		}
-		tmport -= 0x08;
-		j = inb(tmport) & 0x0f;
+		j = inb(wkport + 0x57) & 0x0f;
 		if (j == 0x0f) {
 			goto widep_in;
 		}
@@ -2076,19 +1987,14 @@ static void is880(struct atp_unit *dev, unsigned int wkport)
 		}
 		continue;
 widep_cmd:
-		tmport = wkport + 0x50;
-		outb(0x30, tmport);
-		tmport = wkport + 0x54;
-		outb(0x00, tmport);
-		tmport += 0x04;
-		outb(0x08, tmport);
-		tmport += 0x07;
+		outb(0x30, wkport + 0x50);
+		outb(0x00, wkport + 0x54);
+		outb(0x08, wkport + 0x58);
 
-		while ((inb(tmport) & 0x80) == 0x00)
+		while ((inb(wkport + 0x5f) & 0x80) == 0x00)
 			cpu_relax();
 
-		tmport -= 0x08;
-		j = inb(tmport);
+		j = inb(wkport + 0x57);
 		if (j != 0x16) {
 			if (j == 0x4e) {
 				goto widep_out;
@@ -2129,73 +2035,60 @@ static void is880(struct atp_unit *dev, unsigned int wkport)
 				synuw[4] = 0x0a;
 			}
 		}
-		tmport = wkport + 0x5b;
 		j = 0;
 		if ((m & dev->wide_id[0]) != 0) {
 			j |= 0x01;
 		}
-		outb(j, tmport);
-		tmport = wkport + 0x43;
-		outb(satn[0], tmport++);
-		outb(satn[1], tmport++);
-		outb(satn[2], tmport++);
-		outb(satn[3], tmport++);
-		outb(satn[4], tmport++);
-		outb(satn[5], tmport++);
-		tmport += 0x06;
-		outb(0, tmport);
-		tmport += 0x02;
-		outb(dev->id[0][i].devsp, tmport++);
-		outb(0, tmport++);
-		outb(satn[6], tmport++);
-		outb(satn[7], tmport++);
-		tmport += 0x03;
-		outb(satn[8], tmport);
-		tmport += 0x07;
-
-		while ((inb(tmport) & 0x80) == 0x00)
+		outb(j, wkport + 0x5b);
+		outb(satn[0], wkport + 0x43);
+		outb(satn[1], wkport + 0x44);
+		outb(satn[2], wkport + 0x45);
+		outb(satn[3], wkport + 0x46);
+		outb(satn[4], wkport + 0x47);
+		outb(satn[5], wkport + 0x48);
+		outb(0, wkport + 0x4f);
+		outb(dev->id[0][i].devsp, wkport + 0x51);
+		outb(0, wkport + 0x52);
+		outb(satn[6], wkport + 0x53);
+		outb(satn[7], wkport + 0x54);
+		outb(satn[8], wkport + 0x58);
+
+		while ((inb(wkport + 0x5f) & 0x80) == 0x00)
 			cpu_relax();
 
-		tmport -= 0x08;
-		if ((inb(tmport) != 0x11) && (inb(tmport) != 0x8e)) {
+		if ((inb(wkport + 0x57) != 0x11) && (inb(wkport + 0x57) != 0x8e)) {
 			continue;
 		}
-		while (inb(tmport) != 0x8e)
+		while (inb(wkport + 0x57) != 0x8e)
 			cpu_relax();
 
 try_sync:
 		j = 0;
-		tmport = wkport + 0x54;
-		outb(0x06, tmport);
-		tmport += 0x04;
-		outb(0x20, tmport);
-		tmport += 0x07;
+		outb(0x06, wkport + 0x54);
+		outb(0x20, wkport + 0x58);
 
-		while ((inb(tmport) & 0x80) == 0) {
-			if ((inb(tmport) & 0x01) != 0) {
-				tmport -= 0x06;
+		while ((inb(wkport + 0x5f) & 0x80) == 0) {
+			if ((inb(wkport + 0x5f) & 0x01) != 0) {
 				if ((m & dev->wide_id[0]) != 0) {
 					if ((m & dev->ultra_map[0]) != 0) {
-						outb(synuw[j++], tmport);
+						outb(synuw[j++], wkport + 0x59);
 					} else {
-						outb(synw[j++], tmport);
+						outb(synw[j++], wkport + 0x59);
 					}
 				} else {
 					if ((m & dev->ultra_map[0]) != 0) {
-						outb(synu[j++], tmport);
+						outb(synu[j++], wkport + 0x59);
 					} else {
-						outb(synn[j++], tmport);
+						outb(synn[j++], wkport + 0x59);
 					}
 				}
-				tmport += 0x06;
 			}
 		}
-		tmport -= 0x08;
 
-		while ((inb(tmport) & 0x80) == 0x00)
+		while ((inb(wkport + 0x57) & 0x80) == 0x00)
 			cpu_relax();
 
-		j = inb(tmport) & 0x0f;
+		j = inb(wkport + 0x57) & 0x0f;
 		if (j == 0x0f) {
 			goto phase_ins;
 		}
@@ -2207,18 +2100,12 @@ static void is880(struct atp_unit *dev, unsigned int wkport)
 		}
 		continue;
 phase_outs:
-		tmport = wkport + 0x58;
-		outb(0x20, tmport);
-		tmport += 0x07;
-		while ((inb(tmport) & 0x80) == 0x00) {
-			if ((inb(tmport) & 0x01) != 0x00) {
-				tmport -= 0x06;
-				outb(0x00, tmport);
-				tmport += 0x06;
-			}
+		outb(0x20, wkport + 0x58);
+		while ((inb(wkport + 0x5f) & 0x80) == 0x00) {
+			if ((inb(wkport + 0x5f) & 0x01) != 0x00)
+				outb(0x00, wkport + 0x59);
 		}
-		tmport -= 0x08;
-		j = inb(tmport);
+		j = inb(wkport + 0x57);
 		if (j == 0x85) {
 			goto tar_dcons;
 		}
@@ -2234,29 +2121,23 @@ static void is880(struct atp_unit *dev, unsigned int wkport)
 		}
 		continue;
 phase_ins:
-		tmport = wkport + 0x54;
-		outb(0x06, tmport);
-		tmport += 0x04;
-		outb(0x20, tmport);
-		tmport += 0x07;
+		outb(0x06, wkport + 0x54);
+		outb(0x20, wkport + 0x58);
 		k = 0;
 phase_ins1:
-		j = inb(tmport);
+		j = inb(wkport + 0x5f);
 		if ((j & 0x01) != 0x00) {
-			tmport -= 0x06;
-			mbuf[k++] = inb(tmport);
-			tmport += 0x06;
+			mbuf[k++] = inb(wkport + 0x59);
 			goto phase_ins1;
 		}
 		if ((j & 0x80) == 0x00) {
 			goto phase_ins1;
 		}
-		tmport -= 0x08;
 
-		while ((inb(tmport) & 0x80) == 0x00)
+		while ((inb(wkport + 0x57) & 0x80) == 0x00)
 			cpu_relax();
 
-		j = inb(tmport);
+		j = inb(wkport + 0x57);
 		if (j == 0x85) {
 			goto tar_dcons;
 		}
@@ -2272,20 +2153,15 @@ static void is880(struct atp_unit *dev, unsigned int wkport)
 		}
 		continue;
 phase_cmds:
-		tmport = wkport + 0x50;
-		outb(0x30, tmport);
+		outb(0x30, wkport + 0x50);
 tar_dcons:
-		tmport = wkport + 0x54;
-		outb(0x00, tmport);
-		tmport += 0x04;
-		outb(0x08, tmport);
-		tmport += 0x07;
+		outb(0x00, wkport + 0x54);
+		outb(0x08, wkport + 0x58);
 
-		while ((inb(tmport) & 0x80) == 0x00)
+		while ((inb(wkport + 0x5f) & 0x80) == 0x00)
 			cpu_relax();
 
-		tmport -= 0x08;
-		j = inb(tmport);
+		j = inb(wkport + 0x57);
 		if (j != 0x16) {
 			continue;
 		}

commit ea41ed600b261fec87820c1aa2455942dcfa1ce7
Author: Ondrej Zary <linux@rainbow-software.org>
Date:   Tue Nov 17 19:23:42 2015 +0100

    atp870u: Untangle tmport #4
    
    Untangle the tmport crap so it becomes obvious what ports are accessed.
    
    Signed-off-by: Ondrej Zary <linux@rainbow-software.org>
    Reviewed-by: Hannes Reinicke <hare@suse.de>
    Acked-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/atp870u.c b/drivers/scsi/atp870u.c
index a23f38717d90..3e3a68b2738d 100644
--- a/drivers/scsi/atp870u.c
+++ b/drivers/scsi/atp870u.c
@@ -1207,7 +1207,6 @@ static void tscam(struct Scsi_Host *host)
 
 static void is870(struct atp_unit *dev, unsigned int wkport)
 {
-	unsigned int tmport;
 	unsigned char i, j, k, rmb, n;
 	unsigned short int m;
 	static unsigned char mbuf[512];
@@ -1218,8 +1217,7 @@ static void is870(struct atp_unit *dev, unsigned int wkport)
 	static unsigned char synw[6] = { 0x80, 1, 3, 1, 0x0c, 0x07 };
 	static unsigned char wide[6] = { 0x80, 1, 2, 3, 1, 0 };
 	
-	tmport = wkport + 0x3a;
-	outb((unsigned char) (inb(tmport) | 0x10), tmport);
+	outb((unsigned char) (inb(wkport + 0x3a) | 0x10), wkport + 0x3a);
 
 	for (i = 0; i < 16; i++) {
 		if ((dev->chip_ver != 4) && (i > 7)) {
@@ -1234,135 +1232,105 @@ static void is870(struct atp_unit *dev, unsigned int wkport)
 			printk(KERN_INFO "         ID: %2d  Host Adapter\n", dev->host_id[0]);
 			continue;
 		}
-		tmport = wkport + 0x1b;
 		if (dev->chip_ver == 4) {
-			outb(0x01, tmport);
+			outb(0x01, wkport + 0x1b);
 		} else {
-			outb(0x00, tmport);
-		}
-		tmport = wkport + 1;
-		outb(0x08, tmport++);
-		outb(0x7f, tmport++);
-		outb(satn[0], tmport++);
-		outb(satn[1], tmport++);
-		outb(satn[2], tmport++);
-		outb(satn[3], tmport++);
-		outb(satn[4], tmport++);
-		outb(satn[5], tmport++);
-		tmport += 0x06;
-		outb(0, tmport);
-		tmport += 0x02;
-		outb(dev->id[0][i].devsp, tmport++);
-		outb(0, tmport++);
-		outb(satn[6], tmport++);
-		outb(satn[7], tmport++);
+			outb(0x00, wkport + 0x1b);
+		}
+		outb(0x08, wkport + 1);
+		outb(0x7f, wkport + 2);
+		outb(satn[0], wkport + 3);
+		outb(satn[1], wkport + 4);
+		outb(satn[2], wkport + 5);
+		outb(satn[3], wkport + 6);
+		outb(satn[4], wkport + 7);
+		outb(satn[5], wkport + 8);
+		outb(0, wkport + 0x0f);
+		outb(dev->id[0][i].devsp, wkport + 0x11);
+		outb(0, wkport + 0x12);
+		outb(satn[6], wkport + 0x13);
+		outb(satn[7], wkport + 0x14);
 		j = i;
 		if ((j & 0x08) != 0) {
 			j = (j & 0x07) | 0x40;
 		}
-		outb(j, tmport);
-		tmport += 0x03;
-		outb(satn[8], tmport);
-		tmport += 0x07;
+		outb(j, wkport + 0x15);
+		outb(satn[8], wkport + 0x18);
 
-		while ((inb(tmport) & 0x80) == 0x00)
+		while ((inb(wkport + 0x1f) & 0x80) == 0x00)
 			cpu_relax();
 
-		tmport -= 0x08;
-		if (inb(tmport) != 0x11 && inb(tmport) != 0x8e)
+		if (inb(wkport + 0x17) != 0x11 && inb(wkport + 0x17) != 0x8e)
 			continue;
 
-		while (inb(tmport) != 0x8e)
+		while (inb(wkport + 0x17) != 0x8e)
 			cpu_relax();
 
 		dev->active_id[0] |= m;
 
-		tmport = wkport + 0x10;
-		outb(0x30, tmport);
-		tmport = wkport + 0x04;
-		outb(0x00, tmport);
+		outb(0x30, wkport + 0x10);
+		outb(0x00, wkport + 0x04);
 
 phase_cmd:
-		tmport = wkport + 0x18;
-		outb(0x08, tmport);
-		tmport += 0x07;
-		while ((inb(tmport) & 0x80) == 0x00)
+		outb(0x08, wkport + 0x18);
+		while ((inb(wkport + 0x1f) & 0x80) == 0x00)
 			cpu_relax();
-		tmport -= 0x08;
-		j = inb(tmport);
+		j = inb(wkport + 0x17);
 		if (j != 0x16) {
-			tmport = wkport + 0x10;
-			outb(0x41, tmport);
+			outb(0x41, wkport + 0x10);
 			goto phase_cmd;
 		}
 sel_ok:
-		tmport = wkport + 3;
-		outb(inqd[0], tmport++);
-		outb(inqd[1], tmport++);
-		outb(inqd[2], tmport++);
-		outb(inqd[3], tmport++);
-		outb(inqd[4], tmport++);
-		outb(inqd[5], tmport);
-		tmport += 0x07;
-		outb(0, tmport);
-		tmport += 0x02;
-		outb(dev->id[0][i].devsp, tmport++);
-		outb(0, tmport++);
-		outb(inqd[6], tmport++);
-		outb(inqd[7], tmport++);
-		tmport += 0x03;
-		outb(inqd[8], tmport);
-		tmport += 0x07;
-
-		while ((inb(tmport) & 0x80) == 0x00)
+		outb(inqd[0], wkport + 3);
+		outb(inqd[1], wkport + 4);
+		outb(inqd[2], wkport + 5);
+		outb(inqd[3], wkport + 6);
+		outb(inqd[4], wkport + 7);
+		outb(inqd[5], wkport + 8);
+		outb(0, wkport + 0x0f);
+		outb(dev->id[0][i].devsp, wkport + 0x11);
+		outb(0, wkport + 0x12);
+		outb(inqd[6], wkport + 0x13);
+		outb(inqd[7], wkport + 0x14);
+		outb(inqd[8], wkport + 0x18);
+
+		while ((inb(wkport + 0x1f) & 0x80) == 0x00)
 			cpu_relax();
 			
-		tmport -= 0x08;
-		if (inb(tmport) != 0x11 && inb(tmport) != 0x8e)
+		if (inb(wkport + 0x17) != 0x11 && inb(wkport + 0x17) != 0x8e)
 			continue;
 
-		while (inb(tmport) != 0x8e)
+		while (inb(wkport + 0x17) != 0x8e)
 			cpu_relax();
 			
-		tmport = wkport + 0x1b;
 		if (dev->chip_ver == 4)
-			outb(0x00, tmport);
+			outb(0x00, wkport + 0x1b);
 
-		tmport = wkport + 0x18;
-		outb(0x08, tmport);
-		tmport += 0x07;
+		outb(0x08, wkport + 0x18);
 		j = 0;
 rd_inq_data:
-		k = inb(tmport);
+		k = inb(wkport + 0x1f);
 		if ((k & 0x01) != 0) {
-			tmport -= 0x06;
-			mbuf[j++] = inb(tmport);
-			tmport += 0x06;
+			mbuf[j++] = inb(wkport + 0x19);
 			goto rd_inq_data;
 		}
 		if ((k & 0x80) == 0) {
 			goto rd_inq_data;
 		}
-		tmport -= 0x08;
-		j = inb(tmport);
+		j = inb(wkport + 0x17);
 		if (j == 0x16) {
 			goto inq_ok;
 		}
-		tmport = wkport + 0x10;
-		outb(0x46, tmport);
-		tmport += 0x02;
-		outb(0, tmport++);
-		outb(0, tmport++);
-		outb(0, tmport++);
-		tmport += 0x03;
-		outb(0x08, tmport);
-		tmport += 0x07;
+		outb(0x46, wkport + 0x10);
+		outb(0, wkport + 0x12);
+		outb(0, wkport + 0x13);
+		outb(0, wkport + 0x14);
+		outb(0x08, wkport + 0x18);
 
-		while ((inb(tmport) & 0x80) == 0x00)
+		while ((inb(wkport + 0x1f) & 0x80) == 0x00)
 			cpu_relax();
 			
-		tmport -= 0x08;
-		if (inb(tmport) != 0x16) {
+		if (inb(wkport + 0x17) != 0x16) {
 			goto sel_ok;
 		}
 inq_ok:
@@ -1380,57 +1348,43 @@ static void is870(struct atp_unit *dev, unsigned int wkport)
 		if ((dev->global_map[0] & 0x20) == 0) {
 			goto not_wide;
 		}
-		tmport = wkport + 0x1b;
-		outb(0x01, tmport);
-		tmport = wkport + 3;
-		outb(satn[0], tmport++);
-		outb(satn[1], tmport++);
-		outb(satn[2], tmport++);
-		outb(satn[3], tmport++);
-		outb(satn[4], tmport++);
-		outb(satn[5], tmport++);
-		tmport += 0x06;
-		outb(0, tmport);
-		tmport += 0x02;
-		outb(dev->id[0][i].devsp, tmport++);
-		outb(0, tmport++);
-		outb(satn[6], tmport++);
-		outb(satn[7], tmport++);
-		tmport += 0x03;
-		outb(satn[8], tmport);
-		tmport += 0x07;
-
-		while ((inb(tmport) & 0x80) == 0x00)
+		outb(0x01, wkport + 0x1b);
+		outb(satn[0], wkport + 3);
+		outb(satn[1], wkport + 4);
+		outb(satn[2], wkport + 5);
+		outb(satn[3], wkport + 6);
+		outb(satn[4], wkport + 7);
+		outb(satn[5], wkport + 8);
+		outb(0, wkport + 0x0f);
+		outb(dev->id[0][i].devsp, wkport + 0x11);
+		outb(0, wkport + 0x12);
+		outb(satn[6], wkport + 0x13);
+		outb(satn[7], wkport + 0x14);
+		outb(satn[8], wkport + 0x18);
+
+		while ((inb(wkport + 0x1f) & 0x80) == 0x00)
 			cpu_relax();
 			
-		tmport -= 0x08;
-		if (inb(tmport) != 0x11 && inb(tmport) != 0x8e)
+		if (inb(wkport + 0x17) != 0x11 && inb(wkport + 0x17) != 0x8e)
 			continue;
 
-		while (inb(tmport) != 0x8e)
+		while (inb(wkport + 0x17) != 0x8e)
 			cpu_relax();
 			
 try_wide:
 		j = 0;
-		tmport = wkport + 0x14;
-		outb(0x05, tmport);
-		tmport += 0x04;
-		outb(0x20, tmport);
-		tmport += 0x07;
+		outb(0x05, wkport + 0x14);
+		outb(0x20, wkport + 0x18);
 
-		while ((inb(tmport) & 0x80) == 0) {
-			if ((inb(tmport) & 0x01) != 0) {
-				tmport -= 0x06;
-				outb(wide[j++], tmport);
-				tmport += 0x06;
-			}
+		while ((inb(wkport + 0x1f) & 0x80) == 0) {
+			if ((inb(wkport + 0x1f) & 0x01) != 0)
+				outb(wide[j++], wkport + 0x19);
 		}
-		tmport -= 0x08;
 		
-		while ((inb(tmport) & 0x80) == 0x00)
+		while ((inb(wkport + 0x17) & 0x80) == 0x00)
 			cpu_relax();
 			
-		j = inb(tmport) & 0x0f;
+		j = inb(wkport + 0x17) & 0x0f;
 		if (j == 0x0f) {
 			goto widep_in;
 		}
@@ -1442,18 +1396,12 @@ static void is870(struct atp_unit *dev, unsigned int wkport)
 		}
 		continue;
 widep_out:
-		tmport = wkport + 0x18;
-		outb(0x20, tmport);
-		tmport += 0x07;
-		while ((inb(tmport) & 0x80) == 0) {
-			if ((inb(tmport) & 0x01) != 0) {
-				tmport -= 0x06;
-				outb(0, tmport);
-				tmport += 0x06;
-			}
+		outb(0x20, wkport + 0x18);
+		while ((inb(wkport + 0x1f) & 0x80) == 0) {
+			if ((inb(wkport + 0x1f) & 0x01) != 0)
+				outb(0, wkport + 0x19);
 		}
-		tmport -= 0x08;
-		j = inb(tmport) & 0x0f;
+		j = inb(wkport + 0x17) & 0x0f;
 		if (j == 0x0f) {
 			goto widep_in;
 		}
@@ -1465,25 +1413,19 @@ static void is870(struct atp_unit *dev, unsigned int wkport)
 		}
 		continue;
 widep_in:
-		tmport = wkport + 0x14;
-		outb(0xff, tmport);
-		tmport += 0x04;
-		outb(0x20, tmport);
-		tmport += 0x07;
+		outb(0xff, wkport + 0x14);
+		outb(0x20, wkport + 0x18);
 		k = 0;
 widep_in1:
-		j = inb(tmport);
+		j = inb(wkport + 0x1f);
 		if ((j & 0x01) != 0) {
-			tmport -= 0x06;
-			mbuf[k++] = inb(tmport);
-			tmport += 0x06;
+			mbuf[k++] = inb(wkport + 0x19);
 			goto widep_in1;
 		}
 		if ((j & 0x80) == 0x00) {
 			goto widep_in1;
 		}
-		tmport -= 0x08;
-		j = inb(tmport) & 0x0f;
+		j = inb(wkport + 0x17) & 0x0f;
 		if (j == 0x0f) {
 			goto widep_in;
 		}
@@ -1495,19 +1437,14 @@ static void is870(struct atp_unit *dev, unsigned int wkport)
 		}
 		continue;
 widep_cmd:
-		tmport = wkport + 0x10;
-		outb(0x30, tmport);
-		tmport = wkport + 0x14;
-		outb(0x00, tmport);
-		tmport += 0x04;
-		outb(0x08, tmport);
-		tmport += 0x07;
+		outb(0x30, wkport + 0x10);
+		outb(0x00, wkport + 0x14);
+		outb(0x08, wkport + 0x18);
 		
-		while ((inb(tmport) & 0x80) == 0x00)
+		while ((inb(wkport + 0x1f) & 0x80) == 0x00)
 			cpu_relax();
 
-		tmport -= 0x08;
-		j = inb(tmport);
+		j = inb(wkport + 0x17);
 		if (j != 0x16) {
 			if (j == 0x4e) {
 				goto widep_out;
@@ -1535,69 +1472,56 @@ static void is870(struct atp_unit *dev, unsigned int wkport)
 		}
 		continue;
 set_sync:
-		tmport = wkport + 0x1b;
 		j = 0;
 		if ((m & dev->wide_id[0]) != 0) {
 			j |= 0x01;
 		}
-		outb(j, tmport);
-		tmport = wkport + 3;
-		outb(satn[0], tmport++);
-		outb(satn[1], tmport++);
-		outb(satn[2], tmport++);
-		outb(satn[3], tmport++);
-		outb(satn[4], tmport++);
-		outb(satn[5], tmport++);
-		tmport += 0x06;
-		outb(0, tmport);
-		tmport += 0x02;
-		outb(dev->id[0][i].devsp, tmport++);
-		outb(0, tmport++);
-		outb(satn[6], tmport++);
-		outb(satn[7], tmport++);
-		tmport += 0x03;
-		outb(satn[8], tmport);
-		tmport += 0x07;
-
-		while ((inb(tmport) & 0x80) == 0x00)
+		outb(j, wkport + 0x1b);
+		outb(satn[0], wkport + 3);
+		outb(satn[1], wkport + 4);
+		outb(satn[2], wkport + 5);
+		outb(satn[3], wkport + 6);
+		outb(satn[4], wkport + 7);
+		outb(satn[5], wkport + 8);
+		outb(0, wkport + 0x0f);
+		outb(dev->id[0][i].devsp, wkport + 0x11);
+		outb(0, wkport + 0x12);
+		outb(satn[6], wkport + 0x13);
+		outb(satn[7], wkport + 0x14);
+		outb(satn[8], wkport + 0x18);
+
+		while ((inb(wkport + 0x1f) & 0x80) == 0x00)
 			cpu_relax();
 			
-		tmport -= 0x08;
-		if (inb(tmport) != 0x11 && inb(tmport) != 0x8e)
+		if (inb(wkport + 0x17) != 0x11 && inb(wkport + 0x17) != 0x8e)
 			continue;
 
-		while (inb(tmport) != 0x8e)
+		while (inb(wkport + 0x17) != 0x8e)
 			cpu_relax();
 			
 try_sync:
 		j = 0;
-		tmport = wkport + 0x14;
-		outb(0x06, tmport);
-		tmport += 0x04;
-		outb(0x20, tmport);
-		tmport += 0x07;
+		outb(0x06, wkport + 0x14);
+		outb(0x20, wkport + 0x18);
 
-		while ((inb(tmport) & 0x80) == 0) {
-			if ((inb(tmport) & 0x01) != 0) {
-				tmport -= 0x06;
+		while ((inb(wkport + 0x1f) & 0x80) == 0) {
+			if ((inb(wkport + 0x1f) & 0x01) != 0) {
 				if ((m & dev->wide_id[0]) != 0) {
-					outb(synw[j++], tmport);
+					outb(synw[j++], wkport + 0x19);
 				} else {
 					if ((m & dev->ultra_map[0]) != 0) {
-						outb(synu[j++], tmport);
+						outb(synu[j++], wkport + 0x19);
 					} else {
-						outb(synn[j++], tmport);
+						outb(synn[j++], wkport + 0x19);
 					}
 				}
-				tmport += 0x06;
 			}
 		}
-		tmport -= 0x08;
 		
-		while ((inb(tmport) & 0x80) == 0x00)
+		while ((inb(wkport + 0x17) & 0x80) == 0x00)
 			cpu_relax();
 			
-		j = inb(tmport) & 0x0f;
+		j = inb(wkport + 0x17) & 0x0f;
 		if (j == 0x0f) {
 			goto phase_ins;
 		}
@@ -1609,18 +1533,12 @@ static void is870(struct atp_unit *dev, unsigned int wkport)
 		}
 		continue;
 phase_outs:
-		tmport = wkport + 0x18;
-		outb(0x20, tmport);
-		tmport += 0x07;
-		while ((inb(tmport) & 0x80) == 0x00) {
-			if ((inb(tmport) & 0x01) != 0x00) {
-				tmport -= 0x06;
-				outb(0x00, tmport);
-				tmport += 0x06;
-			}
+		outb(0x20, wkport + 0x18);
+		while ((inb(wkport + 0x1f) & 0x80) == 0x00) {
+			if ((inb(wkport + 0x1f) & 0x01) != 0x00)
+				outb(0x00, wkport + 0x19);
 		}
-		tmport -= 0x08;
-		j = inb(tmport);
+		j = inb(wkport + 0x17);
 		if (j == 0x85) {
 			goto tar_dcons;
 		}
@@ -1636,29 +1554,23 @@ static void is870(struct atp_unit *dev, unsigned int wkport)
 		}
 		continue;
 phase_ins:
-		tmport = wkport + 0x14;
-		outb(0xff, tmport);
-		tmport += 0x04;
-		outb(0x20, tmport);
-		tmport += 0x07;
+		outb(0xff, wkport + 0x14);
+		outb(0x20, wkport + 0x18);
 		k = 0;
 phase_ins1:
-		j = inb(tmport);
+		j = inb(wkport + 0x1f);
 		if ((j & 0x01) != 0x00) {
-			tmport -= 0x06;
-			mbuf[k++] = inb(tmport);
-			tmport += 0x06;
+			mbuf[k++] = inb(wkport + 0x19);
 			goto phase_ins1;
 		}
 		if ((j & 0x80) == 0x00) {
 			goto phase_ins1;
 		}
-		tmport -= 0x08;
 
-		while ((inb(tmport) & 0x80) == 0x00)
+		while ((inb(wkport + 0x17) & 0x80) == 0x00)
 			cpu_relax();
 			
-		j = inb(tmport);
+		j = inb(wkport + 0x17);
 		if (j == 0x85) {
 			goto tar_dcons;
 		}
@@ -1674,20 +1586,15 @@ static void is870(struct atp_unit *dev, unsigned int wkport)
 		}
 		continue;
 phase_cmds:
-		tmport = wkport + 0x10;
-		outb(0x30, tmport);
+		outb(0x30, wkport + 0x10);
 tar_dcons:
-		tmport = wkport + 0x14;
-		outb(0x00, tmport);
-		tmport += 0x04;
-		outb(0x08, tmport);
-		tmport += 0x07;
+		outb(0x00, wkport + 0x14);
+		outb(0x08, wkport + 0x18);
 		
-		while ((inb(tmport) & 0x80) == 0x00)
+		while ((inb(wkport + 0x1f) & 0x80) == 0x00)
 			cpu_relax();
 			
-		tmport -= 0x08;
-		j = inb(tmport);
+		j = inb(wkport + 0x17);
 		if (j != 0x16) {
 			continue;
 		}
@@ -1727,8 +1634,7 @@ static void is870(struct atp_unit *dev, unsigned int wkport)
 set_syn_ok:
 		dev->id[0][i].devsp = (dev->id[0][i].devsp & 0x0f) | j;
 	}
-	tmport = wkport + 0x3a;
-	outb((unsigned char) (inb(tmport) & 0xef), tmport);
+	outb((unsigned char) (inb(wkport + 0x3a) & 0xef), wkport + 0x3a);
 }
 
 static void is880(struct atp_unit *dev, unsigned int wkport)

commit 1940ed62f9ca6d0b1f4c10afef3960f4f8a7d327
Author: Ondrej Zary <linux@rainbow-software.org>
Date:   Tue Nov 17 19:23:41 2015 +0100

    atp870u: Untangle tmport #3
    
    Untangle the tmport crap so it becomes obvious what ports are accessed.
    
    Signed-off-by: Ondrej Zary <linux@rainbow-software.org>
    Reviewed-by: Hannes Reinicke <hare@suse.de>
    Acked-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/atp870u.c b/drivers/scsi/atp870u.c
index 71123372e52b..a23f38717d90 100644
--- a/drivers/scsi/atp870u.c
+++ b/drivers/scsi/atp870u.c
@@ -933,38 +933,36 @@ static void send_s870(struct atp_unit *dev,unsigned char c)
 
 static unsigned char fun_scam(struct atp_unit *dev, unsigned short int *val)
 {
-	unsigned int tmport;
 	unsigned short int i, k;
 	unsigned char j;
 
-	tmport = dev->ioport[0] + 0x1c;
-	outw(*val, tmport);
+	outw(*val, dev->ioport[0] + 0x1c);
 FUN_D7:
 	for (i = 0; i < 10; i++) {	/* stable >= bus settle delay(400 ns)  */
-		k = inw(tmport);
+		k = inw(dev->ioport[0] + 0x1c);
 		j = (unsigned char) (k >> 8);
 		if ((k & 0x8000) != 0) {	/* DB7 all release?    */
 			goto FUN_D7;
 		}
 	}
 	*val |= 0x4000;		/* assert DB6           */
-	outw(*val, tmport);
+	outw(*val, dev->ioport[0] + 0x1c);
 	*val &= 0xdfff;		/* assert DB5           */
-	outw(*val, tmport);
+	outw(*val, dev->ioport[0] + 0x1c);
 FUN_D5:
 	for (i = 0; i < 10; i++) {	/* stable >= bus settle delay(400 ns) */
-		if ((inw(tmport) & 0x2000) != 0) {	/* DB5 all release?       */
+		if ((inw(dev->ioport[0] + 0x1c) & 0x2000) != 0) {	/* DB5 all release?       */
 			goto FUN_D5;
 		}
 	}
 	*val |= 0x8000;		/* no DB4-0, assert DB7    */
 	*val &= 0xe0ff;
-	outw(*val, tmport);
+	outw(*val, dev->ioport[0] + 0x1c);
 	*val &= 0xbfff;		/* release DB6             */
-	outw(*val, tmport);
+	outw(*val, dev->ioport[0] + 0x1c);
 FUN_D6:
 	for (i = 0; i < 10; i++) {	/* stable >= bus settle delay(400 ns)  */
-		if ((inw(tmport) & 0x4000) != 0) {	/* DB6 all release?  */
+		if ((inw(dev->ioport[0] + 0x1c) & 0x4000) != 0) {	/* DB6 all release?  */
 			goto FUN_D6;
 		}
 	}
@@ -975,7 +973,6 @@ static unsigned char fun_scam(struct atp_unit *dev, unsigned short int *val)
 static void tscam(struct Scsi_Host *host)
 {
 
-	unsigned int tmport;
 	unsigned char i, j, k;
 	unsigned long n;
 	unsigned short int m, assignid_map, val;
@@ -992,11 +989,9 @@ static void tscam(struct Scsi_Host *host)
 	}
  */
 
-	tmport = dev->ioport[0] + 1;
-	outb(0x08, tmport++);
-	outb(0x7f, tmport);
-	tmport = dev->ioport[0] + 0x11;
-	outb(0x20, tmport);
+	outb(0x08, dev->ioport[0] + 1);
+	outb(0x7f, dev->ioport[0] + 2);
+	outb(0x20, dev->ioport[0] + 0x11);
 
 	if ((dev->scam_on & 0x40) == 0) {
 		return;
@@ -1009,14 +1004,13 @@ static void tscam(struct Scsi_Host *host)
 		j = 8;
 	}
 	assignid_map = m;
-	tmport = dev->ioport[0] + 0x02;
-	outb(0x02, tmport++);	/* 2*2=4ms,3EH 2/32*3E=3.9ms */
-	outb(0, tmport++);
-	outb(0, tmport++);
-	outb(0, tmport++);
-	outb(0, tmport++);
-	outb(0, tmport++);
-	outb(0, tmport++);
+	outb(0x02, dev->ioport[0] + 0x02);	/* 2*2=4ms,3EH 2/32*3E=3.9ms */
+	outb(0, dev->ioport[0] + 0x03);
+	outb(0, dev->ioport[0] + 0x04);
+	outb(0, dev->ioport[0] + 0x05);
+	outb(0, dev->ioport[0] + 0x06);
+	outb(0, dev->ioport[0] + 0x07);
+	outb(0, dev->ioport[0] + 0x08);
 
 	for (i = 0; i < j; i++) {
 		m = 1;
@@ -1024,79 +1018,69 @@ static void tscam(struct Scsi_Host *host)
 		if ((m & assignid_map) != 0) {
 			continue;
 		}
-		tmport = dev->ioport[0] + 0x0f;
-		outb(0, tmport++);
-		tmport += 0x02;
-		outb(0, tmport++);
-		outb(0, tmport++);
-		outb(0, tmport++);
+		outb(0, dev->ioport[0] + 0x0f);
+		outb(0, dev->ioport[0] + 0x12);
+		outb(0, dev->ioport[0] + 0x13);
+		outb(0, dev->ioport[0] + 0x14);
 		if (i > 7) {
 			k = (i & 0x07) | 0x40;
 		} else {
 			k = i;
 		}
-		outb(k, tmport++);
-		tmport = dev->ioport[0] + 0x1b;
+		outb(k, dev->ioport[0] + 0x15);
 		if (dev->chip_ver == 4) {
-			outb(0x01, tmport);
+			outb(0x01, dev->ioport[0] + 0x1b);
 		} else {
-			outb(0x00, tmport);
+			outb(0x00, dev->ioport[0] + 0x1b);
 		}
 wait_rdyok:
-		tmport = dev->ioport[0] + 0x18;
-		outb(0x09, tmport);
-		tmport += 0x07;
+		outb(0x09, dev->ioport[0] + 0x18);
 
-		while ((inb(tmport) & 0x80) == 0x00)
+		while ((inb(dev->ioport[0] + 0x1f) & 0x80) == 0x00)
 			cpu_relax();
-		tmport -= 0x08;
-		k = inb(tmport);
+		k = inb(dev->ioport[0] + 0x17);
 		if (k != 0x16) {
 			if ((k == 0x85) || (k == 0x42)) {
 				continue;
 			}
-			tmport = dev->ioport[0] + 0x10;
-			outb(0x41, tmport);
+			outb(0x41, dev->ioport[0] + 0x10);
 			goto wait_rdyok;
 		}
 		assignid_map |= m;
 
 	}
-	tmport = dev->ioport[0] + 0x02;
-	outb(0x7f, tmport);
-	tmport = dev->ioport[0] + 0x1b;
-	outb(0x02, tmport);
+	outb(0x7f, dev->ioport[0] + 0x02);
+	outb(0x02, dev->ioport[0] + 0x1b);
 
 	outb(0, 0x80);
 
 	val = 0x0080;		/* bsy  */
-	tmport = dev->ioport[0] + 0x1c;
-	outw(val, tmport);
+	outw(val, dev->ioport[0] + 0x1c);
 	val |= 0x0040;		/* sel  */
-	outw(val, tmport);
+	outw(val, dev->ioport[0] + 0x1c);
 	val |= 0x0004;		/* msg  */
-	outw(val, tmport);
+	outw(val, dev->ioport[0] + 0x1c);
 	inb(0x80);		/* 2 deskew delay(45ns*2=90ns) */
 	val &= 0x007f;		/* no bsy  */
-	outw(val, tmport);
+	outw(val, dev->ioport[0] + 0x1c);
 	mdelay(128);
 	val &= 0x00fb;		/* after 1ms no msg */
-	outw(val, tmport);
+	outw(val, dev->ioport[0] + 0x1c);
 wait_nomsg:
-	if ((inb(tmport) & 0x04) != 0) {
+	if ((inb(dev->ioport[0] + 0x1c) & 0x04) != 0) {
 		goto wait_nomsg;
 	}
 	outb(1, 0x80);
 	udelay(100);
 	for (n = 0; n < 0x30000; n++) {
-		if ((inb(tmport) & 0x80) != 0) {	/* bsy ? */
+		if ((inb(dev->ioport[0] + 0x1c) & 0x80) != 0) {	/* bsy ? */
 			goto wait_io;
 		}
 	}
 	goto TCM_SYNC;
 wait_io:
 	for (n = 0; n < 0x30000; n++) {
-		if ((inb(tmport) & 0x81) == 0x0081) {
+		if ((inb(dev->ioport[0] + 0x1c) & 0x81) == 0x0081) {
 			goto wait_io1;
 		}
 	}
@@ -1104,10 +1088,10 @@ static void tscam(struct Scsi_Host *host)
 wait_io1:
 	inb(0x80);
 	val |= 0x8003;		/* io,cd,db7  */
-	outw(val, tmport);
+	outw(val, dev->ioport[0] + 0x1c);
 	inb(0x80);
 	val &= 0x00bf;		/* no sel     */
-	outw(val, tmport);
+	outw(val, dev->ioport[0] + 0x1c);
 	outb(2, 0x80);
 TCM_SYNC:
 	/*
@@ -1120,18 +1104,14 @@ static void tscam(struct Scsi_Host *host)
 	 */
 	mdelay(2);
 	udelay(48);
-	if ((inb(tmport) & 0x80) == 0x00) {	/* bsy ? */
-		outw(0, tmport--);
-		outb(0, tmport);
-		tmport = dev->ioport[0] + 0x15;
-		outb(0, tmport);
-		tmport += 0x03;
-		outb(0x09, tmport);
-		tmport += 0x07;
-		while ((inb(tmport) & 0x80) == 0)
+	if ((inb(dev->ioport[0] + 0x1c) & 0x80) == 0x00) {	/* bsy ? */
+		outw(0, dev->ioport[0] + 0x1c);
+		outb(0, dev->ioport[0] + 0x1b);
+		outb(0, dev->ioport[0] + 0x15);
+		outb(0x09, dev->ioport[0] + 0x18);
+		while ((inb(dev->ioport[0] + 0x1f) & 0x80) == 0)
 			cpu_relax();
-		tmport -= 0x08;
-		inb(tmport);
+		inb(dev->ioport[0] + 0x17);
 		return;
 	}
 	val &= 0x00ff;		/* synchronization  */
@@ -1145,7 +1125,7 @@ static void tscam(struct Scsi_Host *host)
 	i = 8;
 	j = 0;
 TCM_ID:
-	if ((inw(tmport) & 0x2000) == 0) {
+	if ((inw(dev->ioport[0] + 0x1c) & 0x2000) == 0) {
 		goto TCM_ID;
 	}
 	outb(5, 0x80);

commit 3b836464809aff2795c22ba2a97f3b148e70282e
Author: Ondrej Zary <linux@rainbow-software.org>
Date:   Tue Nov 17 19:23:40 2015 +0100

    atp870u: Untangle tmport #2
    
    Untangle the tmport crap so it becomes obvious what ports are accessed.
    
    Signed-off-by: Ondrej Zary <linux@rainbow-software.org>
    Reviewed-by: Hannes Reinicke <hare@suse.de>
    Acked-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/atp870u.c b/drivers/scsi/atp870u.c
index a25a300efde8..71123372e52b 100644
--- a/drivers/scsi/atp870u.c
+++ b/drivers/scsi/atp870u.c
@@ -562,7 +562,7 @@ static int atp870u_queuecommand_lck(struct scsi_cmnd *req_p,
 			 void (*done) (struct scsi_cmnd *))
 {
 	unsigned char c;
-	unsigned int tmport,m;	
+	unsigned int m;
 	struct atp_unit *dev;
 	struct Scsi_Host *host;
 
@@ -631,11 +631,10 @@ static int atp870u_queuecommand_lck(struct scsi_cmnd *req_p,
 		return 0;
 	}
 	dev->quereq[c][dev->quend[c]] = req_p;
-	tmport = dev->ioport[c] + 0x1c;
 #ifdef ED_DBGP	
-	printk("dev->ioport[c] = %x inb(tmport) = %x dev->in_int[%d] = %d dev->in_snd[%d] = %d\n",dev->ioport[c],inb(tmport),c,dev->in_int[c],c,dev->in_snd[c]);
+	printk("dev->ioport[c] = %x inb(dev->ioport[c] + 0x1c) = %x dev->in_int[%d] = %d dev->in_snd[%d] = %d\n",dev->ioport[c],inb(dev->ioport[c] + 0x1c),c,dev->in_int[c],c,dev->in_snd[c]);
 #endif
-	if ((inb(tmport) == 0) && (dev->in_int[c] == 0) && (dev->in_snd[c] == 0)) {
+	if ((inb(dev->ioport[c] + 0x1c) == 0) && (dev->in_int[c] == 0) && (dev->in_snd[c] == 0)) {
 #ifdef ED_DBGP
 		printk("Call sent_s870(atp870u_queuecommand)\n");
 #endif		
@@ -660,7 +659,6 @@ static DEF_SCSI_QCMD(atp870u_queuecommand)
  */
 static void send_s870(struct atp_unit *dev,unsigned char c)
 {
-	unsigned int tmport;
 	struct scsi_cmnd *workreq;
 	unsigned int i;//,k;
 	unsigned char  j, target_id;
@@ -712,12 +710,10 @@ static void send_s870(struct atp_unit *dev,unsigned char c)
 	dev->in_snd[c] = 0;
 	return;
 cmd_subp:
-	tmport = dev->ioport[c] + 0x1f;
-	if ((inb(tmport) & 0xb0) != 0) {
+	if ((inb(dev->ioport[c] + 0x1f) & 0xb0) != 0) {
 		goto abortsnd;
 	}
-	tmport = dev->ioport[c] + 0x1c;
-	if (inb(tmport) == 0) {
+	if (inb(dev->ioport[c] + 0x1c) == 0) {
 		goto oktosend;
 	}
 abortsnd:
@@ -752,7 +748,6 @@ static void send_s870(struct atp_unit *dev,unsigned char c)
 		l = 0;
 	}
 
-	tmport = dev->ioport[c] + 0x1b;
 	j = 0;
 	target_id = scmd_id(workreq);
 
@@ -764,9 +759,9 @@ static void send_s870(struct atp_unit *dev,unsigned char c)
 	if ((w & dev->wide_id[c]) != 0) {
 		j |= 0x01;
 	}
-	outb(j, tmport);
-	while ((inb(tmport) & 0x01) != j) {
-		outb(j,tmport);
+	outb(j, dev->ioport[c] + 0x1b);
+	while ((inb(dev->ioport[c] + 0x1b) & 0x01) != j) {
+		outb(j,dev->ioport[c] + 0x1b);
 #ifdef ED_DBGP
 		printk("send_s870 while loop 1\n");
 #endif
@@ -775,24 +770,21 @@ static void send_s870(struct atp_unit *dev,unsigned char c)
 	 *	Write the command
 	 */
 
-	tmport = dev->ioport[c];
-	outb(workreq->cmd_len, tmport++);
-	outb(0x2c, tmport++);
+	outb(workreq->cmd_len, dev->ioport[c] + 0x00);
+	outb(0x2c, dev->ioport[c] + 0x01);
 	if (dev->dev_id == ATP885_DEVID) {
-		outb(0x7f, tmport++);
+		outb(0x7f, dev->ioport[c] + 0x02);
 	} else {
-		outb(0xcf, tmport++); 	
+		outb(0xcf, dev->ioport[c] + 0x02);
 	}	
 	for (i = 0; i < workreq->cmd_len; i++) {
-		outb(workreq->cmnd[i], tmport++);
+		outb(workreq->cmnd[i], dev->ioport[c] + 0x03 + i);
 	}
-	tmport = dev->ioport[c] + 0x0f;
-	outb(workreq->device->lun, tmport);
-	tmport += 0x02;
+	outb(workreq->device->lun, dev->ioport[c] + 0x0f);
 	/*
 	 *	Write the target
 	 */
-	outb(dev->id[c][target_id].devsp, tmport++);	 
+	outb(dev->id[c][target_id].devsp, dev->ioport[c] + 0x11);
 #ifdef ED_DBGP	
 	printk("dev->id[%d][%d].devsp = %2x\n",c,target_id,dev->id[c][target_id].devsp);
 #endif
@@ -801,9 +793,9 @@ static void send_s870(struct atp_unit *dev,unsigned char c)
 	/*
 	 *	Write transfer size
 	 */
-	outb((unsigned char) (((unsigned char *) (&l))[2]), tmport++);
-	outb((unsigned char) (((unsigned char *) (&l))[1]), tmport++);
-	outb((unsigned char) (((unsigned char *) (&l))[0]), tmport++);
+	outb((unsigned char) (((unsigned char *) (&l))[2]), dev->ioport[c] + 0x12);
+	outb((unsigned char) (((unsigned char *) (&l))[1]), dev->ioport[c] + 0x13);
+	outb((unsigned char) (((unsigned char *) (&l))[0]), dev->ioport[c] + 0x14);
 	j = target_id;	
 	dev->id[c][j].last_len = l;
 	dev->id[c][j].tran_len = 0;
@@ -820,21 +812,19 @@ static void send_s870(struct atp_unit *dev,unsigned char c)
 	 *	Check transfer direction
 	 */
 	if (workreq->sc_data_direction == DMA_TO_DEVICE) {
-		outb((unsigned char) (j | 0x20), tmport++);
+		outb((unsigned char) (j | 0x20), dev->ioport[c] + 0x15);
 	} else {
-		outb(j, tmport++);
+		outb(j, dev->ioport[c] + 0x15);
 	}
-	outb((unsigned char) (inb(tmport) | 0x80), tmport);
-	outb(0x80, tmport);
-	tmport = dev->ioport[c] + 0x1c;
+	outb((unsigned char) (inb(dev->ioport[c] + 0x16) | 0x80), dev->ioport[c] + 0x16);
+	outb(0x80, dev->ioport[c] + 0x16);
 	dev->id[c][target_id].dirct = 0;
 	if (l == 0) {
-		if (inb(tmport) == 0) {
-			tmport = dev->ioport[c] + 0x18;
+		if (inb(dev->ioport[c] + 0x1c) == 0) {
 #ifdef ED_DBGP
 			printk("change SCSI_CMD_REG 0x08\n");	
 #endif				
-			outb(0x08, tmport);
+			outb(0x08, dev->ioport[c] + 0x18);
 		} else {
 			dev->last_cmd[c] |= 0x40;
 		}
@@ -899,28 +889,24 @@ static void send_s870(struct atp_unit *dev,unsigned char c)
 	} else if ((dev->dev_id == ATP880_DEVID1) ||
 	    	   (dev->dev_id == ATP880_DEVID2)) {
 		tmpcip =tmpcip -2;	
-		tmport = dev->ioport[c] - 0x05;
 		if ((workreq->cmnd[0] == 0x08) || (workreq->cmnd[0] == 0x28) || (workreq->cmnd[0] == 0x0a) || (workreq->cmnd[0] == 0x2a)) {
-			outb((unsigned char) ((inb(tmport) & 0x3f) | 0xc0), tmport);
+			outb((unsigned char) ((inb(dev->ioport[c] - 0x05) & 0x3f) | 0xc0), dev->ioport[c] - 0x05);
 		} else {
-			outb((unsigned char) (inb(tmport) & 0x3f), tmport);
+			outb((unsigned char) (inb(dev->ioport[c] - 0x05) & 0x3f), dev->ioport[c] - 0x05);
 		}		
 	} else {		
 		tmpcip =tmpcip -2;
-		tmport = dev->ioport[c] + 0x3a;
 		if ((workreq->cmnd[0] == 0x08) || (workreq->cmnd[0] == 0x28) || (workreq->cmnd[0] == 0x0a) || (workreq->cmnd[0] == 0x2a)) {
-			outb((inb(tmport) & 0xf3) | 0x08, tmport);
+			outb((inb(dev->ioport[c] + 0x3a) & 0xf3) | 0x08, dev->ioport[c] + 0x3a);
 		} else {
-			outb(inb(tmport) & 0xf3, tmport);
+			outb(inb(dev->ioport[c] + 0x3a) & 0xf3, dev->ioport[c] + 0x3a);
 		}		
 	}	
-	tmport = dev->ioport[c] + 0x1c;
 
 	if(workreq->sc_data_direction == DMA_TO_DEVICE) {
 		dev->id[c][target_id].dirct = 0x20;
-		if (inb(tmport) == 0) {
-			tmport = dev->ioport[c] + 0x18;
-			outb(0x08, tmport);
+		if (inb(dev->ioport[c] + 0x1c) == 0) {
+			outb(0x08, dev->ioport[c] + 0x18);
 			outb(0x01, tmpcip);
 #ifdef ED_DBGP		
 		printk( "start DMA(to target)\n");
@@ -931,9 +917,8 @@ static void send_s870(struct atp_unit *dev,unsigned char c)
 		dev->in_snd[c] = 0;
 		return;
 	}
-	if (inb(tmport) == 0) {		
-		tmport = dev->ioport[c] + 0x18;
-		outb(0x08, tmport);
+	if (inb(dev->ioport[c] + 0x1c) == 0) {
+		outb(0x08, dev->ioport[c] + 0x18);
 		outb(0x09, tmpcip);
 #ifdef ED_DBGP		
 		printk( "start DMA(to host)\n");

commit 3a38e53ee6c6542410a32374a3bd5ae6c8fc9f09
Author: Ondrej Zary <linux@rainbow-software.org>
Date:   Tue Nov 17 19:23:39 2015 +0100

    atp870u: Untangle tmport
    
    Untangle the tmport crap so it becomes obvious what ports are accessed.
    
    Signed-off-by: Ondrej Zary <linux@rainbow-software.org>
    Reviewed-by: Hannes Reinicke <hare@suse.de>
    Acked-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/atp870u.c b/drivers/scsi/atp870u.c
index aac7d4733a6e..a25a300efde8 100644
--- a/drivers/scsi/atp870u.c
+++ b/drivers/scsi/atp870u.c
@@ -51,7 +51,6 @@ static irqreturn_t atp870u_intr_handle(int irq, void *dev_id)
 	unsigned char i, j, c, target_id, lun,cmdp;
 	unsigned char *prd;
 	struct scsi_cmnd *workreq;
-	unsigned int tmport;
 	unsigned long adrcnt, k;
 #ifdef ED_DBGP
 	unsigned long l;
@@ -61,8 +60,7 @@ static irqreturn_t atp870u_intr_handle(int irq, void *dev_id)
 	struct atp_unit *dev = (struct atp_unit *)&host->hostdata;
 
 	for (c = 0; c < 2; c++) {
-		tmport = dev->ioport[c] + 0x1f;
-		j = inb(tmport);
+		j = inb(dev->ioport[c] + 0x1f);
 		if ((j & 0x80) != 0)
 		{			
 	   		goto ch_sel;
@@ -97,9 +95,8 @@ static irqreturn_t atp870u_intr_handle(int irq, void *dev_id)
 stop_dma:
 		tmpcip = dev->pciport[c];
 		outb(0x00, tmpcip);
-		tmport -= 0x08;
 		
-		i = inb(tmport);
+		i = inb(dev->ioport[c] + 0x17);
 		
 		if (dev->dev_id == ATP885_DEVID) {
 			tmpcip += 2;
@@ -107,9 +104,7 @@ static irqreturn_t atp870u_intr_handle(int irq, void *dev_id)
 			tmpcip -= 2;
 		}
 
-		tmport -= 0x02;
-		target_id = inb(tmport);
-		tmport += 0x02;
+		target_id = inb(dev->ioport[c] + 0x15);
 
 		/*
 		 *	Remap wide devices onto id numbers
@@ -137,11 +132,10 @@ static irqreturn_t atp870u_intr_handle(int irq, void *dev_id)
 			   dev->last_cmd[c] = 0xff;
 			}
 			if (dev->dev_id == ATP885_DEVID) {
-				tmport -= 0x05;
 				adrcnt = 0;
-				((unsigned char *) &adrcnt)[2] = inb(tmport++);
-				((unsigned char *) &adrcnt)[1] = inb(tmport++);
-				((unsigned char *) &adrcnt)[0] = inb(tmport);
+				((unsigned char *) &adrcnt)[2] = inb(dev->ioport[c] + 0x12);
+				((unsigned char *) &adrcnt)[1] = inb(dev->ioport[c] + 0x13);
+				((unsigned char *) &adrcnt)[0] = inb(dev->ioport[c] + 0x14);
 				if (dev->id[c][target_id].last_len != adrcnt)
 				{
 			   		k = dev->id[c][target_id].last_len;
@@ -150,7 +144,7 @@ static irqreturn_t atp870u_intr_handle(int irq, void *dev_id)
 			   	dev->id[c][target_id].last_len = adrcnt;			   
 				}
 #ifdef ED_DBGP
-				printk("tmport = %x dev->id[c][target_id].last_len = %d dev->id[c][target_id].tran_len = %d\n",tmport,dev->id[c][target_id].last_len,dev->id[c][target_id].tran_len);
+				printk("dev->id[c][target_id].last_len = %d dev->id[c][target_id].tran_len = %d\n",dev->id[c][target_id].last_len,dev->id[c][target_id].tran_len);
 #endif		
 			}
 
@@ -158,10 +152,9 @@ static irqreturn_t atp870u_intr_handle(int irq, void *dev_id)
 			 *      Flip wide
 			 */			
 			if (dev->wide_id[c] != 0) {
-				tmport = dev->ioport[c] + 0x1b;
-				outb(0x01, tmport);
-				while ((inb(tmport) & 0x01) != 0x01) {
-					outb(0x01, tmport);
+				outb(0x01, dev->ioport[c] + 0x1b);
+				while ((inb(dev->ioport[c] + 0x1b) & 0x01) != 0x01) {
+					outb(0x01, dev->ioport[c] + 0x1b);
 				}
 			}		
 			/*
@@ -196,19 +189,16 @@ static irqreturn_t atp870u_intr_handle(int irq, void *dev_id)
 			if ((dev->last_cmd[c] & 0xf0) != 0x40) {
 			   dev->last_cmd[c] = 0xff;
 			}
-			tmport -= 0x05;
 			adrcnt = 0;
-			((unsigned char *) &adrcnt)[2] = inb(tmport++);
-			((unsigned char *) &adrcnt)[1] = inb(tmport++);
-			((unsigned char *) &adrcnt)[0] = inb(tmport);
+			((unsigned char *) &adrcnt)[2] = inb(dev->ioport[c] + 0x12);
+			((unsigned char *) &adrcnt)[1] = inb(dev->ioport[c] + 0x13);
+			((unsigned char *) &adrcnt)[0] = inb(dev->ioport[c] + 0x14);
 			k = dev->id[c][target_id].last_len;
 			k -= adrcnt;
 			dev->id[c][target_id].tran_len = k;
 			dev->id[c][target_id].last_len = adrcnt;
-			tmport -= 0x04;
-			outb(0x41, tmport);
-			tmport += 0x08;
-			outb(0x08, tmport);
+			outb(0x41, dev->ioport[c] + 0x10);
+			outb(0x08, dev->ioport[c] + 0x18);
 			dev->in_int[c] = 0;
 			goto handled;
 		}
@@ -227,10 +217,8 @@ static irqreturn_t atp870u_intr_handle(int irq, void *dev_id)
 			printk(KERN_DEBUG "Device reselect\n");
 #endif			
 			lun = 0;
-			tmport -= 0x07;
 			if (cmdp == 0x44 || i==0x80) {
-				tmport += 0x0d;
-				lun = inb(tmport) & 0x07;
+				lun = inb(dev->ioport[c] + 0x1d) & 0x07;
 			} else {
 				if ((dev->last_cmd[c] & 0xf0) != 0x40) {
 				   dev->last_cmd[c] = 0xff;
@@ -239,31 +227,27 @@ static irqreturn_t atp870u_intr_handle(int irq, void *dev_id)
 #ifdef ED_DBGP
 					printk("cmdp = 0x41\n");
 #endif						
-					tmport += 0x02;
 					adrcnt = 0;
-					((unsigned char *) &adrcnt)[2] = inb(tmport++);
-					((unsigned char *) &adrcnt)[1] = inb(tmport++);
-					((unsigned char *) &adrcnt)[0] = inb(tmport);
+					((unsigned char *) &adrcnt)[2] = inb(dev->ioport[c] + 0x12);
+					((unsigned char *) &adrcnt)[1] = inb(dev->ioport[c] + 0x13);
+					((unsigned char *) &adrcnt)[0] = inb(dev->ioport[c] + 0x14);
 					k = dev->id[c][target_id].last_len;
 					k -= adrcnt;
 					dev->id[c][target_id].tran_len = k;
 					dev->id[c][target_id].last_len = adrcnt;
-					tmport += 0x04;
-					outb(0x08, tmport);
+					outb(0x08, dev->ioport[c] + 0x18);
 					dev->in_int[c] = 0;
 					goto handled;
 				} else {
 #ifdef ED_DBGP
 					printk("cmdp != 0x41\n");
 #endif						
-					outb(0x46, tmport);
+					outb(0x46, dev->ioport[c] + 0x10);
 					dev->id[c][target_id].dirct = 0x00;
-					tmport += 0x02;
-					outb(0x00, tmport++);
-					outb(0x00, tmport++);
-					outb(0x00, tmport++);
-					tmport += 0x03;
-					outb(0x08, tmport);
+					outb(0x00, dev->ioport[c] + 0x12);
+					outb(0x00, dev->ioport[c] + 0x13);
+					outb(0x00, dev->ioport[c] + 0x14);
+					outb(0x08, dev->ioport[c] + 0x18);
 					dev->in_int[c] = 0;
 					goto handled;
 				}
@@ -274,14 +258,10 @@ static irqreturn_t atp870u_intr_handle(int irq, void *dev_id)
 			if (dev->dev_id == ATP885_DEVID) {
 				j = inb(dev->baseport + 0x29) & 0xfe;
 				outb(j, dev->baseport + 0x29);
-				tmport = dev->ioport[c] + 0x16;
-			} else {
-				tmport = dev->ioport[c] + 0x10;
-				outb(0x45, tmport);
-				tmport += 0x06;				
-			}
-			
-			target_id = inb(tmport);
+			} else
+				outb(0x45, dev->ioport[c] + 0x10);
+
+			target_id = inb(dev->ioport[c] + 0x16);
 			/*
 			 *	Remap wide identifiers
 			 */
@@ -290,10 +270,8 @@ static irqreturn_t atp870u_intr_handle(int irq, void *dev_id)
 			} else {
 				target_id &= 0x07;
 			}
-			if (dev->dev_id == ATP885_DEVID) {
-				tmport = dev->ioport[c] + 0x10;
-				outb(0x45, tmport);
-			}
+			if (dev->dev_id == ATP885_DEVID)
+				outb(0x45, dev->ioport[c] + 0x10);
 			workreq = dev->id[c][target_id].curr_req;
 #ifdef ED_DBGP			
 			scmd_printk(KERN_DEBUG, workreq, "CDB");
@@ -302,18 +280,16 @@ static irqreturn_t atp870u_intr_handle(int irq, void *dev_id)
 			printk("\n");
 #endif	
 			
-			tmport = dev->ioport[c] + 0x0f;
-			outb(lun, tmport);
-			tmport += 0x02;
-			outb(dev->id[c][target_id].devsp, tmport++);
+			outb(lun, dev->ioport[c] + 0x0f);
+			outb(dev->id[c][target_id].devsp, dev->ioport[c] + 0x11);
 			adrcnt = dev->id[c][target_id].tran_len;
 			k = dev->id[c][target_id].last_len;
 
-			outb(((unsigned char *) &k)[2], tmport++);
-			outb(((unsigned char *) &k)[1], tmport++);
-			outb(((unsigned char *) &k)[0], tmport++);
+			outb(((unsigned char *) &k)[2], dev->ioport[c] + 0x12);
+			outb(((unsigned char *) &k)[1], dev->ioport[c] + 0x13);
+			outb(((unsigned char *) &k)[0], dev->ioport[c] + 0x14);
 #ifdef ED_DBGP			
-			printk("k %x, k[0] 0x%x k[1] 0x%x k[2] 0x%x\n", k, inb(tmport-1), inb(tmport-2), inb(tmport-3));
+			printk("k %x, k[0] 0x%x k[1] 0x%x k[2] 0x%x\n", k, inb(dev->ioport[c] + 0x14), inb(dev->ioport[c] + 0x13), inb(dev->ioport[c] + 0x12));
 #endif			
 			/* Remap wide */
 			j = target_id;
@@ -322,8 +298,8 @@ static irqreturn_t atp870u_intr_handle(int irq, void *dev_id)
 			}
 			/* Add direction */
 			j |= dev->id[c][target_id].dirct;
-			outb(j, tmport++);
-			outb(0x80,tmport);
+			outb(j, dev->ioport[c] + 0x15);
+			outb(0x80, dev->ioport[c] + 0x16);
 			
 			/* enable 32 bit fifo transfer */	
 			if (dev->dev_id == ATP885_DEVID) {
@@ -336,21 +312,18 @@ static irqreturn_t atp870u_intr_handle(int irq, void *dev_id)
 				outb(i,tmpcip);		    		    		
 			} else if ((dev->dev_id == ATP880_DEVID1) ||
 	    		    	   (dev->dev_id == ATP880_DEVID2) ) {
-				tmport = dev->ioport[c] - 0x05;
 				if ((workreq->cmnd[0] == 0x08) || (workreq->cmnd[0] == 0x28) || (workreq->cmnd[0] == 0x0a) || (workreq->cmnd[0] == 0x2a)) {
-					outb((unsigned char) ((inb(tmport) & 0x3f) | 0xc0), tmport);
+					outb((unsigned char) ((inb(dev->ioport[c] - 0x05) & 0x3f) | 0xc0), dev->ioport[c] - 0x05);///minus 0x05???
 				} else {
-					outb((unsigned char) (inb(tmport) & 0x3f), tmport);
+					outb((unsigned char) (inb(dev->ioport[c] - 0x05) & 0x3f), dev->ioport[c] - 0x05);///minus 0x05???
 				}
 			} else {				
-				tmport = dev->ioport[c] + 0x3a;
 				if ((workreq->cmnd[0] == 0x08) || (workreq->cmnd[0] == 0x28) || (workreq->cmnd[0] == 0x0a) || (workreq->cmnd[0] == 0x2a)) {
-					outb((unsigned char) ((inb(tmport) & 0xf3) | 0x08), tmport);
+					outb((unsigned char) ((inb(dev->ioport[c] + 0x3a) & 0xf3) | 0x08), dev->ioport[c] + 0x3a);
 				} else {
-					outb((unsigned char) (inb(tmport) & 0xf3), tmport);
+					outb((unsigned char) (inb(dev->ioport[c] + 0x3a) & 0xf3), dev->ioport[c] + 0x3a);
 				}														
 			}	
-			tmport = dev->ioport[c] + 0x1b;
 			j = 0;
 			id = 1;
 			id = id << target_id;
@@ -360,13 +333,12 @@ static irqreturn_t atp870u_intr_handle(int irq, void *dev_id)
 			if ((id & dev->wide_id[c]) != 0) {
 				j |= 0x01;
 			}
-			outb(j, tmport);
-			while ((inb(tmport) & 0x01) != j) {
-				outb(j,tmport);
+			outb(j, dev->ioport[c] + 0x1b);
+			while ((inb(dev->ioport[c] + 0x1b) & 0x01) != j) {
+				outb(j,dev->ioport[c] + 0x1b);
 			}
 			if (dev->id[c][target_id].last_len == 0) {
-				tmport = dev->ioport[c] + 0x18;
-				outb(0x08, tmport);
+				outb(0x08, dev->ioport[c] + 0x18);
 				dev->in_int[c] = 0;
 #ifdef ED_DBGP
 				printk("dev->id[c][target_id].last_len = 0\n");
@@ -412,12 +384,11 @@ static irqreturn_t atp870u_intr_handle(int irq, void *dev_id)
 				outb(0x00, tmpcip);
 				tmpcip -= 0x02;
 			}
-			tmport = dev->ioport[c] + 0x18;
 			/*
 			 *	Check transfer direction
 			 */
 			if (dev->id[c][target_id].dirct != 0) {
-				outb(0x08, tmport);
+				outb(0x08, dev->ioport[c] + 0x18);
 				outb(0x01, tmpcip);
 				dev->in_int[c] = 0;
 #ifdef ED_DBGP
@@ -425,7 +396,7 @@ static irqreturn_t atp870u_intr_handle(int irq, void *dev_id)
 #endif				
 				goto handled;
 			}
-			outb(0x08, tmport);
+			outb(0x08, dev->ioport[c] + 0x18);
 			outb(0x09, tmpcip);
 			dev->in_int[c] = 0;
 #ifdef ED_DBGP
@@ -454,8 +425,7 @@ static irqreturn_t atp870u_intr_handle(int irq, void *dev_id)
 			   dev->last_cmd[c] = 0xff;
 			}
 			errstus = 0;
-			tmport -= 0x08;
-			errstus = inb(tmport);
+			errstus = inb(dev->ioport[c] + 0x0f);
 			if (((dev->r1f[c][target_id] & 0x10) != 0)&&(dev->dev_id==ATP885_DEVID)) {
 			   printk(KERN_WARNING "AEC67162 CRC ERROR !\n");
 			   errstus = 0x02;
@@ -486,10 +456,9 @@ static irqreturn_t atp870u_intr_handle(int irq, void *dev_id)
 			 *      Take it back wide
 			 */
 			if (dev->wide_id[c] != 0) {
-				tmport = dev->ioport[c] + 0x1b;
-				outb(0x01, tmport);
-				while ((inb(tmport) & 0x01) != 0x01) {
-					outb(0x01, tmport);
+				outb(0x01, dev->ioport[c] + 0x1b);
+				while ((inb(dev->ioport[c] + 0x1b) & 0x01) != 0x01) {
+					outb(0x01, dev->ioport[c] + 0x1b);
 				}       
 			} 
 			/*
@@ -521,21 +490,17 @@ static irqreturn_t atp870u_intr_handle(int irq, void *dev_id)
 			outb(0x06, tmpcip);
 			outb(0x00, tmpcip);
 			tmpcip = tmpcip - 2;
-			tmport = dev->ioport[c] + 0x10;
-			outb(0x41, tmport);
+			outb(0x41, dev->ioport[c] + 0x10);
 			if (dev->dev_id == ATP885_DEVID) {
-				tmport += 2;
 				k = dev->id[c][target_id].last_len;
-				outb((unsigned char) (((unsigned char *) (&k))[2]), tmport++);
-				outb((unsigned char) (((unsigned char *) (&k))[1]), tmport++);
-				outb((unsigned char) (((unsigned char *) (&k))[0]), tmport);
+				outb((unsigned char) (((unsigned char *) (&k))[2]), dev->ioport[c] + 0x12);
+				outb((unsigned char) (((unsigned char *) (&k))[1]), dev->ioport[c] + 0x13);
+				outb((unsigned char) (((unsigned char *) (&k))[0]), dev->ioport[c] + 0x14);
 				dev->id[c][target_id].dirct = 0x00;
-				tmport += 0x04;
 			} else {
 				dev->id[c][target_id].dirct = 0x00;
-				tmport += 0x08;				
 			}
-			outb(0x08, tmport);
+			outb(0x08, dev->ioport[c] + 0x18);
 			outb(0x09, tmpcip);
 			dev->in_int[c] = 0;
 			goto handled;
@@ -547,43 +512,34 @@ static irqreturn_t atp870u_intr_handle(int irq, void *dev_id)
 			outb(0x06, tmpcip);
 			outb(0x00, tmpcip);
 			tmpcip = tmpcip - 2;
-			tmport = dev->ioport[c] + 0x10;
-			outb(0x41, tmport);
+			outb(0x41, dev->ioport[c] + 0x10);
 			if (dev->dev_id == ATP885_DEVID) {		
-				tmport += 2;
 				k = dev->id[c][target_id].last_len;
-				outb((unsigned char) (((unsigned char *) (&k))[2]), tmport++);
-				outb((unsigned char) (((unsigned char *) (&k))[1]), tmport++);
-				outb((unsigned char) (((unsigned char *) (&k))[0]), tmport++);
-			} else {
-				tmport += 5;
+				outb((unsigned char) (((unsigned char *) (&k))[2]), dev->ioport[c] + 0x12);
+				outb((unsigned char) (((unsigned char *) (&k))[1]), dev->ioport[c] + 0x13);
+				outb((unsigned char) (((unsigned char *) (&k))[0]), dev->ioport[c] + 0x14);
 			}
-			outb((unsigned char) (inb(tmport) | 0x20), tmport);
+			outb((unsigned char) (inb(dev->ioport[c] + 0x15) | 0x20), dev->ioport[c] + 0x15);
 			dev->id[c][target_id].dirct = 0x20;
-			tmport += 0x03;
-			outb(0x08, tmport);
+			outb(0x08, dev->ioport[c] + 0x18);
 			outb(0x01, tmpcip);
 			dev->in_int[c] = 0;
 			goto handled;
 		}
-		tmport -= 0x07;
 		if (i == 0x0a) {
-			outb(0x30, tmport);
+			outb(0x30, dev->ioport[c] + 0x10);
 		} else {
-			outb(0x46, tmport);
+			outb(0x46, dev->ioport[c] + 0x10);
 		}
 		dev->id[c][target_id].dirct = 0x00;
-		tmport += 0x02;
-		outb(0x00, tmport++);
-		outb(0x00, tmport++);
-		outb(0x00, tmport++);
-		tmport += 0x03;
-		outb(0x08, tmport);
+		outb(0x00, dev->ioport[c] + 0x12);
+		outb(0x00, dev->ioport[c] + 0x13);
+		outb(0x00, dev->ioport[c] + 0x14);
+		outb(0x08, dev->ioport[c] + 0x18);
 		dev->in_int[c] = 0;
 		goto handled;
 	} else {
-//		tmport = dev->ioport[c] + 0x17;
-//		inb(tmport);
+//		inb(dev->ioport[c] + 0x17);
 //		dev->working[c] = 0;
 		dev->in_int[c] = 0;
 		goto handled;

commit b4263b3ce9bac236ee9317153a735ffeb635c0d9
Author: Ondrej Zary <linux@rainbow-software.org>
Date:   Tue Nov 17 19:23:38 2015 +0100

    atp870u: Remove tmport1
    
    Remove tmport1 temporary variable to simplify the code.
    
    Signed-off-by: Ondrej Zary <linux@rainbow-software.org>
    Reviewed-by: Hannes Reinicke <hare@suse.de>
    Acked-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/atp870u.c b/drivers/scsi/atp870u.c
index 3db9d0cdc625..aac7d4733a6e 100644
--- a/drivers/scsi/atp870u.c
+++ b/drivers/scsi/atp870u.c
@@ -51,7 +51,7 @@ static irqreturn_t atp870u_intr_handle(int irq, void *dev_id)
 	unsigned char i, j, c, target_id, lun,cmdp;
 	unsigned char *prd;
 	struct scsi_cmnd *workreq;
-	unsigned int tmport, tmport1;
+	unsigned int tmport;
 	unsigned long adrcnt, k;
 #ifdef ED_DBGP
 	unsigned long l;
@@ -78,9 +78,8 @@ static irqreturn_t atp870u_intr_handle(int irq, void *dev_id)
 	cmdp = inb(dev->ioport[c] + 0x10);
 	if (dev->working[c] != 0) {
 		if (dev->dev_id == ATP885_DEVID) {
-			tmport1 = dev->ioport[c] + 0x16;
-			if ((inb(tmport1) & 0x80) == 0)
-				outb((inb(tmport1) | 0x80), tmport1);
+			if ((inb(dev->ioport[c] + 0x16) & 0x80) == 0)
+				outb((inb(dev->ioport[c] + 0x16) | 0x80), dev->ioport[c] + 0x16);
 		}		
 		tmpcip = dev->pciport[c];
 		if ((inb(tmpcip) & 0x08) != 0)

commit c43cd036e531ca54b885dee535f535ab58bf8a0f
Author: Ondrej Zary <linux@rainbow-software.org>
Date:   Tue Nov 17 19:23:37 2015 +0100

    atp870u: Remove workport
    
    Remove workport temporary variable to simplify the code.
    
    Signed-off-by: Ondrej Zary <linux@rainbow-software.org>
    Reviewed-by: Hannes Reinicke <hare@suse.de>
    Acked-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/atp870u.c b/drivers/scsi/atp870u.c
index 05301bc752ee..3db9d0cdc625 100644
--- a/drivers/scsi/atp870u.c
+++ b/drivers/scsi/atp870u.c
@@ -51,7 +51,7 @@ static irqreturn_t atp870u_intr_handle(int irq, void *dev_id)
 	unsigned char i, j, c, target_id, lun,cmdp;
 	unsigned char *prd;
 	struct scsi_cmnd *workreq;
-	unsigned int workport, tmport, tmport1;
+	unsigned int tmport, tmport1;
 	unsigned long adrcnt, k;
 #ifdef ED_DBGP
 	unsigned long l;
@@ -76,10 +76,9 @@ static irqreturn_t atp870u_intr_handle(int irq, void *dev_id)
 #endif	
 	dev->in_int[c] = 1;
 	cmdp = inb(dev->ioport[c] + 0x10);
-	workport = dev->ioport[c];
 	if (dev->working[c] != 0) {
 		if (dev->dev_id == ATP885_DEVID) {
-			tmport1 = workport + 0x16;
+			tmport1 = dev->ioport[c] + 0x16;
 			if ((inb(tmport1) & 0x80) == 0)
 				outb((inb(tmport1) | 0x80), tmport1);
 		}		
@@ -160,7 +159,7 @@ static irqreturn_t atp870u_intr_handle(int irq, void *dev_id)
 			 *      Flip wide
 			 */			
 			if (dev->wide_id[c] != 0) {
-				tmport = workport + 0x1b;
+				tmport = dev->ioport[c] + 0x1b;
 				outb(0x01, tmport);
 				while ((inb(tmport) & 0x01) != 0x01) {
 					outb(0x01, tmport);
@@ -276,9 +275,9 @@ static irqreturn_t atp870u_intr_handle(int irq, void *dev_id)
 			if (dev->dev_id == ATP885_DEVID) {
 				j = inb(dev->baseport + 0x29) & 0xfe;
 				outb(j, dev->baseport + 0x29);
-				tmport = workport + 0x16;
+				tmport = dev->ioport[c] + 0x16;
 			} else {
-				tmport = workport + 0x10;
+				tmport = dev->ioport[c] + 0x10;
 				outb(0x45, tmport);
 				tmport += 0x06;				
 			}
@@ -293,7 +292,7 @@ static irqreturn_t atp870u_intr_handle(int irq, void *dev_id)
 				target_id &= 0x07;
 			}
 			if (dev->dev_id == ATP885_DEVID) {
-				tmport = workport + 0x10;
+				tmport = dev->ioport[c] + 0x10;
 				outb(0x45, tmport);
 			}
 			workreq = dev->id[c][target_id].curr_req;
@@ -304,7 +303,7 @@ static irqreturn_t atp870u_intr_handle(int irq, void *dev_id)
 			printk("\n");
 #endif	
 			
-			tmport = workport + 0x0f;
+			tmport = dev->ioport[c] + 0x0f;
 			outb(lun, tmport);
 			tmport += 0x02;
 			outb(dev->id[c][target_id].devsp, tmport++);
@@ -338,21 +337,21 @@ static irqreturn_t atp870u_intr_handle(int irq, void *dev_id)
 				outb(i,tmpcip);		    		    		
 			} else if ((dev->dev_id == ATP880_DEVID1) ||
 	    		    	   (dev->dev_id == ATP880_DEVID2) ) {
-				tmport = workport - 0x05;
+				tmport = dev->ioport[c] - 0x05;
 				if ((workreq->cmnd[0] == 0x08) || (workreq->cmnd[0] == 0x28) || (workreq->cmnd[0] == 0x0a) || (workreq->cmnd[0] == 0x2a)) {
 					outb((unsigned char) ((inb(tmport) & 0x3f) | 0xc0), tmport);
 				} else {
 					outb((unsigned char) (inb(tmport) & 0x3f), tmport);
 				}
 			} else {				
-				tmport = workport + 0x3a;
+				tmport = dev->ioport[c] + 0x3a;
 				if ((workreq->cmnd[0] == 0x08) || (workreq->cmnd[0] == 0x28) || (workreq->cmnd[0] == 0x0a) || (workreq->cmnd[0] == 0x2a)) {
 					outb((unsigned char) ((inb(tmport) & 0xf3) | 0x08), tmport);
 				} else {
 					outb((unsigned char) (inb(tmport) & 0xf3), tmport);
 				}														
 			}	
-			tmport = workport + 0x1b;
+			tmport = dev->ioport[c] + 0x1b;
 			j = 0;
 			id = 1;
 			id = id << target_id;
@@ -367,7 +366,7 @@ static irqreturn_t atp870u_intr_handle(int irq, void *dev_id)
 				outb(j,tmport);
 			}
 			if (dev->id[c][target_id].last_len == 0) {
-				tmport = workport + 0x18;
+				tmport = dev->ioport[c] + 0x18;
 				outb(0x08, tmport);
 				dev->in_int[c] = 0;
 #ifdef ED_DBGP
@@ -414,7 +413,7 @@ static irqreturn_t atp870u_intr_handle(int irq, void *dev_id)
 				outb(0x00, tmpcip);
 				tmpcip -= 0x02;
 			}
-			tmport = workport + 0x18;
+			tmport = dev->ioport[c] + 0x18;
 			/*
 			 *	Check transfer direction
 			 */
@@ -488,7 +487,7 @@ static irqreturn_t atp870u_intr_handle(int irq, void *dev_id)
 			 *      Take it back wide
 			 */
 			if (dev->wide_id[c] != 0) {
-				tmport = workport + 0x1b;
+				tmport = dev->ioport[c] + 0x1b;
 				outb(0x01, tmport);
 				while ((inb(tmport) & 0x01) != 0x01) {
 					outb(0x01, tmport);
@@ -523,7 +522,7 @@ static irqreturn_t atp870u_intr_handle(int irq, void *dev_id)
 			outb(0x06, tmpcip);
 			outb(0x00, tmpcip);
 			tmpcip = tmpcip - 2;
-			tmport = workport + 0x10;
+			tmport = dev->ioport[c] + 0x10;
 			outb(0x41, tmport);
 			if (dev->dev_id == ATP885_DEVID) {
 				tmport += 2;
@@ -549,7 +548,7 @@ static irqreturn_t atp870u_intr_handle(int irq, void *dev_id)
 			outb(0x06, tmpcip);
 			outb(0x00, tmpcip);
 			tmpcip = tmpcip - 2;
-			tmport = workport + 0x10;
+			tmport = dev->ioport[c] + 0x10;
 			outb(0x41, tmport);
 			if (dev->dev_id == ATP885_DEVID) {		
 				tmport += 2;
@@ -584,7 +583,7 @@ static irqreturn_t atp870u_intr_handle(int irq, void *dev_id)
 		dev->in_int[c] = 0;
 		goto handled;
 	} else {
-//		tmport = workport + 0x17;
+//		tmport = dev->ioport[c] + 0x17;
 //		inb(tmport);
 //		dev->working[c] = 0;
 		dev->in_int[c] = 0;
@@ -713,7 +712,6 @@ static void send_s870(struct atp_unit *dev,unsigned char c)
 	unsigned char *prd;
 	unsigned short int tmpcip, w;
 	unsigned long l, bttl = 0;
-	unsigned int workport;
 	unsigned long  sg_count;
 
 	if (dev->in_snd[c] != 0) {
@@ -759,12 +757,11 @@ static void send_s870(struct atp_unit *dev,unsigned char c)
 	dev->in_snd[c] = 0;
 	return;
 cmd_subp:
-	workport = dev->ioport[c];
-	tmport = workport + 0x1f;
+	tmport = dev->ioport[c] + 0x1f;
 	if ((inb(tmport) & 0xb0) != 0) {
 		goto abortsnd;
 	}
-	tmport = workport + 0x1c;
+	tmport = dev->ioport[c] + 0x1c;
 	if (inb(tmport) == 0) {
 		goto oktosend;
 	}
@@ -800,7 +797,7 @@ static void send_s870(struct atp_unit *dev,unsigned char c)
 		l = 0;
 	}
 
-	tmport = workport + 0x1b;
+	tmport = dev->ioport[c] + 0x1b;
 	j = 0;
 	target_id = scmd_id(workreq);
 
@@ -823,7 +820,7 @@ static void send_s870(struct atp_unit *dev,unsigned char c)
 	 *	Write the command
 	 */
 
-	tmport = workport;
+	tmport = dev->ioport[c];
 	outb(workreq->cmd_len, tmport++);
 	outb(0x2c, tmport++);
 	if (dev->dev_id == ATP885_DEVID) {
@@ -834,7 +831,7 @@ static void send_s870(struct atp_unit *dev,unsigned char c)
 	for (i = 0; i < workreq->cmd_len; i++) {
 		outb(workreq->cmnd[i], tmport++);
 	}
-	tmport = workport + 0x0f;
+	tmport = dev->ioport[c] + 0x0f;
 	outb(workreq->device->lun, tmport);
 	tmport += 0x02;
 	/*
@@ -874,11 +871,11 @@ static void send_s870(struct atp_unit *dev,unsigned char c)
 	}
 	outb((unsigned char) (inb(tmport) | 0x80), tmport);
 	outb(0x80, tmport);
-	tmport = workport + 0x1c;
+	tmport = dev->ioport[c] + 0x1c;
 	dev->id[c][target_id].dirct = 0;
 	if (l == 0) {
 		if (inb(tmport) == 0) {
-			tmport = workport + 0x18;
+			tmport = dev->ioport[c] + 0x18;
 #ifdef ED_DBGP
 			printk("change SCSI_CMD_REG 0x08\n");	
 #endif				
@@ -947,7 +944,7 @@ static void send_s870(struct atp_unit *dev,unsigned char c)
 	} else if ((dev->dev_id == ATP880_DEVID1) ||
 	    	   (dev->dev_id == ATP880_DEVID2)) {
 		tmpcip =tmpcip -2;	
-		tmport = workport - 0x05;
+		tmport = dev->ioport[c] - 0x05;
 		if ((workreq->cmnd[0] == 0x08) || (workreq->cmnd[0] == 0x28) || (workreq->cmnd[0] == 0x0a) || (workreq->cmnd[0] == 0x2a)) {
 			outb((unsigned char) ((inb(tmport) & 0x3f) | 0xc0), tmport);
 		} else {
@@ -955,19 +952,19 @@ static void send_s870(struct atp_unit *dev,unsigned char c)
 		}		
 	} else {		
 		tmpcip =tmpcip -2;
-		tmport = workport + 0x3a;
+		tmport = dev->ioport[c] + 0x3a;
 		if ((workreq->cmnd[0] == 0x08) || (workreq->cmnd[0] == 0x28) || (workreq->cmnd[0] == 0x0a) || (workreq->cmnd[0] == 0x2a)) {
 			outb((inb(tmport) & 0xf3) | 0x08, tmport);
 		} else {
 			outb(inb(tmport) & 0xf3, tmport);
 		}		
 	}	
-	tmport = workport + 0x1c;
+	tmport = dev->ioport[c] + 0x1c;
 
 	if(workreq->sc_data_direction == DMA_TO_DEVICE) {
 		dev->id[c][target_id].dirct = 0x20;
 		if (inb(tmport) == 0) {
-			tmport = workport + 0x18;
+			tmport = dev->ioport[c] + 0x18;
 			outb(0x08, tmport);
 			outb(0x01, tmpcip);
 #ifdef ED_DBGP		
@@ -980,7 +977,7 @@ static void send_s870(struct atp_unit *dev,unsigned char c)
 		return;
 	}
 	if (inb(tmport) == 0) {		
-		tmport = workport + 0x18;
+		tmport = dev->ioport[c] + 0x18;
 		outb(0x08, tmport);
 		outb(0x09, tmpcip);
 #ifdef ED_DBGP		

commit b84b1d522f979fb53ad347605e24b2940fa2ad99
Author: Hannes Reinecke <hare@suse.de>
Date:   Wed Apr 29 08:57:34 2015 +0200

    scsi: Do not set cmd_per_lun to 1 in the host template
    
    '0' is now used as the default cmd_per_lun value,
    so there's no need to explicitly set it to '1' in the
    host template.
    
    Signed-off-by: Hannes Reinecke <hare@suse.de>
    Reviewed-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: James Bottomley <JBottomley@Odin.com>

diff --git a/drivers/scsi/atp870u.c b/drivers/scsi/atp870u.c
index 0836433e3a2d..05301bc752ee 100644
--- a/drivers/scsi/atp870u.c
+++ b/drivers/scsi/atp870u.c
@@ -3158,7 +3158,6 @@ static struct scsi_host_template atp870u_template = {
      .can_queue         	= qcnt			/* can_queue */,
      .this_id           	= 7			/* SCSI ID */,
      .sg_tablesize      	= ATP870U_SCATTER	/*SG_ALL*/ /*SG_NONE*/,
-     .cmd_per_lun       	= ATP870U_CMDLUN		/* commands per lun */,
      .use_clustering    	= ENABLE_CLUSTERING,
      .max_sectors		= ATP870U_MAX_SECTORS,
 };

commit 3d30079c3a9000504cf71e4e8dd94619070dc4f3
Author: Rasmus Villemoes <linux@rasmusvillemoes.dk>
Date:   Wed Dec 3 00:10:53 2014 +0100

    scsi: merge consecutive seq_puts calls
    
    Consecutive seq_puts calls with literal strings may be replaced by a
    single call, saving a little .text.
    
    Signed-off-by: Rasmus Villemoes <linux@rasmusvillemoes.dk>
    Reviewed-by: Finn Thain <fthain@telegraphics.com.au>
    Signed-off-by: Christoph Hellwig <hch@lst.de>

diff --git a/drivers/scsi/atp870u.c b/drivers/scsi/atp870u.c
index 0b0246716646..0836433e3a2d 100644
--- a/drivers/scsi/atp870u.c
+++ b/drivers/scsi/atp870u.c
@@ -3101,9 +3101,8 @@ static const char *atp870u_info(struct Scsi_Host *notused)
 
 static int atp870u_show_info(struct seq_file *m, struct Scsi_Host *HBAptr)
 {
-	seq_puts(m, "ACARD AEC-671X Driver Version: 2.6+ac\n");
-	seq_puts(m, "\n");
-	seq_puts(m, "Adapter Configuration:\n");
+	seq_puts(m, "ACARD AEC-671X Driver Version: 2.6+ac\n\n"
+		"Adapter Configuration:\n");
 	seq_printf(m, "               Base IO: %#.4lx\n", HBAptr->io_port);
 	seq_printf(m, "                   IRQ: %d\n", HBAptr->irq);
 	return 0;

commit 91c40f24faadd977ee9209fee6a760e72a50d19c
Author: Rasmus Villemoes <linux@rasmusvillemoes.dk>
Date:   Wed Dec 3 00:10:52 2014 +0100

    scsi: replace seq_printf with seq_puts
    
    Using seq_printf to print a simple string is a lot more expensive than
    it needs to be, since seq_puts exists. Replace seq_printf with
    seq_puts when possible.
    
    Signed-off-by: Rasmus Villemoes <linux@rasmusvillemoes.dk>
    Reviewed-by: Finn Thain <fthain@telegraphics.com.au>
    Signed-off-by: Christoph Hellwig <hch@lst.de>

diff --git a/drivers/scsi/atp870u.c b/drivers/scsi/atp870u.c
index a795d81ef875..0b0246716646 100644
--- a/drivers/scsi/atp870u.c
+++ b/drivers/scsi/atp870u.c
@@ -3101,9 +3101,9 @@ static const char *atp870u_info(struct Scsi_Host *notused)
 
 static int atp870u_show_info(struct seq_file *m, struct Scsi_Host *HBAptr)
 {
-	seq_printf(m, "ACARD AEC-671X Driver Version: 2.6+ac\n");
-	seq_printf(m, "\n");
-	seq_printf(m, "Adapter Configuration:\n");
+	seq_puts(m, "ACARD AEC-671X Driver Version: 2.6+ac\n");
+	seq_puts(m, "\n");
+	seq_puts(m, "Adapter Configuration:\n");
 	seq_printf(m, "               Base IO: %#.4lx\n", HBAptr->io_port);
 	seq_printf(m, "                   IRQ: %d\n", HBAptr->irq);
 	return 0;

commit 08b7e10716a518af01b07915dbb1938868bbf878
Author: Jingoo Han <jg1.han@samsung.com>
Date:   Tue Sep 24 10:16:20 2013 +0900

    SCSI: remove unnecessary pci_set_drvdata()
    
    Since commit 0998d0631001288a5974afc0b2a5f568bcdecb4d
    (device-core: Ensure drvdata = NULL when no driver is bound),
    the driver core clears the driver data to NULL after device_release
    or on probe failure. Thus, it is not needed to manually clear the
    device driver data to NULL.
    
    Signed-off-by: Jingoo Han <jg1.han@samsung.com>
    Cc: James Bottomley <JBottomley@parallels.com>
    Signed-off-by: Jiri Kosina <jkosina@suse.cz>

diff --git a/drivers/scsi/atp870u.c b/drivers/scsi/atp870u.c
index 15a629d8ed08..a795d81ef875 100644
--- a/drivers/scsi/atp870u.c
+++ b/drivers/scsi/atp870u.c
@@ -3144,8 +3144,6 @@ static void atp870u_remove (struct pci_dev *pdev)
 	atp870u_free_tables(pshost);
 	printk(KERN_INFO "scsi_host_put : %p\n",pshost);
 	scsi_host_put(pshost);
-	printk(KERN_INFO "pci_set_drvdata : %p\n",pdev);
-	pci_set_drvdata(pdev, NULL);	
 }
 MODULE_LICENSE("GPL");
 

commit d773e42213bcec26400732e494e2d8e37dc08c92
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Sun Mar 31 03:26:26 2013 -0400

    atp870u: switch to ->show_info()
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/drivers/scsi/atp870u.c b/drivers/scsi/atp870u.c
index cfc73041f102..15a629d8ed08 100644
--- a/drivers/scsi/atp870u.c
+++ b/drivers/scsi/atp870u.c
@@ -3099,38 +3099,14 @@ static const char *atp870u_info(struct Scsi_Host *notused)
 	return buffer;
 }
 
-#define BLS buffer + len + size
-static int atp870u_proc_info(struct Scsi_Host *HBAptr, char *buffer, 
-			     char **start, off_t offset, int length, int inout)
+static int atp870u_show_info(struct seq_file *m, struct Scsi_Host *HBAptr)
 {
-	static u8 buff[512];
-	int size = 0;
-	int len = 0;
-	off_t begin = 0;
-	off_t pos = 0;
-	
-	if (inout) 	
-		return -EINVAL;
-	if (offset == 0)
-		memset(buff, 0, sizeof(buff));
-	size += sprintf(BLS, "ACARD AEC-671X Driver Version: 2.6+ac\n");
-	len += size;
-	pos = begin + len;
-	size = 0;
-
-	size += sprintf(BLS, "\n");
-	size += sprintf(BLS, "Adapter Configuration:\n");
-	size += sprintf(BLS, "               Base IO: %#.4lx\n", HBAptr->io_port);
-	size += sprintf(BLS, "                   IRQ: %d\n", HBAptr->irq);
-	len += size;
-	pos = begin + len;
-	
-	*start = buffer + (offset - begin);	/* Start of wanted data */
-	len -= (offset - begin);	/* Start slop */
-	if (len > length) {
-		len = length;	/* Ending slop */
-	}
-	return (len);
+	seq_printf(m, "ACARD AEC-671X Driver Version: 2.6+ac\n");
+	seq_printf(m, "\n");
+	seq_printf(m, "Adapter Configuration:\n");
+	seq_printf(m, "               Base IO: %#.4lx\n", HBAptr->io_port);
+	seq_printf(m, "                   IRQ: %d\n", HBAptr->irq);
+	return 0;
 }
 
 
@@ -3177,7 +3153,7 @@ static struct scsi_host_template atp870u_template = {
      .module			= THIS_MODULE,
      .name              	= "atp870u"		/* name */,
      .proc_name			= "atp870u",
-     .proc_info			= atp870u_proc_info,
+     .show_info			= atp870u_show_info,
      .info              	= atp870u_info		/* info */,
      .queuecommand      	= atp870u_queuecommand	/* queuecommand */,
      .eh_abort_handler  	= atp870u_abort		/* abort */,

commit 6f039790510fd630ff348efe8c4802dbaa041fba
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Fri Dec 21 13:08:55 2012 -0800

    Drivers: scsi: remove __dev* attributes.
    
    CONFIG_HOTPLUG is going away as an option.  As a result, the __dev*
    markings need to be removed.
    
    This change removes the use of __devinit, __devexit_p, __devinitdata,
    __devinitconst, and __devexit from these drivers.
    
    Based on patches originally written by Bill Pemberton, but redone by me
    in order to handle some of the coding style issues better, by hand.
    
    Cc: Bill Pemberton <wfp5p@virginia.edu>
    Cc: Adam Radford <linuxraid@lsi.com>
    Cc: "James E.J. Bottomley" <JBottomley@parallels.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/scsi/atp870u.c b/drivers/scsi/atp870u.c
index a540162ac59c..cfc73041f102 100644
--- a/drivers/scsi/atp870u.c
+++ b/drivers/scsi/atp870u.c
@@ -3210,7 +3210,7 @@ static struct pci_driver atp870u_driver = {
 	.id_table	= atp870u_id_table,
 	.name		= "atp870u",
 	.probe		= atp870u_probe,
-	.remove		= __devexit_p(atp870u_remove),
+	.remove		= atp870u_remove,
 };
 
 static int __init atp870u_init(void)

commit 0f6d93aa9d96cc9022b51bd10d462b03296be146
Author: Martin Michlmayr <tbm@cyrius.com>
Date:   Thu Oct 4 17:11:25 2012 -0700

    drivers/scsi/atp870u.c: fix bad use of udelay
    
    The ACARD driver calls udelay() with a value > 2000, which leads to to
    the following compilation error on ARM:
    
      ERROR: "__bad_udelay" [drivers/scsi/atp870u.ko] undefined!
      make[1]: *** [__modpost] Error 1
    
    This is because udelay is defined on ARM, roughly speaking, as
    
            #define udelay(n) ((n) > 2000 ? __bad_udelay() : \
                    __const_udelay((n) * ((2199023U*HZ)>>11)))
    
    The argument to __const_udelay is the number of jiffies to wait divided
    by 4, but this does not work unless the multiplication does not
    overflow, and that is what the build error is designed to prevent.  The
    intended behavior can be achieved by using mdelay to call udelay
    multiple times in a loop.
    
    [jrnieder@gmail.com: adding context]
    Signed-off-by: Martin Michlmayr <tbm@cyrius.com>
    Signed-off-by: Jonathan Nieder <jrnieder@gmail.com>
    Cc: James Bottomley <James.Bottomley@HansenPartnership.com>
    Cc: <stable@vger.kernel.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/scsi/atp870u.c b/drivers/scsi/atp870u.c
index 68ce08552f69..a540162ac59c 100644
--- a/drivers/scsi/atp870u.c
+++ b/drivers/scsi/atp870u.c
@@ -1173,7 +1173,16 @@ static void tscam(struct Scsi_Host *host)
 	outw(val, tmport);
 	outb(2, 0x80);
 TCM_SYNC:
-	udelay(0x800);
+	/*
+	 * The funny division into multiple delays is to accomodate
+	 * arches like ARM where udelay() multiplies its argument by
+	 * a large number to initialize a loop counter.  To avoid
+	 * overflow, the maximum supported udelay is 2000 microseconds.
+	 *
+	 * XXX it would be more polite to find a way to use msleep()
+	 */
+	mdelay(2);
+	udelay(48);
 	if ((inb(tmport) & 0x80) == 0x00) {	/* bsy ? */
 		outw(0, tmport--);
 		outb(0, tmport);

commit a75ee6ecd411a50bf4da927c2fdb2cb56246a2bd
Merge: c9651e70ad0a 699316948628
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sat Mar 31 13:31:23 2012 -0700

    Merge tag 'scsi-misc' of git://git.kernel.org/pub/scm/linux/kernel/git/jejb/scsi-misc-2.6
    
    Pull SCSI updates from James Bottomley:
     "This is primarily another round of driver updates (lpfc, bfa, fcoe,
      ipr) plus a new ufshcd driver.  There shouldn't be anything
      controversial in here (The final deletion of scsi proc_ops which
      caused some build breakage has been held over until the next merge
      window to give us more time to stabilise it).
    
      I'm afraid, with me moving continents at exactly the wrong time,
      anything submitted after the merge window opened has been held over to
      the next merge window."
    
    * tag 'scsi-misc' of git://git.kernel.org/pub/scm/linux/kernel/git/jejb/scsi-misc-2.6: (63 commits)
      [SCSI] ipr: Driver version 2.5.3
      [SCSI] ipr: Increase alignment boundary of command blocks
      [SCSI] ipr: Increase max concurrent oustanding commands
      [SCSI] ipr: Remove unnecessary memory barriers
      [SCSI] ipr: Remove unnecessary interrupt clearing on new adapters
      [SCSI] ipr: Fix target id allocation re-use problem
      [SCSI] atp870u, mpt2sas, qla4xxx use pci_dev->revision
      [SCSI] fcoe: Drop the rtnl_mutex before calling fcoe_ctlr_link_up
      [SCSI] bfa: Update the driver version to 3.0.23.0
      [SCSI] bfa: BSG and User interface fixes.
      [SCSI] bfa: Fix to avoid vport delete hang on request queue full scenario.
      [SCSI] bfa: Move service parameter programming logic into firmware.
      [SCSI] bfa: Revised Fabric Assigned Address(FAA) feature implementation.
      [SCSI] bfa: Flash controller IOC pll init fixes.
      [SCSI] bfa: Serialize the IOC hw semaphore unlock logic.
      [SCSI] bfa: Modify ISR to process pending completions
      [SCSI] bfa: Add fc host issue lip support
      [SCSI] mpt2sas: remove extraneous sas_log_info messages
      [SCSI] libfc: fcoe_transport_create fails in single-CPU environment
      [SCSI] fcoe: reduce contention for fcoe_rx_list lock [v2]
      ...

commit 9ffc93f203c18a70623f21950f1dd473c9ec48cd
Author: David Howells <dhowells@redhat.com>
Date:   Wed Mar 28 18:30:03 2012 +0100

    Remove all #inclusions of asm/system.h
    
    Remove all #inclusions of asm/system.h preparatory to splitting and killing
    it.  Performed with the following command:
    
    perl -p -i -e 's!^#\s*include\s*<asm/system[.]h>.*\n!!' `grep -Irl '^#\s*include\s*<asm/system[.]h>' *`
    
    Signed-off-by: David Howells <dhowells@redhat.com>

diff --git a/drivers/scsi/atp870u.c b/drivers/scsi/atp870u.c
index 7e6eca4a125e..f29d5121d5ed 100644
--- a/drivers/scsi/atp870u.c
+++ b/drivers/scsi/atp870u.c
@@ -30,7 +30,6 @@
 #include <linux/blkdev.h>
 #include <linux/dma-mapping.h>
 #include <linux/slab.h>
-#include <asm/system.h>
 #include <asm/io.h>
 
 #include <scsi/scsi.h>

commit 7d7311c44567cd2001ca318e4de64b753d9d35f8
Author: Sergei Shtylyov <sshtylyov@ru.mvista.com>
Date:   Wed Mar 14 22:04:30 2012 +0300

    [SCSI] atp870u, mpt2sas, qla4xxx use pci_dev->revision
    
    commit 44c10138fd4bbc4b6d6bff0873c24902f2a9da65 (PCI: Change all
    drivers to use pci_device->revision) converted all drivers to use
    pci_dev->revision.  Convert these three drivers which got missed.
    
    Signed-off-by: Sergei Shtylyov <sshtylyov@ru.mvista.com>
    Signed-off-by: James Bottomley <JBottomley@Parallels.com>

diff --git a/drivers/scsi/atp870u.c b/drivers/scsi/atp870u.c
index 7e6eca4a125e..a9561fb143f3 100644
--- a/drivers/scsi/atp870u.c
+++ b/drivers/scsi/atp870u.c
@@ -2583,7 +2583,7 @@ static int atp870u_probe(struct pci_dev *pdev, const struct pci_device_id *ent)
 	 * this than via the PCI device table
 	 */
 	if (ent->device == PCI_DEVICE_ID_ARTOP_AEC7610) {
-		error = pci_read_config_byte(pdev, PCI_CLASS_REVISION, &atpdev->chip_ver);
+		atpdev->chip_ver = pdev->revision;
 		if (atpdev->chip_ver < 2)
 			goto err_eio;
 	}
@@ -2602,7 +2602,7 @@ static int atp870u_probe(struct pci_dev *pdev, const struct pci_device_id *ent)
 	base_io &= 0xfffffff8;
 
 	if ((ent->device == ATP880_DEVID1)||(ent->device == ATP880_DEVID2)) {
-		error = pci_read_config_byte(pdev, PCI_CLASS_REVISION, &atpdev->chip_ver);
+		atpdev->chip_ver = pdev->revision;
 		pci_write_config_byte(pdev, PCI_LATENCY_TIMER, 0x80);//JCC082803
 
 		host_id = inb(base_io + 0x39);

commit 25985edcedea6396277003854657b5f3cb31a628
Author: Lucas De Marchi <lucas.demarchi@profusion.mobi>
Date:   Wed Mar 30 22:57:33 2011 -0300

    Fix common misspellings
    
    Fixes generated by 'codespell' and manually reviewed.
    
    Signed-off-by: Lucas De Marchi <lucas.demarchi@profusion.mobi>

diff --git a/drivers/scsi/atp870u.c b/drivers/scsi/atp870u.c
index 76029d570beb..7e6eca4a125e 100644
--- a/drivers/scsi/atp870u.c
+++ b/drivers/scsi/atp870u.c
@@ -1228,7 +1228,7 @@ static void tscam(struct Scsi_Host *host)
 	printk(" \n%x %x %x %s\n ",assignid_map,mbuf[0],mbuf[1],&mbuf[2]); */
 	i = 15;
 	j = mbuf[0];
-	if ((j & 0x20) != 0) {	/* bit5=1:ID upto 7      */
+	if ((j & 0x20) != 0) {	/* bit5=1:ID up to 7      */
 		i = 7;
 	}
 	if ((j & 0x06) == 0) {	/* IDvalid?             */

commit f281233d3eba15fb225d21ae2e228fd4553d824a
Author: Jeff Garzik <jeff@garzik.org>
Date:   Tue Nov 16 02:10:29 2010 -0500

    SCSI host lock push-down
    
    Move the mid-layer's ->queuecommand() invocation from being locked
    with the host lock to being unlocked to facilitate speeding up the
    critical path for drivers who don't need this lock taken anyway.
    
    The patch below presents a simple SCSI host lock push-down as an
    equivalent transformation.  No locking or other behavior should change
    with this patch.  All existing bugs and locking orders are preserved.
    
    Additionally, add one parameter to queuecommand,
            struct Scsi_Host *
    and remove one parameter from queuecommand,
            void (*done)(struct scsi_cmnd *)
    
    Scsi_Host* is a convenient pointer that most host drivers need anyway,
    and 'done' is redundant to struct scsi_cmnd->scsi_done.
    
    Minimal code disturbance was attempted with this change.  Most drivers
    needed only two one-line modifications for their host lock push-down.
    
    Signed-off-by: Jeff Garzik <jgarzik@redhat.com>
    Acked-by: James Bottomley <James.Bottomley@suse.de>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/scsi/atp870u.c b/drivers/scsi/atp870u.c
index ab5bdda6903e..76029d570beb 100644
--- a/drivers/scsi/atp870u.c
+++ b/drivers/scsi/atp870u.c
@@ -605,7 +605,7 @@ static irqreturn_t atp870u_intr_handle(int irq, void *dev_id)
  *
  *	Queue a command to the ATP queue. Called with the host lock held.
  */
-static int atp870u_queuecommand(struct scsi_cmnd * req_p, 
+static int atp870u_queuecommand_lck(struct scsi_cmnd *req_p,
 			 void (*done) (struct scsi_cmnd *))
 {
 	unsigned char c;
@@ -694,6 +694,8 @@ static int atp870u_queuecommand(struct scsi_cmnd * req_p,
 	return 0;
 }
 
+static DEF_SCSI_QCMD(atp870u_queuecommand)
+
 /**
  *	send_s870	-	send a command to the controller
  *	@host: host

commit 5a0e3ad6af8660be21ca98a971cd00f331318c05
Author: Tejun Heo <tj@kernel.org>
Date:   Wed Mar 24 17:04:11 2010 +0900

    include cleanup: Update gfp.h and slab.h includes to prepare for breaking implicit slab.h inclusion from percpu.h
    
    percpu.h is included by sched.h and module.h and thus ends up being
    included when building most .c files.  percpu.h includes slab.h which
    in turn includes gfp.h making everything defined by the two files
    universally available and complicating inclusion dependencies.
    
    percpu.h -> slab.h dependency is about to be removed.  Prepare for
    this change by updating users of gfp and slab facilities include those
    headers directly instead of assuming availability.  As this conversion
    needs to touch large number of source files, the following script is
    used as the basis of conversion.
    
      http://userweb.kernel.org/~tj/misc/slabh-sweep.py
    
    The script does the followings.
    
    * Scan files for gfp and slab usages and update includes such that
      only the necessary includes are there.  ie. if only gfp is used,
      gfp.h, if slab is used, slab.h.
    
    * When the script inserts a new include, it looks at the include
      blocks and try to put the new include such that its order conforms
      to its surrounding.  It's put in the include block which contains
      core kernel includes, in the same order that the rest are ordered -
      alphabetical, Christmas tree, rev-Xmas-tree or at the end if there
      doesn't seem to be any matching order.
    
    * If the script can't find a place to put a new include (mostly
      because the file doesn't have fitting include block), it prints out
      an error message indicating which .h file needs to be added to the
      file.
    
    The conversion was done in the following steps.
    
    1. The initial automatic conversion of all .c files updated slightly
       over 4000 files, deleting around 700 includes and adding ~480 gfp.h
       and ~3000 slab.h inclusions.  The script emitted errors for ~400
       files.
    
    2. Each error was manually checked.  Some didn't need the inclusion,
       some needed manual addition while adding it to implementation .h or
       embedding .c file was more appropriate for others.  This step added
       inclusions to around 150 files.
    
    3. The script was run again and the output was compared to the edits
       from #2 to make sure no file was left behind.
    
    4. Several build tests were done and a couple of problems were fixed.
       e.g. lib/decompress_*.c used malloc/free() wrappers around slab
       APIs requiring slab.h to be added manually.
    
    5. The script was run on all .h files but without automatically
       editing them as sprinkling gfp.h and slab.h inclusions around .h
       files could easily lead to inclusion dependency hell.  Most gfp.h
       inclusion directives were ignored as stuff from gfp.h was usually
       wildly available and often used in preprocessor macros.  Each
       slab.h inclusion directive was examined and added manually as
       necessary.
    
    6. percpu.h was updated not to include slab.h.
    
    7. Build test were done on the following configurations and failures
       were fixed.  CONFIG_GCOV_KERNEL was turned off for all tests (as my
       distributed build env didn't work with gcov compiles) and a few
       more options had to be turned off depending on archs to make things
       build (like ipr on powerpc/64 which failed due to missing writeq).
    
       * x86 and x86_64 UP and SMP allmodconfig and a custom test config.
       * powerpc and powerpc64 SMP allmodconfig
       * sparc and sparc64 SMP allmodconfig
       * ia64 SMP allmodconfig
       * s390 SMP allmodconfig
       * alpha SMP allmodconfig
       * um on x86_64 SMP allmodconfig
    
    8. percpu.h modifications were reverted so that it could be applied as
       a separate patch and serve as bisection point.
    
    Given the fact that I had only a couple of failures from tests on step
    6, I'm fairly confident about the coverage of this conversion patch.
    If there is a breakage, it's likely to be something in one of the arch
    headers which should be easily discoverable easily on most builds of
    the specific arch.
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Guess-its-ok-by: Christoph Lameter <cl@linux-foundation.org>
    Cc: Ingo Molnar <mingo@redhat.com>
    Cc: Lee Schermerhorn <Lee.Schermerhorn@hp.com>

diff --git a/drivers/scsi/atp870u.c b/drivers/scsi/atp870u.c
index b137e561f5bc..ab5bdda6903e 100644
--- a/drivers/scsi/atp870u.c
+++ b/drivers/scsi/atp870u.c
@@ -29,6 +29,7 @@
 #include <linux/pci.h>
 #include <linux/blkdev.h>
 #include <linux/dma-mapping.h>
+#include <linux/slab.h>
 #include <asm/system.h>
 #include <asm/io.h>
 

commit 284901a90a9e0b812ca3f5f852cbbfb60d10249d
Author: Yang Hongyang <yanghy@cn.fujitsu.com>
Date:   Mon Apr 6 19:01:15 2009 -0700

    dma-mapping: replace all DMA_32BIT_MASK macro with DMA_BIT_MASK(32)
    
    Replace all DMA_32BIT_MASK macro with DMA_BIT_MASK(32)
    
    Signed-off-by: Yang Hongyang<yanghy@cn.fujitsu.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/scsi/atp870u.c b/drivers/scsi/atp870u.c
index 20ca0a6374b5..b137e561f5bc 100644
--- a/drivers/scsi/atp870u.c
+++ b/drivers/scsi/atp870u.c
@@ -2568,7 +2568,7 @@ static int atp870u_probe(struct pci_dev *pdev, const struct pci_device_id *ent)
 	if (pci_enable_device(pdev))
 		goto err_eio;
 
-        if (!pci_set_dma_mask(pdev, DMA_32BIT_MASK)) {
+        if (!pci_set_dma_mask(pdev, DMA_BIT_MASK(32))) {
                 printk(KERN_INFO "atp870u: use 32bit DMA mask.\n");
         } else {
                 printk(KERN_ERR "atp870u: DMA mask required but not available.\n");

commit fa195afe4ad3f6d85a9b7cc236ae85c05ca8db03
Author: Alan Cox <alan@lxorguk.ukuu.org.uk>
Date:   Mon Oct 27 15:16:36 2008 +0000

    [SCSI] Clean up my email address and use a single standard address for everything
    
    Signed-off-by: Alan Cox <alan@redhat.com>
    Signed-off-by: James Bottomley <James.Bottomley@HansenPartnership.com>

diff --git a/drivers/scsi/atp870u.c b/drivers/scsi/atp870u.c
index 7d311541c76c..20ca0a6374b5 100644
--- a/drivers/scsi/atp870u.c
+++ b/drivers/scsi/atp870u.c
@@ -1,8 +1,8 @@
 /* 
  *  Copyright (C) 1997	Wu Ching Chen
  *  2.1.x update (C) 1998  Krzysztof G. Baranowski
- *  2.5.x update (C) 2002  Red Hat <alan@redhat.com>
- *  2.6.x update (C) 2004  Red Hat <alan@redhat.com>
+ *  2.5.x update (C) 2002  Red Hat
+ *  2.6.x update (C) 2004  Red Hat
  *
  * Marcelo Tosatti <marcelo@conectiva.com.br> : SMP fixes
  *

commit 9bcf091083065c751a4d90317b766370d2497ae9
Author: Harvey Harrison <harvey.harrison@gmail.com>
Date:   Thu May 22 15:45:07 2008 -0700

    scsi: fix integer as NULL pointer warning
    
    drivers/scsi/aha152x.c:3585:60: warning: Using plain integer as NULL pointer
    drivers/scsi/aha152x.c:3845:56: warning: Using plain integer as NULL pointer
    drivers/scsi/qla1280.c:2814:37: warning: Using plain integer as NULL pointer
    drivers/scsi/atp870u.c:750:47: warning: Using plain integer as NULL pointer
    drivers/scsi/3w-9xxx.c:1281:36: warning: Using plain integer as NULL pointer
    drivers/scsi/3w-9xxx.c:1293:36: warning: Using plain integer as NULL pointer
    drivers/scsi/3w-9xxx.c:1301:35: warning: Using plain integer as NULL pointer
    drivers/scsi/hptiop.c:447:10: warning: Using plain integer as NULL pointer
    drivers/scsi/hptiop.c:457:10: warning: Using plain integer as NULL pointer
    drivers/scsi/hptiop.c:479:24: warning: Using plain integer as NULL pointer
    drivers/scsi/hptiop.c:483:22: warning: Using plain integer as NULL pointer
    drivers/scsi/hptiop.c:1213:23: warning: Using plain integer as NULL pointer
    drivers/scsi/hptiop.c:1214:23: warning: Using plain integer as NULL pointer
    
    Signed-off-by: Harvey Harrison <harvey.harrison@gmail.com>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/scsi/atp870u.c b/drivers/scsi/atp870u.c
index db6de5e6afb3..7d311541c76c 100644
--- a/drivers/scsi/atp870u.c
+++ b/drivers/scsi/atp870u.c
@@ -747,7 +747,7 @@ static void send_s870(struct atp_unit *dev,unsigned char c)
 		dev->quhd[c] = 0;
 	}
 	workreq = dev->quereq[c][dev->quhd[c]];
-	if (dev->id[c][scmd_id(workreq)].curr_req == 0) {	
+	if (dev->id[c][scmd_id(workreq)].curr_req == NULL) {
 		dev->id[c][scmd_id(workreq)].curr_req = workreq;
 		dev->last_cmd[c] = scmd_id(workreq);
 		goto cmd_subp;

commit fe7ed98fd49a28287aca8b0ba8da8fb9ca35a055
Author: Boaz Harrosh <bharrosh@panasas.com>
Date:   Sun Sep 9 21:06:23 2007 +0300

    [SCSI] atp870u: convert to accessors and !use_sg cleanup
    
     - convert to accessors and !use_sg cleanup
     - Probably not ready for sg-chaining
    
    Signed-off-by: Boaz Harrosh <bharrosh@panasas.com>
    Acked-by: Christoph Hellwig <hch@infradead.org>
    Cc: jameshsu <jameshsu@acard.com>
    Signed-off-by: James Bottomley <James.Bottomley@HansenPartnership.com>

diff --git a/drivers/scsi/atp870u.c b/drivers/scsi/atp870u.c
index fec58cc47f1c..db6de5e6afb3 100644
--- a/drivers/scsi/atp870u.c
+++ b/drivers/scsi/atp870u.c
@@ -471,18 +471,8 @@ static irqreturn_t atp870u_intr_handle(int irq, void *dev_id)
 			/*
 			 *	Complete the command
 			 */
-			if (workreq->use_sg) {
-				pci_unmap_sg(dev->pdev,
-					(struct scatterlist *)workreq->request_buffer,
-					workreq->use_sg,
-					workreq->sc_data_direction);
-			} else if (workreq->request_bufflen &&
-					workreq->sc_data_direction != DMA_NONE) {
-				pci_unmap_single(dev->pdev,
-					workreq->SCp.dma_handle,
-					workreq->request_bufflen,
-					workreq->sc_data_direction);
-			}			
+			scsi_dma_unmap(workreq);
+
 			spin_lock_irqsave(dev->host->host_lock, flags);
 			(*workreq->scsi_done) (workreq);
 #ifdef ED_DBGP
@@ -624,7 +614,7 @@ static int atp870u_queuecommand(struct scsi_cmnd * req_p,
 
 	c = scmd_channel(req_p);
 	req_p->sense_buffer[0]=0;
-	req_p->resid = 0;
+	scsi_set_resid(req_p, 0);
 	if (scmd_channel(req_p) > 1) {
 		req_p->result = 0x00040000;
 		done(req_p);
@@ -722,7 +712,6 @@ static void send_s870(struct atp_unit *dev,unsigned char c)
 	unsigned short int tmpcip, w;
 	unsigned long l, bttl = 0;
 	unsigned int workport;
-	struct scatterlist *sgpnt;
 	unsigned long  sg_count;
 
 	if (dev->in_snd[c] != 0) {
@@ -793,6 +782,8 @@ static void send_s870(struct atp_unit *dev,unsigned char c)
 	}
 	printk("\n");
 #endif	
+	l = scsi_bufflen(workreq);
+
 	if (dev->dev_id == ATP885_DEVID) {
 		j = inb(dev->baseport + 0x29) & 0xfe;
 		outb(j, dev->baseport + 0x29);
@@ -800,12 +791,11 @@ static void send_s870(struct atp_unit *dev,unsigned char c)
 	}
 	
 	if (workreq->cmnd[0] == READ_CAPACITY) {
-		if (workreq->request_bufflen > 8) {
-			workreq->request_bufflen = 0x08;
-		}
+		if (l > 8)
+			l = 8;
 	}
 	if (workreq->cmnd[0] == 0x00) {
-		workreq->request_bufflen = 0;
+		l = 0;
 	}
 
 	tmport = workport + 0x1b;
@@ -852,40 +842,8 @@ static void send_s870(struct atp_unit *dev,unsigned char c)
 #ifdef ED_DBGP	
 	printk("dev->id[%d][%d].devsp = %2x\n",c,target_id,dev->id[c][target_id].devsp);
 #endif
-	/*
-	 *	Figure out the transfer size
-	 */
-	if (workreq->use_sg) {
-#ifdef ED_DBGP
-		printk("Using SGL\n");
-#endif		
-		l = 0;
-		
-		sgpnt = (struct scatterlist *) workreq->request_buffer;
-		sg_count = pci_map_sg(dev->pdev, sgpnt, workreq->use_sg,
-	   			workreq->sc_data_direction);		
-		
-		for (i = 0; i < workreq->use_sg; i++) {
-			if (sgpnt[i].length == 0 || workreq->use_sg > ATP870U_SCATTER) {
-				panic("Foooooooood fight!");
-			}
-			l += sgpnt[i].length;
-		}
-#ifdef ED_DBGP		
-		printk( "send_s870: workreq->use_sg %d, sg_count %d l %8ld\n", workreq->use_sg, sg_count, l);
-#endif
-	} else if(workreq->request_bufflen && workreq->sc_data_direction != PCI_DMA_NONE) {
-#ifdef ED_DBGP
-		printk("Not using SGL\n");
-#endif					
-		workreq->SCp.dma_handle = pci_map_single(dev->pdev, workreq->request_buffer,
-				workreq->request_bufflen,
-				workreq->sc_data_direction);		
-		l = workreq->request_bufflen;
-#ifdef ED_DBGP		
-		printk( "send_s870: workreq->use_sg %d, l %8ld\n", workreq->use_sg, l);
-#endif
-	} else l = 0;
+
+	sg_count = scsi_dma_map(workreq);
 	/*
 	 *	Write transfer size
 	 */
@@ -938,16 +896,16 @@ static void send_s870(struct atp_unit *dev,unsigned char c)
 	 *	a linear chain.
 	 */
 
-	if (workreq->use_sg) {
-		sgpnt = (struct scatterlist *) workreq->request_buffer;
+	if (l) {
+		struct scatterlist *sgpnt;
 		i = 0;
-		for (j = 0; j < workreq->use_sg; j++) {
-			bttl = sg_dma_address(&sgpnt[j]);
-			l=sg_dma_len(&sgpnt[j]);
+		scsi_for_each_sg(workreq, sgpnt, sg_count, j) {
+			bttl = sg_dma_address(sgpnt);
+			l=sg_dma_len(sgpnt);
 #ifdef ED_DBGP		
-		printk("1. bttl %x, l %x\n",bttl, l);
+			printk("1. bttl %x, l %x\n",bttl, l);
 #endif			
-		while (l > 0x10000) {
+			while (l > 0x10000) {
 				(((u16 *) (prd))[i + 3]) = 0x0000;
 				(((u16 *) (prd))[i + 2]) = 0x0000;
 				(((u32 *) (prd))[i >> 1]) = cpu_to_le32(bttl);
@@ -965,32 +923,6 @@ static void send_s870(struct atp_unit *dev,unsigned char c)
 		printk("prd %4x %4x %4x %4x\n",(((unsigned short int *)prd)[0]),(((unsigned short int *)prd)[1]),(((unsigned short int *)prd)[2]),(((unsigned short int *)prd)[3]));
 		printk("2. bttl %x, l %x\n",bttl, l);
 #endif			
-	} else {
-		/*
-		 *	For a linear request write a chain of blocks
-		 */        
-		bttl = workreq->SCp.dma_handle;
-		l = workreq->request_bufflen;
-		i = 0;
-#ifdef ED_DBGP		
-		printk("3. bttl %x, l %x\n",bttl, l);
-#endif			
-		while (l > 0x10000) {
-				(((u16 *) (prd))[i + 3]) = 0x0000;
-				(((u16 *) (prd))[i + 2]) = 0x0000;
-				(((u32 *) (prd))[i >> 1]) = cpu_to_le32(bttl);
-				l -= 0x10000;
-				bttl += 0x10000;
-				i += 0x04;
-			}
-			(((u16 *) (prd))[i + 3]) = cpu_to_le16(0x8000);
-			(((u16 *) (prd))[i + 2]) = cpu_to_le16(l);
-			(((u32 *) (prd))[i >> 1]) = cpu_to_le32(bttl);		
-#ifdef ED_DBGP		
-		printk("prd %4x %4x %4x %4x\n",(((unsigned short int *)prd)[0]),(((unsigned short int *)prd)[1]),(((unsigned short int *)prd)[2]),(((unsigned short int *)prd)[3]));
-		printk("4. bttl %x, l %x\n",bttl, l);
-#endif			
-		
 	}
 	tmpcip += 4;
 #ifdef ED_DBGP		

commit 7d12e780e003f93433d49ce78cfedf4b4c52adc5
Author: David Howells <dhowells@redhat.com>
Date:   Thu Oct 5 14:55:46 2006 +0100

    IRQ: Maintain regs pointer globally rather than passing to IRQ handlers
    
    Maintain a per-CPU global "struct pt_regs *" variable which can be used instead
    of passing regs around manually through all ~1800 interrupt handlers in the
    Linux kernel.
    
    The regs pointer is used in few places, but it potentially costs both stack
    space and code to pass it around.  On the FRV arch, removing the regs parameter
    from all the genirq function results in a 20% speed up of the IRQ exit path
    (ie: from leaving timer_interrupt() to leaving do_IRQ()).
    
    Where appropriate, an arch may override the generic storage facility and do
    something different with the variable.  On FRV, for instance, the address is
    maintained in GR28 at all times inside the kernel as part of general exception
    handling.
    
    Having looked over the code, it appears that the parameter may be handed down
    through up to twenty or so layers of functions.  Consider a USB character
    device attached to a USB hub, attached to a USB controller that posts its
    interrupts through a cascaded auxiliary interrupt controller.  A character
    device driver may want to pass regs to the sysrq handler through the input
    layer which adds another few layers of parameter passing.
    
    I've build this code with allyesconfig for x86_64 and i386.  I've runtested the
    main part of the code on FRV and i386, though I can't test most of the drivers.
    I've also done partial conversion for powerpc and MIPS - these at least compile
    with minimal configurations.
    
    This will affect all archs.  Mostly the changes should be relatively easy.
    Take do_IRQ(), store the regs pointer at the beginning, saving the old one:
    
            struct pt_regs *old_regs = set_irq_regs(regs);
    
    And put the old one back at the end:
    
            set_irq_regs(old_regs);
    
    Don't pass regs through to generic_handle_irq() or __do_IRQ().
    
    In timer_interrupt(), this sort of change will be necessary:
    
            -       update_process_times(user_mode(regs));
            -       profile_tick(CPU_PROFILING, regs);
            +       update_process_times(user_mode(get_irq_regs()));
            +       profile_tick(CPU_PROFILING);
    
    I'd like to move update_process_times()'s use of get_irq_regs() into itself,
    except that i386, alone of the archs, uses something other than user_mode().
    
    Some notes on the interrupt handling in the drivers:
    
     (*) input_dev() is now gone entirely.  The regs pointer is no longer stored in
         the input_dev struct.
    
     (*) finish_unlinks() in drivers/usb/host/ohci-q.c needs checking.  It does
         something different depending on whether it's been supplied with a regs
         pointer or not.
    
     (*) Various IRQ handler function pointers have been moved to type
         irq_handler_t.
    
    Signed-Off-By: David Howells <dhowells@redhat.com>
    (cherry picked from 1b16e7ac850969f38b375e511e3fa2f474a33867 commit)

diff --git a/drivers/scsi/atp870u.c b/drivers/scsi/atp870u.c
index 0ec41f34f462..fec58cc47f1c 100644
--- a/drivers/scsi/atp870u.c
+++ b/drivers/scsi/atp870u.c
@@ -44,7 +44,7 @@ static void send_s870(struct atp_unit *dev,unsigned char c);
 static void is885(struct atp_unit *dev, unsigned int wkport,unsigned char c);
 static void tscam_885(void);
 
-static irqreturn_t atp870u_intr_handle(int irq, void *dev_id, struct pt_regs *regs)
+static irqreturn_t atp870u_intr_handle(int irq, void *dev_id)
 {
 	unsigned long flags;
 	unsigned short int tmpcip, id;

commit c4e00fac42f268ed0a547cdd1d12bb8399864040
Merge: 29454dde27d8 d6b0c5372375
Author: James Bottomley <jejb@mulgrave.il.steeleye.com>
Date:   Mon Jul 3 09:41:12 2006 -0500

    Merge ../scsi-misc-2.6
    
    Conflicts:
    
            drivers/scsi/nsp32.c
            drivers/scsi/pcmcia/nsp_cs.c
    
    Removal of randomness flag conflicts with SA_ -> IRQF_ global
    replacement.
    
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>

commit 1d6f359a2e06296418481239f8054a878f36e819
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Sat Jul 1 19:29:42 2006 -0700

    [PATCH] irq-flags: scsi: Use the new IRQF_ constants
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: Ingo Molnar <mingo@elte.hu>
    Cc: "David S. Miller" <davem@davemloft.net>
    Cc: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Cc: James Bottomley <James.Bottomley@steeleye.com>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/drivers/scsi/atp870u.c b/drivers/scsi/atp870u.c
index 3ee4d4d3f445..412f8301b757 100644
--- a/drivers/scsi/atp870u.c
+++ b/drivers/scsi/atp870u.c
@@ -2751,7 +2751,7 @@ static int atp870u_probe(struct pci_dev *pdev, const struct pci_device_id *ent)
 			goto unregister;
 		}
 
-		if (request_irq(pdev->irq, atp870u_intr_handle, SA_SHIRQ, "atp880i", shpnt)) {
+		if (request_irq(pdev->irq, atp870u_intr_handle, IRQF_SHARED, "atp880i", shpnt)) {
  			printk(KERN_ERR "Unable to allocate IRQ%d for Acard controller.\n", pdev->irq);
 			goto free_tables;
 		}
@@ -2822,7 +2822,7 @@ static int atp870u_probe(struct pci_dev *pdev, const struct pci_device_id *ent)
 #ifdef ED_DBGP		
 	printk("request_irq() shpnt %p hostdata %p\n", shpnt, p);
 #endif	        
-		if (request_irq(pdev->irq, atp870u_intr_handle, SA_SHIRQ, "atp870u", shpnt)) {
+		if (request_irq(pdev->irq, atp870u_intr_handle, IRQF_SHARED, "atp870u", shpnt)) {
 				printk(KERN_ERR "Unable to allocate IRQ for Acard controller.\n");
 			goto free_tables;
 		}
@@ -3004,7 +3004,7 @@ static int atp870u_probe(struct pci_dev *pdev, const struct pci_device_id *ent)
 		if (atp870u_init_tables(shpnt) < 0)
 			goto unregister;
 
-		if (request_irq(pdev->irq, atp870u_intr_handle, SA_SHIRQ, "atp870i", shpnt)) {
+		if (request_irq(pdev->irq, atp870u_intr_handle, IRQF_SHARED, "atp870i", shpnt)) {
 			printk(KERN_ERR "Unable to allocate IRQ%d for Acard controller.\n", pdev->irq);
 			goto free_tables;
 		}

commit dc6a78f1af10d28fb8c395034ae1e099b85c05b0
Author: Randy Dunlap <rdunlap@xenotime.net>
Date:   Tue Jun 27 22:01:28 2006 -0700

    [SCSI] atp870u: reduce huge stack usage
    
    The atp870u driver is the largest stack eater reported by checkstack
    (on x86_864, allmodconfig).  This converts the offending function
    to kmalloc+kfree struct atp_unit instead of allocating it on the stack.
    Was:
    0x0000164c atp870u_probe [atp870u]:                     3176
    Now:
    0x0000164c atp870u_probe [atp870u]:                     408
    
    Signed-off-by: Randy Dunlap <rdunlap@xenotime.net>
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>

diff --git a/drivers/scsi/atp870u.c b/drivers/scsi/atp870u.c
index 3ee4d4d3f445..69e6e9821c9e 100644
--- a/drivers/scsi/atp870u.c
+++ b/drivers/scsi/atp870u.c
@@ -2625,29 +2625,32 @@ static int atp870u_probe(struct pci_dev *pdev, const struct pci_device_id *ent)
 	unsigned int base_io, tmport, error,n;
 	unsigned char host_id;
 	struct Scsi_Host *shpnt = NULL;
-	struct atp_unit atp_dev, *p;
+	struct atp_unit *atpdev, *p;
 	unsigned char setupdata[2][16];
 	int count = 0;
-	
+
+	atpdev = kzalloc(sizeof(*atpdev), GFP_KERNEL);
+	if (!atpdev)
+		return -ENOMEM;
+
 	if (pci_enable_device(pdev))
-		return -EIO;
+		goto err_eio;
 
         if (!pci_set_dma_mask(pdev, DMA_32BIT_MASK)) {
                 printk(KERN_INFO "atp870u: use 32bit DMA mask.\n");
         } else {
                 printk(KERN_ERR "atp870u: DMA mask required but not available.\n");
-                return -EIO;
+		goto err_eio;
         }
 
-	memset(&atp_dev, 0, sizeof atp_dev);
 	/*
 	 * It's probably easier to weed out some revisions like
 	 * this than via the PCI device table
 	 */
 	if (ent->device == PCI_DEVICE_ID_ARTOP_AEC7610) {
-		error = pci_read_config_byte(pdev, PCI_CLASS_REVISION, &atp_dev.chip_ver);
-		if (atp_dev.chip_ver < 2)
-			return -EIO;
+		error = pci_read_config_byte(pdev, PCI_CLASS_REVISION, &atpdev->chip_ver);
+		if (atpdev->chip_ver < 2)
+			goto err_eio;
 	}
 
 	switch (ent->device) {
@@ -2656,15 +2659,15 @@ static int atp870u_probe(struct pci_dev *pdev, const struct pci_device_id *ent)
 	case ATP880_DEVID1:	
 	case ATP880_DEVID2:	
 	case ATP885_DEVID:	
-		atp_dev.chip_ver = 0x04;
+		atpdev->chip_ver = 0x04;
 	default:
 		break;
 	}
 	base_io = pci_resource_start(pdev, 0);
 	base_io &= 0xfffffff8;
-	
+
 	if ((ent->device == ATP880_DEVID1)||(ent->device == ATP880_DEVID2)) {
-		error = pci_read_config_byte(pdev, PCI_CLASS_REVISION, &atp_dev.chip_ver);
+		error = pci_read_config_byte(pdev, PCI_CLASS_REVISION, &atpdev->chip_ver);
 		pci_write_config_byte(pdev, PCI_LATENCY_TIMER, 0x80);//JCC082803
 
 		host_id = inb(base_io + 0x39);
@@ -2672,17 +2675,17 @@ static int atp870u_probe(struct pci_dev *pdev, const struct pci_device_id *ent)
 
 		printk(KERN_INFO "   ACARD AEC-67160 PCI Ultra3 LVD Host Adapter: %d"
 			"    IO:%x, IRQ:%d.\n", count, base_io, pdev->irq);
-		atp_dev.ioport[0] = base_io + 0x40;
-		atp_dev.pciport[0] = base_io + 0x28;
-		atp_dev.dev_id = ent->device;
-		atp_dev.host_id[0] = host_id;
+		atpdev->ioport[0] = base_io + 0x40;
+		atpdev->pciport[0] = base_io + 0x28;
+		atpdev->dev_id = ent->device;
+		atpdev->host_id[0] = host_id;
 
 		tmport = base_io + 0x22;
-		atp_dev.scam_on = inb(tmport);
+		atpdev->scam_on = inb(tmport);
 		tmport += 0x13;
-		atp_dev.global_map[0] = inb(tmport);
+		atpdev->global_map[0] = inb(tmport);
 		tmport += 0x07;
-		atp_dev.ultra_map[0] = inw(tmport);
+		atpdev->ultra_map[0] = inw(tmport);
 
 		n = 0x3f09;
 next_fblk_880:
@@ -2695,57 +2698,57 @@ static int atp870u_probe(struct pci_dev *pdev, const struct pci_device_id *ent)
 		if (inb(base_io + 0x30) == 0xff)
 			goto flash_ok_880;
 
-		atp_dev.sp[0][m++] = inb(base_io + 0x30);
-		atp_dev.sp[0][m++] = inb(base_io + 0x31);
-		atp_dev.sp[0][m++] = inb(base_io + 0x32);
-		atp_dev.sp[0][m++] = inb(base_io + 0x33);
+		atpdev->sp[0][m++] = inb(base_io + 0x30);
+		atpdev->sp[0][m++] = inb(base_io + 0x31);
+		atpdev->sp[0][m++] = inb(base_io + 0x32);
+		atpdev->sp[0][m++] = inb(base_io + 0x33);
 		outw(n, base_io + 0x34);
 		n += 0x0002;
-		atp_dev.sp[0][m++] = inb(base_io + 0x30);
-		atp_dev.sp[0][m++] = inb(base_io + 0x31);
-		atp_dev.sp[0][m++] = inb(base_io + 0x32);
-		atp_dev.sp[0][m++] = inb(base_io + 0x33);
+		atpdev->sp[0][m++] = inb(base_io + 0x30);
+		atpdev->sp[0][m++] = inb(base_io + 0x31);
+		atpdev->sp[0][m++] = inb(base_io + 0x32);
+		atpdev->sp[0][m++] = inb(base_io + 0x33);
 		outw(n, base_io + 0x34);
 		n += 0x0002;
-		atp_dev.sp[0][m++] = inb(base_io + 0x30);
-		atp_dev.sp[0][m++] = inb(base_io + 0x31);
-		atp_dev.sp[0][m++] = inb(base_io + 0x32);
-		atp_dev.sp[0][m++] = inb(base_io + 0x33);
+		atpdev->sp[0][m++] = inb(base_io + 0x30);
+		atpdev->sp[0][m++] = inb(base_io + 0x31);
+		atpdev->sp[0][m++] = inb(base_io + 0x32);
+		atpdev->sp[0][m++] = inb(base_io + 0x33);
 		outw(n, base_io + 0x34);
 		n += 0x0002;
-		atp_dev.sp[0][m++] = inb(base_io + 0x30);
-		atp_dev.sp[0][m++] = inb(base_io + 0x31);
-		atp_dev.sp[0][m++] = inb(base_io + 0x32);
-		atp_dev.sp[0][m++] = inb(base_io + 0x33);
+		atpdev->sp[0][m++] = inb(base_io + 0x30);
+		atpdev->sp[0][m++] = inb(base_io + 0x31);
+		atpdev->sp[0][m++] = inb(base_io + 0x32);
+		atpdev->sp[0][m++] = inb(base_io + 0x33);
 		n += 0x0018;
 		goto next_fblk_880;
 flash_ok_880:
 		outw(0, base_io + 0x34);
-		atp_dev.ultra_map[0] = 0;
-		atp_dev.async[0] = 0;
+		atpdev->ultra_map[0] = 0;
+		atpdev->async[0] = 0;
 		for (k = 0; k < 16; k++) {
 			n = 1;
 			n = n << k;
-			if (atp_dev.sp[0][k] > 1) {
-				atp_dev.ultra_map[0] |= n;
+			if (atpdev->sp[0][k] > 1) {
+				atpdev->ultra_map[0] |= n;
 			} else {
-				if (atp_dev.sp[0][k] == 0)
-					atp_dev.async[0] |= n;
+				if (atpdev->sp[0][k] == 0)
+					atpdev->async[0] |= n;
  			}
 	 	}
-		atp_dev.async[0] = ~(atp_dev.async[0]);
-		outb(atp_dev.global_map[0], base_io + 0x35);
+		atpdev->async[0] = ~(atpdev->async[0]);
+		outb(atpdev->global_map[0], base_io + 0x35);
  
 		shpnt = scsi_host_alloc(&atp870u_template, sizeof(struct atp_unit));
 		if (!shpnt)
-			return -ENOMEM;
+			goto err_nomem;
 
 		p = (struct atp_unit *)&shpnt->hostdata;
 
-		atp_dev.host = shpnt;
-		atp_dev.pdev = pdev;
+		atpdev->host = shpnt;
+		atpdev->pdev = pdev;
 		pci_set_drvdata(pdev, p);
-		memcpy(p, &atp_dev, sizeof atp_dev);
+		memcpy(p, atpdev, sizeof(*atpdev));
 		if (atp870u_init_tables(shpnt) < 0) {
 			printk(KERN_ERR "Unable to allocate tables for Acard controller\n");
 			goto unregister;
@@ -2798,24 +2801,24 @@ static int atp870u_probe(struct pci_dev *pdev, const struct pci_device_id *ent)
 			printk(KERN_INFO "   ACARD AEC-67162 PCI Ultra3 LVD Host Adapter:  IO:%x, IRQ:%d.\n"
 			       , base_io, pdev->irq);
         	
-		atp_dev.pdev = pdev;	
-		atp_dev.dev_id  = ent->device;
-		atp_dev.baseport = base_io;
-		atp_dev.ioport[0] = base_io + 0x80;
-		atp_dev.ioport[1] = base_io + 0xc0;
-		atp_dev.pciport[0] = base_io + 0x40;
-		atp_dev.pciport[1] = base_io + 0x50;
+		atpdev->pdev = pdev;
+		atpdev->dev_id  = ent->device;
+		atpdev->baseport = base_io;
+		atpdev->ioport[0] = base_io + 0x80;
+		atpdev->ioport[1] = base_io + 0xc0;
+		atpdev->pciport[0] = base_io + 0x40;
+		atpdev->pciport[1] = base_io + 0x50;
 				
 		shpnt = scsi_host_alloc(&atp870u_template, sizeof(struct atp_unit));
 		if (!shpnt)
-			return -ENOMEM;
+			goto err_nomem;
         	
 		p = (struct atp_unit *)&shpnt->hostdata;
         	
-		atp_dev.host = shpnt;
-		atp_dev.pdev = pdev;
+		atpdev->host = shpnt;
+		atpdev->pdev = pdev;
 		pci_set_drvdata(pdev, p);
-		memcpy(p, &atp_dev, sizeof(struct atp_unit));
+		memcpy(p, atpdev, sizeof(struct atp_unit));
 		if (atp870u_init_tables(shpnt) < 0)
 			goto unregister;
 			
@@ -2974,33 +2977,33 @@ static int atp870u_probe(struct pci_dev *pdev, const struct pci_device_id *ent)
 		printk(KERN_INFO "   ACARD AEC-671X PCI Ultra/W SCSI-2/3 Host Adapter: %d "
 			"IO:%x, IRQ:%d.\n", count, base_io, pdev->irq);
 
-		atp_dev.ioport[0] = base_io;
-		atp_dev.pciport[0] = base_io + 0x20;
-		atp_dev.dev_id = ent->device;
+		atpdev->ioport[0] = base_io;
+		atpdev->pciport[0] = base_io + 0x20;
+		atpdev->dev_id = ent->device;
 		host_id &= 0x07;
-		atp_dev.host_id[0] = host_id;
+		atpdev->host_id[0] = host_id;
 		tmport = base_io + 0x22;
-		atp_dev.scam_on = inb(tmport);
+		atpdev->scam_on = inb(tmport);
 		tmport += 0x0b;
-		atp_dev.global_map[0] = inb(tmport++);
-		atp_dev.ultra_map[0] = inw(tmport);
+		atpdev->global_map[0] = inb(tmport++);
+		atpdev->ultra_map[0] = inw(tmport);
 
-		if (atp_dev.ultra_map[0] == 0) {
-			atp_dev.scam_on = 0x00;
-			atp_dev.global_map[0] = 0x20;
-			atp_dev.ultra_map[0] = 0xffff;
+		if (atpdev->ultra_map[0] == 0) {
+			atpdev->scam_on = 0x00;
+			atpdev->global_map[0] = 0x20;
+			atpdev->ultra_map[0] = 0xffff;
 		}
 
 		shpnt = scsi_host_alloc(&atp870u_template, sizeof(struct atp_unit));
 		if (!shpnt)
-			return -ENOMEM;
+			goto err_nomem;
 
 		p = (struct atp_unit *)&shpnt->hostdata;
 		
-		atp_dev.host = shpnt;
-		atp_dev.pdev = pdev;
+		atpdev->host = shpnt;
+		atpdev->pdev = pdev;
 		pci_set_drvdata(pdev, p);
-		memcpy(p, &atp_dev, sizeof atp_dev);
+		memcpy(p, atpdev, sizeof(*atpdev));
 		if (atp870u_init_tables(shpnt) < 0)
 			goto unregister;
 
@@ -3010,7 +3013,7 @@ static int atp870u_probe(struct pci_dev *pdev, const struct pci_device_id *ent)
 		}
 
 		spin_lock_irqsave(shpnt->host_lock, flags);
-		if (atp_dev.chip_ver > 0x07) {	/* check if atp876 chip then enable terminator */
+		if (atpdev->chip_ver > 0x07) {	/* check if atp876 chip then enable terminator */
 			tmport = base_io + 0x3e;
 			outb(0x00, tmport);
 		}
@@ -3044,7 +3047,7 @@ static int atp870u_probe(struct pci_dev *pdev, const struct pci_device_id *ent)
 		outb((inb(tmport) & 0xef), tmport);
 		tmport++;
 		outb((inb(tmport) | 0x20), tmport);
-		if (atp_dev.chip_ver == 4)
+		if (atpdev->chip_ver == 4)
 			shpnt->max_id = 16;
 		else		
 			shpnt->max_id = 8;
@@ -3093,6 +3096,12 @@ static int atp870u_probe(struct pci_dev *pdev, const struct pci_device_id *ent)
 	printk("atp870u_prob:unregister\n");
 	scsi_host_put(shpnt);
 	return -1;		
+err_eio:
+	kfree(atpdev);
+	return -EIO;
+err_nomem:
+	kfree(atpdev);
+	return -ENOMEM;
 }
 
 /* The abort command does not leave the device in a clean state where

commit 5d5ff44fe6775ccb922fd1f7d478b2ba9ca95068
Author: Christoph Hellwig <hch@lst.de>
Date:   Sat Jun 3 13:21:13 2006 +0200

    [SCSI] fix up request buffer reference in various scsi drivers
    
    Various scsi drivers use scsi_cmnd.buffer and scsi_cmnd.bufflen in their
    queuecommand functions.  Those fields are internal storage for the
    midlayer only and are used to restore the original payload after
    request_buffer and request_bufflen have been overwritten for EH.  Using
    the buffer and bufflen fields means they do very broken things in error
    handling.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>

diff --git a/drivers/scsi/atp870u.c b/drivers/scsi/atp870u.c
index 58d7e34807aa..3ee4d4d3f445 100644
--- a/drivers/scsi/atp870u.c
+++ b/drivers/scsi/atp870u.c
@@ -473,7 +473,7 @@ static irqreturn_t atp870u_intr_handle(int irq, void *dev_id, struct pt_regs *re
 			 */
 			if (workreq->use_sg) {
 				pci_unmap_sg(dev->pdev,
-					(struct scatterlist *)workreq->buffer,
+					(struct scatterlist *)workreq->request_buffer,
 					workreq->use_sg,
 					workreq->sc_data_direction);
 			} else if (workreq->request_bufflen &&

commit 2b89dad0c7e3b03d45d9674ee9a7b49670df098e
Author: Hannes Reinecke <hare@suse.de>
Date:   Tue May 23 10:29:28 2006 +0200

    [SCSI] audit drivers for incorrect max_id use
    
    max_id now means the maximum number of ids on the bus, which means it
    is one greater than the largest possible id number.
    
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>

diff --git a/drivers/scsi/atp870u.c b/drivers/scsi/atp870u.c
index a198d86667e9..58d7e34807aa 100644
--- a/drivers/scsi/atp870u.c
+++ b/drivers/scsi/atp870u.c
@@ -3047,7 +3047,7 @@ static int atp870u_probe(struct pci_dev *pdev, const struct pci_device_id *ent)
 		if (atp_dev.chip_ver == 4)
 			shpnt->max_id = 16;
 		else		
-			shpnt->max_id = 7;
+			shpnt->max_id = 8;
 		shpnt->this_id = host_id;
 		shpnt->unique_id = base_io;
 		shpnt->io_port = base_io;

commit 910638ae7ed4be27d6af55f6c9b5bf54b838e78b
Author: Matthias Gehre <M.Gehre@gmx.de>
Date:   Tue Mar 28 01:56:48 2006 -0800

    [PATCH] Replace 0xff.. with correct DMA_xBIT_MASK
    
    Replace all occurences of 0xff..  in calls to function pci_set_dma_mask()
    and pci_set_consistant_dma_mask() with the corresponding DMA_xBIT_MASK from
    linux/dma-mapping.h.
    
    Signed-off-by: Matthias Gehre <M.Gehre@gmx.de>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/drivers/scsi/atp870u.c b/drivers/scsi/atp870u.c
index 5227a779c05c..a198d86667e9 100644
--- a/drivers/scsi/atp870u.c
+++ b/drivers/scsi/atp870u.c
@@ -28,6 +28,7 @@
 #include <linux/spinlock.h>
 #include <linux/pci.h>
 #include <linux/blkdev.h>
+#include <linux/dma-mapping.h>
 #include <asm/system.h>
 #include <asm/io.h>
 
@@ -2631,7 +2632,7 @@ static int atp870u_probe(struct pci_dev *pdev, const struct pci_device_id *ent)
 	if (pci_enable_device(pdev))
 		return -EIO;
 
-        if (!pci_set_dma_mask(pdev, 0xFFFFFFFFUL)) {
+        if (!pci_set_dma_mask(pdev, DMA_32BIT_MASK)) {
                 printk(KERN_INFO "atp870u: use 32bit DMA mask.\n");
         } else {
                 printk(KERN_ERR "atp870u: DMA mask required but not available.\n");

commit 422c0d61d591cbfb70f029e13505fb437e169d68
Author: Jeff Garzik <jgarzik@pobox.com>
Date:   Mon Oct 24 18:05:09 2005 -0400

    [SCSI] use scmd_id(), scmd_channel() throughout code
    
    Wrap a highly common idiom.  Makes the code easier to read, helps pave
    the way for sdev->{id,channel} removal, and adds a token that can easily
    by grepped-for in the future.
    
    There are a couple sdev_id() and scmd_printk() updates thrown in as well.
    
    Rejections fixed up and
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>

diff --git a/drivers/scsi/atp870u.c b/drivers/scsi/atp870u.c
index b150bd8e254a..5227a779c05c 100644
--- a/drivers/scsi/atp870u.c
+++ b/drivers/scsi/atp870u.c
@@ -621,10 +621,10 @@ static int atp870u_queuecommand(struct scsi_cmnd * req_p,
 	struct atp_unit *dev;
 	struct Scsi_Host *host;
 
-	c = req_p->device->channel;	
+	c = scmd_channel(req_p);
 	req_p->sense_buffer[0]=0;
 	req_p->resid = 0;
-	if (req_p->device->channel > 1) {
+	if (scmd_channel(req_p) > 1) {
 		req_p->result = 0x00040000;
 		done(req_p);
 #ifdef ED_DBGP		
@@ -639,7 +639,7 @@ static int atp870u_queuecommand(struct scsi_cmnd * req_p,
 
 		
 	m = 1;
-	m = m << req_p->device->id;
+	m = m << scmd_id(req_p);
 
 	/*
 	 *      Fake a timeout for missing targets
@@ -757,9 +757,9 @@ static void send_s870(struct atp_unit *dev,unsigned char c)
 		dev->quhd[c] = 0;
 	}
 	workreq = dev->quereq[c][dev->quhd[c]];
-	if (dev->id[c][workreq->device->id].curr_req == 0) {	
-		dev->id[c][workreq->device->id].curr_req = workreq;
-		dev->last_cmd[c] = workreq->device->id;
+	if (dev->id[c][scmd_id(workreq)].curr_req == 0) {	
+		dev->id[c][scmd_id(workreq)].curr_req = workreq;
+		dev->last_cmd[c] = scmd_id(workreq);
 		goto cmd_subp;
 	}	
 	dev->quhd[c] = j;
@@ -786,16 +786,16 @@ static void send_s870(struct atp_unit *dev,unsigned char c)
 oktosend:
 #ifdef ED_DBGP
 	printk("OK to Send\n");
-	printk("CDB");
+	scmd_printk(KERN_DEBUG, workreq, "CDB");
 	for(i=0;i<workreq->cmd_len;i++) {
 		printk(" %x",workreq->cmnd[i]);
 	}
-	printk("\nChannel = %d ID = %d LUN = %d\n",c,workreq->device->id,workreq->device->lun);
+	printk("\n");
 #endif	
 	if (dev->dev_id == ATP885_DEVID) {
 		j = inb(dev->baseport + 0x29) & 0xfe;
 		outb(j, dev->baseport + 0x29);
-		dev->r1f[c][workreq->device->id] = 0;
+		dev->r1f[c][scmd_id(workreq)] = 0;
 	}
 	
 	if (workreq->cmnd[0] == READ_CAPACITY) {
@@ -809,7 +809,7 @@ static void send_s870(struct atp_unit *dev,unsigned char c)
 
 	tmport = workport + 0x1b;
 	j = 0;
-	target_id = workreq->device->id;
+	target_id = scmd_id(workreq);
 
 	/*
 	 *	Wide ?
@@ -3108,7 +3108,7 @@ static int atp870u_abort(struct scsi_cmnd * SCpnt)
 	host = SCpnt->device->host;
 
 	dev = (struct atp_unit *)&host->hostdata;
-	c=SCpnt->device->channel;
+	c = scmd_channel(SCpnt);
 	printk(" atp870u: abort Channel = %x \n", c);
 	printk("working=%x last_cmd=%x ", dev->working[c], dev->last_cmd[c]);
 	printk(" quhdu=%x quendu=%x ", dev->quhd[c], dev->quend[c]);

commit 017560fca496f72ed9dd734ffde63ce39dfe0411
Author: Jeff Garzik <jgarzik@pobox.com>
Date:   Mon Oct 24 18:04:36 2005 -0400

    [SCSI] use sfoo_printk() in drivers
    
    Rejections fixed up and
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>

diff --git a/drivers/scsi/atp870u.c b/drivers/scsi/atp870u.c
index a8cfbef304b5..b150bd8e254a 100644
--- a/drivers/scsi/atp870u.c
+++ b/drivers/scsi/atp870u.c
@@ -297,11 +297,10 @@ static irqreturn_t atp870u_intr_handle(int irq, void *dev_id, struct pt_regs *re
 			}
 			workreq = dev->id[c][target_id].curr_req;
 #ifdef ED_DBGP			
-			printk(KERN_DEBUG "Channel = %d ID = %d LUN = %d CDB",c,workreq->device->id,workreq->device->lun);
-			for(l=0;l<workreq->cmd_len;l++)
-			{
+			scmd_printk(KERN_DEBUG, workreq, "CDB");
+			for (l = 0; l < workreq->cmd_len; l++)
 				printk(KERN_DEBUG " %x",workreq->cmnd[l]);
-			}
+			printk("\n");
 #endif	
 			
 			tmport = workport + 0x0f;

commit b5683557331b129658ab435391df527ef72d63dc
Author: James Bottomley <jejb@titanic.(none)>
Date:   Thu Sep 15 08:59:36 2005 -0500

    [SCSI] atp870u: fix memory addressing bug
    
    From: Alan Cox <alan@redhat.com>
    
    The virt_to_bus() wasn't correctly taken out of this driver.  It needs
    to be able to track both physical and virtual addresses for its prd table.
    Update the driver to do this with separate tracking entries.
    
    Signed-off-by: Alan Cox <alan@redhat.com>
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>

diff --git a/drivers/scsi/atp870u.c b/drivers/scsi/atp870u.c
index e6153fe5842a..a8cfbef304b5 100644
--- a/drivers/scsi/atp870u.c
+++ b/drivers/scsi/atp870u.c
@@ -996,6 +996,7 @@ static void send_s870(struct atp_unit *dev,unsigned char c)
 #ifdef ED_DBGP		
 	printk("send_s870: prdaddr_2 0x%8x tmpcip %x target_id %d\n", dev->id[c][target_id].prdaddr,tmpcip,target_id);
 #endif	
+	dev->id[c][target_id].prdaddr = dev->id[c][target_id].prd_bus;
 	outl(dev->id[c][target_id].prdaddr, tmpcip);
 	tmpcip = tmpcip - 2;
 	outb(0x06, tmpcip);
@@ -2572,7 +2573,7 @@ static void atp870u_free_tables(struct Scsi_Host *host)
 		for (k = 0; k < 16; k++) {
 			if (!atp_dev->id[j][k].prd_table)
 				continue;
-			pci_free_consistent(atp_dev->pdev, 1024, atp_dev->id[j][k].prd_table, atp_dev->id[j][k].prdaddr);
+			pci_free_consistent(atp_dev->pdev, 1024, atp_dev->id[j][k].prd_table, atp_dev->id[j][k].prd_bus);
 			atp_dev->id[j][k].prd_table = NULL;
 		}
 	}
@@ -2584,12 +2585,13 @@ static int atp870u_init_tables(struct Scsi_Host *host)
 	int c,k;
 	for(c=0;c < 2;c++) {
 	   	for(k=0;k<16;k++) {
-	   			atp_dev->id[c][k].prd_table = pci_alloc_consistent(atp_dev->pdev, 1024, &(atp_dev->id[c][k].prdaddr));
+	   			atp_dev->id[c][k].prd_table = pci_alloc_consistent(atp_dev->pdev, 1024, &(atp_dev->id[c][k].prd_bus));
 	   			if (!atp_dev->id[c][k].prd_table) {
 	   				printk("atp870u_init_tables fail\n");
 				atp870u_free_tables(host);
 				return -ENOMEM;
 			}
+			atp_dev->id[c][k].prdaddr = atp_dev->id[c][k].prd_bus;
 			atp_dev->id[c][k].devsp=0x20;
 			atp_dev->id[c][k].devtype = 0x7f;
 			atp_dev->id[c][k].curr_req = NULL;			   

commit 420b4a73de8e36f0da486056189da66b0a164398
Author: Adrian Bunk <bunk@stusta.de>
Date:   Sun Apr 24 02:34:17 2005 -0500

    [SCSI] drivers/scsi/atp870u.c: make a function static
    
    This patch makes a needlessly global function static.
    
    Signed-off-by: Adrian Bunk <bunk@stusta.de>
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>

diff --git a/drivers/scsi/atp870u.c b/drivers/scsi/atp870u.c
index 45b75ddacaab..e6153fe5842a 100644
--- a/drivers/scsi/atp870u.c
+++ b/drivers/scsi/atp870u.c
@@ -3146,8 +3146,8 @@ static const char *atp870u_info(struct Scsi_Host *notused)
 }
 
 #define BLS buffer + len + size
-int atp870u_proc_info(struct Scsi_Host *HBAptr, char *buffer, 
-		      char **start, off_t offset, int length, int inout)
+static int atp870u_proc_info(struct Scsi_Host *HBAptr, char *buffer, 
+			     char **start, off_t offset, int length, int inout)
 {
 	static u8 buff[512];
 	int size = 0;

commit 1da177e4c3f41524e886b7f1b8a0c1fc7321cac2
Author: Linus Torvalds <torvalds@ppc970.osdl.org>
Date:   Sat Apr 16 15:20:36 2005 -0700

    Linux-2.6.12-rc2
    
    Initial git repository build. I'm not bothering with the full history,
    even though we have it. We can create a separate "historical" git
    archive of that later if we want to, and in the meantime it's about
    3.2GB when imported into git - space that would just make the early
    git days unnecessarily complicated, when we don't have a lot of good
    infrastructure for it.
    
    Let it rip!

diff --git a/drivers/scsi/atp870u.c b/drivers/scsi/atp870u.c
new file mode 100644
index 000000000000..45b75ddacaab
--- /dev/null
+++ b/drivers/scsi/atp870u.c
@@ -0,0 +1,3970 @@
+/* 
+ *  Copyright (C) 1997	Wu Ching Chen
+ *  2.1.x update (C) 1998  Krzysztof G. Baranowski
+ *  2.5.x update (C) 2002  Red Hat <alan@redhat.com>
+ *  2.6.x update (C) 2004  Red Hat <alan@redhat.com>
+ *
+ * Marcelo Tosatti <marcelo@conectiva.com.br> : SMP fixes
+ *
+ * Wu Ching Chen : NULL pointer fixes  2000/06/02
+ *		   support atp876 chip
+ *		   enable 32 bit fifo transfer
+ *		   support cdrom & remove device run ultra speed
+ *		   fix disconnect bug  2000/12/21
+ *		   support atp880 chip lvd u160 2001/05/15
+ *		   fix prd table bug 2001/09/12 (7.1)
+ *
+ * atp885 support add by ACARD Hao Ping Lian 2005/01/05
+ */
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/interrupt.h>
+#include <linux/kernel.h>
+#include <linux/types.h>
+#include <linux/string.h>
+#include <linux/ioport.h>
+#include <linux/delay.h>
+#include <linux/proc_fs.h>
+#include <linux/spinlock.h>
+#include <linux/pci.h>
+#include <linux/blkdev.h>
+#include <asm/system.h>
+#include <asm/io.h>
+
+#include <scsi/scsi.h>
+#include <scsi/scsi_cmnd.h>
+#include <scsi/scsi_device.h>
+#include <scsi/scsi_host.h>
+
+#include "atp870u.h"
+
+static struct scsi_host_template atp870u_template;
+static void send_s870(struct atp_unit *dev,unsigned char c);
+static void is885(struct atp_unit *dev, unsigned int wkport,unsigned char c);
+static void tscam_885(void);
+
+static irqreturn_t atp870u_intr_handle(int irq, void *dev_id, struct pt_regs *regs)
+{
+	unsigned long flags;
+	unsigned short int tmpcip, id;
+	unsigned char i, j, c, target_id, lun,cmdp;
+	unsigned char *prd;
+	struct scsi_cmnd *workreq;
+	unsigned int workport, tmport, tmport1;
+	unsigned long adrcnt, k;
+#ifdef ED_DBGP
+	unsigned long l;
+#endif
+	int errstus;
+	struct Scsi_Host *host = dev_id;
+	struct atp_unit *dev = (struct atp_unit *)&host->hostdata;
+
+	for (c = 0; c < 2; c++) {
+		tmport = dev->ioport[c] + 0x1f;
+		j = inb(tmport);
+		if ((j & 0x80) != 0)
+		{			
+	   		goto ch_sel;
+		}
+		dev->in_int[c] = 0;
+	}
+	return IRQ_NONE;
+ch_sel:
+#ifdef ED_DBGP	
+	printk("atp870u_intr_handle enter\n");
+#endif	
+	dev->in_int[c] = 1;
+	cmdp = inb(dev->ioport[c] + 0x10);
+	workport = dev->ioport[c];
+	if (dev->working[c] != 0) {
+		if (dev->dev_id == ATP885_DEVID) {
+			tmport1 = workport + 0x16;
+			if ((inb(tmport1) & 0x80) == 0)
+				outb((inb(tmport1) | 0x80), tmport1);
+		}		
+		tmpcip = dev->pciport[c];
+		if ((inb(tmpcip) & 0x08) != 0)
+		{
+			tmpcip += 0x2;
+			for (k=0; k < 1000; k++) {
+				if ((inb(tmpcip) & 0x08) == 0) {
+					goto stop_dma;
+				}
+				if ((inb(tmpcip) & 0x01) == 0) {
+					goto stop_dma;
+				}
+			}
+		}
+stop_dma:
+		tmpcip = dev->pciport[c];
+		outb(0x00, tmpcip);
+		tmport -= 0x08;
+		
+		i = inb(tmport);
+		
+		if (dev->dev_id == ATP885_DEVID) {
+			tmpcip += 2;
+			outb(0x06, tmpcip);
+			tmpcip -= 2;
+		}
+
+		tmport -= 0x02;
+		target_id = inb(tmport);
+		tmport += 0x02;
+
+		/*
+		 *	Remap wide devices onto id numbers
+		 */
+
+		if ((target_id & 0x40) != 0) {
+			target_id = (target_id & 0x07) | 0x08;
+		} else {
+			target_id &= 0x07;
+		}
+
+		if ((j & 0x40) != 0) {
+		     if (dev->last_cmd[c] == 0xff) {
+			dev->last_cmd[c] = target_id;
+		     }
+		     dev->last_cmd[c] |= 0x40;
+		}
+		if (dev->dev_id == ATP885_DEVID) 
+			dev->r1f[c][target_id] |= j;
+#ifdef ED_DBGP
+		printk("atp870u_intr_handle status = %x\n",i);
+#endif	
+		if (i == 0x85) {
+			if ((dev->last_cmd[c] & 0xf0) != 0x40) {
+			   dev->last_cmd[c] = 0xff;
+			}
+			if (dev->dev_id == ATP885_DEVID) {
+				tmport -= 0x05;
+				adrcnt = 0;
+				((unsigned char *) &adrcnt)[2] = inb(tmport++);
+				((unsigned char *) &adrcnt)[1] = inb(tmport++);
+				((unsigned char *) &adrcnt)[0] = inb(tmport);
+				if (dev->id[c][target_id].last_len != adrcnt)
+				{
+			   		k = dev->id[c][target_id].last_len;
+			   		k -= adrcnt;
+			   		dev->id[c][target_id].tran_len = k;			   
+			   	dev->id[c][target_id].last_len = adrcnt;			   
+				}
+#ifdef ED_DBGP
+				printk("tmport = %x dev->id[c][target_id].last_len = %d dev->id[c][target_id].tran_len = %d\n",tmport,dev->id[c][target_id].last_len,dev->id[c][target_id].tran_len);
+#endif		
+			}
+
+			/*
+			 *      Flip wide
+			 */			
+			if (dev->wide_id[c] != 0) {
+				tmport = workport + 0x1b;
+				outb(0x01, tmport);
+				while ((inb(tmport) & 0x01) != 0x01) {
+					outb(0x01, tmport);
+				}
+			}		
+			/*
+			 *	Issue more commands
+			 */
+			spin_lock_irqsave(dev->host->host_lock, flags);			 			 
+			if (((dev->quhd[c] != dev->quend[c]) || (dev->last_cmd[c] != 0xff)) &&
+			    (dev->in_snd[c] == 0)) {
+#ifdef ED_DBGP
+				printk("Call sent_s870\n");
+#endif				
+				send_s870(dev,c);
+			}
+			spin_unlock_irqrestore(dev->host->host_lock, flags);
+			/*
+			 *	Done
+			 */
+			dev->in_int[c] = 0;
+#ifdef ED_DBGP
+				printk("Status 0x85 return\n");
+#endif				
+			goto handled;
+		}
+
+		if (i == 0x40) {
+		     dev->last_cmd[c] |= 0x40;
+		     dev->in_int[c] = 0;
+		     goto handled;
+		}
+
+		if (i == 0x21) {
+			if ((dev->last_cmd[c] & 0xf0) != 0x40) {
+			   dev->last_cmd[c] = 0xff;
+			}
+			tmport -= 0x05;
+			adrcnt = 0;
+			((unsigned char *) &adrcnt)[2] = inb(tmport++);
+			((unsigned char *) &adrcnt)[1] = inb(tmport++);
+			((unsigned char *) &adrcnt)[0] = inb(tmport);
+			k = dev->id[c][target_id].last_len;
+			k -= adrcnt;
+			dev->id[c][target_id].tran_len = k;
+			dev->id[c][target_id].last_len = adrcnt;
+			tmport -= 0x04;
+			outb(0x41, tmport);
+			tmport += 0x08;
+			outb(0x08, tmport);
+			dev->in_int[c] = 0;
+			goto handled;
+		}
+
+		if (dev->dev_id == ATP885_DEVID) {
+			if ((i == 0x4c) || (i == 0x4d) || (i == 0x8c) || (i == 0x8d)) {
+		   		if ((i == 0x4c) || (i == 0x8c)) 
+		      			i=0x48;
+		   		else 
+		      			i=0x49;
+		   	}	
+			
+		}
+		if ((i == 0x80) || (i == 0x8f)) {
+#ifdef ED_DBGP
+			printk(KERN_DEBUG "Device reselect\n");
+#endif			
+			lun = 0;
+			tmport -= 0x07;
+			if (cmdp == 0x44 || i==0x80) {
+				tmport += 0x0d;
+				lun = inb(tmport) & 0x07;
+			} else {
+				if ((dev->last_cmd[c] & 0xf0) != 0x40) {
+				   dev->last_cmd[c] = 0xff;
+				}
+				if (cmdp == 0x41) {
+#ifdef ED_DBGP
+					printk("cmdp = 0x41\n");
+#endif						
+					tmport += 0x02;
+					adrcnt = 0;
+					((unsigned char *) &adrcnt)[2] = inb(tmport++);
+					((unsigned char *) &adrcnt)[1] = inb(tmport++);
+					((unsigned char *) &adrcnt)[0] = inb(tmport);
+					k = dev->id[c][target_id].last_len;
+					k -= adrcnt;
+					dev->id[c][target_id].tran_len = k;
+					dev->id[c][target_id].last_len = adrcnt;
+					tmport += 0x04;
+					outb(0x08, tmport);
+					dev->in_int[c] = 0;
+					goto handled;
+				} else {
+#ifdef ED_DBGP
+					printk("cmdp != 0x41\n");
+#endif						
+					outb(0x46, tmport);
+					dev->id[c][target_id].dirct = 0x00;
+					tmport += 0x02;
+					outb(0x00, tmport++);
+					outb(0x00, tmport++);
+					outb(0x00, tmport++);
+					tmport += 0x03;
+					outb(0x08, tmport);
+					dev->in_int[c] = 0;
+					goto handled;
+				}
+			}
+			if (dev->last_cmd[c] != 0xff) {
+			   dev->last_cmd[c] |= 0x40;
+			}
+			if (dev->dev_id == ATP885_DEVID) {
+				j = inb(dev->baseport + 0x29) & 0xfe;
+				outb(j, dev->baseport + 0x29);
+				tmport = workport + 0x16;
+			} else {
+				tmport = workport + 0x10;
+				outb(0x45, tmport);
+				tmport += 0x06;				
+			}
+			
+			target_id = inb(tmport);
+			/*
+			 *	Remap wide identifiers
+			 */
+			if ((target_id & 0x10) != 0) {
+				target_id = (target_id & 0x07) | 0x08;
+			} else {
+				target_id &= 0x07;
+			}
+			if (dev->dev_id == ATP885_DEVID) {
+				tmport = workport + 0x10;
+				outb(0x45, tmport);
+			}
+			workreq = dev->id[c][target_id].curr_req;
+#ifdef ED_DBGP			
+			printk(KERN_DEBUG "Channel = %d ID = %d LUN = %d CDB",c,workreq->device->id,workreq->device->lun);
+			for(l=0;l<workreq->cmd_len;l++)
+			{
+				printk(KERN_DEBUG " %x",workreq->cmnd[l]);
+			}
+#endif	
+			
+			tmport = workport + 0x0f;
+			outb(lun, tmport);
+			tmport += 0x02;
+			outb(dev->id[c][target_id].devsp, tmport++);
+			adrcnt = dev->id[c][target_id].tran_len;
+			k = dev->id[c][target_id].last_len;
+
+			outb(((unsigned char *) &k)[2], tmport++);
+			outb(((unsigned char *) &k)[1], tmport++);
+			outb(((unsigned char *) &k)[0], tmport++);
+#ifdef ED_DBGP			
+			printk("k %x, k[0] 0x%x k[1] 0x%x k[2] 0x%x\n", k, inb(tmport-1), inb(tmport-2), inb(tmport-3));
+#endif			
+			/* Remap wide */
+			j = target_id;
+			if (target_id > 7) {
+				j = (j & 0x07) | 0x40;
+			}
+			/* Add direction */
+			j |= dev->id[c][target_id].dirct;
+			outb(j, tmport++);
+			outb(0x80,tmport);
+			
+			/* enable 32 bit fifo transfer */	
+			if (dev->dev_id == ATP885_DEVID) {
+				tmpcip = dev->pciport[c] + 1;
+				i=inb(tmpcip) & 0xf3;
+				//j=workreq->cmnd[0];	    		    	
+				if ((workreq->cmnd[0] == 0x08) || (workreq->cmnd[0] == 0x28) || (workreq->cmnd[0] == 0x0a) || (workreq->cmnd[0] == 0x2a)) {
+				   i |= 0x0c;
+				}
+				outb(i,tmpcip);		    		    		
+			} else if ((dev->dev_id == ATP880_DEVID1) ||
+	    		    	   (dev->dev_id == ATP880_DEVID2) ) {
+				tmport = workport - 0x05;
+				if ((workreq->cmnd[0] == 0x08) || (workreq->cmnd[0] == 0x28) || (workreq->cmnd[0] == 0x0a) || (workreq->cmnd[0] == 0x2a)) {
+					outb((unsigned char) ((inb(tmport) & 0x3f) | 0xc0), tmport);
+				} else {
+					outb((unsigned char) (inb(tmport) & 0x3f), tmport);
+				}
+			} else {				
+				tmport = workport + 0x3a;
+				if ((workreq->cmnd[0] == 0x08) || (workreq->cmnd[0] == 0x28) || (workreq->cmnd[0] == 0x0a) || (workreq->cmnd[0] == 0x2a)) {
+					outb((unsigned char) ((inb(tmport) & 0xf3) | 0x08), tmport);
+				} else {
+					outb((unsigned char) (inb(tmport) & 0xf3), tmport);
+				}														
+			}	
+			tmport = workport + 0x1b;
+			j = 0;
+			id = 1;
+			id = id << target_id;
+			/*
+			 *	Is this a wide device
+			 */
+			if ((id & dev->wide_id[c]) != 0) {
+				j |= 0x01;
+			}
+			outb(j, tmport);
+			while ((inb(tmport) & 0x01) != j) {
+				outb(j,tmport);
+			}
+			if (dev->id[c][target_id].last_len == 0) {
+				tmport = workport + 0x18;
+				outb(0x08, tmport);
+				dev->in_int[c] = 0;
+#ifdef ED_DBGP
+				printk("dev->id[c][target_id].last_len = 0\n");
+#endif					
+				goto handled;
+			}
+#ifdef ED_DBGP
+			printk("target_id = %d adrcnt = %d\n",target_id,adrcnt);
+#endif			
+			prd = dev->id[c][target_id].prd_pos;
+			while (adrcnt != 0) {
+				id = ((unsigned short int *)prd)[2];
+				if (id == 0) {
+					k = 0x10000;
+				} else {
+					k = id;
+				}
+				if (k > adrcnt) {
+					((unsigned short int *)prd)[2] = (unsigned short int)
+					    (k - adrcnt);
+					((unsigned long *)prd)[0] += adrcnt;
+					adrcnt = 0;
+					dev->id[c][target_id].prd_pos = prd;
+				} else {
+					adrcnt -= k;
+					dev->id[c][target_id].prdaddr += 0x08;
+					prd += 0x08;
+					if (adrcnt == 0) {
+						dev->id[c][target_id].prd_pos = prd;
+					}
+				}				
+			}
+			tmpcip = dev->pciport[c] + 0x04;
+			outl(dev->id[c][target_id].prdaddr, tmpcip);
+#ifdef ED_DBGP
+			printk("dev->id[%d][%d].prdaddr 0x%8x\n", c, target_id, dev->id[c][target_id].prdaddr);
+#endif
+			if (dev->dev_id == ATP885_DEVID) {
+				tmpcip -= 0x04;
+			} else {
+				tmpcip -= 0x02;
+				outb(0x06, tmpcip);
+				outb(0x00, tmpcip);
+				tmpcip -= 0x02;
+			}
+			tmport = workport + 0x18;
+			/*
+			 *	Check transfer direction
+			 */
+			if (dev->id[c][target_id].dirct != 0) {
+				outb(0x08, tmport);
+				outb(0x01, tmpcip);
+				dev->in_int[c] = 0;
+#ifdef ED_DBGP
+				printk("status 0x80 return dirct != 0\n");
+#endif				
+				goto handled;
+			}
+			outb(0x08, tmport);
+			outb(0x09, tmpcip);
+			dev->in_int[c] = 0;
+#ifdef ED_DBGP
+			printk("status 0x80 return dirct = 0\n");
+#endif			
+			goto handled;
+		}
+
+		/*
+		 *	Current scsi request on this target
+		 */
+
+		workreq = dev->id[c][target_id].curr_req;
+
+		if (i == 0x42) {
+			if ((dev->last_cmd[c] & 0xf0) != 0x40)
+			{
+			   dev->last_cmd[c] = 0xff;
+			}
+			errstus = 0x02;
+			workreq->result = errstus;
+			goto go_42;
+		}
+		if (i == 0x16) {
+			if ((dev->last_cmd[c] & 0xf0) != 0x40) {
+			   dev->last_cmd[c] = 0xff;
+			}
+			errstus = 0;
+			tmport -= 0x08;
+			errstus = inb(tmport);
+			if (((dev->r1f[c][target_id] & 0x10) != 0)&&(dev->dev_id==ATP885_DEVID)) {
+			   printk(KERN_WARNING "AEC67162 CRC ERROR !\n");
+			   errstus = 0x02;
+			}
+			workreq->result = errstus;
+go_42:
+			if (dev->dev_id == ATP885_DEVID) {		
+				j = inb(dev->baseport + 0x29) | 0x01;
+				outb(j, dev->baseport + 0x29);
+			}
+			/*
+			 *	Complete the command
+			 */
+			if (workreq->use_sg) {
+				pci_unmap_sg(dev->pdev,
+					(struct scatterlist *)workreq->buffer,
+					workreq->use_sg,
+					workreq->sc_data_direction);
+			} else if (workreq->request_bufflen &&
+					workreq->sc_data_direction != DMA_NONE) {
+				pci_unmap_single(dev->pdev,
+					workreq->SCp.dma_handle,
+					workreq->request_bufflen,
+					workreq->sc_data_direction);
+			}			
+			spin_lock_irqsave(dev->host->host_lock, flags);
+			(*workreq->scsi_done) (workreq);
+#ifdef ED_DBGP
+			   printk("workreq->scsi_done\n");
+#endif	
+			/*
+			 *	Clear it off the queue
+			 */
+			dev->id[c][target_id].curr_req = NULL;
+			dev->working[c]--;
+			spin_unlock_irqrestore(dev->host->host_lock, flags);
+			/*
+			 *      Take it back wide
+			 */
+			if (dev->wide_id[c] != 0) {
+				tmport = workport + 0x1b;
+				outb(0x01, tmport);
+				while ((inb(tmport) & 0x01) != 0x01) {
+					outb(0x01, tmport);
+				}       
+			} 
+			/*
+			 *	If there is stuff to send and nothing going then send it
+			 */
+			spin_lock_irqsave(dev->host->host_lock, flags);
+			if (((dev->last_cmd[c] != 0xff) || (dev->quhd[c] != dev->quend[c])) &&
+			    (dev->in_snd[c] == 0)) {
+#ifdef ED_DBGP
+			   printk("Call sent_s870(scsi_done)\n");
+#endif				   
+			   send_s870(dev,c);
+			}
+			spin_unlock_irqrestore(dev->host->host_lock, flags);
+			dev->in_int[c] = 0;
+			goto handled;
+		}
+		if ((dev->last_cmd[c] & 0xf0) != 0x40) {
+		   dev->last_cmd[c] = 0xff;
+		}
+		if (i == 0x4f) {
+			i = 0x89;
+		}
+		i &= 0x0f;
+		if (i == 0x09) {
+			tmpcip += 4;
+			outl(dev->id[c][target_id].prdaddr, tmpcip);
+			tmpcip = tmpcip - 2;
+			outb(0x06, tmpcip);
+			outb(0x00, tmpcip);
+			tmpcip = tmpcip - 2;
+			tmport = workport + 0x10;
+			outb(0x41, tmport);
+			if (dev->dev_id == ATP885_DEVID) {
+				tmport += 2;
+				k = dev->id[c][target_id].last_len;
+				outb((unsigned char) (((unsigned char *) (&k))[2]), tmport++);
+				outb((unsigned char) (((unsigned char *) (&k))[1]), tmport++);
+				outb((unsigned char) (((unsigned char *) (&k))[0]), tmport);
+				dev->id[c][target_id].dirct = 0x00;
+				tmport += 0x04;
+			} else {
+				dev->id[c][target_id].dirct = 0x00;
+				tmport += 0x08;				
+			}
+			outb(0x08, tmport);
+			outb(0x09, tmpcip);
+			dev->in_int[c] = 0;
+			goto handled;
+		}
+		if (i == 0x08) {
+			tmpcip += 4;
+			outl(dev->id[c][target_id].prdaddr, tmpcip);
+			tmpcip = tmpcip - 2;
+			outb(0x06, tmpcip);
+			outb(0x00, tmpcip);
+			tmpcip = tmpcip - 2;
+			tmport = workport + 0x10;
+			outb(0x41, tmport);
+			if (dev->dev_id == ATP885_DEVID) {		
+				tmport += 2;
+				k = dev->id[c][target_id].last_len;
+				outb((unsigned char) (((unsigned char *) (&k))[2]), tmport++);
+				outb((unsigned char) (((unsigned char *) (&k))[1]), tmport++);
+				outb((unsigned char) (((unsigned char *) (&k))[0]), tmport++);
+			} else {
+				tmport += 5;
+			}
+			outb((unsigned char) (inb(tmport) | 0x20), tmport);
+			dev->id[c][target_id].dirct = 0x20;
+			tmport += 0x03;
+			outb(0x08, tmport);
+			outb(0x01, tmpcip);
+			dev->in_int[c] = 0;
+			goto handled;
+		}
+		tmport -= 0x07;
+		if (i == 0x0a) {
+			outb(0x30, tmport);
+		} else {
+			outb(0x46, tmport);
+		}
+		dev->id[c][target_id].dirct = 0x00;
+		tmport += 0x02;
+		outb(0x00, tmport++);
+		outb(0x00, tmport++);
+		outb(0x00, tmport++);
+		tmport += 0x03;
+		outb(0x08, tmport);
+		dev->in_int[c] = 0;
+		goto handled;
+	} else {
+//		tmport = workport + 0x17;
+//		inb(tmport);
+//		dev->working[c] = 0;
+		dev->in_int[c] = 0;
+		goto handled;
+	}
+	
+handled:
+#ifdef ED_DBGP
+	printk("atp870u_intr_handle exit\n");
+#endif			
+	return IRQ_HANDLED;
+}
+/**
+ *	atp870u_queuecommand	-	Queue SCSI command
+ *	@req_p: request block
+ *	@done: completion function
+ *
+ *	Queue a command to the ATP queue. Called with the host lock held.
+ */
+static int atp870u_queuecommand(struct scsi_cmnd * req_p, 
+			 void (*done) (struct scsi_cmnd *))
+{
+	unsigned char c;
+	unsigned int tmport,m;	
+	struct atp_unit *dev;
+	struct Scsi_Host *host;
+
+	c = req_p->device->channel;	
+	req_p->sense_buffer[0]=0;
+	req_p->resid = 0;
+	if (req_p->device->channel > 1) {
+		req_p->result = 0x00040000;
+		done(req_p);
+#ifdef ED_DBGP		
+		printk("atp870u_queuecommand : req_p->device->channel > 1\n");	
+#endif			
+		return 0;
+	}
+
+	host = req_p->device->host;
+	dev = (struct atp_unit *)&host->hostdata;
+		
+
+		
+	m = 1;
+	m = m << req_p->device->id;
+
+	/*
+	 *      Fake a timeout for missing targets
+	 */
+
+	if ((m & dev->active_id[c]) == 0) {
+		req_p->result = 0x00040000;
+		done(req_p);
+		return 0;
+	}
+
+	if (done) {
+		req_p->scsi_done = done;
+	} else {
+#ifdef ED_DBGP		
+		printk( "atp870u_queuecommand: done can't be NULL\n");
+#endif		
+		req_p->result = 0;
+		done(req_p);
+		return 0;
+	}
+	
+	/*
+	 *	Count new command
+	 */
+	dev->quend[c]++;
+	if (dev->quend[c] >= qcnt) {
+		dev->quend[c] = 0;
+	}
+	
+	/*
+	 *	Check queue state
+	 */
+	if (dev->quhd[c] == dev->quend[c]) {
+		if (dev->quend[c] == 0) {
+			dev->quend[c] = qcnt;
+		}
+#ifdef ED_DBGP		
+		printk("atp870u_queuecommand : dev->quhd[c] == dev->quend[c]\n");
+#endif		
+		dev->quend[c]--;
+		req_p->result = 0x00020000;
+		done(req_p);	
+		return 0;
+	}
+	dev->quereq[c][dev->quend[c]] = req_p;
+	tmport = dev->ioport[c] + 0x1c;
+#ifdef ED_DBGP	
+	printk("dev->ioport[c] = %x inb(tmport) = %x dev->in_int[%d] = %d dev->in_snd[%d] = %d\n",dev->ioport[c],inb(tmport),c,dev->in_int[c],c,dev->in_snd[c]);
+#endif
+	if ((inb(tmport) == 0) && (dev->in_int[c] == 0) && (dev->in_snd[c] == 0)) {
+#ifdef ED_DBGP
+		printk("Call sent_s870(atp870u_queuecommand)\n");
+#endif		
+		send_s870(dev,c);
+	}
+#ifdef ED_DBGP	
+	printk("atp870u_queuecommand : exit\n");
+#endif	
+	return 0;
+}
+
+/**
+ *	send_s870	-	send a command to the controller
+ *	@host: host
+ *
+ *	On entry there is work queued to be done. We move some of that work to the
+ *	controller itself. 
+ *
+ *	Caller holds the host lock.
+ */
+static void send_s870(struct atp_unit *dev,unsigned char c)
+{
+	unsigned int tmport;
+	struct scsi_cmnd *workreq;
+	unsigned int i;//,k;
+	unsigned char  j, target_id;
+	unsigned char *prd;
+	unsigned short int tmpcip, w;
+	unsigned long l, bttl = 0;
+	unsigned int workport;
+	struct scatterlist *sgpnt;
+	unsigned long  sg_count;
+
+	if (dev->in_snd[c] != 0) {
+#ifdef ED_DBGP		
+		printk("cmnd in_snd\n");
+#endif
+		return;
+	}
+#ifdef ED_DBGP
+	printk("Sent_s870 enter\n");
+#endif
+	dev->in_snd[c] = 1;
+	if ((dev->last_cmd[c] != 0xff) && ((dev->last_cmd[c] & 0x40) != 0)) {
+		dev->last_cmd[c] &= 0x0f;
+		workreq = dev->id[c][dev->last_cmd[c]].curr_req;
+		if (workreq != NULL) {	/* check NULL pointer */
+		   goto cmd_subp;
+		}
+		dev->last_cmd[c] = 0xff;	
+		if (dev->quhd[c] == dev->quend[c]) {
+		   	dev->in_snd[c] = 0;
+		   	return ;
+		}
+	}
+	if ((dev->last_cmd[c] != 0xff) && (dev->working[c] != 0)) {
+	     	dev->in_snd[c] = 0;
+	     	return ;
+	}
+	dev->working[c]++;
+	j = dev->quhd[c];
+	dev->quhd[c]++;
+	if (dev->quhd[c] >= qcnt) {
+		dev->quhd[c] = 0;
+	}
+	workreq = dev->quereq[c][dev->quhd[c]];
+	if (dev->id[c][workreq->device->id].curr_req == 0) {	
+		dev->id[c][workreq->device->id].curr_req = workreq;
+		dev->last_cmd[c] = workreq->device->id;
+		goto cmd_subp;
+	}	
+	dev->quhd[c] = j;
+	dev->working[c]--;
+	dev->in_snd[c] = 0;
+	return;
+cmd_subp:
+	workport = dev->ioport[c];
+	tmport = workport + 0x1f;
+	if ((inb(tmport) & 0xb0) != 0) {
+		goto abortsnd;
+	}
+	tmport = workport + 0x1c;
+	if (inb(tmport) == 0) {
+		goto oktosend;
+	}
+abortsnd:
+#ifdef ED_DBGP
+	printk("Abort to Send\n");
+#endif
+	dev->last_cmd[c] |= 0x40;
+	dev->in_snd[c] = 0;
+	return;
+oktosend:
+#ifdef ED_DBGP
+	printk("OK to Send\n");
+	printk("CDB");
+	for(i=0;i<workreq->cmd_len;i++) {
+		printk(" %x",workreq->cmnd[i]);
+	}
+	printk("\nChannel = %d ID = %d LUN = %d\n",c,workreq->device->id,workreq->device->lun);
+#endif	
+	if (dev->dev_id == ATP885_DEVID) {
+		j = inb(dev->baseport + 0x29) & 0xfe;
+		outb(j, dev->baseport + 0x29);
+		dev->r1f[c][workreq->device->id] = 0;
+	}
+	
+	if (workreq->cmnd[0] == READ_CAPACITY) {
+		if (workreq->request_bufflen > 8) {
+			workreq->request_bufflen = 0x08;
+		}
+	}
+	if (workreq->cmnd[0] == 0x00) {
+		workreq->request_bufflen = 0;
+	}
+
+	tmport = workport + 0x1b;
+	j = 0;
+	target_id = workreq->device->id;
+
+	/*
+	 *	Wide ?
+	 */
+	w = 1;
+	w = w << target_id;
+	if ((w & dev->wide_id[c]) != 0) {
+		j |= 0x01;
+	}
+	outb(j, tmport);
+	while ((inb(tmport) & 0x01) != j) {
+		outb(j,tmport);
+#ifdef ED_DBGP
+		printk("send_s870 while loop 1\n");
+#endif
+	}
+	/*
+	 *	Write the command
+	 */
+
+	tmport = workport;
+	outb(workreq->cmd_len, tmport++);
+	outb(0x2c, tmport++);
+	if (dev->dev_id == ATP885_DEVID) {
+		outb(0x7f, tmport++);
+	} else {
+		outb(0xcf, tmport++); 	
+	}	
+	for (i = 0; i < workreq->cmd_len; i++) {
+		outb(workreq->cmnd[i], tmport++);
+	}
+	tmport = workport + 0x0f;
+	outb(workreq->device->lun, tmport);
+	tmport += 0x02;
+	/*
+	 *	Write the target
+	 */
+	outb(dev->id[c][target_id].devsp, tmport++);	 
+#ifdef ED_DBGP	
+	printk("dev->id[%d][%d].devsp = %2x\n",c,target_id,dev->id[c][target_id].devsp);
+#endif
+	/*
+	 *	Figure out the transfer size
+	 */
+	if (workreq->use_sg) {
+#ifdef ED_DBGP
+		printk("Using SGL\n");
+#endif		
+		l = 0;
+		
+		sgpnt = (struct scatterlist *) workreq->request_buffer;
+		sg_count = pci_map_sg(dev->pdev, sgpnt, workreq->use_sg,
+	   			workreq->sc_data_direction);		
+		
+		for (i = 0; i < workreq->use_sg; i++) {
+			if (sgpnt[i].length == 0 || workreq->use_sg > ATP870U_SCATTER) {
+				panic("Foooooooood fight!");
+			}
+			l += sgpnt[i].length;
+		}
+#ifdef ED_DBGP		
+		printk( "send_s870: workreq->use_sg %d, sg_count %d l %8ld\n", workreq->use_sg, sg_count, l);
+#endif
+	} else if(workreq->request_bufflen && workreq->sc_data_direction != PCI_DMA_NONE) {
+#ifdef ED_DBGP
+		printk("Not using SGL\n");
+#endif					
+		workreq->SCp.dma_handle = pci_map_single(dev->pdev, workreq->request_buffer,
+				workreq->request_bufflen,
+				workreq->sc_data_direction);		
+		l = workreq->request_bufflen;
+#ifdef ED_DBGP		
+		printk( "send_s870: workreq->use_sg %d, l %8ld\n", workreq->use_sg, l);
+#endif
+	} else l = 0;
+	/*
+	 *	Write transfer size
+	 */
+	outb((unsigned char) (((unsigned char *) (&l))[2]), tmport++);
+	outb((unsigned char) (((unsigned char *) (&l))[1]), tmport++);
+	outb((unsigned char) (((unsigned char *) (&l))[0]), tmport++);
+	j = target_id;	
+	dev->id[c][j].last_len = l;
+	dev->id[c][j].tran_len = 0;
+#ifdef ED_DBGP	
+	printk("dev->id[%2d][%2d].last_len = %d\n",c,j,dev->id[c][j].last_len);
+#endif	
+	/*
+	 *	Flip the wide bits
+	 */
+	if ((j & 0x08) != 0) {
+		j = (j & 0x07) | 0x40;
+	}
+	/*
+	 *	Check transfer direction
+	 */
+	if (workreq->sc_data_direction == DMA_TO_DEVICE) {
+		outb((unsigned char) (j | 0x20), tmport++);
+	} else {
+		outb(j, tmport++);
+	}
+	outb((unsigned char) (inb(tmport) | 0x80), tmport);
+	outb(0x80, tmport);
+	tmport = workport + 0x1c;
+	dev->id[c][target_id].dirct = 0;
+	if (l == 0) {
+		if (inb(tmport) == 0) {
+			tmport = workport + 0x18;
+#ifdef ED_DBGP
+			printk("change SCSI_CMD_REG 0x08\n");	
+#endif				
+			outb(0x08, tmport);
+		} else {
+			dev->last_cmd[c] |= 0x40;
+		}
+		dev->in_snd[c] = 0;
+		return;
+	}
+	tmpcip = dev->pciport[c];
+	prd = dev->id[c][target_id].prd_table;
+	dev->id[c][target_id].prd_pos = prd;
+
+	/*
+	 *	Now write the request list. Either as scatter/gather or as
+	 *	a linear chain.
+	 */
+
+	if (workreq->use_sg) {
+		sgpnt = (struct scatterlist *) workreq->request_buffer;
+		i = 0;
+		for (j = 0; j < workreq->use_sg; j++) {
+			bttl = sg_dma_address(&sgpnt[j]);
+			l=sg_dma_len(&sgpnt[j]);
+#ifdef ED_DBGP		
+		printk("1. bttl %x, l %x\n",bttl, l);
+#endif			
+		while (l > 0x10000) {
+				(((u16 *) (prd))[i + 3]) = 0x0000;
+				(((u16 *) (prd))[i + 2]) = 0x0000;
+				(((u32 *) (prd))[i >> 1]) = cpu_to_le32(bttl);
+				l -= 0x10000;
+				bttl += 0x10000;
+				i += 0x04;
+			}
+			(((u32 *) (prd))[i >> 1]) = cpu_to_le32(bttl);
+			(((u16 *) (prd))[i + 2]) = cpu_to_le16(l);
+			(((u16 *) (prd))[i + 3]) = 0;
+			i += 0x04;			
+		}
+		(((u16 *) (prd))[i - 1]) = cpu_to_le16(0x8000);	
+#ifdef ED_DBGP		
+		printk("prd %4x %4x %4x %4x\n",(((unsigned short int *)prd)[0]),(((unsigned short int *)prd)[1]),(((unsigned short int *)prd)[2]),(((unsigned short int *)prd)[3]));
+		printk("2. bttl %x, l %x\n",bttl, l);
+#endif			
+	} else {
+		/*
+		 *	For a linear request write a chain of blocks
+		 */        
+		bttl = workreq->SCp.dma_handle;
+		l = workreq->request_bufflen;
+		i = 0;
+#ifdef ED_DBGP		
+		printk("3. bttl %x, l %x\n",bttl, l);
+#endif			
+		while (l > 0x10000) {
+				(((u16 *) (prd))[i + 3]) = 0x0000;
+				(((u16 *) (prd))[i + 2]) = 0x0000;
+				(((u32 *) (prd))[i >> 1]) = cpu_to_le32(bttl);
+				l -= 0x10000;
+				bttl += 0x10000;
+				i += 0x04;
+			}
+			(((u16 *) (prd))[i + 3]) = cpu_to_le16(0x8000);
+			(((u16 *) (prd))[i + 2]) = cpu_to_le16(l);
+			(((u32 *) (prd))[i >> 1]) = cpu_to_le32(bttl);		
+#ifdef ED_DBGP		
+		printk("prd %4x %4x %4x %4x\n",(((unsigned short int *)prd)[0]),(((unsigned short int *)prd)[1]),(((unsigned short int *)prd)[2]),(((unsigned short int *)prd)[3]));
+		printk("4. bttl %x, l %x\n",bttl, l);
+#endif			
+		
+	}
+	tmpcip += 4;
+#ifdef ED_DBGP		
+	printk("send_s870: prdaddr_2 0x%8x tmpcip %x target_id %d\n", dev->id[c][target_id].prdaddr,tmpcip,target_id);
+#endif	
+	outl(dev->id[c][target_id].prdaddr, tmpcip);
+	tmpcip = tmpcip - 2;
+	outb(0x06, tmpcip);
+	outb(0x00, tmpcip);
+	if (dev->dev_id == ATP885_DEVID) {
+		tmpcip--;
+		j=inb(tmpcip) & 0xf3;
+		if ((workreq->cmnd[0] == 0x08) || (workreq->cmnd[0] == 0x28) ||
+	    	(workreq->cmnd[0] == 0x0a) || (workreq->cmnd[0] == 0x2a)) {
+	   		j |= 0x0c;
+		}
+		outb(j,tmpcip);
+		tmpcip--;	    	
+	} else if ((dev->dev_id == ATP880_DEVID1) ||
+	    	   (dev->dev_id == ATP880_DEVID2)) {
+		tmpcip =tmpcip -2;	
+		tmport = workport - 0x05;
+		if ((workreq->cmnd[0] == 0x08) || (workreq->cmnd[0] == 0x28) || (workreq->cmnd[0] == 0x0a) || (workreq->cmnd[0] == 0x2a)) {
+			outb((unsigned char) ((inb(tmport) & 0x3f) | 0xc0), tmport);
+		} else {
+			outb((unsigned char) (inb(tmport) & 0x3f), tmport);
+		}		
+	} else {		
+		tmpcip =tmpcip -2;
+		tmport = workport + 0x3a;
+		if ((workreq->cmnd[0] == 0x08) || (workreq->cmnd[0] == 0x28) || (workreq->cmnd[0] == 0x0a) || (workreq->cmnd[0] == 0x2a)) {
+			outb((inb(tmport) & 0xf3) | 0x08, tmport);
+		} else {
+			outb(inb(tmport) & 0xf3, tmport);
+		}		
+	}	
+	tmport = workport + 0x1c;
+
+	if(workreq->sc_data_direction == DMA_TO_DEVICE) {
+		dev->id[c][target_id].dirct = 0x20;
+		if (inb(tmport) == 0) {
+			tmport = workport + 0x18;
+			outb(0x08, tmport);
+			outb(0x01, tmpcip);
+#ifdef ED_DBGP		
+		printk( "start DMA(to target)\n");
+#endif				
+		} else {
+			dev->last_cmd[c] |= 0x40;
+		}
+		dev->in_snd[c] = 0;
+		return;
+	}
+	if (inb(tmport) == 0) {		
+		tmport = workport + 0x18;
+		outb(0x08, tmport);
+		outb(0x09, tmpcip);
+#ifdef ED_DBGP		
+		printk( "start DMA(to host)\n");
+#endif			
+	} else {
+		dev->last_cmd[c] |= 0x40;
+	}
+	dev->in_snd[c] = 0;
+	return;
+
+}
+
+static unsigned char fun_scam(struct atp_unit *dev, unsigned short int *val)
+{
+	unsigned int tmport;
+	unsigned short int i, k;
+	unsigned char j;
+
+	tmport = dev->ioport[0] + 0x1c;
+	outw(*val, tmport);
+FUN_D7:
+	for (i = 0; i < 10; i++) {	/* stable >= bus settle delay(400 ns)  */
+		k = inw(tmport);
+		j = (unsigned char) (k >> 8);
+		if ((k & 0x8000) != 0) {	/* DB7 all release?    */
+			goto FUN_D7;
+		}
+	}
+	*val |= 0x4000;		/* assert DB6           */
+	outw(*val, tmport);
+	*val &= 0xdfff;		/* assert DB5           */
+	outw(*val, tmport);
+FUN_D5:
+	for (i = 0; i < 10; i++) {	/* stable >= bus settle delay(400 ns) */
+		if ((inw(tmport) & 0x2000) != 0) {	/* DB5 all release?       */
+			goto FUN_D5;
+		}
+	}
+	*val |= 0x8000;		/* no DB4-0, assert DB7    */
+	*val &= 0xe0ff;
+	outw(*val, tmport);
+	*val &= 0xbfff;		/* release DB6             */
+	outw(*val, tmport);
+FUN_D6:
+	for (i = 0; i < 10; i++) {	/* stable >= bus settle delay(400 ns)  */
+		if ((inw(tmport) & 0x4000) != 0) {	/* DB6 all release?  */
+			goto FUN_D6;
+		}
+	}
+
+	return j;
+}
+
+static void tscam(struct Scsi_Host *host)
+{
+
+	unsigned int tmport;
+	unsigned char i, j, k;
+	unsigned long n;
+	unsigned short int m, assignid_map, val;
+	unsigned char mbuf[33], quintet[2];
+	struct atp_unit *dev = (struct atp_unit *)&host->hostdata;
+	static unsigned char g2q_tab[8] = {
+		0x38, 0x31, 0x32, 0x2b, 0x34, 0x2d, 0x2e, 0x27
+	};
+
+/*  I can't believe we need this before we've even done anything.  Remove it
+ *  and see if anyone bitches.
+	for (i = 0; i < 0x10; i++) {
+		udelay(0xffff);
+	}
+ */
+
+	tmport = dev->ioport[0] + 1;
+	outb(0x08, tmport++);
+	outb(0x7f, tmport);
+	tmport = dev->ioport[0] + 0x11;
+	outb(0x20, tmport);
+
+	if ((dev->scam_on & 0x40) == 0) {
+		return;
+	}
+	m = 1;
+	m <<= dev->host_id[0];
+	j = 16;
+	if (dev->chip_ver < 4) {
+		m |= 0xff00;
+		j = 8;
+	}
+	assignid_map = m;
+	tmport = dev->ioport[0] + 0x02;
+	outb(0x02, tmport++);	/* 2*2=4ms,3EH 2/32*3E=3.9ms */
+	outb(0, tmport++);
+	outb(0, tmport++);
+	outb(0, tmport++);
+	outb(0, tmport++);
+	outb(0, tmport++);
+	outb(0, tmport++);
+
+	for (i = 0; i < j; i++) {
+		m = 1;
+		m = m << i;
+		if ((m & assignid_map) != 0) {
+			continue;
+		}
+		tmport = dev->ioport[0] + 0x0f;
+		outb(0, tmport++);
+		tmport += 0x02;
+		outb(0, tmport++);
+		outb(0, tmport++);
+		outb(0, tmport++);
+		if (i > 7) {
+			k = (i & 0x07) | 0x40;
+		} else {
+			k = i;
+		}
+		outb(k, tmport++);
+		tmport = dev->ioport[0] + 0x1b;
+		if (dev->chip_ver == 4) {
+			outb(0x01, tmport);
+		} else {
+			outb(0x00, tmport);
+		}
+wait_rdyok:
+		tmport = dev->ioport[0] + 0x18;
+		outb(0x09, tmport);
+		tmport += 0x07;
+
+		while ((inb(tmport) & 0x80) == 0x00)
+			cpu_relax();
+		tmport -= 0x08;
+		k = inb(tmport);
+		if (k != 0x16) {
+			if ((k == 0x85) || (k == 0x42)) {
+				continue;
+			}
+			tmport = dev->ioport[0] + 0x10;
+			outb(0x41, tmport);
+			goto wait_rdyok;
+		}
+		assignid_map |= m;
+
+	}
+	tmport = dev->ioport[0] + 0x02;
+	outb(0x7f, tmport);
+	tmport = dev->ioport[0] + 0x1b;
+	outb(0x02, tmport);
+
+	outb(0, 0x80);
+
+	val = 0x0080;		/* bsy  */
+	tmport = dev->ioport[0] + 0x1c;
+	outw(val, tmport);
+	val |= 0x0040;		/* sel  */
+	outw(val, tmport);
+	val |= 0x0004;		/* msg  */
+	outw(val, tmport);
+	inb(0x80);		/* 2 deskew delay(45ns*2=90ns) */
+	val &= 0x007f;		/* no bsy  */
+	outw(val, tmport);
+	mdelay(128);
+	val &= 0x00fb;		/* after 1ms no msg */
+	outw(val, tmport);
+wait_nomsg:
+	if ((inb(tmport) & 0x04) != 0) {
+		goto wait_nomsg;
+	}
+	outb(1, 0x80);
+	udelay(100);
+	for (n = 0; n < 0x30000; n++) {
+		if ((inb(tmport) & 0x80) != 0) {	/* bsy ? */
+			goto wait_io;
+		}
+	}
+	goto TCM_SYNC;
+wait_io:
+	for (n = 0; n < 0x30000; n++) {
+		if ((inb(tmport) & 0x81) == 0x0081) {
+			goto wait_io1;
+		}
+	}
+	goto TCM_SYNC;
+wait_io1:
+	inb(0x80);
+	val |= 0x8003;		/* io,cd,db7  */
+	outw(val, tmport);
+	inb(0x80);
+	val &= 0x00bf;		/* no sel     */
+	outw(val, tmport);
+	outb(2, 0x80);
+TCM_SYNC:
+	udelay(0x800);
+	if ((inb(tmport) & 0x80) == 0x00) {	/* bsy ? */
+		outw(0, tmport--);
+		outb(0, tmport);
+		tmport = dev->ioport[0] + 0x15;
+		outb(0, tmport);
+		tmport += 0x03;
+		outb(0x09, tmport);
+		tmport += 0x07;
+		while ((inb(tmport) & 0x80) == 0)
+			cpu_relax();
+		tmport -= 0x08;
+		inb(tmport);
+		return;
+	}
+	val &= 0x00ff;		/* synchronization  */
+	val |= 0x3f00;
+	fun_scam(dev, &val);
+	outb(3, 0x80);
+	val &= 0x00ff;		/* isolation        */
+	val |= 0x2000;
+	fun_scam(dev, &val);
+	outb(4, 0x80);
+	i = 8;
+	j = 0;
+TCM_ID:
+	if ((inw(tmport) & 0x2000) == 0) {
+		goto TCM_ID;
+	}
+	outb(5, 0x80);
+	val &= 0x00ff;		/* get ID_STRING */
+	val |= 0x2000;
+	k = fun_scam(dev, &val);
+	if ((k & 0x03) == 0) {
+		goto TCM_5;
+	}
+	mbuf[j] <<= 0x01;
+	mbuf[j] &= 0xfe;
+	if ((k & 0x02) != 0) {
+		mbuf[j] |= 0x01;
+	}
+	i--;
+	if (i > 0) {
+		goto TCM_ID;
+	}
+	j++;
+	i = 8;
+	goto TCM_ID;
+
+TCM_5:			/* isolation complete..  */
+/*    mbuf[32]=0;
+	printk(" \n%x %x %x %s\n ",assignid_map,mbuf[0],mbuf[1],&mbuf[2]); */
+	i = 15;
+	j = mbuf[0];
+	if ((j & 0x20) != 0) {	/* bit5=1:ID upto 7      */
+		i = 7;
+	}
+	if ((j & 0x06) == 0) {	/* IDvalid?             */
+		goto G2Q5;
+	}
+	k = mbuf[1];
+small_id:
+	m = 1;
+	m <<= k;
+	if ((m & assignid_map) == 0) {
+		goto G2Q_QUIN;
+	}
+	if (k > 0) {
+		k--;
+		goto small_id;
+	}
+G2Q5:			/* srch from max acceptable ID#  */
+	k = i;			/* max acceptable ID#            */
+G2Q_LP:
+	m = 1;
+	m <<= k;
+	if ((m & assignid_map) == 0) {
+		goto G2Q_QUIN;
+	}
+	if (k > 0) {
+		k--;
+		goto G2Q_LP;
+	}
+G2Q_QUIN:		/* k=binID#,       */
+	assignid_map |= m;
+	if (k < 8) {
+		quintet[0] = 0x38;	/* 1st dft ID<8    */
+	} else {
+		quintet[0] = 0x31;	/* 1st  ID>=8      */
+	}
+	k &= 0x07;
+	quintet[1] = g2q_tab[k];
+
+	val &= 0x00ff;		/* AssignID 1stQuintet,AH=001xxxxx  */
+	m = quintet[0] << 8;
+	val |= m;
+	fun_scam(dev, &val);
+	val &= 0x00ff;		/* AssignID 2ndQuintet,AH=001xxxxx */
+	m = quintet[1] << 8;
+	val |= m;
+	fun_scam(dev, &val);
+
+	goto TCM_SYNC;
+
+}
+
+static void is870(struct atp_unit *dev, unsigned int wkport)
+{
+	unsigned int tmport;
+	unsigned char i, j, k, rmb, n;
+	unsigned short int m;
+	static unsigned char mbuf[512];
+	static unsigned char satn[9] = { 0, 0, 0, 0, 0, 0, 0, 6, 6 };
+	static unsigned char inqd[9] = { 0x12, 0, 0, 0, 0x24, 0, 0, 0x24, 6 };
+	static unsigned char synn[6] = { 0x80, 1, 3, 1, 0x19, 0x0e };
+	static unsigned char synu[6] = { 0x80, 1, 3, 1, 0x0c, 0x0e };
+	static unsigned char synw[6] = { 0x80, 1, 3, 1, 0x0c, 0x07 };
+	static unsigned char wide[6] = { 0x80, 1, 2, 3, 1, 0 };
+	
+	tmport = wkport + 0x3a;
+	outb((unsigned char) (inb(tmport) | 0x10), tmport);
+
+	for (i = 0; i < 16; i++) {
+		if ((dev->chip_ver != 4) && (i > 7)) {
+			break;
+		}
+		m = 1;
+		m = m << i;
+		if ((m & dev->active_id[0]) != 0) {
+			continue;
+		}
+		if (i == dev->host_id[0]) {
+			printk(KERN_INFO "         ID: %2d  Host Adapter\n", dev->host_id[0]);
+			continue;
+		}
+		tmport = wkport + 0x1b;
+		if (dev->chip_ver == 4) {
+			outb(0x01, tmport);
+		} else {
+			outb(0x00, tmport);
+		}
+		tmport = wkport + 1;
+		outb(0x08, tmport++);
+		outb(0x7f, tmport++);
+		outb(satn[0], tmport++);
+		outb(satn[1], tmport++);
+		outb(satn[2], tmport++);
+		outb(satn[3], tmport++);
+		outb(satn[4], tmport++);
+		outb(satn[5], tmport++);
+		tmport += 0x06;
+		outb(0, tmport);
+		tmport += 0x02;
+		outb(dev->id[0][i].devsp, tmport++);
+		outb(0, tmport++);
+		outb(satn[6], tmport++);
+		outb(satn[7], tmport++);
+		j = i;
+		if ((j & 0x08) != 0) {
+			j = (j & 0x07) | 0x40;
+		}
+		outb(j, tmport);
+		tmport += 0x03;
+		outb(satn[8], tmport);
+		tmport += 0x07;
+
+		while ((inb(tmport) & 0x80) == 0x00)
+			cpu_relax();
+
+		tmport -= 0x08;
+		if (inb(tmport) != 0x11 && inb(tmport) != 0x8e)
+			continue;
+
+		while (inb(tmport) != 0x8e)
+			cpu_relax();
+
+		dev->active_id[0] |= m;
+
+		tmport = wkport + 0x10;
+		outb(0x30, tmport);
+		tmport = wkport + 0x04;
+		outb(0x00, tmport);
+
+phase_cmd:
+		tmport = wkport + 0x18;
+		outb(0x08, tmport);
+		tmport += 0x07;
+		while ((inb(tmport) & 0x80) == 0x00)
+			cpu_relax();
+		tmport -= 0x08;
+		j = inb(tmport);
+		if (j != 0x16) {
+			tmport = wkport + 0x10;
+			outb(0x41, tmport);
+			goto phase_cmd;
+		}
+sel_ok:
+		tmport = wkport + 3;
+		outb(inqd[0], tmport++);
+		outb(inqd[1], tmport++);
+		outb(inqd[2], tmport++);
+		outb(inqd[3], tmport++);
+		outb(inqd[4], tmport++);
+		outb(inqd[5], tmport);
+		tmport += 0x07;
+		outb(0, tmport);
+		tmport += 0x02;
+		outb(dev->id[0][i].devsp, tmport++);
+		outb(0, tmport++);
+		outb(inqd[6], tmport++);
+		outb(inqd[7], tmport++);
+		tmport += 0x03;
+		outb(inqd[8], tmport);
+		tmport += 0x07;
+
+		while ((inb(tmport) & 0x80) == 0x00)
+			cpu_relax();
+			
+		tmport -= 0x08;
+		if (inb(tmport) != 0x11 && inb(tmport) != 0x8e)
+			continue;
+
+		while (inb(tmport) != 0x8e)
+			cpu_relax();
+			
+		tmport = wkport + 0x1b;
+		if (dev->chip_ver == 4)
+			outb(0x00, tmport);
+
+		tmport = wkport + 0x18;
+		outb(0x08, tmport);
+		tmport += 0x07;
+		j = 0;
+rd_inq_data:
+		k = inb(tmport);
+		if ((k & 0x01) != 0) {
+			tmport -= 0x06;
+			mbuf[j++] = inb(tmport);
+			tmport += 0x06;
+			goto rd_inq_data;
+		}
+		if ((k & 0x80) == 0) {
+			goto rd_inq_data;
+		}
+		tmport -= 0x08;
+		j = inb(tmport);
+		if (j == 0x16) {
+			goto inq_ok;
+		}
+		tmport = wkport + 0x10;
+		outb(0x46, tmport);
+		tmport += 0x02;
+		outb(0, tmport++);
+		outb(0, tmport++);
+		outb(0, tmport++);
+		tmport += 0x03;
+		outb(0x08, tmport);
+		tmport += 0x07;
+
+		while ((inb(tmport) & 0x80) == 0x00)
+			cpu_relax();
+			
+		tmport -= 0x08;
+		if (inb(tmport) != 0x16) {
+			goto sel_ok;
+		}
+inq_ok:
+		mbuf[36] = 0;
+		printk(KERN_INFO "         ID: %2d  %s\n", i, &mbuf[8]);
+		dev->id[0][i].devtype = mbuf[0];
+		rmb = mbuf[1];
+		n = mbuf[7];
+		if (dev->chip_ver != 4) {
+			goto not_wide;
+		}
+		if ((mbuf[7] & 0x60) == 0) {
+			goto not_wide;
+		}
+		if ((dev->global_map[0] & 0x20) == 0) {
+			goto not_wide;
+		}
+		tmport = wkport + 0x1b;
+		outb(0x01, tmport);
+		tmport = wkport + 3;
+		outb(satn[0], tmport++);
+		outb(satn[1], tmport++);
+		outb(satn[2], tmport++);
+		outb(satn[3], tmport++);
+		outb(satn[4], tmport++);
+		outb(satn[5], tmport++);
+		tmport += 0x06;
+		outb(0, tmport);
+		tmport += 0x02;
+		outb(dev->id[0][i].devsp, tmport++);
+		outb(0, tmport++);
+		outb(satn[6], tmport++);
+		outb(satn[7], tmport++);
+		tmport += 0x03;
+		outb(satn[8], tmport);
+		tmport += 0x07;
+
+		while ((inb(tmport) & 0x80) == 0x00)
+			cpu_relax();
+			
+		tmport -= 0x08;
+		if (inb(tmport) != 0x11 && inb(tmport) != 0x8e)
+			continue;
+
+		while (inb(tmport) != 0x8e)
+			cpu_relax();
+			
+try_wide:
+		j = 0;
+		tmport = wkport + 0x14;
+		outb(0x05, tmport);
+		tmport += 0x04;
+		outb(0x20, tmport);
+		tmport += 0x07;
+
+		while ((inb(tmport) & 0x80) == 0) {
+			if ((inb(tmport) & 0x01) != 0) {
+				tmport -= 0x06;
+				outb(wide[j++], tmport);
+				tmport += 0x06;
+			}
+		}
+		tmport -= 0x08;
+		
+		while ((inb(tmport) & 0x80) == 0x00)
+			cpu_relax();
+			
+		j = inb(tmport) & 0x0f;
+		if (j == 0x0f) {
+			goto widep_in;
+		}
+		if (j == 0x0a) {
+			goto widep_cmd;
+		}
+		if (j == 0x0e) {
+			goto try_wide;
+		}
+		continue;
+widep_out:
+		tmport = wkport + 0x18;
+		outb(0x20, tmport);
+		tmport += 0x07;
+		while ((inb(tmport) & 0x80) == 0) {
+			if ((inb(tmport) & 0x01) != 0) {
+				tmport -= 0x06;
+				outb(0, tmport);
+				tmport += 0x06;
+			}
+		}
+		tmport -= 0x08;
+		j = inb(tmport) & 0x0f;
+		if (j == 0x0f) {
+			goto widep_in;
+		}
+		if (j == 0x0a) {
+			goto widep_cmd;
+		}
+		if (j == 0x0e) {
+			goto widep_out;
+		}
+		continue;
+widep_in:
+		tmport = wkport + 0x14;
+		outb(0xff, tmport);
+		tmport += 0x04;
+		outb(0x20, tmport);
+		tmport += 0x07;
+		k = 0;
+widep_in1:
+		j = inb(tmport);
+		if ((j & 0x01) != 0) {
+			tmport -= 0x06;
+			mbuf[k++] = inb(tmport);
+			tmport += 0x06;
+			goto widep_in1;
+		}
+		if ((j & 0x80) == 0x00) {
+			goto widep_in1;
+		}
+		tmport -= 0x08;
+		j = inb(tmport) & 0x0f;
+		if (j == 0x0f) {
+			goto widep_in;
+		}
+		if (j == 0x0a) {
+			goto widep_cmd;
+		}
+		if (j == 0x0e) {
+			goto widep_out;
+		}
+		continue;
+widep_cmd:
+		tmport = wkport + 0x10;
+		outb(0x30, tmport);
+		tmport = wkport + 0x14;
+		outb(0x00, tmport);
+		tmport += 0x04;
+		outb(0x08, tmport);
+		tmport += 0x07;
+		
+		while ((inb(tmport) & 0x80) == 0x00)
+			cpu_relax();
+
+		tmport -= 0x08;
+		j = inb(tmport);
+		if (j != 0x16) {
+			if (j == 0x4e) {
+				goto widep_out;
+			}
+			continue;
+		}
+		if (mbuf[0] != 0x01) {
+			goto not_wide;
+		}
+		if (mbuf[1] != 0x02) {
+			goto not_wide;
+		}
+		if (mbuf[2] != 0x03) {
+			goto not_wide;
+		}
+		if (mbuf[3] != 0x01) {
+			goto not_wide;
+		}
+		m = 1;
+		m = m << i;
+		dev->wide_id[0] |= m;
+not_wide:
+		if ((dev->id[0][i].devtype == 0x00) || (dev->id[0][i].devtype == 0x07) || ((dev->id[0][i].devtype == 0x05) && ((n & 0x10) != 0))) {
+			goto set_sync;
+		}
+		continue;
+set_sync:
+		tmport = wkport + 0x1b;
+		j = 0;
+		if ((m & dev->wide_id[0]) != 0) {
+			j |= 0x01;
+		}
+		outb(j, tmport);
+		tmport = wkport + 3;
+		outb(satn[0], tmport++);
+		outb(satn[1], tmport++);
+		outb(satn[2], tmport++);
+		outb(satn[3], tmport++);
+		outb(satn[4], tmport++);
+		outb(satn[5], tmport++);
+		tmport += 0x06;
+		outb(0, tmport);
+		tmport += 0x02;
+		outb(dev->id[0][i].devsp, tmport++);
+		outb(0, tmport++);
+		outb(satn[6], tmport++);
+		outb(satn[7], tmport++);
+		tmport += 0x03;
+		outb(satn[8], tmport);
+		tmport += 0x07;
+
+		while ((inb(tmport) & 0x80) == 0x00)
+			cpu_relax();
+			
+		tmport -= 0x08;
+		if (inb(tmport) != 0x11 && inb(tmport) != 0x8e)
+			continue;
+
+		while (inb(tmport) != 0x8e)
+			cpu_relax();
+			
+try_sync:
+		j = 0;
+		tmport = wkport + 0x14;
+		outb(0x06, tmport);
+		tmport += 0x04;
+		outb(0x20, tmport);
+		tmport += 0x07;
+
+		while ((inb(tmport) & 0x80) == 0) {
+			if ((inb(tmport) & 0x01) != 0) {
+				tmport -= 0x06;
+				if ((m & dev->wide_id[0]) != 0) {
+					outb(synw[j++], tmport);
+				} else {
+					if ((m & dev->ultra_map[0]) != 0) {
+						outb(synu[j++], tmport);
+					} else {
+						outb(synn[j++], tmport);
+					}
+				}
+				tmport += 0x06;
+			}
+		}
+		tmport -= 0x08;
+		
+		while ((inb(tmport) & 0x80) == 0x00)
+			cpu_relax();
+			
+		j = inb(tmport) & 0x0f;
+		if (j == 0x0f) {
+			goto phase_ins;
+		}
+		if (j == 0x0a) {
+			goto phase_cmds;
+		}
+		if (j == 0x0e) {
+			goto try_sync;
+		}
+		continue;
+phase_outs:
+		tmport = wkport + 0x18;
+		outb(0x20, tmport);
+		tmport += 0x07;
+		while ((inb(tmport) & 0x80) == 0x00) {
+			if ((inb(tmport) & 0x01) != 0x00) {
+				tmport -= 0x06;
+				outb(0x00, tmport);
+				tmport += 0x06;
+			}
+		}
+		tmport -= 0x08;
+		j = inb(tmport);
+		if (j == 0x85) {
+			goto tar_dcons;
+		}
+		j &= 0x0f;
+		if (j == 0x0f) {
+			goto phase_ins;
+		}
+		if (j == 0x0a) {
+			goto phase_cmds;
+		}
+		if (j == 0x0e) {
+			goto phase_outs;
+		}
+		continue;
+phase_ins:
+		tmport = wkport + 0x14;
+		outb(0xff, tmport);
+		tmport += 0x04;
+		outb(0x20, tmport);
+		tmport += 0x07;
+		k = 0;
+phase_ins1:
+		j = inb(tmport);
+		if ((j & 0x01) != 0x00) {
+			tmport -= 0x06;
+			mbuf[k++] = inb(tmport);
+			tmport += 0x06;
+			goto phase_ins1;
+		}
+		if ((j & 0x80) == 0x00) {
+			goto phase_ins1;
+		}
+		tmport -= 0x08;
+
+		while ((inb(tmport) & 0x80) == 0x00)
+			cpu_relax();
+			
+		j = inb(tmport);
+		if (j == 0x85) {
+			goto tar_dcons;
+		}
+		j &= 0x0f;
+		if (j == 0x0f) {
+			goto phase_ins;
+		}
+		if (j == 0x0a) {
+			goto phase_cmds;
+		}
+		if (j == 0x0e) {
+			goto phase_outs;
+		}
+		continue;
+phase_cmds:
+		tmport = wkport + 0x10;
+		outb(0x30, tmport);
+tar_dcons:
+		tmport = wkport + 0x14;
+		outb(0x00, tmport);
+		tmport += 0x04;
+		outb(0x08, tmport);
+		tmport += 0x07;
+		
+		while ((inb(tmport) & 0x80) == 0x00)
+			cpu_relax();
+			
+		tmport -= 0x08;
+		j = inb(tmport);
+		if (j != 0x16) {
+			continue;
+		}
+		if (mbuf[0] != 0x01) {
+			continue;
+		}
+		if (mbuf[1] != 0x03) {
+			continue;
+		}
+		if (mbuf[4] == 0x00) {
+			continue;
+		}
+		if (mbuf[3] > 0x64) {
+			continue;
+		}
+		if (mbuf[4] > 0x0c) {
+			mbuf[4] = 0x0c;
+		}
+		dev->id[0][i].devsp = mbuf[4];
+		if ((mbuf[3] < 0x0d) && (rmb == 0)) {
+			j = 0xa0;
+			goto set_syn_ok;
+		}
+		if (mbuf[3] < 0x1a) {
+			j = 0x20;
+			goto set_syn_ok;
+		}
+		if (mbuf[3] < 0x33) {
+			j = 0x40;
+			goto set_syn_ok;
+		}
+		if (mbuf[3] < 0x4c) {
+			j = 0x50;
+			goto set_syn_ok;
+		}
+		j = 0x60;
+set_syn_ok:
+		dev->id[0][i].devsp = (dev->id[0][i].devsp & 0x0f) | j;
+	}
+	tmport = wkport + 0x3a;
+	outb((unsigned char) (inb(tmport) & 0xef), tmport);
+}
+
+static void is880(struct atp_unit *dev, unsigned int wkport)
+{
+	unsigned int tmport;
+	unsigned char i, j, k, rmb, n, lvdmode;
+	unsigned short int m;
+	static unsigned char mbuf[512];
+	static unsigned char satn[9] = { 0, 0, 0, 0, 0, 0, 0, 6, 6 };
+	static unsigned char inqd[9] = { 0x12, 0, 0, 0, 0x24, 0, 0, 0x24, 6 };
+	static unsigned char synn[6] = { 0x80, 1, 3, 1, 0x19, 0x0e };
+	unsigned char synu[6] = { 0x80, 1, 3, 1, 0x0a, 0x0e };
+	static unsigned char synw[6] = { 0x80, 1, 3, 1, 0x19, 0x0e };
+	unsigned char synuw[6] = { 0x80, 1, 3, 1, 0x0a, 0x0e };
+	static unsigned char wide[6] = { 0x80, 1, 2, 3, 1, 0 };
+	static unsigned char u3[9] = { 0x80, 1, 6, 4, 0x09, 00, 0x0e, 0x01, 0x02 };
+
+	lvdmode = inb(wkport + 0x3f) & 0x40;
+
+	for (i = 0; i < 16; i++) {
+		m = 1;
+		m = m << i;
+		if ((m & dev->active_id[0]) != 0) {
+			continue;
+		}
+		if (i == dev->host_id[0]) {
+			printk(KERN_INFO "         ID: %2d  Host Adapter\n", dev->host_id[0]);
+			continue;
+		}
+		tmport = wkport + 0x5b;
+		outb(0x01, tmport);
+		tmport = wkport + 0x41;
+		outb(0x08, tmport++);
+		outb(0x7f, tmport++);
+		outb(satn[0], tmport++);
+		outb(satn[1], tmport++);
+		outb(satn[2], tmport++);
+		outb(satn[3], tmport++);
+		outb(satn[4], tmport++);
+		outb(satn[5], tmport++);
+		tmport += 0x06;
+		outb(0, tmport);
+		tmport += 0x02;
+		outb(dev->id[0][i].devsp, tmport++);
+		outb(0, tmport++);
+		outb(satn[6], tmport++);
+		outb(satn[7], tmport++);
+		j = i;
+		if ((j & 0x08) != 0) {
+			j = (j & 0x07) | 0x40;
+		}
+		outb(j, tmport);
+		tmport += 0x03;
+		outb(satn[8], tmport);
+		tmport += 0x07;
+
+		while ((inb(tmport) & 0x80) == 0x00)
+			cpu_relax();
+
+		tmport -= 0x08;
+		if (inb(tmport) != 0x11 && inb(tmport) != 0x8e)
+			continue;
+
+		while (inb(tmport) != 0x8e)
+			cpu_relax();
+			
+		dev->active_id[0] |= m;
+
+		tmport = wkport + 0x50;
+		outb(0x30, tmport);
+		tmport = wkport + 0x54;
+		outb(0x00, tmport);
+
+phase_cmd:
+		tmport = wkport + 0x58;
+		outb(0x08, tmport);
+		tmport += 0x07;
+		
+		while ((inb(tmport) & 0x80) == 0x00)
+			cpu_relax();
+
+		tmport -= 0x08;
+		j = inb(tmport);
+		if (j != 0x16) {
+			tmport = wkport + 0x50;
+			outb(0x41, tmport);
+			goto phase_cmd;
+		}
+sel_ok:
+		tmport = wkport + 0x43;
+		outb(inqd[0], tmport++);
+		outb(inqd[1], tmport++);
+		outb(inqd[2], tmport++);
+		outb(inqd[3], tmport++);
+		outb(inqd[4], tmport++);
+		outb(inqd[5], tmport);
+		tmport += 0x07;
+		outb(0, tmport);
+		tmport += 0x02;
+		outb(dev->id[0][i].devsp, tmport++);
+		outb(0, tmport++);
+		outb(inqd[6], tmport++);
+		outb(inqd[7], tmport++);
+		tmport += 0x03;
+		outb(inqd[8], tmport);
+		tmport += 0x07;
+		
+		while ((inb(tmport) & 0x80) == 0x00)
+			cpu_relax();
+			
+		tmport -= 0x08;
+		if (inb(tmport) != 0x11 && inb(tmport) != 0x8e)
+			continue;
+
+		while (inb(tmport) != 0x8e)
+			cpu_relax();
+			
+		tmport = wkport + 0x5b;
+		outb(0x00, tmport);
+		tmport = wkport + 0x58;
+		outb(0x08, tmport);
+		tmport += 0x07;
+		j = 0;
+rd_inq_data:
+		k = inb(tmport);
+		if ((k & 0x01) != 0) {
+			tmport -= 0x06;
+			mbuf[j++] = inb(tmport);
+			tmport += 0x06;
+			goto rd_inq_data;
+		}
+		if ((k & 0x80) == 0) {
+			goto rd_inq_data;
+		}
+		tmport -= 0x08;
+		j = inb(tmport);
+		if (j == 0x16) {
+			goto inq_ok;
+		}
+		tmport = wkport + 0x50;
+		outb(0x46, tmport);
+		tmport += 0x02;
+		outb(0, tmport++);
+		outb(0, tmport++);
+		outb(0, tmport++);
+		tmport += 0x03;
+		outb(0x08, tmport);
+		tmport += 0x07;
+		while ((inb(tmport) & 0x80) == 0x00)
+			cpu_relax();
+			
+		tmport -= 0x08;
+		if (inb(tmport) != 0x16)
+			goto sel_ok;
+
+inq_ok:
+		mbuf[36] = 0;
+		printk(KERN_INFO "         ID: %2d  %s\n", i, &mbuf[8]);
+		dev->id[0][i].devtype = mbuf[0];
+		rmb = mbuf[1];
+		n = mbuf[7];
+		if ((mbuf[7] & 0x60) == 0) {
+			goto not_wide;
+		}
+		if ((i < 8) && ((dev->global_map[0] & 0x20) == 0)) {
+			goto not_wide;
+		}
+		if (lvdmode == 0) {
+			goto chg_wide;
+		}
+		if (dev->sp[0][i] != 0x04)	// force u2
+		{
+			goto chg_wide;
+		}
+
+		tmport = wkport + 0x5b;
+		outb(0x01, tmport);
+		tmport = wkport + 0x43;
+		outb(satn[0], tmport++);
+		outb(satn[1], tmport++);
+		outb(satn[2], tmport++);
+		outb(satn[3], tmport++);
+		outb(satn[4], tmport++);
+		outb(satn[5], tmport++);
+		tmport += 0x06;
+		outb(0, tmport);
+		tmport += 0x02;
+		outb(dev->id[0][i].devsp, tmport++);
+		outb(0, tmport++);
+		outb(satn[6], tmport++);
+		outb(satn[7], tmport++);
+		tmport += 0x03;
+		outb(satn[8], tmport);
+		tmport += 0x07;
+
+		while ((inb(tmport) & 0x80) == 0x00)
+			cpu_relax();
+
+		tmport -= 0x08;
+
+		if (inb(tmport) != 0x11 && inb(tmport) != 0x8e)
+			continue;
+
+		while (inb(tmport) != 0x8e)
+			cpu_relax();
+
+try_u3:
+		j = 0;
+		tmport = wkport + 0x54;
+		outb(0x09, tmport);
+		tmport += 0x04;
+		outb(0x20, tmport);
+		tmport += 0x07;
+
+		while ((inb(tmport) & 0x80) == 0) {
+			if ((inb(tmport) & 0x01) != 0) {
+				tmport -= 0x06;
+				outb(u3[j++], tmport);
+				tmport += 0x06;
+			}
+		}
+		tmport -= 0x08;
+
+		while ((inb(tmport) & 0x80) == 0x00)
+			cpu_relax();
+			
+		j = inb(tmport) & 0x0f;
+		if (j == 0x0f) {
+			goto u3p_in;
+		}
+		if (j == 0x0a) {
+			goto u3p_cmd;
+		}
+		if (j == 0x0e) {
+			goto try_u3;
+		}
+		continue;
+u3p_out:
+		tmport = wkport + 0x58;
+		outb(0x20, tmport);
+		tmport += 0x07;
+		while ((inb(tmport) & 0x80) == 0) {
+			if ((inb(tmport) & 0x01) != 0) {
+				tmport -= 0x06;
+				outb(0, tmport);
+				tmport += 0x06;
+			}
+		}
+		tmport -= 0x08;
+		j = inb(tmport) & 0x0f;
+		if (j == 0x0f) {
+			goto u3p_in;
+		}
+		if (j == 0x0a) {
+			goto u3p_cmd;
+		}
+		if (j == 0x0e) {
+			goto u3p_out;
+		}
+		continue;
+u3p_in:
+		tmport = wkport + 0x54;
+		outb(0x09, tmport);
+		tmport += 0x04;
+		outb(0x20, tmport);
+		tmport += 0x07;
+		k = 0;
+u3p_in1:
+		j = inb(tmport);
+		if ((j & 0x01) != 0) {
+			tmport -= 0x06;
+			mbuf[k++] = inb(tmport);
+			tmport += 0x06;
+			goto u3p_in1;
+		}
+		if ((j & 0x80) == 0x00) {
+			goto u3p_in1;
+		}
+		tmport -= 0x08;
+		j = inb(tmport) & 0x0f;
+		if (j == 0x0f) {
+			goto u3p_in;
+		}
+		if (j == 0x0a) {
+			goto u3p_cmd;
+		}
+		if (j == 0x0e) {
+			goto u3p_out;
+		}
+		continue;
+u3p_cmd:
+		tmport = wkport + 0x50;
+		outb(0x30, tmport);
+		tmport = wkport + 0x54;
+		outb(0x00, tmport);
+		tmport += 0x04;
+		outb(0x08, tmport);
+		tmport += 0x07;
+		
+		while ((inb(tmport) & 0x80) == 0x00)
+			cpu_relax();
+			
+		tmport -= 0x08;
+		j = inb(tmport);
+		if (j != 0x16) {
+			if (j == 0x4e) {
+				goto u3p_out;
+			}
+			continue;
+		}
+		if (mbuf[0] != 0x01) {
+			goto chg_wide;
+		}
+		if (mbuf[1] != 0x06) {
+			goto chg_wide;
+		}
+		if (mbuf[2] != 0x04) {
+			goto chg_wide;
+		}
+		if (mbuf[3] == 0x09) {
+			m = 1;
+			m = m << i;
+			dev->wide_id[0] |= m;
+			dev->id[0][i].devsp = 0xce;
+			continue;
+		}
+chg_wide:
+		tmport = wkport + 0x5b;
+		outb(0x01, tmport);
+		tmport = wkport + 0x43;
+		outb(satn[0], tmport++);
+		outb(satn[1], tmport++);
+		outb(satn[2], tmport++);
+		outb(satn[3], tmport++);
+		outb(satn[4], tmport++);
+		outb(satn[5], tmport++);
+		tmport += 0x06;
+		outb(0, tmport);
+		tmport += 0x02;
+		outb(dev->id[0][i].devsp, tmport++);
+		outb(0, tmport++);
+		outb(satn[6], tmport++);
+		outb(satn[7], tmport++);
+		tmport += 0x03;
+		outb(satn[8], tmport);
+		tmport += 0x07;
+
+		while ((inb(tmport) & 0x80) == 0x00)
+			cpu_relax();
+			
+		tmport -= 0x08;
+		if (inb(tmport) != 0x11 && inb(tmport) != 0x8e)
+			continue;
+
+		while (inb(tmport) != 0x8e)
+			cpu_relax();
+			
+try_wide:
+		j = 0;
+		tmport = wkport + 0x54;
+		outb(0x05, tmport);
+		tmport += 0x04;
+		outb(0x20, tmport);
+		tmport += 0x07;
+
+		while ((inb(tmport) & 0x80) == 0) {
+			if ((inb(tmport) & 0x01) != 0) {
+				tmport -= 0x06;
+				outb(wide[j++], tmport);
+				tmport += 0x06;
+			}
+		}
+		tmport -= 0x08;
+		while ((inb(tmport) & 0x80) == 0x00)
+			cpu_relax();
+			
+		j = inb(tmport) & 0x0f;
+		if (j == 0x0f) {
+			goto widep_in;
+		}
+		if (j == 0x0a) {
+			goto widep_cmd;
+		}
+		if (j == 0x0e) {
+			goto try_wide;
+		}
+		continue;
+widep_out:
+		tmport = wkport + 0x58;
+		outb(0x20, tmport);
+		tmport += 0x07;
+		while ((inb(tmport) & 0x80) == 0) {
+			if ((inb(tmport) & 0x01) != 0) {
+				tmport -= 0x06;
+				outb(0, tmport);
+				tmport += 0x06;
+			}
+		}
+		tmport -= 0x08;
+		j = inb(tmport) & 0x0f;
+		if (j == 0x0f) {
+			goto widep_in;
+		}
+		if (j == 0x0a) {
+			goto widep_cmd;
+		}
+		if (j == 0x0e) {
+			goto widep_out;
+		}
+		continue;
+widep_in:
+		tmport = wkport + 0x54;
+		outb(0xff, tmport);
+		tmport += 0x04;
+		outb(0x20, tmport);
+		tmport += 0x07;
+		k = 0;
+widep_in1:
+		j = inb(tmport);
+		if ((j & 0x01) != 0) {
+			tmport -= 0x06;
+			mbuf[k++] = inb(tmport);
+			tmport += 0x06;
+			goto widep_in1;
+		}
+		if ((j & 0x80) == 0x00) {
+			goto widep_in1;
+		}
+		tmport -= 0x08;
+		j = inb(tmport) & 0x0f;
+		if (j == 0x0f) {
+			goto widep_in;
+		}
+		if (j == 0x0a) {
+			goto widep_cmd;
+		}
+		if (j == 0x0e) {
+			goto widep_out;
+		}
+		continue;
+widep_cmd:
+		tmport = wkport + 0x50;
+		outb(0x30, tmport);
+		tmport = wkport + 0x54;
+		outb(0x00, tmport);
+		tmport += 0x04;
+		outb(0x08, tmport);
+		tmport += 0x07;
+
+		while ((inb(tmport) & 0x80) == 0x00)
+			cpu_relax();
+
+		tmport -= 0x08;
+		j = inb(tmport);
+		if (j != 0x16) {
+			if (j == 0x4e) {
+				goto widep_out;
+			}
+			continue;
+		}
+		if (mbuf[0] != 0x01) {
+			goto not_wide;
+		}
+		if (mbuf[1] != 0x02) {
+			goto not_wide;
+		}
+		if (mbuf[2] != 0x03) {
+			goto not_wide;
+		}
+		if (mbuf[3] != 0x01) {
+			goto not_wide;
+		}
+		m = 1;
+		m = m << i;
+		dev->wide_id[0] |= m;
+not_wide:
+		if ((dev->id[0][i].devtype == 0x00) || (dev->id[0][i].devtype == 0x07) || ((dev->id[0][i].devtype == 0x05) && ((n & 0x10) != 0))) {
+			m = 1;
+			m = m << i;
+			if ((dev->async[0] & m) != 0) {
+				goto set_sync;
+			}
+		}
+		continue;
+set_sync:
+		if (dev->sp[0][i] == 0x02) {
+			synu[4] = 0x0c;
+			synuw[4] = 0x0c;
+		} else {
+			if (dev->sp[0][i] >= 0x03) {
+				synu[4] = 0x0a;
+				synuw[4] = 0x0a;
+			}
+		}
+		tmport = wkport + 0x5b;
+		j = 0;
+		if ((m & dev->wide_id[0]) != 0) {
+			j |= 0x01;
+		}
+		outb(j, tmport);
+		tmport = wkport + 0x43;
+		outb(satn[0], tmport++);
+		outb(satn[1], tmport++);
+		outb(satn[2], tmport++);
+		outb(satn[3], tmport++);
+		outb(satn[4], tmport++);
+		outb(satn[5], tmport++);
+		tmport += 0x06;
+		outb(0, tmport);
+		tmport += 0x02;
+		outb(dev->id[0][i].devsp, tmport++);
+		outb(0, tmport++);
+		outb(satn[6], tmport++);
+		outb(satn[7], tmport++);
+		tmport += 0x03;
+		outb(satn[8], tmport);
+		tmport += 0x07;
+
+		while ((inb(tmport) & 0x80) == 0x00)
+			cpu_relax();
+
+		tmport -= 0x08;
+		if ((inb(tmport) != 0x11) && (inb(tmport) != 0x8e)) {
+			continue;
+		}
+		while (inb(tmport) != 0x8e)
+			cpu_relax();
+
+try_sync:
+		j = 0;
+		tmport = wkport + 0x54;
+		outb(0x06, tmport);
+		tmport += 0x04;
+		outb(0x20, tmport);
+		tmport += 0x07;
+
+		while ((inb(tmport) & 0x80) == 0) {
+			if ((inb(tmport) & 0x01) != 0) {
+				tmport -= 0x06;
+				if ((m & dev->wide_id[0]) != 0) {
+					if ((m & dev->ultra_map[0]) != 0) {
+						outb(synuw[j++], tmport);
+					} else {
+						outb(synw[j++], tmport);
+					}
+				} else {
+					if ((m & dev->ultra_map[0]) != 0) {
+						outb(synu[j++], tmport);
+					} else {
+						outb(synn[j++], tmport);
+					}
+				}
+				tmport += 0x06;
+			}
+		}
+		tmport -= 0x08;
+
+		while ((inb(tmport) & 0x80) == 0x00)
+			cpu_relax();
+
+		j = inb(tmport) & 0x0f;
+		if (j == 0x0f) {
+			goto phase_ins;
+		}
+		if (j == 0x0a) {
+			goto phase_cmds;
+		}
+		if (j == 0x0e) {
+			goto try_sync;
+		}
+		continue;
+phase_outs:
+		tmport = wkport + 0x58;
+		outb(0x20, tmport);
+		tmport += 0x07;
+		while ((inb(tmport) & 0x80) == 0x00) {
+			if ((inb(tmport) & 0x01) != 0x00) {
+				tmport -= 0x06;
+				outb(0x00, tmport);
+				tmport += 0x06;
+			}
+		}
+		tmport -= 0x08;
+		j = inb(tmport);
+		if (j == 0x85) {
+			goto tar_dcons;
+		}
+		j &= 0x0f;
+		if (j == 0x0f) {
+			goto phase_ins;
+		}
+		if (j == 0x0a) {
+			goto phase_cmds;
+		}
+		if (j == 0x0e) {
+			goto phase_outs;
+		}
+		continue;
+phase_ins:
+		tmport = wkport + 0x54;
+		outb(0x06, tmport);
+		tmport += 0x04;
+		outb(0x20, tmport);
+		tmport += 0x07;
+		k = 0;
+phase_ins1:
+		j = inb(tmport);
+		if ((j & 0x01) != 0x00) {
+			tmport -= 0x06;
+			mbuf[k++] = inb(tmport);
+			tmport += 0x06;
+			goto phase_ins1;
+		}
+		if ((j & 0x80) == 0x00) {
+			goto phase_ins1;
+		}
+		tmport -= 0x08;
+
+		while ((inb(tmport) & 0x80) == 0x00)
+			cpu_relax();
+
+		j = inb(tmport);
+		if (j == 0x85) {
+			goto tar_dcons;
+		}
+		j &= 0x0f;
+		if (j == 0x0f) {
+			goto phase_ins;
+		}
+		if (j == 0x0a) {
+			goto phase_cmds;
+		}
+		if (j == 0x0e) {
+			goto phase_outs;
+		}
+		continue;
+phase_cmds:
+		tmport = wkport + 0x50;
+		outb(0x30, tmport);
+tar_dcons:
+		tmport = wkport + 0x54;
+		outb(0x00, tmport);
+		tmport += 0x04;
+		outb(0x08, tmport);
+		tmport += 0x07;
+
+		while ((inb(tmport) & 0x80) == 0x00)
+			cpu_relax();
+
+		tmport -= 0x08;
+		j = inb(tmport);
+		if (j != 0x16) {
+			continue;
+		}
+		if (mbuf[0] != 0x01) {
+			continue;
+		}
+		if (mbuf[1] != 0x03) {
+			continue;
+		}
+		if (mbuf[4] == 0x00) {
+			continue;
+		}
+		if (mbuf[3] > 0x64) {
+			continue;
+		}
+		if (mbuf[4] > 0x0e) {
+			mbuf[4] = 0x0e;
+		}
+		dev->id[0][i].devsp = mbuf[4];
+		if (mbuf[3] < 0x0c) {
+			j = 0xb0;
+			goto set_syn_ok;
+		}
+		if ((mbuf[3] < 0x0d) && (rmb == 0)) {
+			j = 0xa0;
+			goto set_syn_ok;
+		}
+		if (mbuf[3] < 0x1a) {
+			j = 0x20;
+			goto set_syn_ok;
+		}
+		if (mbuf[3] < 0x33) {
+			j = 0x40;
+			goto set_syn_ok;
+		}
+		if (mbuf[3] < 0x4c) {
+			j = 0x50;
+			goto set_syn_ok;
+		}
+		j = 0x60;
+set_syn_ok:
+		dev->id[0][i].devsp = (dev->id[0][i].devsp & 0x0f) | j;
+	}
+}
+
+static void atp870u_free_tables(struct Scsi_Host *host)
+{
+	struct atp_unit *atp_dev = (struct atp_unit *)&host->hostdata;
+	int j, k;
+	for (j=0; j < 2; j++) {
+		for (k = 0; k < 16; k++) {
+			if (!atp_dev->id[j][k].prd_table)
+				continue;
+			pci_free_consistent(atp_dev->pdev, 1024, atp_dev->id[j][k].prd_table, atp_dev->id[j][k].prdaddr);
+			atp_dev->id[j][k].prd_table = NULL;
+		}
+	}
+}
+
+static int atp870u_init_tables(struct Scsi_Host *host)
+{
+	struct atp_unit *atp_dev = (struct atp_unit *)&host->hostdata;
+	int c,k;
+	for(c=0;c < 2;c++) {
+	   	for(k=0;k<16;k++) {
+	   			atp_dev->id[c][k].prd_table = pci_alloc_consistent(atp_dev->pdev, 1024, &(atp_dev->id[c][k].prdaddr));
+	   			if (!atp_dev->id[c][k].prd_table) {
+	   				printk("atp870u_init_tables fail\n");
+				atp870u_free_tables(host);
+				return -ENOMEM;
+			}
+			atp_dev->id[c][k].devsp=0x20;
+			atp_dev->id[c][k].devtype = 0x7f;
+			atp_dev->id[c][k].curr_req = NULL;			   
+	   	}
+	   			
+	   	atp_dev->active_id[c] = 0;
+	   	atp_dev->wide_id[c] = 0;
+	   	atp_dev->host_id[c] = 0x07;
+	   	atp_dev->quhd[c] = 0;
+	   	atp_dev->quend[c] = 0;
+	   	atp_dev->last_cmd[c] = 0xff;
+	   	atp_dev->in_snd[c] = 0;
+	   	atp_dev->in_int[c] = 0;
+	   	
+	   	for (k = 0; k < qcnt; k++) {
+	   		  atp_dev->quereq[c][k] = NULL;
+	   	}	   		   
+	   	for (k = 0; k < 16; k++) {
+			   atp_dev->id[c][k].curr_req = NULL;
+			   atp_dev->sp[c][k] = 0x04;
+	   	}		   
+	}
+	return 0;
+}
+
+/* return non-zero on detection */
+static int atp870u_probe(struct pci_dev *pdev, const struct pci_device_id *ent)
+{
+	unsigned char k, m, c;
+	unsigned long flags;
+	unsigned int base_io, tmport, error,n;
+	unsigned char host_id;
+	struct Scsi_Host *shpnt = NULL;
+	struct atp_unit atp_dev, *p;
+	unsigned char setupdata[2][16];
+	int count = 0;
+	
+	if (pci_enable_device(pdev))
+		return -EIO;
+
+        if (!pci_set_dma_mask(pdev, 0xFFFFFFFFUL)) {
+                printk(KERN_INFO "atp870u: use 32bit DMA mask.\n");
+        } else {
+                printk(KERN_ERR "atp870u: DMA mask required but not available.\n");
+                return -EIO;
+        }
+
+	memset(&atp_dev, 0, sizeof atp_dev);
+	/*
+	 * It's probably easier to weed out some revisions like
+	 * this than via the PCI device table
+	 */
+	if (ent->device == PCI_DEVICE_ID_ARTOP_AEC7610) {
+		error = pci_read_config_byte(pdev, PCI_CLASS_REVISION, &atp_dev.chip_ver);
+		if (atp_dev.chip_ver < 2)
+			return -EIO;
+	}
+
+	switch (ent->device) {
+	case PCI_DEVICE_ID_ARTOP_AEC7612UW:
+	case PCI_DEVICE_ID_ARTOP_AEC7612SUW:
+	case ATP880_DEVID1:	
+	case ATP880_DEVID2:	
+	case ATP885_DEVID:	
+		atp_dev.chip_ver = 0x04;
+	default:
+		break;
+	}
+	base_io = pci_resource_start(pdev, 0);
+	base_io &= 0xfffffff8;
+	
+	if ((ent->device == ATP880_DEVID1)||(ent->device == ATP880_DEVID2)) {
+		error = pci_read_config_byte(pdev, PCI_CLASS_REVISION, &atp_dev.chip_ver);
+		pci_write_config_byte(pdev, PCI_LATENCY_TIMER, 0x80);//JCC082803
+
+		host_id = inb(base_io + 0x39);
+		host_id >>= 0x04;
+
+		printk(KERN_INFO "   ACARD AEC-67160 PCI Ultra3 LVD Host Adapter: %d"
+			"    IO:%x, IRQ:%d.\n", count, base_io, pdev->irq);
+		atp_dev.ioport[0] = base_io + 0x40;
+		atp_dev.pciport[0] = base_io + 0x28;
+		atp_dev.dev_id = ent->device;
+		atp_dev.host_id[0] = host_id;
+
+		tmport = base_io + 0x22;
+		atp_dev.scam_on = inb(tmport);
+		tmport += 0x13;
+		atp_dev.global_map[0] = inb(tmport);
+		tmport += 0x07;
+		atp_dev.ultra_map[0] = inw(tmport);
+
+		n = 0x3f09;
+next_fblk_880:
+		if (n >= 0x4000)
+			goto flash_ok_880;
+
+		m = 0;
+		outw(n, base_io + 0x34);
+		n += 0x0002;
+		if (inb(base_io + 0x30) == 0xff)
+			goto flash_ok_880;
+
+		atp_dev.sp[0][m++] = inb(base_io + 0x30);
+		atp_dev.sp[0][m++] = inb(base_io + 0x31);
+		atp_dev.sp[0][m++] = inb(base_io + 0x32);
+		atp_dev.sp[0][m++] = inb(base_io + 0x33);
+		outw(n, base_io + 0x34);
+		n += 0x0002;
+		atp_dev.sp[0][m++] = inb(base_io + 0x30);
+		atp_dev.sp[0][m++] = inb(base_io + 0x31);
+		atp_dev.sp[0][m++] = inb(base_io + 0x32);
+		atp_dev.sp[0][m++] = inb(base_io + 0x33);
+		outw(n, base_io + 0x34);
+		n += 0x0002;
+		atp_dev.sp[0][m++] = inb(base_io + 0x30);
+		atp_dev.sp[0][m++] = inb(base_io + 0x31);
+		atp_dev.sp[0][m++] = inb(base_io + 0x32);
+		atp_dev.sp[0][m++] = inb(base_io + 0x33);
+		outw(n, base_io + 0x34);
+		n += 0x0002;
+		atp_dev.sp[0][m++] = inb(base_io + 0x30);
+		atp_dev.sp[0][m++] = inb(base_io + 0x31);
+		atp_dev.sp[0][m++] = inb(base_io + 0x32);
+		atp_dev.sp[0][m++] = inb(base_io + 0x33);
+		n += 0x0018;
+		goto next_fblk_880;
+flash_ok_880:
+		outw(0, base_io + 0x34);
+		atp_dev.ultra_map[0] = 0;
+		atp_dev.async[0] = 0;
+		for (k = 0; k < 16; k++) {
+			n = 1;
+			n = n << k;
+			if (atp_dev.sp[0][k] > 1) {
+				atp_dev.ultra_map[0] |= n;
+			} else {
+				if (atp_dev.sp[0][k] == 0)
+					atp_dev.async[0] |= n;
+ 			}
+	 	}
+		atp_dev.async[0] = ~(atp_dev.async[0]);
+		outb(atp_dev.global_map[0], base_io + 0x35);
+ 
+		shpnt = scsi_host_alloc(&atp870u_template, sizeof(struct atp_unit));
+		if (!shpnt)
+			return -ENOMEM;
+
+		p = (struct atp_unit *)&shpnt->hostdata;
+
+		atp_dev.host = shpnt;
+		atp_dev.pdev = pdev;
+		pci_set_drvdata(pdev, p);
+		memcpy(p, &atp_dev, sizeof atp_dev);
+		if (atp870u_init_tables(shpnt) < 0) {
+			printk(KERN_ERR "Unable to allocate tables for Acard controller\n");
+			goto unregister;
+		}
+
+		if (request_irq(pdev->irq, atp870u_intr_handle, SA_SHIRQ, "atp880i", shpnt)) {
+ 			printk(KERN_ERR "Unable to allocate IRQ%d for Acard controller.\n", pdev->irq);
+			goto free_tables;
+		}
+
+		spin_lock_irqsave(shpnt->host_lock, flags);
+		tmport = base_io + 0x38;
+		k = inb(tmport) & 0x80;
+		outb(k, tmport);
+		tmport += 0x03;
+		outb(0x20, tmport);
+		mdelay(32);
+		outb(0, tmport);
+		mdelay(32);
+		tmport = base_io + 0x5b;
+		inb(tmport);
+		tmport -= 0x04;
+		inb(tmport);
+		tmport = base_io + 0x40;
+		outb((host_id | 0x08), tmport);
+		tmport += 0x18;
+		outb(0, tmport);
+		tmport += 0x07;
+		while ((inb(tmport) & 0x80) == 0)
+			mdelay(1);
+		tmport -= 0x08;
+		inb(tmport);
+		tmport = base_io + 0x41;
+		outb(8, tmport++);
+		outb(0x7f, tmport);
+		tmport = base_io + 0x51;
+		outb(0x20, tmport);
+
+		tscam(shpnt);
+		is880(p, base_io);
+		tmport = base_io + 0x38;
+		outb(0xb0, tmport);
+		shpnt->max_id = 16;
+		shpnt->this_id = host_id;
+		shpnt->unique_id = base_io;
+		shpnt->io_port = base_io;
+		shpnt->n_io_port = 0x60;	/* Number of bytes of I/O space used */
+		shpnt->irq = pdev->irq;			
+	} else if (ent->device == ATP885_DEVID) {	
+			printk(KERN_INFO "   ACARD AEC-67162 PCI Ultra3 LVD Host Adapter:  IO:%x, IRQ:%d.\n"
+			       , base_io, pdev->irq);
+        	
+		atp_dev.pdev = pdev;	
+		atp_dev.dev_id  = ent->device;
+		atp_dev.baseport = base_io;
+		atp_dev.ioport[0] = base_io + 0x80;
+		atp_dev.ioport[1] = base_io + 0xc0;
+		atp_dev.pciport[0] = base_io + 0x40;
+		atp_dev.pciport[1] = base_io + 0x50;
+				
+		shpnt = scsi_host_alloc(&atp870u_template, sizeof(struct atp_unit));
+		if (!shpnt)
+			return -ENOMEM;
+        	
+		p = (struct atp_unit *)&shpnt->hostdata;
+        	
+		atp_dev.host = shpnt;
+		atp_dev.pdev = pdev;
+		pci_set_drvdata(pdev, p);
+		memcpy(p, &atp_dev, sizeof(struct atp_unit));
+		if (atp870u_init_tables(shpnt) < 0)
+			goto unregister;
+			
+#ifdef ED_DBGP		
+	printk("request_irq() shpnt %p hostdata %p\n", shpnt, p);
+#endif	        
+		if (request_irq(pdev->irq, atp870u_intr_handle, SA_SHIRQ, "atp870u", shpnt)) {
+				printk(KERN_ERR "Unable to allocate IRQ for Acard controller.\n");
+			goto free_tables;
+		}
+		
+		spin_lock_irqsave(shpnt->host_lock, flags);        					
+        			
+		c=inb(base_io + 0x29);
+		outb((c | 0x04),base_io + 0x29);
+        	
+		n=0x1f80;
+next_fblk_885:
+		if (n >= 0x2000) {
+		   goto flash_ok_885;
+		}
+		outw(n,base_io + 0x3c);
+		if (inl(base_io + 0x38) == 0xffffffff) {
+		   goto flash_ok_885;
+		}
+		for (m=0; m < 2; m++) {
+		    p->global_map[m]= 0;
+		    for (k=0; k < 4; k++) {
+			outw(n++,base_io + 0x3c);
+			((unsigned long *)&setupdata[m][0])[k]=inl(base_io + 0x38);
+		    }
+		    for (k=0; k < 4; k++) {
+			outw(n++,base_io + 0x3c);
+			((unsigned long *)&p->sp[m][0])[k]=inl(base_io + 0x38);
+		    }
+		    n += 8;
+		}
+		goto next_fblk_885;
+flash_ok_885:
+#ifdef ED_DBGP
+		printk( "Flash Read OK\n");
+#endif	
+		c=inb(base_io + 0x29);
+		outb((c & 0xfb),base_io + 0x29);
+		for (c=0;c < 2;c++) {
+		    p->ultra_map[c]=0;
+		    p->async[c] = 0;
+		    for (k=0; k < 16; k++) {
+			n=1;
+			n = n << k;
+			if (p->sp[c][k] > 1) {
+			   p->ultra_map[c] |= n;
+			} else {
+			   if (p->sp[c][k] == 0) {
+			      p->async[c] |= n;
+			   }
+			}
+		    }
+		    p->async[c] = ~(p->async[c]);
+
+		    if (p->global_map[c] == 0) {
+		       k=setupdata[c][1];
+		       if ((k & 0x40) != 0)
+			  p->global_map[c] |= 0x20;
+		       k &= 0x07;
+		       p->global_map[c] |= k;
+		       if ((setupdata[c][2] & 0x04) != 0)
+			  p->global_map[c] |= 0x08;
+		       p->host_id[c] = setupdata[c][0] & 0x07;
+		    }
+		}
+
+		k = inb(base_io + 0x28) & 0x8f;
+		k |= 0x10;
+		outb(k, base_io + 0x28);
+		outb(0x80, base_io + 0x41);
+		outb(0x80, base_io + 0x51);
+		mdelay(100);
+		outb(0, base_io + 0x41);
+		outb(0, base_io + 0x51);
+		mdelay(1000);
+		inb(base_io + 0x9b);
+		inb(base_io + 0x97);
+		inb(base_io + 0xdb);
+		inb(base_io + 0xd7);
+		tmport = base_io + 0x80;
+		k=p->host_id[0];
+		if (k > 7)
+		   k = (k & 0x07) | 0x40;
+		k |= 0x08;
+		outb(k, tmport);
+		tmport += 0x18;
+		outb(0, tmport);
+		tmport += 0x07;
+
+		while ((inb(tmport) & 0x80) == 0)
+			cpu_relax();
+	
+		tmport -= 0x08;
+		inb(tmport);
+		tmport = base_io + 0x81;
+		outb(8, tmport++);
+		outb(0x7f, tmport);
+		tmport = base_io + 0x91;
+		outb(0x20, tmport);
+
+		tmport = base_io + 0xc0;
+		k=p->host_id[1];
+		if (k > 7)
+		   k = (k & 0x07) | 0x40;
+		k |= 0x08;
+		outb(k, tmport);
+		tmport += 0x18;
+		outb(0, tmport);
+		tmport += 0x07;
+
+		while ((inb(tmport) & 0x80) == 0)
+			cpu_relax();
+
+		tmport -= 0x08;
+		inb(tmport);
+		tmport = base_io + 0xc1;
+		outb(8, tmport++);
+		outb(0x7f, tmport);
+		tmport = base_io + 0xd1;
+		outb(0x20, tmport);
+
+		tscam_885();
+		printk(KERN_INFO "   Scanning Channel A SCSI Device ...\n");
+		is885(p, base_io + 0x80, 0);
+		printk(KERN_INFO "   Scanning Channel B SCSI Device ...\n");
+		is885(p, base_io + 0xc0, 1);
+
+		k = inb(base_io + 0x28) & 0xcf;
+		k |= 0xc0;
+		outb(k, base_io + 0x28);
+		k = inb(base_io + 0x1f) | 0x80;
+		outb(k, base_io + 0x1f);
+		k = inb(base_io + 0x29) | 0x01;
+		outb(k, base_io + 0x29);
+#ifdef ED_DBGP
+		//printk("atp885: atp_host[0] 0x%p\n", atp_host[0]);
+#endif		
+		shpnt->max_id = 16;
+		shpnt->max_lun = (p->global_map[0] & 0x07) + 1;
+		shpnt->max_channel = 1;
+		shpnt->this_id = p->host_id[0];
+		shpnt->unique_id = base_io;
+		shpnt->io_port = base_io;
+		shpnt->n_io_port = 0xff;	/* Number of bytes of I/O space used */
+		shpnt->irq = pdev->irq;
+				
+	} else {
+		error = pci_read_config_byte(pdev, 0x49, &host_id);
+
+		printk(KERN_INFO "   ACARD AEC-671X PCI Ultra/W SCSI-2/3 Host Adapter: %d "
+			"IO:%x, IRQ:%d.\n", count, base_io, pdev->irq);
+
+		atp_dev.ioport[0] = base_io;
+		atp_dev.pciport[0] = base_io + 0x20;
+		atp_dev.dev_id = ent->device;
+		host_id &= 0x07;
+		atp_dev.host_id[0] = host_id;
+		tmport = base_io + 0x22;
+		atp_dev.scam_on = inb(tmport);
+		tmport += 0x0b;
+		atp_dev.global_map[0] = inb(tmport++);
+		atp_dev.ultra_map[0] = inw(tmport);
+
+		if (atp_dev.ultra_map[0] == 0) {
+			atp_dev.scam_on = 0x00;
+			atp_dev.global_map[0] = 0x20;
+			atp_dev.ultra_map[0] = 0xffff;
+		}
+
+		shpnt = scsi_host_alloc(&atp870u_template, sizeof(struct atp_unit));
+		if (!shpnt)
+			return -ENOMEM;
+
+		p = (struct atp_unit *)&shpnt->hostdata;
+		
+		atp_dev.host = shpnt;
+		atp_dev.pdev = pdev;
+		pci_set_drvdata(pdev, p);
+		memcpy(p, &atp_dev, sizeof atp_dev);
+		if (atp870u_init_tables(shpnt) < 0)
+			goto unregister;
+
+		if (request_irq(pdev->irq, atp870u_intr_handle, SA_SHIRQ, "atp870i", shpnt)) {
+			printk(KERN_ERR "Unable to allocate IRQ%d for Acard controller.\n", pdev->irq);
+			goto free_tables;
+		}
+
+		spin_lock_irqsave(shpnt->host_lock, flags);
+		if (atp_dev.chip_ver > 0x07) {	/* check if atp876 chip then enable terminator */
+			tmport = base_io + 0x3e;
+			outb(0x00, tmport);
+		}
+ 
+		tmport = base_io + 0x3a;
+		k = (inb(tmport) & 0xf3) | 0x10;
+		outb(k, tmport);
+		outb((k & 0xdf), tmport);
+		mdelay(32);
+		outb(k, tmport);
+		mdelay(32);
+		tmport = base_io;
+		outb((host_id | 0x08), tmport);
+		tmport += 0x18;
+		outb(0, tmport);
+		tmport += 0x07;
+		while ((inb(tmport) & 0x80) == 0)
+			mdelay(1);
+
+		tmport -= 0x08;
+		inb(tmport);
+		tmport = base_io + 1;
+		outb(8, tmport++);
+		outb(0x7f, tmport);
+		tmport = base_io + 0x11;
+		outb(0x20, tmport);
+
+		tscam(shpnt);
+		is870(p, base_io);
+		tmport = base_io + 0x3a;
+		outb((inb(tmport) & 0xef), tmport);
+		tmport++;
+		outb((inb(tmport) | 0x20), tmport);
+		if (atp_dev.chip_ver == 4)
+			shpnt->max_id = 16;
+		else		
+			shpnt->max_id = 7;
+		shpnt->this_id = host_id;
+		shpnt->unique_id = base_io;
+		shpnt->io_port = base_io;
+		shpnt->n_io_port = 0x40;	/* Number of bytes of I/O space used */
+		shpnt->irq = pdev->irq;		
+	} 
+		spin_unlock_irqrestore(shpnt->host_lock, flags);
+		if(ent->device==ATP885_DEVID) {
+			if(!request_region(base_io, 0xff, "atp870u")) /* Register the IO ports that we use */
+				goto request_io_fail;
+		} else if((ent->device==ATP880_DEVID1)||(ent->device==ATP880_DEVID2)) {
+			if(!request_region(base_io, 0x60, "atp870u")) /* Register the IO ports that we use */
+				goto request_io_fail;
+		} else {
+			if(!request_region(base_io, 0x40, "atp870u")) /* Register the IO ports that we use */
+				goto request_io_fail;
+		}				
+		count++;
+		if (scsi_add_host(shpnt, &pdev->dev))
+			goto scsi_add_fail;
+		scsi_scan_host(shpnt);
+#ifdef ED_DBGP			
+		printk("atp870u_prob : exit\n");
+#endif		
+		return 0;
+
+scsi_add_fail:
+	printk("atp870u_prob:scsi_add_fail\n");
+	if(ent->device==ATP885_DEVID) {
+		release_region(base_io, 0xff);
+	} else if((ent->device==ATP880_DEVID1)||(ent->device==ATP880_DEVID2)) {
+		release_region(base_io, 0x60);
+	} else {
+		release_region(base_io, 0x40);
+	}
+request_io_fail:
+	printk("atp870u_prob:request_io_fail\n");
+	free_irq(pdev->irq, shpnt);
+free_tables:
+	printk("atp870u_prob:free_table\n");
+	atp870u_free_tables(shpnt);
+unregister:
+	printk("atp870u_prob:unregister\n");
+	scsi_host_put(shpnt);
+	return -1;		
+}
+
+/* The abort command does not leave the device in a clean state where
+   it is available to be used again.  Until this gets worked out, we will
+   leave it commented out.  */
+
+static int atp870u_abort(struct scsi_cmnd * SCpnt)
+{
+	unsigned char  j, k, c;
+	struct scsi_cmnd *workrequ;
+	unsigned int tmport;
+	struct atp_unit *dev;	
+	struct Scsi_Host *host;
+	host = SCpnt->device->host;
+
+	dev = (struct atp_unit *)&host->hostdata;
+	c=SCpnt->device->channel;
+	printk(" atp870u: abort Channel = %x \n", c);
+	printk("working=%x last_cmd=%x ", dev->working[c], dev->last_cmd[c]);
+	printk(" quhdu=%x quendu=%x ", dev->quhd[c], dev->quend[c]);
+	tmport = dev->ioport[c];
+	for (j = 0; j < 0x18; j++) {
+		printk(" r%2x=%2x", j, inb(tmport++));
+	}
+	tmport += 0x04;
+	printk(" r1c=%2x", inb(tmport));
+	tmport += 0x03;
+	printk(" r1f=%2x in_snd=%2x ", inb(tmport), dev->in_snd[c]);
+	tmport= dev->pciport[c];
+	printk(" d00=%2x", inb(tmport));
+	tmport += 0x02;
+	printk(" d02=%2x", inb(tmport));
+	for(j=0;j<16;j++) {
+	   if (dev->id[c][j].curr_req != NULL) {
+		workrequ = dev->id[c][j].curr_req;
+		printk("\n que cdb= ");
+		for (k=0; k < workrequ->cmd_len; k++) {
+		    printk(" %2x ",workrequ->cmnd[k]);
+		}
+		printk(" last_lenu= %x ",(unsigned int)dev->id[c][j].last_len);
+	   }
+	}
+	return SUCCESS;
+}
+
+static const char *atp870u_info(struct Scsi_Host *notused)
+{
+	static char buffer[128];
+
+	strcpy(buffer, "ACARD AEC-6710/6712/67160 PCI Ultra/W/LVD SCSI-3 Adapter Driver V2.6+ac ");
+
+	return buffer;
+}
+
+#define BLS buffer + len + size
+int atp870u_proc_info(struct Scsi_Host *HBAptr, char *buffer, 
+		      char **start, off_t offset, int length, int inout)
+{
+	static u8 buff[512];
+	int size = 0;
+	int len = 0;
+	off_t begin = 0;
+	off_t pos = 0;
+	
+	if (inout) 	
+		return -EINVAL;
+	if (offset == 0)
+		memset(buff, 0, sizeof(buff));
+	size += sprintf(BLS, "ACARD AEC-671X Driver Version: 2.6+ac\n");
+	len += size;
+	pos = begin + len;
+	size = 0;
+
+	size += sprintf(BLS, "\n");
+	size += sprintf(BLS, "Adapter Configuration:\n");
+	size += sprintf(BLS, "               Base IO: %#.4lx\n", HBAptr->io_port);
+	size += sprintf(BLS, "                   IRQ: %d\n", HBAptr->irq);
+	len += size;
+	pos = begin + len;
+	
+	*start = buffer + (offset - begin);	/* Start of wanted data */
+	len -= (offset - begin);	/* Start slop */
+	if (len > length) {
+		len = length;	/* Ending slop */
+	}
+	return (len);
+}
+
+
+static int atp870u_biosparam(struct scsi_device *disk, struct block_device *dev,
+			sector_t capacity, int *ip)
+{
+	int heads, sectors, cylinders;
+
+	heads = 64;
+	sectors = 32;
+	cylinders = (unsigned long)capacity / (heads * sectors);
+	if (cylinders > 1024) {
+		heads = 255;
+		sectors = 63;
+		cylinders = (unsigned long)capacity / (heads * sectors);
+	}
+	ip[0] = heads;
+	ip[1] = sectors;
+	ip[2] = cylinders;
+
+	return 0;
+}
+
+static void atp870u_remove (struct pci_dev *pdev)
+{	
+	struct atp_unit *devext = pci_get_drvdata(pdev);
+	struct Scsi_Host *pshost = devext->host;
+	
+	
+	scsi_remove_host(pshost);
+	printk(KERN_INFO "free_irq : %d\n",pshost->irq);
+	free_irq(pshost->irq, pshost);
+	release_region(pshost->io_port, pshost->n_io_port);
+	printk(KERN_INFO "atp870u_free_tables : %p\n",pshost);
+	atp870u_free_tables(pshost);
+	printk(KERN_INFO "scsi_host_put : %p\n",pshost);
+	scsi_host_put(pshost);
+	printk(KERN_INFO "pci_set_drvdata : %p\n",pdev);
+	pci_set_drvdata(pdev, NULL);	
+}
+MODULE_LICENSE("GPL");
+
+static struct scsi_host_template atp870u_template = {
+     .module			= THIS_MODULE,
+     .name              	= "atp870u"		/* name */,
+     .proc_name			= "atp870u",
+     .proc_info			= atp870u_proc_info,
+     .info              	= atp870u_info		/* info */,
+     .queuecommand      	= atp870u_queuecommand	/* queuecommand */,
+     .eh_abort_handler  	= atp870u_abort		/* abort */,
+     .bios_param        	= atp870u_biosparam	/* biosparm */,
+     .can_queue         	= qcnt			/* can_queue */,
+     .this_id           	= 7			/* SCSI ID */,
+     .sg_tablesize      	= ATP870U_SCATTER	/*SG_ALL*/ /*SG_NONE*/,
+     .cmd_per_lun       	= ATP870U_CMDLUN		/* commands per lun */,
+     .use_clustering    	= ENABLE_CLUSTERING,
+     .max_sectors		= ATP870U_MAX_SECTORS,
+};
+
+static struct pci_device_id atp870u_id_table[] = {
+	{ PCI_DEVICE(PCI_VENDOR_ID_ARTOP, ATP885_DEVID)			  },
+	{ PCI_DEVICE(PCI_VENDOR_ID_ARTOP, ATP880_DEVID1)			  },
+	{ PCI_DEVICE(PCI_VENDOR_ID_ARTOP, ATP880_DEVID2)			  },
+	{ PCI_DEVICE(PCI_VENDOR_ID_ARTOP, PCI_DEVICE_ID_ARTOP_AEC7610)    },
+	{ PCI_DEVICE(PCI_VENDOR_ID_ARTOP, PCI_DEVICE_ID_ARTOP_AEC7612UW)  },
+	{ PCI_DEVICE(PCI_VENDOR_ID_ARTOP, PCI_DEVICE_ID_ARTOP_AEC7612U)   },
+	{ PCI_DEVICE(PCI_VENDOR_ID_ARTOP, PCI_DEVICE_ID_ARTOP_AEC7612S)   },
+	{ PCI_DEVICE(PCI_VENDOR_ID_ARTOP, PCI_DEVICE_ID_ARTOP_AEC7612D)	  },
+	{ PCI_DEVICE(PCI_VENDOR_ID_ARTOP, PCI_DEVICE_ID_ARTOP_AEC7612SUW) },
+	{ PCI_DEVICE(PCI_VENDOR_ID_ARTOP, PCI_DEVICE_ID_ARTOP_8060)	  },
+	{ 0, },
+};
+
+MODULE_DEVICE_TABLE(pci, atp870u_id_table);
+
+static struct pci_driver atp870u_driver = {
+	.id_table	= atp870u_id_table,
+	.name		= "atp870u",
+	.probe		= atp870u_probe,
+	.remove		= __devexit_p(atp870u_remove),
+};
+
+static int __init atp870u_init(void)
+{
+#ifdef ED_DBGP	
+	printk("atp870u_init: Entry\n");
+#endif	
+	return pci_register_driver(&atp870u_driver);
+}
+
+static void __exit atp870u_exit(void)
+{
+#ifdef ED_DBGP	
+	printk("atp870u_exit: Entry\n");
+#endif
+	pci_unregister_driver(&atp870u_driver);
+}
+
+static void tscam_885(void)
+{
+	unsigned char i;
+
+	for (i = 0; i < 0x2; i++) {
+		mdelay(300);
+	}
+	return;
+}
+
+
+
+static void is885(struct atp_unit *dev, unsigned int wkport,unsigned char c)
+{
+	unsigned int tmport;
+	unsigned char i, j, k, rmb, n, lvdmode;
+	unsigned short int m;
+	static unsigned char mbuf[512];
+	static unsigned char satn[9] =	{0, 0, 0, 0, 0, 0, 0, 6, 6};
+	static unsigned char inqd[9] =	{0x12, 0, 0, 0, 0x24, 0, 0, 0x24, 6};
+	static unsigned char synn[6] =	{0x80, 1, 3, 1, 0x19, 0x0e};
+	unsigned char synu[6] =  {0x80, 1, 3, 1, 0x0a, 0x0e};
+	static unsigned char synw[6] =	{0x80, 1, 3, 1, 0x19, 0x0e};
+	unsigned char synuw[6] =  {0x80, 1, 3, 1, 0x0a, 0x0e};
+	static unsigned char wide[6] =	{0x80, 1, 2, 3, 1, 0};
+	static unsigned char u3[9] = { 0x80,1,6,4,0x09,00,0x0e,0x01,0x02 };
+
+	lvdmode=inb(wkport + 0x1b) >> 7;
+
+	for (i = 0; i < 16; i++) {
+		m = 1;
+		m = m << i;
+		if ((m & dev->active_id[c]) != 0) {
+			continue;
+		}
+		if (i == dev->host_id[c]) {
+			printk(KERN_INFO "         ID: %2d  Host Adapter\n", dev->host_id[c]);
+			continue;
+		}
+		tmport = wkport + 0x1b;
+		outb(0x01, tmport);
+		tmport = wkport + 0x01;
+		outb(0x08, tmport++);
+		outb(0x7f, tmport++);
+		outb(satn[0], tmport++);
+		outb(satn[1], tmport++);
+		outb(satn[2], tmport++);
+		outb(satn[3], tmport++);
+		outb(satn[4], tmport++);
+		outb(satn[5], tmport++);
+		tmport += 0x06;
+		outb(0, tmport);
+		tmport += 0x02;
+		outb(dev->id[c][i].devsp, tmport++);
+		
+		outb(0, tmport++);
+		outb(satn[6], tmport++);
+		outb(satn[7], tmport++);
+		j = i;
+		if ((j & 0x08) != 0) {
+			j = (j & 0x07) | 0x40;
+		}
+		outb(j, tmport);
+		tmport += 0x03;
+		outb(satn[8], tmport);
+		tmport += 0x07;
+
+		while ((inb(tmport) & 0x80) == 0x00)
+			cpu_relax();
+		tmport -= 0x08;
+		if ((inb(tmport) != 0x11) && (inb(tmport) != 0x8e)) {
+			continue;
+		}
+		while (inb(tmport) != 0x8e)
+			cpu_relax();
+		dev->active_id[c] |= m;
+
+		tmport = wkport + 0x10;
+		outb(0x30, tmport);
+		tmport = wkport + 0x14;
+		outb(0x00, tmport);
+
+phase_cmd:
+		tmport = wkport + 0x18;
+		outb(0x08, tmport);
+		tmport += 0x07;
+		while ((inb(tmport) & 0x80) == 0x00)
+			cpu_relax();
+		tmport -= 0x08;
+		j = inb(tmport);
+		if (j != 0x16) {
+			tmport = wkport + 0x10;
+			outb(0x41, tmport);
+			goto phase_cmd;
+		}
+sel_ok:
+		tmport = wkport + 0x03;
+		outb(inqd[0], tmport++);
+		outb(inqd[1], tmport++);
+		outb(inqd[2], tmport++);
+		outb(inqd[3], tmport++);
+		outb(inqd[4], tmport++);
+		outb(inqd[5], tmport);
+		tmport += 0x07;
+		outb(0, tmport);
+		tmport += 0x02;
+		outb(dev->id[c][i].devsp, tmport++);
+		outb(0, tmport++);
+		outb(inqd[6], tmport++);
+		outb(inqd[7], tmport++);
+		tmport += 0x03;
+		outb(inqd[8], tmport);
+		tmport += 0x07;
+		while ((inb(tmport) & 0x80) == 0x00)
+			cpu_relax();
+		tmport -= 0x08;
+		if ((inb(tmport) != 0x11) && (inb(tmport) != 0x8e)) {
+			continue;
+		}
+		while (inb(tmport) != 0x8e)
+			cpu_relax();
+		tmport = wkport + 0x1b;
+		outb(0x00, tmport);
+		tmport = wkport + 0x18;
+		outb(0x08, tmport);
+		tmport += 0x07;
+		j = 0;
+rd_inq_data:
+		k = inb(tmport);
+		if ((k & 0x01) != 0) {
+			tmport -= 0x06;
+			mbuf[j++] = inb(tmport);
+			tmport += 0x06;
+			goto rd_inq_data;
+		}
+		if ((k & 0x80) == 0) {
+			goto rd_inq_data;
+		}
+		tmport -= 0x08;
+		j = inb(tmport);
+		if (j == 0x16) {
+			goto inq_ok;
+		}
+		tmport = wkport + 0x10;
+		outb(0x46, tmport);
+		tmport += 0x02;
+		outb(0, tmport++);
+		outb(0, tmport++);
+		outb(0, tmport++);
+		tmport += 0x03;
+		outb(0x08, tmport);
+		tmport += 0x07;
+		while ((inb(tmport) & 0x80) == 0x00)
+			cpu_relax();
+		tmport -= 0x08;
+		if (inb(tmport) != 0x16) {
+			goto sel_ok;
+		}
+inq_ok:
+		mbuf[36] = 0;
+		printk( KERN_INFO"         ID: %2d  %s\n", i, &mbuf[8]);
+		dev->id[c][i].devtype = mbuf[0];
+		rmb = mbuf[1];
+		n = mbuf[7];
+		if ((mbuf[7] & 0x60) == 0) {
+			goto not_wide;
+		}
+		if ((i < 8) && ((dev->global_map[c] & 0x20) == 0)) {
+			goto not_wide;
+		}
+		if (lvdmode == 0) {
+		   goto chg_wide;
+		}
+		if (dev->sp[c][i] != 0x04) {	// force u2
+		   goto chg_wide;
+		}
+
+		tmport = wkport + 0x1b;
+		outb(0x01, tmport);
+		tmport = wkport + 0x03;
+		outb(satn[0], tmport++);
+		outb(satn[1], tmport++);
+		outb(satn[2], tmport++);
+		outb(satn[3], tmport++);
+		outb(satn[4], tmport++);
+		outb(satn[5], tmport++);
+		tmport += 0x06;
+		outb(0, tmport);
+		tmport += 0x02;
+		outb(dev->id[c][i].devsp, tmport++);
+		outb(0, tmport++);
+		outb(satn[6], tmport++);
+		outb(satn[7], tmport++);
+		tmport += 0x03;
+		outb(satn[8], tmport);
+		tmport += 0x07;
+
+		while ((inb(tmport) & 0x80) == 0x00)
+			cpu_relax();
+		tmport -= 0x08;
+		if ((inb(tmport) != 0x11) && (inb(tmport) != 0x8e)) {
+			continue;
+		}
+		while (inb(tmport) != 0x8e)
+			cpu_relax();
+try_u3:
+		j = 0;
+		tmport = wkport + 0x14;
+		outb(0x09, tmport);
+		tmport += 0x04;
+		outb(0x20, tmport);
+		tmport += 0x07;
+
+		while ((inb(tmport) & 0x80) == 0) {
+			if ((inb(tmport) & 0x01) != 0) {
+				tmport -= 0x06;
+				outb(u3[j++], tmport);
+				tmport += 0x06;
+			}
+			cpu_relax();
+		}
+		tmport -= 0x08;
+		while ((inb(tmport) & 0x80) == 0x00)
+			cpu_relax();
+		j = inb(tmport) & 0x0f;
+		if (j == 0x0f) {
+			goto u3p_in;
+		}
+		if (j == 0x0a) {
+			goto u3p_cmd;
+		}
+		if (j == 0x0e) {
+			goto try_u3;
+		}
+		continue;
+u3p_out:
+		tmport = wkport + 0x18;
+		outb(0x20, tmport);
+		tmport += 0x07;
+		while ((inb(tmport) & 0x80) == 0) {
+			if ((inb(tmport) & 0x01) != 0) {
+				tmport -= 0x06;
+				outb(0, tmport);
+				tmport += 0x06;
+			}
+			cpu_relax();
+		}
+		tmport -= 0x08;
+		j = inb(tmport) & 0x0f;
+		if (j == 0x0f) {
+			goto u3p_in;
+		}
+		if (j == 0x0a) {
+			goto u3p_cmd;
+		}
+		if (j == 0x0e) {
+			goto u3p_out;
+		}
+		continue;
+u3p_in:
+		tmport = wkport + 0x14;
+		outb(0x09, tmport);
+		tmport += 0x04;
+		outb(0x20, tmport);
+		tmport += 0x07;
+		k = 0;
+u3p_in1:
+		j = inb(tmport);
+		if ((j & 0x01) != 0) {
+			tmport -= 0x06;
+			mbuf[k++] = inb(tmport);
+			tmport += 0x06;
+			goto u3p_in1;
+		}
+		if ((j & 0x80) == 0x00) {
+			goto u3p_in1;
+		}
+		tmport -= 0x08;
+		j = inb(tmport) & 0x0f;
+		if (j == 0x0f) {
+			goto u3p_in;
+		}
+		if (j == 0x0a) {
+			goto u3p_cmd;
+		}
+		if (j == 0x0e) {
+			goto u3p_out;
+		}
+		continue;
+u3p_cmd:
+		tmport = wkport + 0x10;
+		outb(0x30, tmport);
+		tmport = wkport + 0x14;
+		outb(0x00, tmport);
+		tmport += 0x04;
+		outb(0x08, tmport);
+		tmport += 0x07;
+		while ((inb(tmport) & 0x80) == 0x00);
+		tmport -= 0x08;
+		j = inb(tmport);
+		if (j != 0x16) {
+			if (j == 0x4e) {
+				goto u3p_out;
+			}
+			continue;
+		}
+		if (mbuf[0] != 0x01) {
+			goto chg_wide;
+		}
+		if (mbuf[1] != 0x06) {
+			goto chg_wide;
+		}
+		if (mbuf[2] != 0x04) {
+			goto chg_wide;
+		}
+		if (mbuf[3] == 0x09) {
+			m = 1;
+			m = m << i;
+			dev->wide_id[c] |= m;
+			dev->id[c][i].devsp = 0xce;
+#ifdef ED_DBGP		   
+			printk("dev->id[%2d][%2d].devsp = %2x\n",c,i,dev->id[c][i].devsp);
+#endif
+			continue;
+		}
+chg_wide:
+		tmport = wkport + 0x1b;
+		outb(0x01, tmport);
+		tmport = wkport + 0x03;
+		outb(satn[0], tmport++);
+		outb(satn[1], tmport++);
+		outb(satn[2], tmport++);
+		outb(satn[3], tmport++);
+		outb(satn[4], tmport++);
+		outb(satn[5], tmport++);
+		tmport += 0x06;
+		outb(0, tmport);
+		tmport += 0x02;
+		outb(dev->id[c][i].devsp, tmport++);
+		outb(0, tmport++);
+		outb(satn[6], tmport++);
+		outb(satn[7], tmport++);
+		tmport += 0x03;
+		outb(satn[8], tmport);
+		tmport += 0x07;
+
+		while ((inb(tmport) & 0x80) == 0x00)
+			cpu_relax();
+		tmport -= 0x08;
+		if ((inb(tmport) != 0x11) && (inb(tmport) != 0x8e)) {
+			continue;
+		}
+		while (inb(tmport) != 0x8e)
+			cpu_relax();
+try_wide:
+		j = 0;
+		tmport = wkport + 0x14;
+		outb(0x05, tmport);
+		tmport += 0x04;
+		outb(0x20, tmport);
+		tmport += 0x07;
+
+		while ((inb(tmport) & 0x80) == 0) {
+			if ((inb(tmport) & 0x01) != 0) {
+				tmport -= 0x06;
+				outb(wide[j++], tmport);
+				tmport += 0x06;
+			}
+			cpu_relax();
+		}
+		tmport -= 0x08;
+		while ((inb(tmport) & 0x80) == 0x00)
+			cpu_relax();
+		j = inb(tmport) & 0x0f;
+		if (j == 0x0f) {
+			goto widep_in;
+		}
+		if (j == 0x0a) {
+			goto widep_cmd;
+		}
+		if (j == 0x0e) {
+			goto try_wide;
+		}
+		continue;
+widep_out:
+		tmport = wkport + 0x18;
+		outb(0x20, tmport);
+		tmport += 0x07;
+		while ((inb(tmport) & 0x80) == 0) {
+			if ((inb(tmport) & 0x01) != 0) {
+				tmport -= 0x06;
+				outb(0, tmport);
+				tmport += 0x06;
+			}
+			cpu_relax();
+		}
+		tmport -= 0x08;
+		j = inb(tmport) & 0x0f;
+		if (j == 0x0f) {
+			goto widep_in;
+		}
+		if (j == 0x0a) {
+			goto widep_cmd;
+		}
+		if (j == 0x0e) {
+			goto widep_out;
+		}
+		continue;
+widep_in:
+		tmport = wkport + 0x14;
+		outb(0xff, tmport);
+		tmport += 0x04;
+		outb(0x20, tmport);
+		tmport += 0x07;
+		k = 0;
+widep_in1:
+		j = inb(tmport);
+		if ((j & 0x01) != 0) {
+			tmport -= 0x06;
+			mbuf[k++] = inb(tmport);
+			tmport += 0x06;
+			goto widep_in1;
+		}
+		if ((j & 0x80) == 0x00) {
+			goto widep_in1;
+		}
+		tmport -= 0x08;
+		j = inb(tmport) & 0x0f;
+		if (j == 0x0f) {
+			goto widep_in;
+		}
+		if (j == 0x0a) {
+			goto widep_cmd;
+		}
+		if (j == 0x0e) {
+			goto widep_out;
+		}
+		continue;
+widep_cmd:
+		tmport = wkport + 0x10;
+		outb(0x30, tmport);
+		tmport = wkport + 0x14;
+		outb(0x00, tmport);
+		tmport += 0x04;
+		outb(0x08, tmport);
+		tmport += 0x07;
+		while ((inb(tmport) & 0x80) == 0x00)
+			cpu_relax();
+		tmport -= 0x08;
+		j = inb(tmport);
+		if (j != 0x16) {
+			if (j == 0x4e) {
+				goto widep_out;
+			}
+			continue;
+		}
+		if (mbuf[0] != 0x01) {
+			goto not_wide;
+		}
+		if (mbuf[1] != 0x02) {
+			goto not_wide;
+		}
+		if (mbuf[2] != 0x03) {
+			goto not_wide;
+		}
+		if (mbuf[3] != 0x01) {
+			goto not_wide;
+		}
+		m = 1;
+		m = m << i;
+		dev->wide_id[c] |= m;
+not_wide:
+		if ((dev->id[c][i].devtype == 0x00) || (dev->id[c][i].devtype == 0x07) ||
+		    ((dev->id[c][i].devtype == 0x05) && ((n & 0x10) != 0))) {
+			m = 1;
+			m = m << i;
+			if ((dev->async[c] & m) != 0) {
+			   goto set_sync;
+			}
+		}
+		continue;
+set_sync:
+		if (dev->sp[c][i] == 0x02) {
+		   synu[4]=0x0c;
+		   synuw[4]=0x0c;
+		} else {
+		   if (dev->sp[c][i] >= 0x03) {
+		      synu[4]=0x0a;
+		      synuw[4]=0x0a;
+		   }
+		}
+		tmport = wkport + 0x1b;
+		j = 0;
+		if ((m & dev->wide_id[c]) != 0) {
+			j |= 0x01;
+		}
+		outb(j, tmport);
+		tmport = wkport + 0x03;
+		outb(satn[0], tmport++);
+		outb(satn[1], tmport++);
+		outb(satn[2], tmport++);
+		outb(satn[3], tmport++);
+		outb(satn[4], tmport++);
+		outb(satn[5], tmport++);
+		tmport += 0x06;
+		outb(0, tmport);
+		tmport += 0x02;
+		outb(dev->id[c][i].devsp, tmport++);
+		outb(0, tmport++);
+		outb(satn[6], tmport++);
+		outb(satn[7], tmport++);
+		tmport += 0x03;
+		outb(satn[8], tmport);
+		tmport += 0x07;
+
+		while ((inb(tmport) & 0x80) == 0x00)
+			cpu_relax();
+		tmport -= 0x08;
+		if ((inb(tmport) != 0x11) && (inb(tmport) != 0x8e)) {
+			continue;
+		}
+		while (inb(tmport) != 0x8e)
+			cpu_relax();
+try_sync:
+		j = 0;
+		tmport = wkport + 0x14;
+		outb(0x06, tmport);
+		tmport += 0x04;
+		outb(0x20, tmport);
+		tmport += 0x07;
+
+		while ((inb(tmport) & 0x80) == 0) {
+			if ((inb(tmport) & 0x01) != 0) {
+				tmport -= 0x06;
+				if ((m & dev->wide_id[c]) != 0) {
+					if ((m & dev->ultra_map[c]) != 0) {
+						outb(synuw[j++], tmport);
+					} else {
+						outb(synw[j++], tmport);
+					}
+				} else {
+					if ((m & dev->ultra_map[c]) != 0) {
+						outb(synu[j++], tmport);
+					} else {
+						outb(synn[j++], tmport);
+					}
+				}
+				tmport += 0x06;
+			}
+		}
+		tmport -= 0x08;
+		while ((inb(tmport) & 0x80) == 0x00)
+			cpu_relax();
+		j = inb(tmport) & 0x0f;
+		if (j == 0x0f) {
+			goto phase_ins;
+		}
+		if (j == 0x0a) {
+			goto phase_cmds;
+		}
+		if (j == 0x0e) {
+			goto try_sync;
+		}
+		continue;
+phase_outs:
+		tmport = wkport + 0x18;
+		outb(0x20, tmport);
+		tmport += 0x07;
+		while ((inb(tmport) & 0x80) == 0x00) {
+			if ((inb(tmport) & 0x01) != 0x00) {
+				tmport -= 0x06;
+				outb(0x00, tmport);
+				tmport += 0x06;
+			}
+			cpu_relax();
+		}
+		tmport -= 0x08;
+		j = inb(tmport);
+		if (j == 0x85) {
+			goto tar_dcons;
+		}
+		j &= 0x0f;
+		if (j == 0x0f) {
+			goto phase_ins;
+		}
+		if (j == 0x0a) {
+			goto phase_cmds;
+		}
+		if (j == 0x0e) {
+			goto phase_outs;
+		}
+		continue;
+phase_ins:
+		tmport = wkport + 0x14;
+		outb(0x06, tmport);
+		tmport += 0x04;
+		outb(0x20, tmport);
+		tmport += 0x07;
+		k = 0;
+phase_ins1:
+		j = inb(tmport);
+		if ((j & 0x01) != 0x00) {
+			tmport -= 0x06;
+			mbuf[k++] = inb(tmport);
+			tmport += 0x06;
+			goto phase_ins1;
+		}
+		if ((j & 0x80) == 0x00) {
+			goto phase_ins1;
+		}
+		tmport -= 0x08;
+		while ((inb(tmport) & 0x80) == 0x00);
+		j = inb(tmport);
+		if (j == 0x85) {
+			goto tar_dcons;
+		}
+		j &= 0x0f;
+		if (j == 0x0f) {
+			goto phase_ins;
+		}
+		if (j == 0x0a) {
+			goto phase_cmds;
+		}
+		if (j == 0x0e) {
+			goto phase_outs;
+		}
+		continue;
+phase_cmds:
+		tmport = wkport + 0x10;
+		outb(0x30, tmport);
+tar_dcons:
+		tmport = wkport + 0x14;
+		outb(0x00, tmport);
+		tmport += 0x04;
+		outb(0x08, tmport);
+		tmport += 0x07;
+		while ((inb(tmport) & 0x80) == 0x00)
+			cpu_relax();
+		tmport -= 0x08;
+		j = inb(tmport);
+		if (j != 0x16) {
+			continue;
+		}
+		if (mbuf[0] != 0x01) {
+			continue;
+		}
+		if (mbuf[1] != 0x03) {
+			continue;
+		}
+		if (mbuf[4] == 0x00) {
+			continue;
+		}
+		if (mbuf[3] > 0x64) {
+			continue;
+		}
+		if (mbuf[4] > 0x0e) {
+			mbuf[4] = 0x0e;
+		}
+		dev->id[c][i].devsp = mbuf[4];
+		if (mbuf[3] < 0x0c){
+			j = 0xb0;
+			goto set_syn_ok;
+		}
+		if ((mbuf[3] < 0x0d) && (rmb == 0)) {
+			j = 0xa0;
+			goto set_syn_ok;
+		}
+		if (mbuf[3] < 0x1a) {
+			j = 0x20;
+			goto set_syn_ok;
+		}
+		if (mbuf[3] < 0x33) {
+			j = 0x40;
+			goto set_syn_ok;
+		}
+		if (mbuf[3] < 0x4c) {
+			j = 0x50;
+			goto set_syn_ok;
+		}
+		j = 0x60;
+	      set_syn_ok:
+		dev->id[c][i].devsp = (dev->id[c][i].devsp & 0x0f) | j;
+#ifdef ED_DBGP		
+		printk("dev->id[%2d][%2d].devsp = %2x\n",c,i,dev->id[c][i].devsp);
+#endif
+	}
+	tmport = wkport + 0x16;
+	outb(0x80, tmport);
+}
+
+module_init(atp870u_init);
+module_exit(atp870u_exit);
+
