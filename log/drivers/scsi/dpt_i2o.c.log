commit 65fddcfca8ad14778f71a57672fd01e8112d30fa
Author: Mike Rapoport <rppt@linux.ibm.com>
Date:   Mon Jun 8 21:32:42 2020 -0700

    mm: reorder includes after introduction of linux/pgtable.h
    
    The replacement of <asm/pgrable.h> with <linux/pgtable.h> made the include
    of the latter in the middle of asm includes.  Fix this up with the aid of
    the below script and manual adjustments here and there.
    
            import sys
            import re
    
            if len(sys.argv) is not 3:
                print "USAGE: %s <file> <header>" % (sys.argv[0])
                sys.exit(1)
    
            hdr_to_move="#include <linux/%s>" % sys.argv[2]
            moved = False
            in_hdrs = False
    
            with open(sys.argv[1], "r") as f:
                lines = f.readlines()
                for _line in lines:
                    line = _line.rstrip('
    ')
                    if line == hdr_to_move:
                        continue
                    if line.startswith("#include <linux/"):
                        in_hdrs = True
                    elif not moved and in_hdrs:
                        moved = True
                        print hdr_to_move
                    print line
    
    Signed-off-by: Mike Rapoport <rppt@linux.ibm.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Cc: Arnd Bergmann <arnd@arndb.de>
    Cc: Borislav Petkov <bp@alien8.de>
    Cc: Brian Cain <bcain@codeaurora.org>
    Cc: Catalin Marinas <catalin.marinas@arm.com>
    Cc: Chris Zankel <chris@zankel.net>
    Cc: "David S. Miller" <davem@davemloft.net>
    Cc: Geert Uytterhoeven <geert@linux-m68k.org>
    Cc: Greentime Hu <green.hu@gmail.com>
    Cc: Greg Ungerer <gerg@linux-m68k.org>
    Cc: Guan Xuetao <gxt@pku.edu.cn>
    Cc: Guo Ren <guoren@kernel.org>
    Cc: Heiko Carstens <heiko.carstens@de.ibm.com>
    Cc: Helge Deller <deller@gmx.de>
    Cc: Ingo Molnar <mingo@redhat.com>
    Cc: Ley Foon Tan <ley.foon.tan@intel.com>
    Cc: Mark Salter <msalter@redhat.com>
    Cc: Matthew Wilcox <willy@infradead.org>
    Cc: Matt Turner <mattst88@gmail.com>
    Cc: Max Filippov <jcmvbkbc@gmail.com>
    Cc: Michael Ellerman <mpe@ellerman.id.au>
    Cc: Michal Simek <monstr@monstr.eu>
    Cc: Nick Hu <nickhu@andestech.com>
    Cc: Paul Walmsley <paul.walmsley@sifive.com>
    Cc: Richard Weinberger <richard@nod.at>
    Cc: Rich Felker <dalias@libc.org>
    Cc: Russell King <linux@armlinux.org.uk>
    Cc: Stafford Horne <shorne@gmail.com>
    Cc: Thomas Bogendoerfer <tsbogend@alpha.franken.de>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Tony Luck <tony.luck@intel.com>
    Cc: Vincent Chen <deanbo422@gmail.com>
    Cc: Vineet Gupta <vgupta@synopsys.com>
    Cc: Will Deacon <will@kernel.org>
    Cc: Yoshinori Sato <ysato@users.sourceforge.jp>
    Link: http://lkml.kernel.org/r/20200514170327.31389-4-rppt@kernel.org
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/scsi/dpt_i2o.c b/drivers/scsi/dpt_i2o.c
index 049cda29e5ec..0497ef6a9453 100644
--- a/drivers/scsi/dpt_i2o.c
+++ b/drivers/scsi/dpt_i2o.c
@@ -27,6 +27,7 @@
 /*#define UARTDELAY 1 */
 
 #include <linux/module.h>
+#include <linux/pgtable.h>
 
 MODULE_AUTHOR("Deanna Bonds, with _lots_ of help from Mark Salyzyn");
 MODULE_DESCRIPTION("Adaptec I2O RAID Driver");
@@ -55,7 +56,6 @@ MODULE_DESCRIPTION("Adaptec I2O RAID Driver");
 #include <linux/mutex.h>
 
 #include <asm/processor.h>	/* for boot_cpu_data */
-#include <linux/pgtable.h>
 #include <asm/io.h>		/* for virt_to_bus, etc. */
 
 #include <scsi/scsi.h>

commit ca5999fde0a1761665a38e4c9a72dbcd7d190a81
Author: Mike Rapoport <rppt@linux.ibm.com>
Date:   Mon Jun 8 21:32:38 2020 -0700

    mm: introduce include/linux/pgtable.h
    
    The include/linux/pgtable.h is going to be the home of generic page table
    manipulation functions.
    
    Start with moving asm-generic/pgtable.h to include/linux/pgtable.h and
    make the latter include asm/pgtable.h.
    
    Signed-off-by: Mike Rapoport <rppt@linux.ibm.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Cc: Arnd Bergmann <arnd@arndb.de>
    Cc: Borislav Petkov <bp@alien8.de>
    Cc: Brian Cain <bcain@codeaurora.org>
    Cc: Catalin Marinas <catalin.marinas@arm.com>
    Cc: Chris Zankel <chris@zankel.net>
    Cc: "David S. Miller" <davem@davemloft.net>
    Cc: Geert Uytterhoeven <geert@linux-m68k.org>
    Cc: Greentime Hu <green.hu@gmail.com>
    Cc: Greg Ungerer <gerg@linux-m68k.org>
    Cc: Guan Xuetao <gxt@pku.edu.cn>
    Cc: Guo Ren <guoren@kernel.org>
    Cc: Heiko Carstens <heiko.carstens@de.ibm.com>
    Cc: Helge Deller <deller@gmx.de>
    Cc: Ingo Molnar <mingo@redhat.com>
    Cc: Ley Foon Tan <ley.foon.tan@intel.com>
    Cc: Mark Salter <msalter@redhat.com>
    Cc: Matthew Wilcox <willy@infradead.org>
    Cc: Matt Turner <mattst88@gmail.com>
    Cc: Max Filippov <jcmvbkbc@gmail.com>
    Cc: Michael Ellerman <mpe@ellerman.id.au>
    Cc: Michal Simek <monstr@monstr.eu>
    Cc: Nick Hu <nickhu@andestech.com>
    Cc: Paul Walmsley <paul.walmsley@sifive.com>
    Cc: Richard Weinberger <richard@nod.at>
    Cc: Rich Felker <dalias@libc.org>
    Cc: Russell King <linux@armlinux.org.uk>
    Cc: Stafford Horne <shorne@gmail.com>
    Cc: Thomas Bogendoerfer <tsbogend@alpha.franken.de>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Cc: Tony Luck <tony.luck@intel.com>
    Cc: Vincent Chen <deanbo422@gmail.com>
    Cc: Vineet Gupta <vgupta@synopsys.com>
    Cc: Will Deacon <will@kernel.org>
    Cc: Yoshinori Sato <ysato@users.sourceforge.jp>
    Link: http://lkml.kernel.org/r/20200514170327.31389-3-rppt@kernel.org
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/scsi/dpt_i2o.c b/drivers/scsi/dpt_i2o.c
index 2cf889512ece..049cda29e5ec 100644
--- a/drivers/scsi/dpt_i2o.c
+++ b/drivers/scsi/dpt_i2o.c
@@ -55,7 +55,7 @@ MODULE_DESCRIPTION("Adaptec I2O RAID Driver");
 #include <linux/mutex.h>
 
 #include <asm/processor.h>	/* for boot_cpu_data */
-#include <asm/pgtable.h>
+#include <linux/pgtable.h>
 #include <asm/io.h>		/* for virt_to_bus, etc. */
 
 #include <scsi/scsi.h>

commit 6f41f08c88c59ae6e32d32563c9af73ae2d71ece
Author: Xiongfeng Wang <wangxiongfeng2@huawei.com>
Date:   Wed Apr 29 20:10:18 2020 +0800

    scsi: dpt_i2o: Remove always false 'chan < 0' statement
    
    The channel index is represented by an unsigned variable 'u32 chan'. We
    don't need to check whether it is less than zero, the 'chan < 0' statement
    is always false. Remove it.
    
    Link: https://lore.kernel.org/r/1588162218-61757-1-git-send-email-wangxiongfeng2@huawei.com
    Reported-by: Hulk Robot <hulkci@huawei.com>
    Signed-off-by: Xiongfeng Wang <wangxiongfeng2@huawei.com>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/dpt_i2o.c b/drivers/scsi/dpt_i2o.c
index 02dff3a684e0..2cf889512ece 100644
--- a/drivers/scsi/dpt_i2o.c
+++ b/drivers/scsi/dpt_i2o.c
@@ -1120,7 +1120,7 @@ static struct adpt_device* adpt_find_device(adpt_hba* pHba, u32 chan, u32 id, u6
 {
 	struct adpt_device* d;
 
-	if(chan < 0 || chan >= MAX_CHANNEL)
+	if (chan >= MAX_CHANNEL)
 		return NULL;
 	
 	d = pHba->channel[chan].device[id];

commit f22978400e3ea6c35a1050a83a9a11f2c1dc8cb7
Author: Mauro Carvalho Chehab <mchehab+huawei@kernel.org>
Date:   Mon Mar 2 09:15:47 2020 +0100

    scsi: docs: convert dpti.txt to ReST
    
    Link: https://lore.kernel.org/r/212fd7961c134c5bd73d87cd818bcddc30270804.1583136624.git.mchehab+huawei@kernel.org
    Signed-off-by: Mauro Carvalho Chehab <mchehab+huawei@kernel.org>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/dpt_i2o.c b/drivers/scsi/dpt_i2o.c
index ac27323ea135..02dff3a684e0 100644
--- a/drivers/scsi/dpt_i2o.c
+++ b/drivers/scsi/dpt_i2o.c
@@ -8,7 +8,7 @@
 			   July 30, 2001 First version being submitted
 			   for inclusion in the kernel.  V2.4
 
-    See Documentation/scsi/dpti.txt for history, notes, license info
+    See Documentation/scsi/dpti.rst for history, notes, license info
     and credits
  ***************************************************************************/
 

commit 84ff9532e5308d04f97f032a434021ba1b01b6a3
Author: Hannes Reinecke <hare@suse.de>
Date:   Fri Feb 28 08:53:08 2020 +0100

    scsi: dpt_i2o: use scsi_host_complete_all_commands() to abort outstanding commands
    
    Rather than traversing all outstanding commands manually, use the
    scsi_host_complete_all_commands() helper to terminate all commands during
    reset.  With that we can drop the cmd_list usage from the midlayer.
    
    Link: https://lore.kernel.org/r/20200228075318.91255-4-hare@suse.de
    Reviewed-by: Christoph Hellwig <hch@lst.de>
    Reviewed-by: Bart Van Assche <bvanassche@acm.org>
    Signed-off-by: Hannes Reinecke <hare@suse.de>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/dpt_i2o.c b/drivers/scsi/dpt_i2o.c
index c30ace9f251e..ac27323ea135 100644
--- a/drivers/scsi/dpt_i2o.c
+++ b/drivers/scsi/dpt_i2o.c
@@ -817,7 +817,7 @@ static int adpt_hba_reset(adpt_hba* pHba)
 	}
 	pHba->state &= ~DPTI_STATE_RESET;
 
-	adpt_fail_posted_scbs(pHba);
+	scsi_host_complete_all_commands(pHba->host, DID_RESET);
 	return 0;	/* return success */
 }
 
@@ -2335,7 +2335,6 @@ static s32 adpt_scsi_host_alloc(adpt_hba* pHba, struct scsi_host_template *sht)
 	host->unique_id = (u32)sys_tbl_pa + pHba->unit;
 	host->sg_tablesize = pHba->sg_tablesize;
 	host->can_queue = pHba->post_fifo_size;
-	host->use_cmd_list = 1;
 
 	return 0;
 }
@@ -2646,23 +2645,6 @@ static s32 adpt_i2o_reparse_lct(adpt_hba* pHba)
 	return 0;
 }
 
-static void adpt_fail_posted_scbs(adpt_hba* pHba)
-{
-	struct scsi_cmnd* 	cmd = NULL;
-	struct scsi_device* 	d = NULL;
-
-	shost_for_each_device(d, pHba->host) {
-		unsigned long flags;
-		spin_lock_irqsave(&d->list_lock, flags);
-		list_for_each_entry(cmd, &d->cmd_list, list) {
-			cmd->result = (DID_OK << 16) | (QUEUE_FULL <<1);
-			cmd->scsi_done(cmd);
-		}
-		spin_unlock_irqrestore(&d->list_lock, flags);
-	}
-}
-
-
 /*============================================================================
  *  Routines from i2o subsystem
  *============================================================================

commit 22f0ba4a2825f9cb87c142f7fcd3bf3d496ded0f
Author: Hannes Reinecke <hare@suse.de>
Date:   Fri Feb 28 08:53:06 2020 +0100

    scsi: dpt_i2o: rename adpt_i2o_to_scsi() to adpt_i2o_scsi_complete()
    
    Rename the badly named function into adpt_i2o_scsi_complete(), and make it
    a void function as the return value is never used.  This also fixes a
    potential use-after-free as the return value might be evaluated from the
    command result after the command has been freed.
    
    Link: https://lore.kernel.org/r/20200228075318.91255-2-hare@suse.de
    Reviewed-by: Christoph Hellwig <hch@lst.de>
    Reviewed-by: Bart Van Assche <bvanassche@acm.org>
    Signed-off-by: Hannes Reinecke <hare@suse.de>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/dpt_i2o.c b/drivers/scsi/dpt_i2o.c
index abc74fd474dc..c30ace9f251e 100644
--- a/drivers/scsi/dpt_i2o.c
+++ b/drivers/scsi/dpt_i2o.c
@@ -2173,7 +2173,7 @@ static irqreturn_t adpt_isr(int irq, void *dev_id)
 						 readl(reply + 12) - 1);
 			if(cmd != NULL){
 				scsi_dma_unmap(cmd);
-				adpt_i2o_to_scsi(reply, cmd);
+				adpt_i2o_scsi_complete(reply, cmd);
 			}
 		}
 		writel(m, pHba->reply_port);
@@ -2341,7 +2341,7 @@ static s32 adpt_scsi_host_alloc(adpt_hba* pHba, struct scsi_host_template *sht)
 }
 
 
-static s32 adpt_i2o_to_scsi(void __iomem *reply, struct scsi_cmnd* cmd)
+static void adpt_i2o_scsi_complete(void __iomem *reply, struct scsi_cmnd *cmd)
 {
 	adpt_hba* pHba;
 	u32 hba_status;
@@ -2459,7 +2459,6 @@ static s32 adpt_i2o_to_scsi(void __iomem *reply, struct scsi_cmnd* cmd)
 	if(cmd->scsi_done != NULL){
 		cmd->scsi_done(cmd);
 	} 
-	return cmd->result;
 }
 
 

commit 2874c5fd284268364ece81a7bd936f3c8168e567
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon May 27 08:55:01 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 152
    
    Based on 1 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license as published by
      the free software foundation either version 2 of the license or at
      your option any later version
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-or-later
    
    has been chosen to replace the boilerplate/reference in 3029 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190527070032.746973796@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/scsi/dpt_i2o.c b/drivers/scsi/dpt_i2o.c
index a3afd1478ab6..abc74fd474dc 100644
--- a/drivers/scsi/dpt_i2o.c
+++ b/drivers/scsi/dpt_i2o.c
@@ -1,3 +1,4 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
 /***************************************************************************
                           dpti.c  -  description
                              -------------------
@@ -13,10 +14,6 @@
 
 /***************************************************************************
  *                                                                         *
- *   This program is free software; you can redistribute it and/or modify  *
- *   it under the terms of the GNU General Public License as published by  *
- *   the Free Software Foundation; either version 2 of the License, or     *
- *   (at your option) any later version.                                   *
  *                                                                         *
  ***************************************************************************/
 /***************************************************************************

commit d78e9a145a234163f51602a8b8b64f7d06062e56
Author: Colin Ian King <colin.king@canonical.com>
Date:   Wed Jan 23 12:53:19 2019 +0000

    scsi: dpt_i2o: clean up indentation issues, remove spaces
    
    There are several lines where the indentation has an extra space, fix this
    by removing the spaces.
    
    Signed-off-by: Colin Ian King <colin.king@canonical.com>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/dpt_i2o.c b/drivers/scsi/dpt_i2o.c
index abdc34affdf6..a3afd1478ab6 100644
--- a/drivers/scsi/dpt_i2o.c
+++ b/drivers/scsi/dpt_i2o.c
@@ -835,8 +835,8 @@ static void adpt_i2o_sys_shutdown(void)
 	adpt_hba *pHba, *pNext;
 	struct adpt_i2o_post_wait_data *p1, *old;
 
-	 printk(KERN_INFO"Shutting down Adaptec I2O controllers.\n");
-	 printk(KERN_INFO"   This could take a few minutes if there are many devices attached\n");
+	printk(KERN_INFO "Shutting down Adaptec I2O controllers.\n");
+	printk(KERN_INFO "   This could take a few minutes if there are many devices attached\n");
 	/* Delete all IOPs from the controller chain */
 	/* They should have already been released by the
 	 * scsi-core
@@ -859,7 +859,7 @@ static void adpt_i2o_sys_shutdown(void)
 //	spin_unlock_irqrestore(&adpt_post_wait_lock, flags);
 	adpt_post_wait_queue = NULL;
 
-	 printk(KERN_INFO "Adaptec I2O controllers down.\n");
+	printk(KERN_INFO "Adaptec I2O controllers down.\n");
 }
 
 static int adpt_install_hba(struct scsi_host_template* sht, struct pci_dev* pDev)
@@ -3390,7 +3390,7 @@ static int adpt_i2o_issue_params(int cmd, adpt_hba* pHba, int tid,
 		return -((res[1] >> 16) & 0xFF); /* -BlockStatus */
 	}
 
-	 return 4 + ((res[1] & 0x0000FFFF) << 2); /* bytes used in resblk */ 
+	return 4 + ((res[1] & 0x0000FFFF) << 2); /* bytes used in resblk */
 }
 
 
@@ -3463,8 +3463,8 @@ static int adpt_i2o_enable_hba(adpt_hba* pHba)
 
 static int adpt_i2o_systab_send(adpt_hba* pHba)
 {
-	 u32 msg[12];
-	 int ret;
+	u32 msg[12];
+	int ret;
 
 	msg[0] = I2O_MESSAGE_SIZE(12) | SGL_OFFSET_6;
 	msg[1] = I2O_CMD_SYS_TAB_SET<<24 | HOST_TID<<12 | ADAPTER_TID;

commit 470d19e202f02cbf47e85f619232889fd80397e5
Author: Hannes Reinecke <hare@suse.com>
Date:   Tue Feb 26 15:56:39 2019 +0100

    scsi: dpt_i2o: remove serial number usage
    
    Drop references to scsi_cmnd->serial_number.
    
    Signed-off-by: Hannes Reinecke <hare@suse.com>
    Reviewed-by: Bart Van Assche <bvanassche@acm.org>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/dpt_i2o.c b/drivers/scsi/dpt_i2o.c
index 70d1a18278af..abdc34affdf6 100644
--- a/drivers/scsi/dpt_i2o.c
+++ b/drivers/scsi/dpt_i2o.c
@@ -588,46 +588,6 @@ static int adpt_show_info(struct seq_file *m, struct Scsi_Host *host)
 	return 0;
 }
 
-/*
- *	Turn a struct scsi_cmnd * into a unique 32 bit 'context'.
- */
-static u32 adpt_cmd_to_context(struct scsi_cmnd *cmd)
-{
-	return (u32)cmd->serial_number;
-}
-
-/*
- *	Go from a u32 'context' to a struct scsi_cmnd * .
- *	This could probably be made more efficient.
- */
-static struct scsi_cmnd *
-	adpt_cmd_from_context(adpt_hba * pHba, u32 context)
-{
-	struct scsi_cmnd * cmd;
-	struct scsi_device * d;
-
-	if (context == 0)
-		return NULL;
-
-	spin_unlock(pHba->host->host_lock);
-	shost_for_each_device(d, pHba->host) {
-		unsigned long flags;
-		spin_lock_irqsave(&d->list_lock, flags);
-		list_for_each_entry(cmd, &d->cmd_list, list) {
-			if (((u32)cmd->serial_number == context)) {
-				spin_unlock_irqrestore(&d->list_lock, flags);
-				scsi_device_put(d);
-				spin_lock(pHba->host->host_lock);
-				return cmd;
-			}
-		}
-		spin_unlock_irqrestore(&d->list_lock, flags);
-	}
-	spin_lock(pHba->host->host_lock);
-
-	return NULL;
-}
-
 /*
  *	Turn a pointer to ioctl reply data into an u32 'context'
  */
@@ -685,9 +645,6 @@ static int adpt_abort(struct scsi_cmnd * cmd)
 	u32 msg[5];
 	int rcode;
 
-	if(cmd->serial_number == 0){
-		return FAILED;
-	}
 	pHba = (adpt_hba*) cmd->device->host->hostdata[0];
 	printk(KERN_INFO"%s: Trying to Abort\n",pHba->name);
 	if ((dptdevice = (void*) (cmd->device->hostdata)) == NULL) {
@@ -699,8 +656,9 @@ static int adpt_abort(struct scsi_cmnd * cmd)
 	msg[0] = FIVE_WORD_MSG_SIZE|SGL_OFFSET_0;
 	msg[1] = I2O_CMD_SCSI_ABORT<<24|HOST_TID<<12|dptdevice->tid;
 	msg[2] = 0;
-	msg[3]= 0; 
-	msg[4] = adpt_cmd_to_context(cmd);
+	msg[3]= 0;
+	/* Add 1 to avoid firmware treating it as invalid command */
+	msg[4] = cmd->request->tag + 1;
 	if (pHba->host)
 		spin_lock_irq(pHba->host->host_lock);
 	rcode = adpt_i2o_post_wait(pHba, msg, sizeof(msg), FOREVER);
@@ -2198,20 +2156,27 @@ static irqreturn_t adpt_isr(int irq, void *dev_id)
 				status = I2O_POST_WAIT_OK;
 			}
 			if(!(context & 0x40000000)) {
-				cmd = adpt_cmd_from_context(pHba,
-							readl(reply+12));
+				/*
+				 * The request tag is one less than the command tag
+				 * as the firmware might treat a 0 tag as invalid
+				 */
+				cmd = scsi_host_find_tag(pHba->host,
+							 readl(reply + 12) - 1);
 				if(cmd != NULL) {
 					printk(KERN_WARNING"%s: Apparent SCSI cmd in Post Wait Context - cmd=%p context=%x\n", pHba->name, cmd, context);
 				}
 			}
 			adpt_i2o_post_wait_complete(context, status);
 		} else { // SCSI message
-			cmd = adpt_cmd_from_context (pHba, readl(reply+12));
+			/*
+			 * The request tag is one less than the command tag
+			 * as the firmware might treat a 0 tag as invalid
+			 */
+			cmd = scsi_host_find_tag(pHba->host,
+						 readl(reply + 12) - 1);
 			if(cmd != NULL){
 				scsi_dma_unmap(cmd);
-				if(cmd->serial_number != 0) { // If not timedout
-					adpt_i2o_to_scsi(reply, cmd);
-				}
+				adpt_i2o_to_scsi(reply, cmd);
 			}
 		}
 		writel(m, pHba->reply_port);
@@ -2277,7 +2242,8 @@ static s32 adpt_scsi_to_i2o(adpt_hba* pHba, struct scsi_cmnd* cmd, struct adpt_d
 	// I2O_CMD_SCSI_EXEC
 	msg[1] = ((0xff<<24)|(HOST_TID<<12)|d->tid);
 	msg[2] = 0;
-	msg[3] = adpt_cmd_to_context(cmd);  /* Want SCSI control block back */
+	/* Add 1 to avoid firmware treating it as invalid command */
+	msg[3] = cmd->request->tag + 1;
 	// Our cards use the transaction context as the tag for queueing
 	// Adaptec/DPT Private stuff 
 	msg[4] = I2O_CMD_SCSI_EXEC|(DPT_ORGANIZATION_ID<<16);
@@ -2693,9 +2659,6 @@ static void adpt_fail_posted_scbs(adpt_hba* pHba)
 		unsigned long flags;
 		spin_lock_irqsave(&d->list_lock, flags);
 		list_for_each_entry(cmd, &d->cmd_list, list) {
-			if(cmd->serial_number == 0){
-				continue;
-			}
 			cmd->result = (DID_OK << 16) | (QUEUE_FULL <<1);
 			cmd->scsi_done(cmd);
 		}

commit 2a3d4eb8e228061c09d5ca8bf39e7f00c2091213
Author: Christoph Hellwig <hch@lst.de>
Date:   Thu Dec 13 16:17:02 2018 +0100

    scsi: flip the default on use_clustering
    
    Most SCSI drivers want to enable "clustering", that is merging of
    segments so that they might span more than a single page.  Remove the
    ENABLE_CLUSTERING define, and require drivers to explicitly set
    DISABLE_CLUSTERING to disable this feature.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/dpt_i2o.c b/drivers/scsi/dpt_i2o.c
index d5a474d1434f..70d1a18278af 100644
--- a/drivers/scsi/dpt_i2o.c
+++ b/drivers/scsi/dpt_i2o.c
@@ -3569,7 +3569,6 @@ static struct scsi_host_template driver_template = {
 	.slave_configure	= adpt_slave_configure,
 	.can_queue		= MAX_TO_IOP_MESSAGES,
 	.this_id		= 7,
-	.use_clustering		= ENABLE_CLUSTERING,
 };
 
 static int __init adpt_init(void)

commit c79cd9a24ef71c5d9b9185a20b387391abaa6cc7
Author: Christoph Hellwig <hch@lst.de>
Date:   Thu Oct 18 15:10:15 2018 +0200

    scsi: dpt_i2o: use dma_set_mask
    
    The driver currently uses pci_set_dma_mask despite otherwise using the
    generic DMA API.  Also move the dma_get_required_mask check before actually
    setting the dma mask, so that we don't end up with inconsistent settings in
    corner cases.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/dpt_i2o.c b/drivers/scsi/dpt_i2o.c
index 37de8fb186d7..d5a474d1434f 100644
--- a/drivers/scsi/dpt_i2o.c
+++ b/drivers/scsi/dpt_i2o.c
@@ -934,15 +934,15 @@ static int adpt_install_hba(struct scsi_host_template* sht, struct pci_dev* pDev
 	 *	See if we should enable dma64 mode.
 	 */
 	if (sizeof(dma_addr_t) > 4 &&
-	    pci_set_dma_mask(pDev, DMA_BIT_MASK(64)) == 0) {
-		if (dma_get_required_mask(&pDev->dev) > DMA_BIT_MASK(32))
-			dma64 = 1;
-	}
-	if (!dma64 && pci_set_dma_mask(pDev, DMA_BIT_MASK(32)) != 0)
+	    dma_get_required_mask(&pDev->dev) > DMA_BIT_MASK(32) &&
+	    dma_set_mask(&pDev->dev, DMA_BIT_MASK(64)) == 0)
+		dma64 = 1;
+
+	if (!dma64 && dma_set_mask(&pDev->dev, DMA_BIT_MASK(32)) != 0)
 		return -EINVAL;
 
 	/* adapter only supports message blocks below 4GB */
-	pci_set_consistent_dma_mask(pDev, DMA_BIT_MASK(32));
+	dma_set_coherent_mask(&pDev->dev, DMA_BIT_MASK(32));
 
 	base_addr0_phys = pci_resource_start(pDev,0);
 	hba_map0_area_size = pci_resource_len(pDev,0);

commit 60d6d22d85a79d194e9e1a13b831ffafa741cd6e
Author: Kees Cook <keescook@chromium.org>
Date:   Wed May 2 15:21:38 2018 -0700

    scsi: dpt_i2o: Remove VLA usage
    
    On the quest to remove all VLAs from the kernel[1] this moves the
    sg_list variable off the stack, as already done for other allocated
    buffers in adpt_i2o_passthru(). Additionally consolidates the error path
    for kfree().
    
    [1] https://lkml.kernel.org/r/CA+55aFzCG-zNmZwX4A2FQpadafLfEzK6CC=qPXydAacU1RqZWA@mail.gmail.com
    
    Signed-off-by: Kees Cook <keescook@chromium.org>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/dpt_i2o.c b/drivers/scsi/dpt_i2o.c
index 5ceea8da7bb6..37de8fb186d7 100644
--- a/drivers/scsi/dpt_i2o.c
+++ b/drivers/scsi/dpt_i2o.c
@@ -1706,7 +1706,7 @@ static int adpt_i2o_passthru(adpt_hba* pHba, u32 __user *arg)
 	u32 reply_size = 0;
 	u32 __user *user_msg = arg;
 	u32 __user * user_reply = NULL;
-	void *sg_list[pHba->sg_tablesize];
+	void **sg_list = NULL;
 	u32 sg_offset = 0;
 	u32 sg_count = 0;
 	int sg_index = 0;
@@ -1748,19 +1748,23 @@ static int adpt_i2o_passthru(adpt_hba* pHba, u32 __user *arg)
 	msg[2] = 0x40000000; // IOCTL context
 	msg[3] = adpt_ioctl_to_context(pHba, reply);
 	if (msg[3] == (u32)-1) {
-		kfree(reply);
-		return -EBUSY;
+		rcode = -EBUSY;
+		goto free;
 	}
 
-	memset(sg_list,0, sizeof(sg_list[0])*pHba->sg_tablesize);
+	sg_list = kcalloc(pHba->sg_tablesize, sizeof(*sg_list), GFP_KERNEL);
+	if (!sg_list) {
+		rcode = -ENOMEM;
+		goto free;
+	}
 	if(sg_offset) {
 		// TODO add 64 bit API
 		struct sg_simple_element *sg =  (struct sg_simple_element*) (msg+sg_offset);
 		sg_count = (size - sg_offset*4) / sizeof(struct sg_simple_element);
 		if (sg_count > pHba->sg_tablesize){
 			printk(KERN_DEBUG"%s:IOCTL SG List too large (%u)\n", pHba->name,sg_count);
-			kfree (reply);
-			return -EINVAL;
+			rcode = -EINVAL;
+			goto free;
 		}
 
 		for(i = 0; i < sg_count; i++) {
@@ -1879,7 +1883,6 @@ static int adpt_i2o_passthru(adpt_hba* pHba, u32 __user *arg)
 	if (rcode != -ETIME && rcode != -EINTR) {
 		struct sg_simple_element *sg =
 				(struct sg_simple_element*) (msg +sg_offset);
-		kfree (reply);
 		while(sg_index) {
 			if(sg_list[--sg_index]) {
 				dma_free_coherent(&pHba->pDev->dev,
@@ -1889,6 +1892,10 @@ static int adpt_i2o_passthru(adpt_hba* pHba, u32 __user *arg)
 			}
 		}
 	}
+
+free:
+	kfree(sg_list);
+	kfree(reply);
 	return rcode;
 }
 

commit 7709e9bdee96a904ebf18378c803a9288e10bb30
Author: Dan Carpenter <dan.carpenter@oracle.com>
Date:   Wed Mar 21 11:09:42 2018 +0300

    scsi: dpt_i2o: Use after free in I2ORESETCMD ioctl
    
    Here is another use after free if we reset the card.  The adpt_hba_reset()
    function frees "pHba" on error.
    
    Signed-off-by: Dan Carpenter <dan.carpenter@oracle.com>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/dpt_i2o.c b/drivers/scsi/dpt_i2o.c
index 6866975b25f3..5ceea8da7bb6 100644
--- a/drivers/scsi/dpt_i2o.c
+++ b/drivers/scsi/dpt_i2o.c
@@ -2051,13 +2051,16 @@ static int adpt_ioctl(struct inode *inode, struct file *file, uint cmd, ulong ar
 		}
 		break;
 		}
-	case I2ORESETCMD:
-		if(pHba->host)
-			spin_lock_irqsave(pHba->host->host_lock, flags);
+	case I2ORESETCMD: {
+		struct Scsi_Host *shost = pHba->host;
+
+		if (shost)
+			spin_lock_irqsave(shost->host_lock, flags);
 		adpt_hba_reset(pHba);
-		if(pHba->host)
-			spin_unlock_irqrestore(pHba->host->host_lock, flags);
+		if (shost)
+			spin_unlock_irqrestore(shost->host_lock, flags);
 		break;
+	}
 	case I2ORESCANCMD:
 		adpt_rescan(pHba);
 		break;

commit 052c220da392c4dcbc628852d04970447a315683
Merge: 3526dd0c7832 2e1f44f6ad80
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Thu Apr 5 15:05:53 2018 -0700

    Merge tag 'scsi-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/jejb/scsi
    
    Pull SCSI updates from James Bottomley:
     "This is mostly updates of the usual drivers: arcmsr, qla2xx, lpfc,
      ufs, mpt3sas, hisi_sas.
    
      In addition we have removed several really old drivers: sym53c416,
      NCR53c406a, fdomain, fdomain_cs and removed the old scsi_module.c
      initialization from all remaining drivers.
    
      Plus an assortment of bug fixes, initialization errors and other minor
      fixes"
    
    * tag 'scsi-for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/jejb/scsi: (168 commits)
      scsi: ufs: Add support for Auto-Hibernate Idle Timer
      scsi: ufs: sysfs: reworking of the rpm_lvl and spm_lvl entries
      scsi: qla2xxx: fx00 copypaste typo
      scsi: qla2xxx: fix error message on <qla2400
      scsi: smartpqi: update driver version
      scsi: smartpqi: workaround fw bug for oq deletion
      scsi: arcmsr: Change driver version to v1.40.00.05-20180309
      scsi: arcmsr: Sleep to avoid CPU stuck too long for waiting adapter ready
      scsi: arcmsr: Handle adapter removed due to thunderbolt cable disconnection.
      scsi: arcmsr: Rename ACB_F_BUS_HANG_ON to ACB_F_ADAPTER_REMOVED for adapter hot-plug
      scsi: qla2xxx: Update driver version to 10.00.00.06-k
      scsi: qla2xxx: Fix Async GPN_FT for FCP and FC-NVMe scan
      scsi: qla2xxx: Cleanup code to improve FC-NVMe error handling
      scsi: qla2xxx: Fix FC-NVMe IO abort during driver reset
      scsi: qla2xxx: Fix retry for PRLI RJT with reason of BUSY
      scsi: qla2xxx: Remove nvme_done_list
      scsi: qla2xxx: Return busy if rport going away
      scsi: qla2xxx: Fix n2n_ae flag to prevent dev_loss on PDB change
      scsi: qla2xxx: Add FC-NVMe abort processing
      scsi: qla2xxx: Add changes for devloss timeout in driver
      ...

commit 447a5647c9e7ab97780541f546a90e2620caa487
Author: Joe Perches <joe@perches.com>
Date:   Wed Mar 21 15:09:32 2018 -0700

    treewide: Align function definition open/close braces
    
    Some functions definitions have either the initial open brace and/or
    the closing brace outside of column 1.
    
    Move those braces to column 1.
    
    This allows various function analyzers like gnu complexity to work
    properly for these modified functions.
    
    Signed-off-by: Joe Perches <joe@perches.com>
    Acked-by: Andy Shevchenko <andy.shevchenko@gmail.com>
    Acked-by: Paul Moore <paul@paul-moore.com>
    Acked-by: Alex Deucher <alexander.deucher@amd.com>
    Acked-by: Dave Chinner <dchinner@redhat.com>
    Reviewed-by: Darrick J. Wong <darrick.wong@oracle.com>
    Acked-by: Alexandre Belloni <alexandre.belloni@free-electrons.com>
    Acked-by: Martin K. Petersen <martin.petersen@oracle.com>
    Acked-by: Takashi Iwai <tiwai@suse.de>
    Acked-by: Mauro Carvalho Chehab <mchehab@s-opensource.com>
    Acked-by: Rafael J. Wysocki <rafael.j.wysocki@intel.com>
    Acked-by: Nicolin Chen <nicoleotsuka@gmail.com>
    Acked-by: Martin K. Petersen <martin.petersen@oracle.com>
    Acked-by: Steven Rostedt (VMware) <rostedt@goodmis.org>
    Signed-off-by: Jiri Kosina <jkosina@suse.cz>

diff --git a/drivers/scsi/dpt_i2o.c b/drivers/scsi/dpt_i2o.c
index fd172b0890d3..a00d822e3142 100644
--- a/drivers/scsi/dpt_i2o.c
+++ b/drivers/scsi/dpt_i2o.c
@@ -3524,7 +3524,7 @@ static int adpt_i2o_systab_send(adpt_hba* pHba)
 #endif
 
 	return ret;	
- }
+}
 
 
 /*============================================================================

commit 10ff6be6de59e1c7d0bd5d899f896ce991f4fdc2
Author: Dan Carpenter <dan.carpenter@oracle.com>
Date:   Mon Mar 19 13:34:01 2018 +0300

    scsi: dpt_i2o: use after free in __adpt_reset()
    
    In __adpt_reset() the problem is that adpt_hba_reset() frees "pHba" on
    error but we dereference it to print the name in the error message.
    
    Signed-off-by: Dan Carpenter <dan.carpenter@oracle.com>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/dpt_i2o.c b/drivers/scsi/dpt_i2o.c
index 67379e4d0bf9..35d45903ed2e 100644
--- a/drivers/scsi/dpt_i2o.c
+++ b/drivers/scsi/dpt_i2o.c
@@ -799,14 +799,17 @@ static int __adpt_reset(struct scsi_cmnd* cmd)
 {
 	adpt_hba* pHba;
 	int rcode;
+	char name[32];
+
 	pHba = (adpt_hba*)cmd->device->host->hostdata[0];
-	printk(KERN_WARNING"%s: Hba Reset: scsi id %d: tid: %d\n",pHba->name,cmd->device->channel,pHba->channel[cmd->device->channel].tid );
+	strncpy(name, pHba->name, sizeof(name));
+	printk(KERN_WARNING"%s: Hba Reset: scsi id %d: tid: %d\n", name, cmd->device->channel, pHba->channel[cmd->device->channel].tid);
 	rcode =  adpt_hba_reset(pHba);
 	if(rcode == 0){
-		printk(KERN_WARNING"%s: HBA reset complete\n",pHba->name);
+		printk(KERN_WARNING"%s: HBA reset complete\n", name);
 		return SUCCESS;
 	} else {
-		printk(KERN_WARNING"%s: HBA reset failed (%x)\n",pHba->name, rcode);
+		printk(KERN_WARNING"%s: HBA reset failed (%x)\n", name, rcode);
 		return FAILED;
 	}
 }

commit 24268fd1ad3213079f1af09359b4243fffa95869
Author: Dan Carpenter <dan.carpenter@oracle.com>
Date:   Mon Mar 19 13:33:03 2018 +0300

    scsi: dpt_i2o: use after free in adpt_release()
    
    The scsi_host_put() function frees "pHba" and then we dereference it on
    the next line when we do "scsi_host_put(pHba->host);".
    
    [mkp: included fix from hch]
    
    Fixes: 38e09e3bb056 ("scsi: dpt_i2o: stop using scsi_unregister")
    Signed-off-by: Dan Carpenter <dan.carpenter@oracle.com>
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/dpt_i2o.c b/drivers/scsi/dpt_i2o.c
index 3c667b23a801..67379e4d0bf9 100644
--- a/drivers/scsi/dpt_i2o.c
+++ b/drivers/scsi/dpt_i2o.c
@@ -304,10 +304,12 @@ static int adpt_detect(struct scsi_host_template* sht)
 
 static void adpt_release(adpt_hba *pHba)
 {
-	scsi_remove_host(pHba->host);
+	struct Scsi_Host *shost = pHba->host;
+
+	scsi_remove_host(shost);
 //	adpt_i2o_quiesce_hba(pHba);
 	adpt_i2o_delete_hba(pHba);
-	scsi_host_put(pHba->host);
+	scsi_host_put(shost);
 }
 
 

commit 38e09e3bb056b90d70308fe1e3db387ef976ce6e
Author: Christoph Hellwig <hch@lst.de>
Date:   Wed Mar 14 12:48:23 2018 +0100

    scsi: dpt_i2o: stop using scsi_unregister
    
    dpt_i2o doesn't use scsi_register, so it should not use scsi_unregister
    either.  Also refactor the module exit path to make a little more sense.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/dpt_i2o.c b/drivers/scsi/dpt_i2o.c
index fd172b0890d3..3c667b23a801 100644
--- a/drivers/scsi/dpt_i2o.c
+++ b/drivers/scsi/dpt_i2o.c
@@ -302,16 +302,12 @@ static int adpt_detect(struct scsi_host_template* sht)
 }
 
 
-/*
- * scsi_unregister will be called AFTER we return.
- */
-static int adpt_release(struct Scsi_Host *host)
+static void adpt_release(adpt_hba *pHba)
 {
-	adpt_hba* pHba = (adpt_hba*) host->hostdata[0];
+	scsi_remove_host(pHba->host);
 //	adpt_i2o_quiesce_hba(pHba);
 	adpt_i2o_delete_hba(pHba);
-	scsi_unregister(host);
-	return 0;
+	scsi_host_put(pHba->host);
 }
 
 
@@ -1087,8 +1083,6 @@ static void adpt_i2o_delete_hba(adpt_hba* pHba)
 
 
 	mutex_lock(&adpt_configuration_lock);
-	// scsi_unregister calls our adpt_release which
-	// does a quiese
 	if(pHba->host){
 		free_irq(pHba->host->irq, pHba);
 	}
@@ -3595,11 +3589,9 @@ static void __exit adpt_exit(void)
 {
 	adpt_hba	*pHba, *next;
 
-	for (pHba = hba_chain; pHba; pHba = pHba->next)
-		scsi_remove_host(pHba->host);
 	for (pHba = hba_chain; pHba; pHba = next) {
 		next = pHba->next;
-		adpt_release(pHba->host);
+		adpt_release(pHba);
 	}
 }
 

commit 0b7250f93f02a8aaa80146c34c08e4596f0a1e1d
Author: Colin Ian King <colin.king@canonical.com>
Date:   Wed Aug 9 11:17:41 2017 +0100

    scsi: dpt_i2o: remove redundant null check on array device
    
    The null check on pHba->channel[chan].device is redundant because
    device is an array and hence can never be null. Remove the check.
    
    Detected by CoverityScan, CID#115362 ("Array compared against 0")
    
    Signed-off-by: Colin Ian King <colin.king@canonical.com>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/dpt_i2o.c b/drivers/scsi/dpt_i2o.c
index 256dd6791fcc..fd172b0890d3 100644
--- a/drivers/scsi/dpt_i2o.c
+++ b/drivers/scsi/dpt_i2o.c
@@ -1169,11 +1169,6 @@ static struct adpt_device* adpt_find_device(adpt_hba* pHba, u32 chan, u32 id, u6
 	if(chan < 0 || chan >= MAX_CHANNEL)
 		return NULL;
 	
-	if( pHba->channel[chan].device == NULL){
-		printk(KERN_DEBUG"Adaptec I2O RAID: Trying to find device before they are allocated\n");
-		return NULL;
-	}
-
 	d = pHba->channel[chan].device[id];
 	if(!d || d->tid == 0) {
 		return NULL;

commit 19099dc393f3ca1fd9690f914e50278cf2aee78a
Author: Dan Carpenter <dan.carpenter@oracle.com>
Date:   Fri Dec 16 12:35:39 2016 +0300

    scsi: dpt_i2o: double free if adpt_i2o_online_hba() fails
    
    There are two places where adpt_i2o_online_hba() is called.  Both
    callers call adpt_i2o_delete_hba(pHba) if adpt_i2o_online_hba() fails
    and since we also free it here that causes a double free bug.
    
    Signed-off-by: Dan Carpenter <dan.carpenter@oracle.com>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/dpt_i2o.c b/drivers/scsi/dpt_i2o.c
index 5f75e638ec95..256dd6791fcc 100644
--- a/drivers/scsi/dpt_i2o.c
+++ b/drivers/scsi/dpt_i2o.c
@@ -2768,16 +2768,12 @@ static int adpt_i2o_activate_hba(adpt_hba* pHba)
  
 static int adpt_i2o_online_hba(adpt_hba* pHba)
 {
-	if (adpt_i2o_systab_send(pHba) < 0) {
-		adpt_i2o_delete_hba(pHba);
+	if (adpt_i2o_systab_send(pHba) < 0)
 		return -1;
-	}
 	/* In READY state */
 
-	if (adpt_i2o_enable_hba(pHba) < 0) {
-		adpt_i2o_delete_hba(pHba);
+	if (adpt_i2o_enable_hba(pHba) < 0)
 		return -1;
-	}
 
 	/* In OPERATIONAL state  */
 	return 0;

commit 7c0f6ba682b9c7632072ffbedf8d328c8f3c42ba
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sat Dec 24 11:46:01 2016 -0800

    Replace <asm/uaccess.h> with <linux/uaccess.h> globally
    
    This was entirely automated, using the script by Al:
    
      PATT='^[[:blank:]]*#[[:blank:]]*include[[:blank:]]*<asm/uaccess.h>'
      sed -i -e "s!$PATT!#include <linux/uaccess.h>!" \
            $(git grep -l "$PATT"|grep -v ^include/linux/uaccess.h)
    
    to do the replacement at the end of the merge window.
    
    Requested-by: Al Viro <viro@zeniv.linux.org.uk>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/scsi/dpt_i2o.c b/drivers/scsi/dpt_i2o.c
index 27c0dce22e72..5f75e638ec95 100644
--- a/drivers/scsi/dpt_i2o.c
+++ b/drivers/scsi/dpt_i2o.c
@@ -37,7 +37,7 @@ MODULE_DESCRIPTION("Adaptec I2O RAID Driver");
 ////////////////////////////////////////////////////////////////
 
 #include <linux/ioctl.h>	/* For SCSI-Passthrough */
-#include <asm/uaccess.h>
+#include <linux/uaccess.h>
 
 #include <linux/stat.h>
 #include <linux/slab.h>		/* for kmalloc() */

commit af25756de972d0f05246f9e6869f395ee0302c02
Author: Dan Carpenter <dan.carpenter@oracle.com>
Date:   Wed Nov 30 22:36:48 2016 +0300

    scsi: dpt_i2o: double free on error path
    
    We recently introduced a kfree() in the caller for this function.
    That's where, logically, you would think the kfree() should be.
    Unfortunately the code was just ugly and not buggy so the static checker
    warning was a false postive and introduced a double free.
    
    I've removed the old kfree() and left the new one.
    
    Fixes: 021e2927586d ("scsi: dpt_i2o: Add a missing call to kfree")
    Signed-off-by: Dan Carpenter <dan.carpenter@oracle.com>
    Reviewed-by: Quentin Lambert <lambert.quentin@gmail.com>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/dpt_i2o.c b/drivers/scsi/dpt_i2o.c
index f88b3d216a88..27c0dce22e72 100644
--- a/drivers/scsi/dpt_i2o.c
+++ b/drivers/scsi/dpt_i2o.c
@@ -651,7 +651,6 @@ static u32 adpt_ioctl_to_context(adpt_hba * pHba, void *reply)
 	}
 	spin_unlock_irqrestore(pHba->host->host_lock, flags);
 	if (i >= nr) {
-		kfree (reply);
 		printk(KERN_WARNING"%s: Too many outstanding "
 				"ioctl commands\n", pHba->name);
 		return (u32)-1;

commit 021e2927586dafc0a682b7f95d75bd06cc4fb703
Author: Quentin Lambert <lambert.quentin@gmail.com>
Date:   Sat Nov 19 18:42:34 2016 +0100

    scsi: dpt_i2o: Add a missing call to kfree
    
    Most error branches following the call to kzalloc contain a call to
    kfree. This patch add these calls where they are missing.
    
    This issue was found with Hector.
    
    Signed-off-by: Quentin Lambert <lambert.quentin@gmail.com>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/dpt_i2o.c b/drivers/scsi/dpt_i2o.c
index d84004b5d3e0..f88b3d216a88 100644
--- a/drivers/scsi/dpt_i2o.c
+++ b/drivers/scsi/dpt_i2o.c
@@ -1754,8 +1754,10 @@ static int adpt_i2o_passthru(adpt_hba* pHba, u32 __user *arg)
 	sg_offset = (msg[0]>>4)&0xf;
 	msg[2] = 0x40000000; // IOCTL context
 	msg[3] = adpt_ioctl_to_context(pHba, reply);
-	if (msg[3] == (u32)-1)
+	if (msg[3] == (u32)-1) {
+		kfree(reply);
 		return -EBUSY;
+	}
 
 	memset(sg_list,0, sizeof(sg_list[0])*pHba->sg_tablesize);
 	if(sg_offset) {

commit d0799621349dedc8c866d6405302df8eba38f410
Author: Colin Ian King <colin.king@canonical.com>
Date:   Mon Nov 7 16:38:57 2016 +0000

    scsi: fix spelling mistake in error message
    
    Trivial fix to spelling mistake "operatio" to "operation" in critical
    error message
    
    Signed-off-by: Colin Ian King <colin.king@canonical.com>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/dpt_i2o.c b/drivers/scsi/dpt_i2o.c
index 21c8d210c456..d84004b5d3e0 100644
--- a/drivers/scsi/dpt_i2o.c
+++ b/drivers/scsi/dpt_i2o.c
@@ -3350,7 +3350,7 @@ static int adpt_i2o_query_scalar(adpt_hba* pHba, int tid,
 	if (opblk_va == NULL) {
 		dma_free_coherent(&pHba->pDev->dev, sizeof(u8) * (8+buflen),
 			resblk_va, resblk_pa);
-		printk(KERN_CRIT "%s: query operatio failed; Out of memory.\n",
+		printk(KERN_CRIT "%s: query operation failed; Out of memory.\n",
 			pHba->name);
 		return -ENOMEM;
 	}

commit f50abb9b63b1d8773e1ce32115701c06416e6f91
Author: Sudip Mukherjee <sudipm.mukherjee@gmail.com>
Date:   Thu Feb 18 13:59:13 2016 +0530

    dpt_i2o: fix build warning
    
    We were getting build warning about:
    drivers/scsi/dpt_i2o.c:183:29: warning: 'dptids' defined but not used
    
    dptids[] is only used in the MODULE_DEVICE_TABLE so when MODULE is not
    defined then dptids[] becomes unused.
    
    Signed-off-by: Sudip Mukherjee <sudip@vectorindia.org>
    Reviewed-by: Johannes Thumshirn <jthumshirn@suse.de>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/dpt_i2o.c b/drivers/scsi/dpt_i2o.c
index d4cda5e9600e..21c8d210c456 100644
--- a/drivers/scsi/dpt_i2o.c
+++ b/drivers/scsi/dpt_i2o.c
@@ -180,11 +180,14 @@ static u8 adpt_read_blink_led(adpt_hba* host)
  *============================================================================
  */
 
+#ifdef MODULE
 static struct pci_device_id dptids[] = {
 	{ PCI_DPT_VENDOR_ID, PCI_DPT_DEVICE_ID, PCI_ANY_ID, PCI_ANY_ID,},
 	{ PCI_DPT_VENDOR_ID, PCI_DPT_RAPTOR_DEVICE_ID, PCI_ANY_ID, PCI_ANY_ID,},
 	{ 0, }
 };
+#endif
+
 MODULE_DEVICE_TABLE(pci,dptids);
 
 static int adpt_detect(struct scsi_host_template* sht)

commit ba3e127ec105e790eeec4034d9769e018e4a1b54
Author: Brian Gerst <brgerst@gmail.com>
Date:   Wed Jul 29 01:41:21 2015 -0400

    x86/vm86: Clean up vm86.h includes
    
    vm86.h was being implicitly included in alot of places via
    processor.h, which in turn got it from math_emu.h.  Break that
    chain and explicitly include vm86.h in all files that need it.
    Also remove unused vm86 field from math_emu_info.
    
    Signed-off-by: Brian Gerst <brgerst@gmail.com>
    Cc: Andy Lutomirski <luto@amacapital.net>
    Cc: Borislav Petkov <bp@alien8.de>
    Cc: Denys Vlasenko <dvlasenk@redhat.com>
    Cc: H. Peter Anvin <hpa@zytor.com>
    Cc: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: Peter Zijlstra <peterz@infradead.org>
    Cc: Thomas Gleixner <tglx@linutronix.de>
    Link: http://lkml.kernel.org/r/1438148483-11932-7-git-send-email-brgerst@gmail.com
    [ Fixed build failure. ]
    Signed-off-by: Ingo Molnar <mingo@kernel.org>

diff --git a/drivers/scsi/dpt_i2o.c b/drivers/scsi/dpt_i2o.c
index f35ed53adaac..d4cda5e9600e 100644
--- a/drivers/scsi/dpt_i2o.c
+++ b/drivers/scsi/dpt_i2o.c
@@ -1924,6 +1924,9 @@ static void adpt_alpha_info(sysInfo_S* si)
 #endif
 
 #if defined __i386__
+
+#include <uapi/asm/vm86.h>
+
 static void adpt_i386_info(sysInfo_S* si)
 {
 	// This is all the info we need for now

commit b84b1d522f979fb53ad347605e24b2940fa2ad99
Author: Hannes Reinecke <hare@suse.de>
Date:   Wed Apr 29 08:57:34 2015 +0200

    scsi: Do not set cmd_per_lun to 1 in the host template
    
    '0' is now used as the default cmd_per_lun value,
    so there's no need to explicitly set it to '1' in the
    host template.
    
    Signed-off-by: Hannes Reinecke <hare@suse.de>
    Reviewed-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: James Bottomley <JBottomley@Odin.com>

diff --git a/drivers/scsi/dpt_i2o.c b/drivers/scsi/dpt_i2o.c
index 2806cfbec2b9..f35ed53adaac 100644
--- a/drivers/scsi/dpt_i2o.c
+++ b/drivers/scsi/dpt_i2o.c
@@ -3562,7 +3562,6 @@ static struct scsi_host_template driver_template = {
 	.slave_configure	= adpt_slave_configure,
 	.can_queue		= MAX_TO_IOP_MESSAGES,
 	.this_id		= 7,
-	.cmd_per_lun		= 1,
 	.use_clustering		= ENABLE_CLUSTERING,
 };
 

commit 91c40f24faadd977ee9209fee6a760e72a50d19c
Author: Rasmus Villemoes <linux@rasmusvillemoes.dk>
Date:   Wed Dec 3 00:10:52 2014 +0100

    scsi: replace seq_printf with seq_puts
    
    Using seq_printf to print a simple string is a lot more expensive than
    it needs to be, since seq_puts exists. Replace seq_printf with
    seq_puts when possible.
    
    Signed-off-by: Rasmus Villemoes <linux@rasmusvillemoes.dk>
    Reviewed-by: Finn Thain <fthain@telegraphics.com.au>
    Signed-off-by: Christoph Hellwig <hch@lst.de>

diff --git a/drivers/scsi/dpt_i2o.c b/drivers/scsi/dpt_i2o.c
index 0bf976936a10..2806cfbec2b9 100644
--- a/drivers/scsi/dpt_i2o.c
+++ b/drivers/scsi/dpt_i2o.c
@@ -568,7 +568,7 @@ static int adpt_show_info(struct seq_file *m, struct Scsi_Host *host)
 	seq_printf(m, "\tpost fifo size  = %d\n\treply fifo size = %d\n\tsg table size   = %d\n\n",
 			host->can_queue, (int) pHba->reply_fifo_size , host->sg_tablesize);
 
-	seq_printf(m, "Devices:\n");
+	seq_puts(m, "Devices:\n");
 	for(chan = 0; chan < MAX_CHANNEL; chan++) {
 		for(id = 0; id < MAX_ID; id++) {
 			d = pHba->channel[chan].device[id];

commit db5ed4dfd5dd0142ec36ff7b335e0ec3b836b3e6
Author: Christoph Hellwig <hch@lst.de>
Date:   Thu Nov 13 15:08:42 2014 +0100

    scsi: drop reason argument from ->change_queue_depth
    
    Drop the now unused reason argument from the ->change_queue_depth method.
    Also add a return value to scsi_adjust_queue_depth, and rename it to
    scsi_change_queue_depth now that it can be used as the default
    ->change_queue_depth implementation.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Reviewed-by: Mike Christie <michaelc@cs.wisc.edu>
    Reviewed-by: Hannes Reinecke <hare@suse.de>

diff --git a/drivers/scsi/dpt_i2o.c b/drivers/scsi/dpt_i2o.c
index 1af8d54bcded..0bf976936a10 100644
--- a/drivers/scsi/dpt_i2o.c
+++ b/drivers/scsi/dpt_i2o.c
@@ -415,7 +415,7 @@ static int adpt_slave_configure(struct scsi_device * device)
 	pHba = (adpt_hba *) host->hostdata[0];
 
 	if (host->can_queue && device->tagged_supported) {
-		scsi_adjust_queue_depth(device,
+		scsi_change_queue_depth(device,
 				host->can_queue - 1);
 	}
 	return 0;

commit c8b09f6fb67df7fc1b51ced1037fa9b677428149
Author: Christoph Hellwig <hch@lst.de>
Date:   Mon Nov 3 20:15:14 2014 +0100

    scsi: don't set tagging state from scsi_adjust_queue_depth
    
    Remove the tagged argument from scsi_adjust_queue_depth, and just let it
    handle the queue depth.  For most drivers those two are fairly separate,
    given that most modern drivers don't care about the SCSI "tagged" status
    of a command at all, and many old drivers allow queuing of multiple
    untagged commands in the driver.
    
    Instead we start out with the ->simple_tags flag set before calling
    ->slave_configure, which is how all drivers actually looking at
    ->simple_tags except for one worke anyway.  The one other case looks
    broken, but I've kept the behavior as-is for now.
    
    Except for that we only change ->simple_tags from the ->change_queue_type,
    and when rejecting a tag message in a single driver, so keeping this
    churn out of scsi_adjust_queue_depth is a clear win.
    
    Now that the usage of scsi_adjust_queue_depth is more obvious we can
    also remove all the trivial instances in ->slave_alloc or ->slave_configure
    that just set it to the cmd_per_lun default.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Reviewed-by: Mike Christie <michaelc@cs.wisc.edu>
    Reviewed-by: Hannes Reinecke <hare@suse.de>
    Reviewed-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/dpt_i2o.c b/drivers/scsi/dpt_i2o.c
index 072f0ec2851e..1af8d54bcded 100644
--- a/drivers/scsi/dpt_i2o.c
+++ b/drivers/scsi/dpt_i2o.c
@@ -415,10 +415,8 @@ static int adpt_slave_configure(struct scsi_device * device)
 	pHba = (adpt_hba *) host->hostdata[0];
 
 	if (host->can_queue && device->tagged_supported) {
-		scsi_adjust_queue_depth(device, MSG_SIMPLE_TAG,
+		scsi_adjust_queue_depth(device,
 				host->can_queue - 1);
-	} else {
-		scsi_adjust_queue_depth(device, 0, 1);
 	}
 	return 0;
 }

commit 64bdcbc449105377dd60c8da97cfc1663b39562c
Author: Kashyap.Desai@avagotech.com <Kashyap.Desai@avagotech.com>
Date:   Wed Aug 20 19:24:33 2014 +0530

    scsi: add use_cmd_list flag
    
    Add a use_cmd_list flag in struct Scsi_Host to request keeping track of
    all outstanding commands per device.
    
    Default behaviour is not to keep track of cmd_list per sdev, as this may
    introduce lock contention. (overhead is more on multi-node NUMA.), and
    only enable it on the two drivers that need it.
    
    Signed-off-by: Kashyap Desai <kashyap.desai@avagotech.com>
    Reviewed-by: Martin K. Petersen <martin.petersen@oracle.com>
    Reviewed-by: Bart Van Assche <bvanassche@acm.org>
    Signed-off-by: Christoph Hellwig <hch@lst.de>

diff --git a/drivers/scsi/dpt_i2o.c b/drivers/scsi/dpt_i2o.c
index 67283ef418ac..072f0ec2851e 100644
--- a/drivers/scsi/dpt_i2o.c
+++ b/drivers/scsi/dpt_i2o.c
@@ -2363,6 +2363,7 @@ static s32 adpt_scsi_host_alloc(adpt_hba* pHba, struct scsi_host_template *sht)
 	host->unique_id = (u32)sys_tbl_pa + pHba->unit;
 	host->sg_tablesize = pHba->sg_tablesize;
 	host->can_queue = pHba->post_fifo_size;
+	host->use_cmd_list = 1;
 
 	return 0;
 }

commit 9cb78c16f5dadefd8dc5ba0ae5a2f26cd59419b3
Author: Hannes Reinecke <hare@suse.de>
Date:   Wed Jun 25 15:27:36 2014 +0200

    scsi: use 64-bit LUNs
    
    The SCSI standard defines 64-bit values for LUNs, and large arrays
    employing large or hierarchical LUN numbers become more and more
    common.
    
    So update the linux SCSI stack to use 64-bit LUN numbers.
    
    Signed-off-by: Hannes Reinecke <hare@suse.de>
    Reviewed-by: Christoph Hellwig <hch@infradead.org>
    Reviewed-by: Ewan Milne <emilne@redhat.com>
    Signed-off-by: Christoph Hellwig <hch@lst.de>

diff --git a/drivers/scsi/dpt_i2o.c b/drivers/scsi/dpt_i2o.c
index c0ae8fa57a3b..67283ef418ac 100644
--- a/drivers/scsi/dpt_i2o.c
+++ b/drivers/scsi/dpt_i2o.c
@@ -459,7 +459,7 @@ static int adpt_queue_lck(struct scsi_cmnd * cmd, void (*done) (struct scsi_cmnd
 		 * to the device structure.  This should be a TEST_UNIT_READY
 		 * command from scan_scsis_single.
 		 */
-		if ((pDev = adpt_find_device(pHba, (u32)cmd->device->channel, (u32)cmd->device->id, (u32)cmd->device->lun)) == NULL) {
+		if ((pDev = adpt_find_device(pHba, (u32)cmd->device->channel, (u32)cmd->device->id, cmd->device->lun)) == NULL) {
 			// TODO: if any luns are at this bus, scsi id then fake a TEST_UNIT_READY and INQUIRY response 
 			// with type 7F (for all luns less than the max for this bus,id) so the lun scan will continue.
 			cmd->result = (DID_NO_CONNECT << 16);
@@ -579,8 +579,8 @@ static int adpt_show_info(struct seq_file *m, struct Scsi_Host *host)
 				seq_printf(m," Rev: %-8.8s\n", d->pScsi_dev->rev);
 
 				unit = d->pI2o_dev->lct_data.tid;
-				seq_printf(m, "\tTID=%d, (Channel=%d, Target=%d, Lun=%d)  (%s)\n\n",
-					       unit, (int)d->scsi_channel, (int)d->scsi_id, (int)d->scsi_lun,
+				seq_printf(m, "\tTID=%d, (Channel=%d, Target=%d, Lun=%llu)  (%s)\n\n",
+					       unit, (int)d->scsi_channel, (int)d->scsi_id, d->scsi_lun,
 					       scsi_device_online(d->pScsi_dev)? "online":"offline"); 
 				d = d->next_lun;
 			}
@@ -1162,7 +1162,7 @@ static void adpt_i2o_delete_hba(adpt_hba* pHba)
 	}
 }
 
-static struct adpt_device* adpt_find_device(adpt_hba* pHba, u32 chan, u32 id, u32 lun)
+static struct adpt_device* adpt_find_device(adpt_hba* pHba, u32 chan, u32 id, u64 lun)
 {
 	struct adpt_device* d;
 
@@ -1462,7 +1462,7 @@ static int adpt_i2o_parse_lct(adpt_hba* pHba)
 	i2o_lct *lct = pHba->lct;
 	u8 bus_no = 0;
 	s16 scsi_id;
-	s16 scsi_lun;
+	u64 scsi_lun;
 	u32 buf[10]; // larger than 7, or 8 ...
 	struct adpt_device* pDev; 
 	
@@ -1496,7 +1496,7 @@ static int adpt_i2o_parse_lct(adpt_hba* pHba)
 			}
 			bus_no = buf[0]>>16;
 			scsi_id = buf[1];
-			scsi_lun = (buf[2]>>8 )&0xff;
+			scsi_lun = scsilun_to_int((struct scsi_lun *)&buf[2]);
 			if(bus_no >= MAX_CHANNEL) {	// Something wrong skip it
 				printk(KERN_WARNING"%s: Channel number %d out of range \n", pHba->name, bus_no);
 				continue;
@@ -1571,7 +1571,7 @@ static int adpt_i2o_parse_lct(adpt_hba* pHba)
 			if(adpt_i2o_query_scalar(pHba, tid, 0x8000, -1, buf, 32)>=0) {
 				bus_no = buf[0]>>16;
 				scsi_id = buf[1];
-				scsi_lun = (buf[2]>>8 )&0xff;
+				scsi_lun = scsilun_to_int((struct scsi_lun *)&buf[2]);
 				if(bus_no >= MAX_CHANNEL) {	// Something wrong skip it
 					continue;
 				}
@@ -2407,8 +2407,8 @@ static s32 adpt_i2o_to_scsi(void __iomem *reply, struct scsi_cmnd* cmd)
 		case I2O_SCSI_DSC_COMMAND_TIMEOUT:
 		case I2O_SCSI_DSC_NO_ADAPTER:
 		case I2O_SCSI_DSC_RESOURCE_UNAVAILABLE:
-			printk(KERN_WARNING"%s: SCSI Timeout-Device (%d,%d,%d) hba status=0x%x, dev status=0x%x, cmd=0x%x\n",
-				pHba->name, (u32)cmd->device->channel, (u32)cmd->device->id, (u32)cmd->device->lun, hba_status, dev_status, cmd->cmnd[0]);
+			printk(KERN_WARNING"%s: SCSI Timeout-Device (%d,%d,%llu) hba status=0x%x, dev status=0x%x, cmd=0x%x\n",
+				pHba->name, (u32)cmd->device->channel, (u32)cmd->device->id, cmd->device->lun, hba_status, dev_status, cmd->cmnd[0]);
 			cmd->result = (DID_TIME_OUT << 16);
 			break;
 		case I2O_SCSI_DSC_ADAPTER_BUSY:
@@ -2447,8 +2447,8 @@ static s32 adpt_i2o_to_scsi(void __iomem *reply, struct scsi_cmnd* cmd)
 		case I2O_SCSI_DSC_QUEUE_FROZEN:
 		case I2O_SCSI_DSC_REQUEST_INVALID:
 		default:
-			printk(KERN_WARNING"%s: SCSI error %0x-Device(%d,%d,%d) hba_status=0x%x, dev_status=0x%x, cmd=0x%x\n",
-				pHba->name, detailed_status & I2O_SCSI_DSC_MASK, (u32)cmd->device->channel, (u32)cmd->device->id, (u32)cmd->device->lun,
+			printk(KERN_WARNING"%s: SCSI error %0x-Device(%d,%d,%llu) hba_status=0x%x, dev_status=0x%x, cmd=0x%x\n",
+				pHba->name, detailed_status & I2O_SCSI_DSC_MASK, (u32)cmd->device->channel, (u32)cmd->device->id, cmd->device->lun,
 			       hba_status, dev_status, cmd->cmnd[0]);
 			cmd->result = (DID_ERROR << 16);
 			break;
@@ -2464,8 +2464,8 @@ static s32 adpt_i2o_to_scsi(void __iomem *reply, struct scsi_cmnd* cmd)
 			   cmd->sense_buffer[2] == DATA_PROTECT ){
 				/* This is to handle an array failed */
 				cmd->result = (DID_TIME_OUT << 16);
-				printk(KERN_WARNING"%s: SCSI Data Protect-Device (%d,%d,%d) hba_status=0x%x, dev_status=0x%x, cmd=0x%x\n",
-					pHba->name, (u32)cmd->device->channel, (u32)cmd->device->id, (u32)cmd->device->lun, 
+				printk(KERN_WARNING"%s: SCSI Data Protect-Device (%d,%d,%llu) hba_status=0x%x, dev_status=0x%x, cmd=0x%x\n",
+					pHba->name, (u32)cmd->device->channel, (u32)cmd->device->id, cmd->device->lun,
 					hba_status, dev_status, cmd->cmnd[0]);
 
 			}
@@ -2476,8 +2476,8 @@ static s32 adpt_i2o_to_scsi(void __iomem *reply, struct scsi_cmnd* cmd)
 		 * for a limitted number of retries.
 		 */
 		cmd->result = (DID_TIME_OUT << 16);
-		printk(KERN_WARNING"%s: I2O MSG_FAIL - Device (%d,%d,%d) tid=%d, cmd=0x%x\n",
-			pHba->name, (u32)cmd->device->channel, (u32)cmd->device->id, (u32)cmd->device->lun,
+		printk(KERN_WARNING"%s: I2O MSG_FAIL - Device (%d,%d,%llu) tid=%d, cmd=0x%x\n",
+			pHba->name, (u32)cmd->device->channel, (u32)cmd->device->id, cmd->device->lun,
 			((struct adpt_device*)(cmd->device->hostdata))->tid, cmd->cmnd[0]);
 	}
 
@@ -2517,7 +2517,7 @@ static s32 adpt_i2o_reparse_lct(adpt_hba* pHba)
 	i2o_lct *lct = pHba->lct;
 	u8 bus_no = 0;
 	s16 scsi_id;
-	s16 scsi_lun;
+	u64 scsi_lun;
 	u32 buf[10]; // at least 8 u32's
 	struct adpt_device* pDev = NULL;
 	struct i2o_device* pI2o_dev = NULL;
@@ -2564,7 +2564,7 @@ static s32 adpt_i2o_reparse_lct(adpt_hba* pHba)
 			}
 
 			scsi_id = buf[1];
-			scsi_lun = (buf[2]>>8 )&0xff;
+			scsi_lun = scsilun_to_int((struct scsi_lun *)&buf[2]);
 			pDev = pHba->channel[bus_no].device[scsi_id];
 			/* da lun */
 			while(pDev) {
@@ -2633,7 +2633,7 @@ static s32 adpt_i2o_reparse_lct(adpt_hba* pHba)
 			while(pDev) {
 				if(pDev->scsi_lun == scsi_lun) {
 					if(!scsi_device_online(pDev->pScsi_dev)) {
-						printk(KERN_WARNING"%s: Setting device (%d,%d,%d) back online\n",
+						printk(KERN_WARNING"%s: Setting device (%d,%d,%llu) back online\n",
 								pHba->name,bus_no,scsi_id,scsi_lun);
 						if (pDev->pScsi_dev) {
 							scsi_device_set_state(pDev->pScsi_dev, SDEV_RUNNING);
@@ -2665,7 +2665,7 @@ static s32 adpt_i2o_reparse_lct(adpt_hba* pHba)
 		// in the LCT table
 		if (pDev->state & DPTI_DEV_UNSCANNED){
 			pDev->state = DPTI_DEV_OFFLINE;
-			printk(KERN_WARNING"%s: Device (%d,%d,%d) offline\n",pHba->name,pDev->scsi_channel,pDev->scsi_id,pDev->scsi_lun);
+			printk(KERN_WARNING"%s: Device (%d,%d,%llu) offline\n",pHba->name,pDev->scsi_channel,pDev->scsi_id,pDev->scsi_lun);
 			if (pDev->pScsi_dev) {
 				scsi_device_set_state(pDev->pScsi_dev, SDEV_OFFLINE);
 			}

commit 63d80c49baa956d871136d8d4afb7900eb4a6cc9
Author: Hannes Reinecke <hare@suse.de>
Date:   Wed Oct 23 10:51:16 2013 +0200

    [SCSI] dpt_i2o: return SCSI_MLQUEUE_HOST_BUSY when in reset
    
    When the HBA is in reset we should be returning 'busy' and not
    rely on the obscure 'last_reset' feature.
    
    [jejb: checkpatch fixes]
    Signed-off-by: Hannes Reinecke <hare@suse.de>
    Signed-off-by: James Bottomley <JBottomley@Parallels.com>

diff --git a/drivers/scsi/dpt_i2o.c b/drivers/scsi/dpt_i2o.c
index d13517dd0c19..c0ae8fa57a3b 100644
--- a/drivers/scsi/dpt_i2o.c
+++ b/drivers/scsi/dpt_i2o.c
@@ -448,11 +448,8 @@ static int adpt_queue_lck(struct scsi_cmnd * cmd, void (*done) (struct scsi_cmnd
 	}
 
 	rmb();
-	if ((pHba->state) & DPTI_STATE_RESET) {
-		pHba->host->last_reset = jiffies;
-		pHba->host->resetting = 1;
-		return 1;
-	}
+	if ((pHba->state) & DPTI_STATE_RESET)
+		return SCSI_MLQUEUE_HOST_BUSY;
 
 	// TODO if the cmd->device if offline then I may need to issue a bus rescan
 	// followed by a get_lct to see if the device is there anymore

commit 1f8c88c3b52ffd424ca76f80d1ed78639c532aef
Author: Hannes Reinecke <hare@suse.de>
Date:   Wed Oct 23 10:51:15 2013 +0200

    [SCSI] dpt_i2o: Remove DPTI_STATE_IOCTL
    
    scsi_block_host/scsi_unlock_host provides the required
    functionality.
    
    [jejb: checkpatch fixes]
    Signed-off-by: Hannes Reinecke <hare@suse.de>
    Signed-off-by: James Bottomley <JBottomley@Parallels.com>

diff --git a/drivers/scsi/dpt_i2o.c b/drivers/scsi/dpt_i2o.c
index 19e1b422260a..d13517dd0c19 100644
--- a/drivers/scsi/dpt_i2o.c
+++ b/drivers/scsi/dpt_i2o.c
@@ -448,15 +448,7 @@ static int adpt_queue_lck(struct scsi_cmnd * cmd, void (*done) (struct scsi_cmnd
 	}
 
 	rmb();
-	/*
-	 * TODO: I need to block here if I am processing ioctl cmds
-	 * but if the outstanding cmds all finish before the ioctl,
-	 * the scsi-core will not know to start sending cmds to me again.
-	 * I need to a way to restart the scsi-cores queues or should I block
-	 * calling scsi_done on the outstanding cmds instead
-	 * for now we don't set the IOCTL state
-	 */
-	if(((pHba->state) & DPTI_STATE_IOCTL) || ((pHba->state) & DPTI_STATE_RESET)) {
+	if ((pHba->state) & DPTI_STATE_RESET) {
 		pHba->host->last_reset = jiffies;
 		pHba->host->resetting = 1;
 		return 1;
@@ -1811,21 +1803,23 @@ static int adpt_i2o_passthru(adpt_hba* pHba, u32 __user *arg)
 	}
 
 	do {
-		if(pHba->host)
+		/*
+		 * Stop any new commands from enterring the
+		 * controller while processing the ioctl
+		 */
+		if (pHba->host) {
+			scsi_block_requests(pHba->host);
 			spin_lock_irqsave(pHba->host->host_lock, flags);
-		// This state stops any new commands from enterring the
-		// controller while processing the ioctl
-//		pHba->state |= DPTI_STATE_IOCTL;
-//		We can't set this now - The scsi subsystem sets host_blocked and
-//		the queue empties and stops.  We need a way to restart the queue
+		}
 		rcode = adpt_i2o_post_wait(pHba, msg, size, FOREVER);
 		if (rcode != 0)
 			printk("adpt_i2o_passthru: post wait failed %d %p\n",
 					rcode, reply);
-//		pHba->state &= ~DPTI_STATE_IOCTL;
-		if(pHba->host)
+		if (pHba->host) {
 			spin_unlock_irqrestore(pHba->host->host_lock, flags);
-	} while(rcode == -ETIMEDOUT);  
+			scsi_unblock_requests(pHba->host);
+		}
+	} while (rcode == -ETIMEDOUT);
 
 	if(rcode){
 		goto cleanup;

commit ff98f7ce0ec89a3de50a1920eb8a223bf0a3a6f2
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Sun Mar 31 03:21:50 2013 -0400

    dpt_i2o: switch to ->show_info()
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/drivers/scsi/dpt_i2o.c b/drivers/scsi/dpt_i2o.c
index b6e2700ec1c6..19e1b422260a 100644
--- a/drivers/scsi/dpt_i2o.c
+++ b/drivers/scsi/dpt_i2o.c
@@ -553,36 +553,14 @@ static const char *adpt_info(struct Scsi_Host *host)
 	return (char *) (pHba->detail);
 }
 
-static int adpt_proc_info(struct Scsi_Host *host, char *buffer, char **start, off_t offset,
-		  int length, int inout)
+static int adpt_show_info(struct seq_file *m, struct Scsi_Host *host)
 {
 	struct adpt_device* d;
 	int id;
 	int chan;
-	int len = 0;
-	int begin = 0;
-	int pos = 0;
 	adpt_hba* pHba;
 	int unit;
 
-	*start = buffer;
-	if (inout == TRUE) {
-		/*
-		 * The user has done a write and wants us to take the
-		 * data in the buffer and do something with it.
-		 * proc_scsiwrite calls us with inout = 1
-		 *
-		 * Read data from buffer (writing to us) - NOT SUPPORTED
-		 */
-		return -EINVAL;
-	}
-
-	/*
-	 * inout = 0 means the user has done a read and wants information
-	 * returned, so we write information about the cards into the buffer
-	 * proc_scsiread() calls us with inout = 0
-	 */
-
 	// Find HBA (host bus adapter) we are looking for
 	mutex_lock(&adpt_configuration_lock);
 	for (pHba = hba_chain; pHba; pHba = pHba->next) {
@@ -596,86 +574,30 @@ static int adpt_proc_info(struct Scsi_Host *host, char *buffer, char **start, of
 	}
 	host = pHba->host;
 
-	len  = sprintf(buffer    , "Adaptec I2O RAID Driver Version: %s\n\n", DPT_I2O_VERSION);
-	len += sprintf(buffer+len, "%s\n", pHba->detail);
-	len += sprintf(buffer+len, "SCSI Host=scsi%d  Control Node=/dev/%s  irq=%d\n", 
+	seq_printf(m, "Adaptec I2O RAID Driver Version: %s\n\n", DPT_I2O_VERSION);
+	seq_printf(m, "%s\n", pHba->detail);
+	seq_printf(m, "SCSI Host=scsi%d  Control Node=/dev/%s  irq=%d\n", 
 			pHba->host->host_no, pHba->name, host->irq);
-	len += sprintf(buffer+len, "\tpost fifo size  = %d\n\treply fifo size = %d\n\tsg table size   = %d\n\n",
+	seq_printf(m, "\tpost fifo size  = %d\n\treply fifo size = %d\n\tsg table size   = %d\n\n",
 			host->can_queue, (int) pHba->reply_fifo_size , host->sg_tablesize);
 
-	pos = begin + len;
-
-	/* CHECKPOINT */
-	if(pos > offset + length) {
-		goto stop_output;
-	}
-	if(pos <= offset) {
-		/*
-		 * If we haven't even written to where we last left
-		 * off (the last time we were called), reset the 
-		 * beginning pointer.
-		 */
-		len = 0;
-		begin = pos;
-	}
-	len +=  sprintf(buffer+len, "Devices:\n");
+	seq_printf(m, "Devices:\n");
 	for(chan = 0; chan < MAX_CHANNEL; chan++) {
 		for(id = 0; id < MAX_ID; id++) {
 			d = pHba->channel[chan].device[id];
-			while(d){
-				len += sprintf(buffer+len,"\t%-24.24s", d->pScsi_dev->vendor);
-				len += sprintf(buffer+len," Rev: %-8.8s\n", d->pScsi_dev->rev);
-				pos = begin + len;
-
-
-				/* CHECKPOINT */
-				if(pos > offset + length) {
-					goto stop_output;
-				}
-				if(pos <= offset) {
-					len = 0;
-					begin = pos;
-				}
+			while(d) {
+				seq_printf(m,"\t%-24.24s", d->pScsi_dev->vendor);
+				seq_printf(m," Rev: %-8.8s\n", d->pScsi_dev->rev);
 
 				unit = d->pI2o_dev->lct_data.tid;
-				len += sprintf(buffer+len, "\tTID=%d, (Channel=%d, Target=%d, Lun=%d)  (%s)\n\n",
+				seq_printf(m, "\tTID=%d, (Channel=%d, Target=%d, Lun=%d)  (%s)\n\n",
 					       unit, (int)d->scsi_channel, (int)d->scsi_id, (int)d->scsi_lun,
 					       scsi_device_online(d->pScsi_dev)? "online":"offline"); 
-				pos = begin + len;
-
-				/* CHECKPOINT */
-				if(pos > offset + length) {
-					goto stop_output;
-				}
-				if(pos <= offset) {
-					len = 0;
-					begin = pos;
-				}
-
 				d = d->next_lun;
 			}
 		}
 	}
-
-	/*
-	 * begin is where we last checked our position with regards to offset
-	 * begin is always less than offset.  len is relative to begin.  It
-	 * is the number of bytes written past begin
-	 *
-	 */
-stop_output:
-	/* stop the output and calculate the correct length */
-	*(buffer + len) = '\0';
-
-	*start = buffer + (offset - begin);	/* Start of wanted data */
-	len -= (offset - begin);
-	if(len > length) {
-		len = length;
-	} else if(len < 0){
-		len = 0;
-		**start = '\0';
-	}
-	return len;
+	return 0;
 }
 
 /*
@@ -3639,7 +3561,7 @@ static struct scsi_host_template driver_template = {
 	.module			= THIS_MODULE,
 	.name			= "dpt_i2o",
 	.proc_name		= "dpt_i2o",
-	.proc_info		= adpt_proc_info,
+	.show_info		= adpt_show_info,
 	.info			= adpt_info,
 	.queuecommand		= adpt_queue,
 	.eh_abort_handler	= adpt_abort,

commit 496ad9aa8ef448058e36ca7a787c61f2e63f0f54
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Wed Jan 23 17:07:38 2013 -0500

    new helper: file_inode(file)
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/drivers/scsi/dpt_i2o.c b/drivers/scsi/dpt_i2o.c
index b4f6c9a84e71..b6e2700ec1c6 100644
--- a/drivers/scsi/dpt_i2o.c
+++ b/drivers/scsi/dpt_i2o.c
@@ -2161,7 +2161,7 @@ static long adpt_unlocked_ioctl(struct file *file, uint cmd, ulong arg)
 	struct inode *inode;
 	long ret;
  
-	inode = file->f_dentry->d_inode;
+	inode = file_inode(file);
  
 	mutex_lock(&adpt_mutex);
 	ret = adpt_ioctl(inode, file, cmd, arg);
@@ -2177,7 +2177,7 @@ static long compat_adpt_ioctl(struct file *file,
 	struct inode *inode;
 	long ret;
  
-	inode = file->f_dentry->d_inode;
+	inode = file_inode(file);
  
 	mutex_lock(&adpt_mutex);
  

commit 5cd049a59913f359e7d30c11d2dc6187822e77b1
Author: Christoph Hellwig <hch@infradead.org>
Date:   Mon Apr 4 09:42:14 2011 -0400

    [SCSI] remove cmd->serial_number litter
    
    Stop using cmd->serial_number in printks.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: James Bottomley <James.Bottomley@suse.de>

diff --git a/drivers/scsi/dpt_i2o.c b/drivers/scsi/dpt_i2o.c
index cffcb108ac96..b4f6c9a84e71 100644
--- a/drivers/scsi/dpt_i2o.c
+++ b/drivers/scsi/dpt_i2o.c
@@ -780,7 +780,7 @@ static int adpt_abort(struct scsi_cmnd * cmd)
 		return FAILED;
 	}
 	pHba = (adpt_hba*) cmd->device->host->hostdata[0];
-	printk(KERN_INFO"%s: Trying to Abort cmd=%ld\n",pHba->name, cmd->serial_number);
+	printk(KERN_INFO"%s: Trying to Abort\n",pHba->name);
 	if ((dptdevice = (void*) (cmd->device->hostdata)) == NULL) {
 		printk(KERN_ERR "%s: Unable to abort: No device in cmnd\n",pHba->name);
 		return FAILED;
@@ -802,10 +802,10 @@ static int adpt_abort(struct scsi_cmnd * cmd)
 			printk(KERN_INFO"%s: Abort cmd not supported\n",pHba->name);
 			return FAILED;
 		}
-		printk(KERN_INFO"%s: Abort cmd=%ld failed.\n",pHba->name, cmd->serial_number);
+		printk(KERN_INFO"%s: Abort failed.\n",pHba->name);
 		return FAILED;
 	} 
-	printk(KERN_INFO"%s: Abort cmd=%ld complete.\n",pHba->name, cmd->serial_number);
+	printk(KERN_INFO"%s: Abort complete.\n",pHba->name);
 	return SUCCESS;
 }
 

commit f281233d3eba15fb225d21ae2e228fd4553d824a
Author: Jeff Garzik <jeff@garzik.org>
Date:   Tue Nov 16 02:10:29 2010 -0500

    SCSI host lock push-down
    
    Move the mid-layer's ->queuecommand() invocation from being locked
    with the host lock to being unlocked to facilitate speeding up the
    critical path for drivers who don't need this lock taken anyway.
    
    The patch below presents a simple SCSI host lock push-down as an
    equivalent transformation.  No locking or other behavior should change
    with this patch.  All existing bugs and locking orders are preserved.
    
    Additionally, add one parameter to queuecommand,
            struct Scsi_Host *
    and remove one parameter from queuecommand,
            void (*done)(struct scsi_cmnd *)
    
    Scsi_Host* is a convenient pointer that most host drivers need anyway,
    and 'done' is redundant to struct scsi_cmnd->scsi_done.
    
    Minimal code disturbance was attempted with this change.  Most drivers
    needed only two one-line modifications for their host lock push-down.
    
    Signed-off-by: Jeff Garzik <jgarzik@redhat.com>
    Acked-by: James Bottomley <James.Bottomley@suse.de>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/scsi/dpt_i2o.c b/drivers/scsi/dpt_i2o.c
index 23dec0063385..cffcb108ac96 100644
--- a/drivers/scsi/dpt_i2o.c
+++ b/drivers/scsi/dpt_i2o.c
@@ -423,7 +423,7 @@ static int adpt_slave_configure(struct scsi_device * device)
 	return 0;
 }
 
-static int adpt_queue(struct scsi_cmnd * cmd, void (*done) (struct scsi_cmnd *))
+static int adpt_queue_lck(struct scsi_cmnd * cmd, void (*done) (struct scsi_cmnd *))
 {
 	adpt_hba* pHba = NULL;
 	struct adpt_device* pDev = NULL;	/* dpt per device information */
@@ -491,6 +491,8 @@ static int adpt_queue(struct scsi_cmnd * cmd, void (*done) (struct scsi_cmnd *))
 	return adpt_scsi_to_i2o(pHba, cmd, pDev);
 }
 
+static DEF_SCSI_QCMD(adpt_queue)
+
 static int adpt_bios_param(struct scsi_device *sdev, struct block_device *dev,
 		sector_t capacity, int geom[])
 {

commit 092e0e7e520a1fca03e13c9f2d157432a8657ff2
Merge: 79f14b7c56d3 776c163b1b93
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Fri Oct 22 10:52:56 2010 -0700

    Merge branch 'llseek' of git://git.kernel.org/pub/scm/linux/kernel/git/arnd/bkl
    
    * 'llseek' of git://git.kernel.org/pub/scm/linux/kernel/git/arnd/bkl:
      vfs: make no_llseek the default
      vfs: don't use BKL in default_llseek
      llseek: automatically add .llseek fop
      libfs: use generic_file_llseek for simple_attr
      mac80211: disallow seeks in minstrel debug code
      lirc: make chardev nonseekable
      viotape: use noop_llseek
      raw: use explicit llseek file operations
      ibmasmfs: use generic_file_llseek
      spufs: use llseek in all file operations
      arm/omap: use generic_file_llseek in iommu_debug
      lkdtm: use generic_file_llseek in debugfs
      net/wireless: use generic_file_llseek in debugfs
      drm: use noop_llseek

commit 6038f373a3dc1f1c26496e60b6c40b164716f07e
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Sun Aug 15 18:52:59 2010 +0200

    llseek: automatically add .llseek fop
    
    All file_operations should get a .llseek operation so we can make
    nonseekable_open the default for future file operations without a
    .llseek pointer.
    
    The three cases that we can automatically detect are no_llseek, seq_lseek
    and default_llseek. For cases where we can we can automatically prove that
    the file offset is always ignored, we use noop_llseek, which maintains
    the current behavior of not returning an error from a seek.
    
    New drivers should normally not use noop_llseek but instead use no_llseek
    and call nonseekable_open at open time.  Existing drivers can be converted
    to do the same when the maintainer knows for certain that no user code
    relies on calling seek on the device file.
    
    The generated code is often incorrectly indented and right now contains
    comments that clarify for each added line why a specific variant was
    chosen. In the version that gets submitted upstream, the comments will
    be gone and I will manually fix the indentation, because there does not
    seem to be a way to do that using coccinelle.
    
    Some amount of new code is currently sitting in linux-next that should get
    the same modifications, which I will do at the end of the merge window.
    
    Many thanks to Julia Lawall for helping me learn to write a semantic
    patch that does all this.
    
    ===== begin semantic patch =====
    // This adds an llseek= method to all file operations,
    // as a preparation for making no_llseek the default.
    //
    // The rules are
    // - use no_llseek explicitly if we do nonseekable_open
    // - use seq_lseek for sequential files
    // - use default_llseek if we know we access f_pos
    // - use noop_llseek if we know we don't access f_pos,
    //   but we still want to allow users to call lseek
    //
    @ open1 exists @
    identifier nested_open;
    @@
    nested_open(...)
    {
    <+...
    nonseekable_open(...)
    ...+>
    }
    
    @ open exists@
    identifier open_f;
    identifier i, f;
    identifier open1.nested_open;
    @@
    int open_f(struct inode *i, struct file *f)
    {
    <+...
    (
    nonseekable_open(...)
    |
    nested_open(...)
    )
    ...+>
    }
    
    @ read disable optional_qualifier exists @
    identifier read_f;
    identifier f, p, s, off;
    type ssize_t, size_t, loff_t;
    expression E;
    identifier func;
    @@
    ssize_t read_f(struct file *f, char *p, size_t s, loff_t *off)
    {
    <+...
    (
       *off = E
    |
       *off += E
    |
       func(..., off, ...)
    |
       E = *off
    )
    ...+>
    }
    
    @ read_no_fpos disable optional_qualifier exists @
    identifier read_f;
    identifier f, p, s, off;
    type ssize_t, size_t, loff_t;
    @@
    ssize_t read_f(struct file *f, char *p, size_t s, loff_t *off)
    {
    ... when != off
    }
    
    @ write @
    identifier write_f;
    identifier f, p, s, off;
    type ssize_t, size_t, loff_t;
    expression E;
    identifier func;
    @@
    ssize_t write_f(struct file *f, const char *p, size_t s, loff_t *off)
    {
    <+...
    (
      *off = E
    |
      *off += E
    |
      func(..., off, ...)
    |
      E = *off
    )
    ...+>
    }
    
    @ write_no_fpos @
    identifier write_f;
    identifier f, p, s, off;
    type ssize_t, size_t, loff_t;
    @@
    ssize_t write_f(struct file *f, const char *p, size_t s, loff_t *off)
    {
    ... when != off
    }
    
    @ fops0 @
    identifier fops;
    @@
    struct file_operations fops = {
     ...
    };
    
    @ has_llseek depends on fops0 @
    identifier fops0.fops;
    identifier llseek_f;
    @@
    struct file_operations fops = {
    ...
     .llseek = llseek_f,
    ...
    };
    
    @ has_read depends on fops0 @
    identifier fops0.fops;
    identifier read_f;
    @@
    struct file_operations fops = {
    ...
     .read = read_f,
    ...
    };
    
    @ has_write depends on fops0 @
    identifier fops0.fops;
    identifier write_f;
    @@
    struct file_operations fops = {
    ...
     .write = write_f,
    ...
    };
    
    @ has_open depends on fops0 @
    identifier fops0.fops;
    identifier open_f;
    @@
    struct file_operations fops = {
    ...
     .open = open_f,
    ...
    };
    
    // use no_llseek if we call nonseekable_open
    ////////////////////////////////////////////
    @ nonseekable1 depends on !has_llseek && has_open @
    identifier fops0.fops;
    identifier nso ~= "nonseekable_open";
    @@
    struct file_operations fops = {
    ...  .open = nso, ...
    +.llseek = no_llseek, /* nonseekable */
    };
    
    @ nonseekable2 depends on !has_llseek @
    identifier fops0.fops;
    identifier open.open_f;
    @@
    struct file_operations fops = {
    ...  .open = open_f, ...
    +.llseek = no_llseek, /* open uses nonseekable */
    };
    
    // use seq_lseek for sequential files
    /////////////////////////////////////
    @ seq depends on !has_llseek @
    identifier fops0.fops;
    identifier sr ~= "seq_read";
    @@
    struct file_operations fops = {
    ...  .read = sr, ...
    +.llseek = seq_lseek, /* we have seq_read */
    };
    
    // use default_llseek if there is a readdir
    ///////////////////////////////////////////
    @ fops1 depends on !has_llseek && !nonseekable1 && !nonseekable2 && !seq @
    identifier fops0.fops;
    identifier readdir_e;
    @@
    // any other fop is used that changes pos
    struct file_operations fops = {
    ... .readdir = readdir_e, ...
    +.llseek = default_llseek, /* readdir is present */
    };
    
    // use default_llseek if at least one of read/write touches f_pos
    /////////////////////////////////////////////////////////////////
    @ fops2 depends on !fops1 && !has_llseek && !nonseekable1 && !nonseekable2 && !seq @
    identifier fops0.fops;
    identifier read.read_f;
    @@
    // read fops use offset
    struct file_operations fops = {
    ... .read = read_f, ...
    +.llseek = default_llseek, /* read accesses f_pos */
    };
    
    @ fops3 depends on !fops1 && !fops2 && !has_llseek && !nonseekable1 && !nonseekable2 && !seq @
    identifier fops0.fops;
    identifier write.write_f;
    @@
    // write fops use offset
    struct file_operations fops = {
    ... .write = write_f, ...
    +       .llseek = default_llseek, /* write accesses f_pos */
    };
    
    // Use noop_llseek if neither read nor write accesses f_pos
    ///////////////////////////////////////////////////////////
    
    @ fops4 depends on !fops1 && !fops2 && !fops3 && !has_llseek && !nonseekable1 && !nonseekable2 && !seq @
    identifier fops0.fops;
    identifier read_no_fpos.read_f;
    identifier write_no_fpos.write_f;
    @@
    // write fops use offset
    struct file_operations fops = {
    ...
     .write = write_f,
     .read = read_f,
    ...
    +.llseek = noop_llseek, /* read and write both use no f_pos */
    };
    
    @ depends on has_write && !has_read && !fops1 && !fops2 && !has_llseek && !nonseekable1 && !nonseekable2 && !seq @
    identifier fops0.fops;
    identifier write_no_fpos.write_f;
    @@
    struct file_operations fops = {
    ... .write = write_f, ...
    +.llseek = noop_llseek, /* write uses no f_pos */
    };
    
    @ depends on has_read && !has_write && !fops1 && !fops2 && !has_llseek && !nonseekable1 && !nonseekable2 && !seq @
    identifier fops0.fops;
    identifier read_no_fpos.read_f;
    @@
    struct file_operations fops = {
    ... .read = read_f, ...
    +.llseek = noop_llseek, /* read uses no f_pos */
    };
    
    @ depends on !has_read && !has_write && !fops1 && !fops2 && !has_llseek && !nonseekable1 && !nonseekable2 && !seq @
    identifier fops0.fops;
    @@
    struct file_operations fops = {
    ...
    +.llseek = noop_llseek, /* no read or write fn */
    };
    ===== End semantic patch =====
    
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>
    Cc: Julia Lawall <julia@diku.dk>
    Cc: Christoph Hellwig <hch@infradead.org>

diff --git a/drivers/scsi/dpt_i2o.c b/drivers/scsi/dpt_i2o.c
index ffc1edf5e80d..7a61206ed1c0 100644
--- a/drivers/scsi/dpt_i2o.c
+++ b/drivers/scsi/dpt_i2o.c
@@ -126,6 +126,7 @@ static const struct file_operations adpt_fops = {
 #ifdef CONFIG_COMPAT
 	.compat_ioctl	= compat_adpt_ioctl,
 #endif
+	.llseek		= noop_llseek,
 };
 
 /* Structures and definitions for synchronous message posting.

commit c45d15d24eb2b49bf734e1e5e7e103befb76b19b
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Wed Jun 2 14:28:52 2010 +0200

    scsi: autoconvert trivial BKL users to private mutex
    
    All these files use the big kernel lock in a trivial
    way to serialize their private file operations,
    typically resulting from an earlier semi-automatic
    pushdown from VFS.
    
    None of these drivers appears to want to lock against
    other code, and they all use the BKL as the top-level
    lock in their file operations, meaning that there
    is no lock-order inversion problem.
    
    Consequently, we can remove the BKL completely,
    replacing it with a per-file mutex in every case.
    Using a scripted approach means we can avoid
    typos.
    
    file=$1
    name=$2
    if grep -q lock_kernel ${file} ; then
        if grep -q 'include.*linux.mutex.h' ${file} ; then
                sed -i '/include.*<linux\/smp_lock.h>/d' ${file}
        else
                sed -i 's/include.*<linux\/smp_lock.h>.*$/include <linux\/mutex.h>/g' ${file}
        fi
        sed -i ${file} \
            -e "/^#include.*linux.mutex.h/,$ {
                    1,/^\(static\|int\|long\)/ {
                         /^\(static\|int\|long\)/istatic DEFINE_MUTEX(${name}_mutex);
    
    } }"  \
        -e "s/\(un\)*lock_kernel\>[ ]*()/mutex_\1lock(\&${name}_mutex)/g" \
        -e '/[      ]*cycle_kernel_lock();/d'
    else
        sed -i -e '/include.*\<smp_lock.h\>/d' ${file}  \
                    -e '/cycle_kernel_lock()/d'
    fi
    
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>
    Cc: linux-scsi@vger.kernel.org
    Cc: "James E.J. Bottomley" <James.Bottomley@suse.de>

diff --git a/drivers/scsi/dpt_i2o.c b/drivers/scsi/dpt_i2o.c
index ffc1edf5e80d..410ac1def8a6 100644
--- a/drivers/scsi/dpt_i2o.c
+++ b/drivers/scsi/dpt_i2o.c
@@ -49,7 +49,6 @@ MODULE_DESCRIPTION("Adaptec I2O RAID Driver");
 #include <linux/kernel.h>	/* for printk */
 #include <linux/sched.h>
 #include <linux/reboot.h>
-#include <linux/smp_lock.h>
 #include <linux/spinlock.h>
 #include <linux/dma-mapping.h>
 
@@ -76,6 +75,7 @@ MODULE_DESCRIPTION("Adaptec I2O RAID Driver");
  * Needed for our management apps
  *============================================================================
  */
+static DEFINE_MUTEX(adpt_mutex);
 static dpt_sig_S DPTI_sig = {
 	{'d', 'P', 't', 'S', 'i', 'G'}, SIG_VERSION,
 #ifdef __i386__
@@ -1732,12 +1732,12 @@ static int adpt_open(struct inode *inode, struct file *file)
 	int minor;
 	adpt_hba* pHba;
 
-	lock_kernel();
+	mutex_lock(&adpt_mutex);
 	//TODO check for root access
 	//
 	minor = iminor(inode);
 	if (minor >= hba_count) {
-		unlock_kernel();
+		mutex_unlock(&adpt_mutex);
 		return -ENXIO;
 	}
 	mutex_lock(&adpt_configuration_lock);
@@ -1748,7 +1748,7 @@ static int adpt_open(struct inode *inode, struct file *file)
 	}
 	if (pHba == NULL) {
 		mutex_unlock(&adpt_configuration_lock);
-		unlock_kernel();
+		mutex_unlock(&adpt_mutex);
 		return -ENXIO;
 	}
 
@@ -1759,7 +1759,7 @@ static int adpt_open(struct inode *inode, struct file *file)
 
 	pHba->in_use = 1;
 	mutex_unlock(&adpt_configuration_lock);
-	unlock_kernel();
+	mutex_unlock(&adpt_mutex);
 
 	return 0;
 }
@@ -2160,9 +2160,9 @@ static long adpt_unlocked_ioctl(struct file *file, uint cmd, ulong arg)
  
 	inode = file->f_dentry->d_inode;
  
-	lock_kernel();
+	mutex_lock(&adpt_mutex);
 	ret = adpt_ioctl(inode, file, cmd, arg);
-	unlock_kernel();
+	mutex_unlock(&adpt_mutex);
 
 	return ret;
 }
@@ -2176,7 +2176,7 @@ static long compat_adpt_ioctl(struct file *file,
  
 	inode = file->f_dentry->d_inode;
  
-	lock_kernel();
+	mutex_lock(&adpt_mutex);
  
 	switch(cmd) {
 		case DPT_SIGNATURE:
@@ -2194,7 +2194,7 @@ static long compat_adpt_ioctl(struct file *file,
 			ret =  -ENOIOCTLCMD;
 	}
  
-	unlock_kernel();
+	mutex_unlock(&adpt_mutex);
  
 	return ret;
 }

commit e84d96dbb0638186feb526c32810a3400f33d0c8
Author: Dan Carpenter <error27@gmail.com>
Date:   Thu Jul 15 10:20:19 2010 +0200

    [SCSI] dpt_i2o: move range check forward
    
    The check to test that "bus_no" was valid came after we had already used
    it as an array offset.  This patch moves it forward.
    
    Signed-off-by: Dan Carpenter <error27@gmail.com>
    Signed-off-by: James Bottomley <James.Bottomley@suse.de>

diff --git a/drivers/scsi/dpt_i2o.c b/drivers/scsi/dpt_i2o.c
index f2d4df14c311..ffc1edf5e80d 100644
--- a/drivers/scsi/dpt_i2o.c
+++ b/drivers/scsi/dpt_i2o.c
@@ -2640,6 +2640,13 @@ static s32 adpt_i2o_reparse_lct(adpt_hba* pHba)
 				continue;
 			}
 			bus_no = buf[0]>>16;
+			if (bus_no >= MAX_CHANNEL) {	/* Something wrong skip it */
+				printk(KERN_WARNING
+					"%s: Channel number %d out of range\n",
+					pHba->name, bus_no);
+				continue;
+			}
+
 			scsi_id = buf[1];
 			scsi_lun = (buf[2]>>8 )&0xff;
 			pDev = pHba->channel[bus_no].device[scsi_id];
@@ -2668,10 +2675,6 @@ static s32 adpt_i2o_reparse_lct(adpt_hba* pHba)
 				adpt_i2o_report_hba_unit(pHba, d);
 				adpt_i2o_install_device(pHba, d);
 	
-				if(bus_no >= MAX_CHANNEL) {	// Something wrong skip it
-					printk(KERN_WARNING"%s: Channel number %d out of range \n", pHba->name, bus_no);
-					continue;
-				}
 				pDev = pHba->channel[bus_no].device[scsi_id];	
 				if( pDev == NULL){
 					pDev =

commit da2907ffd08a2d708c829ec171f05fe3ceab1315
Author: Julia Lawall <julia@diku.dk>
Date:   Sun May 30 15:49:22 2010 +0200

    [SCSI] dpt_i2o: Use GFP_ATOMIC when a lock is held
    
    The function adpt_i2o_post_wait is called from several places, in some of
    which, such as adpt_abort, a lock may be held.
    
    The functions adpt_i2o_reparse_lct and adpt_i2o_lct_get are called from
    several places, including adpt_rescan where a lock may be held.
    
    The semantic patch that makes this change is as follows:
    (http://coccinelle.lip6.fr/)
    
    // <smpl>
    @gfp exists@
    identifier fn;
    position p;
    @@
    
    fn(...) {
     ... when != spin_unlock_irqrestore
         when any
     GFP_KERNEL@p
     ... when any
    }
    
    @locked@
    identifier gfp.fn;
    @@
    
    spin_lock_irqsave(...)
    ...  when != spin_unlock_irqrestore
    fn(...)
    
    @depends on locked@
    position gfp.p;
    @@
    
    - GFP_KERNEL@p
    + GFP_ATOMIC
    // </smpl>
    
    Signed-off-by: Julia Lawall <julia@diku.dk>
    Signed-off-by: James Bottomley <James.Bottomley@suse.de>

diff --git a/drivers/scsi/dpt_i2o.c b/drivers/scsi/dpt_i2o.c
index b0c576f84b28..f2d4df14c311 100644
--- a/drivers/scsi/dpt_i2o.c
+++ b/drivers/scsi/dpt_i2o.c
@@ -1290,7 +1290,7 @@ static int adpt_i2o_post_wait(adpt_hba* pHba, u32* msg, int len, int timeout)
 	ulong flags = 0;
 	struct adpt_i2o_post_wait_data *p1, *p2;
 	struct adpt_i2o_post_wait_data *wait_data =
-		kmalloc(sizeof(struct adpt_i2o_post_wait_data),GFP_KERNEL);
+		kmalloc(sizeof(struct adpt_i2o_post_wait_data), GFP_ATOMIC);
 	DECLARE_WAITQUEUE(wait, current);
 
 	if (!wait_data)
@@ -2651,7 +2651,8 @@ static s32 adpt_i2o_reparse_lct(adpt_hba* pHba)
 				pDev = pDev->next_lun;
 			}
 			if(!pDev ) { // Something new add it
-				d = kmalloc(sizeof(struct i2o_device), GFP_KERNEL);
+				d = kmalloc(sizeof(struct i2o_device),
+					    GFP_ATOMIC);
 				if(d==NULL)
 				{
 					printk(KERN_CRIT "Out of memory for I2O device data.\n");
@@ -2673,7 +2674,9 @@ static s32 adpt_i2o_reparse_lct(adpt_hba* pHba)
 				}
 				pDev = pHba->channel[bus_no].device[scsi_id];	
 				if( pDev == NULL){
-					pDev =  kzalloc(sizeof(struct adpt_device),GFP_KERNEL);
+					pDev =
+					  kzalloc(sizeof(struct adpt_device),
+						  GFP_ATOMIC);
 					if(pDev == NULL) {
 						return -ENOMEM;
 					}
@@ -2682,7 +2685,9 @@ static s32 adpt_i2o_reparse_lct(adpt_hba* pHba)
 					while (pDev->next_lun) {
 						pDev = pDev->next_lun;
 					}
-					pDev = pDev->next_lun = kzalloc(sizeof(struct adpt_device),GFP_KERNEL);
+					pDev = pDev->next_lun =
+					  kzalloc(sizeof(struct adpt_device),
+						  GFP_ATOMIC);
 					if(pDev == NULL) {
 						return -ENOMEM;
 					}
@@ -3127,7 +3132,7 @@ static int adpt_i2o_lct_get(adpt_hba* pHba)
 		if (pHba->lct == NULL) {
 			pHba->lct = dma_alloc_coherent(&pHba->pDev->dev,
 					pHba->lct_size, &pHba->lct_pa,
-					GFP_KERNEL);
+					GFP_ATOMIC);
 			if(pHba->lct == NULL) {
 				printk(KERN_CRIT "%s: Lct Get failed. Out of memory.\n",
 					pHba->name);

commit f4927c45beda9a70e5c3bda0bd9f12b4f713c00b
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Tue Apr 27 00:24:01 2010 +0200

    scsi: Push down BKL into ioctl functions
    
    Push down the bkl into ioctl functions on the scsi layer.
    
    [jkacur: Forward declaration missing ';'.
    Conflicting declaraction in megaraid.h changed
    Fixed missing inodes declarations]
    
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>
    Signed-off-by: John Kacur <jkacur@redhat.com>
    Signed-off-by: Frederic Weisbecker <fweisbec@gmail.com>

diff --git a/drivers/scsi/dpt_i2o.c b/drivers/scsi/dpt_i2o.c
index 0435d044c9da..b0c576f84b28 100644
--- a/drivers/scsi/dpt_i2o.c
+++ b/drivers/scsi/dpt_i2o.c
@@ -114,12 +114,13 @@ static int hba_count = 0;
 
 static struct class *adpt_sysfs_class;
 
+static long adpt_unlocked_ioctl(struct file *, unsigned int, unsigned long);
 #ifdef CONFIG_COMPAT
 static long compat_adpt_ioctl(struct file *, unsigned int, unsigned long);
 #endif
 
 static const struct file_operations adpt_fops = {
-	.ioctl		= adpt_ioctl,
+	.unlocked_ioctl	= adpt_unlocked_ioctl,
 	.open		= adpt_open,
 	.release	= adpt_close,
 #ifdef CONFIG_COMPAT
@@ -2069,8 +2070,7 @@ static int adpt_system_info(void __user *buffer)
 	return 0;
 }
 
-static int adpt_ioctl(struct inode *inode, struct file *file, uint cmd,
-	      ulong arg)
+static int adpt_ioctl(struct inode *inode, struct file *file, uint cmd, ulong arg)
 {
 	int minor;
 	int error = 0;
@@ -2153,6 +2153,20 @@ static int adpt_ioctl(struct inode *inode, struct file *file, uint cmd,
 	return error;
 }
 
+static long adpt_unlocked_ioctl(struct file *file, uint cmd, ulong arg)
+{
+	struct inode *inode;
+	long ret;
+ 
+	inode = file->f_dentry->d_inode;
+ 
+	lock_kernel();
+	ret = adpt_ioctl(inode, file, cmd, arg);
+	unlock_kernel();
+
+	return ret;
+}
+
 #ifdef CONFIG_COMPAT
 static long compat_adpt_ioctl(struct file *file,
 				unsigned int cmd, unsigned long arg)

commit 229bab6bacc42295f13c0434772381a88ce2308b
Author: Dan Carpenter <error27@gmail.com>
Date:   Mon Mar 15 11:26:56 2010 +0300

    [SCSI] dpt_i2o: several use after free issues
    
    adpt_i2o_delete_hba() calls kfree() so we have to save "pHba->next"
    before calling it.  Also inside adpt_i2o_delete_hba() itself, there
    was another use after free bug which I fixed by moving the kfree()
    down a line.
    
    Signed-off-by: Dan Carpenter <error27@gmail.com>
    Signed-off-by: James Bottomley <James.Bottomley@suse.de>

diff --git a/drivers/scsi/dpt_i2o.c b/drivers/scsi/dpt_i2o.c
index 496764349c41..0435d044c9da 100644
--- a/drivers/scsi/dpt_i2o.c
+++ b/drivers/scsi/dpt_i2o.c
@@ -188,7 +188,8 @@ MODULE_DEVICE_TABLE(pci,dptids);
 static int adpt_detect(struct scsi_host_template* sht)
 {
 	struct pci_dev *pDev = NULL;
-	adpt_hba* pHba;
+	adpt_hba *pHba;
+	adpt_hba *next;
 
 	PINFO("Detecting Adaptec I2O RAID controllers...\n");
 
@@ -206,7 +207,8 @@ static int adpt_detect(struct scsi_host_template* sht)
 	}
 
 	/* In INIT state, Activate IOPs */
-	for (pHba = hba_chain; pHba; pHba = pHba->next) {
+	for (pHba = hba_chain; pHba; pHba = next) {
+		next = pHba->next;
 		// Activate does get status , init outbound, and get hrt
 		if (adpt_i2o_activate_hba(pHba) < 0) {
 			adpt_i2o_delete_hba(pHba);
@@ -243,7 +245,8 @@ static int adpt_detect(struct scsi_host_template* sht)
 	PDEBUG("HBA's in OPERATIONAL state\n");
 
 	printk("dpti: If you have a lot of devices this could take a few minutes.\n");
-	for (pHba = hba_chain; pHba; pHba = pHba->next) {
+	for (pHba = hba_chain; pHba; pHba = next) {
+		next = pHba->next;
 		printk(KERN_INFO"%s: Reading the hardware resource table.\n", pHba->name);
 		if (adpt_i2o_lct_get(pHba) < 0){
 			adpt_i2o_delete_hba(pHba);
@@ -263,7 +266,8 @@ static int adpt_detect(struct scsi_host_template* sht)
 		adpt_sysfs_class = NULL;
 	}
 
-	for (pHba = hba_chain; pHba; pHba = pHba->next) {
+	for (pHba = hba_chain; pHba; pHba = next) {
+		next = pHba->next;
 		if (adpt_scsi_host_alloc(pHba, sht) < 0){
 			adpt_i2o_delete_hba(pHba);
 			continue;
@@ -1229,11 +1233,10 @@ static void adpt_i2o_delete_hba(adpt_hba* pHba)
 		}
 	}
 	pci_dev_put(pHba->pDev);
-	kfree(pHba);
-
 	if (adpt_sysfs_class)
 		device_destroy(adpt_sysfs_class,
 				MKDEV(DPTI_I2O_MAJOR, pHba->unit));
+	kfree(pHba);
 
 	if(hba_count <= 0){
 		unregister_chrdev(DPTI_I2O_MAJOR, DPT_DRIVER);   

commit aefba418bfecd1985a08f50a95bd854a119f0153
Author: OGAWA Hirofumi <hirofumi@mail.parknet.co.jp>
Date:   Fri Oct 30 17:02:31 2009 +0900

    dpt_i2o: Fix typo of EINVAL
    
    Commit ef7562b7f28319e6dd1f85dc1af87df2a7a84832 ("dpt_i2o: Fix up
    copy*user") had a silly typo: EINVAL should be -EINVAL.
    
    Signed-off-by: OGAWA Hirofumi <hirofumi@mail.parknet.co.jp>
    Cc: stable@kernel.org
    Cc: Alan Cox <alan@linux.intel.com>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/scsi/dpt_i2o.c b/drivers/scsi/dpt_i2o.c
index 7d1aac31ec8d..496764349c41 100644
--- a/drivers/scsi/dpt_i2o.c
+++ b/drivers/scsi/dpt_i2o.c
@@ -1919,7 +1919,7 @@ static int adpt_i2o_passthru(adpt_hba* pHba, u32 __user *arg)
 		size = size>>16;
 		size *= 4;
 		if (size > MAX_MESSAGE_SIZE) {
-			rcode = EINVAL;
+			rcode = -EINVAL;
 			goto cleanup;
 		}
 		/* Copy in the user's I2O command */

commit ef7562b7f28319e6dd1f85dc1af87df2a7a84832
Author: Alan Cox <alan@linux.intel.com>
Date:   Tue Oct 27 15:35:35 2009 +0000

    dpt_i2o: Fix up copy*user
    
    Signed-off-by: Alan Cox <alan@linux.intel.com>
    Cc: stable@kernel.org
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/scsi/dpt_i2o.c b/drivers/scsi/dpt_i2o.c
index b6af63ca980b..7d1aac31ec8d 100644
--- a/drivers/scsi/dpt_i2o.c
+++ b/drivers/scsi/dpt_i2o.c
@@ -1918,6 +1918,10 @@ static int adpt_i2o_passthru(adpt_hba* pHba, u32 __user *arg)
 		}
 		size = size>>16;
 		size *= 4;
+		if (size > MAX_MESSAGE_SIZE) {
+			rcode = EINVAL;
+			goto cleanup;
+		}
 		/* Copy in the user's I2O command */
 		if (copy_from_user (msg, user_msg, size)) {
 			rcode = -EFAULT;

commit 284901a90a9e0b812ca3f5f852cbbfb60d10249d
Author: Yang Hongyang <yanghy@cn.fujitsu.com>
Date:   Mon Apr 6 19:01:15 2009 -0700

    dma-mapping: replace all DMA_32BIT_MASK macro with DMA_BIT_MASK(32)
    
    Replace all DMA_32BIT_MASK macro with DMA_BIT_MASK(32)
    
    Signed-off-by: Yang Hongyang<yanghy@cn.fujitsu.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/scsi/dpt_i2o.c b/drivers/scsi/dpt_i2o.c
index 75a94e438fa5..b6af63ca980b 100644
--- a/drivers/scsi/dpt_i2o.c
+++ b/drivers/scsi/dpt_i2o.c
@@ -1015,14 +1015,14 @@ static int adpt_install_hba(struct scsi_host_template* sht, struct pci_dev* pDev
 	 */
 	if (sizeof(dma_addr_t) > 4 &&
 	    pci_set_dma_mask(pDev, DMA_BIT_MASK(64)) == 0) {
-		if (dma_get_required_mask(&pDev->dev) > DMA_32BIT_MASK)
+		if (dma_get_required_mask(&pDev->dev) > DMA_BIT_MASK(32))
 			dma64 = 1;
 	}
-	if (!dma64 && pci_set_dma_mask(pDev, DMA_32BIT_MASK) != 0)
+	if (!dma64 && pci_set_dma_mask(pDev, DMA_BIT_MASK(32)) != 0)
 		return -EINVAL;
 
 	/* adapter only supports message blocks below 4GB */
-	pci_set_consistent_dma_mask(pDev, DMA_32BIT_MASK);
+	pci_set_consistent_dma_mask(pDev, DMA_BIT_MASK(32));
 
 	base_addr0_phys = pci_resource_start(pDev,0);
 	hba_map0_area_size = pci_resource_len(pDev,0);

commit 6a35528a8346f6e6fd32ed7e51f04d1fa4ca2c01
Author: Yang Hongyang <yanghy@cn.fujitsu.com>
Date:   Mon Apr 6 19:01:13 2009 -0700

    dma-mapping: replace all DMA_64BIT_MASK macro with DMA_BIT_MASK(64)
    
    Replace all DMA_64BIT_MASK macro with DMA_BIT_MASK(64)
    
    Signed-off-by: Yang Hongyang<yanghy@cn.fujitsu.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/scsi/dpt_i2o.c b/drivers/scsi/dpt_i2o.c
index 6194ed5d02c4..75a94e438fa5 100644
--- a/drivers/scsi/dpt_i2o.c
+++ b/drivers/scsi/dpt_i2o.c
@@ -1014,7 +1014,7 @@ static int adpt_install_hba(struct scsi_host_template* sht, struct pci_dev* pDev
 	 *	See if we should enable dma64 mode.
 	 */
 	if (sizeof(dma_addr_t) > 4 &&
-	    pci_set_dma_mask(pDev, DMA_64BIT_MASK) == 0) {
+	    pci_set_dma_mask(pDev, DMA_BIT_MASK(64)) == 0) {
 		if (dma_get_required_mask(&pDev->dev) > DMA_32BIT_MASK)
 			dma64 = 1;
 	}

commit df81d2371aeca0f7474f197a3090830899016e39
Author: Miquel van Smoorenburg <mikevs@xs4all.net>
Date:   Wed Nov 5 00:09:12 2008 +0100

    [SCSI] dpt_i2o: fix transferred data length for scsi_set_resid()
    
    dpt_i2o.c::adpt_i2o_to_scsi() reads the value at (reply+5) which
    should contain the length in bytes of the transferred data. This
    would be correct if reply was a u32 *. However it is a void * here,
    so we need to read the value at (reply+20) instead.
    
    The value at (reply+5) is usually 0xff0000, which is apparently
    'large enough' and didn't cause any trouble until 2.6.27 where
    
    commit 427e59f09fdba387547106de7bab980b7fff77be
    Author: James Bottomley <James.Bottomley@HansenPartnership.com>
    Date:   Sat Mar 8 18:24:17 2008 -0600
    
        [SCSI] make use of the residue value
    
    caused this to become visible through e.g. iostat -x .
    
    Signed-off-by: Miquel van Smoorenburg <mikevs@xs4all.net>
    Cc: Stable Tree <stable@kernel.org>
    Signed-off-by: James Bottomley <James.Bottomley@HansenPartnership.com>

diff --git a/drivers/scsi/dpt_i2o.c b/drivers/scsi/dpt_i2o.c
index 8aba4fdfb522..6194ed5d02c4 100644
--- a/drivers/scsi/dpt_i2o.c
+++ b/drivers/scsi/dpt_i2o.c
@@ -2445,7 +2445,7 @@ static s32 adpt_i2o_to_scsi(void __iomem *reply, struct scsi_cmnd* cmd)
 	hba_status = detailed_status >> 8;
 
 	// calculate resid for sg 
-	scsi_set_resid(cmd, scsi_bufflen(cmd) - readl(reply+5));
+	scsi_set_resid(cmd, scsi_bufflen(cmd) - readl(reply+20));
 
 	pHba = (adpt_hba*) cmd->device->host->hostdata[0];
 
@@ -2456,7 +2456,7 @@ static s32 adpt_i2o_to_scsi(void __iomem *reply, struct scsi_cmnd* cmd)
 		case I2O_SCSI_DSC_SUCCESS:
 			cmd->result = (DID_OK << 16);
 			// handle underflow
-			if(readl(reply+5) < cmd->underflow ) {
+			if (readl(reply+20) < cmd->underflow) {
 				cmd->result = (DID_ERROR <<16);
 				printk(KERN_WARNING"%s: SCSI CMD underflow\n",pHba->name);
 			}

commit d73a1a674b5383bb3b38ae3dd625504ffc623d90
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Mon Jul 21 20:03:34 2008 -0700

    device create: scsi: convert device_create_drvdata to device_create
    
    Now that device_create() has been audited, rename things back to the
    original call to be sane.
    
    Cc: James E.J. Bottomley <James.Bottomley@HansenPartnership.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/scsi/dpt_i2o.c b/drivers/scsi/dpt_i2o.c
index 1fe0901e8119..8aba4fdfb522 100644
--- a/drivers/scsi/dpt_i2o.c
+++ b/drivers/scsi/dpt_i2o.c
@@ -271,7 +271,7 @@ static int adpt_detect(struct scsi_host_template* sht)
 		pHba->initialized = TRUE;
 		pHba->state &= ~DPTI_STATE_RESET;
 		if (adpt_sysfs_class) {
-			struct device *dev = device_create_drvdata(adpt_sysfs_class,
+			struct device *dev = device_create(adpt_sysfs_class,
 				NULL, MKDEV(DPTI_I2O_MAJOR, pHba->unit), NULL,
 				"dpti%d", pHba->unit);
 			if (IS_ERR(dev)) {

commit 9def0b9761ee096c3c539b427dfb1e52b373cdad
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Wed May 21 12:52:33 2008 -0700

    device create: scsi: convert device_create to device_create_drvdata
    
    device_create() is race-prone, so use the race-free
    device_create_drvdata() instead as device_create() is going away.
    
    Cc: James E.J. Bottomley <James.Bottomley@HansenPartnership.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/scsi/dpt_i2o.c b/drivers/scsi/dpt_i2o.c
index 2bc30e32b67a..1fe0901e8119 100644
--- a/drivers/scsi/dpt_i2o.c
+++ b/drivers/scsi/dpt_i2o.c
@@ -271,8 +271,8 @@ static int adpt_detect(struct scsi_host_template* sht)
 		pHba->initialized = TRUE;
 		pHba->state &= ~DPTI_STATE_RESET;
 		if (adpt_sysfs_class) {
-			struct device *dev = device_create(adpt_sysfs_class,
-				NULL, MKDEV(DPTI_I2O_MAJOR, pHba->unit),
+			struct device *dev = device_create_drvdata(adpt_sysfs_class,
+				NULL, MKDEV(DPTI_I2O_MAJOR, pHba->unit), NULL,
 				"dpti%d", pHba->unit);
 			if (IS_ERR(dev)) {
 				printk(KERN_WARNING"dpti%d: unable to "

commit dea3f665d6fa263a9870a54e9f8cfd146016f140
Author: Jonathan Corbet <corbet@lwn.net>
Date:   Fri May 16 14:11:09 2008 -0600

    dpt_i20: BKL pushdown
    
    Add lock_kernel() calls to adpt_open()
    
    Signed-off-by: Jonathan Corbet <corbet@lwn.net>

diff --git a/drivers/scsi/dpt_i2o.c b/drivers/scsi/dpt_i2o.c
index 8508816f303d..2bc30e32b67a 100644
--- a/drivers/scsi/dpt_i2o.c
+++ b/drivers/scsi/dpt_i2o.c
@@ -49,6 +49,7 @@ MODULE_DESCRIPTION("Adaptec I2O RAID Driver");
 #include <linux/kernel.h>	/* for printk */
 #include <linux/sched.h>
 #include <linux/reboot.h>
+#include <linux/smp_lock.h>
 #include <linux/spinlock.h>
 #include <linux/dma-mapping.h>
 
@@ -1727,10 +1728,12 @@ static int adpt_open(struct inode *inode, struct file *file)
 	int minor;
 	adpt_hba* pHba;
 
+	lock_kernel();
 	//TODO check for root access
 	//
 	minor = iminor(inode);
 	if (minor >= hba_count) {
+		unlock_kernel();
 		return -ENXIO;
 	}
 	mutex_lock(&adpt_configuration_lock);
@@ -1741,6 +1744,7 @@ static int adpt_open(struct inode *inode, struct file *file)
 	}
 	if (pHba == NULL) {
 		mutex_unlock(&adpt_configuration_lock);
+		unlock_kernel();
 		return -ENXIO;
 	}
 
@@ -1751,6 +1755,7 @@ static int adpt_open(struct inode *inode, struct file *file)
 
 	pHba->in_use = 1;
 	mutex_unlock(&adpt_configuration_lock);
+	unlock_kernel();
 
 	return 0;
 }

commit 8b2cc917a02936c3ea7d8da46801c7b7b6233093
Author: Andrew Morton <akpm@linux-foundation.org>
Date:   Tue May 6 20:42:42 2008 -0700

    drivers/scsi/dpt_i2o.c: fix build on alpha
    
    alpha:
    
    drivers/scsi/dpt_i2o.c:1997: error: implicit declaration of function 'adpt_alpha_info'
    drivers/scsi/dpt_i2o.c: At top level:
    drivers/scsi/dpt_i2o.c:2032: warning: conflicting types for 'adpt_alpha_info'
    drivers/scsi/dpt_i2o.c:2032: error: static declaration of 'adpt_alpha_info' follows non-static declaration
    drivers/scsi/dpt_i2o.c:1997: error: previous implicit declaration of 'adpt_alpha_info' was here
    
    Due to a copy-n-paste error in drivers/scsi/dpti.h.
    
    Fix that up and remove some of the many daft static-declarations-in-a-header
    which this driver enjoys.
    
    Cc: Miquel van Smoorenburg <miquels@cistron.nl>
    Cc: James Bottomley <James.Bottomley@HansenPartnership.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/scsi/dpt_i2o.c b/drivers/scsi/dpt_i2o.c
index 0fb5bf4c43ac..8508816f303d 100644
--- a/drivers/scsi/dpt_i2o.c
+++ b/drivers/scsi/dpt_i2o.c
@@ -1967,45 +1967,6 @@ static int adpt_i2o_passthru(adpt_hba* pHba, u32 __user *arg)
 	return rcode;
 }
 
-
-/*
- * This routine returns information about the system.  This does not effect
- * any logic and if the info is wrong - it doesn't matter.
- */
-
-/* Get all the info we can not get from kernel services */
-static int adpt_system_info(void __user *buffer)
-{
-	sysInfo_S si;
-
-	memset(&si, 0, sizeof(si));
-
-	si.osType = OS_LINUX;
-	si.osMajorVersion = 0;
-	si.osMinorVersion = 0;
-	si.osRevision = 0;
-	si.busType = SI_PCI_BUS;
-	si.processorFamily = DPTI_sig.dsProcessorFamily;
-
-#if defined __i386__ 
-	adpt_i386_info(&si);
-#elif defined (__ia64__)
-	adpt_ia64_info(&si);
-#elif defined(__sparc__)
-	adpt_sparc_info(&si);
-#elif defined (__alpha__)
-	adpt_alpha_info(&si);
-#else
-	si.processorType = 0xff ;
-#endif
-	if(copy_to_user(buffer, &si, sizeof(si))){
-		printk(KERN_WARNING"dpti: Could not copy buffer TO user\n");
-		return -EFAULT;
-	}
-
-	return 0;
-}
-
 #if defined __ia64__ 
 static void adpt_ia64_info(sysInfo_S* si)
 {
@@ -2016,7 +1977,6 @@ static void adpt_ia64_info(sysInfo_S* si)
 }
 #endif
 
-
 #if defined __sparc__ 
 static void adpt_sparc_info(sysInfo_S* si)
 {
@@ -2026,7 +1986,6 @@ static void adpt_sparc_info(sysInfo_S* si)
 	si->processorType = PROC_ULTRASPARC;
 }
 #endif
-
 #if defined __alpha__ 
 static void adpt_alpha_info(sysInfo_S* si)
 {
@@ -2038,7 +1997,6 @@ static void adpt_alpha_info(sysInfo_S* si)
 #endif
 
 #if defined __i386__
-
 static void adpt_i386_info(sysInfo_S* si)
 {
 	// This is all the info we need for now
@@ -2059,9 +2017,45 @@ static void adpt_i386_info(sysInfo_S* si)
 		break;
 	}
 }
+#endif
+
+/*
+ * This routine returns information about the system.  This does not effect
+ * any logic and if the info is wrong - it doesn't matter.
+ */
 
+/* Get all the info we can not get from kernel services */
+static int adpt_system_info(void __user *buffer)
+{
+	sysInfo_S si;
+
+	memset(&si, 0, sizeof(si));
+
+	si.osType = OS_LINUX;
+	si.osMajorVersion = 0;
+	si.osMinorVersion = 0;
+	si.osRevision = 0;
+	si.busType = SI_PCI_BUS;
+	si.processorFamily = DPTI_sig.dsProcessorFamily;
+
+#if defined __i386__
+	adpt_i386_info(&si);
+#elif defined (__ia64__)
+	adpt_ia64_info(&si);
+#elif defined(__sparc__)
+	adpt_sparc_info(&si);
+#elif defined (__alpha__)
+	adpt_alpha_info(&si);
+#else
+	si.processorType = 0xff ;
 #endif
+	if (copy_to_user(buffer, &si, sizeof(si))){
+		printk(KERN_WARNING"dpti: Could not copy buffer TO user\n");
+		return -EFAULT;
+	}
 
+	return 0;
+}
 
 static int adpt_ioctl(struct inode *inode, struct file *file, uint cmd,
 	      ulong arg)

commit d626e3bf728c47746f2129aa00c775d4e8c2a73b
Merge: b66e1f11ebc4 7ad4a485002c
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Fri May 2 13:52:35 2008 -0700

    Merge git://git.kernel.org/pub/scm/linux/kernel/git/jejb/scsi-misc-2.6
    
    * git://git.kernel.org/pub/scm/linux/kernel/git/jejb/scsi-misc-2.6:
      [SCSI] aic94xx: fix section mismatch
      [SCSI] u14-34f: Fix 32bit only problem
      [SCSI] dpt_i2o: sysfs code
      [SCSI] dpt_i2o: 64 bit support
      [SCSI] dpt_i2o: move from virt_to_bus/bus_to_virt to dma_alloc_coherent
      [SCSI] dpt_i2o: use standard __init / __exit code
      [SCSI] megaraid_sas: fix suspend/resume sections
      [SCSI] aacraid: Add Power Management support
      [SCSI] aacraid: Fix jbod operations scan issues
      [SCSI] aacraid: Fix warning about macro side-effects
      [SCSI] add support for variable length extended commands
      [SCSI] Let scsi_cmnd->cmnd use request->cmd buffer
      [SCSI] bsg: add large command support
      [SCSI] aacraid: Fix down_interruptible() to check the return value correctly
      [SCSI] megaraid_sas; Update the Version and Changelog
      [SCSI] ibmvscsi: Handle non SCSI error status
      [SCSI] bug fix for free list handling
      [SCSI] ipr: Rename ipr's state scsi host attribute to prevent collisions
      [SCSI] megaraid_mbox: fix Dell CERC firmware problem

commit 1ed43910956f5faec690ea3214451779e93bbb52
Author: Miquel van Smoorenburg <miquels@cistron.nl>
Date:   Fri May 2 01:08:19 2008 +0200

    [SCSI] dpt_i2o: sysfs code
    
    Create a /sys/class/dpt_i2o directory and populate it with
    dptiN directories. Each dptiN directory contains a "dev" file
    that makes udev create /dev/dptiN
    
    Signed-off-by: Miquel van Smoorenburg <miquels@cistron.nl>
    Acked-by: Mark Salyzyn <Mark_Salyzyn@adaptec.com>
    Signed-off-by: James Bottomley <James.Bottomley@HansenPartnership.com>

diff --git a/drivers/scsi/dpt_i2o.c b/drivers/scsi/dpt_i2o.c
index dc6b2d4a9aa1..8939fbf102fc 100644
--- a/drivers/scsi/dpt_i2o.c
+++ b/drivers/scsi/dpt_i2o.c
@@ -111,6 +111,8 @@ static int sys_tbl_len;
 static adpt_hba* hba_chain = NULL;
 static int hba_count = 0;
 
+static struct class *adpt_sysfs_class;
+
 #ifdef CONFIG_COMPAT
 static long compat_adpt_ioctl(struct file *, unsigned int, unsigned long);
 #endif
@@ -254,6 +256,12 @@ static int adpt_detect(struct scsi_host_template* sht)
 		adpt_inquiry(pHba);
 	}
 
+	adpt_sysfs_class = class_create(THIS_MODULE, "dpt_i2o");
+	if (IS_ERR(adpt_sysfs_class)) {
+		printk(KERN_WARNING"dpti: unable to create dpt_i2o class\n");
+		adpt_sysfs_class = NULL;
+	}
+
 	for (pHba = hba_chain; pHba; pHba = pHba->next) {
 		if (adpt_scsi_host_alloc(pHba, sht) < 0){
 			adpt_i2o_delete_hba(pHba);
@@ -261,6 +269,16 @@ static int adpt_detect(struct scsi_host_template* sht)
 		}
 		pHba->initialized = TRUE;
 		pHba->state &= ~DPTI_STATE_RESET;
+		if (adpt_sysfs_class) {
+			struct device *dev = device_create(adpt_sysfs_class,
+				NULL, MKDEV(DPTI_I2O_MAJOR, pHba->unit),
+				"dpti%d", pHba->unit);
+			if (IS_ERR(dev)) {
+				printk(KERN_WARNING"dpti%d: unable to "
+					"create device in dpt_i2o class\n",
+					pHba->unit);
+			}
+		}
 	}
 
 	// Register our control device node
@@ -1212,8 +1230,16 @@ static void adpt_i2o_delete_hba(adpt_hba* pHba)
 	pci_dev_put(pHba->pDev);
 	kfree(pHba);
 
+	if (adpt_sysfs_class)
+		device_destroy(adpt_sysfs_class,
+				MKDEV(DPTI_I2O_MAJOR, pHba->unit));
+
 	if(hba_count <= 0){
 		unregister_chrdev(DPTI_I2O_MAJOR, DPT_DRIVER);   
+		if (adpt_sysfs_class) {
+			class_destroy(adpt_sysfs_class);
+			adpt_sysfs_class = NULL;
+		}
 	}
 }
 

commit 62ac5aedc51485d672a5d91c262a001acecbe447
Author: Miquel van Smoorenburg <miquels@cistron.nl>
Date:   Fri May 2 01:07:27 2008 +0200

    [SCSI] dpt_i2o: 64 bit support
    
    This is the code to actually support 64 bit platforms. 64 bit
    DMA is enabled on both x86_32 PAE and 64 bit platforms.
    
    This code is based in part on the unofficial adaptec 64-bit
    dpt_i2o driver update that I got from Mark Salyzyn at Adaptec.
    
    Signed-off-by: Miquel van Smoorenburg <miquels@cistron.nl>
    Acked-by: Mark Salyzyn <Mark_Salyzyn@adaptec.com>
    Signed-off-by: James Bottomley <James.Bottomley@HansenPartnership.com>

diff --git a/drivers/scsi/dpt_i2o.c b/drivers/scsi/dpt_i2o.c
index 7b1a084ec94e..dc6b2d4a9aa1 100644
--- a/drivers/scsi/dpt_i2o.c
+++ b/drivers/scsi/dpt_i2o.c
@@ -111,10 +111,17 @@ static int sys_tbl_len;
 static adpt_hba* hba_chain = NULL;
 static int hba_count = 0;
 
+#ifdef CONFIG_COMPAT
+static long compat_adpt_ioctl(struct file *, unsigned int, unsigned long);
+#endif
+
 static const struct file_operations adpt_fops = {
 	.ioctl		= adpt_ioctl,
 	.open		= adpt_open,
-	.release	= adpt_close
+	.release	= adpt_close,
+#ifdef CONFIG_COMPAT
+	.compat_ioctl	= compat_adpt_ioctl,
+#endif
 };
 
 /* Structures and definitions for synchronous message posting.
@@ -138,6 +145,11 @@ static DEFINE_SPINLOCK(adpt_post_wait_lock);
  *============================================================================
  */
 
+static inline int dpt_dma64(adpt_hba *pHba)
+{
+	return (sizeof(dma_addr_t) > 4 && (pHba)->dma64);
+}
+
 static inline u32 dma_high(dma_addr_t addr)
 {
 	return upper_32_bits(addr);
@@ -277,7 +289,7 @@ static int adpt_release(struct Scsi_Host *host)
 
 static void adpt_inquiry(adpt_hba* pHba)
 {
-	u32 msg[14]; 
+	u32 msg[17]; 
 	u32 *mptr;
 	u32 *lenptr;
 	int direction;
@@ -301,7 +313,10 @@ static void adpt_inquiry(adpt_hba* pHba)
 	direction = 0x00000000;	
 	scsidir  =0x40000000;	// DATA IN  (iop<--dev)
 
-	reqlen = 14;		// SINGLE SGE
+	if (dpt_dma64(pHba))
+		reqlen = 17;		// SINGLE SGE, 64 bit
+	else
+		reqlen = 14;		// SINGLE SGE, 32 bit
 	/* Stick the headers on */
 	msg[0] = reqlen<<16 | SGL_OFFSET_12;
 	msg[1] = (0xff<<24|HOST_TID<<12|ADAPTER_TID);
@@ -334,8 +349,16 @@ static void adpt_inquiry(adpt_hba* pHba)
 
 	/* Now fill in the SGList and command */
 	*lenptr = len;
-	*mptr++ = 0xD0000000|direction|len;
-	*mptr++ = addr;
+	if (dpt_dma64(pHba)) {
+		*mptr++ = (0x7C<<24)+(2<<16)+0x02; /* Enable 64 bit */
+		*mptr++ = 1 << PAGE_SHIFT;
+		*mptr++ = 0xD0000000|direction|len;
+		*mptr++ = dma_low(addr);
+		*mptr++ = dma_high(addr);
+	} else {
+		*mptr++ = 0xD0000000|direction|len;
+		*mptr++ = addr;
+	}
 
 	// Send it on it's way
 	rcode = adpt_i2o_post_wait(pHba, msg, reqlen<<2, 120);
@@ -628,6 +651,92 @@ static int adpt_proc_info(struct Scsi_Host *host, char *buffer, char **start, of
 	return len;
 }
 
+/*
+ *	Turn a struct scsi_cmnd * into a unique 32 bit 'context'.
+ */
+static u32 adpt_cmd_to_context(struct scsi_cmnd *cmd)
+{
+	return (u32)cmd->serial_number;
+}
+
+/*
+ *	Go from a u32 'context' to a struct scsi_cmnd * .
+ *	This could probably be made more efficient.
+ */
+static struct scsi_cmnd *
+	adpt_cmd_from_context(adpt_hba * pHba, u32 context)
+{
+	struct scsi_cmnd * cmd;
+	struct scsi_device * d;
+
+	if (context == 0)
+		return NULL;
+
+	spin_unlock(pHba->host->host_lock);
+	shost_for_each_device(d, pHba->host) {
+		unsigned long flags;
+		spin_lock_irqsave(&d->list_lock, flags);
+		list_for_each_entry(cmd, &d->cmd_list, list) {
+			if (((u32)cmd->serial_number == context)) {
+				spin_unlock_irqrestore(&d->list_lock, flags);
+				scsi_device_put(d);
+				spin_lock(pHba->host->host_lock);
+				return cmd;
+			}
+		}
+		spin_unlock_irqrestore(&d->list_lock, flags);
+	}
+	spin_lock(pHba->host->host_lock);
+
+	return NULL;
+}
+
+/*
+ *	Turn a pointer to ioctl reply data into an u32 'context'
+ */
+static u32 adpt_ioctl_to_context(adpt_hba * pHba, void *reply)
+{
+#if BITS_PER_LONG == 32
+	return (u32)(unsigned long)reply;
+#else
+	ulong flags = 0;
+	u32 nr, i;
+
+	spin_lock_irqsave(pHba->host->host_lock, flags);
+	nr = ARRAY_SIZE(pHba->ioctl_reply_context);
+	for (i = 0; i < nr; i++) {
+		if (pHba->ioctl_reply_context[i] == NULL) {
+			pHba->ioctl_reply_context[i] = reply;
+			break;
+		}
+	}
+	spin_unlock_irqrestore(pHba->host->host_lock, flags);
+	if (i >= nr) {
+		kfree (reply);
+		printk(KERN_WARNING"%s: Too many outstanding "
+				"ioctl commands\n", pHba->name);
+		return (u32)-1;
+	}
+
+	return i;
+#endif
+}
+
+/*
+ *	Go from an u32 'context' to a pointer to ioctl reply data.
+ */
+static void *adpt_ioctl_from_context(adpt_hba *pHba, u32 context)
+{
+#if BITS_PER_LONG == 32
+	return (void *)(unsigned long)context;
+#else
+	void *p = pHba->ioctl_reply_context[context];
+	pHba->ioctl_reply_context[context] = NULL;
+
+	return p;
+#endif
+}
+
 /*===========================================================================
  * Error Handling routines
  *===========================================================================
@@ -655,7 +764,7 @@ static int adpt_abort(struct scsi_cmnd * cmd)
 	msg[1] = I2O_CMD_SCSI_ABORT<<24|HOST_TID<<12|dptdevice->tid;
 	msg[2] = 0;
 	msg[3]= 0; 
-	msg[4] = (u32)cmd;
+	msg[4] = adpt_cmd_to_context(cmd);
 	if (pHba->host)
 		spin_lock_irq(pHba->host->host_lock);
 	rcode = adpt_i2o_post_wait(pHba, msg, sizeof(msg), FOREVER);
@@ -867,6 +976,7 @@ static int adpt_install_hba(struct scsi_host_template* sht, struct pci_dev* pDev
 	u32 hba_map1_area_size = 0;
 	void __iomem *base_addr_virt = NULL;
 	void __iomem *msg_addr_virt = NULL;
+	int dma64 = 0;
 
 	int raptorFlag = FALSE;
 
@@ -880,7 +990,16 @@ static int adpt_install_hba(struct scsi_host_template* sht, struct pci_dev* pDev
 	}
 
 	pci_set_master(pDev);
-	if (pci_set_dma_mask(pDev, DMA_32BIT_MASK))
+
+	/*
+	 *	See if we should enable dma64 mode.
+	 */
+	if (sizeof(dma_addr_t) > 4 &&
+	    pci_set_dma_mask(pDev, DMA_64BIT_MASK) == 0) {
+		if (dma_get_required_mask(&pDev->dev) > DMA_32BIT_MASK)
+			dma64 = 1;
+	}
+	if (!dma64 && pci_set_dma_mask(pDev, DMA_32BIT_MASK) != 0)
 		return -EINVAL;
 
 	/* adapter only supports message blocks below 4GB */
@@ -906,6 +1025,25 @@ static int adpt_install_hba(struct scsi_host_template* sht, struct pci_dev* pDev
 		raptorFlag = TRUE;
 	}
 
+#if BITS_PER_LONG == 64
+	/*
+	 *	The original Adaptec 64 bit driver has this comment here:
+	 *	"x86_64 machines need more optimal mappings"
+	 *
+	 *	I assume some HBAs report ridiculously large mappings
+	 *	and we need to limit them on platforms with IOMMUs.
+	 */
+	if (raptorFlag == TRUE) {
+		if (hba_map0_area_size > 128)
+			hba_map0_area_size = 128;
+		if (hba_map1_area_size > 524288)
+			hba_map1_area_size = 524288;
+	} else {
+		if (hba_map0_area_size > 524288)
+			hba_map0_area_size = 524288;
+	}
+#endif
+
 	base_addr_virt = ioremap(base_addr0_phys,hba_map0_area_size);
 	if (!base_addr_virt) {
 		pci_release_regions(pDev);
@@ -968,16 +1106,22 @@ static int adpt_install_hba(struct scsi_host_template* sht, struct pci_dev* pDev
 	pHba->state = DPTI_STATE_RESET;
 	pHba->pDev = pDev;
 	pHba->devices = NULL;
+	pHba->dma64 = dma64;
 
 	// Initializing the spinlocks
 	spin_lock_init(&pHba->state_lock);
 	spin_lock_init(&adpt_post_wait_lock);
 
 	if(raptorFlag == 0){
-		printk(KERN_INFO"Adaptec I2O RAID controller %d at %p size=%x irq=%d\n", 
-			hba_count-1, base_addr_virt, hba_map0_area_size, pDev->irq);
+		printk(KERN_INFO "Adaptec I2O RAID controller"
+				 " %d at %p size=%x irq=%d%s\n", 
+			hba_count-1, base_addr_virt,
+			hba_map0_area_size, pDev->irq,
+			dma64 ? " (64-bit DMA)" : "");
 	} else {
-		printk(KERN_INFO"Adaptec I2O RAID controller %d irq=%d\n",hba_count-1, pDev->irq);
+		printk(KERN_INFO"Adaptec I2O RAID controller %d irq=%d%s\n",
+			hba_count-1, pDev->irq,
+			dma64 ? " (64-bit DMA)" : "");
 		printk(KERN_INFO"     BAR0 %p - size= %x\n",base_addr_virt,hba_map0_area_size);
 		printk(KERN_INFO"     BAR1 %p - size= %x\n",msg_addr_virt,hba_map1_area_size);
 	}
@@ -1030,6 +1174,8 @@ static void adpt_i2o_delete_hba(adpt_hba* pHba)
 	if(pHba->msg_addr_virt != pHba->base_addr_virt){
 		iounmap(pHba->msg_addr_virt);
 	}
+	if(pHba->FwDebugBuffer_P)
+	   	iounmap(pHba->FwDebugBuffer_P);
 	if(pHba->hrt) {
 		dma_free_coherent(&pHba->pDev->dev,
 			pHba->hrt->num_entries * pHba->hrt->entry_len << 2,
@@ -1657,10 +1803,13 @@ static int adpt_i2o_passthru(adpt_hba* pHba, u32 __user *arg)
 	}
 	sg_offset = (msg[0]>>4)&0xf;
 	msg[2] = 0x40000000; // IOCTL context
-	msg[3] = (u32)reply;
+	msg[3] = adpt_ioctl_to_context(pHba, reply);
+	if (msg[3] == (u32)-1)
+		return -EBUSY;
+
 	memset(sg_list,0, sizeof(sg_list[0])*pHba->sg_tablesize);
 	if(sg_offset) {
-		// TODO 64bit fix
+		// TODO add 64 bit API
 		struct sg_simple_element *sg =  (struct sg_simple_element*) (msg+sg_offset);
 		sg_count = (size - sg_offset*4) / sizeof(struct sg_simple_element);
 		if (sg_count > pHba->sg_tablesize){
@@ -1689,15 +1838,15 @@ static int adpt_i2o_passthru(adpt_hba* pHba, u32 __user *arg)
 			sg_list[sg_index++] = p; // sglist indexed with input frame, not our internal frame.
 			/* Copy in the user's SG buffer if necessary */
 			if(sg[i].flag_count & 0x04000000 /*I2O_SGL_FLAGS_DIR*/) {
-				// TODO 64bit fix
-				if (copy_from_user(p,(void __user *)sg[i].addr_bus, sg_size)) {
+				// sg_simple_element API is 32 bit
+				if (copy_from_user(p,(void __user *)(ulong)sg[i].addr_bus, sg_size)) {
 					printk(KERN_DEBUG"%s: Could not copy SG buf %d FROM user\n",pHba->name,i);
 					rcode = -EFAULT;
 					goto cleanup;
 				}
 			}
-			//TODO 64bit fix
-			sg[i].addr_bus = (u32)virt_to_bus(p);
+			/* sg_simple_element API is 32 bit, but addr < 4GB */
+			sg[i].addr_bus = addr;
 		}
 	}
 
@@ -1725,7 +1874,7 @@ static int adpt_i2o_passthru(adpt_hba* pHba, u32 __user *arg)
 	if(sg_offset) {
 	/* Copy back the Scatter Gather buffers back to user space */
 		u32 j;
-		// TODO 64bit fix
+		// TODO add 64 bit API
 		struct sg_simple_element* sg;
 		int sg_size;
 
@@ -1745,14 +1894,14 @@ static int adpt_i2o_passthru(adpt_hba* pHba, u32 __user *arg)
 		}
 		sg_count = (size - sg_offset*4) / sizeof(struct sg_simple_element);
 
-		// TODO 64bit fix
+		// TODO add 64 bit API
 		sg 	 = (struct sg_simple_element*)(msg + sg_offset);
 		for (j = 0; j < sg_count; j++) {
 			/* Copy out the SG list to user's buffer if necessary */
 			if(! (sg[j].flag_count & 0x4000000 /*I2O_SGL_FLAGS_DIR*/)) {
 				sg_size = sg[j].flag_count & 0xffffff; 
-				// TODO 64bit fix
-				if (copy_to_user((void __user *)sg[j].addr_bus,sg_list[j], sg_size)) {
+				// sg_simple_element API is 32 bit
+				if (copy_to_user((void __user *)(ulong)sg[j].addr_bus,sg_list[j], sg_size)) {
 					printk(KERN_WARNING"%s: Could not copy %p TO user %x\n",pHba->name, sg_list[j], sg[j].addr_bus);
 					rcode = -EFAULT;
 					goto cleanup;
@@ -1972,6 +2121,38 @@ static int adpt_ioctl(struct inode *inode, struct file *file, uint cmd,
 	return error;
 }
 
+#ifdef CONFIG_COMPAT
+static long compat_adpt_ioctl(struct file *file,
+				unsigned int cmd, unsigned long arg)
+{
+	struct inode *inode;
+	long ret;
+ 
+	inode = file->f_dentry->d_inode;
+ 
+	lock_kernel();
+ 
+	switch(cmd) {
+		case DPT_SIGNATURE:
+		case I2OUSRCMD:
+		case DPT_CTRLINFO:
+		case DPT_SYSINFO:
+		case DPT_BLINKLED:
+		case I2ORESETCMD:
+		case I2ORESCANCMD:
+		case (DPT_TARGET_BUSY & 0xFFFF):
+		case DPT_TARGET_BUSY:
+			ret = adpt_ioctl(inode, file, cmd, arg);
+			break;
+		default:
+			ret =  -ENOIOCTLCMD;
+	}
+ 
+	unlock_kernel();
+ 
+	return ret;
+}
+#endif
 
 static irqreturn_t adpt_isr(int irq, void *dev_id)
 {
@@ -2032,7 +2213,7 @@ static irqreturn_t adpt_isr(int irq, void *dev_id)
 		} 
 		context = readl(reply+8);
 		if(context & 0x40000000){ // IOCTL
-			void *p = (void *)readl(reply+12);
+			void *p = adpt_ioctl_from_context(pHba, readl(reply+12));
 			if( p != NULL) {
 				memcpy_fromio(p, reply, REPLY_FRAME_SIZE * 4);
 			}
@@ -2046,14 +2227,15 @@ static irqreturn_t adpt_isr(int irq, void *dev_id)
 				status = I2O_POST_WAIT_OK;
 			}
 			if(!(context & 0x40000000)) {
-				cmd = (struct scsi_cmnd*) readl(reply+12); 
+				cmd = adpt_cmd_from_context(pHba,
+							readl(reply+12));
 				if(cmd != NULL) {
 					printk(KERN_WARNING"%s: Apparent SCSI cmd in Post Wait Context - cmd=%p context=%x\n", pHba->name, cmd, context);
 				}
 			}
 			adpt_i2o_post_wait_complete(context, status);
 		} else { // SCSI message
-			cmd = (struct scsi_cmnd*) readl(reply+12); 
+			cmd = adpt_cmd_from_context (pHba, readl(reply+12));
 			if(cmd != NULL){
 				scsi_dma_unmap(cmd);
 				if(cmd->serial_number != 0) { // If not timedout
@@ -2076,6 +2258,7 @@ static s32 adpt_scsi_to_i2o(adpt_hba* pHba, struct scsi_cmnd* cmd, struct adpt_d
 	int i;
 	u32 msg[MAX_MESSAGE_SIZE];
 	u32* mptr;
+	u32* lptr;
 	u32 *lenptr;
 	int direction;
 	int scsidir;
@@ -2083,6 +2266,7 @@ static s32 adpt_scsi_to_i2o(adpt_hba* pHba, struct scsi_cmnd* cmd, struct adpt_d
 	u32 len;
 	u32 reqlen;
 	s32 rcode;
+	dma_addr_t addr;
 
 	memset(msg, 0 , sizeof(msg));
 	len = scsi_bufflen(cmd);
@@ -2122,7 +2306,7 @@ static s32 adpt_scsi_to_i2o(adpt_hba* pHba, struct scsi_cmnd* cmd, struct adpt_d
 	// I2O_CMD_SCSI_EXEC
 	msg[1] = ((0xff<<24)|(HOST_TID<<12)|d->tid);
 	msg[2] = 0;
-	msg[3] = (u32)cmd;	/* We want the SCSI control block back */
+	msg[3] = adpt_cmd_to_context(cmd);  /* Want SCSI control block back */
 	// Our cards use the transaction context as the tag for queueing
 	// Adaptec/DPT Private stuff 
 	msg[4] = I2O_CMD_SCSI_EXEC|(DPT_ORGANIZATION_ID<<16);
@@ -2140,7 +2324,13 @@ static s32 adpt_scsi_to_i2o(adpt_hba* pHba, struct scsi_cmnd* cmd, struct adpt_d
 	memcpy(mptr, cmd->cmnd, cmd->cmd_len);
 	mptr+=4;
 	lenptr=mptr++;		/* Remember me - fill in when we know */
-	reqlen = 14;		// SINGLE SGE
+	if (dpt_dma64(pHba)) {
+		reqlen = 16;		// SINGLE SGE
+		*mptr++ = (0x7C<<24)+(2<<16)+0x02; /* Enable 64 bit */
+		*mptr++ = 1 << PAGE_SHIFT;
+	} else {
+		reqlen = 14;		// SINGLE SGE
+	}
 	/* Now fill in the SGList and command */
 
 	nseg = scsi_dma_map(cmd);
@@ -2150,12 +2340,16 @@ static s32 adpt_scsi_to_i2o(adpt_hba* pHba, struct scsi_cmnd* cmd, struct adpt_d
 
 		len = 0;
 		scsi_for_each_sg(cmd, sg, nseg, i) {
+			lptr = mptr;
 			*mptr++ = direction|0x10000000|sg_dma_len(sg);
 			len+=sg_dma_len(sg);
-			*mptr++ = sg_dma_address(sg);
+			addr = sg_dma_address(sg);
+			*mptr++ = dma_low(addr);
+			if (dpt_dma64(pHba))
+				*mptr++ = dma_high(addr);
 			/* Make this an end of list */
 			if (i == nseg - 1)
-				mptr[-2] = direction|0xD0000000|sg_dma_len(sg);
+				*lptr = direction|0xD0000000|sg_dma_len(sg);
 		}
 		reqlen = mptr - msg;
 		*lenptr = len;
@@ -2824,7 +3018,17 @@ static s32 adpt_i2o_status_get(adpt_hba* pHba)
 	}
 
 	// Calculate the Scatter Gather list size
-	pHba->sg_tablesize = (pHba->status_block->inbound_frame_size * 4 -40)/ sizeof(struct sg_simple_element);
+	if (dpt_dma64(pHba)) {
+		pHba->sg_tablesize
+		  = ((pHba->status_block->inbound_frame_size * 4
+		  - 14 * sizeof(u32))
+		  / (sizeof(struct sg_simple_element) + sizeof(u32)));
+	} else {
+		pHba->sg_tablesize
+		  = ((pHba->status_block->inbound_frame_size * 4
+		  - 12 * sizeof(u32))
+		  / sizeof(struct sg_simple_element));
+	}
 	if (pHba->sg_tablesize > SG_LIST_ELEMENTS) {
 		pHba->sg_tablesize = SG_LIST_ELEMENTS;
 	}
@@ -2916,13 +3120,19 @@ static int adpt_i2o_lct_get(adpt_hba* pHba)
 	// I2O_DPT_EXEC_IOP_BUFFERS_GROUP_NO;
 	if(adpt_i2o_query_scalar(pHba, 0 , 0x8000, -1, buf, sizeof(buf))>=0) {
 		pHba->FwDebugBufferSize = buf[1];
-		pHba->FwDebugBuffer_P    = pHba->base_addr_virt + buf[0];
-		pHba->FwDebugFlags_P     = pHba->FwDebugBuffer_P + FW_DEBUG_FLAGS_OFFSET;
-		pHba->FwDebugBLEDvalue_P = pHba->FwDebugBuffer_P + FW_DEBUG_BLED_OFFSET;
-		pHba->FwDebugBLEDflag_P  = pHba->FwDebugBLEDvalue_P + 1;
-		pHba->FwDebugStrLength_P = pHba->FwDebugBuffer_P + FW_DEBUG_STR_LENGTH_OFFSET;
-		pHba->FwDebugBuffer_P += buf[2]; 
-		pHba->FwDebugFlags = 0;
+		pHba->FwDebugBuffer_P = ioremap(pHba->base_addr_phys + buf[0],
+						pHba->FwDebugBufferSize);
+		if (pHba->FwDebugBuffer_P) {
+			pHba->FwDebugFlags_P     = pHba->FwDebugBuffer_P +
+							FW_DEBUG_FLAGS_OFFSET;
+			pHba->FwDebugBLEDvalue_P = pHba->FwDebugBuffer_P +
+							FW_DEBUG_BLED_OFFSET;
+			pHba->FwDebugBLEDflag_P  = pHba->FwDebugBLEDvalue_P + 1;
+			pHba->FwDebugStrLength_P = pHba->FwDebugBuffer_P +
+						FW_DEBUG_STR_LENGTH_OFFSET;
+			pHba->FwDebugBuffer_P += buf[2]; 
+			pHba->FwDebugFlags = 0;
+		}
 	}
 
 	return 0;

commit 67af2b060e027c84b8e48d77e00b2369d997c0d4
Author: Miquel van Smoorenburg <miquels@cistron.nl>
Date:   Fri May 2 01:06:39 2008 +0200

    [SCSI] dpt_i2o: move from virt_to_bus/bus_to_virt to dma_alloc_coherent
    
    Remove virt_to_bus/bus_to_virt code from dpt_i2o, and use
    dma_alloc_coherent() / dma_free_coherent().
    
    This is in preparation of 64-bit support, dma_alloc_coherent()
    can allocate memory in the lower 32 bits of physical memory
    which is needed because the HBA only supports message blocks under 4GB
    
    This code is based in part on the unofficial adaptec 64-bit
    dpt_i2o driver update that I got from Mark Salyzyn at Adaptec.
    
    Signed-off-by: Miquel van Smoorenburg <miquels@cistron.nl>
    Acked-by: Mark Salyzyn <Mark_Salyzyn@adaptec.com>
    Signed-off-by: James Bottomley <James.Bottomley@HansenPartnership.com>

diff --git a/drivers/scsi/dpt_i2o.c b/drivers/scsi/dpt_i2o.c
index 30c741a12a62..7b1a084ec94e 100644
--- a/drivers/scsi/dpt_i2o.c
+++ b/drivers/scsi/dpt_i2o.c
@@ -29,11 +29,6 @@
 /*#define DEBUG 1 */
 /*#define UARTDELAY 1 */
 
-/* On the real kernel ADDR32 should always be zero for 2.4. GFP_HIGH allocates
-   high pages. Keep the macro around because of the broken unmerged ia64 tree */
-
-#define ADDR32 (0)
-
 #include <linux/module.h>
 
 MODULE_AUTHOR("Deanna Bonds, with _lots_ of help from Mark Salyzyn");
@@ -108,9 +103,10 @@ static dpt_sig_S DPTI_sig = {
 
 static DEFINE_MUTEX(adpt_configuration_lock);
 
-static struct i2o_sys_tbl *sys_tbl = NULL;
-static int sys_tbl_ind = 0;
-static int sys_tbl_len = 0;
+static struct i2o_sys_tbl *sys_tbl;
+static dma_addr_t sys_tbl_pa;
+static int sys_tbl_ind;
+static int sys_tbl_len;
 
 static adpt_hba* hba_chain = NULL;
 static int hba_count = 0;
@@ -142,6 +138,16 @@ static DEFINE_SPINLOCK(adpt_post_wait_lock);
  *============================================================================
  */
 
+static inline u32 dma_high(dma_addr_t addr)
+{
+	return upper_32_bits(addr);
+}
+
+static inline u32 dma_low(dma_addr_t addr)
+{
+	return (u32)addr;
+}
+
 static u8 adpt_read_blink_led(adpt_hba* host)
 {
 	if(host->FwDebugBLEDflag_P != 0) {
@@ -279,11 +285,12 @@ static void adpt_inquiry(adpt_hba* pHba)
 	u32 len;
 	u32 reqlen;
 	u8* buf;
+	dma_addr_t addr;
 	u8  scb[16];
 	s32 rcode;
 
 	memset(msg, 0, sizeof(msg));
-	buf = kmalloc(80,GFP_KERNEL|ADDR32);
+	buf = dma_alloc_coherent(&pHba->pDev->dev, 80, &addr, GFP_KERNEL);
 	if(!buf){
 		printk(KERN_ERR"%s: Could not allocate buffer\n",pHba->name);
 		return;
@@ -328,7 +335,7 @@ static void adpt_inquiry(adpt_hba* pHba)
 	/* Now fill in the SGList and command */
 	*lenptr = len;
 	*mptr++ = 0xD0000000|direction|len;
-	*mptr++ = virt_to_bus(buf);
+	*mptr++ = addr;
 
 	// Send it on it's way
 	rcode = adpt_i2o_post_wait(pHba, msg, reqlen<<2, 120);
@@ -336,7 +343,7 @@ static void adpt_inquiry(adpt_hba* pHba)
 		sprintf(pHba->detail, "Adaptec I2O RAID");
 		printk(KERN_INFO "%s: Inquiry Error (%d)\n",pHba->name,rcode);
 		if (rcode != -ETIME && rcode != -EINTR)
-			kfree(buf);
+			dma_free_coherent(&pHba->pDev->dev, 80, buf, addr);
 	} else {
 		memset(pHba->detail, 0, sizeof(pHba->detail));
 		memcpy(&(pHba->detail), "Vendor: Adaptec ", 16);
@@ -345,7 +352,7 @@ static void adpt_inquiry(adpt_hba* pHba)
 		memcpy(&(pHba->detail[40]), " FW: ", 4);
 		memcpy(&(pHba->detail[44]), (u8*) &buf[32], 4);
 		pHba->detail[48] = '\0';	/* precautionary */
-		kfree(buf);
+		dma_free_coherent(&pHba->pDev->dev, 80, buf, addr);
 	}
 	adpt_i2o_status_get(pHba);
 	return ;
@@ -621,7 +628,6 @@ static int adpt_proc_info(struct Scsi_Host *host, char *buffer, char **start, of
 	return len;
 }
 
-
 /*===========================================================================
  * Error Handling routines
  *===========================================================================
@@ -877,6 +883,9 @@ static int adpt_install_hba(struct scsi_host_template* sht, struct pci_dev* pDev
 	if (pci_set_dma_mask(pDev, DMA_32BIT_MASK))
 		return -EINVAL;
 
+	/* adapter only supports message blocks below 4GB */
+	pci_set_consistent_dma_mask(pDev, DMA_32BIT_MASK);
+
 	base_addr0_phys = pci_resource_start(pDev,0);
 	hba_map0_area_size = pci_resource_len(pDev,0);
 
@@ -1021,10 +1030,24 @@ static void adpt_i2o_delete_hba(adpt_hba* pHba)
 	if(pHba->msg_addr_virt != pHba->base_addr_virt){
 		iounmap(pHba->msg_addr_virt);
 	}
-	kfree(pHba->hrt);
-	kfree(pHba->lct);
-	kfree(pHba->status_block);
-	kfree(pHba->reply_pool);
+	if(pHba->hrt) {
+		dma_free_coherent(&pHba->pDev->dev,
+			pHba->hrt->num_entries * pHba->hrt->entry_len << 2,
+			pHba->hrt, pHba->hrt_pa);
+	}
+	if(pHba->lct) {
+		dma_free_coherent(&pHba->pDev->dev, pHba->lct_size,
+			pHba->lct, pHba->lct_pa);
+	}
+	if(pHba->status_block) {
+		dma_free_coherent(&pHba->pDev->dev, sizeof(i2o_status_block),
+			pHba->status_block, pHba->status_block_pa);
+	}
+	if(pHba->reply_pool) {
+		dma_free_coherent(&pHba->pDev->dev,
+			pHba->reply_fifo_size * REPLY_FRAME_SIZE * 4,
+			pHba->reply_pool, pHba->reply_pool_pa);
+	}
 
 	for(d = pHba->devices; d ; d = next){
 		next = d->next;
@@ -1239,6 +1262,7 @@ static s32 adpt_i2o_reset_hba(adpt_hba* pHba)
 {
 	u32 msg[8];
 	u8* status;
+	dma_addr_t addr;
 	u32 m = EMPTY_QUEUE ;
 	ulong timeout = jiffies + (TMOUT_IOPRESET*HZ);
 
@@ -1261,12 +1285,13 @@ static s32 adpt_i2o_reset_hba(adpt_hba* pHba)
 		schedule_timeout_uninterruptible(1);
 	} while (m == EMPTY_QUEUE);
 
-	status = kzalloc(4, GFP_KERNEL|ADDR32);
+	status = dma_alloc_coherent(&pHba->pDev->dev, 4, &addr, GFP_KERNEL);
 	if(status == NULL) {
 		adpt_send_nop(pHba, m);
 		printk(KERN_ERR"IOP reset failed - no free memory.\n");
 		return -ENOMEM;
 	}
+	memset(status,0,4);
 
 	msg[0]=EIGHT_WORD_MSG_SIZE|SGL_OFFSET_0;
 	msg[1]=I2O_CMD_ADAPTER_RESET<<24|HOST_TID<<12|ADAPTER_TID;
@@ -1274,8 +1299,8 @@ static s32 adpt_i2o_reset_hba(adpt_hba* pHba)
 	msg[3]=0;
 	msg[4]=0;
 	msg[5]=0;
-	msg[6]=virt_to_bus(status);
-	msg[7]=0;     
+	msg[6]=dma_low(addr);
+	msg[7]=dma_high(addr);
 
 	memcpy_toio(pHba->msg_addr_virt+m, msg, sizeof(msg));
 	wmb();
@@ -1285,7 +1310,10 @@ static s32 adpt_i2o_reset_hba(adpt_hba* pHba)
 	while(*status == 0){
 		if(time_after(jiffies,timeout)){
 			printk(KERN_WARNING"%s: IOP Reset Timeout\n",pHba->name);
-			kfree(status);
+			/* We lose 4 bytes of "status" here, but we cannot
+			   free these because controller may awake and corrupt
+			   those bytes at any time */
+			/* dma_free_coherent(&pHba->pDev->dev, 4, buf, addr); */
 			return -ETIMEDOUT;
 		}
 		rmb();
@@ -1304,6 +1332,10 @@ static s32 adpt_i2o_reset_hba(adpt_hba* pHba)
 			}
 			if(time_after(jiffies,timeout)){
 				printk(KERN_ERR "%s:Timeout waiting for IOP Reset.\n",pHba->name);
+				/* We lose 4 bytes of "status" here, but we
+				   cannot free these because controller may
+				   awake and corrupt those bytes at any time */
+				/* dma_free_coherent(&pHba->pDev->dev, 4, buf, addr); */
 				return -ETIMEDOUT;
 			}
 			schedule_timeout_uninterruptible(1);
@@ -1320,7 +1352,7 @@ static s32 adpt_i2o_reset_hba(adpt_hba* pHba)
 		PDEBUG("%s: Reset completed.\n", pHba->name);
 	}
 
-	kfree(status);
+	dma_free_coherent(&pHba->pDev->dev, 4, status, addr);
 #ifdef UARTDELAY
 	// This delay is to allow someone attached to the card through the debug UART to 
 	// set up the dump levels that they want before the rest of the initialization sequence
@@ -1592,6 +1624,7 @@ static int adpt_i2o_passthru(adpt_hba* pHba, u32 __user *arg)
 	u32 i = 0;
 	u32 rcode = 0;
 	void *p = NULL;
+	dma_addr_t addr;
 	ulong flags = 0;
 
 	memset(&msg, 0, MAX_MESSAGE_SIZE*4);
@@ -1646,7 +1679,7 @@ static int adpt_i2o_passthru(adpt_hba* pHba, u32 __user *arg)
 			}
 			sg_size = sg[i].flag_count & 0xffffff;      
 			/* Allocate memory for the transfer */
-			p = kmalloc(sg_size, GFP_KERNEL|ADDR32);
+			p = dma_alloc_coherent(&pHba->pDev->dev, sg_size, &addr, GFP_KERNEL);
 			if(!p) {
 				printk(KERN_DEBUG"%s: Could not allocate SG buffer - size = %d buffer number %d of %d\n",
 						pHba->name,sg_size,i,sg_count);
@@ -1743,12 +1776,17 @@ static int adpt_i2o_passthru(adpt_hba* pHba, u32 __user *arg)
 
 
 cleanup:
-	if (rcode != -ETIME && rcode != -EINTR)
+	if (rcode != -ETIME && rcode != -EINTR) {
+		struct sg_simple_element *sg =
+				(struct sg_simple_element*) (msg +sg_offset);
 		kfree (reply);
-	while(sg_index) {
-		if(sg_list[--sg_index]) {
-			if (rcode != -ETIME && rcode != -EINTR)
-				kfree(sg_list[sg_index]);
+		while(sg_index) {
+			if(sg_list[--sg_index]) {
+				dma_free_coherent(&pHba->pDev->dev,
+					sg[sg_index].flag_count & 0xffffff,
+					sg_list[sg_index],
+					sg[sg_index].addr_bus);
+			}
 		}
 	}
 	return rcode;
@@ -1965,7 +2003,16 @@ static irqreturn_t adpt_isr(int irq, void *dev_id)
 				goto out;
 			}
 		}
-		reply = bus_to_virt(m);
+		if (pHba->reply_pool_pa <= m &&
+		    m < pHba->reply_pool_pa +
+			(pHba->reply_fifo_size * REPLY_FRAME_SIZE * 4)) {
+			reply = (u8 *)pHba->reply_pool +
+						(m - pHba->reply_pool_pa);
+		} else {
+			/* Ick, we should *never* be here */
+			printk(KERN_ERR "dpti: reply frame not from pool\n");
+			reply = (u8 *)bus_to_virt(m);
+		}
 
 		if (readl(reply) & MSG_FAIL) {
 			u32 old_m = readl(reply+28); 
@@ -2008,6 +2055,7 @@ static irqreturn_t adpt_isr(int irq, void *dev_id)
 		} else { // SCSI message
 			cmd = (struct scsi_cmnd*) readl(reply+12); 
 			if(cmd != NULL){
+				scsi_dma_unmap(cmd);
 				if(cmd->serial_number != 0) { // If not timedout
 					adpt_i2o_to_scsi(reply, cmd);
 				}
@@ -2156,7 +2204,7 @@ static s32 adpt_scsi_host_alloc(adpt_hba* pHba, struct scsi_host_template *sht)
 	host->max_lun = 256;
 	host->max_channel = pHba->top_scsi_channel + 1;
 	host->cmd_per_lun = 1;
-	host->unique_id = (uint) pHba;
+	host->unique_id = (u32)sys_tbl_pa + pHba->unit;
 	host->sg_tablesize = pHba->sg_tablesize;
 	host->can_queue = pHba->post_fifo_size;
 
@@ -2596,11 +2644,10 @@ static s32 adpt_send_nop(adpt_hba*pHba,u32 m)
 static s32 adpt_i2o_init_outbound_q(adpt_hba* pHba)
 {
 	u8 *status;
+	dma_addr_t addr;
 	u32 __iomem *msg = NULL;
 	int i;
 	ulong timeout = jiffies + TMOUT_INITOUTBOUND*HZ;
-	u32* ptr;
-	u32 outbound_frame;  // This had to be a 32 bit address
 	u32 m;
 
 	do {
@@ -2619,13 +2666,14 @@ static s32 adpt_i2o_init_outbound_q(adpt_hba* pHba)
 
 	msg=(u32 __iomem *)(pHba->msg_addr_virt+m);
 
-	status = kzalloc(4, GFP_KERNEL|ADDR32);
+	status = dma_alloc_coherent(&pHba->pDev->dev, 4, &addr, GFP_KERNEL);
 	if (!status) {
 		adpt_send_nop(pHba, m);
 		printk(KERN_WARNING"%s: IOP reset failed - no free memory.\n",
 			pHba->name);
 		return -ENOMEM;
 	}
+	memset(status, 0, 4);
 
 	writel(EIGHT_WORD_MSG_SIZE| SGL_OFFSET_6, &msg[0]);
 	writel(I2O_CMD_OUTBOUND_INIT<<24 | HOST_TID<<12 | ADAPTER_TID, &msg[1]);
@@ -2634,7 +2682,7 @@ static s32 adpt_i2o_init_outbound_q(adpt_hba* pHba)
 	writel(4096, &msg[4]);		/* Host page frame size */
 	writel((REPLY_FRAME_SIZE)<<16|0x80, &msg[5]);	/* Outbound msg frame size and Initcode */
 	writel(0xD0000004, &msg[6]);		/* Simple SG LE, EOB */
-	writel(virt_to_bus(status), &msg[7]);
+	writel((u32)addr, &msg[7]);
 
 	writel(m, pHba->post_port);
 	wmb();
@@ -2649,6 +2697,10 @@ static s32 adpt_i2o_init_outbound_q(adpt_hba* pHba)
 		rmb();
 		if(time_after(jiffies,timeout)){
 			printk(KERN_WARNING"%s: Timeout Initializing\n",pHba->name);
+			/* We lose 4 bytes of "status" here, but we
+			   cannot free these because controller may
+			   awake and corrupt those bytes at any time */
+			/* dma_free_coherent(&pHba->pDev->dev, 4, status, addr); */
 			return -ETIMEDOUT;
 		}
 		schedule_timeout_uninterruptible(1);
@@ -2657,25 +2709,30 @@ static s32 adpt_i2o_init_outbound_q(adpt_hba* pHba)
 	// If the command was successful, fill the fifo with our reply
 	// message packets
 	if(*status != 0x04 /*I2O_EXEC_OUTBOUND_INIT_COMPLETE*/) {
-		kfree(status);
+		dma_free_coherent(&pHba->pDev->dev, 4, status, addr);
 		return -2;
 	}
-	kfree(status);
+	dma_free_coherent(&pHba->pDev->dev, 4, status, addr);
 
-	kfree(pHba->reply_pool);
+	if(pHba->reply_pool != NULL) {
+		dma_free_coherent(&pHba->pDev->dev,
+			pHba->reply_fifo_size * REPLY_FRAME_SIZE * 4,
+			pHba->reply_pool, pHba->reply_pool_pa);
+	}
 
-	pHba->reply_pool = kzalloc(pHba->reply_fifo_size * REPLY_FRAME_SIZE * 4, GFP_KERNEL|ADDR32);
+	pHba->reply_pool = dma_alloc_coherent(&pHba->pDev->dev,
+				pHba->reply_fifo_size * REPLY_FRAME_SIZE * 4,
+				&pHba->reply_pool_pa, GFP_KERNEL);
 	if (!pHba->reply_pool) {
 		printk(KERN_ERR "%s: Could not allocate reply pool\n", pHba->name);
 		return -ENOMEM;
 	}
+	memset(pHba->reply_pool, 0 , pHba->reply_fifo_size * REPLY_FRAME_SIZE * 4);
 
-	ptr = pHba->reply_pool;
 	for(i = 0; i < pHba->reply_fifo_size; i++) {
-		outbound_frame = (u32)virt_to_bus(ptr);
-		writel(outbound_frame, pHba->reply_port);
+		writel(pHba->reply_pool_pa + (i * REPLY_FRAME_SIZE * 4),
+			pHba->reply_port);
 		wmb();
-		ptr +=  REPLY_FRAME_SIZE;
 	}
 	adpt_i2o_status_get(pHba);
 	return 0;
@@ -2699,11 +2756,11 @@ static s32 adpt_i2o_status_get(adpt_hba* pHba)
 	u32 m;
 	u32 __iomem *msg;
 	u8 *status_block=NULL;
-	ulong status_block_bus;
 
 	if(pHba->status_block == NULL) {
-		pHba->status_block = (i2o_status_block*)
-			kmalloc(sizeof(i2o_status_block),GFP_KERNEL|ADDR32);
+		pHba->status_block = dma_alloc_coherent(&pHba->pDev->dev,
+					sizeof(i2o_status_block),
+					&pHba->status_block_pa, GFP_KERNEL);
 		if(pHba->status_block == NULL) {
 			printk(KERN_ERR
 			"dpti%d: Get Status Block failed; Out of memory. \n", 
@@ -2713,7 +2770,6 @@ static s32 adpt_i2o_status_get(adpt_hba* pHba)
 	}
 	memset(pHba->status_block, 0, sizeof(i2o_status_block));
 	status_block = (u8*)(pHba->status_block);
-	status_block_bus = virt_to_bus(pHba->status_block);
 	timeout = jiffies+TMOUT_GETSTATUS*HZ;
 	do {
 		rmb();
@@ -2738,8 +2794,8 @@ static s32 adpt_i2o_status_get(adpt_hba* pHba)
 	writel(0, &msg[3]);
 	writel(0, &msg[4]);
 	writel(0, &msg[5]);
-	writel(((u32)status_block_bus)&0xffffffff, &msg[6]);
-	writel(0, &msg[7]);
+	writel( dma_low(pHba->status_block_pa), &msg[6]);
+	writel( dma_high(pHba->status_block_pa), &msg[7]);
 	writel(sizeof(i2o_status_block), &msg[8]); // 88 bytes
 
 	//post message
@@ -2819,7 +2875,9 @@ static int adpt_i2o_lct_get(adpt_hba* pHba)
 	}
 	do {
 		if (pHba->lct == NULL) {
-			pHba->lct = kmalloc(pHba->lct_size, GFP_KERNEL|ADDR32);
+			pHba->lct = dma_alloc_coherent(&pHba->pDev->dev,
+					pHba->lct_size, &pHba->lct_pa,
+					GFP_KERNEL);
 			if(pHba->lct == NULL) {
 				printk(KERN_CRIT "%s: Lct Get failed. Out of memory.\n",
 					pHba->name);
@@ -2835,7 +2893,7 @@ static int adpt_i2o_lct_get(adpt_hba* pHba)
 		msg[4] = 0xFFFFFFFF;	/* All devices */
 		msg[5] = 0x00000000;	/* Report now */
 		msg[6] = 0xD0000000|pHba->lct_size;
-		msg[7] = virt_to_bus(pHba->lct);
+		msg[7] = (u32)pHba->lct_pa;
 
 		if ((ret=adpt_i2o_post_wait(pHba, msg, sizeof(msg), 360))) {
 			printk(KERN_ERR "%s: LCT Get failed (status=%#10x.\n", 
@@ -2846,7 +2904,8 @@ static int adpt_i2o_lct_get(adpt_hba* pHba)
 
 		if ((pHba->lct->table_size << 2) > pHba->lct_size) {
 			pHba->lct_size = pHba->lct->table_size << 2;
-			kfree(pHba->lct);
+			dma_free_coherent(&pHba->pDev->dev, pHba->lct_size,
+					pHba->lct, pHba->lct_pa);
 			pHba->lct = NULL;
 		}
 	} while (pHba->lct == NULL);
@@ -2871,25 +2930,30 @@ static int adpt_i2o_lct_get(adpt_hba* pHba)
 
 static int adpt_i2o_build_sys_table(void)
 {
-	adpt_hba* pHba = NULL;
+	adpt_hba* pHba = hba_chain;
 	int count = 0;
 
+	if (sys_tbl)
+		dma_free_coherent(&pHba->pDev->dev, sys_tbl_len,
+					sys_tbl, sys_tbl_pa);
+
 	sys_tbl_len = sizeof(struct i2o_sys_tbl) +	// Header + IOPs
 				(hba_count) * sizeof(struct i2o_sys_tbl_entry);
 
-	kfree(sys_tbl);
-
-	sys_tbl = kzalloc(sys_tbl_len, GFP_KERNEL|ADDR32);
+	sys_tbl = dma_alloc_coherent(&pHba->pDev->dev,
+				sys_tbl_len, &sys_tbl_pa, GFP_KERNEL);
 	if (!sys_tbl) {
 		printk(KERN_WARNING "SysTab Set failed. Out of memory.\n");	
 		return -ENOMEM;
 	}
+	memset(sys_tbl, 0, sys_tbl_len);
 
 	sys_tbl->num_entries = hba_count;
 	sys_tbl->version = I2OVERSION;
 	sys_tbl->change_ind = sys_tbl_ind++;
 
 	for(pHba = hba_chain; pHba; pHba = pHba->next) {
+		u64 addr;
 		// Get updated Status Block so we have the latest information
 		if (adpt_i2o_status_get(pHba)) {
 			sys_tbl->num_entries--;
@@ -2905,8 +2969,9 @@ static int adpt_i2o_build_sys_table(void)
 		sys_tbl->iops[count].frame_size = pHba->status_block->inbound_frame_size;
 		sys_tbl->iops[count].last_changed = sys_tbl_ind - 1; // ??
 		sys_tbl->iops[count].iop_capabilities = pHba->status_block->iop_capabilities;
-		sys_tbl->iops[count].inbound_low = (u32)virt_to_bus(pHba->post_port);
-		sys_tbl->iops[count].inbound_high = (u32)((u64)virt_to_bus(pHba->post_port)>>32);
+		addr = pHba->base_addr_phys + 0x40;
+		sys_tbl->iops[count].inbound_low = dma_low(addr);
+		sys_tbl->iops[count].inbound_high = dma_high(addr);
 
 		count++;
 	}
@@ -3042,7 +3107,8 @@ static s32 adpt_i2o_hrt_get(adpt_hba* pHba)
 
 	do {
 		if (pHba->hrt == NULL) {
-			pHba->hrt=kmalloc(size, GFP_KERNEL|ADDR32);
+			pHba->hrt = dma_alloc_coherent(&pHba->pDev->dev,
+					size, &pHba->hrt_pa, GFP_KERNEL);
 			if (pHba->hrt == NULL) {
 				printk(KERN_CRIT "%s: Hrt Get failed; Out of memory.\n", pHba->name);
 				return -ENOMEM;
@@ -3054,7 +3120,7 @@ static s32 adpt_i2o_hrt_get(adpt_hba* pHba)
 		msg[2]= 0;
 		msg[3]= 0;
 		msg[4]= (0xD0000000 | size);    /* Simple transaction */
-		msg[5]= virt_to_bus(pHba->hrt);   /* Dump it here */
+		msg[5]= (u32)pHba->hrt_pa;	/* Dump it here */
 
 		if ((ret = adpt_i2o_post_wait(pHba, msg, sizeof(msg),20))) {
 			printk(KERN_ERR "%s: Unable to get HRT (status=%#10x)\n", pHba->name, ret);
@@ -3062,8 +3128,10 @@ static s32 adpt_i2o_hrt_get(adpt_hba* pHba)
 		}
 
 		if (pHba->hrt->num_entries * pHba->hrt->entry_len << 2 > size) {
-			size = pHba->hrt->num_entries * pHba->hrt->entry_len << 2;
-			kfree(pHba->hrt);
+			int newsize = pHba->hrt->num_entries * pHba->hrt->entry_len << 2;
+			dma_free_coherent(&pHba->pDev->dev, size,
+				pHba->hrt, pHba->hrt_pa);
+			size = newsize;
 			pHba->hrt = NULL;
 		}
 	} while(pHba->hrt == NULL);
@@ -3077,33 +3145,54 @@ static int adpt_i2o_query_scalar(adpt_hba* pHba, int tid,
 			int group, int field, void *buf, int buflen)
 {
 	u16 opblk[] = { 1, 0, I2O_PARAMS_FIELD_GET, group, 1, field };
-	u8 *resblk;
+	u8 *opblk_va;
+	dma_addr_t opblk_pa;
+	u8 *resblk_va;
+	dma_addr_t resblk_pa;
 
 	int size;
 
 	/* 8 bytes for header */
-	resblk = kmalloc(sizeof(u8) * (8+buflen), GFP_KERNEL|ADDR32);
-	if (resblk == NULL) {
+	resblk_va = dma_alloc_coherent(&pHba->pDev->dev,
+			sizeof(u8) * (8 + buflen), &resblk_pa, GFP_KERNEL);
+	if (resblk_va == NULL) {
 		printk(KERN_CRIT "%s: query scalar failed; Out of memory.\n", pHba->name);
 		return -ENOMEM;
 	}
 
+	opblk_va = dma_alloc_coherent(&pHba->pDev->dev,
+			sizeof(opblk), &opblk_pa, GFP_KERNEL);
+	if (opblk_va == NULL) {
+		dma_free_coherent(&pHba->pDev->dev, sizeof(u8) * (8+buflen),
+			resblk_va, resblk_pa);
+		printk(KERN_CRIT "%s: query operatio failed; Out of memory.\n",
+			pHba->name);
+		return -ENOMEM;
+	}
 	if (field == -1)  		/* whole group */
 			opblk[4] = -1;
 
+	memcpy(opblk_va, opblk, sizeof(opblk));
 	size = adpt_i2o_issue_params(I2O_CMD_UTIL_PARAMS_GET, pHba, tid, 
-		opblk, sizeof(opblk), resblk, sizeof(u8)*(8+buflen));
+		opblk_va, opblk_pa, sizeof(opblk),
+		resblk_va, resblk_pa, sizeof(u8)*(8+buflen));
+	dma_free_coherent(&pHba->pDev->dev, sizeof(opblk), opblk_va, opblk_pa);
 	if (size == -ETIME) {
+		dma_free_coherent(&pHba->pDev->dev, sizeof(u8) * (8+buflen),
+							resblk_va, resblk_pa);
 		printk(KERN_WARNING "%s: issue params failed; Timed out.\n", pHba->name);
 		return -ETIME;
 	} else if (size == -EINTR) {
+		dma_free_coherent(&pHba->pDev->dev, sizeof(u8) * (8+buflen),
+							resblk_va, resblk_pa);
 		printk(KERN_WARNING "%s: issue params failed; Interrupted.\n", pHba->name);
 		return -EINTR;
 	}
 			
-	memcpy(buf, resblk+8, buflen);  /* cut off header */
+	memcpy(buf, resblk_va+8, buflen);  /* cut off header */
 
-	kfree(resblk);
+	dma_free_coherent(&pHba->pDev->dev, sizeof(u8) * (8+buflen),
+						resblk_va, resblk_pa);
 	if (size < 0)
 		return size;	
 
@@ -3120,10 +3209,11 @@ static int adpt_i2o_query_scalar(adpt_hba* pHba, int tid,
  *	ResultCount, ErrorInfoSize, BlockStatus and BlockSize.
  */
 static int adpt_i2o_issue_params(int cmd, adpt_hba* pHba, int tid, 
-		  void *opblk, int oplen, void *resblk, int reslen)
+		  void *opblk_va,  dma_addr_t opblk_pa, int oplen,
+		void *resblk_va, dma_addr_t resblk_pa, int reslen)
 {
 	u32 msg[9]; 
-	u32 *res = (u32 *)resblk;
+	u32 *res = (u32 *)resblk_va;
 	int wait_status;
 
 	msg[0] = NINE_WORD_MSG_SIZE | SGL_OFFSET_5;
@@ -3132,12 +3222,12 @@ static int adpt_i2o_issue_params(int cmd, adpt_hba* pHba, int tid,
 	msg[3] = 0;
 	msg[4] = 0;
 	msg[5] = 0x54000000 | oplen;	/* OperationBlock */
-	msg[6] = virt_to_bus(opblk);
+	msg[6] = (u32)opblk_pa;
 	msg[7] = 0xD0000000 | reslen;	/* ResultBlock */
-	msg[8] = virt_to_bus(resblk);
+	msg[8] = (u32)resblk_pa;
 
 	if ((wait_status = adpt_i2o_post_wait(pHba, msg, sizeof(msg), 20))) {
-		printk("adpt_i2o_issue_params: post_wait failed (%p)\n", resblk);
+		printk("adpt_i2o_issue_params: post_wait failed (%p)\n", resblk_va);
    		return wait_status; 	/* -DetailedStatus */
 	}
 
@@ -3240,7 +3330,7 @@ static int adpt_i2o_systab_send(adpt_hba* pHba)
 	 * Private i/o space declaration  
 	 */
 	msg[6] = 0x54000000 | sys_tbl_len;
-	msg[7] = virt_to_phys(sys_tbl);
+	msg[7] = (u32)sys_tbl_pa;
 	msg[8] = 0x54000000 | 0;
 	msg[9] = 0;
 	msg[10] = 0xD4000000 | 0;

commit c864cb145dc2218cfad9fe53d323b54b48dbab6c
Author: Miquel van Smoorenburg <miquels@cistron.nl>
Date:   Fri May 2 01:05:33 2008 +0200

    [SCSI] dpt_i2o: use standard __init / __exit code
    
    Update dpt_i2o.c to use the standard __init / __exit
    code instead of the legacy '#include "scsi_module.c"' code.
    
    This is needed in preparation of 64-bit support. scsi_module.c
    calls scsi_add_host() with the device pointer set to NULL, and that
    crashes code like arch/x64/kernel/pci-gart_64.c::need_iommu().
    
    The reboot_notifier code is deleted because it wasn't compiled
    in ever anyway, and it would be useless to duplicate it in
    the new code.
    
    Signed-off-by: Miquel van Smoorenburg <miquels@cistron.nl>
    Acked-by: Mark Salyzyn <Mark_Salyzyn@adaptec.com>
    Signed-off-by: James Bottomley <James.Bottomley@HansenPartnership.com>

diff --git a/drivers/scsi/dpt_i2o.c b/drivers/scsi/dpt_i2o.c
index c9dd8392aab2..30c741a12a62 100644
--- a/drivers/scsi/dpt_i2o.c
+++ b/drivers/scsi/dpt_i2o.c
@@ -121,15 +121,6 @@ static const struct file_operations adpt_fops = {
 	.release	= adpt_close
 };
 
-#ifdef REBOOT_NOTIFIER
-static struct notifier_block adpt_reboot_notifier =
-{
-	 adpt_reboot_event,
-	 NULL,
-	 0
-};
-#endif
-
 /* Structures and definitions for synchronous message posting.
  * See adpt_i2o_post_wait() for description
  * */
@@ -178,8 +169,6 @@ static int adpt_detect(struct scsi_host_template* sht)
 	struct pci_dev *pDev = NULL;
 	adpt_hba* pHba;
 
-	adpt_init();
-
 	PINFO("Detecting Adaptec I2O RAID controllers...\n");
 
         /* search for all Adatpec I2O RAID cards */
@@ -248,7 +237,7 @@ static int adpt_detect(struct scsi_host_template* sht)
 	}
 
 	for (pHba = hba_chain; pHba; pHba = pHba->next) {
-		if( adpt_scsi_register(pHba,sht) < 0){
+		if (adpt_scsi_host_alloc(pHba, sht) < 0){
 			adpt_i2o_delete_hba(pHba);
 			continue;
 		}
@@ -861,27 +850,6 @@ static void adpt_i2o_sys_shutdown(void)
 	 printk(KERN_INFO "Adaptec I2O controllers down.\n");
 }
 
-/*
- * reboot/shutdown notification.
- *
- * - Quiesce each IOP in the system
- *
- */
-
-#ifdef REBOOT_NOTIFIER
-static int adpt_reboot_event(struct notifier_block *n, ulong code, void *p)
-{
-
-	 if(code != SYS_RESTART && code != SYS_HALT && code != SYS_POWER_OFF)
-		  return NOTIFY_DONE;
-
-	 adpt_i2o_sys_shutdown();
-
-	 return NOTIFY_DONE;
-}
-#endif
-
-
 static int adpt_install_hba(struct scsi_host_template* sht, struct pci_dev* pDev)
 {
 
@@ -1080,18 +1048,6 @@ static void adpt_i2o_delete_hba(adpt_hba* pHba)
 	}
 }
 
-
-static int adpt_init(void)
-{
-	printk("Loading Adaptec I2O RAID: Version " DPT_I2O_VERSION "\n");
-#ifdef REBOOT_NOTIFIER
-	register_reboot_notifier(&adpt_reboot_notifier);
-#endif
-
-	return 0;
-}
-
-
 static struct adpt_device* adpt_find_device(adpt_hba* pHba, u32 chan, u32 id, u32 lun)
 {
 	struct adpt_device* d;
@@ -2177,13 +2133,13 @@ static s32 adpt_scsi_to_i2o(adpt_hba* pHba, struct scsi_cmnd* cmd, struct adpt_d
 }
 
 
-static s32 adpt_scsi_register(adpt_hba* pHba,struct scsi_host_template * sht)
+static s32 adpt_scsi_host_alloc(adpt_hba* pHba, struct scsi_host_template *sht)
 {
-	struct Scsi_Host *host = NULL;
+	struct Scsi_Host *host;
 
-	host = scsi_register(sht, sizeof(adpt_hba*));
+	host = scsi_host_alloc(sht, sizeof(adpt_hba*));
 	if (host == NULL) {
-		printk ("%s: scsi_register returned NULL\n",pHba->name);
+		printk("%s: scsi_host_alloc returned NULL\n", pHba->name);
 		return -1;
 	}
 	host->hostdata[0] = (unsigned long)pHba;
@@ -3323,11 +3279,10 @@ static static void adpt_delay(int millisec)
 #endif
 
 static struct scsi_host_template driver_template = {
+	.module			= THIS_MODULE,
 	.name			= "dpt_i2o",
 	.proc_name		= "dpt_i2o",
 	.proc_info		= adpt_proc_info,
-	.detect			= adpt_detect,
-	.release		= adpt_release,
 	.info			= adpt_info,
 	.queuecommand		= adpt_queue,
 	.eh_abort_handler	= adpt_abort,
@@ -3341,5 +3296,48 @@ static struct scsi_host_template driver_template = {
 	.cmd_per_lun		= 1,
 	.use_clustering		= ENABLE_CLUSTERING,
 };
-#include "scsi_module.c"
+
+static int __init adpt_init(void)
+{
+	int		error;
+	adpt_hba	*pHba, *next;
+
+	printk("Loading Adaptec I2O RAID: Version " DPT_I2O_VERSION "\n");
+
+	error = adpt_detect(&driver_template);
+	if (error < 0)
+		return error;
+	if (hba_chain == NULL)
+		return -ENODEV;
+
+	for (pHba = hba_chain; pHba; pHba = pHba->next) {
+		error = scsi_add_host(pHba->host, &pHba->pDev->dev);
+		if (error)
+			goto fail;
+		scsi_scan_host(pHba->host);
+	}
+	return 0;
+fail:
+	for (pHba = hba_chain; pHba; pHba = next) {
+		next = pHba->next;
+		scsi_remove_host(pHba->host);
+	}
+	return error;
+}
+
+static void __exit adpt_exit(void)
+{
+	adpt_hba	*pHba, *next;
+
+	for (pHba = hba_chain; pHba; pHba = pHba->next)
+		scsi_remove_host(pHba->host);
+	for (pHba = hba_chain; pHba; pHba = next) {
+		next = pHba->next;
+		adpt_release(pHba->host);
+	}
+}
+
+module_init(adpt_init);
+module_exit(adpt_exit);
+
 MODULE_LICENSE("GPL");

commit 172c122df5186e7cbd413d61757ff90267331002
Author: Harvey Harrison <harvey.harrison@gmail.com>
Date:   Mon Apr 28 16:50:03 2008 -0700

    scsi: fix integer as NULL pointer warnings
    
    drivers/scsi/aic7xxx/aic7770_osm.c:53:58: warning: Using plain integer as NULL pointer
    drivers/scsi/aic7xxx/aic7xxx_osm_pci.c:355:47: warning: Using plain integer as NULL pointer
    drivers/scsi/aic7xxx/aic7xxx_osm_pci.c:372:55: warning: Using plain integer as NULL pointer
    drivers/scsi/aha152x.c:997:28: warning: Using plain integer as NULL pointer
    drivers/scsi/aha152x.c:1003:28: warning: Using plain integer as NULL pointer
    drivers/scsi/aha152x.c:1165:46: warning: Using plain integer as NULL pointer
    drivers/scsi/fdomain.c:1446:40: warning: Using plain integer as NULL pointer
    drivers/scsi/sym53c8xx_2/sym_hipd.c:1650:51: warning: Using plain integer as NULL pointer
    drivers/scsi/sym53c8xx_2/sym_hipd.c:3171:42: warning: Using plain integer as NULL pointer
    drivers/scsi/sym53c8xx_2/sym_hipd.c:5732:52: warning: Using plain integer as NULL pointer
    drivers/scsi/ncr53c8xx.c:8189:31: warning: Using plain integer as NULL pointer
    drivers/scsi/ncr53c8xx.c:8225:34: warning: Using plain integer as NULL pointer
    drivers/scsi/dpt_i2o.c:156:32: warning: Using plain integer as NULL pointer
    drivers/scsi/ultrastor.c:954:42: warning: Using plain integer as NULL pointer
    drivers/scsi/ultrastor.c:1104:18: warning: Using plain integer as NULL pointer
    
    Signed-off-by: Harvey Harrison <harvey.harrison@gmail.com>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/scsi/dpt_i2o.c b/drivers/scsi/dpt_i2o.c
index c9dd8392aab2..ac92ac143b46 100644
--- a/drivers/scsi/dpt_i2o.c
+++ b/drivers/scsi/dpt_i2o.c
@@ -153,7 +153,7 @@ static DEFINE_SPINLOCK(adpt_post_wait_lock);
 
 static u8 adpt_read_blink_led(adpt_hba* host)
 {
-	if(host->FwDebugBLEDflag_P != 0) {
+	if (host->FwDebugBLEDflag_P) {
 		if( readb(host->FwDebugBLEDflag_P) == 0xbc ){
 			return readb(host->FwDebugBLEDvalue_P);
 		}

commit d3f46f39b7092594b498abc12f0c73b0b9913bde
Author: James Bottomley <James.Bottomley@HansenPartnership.com>
Date:   Tue Jan 15 11:11:46 2008 -0600

    [SCSI] remove use_sg_chaining
    
    With the sg table code, every SCSI driver is now either chain capable
    or broken (or has sg_tablesize set so chaining is never activated), so
    there's no need to have a check in the host template.
    
    Also tidy up the code by moving the scatterlist size defines into the
    SCSI includes and permit the last entry of the scatterlist pools not
    to be a power of two.
    Signed-off-by: James Bottomley <James.Bottomley@HansenPartnership.com>

diff --git a/drivers/scsi/dpt_i2o.c b/drivers/scsi/dpt_i2o.c
index 19cce125124c..c9dd8392aab2 100644
--- a/drivers/scsi/dpt_i2o.c
+++ b/drivers/scsi/dpt_i2o.c
@@ -3340,7 +3340,6 @@ static struct scsi_host_template driver_template = {
 	.this_id		= 7,
 	.cmd_per_lun		= 1,
 	.use_clustering		= ENABLE_CLUSTERING,
-	.use_sg_chaining	= ENABLE_SG_CHAINING,
 };
 #include "scsi_module.c"
 MODULE_LICENSE("GPL");

commit d814c5173c671cf2c88d4e07db01b13312467ecd
Author: Salyzyn, Mark <Mark_Salyzyn@adaptec.com>
Date:   Mon Jan 14 11:04:40 2008 -0800

    [SCSI] dpt_i2o: use constant instead of bare value
    
    0x02 becomes SAM_STAT_CHECK_CONDITION
    
    Signed-off-by: Mark Salyzyn <aacraid@adaptec.com>
    Signed-off-by: James Bottomley <James.Bottomley@HansenPartnership.com>

diff --git a/drivers/scsi/dpt_i2o.c b/drivers/scsi/dpt_i2o.c
index 577b34c93a07..19cce125124c 100644
--- a/drivers/scsi/dpt_i2o.c
+++ b/drivers/scsi/dpt_i2o.c
@@ -2296,7 +2296,7 @@ static s32 adpt_i2o_to_scsi(void __iomem *reply, struct scsi_cmnd* cmd)
 
 		// copy over the request sense data if it was a check
 		// condition status
-		if (dev_status == 0x02 /*CHECK_CONDITION*/) {
+		if (dev_status == SAM_STAT_CHECK_CONDITION) {
 			u32 len = min(SCSI_SENSE_BUFFERSIZE, 40);
 			// Copy over the sense data
 			memcpy_fromio(cmd->sense_buffer, (reply+28) , len);

commit b80ca4f7ee36c26d300c5a8f429e73372d153379
Author: FUJITA Tomonori <tomof@acm.org>
Date:   Sun Jan 13 15:46:13 2008 +0900

    [SCSI] replace sizeof sense_buffer with SCSI_SENSE_BUFFERSIZE
    
    This replaces sizeof sense_buffer with SCSI_SENSE_BUFFERSIZE in
    several LLDs. It's a preparation for the future changes to remove
    sense_buffer array in scsi_cmnd structure.
    
    Signed-off-by: FUJITA Tomonori <fujita.tomonori@lab.ntt.co.jp>
    Signed-off-by: James Bottomley <James.Bottomley@HansenPartnership.com>

diff --git a/drivers/scsi/dpt_i2o.c b/drivers/scsi/dpt_i2o.c
index b31d1c95c9fb..577b34c93a07 100644
--- a/drivers/scsi/dpt_i2o.c
+++ b/drivers/scsi/dpt_i2o.c
@@ -2296,9 +2296,8 @@ static s32 adpt_i2o_to_scsi(void __iomem *reply, struct scsi_cmnd* cmd)
 
 		// copy over the request sense data if it was a check
 		// condition status
-		if(dev_status == 0x02 /*CHECK_CONDITION*/) {
-			u32 len = sizeof(cmd->sense_buffer);
-			len = (len > 40) ?  40 : len;
+		if (dev_status == 0x02 /*CHECK_CONDITION*/) {
+			u32 len = min(SCSI_SENSE_BUFFERSIZE, 40);
 			// Copy over the sense data
 			memcpy_fromio(cmd->sense_buffer, (reply+28) , len);
 			if(cmd->sense_buffer[0] == 0x70 /* class 7 */ && 

commit c80ddf00cde4c21018dbd0ea2872736c90c7dda2
Author: James Bottomley <James.Bottomley@HansenPartnership.com>
Date:   Wed Dec 12 15:06:21 2007 -0500

    [SCSI] dpt_i2o: driver is only 32 bit so don't set 64 bit DMA mask
    
    This fixes a potential corruption bug where the truncation would cause
    reading or writing to the wrong memory area on machines with >4GB of
    main memory.
    
    Cc: Stable Kernel Tree <stable@kernel.org>
    Signed-off-by: James Bottomley <James.Bottomley@HansenPartnership.com>

diff --git a/drivers/scsi/dpt_i2o.c b/drivers/scsi/dpt_i2o.c
index 70f48a1a6d58..b31d1c95c9fb 100644
--- a/drivers/scsi/dpt_i2o.c
+++ b/drivers/scsi/dpt_i2o.c
@@ -906,8 +906,7 @@ static int adpt_install_hba(struct scsi_host_template* sht, struct pci_dev* pDev
 	}
 
 	pci_set_master(pDev);
-	if (pci_set_dma_mask(pDev, DMA_64BIT_MASK) &&
-	    pci_set_dma_mask(pDev, DMA_32BIT_MASK))
+	if (pci_set_dma_mask(pDev, DMA_32BIT_MASK))
 		return -EINVAL;
 
 	base_addr0_phys = pci_resource_start(pDev,0);

commit 24601bbcacb3356657747f2e64317923feb7a1a2
Author: Andrew Morton <akpm@linux-foundation.org>
Date:   Mon Dec 10 15:49:20 2007 -0800

    revert "dpt_i2o: convert to SCSI hotplug model"
    
    revert
    
        commit 55d9fcf57ba5ec427544fca7abc335cf3da78160
        Author: Matthew Wilcox <matthew@wil.cx>
        Date:   Mon Jul 30 15:19:18 2007 -0600
    
            [SCSI] dpt_i2o: convert to SCSI hotplug model
    
             - Delete refereces to HOSTS_C
             - Switch to module_init/module_exit instead of detect/release
             - Don't pass around the host template and rename it to adpt_template
             - Switch from scsi_register/scsi_unregister to scsi_host_alloc,
               scsi_add_host, scsi_scan_host and scsi_host_put.
    
    Because it caused (for unknown reasons) Andres' all-data-reads-as-zeroes
    problem, reported at
    http://groups.google.com/group/fa.linux.kernel/msg/083a9acff0330234
    
    Cc: Matthew Wilcox <matthew@wil.cx>
    Cc: "Salyzyn, Mark" <mark_salyzyn@adaptec.com>
    Cc: James Bottomley <James.Bottomley@SteelEye.com>
    Acked-by: FUJITA Tomonori <fujita.tomonori@lab.ntt.co.jp>
    Cc: Anders Henke <anders.henke@1und1.de>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
    Cc: <stable@kernel.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/scsi/dpt_i2o.c b/drivers/scsi/dpt_i2o.c
index 8258506ba7d7..70f48a1a6d58 100644
--- a/drivers/scsi/dpt_i2o.c
+++ b/drivers/scsi/dpt_i2o.c
@@ -173,20 +173,20 @@ static struct pci_device_id dptids[] = {
 };
 MODULE_DEVICE_TABLE(pci,dptids);
 
-static void adpt_exit(void);
-
-static int adpt_detect(void)
+static int adpt_detect(struct scsi_host_template* sht)
 {
 	struct pci_dev *pDev = NULL;
 	adpt_hba* pHba;
 
+	adpt_init();
+
 	PINFO("Detecting Adaptec I2O RAID controllers...\n");
 
         /* search for all Adatpec I2O RAID cards */
 	while ((pDev = pci_get_device( PCI_DPT_VENDOR_ID, PCI_ANY_ID, pDev))) {
 		if(pDev->device == PCI_DPT_DEVICE_ID ||
 		   pDev->device == PCI_DPT_RAPTOR_DEVICE_ID){
-			if(adpt_install_hba(pDev) ){
+			if(adpt_install_hba(sht, pDev) ){
 				PERROR("Could not Init an I2O RAID device\n");
 				PERROR("Will not try to detect others.\n");
 				return hba_count-1;
@@ -248,33 +248,34 @@ static int adpt_detect(void)
 	}
 
 	for (pHba = hba_chain; pHba; pHba = pHba->next) {
-		if (adpt_scsi_register(pHba) < 0) {
+		if( adpt_scsi_register(pHba,sht) < 0){
 			adpt_i2o_delete_hba(pHba);
 			continue;
 		}
 		pHba->initialized = TRUE;
 		pHba->state &= ~DPTI_STATE_RESET;
-		scsi_scan_host(pHba->host);
 	}
 
 	// Register our control device node
 	// nodes will need to be created in /dev to access this
 	// the nodes can not be created from within the driver
 	if (hba_count && register_chrdev(DPTI_I2O_MAJOR, DPT_DRIVER, &adpt_fops)) {
-		adpt_exit();
+		adpt_i2o_sys_shutdown();
 		return 0;
 	}
 	return hba_count;
 }
 
 
-static int adpt_release(adpt_hba *pHba)
+/*
+ * scsi_unregister will be called AFTER we return.
+ */
+static int adpt_release(struct Scsi_Host *host)
 {
-	struct Scsi_Host *shost = pHba->host;
-	scsi_remove_host(shost);
+	adpt_hba* pHba = (adpt_hba*) host->hostdata[0];
 //	adpt_i2o_quiesce_hba(pHba);
 	adpt_i2o_delete_hba(pHba);
-	scsi_host_put(shost);
+	scsi_unregister(host);
 	return 0;
 }
 
@@ -881,7 +882,7 @@ static int adpt_reboot_event(struct notifier_block *n, ulong code, void *p)
 #endif
 
 
-static int adpt_install_hba(struct pci_dev* pDev)
+static int adpt_install_hba(struct scsi_host_template* sht, struct pci_dev* pDev)
 {
 
 	adpt_hba* pHba = NULL;
@@ -1028,6 +1029,8 @@ static void adpt_i2o_delete_hba(adpt_hba* pHba)
 
 
 	mutex_lock(&adpt_configuration_lock);
+	// scsi_unregister calls our adpt_release which
+	// does a quiese
 	if(pHba->host){
 		free_irq(pHba->host->irq, pHba);
 	}
@@ -1079,6 +1082,17 @@ static void adpt_i2o_delete_hba(adpt_hba* pHba)
 }
 
 
+static int adpt_init(void)
+{
+	printk("Loading Adaptec I2O RAID: Version " DPT_I2O_VERSION "\n");
+#ifdef REBOOT_NOTIFIER
+	register_reboot_notifier(&adpt_reboot_notifier);
+#endif
+
+	return 0;
+}
+
+
 static struct adpt_device* adpt_find_device(adpt_hba* pHba, u32 chan, u32 id, u32 lun)
 {
 	struct adpt_device* d;
@@ -2164,6 +2178,37 @@ static s32 adpt_scsi_to_i2o(adpt_hba* pHba, struct scsi_cmnd* cmd, struct adpt_d
 }
 
 
+static s32 adpt_scsi_register(adpt_hba* pHba,struct scsi_host_template * sht)
+{
+	struct Scsi_Host *host = NULL;
+
+	host = scsi_register(sht, sizeof(adpt_hba*));
+	if (host == NULL) {
+		printk ("%s: scsi_register returned NULL\n",pHba->name);
+		return -1;
+	}
+	host->hostdata[0] = (unsigned long)pHba;
+	pHba->host = host;
+
+	host->irq = pHba->pDev->irq;
+	/* no IO ports, so don't have to set host->io_port and
+	 * host->n_io_port
+	 */
+	host->io_port = 0;
+	host->n_io_port = 0;
+				/* see comments in scsi_host.h */
+	host->max_id = 16;
+	host->max_lun = 256;
+	host->max_channel = pHba->top_scsi_channel + 1;
+	host->cmd_per_lun = 1;
+	host->unique_id = (uint) pHba;
+	host->sg_tablesize = pHba->sg_tablesize;
+	host->can_queue = pHba->post_fifo_size;
+
+	return 0;
+}
+
+
 static s32 adpt_i2o_to_scsi(void __iomem *reply, struct scsi_cmnd* cmd)
 {
 	adpt_hba* pHba;
@@ -3279,10 +3324,12 @@ static static void adpt_delay(int millisec)
 
 #endif
 
-static struct scsi_host_template adpt_template = {
+static struct scsi_host_template driver_template = {
 	.name			= "dpt_i2o",
 	.proc_name		= "dpt_i2o",
 	.proc_info		= adpt_proc_info,
+	.detect			= adpt_detect,
+	.release		= adpt_release,
 	.info			= adpt_info,
 	.queuecommand		= adpt_queue,
 	.eh_abort_handler	= adpt_abort,
@@ -3297,62 +3344,5 @@ static struct scsi_host_template adpt_template = {
 	.use_clustering		= ENABLE_CLUSTERING,
 	.use_sg_chaining	= ENABLE_SG_CHAINING,
 };
-
-static s32 adpt_scsi_register(adpt_hba* pHba)
-{
-	struct Scsi_Host *host;
-
-	host = scsi_host_alloc(&adpt_template, sizeof(adpt_hba*));
-	if (host == NULL) {
-		printk ("%s: scsi_host_alloc returned NULL\n",pHba->name);
-		return -1;
-	}
-	host->hostdata[0] = (unsigned long)pHba;
-	pHba->host = host;
-
-	host->irq = pHba->pDev->irq;
-	/* no IO ports, so don't have to set host->io_port and
-	 * host->n_io_port
-	 */
-	host->io_port = 0;
-	host->n_io_port = 0;
-				/* see comments in scsi_host.h */
-	host->max_id = 16;
-	host->max_lun = 256;
-	host->max_channel = pHba->top_scsi_channel + 1;
-	host->cmd_per_lun = 1;
-	host->unique_id = (uint) pHba;
-	host->sg_tablesize = pHba->sg_tablesize;
-	host->can_queue = pHba->post_fifo_size;
-
-	if (scsi_add_host(host, &pHba->pDev->dev)) {
-		scsi_host_put(host);
-		return -1;
-	}
-
-	return 0;
-}
-
-static int __init adpt_init(void)
-{
-	int count;
-
-	printk("Loading Adaptec I2O RAID: Version " DPT_I2O_VERSION "\n");
-#ifdef REBOOT_NOTIFIER
-	register_reboot_notifier(&adpt_reboot_notifier);
-#endif
-
-	count = adpt_detect();
-
-	return count > 0 ? 0 : -ENODEV;
-}
-
-static void adpt_exit(void)
-{
-	while (hba_chain)
-		adpt_release(hba_chain);
-}
-
-module_init(adpt_init);
-module_exit(adpt_exit);
+#include "scsi_module.c"
 MODULE_LICENSE("GPL");

commit 9cb83c7529d929c00f37d821daed1942a1b20602
Author: FUJITA Tomonori <tomof@acm.org>
Date:   Tue Oct 16 11:24:32 2007 +0200

    [SCSI] add use_sg_chaining option to scsi_host_template
    
    This option is true if a low-level driver can support sg
    chaining. This will be removed eventually when all the drivers are
    converted to support sg chaining. q->max_phys_segments is set to
    SCSI_MAX_SG_SEGMENTS if false.
    
    Signed-off-by: FUJITA Tomonori <fujita.tomonori@lab.ntt.co.jp>
    Signed-off-by: Jens Axboe <jens.axboe@oracle.com>

diff --git a/drivers/scsi/dpt_i2o.c b/drivers/scsi/dpt_i2o.c
index bea9d659af15..8258506ba7d7 100644
--- a/drivers/scsi/dpt_i2o.c
+++ b/drivers/scsi/dpt_i2o.c
@@ -3295,6 +3295,7 @@ static struct scsi_host_template adpt_template = {
 	.this_id		= 7,
 	.cmd_per_lun		= 1,
 	.use_clustering		= ENABLE_CLUSTERING,
+	.use_sg_chaining	= ENABLE_SG_CHAINING,
 };
 
 static s32 adpt_scsi_register(adpt_hba* pHba)

commit 89932697ce742c094916d8270c282042b24776b3
Author: Joe Korty <joe.korty@ccur.com>
Date:   Tue Oct 2 14:38:08 2007 -0700

    [SCSI] dpt_i2o: Fix section mismatch
    
    Fix section mismatch in the Adaptec DPT SCSI Raid driver.
    
    WARNING: vmlinux.o(.init.text+0x1fcd2): Section mismatch:
            reference to .exit.text:adpt_exit (between 'adpt_init' and 'ahc_linux_init')
    
    This warning is due to adaptec device detection calling the exit routine on
    failure to properly register the adaptec device.
    
    The exit routine + call was added on July 30 by
    
            Commit: 55d9fcf57ba5ec427544fca7abc335cf3da78160
            Author: Matthew Wilcox
            Subject: [SCSI] dpt_i2o: convert to SCSI hotplug model.
    
    Mathew: isn't a module exit routine a little too strong to be calling on the
    failure of a single device?  Module exit implies that other, non-failing
    adaptec raid devices will also get shut down.
    
    Signed-off-by: Joe Korty <joe.korty@ccur.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>

diff --git a/drivers/scsi/dpt_i2o.c b/drivers/scsi/dpt_i2o.c
index 9d7bdf73e1e3..bea9d659af15 100644
--- a/drivers/scsi/dpt_i2o.c
+++ b/drivers/scsi/dpt_i2o.c
@@ -3346,7 +3346,7 @@ static int __init adpt_init(void)
 	return count > 0 ? 0 : -ENODEV;
 }
 
-static void __exit adpt_exit(void)
+static void adpt_exit(void)
 {
 	while (hba_chain)
 		adpt_release(hba_chain);

commit bbfbbbc1182f8b44c8cc4c99f4a3f3a512149022
Author: Mariusz Kozlowski <m.kozlowski@tuxland.pl>
Date:   Sat Aug 11 10:13:24 2007 +0200

    [SCSI] kmalloc + memset conversion to kzalloc
    
    In NCR_D700, a4000t, aic7xxx_old, bvme6000, dpt_i2o, gdth, lpfc,
    megaraid, mvme16x osst, pluto, qla2xxx, zorro7xx
    
    Signed-off-by: Mariusz Kozlowski <m.kozlowski@tuxland.pl>
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>

diff --git a/drivers/scsi/dpt_i2o.c b/drivers/scsi/dpt_i2o.c
index 502732ac270d..9d7bdf73e1e3 100644
--- a/drivers/scsi/dpt_i2o.c
+++ b/drivers/scsi/dpt_i2o.c
@@ -949,16 +949,14 @@ static int adpt_install_hba(struct pci_dev* pDev)
 	}
 	
 	// Allocate and zero the data structure
-	pHba = kmalloc(sizeof(adpt_hba), GFP_KERNEL);
-	if( pHba == NULL) {
-		if(msg_addr_virt != base_addr_virt){
+	pHba = kzalloc(sizeof(adpt_hba), GFP_KERNEL);
+	if (!pHba) {
+		if (msg_addr_virt != base_addr_virt)
 			iounmap(msg_addr_virt);
-		}
 		iounmap(base_addr_virt);
 		pci_release_regions(pDev);
 		return -ENOMEM;
 	}
-	memset(pHba, 0, sizeof(adpt_hba));
 
 	mutex_lock(&adpt_configuration_lock);
 
@@ -2622,14 +2620,13 @@ static s32 adpt_i2o_init_outbound_q(adpt_hba* pHba)
 
 	msg=(u32 __iomem *)(pHba->msg_addr_virt+m);
 
-	status = kmalloc(4,GFP_KERNEL|ADDR32);
-	if (status==NULL) {
+	status = kzalloc(4, GFP_KERNEL|ADDR32);
+	if (!status) {
 		adpt_send_nop(pHba, m);
 		printk(KERN_WARNING"%s: IOP reset failed - no free memory.\n",
 			pHba->name);
 		return -ENOMEM;
 	}
-	memset(status, 0, 4);
 
 	writel(EIGHT_WORD_MSG_SIZE| SGL_OFFSET_6, &msg[0]);
 	writel(I2O_CMD_OUTBOUND_INIT<<24 | HOST_TID<<12 | ADAPTER_TID, &msg[1]);
@@ -2668,12 +2665,11 @@ static s32 adpt_i2o_init_outbound_q(adpt_hba* pHba)
 
 	kfree(pHba->reply_pool);
 
-	pHba->reply_pool = kmalloc(pHba->reply_fifo_size * REPLY_FRAME_SIZE * 4, GFP_KERNEL|ADDR32);
-	if(!pHba->reply_pool){
-		printk(KERN_ERR"%s: Could not allocate reply pool\n",pHba->name);
-		return -1;
+	pHba->reply_pool = kzalloc(pHba->reply_fifo_size * REPLY_FRAME_SIZE * 4, GFP_KERNEL|ADDR32);
+	if (!pHba->reply_pool) {
+		printk(KERN_ERR "%s: Could not allocate reply pool\n", pHba->name);
+		return -ENOMEM;
 	}
-	memset(pHba->reply_pool, 0 , pHba->reply_fifo_size * REPLY_FRAME_SIZE * 4);
 
 	ptr = pHba->reply_pool;
 	for(i = 0; i < pHba->reply_fifo_size; i++) {
@@ -2884,12 +2880,11 @@ static int adpt_i2o_build_sys_table(void)
 
 	kfree(sys_tbl);
 
-	sys_tbl = kmalloc(sys_tbl_len, GFP_KERNEL|ADDR32);
-	if(!sys_tbl) {
+	sys_tbl = kzalloc(sys_tbl_len, GFP_KERNEL|ADDR32);
+	if (!sys_tbl) {
 		printk(KERN_WARNING "SysTab Set failed. Out of memory.\n");	
 		return -ENOMEM;
 	}
-	memset(sys_tbl, 0, sys_tbl_len);
 
 	sys_tbl->num_entries = hba_count;
 	sys_tbl->version = I2OVERSION;

commit 55d9fcf57ba5ec427544fca7abc335cf3da78160
Author: Matthew Wilcox <matthew@wil.cx>
Date:   Mon Jul 30 15:19:18 2007 -0600

    [SCSI] dpt_i2o: convert to SCSI hotplug model
    
     - Delete refereces to HOSTS_C
     - Switch to module_init/module_exit instead of detect/release
     - Don't pass around the host template and rename it to adpt_template
     - Switch from scsi_register/scsi_unregister to scsi_host_alloc,
       scsi_add_host, scsi_scan_host and scsi_host_put.
    
    Signed-off-by: Matthew Wilcox <matthew@wil.cx>
    Acked-by: "Salyzyn, Mark" <mark_salyzyn@adaptec.com>
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>

diff --git a/drivers/scsi/dpt_i2o.c b/drivers/scsi/dpt_i2o.c
index 2e2362d787ca..502732ac270d 100644
--- a/drivers/scsi/dpt_i2o.c
+++ b/drivers/scsi/dpt_i2o.c
@@ -173,20 +173,20 @@ static struct pci_device_id dptids[] = {
 };
 MODULE_DEVICE_TABLE(pci,dptids);
 
-static int adpt_detect(struct scsi_host_template* sht)
+static void adpt_exit(void);
+
+static int adpt_detect(void)
 {
 	struct pci_dev *pDev = NULL;
 	adpt_hba* pHba;
 
-	adpt_init();
-
 	PINFO("Detecting Adaptec I2O RAID controllers...\n");
 
         /* search for all Adatpec I2O RAID cards */
 	while ((pDev = pci_get_device( PCI_DPT_VENDOR_ID, PCI_ANY_ID, pDev))) {
 		if(pDev->device == PCI_DPT_DEVICE_ID ||
 		   pDev->device == PCI_DPT_RAPTOR_DEVICE_ID){
-			if(adpt_install_hba(sht, pDev) ){
+			if(adpt_install_hba(pDev) ){
 				PERROR("Could not Init an I2O RAID device\n");
 				PERROR("Will not try to detect others.\n");
 				return hba_count-1;
@@ -248,34 +248,33 @@ static int adpt_detect(struct scsi_host_template* sht)
 	}
 
 	for (pHba = hba_chain; pHba; pHba = pHba->next) {
-		if( adpt_scsi_register(pHba,sht) < 0){
+		if (adpt_scsi_register(pHba) < 0) {
 			adpt_i2o_delete_hba(pHba);
 			continue;
 		}
 		pHba->initialized = TRUE;
 		pHba->state &= ~DPTI_STATE_RESET;
+		scsi_scan_host(pHba->host);
 	}
 
 	// Register our control device node
 	// nodes will need to be created in /dev to access this
 	// the nodes can not be created from within the driver
 	if (hba_count && register_chrdev(DPTI_I2O_MAJOR, DPT_DRIVER, &adpt_fops)) {
-		adpt_i2o_sys_shutdown();
+		adpt_exit();
 		return 0;
 	}
 	return hba_count;
 }
 
 
-/*
- * scsi_unregister will be called AFTER we return. 
- */
-static int adpt_release(struct Scsi_Host *host)
+static int adpt_release(adpt_hba *pHba)
 {
-	adpt_hba* pHba = (adpt_hba*) host->hostdata[0];
+	struct Scsi_Host *shost = pHba->host;
+	scsi_remove_host(shost);
 //	adpt_i2o_quiesce_hba(pHba);
 	adpt_i2o_delete_hba(pHba);
-	scsi_unregister(host);
+	scsi_host_put(shost);
 	return 0;
 }
 
@@ -882,7 +881,7 @@ static int adpt_reboot_event(struct notifier_block *n, ulong code, void *p)
 #endif
 
 
-static int adpt_install_hba(struct scsi_host_template* sht, struct pci_dev* pDev) 
+static int adpt_install_hba(struct pci_dev* pDev)
 {
 
 	adpt_hba* pHba = NULL;
@@ -1031,8 +1030,6 @@ static void adpt_i2o_delete_hba(adpt_hba* pHba)
 
 
 	mutex_lock(&adpt_configuration_lock);
-	// scsi_unregister calls our adpt_release which
-	// does a quiese
 	if(pHba->host){
 		free_irq(pHba->host->irq, pHba);
 	}
@@ -1084,17 +1081,6 @@ static void adpt_i2o_delete_hba(adpt_hba* pHba)
 }
 
 
-static int adpt_init(void)
-{
-	printk("Loading Adaptec I2O RAID: Version " DPT_I2O_VERSION "\n");
-#ifdef REBOOT_NOTIFIER
-	register_reboot_notifier(&adpt_reboot_notifier);
-#endif
-
-	return 0;
-}
-
-
 static struct adpt_device* adpt_find_device(adpt_hba* pHba, u32 chan, u32 id, u32 lun)
 {
 	struct adpt_device* d;
@@ -2180,37 +2166,6 @@ static s32 adpt_scsi_to_i2o(adpt_hba* pHba, struct scsi_cmnd* cmd, struct adpt_d
 }
 
 
-static s32 adpt_scsi_register(adpt_hba* pHba,struct scsi_host_template * sht)
-{
-	struct Scsi_Host *host = NULL;
-
-	host = scsi_register(sht, sizeof(adpt_hba*));
-	if (host == NULL) {
-		printk ("%s: scsi_register returned NULL\n",pHba->name);
-		return -1;
-	}
-	host->hostdata[0] = (unsigned long)pHba;
-	pHba->host = host;
-
-	host->irq = pHba->pDev->irq;
-	/* no IO ports, so don't have to set host->io_port and 
-	 * host->n_io_port
-	 */
-	host->io_port = 0;
-	host->n_io_port = 0;
-				/* see comments in scsi_host.h */
-	host->max_id = 16;
-	host->max_lun = 256;
-	host->max_channel = pHba->top_scsi_channel + 1;
-	host->cmd_per_lun = 1;
-	host->unique_id = (uint) pHba;
-	host->sg_tablesize = pHba->sg_tablesize;
-	host->can_queue = pHba->post_fifo_size;
-
-	return 0;
-}
-
-
 static s32 adpt_i2o_to_scsi(void __iomem *reply, struct scsi_cmnd* cmd)
 {
 	adpt_hba* pHba;
@@ -3329,12 +3284,10 @@ static static void adpt_delay(int millisec)
 
 #endif
 
-static struct scsi_host_template driver_template = {
+static struct scsi_host_template adpt_template = {
 	.name			= "dpt_i2o",
 	.proc_name		= "dpt_i2o",
 	.proc_info		= adpt_proc_info,
-	.detect			= adpt_detect,	
-	.release		= adpt_release,
 	.info			= adpt_info,
 	.queuecommand		= adpt_queue,
 	.eh_abort_handler	= adpt_abort,
@@ -3348,5 +3301,62 @@ static struct scsi_host_template driver_template = {
 	.cmd_per_lun		= 1,
 	.use_clustering		= ENABLE_CLUSTERING,
 };
-#include "scsi_module.c"
+
+static s32 adpt_scsi_register(adpt_hba* pHba)
+{
+	struct Scsi_Host *host;
+
+	host = scsi_host_alloc(&adpt_template, sizeof(adpt_hba*));
+	if (host == NULL) {
+		printk ("%s: scsi_host_alloc returned NULL\n",pHba->name);
+		return -1;
+	}
+	host->hostdata[0] = (unsigned long)pHba;
+	pHba->host = host;
+
+	host->irq = pHba->pDev->irq;
+	/* no IO ports, so don't have to set host->io_port and
+	 * host->n_io_port
+	 */
+	host->io_port = 0;
+	host->n_io_port = 0;
+				/* see comments in scsi_host.h */
+	host->max_id = 16;
+	host->max_lun = 256;
+	host->max_channel = pHba->top_scsi_channel + 1;
+	host->cmd_per_lun = 1;
+	host->unique_id = (uint) pHba;
+	host->sg_tablesize = pHba->sg_tablesize;
+	host->can_queue = pHba->post_fifo_size;
+
+	if (scsi_add_host(host, &pHba->pDev->dev)) {
+		scsi_host_put(host);
+		return -1;
+	}
+
+	return 0;
+}
+
+static int __init adpt_init(void)
+{
+	int count;
+
+	printk("Loading Adaptec I2O RAID: Version " DPT_I2O_VERSION "\n");
+#ifdef REBOOT_NOTIFIER
+	register_reboot_notifier(&adpt_reboot_notifier);
+#endif
+
+	count = adpt_detect();
+
+	return count > 0 ? 0 : -ENODEV;
+}
+
+static void __exit adpt_exit(void)
+{
+	while (hba_chain)
+		adpt_release(hba_chain);
+}
+
+module_init(adpt_init);
+module_exit(adpt_exit);
 MODULE_LICENSE("GPL");

commit 10803de4c18e8e085573fd7153de3e64d4246af5
Author: FUJITA Tomonori <fujita.tomonori@lab.ntt.co.jp>
Date:   Sat May 26 02:08:10 2007 +0900

    [SCSI] dpt_i2o: convert to use the data buffer accessors
    
    - remove the unnecessary map_single path.
    
    - convert to use the new accessors for the sg lists and the
    parameters.
    
    Jens Axboe <jens.axboe@oracle.com> did the for_each_sg cleanup.
    
    Signed-off-by: FUJITA Tomonori <fujita.tomonori@lab.ntt.co.jp>
    
    ACK. Code inspected. Driver changes NOT unit tested or compile tested.
    Acked-by: "Salyzyn, Mark" <mark_salyzyn@adaptec.com>
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>

diff --git a/drivers/scsi/dpt_i2o.c b/drivers/scsi/dpt_i2o.c
index 8c7d2bbf9b1a..2e2362d787ca 100644
--- a/drivers/scsi/dpt_i2o.c
+++ b/drivers/scsi/dpt_i2o.c
@@ -2078,12 +2078,13 @@ static s32 adpt_scsi_to_i2o(adpt_hba* pHba, struct scsi_cmnd* cmd, struct adpt_d
 	u32 *lenptr;
 	int direction;
 	int scsidir;
+	int nseg;
 	u32 len;
 	u32 reqlen;
 	s32 rcode;
 
 	memset(msg, 0 , sizeof(msg));
-	len = cmd->request_bufflen;
+	len = scsi_bufflen(cmd);
 	direction = 0x00000000;	
 	
 	scsidir = 0x00000000;			// DATA NO XFER
@@ -2140,21 +2141,21 @@ static s32 adpt_scsi_to_i2o(adpt_hba* pHba, struct scsi_cmnd* cmd, struct adpt_d
 	lenptr=mptr++;		/* Remember me - fill in when we know */
 	reqlen = 14;		// SINGLE SGE
 	/* Now fill in the SGList and command */
-	if(cmd->use_sg) {
-		struct scatterlist *sg = (struct scatterlist *)cmd->request_buffer;
-		int sg_count = pci_map_sg(pHba->pDev, sg, cmd->use_sg,
-				cmd->sc_data_direction);
 
+	nseg = scsi_dma_map(cmd);
+	BUG_ON(nseg < 0);
+	if (nseg) {
+		struct scatterlist *sg;
 
 		len = 0;
-		for(i = 0 ; i < sg_count; i++) {
+		scsi_for_each_sg(cmd, sg, nseg, i) {
 			*mptr++ = direction|0x10000000|sg_dma_len(sg);
 			len+=sg_dma_len(sg);
 			*mptr++ = sg_dma_address(sg);
-			sg++;
+			/* Make this an end of list */
+			if (i == nseg - 1)
+				mptr[-2] = direction|0xD0000000|sg_dma_len(sg);
 		}
-		/* Make this an end of list */
-		mptr[-2] = direction|0xD0000000|sg_dma_len(sg-1);
 		reqlen = mptr - msg;
 		*lenptr = len;
 		
@@ -2163,16 +2164,8 @@ static s32 adpt_scsi_to_i2o(adpt_hba* pHba, struct scsi_cmnd* cmd, struct adpt_d
 				len, cmd->underflow);
 		}
 	} else {
-		*lenptr = len = cmd->request_bufflen;
-		if(len == 0) {
-			reqlen = 12;
-		} else {
-			*mptr++ = 0xD0000000|direction|cmd->request_bufflen;
-			*mptr++ = pci_map_single(pHba->pDev,
-				cmd->request_buffer,
-				cmd->request_bufflen,
-				cmd->sc_data_direction);
-		}
+		*lenptr = len = 0;
+		reqlen = 12;
 	}
 	
 	/* Stick the headers on */
@@ -2232,7 +2225,7 @@ static s32 adpt_i2o_to_scsi(void __iomem *reply, struct scsi_cmnd* cmd)
 	hba_status = detailed_status >> 8;
 
 	// calculate resid for sg 
-	cmd->resid = cmd->request_bufflen - readl(reply+5);
+	scsi_set_resid(cmd, scsi_bufflen(cmd) - readl(reply+5));
 
 	pHba = (adpt_hba*) cmd->device->host->hostdata[0];
 

commit 6ec129c3a2f8b38bc37e42348470ccfcb7460146
Merge: 01e73be3c8f2 b64ddf96456c
Author: Linus Torvalds <torvalds@woody.linux-foundation.org>
Date:   Tue May 8 20:32:16 2007 -0700

    Merge master.kernel.org:/pub/scm/linux/kernel/git/jejb/scsi-misc-2.6
    
    * master.kernel.org:/pub/scm/linux/kernel/git/jejb/scsi-misc-2.6: (58 commits)
      [SCSI] zfcp: clear boxed flag on unit reopen.
      [SCSI] zfcp: clear adapter failed flag if an fsf request times out.
      [SCSI] zfcp: rework request ID management.
      [SCSI] zfcp: Fix deadlock between zfcp ERP and SCSI
      [SCSI] zfcp: Locking for req_no and req_seq_no
      [SCSI] zfcp: print S_ID and D_ID with 3 bytes
      [SCSI] ipr: Use PCI-E reset API for new ipr adapter
      [SCSI] qla2xxx: Update version number to 8.01.07-k7.
      [SCSI] qla2xxx: Add MSI support.
      [SCSI] qla2xxx: Correct pci_set_msi() usage semantics.
      [SCSI] qla2xxx: Attempt to stop firmware only if it had been previously executed.
      [SCSI] qla2xxx: Honor NVRAM port-down-retry-count settings.
      [SCSI] qla2xxx: Error-out during probe() if we're unable to complete HBA initialization.
      [SCSI] zfcp: Stop system after memory corruption
      [SCSI] mesh: cleanup variable usage in interrupt handler
      [SCSI] megaraid: replace yield() with cond_resched()
      [SCSI] megaraid: fix warnings when CONFIG_PROC_FS=n
      [SCSI] aacraid: correct SUN products to README
      [SCSI] aacraid: superfluous adapter reset for IBM 8 series ServeRAID controllers
      [SCSI] aacraid: kexec fix (reset interrupt handler)
      ...

commit e63340ae6b6205fef26b40a75673d1c9c0c8bb90
Author: Randy Dunlap <randy.dunlap@oracle.com>
Date:   Tue May 8 00:28:08 2007 -0700

    header cleaning: don't include smp_lock.h when not used
    
    Remove includes of <linux/smp_lock.h> where it is not used/needed.
    Suggested by Al Viro.
    
    Builds cleanly on x86_64, i386, alpha, ia64, powerpc, sparc,
    sparc64, and arm (all 59 defconfigs).
    
    Signed-off-by: Randy Dunlap <randy.dunlap@oracle.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/scsi/dpt_i2o.c b/drivers/scsi/dpt_i2o.c
index f7b9dbd64a96..fb6433a56989 100644
--- a/drivers/scsi/dpt_i2o.c
+++ b/drivers/scsi/dpt_i2o.c
@@ -55,7 +55,6 @@ MODULE_DESCRIPTION("Adaptec I2O RAID Driver");
 #include <linux/sched.h>
 #include <linux/reboot.h>
 #include <linux/spinlock.h>
-#include <linux/smp_lock.h>
 #include <linux/dma-mapping.h>
 
 #include <linux/timer.h>

commit ab552204599d311988be89fe0bbbe5ea9d84184a
Author: vignesh.babu@wipro.com <vignesh.babu@wipro.com>
Date:   Mon Apr 16 11:35:38 2007 +0530

    [SCSI] dpt_i2o: kmalloc/memset->kzalloc
    
    Replacing kmalloc/memset combination with kzalloc.
    
    Signed-off-by: vignesh babu <vignesh.babu@wipro.com>
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>

diff --git a/drivers/scsi/dpt_i2o.c b/drivers/scsi/dpt_i2o.c
index f7b9dbd64a96..6c384ab2884a 100644
--- a/drivers/scsi/dpt_i2o.c
+++ b/drivers/scsi/dpt_i2o.c
@@ -1309,13 +1309,12 @@ static s32 adpt_i2o_reset_hba(adpt_hba* pHba)
 		schedule_timeout_uninterruptible(1);
 	} while (m == EMPTY_QUEUE);
 
-	status = kmalloc(4, GFP_KERNEL|ADDR32);
+	status = kzalloc(4, GFP_KERNEL|ADDR32);
 	if(status == NULL) {
 		adpt_send_nop(pHba, m);
 		printk(KERN_ERR"IOP reset failed - no free memory.\n");
 		return -ENOMEM;
 	}
-	memset(status,0,4);
 
 	msg[0]=EIGHT_WORD_MSG_SIZE|SGL_OFFSET_0;
 	msg[1]=I2O_CMD_ADAPTER_RESET<<24|HOST_TID<<12|ADAPTER_TID;
@@ -1505,21 +1504,19 @@ static int adpt_i2o_parse_lct(adpt_hba* pHba)
 					continue;
 				}
 				if( pHba->channel[bus_no].device[scsi_id] == NULL){
-					pDev =  kmalloc(sizeof(struct adpt_device),GFP_KERNEL);
+					pDev =  kzalloc(sizeof(struct adpt_device),GFP_KERNEL);
 					if(pDev == NULL) {
 						return -ENOMEM;
 					}
 					pHba->channel[bus_no].device[scsi_id] = pDev;
-					memset(pDev,0,sizeof(struct adpt_device));
 				} else {
 					for( pDev = pHba->channel[bus_no].device[scsi_id];	
 							pDev->next_lun; pDev = pDev->next_lun){
 					}
-					pDev->next_lun = kmalloc(sizeof(struct adpt_device),GFP_KERNEL);
+					pDev->next_lun = kzalloc(sizeof(struct adpt_device),GFP_KERNEL);
 					if(pDev->next_lun == NULL) {
 						return -ENOMEM;
 					}
-					memset(pDev->next_lun,0,sizeof(struct adpt_device));
 					pDev = pDev->next_lun;
 				}
 				pDev->tid = tid;
@@ -1668,12 +1665,11 @@ static int adpt_i2o_passthru(adpt_hba* pHba, u32 __user *arg)
 		reply_size = REPLY_FRAME_SIZE;
 	}
 	reply_size *= 4;
-	reply = kmalloc(REPLY_FRAME_SIZE*4, GFP_KERNEL);
+	reply = kzalloc(REPLY_FRAME_SIZE*4, GFP_KERNEL);
 	if(reply == NULL) {
 		printk(KERN_WARNING"%s: Could not allocate reply buffer\n",pHba->name);
 		return -ENOMEM;
 	}
-	memset(reply,0,REPLY_FRAME_SIZE*4);
 	sg_offset = (msg[0]>>4)&0xf;
 	msg[2] = 0x40000000; // IOCTL context
 	msg[3] = (u32)reply;
@@ -2445,7 +2441,7 @@ static s32 adpt_i2o_reparse_lct(adpt_hba* pHba)
 				}
 				pDev = pHba->channel[bus_no].device[scsi_id];	
 				if( pDev == NULL){
-					pDev =  kmalloc(sizeof(struct adpt_device),GFP_KERNEL);
+					pDev =  kzalloc(sizeof(struct adpt_device),GFP_KERNEL);
 					if(pDev == NULL) {
 						return -ENOMEM;
 					}
@@ -2454,12 +2450,11 @@ static s32 adpt_i2o_reparse_lct(adpt_hba* pHba)
 					while (pDev->next_lun) {
 						pDev = pDev->next_lun;
 					}
-					pDev = pDev->next_lun = kmalloc(sizeof(struct adpt_device),GFP_KERNEL);
+					pDev = pDev->next_lun = kzalloc(sizeof(struct adpt_device),GFP_KERNEL);
 					if(pDev == NULL) {
 						return -ENOMEM;
 					}
 				}
-				memset(pDev,0,sizeof(struct adpt_device));
 				pDev->tid = d->lct_data.tid;
 				pDev->scsi_channel = bus_no;
 				pDev->scsi_id = scsi_id;

commit 3cfff0fc74bf5ac8213b5a2be583bf675ccd9511
Author: Adrian Bunk <bunk@stusta.de>
Date:   Mon Mar 26 21:59:25 2007 -0800

    [SCSI] dpt_i2o: remove dead code
    
    The Coverity checker spotted this dead code introduced by
    commit a07f353701acae77e023f6270e8af353b37af7c4.
    
    Signed-off-by: Adrian Bunk <bunk@stusta.de>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Acked-by: "Salyzyn, Mark" <mark_salyzyn@adaptec.com>
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>

diff --git a/drivers/scsi/dpt_i2o.c b/drivers/scsi/dpt_i2o.c
index cd36e81b2d93..f7b9dbd64a96 100644
--- a/drivers/scsi/dpt_i2o.c
+++ b/drivers/scsi/dpt_i2o.c
@@ -195,8 +195,6 @@ static int adpt_detect(struct scsi_host_template* sht)
 			pci_dev_get(pDev);
 		}
 	}
-	if (pDev)
-		pci_dev_put(pDev);
 
 	/* In INIT state, Activate IOPs */
 	for (pHba = hba_chain; pHba; pHba = pHba->next) {

commit 00977a59b951207d38380c75f03a36829950265c
Author: Arjan van de Ven <arjan@linux.intel.com>
Date:   Mon Feb 12 00:55:34 2007 -0800

    [PATCH] mark struct file_operations const 6
    
    Many struct file_operations in the kernel can be "const".  Marking them const
    moves these to the .rodata section, which avoids false sharing with potential
    dirty data.  In addition it'll catch accidental writes at compile time to
    these shared resources.
    
    Signed-off-by: Arjan van de Ven <arjan@linux.intel.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/scsi/dpt_i2o.c b/drivers/scsi/dpt_i2o.c
index 365db537a28d..cd36e81b2d93 100644
--- a/drivers/scsi/dpt_i2o.c
+++ b/drivers/scsi/dpt_i2o.c
@@ -116,7 +116,7 @@ static int sys_tbl_len = 0;
 static adpt_hba* hba_chain = NULL;
 static int hba_count = 0;
 
-static struct file_operations adpt_fops = {
+static const struct file_operations adpt_fops = {
 	.ioctl		= adpt_ioctl,
 	.open		= adpt_open,
 	.release	= adpt_close

commit 5cbded585d129d0226cb48ac4202b253c781be26
Author: Robert P. J. Day <rpjday@mindspring.com>
Date:   Wed Dec 13 00:35:56 2006 -0800

    [PATCH] getting rid of all casts of k[cmz]alloc() calls
    
    Run this:
    
            #!/bin/sh
            for f in $(grep -Erl "\([^\)]*\) *k[cmz]alloc" *) ; do
              echo "De-casting $f..."
              perl -pi -e "s/ ?= ?\([^\)]*\) *(k[cmz]alloc) *\(/ = \1\(/" $f
            done
    
    And then go through and reinstate those cases where code is casting pointers
    to non-pointers.
    
    And then drop a few hunks which conflicted with outstanding work.
    
    Cc: Russell King <rmk@arm.linux.org.uk>, Ian Molton <spyro@f2s.com>
    Cc: Mikael Starvik <starvik@axis.com>
    Cc: Yoshinori Sato <ysato@users.sourceforge.jp>
    Cc: Roman Zippel <zippel@linux-m68k.org>
    Cc: Geert Uytterhoeven <geert@linux-m68k.org>
    Cc: Ralf Baechle <ralf@linux-mips.org>
    Cc: Paul Mackerras <paulus@samba.org>
    Cc: Kyle McMartin <kyle@mcmartin.ca>
    Cc: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Cc: Martin Schwidefsky <schwidefsky@de.ibm.com>
    Cc: "David S. Miller" <davem@davemloft.net>
    Cc: Jeff Dike <jdike@addtoit.com>
    Cc: Greg KH <greg@kroah.com>
    Cc: Jens Axboe <jens.axboe@oracle.com>
    Cc: Paul Fulghum <paulkf@microgate.com>
    Cc: Alan Cox <alan@lxorguk.ukuu.org.uk>
    Cc: Karsten Keil <kkeil@suse.de>
    Cc: Mauro Carvalho Chehab <mchehab@infradead.org>
    Cc: Jeff Garzik <jeff@garzik.org>
    Cc: James Bottomley <James.Bottomley@steeleye.com>
    Cc: Ian Kent <raven@themaw.net>
    Cc: Steven French <sfrench@us.ibm.com>
    Cc: David Woodhouse <dwmw2@infradead.org>
    Cc: Neil Brown <neilb@cse.unsw.edu.au>
    Cc: Jaroslav Kysela <perex@suse.cz>
    Cc: Takashi Iwai <tiwai@suse.de>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/drivers/scsi/dpt_i2o.c b/drivers/scsi/dpt_i2o.c
index 60b1b434eba7..365db537a28d 100644
--- a/drivers/scsi/dpt_i2o.c
+++ b/drivers/scsi/dpt_i2o.c
@@ -297,7 +297,7 @@ static void adpt_inquiry(adpt_hba* pHba)
 	s32 rcode;
 
 	memset(msg, 0, sizeof(msg));
-	buf = (u8*)kmalloc(80,GFP_KERNEL|ADDR32);
+	buf = kmalloc(80,GFP_KERNEL|ADDR32);
 	if(!buf){
 		printk(KERN_ERR"%s: Could not allocate buffer\n",pHba->name);
 		return;
@@ -1311,7 +1311,7 @@ static s32 adpt_i2o_reset_hba(adpt_hba* pHba)
 		schedule_timeout_uninterruptible(1);
 	} while (m == EMPTY_QUEUE);
 
-	status = (u8*)kmalloc(4, GFP_KERNEL|ADDR32);
+	status = kmalloc(4, GFP_KERNEL|ADDR32);
 	if(status == NULL) {
 		adpt_send_nop(pHba, m);
 		printk(KERN_ERR"IOP reset failed - no free memory.\n");
@@ -1444,7 +1444,7 @@ static int adpt_i2o_parse_lct(adpt_hba* pHba)
 			}
 			continue;
 		}
-		d = (struct i2o_device *)kmalloc(sizeof(struct i2o_device), GFP_KERNEL);
+		d = kmalloc(sizeof(struct i2o_device), GFP_KERNEL);
 		if(d==NULL)
 		{
 			printk(KERN_CRIT"%s: Out of memory for I2O device data.\n",pHba->name);
@@ -2425,7 +2425,7 @@ static s32 adpt_i2o_reparse_lct(adpt_hba* pHba)
 				pDev = pDev->next_lun;
 			}
 			if(!pDev ) { // Something new add it
-				d = (struct i2o_device *)kmalloc(sizeof(struct i2o_device), GFP_KERNEL);
+				d = kmalloc(sizeof(struct i2o_device), GFP_KERNEL);
 				if(d==NULL)
 				{
 					printk(KERN_CRIT "Out of memory for I2O device data.\n");
@@ -2728,7 +2728,7 @@ static s32 adpt_i2o_init_outbound_q(adpt_hba* pHba)
 
 	kfree(pHba->reply_pool);
 
-	pHba->reply_pool = (u32*)kmalloc(pHba->reply_fifo_size * REPLY_FRAME_SIZE * 4, GFP_KERNEL|ADDR32);
+	pHba->reply_pool = kmalloc(pHba->reply_fifo_size * REPLY_FRAME_SIZE * 4, GFP_KERNEL|ADDR32);
 	if(!pHba->reply_pool){
 		printk(KERN_ERR"%s: Could not allocate reply pool\n",pHba->name);
 		return -1;

commit 7d12e780e003f93433d49ce78cfedf4b4c52adc5
Author: David Howells <dhowells@redhat.com>
Date:   Thu Oct 5 14:55:46 2006 +0100

    IRQ: Maintain regs pointer globally rather than passing to IRQ handlers
    
    Maintain a per-CPU global "struct pt_regs *" variable which can be used instead
    of passing regs around manually through all ~1800 interrupt handlers in the
    Linux kernel.
    
    The regs pointer is used in few places, but it potentially costs both stack
    space and code to pass it around.  On the FRV arch, removing the regs parameter
    from all the genirq function results in a 20% speed up of the IRQ exit path
    (ie: from leaving timer_interrupt() to leaving do_IRQ()).
    
    Where appropriate, an arch may override the generic storage facility and do
    something different with the variable.  On FRV, for instance, the address is
    maintained in GR28 at all times inside the kernel as part of general exception
    handling.
    
    Having looked over the code, it appears that the parameter may be handed down
    through up to twenty or so layers of functions.  Consider a USB character
    device attached to a USB hub, attached to a USB controller that posts its
    interrupts through a cascaded auxiliary interrupt controller.  A character
    device driver may want to pass regs to the sysrq handler through the input
    layer which adds another few layers of parameter passing.
    
    I've build this code with allyesconfig for x86_64 and i386.  I've runtested the
    main part of the code on FRV and i386, though I can't test most of the drivers.
    I've also done partial conversion for powerpc and MIPS - these at least compile
    with minimal configurations.
    
    This will affect all archs.  Mostly the changes should be relatively easy.
    Take do_IRQ(), store the regs pointer at the beginning, saving the old one:
    
            struct pt_regs *old_regs = set_irq_regs(regs);
    
    And put the old one back at the end:
    
            set_irq_regs(old_regs);
    
    Don't pass regs through to generic_handle_irq() or __do_IRQ().
    
    In timer_interrupt(), this sort of change will be necessary:
    
            -       update_process_times(user_mode(regs));
            -       profile_tick(CPU_PROFILING, regs);
            +       update_process_times(user_mode(get_irq_regs()));
            +       profile_tick(CPU_PROFILING);
    
    I'd like to move update_process_times()'s use of get_irq_regs() into itself,
    except that i386, alone of the archs, uses something other than user_mode().
    
    Some notes on the interrupt handling in the drivers:
    
     (*) input_dev() is now gone entirely.  The regs pointer is no longer stored in
         the input_dev struct.
    
     (*) finish_unlinks() in drivers/usb/host/ohci-q.c needs checking.  It does
         something different depending on whether it's been supplied with a regs
         pointer or not.
    
     (*) Various IRQ handler function pointers have been moved to type
         irq_handler_t.
    
    Signed-Off-By: David Howells <dhowells@redhat.com>
    (cherry picked from 1b16e7ac850969f38b375e511e3fa2f474a33867 commit)

diff --git a/drivers/scsi/dpt_i2o.c b/drivers/scsi/dpt_i2o.c
index b20b37661d6f..60b1b434eba7 100644
--- a/drivers/scsi/dpt_i2o.c
+++ b/drivers/scsi/dpt_i2o.c
@@ -1989,7 +1989,7 @@ static int adpt_ioctl(struct inode *inode, struct file *file, uint cmd,
 }
 
 
-static irqreturn_t adpt_isr(int irq, void *dev_id, struct pt_regs *regs)
+static irqreturn_t adpt_isr(int irq, void *dev_id)
 {
 	struct scsi_cmnd* cmd;
 	adpt_hba* pHba = dev_id;

commit de77aaff5f0178f44867f131deb5e2cb1610fe6b
Author: Henne <henne@nachtwindheim.de>
Date:   Wed Oct 4 10:22:09 2006 +0200

    [SCSI] scsi: remove hosts.h
    
    Remove the obsolete hosts.h file under drivers/scsi.
    
    Signed-off-by: Henrik Kretzschmar <henne@nachtwindheim.de>
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>

diff --git a/drivers/scsi/dpt_i2o.c b/drivers/scsi/dpt_i2o.c
index 7b3bd34faf47..b20b37661d6f 100644
--- a/drivers/scsi/dpt_i2o.c
+++ b/drivers/scsi/dpt_i2o.c
@@ -2212,7 +2212,7 @@ static s32 adpt_scsi_register(adpt_hba* pHba,struct scsi_host_template * sht)
 	 */
 	host->io_port = 0;
 	host->n_io_port = 0;
-				/* see comments in hosts.h */
+				/* see comments in scsi_host.h */
 	host->max_id = 16;
 	host->max_lun = 256;
 	host->max_channel = pHba->top_scsi_channel + 1;

commit a07f353701acae77e023f6270e8af353b37af7c4
Author: Alan Cox <alan@lxorguk.ukuu.org.uk>
Date:   Fri Sep 15 15:34:32 2006 +0100

    [SCSI] Switch some more scsi drivers to pci_get_device and refcounted pci structures
    
    Signed-off-by: Alan Cox <alan@redhat.com>
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>

diff --git a/drivers/scsi/dpt_i2o.c b/drivers/scsi/dpt_i2o.c
index 45806336ce02..7b3bd34faf47 100644
--- a/drivers/scsi/dpt_i2o.c
+++ b/drivers/scsi/dpt_i2o.c
@@ -184,7 +184,7 @@ static int adpt_detect(struct scsi_host_template* sht)
 	PINFO("Detecting Adaptec I2O RAID controllers...\n");
 
         /* search for all Adatpec I2O RAID cards */
-	while ((pDev = pci_find_device( PCI_DPT_VENDOR_ID, PCI_ANY_ID, pDev))) {
+	while ((pDev = pci_get_device( PCI_DPT_VENDOR_ID, PCI_ANY_ID, pDev))) {
 		if(pDev->device == PCI_DPT_DEVICE_ID ||
 		   pDev->device == PCI_DPT_RAPTOR_DEVICE_ID){
 			if(adpt_install_hba(sht, pDev) ){
@@ -192,8 +192,11 @@ static int adpt_detect(struct scsi_host_template* sht)
 				PERROR("Will not try to detect others.\n");
 				return hba_count-1;
 			}
+			pci_dev_get(pDev);
 		}
 	}
+	if (pDev)
+		pci_dev_put(pDev);
 
 	/* In INIT state, Activate IOPs */
 	for (pHba = hba_chain; pHba; pHba = pHba->next) {
@@ -1075,6 +1078,7 @@ static void adpt_i2o_delete_hba(adpt_hba* pHba)
 			}
 		}
 	}
+	pci_dev_put(pHba->pDev);
 	kfree(pHba);
 
 	if(hba_count <= 0){

commit a2f5d4d94f0ab9560b9a99d73d5b86b377c7f201
Author: Dave Jones <davej@redhat.com>
Date:   Thu Aug 10 21:41:13 2006 -0400

    [SCSI] remove unnecessary includes of linux/config.h from drivers/scsi/
    
    kbuild includes this automatically these days.
    
    Signed-off-by: Dave Jones <davej@redhat.com>
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>

diff --git a/drivers/scsi/dpt_i2o.c b/drivers/scsi/dpt_i2o.c
index e1337339cacc..45806336ce02 100644
--- a/drivers/scsi/dpt_i2o.c
+++ b/drivers/scsi/dpt_i2o.c
@@ -46,7 +46,6 @@ MODULE_DESCRIPTION("Adaptec I2O RAID Driver");
 
 #include <linux/stat.h>
 #include <linux/slab.h>		/* for kmalloc() */
-#include <linux/config.h>	/* for CONFIG_PCI */
 #include <linux/pci.h>		/* for PCI support */
 #include <linux/proc_fs.h>
 #include <linux/blkdev.h>

commit 1d6f359a2e06296418481239f8054a878f36e819
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Sat Jul 1 19:29:42 2006 -0700

    [PATCH] irq-flags: scsi: Use the new IRQF_ constants
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: Ingo Molnar <mingo@elte.hu>
    Cc: "David S. Miller" <davem@davemloft.net>
    Cc: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Cc: James Bottomley <James.Bottomley@steeleye.com>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/drivers/scsi/dpt_i2o.c b/drivers/scsi/dpt_i2o.c
index b1b704a42efd..e1337339cacc 100644
--- a/drivers/scsi/dpt_i2o.c
+++ b/drivers/scsi/dpt_i2o.c
@@ -1009,7 +1009,7 @@ static int adpt_install_hba(struct scsi_host_template* sht, struct pci_dev* pDev
 		printk(KERN_INFO"     BAR1 %p - size= %x\n",msg_addr_virt,hba_map1_area_size);
 	}
 
-	if (request_irq (pDev->irq, adpt_isr, SA_SHIRQ, pHba->name, pHba)) {
+	if (request_irq (pDev->irq, adpt_isr, IRQF_SHARED, pHba->name, pHba)) {
 		printk(KERN_ERR"%s: Couldn't register IRQ %d\n", pHba->name, pDev->irq);
 		adpt_i2o_delete_hba(pHba);
 		return -EINVAL;

commit 910638ae7ed4be27d6af55f6c9b5bf54b838e78b
Author: Matthias Gehre <M.Gehre@gmx.de>
Date:   Tue Mar 28 01:56:48 2006 -0800

    [PATCH] Replace 0xff.. with correct DMA_xBIT_MASK
    
    Replace all occurences of 0xff..  in calls to function pci_set_dma_mask()
    and pci_set_consistant_dma_mask() with the corresponding DMA_xBIT_MASK from
    linux/dma-mapping.h.
    
    Signed-off-by: Matthias Gehre <M.Gehre@gmx.de>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/drivers/scsi/dpt_i2o.c b/drivers/scsi/dpt_i2o.c
index 6e6b293dcb28..b1b704a42efd 100644
--- a/drivers/scsi/dpt_i2o.c
+++ b/drivers/scsi/dpt_i2o.c
@@ -57,6 +57,7 @@ MODULE_DESCRIPTION("Adaptec I2O RAID Driver");
 #include <linux/reboot.h>
 #include <linux/spinlock.h>
 #include <linux/smp_lock.h>
+#include <linux/dma-mapping.h>
 
 #include <linux/timer.h>
 #include <linux/string.h>
@@ -906,8 +907,8 @@ static int adpt_install_hba(struct scsi_host_template* sht, struct pci_dev* pDev
 	}
 
 	pci_set_master(pDev);
-	if (pci_set_dma_mask(pDev, 0xffffffffffffffffULL) &&
-	    pci_set_dma_mask(pDev, 0xffffffffULL))
+	if (pci_set_dma_mask(pDev, DMA_64BIT_MASK) &&
+	    pci_set_dma_mask(pDev, DMA_32BIT_MASK))
 		return -EINVAL;
 
 	base_addr0_phys = pci_resource_start(pDev,0);

commit 9638d89a75776abc614c29cdeece0cc874ea2a4c
Author: Salyzyn, Mark <mark_salyzyn@adaptec.com>
Date:   Thu Jan 12 08:31:57 2006 -0500

    [SCSI] I2O: move pci_request_regions() just behind pci_enable_device()
    
    The problem in dpt_i2o could be the pci config space accesses it
    triggers as it loads, dangerous to do if there is any I/O activity going
    on in the other driver (probable if a boot driver I guess).
    
    I approve this patch to dpt_i2o.c, and am applying it to the Adaptec
    branch of the driver.
    
    Thanks for the investigation Ryoji.
    
    ---
    
    In linux 2.6.15, data transfer does hang when both dpt_i2o
    and i2o_block drivers are loaded.
    It seems that location of pci_request_regions() are wrong.
    I moved it just behind pci_enable_device() like other drivers,
    and it becomes fine.
    
    Signed-off-by: Ryoji Kamei <kamei@miraclelinux.com>
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>

diff --git a/drivers/scsi/dpt_i2o.c b/drivers/scsi/dpt_i2o.c
index cdeb30b0462e..6e6b293dcb28 100644
--- a/drivers/scsi/dpt_i2o.c
+++ b/drivers/scsi/dpt_i2o.c
@@ -899,6 +899,12 @@ static int adpt_install_hba(struct scsi_host_template* sht, struct pci_dev* pDev
 	if(pci_enable_device(pDev)) {
 		return -EINVAL;
 	}
+
+	if (pci_request_regions(pDev, "dpt_i2o")) {
+		PERROR("dpti: adpt_config_hba: pci request region failed\n");
+		return -EINVAL;
+	}
+
 	pci_set_master(pDev);
 	if (pci_set_dma_mask(pDev, 0xffffffffffffffffULL) &&
 	    pci_set_dma_mask(pDev, 0xffffffffULL))
@@ -924,10 +930,6 @@ static int adpt_install_hba(struct scsi_host_template* sht, struct pci_dev* pDev
 		raptorFlag = TRUE;
 	}
 
-	if (pci_request_regions(pDev, "dpt_i2o")) {
-		PERROR("dpti: adpt_config_hba: pci request region failed\n");
-		return -EINVAL;
-	}
 	base_addr_virt = ioremap(base_addr0_phys,hba_map0_area_size);
 	if (!base_addr_virt) {
 		pci_release_regions(pDev);

commit 0b9506723826c68b50fa33e345700ddcac1bed36
Author: Arjan van de Ven <arjan@infradead.org>
Date:   Wed Jan 11 13:16:10 2006 +0100

    [SCSI] turn most scsi semaphores into mutexes
    
    the scsi layer is using semaphores in a mutex way, this patch converts
    these into using mutexes instead
    
    Signed-off-by: Arjan van de Ven <arjan@infradead.org>
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>

diff --git a/drivers/scsi/dpt_i2o.c b/drivers/scsi/dpt_i2o.c
index 6252b9ddc01e..cdeb30b0462e 100644
--- a/drivers/scsi/dpt_i2o.c
+++ b/drivers/scsi/dpt_i2o.c
@@ -61,6 +61,7 @@ MODULE_DESCRIPTION("Adaptec I2O RAID Driver");
 #include <linux/timer.h>
 #include <linux/string.h>
 #include <linux/ioport.h>
+#include <linux/mutex.h>
 
 #include <asm/processor.h>	/* for boot_cpu_data */
 #include <asm/pgtable.h>
@@ -106,7 +107,7 @@ static dpt_sig_S DPTI_sig = {
  *============================================================================
  */
 
-static DECLARE_MUTEX(adpt_configuration_lock);
+static DEFINE_MUTEX(adpt_configuration_lock);
 
 static struct i2o_sys_tbl *sys_tbl = NULL;
 static int sys_tbl_ind = 0;
@@ -537,13 +538,13 @@ static int adpt_proc_info(struct Scsi_Host *host, char *buffer, char **start, of
 	 */
 
 	// Find HBA (host bus adapter) we are looking for
-	down(&adpt_configuration_lock);
+	mutex_lock(&adpt_configuration_lock);
 	for (pHba = hba_chain; pHba; pHba = pHba->next) {
 		if (pHba->host == host) {
 			break;	/* found adapter */
 		}
 	}
-	up(&adpt_configuration_lock);
+	mutex_unlock(&adpt_configuration_lock);
 	if (pHba == NULL) {
 		return 0;
 	}
@@ -958,7 +959,7 @@ static int adpt_install_hba(struct scsi_host_template* sht, struct pci_dev* pDev
 	}
 	memset(pHba, 0, sizeof(adpt_hba));
 
-	down(&adpt_configuration_lock);
+	mutex_lock(&adpt_configuration_lock);
 
 	if(hba_chain != NULL){
 		for(p = hba_chain; p->next; p = p->next);
@@ -971,7 +972,7 @@ static int adpt_install_hba(struct scsi_host_template* sht, struct pci_dev* pDev
 	sprintf(pHba->name, "dpti%d", hba_count);
 	hba_count++;
 	
-	up(&adpt_configuration_lock);
+	mutex_unlock(&adpt_configuration_lock);
 
 	pHba->pDev = pDev;
 	pHba->base_addr_phys = base_addr0_phys;
@@ -1027,7 +1028,7 @@ static void adpt_i2o_delete_hba(adpt_hba* pHba)
 	struct adpt_device* pNext;
 
 
-	down(&adpt_configuration_lock);
+	mutex_lock(&adpt_configuration_lock);
 	// scsi_unregister calls our adpt_release which
 	// does a quiese
 	if(pHba->host){
@@ -1046,7 +1047,7 @@ static void adpt_i2o_delete_hba(adpt_hba* pHba)
 	}
 
 	hba_count--;
-	up(&adpt_configuration_lock);
+	mutex_unlock(&adpt_configuration_lock);
 
 	iounmap(pHba->base_addr_virt);
 	pci_release_regions(pHba->pDev);
@@ -1549,7 +1550,7 @@ static int adpt_i2o_parse_lct(adpt_hba* pHba)
  
 static int adpt_i2o_install_device(adpt_hba* pHba, struct i2o_device *d)
 {
-	down(&adpt_configuration_lock);
+	mutex_lock(&adpt_configuration_lock);
 	d->controller=pHba;
 	d->owner=NULL;
 	d->next=pHba->devices;
@@ -1560,7 +1561,7 @@ static int adpt_i2o_install_device(adpt_hba* pHba, struct i2o_device *d)
 	pHba->devices=d;
 	*d->dev_name = 0;
 
-	up(&adpt_configuration_lock);
+	mutex_unlock(&adpt_configuration_lock);
 	return 0;
 }
 
@@ -1575,24 +1576,24 @@ static int adpt_open(struct inode *inode, struct file *file)
 	if (minor >= hba_count) {
 		return -ENXIO;
 	}
-	down(&adpt_configuration_lock);
+	mutex_lock(&adpt_configuration_lock);
 	for (pHba = hba_chain; pHba; pHba = pHba->next) {
 		if (pHba->unit == minor) {
 			break;	/* found adapter */
 		}
 	}
 	if (pHba == NULL) {
-		up(&adpt_configuration_lock);
+		mutex_unlock(&adpt_configuration_lock);
 		return -ENXIO;
 	}
 
 //	if(pHba->in_use){
-	//	up(&adpt_configuration_lock);
+	//	mutex_unlock(&adpt_configuration_lock);
 //		return -EBUSY;
 //	}
 
 	pHba->in_use = 1;
-	up(&adpt_configuration_lock);
+	mutex_unlock(&adpt_configuration_lock);
 
 	return 0;
 }
@@ -1606,13 +1607,13 @@ static int adpt_close(struct inode *inode, struct file *file)
 	if (minor >= hba_count) {
 		return -ENXIO;
 	}
-	down(&adpt_configuration_lock);
+	mutex_lock(&adpt_configuration_lock);
 	for (pHba = hba_chain; pHba; pHba = pHba->next) {
 		if (pHba->unit == minor) {
 			break;	/* found adapter */
 		}
 	}
-	up(&adpt_configuration_lock);
+	mutex_unlock(&adpt_configuration_lock);
 	if (pHba == NULL) {
 		return -ENXIO;
 	}
@@ -1910,13 +1911,13 @@ static int adpt_ioctl(struct inode *inode, struct file *file, uint cmd,
 	if (minor >= DPTI_MAX_HBA){
 		return -ENXIO;
 	}
-	down(&adpt_configuration_lock);
+	mutex_lock(&adpt_configuration_lock);
 	for (pHba = hba_chain; pHba; pHba = pHba->next) {
 		if (pHba->unit == minor) {
 			break;	/* found adapter */
 		}
 	}
-	up(&adpt_configuration_lock);
+	mutex_unlock(&adpt_configuration_lock);
 	if(pHba == NULL){
 		return -ENXIO;
 	}

commit e5508c13ac25b07585229b144a45cf64a990171e
Author: Salyzyn, Mark <mark_salyzyn@adaptec.com>
Date:   Sat Dec 17 19:26:30 2005 -0800

    [PATCH] dpt_i2o fix for deadlock condition
    
    Miquel van Smoorenburg <miquels@cistron.nl> forwarded me this fix to
    resolve a deadlock condition that occurs due to the API change in
    2.6.13+ kernels dropping the host locking when entering the error
    handling.  They all end up calling adpt_i2o_post_wait(), which if you
    call it unlocked, might return with host_lock locked anyway and that
    causes a deadlock.
    
    Signed-off-by: Mark Salyzyn <aacraid@adaptec.com>
    Cc: James Bottomley <James.Bottomley@steeleye.com>
    Cc: <stable@kernel.org>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/drivers/scsi/dpt_i2o.c b/drivers/scsi/dpt_i2o.c
index 418fc7b896ac..6252b9ddc01e 100644
--- a/drivers/scsi/dpt_i2o.c
+++ b/drivers/scsi/dpt_i2o.c
@@ -660,7 +660,12 @@ static int adpt_abort(struct scsi_cmnd * cmd)
 	msg[2] = 0;
 	msg[3]= 0; 
 	msg[4] = (u32)cmd;
-	if( (rcode = adpt_i2o_post_wait(pHba, msg, sizeof(msg), FOREVER)) != 0){
+	if (pHba->host)
+		spin_lock_irq(pHba->host->host_lock);
+	rcode = adpt_i2o_post_wait(pHba, msg, sizeof(msg), FOREVER);
+	if (pHba->host)
+		spin_unlock_irq(pHba->host->host_lock);
+	if (rcode != 0) {
 		if(rcode == -EOPNOTSUPP ){
 			printk(KERN_INFO"%s: Abort cmd not supported\n",pHba->name);
 			return FAILED;
@@ -697,10 +702,15 @@ static int adpt_device_reset(struct scsi_cmnd* cmd)
 	msg[2] = 0;
 	msg[3] = 0;
 
+	if (pHba->host)
+		spin_lock_irq(pHba->host->host_lock);
 	old_state = d->state;
 	d->state |= DPTI_DEV_RESET;
-	if( (rcode = adpt_i2o_post_wait(pHba, msg,sizeof(msg), FOREVER)) ){
-		d->state = old_state;
+	rcode = adpt_i2o_post_wait(pHba, msg,sizeof(msg), FOREVER);
+	d->state = old_state;
+	if (pHba->host)
+		spin_unlock_irq(pHba->host->host_lock);
+	if (rcode != 0) {
 		if(rcode == -EOPNOTSUPP ){
 			printk(KERN_INFO"%s: Device reset not supported\n",pHba->name);
 			return FAILED;
@@ -708,7 +718,6 @@ static int adpt_device_reset(struct scsi_cmnd* cmd)
 		printk(KERN_INFO"%s: Device reset failed\n",pHba->name);
 		return FAILED;
 	} else {
-		d->state = old_state;
 		printk(KERN_INFO"%s: Device reset successful\n",pHba->name);
 		return SUCCESS;
 	}
@@ -721,6 +730,7 @@ static int adpt_bus_reset(struct scsi_cmnd* cmd)
 {
 	adpt_hba* pHba;
 	u32 msg[4];
+	u32 rcode;
 
 	pHba = (adpt_hba*)cmd->device->host->hostdata[0];
 	memset(msg, 0, sizeof(msg));
@@ -729,7 +739,12 @@ static int adpt_bus_reset(struct scsi_cmnd* cmd)
 	msg[1] = (I2O_HBA_BUS_RESET<<24|HOST_TID<<12|pHba->channel[cmd->device->channel].tid);
 	msg[2] = 0;
 	msg[3] = 0;
-	if(adpt_i2o_post_wait(pHba, msg,sizeof(msg), FOREVER) ){
+	if (pHba->host)
+		spin_lock_irq(pHba->host->host_lock);
+	rcode = adpt_i2o_post_wait(pHba, msg,sizeof(msg), FOREVER);
+	if (pHba->host)
+		spin_unlock_irq(pHba->host->host_lock);
+	if (rcode != 0) {
 		printk(KERN_WARNING"%s: Bus reset failed.\n",pHba->name);
 		return FAILED;
 	} else {

commit 458af5439fe7ae7d95ca14106844e61f0795166c
Author: Adrian Bunk <bunk@stusta.de>
Date:   Sun Nov 27 00:36:37 2005 +0100

    [PATCH] drivers/scsi/dpt_i2o.c: fix a NULL pointer dereference
    
    The Coverity checker spotted this obvious NULL pointer dereference.
    
    Signed-off-by: Adrian Bunk <bunk@stusta.de>
    Acked-by: Mark Salyzyn <mark_salyzyn@adaptec.com>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/drivers/scsi/dpt_i2o.c b/drivers/scsi/dpt_i2o.c
index c28e3aea1c3c..418fc7b896ac 100644
--- a/drivers/scsi/dpt_i2o.c
+++ b/drivers/scsi/dpt_i2o.c
@@ -816,7 +816,7 @@ static int adpt_hba_reset(adpt_hba* pHba)
 static void adpt_i2o_sys_shutdown(void)
 {
 	adpt_hba *pHba, *pNext;
-	struct adpt_i2o_post_wait_data *p1, *p2;
+	struct adpt_i2o_post_wait_data *p1, *old;
 
 	 printk(KERN_INFO"Shutting down Adaptec I2O controllers.\n");
 	 printk(KERN_INFO"   This could take a few minutes if there are many devices attached\n");
@@ -830,13 +830,14 @@ static void adpt_i2o_sys_shutdown(void)
 	}
 
 	/* Remove any timedout entries from the wait queue.  */
-	p2 = NULL;
 //	spin_lock_irqsave(&adpt_post_wait_lock, flags);
 	/* Nothing should be outstanding at this point so just
 	 * free them 
 	 */
-	for(p1 = adpt_post_wait_queue; p1; p2 = p1, p1 = p2->next) {
-		kfree(p1);
+	for(p1 = adpt_post_wait_queue; p1;) {
+		old = p1;
+		p1 = p1->next;
+		kfree(old);
 	}
 //	spin_unlock_irqrestore(&adpt_post_wait_lock, flags);
 	adpt_post_wait_queue = NULL;

commit c9475cb0c358ff0dd473544280d92482df491913
Author: Jesper Juhl <jesper.juhl@gmail.com>
Date:   Mon Nov 7 01:01:26 2005 -0800

    [PATCH] kfree cleanup: drivers/scsi
    
    This is the drivers/scsi/ part of the big kfree cleanup patch.
    
    Remove pointless checks for NULL prior to calling kfree() in drivers/scsi/.
    
    Signed-off-by: Jesper Juhl <jesper.juhl@gmail.com>
    Cc: James Bottomley <James.Bottomley@steeleye.com>
    Acked-by: Kai Makisara <kai.makisara@kolumbus.fi>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/drivers/scsi/dpt_i2o.c b/drivers/scsi/dpt_i2o.c
index 46d5571ec55a..c28e3aea1c3c 100644
--- a/drivers/scsi/dpt_i2o.c
+++ b/drivers/scsi/dpt_i2o.c
@@ -1037,18 +1037,10 @@ static void adpt_i2o_delete_hba(adpt_hba* pHba)
 	if(pHba->msg_addr_virt != pHba->base_addr_virt){
 		iounmap(pHba->msg_addr_virt);
 	}
-	if(pHba->hrt) {
-		kfree(pHba->hrt);
-	}
-	if(pHba->lct){
-		kfree(pHba->lct);
-	}
-	if(pHba->status_block) {
-		kfree(pHba->status_block);
-	}
-	if(pHba->reply_pool){
-		kfree(pHba->reply_pool);
-	}
+	kfree(pHba->hrt);
+	kfree(pHba->lct);
+	kfree(pHba->status_block);
+	kfree(pHba->reply_pool);
 
 	for(d = pHba->devices; d ; d = next){
 		next = d->next;
@@ -2706,14 +2698,12 @@ static s32 adpt_i2o_init_outbound_q(adpt_hba* pHba)
 	// If the command was successful, fill the fifo with our reply
 	// message packets
 	if(*status != 0x04 /*I2O_EXEC_OUTBOUND_INIT_COMPLETE*/) {
-		kfree((void*)status);
+		kfree(status);
 		return -2;
 	}
-	kfree((void*)status);
+	kfree(status);
 
-	if(pHba->reply_pool != NULL){
-		kfree(pHba->reply_pool);
-	}
+	kfree(pHba->reply_pool);
 
 	pHba->reply_pool = (u32*)kmalloc(pHba->reply_fifo_size * REPLY_FRAME_SIZE * 4, GFP_KERNEL|ADDR32);
 	if(!pHba->reply_pool){
@@ -2929,8 +2919,7 @@ static int adpt_i2o_build_sys_table(void)
 	sys_tbl_len = sizeof(struct i2o_sys_tbl) +	// Header + IOPs
 				(hba_count) * sizeof(struct i2o_sys_tbl_entry);
 
-	if(sys_tbl)
-		kfree(sys_tbl);
+	kfree(sys_tbl);
 
 	sys_tbl = kmalloc(sys_tbl_len, GFP_KERNEL|ADDR32);
 	if(!sys_tbl) {

commit a9a3047dd8ae43ff24caae5ec733a93df129568e
Author: Nishanth Aravamudan <nacc@us.ibm.com>
Date:   Mon Nov 7 01:01:20 2005 -0800

    [PATCH] drivers/scsi: fix-up schedule_timeout() usage
    
    Use schedule_timeout_uninterruptible() instead of
    set_current_state()/schedule_timeout() to reduce kernel size.
    
    Signed-off-by: Nishanth Aravamudan <nacc@us.ibm.com>
    Cc: James Bottomley <James.Bottomley@steeleye.com>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/drivers/scsi/dpt_i2o.c b/drivers/scsi/dpt_i2o.c
index 7235f94f1191..46d5571ec55a 100644
--- a/drivers/scsi/dpt_i2o.c
+++ b/drivers/scsi/dpt_i2o.c
@@ -1218,8 +1218,7 @@ static s32 adpt_i2o_post_this(adpt_hba* pHba, u32* data, int len)
 			printk(KERN_WARNING"dpti%d: Timeout waiting for message frame!\n", pHba->unit);
 			return -ETIMEDOUT;
 		}
-		set_current_state(TASK_UNINTERRUPTIBLE);
-		schedule_timeout(1);
+		schedule_timeout_uninterruptible(1);
 	} while(m == EMPTY_QUEUE);
 		
 	msg = pHba->msg_addr_virt + m;
@@ -1294,8 +1293,7 @@ static s32 adpt_i2o_reset_hba(adpt_hba* pHba)
 			printk(KERN_WARNING"Timeout waiting for message!\n");
 			return -ETIMEDOUT;
 		}
-		set_current_state(TASK_UNINTERRUPTIBLE);
-		schedule_timeout(1);
+		schedule_timeout_uninterruptible(1);
 	} while (m == EMPTY_QUEUE);
 
 	status = (u8*)kmalloc(4, GFP_KERNEL|ADDR32);
@@ -1327,8 +1325,7 @@ static s32 adpt_i2o_reset_hba(adpt_hba* pHba)
 			return -ETIMEDOUT;
 		}
 		rmb();
-		set_current_state(TASK_UNINTERRUPTIBLE);
-		schedule_timeout(1);
+		schedule_timeout_uninterruptible(1);
 	}
 
 	if(*status == 0x01 /*I2O_EXEC_IOP_RESET_IN_PROGRESS*/) {
@@ -1345,8 +1342,7 @@ static s32 adpt_i2o_reset_hba(adpt_hba* pHba)
 				printk(KERN_ERR "%s:Timeout waiting for IOP Reset.\n",pHba->name);
 				return -ETIMEDOUT;
 			}
-			set_current_state(TASK_UNINTERRUPTIBLE);
-			schedule_timeout(1);
+			schedule_timeout_uninterruptible(1);
 		} while (m == EMPTY_QUEUE);
 		// Flush the offset
 		adpt_send_nop(pHba, m);
@@ -1917,11 +1913,8 @@ static int adpt_ioctl(struct inode *inode, struct file *file, uint cmd,
 		return -ENXIO;
 	}
 
-	while((volatile u32) pHba->state & DPTI_STATE_RESET ) {
-		set_task_state(current,TASK_UNINTERRUPTIBLE);
-		schedule_timeout(2);
-
-	}
+	while((volatile u32) pHba->state & DPTI_STATE_RESET )
+		schedule_timeout_uninterruptible(2);
 
 	switch (cmd) {
 	// TODO: handle 3 cases
@@ -2635,8 +2628,7 @@ static s32 adpt_send_nop(adpt_hba*pHba,u32 m)
 			printk(KERN_ERR "%s: Timeout waiting for message frame!\n",pHba->name);
 			return 2;
 		}
-		set_current_state(TASK_UNINTERRUPTIBLE);
-		schedule_timeout(1);
+		schedule_timeout_uninterruptible(1);
 	}
 	msg = (u32 __iomem *)(pHba->msg_addr_virt + m);
 	writel( THREE_WORD_MSG_SIZE | SGL_OFFSET_0,&msg[0]);
@@ -2670,8 +2662,7 @@ static s32 adpt_i2o_init_outbound_q(adpt_hba* pHba)
 			printk(KERN_WARNING"%s: Timeout waiting for message frame\n",pHba->name);
 			return -ETIMEDOUT;
 		}
-		set_current_state(TASK_UNINTERRUPTIBLE);
-		schedule_timeout(1);
+		schedule_timeout_uninterruptible(1);
 	} while(m == EMPTY_QUEUE);
 
 	msg=(u32 __iomem *)(pHba->msg_addr_virt+m);
@@ -2709,8 +2700,7 @@ static s32 adpt_i2o_init_outbound_q(adpt_hba* pHba)
 			printk(KERN_WARNING"%s: Timeout Initializing\n",pHba->name);
 			return -ETIMEDOUT;
 		}
-		set_current_state(TASK_UNINTERRUPTIBLE);
-		schedule_timeout(1);
+		schedule_timeout_uninterruptible(1);
 	} while (1);
 
 	// If the command was successful, fill the fifo with our reply
@@ -2788,8 +2778,7 @@ static s32 adpt_i2o_status_get(adpt_hba* pHba)
 					pHba->name);
 			return -ETIMEDOUT;
 		}
-		set_current_state(TASK_UNINTERRUPTIBLE);
-		schedule_timeout(1);
+		schedule_timeout_uninterruptible(1);
 	} while(m==EMPTY_QUEUE);
 
 	
@@ -2816,8 +2805,7 @@ static s32 adpt_i2o_status_get(adpt_hba* pHba)
 			return -ETIMEDOUT;
 		}
 		rmb();
-		set_current_state(TASK_UNINTERRUPTIBLE);
-		schedule_timeout(1);
+		schedule_timeout_uninterruptible(1);
 	}
 
 	// Set up our number of outbound and inbound messages

commit 5bb8345db8f2aef367e0fddf99a42b7a6029b31f
Author: Salyzyn, Mark <mark_salyzyn@adaptec.com>
Date:   Tue Aug 9 12:57:58 2005 -0400

    [SCSI] dpt_i2o pci_request_regions fix
    
    Originally From: Andrew Morton <akpm@osdl.org>
    
    Altered By: "Salyzyn, Mark" <mark_salyzyn@adaptec.com>
    
    There is an additional 'build fix' patch that Andrew Morton submitted on
    the kernel list (I have changed out his dpr_i2o with dpt_i2o below
    though).
    
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>

diff --git a/drivers/scsi/dpt_i2o.c b/drivers/scsi/dpt_i2o.c
index bc7b84c95db6..7235f94f1191 100644
--- a/drivers/scsi/dpt_i2o.c
+++ b/drivers/scsi/dpt_i2o.c
@@ -907,7 +907,7 @@ static int adpt_install_hba(struct scsi_host_template* sht, struct pci_dev* pDev
 		raptorFlag = TRUE;
 	}
 
-	if (pci_request_regions(pDev)) {
+	if (pci_request_regions(pDev, "dpt_i2o")) {
 		PERROR("dpti: adpt_config_hba: pci request region failed\n");
 		return -EINVAL;
 	}

commit 9c472dd9197429a37691e91c938660a062bf20b0
Author: James Bottomley <jejb@mulgrave.(none)>
Date:   Mon Aug 8 11:51:38 2005 -0500

    [SCSI] Bug 4940 Repeatable Kernel Panic on Adaptec 2015S I20 device on bootup
    
    From: "Salyzyn, Mark" <mark_salyzyn@adaptec.com>
    
    Prevent driver from loading if another driver (i2o) has already claimed
    the resources associated with the card. Discussion associated with this
    bug can be referenced at http://bugzilla.kernel.org/show_bug.cgi?id=4940
    where it was agreed to use pci_request_regions in both the dpt_i2o and
    the i2o driver to prevent both drivers loading on the same adapter(s).
    
    Signed-off-by: Mark Salyzyn <aacraid@adaptec.com>
    
    Rejections fixed up and
    
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>

diff --git a/drivers/scsi/dpt_i2o.c b/drivers/scsi/dpt_i2o.c
index e2370529c632..bc7b84c95db6 100644
--- a/drivers/scsi/dpt_i2o.c
+++ b/drivers/scsi/dpt_i2o.c
@@ -907,9 +907,13 @@ static int adpt_install_hba(struct scsi_host_template* sht, struct pci_dev* pDev
 		raptorFlag = TRUE;
 	}
 
-
+	if (pci_request_regions(pDev)) {
+		PERROR("dpti: adpt_config_hba: pci request region failed\n");
+		return -EINVAL;
+	}
 	base_addr_virt = ioremap(base_addr0_phys,hba_map0_area_size);
 	if (!base_addr_virt) {
+		pci_release_regions(pDev);
 		PERROR("dpti: adpt_config_hba: io remap failed\n");
 		return -EINVAL;
 	}
@@ -919,6 +923,7 @@ static int adpt_install_hba(struct scsi_host_template* sht, struct pci_dev* pDev
 		if (!msg_addr_virt) {
 			PERROR("dpti: adpt_config_hba: io remap failed on BAR1\n");
 			iounmap(base_addr_virt);
+			pci_release_regions(pDev);
 			return -EINVAL;
 		}
 	} else {
@@ -932,6 +937,7 @@ static int adpt_install_hba(struct scsi_host_template* sht, struct pci_dev* pDev
 			iounmap(msg_addr_virt);
 		}
 		iounmap(base_addr_virt);
+		pci_release_regions(pDev);
 		return -ENOMEM;
 	}
 	memset(pHba, 0, sizeof(adpt_hba));
@@ -1027,6 +1033,7 @@ static void adpt_i2o_delete_hba(adpt_hba* pHba)
 	up(&adpt_configuration_lock);
 
 	iounmap(pHba->base_addr_virt);
+	pci_release_regions(pHba->pDev);
 	if(pHba->msg_addr_virt != pHba->base_addr_virt){
 		iounmap(pHba->msg_addr_virt);
 	}

commit a5990120252539bccdaf70a66ac021966e80e3f7
Author: Andrew Morton <akpm@osdl.org>
Date:   Sat Jul 9 01:30:02 2005 -0700

    [SCSI] dpt_i2o warning fix
    
    drivers/scsi/dpt_i2o.c: In function `adpt_queue':
    drivers/scsi/dpt_i2o.c:385: warning: unused variable `timeout'
    
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>

diff --git a/drivers/scsi/dpt_i2o.c b/drivers/scsi/dpt_i2o.c
index c2604e88d3b0..e2370529c632 100644
--- a/drivers/scsi/dpt_i2o.c
+++ b/drivers/scsi/dpt_i2o.c
@@ -382,7 +382,6 @@ static int adpt_queue(struct scsi_cmnd * cmd, void (*done) (struct scsi_cmnd *))
 {
 	adpt_hba* pHba = NULL;
 	struct adpt_device* pDev = NULL;	/* dpt per device information */
-	ulong timeout = jiffies + (TMOUT_SCSI*HZ);
 
 	cmd->scsi_done = done;
 	/*

commit a4c8f6285165a7089edb2010dbd894148ca95d57
Author: Christoph Hellwig <hch@lst.de>
Date:   Sun Jun 19 13:39:23 2005 +0200

    [SCSI] remove scsi_cmnd.eh_state
    
    it's never set to anything, and just three broken drivers are looking
    at it and doing odd things.
    
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>

diff --git a/drivers/scsi/dpt_i2o.c b/drivers/scsi/dpt_i2o.c
index bbe346bd3cb8..c2604e88d3b0 100644
--- a/drivers/scsi/dpt_i2o.c
+++ b/drivers/scsi/dpt_i2o.c
@@ -418,11 +418,6 @@ static int adpt_queue(struct scsi_cmnd * cmd, void (*done) (struct scsi_cmnd *))
 		return 1;
 	}
 
-	if(cmd->eh_state != SCSI_STATE_QUEUED){
-		// If we are not doing error recovery
-		mod_timer(&cmd->eh_timeout, timeout);
-	}
-
 	// TODO if the cmd->device if offline then I may need to issue a bus rescan
 	// followed by a get_lct to see if the device is there anymore
 	if((pDev = (struct adpt_device*) (cmd->device->hostdata)) == NULL) {

commit a4cd16e2e8f0924d8e3a2391edc51556cad26d99
Author: Adrian Bunk <bunk@stusta.de>
Date:   Sat Jun 25 14:59:01 2005 -0700

    [PATCH] drivers/scsi/dpt*: remove version.h dependencies
    
    This patch removes version.h dependencies.
    
    Signed-off-by: Adrian Bunk <bunk@stusta.de>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/drivers/scsi/dpt_i2o.c b/drivers/scsi/dpt_i2o.c
index a699c30b2662..bbe346bd3cb8 100644
--- a/drivers/scsi/dpt_i2o.c
+++ b/drivers/scsi/dpt_i2o.c
@@ -34,7 +34,6 @@
 
 #define ADDR32 (0)
 
-#include <linux/version.h>
 #include <linux/module.h>
 
 MODULE_AUTHOR("Deanna Bonds, with _lots_ of help from Mark Salyzyn");
@@ -1811,9 +1810,9 @@ static int adpt_system_info(void __user *buffer)
 	memset(&si, 0, sizeof(si));
 
 	si.osType = OS_LINUX;
-	si.osMajorVersion = (u8) (LINUX_VERSION_CODE >> 16);
-	si.osMinorVersion = (u8) (LINUX_VERSION_CODE >> 8 & 0x0ff);
-	si.osRevision =     (u8) (LINUX_VERSION_CODE & 0x0ff);
+	si.osMajorVersion = 0;
+	si.osMinorVersion = 0;
+	si.osRevision = 0;
 	si.busType = SI_PCI_BUS;
 	si.processorFamily = DPTI_sig.dsProcessorFamily;
 

commit 4452ea509e29df2f019bed2f7a1e0f5eea092b26
Author: Andrew Morton <akpm@osdl.org>
Date:   Thu Jun 23 00:10:26 2005 -0700

    [PATCH] dpt_i2o: fix waitqueue abuse
    
    The driver plays with waitqueue internals and fails to compile after Ben's
    "aio: make wait_queue ->task ->private" patch.
    
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/drivers/scsi/dpt_i2o.c b/drivers/scsi/dpt_i2o.c
index 9cc0015b717d..a699c30b2662 100644
--- a/drivers/scsi/dpt_i2o.c
+++ b/drivers/scsi/dpt_i2o.c
@@ -1126,11 +1126,11 @@ static int adpt_i2o_post_wait(adpt_hba* pHba, u32* msg, int len, int timeout)
 	struct adpt_i2o_post_wait_data *p1, *p2;
 	struct adpt_i2o_post_wait_data *wait_data =
 		kmalloc(sizeof(struct adpt_i2o_post_wait_data),GFP_KERNEL);
-	adpt_wait_queue_t wait;
+	DECLARE_WAITQUEUE(wait, current);
 
-	if(!wait_data){
+	if (!wait_data)
 		return -ENOMEM;
-	}
+
 	/*
 	 * The spin locking is needed to keep anyone from playing
 	 * with the queue pointers and id while we do the same
@@ -1148,12 +1148,7 @@ static int adpt_i2o_post_wait(adpt_hba* pHba, u32* msg, int len, int timeout)
 	wait_data->wq = &adpt_wq_i2o_post;
 	wait_data->status = -ETIMEDOUT;
 
-	// this code is taken from kernel/sched.c:interruptible_sleep_on_timeout
-	wait.task = current;
-	init_waitqueue_entry(&wait, current);
-	spin_lock_irqsave(&adpt_wq_i2o_post.lock, flags);
-	__add_wait_queue(&adpt_wq_i2o_post, &wait);
-	spin_unlock(&adpt_wq_i2o_post.lock);
+	add_wait_queue(&adpt_wq_i2o_post, &wait);
 
 	msg[2] |= 0x80000000 | ((u32)wait_data->id);
 	timeout *= HZ;
@@ -1175,9 +1170,7 @@ static int adpt_i2o_post_wait(adpt_hba* pHba, u32* msg, int len, int timeout)
 		if(pHba->host)
 			spin_lock_irq(pHba->host->host_lock);
 	}
-	spin_lock_irq(&adpt_wq_i2o_post.lock);
-	__remove_wait_queue(&adpt_wq_i2o_post, &wait);
-	spin_unlock_irqrestore(&adpt_wq_i2o_post.lock, flags);
+	remove_wait_queue(&adpt_wq_i2o_post, &wait);
 
 	if(status == -ETIMEDOUT){
 		printk(KERN_INFO"dpti%d: POST WAIT TIMEOUT\n",pHba->unit);

commit df0ae2497ddefd72a87f3a3b34ff32455d7d4ae0
Author: Jeff Garzik <jgarzik@pobox.com>
Date:   Sat May 28 07:57:14 2005 -0400

    [SCSI] allow sleeping in ->eh_host_reset_handler()
    
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>

diff --git a/drivers/scsi/dpt_i2o.c b/drivers/scsi/dpt_i2o.c
index 2fd728731d5e..9cc0015b717d 100644
--- a/drivers/scsi/dpt_i2o.c
+++ b/drivers/scsi/dpt_i2o.c
@@ -746,7 +746,7 @@ static int adpt_bus_reset(struct scsi_cmnd* cmd)
 }
 
 // This version of reset is called by the eh_error_handler
-static int adpt_reset(struct scsi_cmnd* cmd)
+static int __adpt_reset(struct scsi_cmnd* cmd)
 {
 	adpt_hba* pHba;
 	int rcode;
@@ -762,6 +762,17 @@ static int adpt_reset(struct scsi_cmnd* cmd)
 	}
 }
 
+static int adpt_reset(struct scsi_cmnd* cmd)
+{
+	int rc;
+
+	spin_lock_irq(cmd->device->host->host_lock);
+	rc = __adpt_reset(cmd);
+	spin_unlock_irq(cmd->device->host->host_lock);
+
+	return rc;
+}
+
 // This version of reset is called by the ioctls and indirectly from eh_error_handler via adpt_reset
 static int adpt_hba_reset(adpt_hba* pHba)
 {

commit 1c2fb3f38e250dd3b88612435869acf92b4f51e2
Author: Benoit Boissinot <benoit.boissinot@ens-lyon.org>
Date:   Mon Apr 25 19:46:48 2005 -0700

    [SCSI] drivers/scsi/dpt_i2o.c: fix compile warnings
    
    This patch fixes the following warnings:
    
    drivers/scsi/dpt_i2o.c: In function adpt_isr:
    drivers/scsi/dpt_i2o.c:2030: warning: passing argument 1 of readl makes pointer from integer without a cast
    drivers/scsi/dpt_i2o.c:2031: warning: passing argument 1 of readl makes pointer from integer without a cast
    drivers/scsi/dpt_i2o.c:2042: warning: passing argument 1 of readl makes pointer from integer without a cast
    drivers/scsi/dpt_i2o.c:2043: warning: passing argument 2 of writel makes pointer from integer without a cast
    drivers/scsi/dpt_i2o.c:2046: warning: passing argument 1 of readl makes pointer from integer without a cast
    drivers/scsi/dpt_i2o.c:2048: warning: passing argument 1 of readl makes pointer from integer without a cast
    drivers/scsi/dpt_i2o.c:2055: warning: passing argument 1 of readl makes pointer from integer without a cast
    drivers/scsi/dpt_i2o.c:2062: warning: passing argument 1 of readl makes pointer from integer without a cast
    drivers/scsi/dpt_i2o.c:2069: warning: passing argument 1 of readl makes pointer from integer without a cast
    drivers/scsi/dpt_i2o.c: In function adpt_i2o_to_scsi: drivers/scsi/dpt_i2o.c:2239: warning: passing argument 1 of readl makes pointer from integer without a cast
    drivers/scsi/dpt_i2o.c:2243: warning: passing argument 1 of readl makes pointer from integer without a cast
    drivers/scsi/dpt_i2o.c:2248: warning: passing argument 1 of readl makes pointer from integer without a cast
    drivers/scsi/dpt_i2o.c:2259: warning: passing argument 1 of readl makes pointer from integer without a cast
    
    It define variables which are only used with a type of 'void __iomem *'
    with this type instead of the incorrect 'unsigned long' type.
    It also remove pointless casts.
    
    Signed-off-by: Benoit Boissinot <benoit.boissinot@ens-lyon.org>
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>

diff --git a/drivers/scsi/dpt_i2o.c b/drivers/scsi/dpt_i2o.c
index 973f97dd474c..2fd728731d5e 100644
--- a/drivers/scsi/dpt_i2o.c
+++ b/drivers/scsi/dpt_i2o.c
@@ -690,7 +690,7 @@ static int adpt_device_reset(struct scsi_cmnd* cmd)
 	u32 msg[4];
 	u32 rcode;
 	int old_state;
-	struct adpt_device* d = (void*) cmd->device->hostdata;
+	struct adpt_device* d = cmd->device->hostdata;
 
 	pHba = (void*) cmd->device->host->hostdata[0];
 	printk(KERN_INFO"%s: Trying to reset device\n",pHba->name);
@@ -706,7 +706,7 @@ static int adpt_device_reset(struct scsi_cmnd* cmd)
 
 	old_state = d->state;
 	d->state |= DPTI_DEV_RESET;
-	if( (rcode = adpt_i2o_post_wait(pHba, (void*)msg,sizeof(msg), FOREVER)) ){
+	if( (rcode = adpt_i2o_post_wait(pHba, msg,sizeof(msg), FOREVER)) ){
 		d->state = old_state;
 		if(rcode == -EOPNOTSUPP ){
 			printk(KERN_INFO"%s: Device reset not supported\n",pHba->name);
@@ -736,7 +736,7 @@ static int adpt_bus_reset(struct scsi_cmnd* cmd)
 	msg[1] = (I2O_HBA_BUS_RESET<<24|HOST_TID<<12|pHba->channel[cmd->device->channel].tid);
 	msg[2] = 0;
 	msg[3] = 0;
-	if(adpt_i2o_post_wait(pHba, (void*)msg,sizeof(msg), FOREVER) ){
+	if(adpt_i2o_post_wait(pHba, msg,sizeof(msg), FOREVER) ){
 		printk(KERN_WARNING"%s: Bus reset failed.\n",pHba->name);
 		return FAILED;
 	} else {
@@ -1436,7 +1436,7 @@ static int adpt_i2o_parse_lct(adpt_hba* pHba)
 			return -ENOMEM;
 		}
 		
-		d->controller = (void*)pHba;
+		d->controller = pHba;
 		d->next = NULL;
 
 		memcpy(&d->lct_data, &lct->lct_entry[i], sizeof(i2o_lct_entry));
@@ -1982,7 +1982,7 @@ static irqreturn_t adpt_isr(int irq, void *dev_id, struct pt_regs *regs)
 	struct scsi_cmnd* cmd;
 	adpt_hba* pHba = dev_id;
 	u32 m;
-	ulong reply;
+	void __iomem *reply;
 	u32 status=0;
 	u32 context;
 	ulong flags = 0;
@@ -2007,11 +2007,11 @@ static irqreturn_t adpt_isr(int irq, void *dev_id, struct pt_regs *regs)
 				goto out;
 			}
 		}
-		reply = (ulong)bus_to_virt(m);
+		reply = bus_to_virt(m);
 
 		if (readl(reply) & MSG_FAIL) {
 			u32 old_m = readl(reply+28); 
-			ulong msg;
+			void __iomem *msg;
 			u32 old_context;
 			PDEBUG("%s: Failed message\n",pHba->name);
 			if(old_m >= 0x100000){
@@ -2020,16 +2020,16 @@ static irqreturn_t adpt_isr(int irq, void *dev_id, struct pt_regs *regs)
 				continue;
 			}
 			// Transaction context is 0 in failed reply frame
-			msg = (ulong)(pHba->msg_addr_virt + old_m);
+			msg = pHba->msg_addr_virt + old_m;
 			old_context = readl(msg+12);
 			writel(old_context, reply+12);
 			adpt_send_nop(pHba, old_m);
 		} 
 		context = readl(reply+8);
 		if(context & 0x40000000){ // IOCTL
-			ulong p = (ulong)(readl(reply+12));
-			if( p != 0) {
-				memcpy((void*)p, (void*)reply, REPLY_FRAME_SIZE * 4);
+			void *p = (void *)readl(reply+12);
+			if( p != NULL) {
+				memcpy_fromio(p, reply, REPLY_FRAME_SIZE * 4);
 			}
 			// All IOCTLs will also be post wait
 		}
@@ -2213,7 +2213,7 @@ static s32 adpt_scsi_register(adpt_hba* pHba,struct scsi_host_template * sht)
 }
 
 
-static s32 adpt_i2o_to_scsi(ulong reply, struct scsi_cmnd* cmd)
+static s32 adpt_i2o_to_scsi(void __iomem *reply, struct scsi_cmnd* cmd)
 {
 	adpt_hba* pHba;
 	u32 hba_status;
@@ -2305,7 +2305,7 @@ static s32 adpt_i2o_to_scsi(ulong reply, struct scsi_cmnd* cmd)
 			u32 len = sizeof(cmd->sense_buffer);
 			len = (len > 40) ?  40 : len;
 			// Copy over the sense data
-			memcpy(cmd->sense_buffer, (void*)(reply+28) , len);
+			memcpy_fromio(cmd->sense_buffer, (reply+28) , len);
 			if(cmd->sense_buffer[0] == 0x70 /* class 7 */ && 
 			   cmd->sense_buffer[2] == DATA_PROTECT ){
 				/* This is to handle an array failed */
@@ -2420,7 +2420,7 @@ static s32 adpt_i2o_reparse_lct(adpt_hba* pHba)
 					return -ENOMEM;
 				}
 				
-				d->controller = (void*)pHba;
+				d->controller = pHba;
 				d->next = NULL;
 
 				memcpy(&d->lct_data, &lct->lct_entry[i], sizeof(i2o_lct_entry));
@@ -2967,8 +2967,8 @@ static int adpt_i2o_build_sys_table(void)
 		sys_tbl->iops[count].frame_size = pHba->status_block->inbound_frame_size;
 		sys_tbl->iops[count].last_changed = sys_tbl_ind - 1; // ??
 		sys_tbl->iops[count].iop_capabilities = pHba->status_block->iop_capabilities;
-		sys_tbl->iops[count].inbound_low = (u32)virt_to_bus((void*)pHba->post_port);
-		sys_tbl->iops[count].inbound_high = (u32)((u64)virt_to_bus((void*)pHba->post_port)>>32);
+		sys_tbl->iops[count].inbound_low = (u32)virt_to_bus(pHba->post_port);
+		sys_tbl->iops[count].inbound_high = (u32)((u64)virt_to_bus(pHba->post_port)>>32);
 
 		count++;
 	}

commit 23a2bc2289ad3bbc41093c2b50a9c17b37b4d73d
Author: Benoit Boissinot <benoit.boissinot@ens-lyon.org>
Date:   Mon Apr 25 19:46:30 2005 -0700

    [SCSI] drivers/scsi/dpt_i2o.c: cleanup useless code
    
    This patch removes the array 'hbas' as it seems to be useless
    and redundant with the linked list hbas_chain.
    
    Signed-off-by: Benoit Boissinot <benoit.boissinot@ens-lyon.org>
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>

diff --git a/drivers/scsi/dpt_i2o.c b/drivers/scsi/dpt_i2o.c
index 53c9b93013f1..973f97dd474c 100644
--- a/drivers/scsi/dpt_i2o.c
+++ b/drivers/scsi/dpt_i2o.c
@@ -113,7 +113,6 @@ static struct i2o_sys_tbl *sys_tbl = NULL;
 static int sys_tbl_ind = 0;
 static int sys_tbl_len = 0;
 
-static adpt_hba* hbas[DPTI_MAX_HBA];
 static adpt_hba* hba_chain = NULL;
 static int hba_count = 0;
 
@@ -875,7 +874,6 @@ static int adpt_install_hba(struct scsi_host_template* sht, struct pci_dev* pDev
 	void __iomem *msg_addr_virt = NULL;
 
 	int raptorFlag = FALSE;
-	int i;
 
 	if(pci_enable_device(pDev)) {
 		return -EINVAL;
@@ -935,12 +933,6 @@ static int adpt_install_hba(struct scsi_host_template* sht, struct pci_dev* pDev
 	memset(pHba, 0, sizeof(adpt_hba));
 
 	down(&adpt_configuration_lock);
-	for(i=0;i<DPTI_MAX_HBA;i++) {
-		if(hbas[i]==NULL) {
-			hbas[i]=pHba;
-			break;
-		}
-	}
 
 	if(hba_chain != NULL){
 		for(p = hba_chain; p->next; p = p->next);
@@ -950,7 +942,7 @@ static int adpt_install_hba(struct scsi_host_template* sht, struct pci_dev* pDev
 	}
 	pHba->next = NULL;
 	pHba->unit = hba_count;
-	sprintf(pHba->name, "dpti%d", i);
+	sprintf(pHba->name, "dpti%d", hba_count);
 	hba_count++;
 	
 	up(&adpt_configuration_lock);
@@ -1015,11 +1007,6 @@ static void adpt_i2o_delete_hba(adpt_hba* pHba)
 	if(pHba->host){
 		free_irq(pHba->host->irq, pHba);
 	}
-	for(i=0;i<DPTI_MAX_HBA;i++) {
-		if(hbas[i]==pHba) {
-			hbas[i] = NULL;
-		}
-	}
 	p2 = NULL;
 	for( p1 = hba_chain; p1; p2 = p1,p1=p1->next){
 		if(p1 == pHba) {
@@ -1076,12 +1063,7 @@ static void adpt_i2o_delete_hba(adpt_hba* pHba)
 
 static int adpt_init(void)
 {
-	int i;
-
 	printk("Loading Adaptec I2O RAID: Version " DPT_I2O_VERSION "\n");
-	for (i = 0; i < DPTI_MAX_HBA; i++) {
-		hbas[i] = NULL;
-	}
 #ifdef REBOOT_NOTIFIER
 	register_reboot_notifier(&adpt_reboot_notifier);
 #endif

commit 1da177e4c3f41524e886b7f1b8a0c1fc7321cac2
Author: Linus Torvalds <torvalds@ppc970.osdl.org>
Date:   Sat Apr 16 15:20:36 2005 -0700

    Linux-2.6.12-rc2
    
    Initial git repository build. I'm not bothering with the full history,
    even though we have it. We can create a separate "historical" git
    archive of that later if we want to, and in the meantime it's about
    3.2GB when imported into git - space that would just make the early
    git days unnecessarily complicated, when we don't have a lot of good
    infrastructure for it.
    
    Let it rip!

diff --git a/drivers/scsi/dpt_i2o.c b/drivers/scsi/dpt_i2o.c
new file mode 100644
index 000000000000..53c9b93013f1
--- /dev/null
+++ b/drivers/scsi/dpt_i2o.c
@@ -0,0 +1,3381 @@
+/***************************************************************************
+                          dpti.c  -  description
+                             -------------------
+    begin                : Thu Sep 7 2000
+    copyright            : (C) 2000 by Adaptec
+
+			   July 30, 2001 First version being submitted
+			   for inclusion in the kernel.  V2.4
+
+    See Documentation/scsi/dpti.txt for history, notes, license info
+    and credits
+ ***************************************************************************/
+
+/***************************************************************************
+ *                                                                         *
+ *   This program is free software; you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation; either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ ***************************************************************************/
+/***************************************************************************
+ * Sat Dec 20 2003 Go Taniguchi <go@turbolinux.co.jp>
+ - Support 2.6 kernel and DMA-mapping
+ - ioctl fix for raid tools
+ - use schedule_timeout in long long loop
+ **************************************************************************/
+
+/*#define DEBUG 1 */
+/*#define UARTDELAY 1 */
+
+/* On the real kernel ADDR32 should always be zero for 2.4. GFP_HIGH allocates
+   high pages. Keep the macro around because of the broken unmerged ia64 tree */
+
+#define ADDR32 (0)
+
+#include <linux/version.h>
+#include <linux/module.h>
+
+MODULE_AUTHOR("Deanna Bonds, with _lots_ of help from Mark Salyzyn");
+MODULE_DESCRIPTION("Adaptec I2O RAID Driver");
+
+////////////////////////////////////////////////////////////////
+
+#include <linux/ioctl.h>	/* For SCSI-Passthrough */
+#include <asm/uaccess.h>
+
+#include <linux/stat.h>
+#include <linux/slab.h>		/* for kmalloc() */
+#include <linux/config.h>	/* for CONFIG_PCI */
+#include <linux/pci.h>		/* for PCI support */
+#include <linux/proc_fs.h>
+#include <linux/blkdev.h>
+#include <linux/delay.h>	/* for udelay */
+#include <linux/interrupt.h>
+#include <linux/kernel.h>	/* for printk */
+#include <linux/sched.h>
+#include <linux/reboot.h>
+#include <linux/spinlock.h>
+#include <linux/smp_lock.h>
+
+#include <linux/timer.h>
+#include <linux/string.h>
+#include <linux/ioport.h>
+
+#include <asm/processor.h>	/* for boot_cpu_data */
+#include <asm/pgtable.h>
+#include <asm/io.h>		/* for virt_to_bus, etc. */
+
+#include <scsi/scsi.h>
+#include <scsi/scsi_cmnd.h>
+#include <scsi/scsi_device.h>
+#include <scsi/scsi_host.h>
+#include <scsi/scsi_tcq.h>
+
+#include "dpt/dptsig.h"
+#include "dpti.h"
+
+/*============================================================================
+ * Create a binary signature - this is read by dptsig
+ * Needed for our management apps
+ *============================================================================
+ */
+static dpt_sig_S DPTI_sig = {
+	{'d', 'P', 't', 'S', 'i', 'G'}, SIG_VERSION,
+#ifdef __i386__
+	PROC_INTEL, PROC_386 | PROC_486 | PROC_PENTIUM | PROC_SEXIUM,
+#elif defined(__ia64__)
+	PROC_INTEL, PROC_IA64,
+#elif defined(__sparc__)
+	PROC_ULTRASPARC, PROC_ULTRASPARC,
+#elif defined(__alpha__)
+	PROC_ALPHA, PROC_ALPHA,
+#else
+	(-1),(-1),
+#endif
+	 FT_HBADRVR, 0, OEM_DPT, OS_LINUX, CAP_OVERLAP, DEV_ALL,
+	ADF_ALL_SC5, 0, 0, DPT_VERSION, DPT_REVISION, DPT_SUBREVISION,
+	DPT_MONTH, DPT_DAY, DPT_YEAR, "Adaptec Linux I2O RAID Driver"
+};
+
+
+
+
+/*============================================================================
+ * Globals
+ *============================================================================
+ */
+
+static DECLARE_MUTEX(adpt_configuration_lock);
+
+static struct i2o_sys_tbl *sys_tbl = NULL;
+static int sys_tbl_ind = 0;
+static int sys_tbl_len = 0;
+
+static adpt_hba* hbas[DPTI_MAX_HBA];
+static adpt_hba* hba_chain = NULL;
+static int hba_count = 0;
+
+static struct file_operations adpt_fops = {
+	.ioctl		= adpt_ioctl,
+	.open		= adpt_open,
+	.release	= adpt_close
+};
+
+#ifdef REBOOT_NOTIFIER
+static struct notifier_block adpt_reboot_notifier =
+{
+	 adpt_reboot_event,
+	 NULL,
+	 0
+};
+#endif
+
+/* Structures and definitions for synchronous message posting.
+ * See adpt_i2o_post_wait() for description
+ * */
+struct adpt_i2o_post_wait_data
+{
+	int status;
+	u32 id;
+	adpt_wait_queue_head_t *wq;
+	struct adpt_i2o_post_wait_data *next;
+};
+
+static struct adpt_i2o_post_wait_data *adpt_post_wait_queue = NULL;
+static u32 adpt_post_wait_id = 0;
+static DEFINE_SPINLOCK(adpt_post_wait_lock);
+
+
+/*============================================================================
+ * 				Functions
+ *============================================================================
+ */
+
+static u8 adpt_read_blink_led(adpt_hba* host)
+{
+	if(host->FwDebugBLEDflag_P != 0) {
+		if( readb(host->FwDebugBLEDflag_P) == 0xbc ){
+			return readb(host->FwDebugBLEDvalue_P);
+		}
+	}
+	return 0;
+}
+
+/*============================================================================
+ * Scsi host template interface functions
+ *============================================================================
+ */
+
+static struct pci_device_id dptids[] = {
+	{ PCI_DPT_VENDOR_ID, PCI_DPT_DEVICE_ID, PCI_ANY_ID, PCI_ANY_ID,},
+	{ PCI_DPT_VENDOR_ID, PCI_DPT_RAPTOR_DEVICE_ID, PCI_ANY_ID, PCI_ANY_ID,},
+	{ 0, }
+};
+MODULE_DEVICE_TABLE(pci,dptids);
+
+static int adpt_detect(struct scsi_host_template* sht)
+{
+	struct pci_dev *pDev = NULL;
+	adpt_hba* pHba;
+
+	adpt_init();
+
+	PINFO("Detecting Adaptec I2O RAID controllers...\n");
+
+        /* search for all Adatpec I2O RAID cards */
+	while ((pDev = pci_find_device( PCI_DPT_VENDOR_ID, PCI_ANY_ID, pDev))) {
+		if(pDev->device == PCI_DPT_DEVICE_ID ||
+		   pDev->device == PCI_DPT_RAPTOR_DEVICE_ID){
+			if(adpt_install_hba(sht, pDev) ){
+				PERROR("Could not Init an I2O RAID device\n");
+				PERROR("Will not try to detect others.\n");
+				return hba_count-1;
+			}
+		}
+	}
+
+	/* In INIT state, Activate IOPs */
+	for (pHba = hba_chain; pHba; pHba = pHba->next) {
+		// Activate does get status , init outbound, and get hrt
+		if (adpt_i2o_activate_hba(pHba) < 0) {
+			adpt_i2o_delete_hba(pHba);
+		}
+	}
+
+
+	/* Active IOPs in HOLD state */
+
+rebuild_sys_tab:
+	if (hba_chain == NULL) 
+		return 0;
+
+	/*
+	 * If build_sys_table fails, we kill everything and bail
+	 * as we can't init the IOPs w/o a system table
+	 */	
+	if (adpt_i2o_build_sys_table() < 0) {
+		adpt_i2o_sys_shutdown();
+		return 0;
+	}
+
+	PDEBUG("HBA's in HOLD state\n");
+
+	/* If IOP don't get online, we need to rebuild the System table */
+	for (pHba = hba_chain; pHba; pHba = pHba->next) {
+		if (adpt_i2o_online_hba(pHba) < 0) {
+			adpt_i2o_delete_hba(pHba);	
+			goto rebuild_sys_tab;
+		}
+	}
+
+	/* Active IOPs now in OPERATIONAL state */
+	PDEBUG("HBA's in OPERATIONAL state\n");
+
+	printk("dpti: If you have a lot of devices this could take a few minutes.\n");
+	for (pHba = hba_chain; pHba; pHba = pHba->next) {
+		printk(KERN_INFO"%s: Reading the hardware resource table.\n", pHba->name);
+		if (adpt_i2o_lct_get(pHba) < 0){
+			adpt_i2o_delete_hba(pHba);
+			continue;
+		}
+
+		if (adpt_i2o_parse_lct(pHba) < 0){
+			adpt_i2o_delete_hba(pHba);
+			continue;
+		}
+		adpt_inquiry(pHba);
+	}
+
+	for (pHba = hba_chain; pHba; pHba = pHba->next) {
+		if( adpt_scsi_register(pHba,sht) < 0){
+			adpt_i2o_delete_hba(pHba);
+			continue;
+		}
+		pHba->initialized = TRUE;
+		pHba->state &= ~DPTI_STATE_RESET;
+	}
+
+	// Register our control device node
+	// nodes will need to be created in /dev to access this
+	// the nodes can not be created from within the driver
+	if (hba_count && register_chrdev(DPTI_I2O_MAJOR, DPT_DRIVER, &adpt_fops)) {
+		adpt_i2o_sys_shutdown();
+		return 0;
+	}
+	return hba_count;
+}
+
+
+/*
+ * scsi_unregister will be called AFTER we return. 
+ */
+static int adpt_release(struct Scsi_Host *host)
+{
+	adpt_hba* pHba = (adpt_hba*) host->hostdata[0];
+//	adpt_i2o_quiesce_hba(pHba);
+	adpt_i2o_delete_hba(pHba);
+	scsi_unregister(host);
+	return 0;
+}
+
+
+static void adpt_inquiry(adpt_hba* pHba)
+{
+	u32 msg[14]; 
+	u32 *mptr;
+	u32 *lenptr;
+	int direction;
+	int scsidir;
+	u32 len;
+	u32 reqlen;
+	u8* buf;
+	u8  scb[16];
+	s32 rcode;
+
+	memset(msg, 0, sizeof(msg));
+	buf = (u8*)kmalloc(80,GFP_KERNEL|ADDR32);
+	if(!buf){
+		printk(KERN_ERR"%s: Could not allocate buffer\n",pHba->name);
+		return;
+	}
+	memset((void*)buf, 0, 36);
+	
+	len = 36;
+	direction = 0x00000000;	
+	scsidir  =0x40000000;	// DATA IN  (iop<--dev)
+
+	reqlen = 14;		// SINGLE SGE
+	/* Stick the headers on */
+	msg[0] = reqlen<<16 | SGL_OFFSET_12;
+	msg[1] = (0xff<<24|HOST_TID<<12|ADAPTER_TID);
+	msg[2] = 0;
+	msg[3]  = 0;
+	// Adaptec/DPT Private stuff 
+	msg[4] = I2O_CMD_SCSI_EXEC|DPT_ORGANIZATION_ID<<16;
+	msg[5] = ADAPTER_TID | 1<<16 /* Interpret*/;
+	/* Direction, disconnect ok | sense data | simple queue , CDBLen */
+	// I2O_SCB_FLAG_ENABLE_DISCONNECT | 
+	// I2O_SCB_FLAG_SIMPLE_QUEUE_TAG | 
+	// I2O_SCB_FLAG_SENSE_DATA_IN_MESSAGE;
+	msg[6] = scsidir|0x20a00000| 6 /* cmd len*/;
+
+	mptr=msg+7;
+
+	memset(scb, 0, sizeof(scb));
+	// Write SCSI command into the message - always 16 byte block 
+	scb[0] = INQUIRY;
+	scb[1] = 0;
+	scb[2] = 0;
+	scb[3] = 0;
+	scb[4] = 36;
+	scb[5] = 0;
+	// Don't care about the rest of scb
+
+	memcpy(mptr, scb, sizeof(scb));
+	mptr+=4;
+	lenptr=mptr++;		/* Remember me - fill in when we know */
+
+	/* Now fill in the SGList and command */
+	*lenptr = len;
+	*mptr++ = 0xD0000000|direction|len;
+	*mptr++ = virt_to_bus(buf);
+
+	// Send it on it's way
+	rcode = adpt_i2o_post_wait(pHba, msg, reqlen<<2, 120);
+	if (rcode != 0) {
+		sprintf(pHba->detail, "Adaptec I2O RAID");
+		printk(KERN_INFO "%s: Inquiry Error (%d)\n",pHba->name,rcode);
+		if (rcode != -ETIME && rcode != -EINTR)
+			kfree(buf);
+	} else {
+		memset(pHba->detail, 0, sizeof(pHba->detail));
+		memcpy(&(pHba->detail), "Vendor: Adaptec ", 16);
+		memcpy(&(pHba->detail[16]), " Model: ", 8);
+		memcpy(&(pHba->detail[24]), (u8*) &buf[16], 16);
+		memcpy(&(pHba->detail[40]), " FW: ", 4);
+		memcpy(&(pHba->detail[44]), (u8*) &buf[32], 4);
+		pHba->detail[48] = '\0';	/* precautionary */
+		kfree(buf);
+	}
+	adpt_i2o_status_get(pHba);
+	return ;
+}
+
+
+static int adpt_slave_configure(struct scsi_device * device)
+{
+	struct Scsi_Host *host = device->host;
+	adpt_hba* pHba;
+
+	pHba = (adpt_hba *) host->hostdata[0];
+
+	if (host->can_queue && device->tagged_supported) {
+		scsi_adjust_queue_depth(device, MSG_SIMPLE_TAG,
+				host->can_queue - 1);
+	} else {
+		scsi_adjust_queue_depth(device, 0, 1);
+	}
+	return 0;
+}
+
+static int adpt_queue(struct scsi_cmnd * cmd, void (*done) (struct scsi_cmnd *))
+{
+	adpt_hba* pHba = NULL;
+	struct adpt_device* pDev = NULL;	/* dpt per device information */
+	ulong timeout = jiffies + (TMOUT_SCSI*HZ);
+
+	cmd->scsi_done = done;
+	/*
+	 * SCSI REQUEST_SENSE commands will be executed automatically by the 
+	 * Host Adapter for any errors, so they should not be executed 
+	 * explicitly unless the Sense Data is zero indicating that no error 
+	 * occurred.
+	 */
+
+	if ((cmd->cmnd[0] == REQUEST_SENSE) && (cmd->sense_buffer[0] != 0)) {
+		cmd->result = (DID_OK << 16);
+		cmd->scsi_done(cmd);
+		return 0;
+	}
+
+	pHba = (adpt_hba*)cmd->device->host->hostdata[0];
+	if (!pHba) {
+		return FAILED;
+	}
+
+	rmb();
+	/*
+	 * TODO: I need to block here if I am processing ioctl cmds
+	 * but if the outstanding cmds all finish before the ioctl,
+	 * the scsi-core will not know to start sending cmds to me again.
+	 * I need to a way to restart the scsi-cores queues or should I block
+	 * calling scsi_done on the outstanding cmds instead
+	 * for now we don't set the IOCTL state
+	 */
+	if(((pHba->state) & DPTI_STATE_IOCTL) || ((pHba->state) & DPTI_STATE_RESET)) {
+		pHba->host->last_reset = jiffies;
+		pHba->host->resetting = 1;
+		return 1;
+	}
+
+	if(cmd->eh_state != SCSI_STATE_QUEUED){
+		// If we are not doing error recovery
+		mod_timer(&cmd->eh_timeout, timeout);
+	}
+
+	// TODO if the cmd->device if offline then I may need to issue a bus rescan
+	// followed by a get_lct to see if the device is there anymore
+	if((pDev = (struct adpt_device*) (cmd->device->hostdata)) == NULL) {
+		/*
+		 * First command request for this device.  Set up a pointer
+		 * to the device structure.  This should be a TEST_UNIT_READY
+		 * command from scan_scsis_single.
+		 */
+		if ((pDev = adpt_find_device(pHba, (u32)cmd->device->channel, (u32)cmd->device->id, (u32)cmd->device->lun)) == NULL) {
+			// TODO: if any luns are at this bus, scsi id then fake a TEST_UNIT_READY and INQUIRY response 
+			// with type 7F (for all luns less than the max for this bus,id) so the lun scan will continue.
+			cmd->result = (DID_NO_CONNECT << 16);
+			cmd->scsi_done(cmd);
+			return 0;
+		}
+		cmd->device->hostdata = pDev;
+	}
+	pDev->pScsi_dev = cmd->device;
+
+	/*
+	 * If we are being called from when the device is being reset, 
+	 * delay processing of the command until later.
+	 */
+	if (pDev->state & DPTI_DEV_RESET ) {
+		return FAILED;
+	}
+	return adpt_scsi_to_i2o(pHba, cmd, pDev);
+}
+
+static int adpt_bios_param(struct scsi_device *sdev, struct block_device *dev,
+		sector_t capacity, int geom[])
+{
+	int heads=-1;
+	int sectors=-1;
+	int cylinders=-1;
+
+	// *** First lets set the default geometry ****
+	
+	// If the capacity is less than ox2000
+	if (capacity < 0x2000 ) {	// floppy
+		heads = 18;
+		sectors = 2;
+	} 
+	// else if between 0x2000 and 0x20000
+	else if (capacity < 0x20000) {
+		heads = 64;
+		sectors = 32;
+	}
+	// else if between 0x20000 and 0x40000
+	else if (capacity < 0x40000) {
+		heads = 65;
+		sectors = 63;
+	}
+	// else if between 0x4000 and 0x80000
+	else if (capacity < 0x80000) {
+		heads = 128;
+		sectors = 63;
+	}
+	// else if greater than 0x80000
+	else {
+		heads = 255;
+		sectors = 63;
+	}
+	cylinders = sector_div(capacity, heads * sectors);
+
+	// Special case if CDROM
+	if(sdev->type == 5) {  // CDROM
+		heads = 252;
+		sectors = 63;
+		cylinders = 1111;
+	}
+
+	geom[0] = heads;
+	geom[1] = sectors;
+	geom[2] = cylinders;
+	
+	PDEBUG("adpt_bios_param: exit\n");
+	return 0;
+}
+
+
+static const char *adpt_info(struct Scsi_Host *host)
+{
+	adpt_hba* pHba;
+
+	pHba = (adpt_hba *) host->hostdata[0];
+	return (char *) (pHba->detail);
+}
+
+static int adpt_proc_info(struct Scsi_Host *host, char *buffer, char **start, off_t offset,
+		  int length, int inout)
+{
+	struct adpt_device* d;
+	int id;
+	int chan;
+	int len = 0;
+	int begin = 0;
+	int pos = 0;
+	adpt_hba* pHba;
+	int unit;
+
+	*start = buffer;
+	if (inout == TRUE) {
+		/*
+		 * The user has done a write and wants us to take the
+		 * data in the buffer and do something with it.
+		 * proc_scsiwrite calls us with inout = 1
+		 *
+		 * Read data from buffer (writing to us) - NOT SUPPORTED
+		 */
+		return -EINVAL;
+	}
+
+	/*
+	 * inout = 0 means the user has done a read and wants information
+	 * returned, so we write information about the cards into the buffer
+	 * proc_scsiread() calls us with inout = 0
+	 */
+
+	// Find HBA (host bus adapter) we are looking for
+	down(&adpt_configuration_lock);
+	for (pHba = hba_chain; pHba; pHba = pHba->next) {
+		if (pHba->host == host) {
+			break;	/* found adapter */
+		}
+	}
+	up(&adpt_configuration_lock);
+	if (pHba == NULL) {
+		return 0;
+	}
+	host = pHba->host;
+
+	len  = sprintf(buffer    , "Adaptec I2O RAID Driver Version: %s\n\n", DPT_I2O_VERSION);
+	len += sprintf(buffer+len, "%s\n", pHba->detail);
+	len += sprintf(buffer+len, "SCSI Host=scsi%d  Control Node=/dev/%s  irq=%d\n", 
+			pHba->host->host_no, pHba->name, host->irq);
+	len += sprintf(buffer+len, "\tpost fifo size  = %d\n\treply fifo size = %d\n\tsg table size   = %d\n\n",
+			host->can_queue, (int) pHba->reply_fifo_size , host->sg_tablesize);
+
+	pos = begin + len;
+
+	/* CHECKPOINT */
+	if(pos > offset + length) {
+		goto stop_output;
+	}
+	if(pos <= offset) {
+		/*
+		 * If we haven't even written to where we last left
+		 * off (the last time we were called), reset the 
+		 * beginning pointer.
+		 */
+		len = 0;
+		begin = pos;
+	}
+	len +=  sprintf(buffer+len, "Devices:\n");
+	for(chan = 0; chan < MAX_CHANNEL; chan++) {
+		for(id = 0; id < MAX_ID; id++) {
+			d = pHba->channel[chan].device[id];
+			while(d){
+				len += sprintf(buffer+len,"\t%-24.24s", d->pScsi_dev->vendor);
+				len += sprintf(buffer+len," Rev: %-8.8s\n", d->pScsi_dev->rev);
+				pos = begin + len;
+
+
+				/* CHECKPOINT */
+				if(pos > offset + length) {
+					goto stop_output;
+				}
+				if(pos <= offset) {
+					len = 0;
+					begin = pos;
+				}
+
+				unit = d->pI2o_dev->lct_data.tid;
+				len += sprintf(buffer+len, "\tTID=%d, (Channel=%d, Target=%d, Lun=%d)  (%s)\n\n",
+					       unit, (int)d->scsi_channel, (int)d->scsi_id, (int)d->scsi_lun,
+					       scsi_device_online(d->pScsi_dev)? "online":"offline"); 
+				pos = begin + len;
+
+				/* CHECKPOINT */
+				if(pos > offset + length) {
+					goto stop_output;
+				}
+				if(pos <= offset) {
+					len = 0;
+					begin = pos;
+				}
+
+				d = d->next_lun;
+			}
+		}
+	}
+
+	/*
+	 * begin is where we last checked our position with regards to offset
+	 * begin is always less than offset.  len is relative to begin.  It
+	 * is the number of bytes written past begin
+	 *
+	 */
+stop_output:
+	/* stop the output and calculate the correct length */
+	*(buffer + len) = '\0';
+
+	*start = buffer + (offset - begin);	/* Start of wanted data */
+	len -= (offset - begin);
+	if(len > length) {
+		len = length;
+	} else if(len < 0){
+		len = 0;
+		**start = '\0';
+	}
+	return len;
+}
+
+
+/*===========================================================================
+ * Error Handling routines
+ *===========================================================================
+ */
+
+static int adpt_abort(struct scsi_cmnd * cmd)
+{
+	adpt_hba* pHba = NULL;	/* host bus adapter structure */
+	struct adpt_device* dptdevice;	/* dpt per device information */
+	u32 msg[5];
+	int rcode;
+
+	if(cmd->serial_number == 0){
+		return FAILED;
+	}
+	pHba = (adpt_hba*) cmd->device->host->hostdata[0];
+	printk(KERN_INFO"%s: Trying to Abort cmd=%ld\n",pHba->name, cmd->serial_number);
+	if ((dptdevice = (void*) (cmd->device->hostdata)) == NULL) {
+		printk(KERN_ERR "%s: Unable to abort: No device in cmnd\n",pHba->name);
+		return FAILED;
+	}
+
+	memset(msg, 0, sizeof(msg));
+	msg[0] = FIVE_WORD_MSG_SIZE|SGL_OFFSET_0;
+	msg[1] = I2O_CMD_SCSI_ABORT<<24|HOST_TID<<12|dptdevice->tid;
+	msg[2] = 0;
+	msg[3]= 0; 
+	msg[4] = (u32)cmd;
+	if( (rcode = adpt_i2o_post_wait(pHba, msg, sizeof(msg), FOREVER)) != 0){
+		if(rcode == -EOPNOTSUPP ){
+			printk(KERN_INFO"%s: Abort cmd not supported\n",pHba->name);
+			return FAILED;
+		}
+		printk(KERN_INFO"%s: Abort cmd=%ld failed.\n",pHba->name, cmd->serial_number);
+		return FAILED;
+	} 
+	printk(KERN_INFO"%s: Abort cmd=%ld complete.\n",pHba->name, cmd->serial_number);
+	return SUCCESS;
+}
+
+
+#define I2O_DEVICE_RESET 0x27
+// This is the same for BLK and SCSI devices
+// NOTE this is wrong in the i2o.h definitions
+// This is not currently supported by our adapter but we issue it anyway
+static int adpt_device_reset(struct scsi_cmnd* cmd)
+{
+	adpt_hba* pHba;
+	u32 msg[4];
+	u32 rcode;
+	int old_state;
+	struct adpt_device* d = (void*) cmd->device->hostdata;
+
+	pHba = (void*) cmd->device->host->hostdata[0];
+	printk(KERN_INFO"%s: Trying to reset device\n",pHba->name);
+	if (!d) {
+		printk(KERN_INFO"%s: Reset Device: Device Not found\n",pHba->name);
+		return FAILED;
+	}
+	memset(msg, 0, sizeof(msg));
+	msg[0] = FOUR_WORD_MSG_SIZE|SGL_OFFSET_0;
+	msg[1] = (I2O_DEVICE_RESET<<24|HOST_TID<<12|d->tid);
+	msg[2] = 0;
+	msg[3] = 0;
+
+	old_state = d->state;
+	d->state |= DPTI_DEV_RESET;
+	if( (rcode = adpt_i2o_post_wait(pHba, (void*)msg,sizeof(msg), FOREVER)) ){
+		d->state = old_state;
+		if(rcode == -EOPNOTSUPP ){
+			printk(KERN_INFO"%s: Device reset not supported\n",pHba->name);
+			return FAILED;
+		}
+		printk(KERN_INFO"%s: Device reset failed\n",pHba->name);
+		return FAILED;
+	} else {
+		d->state = old_state;
+		printk(KERN_INFO"%s: Device reset successful\n",pHba->name);
+		return SUCCESS;
+	}
+}
+
+
+#define I2O_HBA_BUS_RESET 0x87
+// This version of bus reset is called by the eh_error handler
+static int adpt_bus_reset(struct scsi_cmnd* cmd)
+{
+	adpt_hba* pHba;
+	u32 msg[4];
+
+	pHba = (adpt_hba*)cmd->device->host->hostdata[0];
+	memset(msg, 0, sizeof(msg));
+	printk(KERN_WARNING"%s: Bus reset: SCSI Bus %d: tid: %d\n",pHba->name, cmd->device->channel,pHba->channel[cmd->device->channel].tid );
+	msg[0] = FOUR_WORD_MSG_SIZE|SGL_OFFSET_0;
+	msg[1] = (I2O_HBA_BUS_RESET<<24|HOST_TID<<12|pHba->channel[cmd->device->channel].tid);
+	msg[2] = 0;
+	msg[3] = 0;
+	if(adpt_i2o_post_wait(pHba, (void*)msg,sizeof(msg), FOREVER) ){
+		printk(KERN_WARNING"%s: Bus reset failed.\n",pHba->name);
+		return FAILED;
+	} else {
+		printk(KERN_WARNING"%s: Bus reset success.\n",pHba->name);
+		return SUCCESS;
+	}
+}
+
+// This version of reset is called by the eh_error_handler
+static int adpt_reset(struct scsi_cmnd* cmd)
+{
+	adpt_hba* pHba;
+	int rcode;
+	pHba = (adpt_hba*)cmd->device->host->hostdata[0];
+	printk(KERN_WARNING"%s: Hba Reset: scsi id %d: tid: %d\n",pHba->name,cmd->device->channel,pHba->channel[cmd->device->channel].tid );
+	rcode =  adpt_hba_reset(pHba);
+	if(rcode == 0){
+		printk(KERN_WARNING"%s: HBA reset complete\n",pHba->name);
+		return SUCCESS;
+	} else {
+		printk(KERN_WARNING"%s: HBA reset failed (%x)\n",pHba->name, rcode);
+		return FAILED;
+	}
+}
+
+// This version of reset is called by the ioctls and indirectly from eh_error_handler via adpt_reset
+static int adpt_hba_reset(adpt_hba* pHba)
+{
+	int rcode;
+
+	pHba->state |= DPTI_STATE_RESET;
+
+	// Activate does get status , init outbound, and get hrt
+	if ((rcode=adpt_i2o_activate_hba(pHba)) < 0) {
+		printk(KERN_ERR "%s: Could not activate\n", pHba->name);
+		adpt_i2o_delete_hba(pHba);
+		return rcode;
+	}
+
+	if ((rcode=adpt_i2o_build_sys_table()) < 0) {
+		adpt_i2o_delete_hba(pHba);
+		return rcode;
+	}
+	PDEBUG("%s: in HOLD state\n",pHba->name);
+
+	if ((rcode=adpt_i2o_online_hba(pHba)) < 0) {
+		adpt_i2o_delete_hba(pHba);	
+		return rcode;
+	}
+	PDEBUG("%s: in OPERATIONAL state\n",pHba->name);
+
+	if ((rcode=adpt_i2o_lct_get(pHba)) < 0){
+		adpt_i2o_delete_hba(pHba);
+		return rcode;
+	}
+
+	if ((rcode=adpt_i2o_reparse_lct(pHba)) < 0){
+		adpt_i2o_delete_hba(pHba);
+		return rcode;
+	}
+	pHba->state &= ~DPTI_STATE_RESET;
+
+	adpt_fail_posted_scbs(pHba);
+	return 0;	/* return success */
+}
+
+/*===========================================================================
+ * 
+ *===========================================================================
+ */
+
+
+static void adpt_i2o_sys_shutdown(void)
+{
+	adpt_hba *pHba, *pNext;
+	struct adpt_i2o_post_wait_data *p1, *p2;
+
+	 printk(KERN_INFO"Shutting down Adaptec I2O controllers.\n");
+	 printk(KERN_INFO"   This could take a few minutes if there are many devices attached\n");
+	/* Delete all IOPs from the controller chain */
+	/* They should have already been released by the
+	 * scsi-core
+	 */
+	for (pHba = hba_chain; pHba; pHba = pNext) {
+		pNext = pHba->next;
+		adpt_i2o_delete_hba(pHba);
+	}
+
+	/* Remove any timedout entries from the wait queue.  */
+	p2 = NULL;
+//	spin_lock_irqsave(&adpt_post_wait_lock, flags);
+	/* Nothing should be outstanding at this point so just
+	 * free them 
+	 */
+	for(p1 = adpt_post_wait_queue; p1; p2 = p1, p1 = p2->next) {
+		kfree(p1);
+	}
+//	spin_unlock_irqrestore(&adpt_post_wait_lock, flags);
+	adpt_post_wait_queue = NULL;
+
+	 printk(KERN_INFO "Adaptec I2O controllers down.\n");
+}
+
+/*
+ * reboot/shutdown notification.
+ *
+ * - Quiesce each IOP in the system
+ *
+ */
+
+#ifdef REBOOT_NOTIFIER
+static int adpt_reboot_event(struct notifier_block *n, ulong code, void *p)
+{
+
+	 if(code != SYS_RESTART && code != SYS_HALT && code != SYS_POWER_OFF)
+		  return NOTIFY_DONE;
+
+	 adpt_i2o_sys_shutdown();
+
+	 return NOTIFY_DONE;
+}
+#endif
+
+
+static int adpt_install_hba(struct scsi_host_template* sht, struct pci_dev* pDev) 
+{
+
+	adpt_hba* pHba = NULL;
+	adpt_hba* p = NULL;
+	ulong base_addr0_phys = 0;
+	ulong base_addr1_phys = 0;
+	u32 hba_map0_area_size = 0;
+	u32 hba_map1_area_size = 0;
+	void __iomem *base_addr_virt = NULL;
+	void __iomem *msg_addr_virt = NULL;
+
+	int raptorFlag = FALSE;
+	int i;
+
+	if(pci_enable_device(pDev)) {
+		return -EINVAL;
+	}
+	pci_set_master(pDev);
+	if (pci_set_dma_mask(pDev, 0xffffffffffffffffULL) &&
+	    pci_set_dma_mask(pDev, 0xffffffffULL))
+		return -EINVAL;
+
+	base_addr0_phys = pci_resource_start(pDev,0);
+	hba_map0_area_size = pci_resource_len(pDev,0);
+
+	// Check if standard PCI card or single BAR Raptor
+	if(pDev->device == PCI_DPT_DEVICE_ID){
+		if(pDev->subsystem_device >=0xc032 && pDev->subsystem_device <= 0xc03b){
+			// Raptor card with this device id needs 4M
+			hba_map0_area_size = 0x400000;
+		} else { // Not Raptor - it is a PCI card
+			if(hba_map0_area_size > 0x100000 ){ 
+				hba_map0_area_size = 0x100000;
+			}
+		}
+	} else {// Raptor split BAR config
+		// Use BAR1 in this configuration
+		base_addr1_phys = pci_resource_start(pDev,1);
+		hba_map1_area_size = pci_resource_len(pDev,1);
+		raptorFlag = TRUE;
+	}
+
+
+	base_addr_virt = ioremap(base_addr0_phys,hba_map0_area_size);
+	if (!base_addr_virt) {
+		PERROR("dpti: adpt_config_hba: io remap failed\n");
+		return -EINVAL;
+	}
+
+        if(raptorFlag == TRUE) {
+		msg_addr_virt = ioremap(base_addr1_phys, hba_map1_area_size );
+		if (!msg_addr_virt) {
+			PERROR("dpti: adpt_config_hba: io remap failed on BAR1\n");
+			iounmap(base_addr_virt);
+			return -EINVAL;
+		}
+	} else {
+		msg_addr_virt = base_addr_virt;
+	}
+	
+	// Allocate and zero the data structure
+	pHba = kmalloc(sizeof(adpt_hba), GFP_KERNEL);
+	if( pHba == NULL) {
+		if(msg_addr_virt != base_addr_virt){
+			iounmap(msg_addr_virt);
+		}
+		iounmap(base_addr_virt);
+		return -ENOMEM;
+	}
+	memset(pHba, 0, sizeof(adpt_hba));
+
+	down(&adpt_configuration_lock);
+	for(i=0;i<DPTI_MAX_HBA;i++) {
+		if(hbas[i]==NULL) {
+			hbas[i]=pHba;
+			break;
+		}
+	}
+
+	if(hba_chain != NULL){
+		for(p = hba_chain; p->next; p = p->next);
+		p->next = pHba;
+	} else {
+		hba_chain = pHba;
+	}
+	pHba->next = NULL;
+	pHba->unit = hba_count;
+	sprintf(pHba->name, "dpti%d", i);
+	hba_count++;
+	
+	up(&adpt_configuration_lock);
+
+	pHba->pDev = pDev;
+	pHba->base_addr_phys = base_addr0_phys;
+
+	// Set up the Virtual Base Address of the I2O Device
+	pHba->base_addr_virt = base_addr_virt;
+	pHba->msg_addr_virt = msg_addr_virt;
+	pHba->irq_mask = base_addr_virt+0x30;
+	pHba->post_port = base_addr_virt+0x40;
+	pHba->reply_port = base_addr_virt+0x44;
+
+	pHba->hrt = NULL;
+	pHba->lct = NULL;
+	pHba->lct_size = 0;
+	pHba->status_block = NULL;
+	pHba->post_count = 0;
+	pHba->state = DPTI_STATE_RESET;
+	pHba->pDev = pDev;
+	pHba->devices = NULL;
+
+	// Initializing the spinlocks
+	spin_lock_init(&pHba->state_lock);
+	spin_lock_init(&adpt_post_wait_lock);
+
+	if(raptorFlag == 0){
+		printk(KERN_INFO"Adaptec I2O RAID controller %d at %p size=%x irq=%d\n", 
+			hba_count-1, base_addr_virt, hba_map0_area_size, pDev->irq);
+	} else {
+		printk(KERN_INFO"Adaptec I2O RAID controller %d irq=%d\n",hba_count-1, pDev->irq);
+		printk(KERN_INFO"     BAR0 %p - size= %x\n",base_addr_virt,hba_map0_area_size);
+		printk(KERN_INFO"     BAR1 %p - size= %x\n",msg_addr_virt,hba_map1_area_size);
+	}
+
+	if (request_irq (pDev->irq, adpt_isr, SA_SHIRQ, pHba->name, pHba)) {
+		printk(KERN_ERR"%s: Couldn't register IRQ %d\n", pHba->name, pDev->irq);
+		adpt_i2o_delete_hba(pHba);
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+
+static void adpt_i2o_delete_hba(adpt_hba* pHba)
+{
+	adpt_hba* p1;
+	adpt_hba* p2;
+	struct i2o_device* d;
+	struct i2o_device* next;
+	int i;
+	int j;
+	struct adpt_device* pDev;
+	struct adpt_device* pNext;
+
+
+	down(&adpt_configuration_lock);
+	// scsi_unregister calls our adpt_release which
+	// does a quiese
+	if(pHba->host){
+		free_irq(pHba->host->irq, pHba);
+	}
+	for(i=0;i<DPTI_MAX_HBA;i++) {
+		if(hbas[i]==pHba) {
+			hbas[i] = NULL;
+		}
+	}
+	p2 = NULL;
+	for( p1 = hba_chain; p1; p2 = p1,p1=p1->next){
+		if(p1 == pHba) {
+			if(p2) {
+				p2->next = p1->next;
+			} else {
+				hba_chain = p1->next;
+			}
+			break;
+		}
+	}
+
+	hba_count--;
+	up(&adpt_configuration_lock);
+
+	iounmap(pHba->base_addr_virt);
+	if(pHba->msg_addr_virt != pHba->base_addr_virt){
+		iounmap(pHba->msg_addr_virt);
+	}
+	if(pHba->hrt) {
+		kfree(pHba->hrt);
+	}
+	if(pHba->lct){
+		kfree(pHba->lct);
+	}
+	if(pHba->status_block) {
+		kfree(pHba->status_block);
+	}
+	if(pHba->reply_pool){
+		kfree(pHba->reply_pool);
+	}
+
+	for(d = pHba->devices; d ; d = next){
+		next = d->next;
+		kfree(d);
+	}
+	for(i = 0 ; i < pHba->top_scsi_channel ; i++){
+		for(j = 0; j < MAX_ID; j++){
+			if(pHba->channel[i].device[j] != NULL){
+				for(pDev = pHba->channel[i].device[j]; pDev; pDev = pNext){
+					pNext = pDev->next_lun;
+					kfree(pDev);
+				}
+			}
+		}
+	}
+	kfree(pHba);
+
+	if(hba_count <= 0){
+		unregister_chrdev(DPTI_I2O_MAJOR, DPT_DRIVER);   
+	}
+}
+
+
+static int adpt_init(void)
+{
+	int i;
+
+	printk("Loading Adaptec I2O RAID: Version " DPT_I2O_VERSION "\n");
+	for (i = 0; i < DPTI_MAX_HBA; i++) {
+		hbas[i] = NULL;
+	}
+#ifdef REBOOT_NOTIFIER
+	register_reboot_notifier(&adpt_reboot_notifier);
+#endif
+
+	return 0;
+}
+
+
+static struct adpt_device* adpt_find_device(adpt_hba* pHba, u32 chan, u32 id, u32 lun)
+{
+	struct adpt_device* d;
+
+	if(chan < 0 || chan >= MAX_CHANNEL)
+		return NULL;
+	
+	if( pHba->channel[chan].device == NULL){
+		printk(KERN_DEBUG"Adaptec I2O RAID: Trying to find device before they are allocated\n");
+		return NULL;
+	}
+
+	d = pHba->channel[chan].device[id];
+	if(!d || d->tid == 0) {
+		return NULL;
+	}
+
+	/* If it is the only lun at that address then this should match*/
+	if(d->scsi_lun == lun){
+		return d;
+	}
+
+	/* else we need to look through all the luns */
+	for(d=d->next_lun ; d ; d = d->next_lun){
+		if(d->scsi_lun == lun){
+			return d;
+		}
+	}
+	return NULL;
+}
+
+
+static int adpt_i2o_post_wait(adpt_hba* pHba, u32* msg, int len, int timeout)
+{
+	// I used my own version of the WAIT_QUEUE_HEAD
+	// to handle some version differences
+	// When embedded in the kernel this could go back to the vanilla one
+	ADPT_DECLARE_WAIT_QUEUE_HEAD(adpt_wq_i2o_post);
+	int status = 0;
+	ulong flags = 0;
+	struct adpt_i2o_post_wait_data *p1, *p2;
+	struct adpt_i2o_post_wait_data *wait_data =
+		kmalloc(sizeof(struct adpt_i2o_post_wait_data),GFP_KERNEL);
+	adpt_wait_queue_t wait;
+
+	if(!wait_data){
+		return -ENOMEM;
+	}
+	/*
+	 * The spin locking is needed to keep anyone from playing
+	 * with the queue pointers and id while we do the same
+	 */
+	spin_lock_irqsave(&adpt_post_wait_lock, flags);
+       // TODO we need a MORE unique way of getting ids
+       // to support async LCT get
+	wait_data->next = adpt_post_wait_queue;
+	adpt_post_wait_queue = wait_data;
+	adpt_post_wait_id++;
+	adpt_post_wait_id &= 0x7fff;
+	wait_data->id =  adpt_post_wait_id;
+	spin_unlock_irqrestore(&adpt_post_wait_lock, flags);
+
+	wait_data->wq = &adpt_wq_i2o_post;
+	wait_data->status = -ETIMEDOUT;
+
+	// this code is taken from kernel/sched.c:interruptible_sleep_on_timeout
+	wait.task = current;
+	init_waitqueue_entry(&wait, current);
+	spin_lock_irqsave(&adpt_wq_i2o_post.lock, flags);
+	__add_wait_queue(&adpt_wq_i2o_post, &wait);
+	spin_unlock(&adpt_wq_i2o_post.lock);
+
+	msg[2] |= 0x80000000 | ((u32)wait_data->id);
+	timeout *= HZ;
+	if((status = adpt_i2o_post_this(pHba, msg, len)) == 0){
+		set_current_state(TASK_INTERRUPTIBLE);
+		if(pHba->host)
+			spin_unlock_irq(pHba->host->host_lock);
+		if (!timeout)
+			schedule();
+		else{
+			timeout = schedule_timeout(timeout);
+			if (timeout == 0) {
+				// I/O issued, but cannot get result in
+				// specified time. Freeing resorces is
+				// dangerous.
+				status = -ETIME;
+			}
+		}
+		if(pHba->host)
+			spin_lock_irq(pHba->host->host_lock);
+	}
+	spin_lock_irq(&adpt_wq_i2o_post.lock);
+	__remove_wait_queue(&adpt_wq_i2o_post, &wait);
+	spin_unlock_irqrestore(&adpt_wq_i2o_post.lock, flags);
+
+	if(status == -ETIMEDOUT){
+		printk(KERN_INFO"dpti%d: POST WAIT TIMEOUT\n",pHba->unit);
+		// We will have to free the wait_data memory during shutdown
+		return status;
+	}
+
+	/* Remove the entry from the queue.  */
+	p2 = NULL;
+	spin_lock_irqsave(&adpt_post_wait_lock, flags);
+	for(p1 = adpt_post_wait_queue; p1; p2 = p1, p1 = p1->next) {
+		if(p1 == wait_data) {
+			if(p1->status == I2O_DETAIL_STATUS_UNSUPPORTED_FUNCTION ) {
+				status = -EOPNOTSUPP;
+			}
+			if(p2) {
+				p2->next = p1->next;
+			} else {
+				adpt_post_wait_queue = p1->next;
+			}
+			break;
+		}
+	}
+	spin_unlock_irqrestore(&adpt_post_wait_lock, flags);
+
+	kfree(wait_data);
+
+	return status;
+}
+
+
+static s32 adpt_i2o_post_this(adpt_hba* pHba, u32* data, int len)
+{
+
+	u32 m = EMPTY_QUEUE;
+	u32 __iomem *msg;
+	ulong timeout = jiffies + 30*HZ;
+	do {
+		rmb();
+		m = readl(pHba->post_port);
+		if (m != EMPTY_QUEUE) {
+			break;
+		}
+		if(time_after(jiffies,timeout)){
+			printk(KERN_WARNING"dpti%d: Timeout waiting for message frame!\n", pHba->unit);
+			return -ETIMEDOUT;
+		}
+		set_current_state(TASK_UNINTERRUPTIBLE);
+		schedule_timeout(1);
+	} while(m == EMPTY_QUEUE);
+		
+	msg = pHba->msg_addr_virt + m;
+	memcpy_toio(msg, data, len);
+	wmb();
+
+	//post message
+	writel(m, pHba->post_port);
+	wmb();
+
+	return 0;
+}
+
+
+static void adpt_i2o_post_wait_complete(u32 context, int status)
+{
+	struct adpt_i2o_post_wait_data *p1 = NULL;
+	/*
+	 * We need to search through the adpt_post_wait
+	 * queue to see if the given message is still
+	 * outstanding.  If not, it means that the IOP
+	 * took longer to respond to the message than we
+	 * had allowed and timer has already expired.
+	 * Not much we can do about that except log
+	 * it for debug purposes, increase timeout, and recompile
+	 *
+	 * Lock needed to keep anyone from moving queue pointers
+	 * around while we're looking through them.
+	 */
+
+	context &= 0x7fff;
+
+	spin_lock(&adpt_post_wait_lock);
+	for(p1 = adpt_post_wait_queue; p1; p1 = p1->next) {
+		if(p1->id == context) {
+			p1->status = status;
+			spin_unlock(&adpt_post_wait_lock);
+			wake_up_interruptible(p1->wq);
+			return;
+		}
+	}
+	spin_unlock(&adpt_post_wait_lock);
+        // If this happens we lose commands that probably really completed
+	printk(KERN_DEBUG"dpti: Could Not find task %d in wait queue\n",context);
+	printk(KERN_DEBUG"      Tasks in wait queue:\n");
+	for(p1 = adpt_post_wait_queue; p1; p1 = p1->next) {
+		printk(KERN_DEBUG"           %d\n",p1->id);
+	}
+	return;
+}
+
+static s32 adpt_i2o_reset_hba(adpt_hba* pHba)			
+{
+	u32 msg[8];
+	u8* status;
+	u32 m = EMPTY_QUEUE ;
+	ulong timeout = jiffies + (TMOUT_IOPRESET*HZ);
+
+	if(pHba->initialized  == FALSE) {	// First time reset should be quick
+		timeout = jiffies + (25*HZ);
+	} else {
+		adpt_i2o_quiesce_hba(pHba);
+	}
+
+	do {
+		rmb();
+		m = readl(pHba->post_port);
+		if (m != EMPTY_QUEUE) {
+			break;
+		}
+		if(time_after(jiffies,timeout)){
+			printk(KERN_WARNING"Timeout waiting for message!\n");
+			return -ETIMEDOUT;
+		}
+		set_current_state(TASK_UNINTERRUPTIBLE);
+		schedule_timeout(1);
+	} while (m == EMPTY_QUEUE);
+
+	status = (u8*)kmalloc(4, GFP_KERNEL|ADDR32);
+	if(status == NULL) {
+		adpt_send_nop(pHba, m);
+		printk(KERN_ERR"IOP reset failed - no free memory.\n");
+		return -ENOMEM;
+	}
+	memset(status,0,4);
+
+	msg[0]=EIGHT_WORD_MSG_SIZE|SGL_OFFSET_0;
+	msg[1]=I2O_CMD_ADAPTER_RESET<<24|HOST_TID<<12|ADAPTER_TID;
+	msg[2]=0;
+	msg[3]=0;
+	msg[4]=0;
+	msg[5]=0;
+	msg[6]=virt_to_bus(status);
+	msg[7]=0;     
+
+	memcpy_toio(pHba->msg_addr_virt+m, msg, sizeof(msg));
+	wmb();
+	writel(m, pHba->post_port);
+	wmb();
+
+	while(*status == 0){
+		if(time_after(jiffies,timeout)){
+			printk(KERN_WARNING"%s: IOP Reset Timeout\n",pHba->name);
+			kfree(status);
+			return -ETIMEDOUT;
+		}
+		rmb();
+		set_current_state(TASK_UNINTERRUPTIBLE);
+		schedule_timeout(1);
+	}
+
+	if(*status == 0x01 /*I2O_EXEC_IOP_RESET_IN_PROGRESS*/) {
+		PDEBUG("%s: Reset in progress...\n", pHba->name);
+		// Here we wait for message frame to become available
+		// indicated that reset has finished
+		do {
+			rmb();
+			m = readl(pHba->post_port);
+			if (m != EMPTY_QUEUE) {
+				break;
+			}
+			if(time_after(jiffies,timeout)){
+				printk(KERN_ERR "%s:Timeout waiting for IOP Reset.\n",pHba->name);
+				return -ETIMEDOUT;
+			}
+			set_current_state(TASK_UNINTERRUPTIBLE);
+			schedule_timeout(1);
+		} while (m == EMPTY_QUEUE);
+		// Flush the offset
+		adpt_send_nop(pHba, m);
+	}
+	adpt_i2o_status_get(pHba);
+	if(*status == 0x02 ||
+			pHba->status_block->iop_state != ADAPTER_STATE_RESET) {
+		printk(KERN_WARNING"%s: Reset reject, trying to clear\n",
+				pHba->name);
+	} else {
+		PDEBUG("%s: Reset completed.\n", pHba->name);
+	}
+
+	kfree(status);
+#ifdef UARTDELAY
+	// This delay is to allow someone attached to the card through the debug UART to 
+	// set up the dump levels that they want before the rest of the initialization sequence
+	adpt_delay(20000);
+#endif
+	return 0;
+}
+
+
+static int adpt_i2o_parse_lct(adpt_hba* pHba)
+{
+	int i;
+	int max;
+	int tid;
+	struct i2o_device *d;
+	i2o_lct *lct = pHba->lct;
+	u8 bus_no = 0;
+	s16 scsi_id;
+	s16 scsi_lun;
+	u32 buf[10]; // larger than 7, or 8 ...
+	struct adpt_device* pDev; 
+	
+	if (lct == NULL) {
+		printk(KERN_ERR "%s: LCT is empty???\n",pHba->name);
+		return -1;
+	}
+	
+	max = lct->table_size;	
+	max -= 3;
+	max /= 9;
+
+	for(i=0;i<max;i++) {
+		if( lct->lct_entry[i].user_tid != 0xfff){
+			/*
+			 * If we have hidden devices, we need to inform the upper layers about
+			 * the possible maximum id reference to handle device access when
+			 * an array is disassembled. This code has no other purpose but to
+			 * allow us future access to devices that are currently hidden
+			 * behind arrays, hotspares or have not been configured (JBOD mode).
+			 */
+			if( lct->lct_entry[i].class_id != I2O_CLASS_RANDOM_BLOCK_STORAGE &&
+			    lct->lct_entry[i].class_id != I2O_CLASS_SCSI_PERIPHERAL &&
+			    lct->lct_entry[i].class_id != I2O_CLASS_FIBRE_CHANNEL_PERIPHERAL ){
+			    	continue;
+			}
+			tid = lct->lct_entry[i].tid;
+			// I2O_DPT_DEVICE_INFO_GROUP_NO;
+			if(adpt_i2o_query_scalar(pHba, tid, 0x8000, -1, buf, 32)<0) {
+				continue;
+			}
+			bus_no = buf[0]>>16;
+			scsi_id = buf[1];
+			scsi_lun = (buf[2]>>8 )&0xff;
+			if(bus_no >= MAX_CHANNEL) {	// Something wrong skip it
+				printk(KERN_WARNING"%s: Channel number %d out of range \n", pHba->name, bus_no);
+				continue;
+			}
+			if (scsi_id >= MAX_ID){
+				printk(KERN_WARNING"%s: SCSI ID %d out of range \n", pHba->name, bus_no);
+				continue;
+			}
+			if(bus_no > pHba->top_scsi_channel){
+				pHba->top_scsi_channel = bus_no;
+			}
+			if(scsi_id > pHba->top_scsi_id){
+				pHba->top_scsi_id = scsi_id;
+			}
+			if(scsi_lun > pHba->top_scsi_lun){
+				pHba->top_scsi_lun = scsi_lun;
+			}
+			continue;
+		}
+		d = (struct i2o_device *)kmalloc(sizeof(struct i2o_device), GFP_KERNEL);
+		if(d==NULL)
+		{
+			printk(KERN_CRIT"%s: Out of memory for I2O device data.\n",pHba->name);
+			return -ENOMEM;
+		}
+		
+		d->controller = (void*)pHba;
+		d->next = NULL;
+
+		memcpy(&d->lct_data, &lct->lct_entry[i], sizeof(i2o_lct_entry));
+
+		d->flags = 0;
+		tid = d->lct_data.tid;
+		adpt_i2o_report_hba_unit(pHba, d);
+		adpt_i2o_install_device(pHba, d);
+	}
+	bus_no = 0;
+	for(d = pHba->devices; d ; d = d->next) {
+		if(d->lct_data.class_id  == I2O_CLASS_BUS_ADAPTER_PORT ||
+		   d->lct_data.class_id  == I2O_CLASS_FIBRE_CHANNEL_PORT){
+			tid = d->lct_data.tid;
+			// TODO get the bus_no from hrt-but for now they are in order
+			//bus_no = 
+			if(bus_no > pHba->top_scsi_channel){
+				pHba->top_scsi_channel = bus_no;
+			}
+			pHba->channel[bus_no].type = d->lct_data.class_id;
+			pHba->channel[bus_no].tid = tid;
+			if(adpt_i2o_query_scalar(pHba, tid, 0x0200, -1, buf, 28)>=0)
+			{
+				pHba->channel[bus_no].scsi_id = buf[1];
+				PDEBUG("Bus %d - SCSI ID %d.\n", bus_no, buf[1]);
+			}
+			// TODO remove - this is just until we get from hrt
+			bus_no++;
+			if(bus_no >= MAX_CHANNEL) {	// Something wrong skip it
+				printk(KERN_WARNING"%s: Channel number %d out of range - LCT\n", pHba->name, bus_no);
+				break;
+			}
+		}
+	}
+
+	// Setup adpt_device table
+	for(d = pHba->devices; d ; d = d->next) {
+		if(d->lct_data.class_id  == I2O_CLASS_RANDOM_BLOCK_STORAGE ||
+		   d->lct_data.class_id  == I2O_CLASS_SCSI_PERIPHERAL ||
+		   d->lct_data.class_id  == I2O_CLASS_FIBRE_CHANNEL_PERIPHERAL ){
+
+			tid = d->lct_data.tid;
+			scsi_id = -1;
+			// I2O_DPT_DEVICE_INFO_GROUP_NO;
+			if(adpt_i2o_query_scalar(pHba, tid, 0x8000, -1, buf, 32)>=0) {
+				bus_no = buf[0]>>16;
+				scsi_id = buf[1];
+				scsi_lun = (buf[2]>>8 )&0xff;
+				if(bus_no >= MAX_CHANNEL) {	// Something wrong skip it
+					continue;
+				}
+				if (scsi_id >= MAX_ID) {
+					continue;
+				}
+				if( pHba->channel[bus_no].device[scsi_id] == NULL){
+					pDev =  kmalloc(sizeof(struct adpt_device),GFP_KERNEL);
+					if(pDev == NULL) {
+						return -ENOMEM;
+					}
+					pHba->channel[bus_no].device[scsi_id] = pDev;
+					memset(pDev,0,sizeof(struct adpt_device));
+				} else {
+					for( pDev = pHba->channel[bus_no].device[scsi_id];	
+							pDev->next_lun; pDev = pDev->next_lun){
+					}
+					pDev->next_lun = kmalloc(sizeof(struct adpt_device),GFP_KERNEL);
+					if(pDev->next_lun == NULL) {
+						return -ENOMEM;
+					}
+					memset(pDev->next_lun,0,sizeof(struct adpt_device));
+					pDev = pDev->next_lun;
+				}
+				pDev->tid = tid;
+				pDev->scsi_channel = bus_no;
+				pDev->scsi_id = scsi_id;
+				pDev->scsi_lun = scsi_lun;
+				pDev->pI2o_dev = d;
+				d->owner = pDev;
+				pDev->type = (buf[0])&0xff;
+				pDev->flags = (buf[0]>>8)&0xff;
+				if(scsi_id > pHba->top_scsi_id){
+					pHba->top_scsi_id = scsi_id;
+				}
+				if(scsi_lun > pHba->top_scsi_lun){
+					pHba->top_scsi_lun = scsi_lun;
+				}
+			}
+			if(scsi_id == -1){
+				printk(KERN_WARNING"Could not find SCSI ID for %s\n",
+						d->lct_data.identity_tag);
+			}
+		}
+	}
+	return 0;
+}
+
+
+/*
+ *	Each I2O controller has a chain of devices on it - these match
+ *	the useful parts of the LCT of the board.
+ */
+ 
+static int adpt_i2o_install_device(adpt_hba* pHba, struct i2o_device *d)
+{
+	down(&adpt_configuration_lock);
+	d->controller=pHba;
+	d->owner=NULL;
+	d->next=pHba->devices;
+	d->prev=NULL;
+	if (pHba->devices != NULL){
+		pHba->devices->prev=d;
+	}
+	pHba->devices=d;
+	*d->dev_name = 0;
+
+	up(&adpt_configuration_lock);
+	return 0;
+}
+
+static int adpt_open(struct inode *inode, struct file *file)
+{
+	int minor;
+	adpt_hba* pHba;
+
+	//TODO check for root access
+	//
+	minor = iminor(inode);
+	if (minor >= hba_count) {
+		return -ENXIO;
+	}
+	down(&adpt_configuration_lock);
+	for (pHba = hba_chain; pHba; pHba = pHba->next) {
+		if (pHba->unit == minor) {
+			break;	/* found adapter */
+		}
+	}
+	if (pHba == NULL) {
+		up(&adpt_configuration_lock);
+		return -ENXIO;
+	}
+
+//	if(pHba->in_use){
+	//	up(&adpt_configuration_lock);
+//		return -EBUSY;
+//	}
+
+	pHba->in_use = 1;
+	up(&adpt_configuration_lock);
+
+	return 0;
+}
+
+static int adpt_close(struct inode *inode, struct file *file)
+{
+	int minor;
+	adpt_hba* pHba;
+
+	minor = iminor(inode);
+	if (minor >= hba_count) {
+		return -ENXIO;
+	}
+	down(&adpt_configuration_lock);
+	for (pHba = hba_chain; pHba; pHba = pHba->next) {
+		if (pHba->unit == minor) {
+			break;	/* found adapter */
+		}
+	}
+	up(&adpt_configuration_lock);
+	if (pHba == NULL) {
+		return -ENXIO;
+	}
+
+	pHba->in_use = 0;
+
+	return 0;
+}
+
+
+static int adpt_i2o_passthru(adpt_hba* pHba, u32 __user *arg)
+{
+	u32 msg[MAX_MESSAGE_SIZE];
+	u32* reply = NULL;
+	u32 size = 0;
+	u32 reply_size = 0;
+	u32 __user *user_msg = arg;
+	u32 __user * user_reply = NULL;
+	void *sg_list[pHba->sg_tablesize];
+	u32 sg_offset = 0;
+	u32 sg_count = 0;
+	int sg_index = 0;
+	u32 i = 0;
+	u32 rcode = 0;
+	void *p = NULL;
+	ulong flags = 0;
+
+	memset(&msg, 0, MAX_MESSAGE_SIZE*4);
+	// get user msg size in u32s 
+	if(get_user(size, &user_msg[0])){
+		return -EFAULT;
+	}
+	size = size>>16;
+
+	user_reply = &user_msg[size];
+	if(size > MAX_MESSAGE_SIZE){
+		return -EFAULT;
+	}
+	size *= 4; // Convert to bytes
+
+	/* Copy in the user's I2O command */
+	if(copy_from_user(msg, user_msg, size)) {
+		return -EFAULT;
+	}
+	get_user(reply_size, &user_reply[0]);
+	reply_size = reply_size>>16;
+	if(reply_size > REPLY_FRAME_SIZE){
+		reply_size = REPLY_FRAME_SIZE;
+	}
+	reply_size *= 4;
+	reply = kmalloc(REPLY_FRAME_SIZE*4, GFP_KERNEL);
+	if(reply == NULL) {
+		printk(KERN_WARNING"%s: Could not allocate reply buffer\n",pHba->name);
+		return -ENOMEM;
+	}
+	memset(reply,0,REPLY_FRAME_SIZE*4);
+	sg_offset = (msg[0]>>4)&0xf;
+	msg[2] = 0x40000000; // IOCTL context
+	msg[3] = (u32)reply;
+	memset(sg_list,0, sizeof(sg_list[0])*pHba->sg_tablesize);
+	if(sg_offset) {
+		// TODO 64bit fix
+		struct sg_simple_element *sg =  (struct sg_simple_element*) (msg+sg_offset);
+		sg_count = (size - sg_offset*4) / sizeof(struct sg_simple_element);
+		if (sg_count > pHba->sg_tablesize){
+			printk(KERN_DEBUG"%s:IOCTL SG List too large (%u)\n", pHba->name,sg_count);
+			kfree (reply);
+			return -EINVAL;
+		}
+
+		for(i = 0; i < sg_count; i++) {
+			int sg_size;
+
+			if (!(sg[i].flag_count & 0x10000000 /*I2O_SGL_FLAGS_SIMPLE_ADDRESS_ELEMENT*/)) {
+				printk(KERN_DEBUG"%s:Bad SG element %d - not simple (%x)\n",pHba->name,i,  sg[i].flag_count);
+				rcode = -EINVAL;
+				goto cleanup;
+			}
+			sg_size = sg[i].flag_count & 0xffffff;      
+			/* Allocate memory for the transfer */
+			p = kmalloc(sg_size, GFP_KERNEL|ADDR32);
+			if(!p) {
+				printk(KERN_DEBUG"%s: Could not allocate SG buffer - size = %d buffer number %d of %d\n",
+						pHba->name,sg_size,i,sg_count);
+				rcode = -ENOMEM;
+				goto cleanup;
+			}
+			sg_list[sg_index++] = p; // sglist indexed with input frame, not our internal frame.
+			/* Copy in the user's SG buffer if necessary */
+			if(sg[i].flag_count & 0x04000000 /*I2O_SGL_FLAGS_DIR*/) {
+				// TODO 64bit fix
+				if (copy_from_user(p,(void __user *)sg[i].addr_bus, sg_size)) {
+					printk(KERN_DEBUG"%s: Could not copy SG buf %d FROM user\n",pHba->name,i);
+					rcode = -EFAULT;
+					goto cleanup;
+				}
+			}
+			//TODO 64bit fix
+			sg[i].addr_bus = (u32)virt_to_bus(p);
+		}
+	}
+
+	do {
+		if(pHba->host)
+			spin_lock_irqsave(pHba->host->host_lock, flags);
+		// This state stops any new commands from enterring the
+		// controller while processing the ioctl
+//		pHba->state |= DPTI_STATE_IOCTL;
+//		We can't set this now - The scsi subsystem sets host_blocked and
+//		the queue empties and stops.  We need a way to restart the queue
+		rcode = adpt_i2o_post_wait(pHba, msg, size, FOREVER);
+		if (rcode != 0)
+			printk("adpt_i2o_passthru: post wait failed %d %p\n",
+					rcode, reply);
+//		pHba->state &= ~DPTI_STATE_IOCTL;
+		if(pHba->host)
+			spin_unlock_irqrestore(pHba->host->host_lock, flags);
+	} while(rcode == -ETIMEDOUT);  
+
+	if(rcode){
+		goto cleanup;
+	}
+
+	if(sg_offset) {
+	/* Copy back the Scatter Gather buffers back to user space */
+		u32 j;
+		// TODO 64bit fix
+		struct sg_simple_element* sg;
+		int sg_size;
+
+		// re-acquire the original message to handle correctly the sg copy operation
+		memset(&msg, 0, MAX_MESSAGE_SIZE*4); 
+		// get user msg size in u32s 
+		if(get_user(size, &user_msg[0])){
+			rcode = -EFAULT; 
+			goto cleanup; 
+		}
+		size = size>>16;
+		size *= 4;
+		/* Copy in the user's I2O command */
+		if (copy_from_user (msg, user_msg, size)) {
+			rcode = -EFAULT;
+			goto cleanup;
+		}
+		sg_count = (size - sg_offset*4) / sizeof(struct sg_simple_element);
+
+		// TODO 64bit fix
+		sg 	 = (struct sg_simple_element*)(msg + sg_offset);
+		for (j = 0; j < sg_count; j++) {
+			/* Copy out the SG list to user's buffer if necessary */
+			if(! (sg[j].flag_count & 0x4000000 /*I2O_SGL_FLAGS_DIR*/)) {
+				sg_size = sg[j].flag_count & 0xffffff; 
+				// TODO 64bit fix
+				if (copy_to_user((void __user *)sg[j].addr_bus,sg_list[j], sg_size)) {
+					printk(KERN_WARNING"%s: Could not copy %p TO user %x\n",pHba->name, sg_list[j], sg[j].addr_bus);
+					rcode = -EFAULT;
+					goto cleanup;
+				}
+			}
+		}
+	} 
+
+	/* Copy back the reply to user space */
+	if (reply_size) {
+		// we wrote our own values for context - now restore the user supplied ones
+		if(copy_from_user(reply+2, user_msg+2, sizeof(u32)*2)) {
+			printk(KERN_WARNING"%s: Could not copy message context FROM user\n",pHba->name);
+			rcode = -EFAULT;
+		}
+		if(copy_to_user(user_reply, reply, reply_size)) {
+			printk(KERN_WARNING"%s: Could not copy reply TO user\n",pHba->name);
+			rcode = -EFAULT;
+		}
+	}
+
+
+cleanup:
+	if (rcode != -ETIME && rcode != -EINTR)
+		kfree (reply);
+	while(sg_index) {
+		if(sg_list[--sg_index]) {
+			if (rcode != -ETIME && rcode != -EINTR)
+				kfree(sg_list[sg_index]);
+		}
+	}
+	return rcode;
+}
+
+
+/*
+ * This routine returns information about the system.  This does not effect
+ * any logic and if the info is wrong - it doesn't matter.
+ */
+
+/* Get all the info we can not get from kernel services */
+static int adpt_system_info(void __user *buffer)
+{
+	sysInfo_S si;
+
+	memset(&si, 0, sizeof(si));
+
+	si.osType = OS_LINUX;
+	si.osMajorVersion = (u8) (LINUX_VERSION_CODE >> 16);
+	si.osMinorVersion = (u8) (LINUX_VERSION_CODE >> 8 & 0x0ff);
+	si.osRevision =     (u8) (LINUX_VERSION_CODE & 0x0ff);
+	si.busType = SI_PCI_BUS;
+	si.processorFamily = DPTI_sig.dsProcessorFamily;
+
+#if defined __i386__ 
+	adpt_i386_info(&si);
+#elif defined (__ia64__)
+	adpt_ia64_info(&si);
+#elif defined(__sparc__)
+	adpt_sparc_info(&si);
+#elif defined (__alpha__)
+	adpt_alpha_info(&si);
+#else
+	si.processorType = 0xff ;
+#endif
+	if(copy_to_user(buffer, &si, sizeof(si))){
+		printk(KERN_WARNING"dpti: Could not copy buffer TO user\n");
+		return -EFAULT;
+	}
+
+	return 0;
+}
+
+#if defined __ia64__ 
+static void adpt_ia64_info(sysInfo_S* si)
+{
+	// This is all the info we need for now
+	// We will add more info as our new
+	// managmenent utility requires it
+	si->processorType = PROC_IA64;
+}
+#endif
+
+
+#if defined __sparc__ 
+static void adpt_sparc_info(sysInfo_S* si)
+{
+	// This is all the info we need for now
+	// We will add more info as our new
+	// managmenent utility requires it
+	si->processorType = PROC_ULTRASPARC;
+}
+#endif
+
+#if defined __alpha__ 
+static void adpt_alpha_info(sysInfo_S* si)
+{
+	// This is all the info we need for now
+	// We will add more info as our new
+	// managmenent utility requires it
+	si->processorType = PROC_ALPHA;
+}
+#endif
+
+#if defined __i386__
+
+static void adpt_i386_info(sysInfo_S* si)
+{
+	// This is all the info we need for now
+	// We will add more info as our new
+	// managmenent utility requires it
+	switch (boot_cpu_data.x86) {
+	case CPU_386:
+		si->processorType = PROC_386;
+		break;
+	case CPU_486:
+		si->processorType = PROC_486;
+		break;
+	case CPU_586:
+		si->processorType = PROC_PENTIUM;
+		break;
+	default:  // Just in case 
+		si->processorType = PROC_PENTIUM;
+		break;
+	}
+}
+
+#endif
+
+
+static int adpt_ioctl(struct inode *inode, struct file *file, uint cmd,
+	      ulong arg)
+{
+	int minor;
+	int error = 0;
+	adpt_hba* pHba;
+	ulong flags = 0;
+	void __user *argp = (void __user *)arg;
+
+	minor = iminor(inode);
+	if (minor >= DPTI_MAX_HBA){
+		return -ENXIO;
+	}
+	down(&adpt_configuration_lock);
+	for (pHba = hba_chain; pHba; pHba = pHba->next) {
+		if (pHba->unit == minor) {
+			break;	/* found adapter */
+		}
+	}
+	up(&adpt_configuration_lock);
+	if(pHba == NULL){
+		return -ENXIO;
+	}
+
+	while((volatile u32) pHba->state & DPTI_STATE_RESET ) {
+		set_task_state(current,TASK_UNINTERRUPTIBLE);
+		schedule_timeout(2);
+
+	}
+
+	switch (cmd) {
+	// TODO: handle 3 cases
+	case DPT_SIGNATURE:
+		if (copy_to_user(argp, &DPTI_sig, sizeof(DPTI_sig))) {
+			return -EFAULT;
+		}
+		break;
+	case I2OUSRCMD:
+		return adpt_i2o_passthru(pHba, argp);
+
+	case DPT_CTRLINFO:{
+		drvrHBAinfo_S HbaInfo;
+
+#define FLG_OSD_PCI_VALID 0x0001
+#define FLG_OSD_DMA	  0x0002
+#define FLG_OSD_I2O	  0x0004
+		memset(&HbaInfo, 0, sizeof(HbaInfo));
+		HbaInfo.drvrHBAnum = pHba->unit;
+		HbaInfo.baseAddr = (ulong) pHba->base_addr_phys;
+		HbaInfo.blinkState = adpt_read_blink_led(pHba);
+		HbaInfo.pciBusNum =  pHba->pDev->bus->number;
+		HbaInfo.pciDeviceNum=PCI_SLOT(pHba->pDev->devfn); 
+		HbaInfo.Interrupt = pHba->pDev->irq; 
+		HbaInfo.hbaFlags = FLG_OSD_PCI_VALID | FLG_OSD_DMA | FLG_OSD_I2O;
+		if(copy_to_user(argp, &HbaInfo, sizeof(HbaInfo))){
+			printk(KERN_WARNING"%s: Could not copy HbaInfo TO user\n",pHba->name);
+			return -EFAULT;
+		}
+		break;
+		}
+	case DPT_SYSINFO:
+		return adpt_system_info(argp);
+	case DPT_BLINKLED:{
+		u32 value;
+		value = (u32)adpt_read_blink_led(pHba);
+		if (copy_to_user(argp, &value, sizeof(value))) {
+			return -EFAULT;
+		}
+		break;
+		}
+	case I2ORESETCMD:
+		if(pHba->host)
+			spin_lock_irqsave(pHba->host->host_lock, flags);
+		adpt_hba_reset(pHba);
+		if(pHba->host)
+			spin_unlock_irqrestore(pHba->host->host_lock, flags);
+		break;
+	case I2ORESCANCMD:
+		adpt_rescan(pHba);
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	return error;
+}
+
+
+static irqreturn_t adpt_isr(int irq, void *dev_id, struct pt_regs *regs)
+{
+	struct scsi_cmnd* cmd;
+	adpt_hba* pHba = dev_id;
+	u32 m;
+	ulong reply;
+	u32 status=0;
+	u32 context;
+	ulong flags = 0;
+	int handled = 0;
+
+	if (pHba == NULL){
+		printk(KERN_WARNING"adpt_isr: NULL dev_id\n");
+		return IRQ_NONE;
+	}
+	if(pHba->host)
+		spin_lock_irqsave(pHba->host->host_lock, flags);
+
+	while( readl(pHba->irq_mask) & I2O_INTERRUPT_PENDING_B) {
+		m = readl(pHba->reply_port);
+		if(m == EMPTY_QUEUE){
+			// Try twice then give up
+			rmb();
+			m = readl(pHba->reply_port);
+			if(m == EMPTY_QUEUE){ 
+				// This really should not happen
+				printk(KERN_ERR"dpti: Could not get reply frame\n");
+				goto out;
+			}
+		}
+		reply = (ulong)bus_to_virt(m);
+
+		if (readl(reply) & MSG_FAIL) {
+			u32 old_m = readl(reply+28); 
+			ulong msg;
+			u32 old_context;
+			PDEBUG("%s: Failed message\n",pHba->name);
+			if(old_m >= 0x100000){
+				printk(KERN_ERR"%s: Bad preserved MFA (%x)- dropping frame\n",pHba->name,old_m);
+				writel(m,pHba->reply_port);
+				continue;
+			}
+			// Transaction context is 0 in failed reply frame
+			msg = (ulong)(pHba->msg_addr_virt + old_m);
+			old_context = readl(msg+12);
+			writel(old_context, reply+12);
+			adpt_send_nop(pHba, old_m);
+		} 
+		context = readl(reply+8);
+		if(context & 0x40000000){ // IOCTL
+			ulong p = (ulong)(readl(reply+12));
+			if( p != 0) {
+				memcpy((void*)p, (void*)reply, REPLY_FRAME_SIZE * 4);
+			}
+			// All IOCTLs will also be post wait
+		}
+		if(context & 0x80000000){ // Post wait message
+			status = readl(reply+16);
+			if(status  >> 24){
+				status &=  0xffff; /* Get detail status */
+			} else {
+				status = I2O_POST_WAIT_OK;
+			}
+			if(!(context & 0x40000000)) {
+				cmd = (struct scsi_cmnd*) readl(reply+12); 
+				if(cmd != NULL) {
+					printk(KERN_WARNING"%s: Apparent SCSI cmd in Post Wait Context - cmd=%p context=%x\n", pHba->name, cmd, context);
+				}
+			}
+			adpt_i2o_post_wait_complete(context, status);
+		} else { // SCSI message
+			cmd = (struct scsi_cmnd*) readl(reply+12); 
+			if(cmd != NULL){
+				if(cmd->serial_number != 0) { // If not timedout
+					adpt_i2o_to_scsi(reply, cmd);
+				}
+			}
+		}
+		writel(m, pHba->reply_port);
+		wmb();
+		rmb();
+	}
+	handled = 1;
+out:	if(pHba->host)
+		spin_unlock_irqrestore(pHba->host->host_lock, flags);
+	return IRQ_RETVAL(handled);
+}
+
+static s32 adpt_scsi_to_i2o(adpt_hba* pHba, struct scsi_cmnd* cmd, struct adpt_device* d)
+{
+	int i;
+	u32 msg[MAX_MESSAGE_SIZE];
+	u32* mptr;
+	u32 *lenptr;
+	int direction;
+	int scsidir;
+	u32 len;
+	u32 reqlen;
+	s32 rcode;
+
+	memset(msg, 0 , sizeof(msg));
+	len = cmd->request_bufflen;
+	direction = 0x00000000;	
+	
+	scsidir = 0x00000000;			// DATA NO XFER
+	if(len) {
+		/*
+		 * Set SCBFlags to indicate if data is being transferred
+		 * in or out, or no data transfer
+		 * Note:  Do not have to verify index is less than 0 since
+		 * cmd->cmnd[0] is an unsigned char
+		 */
+		switch(cmd->sc_data_direction){
+		case DMA_FROM_DEVICE:
+			scsidir  =0x40000000;	// DATA IN  (iop<--dev)
+			break;
+		case DMA_TO_DEVICE:
+			direction=0x04000000;	// SGL OUT
+			scsidir  =0x80000000;	// DATA OUT (iop-->dev)
+			break;
+		case DMA_NONE:
+			break;
+		case DMA_BIDIRECTIONAL:
+			scsidir  =0x40000000;	// DATA IN  (iop<--dev)
+			// Assume In - and continue;
+			break;
+		default:
+			printk(KERN_WARNING"%s: scsi opcode 0x%x not supported.\n",
+			     pHba->name, cmd->cmnd[0]);
+			cmd->result = (DID_OK <<16) | (INITIATOR_ERROR << 8);
+			cmd->scsi_done(cmd);
+			return 	0;
+		}
+	}
+	// msg[0] is set later
+	// I2O_CMD_SCSI_EXEC
+	msg[1] = ((0xff<<24)|(HOST_TID<<12)|d->tid);
+	msg[2] = 0;
+	msg[3] = (u32)cmd;	/* We want the SCSI control block back */
+	// Our cards use the transaction context as the tag for queueing
+	// Adaptec/DPT Private stuff 
+	msg[4] = I2O_CMD_SCSI_EXEC|(DPT_ORGANIZATION_ID<<16);
+	msg[5] = d->tid;
+	/* Direction, disconnect ok | sense data | simple queue , CDBLen */
+	// I2O_SCB_FLAG_ENABLE_DISCONNECT | 
+	// I2O_SCB_FLAG_SIMPLE_QUEUE_TAG | 
+	// I2O_SCB_FLAG_SENSE_DATA_IN_MESSAGE;
+	msg[6] = scsidir|0x20a00000|cmd->cmd_len;
+
+	mptr=msg+7;
+
+	// Write SCSI command into the message - always 16 byte block 
+	memset(mptr, 0,  16);
+	memcpy(mptr, cmd->cmnd, cmd->cmd_len);
+	mptr+=4;
+	lenptr=mptr++;		/* Remember me - fill in when we know */
+	reqlen = 14;		// SINGLE SGE
+	/* Now fill in the SGList and command */
+	if(cmd->use_sg) {
+		struct scatterlist *sg = (struct scatterlist *)cmd->request_buffer;
+		int sg_count = pci_map_sg(pHba->pDev, sg, cmd->use_sg,
+				cmd->sc_data_direction);
+
+
+		len = 0;
+		for(i = 0 ; i < sg_count; i++) {
+			*mptr++ = direction|0x10000000|sg_dma_len(sg);
+			len+=sg_dma_len(sg);
+			*mptr++ = sg_dma_address(sg);
+			sg++;
+		}
+		/* Make this an end of list */
+		mptr[-2] = direction|0xD0000000|sg_dma_len(sg-1);
+		reqlen = mptr - msg;
+		*lenptr = len;
+		
+		if(cmd->underflow && len != cmd->underflow){
+			printk(KERN_WARNING"Cmd len %08X Cmd underflow %08X\n",
+				len, cmd->underflow);
+		}
+	} else {
+		*lenptr = len = cmd->request_bufflen;
+		if(len == 0) {
+			reqlen = 12;
+		} else {
+			*mptr++ = 0xD0000000|direction|cmd->request_bufflen;
+			*mptr++ = pci_map_single(pHba->pDev,
+				cmd->request_buffer,
+				cmd->request_bufflen,
+				cmd->sc_data_direction);
+		}
+	}
+	
+	/* Stick the headers on */
+	msg[0] = reqlen<<16 | ((reqlen > 12) ? SGL_OFFSET_12 : SGL_OFFSET_0);
+	
+	// Send it on it's way
+	rcode = adpt_i2o_post_this(pHba, msg, reqlen<<2);
+	if (rcode == 0) {
+		return 0;
+	}
+	return rcode;
+}
+
+
+static s32 adpt_scsi_register(adpt_hba* pHba,struct scsi_host_template * sht)
+{
+	struct Scsi_Host *host = NULL;
+
+	host = scsi_register(sht, sizeof(adpt_hba*));
+	if (host == NULL) {
+		printk ("%s: scsi_register returned NULL\n",pHba->name);
+		return -1;
+	}
+	host->hostdata[0] = (unsigned long)pHba;
+	pHba->host = host;
+
+	host->irq = pHba->pDev->irq;
+	/* no IO ports, so don't have to set host->io_port and 
+	 * host->n_io_port
+	 */
+	host->io_port = 0;
+	host->n_io_port = 0;
+				/* see comments in hosts.h */
+	host->max_id = 16;
+	host->max_lun = 256;
+	host->max_channel = pHba->top_scsi_channel + 1;
+	host->cmd_per_lun = 1;
+	host->unique_id = (uint) pHba;
+	host->sg_tablesize = pHba->sg_tablesize;
+	host->can_queue = pHba->post_fifo_size;
+
+	return 0;
+}
+
+
+static s32 adpt_i2o_to_scsi(ulong reply, struct scsi_cmnd* cmd)
+{
+	adpt_hba* pHba;
+	u32 hba_status;
+	u32 dev_status;
+	u32 reply_flags = readl(reply) & 0xff00; // Leave it shifted up 8 bits 
+	// I know this would look cleaner if I just read bytes
+	// but the model I have been using for all the rest of the
+	// io is in 4 byte words - so I keep that model
+	u16 detailed_status = readl(reply+16) &0xffff;
+	dev_status = (detailed_status & 0xff);
+	hba_status = detailed_status >> 8;
+
+	// calculate resid for sg 
+	cmd->resid = cmd->request_bufflen - readl(reply+5);
+
+	pHba = (adpt_hba*) cmd->device->host->hostdata[0];
+
+	cmd->sense_buffer[0] = '\0';  // initialize sense valid flag to false
+
+	if(!(reply_flags & MSG_FAIL)) {
+		switch(detailed_status & I2O_SCSI_DSC_MASK) {
+		case I2O_SCSI_DSC_SUCCESS:
+			cmd->result = (DID_OK << 16);
+			// handle underflow
+			if(readl(reply+5) < cmd->underflow ) {
+				cmd->result = (DID_ERROR <<16);
+				printk(KERN_WARNING"%s: SCSI CMD underflow\n",pHba->name);
+			}
+			break;
+		case I2O_SCSI_DSC_REQUEST_ABORTED:
+			cmd->result = (DID_ABORT << 16);
+			break;
+		case I2O_SCSI_DSC_PATH_INVALID:
+		case I2O_SCSI_DSC_DEVICE_NOT_PRESENT:
+		case I2O_SCSI_DSC_SELECTION_TIMEOUT:
+		case I2O_SCSI_DSC_COMMAND_TIMEOUT:
+		case I2O_SCSI_DSC_NO_ADAPTER:
+		case I2O_SCSI_DSC_RESOURCE_UNAVAILABLE:
+			printk(KERN_WARNING"%s: SCSI Timeout-Device (%d,%d,%d) hba status=0x%x, dev status=0x%x, cmd=0x%x\n",
+				pHba->name, (u32)cmd->device->channel, (u32)cmd->device->id, (u32)cmd->device->lun, hba_status, dev_status, cmd->cmnd[0]);
+			cmd->result = (DID_TIME_OUT << 16);
+			break;
+		case I2O_SCSI_DSC_ADAPTER_BUSY:
+		case I2O_SCSI_DSC_BUS_BUSY:
+			cmd->result = (DID_BUS_BUSY << 16);
+			break;
+		case I2O_SCSI_DSC_SCSI_BUS_RESET:
+		case I2O_SCSI_DSC_BDR_MESSAGE_SENT:
+			cmd->result = (DID_RESET << 16);
+			break;
+		case I2O_SCSI_DSC_PARITY_ERROR_FAILURE:
+			printk(KERN_WARNING"%s: SCSI CMD parity error\n",pHba->name);
+			cmd->result = (DID_PARITY << 16);
+			break;
+		case I2O_SCSI_DSC_UNABLE_TO_ABORT:
+		case I2O_SCSI_DSC_COMPLETE_WITH_ERROR:
+		case I2O_SCSI_DSC_UNABLE_TO_TERMINATE:
+		case I2O_SCSI_DSC_MR_MESSAGE_RECEIVED:
+		case I2O_SCSI_DSC_AUTOSENSE_FAILED:
+		case I2O_SCSI_DSC_DATA_OVERRUN:
+		case I2O_SCSI_DSC_UNEXPECTED_BUS_FREE:
+		case I2O_SCSI_DSC_SEQUENCE_FAILURE:
+		case I2O_SCSI_DSC_REQUEST_LENGTH_ERROR:
+		case I2O_SCSI_DSC_PROVIDE_FAILURE:
+		case I2O_SCSI_DSC_REQUEST_TERMINATED:
+		case I2O_SCSI_DSC_IDE_MESSAGE_SENT:
+		case I2O_SCSI_DSC_UNACKNOWLEDGED_EVENT:
+		case I2O_SCSI_DSC_MESSAGE_RECEIVED:
+		case I2O_SCSI_DSC_INVALID_CDB:
+		case I2O_SCSI_DSC_LUN_INVALID:
+		case I2O_SCSI_DSC_SCSI_TID_INVALID:
+		case I2O_SCSI_DSC_FUNCTION_UNAVAILABLE:
+		case I2O_SCSI_DSC_NO_NEXUS:
+		case I2O_SCSI_DSC_CDB_RECEIVED:
+		case I2O_SCSI_DSC_LUN_ALREADY_ENABLED:
+		case I2O_SCSI_DSC_QUEUE_FROZEN:
+		case I2O_SCSI_DSC_REQUEST_INVALID:
+		default:
+			printk(KERN_WARNING"%s: SCSI error %0x-Device(%d,%d,%d) hba_status=0x%x, dev_status=0x%x, cmd=0x%x\n",
+				pHba->name, detailed_status & I2O_SCSI_DSC_MASK, (u32)cmd->device->channel, (u32)cmd->device->id, (u32)cmd->device->lun,
+			       hba_status, dev_status, cmd->cmnd[0]);
+			cmd->result = (DID_ERROR << 16);
+			break;
+		}
+
+		// copy over the request sense data if it was a check
+		// condition status
+		if(dev_status == 0x02 /*CHECK_CONDITION*/) {
+			u32 len = sizeof(cmd->sense_buffer);
+			len = (len > 40) ?  40 : len;
+			// Copy over the sense data
+			memcpy(cmd->sense_buffer, (void*)(reply+28) , len);
+			if(cmd->sense_buffer[0] == 0x70 /* class 7 */ && 
+			   cmd->sense_buffer[2] == DATA_PROTECT ){
+				/* This is to handle an array failed */
+				cmd->result = (DID_TIME_OUT << 16);
+				printk(KERN_WARNING"%s: SCSI Data Protect-Device (%d,%d,%d) hba_status=0x%x, dev_status=0x%x, cmd=0x%x\n",
+					pHba->name, (u32)cmd->device->channel, (u32)cmd->device->id, (u32)cmd->device->lun, 
+					hba_status, dev_status, cmd->cmnd[0]);
+
+			}
+		}
+	} else {
+		/* In this condtion we could not talk to the tid
+		 * the card rejected it.  We should signal a retry
+		 * for a limitted number of retries.
+		 */
+		cmd->result = (DID_TIME_OUT << 16);
+		printk(KERN_WARNING"%s: I2O MSG_FAIL - Device (%d,%d,%d) tid=%d, cmd=0x%x\n",
+			pHba->name, (u32)cmd->device->channel, (u32)cmd->device->id, (u32)cmd->device->lun,
+			((struct adpt_device*)(cmd->device->hostdata))->tid, cmd->cmnd[0]);
+	}
+
+	cmd->result |= (dev_status);
+
+	if(cmd->scsi_done != NULL){
+		cmd->scsi_done(cmd);
+	} 
+	return cmd->result;
+}
+
+
+static s32 adpt_rescan(adpt_hba* pHba)
+{
+	s32 rcode;
+	ulong flags = 0;
+
+	if(pHba->host)
+		spin_lock_irqsave(pHba->host->host_lock, flags);
+	if ((rcode=adpt_i2o_lct_get(pHba)) < 0)
+		goto out;
+	if ((rcode=adpt_i2o_reparse_lct(pHba)) < 0)
+		goto out;
+	rcode = 0;
+out:	if(pHba->host)
+		spin_unlock_irqrestore(pHba->host->host_lock, flags);
+	return rcode;
+}
+
+
+static s32 adpt_i2o_reparse_lct(adpt_hba* pHba)
+{
+	int i;
+	int max;
+	int tid;
+	struct i2o_device *d;
+	i2o_lct *lct = pHba->lct;
+	u8 bus_no = 0;
+	s16 scsi_id;
+	s16 scsi_lun;
+	u32 buf[10]; // at least 8 u32's
+	struct adpt_device* pDev = NULL;
+	struct i2o_device* pI2o_dev = NULL;
+	
+	if (lct == NULL) {
+		printk(KERN_ERR "%s: LCT is empty???\n",pHba->name);
+		return -1;
+	}
+	
+	max = lct->table_size;	
+	max -= 3;
+	max /= 9;
+
+	// Mark each drive as unscanned
+	for (d = pHba->devices; d; d = d->next) {
+		pDev =(struct adpt_device*) d->owner;
+		if(!pDev){
+			continue;
+		}
+		pDev->state |= DPTI_DEV_UNSCANNED;
+	}
+
+	printk(KERN_INFO "%s: LCT has %d entries.\n", pHba->name,max);
+	
+	for(i=0;i<max;i++) {
+		if( lct->lct_entry[i].user_tid != 0xfff){
+			continue;
+		}
+
+		if( lct->lct_entry[i].class_id == I2O_CLASS_RANDOM_BLOCK_STORAGE ||
+		    lct->lct_entry[i].class_id == I2O_CLASS_SCSI_PERIPHERAL ||
+		    lct->lct_entry[i].class_id == I2O_CLASS_FIBRE_CHANNEL_PERIPHERAL ){
+			tid = lct->lct_entry[i].tid;
+			if(adpt_i2o_query_scalar(pHba, tid, 0x8000, -1, buf, 32)<0) {
+				printk(KERN_ERR"%s: Could not query device\n",pHba->name);
+				continue;
+			}
+			bus_no = buf[0]>>16;
+			scsi_id = buf[1];
+			scsi_lun = (buf[2]>>8 )&0xff;
+			pDev = pHba->channel[bus_no].device[scsi_id];
+			/* da lun */
+			while(pDev) {
+				if(pDev->scsi_lun == scsi_lun) {
+					break;
+				}
+				pDev = pDev->next_lun;
+			}
+			if(!pDev ) { // Something new add it
+				d = (struct i2o_device *)kmalloc(sizeof(struct i2o_device), GFP_KERNEL);
+				if(d==NULL)
+				{
+					printk(KERN_CRIT "Out of memory for I2O device data.\n");
+					return -ENOMEM;
+				}
+				
+				d->controller = (void*)pHba;
+				d->next = NULL;
+
+				memcpy(&d->lct_data, &lct->lct_entry[i], sizeof(i2o_lct_entry));
+
+				d->flags = 0;
+				adpt_i2o_report_hba_unit(pHba, d);
+				adpt_i2o_install_device(pHba, d);
+	
+				if(bus_no >= MAX_CHANNEL) {	// Something wrong skip it
+					printk(KERN_WARNING"%s: Channel number %d out of range \n", pHba->name, bus_no);
+					continue;
+				}
+				pDev = pHba->channel[bus_no].device[scsi_id];	
+				if( pDev == NULL){
+					pDev =  kmalloc(sizeof(struct adpt_device),GFP_KERNEL);
+					if(pDev == NULL) {
+						return -ENOMEM;
+					}
+					pHba->channel[bus_no].device[scsi_id] = pDev;
+				} else {
+					while (pDev->next_lun) {
+						pDev = pDev->next_lun;
+					}
+					pDev = pDev->next_lun = kmalloc(sizeof(struct adpt_device),GFP_KERNEL);
+					if(pDev == NULL) {
+						return -ENOMEM;
+					}
+				}
+				memset(pDev,0,sizeof(struct adpt_device));
+				pDev->tid = d->lct_data.tid;
+				pDev->scsi_channel = bus_no;
+				pDev->scsi_id = scsi_id;
+				pDev->scsi_lun = scsi_lun;
+				pDev->pI2o_dev = d;
+				d->owner = pDev;
+				pDev->type = (buf[0])&0xff;
+				pDev->flags = (buf[0]>>8)&0xff;
+				// Too late, SCSI system has made up it's mind, but what the hey ...
+				if(scsi_id > pHba->top_scsi_id){
+					pHba->top_scsi_id = scsi_id;
+				}
+				if(scsi_lun > pHba->top_scsi_lun){
+					pHba->top_scsi_lun = scsi_lun;
+				}
+				continue;
+			} // end of new i2o device
+
+			// We found an old device - check it
+			while(pDev) {
+				if(pDev->scsi_lun == scsi_lun) {
+					if(!scsi_device_online(pDev->pScsi_dev)) {
+						printk(KERN_WARNING"%s: Setting device (%d,%d,%d) back online\n",
+								pHba->name,bus_no,scsi_id,scsi_lun);
+						if (pDev->pScsi_dev) {
+							scsi_device_set_state(pDev->pScsi_dev, SDEV_RUNNING);
+						}
+					}
+					d = pDev->pI2o_dev;
+					if(d->lct_data.tid != tid) { // something changed
+						pDev->tid = tid;
+						memcpy(&d->lct_data, &lct->lct_entry[i], sizeof(i2o_lct_entry));
+						if (pDev->pScsi_dev) {
+							pDev->pScsi_dev->changed = TRUE;
+							pDev->pScsi_dev->removable = TRUE;
+						}
+					}
+					// Found it - mark it scanned
+					pDev->state = DPTI_DEV_ONLINE;
+					break;
+				}
+				pDev = pDev->next_lun;
+			}
+		}
+	}
+	for (pI2o_dev = pHba->devices; pI2o_dev; pI2o_dev = pI2o_dev->next) {
+		pDev =(struct adpt_device*) pI2o_dev->owner;
+		if(!pDev){
+			continue;
+		}
+		// Drive offline drives that previously existed but could not be found
+		// in the LCT table
+		if (pDev->state & DPTI_DEV_UNSCANNED){
+			pDev->state = DPTI_DEV_OFFLINE;
+			printk(KERN_WARNING"%s: Device (%d,%d,%d) offline\n",pHba->name,pDev->scsi_channel,pDev->scsi_id,pDev->scsi_lun);
+			if (pDev->pScsi_dev) {
+				scsi_device_set_state(pDev->pScsi_dev, SDEV_OFFLINE);
+			}
+		}
+	}
+	return 0;
+}
+
+static void adpt_fail_posted_scbs(adpt_hba* pHba)
+{
+	struct scsi_cmnd* 	cmd = NULL;
+	struct scsi_device* 	d = NULL;
+
+	shost_for_each_device(d, pHba->host) {
+		unsigned long flags;
+		spin_lock_irqsave(&d->list_lock, flags);
+		list_for_each_entry(cmd, &d->cmd_list, list) {
+			if(cmd->serial_number == 0){
+				continue;
+			}
+			cmd->result = (DID_OK << 16) | (QUEUE_FULL <<1);
+			cmd->scsi_done(cmd);
+		}
+		spin_unlock_irqrestore(&d->list_lock, flags);
+	}
+}
+
+
+/*============================================================================
+ *  Routines from i2o subsystem
+ *============================================================================
+ */
+
+
+
+/*
+ *	Bring an I2O controller into HOLD state. See the spec.
+ */
+static int adpt_i2o_activate_hba(adpt_hba* pHba)
+{
+	int rcode;
+
+	if(pHba->initialized ) {
+		if (adpt_i2o_status_get(pHba) < 0) {
+			if((rcode = adpt_i2o_reset_hba(pHba)) != 0){
+				printk(KERN_WARNING"%s: Could NOT reset.\n", pHba->name);
+				return rcode;
+			}
+			if (adpt_i2o_status_get(pHba) < 0) {
+				printk(KERN_INFO "HBA not responding.\n");
+				return -1;
+			}
+		}
+
+		if(pHba->status_block->iop_state == ADAPTER_STATE_FAULTED) {
+			printk(KERN_CRIT "%s: hardware fault\n", pHba->name);
+			return -1;
+		}
+
+		if (pHba->status_block->iop_state == ADAPTER_STATE_READY ||
+		    pHba->status_block->iop_state == ADAPTER_STATE_OPERATIONAL ||
+		    pHba->status_block->iop_state == ADAPTER_STATE_HOLD ||
+		    pHba->status_block->iop_state == ADAPTER_STATE_FAILED) {
+			adpt_i2o_reset_hba(pHba);			
+			if (adpt_i2o_status_get(pHba) < 0 || pHba->status_block->iop_state != ADAPTER_STATE_RESET) {
+				printk(KERN_ERR "%s: Failed to initialize.\n", pHba->name);
+				return -1;
+			}
+		}
+	} else {
+		if((rcode = adpt_i2o_reset_hba(pHba)) != 0){
+			printk(KERN_WARNING"%s: Could NOT reset.\n", pHba->name);
+			return rcode;
+		}
+
+	}
+
+	if (adpt_i2o_init_outbound_q(pHba) < 0) {
+		return -1;
+	}
+
+	/* In HOLD state */
+	
+	if (adpt_i2o_hrt_get(pHba) < 0) {
+		return -1;
+	}
+
+	return 0;
+}
+
+/*
+ *	Bring a controller online into OPERATIONAL state. 
+ */
+ 
+static int adpt_i2o_online_hba(adpt_hba* pHba)
+{
+	if (adpt_i2o_systab_send(pHba) < 0) {
+		adpt_i2o_delete_hba(pHba);
+		return -1;
+	}
+	/* In READY state */
+
+	if (adpt_i2o_enable_hba(pHba) < 0) {
+		adpt_i2o_delete_hba(pHba);
+		return -1;
+	}
+
+	/* In OPERATIONAL state  */
+	return 0;
+}
+
+static s32 adpt_send_nop(adpt_hba*pHba,u32 m)
+{
+	u32 __iomem *msg;
+	ulong timeout = jiffies + 5*HZ;
+
+	while(m == EMPTY_QUEUE){
+		rmb();
+		m = readl(pHba->post_port);
+		if(m != EMPTY_QUEUE){
+			break;
+		}
+		if(time_after(jiffies,timeout)){
+			printk(KERN_ERR "%s: Timeout waiting for message frame!\n",pHba->name);
+			return 2;
+		}
+		set_current_state(TASK_UNINTERRUPTIBLE);
+		schedule_timeout(1);
+	}
+	msg = (u32 __iomem *)(pHba->msg_addr_virt + m);
+	writel( THREE_WORD_MSG_SIZE | SGL_OFFSET_0,&msg[0]);
+	writel( I2O_CMD_UTIL_NOP << 24 | HOST_TID << 12 | 0,&msg[1]);
+	writel( 0,&msg[2]);
+	wmb();
+
+	writel(m, pHba->post_port);
+	wmb();
+	return 0;
+}
+
+static s32 adpt_i2o_init_outbound_q(adpt_hba* pHba)
+{
+	u8 *status;
+	u32 __iomem *msg = NULL;
+	int i;
+	ulong timeout = jiffies + TMOUT_INITOUTBOUND*HZ;
+	u32* ptr;
+	u32 outbound_frame;  // This had to be a 32 bit address
+	u32 m;
+
+	do {
+		rmb();
+		m = readl(pHba->post_port);
+		if (m != EMPTY_QUEUE) {
+			break;
+		}
+
+		if(time_after(jiffies,timeout)){
+			printk(KERN_WARNING"%s: Timeout waiting for message frame\n",pHba->name);
+			return -ETIMEDOUT;
+		}
+		set_current_state(TASK_UNINTERRUPTIBLE);
+		schedule_timeout(1);
+	} while(m == EMPTY_QUEUE);
+
+	msg=(u32 __iomem *)(pHba->msg_addr_virt+m);
+
+	status = kmalloc(4,GFP_KERNEL|ADDR32);
+	if (status==NULL) {
+		adpt_send_nop(pHba, m);
+		printk(KERN_WARNING"%s: IOP reset failed - no free memory.\n",
+			pHba->name);
+		return -ENOMEM;
+	}
+	memset(status, 0, 4);
+
+	writel(EIGHT_WORD_MSG_SIZE| SGL_OFFSET_6, &msg[0]);
+	writel(I2O_CMD_OUTBOUND_INIT<<24 | HOST_TID<<12 | ADAPTER_TID, &msg[1]);
+	writel(0, &msg[2]);
+	writel(0x0106, &msg[3]);	/* Transaction context */
+	writel(4096, &msg[4]);		/* Host page frame size */
+	writel((REPLY_FRAME_SIZE)<<16|0x80, &msg[5]);	/* Outbound msg frame size and Initcode */
+	writel(0xD0000004, &msg[6]);		/* Simple SG LE, EOB */
+	writel(virt_to_bus(status), &msg[7]);
+
+	writel(m, pHba->post_port);
+	wmb();
+
+	// Wait for the reply status to come back
+	do {
+		if (*status) {
+			if (*status != 0x01 /*I2O_EXEC_OUTBOUND_INIT_IN_PROGRESS*/) {
+				break;
+			}
+		}
+		rmb();
+		if(time_after(jiffies,timeout)){
+			printk(KERN_WARNING"%s: Timeout Initializing\n",pHba->name);
+			return -ETIMEDOUT;
+		}
+		set_current_state(TASK_UNINTERRUPTIBLE);
+		schedule_timeout(1);
+	} while (1);
+
+	// If the command was successful, fill the fifo with our reply
+	// message packets
+	if(*status != 0x04 /*I2O_EXEC_OUTBOUND_INIT_COMPLETE*/) {
+		kfree((void*)status);
+		return -2;
+	}
+	kfree((void*)status);
+
+	if(pHba->reply_pool != NULL){
+		kfree(pHba->reply_pool);
+	}
+
+	pHba->reply_pool = (u32*)kmalloc(pHba->reply_fifo_size * REPLY_FRAME_SIZE * 4, GFP_KERNEL|ADDR32);
+	if(!pHba->reply_pool){
+		printk(KERN_ERR"%s: Could not allocate reply pool\n",pHba->name);
+		return -1;
+	}
+	memset(pHba->reply_pool, 0 , pHba->reply_fifo_size * REPLY_FRAME_SIZE * 4);
+
+	ptr = pHba->reply_pool;
+	for(i = 0; i < pHba->reply_fifo_size; i++) {
+		outbound_frame = (u32)virt_to_bus(ptr);
+		writel(outbound_frame, pHba->reply_port);
+		wmb();
+		ptr +=  REPLY_FRAME_SIZE;
+	}
+	adpt_i2o_status_get(pHba);
+	return 0;
+}
+
+
+/*
+ * I2O System Table.  Contains information about
+ * all the IOPs in the system.  Used to inform IOPs
+ * about each other's existence.
+ *
+ * sys_tbl_ver is the CurrentChangeIndicator that is
+ * used by IOPs to track changes.
+ */
+
+
+
+static s32 adpt_i2o_status_get(adpt_hba* pHba)
+{
+	ulong timeout;
+	u32 m;
+	u32 __iomem *msg;
+	u8 *status_block=NULL;
+	ulong status_block_bus;
+
+	if(pHba->status_block == NULL) {
+		pHba->status_block = (i2o_status_block*)
+			kmalloc(sizeof(i2o_status_block),GFP_KERNEL|ADDR32);
+		if(pHba->status_block == NULL) {
+			printk(KERN_ERR
+			"dpti%d: Get Status Block failed; Out of memory. \n", 
+			pHba->unit);
+			return -ENOMEM;
+		}
+	}
+	memset(pHba->status_block, 0, sizeof(i2o_status_block));
+	status_block = (u8*)(pHba->status_block);
+	status_block_bus = virt_to_bus(pHba->status_block);
+	timeout = jiffies+TMOUT_GETSTATUS*HZ;
+	do {
+		rmb();
+		m = readl(pHba->post_port);
+		if (m != EMPTY_QUEUE) {
+			break;
+		}
+		if(time_after(jiffies,timeout)){
+			printk(KERN_ERR "%s: Timeout waiting for message !\n",
+					pHba->name);
+			return -ETIMEDOUT;
+		}
+		set_current_state(TASK_UNINTERRUPTIBLE);
+		schedule_timeout(1);
+	} while(m==EMPTY_QUEUE);
+
+	
+	msg=(u32 __iomem *)(pHba->msg_addr_virt+m);
+
+	writel(NINE_WORD_MSG_SIZE|SGL_OFFSET_0, &msg[0]);
+	writel(I2O_CMD_STATUS_GET<<24|HOST_TID<<12|ADAPTER_TID, &msg[1]);
+	writel(1, &msg[2]);
+	writel(0, &msg[3]);
+	writel(0, &msg[4]);
+	writel(0, &msg[5]);
+	writel(((u32)status_block_bus)&0xffffffff, &msg[6]);
+	writel(0, &msg[7]);
+	writel(sizeof(i2o_status_block), &msg[8]); // 88 bytes
+
+	//post message
+	writel(m, pHba->post_port);
+	wmb();
+
+	while(status_block[87]!=0xff){
+		if(time_after(jiffies,timeout)){
+			printk(KERN_ERR"dpti%d: Get status timeout.\n",
+				pHba->unit);
+			return -ETIMEDOUT;
+		}
+		rmb();
+		set_current_state(TASK_UNINTERRUPTIBLE);
+		schedule_timeout(1);
+	}
+
+	// Set up our number of outbound and inbound messages
+	pHba->post_fifo_size = pHba->status_block->max_inbound_frames;
+	if (pHba->post_fifo_size > MAX_TO_IOP_MESSAGES) {
+		pHba->post_fifo_size = MAX_TO_IOP_MESSAGES;
+	}
+
+	pHba->reply_fifo_size = pHba->status_block->max_outbound_frames;
+	if (pHba->reply_fifo_size > MAX_FROM_IOP_MESSAGES) {
+		pHba->reply_fifo_size = MAX_FROM_IOP_MESSAGES;
+	}
+
+	// Calculate the Scatter Gather list size
+	pHba->sg_tablesize = (pHba->status_block->inbound_frame_size * 4 -40)/ sizeof(struct sg_simple_element);
+	if (pHba->sg_tablesize > SG_LIST_ELEMENTS) {
+		pHba->sg_tablesize = SG_LIST_ELEMENTS;
+	}
+
+
+#ifdef DEBUG
+	printk("dpti%d: State = ",pHba->unit);
+	switch(pHba->status_block->iop_state) {
+		case 0x01:
+			printk("INIT\n");
+			break;
+		case 0x02:
+			printk("RESET\n");
+			break;
+		case 0x04:
+			printk("HOLD\n");
+			break;
+		case 0x05:
+			printk("READY\n");
+			break;
+		case 0x08:
+			printk("OPERATIONAL\n");
+			break;
+		case 0x10:
+			printk("FAILED\n");
+			break;
+		case 0x11:
+			printk("FAULTED\n");
+			break;
+		default:
+			printk("%x (unknown!!)\n",pHba->status_block->iop_state);
+	}
+#endif
+	return 0;
+}
+
+/*
+ * Get the IOP's Logical Configuration Table
+ */
+static int adpt_i2o_lct_get(adpt_hba* pHba)
+{
+	u32 msg[8];
+	int ret;
+	u32 buf[16];
+
+	if ((pHba->lct_size == 0) || (pHba->lct == NULL)){
+		pHba->lct_size = pHba->status_block->expected_lct_size;
+	}
+	do {
+		if (pHba->lct == NULL) {
+			pHba->lct = kmalloc(pHba->lct_size, GFP_KERNEL|ADDR32);
+			if(pHba->lct == NULL) {
+				printk(KERN_CRIT "%s: Lct Get failed. Out of memory.\n",
+					pHba->name);
+				return -ENOMEM;
+			}
+		}
+		memset(pHba->lct, 0, pHba->lct_size);
+
+		msg[0] = EIGHT_WORD_MSG_SIZE|SGL_OFFSET_6;
+		msg[1] = I2O_CMD_LCT_NOTIFY<<24 | HOST_TID<<12 | ADAPTER_TID;
+		msg[2] = 0;
+		msg[3] = 0;
+		msg[4] = 0xFFFFFFFF;	/* All devices */
+		msg[5] = 0x00000000;	/* Report now */
+		msg[6] = 0xD0000000|pHba->lct_size;
+		msg[7] = virt_to_bus(pHba->lct);
+
+		if ((ret=adpt_i2o_post_wait(pHba, msg, sizeof(msg), 360))) {
+			printk(KERN_ERR "%s: LCT Get failed (status=%#10x.\n", 
+				pHba->name, ret);	
+			printk(KERN_ERR"Adaptec: Error Reading Hardware.\n");
+			return ret;
+		}
+
+		if ((pHba->lct->table_size << 2) > pHba->lct_size) {
+			pHba->lct_size = pHba->lct->table_size << 2;
+			kfree(pHba->lct);
+			pHba->lct = NULL;
+		}
+	} while (pHba->lct == NULL);
+
+	PDEBUG("%s: Hardware resource table read.\n", pHba->name);
+
+
+	// I2O_DPT_EXEC_IOP_BUFFERS_GROUP_NO;
+	if(adpt_i2o_query_scalar(pHba, 0 , 0x8000, -1, buf, sizeof(buf))>=0) {
+		pHba->FwDebugBufferSize = buf[1];
+		pHba->FwDebugBuffer_P    = pHba->base_addr_virt + buf[0];
+		pHba->FwDebugFlags_P     = pHba->FwDebugBuffer_P + FW_DEBUG_FLAGS_OFFSET;
+		pHba->FwDebugBLEDvalue_P = pHba->FwDebugBuffer_P + FW_DEBUG_BLED_OFFSET;
+		pHba->FwDebugBLEDflag_P  = pHba->FwDebugBLEDvalue_P + 1;
+		pHba->FwDebugStrLength_P = pHba->FwDebugBuffer_P + FW_DEBUG_STR_LENGTH_OFFSET;
+		pHba->FwDebugBuffer_P += buf[2]; 
+		pHba->FwDebugFlags = 0;
+	}
+
+	return 0;
+}
+
+static int adpt_i2o_build_sys_table(void)
+{
+	adpt_hba* pHba = NULL;
+	int count = 0;
+
+	sys_tbl_len = sizeof(struct i2o_sys_tbl) +	// Header + IOPs
+				(hba_count) * sizeof(struct i2o_sys_tbl_entry);
+
+	if(sys_tbl)
+		kfree(sys_tbl);
+
+	sys_tbl = kmalloc(sys_tbl_len, GFP_KERNEL|ADDR32);
+	if(!sys_tbl) {
+		printk(KERN_WARNING "SysTab Set failed. Out of memory.\n");	
+		return -ENOMEM;
+	}
+	memset(sys_tbl, 0, sys_tbl_len);
+
+	sys_tbl->num_entries = hba_count;
+	sys_tbl->version = I2OVERSION;
+	sys_tbl->change_ind = sys_tbl_ind++;
+
+	for(pHba = hba_chain; pHba; pHba = pHba->next) {
+		// Get updated Status Block so we have the latest information
+		if (adpt_i2o_status_get(pHba)) {
+			sys_tbl->num_entries--;
+			continue; // try next one	
+		}
+
+		sys_tbl->iops[count].org_id = pHba->status_block->org_id;
+		sys_tbl->iops[count].iop_id = pHba->unit + 2;
+		sys_tbl->iops[count].seg_num = 0;
+		sys_tbl->iops[count].i2o_version = pHba->status_block->i2o_version;
+		sys_tbl->iops[count].iop_state = pHba->status_block->iop_state;
+		sys_tbl->iops[count].msg_type = pHba->status_block->msg_type;
+		sys_tbl->iops[count].frame_size = pHba->status_block->inbound_frame_size;
+		sys_tbl->iops[count].last_changed = sys_tbl_ind - 1; // ??
+		sys_tbl->iops[count].iop_capabilities = pHba->status_block->iop_capabilities;
+		sys_tbl->iops[count].inbound_low = (u32)virt_to_bus((void*)pHba->post_port);
+		sys_tbl->iops[count].inbound_high = (u32)((u64)virt_to_bus((void*)pHba->post_port)>>32);
+
+		count++;
+	}
+
+#ifdef DEBUG
+{
+	u32 *table = (u32*)sys_tbl;
+	printk(KERN_DEBUG"sys_tbl_len=%d in 32bit words\n",(sys_tbl_len >>2));
+	for(count = 0; count < (sys_tbl_len >>2); count++) {
+		printk(KERN_INFO "sys_tbl[%d] = %0#10x\n", 
+			count, table[count]);
+	}
+}
+#endif
+
+	return 0;
+}
+
+
+/*
+ *	 Dump the information block associated with a given unit (TID)
+ */
+ 
+static void adpt_i2o_report_hba_unit(adpt_hba* pHba, struct i2o_device *d)
+{
+	char buf[64];
+	int unit = d->lct_data.tid;
+
+	printk(KERN_INFO "TID %3.3d ", unit);
+
+	if(adpt_i2o_query_scalar(pHba, unit, 0xF100, 3, buf, 16)>=0)
+	{
+		buf[16]=0;
+		printk(" Vendor: %-12.12s", buf);
+	}
+	if(adpt_i2o_query_scalar(pHba, unit, 0xF100, 4, buf, 16)>=0)
+	{
+		buf[16]=0;
+		printk(" Device: %-12.12s", buf);
+	}
+	if(adpt_i2o_query_scalar(pHba, unit, 0xF100, 6, buf, 8)>=0)
+	{
+		buf[8]=0;
+		printk(" Rev: %-12.12s\n", buf);
+	}
+#ifdef DEBUG
+	 printk(KERN_INFO "\tClass: %.21s\n", adpt_i2o_get_class_name(d->lct_data.class_id));
+	 printk(KERN_INFO "\tSubclass: 0x%04X\n", d->lct_data.sub_class);
+	 printk(KERN_INFO "\tFlags: ");
+
+	 if(d->lct_data.device_flags&(1<<0))
+		  printk("C");	     // ConfigDialog requested
+	 if(d->lct_data.device_flags&(1<<1))
+		  printk("U");	     // Multi-user capable
+	 if(!(d->lct_data.device_flags&(1<<4)))
+		  printk("P");	     // Peer service enabled!
+	 if(!(d->lct_data.device_flags&(1<<5)))
+		  printk("M");	     // Mgmt service enabled!
+	 printk("\n");
+#endif
+}
+
+#ifdef DEBUG
+/*
+ *	Do i2o class name lookup
+ */
+static const char *adpt_i2o_get_class_name(int class)
+{
+	int idx = 16;
+	static char *i2o_class_name[] = {
+		"Executive",
+		"Device Driver Module",
+		"Block Device",
+		"Tape Device",
+		"LAN Interface",
+		"WAN Interface",
+		"Fibre Channel Port",
+		"Fibre Channel Device",
+		"SCSI Device",
+		"ATE Port",
+		"ATE Device",
+		"Floppy Controller",
+		"Floppy Device",
+		"Secondary Bus Port",
+		"Peer Transport Agent",
+		"Peer Transport",
+		"Unknown"
+	};
+	
+	switch(class&0xFFF) {
+	case I2O_CLASS_EXECUTIVE:
+		idx = 0; break;
+	case I2O_CLASS_DDM:
+		idx = 1; break;
+	case I2O_CLASS_RANDOM_BLOCK_STORAGE:
+		idx = 2; break;
+	case I2O_CLASS_SEQUENTIAL_STORAGE:
+		idx = 3; break;
+	case I2O_CLASS_LAN:
+		idx = 4; break;
+	case I2O_CLASS_WAN:
+		idx = 5; break;
+	case I2O_CLASS_FIBRE_CHANNEL_PORT:
+		idx = 6; break;
+	case I2O_CLASS_FIBRE_CHANNEL_PERIPHERAL:
+		idx = 7; break;
+	case I2O_CLASS_SCSI_PERIPHERAL:
+		idx = 8; break;
+	case I2O_CLASS_ATE_PORT:
+		idx = 9; break;
+	case I2O_CLASS_ATE_PERIPHERAL:
+		idx = 10; break;
+	case I2O_CLASS_FLOPPY_CONTROLLER:
+		idx = 11; break;
+	case I2O_CLASS_FLOPPY_DEVICE:
+		idx = 12; break;
+	case I2O_CLASS_BUS_ADAPTER_PORT:
+		idx = 13; break;
+	case I2O_CLASS_PEER_TRANSPORT_AGENT:
+		idx = 14; break;
+	case I2O_CLASS_PEER_TRANSPORT:
+		idx = 15; break;
+	}
+	return i2o_class_name[idx];
+}
+#endif
+
+
+static s32 adpt_i2o_hrt_get(adpt_hba* pHba)
+{
+	u32 msg[6];
+	int ret, size = sizeof(i2o_hrt);
+
+	do {
+		if (pHba->hrt == NULL) {
+			pHba->hrt=kmalloc(size, GFP_KERNEL|ADDR32);
+			if (pHba->hrt == NULL) {
+				printk(KERN_CRIT "%s: Hrt Get failed; Out of memory.\n", pHba->name);
+				return -ENOMEM;
+			}
+		}
+
+		msg[0]= SIX_WORD_MSG_SIZE| SGL_OFFSET_4;
+		msg[1]= I2O_CMD_HRT_GET<<24 | HOST_TID<<12 | ADAPTER_TID;
+		msg[2]= 0;
+		msg[3]= 0;
+		msg[4]= (0xD0000000 | size);    /* Simple transaction */
+		msg[5]= virt_to_bus(pHba->hrt);   /* Dump it here */
+
+		if ((ret = adpt_i2o_post_wait(pHba, msg, sizeof(msg),20))) {
+			printk(KERN_ERR "%s: Unable to get HRT (status=%#10x)\n", pHba->name, ret);
+			return ret;
+		}
+
+		if (pHba->hrt->num_entries * pHba->hrt->entry_len << 2 > size) {
+			size = pHba->hrt->num_entries * pHba->hrt->entry_len << 2;
+			kfree(pHba->hrt);
+			pHba->hrt = NULL;
+		}
+	} while(pHba->hrt == NULL);
+	return 0;
+}                                                                                                                                       
+
+/*
+ *	 Query one scalar group value or a whole scalar group.
+ */		    	
+static int adpt_i2o_query_scalar(adpt_hba* pHba, int tid, 
+			int group, int field, void *buf, int buflen)
+{
+	u16 opblk[] = { 1, 0, I2O_PARAMS_FIELD_GET, group, 1, field };
+	u8 *resblk;
+
+	int size;
+
+	/* 8 bytes for header */
+	resblk = kmalloc(sizeof(u8) * (8+buflen), GFP_KERNEL|ADDR32);
+	if (resblk == NULL) {
+		printk(KERN_CRIT "%s: query scalar failed; Out of memory.\n", pHba->name);
+		return -ENOMEM;
+	}
+
+	if (field == -1)  		/* whole group */
+			opblk[4] = -1;
+
+	size = adpt_i2o_issue_params(I2O_CMD_UTIL_PARAMS_GET, pHba, tid, 
+		opblk, sizeof(opblk), resblk, sizeof(u8)*(8+buflen));
+	if (size == -ETIME) {
+		printk(KERN_WARNING "%s: issue params failed; Timed out.\n", pHba->name);
+		return -ETIME;
+	} else if (size == -EINTR) {
+		printk(KERN_WARNING "%s: issue params failed; Interrupted.\n", pHba->name);
+		return -EINTR;
+	}
+			
+	memcpy(buf, resblk+8, buflen);  /* cut off header */
+
+	kfree(resblk);
+	if (size < 0)
+		return size;	
+
+	return buflen;
+}
+
+
+/*	Issue UTIL_PARAMS_GET or UTIL_PARAMS_SET
+ *
+ *	This function can be used for all UtilParamsGet/Set operations.
+ *	The OperationBlock is given in opblk-buffer, 
+ *	and results are returned in resblk-buffer.
+ *	Note that the minimum sized resblk is 8 bytes and contains
+ *	ResultCount, ErrorInfoSize, BlockStatus and BlockSize.
+ */
+static int adpt_i2o_issue_params(int cmd, adpt_hba* pHba, int tid, 
+		  void *opblk, int oplen, void *resblk, int reslen)
+{
+	u32 msg[9]; 
+	u32 *res = (u32 *)resblk;
+	int wait_status;
+
+	msg[0] = NINE_WORD_MSG_SIZE | SGL_OFFSET_5;
+	msg[1] = cmd << 24 | HOST_TID << 12 | tid; 
+	msg[2] = 0;
+	msg[3] = 0;
+	msg[4] = 0;
+	msg[5] = 0x54000000 | oplen;	/* OperationBlock */
+	msg[6] = virt_to_bus(opblk);
+	msg[7] = 0xD0000000 | reslen;	/* ResultBlock */
+	msg[8] = virt_to_bus(resblk);
+
+	if ((wait_status = adpt_i2o_post_wait(pHba, msg, sizeof(msg), 20))) {
+		printk("adpt_i2o_issue_params: post_wait failed (%p)\n", resblk);
+   		return wait_status; 	/* -DetailedStatus */
+	}
+
+	if (res[1]&0x00FF0000) { 	/* BlockStatus != SUCCESS */
+		printk(KERN_WARNING "%s: %s - Error:\n  ErrorInfoSize = 0x%02x, "
+			"BlockStatus = 0x%02x, BlockSize = 0x%04x\n",
+			pHba->name,
+			(cmd == I2O_CMD_UTIL_PARAMS_SET) ? "PARAMS_SET"
+							 : "PARAMS_GET",   
+			res[1]>>24, (res[1]>>16)&0xFF, res[1]&0xFFFF);
+		return -((res[1] >> 16) & 0xFF); /* -BlockStatus */
+	}
+
+	 return 4 + ((res[1] & 0x0000FFFF) << 2); /* bytes used in resblk */ 
+}
+
+
+static s32 adpt_i2o_quiesce_hba(adpt_hba* pHba)
+{
+	u32 msg[4];
+	int ret;
+
+	adpt_i2o_status_get(pHba);
+
+	/* SysQuiesce discarded if IOP not in READY or OPERATIONAL state */
+
+	if((pHba->status_block->iop_state != ADAPTER_STATE_READY) &&
+   	   (pHba->status_block->iop_state != ADAPTER_STATE_OPERATIONAL)){
+		return 0;
+	}
+
+	msg[0] = FOUR_WORD_MSG_SIZE|SGL_OFFSET_0;
+	msg[1] = I2O_CMD_SYS_QUIESCE<<24|HOST_TID<<12|ADAPTER_TID;
+	msg[2] = 0;
+	msg[3] = 0;
+
+	if((ret = adpt_i2o_post_wait(pHba, msg, sizeof(msg), 240))) {
+		printk(KERN_INFO"dpti%d: Unable to quiesce (status=%#x).\n",
+				pHba->unit, -ret);
+	} else {
+		printk(KERN_INFO"dpti%d: Quiesced.\n",pHba->unit);
+	}
+
+	adpt_i2o_status_get(pHba);
+	return ret;
+}
+
+
+/* 
+ * Enable IOP. Allows the IOP to resume external operations.
+ */
+static int adpt_i2o_enable_hba(adpt_hba* pHba)
+{
+	u32 msg[4];
+	int ret;
+	
+	adpt_i2o_status_get(pHba);
+	if(!pHba->status_block){
+		return -ENOMEM;
+	}
+	/* Enable only allowed on READY state */
+	if(pHba->status_block->iop_state == ADAPTER_STATE_OPERATIONAL)
+		return 0;
+
+	if(pHba->status_block->iop_state != ADAPTER_STATE_READY)
+		return -EINVAL;
+
+	msg[0]=FOUR_WORD_MSG_SIZE|SGL_OFFSET_0;
+	msg[1]=I2O_CMD_SYS_ENABLE<<24|HOST_TID<<12|ADAPTER_TID;
+	msg[2]= 0;
+	msg[3]= 0;
+
+	if ((ret = adpt_i2o_post_wait(pHba, msg, sizeof(msg), 240))) {
+		printk(KERN_WARNING"%s: Could not enable (status=%#10x).\n", 
+			pHba->name, ret);
+	} else {
+		PDEBUG("%s: Enabled.\n", pHba->name);
+	}
+
+	adpt_i2o_status_get(pHba);
+	return ret;
+}
+
+
+static int adpt_i2o_systab_send(adpt_hba* pHba)
+{
+	 u32 msg[12];
+	 int ret;
+
+	msg[0] = I2O_MESSAGE_SIZE(12) | SGL_OFFSET_6;
+	msg[1] = I2O_CMD_SYS_TAB_SET<<24 | HOST_TID<<12 | ADAPTER_TID;
+	msg[2] = 0;
+	msg[3] = 0;
+	msg[4] = (0<<16) | ((pHba->unit+2) << 12); /* Host 0 IOP ID (unit + 2) */
+	msg[5] = 0;				   /* Segment 0 */
+
+	/* 
+	 * Provide three SGL-elements:
+	 * System table (SysTab), Private memory space declaration and 
+	 * Private i/o space declaration  
+	 */
+	msg[6] = 0x54000000 | sys_tbl_len;
+	msg[7] = virt_to_phys(sys_tbl);
+	msg[8] = 0x54000000 | 0;
+	msg[9] = 0;
+	msg[10] = 0xD4000000 | 0;
+	msg[11] = 0;
+
+	if ((ret=adpt_i2o_post_wait(pHba, msg, sizeof(msg), 120))) {
+		printk(KERN_INFO "%s: Unable to set SysTab (status=%#10x).\n", 
+			pHba->name, ret);
+	}
+#ifdef DEBUG
+	else {
+		PINFO("%s: SysTab set.\n", pHba->name);
+	}
+#endif
+
+	return ret;	
+ }
+
+
+/*============================================================================
+ *
+ *============================================================================
+ */
+
+
+#ifdef UARTDELAY 
+
+static static void adpt_delay(int millisec)
+{
+	int i;
+	for (i = 0; i < millisec; i++) {
+		udelay(1000);	/* delay for one millisecond */
+	}
+}
+
+#endif
+
+static struct scsi_host_template driver_template = {
+	.name			= "dpt_i2o",
+	.proc_name		= "dpt_i2o",
+	.proc_info		= adpt_proc_info,
+	.detect			= adpt_detect,	
+	.release		= adpt_release,
+	.info			= adpt_info,
+	.queuecommand		= adpt_queue,
+	.eh_abort_handler	= adpt_abort,
+	.eh_device_reset_handler = adpt_device_reset,
+	.eh_bus_reset_handler	= adpt_bus_reset,
+	.eh_host_reset_handler	= adpt_reset,
+	.bios_param		= adpt_bios_param,
+	.slave_configure	= adpt_slave_configure,
+	.can_queue		= MAX_TO_IOP_MESSAGES,
+	.this_id		= 7,
+	.cmd_per_lun		= 1,
+	.use_clustering		= ENABLE_CLUSTERING,
+};
+#include "scsi_module.c"
+MODULE_LICENSE("GPL");
