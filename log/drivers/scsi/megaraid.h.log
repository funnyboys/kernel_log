commit 91ebc1facd7797d799a4c9208cb7fdc8d86e0bb4
Author: Johannes Thumshirn <jthumshirn@suse.de>
Date:   Wed Jun 13 09:53:47 2018 +0200

    scsi: core: remove Scsi_Cmnd typedef
    
    This will make subsequent refactoring easier to handle.
    
    Note: this patch is nowhere checkpatch clean.
    
    Signed-off-by: Johannes Thumshirn <jthumshirn@suse.de>
    Reviewed-by: Bart Van Assche <bart.vanassche@wdc.com>
    Reviewed-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/megaraid.h b/drivers/scsi/megaraid.h
index 18e85d9267ff..cce23a086fbe 100644
--- a/drivers/scsi/megaraid.h
+++ b/drivers/scsi/megaraid.h
@@ -191,7 +191,7 @@ typedef struct {
 	u32	dma_type;
 	u32	dma_direction;
 
-	Scsi_Cmnd	*cmd;
+	struct scsi_cmnd	*cmd;
 	dma_addr_t	dma_h_bulkdata;
 	dma_addr_t	dma_h_sgdata;
 
@@ -942,7 +942,7 @@ static int issue_scb(adapter_t *, scb_t *);
 static int mega_setup_mailbox(adapter_t *);
 
 static int megaraid_queue (struct Scsi_Host *, struct scsi_cmnd *);
-static scb_t * mega_build_cmd(adapter_t *, Scsi_Cmnd *, int *);
+static scb_t * mega_build_cmd(adapter_t *, struct scsi_cmnd *, int *);
 static void __mega_runpendq(adapter_t *);
 static int issue_scb_block(adapter_t *, u_char *);
 
@@ -951,9 +951,9 @@ static irqreturn_t megaraid_isr_iomapped(int, void *);
 
 static void mega_free_scb(adapter_t *, scb_t *);
 
-static int megaraid_abort(Scsi_Cmnd *);
-static int megaraid_reset(Scsi_Cmnd *);
-static int megaraid_abort_and_reset(adapter_t *, Scsi_Cmnd *, int);
+static int megaraid_abort(struct scsi_cmnd *);
+static int megaraid_reset(struct scsi_cmnd *);
+static int megaraid_abort_and_reset(adapter_t *, struct scsi_cmnd *, int);
 static int megaraid_biosparam(struct scsi_device *, struct block_device *,
 		sector_t, int []);
 
@@ -983,9 +983,9 @@ static int mega_internal_dev_inquiry(adapter_t *, u8, u8, dma_addr_t);
 
 static int mega_support_ext_cdb(adapter_t *);
 static mega_passthru* mega_prepare_passthru(adapter_t *, scb_t *,
-		Scsi_Cmnd *, int, int);
+		struct scsi_cmnd *, int, int);
 static mega_ext_passthru* mega_prepare_extpassthru(adapter_t *,
-		scb_t *, Scsi_Cmnd *, int, int);
+		scb_t *, struct scsi_cmnd *, int, int);
 static void mega_enum_raid_scsi(adapter_t *);
 static void mega_get_boot_drv(adapter_t *);
 static int mega_support_random_del(adapter_t *);

commit f7680bec0456403b4d3d7720e00b95586a7bc26b
Author: Christoph Hellwig <hch@lst.de>
Date:   Fri Apr 13 20:57:56 2018 +0200

    megaraid: simplify procfs code
    
    Use remove_proc_subtree to remove the whole subtree on cleanup, and
    unwind the registration loop into individual calls.  Switch to use
    proc_create_single.
    
    Also don't bother handling proc_create* failures - the driver works
    perfectly fine without the proc files, and the cleanup will handle
    missing files gracefully.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>

diff --git a/drivers/scsi/megaraid.h b/drivers/scsi/megaraid.h
index 21eba2fd465a..18e85d9267ff 100644
--- a/drivers/scsi/megaraid.h
+++ b/drivers/scsi/megaraid.h
@@ -814,18 +814,6 @@ typedef struct {
 
 #ifdef CONFIG_PROC_FS
 	struct proc_dir_entry	*controller_proc_dir_entry;
-	struct proc_dir_entry	*proc_read;
-	struct proc_dir_entry	*proc_stat;
-	struct proc_dir_entry	*proc_mbox;
-
-#if MEGA_HAVE_ENH_PROC
-	struct proc_dir_entry	*proc_rr;
-	struct proc_dir_entry	*proc_battery;
-#define MAX_PROC_CHANNELS	4
-	struct proc_dir_entry	*proc_pdrvstat[MAX_PROC_CHANNELS];
-	struct proc_dir_entry	*proc_rdrvstat[MAX_PROC_CHANNELS];
-#endif
-
 #endif
 
 	int	has_64bit_addr;		/* are we using 64-bit addressing */

commit b24413180f5600bcb3bb70fbed5cf186b60864bd
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Wed Nov 1 15:07:57 2017 +0100

    License cleanup: add SPDX GPL-2.0 license identifier to files with no license
    
    Many source files in the tree are missing licensing information, which
    makes it harder for compliance tools to determine the correct license.
    
    By default all files without license information are under the default
    license of the kernel, which is GPL version 2.
    
    Update the files which contain no license information with the 'GPL-2.0'
    SPDX license identifier.  The SPDX identifier is a legally binding
    shorthand, which can be used instead of the full boiler plate text.
    
    This patch is based on work done by Thomas Gleixner and Kate Stewart and
    Philippe Ombredanne.
    
    How this work was done:
    
    Patches were generated and checked against linux-4.14-rc6 for a subset of
    the use cases:
     - file had no licensing information it it.
     - file was a */uapi/* one with no licensing information in it,
     - file was a */uapi/* one with existing licensing information,
    
    Further patches will be generated in subsequent months to fix up cases
    where non-standard license headers were used, and references to license
    had to be inferred by heuristics based on keywords.
    
    The analysis to determine which SPDX License Identifier to be applied to
    a file was done in a spreadsheet of side by side results from of the
    output of two independent scanners (ScanCode & Windriver) producing SPDX
    tag:value files created by Philippe Ombredanne.  Philippe prepared the
    base worksheet, and did an initial spot review of a few 1000 files.
    
    The 4.13 kernel was the starting point of the analysis with 60,537 files
    assessed.  Kate Stewart did a file by file comparison of the scanner
    results in the spreadsheet to determine which SPDX license identifier(s)
    to be applied to the file. She confirmed any determination that was not
    immediately clear with lawyers working with the Linux Foundation.
    
    Criteria used to select files for SPDX license identifier tagging was:
     - Files considered eligible had to be source code files.
     - Make and config files were included as candidates if they contained >5
       lines of source
     - File already had some variant of a license header in it (even if <5
       lines).
    
    All documentation files were explicitly excluded.
    
    The following heuristics were used to determine which SPDX license
    identifiers to apply.
    
     - when both scanners couldn't find any license traces, file was
       considered to have no license information in it, and the top level
       COPYING file license applied.
    
       For non */uapi/* files that summary was:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|-------
       GPL-2.0                                              11139
    
       and resulted in the first patch in this series.
    
       If that file was a */uapi/* path one, it was "GPL-2.0 WITH
       Linux-syscall-note" otherwise it was "GPL-2.0".  Results of that was:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|-------
       GPL-2.0 WITH Linux-syscall-note                        930
    
       and resulted in the second patch in this series.
    
     - if a file had some form of licensing information in it, and was one
       of the */uapi/* ones, it was denoted with the Linux-syscall-note if
       any GPL family license was found in the file or had no licensing in
       it (per prior point).  Results summary:
    
       SPDX license identifier                            # files
       ---------------------------------------------------|------
       GPL-2.0 WITH Linux-syscall-note                       270
       GPL-2.0+ WITH Linux-syscall-note                      169
       ((GPL-2.0 WITH Linux-syscall-note) OR BSD-2-Clause)    21
       ((GPL-2.0 WITH Linux-syscall-note) OR BSD-3-Clause)    17
       LGPL-2.1+ WITH Linux-syscall-note                      15
       GPL-1.0+ WITH Linux-syscall-note                       14
       ((GPL-2.0+ WITH Linux-syscall-note) OR BSD-3-Clause)    5
       LGPL-2.0+ WITH Linux-syscall-note                       4
       LGPL-2.1 WITH Linux-syscall-note                        3
       ((GPL-2.0 WITH Linux-syscall-note) OR MIT)              3
       ((GPL-2.0 WITH Linux-syscall-note) AND MIT)             1
    
       and that resulted in the third patch in this series.
    
     - when the two scanners agreed on the detected license(s), that became
       the concluded license(s).
    
     - when there was disagreement between the two scanners (one detected a
       license but the other didn't, or they both detected different
       licenses) a manual inspection of the file occurred.
    
     - In most cases a manual inspection of the information in the file
       resulted in a clear resolution of the license that should apply (and
       which scanner probably needed to revisit its heuristics).
    
     - When it was not immediately clear, the license identifier was
       confirmed with lawyers working with the Linux Foundation.
    
     - If there was any question as to the appropriate license identifier,
       the file was flagged for further research and to be revisited later
       in time.
    
    In total, over 70 hours of logged manual review was done on the
    spreadsheet to determine the SPDX license identifiers to apply to the
    source files by Kate, Philippe, Thomas and, in some cases, confirmation
    by lawyers working with the Linux Foundation.
    
    Kate also obtained a third independent scan of the 4.13 code base from
    FOSSology, and compared selected files where the other two scanners
    disagreed against that SPDX file, to see if there was new insights.  The
    Windriver scanner is based on an older version of FOSSology in part, so
    they are related.
    
    Thomas did random spot checks in about 500 files from the spreadsheets
    for the uapi headers and agreed with SPDX license identifier in the
    files he inspected. For the non-uapi files Thomas did random spot checks
    in about 15000 files.
    
    In initial set of patches against 4.14-rc6, 3 files were found to have
    copy/paste license identifier errors, and have been fixed to reflect the
    correct identifier.
    
    Additionally Philippe spent 10 hours this week doing a detailed manual
    inspection and review of the 12,461 patched files from the initial patch
    version early this week with:
     - a full scancode scan run, collecting the matched texts, detected
       license ids and scores
     - reviewing anything where there was a license detected (about 500+
       files) to ensure that the applied SPDX license was correct
     - reviewing anything where there was no detection but the patch license
       was not GPL-2.0 WITH Linux-syscall-note to ensure that the applied
       SPDX license was correct
    
    This produced a worksheet with 20 files needing minor correction.  This
    worksheet was then exported into 3 different .csv files for the
    different types of files to be modified.
    
    These .csv files were then reviewed by Greg.  Thomas wrote a script to
    parse the csv files and add the proper SPDX tag to the file, in the
    format that the file expected.  This script was further refined by Greg
    based on the output to detect more types of files automatically and to
    distinguish between header and source .c files (which need different
    comment types.)  Finally Greg ran the script using the .csv files to
    generate the patches.
    
    Reviewed-by: Kate Stewart <kstewart@linuxfoundation.org>
    Reviewed-by: Philippe Ombredanne <pombredanne@nexb.com>
    Reviewed-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/scsi/megaraid.h b/drivers/scsi/megaraid.h
index 508d65e5a518..21eba2fd465a 100644
--- a/drivers/scsi/megaraid.h
+++ b/drivers/scsi/megaraid.h
@@ -1,3 +1,4 @@
+/* SPDX-License-Identifier: GPL-2.0 */
 #ifndef __MEGARAID_H__
 #define __MEGARAID_H__
 

commit 0f2bb84d2a68448c29d46f9f77a78bb4ed0218db
Author: Christoph Hellwig <hch@infradead.org>
Date:   Thu Feb 20 14:20:59 2014 -0800

    [SCSI] megaraid: simplify internal command handling
    
    We don't use the passed in scsi command for anything, so just add a adapter-
    wide internal status to go along with the internal scb that is used unter
    int_mtx to pass back the return value and get rid of all the complexities
    and abuse of the scsi_cmnd structure.
    
    This gets rid of the only user of scsi_allocate_command/scsi_free_command,
    which can now be removed.
    
    [jejb: checkpatch fixes]
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Acked-by: Adam Radford <aradford@gmail.com>
    Signed-off-by: James Bottomley <JBottomley@Parallels.com>

diff --git a/drivers/scsi/megaraid.h b/drivers/scsi/megaraid.h
index 4d0ce4e78dfd..508d65e5a518 100644
--- a/drivers/scsi/megaraid.h
+++ b/drivers/scsi/megaraid.h
@@ -853,10 +853,10 @@ typedef struct {
 
 	u8	sglen;	/* f/w supported scatter-gather list length */
 
-	unsigned char int_cdb[MAX_COMMAND_SIZE];
 	scb_t			int_scb;
 	struct mutex		int_mtx;	/* To synchronize the internal
 						commands */
+	int			int_status;	/* status of internal cmd */
 	struct completion	int_waitq;	/* wait queue for internal
 						 cmds */
 
@@ -1004,7 +1004,6 @@ static int mega_del_logdrv(adapter_t *, int);
 static int mega_do_del_logdrv(adapter_t *, int);
 static void mega_get_max_sgl(adapter_t *);
 static int mega_internal_command(adapter_t *, megacmd_t *, mega_passthru *);
-static void mega_internal_done(Scsi_Cmnd *);
 static int mega_support_cluster(adapter_t *);
 #endif
 

commit c7f079ca30bc719f6f09524fb2119980c4b45d8f
Author: David Howells <dhowells@redhat.com>
Date:   Wed Apr 10 13:33:21 2013 +0100

    megaraid: Don't use create_proc_read_entry()
    
    Don't use create_proc_read_entry() as that is deprecated, but rather use
    proc_create_data() and seq_file instead.
    
    Signed-off-by: David Howells <dhowells@redhat.com>
    cc: Neela Syam Kolli <megaraidlinux@lsi.com>
    cc: James E.J. Bottomley <JBottomley@parallels.com>
    cc: linux-scsi@vger.kernel.org
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/drivers/scsi/megaraid.h b/drivers/scsi/megaraid.h
index 4fb2adf6b80d..4d0ce4e78dfd 100644
--- a/drivers/scsi/megaraid.h
+++ b/drivers/scsi/megaraid.h
@@ -987,24 +987,7 @@ static int mega_init_scb (adapter_t *);
 static int mega_is_bios_enabled (adapter_t *);
 
 #ifdef CONFIG_PROC_FS
-static int mega_print_inquiry(char *, char *);
 static void mega_create_proc_entry(int, struct proc_dir_entry *);
-static int proc_read_config(char *, char **, off_t, int, int *, void *);
-static int proc_read_stat(char *, char **, off_t, int, int *, void *);
-static int proc_read_mbox(char *, char **, off_t, int, int *, void *);
-static int proc_rebuild_rate(char *, char **, off_t, int, int *, void *);
-static int proc_battery(char *, char **, off_t, int, int *, void *);
-static int proc_pdrv_ch0(char *, char **, off_t, int, int *, void *);
-static int proc_pdrv_ch1(char *, char **, off_t, int, int *, void *);
-static int proc_pdrv_ch2(char *, char **, off_t, int, int *, void *);
-static int proc_pdrv_ch3(char *, char **, off_t, int, int *, void *);
-static int proc_pdrv(adapter_t *, char *, int);
-static int proc_rdrv_10(char *, char **, off_t, int, int *, void *);
-static int proc_rdrv_20(char *, char **, off_t, int, int *, void *);
-static int proc_rdrv_30(char *, char **, off_t, int, int *, void *);
-static int proc_rdrv_40(char *, char **, off_t, int, int *, void *);
-static int proc_rdrv(adapter_t *, char *, int, int);
-
 static int mega_adapinq(adapter_t *, dma_addr_t);
 static int mega_internal_dev_inquiry(adapter_t *, u8, u8, dma_addr_t);
 #endif

commit 54ebfd57813ada76f4459f7f1ba1e6873159319e
Author: Jon Mason <jdmason@kudzu.us>
Date:   Tue Jul 10 15:31:28 2012 -0700

    megaraid: remove unnecessary #defines
    
    Remove PCI vendor and subvendor IDs, as they are already defined in
    pci_ids.h.
    
    Signed-off-by: Jon Mason <jdmason@kudzu.us>
    Signed-off-by: Jiri Kosina <jkosina@suse.cz>

diff --git a/drivers/scsi/megaraid.h b/drivers/scsi/megaraid.h
index 9a7897f8ca43..4fb2adf6b80d 100644
--- a/drivers/scsi/megaraid.h
+++ b/drivers/scsi/megaraid.h
@@ -45,45 +45,10 @@
 
 #define MAX_DEV_TYPE	32
 
-#ifndef PCI_VENDOR_ID_LSI_LOGIC
-#define PCI_VENDOR_ID_LSI_LOGIC		0x1000
-#endif
-
-#ifndef PCI_VENDOR_ID_AMI
-#define PCI_VENDOR_ID_AMI		0x101E
-#endif
-
-#ifndef PCI_VENDOR_ID_DELL
-#define PCI_VENDOR_ID_DELL		0x1028
-#endif
-
-#ifndef PCI_VENDOR_ID_INTEL
-#define PCI_VENDOR_ID_INTEL		0x8086
-#endif
-
-#ifndef PCI_DEVICE_ID_AMI_MEGARAID
-#define PCI_DEVICE_ID_AMI_MEGARAID	0x9010
-#endif
-
-#ifndef PCI_DEVICE_ID_AMI_MEGARAID2
-#define PCI_DEVICE_ID_AMI_MEGARAID2	0x9060
-#endif
-
-#ifndef PCI_DEVICE_ID_AMI_MEGARAID3
-#define PCI_DEVICE_ID_AMI_MEGARAID3	0x1960
-#endif
-
 #define PCI_DEVICE_ID_DISCOVERY		0x000E
 #define PCI_DEVICE_ID_PERC4_DI		0x000F
 #define PCI_DEVICE_ID_PERC4_QC_VERDE	0x0407
 
-/* Sub-System Vendor IDs */
-#define	AMI_SUBSYS_VID			0x101E
-#define DELL_SUBSYS_VID			0x1028
-#define	HP_SUBSYS_VID			0x103C
-#define LSI_SUBSYS_VID			0x1000
-#define INTEL_SUBSYS_VID		0x8086
-
 #define HBA_SIGNATURE	      		0x3344
 #define HBA_SIGNATURE_471	  	0xCCCC
 #define HBA_SIGNATURE_64BIT		0x0299

commit 25985edcedea6396277003854657b5f3cb31a628
Author: Lucas De Marchi <lucas.demarchi@profusion.mobi>
Date:   Wed Mar 30 22:57:33 2011 -0300

    Fix common misspellings
    
    Fixes generated by 'codespell' and manually reviewed.
    
    Signed-off-by: Lucas De Marchi <lucas.demarchi@profusion.mobi>

diff --git a/drivers/scsi/megaraid.h b/drivers/scsi/megaraid.h
index 853411911b2e..9a7897f8ca43 100644
--- a/drivers/scsi/megaraid.h
+++ b/drivers/scsi/megaraid.h
@@ -532,9 +532,9 @@ struct uioctl_t {
 
 /*
  * struct mcontroller is used to pass information about the controllers in the
- * system. Its upto the application how to use the information. We are passing
+ * system. Its up to the application how to use the information. We are passing
  * as much info about the cards as possible and useful. Before issuing the
- * call to find information about the cards, the applicaiton needs to issue a
+ * call to find information about the cards, the application needs to issue a
  * ioctl first to find out the number of controllers in the system.
  */
 #define MAX_CONTROLLERS 32
@@ -804,7 +804,7 @@ typedef struct {
 	unsigned long		base;
 	void __iomem		*mmio_base;
 
-	/* mbox64 with mbox not aligned on 16-byte boundry */
+	/* mbox64 with mbox not aligned on 16-byte boundary */
 	mbox64_t	*una_mbox64;
 	dma_addr_t	una_mbox64_dma;
 

commit 4b7bd364700d9ac8372eff48832062b936d0793b
Merge: c0d8768af260 90a8a73c06cc
Author: Jiri Kosina <jkosina@suse.cz>
Date:   Wed Dec 22 18:57:02 2010 +0100

    Merge branch 'master' into for-next
    
    Conflicts:
            MAINTAINERS
            arch/arm/mach-omap2/pm24xx.c
            drivers/scsi/bfa/bfa_fcpim.c
    
    Needed to update to apply fixes for which the old branch was too
    outdated.

commit f281233d3eba15fb225d21ae2e228fd4553d824a
Author: Jeff Garzik <jeff@garzik.org>
Date:   Tue Nov 16 02:10:29 2010 -0500

    SCSI host lock push-down
    
    Move the mid-layer's ->queuecommand() invocation from being locked
    with the host lock to being unlocked to facilitate speeding up the
    critical path for drivers who don't need this lock taken anyway.
    
    The patch below presents a simple SCSI host lock push-down as an
    equivalent transformation.  No locking or other behavior should change
    with this patch.  All existing bugs and locking orders are preserved.
    
    Additionally, add one parameter to queuecommand,
            struct Scsi_Host *
    and remove one parameter from queuecommand,
            void (*done)(struct scsi_cmnd *)
    
    Scsi_Host* is a convenient pointer that most host drivers need anyway,
    and 'done' is redundant to struct scsi_cmnd->scsi_done.
    
    Minimal code disturbance was attempted with this change.  Most drivers
    needed only two one-line modifications for their host lock push-down.
    
    Signed-off-by: Jeff Garzik <jgarzik@redhat.com>
    Acked-by: James Bottomley <James.Bottomley@suse.de>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/scsi/megaraid.h b/drivers/scsi/megaraid.h
index 2b4a048cadf1..f5644745e24e 100644
--- a/drivers/scsi/megaraid.h
+++ b/drivers/scsi/megaraid.h
@@ -987,7 +987,7 @@ static int mega_query_adapter(adapter_t *);
 static int issue_scb(adapter_t *, scb_t *);
 static int mega_setup_mailbox(adapter_t *);
 
-static int megaraid_queue (Scsi_Cmnd *, void (*)(Scsi_Cmnd *));
+static int megaraid_queue (struct Scsi_Host *, struct scsi_cmnd *);
 static scb_t * mega_build_cmd(adapter_t *, Scsi_Cmnd *, int *);
 static void __mega_runpendq(adapter_t *);
 static int issue_scb_block(adapter_t *, u_char *);

commit b595076a180a56d1bb170e6eceda6eb9d76f4cd3
Author: Uwe Kleine-König <u.kleine-koenig@pengutronix.de>
Date:   Mon Nov 1 15:38:34 2010 -0400

    tree-wide: fix comment/printk typos
    
    "gadget", "through", "command", "maintain", "maintain", "controller", "address",
    "between", "initiali[zs]e", "instead", "function", "select", "already",
    "equal", "access", "management", "hierarchy", "registration", "interest",
    "relative", "memory", "offset", "already",
    
    Signed-off-by: Uwe Kleine-König <u.kleine-koenig@pengutronix.de>
    Signed-off-by: Jiri Kosina <jkosina@suse.cz>

diff --git a/drivers/scsi/megaraid.h b/drivers/scsi/megaraid.h
index 2b4a048cadf1..deb24ad1b8d2 100644
--- a/drivers/scsi/megaraid.h
+++ b/drivers/scsi/megaraid.h
@@ -13,7 +13,7 @@
  */
 
 /*
- * Comand coalescing - This feature allows the driver to be able to combine
+ * Command coalescing - This feature allows the driver to be able to combine
  * two or more commands and issue as one command in order to boost I/O
  * performance. Useful if the nature of the I/O is sequential. It is not very
  * useful for random natured I/Os.

commit f4927c45beda9a70e5c3bda0bd9f12b4f713c00b
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Tue Apr 27 00:24:01 2010 +0200

    scsi: Push down BKL into ioctl functions
    
    Push down the bkl into ioctl functions on the scsi layer.
    
    [jkacur: Forward declaration missing ';'.
    Conflicting declaraction in megaraid.h changed
    Fixed missing inodes declarations]
    
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>
    Signed-off-by: John Kacur <jkacur@redhat.com>
    Signed-off-by: Frederic Weisbecker <fweisbec@gmail.com>

diff --git a/drivers/scsi/megaraid.h b/drivers/scsi/megaraid.h
index d310f49d077e..2b4a048cadf1 100644
--- a/drivers/scsi/megaraid.h
+++ b/drivers/scsi/megaraid.h
@@ -1013,8 +1013,7 @@ static void mega_8_to_40ld (mraid_inquiry *inquiry,
 		mega_inquiry3 *enquiry3, mega_product_info *);
 
 static int megadev_open (struct inode *, struct file *);
-static int megadev_ioctl (struct inode *, struct file *, unsigned int,
-		unsigned long);
+static int megadev_ioctl (struct file *, unsigned int, unsigned long);
 static int mega_m_to_n(void __user *, nitioctl_t *);
 static int mega_n_to_m(void __user *, megacmd_t *);
 

commit af901ca181d92aac3a7dc265144a9081a86d8f39
Author: André Goddard Rosa <andre.goddard@gmail.com>
Date:   Sat Nov 14 13:09:05 2009 -0200

    tree-wide: fix assorted typos all over the place
    
    That is "success", "unknown", "through", "performance", "[re|un]mapping"
    , "access", "default", "reasonable", "[con]currently", "temperature"
    , "channel", "[un]used", "application", "example","hierarchy", "therefore"
    , "[over|under]flow", "contiguous", "threshold", "enough" and others.
    
    Signed-off-by: André Goddard Rosa <andre.goddard@gmail.com>
    Signed-off-by: Jiri Kosina <jkosina@suse.cz>

diff --git a/drivers/scsi/megaraid.h b/drivers/scsi/megaraid.h
index 512c2cc1a33f..d310f49d077e 100644
--- a/drivers/scsi/megaraid.h
+++ b/drivers/scsi/megaraid.h
@@ -381,7 +381,7 @@ typedef struct {
 	u8	battery_status;	/*
 				 * BIT 0: battery module missing
 				 * BIT 1: VBAD
-				 * BIT 2: temprature high
+				 * BIT 2: temperature high
 				 * BIT 3: battery pack missing
 				 * BIT 4,5:
 				 *   00 - charge complete

commit 4b512d26f425be1c779c8319249b42ce3c3424d2
Author: Thadeu Lima de Souza Cascardo <cascardo@holoscopio.com>
Date:   Tue Apr 14 23:14:10 2009 -0300

    trivial: typo (en|dis|avail|remove)bale -> (en|dis|avail|remove)able
    
    Signed-off-by: Thadeu Lima de Souza Cascardo <cascardo@holoscopio.com>
    Signed-off-by: Jiri Kosina <jkosina@suse.cz>

diff --git a/drivers/scsi/megaraid.h b/drivers/scsi/megaraid.h
index 795201fa0b48..512c2cc1a33f 100644
--- a/drivers/scsi/megaraid.h
+++ b/drivers/scsi/megaraid.h
@@ -469,7 +469,7 @@ typedef struct {
 	u8	type;		/* Type of the device */
 	u8	cur_status;	/* current status of the device */
 	u8	tag_depth;	/* Level of tagging */
-	u8	sync_neg;	/* sync negotiation - ENABLE or DISBALE */
+	u8	sync_neg;	/* sync negotiation - ENABLE or DISABLE */
 	u32	size;		/* configurable size in terms of 512 byte
 				   blocks */
 }__attribute__ ((packed)) phys_drv;

commit 6b0eea21efed26f92e18741e54a3121cf5cd197e
Author: FUJITA Tomonori <fujita.tomonori@lab.ntt.co.jp>
Date:   Fri Oct 24 09:21:05 2008 +0900

    [SCSI] megaraid: fix mega_internal_command oops
    
    scsi_cmnd->cmnd was changed from a static array to a pointer post
    2.6.25. It breaks mega_internal_command():
    
    static int
    mega_internal_command(adapter_t *adapter, megacmd_t *mc, mega_passthru *pthru)
    {
    ...
            scb = &adapter->int_scb;
            memset(scb, 0, sizeof(scb_t));
    
            scmd = &adapter->int_scmd;
            memset(scmd, 0, sizeof(Scsi_Cmnd));
    
            sdev = kzalloc(sizeof(struct scsi_device), GFP_KERNEL);
            scmd->device = sdev;
    
            scmd->device->host = adapter->host;
            scmd->host_scribble = (void *)scb;
            scmd->cmnd[0] = MEGA_INTERNAL_CMD;
    
    mega_internal_command() uses scsi_cmnd allocated internally so
    scmd->cmnd is NULL here. This patch adds a static array for cdb to
    adapter_t and uses it here. This also uses
    scsi_allocate_command/scsi_free_command, the recommended way to
    allocate struct scsi_cmnd since the driver might use sense_buffer in
    struct scsi_cmnd.
    
    Signed-off-by: FUJITA Tomonori <fujita.tomonori@lab.ntt.co.jp>
    Reviewed-by: Boaz Harrosh <bharrosh@panasas.com>
    Tested-by: Pascal Terjan <pterjan@gmail.com>
    Reported-by: Pascal Terjan <pterjan@gmail.com>
    Acked-by: "Yang, Bo" <Bo.Yang@lsi.com>
    Signed-off-by: James Bottomley <James.Bottomley@HansenPartnership.com>

diff --git a/drivers/scsi/megaraid.h b/drivers/scsi/megaraid.h
index ee70bd4ae4ba..795201fa0b48 100644
--- a/drivers/scsi/megaraid.h
+++ b/drivers/scsi/megaraid.h
@@ -888,8 +888,8 @@ typedef struct {
 
 	u8	sglen;	/* f/w supported scatter-gather list length */
 
+	unsigned char int_cdb[MAX_COMMAND_SIZE];
 	scb_t			int_scb;
-	Scsi_Cmnd		int_scmd;
 	struct mutex		int_mtx;	/* To synchronize the internal
 						commands */
 	struct completion	int_waitq;	/* wait queue for internal

commit 84a3c97b93ec5b4509637801a703693bb710cd4c
Author: walter harms <wharms@bfs.de>
Date:   Thu Apr 26 00:35:09 2007 -0700

    [SCSI] megaraid: fix warnings when CONFIG_PROC_FS=n
    
    drivers/scsi/megaraid.c: In function 'megaraid_probe_one':
    drivers/scsi/megaraid.c:4893: warning: implicit declaration of function 'mega_create_proc_entry'
    drivers/scsi/megaraid.c: In function 'megaraid_remove_one':
    drivers/scsi/megaraid.c:4968: warning: unused variable 'buf'
    
    Fix by adding #defines
    
    Signed-off-by: walter harms <wharms@bfs.de>
    Signed-off-by: Alexey Dobriyan <adobriyan@gmail.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>

diff --git a/drivers/scsi/megaraid.h b/drivers/scsi/megaraid.h
index c6e74643abe2..ee70bd4ae4ba 100644
--- a/drivers/scsi/megaraid.h
+++ b/drivers/scsi/megaraid.h
@@ -1002,7 +1002,6 @@ static int megaraid_reset(Scsi_Cmnd *);
 static int megaraid_abort_and_reset(adapter_t *, Scsi_Cmnd *, int);
 static int megaraid_biosparam(struct scsi_device *, struct block_device *,
 		sector_t, int []);
-static int mega_print_inquiry(char *, char *);
 
 static int mega_build_sglist (adapter_t *adapter, scb_t *scb,
 			      u32 *buffer, u32 *length);
@@ -1024,6 +1023,7 @@ static int mega_init_scb (adapter_t *);
 static int mega_is_bios_enabled (adapter_t *);
 
 #ifdef CONFIG_PROC_FS
+static int mega_print_inquiry(char *, char *);
 static void mega_create_proc_entry(int, struct proc_dir_entry *);
 static int proc_read_config(char *, char **, off_t, int, int *, void *);
 static int proc_read_stat(char *, char **, off_t, int, int *, void *);
@@ -1040,10 +1040,10 @@ static int proc_rdrv_20(char *, char **, off_t, int, int *, void *);
 static int proc_rdrv_30(char *, char **, off_t, int, int *, void *);
 static int proc_rdrv_40(char *, char **, off_t, int, int *, void *);
 static int proc_rdrv(adapter_t *, char *, int, int);
-#endif
 
 static int mega_adapinq(adapter_t *, dma_addr_t);
 static int mega_internal_dev_inquiry(adapter_t *, u8, u8, dma_addr_t);
+#endif
 
 static int mega_support_ext_cdb(adapter_t *);
 static mega_passthru* mega_prepare_passthru(adapter_t *, scb_t *,

commit 00769ec40074b753c9b218c2ccaba2bfbfffe056
Author: Jeff Garzik <jeff@garzik.org>
Date:   Sun Dec 3 20:49:23 2006 -0500

    [SCSI] megaraid: fix MMIO casts
    
    megaraid's MMIO RD*/WR* macros directly call readl() and writel() with
    an 'unsigned long' argument.  This throws a warning, but is otherwise OK
    because the 'unsigned long' is really the result of ioremap().  This
    setup is also OK because the variable can hold an ioremap cookie /or/ a
    PCI I/O port (PIO).
    
    However, to fix the warning thrown when readl() and writel() are passed
    an unsigned long cookie, I introduce 'void __iomem *mmio_base', holding
    the same value as 'base'.  This will silence the warnings, and also
    cause an oops whenever these MMIO-only functions are ever accidentally
    passed an I/O address.
    
    Signed-off-by: Jeff Garzik <jeff@garzik.org>
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>

diff --git a/drivers/scsi/megaraid.h b/drivers/scsi/megaraid.h
index 66529f11d23c..c6e74643abe2 100644
--- a/drivers/scsi/megaraid.h
+++ b/drivers/scsi/megaraid.h
@@ -801,7 +801,8 @@ typedef struct {
 				   clustering is available */
 	u32	flag;
 
-	unsigned long	base;
+	unsigned long		base;
+	void __iomem		*mmio_base;
 
 	/* mbox64 with mbox not aligned on 16-byte boundry */
 	mbox64_t	*una_mbox64;

commit 7d12e780e003f93433d49ce78cfedf4b4c52adc5
Author: David Howells <dhowells@redhat.com>
Date:   Thu Oct 5 14:55:46 2006 +0100

    IRQ: Maintain regs pointer globally rather than passing to IRQ handlers
    
    Maintain a per-CPU global "struct pt_regs *" variable which can be used instead
    of passing regs around manually through all ~1800 interrupt handlers in the
    Linux kernel.
    
    The regs pointer is used in few places, but it potentially costs both stack
    space and code to pass it around.  On the FRV arch, removing the regs parameter
    from all the genirq function results in a 20% speed up of the IRQ exit path
    (ie: from leaving timer_interrupt() to leaving do_IRQ()).
    
    Where appropriate, an arch may override the generic storage facility and do
    something different with the variable.  On FRV, for instance, the address is
    maintained in GR28 at all times inside the kernel as part of general exception
    handling.
    
    Having looked over the code, it appears that the parameter may be handed down
    through up to twenty or so layers of functions.  Consider a USB character
    device attached to a USB hub, attached to a USB controller that posts its
    interrupts through a cascaded auxiliary interrupt controller.  A character
    device driver may want to pass regs to the sysrq handler through the input
    layer which adds another few layers of parameter passing.
    
    I've build this code with allyesconfig for x86_64 and i386.  I've runtested the
    main part of the code on FRV and i386, though I can't test most of the drivers.
    I've also done partial conversion for powerpc and MIPS - these at least compile
    with minimal configurations.
    
    This will affect all archs.  Mostly the changes should be relatively easy.
    Take do_IRQ(), store the regs pointer at the beginning, saving the old one:
    
            struct pt_regs *old_regs = set_irq_regs(regs);
    
    And put the old one back at the end:
    
            set_irq_regs(old_regs);
    
    Don't pass regs through to generic_handle_irq() or __do_IRQ().
    
    In timer_interrupt(), this sort of change will be necessary:
    
            -       update_process_times(user_mode(regs));
            -       profile_tick(CPU_PROFILING, regs);
            +       update_process_times(user_mode(get_irq_regs()));
            +       profile_tick(CPU_PROFILING);
    
    I'd like to move update_process_times()'s use of get_irq_regs() into itself,
    except that i386, alone of the archs, uses something other than user_mode().
    
    Some notes on the interrupt handling in the drivers:
    
     (*) input_dev() is now gone entirely.  The regs pointer is no longer stored in
         the input_dev struct.
    
     (*) finish_unlinks() in drivers/usb/host/ohci-q.c needs checking.  It does
         something different depending on whether it's been supplied with a regs
         pointer or not.
    
     (*) Various IRQ handler function pointers have been moved to type
         irq_handler_t.
    
    Signed-Off-By: David Howells <dhowells@redhat.com>
    (cherry picked from 1b16e7ac850969f38b375e511e3fa2f474a33867 commit)

diff --git a/drivers/scsi/megaraid.h b/drivers/scsi/megaraid.h
index 4b75fe619d9c..66529f11d23c 100644
--- a/drivers/scsi/megaraid.h
+++ b/drivers/scsi/megaraid.h
@@ -991,8 +991,8 @@ static scb_t * mega_build_cmd(adapter_t *, Scsi_Cmnd *, int *);
 static void __mega_runpendq(adapter_t *);
 static int issue_scb_block(adapter_t *, u_char *);
 
-static irqreturn_t megaraid_isr_memmapped(int, void *, struct pt_regs *);
-static irqreturn_t megaraid_isr_iomapped(int, void *, struct pt_regs *);
+static irqreturn_t megaraid_isr_memmapped(int, void *);
+static irqreturn_t megaraid_isr_iomapped(int, void *);
 
 static void mega_free_scb(adapter_t *, scb_t *);
 

commit 3542adcb354fea4fca792d36b91cb44d0da147e5
Author: Ju, Seokmann <Seokmann.Ju@lsil.com>
Date:   Thu Feb 9 12:32:59 2006 -0700

    [SCSI] megaraid_legacy: kobject_register failure
    
    Attached patch fixes problem that cause kobject_register failure
    during loading.  Kobject_register would fail when there are more than
    1 module with same module name.  This patch will change module name of
    megaraid_legacy from 'megaraid' to 'megaraid_legacy'.
    
    Signed-Off-by: Seokmann Ju <seokmann.ju@lsil.com>
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>

diff --git a/drivers/scsi/megaraid.h b/drivers/scsi/megaraid.h
index 4b3e0d6e5afa..4b75fe619d9c 100644
--- a/drivers/scsi/megaraid.h
+++ b/drivers/scsi/megaraid.h
@@ -5,7 +5,7 @@
 #include <linux/mutex.h>
 
 #define MEGARAID_VERSION	\
-	"v2.00.3 (Release Date: Wed Feb 19 08:51:30 EST 2003)\n"
+	"v2.00.4 (Release Date: Thu Feb 9 08:51:30 EST 2006)\n"
 
 /*
  * Driver features - change the values to enable or disable features in the

commit 0b9506723826c68b50fa33e345700ddcac1bed36
Author: Arjan van de Ven <arjan@infradead.org>
Date:   Wed Jan 11 13:16:10 2006 +0100

    [SCSI] turn most scsi semaphores into mutexes
    
    the scsi layer is using semaphores in a mutex way, this patch converts
    these into using mutexes instead
    
    Signed-off-by: Arjan van de Ven <arjan@infradead.org>
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>

diff --git a/drivers/scsi/megaraid.h b/drivers/scsi/megaraid.h
index 6f9078025748..4b3e0d6e5afa 100644
--- a/drivers/scsi/megaraid.h
+++ b/drivers/scsi/megaraid.h
@@ -2,7 +2,7 @@
 #define __MEGARAID_H__
 
 #include <linux/spinlock.h>
-
+#include <linux/mutex.h>
 
 #define MEGARAID_VERSION	\
 	"v2.00.3 (Release Date: Wed Feb 19 08:51:30 EST 2003)\n"
@@ -889,7 +889,7 @@ typedef struct {
 
 	scb_t			int_scb;
 	Scsi_Cmnd		int_scmd;
-	struct semaphore	int_mtx;	/* To synchronize the internal
+	struct mutex		int_mtx;	/* To synchronize the internal
 						commands */
 	struct completion	int_waitq;	/* wait queue for internal
 						 cmds */

commit cb0258a2fb8e434b3b56856603754d998008d9ee
Author: Christoph Hellwig <hch@lst.de>
Date:   Mon Oct 31 20:12:07 2005 +0100

    [SCSI] megaraid (legacy): remove scsi_assign_lock usage
    
    just take the adapter lock in megaraid_queue.  Additional benefit is
    that we can get rid of the awkward conditional locking in
    mega_internal_command.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>

diff --git a/drivers/scsi/megaraid.h b/drivers/scsi/megaraid.h
index 4facf557cd19..6f9078025748 100644
--- a/drivers/scsi/megaraid.h
+++ b/drivers/scsi/megaraid.h
@@ -925,13 +925,6 @@ struct mega_hbas {
 #define MEGA_BULK_DATA			0x0001
 #define MEGA_SGLIST			0x0002
 
-/*
- * lockscope definitions, callers can specify the lock scope with this data
- * type. LOCK_INT would mean the caller has not acquired the lock before
- * making the call and LOCK_EXT would mean otherwise.
- */
-typedef enum { LOCK_INT, LOCK_EXT } lockscope_t;
-
 /*
  * Parameters for the io-mapped controllers
  */
@@ -1062,8 +1055,7 @@ static int mega_support_random_del(adapter_t *);
 static int mega_del_logdrv(adapter_t *, int);
 static int mega_do_del_logdrv(adapter_t *, int);
 static void mega_get_max_sgl(adapter_t *);
-static int mega_internal_command(adapter_t *, lockscope_t, megacmd_t *,
-		mega_passthru *);
+static int mega_internal_command(adapter_t *, megacmd_t *, mega_passthru *);
 static void mega_internal_done(Scsi_Cmnd *);
 static int mega_support_cluster(adapter_t *);
 #endif

commit 8d115f845a0bd59cd263e791f739964f42b7b0e8
Author: Christoph Hellwig <hch@lst.de>
Date:   Sun Jun 19 13:42:05 2005 +0200

    [SCSI] remove scsi_cmnd->state
    
    We never look at it except for the old megaraid driver that abuses it
    for sending internal commands.  That usage can be fixed easily because
    those internal commands are single-threaded by a mutex and we can easily
    use a completion there.
    
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>

diff --git a/drivers/scsi/megaraid.h b/drivers/scsi/megaraid.h
index e25c4de9edd9..4facf557cd19 100644
--- a/drivers/scsi/megaraid.h
+++ b/drivers/scsi/megaraid.h
@@ -891,7 +891,7 @@ typedef struct {
 	Scsi_Cmnd		int_scmd;
 	struct semaphore	int_mtx;	/* To synchronize the internal
 						commands */
-	wait_queue_head_t	int_waitq;	/* wait queue for internal
+	struct completion	int_waitq;	/* wait queue for internal
 						 cmds */
 
 	int	has_cluster;	/* cluster support on this HBA */

commit 1da177e4c3f41524e886b7f1b8a0c1fc7321cac2
Author: Linus Torvalds <torvalds@ppc970.osdl.org>
Date:   Sat Apr 16 15:20:36 2005 -0700

    Linux-2.6.12-rc2
    
    Initial git repository build. I'm not bothering with the full history,
    even though we have it. We can create a separate "historical" git
    archive of that later if we want to, and in the meantime it's about
    3.2GB when imported into git - space that would just make the early
    git days unnecessarily complicated, when we don't have a lot of good
    infrastructure for it.
    
    Let it rip!

diff --git a/drivers/scsi/megaraid.h b/drivers/scsi/megaraid.h
new file mode 100644
index 000000000000..e25c4de9edd9
--- /dev/null
+++ b/drivers/scsi/megaraid.h
@@ -0,0 +1,1071 @@
+#ifndef __MEGARAID_H__
+#define __MEGARAID_H__
+
+#include <linux/spinlock.h>
+
+
+#define MEGARAID_VERSION	\
+	"v2.00.3 (Release Date: Wed Feb 19 08:51:30 EST 2003)\n"
+
+/*
+ * Driver features - change the values to enable or disable features in the
+ * driver.
+ */
+
+/*
+ * Comand coalescing - This feature allows the driver to be able to combine
+ * two or more commands and issue as one command in order to boost I/O
+ * performance. Useful if the nature of the I/O is sequential. It is not very
+ * useful for random natured I/Os.
+ */
+#define MEGA_HAVE_COALESCING	0
+
+/*
+ * Clustering support - Set this flag if you are planning to use the
+ * clustering services provided by the megaraid controllers and planning to
+ * setup a cluster
+ */
+#define MEGA_HAVE_CLUSTERING	1
+
+/*
+ * Driver statistics - Set this flag if you are interested in statics about
+ * number of I/O completed on each logical drive and how many interrupts
+ * generated. If enabled, this information is available through /proc
+ * interface and through the private ioctl. Setting this flag has a
+ * performance penalty.
+ */
+#define MEGA_HAVE_STATS		0
+
+/*
+ * Enhanced /proc interface - This feature will allow you to have a more
+ * detailed /proc interface for megaraid driver. E.g., a real time update of
+ * the status of the logical drives, battery status, physical drives etc.
+ */
+#define MEGA_HAVE_ENH_PROC	1
+
+#define MAX_DEV_TYPE	32
+
+#ifndef PCI_VENDOR_ID_LSI_LOGIC
+#define PCI_VENDOR_ID_LSI_LOGIC		0x1000
+#endif
+
+#ifndef PCI_VENDOR_ID_AMI
+#define PCI_VENDOR_ID_AMI		0x101E
+#endif
+
+#ifndef PCI_VENDOR_ID_DELL
+#define PCI_VENDOR_ID_DELL		0x1028
+#endif
+
+#ifndef PCI_VENDOR_ID_INTEL
+#define PCI_VENDOR_ID_INTEL		0x8086
+#endif
+
+#ifndef PCI_DEVICE_ID_AMI_MEGARAID
+#define PCI_DEVICE_ID_AMI_MEGARAID	0x9010
+#endif
+
+#ifndef PCI_DEVICE_ID_AMI_MEGARAID2
+#define PCI_DEVICE_ID_AMI_MEGARAID2	0x9060
+#endif
+
+#ifndef PCI_DEVICE_ID_AMI_MEGARAID3
+#define PCI_DEVICE_ID_AMI_MEGARAID3	0x1960
+#endif
+
+#define PCI_DEVICE_ID_DISCOVERY		0x000E
+#define PCI_DEVICE_ID_PERC4_DI		0x000F
+#define PCI_DEVICE_ID_PERC4_QC_VERDE	0x0407
+
+/* Sub-System Vendor IDs */
+#define	AMI_SUBSYS_VID			0x101E
+#define DELL_SUBSYS_VID			0x1028
+#define	HP_SUBSYS_VID			0x103C
+#define LSI_SUBSYS_VID			0x1000
+#define INTEL_SUBSYS_VID		0x8086
+
+#define HBA_SIGNATURE	      		0x3344
+#define HBA_SIGNATURE_471	  	0xCCCC
+#define HBA_SIGNATURE_64BIT		0x0299
+
+#define MBOX_BUSY_WAIT			10	/* wait for up to 10 usec for
+						   mailbox to be free */
+#define DEFAULT_INITIATOR_ID	7
+
+#define MAX_SGLIST		64	/* max supported in f/w */
+#define MIN_SGLIST		26	/* guaranteed to support these many */
+#define MAX_COMMANDS		126
+#define CMDID_INT_CMDS		MAX_COMMANDS+1	/* make sure CMDID_INT_CMDS
+					 	is less than max commands
+						supported by any f/w */
+
+#define MAX_CDB_LEN	     	10
+#define MAX_EXT_CDB_LEN		16	/* we support cdb length up to 16 */
+
+#define DEF_CMD_PER_LUN		63
+#define MAX_CMD_PER_LUN		MAX_COMMANDS
+#define MAX_FIRMWARE_STATUS	46
+#define MAX_XFER_PER_CMD	(64*1024)
+#define MAX_SECTORS_PER_IO	128
+
+#define MAX_LOGICAL_DRIVES_40LD		40
+#define FC_MAX_PHYSICAL_DEVICES		256
+#define MAX_LOGICAL_DRIVES_8LD		8
+#define MAX_CHANNELS			5
+#define MAX_TARGET			15
+#define MAX_PHYSICAL_DRIVES		MAX_CHANNELS*MAX_TARGET
+#define MAX_ROW_SIZE_40LD		32
+#define MAX_ROW_SIZE_8LD		8
+#define MAX_SPAN_DEPTH			8
+
+#define NVIRT_CHAN		4	/* # of virtual channels to represent
+					   up to 60 logical drives */
+struct mbox_out {
+	/* 0x0 */ u8 cmd;
+	/* 0x1 */ u8 cmdid;
+	/* 0x2 */ u16 numsectors;
+	/* 0x4 */ u32 lba;
+	/* 0x8 */ u32 xferaddr;
+	/* 0xC */ u8 logdrv;
+	/* 0xD */ u8 numsgelements;
+	/* 0xE */ u8 resvd;
+} __attribute__ ((packed));
+
+struct mbox_in {
+	/* 0xF */ volatile u8 busy;
+	/* 0x10 */ volatile u8 numstatus;
+	/* 0x11 */ volatile u8 status;
+	/* 0x12 */ volatile u8 completed[MAX_FIRMWARE_STATUS];
+	volatile u8 poll;
+	volatile u8 ack;
+} __attribute__ ((packed));
+
+typedef struct {
+	struct mbox_out	m_out;
+	struct mbox_in	m_in;
+} __attribute__ ((packed)) mbox_t;
+
+typedef struct {
+	u32 xfer_segment_lo;
+	u32 xfer_segment_hi;
+	mbox_t mbox;
+} __attribute__ ((packed)) mbox64_t;
+
+
+/*
+ * Passthru definitions
+ */
+#define MAX_REQ_SENSE_LEN       0x20
+
+typedef struct {
+	u8 timeout:3;		/* 0=6sec/1=60sec/2=10min/3=3hrs */
+	u8 ars:1;
+	u8 reserved:3;
+	u8 islogical:1;
+	u8 logdrv;		/* if islogical == 1 */
+	u8 channel;		/* if islogical == 0 */
+	u8 target;		/* if islogical == 0 */
+	u8 queuetag;		/* unused */
+	u8 queueaction;		/* unused */
+	u8 cdb[MAX_CDB_LEN];
+	u8 cdblen;
+	u8 reqsenselen;
+	u8 reqsensearea[MAX_REQ_SENSE_LEN];
+	u8 numsgelements;
+	u8 scsistatus;
+	u32 dataxferaddr;
+	u32 dataxferlen;
+} __attribute__ ((packed)) mega_passthru;
+
+
+/*
+ * Extended passthru: support CDB > 10 bytes
+ */
+typedef struct {
+	u8 timeout:3;		/* 0=6sec/1=60sec/2=10min/3=3hrs */
+	u8 ars:1;
+	u8 rsvd1:1;
+	u8 cd_rom:1;
+	u8 rsvd2:1;
+	u8 islogical:1;
+	u8 logdrv;		/* if islogical == 1 */
+	u8 channel;		/* if islogical == 0 */
+	u8 target;		/* if islogical == 0 */
+	u8 queuetag;		/* unused */
+	u8 queueaction;		/* unused */
+	u8 cdblen;
+	u8 rsvd3;
+	u8 cdb[MAX_EXT_CDB_LEN];
+	u8 numsgelements;
+	u8 status;
+	u8 reqsenselen;
+	u8 reqsensearea[MAX_REQ_SENSE_LEN];
+	u8 rsvd4;
+	u32 dataxferaddr;
+	u32 dataxferlen;
+} __attribute__ ((packed)) mega_ext_passthru;
+
+typedef struct {
+	u64 address;
+	u32 length;
+} __attribute__ ((packed)) mega_sgl64;
+
+typedef struct {
+	u32 address;
+	u32 length;
+} __attribute__ ((packed)) mega_sglist;
+
+
+/* Queued command data */
+typedef struct {
+	int	idx;
+	u32	state;
+	struct list_head	list;
+	u8	raw_mbox[66];
+	u32	dma_type;
+	u32	dma_direction;
+
+	Scsi_Cmnd	*cmd;
+	dma_addr_t	dma_h_bulkdata;
+	dma_addr_t	dma_h_sgdata;
+
+	mega_sglist	*sgl;
+	mega_sgl64	*sgl64;
+	dma_addr_t	sgl_dma_addr;
+
+	mega_passthru		*pthru;
+	dma_addr_t		pthru_dma_addr;
+	mega_ext_passthru	*epthru;
+	dma_addr_t		epthru_dma_addr;
+} scb_t;
+
+/*
+ * Flags to follow the scb as it transitions between various stages
+ */
+#define SCB_FREE	0x0000	/* on the free list */
+#define SCB_ACTIVE	0x0001	/* off the free list */
+#define SCB_PENDQ	0x0002	/* on the pending queue */
+#define SCB_ISSUED	0x0004	/* issued - owner f/w */
+#define SCB_ABORT	0x0008	/* Got an abort for this one */
+#define SCB_RESET	0x0010	/* Got a reset for this one */
+
+/*
+ * Utilities declare this strcture size as 1024 bytes. So more fields can
+ * be added in future.
+ */
+typedef struct {
+	u32	data_size; /* current size in bytes (not including resvd) */
+
+	u32	config_signature;
+		/* Current value is 0x00282008
+		 * 0x28=MAX_LOGICAL_DRIVES,
+		 * 0x20=Number of stripes and
+		 * 0x08=Number of spans */
+
+	u8	fw_version[16];		/* printable ASCI string */
+	u8	bios_version[16];	/* printable ASCI string */
+	u8	product_name[80];	/* printable ASCI string */
+
+	u8	max_commands;		/* Max. concurrent commands supported */
+	u8	nchannels;		/* Number of SCSI Channels detected */
+	u8	fc_loop_present;	/* Number of Fibre Loops detected */
+	u8	mem_type;		/* EDO, FPM, SDRAM etc */
+
+	u32	signature;
+	u16	dram_size;		/* In terms of MB */
+	u16	subsysid;
+
+	u16	subsysvid;
+	u8	notify_counters;
+	u8	pad1k[889];		/* 135 + 889 resvd = 1024 total size */
+} __attribute__ ((packed)) mega_product_info;
+
+struct notify {
+	u32 global_counter;	/* Any change increments this counter */
+
+	u8 param_counter;	/* Indicates any params changed  */
+	u8 param_id;		/* Param modified - defined below */
+	u16 param_val;		/* New val of last param modified */
+
+	u8 write_config_counter;	/* write config occurred */
+	u8 write_config_rsvd[3];
+
+	u8 ldrv_op_counter;	/* Indicates ldrv op started/completed */
+	u8 ldrv_opid;		/* ldrv num */
+	u8 ldrv_opcmd;		/* ldrv operation - defined below */
+	u8 ldrv_opstatus;	/* status of the operation */
+
+	u8 ldrv_state_counter;	/* Indicates change of ldrv state */
+	u8 ldrv_state_id;		/* ldrv num */
+	u8 ldrv_state_new;	/* New state */
+	u8 ldrv_state_old;	/* old state */
+
+	u8 pdrv_state_counter;	/* Indicates change of ldrv state */
+	u8 pdrv_state_id;		/* pdrv id */
+	u8 pdrv_state_new;	/* New state */
+	u8 pdrv_state_old;	/* old state */
+
+	u8 pdrv_fmt_counter;	/* Indicates pdrv format started/over */
+	u8 pdrv_fmt_id;		/* pdrv id */
+	u8 pdrv_fmt_val;		/* format started/over */
+	u8 pdrv_fmt_rsvd;
+
+	u8 targ_xfer_counter;	/* Indicates SCSI-2 Xfer rate change */
+	u8 targ_xfer_id;	/* pdrv Id  */
+	u8 targ_xfer_val;		/* new Xfer params of last pdrv */
+	u8 targ_xfer_rsvd;
+
+	u8 fcloop_id_chg_counter;	/* Indicates loopid changed */
+	u8 fcloopid_pdrvid;		/* pdrv id */
+	u8 fcloop_id0;			/* loopid on fc loop 0 */
+	u8 fcloop_id1;			/* loopid on fc loop 1 */
+
+	u8 fcloop_state_counter;	/* Indicates loop state changed */
+	u8 fcloop_state0;		/* state of fc loop 0 */
+	u8 fcloop_state1;		/* state of fc loop 1 */
+	u8 fcloop_state_rsvd;
+} __attribute__ ((packed));
+
+#define MAX_NOTIFY_SIZE     0x80
+#define CUR_NOTIFY_SIZE     sizeof(struct notify)
+
+typedef struct {
+	u32	data_size; /* current size in bytes (not including resvd) */
+
+	struct notify notify;
+
+	u8	notify_rsvd[MAX_NOTIFY_SIZE - CUR_NOTIFY_SIZE];
+
+	u8	rebuild_rate;		/* Rebuild rate (0% - 100%) */
+	u8	cache_flush_interval;	/* In terms of Seconds */
+	u8	sense_alert;
+	u8	drive_insert_count;	/* drive insertion count */
+
+	u8	battery_status;
+	u8	num_ldrv;		/* No. of Log Drives configured */
+	u8	recon_state[MAX_LOGICAL_DRIVES_40LD / 8];	/* State of
+							   reconstruct */
+	u16	ldrv_op_status[MAX_LOGICAL_DRIVES_40LD / 8]; /* logdrv
+								 Status */
+
+	u32	ldrv_size[MAX_LOGICAL_DRIVES_40LD];/* Size of each log drv */
+	u8	ldrv_prop[MAX_LOGICAL_DRIVES_40LD];
+	u8	ldrv_state[MAX_LOGICAL_DRIVES_40LD];/* State of log drives */
+	u8	pdrv_state[FC_MAX_PHYSICAL_DEVICES];/* State of phys drvs. */
+	u16	pdrv_format[FC_MAX_PHYSICAL_DEVICES / 16];
+
+	u8	targ_xfer[80];	/* phys device transfer rate */
+	u8	pad1k[263];	/* 761 + 263reserved = 1024 bytes total size */
+} __attribute__ ((packed)) mega_inquiry3;
+
+
+/* Structures */
+typedef struct {
+	u8	max_commands;	/* Max concurrent commands supported */
+	u8	rebuild_rate;	/* Rebuild rate - 0% thru 100% */
+	u8	max_targ_per_chan;	/* Max targ per channel */
+	u8	nchannels;	/* Number of channels on HBA */
+	u8	fw_version[4];	/* Firmware version */
+	u16	age_of_flash;	/* Number of times FW has been flashed */
+	u8	chip_set_value;	/* Contents of 0xC0000832 */
+	u8	dram_size;	/* In MB */
+	u8	cache_flush_interval;	/* in seconds */
+	u8	bios_version[4];
+	u8	board_type;
+	u8	sense_alert;
+	u8	write_config_count;	/* Increase with every configuration
+					   change */
+	u8	drive_inserted_count;	/* Increase with every drive inserted
+					 */
+	u8	inserted_drive;	/* Channel:Id of inserted drive */
+	u8	battery_status;	/*
+				 * BIT 0: battery module missing
+				 * BIT 1: VBAD
+				 * BIT 2: temprature high
+				 * BIT 3: battery pack missing
+				 * BIT 4,5:
+				 *   00 - charge complete
+				 *   01 - fast charge in progress
+				 *   10 - fast charge fail
+				 *   11 - undefined
+				 * Bit 6: counter > 1000
+				 * Bit 7: Undefined
+				 */
+	u8	dec_fault_bus_info;
+} __attribute__ ((packed)) mega_adp_info;
+
+
+typedef struct {
+	u8	num_ldrv;	/* Number of logical drives configured */
+	u8	rsvd[3];
+	u32	ldrv_size[MAX_LOGICAL_DRIVES_8LD];
+	u8	ldrv_prop[MAX_LOGICAL_DRIVES_8LD];
+	u8	ldrv_state[MAX_LOGICAL_DRIVES_8LD];
+} __attribute__ ((packed)) mega_ldrv_info;
+
+typedef struct {
+	u8	pdrv_state[MAX_PHYSICAL_DRIVES];
+	u8	rsvd;
+} __attribute__ ((packed)) mega_pdrv_info;
+
+/* RAID inquiry: Mailbox command 0x05*/
+typedef struct {
+	mega_adp_info	adapter_info;
+	mega_ldrv_info	logdrv_info;
+	mega_pdrv_info	pdrv_info;
+} __attribute__ ((packed)) mraid_inquiry;
+
+
+/* RAID extended inquiry: Mailbox command 0x04*/
+typedef struct {
+	mraid_inquiry	raid_inq;
+	u16	phys_drv_format[MAX_CHANNELS];
+	u8	stack_attn;
+	u8	modem_status;
+	u8	rsvd[2];
+} __attribute__ ((packed)) mraid_ext_inquiry;
+
+
+typedef struct {
+	u8	channel;
+	u8	target;
+}__attribute__ ((packed)) adp_device;
+
+typedef struct {
+	u32		start_blk;	/* starting block */
+	u32		num_blks;	/* # of blocks */
+	adp_device	device[MAX_ROW_SIZE_40LD];
+}__attribute__ ((packed)) adp_span_40ld;
+
+typedef struct {
+	u32		start_blk;	/* starting block */
+	u32		num_blks;	/* # of blocks */
+	adp_device	device[MAX_ROW_SIZE_8LD];
+}__attribute__ ((packed)) adp_span_8ld;
+
+typedef struct {
+	u8	span_depth;	/* Total # of spans */
+	u8	level;		/* RAID level */
+	u8	read_ahead;	/* read ahead, no read ahead, adaptive read
+				   ahead */
+	u8	stripe_sz;	/* Encoded stripe size */
+	u8	status;		/* Status of the logical drive */
+	u8	write_mode;	/* write mode, write_through/write_back */
+	u8	direct_io;	/* direct io or through cache */
+	u8	row_size;	/* Number of stripes in a row */
+} __attribute__ ((packed)) logdrv_param;
+
+typedef struct {
+	logdrv_param	lparam;
+	adp_span_40ld	span[MAX_SPAN_DEPTH];
+}__attribute__ ((packed)) logdrv_40ld;
+
+typedef struct {
+	logdrv_param	lparam;
+	adp_span_8ld	span[MAX_SPAN_DEPTH];
+}__attribute__ ((packed)) logdrv_8ld;
+
+typedef struct {
+	u8	type;		/* Type of the device */
+	u8	cur_status;	/* current status of the device */
+	u8	tag_depth;	/* Level of tagging */
+	u8	sync_neg;	/* sync negotiation - ENABLE or DISBALE */
+	u32	size;		/* configurable size in terms of 512 byte
+				   blocks */
+}__attribute__ ((packed)) phys_drv;
+
+typedef struct {
+	u8		nlog_drives;		/* number of logical drives */
+	u8		resvd[3];
+	logdrv_40ld	ldrv[MAX_LOGICAL_DRIVES_40LD];
+	phys_drv	pdrv[MAX_PHYSICAL_DRIVES];
+}__attribute__ ((packed)) disk_array_40ld;
+
+typedef struct {
+	u8		nlog_drives;	/* number of logical drives */
+	u8		resvd[3];
+	logdrv_8ld	ldrv[MAX_LOGICAL_DRIVES_8LD];
+	phys_drv	pdrv[MAX_PHYSICAL_DRIVES];
+}__attribute__ ((packed)) disk_array_8ld;
+
+
+/*
+ * User ioctl structure.
+ * This structure will be used for Traditional Method ioctl interface
+ * commands (0x80),Alternate Buffer Method (0x81) ioctl commands and the
+ * Driver ioctls.
+ * The Driver ioctl interface handles the commands at the driver level,
+ * without being sent to the card.
+ */
+/* system call imposed limit. Change accordingly */
+#define IOCTL_MAX_DATALEN       4096
+
+struct uioctl_t {
+	u32 inlen;
+	u32 outlen;
+	union {
+		u8 fca[16];
+		struct {
+			u8 opcode;
+			u8 subopcode;
+			u16 adapno;
+#if BITS_PER_LONG == 32
+			u8 *buffer;
+			u8 pad[4];
+#endif
+#if BITS_PER_LONG == 64
+			u8 *buffer;
+#endif
+			u32 length;
+		} __attribute__ ((packed)) fcs;
+	} __attribute__ ((packed)) ui;
+	u8 mbox[18];		/* 16 bytes + 2 status bytes */
+	mega_passthru pthru;
+#if BITS_PER_LONG == 32
+	char __user *data;		/* buffer <= 4096 for 0x80 commands */
+	char pad[4];
+#endif
+#if BITS_PER_LONG == 64
+	char __user *data;
+#endif
+} __attribute__ ((packed));
+
+/*
+ * struct mcontroller is used to pass information about the controllers in the
+ * system. Its upto the application how to use the information. We are passing
+ * as much info about the cards as possible and useful. Before issuing the
+ * call to find information about the cards, the applicaiton needs to issue a
+ * ioctl first to find out the number of controllers in the system.
+ */
+#define MAX_CONTROLLERS 32
+
+struct mcontroller {
+	u64 base;
+	u8 irq;
+	u8 numldrv;
+	u8 pcibus;
+	u16 pcidev;
+	u8 pcifun;
+	u16 pciid;
+	u16 pcivendor;
+	u8 pcislot;
+	u32 uid;
+};
+
+/*
+ * mailbox structure used for internal commands
+ */
+typedef struct {
+	u8	cmd;
+	u8	cmdid;
+	u8	opcode;
+	u8	subopcode;
+	u32	lba;
+	u32	xferaddr;
+	u8	logdrv;
+	u8	rsvd[3];
+	u8	numstatus;
+	u8	status;
+} __attribute__ ((packed)) megacmd_t;
+
+/*
+ * Defines for Driver IOCTL interface
+ */
+#define MEGAIOC_MAGIC  	'm'
+
+#define MEGAIOC_QNADAP		'm'	/* Query # of adapters */
+#define MEGAIOC_QDRVRVER	'e'	/* Query driver version */
+#define MEGAIOC_QADAPINFO   	'g'	/* Query adapter information */
+#define MKADAP(adapno)	  	(MEGAIOC_MAGIC << 8 | (adapno) )
+#define GETADAP(mkadap)	 	( (mkadap) ^ MEGAIOC_MAGIC << 8 )
+
+/*
+ * Definition for the new ioctl interface (NIT)
+ */
+
+/*
+ * Vendor specific Group-7 commands
+ */
+#define VENDOR_SPECIFIC_COMMANDS	0xE0
+#define MEGA_INTERNAL_CMD		VENDOR_SPECIFIC_COMMANDS + 0x01
+
+/*
+ * The ioctl command. No other command shall be used for this interface
+ */
+#define USCSICMD	VENDOR_SPECIFIC_COMMANDS
+
+/*
+ * Data direction flags
+ */
+#define UIOC_RD		0x00001
+#define UIOC_WR		0x00002
+
+/*
+ * ioctl opcodes
+ */
+#define MBOX_CMD	0x00000	/* DCMD or passthru command */
+#define GET_DRIVER_VER	0x10000	/* Get driver version */
+#define GET_N_ADAP	0x20000	/* Get number of adapters */
+#define GET_ADAP_INFO	0x30000	/* Get information about a adapter */
+#define GET_CAP		0x40000	/* Get ioctl capabilities */
+#define GET_STATS	0x50000	/* Get statistics, including error info */
+
+
+/*
+ * The ioctl structure.
+ * MBOX macro converts a nitioctl_t structure to megacmd_t pointer and
+ * MBOX_P macro converts a nitioctl_t pointer to megacmd_t pointer.
+ */
+typedef struct {
+	char		signature[8];	/* Must contain "MEGANIT" */
+	u32		opcode;		/* opcode for the command */
+	u32		adapno;		/* adapter number */
+	union {
+		u8	__raw_mbox[18];
+		void __user *__uaddr; /* xferaddr for non-mbox cmds */
+	}__ua;
+
+#define uioc_rmbox	__ua.__raw_mbox
+#define MBOX(uioc)	((megacmd_t *)&((uioc).__ua.__raw_mbox[0]))
+#define MBOX_P(uioc)	((megacmd_t __user *)&((uioc)->__ua.__raw_mbox[0]))
+#define uioc_uaddr	__ua.__uaddr
+
+	u32		xferlen;	/* xferlen for DCMD and non-mbox
+					   commands */
+	u32		flags;		/* data direction flags */
+}nitioctl_t;
+
+
+/*
+ * I/O statistics for some applications like SNMP agent. The caller must
+ * provide the number of logical drives for which status should be reported.
+ */
+typedef struct {
+	int	num_ldrv;	/* Number for logical drives for which the
+				   status should be reported. */
+	u32	nreads[MAX_LOGICAL_DRIVES_40LD];	/* number of reads for
+							each logical drive */
+	u32	nreadblocks[MAX_LOGICAL_DRIVES_40LD];	/* number of blocks
+							read for each logical
+							drive */
+	u32	nwrites[MAX_LOGICAL_DRIVES_40LD];	/* number of writes
+							for each logical
+							drive */
+	u32	nwriteblocks[MAX_LOGICAL_DRIVES_40LD];	/* number of blocks
+							writes for each
+							logical drive */
+	u32	rd_errors[MAX_LOGICAL_DRIVES_40LD];	/* number of read
+							   errors for each
+							   logical drive */
+	u32	wr_errors[MAX_LOGICAL_DRIVES_40LD];	/* number of write
+							   errors for each
+							   logical drive */
+}megastat_t;
+
+
+struct private_bios_data {
+	u8	geometry:4;	/*
+				 * bits 0-3 - BIOS geometry
+				 * 0x0001 - 1GB
+				 * 0x0010 - 2GB
+				 * 0x1000 - 8GB
+				 * Others values are invalid
+							 */
+	u8	unused:4;	/* bits 4-7 are unused */
+	u8	boot_drv;	/*
+				 * logical drive set as boot drive
+				 * 0..7 - for 8LD cards
+				 * 0..39 - for 40LD cards
+				 */
+	u8	rsvd[12];
+	u16	cksum;	/* 0-(sum of first 13 bytes of this structure) */
+} __attribute__ ((packed));
+
+
+
+
+/*
+ * Mailbox and firmware commands and subopcodes used in this driver.
+ */
+
+#define MEGA_MBOXCMD_LREAD	0x01
+#define MEGA_MBOXCMD_LWRITE	0x02
+#define MEGA_MBOXCMD_PASSTHRU	0x03
+#define MEGA_MBOXCMD_ADPEXTINQ	0x04
+#define MEGA_MBOXCMD_ADAPTERINQ	0x05
+#define MEGA_MBOXCMD_LREAD64	0xA7
+#define MEGA_MBOXCMD_LWRITE64	0xA8
+#define MEGA_MBOXCMD_PASSTHRU64	0xC3
+#define MEGA_MBOXCMD_EXTPTHRU	0xE3
+
+#define MAIN_MISC_OPCODE	0xA4	/* f/w misc opcode */
+#define GET_MAX_SG_SUPPORT	0x01	/* get max sg len supported by f/w */
+
+#define FC_NEW_CONFIG		0xA1
+#define NC_SUBOP_PRODUCT_INFO	0x0E
+#define NC_SUBOP_ENQUIRY3	0x0F
+#define ENQ3_GET_SOLICITED_FULL	0x02
+#define OP_DCMD_READ_CONFIG	0x04
+#define NEW_READ_CONFIG_8LD	0x67
+#define READ_CONFIG_8LD		0x07
+#define FLUSH_ADAPTER		0x0A
+#define FLUSH_SYSTEM		0xFE
+
+/*
+ * Command for random deletion of logical drives
+ */
+#define	FC_DEL_LOGDRV		0xA4	/* f/w command */
+#define	OP_SUP_DEL_LOGDRV	0x2A	/* is feature supported */
+#define OP_GET_LDID_MAP		0x18	/* get ldid and logdrv number map */
+#define OP_DEL_LOGDRV		0x1C	/* delete logical drive */
+
+/*
+ * BIOS commands
+ */
+#define IS_BIOS_ENABLED		0x62
+#define GET_BIOS		0x01
+#define CHNL_CLASS		0xA9
+#define GET_CHNL_CLASS		0x00
+#define SET_CHNL_CLASS		0x01
+#define CH_RAID			0x01
+#define CH_SCSI			0x00
+#define BIOS_PVT_DATA		0x40
+#define GET_BIOS_PVT_DATA	0x00
+
+
+/*
+ * Commands to support clustering
+ */
+#define MEGA_GET_TARGET_ID	0x7D
+#define MEGA_CLUSTER_OP		0x70
+#define MEGA_GET_CLUSTER_MODE	0x02
+#define MEGA_CLUSTER_CMD	0x6E
+#define MEGA_RESERVE_LD		0x01
+#define MEGA_RELEASE_LD		0x02
+#define MEGA_RESET_RESERVATIONS	0x03
+#define MEGA_RESERVATION_STATUS	0x04
+#define MEGA_RESERVE_PD		0x05
+#define MEGA_RELEASE_PD		0x06
+
+
+/*
+ * Module battery status
+ */
+#define MEGA_BATT_MODULE_MISSING	0x01
+#define MEGA_BATT_LOW_VOLTAGE		0x02
+#define MEGA_BATT_TEMP_HIGH		0x04
+#define MEGA_BATT_PACK_MISSING		0x08
+#define MEGA_BATT_CHARGE_MASK		0x30
+#define MEGA_BATT_CHARGE_DONE		0x00
+#define MEGA_BATT_CHARGE_INPROG		0x10
+#define MEGA_BATT_CHARGE_FAIL		0x20
+#define MEGA_BATT_CYCLES_EXCEEDED	0x40
+
+/*
+ * Physical drive states.
+ */
+#define PDRV_UNCNF	0
+#define PDRV_ONLINE	3
+#define PDRV_FAILED	4
+#define PDRV_RBLD	5
+#define PDRV_HOTSPARE	6
+
+
+/*
+ * Raid logical drive states.
+ */
+#define RDRV_OFFLINE	0
+#define RDRV_DEGRADED	1
+#define RDRV_OPTIMAL	2
+#define RDRV_DELETED	3
+
+/*
+ * Read, write and cache policies
+ */
+#define NO_READ_AHEAD		0
+#define READ_AHEAD		1
+#define ADAP_READ_AHEAD		2
+#define WRMODE_WRITE_THRU	0
+#define WRMODE_WRITE_BACK	1
+#define CACHED_IO		0
+#define DIRECT_IO		1
+
+
+#define SCSI_LIST(scp) ((struct list_head *)(&(scp)->SCp))
+
+/*
+ * Each controller's soft state
+ */
+typedef struct {
+	int	this_id;	/* our id, may set to different than 7 if
+				   clustering is available */
+	u32	flag;
+
+	unsigned long	base;
+
+	/* mbox64 with mbox not aligned on 16-byte boundry */
+	mbox64_t	*una_mbox64;
+	dma_addr_t	una_mbox64_dma;
+
+	volatile mbox64_t	*mbox64;/* ptr to 64-bit mailbox */
+	volatile mbox_t		*mbox;	/* ptr to standard mailbox */
+	dma_addr_t		mbox_dma;
+
+	struct pci_dev	*dev;
+
+	struct list_head	free_list;
+	struct list_head	pending_list;
+	struct list_head	completed_list;
+
+	struct Scsi_Host	*host;
+
+#define MEGA_BUFFER_SIZE (2*1024)
+	u8		*mega_buffer;
+	dma_addr_t	buf_dma_handle;
+
+	mega_product_info	product_info;
+
+	u8		max_cmds;
+	scb_t		*scb_list;
+
+	atomic_t	pend_cmds;	/* maintain a counter for pending
+					   commands in firmware */
+
+#if MEGA_HAVE_STATS
+	u32	nreads[MAX_LOGICAL_DRIVES_40LD];
+	u32	nreadblocks[MAX_LOGICAL_DRIVES_40LD];
+	u32	nwrites[MAX_LOGICAL_DRIVES_40LD];
+	u32	nwriteblocks[MAX_LOGICAL_DRIVES_40LD];
+	u32	rd_errors[MAX_LOGICAL_DRIVES_40LD];
+	u32	wr_errors[MAX_LOGICAL_DRIVES_40LD];
+#endif
+
+	/* Host adapter parameters */
+	u8	numldrv;
+	u8	fw_version[7];
+	u8	bios_version[7];
+
+#ifdef CONFIG_PROC_FS
+	struct proc_dir_entry	*controller_proc_dir_entry;
+	struct proc_dir_entry	*proc_read;
+	struct proc_dir_entry	*proc_stat;
+	struct proc_dir_entry	*proc_mbox;
+
+#if MEGA_HAVE_ENH_PROC
+	struct proc_dir_entry	*proc_rr;
+	struct proc_dir_entry	*proc_battery;
+#define MAX_PROC_CHANNELS	4
+	struct proc_dir_entry	*proc_pdrvstat[MAX_PROC_CHANNELS];
+	struct proc_dir_entry	*proc_rdrvstat[MAX_PROC_CHANNELS];
+#endif
+
+#endif
+
+	int	has_64bit_addr;		/* are we using 64-bit addressing */
+	int	support_ext_cdb;
+	int	boot_ldrv_enabled;
+	int	boot_ldrv;
+	int	boot_pdrv_enabled;	/* boot from physical drive */
+	int	boot_pdrv_ch;		/* boot physical drive channel */
+	int	boot_pdrv_tgt;		/* boot physical drive target */
+
+
+	int	support_random_del;	/* Do we support random deletion of
+					   logdrvs */
+	int	read_ldidmap;	/* set after logical drive deltion. The
+				   logical drive number must be read from the
+				   map */
+	atomic_t	quiescent;	/* a stage reached when delete logical
+					   drive needs to be done. Stop
+					   sending requests to the hba till
+					   delete operation is completed */
+	spinlock_t	lock;
+
+	u8	logdrv_chan[MAX_CHANNELS+NVIRT_CHAN]; /* logical drive are on
+							what channels. */
+	int	mega_ch_class;
+
+	u8	sglen;	/* f/w supported scatter-gather list length */
+
+	scb_t			int_scb;
+	Scsi_Cmnd		int_scmd;
+	struct semaphore	int_mtx;	/* To synchronize the internal
+						commands */
+	wait_queue_head_t	int_waitq;	/* wait queue for internal
+						 cmds */
+
+	int	has_cluster;	/* cluster support on this HBA */
+}adapter_t;
+
+
+struct mega_hbas {
+	int is_bios_enabled;
+	adapter_t *hostdata_addr;
+};
+
+
+/*
+ * For state flag. Do not use LSB(8 bits) which are
+ * reserved for storing info about channels.
+ */
+#define IN_ABORT	0x80000000L
+#define IN_RESET	0x40000000L
+#define BOARD_MEMMAP	0x20000000L
+#define BOARD_IOMAP	0x10000000L
+#define BOARD_40LD   	0x08000000L
+#define BOARD_64BIT	0x04000000L
+
+#define INTR_VALID			0x40
+
+#define PCI_CONF_AMISIG			0xa0
+#define PCI_CONF_AMISIG64		0xa4
+
+
+#define MEGA_DMA_TYPE_NONE		0xFFFF
+#define MEGA_BULK_DATA			0x0001
+#define MEGA_SGLIST			0x0002
+
+/*
+ * lockscope definitions, callers can specify the lock scope with this data
+ * type. LOCK_INT would mean the caller has not acquired the lock before
+ * making the call and LOCK_EXT would mean otherwise.
+ */
+typedef enum { LOCK_INT, LOCK_EXT } lockscope_t;
+
+/*
+ * Parameters for the io-mapped controllers
+ */
+
+/* I/O Port offsets */
+#define CMD_PORT	 	0x00
+#define ACK_PORT	 	0x00
+#define TOGGLE_PORT		0x01
+#define INTR_PORT	  	0x0a
+
+#define MBOX_BUSY_PORT     	0x00
+#define MBOX_PORT0	 	0x04
+#define MBOX_PORT1	 	0x05
+#define MBOX_PORT2	 	0x06
+#define MBOX_PORT3	 	0x07
+#define ENABLE_MBOX_REGION 	0x0B
+
+/* I/O Port Values */
+#define ISSUE_BYTE	 	0x10
+#define ACK_BYTE	   	0x08
+#define ENABLE_INTR_BYTE   	0xc0
+#define DISABLE_INTR_BYTE  	0x00
+#define VALID_INTR_BYTE    	0x40
+#define MBOX_BUSY_BYTE     	0x10
+#define ENABLE_MBOX_BYTE   	0x00
+
+
+/* Setup some port macros here */
+#define issue_command(adapter)	\
+		outb_p(ISSUE_BYTE, (adapter)->base + CMD_PORT)
+
+#define irq_state(adapter)	inb_p((adapter)->base + INTR_PORT)
+
+#define set_irq_state(adapter, value)	\
+		outb_p((value), (adapter)->base + INTR_PORT)
+
+#define irq_ack(adapter)	\
+		outb_p(ACK_BYTE, (adapter)->base + ACK_PORT)
+
+#define irq_enable(adapter)	\
+	outb_p(ENABLE_INTR_BYTE, (adapter)->base + TOGGLE_PORT)
+
+#define irq_disable(adapter)	\
+	outb_p(DISABLE_INTR_BYTE, (adapter)->base + TOGGLE_PORT)
+
+
+/*
+ * This is our SYSDEP area. All kernel specific detail should be placed here -
+ * as much as possible
+ */
+
+/*
+ * End of SYSDEP area
+ */
+
+const char *megaraid_info (struct Scsi_Host *);
+
+static int mega_query_adapter(adapter_t *);
+static int issue_scb(adapter_t *, scb_t *);
+static int mega_setup_mailbox(adapter_t *);
+
+static int megaraid_queue (Scsi_Cmnd *, void (*)(Scsi_Cmnd *));
+static scb_t * mega_build_cmd(adapter_t *, Scsi_Cmnd *, int *);
+static void __mega_runpendq(adapter_t *);
+static int issue_scb_block(adapter_t *, u_char *);
+
+static irqreturn_t megaraid_isr_memmapped(int, void *, struct pt_regs *);
+static irqreturn_t megaraid_isr_iomapped(int, void *, struct pt_regs *);
+
+static void mega_free_scb(adapter_t *, scb_t *);
+
+static int megaraid_abort(Scsi_Cmnd *);
+static int megaraid_reset(Scsi_Cmnd *);
+static int megaraid_abort_and_reset(adapter_t *, Scsi_Cmnd *, int);
+static int megaraid_biosparam(struct scsi_device *, struct block_device *,
+		sector_t, int []);
+static int mega_print_inquiry(char *, char *);
+
+static int mega_build_sglist (adapter_t *adapter, scb_t *scb,
+			      u32 *buffer, u32 *length);
+static int __mega_busywait_mbox (adapter_t *);
+static void mega_rundoneq (adapter_t *);
+static void mega_cmd_done(adapter_t *, u8 [], int, int);
+static inline void mega_free_sgl (adapter_t *adapter);
+static void mega_8_to_40ld (mraid_inquiry *inquiry,
+		mega_inquiry3 *enquiry3, mega_product_info *);
+
+static int megadev_open (struct inode *, struct file *);
+static int megadev_ioctl (struct inode *, struct file *, unsigned int,
+		unsigned long);
+static int mega_m_to_n(void __user *, nitioctl_t *);
+static int mega_n_to_m(void __user *, megacmd_t *);
+
+static int mega_init_scb (adapter_t *);
+
+static int mega_is_bios_enabled (adapter_t *);
+
+#ifdef CONFIG_PROC_FS
+static void mega_create_proc_entry(int, struct proc_dir_entry *);
+static int proc_read_config(char *, char **, off_t, int, int *, void *);
+static int proc_read_stat(char *, char **, off_t, int, int *, void *);
+static int proc_read_mbox(char *, char **, off_t, int, int *, void *);
+static int proc_rebuild_rate(char *, char **, off_t, int, int *, void *);
+static int proc_battery(char *, char **, off_t, int, int *, void *);
+static int proc_pdrv_ch0(char *, char **, off_t, int, int *, void *);
+static int proc_pdrv_ch1(char *, char **, off_t, int, int *, void *);
+static int proc_pdrv_ch2(char *, char **, off_t, int, int *, void *);
+static int proc_pdrv_ch3(char *, char **, off_t, int, int *, void *);
+static int proc_pdrv(adapter_t *, char *, int);
+static int proc_rdrv_10(char *, char **, off_t, int, int *, void *);
+static int proc_rdrv_20(char *, char **, off_t, int, int *, void *);
+static int proc_rdrv_30(char *, char **, off_t, int, int *, void *);
+static int proc_rdrv_40(char *, char **, off_t, int, int *, void *);
+static int proc_rdrv(adapter_t *, char *, int, int);
+#endif
+
+static int mega_adapinq(adapter_t *, dma_addr_t);
+static int mega_internal_dev_inquiry(adapter_t *, u8, u8, dma_addr_t);
+
+static int mega_support_ext_cdb(adapter_t *);
+static mega_passthru* mega_prepare_passthru(adapter_t *, scb_t *,
+		Scsi_Cmnd *, int, int);
+static mega_ext_passthru* mega_prepare_extpassthru(adapter_t *,
+		scb_t *, Scsi_Cmnd *, int, int);
+static void mega_enum_raid_scsi(adapter_t *);
+static void mega_get_boot_drv(adapter_t *);
+static int mega_support_random_del(adapter_t *);
+static int mega_del_logdrv(adapter_t *, int);
+static int mega_do_del_logdrv(adapter_t *, int);
+static void mega_get_max_sgl(adapter_t *);
+static int mega_internal_command(adapter_t *, lockscope_t, megacmd_t *,
+		mega_passthru *);
+static void mega_internal_done(Scsi_Cmnd *);
+static int mega_support_cluster(adapter_t *);
+#endif
+
+/* vi: set ts=8 sw=8 tw=78: */
