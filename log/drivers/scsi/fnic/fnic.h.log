commit f03dc9cfc86f7b6a1bb403adeab5543349db1ffc
Author: Satish Kharat <satishkh@cisco.com>
Date:   Fri Jan 18 14:51:45 2019 -0800

    scsi: fnic: Update fnic driver version to 1.6.0.47
    
    Update fnic driver to version 1.6.0.47.
    
    Signed-off-by: Satish Kharat <satishkh@cisco.com>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/fnic/fnic.h b/drivers/scsi/fnic/fnic.h
index a3f20ae0add5..477513dc23b7 100644
--- a/drivers/scsi/fnic/fnic.h
+++ b/drivers/scsi/fnic/fnic.h
@@ -39,7 +39,7 @@
 
 #define DRV_NAME		"fnic"
 #define DRV_DESCRIPTION		"Cisco FCoE HBA Driver"
-#define DRV_VERSION		"1.6.0.34"
+#define DRV_VERSION		"1.6.0.47"
 #define PFX			DRV_NAME ": "
 #define DFX                     DRV_NAME "%d: "
 

commit 18244e9445fef9eef7f3afd3b70a42b87be0f8fd
Author: Satish Kharat <satishkh@cisco.com>
Date:   Mon Jan 14 17:09:29 2019 -0800

    scsi: fnic: Impose upper limit on max. # of CQs processed per intr
    
    Impose an upper limit on the max number of CQ entries (corresponding to the
    copy wq) processed in an interrupt.  Use module parameter to set the limit.
    
    Signed-off-by: Satish Kharat <satishkh@cisco.com>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/fnic/fnic.h b/drivers/scsi/fnic/fnic.h
index 5c9402c811c9..a3f20ae0add5 100644
--- a/drivers/scsi/fnic/fnic.h
+++ b/drivers/scsi/fnic/fnic.h
@@ -128,6 +128,7 @@
 	__fnic_set_state_flags(fnicp, st_flags, 1)
 
 extern unsigned int fnic_log_level;
+extern unsigned int io_completions;
 
 #define FNIC_MAIN_LOGGING 0x01
 #define FNIC_FCS_LOGGING 0x02
@@ -196,6 +197,7 @@ enum fnic_state {
 #define FNIC_WQ_MAX 1
 #define FNIC_RQ_MAX 1
 #define FNIC_CQ_MAX (FNIC_WQ_COPY_MAX + FNIC_WQ_MAX + FNIC_RQ_MAX)
+#define FNIC_DFLT_IO_COMPLETIONS 256
 
 struct mempool;
 

commit 1c55262649a823a1d1c9ea37e7403ea3edd2b9c3
Author: Satish Kharat <satishkh@cisco.com>
Date:   Mon Jan 14 17:09:21 2019 -0800

    scsi: fnic: change fnic queue depth to 256
    
    This patch changes the default lun queuedepth for fnic to 256.
    
    Signed-off-by: Satish Kharat <satishkh@cisco.com>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/fnic/fnic.h b/drivers/scsi/fnic/fnic.h
index d094ba59ed15..5c9402c811c9 100644
--- a/drivers/scsi/fnic/fnic.h
+++ b/drivers/scsi/fnic/fnic.h
@@ -49,7 +49,7 @@
 #define FNIC_MAX_IO_REQ		1024 /* scsi_cmnd tag map entries */
 #define FNIC_DFLT_IO_REQ        256 /* Default scsi_cmnd tag map entries */
 #define	FNIC_IO_LOCKS		64 /* IO locks: power of 2 */
-#define FNIC_DFLT_QUEUE_DEPTH	32
+#define FNIC_DFLT_QUEUE_DEPTH	256
 #define	FNIC_STATS_RATE_LIMIT	4 /* limit rate at which stats are pulled up */
 
 /*

commit 514e59c1195f2634dab025d952242f5e69e052c7
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Fri Jul 14 14:06:58 2017 +0200

    scsi: fnic: fix format string overflow warning
    
    The MSI interrupt name can require 11 bytes in addition to the device name,
    for a total of 23 bytes:
    
    drivers/scsi/fnic/fnic_isr.c: In function 'fnic_request_intr':
    drivers/scsi/fnic/fnic_isr.c:192:4: error: '-fcs-rq' directive writing 7 bytes into a region of size between 5 and 16 [-Werror=format-overflow=]
        "%.11s-fcs-rq", fnic->name);
    drivers/scsi/fnic/fnic_isr.c:206:3: note: 'sprintf' output between 12 and 23 bytes into a destination of size 16
       sprintf(fnic->msix[FNIC_MSIX_ERR_NOTIFY].devname,
       ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        "%.11s-err-notify", fnic->name);
    
    This extends the buffer to fit any possible value.
    
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/fnic/fnic.h b/drivers/scsi/fnic/fnic.h
index 67aab965c0f4..d094ba59ed15 100644
--- a/drivers/scsi/fnic/fnic.h
+++ b/drivers/scsi/fnic/fnic.h
@@ -180,7 +180,7 @@ enum fnic_msix_intr_index {
 
 struct fnic_msix_entry {
 	int requested;
-	char devname[IFNAMSIZ];
+	char devname[IFNAMSIZ + 11];
 	irqreturn_t (*isr)(int, void *);
 	void *devid;
 };

commit 445d2960862eb3c972012bbbb9cf4ee338334b0a
Author: Satish Kharat <satishkh@cisco.com>
Date:   Tue Feb 28 16:15:59 2017 -0800

    scsi: fnic: Adding debug IO and Abort latency counter to fnic stats
    
    The IO and Abort latency counter counts the time taken to complete the
    IO and abort command into broad buckets. This is not intended for
    performance measurement, just a debug statistic.  current_max_io_time
    tries to keep track of the maximum time an IO has taken to complete if
    it is > 30sec.
    
    Signed-off-by: Satish Kharat <satishkh@cisco.com>
    Signed-off-by: Sesidhar Baddela <sebaddel@cisco.com>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/fnic/fnic.h b/drivers/scsi/fnic/fnic.h
index 7d5739e437d2..67aab965c0f4 100644
--- a/drivers/scsi/fnic/fnic.h
+++ b/drivers/scsi/fnic/fnic.h
@@ -39,7 +39,7 @@
 
 #define DRV_NAME		"fnic"
 #define DRV_DESCRIPTION		"Cisco FCoE HBA Driver"
-#define DRV_VERSION		"1.6.0.21"
+#define DRV_VERSION		"1.6.0.34"
 #define PFX			DRV_NAME ": "
 #define DFX                     DRV_NAME "%d: "
 

commit cca678dfbad4954d53e58ca6b132b306c56f4423
Author: Christoph Hellwig <hch@lst.de>
Date:   Wed Feb 1 15:02:53 2017 +0100

    scsi: fnic: switch to pci_alloc_irq_vectors
    
    Not a full cleanup for the IRQ code, for that we'd need to know if the
    max number of the various CQ types is going to stay 1 forever.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Acked-by: Satish Kharat <satishkh@cisco.com>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/fnic/fnic.h b/drivers/scsi/fnic/fnic.h
index 9e4b7709043e..7d5739e437d2 100644
--- a/drivers/scsi/fnic/fnic.h
+++ b/drivers/scsi/fnic/fnic.h
@@ -217,7 +217,6 @@ struct fnic {
 	struct fcoe_ctlr ctlr;		/* FIP FCoE controller structure */
 	struct vnic_dev_bar bar0;
 
-	struct msix_entry msix_entry[FNIC_MSIX_INTR_MAX];
 	struct fnic_msix_entry msix[FNIC_MSIX_INTR_MAX];
 
 	struct vnic_stats *stats;

commit 9698b6f473555a722bf81a3371998427d5d27bde
Author: Satish Kharat <satishkh@cisco.com>
Date:   Wed Dec 14 13:20:41 2016 -0800

    scsi: fnic: Avoid sending reset to firmware when another reset is in progress
    
    This fix is to avoid calling fnic_fw_reset_handler through
    fnic_host_reset when a finc reset is alreay in progress.
    
    Signed-off-by: Satish Kharat <satishkh@cisco.com>
    Signed-off-by: Sesidhar Baddela <sebaddel@cisco.com>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/fnic/fnic.h b/drivers/scsi/fnic/fnic.h
index 9ddc9200e0a4..9e4b7709043e 100644
--- a/drivers/scsi/fnic/fnic.h
+++ b/drivers/scsi/fnic/fnic.h
@@ -248,6 +248,7 @@ struct fnic {
 	struct completion *remove_wait; /* device remove thread blocks */
 
 	atomic_t in_flight;		/* io counter */
+	bool internal_reset_inprogress;
 	u32 _reserved;			/* fill hole */
 	unsigned long state_flags;	/* protected by host lock */
 	enum fnic_state state;

commit 1b6ac5e3ff354652ca59240e1ba8b2d22539df07
Author: Satish Kharat <satishkh@cisco.com>
Date:   Fri Mar 18 11:22:50 2016 -0700

    fnic: Using rport->dd_data to check rport online instead of rport_lookup.
    
    When issuing I/O we check if rport is online through libfc
    rport_lookup() function which needs to be protected by mutex lock that
    cannot acquired in I/O context. The change is to use midlayer remote
    port s dd_data which is preserved until its devloss timeout and no
    protection is required.  The the scsi_cmnd error code is expected to be
    in the left 16 bits of the result field. Changed to correct this.  Fnic
    driver version changed from 1.6.0.20 to 1.6.0.21
    
    Signed-off-by: Satish Kharat <satishkh@cisco.com>
    Signed-off-by: Sesidhar Baddela <sebaddel@cisco.com>
    Reviewed-by: Ewan Milne <emilne@redhat.com>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/fnic/fnic.h b/drivers/scsi/fnic/fnic.h
index 1023eaea17f3..9ddc9200e0a4 100644
--- a/drivers/scsi/fnic/fnic.h
+++ b/drivers/scsi/fnic/fnic.h
@@ -39,7 +39,7 @@
 
 #define DRV_NAME		"fnic"
 #define DRV_DESCRIPTION		"Cisco FCoE HBA Driver"
-#define DRV_VERSION		"1.6.0.20"
+#define DRV_VERSION		"1.6.0.21"
 #define PFX			DRV_NAME ": "
 #define DFX                     DRV_NAME "%d: "
 

commit a36f5dd07dd9098d43d1137ec7a2d6b92aa6d591
Author: Satish Kharat <satishkh@cisco.com>
Date:   Fri Mar 18 11:22:49 2016 -0700

    fnic: Cleanup the I/O pending with fw and has timed out and is used to issue LUN reset
    
    In case of LUN reset, the device reset command is issued with one of the
    I/Os that has timed out on that LUN. The change is to also return this
    I/O with error status set to DID_RESET. In case when the reset is issued
    using the sg_reset tool (from sg3_utils) it is a new command and new_sc
    is set to 1.  Fnic driver version changed from 1.6.0.19 to 1.6.0.20
    
    [mkp: Fixed checkpatch warning]
    
    Signed-off-by: Satish Kharat <satishkh@cisco.com>
    Signed-off-by: Sesidhar Baddela <sebaddel@cisco.com>
    Reviewed-by: Ewan Milne <emilne@redhat.com>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/fnic/fnic.h b/drivers/scsi/fnic/fnic.h
index 52a53f8a907a..1023eaea17f3 100644
--- a/drivers/scsi/fnic/fnic.h
+++ b/drivers/scsi/fnic/fnic.h
@@ -39,7 +39,7 @@
 
 #define DRV_NAME		"fnic"
 #define DRV_DESCRIPTION		"Cisco FCoE HBA Driver"
-#define DRV_VERSION		"1.6.0.19"
+#define DRV_VERSION		"1.6.0.20"
 #define PFX			DRV_NAME ": "
 #define DFX                     DRV_NAME "%d: "
 

commit 691a837c20df0f4eacd49596a4d57fc566a40545
Author: Satish Kharat <satishkh@cisco.com>
Date:   Fri Mar 18 11:22:48 2016 -0700

    fnic: Fix to cleanup aborted IO to avoid device being offlined by mid-layer
    
    If an I/O times out and an abort issued by host, if the abort is
    successful we need to set scsi status as DID_ABORT. Or else the
    mid-layer error handler which looks for this error code, will offline
    the device. Also if the original I/O is not found in fnic firmware, we
    will consider the abort as successful.  The start_time assignment is
    moved because of the new goto.  Fnic driver version changed from
    1.6.0.17a to 1.6.0.19, version 1.6.0.18 has been skipped
    
    [mkp: Fixed checkpatch warning]
    
    Signed-off-by: Satish Kharat <satishkh@cisco.com>
    Signed-off-by: Sesidhar Baddela <sebaddel@cisco.com>
    Reviewed-by: Ewan D. Milne <emilne@redhat.com>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/fnic/fnic.h b/drivers/scsi/fnic/fnic.h
index ce129e595b55..52a53f8a907a 100644
--- a/drivers/scsi/fnic/fnic.h
+++ b/drivers/scsi/fnic/fnic.h
@@ -39,7 +39,7 @@
 
 #define DRV_NAME		"fnic"
 #define DRV_DESCRIPTION		"Cisco FCoE HBA Driver"
-#define DRV_VERSION		"1.6.0.17a"
+#define DRV_VERSION		"1.6.0.19"
 #define PFX			DRV_NAME ": "
 #define DFX                     DRV_NAME "%d: "
 

commit db196935d9562abec4510f48d887bc1f1e054fcf
Author: Hiral Shah <hishah@cisco.com>
Date:   Tue Jul 14 07:08:57 2015 -0700

    fnic: Use the local variable instead of I/O flag to acquire io_req_lock in fnic_queuecommand() to avoid deadloack
    
    We added changes in fnic driver patch 1.6.0.16 to acquire
    io_req_lock in fnic_queuecommand() before issuing I/O so that io completion
    is serialized. But when releasing the lock we check for the I/O flag and
    this could be modified if IO abort occurs before I/O completion. In this case
    we wont release the lock and causes deadlock in some scenerios. Using the
    local variable to check the IO lock status will resolve the problem.
    
    Fixes: 41df7b02db82cf6c14f094757bac3830d10a827f
    Signed-off-by: Hiral Shah <hishah@cisco.com>
    Signed-off-by: Sesidhar Baddela <sebaddel@cisco.com>
    Signed-off-by: Anil Chintalapati <achintal@cisco.com>
    Reviewed-by: Martin K. Petersen <martin.petersen@oracle.com>
    Cc: stable@vger.kernel.org
    Signed-off-by: James Bottomley <JBottomley@Odin.com>

diff --git a/drivers/scsi/fnic/fnic.h b/drivers/scsi/fnic/fnic.h
index 26270c351624..ce129e595b55 100644
--- a/drivers/scsi/fnic/fnic.h
+++ b/drivers/scsi/fnic/fnic.h
@@ -39,7 +39,7 @@
 
 #define DRV_NAME		"fnic"
 #define DRV_DESCRIPTION		"Cisco FCoE HBA Driver"
-#define DRV_VERSION		"1.6.0.17"
+#define DRV_VERSION		"1.6.0.17a"
 #define PFX			DRV_NAME ": "
 #define DFX                     DRV_NAME "%d: "
 

commit efc7a288382cffc76d6cdb9678f643db37991906
Author: Anil Chintalapati (achintal) <achintal@cisco.com>
Date:   Tue Dec 23 19:40:00 2014 +0000

    fnic: IOMMU Fault occurs when IO and abort IO is out of order
    
    When I/O is aborted by mid-layer, fnic FW will complete the I/O before
    completing the abort task. In some cases abort request is completed before
    the I/O, which could lead to inconsistent driver and firmware states.
    In this case firmware reset would clear the inconsistent state.
    
    Signed-off-by: Anil Chintalapati <achintal@cisco.com>
    Signed-off-by: Sesidhar Baddela <sebaddel@cisco.com>
    Signed-off-by: Hiral Shah <hishah@cisco.com>
    Signed-off-by: Christoph Hellwig <hch@lst.de>

diff --git a/drivers/scsi/fnic/fnic.h b/drivers/scsi/fnic/fnic.h
index 3b73b96619e2..26270c351624 100644
--- a/drivers/scsi/fnic/fnic.h
+++ b/drivers/scsi/fnic/fnic.h
@@ -39,7 +39,7 @@
 
 #define DRV_NAME		"fnic"
 #define DRV_DESCRIPTION		"Cisco FCoE HBA Driver"
-#define DRV_VERSION		"1.6.0.16"
+#define DRV_VERSION		"1.6.0.17"
 #define PFX			DRV_NAME ": "
 #define DFX                     DRV_NAME "%d: "
 

commit 41df7b02db82cf6c14f094757bac3830d10a827f
Author: Hiral Shah <hishah@cisco.com>
Date:   Mon Nov 10 12:54:36 2014 -0800

    Fnic: Fnic Driver crashed with NULL pointer reference
    
    When issuing I/O request, if the I/O completes before returning from
    fnic_queuecommand(), we may be referencing scsi_cmnd structure that may
    be freed by interrupt handler. Acquring IO lock would synchronize
    fnic_queuecommand and interrupt handler.
    
    - Increment fnic version from 1.6.0.15 to 1.6.0.16
    
    Signed-off-by: Hiral Shah <hishah@cisco.com>
    Signed-off-by: Sesidhar Baddela <sebaddel@cisco.com>
    Signed-off-by: Anil Chintalapati <achintal@cisco.com>
    Signed-off-by: Christoph Hellwig <hch@lst.de>

diff --git a/drivers/scsi/fnic/fnic.h b/drivers/scsi/fnic/fnic.h
index 977960b03c9f..3b73b96619e2 100644
--- a/drivers/scsi/fnic/fnic.h
+++ b/drivers/scsi/fnic/fnic.h
@@ -39,7 +39,7 @@
 
 #define DRV_NAME		"fnic"
 #define DRV_DESCRIPTION		"Cisco FCoE HBA Driver"
-#define DRV_VERSION		"1.6.0.15"
+#define DRV_VERSION		"1.6.0.16"
 #define PFX			DRV_NAME ": "
 #define DFX                     DRV_NAME "%d: "
 

commit 0ee7b8714dca511a68826a300cc4966f2e83a6c3
Author: Hiral Shah <hishah@cisco.com>
Date:   Mon Nov 10 12:54:35 2014 -0800

    Fnic: For Standalone C series, "sending VLAN request" message seen even if the link is down
    
    When physical link between standalone C series and switch is down,
    the fip timer is not turned off and timer expiration will keep sending
    vlan request.
    
    It can be fixed by stopping the fip_timer and
    it will be restarted automatically when Link is up.
    
    - Increment fnic version from 1.6.0.14 to 1.6.0.15
    
    Signed-off-by: Hiral Shah <hishah@cisco.com>
    Signed-off-by: Sesidhar Baddela <sebaddel@cisco.com>
    Signed-off-by: Anil Chintalapati <achintal@cisco.com>
    Signed-off-by: Christoph Hellwig <hch@lst.de>

diff --git a/drivers/scsi/fnic/fnic.h b/drivers/scsi/fnic/fnic.h
index 5336e8d21704..977960b03c9f 100644
--- a/drivers/scsi/fnic/fnic.h
+++ b/drivers/scsi/fnic/fnic.h
@@ -39,7 +39,7 @@
 
 #define DRV_NAME		"fnic"
 #define DRV_DESCRIPTION		"Cisco FCoE HBA Driver"
-#define DRV_VERSION		"1.6.0.14"
+#define DRV_VERSION		"1.6.0.15"
 #define PFX			DRV_NAME ": "
 #define DFX                     DRV_NAME "%d: "
 

commit 35061e21a1d29dc37ab28a50e82bfcf6de81b65d
Author: Hiral Shah <hishah@cisco.com>
Date:   Mon Nov 10 12:54:34 2014 -0800

    Fnic: Improper resue of exchange Ids
    
    IOs belonging to an rport are aborted with Internal terminate option
    when rport goes offline. Any new IO issued to the rport during this
    time can reuse the terminated exchange which will cause inconsistent
    state of the exchange between local port and remote port.
    
    fc_rport_priv is set to RPORT_ST_DELETE before exchanges are aborted by
    libfc. Not issuing amy more I/O requests when RPORT_ST_DELETE is set,
    will avoid inconsistent state of the exchange between local port and
    remote port.
    
    - Increment fnic version from 1.6.0.13 to 1.6.0.14
    
    Signed-off-by: Hiral Shah <hishah@cisco.com>
    Signed-off-by: Sesidhar Baddela <sebaddel@cisco.com>
    Signed-off-by: Anil Chintalapati <achintal@cisco.com>
    Signed-off-by: Christoph Hellwig <hch@lst.de>

diff --git a/drivers/scsi/fnic/fnic.h b/drivers/scsi/fnic/fnic.h
index dbc69ad2d1c4..5336e8d21704 100644
--- a/drivers/scsi/fnic/fnic.h
+++ b/drivers/scsi/fnic/fnic.h
@@ -39,7 +39,7 @@
 
 #define DRV_NAME		"fnic"
 #define DRV_DESCRIPTION		"Cisco FCoE HBA Driver"
-#define DRV_VERSION		"1.6.0.13"
+#define DRV_VERSION		"1.6.0.14"
 #define PFX			DRV_NAME ": "
 #define DFX                     DRV_NAME "%d: "
 

commit 042b356a5fcf3c5a99c34208eefc572454a330bf
Author: Hiral Shah <hishah@cisco.com>
Date:   Mon Nov 10 12:54:33 2014 -0800

    Fnic: Memcopy only mimumum of data or trace buffer
    
    In case of receive path, we do not have eth header or fcoe header available
    when we take a trace so we fill the fc trace buffer with 0xff for both
    values. We copy only mimimum of received data or trace buffer size -
    fc header - eth and fcoe header
    
    - Increment fnic version from 1.6.0.12 to 1.6.0.13
    
    Signed-off-by: Hiral Shah <hishah@cisco.com>
    Signed-off-by: Sesidhar Baddela <sebaddel@cisco.com>
    Signed-off-by: Anil Chintalapati <achintal@cisco.com>
    Signed-off-by: Christoph Hellwig <hch@lst.de>

diff --git a/drivers/scsi/fnic/fnic.h b/drivers/scsi/fnic/fnic.h
index 69dee6838678..dbc69ad2d1c4 100644
--- a/drivers/scsi/fnic/fnic.h
+++ b/drivers/scsi/fnic/fnic.h
@@ -39,7 +39,7 @@
 
 #define DRV_NAME		"fnic"
 #define DRV_DESCRIPTION		"Cisco FCoE HBA Driver"
-#define DRV_VERSION		"1.6.0.12"
+#define DRV_VERSION		"1.6.0.13"
 #define PFX			DRV_NAME ": "
 #define DFX                     DRV_NAME "%d: "
 

commit a232bfbe195df4b85ff9e5876534fe4081d9fd9a
Author: Hiral Shah <hishah@cisco.com>
Date:   Mon Nov 10 12:54:32 2014 -0800

    Fnic: Not probing all the vNICS via fnic_probe on boot
    
    In fnic_dev_wait, Wait for finish to complete at least three times in two
    seconds while loop before returning -ETIMEDOUT as sometime
    schedule_timeout_uninterruptible takes more than two seconds to wake up.
    
    - Increment fnic version from 1.6.0.11 to 1.6.0.12
    
    Signed-off-by: Hiral Shah <hishah@cisco.com>
    Signed-off-by: Sesidhar Baddela <sebaddel@cisco.com>
    Signed-off-by: Anil Chintalapati <achintal@cisco.com>
    Signed-off-by: Christoph Hellwig <hch@lst.de>

diff --git a/drivers/scsi/fnic/fnic.h b/drivers/scsi/fnic/fnic.h
index bf8d34c26f13..69dee6838678 100644
--- a/drivers/scsi/fnic/fnic.h
+++ b/drivers/scsi/fnic/fnic.h
@@ -39,7 +39,7 @@
 
 #define DRV_NAME		"fnic"
 #define DRV_DESCRIPTION		"Cisco FCoE HBA Driver"
-#define DRV_VERSION		"1.6.0.11"
+#define DRV_VERSION		"1.6.0.12"
 #define PFX			DRV_NAME ": "
 #define DFX                     DRV_NAME "%d: "
 

commit 86001f248e943b7b22c22b50151ffaee9447df2d
Author: Hiral Shah <hishah@cisco.com>
Date:   Fri May 2 17:46:31 2014 -0700

    fnic: assign FIP_ALL_FCF_MACS to fcoe_all_fcfs
    
    1) Assgning FIP_ALL_FCF_MACS to fcoe_all_fcfs allows VLAN request to be sent
    to correct Mac address for VLAN Discovery otherwise VLAN request will be
    sent to invalid address hence FLOGI never happens.
    
    2) Simplify the copy_and_format_trace_data code and log the correct Link event
    for fnic control path tracing in case of link status UP->UP.
    
    3) Increment Fnic driver version
    
    Signed-off-by: Hiral Shah <hishah@cisco.com>
    Signed-off-by: Sesidhar Baddela <sebaddel@cisco.com>
    Signed-off-by: Christoph Hellwig <hch@lst.de>

diff --git a/drivers/scsi/fnic/fnic.h b/drivers/scsi/fnic/fnic.h
index 1d3521e13d77..bf8d34c26f13 100644
--- a/drivers/scsi/fnic/fnic.h
+++ b/drivers/scsi/fnic/fnic.h
@@ -39,7 +39,7 @@
 
 #define DRV_NAME		"fnic"
 #define DRV_DESCRIPTION		"Cisco FCoE HBA Driver"
-#define DRV_VERSION		"1.6.0.10"
+#define DRV_VERSION		"1.6.0.11"
 #define PFX			DRV_NAME ": "
 #define DFX                     DRV_NAME "%d: "
 

commit abb14148c0f850e7201efc3e7aea1762f993606b
Author: Hiral Shah <hishah@cisco.com>
Date:   Fri Apr 18 12:28:19 2014 -0700

    fnic: fnic Control Path Trace Utility
    
    Fnic Ctlr Path Trace utility is a tracing functionality built directly into fnic
    driver to trace the control path frames like discovery, FLOGI request/reply,
    PLOGI request/reply, link event etc.  It will be one trace file for all fnics.
    It will help us to debug and resolve the discovery and initialization related
    issues in more convenient way. This trace information includes time stamp,
    Host Number, Frame type, Frame Length and Frame. By default,64 pages are
    allocated but we can change the number of allocated pages by module parameter
    fnic_fc_trace_max_page. Each entry is of 256 byte and available entries are
    depends on allocated number of pages. We can turn on or off the fnic control
    path trace functionality by module paramter fc_trace_enable and/or reset the
    trace contain by module paramter fc_trace_clear.
    
    Signed-off-by: Hiral Shah <hishah@cisco.com>
    Signed-off-by: Sesidhar Baddela <sebaddel@cisco.com>
    Signed-off-by: Christoph Hellwig <hch@lst.de>

diff --git a/drivers/scsi/fnic/fnic.h b/drivers/scsi/fnic/fnic.h
index ce88951af3d1..1d3521e13d77 100644
--- a/drivers/scsi/fnic/fnic.h
+++ b/drivers/scsi/fnic/fnic.h
@@ -39,7 +39,7 @@
 
 #define DRV_NAME		"fnic"
 #define DRV_DESCRIPTION		"Cisco FCoE HBA Driver"
-#define DRV_VERSION		"1.5.0.45"
+#define DRV_VERSION		"1.6.0.10"
 #define PFX			DRV_NAME ": "
 #define DFX                     DRV_NAME "%d: "
 

commit c8ff03c6da96850e19fcaf359d1ae408308ad9d0
Author: Hiral Shah <hishah@cisco.com>
Date:   Fri Apr 18 12:28:17 2014 -0700

    fnic: NoFIP solicitation frame in NONFIP mode and changed IO Throttle count
    
    This patch contains following three minor fixes.
    
    1) During Probe, fnic was sending FIP solicitation in Non FIP mode which is not
       expected, setting the internal fip state to Non FIP mode explicitly, avoids
       sending FIP frame.
    
    2) When target goes offline, all outstanding IOs belong to the target will be
       terminated by driver, If the termination count is high, then it influences
       firmware responsiveness. To improve the responsiveness, default IO throttle
       count is reduced to 256.
    
    3) Accessing Virtual Fabric Id (vfid) and fc_map of Fibre-Channel Forwarder(FCF)
       is invalid in fnic driver when Clear Virtual Link(CVL) is received prior to
       receiving flogi reject from switch. As CVL clears all FCFs.
    
    Signed-off-by: Hiral Shah <hishah@cisco.com>
    Signed-off-by: Sesidhar Baddela <sebaddel@cisco.com>
    Signed-off-by: Narsimhulu Musini <nmusini@cisco.com>
    Signed-off-by: Anantha Tungarakodi <atungara@cisco.com>
    Signed-off-by: Christoph Hellwig <hch@lst.de>

diff --git a/drivers/scsi/fnic/fnic.h b/drivers/scsi/fnic/fnic.h
index 528d43b7b569..ce88951af3d1 100644
--- a/drivers/scsi/fnic/fnic.h
+++ b/drivers/scsi/fnic/fnic.h
@@ -46,7 +46,8 @@
 #define DESC_CLEAN_LOW_WATERMARK 8
 #define FNIC_UCSM_DFLT_THROTTLE_CNT_BLD	16 /* UCSM default throttle count */
 #define FNIC_MIN_IO_REQ			256 /* Min IO throttle count */
-#define FNIC_MAX_IO_REQ		2048 /* scsi_cmnd tag map entries */
+#define FNIC_MAX_IO_REQ		1024 /* scsi_cmnd tag map entries */
+#define FNIC_DFLT_IO_REQ        256 /* Default scsi_cmnd tag map entries */
 #define	FNIC_IO_LOCKS		64 /* IO locks: power of 2 */
 #define FNIC_DFLT_QUEUE_DEPTH	32
 #define	FNIC_STATS_RATE_LIMIT	4 /* limit rate at which stats are pulled up */

commit 5ae303443094ab49fca41cf331d5af189995bead
Author: Hiral Patel <hiralpat@cisco.com>
Date:   Thu Sep 12 17:45:43 2013 -0700

    [SCSI] fnic: Incremented driver version
    
    Signed-off-by: Hiral Patel <hiralpat@cisco.com>
    Signed-off-by: James Bottomley <JBottomley@Parallels.com>

diff --git a/drivers/scsi/fnic/fnic.h b/drivers/scsi/fnic/fnic.h
index db7a9506ccd3..528d43b7b569 100644
--- a/drivers/scsi/fnic/fnic.h
+++ b/drivers/scsi/fnic/fnic.h
@@ -39,7 +39,7 @@
 
 #define DRV_NAME		"fnic"
 #define DRV_DESCRIPTION		"Cisco FCoE HBA Driver"
-#define DRV_VERSION		"1.5.0.23"
+#define DRV_VERSION		"1.5.0.45"
 #define PFX			DRV_NAME ": "
 #define DFX                     DRV_NAME "%d: "
 

commit 67125b0287a9e6506c4f5afca7376667bf6dab5b
Author: Hiral Patel <hiralpat@cisco.com>
Date:   Thu Sep 12 17:45:42 2013 -0700

    [SCSI] fnic: Fnic Statistics Collection
    
    This feature gathers active and cumulative per fnic stats for io,
    abort, terminate, reset, vlan discovery path and it also includes
    various important stats for debugging issues. It also provided
    debugfs and ioctl interface for user to retrieve these stats.
    It also provides functionality to reset cumulative stats through
    user interface.
    
    Signed-off-by: Hiral Patel <hiralpat@cisco.com>
    Signed-off-by: James Bottomley <JBottomley@Parallels.com>

diff --git a/drivers/scsi/fnic/fnic.h b/drivers/scsi/fnic/fnic.h
index e4dd3d7cd236..db7a9506ccd3 100644
--- a/drivers/scsi/fnic/fnic.h
+++ b/drivers/scsi/fnic/fnic.h
@@ -27,6 +27,7 @@
 #include "fnic_io.h"
 #include "fnic_res.h"
 #include "fnic_trace.h"
+#include "fnic_stats.h"
 #include "vnic_dev.h"
 #include "vnic_wq.h"
 #include "vnic_rq.h"
@@ -232,6 +233,13 @@ struct fnic {
 	unsigned int wq_count;
 	unsigned int cq_count;
 
+	struct dentry *fnic_stats_debugfs_host;
+	struct dentry *fnic_stats_debugfs_file;
+	struct dentry *fnic_reset_debugfs_file;
+	unsigned int reset_stats;
+	atomic64_t io_cmpl_skip;
+	struct fnic_stats fnic_stats;
+
 	u32 vlan_hw_insert:1;	        /* let hw insert the tag */
 	u32 in_remove:1;                /* fnic device in removal */
 	u32 stop_rx_link_events:1;      /* stop proc. rx frames, link events */

commit fc85799ee362e3ef13b8f2f5c687101490aaaa7e
Author: Hiral Patel <hiralpat@cisco.com>
Date:   Mon Sep 9 13:31:51 2013 -0700

    [SCSI] fnic: fnic Driver Tuneables Exposed through CLI
    
    Introduced module params to provide dynamic way of configuring
    queue depth.
    
    Added support to get max io throttle count through UCSM to
    configure maximum outstanding IOs supported by fnic and push
    that value to scsi mid-layer.
    
      Supported IO throttle values:
    
      UCSM IO THROTTLE VALUE        FNIC MAX OUTSTANDING IOS
      ------------------------------------------------------
            16 (Default)                    2048
            <= 256                          256
            > 256                           <ucsm value>
    
    Signed-off-by: Hiral Patel <hiralpat@cisco.com>
    Signed-off-by: James Bottomley <JBottomley@Parallels.com>

diff --git a/drivers/scsi/fnic/fnic.h b/drivers/scsi/fnic/fnic.h
index d276aaf84f18..e4dd3d7cd236 100644
--- a/drivers/scsi/fnic/fnic.h
+++ b/drivers/scsi/fnic/fnic.h
@@ -43,6 +43,8 @@
 #define DFX                     DRV_NAME "%d: "
 
 #define DESC_CLEAN_LOW_WATERMARK 8
+#define FNIC_UCSM_DFLT_THROTTLE_CNT_BLD	16 /* UCSM default throttle count */
+#define FNIC_MIN_IO_REQ			256 /* Min IO throttle count */
 #define FNIC_MAX_IO_REQ		2048 /* scsi_cmnd tag map entries */
 #define	FNIC_IO_LOCKS		64 /* IO locks: power of 2 */
 #define FNIC_DFLT_QUEUE_DEPTH	32
@@ -223,6 +225,7 @@ struct fnic {
 	char name[IFNAMSIZ];
 	struct timer_list notify_timer; /* used for MSI interrupts */
 
+	unsigned int fnic_max_tag_id;
 	unsigned int err_intr_offset;
 	unsigned int link_intr_offset;
 

commit 1adee040114461787c031a792a9392a8b4866fc3
Author: Narsimhulu Musini <nmusini@cisco.com>
Date:   Mon Sep 9 13:31:45 2013 -0700

    [SCSI] fnic: FC stat param seconds_since_last_reset not getting updated
    
    Code to reset fc_host statistics.
    echo 1 > /sys/class/fc_host/hostX/statistics/reset_statistics clears fc_host stats,
    the code also issues command to fnic firmware to clear vnic stats.
    
    Signed-off-by: Narsimhulu Musini <nmusini@cisco.com>
    Signed-off-by: Hiral Patel <hiralpat@cisco.com>
    Signed-off-by: James Bottomley <JBottomley@Parallels.com>

diff --git a/drivers/scsi/fnic/fnic.h b/drivers/scsi/fnic/fnic.h
index c18c68150e9f..d276aaf84f18 100644
--- a/drivers/scsi/fnic/fnic.h
+++ b/drivers/scsi/fnic/fnic.h
@@ -154,6 +154,9 @@ do {								\
 	FNIC_CHECK_LOGGING(FNIC_ISR_LOGGING,			\
 			 shost_printk(kern_level, host, fmt, ##args);)
 
+#define FNIC_MAIN_NOTE(kern_level, host, fmt, args...)          \
+	shost_printk(kern_level, host, fmt, ##args)
+
 extern const char *fnic_state_str[];
 
 enum fnic_intx_intr_index {
@@ -215,6 +218,7 @@ struct fnic {
 
 	struct vnic_stats *stats;
 	unsigned long stats_time;	/* time of stats update */
+	unsigned long stats_reset_time; /* time of stats reset */
 	struct vnic_nic_cfg *nic_cfg;
 	char name[IFNAMSIZ];
 	struct timer_list notify_timer; /* used for MSI interrupts */
@@ -359,4 +363,5 @@ fnic_chk_state_flags_locked(struct fnic *fnic, unsigned long st_flags)
 	return ((fnic->state_flags & st_flags) == st_flags);
 }
 void __fnic_set_state_flags(struct fnic *, unsigned long, unsigned long);
+void fnic_dump_fchost_stats(struct Scsi_Host *, struct fc_host_statistics *);
 #endif /* _FNIC_H_ */

commit e09056b25c38357df5c01985a0b3af608bccbfc0
Author: Chris Leech <cleech@redhat.com>
Date:   Tue Jul 23 13:04:58 2013 -0700

    [SCSI] fnic: BUG: sleeping function called from invalid context during probe
    
    I hit this during driver probe with the latest fnic updates (this trace
    is from a backport into a distro kernel, but the issue is the same).
    
    > BUG: sleeping function called from invalid context at mm/slab.c:3113
    > in_atomic(): 0, irqs_disabled(): 1, pid: 610, name: work_for_cpu
    > INFO: lockdep is turned off.
    > irq event stamp: 0
    > hardirqs last  enabled at (0): [<(null)>] (null)
    > hardirqs last disabled at (0): [<ffffffff81070aa5>]
    > copy_process+0x5e5/0x1670
    > softirqs last  enabled at (0): [<ffffffff81070aa5>]
    > copy_process+0x5e5/0x1670
    > softirqs last disabled at (0): [<(null)>] (null)
    > Pid: 610, comm: work_for_cpu Not tainted
    > Call Trace:
    >  [<ffffffff810b2d10>] ? print_irqtrace_events+0xd0/0xe0
    >  [<ffffffff8105c1a7>] ? __might_sleep+0xf7/0x130
    >  [<ffffffff81184efb>] ? kmem_cache_alloc_trace+0x20b/0x2d0
    >  [<ffffffff8109709e>] ? __create_workqueue_key+0x3e/0x1d0
    >  [<ffffffff8109709e>] ? __create_workqueue_key+0x3e/0x1d0
    >  [<ffffffffa00c101c>] ? fnic_probe+0x977/0x11aa [fnic]
    >  [<ffffffffa00c1048>] ? fnic_probe+0x9a3/0x11aa [fnic]
    >  [<ffffffff81096f00>] ? do_work_for_cpu+0x0/0x30
    >  [<ffffffff812c6da7>] ? local_pci_probe+0x17/0x20
    >  [<ffffffff81096f18>] ? do_work_for_cpu+0x18/0x30
    >  [<ffffffff8109cdc6>] ? kthread+0x96/0xa0
    >  [<ffffffff8100c1ca>] ? child_rip+0xa/0x20
    >  [<ffffffff81550f80>] ? _spin_unlock_irq+0x30/0x40
    >  [<ffffffff8100bb10>] ? restore_args+0x0/0x30
    >  [<ffffffff8109cd30>] ? kthread+0x0/0xa0
    >  [<ffffffff8100c1c0>] ? child_rip+0x0/0x20
    
    The problem is in this hunk of "FIP VLAN Discovery Feature Support"
    (d3c995f1dcf938f1084388d92b8fb97bec366566)
    
    create_singlethreaded_workqueue cannot be called with irqs disabled
    
    @@ -620,7 +634,29 @@ static int __devinit fnic_probe(struct pci_dev
    *pdev,
            vnic_dev_packet_filter(fnic->vdev, 1, 1, 0, 0, 0);
            vnic_dev_add_addr(fnic->vdev, FIP_ALL_ENODE_MACS);
            vnic_dev_add_addr(fnic->vdev, fnic->ctlr.ctl_src_addr);
    +       fnic->set_vlan = fnic_set_vlan;
            fcoe_ctlr_init(&fnic->ctlr, FIP_MODE_AUTO);
    +       setup_timer(&fnic->fip_timer, fnic_fip_notify_timer,
    +                           (unsigned long)fnic);
    +       spin_lock_init(&fnic->vlans_lock);
    +       INIT_WORK(&fnic->fip_frame_work, fnic_handle_fip_frame);
    +       INIT_WORK(&fnic->event_work, fnic_handle_event);
    +       skb_queue_head_init(&fnic->fip_frame_queue);
    +       spin_lock_irqsave(&fnic_list_lock, flags);
    +       if (!fnic_fip_queue) {
    +           fnic_fip_queue =
    +               create_singlethread_workqueue("fnic_fip_q");
    +           if (!fnic_fip_queue) {
    +               spin_unlock_irqrestore(&fnic_list_lock, flags);
    +               printk(KERN_ERR PFX "fnic FIP work queue "
    +                        "create failed\n");
    +               err = -ENOMEM;
    +               goto err_out_free_max_pool;
    +           }
    +       }
    +       spin_unlock_irqrestore(&fnic_list_lock, flags);
    +       INIT_LIST_HEAD(&fnic->evlist);
    +       INIT_LIST_HEAD(&fnic->vlans);
        } else {
            shost_printk(KERN_INFO, fnic->lport->host,
                     "firmware uses non-FIP mode\n");
    
    The attempts to make fnic_fip_queue a single instance for the driver
    while it's being created in probe look awkward anyway, why is this not
    created in fnic_init_module like the event workqueue?
    
    Signed-off-by: Chris Leech <cleech@redhat.com>
    Tested-by: Anantha Tungarakodi <atungara@cisco.com>
    Acked-by: Hiral Patel <hiralpat@cisco.com>
    Signed-off-by: James Bottomley <JBottomley@Parallels.com>

diff --git a/drivers/scsi/fnic/fnic.h b/drivers/scsi/fnic/fnic.h
index b6d1f92ed33c..c18c68150e9f 100644
--- a/drivers/scsi/fnic/fnic.h
+++ b/drivers/scsi/fnic/fnic.h
@@ -38,7 +38,7 @@
 
 #define DRV_NAME		"fnic"
 #define DRV_DESCRIPTION		"Cisco FCoE HBA Driver"
-#define DRV_VERSION		"1.5.0.22"
+#define DRV_VERSION		"1.5.0.23"
 #define PFX			DRV_NAME ": "
 #define DFX                     DRV_NAME "%d: "
 

commit 62271dbda7e83ea7c492c1a2c45bf5e02b072b40
Author: Hiral Patel <hiralpat@cisco.com>
Date:   Mon Feb 25 16:18:38 2013 -0800

    [SCSI] fnic: Incremented driver version
    
    Signed-off-by: Brian Uchino <buchino@cisco.com>
    Signed-off-by: Hiral Patel <hiralpat@cisco.com>
    Signed-off-by: James Bottomley <JBottomley@Parallels.com>

diff --git a/drivers/scsi/fnic/fnic.h b/drivers/scsi/fnic/fnic.h
index acec42a78aef..b6d1f92ed33c 100644
--- a/drivers/scsi/fnic/fnic.h
+++ b/drivers/scsi/fnic/fnic.h
@@ -38,7 +38,7 @@
 
 #define DRV_NAME		"fnic"
 #define DRV_DESCRIPTION		"Cisco FCoE HBA Driver"
-#define DRV_VERSION		"1.5.0.2"
+#define DRV_VERSION		"1.5.0.22"
 #define PFX			DRV_NAME ": "
 #define DFX                     DRV_NAME "%d: "
 

commit d3c995f1dcf938f1084388d92b8fb97bec366566
Author: Hiral Patel <hiralpat@cisco.com>
Date:   Mon Feb 25 16:18:36 2013 -0800

    [SCSI] fnic: FIP VLAN Discovery Feature Support
    
    FIP VLAN discovery discovers the FCoE VLAN that will be used by all other FIP
    protocols as well as by the FCoE encapsulation for Fibre Channel payloads on
    the established virtual link. One of the goals of FC-BB-5 was to be as
    nonintrusive as possible on initiators and targets, and therefore FIP VLAN
    discovery occurs in the native VLAN used by the initiator or target to
    exchange Ethernet traffic. The FIP VLAN discovery protocol is the only FIP
    protocol running on the native VLAN; all other FIP protocols run on the
    discovered FCoE VLANs.
    
    If an administrator has manually configured FCoE VLANs on ENodes and FCFs,
    there is no need to use this protocol. FIP and FCoE will run over the
    configured VLANs.
    
    An ENode without FCoE VLANs configuration would use this automated discovery
    protocol to discover over which VLANs FCoE is running.
    
    The ENode sends a FIP VLAN discovery request to a multicast MAC address called
    All-FCF-MACs, which is a multicast MAC address to which all FCFs listen.
    
    All FCFs that can be reached in the native VLAN of the ENode are expected to
    respond on the same VLAN with a response that lists one or more FCoE VLANs
    that are available for the ENode's VN_Port login. This protocol has the sole
    purpose of allowing the ENode to discover all the available FCoE VLANs.
    
    Now the ENode may enable a subset of these VLANs for FCoE Running the FIP
    protocol in these VLANs on a per VLAN basis. And FCoE data transactions also
    would occur on this VLAN. Hence, Except for FIP VLAN discovery, all other FIP
    and FCoE traffic runs on the selected FCoE VLAN.  Its only the FIP VLAN
    Discovery protocol that is permitted to run on the Default native VLAN of the
    system.
    
    [**** NOTE ****]
    We are working on moving this feature definitions and functionality to libfcoe
    module. We need this patch to be approved, as Suse is looking forward to merge
    this feature in SLES 11 SP3 release.  Once this patch is approved, we will
    submit patch which should move vlan discovery feature to libfoce.
    
    [Fengguang Wu <fengguang.wu@intel.com>: kmalloc cast removal]
    Signed-off-by: Anantha Prakash T <atungara@cisco.com>
    Signed-off-by: Hiral Patel <hiralpat@cisco.com>
    Signed-off-by: James Bottomley <JBottomley@Parallels.com>

diff --git a/drivers/scsi/fnic/fnic.h b/drivers/scsi/fnic/fnic.h
index 98436c363035..acec42a78aef 100644
--- a/drivers/scsi/fnic/fnic.h
+++ b/drivers/scsi/fnic/fnic.h
@@ -192,6 +192,18 @@ enum fnic_state {
 
 struct mempool;
 
+enum fnic_evt {
+	FNIC_EVT_START_VLAN_DISC = 1,
+	FNIC_EVT_START_FCF_DISC = 2,
+	FNIC_EVT_MAX,
+};
+
+struct fnic_event {
+	struct list_head list;
+	struct fnic *fnic;
+	enum fnic_evt event;
+};
+
 /* Per-instance private data structure */
 struct fnic {
 	struct fc_lport *lport;
@@ -254,6 +266,18 @@ struct fnic {
 	struct sk_buff_head frame_queue;
 	struct sk_buff_head tx_queue;
 
+	/*** FIP related data members  -- start ***/
+	void (*set_vlan)(struct fnic *, u16 vlan);
+	struct work_struct      fip_frame_work;
+	struct sk_buff_head     fip_frame_queue;
+	struct timer_list       fip_timer;
+	struct list_head        vlans;
+	spinlock_t              vlans_lock;
+
+	struct work_struct      event_work;
+	struct list_head        evlist;
+	/*** FIP related data members  -- end ***/
+
 	/* copy work queue cache line section */
 	____cacheline_aligned struct vnic_wq_copy wq_copy[FNIC_WQ_COPY_MAX];
 	/* completion queue cache line section */
@@ -278,6 +302,7 @@ static inline struct fnic *fnic_from_ctlr(struct fcoe_ctlr *fip)
 }
 
 extern struct workqueue_struct *fnic_event_queue;
+extern struct workqueue_struct *fnic_fip_queue;
 extern struct device_attribute *fnic_attrs[];
 
 void fnic_clear_intr_mode(struct fnic *fnic);
@@ -289,6 +314,7 @@ int fnic_send(struct fc_lport *, struct fc_frame *);
 void fnic_free_wq_buf(struct vnic_wq *wq, struct vnic_wq_buf *buf);
 void fnic_handle_frame(struct work_struct *work);
 void fnic_handle_link(struct work_struct *work);
+void fnic_handle_event(struct work_struct *work);
 int fnic_rq_cmpl_handler(struct fnic *fnic, int);
 int fnic_alloc_rq_frame(struct vnic_rq *rq);
 void fnic_free_rq_buf(struct vnic_rq *rq, struct vnic_rq_buf *buf);
@@ -321,6 +347,12 @@ void fnic_handle_link_event(struct fnic *fnic);
 
 int fnic_is_abts_pending(struct fnic *, struct scsi_cmnd *);
 
+void fnic_handle_fip_frame(struct work_struct *work);
+void fnic_handle_fip_event(struct fnic *fnic);
+void fnic_fcoe_reset_vlans(struct fnic *fnic);
+void fnic_fcoe_evlist_free(struct fnic *fnic);
+extern void fnic_handle_fip_timer(struct fnic *fnic);
+
 static inline int
 fnic_chk_state_flags_locked(struct fnic *fnic, unsigned long st_flags)
 {

commit 4d7007b49d523d8f954ae047118d82c130f673ce
Author: Hiral Patel <hiralpat@cisco.com>
Date:   Tue Feb 12 17:01:02 2013 -0800

    [SCSI] fnic: Fnic Trace Utility
    
    Fnic Trace utility is a tracing functionality built directly into fnic driver
    to trace events. The benefit that trace buffer brings to fnic driver is the
    ability to see what it happening inside the fnic driver. It also provides the
    capability to trace every IO event inside fnic driver to debug panics, hangs
    and potentially IO corruption issues. This feature makes it easy to find
    problems in fnic driver and it also helps in tracking down strange bugs in a
    more manageable way. Trace buffer is shared across all fnic instances for
    this implementation.
    
    Signed-off-by: Hiral Patel <hiralpat@cisco.com>
    Signed-off-by: James Bottomley <JBottomley@Parallels.com>

diff --git a/drivers/scsi/fnic/fnic.h b/drivers/scsi/fnic/fnic.h
index 9c95a1ad56b9..98436c363035 100644
--- a/drivers/scsi/fnic/fnic.h
+++ b/drivers/scsi/fnic/fnic.h
@@ -26,6 +26,7 @@
 #include <scsi/libfcoe.h>
 #include "fnic_io.h"
 #include "fnic_res.h"
+#include "fnic_trace.h"
 #include "vnic_dev.h"
 #include "vnic_wq.h"
 #include "vnic_rq.h"

commit 14eb5d905d16ecd33e5e3113eb44cfa2bb47e7d7
Author: Hiral Patel <hiralpat@cisco.com>
Date:   Tue Feb 12 17:01:01 2013 -0800

    [SCSI] fnic: New debug flags and debug log messages
    
    Added new fnic debug flags for identifying IO state at every stage of IO while
    debugging and also added more log messages for better debugging capability.
    
    Signed-off-by: Sesidhar Baddela <sebaddel@cisco.com>
    Signed-off-by: Hiral Patel <hiralpat@cisco.com>
    Signed-off-by: James Bottomley <JBottomley@Parallels.com>

diff --git a/drivers/scsi/fnic/fnic.h b/drivers/scsi/fnic/fnic.h
index b8e6644ad237..9c95a1ad56b9 100644
--- a/drivers/scsi/fnic/fnic.h
+++ b/drivers/scsi/fnic/fnic.h
@@ -59,14 +59,29 @@
  * Command flags to identify the type of command and for other future
  * use.
  */
-#define FNIC_NO_FLAGS			0
-#define FNIC_CDB_REQ			BIT(1)	/* All IOs with a valid CDB */
-#define FNIC_BLOCKING_REQ		BIT(2)	/* All blocking Requests */
-#define FNIC_DEVICE_RESET		BIT(3)	/* Device reset request */
-#define FNIC_DEV_RST_PENDING		BIT(4)	/* Device reset pending */
-#define FNIC_DEV_RST_TIMED_OUT		BIT(5)	/* Device reset timed out */
-#define FNIC_DEV_RST_TERM_ISSUED	BIT(6)	/* Device reset terminate */
-#define FNIC_DEV_RST_DONE		BIT(7)	/* Device reset done */
+#define FNIC_NO_FLAGS                   0
+#define FNIC_IO_INITIALIZED             BIT(0)
+#define FNIC_IO_ISSUED                  BIT(1)
+#define FNIC_IO_DONE                    BIT(2)
+#define FNIC_IO_REQ_NULL                BIT(3)
+#define FNIC_IO_ABTS_PENDING            BIT(4)
+#define FNIC_IO_ABORTED                 BIT(5)
+#define FNIC_IO_ABTS_ISSUED             BIT(6)
+#define FNIC_IO_TERM_ISSUED             BIT(7)
+#define FNIC_IO_INTERNAL_TERM_ISSUED    BIT(8)
+#define FNIC_IO_ABT_TERM_DONE           BIT(9)
+#define FNIC_IO_ABT_TERM_REQ_NULL       BIT(10)
+#define FNIC_IO_ABT_TERM_TIMED_OUT      BIT(11)
+#define FNIC_DEVICE_RESET               BIT(12)  /* Device reset request */
+#define FNIC_DEV_RST_ISSUED             BIT(13)
+#define FNIC_DEV_RST_TIMED_OUT          BIT(14)
+#define FNIC_DEV_RST_ABTS_ISSUED        BIT(15)
+#define FNIC_DEV_RST_TERM_ISSUED        BIT(16)
+#define FNIC_DEV_RST_DONE               BIT(17)
+#define FNIC_DEV_RST_REQ_NULL           BIT(18)
+#define FNIC_DEV_RST_ABTS_DONE          BIT(19)
+#define FNIC_DEV_RST_TERM_DONE          BIT(20)
+#define FNIC_DEV_RST_ABTS_PENDING       BIT(21)
 
 /*
  * Usage of the scsi_cmnd scratchpad.

commit a0bf1ca27b644c1c4b1f0ea2d81f99471b2549e8
Author: Hiral Patel <hiralpat@cisco.com>
Date:   Tue Feb 12 17:01:00 2013 -0800

    [SCSI] fnic: fnic driver may hit BUG_ON on device reset
    
    The issue was observed when LUN Reset is issued through IOCTL or sg_reset
    utility.
    
    fnic driver issues LUN RESET to firmware. On successful completion of device
    reset, driver cleans up all the pending IOs that were issued prior to device
    reset. These pending IOs are expected to be in ABTS_PENDING state. This works
    fine, when the device reset operation resulted from midlayer, but not when
    device reset was triggered from IOCTL path as the pending IOs were not in
    ABTS_PENDING state. execution path hits panic if the pending IO is not in
    ABTS_PENDING state.
    
    Changes:
    The fix replaces BUG_ON check in fnic_clean_pending_aborts() with marking
    pending IOs as ABTS_PENDING if they were not in ABTS_PENDING state and skips
    if they were already in ABTS_PENDING state. An extra check is added to validate
    the abort status of the commands after a delay of 2 * E_D_TOV using a
    helper function. The helper function returns 1 if it finds any pending IO in
    ABTS_PENDING state, belong to the LUN on which device reset was issued else 0.
    With this, device reset operation returns success only if the helper funciton
    returns 0, otherwise it returns failure.
    
    Other changes:
    - Removed code in fnic_clean_pending_aborts() that returns failure if it finds
      io_req NULL, instead of returning failure added code to continue with next io
    - Added device reset flags for debugging in fnic_terminate_rport_io,
      fnic_rport_exch_reset, and fnic_clean_pending_aborts
    
    Signed-off-by: Narsimhulu Musini <nmusini@cisco.com>
    Signed-off-by: Hiral Patel <hiralpat@cisco.com>
    Signed-off-by: James Bottomley <JBottomley@Parallels.com>

diff --git a/drivers/scsi/fnic/fnic.h b/drivers/scsi/fnic/fnic.h
index 63b35c8e40bd..b8e6644ad237 100644
--- a/drivers/scsi/fnic/fnic.h
+++ b/drivers/scsi/fnic/fnic.h
@@ -303,6 +303,8 @@ const char *fnic_state_to_str(unsigned int state);
 void fnic_log_q_error(struct fnic *fnic);
 void fnic_handle_link_event(struct fnic *fnic);
 
+int fnic_is_abts_pending(struct fnic *, struct scsi_cmnd *);
+
 static inline int
 fnic_chk_state_flags_locked(struct fnic *fnic, unsigned long st_flags)
 {

commit 03298552cba38f7c805ed338826dc76c405465c7
Author: Hiral Patel <hiralpat@cisco.com>
Date:   Tue Feb 12 17:00:58 2013 -0800

    [SCSI] fnic: fixing issues in device and firmware reset code
    
    1. Handling overlapped firmware resets
         This fix serialize multiple firmware resets to avoid situation where fnic
         device fails to come up for link up event, when firmware resets are issued
         back to back. If there are overlapped firmware resets are issued,
         the firmware reset operation checks whether there is any firmware reset in
         progress, if so it polls for its completion in a loop with 100ms delay.
    
    2. Handling device reset timeout
         fnic_device_reset code has been modified to handle Device reset timeout:
         - Issue terminate on device reset timeout.
         - Introduced flags field (one of the scratch fields in scsi_cmnd).
         With this, device reset request would have DEVICE_RESET flag set for other
         routines to determine the type of the request.
         Also modified fnic_terminate_rport_io, fnic_rport_exch_rset, completion
         routines to handle SCSI commands with DEVICE_RESET flag.
    
    3. LUN/Device Reset hangs when issued through IOCTL using utilities like
       sg_reset.
         Each SCSI command is associated with a valid tag, fnic uses this tag to
         retrieve associated scsi command on completion. the LUN/Device Reset issued
         through IOCTL resulting into a SCSI command that is not associated with a
         valid tag. So fnic fails to retrieve associated scsi command on completion,
         which causes hang. This fix allocates tag, associates it with the
         scsi command and frees the tag, when the operation completed.
    
    4. Preventing IOs during firmware reset.
         Current fnic implementation allows IO submissions during firmware reset.
         This fix synchronizes IO submissions and firmware reset operations.
         It ensures that IOs issued to fnic prior to reset will be issued to the
         firmware before firmware reset.
    
    Signed-off-by: Narsimhulu Musini <nmusini@cisco.com>
    Signed-off-by: Hiral Patel <hiralpat@cisco.com>
    Signed-off-by: James Bottomley <JBottomley@Parallels.com>

diff --git a/drivers/scsi/fnic/fnic.h b/drivers/scsi/fnic/fnic.h
index 95a5ba29320d..63b35c8e40bd 100644
--- a/drivers/scsi/fnic/fnic.h
+++ b/drivers/scsi/fnic/fnic.h
@@ -55,6 +55,19 @@
 #define FNIC_TAG_MASK		(BIT(24) - 1)	/* mask for lookup */
 #define FNIC_NO_TAG             -1
 
+/*
+ * Command flags to identify the type of command and for other future
+ * use.
+ */
+#define FNIC_NO_FLAGS			0
+#define FNIC_CDB_REQ			BIT(1)	/* All IOs with a valid CDB */
+#define FNIC_BLOCKING_REQ		BIT(2)	/* All blocking Requests */
+#define FNIC_DEVICE_RESET		BIT(3)	/* Device reset request */
+#define FNIC_DEV_RST_PENDING		BIT(4)	/* Device reset pending */
+#define FNIC_DEV_RST_TIMED_OUT		BIT(5)	/* Device reset timed out */
+#define FNIC_DEV_RST_TERM_ISSUED	BIT(6)	/* Device reset terminate */
+#define FNIC_DEV_RST_DONE		BIT(7)	/* Device reset done */
+
 /*
  * Usage of the scsi_cmnd scratchpad.
  * These fields are locked by the hashed io_req_lock.
@@ -64,6 +77,7 @@
 #define CMD_ABTS_STATUS(Cmnd)	((Cmnd)->SCp.Message)
 #define CMD_LR_STATUS(Cmnd)	((Cmnd)->SCp.have_data_in)
 #define CMD_TAG(Cmnd)           ((Cmnd)->SCp.sent_command)
+#define CMD_FLAGS(Cmnd)         ((Cmnd)->SCp.Status)
 
 #define FCPIO_INVALID_CODE 0x100 /* hdr_status value unused by firmware */
 
@@ -71,9 +85,28 @@
 #define FNIC_HOST_RESET_TIMEOUT	     10000	/* mSec */
 #define FNIC_RMDEVICE_TIMEOUT        1000       /* mSec */
 #define FNIC_HOST_RESET_SETTLE_TIME  30         /* Sec */
+#define FNIC_ABT_TERM_DELAY_TIMEOUT  500        /* mSec */
 
 #define FNIC_MAX_FCP_TARGET     256
 
+/**
+ * state_flags to identify host state along along with fnic's state
+ **/
+#define __FNIC_FLAGS_FWRESET		BIT(0) /* fwreset in progress */
+#define __FNIC_FLAGS_BLOCK_IO		BIT(1) /* IOs are blocked */
+
+#define FNIC_FLAGS_NONE			(0)
+#define FNIC_FLAGS_FWRESET		(__FNIC_FLAGS_FWRESET | \
+					__FNIC_FLAGS_BLOCK_IO)
+
+#define FNIC_FLAGS_IO_BLOCKED		(__FNIC_FLAGS_BLOCK_IO)
+
+#define fnic_set_state_flags(fnicp, st_flags)	\
+	__fnic_set_state_flags(fnicp, st_flags, 0)
+
+#define fnic_clear_state_flags(fnicp, st_flags)  \
+	__fnic_set_state_flags(fnicp, st_flags, 1)
+
 extern unsigned int fnic_log_level;
 
 #define FNIC_MAIN_LOGGING 0x01
@@ -170,6 +203,9 @@ struct fnic {
 
 	struct completion *remove_wait; /* device remove thread blocks */
 
+	atomic_t in_flight;		/* io counter */
+	u32 _reserved;			/* fill hole */
+	unsigned long state_flags;	/* protected by host lock */
 	enum fnic_state state;
 	spinlock_t fnic_lock;
 
@@ -267,4 +303,10 @@ const char *fnic_state_to_str(unsigned int state);
 void fnic_log_q_error(struct fnic *fnic);
 void fnic_handle_link_event(struct fnic *fnic);
 
+static inline int
+fnic_chk_state_flags_locked(struct fnic *fnic, unsigned long st_flags)
+{
+	return ((fnic->state_flags & st_flags) == st_flags);
+}
+void __fnic_set_state_flags(struct fnic *, unsigned long, unsigned long);
 #endif /* _FNIC_H_ */

commit 0c79c74272b25bbcfb0149d5a4627ed768795d2d
Author: Abhijeet Joglekar <abjoglek@cisco.com>
Date:   Mon Jun 13 21:21:01 2011 -0700

    [SCSI] fnic: fix incorrect use of SLAB_CACHE_DMA flag
    
    Driver was incorrectly using the SLAB_CACHE_DMA flag when creating a cache
    for SGLs. fnic device does not have 24-bit DMA restrictions. Remove the flag
    and allocations from ZONE_DMA.
    
    Thanks to Roland Dreier and David Rientjes for pointing out the bug.
    
    Signed-off-by: Abhijeet Joglekar <abjoglek@cisco.com>
    Signed-off-by: James Bottomley <JBottomley@Parallels.com>

diff --git a/drivers/scsi/fnic/fnic.h b/drivers/scsi/fnic/fnic.h
index 671cde9d4060..95a5ba29320d 100644
--- a/drivers/scsi/fnic/fnic.h
+++ b/drivers/scsi/fnic/fnic.h
@@ -37,7 +37,7 @@
 
 #define DRV_NAME		"fnic"
 #define DRV_DESCRIPTION		"Cisco FCoE HBA Driver"
-#define DRV_VERSION		"1.5.0.1"
+#define DRV_VERSION		"1.5.0.2"
 #define PFX			DRV_NAME ": "
 #define DFX                     DRV_NAME "%d: "
 

commit 6da92d3463cd60f5b804475f70f659dc07331929
Author: Venkata Siva Vijayendra Bhamidipati <vbhamidi@cisco.com>
Date:   Fri Jan 28 16:03:42 2011 -0800

    [SCSI] fnic: Bumping up fnic version from 1.4.0.145 to 1.5.0.1.
    
    Signed-off-by: Venkata Siva Vijayendra Bhamidipati <vbhamidi@cisco.com>
    Signed-off-by: Robert Love <robert.w.love@intel.com>
    Signed-off-by: James Bottomley <James.Bottomley@suse.de>

diff --git a/drivers/scsi/fnic/fnic.h b/drivers/scsi/fnic/fnic.h
index 92f185081e62..671cde9d4060 100644
--- a/drivers/scsi/fnic/fnic.h
+++ b/drivers/scsi/fnic/fnic.h
@@ -37,7 +37,7 @@
 
 #define DRV_NAME		"fnic"
 #define DRV_DESCRIPTION		"Cisco FCoE HBA Driver"
-#define DRV_VERSION		"1.4.0.145"
+#define DRV_VERSION		"1.5.0.1"
 #define PFX			DRV_NAME ": "
 #define DFX                     DRV_NAME "%d: "
 

commit f281233d3eba15fb225d21ae2e228fd4553d824a
Author: Jeff Garzik <jeff@garzik.org>
Date:   Tue Nov 16 02:10:29 2010 -0500

    SCSI host lock push-down
    
    Move the mid-layer's ->queuecommand() invocation from being locked
    with the host lock to being unlocked to facilitate speeding up the
    critical path for drivers who don't need this lock taken anyway.
    
    The patch below presents a simple SCSI host lock push-down as an
    equivalent transformation.  No locking or other behavior should change
    with this patch.  All existing bugs and locking orders are preserved.
    
    Additionally, add one parameter to queuecommand,
            struct Scsi_Host *
    and remove one parameter from queuecommand,
            void (*done)(struct scsi_cmnd *)
    
    Scsi_Host* is a convenient pointer that most host drivers need anyway,
    and 'done' is redundant to struct scsi_cmnd->scsi_done.
    
    Minimal code disturbance was attempted with this change.  Most drivers
    needed only two one-line modifications for their host lock push-down.
    
    Signed-off-by: Jeff Garzik <jgarzik@redhat.com>
    Acked-by: James Bottomley <James.Bottomley@suse.de>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/scsi/fnic/fnic.h b/drivers/scsi/fnic/fnic.h
index cbb20b13b228..92f185081e62 100644
--- a/drivers/scsi/fnic/fnic.h
+++ b/drivers/scsi/fnic/fnic.h
@@ -246,7 +246,7 @@ void fnic_set_port_id(struct fc_lport *, u32, struct fc_frame *);
 void fnic_update_mac(struct fc_lport *, u8 *new);
 void fnic_update_mac_locked(struct fnic *, u8 *new);
 
-int fnic_queuecommand(struct scsi_cmnd *, void (*done)(struct scsi_cmnd *));
+int fnic_queuecommand(struct Scsi_Host *, struct scsi_cmnd *);
 int fnic_abort_cmd(struct scsi_cmnd *);
 int fnic_device_reset(struct scsi_cmnd *);
 int fnic_host_reset(struct scsi_cmnd *);

commit a737b88df8d0b4476ae53daaa6db137df0541203
Author: Andrew Morton <akpm@linux-foundation.org>
Date:   Tue Aug 10 18:01:26 2010 -0700

    scsi: remove private BIT macros
    
    A couple of scsi drivers define a BIT() macro, duplicating the one in
    bitops.h.
    
    Cc: Jing Huang <huangj@brocade.com>
    Cc: Robert Love <robert.w.love@intel.com>
    Cc: James Bottomley <James.Bottomley@HansenPartnership.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/scsi/fnic/fnic.h b/drivers/scsi/fnic/fnic.h
index 19338e0ba2c5..cbb20b13b228 100644
--- a/drivers/scsi/fnic/fnic.h
+++ b/drivers/scsi/fnic/fnic.h
@@ -21,6 +21,7 @@
 #include <linux/interrupt.h>
 #include <linux/netdevice.h>
 #include <linux/workqueue.h>
+#include <linux/bitops.h>
 #include <scsi/libfc.h>
 #include <scsi/libfcoe.h>
 #include "fnic_io.h"
@@ -49,7 +50,6 @@
 /*
  * Tag bits used for special requests.
  */
-#define BIT(nr)			(1UL << (nr))
 #define FNIC_TAG_ABORT		BIT(30)		/* tag bit indicating abort */
 #define FNIC_TAG_DEV_RST	BIT(29)		/* indicates device reset */
 #define FNIC_TAG_MASK		(BIT(24) - 1)	/* mask for lookup */

commit da87bfab8a7e6cfd0e1e5c5874d7fd4f7d11e64e
Author: Vasu Dev <vasu.dev@intel.com>
Date:   Fri Apr 9 14:22:59 2010 -0700

    [SCSI] fcoe, fnic, libfc: increased CDB size to 16 bytes for fcoe.
    
    No reason to restrict CDB size to 12 bytes in fcoe, so
    increased to 16 so that 16 bytes SCSI CDB doesn't fail.
    
    Uses common define to set max_cmd_len for fcoe and fnic,
    fnic is already setting max_cmd_len to 16.
    
    sg_readcap -l fails without this fix.
    
    Signed-off-by: Vasu Dev <vasu.dev@intel.com>
    Signed-off-by: Robert Love <robert.w.love@intel.com>
    Signed-off-by: James Bottomley <James.Bottomley@suse.de>

diff --git a/drivers/scsi/fnic/fnic.h b/drivers/scsi/fnic/fnic.h
index 585cc9cb942c..19338e0ba2c5 100644
--- a/drivers/scsi/fnic/fnic.h
+++ b/drivers/scsi/fnic/fnic.h
@@ -45,7 +45,7 @@
 #define	FNIC_IO_LOCKS		64 /* IO locks: power of 2 */
 #define FNIC_DFLT_QUEUE_DEPTH	32
 #define	FNIC_STATS_RATE_LIMIT	4 /* limit rate at which stats are pulled up */
-#define FNIC_MAX_CMD_LEN        16 /* Supported CDB length */
+
 /*
  * Tag bits used for special requests.
  */

commit 666d07646a29040e3dc4caeb679166559e152ff2
Author: Brian Uchino <buchino@cisco.com>
Date:   Fri Apr 9 14:22:44 2010 -0700

    [SCSI] fnic: Update version to 1.4.0.145
    
    New fnic version to mark inclusion of tx_flush bugfix.
    
    Signed-off-by:  Brian Uchino <buchino@cisco.com>
    Signed-off-by:  Abhijeet Joglekar <abjoglek@cisco.com>
    Signed-off-by: Robert Love <robert.w.love@intel.com>
    Signed-off-by: James Bottomley <James.Bottomley@suse.de>

diff --git a/drivers/scsi/fnic/fnic.h b/drivers/scsi/fnic/fnic.h
index 3966c71d0095..585cc9cb942c 100644
--- a/drivers/scsi/fnic/fnic.h
+++ b/drivers/scsi/fnic/fnic.h
@@ -36,7 +36,7 @@
 
 #define DRV_NAME		"fnic"
 #define DRV_DESCRIPTION		"Cisco FCoE HBA Driver"
-#define DRV_VERSION		"1.4.0.98"
+#define DRV_VERSION		"1.4.0.145"
 #define PFX			DRV_NAME ": "
 #define DFX                     DRV_NAME "%d: "
 

commit f90f50d7c530793c9c705a8f7fa3deb01714f21a
Author: Venkata Siva Vijayendra Bhamidipati <vbhamidi@cisco.com>
Date:   Tue Feb 16 12:15:55 2010 -0800

    [SCSI] fnic: Set fnic driver version
    
    Update fnic driver version.
    
    Signed-off-by: Venkata Siva Vijayendra Bhamidipati <vbhamidi@cisco.com>
    Signed-off-by: Robert Love <robert.w.love@intel.com>
    Signed-off-by: James Bottomley <James.Bottomley@suse.de>

diff --git a/drivers/scsi/fnic/fnic.h b/drivers/scsi/fnic/fnic.h
index bb208a6091e7..3966c71d0095 100644
--- a/drivers/scsi/fnic/fnic.h
+++ b/drivers/scsi/fnic/fnic.h
@@ -36,7 +36,7 @@
 
 #define DRV_NAME		"fnic"
 #define DRV_DESCRIPTION		"Cisco FCoE HBA Driver"
-#define DRV_VERSION		"1.0.0.1121"
+#define DRV_VERSION		"1.4.0.98"
 #define PFX			DRV_NAME ": "
 #define DFX                     DRV_NAME "%d: "
 

commit 78112e5558064cb4d2e355aed87b2036fcdfe3dd
Author: Joe Eykholt <jeykholt@cisco.com>
Date:   Tue Nov 3 11:49:22 2009 -0800

    [SCSI] fnic: Add FIP support to the fnic driver
    
    Use libfcoe as a common FIP implementation with fcoe.
    FIP or non-FIP mode is fully automatic if the firmware
    supports and enables it.
    
    Even if FIP is not supported, this uses libfcoe for the non-FIP
    handling of FLOGI and its response.
    
    Use the new lport_set_port_id() notification to capture
    successful FLOGI responses and port_id resets.
    
    While transitioning between Ethernet and FC mode, all rx and
    tx FC frames are queued.  In Ethernet mode, all frames are
    passed to the exchange manager to capture FLOGI responses.
    
    Change to set data_src_addr to the ctl_src_addr whenever it
    would have previously been zero because we're not logged in.
    This seems safer so we'll never send a frame with a 0 source MAC.
    This also eliminates a special case for sending FLOGI frames.
    
    Signed-off-by: Joe Eykholt <jeykholt@cisco.com>
    Signed-off-by: Robert Love <robert.w.love@intel.com>
    Signed-off-by: James Bottomley <James.Bottomley@suse.de>

diff --git a/drivers/scsi/fnic/fnic.h b/drivers/scsi/fnic/fnic.h
index 1bc267e892d2..bb208a6091e7 100644
--- a/drivers/scsi/fnic/fnic.h
+++ b/drivers/scsi/fnic/fnic.h
@@ -22,6 +22,7 @@
 #include <linux/netdevice.h>
 #include <linux/workqueue.h>
 #include <scsi/libfc.h>
+#include <scsi/libfcoe.h>
 #include "fnic_io.h"
 #include "fnic_res.h"
 #include "vnic_dev.h"
@@ -145,6 +146,7 @@ struct mempool;
 /* Per-instance private data structure */
 struct fnic {
 	struct fc_lport *lport;
+	struct fcoe_ctlr ctlr;		/* FIP FCoE controller structure */
 	struct vnic_dev_bar bar0;
 
 	struct msix_entry msix_entry[FNIC_MSIX_INTR_MAX];
@@ -162,23 +164,16 @@ struct fnic {
 	unsigned int wq_count;
 	unsigned int cq_count;
 
-	u32 fcoui_mode:1;		/* use fcoui address*/
 	u32 vlan_hw_insert:1;	        /* let hw insert the tag */
 	u32 in_remove:1;                /* fnic device in removal */
 	u32 stop_rx_link_events:1;      /* stop proc. rx frames, link events */
 
 	struct completion *remove_wait; /* device remove thread blocks */
 
-	struct fc_frame *flogi;
-	struct fc_frame *flogi_resp;
-	u16 flogi_oxid;
-	unsigned long s_id;
 	enum fnic_state state;
 	spinlock_t fnic_lock;
 
 	u16 vlan_id;	                /* VLAN tag including priority */
-	u8 mac_addr[ETH_ALEN];
-	u8 dest_addr[ETH_ALEN];
 	u8 data_src_addr[ETH_ALEN];
 	u64 fcp_input_bytes;		/* internal statistic */
 	u64 fcp_output_bytes;		/* internal statistic */
@@ -205,6 +200,7 @@ struct fnic {
 	struct work_struct link_work;
 	struct work_struct frame_work;
 	struct sk_buff_head frame_queue;
+	struct sk_buff_head tx_queue;
 
 	/* copy work queue cache line section */
 	____cacheline_aligned struct vnic_wq_copy wq_copy[FNIC_WQ_COPY_MAX];
@@ -224,6 +220,11 @@ struct fnic {
 	____cacheline_aligned struct vnic_intr intr[FNIC_MSIX_INTR_MAX];
 };
 
+static inline struct fnic *fnic_from_ctlr(struct fcoe_ctlr *fip)
+{
+	return container_of(fip, struct fnic, ctlr);
+}
+
 extern struct workqueue_struct *fnic_event_queue;
 extern struct device_attribute *fnic_attrs[];
 
@@ -239,7 +240,11 @@ void fnic_handle_link(struct work_struct *work);
 int fnic_rq_cmpl_handler(struct fnic *fnic, int);
 int fnic_alloc_rq_frame(struct vnic_rq *rq);
 void fnic_free_rq_buf(struct vnic_rq *rq, struct vnic_rq_buf *buf);
-int fnic_send_frame(struct fnic *fnic, struct fc_frame *fp);
+void fnic_flush_tx(struct fnic *);
+void fnic_eth_send(struct fcoe_ctlr *, struct sk_buff *skb);
+void fnic_set_port_id(struct fc_lport *, u32, struct fc_frame *);
+void fnic_update_mac(struct fc_lport *, u8 *new);
+void fnic_update_mac_locked(struct fnic *, u8 *new);
 
 int fnic_queuecommand(struct scsi_cmnd *, void (*done)(struct scsi_cmnd *));
 int fnic_abort_cmd(struct scsi_cmnd *);
@@ -252,7 +257,7 @@ void fnic_empty_scsi_cleanup(struct fc_lport *);
 void fnic_exch_mgr_reset(struct fc_lport *, u32, u32);
 int fnic_wq_copy_cmpl_handler(struct fnic *fnic, int);
 int fnic_wq_cmpl_handler(struct fnic *fnic, int);
-int fnic_flogi_reg_handler(struct fnic *fnic);
+int fnic_flogi_reg_handler(struct fnic *fnic, u32);
 void fnic_wq_copy_cleanup_handler(struct vnic_wq_copy *wq,
 				  struct fcpio_host_req *desc);
 int fnic_fw_reset_handler(struct fnic *fnic);

commit f9bdc3da4c9c2af4886bc6a562effc05cbf75234
Author: Abhijeet Joglekar <abjoglek@cisco.com>
Date:   Wed Oct 21 16:28:19 2009 -0700

    [SCSI] fnic: Set max_cmd_len to driver supported CDB length
    
    Signed-off-by: Abhijeet Joglekar <abjoglek@cisco.com>
    Signed-off-by: Robert Love <robert.w.love@intel.com>
    Signed-off-by: James Bottomley <James.Bottomley@suse.de>

diff --git a/drivers/scsi/fnic/fnic.h b/drivers/scsi/fnic/fnic.h
index e4c0a3d7d87b..1bc267e892d2 100644
--- a/drivers/scsi/fnic/fnic.h
+++ b/drivers/scsi/fnic/fnic.h
@@ -44,7 +44,7 @@
 #define	FNIC_IO_LOCKS		64 /* IO locks: power of 2 */
 #define FNIC_DFLT_QUEUE_DEPTH	32
 #define	FNIC_STATS_RATE_LIMIT	4 /* limit rate at which stats are pulled up */
-
+#define FNIC_MAX_CMD_LEN        16 /* Supported CDB length */
 /*
  * Tag bits used for special requests.
  */

commit 5df6d737dd4b0fe9eccf943abb3677cfea05a6c4
Author: Abhijeet Joglekar <abjoglek@cisco.com>
Date:   Fri Apr 17 18:33:26 2009 -0700

    [SCSI] fnic: Add new Cisco PCI-Express FCoE HBA
    
    fnic is a driver for the Cisco PCI-Express FCoE HBA
    
    Signed-off-by: Abhijeet Joglekar <abjoglek@cisco.com>
    Signed-off-by: Joe Eykholt <jeykholt@cisco.com>
    Signed-off-by: Mike Christie <michaelc@cs.wisc.edu>
    Signed-off-by: James Bottomley <James.Bottomley@HansenPartnership.com>

diff --git a/drivers/scsi/fnic/fnic.h b/drivers/scsi/fnic/fnic.h
new file mode 100644
index 000000000000..e4c0a3d7d87b
--- /dev/null
+++ b/drivers/scsi/fnic/fnic.h
@@ -0,0 +1,265 @@
+/*
+ * Copyright 2008 Cisco Systems, Inc.  All rights reserved.
+ * Copyright 2007 Nuova Systems, Inc.  All rights reserved.
+ *
+ * This program is free software; you may redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; version 2 of the License.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+ * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
+ * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
+ * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
+ * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+ * SOFTWARE.
+ */
+#ifndef _FNIC_H_
+#define _FNIC_H_
+
+#include <linux/interrupt.h>
+#include <linux/netdevice.h>
+#include <linux/workqueue.h>
+#include <scsi/libfc.h>
+#include "fnic_io.h"
+#include "fnic_res.h"
+#include "vnic_dev.h"
+#include "vnic_wq.h"
+#include "vnic_rq.h"
+#include "vnic_cq.h"
+#include "vnic_wq_copy.h"
+#include "vnic_intr.h"
+#include "vnic_stats.h"
+#include "vnic_scsi.h"
+
+#define DRV_NAME		"fnic"
+#define DRV_DESCRIPTION		"Cisco FCoE HBA Driver"
+#define DRV_VERSION		"1.0.0.1121"
+#define PFX			DRV_NAME ": "
+#define DFX                     DRV_NAME "%d: "
+
+#define DESC_CLEAN_LOW_WATERMARK 8
+#define FNIC_MAX_IO_REQ		2048 /* scsi_cmnd tag map entries */
+#define	FNIC_IO_LOCKS		64 /* IO locks: power of 2 */
+#define FNIC_DFLT_QUEUE_DEPTH	32
+#define	FNIC_STATS_RATE_LIMIT	4 /* limit rate at which stats are pulled up */
+
+/*
+ * Tag bits used for special requests.
+ */
+#define BIT(nr)			(1UL << (nr))
+#define FNIC_TAG_ABORT		BIT(30)		/* tag bit indicating abort */
+#define FNIC_TAG_DEV_RST	BIT(29)		/* indicates device reset */
+#define FNIC_TAG_MASK		(BIT(24) - 1)	/* mask for lookup */
+#define FNIC_NO_TAG             -1
+
+/*
+ * Usage of the scsi_cmnd scratchpad.
+ * These fields are locked by the hashed io_req_lock.
+ */
+#define CMD_SP(Cmnd)		((Cmnd)->SCp.ptr)
+#define CMD_STATE(Cmnd)		((Cmnd)->SCp.phase)
+#define CMD_ABTS_STATUS(Cmnd)	((Cmnd)->SCp.Message)
+#define CMD_LR_STATUS(Cmnd)	((Cmnd)->SCp.have_data_in)
+#define CMD_TAG(Cmnd)           ((Cmnd)->SCp.sent_command)
+
+#define FCPIO_INVALID_CODE 0x100 /* hdr_status value unused by firmware */
+
+#define FNIC_LUN_RESET_TIMEOUT	     10000	/* mSec */
+#define FNIC_HOST_RESET_TIMEOUT	     10000	/* mSec */
+#define FNIC_RMDEVICE_TIMEOUT        1000       /* mSec */
+#define FNIC_HOST_RESET_SETTLE_TIME  30         /* Sec */
+
+#define FNIC_MAX_FCP_TARGET     256
+
+extern unsigned int fnic_log_level;
+
+#define FNIC_MAIN_LOGGING 0x01
+#define FNIC_FCS_LOGGING 0x02
+#define FNIC_SCSI_LOGGING 0x04
+#define FNIC_ISR_LOGGING 0x08
+
+#define FNIC_CHECK_LOGGING(LEVEL, CMD)				\
+do {								\
+	if (unlikely(fnic_log_level & LEVEL))			\
+		do {						\
+			CMD;					\
+		} while (0);					\
+} while (0)
+
+#define FNIC_MAIN_DBG(kern_level, host, fmt, args...)		\
+	FNIC_CHECK_LOGGING(FNIC_MAIN_LOGGING,			\
+			 shost_printk(kern_level, host, fmt, ##args);)
+
+#define FNIC_FCS_DBG(kern_level, host, fmt, args...)		\
+	FNIC_CHECK_LOGGING(FNIC_FCS_LOGGING,			\
+			 shost_printk(kern_level, host, fmt, ##args);)
+
+#define FNIC_SCSI_DBG(kern_level, host, fmt, args...)		\
+	FNIC_CHECK_LOGGING(FNIC_SCSI_LOGGING,			\
+			 shost_printk(kern_level, host, fmt, ##args);)
+
+#define FNIC_ISR_DBG(kern_level, host, fmt, args...)		\
+	FNIC_CHECK_LOGGING(FNIC_ISR_LOGGING,			\
+			 shost_printk(kern_level, host, fmt, ##args);)
+
+extern const char *fnic_state_str[];
+
+enum fnic_intx_intr_index {
+	FNIC_INTX_WQ_RQ_COPYWQ,
+	FNIC_INTX_ERR,
+	FNIC_INTX_NOTIFY,
+	FNIC_INTX_INTR_MAX,
+};
+
+enum fnic_msix_intr_index {
+	FNIC_MSIX_RQ,
+	FNIC_MSIX_WQ,
+	FNIC_MSIX_WQ_COPY,
+	FNIC_MSIX_ERR_NOTIFY,
+	FNIC_MSIX_INTR_MAX,
+};
+
+struct fnic_msix_entry {
+	int requested;
+	char devname[IFNAMSIZ];
+	irqreturn_t (*isr)(int, void *);
+	void *devid;
+};
+
+enum fnic_state {
+	FNIC_IN_FC_MODE = 0,
+	FNIC_IN_FC_TRANS_ETH_MODE,
+	FNIC_IN_ETH_MODE,
+	FNIC_IN_ETH_TRANS_FC_MODE,
+};
+
+#define FNIC_WQ_COPY_MAX 1
+#define FNIC_WQ_MAX 1
+#define FNIC_RQ_MAX 1
+#define FNIC_CQ_MAX (FNIC_WQ_COPY_MAX + FNIC_WQ_MAX + FNIC_RQ_MAX)
+
+struct mempool;
+
+/* Per-instance private data structure */
+struct fnic {
+	struct fc_lport *lport;
+	struct vnic_dev_bar bar0;
+
+	struct msix_entry msix_entry[FNIC_MSIX_INTR_MAX];
+	struct fnic_msix_entry msix[FNIC_MSIX_INTR_MAX];
+
+	struct vnic_stats *stats;
+	unsigned long stats_time;	/* time of stats update */
+	struct vnic_nic_cfg *nic_cfg;
+	char name[IFNAMSIZ];
+	struct timer_list notify_timer; /* used for MSI interrupts */
+
+	unsigned int err_intr_offset;
+	unsigned int link_intr_offset;
+
+	unsigned int wq_count;
+	unsigned int cq_count;
+
+	u32 fcoui_mode:1;		/* use fcoui address*/
+	u32 vlan_hw_insert:1;	        /* let hw insert the tag */
+	u32 in_remove:1;                /* fnic device in removal */
+	u32 stop_rx_link_events:1;      /* stop proc. rx frames, link events */
+
+	struct completion *remove_wait; /* device remove thread blocks */
+
+	struct fc_frame *flogi;
+	struct fc_frame *flogi_resp;
+	u16 flogi_oxid;
+	unsigned long s_id;
+	enum fnic_state state;
+	spinlock_t fnic_lock;
+
+	u16 vlan_id;	                /* VLAN tag including priority */
+	u8 mac_addr[ETH_ALEN];
+	u8 dest_addr[ETH_ALEN];
+	u8 data_src_addr[ETH_ALEN];
+	u64 fcp_input_bytes;		/* internal statistic */
+	u64 fcp_output_bytes;		/* internal statistic */
+	u32 link_down_cnt;
+	int link_status;
+
+	struct list_head list;
+	struct pci_dev *pdev;
+	struct vnic_fc_config config;
+	struct vnic_dev *vdev;
+	unsigned int raw_wq_count;
+	unsigned int wq_copy_count;
+	unsigned int rq_count;
+	int fw_ack_index[FNIC_WQ_COPY_MAX];
+	unsigned short fw_ack_recd[FNIC_WQ_COPY_MAX];
+	unsigned short wq_copy_desc_low[FNIC_WQ_COPY_MAX];
+	unsigned int intr_count;
+	u32 __iomem *legacy_pba;
+	struct fnic_host_tag *tags;
+	mempool_t *io_req_pool;
+	mempool_t *io_sgl_pool[FNIC_SGL_NUM_CACHES];
+	spinlock_t io_req_lock[FNIC_IO_LOCKS];	/* locks for scsi cmnds */
+
+	struct work_struct link_work;
+	struct work_struct frame_work;
+	struct sk_buff_head frame_queue;
+
+	/* copy work queue cache line section */
+	____cacheline_aligned struct vnic_wq_copy wq_copy[FNIC_WQ_COPY_MAX];
+	/* completion queue cache line section */
+	____cacheline_aligned struct vnic_cq cq[FNIC_CQ_MAX];
+
+	spinlock_t wq_copy_lock[FNIC_WQ_COPY_MAX];
+
+	/* work queue cache line section */
+	____cacheline_aligned struct vnic_wq wq[FNIC_WQ_MAX];
+	spinlock_t wq_lock[FNIC_WQ_MAX];
+
+	/* receive queue cache line section */
+	____cacheline_aligned struct vnic_rq rq[FNIC_RQ_MAX];
+
+	/* interrupt resource cache line section */
+	____cacheline_aligned struct vnic_intr intr[FNIC_MSIX_INTR_MAX];
+};
+
+extern struct workqueue_struct *fnic_event_queue;
+extern struct device_attribute *fnic_attrs[];
+
+void fnic_clear_intr_mode(struct fnic *fnic);
+int fnic_set_intr_mode(struct fnic *fnic);
+void fnic_free_intr(struct fnic *fnic);
+int fnic_request_intr(struct fnic *fnic);
+
+int fnic_send(struct fc_lport *, struct fc_frame *);
+void fnic_free_wq_buf(struct vnic_wq *wq, struct vnic_wq_buf *buf);
+void fnic_handle_frame(struct work_struct *work);
+void fnic_handle_link(struct work_struct *work);
+int fnic_rq_cmpl_handler(struct fnic *fnic, int);
+int fnic_alloc_rq_frame(struct vnic_rq *rq);
+void fnic_free_rq_buf(struct vnic_rq *rq, struct vnic_rq_buf *buf);
+int fnic_send_frame(struct fnic *fnic, struct fc_frame *fp);
+
+int fnic_queuecommand(struct scsi_cmnd *, void (*done)(struct scsi_cmnd *));
+int fnic_abort_cmd(struct scsi_cmnd *);
+int fnic_device_reset(struct scsi_cmnd *);
+int fnic_host_reset(struct scsi_cmnd *);
+int fnic_reset(struct Scsi_Host *);
+void fnic_scsi_cleanup(struct fc_lport *);
+void fnic_scsi_abort_io(struct fc_lport *);
+void fnic_empty_scsi_cleanup(struct fc_lport *);
+void fnic_exch_mgr_reset(struct fc_lport *, u32, u32);
+int fnic_wq_copy_cmpl_handler(struct fnic *fnic, int);
+int fnic_wq_cmpl_handler(struct fnic *fnic, int);
+int fnic_flogi_reg_handler(struct fnic *fnic);
+void fnic_wq_copy_cleanup_handler(struct vnic_wq_copy *wq,
+				  struct fcpio_host_req *desc);
+int fnic_fw_reset_handler(struct fnic *fnic);
+void fnic_terminate_rport_io(struct fc_rport *);
+const char *fnic_state_to_str(unsigned int state);
+
+void fnic_log_q_error(struct fnic *fnic);
+void fnic_handle_link_event(struct fnic *fnic);
+
+#endif /* _FNIC_H_ */
