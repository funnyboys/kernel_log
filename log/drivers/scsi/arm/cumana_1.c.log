commit 09c434b8a0047c69e48499de0107de312901e798
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Sun May 19 13:08:20 2019 +0100

    treewide: Add SPDX license identifier for more missed files
    
    Add SPDX license identifiers to all files which:
    
     - Have no license information of any form
    
     - Have MODULE_LICENCE("GPL*") inside which was used in the initial
       scan/conversion to ignore the file
    
    These files fall under the project license, GPL v2 only. The resulting SPDX
    license identifier is:
    
      GPL-2.0-only
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/scsi/arm/cumana_1.c b/drivers/scsi/arm/cumana_1.c
index e2d2a81d8e0b..3fd944374631 100644
--- a/drivers/scsi/arm/cumana_1.c
+++ b/drivers/scsi/arm/cumana_1.c
@@ -1,3 +1,4 @@
+// SPDX-License-Identifier: GPL-2.0-only
 /*
  * Generic Generic NCR5380 driver
  *

commit 4af14d113bcf95c12d1462ba623b7e7117bd3fb3
Author: Christoph Hellwig <hch@lst.de>
Date:   Thu Dec 13 16:17:09 2018 +0100

    scsi: remove the use_clustering flag
    
    The same effects can be achieved by setting the dma_boundary to
    PAGE_SIZE - 1 and the max_segment_size to PAGE_SIZE, so shift those
    settings into the drivers.  Note that in many cases the setting might
    be bogus, but this keeps the status quo.
    
    [mkp: fix myrs and myrb]
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/arm/cumana_1.c b/drivers/scsi/arm/cumana_1.c
index ae1d809904fb..e2d2a81d8e0b 100644
--- a/drivers/scsi/arm/cumana_1.c
+++ b/drivers/scsi/arm/cumana_1.c
@@ -221,10 +221,10 @@ static struct scsi_host_template cumanascsi_template = {
 	.this_id		= 7,
 	.sg_tablesize		= SG_ALL,
 	.cmd_per_lun		= 2,
-	.use_clustering		= DISABLE_CLUSTERING,
 	.proc_name		= "CumanaSCSI-1",
 	.cmd_size		= NCR5380_CMD_SIZE,
 	.max_sectors		= 128,
+	.dma_boundary		= PAGE_SIZE - 1,
 };
 
 static int cumanascsi1_probe(struct expansion_card *ec,

commit 12e5fc665a2d8380c1551291a0d7684fc181b02d
Author: Hannes Reinecke <hare@suse.de>
Date:   Fri Aug 25 13:57:10 2017 +0200

    scsi: NCR5380: Move bus reset to host reset
    
    The bus reset handler really is a host reset, so move it to
    eh_bus_reset_handler.
    
    Signed-off-by: Hannes Reinecke <hare@suse.com>
    Acked-by: Finn Thain <fthain@telegraphics.com.au>
    Reviewed-by: Christoph Hellwig <hch@lst.de>
    Reviewed-by: Johannes Thumshirn <jthumshirn@suse.de>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/arm/cumana_1.c b/drivers/scsi/arm/cumana_1.c
index a87b99c7fb9a..ae1d809904fb 100644
--- a/drivers/scsi/arm/cumana_1.c
+++ b/drivers/scsi/arm/cumana_1.c
@@ -216,7 +216,7 @@ static struct scsi_host_template cumanascsi_template = {
 	.info			= cumanascsi_info,
 	.queuecommand		= cumanascsi_queue_command,
 	.eh_abort_handler	= NCR5380_abort,
-	.eh_bus_reset_handler	= NCR5380_bus_reset,
+	.eh_host_reset_handler	= NCR5380_host_reset,
 	.can_queue		= 16,
 	.this_id		= 7,
 	.sg_tablesize		= SG_ALL,

commit 4a98f896bf2c66a69517fc5e10dc67288cb8da93
Author: Finn Thain <fthain@telegraphics.com.au>
Date:   Mon Oct 10 00:46:53 2016 -0400

    scsi: ncr5380: Use correct types for DMA routines
    
    Apply prototypes to get consistent function signatures for the DMA
    functions implemented in the board-specific drivers. To avoid using
    macros to alter actual parameters, some of those functions are reworked
    slightly.
    
    This is a step toward the goal of passing the board-specific routines
    to the core driver using an ops struct (as in a platform driver or
    library module).
    
    This also helps fix some inconsistent types: where the core driver uses
    ints (cmd->SCp.this_residual and hostdata->dma_len) for keeping track of
    transfers, certain board-specific routines used unsigned long.
    
    While we are fixing these function signatures, pass the hostdata pointer
    to DMA routines instead of a Scsi_Host pointer, for shorter and faster
    code.
    
    Signed-off-by: Finn Thain <fthain@telegraphics.com.au>
    Reviewed-by: Hannes Reinecke <hare@suse.com>
    Tested-by: Ondrej Zary <linux@rainbow-software.org>
    Tested-by: Michael Schmitz <schmitzmic@gmail.com>
    Acked-by: Russell King <rmk+kernel@armlinux.org.uk>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/arm/cumana_1.c b/drivers/scsi/arm/cumana_1.c
index fb7600dec5be..a87b99c7fb9a 100644
--- a/drivers/scsi/arm/cumana_1.c
+++ b/drivers/scsi/arm/cumana_1.c
@@ -17,10 +17,10 @@
 #define NCR5380_read(reg)		cumanascsi_read(hostdata, reg)
 #define NCR5380_write(reg, value)	cumanascsi_write(hostdata, reg, value)
 
-#define NCR5380_dma_xfer_len(instance, cmd, phase)	(cmd->transfersize)
+#define NCR5380_dma_xfer_len		cumanascsi_dma_xfer_len
 #define NCR5380_dma_recv_setup		cumanascsi_pread
 #define NCR5380_dma_send_setup		cumanascsi_pwrite
-#define NCR5380_dma_residual(instance)	(0)
+#define NCR5380_dma_residual		NCR5380_dma_residual_none
 
 #define NCR5380_intr			cumanascsi_intr
 #define NCR5380_queue_command		cumanascsi_queue_command
@@ -40,12 +40,12 @@ static void cumanascsi_write(struct NCR5380_hostdata *, unsigned int, u8);
 #define L(v)	(((v)<<16)|((v) & 0x0000ffff))
 #define H(v)	(((v)>>16)|((v) & 0xffff0000))
 
-static inline int cumanascsi_pwrite(struct Scsi_Host *host,
+static inline int cumanascsi_pwrite(struct NCR5380_hostdata *hostdata,
                                     unsigned char *addr, int len)
 {
   unsigned long *laddr;
-  u8 __iomem *base = priv(host)->io;
-  u8 __iomem *dma = priv(host)->pdma_io + 0x2000;
+  u8 __iomem *base = hostdata->io;
+  u8 __iomem *dma = hostdata->pdma_io + 0x2000;
 
   if(!len) return 0;
 
@@ -100,19 +100,19 @@ static inline int cumanascsi_pwrite(struct Scsi_Host *host,
     }
   }
 end:
-  writeb(priv(host)->ctrl | 0x40, base + CTRL);
+  writeb(hostdata->ctrl | 0x40, base + CTRL);
 
 	if (len)
 		return -1;
 	return 0;
 }
 
-static inline int cumanascsi_pread(struct Scsi_Host *host,
+static inline int cumanascsi_pread(struct NCR5380_hostdata *hostdata,
                                    unsigned char *addr, int len)
 {
   unsigned long *laddr;
-  u8 __iomem *base = priv(host)->io;
-  u8 __iomem *dma = priv(host)->pdma_io + 0x2000;
+  u8 __iomem *base = hostdata->io;
+  u8 __iomem *dma = hostdata->pdma_io + 0x2000;
 
   if(!len) return 0;
 
@@ -166,13 +166,19 @@ static inline int cumanascsi_pread(struct Scsi_Host *host,
     }
   }
 end:
-  writeb(priv(host)->ctrl | 0x40, base + CTRL);
+  writeb(hostdata->ctrl | 0x40, base + CTRL);
 
 	if (len)
 		return -1;
 	return 0;
 }
 
+static int cumanascsi_dma_xfer_len(struct NCR5380_hostdata *hostdata,
+                                   struct scsi_cmnd *cmd)
+{
+	return cmd->transfersize;
+}
+
 static u8 cumanascsi_read(struct NCR5380_hostdata *hostdata,
                           unsigned int reg)
 {

commit 7c60663143c29ea64f51e692f950f8619e0e4c77
Author: Finn Thain <fthain@telegraphics.com.au>
Date:   Mon Oct 10 00:46:53 2016 -0400

    scsi: ncr5380: Expedite register polling
    
    Avoid the call to NCR5380_poll_politely2() when possible. The call is
    easily short-circuited on the PIO fast path, using the inline wrapper.
    This requires that the NCR5380_read macro be made available before
    any #include "NCR5380.h" so a few declarations have to be moved too.
    
    Signed-off-by: Finn Thain <fthain@telegraphics.com.au>
    Reviewed-by: Hannes Reinecke <hare@suse.com>
    Tested-by: Ondrej Zary <linux@rainbow-software.org>
    Tested-by: Michael Schmitz <schmitzmic@gmail.com>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/arm/cumana_1.c b/drivers/scsi/arm/cumana_1.c
index ae1d4c6786de..fb7600dec5be 100644
--- a/drivers/scsi/arm/cumana_1.c
+++ b/drivers/scsi/arm/cumana_1.c
@@ -29,6 +29,10 @@
 #define NCR5380_implementation_fields	\
 	unsigned ctrl
 
+struct NCR5380_hostdata;
+static u8 cumanascsi_read(struct NCR5380_hostdata *, unsigned int);
+static void cumanascsi_write(struct NCR5380_hostdata *, unsigned int, u8);
+
 #include "../NCR5380.h"
 
 #define CTRL	0x16fc

commit 61e1ce588b101f13a4c6f713b95d65551c8572e3
Author: Finn Thain <fthain@telegraphics.com.au>
Date:   Mon Oct 10 00:46:53 2016 -0400

    scsi: ncr5380: Use correct types for device register accessors
    
    For timeout values adopt unsigned long, which is the type of jiffies etc.
    
    For chip register values and bit masks pass u8, which is the return type
    of readb, inb etc.
    
    For device register offsets adopt unsigned int, as it is suitable for
    adding to base addresses.
    
    Pass the NCR5380_hostdata pointer to the board-specific routines instead
    of the Scsi_Host pointer. The board-specific code is concerned with
    hardware and not with SCSI protocol or the mid-layer.
    
    Signed-off-by: Finn Thain <fthain@telegraphics.com.au>
    Reviewed-by: Hannes Reinecke <hare@suse.com>
    Tested-by: Ondrej Zary <linux@rainbow-software.org>
    Tested-by: Michael Schmitz <schmitzmic@gmail.com>
    Acked-by: Russell King <rmk+kernel@armlinux.org.uk>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/arm/cumana_1.c b/drivers/scsi/arm/cumana_1.c
index 88db2816f97c..ae1d4c6786de 100644
--- a/drivers/scsi/arm/cumana_1.c
+++ b/drivers/scsi/arm/cumana_1.c
@@ -14,8 +14,8 @@
 #include <scsi/scsi_host.h>
 
 #define priv(host)			((struct NCR5380_hostdata *)(host)->hostdata)
-#define NCR5380_read(reg)		cumanascsi_read(instance, reg)
-#define NCR5380_write(reg, value)	cumanascsi_write(instance, reg, value)
+#define NCR5380_read(reg)		cumanascsi_read(hostdata, reg)
+#define NCR5380_write(reg, value)	cumanascsi_write(hostdata, reg, value)
 
 #define NCR5380_dma_xfer_len(instance, cmd, phase)	(cmd->transfersize)
 #define NCR5380_dma_recv_setup		cumanascsi_pread
@@ -169,30 +169,32 @@ static inline int cumanascsi_pread(struct Scsi_Host *host,
 	return 0;
 }
 
-static unsigned char cumanascsi_read(struct Scsi_Host *host, unsigned int reg)
+static u8 cumanascsi_read(struct NCR5380_hostdata *hostdata,
+                          unsigned int reg)
 {
-	u8 __iomem *base = priv(host)->io;
-	unsigned char val;
+	u8 __iomem *base = hostdata->io;
+	u8 val;
 
 	writeb(0, base + CTRL);
 
 	val = readb(base + 0x2100 + (reg << 2));
 
-	priv(host)->ctrl = 0x40;
+	hostdata->ctrl = 0x40;
 	writeb(0x40, base + CTRL);
 
 	return val;
 }
 
-static void cumanascsi_write(struct Scsi_Host *host, unsigned int reg, unsigned int value)
+static void cumanascsi_write(struct NCR5380_hostdata *hostdata,
+                             unsigned int reg, u8 value)
 {
-	u8 __iomem *base = priv(host)->io;
+	u8 __iomem *base = hostdata->io;
 
 	writeb(0, base + CTRL);
 
 	writeb(value, base + 0x2100 + (reg << 2));
 
-	priv(host)->ctrl = 0x40;
+	hostdata->ctrl = 0x40;
 	writeb(0x40, base + CTRL);
 }
 

commit 820682b1b34ebb97434c4abc00c744870364e2be
Author: Finn Thain <fthain@telegraphics.com.au>
Date:   Mon Oct 10 00:46:53 2016 -0400

    scsi: ncr5380: Store IO ports and addresses in host private data
    
    The various 5380 drivers inconsistently store register pointers
    either in the Scsi_Host struct "legacy crap" area or in special,
    board-specific members of the NCR5380_hostdata struct. Uniform
    use of the latter struct makes for simpler and faster code (see
    the following patches) and helps to reduce use of the
    NCR5380_implementation_fields macro.
    
    Signed-off-by: Finn Thain <fthain@telegraphics.com.au>
    Reviewed-by: Hannes Reinecke <hare@suse.com>
    Tested-by: Ondrej Zary <linux@rainbow-software.org>
    Tested-by: Michael Schmitz <schmitzmic@gmail.com>
    Acked-by: Russell King <rmk+kernel@armlinux.org.uk>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/arm/cumana_1.c b/drivers/scsi/arm/cumana_1.c
index f616756feee5..88db2816f97c 100644
--- a/drivers/scsi/arm/cumana_1.c
+++ b/drivers/scsi/arm/cumana_1.c
@@ -27,9 +27,7 @@
 #define NCR5380_info			cumanascsi_info
 
 #define NCR5380_implementation_fields	\
-	unsigned ctrl;			\
-	void __iomem *base;		\
-	void __iomem *dma
+	unsigned ctrl
 
 #include "../NCR5380.h"
 
@@ -42,17 +40,18 @@ static inline int cumanascsi_pwrite(struct Scsi_Host *host,
                                     unsigned char *addr, int len)
 {
   unsigned long *laddr;
-  void __iomem *dma = priv(host)->dma + 0x2000;
+  u8 __iomem *base = priv(host)->io;
+  u8 __iomem *dma = priv(host)->pdma_io + 0x2000;
 
   if(!len) return 0;
 
-  writeb(0x02, priv(host)->base + CTRL);
+  writeb(0x02, base + CTRL);
   laddr = (unsigned long *)addr;
   while(len >= 32)
   {
     unsigned int status;
     unsigned long v;
-    status = readb(priv(host)->base + STAT);
+    status = readb(base + STAT);
     if(status & 0x80)
       goto end;
     if(!(status & 0x40))
@@ -71,12 +70,12 @@ static inline int cumanascsi_pwrite(struct Scsi_Host *host,
   }
 
   addr = (unsigned char *)laddr;
-  writeb(0x12, priv(host)->base + CTRL);
+  writeb(0x12, base + CTRL);
 
   while(len > 0)
   {
     unsigned int status;
-    status = readb(priv(host)->base + STAT);
+    status = readb(base + STAT);
     if(status & 0x80)
       goto end;
     if(status & 0x40)
@@ -86,7 +85,7 @@ static inline int cumanascsi_pwrite(struct Scsi_Host *host,
         break;
     }
 
-    status = readb(priv(host)->base + STAT);
+    status = readb(base + STAT);
     if(status & 0x80)
       goto end;
     if(status & 0x40)
@@ -97,7 +96,7 @@ static inline int cumanascsi_pwrite(struct Scsi_Host *host,
     }
   }
 end:
-  writeb(priv(host)->ctrl | 0x40, priv(host)->base + CTRL);
+  writeb(priv(host)->ctrl | 0x40, base + CTRL);
 
 	if (len)
 		return -1;
@@ -108,16 +107,17 @@ static inline int cumanascsi_pread(struct Scsi_Host *host,
                                    unsigned char *addr, int len)
 {
   unsigned long *laddr;
-  void __iomem *dma = priv(host)->dma + 0x2000;
+  u8 __iomem *base = priv(host)->io;
+  u8 __iomem *dma = priv(host)->pdma_io + 0x2000;
 
   if(!len) return 0;
 
-  writeb(0x00, priv(host)->base + CTRL);
+  writeb(0x00, base + CTRL);
   laddr = (unsigned long *)addr;
   while(len >= 32)
   {
     unsigned int status;
-    status = readb(priv(host)->base + STAT);
+    status = readb(base + STAT);
     if(status & 0x80)
       goto end;
     if(!(status & 0x40))
@@ -136,12 +136,12 @@ static inline int cumanascsi_pread(struct Scsi_Host *host,
   }
 
   addr = (unsigned char *)laddr;
-  writeb(0x10, priv(host)->base + CTRL);
+  writeb(0x10, base + CTRL);
 
   while(len > 0)
   {
     unsigned int status;
-    status = readb(priv(host)->base + STAT);
+    status = readb(base + STAT);
     if(status & 0x80)
       goto end;
     if(status & 0x40)
@@ -151,7 +151,7 @@ static inline int cumanascsi_pread(struct Scsi_Host *host,
         break;
     }
 
-    status = readb(priv(host)->base + STAT);
+    status = readb(base + STAT);
     if(status & 0x80)
       goto end;
     if(status & 0x40)
@@ -162,7 +162,7 @@ static inline int cumanascsi_pread(struct Scsi_Host *host,
     }
   }
 end:
-  writeb(priv(host)->ctrl | 0x40, priv(host)->base + CTRL);
+  writeb(priv(host)->ctrl | 0x40, base + CTRL);
 
 	if (len)
 		return -1;
@@ -171,7 +171,7 @@ static inline int cumanascsi_pread(struct Scsi_Host *host,
 
 static unsigned char cumanascsi_read(struct Scsi_Host *host, unsigned int reg)
 {
-	void __iomem *base = priv(host)->base;
+	u8 __iomem *base = priv(host)->io;
 	unsigned char val;
 
 	writeb(0, base + CTRL);
@@ -186,7 +186,7 @@ static unsigned char cumanascsi_read(struct Scsi_Host *host, unsigned int reg)
 
 static void cumanascsi_write(struct Scsi_Host *host, unsigned int reg, unsigned int value)
 {
-	void __iomem *base = priv(host)->base;
+	u8 __iomem *base = priv(host)->io;
 
 	writeb(0, base + CTRL);
 
@@ -231,11 +231,11 @@ static int cumanascsi1_probe(struct expansion_card *ec,
 		goto out_release;
 	}
 
-	priv(host)->base = ioremap(ecard_resource_start(ec, ECARD_RES_IOCSLOW),
-				   ecard_resource_len(ec, ECARD_RES_IOCSLOW));
-	priv(host)->dma = ioremap(ecard_resource_start(ec, ECARD_RES_MEMC),
-				  ecard_resource_len(ec, ECARD_RES_MEMC));
-	if (!priv(host)->base || !priv(host)->dma) {
+	priv(host)->io = ioremap(ecard_resource_start(ec, ECARD_RES_IOCSLOW),
+	                         ecard_resource_len(ec, ECARD_RES_IOCSLOW));
+	priv(host)->pdma_io = ioremap(ecard_resource_start(ec, ECARD_RES_MEMC),
+	                              ecard_resource_len(ec, ECARD_RES_MEMC));
+	if (!priv(host)->io || !priv(host)->pdma_io) {
 		ret = -ENOMEM;
 		goto out_unmap;
 	}
@@ -249,7 +249,7 @@ static int cumanascsi1_probe(struct expansion_card *ec,
 	NCR5380_maybe_reset_bus(host);
 
         priv(host)->ctrl = 0;
-        writeb(0, priv(host)->base + CTRL);
+        writeb(0, priv(host)->io + CTRL);
 
 	ret = request_irq(host->irq, cumanascsi_intr, 0,
 			  "CumanaSCSI-1", host);
@@ -271,8 +271,8 @@ static int cumanascsi1_probe(struct expansion_card *ec,
  out_exit:
 	NCR5380_exit(host);
  out_unmap:
-	iounmap(priv(host)->base);
-	iounmap(priv(host)->dma);
+	iounmap(priv(host)->io);
+	iounmap(priv(host)->pdma_io);
 	scsi_host_put(host);
  out_release:
 	ecard_release_resources(ec);
@@ -283,15 +283,17 @@ static int cumanascsi1_probe(struct expansion_card *ec,
 static void cumanascsi1_remove(struct expansion_card *ec)
 {
 	struct Scsi_Host *host = ecard_get_drvdata(ec);
+	void __iomem *base = priv(host)->io;
+	void __iomem *dma = priv(host)->pdma_io;
 
 	ecard_set_drvdata(ec, NULL);
 
 	scsi_remove_host(host);
 	free_irq(host->irq, host);
 	NCR5380_exit(host);
-	iounmap(priv(host)->base);
-	iounmap(priv(host)->dma);
 	scsi_host_put(host);
+	iounmap(base);
+	iounmap(dma);
 	ecard_release_resources(ec);
 }
 

commit b223680da0627eccf38ba28453746ac7bee06342
Author: Finn Thain <fthain@telegraphics.com.au>
Date:   Mon Oct 10 00:46:52 2016 -0400

    scsi: cumana_1: Remove unused cumanascsi_setup() function
    
    Signed-off-by: Finn Thain <fthain@telegraphics.com.au>
    Reviewed-by: Hannes Reinecke <hare@suse.com>
    Acked-by: Russell King <rmk+kernel@armlinux.org.uk>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/arm/cumana_1.c b/drivers/scsi/arm/cumana_1.c
index 8e9cfe8f22f5..f616756feee5 100644
--- a/drivers/scsi/arm/cumana_1.c
+++ b/drivers/scsi/arm/cumana_1.c
@@ -33,10 +33,6 @@
 
 #include "../NCR5380.h"
 
-void cumanascsi_setup(char *str, int *ints)
-{
-}
-
 #define CTRL	0x16fc
 #define STAT	0x2004
 #define L(v)	(((v)<<16)|((v) & 0x0000ffff))

commit 8053b0ee79c0129e827ce8f222398ff4b332dfd7
Author: Finn Thain <fthain@telegraphics.com.au>
Date:   Wed Mar 23 21:10:19 2016 +1100

    ncr5380: Merge DMA implementation from atari_NCR5380 core driver
    
    Adopt the DMA implementation from atari_NCR5380.c. This means that
    atari_scsi and sun3_scsi can make use of the NCR5380.c core driver
    and the atari_NCR5380.c driver fork can be made redundant.
    
    Signed-off-by: Finn Thain <fthain@telegraphics.com.au>
    Reviewed-by: Hannes Reinecke <hare@suse.com>
    Tested-by: Michael Schmitz <schmitzmic@gmail.com>
    Tested-by: Ondrej Zary <linux@rainbow-software.org>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/arm/cumana_1.c b/drivers/scsi/arm/cumana_1.c
index 402d984aa088..8e9cfe8f22f5 100644
--- a/drivers/scsi/arm/cumana_1.c
+++ b/drivers/scsi/arm/cumana_1.c
@@ -20,6 +20,7 @@
 #define NCR5380_dma_xfer_len(instance, cmd, phase)	(cmd->transfersize)
 #define NCR5380_dma_recv_setup		cumanascsi_pread
 #define NCR5380_dma_send_setup		cumanascsi_pwrite
+#define NCR5380_dma_residual(instance)	(0)
 
 #define NCR5380_intr			cumanascsi_intr
 #define NCR5380_queue_command		cumanascsi_queue_command
@@ -245,7 +246,7 @@ static int cumanascsi1_probe(struct expansion_card *ec,
 
 	host->irq = ec->irq;
 
-	ret = NCR5380_init(host, FLAG_DMA_FIXUP);
+	ret = NCR5380_init(host, FLAG_DMA_FIXUP | FLAG_LATE_DMA_SETUP);
 	if (ret)
 		goto out_unmap;
 

commit 438af51c642926f1c1844846bee1c3fb568dcd64
Author: Finn Thain <fthain@telegraphics.com.au>
Date:   Wed Mar 23 21:10:18 2016 +1100

    ncr5380: Adopt uniform DMA setup convention
    
    Standardize the DMA setup hooks so that the DMA implementation in
    atari_NCR5380.c can be reconciled with pseudo DMA implementation in
    NCR5380.c.
    
    Calls to NCR5380_dma_recv_setup() and NCR5380_dma_send_setup() return
    a negative value on failure, zero on PDMA transfer success and a positive
    byte count for DMA setup success.
    
    This convention is not entirely new, but is now applied consistently.
    
    Also remove a pointless Status Register access: the *phase assignment is
    redundant because after NCR5380_transfer_dma() returns control to
    NCR5380_information_transfer(), that routine then returns control
    to NCR5380_main(), which means *phase is dead.
    
    Signed-off-by: Finn Thain <fthain@telegraphics.com.au>
    Reviewed-by: Hannes Reinecke <hare@suse.com>
    Tested-by: Michael Schmitz <schmitzmic@gmail.com>
    Tested-by: Ondrej Zary <linux@rainbow-software.org>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/arm/cumana_1.c b/drivers/scsi/arm/cumana_1.c
index 7bcb66893059..402d984aa088 100644
--- a/drivers/scsi/arm/cumana_1.c
+++ b/drivers/scsi/arm/cumana_1.c
@@ -101,7 +101,10 @@ static inline int cumanascsi_pwrite(struct Scsi_Host *host,
   }
 end:
   writeb(priv(host)->ctrl | 0x40, priv(host)->base + CTRL);
-  return len;
+
+	if (len)
+		return -1;
+	return 0;
 }
 
 static inline int cumanascsi_pread(struct Scsi_Host *host,
@@ -163,7 +166,10 @@ static inline int cumanascsi_pread(struct Scsi_Host *host,
   }
 end:
   writeb(priv(host)->ctrl | 0x40, priv(host)->base + CTRL);
-  return len;
+
+	if (len)
+		return -1;
+	return 0;
 }
 
 static unsigned char cumanascsi_read(struct Scsi_Host *host, unsigned int reg)

commit 6c4b88ca59ba1a68f707f19dba1744ed19e89fce
Author: Finn Thain <fthain@telegraphics.com.au>
Date:   Wed Mar 23 21:10:17 2016 +1100

    ncr5380: Use DMA hooks for PDMA
    
    Those wrapper drivers which use DMA define the REAL_DMA macro and
    those which use pseudo DMA define PSEUDO_DMA. These macros need to be
    removed for a number of reasons, not least of which is to have drivers
    share more code.
    
    Redefine the PDMA send and receive hooks as DMA setup hooks, so that the
    DMA code can be shared by all 5380 wrapper drivers. This will help to
    reunify the forked core driver.
    
    Signed-off-by: Finn Thain <fthain@telegraphics.com.au>
    Reviewed-by: Hannes Reinecke <hare@suse.com>
    Tested-by: Michael Schmitz <schmitzmic@gmail.com>
    Tested-by: Ondrej Zary <linux@rainbow-software.org>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/arm/cumana_1.c b/drivers/scsi/arm/cumana_1.c
index 6e9de19fc3c2..7bcb66893059 100644
--- a/drivers/scsi/arm/cumana_1.c
+++ b/drivers/scsi/arm/cumana_1.c
@@ -18,6 +18,8 @@
 #define NCR5380_write(reg, value)	cumanascsi_write(instance, reg, value)
 
 #define NCR5380_dma_xfer_len(instance, cmd, phase)	(cmd->transfersize)
+#define NCR5380_dma_recv_setup		cumanascsi_pread
+#define NCR5380_dma_send_setup		cumanascsi_pwrite
 
 #define NCR5380_intr			cumanascsi_intr
 #define NCR5380_queue_command		cumanascsi_queue_command
@@ -39,8 +41,8 @@ void cumanascsi_setup(char *str, int *ints)
 #define L(v)	(((v)<<16)|((v) & 0x0000ffff))
 #define H(v)	(((v)>>16)|((v) & 0xffff0000))
 
-static inline int
-NCR5380_pwrite(struct Scsi_Host *host, unsigned char *addr, int len)
+static inline int cumanascsi_pwrite(struct Scsi_Host *host,
+                                    unsigned char *addr, int len)
 {
   unsigned long *laddr;
   void __iomem *dma = priv(host)->dma + 0x2000;
@@ -102,8 +104,8 @@ NCR5380_pwrite(struct Scsi_Host *host, unsigned char *addr, int len)
   return len;
 }
 
-static inline int
-NCR5380_pread(struct Scsi_Host *host, unsigned char *addr, int len)
+static inline int cumanascsi_pread(struct Scsi_Host *host,
+                                   unsigned char *addr, int len)
 {
   unsigned long *laddr;
   void __iomem *dma = priv(host)->dma + 0x2000;

commit f825e40b235f4daf1c9017366809d34c7f5c8c7f
Author: Finn Thain <fthain@telegraphics.com.au>
Date:   Wed Mar 23 21:10:15 2016 +1100

    ncr5380: Remove PSEUDO_DMA macro
    
    For those wrapper drivers which only implement Programmed IO, have
    NCR5380_dma_xfer_len() evaluate to zero. That allows PDMA to be easily
    disabled at run-time and so the PSEUDO_DMA macro is no longer needed.
    
    Also remove the spin counters used for debugging pseudo DMA drivers.
    
    Signed-off-by: Finn Thain <fthain@telegraphics.com.au>
    Reviewed-by: Hannes Reinecke <hare@suse.com>
    Tested-by: Michael Schmitz <schmitzmic@gmail.com>
    Tested-by: Ondrej Zary <linux@rainbow-software.org>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/arm/cumana_1.c b/drivers/scsi/arm/cumana_1.c
index 76b2d3364d9f..6e9de19fc3c2 100644
--- a/drivers/scsi/arm/cumana_1.c
+++ b/drivers/scsi/arm/cumana_1.c
@@ -13,8 +13,6 @@
 
 #include <scsi/scsi_host.h>
 
-#define PSEUDO_DMA
-
 #define priv(host)			((struct NCR5380_hostdata *)(host)->hostdata)
 #define NCR5380_read(reg)		cumanascsi_read(instance, reg)
 #define NCR5380_write(reg, value)	cumanascsi_write(instance, reg, value)

commit 1bb4600245d4d40245dd505ca17528e0b9a9ba8c
Author: Finn Thain <fthain@telegraphics.com.au>
Date:   Wed Mar 23 21:10:14 2016 +1100

    ncr5380: Disable the DMA errata workaround flag by default
    
    The only chip that needs the workarounds enabled is an early NMOS
    device. That means that the common case is to disable them.
    
    Unfortunately the sense of the flag is such that it has to be set
    for the common case.
    
    Rename the flag so that zero can be used to mean "no errata workarounds
    needed". This simplifies the code.
    
    Signed-off-by: Finn Thain <fthain@telegraphics.com.au>
    Reviewed-by: Hannes Reinecke <hare@suse.com>
    Tested-by: Michael Schmitz <schmitzmic@gmail.com>
    Tested-by: Ondrej Zary <linux@rainbow-software.org>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/arm/cumana_1.c b/drivers/scsi/arm/cumana_1.c
index 221f18c5df93..76b2d3364d9f 100644
--- a/drivers/scsi/arm/cumana_1.c
+++ b/drivers/scsi/arm/cumana_1.c
@@ -239,7 +239,7 @@ static int cumanascsi1_probe(struct expansion_card *ec,
 
 	host->irq = ec->irq;
 
-	ret = NCR5380_init(host, 0);
+	ret = NCR5380_init(host, FLAG_DMA_FIXUP);
 	if (ret)
 		goto out_unmap;
 

commit 0a4e36125451165847c6d4e7d5633d92e53f5c69
Author: Finn Thain <fthain@telegraphics.com.au>
Date:   Sun Jan 3 16:06:07 2016 +1100

    ncr5380: Fix soft lockups
    
    Because of the rudimentary design of the chip, it is necessary to poll the
    SCSI bus signals during PIO and this tends to hog the CPU. The driver will
    accept new commands while others execute, and this causes a soft lockup
    because the workqueue item will not terminate until the issue queue is
    emptied.
    
    When exercising dmx3191d using sequential IO from dd, the driver is sent
    512 KiB WRITE commands and 128 KiB READs. For a PIO transfer, the rate is
    is only about 300 KiB/s, so these are long-running commands. And although
    PDMA may run at several MiB/s, interrupts are disabled for the duration
    of the transfer.
    
    Fix the unresponsiveness and soft lockup issues by calling cond_resched()
    after each command is completed and by limiting max_sectors for drivers
    that don't implement real DMA.
    
    Signed-off-by: Finn Thain <fthain@telegraphics.com.au>
    Reviewed-by: Hannes Reinecke <hare@suse.com>
    Tested-by: Ondrej Zary <linux@rainbow-software.org>
    Tested-by: Michael Schmitz <schmitzmic@gmail.com>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/arm/cumana_1.c b/drivers/scsi/arm/cumana_1.c
index b526ba579ba3..221f18c5df93 100644
--- a/drivers/scsi/arm/cumana_1.c
+++ b/drivers/scsi/arm/cumana_1.c
@@ -209,6 +209,7 @@ static struct scsi_host_template cumanascsi_template = {
 	.use_clustering		= DISABLE_CLUSTERING,
 	.proc_name		= "CumanaSCSI-1",
 	.cmd_size		= NCR5380_CMD_SIZE,
+	.max_sectors		= 128,
 };
 
 static int cumanascsi1_probe(struct expansion_card *ec,

commit 32b26a104237c1ba3575a6c8d47e46060cc416fb
Author: Finn Thain <fthain@telegraphics.com.au>
Date:   Sun Jan 3 16:05:58 2016 +1100

    ncr5380: Use standard list data structure
    
    The NCR5380 drivers have a home-spun linked list implementation for
    scsi_cmnd structs that uses cmd->host_scribble as a 'next' pointer. Adopt
    the standard list_head data structure and list operations instead. Remove
    the eh_abort_handler rather than convert it. Doing the conversion would
    only be churn because the existing EH handlers don't work and get replaced
    in a subsequent patch.
    
    Signed-off-by: Finn Thain <fthain@telegraphics.com.au>
    Reviewed-by: Hannes Reinecke <hare@suse.com>
    Tested-by: Ondrej Zary <linux@rainbow-software.org>
    Tested-by: Michael Schmitz <schmitzmic@gmail.com>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/arm/cumana_1.c b/drivers/scsi/arm/cumana_1.c
index 921c982886ae..b526ba579ba3 100644
--- a/drivers/scsi/arm/cumana_1.c
+++ b/drivers/scsi/arm/cumana_1.c
@@ -208,6 +208,7 @@ static struct scsi_host_template cumanascsi_template = {
 	.cmd_per_lun		= 2,
 	.use_clustering		= DISABLE_CLUSTERING,
 	.proc_name		= "CumanaSCSI-1",
+	.cmd_size		= NCR5380_CMD_SIZE,
 };
 
 static int cumanascsi1_probe(struct expansion_card *ec,

commit 161c0059a2a80aefe7000d9ab7ce5c36e5463b5f
Author: Finn Thain <fthain@telegraphics.com.au>
Date:   Sun Jan 3 16:05:46 2016 +1100

    ncr5380: Cleanup #include directives
    
    Remove unused includes (stat.h, signal.h, proc_fs.h) and move includes
    needed by the core drivers into the common header (delay.h etc).
    
    Signed-off-by: Finn Thain <fthain@telegraphics.com.au>
    Reviewed-by: Hannes Reinecke <hare@suse.com>
    Tested-by: Ondrej Zary <linux@rainbow-software.org>
    Tested-by: Michael Schmitz <schmitzmic@gmail.com>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/arm/cumana_1.c b/drivers/scsi/arm/cumana_1.c
index f9fb8dabdbbd..921c982886ae 100644
--- a/drivers/scsi/arm/cumana_1.c
+++ b/drivers/scsi/arm/cumana_1.c
@@ -4,9 +4,7 @@
  * Copyright 1995-2002, Russell King
  */
 #include <linux/module.h>
-#include <linux/signal.h>
 #include <linux/ioport.h>
-#include <linux/delay.h>
 #include <linux/blkdev.h>
 #include <linux/init.h>
 
@@ -15,8 +13,6 @@
 
 #include <scsi/scsi_host.h>
 
-#include <scsi/scsicam.h>
-
 #define PSEUDO_DMA
 
 #define priv(host)			((struct NCR5380_hostdata *)(host)->hostdata)

commit ff3d4578840fd96a50558edf02ca0178b9ebb652
Author: Finn Thain <fthain@telegraphics.com.au>
Date:   Sun Jan 3 16:05:25 2016 +1100

    ncr5380: Implement NCR5380_dma_xfer_len and remove LIMIT_TRANSFERSIZE macro
    
    Follow the example of the atari_NCR5380.c core driver and adopt the
    NCR5380_dma_xfer_len() hook. Implement NCR5380_dma_xfer_len() for dtc.c
    and g_NCR5380.c to take care of the limitations of these cards. Keep the
    default for drivers using PSEUDO_DMA.
    
    Eliminate the unused macro LIMIT_TRANSFERSIZE.
    
    Signed-off-by: Finn Thain <fthain@telegraphics.com.au>
    Reviewed-by: Hannes Reinecke <hare@suse.com>
    Tested-by: Ondrej Zary <linux@rainbow-software.org>
    Tested-by: Michael Schmitz <schmitzmic@gmail.com>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/arm/cumana_1.c b/drivers/scsi/arm/cumana_1.c
index 0d0cb62b8cdb..f9fb8dabdbbd 100644
--- a/drivers/scsi/arm/cumana_1.c
+++ b/drivers/scsi/arm/cumana_1.c
@@ -22,6 +22,9 @@
 #define priv(host)			((struct NCR5380_hostdata *)(host)->hostdata)
 #define NCR5380_read(reg)		cumanascsi_read(instance, reg)
 #define NCR5380_write(reg, value)	cumanascsi_write(instance, reg, value)
+
+#define NCR5380_dma_xfer_len(instance, cmd, phase)	(cmd->transfersize)
+
 #define NCR5380_intr			cumanascsi_intr
 #define NCR5380_queue_command		cumanascsi_queue_command
 #define NCR5380_info			cumanascsi_info

commit 0ad0eff98fec3c940ec199047ff580abaaa5bb1a
Author: Finn Thain <fthain@telegraphics.com.au>
Date:   Sun Jan 3 16:05:21 2016 +1100

    ncr5380: Introduce unbound workqueue
    
    Allocate a work queue that will permit busy waiting and sleeping. This
    means NCR5380_init() can potentially fail, so add this error path.
    
    Signed-off-by: Finn Thain <fthain@telegraphics.com.au>
    Reviewed-by: Hannes Reinecke <hare@suse.com>
    Tested-by: Ondrej Zary <linux@rainbow-software.org>
    Tested-by: Michael Schmitz <schmitzmic@gmail.com>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/arm/cumana_1.c b/drivers/scsi/arm/cumana_1.c
index 3b5ff105f1d6..0d0cb62b8cdb 100644
--- a/drivers/scsi/arm/cumana_1.c
+++ b/drivers/scsi/arm/cumana_1.c
@@ -238,7 +238,9 @@ static int cumanascsi1_probe(struct expansion_card *ec,
 
 	host->irq = ec->irq;
 
-	NCR5380_init(host, 0);
+	ret = NCR5380_init(host, 0);
+	if (ret)
+		goto out_unmap;
 
 	NCR5380_maybe_reset_bus(host);
 
@@ -250,7 +252,7 @@ static int cumanascsi1_probe(struct expansion_card *ec,
 	if (ret) {
 		printk("scsi%d: IRQ%d not free: %d\n",
 		    host->host_no, host->irq, ret);
-		goto out_unmap;
+		goto out_exit;
 	}
 
 	ret = scsi_add_host(host, &ec->dev);
@@ -262,6 +264,8 @@ static int cumanascsi1_probe(struct expansion_card *ec,
 
  out_free_irq:
 	free_irq(host->irq, host);
+ out_exit:
+	NCR5380_exit(host);
  out_unmap:
 	iounmap(priv(host)->base);
 	iounmap(priv(host)->dma);

commit e52bbd5ccf53d2a73e524adb26b6d8a4f810ccb4
Author: Finn Thain <fthain@telegraphics.com.au>
Date:   Sun Jan 3 16:05:20 2016 +1100

    ncr5380: Cleanup bogus {request,release}_region() calls
    
    Commit 8b801ead3d7a ("[ARM] rpc: update Acorn SCSI drivers to modern ecard
    interfaces") neglected to remove a request_region() call in cumana_1.c.
    
    Commit eda32612f7b2 ("[PATCH] give all LLDD driver a ->release method") in
    history/history.git added some pointless release_region() calls in dtc.c,
    pas16.c and t128.c.
    
    Fix these issues.
    
    Signed-off-by: Finn Thain <fthain@telegraphics.com.au>
    Reviewed-by: Hannes Reinecke <hare@suse.com>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/arm/cumana_1.c b/drivers/scsi/arm/cumana_1.c
index c7dc65e39cdb..3b5ff105f1d6 100644
--- a/drivers/scsi/arm/cumana_1.c
+++ b/drivers/scsi/arm/cumana_1.c
@@ -245,12 +245,6 @@ static int cumanascsi1_probe(struct expansion_card *ec,
         priv(host)->ctrl = 0;
         writeb(0, priv(host)->base + CTRL);
 
-	host->n_io_port = 255;
-	if (!(request_region(host->io_port, host->n_io_port, "CumanaSCSI-1"))) {
-		ret = -EBUSY;
-		goto out_unmap;
-	}
-
 	ret = request_irq(host->irq, cumanascsi_intr, 0,
 			  "CumanaSCSI-1", host);
 	if (ret) {

commit b6488f97d3b5b602a066956e58a1ba282456d79b
Author: Finn Thain <fthain@telegraphics.com.au>
Date:   Sun Jan 3 16:05:08 2016 +1100

    ncr5380: Split NCR5380_init() into two functions
    
    This patch splits the NCR5380_init() function into two parts, similar
    to the scheme used with atari_NCR5380.c. This avoids two problems.
    
    Firstly, NCR5380_init() may perform a bus reset, which would cause the
    chip to assert IRQ. The chip is unable to mask its bus reset interrupt.
    Drivers can't call request_irq() before calling NCR5380_init(), because
    initialization must happen before the interrupt handler executes. If
    driver initialization causes an interrupt it may be problematic on some
    platforms. To avoid that, first move the bus reset code into
    NCR5380_maybe_reset_bus().
    
    Secondly, NCR5380_init() contains some board-specific interrupt setup code
    for the NCR53C400 that does not belong in the core driver. In moving this
    code, better not re-order interrupt initialization and bus reset. Again,
    the solution is to move the bus reset code into NCR5380_maybe_reset_bus().
    
    Signed-off-by: Finn Thain <fthain@telegraphics.com.au>
    Reviewed-by: Hannes Reinecke <hare@suse.com>
    Tested-by: Ondrej Zary <linux@rainbow-software.org>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/arm/cumana_1.c b/drivers/scsi/arm/cumana_1.c
index 8996a6ccc08f..c7dc65e39cdb 100644
--- a/drivers/scsi/arm/cumana_1.c
+++ b/drivers/scsi/arm/cumana_1.c
@@ -240,6 +240,8 @@ static int cumanascsi1_probe(struct expansion_card *ec,
 
 	NCR5380_init(host, 0);
 
+	NCR5380_maybe_reset_bus(host);
+
         priv(host)->ctrl = 0;
         writeb(0, priv(host)->base + CTRL);
 

commit 54d8fe4425c9d3fdf8473c1833c6807b61c6e70e
Author: Finn Thain <fthain@telegraphics.com.au>
Date:   Sun Jan 3 16:05:06 2016 +1100

    ncr5380: Remove NCR5380_local_declare and NCR5380_setup macros
    
    The NCR5380_local_declare and NCR5380_setup macros exist to define and
    initialize a particular local variable, to provide the address of the
    chip registers needed for the driver's implementation of its
    NCR5380_read/write register access macros.
    
    In cumana_1 and macscsi, these macros generate pointless code like this,
            struct Scsi_Host *_instance;
            _instance = instance;
    
    In pas16, the use of NCR5380_read/write in pas16_hw_detect() requires that
    the io_port local variable has been defined and initialized, but the
    NCR5380_local_declare and NCR5380_setup macros can't be used for that
    purpose because the Scsi_Host struct has not yet been instantiated.
    
    Moreover, these macros were removed from atari_NCR5380.c long ago and
    now they constitute yet another discrepancy between the two core driver
    forks.
    
    Remove these "optimizations".
    
    Signed-off-by: Finn Thain <fthain@telegraphics.com.au>
    Reviewed-by: Hannes Reinecke <hare@suse.com>
    Tested-by: Ondrej Zary <linux@rainbow-software.org>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/arm/cumana_1.c b/drivers/scsi/arm/cumana_1.c
index d28d6c0f18c0..8996a6ccc08f 100644
--- a/drivers/scsi/arm/cumana_1.c
+++ b/drivers/scsi/arm/cumana_1.c
@@ -20,10 +20,8 @@
 #define PSEUDO_DMA
 
 #define priv(host)			((struct NCR5380_hostdata *)(host)->hostdata)
-#define NCR5380_local_declare()		struct Scsi_Host *_instance
-#define NCR5380_setup(instance)		_instance = instance
-#define NCR5380_read(reg)		cumanascsi_read(_instance, reg)
-#define NCR5380_write(reg, value)	cumanascsi_write(_instance, reg, value)
+#define NCR5380_read(reg)		cumanascsi_read(instance, reg)
+#define NCR5380_write(reg, value)	cumanascsi_write(instance, reg, value)
 #define NCR5380_intr			cumanascsi_intr
 #define NCR5380_queue_command		cumanascsi_queue_command
 #define NCR5380_info			cumanascsi_info

commit 710ddd0d50d22b40e3b644ea35966489ad178978
Author: Finn Thain <fthain@telegraphics.com.au>
Date:   Wed Nov 12 16:12:02 2014 +1100

    ncr5380: Drop legacy scsi.h include
    
    Convert Scsi_Cmnd to struct scsi_cmnd and drop the #include "scsi.h".
    The sun3_NCR5380.c core driver already uses struct scsi_cmnd so converting
    the other core drivers reduces the diff which makes them easier to unify.
    
    Signed-off-by: Finn Thain <fthain@telegraphics.com.au>
    Reviewed-by: Hannes Reinecke <hare@suse.de>
    Tested-by: Michael Schmitz <schmitzmic@gmail.com>
    Signed-off-by: Christoph Hellwig <hch@lst.de>

diff --git a/drivers/scsi/arm/cumana_1.c b/drivers/scsi/arm/cumana_1.c
index 154c9fae255b..d28d6c0f18c0 100644
--- a/drivers/scsi/arm/cumana_1.c
+++ b/drivers/scsi/arm/cumana_1.c
@@ -13,7 +13,6 @@
 #include <asm/ecard.h>
 #include <asm/io.h>
 
-#include "../scsi.h"
 #include <scsi/scsi_host.h>
 
 #include <scsi/scsicam.h>

commit 96068e6b4d86a397f50ae401723f315110874e1a
Author: Finn Thain <fthain@telegraphics.com.au>
Date:   Wed Nov 12 16:12:01 2014 +1100

    ncr5380: Remove *_RELEASE macros
    
    The *_RELEASE macros don't tell me anything. In some cases the version in
    the macro contradicts the version in the comments. Anyway, the Linux kernel
    version is sufficient information. Remove these macros to improve readability.
    
    Signed-off-by: Finn Thain <fthain@telegraphics.com.au>
    Reviewed-by: Hannes Reinecke <hare@suse.de>
    Tested-by: Michael Schmitz <schmitzmic@gmail.com>
    Signed-off-by: Christoph Hellwig <hch@lst.de>

diff --git a/drivers/scsi/arm/cumana_1.c b/drivers/scsi/arm/cumana_1.c
index d3b96af3aa5c..154c9fae255b 100644
--- a/drivers/scsi/arm/cumana_1.c
+++ b/drivers/scsi/arm/cumana_1.c
@@ -20,8 +20,6 @@
 
 #define PSEUDO_DMA
 
-#define CUMANASCSI_PUBLIC_RELEASE 1
-
 #define priv(host)			((struct NCR5380_hostdata *)(host)->hostdata)
 #define NCR5380_local_declare()		struct Scsi_Host *_instance
 #define NCR5380_setup(instance)		_instance = instance

commit 8c32513bd395dc5d382e4883097482567cf8bbc5
Author: Finn Thain <fthain@telegraphics.com.au>
Date:   Wed Nov 12 16:11:58 2014 +1100

    ncr5380: Cleanup host info() methods
    
    If the host->info() method is not set, then host->name is used by default.
    For atari_scsi, that is exactly the same text. So remove the redundant
    info() method. Keep sun3_scsi.c in line with atari_scsi.
    
    Some NCR5380 drivers return an empty string from the info() method
    (arm/cumana_1.c arm/oak.c mac_scsi.c) while other drivers use the default
    (dmx3191d dtc.c g_NCR5380.c pas16.c t128.c).
    
    Implement a common info() method to replace a lot of duplicated code which
    the various drivers use to announce the same information.
    
    This replaces most of the (deprecated) show_info() output and all of the
    NCR5380_print_info() output. This also eliminates a bunch of code in
    g_NCR5380 which just duplicates functionality in the core driver.
    
    Signed-off-by: Finn Thain <fthain@telegraphics.com.au>
    Reviewed-by: Hannes Reinecke <hare@suse.de>
    Tested-by: Michael Schmitz <schmitzmic@gmail.com>
    Signed-off-by: Christoph Hellwig <hch@lst.de>

diff --git a/drivers/scsi/arm/cumana_1.c b/drivers/scsi/arm/cumana_1.c
index 8266039b60ee..d3b96af3aa5c 100644
--- a/drivers/scsi/arm/cumana_1.c
+++ b/drivers/scsi/arm/cumana_1.c
@@ -29,6 +29,7 @@
 #define NCR5380_write(reg, value)	cumanascsi_write(_instance, reg, value)
 #define NCR5380_intr			cumanascsi_intr
 #define NCR5380_queue_command		cumanascsi_queue_command
+#define NCR5380_info			cumanascsi_info
 
 #define NCR5380_implementation_fields	\
 	unsigned ctrl;			\
@@ -41,11 +42,6 @@ void cumanascsi_setup(char *str, int *ints)
 {
 }
 
-const char *cumanascsi_info(struct Scsi_Host *spnt)
-{
-	return "";
-}
-
 #define CTRL	0x16fc
 #define STAT	0x2004
 #define L(v)	(((v)<<16)|((v) & 0x0000ffff))
@@ -266,14 +262,6 @@ static int cumanascsi1_probe(struct expansion_card *ec,
 		goto out_unmap;
 	}
 
-	printk("scsi%d: at port 0x%08lx irq %d",
-		host->host_no, host->io_port, host->irq);
-	printk(" options CAN_QUEUE=%d CMD_PER_LUN=%d release=%d",
-		host->can_queue, host->cmd_per_lun, CUMANASCSI_PUBLIC_RELEASE);
-	printk("\nscsi%d:", host->host_no);
-	NCR5380_print_options(host);
-	printk("\n");
-
 	ret = scsi_add_host(host, &ec->dev);
 	if (ret)
 		goto out_free_irq;

commit 997acab7d593913eaa0606ff257079efcfcb146d
Author: Finn Thain <fthain@telegraphics.com.au>
Date:   Wed Nov 12 16:11:54 2014 +1100

    ncr5380: Remove redundant AUTOSENSE macro
    
    Every NCR5380 driver sets AUTOSENSE so it need not be optional (and the
    mid-layer expects it). Remove this redundant macro to improve readability.
    
    Signed-off-by: Finn Thain <fthain@telegraphics.com.au>
    Reviewed-by: Hannes Reinecke <hare@suse.de>
    Tested-by: Michael Schmitz <schmitzmic@gmail.com>
    Signed-off-by: Christoph Hellwig <hch@lst.de>

diff --git a/drivers/scsi/arm/cumana_1.c b/drivers/scsi/arm/cumana_1.c
index 8ef810a4476e..8266039b60ee 100644
--- a/drivers/scsi/arm/cumana_1.c
+++ b/drivers/scsi/arm/cumana_1.c
@@ -18,7 +18,6 @@
 
 #include <scsi/scsicam.h>
 
-#define AUTOSENSE
 #define PSEUDO_DMA
 
 #define CUMANASCSI_PUBLIC_RELEASE 1

commit d0d22efb634d6bb2dbbe0278471c015a71a832a4
Author: Finn Thain <fthain@telegraphics.com.au>
Date:   Tue Mar 18 11:42:13 2014 +1100

    scsi/NCR5380: remove unused BOARD_NORMAL and BOARD_NCR53C400
    
    BOARD_NORMAL is completely unused and BOARD_NCR53C400 is used only by
    g_NCR5380 internally. Remove the unused definitions.
    
    Signed-off-by: Finn Thain <fthain@telegraphics.com.au>
    Acked-by: Sam Creasey <sammy@sammy.net>
    Signed-off-by: Christoph Hellwig <hch@lst.de>

diff --git a/drivers/scsi/arm/cumana_1.c b/drivers/scsi/arm/cumana_1.c
index f8e060900052..8ef810a4476e 100644
--- a/drivers/scsi/arm/cumana_1.c
+++ b/drivers/scsi/arm/cumana_1.c
@@ -36,9 +36,6 @@
 	void __iomem *base;		\
 	void __iomem *dma
 
-#define BOARD_NORMAL	0
-#define BOARD_NCR53C400	1
-
 #include "../NCR5380.h"
 
 void cumanascsi_setup(char *str, int *ints)

commit 4909cc2b89715c2dfd4c466a37cc08b2b3890fed
Author: Michael Opdenacker <michael.opdenacker@free-electrons.com>
Date:   Wed Mar 5 06:09:41 2014 +0100

    [SCSI] remove deprecated IRQF_DISABLED from SCSI
    
    It's a NOOP since 2.6.35 and it will be removed one day.
    
    [jejb: remove from missed arm scsi drivers]
    Signed-off-by: Michael Opdenacker <michael.opdenacker@free-electrons.com>
    Signed-off-by: James Bottomley <JBottomley@Parallels.com>

diff --git a/drivers/scsi/arm/cumana_1.c b/drivers/scsi/arm/cumana_1.c
index b679778376c5..f8e060900052 100644
--- a/drivers/scsi/arm/cumana_1.c
+++ b/drivers/scsi/arm/cumana_1.c
@@ -262,7 +262,7 @@ static int cumanascsi1_probe(struct expansion_card *ec,
 		goto out_unmap;
 	}
 
-	ret = request_irq(host->irq, cumanascsi_intr, IRQF_DISABLED,
+	ret = request_irq(host->irq, cumanascsi_intr, 0,
 			  "CumanaSCSI-1", host);
 	if (ret) {
 		printk("scsi%d: IRQ%d not free: %d\n",

commit dd7ab71bb3b4dad7fa1c4fd89706d6870991cfe6
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Sun Mar 31 01:15:54 2013 -0400

    NCR5830: switch to ->show_info()
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/drivers/scsi/arm/cumana_1.c b/drivers/scsi/arm/cumana_1.c
index c93938b246d5..b679778376c5 100644
--- a/drivers/scsi/arm/cumana_1.c
+++ b/drivers/scsi/arm/cumana_1.c
@@ -30,7 +30,6 @@
 #define NCR5380_write(reg, value)	cumanascsi_write(_instance, reg, value)
 #define NCR5380_intr			cumanascsi_intr
 #define NCR5380_queue_command		cumanascsi_queue_command
-#define NCR5380_proc_info		cumanascsi_proc_info
 
 #define NCR5380_implementation_fields	\
 	unsigned ctrl;			\

commit 6f039790510fd630ff348efe8c4802dbaa041fba
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Fri Dec 21 13:08:55 2012 -0800

    Drivers: scsi: remove __dev* attributes.
    
    CONFIG_HOTPLUG is going away as an option.  As a result, the __dev*
    markings need to be removed.
    
    This change removes the use of __devinit, __devexit_p, __devinitdata,
    __devinitconst, and __devexit from these drivers.
    
    Based on patches originally written by Bill Pemberton, but redone by me
    in order to handle some of the coding style issues better, by hand.
    
    Cc: Bill Pemberton <wfp5p@virginia.edu>
    Cc: Adam Radford <linuxraid@lsi.com>
    Cc: "James E.J. Bottomley" <JBottomley@parallels.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/scsi/arm/cumana_1.c b/drivers/scsi/arm/cumana_1.c
index c3b99c93637a..c93938b246d5 100644
--- a/drivers/scsi/arm/cumana_1.c
+++ b/drivers/scsi/arm/cumana_1.c
@@ -225,8 +225,8 @@ static struct scsi_host_template cumanascsi_template = {
 	.proc_name		= "CumanaSCSI-1",
 };
 
-static int __devinit
-cumanascsi1_probe(struct expansion_card *ec, const struct ecard_id *id)
+static int cumanascsi1_probe(struct expansion_card *ec,
+			     const struct ecard_id *id)
 {
 	struct Scsi_Host *host;
 	int ret;
@@ -298,7 +298,7 @@ cumanascsi1_probe(struct expansion_card *ec, const struct ecard_id *id)
 	return ret;
 }
 
-static void __devexit cumanascsi1_remove(struct expansion_card *ec)
+static void cumanascsi1_remove(struct expansion_card *ec)
 {
 	struct Scsi_Host *host = ecard_get_drvdata(ec);
 
@@ -320,7 +320,7 @@ static const struct ecard_id cumanascsi1_cids[] = {
 
 static struct ecard_driver cumanascsi1_driver = {
 	.probe		= cumanascsi1_probe,
-	.remove		= __devexit_p(cumanascsi1_remove),
+	.remove		= cumanascsi1_remove,
 	.id_table	= cumanascsi1_cids,
 	.drv = {
 		.name		= "cumanascsi1",

commit 9ffc93f203c18a70623f21950f1dd473c9ec48cd
Author: David Howells <dhowells@redhat.com>
Date:   Wed Mar 28 18:30:03 2012 +0100

    Remove all #inclusions of asm/system.h
    
    Remove all #inclusions of asm/system.h preparatory to splitting and killing
    it.  Performed with the following command:
    
    perl -p -i -e 's!^#\s*include\s*<asm/system[.]h>.*\n!!' `grep -Irl '^#\s*include\s*<asm/system[.]h>' *`
    
    Signed-off-by: David Howells <dhowells@redhat.com>

diff --git a/drivers/scsi/arm/cumana_1.c b/drivers/scsi/arm/cumana_1.c
index a3398fe70a9c..c3b99c93637a 100644
--- a/drivers/scsi/arm/cumana_1.c
+++ b/drivers/scsi/arm/cumana_1.c
@@ -12,7 +12,6 @@
 
 #include <asm/ecard.h>
 #include <asm/io.h>
-#include <asm/system.h>
 
 #include "../scsi.h"
 #include <scsi/scsi_host.h>

commit 9924a781f3e746ba5aa54cf96ca462b8d0915221
Author: Andi Kleen <andi@firstfloor.org>
Date:   Mon Feb 25 00:35:21 2008 +0100

    [SCSI] Remove random noop unchecked_isa_dma users
    
    Lots of drivers set it to 0. Remove that. Patch should be a nop.
    
    Signed-off-by: Andi Kleen <ak@suse.de>
    Signed-off-by: James Bottomley <James.Bottomley@HansenPartnership.com>

diff --git a/drivers/scsi/arm/cumana_1.c b/drivers/scsi/arm/cumana_1.c
index 49d838e90a24..a3398fe70a9c 100644
--- a/drivers/scsi/arm/cumana_1.c
+++ b/drivers/scsi/arm/cumana_1.c
@@ -222,7 +222,6 @@ static struct scsi_host_template cumanascsi_template = {
 	.this_id		= 7,
 	.sg_tablesize		= SG_ALL,
 	.cmd_per_lun		= 2,
-	.unchecked_isa_dma	= 0,
 	.use_clustering		= DISABLE_CLUSTERING,
 	.proc_name		= "CumanaSCSI-1",
 };

commit 8b801ead3d7ab3cce991ea3a2d00c7336215fc7d
Author: Russell King <rmk@dyn-67.arm.linux.org.uk>
Date:   Fri Jul 20 10:38:54 2007 +0100

    [ARM] rpc: update Acorn SCSI drivers to modern ecard interfaces
    
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/drivers/scsi/arm/cumana_1.c b/drivers/scsi/arm/cumana_1.c
index cf9a21cea6d9..49d838e90a24 100644
--- a/drivers/scsi/arm/cumana_1.c
+++ b/drivers/scsi/arm/cumana_1.c
@@ -24,7 +24,7 @@
 
 #define CUMANASCSI_PUBLIC_RELEASE 1
 
-#define NCR5380_implementation_fields	int port, ctrl
+#define priv(host)			((struct NCR5380_hostdata *)(host)->hostdata)
 #define NCR5380_local_declare()		struct Scsi_Host *_instance
 #define NCR5380_setup(instance)		_instance = instance
 #define NCR5380_read(reg)		cumanascsi_read(_instance, reg)
@@ -33,6 +33,11 @@
 #define NCR5380_queue_command		cumanascsi_queue_command
 #define NCR5380_proc_info		cumanascsi_proc_info
 
+#define NCR5380_implementation_fields	\
+	unsigned ctrl;			\
+	void __iomem *base;		\
+	void __iomem *dma
+
 #define BOARD_NORMAL	0
 #define BOARD_NCR53C400	1
 
@@ -47,192 +52,162 @@ const char *cumanascsi_info(struct Scsi_Host *spnt)
 	return "";
 }
 
-#ifdef NOT_EFFICIENT
-#define CTRL(p,v)     outb(*ctrl = (v), (p) - 577)
-#define STAT(p)       inb((p)+1)
-#define IN(p)         inb((p))
-#define OUT(v,p)      outb((v), (p))
-#else
-#define CTRL(p,v)	(p[-2308] = (*ctrl = (v)))
-#define STAT(p)		(p[4])
-#define IN(p)		(*(p))
-#define IN2(p)		((unsigned short)(*(volatile unsigned long *)(p)))
-#define OUT(v,p)	(*(p) = (v))
-#define OUT2(v,p)	(*((volatile unsigned long *)(p)) = (v))
-#endif
-#define L(v)		(((v)<<16)|((v) & 0x0000ffff))
-#define H(v)		(((v)>>16)|((v) & 0xffff0000))
+#define CTRL	0x16fc
+#define STAT	0x2004
+#define L(v)	(((v)<<16)|((v) & 0x0000ffff))
+#define H(v)	(((v)>>16)|((v) & 0xffff0000))
 
 static inline int
-NCR5380_pwrite(struct Scsi_Host *instance, unsigned char *addr, int len)
+NCR5380_pwrite(struct Scsi_Host *host, unsigned char *addr, int len)
 {
-  int *ctrl = &((struct NCR5380_hostdata *)instance->hostdata)->ctrl;
-  int oldctrl = *ctrl;
   unsigned long *laddr;
-#ifdef NOT_EFFICIENT
-  int iobase = instance->io_port;
-  int dma_io = iobase & ~(0x3C0000>>2);
-#else
-  volatile unsigned char *iobase = (unsigned char *)ioaddr(instance->io_port);
-  volatile unsigned char *dma_io = (unsigned char *)((int)iobase & ~0x3C0000);
-#endif
+  void __iomem *dma = priv(host)->dma + 0x2000;
 
   if(!len) return 0;
 
-  CTRL(iobase, 0x02);
+  writeb(0x02, priv(host)->base + CTRL);
   laddr = (unsigned long *)addr;
   while(len >= 32)
   {
-    int status;
+    unsigned int status;
     unsigned long v;
-    status = STAT(iobase);
+    status = readb(priv(host)->base + STAT);
     if(status & 0x80)
       goto end;
     if(!(status & 0x40))
       continue;
-    v=*laddr++; OUT2(L(v),dma_io); OUT2(H(v),dma_io);
-    v=*laddr++; OUT2(L(v),dma_io); OUT2(H(v),dma_io);
-    v=*laddr++; OUT2(L(v),dma_io); OUT2(H(v),dma_io);
-    v=*laddr++; OUT2(L(v),dma_io); OUT2(H(v),dma_io);
-    v=*laddr++; OUT2(L(v),dma_io); OUT2(H(v),dma_io);
-    v=*laddr++; OUT2(L(v),dma_io); OUT2(H(v),dma_io);
-    v=*laddr++; OUT2(L(v),dma_io); OUT2(H(v),dma_io);
-    v=*laddr++; OUT2(L(v),dma_io); OUT2(H(v),dma_io);
+    v=*laddr++; writew(L(v), dma); writew(H(v), dma);
+    v=*laddr++; writew(L(v), dma); writew(H(v), dma);
+    v=*laddr++; writew(L(v), dma); writew(H(v), dma);
+    v=*laddr++; writew(L(v), dma); writew(H(v), dma);
+    v=*laddr++; writew(L(v), dma); writew(H(v), dma);
+    v=*laddr++; writew(L(v), dma); writew(H(v), dma);
+    v=*laddr++; writew(L(v), dma); writew(H(v), dma);
+    v=*laddr++; writew(L(v), dma); writew(H(v), dma);
     len -= 32;
     if(len == 0)
       break;
   }
 
   addr = (unsigned char *)laddr;
-  CTRL(iobase, 0x12);
+  writeb(0x12, priv(host)->base + CTRL);
+
   while(len > 0)
   {
-    int status;
-    status = STAT(iobase);
+    unsigned int status;
+    status = readb(priv(host)->base + STAT);
     if(status & 0x80)
       goto end;
     if(status & 0x40)
     {
-      OUT(*addr++, dma_io);
+      writeb(*addr++, dma);
       if(--len == 0)
         break;
     }
 
-    status = STAT(iobase);
+    status = readb(priv(host)->base + STAT);
     if(status & 0x80)
       goto end;
     if(status & 0x40)
     {
-      OUT(*addr++, dma_io);
+      writeb(*addr++, dma);
       if(--len == 0)
         break;
     }
   }
 end:
-  CTRL(iobase, oldctrl|0x40);
+  writeb(priv(host)->ctrl | 0x40, priv(host)->base + CTRL);
   return len;
 }
 
 static inline int
-NCR5380_pread(struct Scsi_Host *instance, unsigned char *addr, int len)
+NCR5380_pread(struct Scsi_Host *host, unsigned char *addr, int len)
 {
-  int *ctrl = &((struct NCR5380_hostdata *)instance->hostdata)->ctrl;
-  int oldctrl = *ctrl;
   unsigned long *laddr;
-#ifdef NOT_EFFICIENT
-  int iobase = instance->io_port;
-  int dma_io = iobase & ~(0x3C0000>>2);
-#else
-  volatile unsigned char *iobase = (unsigned char *)ioaddr(instance->io_port);
-  volatile unsigned char *dma_io = (unsigned char *)((int)iobase & ~0x3C0000);
-#endif
+  void __iomem *dma = priv(host)->dma + 0x2000;
 
   if(!len) return 0;
 
-  CTRL(iobase, 0x00);
+  writeb(0x00, priv(host)->base + CTRL);
   laddr = (unsigned long *)addr;
   while(len >= 32)
   {
-    int status;
-    status = STAT(iobase);
+    unsigned int status;
+    status = readb(priv(host)->base + STAT);
     if(status & 0x80)
       goto end;
     if(!(status & 0x40))
       continue;
-    *laddr++ = IN2(dma_io)|(IN2(dma_io)<<16);
-    *laddr++ = IN2(dma_io)|(IN2(dma_io)<<16);
-    *laddr++ = IN2(dma_io)|(IN2(dma_io)<<16);
-    *laddr++ = IN2(dma_io)|(IN2(dma_io)<<16);
-    *laddr++ = IN2(dma_io)|(IN2(dma_io)<<16);
-    *laddr++ = IN2(dma_io)|(IN2(dma_io)<<16);
-    *laddr++ = IN2(dma_io)|(IN2(dma_io)<<16);
-    *laddr++ = IN2(dma_io)|(IN2(dma_io)<<16);
+    *laddr++ = readw(dma) | (readw(dma) << 16);
+    *laddr++ = readw(dma) | (readw(dma) << 16);
+    *laddr++ = readw(dma) | (readw(dma) << 16);
+    *laddr++ = readw(dma) | (readw(dma) << 16);
+    *laddr++ = readw(dma) | (readw(dma) << 16);
+    *laddr++ = readw(dma) | (readw(dma) << 16);
+    *laddr++ = readw(dma) | (readw(dma) << 16);
+    *laddr++ = readw(dma) | (readw(dma) << 16);
     len -= 32;
     if(len == 0)
       break;
   }
 
   addr = (unsigned char *)laddr;
-  CTRL(iobase, 0x10);
+  writeb(0x10, priv(host)->base + CTRL);
+
   while(len > 0)
   {
-    int status;
-    status = STAT(iobase);
+    unsigned int status;
+    status = readb(priv(host)->base + STAT);
     if(status & 0x80)
       goto end;
     if(status & 0x40)
     {
-      *addr++ = IN(dma_io);
+      *addr++ = readb(dma);
       if(--len == 0)
         break;
     }
 
-    status = STAT(iobase);
+    status = readb(priv(host)->base + STAT);
     if(status & 0x80)
       goto end;
     if(status & 0x40)
     {
-      *addr++ = IN(dma_io);
+      *addr++ = readb(dma);
       if(--len == 0)
         break;
     }
   }
 end:
-  CTRL(iobase, oldctrl|0x40);
+  writeb(priv(host)->ctrl | 0x40, priv(host)->base + CTRL);
   return len;
 }
 
-#undef STAT
-#undef CTRL
-#undef IN
-#undef OUT
+static unsigned char cumanascsi_read(struct Scsi_Host *host, unsigned int reg)
+{
+	void __iomem *base = priv(host)->base;
+	unsigned char val;
 
-#define CTRL(p,v) outb(*ctrl = (v), (p) - 577)
+	writeb(0, base + CTRL);
 
-static char cumanascsi_read(struct Scsi_Host *instance, int reg)
-{
-	unsigned int iobase = instance->io_port;
-	int i;
-	int *ctrl = &((struct NCR5380_hostdata *)instance->hostdata)->ctrl;
+	val = readb(base + 0x2100 + (reg << 2));
 
-	CTRL(iobase, 0);
-	i = inb(iobase + 64 + reg);
-	CTRL(iobase, 0x40);
+	priv(host)->ctrl = 0x40;
+	writeb(0x40, base + CTRL);
 
-	return i;
+	return val;
 }
 
-static void cumanascsi_write(struct Scsi_Host *instance, int reg, int value)
+static void cumanascsi_write(struct Scsi_Host *host, unsigned int reg, unsigned int value)
 {
-	int iobase = instance->io_port;
-	int *ctrl = &((struct NCR5380_hostdata *)instance->hostdata)->ctrl;
+	void __iomem *base = priv(host)->base;
 
-	CTRL(iobase, 0);
-	outb(value, iobase + 64 + reg);
-	CTRL(iobase, 0x40);
-}
+	writeb(0, base + CTRL);
 
-#undef CTRL
+	writeb(value, base + 0x2100 + (reg << 2));
+
+	priv(host)->ctrl = 0x40;
+	writeb(0x40, base + CTRL);
+}
 
 #include "../NCR5380.c"
 
@@ -256,32 +231,46 @@ static int __devinit
 cumanascsi1_probe(struct expansion_card *ec, const struct ecard_id *id)
 {
 	struct Scsi_Host *host;
-	int ret = -ENOMEM;
+	int ret;
 
-	host = scsi_host_alloc(&cumanascsi_template, sizeof(struct NCR5380_hostdata));
-	if (!host)
+	ret = ecard_request_resources(ec);
+	if (ret)
 		goto out;
 
-        host->io_port = ecard_address(ec, ECARD_IOC, ECARD_SLOW) + 0x800;
+	host = scsi_host_alloc(&cumanascsi_template, sizeof(struct NCR5380_hostdata));
+	if (!host) {
+		ret = -ENOMEM;
+		goto out_release;
+	}
+
+	priv(host)->base = ioremap(ecard_resource_start(ec, ECARD_RES_IOCSLOW),
+				   ecard_resource_len(ec, ECARD_RES_IOCSLOW));
+	priv(host)->dma = ioremap(ecard_resource_start(ec, ECARD_RES_MEMC),
+				  ecard_resource_len(ec, ECARD_RES_MEMC));
+	if (!priv(host)->base || !priv(host)->dma) {
+		ret = -ENOMEM;
+		goto out_unmap;
+	}
+
 	host->irq = ec->irq;
 
 	NCR5380_init(host, 0);
 
+        priv(host)->ctrl = 0;
+        writeb(0, priv(host)->base + CTRL);
+
 	host->n_io_port = 255;
 	if (!(request_region(host->io_port, host->n_io_port, "CumanaSCSI-1"))) {
 		ret = -EBUSY;
-		goto out_free;
+		goto out_unmap;
 	}
 
-        ((struct NCR5380_hostdata *)host->hostdata)->ctrl = 0;
-        outb(0x00, host->io_port - 577);
-
 	ret = request_irq(host->irq, cumanascsi_intr, IRQF_DISABLED,
 			  "CumanaSCSI-1", host);
 	if (ret) {
 		printk("scsi%d: IRQ%d not free: %d\n",
 		    host->host_no, host->irq, ret);
-		goto out_release;
+		goto out_unmap;
 	}
 
 	printk("scsi%d: at port 0x%08lx irq %d",
@@ -301,10 +290,12 @@ cumanascsi1_probe(struct expansion_card *ec, const struct ecard_id *id)
 
  out_free_irq:
 	free_irq(host->irq, host);
- out_release:
-	release_region(host->io_port, host->n_io_port);
- out_free:
+ out_unmap:
+	iounmap(priv(host)->base);
+	iounmap(priv(host)->dma);
 	scsi_host_put(host);
+ out_release:
+	ecard_release_resources(ec);
  out:
 	return ret;
 }
@@ -318,8 +309,10 @@ static void __devexit cumanascsi1_remove(struct expansion_card *ec)
 	scsi_remove_host(host);
 	free_irq(host->irq, host);
 	NCR5380_exit(host);
-	release_region(host->io_port, host->n_io_port);
+	iounmap(priv(host)->base);
+	iounmap(priv(host)->dma);
 	scsi_host_put(host);
+	ecard_release_resources(ec);
 }
 
 static const struct ecard_id cumanascsi1_cids[] = {

commit cd354f1ae75e6466a7e31b727faede57a1f89ca5
Author: Tim Schmielau <tim@physik3.uni-rostock.de>
Date:   Wed Feb 14 00:33:14 2007 -0800

    [PATCH] remove many unneeded #includes of sched.h
    
    After Al Viro (finally) succeeded in removing the sched.h #include in module.h
    recently, it makes sense again to remove other superfluous sched.h includes.
    There are quite a lot of files which include it but don't actually need
    anything defined in there.  Presumably these includes were once needed for
    macros that used to live in sched.h, but moved to other header files in the
    course of cleaning it up.
    
    To ease the pain, this time I did not fiddle with any header files and only
    removed #includes from .c-files, which tend to cause less trouble.
    
    Compile tested against 2.6.20-rc2 and 2.6.20-rc2-mm2 (with offsets) on alpha,
    arm, i386, ia64, mips, powerpc, and x86_64 with allnoconfig, defconfig,
    allmodconfig, and allyesconfig as well as a few randconfigs on x86_64 and all
    configs in arch/arm/configs on arm.  I also checked that no new warnings were
    introduced by the patch (actually, some warnings are removed that were emitted
    by unnecessarily included header files).
    
    Signed-off-by: Tim Schmielau <tim@physik3.uni-rostock.de>
    Acked-by: Russell King <rmk+kernel@arm.linux.org.uk>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/scsi/arm/cumana_1.c b/drivers/scsi/arm/cumana_1.c
index 3bdfc36481ae..cf9a21cea6d9 100644
--- a/drivers/scsi/arm/cumana_1.c
+++ b/drivers/scsi/arm/cumana_1.c
@@ -5,7 +5,6 @@
  */
 #include <linux/module.h>
 #include <linux/signal.h>
-#include <linux/sched.h>
 #include <linux/ioport.h>
 #include <linux/delay.h>
 #include <linux/blkdev.h>

commit 1d6f359a2e06296418481239f8054a878f36e819
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Sat Jul 1 19:29:42 2006 -0700

    [PATCH] irq-flags: scsi: Use the new IRQF_ constants
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: Ingo Molnar <mingo@elte.hu>
    Cc: "David S. Miller" <davem@davemloft.net>
    Cc: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Cc: James Bottomley <James.Bottomley@steeleye.com>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/drivers/scsi/arm/cumana_1.c b/drivers/scsi/arm/cumana_1.c
index e6c9491dc5c0..3bdfc36481ae 100644
--- a/drivers/scsi/arm/cumana_1.c
+++ b/drivers/scsi/arm/cumana_1.c
@@ -277,7 +277,7 @@ cumanascsi1_probe(struct expansion_card *ec, const struct ecard_id *id)
         ((struct NCR5380_hostdata *)host->hostdata)->ctrl = 0;
         outb(0x00, host->io_port - 577);
 
-	ret = request_irq(host->irq, cumanascsi_intr, SA_INTERRUPT,
+	ret = request_irq(host->irq, cumanascsi_intr, IRQF_DISABLED,
 			  "CumanaSCSI-1", host);
 	if (ret) {
 		printk("scsi%d: IRQ%d not free: %d\n",

commit e9368f8288338c25d8a339c91b15e17ebf33752d
Author: Russell King <rmk@dyn-67.arm.linux.org.uk>
Date:   Mon Jan 9 13:56:42 2006 +0000

    [ARM] Remove asm/irq.h includes from ARM drivers
    
    Many ARM drivers do not need to include asm/irq.h - remove this
    unnecessary include from some ARM drivers.
    
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>

diff --git a/drivers/scsi/arm/cumana_1.c b/drivers/scsi/arm/cumana_1.c
index 81e266be26d0..e6c9491dc5c0 100644
--- a/drivers/scsi/arm/cumana_1.c
+++ b/drivers/scsi/arm/cumana_1.c
@@ -13,7 +13,6 @@
 
 #include <asm/ecard.h>
 #include <asm/io.h>
-#include <asm/irq.h>
 #include <asm/system.h>
 
 #include "../scsi.h"

commit d0be4a7d29ad0bd3ce2209dd9e46d410b632db59
Author: Christoph Hellwig <hch@lst.de>
Date:   Mon Oct 31 18:31:40 2005 +0100

    [SCSI] remove Scsi_Host_Template typedef
    
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>

diff --git a/drivers/scsi/arm/cumana_1.c b/drivers/scsi/arm/cumana_1.c
index 26498553a7cc..81e266be26d0 100644
--- a/drivers/scsi/arm/cumana_1.c
+++ b/drivers/scsi/arm/cumana_1.c
@@ -238,7 +238,7 @@ static void cumanascsi_write(struct Scsi_Host *instance, int reg, int value)
 
 #include "../NCR5380.c"
 
-static Scsi_Host_Template cumanascsi_template = {
+static struct scsi_host_template cumanascsi_template = {
 	.module			= THIS_MODULE,
 	.name			= "Cumana 16-bit SCSI",
 	.info			= cumanascsi_info,

commit 3471c288036bf0835a82d0b1bbce2002f6e68390
Author: Jeff Garzik <jgarzik@pobox.com>
Date:   Sat May 28 07:52:51 2005 -0400

    [SCSI] Remove no-op implementations of SCSI EH hooks
    
    Drivers need not implement a hook that returns FAILED, and does nothing
    else, since the SCSI midlayer code will do that for us.
    
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>

diff --git a/drivers/scsi/arm/cumana_1.c b/drivers/scsi/arm/cumana_1.c
index 27271bfc01d7..26498553a7cc 100644
--- a/drivers/scsi/arm/cumana_1.c
+++ b/drivers/scsi/arm/cumana_1.c
@@ -244,9 +244,7 @@ static Scsi_Host_Template cumanascsi_template = {
 	.info			= cumanascsi_info,
 	.queuecommand		= cumanascsi_queue_command,
 	.eh_abort_handler	= NCR5380_abort,
-	.eh_device_reset_handler= NCR5380_device_reset,
 	.eh_bus_reset_handler	= NCR5380_bus_reset,
-	.eh_host_reset_handler	= NCR5380_host_reset,
 	.can_queue		= 16,
 	.this_id		= 7,
 	.sg_tablesize		= SG_ALL,

commit 1da177e4c3f41524e886b7f1b8a0c1fc7321cac2
Author: Linus Torvalds <torvalds@ppc970.osdl.org>
Date:   Sat Apr 16 15:20:36 2005 -0700

    Linux-2.6.12-rc2
    
    Initial git repository build. I'm not bothering with the full history,
    even though we have it. We can create a separate "historical" git
    archive of that later if we want to, and in the meantime it's about
    3.2GB when imported into git - space that would just make the early
    git days unnecessarily complicated, when we don't have a lot of good
    infrastructure for it.
    
    Let it rip!

diff --git a/drivers/scsi/arm/cumana_1.c b/drivers/scsi/arm/cumana_1.c
new file mode 100644
index 000000000000..27271bfc01d7
--- /dev/null
+++ b/drivers/scsi/arm/cumana_1.c
@@ -0,0 +1,357 @@
+/*
+ * Generic Generic NCR5380 driver
+ *
+ * Copyright 1995-2002, Russell King
+ */
+#include <linux/module.h>
+#include <linux/signal.h>
+#include <linux/sched.h>
+#include <linux/ioport.h>
+#include <linux/delay.h>
+#include <linux/blkdev.h>
+#include <linux/init.h>
+
+#include <asm/ecard.h>
+#include <asm/io.h>
+#include <asm/irq.h>
+#include <asm/system.h>
+
+#include "../scsi.h"
+#include <scsi/scsi_host.h>
+
+#include <scsi/scsicam.h>
+
+#define AUTOSENSE
+#define PSEUDO_DMA
+
+#define CUMANASCSI_PUBLIC_RELEASE 1
+
+#define NCR5380_implementation_fields	int port, ctrl
+#define NCR5380_local_declare()		struct Scsi_Host *_instance
+#define NCR5380_setup(instance)		_instance = instance
+#define NCR5380_read(reg)		cumanascsi_read(_instance, reg)
+#define NCR5380_write(reg, value)	cumanascsi_write(_instance, reg, value)
+#define NCR5380_intr			cumanascsi_intr
+#define NCR5380_queue_command		cumanascsi_queue_command
+#define NCR5380_proc_info		cumanascsi_proc_info
+
+#define BOARD_NORMAL	0
+#define BOARD_NCR53C400	1
+
+#include "../NCR5380.h"
+
+void cumanascsi_setup(char *str, int *ints)
+{
+}
+
+const char *cumanascsi_info(struct Scsi_Host *spnt)
+{
+	return "";
+}
+
+#ifdef NOT_EFFICIENT
+#define CTRL(p,v)     outb(*ctrl = (v), (p) - 577)
+#define STAT(p)       inb((p)+1)
+#define IN(p)         inb((p))
+#define OUT(v,p)      outb((v), (p))
+#else
+#define CTRL(p,v)	(p[-2308] = (*ctrl = (v)))
+#define STAT(p)		(p[4])
+#define IN(p)		(*(p))
+#define IN2(p)		((unsigned short)(*(volatile unsigned long *)(p)))
+#define OUT(v,p)	(*(p) = (v))
+#define OUT2(v,p)	(*((volatile unsigned long *)(p)) = (v))
+#endif
+#define L(v)		(((v)<<16)|((v) & 0x0000ffff))
+#define H(v)		(((v)>>16)|((v) & 0xffff0000))
+
+static inline int
+NCR5380_pwrite(struct Scsi_Host *instance, unsigned char *addr, int len)
+{
+  int *ctrl = &((struct NCR5380_hostdata *)instance->hostdata)->ctrl;
+  int oldctrl = *ctrl;
+  unsigned long *laddr;
+#ifdef NOT_EFFICIENT
+  int iobase = instance->io_port;
+  int dma_io = iobase & ~(0x3C0000>>2);
+#else
+  volatile unsigned char *iobase = (unsigned char *)ioaddr(instance->io_port);
+  volatile unsigned char *dma_io = (unsigned char *)((int)iobase & ~0x3C0000);
+#endif
+
+  if(!len) return 0;
+
+  CTRL(iobase, 0x02);
+  laddr = (unsigned long *)addr;
+  while(len >= 32)
+  {
+    int status;
+    unsigned long v;
+    status = STAT(iobase);
+    if(status & 0x80)
+      goto end;
+    if(!(status & 0x40))
+      continue;
+    v=*laddr++; OUT2(L(v),dma_io); OUT2(H(v),dma_io);
+    v=*laddr++; OUT2(L(v),dma_io); OUT2(H(v),dma_io);
+    v=*laddr++; OUT2(L(v),dma_io); OUT2(H(v),dma_io);
+    v=*laddr++; OUT2(L(v),dma_io); OUT2(H(v),dma_io);
+    v=*laddr++; OUT2(L(v),dma_io); OUT2(H(v),dma_io);
+    v=*laddr++; OUT2(L(v),dma_io); OUT2(H(v),dma_io);
+    v=*laddr++; OUT2(L(v),dma_io); OUT2(H(v),dma_io);
+    v=*laddr++; OUT2(L(v),dma_io); OUT2(H(v),dma_io);
+    len -= 32;
+    if(len == 0)
+      break;
+  }
+
+  addr = (unsigned char *)laddr;
+  CTRL(iobase, 0x12);
+  while(len > 0)
+  {
+    int status;
+    status = STAT(iobase);
+    if(status & 0x80)
+      goto end;
+    if(status & 0x40)
+    {
+      OUT(*addr++, dma_io);
+      if(--len == 0)
+        break;
+    }
+
+    status = STAT(iobase);
+    if(status & 0x80)
+      goto end;
+    if(status & 0x40)
+    {
+      OUT(*addr++, dma_io);
+      if(--len == 0)
+        break;
+    }
+  }
+end:
+  CTRL(iobase, oldctrl|0x40);
+  return len;
+}
+
+static inline int
+NCR5380_pread(struct Scsi_Host *instance, unsigned char *addr, int len)
+{
+  int *ctrl = &((struct NCR5380_hostdata *)instance->hostdata)->ctrl;
+  int oldctrl = *ctrl;
+  unsigned long *laddr;
+#ifdef NOT_EFFICIENT
+  int iobase = instance->io_port;
+  int dma_io = iobase & ~(0x3C0000>>2);
+#else
+  volatile unsigned char *iobase = (unsigned char *)ioaddr(instance->io_port);
+  volatile unsigned char *dma_io = (unsigned char *)((int)iobase & ~0x3C0000);
+#endif
+
+  if(!len) return 0;
+
+  CTRL(iobase, 0x00);
+  laddr = (unsigned long *)addr;
+  while(len >= 32)
+  {
+    int status;
+    status = STAT(iobase);
+    if(status & 0x80)
+      goto end;
+    if(!(status & 0x40))
+      continue;
+    *laddr++ = IN2(dma_io)|(IN2(dma_io)<<16);
+    *laddr++ = IN2(dma_io)|(IN2(dma_io)<<16);
+    *laddr++ = IN2(dma_io)|(IN2(dma_io)<<16);
+    *laddr++ = IN2(dma_io)|(IN2(dma_io)<<16);
+    *laddr++ = IN2(dma_io)|(IN2(dma_io)<<16);
+    *laddr++ = IN2(dma_io)|(IN2(dma_io)<<16);
+    *laddr++ = IN2(dma_io)|(IN2(dma_io)<<16);
+    *laddr++ = IN2(dma_io)|(IN2(dma_io)<<16);
+    len -= 32;
+    if(len == 0)
+      break;
+  }
+
+  addr = (unsigned char *)laddr;
+  CTRL(iobase, 0x10);
+  while(len > 0)
+  {
+    int status;
+    status = STAT(iobase);
+    if(status & 0x80)
+      goto end;
+    if(status & 0x40)
+    {
+      *addr++ = IN(dma_io);
+      if(--len == 0)
+        break;
+    }
+
+    status = STAT(iobase);
+    if(status & 0x80)
+      goto end;
+    if(status & 0x40)
+    {
+      *addr++ = IN(dma_io);
+      if(--len == 0)
+        break;
+    }
+  }
+end:
+  CTRL(iobase, oldctrl|0x40);
+  return len;
+}
+
+#undef STAT
+#undef CTRL
+#undef IN
+#undef OUT
+
+#define CTRL(p,v) outb(*ctrl = (v), (p) - 577)
+
+static char cumanascsi_read(struct Scsi_Host *instance, int reg)
+{
+	unsigned int iobase = instance->io_port;
+	int i;
+	int *ctrl = &((struct NCR5380_hostdata *)instance->hostdata)->ctrl;
+
+	CTRL(iobase, 0);
+	i = inb(iobase + 64 + reg);
+	CTRL(iobase, 0x40);
+
+	return i;
+}
+
+static void cumanascsi_write(struct Scsi_Host *instance, int reg, int value)
+{
+	int iobase = instance->io_port;
+	int *ctrl = &((struct NCR5380_hostdata *)instance->hostdata)->ctrl;
+
+	CTRL(iobase, 0);
+	outb(value, iobase + 64 + reg);
+	CTRL(iobase, 0x40);
+}
+
+#undef CTRL
+
+#include "../NCR5380.c"
+
+static Scsi_Host_Template cumanascsi_template = {
+	.module			= THIS_MODULE,
+	.name			= "Cumana 16-bit SCSI",
+	.info			= cumanascsi_info,
+	.queuecommand		= cumanascsi_queue_command,
+	.eh_abort_handler	= NCR5380_abort,
+	.eh_device_reset_handler= NCR5380_device_reset,
+	.eh_bus_reset_handler	= NCR5380_bus_reset,
+	.eh_host_reset_handler	= NCR5380_host_reset,
+	.can_queue		= 16,
+	.this_id		= 7,
+	.sg_tablesize		= SG_ALL,
+	.cmd_per_lun		= 2,
+	.unchecked_isa_dma	= 0,
+	.use_clustering		= DISABLE_CLUSTERING,
+	.proc_name		= "CumanaSCSI-1",
+};
+
+static int __devinit
+cumanascsi1_probe(struct expansion_card *ec, const struct ecard_id *id)
+{
+	struct Scsi_Host *host;
+	int ret = -ENOMEM;
+
+	host = scsi_host_alloc(&cumanascsi_template, sizeof(struct NCR5380_hostdata));
+	if (!host)
+		goto out;
+
+        host->io_port = ecard_address(ec, ECARD_IOC, ECARD_SLOW) + 0x800;
+	host->irq = ec->irq;
+
+	NCR5380_init(host, 0);
+
+	host->n_io_port = 255;
+	if (!(request_region(host->io_port, host->n_io_port, "CumanaSCSI-1"))) {
+		ret = -EBUSY;
+		goto out_free;
+	}
+
+        ((struct NCR5380_hostdata *)host->hostdata)->ctrl = 0;
+        outb(0x00, host->io_port - 577);
+
+	ret = request_irq(host->irq, cumanascsi_intr, SA_INTERRUPT,
+			  "CumanaSCSI-1", host);
+	if (ret) {
+		printk("scsi%d: IRQ%d not free: %d\n",
+		    host->host_no, host->irq, ret);
+		goto out_release;
+	}
+
+	printk("scsi%d: at port 0x%08lx irq %d",
+		host->host_no, host->io_port, host->irq);
+	printk(" options CAN_QUEUE=%d CMD_PER_LUN=%d release=%d",
+		host->can_queue, host->cmd_per_lun, CUMANASCSI_PUBLIC_RELEASE);
+	printk("\nscsi%d:", host->host_no);
+	NCR5380_print_options(host);
+	printk("\n");
+
+	ret = scsi_add_host(host, &ec->dev);
+	if (ret)
+		goto out_free_irq;
+
+	scsi_scan_host(host);
+	goto out;
+
+ out_free_irq:
+	free_irq(host->irq, host);
+ out_release:
+	release_region(host->io_port, host->n_io_port);
+ out_free:
+	scsi_host_put(host);
+ out:
+	return ret;
+}
+
+static void __devexit cumanascsi1_remove(struct expansion_card *ec)
+{
+	struct Scsi_Host *host = ecard_get_drvdata(ec);
+
+	ecard_set_drvdata(ec, NULL);
+
+	scsi_remove_host(host);
+	free_irq(host->irq, host);
+	NCR5380_exit(host);
+	release_region(host->io_port, host->n_io_port);
+	scsi_host_put(host);
+}
+
+static const struct ecard_id cumanascsi1_cids[] = {
+	{ MANU_CUMANA, PROD_CUMANA_SCSI_1 },
+	{ 0xffff, 0xffff }
+};
+
+static struct ecard_driver cumanascsi1_driver = {
+	.probe		= cumanascsi1_probe,
+	.remove		= __devexit_p(cumanascsi1_remove),
+	.id_table	= cumanascsi1_cids,
+	.drv = {
+		.name		= "cumanascsi1",
+	},
+};
+
+static int __init cumanascsi_init(void)
+{
+	return ecard_register_driver(&cumanascsi1_driver);
+}
+
+static void __exit cumanascsi_exit(void)
+{
+	ecard_remove_driver(&cumanascsi1_driver);
+}
+
+module_init(cumanascsi_init);
+module_exit(cumanascsi_exit);
+
+MODULE_DESCRIPTION("Cumana SCSI-1 driver for Acorn machines");
+MODULE_LICENSE("GPL");
