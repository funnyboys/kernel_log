commit d2e993edbcaca293a62dcd8a357f2348c591811a
Author: Colin Ian King <colin.king@canonical.com>
Date:   Wed Jan 23 13:10:04 2019 +0000

    scsi: qlogicfas408: clean up a couple of indentation issues
    
    An if statement is indented correctly and an outb statement has a redundant
    empty comment and incorrect indentation. Fix these.
    
    Signed-off-by: Colin Ian King <colin.king@canonical.com>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/qlogicfas408.c b/drivers/scsi/qlogicfas408.c
index 8b471a925b43..136681ad18a5 100644
--- a/drivers/scsi/qlogicfas408.c
+++ b/drivers/scsi/qlogicfas408.c
@@ -139,7 +139,7 @@ static int ql_pdma(struct qlogicfas408_priv *priv, int phase, char *request, int
 	} else {		/* out */
 #if QL_TURBO_PDMA
 		rtrc(4)
-		    if (reqlen >= 128 && inb(qbase + 8) & 0x10) {	/* empty */
+		if (reqlen >= 128 && inb(qbase + 8) & 0x10) {	/* empty */
 			outsl(qbase + 4, request, 32);
 			reqlen -= 128;
 			request += 128;
@@ -240,7 +240,7 @@ static void ql_icmd(struct scsi_cmnd *cmd)
 	outb(0x40 | qlcfg8 | priv->qinitid, qbase + 8);
 	outb(qlcfg7, qbase + 7);
 	outb(qlcfg6, qbase + 6);
-	 /**/ outb(qlcfg5, qbase + 5);	/* select timer */
+	outb(qlcfg5, qbase + 5);	/* select timer */
 	outb(qlcfg9 & 7, qbase + 9);	/* prescaler */
 /*	outb(0x99, qbase + 5);	*/
 	outb(scmd_id(cmd), qbase + 4);

commit 4a56c1c166b6764f4fb389fbaca6acc75ea215d7
Author: Hannes Reinecke <hare@suse.com>
Date:   Fri Aug 25 13:57:11 2017 +0200

    scsi: qlogicfas: move bus_reset to host_reset
    
    The bus reset handler is really a host reset.
    
    Signed-off-by: Hannes Reinecke <hare@suse.com>
    Reviewed-by: Christoph Hellwig <hch@lst.de>
    Reviewed-by: Johannes Thumshirn <jthumshirn@suse.de>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/qlogicfas408.c b/drivers/scsi/qlogicfas408.c
index c3a9151ca823..8b471a925b43 100644
--- a/drivers/scsi/qlogicfas408.c
+++ b/drivers/scsi/qlogicfas408.c
@@ -496,13 +496,13 @@ int qlogicfas408_abort(struct scsi_cmnd *cmd)
 	return SUCCESS;
 }
 
-/* 
+/*
  *	Reset SCSI bus
  *	FIXME: This function is invoked with cmd = NULL directly by
  *	the PCMCIA qlogic_stub code. This wants fixing
  */
 
-int qlogicfas408_bus_reset(struct scsi_cmnd *cmd)
+int qlogicfas408_host_reset(struct scsi_cmnd *cmd)
 {
 	struct qlogicfas408_priv *priv = get_priv_by_cmd(cmd);
 	unsigned long flags;
@@ -607,7 +607,7 @@ module_exit(qlogicfas408_exit);
 EXPORT_SYMBOL(qlogicfas408_info);
 EXPORT_SYMBOL(qlogicfas408_queuecommand);
 EXPORT_SYMBOL(qlogicfas408_abort);
-EXPORT_SYMBOL(qlogicfas408_bus_reset);
+EXPORT_SYMBOL(qlogicfas408_host_reset);
 EXPORT_SYMBOL(qlogicfas408_biosparam);
 EXPORT_SYMBOL(qlogicfas408_ihandl);
 EXPORT_SYMBOL(qlogicfas408_get_chip_type);

commit f281233d3eba15fb225d21ae2e228fd4553d824a
Author: Jeff Garzik <jeff@garzik.org>
Date:   Tue Nov 16 02:10:29 2010 -0500

    SCSI host lock push-down
    
    Move the mid-layer's ->queuecommand() invocation from being locked
    with the host lock to being unlocked to facilitate speeding up the
    critical path for drivers who don't need this lock taken anyway.
    
    The patch below presents a simple SCSI host lock push-down as an
    equivalent transformation.  No locking or other behavior should change
    with this patch.  All existing bugs and locking orders are preserved.
    
    Additionally, add one parameter to queuecommand,
            struct Scsi_Host *
    and remove one parameter from queuecommand,
            void (*done)(struct scsi_cmnd *)
    
    Scsi_Host* is a convenient pointer that most host drivers need anyway,
    and 'done' is redundant to struct scsi_cmnd->scsi_done.
    
    Minimal code disturbance was attempted with this change.  Most drivers
    needed only two one-line modifications for their host lock push-down.
    
    Signed-off-by: Jeff Garzik <jgarzik@redhat.com>
    Acked-by: James Bottomley <James.Bottomley@suse.de>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/scsi/qlogicfas408.c b/drivers/scsi/qlogicfas408.c
index 1ad51552d6b1..c3a9151ca823 100644
--- a/drivers/scsi/qlogicfas408.c
+++ b/drivers/scsi/qlogicfas408.c
@@ -439,7 +439,7 @@ irqreturn_t qlogicfas408_ihandl(int irq, void *dev_id)
  *	Queued command
  */
 
-int qlogicfas408_queuecommand(struct scsi_cmnd *cmd,
+static int qlogicfas408_queuecommand_lck(struct scsi_cmnd *cmd,
 			      void (*done) (struct scsi_cmnd *))
 {
 	struct qlogicfas408_priv *priv = get_priv_by_cmd(cmd);
@@ -459,6 +459,8 @@ int qlogicfas408_queuecommand(struct scsi_cmnd *cmd,
 	return 0;
 }
 
+DEF_SCSI_QCMD(qlogicfas408_queuecommand)
+
 /* 
  *	Return bios parameters 
  */

commit fa195afe4ad3f6d85a9b7cc236ae85c05ca8db03
Author: Alan Cox <alan@lxorguk.ukuu.org.uk>
Date:   Mon Oct 27 15:16:36 2008 +0000

    [SCSI] Clean up my email address and use a single standard address for everything
    
    Signed-off-by: Alan Cox <alan@redhat.com>
    Signed-off-by: James Bottomley <James.Bottomley@HansenPartnership.com>

diff --git a/drivers/scsi/qlogicfas408.c b/drivers/scsi/qlogicfas408.c
index de7b3bc2cbc9..1ad51552d6b1 100644
--- a/drivers/scsi/qlogicfas408.c
+++ b/drivers/scsi/qlogicfas408.c
@@ -23,7 +23,7 @@
    Functions as standalone, loadable, and PCMCIA driver, the latter from
    Dave Hinds' PCMCIA package.
    
-   Cleaned up 26/10/2002 by Alan Cox <alan@redhat.com> as part of the 2.5
+   Cleaned up 26/10/2002 by Alan Cox <alan@lxorguk.ukuu.org.uk> as part of the 2.5
    SCSI driver cleanup and audit. This driver still needs work on the
    following
    	-	Non terminating hardware waits

commit 45711f1af6eff1a6d010703b4862e0d2b9afd056
Author: Jens Axboe <jens.axboe@oracle.com>
Date:   Mon Oct 22 21:19:53 2007 +0200

    [SG] Update drivers to use sg helpers
    
    Signed-off-by: Jens Axboe <jens.axboe@oracle.com>

diff --git a/drivers/scsi/qlogicfas408.c b/drivers/scsi/qlogicfas408.c
index 2bfbf26c00ed..de7b3bc2cbc9 100644
--- a/drivers/scsi/qlogicfas408.c
+++ b/drivers/scsi/qlogicfas408.c
@@ -317,7 +317,7 @@ static unsigned int ql_pcmd(struct scsi_cmnd *cmd)
 				return ((priv->qabort == 1 ?
 					 DID_ABORT : DID_RESET) << 16);
 			}
-			buf = page_address(sg->page) + sg->offset;
+			buf = sg_virt(sg);
 			if (ql_pdma(priv, phase, buf, sg->length))
 				break;
 		}

commit bc1ebfba1a3a27122462fd342d11216e3faea53f
Author: FUJITA Tomonori <fujita.tomonori@lab.ntt.co.jp>
Date:   Mon May 14 19:24:01 2007 +0900

    [SCSI] qlogicfas408: convert to use the data buffer accessors
    
    - remove the unnecessary map_single path.
    
    - convert to use the new accessors for the sg lists and the
    parameters.
    
    Jens Axboe <jens.axboe@oracle.com> did the for_each_sg cleanup.
    
    Signed-off-by: FUJITA Tomonori <fujita.tomonori@lab.ntt.co.jp>
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>

diff --git a/drivers/scsi/qlogicfas408.c b/drivers/scsi/qlogicfas408.c
index 2e7db18f5aef..2bfbf26c00ed 100644
--- a/drivers/scsi/qlogicfas408.c
+++ b/drivers/scsi/qlogicfas408.c
@@ -265,8 +265,6 @@ static unsigned int ql_pcmd(struct scsi_cmnd *cmd)
 	unsigned int message;	/* scsi returned message */
 	unsigned int phase;	/* recorded scsi phase */
 	unsigned int reqlen;	/* total length of transfer */
-	struct scatterlist *sglist;	/* scatter-gather list pointer */
-	unsigned int sgcount;	/* sg counter */
 	char *buf;
 	struct qlogicfas408_priv *priv = get_priv_by_cmd(cmd);
 	int qbase = priv->qbase;
@@ -301,9 +299,10 @@ static unsigned int ql_pcmd(struct scsi_cmnd *cmd)
 	if (inb(qbase + 7) & 0x1f)	/* if some bytes in fifo */
 		outb(1, qbase + 3);	/* clear fifo */
 	/* note that request_bufflen is the total xfer size when sg is used */
-	reqlen = cmd->request_bufflen;
+	reqlen = scsi_bufflen(cmd);
 	/* note that it won't work if transfers > 16M are requested */
 	if (reqlen && !((phase = inb(qbase + 4)) & 6)) {	/* data phase */
+		struct scatterlist *sg;
 		rtrc(2)
 		outb(reqlen, qbase);	/* low-mid xfer cnt */
 		outb(reqlen >> 8, qbase + 1);	/* low-mid xfer cnt */
@@ -311,23 +310,16 @@ static unsigned int ql_pcmd(struct scsi_cmnd *cmd)
 		outb(0x90, qbase + 3);	/* command do xfer */
 		/* PIO pseudo DMA to buffer or sglist */
 		REG1;
-		if (!cmd->use_sg)
-			ql_pdma(priv, phase, cmd->request_buffer,
-				cmd->request_bufflen);
-		else {
-			sgcount = cmd->use_sg;
-			sglist = cmd->request_buffer;
-			while (sgcount--) {
-				if (priv->qabort) {
-					REG0;
-					return ((priv->qabort == 1 ?
-						DID_ABORT : DID_RESET) << 16);
-				}
-				buf = page_address(sglist->page) + sglist->offset;
-				if (ql_pdma(priv, phase, buf, sglist->length))
-					break;
-				sglist++;
+
+		scsi_for_each_sg(cmd, sg, scsi_sg_count(cmd), i) {
+			if (priv->qabort) {
+				REG0;
+				return ((priv->qabort == 1 ?
+					 DID_ABORT : DID_RESET) << 16);
 			}
+			buf = page_address(sg->page) + sg->offset;
+			if (ql_pdma(priv, phase, buf, sg->length))
+				break;
 		}
 		REG0;
 		rtrc(2)

commit a24342b90c9c829fc5fea9ee01b127f81bca18ef
Author: Henne <henne@nachtwindheim.de>
Date:   Tue Oct 3 21:31:14 2006 +0200

    [SCSI] Scsi_Cmnd conversion in qlogicfas408 driver
    
    Change obsolete Scsi_Cmnd to struct scsi_cmnd in the Qlocic FAS408 driver.
    
    Signed-off-by: Henrik Kretzschmar <henne@nachtwindheim.de>
    
    rejections fixed and
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>

diff --git a/drivers/scsi/qlogicfas408.c b/drivers/scsi/qlogicfas408.c
index e0725353c99c..2e7db18f5aef 100644
--- a/drivers/scsi/qlogicfas408.c
+++ b/drivers/scsi/qlogicfas408.c
@@ -209,7 +209,7 @@ static int ql_wai(struct qlogicfas408_priv *priv)
  *	caller must hold host lock
  */
 
-static void ql_icmd(Scsi_Cmnd * cmd)
+static void ql_icmd(struct scsi_cmnd *cmd)
 {
 	struct qlogicfas408_priv *priv = get_priv_by_cmd(cmd);
 	int 	qbase = priv->qbase;
@@ -256,7 +256,7 @@ static void ql_icmd(Scsi_Cmnd * cmd)
  *	Process scsi command - usually after interrupt 
  */
 
-static unsigned int ql_pcmd(Scsi_Cmnd * cmd)
+static unsigned int ql_pcmd(struct scsi_cmnd *cmd)
 {
 	unsigned int i, j;
 	unsigned long k;
@@ -407,7 +407,7 @@ static unsigned int ql_pcmd(Scsi_Cmnd * cmd)
 
 static void ql_ihandl(void *dev_id)
 {
-	Scsi_Cmnd *icmd;
+	struct scsi_cmnd *icmd;
 	struct Scsi_Host *host = dev_id;
 	struct qlogicfas408_priv *priv = get_priv_by_host(host);
 	int qbase = priv->qbase;
@@ -447,7 +447,8 @@ irqreturn_t qlogicfas408_ihandl(int irq, void *dev_id)
  *	Queued command
  */
 
-int qlogicfas408_queuecommand(Scsi_Cmnd * cmd, void (*done) (Scsi_Cmnd *))
+int qlogicfas408_queuecommand(struct scsi_cmnd *cmd,
+			      void (*done) (struct scsi_cmnd *))
 {
 	struct qlogicfas408_priv *priv = get_priv_by_cmd(cmd);
 	if (scmd_id(cmd) == priv->qinitid) {
@@ -470,9 +471,8 @@ int qlogicfas408_queuecommand(Scsi_Cmnd * cmd, void (*done) (Scsi_Cmnd *))
  *	Return bios parameters 
  */
 
-int qlogicfas408_biosparam(struct scsi_device * disk,
-		        struct block_device *dev,
-			sector_t capacity, int ip[])
+int qlogicfas408_biosparam(struct scsi_device *disk, struct block_device *dev,
+			   sector_t capacity, int ip[])
 {
 /* This should mimic the DOS Qlogic driver's behavior exactly */
 	ip[0] = 0x40;
@@ -494,7 +494,7 @@ int qlogicfas408_biosparam(struct scsi_device * disk,
  *	Abort a command in progress
  */
  
-int qlogicfas408_abort(Scsi_Cmnd * cmd)
+int qlogicfas408_abort(struct scsi_cmnd *cmd)
 {
 	struct qlogicfas408_priv *priv = get_priv_by_cmd(cmd);
 	priv->qabort = 1;
@@ -508,7 +508,7 @@ int qlogicfas408_abort(Scsi_Cmnd * cmd)
  *	the PCMCIA qlogic_stub code. This wants fixing
  */
 
-int qlogicfas408_bus_reset(Scsi_Cmnd * cmd)
+int qlogicfas408_bus_reset(struct scsi_cmnd *cmd)
 {
 	struct qlogicfas408_priv *priv = get_priv_by_cmd(cmd);
 	unsigned long flags;

commit c7bec5aba52392aa8d675b8722735caf4a8b7265
Author: Jeff Garzik <jeff@garzik.org>
Date:   Fri Oct 6 15:00:58 2006 -0400

    Various drivers' irq handlers: kill dead code, needless casts
    
    - Eliminate casts to/from void*
    
    - Eliminate checks for conditions that never occur.  These typically
      fall into two classes:
    
            1) Checking for 'dev_id == NULL', then it is never called with
            NULL as an argument.
    
            2) Checking for invalid irq number, when the only caller (the
            system) guarantees the irq handler is called with the proper
            'irq' number argument.
    
    Signed-off-by: Jeff Garzik <jeff@garzik.org>

diff --git a/drivers/scsi/qlogicfas408.c b/drivers/scsi/qlogicfas408.c
index 1a7de3bd796f..e0725353c99c 100644
--- a/drivers/scsi/qlogicfas408.c
+++ b/drivers/scsi/qlogicfas408.c
@@ -405,10 +405,10 @@ static unsigned int ql_pcmd(Scsi_Cmnd * cmd)
  *	Interrupt handler 
  */
 
-static void ql_ihandl(int irq, void *dev_id)
+static void ql_ihandl(void *dev_id)
 {
 	Scsi_Cmnd *icmd;
-	struct Scsi_Host *host = (struct Scsi_Host *)dev_id;
+	struct Scsi_Host *host = dev_id;
 	struct qlogicfas408_priv *priv = get_priv_by_host(host);
 	int qbase = priv->qbase;
 	REG0;
@@ -438,7 +438,7 @@ irqreturn_t qlogicfas408_ihandl(int irq, void *dev_id)
 	struct Scsi_Host *host = dev_id;
 
 	spin_lock_irqsave(host->host_lock, flags);
-	ql_ihandl(irq, dev_id);
+	ql_ihandl(dev_id);
 	spin_unlock_irqrestore(host->host_lock, flags);
 	return IRQ_HANDLED;
 }

commit 7d12e780e003f93433d49ce78cfedf4b4c52adc5
Author: David Howells <dhowells@redhat.com>
Date:   Thu Oct 5 14:55:46 2006 +0100

    IRQ: Maintain regs pointer globally rather than passing to IRQ handlers
    
    Maintain a per-CPU global "struct pt_regs *" variable which can be used instead
    of passing regs around manually through all ~1800 interrupt handlers in the
    Linux kernel.
    
    The regs pointer is used in few places, but it potentially costs both stack
    space and code to pass it around.  On the FRV arch, removing the regs parameter
    from all the genirq function results in a 20% speed up of the IRQ exit path
    (ie: from leaving timer_interrupt() to leaving do_IRQ()).
    
    Where appropriate, an arch may override the generic storage facility and do
    something different with the variable.  On FRV, for instance, the address is
    maintained in GR28 at all times inside the kernel as part of general exception
    handling.
    
    Having looked over the code, it appears that the parameter may be handed down
    through up to twenty or so layers of functions.  Consider a USB character
    device attached to a USB hub, attached to a USB controller that posts its
    interrupts through a cascaded auxiliary interrupt controller.  A character
    device driver may want to pass regs to the sysrq handler through the input
    layer which adds another few layers of parameter passing.
    
    I've build this code with allyesconfig for x86_64 and i386.  I've runtested the
    main part of the code on FRV and i386, though I can't test most of the drivers.
    I've also done partial conversion for powerpc and MIPS - these at least compile
    with minimal configurations.
    
    This will affect all archs.  Mostly the changes should be relatively easy.
    Take do_IRQ(), store the regs pointer at the beginning, saving the old one:
    
            struct pt_regs *old_regs = set_irq_regs(regs);
    
    And put the old one back at the end:
    
            set_irq_regs(old_regs);
    
    Don't pass regs through to generic_handle_irq() or __do_IRQ().
    
    In timer_interrupt(), this sort of change will be necessary:
    
            -       update_process_times(user_mode(regs));
            -       profile_tick(CPU_PROFILING, regs);
            +       update_process_times(user_mode(get_irq_regs()));
            +       profile_tick(CPU_PROFILING);
    
    I'd like to move update_process_times()'s use of get_irq_regs() into itself,
    except that i386, alone of the archs, uses something other than user_mode().
    
    Some notes on the interrupt handling in the drivers:
    
     (*) input_dev() is now gone entirely.  The regs pointer is no longer stored in
         the input_dev struct.
    
     (*) finish_unlinks() in drivers/usb/host/ohci-q.c needs checking.  It does
         something different depending on whether it's been supplied with a regs
         pointer or not.
    
     (*) Various IRQ handler function pointers have been moved to type
         irq_handler_t.
    
    Signed-Off-By: David Howells <dhowells@redhat.com>
    (cherry picked from 1b16e7ac850969f38b375e511e3fa2f474a33867 commit)

diff --git a/drivers/scsi/qlogicfas408.c b/drivers/scsi/qlogicfas408.c
index 52fb2ec3da70..1a7de3bd796f 100644
--- a/drivers/scsi/qlogicfas408.c
+++ b/drivers/scsi/qlogicfas408.c
@@ -405,7 +405,7 @@ static unsigned int ql_pcmd(Scsi_Cmnd * cmd)
  *	Interrupt handler 
  */
 
-static void ql_ihandl(int irq, void *dev_id, struct pt_regs *regs)
+static void ql_ihandl(int irq, void *dev_id)
 {
 	Scsi_Cmnd *icmd;
 	struct Scsi_Host *host = (struct Scsi_Host *)dev_id;
@@ -432,13 +432,13 @@ static void ql_ihandl(int irq, void *dev_id, struct pt_regs *regs)
 	(icmd->scsi_done) (icmd);
 }
 
-irqreturn_t qlogicfas408_ihandl(int irq, void *dev_id, struct pt_regs *regs)
+irqreturn_t qlogicfas408_ihandl(int irq, void *dev_id)
 {
 	unsigned long flags;
 	struct Scsi_Host *host = dev_id;
 
 	spin_lock_irqsave(host->host_lock, flags);
-	ql_ihandl(irq, dev_id, regs);
+	ql_ihandl(irq, dev_id);
 	spin_unlock_irqrestore(host->host_lock, flags);
 	return IRQ_HANDLED;
 }

commit 422c0d61d591cbfb70f029e13505fb437e169d68
Author: Jeff Garzik <jgarzik@pobox.com>
Date:   Mon Oct 24 18:05:09 2005 -0400

    [SCSI] use scmd_id(), scmd_channel() throughout code
    
    Wrap a highly common idiom.  Makes the code easier to read, helps pave
    the way for sdev->{id,channel} removal, and adds a token that can easily
    by grepped-for in the future.
    
    There are a couple sdev_id() and scmd_printk() updates thrown in as well.
    
    Rejections fixed up and
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>

diff --git a/drivers/scsi/qlogicfas408.c b/drivers/scsi/qlogicfas408.c
index cb75e0b7baea..52fb2ec3da70 100644
--- a/drivers/scsi/qlogicfas408.c
+++ b/drivers/scsi/qlogicfas408.c
@@ -243,7 +243,7 @@ static void ql_icmd(Scsi_Cmnd * cmd)
 	 /**/ outb(qlcfg5, qbase + 5);	/* select timer */
 	outb(qlcfg9 & 7, qbase + 9);	/* prescaler */
 /*	outb(0x99, qbase + 5);	*/
-	outb(cmd->device->id, qbase + 4);
+	outb(scmd_id(cmd), qbase + 4);
 
 	for (i = 0; i < cmd->cmd_len; i++)
 		outb(cmd->cmnd[i], qbase + 2);
@@ -450,7 +450,7 @@ irqreturn_t qlogicfas408_ihandl(int irq, void *dev_id, struct pt_regs *regs)
 int qlogicfas408_queuecommand(Scsi_Cmnd * cmd, void (*done) (Scsi_Cmnd *))
 {
 	struct qlogicfas408_priv *priv = get_priv_by_cmd(cmd);
-	if (cmd->device->id == priv->qinitid) {
+	if (scmd_id(cmd) == priv->qinitid) {
 		cmd->result = DID_BAD_TARGET << 16;
 		done(cmd);
 		return 0;

commit 68b3aa7c9805aee9005a8ca53c5e99177961fbb9
Author: Jeff Garzik <jgarzik@pobox.com>
Date:   Sat May 28 07:56:31 2005 -0400

    [SCSI] allow sleeping in ->eh_bus_reset_handler()
    
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>

diff --git a/drivers/scsi/qlogicfas408.c b/drivers/scsi/qlogicfas408.c
index 575f8a8fcf34..cb75e0b7baea 100644
--- a/drivers/scsi/qlogicfas408.c
+++ b/drivers/scsi/qlogicfas408.c
@@ -511,8 +511,14 @@ int qlogicfas408_abort(Scsi_Cmnd * cmd)
 int qlogicfas408_bus_reset(Scsi_Cmnd * cmd)
 {
 	struct qlogicfas408_priv *priv = get_priv_by_cmd(cmd);
+	unsigned long flags;
+
 	priv->qabort = 2;
+
+	spin_lock_irqsave(cmd->device->host->host_lock, flags);
 	ql_zap(priv);
+	spin_unlock_irqrestore(cmd->device->host->host_lock, flags);
+
 	return SUCCESS;
 }
 

commit 3471c288036bf0835a82d0b1bbce2002f6e68390
Author: Jeff Garzik <jgarzik@pobox.com>
Date:   Sat May 28 07:52:51 2005 -0400

    [SCSI] Remove no-op implementations of SCSI EH hooks
    
    Drivers need not implement a hook that returns FAILED, and does nothing
    else, since the SCSI midlayer code will do that for us.
    
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>

diff --git a/drivers/scsi/qlogicfas408.c b/drivers/scsi/qlogicfas408.c
index 5b6ce0a88f08..575f8a8fcf34 100644
--- a/drivers/scsi/qlogicfas408.c
+++ b/drivers/scsi/qlogicfas408.c
@@ -516,24 +516,6 @@ int qlogicfas408_bus_reset(Scsi_Cmnd * cmd)
 	return SUCCESS;
 }
 
-/* 
- *	Reset SCSI host controller
- */
-
-int qlogicfas408_host_reset(Scsi_Cmnd * cmd)
-{
-	return FAILED;
-}
-
-/* 
- *	Reset SCSI device
- */
-
-int qlogicfas408_device_reset(Scsi_Cmnd * cmd)
-{
-	return FAILED;
-}
-
 /*
  *	Return info string
  */
@@ -626,8 +608,6 @@ EXPORT_SYMBOL(qlogicfas408_info);
 EXPORT_SYMBOL(qlogicfas408_queuecommand);
 EXPORT_SYMBOL(qlogicfas408_abort);
 EXPORT_SYMBOL(qlogicfas408_bus_reset);
-EXPORT_SYMBOL(qlogicfas408_device_reset);
-EXPORT_SYMBOL(qlogicfas408_host_reset);
 EXPORT_SYMBOL(qlogicfas408_biosparam);
 EXPORT_SYMBOL(qlogicfas408_ihandl);
 EXPORT_SYMBOL(qlogicfas408_get_chip_type);

commit 1da177e4c3f41524e886b7f1b8a0c1fc7321cac2
Author: Linus Torvalds <torvalds@ppc970.osdl.org>
Date:   Sat Apr 16 15:20:36 2005 -0700

    Linux-2.6.12-rc2
    
    Initial git repository build. I'm not bothering with the full history,
    even though we have it. We can create a separate "historical" git
    archive of that later if we want to, and in the meantime it's about
    3.2GB when imported into git - space that would just make the early
    git days unnecessarily complicated, when we don't have a lot of good
    infrastructure for it.
    
    Let it rip!

diff --git a/drivers/scsi/qlogicfas408.c b/drivers/scsi/qlogicfas408.c
new file mode 100644
index 000000000000..5b6ce0a88f08
--- /dev/null
+++ b/drivers/scsi/qlogicfas408.c
@@ -0,0 +1,637 @@
+/*----------------------------------------------------------------*/
+/*
+   Qlogic linux driver - work in progress. No Warranty express or implied.
+   Use at your own risk.  Support Tort Reform so you won't have to read all
+   these silly disclaimers.
+
+   Copyright 1994, Tom Zerucha.   
+   tz@execpc.com
+   
+   Additional Code, and much appreciated help by
+   Michael A. Griffith
+   grif@cs.ucr.edu
+
+   Thanks to Eric Youngdale and Dave Hinds for loadable module and PCMCIA
+   help respectively, and for suffering through my foolishness during the
+   debugging process.
+
+   Reference Qlogic FAS408 Technical Manual, 53408-510-00A, May 10, 1994
+   (you can reference it, but it is incomplete and inaccurate in places)
+
+   Version 0.46 1/30/97 - kernel 1.2.0+
+
+   Functions as standalone, loadable, and PCMCIA driver, the latter from
+   Dave Hinds' PCMCIA package.
+   
+   Cleaned up 26/10/2002 by Alan Cox <alan@redhat.com> as part of the 2.5
+   SCSI driver cleanup and audit. This driver still needs work on the
+   following
+   	-	Non terminating hardware waits
+   	-	Some layering violations with its pcmcia stub
+
+   Redistributable under terms of the GNU General Public License
+
+   For the avoidance of doubt the "preferred form" of this code is one which
+   is in an open non patent encumbered format. Where cryptographic key signing
+   forms part of the process of creating an executable the information
+   including keys needed to generate an equivalently functional executable
+   are deemed to be part of the source code.
+
+*/
+
+#include <linux/module.h>
+#include <linux/blkdev.h>		/* to get disk capacity */
+#include <linux/kernel.h>
+#include <linux/string.h>
+#include <linux/init.h>
+#include <linux/interrupt.h>
+#include <linux/ioport.h>
+#include <linux/proc_fs.h>
+#include <linux/unistd.h>
+#include <linux/spinlock.h>
+#include <linux/stat.h>
+
+#include <asm/io.h>
+#include <asm/irq.h>
+#include <asm/dma.h>
+
+#include "scsi.h"
+#include <scsi/scsi_host.h>
+#include "qlogicfas408.h"
+
+/*----------------------------------------------------------------*/
+static int qlcfg5 = (XTALFREQ << 5);	/* 15625/512 */
+static int qlcfg6 = SYNCXFRPD;
+static int qlcfg7 = SYNCOFFST;
+static int qlcfg8 = (SLOWCABLE << 7) | (QL_ENABLE_PARITY << 4);
+static int qlcfg9 = ((XTALFREQ + 4) / 5);
+static int qlcfgc = (FASTCLK << 3) | (FASTSCSI << 4);
+
+/*----------------------------------------------------------------*/
+
+/*----------------------------------------------------------------*/
+/* local functions */
+/*----------------------------------------------------------------*/
+
+/* error recovery - reset everything */
+
+static void ql_zap(struct qlogicfas408_priv *priv)
+{
+	int x;
+	int qbase = priv->qbase;
+	int int_type = priv->int_type;
+
+	x = inb(qbase + 0xd);
+	REG0;
+	outb(3, qbase + 3);	/* reset SCSI */
+	outb(2, qbase + 3);	/* reset chip */
+	if (x & 0x80)
+		REG1;
+}
+
+/*
+ *	Do a pseudo-dma tranfer
+ */
+ 
+static int ql_pdma(struct qlogicfas408_priv *priv, int phase, char *request, int reqlen)
+{
+	int j;
+	int qbase = priv->qbase;
+	j = 0;
+	if (phase & 1) {	/* in */
+#if QL_TURBO_PDMA
+		rtrc(4)
+		/* empty fifo in large chunks */
+		if (reqlen >= 128 && (inb(qbase + 8) & 2)) {	/* full */
+			insl(qbase + 4, request, 32);
+			reqlen -= 128;
+			request += 128;
+		}
+		while (reqlen >= 84 && !(j & 0xc0))	/* 2/3 */
+			if ((j = inb(qbase + 8)) & 4) 
+			{
+				insl(qbase + 4, request, 21);
+				reqlen -= 84;
+				request += 84;
+			}
+		if (reqlen >= 44 && (inb(qbase + 8) & 8)) {	/* 1/3 */
+			insl(qbase + 4, request, 11);
+			reqlen -= 44;
+			request += 44;
+		}
+#endif
+		/* until both empty and int (or until reclen is 0) */
+		rtrc(7)
+		j = 0;
+		while (reqlen && !((j & 0x10) && (j & 0xc0))) 
+		{
+			/* while bytes to receive and not empty */
+			j &= 0xc0;
+			while (reqlen && !((j = inb(qbase + 8)) & 0x10)) 
+			{
+				*request++ = inb(qbase + 4);
+				reqlen--;
+			}
+			if (j & 0x10)
+				j = inb(qbase + 8);
+
+		}
+	} else {		/* out */
+#if QL_TURBO_PDMA
+		rtrc(4)
+		    if (reqlen >= 128 && inb(qbase + 8) & 0x10) {	/* empty */
+			outsl(qbase + 4, request, 32);
+			reqlen -= 128;
+			request += 128;
+		}
+		while (reqlen >= 84 && !(j & 0xc0))	/* 1/3 */
+			if (!((j = inb(qbase + 8)) & 8)) {
+				outsl(qbase + 4, request, 21);
+				reqlen -= 84;
+				request += 84;
+			}
+		if (reqlen >= 40 && !(inb(qbase + 8) & 4)) {	/* 2/3 */
+			outsl(qbase + 4, request, 10);
+			reqlen -= 40;
+			request += 40;
+		}
+#endif
+		/* until full and int (or until reclen is 0) */
+		rtrc(7)
+		    j = 0;
+		while (reqlen && !((j & 2) && (j & 0xc0))) {
+			/* while bytes to send and not full */
+			while (reqlen && !((j = inb(qbase + 8)) & 2)) 
+			{
+				outb(*request++, qbase + 4);
+				reqlen--;
+			}
+			if (j & 2)
+				j = inb(qbase + 8);
+		}
+	}
+	/* maybe return reqlen */
+	return inb(qbase + 8) & 0xc0;
+}
+
+/*
+ *	Wait for interrupt flag (polled - not real hardware interrupt) 
+ */
+
+static int ql_wai(struct qlogicfas408_priv *priv)
+{
+	int k;
+	int qbase = priv->qbase;
+	unsigned long i;
+
+	k = 0;
+	i = jiffies + WATCHDOG;
+	while (time_before(jiffies, i) && !priv->qabort &&
+					!((k = inb(qbase + 4)) & 0xe0)) {
+		barrier();
+		cpu_relax();
+	}
+	if (time_after_eq(jiffies, i))
+		return (DID_TIME_OUT);
+	if (priv->qabort)
+		return (priv->qabort == 1 ? DID_ABORT : DID_RESET);
+	if (k & 0x60)
+		ql_zap(priv);
+	if (k & 0x20)
+		return (DID_PARITY);
+	if (k & 0x40)
+		return (DID_ERROR);
+	return 0;
+}
+
+/*
+ *	Initiate scsi command - queueing handler 
+ *	caller must hold host lock
+ */
+
+static void ql_icmd(Scsi_Cmnd * cmd)
+{
+	struct qlogicfas408_priv *priv = get_priv_by_cmd(cmd);
+	int 	qbase = priv->qbase;
+	int	int_type = priv->int_type;
+	unsigned int i;
+
+	priv->qabort = 0;
+
+	REG0;
+	/* clearing of interrupts and the fifo is needed */
+
+	inb(qbase + 5);		/* clear interrupts */
+	if (inb(qbase + 5))	/* if still interrupting */
+		outb(2, qbase + 3);	/* reset chip */
+	else if (inb(qbase + 7) & 0x1f)
+		outb(1, qbase + 3);	/* clear fifo */
+	while (inb(qbase + 5));	/* clear ints */
+	REG1;
+	outb(1, qbase + 8);	/* set for PIO pseudo DMA */
+	outb(0, qbase + 0xb);	/* disable ints */
+	inb(qbase + 8);		/* clear int bits */
+	REG0;
+	outb(0x40, qbase + 0xb);	/* enable features */
+
+	/* configurables */
+	outb(qlcfgc, qbase + 0xc);
+	/* config: no reset interrupt, (initiator) bus id */
+	outb(0x40 | qlcfg8 | priv->qinitid, qbase + 8);
+	outb(qlcfg7, qbase + 7);
+	outb(qlcfg6, qbase + 6);
+	 /**/ outb(qlcfg5, qbase + 5);	/* select timer */
+	outb(qlcfg9 & 7, qbase + 9);	/* prescaler */
+/*	outb(0x99, qbase + 5);	*/
+	outb(cmd->device->id, qbase + 4);
+
+	for (i = 0; i < cmd->cmd_len; i++)
+		outb(cmd->cmnd[i], qbase + 2);
+
+	priv->qlcmd = cmd;
+	outb(0x41, qbase + 3);	/* select and send command */
+}
+
+/*
+ *	Process scsi command - usually after interrupt 
+ */
+
+static unsigned int ql_pcmd(Scsi_Cmnd * cmd)
+{
+	unsigned int i, j;
+	unsigned long k;
+	unsigned int result;	/* ultimate return result */
+	unsigned int status;	/* scsi returned status */
+	unsigned int message;	/* scsi returned message */
+	unsigned int phase;	/* recorded scsi phase */
+	unsigned int reqlen;	/* total length of transfer */
+	struct scatterlist *sglist;	/* scatter-gather list pointer */
+	unsigned int sgcount;	/* sg counter */
+	char *buf;
+	struct qlogicfas408_priv *priv = get_priv_by_cmd(cmd);
+	int qbase = priv->qbase;
+	int int_type = priv->int_type;
+
+	rtrc(1)
+	j = inb(qbase + 6);
+	i = inb(qbase + 5);
+	if (i == 0x20) {
+		return (DID_NO_CONNECT << 16);
+	}
+	i |= inb(qbase + 5);	/* the 0x10 bit can be set after the 0x08 */
+	if (i != 0x18) {
+		printk(KERN_ERR "Ql:Bad Interrupt status:%02x\n", i);
+		ql_zap(priv);
+		return (DID_BAD_INTR << 16);
+	}
+	j &= 7;			/* j = inb( qbase + 7 ) >> 5; */
+
+	/* correct status is supposed to be step 4 */
+	/* it sometimes returns step 3 but with 0 bytes left to send */
+	/* We can try stuffing the FIFO with the max each time, but we will get a
+	   sequence of 3 if any bytes are left (but we do flush the FIFO anyway */
+
+	if (j != 3 && j != 4) {
+		printk(KERN_ERR "Ql:Bad sequence for command %d, int %02X, cmdleft = %d\n",
+		     j, i, inb(qbase + 7) & 0x1f);
+		ql_zap(priv);
+		return (DID_ERROR << 16);
+	}
+	result = DID_OK;
+	if (inb(qbase + 7) & 0x1f)	/* if some bytes in fifo */
+		outb(1, qbase + 3);	/* clear fifo */
+	/* note that request_bufflen is the total xfer size when sg is used */
+	reqlen = cmd->request_bufflen;
+	/* note that it won't work if transfers > 16M are requested */
+	if (reqlen && !((phase = inb(qbase + 4)) & 6)) {	/* data phase */
+		rtrc(2)
+		outb(reqlen, qbase);	/* low-mid xfer cnt */
+		outb(reqlen >> 8, qbase + 1);	/* low-mid xfer cnt */
+		outb(reqlen >> 16, qbase + 0xe);	/* high xfer cnt */
+		outb(0x90, qbase + 3);	/* command do xfer */
+		/* PIO pseudo DMA to buffer or sglist */
+		REG1;
+		if (!cmd->use_sg)
+			ql_pdma(priv, phase, cmd->request_buffer,
+				cmd->request_bufflen);
+		else {
+			sgcount = cmd->use_sg;
+			sglist = cmd->request_buffer;
+			while (sgcount--) {
+				if (priv->qabort) {
+					REG0;
+					return ((priv->qabort == 1 ?
+						DID_ABORT : DID_RESET) << 16);
+				}
+				buf = page_address(sglist->page) + sglist->offset;
+				if (ql_pdma(priv, phase, buf, sglist->length))
+					break;
+				sglist++;
+			}
+		}
+		REG0;
+		rtrc(2)
+		/*
+		 *	Wait for irq (split into second state of irq handler
+		 *	if this can take time) 
+		 */
+		if ((k = ql_wai(priv)))
+			return (k << 16);
+		k = inb(qbase + 5);	/* should be 0x10, bus service */
+	}
+
+	/*
+	 *	Enter Status (and Message In) Phase 
+	 */
+	 
+	k = jiffies + WATCHDOG;
+
+	while (time_before(jiffies, k) && !priv->qabort &&
+						!(inb(qbase + 4) & 6))
+		cpu_relax();	/* wait for status phase */
+
+	if (time_after_eq(jiffies, k)) {
+		ql_zap(priv);
+		return (DID_TIME_OUT << 16);
+	}
+
+	/* FIXME: timeout ?? */
+	while (inb(qbase + 5))
+		cpu_relax();	/* clear pending ints */
+
+	if (priv->qabort)
+		return ((priv->qabort == 1 ? DID_ABORT : DID_RESET) << 16);
+
+	outb(0x11, qbase + 3);	/* get status and message */
+	if ((k = ql_wai(priv)))
+		return (k << 16);
+	i = inb(qbase + 5);	/* get chip irq stat */
+	j = inb(qbase + 7) & 0x1f;	/* and bytes rec'd */
+	status = inb(qbase + 2);
+	message = inb(qbase + 2);
+
+	/*
+	 *	Should get function complete int if Status and message, else 
+	 *	bus serv if only status 
+	 */
+	if (!((i == 8 && j == 2) || (i == 0x10 && j == 1))) {
+		printk(KERN_ERR "Ql:Error during status phase, int=%02X, %d bytes recd\n", i, j);
+		result = DID_ERROR;
+	}
+	outb(0x12, qbase + 3);	/* done, disconnect */
+	rtrc(1)
+	if ((k = ql_wai(priv)))
+		return (k << 16);
+
+	/*
+	 *	Should get bus service interrupt and disconnect interrupt 
+	 */
+	 
+	i = inb(qbase + 5);	/* should be bus service */
+	while (!priv->qabort && ((i & 0x20) != 0x20)) {
+		barrier();
+		cpu_relax();
+		i |= inb(qbase + 5);
+	}
+	rtrc(0)
+
+	if (priv->qabort)
+		return ((priv->qabort == 1 ? DID_ABORT : DID_RESET) << 16);
+		
+	return (result << 16) | (message << 8) | (status & STATUS_MASK);
+}
+
+/*
+ *	Interrupt handler 
+ */
+
+static void ql_ihandl(int irq, void *dev_id, struct pt_regs *regs)
+{
+	Scsi_Cmnd *icmd;
+	struct Scsi_Host *host = (struct Scsi_Host *)dev_id;
+	struct qlogicfas408_priv *priv = get_priv_by_host(host);
+	int qbase = priv->qbase;
+	REG0;
+
+	if (!(inb(qbase + 4) & 0x80))	/* false alarm? */
+		return;
+
+	if (priv->qlcmd == NULL) {	/* no command to process? */
+		int i;
+		i = 16;
+		while (i-- && inb(qbase + 5));	/* maybe also ql_zap() */
+		return;
+	}
+	icmd = priv->qlcmd;
+	icmd->result = ql_pcmd(icmd);
+	priv->qlcmd = NULL;
+	/*
+	 *	If result is CHECK CONDITION done calls qcommand to request 
+	 *	sense 
+	 */
+	(icmd->scsi_done) (icmd);
+}
+
+irqreturn_t qlogicfas408_ihandl(int irq, void *dev_id, struct pt_regs *regs)
+{
+	unsigned long flags;
+	struct Scsi_Host *host = dev_id;
+
+	spin_lock_irqsave(host->host_lock, flags);
+	ql_ihandl(irq, dev_id, regs);
+	spin_unlock_irqrestore(host->host_lock, flags);
+	return IRQ_HANDLED;
+}
+
+/*
+ *	Queued command
+ */
+
+int qlogicfas408_queuecommand(Scsi_Cmnd * cmd, void (*done) (Scsi_Cmnd *))
+{
+	struct qlogicfas408_priv *priv = get_priv_by_cmd(cmd);
+	if (cmd->device->id == priv->qinitid) {
+		cmd->result = DID_BAD_TARGET << 16;
+		done(cmd);
+		return 0;
+	}
+
+	cmd->scsi_done = done;
+	/* wait for the last command's interrupt to finish */
+	while (priv->qlcmd != NULL) {
+		barrier();
+		cpu_relax();
+	}
+	ql_icmd(cmd);
+	return 0;
+}
+
+/* 
+ *	Return bios parameters 
+ */
+
+int qlogicfas408_biosparam(struct scsi_device * disk,
+		        struct block_device *dev,
+			sector_t capacity, int ip[])
+{
+/* This should mimic the DOS Qlogic driver's behavior exactly */
+	ip[0] = 0x40;
+	ip[1] = 0x20;
+	ip[2] = (unsigned long) capacity / (ip[0] * ip[1]);
+	if (ip[2] > 1024) {
+		ip[0] = 0xff;
+		ip[1] = 0x3f;
+		ip[2] = (unsigned long) capacity / (ip[0] * ip[1]);
+#if 0
+		if (ip[2] > 1023)
+			ip[2] = 1023;
+#endif
+	}
+	return 0;
+}
+
+/*
+ *	Abort a command in progress
+ */
+ 
+int qlogicfas408_abort(Scsi_Cmnd * cmd)
+{
+	struct qlogicfas408_priv *priv = get_priv_by_cmd(cmd);
+	priv->qabort = 1;
+	ql_zap(priv);
+	return SUCCESS;
+}
+
+/* 
+ *	Reset SCSI bus
+ *	FIXME: This function is invoked with cmd = NULL directly by
+ *	the PCMCIA qlogic_stub code. This wants fixing
+ */
+
+int qlogicfas408_bus_reset(Scsi_Cmnd * cmd)
+{
+	struct qlogicfas408_priv *priv = get_priv_by_cmd(cmd);
+	priv->qabort = 2;
+	ql_zap(priv);
+	return SUCCESS;
+}
+
+/* 
+ *	Reset SCSI host controller
+ */
+
+int qlogicfas408_host_reset(Scsi_Cmnd * cmd)
+{
+	return FAILED;
+}
+
+/* 
+ *	Reset SCSI device
+ */
+
+int qlogicfas408_device_reset(Scsi_Cmnd * cmd)
+{
+	return FAILED;
+}
+
+/*
+ *	Return info string
+ */
+
+const char *qlogicfas408_info(struct Scsi_Host *host)
+{
+	struct qlogicfas408_priv *priv = get_priv_by_host(host);
+	return priv->qinfo;
+}
+
+/*
+ *	Get type of chip
+ */
+
+int qlogicfas408_get_chip_type(int qbase, int int_type)
+{
+	REG1;
+	return inb(qbase + 0xe) & 0xf8;
+}
+
+/*
+ *	Perform initialization tasks
+ */
+
+void qlogicfas408_setup(int qbase, int id, int int_type)
+{
+	outb(1, qbase + 8);	/* set for PIO pseudo DMA */
+	REG0;
+	outb(0x40 | qlcfg8 | id, qbase + 8);	/* (ini) bus id, disable scsi rst */
+	outb(qlcfg5, qbase + 5);	/* select timer */
+	outb(qlcfg9, qbase + 9);	/* prescaler */
+
+#if QL_RESET_AT_START
+	outb(3, qbase + 3);
+
+	REG1;
+	/* FIXME: timeout */
+	while (inb(qbase + 0xf) & 4)
+		cpu_relax();
+
+	REG0;
+#endif
+}
+
+/*
+ *	Checks if this is a QLogic FAS 408
+ */
+
+int qlogicfas408_detect(int qbase, int int_type)
+{
+        REG1;
+	return (((inb(qbase + 0xe) ^ inb(qbase + 0xe)) == 7) &&
+	       ((inb(qbase + 0xe) ^ inb(qbase + 0xe)) == 7));		
+}
+
+/*
+ *	Disable interrupts
+ */
+
+void qlogicfas408_disable_ints(struct qlogicfas408_priv *priv)
+{
+	int qbase = priv->qbase;
+	int int_type = priv->int_type;
+
+	REG1;
+	outb(0, qbase + 0xb);	/* disable ints */
+}
+
+/*
+ *	Init and exit functions
+ */
+
+static int __init qlogicfas408_init(void)
+{
+	return 0;
+}
+
+static void __exit qlogicfas408_exit(void)
+{
+
+}
+
+MODULE_AUTHOR("Tom Zerucha, Michael Griffith");
+MODULE_DESCRIPTION("Driver for the Qlogic FAS SCSI controllers");
+MODULE_LICENSE("GPL");
+module_init(qlogicfas408_init);
+module_exit(qlogicfas408_exit);
+
+EXPORT_SYMBOL(qlogicfas408_info);
+EXPORT_SYMBOL(qlogicfas408_queuecommand);
+EXPORT_SYMBOL(qlogicfas408_abort);
+EXPORT_SYMBOL(qlogicfas408_bus_reset);
+EXPORT_SYMBOL(qlogicfas408_device_reset);
+EXPORT_SYMBOL(qlogicfas408_host_reset);
+EXPORT_SYMBOL(qlogicfas408_biosparam);
+EXPORT_SYMBOL(qlogicfas408_ihandl);
+EXPORT_SYMBOL(qlogicfas408_get_chip_type);
+EXPORT_SYMBOL(qlogicfas408_setup);
+EXPORT_SYMBOL(qlogicfas408_detect);
+EXPORT_SYMBOL(qlogicfas408_disable_ints);
+
