commit a10183d744fb4e3f8aa38086c2b5e6fdf0171a1a
Author: Christoph Hellwig <hch@lst.de>
Date:   Tue Mar 24 08:25:17 2020 +0100

    scsi: simplify scsi_partsize
    
    Call scsi_bios_ptable from scsi_partsize instead of requiring boilerplate
    code in the callers.  Also switch the calling convention to match that
    of the ->bios_param instances calling this function, and use true/false
    for the return value instead of the weird -1 convention.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Jens Axboe <axboe@kernel.dk>

diff --git a/drivers/scsi/megaraid.c b/drivers/scsi/megaraid.c
index ff6d4aa92421..f27ffd088c8a 100644
--- a/drivers/scsi/megaraid.c
+++ b/drivers/scsi/megaraid.c
@@ -2795,11 +2795,9 @@ megaraid_biosparam(struct scsi_device *sdev, struct block_device *bdev,
 		    sector_t capacity, int geom[])
 {
 	adapter_t	*adapter;
-	unsigned char	*bh;
 	int	heads;
 	int	sectors;
 	int	cylinders;
-	int	rval;
 
 	/* Get pointer to host config structure */
 	adapter = (adapter_t *)sdev->host->hostdata;
@@ -2826,15 +2824,8 @@ megaraid_biosparam(struct scsi_device *sdev, struct block_device *bdev,
 			geom[2] = cylinders;
 	}
 	else {
-		bh = scsi_bios_ptable(bdev);
-
-		if( bh ) {
-			rval = scsi_partsize(bh, capacity,
-					    &geom[2], &geom[0], &geom[1]);
-			kfree(bh);
-			if( rval != -1 )
-				return rval;
-		}
+		if (scsi_partsize(bdev, capacity, geom))
+			return 0;
 
 		dev_info(&adapter->dev->dev,
 			 "invalid partition on this disk on channel %d\n",

commit 70054aa39a013fa52eff432f2223b8bd5c0048f8
Author: Xiang Chen <chenxiang66@hisilicon.com>
Date:   Sat Sep 7 09:07:30 2019 +0800

    scsi: megaraid: disable device when probe failed after enabled device
    
    For pci device, need to disable device when probe failed after enabled
    device.
    
    Link: https://lore.kernel.org/r/1567818450-173315-1-git-send-email-chenxiang66@hisilicon.com
    Signed-off-by: Xiang Chen <chenxiang66@hisilicon.com>
    Reviewed-by: John Garry <john.garry@huawei.com>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/megaraid.c b/drivers/scsi/megaraid.c
index 45a66048801b..ff6d4aa92421 100644
--- a/drivers/scsi/megaraid.c
+++ b/drivers/scsi/megaraid.c
@@ -4183,11 +4183,11 @@ megaraid_probe_one(struct pci_dev *pdev, const struct pci_device_id *id)
 		 */
 		if (pdev->subsystem_vendor == PCI_VENDOR_ID_COMPAQ &&
 		    pdev->subsystem_device == 0xC000)
-		   	return -ENODEV;
+			goto out_disable_device;
 		/* Now check the magic signature byte */
 		pci_read_config_word(pdev, PCI_CONF_AMISIG, &magic);
 		if (magic != HBA_SIGNATURE_471 && magic != HBA_SIGNATURE)
-			return -ENODEV;
+			goto out_disable_device;
 		/* Ok it is probably a megaraid */
 	}
 

commit 2874c5fd284268364ece81a7bd936f3c8168e567
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Mon May 27 08:55:01 2019 +0200

    treewide: Replace GPLv2 boilerplate/reference with SPDX - rule 152
    
    Based on 1 normalized pattern(s):
    
      this program is free software you can redistribute it and or modify
      it under the terms of the gnu general public license as published by
      the free software foundation either version 2 of the license or at
      your option any later version
    
    extracted by the scancode license scanner the SPDX license identifier
    
      GPL-2.0-or-later
    
    has been chosen to replace the boilerplate/reference in 3029 file(s).
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Reviewed-by: Allison Randal <allison@lohutok.net>
    Cc: linux-spdx@vger.kernel.org
    Link: https://lkml.kernel.org/r/20190527070032.746973796@linutronix.de
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/scsi/megaraid.c b/drivers/scsi/megaraid.c
index 4862f65ec3e8..45a66048801b 100644
--- a/drivers/scsi/megaraid.c
+++ b/drivers/scsi/megaraid.c
@@ -1,14 +1,10 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
 /*
  *
  *			Linux MegaRAID device driver
  *
  * Copyright (c) 2002  LSI Logic Corporation.
  *
- *	   This program is free software; you can redistribute it and/or
- *	   modify it under the terms of the GNU General Public License
- *	   as published by the Free Software Foundation; either version
- *	   2 of the License, or (at your option) any later version.
- *
  * Copyright (c) 2002  Red Hat, Inc. All rights reserved.
  *	  - fixes
  *	  - speed-ups (list handling fixes, issued_list, optimizations.)
@@ -28,7 +24,6 @@
  * This driver is supported by LSI Logic, with assistance from Red Hat, Dell,
  * and others. Please send updates to the mailing list
  * linux-scsi@vger.kernel.org .
- *
  */
 
 #include <linux/mm.h>

commit 2a3d4eb8e228061c09d5ca8bf39e7f00c2091213
Author: Christoph Hellwig <hch@lst.de>
Date:   Thu Dec 13 16:17:02 2018 +0100

    scsi: flip the default on use_clustering
    
    Most SCSI drivers want to enable "clustering", that is merging of
    segments so that they might span more than a single page.  Remove the
    ENABLE_CLUSTERING define, and require drivers to explicitly set
    DISABLE_CLUSTERING to disable this feature.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/megaraid.c b/drivers/scsi/megaraid.c
index 8c7154143a4e..4862f65ec3e8 100644
--- a/drivers/scsi/megaraid.c
+++ b/drivers/scsi/megaraid.c
@@ -4148,7 +4148,6 @@ static struct scsi_host_template megaraid_template = {
 	.this_id			= DEFAULT_INITIATOR_ID,
 	.sg_tablesize			= MAX_SGLIST,
 	.cmd_per_lun			= DEF_CMD_PER_LUN,
-	.use_clustering			= ENABLE_CLUSTERING,
 	.eh_abort_handler		= megaraid_abort,
 	.eh_device_reset_handler	= megaraid_reset,
 	.eh_bus_reset_handler		= megaraid_reset,

commit 91ebc1facd7797d799a4c9208cb7fdc8d86e0bb4
Author: Johannes Thumshirn <jthumshirn@suse.de>
Date:   Wed Jun 13 09:53:47 2018 +0200

    scsi: core: remove Scsi_Cmnd typedef
    
    This will make subsequent refactoring easier to handle.
    
    Note: this patch is nowhere checkpatch clean.
    
    Signed-off-by: Johannes Thumshirn <jthumshirn@suse.de>
    Reviewed-by: Bart Van Assche <bart.vanassche@wdc.com>
    Reviewed-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/megaraid.c b/drivers/scsi/megaraid.c
index 8e8cf1145d7f..8c7154143a4e 100644
--- a/drivers/scsi/megaraid.c
+++ b/drivers/scsi/megaraid.c
@@ -371,7 +371,7 @@ mega_runpendq(adapter_t *adapter)
  * The command queuing entry point for the mid-layer.
  */
 static int
-megaraid_queue_lck(Scsi_Cmnd *scmd, void (*done)(Scsi_Cmnd *))
+megaraid_queue_lck(struct scsi_cmnd *scmd, void (*done)(struct scsi_cmnd *))
 {
 	adapter_t	*adapter;
 	scb_t	*scb;
@@ -425,7 +425,7 @@ static DEF_SCSI_QCMD(megaraid_queue)
  * commands.
  */
 static inline scb_t *
-mega_allocate_scb(adapter_t *adapter, Scsi_Cmnd *cmd)
+mega_allocate_scb(adapter_t *adapter, struct scsi_cmnd *cmd)
 {
 	struct list_head *head = &adapter->free_list;
 	scb_t	*scb;
@@ -457,7 +457,7 @@ mega_allocate_scb(adapter_t *adapter, Scsi_Cmnd *cmd)
  * and the channel number.
  */
 static inline int
-mega_get_ldrv_num(adapter_t *adapter, Scsi_Cmnd *cmd, int channel)
+mega_get_ldrv_num(adapter_t *adapter, struct scsi_cmnd *cmd, int channel)
 {
 	int		tgt;
 	int		ldrv_num;
@@ -520,7 +520,7 @@ mega_get_ldrv_num(adapter_t *adapter, Scsi_Cmnd *cmd, int channel)
  * boot settings.
  */
 static scb_t *
-mega_build_cmd(adapter_t *adapter, Scsi_Cmnd *cmd, int *busy)
+mega_build_cmd(adapter_t *adapter, struct scsi_cmnd *cmd, int *busy)
 {
 	mega_ext_passthru	*epthru;
 	mega_passthru	*pthru;
@@ -951,8 +951,8 @@ mega_build_cmd(adapter_t *adapter, Scsi_Cmnd *cmd, int *busy)
  * prepare a command for the scsi physical devices.
  */
 static mega_passthru *
-mega_prepare_passthru(adapter_t *adapter, scb_t *scb, Scsi_Cmnd *cmd,
-		int channel, int target)
+mega_prepare_passthru(adapter_t *adapter, scb_t *scb, struct scsi_cmnd *cmd,
+		      int channel, int target)
 {
 	mega_passthru *pthru;
 
@@ -1015,8 +1015,9 @@ mega_prepare_passthru(adapter_t *adapter, scb_t *scb, Scsi_Cmnd *cmd,
  * commands for devices which can take extended CDBs (>10 bytes)
  */
 static mega_ext_passthru *
-mega_prepare_extpassthru(adapter_t *adapter, scb_t *scb, Scsi_Cmnd *cmd,
-		int channel, int target)
+mega_prepare_extpassthru(adapter_t *adapter, scb_t *scb,
+			 struct scsi_cmnd *cmd,
+			 int channel, int target)
 {
 	mega_ext_passthru	*epthru;
 
@@ -1417,7 +1418,7 @@ mega_cmd_done(adapter_t *adapter, u8 completed[], int nstatus, int status)
 {
 	mega_ext_passthru	*epthru = NULL;
 	struct scatterlist	*sgl;
-	Scsi_Cmnd	*cmd = NULL;
+	struct scsi_cmnd	*cmd = NULL;
 	mega_passthru	*pthru = NULL;
 	mbox_t	*mbox = NULL;
 	u8	c;
@@ -1652,14 +1653,14 @@ mega_cmd_done(adapter_t *adapter, u8 completed[], int nstatus, int status)
 static void
 mega_rundoneq (adapter_t *adapter)
 {
-	Scsi_Cmnd *cmd;
+	struct scsi_cmnd *cmd;
 	struct list_head *pos;
 
 	list_for_each(pos, &adapter->completed_list) {
 
 		struct scsi_pointer* spos = (struct scsi_pointer *)pos;
 
-		cmd = list_entry(spos, Scsi_Cmnd, SCp);
+		cmd = list_entry(spos, struct scsi_cmnd, SCp);
 		cmd->scsi_done(cmd);
 	}
 
@@ -1722,7 +1723,7 @@ static int
 mega_build_sglist(adapter_t *adapter, scb_t *scb, u32 *buf, u32 *len)
 {
 	struct scatterlist *sg;
-	Scsi_Cmnd	*cmd;
+	struct scsi_cmnd	*cmd;
 	int	sgcnt;
 	int	idx;
 
@@ -1869,7 +1870,7 @@ megaraid_info(struct Scsi_Host *host)
  * aborted. All the commands issued to the F/W must complete.
  */
 static int
-megaraid_abort(Scsi_Cmnd *cmd)
+megaraid_abort(struct scsi_cmnd *cmd)
 {
 	adapter_t	*adapter;
 	int		rval;
@@ -1933,7 +1934,7 @@ megaraid_reset(struct scsi_cmnd *cmd)
  * issued to the controller, abort/reset it. Otherwise return failure
  */
 static int
-megaraid_abort_and_reset(adapter_t *adapter, Scsi_Cmnd *cmd, int aor)
+megaraid_abort_and_reset(adapter_t *adapter, struct scsi_cmnd *cmd, int aor)
 {
 	struct list_head	*pos, *next;
 	scb_t			*scb;

commit 6da2ec56059c3c7a7e5f729e6349e74ace1e5c57
Author: Kees Cook <keescook@chromium.org>
Date:   Tue Jun 12 13:55:00 2018 -0700

    treewide: kmalloc() -> kmalloc_array()
    
    The kmalloc() function has a 2-factor argument form, kmalloc_array(). This
    patch replaces cases of:
    
            kmalloc(a * b, gfp)
    
    with:
            kmalloc_array(a * b, gfp)
    
    as well as handling cases of:
    
            kmalloc(a * b * c, gfp)
    
    with:
    
            kmalloc(array3_size(a, b, c), gfp)
    
    as it's slightly less ugly than:
    
            kmalloc_array(array_size(a, b), c, gfp)
    
    This does, however, attempt to ignore constant size factors like:
    
            kmalloc(4 * 1024, gfp)
    
    though any constants defined via macros get caught up in the conversion.
    
    Any factors with a sizeof() of "unsigned char", "char", and "u8" were
    dropped, since they're redundant.
    
    The tools/ directory was manually excluded, since it has its own
    implementation of kmalloc().
    
    The Coccinelle script used for this was:
    
    // Fix redundant parens around sizeof().
    @@
    type TYPE;
    expression THING, E;
    @@
    
    (
      kmalloc(
    -       (sizeof(TYPE)) * E
    +       sizeof(TYPE) * E
      , ...)
    |
      kmalloc(
    -       (sizeof(THING)) * E
    +       sizeof(THING) * E
      , ...)
    )
    
    // Drop single-byte sizes and redundant parens.
    @@
    expression COUNT;
    typedef u8;
    typedef __u8;
    @@
    
    (
      kmalloc(
    -       sizeof(u8) * (COUNT)
    +       COUNT
      , ...)
    |
      kmalloc(
    -       sizeof(__u8) * (COUNT)
    +       COUNT
      , ...)
    |
      kmalloc(
    -       sizeof(char) * (COUNT)
    +       COUNT
      , ...)
    |
      kmalloc(
    -       sizeof(unsigned char) * (COUNT)
    +       COUNT
      , ...)
    |
      kmalloc(
    -       sizeof(u8) * COUNT
    +       COUNT
      , ...)
    |
      kmalloc(
    -       sizeof(__u8) * COUNT
    +       COUNT
      , ...)
    |
      kmalloc(
    -       sizeof(char) * COUNT
    +       COUNT
      , ...)
    |
      kmalloc(
    -       sizeof(unsigned char) * COUNT
    +       COUNT
      , ...)
    )
    
    // 2-factor product with sizeof(type/expression) and identifier or constant.
    @@
    type TYPE;
    expression THING;
    identifier COUNT_ID;
    constant COUNT_CONST;
    @@
    
    (
    - kmalloc
    + kmalloc_array
      (
    -       sizeof(TYPE) * (COUNT_ID)
    +       COUNT_ID, sizeof(TYPE)
      , ...)
    |
    - kmalloc
    + kmalloc_array
      (
    -       sizeof(TYPE) * COUNT_ID
    +       COUNT_ID, sizeof(TYPE)
      , ...)
    |
    - kmalloc
    + kmalloc_array
      (
    -       sizeof(TYPE) * (COUNT_CONST)
    +       COUNT_CONST, sizeof(TYPE)
      , ...)
    |
    - kmalloc
    + kmalloc_array
      (
    -       sizeof(TYPE) * COUNT_CONST
    +       COUNT_CONST, sizeof(TYPE)
      , ...)
    |
    - kmalloc
    + kmalloc_array
      (
    -       sizeof(THING) * (COUNT_ID)
    +       COUNT_ID, sizeof(THING)
      , ...)
    |
    - kmalloc
    + kmalloc_array
      (
    -       sizeof(THING) * COUNT_ID
    +       COUNT_ID, sizeof(THING)
      , ...)
    |
    - kmalloc
    + kmalloc_array
      (
    -       sizeof(THING) * (COUNT_CONST)
    +       COUNT_CONST, sizeof(THING)
      , ...)
    |
    - kmalloc
    + kmalloc_array
      (
    -       sizeof(THING) * COUNT_CONST
    +       COUNT_CONST, sizeof(THING)
      , ...)
    )
    
    // 2-factor product, only identifiers.
    @@
    identifier SIZE, COUNT;
    @@
    
    - kmalloc
    + kmalloc_array
      (
    -       SIZE * COUNT
    +       COUNT, SIZE
      , ...)
    
    // 3-factor product with 1 sizeof(type) or sizeof(expression), with
    // redundant parens removed.
    @@
    expression THING;
    identifier STRIDE, COUNT;
    type TYPE;
    @@
    
    (
      kmalloc(
    -       sizeof(TYPE) * (COUNT) * (STRIDE)
    +       array3_size(COUNT, STRIDE, sizeof(TYPE))
      , ...)
    |
      kmalloc(
    -       sizeof(TYPE) * (COUNT) * STRIDE
    +       array3_size(COUNT, STRIDE, sizeof(TYPE))
      , ...)
    |
      kmalloc(
    -       sizeof(TYPE) * COUNT * (STRIDE)
    +       array3_size(COUNT, STRIDE, sizeof(TYPE))
      , ...)
    |
      kmalloc(
    -       sizeof(TYPE) * COUNT * STRIDE
    +       array3_size(COUNT, STRIDE, sizeof(TYPE))
      , ...)
    |
      kmalloc(
    -       sizeof(THING) * (COUNT) * (STRIDE)
    +       array3_size(COUNT, STRIDE, sizeof(THING))
      , ...)
    |
      kmalloc(
    -       sizeof(THING) * (COUNT) * STRIDE
    +       array3_size(COUNT, STRIDE, sizeof(THING))
      , ...)
    |
      kmalloc(
    -       sizeof(THING) * COUNT * (STRIDE)
    +       array3_size(COUNT, STRIDE, sizeof(THING))
      , ...)
    |
      kmalloc(
    -       sizeof(THING) * COUNT * STRIDE
    +       array3_size(COUNT, STRIDE, sizeof(THING))
      , ...)
    )
    
    // 3-factor product with 2 sizeof(variable), with redundant parens removed.
    @@
    expression THING1, THING2;
    identifier COUNT;
    type TYPE1, TYPE2;
    @@
    
    (
      kmalloc(
    -       sizeof(TYPE1) * sizeof(TYPE2) * COUNT
    +       array3_size(COUNT, sizeof(TYPE1), sizeof(TYPE2))
      , ...)
    |
      kmalloc(
    -       sizeof(TYPE1) * sizeof(THING2) * (COUNT)
    +       array3_size(COUNT, sizeof(TYPE1), sizeof(TYPE2))
      , ...)
    |
      kmalloc(
    -       sizeof(THING1) * sizeof(THING2) * COUNT
    +       array3_size(COUNT, sizeof(THING1), sizeof(THING2))
      , ...)
    |
      kmalloc(
    -       sizeof(THING1) * sizeof(THING2) * (COUNT)
    +       array3_size(COUNT, sizeof(THING1), sizeof(THING2))
      , ...)
    |
      kmalloc(
    -       sizeof(TYPE1) * sizeof(THING2) * COUNT
    +       array3_size(COUNT, sizeof(TYPE1), sizeof(THING2))
      , ...)
    |
      kmalloc(
    -       sizeof(TYPE1) * sizeof(THING2) * (COUNT)
    +       array3_size(COUNT, sizeof(TYPE1), sizeof(THING2))
      , ...)
    )
    
    // 3-factor product, only identifiers, with redundant parens removed.
    @@
    identifier STRIDE, SIZE, COUNT;
    @@
    
    (
      kmalloc(
    -       (COUNT) * STRIDE * SIZE
    +       array3_size(COUNT, STRIDE, SIZE)
      , ...)
    |
      kmalloc(
    -       COUNT * (STRIDE) * SIZE
    +       array3_size(COUNT, STRIDE, SIZE)
      , ...)
    |
      kmalloc(
    -       COUNT * STRIDE * (SIZE)
    +       array3_size(COUNT, STRIDE, SIZE)
      , ...)
    |
      kmalloc(
    -       (COUNT) * (STRIDE) * SIZE
    +       array3_size(COUNT, STRIDE, SIZE)
      , ...)
    |
      kmalloc(
    -       COUNT * (STRIDE) * (SIZE)
    +       array3_size(COUNT, STRIDE, SIZE)
      , ...)
    |
      kmalloc(
    -       (COUNT) * STRIDE * (SIZE)
    +       array3_size(COUNT, STRIDE, SIZE)
      , ...)
    |
      kmalloc(
    -       (COUNT) * (STRIDE) * (SIZE)
    +       array3_size(COUNT, STRIDE, SIZE)
      , ...)
    |
      kmalloc(
    -       COUNT * STRIDE * SIZE
    +       array3_size(COUNT, STRIDE, SIZE)
      , ...)
    )
    
    // Any remaining multi-factor products, first at least 3-factor products,
    // when they're not all constants...
    @@
    expression E1, E2, E3;
    constant C1, C2, C3;
    @@
    
    (
      kmalloc(C1 * C2 * C3, ...)
    |
      kmalloc(
    -       (E1) * E2 * E3
    +       array3_size(E1, E2, E3)
      , ...)
    |
      kmalloc(
    -       (E1) * (E2) * E3
    +       array3_size(E1, E2, E3)
      , ...)
    |
      kmalloc(
    -       (E1) * (E2) * (E3)
    +       array3_size(E1, E2, E3)
      , ...)
    |
      kmalloc(
    -       E1 * E2 * E3
    +       array3_size(E1, E2, E3)
      , ...)
    )
    
    // And then all remaining 2 factors products when they're not all constants,
    // keeping sizeof() as the second factor argument.
    @@
    expression THING, E1, E2;
    type TYPE;
    constant C1, C2, C3;
    @@
    
    (
      kmalloc(sizeof(THING) * C2, ...)
    |
      kmalloc(sizeof(TYPE) * C2, ...)
    |
      kmalloc(C1 * C2 * C3, ...)
    |
      kmalloc(C1 * C2, ...)
    |
    - kmalloc
    + kmalloc_array
      (
    -       sizeof(TYPE) * (E2)
    +       E2, sizeof(TYPE)
      , ...)
    |
    - kmalloc
    + kmalloc_array
      (
    -       sizeof(TYPE) * E2
    +       E2, sizeof(TYPE)
      , ...)
    |
    - kmalloc
    + kmalloc_array
      (
    -       sizeof(THING) * (E2)
    +       E2, sizeof(THING)
      , ...)
    |
    - kmalloc
    + kmalloc_array
      (
    -       sizeof(THING) * E2
    +       E2, sizeof(THING)
      , ...)
    |
    - kmalloc
    + kmalloc_array
      (
    -       (E1) * E2
    +       E1, E2
      , ...)
    |
    - kmalloc
    + kmalloc_array
      (
    -       (E1) * (E2)
    +       E1, E2
      , ...)
    |
    - kmalloc
    + kmalloc_array
      (
    -       E1 * E2
    +       E1, E2
      , ...)
    )
    
    Signed-off-by: Kees Cook <keescook@chromium.org>

diff --git a/drivers/scsi/megaraid.c b/drivers/scsi/megaraid.c
index 3b3767e240d8..8e8cf1145d7f 100644
--- a/drivers/scsi/megaraid.c
+++ b/drivers/scsi/megaraid.c
@@ -4292,7 +4292,8 @@ megaraid_probe_one(struct pci_dev *pdev, const struct pci_device_id *id)
 		goto out_host_put;
 	}
 
-	adapter->scb_list = kmalloc(sizeof(scb_t) * MAX_COMMANDS, GFP_KERNEL);
+	adapter->scb_list = kmalloc_array(MAX_COMMANDS, sizeof(scb_t),
+					  GFP_KERNEL);
 	if (!adapter->scb_list) {
 		dev_warn(&pdev->dev, "out of RAM\n");
 		goto out_free_cmd_buffer;

commit 5f85942c2ea2ed59d8f19c954bbb0f5c1a2ebdd1
Merge: 0c14e43a42e4 1b5c2cb19668
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sun Jun 10 13:01:12 2018 -0700

    Merge tag 'scsi-misc' of git://git.kernel.org/pub/scm/linux/kernel/git/jejb/scsi
    
    Pull SCSI updates from James Bottomley:
     "This is mostly updates to the usual drivers: ufs, qedf, mpt3sas, lpfc,
      xfcp, hisi_sas, cxlflash, qla2xxx.
    
      In the absence of Nic, we're also taking target updates which are
      mostly minor except for the tcmu refactor.
    
      The only real core change to worry about is the removal of high page
      bouncing (in sas, storvsc and iscsi). This has been well tested and no
      problems have shown up so far"
    
    * tag 'scsi-misc' of git://git.kernel.org/pub/scm/linux/kernel/git/jejb/scsi: (268 commits)
      scsi: lpfc: update driver version to 12.0.0.4
      scsi: lpfc: Fix port initialization failure.
      scsi: lpfc: Fix 16gb hbas failing cq create.
      scsi: lpfc: Fix crash in blk_mq layer when executing modprobe -r lpfc
      scsi: lpfc: correct oversubscription of nvme io requests for an adapter
      scsi: lpfc: Fix MDS diagnostics failure (Rx < Tx)
      scsi: hisi_sas: Mark PHY as in reset for nexus reset
      scsi: hisi_sas: Fix return value when get_free_slot() failed
      scsi: hisi_sas: Terminate STP reject quickly for v2 hw
      scsi: hisi_sas: Add v2 hw force PHY function for internal ATA command
      scsi: hisi_sas: Include TMF elements in struct hisi_sas_slot
      scsi: hisi_sas: Try wait commands before before controller reset
      scsi: hisi_sas: Init disks after controller reset
      scsi: hisi_sas: Create a scsi_host_template per HW module
      scsi: hisi_sas: Reset disks when discovered
      scsi: hisi_sas: Add LED feature for v3 hw
      scsi: hisi_sas: Change common allocation mode of device id
      scsi: hisi_sas: change slot index allocation mode
      scsi: hisi_sas: Introduce hisi_sas_phy_set_linkrate()
      scsi: hisi_sas: fix a typo in hisi_sas_task_prep()
      ...

commit f7680bec0456403b4d3d7720e00b95586a7bc26b
Author: Christoph Hellwig <hch@lst.de>
Date:   Fri Apr 13 20:57:56 2018 +0200

    megaraid: simplify procfs code
    
    Use remove_proc_subtree to remove the whole subtree on cleanup, and
    unwind the registration loop into individual calls.  Switch to use
    proc_create_single.
    
    Also don't bother handling proc_create* failures - the driver works
    perfectly fine without the proc files, and the cleanup will handle
    missing files gracefully.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>

diff --git a/drivers/scsi/megaraid.c b/drivers/scsi/megaraid.c
index 7195cff51d4c..91f5e2c68dbc 100644
--- a/drivers/scsi/megaraid.c
+++ b/drivers/scsi/megaraid.c
@@ -2731,53 +2731,6 @@ proc_show_rdrv_40(struct seq_file *m, void *v)
 	return proc_show_rdrv(m, m->private, 30, 39);
 }
 
-
-/*
- * seq_file wrappers for procfile show routines.
- */
-static int mega_proc_open(struct inode *inode, struct file *file)
-{
-	adapter_t *adapter = proc_get_parent_data(inode);
-	int (*show)(struct seq_file *, void *) = PDE_DATA(inode);
-
-	return single_open(file, show, adapter);
-}
-
-static const struct file_operations mega_proc_fops = {
-	.open		= mega_proc_open,
-	.read		= seq_read,
-	.llseek		= seq_lseek,
-	.release	= single_release,
-};
-
-/*
- * Table of proc files we need to create.
- */
-struct mega_proc_file {
-	const char *name;
-	unsigned short ptr_offset;
-	int (*show) (struct seq_file *m, void *v);
-};
-
-static const struct mega_proc_file mega_proc_files[] = {
-	{ "config",	      offsetof(adapter_t, proc_read), proc_show_config },
-	{ "stat",	      offsetof(adapter_t, proc_stat), proc_show_stat },
-	{ "mailbox",	      offsetof(adapter_t, proc_mbox), proc_show_mbox },
-#if MEGA_HAVE_ENH_PROC
-	{ "rebuild-rate",     offsetof(adapter_t, proc_rr), proc_show_rebuild_rate },
-	{ "battery-status",   offsetof(adapter_t, proc_battery), proc_show_battery },
-	{ "diskdrives-ch0",   offsetof(adapter_t, proc_pdrvstat[0]), proc_show_pdrv_ch0 },
-	{ "diskdrives-ch1",   offsetof(adapter_t, proc_pdrvstat[1]), proc_show_pdrv_ch1 },
-	{ "diskdrives-ch2",   offsetof(adapter_t, proc_pdrvstat[2]), proc_show_pdrv_ch2 },
-	{ "diskdrives-ch3",   offsetof(adapter_t, proc_pdrvstat[3]), proc_show_pdrv_ch3 },
-	{ "raiddrives-0-9",   offsetof(adapter_t, proc_rdrvstat[0]), proc_show_rdrv_10 },
-	{ "raiddrives-10-19", offsetof(adapter_t, proc_rdrvstat[1]), proc_show_rdrv_20 },
-	{ "raiddrives-20-29", offsetof(adapter_t, proc_rdrvstat[2]), proc_show_rdrv_30 },
-	{ "raiddrives-30-39", offsetof(adapter_t, proc_rdrvstat[3]), proc_show_rdrv_40 },
-#endif
-	{ NULL }
-};
-
 /**
  * mega_create_proc_entry()
  * @index - index in soft state array
@@ -2788,31 +2741,45 @@ static const struct mega_proc_file mega_proc_files[] = {
 static void
 mega_create_proc_entry(int index, struct proc_dir_entry *parent)
 {
-	const struct mega_proc_file *f;
-	adapter_t	*adapter = hba_soft_state[index];
-	struct proc_dir_entry	*dir, *de, **ppde;
-	u8		string[16];
+	adapter_t *adapter = hba_soft_state[index];
+	struct proc_dir_entry *dir;
+	u8 string[16];
 
 	sprintf(string, "hba%d", adapter->host->host_no);
-
-	dir = adapter->controller_proc_dir_entry =
-		proc_mkdir_data(string, 0, parent, adapter);
-	if(!dir) {
+	dir = proc_mkdir_data(string, 0, parent, adapter);
+	if (!dir) {
 		dev_warn(&adapter->dev->dev, "proc_mkdir failed\n");
 		return;
 	}
 
-	for (f = mega_proc_files; f->name; f++) {
-		de = proc_create_data(f->name, S_IRUSR, dir, &mega_proc_fops,
-				      f->show);
-		if (!de) {
-			dev_warn(&adapter->dev->dev, "proc_create failed\n");
-			return;
-		}
-
-		ppde = (void *)adapter + f->ptr_offset;
-		*ppde = de;
-	}
+	proc_create_single_data("config", S_IRUSR, dir,
+			proc_show_config, adapter);
+	proc_create_single_data("stat", S_IRUSR, dir,
+			proc_show_stat, adapter);
+	proc_create_single_data("mailbox", S_IRUSR, dir,
+			proc_show_mbox, adapter);
+#if MEGA_HAVE_ENH_PROC
+	proc_create_single_data("rebuild-rate", S_IRUSR, dir,
+			proc_show_rebuild_rate, adapter);
+	proc_create_single_data("battery-status", S_IRUSR, dir,
+			proc_show_battery, adapter);
+	proc_create_single_data("diskdrives-ch0", S_IRUSR, dir,
+			proc_show_pdrv_ch0, adapter);
+	proc_create_single_data("diskdrives-ch1", S_IRUSR, dir,
+			proc_show_pdrv_ch1, adapter);
+	proc_create_single_data("diskdrives-ch2", S_IRUSR, dir,
+			proc_show_pdrv_ch2, adapter);
+	proc_create_single_data("diskdrives-ch3", S_IRUSR, dir,
+			proc_show_pdrv_ch3, adapter);
+	proc_create_single_data("raiddrives-0-9", S_IRUSR, dir,
+			proc_show_rdrv_10, adapter);
+	proc_create_single_data("raiddrives-10-19", S_IRUSR, dir,
+			proc_show_rdrv_20, adapter);
+	proc_create_single_data("raiddrives-20-29", S_IRUSR, dir,
+			proc_show_rdrv_30, adapter);
+	proc_create_single_data("raiddrives-30-39", S_IRUSR, dir,
+			proc_show_rdrv_40, adapter);
+#endif
 }
 
 #else
@@ -4580,6 +4547,7 @@ megaraid_remove_one(struct pci_dev *pdev)
 {
 	struct Scsi_Host *host = pci_get_drvdata(pdev);
 	adapter_t *adapter = (adapter_t *)host->hostdata;
+	char buf[12] = { 0 };
 
 	scsi_remove_host(host);
 
@@ -4594,44 +4562,8 @@ megaraid_remove_one(struct pci_dev *pdev)
 
 	mega_free_sgl(adapter);
 
-#ifdef CONFIG_PROC_FS
-	if (adapter->controller_proc_dir_entry) {
-		remove_proc_entry("stat", adapter->controller_proc_dir_entry);
-		remove_proc_entry("config",
-				adapter->controller_proc_dir_entry);
-		remove_proc_entry("mailbox",
-				adapter->controller_proc_dir_entry);
-#if MEGA_HAVE_ENH_PROC
-		remove_proc_entry("rebuild-rate",
-				adapter->controller_proc_dir_entry);
-		remove_proc_entry("battery-status",
-				adapter->controller_proc_dir_entry);
-
-		remove_proc_entry("diskdrives-ch0",
-				adapter->controller_proc_dir_entry);
-		remove_proc_entry("diskdrives-ch1",
-				adapter->controller_proc_dir_entry);
-		remove_proc_entry("diskdrives-ch2",
-				adapter->controller_proc_dir_entry);
-		remove_proc_entry("diskdrives-ch3",
-				adapter->controller_proc_dir_entry);
-
-		remove_proc_entry("raiddrives-0-9",
-				adapter->controller_proc_dir_entry);
-		remove_proc_entry("raiddrives-10-19",
-				adapter->controller_proc_dir_entry);
-		remove_proc_entry("raiddrives-20-29",
-				adapter->controller_proc_dir_entry);
-		remove_proc_entry("raiddrives-30-39",
-				adapter->controller_proc_dir_entry);
-#endif
-		{
-			char	buf[12] = { 0 };
-			sprintf(buf, "hba%d", adapter->host->host_no);
-			remove_proc_entry(buf, mega_proc_dir_entry);
-		}
-	}
-#endif
+	sprintf(buf, "hba%d", adapter->host->host_no);
+	remove_proc_subtree(buf, mega_proc_dir_entry);
 
 	pci_free_consistent(adapter->dev, MEGA_BUFFER_SIZE,
 			adapter->mega_buffer, adapter->buf_dma_handle);

commit 27e833dabab74ee665e487e291c9afc6d71effba
Author: Dan Carpenter <dan.carpenter@oracle.com>
Date:   Thu May 3 13:54:32 2018 +0300

    scsi: megaraid: silence a static checker bug
    
    If we had more than 32 megaraid cards then it would cause memory
    corruption.  That's not likely, of course, but it's handy to enforce it
    and make the static checker happy.
    
    Signed-off-by: Dan Carpenter <dan.carpenter@oracle.com>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/megaraid.c b/drivers/scsi/megaraid.c
index 7195cff51d4c..9b6f5d024dba 100644
--- a/drivers/scsi/megaraid.c
+++ b/drivers/scsi/megaraid.c
@@ -4199,6 +4199,9 @@ megaraid_probe_one(struct pci_dev *pdev, const struct pci_device_id *id)
 	int irq, i, j;
 	int error = -ENODEV;
 
+	if (hba_count >= MAX_CONTROLLERS)
+		goto out;
+
 	if (pci_enable_device(pdev))
 		goto out;
 	pci_set_master(pdev);

commit 875826a71c8b5ef9b7cc830dc61fa83d01016e5c
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Fri Jul 14 14:06:54 2017 +0200

    scsi: megaraid: fix format-overflow warning
    
    gcc-7 complains that the firmware version strings might overflow
    for some values:
    
    drivers/scsi/megaraid.c: In function 'megaraid_probe_one':
    drivers/scsi/megaraid.c:314:33: error: '%d' directive writing between 1 and 2 bytes into a region of size between 1 and 2 [-Werror=format-overflow=]
    drivers/scsi/megaraid.c:314:33: note: directive argument in the range [0, 15]
    drivers/scsi/megaraid.c:314:3: note: 'sprintf' output between 7 and 9 bytes into a destination of size 7
    drivers/scsi/megaraid.c:320:35: error: '%d' directive writing between 1 and 2 bytes into a region of size between 1 and 2 [-Werror=format-overflow=]
    drivers/scsi/megaraid.c:320:35: note: directive argument in the range [0, 15]
    drivers/scsi/megaraid.c:320:3: note: 'sprintf' output between 7 and 9 bytes into a destination of size 7
    
    This makes the code use a truncating snprintf() instead, which shuts
    up that warning.
    
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/megaraid.c b/drivers/scsi/megaraid.c
index 3c63c292cb92..7195cff51d4c 100644
--- a/drivers/scsi/megaraid.c
+++ b/drivers/scsi/megaraid.c
@@ -311,13 +311,15 @@ mega_query_adapter(adapter_t *adapter)
 	   right 8 bits making them zero. This 0 value was hardcoded to fix
 	   sparse warnings. */
 	if (adapter->product_info.subsysvid == PCI_VENDOR_ID_HP) {
-		sprintf (adapter->fw_version, "%c%d%d.%d%d",
+		snprintf(adapter->fw_version, sizeof(adapter->fw_version),
+			 "%c%d%d.%d%d",
 			 adapter->product_info.fw_version[2],
 			 0,
 			 adapter->product_info.fw_version[1] & 0x0f,
 			 0,
 			 adapter->product_info.fw_version[0] & 0x0f);
-		sprintf (adapter->bios_version, "%c%d%d.%d%d",
+		snprintf(adapter->bios_version, sizeof(adapter->fw_version),
+			 "%c%d%d.%d%d",
 			 adapter->product_info.bios_version[2],
 			 0,
 			 adapter->product_info.bios_version[1] & 0x0f,

commit 7c0f6ba682b9c7632072ffbedf8d328c8f3c42ba
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sat Dec 24 11:46:01 2016 -0800

    Replace <asm/uaccess.h> with <linux/uaccess.h> globally
    
    This was entirely automated, using the script by Al:
    
      PATT='^[[:blank:]]*#[[:blank:]]*include[[:blank:]]*<asm/uaccess.h>'
      sed -i -e "s!$PATT!#include <linux/uaccess.h>!" \
            $(git grep -l "$PATT"|grep -v ^include/linux/uaccess.h)
    
    to do the replacement at the end of the merge window.
    
    Requested-by: Al Viro <viro@zeniv.linux.org.uk>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/scsi/megaraid.c b/drivers/scsi/megaraid.c
index 9d05302a3bcd..3c63c292cb92 100644
--- a/drivers/scsi/megaraid.c
+++ b/drivers/scsi/megaraid.c
@@ -34,7 +34,7 @@
 #include <linux/mm.h>
 #include <linux/fs.h>
 #include <linux/blkdev.h>
-#include <asm/uaccess.h>
+#include <linux/uaccess.h>
 #include <asm/io.h>
 #include <linux/completion.h>
 #include <linux/delay.h>

commit 3b8a1ba378b7502c7206ab3da5ea484a132ad30c
Author: Bjorn Helgaas <bhelgaas@google.com>
Date:   Tue Jul 7 15:52:25 2015 -0500

    megaraid : use dev_printk when possible
    
    Use dev_printk() when possible to make messages more useful.
    
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Reviewed-by: Hannes Reinecke <hare@suse.de>
    Acked-by: Sumit Saxena <sumit.saxena@avagotech.com>
    Signed-off-by: James Bottomley <JBottomley@Odin.com>

diff --git a/drivers/scsi/megaraid.c b/drivers/scsi/megaraid.c
index bc7b34c02723..9d05302a3bcd 100644
--- a/drivers/scsi/megaraid.c
+++ b/drivers/scsi/megaraid.c
@@ -268,8 +268,8 @@ mega_query_adapter(adapter_t *adapter)
 		raw_mbox[2] = NC_SUBOP_PRODUCT_INFO;	/* i.e. 0x0E */
 
 		if ((retval = issue_scb_block(adapter, raw_mbox)))
-			printk(KERN_WARNING
-			"megaraid: Product_info cmd failed with error: %d\n",
+			dev_warn(&adapter->dev->dev,
+				"Product_info cmd failed with error: %d\n",
 				retval);
 
 		pci_unmap_single(adapter->dev, prod_info_dma_handle,
@@ -334,7 +334,7 @@ mega_query_adapter(adapter_t *adapter)
 		adapter->bios_version[4] = 0;
 	}
 
-	printk(KERN_NOTICE "megaraid: [%s:%s] detected %d logical drives.\n",
+	dev_notice(&adapter->dev->dev, "[%s:%s] detected %d logical drives\n",
 		adapter->fw_version, adapter->bios_version, adapter->numldrv);
 
 	/*
@@ -342,7 +342,7 @@ mega_query_adapter(adapter_t *adapter)
 	 */
 	adapter->support_ext_cdb = mega_support_ext_cdb(adapter);
 	if (adapter->support_ext_cdb)
-		printk(KERN_NOTICE "megaraid: supports extended CDBs.\n");
+		dev_notice(&adapter->dev->dev, "supports extended CDBs\n");
 
 
 	return 0;
@@ -678,11 +678,11 @@ mega_build_cmd(adapter_t *adapter, Scsi_Cmnd *cmd, int *busy)
 
 			if(!(adapter->flag & (1L << cmd->device->channel))) {
 
-				printk(KERN_NOTICE
-					"scsi%d: scanning scsi channel %d ",
+				dev_notice(&adapter->dev->dev,
+					"scsi%d: scanning scsi channel %d "
+					"for logical drives\n",
 						adapter->host->host_no,
 						cmd->device->channel);
-				printk("for logical drives.\n");
 
 				adapter->flag |= (1L << cmd->device->channel);
 			}
@@ -983,11 +983,11 @@ mega_prepare_passthru(adapter_t *adapter, scb_t *scb, Scsi_Cmnd *cmd,
 	case READ_CAPACITY:
 		if(!(adapter->flag & (1L << cmd->device->channel))) {
 
-			printk(KERN_NOTICE
-				"scsi%d: scanning scsi channel %d [P%d] ",
+			dev_notice(&adapter->dev->dev,
+				"scsi%d: scanning scsi channel %d [P%d] "
+				"for physical devices\n",
 					adapter->host->host_no,
 					cmd->device->channel, channel);
-			printk("for physical devices.\n");
 
 			adapter->flag |= (1L << cmd->device->channel);
 		}
@@ -1045,11 +1045,11 @@ mega_prepare_extpassthru(adapter_t *adapter, scb_t *scb, Scsi_Cmnd *cmd,
 	case READ_CAPACITY:
 		if(!(adapter->flag & (1L << cmd->device->channel))) {
 
-			printk(KERN_NOTICE
-				"scsi%d: scanning scsi channel %d [P%d] ",
+			dev_notice(&adapter->dev->dev,
+				"scsi%d: scanning scsi channel %d [P%d] "
+				"for physical devices\n",
 					adapter->host->host_no,
 					cmd->device->channel, channel);
-			printk("for physical devices.\n");
 
 			adapter->flag |= (1L << cmd->device->channel);
 		}
@@ -1241,7 +1241,7 @@ issue_scb_block(adapter_t *adapter, u_char *raw_mbox)
 	return mbox->m_in.status;
 
 bug_blocked_mailbox:
-	printk(KERN_WARNING "megaraid: Blocked mailbox......!!\n");
+	dev_warn(&adapter->dev->dev, "Blocked mailbox......!!\n");
 	udelay (1000);
 	return -1;
 }
@@ -1454,9 +1454,8 @@ mega_cmd_done(adapter_t *adapter, u8 completed[], int nstatus, int status)
 			 * Make sure f/w has completed a valid command
 			 */
 			if( !(scb->state & SCB_ISSUED) || scb->cmd == NULL ) {
-				printk(KERN_CRIT
-					"megaraid: invalid command ");
-				printk("Id %d, scb->state:%x, scsi cmd:%p\n",
+				dev_crit(&adapter->dev->dev, "invalid command "
+					"Id %d, scb->state:%x, scsi cmd:%p\n",
 					cmdid, scb->state, scb->cmd);
 
 				continue;
@@ -1467,8 +1466,8 @@ mega_cmd_done(adapter_t *adapter, u8 completed[], int nstatus, int status)
 			 */
 			if( scb->state & SCB_ABORT ) {
 
-				printk(KERN_WARNING
-				"megaraid: aborted cmd [%x] complete.\n",
+				dev_warn(&adapter->dev->dev,
+					"aborted cmd [%x] complete\n",
 					scb->idx);
 
 				scb->cmd->result = (DID_ABORT << 16);
@@ -1486,8 +1485,8 @@ mega_cmd_done(adapter_t *adapter, u8 completed[], int nstatus, int status)
 			 */
 			if( scb->state & SCB_RESET ) {
 
-				printk(KERN_WARNING
-				"megaraid: reset cmd [%x] complete.\n",
+				dev_warn(&adapter->dev->dev,
+					"reset cmd [%x] complete\n",
 					scb->idx);
 
 				scb->cmd->result = (DID_RESET << 16);
@@ -1553,8 +1552,7 @@ mega_cmd_done(adapter_t *adapter, u8 completed[], int nstatus, int status)
 			if( sg_page(sgl) ) {
 				c = *(unsigned char *) sg_virt(&sgl[0]);
 			} else {
-				printk(KERN_WARNING
-				       "megaraid: invalid sg.\n");
+				dev_warn(&adapter->dev->dev, "invalid sg\n");
 				c = 0;
 			}
 
@@ -1902,11 +1900,10 @@ megaraid_reset(struct scsi_cmnd *cmd)
 	mc.opcode = MEGA_RESET_RESERVATIONS;
 
 	if( mega_internal_command(adapter, &mc, NULL) != 0 ) {
-		printk(KERN_WARNING
-				"megaraid: reservation reset failed.\n");
+		dev_warn(&adapter->dev->dev, "reservation reset failed\n");
 	}
 	else {
-		printk(KERN_INFO "megaraid: reservation reset.\n");
+		dev_info(&adapter->dev->dev, "reservation reset\n");
 	}
 #endif
 
@@ -1939,7 +1936,7 @@ megaraid_abort_and_reset(adapter_t *adapter, Scsi_Cmnd *cmd, int aor)
 	struct list_head	*pos, *next;
 	scb_t			*scb;
 
-	printk(KERN_WARNING "megaraid: %s cmd=%x <c=%d t=%d l=%d>\n",
+	dev_warn(&adapter->dev->dev, "%s cmd=%x <c=%d t=%d l=%d>\n",
 	     (aor == SCB_ABORT)? "ABORTING":"RESET",
 	     cmd->cmnd[0], cmd->device->channel,
 	     cmd->device->id, (u32)cmd->device->lun);
@@ -1963,8 +1960,8 @@ megaraid_abort_and_reset(adapter_t *adapter, Scsi_Cmnd *cmd, int aor)
 			 */
 			if( scb->state & SCB_ISSUED ) {
 
-				printk(KERN_WARNING
-					"megaraid: %s[%x], fw owner.\n",
+				dev_warn(&adapter->dev->dev,
+					"%s[%x], fw owner\n",
 					(aor==SCB_ABORT) ? "ABORTING":"RESET",
 					scb->idx);
 
@@ -1976,8 +1973,8 @@ megaraid_abort_and_reset(adapter_t *adapter, Scsi_Cmnd *cmd, int aor)
 				 * Not yet issued! Remove from the pending
 				 * list
 				 */
-				printk(KERN_WARNING
-					"megaraid: %s-[%x], driver owner.\n",
+				dev_warn(&adapter->dev->dev,
+					"%s-[%x], driver owner\n",
 					(aor==SCB_ABORT) ? "ABORTING":"RESET",
 					scb->idx);
 
@@ -2197,7 +2194,7 @@ proc_show_rebuild_rate(struct seq_file *m, void *v)
 
 	if( mega_adapinq(adapter, dma_handle) != 0 ) {
 		seq_puts(m, "Adapter inquiry failed.\n");
-		printk(KERN_WARNING "megaraid: inquiry failed.\n");
+		dev_warn(&adapter->dev->dev, "inquiry failed\n");
 		goto free_inquiry;
 	}
 
@@ -2241,7 +2238,7 @@ proc_show_battery(struct seq_file *m, void *v)
 
 	if( mega_adapinq(adapter, dma_handle) != 0 ) {
 		seq_puts(m, "Adapter inquiry failed.\n");
-		printk(KERN_WARNING "megaraid: inquiry failed.\n");
+		dev_warn(&adapter->dev->dev, "inquiry failed\n");
 		goto free_inquiry;
 	}
 
@@ -2350,7 +2347,7 @@ proc_show_pdrv(struct seq_file *m, adapter_t *adapter, int channel)
 
 	if( mega_adapinq(adapter, dma_handle) != 0 ) {
 		seq_puts(m, "Adapter inquiry failed.\n");
-		printk(KERN_WARNING "megaraid: inquiry failed.\n");
+		dev_warn(&adapter->dev->dev, "inquiry failed\n");
 		goto free_inquiry;
 	}
 
@@ -2525,7 +2522,7 @@ proc_show_rdrv(struct seq_file *m, adapter_t *adapter, int start, int end )
 
 	if( mega_adapinq(adapter, dma_handle) != 0 ) {
 		seq_puts(m, "Adapter inquiry failed.\n");
-		printk(KERN_WARNING "megaraid: inquiry failed.\n");
+		dev_warn(&adapter->dev->dev, "inquiry failed\n");
 		goto free_inquiry;
 	}
 
@@ -2799,7 +2796,7 @@ mega_create_proc_entry(int index, struct proc_dir_entry *parent)
 	dir = adapter->controller_proc_dir_entry =
 		proc_mkdir_data(string, 0, parent, adapter);
 	if(!dir) {
-		printk(KERN_WARNING "\nmegaraid: proc_mkdir failed\n");
+		dev_warn(&adapter->dev->dev, "proc_mkdir failed\n");
 		return;
 	}
 
@@ -2807,7 +2804,7 @@ mega_create_proc_entry(int index, struct proc_dir_entry *parent)
 		de = proc_create_data(f->name, S_IRUSR, dir, &mega_proc_fops,
 				      f->show);
 		if (!de) {
-			printk(KERN_WARNING "\nmegaraid: proc_create failed\n");
+			dev_warn(&adapter->dev->dev, "proc_create failed\n");
 			return;
 		}
 
@@ -2874,9 +2871,9 @@ megaraid_biosparam(struct scsi_device *sdev, struct block_device *bdev,
 				return rval;
 		}
 
-		printk(KERN_INFO
-		"megaraid: invalid partition on this disk on channel %d\n",
-				sdev->channel);
+		dev_info(&adapter->dev->dev,
+			 "invalid partition on this disk on channel %d\n",
+			 sdev->channel);
 
 		/* Default heads (64) & sectors (32) */
 		heads = 64;
@@ -2936,7 +2933,7 @@ mega_init_scb(adapter_t *adapter)
 		scb->sgl = (mega_sglist *)scb->sgl64;
 
 		if( !scb->sgl ) {
-			printk(KERN_WARNING "RAID: Can't allocate sglist.\n");
+			dev_warn(&adapter->dev->dev, "RAID: Can't allocate sglist\n");
 			mega_free_sgl(adapter);
 			return -1;
 		}
@@ -2946,7 +2943,7 @@ mega_init_scb(adapter_t *adapter)
 				&scb->pthru_dma_addr);
 
 		if( !scb->pthru ) {
-			printk(KERN_WARNING "RAID: Can't allocate passthru.\n");
+			dev_warn(&adapter->dev->dev, "RAID: Can't allocate passthru\n");
 			mega_free_sgl(adapter);
 			return -1;
 		}
@@ -2956,8 +2953,8 @@ mega_init_scb(adapter_t *adapter)
 				&scb->epthru_dma_addr);
 
 		if( !scb->epthru ) {
-			printk(KERN_WARNING
-				"Can't allocate extended passthru.\n");
+			dev_warn(&adapter->dev->dev,
+				"Can't allocate extended passthru\n");
 			mega_free_sgl(adapter);
 			return -1;
 		}
@@ -3154,8 +3151,8 @@ megadev_ioctl(struct file *filep, unsigned int cmd, unsigned long arg)
 			 * Do we support this feature
 			 */
 			if( !adapter->support_random_del ) {
-				printk(KERN_WARNING "megaraid: logdrv ");
-				printk("delete on non-supporting F/W.\n");
+				dev_warn(&adapter->dev->dev, "logdrv "
+					"delete on non-supporting F/W\n");
 
 				return (-EINVAL);
 			}
@@ -3179,7 +3176,7 @@ megadev_ioctl(struct file *filep, unsigned int cmd, unsigned long arg)
 		if( uioc.uioc_rmbox[0] == MEGA_MBOXCMD_PASSTHRU64 ||
 			uioc.uioc_rmbox[0] == MEGA_MBOXCMD_EXTPTHRU ) {
 
-			printk(KERN_WARNING "megaraid: rejected passthru.\n");
+			dev_warn(&adapter->dev->dev, "rejected passthru\n");
 
 			return (-EINVAL);
 		}
@@ -3683,11 +3680,11 @@ mega_enum_raid_scsi(adapter_t *adapter)
 
 	for( i = 0; i < adapter->product_info.nchannels; i++ ) { 
 		if( (adapter->mega_ch_class >> i) & 0x01 ) {
-			printk(KERN_INFO "megaraid: channel[%d] is raid.\n",
+			dev_info(&adapter->dev->dev, "channel[%d] is raid\n",
 					i);
 		}
 		else {
-			printk(KERN_INFO "megaraid: channel[%d] is scsi.\n",
+			dev_info(&adapter->dev->dev, "channel[%d] is scsi\n",
 					i);
 		}
 	}
@@ -3893,7 +3890,7 @@ mega_do_del_logdrv(adapter_t *adapter, int logdrv)
 
 	/* log this event */
 	if(rval) {
-		printk(KERN_WARNING "megaraid: Delete LD-%d failed.", logdrv);
+		dev_warn(&adapter->dev->dev, "Delete LD-%d failed", logdrv);
 		return rval;
 	}
 
@@ -4161,7 +4158,7 @@ mega_internal_command(adapter_t *adapter, megacmd_t *mc, mega_passthru *pthru)
 	 * this information.
 	 */
 	if (rval && trace_level) {
-		printk("megaraid: cmd [%x, %x, %x] status:[%x]\n",
+		dev_info(&adapter->dev->dev, "cmd [%x, %x, %x] status:[%x]\n",
 			mc->cmd, mc->opcode, mc->subopcode, rval);
 	}
 
@@ -4244,11 +4241,8 @@ megaraid_probe_one(struct pci_dev *pdev, const struct pci_device_id *id)
 	subsysvid = pdev->subsystem_vendor;
 	subsysid = pdev->subsystem_device;
 
-	printk(KERN_NOTICE "megaraid: found 0x%4.04x:0x%4.04x:bus %d:",
-		id->vendor, id->device, pci_bus);
-
-	printk("slot %d:func %d\n",
-		PCI_SLOT(pci_dev_func), PCI_FUNC(pci_dev_func));
+	dev_notice(&pdev->dev, "found 0x%4.04x:0x%4.04x\n",
+		id->vendor, id->device);
 
 	/* Read the base port and IRQ from PCI */
 	mega_baseport = pci_resource_start(pdev, 0);
@@ -4259,14 +4253,13 @@ megaraid_probe_one(struct pci_dev *pdev, const struct pci_device_id *id)
 		flag |= BOARD_MEMMAP;
 
 		if (!request_mem_region(mega_baseport, 128, "megaraid")) {
-			printk(KERN_WARNING "megaraid: mem region busy!\n");
+			dev_warn(&pdev->dev, "mem region busy!\n");
 			goto out_disable_device;
 		}
 
 		mega_baseport = (unsigned long)ioremap(mega_baseport, 128);
 		if (!mega_baseport) {
-			printk(KERN_WARNING
-			       "megaraid: could not map hba memory\n");
+			dev_warn(&pdev->dev, "could not map hba memory\n");
 			goto out_release_region;
 		}
 	} else {
@@ -4285,7 +4278,7 @@ megaraid_probe_one(struct pci_dev *pdev, const struct pci_device_id *id)
 	adapter = (adapter_t *)host->hostdata;
 	memset(adapter, 0, sizeof(adapter_t));
 
-	printk(KERN_NOTICE
+	dev_notice(&pdev->dev,
 		"scsi%d:Found MegaRAID controller at 0x%lx, IRQ:%d\n",
 		host->host_no, mega_baseport, irq);
 
@@ -4323,21 +4316,20 @@ megaraid_probe_one(struct pci_dev *pdev, const struct pci_device_id *id)
 	adapter->mega_buffer = pci_alloc_consistent(adapter->dev,
 		MEGA_BUFFER_SIZE, &adapter->buf_dma_handle);
 	if (!adapter->mega_buffer) {
-		printk(KERN_WARNING "megaraid: out of RAM.\n");
+		dev_warn(&pdev->dev, "out of RAM\n");
 		goto out_host_put;
 	}
 
 	adapter->scb_list = kmalloc(sizeof(scb_t) * MAX_COMMANDS, GFP_KERNEL);
 	if (!adapter->scb_list) {
-		printk(KERN_WARNING "megaraid: out of RAM.\n");
+		dev_warn(&pdev->dev, "out of RAM\n");
 		goto out_free_cmd_buffer;
 	}
 
 	if (request_irq(irq, (adapter->flag & BOARD_MEMMAP) ?
 				megaraid_isr_memmapped : megaraid_isr_iomapped,
 					IRQF_SHARED, "megaraid", adapter)) {
-		printk(KERN_WARNING
-			"megaraid: Couldn't register IRQ %d!\n", irq);
+		dev_warn(&pdev->dev, "Couldn't register IRQ %d!\n", irq);
 		goto out_free_scb_list;
 	}
 
@@ -4357,9 +4349,9 @@ megaraid_probe_one(struct pci_dev *pdev, const struct pci_device_id *id)
 		if (!strcmp(adapter->fw_version, "3.00") ||
 				!strcmp(adapter->fw_version, "3.01")) {
 
-			printk( KERN_WARNING
-				"megaraid: Your  card is a Dell PERC "
-				"2/SC RAID controller with  "
+			dev_warn(&pdev->dev,
+				"Your card is a Dell PERC "
+				"2/SC RAID controller with "
 				"firmware\nmegaraid: 3.00 or 3.01.  "
 				"This driver is known to have "
 				"corruption issues\nmegaraid: with "
@@ -4390,12 +4382,12 @@ megaraid_probe_one(struct pci_dev *pdev, const struct pci_device_id *id)
 		if (!strcmp(adapter->fw_version, "H01.07") ||
 		    !strcmp(adapter->fw_version, "H01.08") ||
 		    !strcmp(adapter->fw_version, "H01.09") ) {
-			printk(KERN_WARNING
-				"megaraid: Firmware H.01.07, "
+			dev_warn(&pdev->dev,
+				"Firmware H.01.07, "
 				"H.01.08, and H.01.09 on 1M/2M "
 				"controllers\n"
-				"megaraid: do not support 64 bit "
-				"addressing.\nmegaraid: DISABLING "
+				"do not support 64 bit "
+				"addressing.\nDISABLING "
 				"64 bit support.\n");
 			adapter->flag &= ~BOARD_64BIT;
 		}
@@ -4503,8 +4495,8 @@ megaraid_probe_one(struct pci_dev *pdev, const struct pci_device_id *id)
 	 */
 	adapter->has_cluster = mega_support_cluster(adapter);
 	if (adapter->has_cluster) {
-		printk(KERN_NOTICE
-			"megaraid: Cluster driver, initiator id:%d\n",
+		dev_notice(&pdev->dev,
+			"Cluster driver, initiator id:%d\n",
 			adapter->this_id);
 	}
 #endif
@@ -4571,7 +4563,7 @@ __megaraid_shutdown(adapter_t *adapter)
 	issue_scb_block(adapter, raw_mbox);
 	
 	if (atomic_read(&adapter->pend_cmds) > 0)
-		printk(KERN_WARNING "megaraid: pending commands!!\n");
+		dev_warn(&adapter->dev->dev, "pending commands!!\n");
 
 	/*
 	 * Have a delibrate delay to make sure all the caches are

commit 91c40f24faadd977ee9209fee6a760e72a50d19c
Author: Rasmus Villemoes <linux@rasmusvillemoes.dk>
Date:   Wed Dec 3 00:10:52 2014 +0100

    scsi: replace seq_printf with seq_puts
    
    Using seq_printf to print a simple string is a lot more expensive than
    it needs to be, since seq_puts exists. Replace seq_printf with
    seq_puts when possible.
    
    Signed-off-by: Rasmus Villemoes <linux@rasmusvillemoes.dk>
    Reviewed-by: Finn Thain <fthain@telegraphics.com.au>
    Signed-off-by: Christoph Hellwig <hch@lst.de>

diff --git a/drivers/scsi/megaraid.c b/drivers/scsi/megaraid.c
index 2485255f3414..bc7b34c02723 100644
--- a/drivers/scsi/megaraid.c
+++ b/drivers/scsi/megaraid.c
@@ -2240,7 +2240,7 @@ proc_show_battery(struct seq_file *m, void *v)
 		goto free_pdev;
 
 	if( mega_adapinq(adapter, dma_handle) != 0 ) {
-		seq_printf(m, "Adapter inquiry failed.\n");
+		seq_puts(m, "Adapter inquiry failed.\n");
 		printk(KERN_WARNING "megaraid: inquiry failed.\n");
 		goto free_inquiry;
 	}

commit b6c92b7e0af575e2b8b05bdf33633cf9e1661cbf
Author: Hannes Reinecke <hare@suse.de>
Date:   Thu Oct 30 09:44:36 2014 +0100

    scsi: correct return values for .eh_abort_handler implementations
    
    The .eh_abort_handler needs to return SUCCESS, FAILED, or
    FAST_IO_FAIL. So fixup all callers to adhere to this requirement.
    
    Reviewed-by: Robert Elliott <elliott@hp.com>
    Cc: <stable@vger.kernel.org>
    Signed-off-by: Hannes Reinecke <hare@suse.de>
    Signed-off-by: Christoph Hellwig <hch@lst.de>

diff --git a/drivers/scsi/megaraid.c b/drivers/scsi/megaraid.c
index ac5d94cfd52f..2485255f3414 100644
--- a/drivers/scsi/megaraid.c
+++ b/drivers/scsi/megaraid.c
@@ -1945,7 +1945,7 @@ megaraid_abort_and_reset(adapter_t *adapter, Scsi_Cmnd *cmd, int aor)
 	     cmd->device->id, (u32)cmd->device->lun);
 
 	if(list_empty(&adapter->pending_list))
-		return FALSE;
+		return FAILED;
 
 	list_for_each_safe(pos, next, &adapter->pending_list) {
 
@@ -1968,7 +1968,7 @@ megaraid_abort_and_reset(adapter_t *adapter, Scsi_Cmnd *cmd, int aor)
 					(aor==SCB_ABORT) ? "ABORTING":"RESET",
 					scb->idx);
 
-				return FALSE;
+				return FAILED;
 			}
 			else {
 
@@ -1993,12 +1993,12 @@ megaraid_abort_and_reset(adapter_t *adapter, Scsi_Cmnd *cmd, int aor)
 				list_add_tail(SCSI_LIST(cmd),
 						&adapter->completed_list);
 
-				return TRUE;
+				return SUCCESS;
 			}
 		}
 	}
 
-	return FALSE;
+	return FAILED;
 }
 
 static inline int

commit 1abf635d2f3332641570e1913e317073834a055f
Author: Hannes Reinecke <hare@suse.de>
Date:   Wed Jun 25 15:27:38 2014 +0200

    scsi: use 64-bit value for 'max_luns'
    
    Now that we're using 64-bit LUNs internally we need to increase
    the size of max_luns to 64 bits, too.
    
    Signed-off-by: Hannes Reinecke <hare@suse.de>
    Reviewed-by: Christoph Hellwig <hch@infradead.org>
    Reviewed-by: Ewan Milne <emilne@redhat.com>
    Signed-off-by: Christoph Hellwig <hch@lst.de>

diff --git a/drivers/scsi/megaraid.c b/drivers/scsi/megaraid.c
index 6bb2b52646b4..ac5d94cfd52f 100644
--- a/drivers/scsi/megaraid.c
+++ b/drivers/scsi/megaraid.c
@@ -1860,7 +1860,7 @@ megaraid_info(struct Scsi_Host *host)
 		 "LSI Logic MegaRAID %s %d commands %d targs %d chans %d luns",
 		 adapter->fw_version, adapter->product_info.max_commands,
 		 adapter->host->max_id, adapter->host->max_channel,
-		 adapter->host->max_lun);
+		 (u32)adapter->host->max_lun);
 	return buffer;
 }
 

commit 9cb78c16f5dadefd8dc5ba0ae5a2f26cd59419b3
Author: Hannes Reinecke <hare@suse.de>
Date:   Wed Jun 25 15:27:36 2014 +0200

    scsi: use 64-bit LUNs
    
    The SCSI standard defines 64-bit values for LUNs, and large arrays
    employing large or hierarchical LUN numbers become more and more
    common.
    
    So update the linux SCSI stack to use 64-bit LUN numbers.
    
    Signed-off-by: Hannes Reinecke <hare@suse.de>
    Reviewed-by: Christoph Hellwig <hch@infradead.org>
    Reviewed-by: Ewan Milne <emilne@redhat.com>
    Signed-off-by: Christoph Hellwig <hch@lst.de>

diff --git a/drivers/scsi/megaraid.c b/drivers/scsi/megaraid.c
index b7770516f4c2..6bb2b52646b4 100644
--- a/drivers/scsi/megaraid.c
+++ b/drivers/scsi/megaraid.c
@@ -1941,8 +1941,8 @@ megaraid_abort_and_reset(adapter_t *adapter, Scsi_Cmnd *cmd, int aor)
 
 	printk(KERN_WARNING "megaraid: %s cmd=%x <c=%d t=%d l=%d>\n",
 	     (aor == SCB_ABORT)? "ABORTING":"RESET",
-	     cmd->cmnd[0], cmd->device->channel, 
-	     cmd->device->id, cmd->device->lun);
+	     cmd->cmnd[0], cmd->device->channel,
+	     cmd->device->id, (u32)cmd->device->lun);
 
 	if(list_empty(&adapter->pending_list))
 		return FALSE;

commit 0f2bb84d2a68448c29d46f9f77a78bb4ed0218db
Author: Christoph Hellwig <hch@infradead.org>
Date:   Thu Feb 20 14:20:59 2014 -0800

    [SCSI] megaraid: simplify internal command handling
    
    We don't use the passed in scsi command for anything, so just add a adapter-
    wide internal status to go along with the internal scb that is used unter
    int_mtx to pass back the return value and get rid of all the complexities
    and abuse of the scsi_cmnd structure.
    
    This gets rid of the only user of scsi_allocate_command/scsi_free_command,
    which can now be removed.
    
    [jejb: checkpatch fixes]
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Acked-by: Adam Radford <aradford@gmail.com>
    Signed-off-by: James Bottomley <JBottomley@Parallels.com>

diff --git a/drivers/scsi/megaraid.c b/drivers/scsi/megaraid.c
index 816db12ef5d5..b7770516f4c2 100644
--- a/drivers/scsi/megaraid.c
+++ b/drivers/scsi/megaraid.c
@@ -531,13 +531,6 @@ mega_build_cmd(adapter_t *adapter, Scsi_Cmnd *cmd, int *busy)
 	int	target = 0;
 	int	ldrv_num = 0;   /* logical drive number */
 
-
-	/*
-	 * filter the internal and ioctl commands
-	 */
-	if((cmd->cmnd[0] == MEGA_INTERNAL_CMD))
-		return (scb_t *)cmd->host_scribble;
-
 	/*
 	 * We know what channels our logical drives are on - mega_find_card()
 	 */
@@ -1439,19 +1432,22 @@ mega_cmd_done(adapter_t *adapter, u8 completed[], int nstatus, int status)
 
 		cmdid = completed[i];
 
-		if( cmdid == CMDID_INT_CMDS ) { /* internal command */
+		/*
+		 * Only free SCBs for the commands coming down from the
+		 * mid-layer, not for which were issued internally
+		 *
+		 * For internal command, restore the status returned by the
+		 * firmware so that user can interpret it.
+		 */
+		if (cmdid == CMDID_INT_CMDS) {
 			scb = &adapter->int_scb;
-			cmd = scb->cmd;
-			mbox = (mbox_t *)scb->raw_mbox;
 
-			/*
-			 * Internal command interface do not fire the extended
-			 * passthru or 64-bit passthru
-			 */
-			pthru = scb->pthru;
+			list_del_init(&scb->list);
+			scb->state = SCB_FREE;
 
-		}
-		else {
+			adapter->int_status = status;
+			complete(&adapter->int_waitq);
+		} else {
 			scb = &adapter->scb_list[cmdid];
 
 			/*
@@ -1640,25 +1636,7 @@ mega_cmd_done(adapter_t *adapter, u8 completed[], int nstatus, int status)
 				cmd->result |= (DID_BAD_TARGET << 16)|status;
 		}
 
-		/*
-		 * Only free SCBs for the commands coming down from the
-		 * mid-layer, not for which were issued internally
-		 *
-		 * For internal command, restore the status returned by the
-		 * firmware so that user can interpret it.
-		 */
-		if( cmdid == CMDID_INT_CMDS ) { /* internal command */
-			cmd->result = status;
-
-			/*
-			 * Remove the internal command from the pending list
-			 */
-			list_del_init(&scb->list);
-			scb->state = SCB_FREE;
-		}
-		else {
-			mega_free_scb(adapter, scb);
-		}
+		mega_free_scb(adapter, scb);
 
 		/* Add Scsi_Command to end of completed queue */
 		list_add_tail(SCSI_LIST(cmd), &adapter->completed_list);
@@ -4133,23 +4111,15 @@ mega_internal_dev_inquiry(adapter_t *adapter, u8 ch, u8 tgt,
  * The last argument is the address of the passthru structure if the command
  * to be fired is a passthru command
  *
- * lockscope specifies whether the caller has already acquired the lock. Of
- * course, the caller must know which lock we are talking about.
- *
  * Note: parameter 'pthru' is null for non-passthru commands.
  */
 static int
 mega_internal_command(adapter_t *adapter, megacmd_t *mc, mega_passthru *pthru)
 {
-	Scsi_Cmnd	*scmd;
-	struct	scsi_device *sdev;
+	unsigned long flags;
 	scb_t	*scb;
 	int	rval;
 
-	scmd = scsi_allocate_command(GFP_KERNEL);
-	if (!scmd)
-		return -ENOMEM;
-
 	/*
 	 * The internal commands share one command id and hence are
 	 * serialized. This is so because we want to reserve maximum number of
@@ -4160,73 +4130,45 @@ mega_internal_command(adapter_t *adapter, megacmd_t *mc, mega_passthru *pthru)
 	scb = &adapter->int_scb;
 	memset(scb, 0, sizeof(scb_t));
 
-	sdev = kzalloc(sizeof(struct scsi_device), GFP_KERNEL);
-	scmd->device = sdev;
-
-	memset(adapter->int_cdb, 0, sizeof(adapter->int_cdb));
-	scmd->cmnd = adapter->int_cdb;
-	scmd->device->host = adapter->host;
-	scmd->host_scribble = (void *)scb;
-	scmd->cmnd[0] = MEGA_INTERNAL_CMD;
-
-	scb->state |= SCB_ACTIVE;
-	scb->cmd = scmd;
+	scb->idx = CMDID_INT_CMDS;
+	scb->state |= SCB_ACTIVE | SCB_PENDQ;
 
 	memcpy(scb->raw_mbox, mc, sizeof(megacmd_t));
 
 	/*
 	 * Is it a passthru command
 	 */
-	if( mc->cmd == MEGA_MBOXCMD_PASSTHRU ) {
-
+	if (mc->cmd == MEGA_MBOXCMD_PASSTHRU)
 		scb->pthru = pthru;
-	}
-
-	scb->idx = CMDID_INT_CMDS;
 
-	megaraid_queue_lck(scmd, mega_internal_done);
+	spin_lock_irqsave(&adapter->lock, flags);
+	list_add_tail(&scb->list, &adapter->pending_list);
+	/*
+	 * Check if the HBA is in quiescent state, e.g., during a
+	 * delete logical drive opertion. If it is, don't run
+	 * the pending_list.
+	 */
+	if (atomic_read(&adapter->quiescent) == 0)
+		mega_runpendq(adapter);
+	spin_unlock_irqrestore(&adapter->lock, flags);
 
 	wait_for_completion(&adapter->int_waitq);
 
-	rval = scmd->result;
-	mc->status = scmd->result;
-	kfree(sdev);
+	mc->status = rval = adapter->int_status;
 
 	/*
 	 * Print a debug message for all failed commands. Applications can use
 	 * this information.
 	 */
-	if( scmd->result && trace_level ) {
+	if (rval && trace_level) {
 		printk("megaraid: cmd [%x, %x, %x] status:[%x]\n",
-			mc->cmd, mc->opcode, mc->subopcode, scmd->result);
+			mc->cmd, mc->opcode, mc->subopcode, rval);
 	}
 
 	mutex_unlock(&adapter->int_mtx);
-
-	scsi_free_command(GFP_KERNEL, scmd);
-
 	return rval;
 }
 
-
-/**
- * mega_internal_done()
- * @scmd - internal scsi command
- *
- * Callback routine for internal commands.
- */
-static void
-mega_internal_done(Scsi_Cmnd *scmd)
-{
-	adapter_t	*adapter;
-
-	adapter = (adapter_t *)scmd->device->host->hostdata;
-
-	complete(&adapter->int_waitq);
-
-}
-
-
 static struct scsi_host_template megaraid_template = {
 	.module				= THIS_MODULE,
 	.name				= "MegaRAID",

commit 54b2b50c20a61b51199bedb6e5d2f8ec2568fb43
Author: Martin K. Petersen <martin.petersen@oracle.com>
Date:   Wed Oct 23 06:25:40 2013 -0400

    [SCSI] Disable WRITE SAME for RAID and virtual host adapter drivers
    
    Some host adapters do not pass commands through to the target disk
    directly. Instead they provide an emulated target which may or may not
    accurately report its capabilities. In some cases the physical device
    characteristics are reported even when the host adapter is processing
    commands on the device's behalf. This can lead to adapter firmware hangs
    or excessive I/O errors.
    
    This patch disables WRITE SAME for devices connected to host adapters
    that provide an emulated target. Driver writers can disable WRITE SAME
    by setting the no_write_same flag in the host adapter template.
    
    [jejb: fix up rejections due to eh_deadline patch]
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>
    Cc: stable@kernel.org
    Signed-off-by: James Bottomley <JBottomley@Parallels.com>

diff --git a/drivers/scsi/megaraid.c b/drivers/scsi/megaraid.c
index 90c95a3385d1..816db12ef5d5 100644
--- a/drivers/scsi/megaraid.c
+++ b/drivers/scsi/megaraid.c
@@ -4244,6 +4244,7 @@ static struct scsi_host_template megaraid_template = {
 	.eh_device_reset_handler	= megaraid_reset,
 	.eh_bus_reset_handler		= megaraid_reset,
 	.eh_host_reset_handler		= megaraid_reset,
+	.no_write_same			= 1,
 };
 
 static int

commit 8b1fce04dc2a2210f050484afa85acc3a81cfbba
Author: Gu Zheng <guz.fnst@cn.fujitsu.com>
Date:   Sat May 25 21:48:31 2013 +0800

    PCI: Convert alloc_pci_dev(void) to pci_alloc_dev(bus)
    
    Use the new pci_alloc_dev(bus) to replace the existing using of
    alloc_pci_dev(void).
    
    [bhelgaas: drop pci_bus ref later in pci_release_dev()]
    Signed-off-by: Gu Zheng <guz.fnst@cn.fujitsu.com>
    Signed-off-by: Jiang Liu <jiang.liu@huawei.com>
    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>
    Cc: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Cc: Paul Mackerras <paulus@samba.org>
    Cc: "David S. Miller" <davem@davemloft.net>
    Cc: David Airlie <airlied@linux.ie>
    Cc: Neela Syam Kolli <megaraidlinux@lsi.com>
    Cc: "James E.J. Bottomley" <JBottomley@parallels.com>
    Cc: Yinghai Lu <yinghai@kernel.org>
    Cc: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Cc: Andrew Morton <akpm@linux-foundation.org>

diff --git a/drivers/scsi/megaraid.c b/drivers/scsi/megaraid.c
index 846f475f62c1..90c95a3385d1 100644
--- a/drivers/scsi/megaraid.c
+++ b/drivers/scsi/megaraid.c
@@ -2026,7 +2026,7 @@ megaraid_abort_and_reset(adapter_t *adapter, Scsi_Cmnd *cmd, int aor)
 static inline int
 make_local_pdev(adapter_t *adapter, struct pci_dev **pdev)
 {
-	*pdev = alloc_pci_dev();
+	*pdev = pci_alloc_dev(NULL);
 
 	if( *pdev == NULL ) return -1;
 

commit 9bec8a7401841be71b9bbd4110edf9da4cb5f39d
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Sun May 5 00:15:15 2013 -0400

    megaraid: single_open() leak
    
    Cc: stable@vger.kernel.org
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/drivers/scsi/megaraid.c b/drivers/scsi/megaraid.c
index 7373255aa1e8..846f475f62c1 100644
--- a/drivers/scsi/megaraid.c
+++ b/drivers/scsi/megaraid.c
@@ -2770,7 +2770,7 @@ static const struct file_operations mega_proc_fops = {
 	.open		= mega_proc_open,
 	.read		= seq_read,
 	.llseek		= seq_lseek,
-	.release	= seq_release,
+	.release	= single_release,
 };
 
 /*

commit 4a520d2769beb736ba2bd084b8293ce148a1a7ae
Author: David Howells <dhowells@redhat.com>
Date:   Fri Apr 12 14:06:01 2013 +0100

    proc: Supply an accessor for getting the data from a PDE's parent
    
    Supply an accessor function for getting the private data from the parent
    proc_dir_entry struct of the proc_dir_entry struct associated with an inode.
    
    ReiserFS, for instance, stores the super_block pointer in the proc directory
    it makes for that super_block, and a pointer to the respective seq_file show
    function in each of the proc files in that directory.
    
    This allows a reduction in the number of file_operations structs, open
    functions and seq_operations structs required.  The problem otherwise is that
    each show function requires two pieces of data but only has storage for one
    per PDE (and this has no release function).
    
    Signed-off-by: David Howells <dhowells@redhat.com>
    Acked-by: Mauro Carvalho Chehab <mchehab@redhat.com>
    Acked-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    cc: Jerry Chuang <jerry-chuang@realtek.com>
    cc: Maxim Mikityanskiy <maxtram95@gmail.com>
    cc: YAMANE Toshiaki <yamanetoshi@gmail.com>
    cc: linux-wireless@vger.kernel.org
    cc: linux-scsi@vger.kernel.org
    cc: devel@driverdev.osuosl.org
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/drivers/scsi/megaraid.c b/drivers/scsi/megaraid.c
index ef3384d39e11..7373255aa1e8 100644
--- a/drivers/scsi/megaraid.c
+++ b/drivers/scsi/megaraid.c
@@ -2760,7 +2760,7 @@ proc_show_rdrv_40(struct seq_file *m, void *v)
  */
 static int mega_proc_open(struct inode *inode, struct file *file)
 {
-	adapter_t *adapter = PDE(inode)->parent->data;
+	adapter_t *adapter = proc_get_parent_data(inode);
 	int (*show)(struct seq_file *, void *) = PDE_DATA(inode);
 
 	return single_open(file, show, adapter);

commit 270b5ac2151707c25d3327722c5badfbd95945bc
Author: David Howells <dhowells@redhat.com>
Date:   Fri Apr 12 02:48:30 2013 +0100

    proc: Add proc_mkdir_data()
    
    Add proc_mkdir_data() to allow procfs directories to be created that are
    annotated at the time of creation with private data rather than doing this
    post-creation.  This means no access is then required to the proc_dir_entry
    struct to set this.
    
    Signed-off-by: David Howells <dhowells@redhat.com>
    Acked-by: Mauro Carvalho Chehab <mchehab@redhat.com>
    Acked-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    cc: Neela Syam Kolli <megaraidlinux@lsi.com>
    cc: Jerry Chuang <jerry-chuang@realtek.com>
    cc: linux-scsi@vger.kernel.org
    cc: devel@driverdev.osuosl.org
    cc: linux-wireless@vger.kernel.org
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/drivers/scsi/megaraid.c b/drivers/scsi/megaraid.c
index a1c90bd34e78..ef3384d39e11 100644
--- a/drivers/scsi/megaraid.c
+++ b/drivers/scsi/megaraid.c
@@ -2818,12 +2818,12 @@ mega_create_proc_entry(int index, struct proc_dir_entry *parent)
 
 	sprintf(string, "hba%d", adapter->host->host_no);
 
-	dir = adapter->controller_proc_dir_entry = proc_mkdir(string, parent);
+	dir = adapter->controller_proc_dir_entry =
+		proc_mkdir_data(string, 0, parent, adapter);
 	if(!dir) {
 		printk(KERN_WARNING "\nmegaraid: proc_mkdir failed\n");
 		return;
 	}
-	dir->data = adapter;
 
 	for (f = mega_proc_files; f->name; f++) {
 		de = proc_create_data(f->name, S_IRUSR, dir, &mega_proc_fops,

commit c7f079ca30bc719f6f09524fb2119980c4b45d8f
Author: David Howells <dhowells@redhat.com>
Date:   Wed Apr 10 13:33:21 2013 +0100

    megaraid: Don't use create_proc_read_entry()
    
    Don't use create_proc_read_entry() as that is deprecated, but rather use
    proc_create_data() and seq_file instead.
    
    Signed-off-by: David Howells <dhowells@redhat.com>
    cc: Neela Syam Kolli <megaraidlinux@lsi.com>
    cc: James E.J. Bottomley <JBottomley@parallels.com>
    cc: linux-scsi@vger.kernel.org
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/drivers/scsi/megaraid.c b/drivers/scsi/megaraid.c
index 9504ec0ec682..a1c90bd34e78 100644
--- a/drivers/scsi/megaraid.c
+++ b/drivers/scsi/megaraid.c
@@ -39,6 +39,7 @@
 #include <linux/completion.h>
 #include <linux/delay.h>
 #include <linux/proc_fs.h>
+#include <linux/seq_file.h>
 #include <linux/reboot.h>
 #include <linux/module.h>
 #include <linux/list.h>
@@ -2069,385 +2070,201 @@ mega_free_inquiry(void *inquiry, dma_addr_t dma_handle, struct pci_dev *pdev)
 #ifdef CONFIG_PROC_FS
 /* Following code handles /proc fs  */
 
-#define CREATE_READ_PROC(string, func)	create_proc_read_entry(string,	\
-					S_IRUSR | S_IFREG,		\
-					controller_proc_dir_entry,	\
-					func, adapter)
-
-/**
- * mega_create_proc_entry()
- * @index - index in soft state array
- * @parent - parent node for this /proc entry
- *
- * Creates /proc entries for our controllers.
- */
-static void
-mega_create_proc_entry(int index, struct proc_dir_entry *parent)
-{
-	struct proc_dir_entry	*controller_proc_dir_entry = NULL;
-	u8		string[64] = { 0 };
-	adapter_t	*adapter = hba_soft_state[index];
-
-	sprintf(string, "hba%d", adapter->host->host_no);
-
-	controller_proc_dir_entry =
-		adapter->controller_proc_dir_entry = proc_mkdir(string, parent);
-
-	if(!controller_proc_dir_entry) {
-		printk(KERN_WARNING "\nmegaraid: proc_mkdir failed\n");
-		return;
-	}
-	adapter->proc_read = CREATE_READ_PROC("config", proc_read_config);
-	adapter->proc_stat = CREATE_READ_PROC("stat", proc_read_stat);
-	adapter->proc_mbox = CREATE_READ_PROC("mailbox", proc_read_mbox);
-#if MEGA_HAVE_ENH_PROC
-	adapter->proc_rr = CREATE_READ_PROC("rebuild-rate", proc_rebuild_rate);
-	adapter->proc_battery = CREATE_READ_PROC("battery-status",
-			proc_battery);
-
-	/*
-	 * Display each physical drive on its channel
-	 */
-	adapter->proc_pdrvstat[0] = CREATE_READ_PROC("diskdrives-ch0",
-					proc_pdrv_ch0);
-	adapter->proc_pdrvstat[1] = CREATE_READ_PROC("diskdrives-ch1",
-					proc_pdrv_ch1);
-	adapter->proc_pdrvstat[2] = CREATE_READ_PROC("diskdrives-ch2",
-					proc_pdrv_ch2);
-	adapter->proc_pdrvstat[3] = CREATE_READ_PROC("diskdrives-ch3",
-					proc_pdrv_ch3);
-
-	/*
-	 * Display a set of up to 10 logical drive through each of following
-	 * /proc entries
-	 */
-	adapter->proc_rdrvstat[0] = CREATE_READ_PROC("raiddrives-0-9",
-					proc_rdrv_10);
-	adapter->proc_rdrvstat[1] = CREATE_READ_PROC("raiddrives-10-19",
-					proc_rdrv_20);
-	adapter->proc_rdrvstat[2] = CREATE_READ_PROC("raiddrives-20-29",
-					proc_rdrv_30);
-	adapter->proc_rdrvstat[3] = CREATE_READ_PROC("raiddrives-30-39",
-					proc_rdrv_40);
-#endif
-}
-
-
 /**
- * proc_read_config()
- * @page - buffer to write the data in
- * @start - where the actual data has been written in page
- * @offset - same meaning as the read system call
- * @count - same meaning as the read system call
- * @eof - set if no more data needs to be returned
- * @data - pointer to our soft state
+ * proc_show_config()
+ * @m - Synthetic file construction data
+ * @v - File iterator
  *
  * Display configuration information about the controller.
  */
 static int
-proc_read_config(char *page, char **start, off_t offset, int count, int *eof,
-		void *data)
+proc_show_config(struct seq_file *m, void *v)
 {
 
-	adapter_t *adapter = (adapter_t *)data;
-	int len = 0;
-
-	len += sprintf(page+len, "%s", MEGARAID_VERSION);
+	adapter_t *adapter = m->private;
 
+	seq_puts(m, MEGARAID_VERSION);
 	if(adapter->product_info.product_name[0])
-		len += sprintf(page+len, "%s\n",
-				adapter->product_info.product_name);
-
-	len += sprintf(page+len, "Controller Type: ");
+		seq_printf(m, "%s\n", adapter->product_info.product_name);
 
-	if( adapter->flag & BOARD_MEMMAP ) {
-		len += sprintf(page+len,
-			"438/466/467/471/493/518/520/531/532\n");
-	}
-	else {
-		len += sprintf(page+len,
-			"418/428/434\n");
-	}
+	seq_puts(m, "Controller Type: ");
 
-	if(adapter->flag & BOARD_40LD) {
-		len += sprintf(page+len,
-				"Controller Supports 40 Logical Drives\n");
-	}
+	if( adapter->flag & BOARD_MEMMAP )
+		seq_puts(m, "438/466/467/471/493/518/520/531/532\n");
+	else
+		seq_puts(m, "418/428/434\n");
 
-	if(adapter->flag & BOARD_64BIT) {
-		len += sprintf(page+len,
-		"Controller capable of 64-bit memory addressing\n");
-	}
-	if( adapter->has_64bit_addr ) {
-		len += sprintf(page+len,
-			"Controller using 64-bit memory addressing\n");
-	}
-	else {
-		len += sprintf(page+len,
-			"Controller is not using 64-bit memory addressing\n");
-	}
+	if(adapter->flag & BOARD_40LD)
+		seq_puts(m, "Controller Supports 40 Logical Drives\n");
 
-	len += sprintf(page+len, "Base = %08lx, Irq = %d, ", adapter->base,
-			adapter->host->irq);
-
-	len += sprintf(page+len, "Logical Drives = %d, Channels = %d\n",
-			adapter->numldrv, adapter->product_info.nchannels);
-
-	len += sprintf(page+len, "Version =%s:%s, DRAM = %dMb\n",
-			adapter->fw_version, adapter->bios_version,
-			adapter->product_info.dram_size);
-
-	len += sprintf(page+len,
-		"Controller Queue Depth = %d, Driver Queue Depth = %d\n",
-		adapter->product_info.max_commands, adapter->max_cmds);
-
-	len += sprintf(page+len, "support_ext_cdb    = %d\n",
-			adapter->support_ext_cdb);
-	len += sprintf(page+len, "support_random_del = %d\n",
-			adapter->support_random_del);
-	len += sprintf(page+len, "boot_ldrv_enabled  = %d\n",
-			adapter->boot_ldrv_enabled);
-	len += sprintf(page+len, "boot_ldrv          = %d\n",
-			adapter->boot_ldrv);
-	len += sprintf(page+len, "boot_pdrv_enabled  = %d\n",
-			adapter->boot_pdrv_enabled);
-	len += sprintf(page+len, "boot_pdrv_ch       = %d\n",
-			adapter->boot_pdrv_ch);
-	len += sprintf(page+len, "boot_pdrv_tgt      = %d\n",
-			adapter->boot_pdrv_tgt);
-	len += sprintf(page+len, "quiescent          = %d\n",
-			atomic_read(&adapter->quiescent));
-	len += sprintf(page+len, "has_cluster        = %d\n",
-			adapter->has_cluster);
-
-	len += sprintf(page+len, "\nModule Parameters:\n");
-	len += sprintf(page+len, "max_cmd_per_lun    = %d\n",
-			max_cmd_per_lun);
-	len += sprintf(page+len, "max_sectors_per_io = %d\n",
-			max_sectors_per_io);
-
-	*eof = 1;
-
-	return len;
+	if(adapter->flag & BOARD_64BIT)
+		seq_puts(m, "Controller capable of 64-bit memory addressing\n");
+	if( adapter->has_64bit_addr )
+		seq_puts(m, "Controller using 64-bit memory addressing\n");
+	else
+		seq_puts(m, "Controller is not using 64-bit memory addressing\n");
+
+	seq_printf(m, "Base = %08lx, Irq = %d, ",
+		   adapter->base, adapter->host->irq);
+
+	seq_printf(m, "Logical Drives = %d, Channels = %d\n",
+		   adapter->numldrv, adapter->product_info.nchannels);
+
+	seq_printf(m, "Version =%s:%s, DRAM = %dMb\n",
+		   adapter->fw_version, adapter->bios_version,
+		   adapter->product_info.dram_size);
+
+	seq_printf(m, "Controller Queue Depth = %d, Driver Queue Depth = %d\n",
+		   adapter->product_info.max_commands, adapter->max_cmds);
+
+	seq_printf(m, "support_ext_cdb    = %d\n", adapter->support_ext_cdb);
+	seq_printf(m, "support_random_del = %d\n", adapter->support_random_del);
+	seq_printf(m, "boot_ldrv_enabled  = %d\n", adapter->boot_ldrv_enabled);
+	seq_printf(m, "boot_ldrv          = %d\n", adapter->boot_ldrv);
+	seq_printf(m, "boot_pdrv_enabled  = %d\n", adapter->boot_pdrv_enabled);
+	seq_printf(m, "boot_pdrv_ch       = %d\n", adapter->boot_pdrv_ch);
+	seq_printf(m, "boot_pdrv_tgt      = %d\n", adapter->boot_pdrv_tgt);
+	seq_printf(m, "quiescent          = %d\n",
+		   atomic_read(&adapter->quiescent));
+	seq_printf(m, "has_cluster        = %d\n", adapter->has_cluster);
+
+	seq_puts(m, "\nModule Parameters:\n");
+	seq_printf(m, "max_cmd_per_lun    = %d\n", max_cmd_per_lun);
+	seq_printf(m, "max_sectors_per_io = %d\n", max_sectors_per_io);
+	return 0;
 }
 
-
-
 /**
- * proc_read_stat()
- * @page - buffer to write the data in
- * @start - where the actual data has been written in page
- * @offset - same meaning as the read system call
- * @count - same meaning as the read system call
- * @eof - set if no more data needs to be returned
- * @data - pointer to our soft state
+ * proc_show_stat()
+ * @m - Synthetic file construction data
+ * @v - File iterator
  *
- * Diaplay statistical information about the I/O activity.
+ * Display statistical information about the I/O activity.
  */
 static int
-proc_read_stat(char *page, char **start, off_t offset, int count, int *eof,
-		void *data)
+proc_show_stat(struct seq_file *m, void *v)
 {
-	adapter_t	*adapter;
-	int	len;
+	adapter_t *adapter = m->private;
+#if MEGA_HAVE_STATS
 	int	i;
+#endif
 
-	i = 0;	/* avoid compilation warnings */
-	len = 0;
-	adapter = (adapter_t *)data;
-
-	len = sprintf(page, "Statistical Information for this controller\n");
-	len += sprintf(page+len, "pend_cmds = %d\n",
-			atomic_read(&adapter->pend_cmds));
+	seq_puts(m, "Statistical Information for this controller\n");
+	seq_printf(m, "pend_cmds = %d\n", atomic_read(&adapter->pend_cmds));
 #if MEGA_HAVE_STATS
 	for(i = 0; i < adapter->numldrv; i++) {
-		len += sprintf(page+len, "Logical Drive %d:\n", i);
-
-		len += sprintf(page+len,
-			"\tReads Issued = %lu, Writes Issued = %lu\n",
-			adapter->nreads[i], adapter->nwrites[i]);
-
-		len += sprintf(page+len,
-			"\tSectors Read = %lu, Sectors Written = %lu\n",
-			adapter->nreadblocks[i], adapter->nwriteblocks[i]);
-
-		len += sprintf(page+len,
-			"\tRead errors = %lu, Write errors = %lu\n\n",
-			adapter->rd_errors[i], adapter->wr_errors[i]);
+		seq_printf(m, "Logical Drive %d:\n", i);
+		seq_printf(m, "\tReads Issued = %lu, Writes Issued = %lu\n",
+			   adapter->nreads[i], adapter->nwrites[i]);
+		seq_printf(m, "\tSectors Read = %lu, Sectors Written = %lu\n",
+			   adapter->nreadblocks[i], adapter->nwriteblocks[i]);
+		seq_printf(m, "\tRead errors = %lu, Write errors = %lu\n\n",
+			   adapter->rd_errors[i], adapter->wr_errors[i]);
 	}
 #else
-	len += sprintf(page+len,
-			"IO and error counters not compiled in driver.\n");
+	seq_puts(m, "IO and error counters not compiled in driver.\n");
 #endif
-
-	*eof = 1;
-
-	return len;
+	return 0;
 }
 
 
 /**
- * proc_read_mbox()
- * @page - buffer to write the data in
- * @start - where the actual data has been written in page
- * @offset - same meaning as the read system call
- * @count - same meaning as the read system call
- * @eof - set if no more data needs to be returned
- * @data - pointer to our soft state
+ * proc_show_mbox()
+ * @m - Synthetic file construction data
+ * @v - File iterator
  *
  * Display mailbox information for the last command issued. This information
  * is good for debugging.
  */
 static int
-proc_read_mbox(char *page, char **start, off_t offset, int count, int *eof,
-		void *data)
+proc_show_mbox(struct seq_file *m, void *v)
 {
-
-	adapter_t	*adapter = (adapter_t *)data;
+	adapter_t	*adapter = m->private;
 	volatile mbox_t	*mbox = adapter->mbox;
-	int	len = 0;
-
-	len = sprintf(page, "Contents of Mail Box Structure\n");
-	len += sprintf(page+len, "  Fw Command   = 0x%02x\n", 
-			mbox->m_out.cmd);
-	len += sprintf(page+len, "  Cmd Sequence = 0x%02x\n", 
-			mbox->m_out.cmdid);
-	len += sprintf(page+len, "  No of Sectors= %04d\n", 
-			mbox->m_out.numsectors);
-	len += sprintf(page+len, "  LBA          = 0x%02x\n", 
-			mbox->m_out.lba);
-	len += sprintf(page+len, "  DTA          = 0x%08x\n", 
-			mbox->m_out.xferaddr);
-	len += sprintf(page+len, "  Logical Drive= 0x%02x\n", 
-			mbox->m_out.logdrv);
-	len += sprintf(page+len, "  No of SG Elmt= 0x%02x\n",
-			mbox->m_out.numsgelements);
-	len += sprintf(page+len, "  Busy         = %01x\n", 
-			mbox->m_in.busy);
-	len += sprintf(page+len, "  Status       = 0x%02x\n", 
-			mbox->m_in.status);
-
-	*eof = 1;
-
-	return len;
+
+	seq_puts(m, "Contents of Mail Box Structure\n");
+	seq_printf(m, "  Fw Command   = 0x%02x\n", mbox->m_out.cmd);
+	seq_printf(m, "  Cmd Sequence = 0x%02x\n", mbox->m_out.cmdid);
+	seq_printf(m, "  No of Sectors= %04d\n", mbox->m_out.numsectors);
+	seq_printf(m, "  LBA          = 0x%02x\n", mbox->m_out.lba);
+	seq_printf(m, "  DTA          = 0x%08x\n", mbox->m_out.xferaddr);
+	seq_printf(m, "  Logical Drive= 0x%02x\n", mbox->m_out.logdrv);
+	seq_printf(m, "  No of SG Elmt= 0x%02x\n", mbox->m_out.numsgelements);
+	seq_printf(m, "  Busy         = %01x\n", mbox->m_in.busy);
+	seq_printf(m, "  Status       = 0x%02x\n", mbox->m_in.status);
+	return 0;
 }
 
 
 /**
- * proc_rebuild_rate()
- * @page - buffer to write the data in
- * @start - where the actual data has been written in page
- * @offset - same meaning as the read system call
- * @count - same meaning as the read system call
- * @eof - set if no more data needs to be returned
- * @data - pointer to our soft state
+ * proc_show_rebuild_rate()
+ * @m - Synthetic file construction data
+ * @v - File iterator
  *
  * Display current rebuild rate
  */
 static int
-proc_rebuild_rate(char *page, char **start, off_t offset, int count, int *eof,
-		void *data)
+proc_show_rebuild_rate(struct seq_file *m, void *v)
 {
-	adapter_t	*adapter = (adapter_t *)data;
+	adapter_t	*adapter = m->private;
 	dma_addr_t	dma_handle;
 	caddr_t		inquiry;
 	struct pci_dev	*pdev;
-	int	len = 0;
 
-	if( make_local_pdev(adapter, &pdev) != 0 ) {
-		*eof = 1;
-		return len;
-	}
+	if( make_local_pdev(adapter, &pdev) != 0 )
+		return 0;
 
-	if( (inquiry = mega_allocate_inquiry(&dma_handle, pdev)) == NULL ) {
-		free_local_pdev(pdev);
-		*eof = 1;
-		return len;
-	}
+	if( (inquiry = mega_allocate_inquiry(&dma_handle, pdev)) == NULL )
+		goto free_pdev;
 
 	if( mega_adapinq(adapter, dma_handle) != 0 ) {
-
-		len = sprintf(page, "Adapter inquiry failed.\n");
-
+		seq_puts(m, "Adapter inquiry failed.\n");
 		printk(KERN_WARNING "megaraid: inquiry failed.\n");
-
-		mega_free_inquiry(inquiry, dma_handle, pdev);
-
-		free_local_pdev(pdev);
-
-		*eof = 1;
-
-		return len;
+		goto free_inquiry;
 	}
 
-	if( adapter->flag & BOARD_40LD ) {
-		len = sprintf(page, "Rebuild Rate: [%d%%]\n",
-			((mega_inquiry3 *)inquiry)->rebuild_rate);
-	}
-	else {
-		len = sprintf(page, "Rebuild Rate: [%d%%]\n",
+	if( adapter->flag & BOARD_40LD )
+		seq_printf(m, "Rebuild Rate: [%d%%]\n",
+			   ((mega_inquiry3 *)inquiry)->rebuild_rate);
+	else
+		seq_printf(m, "Rebuild Rate: [%d%%]\n",
 			((mraid_ext_inquiry *)
-			inquiry)->raid_inq.adapter_info.rebuild_rate);
-	}
-
+			 inquiry)->raid_inq.adapter_info.rebuild_rate);
 
+free_inquiry:
 	mega_free_inquiry(inquiry, dma_handle, pdev);
-
+free_pdev:
 	free_local_pdev(pdev);
-
-	*eof = 1;
-
-	return len;
+	return 0;
 }
 
 
 /**
- * proc_battery()
- * @page - buffer to write the data in
- * @start - where the actual data has been written in page
- * @offset - same meaning as the read system call
- * @count - same meaning as the read system call
- * @eof - set if no more data needs to be returned
- * @data - pointer to our soft state
+ * proc_show_battery()
+ * @m - Synthetic file construction data
+ * @v - File iterator
  *
  * Display information about the battery module on the controller.
  */
 static int
-proc_battery(char *page, char **start, off_t offset, int count, int *eof,
-		void *data)
+proc_show_battery(struct seq_file *m, void *v)
 {
-	adapter_t	*adapter = (adapter_t *)data;
+	adapter_t	*adapter = m->private;
 	dma_addr_t	dma_handle;
 	caddr_t		inquiry;
 	struct pci_dev	*pdev;
-	u8	battery_status = 0;
-	char	str[256];
-	int	len = 0;
+	u8	battery_status;
 
-	if( make_local_pdev(adapter, &pdev) != 0 ) {
-		*eof = 1;
-		return len;
-	}
+	if( make_local_pdev(adapter, &pdev) != 0 )
+		return 0;
 
-	if( (inquiry = mega_allocate_inquiry(&dma_handle, pdev)) == NULL ) {
-		free_local_pdev(pdev);
-		*eof = 1;
-		return len;
-	}
+	if( (inquiry = mega_allocate_inquiry(&dma_handle, pdev)) == NULL )
+		goto free_pdev;
 
 	if( mega_adapinq(adapter, dma_handle) != 0 ) {
-
-		len = sprintf(page, "Adapter inquiry failed.\n");
-
+		seq_printf(m, "Adapter inquiry failed.\n");
 		printk(KERN_WARNING "megaraid: inquiry failed.\n");
-
-		mega_free_inquiry(inquiry, dma_handle, pdev);
-
-		free_local_pdev(pdev);
-
-		*eof = 1;
-
-		return len;
+		goto free_inquiry;
 	}
 
 	if( adapter->flag & BOARD_40LD ) {
@@ -2461,146 +2278,80 @@ proc_battery(char *page, char **start, off_t offset, int count, int *eof,
 	/*
 	 * Decode the battery status
 	 */
-	sprintf(str, "Battery Status:[%d]", battery_status);
+	seq_printf(m, "Battery Status:[%d]", battery_status);
 
 	if(battery_status == MEGA_BATT_CHARGE_DONE)
-		strcat(str, " Charge Done");
+		seq_puts(m, " Charge Done");
 
 	if(battery_status & MEGA_BATT_MODULE_MISSING)
-		strcat(str, " Module Missing");
+		seq_puts(m, " Module Missing");
 	
 	if(battery_status & MEGA_BATT_LOW_VOLTAGE)
-		strcat(str, " Low Voltage");
+		seq_puts(m, " Low Voltage");
 	
 	if(battery_status & MEGA_BATT_TEMP_HIGH)
-		strcat(str, " Temperature High");
+		seq_puts(m, " Temperature High");
 	
 	if(battery_status & MEGA_BATT_PACK_MISSING)
-		strcat(str, " Pack Missing");
+		seq_puts(m, " Pack Missing");
 	
 	if(battery_status & MEGA_BATT_CHARGE_INPROG)
-		strcat(str, " Charge In-progress");
+		seq_puts(m, " Charge In-progress");
 	
 	if(battery_status & MEGA_BATT_CHARGE_FAIL)
-		strcat(str, " Charge Fail");
+		seq_puts(m, " Charge Fail");
 	
 	if(battery_status & MEGA_BATT_CYCLES_EXCEEDED)
-		strcat(str, " Cycles Exceeded");
-
-	len = sprintf(page, "%s\n", str);
+		seq_puts(m, " Cycles Exceeded");
 
+	seq_putc(m, '\n');
 
+free_inquiry:
 	mega_free_inquiry(inquiry, dma_handle, pdev);
-
+free_pdev:
 	free_local_pdev(pdev);
-
-	*eof = 1;
-
-	return len;
-}
-
-
-/**
- * proc_pdrv_ch0()
- * @page - buffer to write the data in
- * @start - where the actual data has been written in page
- * @offset - same meaning as the read system call
- * @count - same meaning as the read system call
- * @eof - set if no more data needs to be returned
- * @data - pointer to our soft state
- *
- * Display information about the physical drives on physical channel 0.
- */
-static int
-proc_pdrv_ch0(char *page, char **start, off_t offset, int count, int *eof,
-		void *data)
-{
-	adapter_t *adapter = (adapter_t *)data;
-
-	*eof = 1;
-
-	return (proc_pdrv(adapter, page, 0));
-}
-
-
-/**
- * proc_pdrv_ch1()
- * @page - buffer to write the data in
- * @start - where the actual data has been written in page
- * @offset - same meaning as the read system call
- * @count - same meaning as the read system call
- * @eof - set if no more data needs to be returned
- * @data - pointer to our soft state
- *
- * Display information about the physical drives on physical channel 1.
- */
-static int
-proc_pdrv_ch1(char *page, char **start, off_t offset, int count, int *eof,
-		void *data)
-{
-	adapter_t *adapter = (adapter_t *)data;
-
-	*eof = 1;
-
-	return (proc_pdrv(adapter, page, 1));
+	return 0;
 }
 
 
-/**
- * proc_pdrv_ch2()
- * @page - buffer to write the data in
- * @start - where the actual data has been written in page
- * @offset - same meaning as the read system call
- * @count - same meaning as the read system call
- * @eof - set if no more data needs to be returned
- * @data - pointer to our soft state
- *
- * Display information about the physical drives on physical channel 2.
+/*
+ * Display scsi inquiry
  */
-static int
-proc_pdrv_ch2(char *page, char **start, off_t offset, int count, int *eof,
-		void *data)
+static void
+mega_print_inquiry(struct seq_file *m, char *scsi_inq)
 {
-	adapter_t *adapter = (adapter_t *)data;
-
-	*eof = 1;
-
-	return (proc_pdrv(adapter, page, 2));
-}
+	int	i;
 
+	seq_puts(m, "  Vendor: ");
+	seq_write(m, scsi_inq + 8, 8);
+	seq_puts(m, "  Model: ");
+	seq_write(m, scsi_inq + 16, 16);
+	seq_puts(m, "  Rev: ");
+	seq_write(m, scsi_inq + 32, 4);
+	seq_putc(m, '\n');
 
-/**
- * proc_pdrv_ch3()
- * @page - buffer to write the data in
- * @start - where the actual data has been written in page
- * @offset - same meaning as the read system call
- * @count - same meaning as the read system call
- * @eof - set if no more data needs to be returned
- * @data - pointer to our soft state
- *
- * Display information about the physical drives on physical channel 3.
- */
-static int
-proc_pdrv_ch3(char *page, char **start, off_t offset, int count, int *eof,
-		void *data)
-{
-	adapter_t *adapter = (adapter_t *)data;
+	i = scsi_inq[0] & 0x1f;
+	seq_printf(m, "  Type:   %s ", scsi_device_type(i));
 
-	*eof = 1;
+	seq_printf(m, "                 ANSI SCSI revision: %02x",
+		   scsi_inq[2] & 0x07);
 
-	return (proc_pdrv(adapter, page, 3));
+	if( (scsi_inq[2] & 0x07) == 1 && (scsi_inq[3] & 0x0f) == 1 )
+		seq_puts(m, " CCS\n");
+	else
+		seq_putc(m, '\n');
 }
 
-
 /**
- * proc_pdrv()
+ * proc_show_pdrv()
+ * @m - Synthetic file construction data
  * @page - buffer to write the data in
  * @adapter - pointer to our soft state
  *
  * Display information about the physical drives.
  */
 static int
-proc_pdrv(adapter_t *adapter, char *page, int channel)
+proc_show_pdrv(struct seq_file *m, adapter_t *adapter, int channel)
 {
 	dma_addr_t	dma_handle;
 	char		*scsi_inq;
@@ -2611,32 +2362,24 @@ proc_pdrv(adapter_t *adapter, char *page, int channel)
 	u8	state;
 	int	tgt;
 	int	max_channels;
-	int	len = 0;
-	char	str[80];
 	int	i;
 
-	if( make_local_pdev(adapter, &pdev) != 0 ) {
-		return len;
-	}
+	if( make_local_pdev(adapter, &pdev) != 0 )
+		return 0;
 
-	if( (inquiry = mega_allocate_inquiry(&dma_handle, pdev)) == NULL ) {
+	if( (inquiry = mega_allocate_inquiry(&dma_handle, pdev)) == NULL )
 		goto free_pdev;
-	}
 
 	if( mega_adapinq(adapter, dma_handle) != 0 ) {
-		len = sprintf(page, "Adapter inquiry failed.\n");
-
+		seq_puts(m, "Adapter inquiry failed.\n");
 		printk(KERN_WARNING "megaraid: inquiry failed.\n");
-
 		goto free_inquiry;
 	}
 
 
 	scsi_inq = pci_alloc_consistent(pdev, 256, &scsi_inq_dma_handle);
-
 	if( scsi_inq == NULL ) {
-		len = sprintf(page, "memory not available for scsi inq.\n");
-
+		seq_puts(m, "memory not available for scsi inq.\n");
 		goto free_inquiry;
 	}
 
@@ -2659,39 +2402,31 @@ proc_pdrv(adapter_t *adapter, char *page, int channel)
 		i = channel*16 + tgt;
 
 		state = *(pdrv_state + i);
-
 		switch( state & 0x0F ) {
-
 		case PDRV_ONLINE:
-			sprintf(str,
-			"Channel:%2d Id:%2d State: Online",
-				channel, tgt);
+			seq_printf(m, "Channel:%2d Id:%2d State: Online",
+				   channel, tgt);
 			break;
 
 		case PDRV_FAILED:
-			sprintf(str,
-			"Channel:%2d Id:%2d State: Failed",
-				channel, tgt);
+			seq_printf(m, "Channel:%2d Id:%2d State: Failed",
+				   channel, tgt);
 			break;
 
 		case PDRV_RBLD:
-			sprintf(str,
-			"Channel:%2d Id:%2d State: Rebuild",
-				channel, tgt);
+			seq_printf(m, "Channel:%2d Id:%2d State: Rebuild",
+				   channel, tgt);
 			break;
 
 		case PDRV_HOTSPARE:
-			sprintf(str,
-			"Channel:%2d Id:%2d State: Hot spare",
-				channel, tgt);
+			seq_printf(m, "Channel:%2d Id:%2d State: Hot spare",
+				   channel, tgt);
 			break;
 
 		default:
-			sprintf(str,
-			"Channel:%2d Id:%2d State: Un-configured",
-				channel, tgt);
+			seq_printf(m, "Channel:%2d Id:%2d State: Un-configured",
+				   channel, tgt);
 			break;
-
 		}
 
 		/*
@@ -2710,11 +2445,8 @@ proc_pdrv(adapter_t *adapter, char *page, int channel)
 		 * Check for overflow. We print less than 240
 		 * characters for inquiry
 		 */
-		if( (len + 240) >= PAGE_SIZE ) break;
-
-		len += sprintf(page+len, "%s.\n", str);
-
-		len += mega_print_inquiry(page+len, scsi_inq);
+		seq_puts(m, ".\n");
+		mega_print_inquiry(m, scsi_inq);
 	}
 
 free_pci:
@@ -2723,150 +2455,68 @@ proc_pdrv(adapter_t *adapter, char *page, int channel)
 	mega_free_inquiry(inquiry, dma_handle, pdev);
 free_pdev:
 	free_local_pdev(pdev);
-
-	return len;
-}
-
-
-/*
- * Display scsi inquiry
- */
-static int
-mega_print_inquiry(char *page, char *scsi_inq)
-{
-	int	len = 0;
-	int	i;
-
-	len = sprintf(page, "  Vendor: ");
-	for( i = 8; i < 16; i++ ) {
-		len += sprintf(page+len, "%c", scsi_inq[i]);
-	}
-
-	len += sprintf(page+len, "  Model: ");
-
-	for( i = 16; i < 32; i++ ) {
-		len += sprintf(page+len, "%c", scsi_inq[i]);
-	}
-
-	len += sprintf(page+len, "  Rev: ");
-
-	for( i = 32; i < 36; i++ ) {
-		len += sprintf(page+len, "%c", scsi_inq[i]);
-	}
-
-	len += sprintf(page+len, "\n");
-
-	i = scsi_inq[0] & 0x1f;
-
-	len += sprintf(page+len, "  Type:   %s ", scsi_device_type(i));
-
-	len += sprintf(page+len,
-	"                 ANSI SCSI revision: %02x", scsi_inq[2] & 0x07);
-
-	if( (scsi_inq[2] & 0x07) == 1 && (scsi_inq[3] & 0x0f) == 1 )
-		len += sprintf(page+len, " CCS\n");
-	else
-		len += sprintf(page+len, "\n");
-
-	return len;
+	return 0;
 }
 
-
 /**
- * proc_rdrv_10()
- * @page - buffer to write the data in
- * @start - where the actual data has been written in page
- * @offset - same meaning as the read system call
- * @count - same meaning as the read system call
- * @eof - set if no more data needs to be returned
- * @data - pointer to our soft state
+ * proc_show_pdrv_ch0()
+ * @m - Synthetic file construction data
+ * @v - File iterator
  *
- * Display real time information about the logical drives 0 through 9.
+ * Display information about the physical drives on physical channel 0.
  */
 static int
-proc_rdrv_10(char *page, char **start, off_t offset, int count, int *eof,
-		void *data)
+proc_show_pdrv_ch0(struct seq_file *m, void *v)
 {
-	adapter_t *adapter = (adapter_t *)data;
-
-	*eof = 1;
-
-	return (proc_rdrv(adapter, page, 0, 9));
+	return proc_show_pdrv(m, m->private, 0);
 }
 
 
 /**
- * proc_rdrv_20()
- * @page - buffer to write the data in
- * @start - where the actual data has been written in page
- * @offset - same meaning as the read system call
- * @count - same meaning as the read system call
- * @eof - set if no more data needs to be returned
- * @data - pointer to our soft state
+ * proc_show_pdrv_ch1()
+ * @m - Synthetic file construction data
+ * @v - File iterator
  *
- * Display real time information about the logical drives 0 through 9.
+ * Display information about the physical drives on physical channel 1.
  */
 static int
-proc_rdrv_20(char *page, char **start, off_t offset, int count, int *eof,
-		void *data)
+proc_show_pdrv_ch1(struct seq_file *m, void *v)
 {
-	adapter_t *adapter = (adapter_t *)data;
-
-	*eof = 1;
-
-	return (proc_rdrv(adapter, page, 10, 19));
+	return proc_show_pdrv(m, m->private, 1);
 }
 
 
 /**
- * proc_rdrv_30()
- * @page - buffer to write the data in
- * @start - where the actual data has been written in page
- * @offset - same meaning as the read system call
- * @count - same meaning as the read system call
- * @eof - set if no more data needs to be returned
- * @data - pointer to our soft state
+ * proc_show_pdrv_ch2()
+ * @m - Synthetic file construction data
+ * @v - File iterator
  *
- * Display real time information about the logical drives 0 through 9.
+ * Display information about the physical drives on physical channel 2.
  */
 static int
-proc_rdrv_30(char *page, char **start, off_t offset, int count, int *eof,
-		void *data)
+proc_show_pdrv_ch2(struct seq_file *m, void *v)
 {
-	adapter_t *adapter = (adapter_t *)data;
-
-	*eof = 1;
-
-	return (proc_rdrv(adapter, page, 20, 29));
+	return proc_show_pdrv(m, m->private, 2);
 }
 
 
 /**
- * proc_rdrv_40()
- * @page - buffer to write the data in
- * @start - where the actual data has been written in page
- * @offset - same meaning as the read system call
- * @count - same meaning as the read system call
- * @eof - set if no more data needs to be returned
- * @data - pointer to our soft state
+ * proc_show_pdrv_ch3()
+ * @m - Synthetic file construction data
+ * @v - File iterator
  *
- * Display real time information about the logical drives 0 through 9.
+ * Display information about the physical drives on physical channel 3.
  */
 static int
-proc_rdrv_40(char *page, char **start, off_t offset, int count, int *eof,
-		void *data)
+proc_show_pdrv_ch3(struct seq_file *m, void *v)
 {
-	adapter_t *adapter = (adapter_t *)data;
-
-	*eof = 1;
-
-	return (proc_rdrv(adapter, page, 30, 39));
+	return proc_show_pdrv(m, m->private, 3);
 }
 
 
 /**
- * proc_rdrv()
- * @page - buffer to write the data in
+ * proc_show_rdrv()
+ * @m - Synthetic file construction data
  * @adapter - pointer to our soft state
  * @start - starting logical drive to display
  * @end - ending logical drive to display
@@ -2875,7 +2525,7 @@ proc_rdrv_40(char *page, char **start, off_t offset, int count, int *eof,
  * /proc/scsi/scsi interface
  */
 static int
-proc_rdrv(adapter_t *adapter, char *page, int start, int end )
+proc_show_rdrv(struct seq_file *m, adapter_t *adapter, int start, int end )
 {
 	dma_addr_t	dma_handle;
 	logdrv_param	*lparam;
@@ -2887,29 +2537,18 @@ proc_rdrv(adapter_t *adapter, char *page, int start, int end )
 	u8	*rdrv_state;
 	int	num_ldrv;
 	u32	array_sz;
-	int	len = 0;
 	int	i;
 
-	if( make_local_pdev(adapter, &pdev) != 0 ) {
-		return len;
-	}
+	if( make_local_pdev(adapter, &pdev) != 0 )
+		return 0;
 
-	if( (inquiry = mega_allocate_inquiry(&dma_handle, pdev)) == NULL ) {
-		free_local_pdev(pdev);
-		return len;
-	}
+	if( (inquiry = mega_allocate_inquiry(&dma_handle, pdev)) == NULL )
+		goto free_pdev;
 
 	if( mega_adapinq(adapter, dma_handle) != 0 ) {
-
-		len = sprintf(page, "Adapter inquiry failed.\n");
-
+		seq_puts(m, "Adapter inquiry failed.\n");
 		printk(KERN_WARNING "megaraid: inquiry failed.\n");
-
-		mega_free_inquiry(inquiry, dma_handle, pdev);
-
-		free_local_pdev(pdev);
-
-		return len;
+		goto free_inquiry;
 	}
 
 	memset(&mc, 0, sizeof(megacmd_t));
@@ -2935,13 +2574,8 @@ proc_rdrv(adapter_t *adapter, char *page, int start, int end )
 			&disk_array_dma_handle);
 
 	if( disk_array == NULL ) {
-		len = sprintf(page, "memory not available.\n");
-
-		mega_free_inquiry(inquiry, dma_handle, pdev);
-
-		free_local_pdev(pdev);
-
-		return len;
+		seq_puts(m, "memory not available.\n");
+		goto free_inquiry;
 	}
 
 	mc.xferaddr = (u32)disk_array_dma_handle;
@@ -2951,17 +2585,8 @@ proc_rdrv(adapter_t *adapter, char *page, int start, int end )
 		mc.opcode = OP_DCMD_READ_CONFIG;
 
 		if( mega_internal_command(adapter, &mc, NULL) ) {
-
-			len = sprintf(page, "40LD read config failed.\n");
-
-			mega_free_inquiry(inquiry, dma_handle, pdev);
-
-			pci_free_consistent(pdev, array_sz, disk_array,
-					disk_array_dma_handle);
-
-			free_local_pdev(pdev);
-
-			return len;
+			seq_puts(m, "40LD read config failed.\n");
+			goto free_pci;
 		}
 
 	}
@@ -2969,24 +2594,10 @@ proc_rdrv(adapter_t *adapter, char *page, int start, int end )
 		mc.cmd = NEW_READ_CONFIG_8LD;
 
 		if( mega_internal_command(adapter, &mc, NULL) ) {
-
 			mc.cmd = READ_CONFIG_8LD;
-
-			if( mega_internal_command(adapter, &mc,
-						NULL) ){
-
-				len = sprintf(page,
-					"8LD read config failed.\n");
-
-				mega_free_inquiry(inquiry, dma_handle, pdev);
-
-				pci_free_consistent(pdev, array_sz,
-						disk_array,
-						disk_array_dma_handle);
-
-				free_local_pdev(pdev);
-
-				return len;
+			if( mega_internal_command(adapter, &mc, NULL) ) {
+				seq_puts(m, "8LD read config failed.\n");
+				goto free_pci;
 			}
 		}
 	}
@@ -3006,29 +2617,23 @@ proc_rdrv(adapter_t *adapter, char *page, int start, int end )
 		 * Check for overflow. We print less than 240 characters for
 		 * information about each logical drive.
 		 */
-		if( (len + 240) >= PAGE_SIZE ) break;
-
-		len += sprintf(page+len, "Logical drive:%2d:, ", i);
+		seq_printf(m, "Logical drive:%2d:, ", i);
 
 		switch( rdrv_state[i] & 0x0F ) {
 		case RDRV_OFFLINE:
-			len += sprintf(page+len, "state: offline");
+			seq_puts(m, "state: offline");
 			break;
-
 		case RDRV_DEGRADED:
-			len += sprintf(page+len, "state: degraded");
+			seq_puts(m, "state: degraded");
 			break;
-
 		case RDRV_OPTIMAL:
-			len += sprintf(page+len, "state: optimal");
+			seq_puts(m, "state: optimal");
 			break;
-
 		case RDRV_DELETED:
-			len += sprintf(page+len, "state: deleted");
+			seq_puts(m, "state: deleted");
 			break;
-
 		default:
-			len += sprintf(page+len, "state: unknown");
+			seq_puts(m, "state: unknown");
 			break;
 		}
 
@@ -3036,84 +2641,203 @@ proc_rdrv(adapter_t *adapter, char *page, int start, int end )
 		 * Check if check consistency or initialization is going on
 		 * for this logical drive.
 		 */
-		if( (rdrv_state[i] & 0xF0) == 0x20 ) {
-			len += sprintf(page+len,
-					", check-consistency in progress");
-		}
-		else if( (rdrv_state[i] & 0xF0) == 0x10 ) {
-			len += sprintf(page+len,
-					", initialization in progress");
-		}
+		if( (rdrv_state[i] & 0xF0) == 0x20 )
+			seq_puts(m, ", check-consistency in progress");
+		else if( (rdrv_state[i] & 0xF0) == 0x10 )
+			seq_puts(m, ", initialization in progress");
 		
-		len += sprintf(page+len, "\n");
-
-		len += sprintf(page+len, "Span depth:%3d, ",
-				lparam->span_depth);
-
-		len += sprintf(page+len, "RAID level:%3d, ",
-				lparam->level);
-
-		len += sprintf(page+len, "Stripe size:%3d, ",
-				lparam->stripe_sz ? lparam->stripe_sz/2: 128);
-
-		len += sprintf(page+len, "Row size:%3d\n",
-				lparam->row_size);
+		seq_putc(m, '\n');
 
+		seq_printf(m, "Span depth:%3d, ", lparam->span_depth);
+		seq_printf(m, "RAID level:%3d, ", lparam->level);
+		seq_printf(m, "Stripe size:%3d, ",
+			   lparam->stripe_sz ? lparam->stripe_sz/2: 128);
+		seq_printf(m, "Row size:%3d\n", lparam->row_size);
 
-		len += sprintf(page+len, "Read Policy: ");
-
+		seq_puts(m, "Read Policy: ");
 		switch(lparam->read_ahead) {
-
 		case NO_READ_AHEAD:
-			len += sprintf(page+len, "No read ahead, ");
+			seq_puts(m, "No read ahead, ");
 			break;
-
 		case READ_AHEAD:
-			len += sprintf(page+len, "Read ahead, ");
+			seq_puts(m, "Read ahead, ");
 			break;
-
 		case ADAP_READ_AHEAD:
-			len += sprintf(page+len, "Adaptive, ");
+			seq_puts(m, "Adaptive, ");
 			break;
 
 		}
 
-		len += sprintf(page+len, "Write Policy: ");
-
+		seq_puts(m, "Write Policy: ");
 		switch(lparam->write_mode) {
-
 		case WRMODE_WRITE_THRU:
-			len += sprintf(page+len, "Write thru, ");
+			seq_puts(m, "Write thru, ");
 			break;
-
 		case WRMODE_WRITE_BACK:
-			len += sprintf(page+len, "Write back, ");
+			seq_puts(m, "Write back, ");
 			break;
 		}
 
-		len += sprintf(page+len, "Cache Policy: ");
-
+		seq_puts(m, "Cache Policy: ");
 		switch(lparam->direct_io) {
-
 		case CACHED_IO:
-			len += sprintf(page+len, "Cached IO\n\n");
+			seq_puts(m, "Cached IO\n\n");
 			break;
-
 		case DIRECT_IO:
-			len += sprintf(page+len, "Direct IO\n\n");
+			seq_puts(m, "Direct IO\n\n");
 			break;
 		}
 	}
 
-	mega_free_inquiry(inquiry, dma_handle, pdev);
-
+free_pci:
 	pci_free_consistent(pdev, array_sz, disk_array,
 			disk_array_dma_handle);
-
+free_inquiry:
+	mega_free_inquiry(inquiry, dma_handle, pdev);
+free_pdev:
 	free_local_pdev(pdev);
+	return 0;
+}
+
+/**
+ * proc_show_rdrv_10()
+ * @m - Synthetic file construction data
+ * @v - File iterator
+ *
+ * Display real time information about the logical drives 0 through 9.
+ */
+static int
+proc_show_rdrv_10(struct seq_file *m, void *v)
+{
+	return proc_show_rdrv(m, m->private, 0, 9);
+}
 
-	return len;
+
+/**
+ * proc_show_rdrv_20()
+ * @m - Synthetic file construction data
+ * @v - File iterator
+ *
+ * Display real time information about the logical drives 0 through 9.
+ */
+static int
+proc_show_rdrv_20(struct seq_file *m, void *v)
+{
+	return proc_show_rdrv(m, m->private, 10, 19);
+}
+
+
+/**
+ * proc_show_rdrv_30()
+ * @m - Synthetic file construction data
+ * @v - File iterator
+ *
+ * Display real time information about the logical drives 0 through 9.
+ */
+static int
+proc_show_rdrv_30(struct seq_file *m, void *v)
+{
+	return proc_show_rdrv(m, m->private, 20, 29);
 }
+
+
+/**
+ * proc_show_rdrv_40()
+ * @m - Synthetic file construction data
+ * @v - File iterator
+ *
+ * Display real time information about the logical drives 0 through 9.
+ */
+static int
+proc_show_rdrv_40(struct seq_file *m, void *v)
+{
+	return proc_show_rdrv(m, m->private, 30, 39);
+}
+
+
+/*
+ * seq_file wrappers for procfile show routines.
+ */
+static int mega_proc_open(struct inode *inode, struct file *file)
+{
+	adapter_t *adapter = PDE(inode)->parent->data;
+	int (*show)(struct seq_file *, void *) = PDE_DATA(inode);
+
+	return single_open(file, show, adapter);
+}
+
+static const struct file_operations mega_proc_fops = {
+	.open		= mega_proc_open,
+	.read		= seq_read,
+	.llseek		= seq_lseek,
+	.release	= seq_release,
+};
+
+/*
+ * Table of proc files we need to create.
+ */
+struct mega_proc_file {
+	const char *name;
+	unsigned short ptr_offset;
+	int (*show) (struct seq_file *m, void *v);
+};
+
+static const struct mega_proc_file mega_proc_files[] = {
+	{ "config",	      offsetof(adapter_t, proc_read), proc_show_config },
+	{ "stat",	      offsetof(adapter_t, proc_stat), proc_show_stat },
+	{ "mailbox",	      offsetof(adapter_t, proc_mbox), proc_show_mbox },
+#if MEGA_HAVE_ENH_PROC
+	{ "rebuild-rate",     offsetof(adapter_t, proc_rr), proc_show_rebuild_rate },
+	{ "battery-status",   offsetof(adapter_t, proc_battery), proc_show_battery },
+	{ "diskdrives-ch0",   offsetof(adapter_t, proc_pdrvstat[0]), proc_show_pdrv_ch0 },
+	{ "diskdrives-ch1",   offsetof(adapter_t, proc_pdrvstat[1]), proc_show_pdrv_ch1 },
+	{ "diskdrives-ch2",   offsetof(adapter_t, proc_pdrvstat[2]), proc_show_pdrv_ch2 },
+	{ "diskdrives-ch3",   offsetof(adapter_t, proc_pdrvstat[3]), proc_show_pdrv_ch3 },
+	{ "raiddrives-0-9",   offsetof(adapter_t, proc_rdrvstat[0]), proc_show_rdrv_10 },
+	{ "raiddrives-10-19", offsetof(adapter_t, proc_rdrvstat[1]), proc_show_rdrv_20 },
+	{ "raiddrives-20-29", offsetof(adapter_t, proc_rdrvstat[2]), proc_show_rdrv_30 },
+	{ "raiddrives-30-39", offsetof(adapter_t, proc_rdrvstat[3]), proc_show_rdrv_40 },
+#endif
+	{ NULL }
+};
+
+/**
+ * mega_create_proc_entry()
+ * @index - index in soft state array
+ * @parent - parent node for this /proc entry
+ *
+ * Creates /proc entries for our controllers.
+ */
+static void
+mega_create_proc_entry(int index, struct proc_dir_entry *parent)
+{
+	const struct mega_proc_file *f;
+	adapter_t	*adapter = hba_soft_state[index];
+	struct proc_dir_entry	*dir, *de, **ppde;
+	u8		string[16];
+
+	sprintf(string, "hba%d", adapter->host->host_no);
+
+	dir = adapter->controller_proc_dir_entry = proc_mkdir(string, parent);
+	if(!dir) {
+		printk(KERN_WARNING "\nmegaraid: proc_mkdir failed\n");
+		return;
+	}
+	dir->data = adapter;
+
+	for (f = mega_proc_files; f->name; f++) {
+		de = proc_create_data(f->name, S_IRUSR, dir, &mega_proc_fops,
+				      f->show);
+		if (!de) {
+			printk(KERN_WARNING "\nmegaraid: proc_create failed\n");
+			return;
+		}
+
+		ppde = (void *)adapter + f->ptr_offset;
+		*ppde = de;
+	}
+}
+
 #else
 static inline void mega_create_proc_entry(int index, struct proc_dir_entry *parent)
 {

commit 6f039790510fd630ff348efe8c4802dbaa041fba
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Fri Dec 21 13:08:55 2012 -0800

    Drivers: scsi: remove __dev* attributes.
    
    CONFIG_HOTPLUG is going away as an option.  As a result, the __dev*
    markings need to be removed.
    
    This change removes the use of __devinit, __devexit_p, __devinitdata,
    __devinitconst, and __devexit from these drivers.
    
    Based on patches originally written by Bill Pemberton, but redone by me
    in order to handle some of the coding style issues better, by hand.
    
    Cc: Bill Pemberton <wfp5p@virginia.edu>
    Cc: Adam Radford <linuxraid@lsi.com>
    Cc: "James E.J. Bottomley" <JBottomley@parallels.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/scsi/megaraid.c b/drivers/scsi/megaraid.c
index 76ad72d32c3f..9504ec0ec682 100644
--- a/drivers/scsi/megaraid.c
+++ b/drivers/scsi/megaraid.c
@@ -4522,7 +4522,7 @@ static struct scsi_host_template megaraid_template = {
 	.eh_host_reset_handler		= megaraid_reset,
 };
 
-static int __devinit
+static int
 megaraid_probe_one(struct pci_dev *pdev, const struct pci_device_id *id)
 {
 	struct Scsi_Host *host;
@@ -4914,7 +4914,7 @@ __megaraid_shutdown(adapter_t *adapter)
 		mdelay(1000);
 }
 
-static void __devexit
+static void
 megaraid_remove_one(struct pci_dev *pdev)
 {
 	struct Scsi_Host *host = pci_get_drvdata(pdev);
@@ -5008,7 +5008,7 @@ static struct pci_driver megaraid_pci_driver = {
 	.name		= "megaraid_legacy",
 	.id_table	= megaraid_pci_tbl,
 	.probe		= megaraid_probe_one,
-	.remove		= __devexit_p(megaraid_remove_one),
+	.remove		= megaraid_remove_one,
 	.shutdown	= megaraid_shutdown,
 };
 

commit 99dbb1632f1165c2726056ebfce6edde0e5a0208
Merge: aae6f989c6e9 9c33c512b2d3
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Mon Oct 1 09:06:36 2012 -0700

    Merge branch 'for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/jikos/trivial
    
    Pull the trivial tree from Jiri Kosina:
     "Tiny usual fixes all over the place"
    
    * 'for-linus' of git://git.kernel.org/pub/scm/linux/kernel/git/jikos/trivial: (34 commits)
      doc: fix old config name of kprobetrace
      fs/fs-writeback.c: cleanup riteback_sb_inodes kerneldoc
      btrfs: fix the commment for the action flags in delayed-ref.h
      btrfs: fix trivial typo for the comment of BTRFS_FREE_INO_OBJECTID
      vfs: fix kerneldoc for generic_fh_to_parent()
      treewide: fix comment/printk/variable typos
      ipr: fix small coding style issues
      doc: fix broken utf8 encoding
      nfs: comment fix
      platform/x86: fix asus_laptop.wled_type module parameter
      mfd: printk/comment fixes
      doc: getdelays.c: remember to close() socket on error in create_nl_socket()
      doc: aliasing-test: close fd on write error
      mmc: fix comment typos
      dma: fix comments
      spi: fix comment/printk typos in spi
      Coccinelle: fix typo in memdup_user.cocci
      tmiofb: missing NULL pointer checks
      tools: perf: Fix typo in tools/perf
      tools/testing: fix comment / output typos
      ...

commit 54ebfd57813ada76f4459f7f1ba1e6873159319e
Author: Jon Mason <jdmason@kudzu.us>
Date:   Tue Jul 10 15:31:28 2012 -0700

    megaraid: remove unnecessary #defines
    
    Remove PCI vendor and subvendor IDs, as they are already defined in
    pci_ids.h.
    
    Signed-off-by: Jon Mason <jdmason@kudzu.us>
    Signed-off-by: Jiri Kosina <jkosina@suse.cz>

diff --git a/drivers/scsi/megaraid.c b/drivers/scsi/megaraid.c
index 4d39a9ffc081..f066ec483bea 100644
--- a/drivers/scsi/megaraid.c
+++ b/drivers/scsi/megaraid.c
@@ -305,12 +305,11 @@ mega_query_adapter(adapter_t *adapter)
 
 	adapter->host->sg_tablesize = adapter->sglen;
 
-
 	/* use HP firmware and bios version encoding
 	   Note: fw_version[0|1] and bios_version[0|1] were originally shifted
 	   right 8 bits making them zero. This 0 value was hardcoded to fix
 	   sparse warnings. */
-	if (adapter->product_info.subsysvid == HP_SUBSYS_VID) {
+	if (adapter->product_info.subsysvid == PCI_VENDOR_ID_HP) {
 		sprintf (adapter->fw_version, "%c%d%d.%d%d",
 			 adapter->product_info.fw_version[2],
 			 0,
@@ -4716,7 +4715,7 @@ megaraid_probe_one(struct pci_dev *pdev, const struct pci_device_id *id)
 	 * support, since this firmware cannot handle 64 bit
 	 * addressing
 	 */
-	if ((subsysvid == HP_SUBSYS_VID) &&
+	if ((subsysvid == PCI_VENDOR_ID_HP) &&
 	    ((subsysid == 0x60E7) || (subsysid == 0x60E8))) {
 		/*
 		 * which firmware

commit 9d5d93e32a365f962fb26ebd19c0b4a392f38e64
Author: Dan Carpenter <dan.carpenter@oracle.com>
Date:   Wed Jun 27 12:08:25 2012 +0300

    [SCSI] megaraid: cleanup type issue in mega_build_cmd()
    
    On 64 bit systems the current code sets 32 bits of "seg" and leaves the
    other 32 uninitialized.  It doesn't matter since the variable is never
    used.  But it's still messy and we should fix it.
    
    Signed-off-by: Dan Carpenter <dan.carpenter@oracle.com>
    Acked-by: Adam Radford <aradford@gmail.com>
    Signed-off-by: James Bottomley <JBottomley@Parallels.com>

diff --git a/drivers/scsi/megaraid.c b/drivers/scsi/megaraid.c
index 4d39a9ffc081..97825f116954 100644
--- a/drivers/scsi/megaraid.c
+++ b/drivers/scsi/megaraid.c
@@ -524,7 +524,7 @@ mega_build_cmd(adapter_t *adapter, Scsi_Cmnd *cmd, int *busy)
 	mega_passthru	*pthru;
 	scb_t	*scb;
 	mbox_t	*mbox;
-	long	seg;
+	u32	seg;
 	char	islogical;
 	int	max_ldrv_num;
 	int	channel = 0;
@@ -858,7 +858,7 @@ mega_build_cmd(adapter_t *adapter, Scsi_Cmnd *cmd, int *busy)
 
 			/* Calculate Scatter-Gather info */
 			mbox->m_out.numsgelements = mega_build_sglist(adapter, scb,
-					(u32 *)&mbox->m_out.xferaddr, (u32 *)&seg);
+					(u32 *)&mbox->m_out.xferaddr, &seg);
 
 			return scb;
 

commit 77dfce076cbd76c04e90abff188d058cdbff78dd
Author: Cong Wang <amwang@redhat.com>
Date:   Fri Nov 25 23:14:23 2011 +0800

    scsi: remove the second argument of k[un]map_atomic()
    
    Signed-off-by: Cong Wang <amwang@redhat.com>

diff --git a/drivers/scsi/megaraid.c b/drivers/scsi/megaraid.c
index 15eefa1d61fd..4d39a9ffc081 100644
--- a/drivers/scsi/megaraid.c
+++ b/drivers/scsi/megaraid.c
@@ -670,10 +670,10 @@ mega_build_cmd(adapter_t *adapter, Scsi_Cmnd *cmd, int *busy)
 			struct scatterlist *sg;
 
 			sg = scsi_sglist(cmd);
-			buf = kmap_atomic(sg_page(sg), KM_IRQ0) + sg->offset;
+			buf = kmap_atomic(sg_page(sg)) + sg->offset;
 
 			memset(buf, 0, cmd->cmnd[4]);
-			kunmap_atomic(buf - sg->offset, KM_IRQ0);
+			kunmap_atomic(buf - sg->offset);
 
 			cmd->result = (DID_OK << 16);
 			cmd->scsi_done(cmd);

commit 124dd90f6525ee785b47b59aebadd4a35f797dc1
Author: adam radford <aradford@gmail.com>
Date:   Tue Jan 10 18:07:56 2012 -0800

    [SCSI] megaraid: fix sparse warnings
    
    There's a zero day mistake in the megaraid driver in that the code that
    obtains the version number does a >> 8 on a char quantity.  This >>8 causes a
    sparse warning because it always produces zero.  Al Viro suggested these
    shifts should be >> 4 thus treating the firmware version as a BCD quantity.
    However, in the interests of safety we've elected to replace the >> 8
    quantities with an explicit zero, thus quieting the sparse warning while
    preserving the same (albeit incorrect) version number as had previously been
    seen.
    
    Signed-off-by: Adam Radford <aradford@gmail.com>
    Signed-off-by: James Bottomley <JBottomley@Parallels.com>

diff --git a/drivers/scsi/megaraid.c b/drivers/scsi/megaraid.c
index 5c1776406c96..15eefa1d61fd 100644
--- a/drivers/scsi/megaraid.c
+++ b/drivers/scsi/megaraid.c
@@ -306,19 +306,22 @@ mega_query_adapter(adapter_t *adapter)
 	adapter->host->sg_tablesize = adapter->sglen;
 
 
-	/* use HP firmware and bios version encoding */
+	/* use HP firmware and bios version encoding
+	   Note: fw_version[0|1] and bios_version[0|1] were originally shifted
+	   right 8 bits making them zero. This 0 value was hardcoded to fix
+	   sparse warnings. */
 	if (adapter->product_info.subsysvid == HP_SUBSYS_VID) {
 		sprintf (adapter->fw_version, "%c%d%d.%d%d",
 			 adapter->product_info.fw_version[2],
-			 adapter->product_info.fw_version[1] >> 8,
+			 0,
 			 adapter->product_info.fw_version[1] & 0x0f,
-			 adapter->product_info.fw_version[0] >> 8,
+			 0,
 			 adapter->product_info.fw_version[0] & 0x0f);
 		sprintf (adapter->bios_version, "%c%d%d.%d%d",
 			 adapter->product_info.bios_version[2],
-			 adapter->product_info.bios_version[1] >> 8,
+			 0,
 			 adapter->product_info.bios_version[1] & 0x0f,
-			 adapter->product_info.bios_version[0] >> 8,
+			 0,
 			 adapter->product_info.bios_version[0] & 0x0f);
 	} else {
 		memcpy(adapter->fw_version,

commit 5cd049a59913f359e7d30c11d2dc6187822e77b1
Author: Christoph Hellwig <hch@infradead.org>
Date:   Mon Apr 4 09:42:14 2011 -0400

    [SCSI] remove cmd->serial_number litter
    
    Stop using cmd->serial_number in printks.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: James Bottomley <James.Bottomley@suse.de>

diff --git a/drivers/scsi/megaraid.c b/drivers/scsi/megaraid.c
index f2684dd09ed0..5c1776406c96 100644
--- a/drivers/scsi/megaraid.c
+++ b/drivers/scsi/megaraid.c
@@ -1469,8 +1469,8 @@ mega_cmd_done(adapter_t *adapter, u8 completed[], int nstatus, int status)
 			if( scb->state & SCB_ABORT ) {
 
 				printk(KERN_WARNING
-				"megaraid: aborted cmd %lx[%x] complete.\n",
-					scb->cmd->serial_number, scb->idx);
+				"megaraid: aborted cmd [%x] complete.\n",
+					scb->idx);
 
 				scb->cmd->result = (DID_ABORT << 16);
 
@@ -1488,8 +1488,8 @@ mega_cmd_done(adapter_t *adapter, u8 completed[], int nstatus, int status)
 			if( scb->state & SCB_RESET ) {
 
 				printk(KERN_WARNING
-				"megaraid: reset cmd %lx[%x] complete.\n",
-					scb->cmd->serial_number, scb->idx);
+				"megaraid: reset cmd [%x] complete.\n",
+					scb->idx);
 
 				scb->cmd->result = (DID_RESET << 16);
 
@@ -1958,8 +1958,8 @@ megaraid_abort_and_reset(adapter_t *adapter, Scsi_Cmnd *cmd, int aor)
 	struct list_head	*pos, *next;
 	scb_t			*scb;
 
-	printk(KERN_WARNING "megaraid: %s-%lx cmd=%x <c=%d t=%d l=%d>\n",
-	     (aor == SCB_ABORT)? "ABORTING":"RESET", cmd->serial_number,
+	printk(KERN_WARNING "megaraid: %s cmd=%x <c=%d t=%d l=%d>\n",
+	     (aor == SCB_ABORT)? "ABORTING":"RESET",
 	     cmd->cmnd[0], cmd->device->channel, 
 	     cmd->device->id, cmd->device->lun);
 
@@ -1983,9 +1983,9 @@ megaraid_abort_and_reset(adapter_t *adapter, Scsi_Cmnd *cmd, int aor)
 			if( scb->state & SCB_ISSUED ) {
 
 				printk(KERN_WARNING
-					"megaraid: %s-%lx[%x], fw owner.\n",
+					"megaraid: %s[%x], fw owner.\n",
 					(aor==SCB_ABORT) ? "ABORTING":"RESET",
-					cmd->serial_number, scb->idx);
+					scb->idx);
 
 				return FALSE;
 			}
@@ -1996,9 +1996,9 @@ megaraid_abort_and_reset(adapter_t *adapter, Scsi_Cmnd *cmd, int aor)
 				 * list
 				 */
 				printk(KERN_WARNING
-					"megaraid: %s-%lx[%x], driver owner.\n",
+					"megaraid: %s-[%x], driver owner.\n",
 					(aor==SCB_ABORT) ? "ABORTING":"RESET",
-					cmd->serial_number, scb->idx);
+					scb->idx);
 
 				mega_free_scb(adapter, scb);
 

commit 25985edcedea6396277003854657b5f3cb31a628
Author: Lucas De Marchi <lucas.demarchi@profusion.mobi>
Date:   Wed Mar 30 22:57:33 2011 -0300

    Fix common misspellings
    
    Fixes generated by 'codespell' and manually reviewed.
    
    Signed-off-by: Lucas De Marchi <lucas.demarchi@profusion.mobi>

diff --git a/drivers/scsi/megaraid.c b/drivers/scsi/megaraid.c
index c212694a9714..f2684dd09ed0 100644
--- a/drivers/scsi/megaraid.c
+++ b/drivers/scsi/megaraid.c
@@ -284,7 +284,7 @@ mega_query_adapter(adapter_t *adapter)
 
 	adapter->host->max_id = 16;	/* max targets per channel */
 
-	adapter->host->max_lun = 7;	/* Upto 7 luns for non disk devices */
+	adapter->host->max_lun = 7;	/* Up to 7 luns for non disk devices */
 
 	adapter->host->cmd_per_lun = max_cmd_per_lun;
 
@@ -3734,7 +3734,7 @@ mega_m_to_n(void __user *arg, nitioctl_t *uioc)
 	 * check is the application conforms to NIT. We do not have to do much
 	 * in that case.
 	 * We exploit the fact that the signature is stored in the very
-	 * begining of the structure.
+	 * beginning of the structure.
 	 */
 
 	if( copy_from_user(signature, arg, 7) )

commit 8e572bab39c484cdf512715f98626337f25cfc32
Author: Justin P. Mattock <justinmattock@gmail.com>
Date:   Wed Feb 2 11:31:21 2011 +0100

    fix typos 'comamnd' -> 'command' in comments
    
    Signed-off-by: Justin P. Mattock <justinmattock@gmail.com>

diff --git a/drivers/scsi/megaraid.c b/drivers/scsi/megaraid.c
index 9aa048525eb2..c212694a9714 100644
--- a/drivers/scsi/megaraid.c
+++ b/drivers/scsi/megaraid.c
@@ -1412,7 +1412,7 @@ megaraid_isr_memmapped(int irq, void *devp)
  * @nstatus - number of completed commands
  * @status - status of the last command completed
  *
- * Complete the comamnds and call the scsi mid-layer callback hooks.
+ * Complete the commands and call the scsi mid-layer callback hooks.
  */
 static void
 mega_cmd_done(adapter_t *adapter, u8 completed[], int nstatus, int status)
@@ -4296,7 +4296,7 @@ mega_support_cluster(adapter_t *adapter)
  * @adapter - pointer to our soft state
  * @dma_handle - DMA address of the buffer
  *
- * Issue internal comamnds while interrupts are available.
+ * Issue internal commands while interrupts are available.
  * We only issue direct mailbox commands from within the driver. ioctl()
  * interface using these routines can issue passthru commands.
  */

commit f281233d3eba15fb225d21ae2e228fd4553d824a
Author: Jeff Garzik <jeff@garzik.org>
Date:   Tue Nov 16 02:10:29 2010 -0500

    SCSI host lock push-down
    
    Move the mid-layer's ->queuecommand() invocation from being locked
    with the host lock to being unlocked to facilitate speeding up the
    critical path for drivers who don't need this lock taken anyway.
    
    The patch below presents a simple SCSI host lock push-down as an
    equivalent transformation.  No locking or other behavior should change
    with this patch.  All existing bugs and locking orders are preserved.
    
    Additionally, add one parameter to queuecommand,
            struct Scsi_Host *
    and remove one parameter from queuecommand,
            void (*done)(struct scsi_cmnd *)
    
    Scsi_Host* is a convenient pointer that most host drivers need anyway,
    and 'done' is redundant to struct scsi_cmnd->scsi_done.
    
    Minimal code disturbance was attempted with this change.  Most drivers
    needed only two one-line modifications for their host lock push-down.
    
    Signed-off-by: Jeff Garzik <jgarzik@redhat.com>
    Acked-by: James Bottomley <James.Bottomley@suse.de>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/scsi/megaraid.c b/drivers/scsi/megaraid.c
index 7ceb5cf12c6b..9aa048525eb2 100644
--- a/drivers/scsi/megaraid.c
+++ b/drivers/scsi/megaraid.c
@@ -366,7 +366,7 @@ mega_runpendq(adapter_t *adapter)
  * The command queuing entry point for the mid-layer.
  */
 static int
-megaraid_queue(Scsi_Cmnd *scmd, void (*done)(Scsi_Cmnd *))
+megaraid_queue_lck(Scsi_Cmnd *scmd, void (*done)(Scsi_Cmnd *))
 {
 	adapter_t	*adapter;
 	scb_t	*scb;
@@ -409,6 +409,8 @@ megaraid_queue(Scsi_Cmnd *scmd, void (*done)(Scsi_Cmnd *))
 	return busy;
 }
 
+static DEF_SCSI_QCMD(megaraid_queue)
+
 /**
  * mega_allocate_scb()
  * @adapter - pointer to our soft state
@@ -4456,7 +4458,7 @@ mega_internal_command(adapter_t *adapter, megacmd_t *mc, mega_passthru *pthru)
 
 	scb->idx = CMDID_INT_CMDS;
 
-	megaraid_queue(scmd, mega_internal_done);
+	megaraid_queue_lck(scmd, mega_internal_done);
 
 	wait_for_completion(&adapter->int_waitq);
 

commit 092e0e7e520a1fca03e13c9f2d157432a8657ff2
Merge: 79f14b7c56d3 776c163b1b93
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Fri Oct 22 10:52:56 2010 -0700

    Merge branch 'llseek' of git://git.kernel.org/pub/scm/linux/kernel/git/arnd/bkl
    
    * 'llseek' of git://git.kernel.org/pub/scm/linux/kernel/git/arnd/bkl:
      vfs: make no_llseek the default
      vfs: don't use BKL in default_llseek
      llseek: automatically add .llseek fop
      libfs: use generic_file_llseek for simple_attr
      mac80211: disallow seeks in minstrel debug code
      lirc: make chardev nonseekable
      viotape: use noop_llseek
      raw: use explicit llseek file operations
      ibmasmfs: use generic_file_llseek
      spufs: use llseek in all file operations
      arm/omap: use generic_file_llseek in iommu_debug
      lkdtm: use generic_file_llseek in debugfs
      net/wireless: use generic_file_llseek in debugfs
      drm: use noop_llseek

commit 6038f373a3dc1f1c26496e60b6c40b164716f07e
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Sun Aug 15 18:52:59 2010 +0200

    llseek: automatically add .llseek fop
    
    All file_operations should get a .llseek operation so we can make
    nonseekable_open the default for future file operations without a
    .llseek pointer.
    
    The three cases that we can automatically detect are no_llseek, seq_lseek
    and default_llseek. For cases where we can we can automatically prove that
    the file offset is always ignored, we use noop_llseek, which maintains
    the current behavior of not returning an error from a seek.
    
    New drivers should normally not use noop_llseek but instead use no_llseek
    and call nonseekable_open at open time.  Existing drivers can be converted
    to do the same when the maintainer knows for certain that no user code
    relies on calling seek on the device file.
    
    The generated code is often incorrectly indented and right now contains
    comments that clarify for each added line why a specific variant was
    chosen. In the version that gets submitted upstream, the comments will
    be gone and I will manually fix the indentation, because there does not
    seem to be a way to do that using coccinelle.
    
    Some amount of new code is currently sitting in linux-next that should get
    the same modifications, which I will do at the end of the merge window.
    
    Many thanks to Julia Lawall for helping me learn to write a semantic
    patch that does all this.
    
    ===== begin semantic patch =====
    // This adds an llseek= method to all file operations,
    // as a preparation for making no_llseek the default.
    //
    // The rules are
    // - use no_llseek explicitly if we do nonseekable_open
    // - use seq_lseek for sequential files
    // - use default_llseek if we know we access f_pos
    // - use noop_llseek if we know we don't access f_pos,
    //   but we still want to allow users to call lseek
    //
    @ open1 exists @
    identifier nested_open;
    @@
    nested_open(...)
    {
    <+...
    nonseekable_open(...)
    ...+>
    }
    
    @ open exists@
    identifier open_f;
    identifier i, f;
    identifier open1.nested_open;
    @@
    int open_f(struct inode *i, struct file *f)
    {
    <+...
    (
    nonseekable_open(...)
    |
    nested_open(...)
    )
    ...+>
    }
    
    @ read disable optional_qualifier exists @
    identifier read_f;
    identifier f, p, s, off;
    type ssize_t, size_t, loff_t;
    expression E;
    identifier func;
    @@
    ssize_t read_f(struct file *f, char *p, size_t s, loff_t *off)
    {
    <+...
    (
       *off = E
    |
       *off += E
    |
       func(..., off, ...)
    |
       E = *off
    )
    ...+>
    }
    
    @ read_no_fpos disable optional_qualifier exists @
    identifier read_f;
    identifier f, p, s, off;
    type ssize_t, size_t, loff_t;
    @@
    ssize_t read_f(struct file *f, char *p, size_t s, loff_t *off)
    {
    ... when != off
    }
    
    @ write @
    identifier write_f;
    identifier f, p, s, off;
    type ssize_t, size_t, loff_t;
    expression E;
    identifier func;
    @@
    ssize_t write_f(struct file *f, const char *p, size_t s, loff_t *off)
    {
    <+...
    (
      *off = E
    |
      *off += E
    |
      func(..., off, ...)
    |
      E = *off
    )
    ...+>
    }
    
    @ write_no_fpos @
    identifier write_f;
    identifier f, p, s, off;
    type ssize_t, size_t, loff_t;
    @@
    ssize_t write_f(struct file *f, const char *p, size_t s, loff_t *off)
    {
    ... when != off
    }
    
    @ fops0 @
    identifier fops;
    @@
    struct file_operations fops = {
     ...
    };
    
    @ has_llseek depends on fops0 @
    identifier fops0.fops;
    identifier llseek_f;
    @@
    struct file_operations fops = {
    ...
     .llseek = llseek_f,
    ...
    };
    
    @ has_read depends on fops0 @
    identifier fops0.fops;
    identifier read_f;
    @@
    struct file_operations fops = {
    ...
     .read = read_f,
    ...
    };
    
    @ has_write depends on fops0 @
    identifier fops0.fops;
    identifier write_f;
    @@
    struct file_operations fops = {
    ...
     .write = write_f,
    ...
    };
    
    @ has_open depends on fops0 @
    identifier fops0.fops;
    identifier open_f;
    @@
    struct file_operations fops = {
    ...
     .open = open_f,
    ...
    };
    
    // use no_llseek if we call nonseekable_open
    ////////////////////////////////////////////
    @ nonseekable1 depends on !has_llseek && has_open @
    identifier fops0.fops;
    identifier nso ~= "nonseekable_open";
    @@
    struct file_operations fops = {
    ...  .open = nso, ...
    +.llseek = no_llseek, /* nonseekable */
    };
    
    @ nonseekable2 depends on !has_llseek @
    identifier fops0.fops;
    identifier open.open_f;
    @@
    struct file_operations fops = {
    ...  .open = open_f, ...
    +.llseek = no_llseek, /* open uses nonseekable */
    };
    
    // use seq_lseek for sequential files
    /////////////////////////////////////
    @ seq depends on !has_llseek @
    identifier fops0.fops;
    identifier sr ~= "seq_read";
    @@
    struct file_operations fops = {
    ...  .read = sr, ...
    +.llseek = seq_lseek, /* we have seq_read */
    };
    
    // use default_llseek if there is a readdir
    ///////////////////////////////////////////
    @ fops1 depends on !has_llseek && !nonseekable1 && !nonseekable2 && !seq @
    identifier fops0.fops;
    identifier readdir_e;
    @@
    // any other fop is used that changes pos
    struct file_operations fops = {
    ... .readdir = readdir_e, ...
    +.llseek = default_llseek, /* readdir is present */
    };
    
    // use default_llseek if at least one of read/write touches f_pos
    /////////////////////////////////////////////////////////////////
    @ fops2 depends on !fops1 && !has_llseek && !nonseekable1 && !nonseekable2 && !seq @
    identifier fops0.fops;
    identifier read.read_f;
    @@
    // read fops use offset
    struct file_operations fops = {
    ... .read = read_f, ...
    +.llseek = default_llseek, /* read accesses f_pos */
    };
    
    @ fops3 depends on !fops1 && !fops2 && !has_llseek && !nonseekable1 && !nonseekable2 && !seq @
    identifier fops0.fops;
    identifier write.write_f;
    @@
    // write fops use offset
    struct file_operations fops = {
    ... .write = write_f, ...
    +       .llseek = default_llseek, /* write accesses f_pos */
    };
    
    // Use noop_llseek if neither read nor write accesses f_pos
    ///////////////////////////////////////////////////////////
    
    @ fops4 depends on !fops1 && !fops2 && !fops3 && !has_llseek && !nonseekable1 && !nonseekable2 && !seq @
    identifier fops0.fops;
    identifier read_no_fpos.read_f;
    identifier write_no_fpos.write_f;
    @@
    // write fops use offset
    struct file_operations fops = {
    ...
     .write = write_f,
     .read = read_f,
    ...
    +.llseek = noop_llseek, /* read and write both use no f_pos */
    };
    
    @ depends on has_write && !has_read && !fops1 && !fops2 && !has_llseek && !nonseekable1 && !nonseekable2 && !seq @
    identifier fops0.fops;
    identifier write_no_fpos.write_f;
    @@
    struct file_operations fops = {
    ... .write = write_f, ...
    +.llseek = noop_llseek, /* write uses no f_pos */
    };
    
    @ depends on has_read && !has_write && !fops1 && !fops2 && !has_llseek && !nonseekable1 && !nonseekable2 && !seq @
    identifier fops0.fops;
    identifier read_no_fpos.read_f;
    @@
    struct file_operations fops = {
    ... .read = read_f, ...
    +.llseek = noop_llseek, /* read uses no f_pos */
    };
    
    @ depends on !has_read && !has_write && !fops1 && !fops2 && !has_llseek && !nonseekable1 && !nonseekable2 && !seq @
    identifier fops0.fops;
    @@
    struct file_operations fops = {
    ...
    +.llseek = noop_llseek, /* no read or write fn */
    };
    ===== End semantic patch =====
    
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>
    Cc: Julia Lawall <julia@diku.dk>
    Cc: Christoph Hellwig <hch@infradead.org>

diff --git a/drivers/scsi/megaraid.c b/drivers/scsi/megaraid.c
index 0b6e3228610a..aac80f7bb999 100644
--- a/drivers/scsi/megaraid.c
+++ b/drivers/scsi/megaraid.c
@@ -101,6 +101,7 @@ static const struct file_operations megadev_fops = {
 	.owner		= THIS_MODULE,
 	.unlocked_ioctl	= megadev_unlocked_ioctl,
 	.open		= megadev_open,
+	.llseek		= noop_llseek,
 };
 
 /*

commit c45d15d24eb2b49bf734e1e5e7e103befb76b19b
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Wed Jun 2 14:28:52 2010 +0200

    scsi: autoconvert trivial BKL users to private mutex
    
    All these files use the big kernel lock in a trivial
    way to serialize their private file operations,
    typically resulting from an earlier semi-automatic
    pushdown from VFS.
    
    None of these drivers appears to want to lock against
    other code, and they all use the BKL as the top-level
    lock in their file operations, meaning that there
    is no lock-order inversion problem.
    
    Consequently, we can remove the BKL completely,
    replacing it with a per-file mutex in every case.
    Using a scripted approach means we can avoid
    typos.
    
    file=$1
    name=$2
    if grep -q lock_kernel ${file} ; then
        if grep -q 'include.*linux.mutex.h' ${file} ; then
                sed -i '/include.*<linux\/smp_lock.h>/d' ${file}
        else
                sed -i 's/include.*<linux\/smp_lock.h>.*$/include <linux\/mutex.h>/g' ${file}
        fi
        sed -i ${file} \
            -e "/^#include.*linux.mutex.h/,$ {
                    1,/^\(static\|int\|long\)/ {
                         /^\(static\|int\|long\)/istatic DEFINE_MUTEX(${name}_mutex);
    
    } }"  \
        -e "s/\(un\)*lock_kernel\>[ ]*()/mutex_\1lock(\&${name}_mutex)/g" \
        -e '/[      ]*cycle_kernel_lock();/d'
    else
        sed -i -e '/include.*\<smp_lock.h\>/d' ${file}  \
                    -e '/cycle_kernel_lock()/d'
    fi
    
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>
    Cc: linux-scsi@vger.kernel.org
    Cc: "James E.J. Bottomley" <James.Bottomley@suse.de>

diff --git a/drivers/scsi/megaraid.c b/drivers/scsi/megaraid.c
index 0b6e3228610a..4d0cf5cd82cc 100644
--- a/drivers/scsi/megaraid.c
+++ b/drivers/scsi/megaraid.c
@@ -46,7 +46,7 @@
 #include <linux/pci.h>
 #include <linux/init.h>
 #include <linux/dma-mapping.h>
-#include <linux/smp_lock.h>
+#include <linux/mutex.h>
 #include <linux/slab.h>
 #include <scsi/scsicam.h>
 
@@ -62,6 +62,7 @@ MODULE_DESCRIPTION ("LSI Logic MegaRAID legacy driver");
 MODULE_LICENSE ("GPL");
 MODULE_VERSION(MEGARAID_MODULE_VERSION);
 
+static DEFINE_MUTEX(megadev_mutex);
 static unsigned int max_cmd_per_lun = DEF_CMD_PER_LUN;
 module_param(max_cmd_per_lun, uint, 0);
 MODULE_PARM_DESC(max_cmd_per_lun, "Maximum number of commands which can be issued to a single LUN (default=DEF_CMD_PER_LUN=63)");
@@ -3282,7 +3283,6 @@ mega_init_scb(adapter_t *adapter)
 static int
 megadev_open (struct inode *inode, struct file *filep)
 {
-	cycle_kernel_lock();
 	/*
 	 * Only allow superuser to access private ioctl interface
 	 */
@@ -3701,9 +3701,9 @@ megadev_unlocked_ioctl(struct file *filep, unsigned int cmd, unsigned long arg)
 {
 	int ret;
 
-	lock_kernel();
+	mutex_lock(&megadev_mutex);
 	ret = megadev_ioctl(filep, cmd, arg);
-	unlock_kernel();
+	mutex_unlock(&megadev_mutex);
 
 	return ret;
 }

commit f4927c45beda9a70e5c3bda0bd9f12b4f713c00b
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Tue Apr 27 00:24:01 2010 +0200

    scsi: Push down BKL into ioctl functions
    
    Push down the bkl into ioctl functions on the scsi layer.
    
    [jkacur: Forward declaration missing ';'.
    Conflicting declaraction in megaraid.h changed
    Fixed missing inodes declarations]
    
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>
    Signed-off-by: John Kacur <jkacur@redhat.com>
    Signed-off-by: Frederic Weisbecker <fweisbec@gmail.com>

diff --git a/drivers/scsi/megaraid.c b/drivers/scsi/megaraid.c
index 4bf7edca9e69..0b6e3228610a 100644
--- a/drivers/scsi/megaraid.c
+++ b/drivers/scsi/megaraid.c
@@ -91,12 +91,15 @@ static struct proc_dir_entry *mega_proc_dir_entry;
 /* For controller re-ordering */
 static struct mega_hbas mega_hbas[MAX_CONTROLLERS];
 
+static long
+megadev_unlocked_ioctl(struct file *filep, unsigned int cmd, unsigned long arg);
+
 /*
  * The File Operations structure for the serial/ioctl interface of the driver
  */
 static const struct file_operations megadev_fops = {
 	.owner		= THIS_MODULE,
-	.ioctl		= megadev_ioctl,
+	.unlocked_ioctl	= megadev_unlocked_ioctl,
 	.open		= megadev_open,
 };
 
@@ -3302,8 +3305,7 @@ megadev_open (struct inode *inode, struct file *filep)
  * controller.
  */
 static int
-megadev_ioctl(struct inode *inode, struct file *filep, unsigned int cmd,
-		unsigned long arg)
+megadev_ioctl(struct file *filep, unsigned int cmd, unsigned long arg)
 {
 	adapter_t	*adapter;
 	nitioctl_t	uioc;
@@ -3694,6 +3696,18 @@ megadev_ioctl(struct inode *inode, struct file *filep, unsigned int cmd,
 	return 0;
 }
 
+static long
+megadev_unlocked_ioctl(struct file *filep, unsigned int cmd, unsigned long arg)
+{
+	int ret;
+
+	lock_kernel();
+	ret = megadev_ioctl(filep, cmd, arg);
+	unlock_kernel();
+
+	return ret;
+}
+
 /**
  * mega_m_to_n()
  * @arg - user address

commit 5a0e3ad6af8660be21ca98a971cd00f331318c05
Author: Tejun Heo <tj@kernel.org>
Date:   Wed Mar 24 17:04:11 2010 +0900

    include cleanup: Update gfp.h and slab.h includes to prepare for breaking implicit slab.h inclusion from percpu.h
    
    percpu.h is included by sched.h and module.h and thus ends up being
    included when building most .c files.  percpu.h includes slab.h which
    in turn includes gfp.h making everything defined by the two files
    universally available and complicating inclusion dependencies.
    
    percpu.h -> slab.h dependency is about to be removed.  Prepare for
    this change by updating users of gfp and slab facilities include those
    headers directly instead of assuming availability.  As this conversion
    needs to touch large number of source files, the following script is
    used as the basis of conversion.
    
      http://userweb.kernel.org/~tj/misc/slabh-sweep.py
    
    The script does the followings.
    
    * Scan files for gfp and slab usages and update includes such that
      only the necessary includes are there.  ie. if only gfp is used,
      gfp.h, if slab is used, slab.h.
    
    * When the script inserts a new include, it looks at the include
      blocks and try to put the new include such that its order conforms
      to its surrounding.  It's put in the include block which contains
      core kernel includes, in the same order that the rest are ordered -
      alphabetical, Christmas tree, rev-Xmas-tree or at the end if there
      doesn't seem to be any matching order.
    
    * If the script can't find a place to put a new include (mostly
      because the file doesn't have fitting include block), it prints out
      an error message indicating which .h file needs to be added to the
      file.
    
    The conversion was done in the following steps.
    
    1. The initial automatic conversion of all .c files updated slightly
       over 4000 files, deleting around 700 includes and adding ~480 gfp.h
       and ~3000 slab.h inclusions.  The script emitted errors for ~400
       files.
    
    2. Each error was manually checked.  Some didn't need the inclusion,
       some needed manual addition while adding it to implementation .h or
       embedding .c file was more appropriate for others.  This step added
       inclusions to around 150 files.
    
    3. The script was run again and the output was compared to the edits
       from #2 to make sure no file was left behind.
    
    4. Several build tests were done and a couple of problems were fixed.
       e.g. lib/decompress_*.c used malloc/free() wrappers around slab
       APIs requiring slab.h to be added manually.
    
    5. The script was run on all .h files but without automatically
       editing them as sprinkling gfp.h and slab.h inclusions around .h
       files could easily lead to inclusion dependency hell.  Most gfp.h
       inclusion directives were ignored as stuff from gfp.h was usually
       wildly available and often used in preprocessor macros.  Each
       slab.h inclusion directive was examined and added manually as
       necessary.
    
    6. percpu.h was updated not to include slab.h.
    
    7. Build test were done on the following configurations and failures
       were fixed.  CONFIG_GCOV_KERNEL was turned off for all tests (as my
       distributed build env didn't work with gcov compiles) and a few
       more options had to be turned off depending on archs to make things
       build (like ipr on powerpc/64 which failed due to missing writeq).
    
       * x86 and x86_64 UP and SMP allmodconfig and a custom test config.
       * powerpc and powerpc64 SMP allmodconfig
       * sparc and sparc64 SMP allmodconfig
       * ia64 SMP allmodconfig
       * s390 SMP allmodconfig
       * alpha SMP allmodconfig
       * um on x86_64 SMP allmodconfig
    
    8. percpu.h modifications were reverted so that it could be applied as
       a separate patch and serve as bisection point.
    
    Given the fact that I had only a couple of failures from tests on step
    6, I'm fairly confident about the coverage of this conversion patch.
    If there is a breakage, it's likely to be something in one of the arch
    headers which should be easily discoverable easily on most builds of
    the specific arch.
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Guess-its-ok-by: Christoph Lameter <cl@linux-foundation.org>
    Cc: Ingo Molnar <mingo@redhat.com>
    Cc: Lee Schermerhorn <Lee.Schermerhorn@hp.com>

diff --git a/drivers/scsi/megaraid.c b/drivers/scsi/megaraid.c
index 49eb0612d5af..4bf7edca9e69 100644
--- a/drivers/scsi/megaraid.c
+++ b/drivers/scsi/megaraid.c
@@ -47,6 +47,7 @@
 #include <linux/init.h>
 #include <linux/dma-mapping.h>
 #include <linux/smp_lock.h>
+#include <linux/slab.h>
 #include <scsi/scsicam.h>
 
 #include "scsi.h"

commit 284901a90a9e0b812ca3f5f852cbbfb60d10249d
Author: Yang Hongyang <yanghy@cn.fujitsu.com>
Date:   Mon Apr 6 19:01:15 2009 -0700

    dma-mapping: replace all DMA_32BIT_MASK macro with DMA_BIT_MASK(32)
    
    Replace all DMA_32BIT_MASK macro with DMA_BIT_MASK(32)
    
    Signed-off-by: Yang Hongyang<yanghy@cn.fujitsu.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/scsi/megaraid.c b/drivers/scsi/megaraid.c
index 112991d46d95..49eb0612d5af 100644
--- a/drivers/scsi/megaraid.c
+++ b/drivers/scsi/megaraid.c
@@ -2021,7 +2021,7 @@ make_local_pdev(adapter_t *adapter, struct pci_dev **pdev)
 
 	memcpy(*pdev, adapter->dev, sizeof(struct pci_dev));
 
-	if( pci_set_dma_mask(*pdev, DMA_32BIT_MASK) != 0 ) {
+	if( pci_set_dma_mask(*pdev, DMA_BIT_MASK(32)) != 0 ) {
 		kfree(*pdev);
 		return -1;
 	}
@@ -4796,7 +4796,7 @@ megaraid_probe_one(struct pci_dev *pdev, const struct pci_device_id *id)
 		pci_set_dma_mask(pdev, DMA_BIT_MASK(64));
 		adapter->has_64bit_addr = 1;
 	} else  {
-		pci_set_dma_mask(pdev, DMA_32BIT_MASK);
+		pci_set_dma_mask(pdev, DMA_BIT_MASK(32));
 		adapter->has_64bit_addr = 0;
 	}
 		

commit 6a35528a8346f6e6fd32ed7e51f04d1fa4ca2c01
Author: Yang Hongyang <yanghy@cn.fujitsu.com>
Date:   Mon Apr 6 19:01:13 2009 -0700

    dma-mapping: replace all DMA_64BIT_MASK macro with DMA_BIT_MASK(64)
    
    Replace all DMA_64BIT_MASK macro with DMA_BIT_MASK(64)
    
    Signed-off-by: Yang Hongyang<yanghy@cn.fujitsu.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/scsi/megaraid.c b/drivers/scsi/megaraid.c
index 9fdcd60c5493..112991d46d95 100644
--- a/drivers/scsi/megaraid.c
+++ b/drivers/scsi/megaraid.c
@@ -4793,7 +4793,7 @@ megaraid_probe_one(struct pci_dev *pdev, const struct pci_device_id *id)
 
 	/* Set the Mode of addressing to 64 bit if we can */
 	if ((adapter->flag & BOARD_64BIT) && (sizeof(dma_addr_t) == 8)) {
-		pci_set_dma_mask(pdev, DMA_64BIT_MASK);
+		pci_set_dma_mask(pdev, DMA_BIT_MASK(64));
 		adapter->has_64bit_addr = 1;
 	} else  {
 		pci_set_dma_mask(pdev, DMA_32BIT_MASK);

commit d41ad93872adf345595c8e28b3de980b2ae15268
Author: Nick Andrew <nick@nick-andrew.net>
Date:   Sat Jan 3 18:55:39 2009 +1100

    trivial: Fix misspelling of "firmware" in megaraid.c
    
    Fix misspelling of "firmware" in megaraid.c
    
    Fixed "firmware", "ownership" and grammar in the same comment.
    
    Signed-off-by: Nick Andrew <nick@nick-andrew.net>
    Signed-off-by: Jiri Kosina <jkosina@suse.cz>

diff --git a/drivers/scsi/megaraid.c b/drivers/scsi/megaraid.c
index 7dc62deb4087..9fdcd60c5493 100644
--- a/drivers/scsi/megaraid.c
+++ b/drivers/scsi/megaraid.c
@@ -1967,8 +1967,8 @@ megaraid_abort_and_reset(adapter_t *adapter, Scsi_Cmnd *cmd, int aor)
 			scb->state |= aor;
 
 			/*
-			 * Check if this command has firmare owenership. If
-			 * yes, we cannot reset this command. Whenever, f/w
+			 * Check if this command has firmware ownership. If
+			 * yes, we cannot reset this command. Whenever f/w
 			 * completes this command, we will return appropriate
 			 * status from ISR.
 			 */

commit 6b0eea21efed26f92e18741e54a3121cf5cd197e
Author: FUJITA Tomonori <fujita.tomonori@lab.ntt.co.jp>
Date:   Fri Oct 24 09:21:05 2008 +0900

    [SCSI] megaraid: fix mega_internal_command oops
    
    scsi_cmnd->cmnd was changed from a static array to a pointer post
    2.6.25. It breaks mega_internal_command():
    
    static int
    mega_internal_command(adapter_t *adapter, megacmd_t *mc, mega_passthru *pthru)
    {
    ...
            scb = &adapter->int_scb;
            memset(scb, 0, sizeof(scb_t));
    
            scmd = &adapter->int_scmd;
            memset(scmd, 0, sizeof(Scsi_Cmnd));
    
            sdev = kzalloc(sizeof(struct scsi_device), GFP_KERNEL);
            scmd->device = sdev;
    
            scmd->device->host = adapter->host;
            scmd->host_scribble = (void *)scb;
            scmd->cmnd[0] = MEGA_INTERNAL_CMD;
    
    mega_internal_command() uses scsi_cmnd allocated internally so
    scmd->cmnd is NULL here. This patch adds a static array for cdb to
    adapter_t and uses it here. This also uses
    scsi_allocate_command/scsi_free_command, the recommended way to
    allocate struct scsi_cmnd since the driver might use sense_buffer in
    struct scsi_cmnd.
    
    Signed-off-by: FUJITA Tomonori <fujita.tomonori@lab.ntt.co.jp>
    Reviewed-by: Boaz Harrosh <bharrosh@panasas.com>
    Tested-by: Pascal Terjan <pterjan@gmail.com>
    Reported-by: Pascal Terjan <pterjan@gmail.com>
    Acked-by: "Yang, Bo" <Bo.Yang@lsi.com>
    Signed-off-by: James Bottomley <James.Bottomley@HansenPartnership.com>

diff --git a/drivers/scsi/megaraid.c b/drivers/scsi/megaraid.c
index 28c9da7d4a5c..7dc62deb4087 100644
--- a/drivers/scsi/megaraid.c
+++ b/drivers/scsi/megaraid.c
@@ -4402,6 +4402,10 @@ mega_internal_command(adapter_t *adapter, megacmd_t *mc, mega_passthru *pthru)
 	scb_t	*scb;
 	int	rval;
 
+	scmd = scsi_allocate_command(GFP_KERNEL);
+	if (!scmd)
+		return -ENOMEM;
+
 	/*
 	 * The internal commands share one command id and hence are
 	 * serialized. This is so because we want to reserve maximum number of
@@ -4412,12 +4416,11 @@ mega_internal_command(adapter_t *adapter, megacmd_t *mc, mega_passthru *pthru)
 	scb = &adapter->int_scb;
 	memset(scb, 0, sizeof(scb_t));
 
-	scmd = &adapter->int_scmd;
-	memset(scmd, 0, sizeof(Scsi_Cmnd));
-
 	sdev = kzalloc(sizeof(struct scsi_device), GFP_KERNEL);
 	scmd->device = sdev;
 
+	memset(adapter->int_cdb, 0, sizeof(adapter->int_cdb));
+	scmd->cmnd = adapter->int_cdb;
 	scmd->device->host = adapter->host;
 	scmd->host_scribble = (void *)scb;
 	scmd->cmnd[0] = MEGA_INTERNAL_CMD;
@@ -4456,6 +4459,8 @@ mega_internal_command(adapter_t *adapter, megacmd_t *mc, mega_passthru *pthru)
 
 	mutex_unlock(&adapter->int_mtx);
 
+	scsi_free_command(GFP_KERNEL, scmd);
+
 	return rval;
 }
 

commit f2b9857eee17797541b845782ade4d7a9d50f843
Author: Jonathan Corbet <corbet@lwn.net>
Date:   Sun May 18 15:32:43 2008 -0600

    Add a bunch of cycle_kernel_lock() calls
    
    All of the open() functions which don't need the BKL on their face may
    still depend on its acquisition to serialize opens against driver
    initialization.  So make those functions acquire then release the BKL to be
    on the safe side.
    
    Signed-off-by: Jonathan Corbet <corbet@lwn.net>

diff --git a/drivers/scsi/megaraid.c b/drivers/scsi/megaraid.c
index c9aa2c45a699..28c9da7d4a5c 100644
--- a/drivers/scsi/megaraid.c
+++ b/drivers/scsi/megaraid.c
@@ -46,6 +46,7 @@
 #include <linux/pci.h>
 #include <linux/init.h>
 #include <linux/dma-mapping.h>
+#include <linux/smp_lock.h>
 #include <scsi/scsicam.h>
 
 #include "scsi.h"
@@ -3273,12 +3274,11 @@ mega_init_scb(adapter_t *adapter)
  *
  * Routines for the character/ioctl interface to the driver. Find out if this
  * is a valid open. 
- *
- * No BKL needed here.
  */
 static int
 megadev_open (struct inode *inode, struct file *filep)
 {
+	cycle_kernel_lock();
 	/*
 	 * Only allow superuser to access private ioctl interface
 	 */

commit d21c95c569c462da20d491b75d0a45bd70ddc1bf
Author: Jonathan Corbet <corbet@lwn.net>
Date:   Fri May 16 13:40:30 2008 -0600

    Add "no BKL needed" comments to several drivers
    
    This documents the fact that somebody looked at the relevant open()
    functions and concluded that, due to their trivial nature, no locking was
    needed.
    
    Signed-off-by: Jonathan Corbet <corbet@lwn.net>

diff --git a/drivers/scsi/megaraid.c b/drivers/scsi/megaraid.c
index 18551aaf5e09..c9aa2c45a699 100644
--- a/drivers/scsi/megaraid.c
+++ b/drivers/scsi/megaraid.c
@@ -3272,8 +3272,9 @@ mega_init_scb(adapter_t *adapter)
  * @filep - unused
  *
  * Routines for the character/ioctl interface to the driver. Find out if this
- * is a valid open. If yes, increment the module use count so that it cannot
- * be unloaded.
+ * is a valid open. 
+ *
+ * No BKL needed here.
  */
 static int
 megadev_open (struct inode *inode, struct file *filep)

commit c74c120a21d87b0b6925ada5830d8cac21e852d9
Author: Alexey Dobriyan <adobriyan@gmail.com>
Date:   Tue Apr 29 01:01:44 2008 -0700

    proc: remove proc_root from drivers
    
    Remove proc_root export.  Creation and removal works well if parent PDE is
    supplied as NULL -- it worked always that way.
    
    So, one useless export removed and consistency added, some drivers created
    PDEs with &proc_root as parent but removed them as NULL and so on.
    
    Signed-off-by: Alexey Dobriyan <adobriyan@gmail.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/scsi/megaraid.c b/drivers/scsi/megaraid.c
index b135a1ed4b2c..18551aaf5e09 100644
--- a/drivers/scsi/megaraid.c
+++ b/drivers/scsi/megaraid.c
@@ -4996,7 +4996,7 @@ static int __init megaraid_init(void)
 		max_mbox_busy_wait = MBOX_BUSY_WAIT;
 
 #ifdef CONFIG_PROC_FS
-	mega_proc_dir_entry = proc_mkdir("megaraid", &proc_root);
+	mega_proc_dir_entry = proc_mkdir("megaraid", NULL);
 	if (!mega_proc_dir_entry) {
 		printk(KERN_WARNING
 				"megaraid: failed to create megaraid root\n");
@@ -5005,7 +5005,7 @@ static int __init megaraid_init(void)
 	error = pci_register_driver(&megaraid_pci_driver);
 	if (error) {
 #ifdef CONFIG_PROC_FS
-		remove_proc_entry("megaraid", &proc_root);
+		remove_proc_entry("megaraid", NULL);
 #endif
 		return error;
 	}
@@ -5035,7 +5035,7 @@ static void __exit megaraid_exit(void)
 	pci_unregister_driver(&megaraid_pci_driver);
 
 #ifdef CONFIG_PROC_FS
-	remove_proc_entry("megaraid", &proc_root);
+	remove_proc_entry("megaraid", NULL);
 #endif
 }
 

commit 7d1abbe82434d29dd0d7d69dc0e6acdf25a8c2b5
Author: Alan Cox <alan@lxorguk.ukuu.org.uk>
Date:   Fri Feb 8 15:34:24 2008 +0000

    [SCSI] megaraid: outb_p extermination
    
    From conversations with the maintainers the _p isn't needed so kill it.
    That removes the last non ISA _p user from the SCSI layer to my knowledge.
    
    Signed-off-by: Alan Cox <alan@redhat.com>
    Acked-by: "Yang, Bo" <Bo.Yang@lsi.com>
    Signed-off-by: James Bottomley <James.Bottomley@HansenPartnership.com>

diff --git a/drivers/scsi/megaraid.c b/drivers/scsi/megaraid.c
index 4d59ae8491a4..b135a1ed4b2c 100644
--- a/drivers/scsi/megaraid.c
+++ b/drivers/scsi/megaraid.c
@@ -151,19 +151,19 @@ mega_setup_mailbox(adapter_t *adapter)
 	 */
 	if( adapter->flag & BOARD_IOMAP ) {
 
-		outb_p(adapter->mbox_dma & 0xFF,
+		outb(adapter->mbox_dma & 0xFF,
 				adapter->host->io_port + MBOX_PORT0);
 
-		outb_p((adapter->mbox_dma >> 8) & 0xFF,
+		outb((adapter->mbox_dma >> 8) & 0xFF,
 				adapter->host->io_port + MBOX_PORT1);
 
-		outb_p((adapter->mbox_dma >> 16) & 0xFF,
+		outb((adapter->mbox_dma >> 16) & 0xFF,
 				adapter->host->io_port + MBOX_PORT2);
 
-		outb_p((adapter->mbox_dma >> 24) & 0xFF,
+		outb((adapter->mbox_dma >> 24) & 0xFF,
 				adapter->host->io_port + MBOX_PORT3);
 
-		outb_p(ENABLE_MBOX_BYTE,
+		outb(ENABLE_MBOX_BYTE,
 				adapter->host->io_port + ENABLE_MBOX_REGION);
 
 		irq_ack(adapter);

commit d3f46f39b7092594b498abc12f0c73b0b9913bde
Author: James Bottomley <James.Bottomley@HansenPartnership.com>
Date:   Tue Jan 15 11:11:46 2008 -0600

    [SCSI] remove use_sg_chaining
    
    With the sg table code, every SCSI driver is now either chain capable
    or broken (or has sg_tablesize set so chaining is never activated), so
    there's no need to have a check in the host template.
    
    Also tidy up the code by moving the scatterlist size defines into the
    SCSI includes and permit the last entry of the scatterlist pools not
    to be a power of two.
    Signed-off-by: James Bottomley <James.Bottomley@HansenPartnership.com>

diff --git a/drivers/scsi/megaraid.c b/drivers/scsi/megaraid.c
index 765c24d2bc38..4d59ae8491a4 100644
--- a/drivers/scsi/megaraid.c
+++ b/drivers/scsi/megaraid.c
@@ -4490,7 +4490,6 @@ static struct scsi_host_template megaraid_template = {
 	.sg_tablesize			= MAX_SGLIST,
 	.cmd_per_lun			= DEF_CMD_PER_LUN,
 	.use_clustering			= ENABLE_CLUSTERING,
-	.use_sg_chaining		= ENABLE_SG_CHAINING,
 	.eh_abort_handler		= megaraid_abort,
 	.eh_device_reset_handler	= megaraid_reset,
 	.eh_bus_reset_handler		= megaraid_reset,

commit bfd90dce248a49ced2b7419ecf78af9f7f37039e
Author: Adrian Bunk <bunk@kernel.org>
Date:   Tue Dec 11 23:23:31 2007 +0100

    [SCSI] megaraid: add __devexit annotation
    
    megaraid_remove_one() can become __devexit.
    
    Signed-off-by: Adrian Bunk <bunk@kernel.org>
    Acked-by: "Patro, Sumant" <Sumant.Patro@lsi.com>
    Signed-off-by: James Bottomley <James.Bottomley@HansenPartnership.com>

diff --git a/drivers/scsi/megaraid.c b/drivers/scsi/megaraid.c
index 66c652035730..765c24d2bc38 100644
--- a/drivers/scsi/megaraid.c
+++ b/drivers/scsi/megaraid.c
@@ -4889,7 +4889,7 @@ __megaraid_shutdown(adapter_t *adapter)
 		mdelay(1000);
 }
 
-static void
+static void __devexit
 megaraid_remove_one(struct pci_dev *pdev)
 {
 	struct Scsi_Host *host = pci_get_drvdata(pdev);

commit 45711f1af6eff1a6d010703b4862e0d2b9afd056
Author: Jens Axboe <jens.axboe@oracle.com>
Date:   Mon Oct 22 21:19:53 2007 +0200

    [SG] Update drivers to use sg helpers
    
    Signed-off-by: Jens Axboe <jens.axboe@oracle.com>

diff --git a/drivers/scsi/megaraid.c b/drivers/scsi/megaraid.c
index 10d1aff9938a..66c652035730 100644
--- a/drivers/scsi/megaraid.c
+++ b/drivers/scsi/megaraid.c
@@ -658,7 +658,7 @@ mega_build_cmd(adapter_t *adapter, Scsi_Cmnd *cmd, int *busy)
 			struct scatterlist *sg;
 
 			sg = scsi_sglist(cmd);
-			buf = kmap_atomic(sg->page, KM_IRQ0) + sg->offset;
+			buf = kmap_atomic(sg_page(sg), KM_IRQ0) + sg->offset;
 
 			memset(buf, 0, cmd->cmnd[4]);
 			kunmap_atomic(buf - sg->offset, KM_IRQ0);
@@ -1542,10 +1542,8 @@ mega_cmd_done(adapter_t *adapter, u8 completed[], int nstatus, int status)
 		if( cmd->cmnd[0] == INQUIRY && !islogical ) {
 
 			sgl = scsi_sglist(cmd);
-			if( sgl->page ) {
-				c = *(unsigned char *)
-					page_address((&sgl[0])->page) +
-					(&sgl[0])->offset; 
+			if( sg_page(sgl) ) {
+				c = *(unsigned char *) sg_virt(&sgl[0]);
 			} else {
 				printk(KERN_WARNING
 				       "megaraid: invalid sg.\n");

commit 9cb83c7529d929c00f37d821daed1942a1b20602
Author: FUJITA Tomonori <tomof@acm.org>
Date:   Tue Oct 16 11:24:32 2007 +0200

    [SCSI] add use_sg_chaining option to scsi_host_template
    
    This option is true if a low-level driver can support sg
    chaining. This will be removed eventually when all the drivers are
    converted to support sg chaining. q->max_phys_segments is set to
    SCSI_MAX_SG_SEGMENTS if false.
    
    Signed-off-by: FUJITA Tomonori <fujita.tomonori@lab.ntt.co.jp>
    Signed-off-by: Jens Axboe <jens.axboe@oracle.com>

diff --git a/drivers/scsi/megaraid.c b/drivers/scsi/megaraid.c
index e7e11f282c8f..10d1aff9938a 100644
--- a/drivers/scsi/megaraid.c
+++ b/drivers/scsi/megaraid.c
@@ -4492,6 +4492,7 @@ static struct scsi_host_template megaraid_template = {
 	.sg_tablesize			= MAX_SGLIST,
 	.cmd_per_lun			= DEF_CMD_PER_LUN,
 	.use_clustering			= ENABLE_CLUSTERING,
+	.use_sg_chaining		= ENABLE_SG_CHAINING,
 	.eh_abort_handler		= megaraid_abort,
 	.eh_device_reset_handler	= megaraid_reset,
 	.eh_bus_reset_handler		= megaraid_reset,

commit df3d80f5a5c74168be42788364d13cf6c83c7b9c
Merge: 3d06f7a5f74a c8e91b0a8fc8
Author: Linus Torvalds <torvalds@woody.linux-foundation.org>
Date:   Mon Oct 15 08:19:33 2007 -0700

    Merge master.kernel.org:/pub/scm/linux/kernel/git/jejb/scsi-misc-2.6
    
    * master.kernel.org:/pub/scm/linux/kernel/git/jejb/scsi-misc-2.6: (207 commits)
      [SCSI] gdth: fix CONFIG_ISA build failure
      [SCSI] esp_scsi: remove __dev{init,exit}
      [SCSI] gdth: !use_sg cleanup and use of scsi accessors
      [SCSI] gdth: Move members from SCp to gdth_cmndinfo, stage 2
      [SCSI] gdth: Setup proper per-command private data
      [SCSI] gdth: Remove gdth_ctr_tab[]
      [SCSI] gdth: switch to modern scsi host registration
      [SCSI] gdth: gdth_interrupt() gdth_get_status() & gdth_wait() fixes
      [SCSI] gdth: clean up host private data
      [SCSI] gdth: Remove virt hosts
      [SCSI] gdth: Reorder scsi_host_template intitializers
      [SCSI] gdth: kill gdth_{read,write}[bwl] wrappers
      [SCSI] gdth: Remove 2.4.x support, in-kernel changelog
      [SCSI] gdth: split out pci probing
      [SCSI] gdth: split out eisa probing
      [SCSI] gdth: split out isa probing
      gdth: Make one abuse of scsi_cmnd less obvious
      [SCSI] NCR5380: Use scsi_eh API for REQUEST_SENSE invocation
      [SCSI] usb storage: use scsi_eh API in REQUEST_SENSE execution
      [SCSI] scsi_error: Refactoring scsi_error to facilitate in synchronous REQUEST_SENSE
      ...

commit bbfbbbc1182f8b44c8cc4c99f4a3f3a512149022
Author: Mariusz Kozlowski <m.kozlowski@tuxland.pl>
Date:   Sat Aug 11 10:13:24 2007 +0200

    [SCSI] kmalloc + memset conversion to kzalloc
    
    In NCR_D700, a4000t, aic7xxx_old, bvme6000, dpt_i2o, gdth, lpfc,
    megaraid, mvme16x osst, pluto, qla2xxx, zorro7xx
    
    Signed-off-by: Mariusz Kozlowski <m.kozlowski@tuxland.pl>
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>

diff --git a/drivers/scsi/megaraid.c b/drivers/scsi/megaraid.c
index 3907f6718ede..9023ec6a0f8e 100644
--- a/drivers/scsi/megaraid.c
+++ b/drivers/scsi/megaraid.c
@@ -4408,8 +4408,7 @@ mega_internal_command(adapter_t *adapter, megacmd_t *mc, mega_passthru *pthru)
 	scmd = &adapter->int_scmd;
 	memset(scmd, 0, sizeof(Scsi_Cmnd));
 
-	sdev = kmalloc(sizeof(struct scsi_device), GFP_KERNEL);
-	memset(sdev, 0, sizeof(struct scsi_device));
+	sdev = kzalloc(sizeof(struct scsi_device), GFP_KERNEL);
 	scmd->device = sdev;
 
 	scmd->device->host = adapter->host;

commit d5e89385e92a77b2764d9eb8284808a7628cb2a8
Author: FUJITA Tomonori <fujita.tomonori@lab.ntt.co.jp>
Date:   Wed Oct 3 09:00:58 2007 +0900

    [SCSI] megaraid_old: fix READ_CAPACITY
    
    The bulk transfer mode got eleminated by
    3f6270ef76f2ce5c134615a470685d6c2a66c07e.  Unfortunately, this mode is
    required for READ_CAPACITY commands on certain cards, so put it back
    again.  This fixes a boot failure regression reported by Burton
    Windle.
    
    Signed-off-by: FUJITA Tomonori <fujita.tomonori@lab.ntt.co.jp>
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>

diff --git a/drivers/scsi/megaraid.c b/drivers/scsi/megaraid.c
index 3907f6718ede..da56163c30a8 100644
--- a/drivers/scsi/megaraid.c
+++ b/drivers/scsi/megaraid.c
@@ -1753,6 +1753,14 @@ mega_build_sglist(adapter_t *adapter, scb_t *scb, u32 *buf, u32 *len)
 
 	*len = 0;
 
+	if (scsi_sg_count(cmd) == 1 && !adapter->has_64bit_addr) {
+		sg = scsi_sglist(cmd);
+		scb->dma_h_bulkdata = sg_dma_address(sg);
+		*buf = (u32)scb->dma_h_bulkdata;
+		*len = sg_dma_len(sg);
+		return 0;
+	}
+
 	scsi_for_each_sg(cmd, sg, sgcnt, idx) {
 		if (adapter->has_64bit_addr) {
 			scb->sgl64[idx].address = sg_dma_address(sg);

commit 3f6270ef76f2ce5c134615a470685d6c2a66c07e
Author: FUJITA Tomonori <fujita.tomonori@lab.ntt.co.jp>
Date:   Mon May 14 20:17:27 2007 +0900

    [SCSI] megaraid_old: convert to use the data buffer accessors
    
    - remove the unnecessary map_single path.
    
    - convert to use the new accessors for the sg lists and the
    parameters.
    
    Jens Axboe <jens.axboe@oracle.com> did the for_each_sg cleanup.
    
    Signed-off-by: FUJITA Tomonori <fujita.tomonori@lab.ntt.co.jp>
    Acked-by: Sumant Patro <sumant.patro@lsi.com>
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>

diff --git a/drivers/scsi/megaraid.c b/drivers/scsi/megaraid.c
index 40ee07dab450..3907f6718ede 100644
--- a/drivers/scsi/megaraid.c
+++ b/drivers/scsi/megaraid.c
@@ -523,10 +523,8 @@ mega_build_cmd(adapter_t *adapter, Scsi_Cmnd *cmd, int *busy)
 	/*
 	 * filter the internal and ioctl commands
 	 */
-	if((cmd->cmnd[0] == MEGA_INTERNAL_CMD)) {
-		return cmd->request_buffer;
-	}
-
+	if((cmd->cmnd[0] == MEGA_INTERNAL_CMD))
+		return (scb_t *)cmd->host_scribble;
 
 	/*
 	 * We know what channels our logical drives are on - mega_find_card()
@@ -657,22 +655,14 @@ mega_build_cmd(adapter_t *adapter, Scsi_Cmnd *cmd, int *busy)
 
 		case MODE_SENSE: {
 			char *buf;
+			struct scatterlist *sg;
 
-			if (cmd->use_sg) {
-				struct scatterlist *sg;
+			sg = scsi_sglist(cmd);
+			buf = kmap_atomic(sg->page, KM_IRQ0) + sg->offset;
 
-				sg = (struct scatterlist *)cmd->request_buffer;
-				buf = kmap_atomic(sg->page, KM_IRQ0) +
-					sg->offset;
-			} else
-				buf = cmd->request_buffer;
 			memset(buf, 0, cmd->cmnd[4]);
-			if (cmd->use_sg) {
-				struct scatterlist *sg;
+			kunmap_atomic(buf - sg->offset, KM_IRQ0);
 
-				sg = (struct scatterlist *)cmd->request_buffer;
-				kunmap_atomic(buf - sg->offset, KM_IRQ0);
-			}
 			cmd->result = (DID_OK << 16);
 			cmd->scsi_done(cmd);
 			return NULL;
@@ -1551,23 +1541,15 @@ mega_cmd_done(adapter_t *adapter, u8 completed[], int nstatus, int status)
 		islogical = adapter->logdrv_chan[cmd->device->channel];
 		if( cmd->cmnd[0] == INQUIRY && !islogical ) {
 
-			if( cmd->use_sg ) {
-				sgl = (struct scatterlist *)
-					cmd->request_buffer;
-
-				if( sgl->page ) {
-					c = *(unsigned char *)
+			sgl = scsi_sglist(cmd);
+			if( sgl->page ) {
+				c = *(unsigned char *)
 					page_address((&sgl[0])->page) +
 					(&sgl[0])->offset; 
-				}
-				else {
-					printk(KERN_WARNING
-						"megaraid: invalid sg.\n");
-					c = 0;
-				}
-			}
-			else {
-				c = *(u8 *)cmd->request_buffer;
+			} else {
+				printk(KERN_WARNING
+				       "megaraid: invalid sg.\n");
+				c = 0;
 			}
 
 			if(IS_RAID_CH(adapter, cmd->device->channel) &&
@@ -1704,30 +1686,14 @@ mega_rundoneq (adapter_t *adapter)
 static void
 mega_free_scb(adapter_t *adapter, scb_t *scb)
 {
-	unsigned long length;
-
 	switch( scb->dma_type ) {
 
 	case MEGA_DMA_TYPE_NONE:
 		break;
 
-	case MEGA_BULK_DATA:
-		if (scb->cmd->use_sg == 0)
-			length = scb->cmd->request_bufflen;
-		else {
-			struct scatterlist *sgl =
-				(struct scatterlist *)scb->cmd->request_buffer;
-			length = sgl->length;
-		}
-		pci_unmap_page(adapter->dev, scb->dma_h_bulkdata,
-			       length, scb->dma_direction);
-		break;
-
 	case MEGA_SGLIST:
-		pci_unmap_sg(adapter->dev, scb->cmd->request_buffer,
-			scb->cmd->use_sg, scb->dma_direction);
+		scsi_dma_unmap(scb->cmd);
 		break;
-
 	default:
 		break;
 	}
@@ -1767,80 +1733,33 @@ __mega_busywait_mbox (adapter_t *adapter)
 static int
 mega_build_sglist(adapter_t *adapter, scb_t *scb, u32 *buf, u32 *len)
 {
-	struct scatterlist	*sgl;
-	struct page	*page;
-	unsigned long	offset;
-	unsigned int	length;
+	struct scatterlist *sg;
 	Scsi_Cmnd	*cmd;
 	int	sgcnt;
 	int	idx;
 
 	cmd = scb->cmd;
 
-	/* Scatter-gather not used */
-	if( cmd->use_sg == 0 || (cmd->use_sg == 1 && 
-				 !adapter->has_64bit_addr)) {
-
-		if (cmd->use_sg == 0) {
-			page = virt_to_page(cmd->request_buffer);
-			offset = offset_in_page(cmd->request_buffer);
-			length = cmd->request_bufflen;
-		} else {
-			sgl = (struct scatterlist *)cmd->request_buffer;
-			page = sgl->page;
-			offset = sgl->offset;
-			length = sgl->length;
-		}
-
-		scb->dma_h_bulkdata = pci_map_page(adapter->dev,
-						  page, offset,
-						  length,
-						  scb->dma_direction);
-		scb->dma_type = MEGA_BULK_DATA;
-
-		/*
-		 * We need to handle special 64-bit commands that need a
-		 * minimum of 1 SG
-		 */
-		if( adapter->has_64bit_addr ) {
-			scb->sgl64[0].address = scb->dma_h_bulkdata;
-			scb->sgl64[0].length = length;
-			*buf = (u32)scb->sgl_dma_addr;
-			*len = (u32)length;
-			return 1;
-		}
-		else {
-			*buf = (u32)scb->dma_h_bulkdata;
-			*len = (u32)length;
-		}
-		return 0;
-	}
-
-	sgl = (struct scatterlist *)cmd->request_buffer;
-
 	/*
 	 * Copy Scatter-Gather list info into controller structure.
 	 *
 	 * The number of sg elements returned must not exceed our limit
 	 */
-	sgcnt = pci_map_sg(adapter->dev, sgl, cmd->use_sg,
-			scb->dma_direction);
+	sgcnt = scsi_dma_map(cmd);
 
 	scb->dma_type = MEGA_SGLIST;
 
-	BUG_ON(sgcnt > adapter->sglen);
+	BUG_ON(sgcnt > adapter->sglen || sgcnt < 0);
 
 	*len = 0;
 
-	for( idx = 0; idx < sgcnt; idx++, sgl++ ) {
-
-		if( adapter->has_64bit_addr ) {
-			scb->sgl64[idx].address = sg_dma_address(sgl);
-			*len += scb->sgl64[idx].length = sg_dma_len(sgl);
-		}
-		else {
-			scb->sgl[idx].address = sg_dma_address(sgl);
-			*len += scb->sgl[idx].length = sg_dma_len(sgl);
+	scsi_for_each_sg(cmd, sg, sgcnt, idx) {
+		if (adapter->has_64bit_addr) {
+			scb->sgl64[idx].address = sg_dma_address(sg);
+			*len += scb->sgl64[idx].length = sg_dma_len(sg);
+		} else {
+			scb->sgl[idx].address = sg_dma_address(sg);
+			*len += scb->sgl[idx].length = sg_dma_len(sg);
 		}
 	}
 
@@ -4494,7 +4413,7 @@ mega_internal_command(adapter_t *adapter, megacmd_t *mc, mega_passthru *pthru)
 	scmd->device = sdev;
 
 	scmd->device->host = adapter->host;
-	scmd->request_buffer = (void *)scb;
+	scmd->host_scribble = (void *)scb;
 	scmd->cmnd[0] = MEGA_INTERNAL_CMD;
 
 	scb->state |= SCB_ACTIVE;

commit de5952e91caf41bd838a787c7b9b6ca2e1292484
Author: Martin Bligh <mbligh@google.com>
Date:   Wed May 23 16:11:46 2007 -0700

    [SCSI] megaraid: fix compiler warnings
    
    The user ioctl mailbox can only support a 32 bit address for the
    commands structure.  This is fine, since the area it's pointing to is
    allocated with pci_alloc_consistent(), so it should be physically <
    4GB.  Thus kill the ptr to u32 conversion warnings on 64 bit.
    
    Signed-off-by: Martin J. Bligh <mbligh@google.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Acked-by: "Patro, Sumant" <Sumant.Patro@lsi.com>
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>

diff --git a/drivers/scsi/megaraid.c b/drivers/scsi/megaraid.c
index 3cce75d70263..40ee07dab450 100644
--- a/drivers/scsi/megaraid.c
+++ b/drivers/scsi/megaraid.c
@@ -3571,7 +3571,7 @@ megadev_ioctl(struct inode *inode, struct file *filep, unsigned int cmd,
 			/*
 			 * The user passthru structure
 			 */
-			upthru = (mega_passthru __user *)MBOX(uioc)->xferaddr;
+			upthru = (mega_passthru __user *)(unsigned long)MBOX(uioc)->xferaddr;
 
 			/*
 			 * Copy in the user passthru here.
@@ -3623,7 +3623,7 @@ megadev_ioctl(struct inode *inode, struct file *filep, unsigned int cmd,
 				/*
 				 * Get the user data
 				 */
-				if( copy_from_user(data, (char __user *)uxferaddr,
+				if( copy_from_user(data, (char __user *)(unsigned long) uxferaddr,
 							pthru->dataxferlen) ) {
 					rval = (-EFAULT);
 					goto freemem_and_return;
@@ -3649,7 +3649,7 @@ megadev_ioctl(struct inode *inode, struct file *filep, unsigned int cmd,
 			 * Is data going up-stream
 			 */
 			if( pthru->dataxferlen && (uioc.flags & UIOC_RD) ) {
-				if( copy_to_user((char __user *)uxferaddr, data,
+				if( copy_to_user((char __user *)(unsigned long) uxferaddr, data,
 							pthru->dataxferlen) ) {
 					rval = (-EFAULT);
 				}
@@ -3702,7 +3702,7 @@ megadev_ioctl(struct inode *inode, struct file *filep, unsigned int cmd,
 				/*
 				 * Get the user data
 				 */
-				if( copy_from_user(data, (char __user *)uxferaddr,
+				if( copy_from_user(data, (char __user *)(unsigned long) uxferaddr,
 							uioc.xferlen) ) {
 
 					pci_free_consistent(pdev,
@@ -3742,7 +3742,7 @@ megadev_ioctl(struct inode *inode, struct file *filep, unsigned int cmd,
 			 * Is data going up-stream
 			 */
 			if( uioc.xferlen && (uioc.flags & UIOC_RD) ) {
-				if( copy_to_user((char __user *)uxferaddr, data,
+				if( copy_to_user((char __user *)(unsigned long) uxferaddr, data,
 							uioc.xferlen) ) {
 
 					rval = (-EFAULT);

commit e1fa0ceaf366ba8042a388d02ce841b36d063fe2
Author: Amol Lad <amol@verismonetworks.com>
Date:   Thu Apr 26 00:35:13 2007 -0700

    [SCSI] megaraid: replace yield() with cond_resched()
    
    For this driver cond_resched() seems to be a better alternative
    
    Signed-off-by: Amol Lad <amol@verismonetworks.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>

diff --git a/drivers/scsi/megaraid.c b/drivers/scsi/megaraid.c
index 65bc130430e2..3cce75d70263 100644
--- a/drivers/scsi/megaraid.c
+++ b/drivers/scsi/megaraid.c
@@ -1754,7 +1754,8 @@ __mega_busywait_mbox (adapter_t *adapter)
 	for (counter = 0; counter < 10000; counter++) {
 		if (!mbox->m_in.busy)
 			return 0;
-		udelay(100); yield();
+		udelay(100);
+		cond_resched();
 	}
 	return -1;		/* give up after 1 second */
 }

commit 84a3c97b93ec5b4509637801a703693bb710cd4c
Author: walter harms <wharms@bfs.de>
Date:   Thu Apr 26 00:35:09 2007 -0700

    [SCSI] megaraid: fix warnings when CONFIG_PROC_FS=n
    
    drivers/scsi/megaraid.c: In function 'megaraid_probe_one':
    drivers/scsi/megaraid.c:4893: warning: implicit declaration of function 'mega_create_proc_entry'
    drivers/scsi/megaraid.c: In function 'megaraid_remove_one':
    drivers/scsi/megaraid.c:4968: warning: unused variable 'buf'
    
    Fix by adding #defines
    
    Signed-off-by: walter harms <wharms@bfs.de>
    Signed-off-by: Alexey Dobriyan <adobriyan@gmail.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>

diff --git a/drivers/scsi/megaraid.c b/drivers/scsi/megaraid.c
index 7fc6e06ea7e1..65bc130430e2 100644
--- a/drivers/scsi/megaraid.c
+++ b/drivers/scsi/megaraid.c
@@ -3177,7 +3177,10 @@ proc_rdrv(adapter_t *adapter, char *page, int start, int end )
 
 	return len;
 }
-
+#else
+static inline void mega_create_proc_entry(int index, struct proc_dir_entry *parent)
+{
+}
 #endif
 
 
@@ -4342,7 +4345,7 @@ mega_support_cluster(adapter_t *adapter)
 	return 0;
 }
 
-
+#ifdef CONFIG_PROC_FS
 /**
  * mega_adapinq()
  * @adapter - pointer to our soft state
@@ -4447,7 +4450,7 @@ mega_internal_dev_inquiry(adapter_t *adapter, u8 ch, u8 tgt,
 
 	return rval;
 }
-
+#endif
 
 /**
  * mega_internal_command()
@@ -4965,7 +4968,6 @@ megaraid_remove_one(struct pci_dev *pdev)
 {
 	struct Scsi_Host *host = pci_get_drvdata(pdev);
 	adapter_t *adapter = (adapter_t *)host->hostdata;
-	char	buf[12] = { 0 };
 
 	scsi_remove_host(host);
 
@@ -5011,8 +5013,11 @@ megaraid_remove_one(struct pci_dev *pdev)
 		remove_proc_entry("raiddrives-30-39",
 				adapter->controller_proc_dir_entry);
 #endif
-		sprintf(buf, "hba%d", adapter->host->host_no);
-		remove_proc_entry(buf, mega_proc_dir_entry);
+		{
+			char	buf[12] = { 0 };
+			sprintf(buf, "hba%d", adapter->host->host_no);
+			remove_proc_entry(buf, mega_proc_dir_entry);
+		}
 	}
 #endif
 

commit bab41e9be75121c473b00df2ffa33af3c44066a7
Author: Michael Ellerman <michael@ellerman.id.au>
Date:   Thu Apr 5 17:19:09 2007 +1000

    PCI: Convert to alloc_pci_dev()
    
    Convert code that allocs a struct pci_dev to use alloc_pci_dev().
    
    Signed-off-by: Michael Ellerman <michael@ellerman.id.au>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/scsi/megaraid.c b/drivers/scsi/megaraid.c
index 0aa3304f6b9b..7fc6e06ea7e1 100644
--- a/drivers/scsi/megaraid.c
+++ b/drivers/scsi/megaraid.c
@@ -2088,7 +2088,7 @@ megaraid_abort_and_reset(adapter_t *adapter, Scsi_Cmnd *cmd, int aor)
 static inline int
 make_local_pdev(adapter_t *adapter, struct pci_dev **pdev)
 {
-	*pdev = kmalloc(sizeof(struct pci_dev), GFP_KERNEL);
+	*pdev = alloc_pci_dev();
 
 	if( *pdev == NULL ) return -1;
 

commit 4520b0089b41151ab3cc3ae1ee92d0aa19d88aae
Author: Richard Knutsson <ricknu-0@student.ltu.se>
Date:   Wed Feb 14 01:40:39 2007 +0100

    [SCSI] megaraid: pci_module_init to pci_register_driver
    
    Convert pci_module_init() to pci_register_driver().
    
    Signed-off-by: Richard Knutsson <ricknu-0@student.ltu.se>
    Acked-by: "Patro, Sumant" <Sumant.Patro@lsi.com>
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>

diff --git a/drivers/scsi/megaraid.c b/drivers/scsi/megaraid.c
index 808a1b8c4043..0aa3304f6b9b 100644
--- a/drivers/scsi/megaraid.c
+++ b/drivers/scsi/megaraid.c
@@ -5072,7 +5072,7 @@ static int __init megaraid_init(void)
 				"megaraid: failed to create megaraid root\n");
 	}
 #endif
-	error = pci_module_init(&megaraid_pci_driver);
+	error = pci_register_driver(&megaraid_pci_driver);
 	if (error) {
 #ifdef CONFIG_PROC_FS
 		remove_proc_entry("megaraid", &proc_root);

commit 00977a59b951207d38380c75f03a36829950265c
Author: Arjan van de Ven <arjan@linux.intel.com>
Date:   Mon Feb 12 00:55:34 2007 -0800

    [PATCH] mark struct file_operations const 6
    
    Many struct file_operations in the kernel can be "const".  Marking them const
    moves these to the .rodata section, which avoids false sharing with potential
    dirty data.  In addition it'll catch accidental writes at compile time to
    these shared resources.
    
    Signed-off-by: Arjan van de Ven <arjan@linux.intel.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/scsi/megaraid.c b/drivers/scsi/megaraid.c
index 77d9d3804ccf..808a1b8c4043 100644
--- a/drivers/scsi/megaraid.c
+++ b/drivers/scsi/megaraid.c
@@ -92,7 +92,7 @@ static struct mega_hbas mega_hbas[MAX_CONTROLLERS];
 /*
  * The File Operations structure for the serial/ioctl interface of the driver
  */
-static struct file_operations megadev_fops = {
+static const struct file_operations megadev_fops = {
 	.owner		= THIS_MODULE,
 	.ioctl		= megadev_ioctl,
 	.open		= megadev_open,

commit 00769ec40074b753c9b218c2ccaba2bfbfffe056
Author: Jeff Garzik <jeff@garzik.org>
Date:   Sun Dec 3 20:49:23 2006 -0500

    [SCSI] megaraid: fix MMIO casts
    
    megaraid's MMIO RD*/WR* macros directly call readl() and writel() with
    an 'unsigned long' argument.  This throws a warning, but is otherwise OK
    because the 'unsigned long' is really the result of ioremap().  This
    setup is also OK because the variable can hold an ioremap cookie /or/ a
    PCI I/O port (PIO).
    
    However, to fix the warning thrown when readl() and writel() are passed
    an unsigned long cookie, I introduce 'void __iomem *mmio_base', holding
    the same value as 'base'.  This will silence the warnings, and also
    cause an oops whenever these MMIO-only functions are ever accidentally
    passed an I/O address.
    
    Signed-off-by: Jeff Garzik <jeff@garzik.org>
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>

diff --git a/drivers/scsi/megaraid.c b/drivers/scsi/megaraid.c
index 86099fde1b2a..77d9d3804ccf 100644
--- a/drivers/scsi/megaraid.c
+++ b/drivers/scsi/megaraid.c
@@ -73,10 +73,10 @@ static unsigned short int max_mbox_busy_wait = MBOX_BUSY_WAIT;
 module_param(max_mbox_busy_wait, ushort, 0);
 MODULE_PARM_DESC(max_mbox_busy_wait, "Maximum wait for mailbox in microseconds if busy (default=MBOX_BUSY_WAIT=10)");
 
-#define RDINDOOR(adapter)		readl((adapter)->base + 0x20)
-#define RDOUTDOOR(adapter)		readl((adapter)->base + 0x2C)
-#define WRINDOOR(adapter,value)		writel(value, (adapter)->base + 0x20)
-#define WROUTDOOR(adapter,value)	writel(value, (adapter)->base + 0x2C)
+#define RDINDOOR(adapter)	readl((adapter)->mmio_base + 0x20)
+#define RDOUTDOOR(adapter)	readl((adapter)->mmio_base + 0x2C)
+#define WRINDOOR(adapter,value)	 writel(value, (adapter)->mmio_base + 0x20)
+#define WROUTDOOR(adapter,value) writel(value, (adapter)->mmio_base + 0x2C)
 
 /*
  * Global variables
@@ -1386,7 +1386,8 @@ megaraid_isr_memmapped(int irq, void *devp)
 
 		handled = 1;
 
-		while( RDINDOOR(adapter) & 0x02 ) cpu_relax();
+		while( RDINDOOR(adapter) & 0x02 )
+			cpu_relax();
 
 		mega_cmd_done(adapter, completed, nstatus, status);
 
@@ -4668,6 +4669,8 @@ megaraid_probe_one(struct pci_dev *pdev, const struct pci_device_id *id)
 		host->host_no, mega_baseport, irq);
 
 	adapter->base = mega_baseport;
+	if (flag & BOARD_MEMMAP)
+		adapter->mmio_base = (void __iomem *) mega_baseport;
 
 	INIT_LIST_HEAD(&adapter->free_list);
 	INIT_LIST_HEAD(&adapter->pending_list);

commit 7d12e780e003f93433d49ce78cfedf4b4c52adc5
Author: David Howells <dhowells@redhat.com>
Date:   Thu Oct 5 14:55:46 2006 +0100

    IRQ: Maintain regs pointer globally rather than passing to IRQ handlers
    
    Maintain a per-CPU global "struct pt_regs *" variable which can be used instead
    of passing regs around manually through all ~1800 interrupt handlers in the
    Linux kernel.
    
    The regs pointer is used in few places, but it potentially costs both stack
    space and code to pass it around.  On the FRV arch, removing the regs parameter
    from all the genirq function results in a 20% speed up of the IRQ exit path
    (ie: from leaving timer_interrupt() to leaving do_IRQ()).
    
    Where appropriate, an arch may override the generic storage facility and do
    something different with the variable.  On FRV, for instance, the address is
    maintained in GR28 at all times inside the kernel as part of general exception
    handling.
    
    Having looked over the code, it appears that the parameter may be handed down
    through up to twenty or so layers of functions.  Consider a USB character
    device attached to a USB hub, attached to a USB controller that posts its
    interrupts through a cascaded auxiliary interrupt controller.  A character
    device driver may want to pass regs to the sysrq handler through the input
    layer which adds another few layers of parameter passing.
    
    I've build this code with allyesconfig for x86_64 and i386.  I've runtested the
    main part of the code on FRV and i386, though I can't test most of the drivers.
    I've also done partial conversion for powerpc and MIPS - these at least compile
    with minimal configurations.
    
    This will affect all archs.  Mostly the changes should be relatively easy.
    Take do_IRQ(), store the regs pointer at the beginning, saving the old one:
    
            struct pt_regs *old_regs = set_irq_regs(regs);
    
    And put the old one back at the end:
    
            set_irq_regs(old_regs);
    
    Don't pass regs through to generic_handle_irq() or __do_IRQ().
    
    In timer_interrupt(), this sort of change will be necessary:
    
            -       update_process_times(user_mode(regs));
            -       profile_tick(CPU_PROFILING, regs);
            +       update_process_times(user_mode(get_irq_regs()));
            +       profile_tick(CPU_PROFILING);
    
    I'd like to move update_process_times()'s use of get_irq_regs() into itself,
    except that i386, alone of the archs, uses something other than user_mode().
    
    Some notes on the interrupt handling in the drivers:
    
     (*) input_dev() is now gone entirely.  The regs pointer is no longer stored in
         the input_dev struct.
    
     (*) finish_unlinks() in drivers/usb/host/ohci-q.c needs checking.  It does
         something different depending on whether it's been supplied with a regs
         pointer or not.
    
     (*) Various IRQ handler function pointers have been moved to type
         irq_handler_t.
    
    Signed-Off-By: David Howells <dhowells@redhat.com>
    (cherry picked from 1b16e7ac850969f38b375e511e3fa2f474a33867 commit)

diff --git a/drivers/scsi/megaraid.c b/drivers/scsi/megaraid.c
index b87bef69ba0f..86099fde1b2a 100644
--- a/drivers/scsi/megaraid.c
+++ b/drivers/scsi/megaraid.c
@@ -1256,14 +1256,13 @@ issue_scb_block(adapter_t *adapter, u_char *raw_mbox)
  * megaraid_isr_iomapped()
  * @irq - irq
  * @devp - pointer to our soft state
- * @regs - unused
  *
  * Interrupt service routine for io-mapped controllers.
  * Find out if our device is interrupting. If yes, acknowledge the interrupt
  * and service the completed commands.
  */
 static irqreturn_t
-megaraid_isr_iomapped(int irq, void *devp, struct pt_regs *regs)
+megaraid_isr_iomapped(int irq, void *devp)
 {
 	adapter_t	*adapter = devp;
 	unsigned long	flags;
@@ -1333,14 +1332,13 @@ megaraid_isr_iomapped(int irq, void *devp, struct pt_regs *regs)
  * megaraid_isr_memmapped()
  * @irq - irq
  * @devp - pointer to our soft state
- * @regs - unused
  *
  * Interrupt service routine for memory-mapped controllers.
  * Find out if our device is interrupting. If yes, acknowledge the interrupt
  * and service the completed commands.
  */
 static irqreturn_t
-megaraid_isr_memmapped(int irq, void *devp, struct pt_regs *regs)
+megaraid_isr_memmapped(int irq, void *devp)
 {
 	adapter_t	*adapter = devp;
 	unsigned long	flags;

commit 2d2f8d59b14bec6c745e219a350ac51d9e00673f
Author: Jesper Juhl <jesper.juhl@gmail.com>
Date:   Fri Sep 15 14:43:11 2006 +0200

    [SCSI] megaraid: Make megaraid_ioctl() check copy_to_user() return value
    
    Check copy_to_user() return value in drivers/scsi/megaraid.c::megadev_ioctl()
    This gets rid of this little warning:
      drivers/scsi/megaraid.c:3661: warning: ignoring return value of 'copy_to_user', declared with attribute warn_unused_result
    
    Signed-off-by: Jesper Juhl <jesper.juhl@gmail.com>
    Acked-by: "Ju, Seokmann" <Seokmann.Ju@lsil.com>
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>

diff --git a/drivers/scsi/megaraid.c b/drivers/scsi/megaraid.c
index ccb0055ac73a..b87bef69ba0f 100644
--- a/drivers/scsi/megaraid.c
+++ b/drivers/scsi/megaraid.c
@@ -3656,8 +3656,9 @@ megadev_ioctl(struct inode *inode, struct file *filep, unsigned int cmd,
 			 * Send the request sense data also, irrespective of
 			 * whether the user has asked for it or not.
 			 */
-			copy_to_user(upthru->reqsensearea,
-					pthru->reqsensearea, 14);
+			if (copy_to_user(upthru->reqsensearea,
+					pthru->reqsensearea, 14))
+				rval = -EFAULT;
 
 freemem_and_return:
 			if( pthru->dataxferlen ) {

commit 4ff36718ede26ee2da73f2dae94d71e2b06845fc
Author: Matthew Wilcox <matthew@wil.cx>
Date:   Tue Jul 4 12:15:20 2006 -0600

    [SCSI] Improve inquiry printing
    
     - Replace scsi_device_types array API with scsi_device_type function API.
       Gets rid of a lot of common code, as well as being easier to use.
     - Add the new device types in SPC4 r05a, and rename some of the older ones.
     - Reformat the printing of inquiry data; now fits on one line and
       includes PQ.
    
    I think I've addressed all the feedback from the previous versions.  My
    current test box prints:
    
    scsi 2:0:1:0: Direct access     HP 18.2G ATLAS10K3_18_SCA HP05 PQ: 0 ANSI: 2
    
    Signed-off-by: Matthew Wilcox <matthew@wil.cx>
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>

diff --git a/drivers/scsi/megaraid.c b/drivers/scsi/megaraid.c
index 76edbb639d37..ccb0055ac73a 100644
--- a/drivers/scsi/megaraid.c
+++ b/drivers/scsi/megaraid.c
@@ -2822,9 +2822,7 @@ mega_print_inquiry(char *page, char *scsi_inq)
 
 	i = scsi_inq[0] & 0x1f;
 
-	len += sprintf(page+len, "  Type:   %s ",
-		i < MAX_SCSI_DEVICE_CODE ? scsi_device_types[i] :
-		   "Unknown          ");
+	len += sprintf(page+len, "  Type:   %s ", scsi_device_type(i));
 
 	len += sprintf(page+len,
 	"                 ANSI SCSI revision: %02x", scsi_inq[2] & 0x07);

commit 1d6f359a2e06296418481239f8054a878f36e819
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Sat Jul 1 19:29:42 2006 -0700

    [PATCH] irq-flags: scsi: Use the new IRQF_ constants
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: Ingo Molnar <mingo@elte.hu>
    Cc: "David S. Miller" <davem@davemloft.net>
    Cc: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Cc: James Bottomley <James.Bottomley@steeleye.com>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/drivers/scsi/megaraid.c b/drivers/scsi/megaraid.c
index 5d2cefb5e52d..76edbb639d37 100644
--- a/drivers/scsi/megaraid.c
+++ b/drivers/scsi/megaraid.c
@@ -4714,7 +4714,7 @@ megaraid_probe_one(struct pci_dev *pdev, const struct pci_device_id *id)
 
 	if (request_irq(irq, (adapter->flag & BOARD_MEMMAP) ?
 				megaraid_isr_memmapped : megaraid_isr_iomapped,
-					SA_SHIRQ, "megaraid", adapter)) {
+					IRQF_SHARED, "megaraid", adapter)) {
 		printk(KERN_WARNING
 			"megaraid: Couldn't register IRQ %d!\n", irq);
 		goto out_free_scb_list;

commit 125e18745f16685f69a34fd6130d47598fc4bf54
Author: Eric Sesterhenn <snakebyte@gmx.de>
Date:   Fri Jun 23 02:06:06 2006 -0700

    [PATCH] More BUG_ON conversion
    
    Signed-off-by: Eric Sesterhenn <snakebyte@gmx.de>
    Signed-off-by: Alexey Dobriyan <adobriyan@gmail.com>
    Cc: Bartlomiej Zolnierkiewicz <B.Zolnierkiewicz@elka.pw.edu.pl>
    Cc: Alan Cox <alan@lxorguk.ukuu.org.uk>
    Cc: James Bottomley <James.Bottomley@steeleye.com>
    Acked-by: "Salyzyn, Mark" <mark_salyzyn@adaptec.com>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/drivers/scsi/megaraid.c b/drivers/scsi/megaraid.c
index c33857e7b33b..5d2cefb5e52d 100644
--- a/drivers/scsi/megaraid.c
+++ b/drivers/scsi/megaraid.c
@@ -1828,7 +1828,7 @@ mega_build_sglist(adapter_t *adapter, scb_t *scb, u32 *buf, u32 *len)
 
 	scb->dma_type = MEGA_SGLIST;
 
-	if( sgcnt > adapter->sglen ) BUG();
+	BUG_ON(sgcnt > adapter->sglen);
 
 	*len = 0;
 

commit f0cd91a68acdc9b49d7f6738b514a426da627649
Merge: 60eef25701d2 128e6ced247c
Author: James Bottomley <jejb@mulgrave.il.steeleye.com>
Date:   Sat Jun 10 13:47:26 2006 -0500

    Merge ../linux-2.6

commit 5d5ff44fe6775ccb922fd1f7d478b2ba9ca95068
Author: Christoph Hellwig <hch@lst.de>
Date:   Sat Jun 3 13:21:13 2006 +0200

    [SCSI] fix up request buffer reference in various scsi drivers
    
    Various scsi drivers use scsi_cmnd.buffer and scsi_cmnd.bufflen in their
    queuecommand functions.  Those fields are internal storage for the
    midlayer only and are used to restore the original payload after
    request_buffer and request_bufflen have been overwritten for EH.  Using
    the buffer and bufflen fields means they do very broken things in error
    handling.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>

diff --git a/drivers/scsi/megaraid.c b/drivers/scsi/megaraid.c
index 80b68a2481b3..d245717fee65 100644
--- a/drivers/scsi/megaraid.c
+++ b/drivers/scsi/megaraid.c
@@ -524,7 +524,7 @@ mega_build_cmd(adapter_t *adapter, Scsi_Cmnd *cmd, int *busy)
 	 * filter the internal and ioctl commands
 	 */
 	if((cmd->cmnd[0] == MEGA_INTERNAL_CMD)) {
-		return cmd->buffer;
+		return cmd->request_buffer;
 	}
 
 
@@ -4493,7 +4493,7 @@ mega_internal_command(adapter_t *adapter, megacmd_t *mc, mega_passthru *pthru)
 	scmd->device = sdev;
 
 	scmd->device->host = adapter->host;
-	scmd->buffer = (void *)scb;
+	scmd->request_buffer = (void *)scb;
 	scmd->cmnd[0] = MEGA_INTERNAL_CMD;
 
 	scb->state |= SCB_ACTIVE;

commit 52988410587db6b4992a8c1e6193777e27f37dc7
Author: Andrew Morton <akpm@osdl.org>
Date:   Tue Apr 18 21:09:10 2006 -0700

    [SCSI] megaraid: unused variable
    
    drivers/scsi/megaraid.c: In function `mega_internal_command':
    drivers/scsi/megaraid.c:4474: warning: unused variable `flags'
    
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>

diff --git a/drivers/scsi/megaraid.c b/drivers/scsi/megaraid.c
index 80b68a2481b3..de35ffe2f79d 100644
--- a/drivers/scsi/megaraid.c
+++ b/drivers/scsi/megaraid.c
@@ -4471,7 +4471,6 @@ mega_internal_command(adapter_t *adapter, megacmd_t *mc, mega_passthru *pthru)
 {
 	Scsi_Cmnd	*scmd;
 	struct	scsi_device *sdev;
-	unsigned long	flags = 0;
 	scb_t	*scb;
 	int	rval;
 

commit 910638ae7ed4be27d6af55f6c9b5bf54b838e78b
Author: Matthias Gehre <M.Gehre@gmx.de>
Date:   Tue Mar 28 01:56:48 2006 -0800

    [PATCH] Replace 0xff.. with correct DMA_xBIT_MASK
    
    Replace all occurences of 0xff..  in calls to function pci_set_dma_mask()
    and pci_set_consistant_dma_mask() with the corresponding DMA_xBIT_MASK from
    linux/dma-mapping.h.
    
    Signed-off-by: Matthias Gehre <M.Gehre@gmx.de>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/drivers/scsi/megaraid.c b/drivers/scsi/megaraid.c
index 7144674bc8e6..80b68a2481b3 100644
--- a/drivers/scsi/megaraid.c
+++ b/drivers/scsi/megaraid.c
@@ -45,6 +45,7 @@
 #include <linux/interrupt.h>
 #include <linux/pci.h>
 #include <linux/init.h>
+#include <linux/dma-mapping.h>
 #include <scsi/scsicam.h>
 
 #include "scsi.h"
@@ -2094,7 +2095,7 @@ make_local_pdev(adapter_t *adapter, struct pci_dev **pdev)
 
 	memcpy(*pdev, adapter->dev, sizeof(struct pci_dev));
 
-	if( pci_set_dma_mask(*pdev, 0xffffffff) != 0 ) {
+	if( pci_set_dma_mask(*pdev, DMA_32BIT_MASK) != 0 ) {
 		kfree(*pdev);
 		return -1;
 	}
@@ -4859,10 +4860,10 @@ megaraid_probe_one(struct pci_dev *pdev, const struct pci_device_id *id)
 
 	/* Set the Mode of addressing to 64 bit if we can */
 	if ((adapter->flag & BOARD_64BIT) && (sizeof(dma_addr_t) == 8)) {
-		pci_set_dma_mask(pdev, 0xffffffffffffffffULL);
+		pci_set_dma_mask(pdev, DMA_64BIT_MASK);
 		adapter->has_64bit_addr = 1;
 	} else  {
-		pci_set_dma_mask(pdev, 0xffffffff);
+		pci_set_dma_mask(pdev, DMA_32BIT_MASK);
 		adapter->has_64bit_addr = 0;
 	}
 		

commit 3542adcb354fea4fca792d36b91cb44d0da147e5
Author: Ju, Seokmann <Seokmann.Ju@lsil.com>
Date:   Thu Feb 9 12:32:59 2006 -0700

    [SCSI] megaraid_legacy: kobject_register failure
    
    Attached patch fixes problem that cause kobject_register failure
    during loading.  Kobject_register would fail when there are more than
    1 module with same module name.  This patch will change module name of
    megaraid_legacy from 'megaraid' to 'megaraid_legacy'.
    
    Signed-Off-by: Seokmann Ju <seokmann.ju@lsil.com>
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>

diff --git a/drivers/scsi/megaraid.c b/drivers/scsi/megaraid.c
index d101a8a6f4e8..7144674bc8e6 100644
--- a/drivers/scsi/megaraid.c
+++ b/drivers/scsi/megaraid.c
@@ -5049,7 +5049,7 @@ static struct pci_device_id megaraid_pci_tbl[] = {
 MODULE_DEVICE_TABLE(pci, megaraid_pci_tbl);
 
 static struct pci_driver megaraid_pci_driver = {
-	.name		= "megaraid",
+	.name		= "megaraid_legacy",
 	.id_table	= megaraid_pci_tbl,
 	.probe		= megaraid_probe_one,
 	.remove		= __devexit_p(megaraid_remove_one),

commit 0b9506723826c68b50fa33e345700ddcac1bed36
Author: Arjan van de Ven <arjan@infradead.org>
Date:   Wed Jan 11 13:16:10 2006 +0100

    [SCSI] turn most scsi semaphores into mutexes
    
    the scsi layer is using semaphores in a mutex way, this patch converts
    these into using mutexes instead
    
    Signed-off-by: Arjan van de Ven <arjan@infradead.org>
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>

diff --git a/drivers/scsi/megaraid.c b/drivers/scsi/megaraid.c
index 4a6feb1e5e3d..d101a8a6f4e8 100644
--- a/drivers/scsi/megaraid.c
+++ b/drivers/scsi/megaraid.c
@@ -4479,7 +4479,7 @@ mega_internal_command(adapter_t *adapter, megacmd_t *mc, mega_passthru *pthru)
 	 * serialized. This is so because we want to reserve maximum number of
 	 * available command ids for the I/O commands.
 	 */
-	down(&adapter->int_mtx);
+	mutex_lock(&adapter->int_mtx);
 
 	scb = &adapter->int_scb;
 	memset(scb, 0, sizeof(scb_t));
@@ -4527,7 +4527,7 @@ mega_internal_command(adapter_t *adapter, megacmd_t *mc, mega_passthru *pthru)
 			mc->cmd, mc->opcode, mc->subopcode, scmd->result);
 	}
 
-	up(&adapter->int_mtx);
+	mutex_unlock(&adapter->int_mtx);
 
 	return rval;
 }
@@ -4866,7 +4866,7 @@ megaraid_probe_one(struct pci_dev *pdev, const struct pci_device_id *id)
 		adapter->has_64bit_addr = 0;
 	}
 		
-	init_MUTEX(&adapter->int_mtx);
+	mutex_init(&adapter->int_mtx);
 	init_completion(&adapter->int_waitq);
 
 	adapter->this_id = DEFAULT_INITIATOR_ID;

commit 2a1e1379bae53f647c463a677cc2ec71b591c348
Merge: 787926b1b2d2 7b6666530e27
Author: James Bottomley <jejb@titanic.(none)>
Date:   Thu Dec 15 17:35:24 2005 -0600

    Merge by hand (conflicts in scsi_lib.c)
    
    This merge is pretty extensive.  The conflict is over the new
    req->retries parameter, so I had to change the prototype to
    scsi_setup_blk_pc_cmnd() and the usage in sd, sr and st.
    
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>

commit 3492b328834319c9503c0a34c50fb3f009556443
Author: Ju, Seokmann <Seokmann.Ju@engenio.com>
Date:   Thu Nov 17 13:13:31 2005 -0500

    [SCSI] megaraid_legacy: removed PCI ID overlap from the driv er
    
    This patch fixes
            - PCI ID overlap issue
            - node name changed to 'megaraid_legacy'
    I hope this patch addresses concerns brought by Daniel Drake.
    
    Signed-off by: Seokmann Ju <seokmann.ju@enginio.com>
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>

diff --git a/drivers/scsi/megaraid.c b/drivers/scsi/megaraid.c
index f9792528e33f..9fa41ccadef2 100644
--- a/drivers/scsi/megaraid.c
+++ b/drivers/scsi/megaraid.c
@@ -2,7 +2,7 @@
  *
  *			Linux MegaRAID device driver
  *
- * Copyright  2002  LSI Logic Corporation.
+ * Copyright (c) 2002  LSI Logic Corporation.
  *
  *	   This program is free software; you can redistribute it and/or
  *	   modify it under the terms of the GNU General Public License
@@ -17,7 +17,8 @@
  * Copyright (c) 2003  Christoph Hellwig  <hch@lst.de>
  *	  - new-style, hotplug-aware pci probing and scsi registration
  *
- * Version : v2.00.3 (Feb 19, 2003) - Atul Mukker <Atul.Mukker@lsil.com>
+ * Version : v2.00.4 Mon Nov 14 14:02:43 EST 2005 - Seokmann Ju
+ * 						<Seokmann.Ju@lsil.com>
  *
  * Description: Linux device driver for LSI Logic MegaRAID controller
  *
@@ -51,10 +52,10 @@
 
 #include "megaraid.h"
 
-#define MEGARAID_MODULE_VERSION "2.00.3"
+#define MEGARAID_MODULE_VERSION "2.00.4"
 
-MODULE_AUTHOR ("LSI Logic Corporation");
-MODULE_DESCRIPTION ("LSI Logic MegaRAID driver");
+MODULE_AUTHOR ("sju@lsil.com");
+MODULE_DESCRIPTION ("LSI Logic MegaRAID legacy driver");
 MODULE_LICENSE ("GPL");
 MODULE_VERSION(MEGARAID_MODULE_VERSION);
 
@@ -4553,7 +4554,7 @@ mega_internal_done(Scsi_Cmnd *scmd)
 static struct scsi_host_template megaraid_template = {
 	.module				= THIS_MODULE,
 	.name				= "MegaRAID",
-	.proc_name			= "megaraid",
+	.proc_name			= "megaraid_legacy",
 	.info				= megaraid_info,
 	.queuecommand			= megaraid_queue,	
 	.bios_param			= megaraid_biosparam,
@@ -5037,22 +5038,12 @@ megaraid_shutdown(struct pci_dev *pdev)
 }
 
 static struct pci_device_id megaraid_pci_tbl[] = {
-	{PCI_VENDOR_ID_DELL, PCI_DEVICE_ID_DISCOVERY,
-		PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},
-	{PCI_VENDOR_ID_DELL, PCI_DEVICE_ID_PERC4_DI,
-		PCI_ANY_ID, PCI_ANY_ID, 0, 0, BOARD_64BIT},
-	{PCI_VENDOR_ID_LSI_LOGIC, PCI_DEVICE_ID_PERC4_QC_VERDE,
-		PCI_ANY_ID, PCI_ANY_ID, 0, 0, BOARD_64BIT},
 	{PCI_VENDOR_ID_AMI, PCI_DEVICE_ID_AMI_MEGARAID,
 		PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},
 	{PCI_VENDOR_ID_AMI, PCI_DEVICE_ID_AMI_MEGARAID2,
 		PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},
-	{PCI_VENDOR_ID_AMI, PCI_DEVICE_ID_AMI_MEGARAID3,
-		PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},
 	{PCI_VENDOR_ID_INTEL, PCI_DEVICE_ID_AMI_MEGARAID3,
 		PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},
-	{PCI_VENDOR_ID_LSI_LOGIC, PCI_DEVICE_ID_AMI_MEGARAID3,
-		PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},
 	{0,}
 };
 MODULE_DEVICE_TABLE(pci, megaraid_pci_tbl);
@@ -5095,7 +5086,7 @@ static int __init megaraid_init(void)
 	 * First argument (major) to register_chrdev implies a dynamic
 	 * major number allocation.
 	 */
-	major = register_chrdev(0, "megadev", &megadev_fops);
+	major = register_chrdev(0, "megadev_legacy", &megadev_fops);
 	if (!major) {
 		printk(KERN_WARNING
 				"megaraid: failed to register char device\n");
@@ -5109,7 +5100,7 @@ static void __exit megaraid_exit(void)
 	/*
 	 * Unregister the character device interface to the driver.
 	 */
-	unregister_chrdev(major, "megadev");
+	unregister_chrdev(major, "megadev_legacy");
 
 	pci_unregister_driver(&megaraid_pci_driver);
 

commit f0353301e6752399ceb874ede7f44e3571c5e4f3
Author: Mark Lord <lkml@rtr.ca>
Date:   Wed Dec 7 17:46:57 2005 -0500

    [SCSI] Fix incorrect pointer in megaraid.c MODE_SENSE emulation
    
    The SCSI megaraid drive goes to great effort to kmap
    the scatterlist buffer (if used), but then uses the
    wrong pointer when copying to it afterward.
    
    Signed-off-by:  Mark Lord <lkml@rtr.ca>
    Acked by: Ju, Seokmann <Seokmann.Ju@engenio.com>
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>

diff --git a/drivers/scsi/megaraid.c b/drivers/scsi/megaraid.c
index f9792528e33f..578143e93a6f 100644
--- a/drivers/scsi/megaraid.c
+++ b/drivers/scsi/megaraid.c
@@ -664,7 +664,7 @@ mega_build_cmd(adapter_t *adapter, Scsi_Cmnd *cmd, int *busy)
 					sg->offset;
 			} else
 				buf = cmd->request_buffer;
-			memset(cmd->request_buffer, 0, cmd->cmnd[4]);
+			memset(buf, 0, cmd->cmnd[4]);
 			if (cmd->use_sg) {
 				struct scatterlist *sg;
 

commit 238f9b063dcc9f23493a0d3fecca29fe332d4905
Author: Christoph Hellwig <hch@lst.de>
Date:   Tue Nov 29 21:36:16 2005 +0100

    [PATCH] fix megaraid.c locking
    
    This fixes locking in megaraid.c, namely:
    
     (1) make sure megaraid_queue release the adapter lock by changing the
         code to have a single return
     (2) remove the errornous scsi_assign_lock call
    
    Testing by Burton Windle.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Acked-by: Burton Windle <bwindle@fint.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/drivers/scsi/megaraid.c b/drivers/scsi/megaraid.c
index dfea346b00a5..f9792528e33f 100644
--- a/drivers/scsi/megaraid.c
+++ b/drivers/scsi/megaraid.c
@@ -380,23 +380,23 @@ megaraid_queue(Scsi_Cmnd *scmd, void (*done)(Scsi_Cmnd *))
 
 	spin_lock_irqsave(&adapter->lock, flags);
 	scb = mega_build_cmd(adapter, scmd, &busy);
+	if (!scb)
+		goto out;
 
-	if(scb) {
-		scb->state |= SCB_PENDQ;
-		list_add_tail(&scb->list, &adapter->pending_list);
+	scb->state |= SCB_PENDQ;
+	list_add_tail(&scb->list, &adapter->pending_list);
 
-		/*
-		 * Check if the HBA is in quiescent state, e.g., during a
-		 * delete logical drive opertion. If it is, don't run
-		 * the pending_list.
-		 */
-		if(atomic_read(&adapter->quiescent) == 0) {
-			mega_runpendq(adapter);
-		}
-		return 0;
-	}
-	spin_unlock_irqrestore(&adapter->lock, flags);
+	/*
+	 * Check if the HBA is in quiescent state, e.g., during a
+	 * delete logical drive opertion. If it is, don't run
+	 * the pending_list.
+	 */
+	if (atomic_read(&adapter->quiescent) == 0)
+		mega_runpendq(adapter);
 
+	busy = 0;
+ out:
+	spin_unlock_irqrestore(&adapter->lock, flags);
 	return busy;
 }
 
@@ -4677,7 +4677,6 @@ megaraid_probe_one(struct pci_dev *pdev, const struct pci_device_id *id)
 
 	adapter->flag = flag;
 	spin_lock_init(&adapter->lock);
-	scsi_assign_lock(host, &adapter->lock);
 
 	host->cmd_per_lun = max_cmd_per_lun;
 	host->max_sectors = max_sectors_per_io;

commit 0a04137e75204e370dbdf2376033853eea126de7
Author: Christoph Hellwig <hch@lst.de>
Date:   Mon Oct 31 18:31:56 2005 +0100

    [SCSI] remove Scsi_Pointer typedef
    
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>

diff --git a/drivers/scsi/megaraid.c b/drivers/scsi/megaraid.c
index 93c95bc82c1f..dfea346b00a5 100644
--- a/drivers/scsi/megaraid.c
+++ b/drivers/scsi/megaraid.c
@@ -1686,7 +1686,7 @@ mega_rundoneq (adapter_t *adapter)
 
 	list_for_each(pos, &adapter->completed_list) {
 
-		Scsi_Pointer* spos = (Scsi_Pointer *)pos;
+		struct scsi_pointer* spos = (struct scsi_pointer *)pos;
 
 		cmd = list_entry(spos, Scsi_Cmnd, SCp);
 		cmd->scsi_done(cmd);

commit cb0258a2fb8e434b3b56856603754d998008d9ee
Author: Christoph Hellwig <hch@lst.de>
Date:   Mon Oct 31 20:12:07 2005 +0100

    [SCSI] megaraid (legacy): remove scsi_assign_lock usage
    
    just take the adapter lock in megaraid_queue.  Additional benefit is
    that we can get rid of the awkward conditional locking in
    mega_internal_command.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>

diff --git a/drivers/scsi/megaraid.c b/drivers/scsi/megaraid.c
index 61a6fd810bb4..93c95bc82c1f 100644
--- a/drivers/scsi/megaraid.c
+++ b/drivers/scsi/megaraid.c
@@ -362,6 +362,7 @@ megaraid_queue(Scsi_Cmnd *scmd, void (*done)(Scsi_Cmnd *))
 	adapter_t	*adapter;
 	scb_t	*scb;
 	int	busy=0;
+	unsigned long flags;
 
 	adapter = (adapter_t *)scmd->device->host->hostdata;
 
@@ -377,6 +378,7 @@ megaraid_queue(Scsi_Cmnd *scmd, void (*done)(Scsi_Cmnd *))
 	 * return 0 in that case.
 	 */
 
+	spin_lock_irqsave(&adapter->lock, flags);
 	scb = mega_build_cmd(adapter, scmd, &busy);
 
 	if(scb) {
@@ -393,6 +395,7 @@ megaraid_queue(Scsi_Cmnd *scmd, void (*done)(Scsi_Cmnd *))
 		}
 		return 0;
 	}
+	spin_unlock_irqrestore(&adapter->lock, flags);
 
 	return busy;
 }
@@ -1981,7 +1984,7 @@ megaraid_reset(struct scsi_cmnd *cmd)
 	mc.cmd = MEGA_CLUSTER_CMD;
 	mc.opcode = MEGA_RESET_RESERVATIONS;
 
-	if( mega_internal_command(adapter, LOCK_INT, &mc, NULL) != 0 ) {
+	if( mega_internal_command(adapter, &mc, NULL) != 0 ) {
 		printk(KERN_WARNING
 				"megaraid: reservation reset failed.\n");
 	}
@@ -3011,7 +3014,7 @@ proc_rdrv(adapter_t *adapter, char *page, int start, int end )
 		mc.cmd = FC_NEW_CONFIG;
 		mc.opcode = OP_DCMD_READ_CONFIG;
 
-		if( mega_internal_command(adapter, LOCK_INT, &mc, NULL) ) {
+		if( mega_internal_command(adapter, &mc, NULL) ) {
 
 			len = sprintf(page, "40LD read config failed.\n");
 
@@ -3029,11 +3032,11 @@ proc_rdrv(adapter_t *adapter, char *page, int start, int end )
 	else {
 		mc.cmd = NEW_READ_CONFIG_8LD;
 
-		if( mega_internal_command(adapter, LOCK_INT, &mc, NULL) ) {
+		if( mega_internal_command(adapter, &mc, NULL) ) {
 
 			mc.cmd = READ_CONFIG_8LD;
 
-			if( mega_internal_command(adapter, LOCK_INT, &mc,
+			if( mega_internal_command(adapter, &mc,
 						NULL) ){
 
 				len = sprintf(page,
@@ -3632,7 +3635,7 @@ megadev_ioctl(struct inode *inode, struct file *filep, unsigned int cmd,
 			/*
 			 * Issue the command
 			 */
-			mega_internal_command(adapter, LOCK_INT, &mc, pthru);
+			mega_internal_command(adapter, &mc, pthru);
 
 			rval = mega_n_to_m((void __user *)arg, &mc);
 
@@ -3715,7 +3718,7 @@ megadev_ioctl(struct inode *inode, struct file *filep, unsigned int cmd,
 			/*
 			 * Issue the command
 			 */
-			mega_internal_command(adapter, LOCK_INT, &mc, NULL);
+			mega_internal_command(adapter, &mc, NULL);
 
 			rval = mega_n_to_m((void __user *)arg, &mc);
 
@@ -4234,7 +4237,7 @@ mega_do_del_logdrv(adapter_t *adapter, int logdrv)
 	mc.opcode = OP_DEL_LOGDRV;
 	mc.subopcode = logdrv;
 
-	rval = mega_internal_command(adapter, LOCK_INT, &mc, NULL);
+	rval = mega_internal_command(adapter, &mc, NULL);
 
 	/* log this event */
 	if(rval) {
@@ -4367,7 +4370,7 @@ mega_adapinq(adapter_t *adapter, dma_addr_t dma_handle)
 
 	mc.xferaddr = (u32)dma_handle;
 
-	if ( mega_internal_command(adapter, LOCK_INT, &mc, NULL) != 0 ) {
+	if ( mega_internal_command(adapter, &mc, NULL) != 0 ) {
 		return -1;
 	}
 
@@ -4435,7 +4438,7 @@ mega_internal_dev_inquiry(adapter_t *adapter, u8 ch, u8 tgt,
 	mc.cmd = MEGA_MBOXCMD_PASSTHRU;
 	mc.xferaddr = (u32)pthru_dma_handle;
 
-	rval = mega_internal_command(adapter, LOCK_INT, &mc, pthru);
+	rval = mega_internal_command(adapter, &mc, pthru);
 
 	pci_free_consistent(pdev, sizeof(mega_passthru), pthru,
 			pthru_dma_handle);
@@ -4449,7 +4452,6 @@ mega_internal_dev_inquiry(adapter_t *adapter, u8 ch, u8 tgt,
 /**
  * mega_internal_command()
  * @adapter - pointer to our soft state
- * @ls - the scope of the exclusion lock.
  * @mc - the mailbox command
  * @pthru - Passthru structure for DCDB commands
  *
@@ -4463,8 +4465,7 @@ mega_internal_dev_inquiry(adapter_t *adapter, u8 ch, u8 tgt,
  * Note: parameter 'pthru' is null for non-passthru commands.
  */
 static int
-mega_internal_command(adapter_t *adapter, lockscope_t ls, megacmd_t *mc,
-		mega_passthru *pthru )
+mega_internal_command(adapter_t *adapter, megacmd_t *mc, mega_passthru *pthru)
 {
 	Scsi_Cmnd	*scmd;
 	struct	scsi_device *sdev;
@@ -4508,15 +4509,8 @@ mega_internal_command(adapter_t *adapter, lockscope_t ls, megacmd_t *mc,
 
 	scb->idx = CMDID_INT_CMDS;
 
-	/*
-	 * Get the lock only if the caller has not acquired it already
-	 */
-	if( ls == LOCK_INT ) spin_lock_irqsave(&adapter->lock, flags);
-
 	megaraid_queue(scmd, mega_internal_done);
 
-	if( ls == LOCK_INT ) spin_unlock_irqrestore(&adapter->lock, flags);
-
 	wait_for_completion(&adapter->int_waitq);
 
 	rval = scmd->result;

commit 51c928c34fa7cff38df584ad01de988805877dba
Author: James Bottomley <James.Bottomley@SteelEye.com>
Date:   Sat Oct 1 09:38:05 2005 -0500

    [SCSI] Legacy MegaRAID: Fix READ CAPACITY
    
    Some Legacy megaraid cards can't actually cope with the scatter/gather
    version of the READ CAPACITY command (which is what we now send them
    since altering all SCSI internal I/O to go via the block layer).  Fix
    this (and a few other broken megaraid driver assumptions) by sending
    the non-sg version of the command if the sg list only has a single
    element.
    
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>

diff --git a/drivers/scsi/megaraid.c b/drivers/scsi/megaraid.c
index 6f308ebe3e79..61a6fd810bb4 100644
--- a/drivers/scsi/megaraid.c
+++ b/drivers/scsi/megaraid.c
@@ -621,8 +621,6 @@ mega_build_cmd(adapter_t *adapter, Scsi_Cmnd *cmd, int *busy)
 	if(islogical) {
 		switch (cmd->cmnd[0]) {
 		case TEST_UNIT_READY:
-			memset(cmd->request_buffer, 0, cmd->request_bufflen);
-
 #if MEGA_HAVE_CLUSTERING
 			/*
 			 * Do we support clustering and is the support enabled
@@ -652,11 +650,28 @@ mega_build_cmd(adapter_t *adapter, Scsi_Cmnd *cmd, int *busy)
 			return NULL;
 #endif
 
-		case MODE_SENSE:
+		case MODE_SENSE: {
+			char *buf;
+
+			if (cmd->use_sg) {
+				struct scatterlist *sg;
+
+				sg = (struct scatterlist *)cmd->request_buffer;
+				buf = kmap_atomic(sg->page, KM_IRQ0) +
+					sg->offset;
+			} else
+				buf = cmd->request_buffer;
 			memset(cmd->request_buffer, 0, cmd->cmnd[4]);
+			if (cmd->use_sg) {
+				struct scatterlist *sg;
+
+				sg = (struct scatterlist *)cmd->request_buffer;
+				kunmap_atomic(buf - sg->offset, KM_IRQ0);
+			}
 			cmd->result = (DID_OK << 16);
 			cmd->scsi_done(cmd);
 			return NULL;
+		}
 
 		case READ_CAPACITY:
 		case INQUIRY:
@@ -1685,14 +1700,23 @@ mega_rundoneq (adapter_t *adapter)
 static void
 mega_free_scb(adapter_t *adapter, scb_t *scb)
 {
+	unsigned long length;
+
 	switch( scb->dma_type ) {
 
 	case MEGA_DMA_TYPE_NONE:
 		break;
 
 	case MEGA_BULK_DATA:
+		if (scb->cmd->use_sg == 0)
+			length = scb->cmd->request_bufflen;
+		else {
+			struct scatterlist *sgl =
+				(struct scatterlist *)scb->cmd->request_buffer;
+			length = sgl->length;
+		}
 		pci_unmap_page(adapter->dev, scb->dma_h_bulkdata,
-			scb->cmd->request_bufflen, scb->dma_direction);
+			       length, scb->dma_direction);
 		break;
 
 	case MEGA_SGLIST:
@@ -1741,6 +1765,7 @@ mega_build_sglist(adapter_t *adapter, scb_t *scb, u32 *buf, u32 *len)
 	struct scatterlist	*sgl;
 	struct page	*page;
 	unsigned long	offset;
+	unsigned int	length;
 	Scsi_Cmnd	*cmd;
 	int	sgcnt;
 	int	idx;
@@ -1748,14 +1773,23 @@ mega_build_sglist(adapter_t *adapter, scb_t *scb, u32 *buf, u32 *len)
 	cmd = scb->cmd;
 
 	/* Scatter-gather not used */
-	if( !cmd->use_sg ) {
-
-		page = virt_to_page(cmd->request_buffer);
-		offset = offset_in_page(cmd->request_buffer);
+	if( cmd->use_sg == 0 || (cmd->use_sg == 1 && 
+				 !adapter->has_64bit_addr)) {
+
+		if (cmd->use_sg == 0) {
+			page = virt_to_page(cmd->request_buffer);
+			offset = offset_in_page(cmd->request_buffer);
+			length = cmd->request_bufflen;
+		} else {
+			sgl = (struct scatterlist *)cmd->request_buffer;
+			page = sgl->page;
+			offset = sgl->offset;
+			length = sgl->length;
+		}
 
 		scb->dma_h_bulkdata = pci_map_page(adapter->dev,
 						  page, offset,
-						  cmd->request_bufflen,
+						  length,
 						  scb->dma_direction);
 		scb->dma_type = MEGA_BULK_DATA;
 
@@ -1765,14 +1799,14 @@ mega_build_sglist(adapter_t *adapter, scb_t *scb, u32 *buf, u32 *len)
 		 */
 		if( adapter->has_64bit_addr ) {
 			scb->sgl64[0].address = scb->dma_h_bulkdata;
-			scb->sgl64[0].length = cmd->request_bufflen;
+			scb->sgl64[0].length = length;
 			*buf = (u32)scb->sgl_dma_addr;
-			*len = (u32)cmd->request_bufflen;
+			*len = (u32)length;
 			return 1;
 		}
 		else {
 			*buf = (u32)scb->dma_h_bulkdata;
-			*len = (u32)cmd->request_bufflen;
+			*len = (u32)length;
 		}
 		return 0;
 	}
@@ -1791,27 +1825,23 @@ mega_build_sglist(adapter_t *adapter, scb_t *scb, u32 *buf, u32 *len)
 
 	if( sgcnt > adapter->sglen ) BUG();
 
+	*len = 0;
+
 	for( idx = 0; idx < sgcnt; idx++, sgl++ ) {
 
 		if( adapter->has_64bit_addr ) {
 			scb->sgl64[idx].address = sg_dma_address(sgl);
-			scb->sgl64[idx].length = sg_dma_len(sgl);
+			*len += scb->sgl64[idx].length = sg_dma_len(sgl);
 		}
 		else {
 			scb->sgl[idx].address = sg_dma_address(sgl);
-			scb->sgl[idx].length = sg_dma_len(sgl);
+			*len += scb->sgl[idx].length = sg_dma_len(sgl);
 		}
 	}
 
 	/* Reset pointer and length fields */
 	*buf = scb->sgl_dma_addr;
 
-	/*
-	 * For passthru command, dataxferlen must be set, even for commands
-	 * with a sg list
-	 */
-	*len = (u32)cmd->request_bufflen;
-
 	/* Return count of SG requests */
 	return sgcnt;
 }

commit 2d986010ad13a00b83851238d52601d6092df40e
Merge: 6b6a93c6876e e10fb91c4dc8
Author: Linus Torvalds <torvalds@g5.osdl.org>
Date:   Tue Jul 26 13:28:47 2005 -0700

    Merge master.kernel.org:/pub/scm/linux/kernel/git/jejb/scsi-for-linus-2.6

commit d18c3db58bc544fce6662ca7edba616ca9788a70
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Thu Jun 23 17:35:56 2005 -0700

    [PATCH] PCI: make drivers use the pci shutdown callback instead of the driver core callback.
    
    Now we can change the pci core to always set this pointer, as pci drivers
    should use it, not the driver core callback.
    
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/scsi/megaraid.c b/drivers/scsi/megaraid.c
index ec81532eb845..a70cdf31311c 100644
--- a/drivers/scsi/megaraid.c
+++ b/drivers/scsi/megaraid.c
@@ -5036,9 +5036,9 @@ megaraid_remove_one(struct pci_dev *pdev)
 }
 
 static void
-megaraid_shutdown(struct device *dev)
+megaraid_shutdown(struct pci_dev *pdev)
 {
-	struct Scsi_Host *host = pci_get_drvdata(to_pci_dev(dev));
+	struct Scsi_Host *host = pci_get_drvdata(pdev);
 	adapter_t *adapter = (adapter_t *)host->hostdata;
 
 	__megaraid_shutdown(adapter);
@@ -5070,9 +5070,7 @@ static struct pci_driver megaraid_pci_driver = {
 	.id_table	= megaraid_pci_tbl,
 	.probe		= megaraid_probe_one,
 	.remove		= __devexit_p(megaraid_remove_one),
-	.driver		= {
-		.shutdown = megaraid_shutdown,
-	},
+	.shutdown	= megaraid_shutdown,
 };
 
 static int __init megaraid_init(void)

commit 8d115f845a0bd59cd263e791f739964f42b7b0e8
Author: Christoph Hellwig <hch@lst.de>
Date:   Sun Jun 19 13:42:05 2005 +0200

    [SCSI] remove scsi_cmnd->state
    
    We never look at it except for the old megaraid driver that abuses it
    for sending internal commands.  That usage can be fixed easily because
    those internal commands are single-threaded by a mutex and we can easily
    use a completion there.
    
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>

diff --git a/drivers/scsi/megaraid.c b/drivers/scsi/megaraid.c
index 6ee88c59953e..6fe884a2d00d 100644
--- a/drivers/scsi/megaraid.c
+++ b/drivers/scsi/megaraid.c
@@ -35,6 +35,7 @@
 #include <linux/blkdev.h>
 #include <asm/uaccess.h>
 #include <asm/io.h>
+#include <linux/completion.h>
 #include <linux/delay.h>
 #include <linux/proc_fs.h>
 #include <linux/reboot.h>
@@ -4477,8 +4478,6 @@ mega_internal_command(adapter_t *adapter, lockscope_t ls, megacmd_t *mc,
 
 	scb->idx = CMDID_INT_CMDS;
 
-	scmd->state = 0;
-
 	/*
 	 * Get the lock only if the caller has not acquired it already
 	 */
@@ -4488,15 +4487,7 @@ mega_internal_command(adapter_t *adapter, lockscope_t ls, megacmd_t *mc,
 
 	if( ls == LOCK_INT ) spin_unlock_irqrestore(&adapter->lock, flags);
 
-	/*
-	 * Wait till this command finishes. Do not use
-	 * wait_event_interruptible(). It causes panic if CTRL-C is hit when
-	 * dumping e.g., physical disk information through /proc interface.
-	 */
-#if 0
-	wait_event_interruptible(adapter->int_waitq, scmd->state);
-#endif
-	wait_event(adapter->int_waitq, scmd->state);
+	wait_for_completion(&adapter->int_waitq);
 
 	rval = scmd->result;
 	mc->status = scmd->result;
@@ -4530,16 +4521,7 @@ mega_internal_done(Scsi_Cmnd *scmd)
 
 	adapter = (adapter_t *)scmd->device->host->hostdata;
 
-	scmd->state = 1; /* thread waiting for its command to complete */
-
-	/*
-	 * See comment in mega_internal_command() routine for
-	 * wait_event_interruptible()
-	 */
-#if 0
-	wake_up_interruptible(&adapter->int_waitq);
-#endif
-	wake_up(&adapter->int_waitq);
+	complete(&adapter->int_waitq);
 
 }
 
@@ -4861,7 +4843,7 @@ megaraid_probe_one(struct pci_dev *pdev, const struct pci_device_id *id)
 	}
 		
 	init_MUTEX(&adapter->int_mtx);
-	init_waitqueue_head(&adapter->int_waitq);
+	init_completion(&adapter->int_waitq);
 
 	adapter->this_id = DEFAULT_INITIATOR_ID;
 	adapter->host->this_id = DEFAULT_INITIATOR_ID;

commit fa4c49669f0408557bc52cd7054c920a8790dec6
Author: James Bottomley <jejb@titanic.(none)>
Date:   Sun Jun 26 08:45:39 2005 -0500

    [SCSI]  megaraid: fix compilation after eh locking changes
    
    From: Christoph Hellwig <hch@lst.de>
    
    Patch fixed up and
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>

diff --git a/drivers/scsi/megaraid.c b/drivers/scsi/megaraid.c
index ec81532eb845..6ee88c59953e 100644
--- a/drivers/scsi/megaraid.c
+++ b/drivers/scsi/megaraid.c
@@ -1938,7 +1938,7 @@ megaraid_abort(Scsi_Cmnd *cmd)
 
 
 static int
-__megaraid_reset(Scsi_Cmnd *cmd)
+megaraid_reset(struct scsi_cmnd *cmd)
 {
 	adapter_t	*adapter;
 	megacmd_t	mc;
@@ -1950,7 +1950,6 @@ __megaraid_reset(Scsi_Cmnd *cmd)
 	mc.cmd = MEGA_CLUSTER_CMD;
 	mc.opcode = MEGA_RESET_RESERVATIONS;
 
-	spin_unlock_irq(&adapter->lock);
 	if( mega_internal_command(adapter, LOCK_INT, &mc, NULL) != 0 ) {
 		printk(KERN_WARNING
 				"megaraid: reservation reset failed.\n");
@@ -1958,9 +1957,10 @@ __megaraid_reset(Scsi_Cmnd *cmd)
 	else {
 		printk(KERN_INFO "megaraid: reservation reset.\n");
 	}
-	spin_lock_irq(&adapter->lock);
 #endif
 
+	spin_lock_irq(&adapter->lock);
+
 	rval =  megaraid_abort_and_reset(adapter, cmd, SCB_RESET);
 
 	/*
@@ -1968,24 +1968,11 @@ __megaraid_reset(Scsi_Cmnd *cmd)
 	 * to be communicated over to the mid layer.
 	 */
 	mega_rundoneq(adapter);
-
-	return rval;
-}
-
-static int
-megaraid_reset(Scsi_Cmnd *cmd)
-{
-	adapter_t *adapter = (adapter_t *)cmd->device->host->hostdata;
-	int rc;
-
-	spin_lock_irq(&adapter->lock);
-	rc = __megaraid_reset(cmd);
 	spin_unlock_irq(&adapter->lock);
 
-	return rc;
+	return rval;
 }
 
-
 /**
  * megaraid_abort_and_reset()
  * @adapter - megaraid soft state

commit 7f20b6a4792c1b5033583c23b5594887dd3867b9
Author: bobl <bobl@turbolinux.com>
Date:   Tue Jun 21 17:14:29 2005 -0700

    [PATCH] megaraid build fix
    
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/drivers/scsi/megaraid.c b/drivers/scsi/megaraid.c
index 80b0c40c522b..ec81532eb845 100644
--- a/drivers/scsi/megaraid.c
+++ b/drivers/scsi/megaraid.c
@@ -1975,7 +1975,7 @@ __megaraid_reset(Scsi_Cmnd *cmd)
 static int
 megaraid_reset(Scsi_Cmnd *cmd)
 {
-	adapter = (adapter_t *)cmd->device->host->hostdata;
+	adapter_t *adapter = (adapter_t *)cmd->device->host->hostdata;
 	int rc;
 
 	spin_lock_irq(&adapter->lock);

commit 94d0e7b805961c44e4dc486ffc21075084bb7175
Author: Jeff Garzik <jgarzik@pobox.com>
Date:   Sat May 28 07:55:48 2005 -0400

    [SCSI] allow sleeping in ->eh_device_reset_handler()
    
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>

diff --git a/drivers/scsi/megaraid.c b/drivers/scsi/megaraid.c
index 8d707b29027d..80b0c40c522b 100644
--- a/drivers/scsi/megaraid.c
+++ b/drivers/scsi/megaraid.c
@@ -1938,7 +1938,7 @@ megaraid_abort(Scsi_Cmnd *cmd)
 
 
 static int
-megaraid_reset(Scsi_Cmnd *cmd)
+__megaraid_reset(Scsi_Cmnd *cmd)
 {
 	adapter_t	*adapter;
 	megacmd_t	mc;
@@ -1972,6 +1972,18 @@ megaraid_reset(Scsi_Cmnd *cmd)
 	return rval;
 }
 
+static int
+megaraid_reset(Scsi_Cmnd *cmd)
+{
+	adapter = (adapter_t *)cmd->device->host->hostdata;
+	int rc;
+
+	spin_lock_irq(&adapter->lock);
+	rc = __megaraid_reset(cmd);
+	spin_unlock_irq(&adapter->lock);
+
+	return rc;
+}
 
 
 /**

commit 1da177e4c3f41524e886b7f1b8a0c1fc7321cac2
Author: Linus Torvalds <torvalds@ppc970.osdl.org>
Date:   Sat Apr 16 15:20:36 2005 -0700

    Linux-2.6.12-rc2
    
    Initial git repository build. I'm not bothering with the full history,
    even though we have it. We can create a separate "historical" git
    archive of that later if we want to, and in the meantime it's about
    3.2GB when imported into git - space that would just make the early
    git days unnecessarily complicated, when we don't have a lot of good
    infrastructure for it.
    
    Let it rip!

diff --git a/drivers/scsi/megaraid.c b/drivers/scsi/megaraid.c
new file mode 100644
index 000000000000..8d707b29027d
--- /dev/null
+++ b/drivers/scsi/megaraid.c
@@ -0,0 +1,5122 @@
+/*
+ *
+ *			Linux MegaRAID device driver
+ *
+ * Copyright  2002  LSI Logic Corporation.
+ *
+ *	   This program is free software; you can redistribute it and/or
+ *	   modify it under the terms of the GNU General Public License
+ *	   as published by the Free Software Foundation; either version
+ *	   2 of the License, or (at your option) any later version.
+ *
+ * Copyright (c) 2002  Red Hat, Inc. All rights reserved.
+ *	  - fixes
+ *	  - speed-ups (list handling fixes, issued_list, optimizations.)
+ *	  - lots of cleanups.
+ *
+ * Copyright (c) 2003  Christoph Hellwig  <hch@lst.de>
+ *	  - new-style, hotplug-aware pci probing and scsi registration
+ *
+ * Version : v2.00.3 (Feb 19, 2003) - Atul Mukker <Atul.Mukker@lsil.com>
+ *
+ * Description: Linux device driver for LSI Logic MegaRAID controller
+ *
+ * Supported controllers: MegaRAID 418, 428, 438, 466, 762, 467, 471, 490, 493
+ *					518, 520, 531, 532
+ *
+ * This driver is supported by LSI Logic, with assistance from Red Hat, Dell,
+ * and others. Please send updates to the mailing list
+ * linux-scsi@vger.kernel.org .
+ *
+ */
+
+#include <linux/mm.h>
+#include <linux/fs.h>
+#include <linux/blkdev.h>
+#include <asm/uaccess.h>
+#include <asm/io.h>
+#include <linux/delay.h>
+#include <linux/proc_fs.h>
+#include <linux/reboot.h>
+#include <linux/module.h>
+#include <linux/list.h>
+#include <linux/interrupt.h>
+#include <linux/pci.h>
+#include <linux/init.h>
+#include <scsi/scsicam.h>
+
+#include "scsi.h"
+#include <scsi/scsi_host.h>
+
+#include "megaraid.h"
+
+#define MEGARAID_MODULE_VERSION "2.00.3"
+
+MODULE_AUTHOR ("LSI Logic Corporation");
+MODULE_DESCRIPTION ("LSI Logic MegaRAID driver");
+MODULE_LICENSE ("GPL");
+MODULE_VERSION(MEGARAID_MODULE_VERSION);
+
+static unsigned int max_cmd_per_lun = DEF_CMD_PER_LUN;
+module_param(max_cmd_per_lun, uint, 0);
+MODULE_PARM_DESC(max_cmd_per_lun, "Maximum number of commands which can be issued to a single LUN (default=DEF_CMD_PER_LUN=63)");
+
+static unsigned short int max_sectors_per_io = MAX_SECTORS_PER_IO;
+module_param(max_sectors_per_io, ushort, 0);
+MODULE_PARM_DESC(max_sectors_per_io, "Maximum number of sectors per I/O request (default=MAX_SECTORS_PER_IO=128)");
+
+
+static unsigned short int max_mbox_busy_wait = MBOX_BUSY_WAIT;
+module_param(max_mbox_busy_wait, ushort, 0);
+MODULE_PARM_DESC(max_mbox_busy_wait, "Maximum wait for mailbox in microseconds if busy (default=MBOX_BUSY_WAIT=10)");
+
+#define RDINDOOR(adapter)		readl((adapter)->base + 0x20)
+#define RDOUTDOOR(adapter)		readl((adapter)->base + 0x2C)
+#define WRINDOOR(adapter,value)		writel(value, (adapter)->base + 0x20)
+#define WROUTDOOR(adapter,value)	writel(value, (adapter)->base + 0x2C)
+
+/*
+ * Global variables
+ */
+
+static int hba_count;
+static adapter_t *hba_soft_state[MAX_CONTROLLERS];
+static struct proc_dir_entry *mega_proc_dir_entry;
+
+/* For controller re-ordering */
+static struct mega_hbas mega_hbas[MAX_CONTROLLERS];
+
+/*
+ * The File Operations structure for the serial/ioctl interface of the driver
+ */
+static struct file_operations megadev_fops = {
+	.owner		= THIS_MODULE,
+	.ioctl		= megadev_ioctl,
+	.open		= megadev_open,
+};
+
+/*
+ * Array to structures for storing the information about the controllers. This
+ * information is sent to the user level applications, when they do an ioctl
+ * for this information.
+ */
+static struct mcontroller mcontroller[MAX_CONTROLLERS];
+
+/* The current driver version */
+static u32 driver_ver = 0x02000000;
+
+/* major number used by the device for character interface */
+static int major;
+
+#define IS_RAID_CH(hba, ch)	(((hba)->mega_ch_class >> (ch)) & 0x01)
+
+
+/*
+ * Debug variable to print some diagnostic messages
+ */
+static int trace_level;
+
+/**
+ * mega_setup_mailbox()
+ * @adapter - pointer to our soft state
+ *
+ * Allocates a 8 byte aligned memory for the handshake mailbox.
+ */
+static int
+mega_setup_mailbox(adapter_t *adapter)
+{
+	unsigned long	align;
+
+	adapter->una_mbox64 = pci_alloc_consistent(adapter->dev,
+			sizeof(mbox64_t), &adapter->una_mbox64_dma);
+
+	if( !adapter->una_mbox64 ) return -1;
+		
+	adapter->mbox = &adapter->una_mbox64->mbox;
+
+	adapter->mbox = (mbox_t *)((((unsigned long) adapter->mbox) + 15) &
+			(~0UL ^ 0xFUL));
+
+	adapter->mbox64 = (mbox64_t *)(((unsigned long)adapter->mbox) - 8);
+
+	align = ((void *)adapter->mbox) - ((void *)&adapter->una_mbox64->mbox);
+
+	adapter->mbox_dma = adapter->una_mbox64_dma + 8 + align;
+
+	/*
+	 * Register the mailbox if the controller is an io-mapped controller
+	 */
+	if( adapter->flag & BOARD_IOMAP ) {
+
+		outb_p(adapter->mbox_dma & 0xFF,
+				adapter->host->io_port + MBOX_PORT0);
+
+		outb_p((adapter->mbox_dma >> 8) & 0xFF,
+				adapter->host->io_port + MBOX_PORT1);
+
+		outb_p((adapter->mbox_dma >> 16) & 0xFF,
+				adapter->host->io_port + MBOX_PORT2);
+
+		outb_p((adapter->mbox_dma >> 24) & 0xFF,
+				adapter->host->io_port + MBOX_PORT3);
+
+		outb_p(ENABLE_MBOX_BYTE,
+				adapter->host->io_port + ENABLE_MBOX_REGION);
+
+		irq_ack(adapter);
+
+		irq_enable(adapter);
+	}
+
+	return 0;
+}
+
+
+/*
+ * mega_query_adapter()
+ * @adapter - pointer to our soft state
+ *
+ * Issue the adapter inquiry commands to the controller and find out
+ * information and parameter about the devices attached
+ */
+static int
+mega_query_adapter(adapter_t *adapter)
+{
+	dma_addr_t	prod_info_dma_handle;
+	mega_inquiry3	*inquiry3;
+	u8	raw_mbox[sizeof(struct mbox_out)];
+	mbox_t	*mbox;
+	int	retval;
+
+	/* Initialize adapter inquiry mailbox */
+
+	mbox = (mbox_t *)raw_mbox;
+
+	memset((void *)adapter->mega_buffer, 0, MEGA_BUFFER_SIZE);
+	memset(&mbox->m_out, 0, sizeof(raw_mbox));
+
+	/*
+	 * Try to issue Inquiry3 command
+	 * if not succeeded, then issue MEGA_MBOXCMD_ADAPTERINQ command and
+	 * update enquiry3 structure
+	 */
+	mbox->m_out.xferaddr = (u32)adapter->buf_dma_handle;
+
+	inquiry3 = (mega_inquiry3 *)adapter->mega_buffer;
+
+	raw_mbox[0] = FC_NEW_CONFIG;		/* i.e. mbox->cmd=0xA1 */
+	raw_mbox[2] = NC_SUBOP_ENQUIRY3;	/* i.e. 0x0F */
+	raw_mbox[3] = ENQ3_GET_SOLICITED_FULL;	/* i.e. 0x02 */
+
+	/* Issue a blocking command to the card */
+	if ((retval = issue_scb_block(adapter, raw_mbox))) {
+		/* the adapter does not support 40ld */
+
+		mraid_ext_inquiry	*ext_inq;
+		mraid_inquiry		*inq;
+		dma_addr_t		dma_handle;
+
+		ext_inq = pci_alloc_consistent(adapter->dev,
+				sizeof(mraid_ext_inquiry), &dma_handle);
+
+		if( ext_inq == NULL ) return -1;
+
+		inq = &ext_inq->raid_inq;
+
+		mbox->m_out.xferaddr = (u32)dma_handle;
+
+		/*issue old 0x04 command to adapter */
+		mbox->m_out.cmd = MEGA_MBOXCMD_ADPEXTINQ;
+
+		issue_scb_block(adapter, raw_mbox);
+
+		/*
+		 * update Enquiry3 and ProductInfo structures with
+		 * mraid_inquiry structure
+		 */
+		mega_8_to_40ld(inq, inquiry3,
+				(mega_product_info *)&adapter->product_info);
+
+		pci_free_consistent(adapter->dev, sizeof(mraid_ext_inquiry),
+				ext_inq, dma_handle);
+
+	} else {		/*adapter supports 40ld */
+		adapter->flag |= BOARD_40LD;
+
+		/*
+		 * get product_info, which is static information and will be
+		 * unchanged
+		 */
+		prod_info_dma_handle = pci_map_single(adapter->dev, (void *)
+				&adapter->product_info,
+				sizeof(mega_product_info), PCI_DMA_FROMDEVICE);
+
+		mbox->m_out.xferaddr = prod_info_dma_handle;
+
+		raw_mbox[0] = FC_NEW_CONFIG;	/* i.e. mbox->cmd=0xA1 */
+		raw_mbox[2] = NC_SUBOP_PRODUCT_INFO;	/* i.e. 0x0E */
+
+		if ((retval = issue_scb_block(adapter, raw_mbox)))
+			printk(KERN_WARNING
+			"megaraid: Product_info cmd failed with error: %d\n",
+				retval);
+
+		pci_unmap_single(adapter->dev, prod_info_dma_handle,
+				sizeof(mega_product_info), PCI_DMA_FROMDEVICE);
+	}
+
+
+	/*
+	 * kernel scans the channels from 0 to <= max_channel
+	 */
+	adapter->host->max_channel =
+		adapter->product_info.nchannels + NVIRT_CHAN -1;
+
+	adapter->host->max_id = 16;	/* max targets per channel */
+
+	adapter->host->max_lun = 7;	/* Upto 7 luns for non disk devices */
+
+	adapter->host->cmd_per_lun = max_cmd_per_lun;
+
+	adapter->numldrv = inquiry3->num_ldrv;
+
+	adapter->max_cmds = adapter->product_info.max_commands;
+
+	if(adapter->max_cmds > MAX_COMMANDS)
+		adapter->max_cmds = MAX_COMMANDS;
+
+	adapter->host->can_queue = adapter->max_cmds - 1;
+
+	/*
+	 * Get the maximum number of scatter-gather elements supported by this
+	 * firmware
+	 */
+	mega_get_max_sgl(adapter);
+
+	adapter->host->sg_tablesize = adapter->sglen;
+
+
+	/* use HP firmware and bios version encoding */
+	if (adapter->product_info.subsysvid == HP_SUBSYS_VID) {
+		sprintf (adapter->fw_version, "%c%d%d.%d%d",
+			 adapter->product_info.fw_version[2],
+			 adapter->product_info.fw_version[1] >> 8,
+			 adapter->product_info.fw_version[1] & 0x0f,
+			 adapter->product_info.fw_version[0] >> 8,
+			 adapter->product_info.fw_version[0] & 0x0f);
+		sprintf (adapter->bios_version, "%c%d%d.%d%d",
+			 adapter->product_info.bios_version[2],
+			 adapter->product_info.bios_version[1] >> 8,
+			 adapter->product_info.bios_version[1] & 0x0f,
+			 adapter->product_info.bios_version[0] >> 8,
+			 adapter->product_info.bios_version[0] & 0x0f);
+	} else {
+		memcpy(adapter->fw_version,
+				(char *)adapter->product_info.fw_version, 4);
+		adapter->fw_version[4] = 0;
+
+		memcpy(adapter->bios_version,
+				(char *)adapter->product_info.bios_version, 4);
+
+		adapter->bios_version[4] = 0;
+	}
+
+	printk(KERN_NOTICE "megaraid: [%s:%s] detected %d logical drives.\n",
+		adapter->fw_version, adapter->bios_version, adapter->numldrv);
+
+	/*
+	 * Do we support extended (>10 bytes) cdbs
+	 */
+	adapter->support_ext_cdb = mega_support_ext_cdb(adapter);
+	if (adapter->support_ext_cdb)
+		printk(KERN_NOTICE "megaraid: supports extended CDBs.\n");
+
+
+	return 0;
+}
+
+/**
+ * mega_runpendq()
+ * @adapter - pointer to our soft state
+ *
+ * Runs through the list of pending requests.
+ */
+static inline void
+mega_runpendq(adapter_t *adapter)
+{
+	if(!list_empty(&adapter->pending_list))
+		__mega_runpendq(adapter);
+}
+
+/*
+ * megaraid_queue()
+ * @scmd - Issue this scsi command
+ * @done - the callback hook into the scsi mid-layer
+ *
+ * The command queuing entry point for the mid-layer.
+ */
+static int
+megaraid_queue(Scsi_Cmnd *scmd, void (*done)(Scsi_Cmnd *))
+{
+	adapter_t	*adapter;
+	scb_t	*scb;
+	int	busy=0;
+
+	adapter = (adapter_t *)scmd->device->host->hostdata;
+
+	scmd->scsi_done = done;
+
+
+	/*
+	 * Allocate and build a SCB request
+	 * busy flag will be set if mega_build_cmd() command could not
+	 * allocate scb. We will return non-zero status in that case.
+	 * NOTE: scb can be null even though certain commands completed
+	 * successfully, e.g., MODE_SENSE and TEST_UNIT_READY, we would
+	 * return 0 in that case.
+	 */
+
+	scb = mega_build_cmd(adapter, scmd, &busy);
+
+	if(scb) {
+		scb->state |= SCB_PENDQ;
+		list_add_tail(&scb->list, &adapter->pending_list);
+
+		/*
+		 * Check if the HBA is in quiescent state, e.g., during a
+		 * delete logical drive opertion. If it is, don't run
+		 * the pending_list.
+		 */
+		if(atomic_read(&adapter->quiescent) == 0) {
+			mega_runpendq(adapter);
+		}
+		return 0;
+	}
+
+	return busy;
+}
+
+/**
+ * mega_allocate_scb()
+ * @adapter - pointer to our soft state
+ * @cmd - scsi command from the mid-layer
+ *
+ * Allocate a SCB structure. This is the central structure for controller
+ * commands.
+ */
+static inline scb_t *
+mega_allocate_scb(adapter_t *adapter, Scsi_Cmnd *cmd)
+{
+	struct list_head *head = &adapter->free_list;
+	scb_t	*scb;
+
+	/* Unlink command from Free List */
+	if( !list_empty(head) ) {
+
+		scb = list_entry(head->next, scb_t, list);
+
+		list_del_init(head->next);
+
+		scb->state = SCB_ACTIVE;
+		scb->cmd = cmd;
+		scb->dma_type = MEGA_DMA_TYPE_NONE;
+
+		return scb;
+	}
+
+	return NULL;
+}
+
+/**
+ * mega_get_ldrv_num()
+ * @adapter - pointer to our soft state
+ * @cmd - scsi mid layer command
+ * @channel - channel on the controller
+ *
+ * Calculate the logical drive number based on the information in scsi command
+ * and the channel number.
+ */
+static inline int
+mega_get_ldrv_num(adapter_t *adapter, Scsi_Cmnd *cmd, int channel)
+{
+	int		tgt;
+	int		ldrv_num;
+
+	tgt = cmd->device->id;
+	
+	if ( tgt > adapter->this_id )
+		tgt--;	/* we do not get inquires for initiator id */
+
+	ldrv_num = (channel * 15) + tgt;
+
+
+	/*
+	 * If we have a logical drive with boot enabled, project it first
+	 */
+	if( adapter->boot_ldrv_enabled ) {
+		if( ldrv_num == 0 ) {
+			ldrv_num = adapter->boot_ldrv;
+		}
+		else {
+			if( ldrv_num <= adapter->boot_ldrv ) {
+				ldrv_num--;
+			}
+		}
+	}
+
+	/*
+	 * If "delete logical drive" feature is enabled on this controller.
+	 * Do only if at least one delete logical drive operation was done.
+	 *
+	 * Also, after logical drive deletion, instead of logical drive number,
+	 * the value returned should be 0x80+logical drive id.
+	 *
+	 * These is valid only for IO commands.
+	 */
+
+	if (adapter->support_random_del && adapter->read_ldidmap )
+		switch (cmd->cmnd[0]) {
+		case READ_6:	/* fall through */
+		case WRITE_6:	/* fall through */
+		case READ_10:	/* fall through */
+		case WRITE_10:
+			ldrv_num += 0x80;
+		}
+
+	return ldrv_num;
+}
+
+/**
+ * mega_build_cmd()
+ * @adapter - pointer to our soft state
+ * @cmd - Prepare using this scsi command
+ * @busy - busy flag if no resources
+ *
+ * Prepares a command and scatter gather list for the controller. This routine
+ * also finds out if the commands is intended for a logical drive or a
+ * physical device and prepares the controller command accordingly.
+ *
+ * We also re-order the logical drives and physical devices based on their
+ * boot settings.
+ */
+static scb_t *
+mega_build_cmd(adapter_t *adapter, Scsi_Cmnd *cmd, int *busy)
+{
+	mega_ext_passthru	*epthru;
+	mega_passthru	*pthru;
+	scb_t	*scb;
+	mbox_t	*mbox;
+	long	seg;
+	char	islogical;
+	int	max_ldrv_num;
+	int	channel = 0;
+	int	target = 0;
+	int	ldrv_num = 0;   /* logical drive number */
+
+
+	/*
+	 * filter the internal and ioctl commands
+	 */
+	if((cmd->cmnd[0] == MEGA_INTERNAL_CMD)) {
+		return cmd->buffer;
+	}
+
+
+	/*
+	 * We know what channels our logical drives are on - mega_find_card()
+	 */
+	islogical = adapter->logdrv_chan[cmd->device->channel];
+
+	/*
+	 * The theory: If physical drive is chosen for boot, all the physical
+	 * devices are exported before the logical drives, otherwise physical
+	 * devices are pushed after logical drives, in which case - Kernel sees
+	 * the physical devices on virtual channel which is obviously converted
+	 * to actual channel on the HBA.
+	 */
+	if( adapter->boot_pdrv_enabled ) {
+		if( islogical ) {
+			/* logical channel */
+			channel = cmd->device->channel -
+				adapter->product_info.nchannels;
+		}
+		else {
+			/* this is physical channel */
+			channel = cmd->device->channel; 
+			target = cmd->device->id;
+
+			/*
+			 * boot from a physical disk, that disk needs to be
+			 * exposed first IF both the channels are SCSI, then
+			 * booting from the second channel is not allowed.
+			 */
+			if( target == 0 ) {
+				target = adapter->boot_pdrv_tgt;
+			}
+			else if( target == adapter->boot_pdrv_tgt ) {
+				target = 0;
+			}
+		}
+	}
+	else {
+		if( islogical ) {
+			/* this is the logical channel */
+			channel = cmd->device->channel;	
+		}
+		else {
+			/* physical channel */
+			channel = cmd->device->channel - NVIRT_CHAN;	
+			target = cmd->device->id;
+		}
+	}
+
+
+	if(islogical) {
+
+		/* have just LUN 0 for each target on virtual channels */
+		if (cmd->device->lun) {
+			cmd->result = (DID_BAD_TARGET << 16);
+			cmd->scsi_done(cmd);
+			return NULL;
+		}
+
+		ldrv_num = mega_get_ldrv_num(adapter, cmd, channel);
+
+
+		max_ldrv_num = (adapter->flag & BOARD_40LD) ?
+			MAX_LOGICAL_DRIVES_40LD : MAX_LOGICAL_DRIVES_8LD;
+
+		/*
+		 * max_ldrv_num increases by 0x80 if some logical drive was
+		 * deleted.
+		 */
+		if(adapter->read_ldidmap)
+			max_ldrv_num += 0x80;
+
+		if(ldrv_num > max_ldrv_num ) {
+			cmd->result = (DID_BAD_TARGET << 16);
+			cmd->scsi_done(cmd);
+			return NULL;
+		}
+
+	}
+	else {
+		if( cmd->device->lun > 7) {
+			/*
+			 * Do not support lun >7 for physically accessed
+			 * devices
+			 */
+			cmd->result = (DID_BAD_TARGET << 16);
+			cmd->scsi_done(cmd);
+			return NULL;
+		}
+	}
+
+	/*
+	 *
+	 * Logical drive commands
+	 *
+	 */
+	if(islogical) {
+		switch (cmd->cmnd[0]) {
+		case TEST_UNIT_READY:
+			memset(cmd->request_buffer, 0, cmd->request_bufflen);
+
+#if MEGA_HAVE_CLUSTERING
+			/*
+			 * Do we support clustering and is the support enabled
+			 * If no, return success always
+			 */
+			if( !adapter->has_cluster ) {
+				cmd->result = (DID_OK << 16);
+				cmd->scsi_done(cmd);
+				return NULL;
+			}
+
+			if(!(scb = mega_allocate_scb(adapter, cmd))) {
+				*busy = 1;
+				return NULL;
+			}
+
+			scb->raw_mbox[0] = MEGA_CLUSTER_CMD;
+			scb->raw_mbox[2] = MEGA_RESERVATION_STATUS;
+			scb->raw_mbox[3] = ldrv_num;
+
+			scb->dma_direction = PCI_DMA_NONE;
+
+			return scb;
+#else
+			cmd->result = (DID_OK << 16);
+			cmd->scsi_done(cmd);
+			return NULL;
+#endif
+
+		case MODE_SENSE:
+			memset(cmd->request_buffer, 0, cmd->cmnd[4]);
+			cmd->result = (DID_OK << 16);
+			cmd->scsi_done(cmd);
+			return NULL;
+
+		case READ_CAPACITY:
+		case INQUIRY:
+
+			if(!(adapter->flag & (1L << cmd->device->channel))) {
+
+				printk(KERN_NOTICE
+					"scsi%d: scanning scsi channel %d ",
+						adapter->host->host_no,
+						cmd->device->channel);
+				printk("for logical drives.\n");
+
+				adapter->flag |= (1L << cmd->device->channel);
+			}
+
+			/* Allocate a SCB and initialize passthru */
+			if(!(scb = mega_allocate_scb(adapter, cmd))) {
+				*busy = 1;
+				return NULL;
+			}
+			pthru = scb->pthru;
+
+			mbox = (mbox_t *)scb->raw_mbox;
+			memset(mbox, 0, sizeof(scb->raw_mbox));
+			memset(pthru, 0, sizeof(mega_passthru));
+
+			pthru->timeout = 0;
+			pthru->ars = 1;
+			pthru->reqsenselen = 14;
+			pthru->islogical = 1;
+			pthru->logdrv = ldrv_num;
+			pthru->cdblen = cmd->cmd_len;
+			memcpy(pthru->cdb, cmd->cmnd, cmd->cmd_len);
+
+			if( adapter->has_64bit_addr ) {
+				mbox->m_out.cmd = MEGA_MBOXCMD_PASSTHRU64;
+			}
+			else {
+				mbox->m_out.cmd = MEGA_MBOXCMD_PASSTHRU;
+			}
+
+			scb->dma_direction = PCI_DMA_FROMDEVICE;
+
+			pthru->numsgelements = mega_build_sglist(adapter, scb,
+				&pthru->dataxferaddr, &pthru->dataxferlen);
+
+			mbox->m_out.xferaddr = scb->pthru_dma_addr;
+
+			return scb;
+
+		case READ_6:
+		case WRITE_6:
+		case READ_10:
+		case WRITE_10:
+		case READ_12:
+		case WRITE_12:
+
+			/* Allocate a SCB and initialize mailbox */
+			if(!(scb = mega_allocate_scb(adapter, cmd))) {
+				*busy = 1;
+				return NULL;
+			}
+			mbox = (mbox_t *)scb->raw_mbox;
+
+			memset(mbox, 0, sizeof(scb->raw_mbox));
+			mbox->m_out.logdrv = ldrv_num;
+
+			/*
+			 * A little hack: 2nd bit is zero for all scsi read
+			 * commands and is set for all scsi write commands
+			 */
+			if( adapter->has_64bit_addr ) {
+				mbox->m_out.cmd = (*cmd->cmnd & 0x02) ?
+					MEGA_MBOXCMD_LWRITE64:
+					MEGA_MBOXCMD_LREAD64 ;
+			}
+			else {
+				mbox->m_out.cmd = (*cmd->cmnd & 0x02) ?
+					MEGA_MBOXCMD_LWRITE:
+					MEGA_MBOXCMD_LREAD ;
+			}
+
+			/*
+			 * 6-byte READ(0x08) or WRITE(0x0A) cdb
+			 */
+			if( cmd->cmd_len == 6 ) {
+				mbox->m_out.numsectors = (u32) cmd->cmnd[4];
+				mbox->m_out.lba =
+					((u32)cmd->cmnd[1] << 16) |
+					((u32)cmd->cmnd[2] << 8) |
+					(u32)cmd->cmnd[3];
+
+				mbox->m_out.lba &= 0x1FFFFF;
+
+#if MEGA_HAVE_STATS
+				/*
+				 * Take modulo 0x80, since the logical drive
+				 * number increases by 0x80 when a logical
+				 * drive was deleted
+				 */
+				if (*cmd->cmnd == READ_6) {
+					adapter->nreads[ldrv_num%0x80]++;
+					adapter->nreadblocks[ldrv_num%0x80] +=
+						mbox->m_out.numsectors;
+				} else {
+					adapter->nwrites[ldrv_num%0x80]++;
+					adapter->nwriteblocks[ldrv_num%0x80] +=
+						mbox->m_out.numsectors;
+				}
+#endif
+			}
+
+			/*
+			 * 10-byte READ(0x28) or WRITE(0x2A) cdb
+			 */
+			if( cmd->cmd_len == 10 ) {
+				mbox->m_out.numsectors =
+					(u32)cmd->cmnd[8] |
+					((u32)cmd->cmnd[7] << 8);
+				mbox->m_out.lba =
+					((u32)cmd->cmnd[2] << 24) |
+					((u32)cmd->cmnd[3] << 16) |
+					((u32)cmd->cmnd[4] << 8) |
+					(u32)cmd->cmnd[5];
+
+#if MEGA_HAVE_STATS
+				if (*cmd->cmnd == READ_10) {
+					adapter->nreads[ldrv_num%0x80]++;
+					adapter->nreadblocks[ldrv_num%0x80] +=
+						mbox->m_out.numsectors;
+				} else {
+					adapter->nwrites[ldrv_num%0x80]++;
+					adapter->nwriteblocks[ldrv_num%0x80] +=
+						mbox->m_out.numsectors;
+				}
+#endif
+			}
+
+			/*
+			 * 12-byte READ(0xA8) or WRITE(0xAA) cdb
+			 */
+			if( cmd->cmd_len == 12 ) {
+				mbox->m_out.lba =
+					((u32)cmd->cmnd[2] << 24) |
+					((u32)cmd->cmnd[3] << 16) |
+					((u32)cmd->cmnd[4] << 8) |
+					(u32)cmd->cmnd[5];
+
+				mbox->m_out.numsectors =
+					((u32)cmd->cmnd[6] << 24) |
+					((u32)cmd->cmnd[7] << 16) |
+					((u32)cmd->cmnd[8] << 8) |
+					(u32)cmd->cmnd[9];
+
+#if MEGA_HAVE_STATS
+				if (*cmd->cmnd == READ_12) {
+					adapter->nreads[ldrv_num%0x80]++;
+					adapter->nreadblocks[ldrv_num%0x80] +=
+						mbox->m_out.numsectors;
+				} else {
+					adapter->nwrites[ldrv_num%0x80]++;
+					adapter->nwriteblocks[ldrv_num%0x80] +=
+						mbox->m_out.numsectors;
+				}
+#endif
+			}
+
+			/*
+			 * If it is a read command
+			 */
+			if( (*cmd->cmnd & 0x0F) == 0x08 ) {
+				scb->dma_direction = PCI_DMA_FROMDEVICE;
+			}
+			else {
+				scb->dma_direction = PCI_DMA_TODEVICE;
+			}
+
+			/* Calculate Scatter-Gather info */
+			mbox->m_out.numsgelements = mega_build_sglist(adapter, scb,
+					(u32 *)&mbox->m_out.xferaddr, (u32 *)&seg);
+
+			return scb;
+
+#if MEGA_HAVE_CLUSTERING
+		case RESERVE:	/* Fall through */
+		case RELEASE:
+
+			/*
+			 * Do we support clustering and is the support enabled
+			 */
+			if( ! adapter->has_cluster ) {
+
+				cmd->result = (DID_BAD_TARGET << 16);
+				cmd->scsi_done(cmd);
+				return NULL;
+			}
+
+			/* Allocate a SCB and initialize mailbox */
+			if(!(scb = mega_allocate_scb(adapter, cmd))) {
+				*busy = 1;
+				return NULL;
+			}
+
+			scb->raw_mbox[0] = MEGA_CLUSTER_CMD;
+			scb->raw_mbox[2] = ( *cmd->cmnd == RESERVE ) ?
+				MEGA_RESERVE_LD : MEGA_RELEASE_LD;
+
+			scb->raw_mbox[3] = ldrv_num;
+
+			scb->dma_direction = PCI_DMA_NONE;
+
+			return scb;
+#endif
+
+		default:
+			cmd->result = (DID_BAD_TARGET << 16);
+			cmd->scsi_done(cmd);
+			return NULL;
+		}
+	}
+
+	/*
+	 * Passthru drive commands
+	 */
+	else {
+		/* Allocate a SCB and initialize passthru */
+		if(!(scb = mega_allocate_scb(adapter, cmd))) {
+			*busy = 1;
+			return NULL;
+		}
+
+		mbox = (mbox_t *)scb->raw_mbox;
+		memset(mbox, 0, sizeof(scb->raw_mbox));
+
+		if( adapter->support_ext_cdb ) {
+
+			epthru = mega_prepare_extpassthru(adapter, scb, cmd,
+					channel, target);
+
+			mbox->m_out.cmd = MEGA_MBOXCMD_EXTPTHRU;
+
+			mbox->m_out.xferaddr = scb->epthru_dma_addr;
+
+		}
+		else {
+
+			pthru = mega_prepare_passthru(adapter, scb, cmd,
+					channel, target);
+
+			/* Initialize mailbox */
+			if( adapter->has_64bit_addr ) {
+				mbox->m_out.cmd = MEGA_MBOXCMD_PASSTHRU64;
+			}
+			else {
+				mbox->m_out.cmd = MEGA_MBOXCMD_PASSTHRU;
+			}
+
+			mbox->m_out.xferaddr = scb->pthru_dma_addr;
+
+		}
+		return scb;
+	}
+	return NULL;
+}
+
+
+/**
+ * mega_prepare_passthru()
+ * @adapter - pointer to our soft state
+ * @scb - our scsi control block
+ * @cmd - scsi command from the mid-layer
+ * @channel - actual channel on the controller
+ * @target - actual id on the controller.
+ *
+ * prepare a command for the scsi physical devices.
+ */
+static mega_passthru *
+mega_prepare_passthru(adapter_t *adapter, scb_t *scb, Scsi_Cmnd *cmd,
+		int channel, int target)
+{
+	mega_passthru *pthru;
+
+	pthru = scb->pthru;
+	memset(pthru, 0, sizeof (mega_passthru));
+
+	/* 0=6sec/1=60sec/2=10min/3=3hrs */
+	pthru->timeout = 2;
+
+	pthru->ars = 1;
+	pthru->reqsenselen = 14;
+	pthru->islogical = 0;
+
+	pthru->channel = (adapter->flag & BOARD_40LD) ? 0 : channel;
+
+	pthru->target = (adapter->flag & BOARD_40LD) ?
+		(channel << 4) | target : target;
+
+	pthru->cdblen = cmd->cmd_len;
+	pthru->logdrv = cmd->device->lun;
+
+	memcpy(pthru->cdb, cmd->cmnd, cmd->cmd_len);
+
+	/* Not sure about the direction */
+	scb->dma_direction = PCI_DMA_BIDIRECTIONAL;
+
+	/* Special Code for Handling READ_CAPA/ INQ using bounce buffers */
+	switch (cmd->cmnd[0]) {
+	case INQUIRY:
+	case READ_CAPACITY:
+		if(!(adapter->flag & (1L << cmd->device->channel))) {
+
+			printk(KERN_NOTICE
+				"scsi%d: scanning scsi channel %d [P%d] ",
+					adapter->host->host_no,
+					cmd->device->channel, channel);
+			printk("for physical devices.\n");
+
+			adapter->flag |= (1L << cmd->device->channel);
+		}
+		/* Fall through */
+	default:
+		pthru->numsgelements = mega_build_sglist(adapter, scb,
+				&pthru->dataxferaddr, &pthru->dataxferlen);
+		break;
+	}
+	return pthru;
+}
+
+
+/**
+ * mega_prepare_extpassthru()
+ * @adapter - pointer to our soft state
+ * @scb - our scsi control block
+ * @cmd - scsi command from the mid-layer
+ * @channel - actual channel on the controller
+ * @target - actual id on the controller.
+ *
+ * prepare a command for the scsi physical devices. This rountine prepares
+ * commands for devices which can take extended CDBs (>10 bytes)
+ */
+static mega_ext_passthru *
+mega_prepare_extpassthru(adapter_t *adapter, scb_t *scb, Scsi_Cmnd *cmd,
+		int channel, int target)
+{
+	mega_ext_passthru	*epthru;
+
+	epthru = scb->epthru;
+	memset(epthru, 0, sizeof(mega_ext_passthru));
+
+	/* 0=6sec/1=60sec/2=10min/3=3hrs */
+	epthru->timeout = 2;
+
+	epthru->ars = 1;
+	epthru->reqsenselen = 14;
+	epthru->islogical = 0;
+
+	epthru->channel = (adapter->flag & BOARD_40LD) ? 0 : channel;
+	epthru->target = (adapter->flag & BOARD_40LD) ?
+		(channel << 4) | target : target;
+
+	epthru->cdblen = cmd->cmd_len;
+	epthru->logdrv = cmd->device->lun;
+
+	memcpy(epthru->cdb, cmd->cmnd, cmd->cmd_len);
+
+	/* Not sure about the direction */
+	scb->dma_direction = PCI_DMA_BIDIRECTIONAL;
+
+	switch(cmd->cmnd[0]) {
+	case INQUIRY:
+	case READ_CAPACITY:
+		if(!(adapter->flag & (1L << cmd->device->channel))) {
+
+			printk(KERN_NOTICE
+				"scsi%d: scanning scsi channel %d [P%d] ",
+					adapter->host->host_no,
+					cmd->device->channel, channel);
+			printk("for physical devices.\n");
+
+			adapter->flag |= (1L << cmd->device->channel);
+		}
+		/* Fall through */
+	default:
+		epthru->numsgelements = mega_build_sglist(adapter, scb,
+				&epthru->dataxferaddr, &epthru->dataxferlen);
+		break;
+	}
+
+	return epthru;
+}
+
+static void
+__mega_runpendq(adapter_t *adapter)
+{
+	scb_t *scb;
+	struct list_head *pos, *next;
+
+	/* Issue any pending commands to the card */
+	list_for_each_safe(pos, next, &adapter->pending_list) {
+
+		scb = list_entry(pos, scb_t, list);
+
+		if( !(scb->state & SCB_ISSUED) ) {
+
+			if( issue_scb(adapter, scb) != 0 )
+				return;
+		}
+	}
+
+	return;
+}
+
+
+/**
+ * issue_scb()
+ * @adapter - pointer to our soft state
+ * @scb - scsi control block
+ *
+ * Post a command to the card if the mailbox is available, otherwise return
+ * busy. We also take the scb from the pending list if the mailbox is
+ * available.
+ */
+static int
+issue_scb(adapter_t *adapter, scb_t *scb)
+{
+	volatile mbox64_t	*mbox64 = adapter->mbox64;
+	volatile mbox_t		*mbox = adapter->mbox;
+	unsigned int	i = 0;
+
+	if(unlikely(mbox->m_in.busy)) {
+		do {
+			udelay(1);
+			i++;
+		} while( mbox->m_in.busy && (i < max_mbox_busy_wait) );
+
+		if(mbox->m_in.busy) return -1;
+	}
+
+	/* Copy mailbox data into host structure */
+	memcpy((char *)&mbox->m_out, (char *)scb->raw_mbox, 
+			sizeof(struct mbox_out));
+
+	mbox->m_out.cmdid = scb->idx;	/* Set cmdid */
+	mbox->m_in.busy = 1;		/* Set busy */
+
+
+	/*
+	 * Increment the pending queue counter
+	 */
+	atomic_inc(&adapter->pend_cmds);
+
+	switch (mbox->m_out.cmd) {
+	case MEGA_MBOXCMD_LREAD64:
+	case MEGA_MBOXCMD_LWRITE64:
+	case MEGA_MBOXCMD_PASSTHRU64:
+	case MEGA_MBOXCMD_EXTPTHRU:
+		mbox64->xfer_segment_lo = mbox->m_out.xferaddr;
+		mbox64->xfer_segment_hi = 0;
+		mbox->m_out.xferaddr = 0xFFFFFFFF;
+		break;
+	default:
+		mbox64->xfer_segment_lo = 0;
+		mbox64->xfer_segment_hi = 0;
+	}
+
+	/*
+	 * post the command
+	 */
+	scb->state |= SCB_ISSUED;
+
+	if( likely(adapter->flag & BOARD_MEMMAP) ) {
+		mbox->m_in.poll = 0;
+		mbox->m_in.ack = 0;
+		WRINDOOR(adapter, adapter->mbox_dma | 0x1);
+	}
+	else {
+		irq_enable(adapter);
+		issue_command(adapter);
+	}
+
+	return 0;
+}
+
+/*
+ * Wait until the controller's mailbox is available
+ */
+static inline int
+mega_busywait_mbox (adapter_t *adapter)
+{
+	if (adapter->mbox->m_in.busy)
+		return __mega_busywait_mbox(adapter);
+	return 0;
+}
+
+/**
+ * issue_scb_block()
+ * @adapter - pointer to our soft state
+ * @raw_mbox - the mailbox
+ *
+ * Issue a scb in synchronous and non-interrupt mode
+ */
+static int
+issue_scb_block(adapter_t *adapter, u_char *raw_mbox)
+{
+	volatile mbox64_t *mbox64 = adapter->mbox64;
+	volatile mbox_t *mbox = adapter->mbox;
+	u8	byte;
+
+	/* Wait until mailbox is free */
+	if(mega_busywait_mbox (adapter))
+		goto bug_blocked_mailbox;
+
+	/* Copy mailbox data into host structure */
+	memcpy((char *) mbox, raw_mbox, sizeof(struct mbox_out));
+	mbox->m_out.cmdid = 0xFE;
+	mbox->m_in.busy = 1;
+
+	switch (raw_mbox[0]) {
+	case MEGA_MBOXCMD_LREAD64:
+	case MEGA_MBOXCMD_LWRITE64:
+	case MEGA_MBOXCMD_PASSTHRU64:
+	case MEGA_MBOXCMD_EXTPTHRU:
+		mbox64->xfer_segment_lo = mbox->m_out.xferaddr;
+		mbox64->xfer_segment_hi = 0;
+		mbox->m_out.xferaddr = 0xFFFFFFFF;
+		break;
+	default:
+		mbox64->xfer_segment_lo = 0;
+		mbox64->xfer_segment_hi = 0;
+	}
+
+	if( likely(adapter->flag & BOARD_MEMMAP) ) {
+		mbox->m_in.poll = 0;
+		mbox->m_in.ack = 0;
+		mbox->m_in.numstatus = 0xFF;
+		mbox->m_in.status = 0xFF;
+		WRINDOOR(adapter, adapter->mbox_dma | 0x1);
+
+		while((volatile u8)mbox->m_in.numstatus == 0xFF)
+			cpu_relax();
+
+		mbox->m_in.numstatus = 0xFF;
+
+		while( (volatile u8)mbox->m_in.poll != 0x77 )
+			cpu_relax();
+
+		mbox->m_in.poll = 0;
+		mbox->m_in.ack = 0x77;
+
+		WRINDOOR(adapter, adapter->mbox_dma | 0x2);
+
+		while(RDINDOOR(adapter) & 0x2)
+			cpu_relax();
+	}
+	else {
+		irq_disable(adapter);
+		issue_command(adapter);
+
+		while (!((byte = irq_state(adapter)) & INTR_VALID))
+			cpu_relax();
+
+		set_irq_state(adapter, byte);
+		irq_enable(adapter);
+		irq_ack(adapter);
+	}
+
+	return mbox->m_in.status;
+
+bug_blocked_mailbox:
+	printk(KERN_WARNING "megaraid: Blocked mailbox......!!\n");
+	udelay (1000);
+	return -1;
+}
+
+
+/**
+ * megaraid_isr_iomapped()
+ * @irq - irq
+ * @devp - pointer to our soft state
+ * @regs - unused
+ *
+ * Interrupt service routine for io-mapped controllers.
+ * Find out if our device is interrupting. If yes, acknowledge the interrupt
+ * and service the completed commands.
+ */
+static irqreturn_t
+megaraid_isr_iomapped(int irq, void *devp, struct pt_regs *regs)
+{
+	adapter_t	*adapter = devp;
+	unsigned long	flags;
+	u8	status;
+	u8	nstatus;
+	u8	completed[MAX_FIRMWARE_STATUS];
+	u8	byte;
+	int	handled = 0;
+
+
+	/*
+	 * loop till F/W has more commands for us to complete.
+	 */
+	spin_lock_irqsave(&adapter->lock, flags);
+
+	do {
+		/* Check if a valid interrupt is pending */
+		byte = irq_state(adapter);
+		if( (byte & VALID_INTR_BYTE) == 0 ) {
+			/*
+			 * No more pending commands
+			 */
+			goto out_unlock;
+		}
+		set_irq_state(adapter, byte);
+
+		while((nstatus = (volatile u8)adapter->mbox->m_in.numstatus)
+				== 0xFF)
+			cpu_relax();
+		adapter->mbox->m_in.numstatus = 0xFF;
+
+		status = adapter->mbox->m_in.status;
+
+		/*
+		 * decrement the pending queue counter
+		 */
+		atomic_sub(nstatus, &adapter->pend_cmds);
+
+		memcpy(completed, (void *)adapter->mbox->m_in.completed, 
+				nstatus);
+
+		/* Acknowledge interrupt */
+		irq_ack(adapter);
+
+		mega_cmd_done(adapter, completed, nstatus, status);
+
+		mega_rundoneq(adapter);
+
+		handled = 1;
+
+		/* Loop through any pending requests */
+		if(atomic_read(&adapter->quiescent) == 0) {
+			mega_runpendq(adapter);
+		}
+
+	} while(1);
+
+ out_unlock:
+
+	spin_unlock_irqrestore(&adapter->lock, flags);
+
+	return IRQ_RETVAL(handled);
+}
+
+
+/**
+ * megaraid_isr_memmapped()
+ * @irq - irq
+ * @devp - pointer to our soft state
+ * @regs - unused
+ *
+ * Interrupt service routine for memory-mapped controllers.
+ * Find out if our device is interrupting. If yes, acknowledge the interrupt
+ * and service the completed commands.
+ */
+static irqreturn_t
+megaraid_isr_memmapped(int irq, void *devp, struct pt_regs *regs)
+{
+	adapter_t	*adapter = devp;
+	unsigned long	flags;
+	u8	status;
+	u32	dword = 0;
+	u8	nstatus;
+	u8	completed[MAX_FIRMWARE_STATUS];
+	int	handled = 0;
+
+
+	/*
+	 * loop till F/W has more commands for us to complete.
+	 */
+	spin_lock_irqsave(&adapter->lock, flags);
+
+	do {
+		/* Check if a valid interrupt is pending */
+		dword = RDOUTDOOR(adapter);
+		if(dword != 0x10001234) {
+			/*
+			 * No more pending commands
+			 */
+			goto out_unlock;
+		}
+		WROUTDOOR(adapter, 0x10001234);
+
+		while((nstatus = (volatile u8)adapter->mbox->m_in.numstatus)
+				== 0xFF) {
+			cpu_relax();
+		}
+		adapter->mbox->m_in.numstatus = 0xFF;
+
+		status = adapter->mbox->m_in.status;
+
+		/*
+		 * decrement the pending queue counter
+		 */
+		atomic_sub(nstatus, &adapter->pend_cmds);
+
+		memcpy(completed, (void *)adapter->mbox->m_in.completed, 
+				nstatus);
+
+		/* Acknowledge interrupt */
+		WRINDOOR(adapter, 0x2);
+
+		handled = 1;
+
+		while( RDINDOOR(adapter) & 0x02 ) cpu_relax();
+
+		mega_cmd_done(adapter, completed, nstatus, status);
+
+		mega_rundoneq(adapter);
+
+		/* Loop through any pending requests */
+		if(atomic_read(&adapter->quiescent) == 0) {
+			mega_runpendq(adapter);
+		}
+
+	} while(1);
+
+ out_unlock:
+
+	spin_unlock_irqrestore(&adapter->lock, flags);
+
+	return IRQ_RETVAL(handled);
+}
+/**
+ * mega_cmd_done()
+ * @adapter - pointer to our soft state
+ * @completed - array of ids of completed commands
+ * @nstatus - number of completed commands
+ * @status - status of the last command completed
+ *
+ * Complete the comamnds and call the scsi mid-layer callback hooks.
+ */
+static void
+mega_cmd_done(adapter_t *adapter, u8 completed[], int nstatus, int status)
+{
+	mega_ext_passthru	*epthru = NULL;
+	struct scatterlist	*sgl;
+	Scsi_Cmnd	*cmd = NULL;
+	mega_passthru	*pthru = NULL;
+	mbox_t	*mbox = NULL;
+	u8	c;
+	scb_t	*scb;
+	int	islogical;
+	int	cmdid;
+	int	i;
+
+	/*
+	 * for all the commands completed, call the mid-layer callback routine
+	 * and free the scb.
+	 */
+	for( i = 0; i < nstatus; i++ ) {
+
+		cmdid = completed[i];
+
+		if( cmdid == CMDID_INT_CMDS ) { /* internal command */
+			scb = &adapter->int_scb;
+			cmd = scb->cmd;
+			mbox = (mbox_t *)scb->raw_mbox;
+
+			/*
+			 * Internal command interface do not fire the extended
+			 * passthru or 64-bit passthru
+			 */
+			pthru = scb->pthru;
+
+		}
+		else {
+			scb = &adapter->scb_list[cmdid];
+
+			/*
+			 * Make sure f/w has completed a valid command
+			 */
+			if( !(scb->state & SCB_ISSUED) || scb->cmd == NULL ) {
+				printk(KERN_CRIT
+					"megaraid: invalid command ");
+				printk("Id %d, scb->state:%x, scsi cmd:%p\n",
+					cmdid, scb->state, scb->cmd);
+
+				continue;
+			}
+
+			/*
+			 * Was a abort issued for this command
+			 */
+			if( scb->state & SCB_ABORT ) {
+
+				printk(KERN_WARNING
+				"megaraid: aborted cmd %lx[%x] complete.\n",
+					scb->cmd->serial_number, scb->idx);
+
+				scb->cmd->result = (DID_ABORT << 16);
+
+				list_add_tail(SCSI_LIST(scb->cmd),
+						&adapter->completed_list);
+
+				mega_free_scb(adapter, scb);
+
+				continue;
+			}
+
+			/*
+			 * Was a reset issued for this command
+			 */
+			if( scb->state & SCB_RESET ) {
+
+				printk(KERN_WARNING
+				"megaraid: reset cmd %lx[%x] complete.\n",
+					scb->cmd->serial_number, scb->idx);
+
+				scb->cmd->result = (DID_RESET << 16);
+
+				list_add_tail(SCSI_LIST(scb->cmd),
+						&adapter->completed_list);
+
+				mega_free_scb (adapter, scb);
+
+				continue;
+			}
+
+			cmd = scb->cmd;
+			pthru = scb->pthru;
+			epthru = scb->epthru;
+			mbox = (mbox_t *)scb->raw_mbox;
+
+#if MEGA_HAVE_STATS
+			{
+
+			int	logdrv = mbox->m_out.logdrv;
+
+			islogical = adapter->logdrv_chan[cmd->channel];
+			/*
+			 * Maintain an error counter for the logical drive.
+			 * Some application like SNMP agent need such
+			 * statistics
+			 */
+			if( status && islogical && (cmd->cmnd[0] == READ_6 ||
+						cmd->cmnd[0] == READ_10 ||
+						cmd->cmnd[0] == READ_12)) {
+				/*
+				 * Logical drive number increases by 0x80 when
+				 * a logical drive is deleted
+				 */
+				adapter->rd_errors[logdrv%0x80]++;
+			}
+
+			if( status && islogical && (cmd->cmnd[0] == WRITE_6 ||
+						cmd->cmnd[0] == WRITE_10 ||
+						cmd->cmnd[0] == WRITE_12)) {
+				/*
+				 * Logical drive number increases by 0x80 when
+				 * a logical drive is deleted
+				 */
+				adapter->wr_errors[logdrv%0x80]++;
+			}
+
+			}
+#endif
+		}
+
+		/*
+		 * Do not return the presence of hard disk on the channel so,
+		 * inquiry sent, and returned data==hard disk or removable
+		 * hard disk and not logical, request should return failure! -
+		 * PJ
+		 */
+		islogical = adapter->logdrv_chan[cmd->device->channel];
+		if( cmd->cmnd[0] == INQUIRY && !islogical ) {
+
+			if( cmd->use_sg ) {
+				sgl = (struct scatterlist *)
+					cmd->request_buffer;
+
+				if( sgl->page ) {
+					c = *(unsigned char *)
+					page_address((&sgl[0])->page) +
+					(&sgl[0])->offset; 
+				}
+				else {
+					printk(KERN_WARNING
+						"megaraid: invalid sg.\n");
+					c = 0;
+				}
+			}
+			else {
+				c = *(u8 *)cmd->request_buffer;
+			}
+
+			if(IS_RAID_CH(adapter, cmd->device->channel) &&
+					((c & 0x1F ) == TYPE_DISK)) {
+				status = 0xF0;
+			}
+		}
+
+		/* clear result; otherwise, success returns corrupt value */
+		cmd->result = 0;
+
+		/* Convert MegaRAID status to Linux error code */
+		switch (status) {
+		case 0x00:	/* SUCCESS , i.e. SCSI_STATUS_GOOD */
+			cmd->result |= (DID_OK << 16);
+			break;
+
+		case 0x02:	/* ERROR_ABORTED, i.e.
+				   SCSI_STATUS_CHECK_CONDITION */
+
+			/* set sense_buffer and result fields */
+			if( mbox->m_out.cmd == MEGA_MBOXCMD_PASSTHRU ||
+				mbox->m_out.cmd == MEGA_MBOXCMD_PASSTHRU64 ) {
+
+				memcpy(cmd->sense_buffer, pthru->reqsensearea,
+						14);
+
+				cmd->result = (DRIVER_SENSE << 24) |
+					(DID_OK << 16) |
+					(CHECK_CONDITION << 1);
+			}
+			else {
+				if (mbox->m_out.cmd == MEGA_MBOXCMD_EXTPTHRU) {
+
+					memcpy(cmd->sense_buffer,
+						epthru->reqsensearea, 14);
+
+					cmd->result = (DRIVER_SENSE << 24) |
+						(DID_OK << 16) |
+						(CHECK_CONDITION << 1);
+				} else {
+					cmd->sense_buffer[0] = 0x70;
+					cmd->sense_buffer[2] = ABORTED_COMMAND;
+					cmd->result |= (CHECK_CONDITION << 1);
+				}
+			}
+			break;
+
+		case 0x08:	/* ERR_DEST_DRIVE_FAILED, i.e.
+				   SCSI_STATUS_BUSY */
+			cmd->result |= (DID_BUS_BUSY << 16) | status;
+			break;
+
+		default:
+#if MEGA_HAVE_CLUSTERING
+			/*
+			 * If TEST_UNIT_READY fails, we know
+			 * MEGA_RESERVATION_STATUS failed
+			 */
+			if( cmd->cmnd[0] == TEST_UNIT_READY ) {
+				cmd->result |= (DID_ERROR << 16) |
+					(RESERVATION_CONFLICT << 1);
+			}
+			else
+			/*
+			 * Error code returned is 1 if Reserve or Release
+			 * failed or the input parameter is invalid
+			 */
+			if( status == 1 &&
+				(cmd->cmnd[0] == RESERVE ||
+					 cmd->cmnd[0] == RELEASE) ) {
+
+				cmd->result |= (DID_ERROR << 16) |
+					(RESERVATION_CONFLICT << 1);
+			}
+			else
+#endif
+				cmd->result |= (DID_BAD_TARGET << 16)|status;
+		}
+
+		/*
+		 * Only free SCBs for the commands coming down from the
+		 * mid-layer, not for which were issued internally
+		 *
+		 * For internal command, restore the status returned by the
+		 * firmware so that user can interpret it.
+		 */
+		if( cmdid == CMDID_INT_CMDS ) { /* internal command */
+			cmd->result = status;
+
+			/*
+			 * Remove the internal command from the pending list
+			 */
+			list_del_init(&scb->list);
+			scb->state = SCB_FREE;
+		}
+		else {
+			mega_free_scb(adapter, scb);
+		}
+
+		/* Add Scsi_Command to end of completed queue */
+		list_add_tail(SCSI_LIST(cmd), &adapter->completed_list);
+	}
+}
+
+
+/*
+ * mega_runpendq()
+ *
+ * Run through the list of completed requests and finish it
+ */
+static void
+mega_rundoneq (adapter_t *adapter)
+{
+	Scsi_Cmnd *cmd;
+	struct list_head *pos;
+
+	list_for_each(pos, &adapter->completed_list) {
+
+		Scsi_Pointer* spos = (Scsi_Pointer *)pos;
+
+		cmd = list_entry(spos, Scsi_Cmnd, SCp);
+		cmd->scsi_done(cmd);
+	}
+
+	INIT_LIST_HEAD(&adapter->completed_list);
+}
+
+
+/*
+ * Free a SCB structure
+ * Note: We assume the scsi commands associated with this scb is not free yet.
+ */
+static void
+mega_free_scb(adapter_t *adapter, scb_t *scb)
+{
+	switch( scb->dma_type ) {
+
+	case MEGA_DMA_TYPE_NONE:
+		break;
+
+	case MEGA_BULK_DATA:
+		pci_unmap_page(adapter->dev, scb->dma_h_bulkdata,
+			scb->cmd->request_bufflen, scb->dma_direction);
+		break;
+
+	case MEGA_SGLIST:
+		pci_unmap_sg(adapter->dev, scb->cmd->request_buffer,
+			scb->cmd->use_sg, scb->dma_direction);
+		break;
+
+	default:
+		break;
+	}
+
+	/*
+	 * Remove from the pending list
+	 */
+	list_del_init(&scb->list);
+
+	/* Link the scb back into free list */
+	scb->state = SCB_FREE;
+	scb->cmd = NULL;
+
+	list_add(&scb->list, &adapter->free_list);
+}
+
+
+static int
+__mega_busywait_mbox (adapter_t *adapter)
+{
+	volatile mbox_t *mbox = adapter->mbox;
+	long counter;
+
+	for (counter = 0; counter < 10000; counter++) {
+		if (!mbox->m_in.busy)
+			return 0;
+		udelay(100); yield();
+	}
+	return -1;		/* give up after 1 second */
+}
+
+/*
+ * Copies data to SGLIST
+ * Note: For 64 bit cards, we need a minimum of one SG element for read/write
+ */
+static int
+mega_build_sglist(adapter_t *adapter, scb_t *scb, u32 *buf, u32 *len)
+{
+	struct scatterlist	*sgl;
+	struct page	*page;
+	unsigned long	offset;
+	Scsi_Cmnd	*cmd;
+	int	sgcnt;
+	int	idx;
+
+	cmd = scb->cmd;
+
+	/* Scatter-gather not used */
+	if( !cmd->use_sg ) {
+
+		page = virt_to_page(cmd->request_buffer);
+		offset = offset_in_page(cmd->request_buffer);
+
+		scb->dma_h_bulkdata = pci_map_page(adapter->dev,
+						  page, offset,
+						  cmd->request_bufflen,
+						  scb->dma_direction);
+		scb->dma_type = MEGA_BULK_DATA;
+
+		/*
+		 * We need to handle special 64-bit commands that need a
+		 * minimum of 1 SG
+		 */
+		if( adapter->has_64bit_addr ) {
+			scb->sgl64[0].address = scb->dma_h_bulkdata;
+			scb->sgl64[0].length = cmd->request_bufflen;
+			*buf = (u32)scb->sgl_dma_addr;
+			*len = (u32)cmd->request_bufflen;
+			return 1;
+		}
+		else {
+			*buf = (u32)scb->dma_h_bulkdata;
+			*len = (u32)cmd->request_bufflen;
+		}
+		return 0;
+	}
+
+	sgl = (struct scatterlist *)cmd->request_buffer;
+
+	/*
+	 * Copy Scatter-Gather list info into controller structure.
+	 *
+	 * The number of sg elements returned must not exceed our limit
+	 */
+	sgcnt = pci_map_sg(adapter->dev, sgl, cmd->use_sg,
+			scb->dma_direction);
+
+	scb->dma_type = MEGA_SGLIST;
+
+	if( sgcnt > adapter->sglen ) BUG();
+
+	for( idx = 0; idx < sgcnt; idx++, sgl++ ) {
+
+		if( adapter->has_64bit_addr ) {
+			scb->sgl64[idx].address = sg_dma_address(sgl);
+			scb->sgl64[idx].length = sg_dma_len(sgl);
+		}
+		else {
+			scb->sgl[idx].address = sg_dma_address(sgl);
+			scb->sgl[idx].length = sg_dma_len(sgl);
+		}
+	}
+
+	/* Reset pointer and length fields */
+	*buf = scb->sgl_dma_addr;
+
+	/*
+	 * For passthru command, dataxferlen must be set, even for commands
+	 * with a sg list
+	 */
+	*len = (u32)cmd->request_bufflen;
+
+	/* Return count of SG requests */
+	return sgcnt;
+}
+
+
+/*
+ * mega_8_to_40ld()
+ *
+ * takes all info in AdapterInquiry structure and puts it into ProductInfo and
+ * Enquiry3 structures for later use
+ */
+static void
+mega_8_to_40ld(mraid_inquiry *inquiry, mega_inquiry3 *enquiry3,
+		mega_product_info *product_info)
+{
+	int i;
+
+	product_info->max_commands = inquiry->adapter_info.max_commands;
+	enquiry3->rebuild_rate = inquiry->adapter_info.rebuild_rate;
+	product_info->nchannels = inquiry->adapter_info.nchannels;
+
+	for (i = 0; i < 4; i++) {
+		product_info->fw_version[i] =
+			inquiry->adapter_info.fw_version[i];
+
+		product_info->bios_version[i] =
+			inquiry->adapter_info.bios_version[i];
+	}
+	enquiry3->cache_flush_interval =
+		inquiry->adapter_info.cache_flush_interval;
+
+	product_info->dram_size = inquiry->adapter_info.dram_size;
+
+	enquiry3->num_ldrv = inquiry->logdrv_info.num_ldrv;
+
+	for (i = 0; i < MAX_LOGICAL_DRIVES_8LD; i++) {
+		enquiry3->ldrv_size[i] = inquiry->logdrv_info.ldrv_size[i];
+		enquiry3->ldrv_prop[i] = inquiry->logdrv_info.ldrv_prop[i];
+		enquiry3->ldrv_state[i] = inquiry->logdrv_info.ldrv_state[i];
+	}
+
+	for (i = 0; i < (MAX_PHYSICAL_DRIVES); i++)
+		enquiry3->pdrv_state[i] = inquiry->pdrv_info.pdrv_state[i];
+}
+
+static inline void
+mega_free_sgl(adapter_t *adapter)
+{
+	scb_t	*scb;
+	int	i;
+
+	for(i = 0; i < adapter->max_cmds; i++) {
+
+		scb = &adapter->scb_list[i];
+
+		if( scb->sgl64 ) {
+			pci_free_consistent(adapter->dev,
+				sizeof(mega_sgl64) * adapter->sglen,
+				scb->sgl64,
+				scb->sgl_dma_addr);
+
+			scb->sgl64 = NULL;
+		}
+
+		if( scb->pthru ) {
+			pci_free_consistent(adapter->dev, sizeof(mega_passthru),
+				scb->pthru, scb->pthru_dma_addr);
+
+			scb->pthru = NULL;
+		}
+
+		if( scb->epthru ) {
+			pci_free_consistent(adapter->dev,
+				sizeof(mega_ext_passthru),
+				scb->epthru, scb->epthru_dma_addr);
+
+			scb->epthru = NULL;
+		}
+
+	}
+}
+
+
+/*
+ * Get information about the card/driver
+ */
+const char *
+megaraid_info(struct Scsi_Host *host)
+{
+	static char buffer[512];
+	adapter_t *adapter;
+
+	adapter = (adapter_t *)host->hostdata;
+
+	sprintf (buffer,
+		 "LSI Logic MegaRAID %s %d commands %d targs %d chans %d luns",
+		 adapter->fw_version, adapter->product_info.max_commands,
+		 adapter->host->max_id, adapter->host->max_channel,
+		 adapter->host->max_lun);
+	return buffer;
+}
+
+/*
+ * Abort a previous SCSI request. Only commands on the pending list can be
+ * aborted. All the commands issued to the F/W must complete.
+ */
+static int
+megaraid_abort(Scsi_Cmnd *cmd)
+{
+	adapter_t	*adapter;
+	int		rval;
+
+	adapter = (adapter_t *)cmd->device->host->hostdata;
+
+	rval =  megaraid_abort_and_reset(adapter, cmd, SCB_ABORT);
+
+	/*
+	 * This is required here to complete any completed requests
+	 * to be communicated over to the mid layer.
+	 */
+	mega_rundoneq(adapter);
+
+	return rval;
+}
+
+
+static int
+megaraid_reset(Scsi_Cmnd *cmd)
+{
+	adapter_t	*adapter;
+	megacmd_t	mc;
+	int		rval;
+
+	adapter = (adapter_t *)cmd->device->host->hostdata;
+
+#if MEGA_HAVE_CLUSTERING
+	mc.cmd = MEGA_CLUSTER_CMD;
+	mc.opcode = MEGA_RESET_RESERVATIONS;
+
+	spin_unlock_irq(&adapter->lock);
+	if( mega_internal_command(adapter, LOCK_INT, &mc, NULL) != 0 ) {
+		printk(KERN_WARNING
+				"megaraid: reservation reset failed.\n");
+	}
+	else {
+		printk(KERN_INFO "megaraid: reservation reset.\n");
+	}
+	spin_lock_irq(&adapter->lock);
+#endif
+
+	rval =  megaraid_abort_and_reset(adapter, cmd, SCB_RESET);
+
+	/*
+	 * This is required here to complete any completed requests
+	 * to be communicated over to the mid layer.
+	 */
+	mega_rundoneq(adapter);
+
+	return rval;
+}
+
+
+
+/**
+ * megaraid_abort_and_reset()
+ * @adapter - megaraid soft state
+ * @cmd - scsi command to be aborted or reset
+ * @aor - abort or reset flag
+ *
+ * Try to locate the scsi command in the pending queue. If found and is not
+ * issued to the controller, abort/reset it. Otherwise return failure
+ */
+static int
+megaraid_abort_and_reset(adapter_t *adapter, Scsi_Cmnd *cmd, int aor)
+{
+	struct list_head	*pos, *next;
+	scb_t			*scb;
+
+	printk(KERN_WARNING "megaraid: %s-%lx cmd=%x <c=%d t=%d l=%d>\n",
+	     (aor == SCB_ABORT)? "ABORTING":"RESET", cmd->serial_number,
+	     cmd->cmnd[0], cmd->device->channel, 
+	     cmd->device->id, cmd->device->lun);
+
+	if(list_empty(&adapter->pending_list))
+		return FALSE;
+
+	list_for_each_safe(pos, next, &adapter->pending_list) {
+
+		scb = list_entry(pos, scb_t, list);
+
+		if (scb->cmd == cmd) { /* Found command */
+
+			scb->state |= aor;
+
+			/*
+			 * Check if this command has firmare owenership. If
+			 * yes, we cannot reset this command. Whenever, f/w
+			 * completes this command, we will return appropriate
+			 * status from ISR.
+			 */
+			if( scb->state & SCB_ISSUED ) {
+
+				printk(KERN_WARNING
+					"megaraid: %s-%lx[%x], fw owner.\n",
+					(aor==SCB_ABORT) ? "ABORTING":"RESET",
+					cmd->serial_number, scb->idx);
+
+				return FALSE;
+			}
+			else {
+
+				/*
+				 * Not yet issued! Remove from the pending
+				 * list
+				 */
+				printk(KERN_WARNING
+					"megaraid: %s-%lx[%x], driver owner.\n",
+					(aor==SCB_ABORT) ? "ABORTING":"RESET",
+					cmd->serial_number, scb->idx);
+
+				mega_free_scb(adapter, scb);
+
+				if( aor == SCB_ABORT ) {
+					cmd->result = (DID_ABORT << 16);
+				}
+				else {
+					cmd->result = (DID_RESET << 16);
+				}
+
+				list_add_tail(SCSI_LIST(cmd),
+						&adapter->completed_list);
+
+				return TRUE;
+			}
+		}
+	}
+
+	return FALSE;
+}
+
+static inline int
+make_local_pdev(adapter_t *adapter, struct pci_dev **pdev)
+{
+	*pdev = kmalloc(sizeof(struct pci_dev), GFP_KERNEL);
+
+	if( *pdev == NULL ) return -1;
+
+	memcpy(*pdev, adapter->dev, sizeof(struct pci_dev));
+
+	if( pci_set_dma_mask(*pdev, 0xffffffff) != 0 ) {
+		kfree(*pdev);
+		return -1;
+	}
+
+	return 0;
+}
+
+static inline void
+free_local_pdev(struct pci_dev *pdev)
+{
+	kfree(pdev);
+}
+
+/**
+ * mega_allocate_inquiry()
+ * @dma_handle - handle returned for dma address
+ * @pdev - handle to pci device
+ *
+ * allocates memory for inquiry structure
+ */
+static inline void *
+mega_allocate_inquiry(dma_addr_t *dma_handle, struct pci_dev *pdev)
+{
+	return pci_alloc_consistent(pdev, sizeof(mega_inquiry3), dma_handle);
+}
+
+
+static inline void
+mega_free_inquiry(void *inquiry, dma_addr_t dma_handle, struct pci_dev *pdev)
+{
+	pci_free_consistent(pdev, sizeof(mega_inquiry3), inquiry, dma_handle);
+}
+
+
+#ifdef CONFIG_PROC_FS
+/* Following code handles /proc fs  */
+
+#define CREATE_READ_PROC(string, func)	create_proc_read_entry(string,	\
+					S_IRUSR | S_IFREG,		\
+					controller_proc_dir_entry,	\
+					func, adapter)
+
+/**
+ * mega_create_proc_entry()
+ * @index - index in soft state array
+ * @parent - parent node for this /proc entry
+ *
+ * Creates /proc entries for our controllers.
+ */
+static void
+mega_create_proc_entry(int index, struct proc_dir_entry *parent)
+{
+	struct proc_dir_entry	*controller_proc_dir_entry = NULL;
+	u8		string[64] = { 0 };
+	adapter_t	*adapter = hba_soft_state[index];
+
+	sprintf(string, "hba%d", adapter->host->host_no);
+
+	controller_proc_dir_entry =
+		adapter->controller_proc_dir_entry = proc_mkdir(string, parent);
+
+	if(!controller_proc_dir_entry) {
+		printk(KERN_WARNING "\nmegaraid: proc_mkdir failed\n");
+		return;
+	}
+	adapter->proc_read = CREATE_READ_PROC("config", proc_read_config);
+	adapter->proc_stat = CREATE_READ_PROC("stat", proc_read_stat);
+	adapter->proc_mbox = CREATE_READ_PROC("mailbox", proc_read_mbox);
+#if MEGA_HAVE_ENH_PROC
+	adapter->proc_rr = CREATE_READ_PROC("rebuild-rate", proc_rebuild_rate);
+	adapter->proc_battery = CREATE_READ_PROC("battery-status",
+			proc_battery);
+
+	/*
+	 * Display each physical drive on its channel
+	 */
+	adapter->proc_pdrvstat[0] = CREATE_READ_PROC("diskdrives-ch0",
+					proc_pdrv_ch0);
+	adapter->proc_pdrvstat[1] = CREATE_READ_PROC("diskdrives-ch1",
+					proc_pdrv_ch1);
+	adapter->proc_pdrvstat[2] = CREATE_READ_PROC("diskdrives-ch2",
+					proc_pdrv_ch2);
+	adapter->proc_pdrvstat[3] = CREATE_READ_PROC("diskdrives-ch3",
+					proc_pdrv_ch3);
+
+	/*
+	 * Display a set of up to 10 logical drive through each of following
+	 * /proc entries
+	 */
+	adapter->proc_rdrvstat[0] = CREATE_READ_PROC("raiddrives-0-9",
+					proc_rdrv_10);
+	adapter->proc_rdrvstat[1] = CREATE_READ_PROC("raiddrives-10-19",
+					proc_rdrv_20);
+	adapter->proc_rdrvstat[2] = CREATE_READ_PROC("raiddrives-20-29",
+					proc_rdrv_30);
+	adapter->proc_rdrvstat[3] = CREATE_READ_PROC("raiddrives-30-39",
+					proc_rdrv_40);
+#endif
+}
+
+
+/**
+ * proc_read_config()
+ * @page - buffer to write the data in
+ * @start - where the actual data has been written in page
+ * @offset - same meaning as the read system call
+ * @count - same meaning as the read system call
+ * @eof - set if no more data needs to be returned
+ * @data - pointer to our soft state
+ *
+ * Display configuration information about the controller.
+ */
+static int
+proc_read_config(char *page, char **start, off_t offset, int count, int *eof,
+		void *data)
+{
+
+	adapter_t *adapter = (adapter_t *)data;
+	int len = 0;
+
+	len += sprintf(page+len, "%s", MEGARAID_VERSION);
+
+	if(adapter->product_info.product_name[0])
+		len += sprintf(page+len, "%s\n",
+				adapter->product_info.product_name);
+
+	len += sprintf(page+len, "Controller Type: ");
+
+	if( adapter->flag & BOARD_MEMMAP ) {
+		len += sprintf(page+len,
+			"438/466/467/471/493/518/520/531/532\n");
+	}
+	else {
+		len += sprintf(page+len,
+			"418/428/434\n");
+	}
+
+	if(adapter->flag & BOARD_40LD) {
+		len += sprintf(page+len,
+				"Controller Supports 40 Logical Drives\n");
+	}
+
+	if(adapter->flag & BOARD_64BIT) {
+		len += sprintf(page+len,
+		"Controller capable of 64-bit memory addressing\n");
+	}
+	if( adapter->has_64bit_addr ) {
+		len += sprintf(page+len,
+			"Controller using 64-bit memory addressing\n");
+	}
+	else {
+		len += sprintf(page+len,
+			"Controller is not using 64-bit memory addressing\n");
+	}
+
+	len += sprintf(page+len, "Base = %08lx, Irq = %d, ", adapter->base,
+			adapter->host->irq);
+
+	len += sprintf(page+len, "Logical Drives = %d, Channels = %d\n",
+			adapter->numldrv, adapter->product_info.nchannels);
+
+	len += sprintf(page+len, "Version =%s:%s, DRAM = %dMb\n",
+			adapter->fw_version, adapter->bios_version,
+			adapter->product_info.dram_size);
+
+	len += sprintf(page+len,
+		"Controller Queue Depth = %d, Driver Queue Depth = %d\n",
+		adapter->product_info.max_commands, adapter->max_cmds);
+
+	len += sprintf(page+len, "support_ext_cdb    = %d\n",
+			adapter->support_ext_cdb);
+	len += sprintf(page+len, "support_random_del = %d\n",
+			adapter->support_random_del);
+	len += sprintf(page+len, "boot_ldrv_enabled  = %d\n",
+			adapter->boot_ldrv_enabled);
+	len += sprintf(page+len, "boot_ldrv          = %d\n",
+			adapter->boot_ldrv);
+	len += sprintf(page+len, "boot_pdrv_enabled  = %d\n",
+			adapter->boot_pdrv_enabled);
+	len += sprintf(page+len, "boot_pdrv_ch       = %d\n",
+			adapter->boot_pdrv_ch);
+	len += sprintf(page+len, "boot_pdrv_tgt      = %d\n",
+			adapter->boot_pdrv_tgt);
+	len += sprintf(page+len, "quiescent          = %d\n",
+			atomic_read(&adapter->quiescent));
+	len += sprintf(page+len, "has_cluster        = %d\n",
+			adapter->has_cluster);
+
+	len += sprintf(page+len, "\nModule Parameters:\n");
+	len += sprintf(page+len, "max_cmd_per_lun    = %d\n",
+			max_cmd_per_lun);
+	len += sprintf(page+len, "max_sectors_per_io = %d\n",
+			max_sectors_per_io);
+
+	*eof = 1;
+
+	return len;
+}
+
+
+
+/**
+ * proc_read_stat()
+ * @page - buffer to write the data in
+ * @start - where the actual data has been written in page
+ * @offset - same meaning as the read system call
+ * @count - same meaning as the read system call
+ * @eof - set if no more data needs to be returned
+ * @data - pointer to our soft state
+ *
+ * Diaplay statistical information about the I/O activity.
+ */
+static int
+proc_read_stat(char *page, char **start, off_t offset, int count, int *eof,
+		void *data)
+{
+	adapter_t	*adapter;
+	int	len;
+	int	i;
+
+	i = 0;	/* avoid compilation warnings */
+	len = 0;
+	adapter = (adapter_t *)data;
+
+	len = sprintf(page, "Statistical Information for this controller\n");
+	len += sprintf(page+len, "pend_cmds = %d\n",
+			atomic_read(&adapter->pend_cmds));
+#if MEGA_HAVE_STATS
+	for(i = 0; i < adapter->numldrv; i++) {
+		len += sprintf(page+len, "Logical Drive %d:\n", i);
+
+		len += sprintf(page+len,
+			"\tReads Issued = %lu, Writes Issued = %lu\n",
+			adapter->nreads[i], adapter->nwrites[i]);
+
+		len += sprintf(page+len,
+			"\tSectors Read = %lu, Sectors Written = %lu\n",
+			adapter->nreadblocks[i], adapter->nwriteblocks[i]);
+
+		len += sprintf(page+len,
+			"\tRead errors = %lu, Write errors = %lu\n\n",
+			adapter->rd_errors[i], adapter->wr_errors[i]);
+	}
+#else
+	len += sprintf(page+len,
+			"IO and error counters not compiled in driver.\n");
+#endif
+
+	*eof = 1;
+
+	return len;
+}
+
+
+/**
+ * proc_read_mbox()
+ * @page - buffer to write the data in
+ * @start - where the actual data has been written in page
+ * @offset - same meaning as the read system call
+ * @count - same meaning as the read system call
+ * @eof - set if no more data needs to be returned
+ * @data - pointer to our soft state
+ *
+ * Display mailbox information for the last command issued. This information
+ * is good for debugging.
+ */
+static int
+proc_read_mbox(char *page, char **start, off_t offset, int count, int *eof,
+		void *data)
+{
+
+	adapter_t	*adapter = (adapter_t *)data;
+	volatile mbox_t	*mbox = adapter->mbox;
+	int	len = 0;
+
+	len = sprintf(page, "Contents of Mail Box Structure\n");
+	len += sprintf(page+len, "  Fw Command   = 0x%02x\n", 
+			mbox->m_out.cmd);
+	len += sprintf(page+len, "  Cmd Sequence = 0x%02x\n", 
+			mbox->m_out.cmdid);
+	len += sprintf(page+len, "  No of Sectors= %04d\n", 
+			mbox->m_out.numsectors);
+	len += sprintf(page+len, "  LBA          = 0x%02x\n", 
+			mbox->m_out.lba);
+	len += sprintf(page+len, "  DTA          = 0x%08x\n", 
+			mbox->m_out.xferaddr);
+	len += sprintf(page+len, "  Logical Drive= 0x%02x\n", 
+			mbox->m_out.logdrv);
+	len += sprintf(page+len, "  No of SG Elmt= 0x%02x\n",
+			mbox->m_out.numsgelements);
+	len += sprintf(page+len, "  Busy         = %01x\n", 
+			mbox->m_in.busy);
+	len += sprintf(page+len, "  Status       = 0x%02x\n", 
+			mbox->m_in.status);
+
+	*eof = 1;
+
+	return len;
+}
+
+
+/**
+ * proc_rebuild_rate()
+ * @page - buffer to write the data in
+ * @start - where the actual data has been written in page
+ * @offset - same meaning as the read system call
+ * @count - same meaning as the read system call
+ * @eof - set if no more data needs to be returned
+ * @data - pointer to our soft state
+ *
+ * Display current rebuild rate
+ */
+static int
+proc_rebuild_rate(char *page, char **start, off_t offset, int count, int *eof,
+		void *data)
+{
+	adapter_t	*adapter = (adapter_t *)data;
+	dma_addr_t	dma_handle;
+	caddr_t		inquiry;
+	struct pci_dev	*pdev;
+	int	len = 0;
+
+	if( make_local_pdev(adapter, &pdev) != 0 ) {
+		*eof = 1;
+		return len;
+	}
+
+	if( (inquiry = mega_allocate_inquiry(&dma_handle, pdev)) == NULL ) {
+		free_local_pdev(pdev);
+		*eof = 1;
+		return len;
+	}
+
+	if( mega_adapinq(adapter, dma_handle) != 0 ) {
+
+		len = sprintf(page, "Adapter inquiry failed.\n");
+
+		printk(KERN_WARNING "megaraid: inquiry failed.\n");
+
+		mega_free_inquiry(inquiry, dma_handle, pdev);
+
+		free_local_pdev(pdev);
+
+		*eof = 1;
+
+		return len;
+	}
+
+	if( adapter->flag & BOARD_40LD ) {
+		len = sprintf(page, "Rebuild Rate: [%d%%]\n",
+			((mega_inquiry3 *)inquiry)->rebuild_rate);
+	}
+	else {
+		len = sprintf(page, "Rebuild Rate: [%d%%]\n",
+			((mraid_ext_inquiry *)
+			inquiry)->raid_inq.adapter_info.rebuild_rate);
+	}
+
+
+	mega_free_inquiry(inquiry, dma_handle, pdev);
+
+	free_local_pdev(pdev);
+
+	*eof = 1;
+
+	return len;
+}
+
+
+/**
+ * proc_battery()
+ * @page - buffer to write the data in
+ * @start - where the actual data has been written in page
+ * @offset - same meaning as the read system call
+ * @count - same meaning as the read system call
+ * @eof - set if no more data needs to be returned
+ * @data - pointer to our soft state
+ *
+ * Display information about the battery module on the controller.
+ */
+static int
+proc_battery(char *page, char **start, off_t offset, int count, int *eof,
+		void *data)
+{
+	adapter_t	*adapter = (adapter_t *)data;
+	dma_addr_t	dma_handle;
+	caddr_t		inquiry;
+	struct pci_dev	*pdev;
+	u8	battery_status = 0;
+	char	str[256];
+	int	len = 0;
+
+	if( make_local_pdev(adapter, &pdev) != 0 ) {
+		*eof = 1;
+		return len;
+	}
+
+	if( (inquiry = mega_allocate_inquiry(&dma_handle, pdev)) == NULL ) {
+		free_local_pdev(pdev);
+		*eof = 1;
+		return len;
+	}
+
+	if( mega_adapinq(adapter, dma_handle) != 0 ) {
+
+		len = sprintf(page, "Adapter inquiry failed.\n");
+
+		printk(KERN_WARNING "megaraid: inquiry failed.\n");
+
+		mega_free_inquiry(inquiry, dma_handle, pdev);
+
+		free_local_pdev(pdev);
+
+		*eof = 1;
+
+		return len;
+	}
+
+	if( adapter->flag & BOARD_40LD ) {
+		battery_status = ((mega_inquiry3 *)inquiry)->battery_status;
+	}
+	else {
+		battery_status = ((mraid_ext_inquiry *)inquiry)->
+			raid_inq.adapter_info.battery_status;
+	}
+
+	/*
+	 * Decode the battery status
+	 */
+	sprintf(str, "Battery Status:[%d]", battery_status);
+
+	if(battery_status == MEGA_BATT_CHARGE_DONE)
+		strcat(str, " Charge Done");
+
+	if(battery_status & MEGA_BATT_MODULE_MISSING)
+		strcat(str, " Module Missing");
+	
+	if(battery_status & MEGA_BATT_LOW_VOLTAGE)
+		strcat(str, " Low Voltage");
+	
+	if(battery_status & MEGA_BATT_TEMP_HIGH)
+		strcat(str, " Temperature High");
+	
+	if(battery_status & MEGA_BATT_PACK_MISSING)
+		strcat(str, " Pack Missing");
+	
+	if(battery_status & MEGA_BATT_CHARGE_INPROG)
+		strcat(str, " Charge In-progress");
+	
+	if(battery_status & MEGA_BATT_CHARGE_FAIL)
+		strcat(str, " Charge Fail");
+	
+	if(battery_status & MEGA_BATT_CYCLES_EXCEEDED)
+		strcat(str, " Cycles Exceeded");
+
+	len = sprintf(page, "%s\n", str);
+
+
+	mega_free_inquiry(inquiry, dma_handle, pdev);
+
+	free_local_pdev(pdev);
+
+	*eof = 1;
+
+	return len;
+}
+
+
+/**
+ * proc_pdrv_ch0()
+ * @page - buffer to write the data in
+ * @start - where the actual data has been written in page
+ * @offset - same meaning as the read system call
+ * @count - same meaning as the read system call
+ * @eof - set if no more data needs to be returned
+ * @data - pointer to our soft state
+ *
+ * Display information about the physical drives on physical channel 0.
+ */
+static int
+proc_pdrv_ch0(char *page, char **start, off_t offset, int count, int *eof,
+		void *data)
+{
+	adapter_t *adapter = (adapter_t *)data;
+
+	*eof = 1;
+
+	return (proc_pdrv(adapter, page, 0));
+}
+
+
+/**
+ * proc_pdrv_ch1()
+ * @page - buffer to write the data in
+ * @start - where the actual data has been written in page
+ * @offset - same meaning as the read system call
+ * @count - same meaning as the read system call
+ * @eof - set if no more data needs to be returned
+ * @data - pointer to our soft state
+ *
+ * Display information about the physical drives on physical channel 1.
+ */
+static int
+proc_pdrv_ch1(char *page, char **start, off_t offset, int count, int *eof,
+		void *data)
+{
+	adapter_t *adapter = (adapter_t *)data;
+
+	*eof = 1;
+
+	return (proc_pdrv(adapter, page, 1));
+}
+
+
+/**
+ * proc_pdrv_ch2()
+ * @page - buffer to write the data in
+ * @start - where the actual data has been written in page
+ * @offset - same meaning as the read system call
+ * @count - same meaning as the read system call
+ * @eof - set if no more data needs to be returned
+ * @data - pointer to our soft state
+ *
+ * Display information about the physical drives on physical channel 2.
+ */
+static int
+proc_pdrv_ch2(char *page, char **start, off_t offset, int count, int *eof,
+		void *data)
+{
+	adapter_t *adapter = (adapter_t *)data;
+
+	*eof = 1;
+
+	return (proc_pdrv(adapter, page, 2));
+}
+
+
+/**
+ * proc_pdrv_ch3()
+ * @page - buffer to write the data in
+ * @start - where the actual data has been written in page
+ * @offset - same meaning as the read system call
+ * @count - same meaning as the read system call
+ * @eof - set if no more data needs to be returned
+ * @data - pointer to our soft state
+ *
+ * Display information about the physical drives on physical channel 3.
+ */
+static int
+proc_pdrv_ch3(char *page, char **start, off_t offset, int count, int *eof,
+		void *data)
+{
+	adapter_t *adapter = (adapter_t *)data;
+
+	*eof = 1;
+
+	return (proc_pdrv(adapter, page, 3));
+}
+
+
+/**
+ * proc_pdrv()
+ * @page - buffer to write the data in
+ * @adapter - pointer to our soft state
+ *
+ * Display information about the physical drives.
+ */
+static int
+proc_pdrv(adapter_t *adapter, char *page, int channel)
+{
+	dma_addr_t	dma_handle;
+	char		*scsi_inq;
+	dma_addr_t	scsi_inq_dma_handle;
+	caddr_t		inquiry;
+	struct pci_dev	*pdev;
+	u8	*pdrv_state;
+	u8	state;
+	int	tgt;
+	int	max_channels;
+	int	len = 0;
+	char	str[80];
+	int	i;
+
+	if( make_local_pdev(adapter, &pdev) != 0 ) {
+		return len;
+	}
+
+	if( (inquiry = mega_allocate_inquiry(&dma_handle, pdev)) == NULL ) {
+		goto free_pdev;
+	}
+
+	if( mega_adapinq(adapter, dma_handle) != 0 ) {
+		len = sprintf(page, "Adapter inquiry failed.\n");
+
+		printk(KERN_WARNING "megaraid: inquiry failed.\n");
+
+		goto free_inquiry;
+	}
+
+
+	scsi_inq = pci_alloc_consistent(pdev, 256, &scsi_inq_dma_handle);
+
+	if( scsi_inq == NULL ) {
+		len = sprintf(page, "memory not available for scsi inq.\n");
+
+		goto free_inquiry;
+	}
+
+	if( adapter->flag & BOARD_40LD ) {
+		pdrv_state = ((mega_inquiry3 *)inquiry)->pdrv_state;
+	}
+	else {
+		pdrv_state = ((mraid_ext_inquiry *)inquiry)->
+			raid_inq.pdrv_info.pdrv_state;
+	}
+
+	max_channels = adapter->product_info.nchannels;
+
+	if( channel >= max_channels ) {
+		goto free_pci;
+	}
+
+	for( tgt = 0; tgt <= MAX_TARGET; tgt++ ) {
+
+		i = channel*16 + tgt;
+
+		state = *(pdrv_state + i);
+
+		switch( state & 0x0F ) {
+
+		case PDRV_ONLINE:
+			sprintf(str,
+			"Channel:%2d Id:%2d State: Online",
+				channel, tgt);
+			break;
+
+		case PDRV_FAILED:
+			sprintf(str,
+			"Channel:%2d Id:%2d State: Failed",
+				channel, tgt);
+			break;
+
+		case PDRV_RBLD:
+			sprintf(str,
+			"Channel:%2d Id:%2d State: Rebuild",
+				channel, tgt);
+			break;
+
+		case PDRV_HOTSPARE:
+			sprintf(str,
+			"Channel:%2d Id:%2d State: Hot spare",
+				channel, tgt);
+			break;
+
+		default:
+			sprintf(str,
+			"Channel:%2d Id:%2d State: Un-configured",
+				channel, tgt);
+			break;
+
+		}
+
+		/*
+		 * This interface displays inquiries for disk drives
+		 * only. Inquries for logical drives and non-disk
+		 * devices are available through /proc/scsi/scsi
+		 */
+		memset(scsi_inq, 0, 256);
+		if( mega_internal_dev_inquiry(adapter, channel, tgt,
+				scsi_inq_dma_handle) ||
+				(scsi_inq[0] & 0x1F) != TYPE_DISK ) {
+			continue;
+		}
+
+		/*
+		 * Check for overflow. We print less than 240
+		 * characters for inquiry
+		 */
+		if( (len + 240) >= PAGE_SIZE ) break;
+
+		len += sprintf(page+len, "%s.\n", str);
+
+		len += mega_print_inquiry(page+len, scsi_inq);
+	}
+
+free_pci:
+	pci_free_consistent(pdev, 256, scsi_inq, scsi_inq_dma_handle);
+free_inquiry:
+	mega_free_inquiry(inquiry, dma_handle, pdev);
+free_pdev:
+	free_local_pdev(pdev);
+
+	return len;
+}
+
+
+/*
+ * Display scsi inquiry
+ */
+static int
+mega_print_inquiry(char *page, char *scsi_inq)
+{
+	int	len = 0;
+	int	i;
+
+	len = sprintf(page, "  Vendor: ");
+	for( i = 8; i < 16; i++ ) {
+		len += sprintf(page+len, "%c", scsi_inq[i]);
+	}
+
+	len += sprintf(page+len, "  Model: ");
+
+	for( i = 16; i < 32; i++ ) {
+		len += sprintf(page+len, "%c", scsi_inq[i]);
+	}
+
+	len += sprintf(page+len, "  Rev: ");
+
+	for( i = 32; i < 36; i++ ) {
+		len += sprintf(page+len, "%c", scsi_inq[i]);
+	}
+
+	len += sprintf(page+len, "\n");
+
+	i = scsi_inq[0] & 0x1f;
+
+	len += sprintf(page+len, "  Type:   %s ",
+		i < MAX_SCSI_DEVICE_CODE ? scsi_device_types[i] :
+		   "Unknown          ");
+
+	len += sprintf(page+len,
+	"                 ANSI SCSI revision: %02x", scsi_inq[2] & 0x07);
+
+	if( (scsi_inq[2] & 0x07) == 1 && (scsi_inq[3] & 0x0f) == 1 )
+		len += sprintf(page+len, " CCS\n");
+	else
+		len += sprintf(page+len, "\n");
+
+	return len;
+}
+
+
+/**
+ * proc_rdrv_10()
+ * @page - buffer to write the data in
+ * @start - where the actual data has been written in page
+ * @offset - same meaning as the read system call
+ * @count - same meaning as the read system call
+ * @eof - set if no more data needs to be returned
+ * @data - pointer to our soft state
+ *
+ * Display real time information about the logical drives 0 through 9.
+ */
+static int
+proc_rdrv_10(char *page, char **start, off_t offset, int count, int *eof,
+		void *data)
+{
+	adapter_t *adapter = (adapter_t *)data;
+
+	*eof = 1;
+
+	return (proc_rdrv(adapter, page, 0, 9));
+}
+
+
+/**
+ * proc_rdrv_20()
+ * @page - buffer to write the data in
+ * @start - where the actual data has been written in page
+ * @offset - same meaning as the read system call
+ * @count - same meaning as the read system call
+ * @eof - set if no more data needs to be returned
+ * @data - pointer to our soft state
+ *
+ * Display real time information about the logical drives 0 through 9.
+ */
+static int
+proc_rdrv_20(char *page, char **start, off_t offset, int count, int *eof,
+		void *data)
+{
+	adapter_t *adapter = (adapter_t *)data;
+
+	*eof = 1;
+
+	return (proc_rdrv(adapter, page, 10, 19));
+}
+
+
+/**
+ * proc_rdrv_30()
+ * @page - buffer to write the data in
+ * @start - where the actual data has been written in page
+ * @offset - same meaning as the read system call
+ * @count - same meaning as the read system call
+ * @eof - set if no more data needs to be returned
+ * @data - pointer to our soft state
+ *
+ * Display real time information about the logical drives 0 through 9.
+ */
+static int
+proc_rdrv_30(char *page, char **start, off_t offset, int count, int *eof,
+		void *data)
+{
+	adapter_t *adapter = (adapter_t *)data;
+
+	*eof = 1;
+
+	return (proc_rdrv(adapter, page, 20, 29));
+}
+
+
+/**
+ * proc_rdrv_40()
+ * @page - buffer to write the data in
+ * @start - where the actual data has been written in page
+ * @offset - same meaning as the read system call
+ * @count - same meaning as the read system call
+ * @eof - set if no more data needs to be returned
+ * @data - pointer to our soft state
+ *
+ * Display real time information about the logical drives 0 through 9.
+ */
+static int
+proc_rdrv_40(char *page, char **start, off_t offset, int count, int *eof,
+		void *data)
+{
+	adapter_t *adapter = (adapter_t *)data;
+
+	*eof = 1;
+
+	return (proc_rdrv(adapter, page, 30, 39));
+}
+
+
+/**
+ * proc_rdrv()
+ * @page - buffer to write the data in
+ * @adapter - pointer to our soft state
+ * @start - starting logical drive to display
+ * @end - ending logical drive to display
+ *
+ * We do not print the inquiry information since its already available through
+ * /proc/scsi/scsi interface
+ */
+static int
+proc_rdrv(adapter_t *adapter, char *page, int start, int end )
+{
+	dma_addr_t	dma_handle;
+	logdrv_param	*lparam;
+	megacmd_t	mc;
+	char		*disk_array;
+	dma_addr_t	disk_array_dma_handle;
+	caddr_t		inquiry;
+	struct pci_dev	*pdev;
+	u8	*rdrv_state;
+	int	num_ldrv;
+	u32	array_sz;
+	int	len = 0;
+	int	i;
+
+	if( make_local_pdev(adapter, &pdev) != 0 ) {
+		return len;
+	}
+
+	if( (inquiry = mega_allocate_inquiry(&dma_handle, pdev)) == NULL ) {
+		free_local_pdev(pdev);
+		return len;
+	}
+
+	if( mega_adapinq(adapter, dma_handle) != 0 ) {
+
+		len = sprintf(page, "Adapter inquiry failed.\n");
+
+		printk(KERN_WARNING "megaraid: inquiry failed.\n");
+
+		mega_free_inquiry(inquiry, dma_handle, pdev);
+
+		free_local_pdev(pdev);
+
+		return len;
+	}
+
+	memset(&mc, 0, sizeof(megacmd_t));
+
+	if( adapter->flag & BOARD_40LD ) {
+		array_sz = sizeof(disk_array_40ld);
+
+		rdrv_state = ((mega_inquiry3 *)inquiry)->ldrv_state;
+
+		num_ldrv = ((mega_inquiry3 *)inquiry)->num_ldrv;
+	}
+	else {
+		array_sz = sizeof(disk_array_8ld);
+
+		rdrv_state = ((mraid_ext_inquiry *)inquiry)->
+			raid_inq.logdrv_info.ldrv_state;
+
+		num_ldrv = ((mraid_ext_inquiry *)inquiry)->
+			raid_inq.logdrv_info.num_ldrv;
+	}
+
+	disk_array = pci_alloc_consistent(pdev, array_sz,
+			&disk_array_dma_handle);
+
+	if( disk_array == NULL ) {
+		len = sprintf(page, "memory not available.\n");
+
+		mega_free_inquiry(inquiry, dma_handle, pdev);
+
+		free_local_pdev(pdev);
+
+		return len;
+	}
+
+	mc.xferaddr = (u32)disk_array_dma_handle;
+
+	if( adapter->flag & BOARD_40LD ) {
+		mc.cmd = FC_NEW_CONFIG;
+		mc.opcode = OP_DCMD_READ_CONFIG;
+
+		if( mega_internal_command(adapter, LOCK_INT, &mc, NULL) ) {
+
+			len = sprintf(page, "40LD read config failed.\n");
+
+			mega_free_inquiry(inquiry, dma_handle, pdev);
+
+			pci_free_consistent(pdev, array_sz, disk_array,
+					disk_array_dma_handle);
+
+			free_local_pdev(pdev);
+
+			return len;
+		}
+
+	}
+	else {
+		mc.cmd = NEW_READ_CONFIG_8LD;
+
+		if( mega_internal_command(adapter, LOCK_INT, &mc, NULL) ) {
+
+			mc.cmd = READ_CONFIG_8LD;
+
+			if( mega_internal_command(adapter, LOCK_INT, &mc,
+						NULL) ){
+
+				len = sprintf(page,
+					"8LD read config failed.\n");
+
+				mega_free_inquiry(inquiry, dma_handle, pdev);
+
+				pci_free_consistent(pdev, array_sz,
+						disk_array,
+						disk_array_dma_handle);
+
+				free_local_pdev(pdev);
+
+				return len;
+			}
+		}
+	}
+
+	for( i = start; i < ( (end+1 < num_ldrv) ? end+1 : num_ldrv ); i++ ) {
+
+		if( adapter->flag & BOARD_40LD ) {
+			lparam =
+			&((disk_array_40ld *)disk_array)->ldrv[i].lparam;
+		}
+		else {
+			lparam =
+			&((disk_array_8ld *)disk_array)->ldrv[i].lparam;
+		}
+
+		/*
+		 * Check for overflow. We print less than 240 characters for
+		 * information about each logical drive.
+		 */
+		if( (len + 240) >= PAGE_SIZE ) break;
+
+		len += sprintf(page+len, "Logical drive:%2d:, ", i);
+
+		switch( rdrv_state[i] & 0x0F ) {
+		case RDRV_OFFLINE:
+			len += sprintf(page+len, "state: offline");
+			break;
+
+		case RDRV_DEGRADED:
+			len += sprintf(page+len, "state: degraded");
+			break;
+
+		case RDRV_OPTIMAL:
+			len += sprintf(page+len, "state: optimal");
+			break;
+
+		case RDRV_DELETED:
+			len += sprintf(page+len, "state: deleted");
+			break;
+
+		default:
+			len += sprintf(page+len, "state: unknown");
+			break;
+		}
+
+		/*
+		 * Check if check consistency or initialization is going on
+		 * for this logical drive.
+		 */
+		if( (rdrv_state[i] & 0xF0) == 0x20 ) {
+			len += sprintf(page+len,
+					", check-consistency in progress");
+		}
+		else if( (rdrv_state[i] & 0xF0) == 0x10 ) {
+			len += sprintf(page+len,
+					", initialization in progress");
+		}
+		
+		len += sprintf(page+len, "\n");
+
+		len += sprintf(page+len, "Span depth:%3d, ",
+				lparam->span_depth);
+
+		len += sprintf(page+len, "RAID level:%3d, ",
+				lparam->level);
+
+		len += sprintf(page+len, "Stripe size:%3d, ",
+				lparam->stripe_sz ? lparam->stripe_sz/2: 128);
+
+		len += sprintf(page+len, "Row size:%3d\n",
+				lparam->row_size);
+
+
+		len += sprintf(page+len, "Read Policy: ");
+
+		switch(lparam->read_ahead) {
+
+		case NO_READ_AHEAD:
+			len += sprintf(page+len, "No read ahead, ");
+			break;
+
+		case READ_AHEAD:
+			len += sprintf(page+len, "Read ahead, ");
+			break;
+
+		case ADAP_READ_AHEAD:
+			len += sprintf(page+len, "Adaptive, ");
+			break;
+
+		}
+
+		len += sprintf(page+len, "Write Policy: ");
+
+		switch(lparam->write_mode) {
+
+		case WRMODE_WRITE_THRU:
+			len += sprintf(page+len, "Write thru, ");
+			break;
+
+		case WRMODE_WRITE_BACK:
+			len += sprintf(page+len, "Write back, ");
+			break;
+		}
+
+		len += sprintf(page+len, "Cache Policy: ");
+
+		switch(lparam->direct_io) {
+
+		case CACHED_IO:
+			len += sprintf(page+len, "Cached IO\n\n");
+			break;
+
+		case DIRECT_IO:
+			len += sprintf(page+len, "Direct IO\n\n");
+			break;
+		}
+	}
+
+	mega_free_inquiry(inquiry, dma_handle, pdev);
+
+	pci_free_consistent(pdev, array_sz, disk_array,
+			disk_array_dma_handle);
+
+	free_local_pdev(pdev);
+
+	return len;
+}
+
+#endif
+
+
+/**
+ * megaraid_biosparam()
+ *
+ * Return the disk geometry for a particular disk
+ */
+static int
+megaraid_biosparam(struct scsi_device *sdev, struct block_device *bdev,
+		    sector_t capacity, int geom[])
+{
+	adapter_t	*adapter;
+	unsigned char	*bh;
+	int	heads;
+	int	sectors;
+	int	cylinders;
+	int	rval;
+
+	/* Get pointer to host config structure */
+	adapter = (adapter_t *)sdev->host->hostdata;
+
+	if (IS_RAID_CH(adapter, sdev->channel)) {
+			/* Default heads (64) & sectors (32) */
+			heads = 64;
+			sectors = 32;
+			cylinders = (ulong)capacity / (heads * sectors);
+
+			/*
+			 * Handle extended translation size for logical drives
+			 * > 1Gb
+			 */
+			if ((ulong)capacity >= 0x200000) {
+				heads = 255;
+				sectors = 63;
+				cylinders = (ulong)capacity / (heads * sectors);
+			}
+
+			/* return result */
+			geom[0] = heads;
+			geom[1] = sectors;
+			geom[2] = cylinders;
+	}
+	else {
+		bh = scsi_bios_ptable(bdev);
+
+		if( bh ) {
+			rval = scsi_partsize(bh, capacity,
+					    &geom[2], &geom[0], &geom[1]);
+			kfree(bh);
+			if( rval != -1 )
+				return rval;
+		}
+
+		printk(KERN_INFO
+		"megaraid: invalid partition on this disk on channel %d\n",
+				sdev->channel);
+
+		/* Default heads (64) & sectors (32) */
+		heads = 64;
+		sectors = 32;
+		cylinders = (ulong)capacity / (heads * sectors);
+
+		/* Handle extended translation size for logical drives > 1Gb */
+		if ((ulong)capacity >= 0x200000) {
+			heads = 255;
+			sectors = 63;
+			cylinders = (ulong)capacity / (heads * sectors);
+		}
+
+		/* return result */
+		geom[0] = heads;
+		geom[1] = sectors;
+		geom[2] = cylinders;
+	}
+
+	return 0;
+}
+
+/**
+ * mega_init_scb()
+ * @adapter - pointer to our soft state
+ *
+ * Allocate memory for the various pointers in the scb structures:
+ * scatter-gather list pointer, passthru and extended passthru structure
+ * pointers.
+ */
+static int
+mega_init_scb(adapter_t *adapter)
+{
+	scb_t	*scb;
+	int	i;
+
+	for( i = 0; i < adapter->max_cmds; i++ ) {
+
+		scb = &adapter->scb_list[i];
+
+		scb->sgl64 = NULL;
+		scb->sgl = NULL;
+		scb->pthru = NULL;
+		scb->epthru = NULL;
+	}
+
+	for( i = 0; i < adapter->max_cmds; i++ ) {
+
+		scb = &adapter->scb_list[i];
+
+		scb->idx = i;
+
+		scb->sgl64 = pci_alloc_consistent(adapter->dev,
+				sizeof(mega_sgl64) * adapter->sglen,
+				&scb->sgl_dma_addr);
+
+		scb->sgl = (mega_sglist *)scb->sgl64;
+
+		if( !scb->sgl ) {
+			printk(KERN_WARNING "RAID: Can't allocate sglist.\n");
+			mega_free_sgl(adapter);
+			return -1;
+		}
+
+		scb->pthru = pci_alloc_consistent(adapter->dev,
+				sizeof(mega_passthru),
+				&scb->pthru_dma_addr);
+
+		if( !scb->pthru ) {
+			printk(KERN_WARNING "RAID: Can't allocate passthru.\n");
+			mega_free_sgl(adapter);
+			return -1;
+		}
+
+		scb->epthru = pci_alloc_consistent(adapter->dev,
+				sizeof(mega_ext_passthru),
+				&scb->epthru_dma_addr);
+
+		if( !scb->epthru ) {
+			printk(KERN_WARNING
+				"Can't allocate extended passthru.\n");
+			mega_free_sgl(adapter);
+			return -1;
+		}
+
+
+		scb->dma_type = MEGA_DMA_TYPE_NONE;
+
+		/*
+		 * Link to free list
+		 * lock not required since we are loading the driver, so no
+		 * commands possible right now.
+		 */
+		scb->state = SCB_FREE;
+		scb->cmd = NULL;
+		list_add(&scb->list, &adapter->free_list);
+	}
+
+	return 0;
+}
+
+
+/**
+ * megadev_open()
+ * @inode - unused
+ * @filep - unused
+ *
+ * Routines for the character/ioctl interface to the driver. Find out if this
+ * is a valid open. If yes, increment the module use count so that it cannot
+ * be unloaded.
+ */
+static int
+megadev_open (struct inode *inode, struct file *filep)
+{
+	/*
+	 * Only allow superuser to access private ioctl interface
+	 */
+	if( !capable(CAP_SYS_ADMIN) ) return -EACCES;
+
+	return 0;
+}
+
+
+/**
+ * megadev_ioctl()
+ * @inode - Our device inode
+ * @filep - unused
+ * @cmd - ioctl command
+ * @arg - user buffer
+ *
+ * ioctl entry point for our private ioctl interface. We move the data in from
+ * the user space, prepare the command (if necessary, convert the old MIMD
+ * ioctl to new ioctl command), and issue a synchronous command to the
+ * controller.
+ */
+static int
+megadev_ioctl(struct inode *inode, struct file *filep, unsigned int cmd,
+		unsigned long arg)
+{
+	adapter_t	*adapter;
+	nitioctl_t	uioc;
+	int		adapno;
+	int		rval;
+	mega_passthru	__user *upthru;	/* user address for passthru */
+	mega_passthru	*pthru;		/* copy user passthru here */
+	dma_addr_t	pthru_dma_hndl;
+	void		*data = NULL;	/* data to be transferred */
+	dma_addr_t	data_dma_hndl;	/* dma handle for data xfer area */
+	megacmd_t	mc;
+	megastat_t	__user *ustats;
+	int		num_ldrv;
+	u32		uxferaddr = 0;
+	struct pci_dev	*pdev;
+
+	ustats = NULL; /* avoid compilation warnings */
+	num_ldrv = 0;
+
+	/*
+	 * Make sure only USCSICMD are issued through this interface.
+	 * MIMD application would still fire different command.
+	 */
+	if( (_IOC_TYPE(cmd) != MEGAIOC_MAGIC) && (cmd != USCSICMD) ) {
+		return -EINVAL;
+	}
+
+	/*
+	 * Check and convert a possible MIMD command to NIT command.
+	 * mega_m_to_n() copies the data from the user space, so we do not
+	 * have to do it here.
+	 * NOTE: We will need some user address to copyout the data, therefore
+	 * the inteface layer will also provide us with the required user
+	 * addresses.
+	 */
+	memset(&uioc, 0, sizeof(nitioctl_t));
+	if( (rval = mega_m_to_n( (void __user *)arg, &uioc)) != 0 )
+		return rval;
+
+
+	switch( uioc.opcode ) {
+
+	case GET_DRIVER_VER:
+		if( put_user(driver_ver, (u32 __user *)uioc.uioc_uaddr) )
+			return (-EFAULT);
+
+		break;
+
+	case GET_N_ADAP:
+		if( put_user(hba_count, (u32 __user *)uioc.uioc_uaddr) )
+			return (-EFAULT);
+
+		/*
+		 * Shucks. MIMD interface returns a positive value for number
+		 * of adapters. TODO: Change it to return 0 when there is no
+		 * applicatio using mimd interface.
+		 */
+		return hba_count;
+
+	case GET_ADAP_INFO:
+
+		/*
+		 * Which adapter
+		 */
+		if( (adapno = GETADAP(uioc.adapno)) >= hba_count )
+			return (-ENODEV);
+
+		if( copy_to_user(uioc.uioc_uaddr, mcontroller+adapno,
+				sizeof(struct mcontroller)) )
+			return (-EFAULT);
+		break;
+
+#if MEGA_HAVE_STATS
+
+	case GET_STATS:
+		/*
+		 * Which adapter
+		 */
+		if( (adapno = GETADAP(uioc.adapno)) >= hba_count )
+			return (-ENODEV);
+
+		adapter = hba_soft_state[adapno];
+
+		ustats = uioc.uioc_uaddr;
+
+		if( copy_from_user(&num_ldrv, &ustats->num_ldrv, sizeof(int)) )
+			return (-EFAULT);
+
+		/*
+		 * Check for the validity of the logical drive number
+		 */
+		if( num_ldrv >= MAX_LOGICAL_DRIVES_40LD ) return -EINVAL;
+
+		if( copy_to_user(ustats->nreads, adapter->nreads,
+					num_ldrv*sizeof(u32)) )
+			return -EFAULT;
+
+		if( copy_to_user(ustats->nreadblocks, adapter->nreadblocks,
+					num_ldrv*sizeof(u32)) )
+			return -EFAULT;
+
+		if( copy_to_user(ustats->nwrites, adapter->nwrites,
+					num_ldrv*sizeof(u32)) )
+			return -EFAULT;
+
+		if( copy_to_user(ustats->nwriteblocks, adapter->nwriteblocks,
+					num_ldrv*sizeof(u32)) )
+			return -EFAULT;
+
+		if( copy_to_user(ustats->rd_errors, adapter->rd_errors,
+					num_ldrv*sizeof(u32)) )
+			return -EFAULT;
+
+		if( copy_to_user(ustats->wr_errors, adapter->wr_errors,
+					num_ldrv*sizeof(u32)) )
+			return -EFAULT;
+
+		return 0;
+
+#endif
+	case MBOX_CMD:
+
+		/*
+		 * Which adapter
+		 */
+		if( (adapno = GETADAP(uioc.adapno)) >= hba_count )
+			return (-ENODEV);
+
+		adapter = hba_soft_state[adapno];
+
+		/*
+		 * Deletion of logical drive is a special case. The adapter
+		 * should be quiescent before this command is issued.
+		 */
+		if( uioc.uioc_rmbox[0] == FC_DEL_LOGDRV &&
+				uioc.uioc_rmbox[2] == OP_DEL_LOGDRV ) {
+
+			/*
+			 * Do we support this feature
+			 */
+			if( !adapter->support_random_del ) {
+				printk(KERN_WARNING "megaraid: logdrv ");
+				printk("delete on non-supporting F/W.\n");
+
+				return (-EINVAL);
+			}
+
+			rval = mega_del_logdrv( adapter, uioc.uioc_rmbox[3] );
+
+			if( rval == 0 ) {
+				memset(&mc, 0, sizeof(megacmd_t));
+
+				mc.status = rval;
+
+				rval = mega_n_to_m((void __user *)arg, &mc);
+			}
+
+			return rval;
+		}
+		/*
+		 * This interface only support the regular passthru commands.
+		 * Reject extended passthru and 64-bit passthru
+		 */
+		if( uioc.uioc_rmbox[0] == MEGA_MBOXCMD_PASSTHRU64 ||
+			uioc.uioc_rmbox[0] == MEGA_MBOXCMD_EXTPTHRU ) {
+
+			printk(KERN_WARNING "megaraid: rejected passthru.\n");
+
+			return (-EINVAL);
+		}
+
+		/*
+		 * For all internal commands, the buffer must be allocated in
+		 * <4GB address range
+		 */
+		if( make_local_pdev(adapter, &pdev) != 0 )
+			return -EIO;
+
+		/* Is it a passthru command or a DCMD */
+		if( uioc.uioc_rmbox[0] == MEGA_MBOXCMD_PASSTHRU ) {
+			/* Passthru commands */
+
+			pthru = pci_alloc_consistent(pdev,
+					sizeof(mega_passthru),
+					&pthru_dma_hndl);
+
+			if( pthru == NULL ) {
+				free_local_pdev(pdev);
+				return (-ENOMEM);
+			}
+
+			/*
+			 * The user passthru structure
+			 */
+			upthru = (mega_passthru __user *)MBOX(uioc)->xferaddr;
+
+			/*
+			 * Copy in the user passthru here.
+			 */
+			if( copy_from_user(pthru, upthru,
+						sizeof(mega_passthru)) ) {
+
+				pci_free_consistent(pdev,
+						sizeof(mega_passthru), pthru,
+						pthru_dma_hndl);
+
+				free_local_pdev(pdev);
+
+				return (-EFAULT);
+			}
+
+			/*
+			 * Is there a data transfer
+			 */
+			if( pthru->dataxferlen ) {
+				data = pci_alloc_consistent(pdev,
+						pthru->dataxferlen,
+						&data_dma_hndl);
+
+				if( data == NULL ) {
+					pci_free_consistent(pdev,
+							sizeof(mega_passthru),
+							pthru,
+							pthru_dma_hndl);
+
+					free_local_pdev(pdev);
+
+					return (-ENOMEM);
+				}
+
+				/*
+				 * Save the user address and point the kernel
+				 * address at just allocated memory
+				 */
+				uxferaddr = pthru->dataxferaddr;
+				pthru->dataxferaddr = data_dma_hndl;
+			}
+
+
+			/*
+			 * Is data coming down-stream
+			 */
+			if( pthru->dataxferlen && (uioc.flags & UIOC_WR) ) {
+				/*
+				 * Get the user data
+				 */
+				if( copy_from_user(data, (char __user *)uxferaddr,
+							pthru->dataxferlen) ) {
+					rval = (-EFAULT);
+					goto freemem_and_return;
+				}
+			}
+
+			memset(&mc, 0, sizeof(megacmd_t));
+
+			mc.cmd = MEGA_MBOXCMD_PASSTHRU;
+			mc.xferaddr = (u32)pthru_dma_hndl;
+
+			/*
+			 * Issue the command
+			 */
+			mega_internal_command(adapter, LOCK_INT, &mc, pthru);
+
+			rval = mega_n_to_m((void __user *)arg, &mc);
+
+			if( rval ) goto freemem_and_return;
+
+
+			/*
+			 * Is data going up-stream
+			 */
+			if( pthru->dataxferlen && (uioc.flags & UIOC_RD) ) {
+				if( copy_to_user((char __user *)uxferaddr, data,
+							pthru->dataxferlen) ) {
+					rval = (-EFAULT);
+				}
+			}
+
+			/*
+			 * Send the request sense data also, irrespective of
+			 * whether the user has asked for it or not.
+			 */
+			copy_to_user(upthru->reqsensearea,
+					pthru->reqsensearea, 14);
+
+freemem_and_return:
+			if( pthru->dataxferlen ) {
+				pci_free_consistent(pdev,
+						pthru->dataxferlen, data,
+						data_dma_hndl);
+			}
+
+			pci_free_consistent(pdev, sizeof(mega_passthru),
+					pthru, pthru_dma_hndl);
+
+			free_local_pdev(pdev);
+
+			return rval;
+		}
+		else {
+			/* DCMD commands */
+
+			/*
+			 * Is there a data transfer
+			 */
+			if( uioc.xferlen ) {
+				data = pci_alloc_consistent(pdev,
+						uioc.xferlen, &data_dma_hndl);
+
+				if( data == NULL ) {
+					free_local_pdev(pdev);
+					return (-ENOMEM);
+				}
+
+				uxferaddr = MBOX(uioc)->xferaddr;
+			}
+
+			/*
+			 * Is data coming down-stream
+			 */
+			if( uioc.xferlen && (uioc.flags & UIOC_WR) ) {
+				/*
+				 * Get the user data
+				 */
+				if( copy_from_user(data, (char __user *)uxferaddr,
+							uioc.xferlen) ) {
+
+					pci_free_consistent(pdev,
+							uioc.xferlen,
+							data, data_dma_hndl);
+
+					free_local_pdev(pdev);
+
+					return (-EFAULT);
+				}
+			}
+
+			memcpy(&mc, MBOX(uioc), sizeof(megacmd_t));
+
+			mc.xferaddr = (u32)data_dma_hndl;
+
+			/*
+			 * Issue the command
+			 */
+			mega_internal_command(adapter, LOCK_INT, &mc, NULL);
+
+			rval = mega_n_to_m((void __user *)arg, &mc);
+
+			if( rval ) {
+				if( uioc.xferlen ) {
+					pci_free_consistent(pdev,
+							uioc.xferlen, data,
+							data_dma_hndl);
+				}
+
+				free_local_pdev(pdev);
+
+				return rval;
+			}
+
+			/*
+			 * Is data going up-stream
+			 */
+			if( uioc.xferlen && (uioc.flags & UIOC_RD) ) {
+				if( copy_to_user((char __user *)uxferaddr, data,
+							uioc.xferlen) ) {
+
+					rval = (-EFAULT);
+				}
+			}
+
+			if( uioc.xferlen ) {
+				pci_free_consistent(pdev,
+						uioc.xferlen, data,
+						data_dma_hndl);
+			}
+
+			free_local_pdev(pdev);
+
+			return rval;
+		}
+
+	default:
+		return (-EINVAL);
+	}
+
+	return 0;
+}
+
+/**
+ * mega_m_to_n()
+ * @arg - user address
+ * @uioc - new ioctl structure
+ *
+ * A thin layer to convert older mimd interface ioctl structure to NIT ioctl
+ * structure
+ *
+ * Converts the older mimd ioctl structure to newer NIT structure
+ */
+static int
+mega_m_to_n(void __user *arg, nitioctl_t *uioc)
+{
+	struct uioctl_t	uioc_mimd;
+	char	signature[8] = {0};
+	u8	opcode;
+	u8	subopcode;
+
+
+	/*
+	 * check is the application conforms to NIT. We do not have to do much
+	 * in that case.
+	 * We exploit the fact that the signature is stored in the very
+	 * begining of the structure.
+	 */
+
+	if( copy_from_user(signature, arg, 7) )
+		return (-EFAULT);
+
+	if( memcmp(signature, "MEGANIT", 7) == 0 ) {
+
+		/*
+		 * NOTE NOTE: The nit ioctl is still under flux because of
+		 * change of mailbox definition, in HPE. No applications yet
+		 * use this interface and let's not have applications use this
+		 * interface till the new specifitions are in place.
+		 */
+		return -EINVAL;
+#if 0
+		if( copy_from_user(uioc, arg, sizeof(nitioctl_t)) )
+			return (-EFAULT);
+		return 0;
+#endif
+	}
+
+	/*
+	 * Else assume we have mimd uioctl_t as arg. Convert to nitioctl_t
+	 *
+	 * Get the user ioctl structure
+	 */
+	if( copy_from_user(&uioc_mimd, arg, sizeof(struct uioctl_t)) )
+		return (-EFAULT);
+
+
+	/*
+	 * Get the opcode and subopcode for the commands
+	 */
+	opcode = uioc_mimd.ui.fcs.opcode;
+	subopcode = uioc_mimd.ui.fcs.subopcode;
+
+	switch (opcode) {
+	case 0x82:
+
+		switch (subopcode) {
+
+		case MEGAIOC_QDRVRVER:	/* Query driver version */
+			uioc->opcode = GET_DRIVER_VER;
+			uioc->uioc_uaddr = uioc_mimd.data;
+			break;
+
+		case MEGAIOC_QNADAP:	/* Get # of adapters */
+			uioc->opcode = GET_N_ADAP;
+			uioc->uioc_uaddr = uioc_mimd.data;
+			break;
+
+		case MEGAIOC_QADAPINFO:	/* Get adapter information */
+			uioc->opcode = GET_ADAP_INFO;
+			uioc->adapno = uioc_mimd.ui.fcs.adapno;
+			uioc->uioc_uaddr = uioc_mimd.data;
+			break;
+
+		default:
+			return(-EINVAL);
+		}
+
+		break;
+
+
+	case 0x81:
+
+		uioc->opcode = MBOX_CMD;
+		uioc->adapno = uioc_mimd.ui.fcs.adapno;
+
+		memcpy(uioc->uioc_rmbox, uioc_mimd.mbox, 18);
+
+		uioc->xferlen = uioc_mimd.ui.fcs.length;
+
+		if( uioc_mimd.outlen ) uioc->flags = UIOC_RD;
+		if( uioc_mimd.inlen ) uioc->flags |= UIOC_WR;
+
+		break;
+
+	case 0x80:
+
+		uioc->opcode = MBOX_CMD;
+		uioc->adapno = uioc_mimd.ui.fcs.adapno;
+
+		memcpy(uioc->uioc_rmbox, uioc_mimd.mbox, 18);
+
+		/*
+		 * Choose the xferlen bigger of input and output data
+		 */
+		uioc->xferlen = uioc_mimd.outlen > uioc_mimd.inlen ?
+			uioc_mimd.outlen : uioc_mimd.inlen;
+
+		if( uioc_mimd.outlen ) uioc->flags = UIOC_RD;
+		if( uioc_mimd.inlen ) uioc->flags |= UIOC_WR;
+
+		break;
+
+	default:
+		return (-EINVAL);
+
+	}
+
+	return 0;
+}
+
+/*
+ * mega_n_to_m()
+ * @arg - user address
+ * @mc - mailbox command
+ *
+ * Updates the status information to the application, depending on application
+ * conforms to older mimd ioctl interface or newer NIT ioctl interface
+ */
+static int
+mega_n_to_m(void __user *arg, megacmd_t *mc)
+{
+	nitioctl_t	__user *uiocp;
+	megacmd_t	__user *umc;
+	mega_passthru	__user *upthru;
+	struct uioctl_t	__user *uioc_mimd;
+	char	signature[8] = {0};
+
+	/*
+	 * check is the application conforms to NIT.
+	 */
+	if( copy_from_user(signature, arg, 7) )
+		return -EFAULT;
+
+	if( memcmp(signature, "MEGANIT", 7) == 0 ) {
+
+		uiocp = arg;
+
+		if( put_user(mc->status, (u8 __user *)&MBOX_P(uiocp)->status) )
+			return (-EFAULT);
+
+		if( mc->cmd == MEGA_MBOXCMD_PASSTHRU ) {
+
+			umc = MBOX_P(uiocp);
+
+			if (get_user(upthru, (mega_passthru __user * __user *)&umc->xferaddr))
+				return -EFAULT;
+
+			if( put_user(mc->status, (u8 __user *)&upthru->scsistatus))
+				return (-EFAULT);
+		}
+	}
+	else {
+		uioc_mimd = arg;
+
+		if( put_user(mc->status, (u8 __user *)&uioc_mimd->mbox[17]) )
+			return (-EFAULT);
+
+		if( mc->cmd == MEGA_MBOXCMD_PASSTHRU ) {
+
+			umc = (megacmd_t __user *)uioc_mimd->mbox;
+
+			if (get_user(upthru, (mega_passthru __user * __user *)&umc->xferaddr))
+				return (-EFAULT);
+
+			if( put_user(mc->status, (u8 __user *)&upthru->scsistatus) )
+				return (-EFAULT);
+		}
+	}
+
+	return 0;
+}
+
+
+/*
+ * MEGARAID 'FW' commands.
+ */
+
+/**
+ * mega_is_bios_enabled()
+ * @adapter - pointer to our soft state
+ *
+ * issue command to find out if the BIOS is enabled for this controller
+ */
+static int
+mega_is_bios_enabled(adapter_t *adapter)
+{
+	unsigned char	raw_mbox[sizeof(struct mbox_out)];
+	mbox_t	*mbox;
+	int	ret;
+
+	mbox = (mbox_t *)raw_mbox;
+
+	memset(&mbox->m_out, 0, sizeof(raw_mbox));
+
+	memset((void *)adapter->mega_buffer, 0, MEGA_BUFFER_SIZE);
+
+	mbox->m_out.xferaddr = (u32)adapter->buf_dma_handle;
+
+	raw_mbox[0] = IS_BIOS_ENABLED;
+	raw_mbox[2] = GET_BIOS;
+
+
+	ret = issue_scb_block(adapter, raw_mbox);
+
+	return *(char *)adapter->mega_buffer;
+}
+
+
+/**
+ * mega_enum_raid_scsi()
+ * @adapter - pointer to our soft state
+ *
+ * Find out what channels are RAID/SCSI. This information is used to
+ * differentiate the virtual channels and physical channels and to support
+ * ROMB feature and non-disk devices.
+ */
+static void
+mega_enum_raid_scsi(adapter_t *adapter)
+{
+	unsigned char raw_mbox[sizeof(struct mbox_out)];
+	mbox_t *mbox;
+	int i;
+
+	mbox = (mbox_t *)raw_mbox;
+
+	memset(&mbox->m_out, 0, sizeof(raw_mbox));
+
+	/*
+	 * issue command to find out what channels are raid/scsi
+	 */
+	raw_mbox[0] = CHNL_CLASS;
+	raw_mbox[2] = GET_CHNL_CLASS;
+
+	memset((void *)adapter->mega_buffer, 0, MEGA_BUFFER_SIZE);
+
+	mbox->m_out.xferaddr = (u32)adapter->buf_dma_handle;
+
+	/*
+	 * Non-ROMB firmware fail this command, so all channels
+	 * must be shown RAID
+	 */
+	adapter->mega_ch_class = 0xFF;
+
+	if(!issue_scb_block(adapter, raw_mbox)) {
+		adapter->mega_ch_class = *((char *)adapter->mega_buffer);
+
+	}
+
+	for( i = 0; i < adapter->product_info.nchannels; i++ ) { 
+		if( (adapter->mega_ch_class >> i) & 0x01 ) {
+			printk(KERN_INFO "megaraid: channel[%d] is raid.\n",
+					i);
+		}
+		else {
+			printk(KERN_INFO "megaraid: channel[%d] is scsi.\n",
+					i);
+		}
+	}
+
+	return;
+}
+
+
+/**
+ * mega_get_boot_drv()
+ * @adapter - pointer to our soft state
+ *
+ * Find out which device is the boot device. Note, any logical drive or any
+ * phyical device (e.g., a CDROM) can be designated as a boot device.
+ */
+static void
+mega_get_boot_drv(adapter_t *adapter)
+{
+	struct private_bios_data	*prv_bios_data;
+	unsigned char	raw_mbox[sizeof(struct mbox_out)];
+	mbox_t	*mbox;
+	u16	cksum = 0;
+	u8	*cksum_p;
+	u8	boot_pdrv;
+	int	i;
+
+	mbox = (mbox_t *)raw_mbox;
+
+	memset(&mbox->m_out, 0, sizeof(raw_mbox));
+
+	raw_mbox[0] = BIOS_PVT_DATA;
+	raw_mbox[2] = GET_BIOS_PVT_DATA;
+
+	memset((void *)adapter->mega_buffer, 0, MEGA_BUFFER_SIZE);
+
+	mbox->m_out.xferaddr = (u32)adapter->buf_dma_handle;
+
+	adapter->boot_ldrv_enabled = 0;
+	adapter->boot_ldrv = 0;
+
+	adapter->boot_pdrv_enabled = 0;
+	adapter->boot_pdrv_ch = 0;
+	adapter->boot_pdrv_tgt = 0;
+
+	if(issue_scb_block(adapter, raw_mbox) == 0) {
+		prv_bios_data =
+			(struct private_bios_data *)adapter->mega_buffer;
+
+		cksum = 0;
+		cksum_p = (char *)prv_bios_data;
+		for (i = 0; i < 14; i++ ) {
+			cksum += (u16)(*cksum_p++);
+		}
+
+		if (prv_bios_data->cksum == (u16)(0-cksum) ) {
+
+			/*
+			 * If MSB is set, a physical drive is set as boot
+			 * device
+			 */
+			if( prv_bios_data->boot_drv & 0x80 ) {
+				adapter->boot_pdrv_enabled = 1;
+				boot_pdrv = prv_bios_data->boot_drv & 0x7F;
+				adapter->boot_pdrv_ch = boot_pdrv / 16;
+				adapter->boot_pdrv_tgt = boot_pdrv % 16;
+			}
+			else {
+				adapter->boot_ldrv_enabled = 1;
+				adapter->boot_ldrv = prv_bios_data->boot_drv;
+			}
+		}
+	}
+
+}
+
+/**
+ * mega_support_random_del()
+ * @adapter - pointer to our soft state
+ *
+ * Find out if this controller supports random deletion and addition of
+ * logical drives
+ */
+static int
+mega_support_random_del(adapter_t *adapter)
+{
+	unsigned char raw_mbox[sizeof(struct mbox_out)];
+	mbox_t *mbox;
+	int rval;
+
+	mbox = (mbox_t *)raw_mbox;
+
+	memset(&mbox->m_out, 0, sizeof(raw_mbox));
+
+	/*
+	 * issue command
+	 */
+	raw_mbox[0] = FC_DEL_LOGDRV;
+	raw_mbox[2] = OP_SUP_DEL_LOGDRV;
+
+	rval = issue_scb_block(adapter, raw_mbox);
+
+	return !rval;
+}
+
+
+/**
+ * mega_support_ext_cdb()
+ * @adapter - pointer to our soft state
+ *
+ * Find out if this firmware support cdblen > 10
+ */
+static int
+mega_support_ext_cdb(adapter_t *adapter)
+{
+	unsigned char raw_mbox[sizeof(struct mbox_out)];
+	mbox_t *mbox;
+	int rval;
+
+	mbox = (mbox_t *)raw_mbox;
+
+	memset(&mbox->m_out, 0, sizeof(raw_mbox));
+	/*
+	 * issue command to find out if controller supports extended CDBs.
+	 */
+	raw_mbox[0] = 0xA4;
+	raw_mbox[2] = 0x16;
+
+	rval = issue_scb_block(adapter, raw_mbox);
+
+	return !rval;
+}
+
+
+/**
+ * mega_del_logdrv()
+ * @adapter - pointer to our soft state
+ * @logdrv - logical drive to be deleted
+ *
+ * Delete the specified logical drive. It is the responsibility of the user
+ * app to let the OS know about this operation.
+ */
+static int
+mega_del_logdrv(adapter_t *adapter, int logdrv)
+{
+	unsigned long flags;
+	scb_t *scb;
+	int rval;
+
+	/*
+	 * Stop sending commands to the controller, queue them internally.
+	 * When deletion is complete, ISR will flush the queue.
+	 */
+	atomic_set(&adapter->quiescent, 1);
+
+	/*
+	 * Wait till all the issued commands are complete and there are no
+	 * commands in the pending queue
+	 */
+	while (atomic_read(&adapter->pend_cmds) > 0 ||
+	       !list_empty(&adapter->pending_list))
+		msleep(1000);	/* sleep for 1s */
+
+	rval = mega_do_del_logdrv(adapter, logdrv);
+
+	spin_lock_irqsave(&adapter->lock, flags);
+
+	/*
+	 * If delete operation was successful, add 0x80 to the logical drive
+	 * ids for commands in the pending queue.
+	 */
+	if (adapter->read_ldidmap) {
+		struct list_head *pos;
+		list_for_each(pos, &adapter->pending_list) {
+			scb = list_entry(pos, scb_t, list);
+			if (scb->pthru->logdrv < 0x80 )
+				scb->pthru->logdrv += 0x80;
+		}
+	}
+
+	atomic_set(&adapter->quiescent, 0);
+
+	mega_runpendq(adapter);
+
+	spin_unlock_irqrestore(&adapter->lock, flags);
+
+	return rval;
+}
+
+
+static int
+mega_do_del_logdrv(adapter_t *adapter, int logdrv)
+{
+	megacmd_t	mc;
+	int	rval;
+
+	memset( &mc, 0, sizeof(megacmd_t));
+
+	mc.cmd = FC_DEL_LOGDRV;
+	mc.opcode = OP_DEL_LOGDRV;
+	mc.subopcode = logdrv;
+
+	rval = mega_internal_command(adapter, LOCK_INT, &mc, NULL);
+
+	/* log this event */
+	if(rval) {
+		printk(KERN_WARNING "megaraid: Delete LD-%d failed.", logdrv);
+		return rval;
+	}
+
+	/*
+	 * After deleting first logical drive, the logical drives must be
+	 * addressed by adding 0x80 to the logical drive id.
+	 */
+	adapter->read_ldidmap = 1;
+
+	return rval;
+}
+
+
+/**
+ * mega_get_max_sgl()
+ * @adapter - pointer to our soft state
+ *
+ * Find out the maximum number of scatter-gather elements supported by this
+ * version of the firmware
+ */
+static void
+mega_get_max_sgl(adapter_t *adapter)
+{
+	unsigned char	raw_mbox[sizeof(struct mbox_out)];
+	mbox_t	*mbox;
+
+	mbox = (mbox_t *)raw_mbox;
+
+	memset(mbox, 0, sizeof(raw_mbox));
+
+	memset((void *)adapter->mega_buffer, 0, MEGA_BUFFER_SIZE);
+
+	mbox->m_out.xferaddr = (u32)adapter->buf_dma_handle;
+
+	raw_mbox[0] = MAIN_MISC_OPCODE;
+	raw_mbox[2] = GET_MAX_SG_SUPPORT;
+
+
+	if( issue_scb_block(adapter, raw_mbox) ) {
+		/*
+		 * f/w does not support this command. Choose the default value
+		 */
+		adapter->sglen = MIN_SGLIST;
+	}
+	else {
+		adapter->sglen = *((char *)adapter->mega_buffer);
+		
+		/*
+		 * Make sure this is not more than the resources we are
+		 * planning to allocate
+		 */
+		if ( adapter->sglen > MAX_SGLIST )
+			adapter->sglen = MAX_SGLIST;
+	}
+
+	return;
+}
+
+
+/**
+ * mega_support_cluster()
+ * @adapter - pointer to our soft state
+ *
+ * Find out if this firmware support cluster calls.
+ */
+static int
+mega_support_cluster(adapter_t *adapter)
+{
+	unsigned char	raw_mbox[sizeof(struct mbox_out)];
+	mbox_t	*mbox;
+
+	mbox = (mbox_t *)raw_mbox;
+
+	memset(mbox, 0, sizeof(raw_mbox));
+
+	memset((void *)adapter->mega_buffer, 0, MEGA_BUFFER_SIZE);
+
+	mbox->m_out.xferaddr = (u32)adapter->buf_dma_handle;
+
+	/*
+	 * Try to get the initiator id. This command will succeed iff the
+	 * clustering is available on this HBA.
+	 */
+	raw_mbox[0] = MEGA_GET_TARGET_ID;
+
+	if( issue_scb_block(adapter, raw_mbox) == 0 ) {
+
+		/*
+		 * Cluster support available. Get the initiator target id.
+		 * Tell our id to mid-layer too.
+		 */
+		adapter->this_id = *(u32 *)adapter->mega_buffer;
+		adapter->host->this_id = adapter->this_id;
+
+		return 1;
+	}
+
+	return 0;
+}
+
+
+/**
+ * mega_adapinq()
+ * @adapter - pointer to our soft state
+ * @dma_handle - DMA address of the buffer
+ *
+ * Issue internal comamnds while interrupts are available.
+ * We only issue direct mailbox commands from within the driver. ioctl()
+ * interface using these routines can issue passthru commands.
+ */
+static int
+mega_adapinq(adapter_t *adapter, dma_addr_t dma_handle)
+{
+	megacmd_t	mc;
+
+	memset(&mc, 0, sizeof(megacmd_t));
+
+	if( adapter->flag & BOARD_40LD ) {
+		mc.cmd = FC_NEW_CONFIG;
+		mc.opcode = NC_SUBOP_ENQUIRY3;
+		mc.subopcode = ENQ3_GET_SOLICITED_FULL;
+	}
+	else {
+		mc.cmd = MEGA_MBOXCMD_ADPEXTINQ;
+	}
+
+	mc.xferaddr = (u32)dma_handle;
+
+	if ( mega_internal_command(adapter, LOCK_INT, &mc, NULL) != 0 ) {
+		return -1;
+	}
+
+	return 0;
+}
+
+
+/** mega_internal_dev_inquiry()
+ * @adapter - pointer to our soft state
+ * @ch - channel for this device
+ * @tgt - ID of this device
+ * @buf_dma_handle - DMA address of the buffer
+ *
+ * Issue the scsi inquiry for the specified device.
+ */
+static int
+mega_internal_dev_inquiry(adapter_t *adapter, u8 ch, u8 tgt,
+		dma_addr_t buf_dma_handle)
+{
+	mega_passthru	*pthru;
+	dma_addr_t	pthru_dma_handle;
+	megacmd_t	mc;
+	int		rval;
+	struct pci_dev	*pdev;
+
+
+	/*
+	 * For all internal commands, the buffer must be allocated in <4GB
+	 * address range
+	 */
+	if( make_local_pdev(adapter, &pdev) != 0 ) return -1;
+
+	pthru = pci_alloc_consistent(pdev, sizeof(mega_passthru),
+			&pthru_dma_handle);
+
+	if( pthru == NULL ) {
+		free_local_pdev(pdev);
+		return -1;
+	}
+
+	pthru->timeout = 2;
+	pthru->ars = 1;
+	pthru->reqsenselen = 14;
+	pthru->islogical = 0;
+
+	pthru->channel = (adapter->flag & BOARD_40LD) ? 0 : ch;
+
+	pthru->target = (adapter->flag & BOARD_40LD) ? (ch << 4)|tgt : tgt;
+
+	pthru->cdblen = 6;
+
+	pthru->cdb[0] = INQUIRY;
+	pthru->cdb[1] = 0;
+	pthru->cdb[2] = 0;
+	pthru->cdb[3] = 0;
+	pthru->cdb[4] = 255;
+	pthru->cdb[5] = 0;
+
+
+	pthru->dataxferaddr = (u32)buf_dma_handle;
+	pthru->dataxferlen = 256;
+
+	memset(&mc, 0, sizeof(megacmd_t));
+
+	mc.cmd = MEGA_MBOXCMD_PASSTHRU;
+	mc.xferaddr = (u32)pthru_dma_handle;
+
+	rval = mega_internal_command(adapter, LOCK_INT, &mc, pthru);
+
+	pci_free_consistent(pdev, sizeof(mega_passthru), pthru,
+			pthru_dma_handle);
+
+	free_local_pdev(pdev);
+
+	return rval;
+}
+
+
+/**
+ * mega_internal_command()
+ * @adapter - pointer to our soft state
+ * @ls - the scope of the exclusion lock.
+ * @mc - the mailbox command
+ * @pthru - Passthru structure for DCDB commands
+ *
+ * Issue the internal commands in interrupt mode.
+ * The last argument is the address of the passthru structure if the command
+ * to be fired is a passthru command
+ *
+ * lockscope specifies whether the caller has already acquired the lock. Of
+ * course, the caller must know which lock we are talking about.
+ *
+ * Note: parameter 'pthru' is null for non-passthru commands.
+ */
+static int
+mega_internal_command(adapter_t *adapter, lockscope_t ls, megacmd_t *mc,
+		mega_passthru *pthru )
+{
+	Scsi_Cmnd	*scmd;
+	struct	scsi_device *sdev;
+	unsigned long	flags = 0;
+	scb_t	*scb;
+	int	rval;
+
+	/*
+	 * The internal commands share one command id and hence are
+	 * serialized. This is so because we want to reserve maximum number of
+	 * available command ids for the I/O commands.
+	 */
+	down(&adapter->int_mtx);
+
+	scb = &adapter->int_scb;
+	memset(scb, 0, sizeof(scb_t));
+
+	scmd = &adapter->int_scmd;
+	memset(scmd, 0, sizeof(Scsi_Cmnd));
+
+	sdev = kmalloc(sizeof(struct scsi_device), GFP_KERNEL);
+	memset(sdev, 0, sizeof(struct scsi_device));
+	scmd->device = sdev;
+
+	scmd->device->host = adapter->host;
+	scmd->buffer = (void *)scb;
+	scmd->cmnd[0] = MEGA_INTERNAL_CMD;
+
+	scb->state |= SCB_ACTIVE;
+	scb->cmd = scmd;
+
+	memcpy(scb->raw_mbox, mc, sizeof(megacmd_t));
+
+	/*
+	 * Is it a passthru command
+	 */
+	if( mc->cmd == MEGA_MBOXCMD_PASSTHRU ) {
+
+		scb->pthru = pthru;
+	}
+
+	scb->idx = CMDID_INT_CMDS;
+
+	scmd->state = 0;
+
+	/*
+	 * Get the lock only if the caller has not acquired it already
+	 */
+	if( ls == LOCK_INT ) spin_lock_irqsave(&adapter->lock, flags);
+
+	megaraid_queue(scmd, mega_internal_done);
+
+	if( ls == LOCK_INT ) spin_unlock_irqrestore(&adapter->lock, flags);
+
+	/*
+	 * Wait till this command finishes. Do not use
+	 * wait_event_interruptible(). It causes panic if CTRL-C is hit when
+	 * dumping e.g., physical disk information through /proc interface.
+	 */
+#if 0
+	wait_event_interruptible(adapter->int_waitq, scmd->state);
+#endif
+	wait_event(adapter->int_waitq, scmd->state);
+
+	rval = scmd->result;
+	mc->status = scmd->result;
+	kfree(sdev);
+
+	/*
+	 * Print a debug message for all failed commands. Applications can use
+	 * this information.
+	 */
+	if( scmd->result && trace_level ) {
+		printk("megaraid: cmd [%x, %x, %x] status:[%x]\n",
+			mc->cmd, mc->opcode, mc->subopcode, scmd->result);
+	}
+
+	up(&adapter->int_mtx);
+
+	return rval;
+}
+
+
+/**
+ * mega_internal_done()
+ * @scmd - internal scsi command
+ *
+ * Callback routine for internal commands.
+ */
+static void
+mega_internal_done(Scsi_Cmnd *scmd)
+{
+	adapter_t	*adapter;
+
+	adapter = (adapter_t *)scmd->device->host->hostdata;
+
+	scmd->state = 1; /* thread waiting for its command to complete */
+
+	/*
+	 * See comment in mega_internal_command() routine for
+	 * wait_event_interruptible()
+	 */
+#if 0
+	wake_up_interruptible(&adapter->int_waitq);
+#endif
+	wake_up(&adapter->int_waitq);
+
+}
+
+
+static struct scsi_host_template megaraid_template = {
+	.module				= THIS_MODULE,
+	.name				= "MegaRAID",
+	.proc_name			= "megaraid",
+	.info				= megaraid_info,
+	.queuecommand			= megaraid_queue,	
+	.bios_param			= megaraid_biosparam,
+	.max_sectors			= MAX_SECTORS_PER_IO,
+	.can_queue			= MAX_COMMANDS,
+	.this_id			= DEFAULT_INITIATOR_ID,
+	.sg_tablesize			= MAX_SGLIST,
+	.cmd_per_lun			= DEF_CMD_PER_LUN,
+	.use_clustering			= ENABLE_CLUSTERING,
+	.eh_abort_handler		= megaraid_abort,
+	.eh_device_reset_handler	= megaraid_reset,
+	.eh_bus_reset_handler		= megaraid_reset,
+	.eh_host_reset_handler		= megaraid_reset,
+};
+
+static int __devinit
+megaraid_probe_one(struct pci_dev *pdev, const struct pci_device_id *id)
+{
+	struct Scsi_Host *host;
+	adapter_t *adapter;
+	unsigned long mega_baseport, tbase, flag = 0;
+	u16 subsysid, subsysvid;
+	u8 pci_bus, pci_dev_func;
+	int irq, i, j;
+	int error = -ENODEV;
+
+	if (pci_enable_device(pdev))
+		goto out;
+	pci_set_master(pdev);
+
+	pci_bus = pdev->bus->number;
+	pci_dev_func = pdev->devfn;
+
+	/*
+	 * The megaraid3 stuff reports the ID of the Intel part which is not
+	 * remotely specific to the megaraid
+	 */
+	if (pdev->vendor == PCI_VENDOR_ID_INTEL) {
+		u16 magic;
+		/*
+		 * Don't fall over the Compaq management cards using the same
+		 * PCI identifier
+		 */
+		if (pdev->subsystem_vendor == PCI_VENDOR_ID_COMPAQ &&
+		    pdev->subsystem_device == 0xC000)
+		   	return -ENODEV;
+		/* Now check the magic signature byte */
+		pci_read_config_word(pdev, PCI_CONF_AMISIG, &magic);
+		if (magic != HBA_SIGNATURE_471 && magic != HBA_SIGNATURE)
+			return -ENODEV;
+		/* Ok it is probably a megaraid */
+	}
+
+	/*
+	 * For these vendor and device ids, signature offsets are not
+	 * valid and 64 bit is implicit
+	 */
+	if (id->driver_data & BOARD_64BIT)
+		flag |= BOARD_64BIT;
+	else {
+		u32 magic64;
+
+		pci_read_config_dword(pdev, PCI_CONF_AMISIG64, &magic64);
+		if (magic64 == HBA_SIGNATURE_64BIT)
+			flag |= BOARD_64BIT;
+	}
+
+	subsysvid = pdev->subsystem_vendor;
+	subsysid = pdev->subsystem_device;
+
+	printk(KERN_NOTICE "megaraid: found 0x%4.04x:0x%4.04x:bus %d:",
+		id->vendor, id->device, pci_bus);
+
+	printk("slot %d:func %d\n",
+		PCI_SLOT(pci_dev_func), PCI_FUNC(pci_dev_func));
+
+	/* Read the base port and IRQ from PCI */
+	mega_baseport = pci_resource_start(pdev, 0);
+	irq = pdev->irq;
+
+	tbase = mega_baseport;
+	if (pci_resource_flags(pdev, 0) & IORESOURCE_MEM) {
+		flag |= BOARD_MEMMAP;
+
+		if (!request_mem_region(mega_baseport, 128, "megaraid")) {
+			printk(KERN_WARNING "megaraid: mem region busy!\n");
+			goto out_disable_device;
+		}
+
+		mega_baseport = (unsigned long)ioremap(mega_baseport, 128);
+		if (!mega_baseport) {
+			printk(KERN_WARNING
+			       "megaraid: could not map hba memory\n");
+			goto out_release_region;
+		}
+	} else {
+		flag |= BOARD_IOMAP;
+		mega_baseport += 0x10;
+
+		if (!request_region(mega_baseport, 16, "megaraid"))
+			goto out_disable_device;
+	}
+
+	/* Initialize SCSI Host structure */
+	host = scsi_host_alloc(&megaraid_template, sizeof(adapter_t));
+	if (!host)
+		goto out_iounmap;
+
+	adapter = (adapter_t *)host->hostdata;
+	memset(adapter, 0, sizeof(adapter_t));
+
+	printk(KERN_NOTICE
+		"scsi%d:Found MegaRAID controller at 0x%lx, IRQ:%d\n",
+		host->host_no, mega_baseport, irq);
+
+	adapter->base = mega_baseport;
+
+	INIT_LIST_HEAD(&adapter->free_list);
+	INIT_LIST_HEAD(&adapter->pending_list);
+	INIT_LIST_HEAD(&adapter->completed_list);
+
+	adapter->flag = flag;
+	spin_lock_init(&adapter->lock);
+	scsi_assign_lock(host, &adapter->lock);
+
+	host->cmd_per_lun = max_cmd_per_lun;
+	host->max_sectors = max_sectors_per_io;
+
+	adapter->dev = pdev;
+	adapter->host = host;
+
+	adapter->host->irq = irq;
+
+	if (flag & BOARD_MEMMAP)
+		adapter->host->base = tbase;
+	else {
+		adapter->host->io_port = tbase;
+		adapter->host->n_io_port = 16;
+	}
+
+	adapter->host->unique_id = (pci_bus << 8) | pci_dev_func;
+
+	/*
+	 * Allocate buffer to issue internal commands.
+	 */
+	adapter->mega_buffer = pci_alloc_consistent(adapter->dev,
+		MEGA_BUFFER_SIZE, &adapter->buf_dma_handle);
+	if (!adapter->mega_buffer) {
+		printk(KERN_WARNING "megaraid: out of RAM.\n");
+		goto out_host_put;
+	}
+
+	adapter->scb_list = kmalloc(sizeof(scb_t) * MAX_COMMANDS, GFP_KERNEL);
+	if (!adapter->scb_list) {
+		printk(KERN_WARNING "megaraid: out of RAM.\n");
+		goto out_free_cmd_buffer;
+	}
+
+	if (request_irq(irq, (adapter->flag & BOARD_MEMMAP) ?
+				megaraid_isr_memmapped : megaraid_isr_iomapped,
+					SA_SHIRQ, "megaraid", adapter)) {
+		printk(KERN_WARNING
+			"megaraid: Couldn't register IRQ %d!\n", irq);
+		goto out_free_scb_list;
+	}
+
+	if (mega_setup_mailbox(adapter))
+		goto out_free_irq;
+
+	if (mega_query_adapter(adapter))
+		goto out_free_mbox;
+
+	/*
+	 * Have checks for some buggy f/w
+	 */
+	if ((subsysid == 0x1111) && (subsysvid == 0x1111)) {
+		/*
+		 * Which firmware
+		 */
+		if (!strcmp(adapter->fw_version, "3.00") ||
+				!strcmp(adapter->fw_version, "3.01")) {
+
+			printk( KERN_WARNING
+				"megaraid: Your  card is a Dell PERC "
+				"2/SC RAID controller with  "
+				"firmware\nmegaraid: 3.00 or 3.01.  "
+				"This driver is known to have "
+				"corruption issues\nmegaraid: with "
+				"those firmware versions on this "
+				"specific card.  In order\nmegaraid: "
+				"to protect your data, please upgrade "
+				"your firmware to version\nmegaraid: "
+				"3.10 or later, available from the "
+				"Dell Technical Support web\n"
+				"megaraid: site at\nhttp://support."
+				"dell.com/us/en/filelib/download/"
+				"index.asp?fileid=2940\n"
+			);
+		}
+	}
+
+	/*
+	 * If we have a HP 1M(0x60E7)/2M(0x60E8) controller with
+	 * firmware H.01.07, H.01.08, and H.01.09 disable 64 bit
+	 * support, since this firmware cannot handle 64 bit
+	 * addressing
+	 */
+	if ((subsysvid == HP_SUBSYS_VID) &&
+	    ((subsysid == 0x60E7) || (subsysid == 0x60E8))) {
+		/*
+		 * which firmware
+		 */
+		if (!strcmp(adapter->fw_version, "H01.07") ||
+		    !strcmp(adapter->fw_version, "H01.08") ||
+		    !strcmp(adapter->fw_version, "H01.09") ) {
+			printk(KERN_WARNING
+				"megaraid: Firmware H.01.07, "
+				"H.01.08, and H.01.09 on 1M/2M "
+				"controllers\n"
+				"megaraid: do not support 64 bit "
+				"addressing.\nmegaraid: DISABLING "
+				"64 bit support.\n");
+			adapter->flag &= ~BOARD_64BIT;
+		}
+	}
+
+	if (mega_is_bios_enabled(adapter))
+		mega_hbas[hba_count].is_bios_enabled = 1;
+	mega_hbas[hba_count].hostdata_addr = adapter;
+
+	/*
+	 * Find out which channel is raid and which is scsi. This is
+	 * for ROMB support.
+	 */
+	mega_enum_raid_scsi(adapter);
+
+	/*
+	 * Find out if a logical drive is set as the boot drive. If
+	 * there is one, will make that as the first logical drive.
+	 * ROMB: Do we have to boot from a physical drive. Then all
+	 * the physical drives would appear before the logical disks.
+	 * Else, all the physical drives would be exported to the mid
+	 * layer after logical drives.
+	 */
+	mega_get_boot_drv(adapter);
+
+	if (adapter->boot_pdrv_enabled) {
+		j = adapter->product_info.nchannels;
+		for( i = 0; i < j; i++ )
+			adapter->logdrv_chan[i] = 0;
+		for( i = j; i < NVIRT_CHAN + j; i++ )
+			adapter->logdrv_chan[i] = 1;
+	} else {
+		for (i = 0; i < NVIRT_CHAN; i++)
+			adapter->logdrv_chan[i] = 1;
+		for (i = NVIRT_CHAN; i < MAX_CHANNELS+NVIRT_CHAN; i++)
+			adapter->logdrv_chan[i] = 0;
+		adapter->mega_ch_class <<= NVIRT_CHAN;
+	}
+
+	/*
+	 * Do we support random deletion and addition of logical
+	 * drives
+	 */
+	adapter->read_ldidmap = 0;	/* set it after first logdrv
+						   delete cmd */
+	adapter->support_random_del = mega_support_random_del(adapter);
+
+	/* Initialize SCBs */
+	if (mega_init_scb(adapter))
+		goto out_free_mbox;
+
+	/*
+	 * Reset the pending commands counter
+	 */
+	atomic_set(&adapter->pend_cmds, 0);
+
+	/*
+	 * Reset the adapter quiescent flag
+	 */
+	atomic_set(&adapter->quiescent, 0);
+
+	hba_soft_state[hba_count] = adapter;
+
+	/*
+	 * Fill in the structure which needs to be passed back to the
+	 * application when it does an ioctl() for controller related
+	 * information.
+	 */
+	i = hba_count;
+
+	mcontroller[i].base = mega_baseport;
+	mcontroller[i].irq = irq;
+	mcontroller[i].numldrv = adapter->numldrv;
+	mcontroller[i].pcibus = pci_bus;
+	mcontroller[i].pcidev = id->device;
+	mcontroller[i].pcifun = PCI_FUNC (pci_dev_func);
+	mcontroller[i].pciid = -1;
+	mcontroller[i].pcivendor = id->vendor;
+	mcontroller[i].pcislot = PCI_SLOT(pci_dev_func);
+	mcontroller[i].uid = (pci_bus << 8) | pci_dev_func;
+
+
+	/* Set the Mode of addressing to 64 bit if we can */
+	if ((adapter->flag & BOARD_64BIT) && (sizeof(dma_addr_t) == 8)) {
+		pci_set_dma_mask(pdev, 0xffffffffffffffffULL);
+		adapter->has_64bit_addr = 1;
+	} else  {
+		pci_set_dma_mask(pdev, 0xffffffff);
+		adapter->has_64bit_addr = 0;
+	}
+		
+	init_MUTEX(&adapter->int_mtx);
+	init_waitqueue_head(&adapter->int_waitq);
+
+	adapter->this_id = DEFAULT_INITIATOR_ID;
+	adapter->host->this_id = DEFAULT_INITIATOR_ID;
+
+#if MEGA_HAVE_CLUSTERING
+	/*
+	 * Is cluster support enabled on this controller
+	 * Note: In a cluster the HBAs ( the initiators ) will have
+	 * different target IDs and we cannot assume it to be 7. Call
+	 * to mega_support_cluster() will get the target ids also if
+	 * the cluster support is available
+	 */
+	adapter->has_cluster = mega_support_cluster(adapter);
+	if (adapter->has_cluster) {
+		printk(KERN_NOTICE
+			"megaraid: Cluster driver, initiator id:%d\n",
+			adapter->this_id);
+	}
+#endif
+
+	pci_set_drvdata(pdev, host);
+
+	mega_create_proc_entry(hba_count, mega_proc_dir_entry);
+
+	error = scsi_add_host(host, &pdev->dev);
+	if (error)
+		goto out_free_mbox;
+
+	scsi_scan_host(host);
+	hba_count++;
+	return 0;
+
+ out_free_mbox:
+	pci_free_consistent(adapter->dev, sizeof(mbox64_t),
+			adapter->una_mbox64, adapter->una_mbox64_dma);
+ out_free_irq:
+	free_irq(adapter->host->irq, adapter);
+ out_free_scb_list:
+	kfree(adapter->scb_list);
+ out_free_cmd_buffer:
+	pci_free_consistent(adapter->dev, MEGA_BUFFER_SIZE,
+			adapter->mega_buffer, adapter->buf_dma_handle);
+ out_host_put:
+	scsi_host_put(host);
+ out_iounmap:
+	if (flag & BOARD_MEMMAP)
+		iounmap((void *)mega_baseport);
+ out_release_region:
+	if (flag & BOARD_MEMMAP)
+		release_mem_region(tbase, 128);
+	else
+		release_region(mega_baseport, 16);
+ out_disable_device:
+	pci_disable_device(pdev);
+ out:
+	return error;
+}
+
+static void
+__megaraid_shutdown(adapter_t *adapter)
+{
+	u_char	raw_mbox[sizeof(struct mbox_out)];
+	mbox_t	*mbox = (mbox_t *)raw_mbox;
+	int	i;
+
+	/* Flush adapter cache */
+	memset(&mbox->m_out, 0, sizeof(raw_mbox));
+	raw_mbox[0] = FLUSH_ADAPTER;
+
+	free_irq(adapter->host->irq, adapter);
+
+	/* Issue a blocking (interrupts disabled) command to the card */
+	issue_scb_block(adapter, raw_mbox);
+
+	/* Flush disks cache */
+	memset(&mbox->m_out, 0, sizeof(raw_mbox));
+	raw_mbox[0] = FLUSH_SYSTEM;
+
+	/* Issue a blocking (interrupts disabled) command to the card */
+	issue_scb_block(adapter, raw_mbox);
+	
+	if (atomic_read(&adapter->pend_cmds) > 0)
+		printk(KERN_WARNING "megaraid: pending commands!!\n");
+
+	/*
+	 * Have a delibrate delay to make sure all the caches are
+	 * actually flushed.
+	 */
+	for (i = 0; i <= 10; i++)
+		mdelay(1000);
+}
+
+static void
+megaraid_remove_one(struct pci_dev *pdev)
+{
+	struct Scsi_Host *host = pci_get_drvdata(pdev);
+	adapter_t *adapter = (adapter_t *)host->hostdata;
+	char	buf[12] = { 0 };
+
+	scsi_remove_host(host);
+
+	__megaraid_shutdown(adapter);
+
+	/* Free our resources */
+	if (adapter->flag & BOARD_MEMMAP) {
+		iounmap((void *)adapter->base);
+		release_mem_region(adapter->host->base, 128);
+	} else
+		release_region(adapter->base, 16);
+
+	mega_free_sgl(adapter);
+
+#ifdef CONFIG_PROC_FS
+	if (adapter->controller_proc_dir_entry) {
+		remove_proc_entry("stat", adapter->controller_proc_dir_entry);
+		remove_proc_entry("config",
+				adapter->controller_proc_dir_entry);
+		remove_proc_entry("mailbox",
+				adapter->controller_proc_dir_entry);
+#if MEGA_HAVE_ENH_PROC
+		remove_proc_entry("rebuild-rate",
+				adapter->controller_proc_dir_entry);
+		remove_proc_entry("battery-status",
+				adapter->controller_proc_dir_entry);
+
+		remove_proc_entry("diskdrives-ch0",
+				adapter->controller_proc_dir_entry);
+		remove_proc_entry("diskdrives-ch1",
+				adapter->controller_proc_dir_entry);
+		remove_proc_entry("diskdrives-ch2",
+				adapter->controller_proc_dir_entry);
+		remove_proc_entry("diskdrives-ch3",
+				adapter->controller_proc_dir_entry);
+
+		remove_proc_entry("raiddrives-0-9",
+				adapter->controller_proc_dir_entry);
+		remove_proc_entry("raiddrives-10-19",
+				adapter->controller_proc_dir_entry);
+		remove_proc_entry("raiddrives-20-29",
+				adapter->controller_proc_dir_entry);
+		remove_proc_entry("raiddrives-30-39",
+				adapter->controller_proc_dir_entry);
+#endif
+		sprintf(buf, "hba%d", adapter->host->host_no);
+		remove_proc_entry(buf, mega_proc_dir_entry);
+	}
+#endif
+
+	pci_free_consistent(adapter->dev, MEGA_BUFFER_SIZE,
+			adapter->mega_buffer, adapter->buf_dma_handle);
+	kfree(adapter->scb_list);
+	pci_free_consistent(adapter->dev, sizeof(mbox64_t),
+			adapter->una_mbox64, adapter->una_mbox64_dma);
+
+	scsi_host_put(host);
+	pci_disable_device(pdev);
+
+	hba_count--;
+}
+
+static void
+megaraid_shutdown(struct device *dev)
+{
+	struct Scsi_Host *host = pci_get_drvdata(to_pci_dev(dev));
+	adapter_t *adapter = (adapter_t *)host->hostdata;
+
+	__megaraid_shutdown(adapter);
+}
+
+static struct pci_device_id megaraid_pci_tbl[] = {
+	{PCI_VENDOR_ID_DELL, PCI_DEVICE_ID_DISCOVERY,
+		PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},
+	{PCI_VENDOR_ID_DELL, PCI_DEVICE_ID_PERC4_DI,
+		PCI_ANY_ID, PCI_ANY_ID, 0, 0, BOARD_64BIT},
+	{PCI_VENDOR_ID_LSI_LOGIC, PCI_DEVICE_ID_PERC4_QC_VERDE,
+		PCI_ANY_ID, PCI_ANY_ID, 0, 0, BOARD_64BIT},
+	{PCI_VENDOR_ID_AMI, PCI_DEVICE_ID_AMI_MEGARAID,
+		PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},
+	{PCI_VENDOR_ID_AMI, PCI_DEVICE_ID_AMI_MEGARAID2,
+		PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},
+	{PCI_VENDOR_ID_AMI, PCI_DEVICE_ID_AMI_MEGARAID3,
+		PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},
+	{PCI_VENDOR_ID_INTEL, PCI_DEVICE_ID_AMI_MEGARAID3,
+		PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},
+	{PCI_VENDOR_ID_LSI_LOGIC, PCI_DEVICE_ID_AMI_MEGARAID3,
+		PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0},
+	{0,}
+};
+MODULE_DEVICE_TABLE(pci, megaraid_pci_tbl);
+
+static struct pci_driver megaraid_pci_driver = {
+	.name		= "megaraid",
+	.id_table	= megaraid_pci_tbl,
+	.probe		= megaraid_probe_one,
+	.remove		= __devexit_p(megaraid_remove_one),
+	.driver		= {
+		.shutdown = megaraid_shutdown,
+	},
+};
+
+static int __init megaraid_init(void)
+{
+	int error;
+
+	if ((max_cmd_per_lun <= 0) || (max_cmd_per_lun > MAX_CMD_PER_LUN))
+		max_cmd_per_lun = MAX_CMD_PER_LUN;
+	if (max_mbox_busy_wait > MBOX_BUSY_WAIT)
+		max_mbox_busy_wait = MBOX_BUSY_WAIT;
+
+#ifdef CONFIG_PROC_FS
+	mega_proc_dir_entry = proc_mkdir("megaraid", &proc_root);
+	if (!mega_proc_dir_entry) {
+		printk(KERN_WARNING
+				"megaraid: failed to create megaraid root\n");
+	}
+#endif
+	error = pci_module_init(&megaraid_pci_driver);
+	if (error) {
+#ifdef CONFIG_PROC_FS
+		remove_proc_entry("megaraid", &proc_root);
+#endif
+		return error;
+	}
+
+	/*
+	 * Register the driver as a character device, for applications
+	 * to access it for ioctls.
+	 * First argument (major) to register_chrdev implies a dynamic
+	 * major number allocation.
+	 */
+	major = register_chrdev(0, "megadev", &megadev_fops);
+	if (!major) {
+		printk(KERN_WARNING
+				"megaraid: failed to register char device\n");
+	}
+
+	return 0;
+}
+
+static void __exit megaraid_exit(void)
+{
+	/*
+	 * Unregister the character device interface to the driver.
+	 */
+	unregister_chrdev(major, "megadev");
+
+	pci_unregister_driver(&megaraid_pci_driver);
+
+#ifdef CONFIG_PROC_FS
+	remove_proc_entry("megaraid", &proc_root);
+#endif
+}
+
+module_init(megaraid_init);
+module_exit(megaraid_exit);
+
+/* vi: set ts=8 sw=8 tw=78: */
