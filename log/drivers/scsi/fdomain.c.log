commit 7a1c0b79dbe3423214e70750a5ee38fb617168ab
Author: Sergei Shtylyov <sergei.shtylyov@cogentembedded.com>
Date:   Tue Jul 16 23:40:47 2019 +0300

    scsi: fdomain: use BSTAT_{MSG|CMD|IO} in fdomain_work()
    
    Commit 1697c6a64c49 ("scsi: fdomain: Add register definitions") somehow
    missed the masking of the 'status' variable with the SCSI phase mask in
    fdomain_work(), leaving the magic number intact. Fix this issue; while at
    it, change the order of BSTAT_{MSG|CMD|IO} bits in the MESSAGE IN
    phase *case* (with no change in the generated object file).
    
    Fixes: 1697c6a64c49 ("scsi: fdomain: Add register definitions")
    Signed-off-by: Sergei Shtylyov <sergei.shtylyov@cogentembedded.com>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/fdomain.c b/drivers/scsi/fdomain.c
index fcf4cd5ef1ac..772bdc93930a 100644
--- a/drivers/scsi/fdomain.c
+++ b/drivers/scsi/fdomain.c
@@ -306,7 +306,7 @@ static void fdomain_work(struct work_struct *work)
 	status = inb(fd->base + REG_BSTAT);
 
 	if (status & BSTAT_REQ) {
-		switch (status & 0x0e) {
+		switch (status & (BSTAT_MSG | BSTAT_CMD | BSTAT_IO)) {
 		case BSTAT_CMD:	/* COMMAND OUT */
 			outb(cmd->cmnd[cmd->SCp.sent_command++],
 			     fd->base + REG_SCSI_DATA);
@@ -331,7 +331,7 @@ static void fdomain_work(struct work_struct *work)
 		case BSTAT_MSG | BSTAT_CMD:	/* MESSAGE OUT */
 			outb(MESSAGE_REJECT, fd->base + REG_SCSI_DATA);
 			break;
-		case BSTAT_MSG | BSTAT_IO | BSTAT_CMD:	/* MESSAGE IN */
+		case BSTAT_MSG | BSTAT_CMD | BSTAT_IO:	/* MESSAGE IN */
 			cmd->SCp.Message = inb(fd->base + REG_SCSI_DATA);
 			if (!cmd->SCp.Message)
 				++done;

commit a9651be7e4818d252e2a35f371bde79c556b1560
Author: Sergei Shtylyov <sergei.shtylyov@cogentembedded.com>
Date:   Tue Jul 16 23:39:15 2019 +0300

    scsi: fdomain: use BCTL_RST in fdomain_reset()
    
    Commit 1697c6a64c49 ("scsi: fdomain: Add register definitions") somehow
    missed the use of BCTL_RST in fdomain_reset(), leaving the magic number
    intact.  Fix this issue (with no change in the generated object file).
    
    Fixes: 1697c6a64c49 ("scsi: fdomain: Add register definitions")
    Signed-off-by: Sergei Shtylyov <sergei.shtylyov@cogentembedded.com>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/fdomain.c b/drivers/scsi/fdomain.c
index b5e66971b6d9..fcf4cd5ef1ac 100644
--- a/drivers/scsi/fdomain.c
+++ b/drivers/scsi/fdomain.c
@@ -166,7 +166,7 @@ static int fdomain_test_loopback(int base)
 
 static void fdomain_reset(int base)
 {
-	outb(1, base + REG_BCTL);
+	outb(BCTL_RST, base + REG_BCTL);
 	mdelay(20);
 	outb(0, base + REG_BCTL);
 	mdelay(1150);

commit 8674a8aa2c399cb4014052796ba4bd0fbd6f3c03
Author: Ondrej Zary <linux@zary.sk>
Date:   Mon May 27 22:19:47 2019 +0200

    scsi: fdomain: Add PCMCIA support
    
    Add PCMCIA card support to Future Domain SCSI driver.
    
    Tested with IBM SCSI PCMCIA Adapter 40G1890.
    
    Signed-off-by: Ondrej Zary <linux@zary.sk>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/fdomain.c b/drivers/scsi/fdomain.c
index 297ccc799436..b5e66971b6d9 100644
--- a/drivers/scsi/fdomain.c
+++ b/drivers/scsi/fdomain.c
@@ -510,6 +510,7 @@ struct Scsi_Host *fdomain_create(int base, int irq, int this_id,
 	static const char * const chip_names[] = {
 		"Unknown", "TMC-1800", "TMC-18C50", "TMC-18C30"
 	};
+	unsigned long irq_flags = 0;
 
 	chip = fdomain_identify(base);
 	if (!chip)
@@ -541,8 +542,10 @@ struct Scsi_Host *fdomain_create(int base, int irq, int this_id,
 	fd->chip = chip;
 	INIT_WORK(&fd->work, fdomain_work);
 
-	if (request_irq(irq, fdomain_irq, dev_is_pci(dev) ? IRQF_SHARED : 0,
-			  "fdomain", fd))
+	if (dev_is_pci(dev) || !strcmp(dev->bus->name, "pcmcia"))
+		irq_flags = IRQF_SHARED;
+
+	if (request_irq(irq, fdomain_irq, irq_flags, "fdomain", fd))
 		goto fail_put;
 
 	shost_printk(KERN_INFO, sh, "%s chip at 0x%x irq %d SCSI ID %d\n",

commit 1697c6a64c49df3ed1a7e81845dcf2edf6ea23db
Author: Ondrej Zary <linux@zary.sk>
Date:   Sat May 18 21:47:24 2019 +0200

    scsi: fdomain: Add register definitions
    
    Add register bit definitions from documentation to header file and use them
    instead of magic constants. No changes to generated binary.
    
    Signed-off-by: Ondrej Zary <linux@zary.sk>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/fdomain.c b/drivers/scsi/fdomain.c
index 19af1ae608df..297ccc799436 100644
--- a/drivers/scsi/fdomain.c
+++ b/drivers/scsi/fdomain.c
@@ -99,7 +99,7 @@
  * up the machine.
  */
 #define FIFO_COUNT	2	/* Number of 512 byte blocks before INTR */
-#define PARITY_MASK	0x08	/* Parity enabled, 0x00 = disabled */
+#define PARITY_MASK	ACTL_PAREN	/* Parity enabled, 0 = disabled */
 
 enum chip_type {
 	unknown		= 0x00,
@@ -117,18 +117,19 @@ struct fdomain {
 
 static inline void fdomain_make_bus_idle(struct fdomain *fd)
 {
-	outb(0, fd->base + SCSI_Cntl);
-	outb(0, fd->base + SCSI_Mode_Cntl);
+	outb(0, fd->base + REG_BCTL);
+	outb(0, fd->base + REG_MCTL);
 	if (fd->chip == tmc18c50 || fd->chip == tmc18c30)
 		/* Clear forced intr. */
-		outb(0x21 | PARITY_MASK, fd->base + TMC_Cntl);
+		outb(ACTL_RESET | ACTL_CLRFIRQ | PARITY_MASK,
+		     fd->base + REG_ACTL);
 	else
-		outb(0x01 | PARITY_MASK, fd->base + TMC_Cntl);
+		outb(ACTL_RESET | PARITY_MASK, fd->base + REG_ACTL);
 }
 
 static enum chip_type fdomain_identify(int port)
 {
-	u16 id = inb(port + LSB_ID_Code) | inb(port + MSB_ID_Code) << 8;
+	u16 id = inb(port + REG_ID_LSB) | inb(port + REG_ID_MSB) << 8;
 
 	switch (id) {
 	case 0x6127:
@@ -140,10 +141,10 @@ static enum chip_type fdomain_identify(int port)
 	}
 
 	/* Try to toggle 32-bit mode. This only works on an 18c30 chip. */
-	outb(0x80, port + IO_Control);
-	if ((inb(port + Configuration2) & 0x80) == 0x80) {
-		outb(0x00, port + IO_Control);
-		if ((inb(port + Configuration2) & 0x80) == 0x00)
+	outb(CFG2_32BIT, port + REG_CFG2);
+	if ((inb(port + REG_CFG2) & CFG2_32BIT)) {
+		outb(0, port + REG_CFG2);
+		if ((inb(port + REG_CFG2) & CFG2_32BIT) == 0)
 			return tmc18c30;
 	}
 	/* If that failed, we are an 18c50. */
@@ -155,8 +156,8 @@ static int fdomain_test_loopback(int base)
 	int i;
 
 	for (i = 0; i < 255; i++) {
-		outb(i, base + Write_Loopback);
-		if (inb(base + Read_Loopback) != i)
+		outb(i, base + REG_LOOPBACK);
+		if (inb(base + REG_LOOPBACK) != i)
 			return 1;
 	}
 
@@ -165,12 +166,12 @@ static int fdomain_test_loopback(int base)
 
 static void fdomain_reset(int base)
 {
-	outb(1, base + SCSI_Cntl);
+	outb(1, base + REG_BCTL);
 	mdelay(20);
-	outb(0, base + SCSI_Cntl);
+	outb(0, base + REG_BCTL);
 	mdelay(1150);
-	outb(0, base + SCSI_Mode_Cntl);
-	outb(PARITY_MASK, base + TMC_Cntl);
+	outb(0, base + REG_MCTL);
+	outb(PARITY_MASK, base + REG_ACTL);
 }
 
 static int fdomain_select(struct Scsi_Host *sh, int target)
@@ -179,20 +180,20 @@ static int fdomain_select(struct Scsi_Host *sh, int target)
 	unsigned long timeout;
 	struct fdomain *fd = shost_priv(sh);
 
-	outb(0x82, fd->base + SCSI_Cntl); /* Bus Enable + Select */
-	outb(BIT(sh->this_id) | BIT(target), fd->base + SCSI_Data_NoACK);
+	outb(BCTL_BUSEN | BCTL_SEL, fd->base + REG_BCTL);
+	outb(BIT(sh->this_id) | BIT(target), fd->base + REG_SCSI_DATA_NOACK);
 
 	/* Stop arbitration and enable parity */
-	outb(PARITY_MASK, fd->base + TMC_Cntl);
+	outb(PARITY_MASK, fd->base + REG_ACTL);
 
 	timeout = 350;	/* 350 msec */
 
 	do {
-		status = inb(fd->base + SCSI_Status); /* Read adapter status */
-		if (status & 1) {	/* Busy asserted */
+		status = inb(fd->base + REG_BSTAT);
+		if (status & BSTAT_BSY) {
 			/* Enable SCSI Bus */
 			/* (on error, should make bus idle with 0) */
-			outb(0x80, fd->base + SCSI_Cntl);
+			outb(BCTL_BUSEN, fd->base + REG_BCTL);
 			return 0;
 		}
 		mdelay(1);
@@ -203,7 +204,7 @@ static int fdomain_select(struct Scsi_Host *sh, int target)
 
 static void fdomain_finish_cmd(struct fdomain *fd, int result)
 {
-	outb(0x00, fd->base + Interrupt_Cntl);
+	outb(0, fd->base + REG_ICTL);
 	fdomain_make_bus_idle(fd);
 	fd->cur_cmd->result = result;
 	fd->cur_cmd->scsi_done(fd->cur_cmd);
@@ -216,15 +217,15 @@ static void fdomain_read_data(struct scsi_cmnd *cmd)
 	unsigned char *virt, *ptr;
 	size_t offset, len;
 
-	while ((len = inw(fd->base + FIFO_Data_Count)) > 0) {
+	while ((len = inw(fd->base + REG_FIFO_COUNT)) > 0) {
 		offset = scsi_bufflen(cmd) - scsi_get_resid(cmd);
 		virt = scsi_kmap_atomic_sg(scsi_sglist(cmd), scsi_sg_count(cmd),
 					   &offset, &len);
 		ptr = virt + offset;
 		if (len & 1)
-			*ptr++ = inb(fd->base + Read_FIFO);
+			*ptr++ = inb(fd->base + REG_FIFO);
 		if (len > 1)
-			insw(fd->base + Read_FIFO, ptr, len >> 1);
+			insw(fd->base + REG_FIFO, ptr, len >> 1);
 		scsi_set_resid(cmd, scsi_get_resid(cmd) - len);
 		scsi_kunmap_atomic_sg(virt);
 	}
@@ -238,7 +239,7 @@ static void fdomain_write_data(struct scsi_cmnd *cmd)
 	unsigned char *virt, *ptr;
 	size_t offset, len;
 
-	while ((len = FIFO_Size - inw(fd->base + FIFO_Data_Count)) > 512) {
+	while ((len = FIFO_Size - inw(fd->base + REG_FIFO_COUNT)) > 512) {
 		offset = scsi_bufflen(cmd) - scsi_get_resid(cmd);
 		if (len + offset > scsi_bufflen(cmd)) {
 			len = scsi_bufflen(cmd) - offset;
@@ -249,9 +250,9 @@ static void fdomain_write_data(struct scsi_cmnd *cmd)
 					   &offset, &len);
 		ptr = virt + offset;
 		if (len & 1)
-			outb(*ptr++, fd->base + Write_FIFO);
+			outb(*ptr++, fd->base + REG_FIFO);
 		if (len > 1)
-			outsw(fd->base + Write_FIFO, ptr, len >> 1);
+			outsw(fd->base + REG_FIFO, ptr, len >> 1);
 		scsi_set_resid(cmd, scsi_get_resid(cmd) - len);
 		scsi_kunmap_atomic_sg(virt);
 	}
@@ -270,66 +271,68 @@ static void fdomain_work(struct work_struct *work)
 	spin_lock_irqsave(sh->host_lock, flags);
 
 	if (cmd->SCp.phase & in_arbitration) {
-		status = inb(fd->base + TMC_Status);
-		if (!(status & 0x02)) {
+		status = inb(fd->base + REG_ASTAT);
+		if (!(status & ASTAT_ARB)) {
 			fdomain_finish_cmd(fd, DID_BUS_BUSY << 16);
 			goto out;
 		}
 		cmd->SCp.phase = in_selection;
 
-		outb(0x40 | FIFO_COUNT, fd->base + Interrupt_Cntl);
-		outb(0x82, fd->base + SCSI_Cntl); /* Bus Enable + Select */
-		outb(BIT(cmd->device->host->this_id) |
-		     BIT(scmd_id(cmd)), fd->base + SCSI_Data_NoACK);
+		outb(ICTL_SEL | FIFO_COUNT, fd->base + REG_ICTL);
+		outb(BCTL_BUSEN | BCTL_SEL, fd->base + REG_BCTL);
+		outb(BIT(cmd->device->host->this_id) | BIT(scmd_id(cmd)),
+		     fd->base + REG_SCSI_DATA_NOACK);
 		/* Stop arbitration and enable parity */
-		outb(0x10 | PARITY_MASK, fd->base + TMC_Cntl);
+		outb(ACTL_IRQEN | PARITY_MASK, fd->base + REG_ACTL);
 		goto out;
 	} else if (cmd->SCp.phase & in_selection) {
-		status = inb(fd->base + SCSI_Status);
-		if (!(status & 0x01)) {
+		status = inb(fd->base + REG_BSTAT);
+		if (!(status & BSTAT_BSY)) {
 			/* Try again, for slow devices */
 			if (fdomain_select(cmd->device->host, scmd_id(cmd))) {
 				fdomain_finish_cmd(fd, DID_NO_CONNECT << 16);
 				goto out;
 			}
 			/* Stop arbitration and enable parity */
-			outb(0x10 | PARITY_MASK, fd->base + TMC_Cntl);
+			outb(ACTL_IRQEN | PARITY_MASK, fd->base + REG_ACTL);
 		}
 		cmd->SCp.phase = in_other;
-		outb(0x90 | FIFO_COUNT, fd->base + Interrupt_Cntl);
-		outb(0x80, fd->base + SCSI_Cntl);
+		outb(ICTL_FIFO | ICTL_REQ | FIFO_COUNT, fd->base + REG_ICTL);
+		outb(BCTL_BUSEN, fd->base + REG_BCTL);
 		goto out;
 	}
 
 	/* cur_cmd->SCp.phase == in_other: this is the body of the routine */
-	status = inb(fd->base + SCSI_Status);
+	status = inb(fd->base + REG_BSTAT);
 
-	if (status & 0x10) {	/* REQ */
+	if (status & BSTAT_REQ) {
 		switch (status & 0x0e) {
-		case 0x08:	/* COMMAND OUT */
+		case BSTAT_CMD:	/* COMMAND OUT */
 			outb(cmd->cmnd[cmd->SCp.sent_command++],
-			     fd->base + Write_SCSI_Data);
+			     fd->base + REG_SCSI_DATA);
 			break;
-		case 0x00:	/* DATA OUT -- tmc18c50/tmc18c30 only */
+		case 0:	/* DATA OUT -- tmc18c50/tmc18c30 only */
 			if (fd->chip != tmc1800 && !cmd->SCp.have_data_in) {
 				cmd->SCp.have_data_in = -1;
-				outb(0xd0 | PARITY_MASK, fd->base + TMC_Cntl);
+				outb(ACTL_IRQEN | ACTL_FIFOWR | ACTL_FIFOEN |
+				     PARITY_MASK, fd->base + REG_ACTL);
 			}
 			break;
-		case 0x04:	/* DATA IN -- tmc18c50/tmc18c30 only */
+		case BSTAT_IO:	/* DATA IN -- tmc18c50/tmc18c30 only */
 			if (fd->chip != tmc1800 && !cmd->SCp.have_data_in) {
 				cmd->SCp.have_data_in = 1;
-				outb(0x90 | PARITY_MASK, fd->base + TMC_Cntl);
+				outb(ACTL_IRQEN | ACTL_FIFOEN | PARITY_MASK,
+				     fd->base + REG_ACTL);
 			}
 			break;
-		case 0x0c:	/* STATUS IN */
-			cmd->SCp.Status = inb(fd->base + Read_SCSI_Data);
+		case BSTAT_CMD | BSTAT_IO:	/* STATUS IN */
+			cmd->SCp.Status = inb(fd->base + REG_SCSI_DATA);
 			break;
-		case 0x0a:	/* MESSAGE OUT */
-			outb(MESSAGE_REJECT, fd->base + Write_SCSI_Data);
+		case BSTAT_MSG | BSTAT_CMD:	/* MESSAGE OUT */
+			outb(MESSAGE_REJECT, fd->base + REG_SCSI_DATA);
 			break;
-		case 0x0e:	/* MESSAGE IN */
-			cmd->SCp.Message = inb(fd->base + Read_SCSI_Data);
+		case BSTAT_MSG | BSTAT_IO | BSTAT_CMD:	/* MESSAGE IN */
+			cmd->SCp.Message = inb(fd->base + REG_SCSI_DATA);
 			if (!cmd->SCp.Message)
 				++done;
 			break;
@@ -340,10 +343,12 @@ static void fdomain_work(struct work_struct *work)
 	    cmd->SCp.sent_command >= cmd->cmd_len) {
 		if (cmd->sc_data_direction == DMA_TO_DEVICE) {
 			cmd->SCp.have_data_in = -1;
-			outb(0xd0 | PARITY_MASK, fd->base + TMC_Cntl);
+			outb(ACTL_IRQEN | ACTL_FIFOWR | ACTL_FIFOEN |
+			     PARITY_MASK, fd->base + REG_ACTL);
 		} else {
 			cmd->SCp.have_data_in = 1;
-			outb(0x90 | PARITY_MASK, fd->base + TMC_Cntl);
+			outb(ACTL_IRQEN | ACTL_FIFOEN | PARITY_MASK,
+			     fd->base + REG_ACTL);
 		}
 	}
 
@@ -359,10 +364,12 @@ static void fdomain_work(struct work_struct *work)
 				   (DID_OK << 16));
 	} else {
 		if (cmd->SCp.phase & disconnect) {
-			outb(0xd0 | FIFO_COUNT, fd->base + Interrupt_Cntl);
-			outb(0x00, fd->base + SCSI_Cntl);
+			outb(ICTL_FIFO | ICTL_SEL | ICTL_REQ | FIFO_COUNT,
+			     fd->base + REG_ICTL);
+			outb(0, fd->base + REG_BCTL);
 		} else
-			outb(0x90 | FIFO_COUNT, fd->base + Interrupt_Cntl);
+			outb(ICTL_FIFO | ICTL_REQ | FIFO_COUNT,
+			     fd->base + REG_ICTL);
 	}
 out:
 	spin_unlock_irqrestore(sh->host_lock, flags);
@@ -373,10 +380,10 @@ static irqreturn_t fdomain_irq(int irq, void *dev_id)
 	struct fdomain *fd = dev_id;
 
 	/* Is it our IRQ? */
-	if ((inb(fd->base + TMC_Status) & 0x01) == 0)
+	if ((inb(fd->base + REG_ASTAT) & ASTAT_IRQ) == 0)
 		return IRQ_NONE;
 
-	outb(0x00, fd->base + Interrupt_Cntl);
+	outb(0, fd->base + REG_ICTL);
 
 	/* We usually have one spurious interrupt after each command. */
 	if (!fd->cur_cmd)	/* Spurious interrupt */
@@ -406,12 +413,13 @@ static int fdomain_queue(struct Scsi_Host *sh, struct scsi_cmnd *cmd)
 	fdomain_make_bus_idle(fd);
 
 	/* Start arbitration */
-	outb(0x00, fd->base + Interrupt_Cntl);
-	outb(0x00, fd->base + SCSI_Cntl);	/* Disable data drivers */
-	outb(BIT(cmd->device->host->this_id),
-	     fd->base + SCSI_Data_NoACK);	/* Set our id bit */
-	outb(0x20, fd->base + Interrupt_Cntl);
-	outb(0x14 | PARITY_MASK, fd->base + TMC_Cntl);	/* Start arbitration */
+	outb(0, fd->base + REG_ICTL);
+	outb(0, fd->base + REG_BCTL);	/* Disable data drivers */
+	/* Set our id bit */
+	outb(BIT(cmd->device->host->this_id), fd->base + REG_SCSI_DATA_NOACK);
+	outb(ICTL_ARB, fd->base + REG_ICTL);
+	/* Start arbitration */
+	outb(ACTL_ARB | ACTL_IRQEN | PARITY_MASK, fd->base + REG_ACTL);
 
 	spin_unlock_irqrestore(sh->host_lock, flags);
 

commit ebeb466531154d6238399eb54438235f6fbbd013
Author: Ondrej Zary <linux@zary.sk>
Date:   Tue May 14 19:23:07 2019 +0200

    scsi: fdomain: Resurrect driver - Core
    
    Future Domain TMC-16xx/TMC-3260 SCSI driver.
    
    This is the core driver, common for PCI, ISA and PCMCIA cards.
    
    Signed-off-by: Ondrej Zary <linux@zary.sk>
    Reviewed-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/fdomain.c b/drivers/scsi/fdomain.c
new file mode 100644
index 000000000000..19af1ae608df
--- /dev/null
+++ b/drivers/scsi/fdomain.c
@@ -0,0 +1,586 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Driver for Future Domain TMC-16x0 and TMC-3260 SCSI host adapters
+ * Copyright 2019 Ondrej Zary
+ *
+ * Original driver by
+ * Rickard E. Faith, faith@cs.unc.edu
+ *
+ * Future Domain BIOS versions supported for autodetect:
+ *    2.0, 3.0, 3.2, 3.4 (1.0), 3.5 (2.0), 3.6, 3.61
+ * Chips supported:
+ *    TMC-1800, TMC-18C50, TMC-18C30, TMC-36C70
+ * Boards supported:
+ *    Future Domain TMC-1650, TMC-1660, TMC-1670, TMC-1680, TMC-1610M/MER/MEX
+ *    Future Domain TMC-3260 (PCI)
+ *    Quantum ISA-200S, ISA-250MG
+ *    Adaptec AHA-2920A (PCI) [BUT *NOT* AHA-2920C -- use aic7xxx instead]
+ *    IBM ?
+ *
+ * NOTE:
+ *
+ * The Adaptec AHA-2920C has an Adaptec AIC-7850 chip on it.
+ * Use the aic7xxx driver for this board.
+ *
+ * The Adaptec AHA-2920A has a Future Domain chip on it, so this is the right
+ * driver for that card.  Unfortunately, the boxes will probably just say
+ * "2920", so you'll have to look on the card for a Future Domain logo, or a
+ * letter after the 2920.
+ *
+ * If you have a TMC-8xx or TMC-9xx board, then this is not the driver for
+ * your board.
+ *
+ * DESCRIPTION:
+ *
+ * This is the Linux low-level SCSI driver for Future Domain TMC-1660/1680
+ * TMC-1650/1670, and TMC-3260 SCSI host adapters.  The 1650 and 1670 have a
+ * 25-pin external connector, whereas the 1660 and 1680 have a SCSI-2 50-pin
+ * high-density external connector.  The 1670 and 1680 have floppy disk
+ * controllers built in.  The TMC-3260 is a PCI bus card.
+ *
+ * Future Domain's older boards are based on the TMC-1800 chip, and this
+ * driver was originally written for a TMC-1680 board with the TMC-1800 chip.
+ * More recently, boards are being produced with the TMC-18C50 and TMC-18C30
+ * chips.
+ *
+ * Please note that the drive ordering that Future Domain implemented in BIOS
+ * versions 3.4 and 3.5 is the opposite of the order (currently) used by the
+ * rest of the SCSI industry.
+ *
+ *
+ * REFERENCES USED:
+ *
+ * "TMC-1800 SCSI Chip Specification (FDC-1800T)", Future Domain Corporation,
+ * 1990.
+ *
+ * "Technical Reference Manual: 18C50 SCSI Host Adapter Chip", Future Domain
+ * Corporation, January 1992.
+ *
+ * "LXT SCSI Products: Specifications and OEM Technical Manual (Revision
+ * B/September 1991)", Maxtor Corporation, 1991.
+ *
+ * "7213S product Manual (Revision P3)", Maxtor Corporation, 1992.
+ *
+ * "Draft Proposed American National Standard: Small Computer System
+ * Interface - 2 (SCSI-2)", Global Engineering Documents. (X3T9.2/86-109,
+ * revision 10h, October 17, 1991)
+ *
+ * Private communications, Drew Eckhardt (drew@cs.colorado.edu) and Eric
+ * Youngdale (ericy@cais.com), 1992.
+ *
+ * Private communication, Tuong Le (Future Domain Engineering department),
+ * 1994. (Disk geometry computations for Future Domain BIOS version 3.4, and
+ * TMC-18C30 detection.)
+ *
+ * Hogan, Thom. The Programmer's PC Sourcebook. Microsoft Press, 1988. Page
+ * 60 (2.39: Disk Partition Table Layout).
+ *
+ * "18C30 Technical Reference Manual", Future Domain Corporation, 1993, page
+ * 6-1.
+ */
+
+#include <linux/module.h>
+#include <linux/interrupt.h>
+#include <linux/delay.h>
+#include <linux/pci.h>
+#include <linux/workqueue.h>
+#include <scsi/scsicam.h>
+#include <scsi/scsi_cmnd.h>
+#include <scsi/scsi_device.h>
+#include <scsi/scsi_host.h>
+#include "fdomain.h"
+
+/*
+ * FIFO_COUNT: The host adapter has an 8K cache (host adapters based on the
+ * 18C30 chip have a 2k cache).  When this many 512 byte blocks are filled by
+ * the SCSI device, an interrupt will be raised.  Therefore, this could be as
+ * low as 0, or as high as 16.  Note, however, that values which are too high
+ * or too low seem to prevent any interrupts from occurring, and thereby lock
+ * up the machine.
+ */
+#define FIFO_COUNT	2	/* Number of 512 byte blocks before INTR */
+#define PARITY_MASK	0x08	/* Parity enabled, 0x00 = disabled */
+
+enum chip_type {
+	unknown		= 0x00,
+	tmc1800		= 0x01,
+	tmc18c50	= 0x02,
+	tmc18c30	= 0x03,
+};
+
+struct fdomain {
+	int base;
+	struct scsi_cmnd *cur_cmd;
+	enum chip_type chip;
+	struct work_struct work;
+};
+
+static inline void fdomain_make_bus_idle(struct fdomain *fd)
+{
+	outb(0, fd->base + SCSI_Cntl);
+	outb(0, fd->base + SCSI_Mode_Cntl);
+	if (fd->chip == tmc18c50 || fd->chip == tmc18c30)
+		/* Clear forced intr. */
+		outb(0x21 | PARITY_MASK, fd->base + TMC_Cntl);
+	else
+		outb(0x01 | PARITY_MASK, fd->base + TMC_Cntl);
+}
+
+static enum chip_type fdomain_identify(int port)
+{
+	u16 id = inb(port + LSB_ID_Code) | inb(port + MSB_ID_Code) << 8;
+
+	switch (id) {
+	case 0x6127:
+		return tmc1800;
+	case 0x60e9: /* 18c50 or 18c30 */
+		break;
+	default:
+		return unknown;
+	}
+
+	/* Try to toggle 32-bit mode. This only works on an 18c30 chip. */
+	outb(0x80, port + IO_Control);
+	if ((inb(port + Configuration2) & 0x80) == 0x80) {
+		outb(0x00, port + IO_Control);
+		if ((inb(port + Configuration2) & 0x80) == 0x00)
+			return tmc18c30;
+	}
+	/* If that failed, we are an 18c50. */
+	return tmc18c50;
+}
+
+static int fdomain_test_loopback(int base)
+{
+	int i;
+
+	for (i = 0; i < 255; i++) {
+		outb(i, base + Write_Loopback);
+		if (inb(base + Read_Loopback) != i)
+			return 1;
+	}
+
+	return 0;
+}
+
+static void fdomain_reset(int base)
+{
+	outb(1, base + SCSI_Cntl);
+	mdelay(20);
+	outb(0, base + SCSI_Cntl);
+	mdelay(1150);
+	outb(0, base + SCSI_Mode_Cntl);
+	outb(PARITY_MASK, base + TMC_Cntl);
+}
+
+static int fdomain_select(struct Scsi_Host *sh, int target)
+{
+	int status;
+	unsigned long timeout;
+	struct fdomain *fd = shost_priv(sh);
+
+	outb(0x82, fd->base + SCSI_Cntl); /* Bus Enable + Select */
+	outb(BIT(sh->this_id) | BIT(target), fd->base + SCSI_Data_NoACK);
+
+	/* Stop arbitration and enable parity */
+	outb(PARITY_MASK, fd->base + TMC_Cntl);
+
+	timeout = 350;	/* 350 msec */
+
+	do {
+		status = inb(fd->base + SCSI_Status); /* Read adapter status */
+		if (status & 1) {	/* Busy asserted */
+			/* Enable SCSI Bus */
+			/* (on error, should make bus idle with 0) */
+			outb(0x80, fd->base + SCSI_Cntl);
+			return 0;
+		}
+		mdelay(1);
+	} while (--timeout);
+	fdomain_make_bus_idle(fd);
+	return 1;
+}
+
+static void fdomain_finish_cmd(struct fdomain *fd, int result)
+{
+	outb(0x00, fd->base + Interrupt_Cntl);
+	fdomain_make_bus_idle(fd);
+	fd->cur_cmd->result = result;
+	fd->cur_cmd->scsi_done(fd->cur_cmd);
+	fd->cur_cmd = NULL;
+}
+
+static void fdomain_read_data(struct scsi_cmnd *cmd)
+{
+	struct fdomain *fd = shost_priv(cmd->device->host);
+	unsigned char *virt, *ptr;
+	size_t offset, len;
+
+	while ((len = inw(fd->base + FIFO_Data_Count)) > 0) {
+		offset = scsi_bufflen(cmd) - scsi_get_resid(cmd);
+		virt = scsi_kmap_atomic_sg(scsi_sglist(cmd), scsi_sg_count(cmd),
+					   &offset, &len);
+		ptr = virt + offset;
+		if (len & 1)
+			*ptr++ = inb(fd->base + Read_FIFO);
+		if (len > 1)
+			insw(fd->base + Read_FIFO, ptr, len >> 1);
+		scsi_set_resid(cmd, scsi_get_resid(cmd) - len);
+		scsi_kunmap_atomic_sg(virt);
+	}
+}
+
+static void fdomain_write_data(struct scsi_cmnd *cmd)
+{
+	struct fdomain *fd = shost_priv(cmd->device->host);
+	/* 8k FIFO for pre-tmc18c30 chips, 2k FIFO for tmc18c30 */
+	int FIFO_Size = fd->chip == tmc18c30 ? 0x800 : 0x2000;
+	unsigned char *virt, *ptr;
+	size_t offset, len;
+
+	while ((len = FIFO_Size - inw(fd->base + FIFO_Data_Count)) > 512) {
+		offset = scsi_bufflen(cmd) - scsi_get_resid(cmd);
+		if (len + offset > scsi_bufflen(cmd)) {
+			len = scsi_bufflen(cmd) - offset;
+			if (len == 0)
+				break;
+		}
+		virt = scsi_kmap_atomic_sg(scsi_sglist(cmd), scsi_sg_count(cmd),
+					   &offset, &len);
+		ptr = virt + offset;
+		if (len & 1)
+			outb(*ptr++, fd->base + Write_FIFO);
+		if (len > 1)
+			outsw(fd->base + Write_FIFO, ptr, len >> 1);
+		scsi_set_resid(cmd, scsi_get_resid(cmd) - len);
+		scsi_kunmap_atomic_sg(virt);
+	}
+}
+
+static void fdomain_work(struct work_struct *work)
+{
+	struct fdomain *fd = container_of(work, struct fdomain, work);
+	struct Scsi_Host *sh = container_of((void *)fd, struct Scsi_Host,
+					    hostdata);
+	struct scsi_cmnd *cmd = fd->cur_cmd;
+	unsigned long flags;
+	int status;
+	int done = 0;
+
+	spin_lock_irqsave(sh->host_lock, flags);
+
+	if (cmd->SCp.phase & in_arbitration) {
+		status = inb(fd->base + TMC_Status);
+		if (!(status & 0x02)) {
+			fdomain_finish_cmd(fd, DID_BUS_BUSY << 16);
+			goto out;
+		}
+		cmd->SCp.phase = in_selection;
+
+		outb(0x40 | FIFO_COUNT, fd->base + Interrupt_Cntl);
+		outb(0x82, fd->base + SCSI_Cntl); /* Bus Enable + Select */
+		outb(BIT(cmd->device->host->this_id) |
+		     BIT(scmd_id(cmd)), fd->base + SCSI_Data_NoACK);
+		/* Stop arbitration and enable parity */
+		outb(0x10 | PARITY_MASK, fd->base + TMC_Cntl);
+		goto out;
+	} else if (cmd->SCp.phase & in_selection) {
+		status = inb(fd->base + SCSI_Status);
+		if (!(status & 0x01)) {
+			/* Try again, for slow devices */
+			if (fdomain_select(cmd->device->host, scmd_id(cmd))) {
+				fdomain_finish_cmd(fd, DID_NO_CONNECT << 16);
+				goto out;
+			}
+			/* Stop arbitration and enable parity */
+			outb(0x10 | PARITY_MASK, fd->base + TMC_Cntl);
+		}
+		cmd->SCp.phase = in_other;
+		outb(0x90 | FIFO_COUNT, fd->base + Interrupt_Cntl);
+		outb(0x80, fd->base + SCSI_Cntl);
+		goto out;
+	}
+
+	/* cur_cmd->SCp.phase == in_other: this is the body of the routine */
+	status = inb(fd->base + SCSI_Status);
+
+	if (status & 0x10) {	/* REQ */
+		switch (status & 0x0e) {
+		case 0x08:	/* COMMAND OUT */
+			outb(cmd->cmnd[cmd->SCp.sent_command++],
+			     fd->base + Write_SCSI_Data);
+			break;
+		case 0x00:	/* DATA OUT -- tmc18c50/tmc18c30 only */
+			if (fd->chip != tmc1800 && !cmd->SCp.have_data_in) {
+				cmd->SCp.have_data_in = -1;
+				outb(0xd0 | PARITY_MASK, fd->base + TMC_Cntl);
+			}
+			break;
+		case 0x04:	/* DATA IN -- tmc18c50/tmc18c30 only */
+			if (fd->chip != tmc1800 && !cmd->SCp.have_data_in) {
+				cmd->SCp.have_data_in = 1;
+				outb(0x90 | PARITY_MASK, fd->base + TMC_Cntl);
+			}
+			break;
+		case 0x0c:	/* STATUS IN */
+			cmd->SCp.Status = inb(fd->base + Read_SCSI_Data);
+			break;
+		case 0x0a:	/* MESSAGE OUT */
+			outb(MESSAGE_REJECT, fd->base + Write_SCSI_Data);
+			break;
+		case 0x0e:	/* MESSAGE IN */
+			cmd->SCp.Message = inb(fd->base + Read_SCSI_Data);
+			if (!cmd->SCp.Message)
+				++done;
+			break;
+		}
+	}
+
+	if (fd->chip == tmc1800 && !cmd->SCp.have_data_in &&
+	    cmd->SCp.sent_command >= cmd->cmd_len) {
+		if (cmd->sc_data_direction == DMA_TO_DEVICE) {
+			cmd->SCp.have_data_in = -1;
+			outb(0xd0 | PARITY_MASK, fd->base + TMC_Cntl);
+		} else {
+			cmd->SCp.have_data_in = 1;
+			outb(0x90 | PARITY_MASK, fd->base + TMC_Cntl);
+		}
+	}
+
+	if (cmd->SCp.have_data_in == -1) /* DATA OUT */
+		fdomain_write_data(cmd);
+
+	if (cmd->SCp.have_data_in == 1) /* DATA IN */
+		fdomain_read_data(cmd);
+
+	if (done) {
+		fdomain_finish_cmd(fd, (cmd->SCp.Status & 0xff) |
+				   ((cmd->SCp.Message & 0xff) << 8) |
+				   (DID_OK << 16));
+	} else {
+		if (cmd->SCp.phase & disconnect) {
+			outb(0xd0 | FIFO_COUNT, fd->base + Interrupt_Cntl);
+			outb(0x00, fd->base + SCSI_Cntl);
+		} else
+			outb(0x90 | FIFO_COUNT, fd->base + Interrupt_Cntl);
+	}
+out:
+	spin_unlock_irqrestore(sh->host_lock, flags);
+}
+
+static irqreturn_t fdomain_irq(int irq, void *dev_id)
+{
+	struct fdomain *fd = dev_id;
+
+	/* Is it our IRQ? */
+	if ((inb(fd->base + TMC_Status) & 0x01) == 0)
+		return IRQ_NONE;
+
+	outb(0x00, fd->base + Interrupt_Cntl);
+
+	/* We usually have one spurious interrupt after each command. */
+	if (!fd->cur_cmd)	/* Spurious interrupt */
+		return IRQ_NONE;
+
+	schedule_work(&fd->work);
+
+	return IRQ_HANDLED;
+}
+
+static int fdomain_queue(struct Scsi_Host *sh, struct scsi_cmnd *cmd)
+{
+	struct fdomain *fd = shost_priv(cmd->device->host);
+	unsigned long flags;
+
+	cmd->SCp.Status		= 0;
+	cmd->SCp.Message	= 0;
+	cmd->SCp.have_data_in	= 0;
+	cmd->SCp.sent_command	= 0;
+	cmd->SCp.phase		= in_arbitration;
+	scsi_set_resid(cmd, scsi_bufflen(cmd));
+
+	spin_lock_irqsave(sh->host_lock, flags);
+
+	fd->cur_cmd = cmd;
+
+	fdomain_make_bus_idle(fd);
+
+	/* Start arbitration */
+	outb(0x00, fd->base + Interrupt_Cntl);
+	outb(0x00, fd->base + SCSI_Cntl);	/* Disable data drivers */
+	outb(BIT(cmd->device->host->this_id),
+	     fd->base + SCSI_Data_NoACK);	/* Set our id bit */
+	outb(0x20, fd->base + Interrupt_Cntl);
+	outb(0x14 | PARITY_MASK, fd->base + TMC_Cntl);	/* Start arbitration */
+
+	spin_unlock_irqrestore(sh->host_lock, flags);
+
+	return 0;
+}
+
+static int fdomain_abort(struct scsi_cmnd *cmd)
+{
+	struct Scsi_Host *sh = cmd->device->host;
+	struct fdomain *fd = shost_priv(sh);
+	unsigned long flags;
+
+	if (!fd->cur_cmd)
+		return FAILED;
+
+	spin_lock_irqsave(sh->host_lock, flags);
+
+	fdomain_make_bus_idle(fd);
+	fd->cur_cmd->SCp.phase |= aborted;
+	fd->cur_cmd->result = DID_ABORT << 16;
+
+	/* Aborts are not done well. . . */
+	fdomain_finish_cmd(fd, DID_ABORT << 16);
+	spin_unlock_irqrestore(sh->host_lock, flags);
+	return SUCCESS;
+}
+
+static int fdomain_host_reset(struct scsi_cmnd *cmd)
+{
+	struct Scsi_Host *sh = cmd->device->host;
+	struct fdomain *fd = shost_priv(sh);
+	unsigned long flags;
+
+	spin_lock_irqsave(sh->host_lock, flags);
+	fdomain_reset(fd->base);
+	spin_unlock_irqrestore(sh->host_lock, flags);
+	return SUCCESS;
+}
+
+static int fdomain_biosparam(struct scsi_device *sdev,
+			     struct block_device *bdev,	sector_t capacity,
+			     int geom[])
+{
+	unsigned char *p = scsi_bios_ptable(bdev);
+
+	if (p && p[65] == 0xaa && p[64] == 0x55 /* Partition table valid */
+	    && p[4]) {	 /* Partition type */
+		geom[0] = p[5] + 1;	/* heads */
+		geom[1] = p[6] & 0x3f;	/* sectors */
+	} else {
+		if (capacity >= 0x7e0000) {
+			geom[0] = 255;	/* heads */
+			geom[1] = 63;	/* sectors */
+		} else if (capacity >= 0x200000) {
+			geom[0] = 128;	/* heads */
+			geom[1] = 63;	/* sectors */
+		} else {
+			geom[0] = 64;	/* heads */
+			geom[1] = 32;	/* sectors */
+		}
+	}
+	geom[2] = sector_div(capacity, geom[0] * geom[1]);
+	kfree(p);
+
+	return 0;
+}
+
+static struct scsi_host_template fdomain_template = {
+	.module			= THIS_MODULE,
+	.name			= "Future Domain TMC-16x0",
+	.proc_name		= "fdomain",
+	.queuecommand		= fdomain_queue,
+	.eh_abort_handler	= fdomain_abort,
+	.eh_host_reset_handler	= fdomain_host_reset,
+	.bios_param		= fdomain_biosparam,
+	.can_queue		= 1,
+	.this_id		= 7,
+	.sg_tablesize		= 64,
+	.dma_boundary		= PAGE_SIZE - 1,
+};
+
+struct Scsi_Host *fdomain_create(int base, int irq, int this_id,
+				 struct device *dev)
+{
+	struct Scsi_Host *sh;
+	struct fdomain *fd;
+	enum chip_type chip;
+	static const char * const chip_names[] = {
+		"Unknown", "TMC-1800", "TMC-18C50", "TMC-18C30"
+	};
+
+	chip = fdomain_identify(base);
+	if (!chip)
+		return NULL;
+
+	fdomain_reset(base);
+
+	if (fdomain_test_loopback(base))
+		return NULL;
+
+	if (!irq) {
+		dev_err(dev, "card has no IRQ assigned");
+		return NULL;
+	}
+
+	sh = scsi_host_alloc(&fdomain_template, sizeof(struct fdomain));
+	if (!sh)
+		return NULL;
+
+	if (this_id)
+		sh->this_id = this_id & 0x07;
+
+	sh->irq = irq;
+	sh->io_port = base;
+	sh->n_io_port = FDOMAIN_REGION_SIZE;
+
+	fd = shost_priv(sh);
+	fd->base = base;
+	fd->chip = chip;
+	INIT_WORK(&fd->work, fdomain_work);
+
+	if (request_irq(irq, fdomain_irq, dev_is_pci(dev) ? IRQF_SHARED : 0,
+			  "fdomain", fd))
+		goto fail_put;
+
+	shost_printk(KERN_INFO, sh, "%s chip at 0x%x irq %d SCSI ID %d\n",
+		     dev_is_pci(dev) ? "TMC-36C70 (PCI bus)" : chip_names[chip],
+		     base, irq, sh->this_id);
+
+	if (scsi_add_host(sh, dev))
+		goto fail_free_irq;
+
+	scsi_scan_host(sh);
+
+	return sh;
+
+fail_free_irq:
+	free_irq(irq, fd);
+fail_put:
+	scsi_host_put(sh);
+	return NULL;
+}
+EXPORT_SYMBOL_GPL(fdomain_create);
+
+int fdomain_destroy(struct Scsi_Host *sh)
+{
+	struct fdomain *fd = shost_priv(sh);
+
+	cancel_work_sync(&fd->work);
+	scsi_remove_host(sh);
+	if (sh->irq)
+		free_irq(sh->irq, fd);
+	scsi_host_put(sh);
+	return 0;
+}
+EXPORT_SYMBOL_GPL(fdomain_destroy);
+
+#ifdef CONFIG_PM_SLEEP
+static int fdomain_resume(struct device *dev)
+{
+	struct fdomain *fd = shost_priv(dev_get_drvdata(dev));
+
+	fdomain_reset(fd->base);
+	return 0;
+}
+
+static SIMPLE_DEV_PM_OPS(fdomain_pm_ops, NULL, fdomain_resume);
+#endif /* CONFIG_PM_SLEEP */
+
+MODULE_AUTHOR("Ondrej Zary, Rickard E. Faith");
+MODULE_DESCRIPTION("Future Domain TMC-16x0/TMC-3260 SCSI driver");
+MODULE_LICENSE("GPL");

commit e184f2bf4d9f1a3c612a8c1d67e73e9cf8ab5ab9
Author: Christoph Hellwig <hch@lst.de>
Date:   Mon Mar 19 08:37:50 2018 +0100

    scsi: remove the fdomain and fdomain_cs drivers
    
    These drivers haven't seen any recent bug fixing and are two of the last
    drivers using the scsi_module.c infrastruture that has been deprecated
    15 years ago.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/fdomain.c b/drivers/scsi/fdomain.c
deleted file mode 100644
index ebbe5a3e665d..000000000000
--- a/drivers/scsi/fdomain.c
+++ /dev/null
@@ -1,1783 +0,0 @@
-/* fdomain.c -- Future Domain TMC-16x0 SCSI driver
- * Created: Sun May  3 18:53:19 1992 by faith@cs.unc.edu
- * Revised: Mon Dec 28 21:59:02 1998 by faith@acm.org
- * Author: Rickard E. Faith, faith@cs.unc.edu
- * Copyright 1992-1996, 1998 Rickard E. Faith (faith@acm.org)
- * Shared IRQ supported added 7/7/2001  Alan Cox <alan@lxorguk.ukuu.org.uk>
-
- * This program is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License as published by the
- * Free Software Foundation; either version 2, or (at your option) any
- * later version.
-
- * This program is distributed in the hope that it will be useful, but
- * WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * General Public License for more details.
-
- * You should have received a copy of the GNU General Public License along
- * with this program; if not, write to the Free Software Foundation, Inc.,
- * 675 Mass Ave, Cambridge, MA 02139, USA.
-
- **************************************************************************
-
- SUMMARY:
-
- Future Domain BIOS versions supported for autodetect:
-    2.0, 3.0, 3.2, 3.4 (1.0), 3.5 (2.0), 3.6, 3.61
- Chips are supported:
-    TMC-1800, TMC-18C50, TMC-18C30, TMC-36C70
- Boards supported:
-    Future Domain TMC-1650, TMC-1660, TMC-1670, TMC-1680, TMC-1610M/MER/MEX
-    Future Domain TMC-3260 (PCI)
-    Quantum ISA-200S, ISA-250MG
-    Adaptec AHA-2920A (PCI) [BUT *NOT* AHA-2920C -- use aic7xxx instead]
-    IBM ?
- LILO/INSMOD command-line options:
-    fdomain=<PORT_BASE>,<IRQ>[,<ADAPTER_ID>]
-
-
-    
- NOTE:
-
- The Adaptec AHA-2920C has an Adaptec AIC-7850 chip on it.
- Use the aic7xxx driver for this board.
-       
- The Adaptec AHA-2920A has a Future Domain chip on it, so this is the right
- driver for that card.  Unfortunately, the boxes will probably just say
- "2920", so you'll have to look on the card for a Future Domain logo, or a
- letter after the 2920.
-
- 
- 
- THANKS:
-
- Thanks to Adaptec for providing PCI boards for testing.  This finally
- enabled me to test the PCI detection and correct it for PCI boards that do
- not have a BIOS at a standard ISA location.  For PCI boards, LILO/INSMOD
- command-line options should no longer be needed.  --RF 18Nov98
-
-
- 
- DESCRIPTION:
- 
- This is the Linux low-level SCSI driver for Future Domain TMC-1660/1680
- TMC-1650/1670, and TMC-3260 SCSI host adapters.  The 1650 and 1670 have a
- 25-pin external connector, whereas the 1660 and 1680 have a SCSI-2 50-pin
- high-density external connector.  The 1670 and 1680 have floppy disk
- controllers built in.  The TMC-3260 is a PCI bus card.
-
- Future Domain's older boards are based on the TMC-1800 chip, and this
- driver was originally written for a TMC-1680 board with the TMC-1800 chip.
- More recently, boards are being produced with the TMC-18C50 and TMC-18C30
- chips.  The latest and greatest board may not work with this driver.  If
- you have to patch this driver so that it will recognize your board's BIOS
- signature, then the driver may fail to function after the board is
- detected.
-
- Please note that the drive ordering that Future Domain implemented in BIOS
- versions 3.4 and 3.5 is the opposite of the order (currently) used by the
- rest of the SCSI industry.  If you have BIOS version 3.4 or 3.5, and have
- more than one drive, then the drive ordering will be the reverse of that
- which you see under DOS.  For example, under DOS SCSI ID 0 will be D: and
- SCSI ID 1 will be C: (the boot device).  Under Linux, SCSI ID 0 will be
- /dev/sda and SCSI ID 1 will be /dev/sdb.  The Linux ordering is consistent
- with that provided by all the other SCSI drivers for Linux.  If you want
- this changed, you will probably have to patch the higher level SCSI code.
- If you do so, please send me patches that are protected by #ifdefs.
-
- If you have a TMC-8xx or TMC-9xx board, then this is not the driver for
- your board.  Please refer to the Seagate driver for more information and
- possible support.
-
- 
- 
- HISTORY:
-
- Linux       Driver      Driver
- Version     Version     Date         Support/Notes
-
-             0.0          3 May 1992  V2.0 BIOS; 1800 chip
- 0.97        1.9         28 Jul 1992
- 0.98.6      3.1         27 Nov 1992
- 0.99        3.2          9 Dec 1992
-
- 0.99.3      3.3         10 Jan 1993  V3.0 BIOS
- 0.99.5      3.5         18 Feb 1993
- 0.99.10     3.6         15 May 1993  V3.2 BIOS; 18C50 chip
- 0.99.11     3.17         3 Jul 1993  (now under RCS)
- 0.99.12     3.18        13 Aug 1993
- 0.99.14     5.6         31 Oct 1993  (reselection code removed)
-
- 0.99.15     5.9         23 Jan 1994  V3.4 BIOS (preliminary)
- 1.0.8/1.1.1 5.15         1 Apr 1994  V3.4 BIOS; 18C30 chip (preliminary)
- 1.0.9/1.1.3 5.16         7 Apr 1994  V3.4 BIOS; 18C30 chip
- 1.1.38      5.18        30 Jul 1994  36C70 chip (PCI version of 18C30)
- 1.1.62      5.20         2 Nov 1994  V3.5 BIOS
- 1.1.73      5.22         7 Dec 1994  Quantum ISA-200S board; V2.0 BIOS
-
- 1.1.82      5.26        14 Jan 1995  V3.5 BIOS; TMC-1610M/MER/MEX board
- 1.2.10      5.28         5 Jun 1995  Quantum ISA-250MG board; V2.0, V2.01 BIOS
- 1.3.4       5.31        23 Jun 1995  PCI BIOS-32 detection (preliminary)
- 1.3.7       5.33         4 Jul 1995  PCI BIOS-32 detection
- 1.3.28      5.36        17 Sep 1995  V3.61 BIOS; LILO command-line support
- 1.3.34      5.39        12 Oct 1995  V3.60 BIOS; /proc
- 1.3.72      5.39         8 Feb 1996  Adaptec AHA-2920 board
- 1.3.85      5.41         4 Apr 1996
- 2.0.12      5.44         8 Aug 1996  Use ID 7 for all PCI cards
- 2.1.1       5.45         2 Oct 1996  Update ROM accesses for 2.1.x
- 2.1.97      5.46	 23 Apr 1998  Rewritten PCI detection routines [mj]
- 2.1.11x     5.47	  9 Aug 1998  Touched for 8 SCSI disk majors support
-             5.48        18 Nov 1998  BIOS no longer needed for PCI detection
- 2.2.0       5.50        28 Dec 1998  Support insmod parameters
- 
-
- REFERENCES USED:
-
- "TMC-1800 SCSI Chip Specification (FDC-1800T)", Future Domain Corporation,
- 1990.
-
- "Technical Reference Manual: 18C50 SCSI Host Adapter Chip", Future Domain
- Corporation, January 1992.
-
- "LXT SCSI Products: Specifications and OEM Technical Manual (Revision
- B/September 1991)", Maxtor Corporation, 1991.
-
- "7213S product Manual (Revision P3)", Maxtor Corporation, 1992.
-
- "Draft Proposed American National Standard: Small Computer System
- Interface - 2 (SCSI-2)", Global Engineering Documents. (X3T9.2/86-109,
- revision 10h, October 17, 1991)
-
- Private communications, Drew Eckhardt (drew@cs.colorado.edu) and Eric
- Youngdale (ericy@cais.com), 1992.
-
- Private communication, Tuong Le (Future Domain Engineering department),
- 1994. (Disk geometry computations for Future Domain BIOS version 3.4, and
- TMC-18C30 detection.)
-
- Hogan, Thom. The Programmer's PC Sourcebook. Microsoft Press, 1988. Page
- 60 (2.39: Disk Partition Table Layout).
-
- "18C30 Technical Reference Manual", Future Domain Corporation, 1993, page
- 6-1.
-
-
- 
- NOTES ON REFERENCES:
-
- The Maxtor manuals were free.  Maxtor telephone technical support is
- great!
-
- The Future Domain manuals were $25 and $35.  They document the chip, not
- the TMC-16x0 boards, so some information I had to guess at.  In 1992,
- Future Domain sold DOS BIOS source for $250 and the UN*X driver source was
- $750, but these required a non-disclosure agreement, so even if I could
- have afforded them, they would *not* have been useful for writing this
- publicly distributable driver.  Future Domain technical support has
- provided some information on the phone and have sent a few useful FAXs.
- They have been much more helpful since they started to recognize that the
- word "Linux" refers to an operating system :-).
-
- 
-
- ALPHA TESTERS:
-
- There are many other alpha testers that come and go as the driver
- develops.  The people listed here were most helpful in times of greatest
- need (mostly early on -- I've probably left out a few worthy people in
- more recent times):
-
- Todd Carrico (todd@wutc.wustl.edu), Dan Poirier (poirier@cs.unc.edu ), Ken
- Corey (kenc@sol.acs.unt.edu), C. de Bruin (bruin@bruin@sterbbs.nl), Sakari
- Aaltonen (sakaria@vipunen.hit.fi), John Rice (rice@xanth.cs.odu.edu), Brad
- Yearwood (brad@optilink.com), and Ray Toy (toy@soho.crd.ge.com).
-
- Special thanks to Tien-Wan Yang (twyang@cs.uh.edu), who graciously lent me
- his 18C50-based card for debugging.  He is the sole reason that this
- driver works with the 18C50 chip.
-
- Thanks to Dave Newman (dnewman@crl.com) for providing initial patches for
- the version 3.4 BIOS.
-
- Thanks to James T. McKinley (mckinley@msupa.pa.msu.edu) for providing
- patches that support the TMC-3260, a PCI bus card with the 36C70 chip.
- The 36C70 chip appears to be "completely compatible" with the 18C30 chip.
-
- Thanks to Eric Kasten (tigger@petroglyph.cl.msu.edu) for providing the
- patch for the version 3.5 BIOS.
-
- Thanks for Stephen Henson (shenson@nyx10.cs.du.edu) for providing the
- patch for the Quantum ISA-200S SCSI adapter.
- 
- Thanks to Adam Bowen for the signature to the 1610M/MER/MEX scsi cards, to
- Martin Andrews (andrewm@ccfadm.eeg.ccf.org) for the signature to some
- random TMC-1680 repackaged by IBM; and to Mintak Ng (mintak@panix.com) for
- the version 3.61 BIOS signature.
-
- Thanks for Mark Singer (elf@netcom.com) and Richard Simpson
- (rsimpson@ewrcsdra.demon.co.uk) for more Quantum signatures and detective
- work on the Quantum RAM layout.
-
- Special thanks to James T. McKinley (mckinley@msupa.pa.msu.edu) for
- providing patches for proper PCI BIOS32-mediated detection of the TMC-3260
- card (a PCI bus card with the 36C70 chip).  Please send James PCI-related
- bug reports.
-
- Thanks to Tom Cavin (tec@usa1.com) for preliminary command-line option
- patches.
-
- New PCI detection code written by Martin Mares <mj@atrey.karlin.mff.cuni.cz>
-
- Insmod parameter code based on patches from Daniel Graham
- <graham@balance.uoregon.edu>. 
- 
- All of the alpha testers deserve much thanks.
-
-
-
- NOTES ON USER DEFINABLE OPTIONS:
-
- DEBUG: This turns on the printing of various debug information.
-
- ENABLE_PARITY: This turns on SCSI parity checking.  With the current
- driver, all attached devices must support SCSI parity.  If none of your
- devices support parity, then you can probably get the driver to work by
- turning this option off.  I have no way of testing this, however, and it
- would appear that no one ever uses this option.
-
- FIFO_COUNT: The host adapter has an 8K cache (host adapters based on the
- 18C30 chip have a 2k cache).  When this many 512 byte blocks are filled by
- the SCSI device, an interrupt will be raised.  Therefore, this could be as
- low as 0, or as high as 16.  Note, however, that values which are too high
- or too low seem to prevent any interrupts from occurring, and thereby lock
- up the machine.  I have found that 2 is a good number, but throughput may
- be increased by changing this value to values which are close to 2.
- Please let me know if you try any different values.
-
- RESELECTION: This is no longer an option, since I gave up trying to
- implement it in version 4.x of this driver.  It did not improve
- performance at all and made the driver unstable (because I never found one
- of the two race conditions which were introduced by the multiple
- outstanding command code).  The instability seems a very high price to pay
- just so that you don't have to wait for the tape to rewind.  If you want
- this feature implemented, send me patches.  I'll be happy to send a copy
- of my (broken) driver to anyone who would like to see a copy.
-
- **************************************************************************/
-
-#include <linux/module.h>
-#include <linux/init.h>
-#include <linux/interrupt.h>
-#include <linux/blkdev.h>
-#include <linux/spinlock.h>
-#include <linux/errno.h>
-#include <linux/string.h>
-#include <linux/ioport.h>
-#include <linux/proc_fs.h>
-#include <linux/pci.h>
-#include <linux/stat.h>
-#include <linux/delay.h>
-#include <linux/io.h>
-#include <linux/slab.h>
-#include <scsi/scsicam.h>
-
-
-#include <scsi/scsi.h>
-#include <scsi/scsi_cmnd.h>
-#include <scsi/scsi_device.h>
-#include <scsi/scsi_host.h>
-#include <scsi/scsi_ioctl.h>
-#include "fdomain.h"
-
-#ifndef PCMCIA
-MODULE_AUTHOR("Rickard E. Faith");
-MODULE_DESCRIPTION("Future domain SCSI driver");
-MODULE_LICENSE("GPL");
-#endif
-
-  
-#define VERSION          "$Revision: 5.51 $"
-
-/* START OF USER DEFINABLE OPTIONS */
-
-#define DEBUG            0	/* Enable debugging output */
-#define ENABLE_PARITY    1	/* Enable SCSI Parity */
-#define FIFO_COUNT       2	/* Number of 512 byte blocks before INTR */
-
-/* END OF USER DEFINABLE OPTIONS */
-
-#if DEBUG
-#define EVERY_ACCESS     0	/* Write a line on every scsi access */
-#define ERRORS_ONLY      1	/* Only write a line if there is an error */
-#define DEBUG_DETECT     0	/* Debug fdomain_16x0_detect() */
-#define DEBUG_MESSAGES   1	/* Debug MESSAGE IN phase */
-#define DEBUG_ABORT      1	/* Debug abort() routine */
-#define DEBUG_RESET      1	/* Debug reset() routine */
-#define DEBUG_RACE       1      /* Debug interrupt-driven race condition */
-#else
-#define EVERY_ACCESS     0	/* LEAVE THESE ALONE--CHANGE THE ONES ABOVE */
-#define ERRORS_ONLY      0
-#define DEBUG_DETECT     0
-#define DEBUG_MESSAGES   0
-#define DEBUG_ABORT      0
-#define DEBUG_RESET      0
-#define DEBUG_RACE       0
-#endif
-
-/* Errors are reported on the line, so we don't need to report them again */
-#if EVERY_ACCESS
-#undef ERRORS_ONLY
-#define ERRORS_ONLY      0
-#endif
-
-#if ENABLE_PARITY
-#define PARITY_MASK      0x08
-#else
-#define PARITY_MASK      0x00
-#endif
-
-enum chip_type {
-   unknown          = 0x00,
-   tmc1800          = 0x01,
-   tmc18c50         = 0x02,
-   tmc18c30         = 0x03,
-};
-
-enum {
-   in_arbitration   = 0x02,
-   in_selection     = 0x04,
-   in_other         = 0x08,
-   disconnect       = 0x10,
-   aborted          = 0x20,
-   sent_ident       = 0x40,
-};
-
-enum in_port_type {
-   Read_SCSI_Data   =  0,
-   SCSI_Status      =  1,
-   TMC_Status       =  2,
-   FIFO_Status      =  3,	/* tmc18c50/tmc18c30 only */
-   Interrupt_Cond   =  4,	/* tmc18c50/tmc18c30 only */
-   LSB_ID_Code      =  5,
-   MSB_ID_Code      =  6,
-   Read_Loopback    =  7,
-   SCSI_Data_NoACK  =  8,
-   Interrupt_Status =  9,
-   Configuration1   = 10,
-   Configuration2   = 11,	/* tmc18c50/tmc18c30 only */
-   Read_FIFO        = 12,
-   FIFO_Data_Count  = 14
-};
-
-enum out_port_type {
-   Write_SCSI_Data  =  0,
-   SCSI_Cntl        =  1,
-   Interrupt_Cntl   =  2,
-   SCSI_Mode_Cntl   =  3,
-   TMC_Cntl         =  4,
-   Memory_Cntl      =  5,	/* tmc18c50/tmc18c30 only */
-   Write_Loopback   =  7,
-   IO_Control       = 11,	/* tmc18c30 only */
-   Write_FIFO       = 12
-};
-
-/* .bss will zero all the static variables below */
-static int               port_base;
-static unsigned long     bios_base;
-static void __iomem *    bios_mem;
-static int               bios_major;
-static int               bios_minor;
-static int               PCI_bus;
-#ifdef CONFIG_PCI
-static struct pci_dev	*PCI_dev;
-#endif
-static int               Quantum;	/* Quantum board variant */
-static int               interrupt_level;
-static volatile int      in_command;
-static struct scsi_cmnd  *current_SC;
-static enum chip_type    chip              = unknown;
-static int               adapter_mask;
-static int               this_id;
-static int               setup_called;
-
-#if DEBUG_RACE
-static volatile int      in_interrupt_flag;
-#endif
-
-static int               FIFO_Size = 0x2000; /* 8k FIFO for
-						pre-tmc18c30 chips */
-
-static irqreturn_t       do_fdomain_16x0_intr( int irq, void *dev_id );
-/* Allow insmod parameters to be like LILO parameters.  For example:
-   insmod fdomain fdomain=0x140,11 */
-static char * fdomain = NULL;
-module_param(fdomain, charp, 0);
-
-#ifndef PCMCIA
-
-static unsigned long addresses[] = {
-   0xc8000,
-   0xca000,
-   0xce000,
-   0xde000,
-   0xcc000,		/* Extra addresses for PCI boards */
-   0xd0000,
-   0xe0000,
-};
-#define ADDRESS_COUNT ARRAY_SIZE(addresses)
-
-static unsigned short ports[] = { 0x140, 0x150, 0x160, 0x170 };
-#define PORT_COUNT ARRAY_SIZE(ports)
-
-static unsigned short ints[] = { 3, 5, 10, 11, 12, 14, 15, 0 };
-
-#endif /* !PCMCIA */
-
-/*
-
-  READ THIS BEFORE YOU ADD A SIGNATURE!
-
-  READING THIS SHORT NOTE CAN SAVE YOU LOTS OF TIME!
-
-  READ EVERY WORD, ESPECIALLY THE WORD *NOT*
-
-  This driver works *ONLY* for Future Domain cards using the TMC-1800,
-  TMC-18C50, or TMC-18C30 chip.  This includes models TMC-1650, 1660, 1670,
-  and 1680.  These are all 16-bit cards.
-
-  The following BIOS signature signatures are for boards which do *NOT*
-  work with this driver (these TMC-8xx and TMC-9xx boards may work with the
-  Seagate driver):
-
-  FUTURE DOMAIN CORP. (C) 1986-1988 V4.0I 03/16/88
-  FUTURE DOMAIN CORP. (C) 1986-1989 V5.0C2/14/89
-  FUTURE DOMAIN CORP. (C) 1986-1989 V6.0A7/28/89
-  FUTURE DOMAIN CORP. (C) 1986-1990 V6.0105/31/90
-  FUTURE DOMAIN CORP. (C) 1986-1990 V6.0209/18/90
-  FUTURE DOMAIN CORP. (C) 1986-1990 V7.009/18/90
-  FUTURE DOMAIN CORP. (C) 1992 V8.00.004/02/92
-
-  (The cards which do *NOT* work are all 8-bit cards -- although some of
-  them have a 16-bit form-factor, the upper 8-bits are used only for IRQs
-  and are *NOT* used for data.  You can tell the difference by following
-  the tracings on the circuit board -- if only the IRQ lines are involved,
-  you have a "8-bit" card, and should *NOT* use this driver.)
-
-*/
-
-#ifndef PCMCIA
-
-static struct signature {
-   const char *signature;
-   int  sig_offset;
-   int  sig_length;
-   int  major_bios_version;
-   int  minor_bios_version;
-   int  flag; /* 1 == PCI_bus, 2 == ISA_200S, 3 == ISA_250MG, 4 == ISA_200S */
-} signatures[] = {
-   /*          1         2         3         4         5         6 */
-   /* 123456789012345678901234567890123456789012345678901234567890 */
-   { "FUTURE DOMAIN CORP. (C) 1986-1990 1800-V2.07/28/89",  5, 50,  2,  0, 0 },
-   { "FUTURE DOMAIN CORP. (C) 1986-1990 1800-V1.07/28/89",  5, 50,  2,  0, 0 },
-   { "FUTURE DOMAIN CORP. (C) 1986-1990 1800-V2.07/28/89", 72, 50,  2,  0, 2 },
-   { "FUTURE DOMAIN CORP. (C) 1986-1990 1800-V2.0",        73, 43,  2,  0, 3 },
-   { "FUTURE DOMAIN CORP. (C) 1991 1800-V2.0.",            72, 39,  2,  0, 4 },
-   { "FUTURE DOMAIN CORP. (C) 1992 V3.00.004/02/92",        5, 44,  3,  0, 0 },
-   { "FUTURE DOMAIN TMC-18XX (C) 1993 V3.203/12/93",        5, 44,  3,  2, 0 },
-   { "IBM F1 P2 BIOS v1.0104/29/93",                        5, 28,  3, -1, 0 },
-   { "Future Domain Corp. V1.0008/18/93",                   5, 33,  3,  4, 0 },
-   { "Future Domain Corp. V1.0008/18/93",                  26, 33,  3,  4, 1 },
-   { "Adaptec AHA-2920 PCI-SCSI Card",                     42, 31,  3, -1, 1 },
-   { "IBM F1 P264/32",                                      5, 14,  3, -1, 1 },
-				/* This next signature may not be a 3.5 bios */
-   { "Future Domain Corp. V2.0108/18/93",                   5, 33,  3,  5, 0 },
-   { "FUTURE DOMAIN CORP.  V3.5008/18/93",                  5, 34,  3,  5, 0 },
-   { "FUTURE DOMAIN 18c30/18c50/1800 (C) 1994 V3.5",        5, 44,  3,  5, 0 },
-   { "FUTURE DOMAIN CORP.  V3.6008/18/93",                  5, 34,  3,  6, 0 },
-   { "FUTURE DOMAIN CORP.  V3.6108/18/93",                  5, 34,  3,  6, 0 },
-   { "FUTURE DOMAIN TMC-18XX",                              5, 22, -1, -1, 0 },
-
-   /* READ NOTICE ABOVE *BEFORE* YOU WASTE YOUR TIME ADDING A SIGNATURE
-    Also, fix the disk geometry code for your signature and send your
-    changes for faith@cs.unc.edu.  Above all, do *NOT* change any old
-    signatures!
-
-    Note that the last line will match a "generic" 18XX bios.  Because
-    Future Domain has changed the host SCSI ID and/or the location of the
-    geometry information in the on-board RAM area for each of the first
-    three BIOS's, it is still important to enter a fully qualified
-    signature in the table for any new BIOS's (after the host SCSI ID and
-    geometry location are verified). */
-};
-
-#define SIGNATURE_COUNT ARRAY_SIZE(signatures)
-
-#endif /* !PCMCIA */
-
-static void print_banner( struct Scsi_Host *shpnt )
-{
-   if (!shpnt) return;		/* This won't ever happen */
-
-   if (bios_major < 0 && bios_minor < 0) {
-      printk(KERN_INFO "scsi%d: <fdomain> No BIOS; using scsi id %d\n",
-	      shpnt->host_no, shpnt->this_id);
-   } else {
-      printk(KERN_INFO "scsi%d: <fdomain> BIOS version ", shpnt->host_no);
-
-      if (bios_major >= 0) printk("%d.", bios_major);
-      else                 printk("?.");
-
-      if (bios_minor >= 0) printk("%d", bios_minor);
-      else                 printk("?.");
-
-      printk( " at 0x%lx using scsi id %d\n",
-	      bios_base, shpnt->this_id );
-   }
-
-				/* If this driver works for later FD PCI
-				   boards, we will have to modify banner
-				   for additional PCI cards, but for now if
-				   it's PCI it's a TMC-3260 - JTM */
-   printk(KERN_INFO "scsi%d: <fdomain> %s chip at 0x%x irq ",
-	   shpnt->host_no,
-	   chip == tmc1800 ? "TMC-1800" : (chip == tmc18c50 ? "TMC-18C50" : (chip == tmc18c30 ? (PCI_bus ? "TMC-36C70 (PCI bus)" : "TMC-18C30") : "Unknown")),
-	   port_base);
-
-   if (interrupt_level)
-   	printk("%d", interrupt_level);
-   else
-        printk("<none>");
-
-   printk( "\n" );
-}
-
-int fdomain_setup(char *str)
-{
-	int ints[4];
-
-	(void)get_options(str, ARRAY_SIZE(ints), ints);
-
-	if (setup_called++ || ints[0] < 2 || ints[0] > 3) {
-		printk(KERN_INFO "scsi: <fdomain> Usage: fdomain=<PORT_BASE>,<IRQ>[,<ADAPTER_ID>]\n");
-		printk(KERN_ERR "scsi: <fdomain> Bad LILO/INSMOD parameters?\n");
-		return 0;
-	}
-
-	port_base       = ints[0] >= 1 ? ints[1] : 0;
-	interrupt_level = ints[0] >= 2 ? ints[2] : 0;
-	this_id         = ints[0] >= 3 ? ints[3] : 0;
-   
-	bios_major = bios_minor = -1; /* Use geometry for BIOS version >= 3.4 */
-	++setup_called;
-	return 1;
-}
-
-__setup("fdomain=", fdomain_setup);
-
-
-static void do_pause(unsigned amount)	/* Pause for amount*10 milliseconds */
-{
-	mdelay(10*amount);
-}
-
-static inline void fdomain_make_bus_idle( void )
-{
-   outb(0, port_base + SCSI_Cntl);
-   outb(0, port_base + SCSI_Mode_Cntl);
-   if (chip == tmc18c50 || chip == tmc18c30)
-	 outb(0x21 | PARITY_MASK, port_base + TMC_Cntl); /* Clear forced intr. */
-   else
-	 outb(0x01 | PARITY_MASK, port_base + TMC_Cntl);
-}
-
-static int fdomain_is_valid_port( int port )
-{
-#if DEBUG_DETECT 
-   printk( " (%x%x),",
-	   inb( port + MSB_ID_Code ), inb( port + LSB_ID_Code ) );
-#endif
-
-   /* The MCA ID is a unique id for each MCA compatible board.  We
-      are using ISA boards, but Future Domain provides the MCA ID
-      anyway.  We can use this ID to ensure that this is a Future
-      Domain TMC-1660/TMC-1680.
-    */
-
-   if (inb( port + LSB_ID_Code ) != 0xe9) { /* test for 0x6127 id */
-      if (inb( port + LSB_ID_Code ) != 0x27) return 0;
-      if (inb( port + MSB_ID_Code ) != 0x61) return 0;
-      chip = tmc1800;
-   } else {				    /* test for 0xe960 id */
-      if (inb( port + MSB_ID_Code ) != 0x60) return 0;
-      chip = tmc18c50;
-
-				/* Try to toggle 32-bit mode.  This only
-				   works on an 18c30 chip.  (User reports
-				   say this works, so we should switch to
-				   it in the near future.) */
-
-      outb( 0x80, port + IO_Control );
-      if ((inb( port + Configuration2 ) & 0x80) == 0x80) {
-	 outb( 0x00, port + IO_Control );
-	 if ((inb( port + Configuration2 ) & 0x80) == 0x00) {
-	    chip = tmc18c30;
-	    FIFO_Size = 0x800;	/* 2k FIFO */
-	 }
-      }
-				/* If that failed, we are an 18c50. */
-   }
-
-   return 1;
-}
-
-static int fdomain_test_loopback( void )
-{
-   int i;
-   int result;
-
-   for (i = 0; i < 255; i++) {
-      outb( i, port_base + Write_Loopback );
-      result = inb( port_base + Read_Loopback );
-      if (i != result)
-	    return 1;
-   }
-   return 0;
-}
-
-#ifndef PCMCIA
-
-/* fdomain_get_irq assumes that we have a valid MCA ID for a
-   TMC-1660/TMC-1680 Future Domain board.  Now, check to be sure the
-   bios_base matches these ports.  If someone was unlucky enough to have
-   purchased more than one Future Domain board, then they will have to
-   modify this code, as we only detect one board here.  [The one with the
-   lowest bios_base.]
-
-   Note that this routine is only used for systems without a PCI BIOS32
-   (e.g., ISA bus).  For PCI bus systems, this routine will likely fail
-   unless one of the IRQs listed in the ints array is used by the board.
-   Sometimes it is possible to use the computer's BIOS setup screen to
-   configure a PCI system so that one of these IRQs will be used by the
-   Future Domain card. */
-
-static int fdomain_get_irq( int base )
-{
-   int options = inb(base + Configuration1);
-
-#if DEBUG_DETECT
-   printk("scsi: <fdomain> Options = %x\n", options);
-#endif
- 
-   /* Check for board with lowest bios_base --
-      this isn't valid for the 18c30 or for
-      boards on the PCI bus, so just assume we
-      have the right board. */
-
-   if (chip != tmc18c30 && !PCI_bus && addresses[(options & 0xc0) >> 6 ] != bios_base)
-   	return 0;
-   return ints[(options & 0x0e) >> 1];
-}
-
-static int fdomain_isa_detect( int *irq, int *iobase )
-{
-   int i, j;
-   int base = 0xdeadbeef;
-   int flag = 0;
-
-#if DEBUG_DETECT
-   printk( "scsi: <fdomain> fdomain_isa_detect:" );
-#endif
-
-   for (i = 0; i < ADDRESS_COUNT; i++) {
-      void __iomem *p = ioremap(addresses[i], 0x2000);
-      if (!p)
-	continue;
-#if DEBUG_DETECT
-      printk( " %lx(%lx),", addresses[i], bios_base );
-#endif
-      for (j = 0; j < SIGNATURE_COUNT; j++) {
-	 if (check_signature(p + signatures[j].sig_offset,
-			     signatures[j].signature,
-			     signatures[j].sig_length )) {
-	    bios_major = signatures[j].major_bios_version;
-	    bios_minor = signatures[j].minor_bios_version;
-	    PCI_bus    = (signatures[j].flag == 1);
-	    Quantum    = (signatures[j].flag > 1) ? signatures[j].flag : 0;
-	    bios_base  = addresses[i];
-	    bios_mem   = p;
-	    goto found;
-	 }
-      }
-      iounmap(p);
-   }
- 
-found:
-   if (bios_major == 2) {
-      /* The TMC-1660/TMC-1680 has a RAM area just after the BIOS ROM.
-	 Assuming the ROM is enabled (otherwise we wouldn't have been
-	 able to read the ROM signature :-), then the ROM sets up the
-	 RAM area with some magic numbers, such as a list of port
-	 base addresses and a list of the disk "geometry" reported to
-	 DOS (this geometry has nothing to do with physical geometry).
-       */
-
-      switch (Quantum) {
-      case 2:			/* ISA_200S */
-      case 3:			/* ISA_250MG */
-	 base = readb(bios_mem + 0x1fa2) + (readb(bios_mem + 0x1fa3) << 8);
-	 break;
-      case 4:			/* ISA_200S (another one) */
-	 base = readb(bios_mem + 0x1fa3) + (readb(bios_mem + 0x1fa4) << 8);
-	 break;
-      default:
-	 base = readb(bios_mem + 0x1fcc) + (readb(bios_mem + 0x1fcd) << 8);
-	 break;
-      }
-   
-#if DEBUG_DETECT
-      printk( " %x,", base );
-#endif
-
-      for (i = 0; i < PORT_COUNT; i++) {
-	if (base == ports[i]) {
-		if (!request_region(base, 0x10, "fdomain"))
-			break;
-		if (!fdomain_is_valid_port(base)) {
-			release_region(base, 0x10);
-			break;
-		}
-		*irq    = fdomain_get_irq( base );
-		*iobase = base;
-		return 1;
-	}
-      }
-
-      /* This is a bad sign.  It usually means that someone patched the
-	 BIOS signature list (the signatures variable) to contain a BIOS
-	 signature for a board *OTHER THAN* the TMC-1660/TMC-1680. */
-      
-#if DEBUG_DETECT
-      printk( " RAM FAILED, " );
-#endif
-   }
-
-   /* Anyway, the alternative to finding the address in the RAM is to just
-      search through every possible port address for one that is attached
-      to the Future Domain card.  Don't panic, though, about reading all
-      these random port addresses -- there are rumors that the Future
-      Domain BIOS does something very similar.
-
-      Do not, however, check ports which the kernel knows are being used by
-      another driver. */
-
-   for (i = 0; i < PORT_COUNT; i++) {
-      base = ports[i];
-      if (!request_region(base, 0x10, "fdomain")) {
-#if DEBUG_DETECT
-	 printk( " (%x inuse),", base );
-#endif
-	 continue;
-      }
-#if DEBUG_DETECT
-      printk( " %x,", base );
-#endif
-      flag = fdomain_is_valid_port(base);
-      if (flag)
-	break;
-      release_region(base, 0x10);
-   }
-
-#if DEBUG_DETECT
-   if (flag) printk( " SUCCESS\n" );
-   else      printk( " FAILURE\n" );
-#endif
-
-   if (!flag) return 0;		/* iobase not found */
-
-   *irq    = fdomain_get_irq( base );
-   *iobase = base;
-
-   return 1;			/* success */
-}
-
-#else /* PCMCIA */
-
-static int fdomain_isa_detect( int *irq, int *iobase )
-{
-	if (irq)
-		*irq = 0;
-	if (iobase)
-		*iobase = 0;
-	return 0;
-}
-
-#endif /* !PCMCIA */
-
-
-/* PCI detection function: int fdomain_pci_bios_detect(int* irq, int*
-   iobase) This function gets the Interrupt Level and I/O base address from
-   the PCI configuration registers. */
-
-#ifdef CONFIG_PCI
-static int fdomain_pci_bios_detect( int *irq, int *iobase, struct pci_dev **ret_pdev )
-{
-   unsigned int     pci_irq;                /* PCI interrupt line */
-   unsigned long    pci_base;               /* PCI I/O base address */
-   struct pci_dev   *pdev = NULL;
-
-#if DEBUG_DETECT
-   /* Tell how to print a list of the known PCI devices from bios32 and
-      list vendor and device IDs being used if in debug mode.  */
-      
-   printk( "scsi: <fdomain> INFO: use lspci -v to see list of PCI devices\n" );
-   printk( "scsi: <fdomain> TMC-3260 detect:"
-	   " Using Vendor ID: 0x%x and Device ID: 0x%x\n",
-	   PCI_VENDOR_ID_FD, 
-	   PCI_DEVICE_ID_FD_36C70 );
-#endif 
-
-   if ((pdev = pci_get_device(PCI_VENDOR_ID_FD, PCI_DEVICE_ID_FD_36C70, pdev)) == NULL)
-		return 0;
-   if (pci_enable_device(pdev))
-   	goto fail;
-       
-#if DEBUG_DETECT
-   printk( "scsi: <fdomain> TMC-3260 detect:"
-	   " PCI bus %u, device %u, function %u\n",
-	   pdev->bus->number,
-	   PCI_SLOT(pdev->devfn),
-	   PCI_FUNC(pdev->devfn));
-#endif
-
-   /* We now have the appropriate device function for the FD board so we
-      just read the PCI config info from the registers.  */
-
-   pci_base = pci_resource_start(pdev, 0);
-   pci_irq = pdev->irq;
-
-   if (!request_region( pci_base, 0x10, "fdomain" ))
-   	goto fail;
-
-   /* Now we have the I/O base address and interrupt from the PCI
-      configuration registers. */
-
-   *irq    = pci_irq;
-   *iobase = pci_base;
-   *ret_pdev = pdev;
-
-#if DEBUG_DETECT
-   printk( "scsi: <fdomain> TMC-3260 detect:"
-	   " IRQ = %d, I/O base = 0x%x [0x%lx]\n", *irq, *iobase, pci_base );
-#endif
-
-   if (!fdomain_is_valid_port(pci_base)) {
-      printk(KERN_ERR "scsi: <fdomain> PCI card detected, but driver not loaded (invalid port)\n" );
-      release_region(pci_base, 0x10);
-      goto fail;
-   }
-
-				/* Fill in a few global variables.  Ugh. */
-   bios_major = bios_minor = -1;
-   PCI_bus    = 1;
-   PCI_dev    = pdev;
-   Quantum    = 0;
-   bios_base  = 0;
-   
-   return 1;
-fail:
-   pci_dev_put(pdev);
-   return 0;
-}
-
-#endif
-
-struct Scsi_Host *__fdomain_16x0_detect(struct scsi_host_template *tpnt )
-{
-   int              retcode;
-   struct Scsi_Host *shpnt;
-   struct pci_dev *pdev = NULL;
-
-   if (setup_called) {
-#if DEBUG_DETECT
-      printk( "scsi: <fdomain> No BIOS, using port_base = 0x%x, irq = %d\n",
-	      port_base, interrupt_level );
-#endif
-      if (!request_region(port_base, 0x10, "fdomain")) {
-	 printk( "scsi: <fdomain> port 0x%x is busy\n", port_base );
-	 printk( "scsi: <fdomain> Bad LILO/INSMOD parameters?\n" );
-	 return NULL;
-      }
-      if (!fdomain_is_valid_port( port_base )) {
-	 printk( "scsi: <fdomain> Cannot locate chip at port base 0x%x\n",
-		 port_base );
-	 printk( "scsi: <fdomain> Bad LILO/INSMOD parameters?\n" );
-	 release_region(port_base, 0x10);
-	 return NULL;
-      }
-   } else {
-      int flag = 0;
-
-#ifdef CONFIG_PCI
-				/* Try PCI detection first */
-      flag = fdomain_pci_bios_detect( &interrupt_level, &port_base, &pdev );
-#endif
-      if (!flag) {
-				/* Then try ISA bus detection */
-	 flag = fdomain_isa_detect( &interrupt_level, &port_base );
-
-	 if (!flag) {
-	    printk( "scsi: <fdomain> Detection failed (no card)\n" );
-	    return NULL;
-	 }
-      }
-   }
-
-   fdomain_16x0_host_reset(NULL);
-
-   if (fdomain_test_loopback()) {
-      printk(KERN_ERR  "scsi: <fdomain> Detection failed (loopback test failed at port base 0x%x)\n", port_base);
-      if (setup_called) {
-	 printk(KERN_ERR "scsi: <fdomain> Bad LILO/INSMOD parameters?\n");
-      }
-      goto fail;
-   }
-
-   if (this_id) {
-      tpnt->this_id = (this_id & 0x07);
-      adapter_mask  = (1 << tpnt->this_id);
-   } else {
-      if (PCI_bus || (bios_major == 3 && bios_minor >= 2) || bios_major < 0) {
-	 tpnt->this_id = 7;
-	 adapter_mask  = 0x80;
-      } else {
-	 tpnt->this_id = 6;
-	 adapter_mask  = 0x40;
-      }
-   }
-
-/* Print out a banner here in case we can't
-   get resources.  */
-
-   shpnt = scsi_register( tpnt, 0 );
-   if(shpnt == NULL) {
-	release_region(port_base, 0x10);
-   	return NULL;
-   }
-   shpnt->irq = interrupt_level;
-   shpnt->io_port = port_base;
-   shpnt->n_io_port = 0x10;
-   print_banner( shpnt );
-
-   /* Log IRQ with kernel */   
-   if (!interrupt_level) {
-      printk(KERN_ERR "scsi: <fdomain> Card Detected, but driver not loaded (no IRQ)\n" );
-      goto fail;
-   } else {
-      /* Register the IRQ with the kernel */
-
-      retcode = request_irq( interrupt_level,
-			     do_fdomain_16x0_intr, pdev?IRQF_SHARED:0, "fdomain", shpnt);
-
-      if (retcode < 0) {
-	 if (retcode == -EINVAL) {
-	    printk(KERN_ERR "scsi: <fdomain> IRQ %d is bad!\n", interrupt_level );
-	    printk(KERN_ERR "                This shouldn't happen!\n" );
-	    printk(KERN_ERR "                Send mail to faith@acm.org\n" );
-	 } else if (retcode == -EBUSY) {
-	    printk(KERN_ERR "scsi: <fdomain> IRQ %d is already in use!\n", interrupt_level );
-	    printk(KERN_ERR "                Please use another IRQ!\n" );
-	 } else {
-	    printk(KERN_ERR "scsi: <fdomain> Error getting IRQ %d\n", interrupt_level );
-	    printk(KERN_ERR "                This shouldn't happen!\n" );
-	    printk(KERN_ERR "                Send mail to faith@acm.org\n" );
-	 }
-	 printk(KERN_ERR "scsi: <fdomain> Detected, but driver not loaded (IRQ)\n" );
-	 goto fail;
-      }
-   }
-   return shpnt;
-fail:
-   pci_dev_put(pdev);
-   release_region(port_base, 0x10);
-   return NULL;
-}
-
-static int fdomain_16x0_detect(struct scsi_host_template *tpnt)
-{
-	if (fdomain)
-		fdomain_setup(fdomain);
-	return (__fdomain_16x0_detect(tpnt) != NULL);
-}
-
-static const char *fdomain_16x0_info( struct Scsi_Host *ignore )
-{
-   static char buffer[128];
-   char        *pt;
-   
-   strcpy( buffer, "Future Domain 16-bit SCSI Driver Version" );
-   if (strchr( VERSION, ':')) { /* Assume VERSION is an RCS Revision string */
-      strcat( buffer, strchr( VERSION, ':' ) + 1 );
-      pt = strrchr( buffer, '$') - 1;
-      if (!pt)  		/* Stripped RCS Revision string? */
-	    pt = buffer + strlen( buffer ) - 1;
-      if (*pt != ' ')
-	    ++pt;
-      *pt = '\0';
-   } else {			/* Assume VERSION is a number */
-      strcat( buffer, " " VERSION );
-   }
-      
-   return buffer;
-}
-
-#if 0
-static int fdomain_arbitrate( void )
-{
-   int           status = 0;
-   unsigned long timeout;
-
-#if EVERY_ACCESS
-   printk( "fdomain_arbitrate()\n" );
-#endif
-   
-   outb(0x00, port_base + SCSI_Cntl);              /* Disable data drivers */
-   outb(adapter_mask, port_base + SCSI_Data_NoACK); /* Set our id bit */
-   outb(0x04 | PARITY_MASK, port_base + TMC_Cntl); /* Start arbitration */
-
-   timeout = 500;
-   do {
-      status = inb(port_base + TMC_Status);        /* Read adapter status */
-      if (status & 0x02)		      /* Arbitration complete */
-	    return 0;
-      mdelay(1);			/* Wait one millisecond */
-   } while (--timeout);
-
-   /* Make bus idle */
-   fdomain_make_bus_idle();
-
-#if EVERY_ACCESS
-   printk( "Arbitration failed, status = %x\n", status );
-#endif
-#if ERRORS_ONLY
-   printk( "scsi: <fdomain> Arbitration failed, status = %x\n", status );
-#endif
-   return 1;
-}
-#endif
-
-static int fdomain_select( int target )
-{
-   int           status;
-   unsigned long timeout;
-#if ERRORS_ONLY
-   static int    flag = 0;
-#endif
-
-   outb(0x82, port_base + SCSI_Cntl); /* Bus Enable + Select */
-   outb(adapter_mask | (1 << target), port_base + SCSI_Data_NoACK);
-
-   /* Stop arbitration and enable parity */
-   outb(PARITY_MASK, port_base + TMC_Cntl); 
-
-   timeout = 350;			/* 350 msec */
-
-   do {
-      status = inb(port_base + SCSI_Status); /* Read adapter status */
-      if (status & 1) {			/* Busy asserted */
-	 /* Enable SCSI Bus (on error, should make bus idle with 0) */
-	 outb(0x80, port_base + SCSI_Cntl);
-	 return 0;
-      }
-      mdelay(1);			/* wait one msec */
-   } while (--timeout);
-   /* Make bus idle */
-   fdomain_make_bus_idle();
-#if EVERY_ACCESS
-   if (!target) printk( "Selection failed\n" );
-#endif
-#if ERRORS_ONLY
-   if (!target) {
-      if (!flag) /* Skip first failure for all chips. */
-	    ++flag;
-      else
-	    printk( "scsi: <fdomain> Selection failed\n" );
-   }
-#endif
-   return 1;
-}
-
-static void my_done(int error)
-{
-   if (in_command) {
-      in_command = 0;
-      outb(0x00, port_base + Interrupt_Cntl);
-      fdomain_make_bus_idle();
-      current_SC->result = error;
-      if (current_SC->scsi_done)
-	    current_SC->scsi_done( current_SC );
-      else panic( "scsi: <fdomain> current_SC->scsi_done() == NULL" );
-   } else {
-      panic( "scsi: <fdomain> my_done() called outside of command\n" );
-   }
-#if DEBUG_RACE
-   in_interrupt_flag = 0;
-#endif
-}
-
-static irqreturn_t do_fdomain_16x0_intr(int irq, void *dev_id)
-{
-   unsigned long flags;
-   int      status;
-   int      done = 0;
-   unsigned data_count;
-
-				/* The fdomain_16x0_intr is only called via
-				   the interrupt handler.  The goal of the
-				   sti() here is to allow other
-				   interruptions while this routine is
-				   running. */
-
-   /* Check for other IRQ sources */
-   if ((inb(port_base + TMC_Status) & 0x01) == 0)
-   	return IRQ_NONE;
-
-   /* It is our IRQ */   	
-   outb(0x00, port_base + Interrupt_Cntl);
-
-   /* We usually have one spurious interrupt after each command.  Ignore it. */
-   if (!in_command || !current_SC) {	/* Spurious interrupt */
-#if EVERY_ACCESS
-      printk( "Spurious interrupt, in_command = %d, current_SC = %x\n",
-	      in_command, current_SC );
-#endif
-      return IRQ_NONE;
-   }
-
-   /* Abort calls my_done, so we do nothing here. */
-   if (current_SC->SCp.phase & aborted) {
-#if DEBUG_ABORT
-      printk( "scsi: <fdomain> Interrupt after abort, ignoring\n" );
-#endif
-      /*
-      return IRQ_HANDLED; */
-   }
-
-#if DEBUG_RACE
-   ++in_interrupt_flag;
-#endif
-
-   if (current_SC->SCp.phase & in_arbitration) {
-      status = inb(port_base + TMC_Status);        /* Read adapter status */
-      if (!(status & 0x02)) {
-#if EVERY_ACCESS
-	 printk( " AFAIL " );
-#endif
-         spin_lock_irqsave(current_SC->device->host->host_lock, flags);
-	 my_done( DID_BUS_BUSY << 16 );
-         spin_unlock_irqrestore(current_SC->device->host->host_lock, flags);
-	 return IRQ_HANDLED;
-      }
-      current_SC->SCp.phase = in_selection;
-      
-      outb(0x40 | FIFO_COUNT, port_base + Interrupt_Cntl);
-
-      outb(0x82, port_base + SCSI_Cntl); /* Bus Enable + Select */
-      outb(adapter_mask | (1 << scmd_id(current_SC)), port_base + SCSI_Data_NoACK);
-      
-      /* Stop arbitration and enable parity */
-      outb(0x10 | PARITY_MASK, port_base + TMC_Cntl);
-#if DEBUG_RACE
-      in_interrupt_flag = 0;
-#endif
-      return IRQ_HANDLED;
-   } else if (current_SC->SCp.phase & in_selection) {
-      status = inb(port_base + SCSI_Status);
-      if (!(status & 0x01)) {
-	 /* Try again, for slow devices */
-	 if (fdomain_select( scmd_id(current_SC) )) {
-#if EVERY_ACCESS
-	    printk( " SFAIL " );
-#endif
-            spin_lock_irqsave(current_SC->device->host->host_lock, flags);
-	    my_done( DID_NO_CONNECT << 16 );
-            spin_unlock_irqrestore(current_SC->device->host->host_lock, flags);
-	    return IRQ_HANDLED;
-	 } else {
-#if EVERY_ACCESS
-	    printk( " AltSel " );
-#endif
-	    /* Stop arbitration and enable parity */
-	    outb(0x10 | PARITY_MASK, port_base + TMC_Cntl);
-	 }
-      }
-      current_SC->SCp.phase = in_other;
-      outb(0x90 | FIFO_COUNT, port_base + Interrupt_Cntl);
-      outb(0x80, port_base + SCSI_Cntl);
-#if DEBUG_RACE
-      in_interrupt_flag = 0;
-#endif
-      return IRQ_HANDLED;
-   }
-   
-   /* current_SC->SCp.phase == in_other: this is the body of the routine */
-   
-   status = inb(port_base + SCSI_Status);
-   
-   if (status & 0x10) {	/* REQ */
-      
-      switch (status & 0x0e) {
-       
-      case 0x08:		/* COMMAND OUT */
-	 outb(current_SC->cmnd[current_SC->SCp.sent_command++],
-	      port_base + Write_SCSI_Data);
-#if EVERY_ACCESS
-	 printk( "CMD = %x,",
-		 current_SC->cmnd[ current_SC->SCp.sent_command - 1] );
-#endif
-	 break;
-      case 0x00:		/* DATA OUT -- tmc18c50/tmc18c30 only */
-	 if (chip != tmc1800 && !current_SC->SCp.have_data_in) {
-	    current_SC->SCp.have_data_in = -1;
-	    outb(0xd0 | PARITY_MASK, port_base + TMC_Cntl);
-	 }
-	 break;
-      case 0x04:		/* DATA IN -- tmc18c50/tmc18c30 only */
-	 if (chip != tmc1800 && !current_SC->SCp.have_data_in) {
-	    current_SC->SCp.have_data_in = 1;
-	    outb(0x90 | PARITY_MASK, port_base + TMC_Cntl);
-	 }
-	 break;
-      case 0x0c:		/* STATUS IN */
-	 current_SC->SCp.Status = inb(port_base + Read_SCSI_Data);
-#if EVERY_ACCESS
-	 printk( "Status = %x, ", current_SC->SCp.Status );
-#endif
-#if ERRORS_ONLY
-	 if (current_SC->SCp.Status
-	     && current_SC->SCp.Status != 2
-	     && current_SC->SCp.Status != 8) {
-	    printk( "scsi: <fdomain> target = %d, command = %x, status = %x\n",
-		    current_SC->device->id,
-		    current_SC->cmnd[0],
-		    current_SC->SCp.Status );
-	 }
-#endif
-	       break;
-      case 0x0a:		/* MESSAGE OUT */
-	 outb(MESSAGE_REJECT, port_base + Write_SCSI_Data); /* Reject */
-	 break;
-      case 0x0e:		/* MESSAGE IN */
-	 current_SC->SCp.Message = inb(port_base + Read_SCSI_Data);
-#if EVERY_ACCESS
-	 printk( "Message = %x, ", current_SC->SCp.Message );
-#endif
-	 if (!current_SC->SCp.Message) ++done;
-#if DEBUG_MESSAGES || EVERY_ACCESS
-	 if (current_SC->SCp.Message) {
-	    printk( "scsi: <fdomain> message = %x\n",
-		    current_SC->SCp.Message );
-	 }
-#endif
-	 break;
-      }
-   }
-
-   if (chip == tmc1800 && !current_SC->SCp.have_data_in
-       && (current_SC->SCp.sent_command >= current_SC->cmd_len)) {
-      
-      if(current_SC->sc_data_direction == DMA_TO_DEVICE)
-      {
-	 current_SC->SCp.have_data_in = -1;
-	 outb(0xd0 | PARITY_MASK, port_base + TMC_Cntl);
-      }
-      else
-      {
-	 current_SC->SCp.have_data_in = 1;
-	 outb(0x90 | PARITY_MASK, port_base + TMC_Cntl);
-      }
-   }
-
-   if (current_SC->SCp.have_data_in == -1) { /* DATA OUT */
-      while ((data_count = FIFO_Size - inw(port_base + FIFO_Data_Count)) > 512) {
-#if EVERY_ACCESS
-	 printk( "DC=%d, ", data_count ) ;
-#endif
-	 if (data_count > current_SC->SCp.this_residual)
-	       data_count = current_SC->SCp.this_residual;
-	 if (data_count > 0) {
-#if EVERY_ACCESS
-	    printk( "%d OUT, ", data_count );
-#endif
-	    if (data_count == 1) {
-	       outb(*current_SC->SCp.ptr++, port_base + Write_FIFO);
-	       --current_SC->SCp.this_residual;
-	    } else {
-	       data_count >>= 1;
-	       outsw(port_base + Write_FIFO, current_SC->SCp.ptr, data_count);
-	       current_SC->SCp.ptr += 2 * data_count;
-	       current_SC->SCp.this_residual -= 2 * data_count;
-	    }
-	 }
-	 if (!current_SC->SCp.this_residual) {
-	    if (current_SC->SCp.buffers_residual) {
-	       --current_SC->SCp.buffers_residual;
-	       ++current_SC->SCp.buffer;
-	       current_SC->SCp.ptr = sg_virt(current_SC->SCp.buffer);
-	       current_SC->SCp.this_residual = current_SC->SCp.buffer->length;
-	    } else
-		  break;
-	 }
-      }
-   }
-   
-   if (current_SC->SCp.have_data_in == 1) { /* DATA IN */
-      while ((data_count = inw(port_base + FIFO_Data_Count)) > 0) {
-#if EVERY_ACCESS
-	 printk( "DC=%d, ", data_count );
-#endif
-	 if (data_count > current_SC->SCp.this_residual)
-	       data_count = current_SC->SCp.this_residual;
-	 if (data_count) {
-#if EVERY_ACCESS
-	    printk( "%d IN, ", data_count );
-#endif
-	    if (data_count == 1) {
-	       *current_SC->SCp.ptr++ = inb(port_base + Read_FIFO);
-	       --current_SC->SCp.this_residual;
-	    } else {
-	       data_count >>= 1; /* Number of words */
-	       insw(port_base + Read_FIFO, current_SC->SCp.ptr, data_count);
-	       current_SC->SCp.ptr += 2 * data_count;
-	       current_SC->SCp.this_residual -= 2 * data_count;
-	    }
-	 }
-	 if (!current_SC->SCp.this_residual
-	     && current_SC->SCp.buffers_residual) {
-	    --current_SC->SCp.buffers_residual;
-	    ++current_SC->SCp.buffer;
-	    current_SC->SCp.ptr = sg_virt(current_SC->SCp.buffer);
-	    current_SC->SCp.this_residual = current_SC->SCp.buffer->length;
-	 }
-      }
-   }
-   
-   if (done) {
-#if EVERY_ACCESS
-      printk( " ** IN DONE %d ** ", current_SC->SCp.have_data_in );
-#endif
-
-#if ERRORS_ONLY
-      if (current_SC->cmnd[0] == REQUEST_SENSE && !current_SC->SCp.Status) {
-	      char *buf = scsi_sglist(current_SC);
-	 if ((unsigned char)(*(buf + 2)) & 0x0f) {
-	    unsigned char key;
-	    unsigned char code;
-	    unsigned char qualifier;
-
-	    key = (unsigned char)(*(buf + 2)) & 0x0f;
-	    code = (unsigned char)(*(buf + 12));
-	    qualifier = (unsigned char)(*(buf + 13));
-
-	    if (key != UNIT_ATTENTION
-		&& !(key == NOT_READY
-		     && code == 0x04
-		     && (!qualifier || qualifier == 0x02 || qualifier == 0x01))
-		&& !(key == ILLEGAL_REQUEST && (code == 0x25
-						|| code == 0x24
-						|| !code)))
-		  
-		  printk( "scsi: <fdomain> REQUEST SENSE"
-			  " Key = %x, Code = %x, Qualifier = %x\n",
-			  key, code, qualifier );
-	 }
-      }
-#endif
-#if EVERY_ACCESS
-      printk( "BEFORE MY_DONE. . ." );
-#endif
-      spin_lock_irqsave(current_SC->device->host->host_lock, flags);
-      my_done( (current_SC->SCp.Status & 0xff)
-	       | ((current_SC->SCp.Message & 0xff) << 8) | (DID_OK << 16) );
-      spin_unlock_irqrestore(current_SC->device->host->host_lock, flags);
-#if EVERY_ACCESS
-      printk( "RETURNING.\n" );
-#endif
-      
-   } else {
-      if (current_SC->SCp.phase & disconnect) {
-	 outb(0xd0 | FIFO_COUNT, port_base + Interrupt_Cntl);
-	 outb(0x00, port_base + SCSI_Cntl);
-      } else {
-	 outb(0x90 | FIFO_COUNT, port_base + Interrupt_Cntl);
-      }
-   }
-#if DEBUG_RACE
-   in_interrupt_flag = 0;
-#endif
-   return IRQ_HANDLED;
-}
-
-static int fdomain_16x0_queue_lck(struct scsi_cmnd *SCpnt,
-		void (*done)(struct scsi_cmnd *))
-{
-   if (in_command) {
-      panic( "scsi: <fdomain> fdomain_16x0_queue() NOT REENTRANT!\n" );
-   }
-#if EVERY_ACCESS
-   printk( "queue: target = %d cmnd = 0x%02x pieces = %d size = %u\n",
-	   SCpnt->target,
-	   *(unsigned char *)SCpnt->cmnd,
-	   scsi_sg_count(SCpnt),
-	   scsi_bufflen(SCpnt));
-#endif
-
-   fdomain_make_bus_idle();
-
-   current_SC            = SCpnt; /* Save this for the done function */
-   current_SC->scsi_done = done;
-
-   /* Initialize static data */
-
-   if (scsi_sg_count(current_SC)) {
-	   current_SC->SCp.buffer = scsi_sglist(current_SC);
-	   current_SC->SCp.ptr = sg_virt(current_SC->SCp.buffer);
-	   current_SC->SCp.this_residual    = current_SC->SCp.buffer->length;
-	   current_SC->SCp.buffers_residual = scsi_sg_count(current_SC) - 1;
-   } else {
-	   current_SC->SCp.ptr              = NULL;
-	   current_SC->SCp.this_residual    = 0;
-	   current_SC->SCp.buffer           = NULL;
-	   current_SC->SCp.buffers_residual = 0;
-   }
-
-   current_SC->SCp.Status              = 0;
-   current_SC->SCp.Message             = 0;
-   current_SC->SCp.have_data_in        = 0;
-   current_SC->SCp.sent_command        = 0;
-   current_SC->SCp.phase               = in_arbitration;
-
-   /* Start arbitration */
-   outb(0x00, port_base + Interrupt_Cntl);
-   outb(0x00, port_base + SCSI_Cntl);              /* Disable data drivers */
-   outb(adapter_mask, port_base + SCSI_Data_NoACK); /* Set our id bit */
-   ++in_command;
-   outb(0x20, port_base + Interrupt_Cntl);
-   outb(0x14 | PARITY_MASK, port_base + TMC_Cntl); /* Start arbitration */
-
-   return 0;
-}
-
-static DEF_SCSI_QCMD(fdomain_16x0_queue)
-
-#if DEBUG_ABORT
-static void print_info(struct scsi_cmnd *SCpnt)
-{
-   unsigned int imr;
-   unsigned int irr;
-   unsigned int isr;
-
-   if (!SCpnt || !SCpnt->device || !SCpnt->device->host) {
-      printk(KERN_WARNING "scsi: <fdomain> Cannot provide detailed information\n");
-      return;
-   }
-   
-   printk(KERN_INFO "%s\n", fdomain_16x0_info( SCpnt->device->host ) );
-   print_banner(SCpnt->device->host);
-   switch (SCpnt->SCp.phase) {
-   case in_arbitration: printk("arbitration"); break;
-   case in_selection:   printk("selection");   break;
-   case in_other:       printk("other");       break;
-   default:             printk("unknown");     break;
-   }
-
-   printk( " (%d), target = %d cmnd = 0x%02x pieces = %d size = %u\n",
-	   SCpnt->SCp.phase,
-	   SCpnt->device->id,
-	   *(unsigned char *)SCpnt->cmnd,
-	   scsi_sg_count(SCpnt),
-	   scsi_bufflen(SCpnt));
-   printk( "sent_command = %d, have_data_in = %d, timeout = %d\n",
-	   SCpnt->SCp.sent_command,
-	   SCpnt->SCp.have_data_in,
-	   SCpnt->timeout );
-#if DEBUG_RACE
-   printk( "in_interrupt_flag = %d\n", in_interrupt_flag );
-#endif
-
-   imr = (inb( 0x0a1 ) << 8) + inb( 0x21 );
-   outb( 0x0a, 0xa0 );
-   irr = inb( 0xa0 ) << 8;
-   outb( 0x0a, 0x20 );
-   irr += inb( 0x20 );
-   outb( 0x0b, 0xa0 );
-   isr = inb( 0xa0 ) << 8;
-   outb( 0x0b, 0x20 );
-   isr += inb( 0x20 );
-
-				/* Print out interesting information */
-   printk( "IMR = 0x%04x", imr );
-   if (imr & (1 << interrupt_level))
-	 printk( " (masked)" );
-   printk( ", IRR = 0x%04x, ISR = 0x%04x\n", irr, isr );
-
-   printk( "SCSI Status      = 0x%02x\n", inb(port_base + SCSI_Status));
-   printk( "TMC Status       = 0x%02x", inb(port_base + TMC_Status));
-   if (inb((port_base + TMC_Status) & 1))
-	 printk( " (interrupt)" );
-   printk( "\n" );
-   printk("Interrupt Status = 0x%02x", inb(port_base + Interrupt_Status));
-   if (inb(port_base + Interrupt_Status) & 0x08)
-	 printk( " (enabled)" );
-   printk( "\n" );
-   if (chip == tmc18c50 || chip == tmc18c30) {
-      printk("FIFO Status      = 0x%02x\n", inb(port_base + FIFO_Status));
-      printk( "Int. Condition   = 0x%02x\n",
-	      inb( port_base + Interrupt_Cond ) );
-   }
-   printk( "Configuration 1  = 0x%02x\n", inb( port_base + Configuration1 ) );
-   if (chip == tmc18c50 || chip == tmc18c30)
-	 printk( "Configuration 2  = 0x%02x\n",
-		 inb( port_base + Configuration2 ) );
-}
-#endif
-
-static int fdomain_16x0_abort(struct scsi_cmnd *SCpnt)
-{
-#if EVERY_ACCESS || ERRORS_ONLY || DEBUG_ABORT
-   printk( "scsi: <fdomain> abort " );
-#endif
-
-   if (!in_command) {
-#if EVERY_ACCESS || ERRORS_ONLY
-      printk( " (not in command)\n" );
-#endif
-      return FAILED;
-   } else printk( "\n" );
-
-#if DEBUG_ABORT
-   print_info( SCpnt );
-#endif
-
-   fdomain_make_bus_idle();
-   current_SC->SCp.phase |= aborted;
-   current_SC->result = DID_ABORT << 16;
-   
-   /* Aborts are not done well. . . */
-   my_done(DID_ABORT << 16);
-   return SUCCESS;
-}
-
-int fdomain_16x0_host_reset(struct scsi_cmnd *SCpnt)
-{
-   unsigned long flags;
-
-   local_irq_save(flags);
-
-   outb(1, port_base + SCSI_Cntl);
-   do_pause( 2 );
-   outb(0, port_base + SCSI_Cntl);
-   do_pause( 115 );
-   outb(0, port_base + SCSI_Mode_Cntl);
-   outb(PARITY_MASK, port_base + TMC_Cntl);
-
-   local_irq_restore(flags);
-   return SUCCESS;
-}
-
-static int fdomain_16x0_biosparam(struct scsi_device *sdev,
-		struct block_device *bdev,
-		sector_t capacity, int *info_array)
-{
-   int              drive;
-   int		    size      = capacity;
-   unsigned long    offset;
-   struct drive_info {
-      unsigned short cylinders;
-      unsigned char  heads;
-      unsigned char  sectors;
-   } i;
-   
-   /* NOTES:
-      The RAM area starts at 0x1f00 from the bios_base address.
-
-      For BIOS Version 2.0:
-      
-      The drive parameter table seems to start at 0x1f30.
-      The first byte's purpose is not known.
-      Next is the cylinder, head, and sector information.
-      The last 4 bytes appear to be the drive's size in sectors.
-      The other bytes in the drive parameter table are unknown.
-      If anyone figures them out, please send me mail, and I will
-      update these notes.
-
-      Tape drives do not get placed in this table.
-
-      There is another table at 0x1fea:
-      If the byte is 0x01, then the SCSI ID is not in use.
-      If the byte is 0x18 or 0x48, then the SCSI ID is in use,
-      although tapes don't seem to be in this table.  I haven't
-      seen any other numbers (in a limited sample).
-
-      0x1f2d is a drive count (i.e., not including tapes)
-
-      The table at 0x1fcc are I/O ports addresses for the various
-      operations.  I calculate these by hand in this driver code.
-
-      
-      
-      For the ISA-200S version of BIOS Version 2.0:
-
-      The drive parameter table starts at 0x1f33.
-
-      WARNING: Assume that the table entry is 25 bytes long.  Someone needs
-      to check this for the Quantum ISA-200S card.
-
-      
-      
-      For BIOS Version 3.2:
-
-      The drive parameter table starts at 0x1f70.  Each entry is
-      0x0a bytes long.  Heads are one less than we need to report.
-    */
-
-   if (MAJOR(bdev->bd_dev) != SCSI_DISK0_MAJOR) {
-      printk("scsi: <fdomain> fdomain_16x0_biosparam: too many disks");
-      return 0;
-   }
-   drive = MINOR(bdev->bd_dev) >> 4;
-
-   if (bios_major == 2) {
-      switch (Quantum) {
-      case 2:			/* ISA_200S */
-				/* The value of 25 has never been verified.
-				   It should probably be 15. */
-	 offset = 0x1f33 + drive * 25;
-	 break;
-      case 3:			/* ISA_250MG */
-	 offset = 0x1f36 + drive * 15;
-	 break;
-      case 4:			/* ISA_200S (another one) */
-	 offset = 0x1f34 + drive * 15;
-	 break;
-      default:
-	 offset = 0x1f31 + drive * 25;
-	 break;
-      }
-      memcpy_fromio( &i, bios_mem + offset, sizeof( struct drive_info ) );
-      info_array[0] = i.heads;
-      info_array[1] = i.sectors;
-      info_array[2] = i.cylinders;
-   } else if (bios_major == 3
-	      && bios_minor >= 0
-	      && bios_minor < 4) { /* 3.0 and 3.2 BIOS */
-      memcpy_fromio( &i, bios_mem + 0x1f71 + drive * 10,
-		     sizeof( struct drive_info ) );
-      info_array[0] = i.heads + 1;
-      info_array[1] = i.sectors;
-      info_array[2] = i.cylinders;
-   } else {			/* 3.4 BIOS (and up?) */
-      /* This algorithm was provided by Future Domain (much thanks!). */
-      unsigned char *p = scsi_bios_ptable(bdev);
-
-      if (p && p[65] == 0xaa && p[64] == 0x55 /* Partition table valid */
-	  && p[4]) {			    /* Partition type */
-
-	 /* The partition table layout is as follows:
-
-	    Start: 0x1b3h
-	    Offset: 0 = partition status
-		    1 = starting head
-		    2 = starting sector and cylinder (word, encoded)
-		    4 = partition type
-		    5 = ending head
-		    6 = ending sector and cylinder (word, encoded)
-		    8 = starting absolute sector (double word)
-		    c = number of sectors (double word)
-	    Signature: 0x1fe = 0x55aa
-
-	    So, this algorithm assumes:
-	    1) the first partition table is in use,
-	    2) the data in the first entry is correct, and
-	    3) partitions never divide cylinders
-
-	    Note that (1) may be FALSE for NetBSD (and other BSD flavors),
-	    as well as for Linux.  Note also, that Linux doesn't pay any
-	    attention to the fields that are used by this algorithm -- it
-	    only uses the absolute sector data.  Recent versions of Linux's
-	    fdisk(1) will fill this data in correctly, and forthcoming
-	    versions will check for consistency.
-
-	    Checking for a non-zero partition type is not part of the
-	    Future Domain algorithm, but it seemed to be a reasonable thing
-	    to do, especially in the Linux and BSD worlds. */
-
-	 info_array[0] = p[5] + 1;	    /* heads */
-	 info_array[1] = p[6] & 0x3f;	    /* sectors */
-      } else {
-
- 	 /* Note that this new method guarantees that there will always be
-	    less than 1024 cylinders on a platter.  This is good for drives
-	    up to approximately 7.85GB (where 1GB = 1024 * 1024 kB). */
-
-	 if ((unsigned int)size >= 0x7e0000U) {
-	    info_array[0] = 0xff; /* heads   = 255 */
-	    info_array[1] = 0x3f; /* sectors =  63 */
-	 } else if ((unsigned int)size >= 0x200000U) {
-	    info_array[0] = 0x80; /* heads   = 128 */
-	    info_array[1] = 0x3f; /* sectors =  63 */
-	 } else {
-	    info_array[0] = 0x40; /* heads   =  64 */
-	    info_array[1] = 0x20; /* sectors =  32 */
-	 }
-      }
-				/* For both methods, compute the cylinders */
-      info_array[2] = (unsigned int)size / (info_array[0] * info_array[1] );
-      kfree(p);
-   }
-   
-   return 0;
-}
-
-static int fdomain_16x0_release(struct Scsi_Host *shpnt)
-{
-	if (shpnt->irq)
-		free_irq(shpnt->irq, shpnt);
-	if (shpnt->io_port && shpnt->n_io_port)
-		release_region(shpnt->io_port, shpnt->n_io_port);
-	if (PCI_bus)
-		pci_dev_put(PCI_dev);
-	return 0;
-}
-
-struct scsi_host_template fdomain_driver_template = {
-	.module			= THIS_MODULE,
-	.name			= "fdomain",
-	.proc_name		= "fdomain",
-	.detect			= fdomain_16x0_detect,
-	.info			= fdomain_16x0_info,
-	.queuecommand		= fdomain_16x0_queue,
-	.eh_abort_handler	= fdomain_16x0_abort,
-	.eh_host_reset_handler	= fdomain_16x0_host_reset,
-	.bios_param		= fdomain_16x0_biosparam,
-	.release		= fdomain_16x0_release,
-	.can_queue		= 1,
-	.this_id		= 6,
-	.sg_tablesize		= 64,
-	.use_clustering		= DISABLE_CLUSTERING,
-};
-
-#ifndef PCMCIA
-#if defined(CONFIG_PCI) && defined(MODULE)
-
-static struct pci_device_id fdomain_pci_tbl[] = {
-	{ PCI_VENDOR_ID_FD, PCI_DEVICE_ID_FD_36C70,
-	  PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0UL },
-	{ }
-};
-MODULE_DEVICE_TABLE(pci, fdomain_pci_tbl);
-#endif
-#define driver_template fdomain_driver_template
-#include "scsi_module.c"
-
-#endif

commit 63cd2f7f9031a91c11583ca16c84280c5debeeae
Author: Hannes Reinecke <hare@suse.de>
Date:   Fri Aug 25 13:57:05 2017 +0200

    scsi: fdomain: move bus reset to host reset
    
    The bus reset function really is a host reset, so move it to
    eh_host_reset_handler().
    
    Signed-off-by: Hannes Reinecke <hare@suse.com>
    Reviewed-by: Christoph Hellwig <hch@lst.de>
    Reviewed-by: Johannes Thumshirn <jthumshirn@suse.de>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/fdomain.c b/drivers/scsi/fdomain.c
index b87ab38a4530..ebbe5a3e665d 100644
--- a/drivers/scsi/fdomain.c
+++ b/drivers/scsi/fdomain.c
@@ -933,7 +933,7 @@ struct Scsi_Host *__fdomain_16x0_detect(struct scsi_host_template *tpnt )
       }
    }
 
-   fdomain_16x0_bus_reset(NULL);
+   fdomain_16x0_host_reset(NULL);
 
    if (fdomain_test_loopback()) {
       printk(KERN_ERR  "scsi: <fdomain> Detection failed (loopback test failed at port base 0x%x)\n", port_base);
@@ -1568,7 +1568,7 @@ static int fdomain_16x0_abort(struct scsi_cmnd *SCpnt)
    return SUCCESS;
 }
 
-int fdomain_16x0_bus_reset(struct scsi_cmnd *SCpnt)
+int fdomain_16x0_host_reset(struct scsi_cmnd *SCpnt)
 {
    unsigned long flags;
 
@@ -1758,7 +1758,7 @@ struct scsi_host_template fdomain_driver_template = {
 	.info			= fdomain_16x0_info,
 	.queuecommand		= fdomain_16x0_queue,
 	.eh_abort_handler	= fdomain_16x0_abort,
-	.eh_bus_reset_handler	= fdomain_16x0_bus_reset,
+	.eh_host_reset_handler	= fdomain_16x0_host_reset,
 	.bios_param		= fdomain_16x0_biosparam,
 	.release		= fdomain_16x0_release,
 	.can_queue		= 1,

commit 120f83f8d6f2e2e7dea3570646722c62ecee70b0
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Wed Jan 27 16:57:17 2016 +0100

    scsi: fdomain: drop fdomain_pci_tbl when built-in
    
    The fdomain SCSI host driver is one of the last remaining drivers that
    manually search the PCI bus using pci_get_device rather than registering
    a pci_driver instance.
    
    This means the module device table is unused when the driver is
    built-in, and we get a warning about it:
    
    drivers/scsi/fdomain.c:1773:29: warning: 'fdomain_pci_tbl' defined but not used [-Wunused-variable]
    
    To avoid the warning, this adds another #ifdef around the table
    definition.
    
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/fdomain.c b/drivers/scsi/fdomain.c
index eefe14d453db..b87ab38a4530 100644
--- a/drivers/scsi/fdomain.c
+++ b/drivers/scsi/fdomain.c
@@ -1768,7 +1768,7 @@ struct scsi_host_template fdomain_driver_template = {
 };
 
 #ifndef PCMCIA
-#ifdef CONFIG_PCI
+#if defined(CONFIG_PCI) && defined(MODULE)
 
 static struct pci_device_id fdomain_pci_tbl[] = {
 	{ PCI_VENDOR_ID_FD, PCI_DEVICE_ID_FD_36C70,

commit b84b1d522f979fb53ad347605e24b2940fa2ad99
Author: Hannes Reinecke <hare@suse.de>
Date:   Wed Apr 29 08:57:34 2015 +0200

    scsi: Do not set cmd_per_lun to 1 in the host template
    
    '0' is now used as the default cmd_per_lun value,
    so there's no need to explicitly set it to '1' in the
    host template.
    
    Signed-off-by: Hannes Reinecke <hare@suse.de>
    Reviewed-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: James Bottomley <JBottomley@Odin.com>

diff --git a/drivers/scsi/fdomain.c b/drivers/scsi/fdomain.c
index fff682976c56..eefe14d453db 100644
--- a/drivers/scsi/fdomain.c
+++ b/drivers/scsi/fdomain.c
@@ -1764,7 +1764,6 @@ struct scsi_host_template fdomain_driver_template = {
 	.can_queue		= 1,
 	.this_id		= 6,
 	.sg_tablesize		= 64,
-	.cmd_per_lun		= 1,
 	.use_clustering		= DISABLE_CLUSTERING,
 };
 

commit 6f039790510fd630ff348efe8c4802dbaa041fba
Author: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
Date:   Fri Dec 21 13:08:55 2012 -0800

    Drivers: scsi: remove __dev* attributes.
    
    CONFIG_HOTPLUG is going away as an option.  As a result, the __dev*
    markings need to be removed.
    
    This change removes the use of __devinit, __devexit_p, __devinitdata,
    __devinitconst, and __devexit from these drivers.
    
    Based on patches originally written by Bill Pemberton, but redone by me
    in order to handle some of the coding style issues better, by hand.
    
    Cc: Bill Pemberton <wfp5p@virginia.edu>
    Cc: Adam Radford <linuxraid@lsi.com>
    Cc: "James E.J. Bottomley" <JBottomley@parallels.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/scsi/fdomain.c b/drivers/scsi/fdomain.c
index 1a2a1e5824e3..fff682976c56 100644
--- a/drivers/scsi/fdomain.c
+++ b/drivers/scsi/fdomain.c
@@ -1771,7 +1771,7 @@ struct scsi_host_template fdomain_driver_template = {
 #ifndef PCMCIA
 #ifdef CONFIG_PCI
 
-static struct pci_device_id fdomain_pci_tbl[] __devinitdata = {
+static struct pci_device_id fdomain_pci_tbl[] = {
 	{ PCI_VENDOR_ID_FD, PCI_DEVICE_ID_FD_36C70,
 	  PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0UL },
 	{ }

commit 9ffc93f203c18a70623f21950f1dd473c9ec48cd
Author: David Howells <dhowells@redhat.com>
Date:   Wed Mar 28 18:30:03 2012 +0100

    Remove all #inclusions of asm/system.h
    
    Remove all #inclusions of asm/system.h preparatory to splitting and killing
    it.  Performed with the following command:
    
    perl -p -i -e 's!^#\s*include\s*<asm/system[.]h>.*\n!!' `grep -Irl '^#\s*include\s*<asm/system[.]h>' *`
    
    Signed-off-by: David Howells <dhowells@redhat.com>

diff --git a/drivers/scsi/fdomain.c b/drivers/scsi/fdomain.c
index 643f6d500fe7..1a2a1e5824e3 100644
--- a/drivers/scsi/fdomain.c
+++ b/drivers/scsi/fdomain.c
@@ -282,7 +282,6 @@
 #include <linux/slab.h>
 #include <scsi/scsicam.h>
 
-#include <asm/system.h>
 
 #include <scsi/scsi.h>
 #include <scsi/scsi_cmnd.h>

commit 25985edcedea6396277003854657b5f3cb31a628
Author: Lucas De Marchi <lucas.demarchi@profusion.mobi>
Date:   Wed Mar 30 22:57:33 2011 -0300

    Fix common misspellings
    
    Fixes generated by 'codespell' and manually reviewed.
    
    Signed-off-by: Lucas De Marchi <lucas.demarchi@profusion.mobi>

diff --git a/drivers/scsi/fdomain.c b/drivers/scsi/fdomain.c
index 69b7aa54f43f..643f6d500fe7 100644
--- a/drivers/scsi/fdomain.c
+++ b/drivers/scsi/fdomain.c
@@ -174,7 +174,7 @@
  Future Domain sold DOS BIOS source for $250 and the UN*X driver source was
  $750, but these required a non-disclosure agreement, so even if I could
  have afforded them, they would *not* have been useful for writing this
- publically distributable driver.  Future Domain technical support has
+ publicly distributable driver.  Future Domain technical support has
  provided some information on the phone and have sent a few useful FAXs.
  They have been much more helpful since they started to recognize that the
  word "Linux" refers to an operating system :-).

commit f281233d3eba15fb225d21ae2e228fd4553d824a
Author: Jeff Garzik <jeff@garzik.org>
Date:   Tue Nov 16 02:10:29 2010 -0500

    SCSI host lock push-down
    
    Move the mid-layer's ->queuecommand() invocation from being locked
    with the host lock to being unlocked to facilitate speeding up the
    critical path for drivers who don't need this lock taken anyway.
    
    The patch below presents a simple SCSI host lock push-down as an
    equivalent transformation.  No locking or other behavior should change
    with this patch.  All existing bugs and locking orders are preserved.
    
    Additionally, add one parameter to queuecommand,
            struct Scsi_Host *
    and remove one parameter from queuecommand,
            void (*done)(struct scsi_cmnd *)
    
    Scsi_Host* is a convenient pointer that most host drivers need anyway,
    and 'done' is redundant to struct scsi_cmnd->scsi_done.
    
    Minimal code disturbance was attempted with this change.  Most drivers
    needed only two one-line modifications for their host lock push-down.
    
    Signed-off-by: Jeff Garzik <jgarzik@redhat.com>
    Acked-by: James Bottomley <James.Bottomley@suse.de>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/scsi/fdomain.c b/drivers/scsi/fdomain.c
index e296bcc57d5c..69b7aa54f43f 100644
--- a/drivers/scsi/fdomain.c
+++ b/drivers/scsi/fdomain.c
@@ -1419,7 +1419,7 @@ static irqreturn_t do_fdomain_16x0_intr(int irq, void *dev_id)
    return IRQ_HANDLED;
 }
 
-static int fdomain_16x0_queue(struct scsi_cmnd *SCpnt,
+static int fdomain_16x0_queue_lck(struct scsi_cmnd *SCpnt,
 		void (*done)(struct scsi_cmnd *))
 {
    if (in_command) {
@@ -1469,6 +1469,8 @@ static int fdomain_16x0_queue(struct scsi_cmnd *SCpnt,
    return 0;
 }
 
+static DEF_SCSI_QCMD(fdomain_16x0_queue)
+
 #if DEBUG_ABORT
 static void print_info(struct scsi_cmnd *SCpnt)
 {

commit 5a0e3ad6af8660be21ca98a971cd00f331318c05
Author: Tejun Heo <tj@kernel.org>
Date:   Wed Mar 24 17:04:11 2010 +0900

    include cleanup: Update gfp.h and slab.h includes to prepare for breaking implicit slab.h inclusion from percpu.h
    
    percpu.h is included by sched.h and module.h and thus ends up being
    included when building most .c files.  percpu.h includes slab.h which
    in turn includes gfp.h making everything defined by the two files
    universally available and complicating inclusion dependencies.
    
    percpu.h -> slab.h dependency is about to be removed.  Prepare for
    this change by updating users of gfp and slab facilities include those
    headers directly instead of assuming availability.  As this conversion
    needs to touch large number of source files, the following script is
    used as the basis of conversion.
    
      http://userweb.kernel.org/~tj/misc/slabh-sweep.py
    
    The script does the followings.
    
    * Scan files for gfp and slab usages and update includes such that
      only the necessary includes are there.  ie. if only gfp is used,
      gfp.h, if slab is used, slab.h.
    
    * When the script inserts a new include, it looks at the include
      blocks and try to put the new include such that its order conforms
      to its surrounding.  It's put in the include block which contains
      core kernel includes, in the same order that the rest are ordered -
      alphabetical, Christmas tree, rev-Xmas-tree or at the end if there
      doesn't seem to be any matching order.
    
    * If the script can't find a place to put a new include (mostly
      because the file doesn't have fitting include block), it prints out
      an error message indicating which .h file needs to be added to the
      file.
    
    The conversion was done in the following steps.
    
    1. The initial automatic conversion of all .c files updated slightly
       over 4000 files, deleting around 700 includes and adding ~480 gfp.h
       and ~3000 slab.h inclusions.  The script emitted errors for ~400
       files.
    
    2. Each error was manually checked.  Some didn't need the inclusion,
       some needed manual addition while adding it to implementation .h or
       embedding .c file was more appropriate for others.  This step added
       inclusions to around 150 files.
    
    3. The script was run again and the output was compared to the edits
       from #2 to make sure no file was left behind.
    
    4. Several build tests were done and a couple of problems were fixed.
       e.g. lib/decompress_*.c used malloc/free() wrappers around slab
       APIs requiring slab.h to be added manually.
    
    5. The script was run on all .h files but without automatically
       editing them as sprinkling gfp.h and slab.h inclusions around .h
       files could easily lead to inclusion dependency hell.  Most gfp.h
       inclusion directives were ignored as stuff from gfp.h was usually
       wildly available and often used in preprocessor macros.  Each
       slab.h inclusion directive was examined and added manually as
       necessary.
    
    6. percpu.h was updated not to include slab.h.
    
    7. Build test were done on the following configurations and failures
       were fixed.  CONFIG_GCOV_KERNEL was turned off for all tests (as my
       distributed build env didn't work with gcov compiles) and a few
       more options had to be turned off depending on archs to make things
       build (like ipr on powerpc/64 which failed due to missing writeq).
    
       * x86 and x86_64 UP and SMP allmodconfig and a custom test config.
       * powerpc and powerpc64 SMP allmodconfig
       * sparc and sparc64 SMP allmodconfig
       * ia64 SMP allmodconfig
       * s390 SMP allmodconfig
       * alpha SMP allmodconfig
       * um on x86_64 SMP allmodconfig
    
    8. percpu.h modifications were reverted so that it could be applied as
       a separate patch and serve as bisection point.
    
    Given the fact that I had only a couple of failures from tests on step
    6, I'm fairly confident about the coverage of this conversion patch.
    If there is a breakage, it's likely to be something in one of the arch
    headers which should be easily discoverable easily on most builds of
    the specific arch.
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Guess-its-ok-by: Christoph Lameter <cl@linux-foundation.org>
    Cc: Ingo Molnar <mingo@redhat.com>
    Cc: Lee Schermerhorn <Lee.Schermerhorn@hp.com>

diff --git a/drivers/scsi/fdomain.c b/drivers/scsi/fdomain.c
index 32eef66114c7..e296bcc57d5c 100644
--- a/drivers/scsi/fdomain.c
+++ b/drivers/scsi/fdomain.c
@@ -279,6 +279,7 @@
 #include <linux/stat.h>
 #include <linux/delay.h>
 #include <linux/io.h>
+#include <linux/slab.h>
 #include <scsi/scsicam.h>
 
 #include <asm/system.h>

commit fa195afe4ad3f6d85a9b7cc236ae85c05ca8db03
Author: Alan Cox <alan@lxorguk.ukuu.org.uk>
Date:   Mon Oct 27 15:16:36 2008 +0000

    [SCSI] Clean up my email address and use a single standard address for everything
    
    Signed-off-by: Alan Cox <alan@redhat.com>
    Signed-off-by: James Bottomley <James.Bottomley@HansenPartnership.com>

diff --git a/drivers/scsi/fdomain.c b/drivers/scsi/fdomain.c
index 56f4e6bffc21..32eef66114c7 100644
--- a/drivers/scsi/fdomain.c
+++ b/drivers/scsi/fdomain.c
@@ -3,7 +3,7 @@
  * Revised: Mon Dec 28 21:59:02 1998 by faith@acm.org
  * Author: Rickard E. Faith, faith@cs.unc.edu
  * Copyright 1992-1996, 1998 Rickard E. Faith (faith@acm.org)
- * Shared IRQ supported added 7/7/2001  Alan Cox <alan@redhat.com>
+ * Shared IRQ supported added 7/7/2001  Alan Cox <alan@lxorguk.ukuu.org.uk>
 
  * This program is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License as published by the

commit 5cb02ff3489d710c73b4a21bb804feedeacce116
Author: Alan Cox <alan@redhat.com>
Date:   Sun Oct 5 17:39:16 2008 +0100

    fdomain_cs: Sort out modules with duplicate description
    
    The PCMCIA one provides its own description so in PCMCIA mode we should use
    that.
    
    Signed-off-by: Alan Cox <alan@redhat.com>
    Signed-off-by: Dominik Brodowski <linux@dominikbrodowski.net>

diff --git a/drivers/scsi/fdomain.c b/drivers/scsi/fdomain.c
index c33bcb284df7..56f4e6bffc21 100644
--- a/drivers/scsi/fdomain.c
+++ b/drivers/scsi/fdomain.c
@@ -290,9 +290,11 @@
 #include <scsi/scsi_ioctl.h>
 #include "fdomain.h"
 
+#ifndef PCMCIA
 MODULE_AUTHOR("Rickard E. Faith");
 MODULE_DESCRIPTION("Future domain SCSI driver");
 MODULE_LICENSE("GPL");
+#endif
 
   
 #define VERSION          "$Revision: 5.51 $"

commit 172c122df5186e7cbd413d61757ff90267331002
Author: Harvey Harrison <harvey.harrison@gmail.com>
Date:   Mon Apr 28 16:50:03 2008 -0700

    scsi: fix integer as NULL pointer warnings
    
    drivers/scsi/aic7xxx/aic7770_osm.c:53:58: warning: Using plain integer as NULL pointer
    drivers/scsi/aic7xxx/aic7xxx_osm_pci.c:355:47: warning: Using plain integer as NULL pointer
    drivers/scsi/aic7xxx/aic7xxx_osm_pci.c:372:55: warning: Using plain integer as NULL pointer
    drivers/scsi/aha152x.c:997:28: warning: Using plain integer as NULL pointer
    drivers/scsi/aha152x.c:1003:28: warning: Using plain integer as NULL pointer
    drivers/scsi/aha152x.c:1165:46: warning: Using plain integer as NULL pointer
    drivers/scsi/fdomain.c:1446:40: warning: Using plain integer as NULL pointer
    drivers/scsi/sym53c8xx_2/sym_hipd.c:1650:51: warning: Using plain integer as NULL pointer
    drivers/scsi/sym53c8xx_2/sym_hipd.c:3171:42: warning: Using plain integer as NULL pointer
    drivers/scsi/sym53c8xx_2/sym_hipd.c:5732:52: warning: Using plain integer as NULL pointer
    drivers/scsi/ncr53c8xx.c:8189:31: warning: Using plain integer as NULL pointer
    drivers/scsi/ncr53c8xx.c:8225:34: warning: Using plain integer as NULL pointer
    drivers/scsi/dpt_i2o.c:156:32: warning: Using plain integer as NULL pointer
    drivers/scsi/ultrastor.c:954:42: warning: Using plain integer as NULL pointer
    drivers/scsi/ultrastor.c:1104:18: warning: Using plain integer as NULL pointer
    
    Signed-off-by: Harvey Harrison <harvey.harrison@gmail.com>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/scsi/fdomain.c b/drivers/scsi/fdomain.c
index 2cd6b4959eb2..c33bcb284df7 100644
--- a/drivers/scsi/fdomain.c
+++ b/drivers/scsi/fdomain.c
@@ -1443,7 +1443,7 @@ static int fdomain_16x0_queue(struct scsi_cmnd *SCpnt,
 	   current_SC->SCp.this_residual    = current_SC->SCp.buffer->length;
 	   current_SC->SCp.buffers_residual = scsi_sg_count(current_SC) - 1;
    } else {
-	   current_SC->SCp.ptr              = 0;
+	   current_SC->SCp.ptr              = NULL;
 	   current_SC->SCp.this_residual    = 0;
 	   current_SC->SCp.buffer           = NULL;
 	   current_SC->SCp.buffers_residual = 0;

commit 45711f1af6eff1a6d010703b4862e0d2b9afd056
Author: Jens Axboe <jens.axboe@oracle.com>
Date:   Mon Oct 22 21:19:53 2007 +0200

    [SG] Update drivers to use sg helpers
    
    Signed-off-by: Jens Axboe <jens.axboe@oracle.com>

diff --git a/drivers/scsi/fdomain.c b/drivers/scsi/fdomain.c
index 5d282e6a6ae1..2cd6b4959eb2 100644
--- a/drivers/scsi/fdomain.c
+++ b/drivers/scsi/fdomain.c
@@ -1321,7 +1321,7 @@ static irqreturn_t do_fdomain_16x0_intr(int irq, void *dev_id)
 	    if (current_SC->SCp.buffers_residual) {
 	       --current_SC->SCp.buffers_residual;
 	       ++current_SC->SCp.buffer;
-	       current_SC->SCp.ptr = page_address(current_SC->SCp.buffer->page) + current_SC->SCp.buffer->offset;
+	       current_SC->SCp.ptr = sg_virt(current_SC->SCp.buffer);
 	       current_SC->SCp.this_residual = current_SC->SCp.buffer->length;
 	    } else
 		  break;
@@ -1354,7 +1354,7 @@ static irqreturn_t do_fdomain_16x0_intr(int irq, void *dev_id)
 	     && current_SC->SCp.buffers_residual) {
 	    --current_SC->SCp.buffers_residual;
 	    ++current_SC->SCp.buffer;
-	    current_SC->SCp.ptr = page_address(current_SC->SCp.buffer->page) + current_SC->SCp.buffer->offset;
+	    current_SC->SCp.ptr = sg_virt(current_SC->SCp.buffer);
 	    current_SC->SCp.this_residual = current_SC->SCp.buffer->length;
 	 }
       }
@@ -1439,8 +1439,7 @@ static int fdomain_16x0_queue(struct scsi_cmnd *SCpnt,
 
    if (scsi_sg_count(current_SC)) {
 	   current_SC->SCp.buffer = scsi_sglist(current_SC);
-	   current_SC->SCp.ptr = page_address(current_SC->SCp.buffer->page)
-		   + current_SC->SCp.buffer->offset;
+	   current_SC->SCp.ptr = sg_virt(current_SC->SCp.buffer);
 	   current_SC->SCp.this_residual    = current_SC->SCp.buffer->length;
 	   current_SC->SCp.buffers_residual = scsi_sg_count(current_SC) - 1;
    } else {

commit 2ca482302f2080e6861eaf753051ac35b6b411ad
Author: Gabriel C <nix.or.die@googlemail.com>
Date:   Tue Oct 2 14:38:02 2007 -0700

    [SCSI] fdomain: fix CONFIG_PCI=n warnings
    
    I get this warnings on current git when CONFIG_PCI is not set :
    
    drivers/scsi/fdomain.c:390: warning: 'PCI_dev' defined but not used
    drivers/scsi/fdomain.c:1768: warning: 'fdomain_pci_tbl' defined but not used
    
    Signed-off-by: Gabriel Craciunescu <nix.or.die@googlemail.com>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>

diff --git a/drivers/scsi/fdomain.c b/drivers/scsi/fdomain.c
index 36169d597e98..5d282e6a6ae1 100644
--- a/drivers/scsi/fdomain.c
+++ b/drivers/scsi/fdomain.c
@@ -387,7 +387,9 @@ static void __iomem *    bios_mem;
 static int               bios_major;
 static int               bios_minor;
 static int               PCI_bus;
+#ifdef CONFIG_PCI
 static struct pci_dev	*PCI_dev;
+#endif
 static int               Quantum;	/* Quantum board variant */
 static int               interrupt_level;
 static volatile int      in_command;
@@ -1764,6 +1766,7 @@ struct scsi_host_template fdomain_driver_template = {
 };
 
 #ifndef PCMCIA
+#ifdef CONFIG_PCI
 
 static struct pci_device_id fdomain_pci_tbl[] __devinitdata = {
 	{ PCI_VENDOR_ID_FD, PCI_DEVICE_ID_FD_36C70,
@@ -1771,7 +1774,7 @@ static struct pci_device_id fdomain_pci_tbl[] __devinitdata = {
 	{ }
 };
 MODULE_DEVICE_TABLE(pci, fdomain_pci_tbl);
-
+#endif
 #define driver_template fdomain_driver_template
 #include "scsi_module.c"
 

commit 6cad75a61d802c5f4f4299103b8f95aeb3ee9876
Author: Jeff Garzik <jeff@garzik.org>
Date:   Sun May 27 08:52:12 2007 -0400

    [SCSI] fdomain: fix PCMCIA-related warnings
    
    fdomain is one of those drivers that is compiled twice, once for PCMCIA
    and once for non-PCMCIA.  The resultant two-driver setup leaves a bit of
    dead code and data in the non-PCMCIA case, which gcc complains about.
    
    Shuffle ifdefs a bit to eliminate the conditionally-dead code, and
    the compiler warnings.
    
    Signed-off-by: Jeff Garzik <jeff@garzik.org>
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>

diff --git a/drivers/scsi/fdomain.c b/drivers/scsi/fdomain.c
index 0d1661a8116b..36169d597e98 100644
--- a/drivers/scsi/fdomain.c
+++ b/drivers/scsi/fdomain.c
@@ -410,6 +410,8 @@ static irqreturn_t       do_fdomain_16x0_intr( int irq, void *dev_id );
 static char * fdomain = NULL;
 module_param(fdomain, charp, 0);
 
+#ifndef PCMCIA
+
 static unsigned long addresses[] = {
    0xc8000,
    0xca000,
@@ -426,6 +428,8 @@ static unsigned short ports[] = { 0x140, 0x150, 0x160, 0x170 };
 
 static unsigned short ints[] = { 3, 5, 10, 11, 12, 14, 15, 0 };
 
+#endif /* !PCMCIA */
+
 /*
 
   READ THIS BEFORE YOU ADD A SIGNATURE!
@@ -458,6 +462,8 @@ static unsigned short ints[] = { 3, 5, 10, 11, 12, 14, 15, 0 };
 
 */
 
+#ifndef PCMCIA
+
 static struct signature {
    const char *signature;
    int  sig_offset;
@@ -503,6 +509,8 @@ static struct signature {
 
 #define SIGNATURE_COUNT ARRAY_SIZE(signatures)
 
+#endif /* !PCMCIA */
+
 static void print_banner( struct Scsi_Host *shpnt )
 {
    if (!shpnt) return;		/* This won't ever happen */
@@ -633,6 +641,8 @@ static int fdomain_test_loopback( void )
    return 0;
 }
 
+#ifndef PCMCIA
+
 /* fdomain_get_irq assumes that we have a valid MCA ID for a
    TMC-1660/TMC-1680 Future Domain board.  Now, check to be sure the
    bios_base matches these ports.  If someone was unlucky enough to have
@@ -667,7 +677,6 @@ static int fdomain_get_irq( int base )
 
 static int fdomain_isa_detect( int *irq, int *iobase )
 {
-#ifndef PCMCIA
    int i, j;
    int base = 0xdeadbeef;
    int flag = 0;
@@ -786,11 +795,22 @@ static int fdomain_isa_detect( int *irq, int *iobase )
    *iobase = base;
 
    return 1;			/* success */
-#else
-   return 0;
-#endif
 }
 
+#else /* PCMCIA */
+
+static int fdomain_isa_detect( int *irq, int *iobase )
+{
+	if (irq)
+		*irq = 0;
+	if (iobase)
+		*iobase = 0;
+	return 0;
+}
+
+#endif /* !PCMCIA */
+
+
 /* PCI detection function: int fdomain_pci_bios_detect(int* irq, int*
    iobase) This function gets the Interrupt Level and I/O base address from
    the PCI configuration registers. */

commit e1eaf460098e4fd168908af4e6951f921951e916
Author: FUJITA Tomonori <fujita.tomonori@lab.ntt.co.jp>
Date:   Mon May 14 20:27:00 2007 +0900

    [SCSI] fdomain: convert to use the data buffer accessors
    
    - remove the unnecessary map_single path.
    
    - convert to use the new accessors for the sg lists and the
    parameters.
    
    Signed-off-by: FUJITA Tomonori <fujita.tomonori@lab.ntt.co.jp>
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>

diff --git a/drivers/scsi/fdomain.c b/drivers/scsi/fdomain.c
index 5d4ea6f77953..0d1661a8116b 100644
--- a/drivers/scsi/fdomain.c
+++ b/drivers/scsi/fdomain.c
@@ -1345,16 +1345,15 @@ static irqreturn_t do_fdomain_16x0_intr(int irq, void *dev_id)
 
 #if ERRORS_ONLY
       if (current_SC->cmnd[0] == REQUEST_SENSE && !current_SC->SCp.Status) {
-	 if ((unsigned char)(*((char *)current_SC->request_buffer+2)) & 0x0f) {
+	      char *buf = scsi_sglist(current_SC);
+	 if ((unsigned char)(*(buf + 2)) & 0x0f) {
 	    unsigned char key;
 	    unsigned char code;
 	    unsigned char qualifier;
 
-	    key = (unsigned char)(*((char *)current_SC->request_buffer + 2))
-		  & 0x0f;
-	    code = (unsigned char)(*((char *)current_SC->request_buffer + 12));
-	    qualifier = (unsigned char)(*((char *)current_SC->request_buffer
-					  + 13));
+	    key = (unsigned char)(*(buf + 2)) & 0x0f;
+	    code = (unsigned char)(*(buf + 12));
+	    qualifier = (unsigned char)(*(buf + 13));
 
 	    if (key != UNIT_ATTENTION
 		&& !(key == NOT_READY
@@ -1405,8 +1404,8 @@ static int fdomain_16x0_queue(struct scsi_cmnd *SCpnt,
    printk( "queue: target = %d cmnd = 0x%02x pieces = %d size = %u\n",
 	   SCpnt->target,
 	   *(unsigned char *)SCpnt->cmnd,
-	   SCpnt->use_sg,
-	   SCpnt->request_bufflen );
+	   scsi_sg_count(SCpnt),
+	   scsi_bufflen(SCpnt));
 #endif
 
    fdomain_make_bus_idle();
@@ -1416,20 +1415,19 @@ static int fdomain_16x0_queue(struct scsi_cmnd *SCpnt,
 
    /* Initialize static data */
 
-   if (current_SC->use_sg) {
-      current_SC->SCp.buffer =
-	    (struct scatterlist *)current_SC->request_buffer;
-      current_SC->SCp.ptr              = page_address(current_SC->SCp.buffer->page) + current_SC->SCp.buffer->offset;
-      current_SC->SCp.this_residual    = current_SC->SCp.buffer->length;
-      current_SC->SCp.buffers_residual = current_SC->use_sg - 1;
+   if (scsi_sg_count(current_SC)) {
+	   current_SC->SCp.buffer = scsi_sglist(current_SC);
+	   current_SC->SCp.ptr = page_address(current_SC->SCp.buffer->page)
+		   + current_SC->SCp.buffer->offset;
+	   current_SC->SCp.this_residual    = current_SC->SCp.buffer->length;
+	   current_SC->SCp.buffers_residual = scsi_sg_count(current_SC) - 1;
    } else {
-      current_SC->SCp.ptr              = (char *)current_SC->request_buffer;
-      current_SC->SCp.this_residual    = current_SC->request_bufflen;
-      current_SC->SCp.buffer           = NULL;
-      current_SC->SCp.buffers_residual = 0;
+	   current_SC->SCp.ptr              = 0;
+	   current_SC->SCp.this_residual    = 0;
+	   current_SC->SCp.buffer           = NULL;
+	   current_SC->SCp.buffers_residual = 0;
    }
-	 
-   
+
    current_SC->SCp.Status              = 0;
    current_SC->SCp.Message             = 0;
    current_SC->SCp.have_data_in        = 0;
@@ -1472,8 +1470,8 @@ static void print_info(struct scsi_cmnd *SCpnt)
 	   SCpnt->SCp.phase,
 	   SCpnt->device->id,
 	   *(unsigned char *)SCpnt->cmnd,
-	   SCpnt->use_sg,
-	   SCpnt->request_bufflen );
+	   scsi_sg_count(SCpnt),
+	   scsi_bufflen(SCpnt));
    printk( "sent_command = %d, have_data_in = %d, timeout = %d\n",
 	   SCpnt->SCp.sent_command,
 	   SCpnt->SCp.have_data_in,

commit 71fa0a849b384f066dea6a2351c722c19846f4ac
Merge: 9d81a782d55b d6b9ccbbeb62
Author: Linus Torvalds <torvalds@g5.osdl.org>
Date:   Wed Oct 25 20:22:55 2006 -0700

    Merge master.kernel.org:/pub/scm/linux/kernel/git/jejb/scsi-rc-fixes-2.6
    
    * master.kernel.org:/pub/scm/linux/kernel/git/jejb/scsi-rc-fixes-2.6: (40 commits)
      [SCSI] aic79xx: Print out signalling
      [SCSI] aic7xxx: Remove slave_destroy
      [SCSI] aic79xx: set precompensation
      [SCSI] aic79xx: Fixup external device reset
      [SCSI] replace u8 and u32 with __u8 and __u32 in scsi.h for user space
      [SCSI] lpfc: fix printk format warning
      [SCSI] aic79xx: make ahd_set_tags() static
      [SCSI] aic7xxx: cleanups
      [SCSI] drivers/scsi: Handcrafted MIN/MAX macro removal
      [SCSI] scsi_debug: support REPORT TARGET PORT GROUPS
      [SCSI] qla1280 bus reset typo
      [SCSI] libiscsi: fix logout pdu processing
      [SCSI] libiscsi: fix aen support
      [SCSI] libiscsi: fix missed iscsi_task_put in xmit error path
      [SCSI] libiscsi: fix oops in connection create failure path
      [SCSI] iscsi class: fix slab corruption during restart
      [SCSI] Switch fdomain to the pci_get API
      [SCSI] add can_queue to host parameters
      [SCSI] megaraid_{mm,mbox}: 64-bit DMA capability fix
      [SCSI] aic94xx: Supermicro motherboards support
      ...

commit 47bcd3546d5141e54f15e40a20dc01d7c5f5a473
Author: Alan Cox <alan@lxorguk.ukuu.org.uk>
Date:   Mon Oct 16 16:55:46 2006 +0100

    [SCSI] Switch fdomain to the pci_get API
    
    Doesn't make the hardware hot pluggable but does ensure the driver won't
    crash when another device is hot-unplugged at the wrong moment. Soon I
    propose to deprecate pci_find_device() and some of its friends.
    
    Signed-off-by: Alan Cox <alan@redhat.com>
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>

diff --git a/drivers/scsi/fdomain.c b/drivers/scsi/fdomain.c
index 41b05fc45380..2a964240cf4c 100644
--- a/drivers/scsi/fdomain.c
+++ b/drivers/scsi/fdomain.c
@@ -387,6 +387,7 @@ static void __iomem *    bios_mem;
 static int               bios_major;
 static int               bios_minor;
 static int               PCI_bus;
+static struct pci_dev	*PCI_dev;
 static int               Quantum;	/* Quantum board variant */
 static int               interrupt_level;
 static volatile int      in_command;
@@ -812,9 +813,10 @@ static int fdomain_pci_bios_detect( int *irq, int *iobase, struct pci_dev **ret_
 	   PCI_DEVICE_ID_FD_36C70 );
 #endif 
 
-   if ((pdev = pci_find_device(PCI_VENDOR_ID_FD, PCI_DEVICE_ID_FD_36C70, pdev)) == NULL)
+   if ((pdev = pci_get_device(PCI_VENDOR_ID_FD, PCI_DEVICE_ID_FD_36C70, pdev)) == NULL)
 		return 0;
-   if (pci_enable_device(pdev)) return 0;
+   if (pci_enable_device(pdev))
+   	goto fail;
        
 #if DEBUG_DETECT
    printk( "scsi: <fdomain> TMC-3260 detect:"
@@ -831,7 +833,7 @@ static int fdomain_pci_bios_detect( int *irq, int *iobase, struct pci_dev **ret_
    pci_irq = pdev->irq;
 
    if (!request_region( pci_base, 0x10, "fdomain" ))
-	return 0;
+   	goto fail;
 
    /* Now we have the I/O base address and interrupt from the PCI
       configuration registers. */
@@ -848,17 +850,22 @@ static int fdomain_pci_bios_detect( int *irq, int *iobase, struct pci_dev **ret_
    if (!fdomain_is_valid_port(pci_base)) {
       printk(KERN_ERR "scsi: <fdomain> PCI card detected, but driver not loaded (invalid port)\n" );
       release_region(pci_base, 0x10);
-      return 0;
+      goto fail;
    }
 
 				/* Fill in a few global variables.  Ugh. */
    bios_major = bios_minor = -1;
    PCI_bus    = 1;
+   PCI_dev    = pdev;
    Quantum    = 0;
    bios_base  = 0;
    
    return 1;
+fail:
+   pci_dev_put(pdev);
+   return 0;
 }
+
 #endif
 
 struct Scsi_Host *__fdomain_16x0_detect(struct scsi_host_template *tpnt )
@@ -909,8 +916,7 @@ struct Scsi_Host *__fdomain_16x0_detect(struct scsi_host_template *tpnt )
       if (setup_called) {
 	 printk(KERN_ERR "scsi: <fdomain> Bad LILO/INSMOD parameters?\n");
       }
-      release_region(port_base, 0x10);
-      return NULL;
+      goto fail;
    }
 
    if (this_id) {
@@ -942,8 +948,7 @@ struct Scsi_Host *__fdomain_16x0_detect(struct scsi_host_template *tpnt )
    /* Log IRQ with kernel */   
    if (!interrupt_level) {
       printk(KERN_ERR "scsi: <fdomain> Card Detected, but driver not loaded (no IRQ)\n" );
-      release_region(port_base, 0x10);
-      return NULL;
+      goto fail;
    } else {
       /* Register the IRQ with the kernel */
 
@@ -964,11 +969,14 @@ struct Scsi_Host *__fdomain_16x0_detect(struct scsi_host_template *tpnt )
 	    printk(KERN_ERR "                Send mail to faith@acm.org\n" );
 	 }
 	 printk(KERN_ERR "scsi: <fdomain> Detected, but driver not loaded (IRQ)\n" );
-         release_region(port_base, 0x10);
-	 return NULL;
+	 goto fail;
       }
    }
    return shpnt;
+fail:
+   pci_dev_put(pdev);
+   release_region(port_base, 0x10);
+   return NULL;
 }
 
 static int fdomain_16x0_detect(struct scsi_host_template *tpnt)
@@ -1714,6 +1722,8 @@ static int fdomain_16x0_release(struct Scsi_Host *shpnt)
 		free_irq(shpnt->irq, shpnt);
 	if (shpnt->io_port && shpnt->n_io_port)
 		release_region(shpnt->io_port, shpnt->n_io_port);
+	if (PCI_bus)
+		pci_dev_put(PCI_dev);
 	return 0;
 }
 

commit 3985b977441f857404bb604a4b15911bbb0b9c5b
Author: Ben Collins <bcollins@ubuntu.com>
Date:   Wed Oct 18 08:38:41 2006 -0400

    [fdomain] Add pci dev table for module auto loading.
    
    Signed-off-by: Ben Collins <bcollins@ubuntu.com>

diff --git a/drivers/scsi/fdomain.c b/drivers/scsi/fdomain.c
index 72794a7b6dcc..65e6e7b7ba07 100644
--- a/drivers/scsi/fdomain.c
+++ b/drivers/scsi/fdomain.c
@@ -1736,6 +1736,15 @@ struct scsi_host_template fdomain_driver_template = {
 };
 
 #ifndef PCMCIA
+
+static struct pci_device_id fdomain_pci_tbl[] __devinitdata = {
+	{ PCI_VENDOR_ID_FD, PCI_DEVICE_ID_FD_36C70,
+	  PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0UL },
+	{ }
+};
+MODULE_DEVICE_TABLE(pci, fdomain_pci_tbl);
+
 #define driver_template fdomain_driver_template
 #include "scsi_module.c"
+
 #endif

commit 53d5ed627df852ba8bab7f70df25290bd733792c
Author: Matthew Wilcox <matthew@wil.cx>
Date:   Wed Oct 11 01:22:01 2006 -0700

    [PATCH] Use linux/io.h instead of asm/io.h
    
    In preparation for moving check_signature, change these users from asm/io.h
    to linux/io.h
    
    Signed-off-by: Matthew Wilcox <willy@parisc-linux.org>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/drivers/scsi/fdomain.c b/drivers/scsi/fdomain.c
index 41b05fc45380..72794a7b6dcc 100644
--- a/drivers/scsi/fdomain.c
+++ b/drivers/scsi/fdomain.c
@@ -278,9 +278,9 @@
 #include <linux/pci.h>
 #include <linux/stat.h>
 #include <linux/delay.h>
+#include <linux/io.h>
 #include <scsi/scsicam.h>
 
-#include <asm/io.h>
 #include <asm/system.h>
 
 #include <scsi/scsi.h>

commit 7d12e780e003f93433d49ce78cfedf4b4c52adc5
Author: David Howells <dhowells@redhat.com>
Date:   Thu Oct 5 14:55:46 2006 +0100

    IRQ: Maintain regs pointer globally rather than passing to IRQ handlers
    
    Maintain a per-CPU global "struct pt_regs *" variable which can be used instead
    of passing regs around manually through all ~1800 interrupt handlers in the
    Linux kernel.
    
    The regs pointer is used in few places, but it potentially costs both stack
    space and code to pass it around.  On the FRV arch, removing the regs parameter
    from all the genirq function results in a 20% speed up of the IRQ exit path
    (ie: from leaving timer_interrupt() to leaving do_IRQ()).
    
    Where appropriate, an arch may override the generic storage facility and do
    something different with the variable.  On FRV, for instance, the address is
    maintained in GR28 at all times inside the kernel as part of general exception
    handling.
    
    Having looked over the code, it appears that the parameter may be handed down
    through up to twenty or so layers of functions.  Consider a USB character
    device attached to a USB hub, attached to a USB controller that posts its
    interrupts through a cascaded auxiliary interrupt controller.  A character
    device driver may want to pass regs to the sysrq handler through the input
    layer which adds another few layers of parameter passing.
    
    I've build this code with allyesconfig for x86_64 and i386.  I've runtested the
    main part of the code on FRV and i386, though I can't test most of the drivers.
    I've also done partial conversion for powerpc and MIPS - these at least compile
    with minimal configurations.
    
    This will affect all archs.  Mostly the changes should be relatively easy.
    Take do_IRQ(), store the regs pointer at the beginning, saving the old one:
    
            struct pt_regs *old_regs = set_irq_regs(regs);
    
    And put the old one back at the end:
    
            set_irq_regs(old_regs);
    
    Don't pass regs through to generic_handle_irq() or __do_IRQ().
    
    In timer_interrupt(), this sort of change will be necessary:
    
            -       update_process_times(user_mode(regs));
            -       profile_tick(CPU_PROFILING, regs);
            +       update_process_times(user_mode(get_irq_regs()));
            +       profile_tick(CPU_PROFILING);
    
    I'd like to move update_process_times()'s use of get_irq_regs() into itself,
    except that i386, alone of the archs, uses something other than user_mode().
    
    Some notes on the interrupt handling in the drivers:
    
     (*) input_dev() is now gone entirely.  The regs pointer is no longer stored in
         the input_dev struct.
    
     (*) finish_unlinks() in drivers/usb/host/ohci-q.c needs checking.  It does
         something different depending on whether it's been supplied with a regs
         pointer or not.
    
     (*) Various IRQ handler function pointers have been moved to type
         irq_handler_t.
    
    Signed-Off-By: David Howells <dhowells@redhat.com>
    (cherry picked from 1b16e7ac850969f38b375e511e3fa2f474a33867 commit)

diff --git a/drivers/scsi/fdomain.c b/drivers/scsi/fdomain.c
index b0694dcce246..41b05fc45380 100644
--- a/drivers/scsi/fdomain.c
+++ b/drivers/scsi/fdomain.c
@@ -403,8 +403,7 @@ static volatile int      in_interrupt_flag;
 static int               FIFO_Size = 0x2000; /* 8k FIFO for
 						pre-tmc18c30 chips */
 
-static irqreturn_t       do_fdomain_16x0_intr( int irq, void *dev_id,
-					    struct pt_regs * regs );
+static irqreturn_t       do_fdomain_16x0_intr( int irq, void *dev_id );
 /* Allow insmod parameters to be like LILO parameters.  For example:
    insmod fdomain fdomain=0x140,11 */
 static char * fdomain = NULL;
@@ -1094,8 +1093,7 @@ static void my_done(int error)
 #endif
 }
 
-static irqreturn_t do_fdomain_16x0_intr(int irq, void *dev_id,
-					struct pt_regs * regs )
+static irqreturn_t do_fdomain_16x0_intr(int irq, void *dev_id)
 {
    unsigned long flags;
    int      status;

commit 1d6f359a2e06296418481239f8054a878f36e819
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Sat Jul 1 19:29:42 2006 -0700

    [PATCH] irq-flags: scsi: Use the new IRQF_ constants
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Cc: Ingo Molnar <mingo@elte.hu>
    Cc: "David S. Miller" <davem@davemloft.net>
    Cc: Benjamin Herrenschmidt <benh@kernel.crashing.org>
    Cc: James Bottomley <James.Bottomley@steeleye.com>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/drivers/scsi/fdomain.c b/drivers/scsi/fdomain.c
index 03356887202d..b0694dcce246 100644
--- a/drivers/scsi/fdomain.c
+++ b/drivers/scsi/fdomain.c
@@ -949,7 +949,7 @@ struct Scsi_Host *__fdomain_16x0_detect(struct scsi_host_template *tpnt )
       /* Register the IRQ with the kernel */
 
       retcode = request_irq( interrupt_level,
-			     do_fdomain_16x0_intr, pdev?SA_SHIRQ:0, "fdomain", shpnt);
+			     do_fdomain_16x0_intr, pdev?IRQF_SHARED:0, "fdomain", shpnt);
 
       if (retcode < 0) {
 	 if (retcode == -EINVAL) {

commit 6ab3d5624e172c553004ecc862bfeac16d9d68b7
Author: Jörn Engel <joern@wohnheim.fh-wedel.de>
Date:   Fri Jun 30 19:25:36 2006 +0200

    Remove obsolete #include <linux/config.h>
    
    Signed-off-by: Jörn Engel <joern@wohnheim.fh-wedel.de>
    Signed-off-by: Adrian Bunk <bunk@stusta.de>

diff --git a/drivers/scsi/fdomain.c b/drivers/scsi/fdomain.c
index e16013f0ad6e..03356887202d 100644
--- a/drivers/scsi/fdomain.c
+++ b/drivers/scsi/fdomain.c
@@ -266,7 +266,6 @@
 
  **************************************************************************/
 
-#include <linux/config.h>
 #include <linux/module.h>
 #include <linux/init.h>
 #include <linux/interrupt.h>

commit 6391a11375de5e2bb1eb8481e54619761dc65d9f
Author: Tobias Klauser <tklauser@nuerscht.ch>
Date:   Thu Jun 8 22:23:48 2006 -0700

    [SCSI] drivers/scsi: Use ARRAY_SIZE macro
    
    Use ARRAY_SIZE macro instead of sizeof(x)/sizeof(x[0]) and remove
    duplicates of the macro.
    
    Signed-off-by: Tobias Klauser <tklauser@nuerscht.ch>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>

diff --git a/drivers/scsi/fdomain.c b/drivers/scsi/fdomain.c
index 7334244397d1..e16013f0ad6e 100644
--- a/drivers/scsi/fdomain.c
+++ b/drivers/scsi/fdomain.c
@@ -420,10 +420,10 @@ static unsigned long addresses[] = {
    0xd0000,
    0xe0000,
 };
-#define ADDRESS_COUNT (sizeof( addresses ) / sizeof( unsigned ))
-		       
+#define ADDRESS_COUNT ARRAY_SIZE(addresses)
+
 static unsigned short ports[] = { 0x140, 0x150, 0x160, 0x170 };
-#define PORT_COUNT (sizeof( ports ) / sizeof( unsigned short ))
+#define PORT_COUNT ARRAY_SIZE(ports)
 
 static unsigned short ints[] = { 3, 5, 10, 11, 12, 14, 15, 0 };
 
@@ -502,7 +502,7 @@ static struct signature {
     geometry location are verified). */
 };
 
-#define SIGNATURE_COUNT (sizeof( signatures ) / sizeof( struct signature ))
+#define SIGNATURE_COUNT ARRAY_SIZE(signatures)
 
 static void print_banner( struct Scsi_Host *shpnt )
 {
@@ -519,7 +519,7 @@ static void print_banner( struct Scsi_Host *shpnt )
 
       if (bios_minor >= 0) printk("%d", bios_minor);
       else                 printk("?.");
-   
+
       printk( " at 0x%lx using scsi id %d\n",
 	      bios_base, shpnt->this_id );
    }

commit 422c0d61d591cbfb70f029e13505fb437e169d68
Author: Jeff Garzik <jgarzik@pobox.com>
Date:   Mon Oct 24 18:05:09 2005 -0400

    [SCSI] use scmd_id(), scmd_channel() throughout code
    
    Wrap a highly common idiom.  Makes the code easier to read, helps pave
    the way for sdev->{id,channel} removal, and adds a token that can easily
    by grepped-for in the future.
    
    There are a couple sdev_id() and scmd_printk() updates thrown in as well.
    
    Rejections fixed up and
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>

diff --git a/drivers/scsi/fdomain.c b/drivers/scsi/fdomain.c
index 3b2a5bf5c43e..7334244397d1 100644
--- a/drivers/scsi/fdomain.c
+++ b/drivers/scsi/fdomain.c
@@ -1154,7 +1154,7 @@ static irqreturn_t do_fdomain_16x0_intr(int irq, void *dev_id,
       outb(0x40 | FIFO_COUNT, port_base + Interrupt_Cntl);
 
       outb(0x82, port_base + SCSI_Cntl); /* Bus Enable + Select */
-      outb(adapter_mask | (1 << current_SC->device->id), port_base + SCSI_Data_NoACK);
+      outb(adapter_mask | (1 << scmd_id(current_SC)), port_base + SCSI_Data_NoACK);
       
       /* Stop arbitration and enable parity */
       outb(0x10 | PARITY_MASK, port_base + TMC_Cntl);
@@ -1166,7 +1166,7 @@ static irqreturn_t do_fdomain_16x0_intr(int irq, void *dev_id,
       status = inb(port_base + SCSI_Status);
       if (!(status & 0x01)) {
 	 /* Try again, for slow devices */
-	 if (fdomain_select( current_SC->device->id )) {
+	 if (fdomain_select( scmd_id(current_SC) )) {
 #if EVERY_ACCESS
 	    printk( " SFAIL " );
 #endif

commit 77933d7276ee8fa0e2947641941a6f7a100a327b
Author: Jesper Juhl <juhl@dif.dk>
Date:   Wed Jul 27 11:46:09 2005 -0700

    [PATCH] clean up inline static vs static inline
    
    `gcc -W' likes to complain if the static keyword is not at the beginning of
    the declaration.  This patch fixes all remaining occurrences of "inline
    static" up with "static inline" in the entire kernel tree (140 occurrences in
    47 files).
    
    While making this change I came across a few lines with trailing whitespace
    that I also fixed up, I have also added or removed a blank line or two here
    and there, but there are no functional changes in the patch.
    
    Signed-off-by: Jesper Juhl <juhl-lkml@dif.dk>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/drivers/scsi/fdomain.c b/drivers/scsi/fdomain.c
index aecf32dd0bde..3b2a5bf5c43e 100644
--- a/drivers/scsi/fdomain.c
+++ b/drivers/scsi/fdomain.c
@@ -570,7 +570,7 @@ static void do_pause(unsigned amount)	/* Pause for amount*10 milliseconds */
 	mdelay(10*amount);
 }
 
-inline static void fdomain_make_bus_idle( void )
+static inline void fdomain_make_bus_idle( void )
 {
    outb(0, port_base + SCSI_Cntl);
    outb(0, port_base + SCSI_Mode_Cntl);

commit 12413197eef2a29e0b9fb0fa541f5cbaeb1d3f3f
Author: Christoph Hellwig <hch@lst.de>
Date:   Sat Jun 11 01:05:01 2005 +0200

    [SCSI] remove scsi_set_device
    
    scsi_add_host is the proper place to set the device, but people copy
    the scsi_set_device usage from older drivers again and again.
    
    note that this leaves some legacy drivers like qlogicisp/qlogicfc
    without pci association in sysfs, but they're scheduled to go away soon
    anyway.
    
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>

diff --git a/drivers/scsi/fdomain.c b/drivers/scsi/fdomain.c
index 4ba6a15cf43d..aecf32dd0bde 100644
--- a/drivers/scsi/fdomain.c
+++ b/drivers/scsi/fdomain.c
@@ -938,7 +938,6 @@ struct Scsi_Host *__fdomain_16x0_detect(struct scsi_host_template *tpnt )
    }
    shpnt->irq = interrupt_level;
    shpnt->io_port = port_base;
-   scsi_set_device(shpnt, &pdev->dev);
    shpnt->n_io_port = 0x10;
    print_banner( shpnt );
 

commit 68b3aa7c9805aee9005a8ca53c5e99177961fbb9
Author: Jeff Garzik <jgarzik@pobox.com>
Date:   Sat May 28 07:56:31 2005 -0400

    [SCSI] allow sleeping in ->eh_bus_reset_handler()
    
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>

diff --git a/drivers/scsi/fdomain.c b/drivers/scsi/fdomain.c
index a843c080c1d8..4ba6a15cf43d 100644
--- a/drivers/scsi/fdomain.c
+++ b/drivers/scsi/fdomain.c
@@ -1543,12 +1543,18 @@ static int fdomain_16x0_abort(struct scsi_cmnd *SCpnt)
 
 int fdomain_16x0_bus_reset(struct scsi_cmnd *SCpnt)
 {
+   unsigned long flags;
+
+   local_irq_save(flags);
+
    outb(1, port_base + SCSI_Cntl);
    do_pause( 2 );
    outb(0, port_base + SCSI_Cntl);
    do_pause( 115 );
    outb(0, port_base + SCSI_Mode_Cntl);
    outb(PARITY_MASK, port_base + TMC_Cntl);
+
+   local_irq_restore(flags);
    return SUCCESS;
 }
 

commit 1da177e4c3f41524e886b7f1b8a0c1fc7321cac2
Author: Linus Torvalds <torvalds@ppc970.osdl.org>
Date:   Sat Apr 16 15:20:36 2005 -0700

    Linux-2.6.12-rc2
    
    Initial git repository build. I'm not bothering with the full history,
    even though we have it. We can create a separate "historical" git
    archive of that later if we want to, and in the meantime it's about
    3.2GB when imported into git - space that would just make the early
    git days unnecessarily complicated, when we don't have a lot of good
    infrastructure for it.
    
    Let it rip!

diff --git a/drivers/scsi/fdomain.c b/drivers/scsi/fdomain.c
new file mode 100644
index 000000000000..a843c080c1d8
--- /dev/null
+++ b/drivers/scsi/fdomain.c
@@ -0,0 +1,1739 @@
+/* fdomain.c -- Future Domain TMC-16x0 SCSI driver
+ * Created: Sun May  3 18:53:19 1992 by faith@cs.unc.edu
+ * Revised: Mon Dec 28 21:59:02 1998 by faith@acm.org
+ * Author: Rickard E. Faith, faith@cs.unc.edu
+ * Copyright 1992-1996, 1998 Rickard E. Faith (faith@acm.org)
+ * Shared IRQ supported added 7/7/2001  Alan Cox <alan@redhat.com>
+
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2, or (at your option) any
+ * later version.
+
+ * This program is distributed in the hope that it will be useful, but
+ * WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * General Public License for more details.
+
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 675 Mass Ave, Cambridge, MA 02139, USA.
+
+ **************************************************************************
+
+ SUMMARY:
+
+ Future Domain BIOS versions supported for autodetect:
+    2.0, 3.0, 3.2, 3.4 (1.0), 3.5 (2.0), 3.6, 3.61
+ Chips are supported:
+    TMC-1800, TMC-18C50, TMC-18C30, TMC-36C70
+ Boards supported:
+    Future Domain TMC-1650, TMC-1660, TMC-1670, TMC-1680, TMC-1610M/MER/MEX
+    Future Domain TMC-3260 (PCI)
+    Quantum ISA-200S, ISA-250MG
+    Adaptec AHA-2920A (PCI) [BUT *NOT* AHA-2920C -- use aic7xxx instead]
+    IBM ?
+ LILO/INSMOD command-line options:
+    fdomain=<PORT_BASE>,<IRQ>[,<ADAPTER_ID>]
+
+
+    
+ NOTE:
+
+ The Adaptec AHA-2920C has an Adaptec AIC-7850 chip on it.
+ Use the aic7xxx driver for this board.
+       
+ The Adaptec AHA-2920A has a Future Domain chip on it, so this is the right
+ driver for that card.  Unfortunately, the boxes will probably just say
+ "2920", so you'll have to look on the card for a Future Domain logo, or a
+ letter after the 2920.
+
+ 
+ 
+ THANKS:
+
+ Thanks to Adaptec for providing PCI boards for testing.  This finally
+ enabled me to test the PCI detection and correct it for PCI boards that do
+ not have a BIOS at a standard ISA location.  For PCI boards, LILO/INSMOD
+ command-line options should no longer be needed.  --RF 18Nov98
+
+
+ 
+ DESCRIPTION:
+ 
+ This is the Linux low-level SCSI driver for Future Domain TMC-1660/1680
+ TMC-1650/1670, and TMC-3260 SCSI host adapters.  The 1650 and 1670 have a
+ 25-pin external connector, whereas the 1660 and 1680 have a SCSI-2 50-pin
+ high-density external connector.  The 1670 and 1680 have floppy disk
+ controllers built in.  The TMC-3260 is a PCI bus card.
+
+ Future Domain's older boards are based on the TMC-1800 chip, and this
+ driver was originally written for a TMC-1680 board with the TMC-1800 chip.
+ More recently, boards are being produced with the TMC-18C50 and TMC-18C30
+ chips.  The latest and greatest board may not work with this driver.  If
+ you have to patch this driver so that it will recognize your board's BIOS
+ signature, then the driver may fail to function after the board is
+ detected.
+
+ Please note that the drive ordering that Future Domain implemented in BIOS
+ versions 3.4 and 3.5 is the opposite of the order (currently) used by the
+ rest of the SCSI industry.  If you have BIOS version 3.4 or 3.5, and have
+ more than one drive, then the drive ordering will be the reverse of that
+ which you see under DOS.  For example, under DOS SCSI ID 0 will be D: and
+ SCSI ID 1 will be C: (the boot device).  Under Linux, SCSI ID 0 will be
+ /dev/sda and SCSI ID 1 will be /dev/sdb.  The Linux ordering is consistent
+ with that provided by all the other SCSI drivers for Linux.  If you want
+ this changed, you will probably have to patch the higher level SCSI code.
+ If you do so, please send me patches that are protected by #ifdefs.
+
+ If you have a TMC-8xx or TMC-9xx board, then this is not the driver for
+ your board.  Please refer to the Seagate driver for more information and
+ possible support.
+
+ 
+ 
+ HISTORY:
+
+ Linux       Driver      Driver
+ Version     Version     Date         Support/Notes
+
+             0.0          3 May 1992  V2.0 BIOS; 1800 chip
+ 0.97        1.9         28 Jul 1992
+ 0.98.6      3.1         27 Nov 1992
+ 0.99        3.2          9 Dec 1992
+
+ 0.99.3      3.3         10 Jan 1993  V3.0 BIOS
+ 0.99.5      3.5         18 Feb 1993
+ 0.99.10     3.6         15 May 1993  V3.2 BIOS; 18C50 chip
+ 0.99.11     3.17         3 Jul 1993  (now under RCS)
+ 0.99.12     3.18        13 Aug 1993
+ 0.99.14     5.6         31 Oct 1993  (reselection code removed)
+
+ 0.99.15     5.9         23 Jan 1994  V3.4 BIOS (preliminary)
+ 1.0.8/1.1.1 5.15         1 Apr 1994  V3.4 BIOS; 18C30 chip (preliminary)
+ 1.0.9/1.1.3 5.16         7 Apr 1994  V3.4 BIOS; 18C30 chip
+ 1.1.38      5.18        30 Jul 1994  36C70 chip (PCI version of 18C30)
+ 1.1.62      5.20         2 Nov 1994  V3.5 BIOS
+ 1.1.73      5.22         7 Dec 1994  Quantum ISA-200S board; V2.0 BIOS
+
+ 1.1.82      5.26        14 Jan 1995  V3.5 BIOS; TMC-1610M/MER/MEX board
+ 1.2.10      5.28         5 Jun 1995  Quantum ISA-250MG board; V2.0, V2.01 BIOS
+ 1.3.4       5.31        23 Jun 1995  PCI BIOS-32 detection (preliminary)
+ 1.3.7       5.33         4 Jul 1995  PCI BIOS-32 detection
+ 1.3.28      5.36        17 Sep 1995  V3.61 BIOS; LILO command-line support
+ 1.3.34      5.39        12 Oct 1995  V3.60 BIOS; /proc
+ 1.3.72      5.39         8 Feb 1996  Adaptec AHA-2920 board
+ 1.3.85      5.41         4 Apr 1996
+ 2.0.12      5.44         8 Aug 1996  Use ID 7 for all PCI cards
+ 2.1.1       5.45         2 Oct 1996  Update ROM accesses for 2.1.x
+ 2.1.97      5.46	 23 Apr 1998  Rewritten PCI detection routines [mj]
+ 2.1.11x     5.47	  9 Aug 1998  Touched for 8 SCSI disk majors support
+             5.48        18 Nov 1998  BIOS no longer needed for PCI detection
+ 2.2.0       5.50        28 Dec 1998  Support insmod parameters
+ 
+
+ REFERENCES USED:
+
+ "TMC-1800 SCSI Chip Specification (FDC-1800T)", Future Domain Corporation,
+ 1990.
+
+ "Technical Reference Manual: 18C50 SCSI Host Adapter Chip", Future Domain
+ Corporation, January 1992.
+
+ "LXT SCSI Products: Specifications and OEM Technical Manual (Revision
+ B/September 1991)", Maxtor Corporation, 1991.
+
+ "7213S product Manual (Revision P3)", Maxtor Corporation, 1992.
+
+ "Draft Proposed American National Standard: Small Computer System
+ Interface - 2 (SCSI-2)", Global Engineering Documents. (X3T9.2/86-109,
+ revision 10h, October 17, 1991)
+
+ Private communications, Drew Eckhardt (drew@cs.colorado.edu) and Eric
+ Youngdale (ericy@cais.com), 1992.
+
+ Private communication, Tuong Le (Future Domain Engineering department),
+ 1994. (Disk geometry computations for Future Domain BIOS version 3.4, and
+ TMC-18C30 detection.)
+
+ Hogan, Thom. The Programmer's PC Sourcebook. Microsoft Press, 1988. Page
+ 60 (2.39: Disk Partition Table Layout).
+
+ "18C30 Technical Reference Manual", Future Domain Corporation, 1993, page
+ 6-1.
+
+
+ 
+ NOTES ON REFERENCES:
+
+ The Maxtor manuals were free.  Maxtor telephone technical support is
+ great!
+
+ The Future Domain manuals were $25 and $35.  They document the chip, not
+ the TMC-16x0 boards, so some information I had to guess at.  In 1992,
+ Future Domain sold DOS BIOS source for $250 and the UN*X driver source was
+ $750, but these required a non-disclosure agreement, so even if I could
+ have afforded them, they would *not* have been useful for writing this
+ publically distributable driver.  Future Domain technical support has
+ provided some information on the phone and have sent a few useful FAXs.
+ They have been much more helpful since they started to recognize that the
+ word "Linux" refers to an operating system :-).
+
+ 
+
+ ALPHA TESTERS:
+
+ There are many other alpha testers that come and go as the driver
+ develops.  The people listed here were most helpful in times of greatest
+ need (mostly early on -- I've probably left out a few worthy people in
+ more recent times):
+
+ Todd Carrico (todd@wutc.wustl.edu), Dan Poirier (poirier@cs.unc.edu ), Ken
+ Corey (kenc@sol.acs.unt.edu), C. de Bruin (bruin@bruin@sterbbs.nl), Sakari
+ Aaltonen (sakaria@vipunen.hit.fi), John Rice (rice@xanth.cs.odu.edu), Brad
+ Yearwood (brad@optilink.com), and Ray Toy (toy@soho.crd.ge.com).
+
+ Special thanks to Tien-Wan Yang (twyang@cs.uh.edu), who graciously lent me
+ his 18C50-based card for debugging.  He is the sole reason that this
+ driver works with the 18C50 chip.
+
+ Thanks to Dave Newman (dnewman@crl.com) for providing initial patches for
+ the version 3.4 BIOS.
+
+ Thanks to James T. McKinley (mckinley@msupa.pa.msu.edu) for providing
+ patches that support the TMC-3260, a PCI bus card with the 36C70 chip.
+ The 36C70 chip appears to be "completely compatible" with the 18C30 chip.
+
+ Thanks to Eric Kasten (tigger@petroglyph.cl.msu.edu) for providing the
+ patch for the version 3.5 BIOS.
+
+ Thanks for Stephen Henson (shenson@nyx10.cs.du.edu) for providing the
+ patch for the Quantum ISA-200S SCSI adapter.
+ 
+ Thanks to Adam Bowen for the signature to the 1610M/MER/MEX scsi cards, to
+ Martin Andrews (andrewm@ccfadm.eeg.ccf.org) for the signature to some
+ random TMC-1680 repackaged by IBM; and to Mintak Ng (mintak@panix.com) for
+ the version 3.61 BIOS signature.
+
+ Thanks for Mark Singer (elf@netcom.com) and Richard Simpson
+ (rsimpson@ewrcsdra.demon.co.uk) for more Quantum signatures and detective
+ work on the Quantum RAM layout.
+
+ Special thanks to James T. McKinley (mckinley@msupa.pa.msu.edu) for
+ providing patches for proper PCI BIOS32-mediated detection of the TMC-3260
+ card (a PCI bus card with the 36C70 chip).  Please send James PCI-related
+ bug reports.
+
+ Thanks to Tom Cavin (tec@usa1.com) for preliminary command-line option
+ patches.
+
+ New PCI detection code written by Martin Mares <mj@atrey.karlin.mff.cuni.cz>
+
+ Insmod parameter code based on patches from Daniel Graham
+ <graham@balance.uoregon.edu>. 
+ 
+ All of the alpha testers deserve much thanks.
+
+
+
+ NOTES ON USER DEFINABLE OPTIONS:
+
+ DEBUG: This turns on the printing of various debug information.
+
+ ENABLE_PARITY: This turns on SCSI parity checking.  With the current
+ driver, all attached devices must support SCSI parity.  If none of your
+ devices support parity, then you can probably get the driver to work by
+ turning this option off.  I have no way of testing this, however, and it
+ would appear that no one ever uses this option.
+
+ FIFO_COUNT: The host adapter has an 8K cache (host adapters based on the
+ 18C30 chip have a 2k cache).  When this many 512 byte blocks are filled by
+ the SCSI device, an interrupt will be raised.  Therefore, this could be as
+ low as 0, or as high as 16.  Note, however, that values which are too high
+ or too low seem to prevent any interrupts from occurring, and thereby lock
+ up the machine.  I have found that 2 is a good number, but throughput may
+ be increased by changing this value to values which are close to 2.
+ Please let me know if you try any different values.
+
+ RESELECTION: This is no longer an option, since I gave up trying to
+ implement it in version 4.x of this driver.  It did not improve
+ performance at all and made the driver unstable (because I never found one
+ of the two race conditions which were introduced by the multiple
+ outstanding command code).  The instability seems a very high price to pay
+ just so that you don't have to wait for the tape to rewind.  If you want
+ this feature implemented, send me patches.  I'll be happy to send a copy
+ of my (broken) driver to anyone who would like to see a copy.
+
+ **************************************************************************/
+
+#include <linux/config.h>
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/interrupt.h>
+#include <linux/blkdev.h>
+#include <linux/spinlock.h>
+#include <linux/errno.h>
+#include <linux/string.h>
+#include <linux/ioport.h>
+#include <linux/proc_fs.h>
+#include <linux/pci.h>
+#include <linux/stat.h>
+#include <linux/delay.h>
+#include <scsi/scsicam.h>
+
+#include <asm/io.h>
+#include <asm/system.h>
+
+#include <scsi/scsi.h>
+#include <scsi/scsi_cmnd.h>
+#include <scsi/scsi_device.h>
+#include <scsi/scsi_host.h>
+#include <scsi/scsi_ioctl.h>
+#include "fdomain.h"
+
+MODULE_AUTHOR("Rickard E. Faith");
+MODULE_DESCRIPTION("Future domain SCSI driver");
+MODULE_LICENSE("GPL");
+
+  
+#define VERSION          "$Revision: 5.51 $"
+
+/* START OF USER DEFINABLE OPTIONS */
+
+#define DEBUG            0	/* Enable debugging output */
+#define ENABLE_PARITY    1	/* Enable SCSI Parity */
+#define FIFO_COUNT       2	/* Number of 512 byte blocks before INTR */
+
+/* END OF USER DEFINABLE OPTIONS */
+
+#if DEBUG
+#define EVERY_ACCESS     0	/* Write a line on every scsi access */
+#define ERRORS_ONLY      1	/* Only write a line if there is an error */
+#define DEBUG_DETECT     0	/* Debug fdomain_16x0_detect() */
+#define DEBUG_MESSAGES   1	/* Debug MESSAGE IN phase */
+#define DEBUG_ABORT      1	/* Debug abort() routine */
+#define DEBUG_RESET      1	/* Debug reset() routine */
+#define DEBUG_RACE       1      /* Debug interrupt-driven race condition */
+#else
+#define EVERY_ACCESS     0	/* LEAVE THESE ALONE--CHANGE THE ONES ABOVE */
+#define ERRORS_ONLY      0
+#define DEBUG_DETECT     0
+#define DEBUG_MESSAGES   0
+#define DEBUG_ABORT      0
+#define DEBUG_RESET      0
+#define DEBUG_RACE       0
+#endif
+
+/* Errors are reported on the line, so we don't need to report them again */
+#if EVERY_ACCESS
+#undef ERRORS_ONLY
+#define ERRORS_ONLY      0
+#endif
+
+#if ENABLE_PARITY
+#define PARITY_MASK      0x08
+#else
+#define PARITY_MASK      0x00
+#endif
+
+enum chip_type {
+   unknown          = 0x00,
+   tmc1800          = 0x01,
+   tmc18c50         = 0x02,
+   tmc18c30         = 0x03,
+};
+
+enum {
+   in_arbitration   = 0x02,
+   in_selection     = 0x04,
+   in_other         = 0x08,
+   disconnect       = 0x10,
+   aborted          = 0x20,
+   sent_ident       = 0x40,
+};
+
+enum in_port_type {
+   Read_SCSI_Data   =  0,
+   SCSI_Status      =  1,
+   TMC_Status       =  2,
+   FIFO_Status      =  3,	/* tmc18c50/tmc18c30 only */
+   Interrupt_Cond   =  4,	/* tmc18c50/tmc18c30 only */
+   LSB_ID_Code      =  5,
+   MSB_ID_Code      =  6,
+   Read_Loopback    =  7,
+   SCSI_Data_NoACK  =  8,
+   Interrupt_Status =  9,
+   Configuration1   = 10,
+   Configuration2   = 11,	/* tmc18c50/tmc18c30 only */
+   Read_FIFO        = 12,
+   FIFO_Data_Count  = 14
+};
+
+enum out_port_type {
+   Write_SCSI_Data  =  0,
+   SCSI_Cntl        =  1,
+   Interrupt_Cntl   =  2,
+   SCSI_Mode_Cntl   =  3,
+   TMC_Cntl         =  4,
+   Memory_Cntl      =  5,	/* tmc18c50/tmc18c30 only */
+   Write_Loopback   =  7,
+   IO_Control       = 11,	/* tmc18c30 only */
+   Write_FIFO       = 12
+};
+
+/* .bss will zero all the static variables below */
+static int               port_base;
+static unsigned long     bios_base;
+static void __iomem *    bios_mem;
+static int               bios_major;
+static int               bios_minor;
+static int               PCI_bus;
+static int               Quantum;	/* Quantum board variant */
+static int               interrupt_level;
+static volatile int      in_command;
+static struct scsi_cmnd  *current_SC;
+static enum chip_type    chip              = unknown;
+static int               adapter_mask;
+static int               this_id;
+static int               setup_called;
+
+#if DEBUG_RACE
+static volatile int      in_interrupt_flag;
+#endif
+
+static int               FIFO_Size = 0x2000; /* 8k FIFO for
+						pre-tmc18c30 chips */
+
+static irqreturn_t       do_fdomain_16x0_intr( int irq, void *dev_id,
+					    struct pt_regs * regs );
+/* Allow insmod parameters to be like LILO parameters.  For example:
+   insmod fdomain fdomain=0x140,11 */
+static char * fdomain = NULL;
+module_param(fdomain, charp, 0);
+
+static unsigned long addresses[] = {
+   0xc8000,
+   0xca000,
+   0xce000,
+   0xde000,
+   0xcc000,		/* Extra addresses for PCI boards */
+   0xd0000,
+   0xe0000,
+};
+#define ADDRESS_COUNT (sizeof( addresses ) / sizeof( unsigned ))
+		       
+static unsigned short ports[] = { 0x140, 0x150, 0x160, 0x170 };
+#define PORT_COUNT (sizeof( ports ) / sizeof( unsigned short ))
+
+static unsigned short ints[] = { 3, 5, 10, 11, 12, 14, 15, 0 };
+
+/*
+
+  READ THIS BEFORE YOU ADD A SIGNATURE!
+
+  READING THIS SHORT NOTE CAN SAVE YOU LOTS OF TIME!
+
+  READ EVERY WORD, ESPECIALLY THE WORD *NOT*
+
+  This driver works *ONLY* for Future Domain cards using the TMC-1800,
+  TMC-18C50, or TMC-18C30 chip.  This includes models TMC-1650, 1660, 1670,
+  and 1680.  These are all 16-bit cards.
+
+  The following BIOS signature signatures are for boards which do *NOT*
+  work with this driver (these TMC-8xx and TMC-9xx boards may work with the
+  Seagate driver):
+
+  FUTURE DOMAIN CORP. (C) 1986-1988 V4.0I 03/16/88
+  FUTURE DOMAIN CORP. (C) 1986-1989 V5.0C2/14/89
+  FUTURE DOMAIN CORP. (C) 1986-1989 V6.0A7/28/89
+  FUTURE DOMAIN CORP. (C) 1986-1990 V6.0105/31/90
+  FUTURE DOMAIN CORP. (C) 1986-1990 V6.0209/18/90
+  FUTURE DOMAIN CORP. (C) 1986-1990 V7.009/18/90
+  FUTURE DOMAIN CORP. (C) 1992 V8.00.004/02/92
+
+  (The cards which do *NOT* work are all 8-bit cards -- although some of
+  them have a 16-bit form-factor, the upper 8-bits are used only for IRQs
+  and are *NOT* used for data.  You can tell the difference by following
+  the tracings on the circuit board -- if only the IRQ lines are involved,
+  you have a "8-bit" card, and should *NOT* use this driver.)
+
+*/
+
+static struct signature {
+   const char *signature;
+   int  sig_offset;
+   int  sig_length;
+   int  major_bios_version;
+   int  minor_bios_version;
+   int  flag; /* 1 == PCI_bus, 2 == ISA_200S, 3 == ISA_250MG, 4 == ISA_200S */
+} signatures[] = {
+   /*          1         2         3         4         5         6 */
+   /* 123456789012345678901234567890123456789012345678901234567890 */
+   { "FUTURE DOMAIN CORP. (C) 1986-1990 1800-V2.07/28/89",  5, 50,  2,  0, 0 },
+   { "FUTURE DOMAIN CORP. (C) 1986-1990 1800-V1.07/28/89",  5, 50,  2,  0, 0 },
+   { "FUTURE DOMAIN CORP. (C) 1986-1990 1800-V2.07/28/89", 72, 50,  2,  0, 2 },
+   { "FUTURE DOMAIN CORP. (C) 1986-1990 1800-V2.0",        73, 43,  2,  0, 3 },
+   { "FUTURE DOMAIN CORP. (C) 1991 1800-V2.0.",            72, 39,  2,  0, 4 },
+   { "FUTURE DOMAIN CORP. (C) 1992 V3.00.004/02/92",        5, 44,  3,  0, 0 },
+   { "FUTURE DOMAIN TMC-18XX (C) 1993 V3.203/12/93",        5, 44,  3,  2, 0 },
+   { "IBM F1 P2 BIOS v1.0104/29/93",                        5, 28,  3, -1, 0 },
+   { "Future Domain Corp. V1.0008/18/93",                   5, 33,  3,  4, 0 },
+   { "Future Domain Corp. V1.0008/18/93",                  26, 33,  3,  4, 1 },
+   { "Adaptec AHA-2920 PCI-SCSI Card",                     42, 31,  3, -1, 1 },
+   { "IBM F1 P264/32",                                      5, 14,  3, -1, 1 },
+				/* This next signature may not be a 3.5 bios */
+   { "Future Domain Corp. V2.0108/18/93",                   5, 33,  3,  5, 0 },
+   { "FUTURE DOMAIN CORP.  V3.5008/18/93",                  5, 34,  3,  5, 0 },
+   { "FUTURE DOMAIN 18c30/18c50/1800 (C) 1994 V3.5",        5, 44,  3,  5, 0 },
+   { "FUTURE DOMAIN CORP.  V3.6008/18/93",                  5, 34,  3,  6, 0 },
+   { "FUTURE DOMAIN CORP.  V3.6108/18/93",                  5, 34,  3,  6, 0 },
+   { "FUTURE DOMAIN TMC-18XX",                              5, 22, -1, -1, 0 },
+
+   /* READ NOTICE ABOVE *BEFORE* YOU WASTE YOUR TIME ADDING A SIGNATURE
+    Also, fix the disk geometry code for your signature and send your
+    changes for faith@cs.unc.edu.  Above all, do *NOT* change any old
+    signatures!
+
+    Note that the last line will match a "generic" 18XX bios.  Because
+    Future Domain has changed the host SCSI ID and/or the location of the
+    geometry information in the on-board RAM area for each of the first
+    three BIOS's, it is still important to enter a fully qualified
+    signature in the table for any new BIOS's (after the host SCSI ID and
+    geometry location are verified). */
+};
+
+#define SIGNATURE_COUNT (sizeof( signatures ) / sizeof( struct signature ))
+
+static void print_banner( struct Scsi_Host *shpnt )
+{
+   if (!shpnt) return;		/* This won't ever happen */
+
+   if (bios_major < 0 && bios_minor < 0) {
+      printk(KERN_INFO "scsi%d: <fdomain> No BIOS; using scsi id %d\n",
+	      shpnt->host_no, shpnt->this_id);
+   } else {
+      printk(KERN_INFO "scsi%d: <fdomain> BIOS version ", shpnt->host_no);
+
+      if (bios_major >= 0) printk("%d.", bios_major);
+      else                 printk("?.");
+
+      if (bios_minor >= 0) printk("%d", bios_minor);
+      else                 printk("?.");
+   
+      printk( " at 0x%lx using scsi id %d\n",
+	      bios_base, shpnt->this_id );
+   }
+
+				/* If this driver works for later FD PCI
+				   boards, we will have to modify banner
+				   for additional PCI cards, but for now if
+				   it's PCI it's a TMC-3260 - JTM */
+   printk(KERN_INFO "scsi%d: <fdomain> %s chip at 0x%x irq ",
+	   shpnt->host_no,
+	   chip == tmc1800 ? "TMC-1800" : (chip == tmc18c50 ? "TMC-18C50" : (chip == tmc18c30 ? (PCI_bus ? "TMC-36C70 (PCI bus)" : "TMC-18C30") : "Unknown")),
+	   port_base);
+
+   if (interrupt_level)
+   	printk("%d", interrupt_level);
+   else
+        printk("<none>");
+
+   printk( "\n" );
+}
+
+int fdomain_setup(char *str)
+{
+	int ints[4];
+
+	(void)get_options(str, ARRAY_SIZE(ints), ints);
+
+	if (setup_called++ || ints[0] < 2 || ints[0] > 3) {
+		printk(KERN_INFO "scsi: <fdomain> Usage: fdomain=<PORT_BASE>,<IRQ>[,<ADAPTER_ID>]\n");
+		printk(KERN_ERR "scsi: <fdomain> Bad LILO/INSMOD parameters?\n");
+		return 0;
+	}
+
+	port_base       = ints[0] >= 1 ? ints[1] : 0;
+	interrupt_level = ints[0] >= 2 ? ints[2] : 0;
+	this_id         = ints[0] >= 3 ? ints[3] : 0;
+   
+	bios_major = bios_minor = -1; /* Use geometry for BIOS version >= 3.4 */
+	++setup_called;
+	return 1;
+}
+
+__setup("fdomain=", fdomain_setup);
+
+
+static void do_pause(unsigned amount)	/* Pause for amount*10 milliseconds */
+{
+	mdelay(10*amount);
+}
+
+inline static void fdomain_make_bus_idle( void )
+{
+   outb(0, port_base + SCSI_Cntl);
+   outb(0, port_base + SCSI_Mode_Cntl);
+   if (chip == tmc18c50 || chip == tmc18c30)
+	 outb(0x21 | PARITY_MASK, port_base + TMC_Cntl); /* Clear forced intr. */
+   else
+	 outb(0x01 | PARITY_MASK, port_base + TMC_Cntl);
+}
+
+static int fdomain_is_valid_port( int port )
+{
+#if DEBUG_DETECT 
+   printk( " (%x%x),",
+	   inb( port + MSB_ID_Code ), inb( port + LSB_ID_Code ) );
+#endif
+
+   /* The MCA ID is a unique id for each MCA compatible board.  We
+      are using ISA boards, but Future Domain provides the MCA ID
+      anyway.  We can use this ID to ensure that this is a Future
+      Domain TMC-1660/TMC-1680.
+    */
+
+   if (inb( port + LSB_ID_Code ) != 0xe9) { /* test for 0x6127 id */
+      if (inb( port + LSB_ID_Code ) != 0x27) return 0;
+      if (inb( port + MSB_ID_Code ) != 0x61) return 0;
+      chip = tmc1800;
+   } else {				    /* test for 0xe960 id */
+      if (inb( port + MSB_ID_Code ) != 0x60) return 0;
+      chip = tmc18c50;
+
+				/* Try to toggle 32-bit mode.  This only
+				   works on an 18c30 chip.  (User reports
+				   say this works, so we should switch to
+				   it in the near future.) */
+
+      outb( 0x80, port + IO_Control );
+      if ((inb( port + Configuration2 ) & 0x80) == 0x80) {
+	 outb( 0x00, port + IO_Control );
+	 if ((inb( port + Configuration2 ) & 0x80) == 0x00) {
+	    chip = tmc18c30;
+	    FIFO_Size = 0x800;	/* 2k FIFO */
+	 }
+      }
+				/* If that failed, we are an 18c50. */
+   }
+
+   return 1;
+}
+
+static int fdomain_test_loopback( void )
+{
+   int i;
+   int result;
+
+   for (i = 0; i < 255; i++) {
+      outb( i, port_base + Write_Loopback );
+      result = inb( port_base + Read_Loopback );
+      if (i != result)
+	    return 1;
+   }
+   return 0;
+}
+
+/* fdomain_get_irq assumes that we have a valid MCA ID for a
+   TMC-1660/TMC-1680 Future Domain board.  Now, check to be sure the
+   bios_base matches these ports.  If someone was unlucky enough to have
+   purchased more than one Future Domain board, then they will have to
+   modify this code, as we only detect one board here.  [The one with the
+   lowest bios_base.]
+
+   Note that this routine is only used for systems without a PCI BIOS32
+   (e.g., ISA bus).  For PCI bus systems, this routine will likely fail
+   unless one of the IRQs listed in the ints array is used by the board.
+   Sometimes it is possible to use the computer's BIOS setup screen to
+   configure a PCI system so that one of these IRQs will be used by the
+   Future Domain card. */
+
+static int fdomain_get_irq( int base )
+{
+   int options = inb(base + Configuration1);
+
+#if DEBUG_DETECT
+   printk("scsi: <fdomain> Options = %x\n", options);
+#endif
+ 
+   /* Check for board with lowest bios_base --
+      this isn't valid for the 18c30 or for
+      boards on the PCI bus, so just assume we
+      have the right board. */
+
+   if (chip != tmc18c30 && !PCI_bus && addresses[(options & 0xc0) >> 6 ] != bios_base)
+   	return 0;
+   return ints[(options & 0x0e) >> 1];
+}
+
+static int fdomain_isa_detect( int *irq, int *iobase )
+{
+#ifndef PCMCIA
+   int i, j;
+   int base = 0xdeadbeef;
+   int flag = 0;
+
+#if DEBUG_DETECT
+   printk( "scsi: <fdomain> fdomain_isa_detect:" );
+#endif
+
+   for (i = 0; i < ADDRESS_COUNT; i++) {
+      void __iomem *p = ioremap(addresses[i], 0x2000);
+      if (!p)
+	continue;
+#if DEBUG_DETECT
+      printk( " %lx(%lx),", addresses[i], bios_base );
+#endif
+      for (j = 0; j < SIGNATURE_COUNT; j++) {
+	 if (check_signature(p + signatures[j].sig_offset,
+			     signatures[j].signature,
+			     signatures[j].sig_length )) {
+	    bios_major = signatures[j].major_bios_version;
+	    bios_minor = signatures[j].minor_bios_version;
+	    PCI_bus    = (signatures[j].flag == 1);
+	    Quantum    = (signatures[j].flag > 1) ? signatures[j].flag : 0;
+	    bios_base  = addresses[i];
+	    bios_mem   = p;
+	    goto found;
+	 }
+      }
+      iounmap(p);
+   }
+ 
+found:
+   if (bios_major == 2) {
+      /* The TMC-1660/TMC-1680 has a RAM area just after the BIOS ROM.
+	 Assuming the ROM is enabled (otherwise we wouldn't have been
+	 able to read the ROM signature :-), then the ROM sets up the
+	 RAM area with some magic numbers, such as a list of port
+	 base addresses and a list of the disk "geometry" reported to
+	 DOS (this geometry has nothing to do with physical geometry).
+       */
+
+      switch (Quantum) {
+      case 2:			/* ISA_200S */
+      case 3:			/* ISA_250MG */
+	 base = readb(bios_mem + 0x1fa2) + (readb(bios_mem + 0x1fa3) << 8);
+	 break;
+      case 4:			/* ISA_200S (another one) */
+	 base = readb(bios_mem + 0x1fa3) + (readb(bios_mem + 0x1fa4) << 8);
+	 break;
+      default:
+	 base = readb(bios_mem + 0x1fcc) + (readb(bios_mem + 0x1fcd) << 8);
+	 break;
+      }
+   
+#if DEBUG_DETECT
+      printk( " %x,", base );
+#endif
+
+      for (i = 0; i < PORT_COUNT; i++) {
+	if (base == ports[i]) {
+		if (!request_region(base, 0x10, "fdomain"))
+			break;
+		if (!fdomain_is_valid_port(base)) {
+			release_region(base, 0x10);
+			break;
+		}
+		*irq    = fdomain_get_irq( base );
+		*iobase = base;
+		return 1;
+	}
+      }
+
+      /* This is a bad sign.  It usually means that someone patched the
+	 BIOS signature list (the signatures variable) to contain a BIOS
+	 signature for a board *OTHER THAN* the TMC-1660/TMC-1680. */
+      
+#if DEBUG_DETECT
+      printk( " RAM FAILED, " );
+#endif
+   }
+
+   /* Anyway, the alternative to finding the address in the RAM is to just
+      search through every possible port address for one that is attached
+      to the Future Domain card.  Don't panic, though, about reading all
+      these random port addresses -- there are rumors that the Future
+      Domain BIOS does something very similar.
+
+      Do not, however, check ports which the kernel knows are being used by
+      another driver. */
+
+   for (i = 0; i < PORT_COUNT; i++) {
+      base = ports[i];
+      if (!request_region(base, 0x10, "fdomain")) {
+#if DEBUG_DETECT
+	 printk( " (%x inuse),", base );
+#endif
+	 continue;
+      }
+#if DEBUG_DETECT
+      printk( " %x,", base );
+#endif
+      flag = fdomain_is_valid_port(base);
+      if (flag)
+	break;
+      release_region(base, 0x10);
+   }
+
+#if DEBUG_DETECT
+   if (flag) printk( " SUCCESS\n" );
+   else      printk( " FAILURE\n" );
+#endif
+
+   if (!flag) return 0;		/* iobase not found */
+
+   *irq    = fdomain_get_irq( base );
+   *iobase = base;
+
+   return 1;			/* success */
+#else
+   return 0;
+#endif
+}
+
+/* PCI detection function: int fdomain_pci_bios_detect(int* irq, int*
+   iobase) This function gets the Interrupt Level and I/O base address from
+   the PCI configuration registers. */
+
+#ifdef CONFIG_PCI
+static int fdomain_pci_bios_detect( int *irq, int *iobase, struct pci_dev **ret_pdev )
+{
+   unsigned int     pci_irq;                /* PCI interrupt line */
+   unsigned long    pci_base;               /* PCI I/O base address */
+   struct pci_dev   *pdev = NULL;
+
+#if DEBUG_DETECT
+   /* Tell how to print a list of the known PCI devices from bios32 and
+      list vendor and device IDs being used if in debug mode.  */
+      
+   printk( "scsi: <fdomain> INFO: use lspci -v to see list of PCI devices\n" );
+   printk( "scsi: <fdomain> TMC-3260 detect:"
+	   " Using Vendor ID: 0x%x and Device ID: 0x%x\n",
+	   PCI_VENDOR_ID_FD, 
+	   PCI_DEVICE_ID_FD_36C70 );
+#endif 
+
+   if ((pdev = pci_find_device(PCI_VENDOR_ID_FD, PCI_DEVICE_ID_FD_36C70, pdev)) == NULL)
+		return 0;
+   if (pci_enable_device(pdev)) return 0;
+       
+#if DEBUG_DETECT
+   printk( "scsi: <fdomain> TMC-3260 detect:"
+	   " PCI bus %u, device %u, function %u\n",
+	   pdev->bus->number,
+	   PCI_SLOT(pdev->devfn),
+	   PCI_FUNC(pdev->devfn));
+#endif
+
+   /* We now have the appropriate device function for the FD board so we
+      just read the PCI config info from the registers.  */
+
+   pci_base = pci_resource_start(pdev, 0);
+   pci_irq = pdev->irq;
+
+   if (!request_region( pci_base, 0x10, "fdomain" ))
+	return 0;
+
+   /* Now we have the I/O base address and interrupt from the PCI
+      configuration registers. */
+
+   *irq    = pci_irq;
+   *iobase = pci_base;
+   *ret_pdev = pdev;
+
+#if DEBUG_DETECT
+   printk( "scsi: <fdomain> TMC-3260 detect:"
+	   " IRQ = %d, I/O base = 0x%x [0x%lx]\n", *irq, *iobase, pci_base );
+#endif
+
+   if (!fdomain_is_valid_port(pci_base)) {
+      printk(KERN_ERR "scsi: <fdomain> PCI card detected, but driver not loaded (invalid port)\n" );
+      release_region(pci_base, 0x10);
+      return 0;
+   }
+
+				/* Fill in a few global variables.  Ugh. */
+   bios_major = bios_minor = -1;
+   PCI_bus    = 1;
+   Quantum    = 0;
+   bios_base  = 0;
+   
+   return 1;
+}
+#endif
+
+struct Scsi_Host *__fdomain_16x0_detect(struct scsi_host_template *tpnt )
+{
+   int              retcode;
+   struct Scsi_Host *shpnt;
+   struct pci_dev *pdev = NULL;
+
+   if (setup_called) {
+#if DEBUG_DETECT
+      printk( "scsi: <fdomain> No BIOS, using port_base = 0x%x, irq = %d\n",
+	      port_base, interrupt_level );
+#endif
+      if (!request_region(port_base, 0x10, "fdomain")) {
+	 printk( "scsi: <fdomain> port 0x%x is busy\n", port_base );
+	 printk( "scsi: <fdomain> Bad LILO/INSMOD parameters?\n" );
+	 return NULL;
+      }
+      if (!fdomain_is_valid_port( port_base )) {
+	 printk( "scsi: <fdomain> Cannot locate chip at port base 0x%x\n",
+		 port_base );
+	 printk( "scsi: <fdomain> Bad LILO/INSMOD parameters?\n" );
+	 release_region(port_base, 0x10);
+	 return NULL;
+      }
+   } else {
+      int flag = 0;
+
+#ifdef CONFIG_PCI
+				/* Try PCI detection first */
+      flag = fdomain_pci_bios_detect( &interrupt_level, &port_base, &pdev );
+#endif
+      if (!flag) {
+				/* Then try ISA bus detection */
+	 flag = fdomain_isa_detect( &interrupt_level, &port_base );
+
+	 if (!flag) {
+	    printk( "scsi: <fdomain> Detection failed (no card)\n" );
+	    return NULL;
+	 }
+      }
+   }
+
+   fdomain_16x0_bus_reset(NULL);
+
+   if (fdomain_test_loopback()) {
+      printk(KERN_ERR  "scsi: <fdomain> Detection failed (loopback test failed at port base 0x%x)\n", port_base);
+      if (setup_called) {
+	 printk(KERN_ERR "scsi: <fdomain> Bad LILO/INSMOD parameters?\n");
+      }
+      release_region(port_base, 0x10);
+      return NULL;
+   }
+
+   if (this_id) {
+      tpnt->this_id = (this_id & 0x07);
+      adapter_mask  = (1 << tpnt->this_id);
+   } else {
+      if (PCI_bus || (bios_major == 3 && bios_minor >= 2) || bios_major < 0) {
+	 tpnt->this_id = 7;
+	 adapter_mask  = 0x80;
+      } else {
+	 tpnt->this_id = 6;
+	 adapter_mask  = 0x40;
+      }
+   }
+
+/* Print out a banner here in case we can't
+   get resources.  */
+
+   shpnt = scsi_register( tpnt, 0 );
+   if(shpnt == NULL) {
+	release_region(port_base, 0x10);
+   	return NULL;
+   }
+   shpnt->irq = interrupt_level;
+   shpnt->io_port = port_base;
+   scsi_set_device(shpnt, &pdev->dev);
+   shpnt->n_io_port = 0x10;
+   print_banner( shpnt );
+
+   /* Log IRQ with kernel */   
+   if (!interrupt_level) {
+      printk(KERN_ERR "scsi: <fdomain> Card Detected, but driver not loaded (no IRQ)\n" );
+      release_region(port_base, 0x10);
+      return NULL;
+   } else {
+      /* Register the IRQ with the kernel */
+
+      retcode = request_irq( interrupt_level,
+			     do_fdomain_16x0_intr, pdev?SA_SHIRQ:0, "fdomain", shpnt);
+
+      if (retcode < 0) {
+	 if (retcode == -EINVAL) {
+	    printk(KERN_ERR "scsi: <fdomain> IRQ %d is bad!\n", interrupt_level );
+	    printk(KERN_ERR "                This shouldn't happen!\n" );
+	    printk(KERN_ERR "                Send mail to faith@acm.org\n" );
+	 } else if (retcode == -EBUSY) {
+	    printk(KERN_ERR "scsi: <fdomain> IRQ %d is already in use!\n", interrupt_level );
+	    printk(KERN_ERR "                Please use another IRQ!\n" );
+	 } else {
+	    printk(KERN_ERR "scsi: <fdomain> Error getting IRQ %d\n", interrupt_level );
+	    printk(KERN_ERR "                This shouldn't happen!\n" );
+	    printk(KERN_ERR "                Send mail to faith@acm.org\n" );
+	 }
+	 printk(KERN_ERR "scsi: <fdomain> Detected, but driver not loaded (IRQ)\n" );
+         release_region(port_base, 0x10);
+	 return NULL;
+      }
+   }
+   return shpnt;
+}
+
+static int fdomain_16x0_detect(struct scsi_host_template *tpnt)
+{
+	if (fdomain)
+		fdomain_setup(fdomain);
+	return (__fdomain_16x0_detect(tpnt) != NULL);
+}
+
+static const char *fdomain_16x0_info( struct Scsi_Host *ignore )
+{
+   static char buffer[128];
+   char        *pt;
+   
+   strcpy( buffer, "Future Domain 16-bit SCSI Driver Version" );
+   if (strchr( VERSION, ':')) { /* Assume VERSION is an RCS Revision string */
+      strcat( buffer, strchr( VERSION, ':' ) + 1 );
+      pt = strrchr( buffer, '$') - 1;
+      if (!pt)  		/* Stripped RCS Revision string? */
+	    pt = buffer + strlen( buffer ) - 1;
+      if (*pt != ' ')
+	    ++pt;
+      *pt = '\0';
+   } else {			/* Assume VERSION is a number */
+      strcat( buffer, " " VERSION );
+   }
+      
+   return buffer;
+}
+
+#if 0
+static int fdomain_arbitrate( void )
+{
+   int           status = 0;
+   unsigned long timeout;
+
+#if EVERY_ACCESS
+   printk( "fdomain_arbitrate()\n" );
+#endif
+   
+   outb(0x00, port_base + SCSI_Cntl);              /* Disable data drivers */
+   outb(adapter_mask, port_base + SCSI_Data_NoACK); /* Set our id bit */
+   outb(0x04 | PARITY_MASK, port_base + TMC_Cntl); /* Start arbitration */
+
+   timeout = 500;
+   do {
+      status = inb(port_base + TMC_Status);        /* Read adapter status */
+      if (status & 0x02)		      /* Arbitration complete */
+	    return 0;
+      mdelay(1);			/* Wait one millisecond */
+   } while (--timeout);
+
+   /* Make bus idle */
+   fdomain_make_bus_idle();
+
+#if EVERY_ACCESS
+   printk( "Arbitration failed, status = %x\n", status );
+#endif
+#if ERRORS_ONLY
+   printk( "scsi: <fdomain> Arbitration failed, status = %x\n", status );
+#endif
+   return 1;
+}
+#endif
+
+static int fdomain_select( int target )
+{
+   int           status;
+   unsigned long timeout;
+#if ERRORS_ONLY
+   static int    flag = 0;
+#endif
+
+   outb(0x82, port_base + SCSI_Cntl); /* Bus Enable + Select */
+   outb(adapter_mask | (1 << target), port_base + SCSI_Data_NoACK);
+
+   /* Stop arbitration and enable parity */
+   outb(PARITY_MASK, port_base + TMC_Cntl); 
+
+   timeout = 350;			/* 350 msec */
+
+   do {
+      status = inb(port_base + SCSI_Status); /* Read adapter status */
+      if (status & 1) {			/* Busy asserted */
+	 /* Enable SCSI Bus (on error, should make bus idle with 0) */
+	 outb(0x80, port_base + SCSI_Cntl);
+	 return 0;
+      }
+      mdelay(1);			/* wait one msec */
+   } while (--timeout);
+   /* Make bus idle */
+   fdomain_make_bus_idle();
+#if EVERY_ACCESS
+   if (!target) printk( "Selection failed\n" );
+#endif
+#if ERRORS_ONLY
+   if (!target) {
+      if (!flag) /* Skip first failure for all chips. */
+	    ++flag;
+      else
+	    printk( "scsi: <fdomain> Selection failed\n" );
+   }
+#endif
+   return 1;
+}
+
+static void my_done(int error)
+{
+   if (in_command) {
+      in_command = 0;
+      outb(0x00, port_base + Interrupt_Cntl);
+      fdomain_make_bus_idle();
+      current_SC->result = error;
+      if (current_SC->scsi_done)
+	    current_SC->scsi_done( current_SC );
+      else panic( "scsi: <fdomain> current_SC->scsi_done() == NULL" );
+   } else {
+      panic( "scsi: <fdomain> my_done() called outside of command\n" );
+   }
+#if DEBUG_RACE
+   in_interrupt_flag = 0;
+#endif
+}
+
+static irqreturn_t do_fdomain_16x0_intr(int irq, void *dev_id,
+					struct pt_regs * regs )
+{
+   unsigned long flags;
+   int      status;
+   int      done = 0;
+   unsigned data_count;
+
+				/* The fdomain_16x0_intr is only called via
+				   the interrupt handler.  The goal of the
+				   sti() here is to allow other
+				   interruptions while this routine is
+				   running. */
+
+   /* Check for other IRQ sources */
+   if ((inb(port_base + TMC_Status) & 0x01) == 0)
+   	return IRQ_NONE;
+
+   /* It is our IRQ */   	
+   outb(0x00, port_base + Interrupt_Cntl);
+
+   /* We usually have one spurious interrupt after each command.  Ignore it. */
+   if (!in_command || !current_SC) {	/* Spurious interrupt */
+#if EVERY_ACCESS
+      printk( "Spurious interrupt, in_command = %d, current_SC = %x\n",
+	      in_command, current_SC );
+#endif
+      return IRQ_NONE;
+   }
+
+   /* Abort calls my_done, so we do nothing here. */
+   if (current_SC->SCp.phase & aborted) {
+#if DEBUG_ABORT
+      printk( "scsi: <fdomain> Interrupt after abort, ignoring\n" );
+#endif
+      /*
+      return IRQ_HANDLED; */
+   }
+
+#if DEBUG_RACE
+   ++in_interrupt_flag;
+#endif
+
+   if (current_SC->SCp.phase & in_arbitration) {
+      status = inb(port_base + TMC_Status);        /* Read adapter status */
+      if (!(status & 0x02)) {
+#if EVERY_ACCESS
+	 printk( " AFAIL " );
+#endif
+         spin_lock_irqsave(current_SC->device->host->host_lock, flags);
+	 my_done( DID_BUS_BUSY << 16 );
+         spin_unlock_irqrestore(current_SC->device->host->host_lock, flags);
+	 return IRQ_HANDLED;
+      }
+      current_SC->SCp.phase = in_selection;
+      
+      outb(0x40 | FIFO_COUNT, port_base + Interrupt_Cntl);
+
+      outb(0x82, port_base + SCSI_Cntl); /* Bus Enable + Select */
+      outb(adapter_mask | (1 << current_SC->device->id), port_base + SCSI_Data_NoACK);
+      
+      /* Stop arbitration and enable parity */
+      outb(0x10 | PARITY_MASK, port_base + TMC_Cntl);
+#if DEBUG_RACE
+      in_interrupt_flag = 0;
+#endif
+      return IRQ_HANDLED;
+   } else if (current_SC->SCp.phase & in_selection) {
+      status = inb(port_base + SCSI_Status);
+      if (!(status & 0x01)) {
+	 /* Try again, for slow devices */
+	 if (fdomain_select( current_SC->device->id )) {
+#if EVERY_ACCESS
+	    printk( " SFAIL " );
+#endif
+            spin_lock_irqsave(current_SC->device->host->host_lock, flags);
+	    my_done( DID_NO_CONNECT << 16 );
+            spin_unlock_irqrestore(current_SC->device->host->host_lock, flags);
+	    return IRQ_HANDLED;
+	 } else {
+#if EVERY_ACCESS
+	    printk( " AltSel " );
+#endif
+	    /* Stop arbitration and enable parity */
+	    outb(0x10 | PARITY_MASK, port_base + TMC_Cntl);
+	 }
+      }
+      current_SC->SCp.phase = in_other;
+      outb(0x90 | FIFO_COUNT, port_base + Interrupt_Cntl);
+      outb(0x80, port_base + SCSI_Cntl);
+#if DEBUG_RACE
+      in_interrupt_flag = 0;
+#endif
+      return IRQ_HANDLED;
+   }
+   
+   /* current_SC->SCp.phase == in_other: this is the body of the routine */
+   
+   status = inb(port_base + SCSI_Status);
+   
+   if (status & 0x10) {	/* REQ */
+      
+      switch (status & 0x0e) {
+       
+      case 0x08:		/* COMMAND OUT */
+	 outb(current_SC->cmnd[current_SC->SCp.sent_command++],
+	      port_base + Write_SCSI_Data);
+#if EVERY_ACCESS
+	 printk( "CMD = %x,",
+		 current_SC->cmnd[ current_SC->SCp.sent_command - 1] );
+#endif
+	 break;
+      case 0x00:		/* DATA OUT -- tmc18c50/tmc18c30 only */
+	 if (chip != tmc1800 && !current_SC->SCp.have_data_in) {
+	    current_SC->SCp.have_data_in = -1;
+	    outb(0xd0 | PARITY_MASK, port_base + TMC_Cntl);
+	 }
+	 break;
+      case 0x04:		/* DATA IN -- tmc18c50/tmc18c30 only */
+	 if (chip != tmc1800 && !current_SC->SCp.have_data_in) {
+	    current_SC->SCp.have_data_in = 1;
+	    outb(0x90 | PARITY_MASK, port_base + TMC_Cntl);
+	 }
+	 break;
+      case 0x0c:		/* STATUS IN */
+	 current_SC->SCp.Status = inb(port_base + Read_SCSI_Data);
+#if EVERY_ACCESS
+	 printk( "Status = %x, ", current_SC->SCp.Status );
+#endif
+#if ERRORS_ONLY
+	 if (current_SC->SCp.Status
+	     && current_SC->SCp.Status != 2
+	     && current_SC->SCp.Status != 8) {
+	    printk( "scsi: <fdomain> target = %d, command = %x, status = %x\n",
+		    current_SC->device->id,
+		    current_SC->cmnd[0],
+		    current_SC->SCp.Status );
+	 }
+#endif
+	       break;
+      case 0x0a:		/* MESSAGE OUT */
+	 outb(MESSAGE_REJECT, port_base + Write_SCSI_Data); /* Reject */
+	 break;
+      case 0x0e:		/* MESSAGE IN */
+	 current_SC->SCp.Message = inb(port_base + Read_SCSI_Data);
+#if EVERY_ACCESS
+	 printk( "Message = %x, ", current_SC->SCp.Message );
+#endif
+	 if (!current_SC->SCp.Message) ++done;
+#if DEBUG_MESSAGES || EVERY_ACCESS
+	 if (current_SC->SCp.Message) {
+	    printk( "scsi: <fdomain> message = %x\n",
+		    current_SC->SCp.Message );
+	 }
+#endif
+	 break;
+      }
+   }
+
+   if (chip == tmc1800 && !current_SC->SCp.have_data_in
+       && (current_SC->SCp.sent_command >= current_SC->cmd_len)) {
+      
+      if(current_SC->sc_data_direction == DMA_TO_DEVICE)
+      {
+	 current_SC->SCp.have_data_in = -1;
+	 outb(0xd0 | PARITY_MASK, port_base + TMC_Cntl);
+      }
+      else
+      {
+	 current_SC->SCp.have_data_in = 1;
+	 outb(0x90 | PARITY_MASK, port_base + TMC_Cntl);
+      }
+   }
+
+   if (current_SC->SCp.have_data_in == -1) { /* DATA OUT */
+      while ((data_count = FIFO_Size - inw(port_base + FIFO_Data_Count)) > 512) {
+#if EVERY_ACCESS
+	 printk( "DC=%d, ", data_count ) ;
+#endif
+	 if (data_count > current_SC->SCp.this_residual)
+	       data_count = current_SC->SCp.this_residual;
+	 if (data_count > 0) {
+#if EVERY_ACCESS
+	    printk( "%d OUT, ", data_count );
+#endif
+	    if (data_count == 1) {
+	       outb(*current_SC->SCp.ptr++, port_base + Write_FIFO);
+	       --current_SC->SCp.this_residual;
+	    } else {
+	       data_count >>= 1;
+	       outsw(port_base + Write_FIFO, current_SC->SCp.ptr, data_count);
+	       current_SC->SCp.ptr += 2 * data_count;
+	       current_SC->SCp.this_residual -= 2 * data_count;
+	    }
+	 }
+	 if (!current_SC->SCp.this_residual) {
+	    if (current_SC->SCp.buffers_residual) {
+	       --current_SC->SCp.buffers_residual;
+	       ++current_SC->SCp.buffer;
+	       current_SC->SCp.ptr = page_address(current_SC->SCp.buffer->page) + current_SC->SCp.buffer->offset;
+	       current_SC->SCp.this_residual = current_SC->SCp.buffer->length;
+	    } else
+		  break;
+	 }
+      }
+   }
+   
+   if (current_SC->SCp.have_data_in == 1) { /* DATA IN */
+      while ((data_count = inw(port_base + FIFO_Data_Count)) > 0) {
+#if EVERY_ACCESS
+	 printk( "DC=%d, ", data_count );
+#endif
+	 if (data_count > current_SC->SCp.this_residual)
+	       data_count = current_SC->SCp.this_residual;
+	 if (data_count) {
+#if EVERY_ACCESS
+	    printk( "%d IN, ", data_count );
+#endif
+	    if (data_count == 1) {
+	       *current_SC->SCp.ptr++ = inb(port_base + Read_FIFO);
+	       --current_SC->SCp.this_residual;
+	    } else {
+	       data_count >>= 1; /* Number of words */
+	       insw(port_base + Read_FIFO, current_SC->SCp.ptr, data_count);
+	       current_SC->SCp.ptr += 2 * data_count;
+	       current_SC->SCp.this_residual -= 2 * data_count;
+	    }
+	 }
+	 if (!current_SC->SCp.this_residual
+	     && current_SC->SCp.buffers_residual) {
+	    --current_SC->SCp.buffers_residual;
+	    ++current_SC->SCp.buffer;
+	    current_SC->SCp.ptr = page_address(current_SC->SCp.buffer->page) + current_SC->SCp.buffer->offset;
+	    current_SC->SCp.this_residual = current_SC->SCp.buffer->length;
+	 }
+      }
+   }
+   
+   if (done) {
+#if EVERY_ACCESS
+      printk( " ** IN DONE %d ** ", current_SC->SCp.have_data_in );
+#endif
+
+#if ERRORS_ONLY
+      if (current_SC->cmnd[0] == REQUEST_SENSE && !current_SC->SCp.Status) {
+	 if ((unsigned char)(*((char *)current_SC->request_buffer+2)) & 0x0f) {
+	    unsigned char key;
+	    unsigned char code;
+	    unsigned char qualifier;
+
+	    key = (unsigned char)(*((char *)current_SC->request_buffer + 2))
+		  & 0x0f;
+	    code = (unsigned char)(*((char *)current_SC->request_buffer + 12));
+	    qualifier = (unsigned char)(*((char *)current_SC->request_buffer
+					  + 13));
+
+	    if (key != UNIT_ATTENTION
+		&& !(key == NOT_READY
+		     && code == 0x04
+		     && (!qualifier || qualifier == 0x02 || qualifier == 0x01))
+		&& !(key == ILLEGAL_REQUEST && (code == 0x25
+						|| code == 0x24
+						|| !code)))
+		  
+		  printk( "scsi: <fdomain> REQUEST SENSE"
+			  " Key = %x, Code = %x, Qualifier = %x\n",
+			  key, code, qualifier );
+	 }
+      }
+#endif
+#if EVERY_ACCESS
+      printk( "BEFORE MY_DONE. . ." );
+#endif
+      spin_lock_irqsave(current_SC->device->host->host_lock, flags);
+      my_done( (current_SC->SCp.Status & 0xff)
+	       | ((current_SC->SCp.Message & 0xff) << 8) | (DID_OK << 16) );
+      spin_unlock_irqrestore(current_SC->device->host->host_lock, flags);
+#if EVERY_ACCESS
+      printk( "RETURNING.\n" );
+#endif
+      
+   } else {
+      if (current_SC->SCp.phase & disconnect) {
+	 outb(0xd0 | FIFO_COUNT, port_base + Interrupt_Cntl);
+	 outb(0x00, port_base + SCSI_Cntl);
+      } else {
+	 outb(0x90 | FIFO_COUNT, port_base + Interrupt_Cntl);
+      }
+   }
+#if DEBUG_RACE
+   in_interrupt_flag = 0;
+#endif
+   return IRQ_HANDLED;
+}
+
+static int fdomain_16x0_queue(struct scsi_cmnd *SCpnt,
+		void (*done)(struct scsi_cmnd *))
+{
+   if (in_command) {
+      panic( "scsi: <fdomain> fdomain_16x0_queue() NOT REENTRANT!\n" );
+   }
+#if EVERY_ACCESS
+   printk( "queue: target = %d cmnd = 0x%02x pieces = %d size = %u\n",
+	   SCpnt->target,
+	   *(unsigned char *)SCpnt->cmnd,
+	   SCpnt->use_sg,
+	   SCpnt->request_bufflen );
+#endif
+
+   fdomain_make_bus_idle();
+
+   current_SC            = SCpnt; /* Save this for the done function */
+   current_SC->scsi_done = done;
+
+   /* Initialize static data */
+
+   if (current_SC->use_sg) {
+      current_SC->SCp.buffer =
+	    (struct scatterlist *)current_SC->request_buffer;
+      current_SC->SCp.ptr              = page_address(current_SC->SCp.buffer->page) + current_SC->SCp.buffer->offset;
+      current_SC->SCp.this_residual    = current_SC->SCp.buffer->length;
+      current_SC->SCp.buffers_residual = current_SC->use_sg - 1;
+   } else {
+      current_SC->SCp.ptr              = (char *)current_SC->request_buffer;
+      current_SC->SCp.this_residual    = current_SC->request_bufflen;
+      current_SC->SCp.buffer           = NULL;
+      current_SC->SCp.buffers_residual = 0;
+   }
+	 
+   
+   current_SC->SCp.Status              = 0;
+   current_SC->SCp.Message             = 0;
+   current_SC->SCp.have_data_in        = 0;
+   current_SC->SCp.sent_command        = 0;
+   current_SC->SCp.phase               = in_arbitration;
+
+   /* Start arbitration */
+   outb(0x00, port_base + Interrupt_Cntl);
+   outb(0x00, port_base + SCSI_Cntl);              /* Disable data drivers */
+   outb(adapter_mask, port_base + SCSI_Data_NoACK); /* Set our id bit */
+   ++in_command;
+   outb(0x20, port_base + Interrupt_Cntl);
+   outb(0x14 | PARITY_MASK, port_base + TMC_Cntl); /* Start arbitration */
+
+   return 0;
+}
+
+#if DEBUG_ABORT
+static void print_info(struct scsi_cmnd *SCpnt)
+{
+   unsigned int imr;
+   unsigned int irr;
+   unsigned int isr;
+
+   if (!SCpnt || !SCpnt->device || !SCpnt->device->host) {
+      printk(KERN_WARNING "scsi: <fdomain> Cannot provide detailed information\n");
+      return;
+   }
+   
+   printk(KERN_INFO "%s\n", fdomain_16x0_info( SCpnt->device->host ) );
+   print_banner(SCpnt->device->host);
+   switch (SCpnt->SCp.phase) {
+   case in_arbitration: printk("arbitration"); break;
+   case in_selection:   printk("selection");   break;
+   case in_other:       printk("other");       break;
+   default:             printk("unknown");     break;
+   }
+
+   printk( " (%d), target = %d cmnd = 0x%02x pieces = %d size = %u\n",
+	   SCpnt->SCp.phase,
+	   SCpnt->device->id,
+	   *(unsigned char *)SCpnt->cmnd,
+	   SCpnt->use_sg,
+	   SCpnt->request_bufflen );
+   printk( "sent_command = %d, have_data_in = %d, timeout = %d\n",
+	   SCpnt->SCp.sent_command,
+	   SCpnt->SCp.have_data_in,
+	   SCpnt->timeout );
+#if DEBUG_RACE
+   printk( "in_interrupt_flag = %d\n", in_interrupt_flag );
+#endif
+
+   imr = (inb( 0x0a1 ) << 8) + inb( 0x21 );
+   outb( 0x0a, 0xa0 );
+   irr = inb( 0xa0 ) << 8;
+   outb( 0x0a, 0x20 );
+   irr += inb( 0x20 );
+   outb( 0x0b, 0xa0 );
+   isr = inb( 0xa0 ) << 8;
+   outb( 0x0b, 0x20 );
+   isr += inb( 0x20 );
+
+				/* Print out interesting information */
+   printk( "IMR = 0x%04x", imr );
+   if (imr & (1 << interrupt_level))
+	 printk( " (masked)" );
+   printk( ", IRR = 0x%04x, ISR = 0x%04x\n", irr, isr );
+
+   printk( "SCSI Status      = 0x%02x\n", inb(port_base + SCSI_Status));
+   printk( "TMC Status       = 0x%02x", inb(port_base + TMC_Status));
+   if (inb((port_base + TMC_Status) & 1))
+	 printk( " (interrupt)" );
+   printk( "\n" );
+   printk("Interrupt Status = 0x%02x", inb(port_base + Interrupt_Status));
+   if (inb(port_base + Interrupt_Status) & 0x08)
+	 printk( " (enabled)" );
+   printk( "\n" );
+   if (chip == tmc18c50 || chip == tmc18c30) {
+      printk("FIFO Status      = 0x%02x\n", inb(port_base + FIFO_Status));
+      printk( "Int. Condition   = 0x%02x\n",
+	      inb( port_base + Interrupt_Cond ) );
+   }
+   printk( "Configuration 1  = 0x%02x\n", inb( port_base + Configuration1 ) );
+   if (chip == tmc18c50 || chip == tmc18c30)
+	 printk( "Configuration 2  = 0x%02x\n",
+		 inb( port_base + Configuration2 ) );
+}
+#endif
+
+static int fdomain_16x0_abort(struct scsi_cmnd *SCpnt)
+{
+#if EVERY_ACCESS || ERRORS_ONLY || DEBUG_ABORT
+   printk( "scsi: <fdomain> abort " );
+#endif
+
+   if (!in_command) {
+#if EVERY_ACCESS || ERRORS_ONLY
+      printk( " (not in command)\n" );
+#endif
+      return FAILED;
+   } else printk( "\n" );
+
+#if DEBUG_ABORT
+   print_info( SCpnt );
+#endif
+
+   fdomain_make_bus_idle();
+   current_SC->SCp.phase |= aborted;
+   current_SC->result = DID_ABORT << 16;
+   
+   /* Aborts are not done well. . . */
+   my_done(DID_ABORT << 16);
+   return SUCCESS;
+}
+
+int fdomain_16x0_bus_reset(struct scsi_cmnd *SCpnt)
+{
+   outb(1, port_base + SCSI_Cntl);
+   do_pause( 2 );
+   outb(0, port_base + SCSI_Cntl);
+   do_pause( 115 );
+   outb(0, port_base + SCSI_Mode_Cntl);
+   outb(PARITY_MASK, port_base + TMC_Cntl);
+   return SUCCESS;
+}
+
+static int fdomain_16x0_biosparam(struct scsi_device *sdev,
+		struct block_device *bdev,
+		sector_t capacity, int *info_array)
+{
+   int              drive;
+   int		    size      = capacity;
+   unsigned long    offset;
+   struct drive_info {
+      unsigned short cylinders;
+      unsigned char  heads;
+      unsigned char  sectors;
+   } i;
+   
+   /* NOTES:
+      The RAM area starts at 0x1f00 from the bios_base address.
+
+      For BIOS Version 2.0:
+      
+      The drive parameter table seems to start at 0x1f30.
+      The first byte's purpose is not known.
+      Next is the cylinder, head, and sector information.
+      The last 4 bytes appear to be the drive's size in sectors.
+      The other bytes in the drive parameter table are unknown.
+      If anyone figures them out, please send me mail, and I will
+      update these notes.
+
+      Tape drives do not get placed in this table.
+
+      There is another table at 0x1fea:
+      If the byte is 0x01, then the SCSI ID is not in use.
+      If the byte is 0x18 or 0x48, then the SCSI ID is in use,
+      although tapes don't seem to be in this table.  I haven't
+      seen any other numbers (in a limited sample).
+
+      0x1f2d is a drive count (i.e., not including tapes)
+
+      The table at 0x1fcc are I/O ports addresses for the various
+      operations.  I calculate these by hand in this driver code.
+
+      
+      
+      For the ISA-200S version of BIOS Version 2.0:
+
+      The drive parameter table starts at 0x1f33.
+
+      WARNING: Assume that the table entry is 25 bytes long.  Someone needs
+      to check this for the Quantum ISA-200S card.
+
+      
+      
+      For BIOS Version 3.2:
+
+      The drive parameter table starts at 0x1f70.  Each entry is
+      0x0a bytes long.  Heads are one less than we need to report.
+    */
+
+   if (MAJOR(bdev->bd_dev) != SCSI_DISK0_MAJOR) {
+      printk("scsi: <fdomain> fdomain_16x0_biosparam: too many disks");
+      return 0;
+   }
+   drive = MINOR(bdev->bd_dev) >> 4;
+
+   if (bios_major == 2) {
+      switch (Quantum) {
+      case 2:			/* ISA_200S */
+				/* The value of 25 has never been verified.
+				   It should probably be 15. */
+	 offset = 0x1f33 + drive * 25;
+	 break;
+      case 3:			/* ISA_250MG */
+	 offset = 0x1f36 + drive * 15;
+	 break;
+      case 4:			/* ISA_200S (another one) */
+	 offset = 0x1f34 + drive * 15;
+	 break;
+      default:
+	 offset = 0x1f31 + drive * 25;
+	 break;
+      }
+      memcpy_fromio( &i, bios_mem + offset, sizeof( struct drive_info ) );
+      info_array[0] = i.heads;
+      info_array[1] = i.sectors;
+      info_array[2] = i.cylinders;
+   } else if (bios_major == 3
+	      && bios_minor >= 0
+	      && bios_minor < 4) { /* 3.0 and 3.2 BIOS */
+      memcpy_fromio( &i, bios_mem + 0x1f71 + drive * 10,
+		     sizeof( struct drive_info ) );
+      info_array[0] = i.heads + 1;
+      info_array[1] = i.sectors;
+      info_array[2] = i.cylinders;
+   } else {			/* 3.4 BIOS (and up?) */
+      /* This algorithm was provided by Future Domain (much thanks!). */
+      unsigned char *p = scsi_bios_ptable(bdev);
+
+      if (p && p[65] == 0xaa && p[64] == 0x55 /* Partition table valid */
+	  && p[4]) {			    /* Partition type */
+
+	 /* The partition table layout is as follows:
+
+	    Start: 0x1b3h
+	    Offset: 0 = partition status
+		    1 = starting head
+		    2 = starting sector and cylinder (word, encoded)
+		    4 = partition type
+		    5 = ending head
+		    6 = ending sector and cylinder (word, encoded)
+		    8 = starting absolute sector (double word)
+		    c = number of sectors (double word)
+	    Signature: 0x1fe = 0x55aa
+
+	    So, this algorithm assumes:
+	    1) the first partition table is in use,
+	    2) the data in the first entry is correct, and
+	    3) partitions never divide cylinders
+
+	    Note that (1) may be FALSE for NetBSD (and other BSD flavors),
+	    as well as for Linux.  Note also, that Linux doesn't pay any
+	    attention to the fields that are used by this algorithm -- it
+	    only uses the absolute sector data.  Recent versions of Linux's
+	    fdisk(1) will fill this data in correctly, and forthcoming
+	    versions will check for consistency.
+
+	    Checking for a non-zero partition type is not part of the
+	    Future Domain algorithm, but it seemed to be a reasonable thing
+	    to do, especially in the Linux and BSD worlds. */
+
+	 info_array[0] = p[5] + 1;	    /* heads */
+	 info_array[1] = p[6] & 0x3f;	    /* sectors */
+      } else {
+
+ 	 /* Note that this new method guarantees that there will always be
+	    less than 1024 cylinders on a platter.  This is good for drives
+	    up to approximately 7.85GB (where 1GB = 1024 * 1024 kB). */
+
+	 if ((unsigned int)size >= 0x7e0000U) {
+	    info_array[0] = 0xff; /* heads   = 255 */
+	    info_array[1] = 0x3f; /* sectors =  63 */
+	 } else if ((unsigned int)size >= 0x200000U) {
+	    info_array[0] = 0x80; /* heads   = 128 */
+	    info_array[1] = 0x3f; /* sectors =  63 */
+	 } else {
+	    info_array[0] = 0x40; /* heads   =  64 */
+	    info_array[1] = 0x20; /* sectors =  32 */
+	 }
+      }
+				/* For both methods, compute the cylinders */
+      info_array[2] = (unsigned int)size / (info_array[0] * info_array[1] );
+      kfree(p);
+   }
+   
+   return 0;
+}
+
+static int fdomain_16x0_release(struct Scsi_Host *shpnt)
+{
+	if (shpnt->irq)
+		free_irq(shpnt->irq, shpnt);
+	if (shpnt->io_port && shpnt->n_io_port)
+		release_region(shpnt->io_port, shpnt->n_io_port);
+	return 0;
+}
+
+struct scsi_host_template fdomain_driver_template = {
+	.module			= THIS_MODULE,
+	.name			= "fdomain",
+	.proc_name		= "fdomain",
+	.detect			= fdomain_16x0_detect,
+	.info			= fdomain_16x0_info,
+	.queuecommand		= fdomain_16x0_queue,
+	.eh_abort_handler	= fdomain_16x0_abort,
+	.eh_bus_reset_handler	= fdomain_16x0_bus_reset,
+	.bios_param		= fdomain_16x0_biosparam,
+	.release		= fdomain_16x0_release,
+	.can_queue		= 1,
+	.this_id		= 6,
+	.sg_tablesize		= 64,
+	.cmd_per_lun		= 1,
+	.use_clustering		= DISABLE_CLUSTERING,
+};
+
+#ifndef PCMCIA
+#define driver_template fdomain_driver_template
+#include "scsi_module.c"
+#endif
