commit 79172ab20bfd8437b277254028efdb68484e2c21
Author: Finn Thain <fthain@telegraphics.com.au>
Date:   Sat Nov 2 12:06:54 2019 +1100

    scsi: atari_scsi: sun3_scsi: Set sg_tablesize to 1 instead of SG_NONE
    
    Since the scsi subsystem adopted the blk-mq API, a host with zero
    sg_tablesize crashes with a NULL pointer dereference.
    
    blk_queue_max_segments: set to minimum 1
    scsi 0:0:0:0: Direct-Access     QEMU     QEMU HARDDISK    2.5+ PQ: 0 ANSI: 5
    scsi target0:0:0: Beginning Domain Validation
    scsi target0:0:0: Domain Validation skipping write tests
    scsi target0:0:0: Ending Domain Validation
    blk_queue_max_segments: set to minimum 1
    scsi 0:0:1:0: Direct-Access     QEMU     QEMU HARDDISK    2.5+ PQ: 0 ANSI: 5
    scsi target0:0:1: Beginning Domain Validation
    scsi target0:0:1: Domain Validation skipping write tests
    scsi target0:0:1: Ending Domain Validation
    blk_queue_max_segments: set to minimum 1
    scsi 0:0:2:0: CD-ROM            QEMU     QEMU CD-ROM      2.5+ PQ: 0 ANSI: 5
    scsi target0:0:2: Beginning Domain Validation
    scsi target0:0:2: Domain Validation skipping write tests
    scsi target0:0:2: Ending Domain Validation
    blk_queue_max_segments: set to minimum 1
    blk_queue_max_segments: set to minimum 1
    blk_queue_max_segments: set to minimum 1
    blk_queue_max_segments: set to minimum 1
    sr 0:0:2:0: Power-on or device reset occurred
    sd 0:0:0:0: Power-on or device reset occurred
    sd 0:0:1:0: Power-on or device reset occurred
    sd 0:0:0:0: [sda] 10485762 512-byte logical blocks: (5.37 GB/5.00 GiB)
    sd 0:0:0:0: [sda] Write Protect is off
    sd 0:0:0:0: [sda] Write cache: enabled, read cache: enabled, doesn't support DPO or FUA
    Unable to handle kernel NULL pointer dereference at virtual address (ptrval)
    Oops: 00000000
    Modules linked in:
    PC: [<001cd874>] blk_mq_free_request+0x66/0xe2
    SR: 2004  SP: (ptrval)  a2: 00874520
    d0: 00000000    d1: 00000000    d2: 009ba800    d3: 00000000
    d4: 00000000    d5: 08000002    a0: 0087be68    a1: 009a81e0
    Process kworker/u2:2 (pid: 15, task=(ptrval))
    Frame format=7 eff addr=0000007a ssw=0505 faddr=0000007a
    wb 1 stat/addr/data: 0000 00000000 00000000
    wb 2 stat/addr/data: 0000 00000000 00000000
    wb 3 stat/addr/data: 0000 0000007a 00000000
    push data: 00000000 00000000 00000000 00000000
    Stack from 0087bd98:
            00000002 00000000 0087be72 009a7820 0087bdb4 001c4f6c 009a7820 0087bdd4
            0024d200 009a7820 0024d0dc 0087be72 009baa00 0087be68 009a5000 0087be7c
            00265d10 009a5000 0087be72 00000003 00000000 00000000 00000000 0087be68
            00000bb8 00000005 00000000 00000000 00000000 00000000 00265c56 00000000
            009ba60c 0036ddf4 00000002 ffffffff 009baa00 009ba600 009a50d6 0087be74
            00227ba0 009baa08 00000001 009baa08 009ba60c 0036ddf4 00000000 00000000
    Call Trace: [<001c4f6c>] blk_put_request+0xe/0x14
     [<0024d200>] __scsi_execute+0x124/0x174
     [<0024d0dc>] __scsi_execute+0x0/0x174
     [<00265d10>] sd_revalidate_disk+0xba/0x1f02
     [<00265c56>] sd_revalidate_disk+0x0/0x1f02
     [<0036ddf4>] strlen+0x0/0x22
     [<00227ba0>] device_add+0x3da/0x604
     [<0036ddf4>] strlen+0x0/0x22
     [<00267e64>] sd_probe+0x30c/0x4b4
     [<0002da44>] process_one_work+0x0/0x402
     [<0022b978>] really_probe+0x226/0x354
     [<0022bc34>] driver_probe_device+0xa4/0xf0
     [<0002da44>] process_one_work+0x0/0x402
     [<0022bcd0>] __driver_attach_async_helper+0x50/0x70
     [<00035dae>] async_run_entry_fn+0x36/0x130
     [<0002db88>] process_one_work+0x144/0x402
     [<0002e1aa>] worker_thread+0x0/0x570
     [<0002e29a>] worker_thread+0xf0/0x570
     [<0002e1aa>] worker_thread+0x0/0x570
     [<003768d8>] schedule+0x0/0xb8
     [<0003f58c>] __init_waitqueue_head+0x0/0x12
     [<00033e92>] kthread+0xc2/0xf6
     [<000331e8>] kthread_parkme+0x0/0x4e
     [<003768d8>] schedule+0x0/0xb8
     [<00033dd0>] kthread+0x0/0xf6
     [<00002c10>] ret_from_kernel_thread+0xc/0x14
    Code: 0280 0006 0800 56c0 4400 0280 0000 00ff <52b4> 0c3a 082b 0006 0013 6706 2042 53a8 00c4 4ab9 0047 3374 6640 202d 000c 670c
    Disabling lock debugging due to kernel taint
    
    Avoid this by setting sg_tablesize = 1.
    
    Link: https://lore.kernel.org/r/4567bcae94523b47d6f3b77450ba305823bca479.1572656814.git.fthain@telegraphics.com.au
    Reported-and-tested-by: Michael Schmitz <schmitzmic@gmail.com>
    Reviewed-by: Michael Schmitz <schmitzmic@gmail.com>
    References: commit 68ab2d76e4be ("scsi: cxlflash: Set sg_tablesize to 1 instead of SG_NONE")
    Signed-off-by: Finn Thain <fthain@telegraphics.com.au>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/sun3_scsi.c b/drivers/scsi/sun3_scsi.c
index 955e4c938d49..701b842296f0 100644
--- a/drivers/scsi/sun3_scsi.c
+++ b/drivers/scsi/sun3_scsi.c
@@ -501,7 +501,7 @@ static struct scsi_host_template sun3_scsi_template = {
 	.eh_host_reset_handler	= sun3scsi_host_reset,
 	.can_queue		= 16,
 	.this_id		= 7,
-	.sg_tablesize		= SG_NONE,
+	.sg_tablesize		= 1,
 	.cmd_per_lun		= 2,
 	.dma_boundary		= PAGE_SIZE - 1,
 	.cmd_size		= NCR5380_CMD_SIZE,
@@ -523,7 +523,7 @@ static int __init sun3_scsi_probe(struct platform_device *pdev)
 		sun3_scsi_template.can_queue = setup_can_queue;
 	if (setup_cmd_per_lun > 0)
 		sun3_scsi_template.cmd_per_lun = setup_cmd_per_lun;
-	if (setup_sg_tablesize >= 0)
+	if (setup_sg_tablesize > 0)
 		sun3_scsi_template.sg_tablesize = setup_sg_tablesize;
 	if (setup_hostid >= 0)
 		sun3_scsi_template.this_id = setup_hostid & 7;

commit c78a66584d0318e2a01a3f10857c9b517d23bf7a
Author: Gustavo A. R. Silva <gustavo@embeddedor.com>
Date:   Mon Jul 29 09:30:07 2019 -0500

    scsi: sun3_scsi: Mark expected switch fall-throughs
    
    Mark switch cases where we are expecting to fall through.
    
    This patch fixes the following warnings:
    
    drivers/scsi/sun3_scsi.c: warning: this statement may fall through
    [-Wimplicit-fallthrough=]:  => 399:9, 403:9
    
    Reported-by: Geert Uytterhoeven <geert@linux-m68k.org>
    Signed-off-by: Gustavo A. R. Silva <gustavo@embeddedor.com>
    Tested-by: Geert Uytterhoeven <geert@linux-m68k.org>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/sun3_scsi.c b/drivers/scsi/sun3_scsi.c
index 3d80ab67a626..955e4c938d49 100644
--- a/drivers/scsi/sun3_scsi.c
+++ b/drivers/scsi/sun3_scsi.c
@@ -397,10 +397,12 @@ static int sun3scsi_dma_finish(int write_flag)
 		case CSR_LEFT_3:
 			*vaddr = (dregs->bpack_lo & 0xff00) >> 8;
 			vaddr--;
+			/* Fall through */
 
 		case CSR_LEFT_2:
 			*vaddr = (dregs->bpack_hi & 0x00ff);
 			vaddr--;
+			/* Fall through */
 
 		case CSR_LEFT_1:
 			*vaddr = (dregs->bpack_hi & 0xff00) >> 8;

commit 09c434b8a0047c69e48499de0107de312901e798
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Sun May 19 13:08:20 2019 +0100

    treewide: Add SPDX license identifier for more missed files
    
    Add SPDX license identifiers to all files which:
    
     - Have no license information of any form
    
     - Have MODULE_LICENCE("GPL*") inside which was used in the initial
       scan/conversion to ignore the file
    
    These files fall under the project license, GPL v2 only. The resulting SPDX
    license identifier is:
    
      GPL-2.0-only
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/scsi/sun3_scsi.c b/drivers/scsi/sun3_scsi.c
index 95a7ea7eefa0..3d80ab67a626 100644
--- a/drivers/scsi/sun3_scsi.c
+++ b/drivers/scsi/sun3_scsi.c
@@ -1,3 +1,4 @@
+// SPDX-License-Identifier: GPL-2.0-only
 /*
  * Sun3 SCSI stuff by Erik Verbruggen (erik@bigmama.xtdnet.nl)
  *

commit 4af14d113bcf95c12d1462ba623b7e7117bd3fb3
Author: Christoph Hellwig <hch@lst.de>
Date:   Thu Dec 13 16:17:09 2018 +0100

    scsi: remove the use_clustering flag
    
    The same effects can be achieved by setting the dma_boundary to
    PAGE_SIZE - 1 and the max_segment_size to PAGE_SIZE, so shift those
    settings into the drivers.  Note that in many cases the setting might
    be bogus, but this keeps the status quo.
    
    [mkp: fix myrs and myrb]
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/sun3_scsi.c b/drivers/scsi/sun3_scsi.c
index 9492638296c8..95a7ea7eefa0 100644
--- a/drivers/scsi/sun3_scsi.c
+++ b/drivers/scsi/sun3_scsi.c
@@ -500,7 +500,7 @@ static struct scsi_host_template sun3_scsi_template = {
 	.this_id		= 7,
 	.sg_tablesize		= SG_NONE,
 	.cmd_per_lun		= 2,
-	.use_clustering		= DISABLE_CLUSTERING,
+	.dma_boundary		= PAGE_SIZE - 1,
 	.cmd_size		= NCR5380_CMD_SIZE,
 };
 

commit 12e5fc665a2d8380c1551291a0d7684fc181b02d
Author: Hannes Reinecke <hare@suse.de>
Date:   Fri Aug 25 13:57:10 2017 +0200

    scsi: NCR5380: Move bus reset to host reset
    
    The bus reset handler really is a host reset, so move it to
    eh_bus_reset_handler.
    
    Signed-off-by: Hannes Reinecke <hare@suse.com>
    Acked-by: Finn Thain <fthain@telegraphics.com.au>
    Reviewed-by: Christoph Hellwig <hch@lst.de>
    Reviewed-by: Johannes Thumshirn <jthumshirn@suse.de>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/sun3_scsi.c b/drivers/scsi/sun3_scsi.c
index e64b0c542f95..9492638296c8 100644
--- a/drivers/scsi/sun3_scsi.c
+++ b/drivers/scsi/sun3_scsi.c
@@ -46,7 +46,7 @@
 #define NCR5380_write(reg, value)       out_8(hostdata->io + (reg), value)
 
 #define NCR5380_queue_command           sun3scsi_queue_command
-#define NCR5380_bus_reset               sun3scsi_bus_reset
+#define NCR5380_host_reset              sun3scsi_host_reset
 #define NCR5380_abort                   sun3scsi_abort
 #define NCR5380_info                    sun3scsi_info
 
@@ -495,7 +495,7 @@ static struct scsi_host_template sun3_scsi_template = {
 	.info			= sun3scsi_info,
 	.queuecommand		= sun3scsi_queue_command,
 	.eh_abort_handler	= sun3scsi_abort,
-	.eh_bus_reset_handler	= sun3scsi_bus_reset,
+	.eh_host_reset_handler	= sun3scsi_host_reset,
 	.can_queue		= 16,
 	.this_id		= 7,
 	.sg_tablesize		= SG_NONE,

commit cdc194705d26fdd7fc5446b5d830f2bbe2b22c30
Merge: 772c8f6f3bbd d1da522fb8a7
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue Feb 21 11:51:42 2017 -0800

    Merge tag 'scsi-misc' of git://git.kernel.org/pub/scm/linux/kernel/git/jejb/scsi
    
    Pull SCSI updates from James Bottomley:
     "This update includes the usual round of major driver updates (ncr5380,
      ufs, lpfc, be2iscsi, hisi_sas, storvsc, cxlflash, aacraid,
      megaraid_sas, ...).
    
      There's also an assortment of minor fixes and the major update of
      switching a bunch of drivers to pci_alloc_irq_vectors from Christoph"
    
    * tag 'scsi-misc' of git://git.kernel.org/pub/scm/linux/kernel/git/jejb/scsi: (188 commits)
      scsi: megaraid_sas: handle dma_addr_t right on 32-bit
      scsi: megaraid_sas: array overflow in megasas_dump_frame()
      scsi: snic: switch to pci_irq_alloc_vectors
      scsi: megaraid_sas: driver version upgrade
      scsi: megaraid_sas: Change RAID_1_10_RMW_CMDS to RAID_1_PEER_CMDS and set value to 2
      scsi: megaraid_sas: Indentation and smatch warning fixes
      scsi: megaraid_sas: Cleanup VD_EXT_DEBUG and SPAN_DEBUG related debug prints
      scsi: megaraid_sas: Increase internal command pool
      scsi: megaraid_sas: Use synchronize_irq to wait for IRQs to complete
      scsi: megaraid_sas: Bail out the driver load if ld_list_query fails
      scsi: megaraid_sas: Change build_mpt_mfi_pass_thru to return void
      scsi: megaraid_sas: During OCR, if get_ctrl_info fails do not continue with OCR
      scsi: megaraid_sas: Do not set fp_possible if TM capable for non-RW syspdIO, change fp_possible to bool
      scsi: megaraid_sas: Remove unused pd_index from megasas_build_ld_nonrw_fusion
      scsi: megaraid_sas: megasas_return_cmd does not memset IO frame to zero
      scsi: megaraid_sas: max_fw_cmds are decremented twice, remove duplicate
      scsi: megaraid_sas: update can_queue only if the new value is less
      scsi: megaraid_sas: Change max_cmd from u32 to u16 in all functions
      scsi: megaraid_sas: set pd_after_lb from MR_BuildRaidContext and initialize pDevHandle to MR_DEVHANDLE_INVALID
      scsi: megaraid_sas: latest controller OCR capability from FW before sending shutdown DCMD
      ...

commit 14d739f640d894b4b5db1ab3e1df17b865825a42
Author: Finn Thain <fthain@telegraphics.com.au>
Date:   Sun Jan 15 18:50:57 2017 -0500

    scsi: ncr5380: Reduce #include files
    
    The NCR5380 wrapper drivers don't export symbols or declarations and
    don't actually need separate header files. Most of these header files
    were removed already; only sun3_scsi.h and g_NCR5380.h remain.
    
    Move the remaining definitions to the corresponding .c files to improve
    readability and proximity. The #defines which influence the #included
    core driver are no longer mixed up with unrelated #defines and #includes.
    
    Signed-off-by: Finn Thain <fthain@telegraphics.com.au>
    Tested-by: Ondrej Zary <linux@rainbow-software.org>
    Tested-by: Michael Schmitz <schmitzmic@gmail.com>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/sun3_scsi.c b/drivers/scsi/sun3_scsi.c
index 166f466964c4..14cebaf10371 100644
--- a/drivers/scsi/sun3_scsi.c
+++ b/drivers/scsi/sun3_scsi.c
@@ -34,7 +34,6 @@
 #include <asm/dvma.h>
 
 #include <scsi/scsi_host.h>
-#include "sun3_scsi.h"
 
 /* minimum number of bytes to do dma on */
 #define DMA_MIN_SIZE                    129
@@ -58,6 +57,85 @@
 
 #include "NCR5380.h"
 
+/* dma regs start at regbase + 8, directly after the NCR regs */
+struct sun3_dma_regs {
+	unsigned short dma_addr_hi; /* vme only */
+	unsigned short dma_addr_lo; /* vme only */
+	unsigned short dma_count_hi; /* vme only */
+	unsigned short dma_count_lo; /* vme only */
+	unsigned short udc_data; /* udc dma data reg (obio only) */
+	unsigned short udc_addr; /* uda dma addr reg (obio only) */
+	unsigned short fifo_data; /* fifo data reg,
+	                           * holds extra byte on odd dma reads
+	                           */
+	unsigned short fifo_count;
+	unsigned short csr; /* control/status reg */
+	unsigned short bpack_hi; /* vme only */
+	unsigned short bpack_lo; /* vme only */
+	unsigned short ivect; /* vme only */
+	unsigned short fifo_count_hi; /* vme only */
+};
+
+/* ucd chip specific regs - live in dvma space */
+struct sun3_udc_regs {
+	unsigned short rsel; /* select regs to load */
+	unsigned short addr_hi; /* high word of addr */
+	unsigned short addr_lo; /* low word */
+	unsigned short count; /* words to be xfer'd */
+	unsigned short mode_hi; /* high word of channel mode */
+	unsigned short mode_lo; /* low word of channel mode */
+};
+
+/* addresses of the udc registers */
+#define UDC_MODE 0x38
+#define UDC_CSR 0x2e /* command/status */
+#define UDC_CHN_HI 0x26 /* chain high word */
+#define UDC_CHN_LO 0x22 /* chain lo word */
+#define UDC_CURA_HI 0x1a /* cur reg A high */
+#define UDC_CURA_LO 0x0a /* cur reg A low */
+#define UDC_CURB_HI 0x12 /* cur reg B high */
+#define UDC_CURB_LO 0x02 /* cur reg B low */
+#define UDC_MODE_HI 0x56 /* mode reg high */
+#define UDC_MODE_LO 0x52 /* mode reg low */
+#define UDC_COUNT 0x32 /* words to xfer */
+
+/* some udc commands */
+#define UDC_RESET 0
+#define UDC_CHN_START 0xa0 /* start chain */
+#define UDC_INT_ENABLE 0x32 /* channel 1 int on */
+
+/* udc mode words */
+#define UDC_MODE_HIWORD 0x40
+#define UDC_MODE_LSEND 0xc2
+#define UDC_MODE_LRECV 0xd2
+
+/* udc reg selections */
+#define UDC_RSEL_SEND 0x282
+#define UDC_RSEL_RECV 0x182
+
+/* bits in csr reg */
+#define CSR_DMA_ACTIVE 0x8000
+#define CSR_DMA_CONFLICT 0x4000
+#define CSR_DMA_BUSERR 0x2000
+
+#define CSR_FIFO_EMPTY 0x400 /* fifo flushed? */
+#define CSR_SDB_INT 0x200 /* sbc interrupt pending */
+#define CSR_DMA_INT 0x100 /* dma interrupt pending */
+
+#define CSR_LEFT 0xc0
+#define CSR_LEFT_3 0xc0
+#define CSR_LEFT_2 0x80
+#define CSR_LEFT_1 0x40
+#define CSR_PACK_ENABLE 0x20
+
+#define CSR_DMA_ENABLE 0x10
+
+#define CSR_SEND 0x8 /* 1 = send  0 = recv */
+#define CSR_FIFO 0x2 /* reset fifo */
+#define CSR_INTR 0x4 /* interrupt enable */
+#define CSR_SCSI 0x1
+
+#define VME_DATA24 0x3d00
 
 extern int sun3_map_test(unsigned long, char *);
 

commit 9507037304e581493bcd8bf76e013e44be71470e
Author: Finn Thain <fthain@telegraphics.com.au>
Date:   Sun Jan 15 18:50:57 2017 -0500

    scsi: ncr5380: Clean up dead code and redundant macro usage
    
    Remove dead code inside #if 0 conditionals.
    
    Remove the #ifdef __KERNEL__ test, since NCR5380.h has no definitions
    that relate to userspace code.
    
    Remove two redundant macro definitions which were overlooked in
    commit e9db3198e08b ("sun3_scsi: Adopt NCR5380.c core driver").
    
    Signed-off-by: Finn Thain <fthain@telegraphics.com.au>
    Tested-by: Ondrej Zary <linux@rainbow-software.org>
    Tested-by: Michael Schmitz <schmitzmic@gmail.com>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/sun3_scsi.c b/drivers/scsi/sun3_scsi.c
index 88db6992420e..166f466964c4 100644
--- a/drivers/scsi/sun3_scsi.c
+++ b/drivers/scsi/sun3_scsi.c
@@ -56,9 +56,6 @@
 #define NCR5380_dma_send_setup          sun3scsi_dma_count
 #define NCR5380_dma_residual            sun3scsi_dma_residual
 
-#define NCR5380_acquire_dma_irq(instance)    (1)
-#define NCR5380_release_dma_irq(instance)
-
 #include "NCR5380.h"
 
 

commit 57292b58ddb58689e8c3b4c6eadbef10d9ca44dd
Author: Christoph Hellwig <hch@lst.de>
Date:   Tue Jan 31 16:57:29 2017 +0100

    block: introduce blk_rq_is_passthrough
    
    This can be used to check for fs vs non-fs requests and basically
    removes all knowledge of BLOCK_PC specific from the block layer,
    as well as preparing for removing the cmd_type field in struct request.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Jens Axboe <axboe@fb.com>

diff --git a/drivers/scsi/sun3_scsi.c b/drivers/scsi/sun3_scsi.c
index 88db6992420e..bcf7d05d1aab 100644
--- a/drivers/scsi/sun3_scsi.c
+++ b/drivers/scsi/sun3_scsi.c
@@ -260,7 +260,7 @@ static int sun3scsi_dma_xfer_len(struct NCR5380_hostdata *hostdata,
 {
 	int wanted_len = cmd->SCp.this_residual;
 
-	if (wanted_len < DMA_MIN_SIZE || cmd->request->cmd_type != REQ_TYPE_FS)
+	if (wanted_len < DMA_MIN_SIZE || blk_rq_is_passthrough(cmd->request))
 		return 0;
 
 	return wanted_len;

commit 4a98f896bf2c66a69517fc5e10dc67288cb8da93
Author: Finn Thain <fthain@telegraphics.com.au>
Date:   Mon Oct 10 00:46:53 2016 -0400

    scsi: ncr5380: Use correct types for DMA routines
    
    Apply prototypes to get consistent function signatures for the DMA
    functions implemented in the board-specific drivers. To avoid using
    macros to alter actual parameters, some of those functions are reworked
    slightly.
    
    This is a step toward the goal of passing the board-specific routines
    to the core driver using an ops struct (as in a platform driver or
    library module).
    
    This also helps fix some inconsistent types: where the core driver uses
    ints (cmd->SCp.this_residual and hostdata->dma_len) for keeping track of
    transfers, certain board-specific routines used unsigned long.
    
    While we are fixing these function signatures, pass the hostdata pointer
    to DMA routines instead of a Scsi_Host pointer, for shorter and faster
    code.
    
    Signed-off-by: Finn Thain <fthain@telegraphics.com.au>
    Reviewed-by: Hannes Reinecke <hare@suse.com>
    Tested-by: Ondrej Zary <linux@rainbow-software.org>
    Tested-by: Michael Schmitz <schmitzmic@gmail.com>
    Acked-by: Russell King <rmk+kernel@armlinux.org.uk>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/sun3_scsi.c b/drivers/scsi/sun3_scsi.c
index b408474885dc..88db6992420e 100644
--- a/drivers/scsi/sun3_scsi.c
+++ b/drivers/scsi/sun3_scsi.c
@@ -51,12 +51,10 @@
 #define NCR5380_abort                   sun3scsi_abort
 #define NCR5380_info                    sun3scsi_info
 
-#define NCR5380_dma_recv_setup(instance, data, count) (count)
-#define NCR5380_dma_send_setup(instance, data, count) (count)
-#define NCR5380_dma_residual(instance) \
-        sun3scsi_dma_residual(instance)
-#define NCR5380_dma_xfer_len(instance, cmd, phase) \
-        sun3scsi_dma_xfer_len(cmd->SCp.this_residual, cmd)
+#define NCR5380_dma_xfer_len            sun3scsi_dma_xfer_len
+#define NCR5380_dma_recv_setup          sun3scsi_dma_count
+#define NCR5380_dma_send_setup          sun3scsi_dma_count
+#define NCR5380_dma_residual            sun3scsi_dma_residual
 
 #define NCR5380_acquire_dma_irq(instance)    (1)
 #define NCR5380_release_dma_irq(instance)
@@ -143,8 +141,8 @@ static irqreturn_t scsi_sun3_intr(int irq, void *dev)
 }
 
 /* sun3scsi_dma_setup() -- initialize the dma controller for a read/write */
-static unsigned long sun3scsi_dma_setup(struct Scsi_Host *instance,
-                                void *data, unsigned long count, int write_flag)
+static int sun3scsi_dma_setup(struct NCR5380_hostdata *hostdata,
+                              unsigned char *data, int count, int write_flag)
 {
 	void *addr;
 
@@ -196,9 +194,10 @@ static unsigned long sun3scsi_dma_setup(struct Scsi_Host *instance,
 	dregs->csr |= CSR_FIFO;
 	
 	if(dregs->fifo_count != count) { 
-		shost_printk(KERN_ERR, instance, "FIFO mismatch %04x not %04x\n",
+		shost_printk(KERN_ERR, hostdata->host,
+		             "FIFO mismatch %04x not %04x\n",
 		             dregs->fifo_count, (unsigned int) count);
-		NCR5380_dprint(NDEBUG_DMA, instance);
+		NCR5380_dprint(NDEBUG_DMA, hostdata->host);
 	}
 
 	/* setup udc */
@@ -233,14 +232,34 @@ static unsigned long sun3scsi_dma_setup(struct Scsi_Host *instance,
 
 }
 
-static inline unsigned long sun3scsi_dma_residual(struct Scsi_Host *instance)
+static int sun3scsi_dma_count(struct NCR5380_hostdata *hostdata,
+                              unsigned char *data, int count)
+{
+	return count;
+}
+
+static inline int sun3scsi_dma_recv_setup(struct NCR5380_hostdata *hostdata,
+                                          unsigned char *data, int count)
+{
+	return sun3scsi_dma_setup(hostdata, data, count, 0);
+}
+
+static inline int sun3scsi_dma_send_setup(struct NCR5380_hostdata *hostdata,
+                                          unsigned char *data, int count)
+{
+	return sun3scsi_dma_setup(hostdata, data, count, 1);
+}
+
+static int sun3scsi_dma_residual(struct NCR5380_hostdata *hostdata)
 {
 	return last_residual;
 }
 
-static inline unsigned long sun3scsi_dma_xfer_len(unsigned long wanted_len,
-                                                  struct scsi_cmnd *cmd)
+static int sun3scsi_dma_xfer_len(struct NCR5380_hostdata *hostdata,
+                                 struct scsi_cmnd *cmd)
 {
+	int wanted_len = cmd->SCp.this_residual;
+
 	if (wanted_len < DMA_MIN_SIZE || cmd->request->cmd_type != REQ_TYPE_FS)
 		return 0;
 

commit 61e1ce588b101f13a4c6f713b95d65551c8572e3
Author: Finn Thain <fthain@telegraphics.com.au>
Date:   Mon Oct 10 00:46:53 2016 -0400

    scsi: ncr5380: Use correct types for device register accessors
    
    For timeout values adopt unsigned long, which is the type of jiffies etc.
    
    For chip register values and bit masks pass u8, which is the return type
    of readb, inb etc.
    
    For device register offsets adopt unsigned int, as it is suitable for
    adding to base addresses.
    
    Pass the NCR5380_hostdata pointer to the board-specific routines instead
    of the Scsi_Host pointer. The board-specific code is concerned with
    hardware and not with SCSI protocol or the mid-layer.
    
    Signed-off-by: Finn Thain <fthain@telegraphics.com.au>
    Reviewed-by: Hannes Reinecke <hare@suse.com>
    Tested-by: Ondrej Zary <linux@rainbow-software.org>
    Tested-by: Michael Schmitz <schmitzmic@gmail.com>
    Acked-by: Russell King <rmk+kernel@armlinux.org.uk>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/sun3_scsi.c b/drivers/scsi/sun3_scsi.c
index efee144c6056..b408474885dc 100644
--- a/drivers/scsi/sun3_scsi.c
+++ b/drivers/scsi/sun3_scsi.c
@@ -43,8 +43,8 @@
 
 #define NCR5380_implementation_fields   /* none */
 
-#define NCR5380_read(reg)               sun3scsi_read(reg)
-#define NCR5380_write(reg, value)       sun3scsi_write(reg, value)
+#define NCR5380_read(reg)               in_8(hostdata->io + (reg))
+#define NCR5380_write(reg, value)       out_8(hostdata->io + (reg), value)
 
 #define NCR5380_queue_command           sun3scsi_queue_command
 #define NCR5380_bus_reset               sun3scsi_bus_reset
@@ -82,7 +82,6 @@ module_param(setup_hostid, int, 0);
 #define SUN3_DVMA_BUFSIZE 0xe000
 
 static struct scsi_cmnd *sun3_dma_setup_done;
-static unsigned char *sun3_scsi_regp;
 static volatile struct sun3_dma_regs *dregs;
 static struct sun3_udc_regs *udc_regs;
 static unsigned char *sun3_dma_orig_addr;
@@ -90,20 +89,6 @@ static unsigned long sun3_dma_orig_count;
 static int sun3_dma_active;
 static unsigned long last_residual;
 
-/*
- * NCR 5380 register access functions
- */
-
-static inline unsigned char sun3scsi_read(int reg)
-{
-	return in_8(sun3_scsi_regp + reg);
-}
-
-static inline void sun3scsi_write(int reg, int value)
-{
-	out_8(sun3_scsi_regp + reg, value);
-}
-
 #ifndef SUN3_SCSI_VME
 /* dma controller register access functions */
 
@@ -431,7 +416,7 @@ static int __init sun3_scsi_probe(struct platform_device *pdev)
 	struct NCR5380_hostdata *hostdata;
 	int error;
 	struct resource *irq, *mem;
-	unsigned char *ioaddr;
+	void __iomem *ioaddr;
 	int host_flags = 0;
 #ifdef SUN3_SCSI_VME
 	int i;
@@ -494,8 +479,6 @@ static int __init sun3_scsi_probe(struct platform_device *pdev)
 	}
 #endif
 
-	sun3_scsi_regp = ioaddr;
-
 	instance = scsi_host_alloc(&sun3_scsi_template,
 	                           sizeof(struct NCR5380_hostdata));
 	if (!instance) {
@@ -506,7 +489,8 @@ static int __init sun3_scsi_probe(struct platform_device *pdev)
 	instance->irq = irq->start;
 
 	hostdata = shost_priv(instance);
-	hostdata->base = (unsigned long)ioaddr;
+	hostdata->base = mem->start;
+	hostdata->io = ioaddr;
 
 	error = NCR5380_init(instance, host_flags);
 	if (error)
@@ -555,13 +539,15 @@ static int __init sun3_scsi_probe(struct platform_device *pdev)
 fail_alloc:
 	if (udc_regs)
 		dvma_free(udc_regs);
-	iounmap(sun3_scsi_regp);
+	iounmap(ioaddr);
 	return error;
 }
 
 static int __exit sun3_scsi_remove(struct platform_device *pdev)
 {
 	struct Scsi_Host *instance = platform_get_drvdata(pdev);
+	struct NCR5380_hostdata *hostdata = shost_priv(instance);
+	void __iomem *ioaddr = hostdata->io;
 
 	scsi_remove_host(instance);
 	free_irq(instance->irq, instance);
@@ -569,7 +555,7 @@ static int __exit sun3_scsi_remove(struct platform_device *pdev)
 	scsi_host_put(instance);
 	if (udc_regs)
 		dvma_free(udc_regs);
-	iounmap(sun3_scsi_regp);
+	iounmap(ioaddr);
 	return 0;
 }
 

commit 820682b1b34ebb97434c4abc00c744870364e2be
Author: Finn Thain <fthain@telegraphics.com.au>
Date:   Mon Oct 10 00:46:53 2016 -0400

    scsi: ncr5380: Store IO ports and addresses in host private data
    
    The various 5380 drivers inconsistently store register pointers
    either in the Scsi_Host struct "legacy crap" area or in special,
    board-specific members of the NCR5380_hostdata struct. Uniform
    use of the latter struct makes for simpler and faster code (see
    the following patches) and helps to reduce use of the
    NCR5380_implementation_fields macro.
    
    Signed-off-by: Finn Thain <fthain@telegraphics.com.au>
    Reviewed-by: Hannes Reinecke <hare@suse.com>
    Tested-by: Ondrej Zary <linux@rainbow-software.org>
    Tested-by: Michael Schmitz <schmitzmic@gmail.com>
    Acked-by: Russell King <rmk+kernel@armlinux.org.uk>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/sun3_scsi.c b/drivers/scsi/sun3_scsi.c
index 3c4c07038948..efee144c6056 100644
--- a/drivers/scsi/sun3_scsi.c
+++ b/drivers/scsi/sun3_scsi.c
@@ -428,6 +428,7 @@ static struct scsi_host_template sun3_scsi_template = {
 static int __init sun3_scsi_probe(struct platform_device *pdev)
 {
 	struct Scsi_Host *instance;
+	struct NCR5380_hostdata *hostdata;
 	int error;
 	struct resource *irq, *mem;
 	unsigned char *ioaddr;
@@ -502,9 +503,11 @@ static int __init sun3_scsi_probe(struct platform_device *pdev)
 		goto fail_alloc;
 	}
 
-	instance->io_port = (unsigned long)ioaddr;
 	instance->irq = irq->start;
 
+	hostdata = shost_priv(instance);
+	hostdata->base = (unsigned long)ioaddr;
+
 	error = NCR5380_init(instance, host_flags);
 	if (error)
 		goto fail_init;

commit c4ec6f924f0682e1f40107204152e977d6b1bd07
Author: Finn Thain <fthain@telegraphics.com.au>
Date:   Wed Mar 23 21:10:22 2016 +1100

    ncr5380: Remove disused atari_NCR5380.c core driver
    
    Now that atari_scsi and sun3_scsi have been converted to use the NCR5380.c
    core driver, remove atari_NCR5380.c. Also remove the last vestiges of its
    Tagged Command Queueing implementation from the wrapper drivers.
    
    The TCQ support in atari_NCR5380.c is abandoned by this patch. It is not
    merged into the remaining core driver because,
    
    1) atari_scsi defines SUPPORT_TAGS but leaves FLAG_TAGGED_QUEUING disabled
    by default, which indicates that it is mostly undesirable.
    
    2) I'm told that it doesn't work correctly when enabled.
    
    3) The algorithm does not make use of block layer tags which it will have
    to do because scmd->tag is deprecated.
    
    4) sun3_scsi doesn't define SUPPORT_TAGS at all, yet the the SUPPORT_TAGS
    macro interacts with the CONFIG_SUN3 macro in 'interesting' ways.
    
    5) Compile-time configuration with macros like SUPPORT_TAGS caused the
    configuration space to explode, leading to untestable and unmaintainable
    code that is too hard to reason about.
    
    The merge_contiguous_buffers() code is also abandoned. This was unused
    by sun3_scsi. Only atari_scsi used it and then only on TT, because only TT
    supports scatter/gather. I suspect that the TT would work fine with
    ENABLE_CLUSTERING instead. If someone can benchmark the difference then
    perhaps the merge_contiguous_buffers() code can be be justified. Until
    then we are better off without the extra complexity.
    
    Signed-off-by: Finn Thain <fthain@telegraphics.com.au>
    Reviewed-by: Hannes Reinecke <hare@suse.com>
    Tested-by: Michael Schmitz <schmitzmic@gmail.com>
    Tested-by: Ondrej Zary <linux@rainbow-software.org>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/sun3_scsi.c b/drivers/scsi/sun3_scsi.c
index f2fc788cb08b..3c4c07038948 100644
--- a/drivers/scsi/sun3_scsi.c
+++ b/drivers/scsi/sun3_scsi.c
@@ -41,9 +41,6 @@
 
 /* Definitions for the core NCR5380 driver. */
 
-/* #define SUPPORT_TAGS */
-/* #define MAX_TAGS                     32 */
-
 #define NCR5380_implementation_fields   /* none */
 
 #define NCR5380_read(reg)               sun3scsi_read(reg)
@@ -75,10 +72,6 @@ static int setup_cmd_per_lun = -1;
 module_param(setup_cmd_per_lun, int, 0);
 static int setup_sg_tablesize = -1;
 module_param(setup_sg_tablesize, int, 0);
-#ifdef SUPPORT_TAGS
-static int setup_use_tagged_queuing = -1;
-module_param(setup_use_tagged_queuing, int, 0);
-#endif
 static int setup_hostid = -1;
 module_param(setup_hostid, int, 0);
 
@@ -512,10 +505,6 @@ static int __init sun3_scsi_probe(struct platform_device *pdev)
 	instance->io_port = (unsigned long)ioaddr;
 	instance->irq = irq->start;
 
-#ifdef SUPPORT_TAGS
-	host_flags |= setup_use_tagged_queuing > 0 ? FLAG_TAGGED_QUEUING : 0;
-#endif
-
 	error = NCR5380_init(instance, host_flags);
 	if (error)
 		goto fail_init;

commit e9db3198e08b6a01e2847f732e595bb8e89153c1
Author: Finn Thain <fthain@telegraphics.com.au>
Date:   Wed Mar 23 21:10:21 2016 +1100

    sun3_scsi: Adopt NCR5380.c core driver
    
    Add support for the custom Sun 3 DMA logic to the NCR5380.c core driver.
    This code is copied from atari_NCR5380.c.
    
    Signed-off-by: Finn Thain <fthain@telegraphics.com.au>
    Reviewed-by: Hannes Reinecke <hare@suse.com>
    Tested-by: Michael Schmitz <schmitzmic@gmail.com>
    Tested-by: Ondrej Zary <linux@rainbow-software.org>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/sun3_scsi.c b/drivers/scsi/sun3_scsi.c
index fd4fad816ad4..f2fc788cb08b 100644
--- a/drivers/scsi/sun3_scsi.c
+++ b/drivers/scsi/sun3_scsi.c
@@ -54,10 +54,8 @@
 #define NCR5380_abort                   sun3scsi_abort
 #define NCR5380_info                    sun3scsi_info
 
-#define NCR5380_dma_read_setup(instance, data, count) \
-        sun3scsi_dma_setup(instance, data, count, 0)
-#define NCR5380_dma_write_setup(instance, data, count) \
-        sun3scsi_dma_setup(instance, data, count, 1)
+#define NCR5380_dma_recv_setup(instance, data, count) (count)
+#define NCR5380_dma_send_setup(instance, data, count) (count)
 #define NCR5380_dma_residual(instance) \
         sun3scsi_dma_residual(instance)
 #define NCR5380_dma_xfer_len(instance, cmd, phase) \
@@ -406,7 +404,7 @@ static int sun3scsi_dma_finish(int write_flag)
 
 }
 	
-#include "atari_NCR5380.c"
+#include "NCR5380.c"
 
 #ifdef SUN3_SCSI_VME
 #define SUN3_SCSI_NAME          "Sun3 NCR5380 VME SCSI"

commit e63449c43a58fc185ff35ace6a842817f57ec6c8
Author: Finn Thain <fthain@telegraphics.com.au>
Date:   Wed Mar 23 21:10:13 2016 +1100

    atari_NCR5380: Remove DMA_MIN_SIZE macro
    
    Only the atari_scsi and sun3_scsi drivers define DMA_MIN_SIZE.
    Both drivers also define NCR5380_dma_xfer_len, which means
    DMA_MIN_SIZE can be removed from the core driver.
    
    This removes another discrepancy between the two core drivers.
    
    Signed-off-by: Finn Thain <fthain@telegraphics.com.au>
    Tested-by: Michael Schmitz <schmitzmic@gmail.com>
    Reviewed-by: Hannes Reinecke <hare@suse.com>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/sun3_scsi.c b/drivers/scsi/sun3_scsi.c
index 5551b1623ed6..fd4fad816ad4 100644
--- a/drivers/scsi/sun3_scsi.c
+++ b/drivers/scsi/sun3_scsi.c
@@ -36,12 +36,12 @@
 #include <scsi/scsi_host.h>
 #include "sun3_scsi.h"
 
-/* Definitions for the core NCR5380 driver. */
-
-/* #define SUPPORT_TAGS */
 /* minimum number of bytes to do dma on */
 #define DMA_MIN_SIZE                    129
 
+/* Definitions for the core NCR5380 driver. */
+
+/* #define SUPPORT_TAGS */
 /* #define MAX_TAGS                     32 */
 
 #define NCR5380_implementation_fields   /* none */
@@ -61,7 +61,7 @@
 #define NCR5380_dma_residual(instance) \
         sun3scsi_dma_residual(instance)
 #define NCR5380_dma_xfer_len(instance, cmd, phase) \
-        sun3scsi_dma_xfer_len(cmd->SCp.this_residual, cmd, !((phase) & SR_IO))
+        sun3scsi_dma_xfer_len(cmd->SCp.this_residual, cmd)
 
 #define NCR5380_acquire_dma_irq(instance)    (1)
 #define NCR5380_release_dma_irq(instance)
@@ -262,14 +262,13 @@ static inline unsigned long sun3scsi_dma_residual(struct Scsi_Host *instance)
 	return last_residual;
 }
 
-static inline unsigned long sun3scsi_dma_xfer_len(unsigned long wanted,
-						  struct scsi_cmnd *cmd,
-						  int write_flag)
+static inline unsigned long sun3scsi_dma_xfer_len(unsigned long wanted_len,
+                                                  struct scsi_cmnd *cmd)
 {
-	if (cmd->request->cmd_type == REQ_TYPE_FS)
- 		return wanted;
-	else
+	if (wanted_len < DMA_MIN_SIZE || cmd->request->cmd_type != REQ_TYPE_FS)
 		return 0;
+
+	return wanted_len;
 }
 
 static inline int sun3scsi_dma_start(unsigned long count, unsigned char *data)

commit e4dec6806aceca768b74c1c6402e6d31ecf3c960
Author: Finn Thain <fthain@telegraphics.com.au>
Date:   Wed Mar 23 21:10:12 2016 +1100

    ncr5380: Remove REAL_DMA and REAL_DMA_POLL macros
    
    For the NCR5380.c core driver, these macros are never used.
    If REAL_DMA were to be defined, compilation would fail.
    
    For the atari_NCR5380.c core driver, REAL_DMA is always defined.
    
    Hence these macros are pointless.
    
    Signed-off-by: Finn Thain <fthain@telegraphics.com.au>
    Reviewed-by: Hannes Reinecke <hare@suse.com>
    Tested-by: Michael Schmitz <schmitzmic@gmail.com>
    Tested-by: Ondrej Zary <linux@rainbow-software.org>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/sun3_scsi.c b/drivers/scsi/sun3_scsi.c
index b9de487bbd31..5551b1623ed6 100644
--- a/drivers/scsi/sun3_scsi.c
+++ b/drivers/scsi/sun3_scsi.c
@@ -38,7 +38,6 @@
 
 /* Definitions for the core NCR5380 driver. */
 
-#define REAL_DMA
 /* #define SUPPORT_TAGS */
 /* minimum number of bytes to do dma on */
 #define DMA_MIN_SIZE                    129
@@ -527,15 +526,9 @@ static int __init sun3_scsi_probe(struct platform_device *pdev)
 	error = request_irq(instance->irq, scsi_sun3_intr, 0,
 	                    "NCR5380", instance);
 	if (error) {
-#ifdef REAL_DMA
 		pr_err(PFX "scsi%d: IRQ %d not free, bailing out\n",
 		       instance->host_no, instance->irq);
 		goto fail_irq;
-#else
-		pr_warn(PFX "scsi%d: IRQ %d not free, interrupts disabled\n",
-		        instance->host_no, instance->irq);
-		instance->irq = NO_IRQ;
-#endif
 	}
 
 	dregs->csr = 0;
@@ -565,8 +558,7 @@ static int __init sun3_scsi_probe(struct platform_device *pdev)
 	return 0;
 
 fail_host:
-	if (instance->irq != NO_IRQ)
-		free_irq(instance->irq, instance);
+	free_irq(instance->irq, instance);
 fail_irq:
 	NCR5380_exit(instance);
 fail_init:
@@ -583,8 +575,7 @@ static int __exit sun3_scsi_remove(struct platform_device *pdev)
 	struct Scsi_Host *instance = platform_get_drvdata(pdev);
 
 	scsi_remove_host(instance);
-	if (instance->irq != NO_IRQ)
-		free_irq(instance->irq, instance);
+	free_irq(instance->irq, instance);
 	NCR5380_exit(instance);
 	scsi_host_put(instance);
 	if (udc_regs)

commit cd46140a9a2f8fe0208262dc5f4d1fba15c93063
Author: Finn Thain <fthain@telegraphics.com.au>
Date:   Sun Jan 3 16:06:06 2016 +1100

    atari_scsi, sun3_scsi: Remove global Scsi_Host pointer
    
    This refactoring removes two global Scsi_Host pointers. This
    improves consistency with other ncr5380 drivers. Adopting the same
    conventions as the other drivers makes them easier to read.
    
    Signed-off-by: Finn Thain <fthain@telegraphics.com.au>
    Reviewed-by: Hannes Reinecke <hare@suse.com>
    Tested-by: Michael Schmitz <schmitzmic@gmail.com>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/sun3_scsi.c b/drivers/scsi/sun3_scsi.c
index c10782b4843e..b9de487bbd31 100644
--- a/drivers/scsi/sun3_scsi.c
+++ b/drivers/scsi/sun3_scsi.c
@@ -56,9 +56,9 @@
 #define NCR5380_info                    sun3scsi_info
 
 #define NCR5380_dma_read_setup(instance, data, count) \
-        sun3scsi_dma_setup(data, count, 0)
+        sun3scsi_dma_setup(instance, data, count, 0)
 #define NCR5380_dma_write_setup(instance, data, count) \
-        sun3scsi_dma_setup(data, count, 1)
+        sun3scsi_dma_setup(instance, data, count, 1)
 #define NCR5380_dma_residual(instance) \
         sun3scsi_dma_residual(instance)
 #define NCR5380_dma_xfer_len(instance, cmd, phase) \
@@ -99,7 +99,6 @@ static unsigned char *sun3_dma_orig_addr;
 static unsigned long sun3_dma_orig_count;
 static int sun3_dma_active;
 static unsigned long last_residual;
-static struct Scsi_Host *default_instance;
 
 /*
  * NCR 5380 register access functions
@@ -142,8 +141,9 @@ static inline void sun3_udc_write(unsigned short val, unsigned char reg)
 // safe bits for the CSR
 #define CSR_GOOD 0x060f
 
-static irqreturn_t scsi_sun3_intr(int irq, void *dummy)
+static irqreturn_t scsi_sun3_intr(int irq, void *dev)
 {
+	struct Scsi_Host *instance = dev;
 	unsigned short csr = dregs->csr;
 	int handled = 0;
 
@@ -152,46 +152,24 @@ static irqreturn_t scsi_sun3_intr(int irq, void *dummy)
 #endif
 
 	if(csr & ~CSR_GOOD) {
-		if(csr & CSR_DMA_BUSERR) {
-			printk("scsi%d: bus error in dma\n", default_instance->host_no);
-		}
-
-		if(csr & CSR_DMA_CONFLICT) {
-			printk("scsi%d: dma conflict\n", default_instance->host_no);
-		}
+		if (csr & CSR_DMA_BUSERR)
+			shost_printk(KERN_ERR, instance, "bus error in DMA\n");
+		if (csr & CSR_DMA_CONFLICT)
+			shost_printk(KERN_ERR, instance, "DMA conflict\n");
 		handled = 1;
 	}
 
 	if(csr & (CSR_SDB_INT | CSR_DMA_INT)) {
-		NCR5380_intr(irq, dummy);
+		NCR5380_intr(irq, dev);
 		handled = 1;
 	}
 
 	return IRQ_RETVAL(handled);
 }
 
-/*
- * Debug stuff - to be called on NMI, or sysrq key. Use at your own risk; 
- * reentering NCR5380_print_status seems to have ugly side effects
- */
-
-/* this doesn't seem to get used at all -- sam */
-#if 0
-void sun3_sun3_debug (void)
-{
-	unsigned long flags;
-
-	if (default_instance) {
-			local_irq_save(flags);
-			NCR5380_print_status(default_instance);
-			local_irq_restore(flags);
-	}
-}
-#endif
-
-
 /* sun3scsi_dma_setup() -- initialize the dma controller for a read/write */
-static unsigned long sun3scsi_dma_setup(void *data, unsigned long count, int write_flag)
+static unsigned long sun3scsi_dma_setup(struct Scsi_Host *instance,
+                                void *data, unsigned long count, int write_flag)
 {
 	void *addr;
 
@@ -243,10 +221,9 @@ static unsigned long sun3scsi_dma_setup(void *data, unsigned long count, int wri
 	dregs->csr |= CSR_FIFO;
 	
 	if(dregs->fifo_count != count) { 
-		printk("scsi%d: fifo_mismatch %04x not %04x\n",
-		       default_instance->host_no, dregs->fifo_count,
-		       (unsigned int) count);
-		NCR5380_dprint(NDEBUG_DMA, default_instance);
+		shost_printk(KERN_ERR, instance, "FIFO mismatch %04x not %04x\n",
+		             dregs->fifo_count, (unsigned int) count);
+		NCR5380_dprint(NDEBUG_DMA, instance);
 	}
 
 	/* setup udc */
@@ -281,21 +258,6 @@ static unsigned long sun3scsi_dma_setup(void *data, unsigned long count, int wri
 
 }
 
-#ifndef SUN3_SCSI_VME
-static inline unsigned long sun3scsi_dma_count(struct Scsi_Host *instance)
-{
-	unsigned short resid;
-
-	dregs->udc_addr = 0x32; 
-	udelay(SUN3_DMA_DELAY);
-	resid = dregs->udc_data;
-	udelay(SUN3_DMA_DELAY);
-	resid *= 2;
-
-	return (unsigned long) resid;
-}
-#endif
-
 static inline unsigned long sun3scsi_dma_residual(struct Scsi_Host *instance)
 {
 	return last_residual;
@@ -393,7 +355,10 @@ static int sun3scsi_dma_finish(int write_flag)
 		}
 	}
 
-	count = sun3scsi_dma_count(default_instance);
+	dregs->udc_addr = 0x32;
+	udelay(SUN3_DMA_DELAY);
+	count = 2 * dregs->udc_data;
+	udelay(SUN3_DMA_DELAY);
 
 	fifo = dregs->fifo_count;
 	last_residual = fifo;
@@ -547,7 +512,6 @@ static int __init sun3_scsi_probe(struct platform_device *pdev)
 		error = -ENOMEM;
 		goto fail_alloc;
 	}
-	default_instance = instance;
 
 	instance->io_port = (unsigned long)ioaddr;
 	instance->irq = irq->start;

commit 32b26a104237c1ba3575a6c8d47e46060cc416fb
Author: Finn Thain <fthain@telegraphics.com.au>
Date:   Sun Jan 3 16:05:58 2016 +1100

    ncr5380: Use standard list data structure
    
    The NCR5380 drivers have a home-spun linked list implementation for
    scsi_cmnd structs that uses cmd->host_scribble as a 'next' pointer. Adopt
    the standard list_head data structure and list operations instead. Remove
    the eh_abort_handler rather than convert it. Doing the conversion would
    only be churn because the existing EH handlers don't work and get replaced
    in a subsequent patch.
    
    Signed-off-by: Finn Thain <fthain@telegraphics.com.au>
    Reviewed-by: Hannes Reinecke <hare@suse.com>
    Tested-by: Ondrej Zary <linux@rainbow-software.org>
    Tested-by: Michael Schmitz <schmitzmic@gmail.com>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/sun3_scsi.c b/drivers/scsi/sun3_scsi.c
index 14835540fecb..c10782b4843e 100644
--- a/drivers/scsi/sun3_scsi.c
+++ b/drivers/scsi/sun3_scsi.c
@@ -468,6 +468,7 @@ static struct scsi_host_template sun3_scsi_template = {
 	.sg_tablesize		= SG_NONE,
 	.cmd_per_lun		= 2,
 	.use_clustering		= DISABLE_CLUSTERING,
+	.cmd_size		= NCR5380_CMD_SIZE,
 };
 
 static int __init sun3_scsi_probe(struct platform_device *pdev)

commit e5c3fddfaa066e440315e713ddf8b60e9ac48cf7
Author: Finn Thain <fthain@telegraphics.com.au>
Date:   Sun Jan 3 16:05:52 2016 +1100

    ncr5380: Remove command list debug code
    
    Some NCR5380 hosts offer a .show_info method to access the contents of
    the various command list data structures from a procfs file. When NDEBUG
    is set, the same information is sent to the console during EH.
    
    The two core drivers, atari_NCR5380.c and NCR5380.c differ here. Because
    it is just for debugging, the easiest way to fix the discrepancy is
    simply remove this code.
    
    The only remaining users of NCR5380_show_info() and NCR5380_write_info()
    are drivers that define PSEUDO_DMA. The others have no use for the
    .show_info method, so don't initialize it.
    
    Signed-off-by: Finn Thain <fthain@telegraphics.com.au>
    Reviewed-by: Hannes Reinecke <hare@suse.com>
    Tested-by: Ondrej Zary <linux@rainbow-software.org>
    Tested-by: Michael Schmitz <schmitzmic@gmail.com>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/sun3_scsi.c b/drivers/scsi/sun3_scsi.c
index 082c91a4c1c4..14835540fecb 100644
--- a/drivers/scsi/sun3_scsi.c
+++ b/drivers/scsi/sun3_scsi.c
@@ -53,7 +53,6 @@
 #define NCR5380_queue_command           sun3scsi_queue_command
 #define NCR5380_bus_reset               sun3scsi_bus_reset
 #define NCR5380_abort                   sun3scsi_abort
-#define NCR5380_show_info               sun3scsi_show_info
 #define NCR5380_info                    sun3scsi_info
 
 #define NCR5380_dma_read_setup(instance, data, count) \
@@ -459,7 +458,6 @@ static int sun3scsi_dma_finish(int write_flag)
 static struct scsi_host_template sun3_scsi_template = {
 	.module			= THIS_MODULE,
 	.proc_name		= DRV_MODULE_NAME,
-	.show_info		= sun3scsi_show_info,
 	.name			= SUN3_SCSI_NAME,
 	.info			= sun3scsi_info,
 	.queuecommand		= sun3scsi_queue_command,

commit aa2e2cb1dde0e72e039f94210fb17e73661a6351
Author: Finn Thain <fthain@telegraphics.com.au>
Date:   Sun Jan 3 16:05:48 2016 +1100

    ncr5380: Fix and cleanup scsi_host_template initializers
    
    Add missing .module initializer. Use distinct .proc_name values for the
    g_NCR5380 and g_NCR5380_mmio modules. Remove pointless CAN_QUEUE and
    CMD_PER_LUN override macros. Cleanup whitespace and code style.
    
    Signed-off-by: Finn Thain <fthain@telegraphics.com.au>
    Reviewed-by: Hannes Reinecke <hare@suse.com>
    Tested-by: Ondrej Zary <linux@rainbow-software.org>
    Tested-by: Michael Schmitz <schmitzmic@gmail.com>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/sun3_scsi.c b/drivers/scsi/sun3_scsi.c
index c4fcf2fa74fc..082c91a4c1c4 100644
--- a/drivers/scsi/sun3_scsi.c
+++ b/drivers/scsi/sun3_scsi.c
@@ -463,13 +463,13 @@ static struct scsi_host_template sun3_scsi_template = {
 	.name			= SUN3_SCSI_NAME,
 	.info			= sun3scsi_info,
 	.queuecommand		= sun3scsi_queue_command,
-	.eh_abort_handler      	= sun3scsi_abort,
-	.eh_bus_reset_handler  	= sun3scsi_bus_reset,
+	.eh_abort_handler	= sun3scsi_abort,
+	.eh_bus_reset_handler	= sun3scsi_bus_reset,
 	.can_queue		= 16,
 	.this_id		= 7,
 	.sg_tablesize		= SG_NONE,
 	.cmd_per_lun		= 2,
-	.use_clustering		= DISABLE_CLUSTERING
+	.use_clustering		= DISABLE_CLUSTERING,
 };
 
 static int __init sun3_scsi_probe(struct platform_device *pdev)

commit 0ad0eff98fec3c940ec199047ff580abaaa5bb1a
Author: Finn Thain <fthain@telegraphics.com.au>
Date:   Sun Jan 3 16:05:21 2016 +1100

    ncr5380: Introduce unbound workqueue
    
    Allocate a work queue that will permit busy waiting and sleeping. This
    means NCR5380_init() can potentially fail, so add this error path.
    
    Signed-off-by: Finn Thain <fthain@telegraphics.com.au>
    Reviewed-by: Hannes Reinecke <hare@suse.com>
    Tested-by: Ondrej Zary <linux@rainbow-software.org>
    Tested-by: Michael Schmitz <schmitzmic@gmail.com>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/sun3_scsi.c b/drivers/scsi/sun3_scsi.c
index 9376b3d8bfdc..c4fcf2fa74fc 100644
--- a/drivers/scsi/sun3_scsi.c
+++ b/drivers/scsi/sun3_scsi.c
@@ -557,7 +557,9 @@ static int __init sun3_scsi_probe(struct platform_device *pdev)
 	host_flags |= setup_use_tagged_queuing > 0 ? FLAG_TAGGED_QUEUING : 0;
 #endif
 
-	NCR5380_init(instance, host_flags);
+	error = NCR5380_init(instance, host_flags);
+	if (error)
+		goto fail_init;
 
 	error = request_irq(instance->irq, scsi_sun3_intr, 0,
 	                    "NCR5380", instance);
@@ -604,6 +606,7 @@ static int __init sun3_scsi_probe(struct platform_device *pdev)
 		free_irq(instance->irq, instance);
 fail_irq:
 	NCR5380_exit(instance);
+fail_init:
 	scsi_host_put(instance);
 fail_alloc:
 	if (udc_regs)

commit 9c3f0e2b52ada30fe72beec27b83e91e12566609
Author: Finn Thain <fthain@telegraphics.com.au>
Date:   Sun Jan 3 16:05:11 2016 +1100

    atari_NCR5380: Remove RESET_BOOT, CONFIG_ATARI_SCSI_TOSHIBA_DELAY and CONFIG_ATARI_SCSI_RESET_BOOT
    
    The atari_NCR5380.c core driver now takes care of bus reset upon driver
    initialization if required (same as NCR5380.c). Move the Toshiba CD-ROM
    support into the core driver, enabled with a host flag, so that all
    NCR5380 drivers can make use of it.
    
    Drop the RESET_BOOT macros and the ATARI_SCSI_RESET_BOOT and
    ATARI_SCSI_TOSHIBA_DELAY Kconfig symbols, which are now redundant.
    
    Remove the atari_scsi_reset_boot(), mac_scsi_reset_boot() and
    sun3_scsi_reset_boot() routines. None of this duplicated code is needed
    now that all drivers can use NCR5380_maybe_reset_bus().
    
    This brings atari_scsi, mac_scsi and sun3_scsi into line with all of the
    other NCR5380 drivers.
    
    The bus reset may raise an interrupt. That would be new behaviour for
    atari_scsi only when CONFIG_ATARI_SCSI_RESET_BOOT=n. The ST DMA interrupt
    is not assigned to atari_scsi at this stage, so
    CONFIG_ATARI_SCSI_RESET_BOOT=y may well be problematic already.
    Regardless, do_reset() now raises and clears the interrupt within
    local_irq_save/restore which should avoid problems.
    
    Signed-off-by: Finn Thain <fthain@telegraphics.com.au>
    Reviewed-by: Hannes Reinecke <hare@suse.com>
    Tested-by: Ondrej Zary <linux@rainbow-software.org>
    Tested-by: Michael Schmitz <schmitzmic@gmail.com>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/sun3_scsi.c b/drivers/scsi/sun3_scsi.c
index 836f5ca6d209..9376b3d8bfdc 100644
--- a/drivers/scsi/sun3_scsi.c
+++ b/drivers/scsi/sun3_scsi.c
@@ -86,10 +86,6 @@ module_param(setup_use_tagged_queuing, int, 0);
 static int setup_hostid = -1;
 module_param(setup_hostid, int, 0);
 
-/* #define RESET_BOOT */
-
-#define	AFTER_RESET_DELAY	(HZ/2)
-
 /* ms to wait after hitting dma regs */
 #define SUN3_DMA_DELAY 10
 
@@ -144,45 +140,6 @@ static inline void sun3_udc_write(unsigned short val, unsigned char reg)
 }
 #endif
 
-#ifdef RESET_BOOT
-static void sun3_scsi_reset_boot(struct Scsi_Host *instance)
-{
-	unsigned long end;
-	
-	/*
-	 * Do a SCSI reset to clean up the bus during initialization. No
-	 * messing with the queues, interrupts, or locks necessary here.
-	 */
-
-	printk( "Sun3 SCSI: resetting the SCSI bus..." );
-
-	/* switch off SCSI IRQ - catch an interrupt without IRQ bit set else */
-//       	sun3_disable_irq( IRQ_SUN3_SCSI );
-
-	/* get in phase */
-	NCR5380_write( TARGET_COMMAND_REG,
-		      PHASE_SR_TO_TCR( NCR5380_read(STATUS_REG) ));
-
-	/* assert RST */
-	NCR5380_write( INITIATOR_COMMAND_REG, ICR_BASE | ICR_ASSERT_RST );
-
-	/* The min. reset hold time is 25us, so 40us should be enough */
-	udelay( 50 );
-
-	/* reset RST and interrupt */
-	NCR5380_write( INITIATOR_COMMAND_REG, ICR_BASE );
-	NCR5380_read( RESET_PARITY_INTERRUPT_REG );
-
-	for( end = jiffies + AFTER_RESET_DELAY; time_before(jiffies, end); )
-		barrier();
-
-	/* switch on SCSI IRQ again */
-//       	sun3_enable_irq( IRQ_SUN3_SCSI );
-
-	printk( " done\n" );
-}
-#endif
-
 // safe bits for the CSR
 #define CSR_GOOD 0x060f
 
@@ -631,9 +588,7 @@ static int __init sun3_scsi_probe(struct platform_device *pdev)
 	dregs->ivect = VME_DATA24 | (instance->irq & 0xff);
 #endif
 
-#ifdef RESET_BOOT
-	sun3_scsi_reset_boot(instance);
-#endif
+	NCR5380_maybe_reset_bus(instance);
 
 	error = scsi_add_host(instance, NULL);
 	if (error)

commit d5f7e65df0d41982b1e9cbba9df04003ebb2178d
Author: Finn Thain <fthain@telegraphics.com.au>
Date:   Sun Jan 3 16:05:03 2016 +1100

    ncr5380: Remove redundant static variable initializers
    
    Signed-off-by: Finn Thain <fthain@telegraphics.com.au>
    Reviewed-by: Hannes Reinecke <hare@suse.com>
    Tested-by: Ondrej Zary <linux@rainbow-software.org>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/sun3_scsi.c b/drivers/scsi/sun3_scsi.c
index 22a42836d193..836f5ca6d209 100644
--- a/drivers/scsi/sun3_scsi.c
+++ b/drivers/scsi/sun3_scsi.c
@@ -100,10 +100,10 @@ static struct scsi_cmnd *sun3_dma_setup_done;
 static unsigned char *sun3_scsi_regp;
 static volatile struct sun3_dma_regs *dregs;
 static struct sun3_udc_regs *udc_regs;
-static unsigned char *sun3_dma_orig_addr = NULL;
-static unsigned long sun3_dma_orig_count = 0;
-static int sun3_dma_active = 0;
-static unsigned long last_residual = 0;
+static unsigned char *sun3_dma_orig_addr;
+static unsigned long sun3_dma_orig_count;
+static int sun3_dma_active;
+static unsigned long last_residual;
 static struct Scsi_Host *default_instance;
 
 /*

commit 700d98551ff16a59e164bf884aefbdc5d798ff75
Author: Wolfram Sang <wsa@the-dreams.de>
Date:   Thu Jan 29 17:54:46 2015 +1100

    ncr5380: Drop owner assignment from platform_drivers
    
    This platform_driver does not need to set an owner, it will be populated by
    the driver core.
    
    Signed-off-by: Wolfram Sang <wsa@the-dreams.de>
    Signed-off-by: Finn Thain <fthain@telegraphics.com.au>
    Signed-off-by: James Bottomley <JBottomley@Parallels.com>

diff --git a/drivers/scsi/sun3_scsi.c b/drivers/scsi/sun3_scsi.c
index 2a906d1d34ba..22a42836d193 100644
--- a/drivers/scsi/sun3_scsi.c
+++ b/drivers/scsi/sun3_scsi.c
@@ -676,7 +676,6 @@ static struct platform_driver sun3_scsi_driver = {
 	.remove = __exit_p(sun3_scsi_remove),
 	.driver = {
 		.name	= DRV_MODULE_NAME,
-		.owner	= THIS_MODULE,
 	},
 };
 

commit ab93afaceb9623d5ad27b6022366b8f3d27d20e4
Author: Finn Thain <fthain@telegraphics.com.au>
Date:   Wed Nov 12 16:12:22 2014 +1100

    atari_NCR5380: Remove RESET_RUN_DONE macro
    
    There's no need to run the cmd->done callback for aborted commands. Remove
    the old EH code and the RESET_RUN_DONE macro.
    
    Signed-off-by: Finn Thain <fthain@telegraphics.com.au>
    Reviewed-by: Hannes Reinecke <hare@suse.de>
    Tested-by: Michael Schmitz <schmitzmic@gmail.com>
    Signed-off-by: Christoph Hellwig <hch@lst.de>

diff --git a/drivers/scsi/sun3_scsi.c b/drivers/scsi/sun3_scsi.c
index a98c7325f2dd..2a906d1d34ba 100644
--- a/drivers/scsi/sun3_scsi.c
+++ b/drivers/scsi/sun3_scsi.c
@@ -39,7 +39,6 @@
 /* Definitions for the core NCR5380 driver. */
 
 #define REAL_DMA
-#define RESET_RUN_DONE
 /* #define SUPPORT_TAGS */
 /* minimum number of bytes to do dma on */
 #define DMA_MIN_SIZE                    129

commit ca513fc948e66ecdd3c75cca9371762bb4c06776
Author: Finn Thain <fthain@telegraphics.com.au>
Date:   Wed Nov 12 16:12:19 2014 +1100

    atari_NCR5380: Introduce FLAG_TAGGED_QUEUING
    
    The static variable setup_use_tagged_queuing is declared in mac_scsi.c,
    sun3_scsi.c and atari_scsi.c and doesn't belong in the core driver.
    None of the other NCR5380 drivers suffer from this layering issue which
    makes merging the core drivers more difficult and will likely hinder plans
    for future use of platform data to configure the driver.
    
    Replace the static variable with a host flag. This way it can be reported
    along with the other flags.
    
    Signed-off-by: Finn Thain <fthain@telegraphics.com.au>
    Reviewed-by: Hannes Reinecke <hare@suse.de>
    Tested-by: Michael Schmitz <schmitzmic@gmail.com>
    Signed-off-by: Christoph Hellwig <hch@lst.de>

diff --git a/drivers/scsi/sun3_scsi.c b/drivers/scsi/sun3_scsi.c
index 985a6b36756e..a98c7325f2dd 100644
--- a/drivers/scsi/sun3_scsi.c
+++ b/drivers/scsi/sun3_scsi.c
@@ -522,6 +522,7 @@ static int __init sun3_scsi_probe(struct platform_device *pdev)
 	int error;
 	struct resource *irq, *mem;
 	unsigned char *ioaddr;
+	int host_flags = 0;
 #ifdef SUN3_SCSI_VME
 	int i;
 #endif
@@ -535,11 +536,6 @@ static int __init sun3_scsi_probe(struct platform_device *pdev)
 	if (setup_hostid >= 0)
 		sun3_scsi_template.this_id = setup_hostid & 7;
 
-#ifdef SUPPORT_TAGS
-	if (setup_use_tagged_queuing < 0)
-		setup_use_tagged_queuing = 1;
-#endif
-
 #ifdef SUN3_SCSI_VME
 	ioaddr = NULL;
 	for (i = 0; i < 2; i++) {
@@ -601,7 +597,11 @@ static int __init sun3_scsi_probe(struct platform_device *pdev)
 	instance->io_port = (unsigned long)ioaddr;
 	instance->irq = irq->start;
 
-	NCR5380_init(instance, 0);
+#ifdef SUPPORT_TAGS
+	host_flags |= setup_use_tagged_queuing > 0 ? FLAG_TAGGED_QUEUING : 0;
+#endif
+
+	NCR5380_init(instance, host_flags);
 
 	error = request_irq(instance->irq, scsi_sun3_intr, 0,
 	                    "NCR5380", instance);

commit 8dad0c51dac3f906b213ef3486cad39a06419252
Author: Finn Thain <fthain@telegraphics.com.au>
Date:   Wed Nov 12 16:12:17 2014 +1100

    sun3_scsi: Adopt atari_NCR5380 core driver and remove sun3_NCR5380.c
    
    Given the preceding changes to atari_NCR5380.c, this patch should not change
    behaviour of the sun3_scsi and sun3_scsi_vme modules.
    
    Signed-off-by: Finn Thain <fthain@telegraphics.com.au>
    Reviewed-by: Hannes Reinecke <hare@suse.de>
    Signed-off-by: Christoph Hellwig <hch@lst.de>

diff --git a/drivers/scsi/sun3_scsi.c b/drivers/scsi/sun3_scsi.c
index 446c8e58a8db..985a6b36756e 100644
--- a/drivers/scsi/sun3_scsi.c
+++ b/drivers/scsi/sun3_scsi.c
@@ -41,6 +41,8 @@
 #define REAL_DMA
 #define RESET_RUN_DONE
 /* #define SUPPORT_TAGS */
+/* minimum number of bytes to do dma on */
+#define DMA_MIN_SIZE                    129
 
 /* #define MAX_TAGS                     32 */
 
@@ -64,6 +66,9 @@
 #define NCR5380_dma_xfer_len(instance, cmd, phase) \
         sun3scsi_dma_xfer_len(cmd->SCp.this_residual, cmd, !((phase) & SR_IO))
 
+#define NCR5380_acquire_dma_irq(instance)    (1)
+#define NCR5380_release_dma_irq(instance)
+
 #include "NCR5380.h"
 
 
@@ -92,9 +97,6 @@ module_param(setup_hostid, int, 0);
 /* dvma buffer to allocate -- 32k should hopefully be more than sufficient */
 #define SUN3_DVMA_BUFSIZE 0xe000
 
-/* minimum number of bytes to do dma on */
-#define SUN3_DMA_MINSIZE 128
-
 static struct scsi_cmnd *sun3_dma_setup_done;
 static unsigned char *sun3_scsi_regp;
 static volatile struct sun3_dma_regs *dregs;
@@ -486,7 +488,7 @@ static int sun3scsi_dma_finish(int write_flag)
 
 }
 	
-#include "sun3_NCR5380.c"
+#include "atari_NCR5380.c"
 
 #ifdef SUN3_SCSI_VME
 #define SUN3_SCSI_NAME          "Sun3 NCR5380 VME SCSI"

commit f527590278f1b823ba979a234241d09ed2c436b4
Author: Finn Thain <fthain@telegraphics.com.au>
Date:   Wed Nov 12 16:12:13 2014 +1100

    ncr5380: Remove ENABLE_IRQ/DISABLE_IRQ macros
    
    atari_NCR5380.c enables its IRQ when it is already enabled. Sun3 doesn't
    use the ENABLE_IRQ/DISABLE_IRQ cruft. Remove it.
    
    Signed-off-by: Finn Thain <fthain@telegraphics.com.au>
    Reviewed-by: Hannes Reinecke <hare@suse.de>
    Tested-by: Michael Schmitz <schmitzmic@gmail.com>
    Signed-off-by: Christoph Hellwig <hch@lst.de>

diff --git a/drivers/scsi/sun3_scsi.c b/drivers/scsi/sun3_scsi.c
index 6943dd6b9b56..446c8e58a8db 100644
--- a/drivers/scsi/sun3_scsi.c
+++ b/drivers/scsi/sun3_scsi.c
@@ -69,13 +69,6 @@
 
 extern int sun3_map_test(unsigned long, char *);
 
-#ifdef SUN3_SCSI_VME
-#define ENABLE_IRQ()
-#else
-#define	ENABLE_IRQ()	enable_irq( IRQ_SUN3_SCSI ); 
-#endif
-
-
 static int setup_can_queue = -1;
 module_param(setup_can_queue, int, 0);
 static int setup_cmd_per_lun = -1;

commit 2231ef876a0ab4ab7b344bff6cc1508d9b6c1b52
Author: Finn Thain <fthain@telegraphics.com.au>
Date:   Wed Nov 12 16:12:12 2014 +1100

    sun3_scsi: Move macro definitions
    
    The #defines in sun3_scsi.h are intended to influence subsequent #includes
    in sun3_scsi.c. IMHO, that's too convoluted.
    
    Move sun3_scsi.h macro definitions to sun3_scsi.c, consistent with other
    NCR5380 drivers.
    
    Omit the unused NCR5380_local_declare() and NCR5380_setup() macros.
    
    Signed-off-by: Finn Thain <fthain@telegraphics.com.au>
    Reviewed-by: Hannes Reinecke <hare@suse.de>
    Signed-off-by: Christoph Hellwig <hch@lst.de>

diff --git a/drivers/scsi/sun3_scsi.c b/drivers/scsi/sun3_scsi.c
index ba5169982706..6943dd6b9b56 100644
--- a/drivers/scsi/sun3_scsi.c
+++ b/drivers/scsi/sun3_scsi.c
@@ -33,18 +33,42 @@
 #include <asm/io.h>
 #include <asm/dvma.h>
 
-/* dma on! */
-#define REAL_DMA
-
 #include <scsi/scsi_host.h>
 #include "sun3_scsi.h"
-#include "NCR5380.h"
 
-extern int sun3_map_test(unsigned long, char *);
+/* Definitions for the core NCR5380 driver. */
 
-/*#define RESET_BOOT */
+#define REAL_DMA
+#define RESET_RUN_DONE
 /* #define SUPPORT_TAGS */
 
+/* #define MAX_TAGS                     32 */
+
+#define NCR5380_implementation_fields   /* none */
+
+#define NCR5380_read(reg)               sun3scsi_read(reg)
+#define NCR5380_write(reg, value)       sun3scsi_write(reg, value)
+
+#define NCR5380_queue_command           sun3scsi_queue_command
+#define NCR5380_bus_reset               sun3scsi_bus_reset
+#define NCR5380_abort                   sun3scsi_abort
+#define NCR5380_show_info               sun3scsi_show_info
+#define NCR5380_info                    sun3scsi_info
+
+#define NCR5380_dma_read_setup(instance, data, count) \
+        sun3scsi_dma_setup(data, count, 0)
+#define NCR5380_dma_write_setup(instance, data, count) \
+        sun3scsi_dma_setup(data, count, 1)
+#define NCR5380_dma_residual(instance) \
+        sun3scsi_dma_residual(instance)
+#define NCR5380_dma_xfer_len(instance, cmd, phase) \
+        sun3scsi_dma_xfer_len(cmd->SCp.this_residual, cmd, !((phase) & SR_IO))
+
+#include "NCR5380.h"
+
+
+extern int sun3_map_test(unsigned long, char *);
+
 #ifdef SUN3_SCSI_VME
 #define ENABLE_IRQ()
 #else
@@ -65,9 +89,7 @@ module_param(setup_use_tagged_queuing, int, 0);
 static int setup_hostid = -1;
 module_param(setup_hostid, int, 0);
 
-static struct scsi_cmnd *sun3_dma_setup_done = NULL;
-
-#define	RESET_RUN_DONE
+/* #define RESET_BOOT */
 
 #define	AFTER_RESET_DELAY	(HZ/2)
 
@@ -80,6 +102,7 @@ static struct scsi_cmnd *sun3_dma_setup_done = NULL;
 /* minimum number of bytes to do dma on */
 #define SUN3_DMA_MINSIZE 128
 
+static struct scsi_cmnd *sun3_dma_setup_done;
 static unsigned char *sun3_scsi_regp;
 static volatile struct sun3_dma_regs *dregs;
 static struct sun3_udc_regs *udc_regs;
@@ -131,9 +154,6 @@ static inline void sun3_udc_write(unsigned short val, unsigned char reg)
 static void sun3_scsi_reset_boot(struct Scsi_Host *instance)
 {
 	unsigned long end;
-
-	NCR5380_local_declare();
-	NCR5380_setup(instance);
 	
 	/*
 	 * Do a SCSI reset to clean up the bus during initialization. No
@@ -210,7 +230,6 @@ static irqreturn_t scsi_sun3_intr(int irq, void *dummy)
 void sun3_sun3_debug (void)
 {
 	unsigned long flags;
-	NCR5380_local_declare();
 
 	if (default_instance) {
 			local_irq_save(flags);

commit 0d31f8759109cbc1e6fc196d08e6b0e8a9e93b3f
Author: Finn Thain <fthain@telegraphics.com.au>
Date:   Thu Nov 13 12:21:28 2014 +1100

    sun3_scsi: Convert to platform device
    
    Convert sun3_scsi to platform device and eliminate scsi_register().
    
    Signed-off-by: Finn Thain <fthain@telegraphics.com.au>
    Reviewed-by: Hannes Reinecke <hare@suse.de>
    Acked-by: Geert Uytterhoeven <geert@linux-m68k.org>
    Signed-off-by: Christoph Hellwig <hch@lst.de>

diff --git a/drivers/scsi/sun3_scsi.c b/drivers/scsi/sun3_scsi.c
index bb660fe4739d..ba5169982706 100644
--- a/drivers/scsi/sun3_scsi.c
+++ b/drivers/scsi/sun3_scsi.c
@@ -23,22 +23,15 @@
  */
 
 #include <linux/types.h>
-#include <linux/stddef.h>
-#include <linux/ctype.h>
 #include <linux/delay.h>
-
 #include <linux/module.h>
-#include <linux/signal.h>
 #include <linux/ioport.h>
 #include <linux/init.h>
 #include <linux/blkdev.h>
+#include <linux/platform_device.h>
 
 #include <asm/io.h>
-
-#include <asm/sun3ints.h>
 #include <asm/dvma.h>
-#include <asm/idprom.h>
-#include <asm/machines.h>
 
 /* dma on! */
 #define REAL_DMA
@@ -59,8 +52,6 @@ extern int sun3_map_test(unsigned long, char *);
 #endif
 
 
-static irqreturn_t scsi_sun3_intr(int irq, void *dummy);
-
 static int setup_can_queue = -1;
 module_param(setup_can_queue, int, 0);
 static int setup_cmd_per_lun = -1;
@@ -89,15 +80,14 @@ static struct scsi_cmnd *sun3_dma_setup_done = NULL;
 /* minimum number of bytes to do dma on */
 #define SUN3_DMA_MINSIZE 128
 
-static volatile unsigned char *sun3_scsi_regp;
+static unsigned char *sun3_scsi_regp;
 static volatile struct sun3_dma_regs *dregs;
-#ifndef SUN3_SCSI_VME
-static struct sun3_udc_regs *udc_regs = NULL;
-#endif
+static struct sun3_udc_regs *udc_regs;
 static unsigned char *sun3_dma_orig_addr = NULL;
 static unsigned long sun3_dma_orig_count = 0;
 static int sun3_dma_active = 0;
 static unsigned long last_residual = 0;
+static struct Scsi_Host *default_instance;
 
 /*
  * NCR 5380 register access functions
@@ -105,12 +95,12 @@ static unsigned long last_residual = 0;
 
 static inline unsigned char sun3scsi_read(int reg)
 {
-	return( sun3_scsi_regp[reg] );
+	return in_8(sun3_scsi_regp + reg);
 }
 
 static inline void sun3scsi_write(int reg, int value)
 {
-	sun3_scsi_regp[reg] = value;
+	out_8(sun3_scsi_regp + reg, value);
 }
 
 #ifndef SUN3_SCSI_VME
@@ -137,192 +127,7 @@ static inline void sun3_udc_write(unsigned short val, unsigned char reg)
 }
 #endif
 
-/*
- * XXX: status debug
- */
-static struct Scsi_Host *default_instance;
-
-/*
- * Function : int sun3scsi_detect(struct scsi_host_template * tpnt)
- *
- * Purpose : initializes mac NCR5380 driver based on the
- *	command line / compile time port and irq definitions.
- *
- * Inputs : tpnt - template for this SCSI adapter.
- *
- * Returns : 1 if a host adapter was found, 0 if not.
- *
- */
- 
-static int __init sun3scsi_detect(struct scsi_host_template *tpnt)
-{
-	unsigned long ioaddr, irq;
-	static int called = 0;
-	struct Scsi_Host *instance;
-#ifdef SUN3_SCSI_VME
-	int i;
-	unsigned long addrs[3] = { IOBASE_SUN3_VMESCSI,
-				   IOBASE_SUN3_VMESCSI + 0x4000,
-				   0 };
-	unsigned long vecs[3] = { SUN3_VEC_VMESCSI0,
-				  SUN3_VEC_VMESCSI1,
-				  0 };
-#endif
-
-	/* check that this machine has an onboard 5380 */
-	switch(idprom->id_machtype) {
-#ifdef SUN3_SCSI_VME
-	case SM_SUN3|SM_3_160:
-	case SM_SUN3|SM_3_260:
-		break;
-#else
-	case SM_SUN3|SM_3_50:
-	case SM_SUN3|SM_3_60:
-		break;
-#endif
-
-	default:
-		return 0;
-	}
-
-	if(called)
-		return 0;
-
-#ifdef SUN3_SCSI_VME
-	tpnt->proc_name = "Sun3 5380 VME SCSI";
-#else
-	tpnt->proc_name = "Sun3 5380 SCSI";
-#endif
-
-	/* setup variables */
-	if (setup_can_queue > 0)
-		tpnt->can_queue = setup_can_queue;
-	if (setup_cmd_per_lun > 0)
-		tpnt->cmd_per_lun = setup_cmd_per_lun;
-	if (setup_sg_tablesize >= 0)
-		tpnt->sg_tablesize = setup_sg_tablesize;
-
-	if (setup_hostid >= 0)
-		tpnt->this_id = setup_hostid;
-	else {
-		/* use 7 as default */
-		tpnt->this_id = 7;
-	}
-
-#ifdef SUN3_SCSI_VME
-	ioaddr = 0;
-	for (i = 0; addrs[i] != 0; i++) {
-		unsigned char x;
-
-		ioaddr = (unsigned long)sun3_ioremap(addrs[i], PAGE_SIZE,
-						     SUN3_PAGE_TYPE_VME16);
-		irq = vecs[i];
-		sun3_scsi_regp = (unsigned char *)ioaddr;
-
-		dregs = (struct sun3_dma_regs *)(((unsigned char *)ioaddr) + 8);
-
-		if (sun3_map_test((unsigned long)dregs, &x)) {
-			unsigned short oldcsr;
-
-			oldcsr = dregs->csr;
-			dregs->csr = 0;
-			udelay(SUN3_DMA_DELAY);
-			if (dregs->csr == 0x1400)
-				break;
-
-			dregs->csr = oldcsr;
-		}
-
-		iounmap((void *)ioaddr);
-		ioaddr = 0;
-	}
-
-	if (!ioaddr)
-		return 0;
-#else
-	irq = IRQ_SUN3_SCSI;
-	ioaddr = (unsigned long)ioremap(IOBASE_SUN3_SCSI, PAGE_SIZE);
-	sun3_scsi_regp = (unsigned char *)ioaddr;
-
-	dregs = (struct sun3_dma_regs *)(((unsigned char *)ioaddr) + 8);
-
-	if((udc_regs = dvma_malloc(sizeof(struct sun3_udc_regs)))
-	   == NULL) {
-	     printk("SUN3 Scsi couldn't allocate DVMA memory!\n");
-	     return 0;
-	}
-#endif
-#ifdef SUPPORT_TAGS
-	if (setup_use_tagged_queuing < 0)
-		setup_use_tagged_queuing = 1;
-#endif
-
-	instance = scsi_register (tpnt, sizeof(struct NCR5380_hostdata));
-	if(instance == NULL)
-		return 0;
-		
-	default_instance = instance;
-
-        instance->io_port = (unsigned long) ioaddr;
-	instance->irq = irq;
-
-	NCR5380_init(instance, 0);
-
-	instance->n_io_port = 32;
-
-	if (request_irq(instance->irq, scsi_sun3_intr,
-			     0, "Sun3SCSI-5380", instance)) {
-#ifndef REAL_DMA
-		printk("scsi%d: IRQ%d not free, interrupts disabled\n",
-		       instance->host_no, instance->irq);
-		instance->irq = NO_IRQ;
-#else
-		printk("scsi%d: IRQ%d not free, bailing out\n",
-		       instance->host_no, instance->irq);
-		return 0;
-#endif
-	}
-	
-	dregs->csr = 0;
-	udelay(SUN3_DMA_DELAY);
-	dregs->csr = CSR_SCSI | CSR_FIFO | CSR_INTR;
-	udelay(SUN3_DMA_DELAY);
-	dregs->fifo_count = 0;
-#ifdef SUN3_SCSI_VME
-	dregs->fifo_count_hi = 0;
-	dregs->dma_addr_hi = 0;
-	dregs->dma_addr_lo = 0;
-	dregs->dma_count_hi = 0;
-	dregs->dma_count_lo = 0;
-
-	dregs->ivect = VME_DATA24 | (instance->irq & 0xff);
-#endif
-
-	called = 1;
-
-#ifdef RESET_BOOT
-	sun3_scsi_reset_boot(instance);
-#endif
-
-	return 1;
-}
-
-static int sun3scsi_release(struct Scsi_Host *shpnt)
-{
-	if (shpnt->irq != NO_IRQ)
-		free_irq(shpnt->irq, shpnt);
-
-	iounmap((void *)sun3_scsi_regp);
-
-	NCR5380_exit(shpnt);
-	return 0;
-}
-
 #ifdef RESET_BOOT
-/*
- * Our 'bus reset on boot' function
- */
-
 static void sun3_scsi_reset_boot(struct Scsi_Host *instance)
 {
 	unsigned long end;
@@ -671,11 +476,21 @@ static int sun3scsi_dma_finish(int write_flag)
 	
 #include "sun3_NCR5380.c"
 
-static struct scsi_host_template driver_template = {
+#ifdef SUN3_SCSI_VME
+#define SUN3_SCSI_NAME          "Sun3 NCR5380 VME SCSI"
+#define DRV_MODULE_NAME         "sun3_scsi_vme"
+#else
+#define SUN3_SCSI_NAME          "Sun3 NCR5380 SCSI"
+#define DRV_MODULE_NAME         "sun3_scsi"
+#endif
+
+#define PFX                     DRV_MODULE_NAME ": "
+
+static struct scsi_host_template sun3_scsi_template = {
+	.module			= THIS_MODULE,
+	.proc_name		= DRV_MODULE_NAME,
 	.show_info		= sun3scsi_show_info,
 	.name			= SUN3_SCSI_NAME,
-	.detect			= sun3scsi_detect,
-	.release		= sun3scsi_release,
 	.info			= sun3scsi_info,
 	.queuecommand		= sun3scsi_queue_command,
 	.eh_abort_handler      	= sun3scsi_abort,
@@ -687,7 +502,172 @@ static struct scsi_host_template driver_template = {
 	.use_clustering		= DISABLE_CLUSTERING
 };
 
+static int __init sun3_scsi_probe(struct platform_device *pdev)
+{
+	struct Scsi_Host *instance;
+	int error;
+	struct resource *irq, *mem;
+	unsigned char *ioaddr;
+#ifdef SUN3_SCSI_VME
+	int i;
+#endif
+
+	if (setup_can_queue > 0)
+		sun3_scsi_template.can_queue = setup_can_queue;
+	if (setup_cmd_per_lun > 0)
+		sun3_scsi_template.cmd_per_lun = setup_cmd_per_lun;
+	if (setup_sg_tablesize >= 0)
+		sun3_scsi_template.sg_tablesize = setup_sg_tablesize;
+	if (setup_hostid >= 0)
+		sun3_scsi_template.this_id = setup_hostid & 7;
+
+#ifdef SUPPORT_TAGS
+	if (setup_use_tagged_queuing < 0)
+		setup_use_tagged_queuing = 1;
+#endif
+
+#ifdef SUN3_SCSI_VME
+	ioaddr = NULL;
+	for (i = 0; i < 2; i++) {
+		unsigned char x;
+
+		irq = platform_get_resource(pdev, IORESOURCE_IRQ, i);
+		mem = platform_get_resource(pdev, IORESOURCE_MEM, i);
+		if (!irq || !mem)
+			break;
+
+		ioaddr = sun3_ioremap(mem->start, resource_size(mem),
+		                      SUN3_PAGE_TYPE_VME16);
+		dregs = (struct sun3_dma_regs *)(ioaddr + 8);
+
+		if (sun3_map_test((unsigned long)dregs, &x)) {
+			unsigned short oldcsr;
+
+			oldcsr = dregs->csr;
+			dregs->csr = 0;
+			udelay(SUN3_DMA_DELAY);
+			if (dregs->csr == 0x1400)
+				break;
+
+			dregs->csr = oldcsr;
+		}
+
+		iounmap(ioaddr);
+		ioaddr = NULL;
+	}
+	if (!ioaddr)
+		return -ENODEV;
+#else
+	irq = platform_get_resource(pdev, IORESOURCE_IRQ, 0);
+	mem = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (!irq || !mem)
+		return -ENODEV;
+
+	ioaddr = ioremap(mem->start, resource_size(mem));
+	dregs = (struct sun3_dma_regs *)(ioaddr + 8);
+
+	udc_regs = dvma_malloc(sizeof(struct sun3_udc_regs));
+	if (!udc_regs) {
+		pr_err(PFX "couldn't allocate DVMA memory!\n");
+		iounmap(ioaddr);
+		return -ENOMEM;
+	}
+#endif
+
+	sun3_scsi_regp = ioaddr;
+
+	instance = scsi_host_alloc(&sun3_scsi_template,
+	                           sizeof(struct NCR5380_hostdata));
+	if (!instance) {
+		error = -ENOMEM;
+		goto fail_alloc;
+	}
+	default_instance = instance;
+
+	instance->io_port = (unsigned long)ioaddr;
+	instance->irq = irq->start;
+
+	NCR5380_init(instance, 0);
+
+	error = request_irq(instance->irq, scsi_sun3_intr, 0,
+	                    "NCR5380", instance);
+	if (error) {
+#ifdef REAL_DMA
+		pr_err(PFX "scsi%d: IRQ %d not free, bailing out\n",
+		       instance->host_no, instance->irq);
+		goto fail_irq;
+#else
+		pr_warn(PFX "scsi%d: IRQ %d not free, interrupts disabled\n",
+		        instance->host_no, instance->irq);
+		instance->irq = NO_IRQ;
+#endif
+	}
+
+	dregs->csr = 0;
+	udelay(SUN3_DMA_DELAY);
+	dregs->csr = CSR_SCSI | CSR_FIFO | CSR_INTR;
+	udelay(SUN3_DMA_DELAY);
+	dregs->fifo_count = 0;
+#ifdef SUN3_SCSI_VME
+	dregs->fifo_count_hi = 0;
+	dregs->dma_addr_hi = 0;
+	dregs->dma_addr_lo = 0;
+	dregs->dma_count_hi = 0;
+	dregs->dma_count_lo = 0;
+
+	dregs->ivect = VME_DATA24 | (instance->irq & 0xff);
+#endif
+
+#ifdef RESET_BOOT
+	sun3_scsi_reset_boot(instance);
+#endif
+
+	error = scsi_add_host(instance, NULL);
+	if (error)
+		goto fail_host;
+
+	platform_set_drvdata(pdev, instance);
+
+	scsi_scan_host(instance);
+	return 0;
+
+fail_host:
+	if (instance->irq != NO_IRQ)
+		free_irq(instance->irq, instance);
+fail_irq:
+	NCR5380_exit(instance);
+	scsi_host_put(instance);
+fail_alloc:
+	if (udc_regs)
+		dvma_free(udc_regs);
+	iounmap(sun3_scsi_regp);
+	return error;
+}
+
+static int __exit sun3_scsi_remove(struct platform_device *pdev)
+{
+	struct Scsi_Host *instance = platform_get_drvdata(pdev);
+
+	scsi_remove_host(instance);
+	if (instance->irq != NO_IRQ)
+		free_irq(instance->irq, instance);
+	NCR5380_exit(instance);
+	scsi_host_put(instance);
+	if (udc_regs)
+		dvma_free(udc_regs);
+	iounmap(sun3_scsi_regp);
+	return 0;
+}
+
+static struct platform_driver sun3_scsi_driver = {
+	.remove = __exit_p(sun3_scsi_remove),
+	.driver = {
+		.name	= DRV_MODULE_NAME,
+		.owner	= THIS_MODULE,
+	},
+};
 
-#include "scsi_module.c"
+module_platform_driver_probe(sun3_scsi_driver, sun3_scsi_probe);
 
+MODULE_ALIAS("platform:" DRV_MODULE_NAME);
 MODULE_LICENSE("GPL");

commit 710ddd0d50d22b40e3b644ea35966489ad178978
Author: Finn Thain <fthain@telegraphics.com.au>
Date:   Wed Nov 12 16:12:02 2014 +1100

    ncr5380: Drop legacy scsi.h include
    
    Convert Scsi_Cmnd to struct scsi_cmnd and drop the #include "scsi.h".
    The sun3_NCR5380.c core driver already uses struct scsi_cmnd so converting
    the other core drivers reduces the diff which makes them easier to unify.
    
    Signed-off-by: Finn Thain <fthain@telegraphics.com.au>
    Reviewed-by: Hannes Reinecke <hare@suse.de>
    Tested-by: Michael Schmitz <schmitzmic@gmail.com>
    Signed-off-by: Christoph Hellwig <hch@lst.de>

diff --git a/drivers/scsi/sun3_scsi.c b/drivers/scsi/sun3_scsi.c
index 19e9808be8d8..bb660fe4739d 100644
--- a/drivers/scsi/sun3_scsi.c
+++ b/drivers/scsi/sun3_scsi.c
@@ -43,7 +43,6 @@
 /* dma on! */
 #define REAL_DMA
 
-#include "scsi.h"
 #include <scsi/scsi_host.h>
 #include "sun3_scsi.h"
 #include "NCR5380.h"

commit 96068e6b4d86a397f50ae401723f315110874e1a
Author: Finn Thain <fthain@telegraphics.com.au>
Date:   Wed Nov 12 16:12:01 2014 +1100

    ncr5380: Remove *_RELEASE macros
    
    The *_RELEASE macros don't tell me anything. In some cases the version in
    the macro contradicts the version in the comments. Anyway, the Linux kernel
    version is sufficient information. Remove these macros to improve readability.
    
    Signed-off-by: Finn Thain <fthain@telegraphics.com.au>
    Reviewed-by: Hannes Reinecke <hare@suse.de>
    Tested-by: Michael Schmitz <schmitzmic@gmail.com>
    Signed-off-by: Christoph Hellwig <hch@lst.de>

diff --git a/drivers/scsi/sun3_scsi.c b/drivers/scsi/sun3_scsi.c
index 12a991b19e58..19e9808be8d8 100644
--- a/drivers/scsi/sun3_scsi.c
+++ b/drivers/scsi/sun3_scsi.c
@@ -20,8 +20,6 @@
  * Generic Generic NCR5380 driver
  *
  * Copyright 1995, Russell King
- *
- * ALPHA RELEASE 1.
  */
 
 #include <linux/types.h>

commit d572f65fdf78a6dcb55b86ad8684f88830bf2e08
Author: Finn Thain <fthain@telegraphics.com.au>
Date:   Wed Nov 12 16:12:00 2014 +1100

    ncr5380: Remove pointless compiler command line override macros
    
    Compile-time override of scsi host defaults is pointless for drivers that
    provide module parameters and __setup options for that. Too many macros make
    the code hard to read so remove them.
    
    Signed-off-by: Finn Thain <fthain@telegraphics.com.au>
    Reviewed-by: Hannes Reinecke <hare@suse.de>
    Tested-by: Michael Schmitz <schmitzmic@gmail.com>
    Signed-off-by: Christoph Hellwig <hch@lst.de>

diff --git a/drivers/scsi/sun3_scsi.c b/drivers/scsi/sun3_scsi.c
index 9bae5f6122a7..12a991b19e58 100644
--- a/drivers/scsi/sun3_scsi.c
+++ b/drivers/scsi/sun3_scsi.c
@@ -198,12 +198,12 @@ static int __init sun3scsi_detect(struct scsi_host_template *tpnt)
 #endif
 
 	/* setup variables */
-	tpnt->can_queue =
-		(setup_can_queue > 0) ? setup_can_queue : CAN_QUEUE;
-	tpnt->cmd_per_lun =
-		(setup_cmd_per_lun > 0) ? setup_cmd_per_lun : CMD_PER_LUN;
-	tpnt->sg_tablesize = 
-		(setup_sg_tablesize >= 0) ? setup_sg_tablesize : SG_TABLESIZE;
+	if (setup_can_queue > 0)
+		tpnt->can_queue = setup_can_queue;
+	if (setup_cmd_per_lun > 0)
+		tpnt->cmd_per_lun = setup_cmd_per_lun;
+	if (setup_sg_tablesize >= 0)
+		tpnt->sg_tablesize = setup_sg_tablesize;
 
 	if (setup_hostid >= 0)
 		tpnt->this_id = setup_hostid;
@@ -257,7 +257,7 @@ static int __init sun3scsi_detect(struct scsi_host_template *tpnt)
 #endif
 #ifdef SUPPORT_TAGS
 	if (setup_use_tagged_queuing < 0)
-		setup_use_tagged_queuing = USE_TAGGED_QUEUING;
+		setup_use_tagged_queuing = 1;
 #endif
 
 	instance = scsi_register (tpnt, sizeof(struct NCR5380_hostdata));
@@ -683,10 +683,10 @@ static struct scsi_host_template driver_template = {
 	.queuecommand		= sun3scsi_queue_command,
 	.eh_abort_handler      	= sun3scsi_abort,
 	.eh_bus_reset_handler  	= sun3scsi_bus_reset,
-	.can_queue		= CAN_QUEUE,
+	.can_queue		= 16,
 	.this_id		= 7,
-	.sg_tablesize		= SG_TABLESIZE,
-	.cmd_per_lun		= CMD_PER_LUN,
+	.sg_tablesize		= SG_NONE,
+	.cmd_per_lun		= 2,
 	.use_clustering		= DISABLE_CLUSTERING
 };
 

commit 8c32513bd395dc5d382e4883097482567cf8bbc5
Author: Finn Thain <fthain@telegraphics.com.au>
Date:   Wed Nov 12 16:11:58 2014 +1100

    ncr5380: Cleanup host info() methods
    
    If the host->info() method is not set, then host->name is used by default.
    For atari_scsi, that is exactly the same text. So remove the redundant
    info() method. Keep sun3_scsi.c in line with atari_scsi.
    
    Some NCR5380 drivers return an empty string from the info() method
    (arm/cumana_1.c arm/oak.c mac_scsi.c) while other drivers use the default
    (dmx3191d dtc.c g_NCR5380.c pas16.c t128.c).
    
    Implement a common info() method to replace a lot of duplicated code which
    the various drivers use to announce the same information.
    
    This replaces most of the (deprecated) show_info() output and all of the
    NCR5380_print_info() output. This also eliminates a bunch of code in
    g_NCR5380 which just duplicates functionality in the core driver.
    
    Signed-off-by: Finn Thain <fthain@telegraphics.com.au>
    Reviewed-by: Hannes Reinecke <hare@suse.de>
    Tested-by: Michael Schmitz <schmitzmic@gmail.com>
    Signed-off-by: Christoph Hellwig <hch@lst.de>

diff --git a/drivers/scsi/sun3_scsi.c b/drivers/scsi/sun3_scsi.c
index 3e6386252953..9bae5f6122a7 100644
--- a/drivers/scsi/sun3_scsi.c
+++ b/drivers/scsi/sun3_scsi.c
@@ -286,19 +286,6 @@ static int __init sun3scsi_detect(struct scsi_host_template *tpnt)
 #endif
 	}
 	
-	pr_info("scsi%d: %s at port %lX irq", instance->host_no,
-		tpnt->proc_name, instance->io_port);
-	if (instance->irq == NO_IRQ)
-		printk ("s disabled");
-	else
-		printk (" %d", instance->irq);
-	printk(" options CAN_QUEUE=%d CMD_PER_LUN=%d release=%d",
-	       instance->can_queue, instance->cmd_per_lun,
-	       SUN3SCSI_PUBLIC_RELEASE);
-	printk("\nscsi%d:", instance->host_no);
-	NCR5380_print_options(instance);
-	printk("\n");
-
 	dregs->csr = 0;
 	udelay(SUN3_DMA_DELAY);
 	dregs->csr = CSR_SCSI | CSR_FIFO | CSR_INTR;
@@ -380,11 +367,6 @@ static void sun3_scsi_reset_boot(struct Scsi_Host *instance)
 }
 #endif
 
-static const char *sun3scsi_info(struct Scsi_Host *spnt)
-{
-    return "";
-}
-
 // safe bits for the CSR
 #define CSR_GOOD 0x060f
 

commit 22f5f10d2dadc50bf26a482b782a5e04f6e9b362
Author: Finn Thain <fthain@telegraphics.com.au>
Date:   Wed Nov 12 16:11:56 2014 +1100

    ncr5380: Fix SCSI_IRQ_NONE bugs
    
    Oak scsi doesn't use any IRQ, but it sets irq = IRQ_NONE rather than
    SCSI_IRQ_NONE. Problem is, the core NCR5380 driver expects SCSI_IRQ_NONE
    if it is to issue IDENTIFY commands that prevent target disconnection.
    And, as Geert points out, IRQ_NONE is part of enum irqreturn.
    
    Other drivers, when they can't get an IRQ or can't use one, will set
    host->irq = SCSI_IRQ_NONE (that is, 255). But when they exit they will
    attempt to free IRQ 255 which was never requested.
    
    Fix these bugs by using NO_IRQ in place of SCSI_IRQ_NONE and IRQ_NONE.
    That means IRQ 0 is no longer probed by ISA drivers but I don't think
    this matters.
    
    Setting IRQ = 255 for these ISA drivers is understood to mean no IRQ.
    This remains supported so as to avoid breaking existing ISA setups (which
    can be difficult to get working) and because existing documentation
    (SANE, TLDP etc) describes this usage for the ISA NCR5380 driver options.
    
    Signed-off-by: Finn Thain <fthain@telegraphics.com.au>
    Reviewed-by: Hannes Reinecke <hare@suse.de>
    Tested-by: Michael Schmitz <schmitzmic@gmail.com>
    Signed-off-by: Christoph Hellwig <hch@lst.de>

diff --git a/drivers/scsi/sun3_scsi.c b/drivers/scsi/sun3_scsi.c
index 26b95dcb5e48..3e6386252953 100644
--- a/drivers/scsi/sun3_scsi.c
+++ b/drivers/scsi/sun3_scsi.c
@@ -278,7 +278,7 @@ static int __init sun3scsi_detect(struct scsi_host_template *tpnt)
 #ifndef REAL_DMA
 		printk("scsi%d: IRQ%d not free, interrupts disabled\n",
 		       instance->host_no, instance->irq);
-		instance->irq = SCSI_IRQ_NONE;
+		instance->irq = NO_IRQ;
 #else
 		printk("scsi%d: IRQ%d not free, bailing out\n",
 		       instance->host_no, instance->irq);
@@ -288,7 +288,7 @@ static int __init sun3scsi_detect(struct scsi_host_template *tpnt)
 	
 	pr_info("scsi%d: %s at port %lX irq", instance->host_no,
 		tpnt->proc_name, instance->io_port);
-	if (instance->irq == SCSI_IRQ_NONE)
+	if (instance->irq == NO_IRQ)
 		printk ("s disabled");
 	else
 		printk (" %d", instance->irq);
@@ -325,7 +325,7 @@ static int __init sun3scsi_detect(struct scsi_host_template *tpnt)
 
 static int sun3scsi_release(struct Scsi_Host *shpnt)
 {
-	if (shpnt->irq != SCSI_IRQ_NONE)
+	if (shpnt->irq != NO_IRQ)
 		free_irq(shpnt->irq, shpnt);
 
 	iounmap((void *)sun3_scsi_regp);

commit 3f9e986e2f1df8fa69ffe213098c1ee98f1c9584
Author: Finn Thain <fthain@telegraphics.com.au>
Date:   Wed Nov 12 16:11:55 2014 +1100

    ncr5380: Remove duplicate comments
    
    The LIMIT_TRANSFERSIZE, PSEUDO_DMA, PARITY and UNSAFE options are all
    documented in the core drivers where they are used. The same goes for the
    chip databook reference. Remove the duplicate comments.
    
    Signed-off-by: Finn Thain <fthain@telegraphics.com.au>
    Reviewed-by: Hannes Reinecke <hare@suse.de>
    Signed-off-by: Christoph Hellwig <hch@lst.de>

diff --git a/drivers/scsi/sun3_scsi.c b/drivers/scsi/sun3_scsi.c
index a5e58a7373be..26b95dcb5e48 100644
--- a/drivers/scsi/sun3_scsi.c
+++ b/drivers/scsi/sun3_scsi.c
@@ -22,27 +22,6 @@
  * Copyright 1995, Russell King
  *
  * ALPHA RELEASE 1.
- *
- * For more information, please consult
- *
- * NCR 5380 Family
- * SCSI Protocol Controller
- * Databook
- *
- * NCR Microelectronics
- * 1635 Aeroplaza Drive
- * Colorado Springs, CO 80916
- * 1+ (719) 578-3400
- * 1+ (800) 334-5454
- */
-
-
-/*
- * This is from mac_scsi.h, but hey, maybe this is useful for Sun3 too! :)
- *
- * Options :
- *
- * PARITY - enable parity checking.  Not supported.
  */
 
 #include <linux/types.h>

commit 997acab7d593913eaa0606ff257079efcfcb146d
Author: Finn Thain <fthain@telegraphics.com.au>
Date:   Wed Nov 12 16:11:54 2014 +1100

    ncr5380: Remove redundant AUTOSENSE macro
    
    Every NCR5380 driver sets AUTOSENSE so it need not be optional (and the
    mid-layer expects it). Remove this redundant macro to improve readability.
    
    Signed-off-by: Finn Thain <fthain@telegraphics.com.au>
    Reviewed-by: Hannes Reinecke <hare@suse.de>
    Tested-by: Michael Schmitz <schmitzmic@gmail.com>
    Signed-off-by: Christoph Hellwig <hch@lst.de>

diff --git a/drivers/scsi/sun3_scsi.c b/drivers/scsi/sun3_scsi.c
index 30353f6b599c..a5e58a7373be 100644
--- a/drivers/scsi/sun3_scsi.c
+++ b/drivers/scsi/sun3_scsi.c
@@ -45,8 +45,6 @@
  * PARITY - enable parity checking.  Not supported.
  */
 
-#define AUTOSENSE
-
 #include <linux/types.h>
 #include <linux/stddef.h>
 #include <linux/ctype.h>

commit ed8b9e7f1827ebae902e868866438d1bcdbef0a2
Author: Finn Thain <fthain@telegraphics.com.au>
Date:   Wed Nov 12 16:11:51 2014 +1100

    ncr5380: Remove useless prototypes
    
    Add missing static qualifiers and remove the now pointless prototypes. The
    NCR5380_* prototypes are all declared in NCR5380.h and renamed using macros.
    Further declarations are redundant (some are completely unused). Remove
    them.
    
    Signed-off-by: Finn Thain <fthain@telegraphics.com.au>
    Reviewed-by: Hannes Reinecke <hare@suse.de>
    Tested-by: Michael Schmitz <schmitzmic@gmail.com>
    Signed-off-by: Christoph Hellwig <hch@lst.de>

diff --git a/drivers/scsi/sun3_scsi.c b/drivers/scsi/sun3_scsi.c
index a6fe27b21dba..30353f6b599c 100644
--- a/drivers/scsi/sun3_scsi.c
+++ b/drivers/scsi/sun3_scsi.c
@@ -86,8 +86,6 @@ extern int sun3_map_test(unsigned long, char *);
 
 
 static irqreturn_t scsi_sun3_intr(int irq, void *dummy);
-static inline unsigned char sun3scsi_read(int reg);
-static inline void sun3scsi_write(int reg, int value);
 
 static int setup_can_queue = -1;
 module_param(setup_can_queue, int, 0);
@@ -348,7 +346,7 @@ static int __init sun3scsi_detect(struct scsi_host_template *tpnt)
 	return 1;
 }
 
-int sun3scsi_release (struct Scsi_Host *shpnt)
+static int sun3scsi_release(struct Scsi_Host *shpnt)
 {
 	if (shpnt->irq != SCSI_IRQ_NONE)
 		free_irq(shpnt->irq, shpnt);

commit 48f16c9bef8ee6b699ab8e7c5c55920ddd1c7e8f
Author: Finn Thain <fthain@telegraphics.com.au>
Date:   Wed Nov 12 16:11:50 2014 +1100

    ncr5380: Remove unused macros
    
    Some macros are never evaluated (i.e. FOO, USLEEP, SCSI2 and USE_WRAPPER;
    and in some drivers, NCR5380_intr and NCR5380_proc_info). DRIVER_SETUP
    serves no purpose anymore. Remove these macro definitions.
    
    Signed-off-by: Finn Thain <fthain@telegraphics.com.au>
    Reviewed-by: Hannes Reinecke <hare@suse.de>
    Tested-by: Michael Schmitz <schmitzmic@gmail.com>
    Signed-off-by: Christoph Hellwig <hch@lst.de>

diff --git a/drivers/scsi/sun3_scsi.c b/drivers/scsi/sun3_scsi.c
index cd4bf3a5faaa..a6fe27b21dba 100644
--- a/drivers/scsi/sun3_scsi.c
+++ b/drivers/scsi/sun3_scsi.c
@@ -43,10 +43,6 @@
  * Options :
  *
  * PARITY - enable parity checking.  Not supported.
- *
- * SCSI2 - enable support for SCSI-II tagged queueing.  Untested.
- *
- * USLEEP - enable support for devices that don't disconnect.  Untested.
  */
 
 #define AUTOSENSE
@@ -79,18 +75,7 @@
 
 extern int sun3_map_test(unsigned long, char *);
 
-#define USE_WRAPPER
 /*#define RESET_BOOT */
-#define DRIVER_SETUP
-
-/*
- * BUG can be used to trigger a strange code-size related hang on 2.1 kernels
- */
-#ifdef BUG
-#undef RESET_BOOT
-#undef DRIVER_SETUP
-#endif
-
 /* #define SUPPORT_TAGS */
 
 #ifdef SUN3_SCSI_VME

commit acfc8cad9135444fdad5385cd9f795fab469a699
Author: Finn Thain <fthain@telegraphics.com.au>
Date:   Wed Nov 12 16:11:48 2014 +1100

    ncr5380: Remove unused hostdata fields
    
    Remove unused fields from hostdata structs declared with the
    NCR5380_implementation_fields macro.
    
    Signed-off-by: Finn Thain <fthain@telegraphics.com.au>
    Reviewed-by: Hannes Reinecke <hare@suse.de>
    Signed-off-by: Christoph Hellwig <hch@lst.de>

diff --git a/drivers/scsi/sun3_scsi.c b/drivers/scsi/sun3_scsi.c
index 9707b7494a89..cd4bf3a5faaa 100644
--- a/drivers/scsi/sun3_scsi.c
+++ b/drivers/scsi/sun3_scsi.c
@@ -313,8 +313,6 @@ static int __init sun3scsi_detect(struct scsi_host_template *tpnt)
 
 	instance->n_io_port = 32;
 
-        ((struct NCR5380_hostdata *)instance->hostdata)->ctrl = 0;
-
 	if (request_irq(instance->irq, scsi_sun3_intr,
 			     0, "Sun3SCSI-5380", instance)) {
 #ifndef REAL_DMA

commit 757f5bad2b748dca6f82e660875320d156485ea5
Author: Finn Thain <fthain@telegraphics.com.au>
Date:   Tue Mar 18 11:42:24 2014 +1100

    scsi/NCR5380: merge sun3_scsi_vme.c into sun3_scsi.c
    
    The sun3 drivers suffer from a whole bunch of duplicated code. Fix this
    by following the g_NCR5380_mmio example. (Notionally, sun3_scsi relates to
    sun3_scsi_vme in the same way that g_NCR5380 relates to g_NCR5380_mmio.)
    
    Dead code is also removed: we now have working debug macros so
    SUN3_SCSI_DEBUG is undesirable. Dead code within #ifdef OLD_DMA is also
    dropped, consistent with sun3_scsi_vme.c.
    
    Signed-off-by: Finn Thain <fthain@telegraphics.com.au>
    Acked-by: Sam Creasey <sammy@sammy.net>
    Signed-off-by: Christoph Hellwig <hch@lst.de>

diff --git a/drivers/scsi/sun3_scsi.c b/drivers/scsi/sun3_scsi.c
index ac9c29b55a33..9707b7494a89 100644
--- a/drivers/scsi/sun3_scsi.c
+++ b/drivers/scsi/sun3_scsi.c
@@ -3,6 +3,10 @@
  *
  * Sun3 DMA routines added by Sam Creasey (sammy@sammy.net)
  *
+ * VME support added by Sam Creasey
+ *
+ * TODO: modify this driver to support multiple Sun3 SCSI VME boards
+ *
  * Adapted from mac_scsinew.c:
  */
 /*
@@ -73,7 +77,7 @@
 #include "sun3_scsi.h"
 #include "NCR5380.h"
 
-/* #define OLDDMA */
+extern int sun3_map_test(unsigned long, char *);
 
 #define USE_WRAPPER
 /*#define RESET_BOOT */
@@ -89,7 +93,11 @@
 
 /* #define SUPPORT_TAGS */
 
+#ifdef SUN3_SCSI_VME
+#define ENABLE_IRQ()
+#else
 #define	ENABLE_IRQ()	enable_irq( IRQ_SUN3_SCSI ); 
+#endif
 
 
 static irqreturn_t scsi_sun3_intr(int irq, void *dummy);
@@ -126,10 +134,9 @@ static struct scsi_cmnd *sun3_dma_setup_done = NULL;
 
 static volatile unsigned char *sun3_scsi_regp;
 static volatile struct sun3_dma_regs *dregs;
-#ifdef OLDDMA
-static unsigned char *dmabuf = NULL; /* dma memory buffer */
-#endif
+#ifndef SUN3_SCSI_VME
 static struct sun3_udc_regs *udc_regs = NULL;
+#endif
 static unsigned char *sun3_dma_orig_addr = NULL;
 static unsigned long sun3_dma_orig_count = 0;
 static int sun3_dma_active = 0;
@@ -149,6 +156,7 @@ static inline void sun3scsi_write(int reg, int value)
 	sun3_scsi_regp[reg] = value;
 }
 
+#ifndef SUN3_SCSI_VME
 /* dma controller register access functions */
 
 static inline unsigned short sun3_udc_read(unsigned char reg)
@@ -170,6 +178,7 @@ static inline void sun3_udc_write(unsigned short val, unsigned char reg)
 	dregs->udc_data = val;
 	udelay(SUN3_DMA_DELAY);
 }
+#endif
 
 /*
  * XXX: status debug
@@ -188,17 +197,32 @@ static struct Scsi_Host *default_instance;
  *
  */
  
-int __init sun3scsi_detect(struct scsi_host_template * tpnt)
+static int __init sun3scsi_detect(struct scsi_host_template *tpnt)
 {
-	unsigned long ioaddr;
+	unsigned long ioaddr, irq;
 	static int called = 0;
 	struct Scsi_Host *instance;
+#ifdef SUN3_SCSI_VME
+	int i;
+	unsigned long addrs[3] = { IOBASE_SUN3_VMESCSI,
+				   IOBASE_SUN3_VMESCSI + 0x4000,
+				   0 };
+	unsigned long vecs[3] = { SUN3_VEC_VMESCSI0,
+				  SUN3_VEC_VMESCSI1,
+				  0 };
+#endif
 
 	/* check that this machine has an onboard 5380 */
 	switch(idprom->id_machtype) {
+#ifdef SUN3_SCSI_VME
+	case SM_SUN3|SM_3_160:
+	case SM_SUN3|SM_3_260:
+		break;
+#else
 	case SM_SUN3|SM_3_50:
 	case SM_SUN3|SM_3_60:
 		break;
+#endif
 
 	default:
 		return 0;
@@ -207,7 +231,11 @@ int __init sun3scsi_detect(struct scsi_host_template * tpnt)
 	if(called)
 		return 0;
 
+#ifdef SUN3_SCSI_VME
+	tpnt->proc_name = "Sun3 5380 VME SCSI";
+#else
 	tpnt->proc_name = "Sun3 5380 SCSI";
+#endif
 
 	/* setup variables */
 	tpnt->can_queue =
@@ -224,6 +252,38 @@ int __init sun3scsi_detect(struct scsi_host_template * tpnt)
 		tpnt->this_id = 7;
 	}
 
+#ifdef SUN3_SCSI_VME
+	ioaddr = 0;
+	for (i = 0; addrs[i] != 0; i++) {
+		unsigned char x;
+
+		ioaddr = (unsigned long)sun3_ioremap(addrs[i], PAGE_SIZE,
+						     SUN3_PAGE_TYPE_VME16);
+		irq = vecs[i];
+		sun3_scsi_regp = (unsigned char *)ioaddr;
+
+		dregs = (struct sun3_dma_regs *)(((unsigned char *)ioaddr) + 8);
+
+		if (sun3_map_test((unsigned long)dregs, &x)) {
+			unsigned short oldcsr;
+
+			oldcsr = dregs->csr;
+			dregs->csr = 0;
+			udelay(SUN3_DMA_DELAY);
+			if (dregs->csr == 0x1400)
+				break;
+
+			dregs->csr = oldcsr;
+		}
+
+		iounmap((void *)ioaddr);
+		ioaddr = 0;
+	}
+
+	if (!ioaddr)
+		return 0;
+#else
+	irq = IRQ_SUN3_SCSI;
 	ioaddr = (unsigned long)ioremap(IOBASE_SUN3_SCSI, PAGE_SIZE);
 	sun3_scsi_regp = (unsigned char *)ioaddr;
 
@@ -234,11 +294,6 @@ int __init sun3scsi_detect(struct scsi_host_template * tpnt)
 	     printk("SUN3 Scsi couldn't allocate DVMA memory!\n");
 	     return 0;
 	}
-#ifdef OLDDMA
-	if((dmabuf = dvma_malloc_align(SUN3_DVMA_BUFSIZE, 0x10000)) == NULL) {
-	     printk("SUN3 Scsi couldn't allocate DVMA memory!\n");
-	     return 0;
-	}
 #endif
 #ifdef SUPPORT_TAGS
 	if (setup_use_tagged_queuing < 0)
@@ -252,7 +307,7 @@ int __init sun3scsi_detect(struct scsi_host_template * tpnt)
 	default_instance = instance;
 
         instance->io_port = (unsigned long) ioaddr;
-	instance->irq = IRQ_SUN3_SCSI;
+	instance->irq = irq;
 
 	NCR5380_init(instance, 0);
 
@@ -273,7 +328,8 @@ int __init sun3scsi_detect(struct scsi_host_template * tpnt)
 #endif
 	}
 	
-	printk("scsi%d: Sun3 5380 at port %lX irq", instance->host_no, instance->io_port);
+	pr_info("scsi%d: %s at port %lX irq", instance->host_no,
+		tpnt->proc_name, instance->io_port);
 	if (instance->irq == SCSI_IRQ_NONE)
 		printk ("s disabled");
 	else
@@ -290,6 +346,15 @@ int __init sun3scsi_detect(struct scsi_host_template * tpnt)
 	dregs->csr = CSR_SCSI | CSR_FIFO | CSR_INTR;
 	udelay(SUN3_DMA_DELAY);
 	dregs->fifo_count = 0;
+#ifdef SUN3_SCSI_VME
+	dregs->fifo_count_hi = 0;
+	dregs->dma_addr_hi = 0;
+	dregs->dma_addr_lo = 0;
+	dregs->dma_count_hi = 0;
+	dregs->dma_count_lo = 0;
+
+	dregs->ivect = VME_DATA24 | (instance->irq & 0xff);
+#endif
 
 	called = 1;
 
@@ -357,7 +422,8 @@ static void sun3_scsi_reset_boot(struct Scsi_Host *instance)
 }
 #endif
 
-const char * sun3scsi_info (struct Scsi_Host *spnt) {
+static const char *sun3scsi_info(struct Scsi_Host *spnt)
+{
     return "";
 }
 
@@ -369,6 +435,10 @@ static irqreturn_t scsi_sun3_intr(int irq, void *dummy)
 	unsigned short csr = dregs->csr;
 	int handled = 0;
 
+#ifdef SUN3_SCSI_VME
+	dregs->csr &= ~CSR_DMA_ENABLE;
+#endif
+
 	if(csr & ~CSR_GOOD) {
 		if(csr & CSR_DMA_BUSERR) {
 			printk("scsi%d: bus error in dma\n", default_instance->host_no);
@@ -412,31 +482,28 @@ void sun3_sun3_debug (void)
 /* sun3scsi_dma_setup() -- initialize the dma controller for a read/write */
 static unsigned long sun3scsi_dma_setup(void *data, unsigned long count, int write_flag)
 {
-#ifdef OLDDMA
-	if(write_flag) 
-		memcpy(dmabuf, data, count);
-	else {
-		sun3_dma_orig_addr = data;
-		sun3_dma_orig_count = count;
-	}
-#else
 	void *addr;
 
 	if(sun3_dma_orig_addr != NULL)
 		dvma_unmap(sun3_dma_orig_addr);
 
-//	addr = sun3_dvma_page((unsigned long)data, (unsigned long)dmabuf);
+#ifdef SUN3_SCSI_VME
+	addr = (void *)dvma_map_vme((unsigned long) data, count);
+#else
 	addr = (void *)dvma_map((unsigned long) data, count);
+#endif
 		
 	sun3_dma_orig_addr = addr;
 	sun3_dma_orig_count = count;
-#endif
+
+#ifndef SUN3_SCSI_VME
 	dregs->fifo_count = 0;
 	sun3_udc_write(UDC_RESET, UDC_CSR);
 	
 	/* reset fifo */
 	dregs->csr &= ~CSR_FIFO;
 	dregs->csr |= CSR_FIFO;
+#endif
 	
 	/* set direction */
 	if(write_flag)
@@ -444,6 +511,17 @@ static unsigned long sun3scsi_dma_setup(void *data, unsigned long count, int wri
 	else
 		dregs->csr &= ~CSR_SEND;
 	
+#ifdef SUN3_SCSI_VME
+	dregs->csr |= CSR_PACK_ENABLE;
+
+	dregs->dma_addr_hi = ((unsigned long)addr >> 16);
+	dregs->dma_addr_lo = ((unsigned long)addr & 0xffff);
+
+	dregs->dma_count_hi = 0;
+	dregs->dma_count_lo = 0;
+	dregs->fifo_count_hi = 0;
+	dregs->fifo_count = 0;
+#else
 	/* byte count for fifo */
 	dregs->fifo_count = count;
 
@@ -461,13 +539,8 @@ static unsigned long sun3scsi_dma_setup(void *data, unsigned long count, int wri
 	}
 
 	/* setup udc */
-#ifdef OLDDMA
-	udc_regs->addr_hi = ((dvma_vtob(dmabuf) & 0xff0000) >> 8);
-	udc_regs->addr_lo = (dvma_vtob(dmabuf) & 0xffff);
-#else
 	udc_regs->addr_hi = (((unsigned long)(addr) & 0xff0000) >> 8);
 	udc_regs->addr_lo = ((unsigned long)(addr) & 0xffff);
-#endif
 	udc_regs->count = count/2; /* count in words */
 	udc_regs->mode_hi = UDC_MODE_HIWORD;
 	if(write_flag) {
@@ -491,11 +564,13 @@ static unsigned long sun3scsi_dma_setup(void *data, unsigned long count, int wri
 
 	/* interrupt enable */
 	sun3_udc_write(UDC_INT_ENABLE, UDC_CSR);
+#endif
 	
        	return count;
 
 }
 
+#ifndef SUN3_SCSI_VME
 static inline unsigned long sun3scsi_dma_count(struct Scsi_Host *instance)
 {
 	unsigned short resid;
@@ -508,6 +583,7 @@ static inline unsigned long sun3scsi_dma_count(struct Scsi_Host *instance)
 
 	return (unsigned long) resid;
 }
+#endif
 
 static inline unsigned long sun3scsi_dma_residual(struct Scsi_Host *instance)
 {
@@ -526,8 +602,23 @@ static inline unsigned long sun3scsi_dma_xfer_len(unsigned long wanted,
 
 static inline int sun3scsi_dma_start(unsigned long count, unsigned char *data)
 {
+#ifdef SUN3_SCSI_VME
+	unsigned short csr;
+
+	csr = dregs->csr;
+
+	dregs->dma_count_hi = (sun3_dma_orig_count >> 16);
+	dregs->dma_count_lo = (sun3_dma_orig_count & 0xffff);
 
+	dregs->fifo_count_hi = (sun3_dma_orig_count >> 16);
+	dregs->fifo_count = (sun3_dma_orig_count & 0xffff);
+
+/*	if(!(csr & CSR_DMA_ENABLE))
+ *		dregs->csr |= CSR_DMA_ENABLE;
+ */
+#else
     sun3_udc_write(UDC_CHN_START, UDC_CSR);
+#endif
     
     return 0;
 }
@@ -535,12 +626,46 @@ static inline int sun3scsi_dma_start(unsigned long count, unsigned char *data)
 /* clean up after our dma is done */
 static int sun3scsi_dma_finish(int write_flag)
 {
-	unsigned short count;
+	unsigned short __maybe_unused count;
 	unsigned short fifo;
 	int ret = 0;
 	
 	sun3_dma_active = 0;
-#if 1
+
+#ifdef SUN3_SCSI_VME
+	dregs->csr &= ~CSR_DMA_ENABLE;
+
+	fifo = dregs->fifo_count;
+	if (write_flag) {
+		if ((fifo > 0) && (fifo < sun3_dma_orig_count))
+			fifo++;
+	}
+
+	last_residual = fifo;
+	/* empty bytes from the fifo which didn't make it */
+	if ((!write_flag) && (dregs->csr & CSR_LEFT)) {
+		unsigned char *vaddr;
+
+		vaddr = (unsigned char *)dvma_vmetov(sun3_dma_orig_addr);
+
+		vaddr += (sun3_dma_orig_count - fifo);
+		vaddr--;
+
+		switch (dregs->csr & CSR_LEFT) {
+		case CSR_LEFT_3:
+			*vaddr = (dregs->bpack_lo & 0xff00) >> 8;
+			vaddr--;
+
+		case CSR_LEFT_2:
+			*vaddr = (dregs->bpack_hi & 0x00ff);
+			vaddr--;
+
+		case CSR_LEFT_1:
+			*vaddr = (dregs->bpack_hi & 0xff00) >> 8;
+			break;
+		}
+	}
+#else
 	// check to empty the fifo on a read
 	if(!write_flag) {
 		int tmo = 20000; /* .2 sec */
@@ -556,28 +681,8 @@ static int sun3scsi_dma_finish(int write_flag)
 			udelay(10);
 		}
 	}
-		
-#endif
 
 	count = sun3scsi_dma_count(default_instance);
-#ifdef OLDDMA
-
-	/* if we've finished a read, copy out the data we read */
- 	if(sun3_dma_orig_addr) {
-		/* check for residual bytes after dma end */
-		if(count && (NCR5380_read(BUS_AND_STATUS_REG) &
-			     (BASR_PHASE_MATCH | BASR_ACK))) {
-			printk("scsi%d: sun3_scsi_finish: read overrun baby... ", default_instance->host_no);
-			printk("basr now %02x\n", NCR5380_read(BUS_AND_STATUS_REG));
-			ret = count;
-		}
-		
-		/* copy in what we dma'd no matter what */
-		memcpy(sun3_dma_orig_addr, dmabuf, sun3_dma_orig_count);
-		sun3_dma_orig_addr = NULL;
-
-	}
-#else
 
 	fifo = dregs->fifo_count;
 	last_residual = fifo;
@@ -595,10 +700,23 @@ static int sun3scsi_dma_finish(int write_flag)
 		vaddr[-2] = (data & 0xff00) >> 8;
 		vaddr[-1] = (data & 0xff);
 	}
+#endif
 
 	dvma_unmap(sun3_dma_orig_addr);
 	sun3_dma_orig_addr = NULL;
-#endif
+
+#ifdef SUN3_SCSI_VME
+	dregs->dma_addr_hi = 0;
+	dregs->dma_addr_lo = 0;
+	dregs->dma_count_hi = 0;
+	dregs->dma_count_lo = 0;
+
+	dregs->fifo_count = 0;
+	dregs->fifo_count_hi = 0;
+
+	dregs->csr &= ~CSR_SEND;
+/*	dregs->csr |= CSR_DMA_ENABLE; */
+#else
 	sun3_udc_write(UDC_RESET, UDC_CSR);
 	dregs->fifo_count = 0;
 	dregs->csr &= ~CSR_SEND;
@@ -606,6 +724,7 @@ static int sun3scsi_dma_finish(int write_flag)
 	/* reset fifo */
 	dregs->csr &= ~CSR_FIFO;
 	dregs->csr |= CSR_FIFO;
+#endif
 	
 	sun3_dma_setup_done = NULL;
 

commit 9f6620a318e87d73f8ce3daa7f84efc739d1fa2d
Author: Finn Thain <fthain@telegraphics.com.au>
Date:   Tue Mar 18 11:42:23 2014 +1100

    scsi/NCR5380: reduce depth of sun3_scsi nested includes
    
    Move the #include "NCR5380.h" out of the sun3_scsi.h header file and into
    the driver .c files, like all the other NCR5380 drivers in the tree.
    
    This improves uniformity and reduces the depth of nested includes. The
    sequence of #include's, #define's and #if's no longer does my head in.
    
    Signed-off-by: Finn Thain <fthain@telegraphics.com.au>
    Acked-by: Sam Creasey <sammy@sammy.net>
    Signed-off-by: Christoph Hellwig <hch@lst.de>

diff --git a/drivers/scsi/sun3_scsi.c b/drivers/scsi/sun3_scsi.c
index 99466e64e507..ac9c29b55a33 100644
--- a/drivers/scsi/sun3_scsi.c
+++ b/drivers/scsi/sun3_scsi.c
@@ -71,6 +71,7 @@
 #include "scsi.h"
 #include <scsi/scsi_host.h>
 #include "sun3_scsi.h"
+#include "NCR5380.h"
 
 /* #define OLDDMA */
 

commit 9829e52897359a17169410960e2a9dfcababb83b
Author: Finn Thain <fthain@telegraphics.com.au>
Date:   Tue Mar 18 11:42:21 2014 +1100

    scsi/NCR5380: fix and standardize NDEBUG macros
    
    All three NCR5380 core driver implementations share the same NCR5380.h
    header file so they need to agree on certain macro definitions.
    
    The flag bit used by the NDEBUG_MERGING macro in atari_NCR5380 and
    sun3_NCR5380 collides with the bit used by NDEBUG_LISTS.
    
    Moreover, NDEBUG_ABORT appears in NCR5380.c so it should be defined in
    NCR5380.h rather than in each of the many drivers using that core.
    
    An undefined NDEBUG_ABORT macro caused compiler errors and led to dodgy
    workarounds in the core driver that can now be removed.
    (See commits f566a576bca09de85bf477fc0ab2c8c96405b77b and
    185a7a1cd79b9891e3c17abdb103ba1c98d6ca7a.)
    
    Move all of the NDEBUG_ABORT, NDEBUG_TAGS and NDEBUG_MERGING macro
    definitions into NCR5380.h where all the other NDEBUG macros live.
    
    Also, incorrect "#ifdef NDEBUG" becomes "#if NDEBUG" to fix the warning:
    drivers/scsi/mac_scsi.c: At top level:
    drivers/scsi/NCR5380.c:418: warning: 'NCR5380_print' defined but not used
    drivers/scsi/NCR5380.c:459: warning: 'NCR5380_print_phase' defined but not used
    
    The debugging code is now enabled when NDEBUG != 0.
    
    Signed-off-by: Finn Thain <fthain@telegraphics.com.au>
    Acked-by: Sam Creasey <sammy@sammy.net>
    Signed-off-by: Christoph Hellwig <hch@lst.de>

diff --git a/drivers/scsi/sun3_scsi.c b/drivers/scsi/sun3_scsi.c
index 020d38aed4f5..99466e64e507 100644
--- a/drivers/scsi/sun3_scsi.c
+++ b/drivers/scsi/sun3_scsi.c
@@ -65,12 +65,6 @@
 #include <asm/idprom.h>
 #include <asm/machines.h>
 
-#define NDEBUG 0
-
-#define NDEBUG_ABORT		0x00100000
-#define NDEBUG_TAGS		0x00200000
-#define NDEBUG_MERGING		0x00400000
-
 /* dma on! */
 #define REAL_DMA
 

commit d614f06832870a4b500c3122e4f24a665ece190d
Author: Finn Thain <fthain@telegraphics.com.au>
Date:   Tue Mar 18 11:42:16 2014 +1100

    scsi/NCR5380: use NCR5380_dprint() instead of NCR5380_print()
    
    Only the NCR5380_dprint() macro should invoke the NCR5380_print() function.
    That's why NCR5380.c only defines the function #if NDEBUG. Use the standard
    macro.
    
    Signed-off-by: Finn Thain <fthain@telegraphics.com.au>
    Acked-by: Sam Creasey <sammy@sammy.net>
    Signed-off-by: Christoph Hellwig <hch@lst.de>

diff --git a/drivers/scsi/sun3_scsi.c b/drivers/scsi/sun3_scsi.c
index ab722a1c62db..020d38aed4f5 100644
--- a/drivers/scsi/sun3_scsi.c
+++ b/drivers/scsi/sun3_scsi.c
@@ -78,8 +78,6 @@
 #include <scsi/scsi_host.h>
 #include "sun3_scsi.h"
 
-static void NCR5380_print(struct Scsi_Host *instance);
-
 /* #define OLDDMA */
 
 #define USE_WRAPPER
@@ -464,7 +462,7 @@ static unsigned long sun3scsi_dma_setup(void *data, unsigned long count, int wri
 		printk("scsi%d: fifo_mismatch %04x not %04x\n",
 		       default_instance->host_no, dregs->fifo_count,
 		       (unsigned int) count);
-		NCR5380_print(default_instance);
+		NCR5380_dprint(NDEBUG_DMA, default_instance);
 	}
 
 	/* setup udc */

commit 7ac44e061b2eb7871f55f64fe794d221394d126f
Author: Finn Thain <fthain@telegraphics.com.au>
Date:   Tue Mar 18 11:42:15 2014 +1100

    scsi/NCR5380: remove old CVS keywords
    
    Signed-off-by: Finn Thain <fthain@telegraphics.com.au>
    Acked-by: Sam Creasey <sammy@sammy.net>
    Signed-off-by: Christoph Hellwig <hch@lst.de>

diff --git a/drivers/scsi/sun3_scsi.c b/drivers/scsi/sun3_scsi.c
index 243c228a6d8c..ab722a1c62db 100644
--- a/drivers/scsi/sun3_scsi.c
+++ b/drivers/scsi/sun3_scsi.c
@@ -45,10 +45,6 @@
  * USLEEP - enable support for devices that don't disconnect.  Untested.
  */
 
-/*
- * $Log: sun3_NCR5380.c,v $
- */
-
 #define AUTOSENSE
 
 #include <linux/types.h>

commit 2b0f834ca3c93e3d76ae335586b41ed921c5a293
Author: Michael Schmitz <schmitzmic@gmail.com>
Date:   Fri May 2 20:43:01 2014 +1200

    m68k/atari - atari_scsi: change abort/reset return codes
    
    [Resend of earlier patch - added equivalent changes to sun3 NCR5380 code]
    
    The abort/reset lowlevel return codes had changed with the new
    error SCSI handling - update Atari and Sun3 NCR5380 drivers to reflect this.
    
    Change reset handling for Atari to clear queues only, do not attempt
    to call done() on each command aborted by the reset. The EH code
    should do that for us. Queues _must_ be cleared, otherwise
    atari_scsi_bus_reset will not release the ST-DMA lock, deadlocking
    further error recovery.
    
    Update the Sun3 NCR5380 driver as well - the Sun3 driver was
    derived from the Atari one. Kudos to Finn Thain for the Sun3 part
    and cleaning up the header files. After the header cleanup, the
    initio.h include (!) can be dropped from sun3_scsi.h now.
    
    Signed-off-by: Michael Schmitz <schmitz@debian.org>
    Signed-off-by: Finn Thain <fthain@telegraphics.com.au>
    Acked-by: Sam Creasey <sammy@sammy.net>
    Cc: Geert Uytterhoeven <geert@linux-m68k.org>
    Cc: James E.J. Bottomley <JBottomley@parallels.com>
    Cc: linux-scsi@vger.kernel.org
    Signed-off-by: Christoph Hellwig <hch@lst.de>

diff --git a/drivers/scsi/sun3_scsi.c b/drivers/scsi/sun3_scsi.c
index e2c009b033ce..243c228a6d8c 100644
--- a/drivers/scsi/sun3_scsi.c
+++ b/drivers/scsi/sun3_scsi.c
@@ -79,7 +79,6 @@
 #define REAL_DMA
 
 #include "scsi.h"
-#include "initio.h"
 #include <scsi/scsi_host.h>
 #include "sun3_scsi.h"
 
@@ -123,6 +122,8 @@ module_param(setup_hostid, int, 0);
 
 static struct scsi_cmnd *sun3_dma_setup_done = NULL;
 
+#define	RESET_RUN_DONE
+
 #define	AFTER_RESET_DELAY	(HZ/2)
 
 /* ms to wait after hitting dma regs */

commit 9dcc26cf67fb7db7613290e62eeed6c4276c75ce
Author: Geert Uytterhoeven <geert@linux-m68k.org>
Date:   Wed Apr 10 13:52:09 2013 +0200

    sun3_scsi: add ->show_info()
    
    Based on Al's changes to atari_scsi.
    
    Signed-off-by: Geert Uytterhoeven <geert@linux-m68k.org>
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>

diff --git a/drivers/scsi/sun3_scsi.c b/drivers/scsi/sun3_scsi.c
index 6e25889db9d4..e2c009b033ce 100644
--- a/drivers/scsi/sun3_scsi.c
+++ b/drivers/scsi/sun3_scsi.c
@@ -626,6 +626,7 @@ static int sun3scsi_dma_finish(int write_flag)
 #include "sun3_NCR5380.c"
 
 static struct scsi_host_template driver_template = {
+	.show_info		= sun3scsi_show_info,
 	.name			= SUN3_SCSI_NAME,
 	.detect			= sun3scsi_detect,
 	.release		= sun3scsi_release,

commit 9ffc93f203c18a70623f21950f1dd473c9ec48cd
Author: David Howells <dhowells@redhat.com>
Date:   Wed Mar 28 18:30:03 2012 +0100

    Remove all #inclusions of asm/system.h
    
    Remove all #inclusions of asm/system.h preparatory to splitting and killing
    it.  Performed with the following command:
    
    perl -p -i -e 's!^#\s*include\s*<asm/system[.]h>.*\n!!' `grep -Irl '^#\s*include\s*<asm/system[.]h>' *`
    
    Signed-off-by: David Howells <dhowells@redhat.com>

diff --git a/drivers/scsi/sun3_scsi.c b/drivers/scsi/sun3_scsi.c
index baf7328de956..6e25889db9d4 100644
--- a/drivers/scsi/sun3_scsi.c
+++ b/drivers/scsi/sun3_scsi.c
@@ -63,7 +63,6 @@
 #include <linux/blkdev.h>
 
 #include <asm/io.h>
-#include <asm/system.h>
 
 #include <asm/sun3ints.h>
 #include <asm/dvma.h>

commit 2ba51ea28ba54ea8808ba7dfd694f1dd37e8b7c7
Author: Geert Uytterhoeven <geert@linux-m68k.org>
Date:   Mon Jun 13 20:39:21 2011 +0200

    [SCSI] sun3: Add various missing NDEBUG* definitions
    
    This fixes a.o.:
    
    drivers/scsi/sun3_scsi.h:225:5: warning: "NDEBUG" is not defined
    drivers/scsi/sun3_scsi.h:345:14: warning: "NDEBUG_ABORT" is not defined
    drivers/scsi/sun3_scsi.h:351:14: warning: "NDEBUG_TAGS" is not defined
    drivers/scsi/sun3_scsi.h:357:14: warning: "NDEBUG_MERGING" is not defined
    
    Signed-off-by: Geert Uytterhoeven <geert@linux-m68k.org>
    Signed-off-by: James Bottomley <JBottomley@Parallels.com>

diff --git a/drivers/scsi/sun3_scsi.c b/drivers/scsi/sun3_scsi.c
index 2cc83ef3f37f..baf7328de956 100644
--- a/drivers/scsi/sun3_scsi.c
+++ b/drivers/scsi/sun3_scsi.c
@@ -70,6 +70,12 @@
 #include <asm/idprom.h>
 #include <asm/machines.h>
 
+#define NDEBUG 0
+
+#define NDEBUG_ABORT		0x00100000
+#define NDEBUG_TAGS		0x00200000
+#define NDEBUG_MERGING		0x00400000
+
 /* dma on! */
 #define REAL_DMA
 
@@ -86,8 +92,6 @@ static void NCR5380_print(struct Scsi_Host *instance);
 /*#define RESET_BOOT */
 #define DRIVER_SETUP
 
-#define NDEBUG 0
-
 /*
  * BUG can be used to trigger a strange code-size related hang on 2.1 kernels
  */

commit 19b6c51cf05656c9dd970164be52b120162391bf
Author: Geert Uytterhoeven <geert@linux-m68k.org>
Date:   Mon Jun 13 20:39:19 2011 +0200

    [SCSI] sun3: Provide a dummy NCR5380_exit()
    
    and call it from sun3scsi_release(), cfr. the other NCR5380 drivers.
    
    This fixes:
    
    drivers/scsi/NCR5380.h:303: warning: ‘NCR5380_exit’ declared ‘static’ but never defined
    
    Signed-off-by: Geert Uytterhoeven <geert@linux-m68k.org>
    Signed-off-by: James Bottomley <JBottomley@Parallels.com>

diff --git a/drivers/scsi/sun3_scsi.c b/drivers/scsi/sun3_scsi.c
index 2ad6b91d71eb..2cc83ef3f37f 100644
--- a/drivers/scsi/sun3_scsi.c
+++ b/drivers/scsi/sun3_scsi.c
@@ -314,6 +314,7 @@ int sun3scsi_release (struct Scsi_Host *shpnt)
 
 	iounmap((void *)sun3_scsi_regp);
 
+	NCR5380_exit(shpnt);
 	return 0;
 }
 

commit d559c49e026b4b64dbeb9227c70c98ad11518747
Author: Geert Uytterhoeven <geert@linux-m68k.org>
Date:   Mon Jun 13 20:39:18 2011 +0200

    [SCSI] sun3: sun3scsi_detect() and NCR5380_init() should be __init
    
    WARNING: vmlinux.o(.text+0x18545c): Section mismatch in reference from the function sun3scsi_detect() to the function .init.text:NCR5380_print_options()
    WARNING: vmlinux.o(.text+0x18556c): Section mismatch in reference from the function sun3scsi_detect() to the function .init.text:NCR5380_print_options()
    WARNING: vmlinux.o(.text+0x187692): Section mismatch in reference from the function sun3scsi_detect() to the function .init.text:NCR5380_print_options()
    WARNING: vmlinux.o(.text+0x187770): Section mismatch in reference from the function sun3scsi_detect() to the function .init.text:NCR5380_print_options()
    
    Signed-off-by: Geert Uytterhoeven <geert@linux-m68k.org>
    Signed-off-by: James Bottomley <JBottomley@Parallels.com>

diff --git a/drivers/scsi/sun3_scsi.c b/drivers/scsi/sun3_scsi.c
index 613f5880d135..2ad6b91d71eb 100644
--- a/drivers/scsi/sun3_scsi.c
+++ b/drivers/scsi/sun3_scsi.c
@@ -195,7 +195,7 @@ static struct Scsi_Host *default_instance;
  *
  */
  
-int sun3scsi_detect(struct scsi_host_template * tpnt)
+int __init sun3scsi_detect(struct scsi_host_template * tpnt)
 {
 	unsigned long ioaddr;
 	static int called = 0;

commit 33659ebbae262228eef4e0fe990f393d1f0ed941
Author: Christoph Hellwig <hch@lst.de>
Date:   Sat Aug 7 18:17:56 2010 +0200

    block: remove wrappers for request type/flags
    
    Remove all the trivial wrappers for the cmd_type and cmd_flags fields in
    struct requests.  This allows much easier grepping for different request
    types instead of unwinding through macros.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Jens Axboe <jaxboe@fusionio.com>

diff --git a/drivers/scsi/sun3_scsi.c b/drivers/scsi/sun3_scsi.c
index e606cf0a2eb7..613f5880d135 100644
--- a/drivers/scsi/sun3_scsi.c
+++ b/drivers/scsi/sun3_scsi.c
@@ -524,7 +524,7 @@ static inline unsigned long sun3scsi_dma_xfer_len(unsigned long wanted,
 						  struct scsi_cmnd *cmd,
 						  int write_flag)
 {
-	if(blk_fs_request(cmd->request))
+	if (cmd->request->cmd_type == REQ_TYPE_FS)
  		return wanted;
 	else
 		return 0;

commit 1e641664301744f0d381de43ae1e12343e60b479
Author: Jeff Garzik <jeff@garzik.org>
Date:   Sun Nov 11 19:52:05 2007 -0500

    [SCSI] NCR5380: Fix bugs and canonicalize irq handler usage
    
    * Always pass the same value to free_irq() that we pass to
      request_irq().  This fixes several bugs.
    
    * Always call NCR5380_intr() with 'irq' and 'dev_id' arguments.
    
      Note, scsi_falcon_intr() is the only case now where dev_id is not the
      scsi_host.
    
    * Always pass Scsi_Host to request_irq().  For most cases, the drivers
      already did so, and I merely neated the source code line.  In other
      cases, either NULL or a non-sensical value was passed, verified to be
      unused, then changed to be Scsi_Host in anticipation of the future.
    
    In addition to the bugs fixes, this change makes the interface usage
    consistent, which in turn enables the possibility of directly
    referencing Scsi_Host from all NCR5380_intr() invocations.
    
    Signed-off-by: Jeff Garzik <jgarzik@redhat.com>
    Signed-off-by: James Bottomley <James.Bottomley@HansenPartnership.com>

diff --git a/drivers/scsi/sun3_scsi.c b/drivers/scsi/sun3_scsi.c
index 5e46d842c6f9..e606cf0a2eb7 100644
--- a/drivers/scsi/sun3_scsi.c
+++ b/drivers/scsi/sun3_scsi.c
@@ -268,7 +268,7 @@ int sun3scsi_detect(struct scsi_host_template * tpnt)
         ((struct NCR5380_hostdata *)instance->hostdata)->ctrl = 0;
 
 	if (request_irq(instance->irq, scsi_sun3_intr,
-			     0, "Sun3SCSI-5380", NULL)) {
+			     0, "Sun3SCSI-5380", instance)) {
 #ifndef REAL_DMA
 		printk("scsi%d: IRQ%d not free, interrupts disabled\n",
 		       instance->host_no, instance->irq);
@@ -310,7 +310,7 @@ int sun3scsi_detect(struct scsi_host_template * tpnt)
 int sun3scsi_release (struct Scsi_Host *shpnt)
 {
 	if (shpnt->irq != SCSI_IRQ_NONE)
-		free_irq (shpnt->irq, NULL);
+		free_irq(shpnt->irq, shpnt);
 
 	iounmap((void *)sun3_scsi_regp);
 

commit cd354f1ae75e6466a7e31b727faede57a1f89ca5
Author: Tim Schmielau <tim@physik3.uni-rostock.de>
Date:   Wed Feb 14 00:33:14 2007 -0800

    [PATCH] remove many unneeded #includes of sched.h
    
    After Al Viro (finally) succeeded in removing the sched.h #include in module.h
    recently, it makes sense again to remove other superfluous sched.h includes.
    There are quite a lot of files which include it but don't actually need
    anything defined in there.  Presumably these includes were once needed for
    macros that used to live in sched.h, but moved to other header files in the
    course of cleaning it up.
    
    To ease the pain, this time I did not fiddle with any header files and only
    removed #includes from .c-files, which tend to cause less trouble.
    
    Compile tested against 2.6.20-rc2 and 2.6.20-rc2-mm2 (with offsets) on alpha,
    arm, i386, ia64, mips, powerpc, and x86_64 with allnoconfig, defconfig,
    allmodconfig, and allyesconfig as well as a few randconfigs on x86_64 and all
    configs in arch/arm/configs on arm.  I also checked that no new warnings were
    introduced by the patch (actually, some warnings are removed that were emitted
    by unnecessarily included header files).
    
    Signed-off-by: Tim Schmielau <tim@physik3.uni-rostock.de>
    Acked-by: Russell King <rmk+kernel@arm.linux.org.uk>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>

diff --git a/drivers/scsi/sun3_scsi.c b/drivers/scsi/sun3_scsi.c
index 69ee3e4a820e..5e46d842c6f9 100644
--- a/drivers/scsi/sun3_scsi.c
+++ b/drivers/scsi/sun3_scsi.c
@@ -58,7 +58,6 @@
 
 #include <linux/module.h>
 #include <linux/signal.h>
-#include <linux/sched.h>
 #include <linux/ioport.h>
 #include <linux/init.h>
 #include <linux/blkdev.h>

commit c39e7eee149b4105fc49df27a2cb04fad880bb00
Author: Sam Creasey <sammy@sammy.net>
Date:   Sat Dec 9 10:37:05 2006 +0100

    [PATCH] Sun3 SCSI: Make sun3 scsi drivers compile/work again
    
    Make sun3 scsi drivers compile/work again (though with way too many warnings...)
    
    Tested on 3/50, 3/60.
    
    Signed-off-by: Sam Creasey <sammy@sammy.net>
    Signed-off-by: Geert Uytterhoeven <geert@linux-m68k.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/drivers/scsi/sun3_scsi.c b/drivers/scsi/sun3_scsi.c
index d56d85dd9ba0..69ee3e4a820e 100644
--- a/drivers/scsi/sun3_scsi.c
+++ b/drivers/scsi/sun3_scsi.c
@@ -75,9 +75,9 @@
 #define REAL_DMA
 
 #include "scsi.h"
+#include "initio.h"
 #include <scsi/scsi_host.h>
 #include "sun3_scsi.h"
-#include "NCR5380.h"
 
 static void NCR5380_print(struct Scsi_Host *instance);
 

commit 811c93666c3f4a0e99382c24a84480b03c7262f6
Author: Henne <henne@nachtwindheim.de>
Date:   Tue Oct 3 19:51:59 2006 +0200

    [SCSI] Scsi_Cmnd convertion in sun3-driver
    
    Change the obsolete Scsi_Cmnd to struct scsi_cmnd in the sun3-driver.
    
    Signed-off-by: Henrik Kretzschmar <henne@nachtwindheim.de>
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>

diff --git a/drivers/scsi/sun3_scsi.c b/drivers/scsi/sun3_scsi.c
index e625b4c5833a..d56d85dd9ba0 100644
--- a/drivers/scsi/sun3_scsi.c
+++ b/drivers/scsi/sun3_scsi.c
@@ -119,7 +119,7 @@ module_param(setup_use_tagged_queuing, int, 0);
 static int setup_hostid = -1;
 module_param(setup_hostid, int, 0);
 
-static Scsi_Cmnd *sun3_dma_setup_done = NULL;
+static struct scsi_cmnd *sun3_dma_setup_done = NULL;
 
 #define	AFTER_RESET_DELAY	(HZ/2)
 
@@ -521,8 +521,9 @@ static inline unsigned long sun3scsi_dma_residual(struct Scsi_Host *instance)
 	return last_residual;
 }
 
-static inline unsigned long sun3scsi_dma_xfer_len(unsigned long wanted, Scsi_Cmnd *cmd,
-				    int write_flag)
+static inline unsigned long sun3scsi_dma_xfer_len(unsigned long wanted,
+						  struct scsi_cmnd *cmd,
+						  int write_flag)
 {
 	if(blk_fs_request(cmd->request))
  		return wanted;

commit 7d12e780e003f93433d49ce78cfedf4b4c52adc5
Author: David Howells <dhowells@redhat.com>
Date:   Thu Oct 5 14:55:46 2006 +0100

    IRQ: Maintain regs pointer globally rather than passing to IRQ handlers
    
    Maintain a per-CPU global "struct pt_regs *" variable which can be used instead
    of passing regs around manually through all ~1800 interrupt handlers in the
    Linux kernel.
    
    The regs pointer is used in few places, but it potentially costs both stack
    space and code to pass it around.  On the FRV arch, removing the regs parameter
    from all the genirq function results in a 20% speed up of the IRQ exit path
    (ie: from leaving timer_interrupt() to leaving do_IRQ()).
    
    Where appropriate, an arch may override the generic storage facility and do
    something different with the variable.  On FRV, for instance, the address is
    maintained in GR28 at all times inside the kernel as part of general exception
    handling.
    
    Having looked over the code, it appears that the parameter may be handed down
    through up to twenty or so layers of functions.  Consider a USB character
    device attached to a USB hub, attached to a USB controller that posts its
    interrupts through a cascaded auxiliary interrupt controller.  A character
    device driver may want to pass regs to the sysrq handler through the input
    layer which adds another few layers of parameter passing.
    
    I've build this code with allyesconfig for x86_64 and i386.  I've runtested the
    main part of the code on FRV and i386, though I can't test most of the drivers.
    I've also done partial conversion for powerpc and MIPS - these at least compile
    with minimal configurations.
    
    This will affect all archs.  Mostly the changes should be relatively easy.
    Take do_IRQ(), store the regs pointer at the beginning, saving the old one:
    
            struct pt_regs *old_regs = set_irq_regs(regs);
    
    And put the old one back at the end:
    
            set_irq_regs(old_regs);
    
    Don't pass regs through to generic_handle_irq() or __do_IRQ().
    
    In timer_interrupt(), this sort of change will be necessary:
    
            -       update_process_times(user_mode(regs));
            -       profile_tick(CPU_PROFILING, regs);
            +       update_process_times(user_mode(get_irq_regs()));
            +       profile_tick(CPU_PROFILING);
    
    I'd like to move update_process_times()'s use of get_irq_regs() into itself,
    except that i386, alone of the archs, uses something other than user_mode().
    
    Some notes on the interrupt handling in the drivers:
    
     (*) input_dev() is now gone entirely.  The regs pointer is no longer stored in
         the input_dev struct.
    
     (*) finish_unlinks() in drivers/usb/host/ohci-q.c needs checking.  It does
         something different depending on whether it's been supplied with a regs
         pointer or not.
    
     (*) Various IRQ handler function pointers have been moved to type
         irq_handler_t.
    
    Signed-Off-By: David Howells <dhowells@redhat.com>
    (cherry picked from 1b16e7ac850969f38b375e511e3fa2f474a33867 commit)

diff --git a/drivers/scsi/sun3_scsi.c b/drivers/scsi/sun3_scsi.c
index 44a99aeb8180..e625b4c5833a 100644
--- a/drivers/scsi/sun3_scsi.c
+++ b/drivers/scsi/sun3_scsi.c
@@ -102,7 +102,7 @@ static void NCR5380_print(struct Scsi_Host *instance);
 #define	ENABLE_IRQ()	enable_irq( IRQ_SUN3_SCSI ); 
 
 
-static irqreturn_t scsi_sun3_intr(int irq, void *dummy, struct pt_regs *fp);
+static irqreturn_t scsi_sun3_intr(int irq, void *dummy);
 static inline unsigned char sun3scsi_read(int reg);
 static inline void sun3scsi_write(int reg, int value);
 
@@ -371,7 +371,7 @@ const char * sun3scsi_info (struct Scsi_Host *spnt) {
 // safe bits for the CSR
 #define CSR_GOOD 0x060f
 
-static irqreturn_t scsi_sun3_intr(int irq, void *dummy, struct pt_regs *fp)
+static irqreturn_t scsi_sun3_intr(int irq, void *dummy)
 {
 	unsigned short csr = dregs->csr;
 	int handled = 0;
@@ -388,7 +388,7 @@ static irqreturn_t scsi_sun3_intr(int irq, void *dummy, struct pt_regs *fp)
 	}
 
 	if(csr & (CSR_SDB_INT | CSR_DMA_INT)) {
-		NCR5380_intr(irq, dummy, fp);
+		NCR5380_intr(irq, dummy);
 		handled = 1;
 	}
 

commit 4aff5e2333c9a1609662f2091f55c3f6fffdad36
Author: Jens Axboe <axboe@suse.de>
Date:   Thu Aug 10 08:44:47 2006 +0200

    [PATCH] Split struct request ->flags into two parts
    
    Right now ->flags is a bit of a mess: some are request types, and
    others are just modifiers. Clean this up by splitting it into
    ->cmd_type and ->cmd_flags. This allows introduction of generic
    Linux block message types, useful for sending generic Linux commands
    to block devices.
    
    Signed-off-by: Jens Axboe <axboe@suse.de>

diff --git a/drivers/scsi/sun3_scsi.c b/drivers/scsi/sun3_scsi.c
index 837173415d4c..44a99aeb8180 100644
--- a/drivers/scsi/sun3_scsi.c
+++ b/drivers/scsi/sun3_scsi.c
@@ -524,7 +524,7 @@ static inline unsigned long sun3scsi_dma_residual(struct Scsi_Host *instance)
 static inline unsigned long sun3scsi_dma_xfer_len(unsigned long wanted, Scsi_Cmnd *cmd,
 				    int write_flag)
 {
-	if(cmd->request->flags & REQ_CMD)
+	if(blk_fs_request(cmd->request))
  		return wanted;
 	else
 		return 0;

commit d0be4a7d29ad0bd3ce2209dd9e46d410b632db59
Author: Christoph Hellwig <hch@lst.de>
Date:   Mon Oct 31 18:31:40 2005 +0100

    [SCSI] remove Scsi_Host_Template typedef
    
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>

diff --git a/drivers/scsi/sun3_scsi.c b/drivers/scsi/sun3_scsi.c
index e3ea99f23d60..837173415d4c 100644
--- a/drivers/scsi/sun3_scsi.c
+++ b/drivers/scsi/sun3_scsi.c
@@ -185,7 +185,7 @@ static inline void sun3_udc_write(unsigned short val, unsigned char reg)
 static struct Scsi_Host *default_instance;
 
 /*
- * Function : int sun3scsi_detect(Scsi_Host_Template * tpnt)
+ * Function : int sun3scsi_detect(struct scsi_host_template * tpnt)
  *
  * Purpose : initializes mac NCR5380 driver based on the
  *	command line / compile time port and irq definitions.
@@ -196,7 +196,7 @@ static struct Scsi_Host *default_instance;
  *
  */
  
-int sun3scsi_detect(Scsi_Host_Template * tpnt)
+int sun3scsi_detect(struct scsi_host_template * tpnt)
 {
 	unsigned long ioaddr;
 	static int called = 0;
@@ -621,7 +621,7 @@ static int sun3scsi_dma_finish(int write_flag)
 	
 #include "sun3_NCR5380.c"
 
-static Scsi_Host_Template driver_template = {
+static struct scsi_host_template driver_template = {
 	.name			= SUN3_SCSI_NAME,
 	.detect			= sun3scsi_detect,
 	.release		= sun3scsi_release,

commit 1da177e4c3f41524e886b7f1b8a0c1fc7321cac2
Author: Linus Torvalds <torvalds@ppc970.osdl.org>
Date:   Sat Apr 16 15:20:36 2005 -0700

    Linux-2.6.12-rc2
    
    Initial git repository build. I'm not bothering with the full history,
    even though we have it. We can create a separate "historical" git
    archive of that later if we want to, and in the meantime it's about
    3.2GB when imported into git - space that would just make the early
    git days unnecessarily complicated, when we don't have a lot of good
    infrastructure for it.
    
    Let it rip!

diff --git a/drivers/scsi/sun3_scsi.c b/drivers/scsi/sun3_scsi.c
new file mode 100644
index 000000000000..e3ea99f23d60
--- /dev/null
+++ b/drivers/scsi/sun3_scsi.c
@@ -0,0 +1,642 @@
+/*
+ * Sun3 SCSI stuff by Erik Verbruggen (erik@bigmama.xtdnet.nl)
+ *
+ * Sun3 DMA routines added by Sam Creasey (sammy@sammy.net)
+ *
+ * Adapted from mac_scsinew.c:
+ */
+/*
+ * Generic Macintosh NCR5380 driver
+ *
+ * Copyright 1998, Michael Schmitz <mschmitz@lbl.gov>
+ *
+ * derived in part from:
+ */
+/*
+ * Generic Generic NCR5380 driver
+ *
+ * Copyright 1995, Russell King
+ *
+ * ALPHA RELEASE 1.
+ *
+ * For more information, please consult
+ *
+ * NCR 5380 Family
+ * SCSI Protocol Controller
+ * Databook
+ *
+ * NCR Microelectronics
+ * 1635 Aeroplaza Drive
+ * Colorado Springs, CO 80916
+ * 1+ (719) 578-3400
+ * 1+ (800) 334-5454
+ */
+
+
+/*
+ * This is from mac_scsi.h, but hey, maybe this is useful for Sun3 too! :)
+ *
+ * Options :
+ *
+ * PARITY - enable parity checking.  Not supported.
+ *
+ * SCSI2 - enable support for SCSI-II tagged queueing.  Untested.
+ *
+ * USLEEP - enable support for devices that don't disconnect.  Untested.
+ */
+
+/*
+ * $Log: sun3_NCR5380.c,v $
+ */
+
+#define AUTOSENSE
+
+#include <linux/types.h>
+#include <linux/stddef.h>
+#include <linux/ctype.h>
+#include <linux/delay.h>
+
+#include <linux/module.h>
+#include <linux/signal.h>
+#include <linux/sched.h>
+#include <linux/ioport.h>
+#include <linux/init.h>
+#include <linux/blkdev.h>
+
+#include <asm/io.h>
+#include <asm/system.h>
+
+#include <asm/sun3ints.h>
+#include <asm/dvma.h>
+#include <asm/idprom.h>
+#include <asm/machines.h>
+
+/* dma on! */
+#define REAL_DMA
+
+#include "scsi.h"
+#include <scsi/scsi_host.h>
+#include "sun3_scsi.h"
+#include "NCR5380.h"
+
+static void NCR5380_print(struct Scsi_Host *instance);
+
+/* #define OLDDMA */
+
+#define USE_WRAPPER
+/*#define RESET_BOOT */
+#define DRIVER_SETUP
+
+#define NDEBUG 0
+
+/*
+ * BUG can be used to trigger a strange code-size related hang on 2.1 kernels
+ */
+#ifdef BUG
+#undef RESET_BOOT
+#undef DRIVER_SETUP
+#endif
+
+/* #define SUPPORT_TAGS */
+
+#define	ENABLE_IRQ()	enable_irq( IRQ_SUN3_SCSI ); 
+
+
+static irqreturn_t scsi_sun3_intr(int irq, void *dummy, struct pt_regs *fp);
+static inline unsigned char sun3scsi_read(int reg);
+static inline void sun3scsi_write(int reg, int value);
+
+static int setup_can_queue = -1;
+module_param(setup_can_queue, int, 0);
+static int setup_cmd_per_lun = -1;
+module_param(setup_cmd_per_lun, int, 0);
+static int setup_sg_tablesize = -1;
+module_param(setup_sg_tablesize, int, 0);
+#ifdef SUPPORT_TAGS
+static int setup_use_tagged_queuing = -1;
+module_param(setup_use_tagged_queuing, int, 0);
+#endif
+static int setup_hostid = -1;
+module_param(setup_hostid, int, 0);
+
+static Scsi_Cmnd *sun3_dma_setup_done = NULL;
+
+#define	AFTER_RESET_DELAY	(HZ/2)
+
+/* ms to wait after hitting dma regs */
+#define SUN3_DMA_DELAY 10
+
+/* dvma buffer to allocate -- 32k should hopefully be more than sufficient */
+#define SUN3_DVMA_BUFSIZE 0xe000
+
+/* minimum number of bytes to do dma on */
+#define SUN3_DMA_MINSIZE 128
+
+static volatile unsigned char *sun3_scsi_regp;
+static volatile struct sun3_dma_regs *dregs;
+#ifdef OLDDMA
+static unsigned char *dmabuf = NULL; /* dma memory buffer */
+#endif
+static struct sun3_udc_regs *udc_regs = NULL;
+static unsigned char *sun3_dma_orig_addr = NULL;
+static unsigned long sun3_dma_orig_count = 0;
+static int sun3_dma_active = 0;
+static unsigned long last_residual = 0;
+
+/*
+ * NCR 5380 register access functions
+ */
+
+static inline unsigned char sun3scsi_read(int reg)
+{
+	return( sun3_scsi_regp[reg] );
+}
+
+static inline void sun3scsi_write(int reg, int value)
+{
+	sun3_scsi_regp[reg] = value;
+}
+
+/* dma controller register access functions */
+
+static inline unsigned short sun3_udc_read(unsigned char reg)
+{
+	unsigned short ret;
+
+	dregs->udc_addr = UDC_CSR;
+	udelay(SUN3_DMA_DELAY);
+	ret = dregs->udc_data;
+	udelay(SUN3_DMA_DELAY);
+	
+	return ret;
+}
+
+static inline void sun3_udc_write(unsigned short val, unsigned char reg)
+{
+	dregs->udc_addr = reg;
+	udelay(SUN3_DMA_DELAY);
+	dregs->udc_data = val;
+	udelay(SUN3_DMA_DELAY);
+}
+
+/*
+ * XXX: status debug
+ */
+static struct Scsi_Host *default_instance;
+
+/*
+ * Function : int sun3scsi_detect(Scsi_Host_Template * tpnt)
+ *
+ * Purpose : initializes mac NCR5380 driver based on the
+ *	command line / compile time port and irq definitions.
+ *
+ * Inputs : tpnt - template for this SCSI adapter.
+ *
+ * Returns : 1 if a host adapter was found, 0 if not.
+ *
+ */
+ 
+int sun3scsi_detect(Scsi_Host_Template * tpnt)
+{
+	unsigned long ioaddr;
+	static int called = 0;
+	struct Scsi_Host *instance;
+
+	/* check that this machine has an onboard 5380 */
+	switch(idprom->id_machtype) {
+	case SM_SUN3|SM_3_50:
+	case SM_SUN3|SM_3_60:
+		break;
+
+	default:
+		return 0;
+	}
+
+	if(called)
+		return 0;
+
+	tpnt->proc_name = "Sun3 5380 SCSI";
+
+	/* setup variables */
+	tpnt->can_queue =
+		(setup_can_queue > 0) ? setup_can_queue : CAN_QUEUE;
+	tpnt->cmd_per_lun =
+		(setup_cmd_per_lun > 0) ? setup_cmd_per_lun : CMD_PER_LUN;
+	tpnt->sg_tablesize = 
+		(setup_sg_tablesize >= 0) ? setup_sg_tablesize : SG_TABLESIZE;
+
+	if (setup_hostid >= 0)
+		tpnt->this_id = setup_hostid;
+	else {
+		/* use 7 as default */
+		tpnt->this_id = 7;
+	}
+
+	ioaddr = (unsigned long)ioremap(IOBASE_SUN3_SCSI, PAGE_SIZE);
+	sun3_scsi_regp = (unsigned char *)ioaddr;
+
+	dregs = (struct sun3_dma_regs *)(((unsigned char *)ioaddr) + 8);
+
+	if((udc_regs = dvma_malloc(sizeof(struct sun3_udc_regs)))
+	   == NULL) {
+	     printk("SUN3 Scsi couldn't allocate DVMA memory!\n");
+	     return 0;
+	}
+#ifdef OLDDMA
+	if((dmabuf = dvma_malloc_align(SUN3_DVMA_BUFSIZE, 0x10000)) == NULL) {
+	     printk("SUN3 Scsi couldn't allocate DVMA memory!\n");
+	     return 0;
+	}
+#endif
+#ifdef SUPPORT_TAGS
+	if (setup_use_tagged_queuing < 0)
+		setup_use_tagged_queuing = USE_TAGGED_QUEUING;
+#endif
+
+	instance = scsi_register (tpnt, sizeof(struct NCR5380_hostdata));
+	if(instance == NULL)
+		return 0;
+		
+	default_instance = instance;
+
+        instance->io_port = (unsigned long) ioaddr;
+	instance->irq = IRQ_SUN3_SCSI;
+
+	NCR5380_init(instance, 0);
+
+	instance->n_io_port = 32;
+
+        ((struct NCR5380_hostdata *)instance->hostdata)->ctrl = 0;
+
+	if (request_irq(instance->irq, scsi_sun3_intr,
+			     0, "Sun3SCSI-5380", NULL)) {
+#ifndef REAL_DMA
+		printk("scsi%d: IRQ%d not free, interrupts disabled\n",
+		       instance->host_no, instance->irq);
+		instance->irq = SCSI_IRQ_NONE;
+#else
+		printk("scsi%d: IRQ%d not free, bailing out\n",
+		       instance->host_no, instance->irq);
+		return 0;
+#endif
+	}
+	
+	printk("scsi%d: Sun3 5380 at port %lX irq", instance->host_no, instance->io_port);
+	if (instance->irq == SCSI_IRQ_NONE)
+		printk ("s disabled");
+	else
+		printk (" %d", instance->irq);
+	printk(" options CAN_QUEUE=%d CMD_PER_LUN=%d release=%d",
+	       instance->can_queue, instance->cmd_per_lun,
+	       SUN3SCSI_PUBLIC_RELEASE);
+	printk("\nscsi%d:", instance->host_no);
+	NCR5380_print_options(instance);
+	printk("\n");
+
+	dregs->csr = 0;
+	udelay(SUN3_DMA_DELAY);
+	dregs->csr = CSR_SCSI | CSR_FIFO | CSR_INTR;
+	udelay(SUN3_DMA_DELAY);
+	dregs->fifo_count = 0;
+
+	called = 1;
+
+#ifdef RESET_BOOT
+	sun3_scsi_reset_boot(instance);
+#endif
+
+	return 1;
+}
+
+int sun3scsi_release (struct Scsi_Host *shpnt)
+{
+	if (shpnt->irq != SCSI_IRQ_NONE)
+		free_irq (shpnt->irq, NULL);
+
+	iounmap((void *)sun3_scsi_regp);
+
+	return 0;
+}
+
+#ifdef RESET_BOOT
+/*
+ * Our 'bus reset on boot' function
+ */
+
+static void sun3_scsi_reset_boot(struct Scsi_Host *instance)
+{
+	unsigned long end;
+
+	NCR5380_local_declare();
+	NCR5380_setup(instance);
+	
+	/*
+	 * Do a SCSI reset to clean up the bus during initialization. No
+	 * messing with the queues, interrupts, or locks necessary here.
+	 */
+
+	printk( "Sun3 SCSI: resetting the SCSI bus..." );
+
+	/* switch off SCSI IRQ - catch an interrupt without IRQ bit set else */
+//       	sun3_disable_irq( IRQ_SUN3_SCSI );
+
+	/* get in phase */
+	NCR5380_write( TARGET_COMMAND_REG,
+		      PHASE_SR_TO_TCR( NCR5380_read(STATUS_REG) ));
+
+	/* assert RST */
+	NCR5380_write( INITIATOR_COMMAND_REG, ICR_BASE | ICR_ASSERT_RST );
+
+	/* The min. reset hold time is 25us, so 40us should be enough */
+	udelay( 50 );
+
+	/* reset RST and interrupt */
+	NCR5380_write( INITIATOR_COMMAND_REG, ICR_BASE );
+	NCR5380_read( RESET_PARITY_INTERRUPT_REG );
+
+	for( end = jiffies + AFTER_RESET_DELAY; time_before(jiffies, end); )
+		barrier();
+
+	/* switch on SCSI IRQ again */
+//       	sun3_enable_irq( IRQ_SUN3_SCSI );
+
+	printk( " done\n" );
+}
+#endif
+
+const char * sun3scsi_info (struct Scsi_Host *spnt) {
+    return "";
+}
+
+// safe bits for the CSR
+#define CSR_GOOD 0x060f
+
+static irqreturn_t scsi_sun3_intr(int irq, void *dummy, struct pt_regs *fp)
+{
+	unsigned short csr = dregs->csr;
+	int handled = 0;
+
+	if(csr & ~CSR_GOOD) {
+		if(csr & CSR_DMA_BUSERR) {
+			printk("scsi%d: bus error in dma\n", default_instance->host_no);
+		}
+
+		if(csr & CSR_DMA_CONFLICT) {
+			printk("scsi%d: dma conflict\n", default_instance->host_no);
+		}
+		handled = 1;
+	}
+
+	if(csr & (CSR_SDB_INT | CSR_DMA_INT)) {
+		NCR5380_intr(irq, dummy, fp);
+		handled = 1;
+	}
+
+	return IRQ_RETVAL(handled);
+}
+
+/*
+ * Debug stuff - to be called on NMI, or sysrq key. Use at your own risk; 
+ * reentering NCR5380_print_status seems to have ugly side effects
+ */
+
+/* this doesn't seem to get used at all -- sam */
+#if 0
+void sun3_sun3_debug (void)
+{
+	unsigned long flags;
+	NCR5380_local_declare();
+
+	if (default_instance) {
+			local_irq_save(flags);
+			NCR5380_print_status(default_instance);
+			local_irq_restore(flags);
+	}
+}
+#endif
+
+
+/* sun3scsi_dma_setup() -- initialize the dma controller for a read/write */
+static unsigned long sun3scsi_dma_setup(void *data, unsigned long count, int write_flag)
+{
+#ifdef OLDDMA
+	if(write_flag) 
+		memcpy(dmabuf, data, count);
+	else {
+		sun3_dma_orig_addr = data;
+		sun3_dma_orig_count = count;
+	}
+#else
+	void *addr;
+
+	if(sun3_dma_orig_addr != NULL)
+		dvma_unmap(sun3_dma_orig_addr);
+
+//	addr = sun3_dvma_page((unsigned long)data, (unsigned long)dmabuf);
+	addr = (void *)dvma_map((unsigned long) data, count);
+		
+	sun3_dma_orig_addr = addr;
+	sun3_dma_orig_count = count;
+#endif
+	dregs->fifo_count = 0;
+	sun3_udc_write(UDC_RESET, UDC_CSR);
+	
+	/* reset fifo */
+	dregs->csr &= ~CSR_FIFO;
+	dregs->csr |= CSR_FIFO;
+	
+	/* set direction */
+	if(write_flag)
+		dregs->csr |= CSR_SEND;
+	else
+		dregs->csr &= ~CSR_SEND;
+	
+	/* byte count for fifo */
+	dregs->fifo_count = count;
+
+	sun3_udc_write(UDC_RESET, UDC_CSR);
+	
+	/* reset fifo */
+	dregs->csr &= ~CSR_FIFO;
+	dregs->csr |= CSR_FIFO;
+	
+	if(dregs->fifo_count != count) { 
+		printk("scsi%d: fifo_mismatch %04x not %04x\n",
+		       default_instance->host_no, dregs->fifo_count,
+		       (unsigned int) count);
+		NCR5380_print(default_instance);
+	}
+
+	/* setup udc */
+#ifdef OLDDMA
+	udc_regs->addr_hi = ((dvma_vtob(dmabuf) & 0xff0000) >> 8);
+	udc_regs->addr_lo = (dvma_vtob(dmabuf) & 0xffff);
+#else
+	udc_regs->addr_hi = (((unsigned long)(addr) & 0xff0000) >> 8);
+	udc_regs->addr_lo = ((unsigned long)(addr) & 0xffff);
+#endif
+	udc_regs->count = count/2; /* count in words */
+	udc_regs->mode_hi = UDC_MODE_HIWORD;
+	if(write_flag) {
+		if(count & 1)
+			udc_regs->count++;
+		udc_regs->mode_lo = UDC_MODE_LSEND;
+		udc_regs->rsel = UDC_RSEL_SEND;
+	} else {
+		udc_regs->mode_lo = UDC_MODE_LRECV;
+		udc_regs->rsel = UDC_RSEL_RECV;
+	}
+	
+	/* announce location of regs block */
+	sun3_udc_write(((dvma_vtob(udc_regs) & 0xff0000) >> 8),
+		       UDC_CHN_HI); 
+
+	sun3_udc_write((dvma_vtob(udc_regs) & 0xffff), UDC_CHN_LO);
+
+	/* set dma master on */
+	sun3_udc_write(0xd, UDC_MODE);
+
+	/* interrupt enable */
+	sun3_udc_write(UDC_INT_ENABLE, UDC_CSR);
+	
+       	return count;
+
+}
+
+static inline unsigned long sun3scsi_dma_count(struct Scsi_Host *instance)
+{
+	unsigned short resid;
+
+	dregs->udc_addr = 0x32; 
+	udelay(SUN3_DMA_DELAY);
+	resid = dregs->udc_data;
+	udelay(SUN3_DMA_DELAY);
+	resid *= 2;
+
+	return (unsigned long) resid;
+}
+
+static inline unsigned long sun3scsi_dma_residual(struct Scsi_Host *instance)
+{
+	return last_residual;
+}
+
+static inline unsigned long sun3scsi_dma_xfer_len(unsigned long wanted, Scsi_Cmnd *cmd,
+				    int write_flag)
+{
+	if(cmd->request->flags & REQ_CMD)
+ 		return wanted;
+	else
+		return 0;
+}
+
+static inline int sun3scsi_dma_start(unsigned long count, unsigned char *data)
+{
+
+    sun3_udc_write(UDC_CHN_START, UDC_CSR);
+    
+    return 0;
+}
+
+/* clean up after our dma is done */
+static int sun3scsi_dma_finish(int write_flag)
+{
+	unsigned short count;
+	unsigned short fifo;
+	int ret = 0;
+	
+	sun3_dma_active = 0;
+#if 1
+	// check to empty the fifo on a read
+	if(!write_flag) {
+		int tmo = 20000; /* .2 sec */
+		
+		while(1) {
+			if(dregs->csr & CSR_FIFO_EMPTY)
+				break;
+
+			if(--tmo <= 0) {
+				printk("sun3scsi: fifo failed to empty!\n");
+				return 1;
+			}
+			udelay(10);
+		}
+	}
+		
+#endif
+
+	count = sun3scsi_dma_count(default_instance);
+#ifdef OLDDMA
+
+	/* if we've finished a read, copy out the data we read */
+ 	if(sun3_dma_orig_addr) {
+		/* check for residual bytes after dma end */
+		if(count && (NCR5380_read(BUS_AND_STATUS_REG) &
+			     (BASR_PHASE_MATCH | BASR_ACK))) {
+			printk("scsi%d: sun3_scsi_finish: read overrun baby... ", default_instance->host_no);
+			printk("basr now %02x\n", NCR5380_read(BUS_AND_STATUS_REG));
+			ret = count;
+		}
+		
+		/* copy in what we dma'd no matter what */
+		memcpy(sun3_dma_orig_addr, dmabuf, sun3_dma_orig_count);
+		sun3_dma_orig_addr = NULL;
+
+	}
+#else
+
+	fifo = dregs->fifo_count;
+	last_residual = fifo;
+
+	/* empty bytes from the fifo which didn't make it */
+	if((!write_flag) && (count - fifo) == 2) {
+		unsigned short data;
+		unsigned char *vaddr;
+
+		data = dregs->fifo_data;
+		vaddr = (unsigned char *)dvma_btov(sun3_dma_orig_addr);
+		
+		vaddr += (sun3_dma_orig_count - fifo);
+
+		vaddr[-2] = (data & 0xff00) >> 8;
+		vaddr[-1] = (data & 0xff);
+	}
+
+	dvma_unmap(sun3_dma_orig_addr);
+	sun3_dma_orig_addr = NULL;
+#endif
+	sun3_udc_write(UDC_RESET, UDC_CSR);
+	dregs->fifo_count = 0;
+	dregs->csr &= ~CSR_SEND;
+
+	/* reset fifo */
+	dregs->csr &= ~CSR_FIFO;
+	dregs->csr |= CSR_FIFO;
+	
+	sun3_dma_setup_done = NULL;
+
+	return ret;
+
+}
+	
+#include "sun3_NCR5380.c"
+
+static Scsi_Host_Template driver_template = {
+	.name			= SUN3_SCSI_NAME,
+	.detect			= sun3scsi_detect,
+	.release		= sun3scsi_release,
+	.info			= sun3scsi_info,
+	.queuecommand		= sun3scsi_queue_command,
+	.eh_abort_handler      	= sun3scsi_abort,
+	.eh_bus_reset_handler  	= sun3scsi_bus_reset,
+	.can_queue		= CAN_QUEUE,
+	.this_id		= 7,
+	.sg_tablesize		= SG_TABLESIZE,
+	.cmd_per_lun		= CMD_PER_LUN,
+	.use_clustering		= DISABLE_CLUSTERING
+};
+
+
+#include "scsi_module.c"
+
+MODULE_LICENSE("GPL");
