commit 51dd905bd2f617f5d6e60273bb5f0940bbd86611
Author: Stanley Chu <stanley.chu@mediatek.com>
Date:   Fri May 22 16:32:12 2020 +0800

    scsi: ufs: Fix WriteBooster flush during runtime suspend
    
    Currently UFS host driver promises VCC supply if UFS device needs to do
    WriteBooster flush during runtime suspend.
    
    However the UFS specification mentions:
    
    "While the flushing operation is in progress, the device is in Active power
    mode."
    
    Therefore UFS host driver needs to promise more: Keep UFS device as "Active
    power mode", otherwise UFS device shall not do any flush if device enters
    Sleep or PowerDown power mode.  Similarly, the same promises shall be
    applied if device needs urgent BKOP during runtime suspend.
    
    Fix this by not changing device power mode if WriteBooster flush or urgent
    BKOP is required in ufshcd_suspend().
    
    Now, if device finishes its job but is not resumed for a very long time,
    system will have unnecessary power drain because VCC is still supplied. A
    method to re-check the threshold of keeping VCC supply is required to fix
    the power drain. However, the threshold re-check needs to re-activate the
    link first because the decision depends on the latest device status.
    
    Also introduce a delayed work to force runtime resume after a certain delay
    during runtime suspend. This makes threshold re-check happen natually in
    the entry of the next runtime-suspend. The device can continue its
    WriteBooster flush or urgent BKOP jobs soon after resumed if device has no
    upcoming requests and link enters hibern8 state either by Auto-Hibern8 or
    hibern8 during clk-gating scheme. This solution not only prevents power
    drain but also makes as much use of time as possible for device's
    background jobs.
    
    Link: https://lore.kernel.org/r/20200522083212.4008-5-stanley.chu@mediatek.com
    Reviewed-by: Asutosh Das <asutoshd@codeaurora.org>
    Signed-off-by: Stanley Chu <stanley.chu@mediatek.com>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/ufs/ufshcd.h b/drivers/scsi/ufs/ufshcd.h
index 9acaeaf94d29..bf97d616e597 100644
--- a/drivers/scsi/ufs/ufshcd.h
+++ b/drivers/scsi/ufs/ufshcd.h
@@ -745,6 +745,7 @@ struct ufs_hba {
 	struct request_queue	*bsg_queue;
 	bool wb_buf_flush_enabled;
 	bool wb_enabled;
+	struct delayed_work rpm_dev_flush_recheck_work;
 };
 
 /* Returns true if clocks can be gated. Otherwise false */

commit e31011ab370989022abf216c606f947a3b02a53a
Author: Stanley Chu <stanley.chu@mediatek.com>
Date:   Fri May 22 16:32:11 2020 +0800

    scsi: ufs: Fix index of attributes query for WriteBooster feature
    
    For WriteBooster feature related attributes, the index used by query shall
    be LUN ID if LU Dedicated buffer mode is enabled.
    
    Link: https://lore.kernel.org/r/20200522083212.4008-4-stanley.chu@mediatek.com
    Reviewed-by: Avri Altman <avri.altman@wdc.com>
    Reviewed-by: Asutosh Das <asutoshd@codeaurora.org>
    Signed-off-by: Stanley Chu <stanley.chu@mediatek.com>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/ufs/ufshcd.h b/drivers/scsi/ufs/ufshcd.h
index 88d420242782..9acaeaf94d29 100644
--- a/drivers/scsi/ufs/ufshcd.h
+++ b/drivers/scsi/ufs/ufshcd.h
@@ -868,7 +868,7 @@ static inline bool ufshcd_keep_autobkops_enabled_except_suspend(
 	return hba->caps & UFSHCD_CAP_KEEP_AUTO_BKOPS_ENABLED_EXCEPT_SUSPEND;
 }
 
-static inline u8 ufshcd_wb_get_flag_index(struct ufs_hba *hba)
+static inline u8 ufshcd_wb_get_query_index(struct ufs_hba *hba)
 {
 	if (hba->dev_info.b_wb_buffer_type == WB_BUF_MODE_LU_DEDICATED)
 		return hba->dev_info.wb_dedicated_lu;

commit 5cac1095cf289f7623f835a9212b9ec0ad3b85b3
Author: Bart Van Assche <bvanassche@acm.org>
Date:   Thu May 7 15:27:50 2020 -0700

    scsi: ufs: Make ufshcd_wait_for_register() sleep instead of busy-waiting
    
    The ufshcd_wait_for_register() function either sleeps or spins until the
    specified register has reached the desired value. Busy-waiting is not only
    considered a bad practice but also has a bad impact on energy
    consumption. Always sleep instead of spinning by making sure that all
    ufshcd_wait_for_register() calls happen from a context where it is allowed
    to sleep. The only function call that has to be moved is the
    ufshcd_hba_stop() call in ufshcd_host_reset_and_restore().
    
    Link: https://lore.kernel.org/r/20200507222750.19113-1-bvanassche@acm.org
    Cc: Can Guo <cang@codeaurora.org>
    Cc: Avri Altman <avri.altman@wdc.com>
    Cc: Bean Huo <beanhuo@micron.com>
    Cc: Alim Akhtar <alim.akhtar@samsung.com>
    Cc: Asutosh Das <asutoshd@codeaurora.org>
    Tested-by: Bean Huo <beanhuo@micron.com>
    Reviewed-by: Stanley Chu <stanley.chu@mediatek.com>
    Reviewed-by: Bean Huo <beanhuo@micron.com>
    Reviewed-by: Asutosh Das <asutoshd@codeaurora.org>
    Signed-off-by: Bart Van Assche <bvanassche@acm.org>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/ufs/ufshcd.h b/drivers/scsi/ufs/ufshcd.h
index e3dfb48e669e..88d420242782 100644
--- a/drivers/scsi/ufs/ufshcd.h
+++ b/drivers/scsi/ufs/ufshcd.h
@@ -831,7 +831,7 @@ int ufshcd_uic_hibern8_exit(struct ufs_hba *hba);
 void ufshcd_delay_us(unsigned long us, unsigned long tolerance);
 int ufshcd_wait_for_register(struct ufs_hba *hba, u32 reg, u32 mask,
 				u32 val, unsigned long interval_us,
-				unsigned long timeout_ms, bool can_sleep);
+				unsigned long timeout_ms);
 void ufshcd_parse_dev_ref_clk_freq(struct ufs_hba *hba, struct clk *refclk);
 void ufshcd_update_reg_hist(struct ufs_err_reg_hist *reg_hist,
 			    u32 reg);

commit d14734ae3ae79d3b0286a2431782054e5066da8f
Author: Stanley Chu <stanley.chu@mediatek.com>
Date:   Sat May 9 17:37:15 2020 +0800

    scsi: ufs: Customize flush threshold for WriteBooster
    
    Allow flush threshold for WriteBooster to be customizable by vendors. To
    achieve this, make the value a variable in struct ufs_hba_variant_params.
    
    Also introduce UFS_WB_BUF_REMAIN_PERCENT() macro to provide a more flexible
    way to specify WriteBooster available buffer values.
    
    Link: https://lore.kernel.org/r/20200509093716.21010-4-stanley.chu@mediatek.com
    Reviewed-by: Asutosh Das <asutoshd@codeaurora.org>
    Signed-off-by: Stanley Chu <stanley.chu@mediatek.com>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/ufs/ufshcd.h b/drivers/scsi/ufs/ufshcd.h
index f7bdf52ba8b0..e3dfb48e669e 100644
--- a/drivers/scsi/ufs/ufshcd.h
+++ b/drivers/scsi/ufs/ufshcd.h
@@ -570,6 +570,7 @@ struct ufs_hba_variant_params {
 	struct devfreq_dev_profile devfreq_profile;
 	struct devfreq_simple_ondemand_data ondemand_data;
 	u16 hba_enable_delay_us;
+	u32 wb_flush_threshold;
 };
 
 /**

commit 90b8491c0033915ec1b290bc1c0de27935cb132d
Author: Stanley Chu <stanley.chu@mediatek.com>
Date:   Sat May 9 17:37:13 2020 +0800

    scsi: ufs: Introduce ufs_hba_variant_params to group customizable parameters
    
    The UFS driver is growing more and more customizable parameters. Collect
    them in one place.
    
    Link: https://lore.kernel.org/r/20200509093716.21010-2-stanley.chu@mediatek.com
    Reviewed-by: Asutosh Das <asutoshd@codeaurora.org>
    Signed-off-by: Stanley Chu <stanley.chu@mediatek.com>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/ufs/ufshcd.h b/drivers/scsi/ufs/ufshcd.h
index 23a434c03c2a..f7bdf52ba8b0 100644
--- a/drivers/scsi/ufs/ufshcd.h
+++ b/drivers/scsi/ufs/ufshcd.h
@@ -566,6 +566,12 @@ enum ufshcd_caps {
 	UFSHCD_CAP_WB_EN				= 1 << 7,
 };
 
+struct ufs_hba_variant_params {
+	struct devfreq_dev_profile devfreq_profile;
+	struct devfreq_simple_ondemand_data ondemand_data;
+	u16 hba_enable_delay_us;
+};
+
 /**
  * struct ufs_hba - per adapter private structure
  * @mmio_base: UFSHCI base register address
@@ -663,6 +669,7 @@ struct ufs_hba {
 	int nutmrs;
 	u32 ufs_version;
 	const struct ufs_hba_variant_ops *vops;
+	struct ufs_hba_variant_params *vps;
 	void *priv;
 	unsigned int irq;
 	bool is_irq_enabled;
@@ -684,7 +691,6 @@ struct ufs_hba {
 	u32 eh_flags;
 	u32 intr_mask;
 	u16 ee_ctrl_mask;
-	u16 hba_enable_delay_us;
 	bool is_powered;
 
 	/* Work Queues */

commit 6f8d5a6a78cff85a7cbd1f9327e9aee25b0a48b2
Author: Stanley Chu <stanley.chu@mediatek.com>
Date:   Fri May 8 16:01:13 2020 +0800

    scsi: ufs: Add LU Dedicated buffer mode support for WriteBooster
    
    According to UFS specification, there are two WriteBooster mode of
    operations: "LU dedicated buffer" mode and "shared buffer" mode.  In the
    "LU dedicated buffer" mode, the WriteBooster Buffer is dedicated to a
    logical unit.
    
    If the device supports the "LU dedicated buffer" mode, this mode is
    configured by setting bWriteBoosterBufferType to 00h. The logical unit
    WriteBooster Buffer size is configured by setting the
    dLUNumWriteBoosterBufferAllocUnits field of the related Unit
    Descriptor. Only a value greater than zero enables the WriteBooster feature
    in the logical unit.
    
    Modify ufshcd_wb_probe() as above description to support LU Dedicated
    buffer mode.
    
    Note that according to UFS 3.1 specification, the valid value of
    bDeviceMaxWriteBoosterLUs parameter in Geometry Descriptor is 1, which
    means at most one LUN can have WriteBooster buffer in "LU dedicated buffer
    mode". Therefore this patch supports only one LUN with WriteBooster
    enabled. All WriteBooster related sysfs nodes are specifically mapped to
    the LUN with WriteBooster enabled in LU Dedicated buffer mode.
    
    Link: https://lore.kernel.org/r/20200508080115.24233-7-stanley.chu@mediatek.com
    Reviewed-by: Avri Altman <avri.altman@wdc.com>
    Reviewed-by: Bean Huo <beanhuo@micron.com>
    Reviewed-by: Asutosh Das <asutoshd@codeaurora.org>
    Signed-off-by: Stanley Chu <stanley.chu@mediatek.com>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/ufs/ufshcd.h b/drivers/scsi/ufs/ufshcd.h
index 8262a48eb9eb..23a434c03c2a 100644
--- a/drivers/scsi/ufs/ufshcd.h
+++ b/drivers/scsi/ufs/ufshcd.h
@@ -861,6 +861,13 @@ static inline bool ufshcd_keep_autobkops_enabled_except_suspend(
 	return hba->caps & UFSHCD_CAP_KEEP_AUTO_BKOPS_ENABLED_EXCEPT_SUSPEND;
 }
 
+static inline u8 ufshcd_wb_get_flag_index(struct ufs_hba *hba)
+{
+	if (hba->dev_info.b_wb_buffer_type == WB_BUF_MODE_LU_DEDICATED)
+		return hba->dev_info.wb_dedicated_lu;
+	return 0;
+}
+
 extern int ufshcd_runtime_suspend(struct ufs_hba *hba);
 extern int ufshcd_runtime_resume(struct ufs_hba *hba);
 extern int ufshcd_runtime_idle(struct ufs_hba *hba);

commit 1f34eedf9bc15d238aece3308aba0a21a1ef5fe2
Author: Stanley Chu <stanley.chu@mediatek.com>
Date:   Fri May 8 16:01:12 2020 +0800

    scsi: ufs: Add "index" in parameter list of ufshcd_query_flag()
    
    For preparation of LU Dedicated buffer mode support on WriteBooster
    feature, "index" parameter shall be added and allowed to be specified by
    callers.
    
    Link: https://lore.kernel.org/r/20200508080115.24233-6-stanley.chu@mediatek.com
    Reviewed-by: Bean Huo <beanhuo@micron.com>
    Reviewed-by: Avri Altman <avri.altman@wdc.com>
    Reviewed-by: Can Guo <cang@codeaurora.org>
    Reviewed-by: Asutosh Das <asutoshd@codeaurora.org>
    Signed-off-by: Stanley Chu <stanley.chu@mediatek.com>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/ufs/ufshcd.h b/drivers/scsi/ufs/ufshcd.h
index 4d296acadd6f..8262a48eb9eb 100644
--- a/drivers/scsi/ufs/ufshcd.h
+++ b/drivers/scsi/ufs/ufshcd.h
@@ -948,7 +948,7 @@ int ufshcd_read_desc_param(struct ufs_hba *hba,
 int ufshcd_query_attr(struct ufs_hba *hba, enum query_opcode opcode,
 		      enum attr_idn idn, u8 index, u8 selector, u32 *attr_val);
 int ufshcd_query_flag(struct ufs_hba *hba, enum query_opcode opcode,
-	enum flag_idn idn, bool *flag_res);
+	enum flag_idn idn, u8 index, bool *flag_res);
 
 void ufshcd_auto_hibern8_enable(struct ufs_hba *hba);
 void ufshcd_auto_hibern8_update(struct ufs_hba *hba, u32 ahit);

commit 8db269a5102eabfb05f4207f90e0a022caf7b804
Author: Stanley Chu <stanley.chu@mediatek.com>
Date:   Fri May 8 16:01:10 2020 +0800

    scsi: ufs: Export ufs_fixup_device_setup() function
    
    Export ufs_fixup_device_setup() to allow vendors to re-use it for fixing
    device quriks on specified UFS hosts.
    
    Link: https://lore.kernel.org/r/20200508080115.24233-4-stanley.chu@mediatek.com
    Reviewed-by: Avri Altman <avri.altman@wdc.com>
    Reviewed-by: Asutosh Das <asutoshd@codeaurora.org>
    Signed-off-by: Stanley Chu <stanley.chu@mediatek.com>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/ufs/ufshcd.h b/drivers/scsi/ufs/ufshcd.h
index 897338ba67aa..4d296acadd6f 100644
--- a/drivers/scsi/ufs/ufshcd.h
+++ b/drivers/scsi/ufs/ufshcd.h
@@ -952,6 +952,7 @@ int ufshcd_query_flag(struct ufs_hba *hba, enum query_opcode opcode,
 
 void ufshcd_auto_hibern8_enable(struct ufs_hba *hba);
 void ufshcd_auto_hibern8_update(struct ufs_hba *hba, u32 ahit);
+void ufshcd_fixup_dev_quirks(struct ufs_hba *hba, struct ufs_dev_fix *fixups);
 #define SD_ASCII_STD true
 #define SD_RAW false
 int ufshcd_read_string_desc(struct ufs_hba *hba, u8 desc_index,

commit c28c00ba4f060949c2f461f08a4aa10024a40672
Author: Stanley Chu <stanley.chu@mediatek.com>
Date:   Fri May 8 16:01:09 2020 +0800

    scsi: ufs: Introduce fixup_dev_quirks vops
    
    Some UFS deivces may have required device quirks or have non-standard
    features which are enabled only on specified UFS hosts or for special
    customers.
    
    To not "pollute" common device quirk list, i.e. ufs_fixups table, for those
    devices mentioned above, introduce "fixup_dev_quirks" vops to allow vendors
    to fix or modify device quirks accordingly.
    
    Link: https://lore.kernel.org/r/20200508080115.24233-3-stanley.chu@mediatek.com
    Reviewed-by: Avri Altman <avri.altman@wdc.com>
    Reviewed-by: Asutosh Das <asutoshd@codeaurora.org>
    Signed-off-by: Stanley Chu <stanley.chu@mediatek.com>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/ufs/ufshcd.h b/drivers/scsi/ufs/ufshcd.h
index 056537e52c19..897338ba67aa 100644
--- a/drivers/scsi/ufs/ufshcd.h
+++ b/drivers/scsi/ufs/ufshcd.h
@@ -69,6 +69,7 @@
 #include <scsi/scsi_eh.h>
 
 #include "ufs.h"
+#include "ufs_quirks.h"
 #include "ufshci.h"
 
 #define UFSHCD "ufshcd"
@@ -336,6 +337,7 @@ struct ufs_hba_variant_ops {
 	void    (*hibern8_notify)(struct ufs_hba *, enum uic_cmd_dme,
 					enum ufs_notify_change_status);
 	int	(*apply_dev_quirks)(struct ufs_hba *hba);
+	void	(*fixup_dev_quirks)(struct ufs_hba *hba);
 	int     (*suspend)(struct ufs_hba *, enum ufs_pm_op);
 	int     (*resume)(struct ufs_hba *, enum ufs_pm_op);
 	void	(*dbg_register_dump)(struct ufs_hba *hba);
@@ -950,7 +952,6 @@ int ufshcd_query_flag(struct ufs_hba *hba, enum query_opcode opcode,
 
 void ufshcd_auto_hibern8_enable(struct ufs_hba *hba);
 void ufshcd_auto_hibern8_update(struct ufs_hba *hba, u32 ahit);
-
 #define SD_ASCII_STD true
 #define SD_RAW false
 int ufshcd_read_string_desc(struct ufs_hba *hba, u8 desc_index,
@@ -1085,6 +1086,12 @@ static inline int ufshcd_vops_apply_dev_quirks(struct ufs_hba *hba)
 	return 0;
 }
 
+static inline void ufshcd_vops_fixup_dev_quirks(struct ufs_hba *hba)
+{
+	if (hba->vops && hba->vops->fixup_dev_quirks)
+		hba->vops->fixup_dev_quirks(hba);
+}
+
 static inline int ufshcd_vops_suspend(struct ufs_hba *hba, enum ufs_pm_op op)
 {
 	if (hba->vops && hba->vops->suspend)

commit 3d17b9b5ab11556b2fea07d4f24154095a685ad2
Author: Asutosh Das <asutoshd@codeaurora.org>
Date:   Wed Apr 22 14:41:42 2020 -0700

    scsi: ufs: Add write booster feature support
    
    The write performance of TLC NAND is considerably lower than SLC NAND.
    Using SLC NAND as a WriteBooster Buffer enables the write request to be
    processed with lower latency and improves the overall write performance.
    
    Adds support for shared-buffer mode WriteBooster.
    
    WriteBooster enable: SW enables it when clocks are scaled up, thus it's
    enabled only in high load conditions.
    
    WriteBooster disable: SW will disable the feature, when clocks are scaled
    down. Thus writes would go as normal writes.
    
    To keep the endurance of the WriteBooster Buffer at a maximum, this
    load-based toggling is adopted.
    
    Link: https://lore.kernel.org/r/2871444d9083b0e9323ef6d8ff1b544b7784adc9.1587591527.git.asutoshd@codeaurora.org
    Reviewed-by: Avri Altman <avri.altman@wdc.com>
    Signed-off-by: Asutosh Das <asutoshd@codeaurora.org>
    Signed-off-by: Subhash Jadavani <subhashj@codeaurora.org>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/ufs/ufshcd.h b/drivers/scsi/ufs/ufshcd.h
index 6ffc08ad85f6..056537e52c19 100644
--- a/drivers/scsi/ufs/ufshcd.h
+++ b/drivers/scsi/ufs/ufshcd.h
@@ -555,6 +555,13 @@ enum ufshcd_caps {
 	 * for userspace to control the power management.
 	 */
 	UFSHCD_CAP_RPM_AUTOSUSPEND			= 1 << 6,
+
+	/*
+	 * This capability allows the host controller driver to turn-on
+	 * WriteBooster, if the underlying device supports it and is
+	 * provisioned to be used. This would increase the write performance.
+	 */
+	UFSHCD_CAP_WB_EN				= 1 << 7,
 };
 
 /**
@@ -727,6 +734,8 @@ struct ufs_hba {
 
 	struct device		bsg_dev;
 	struct request_queue	*bsg_queue;
+	bool wb_buf_flush_enabled;
+	bool wb_enabled;
 };
 
 /* Returns true if clocks can be gated. Otherwise false */
@@ -775,6 +784,11 @@ static inline bool ufshcd_is_auto_hibern8_enabled(struct ufs_hba *hba)
 	return FIELD_GET(UFSHCI_AHIBERN8_TIMER_MASK, hba->ahit) ? true : false;
 }
 
+static inline bool ufshcd_is_wb_allowed(struct ufs_hba *hba)
+{
+	return hba->caps & UFSHCD_CAP_WB_EN;
+}
+
 #define ufshcd_writel(hba, val, reg)	\
 	writel((val), (hba)->mmio_base + (reg))
 #define ufshcd_readl(hba, reg)	\

commit 1764fa2ab97ade8de7269eb34f2740c54e38fc4a
Author: Stanley Chu <stanley.chu@mediatek.com>
Date:   Fri Mar 27 17:58:35 2020 +0800

    scsi: ufs: set device as active power mode after resetting device
    
    Currently ufshcd driver assumes that bInitPowerMode parameter is not
    changed by any vendors thus device power mode can be set as "Active" during
    initialization.
    
    According to UFS JEDEC specification, device power mode shall be "Active"
    after HW Reset is triggered if the bInitPowerMode parameter in Device
    Descriptor is default value.
    
    By above description, we can set device power mode as "Active" after device
    reset is triggered by vendor's callback. With this change, the link startup
    performance can be improved in some cases by not setting link_startup_again
    as true in ufshcd_link_startup().
    
    Link: https://lore.kernel.org/r/20200327095835.10293-1-stanley.chu@mediatek.com
    Reviewed-by: Can Guo <cang@codeaurora.org>
    Reviewed-by: Asutosh Das <asutoshd@codeaurora.org>
    Signed-off-by: Stanley Chu <stanley.chu@mediatek.com>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/ufs/ufshcd.h b/drivers/scsi/ufs/ufshcd.h
index fafc781fead9..6ffc08ad85f6 100644
--- a/drivers/scsi/ufs/ufshcd.h
+++ b/drivers/scsi/ufs/ufshcd.h
@@ -130,6 +130,19 @@ enum uic_link_state {
 #define ufshcd_set_link_hibern8(hba) ((hba)->uic_link_state = \
 				    UIC_LINK_HIBERN8_STATE)
 
+#define ufshcd_set_ufs_dev_active(h) \
+	((h)->curr_dev_pwr_mode = UFS_ACTIVE_PWR_MODE)
+#define ufshcd_set_ufs_dev_sleep(h) \
+	((h)->curr_dev_pwr_mode = UFS_SLEEP_PWR_MODE)
+#define ufshcd_set_ufs_dev_poweroff(h) \
+	((h)->curr_dev_pwr_mode = UFS_POWERDOWN_PWR_MODE)
+#define ufshcd_is_ufs_dev_active(h) \
+	((h)->curr_dev_pwr_mode == UFS_ACTIVE_PWR_MODE)
+#define ufshcd_is_ufs_dev_sleep(h) \
+	((h)->curr_dev_pwr_mode == UFS_SLEEP_PWR_MODE)
+#define ufshcd_is_ufs_dev_poweroff(h) \
+	((h)->curr_dev_pwr_mode == UFS_POWERDOWN_PWR_MODE)
+
 /*
  * UFS Power management levels.
  * Each level is in increasing order of power savings.
@@ -1084,6 +1097,7 @@ static inline void ufshcd_vops_device_reset(struct ufs_hba *hba)
 {
 	if (hba->vops && hba->vops->device_reset) {
 		hba->vops->device_reset(hba);
+		ufshcd_set_ufs_dev_active(hba);
 		ufshcd_update_reg_hist(&hba->ufs_stats.dev_reset, 0);
 	}
 }

commit 087c5efafa48661ac98184fbf8826a1a79dc5784
Author: Stanley Chu <stanley.chu@mediatek.com>
Date:   Fri Mar 27 17:53:28 2020 +0800

    scsi: ufs: export ufshcd_link_recovery
    
    Export ufshcd_link_recovery to allow vendors to recover failed link in
    vendor's callbacks.
    
    Link: https://lore.kernel.org/r/20200327095329.10083-2-stanley.chu@mediatek.com
    Reviewed-by: Avri Altman <avri.altman@wdc.com>
    Signed-off-by: Stanley Chu <stanley.chu@mediatek.com>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/ufs/ufshcd.h b/drivers/scsi/ufs/ufshcd.h
index dd1ee277069a..fafc781fead9 100644
--- a/drivers/scsi/ufs/ufshcd.h
+++ b/drivers/scsi/ufs/ufshcd.h
@@ -788,6 +788,7 @@ int ufshcd_alloc_host(struct device *, struct ufs_hba **);
 void ufshcd_dealloc_host(struct ufs_hba *);
 int ufshcd_hba_enable(struct ufs_hba *hba);
 int ufshcd_init(struct ufs_hba * , void __iomem * , unsigned int);
+int ufshcd_link_recovery(struct ufs_hba *hba);
 int ufshcd_make_hba_operational(struct ufs_hba *hba);
 void ufshcd_remove(struct ufs_hba *);
 int ufshcd_uic_hibern8_exit(struct ufs_hba *hba);

commit e89860f196fca353d1b93c95b6a5b4fd88178d3b
Author: Can Guo <cang@codeaurora.org>
Date:   Thu Mar 26 02:25:41 2020 -0700

    scsi: ufs: Do not rely on prefetched data
    
    We were setting bActiveICCLevel attribute for UFS device only once but the
    type of this attribute has changed from persistent to volatile since UFS
    device specification v2.1. This attribute is set to the default value after
    power cycle or hardware reset event. It isn't safe to rely on prefetched
    data (only used for bActiveICCLevel attribute now). Hence this change
    removes the code related to data prefetching and set this parameter on
    every attempt to probe the UFS device.
    
    Tested-by: Stanley Chu <stanley.chu@mediatek.com>
    Reviewed-by: Stanley Chu <stanley.chu@mediatek.com>
    Reviewed-by: Avri Altman <avri.altman@wdc.com>
    Signed-off-by: Can Guo <cang@codeaurora.org>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/ufs/ufshcd.h b/drivers/scsi/ufs/ufshcd.h
index fce7606b2857..dd1ee277069a 100644
--- a/drivers/scsi/ufs/ufshcd.h
+++ b/drivers/scsi/ufs/ufshcd.h
@@ -408,15 +408,6 @@ struct ufs_clk_scaling {
 	bool is_suspended;
 };
 
-/**
- * struct ufs_init_prefetch - contains data that is pre-fetched once during
- * initialization
- * @icc_level: icc level which was read during initialization
- */
-struct ufs_init_prefetch {
-	u32 icc_level;
-};
-
 #define UFS_ERR_REG_HIST_LENGTH 8
 /**
  * struct ufs_err_reg_hist - keeps history of errors
@@ -585,7 +576,6 @@ enum ufshcd_caps {
  * @intr_mask: Interrupt Mask Bits
  * @ee_ctrl_mask: Exception event control mask
  * @is_powered: flag to check if HBA is powered
- * @init_prefetch_data: data pre-fetched during initialization
  * @eh_work: Worker to handle UFS errors that require s/w attention
  * @eeh_work: Worker to handle exception events
  * @errors: HBA errors
@@ -674,7 +664,6 @@ struct ufs_hba {
 	u16 ee_ctrl_mask;
 	u16 hba_enable_delay_us;
 	bool is_powered;
-	struct ufs_init_prefetch init_prefetch_data;
 
 	/* Work Queues */
 	struct work_struct eh_work;

commit 2c75f9a5be53501a6e733cd72c1c46281eaa49a0
Author: Asutosh Das <asutoshd@codeaurora.org>
Date:   Wed Mar 25 11:29:01 2020 -0700

    scsi: ufshcd: Let vendor override devfreq parameters
    
    Vendor drivers may have a need to update the polling interval and
    thresholds.  Provide a vops for vendor drivers to use.
    
    Link: https://lore.kernel.org/r/acd79e00396cff855256adad47f615ccdbde85ac.1585160616.git.asutoshd@codeaurora.org
    Acked-by: Avri Altman <Avri.Altman@wdc.com>
    Signed-off-by: Asutosh Das <asutoshd@codeaurora.org>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/ufs/ufshcd.h b/drivers/scsi/ufs/ufshcd.h
index 9f1576bbfc50..fce7606b2857 100644
--- a/drivers/scsi/ufs/ufshcd.h
+++ b/drivers/scsi/ufs/ufshcd.h
@@ -56,6 +56,7 @@
 #include <linux/completion.h>
 #include <linux/regulator/consumer.h>
 #include <linux/bitfield.h>
+#include <linux/devfreq.h>
 #include "unipro.h"
 
 #include <asm/irq.h>
@@ -327,6 +328,9 @@ struct ufs_hba_variant_ops {
 	void	(*dbg_register_dump)(struct ufs_hba *hba);
 	int	(*phy_initialization)(struct ufs_hba *);
 	void	(*device_reset)(struct ufs_hba *hba);
+	void	(*config_scaling_param)(struct ufs_hba *hba,
+					struct devfreq_dev_profile *profile,
+					void *data);
 };
 
 /* clock gating state  */
@@ -1094,6 +1098,14 @@ static inline void ufshcd_vops_device_reset(struct ufs_hba *hba)
 	}
 }
 
+static inline void ufshcd_vops_config_scaling_param(struct ufs_hba *hba,
+						    struct devfreq_dev_profile
+						    *profile, void *data)
+{
+	if (hba->vops && hba->vops->config_scaling_param)
+		hba->vops->config_scaling_param(hba, profile, data);
+}
+
 extern struct ufs_pm_lvl_states ufs_pm_lvl_states[];
 
 /*

commit b9dc8aca2899fb494d66b6c5f50c25563d1636a7
Author: Stanley Chu <stanley.chu@mediatek.com>
Date:   Wed Mar 18 18:40:14 2020 +0800

    scsi: ufs: allow custom delay prior to host enabling
    
    Currently a 1 ms delay is applied before polling CONTROLLER_ENABLE
    bit. This delay may not be required or can be changed in different
    controllers. Make the delay as a changeable value in struct ufs_hba to
    allow it customized by vendors.
    
    Link: https://lore.kernel.org/r/20200318104016.28049-6-stanley.chu@mediatek.com
    Reviewed-by: Avri Altman <avri.altman@wdc.com>
    Reviewed-by: Can Guo <cang@codeaurora.org>
    Signed-off-by: Stanley Chu <stanley.chu@mediatek.com>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/ufs/ufshcd.h b/drivers/scsi/ufs/ufshcd.h
index 493674f99dcc..9f1576bbfc50 100644
--- a/drivers/scsi/ufs/ufshcd.h
+++ b/drivers/scsi/ufs/ufshcd.h
@@ -668,6 +668,7 @@ struct ufs_hba {
 	u32 eh_flags;
 	u32 intr_mask;
 	u16 ee_ctrl_mask;
+	u16 hba_enable_delay_us;
 	bool is_powered;
 	struct ufs_init_prefetch init_prefetch_data;
 

commit 5c955c10d0c26eb920f9cfad11adb58c93f666a0
Author: Stanley Chu <stanley.chu@mediatek.com>
Date:   Wed Mar 18 18:40:12 2020 +0800

    scsi: ufs: introduce common and flexible delay function
    
    Introduce a common delay function to provide flexible way for users to take
    choices of udelay and usleep_range into consideration according to the
    required delay time.
    
    Link: https://lore.kernel.org/r/20200318104016.28049-4-stanley.chu@mediatek.com
    Reviewed-by: Avri Altman <avri.altman@wdc.com>
    Reviewed-by: Can Guo <cang@codeaurora.org>
    Signed-off-by: Stanley Chu <stanley.chu@mediatek.com>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/ufs/ufshcd.h b/drivers/scsi/ufs/ufshcd.h
index 91a47ea61d9a..493674f99dcc 100644
--- a/drivers/scsi/ufs/ufshcd.h
+++ b/drivers/scsi/ufs/ufshcd.h
@@ -797,6 +797,7 @@ int ufshcd_init(struct ufs_hba * , void __iomem * , unsigned int);
 int ufshcd_make_hba_operational(struct ufs_hba *hba);
 void ufshcd_remove(struct ufs_hba *);
 int ufshcd_uic_hibern8_exit(struct ufs_hba *hba);
+void ufshcd_delay_us(unsigned long us, unsigned long tolerance);
 int ufshcd_wait_for_register(struct ufs_hba *hba, u32 reg, u32 mask,
 				u32 val, unsigned long interval_us,
 				unsigned long timeout_ms, bool can_sleep);

commit c2014682d03d80cfdf5eac440f8e96dce7dfe213
Author: Stanley Chu <stanley.chu@mediatek.com>
Date:   Wed Mar 18 18:40:11 2020 +0800

    scsi: ufs: use an enum for host capabilities
    
    Use an enum to specify the host capabilities instead of #defines inside the
    structure definition.
    
    Link: https://lore.kernel.org/r/20200318104016.28049-3-stanley.chu@mediatek.com
    Reviewed-by: Avri Altman <avri.altman@wdc.com>
    Reviewed-by: Can Guo <cang@codeaurora.org>
    Reviewed-by: Bean Huo <beanhuo@micron.com>
    Reviewed-by: Asutosh Das <asutoshd@codeaurora.org>
    Signed-off-by: Stanley Chu <stanley.chu@mediatek.com>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/ufs/ufshcd.h b/drivers/scsi/ufs/ufshcd.h
index d45a04444191..91a47ea61d9a 100644
--- a/drivers/scsi/ufs/ufshcd.h
+++ b/drivers/scsi/ufs/ufshcd.h
@@ -512,6 +512,43 @@ enum ufshcd_quirks {
 	UFSHCD_QUIRK_BROKEN_UFS_HCI_VERSION		= 1 << 5,
 };
 
+enum ufshcd_caps {
+	/* Allow dynamic clk gating */
+	UFSHCD_CAP_CLK_GATING				= 1 << 0,
+
+	/* Allow hiberb8 with clk gating */
+	UFSHCD_CAP_HIBERN8_WITH_CLK_GATING		= 1 << 1,
+
+	/* Allow dynamic clk scaling */
+	UFSHCD_CAP_CLK_SCALING				= 1 << 2,
+
+	/* Allow auto bkops to enabled during runtime suspend */
+	UFSHCD_CAP_AUTO_BKOPS_SUSPEND			= 1 << 3,
+
+	/*
+	 * This capability allows host controller driver to use the UFS HCI's
+	 * interrupt aggregation capability.
+	 * CAUTION: Enabling this might reduce overall UFS throughput.
+	 */
+	UFSHCD_CAP_INTR_AGGR				= 1 << 4,
+
+	/*
+	 * This capability allows the device auto-bkops to be always enabled
+	 * except during suspend (both runtime and suspend).
+	 * Enabling this capability means that device will always be allowed
+	 * to do background operation when it's active but it might degrade
+	 * the performance of ongoing read/write operations.
+	 */
+	UFSHCD_CAP_KEEP_AUTO_BKOPS_ENABLED_EXCEPT_SUSPEND = 1 << 5,
+
+	/*
+	 * This capability allows host controller driver to automatically
+	 * enable runtime power management by itself instead of waiting
+	 * for userspace to control the power management.
+	 */
+	UFSHCD_CAP_RPM_AUTOSUSPEND			= 1 << 6,
+};
+
 /**
  * struct ufs_hba - per adapter private structure
  * @mmio_base: UFSHCI base register address
@@ -669,34 +706,6 @@ struct ufs_hba {
 	struct ufs_clk_gating clk_gating;
 	/* Control to enable/disable host capabilities */
 	u32 caps;
-	/* Allow dynamic clk gating */
-#define UFSHCD_CAP_CLK_GATING	(1 << 0)
-	/* Allow hiberb8 with clk gating */
-#define UFSHCD_CAP_HIBERN8_WITH_CLK_GATING (1 << 1)
-	/* Allow dynamic clk scaling */
-#define UFSHCD_CAP_CLK_SCALING	(1 << 2)
-	/* Allow auto bkops to enabled during runtime suspend */
-#define UFSHCD_CAP_AUTO_BKOPS_SUSPEND (1 << 3)
-	/*
-	 * This capability allows host controller driver to use the UFS HCI's
-	 * interrupt aggregation capability.
-	 * CAUTION: Enabling this might reduce overall UFS throughput.
-	 */
-#define UFSHCD_CAP_INTR_AGGR (1 << 4)
-	/*
-	 * This capability allows the device auto-bkops to be always enabled
-	 * except during suspend (both runtime and suspend).
-	 * Enabling this capability means that device will always be allowed
-	 * to do background operation when it's active but it might degrade
-	 * the performance of ongoing read/write operations.
-	 */
-#define UFSHCD_CAP_KEEP_AUTO_BKOPS_ENABLED_EXCEPT_SUSPEND (1 << 5)
-	/*
-	 * This capability allows host controller driver to automatically
-	 * enable runtime power management by itself instead of waiting
-	 * for userspace to control the power management.
-	 */
-#define UFSHCD_CAP_RPM_AUTOSUSPEND (1 << 6)
 
 	struct devfreq *devfreq;
 	struct ufs_clk_scaling clk_scaling;

commit c3f7d1fcb4a26a0f2a45e0e3bd8a1acc19481b8c
Author: Christoph Hellwig <hch@lst.de>
Date:   Fri Feb 21 06:08:12 2020 -0800

    scsi: ufshcd: use an enum for quirks
    
    Use an enum to specify the various quirks instead of #defines inside the
    structure definition.
    
    [mkp: fix typo]
    
    Link: https://lore.kernel.org/r/20200221140812.476338-3-hch@lst.de
    Reviewed-by: Bart Van Assche <bvanassche@acm.org>
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/ufs/ufshcd.h b/drivers/scsi/ufs/ufshcd.h
index 6f22f466668f..d45a04444191 100644
--- a/drivers/scsi/ufs/ufshcd.h
+++ b/drivers/scsi/ufs/ufshcd.h
@@ -470,6 +470,48 @@ struct ufs_stats {
 	struct ufs_err_reg_hist task_abort;
 };
 
+enum ufshcd_quirks {
+	/* Interrupt aggregation support is broken */
+	UFSHCD_QUIRK_BROKEN_INTR_AGGR			= 1 << 0,
+
+	/*
+	 * delay before each dme command is required as the unipro
+	 * layer has shown instabilities
+	 */
+	UFSHCD_QUIRK_DELAY_BEFORE_DME_CMDS		= 1 << 1,
+
+	/*
+	 * If UFS host controller is having issue in processing LCC (Line
+	 * Control Command) coming from device then enable this quirk.
+	 * When this quirk is enabled, host controller driver should disable
+	 * the LCC transmission on UFS device (by clearing TX_LCC_ENABLE
+	 * attribute of device to 0).
+	 */
+	UFSHCD_QUIRK_BROKEN_LCC				= 1 << 2,
+
+	/*
+	 * The attribute PA_RXHSUNTERMCAP specifies whether or not the
+	 * inbound Link supports unterminated line in HS mode. Setting this
+	 * attribute to 1 fixes moving to HS gear.
+	 */
+	UFSHCD_QUIRK_BROKEN_PA_RXHSUNTERMCAP		= 1 << 3,
+
+	/*
+	 * This quirk needs to be enabled if the host controller only allows
+	 * accessing the peer dme attributes in AUTO mode (FAST AUTO or
+	 * SLOW AUTO).
+	 */
+	UFSHCD_QUIRK_DME_PEER_ACCESS_AUTO_MODE		= 1 << 4,
+
+	/*
+	 * This quirk needs to be enabled if the host controller doesn't
+	 * advertise the correct version in UFS_VER register. If this quirk
+	 * is enabled, standard UFS host driver will call the vendor specific
+	 * ops (get_ufs_hci_version) to get the correct version.
+	 */
+	UFSHCD_QUIRK_BROKEN_UFS_HCI_VERSION		= 1 << 5,
+};
+
 /**
  * struct ufs_hba - per adapter private structure
  * @mmio_base: UFSHCI base register address
@@ -573,46 +615,6 @@ struct ufs_hba {
 	bool is_irq_enabled;
 	enum ufs_ref_clk_freq dev_ref_clk_freq;
 
-	/* Interrupt aggregation support is broken */
-	#define UFSHCD_QUIRK_BROKEN_INTR_AGGR			0x1
-
-	/*
-	 * delay before each dme command is required as the unipro
-	 * layer has shown instabilities
-	 */
-	#define UFSHCD_QUIRK_DELAY_BEFORE_DME_CMDS		0x2
-
-	/*
-	 * If UFS host controller is having issue in processing LCC (Line
-	 * Control Command) coming from device then enable this quirk.
-	 * When this quirk is enabled, host controller driver should disable
-	 * the LCC transmission on UFS device (by clearing TX_LCC_ENABLE
-	 * attribute of device to 0).
-	 */
-	#define UFSHCD_QUIRK_BROKEN_LCC				0x4
-
-	/*
-	 * The attribute PA_RXHSUNTERMCAP specifies whether or not the
-	 * inbound Link supports unterminated line in HS mode. Setting this
-	 * attribute to 1 fixes moving to HS gear.
-	 */
-	#define UFSHCD_QUIRK_BROKEN_PA_RXHSUNTERMCAP		0x8
-
-	/*
-	 * This quirk needs to be enabled if the host contoller only allows
-	 * accessing the peer dme attributes in AUTO mode (FAST AUTO or
-	 * SLOW AUTO).
-	 */
-	#define UFSHCD_QUIRK_DME_PEER_ACCESS_AUTO_MODE		0x10
-
-	/*
-	 * This quirk needs to be enabled if the host contoller doesn't
-	 * advertise the correct version in UFS_VER register. If this quirk
-	 * is enabled, standard UFS host driver will call the vendor specific
-	 * ops (get_ufs_hci_version) to get the correct version.
-	 */
-	#define UFSHCD_QUIRK_BROKEN_UFS_HCI_VERSION		0x20
-
 	unsigned int quirks;	/* Deviations from standard UFSHCI spec. */
 
 	/* Device deviations from standard UFS device spec. */

commit 492001990f641b0d0df4dbd45c759785fda76f5b
Author: Christoph Hellwig <hch@lst.de>
Date:   Fri Feb 21 06:08:11 2020 -0800

    scsi: ufshcd: remove unused quirks
    
    Remove various quirks that don't have users, as well as the dead code keyed
    off them.
    
    Link: https://lore.kernel.org/r/20200221140812.476338-2-hch@lst.de
    Reviewed-by: Bart Van Assche <bvanassche@acm.org>
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/ufs/ufshcd.h b/drivers/scsi/ufs/ufshcd.h
index 8f516b205c32..6f22f466668f 100644
--- a/drivers/scsi/ufs/ufshcd.h
+++ b/drivers/scsi/ufs/ufshcd.h
@@ -613,28 +613,6 @@ struct ufs_hba {
 	 */
 	#define UFSHCD_QUIRK_BROKEN_UFS_HCI_VERSION		0x20
 
-	/*
-	 * This quirk needs to be enabled if the host contoller regards
-	 * resolution of the values of PRDTO and PRDTL in UTRD as byte.
-	 */
-	#define UFSHCD_QUIRK_PRDT_BYTE_GRAN			0x80
-
-	/*
-	 * Clear handling for transfer/task request list is just opposite.
-	 */
-	#define UFSHCI_QUIRK_BROKEN_REQ_LIST_CLR		0x100
-
-	/*
-	 * This quirk needs to be enabled if host controller doesn't allow
-	 * that the interrupt aggregation timer and counter are reset by s/w.
-	 */
-	#define UFSHCI_QUIRK_SKIP_RESET_INTR_AGGR		0x200
-
-	/*
-	 * This quirks needs to be enabled if host controller cannot be
-	 * enabled via HCE register.
-	 */
-	#define UFSHCI_QUIRK_BROKEN_HCE				0x400
 	unsigned int quirks;	/* Deviations from standard UFSHCI spec. */
 
 	/* Device deviations from standard UFS device spec. */

commit 984eaac133e3d6d993ffd4de9e4bdc2c94de742b
Author: Stanley Chu <stanley.chu@mediatek.com>
Date:   Fri Feb 7 15:03:57 2020 +0800

    scsi: ufs: introduce common function to disable host TX LCC
    
    Many vendors would like to disable host TX LCC during initialization
    flow. Introduce a common function for all users to make drivers easier to
    read and maintained. This patch does not change any functionality.
    
    Link: https://lore.kernel.org/r/20200207070357.17169-3-stanley.chu@mediatek.com
    Reviewed-by: Can Guo <cang@codeaurora.org>
    Reviewed-by: Avri Altman <avri.altman@wdc.com>
    Reviewed-by: Asutosh Das <asutoshd@codeaurora.org>
    Signed-off-by: Stanley Chu <stanley.chu@mediatek.com>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/ufs/ufshcd.h b/drivers/scsi/ufs/ufshcd.h
index 81c71a3e3474..8f516b205c32 100644
--- a/drivers/scsi/ufs/ufshcd.h
+++ b/drivers/scsi/ufs/ufshcd.h
@@ -914,6 +914,11 @@ static inline bool ufshcd_is_hs_mode(struct ufs_pa_layer_attr *pwr_info)
 		pwr_info->pwr_tx == FASTAUTO_MODE);
 }
 
+static inline int ufshcd_disable_host_tx_lcc(struct ufs_hba *hba)
+{
+	return ufshcd_dme_set(hba, UIC_ARG_MIB(PA_LOCAL_TX_LCC_ENABLE), 0);
+}
+
 /* Expose Query-Request API */
 int ufshcd_query_descriptor_retry(struct ufs_hba *hba,
 				  enum query_opcode opcode,

commit 5a244e0ea67b293abb1d26c825db2ddde5f2862f
Author: Stanley Chu <stanley.chu@mediatek.com>
Date:   Wed Jan 29 18:52:50 2020 +0800

    scsi: ufs: fix Auto-Hibern8 error detection
    
    Auto-Hibern8 may be disabled by some vendors or sysfs in runtime even if
    Auto-Hibern8 capability is supported by host. If Auto-Hibern8 capability is
    supported by host but not actually enabled, Auto-Hibern8 error shall not
    happen.
    
    To fix this, provide a way to detect if Auto-Hibern8 is actually enabled
    first, and bypass Auto-Hibern8 disabling case in
    ufshcd_is_auto_hibern8_error().
    
    Fixes: 821744403913 ("scsi: ufs: Add error-handling of Auto-Hibernate")
    Cc: stable@vger.kernel.org
    Link: https://lore.kernel.org/r/20200129105251.12466-4-stanley.chu@mediatek.com
    Reviewed-by: Bean Huo <beanhuo@micron.com>
    Reviewed-by: Alim Akhtar <alim.akhtar@samsung.com>
    Reviewed-by: Asutosh Das <asutoshd@codeaurora.org>
    Reviewed-by: Can Guo <cang@codeaurora.org>
    Signed-off-by: Stanley Chu <stanley.chu@mediatek.com>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/ufs/ufshcd.h b/drivers/scsi/ufs/ufshcd.h
index 2ae6c7c8528c..81c71a3e3474 100644
--- a/drivers/scsi/ufs/ufshcd.h
+++ b/drivers/scsi/ufs/ufshcd.h
@@ -55,6 +55,7 @@
 #include <linux/clk.h>
 #include <linux/completion.h>
 #include <linux/regulator/consumer.h>
+#include <linux/bitfield.h>
 #include "unipro.h"
 
 #include <asm/irq.h>
@@ -773,6 +774,11 @@ static inline bool ufshcd_is_auto_hibern8_supported(struct ufs_hba *hba)
 	return (hba->capabilities & MASK_AUTO_HIBERN8_SUPPORT);
 }
 
+static inline bool ufshcd_is_auto_hibern8_enabled(struct ufs_hba *hba)
+{
+	return FIELD_GET(UFSHCI_AHIBERN8_TIMER_MASK, hba->ahit) ? true : false;
+}
+
 #define ufshcd_writel(hba, val, reg)	\
 	writel((val), (hba)->mmio_base + (reg))
 #define ufshcd_readl(hba, reg)	\

commit 046c1e6f2707890a2e64f3f15388ca389aaebcbf
Author: Bean Huo <beanhuo@micron.com>
Date:   Mon Jan 20 14:08:18 2020 +0100

    scsi: ufs: Delete is_init_prefetch from struct ufs_hba
    
    Without variable is_init_prefetch, the current logic can guarantee
    ufshcd_init_icc_levels() will execute only once, delete it now.
    
    Link: https://lore.kernel.org/r/20200120130820.1737-7-huobean@gmail.com
    Reviewed-by: Asutosh Das <asutoshd@codeaurora.org>
    Signed-off-by: Bean Huo <beanhuo@micron.com>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/ufs/ufshcd.h b/drivers/scsi/ufs/ufshcd.h
index 961d6737cd15..2ae6c7c8528c 100644
--- a/drivers/scsi/ufs/ufshcd.h
+++ b/drivers/scsi/ufs/ufshcd.h
@@ -501,7 +501,6 @@ struct ufs_stats {
  * @intr_mask: Interrupt Mask Bits
  * @ee_ctrl_mask: Exception event control mask
  * @is_powered: flag to check if HBA is powered
- * @is_init_prefetch: flag to check if data was pre-fetched in initialization
  * @init_prefetch_data: data pre-fetched during initialization
  * @eh_work: Worker to handle UFS errors that require s/w attention
  * @eeh_work: Worker to handle exception events
@@ -652,7 +651,6 @@ struct ufs_hba {
 	u32 intr_mask;
 	u16 ee_ctrl_mask;
 	bool is_powered;
-	bool is_init_prefetch;
 	struct ufs_init_prefetch init_prefetch_data;
 
 	/* Work Queues */

commit 097500666ec9912a9245160e0e53c1e3944d80d9
Author: Bean Huo <beanhuo@micron.com>
Date:   Mon Jan 20 14:08:14 2020 +0100

    scsi: ufs: Delete struct ufs_dev_desc
    
    In consideration of UFS host driver uses parameters of struct ufs_dev_desc,
    move its parameters to struct ufs_dev_info, delete struct ufs_dev_desc.
    
    Link: https://lore.kernel.org/r/20200120130820.1737-3-huobean@gmail.com
    Reviewed-by: Bart Van Assche <bvanassche@acm.org>
    Reviewed-by: Asutosh Das <asutoshd@codeaurora.org>
    Reviewed-by: Alim Akhtar <alim.akhtar@samsung.com>
    Reviewed-by: Stanley Chu <stanley.chu@mediatek.com>
    Signed-off-by: Bean Huo <beanhuo@micron.com>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/ufs/ufshcd.h b/drivers/scsi/ufs/ufshcd.h
index fca372d98495..961d6737cd15 100644
--- a/drivers/scsi/ufs/ufshcd.h
+++ b/drivers/scsi/ufs/ufshcd.h
@@ -320,7 +320,7 @@ struct ufs_hba_variant_ops {
 	void	(*setup_task_mgmt)(struct ufs_hba *, int, u8);
 	void    (*hibern8_notify)(struct ufs_hba *, enum uic_cmd_dme,
 					enum ufs_notify_change_status);
-	int	(*apply_dev_quirks)(struct ufs_hba *, struct ufs_dev_desc *);
+	int	(*apply_dev_quirks)(struct ufs_hba *hba);
 	int     (*suspend)(struct ufs_hba *, enum ufs_pm_op);
 	int     (*resume)(struct ufs_hba *, enum ufs_pm_op);
 	void	(*dbg_register_dump)(struct ufs_hba *hba);
@@ -1057,11 +1057,10 @@ static inline void ufshcd_vops_hibern8_notify(struct ufs_hba *hba,
 		return hba->vops->hibern8_notify(hba, cmd, status);
 }
 
-static inline int ufshcd_vops_apply_dev_quirks(struct ufs_hba *hba,
-					       struct ufs_dev_desc *card)
+static inline int ufshcd_vops_apply_dev_quirks(struct ufs_hba *hba)
 {
 	if (hba->vops && hba->vops->apply_dev_quirks)
-		return hba->vops->apply_dev_quirks(hba, card);
+		return hba->vops->apply_dev_quirks(hba);
 	return 0;
 }
 

commit 9d19bf7ad168a8ef5fe0e1cdd64313d76207934a
Author: Stanley Chu <stanley.chu@mediatek.com>
Date:   Fri Jan 17 11:51:07 2020 +0800

    scsi: ufs: export some functions for vendor usage
    
    Export below functions for vendor usage:
    
    int ufshcd_hba_enable(struct ufs_hba *hba);
    int ufshcd_make_hba_operational(struct ufs_hba *hba);
    int ufshcd_uic_hibern8_exit(struct ufs_hba *hba);
    
    Link: https://lore.kernel.org/r/20200117035108.19699-3-stanley.chu@mediatek.com
    Reviewed-by: Alim Akhtar <alim.akhtar@samsung.com>
    Reviewed-by: Asutosh Das <asutoshd@codeaurora.org>
    Signed-off-by: Stanley Chu <stanley.chu@mediatek.com>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/ufs/ufshcd.h b/drivers/scsi/ufs/ufshcd.h
index b1a1c65be8b1..fca372d98495 100644
--- a/drivers/scsi/ufs/ufshcd.h
+++ b/drivers/scsi/ufs/ufshcd.h
@@ -799,8 +799,11 @@ static inline void ufshcd_rmwl(struct ufs_hba *hba, u32 mask, u32 val, u32 reg)
 
 int ufshcd_alloc_host(struct device *, struct ufs_hba **);
 void ufshcd_dealloc_host(struct ufs_hba *);
+int ufshcd_hba_enable(struct ufs_hba *hba);
 int ufshcd_init(struct ufs_hba * , void __iomem * , unsigned int);
+int ufshcd_make_hba_operational(struct ufs_hba *hba);
 void ufshcd_remove(struct ufs_hba *);
+int ufshcd_uic_hibern8_exit(struct ufs_hba *hba);
 int ufshcd_wait_for_register(struct ufs_hba *hba, u32 reg, u32 mask,
 				u32 val, unsigned long interval_us,
 				unsigned long timeout_ms, bool can_sleep);

commit c40ad6b7fcd35bc4d36db820c7737e1aa18d5d41
Author: Stanley Chu <stanley.chu@mediatek.com>
Date:   Sat Jan 11 15:11:46 2020 +0800

    scsi: ufs: pass device information to apply_dev_quirks
    
    Pass UFS device information to vendor-specific variant callback
    "apply_dev_quirks" because some platform vendors need to know such
    information to apply special handling or quirks in specific devices.
    
    At the same time, modify existing vendor implementations according to the
    new interface for those vendor drivers which will be built-in or built as a
    module alone with UFS core driver.
    
    [mkp: clarified commit desc]
    
    Cc: Alim Akhtar <alim.akhtar@samsung.com>
    Cc: Asutosh Das <asutoshd@codeaurora.org>
    Cc: Avri Altman <avri.altman@wdc.com>
    Cc: Bart Van Assche <bvanassche@acm.org>
    Cc: Bean Huo <beanhuo@micron.com>
    Cc: Can Guo <cang@codeaurora.org>
    Cc: Matthias Brugger <matthias.bgg@gmail.com>
    Link: https://lore.kernel.org/r/1578726707-6596-2-git-send-email-stanley.chu@mediatek.com
    Reviewed-by: Avri Altman <avri.altman@wdc.com>
    Reviewed-by: Bean Huo <beanhuo@micron.com>
    Signed-off-by: Stanley Chu <stanley.chu@mediatek.com>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/ufs/ufshcd.h b/drivers/scsi/ufs/ufshcd.h
index de1be6a862b0..b1a1c65be8b1 100644
--- a/drivers/scsi/ufs/ufshcd.h
+++ b/drivers/scsi/ufs/ufshcd.h
@@ -320,7 +320,7 @@ struct ufs_hba_variant_ops {
 	void	(*setup_task_mgmt)(struct ufs_hba *, int, u8);
 	void    (*hibern8_notify)(struct ufs_hba *, enum uic_cmd_dme,
 					enum ufs_notify_change_status);
-	int	(*apply_dev_quirks)(struct ufs_hba *);
+	int	(*apply_dev_quirks)(struct ufs_hba *, struct ufs_dev_desc *);
 	int     (*suspend)(struct ufs_hba *, enum ufs_pm_op);
 	int     (*resume)(struct ufs_hba *, enum ufs_pm_op);
 	void	(*dbg_register_dump)(struct ufs_hba *hba);
@@ -1054,10 +1054,11 @@ static inline void ufshcd_vops_hibern8_notify(struct ufs_hba *hba,
 		return hba->vops->hibern8_notify(hba, cmd, status);
 }
 
-static inline int ufshcd_vops_apply_dev_quirks(struct ufs_hba *hba)
+static inline int ufshcd_vops_apply_dev_quirks(struct ufs_hba *hba,
+					       struct ufs_dev_desc *card)
 {
 	if (hba->vops && hba->vops->apply_dev_quirks)
-		return hba->vops->apply_dev_quirks(hba);
+		return hba->vops->apply_dev_quirks(hba, card);
 	return 0;
 }
 

commit a5fe372d92396bbcae2e2688e542d8d77e34662b
Author: Stanley Chu <stanley.chu@mediatek.com>
Date:   Sat Jan 4 22:26:07 2020 +0800

    scsi: ufs: add device reset history for vendor implementations
    
    Device reset history shall be also added for vendor's device reset variant
    operation implementation.
    
    Cc: Alim Akhtar <alim.akhtar@samsung.com>
    Cc: Asutosh Das <asutoshd@codeaurora.org>
    Cc: Avri Altman <avri.altman@wdc.com>
    Cc: Bart Van Assche <bvanassche@acm.org>
    Cc: Bean Huo <beanhuo@micron.com>
    Cc: Can Guo <cang@codeaurora.org>
    Cc: Matthias Brugger <matthias.bgg@gmail.com>
    Link: https://lore.kernel.org/r/1578147968-30938-3-git-send-email-stanley.chu@mediatek.com
    Reviewed-by: Bean Huo <beanhuo@micron.com>
    Reviewed-by: Asutosh Das <asutoshd@codeaurora.org>
    Signed-off-by: Stanley Chu <stanley.chu@mediatek.com>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/ufs/ufshcd.h b/drivers/scsi/ufs/ufshcd.h
index e05cafddc87b..de1be6a862b0 100644
--- a/drivers/scsi/ufs/ufshcd.h
+++ b/drivers/scsi/ufs/ufshcd.h
@@ -805,6 +805,8 @@ int ufshcd_wait_for_register(struct ufs_hba *hba, u32 reg, u32 mask,
 				u32 val, unsigned long interval_us,
 				unsigned long timeout_ms, bool can_sleep);
 void ufshcd_parse_dev_ref_clk_freq(struct ufs_hba *hba, struct clk *refclk);
+void ufshcd_update_reg_hist(struct ufs_err_reg_hist *reg_hist,
+			    u32 reg);
 
 static inline void check_upiu_size(void)
 {
@@ -1083,8 +1085,10 @@ static inline void ufshcd_vops_dbg_register_dump(struct ufs_hba *hba)
 
 static inline void ufshcd_vops_device_reset(struct ufs_hba *hba)
 {
-	if (hba->vops && hba->vops->device_reset)
+	if (hba->vops && hba->vops->device_reset) {
 		hba->vops->device_reset(hba);
+		ufshcd_update_reg_hist(&hba->ufs_stats.dev_reset, 0);
+	}
 }
 
 extern struct ufs_pm_lvl_states ufs_pm_lvl_states[];

commit ba7af5ec5126dca17cdc8cfdb6740cdfb4bad70c
Author: Stanley Chu <stanley.chu@mediatek.com>
Date:   Mon Dec 30 13:32:28 2019 +0800

    scsi: ufs: export ufshcd_auto_hibern8_update for vendor usage
    
    Export ufshcd_auto_hibern8_update to allow vendors to use common interface
    to customize auto-hibernate timer.
    
    Cc: Alim Akhtar <alim.akhtar@samsung.com>
    Cc: Avri Altman <avri.altman@wdc.com>
    Cc: Bart Van Assche <bvanassche@acm.org>
    Cc: Bean Huo <beanhuo@micron.com>
    Cc: Can Guo <cang@codeaurora.org>
    Cc: Florian Fainelli <f.fainelli@gmail.com>
    Cc: Matthias Brugger <matthias.bgg@gmail.com>
    Link: https://lore.kernel.org/r/1577683950-1702-5-git-send-email-stanley.chu@mediatek.com
    Reviewed-by: Asutosh Das <asutoshd@codeaurora.org>
    Reviewed-by: Alim Akhtar <alim.akhtar@samsung.com>
    Signed-off-by: Stanley Chu <stanley.chu@mediatek.com>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/ufs/ufshcd.h b/drivers/scsi/ufs/ufshcd.h
index b536a26d665e..e05cafddc87b 100644
--- a/drivers/scsi/ufs/ufshcd.h
+++ b/drivers/scsi/ufs/ufshcd.h
@@ -923,6 +923,7 @@ int ufshcd_query_flag(struct ufs_hba *hba, enum query_opcode opcode,
 	enum flag_idn idn, bool *flag_res);
 
 void ufshcd_auto_hibern8_enable(struct ufs_hba *hba);
+void ufshcd_auto_hibern8_update(struct ufs_hba *hba, u32 ahit);
 
 #define SD_ASCII_STD true
 #define SD_RAW false

commit 2df74b6985b51e77756e2e8faa16c45ca3ba53c5
Author: Can Guo <cang@codeaurora.org>
Date:   Mon Nov 25 22:53:33 2019 -0800

    scsi: ufs: Complete pending requests in host reset and restore path
    
    In UFS host reset and restore path, before probe, we stop and start the
    host controller once. After host controller is stopped, the pending
    requests, if any, are cleared from the doorbell, but no completion IRQ
    would be raised due to the hba is stopped.  These pending requests shall be
    completed along with the first NOP_OUT command (as it is the first command
    which can raise a transfer completion IRQ) sent during probe.  Since the
    OCSs of these pending requests are not SUCCESS (because they are not yet
    literally finished), their UPIUs shall be dumped. When there are multiple
    pending requests, the UPIU dump can be overwhelming and may lead to
    stability issues because it is in atomic context.  Therefore, before probe,
    complete these pending requests right after host controller is stopped and
    silence the UPIU dump from them.
    
    Link: https://lore.kernel.org/r/1574751214-8321-5-git-send-email-cang@qti.qualcomm.com
    Reviewed-by: Alim Akhtar <alim.akhtar@samsung.com>
    Reviewed-by: Bean Huo <beanhuo@micron.com>
    Tested-by: Bean Huo <beanhuo@micron.com>
    Signed-off-by: Can Guo <cang@codeaurora.org>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/ufs/ufshcd.h b/drivers/scsi/ufs/ufshcd.h
index 53bfe175342c..b536a26d665e 100644
--- a/drivers/scsi/ufs/ufshcd.h
+++ b/drivers/scsi/ufs/ufshcd.h
@@ -509,6 +509,7 @@ struct ufs_stats {
  * @uic_error: UFS interconnect layer error status
  * @saved_err: sticky error mask
  * @saved_uic_err: sticky UIC error mask
+ * @silence_err_logs: flag to silence error logs
  * @dev_cmd: ufs device management command information
  * @last_dme_cmd_tstamp: time stamp of the last completed DME command
  * @auto_bkops_enabled: to track whether bkops is enabled in device
@@ -664,6 +665,7 @@ struct ufs_hba {
 	u32 saved_err;
 	u32 saved_uic_err;
 	struct ufs_stats ufs_stats;
+	bool silence_err_logs;
 
 	/* Device management request data */
 	struct ufs_dev_cmd dev_cmd;

commit 69a6c269c097d780a2db320ecd47f7a62fafd92e
Author: Bart Van Assche <bvanassche@acm.org>
Date:   Mon Dec 9 10:13:09 2019 -0800

    scsi: ufs: Use blk_{get,put}_request() to allocate and free TMFs
    
    Manage TMF tags with blk_{get,put}_request() instead of
    ufshcd_get_tm_free_slot() / ufshcd_put_tm_slot(). Store a per-request
    completion pointer in request.end_io_data instead of using a waitqueue to
    report TMF completion.
    
    Cc: Can Guo <cang@codeaurora.org>
    Cc: Stanley Chu <stanley.chu@mediatek.com>
    Cc: Avri Altman <avri.altman@wdc.com>
    Cc: Tomas Winkler <tomas.winkler@intel.com>
    Link: https://lore.kernel.org/r/20191209181309.196233-3-bvanassche@acm.org
    Tested-by: Bean Huo <beanhuo@micron.com>
    Reviewed-by: Avri Altman <avri.altman@wdc.com>
    Signed-off-by: Bart Van Assche <bvanassche@acm.org>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/ufs/ufshcd.h b/drivers/scsi/ufs/ufshcd.h
index 56b9da6db1cc..53bfe175342c 100644
--- a/drivers/scsi/ufs/ufshcd.h
+++ b/drivers/scsi/ufs/ufshcd.h
@@ -493,11 +493,9 @@ struct ufs_stats {
  * @irq: Irq number of the controller
  * @active_uic_cmd: handle of active UIC command
  * @uic_cmd_mutex: mutex for uic command
- * @tm_wq: wait queue for task management
- * @tm_tag_wq: wait queue for free task management slots
- * @tm_slots_in_use: bit map of task management request slots in use
+ * @tmf_tag_set: TMF tag set.
+ * @tmf_queue: Used to allocate TMF tags.
  * @pwr_done: completion for power mode change
- * @tm_condition: condition variable for task management
  * @ufshcd_state: UFSHCD states
  * @eh_flags: Error handling flags
  * @intr_mask: Interrupt Mask Bits
@@ -641,10 +639,8 @@ struct ufs_hba {
 	/* Device deviations from standard UFS device spec. */
 	unsigned int dev_quirks;
 
-	wait_queue_head_t tm_wq;
-	wait_queue_head_t tm_tag_wq;
-	unsigned long tm_condition;
-	unsigned long tm_slots_in_use;
+	struct blk_mq_tag_set tmf_tag_set;
+	struct request_queue *tmf_queue;
 
 	struct uic_command *active_uic_cmd;
 	struct mutex uic_cmd_mutex;

commit 7252a3603015f1fd04363956f4b72a537c9f9c42
Author: Bart Van Assche <bvanassche@acm.org>
Date:   Mon Dec 9 10:13:08 2019 -0800

    scsi: ufs: Avoid busy-waiting by eliminating tag conflicts
    
    Instead of tracking which tags are in use in the ufs_hba.lrb_in_use
    bitmask, rely on the block layer tag allocation mechanism. This patch
    removes the following busy-waiting loop if ufshcd_issue_devman_upiu_cmd()
    and the block layer accidentally allocate the same tag for a SCSI request:
    
     * ufshcd_queuecommand() returns SCSI_MLQUEUE_HOST_BUSY.
    
     * The SCSI core requeues the SCSI command.
    
    Cc: Can Guo <cang@codeaurora.org>
    Cc: Stanley Chu <stanley.chu@mediatek.com>
    Cc: Avri Altman <avri.altman@wdc.com>
    Cc: Tomas Winkler <tomas.winkler@intel.com>
    Link: https://lore.kernel.org/r/20191209181309.196233-2-bvanassche@acm.org
    Tested-by: Bean Huo <beanhuo@micron.com>
    Reviewed-by: Avri Altman <avri.altman@wdc.com>
    Signed-off-by: Bart Van Assche <bvanassche@acm.org>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/ufs/ufshcd.h b/drivers/scsi/ufs/ufshcd.h
index 2740f6941ec6..56b9da6db1cc 100644
--- a/drivers/scsi/ufs/ufshcd.h
+++ b/drivers/scsi/ufs/ufshcd.h
@@ -212,13 +212,11 @@ struct ufs_query {
  * @type: device management command type - Query, NOP OUT
  * @lock: lock to allow one command at a time
  * @complete: internal commands completion
- * @tag_wq: wait queue until free command slot is available
  */
 struct ufs_dev_cmd {
 	enum dev_cmd_type type;
 	struct mutex lock;
 	struct completion *complete;
-	wait_queue_head_t tag_wq;
 	struct ufs_query query;
 };
 
@@ -483,7 +481,7 @@ struct ufs_stats {
  * @host: Scsi_Host instance of the driver
  * @dev: device handle
  * @lrb: local reference block
- * @lrb_in_use: lrb in use
+ * @cmd_queue: Used to allocate command tags from hba->host->tag_set.
  * @outstanding_tasks: Bits representing outstanding task requests
  * @outstanding_reqs: Bits representing outstanding transfer requests
  * @capabilities: UFS Controller Capabilities
@@ -541,6 +539,7 @@ struct ufs_hba {
 
 	struct Scsi_Host *host;
 	struct device *dev;
+	struct request_queue *cmd_queue;
 	/*
 	 * This field is to keep a reference to "scsi_device" corresponding to
 	 * "UFS device" W-LU.
@@ -561,7 +560,6 @@ struct ufs_hba {
 	u32 ahit;
 
 	struct ufshcd_lrb *lrb;
-	unsigned long lrb_in_use;
 
 	unsigned long outstanding_tasks;
 	unsigned long outstanding_reqs;

commit 71d848b8d97ec0f8e993d63cf9de6ac8b3f7c43d
Author: Can Guo <cang@codeaurora.org>
Date:   Thu Nov 14 22:09:26 2019 -0800

    scsi: ufs: Fix up auto hibern8 enablement
    
    Fix up possible unclocked register access to auto hibern8 register in
    resume path and through sysfs entry. Meanwhile, enable auto hibern8 only
    after device is fully initialized in probe path.
    
    Link: https://lore.kernel.org/r/1573798172-20534-4-git-send-email-cang@codeaurora.org
    Reviewed-by: Stanley Chu <stanley.chu@mediatek.com>
    Signed-off-by: Can Guo <cang@codeaurora.org>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/ufs/ufshcd.h b/drivers/scsi/ufs/ufshcd.h
index e0fe247c719e..2740f6941ec6 100644
--- a/drivers/scsi/ufs/ufshcd.h
+++ b/drivers/scsi/ufs/ufshcd.h
@@ -926,6 +926,8 @@ int ufshcd_query_attr(struct ufs_hba *hba, enum query_opcode opcode,
 int ufshcd_query_flag(struct ufs_hba *hba, enum query_opcode opcode,
 	enum flag_idn idn, bool *flag_res);
 
+void ufshcd_auto_hibern8_enable(struct ufs_hba *hba);
+
 #define SD_ASCII_STD true
 #define SD_RAW false
 int ufshcd_read_string_desc(struct ufs_hba *hba, u8 desc_index,

commit 49615ba144a0929c725d08f0d3ba8494c8b77404
Author: Stanley Chu <stanley.chu@mediatek.com>
Date:   Mon Sep 16 23:56:50 2019 +0800

    scsi: ufs: override auto suspend tunables for ufs
    
    Rework from previous work by:
    Sujit Reddy Thumma <sthumma@codeaurora.org>
    
    Override auto suspend tunables for UFS device LUNs during initialization so
    as to efficiently manage background operations and the power consumption.
    
    Link: https://lore.kernel.org/r/1568649411-5127-3-git-send-email-stanley.chu@mediatek.com
    Reviewed-by: Avri Altman <avri.altman@wdc.com>
    Reviewed-by: Bean Huo <beanhuo@micron.com>
    Signed-off-by: Stanley Chu <stanley.chu@mediatek.com>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/ufs/ufshcd.h b/drivers/scsi/ufs/ufshcd.h
index c94cfda52829..e0fe247c719e 100644
--- a/drivers/scsi/ufs/ufshcd.h
+++ b/drivers/scsi/ufs/ufshcd.h
@@ -716,6 +716,12 @@ struct ufs_hba {
 	 * the performance of ongoing read/write operations.
 	 */
 #define UFSHCD_CAP_KEEP_AUTO_BKOPS_ENABLED_EXCEPT_SUSPEND (1 << 5)
+	/*
+	 * This capability allows host controller driver to automatically
+	 * enable runtime power management by itself instead of waiting
+	 * for userspace to control the power management.
+	 */
+#define UFSHCD_CAP_RPM_AUTOSUSPEND (1 << 6)
 
 	struct devfreq *devfreq;
 	struct ufs_clk_scaling clk_scaling;
@@ -749,6 +755,10 @@ static inline bool ufshcd_can_autobkops_during_suspend(struct ufs_hba *hba)
 {
 	return hba->caps & UFSHCD_CAP_AUTO_BKOPS_SUSPEND;
 }
+static inline bool ufshcd_is_rpm_autosuspend_allowed(struct ufs_hba *hba)
+{
+	return hba->caps & UFSHCD_CAP_RPM_AUTOSUSPEND;
+}
 
 static inline bool ufshcd_is_intr_aggr_allowed(struct ufs_hba *hba)
 {

commit d8d9f7931ac2698fc2b37d2db748c47122ee2a6f
Author: Bjorn Andersson <bjorn.andersson@linaro.org>
Date:   Wed Aug 28 12:17:54 2019 -0700

    scsi: ufs: Introduce vops for resetting device
    
    Some UFS memory devices needs their reset line toggled in order to get them
    into a good state for initialization. Provide a new vops to allow the
    platform driver to implement this operation.
    
    Link: https://lore.kernel.org/r/20190828191756.24312-2-bjorn.andersson@linaro.org
    Signed-off-by: Bjorn Andersson <bjorn.andersson@linaro.org>
    Reviewed-by: Alim Akhtar <alim.akhtar@samsung.com>
    Reviewed-by: Bean Huo <beanhuo@micron.com>
    Reviewed-by: Stanley Chu <stanley.chu@mediatek.com>
    Acked-by: Avri Altman <Avri.Altman@wdc.com>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/ufs/ufshcd.h b/drivers/scsi/ufs/ufshcd.h
index 9f61550abc7f..c94cfda52829 100644
--- a/drivers/scsi/ufs/ufshcd.h
+++ b/drivers/scsi/ufs/ufshcd.h
@@ -298,6 +298,7 @@ struct ufs_pwr_mode_info {
  * @resume: called during host controller PM callback
  * @dbg_register_dump: used to dump controller debug information
  * @phy_initialization: used to initialize phys
+ * @device_reset: called to issue a reset pulse on the UFS device
  */
 struct ufs_hba_variant_ops {
 	const char *name;
@@ -326,6 +327,7 @@ struct ufs_hba_variant_ops {
 	int     (*resume)(struct ufs_hba *, enum ufs_pm_op);
 	void	(*dbg_register_dump)(struct ufs_hba *hba);
 	int	(*phy_initialization)(struct ufs_hba *);
+	void	(*device_reset)(struct ufs_hba *hba);
 };
 
 /* clock gating state  */
@@ -1070,6 +1072,12 @@ static inline void ufshcd_vops_dbg_register_dump(struct ufs_hba *hba)
 		hba->vops->dbg_register_dump(hba);
 }
 
+static inline void ufshcd_vops_device_reset(struct ufs_hba *hba)
+{
+	if (hba->vops && hba->vops->device_reset)
+		hba->vops->device_reset(hba);
+}
+
 extern struct ufs_pm_lvl_states ufs_pm_lvl_states[];
 
 /*

commit 4b828fe156a662a4b6135019bf077040340f299b
Author: Tomas Winkler <tomas.winkler@intel.com>
Date:   Tue Jul 30 08:55:17 2019 +0300

    scsi: ufs: revamp string descriptor reading
    
    Define new a type: uc_string_id for easier string handling and less
    casting. Reduce number or string copies in price of a dynamic allocation.
    
    Signed-off-by: Tomas Winkler <tomas.winkler@intel.com>
    Tested-by: Avri Altman <avri.altman@wdc.com>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/ufs/ufshcd.h b/drivers/scsi/ufs/ufshcd.h
index a43c7135f33d..9f61550abc7f 100644
--- a/drivers/scsi/ufs/ufshcd.h
+++ b/drivers/scsi/ufs/ufshcd.h
@@ -913,8 +913,11 @@ int ufshcd_query_attr(struct ufs_hba *hba, enum query_opcode opcode,
 		      enum attr_idn idn, u8 index, u8 selector, u32 *attr_val);
 int ufshcd_query_flag(struct ufs_hba *hba, enum query_opcode opcode,
 	enum flag_idn idn, bool *flag_res);
-int ufshcd_read_string_desc(struct ufs_hba *hba, int desc_index,
-			    u8 *buf, u32 size, bool ascii);
+
+#define SD_ASCII_STD true
+#define SD_RAW false
+int ufshcd_read_string_desc(struct ufs_hba *hba, u8 desc_index,
+			    u8 **buf, bool ascii);
 
 int ufshcd_hold(struct ufs_hba *hba, bool async);
 void ufshcd_release(struct ufs_hba *hba);

commit 8808b4e9dcdc908e1d48b1809416c5f80af9c87e
Author: Stanley Chu <stanley.chu@mediatek.com>
Date:   Wed Jul 10 21:38:21 2019 +0800

    scsi: ufs: Add history of fatal events
    
    Currently only "interrupt-based" errors have their own history, however
    there are some "non-interrupt-based" errors or events which need history
    to improve debugging or help know the health status of UFS devices.
    
    Example of fatal errors:
    
     - Link startup error
    
     - Suspend error
    
     - Resume error
    
    Example of abnormal events:
    
     - Task or request abort
    
     - Device reset (now equals to Logical Unit Reset)
    
     - Host reset
    
    This patch tries to track above errors and events by existed UFS error
    history mechanism.
    
    Signed-off-by: Stanley Chu <stanley.chu@mediatek.com>
    Reviewed-by: Avri Altman <avri.altman@wdc.com>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/ufs/ufshcd.h b/drivers/scsi/ufs/ufshcd.h
index c6ec5c749ceb..a43c7135f33d 100644
--- a/drivers/scsi/ufs/ufshcd.h
+++ b/drivers/scsi/ufs/ufshcd.h
@@ -436,8 +436,14 @@ struct ufs_err_reg_hist {
  * @nl_err: tracks nl-uic errors
  * @tl_err: tracks tl-uic errors
  * @dme_err: tracks dme errors
- * @fatal_err: tracks fatal errors
  * @auto_hibern8_err: tracks auto-hibernate errors
+ * @fatal_err: tracks fatal errors
+ * @linkup_err: tracks link-startup errors
+ * @resume_err: tracks resume errors
+ * @suspend_err: tracks suspend errors
+ * @dev_reset: tracks device reset events
+ * @host_reset: tracks host reset events
+ * @tsk_abort: tracks task abort events
  */
 struct ufs_stats {
 	u32 hibern8_exit_cnt;
@@ -451,8 +457,16 @@ struct ufs_stats {
 	struct ufs_err_reg_hist dme_err;
 
 	/* fatal errors */
-	struct ufs_err_reg_hist fatal_err;
 	struct ufs_err_reg_hist auto_hibern8_err;
+	struct ufs_err_reg_hist fatal_err;
+	struct ufs_err_reg_hist link_startup_err;
+	struct ufs_err_reg_hist resume_err;
+	struct ufs_err_reg_hist suspend_err;
+
+	/* abnormal events */
+	struct ufs_err_reg_hist dev_reset;
+	struct ufs_err_reg_hist host_reset;
+	struct ufs_err_reg_hist task_abort;
 };
 
 /**

commit d3c615bf586f2796f24097bfa13386effaa4bf3e
Author: Stanley Chu <stanley.chu@mediatek.com>
Date:   Wed Jul 10 21:38:19 2019 +0800

    scsi: ufs: Add fatal and auto-hibern8 error history
    
    Provide more information about fatal and auto-hibern8 errors to improve
    debugging by extending existing UFS error history framework.
    
    [mkp: typos]
    
    Signed-off-by: Stanley Chu <stanley.chu@mediatek.com>
    Reviewed-by: Avri Altman <avri.altman@wdc.com>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/ufs/ufshcd.h b/drivers/scsi/ufs/ufshcd.h
index dcc61f857c38..c6ec5c749ceb 100644
--- a/drivers/scsi/ufs/ufshcd.h
+++ b/drivers/scsi/ufs/ufshcd.h
@@ -414,7 +414,7 @@ struct ufs_init_prefetch {
 
 #define UFS_ERR_REG_HIST_LENGTH 8
 /**
- * struct ufs_err_reg_hist - keeps history of uic errors
+ * struct ufs_err_reg_hist - keeps history of errors
  * @pos: index to indicate cyclic buffer position
  * @reg: cyclic buffer for registers value
  * @tstamp: cyclic buffer for time stamp
@@ -436,15 +436,23 @@ struct ufs_err_reg_hist {
  * @nl_err: tracks nl-uic errors
  * @tl_err: tracks tl-uic errors
  * @dme_err: tracks dme errors
+ * @fatal_err: tracks fatal errors
+ * @auto_hibern8_err: tracks auto-hibernate errors
  */
 struct ufs_stats {
 	u32 hibern8_exit_cnt;
 	ktime_t last_hibern8_exit_tstamp;
+
+	/* uic specific errors */
 	struct ufs_err_reg_hist pa_err;
 	struct ufs_err_reg_hist dl_err;
 	struct ufs_err_reg_hist nl_err;
 	struct ufs_err_reg_hist tl_err;
 	struct ufs_err_reg_hist dme_err;
+
+	/* fatal errors */
+	struct ufs_err_reg_hist fatal_err;
+	struct ufs_err_reg_hist auto_hibern8_err;
 };
 
 /**

commit 48d5b9732580bca18fed9ef20da8aa210c646755
Author: Stanley Chu <stanley.chu@mediatek.com>
Date:   Wed Jul 10 21:38:18 2019 +0800

    scsi: ufs: Change names related to error history
    
    Remove "uic" term in below error history functions and structures for more
    general usages,
    
    struct ufs_uic_err_reg_hist;
    void ufshcd_update_uic_reg_hist(struct ufs_uic_err_reg_hist *reg_hist,
            u32 reg);
    void ufshcd_print_uic_err_hist(struct ufs_hba *hba,
            struct ufs_uic)err_reg_hist *err_hist, char *err_name);
    
    Signed-off-by: Stanley Chu <stanley.chu@mediatek.com>
    Reviewed-by: Avri Altman <avri.altman@wdc.com>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/ufs/ufshcd.h b/drivers/scsi/ufs/ufshcd.h
index 994d73d03207..dcc61f857c38 100644
--- a/drivers/scsi/ufs/ufshcd.h
+++ b/drivers/scsi/ufs/ufshcd.h
@@ -412,17 +412,17 @@ struct ufs_init_prefetch {
 	u32 icc_level;
 };
 
-#define UIC_ERR_REG_HIST_LENGTH 8
+#define UFS_ERR_REG_HIST_LENGTH 8
 /**
- * struct ufs_uic_err_reg_hist - keeps history of uic errors
+ * struct ufs_err_reg_hist - keeps history of uic errors
  * @pos: index to indicate cyclic buffer position
  * @reg: cyclic buffer for registers value
  * @tstamp: cyclic buffer for time stamp
  */
-struct ufs_uic_err_reg_hist {
+struct ufs_err_reg_hist {
 	int pos;
-	u32 reg[UIC_ERR_REG_HIST_LENGTH];
-	ktime_t tstamp[UIC_ERR_REG_HIST_LENGTH];
+	u32 reg[UFS_ERR_REG_HIST_LENGTH];
+	ktime_t tstamp[UFS_ERR_REG_HIST_LENGTH];
 };
 
 /**
@@ -440,11 +440,11 @@ struct ufs_uic_err_reg_hist {
 struct ufs_stats {
 	u32 hibern8_exit_cnt;
 	ktime_t last_hibern8_exit_tstamp;
-	struct ufs_uic_err_reg_hist pa_err;
-	struct ufs_uic_err_reg_hist dl_err;
-	struct ufs_uic_err_reg_hist nl_err;
-	struct ufs_uic_err_reg_hist tl_err;
-	struct ufs_uic_err_reg_hist dme_err;
+	struct ufs_err_reg_hist pa_err;
+	struct ufs_err_reg_hist dl_err;
+	struct ufs_err_reg_hist nl_err;
+	struct ufs_err_reg_hist tl_err;
+	struct ufs_err_reg_hist dme_err;
 };
 
 /**

commit ee5f1042b20e1ffbc5c7eb0e0883fdbc05cec85f
Author: Stanley Chu <stanley.chu@mediatek.com>
Date:   Tue May 21 14:44:52 2019 +0800

    scsi: ufs: Introduce ufshcd_is_auto_hibern8_supported()
    
    The checking of Auto-Hibernation support is used in many places in the
    driver, thus re-factor it as ufshcd_is_auto_hibern8_supported() to make
    code more clean.
    
    Signed-off-by: Stanley Chu <stanley.chu@mediatek.com>
    Reviewed-by: Bean Huo <beanhuo@micron.com>
    Reviewed-by: Alim Akhtar <alim.akhtar@samsung.com>
    Reviewed-by: Avri Altman <Avri.Altman@wdc.com>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/ufs/ufshcd.h b/drivers/scsi/ufs/ufshcd.h
index ecfa898b9ccc..994d73d03207 100644
--- a/drivers/scsi/ufs/ufshcd.h
+++ b/drivers/scsi/ufs/ufshcd.h
@@ -740,6 +740,11 @@ return true;
 #endif
 }
 
+static inline bool ufshcd_is_auto_hibern8_supported(struct ufs_hba *hba)
+{
+	return (hba->capabilities & MASK_AUTO_HIBERN8_SUPPORT);
+}
+
 #define ufshcd_writel(hba, val, reg)	\
 	writel((val), (hba)->mmio_base + (reg))
 #define ufshcd_readl(hba, reg)	\

commit 176eb927744201ba95ca9a85c2f9af457559374f
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Mon Mar 4 20:39:11 2019 +0100

    scsi: ufs: hisi: fix ufs_hba_variant_ops passing
    
    Without CONFIG_OF, the of_match_node() helper does not evaluate its
    argument, and the compiler warns about the unused variable:
    
    drivers/scsi/ufs/ufs-hisi.c: In function 'ufs_hisi_probe':
    drivers/scsi/ufs/ufs-hisi.c:673:17: error: unused variable 'dev' [-Werror=unused-variable]
    
    Rework this code to pass the data directly, and while we're at it,
    correctly handle the const pointers.
    
    Fixes: 653fcb07d95e ("scsi: ufs: Add HI3670 SoC UFS driver support")
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>
    Reviewed-by: Avri Altman <avri.altman@wdc.com>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/ufs/ufshcd.h b/drivers/scsi/ufs/ufshcd.h
index 69ba7445d2b3..ecfa898b9ccc 100644
--- a/drivers/scsi/ufs/ufshcd.h
+++ b/drivers/scsi/ufs/ufshcd.h
@@ -546,7 +546,7 @@ struct ufs_hba {
 	int nutrs;
 	int nutmrs;
 	u32 ufs_version;
-	struct ufs_hba_variant_ops *vops;
+	const struct ufs_hba_variant_ops *vops;
 	void *priv;
 	unsigned int irq;
 	bool is_irq_enabled;

commit 9e1e8a75708031937a0f92567c19760c92658410
Author: Subhash Jadavani <subhashj@codeaurora.org>
Date:   Tue Oct 16 14:29:41 2018 +0530

    scsi: ufs: set the device reference clock setting
    
    UFS host supplies the reference clock to UFS device and UFS device
    specification allows host to provide one of the 4 frequencies (19.2 MHz, 26
    MHz, 38.4 MHz, 52 MHz) for reference clock. Host should set the device
    reference clock frequency setting in the device based on what frequency it
    is supplying to UFS device.
    
    Signed-off-by: Subhash Jadavani <subhashj@codeaurora.org>
    Signed-off-by: Can Guo <cang@codeaurora.org>
    Signed-off-by: Sayali Lokhande <sayalil@codeaurora.org>
    Reviewed-by: Evan Green <evgreen@chromium.org>
    Acked-by: Rob Herring <robh@kernel.org>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/ufs/ufshcd.h b/drivers/scsi/ufs/ufshcd.h
index 1a1c2b487a4e..69ba7445d2b3 100644
--- a/drivers/scsi/ufs/ufshcd.h
+++ b/drivers/scsi/ufs/ufshcd.h
@@ -550,6 +550,7 @@ struct ufs_hba {
 	void *priv;
 	unsigned int irq;
 	bool is_irq_enabled;
+	enum ufs_ref_clk_freq dev_ref_clk_freq;
 
 	/* Interrupt aggregation support is broken */
 	#define UFSHCD_QUIRK_BROKEN_INTR_AGGR			0x1
@@ -768,6 +769,7 @@ void ufshcd_remove(struct ufs_hba *);
 int ufshcd_wait_for_register(struct ufs_hba *hba, u32 reg, u32 mask,
 				u32 val, unsigned long interval_us,
 				unsigned long timeout_ms, bool can_sleep);
+void ufshcd_parse_dev_ref_clk_freq(struct ufs_hba *hba, struct clk *refclk);
 
 static inline void check_upiu_size(void)
 {

commit e77044c5a8422e4e139f0a2ac5d49f4075779594
Author: Avri Altman <avri.altman@wdc.com>
Date:   Sun Oct 7 17:30:39 2018 +0300

    scsi: ufs-bsg: Add support for uic commands in ufs_bsg_request()
    
    Make ufshcd_send_uic_cmd() public for that.
    
    Signed-off-by: Avri Altman <avri.altman@wdc.com>
    Reviewed-by: Christoph Hellwig <hch@lst.de>
    Reviewed-by: Bart Van Assche <Bart.VanAssche@wdc.com>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/ufs/ufshcd.h b/drivers/scsi/ufs/ufshcd.h
index 087813417a71..1a1c2b487a4e 100644
--- a/drivers/scsi/ufs/ufshcd.h
+++ b/drivers/scsi/ufs/ufshcd.h
@@ -895,6 +895,8 @@ int ufshcd_map_desc_id_to_length(struct ufs_hba *hba, enum desc_idn desc_id,
 
 u32 ufshcd_get_local_unipro_ver(struct ufs_hba *hba);
 
+int ufshcd_send_uic_cmd(struct ufs_hba *hba, struct uic_command *uic_cmd);
+
 int ufshcd_exec_raw_upiu_cmd(struct ufs_hba *hba,
 			     struct utp_upiu_req *req_upiu,
 			     struct utp_upiu_req *rsp_upiu,

commit 5e0a86eed84607432436766e3e1bb37f8318f7b2
Author: Avri Altman <avri.altman@wdc.com>
Date:   Sun Oct 7 17:30:37 2018 +0300

    scsi: ufs: Add API to execute raw upiu commands
    
    The UFS host software uses a combination of a host register set and
    Transfer Request Descriptors in system memory to communicate with host
    controller hardware. In its mmio space, a separate places are assigned
    to UTP Transfer Request Descriptor ("utrd") list, and to UTP Task
    Management Request Descriptor ("utmrd") list.
    
    The provided API supports utrd-typed requests: nop out and device
    management commands. It also supports utmrd-type requests:
    task management requests. Other UPIU types are not supported for now.
    
    We utilize the already existing code for tag and task work queues.
    That is, all utrd-typed UPIUs are "disguised" as device management
    commands. Similarly, the utmrd-typed UPUIs uses the task management
    infrastructure.
    
    It is up to the caller to fill the upiu request properly, as it will be
    copied without any further input validations.
    
    Signed-off-by: Avri Altman <avri.altman@wdc.com>
    Reviewed-by: Christoph Hellwig <hch@lst.de>
    Reviewed-by: Bart Van Assche <Bart.VanAssche@wdc.com>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/ufs/ufshcd.h b/drivers/scsi/ufs/ufshcd.h
index 54e6fe87954f..087813417a71 100644
--- a/drivers/scsi/ufs/ufshcd.h
+++ b/drivers/scsi/ufs/ufshcd.h
@@ -895,6 +895,13 @@ int ufshcd_map_desc_id_to_length(struct ufs_hba *hba, enum desc_idn desc_id,
 
 u32 ufshcd_get_local_unipro_ver(struct ufs_hba *hba);
 
+int ufshcd_exec_raw_upiu_cmd(struct ufs_hba *hba,
+			     struct utp_upiu_req *req_upiu,
+			     struct utp_upiu_req *rsp_upiu,
+			     int msgcode,
+			     u8 *desc_buff, int *buff_len,
+			     enum query_opcode desc_op);
+
 /* Wrapper functions for safely calling variant operations */
 static inline const char *ufshcd_get_var_name(struct ufs_hba *hba)
 {

commit df032bf27a414acf61c957ec2fad22a57d903b39
Author: Avri Altman <avri.altman@wdc.com>
Date:   Sun Oct 7 17:30:35 2018 +0300

    scsi: ufs: Add a bsg endpoint that supports UPIUs
    
    For now, just provide an API to allocate and remove ufs-bsg node. We
    will use this framework to manage ufs devices by sending UPIU
    transactions.
    
    For the time being, implements an empty bsg_request() - will add some
    more functionality in coming patches.
    
    Nonetheless, we reveal here the protocol we are planning to use: UFS
    Transport Protocol Transactions. UFS transactions consist of packets
    called UFS Protocol Information Units (UPIU).
    
    There are UPIUs defined for UFS SCSI commands, responses, data in and
    data out, task management, utility functions, vendor functions,
    transaction synchronization and control, and more.
    
    By using UPIUs, we get access to the most fine-grained internals of this
    protocol, and able to communicate with the device in ways, that are
    sometimes beyond the capacity of the ufs driver.
    
    Moreover and as a result, our core structure - ufs_bsg_node has a pretty
    lean structure: using upiu transactions that contains the outmost
    detailed info, so we don't really need complex constructs to support it.
    
    Signed-off-by: Avri Altman <avri.altman@wdc.com>
    Reviewed-by: Christoph Hellwig <hch@lst.de>
    Reviewed-by: Bart Van Assche <Bart.VanAssche@wdc.com>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/ufs/ufshcd.h b/drivers/scsi/ufs/ufshcd.h
index 33fdd3f281ae..54e6fe87954f 100644
--- a/drivers/scsi/ufs/ufshcd.h
+++ b/drivers/scsi/ufs/ufshcd.h
@@ -702,6 +702,9 @@ struct ufs_hba {
 	struct rw_semaphore clk_scaling_lock;
 	struct ufs_desc_size desc_size;
 	atomic_t scsi_block_reqs_cnt;
+
+	struct device		bsg_dev;
+	struct request_queue	*bsg_queue;
 };
 
 /* Returns true if clocks can be gated. Otherwise false */

commit ba80917d9932da022d2e74eae66e44139dd65136
Author: Tomas Winkler <tomas.winkler@intel.com>
Date:   Thu Jun 14 11:14:09 2018 +0300

    scsi: ufs: ufshcd_dump_regs to use memcpy_fromio
    
    ufshcd_dump_regs should use memcpy_fromio to read host registers
    instead of directly accessing using memcpy.  The same function is
    utilized in ufs-qcom.
    
    Elminite compilation warning
    drivers/scsi/ufs/ufshcd.c:356:9: warning: incorrect type in argument 6 (different address spaces)
    drivers/scsi/ufs/ufshcd.c:356:9:    expected void const *buf
    drivers/scsi/ufs/ufshcd.c:356:9:    got void [noderef] <asn:2>*mmio_base
    
    Signed-off-by: Tomas Winkler <tomas.winkler@intel.com>
    Reviewed-by: Avri Altman <avri.altman@wdc.com>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/ufs/ufshcd.h b/drivers/scsi/ufs/ufshcd.h
index f51758f1e5cc..33fdd3f281ae 100644
--- a/drivers/scsi/ufs/ufshcd.h
+++ b/drivers/scsi/ufs/ufshcd.h
@@ -1043,4 +1043,7 @@ static inline u8 ufshcd_scsi_to_upiu_lun(unsigned int scsi_lun)
 		return scsi_lun & UFS_UPIU_MAX_UNIT_NUM_ID;
 }
 
+int ufshcd_dump_regs(struct ufs_hba *hba, size_t offset, size_t len,
+		     const char *prefix);
+
 #endif /* End of Header */

commit 10e5e37581fc5817d52ff5f8e2b3362f64eb04f4
Author: Vijay Viswanath <vviswana@codeaurora.org>
Date:   Thu May 3 16:37:22 2018 +0530

    scsi: ufs: Add clock ungating to a separate workqueue
    
    UFS driver can receive a request during memory reclaim by kswapd.  So
    when ufs driver puts the ungate work in queue, and if there are no idle
    workers, kthreadd is invoked to create a new kworker. Since kswapd task
    holds a mutex which kthreadd also needs, this can cause a deadlock
    situation. So ungate work must be done in a separate work queue with
    WQ_MEM_RECLAIM flag enabled.  Such a workqueue will have a rescue thread
    which will be called when the above deadlock condition is possible.
    
    Signed-off-by: Vijay Viswanath <vviswana@codeaurora.org>
    Signed-off-by: Can Guo <cang@codeaurora.org>
    Signed-off-by: Asutosh Das <asutoshd@codeaurora.org>
    Reviewed-by: Subhash Jadavani <subhashj@codeaurora.org>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/ufs/ufshcd.h b/drivers/scsi/ufs/ufshcd.h
index a44b9f45ddd2..f51758f1e5cc 100644
--- a/drivers/scsi/ufs/ufshcd.h
+++ b/drivers/scsi/ufs/ufshcd.h
@@ -362,6 +362,7 @@ struct ufs_clk_gating {
 	struct device_attribute enable_attr;
 	bool is_enabled;
 	int active_reqs;
+	struct workqueue_struct *clk_gating_workq;
 };
 
 struct ufs_saved_pwr_info {

commit 38135535dcc25af856336fda31aeef79d8ad9dab
Author: Subhash Jadavani <subhashj@codeaurora.org>
Date:   Thu May 3 16:37:18 2018 +0530

    scsi: ufs: add reference counting for scsi block requests
    
    Currently we call the scsi_block_requests()/scsi_unblock_requests()
    whenever we want to block/unblock scsi requests but as there is no
    reference counting, nesting of these calls could leave us in undesired
    state sometime. Consider following call flow sequence:
    
    1. func1() calls scsi_block_requests() but calls func2() before
       calling scsi_unblock_requests()
    2. func2() calls scsi_block_requests()
    3. func2() calls scsi_unblock_requests()
    4. func1() calls scsi_unblock_requests()
    
    As there is no reference counting, we will have scsi requests unblocked
    after #3 instead of it to be unblocked only after #4. Though we may not
    have failures seen with this, we might run into some failures in future.
    Better solution would be to fix this by adding reference counting.
    
    Signed-off-by: Subhash Jadavani <subhashj@codeaurora.org>
    Signed-off-by: Can Guo <cang@codeaurora.org>
    Signed-off-by: Asutosh Das <asutoshd@codeaurora.org>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/ufs/ufshcd.h b/drivers/scsi/ufs/ufshcd.h
index 53121fd6c287..a44b9f45ddd2 100644
--- a/drivers/scsi/ufs/ufshcd.h
+++ b/drivers/scsi/ufs/ufshcd.h
@@ -499,6 +499,7 @@ struct ufs_stats {
  * @urgent_bkops_lvl: keeps track of urgent bkops level for device
  * @is_urgent_bkops_lvl_checked: keeps track if the urgent bkops level for
  *  device is known or not.
+ * @scsi_block_reqs_cnt: reference counting for scsi block requests
  */
 struct ufs_hba {
 	void __iomem *mmio_base;
@@ -699,6 +700,7 @@ struct ufs_hba {
 
 	struct rw_semaphore clk_scaling_lock;
 	struct ufs_desc_size desc_size;
+	atomic_t scsi_block_reqs_cnt;
 };
 
 /* Returns true if clocks can be gated. Otherwise false */

commit 0d846e703dc8b77d31cc71e0bd8d004f187eac30
Author: Alim Akhtar <alim.akhtar@samsung.com>
Date:   Sun May 6 15:44:18 2018 +0530

    scsi: ufs: make ufshcd_config_pwr_mode of non-static func
    
    This makes ufshcd_config_pwr_mode non-static so that other vendors like
    exynos can use it.
    
    Signed-off-by: Seungwon Jeon <essuuj@gmail.com>
    Signed-off-by: Alim Akhtar <alim.akhtar@samsung.com>
    Reviewed-by: Avri Altman <avri.altman@wdc.com>
    Reviewed-by: Subhash Jadavani <subhashj@codeaurora.org>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/ufs/ufshcd.h b/drivers/scsi/ufs/ufshcd.h
index a39cdb51ab41..53121fd6c287 100644
--- a/drivers/scsi/ufs/ufshcd.h
+++ b/drivers/scsi/ufs/ufshcd.h
@@ -805,6 +805,8 @@ extern int ufshcd_dme_set_attr(struct ufs_hba *hba, u32 attr_sel,
 			       u8 attr_set, u32 mib_val, u8 peer);
 extern int ufshcd_dme_get_attr(struct ufs_hba *hba, u32 attr_sel,
 			       u32 *mib_val, u8 peer);
+extern int ufshcd_config_pwr_mode(struct ufs_hba *hba,
+			struct ufs_pa_layer_attr *desired_pwr_mode);
 
 /* UIC command interfaces for DME primitives */
 #define DME_LOCAL	0

commit 4404c5de7707859d8e54f4356ac17c82413c80e9
Author: Alim Akhtar <alim.akhtar@samsung.com>
Date:   Sun May 6 15:44:17 2018 +0530

    scsi: ufs: add quirk to enable host controller without hce
    
    Some host controllers don't support host controller enable via HCE.
    
    Signed-off-by: Seungwon Jeon <essuuj@gmail.com>
    Signed-off-by: Alim Akhtar <alim.akhtar@samsung.com>
    Reviewed-by: Subhash Jadavani <subhashj@codeaurora.org>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/ufs/ufshcd.h b/drivers/scsi/ufs/ufshcd.h
index d8c922d5bbee..a39cdb51ab41 100644
--- a/drivers/scsi/ufs/ufshcd.h
+++ b/drivers/scsi/ufs/ufshcd.h
@@ -606,6 +606,11 @@ struct ufs_hba {
 	 */
 	#define UFSHCI_QUIRK_SKIP_RESET_INTR_AGGR		0x200
 
+	/*
+	 * This quirks needs to be enabled if host controller cannot be
+	 * enabled via HCE register.
+	 */
+	#define UFSHCI_QUIRK_BROKEN_HCE				0x400
 	unsigned int quirks;	/* Deviations from standard UFSHCI spec. */
 
 	/* Device deviations from standard UFS device spec. */

commit 5ac6abc9415c3c70040b529631426b78e26108c4
Author: Alim Akhtar <alim.akhtar@samsung.com>
Date:   Sun May 6 15:44:16 2018 +0530

    scsi: ufs: add quirk to disallow reset of interrupt aggregation
    
    Some host controllers support interrupt aggregation but don't allow
    resetting counter and timer in software.
    
    Signed-off-by: Seungwon Jeon <essuuj@gmail.com>
    Signed-off-by: Alim Akhtar <alim.akhtar@samsung.com>
    Reviewed-by: Subhash Jadavani <subhashj@codeaurora.org>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/ufs/ufshcd.h b/drivers/scsi/ufs/ufshcd.h
index 09c285f62c6a..d8c922d5bbee 100644
--- a/drivers/scsi/ufs/ufshcd.h
+++ b/drivers/scsi/ufs/ufshcd.h
@@ -600,6 +600,12 @@ struct ufs_hba {
 	 */
 	#define UFSHCI_QUIRK_BROKEN_REQ_LIST_CLR		0x100
 
+	/*
+	 * This quirk needs to be enabled if host controller doesn't allow
+	 * that the interrupt aggregation timer and counter are reset by s/w.
+	 */
+	#define UFSHCI_QUIRK_SKIP_RESET_INTR_AGGR		0x200
+
 	unsigned int quirks;	/* Deviations from standard UFSHCI spec. */
 
 	/* Device deviations from standard UFS device spec. */

commit 1399c5b02c568700ba50ce1ec19c12e71b25c73d
Author: Alim Akhtar <alim.akhtar@samsung.com>
Date:   Sun May 6 15:44:15 2018 +0530

    scsi: ufs: add quirk to fix mishandling utrlclr/utmrlclr
    
    In the right behavior, setting the bit to '0' indicates clear and '1'
    indicates no change. If host controller handles this the other way,
    UFSHCI_QUIRK_BROKEN_REQ_LIST_CLR can be used.
    
    [mkp: typo]
    
    Signed-off-by: Seungwon Jeon <essuuj@gmail.com>
    Signed-off-by: Alim Akhtar <alim.akhtar@samsung.com>
    Reviewed-by: Subhash Jadavani <subhashj@codeaurora.org>
    Reviewed-by: "Asutosh Das (asd)" <asutoshd@codeaurora.org>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/ufs/ufshcd.h b/drivers/scsi/ufs/ufshcd.h
index 8110dcd04d22..09c285f62c6a 100644
--- a/drivers/scsi/ufs/ufshcd.h
+++ b/drivers/scsi/ufs/ufshcd.h
@@ -595,6 +595,11 @@ struct ufs_hba {
 	 */
 	#define UFSHCD_QUIRK_PRDT_BYTE_GRAN			0x80
 
+	/*
+	 * Clear handling for transfer/task request list is just opposite.
+	 */
+	#define UFSHCI_QUIRK_BROKEN_REQ_LIST_CLR		0x100
+
 	unsigned int quirks;	/* Deviations from standard UFSHCI spec. */
 
 	/* Device deviations from standard UFS device spec. */

commit ad448378825f5746c5fa37718724bc8f4e7b6945
Author: Adrian Hunter <adrian.hunter@intel.com>
Date:   Tue Mar 20 15:07:38 2018 +0200

    scsi: ufs: Add support for Auto-Hibernate Idle Timer
    
    UFS host controllers may support an autonomous power management feature
    called the Auto-Hibernate Idle Timer. The timer is set to the number of
    microseconds of idle time before the UFS host controller will autonomously
    put the link into Hibernate state. That will save power at the expense of
    increased latency. Any access to the host controller interface registers
    will automatically put the link out of Hibernate state. So once configured,
    the feature is transparent to the driver.
    
    Expose the Auto-Hibernate Idle Timer value via SysFS to allow users to
    choose between power efficiency or lower latency. Set a default value of
    150 ms.
    
    Signed-off-by: Adrian Hunter <adrian.hunter@intel.com>
    Acked-by: Stanislav Nijnikov <stanislav.nijnikov@wdc.com>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/ufs/ufshcd.h b/drivers/scsi/ufs/ufshcd.h
index deb3c5d382e9..8110dcd04d22 100644
--- a/drivers/scsi/ufs/ufshcd.h
+++ b/drivers/scsi/ufs/ufshcd.h
@@ -531,6 +531,9 @@ struct ufs_hba {
 	struct device_attribute spm_lvl_attr;
 	int pm_op_in_progress;
 
+	/* Auto-Hibernate Idle Timer register value */
+	u32 ahit;
+
 	struct ufshcd_lrb *lrb;
 	unsigned long lrb_in_use;
 

commit ec92b59cc03c3d5757449c1c9344524e088df2bd
Author: Stanislav Nijnikov <stanislav.nijnikov@wdc.com>
Date:   Thu Feb 15 14:14:11 2018 +0200

    scsi: ufs: sysfs: attributes
    
    This patch introduces a sysfs group entry for the UFS attributes. The
    group adds "attributes" folder under the UFS driver sysfs entry
    (/sys/bus/platform/drivers/ufshcd/*). The attributes are shown
    as hexadecimal numbers. The full information about the attributes could
    be found at UFS specifications 2.1.
    
    Signed-off-by: Stanislav Nijnikov <stanislav.nijnikov@wdc.com>
    Reviewed-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/ufs/ufshcd.h b/drivers/scsi/ufs/ufshcd.h
index f4cb31b23728..deb3c5d382e9 100644
--- a/drivers/scsi/ufs/ufshcd.h
+++ b/drivers/scsi/ufs/ufshcd.h
@@ -847,13 +847,14 @@ int ufshcd_query_descriptor_retry(struct ufs_hba *hba,
 				  enum desc_idn idn, u8 index,
 				  u8 selector,
 				  u8 *desc_buf, int *buf_len);
-
 int ufshcd_read_desc_param(struct ufs_hba *hba,
 			   enum desc_idn desc_id,
 			   int desc_index,
 			   u8 param_offset,
 			   u8 *param_read_buf,
 			   u8 param_size);
+int ufshcd_query_attr(struct ufs_hba *hba, enum query_opcode opcode,
+		      enum attr_idn idn, u8 index, u8 selector, u32 *attr_val);
 int ufshcd_query_flag(struct ufs_hba *hba, enum query_opcode opcode,
 	enum flag_idn idn, bool *flag_res);
 int ufshcd_read_string_desc(struct ufs_hba *hba, int desc_index,

commit d829fc8a1058851f1058b4a29ea02da125c1684a
Author: Stanislav Nijnikov <stanislav.nijnikov@wdc.com>
Date:   Thu Feb 15 14:14:09 2018 +0200

    scsi: ufs: sysfs: unit descriptor
    
    This patch introduces a sysfs group entry for the UFS unit descriptor
    parameters. The group adds "unit_descriptor" folder under the corresponding
    SCSI device sysfs entry (/sys/class/scsi_device/*/device/). The parameters
    are shown as hexadecimal numbers. The full information about the parameters
    could be found at UFS specifications 2.1.
    
    Signed-off-by: Stanislav Nijnikov <stanislav.nijnikov@wdc.com>
    Reviewed-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/ufs/ufshcd.h b/drivers/scsi/ufs/ufshcd.h
index 2dad9dada86a..f4cb31b23728 100644
--- a/drivers/scsi/ufs/ufshcd.h
+++ b/drivers/scsi/ufs/ufshcd.h
@@ -1003,4 +1003,19 @@ static inline void ufshcd_vops_dbg_register_dump(struct ufs_hba *hba)
 
 extern struct ufs_pm_lvl_states ufs_pm_lvl_states[];
 
+/*
+ * ufshcd_scsi_to_upiu_lun - maps scsi LUN to UPIU LUN
+ * @scsi_lun: scsi LUN id
+ *
+ * Returns UPIU LUN id
+ */
+static inline u8 ufshcd_scsi_to_upiu_lun(unsigned int scsi_lun)
+{
+	if (scsi_is_wlun(scsi_lun))
+		return (scsi_lun & UFS_UPIU_MAX_UNIT_NUM_ID)
+			| UFS_UPIU_WLUN_ID;
+	else
+		return scsi_lun & UFS_UPIU_MAX_UNIT_NUM_ID;
+}
+
 #endif /* End of Header */

commit 2238d31cdeabc585de5869efd11856815aa4dd13
Author: Stanislav Nijnikov <stanislav.nijnikov@wdc.com>
Date:   Thu Feb 15 14:14:07 2018 +0200

    scsi: ufs: sysfs: string descriptors
    
    This patch introduces a sysfs group entry for the UFS string descriptors.
    The group adds "string_descriptors" folder under the UFS driver
    sysfs entry (/sys/bus/platform/drivers/ufshcd/*). The folder will contain
    5 files that will show string values defined by the UFS spec:
    a manufacturer name, a product name, an OEM id, a serial number and a
    product revision.  The full information about the string descriptors
    could be found at UFS specifications 2.1.
    
    Signed-off-by: Stanislav Nijnikov <stanislav.nijnikov@wdc.com>
    Reviewed-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/ufs/ufshcd.h b/drivers/scsi/ufs/ufshcd.h
index 515c6e6244be..2dad9dada86a 100644
--- a/drivers/scsi/ufs/ufshcd.h
+++ b/drivers/scsi/ufs/ufshcd.h
@@ -842,6 +842,12 @@ static inline bool ufshcd_is_hs_mode(struct ufs_pa_layer_attr *pwr_info)
 }
 
 /* Expose Query-Request API */
+int ufshcd_query_descriptor_retry(struct ufs_hba *hba,
+				  enum query_opcode opcode,
+				  enum desc_idn idn, u8 index,
+				  u8 selector,
+				  u8 *desc_buf, int *buf_len);
+
 int ufshcd_read_desc_param(struct ufs_hba *hba,
 			   enum desc_idn desc_id,
 			   int desc_index,
@@ -850,6 +856,9 @@ int ufshcd_read_desc_param(struct ufs_hba *hba,
 			   u8 param_size);
 int ufshcd_query_flag(struct ufs_hba *hba, enum query_opcode opcode,
 	enum flag_idn idn, bool *flag_res);
+int ufshcd_read_string_desc(struct ufs_hba *hba, int desc_index,
+			    u8 *buf, u32 size, bool ascii);
+
 int ufshcd_hold(struct ufs_hba *hba, bool async);
 void ufshcd_release(struct ufs_hba *hba);
 

commit c648c2d27f168ae4faeb43f8c3074226aae3862c
Author: Stanislav Nijnikov <stanislav.nijnikov@wdc.com>
Date:   Thu Feb 15 14:14:05 2018 +0200

    scsi: ufs: sysfs: health descriptor
    
    This patch introduces a sysfs group entry for the UFS health descriptor
    parameters. The group adds "health_descriptor" folder under the UFS driver
    sysfs entry (/sys/bus/platform/drivers/ufshcd/*). The parameters are shown
    as hexadecimal numbers. The full information about the parameters could be
    found at UFS specifications 2.1.
    
    Signed-off-by: Stanislav Nijnikov <stanislav.nijnikov@wdc.com>
    Reviewed-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/ufs/ufshcd.h b/drivers/scsi/ufs/ufshcd.h
index 38c307d053c7..515c6e6244be 100644
--- a/drivers/scsi/ufs/ufshcd.h
+++ b/drivers/scsi/ufs/ufshcd.h
@@ -229,6 +229,7 @@ struct ufs_desc_size {
 	int interc_desc;
 	int unit_desc;
 	int conf_desc;
+	int hlth_desc;
 };
 
 /**

commit 45bced87e79316ecd868aee8f187284025792c5f
Author: Stanislav Nijnikov <stanislav.nijnikov@wdc.com>
Date:   Thu Feb 15 14:14:02 2018 +0200

    scsi: ufs: sysfs: device descriptor
    
    This patch introduces a sysfs group entry for the UFS device descriptor
    parameters. The group adds "device_descriptor" folder under the UFS driver
    sysfs entry (/sys/bus/platform/drivers/ufshcd/*). The parameters are shown
    as hexadecimal numbers. The full information about the parameters could be
    found at UFS specifications 2.1.
    
    Signed-off-by: Stanislav Nijnikov <stanislav.nijnikov@wdc.com>
    Reviewed-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/ufs/ufshcd.h b/drivers/scsi/ufs/ufshcd.h
index 53e2779f9d06..38c307d053c7 100644
--- a/drivers/scsi/ufs/ufshcd.h
+++ b/drivers/scsi/ufs/ufshcd.h
@@ -841,6 +841,12 @@ static inline bool ufshcd_is_hs_mode(struct ufs_pa_layer_attr *pwr_info)
 }
 
 /* Expose Query-Request API */
+int ufshcd_read_desc_param(struct ufs_hba *hba,
+			   enum desc_idn desc_id,
+			   int desc_index,
+			   u8 param_offset,
+			   u8 *param_read_buf,
+			   u8 param_size);
 int ufshcd_query_flag(struct ufs_hba *hba, enum query_opcode opcode,
 	enum flag_idn idn, bool *flag_res);
 int ufshcd_hold(struct ufs_hba *hba, bool async);

commit cbb6813ee771abc17a713432f31820581eafd4ae
Author: Stanislav Nijnikov <stanislav.nijnikov@wdc.com>
Date:   Thu Feb 15 14:14:01 2018 +0200

    scsi: ufs: sysfs: attribute group for existing sysfs entries.
    
    This patch introduces attribute group to show existing sysfs entries.
    
    Signed-off-by: Stanislav Nijnikov <stanislav.nijnikov@wdc.com>
    Reviewed-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/ufs/ufshcd.h b/drivers/scsi/ufs/ufshcd.h
index 1332e544da92..53e2779f9d06 100644
--- a/drivers/scsi/ufs/ufshcd.h
+++ b/drivers/scsi/ufs/ufshcd.h
@@ -985,4 +985,6 @@ static inline void ufshcd_vops_dbg_register_dump(struct ufs_hba *hba)
 		hba->vops->dbg_register_dump(hba);
 }
 
+extern struct ufs_pm_lvl_states ufs_pm_lvl_states[];
+
 #endif /* End of Header */

commit cc81641a45252084878034620bcf80e15c9f9580
Author: Alim Akhtar <alim.akhtar@samsung.com>
Date:   Tue Oct 3 20:51:22 2017 +0530

    scsi: ufs: Change HCI macro to actual bit position
    
    Currently UFS HCI uses UFS_BIT() macro to get various bit position for
    the hardware registers status bits. Which makes code longer instead of
    shorter. This macro does not improve code readability as well.  Lets
    re-write these macro definition with the actual bit position.
    
    Suggested-by: Bart Van Assche <Bart.VanAssche@wdc.com>
    Signed-off-by: Alim Akhtar <alim.akhtar@samsung.com>
    Reviewed-by: Bart Van Assche <bart.vanassche@wdc.com>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/ufs/ufshcd.h b/drivers/scsi/ufs/ufshcd.h
index 40ea4759a02f..1332e544da92 100644
--- a/drivers/scsi/ufs/ufshcd.h
+++ b/drivers/scsi/ufs/ufshcd.h
@@ -546,13 +546,13 @@ struct ufs_hba {
 	bool is_irq_enabled;
 
 	/* Interrupt aggregation support is broken */
-	#define UFSHCD_QUIRK_BROKEN_INTR_AGGR			UFS_BIT(0)
+	#define UFSHCD_QUIRK_BROKEN_INTR_AGGR			0x1
 
 	/*
 	 * delay before each dme command is required as the unipro
 	 * layer has shown instabilities
 	 */
-	#define UFSHCD_QUIRK_DELAY_BEFORE_DME_CMDS		UFS_BIT(1)
+	#define UFSHCD_QUIRK_DELAY_BEFORE_DME_CMDS		0x2
 
 	/*
 	 * If UFS host controller is having issue in processing LCC (Line
@@ -561,21 +561,21 @@ struct ufs_hba {
 	 * the LCC transmission on UFS device (by clearing TX_LCC_ENABLE
 	 * attribute of device to 0).
 	 */
-	#define UFSHCD_QUIRK_BROKEN_LCC				UFS_BIT(2)
+	#define UFSHCD_QUIRK_BROKEN_LCC				0x4
 
 	/*
 	 * The attribute PA_RXHSUNTERMCAP specifies whether or not the
 	 * inbound Link supports unterminated line in HS mode. Setting this
 	 * attribute to 1 fixes moving to HS gear.
 	 */
-	#define UFSHCD_QUIRK_BROKEN_PA_RXHSUNTERMCAP		UFS_BIT(3)
+	#define UFSHCD_QUIRK_BROKEN_PA_RXHSUNTERMCAP		0x8
 
 	/*
 	 * This quirk needs to be enabled if the host contoller only allows
 	 * accessing the peer dme attributes in AUTO mode (FAST AUTO or
 	 * SLOW AUTO).
 	 */
-	#define UFSHCD_QUIRK_DME_PEER_ACCESS_AUTO_MODE		UFS_BIT(4)
+	#define UFSHCD_QUIRK_DME_PEER_ACCESS_AUTO_MODE		0x10
 
 	/*
 	 * This quirk needs to be enabled if the host contoller doesn't
@@ -583,13 +583,13 @@ struct ufs_hba {
 	 * is enabled, standard UFS host driver will call the vendor specific
 	 * ops (get_ufs_hci_version) to get the correct version.
 	 */
-	#define UFSHCD_QUIRK_BROKEN_UFS_HCI_VERSION		UFS_BIT(5)
+	#define UFSHCD_QUIRK_BROKEN_UFS_HCI_VERSION		0x20
 
 	/*
 	 * This quirk needs to be enabled if the host contoller regards
 	 * resolution of the values of PRDTO and PRDTL in UTRD as byte.
 	 */
-	#define UFSHCD_QUIRK_PRDT_BYTE_GRAN			UFS_BIT(7)
+	#define UFSHCD_QUIRK_PRDT_BYTE_GRAN			0x80
 
 	unsigned int quirks;	/* Deviations from standard UFSHCI spec. */
 

commit 090171885f505ea6814ad6459e9982bb4444c245
Author: Zang Leigang <zangleigang@hisilicon.com>
Date:   Wed Sep 27 10:06:06 2017 +0800

    scsi: ufs: add ufs a command complete time stamp
    
    Signed-off-by: Zang Leigang <zangleigang@hisilicon.com>
    Reviewed-by: Subhash Jadavani <subhashj@codeaurora.org>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/ufs/ufshcd.h b/drivers/scsi/ufs/ufshcd.h
index cdc8bd05f7df..40ea4759a02f 100644
--- a/drivers/scsi/ufs/ufshcd.h
+++ b/drivers/scsi/ufs/ufshcd.h
@@ -166,6 +166,7 @@ struct ufs_pm_lvl_states {
  * @lun: LUN of the command
  * @intr_cmd: Interrupt command (doesn't participate in interrupt aggregation)
  * @issue_time_stamp: time stamp for debug purposes
+ * @compl_time_stamp: time stamp for statistics
  * @req_abort_skip: skip request abort task flag
  */
 struct ufshcd_lrb {
@@ -189,6 +190,7 @@ struct ufshcd_lrb {
 	u8 lun; /* UPIU LUN id field is only 8-bit wide */
 	bool intr_cmd;
 	ktime_t issue_time_stamp;
+	ktime_t compl_time_stamp;
 
 	bool req_abort_skip;
 };

commit a4b0e8a4e92b1baa860e744847fbdb84a50a5071
Author: Potomski, MichalX <michalx.potomski@intel.com>
Date:   Thu Feb 23 09:05:30 2017 +0000

    scsi: ufs: Factor out ufshcd_read_desc_param
    
    Since in UFS 2.1 specification some of the descriptor lengths differs
    from 2.0 specification and some devices, which are reporting spec
    version 2.0 have different descriptor lengths we can not rely on
    hardcoded values taken from 2.0 specification. This patch introduces
    reading these lengths per each device from descriptor headers at probe
    time to ensure their correctness.
    
    Signed-off-by: Michal' Potomski <michalx.potomski@intel.com>
    Reviewed-by: Subhash Jadavani <subhashj@codeaurora.org>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/ufs/ufshcd.h b/drivers/scsi/ufs/ufshcd.h
index 7630600217a2..cdc8bd05f7df 100644
--- a/drivers/scsi/ufs/ufshcd.h
+++ b/drivers/scsi/ufs/ufshcd.h
@@ -220,6 +220,15 @@ struct ufs_dev_cmd {
 	struct ufs_query query;
 };
 
+struct ufs_desc_size {
+	int dev_desc;
+	int pwr_desc;
+	int geom_desc;
+	int interc_desc;
+	int unit_desc;
+	int conf_desc;
+};
+
 /**
  * struct ufs_clk_info - UFS clock related info
  * @list: list headed by hba->clk_list_head
@@ -483,6 +492,7 @@ struct ufs_stats {
  * @clk_list_head: UFS host controller clocks list node head
  * @pwr_info: holds current power mode
  * @max_pwr_info: keeps the device max valid pwm
+ * @desc_size: descriptor sizes reported by device
  * @urgent_bkops_lvl: keeps track of urgent bkops level for device
  * @is_urgent_bkops_lvl_checked: keeps track if the urgent bkops level for
  *  device is known or not.
@@ -666,6 +676,7 @@ struct ufs_hba {
 	bool is_urgent_bkops_lvl_checked;
 
 	struct rw_semaphore clk_scaling_lock;
+	struct ufs_desc_size desc_size;
 };
 
 /* Returns true if clocks can be gated. Otherwise false */
@@ -832,6 +843,10 @@ int ufshcd_query_flag(struct ufs_hba *hba, enum query_opcode opcode,
 	enum flag_idn idn, bool *flag_res);
 int ufshcd_hold(struct ufs_hba *hba, bool async);
 void ufshcd_release(struct ufs_hba *hba);
+
+int ufshcd_map_desc_id_to_length(struct ufs_hba *hba, enum desc_idn desc_id,
+	int *desc_length);
+
 u32 ufshcd_get_local_unipro_ver(struct ufs_hba *hba);
 
 /* Wrapper functions for safely calling variant operations */

commit 401f1e4490ee9d6e74d7514903dd01dae61488bf
Author: subhashj@codeaurora.org <subhashj@codeaurora.org>
Date:   Fri Feb 3 16:57:39 2017 -0800

    scsi: ufs: don't suspend clock scaling during clock gating
    
    Currently we are suspending clock scaling during clock gating which doesn't
    allow us to have clock gating timeout lower than clock scaling polling
    window. If clock gating timeout is smaller than the clock scaling polling
    window then we will mostly suspend the clock scaling before clock scaling
    polling window expires and we might get stuck in same state (scaled down
    or scaled up) for quite a long time. And for this reason, we have clock
    gating timeout (150ms) greater than clock scaling polling window (100ms).
    
    We would like to have aggressive clock gating timeout even lower than the
    clock scaling polling window hence this change is decoupling the clock
    scaling suspend/resume from clock gate/ungate. We will not suspend the
    clock scaling as part of clock gating instead clock scaling context will
    schedule scaling suspend work if there are no more pending transfer
    requests.
    
    Signed-off-by: Subhash Jadavani <subhashj@codeaurora.org>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/ufs/ufshcd.h b/drivers/scsi/ufs/ufshcd.h
index 4da2bbd617e8..7630600217a2 100644
--- a/drivers/scsi/ufs/ufshcd.h
+++ b/drivers/scsi/ufs/ufshcd.h
@@ -357,14 +357,37 @@ struct ufs_saved_pwr_info {
 	bool is_valid;
 };
 
+/**
+ * struct ufs_clk_scaling - UFS clock scaling related data
+ * @active_reqs: number of requests that are pending. If this is zero when
+ * devfreq ->target() function is called then schedule "suspend_work" to
+ * suspend devfreq.
+ * @tot_busy_t: Total busy time in current polling window
+ * @window_start_t: Start time (in jiffies) of the current polling window
+ * @busy_start_t: Start time of current busy period
+ * @enable_attr: sysfs attribute to enable/disable clock scaling
+ * @saved_pwr_info: UFS power mode may also be changed during scaling and this
+ * one keeps track of previous power mode.
+ * @workq: workqueue to schedule devfreq suspend/resume work
+ * @suspend_work: worker to suspend devfreq
+ * @resume_work: worker to resume devfreq
+ * @is_allowed: tracks if scaling is currently allowed or not
+ * @is_busy_started: tracks if busy period has started or not
+ * @is_suspended: tracks if devfreq is suspended or not
+ */
 struct ufs_clk_scaling {
-	ktime_t  busy_start_t;
-	bool is_busy_started;
-	unsigned long  tot_busy_t;
+	int active_reqs;
+	unsigned long tot_busy_t;
 	unsigned long window_start_t;
+	ktime_t busy_start_t;
 	struct device_attribute enable_attr;
-	bool is_allowed;
 	struct ufs_saved_pwr_info saved_pwr_info;
+	struct workqueue_struct *workq;
+	struct work_struct suspend_work;
+	struct work_struct resume_work;
+	bool is_allowed;
+	bool is_busy_started;
+	bool is_suspended;
 };
 
 /**

commit a3cd5ec55f6c72834f812f9150deb38ddc019782
Author: subhashj@codeaurora.org <subhashj@codeaurora.org>
Date:   Fri Feb 3 16:57:02 2017 -0800

    scsi: ufs: add load based scaling of UFS gear
    
    UFS driver's load based clock scaling feature scales down the ufs related
    clocks in order to allow low power modes of chipsets. UniPro 1.6 supports
    maximum gear up to HS-G3 (High Speed Gear3) and some of the chipsets
    low power modes may not be allowed in HS-G3 hence this change adds support
    to scale gear between HS-G3 and HS-G1 based on same existing load based
    clock scaling logic.
    
    Signed-off-by: Subhash Jadavani <subhashj@codeaurora.org>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/ufs/ufshcd.h b/drivers/scsi/ufs/ufshcd.h
index b7ce12996a19..4da2bbd617e8 100644
--- a/drivers/scsi/ufs/ufshcd.h
+++ b/drivers/scsi/ufs/ufshcd.h
@@ -45,6 +45,7 @@
 #include <linux/delay.h>
 #include <linux/slab.h>
 #include <linux/spinlock.h>
+#include <linux/rwsem.h>
 #include <linux/workqueue.h>
 #include <linux/errno.h>
 #include <linux/types.h>
@@ -351,6 +352,11 @@ struct ufs_clk_gating {
 	int active_reqs;
 };
 
+struct ufs_saved_pwr_info {
+	struct ufs_pa_layer_attr info;
+	bool is_valid;
+};
+
 struct ufs_clk_scaling {
 	ktime_t  busy_start_t;
 	bool is_busy_started;
@@ -358,6 +364,7 @@ struct ufs_clk_scaling {
 	unsigned long window_start_t;
 	struct device_attribute enable_attr;
 	bool is_allowed;
+	struct ufs_saved_pwr_info saved_pwr_info;
 };
 
 /**
@@ -634,6 +641,8 @@ struct ufs_hba {
 
 	enum bkops_status urgent_bkops_lvl;
 	bool is_urgent_bkops_lvl_checked;
+
+	struct rw_semaphore clk_scaling_lock;
 };
 
 /* Returns true if clocks can be gated. Otherwise false */

commit 7fabb77b3aa01651f9ebc7c139a253bcabb06880
Author: Gilad Broner <gbroner@codeaurora.org>
Date:   Fri Feb 3 16:56:50 2017 -0800

    scsi: ufs: reduce printout for aborted requests
    
    Details printed for each request that is aborted can overload the
    target as there can be several requests that are aborted at once.
    This change will print full request details only for the first
    aborted request since the last link reset, and minimal details
    for other subsequent requests.
    
    Signed-off-by: Gilad Broner <gbroner@codeaurora.org>
    Signed-off-by: Subhash Jadavani <subhashj@codeaurora.org>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/ufs/ufshcd.h b/drivers/scsi/ufs/ufshcd.h
index 292fc14522c7..b7ce12996a19 100644
--- a/drivers/scsi/ufs/ufshcd.h
+++ b/drivers/scsi/ufs/ufshcd.h
@@ -594,6 +594,9 @@ struct ufs_hba {
 
 	bool wlun_dev_clr_ua;
 
+	/* Number of requests aborts */
+	int req_abort_count;
+
 	/* Number of lanes available (1 or 2) for Rx/Tx */
 	u32 lanes_per_direction;
 	struct ufs_pa_layer_attr pwr_info;

commit e0b299e36004f58f844b776df58f6882877bb18a
Author: Gilad Broner <gbroner@codeaurora.org>
Date:   Fri Feb 3 16:56:40 2017 -0800

    scsi: ufs: skip request abort task when previous aborts failed
    
    On certain error conditions request abort task itself might fail
    when aborting a request. In such case, subsequent request aborts
    should skip issuing the abort task as it is expected to fail as well,
    and device reset handler will be called next.
    
    Signed-off-by: Gilad Broner <gbroner@codeaurora.org>
    Signed-off-by: Subhash Jadavani <subhashj@codeaurora.org>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/ufs/ufshcd.h b/drivers/scsi/ufs/ufshcd.h
index 7ffcde21975b..292fc14522c7 100644
--- a/drivers/scsi/ufs/ufshcd.h
+++ b/drivers/scsi/ufs/ufshcd.h
@@ -165,6 +165,7 @@ struct ufs_pm_lvl_states {
  * @lun: LUN of the command
  * @intr_cmd: Interrupt command (doesn't participate in interrupt aggregation)
  * @issue_time_stamp: time stamp for debug purposes
+ * @req_abort_skip: skip request abort task flag
  */
 struct ufshcd_lrb {
 	struct utp_transfer_req_desc *utr_descriptor_ptr;
@@ -187,6 +188,8 @@ struct ufshcd_lrb {
 	u8 lun; /* UPIU LUN id field is only 8-bit wide */
 	bool intr_cmd;
 	ktime_t issue_time_stamp;
+
+	bool req_abort_skip;
 };
 
 /**

commit 8209b6d54e7e2f8b305da831c78629b65d144f91
Author: Tomas Winkler <tomas.winkler@intel.com>
Date:   Thu Jan 5 10:45:10 2017 +0200

    scsi: ufs: unexport descritpor reading functions
    
    Unexport ufshcd_read_device_desc and ufshcd_read_string_desc there is no
    really possibility to calling them directly outside of UFS context.
    
    Signed-off-by: Tomas Winkler <tomas.winkler@intel.com>
    Reviewed-by: Subhash Jadavani <subhashj@codeaurora.org>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/ufs/ufshcd.h b/drivers/scsi/ufs/ufshcd.h
index 0ea49f982cac..7ffcde21975b 100644
--- a/drivers/scsi/ufs/ufshcd.h
+++ b/drivers/scsi/ufs/ufshcd.h
@@ -781,8 +781,6 @@ static inline int ufshcd_dme_peer_get(struct ufs_hba *hba,
 	return ufshcd_dme_get_attr(hba, attr_sel, mib_val, DME_PEER);
 }
 
-int ufshcd_read_device_desc(struct ufs_hba *hba, u8 *buf, u32 size);
-
 static inline bool ufshcd_is_hs_mode(struct ufs_pa_layer_attr *pwr_info)
 {
 	return (pwr_info->pwr_rx == FAST_MODE ||
@@ -791,11 +789,6 @@ static inline bool ufshcd_is_hs_mode(struct ufs_pa_layer_attr *pwr_info)
 		pwr_info->pwr_tx == FASTAUTO_MODE);
 }
 
-#define ASCII_STD true
-
-int ufshcd_read_string_desc(struct ufs_hba *hba, int desc_index, u8 *buf,
-				u32 size, bool ascii);
-
 /* Expose Query-Request API */
 int ufshcd_query_flag(struct ufs_hba *hba, enum query_opcode opcode,
 	enum flag_idn idn, bool *flag_res);

commit ff8e20c66249210563aaea5382b08c94933f720d
Author: Dolev Raviv <draviv@codeaurora.org>
Date:   Thu Dec 22 18:42:18 2016 -0800

    scsi: ufs: Improve fatal error logs
    
    Errors such as UIC error, illegal OCS values, and others may require
    more information for debugging. Such information could be hibern8 events,
    events sequences, recoverable errors, error history, and more.
    This patch improves tracking of important errors and events in debug level
    to be enabled when debugging a such issues. It includes:
    * UIC error history
    * Successful hibern8 events
    * Successful command after hibern8 exit
    * Clk-freq info
    * Failed device command
    * Infrastructure for dumping host controller debug information
    
    Signed-off-by: Dolev Raviv <draviv@codeaurora.org>
    Signed-off-by: Subhash Jadavani <subhashj@codeaurora.org>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/ufs/ufshcd.h b/drivers/scsi/ufs/ufshcd.h
index f25d4684ef0e..0ea49f982cac 100644
--- a/drivers/scsi/ufs/ufshcd.h
+++ b/drivers/scsi/ufs/ufshcd.h
@@ -152,6 +152,10 @@ struct ufs_pm_lvl_states {
  * @ucd_req_ptr: UCD address of the command
  * @ucd_rsp_ptr: Response UPIU address for this command
  * @ucd_prdt_ptr: PRDT address of the command
+ * @utrd_dma_addr: UTRD dma address for debug
+ * @ucd_prdt_dma_addr: PRDT dma address for debug
+ * @ucd_rsp_dma_addr: UPIU response dma address for debug
+ * @ucd_req_dma_addr: UPIU request dma address for debug
  * @cmd: pointer to SCSI command
  * @sense_buffer: pointer to sense buffer address of the SCSI command
  * @sense_bufflen: Length of the sense buffer
@@ -160,6 +164,7 @@ struct ufs_pm_lvl_states {
  * @task_tag: Task tag of the command
  * @lun: LUN of the command
  * @intr_cmd: Interrupt command (doesn't participate in interrupt aggregation)
+ * @issue_time_stamp: time stamp for debug purposes
  */
 struct ufshcd_lrb {
 	struct utp_transfer_req_desc *utr_descriptor_ptr;
@@ -167,6 +172,11 @@ struct ufshcd_lrb {
 	struct utp_upiu_rsp *ucd_rsp_ptr;
 	struct ufshcd_sg_entry *ucd_prdt_ptr;
 
+	dma_addr_t utrd_dma_addr;
+	dma_addr_t ucd_req_dma_addr;
+	dma_addr_t ucd_rsp_dma_addr;
+	dma_addr_t ucd_prdt_dma_addr;
+
 	struct scsi_cmnd *cmd;
 	u8 *sense_buffer;
 	unsigned int sense_bufflen;
@@ -176,6 +186,7 @@ struct ufshcd_lrb {
 	int task_tag;
 	u8 lun; /* UPIU LUN id field is only 8-bit wide */
 	bool intr_cmd;
+	ktime_t issue_time_stamp;
 };
 
 /**
@@ -355,6 +366,41 @@ struct ufs_init_prefetch {
 	u32 icc_level;
 };
 
+#define UIC_ERR_REG_HIST_LENGTH 8
+/**
+ * struct ufs_uic_err_reg_hist - keeps history of uic errors
+ * @pos: index to indicate cyclic buffer position
+ * @reg: cyclic buffer for registers value
+ * @tstamp: cyclic buffer for time stamp
+ */
+struct ufs_uic_err_reg_hist {
+	int pos;
+	u32 reg[UIC_ERR_REG_HIST_LENGTH];
+	ktime_t tstamp[UIC_ERR_REG_HIST_LENGTH];
+};
+
+/**
+ * struct ufs_stats - keeps usage/err statistics
+ * @hibern8_exit_cnt: Counter to keep track of number of exits,
+ *		reset this after link-startup.
+ * @last_hibern8_exit_tstamp: Set time after the hibern8 exit.
+ *		Clear after the first successful command completion.
+ * @pa_err: tracks pa-uic errors
+ * @dl_err: tracks dl-uic errors
+ * @nl_err: tracks nl-uic errors
+ * @tl_err: tracks tl-uic errors
+ * @dme_err: tracks dme errors
+ */
+struct ufs_stats {
+	u32 hibern8_exit_cnt;
+	ktime_t last_hibern8_exit_tstamp;
+	struct ufs_uic_err_reg_hist pa_err;
+	struct ufs_uic_err_reg_hist dl_err;
+	struct ufs_uic_err_reg_hist nl_err;
+	struct ufs_uic_err_reg_hist tl_err;
+	struct ufs_uic_err_reg_hist dme_err;
+};
+
 /**
  * struct ufs_hba - per adapter private structure
  * @mmio_base: UFSHCI base register address
@@ -531,6 +577,7 @@ struct ufs_hba {
 	u32 uic_error;
 	u32 saved_err;
 	u32 saved_uic_err;
+	struct ufs_stats ufs_stats;
 
 	/* Device management request data */
 	struct ufs_dev_cmd dev_cmd;

commit 4e768e7645ec4ffa92ee163643777b261ae97142
Author: subhashj@codeaurora.org <subhashj@codeaurora.org>
Date:   Thu Dec 22 18:41:22 2016 -0800

    scsi: ufs: add capability to keep auto bkops always enabled
    
    UFS device requires to perform bkops (back ground operations) periodically
    but host can control (via auto-bkops parameter of device) when device can
    perform bkops based on its performance requirements. In general, host
    would like to enable the device's auto-bkops only when it's not doing any
    regular data transfer but sometimes device may not behave properly if host
    keeps the auto-bkops disabled. This change adds the capability to let the
    device auto-bkops always enabled except suspend.
    
    Reviewed-by: Sahitya Tummala <stummala@codeaurora.org>
    Signed-off-by: Subhash Jadavani <subhashj@codeaurora.org>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/ufs/ufshcd.h b/drivers/scsi/ufs/ufshcd.h
index 787323be0919..f25d4684ef0e 100644
--- a/drivers/scsi/ufs/ufshcd.h
+++ b/drivers/scsi/ufs/ufshcd.h
@@ -566,6 +566,14 @@ struct ufs_hba {
 	 * CAUTION: Enabling this might reduce overall UFS throughput.
 	 */
 #define UFSHCD_CAP_INTR_AGGR (1 << 4)
+	/*
+	 * This capability allows the device auto-bkops to be always enabled
+	 * except during suspend (both runtime and suspend).
+	 * Enabling this capability means that device will always be allowed
+	 * to do background operation when it's active but it might degrade
+	 * the performance of ongoing read/write operations.
+	 */
+#define UFSHCD_CAP_KEEP_AUTO_BKOPS_ENABLED_EXCEPT_SUSPEND (1 << 5)
 
 	struct devfreq *devfreq;
 	struct ufs_clk_scaling clk_scaling;
@@ -663,6 +671,11 @@ static inline void *ufshcd_get_variant(struct ufs_hba *hba)
 	BUG_ON(!hba);
 	return hba->priv;
 }
+static inline bool ufshcd_keep_autobkops_enabled_except_suspend(
+							struct ufs_hba *hba)
+{
+	return hba->caps & UFSHCD_CAP_KEEP_AUTO_BKOPS_ENABLED_EXCEPT_SUSPEND;
+}
 
 extern int ufshcd_runtime_suspend(struct ufs_hba *hba);
 extern int ufshcd_runtime_resume(struct ufs_hba *hba);

commit 09690d5a6ae1b7e4cb5ac429c311b99d09352c12
Author: subhashj@codeaurora.org <subhashj@codeaurora.org>
Date:   Thu Dec 22 18:41:00 2016 -0800

    scsi: ufs: provide sysfs attribute to select the PM level
    
    This patch provides the sysfs attribute to choose the power management
    level for UFS runtime and system suspend.
    
    Reviewed-by: Sujit Reddy Thumma <sthumma@codeaurora.org>
    Signed-off-by: Subhash Jadavani <subhashj@codeaurora.org>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/ufs/ufshcd.h b/drivers/scsi/ufs/ufshcd.h
index bdd2284967f2..787323be0919 100644
--- a/drivers/scsi/ufs/ufshcd.h
+++ b/drivers/scsi/ufs/ufshcd.h
@@ -435,6 +435,8 @@ struct ufs_hba {
 	enum ufs_pm_level rpm_lvl;
 	/* Desired UFS power management level during system PM */
 	enum ufs_pm_level spm_lvl;
+	struct device_attribute rpm_lvl_attr;
+	struct device_attribute spm_lvl_attr;
 	int pm_op_in_progress;
 
 	struct ufshcd_lrb *lrb;

commit fcb0c4b08a18fe35c3adc594d3edc8e335ff7960
Author: Sahitya Tummala <stummala@codeaurora.org>
Date:   Thu Dec 22 18:40:50 2016 -0800

    scsi: ufs: Add sysfs node to dynamically control clock scaling
    
    Provide an option to enable/disable clock scaling during runtime.
    Write 1/0 to "clkscale_enable" sysfs node to enable/disable clock
    scaling.
    
    Signed-off-by: Sahitya Tummala <stummala@codeaurora.org>
    Signed-off-by: Subhash Jadavani <subhashj@codeaurora.org>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/ufs/ufshcd.h b/drivers/scsi/ufs/ufshcd.h
index 0882ba67ccb1..bdd2284967f2 100644
--- a/drivers/scsi/ufs/ufshcd.h
+++ b/drivers/scsi/ufs/ufshcd.h
@@ -342,6 +342,8 @@ struct ufs_clk_scaling {
 	bool is_busy_started;
 	unsigned long  tot_busy_t;
 	unsigned long window_start_t;
+	struct device_attribute enable_attr;
+	bool is_allowed;
 };
 
 /**
@@ -580,7 +582,7 @@ static inline bool ufshcd_can_hibern8_during_gating(struct ufs_hba *hba)
 {
 	return hba->caps & UFSHCD_CAP_HIBERN8_WITH_CLK_GATING;
 }
-static inline int ufshcd_is_clkscaling_enabled(struct ufs_hba *hba)
+static inline int ufshcd_is_clkscaling_supported(struct ufs_hba *hba)
 {
 	return hba->caps & UFSHCD_CAP_CLK_SCALING;
 }

commit b427411abb3d61c234cb7dd58bc9b9f92c0fd8cb
Author: Sahitya Tummala <stummala@codeaurora.org>
Date:   Thu Dec 22 18:40:39 2016 -0800

    scsi: ufs: Add sysfs node to dynamically control clock gating
    
    Provide an option to enable/disable clock gating during runtime.
    Write 1 or 0 to "clkgate_enable" sysfs node to enable/disable
    clock gating.
    
    Signed-off-by: Sahitya Tummala <stummala@codeaurora.org>
    Signed-off-by: Subhash Jadavani <subhashj@codeaurora.org>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/ufs/ufshcd.h b/drivers/scsi/ufs/ufshcd.h
index 08cd26ed2382..0882ba67ccb1 100644
--- a/drivers/scsi/ufs/ufshcd.h
+++ b/drivers/scsi/ufs/ufshcd.h
@@ -320,6 +320,8 @@ enum clk_gating_state {
  * @is_suspended: clk gating is suspended when set to 1 which can be used
  * during suspend/resume
  * @delay_attr: sysfs attribute to control delay_attr
+ * @enable_attr: sysfs attribute to enable/disable clock gating
+ * @is_enabled: Indicates the current status of clock gating
  * @active_reqs: number of requests that are pending and should be waited for
  * completion before gating clocks.
  */
@@ -330,6 +332,8 @@ struct ufs_clk_gating {
 	unsigned long delay_ms;
 	bool is_suspended;
 	struct device_attribute delay_attr;
+	struct device_attribute enable_attr;
+	bool is_enabled;
 	int active_reqs;
 };
 

commit 56d4a1866d748732fd8d690b2c2156bbc9c9eb02
Author: Subhash Jadavani <subhashj@codeaurora.org>
Date:   Mon Dec 5 19:25:32 2016 -0800

    scsi: ufs: add quirk to increase host PA_SaveConfigTime
    
    The maximum value PA_SaveConfigTime is 250 (10us) but this is not enough
    for some vendors. Gear switch from PWM to HS may fail even with this
    max.  PA_SaveConfigTime. Gear switch can be issued by host controller as
    an error recovery and any software delay will not help on this case so
    we need to increase PA_SaveConfigTime to >32us as per vendor
    recommendation.  This change adds a quirk to increase the
    PA_SaveConfigTime parameter.
    
    Reviewed-by: Venkat Gopalakrishnan <venkatg@codeaurora.org>
    Signed-off-by: Subhash Jadavani <subhashj@codeaurora.org>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/ufs/ufshcd.h b/drivers/scsi/ufs/ufshcd.h
index 7d9ff22acfea..08cd26ed2382 100644
--- a/drivers/scsi/ufs/ufshcd.h
+++ b/drivers/scsi/ufs/ufshcd.h
@@ -266,7 +266,7 @@ struct ufs_pwr_mode_info {
  * @setup_task_mgmt: called before any task management request is issued
  *                  to set some things
  * @hibern8_notify: called around hibern8 enter/exit
- *		    to configure some things
+ * @apply_dev_quirks: called to apply device specific quirks
  * @suspend: called during host controller PM callback
  * @resume: called during host controller PM callback
  * @dbg_register_dump: used to dump controller debug information
@@ -293,7 +293,8 @@ struct ufs_hba_variant_ops {
 	void	(*setup_xfer_req)(struct ufs_hba *, int, bool);
 	void	(*setup_task_mgmt)(struct ufs_hba *, int, u8);
 	void    (*hibern8_notify)(struct ufs_hba *, enum uic_cmd_dme,
-				       enum ufs_notify_change_status);
+					enum ufs_notify_change_status);
+	int	(*apply_dev_quirks)(struct ufs_hba *);
 	int     (*suspend)(struct ufs_hba *, enum ufs_pm_op);
 	int     (*resume)(struct ufs_hba *, enum ufs_pm_op);
 	void	(*dbg_register_dump)(struct ufs_hba *hba);
@@ -839,6 +840,13 @@ static inline void ufshcd_vops_hibern8_notify(struct ufs_hba *hba,
 		return hba->vops->hibern8_notify(hba, cmd, status);
 }
 
+static inline int ufshcd_vops_apply_dev_quirks(struct ufs_hba *hba)
+{
+	if (hba->vops && hba->vops->apply_dev_quirks)
+		return hba->vops->apply_dev_quirks(hba);
+	return 0;
+}
+
 static inline int ufshcd_vops_suspend(struct ufs_hba *hba, enum ufs_pm_op op)
 {
 	if (hba->vops && hba->vops->suspend)

commit 75b1cc4ad63afa28c1a045b5157c008f405f06a9
Author: Kiwoong Kim <kwmad.kim@samsung.com>
Date:   Tue Nov 22 17:06:59 2016 +0900

    scsi: ufs: introduce UFSHCD_QUIRK_PRDT_BYTE_GRAN quirk
    
    Some UFS host controllers may think granularities of PRDT length and
    offset as bytes, not double words.
    
    Signed-off-by: Kiwoong Kim <kwmad.kim@samsung.com>
    Reviewed-by: Subhash Jadavani <subhashj@codeaurora.org>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/ufs/ufshcd.h b/drivers/scsi/ufs/ufshcd.h
index 8e76501144d6..7d9ff22acfea 100644
--- a/drivers/scsi/ufs/ufshcd.h
+++ b/drivers/scsi/ufs/ufshcd.h
@@ -485,6 +485,12 @@ struct ufs_hba {
 	 */
 	#define UFSHCD_QUIRK_BROKEN_UFS_HCI_VERSION		UFS_BIT(5)
 
+	/*
+	 * This quirk needs to be enabled if the host contoller regards
+	 * resolution of the values of PRDTO and PRDTL in UTRD as byte.
+	 */
+	#define UFSHCD_QUIRK_PRDT_BYTE_GRAN			UFS_BIT(7)
+
 	unsigned int quirks;	/* Deviations from standard UFSHCI spec. */
 
 	/* Device deviations from standard UFS device spec. */

commit ee32c9098f2eff12c0e020aac2acade8250c80e4
Author: Kiwoong Kim <kwmad.kim@samsung.com>
Date:   Thu Nov 10 21:17:43 2016 +0900

    scsi: ufs: introduce hibern8_notify callback
    
    Some UFS host controller may need to configure some things around
    hibern8 enter/exit
    
    Signed-off-by: Kiwoong Kim <kwmad.kim@samsung.com>
    Reviewed-by: Subhash Jadavani <subhashj@codeaurora.org>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/ufs/ufshcd.h b/drivers/scsi/ufs/ufshcd.h
index 05d8384a9b2a..8e76501144d6 100644
--- a/drivers/scsi/ufs/ufshcd.h
+++ b/drivers/scsi/ufs/ufshcd.h
@@ -265,6 +265,8 @@ struct ufs_pwr_mode_info {
  *                  to set some things
  * @setup_task_mgmt: called before any task management request is issued
  *                  to set some things
+ * @hibern8_notify: called around hibern8 enter/exit
+ *		    to configure some things
  * @suspend: called during host controller PM callback
  * @resume: called during host controller PM callback
  * @dbg_register_dump: used to dump controller debug information
@@ -290,6 +292,8 @@ struct ufs_hba_variant_ops {
 					struct ufs_pa_layer_attr *);
 	void	(*setup_xfer_req)(struct ufs_hba *, int, bool);
 	void	(*setup_task_mgmt)(struct ufs_hba *, int, u8);
+	void    (*hibern8_notify)(struct ufs_hba *, enum uic_cmd_dme,
+				       enum ufs_notify_change_status);
 	int     (*suspend)(struct ufs_hba *, enum ufs_pm_op);
 	int     (*resume)(struct ufs_hba *, enum ufs_pm_op);
 	void	(*dbg_register_dump)(struct ufs_hba *hba);
@@ -821,6 +825,14 @@ static inline void ufshcd_vops_setup_task_mgmt(struct ufs_hba *hba,
 		return hba->vops->setup_task_mgmt(hba, tag, tm_function);
 }
 
+static inline void ufshcd_vops_hibern8_notify(struct ufs_hba *hba,
+					enum uic_cmd_dme cmd,
+					enum ufs_notify_change_status status)
+{
+	if (hba->vops && hba->vops->hibern8_notify)
+		return hba->vops->hibern8_notify(hba, cmd, status);
+}
+
 static inline int ufshcd_vops_suspend(struct ufs_hba *hba, enum ufs_pm_op op)
 {
 	if (hba->vops && hba->vops->suspend)

commit d2877be42f35a8420dc452cf775b5f99b55169aa
Author: Kiwoong Kim <kwmad.kim@samsung.com>
Date:   Thu Nov 10 21:16:15 2016 +0900

    scsi: ufs: introduce setup_task_mgmt
    
    Some UFS host controller may need to configure some things before any
    task management request is issued
    
    Signed-off-by: Kiwoong Kim <kwmad.kim@samsung.com>
    Reviewed-by: Subhash Jadavani <subhashj@codeaurora.org>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/ufs/ufshcd.h b/drivers/scsi/ufs/ufshcd.h
index e935fd1b6b3a..05d8384a9b2a 100644
--- a/drivers/scsi/ufs/ufshcd.h
+++ b/drivers/scsi/ufs/ufshcd.h
@@ -263,6 +263,8 @@ struct ufs_pwr_mode_info {
  *			to be set.
  * @setup_xfer_req: called before any transfer request is issued
  *                  to set some things
+ * @setup_task_mgmt: called before any task management request is issued
+ *                  to set some things
  * @suspend: called during host controller PM callback
  * @resume: called during host controller PM callback
  * @dbg_register_dump: used to dump controller debug information
@@ -287,6 +289,7 @@ struct ufs_hba_variant_ops {
 					struct ufs_pa_layer_attr *,
 					struct ufs_pa_layer_attr *);
 	void	(*setup_xfer_req)(struct ufs_hba *, int, bool);
+	void	(*setup_task_mgmt)(struct ufs_hba *, int, u8);
 	int     (*suspend)(struct ufs_hba *, enum ufs_pm_op);
 	int     (*resume)(struct ufs_hba *, enum ufs_pm_op);
 	void	(*dbg_register_dump)(struct ufs_hba *hba);
@@ -811,6 +814,13 @@ static inline void ufshcd_vops_setup_xfer_req(struct ufs_hba *hba, int tag,
 		return hba->vops->setup_xfer_req(hba, tag, is_scsi_cmd);
 }
 
+static inline void ufshcd_vops_setup_task_mgmt(struct ufs_hba *hba,
+					int tag, u8 tm_function)
+{
+	if (hba->vops && hba->vops->setup_task_mgmt)
+		return hba->vops->setup_task_mgmt(hba, tag, tm_function);
+}
+
 static inline int ufshcd_vops_suspend(struct ufs_hba *hba, enum ufs_pm_op op)
 {
 	if (hba->vops && hba->vops->suspend)

commit 0e675efa9e9edef113bb55b25d1f22b1ae8225f4
Author: Kiwoong Kim <kwmad.kim@samsung.com>
Date:   Thu Nov 10 21:14:36 2016 +0900

    scsi: ufs: introduce setup_xfer_req callback
    
    Some UFS host controller may need to configure some things before any
    transfer request is issued.
    
    Signed-off-by: Kiwoong Kim <kwmad.kim@samsung.com>
    Reviewed-by: Subhash Jadavani <subhashj@codeaurora.org>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/ufs/ufshcd.h b/drivers/scsi/ufs/ufshcd.h
index afff7f4de81b..e935fd1b6b3a 100644
--- a/drivers/scsi/ufs/ufshcd.h
+++ b/drivers/scsi/ufs/ufshcd.h
@@ -261,6 +261,8 @@ struct ufs_pwr_mode_info {
  * @pwr_change_notify: called before and after a power mode change
  *			is carried out to allow vendor spesific capabilities
  *			to be set.
+ * @setup_xfer_req: called before any transfer request is issued
+ *                  to set some things
  * @suspend: called during host controller PM callback
  * @resume: called during host controller PM callback
  * @dbg_register_dump: used to dump controller debug information
@@ -284,6 +286,7 @@ struct ufs_hba_variant_ops {
 					enum ufs_notify_change_status status,
 					struct ufs_pa_layer_attr *,
 					struct ufs_pa_layer_attr *);
+	void	(*setup_xfer_req)(struct ufs_hba *, int, bool);
 	int     (*suspend)(struct ufs_hba *, enum ufs_pm_op);
 	int     (*resume)(struct ufs_hba *, enum ufs_pm_op);
 	void	(*dbg_register_dump)(struct ufs_hba *hba);
@@ -801,6 +804,13 @@ static inline int ufshcd_vops_pwr_change_notify(struct ufs_hba *hba,
 	return -ENOTSUPP;
 }
 
+static inline void ufshcd_vops_setup_xfer_req(struct ufs_hba *hba, int tag,
+					bool is_scsi_cmd)
+{
+	if (hba->vops && hba->vops->setup_xfer_req)
+		return hba->vops->setup_xfer_req(hba, tag, is_scsi_cmd);
+}
+
 static inline int ufshcd_vops_suspend(struct ufs_hba *hba, enum ufs_pm_op op)
 {
 	if (hba->vops && hba->vops->suspend)

commit 1e879e8fa9f62e18d79bfc339050bf8fed7a81e4
Author: Subhash Jadavani <subhashj@codeaurora.org>
Date:   Thu Oct 6 21:48:22 2016 -0700

    scsi: ufshcd: Fix possible unclocked register access
    
    Vendor specific setup_clocks callback may require the clocks managed by
    ufshcd driver to be ON. So if the vendor specific setup_clocks callback
    is called while the required clocks are turned off, it could result into
    unclocked register access.
    
    To prevent possible unclock register access, this change adds one more
    argument to setup_clocks callback to let it know whether it is called
    pre/post the clock changes by core driver.
    
    Signed-off-by: Subhash Jadavani <subhashj@codeaurora.org>
    Reviewed-by: Kiwoong Kim <kwmad.kim@samsung.com>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/ufs/ufshcd.h b/drivers/scsi/ufs/ufshcd.h
index 430bef111293..afff7f4de81b 100644
--- a/drivers/scsi/ufs/ufshcd.h
+++ b/drivers/scsi/ufs/ufshcd.h
@@ -273,7 +273,8 @@ struct ufs_hba_variant_ops {
 	u32	(*get_ufs_hci_version)(struct ufs_hba *);
 	int	(*clk_scale_notify)(struct ufs_hba *, bool,
 				    enum ufs_notify_change_status);
-	int	(*setup_clocks)(struct ufs_hba *, bool);
+	int	(*setup_clocks)(struct ufs_hba *, bool,
+				enum ufs_notify_change_status);
 	int     (*setup_regulators)(struct ufs_hba *, bool);
 	int	(*hce_enable_notify)(struct ufs_hba *,
 				     enum ufs_notify_change_status);
@@ -755,10 +756,11 @@ static inline int ufshcd_vops_clk_scale_notify(struct ufs_hba *hba,
 	return 0;
 }
 
-static inline int ufshcd_vops_setup_clocks(struct ufs_hba *hba, bool on)
+static inline int ufshcd_vops_setup_clocks(struct ufs_hba *hba, bool on,
+					enum ufs_notify_change_status status)
 {
 	if (hba->vops && hba->vops->setup_clocks)
-		return hba->vops->setup_clocks(hba, on);
+		return hba->vops->setup_clocks(hba, on, status);
 	return 0;
 }
 

commit 4b9ffb5a353bdee49f1f477ffe2b95ab3f9cbc0c
Author: Joao Pinto <Joao.Pinto@synopsys.com>
Date:   Wed May 11 12:21:30 2016 +0100

    ufs: add support for DesignWare Controller
    
    This patch has the goal to add support for DesignWare UFS Controller
    specific operations.
    
    Signed-off-by: Joao Pinto <jpinto@synopsys.com>
    Reviewed-by: Hannes Reinicke <hare@suse.de>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/ufs/ufshcd.h b/drivers/scsi/ufs/ufshcd.h
index 4bb65669f052..430bef111293 100644
--- a/drivers/scsi/ufs/ufshcd.h
+++ b/drivers/scsi/ufs/ufshcd.h
@@ -264,6 +264,7 @@ struct ufs_pwr_mode_info {
  * @suspend: called during host controller PM callback
  * @resume: called during host controller PM callback
  * @dbg_register_dump: used to dump controller debug information
+ * @phy_initialization: used to initialize phys
  */
 struct ufs_hba_variant_ops {
 	const char *name;
@@ -285,6 +286,7 @@ struct ufs_hba_variant_ops {
 	int     (*suspend)(struct ufs_hba *, enum ufs_pm_op);
 	int     (*resume)(struct ufs_hba *, enum ufs_pm_op);
 	void	(*dbg_register_dump)(struct ufs_hba *hba);
+	int	(*phy_initialization)(struct ufs_hba *);
 };
 
 /* clock gating state  */
@@ -567,11 +569,16 @@ static inline bool ufshcd_can_autobkops_during_suspend(struct ufs_hba *hba)
 
 static inline bool ufshcd_is_intr_aggr_allowed(struct ufs_hba *hba)
 {
+/* DWC UFS Core has the Interrupt aggregation feature but is not detectable*/
+#ifndef CONFIG_SCSI_UFS_DWC
 	if ((hba->caps & UFSHCD_CAP_INTR_AGGR) &&
 	    !(hba->quirks & UFSHCD_QUIRK_BROKEN_INTR_AGGR))
 		return true;
 	else
 		return false;
+#else
+return true;
+#endif
 }
 
 #define ufshcd_writel(hba, val, reg)	\

commit f37aabcf58202e65db3035b1b360d856dd378ee2
Author: Yaniv Gardi <ygardi@codeaurora.org>
Date:   Thu Mar 10 17:37:20 2016 +0200

    scsi: ufs-qcom: enable/disable the device ref clock
    
    This change enables the device ref clock before changing to HS mode
    and disables it if entered to PWM mode.
    
    Reviewed-by: Gilad Broner <gbroner@codeaurora.org>
    Signed-off-by: Yaniv Gardi <ygardi@codeaurora.org>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/ufs/ufshcd.h b/drivers/scsi/ufs/ufshcd.h
index 41d9bfd17fac..4bb65669f052 100644
--- a/drivers/scsi/ufs/ufshcd.h
+++ b/drivers/scsi/ufs/ufshcd.h
@@ -54,6 +54,7 @@
 #include <linux/clk.h>
 #include <linux/completion.h>
 #include <linux/regulator/consumer.h>
+#include "unipro.h"
 
 #include <asm/irq.h>
 #include <asm/byteorder.h>
@@ -689,6 +690,14 @@ static inline int ufshcd_dme_peer_get(struct ufs_hba *hba,
 
 int ufshcd_read_device_desc(struct ufs_hba *hba, u8 *buf, u32 size);
 
+static inline bool ufshcd_is_hs_mode(struct ufs_pa_layer_attr *pwr_info)
+{
+	return (pwr_info->pwr_rx == FAST_MODE ||
+		pwr_info->pwr_rx == FASTAUTO_MODE) &&
+		(pwr_info->pwr_tx == FAST_MODE ||
+		pwr_info->pwr_tx == FASTAUTO_MODE);
+}
+
 #define ASCII_STD true
 
 int ufshcd_read_string_desc(struct ufs_hba *hba, int desc_index, u8 *buf,

commit 371131065de99b57d39620ac159d94e0d3773f13
Author: Yaniv Gardi <ygardi@codeaurora.org>
Date:   Thu Mar 10 17:37:16 2016 +0200

    scsi: ufs: tune UniPro parameters to optimize hibern8 exit time
    
    Optimal values of local UniPro parameters like PA_Hibern8Time &
    PA_TActivate can help reduce the hibern8 exit latency. If both host and
    device supports UniPro ver1.6 or later, these parameters will be
    automatically tuned during link startup itself. But if either host or
    device doesn't support UniPro ver 1.6 or later, we have to manually
    tune them. But to keep manual tuning logic simple, we will only do
    manual tuning if local unipro version doesn't support ver1.6 or later.
    
    Reviewed-by: Hannes Reinecke <hare@suse.de>
    Signed-off-by: Subhash Jadavani <subhashj@codeaurora.org>
    Signed-off-by: Yaniv Gardi <ygardi@codeaurora.org>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/ufs/ufshcd.h b/drivers/scsi/ufs/ufshcd.h
index 65f29aa881d6..41d9bfd17fac 100644
--- a/drivers/scsi/ufs/ufshcd.h
+++ b/drivers/scsi/ufs/ufshcd.h
@@ -699,6 +699,7 @@ int ufshcd_query_flag(struct ufs_hba *hba, enum query_opcode opcode,
 	enum flag_idn idn, bool *flag_res);
 int ufshcd_hold(struct ufs_hba *hba, bool async);
 void ufshcd_release(struct ufs_hba *hba);
+u32 ufshcd_get_local_unipro_ver(struct ufs_hba *hba);
 
 /* Wrapper functions for safely calling variant operations */
 static inline const char *ufshcd_get_var_name(struct ufs_hba *hba)

commit afdfff59a0e0c5527610d3bc5d338a0da03dd23d
Author: Yaniv Gardi <ygardi@codeaurora.org>
Date:   Thu Mar 10 17:37:15 2016 +0200

    scsi: ufs: handle non spec compliant bkops behaviour by device
    
    We are seeing that some devices are raising the urgent bkops exception
    events even when BKOPS status doesn't indicate performace impacted or
    critical. Handle these device by determining their urgent bkops status
    at runtime.
    
    Reviewed-by: Hannes Reinecke <hare@suse.de>
    Signed-off-by: Subhash Jadavani <subhashj@codeaurora.org>
    Signed-off-by: Yaniv Gardi <ygardi@codeaurora.org>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/ufs/ufshcd.h b/drivers/scsi/ufs/ufshcd.h
index 77e79c00ef8c..65f29aa881d6 100644
--- a/drivers/scsi/ufs/ufshcd.h
+++ b/drivers/scsi/ufs/ufshcd.h
@@ -383,6 +383,9 @@ struct ufs_init_prefetch {
  * @clk_list_head: UFS host controller clocks list node head
  * @pwr_info: holds current power mode
  * @max_pwr_info: keeps the device max valid pwm
+ * @urgent_bkops_lvl: keeps track of urgent bkops level for device
+ * @is_urgent_bkops_lvl_checked: keeps track if the urgent bkops level for
+ *  device is known or not.
  */
 struct ufs_hba {
 	void __iomem *mmio_base;
@@ -538,6 +541,9 @@ struct ufs_hba {
 	struct devfreq *devfreq;
 	struct ufs_clk_scaling clk_scaling;
 	bool is_sys_suspended;
+
+	enum bkops_status urgent_bkops_lvl;
+	bool is_urgent_bkops_lvl_checked;
 };
 
 /* Returns true if clocks can be gated. Otherwise false */

commit c58ab7aab71e2c783087115f0ce1623c2fdcf0b2
Author: Yaniv Gardi <ygardi@codeaurora.org>
Date:   Thu Mar 10 17:37:10 2016 +0200

    scsi: ufs: separate device and host quirks
    
    Currently we use the host quirks mechanism in order to
    handle both device and host controller quirks.
    In order to support various of UFS devices we should separate
    handling the device quirks from the host controller's.
    
    Reviewed-by: Gilad Broner <gbroner@codeaurora.org>
    Reviewed-by: Hannes Reinecke <hare@suse.de>
    Signed-off-by: Raviv Shvili <rshvili@codeaurora.org>
    Signed-off-by: Yaniv Gardi <ygardi@codeaurora.org>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/ufs/ufshcd.h b/drivers/scsi/ufs/ufshcd.h
index 54e13ccb5754..77e79c00ef8c 100644
--- a/drivers/scsi/ufs/ufshcd.h
+++ b/drivers/scsi/ufs/ufshcd.h
@@ -470,6 +470,9 @@ struct ufs_hba {
 
 	unsigned int quirks;	/* Deviations from standard UFSHCI spec. */
 
+	/* Device deviations from standard UFS device spec. */
+	unsigned int dev_quirks;
+
 	wait_queue_head_t tm_wq;
 	wait_queue_head_t tm_tag_wq;
 	unsigned long tm_condition;

commit b573d484e4ff33b60b1ef95ca30f199e749ff7c9
Author: Yaniv Gardi <ygardi@codeaurora.org>
Date:   Thu Mar 10 17:37:09 2016 +0200

    scsi: ufs: add support to read device and string descriptors
    
    This change adds support to read device descriptor and string descriptor
    from a UFS device
    
    Reviewed-by: Gilad Broner <gbroner@codeaurora.org>
    Reviewed-by: Hannes Reinecke <hare@suse.com>
    Signed-off-by: Raviv Shvili <rshvili@codeaurora.org>
    Signed-off-by: Yaniv Gardi <ygardi@codeaurora.org>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/ufs/ufshcd.h b/drivers/scsi/ufs/ufshcd.h
index a6d35724ccdc..54e13ccb5754 100644
--- a/drivers/scsi/ufs/ufshcd.h
+++ b/drivers/scsi/ufs/ufshcd.h
@@ -678,6 +678,13 @@ static inline int ufshcd_dme_peer_get(struct ufs_hba *hba,
 	return ufshcd_dme_get_attr(hba, attr_sel, mib_val, DME_PEER);
 }
 
+int ufshcd_read_device_desc(struct ufs_hba *hba, u8 *buf, u32 size);
+
+#define ASCII_STD true
+
+int ufshcd_read_string_desc(struct ufs_hba *hba, int desc_index, u8 *buf,
+				u32 size, bool ascii);
+
 /* Expose Query-Request API */
 int ufshcd_query_flag(struct ufs_hba *hba, enum query_opcode opcode,
 	enum flag_idn idn, bool *flag_res);

commit 596585a285a41993f26efab686e1ef20fc16a04a
Author: Yaniv Gardi <ygardi@codeaurora.org>
Date:   Thu Mar 10 17:37:08 2016 +0200

    scsi: ufs: verify hba controller hce reg value
    
    Sometimes due to hw issues it takes some time to the
    host controller register to update. In order to verify the register
    has updated, a polling is done until its value is set.
    
    In addition the functions ufshcd_hba_stop() and
    ufshcd_wait_for_register() was updated with an additional input
    parameter, indicating the timeout between reads will
    be done by sleeping or spinning the cpu.
    
    Reviewed-by: Hannes Reinecke <hare@suse.com>
    Signed-off-by: Raviv Shvili <rshvili@codeaurora.org>
    Signed-off-by: Yaniv Gardi <ygardi@codeaurora.org>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/ufs/ufshcd.h b/drivers/scsi/ufs/ufshcd.h
index 9ae7f85b2a33..a6d35724ccdc 100644
--- a/drivers/scsi/ufs/ufshcd.h
+++ b/drivers/scsi/ufs/ufshcd.h
@@ -590,15 +590,9 @@ int ufshcd_alloc_host(struct device *, struct ufs_hba **);
 void ufshcd_dealloc_host(struct ufs_hba *);
 int ufshcd_init(struct ufs_hba * , void __iomem * , unsigned int);
 void ufshcd_remove(struct ufs_hba *);
-
-/**
- * ufshcd_hba_stop - Send controller to reset state
- * @hba: per adapter instance
- */
-static inline void ufshcd_hba_stop(struct ufs_hba *hba)
-{
-	ufshcd_writel(hba, CONTROLLER_DISABLE,  REG_CONTROLLER_ENABLE);
-}
+int ufshcd_wait_for_register(struct ufs_hba *hba, u32 reg, u32 mask,
+				u32 val, unsigned long interval_us,
+				unsigned long timeout_ms, bool can_sleep);
 
 static inline void check_upiu_size(void)
 {

commit 54b879b76ea253105505f840bd842c1927c9e380
Author: Yaniv Gardi <ygardi@codeaurora.org>
Date:   Thu Mar 10 17:37:05 2016 +0200

    scsi: ufs-qcom: add number of lanes per direction
    
    Different platform may have different number of lanes
    for the UFS link.
    Add parameter to device tree specifying how many lanes
    should be configured for the UFS link.
    
    Reviewed-by: Hannes Reinecke <hare@suse.de>
    Acked-by: Rob Herring <robh@kernel.org>
    Signed-off-by: Gilad Broner <gbroner@codeaurora.org>
    Signed-off-by: Yaniv Gardi <ygardi@codeaurora.org>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/ufs/ufshcd.h b/drivers/scsi/ufs/ufshcd.h
index e3931d0c94eb..9ae7f85b2a33 100644
--- a/drivers/scsi/ufs/ufshcd.h
+++ b/drivers/scsi/ufs/ufshcd.h
@@ -509,6 +509,8 @@ struct ufs_hba {
 
 	bool wlun_dev_clr_ua;
 
+	/* Number of lanes available (1 or 2) for Rx/Tx */
+	u32 lanes_per_direction;
 	struct ufs_pa_layer_attr pwr_info;
 	struct ufs_pwr_mode_info max_pwr_info;
 

commit a230c2f6363c3fee8b6280b0732d7eb17554a4ca
Author: Tomas Winkler <tomas.winkler@intel.com>
Date:   Tue Feb 9 10:25:41 2016 +0200

    scsi: ufs: fix typo in comment
    
    [mkp: Only one typo remained]
    
    Signed-off-by: Tomas Winkler <tomas.winkler@intel.com>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/ufs/ufshcd.h b/drivers/scsi/ufs/ufshcd.h
index 8e22e6ca588b..e3931d0c94eb 100644
--- a/drivers/scsi/ufs/ufshcd.h
+++ b/drivers/scsi/ufs/ufshcd.h
@@ -178,7 +178,7 @@ struct ufshcd_lrb {
 };
 
 /**
- * struct ufs_query - holds relevent data structures for query request
+ * struct ufs_query - holds relevant data structures for query request
  * @request: request upiu and function
  * @descriptor: buffer for sending/receiving descriptor
  * @response: response upiu and response

commit dc3c8d3a7d455859c58de8ccfaea5def6b512079
Author: Yaniv Gardi <ygardi@codeaurora.org>
Date:   Mon Feb 1 15:02:46 2016 +0200

    scsi: ufs: retry failed query flag requests
    
    UFS flag query requests may fail sometimes due to timeouts etc.  Add a
    wrapper function to retry up to 10 times in case of such failure,
    similar to retries being made for attribute queries.
    
    Reviewed-by: Dolev Raviv <draviv@codeaurora.org>
    Signed-off-by: Gilad Broner <gbroner@codeaurora.org>
    Signed-off-by: Yaniv Gardi <ygardi@codeaurora.org>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/ufs/ufshcd.h b/drivers/scsi/ufs/ufshcd.h
index 2570d9477b37..8e22e6ca588b 100644
--- a/drivers/scsi/ufs/ufshcd.h
+++ b/drivers/scsi/ufs/ufshcd.h
@@ -3,6 +3,7 @@
  *
  * This code is based on drivers/scsi/ufs/ufshcd.h
  * Copyright (C) 2011-2013 Samsung India Software Operations
+ * Copyright (c) 2013-2016, The Linux Foundation. All rights reserved.
  *
  * Authors:
  *	Santosh Yaraganavi <santosh.sy@samsung.com>
@@ -681,6 +682,9 @@ static inline int ufshcd_dme_peer_get(struct ufs_hba *hba,
 	return ufshcd_dme_get_attr(hba, attr_sel, mib_val, DME_PEER);
 }
 
+/* Expose Query-Request API */
+int ufshcd_query_flag(struct ufs_hba *hba, enum query_opcode opcode,
+	enum flag_idn idn, bool *flag_res);
 int ufshcd_hold(struct ufs_hba *hba, bool async);
 void ufshcd_release(struct ufs_hba *hba);
 

commit f06fcc7155dcbcd9b697d499595a2c1a3945bda2
Author: Yaniv Gardi <ygardi@codeaurora.org>
Date:   Wed Oct 28 13:15:51 2015 +0200

    scsi: ufs-qcom: add QUniPro hardware support and power optimizations
    
    New revisions of UFS host controller supports the new UniPro
    hardware controller (referred as QUniPro). This patch adds
    the support to enable this new UniPro controller hardware.
    
    This change also adds power optimization for bus scaling feature,
    as well as support for HS-G3 power mode.
    
    Reviewed-by: Subhash Jadavani <subhashj@codeaurora.org>
    Reviewed-by: Gilad Broner <gbroner@codeaurora.org>
    Signed-off-by: Yaniv Gardi <ygardi@codeaurora.org>
    Reviewed-by: Hannes Reinecke <hare@suse.de>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/ufs/ufshcd.h b/drivers/scsi/ufs/ufshcd.h
index 471c667a1fb4..2570d9477b37 100644
--- a/drivers/scsi/ufs/ufshcd.h
+++ b/drivers/scsi/ufs/ufshcd.h
@@ -223,8 +223,10 @@ struct ufs_clk_info {
 	bool enabled;
 };
 
-#define PRE_CHANGE      0
-#define POST_CHANGE     1
+enum ufs_notify_change_status {
+	PRE_CHANGE,
+	POST_CHANGE,
+};
 
 struct ufs_pa_layer_attr {
 	u32 gear_rx;
@@ -266,13 +268,17 @@ struct ufs_hba_variant_ops {
 	int	(*init)(struct ufs_hba *);
 	void    (*exit)(struct ufs_hba *);
 	u32	(*get_ufs_hci_version)(struct ufs_hba *);
-	void    (*clk_scale_notify)(struct ufs_hba *);
-	int     (*setup_clocks)(struct ufs_hba *, bool);
+	int	(*clk_scale_notify)(struct ufs_hba *, bool,
+				    enum ufs_notify_change_status);
+	int	(*setup_clocks)(struct ufs_hba *, bool);
 	int     (*setup_regulators)(struct ufs_hba *, bool);
-	int     (*hce_enable_notify)(struct ufs_hba *, bool);
-	int     (*link_startup_notify)(struct ufs_hba *, bool);
+	int	(*hce_enable_notify)(struct ufs_hba *,
+				     enum ufs_notify_change_status);
+	int	(*link_startup_notify)(struct ufs_hba *,
+				       enum ufs_notify_change_status);
 	int	(*pwr_change_notify)(struct ufs_hba *,
-					bool, struct ufs_pa_layer_attr *,
+					enum ufs_notify_change_status status,
+					struct ufs_pa_layer_attr *,
 					struct ufs_pa_layer_attr *);
 	int     (*suspend)(struct ufs_hba *, enum ufs_pm_op);
 	int     (*resume)(struct ufs_hba *, enum ufs_pm_op);
@@ -708,17 +714,18 @@ static inline u32 ufshcd_vops_get_ufs_hci_version(struct ufs_hba *hba)
 	return ufshcd_readl(hba, REG_UFS_VERSION);
 }
 
-static inline void ufshcd_vops_clk_scale_notify(struct ufs_hba *hba)
+static inline int ufshcd_vops_clk_scale_notify(struct ufs_hba *hba,
+			bool up, enum ufs_notify_change_status status)
 {
 	if (hba->vops && hba->vops->clk_scale_notify)
-		return hba->vops->clk_scale_notify(hba);
+		return hba->vops->clk_scale_notify(hba, up, status);
+	return 0;
 }
 
 static inline int ufshcd_vops_setup_clocks(struct ufs_hba *hba, bool on)
 {
 	if (hba->vops && hba->vops->setup_clocks)
 		return hba->vops->setup_clocks(hba, on);
-
 	return 0;
 }
 

commit 6e3fd44d7b7638e0f7e3331eaf7f90f3a629f3e7
Author: Yaniv Gardi <ygardi@codeaurora.org>
Date:   Wed Oct 28 13:15:50 2015 +0200

    scsi: ufs-qcom: add debug prints for test bus
    
    Adds support for configuring and reading the test bus and debug
    registers. This change also adds another vops in order to print the
    debug registers.
    
    Reviewed-by: Subhash Jadavani <subhashj@codeaurora.org>
    Reviewed-by: Gilad Broner <gbroner@codeaurora.org>
    Signed-off-by: Yaniv Gardi <ygardi@codeaurora.org>
    Reviewed-by: Hannes Reinecke <hare@suse.de>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/ufs/ufshcd.h b/drivers/scsi/ufs/ufshcd.h
index f2aa47e15b13..471c667a1fb4 100644
--- a/drivers/scsi/ufs/ufshcd.h
+++ b/drivers/scsi/ufs/ufshcd.h
@@ -259,6 +259,7 @@ struct ufs_pwr_mode_info {
  *			to be set.
  * @suspend: called during host controller PM callback
  * @resume: called during host controller PM callback
+ * @dbg_register_dump: used to dump controller debug information
  */
 struct ufs_hba_variant_ops {
 	const char *name;
@@ -275,6 +276,7 @@ struct ufs_hba_variant_ops {
 					struct ufs_pa_layer_attr *);
 	int     (*suspend)(struct ufs_hba *, enum ufs_pm_op);
 	int     (*resume)(struct ufs_hba *, enum ufs_pm_op);
+	void	(*dbg_register_dump)(struct ufs_hba *hba);
 };
 
 /* clock gating state  */
@@ -773,4 +775,10 @@ static inline int ufshcd_vops_resume(struct ufs_hba *hba, enum ufs_pm_op op)
 	return 0;
 }
 
+static inline void ufshcd_vops_dbg_register_dump(struct ufs_hba *hba)
+{
+	if (hba->vops && hba->vops->dbg_register_dump)
+		hba->vops->dbg_register_dump(hba);
+}
+
 #endif /* End of Header */

commit 47555a5c8a11a423e6767f942941c745766c99a2
Author: Yaniv Gardi <ygardi@codeaurora.org>
Date:   Wed Oct 28 13:15:49 2015 +0200

    scsi: ufs: make the UFS variant a platform device
    
    This change turns the UFS variant (SCSI_UFS_QCOM) into a UFS
    a platform device.
    In order to do so a few additional changes are required:
    1. The ufshcd-pltfrm is no longer serves as a platform device.
       Now it only serves as a group of platform APIs such as PM APIs
       (runtime suspend/resume, system suspend/resume etc), parsers of
       clocks, regulators and pm_levels from DT.
    2. What used to be the old platform "probe" is now "only"
       a pltfrm_init() routine, that does exactly the same, but only
       being called by the new probe function of the UFS variant.
    
    Reviewed-by: Rob Herring <robherring2@gmail.com>
    Reviewed-by: Gilad Broner <gbroner@codeaurora.org>
    Signed-off-by: Yaniv Gardi <ygardi@codeaurora.org>
    Tested-by: Alim Akhtar <alim.akhtar@samsung.com>
    Reviewed-by: Hannes Reinecke <hare@suse.de>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/ufs/ufshcd.h b/drivers/scsi/ufs/ufshcd.h
index ce756266b0af..f2aa47e15b13 100644
--- a/drivers/scsi/ufs/ufshcd.h
+++ b/drivers/scsi/ufs/ufshcd.h
@@ -576,6 +576,7 @@ static inline void ufshcd_rmwl(struct ufs_hba *hba, u32 mask, u32 val, u32 reg)
 }
 
 int ufshcd_alloc_host(struct device *, struct ufs_hba **);
+void ufshcd_dealloc_host(struct ufs_hba *);
 int ufshcd_init(struct ufs_hba * , void __iomem * , unsigned int);
 void ufshcd_remove(struct ufs_hba *);
 

commit 0263bcd0e8319642440fa29c184b0d7f4b2d5857
Author: Yaniv Gardi <ygardi@codeaurora.org>
Date:   Wed Oct 28 13:15:48 2015 +0200

    scsi: ufs: creates wrapper functions for vops
    
    In order to simplify the code a set of wrapper functions is created
    to test and call each of the variant operations.
    
    Reviewed-by: Akinobu Mita <akinobu.mita@gmail.com>
    Reviewed-by: Subhash Jadavani <subhashj@codeaurora.org>
    Reviewed-by: Gilad Broner <gbroner@codeaurora.org>
    Signed-off-by: Yaniv Gardi <ygardi@codeaurora.org>
    Tested-by: Alim Akhtar <alim.akhtar@samsung.com>
    Reviewed-by: Hannes Reinecke <hare@suse.de>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/ufs/ufshcd.h b/drivers/scsi/ufs/ufshcd.h
index 54e7afb4a432..ce756266b0af 100644
--- a/drivers/scsi/ufs/ufshcd.h
+++ b/drivers/scsi/ufs/ufshcd.h
@@ -674,4 +674,102 @@ static inline int ufshcd_dme_peer_get(struct ufs_hba *hba,
 
 int ufshcd_hold(struct ufs_hba *hba, bool async);
 void ufshcd_release(struct ufs_hba *hba);
+
+/* Wrapper functions for safely calling variant operations */
+static inline const char *ufshcd_get_var_name(struct ufs_hba *hba)
+{
+	if (hba->vops)
+		return hba->vops->name;
+	return "";
+}
+
+static inline int ufshcd_vops_init(struct ufs_hba *hba)
+{
+	if (hba->vops && hba->vops->init)
+		return hba->vops->init(hba);
+
+	return 0;
+}
+
+static inline void ufshcd_vops_exit(struct ufs_hba *hba)
+{
+	if (hba->vops && hba->vops->exit)
+		return hba->vops->exit(hba);
+}
+
+static inline u32 ufshcd_vops_get_ufs_hci_version(struct ufs_hba *hba)
+{
+	if (hba->vops && hba->vops->get_ufs_hci_version)
+		return hba->vops->get_ufs_hci_version(hba);
+
+	return ufshcd_readl(hba, REG_UFS_VERSION);
+}
+
+static inline void ufshcd_vops_clk_scale_notify(struct ufs_hba *hba)
+{
+	if (hba->vops && hba->vops->clk_scale_notify)
+		return hba->vops->clk_scale_notify(hba);
+}
+
+static inline int ufshcd_vops_setup_clocks(struct ufs_hba *hba, bool on)
+{
+	if (hba->vops && hba->vops->setup_clocks)
+		return hba->vops->setup_clocks(hba, on);
+
+	return 0;
+}
+
+static inline int ufshcd_vops_setup_regulators(struct ufs_hba *hba, bool status)
+{
+	if (hba->vops && hba->vops->setup_regulators)
+		return hba->vops->setup_regulators(hba, status);
+
+	return 0;
+}
+
+static inline int ufshcd_vops_hce_enable_notify(struct ufs_hba *hba,
+						bool status)
+{
+	if (hba->vops && hba->vops->hce_enable_notify)
+		return hba->vops->hce_enable_notify(hba, status);
+
+	return 0;
+}
+static inline int ufshcd_vops_link_startup_notify(struct ufs_hba *hba,
+						bool status)
+{
+	if (hba->vops && hba->vops->link_startup_notify)
+		return hba->vops->link_startup_notify(hba, status);
+
+	return 0;
+}
+
+static inline int ufshcd_vops_pwr_change_notify(struct ufs_hba *hba,
+				  bool status,
+				  struct ufs_pa_layer_attr *dev_max_params,
+				  struct ufs_pa_layer_attr *dev_req_params)
+{
+	if (hba->vops && hba->vops->pwr_change_notify)
+		return hba->vops->pwr_change_notify(hba, status,
+					dev_max_params, dev_req_params);
+
+	return -ENOTSUPP;
+}
+
+static inline int ufshcd_vops_suspend(struct ufs_hba *hba, enum ufs_pm_op op)
+{
+	if (hba->vops && hba->vops->suspend)
+		return hba->vops->suspend(hba, op);
+
+	return 0;
+}
+
+static inline int ufshcd_vops_resume(struct ufs_hba *hba, enum ufs_pm_op op)
+{
+	if (hba->vops && hba->vops->resume)
+		return hba->vops->resume(hba, op);
+
+	return 0;
+}
+
 #endif /* End of Header */

commit 1ce5898af55e23e933f6a68d102d4be730e9b503
Author: Yaniv Gardi <ygardi@codeaurora.org>
Date:   Wed Oct 28 13:15:47 2015 +0200

    scsi: ufs: add ufshcd_get_variant ufshcd_set_variant
    
    This patch adds ufshcd_get_variant() and ufshcd_set_variant()
    routines in order to get/set the variant specific data.
    
    Reviewed-by: Akinobu Mita <akinobu.mita@gmail.com>
    Reviewed-by: Subhash Jadavani <subhashj@codeaurora.org>
    Reviewed-by: Gilad Broner <gbroner@codeaurora.org>
    Signed-off-by: Yaniv Gardi <ygardi@codeaurora.org>
    Tested-by: Alim Akhtar <alim.akhtar@samsung.com>
    Reviewed-by: Hannes Reinecke <hare@suse.de>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/ufs/ufshcd.h b/drivers/scsi/ufs/ufshcd.h
index c40a0e78a6c4..54e7afb4a432 100644
--- a/drivers/scsi/ufs/ufshcd.h
+++ b/drivers/scsi/ufs/ufshcd.h
@@ -594,6 +594,27 @@ static inline void check_upiu_size(void)
 		GENERAL_UPIU_REQUEST_SIZE + QUERY_DESC_MAX_SIZE);
 }
 
+/**
+ * ufshcd_set_variant - set variant specific data to the hba
+ * @hba - per adapter instance
+ * @variant - pointer to variant specific data
+ */
+static inline void ufshcd_set_variant(struct ufs_hba *hba, void *variant)
+{
+	BUG_ON(!hba);
+	hba->priv = variant;
+}
+
+/**
+ * ufshcd_get_variant - get variant specific data from the hba
+ * @hba - per adapter instance
+ */
+static inline void *ufshcd_get_variant(struct ufs_hba *hba)
+{
+	BUG_ON(!hba);
+	return hba->priv;
+}
+
 extern int ufshcd_runtime_suspend(struct ufs_hba *hba);
 extern int ufshcd_runtime_resume(struct ufs_hba *hba);
 extern int ufshcd_runtime_idle(struct ufs_hba *hba);

commit 9949e702e69718965f3c3c6787eb17d420daa7df
Author: Yaniv Gardi <ygardi@codeaurora.org>
Date:   Sun May 17 18:55:05 2015 +0300

    scsi: ufs: add quirk to handle broken UFS HCI version
    
    Some host controller hardware controllers may not advertise correct
    version in UFS HCI VER register. To workaround this, add new quirk
    and call the host controller hardware vendor specific callback to
    get the correct UFS HCI version register value.
    
    Signed-off-by: Yaniv Gardi <ygardi@codeaurora.org>
    Reviewed-by: Akinobu Mita <akinobu.mita@gmail.com>
    Signed-off-by: James Bottomley <JBottomley@Odin.com>

diff --git a/drivers/scsi/ufs/ufshcd.h b/drivers/scsi/ufs/ufshcd.h
index eb6831db1548..c40a0e78a6c4 100644
--- a/drivers/scsi/ufs/ufshcd.h
+++ b/drivers/scsi/ufs/ufshcd.h
@@ -246,6 +246,7 @@ struct ufs_pwr_mode_info {
  * @name: variant name
  * @init: called when the driver is initialized
  * @exit: called to cleanup everything done in init
+ * @get_ufs_hci_version: called to get UFS HCI version
  * @clk_scale_notify: notifies that clks are scaled up/down
  * @setup_clocks: called before touching any of the controller registers
  * @setup_regulators: called before accessing the host controller
@@ -263,6 +264,7 @@ struct ufs_hba_variant_ops {
 	const char *name;
 	int	(*init)(struct ufs_hba *);
 	void    (*exit)(struct ufs_hba *);
+	u32	(*get_ufs_hci_version)(struct ufs_hba *);
 	void    (*clk_scale_notify)(struct ufs_hba *);
 	int     (*setup_clocks)(struct ufs_hba *, bool);
 	int     (*setup_regulators)(struct ufs_hba *, bool);
@@ -449,6 +451,14 @@ struct ufs_hba {
 	 */
 	#define UFSHCD_QUIRK_DME_PEER_ACCESS_AUTO_MODE		UFS_BIT(4)
 
+	/*
+	 * This quirk needs to be enabled if the host contoller doesn't
+	 * advertise the correct version in UFS_VER register. If this quirk
+	 * is enabled, standard UFS host driver will call the vendor specific
+	 * ops (get_ufs_hci_version) to get the correct version.
+	 */
+	#define UFSHCD_QUIRK_BROKEN_UFS_HCI_VERSION		UFS_BIT(5)
+
 	unsigned int quirks;	/* Deviations from standard UFSHCI spec. */
 
 	wait_queue_head_t tm_wq;

commit 874237f7f2aae61d166613cc191238d8335087f8
Author: Yaniv Gardi <ygardi@codeaurora.org>
Date:   Sun May 17 18:55:03 2015 +0300

    scsi: ufs: introduce UFSHCD_QUIRK_DME_PEER_ACCESS_AUTO_MODE quirk
    
    Some UFS host controllers may only allow accessing the peer DME attribute
    in AUTO mode (FAST AUTO or SLOW AUTO) hence we had added a quirk for
    switching to AUTO power mode before accessing the peer DME attribute.
    
    Signed-off-by: Yaniv Gardi <ygardi@codeaurora.org>
    Reviewed-by: Akinobu Mita <akinobu.mita@gmail.com>
    Signed-off-by: James Bottomley <JBottomley@Odin.com>

diff --git a/drivers/scsi/ufs/ufshcd.h b/drivers/scsi/ufs/ufshcd.h
index 8636ec970946..eb6831db1548 100644
--- a/drivers/scsi/ufs/ufshcd.h
+++ b/drivers/scsi/ufs/ufshcd.h
@@ -442,6 +442,13 @@ struct ufs_hba {
 	 */
 	#define UFSHCD_QUIRK_BROKEN_PA_RXHSUNTERMCAP		UFS_BIT(3)
 
+	/*
+	 * This quirk needs to be enabled if the host contoller only allows
+	 * accessing the peer dme attributes in AUTO mode (FAST AUTO or
+	 * SLOW AUTO).
+	 */
+	#define UFSHCD_QUIRK_DME_PEER_ACCESS_AUTO_MODE		UFS_BIT(4)
+
 	unsigned int quirks;	/* Deviations from standard UFSHCI spec. */
 
 	wait_queue_head_t tm_wq;

commit c3a2f9ee93cf2d074dbf0234c2ef5dcdbf84a7d0
Author: Yaniv Gardi <ygardi@codeaurora.org>
Date:   Sun May 17 18:55:01 2015 +0300

    scsi: ufs: introduce a broken PA_RXHSUNTERMCAP quirk
    
    The attribute PA_RXHSUNTERMCAP specifies whether or not the
    inbound Link supports unterminated line in HS mode. enabling this
    attribute to 1 fixes moving to HS gear.
    
    Signed-off-by: Yaniv Gardi <ygardi@codeaurora.org>
    Reviewed-by: Akinobu Mita <akinobu.mita@gmail.com>
    Signed-off-by: James Bottomley <JBottomley@Odin.com>

diff --git a/drivers/scsi/ufs/ufshcd.h b/drivers/scsi/ufs/ufshcd.h
index b845f1535f29..8636ec970946 100644
--- a/drivers/scsi/ufs/ufshcd.h
+++ b/drivers/scsi/ufs/ufshcd.h
@@ -435,6 +435,13 @@ struct ufs_hba {
 	 */
 	#define UFSHCD_QUIRK_BROKEN_LCC				UFS_BIT(2)
 
+	/*
+	 * The attribute PA_RXHSUNTERMCAP specifies whether or not the
+	 * inbound Link supports unterminated line in HS mode. Setting this
+	 * attribute to 1 fixes moving to HS gear.
+	 */
+	#define UFSHCD_QUIRK_BROKEN_PA_RXHSUNTERMCAP		UFS_BIT(3)
+
 	unsigned int quirks;	/* Deviations from standard UFSHCI spec. */
 
 	wait_queue_head_t tm_wq;

commit 7ca38cf300eb7fba9010d847baa6a4f5c458dd4e
Author: Yaniv Gardi <ygardi@codeaurora.org>
Date:   Sun May 17 18:54:59 2015 +0300

    scsi: ufs: provide a quirk to disable the LCC
    
    LCC (Line Control Command) are being used for communication between
    UFS host and UFS device.
    New commercial UFS devices don't have the issues with LCC processing
    but UFS host controller might still have the issue with LCC processing,
    hence, added a routine to disable TX LCC on the device.
    
    Signed-off-by: Yaniv Gardi <ygardi@codeaurora.org>
    Reviewed-by: Akinobu Mita <akinobu.mita@gmail.com>
    Signed-off-by: James Bottomley <JBottomley@Odin.com>

diff --git a/drivers/scsi/ufs/ufshcd.h b/drivers/scsi/ufs/ufshcd.h
index fc8bec9960b1..b845f1535f29 100644
--- a/drivers/scsi/ufs/ufshcd.h
+++ b/drivers/scsi/ufs/ufshcd.h
@@ -426,6 +426,14 @@ struct ufs_hba {
 	 */
 	#define UFSHCD_QUIRK_DELAY_BEFORE_DME_CMDS		UFS_BIT(1)
 
+	/*
+	 * If UFS host controller is having issue in processing LCC (Line
+	 * Control Command) coming from device then enable this quirk.
+	 * When this quirk is enabled, host controller driver should disable
+	 * the LCC transmission on UFS device (by clearing TX_LCC_ENABLE
+	 * attribute of device to 0).
+	 */
+	#define UFSHCD_QUIRK_BROKEN_LCC				UFS_BIT(2)
 
 	unsigned int quirks;	/* Deviations from standard UFSHCI spec. */
 

commit b852190e589abe8ad4891251424a636872960f56
Author: Yaniv Gardi <ygardi@codeaurora.org>
Date:   Sun May 17 18:54:57 2015 +0300

    scsi: ufs: introduce the capability and quirk for interrupt aggregation
    
    UFS HCI (Host Controller Interface) allows the transfer requests
    interrupts to be aggregated to generate the single interrupt but
    this can impact the performance. Hence introduce the capability which
    gives choice to use the interrupt aggregation capability or not.
    By default interrupt aggregation capability is kept disabled.
    
    This change also introduces a quirk for broken interrupt aggregation
    feature, as in some UFS controllers, this feature may not work.
    
    Signed-off-by: Yaniv Gardi <ygardi@codeaurora.org>
    Reviewed-by: Akinobu Mita <akinobu.mita@gmail.com>
    Signed-off-by: James Bottomley <JBottomley@Odin.com>

diff --git a/drivers/scsi/ufs/ufshcd.h b/drivers/scsi/ufs/ufshcd.h
index b47ff07698e8..fc8bec9960b1 100644
--- a/drivers/scsi/ufs/ufshcd.h
+++ b/drivers/scsi/ufs/ufshcd.h
@@ -417,11 +417,15 @@ struct ufs_hba {
 	unsigned int irq;
 	bool is_irq_enabled;
 
+	/* Interrupt aggregation support is broken */
+	#define UFSHCD_QUIRK_BROKEN_INTR_AGGR			UFS_BIT(0)
+
 	/*
 	 * delay before each dme command is required as the unipro
 	 * layer has shown instabilities
 	 */
-	#define UFSHCD_QUIRK_DELAY_BEFORE_DME_CMDS		UFS_BIT(0)
+	#define UFSHCD_QUIRK_DELAY_BEFORE_DME_CMDS		UFS_BIT(1)
+
 
 	unsigned int quirks;	/* Deviations from standard UFSHCI spec. */
 
@@ -478,6 +482,12 @@ struct ufs_hba {
 #define UFSHCD_CAP_CLK_SCALING	(1 << 2)
 	/* Allow auto bkops to enabled during runtime suspend */
 #define UFSHCD_CAP_AUTO_BKOPS_SUSPEND (1 << 3)
+	/*
+	 * This capability allows host controller driver to use the UFS HCI's
+	 * interrupt aggregation capability.
+	 * CAUTION: Enabling this might reduce overall UFS throughput.
+	 */
+#define UFSHCD_CAP_INTR_AGGR (1 << 4)
 
 	struct devfreq *devfreq;
 	struct ufs_clk_scaling clk_scaling;
@@ -502,6 +512,15 @@ static inline bool ufshcd_can_autobkops_during_suspend(struct ufs_hba *hba)
 	return hba->caps & UFSHCD_CAP_AUTO_BKOPS_SUSPEND;
 }
 
+static inline bool ufshcd_is_intr_aggr_allowed(struct ufs_hba *hba)
+{
+	if ((hba->caps & UFSHCD_CAP_INTR_AGGR) &&
+	    !(hba->quirks & UFSHCD_QUIRK_BROKEN_INTR_AGGR))
+		return true;
+	else
+		return false;
+}
+
 #define ufshcd_writel(hba, val, reg)	\
 	writel((val), (hba)->mmio_base + (reg))
 #define ufshcd_readl(hba, reg)	\

commit cad2e03d8607793fd71a830b4b41fc8e9e9995ea
Author: Yaniv Gardi <ygardi@codeaurora.org>
Date:   Tue Mar 31 17:37:14 2015 +0300

    ufs: add support to allow non standard behaviours (quirks)
    
    Some implementation of UFS host controller HW might have some non-standard
    behaviours (quirks) when compared to behaviour specified by UFSHCI
    specification. This patch add support to allow specifying all such quirks
    to standard UFS host controller driver so standard driver takes them into
    account.
    
    In this change a UFSHCD_QUIRK_DELAY_BEFORE_DME_CMDS is introduced,
    where a minimum delay of 1ms is required before DME commands for
    stability purposes.
    
    Signed-off-by: Yaniv Gardi <ygardi@codeaurora.org>
    Reviewed-by: Gilad Broner <gbroner@codeaurora.org>
    Signed-off-by: James Bottomley <JBottomley@Odin.com>

diff --git a/drivers/scsi/ufs/ufshcd.h b/drivers/scsi/ufs/ufshcd.h
index 4a574aa45855..b47ff07698e8 100644
--- a/drivers/scsi/ufs/ufshcd.h
+++ b/drivers/scsi/ufs/ufshcd.h
@@ -366,6 +366,7 @@ struct ufs_init_prefetch {
  * @saved_err: sticky error mask
  * @saved_uic_err: sticky UIC error mask
  * @dev_cmd: ufs device management command information
+ * @last_dme_cmd_tstamp: time stamp of the last completed DME command
  * @auto_bkops_enabled: to track whether bkops is enabled in device
  * @vreg_info: UFS device voltage regulator information
  * @clk_list_head: UFS host controller clocks list node head
@@ -416,6 +417,13 @@ struct ufs_hba {
 	unsigned int irq;
 	bool is_irq_enabled;
 
+	/*
+	 * delay before each dme command is required as the unipro
+	 * layer has shown instabilities
+	 */
+	#define UFSHCD_QUIRK_DELAY_BEFORE_DME_CMDS		UFS_BIT(0)
+
+	unsigned int quirks;	/* Deviations from standard UFSHCI spec. */
 
 	wait_queue_head_t tm_wq;
 	wait_queue_head_t tm_tag_wq;
@@ -446,6 +454,7 @@ struct ufs_hba {
 
 	/* Device management request data */
 	struct ufs_dev_cmd dev_cmd;
+	ktime_t last_dme_cmd_tstamp;
 
 	/* Keeps information of the UFS device connected to this host */
 	struct ufs_dev_info dev_info;

commit 7c48bfd038e570cd12b33d6ab13316f3a0b0d1a7
Author: Akinobu Mita <akinobu.mita@gmail.com>
Date:   Thu Oct 23 13:25:12 2014 +0300

    ufs: fix reference counting of W-LUs
    
    UFS driver adds three well known LUs in the initialization, but those
    reference counts are not decremented, so it makes ufshcd module
    impossible to unload.
    
    This fixes it by putting scsi_device_put() in the initalization, and in
    order to protect concurrent access to hba->sdev_ufs_device (UFS Device
    W-LU) from manual delete, increment the reference count while requesting
    device power mode setting.
    
    The rest of W-LUs (hba->sdev_boot and hba->sdev_rpmb) are not directly
    used from driver, so these references in struct ufs_hba are removed.
    
    Signed-off-by: Akinobu Mita <mita@fixstars.com>
    Reviewed-by: Maya Erez <merez@codeaurora.org>
    Reviewed-by: Dolev Raviv <draviv@codeaurora.org>
    Signed-off-by: Christoph Hellwig <hch@lst.de>

diff --git a/drivers/scsi/ufs/ufshcd.h b/drivers/scsi/ufs/ufshcd.h
index 58ecdff5065c..4a574aa45855 100644
--- a/drivers/scsi/ufs/ufshcd.h
+++ b/drivers/scsi/ufs/ufshcd.h
@@ -392,8 +392,6 @@ struct ufs_hba {
 	 * "UFS device" W-LU.
 	 */
 	struct scsi_device *sdev_ufs_device;
-	struct scsi_device *sdev_rpmb;
-	struct scsi_device *sdev_boot;
 
 	enum ufs_dev_pwr_mode curr_dev_pwr_mode;
 	enum uic_link_state uic_link_state;

commit e785060ea3a1c8e37a8bc1449c79e36bff2b5b13
Author: Dolev Raviv <draviv@codeaurora.org>
Date:   Thu Sep 25 15:32:36 2014 +0300

    ufs: definitions for phy interface
    
    - Adding some of the definitions missing in unipro.h, including power
      enumeration.
    - Read Modify Write Line helper function
    - Indication for the type of suspend
    
    Signed-off-by: Dolev Raviv <draviv@codeaurora.org>
    Signed-off-by: Subhash Jadavani <subhashj@codeaurora.org>
    Signed-off-by: Yaniv Gardi <ygardi@codeaurora.org>
    Signed-off-by: Christoph Hellwig <hch@lst.de>

diff --git a/drivers/scsi/ufs/ufshcd.h b/drivers/scsi/ufs/ufshcd.h
index d7fec869d590..58ecdff5065c 100644
--- a/drivers/scsi/ufs/ufshcd.h
+++ b/drivers/scsi/ufs/ufshcd.h
@@ -474,6 +474,7 @@ struct ufs_hba {
 
 	struct devfreq *devfreq;
 	struct ufs_clk_scaling clk_scaling;
+	bool is_sys_suspended;
 };
 
 /* Returns true if clocks can be gated. Otherwise false */
@@ -499,6 +500,23 @@ static inline bool ufshcd_can_autobkops_during_suspend(struct ufs_hba *hba)
 #define ufshcd_readl(hba, reg)	\
 	readl((hba)->mmio_base + (reg))
 
+/**
+ * ufshcd_rmwl - read modify write into a register
+ * @hba - per adapter instance
+ * @mask - mask to apply on read value
+ * @val - actual value to write
+ * @reg - register address
+ */
+static inline void ufshcd_rmwl(struct ufs_hba *hba, u32 mask, u32 val, u32 reg)
+{
+	u32 tmp;
+
+	tmp = ufshcd_readl(hba, reg);
+	tmp &= ~mask;
+	tmp |= (val & mask);
+	ufshcd_writel(hba, tmp, reg);
+}
+
 int ufshcd_alloc_host(struct device *, struct ufs_hba **);
 int ufshcd_init(struct ufs_hba * , void __iomem * , unsigned int);
 void ufshcd_remove(struct ufs_hba *);

commit 374a246e4ebda1fc55d537877bf2412e511ecc7b
Author: Subhash Jadavani <subhashj@codeaurora.org>
Date:   Thu Sep 25 15:32:35 2014 +0300

    ufs: tune bkops while power managment events
    
    Add capability to control the auto bkops during suspend.
    If host explicitly enables the auto bkops (background operation) on device
    then only device would perform the bkops on its own. If auto bkops is not
    enabled explicitly and if the device reaches to state where it must do
    background operation, device would raise the urgent bkops exception event
    to host and then host will enable the auto bkops on device. This patch
    adds the option to choose whether auto bkops should be enabled during
    runtime suspend or not. Since we don't want to keep the device active to
    perform the non critical bkops, host will enable urgent bkops only.
    
    Keep auto-bkops enabled after resume if urgent bkops needed.
    If device bkops status shows that its in critical need of executing
    background operations, host should allow the device to continue doing
    background operations.
    
    Signed-off-by: Subhash Jadavani <subhashj@codeaurora.org>
    Signed-off-by: Dolev Raviv <draviv@codeaurora.org>
    Signed-off-by: Christoph Hellwig <hch@lst.de>

diff --git a/drivers/scsi/ufs/ufshcd.h b/drivers/scsi/ufs/ufshcd.h
index 908db3eb0609..d7fec869d590 100644
--- a/drivers/scsi/ufs/ufshcd.h
+++ b/drivers/scsi/ufs/ufshcd.h
@@ -469,6 +469,8 @@ struct ufs_hba {
 #define UFSHCD_CAP_HIBERN8_WITH_CLK_GATING (1 << 1)
 	/* Allow dynamic clk scaling */
 #define UFSHCD_CAP_CLK_SCALING	(1 << 2)
+	/* Allow auto bkops to enabled during runtime suspend */
+#define UFSHCD_CAP_AUTO_BKOPS_SUSPEND (1 << 3)
 
 	struct devfreq *devfreq;
 	struct ufs_clk_scaling clk_scaling;
@@ -487,6 +489,11 @@ static inline int ufshcd_is_clkscaling_enabled(struct ufs_hba *hba)
 {
 	return hba->caps & UFSHCD_CAP_CLK_SCALING;
 }
+static inline bool ufshcd_can_autobkops_during_suspend(struct ufs_hba *hba)
+{
+	return hba->caps & UFSHCD_CAP_AUTO_BKOPS_SUSPEND;
+}
+
 #define ufshcd_writel(hba, val, reg)	\
 	writel((val), (hba)->mmio_base + (reg))
 #define ufshcd_readl(hba, reg)	\

commit 856b348305c98d4e0c8e5eafa97c61443197f8d3
Author: Sahitya Tummala <stummala@codeaurora.org>
Date:   Thu Sep 25 15:32:34 2014 +0300

    ufs: Add support for clock scaling using devfreq framework
    
    The clocks for UFS device will be managed by generic DVFS (Dynamic
    Voltage and Frequency Scaling) framework within kernel. This devfreq
    framework works with different governors to scale the clocks. By default,
    UFS devices uses simple_ondemand governor which scales the clocks up if
    the load is more than upthreshold and scales down if the load is less than
    downthreshold.
    
    Signed-off-by: Sahitya Tummala <stummala@codeaurora.org>
    Signed-off-by: Dolev Raviv <draviv@codeaurora.org>
    Signed-off-by: Christoph Hellwig <hch@lst.de>

diff --git a/drivers/scsi/ufs/ufshcd.h b/drivers/scsi/ufs/ufshcd.h
index ac72a6daf50e..908db3eb0609 100644
--- a/drivers/scsi/ufs/ufshcd.h
+++ b/drivers/scsi/ufs/ufshcd.h
@@ -210,6 +210,7 @@ struct ufs_dev_cmd {
  * @name: clock name
  * @max_freq: maximum frequency supported by the clock
  * @min_freq: min frequency that can be used for clock scaling
+ * @curr_freq: indicates the current frequency that it is set to
  * @enabled: variable to check against multiple enable/disable
  */
 struct ufs_clk_info {
@@ -218,6 +219,7 @@ struct ufs_clk_info {
 	const char *name;
 	u32 max_freq;
 	u32 min_freq;
+	u32 curr_freq;
 	bool enabled;
 };
 
@@ -244,6 +246,7 @@ struct ufs_pwr_mode_info {
  * @name: variant name
  * @init: called when the driver is initialized
  * @exit: called to cleanup everything done in init
+ * @clk_scale_notify: notifies that clks are scaled up/down
  * @setup_clocks: called before touching any of the controller registers
  * @setup_regulators: called before accessing the host controller
  * @hce_enable_notify: called before and after HCE enable bit is set to allow
@@ -260,6 +263,7 @@ struct ufs_hba_variant_ops {
 	const char *name;
 	int	(*init)(struct ufs_hba *);
 	void    (*exit)(struct ufs_hba *);
+	void    (*clk_scale_notify)(struct ufs_hba *);
 	int     (*setup_clocks)(struct ufs_hba *, bool);
 	int     (*setup_regulators)(struct ufs_hba *, bool);
 	int     (*hce_enable_notify)(struct ufs_hba *, bool);
@@ -303,6 +307,13 @@ struct ufs_clk_gating {
 	int active_reqs;
 };
 
+struct ufs_clk_scaling {
+	ktime_t  busy_start_t;
+	bool is_busy_started;
+	unsigned long  tot_busy_t;
+	unsigned long window_start_t;
+};
+
 /**
  * struct ufs_init_prefetch - contains data that is pre-fetched once during
  * initialization
@@ -456,6 +467,11 @@ struct ufs_hba {
 #define UFSHCD_CAP_CLK_GATING	(1 << 0)
 	/* Allow hiberb8 with clk gating */
 #define UFSHCD_CAP_HIBERN8_WITH_CLK_GATING (1 << 1)
+	/* Allow dynamic clk scaling */
+#define UFSHCD_CAP_CLK_SCALING	(1 << 2)
+
+	struct devfreq *devfreq;
+	struct ufs_clk_scaling clk_scaling;
 };
 
 /* Returns true if clocks can be gated. Otherwise false */
@@ -467,6 +483,10 @@ static inline bool ufshcd_can_hibern8_during_gating(struct ufs_hba *hba)
 {
 	return hba->caps & UFSHCD_CAP_HIBERN8_WITH_CLK_GATING;
 }
+static inline int ufshcd_is_clkscaling_enabled(struct ufs_hba *hba)
+{
+	return hba->caps & UFSHCD_CAP_CLK_SCALING;
+}
 #define ufshcd_writel(hba, val, reg)	\
 	writel((val), (hba)->mmio_base + (reg))
 #define ufshcd_readl(hba, reg)	\

commit 4cff6d991e4a291cf50fe2659da2ea9ad46620bf
Author: Sahitya Tummala <stummala@codeaurora.org>
Date:   Thu Sep 25 15:32:33 2014 +0300

    ufs: Add freq-table-hz property for UFS device
    
    Add freq-table-hz propery for UFS device to keep track of
    <min max> frequencies supported by UFS clocks.
    
    Signed-off-by: Sahitya Tummala <stummala@codeaurora.org>
    Signed-off-by: Dolev Raviv <draviv@codeaurora.org>
    Signed-off-by: Christoph Hellwig <hch@lst.de>

diff --git a/drivers/scsi/ufs/ufshcd.h b/drivers/scsi/ufs/ufshcd.h
index 29d34d3aa5ee..ac72a6daf50e 100644
--- a/drivers/scsi/ufs/ufshcd.h
+++ b/drivers/scsi/ufs/ufshcd.h
@@ -209,6 +209,7 @@ struct ufs_dev_cmd {
  * @clk: clock node
  * @name: clock name
  * @max_freq: maximum frequency supported by the clock
+ * @min_freq: min frequency that can be used for clock scaling
  * @enabled: variable to check against multiple enable/disable
  */
 struct ufs_clk_info {
@@ -216,6 +217,7 @@ struct ufs_clk_info {
 	struct clk *clk;
 	const char *name;
 	u32 max_freq;
+	u32 min_freq;
 	bool enabled;
 };
 

commit 1ab27c9cf8b63dd8dec9e17b5c17721c7f3b6cc7
Author: Sahitya Tummala <stummala@codeaurora.org>
Date:   Thu Sep 25 15:32:32 2014 +0300

    ufs: Add support for clock gating
    
    The UFS controller clocks can be gated after certain period of
    inactivity, which is typically less than runtime suspend timeout.
    In addition to clocks the link will also be put into Hibern8 mode
    to save more power.
    
    The clock gating can be turned on by enabling the capability
    UFSHCD_CAP_CLK_GATING. To enable entering into Hibern8 mode as part of
    clock gating, set the capability UFSHCD_CAP_HIBERN8_WITH_CLK_GATING.
    
    The tracing events for clock gating can be enabled through debugfs as:
    echo 1 > /sys/kernel/debug/tracing/events/ufs/ufshcd_clk_gating/enable
    cat /sys/kernel/debug/tracing/trace_pipe
    
    Signed-off-by: Sahitya Tummala <stummala@codeaurora.org>
    Signed-off-by: Dolev Raviv <draviv@codeaurora.org>
    Signed-off-by: Christoph Hellwig <hch@lst.de>

diff --git a/drivers/scsi/ufs/ufshcd.h b/drivers/scsi/ufs/ufshcd.h
index 343b18a7a8b0..29d34d3aa5ee 100644
--- a/drivers/scsi/ufs/ufshcd.h
+++ b/drivers/scsi/ufs/ufshcd.h
@@ -269,6 +269,38 @@ struct ufs_hba_variant_ops {
 	int     (*resume)(struct ufs_hba *, enum ufs_pm_op);
 };
 
+/* clock gating state  */
+enum clk_gating_state {
+	CLKS_OFF,
+	CLKS_ON,
+	REQ_CLKS_OFF,
+	REQ_CLKS_ON,
+};
+
+/**
+ * struct ufs_clk_gating - UFS clock gating related info
+ * @gate_work: worker to turn off clocks after some delay as specified in
+ * delay_ms
+ * @ungate_work: worker to turn on clocks that will be used in case of
+ * interrupt context
+ * @state: the current clocks state
+ * @delay_ms: gating delay in ms
+ * @is_suspended: clk gating is suspended when set to 1 which can be used
+ * during suspend/resume
+ * @delay_attr: sysfs attribute to control delay_attr
+ * @active_reqs: number of requests that are pending and should be waited for
+ * completion before gating clocks.
+ */
+struct ufs_clk_gating {
+	struct delayed_work gate_work;
+	struct work_struct ungate_work;
+	enum clk_gating_state state;
+	unsigned long delay_ms;
+	bool is_suspended;
+	struct device_attribute delay_attr;
+	int active_reqs;
+};
+
 /**
  * struct ufs_init_prefetch - contains data that is pre-fetched once during
  * initialization
@@ -414,8 +446,25 @@ struct ufs_hba {
 
 	struct ufs_pa_layer_attr pwr_info;
 	struct ufs_pwr_mode_info max_pwr_info;
+
+	struct ufs_clk_gating clk_gating;
+	/* Control to enable/disable host capabilities */
+	u32 caps;
+	/* Allow dynamic clk gating */
+#define UFSHCD_CAP_CLK_GATING	(1 << 0)
+	/* Allow hiberb8 with clk gating */
+#define UFSHCD_CAP_HIBERN8_WITH_CLK_GATING (1 << 1)
 };
 
+/* Returns true if clocks can be gated. Otherwise false */
+static inline bool ufshcd_is_clkgating_allowed(struct ufs_hba *hba)
+{
+	return hba->caps & UFSHCD_CAP_CLK_GATING;
+}
+static inline bool ufshcd_can_hibern8_during_gating(struct ufs_hba *hba)
+{
+	return hba->caps & UFSHCD_CAP_HIBERN8_WITH_CLK_GATING;
+}
 #define ufshcd_writel(hba, val, reg)	\
 	writel((val), (hba)->mmio_base + (reg))
 #define ufshcd_readl(hba, reg)	\
@@ -497,4 +546,6 @@ static inline int ufshcd_dme_peer_get(struct ufs_hba *hba,
 	return ufshcd_dme_get_attr(hba, attr_sel, mib_val, DME_PEER);
 }
 
+int ufshcd_hold(struct ufs_hba *hba, bool async);
+void ufshcd_release(struct ufs_hba *hba);
 #endif /* End of Header */

commit 7eb584db73bebbc9852a14341431ed6935419bec
Author: Dolev Raviv <draviv@codeaurora.org>
Date:   Thu Sep 25 15:32:31 2014 +0300

    ufs: refactor configuring power mode
    
    Sometimes, the device shall report its maximum power and speed
    capabilities, but we might not wish to configure it to use those
    maximum capabilities.
    This change adds support for the vendor specific host driver to
    implement power change notify callback.
    
    To enable configuring different power modes (number of lanes,
    gear number and fast/slow modes) it is necessary to split the
    configuration stage from the stage that reads the device max power mode.
    In addition, it is not required to read the configuration more than
    once, thus the configuration is stored after reading it once.
    
    Signed-off-by: Dolev Raviv <draviv@codeaurora.org>
    Signed-off-by: Yaniv Gardi <ygardi@codeaurora.org>
    Signed-off-by: Christoph Hellwig <hch@lst.de>

diff --git a/drivers/scsi/ufs/ufshcd.h b/drivers/scsi/ufs/ufshcd.h
index e1bde0598d92..343b18a7a8b0 100644
--- a/drivers/scsi/ufs/ufshcd.h
+++ b/drivers/scsi/ufs/ufshcd.h
@@ -221,6 +221,22 @@ struct ufs_clk_info {
 
 #define PRE_CHANGE      0
 #define POST_CHANGE     1
+
+struct ufs_pa_layer_attr {
+	u32 gear_rx;
+	u32 gear_tx;
+	u32 lane_rx;
+	u32 lane_tx;
+	u32 pwr_rx;
+	u32 pwr_tx;
+	u32 hs_rate;
+};
+
+struct ufs_pwr_mode_info {
+	bool is_valid;
+	struct ufs_pa_layer_attr info;
+};
+
 /**
  * struct ufs_hba_variant_ops - variant specific callbacks
  * @name: variant name
@@ -232,6 +248,9 @@ struct ufs_clk_info {
  *                     variant specific Uni-Pro initialization.
  * @link_startup_notify: called before and after Link startup is carried out
  *                       to allow variant specific Uni-Pro initialization.
+ * @pwr_change_notify: called before and after a power mode change
+ *			is carried out to allow vendor spesific capabilities
+ *			to be set.
  * @suspend: called during host controller PM callback
  * @resume: called during host controller PM callback
  */
@@ -243,6 +262,9 @@ struct ufs_hba_variant_ops {
 	int     (*setup_regulators)(struct ufs_hba *, bool);
 	int     (*hce_enable_notify)(struct ufs_hba *, bool);
 	int     (*link_startup_notify)(struct ufs_hba *, bool);
+	int	(*pwr_change_notify)(struct ufs_hba *,
+					bool, struct ufs_pa_layer_attr *,
+					struct ufs_pa_layer_attr *);
 	int     (*suspend)(struct ufs_hba *, enum ufs_pm_op);
 	int     (*resume)(struct ufs_hba *, enum ufs_pm_op);
 };
@@ -302,6 +324,8 @@ struct ufs_init_prefetch {
  * @auto_bkops_enabled: to track whether bkops is enabled in device
  * @vreg_info: UFS device voltage regulator information
  * @clk_list_head: UFS host controller clocks list node head
+ * @pwr_info: holds current power mode
+ * @max_pwr_info: keeps the device max valid pwm
  */
 struct ufs_hba {
 	void __iomem *mmio_base;
@@ -387,6 +411,9 @@ struct ufs_hba {
 	struct list_head clk_list_head;
 
 	bool wlun_dev_clr_ua;
+
+	struct ufs_pa_layer_attr pwr_info;
+	struct ufs_pwr_mode_info max_pwr_info;
 };
 
 #define ufshcd_writel(hba, val, reg)	\

commit 57d104c153d3d6d7bea60089e80f37501851ed2c
Author: Subhash Jadavani <subhashj@codeaurora.org>
Date:   Thu Sep 25 15:32:30 2014 +0300

    ufs: add UFS power management support
    
    This patch adds support for UFS device and UniPro link power management
    during runtime/system PM.
    
    Main idea is to define multiple UFS low power levels based on UFS device
    and UFS link power states. This would allow any specific platform or pci
    driver to choose the best suited low power level during runtime and
    system suspend based on their power goals.
    
    bkops handlig:
    To put the UFS device in sleep state when bkops is disabled, first query
    the bkops status from the device and enable bkops on device only if
    device needs time to perform the bkops.
    
    START_STOP handling:
    Before sending START_STOP_UNIT to the device well-known logical unit
    (w-lun) to make sure that the device w-lun unit attention condition is
    cleared.
    
    Write protection:
    UFS device specification allows LUs to be write protected, either
    permanently or power on write protected. If any LU is power on write
    protected and if the card is power cycled (by powering off VCCQ and/or
    VCC rails), LU's write protect status would be lost. So this means those
    LUs can be written now. To ensures that UFS device is power cycled only
    if the power on protect is not set for any of the LUs, check if power on
    write protect is set and if device is in sleep/power-off state & link in
    inactive state (Hibern8 or OFF state).
    If none of the Logical Units on UFS device is power on write protected
    then all UFS device power rails (VCC, VCCQ & VCCQ2) can be turned off if
    UFS device is in power-off state and UFS link is in OFF state. But current
    implementation would disable all device power rails even if UFS link is
    not in OFF state.
    
    Low power mode:
    If UFS link is in OFF state then UFS host controller can be power collapsed
    to avoid leakage current from it. Note that if UFS host controller is power
    collapsed, full UFS reinitialization will be required on resume to
    re-establish the link between host and device.
    
    Signed-off-by: Subhash Jadavani <subhashj@codeaurora.org>
    Signed-off-by: Dolev Raviv <draviv@codeaurora.org>
    Signed-off-by: Sujit Reddy Thumma <sthumma@codeaurora.org>
    Signed-off-by: Christoph Hellwig <hch@lst.de>

diff --git a/drivers/scsi/ufs/ufshcd.h b/drivers/scsi/ufs/ufshcd.h
index 5c25337bfcc8..e1bde0598d92 100644
--- a/drivers/scsi/ufs/ufshcd.h
+++ b/drivers/scsi/ufs/ufshcd.h
@@ -96,6 +96,54 @@ struct uic_command {
 	struct completion done;
 };
 
+/* Used to differentiate the power management options */
+enum ufs_pm_op {
+	UFS_RUNTIME_PM,
+	UFS_SYSTEM_PM,
+	UFS_SHUTDOWN_PM,
+};
+
+#define ufshcd_is_runtime_pm(op) ((op) == UFS_RUNTIME_PM)
+#define ufshcd_is_system_pm(op) ((op) == UFS_SYSTEM_PM)
+#define ufshcd_is_shutdown_pm(op) ((op) == UFS_SHUTDOWN_PM)
+
+/* Host <-> Device UniPro Link state */
+enum uic_link_state {
+	UIC_LINK_OFF_STATE	= 0, /* Link powered down or disabled */
+	UIC_LINK_ACTIVE_STATE	= 1, /* Link is in Fast/Slow/Sleep state */
+	UIC_LINK_HIBERN8_STATE	= 2, /* Link is in Hibernate state */
+};
+
+#define ufshcd_is_link_off(hba) ((hba)->uic_link_state == UIC_LINK_OFF_STATE)
+#define ufshcd_is_link_active(hba) ((hba)->uic_link_state == \
+				    UIC_LINK_ACTIVE_STATE)
+#define ufshcd_is_link_hibern8(hba) ((hba)->uic_link_state == \
+				    UIC_LINK_HIBERN8_STATE)
+#define ufshcd_set_link_off(hba) ((hba)->uic_link_state = UIC_LINK_OFF_STATE)
+#define ufshcd_set_link_active(hba) ((hba)->uic_link_state = \
+				    UIC_LINK_ACTIVE_STATE)
+#define ufshcd_set_link_hibern8(hba) ((hba)->uic_link_state = \
+				    UIC_LINK_HIBERN8_STATE)
+
+/*
+ * UFS Power management levels.
+ * Each level is in increasing order of power savings.
+ */
+enum ufs_pm_level {
+	UFS_PM_LVL_0, /* UFS_ACTIVE_PWR_MODE, UIC_LINK_ACTIVE_STATE */
+	UFS_PM_LVL_1, /* UFS_ACTIVE_PWR_MODE, UIC_LINK_HIBERN8_STATE */
+	UFS_PM_LVL_2, /* UFS_SLEEP_PWR_MODE, UIC_LINK_ACTIVE_STATE */
+	UFS_PM_LVL_3, /* UFS_SLEEP_PWR_MODE, UIC_LINK_HIBERN8_STATE */
+	UFS_PM_LVL_4, /* UFS_POWERDOWN_PWR_MODE, UIC_LINK_HIBERN8_STATE */
+	UFS_PM_LVL_5, /* UFS_POWERDOWN_PWR_MODE, UIC_LINK_OFF_STATE */
+	UFS_PM_LVL_MAX
+};
+
+struct ufs_pm_lvl_states {
+	enum ufs_dev_pwr_mode dev_state;
+	enum uic_link_state link_state;
+};
+
 /**
  * struct ufshcd_lrb - local reference block
  * @utr_descriptor_ptr: UTRD address of the command
@@ -184,6 +232,8 @@ struct ufs_clk_info {
  *                     variant specific Uni-Pro initialization.
  * @link_startup_notify: called before and after Link startup is carried out
  *                       to allow variant specific Uni-Pro initialization.
+ * @suspend: called during host controller PM callback
+ * @resume: called during host controller PM callback
  */
 struct ufs_hba_variant_ops {
 	const char *name;
@@ -193,6 +243,8 @@ struct ufs_hba_variant_ops {
 	int     (*setup_regulators)(struct ufs_hba *, bool);
 	int     (*hce_enable_notify)(struct ufs_hba *, bool);
 	int     (*link_startup_notify)(struct ufs_hba *, bool);
+	int     (*suspend)(struct ufs_hba *, enum ufs_pm_op);
+	int     (*resume)(struct ufs_hba *, enum ufs_pm_op);
 };
 
 /**
@@ -274,6 +326,14 @@ struct ufs_hba {
 	struct scsi_device *sdev_rpmb;
 	struct scsi_device *sdev_boot;
 
+	enum ufs_dev_pwr_mode curr_dev_pwr_mode;
+	enum uic_link_state uic_link_state;
+	/* Desired UFS power management level during runtime PM */
+	enum ufs_pm_level rpm_lvl;
+	/* Desired UFS power management level during system PM */
+	enum ufs_pm_level spm_lvl;
+	int pm_op_in_progress;
+
 	struct ufshcd_lrb *lrb;
 	unsigned long lrb_in_use;
 
@@ -287,16 +347,17 @@ struct ufs_hba {
 	struct ufs_hba_variant_ops *vops;
 	void *priv;
 	unsigned int irq;
+	bool is_irq_enabled;
 
-	struct uic_command *active_uic_cmd;
-	struct mutex uic_cmd_mutex;
 
 	wait_queue_head_t tm_wq;
 	wait_queue_head_t tm_tag_wq;
 	unsigned long tm_condition;
 	unsigned long tm_slots_in_use;
 
-	struct completion *pwr_done;
+	struct uic_command *active_uic_cmd;
+	struct mutex uic_cmd_mutex;
+	struct completion *uic_async_done;
 
 	u32 ufshcd_state;
 	u32 eh_flags;
@@ -319,9 +380,13 @@ struct ufs_hba {
 	/* Device management request data */
 	struct ufs_dev_cmd dev_cmd;
 
+	/* Keeps information of the UFS device connected to this host */
+	struct ufs_dev_info dev_info;
 	bool auto_bkops_enabled;
 	struct ufs_vreg_info vreg_info;
 	struct list_head clk_list_head;
+
+	bool wlun_dev_clr_ua;
 };
 
 #define ufshcd_writel(hba, val, reg)	\
@@ -348,11 +413,12 @@ static inline void check_upiu_size(void)
 		GENERAL_UPIU_REQUEST_SIZE + QUERY_DESC_MAX_SIZE);
 }
 
-extern int ufshcd_suspend(struct ufs_hba *hba, pm_message_t state);
-extern int ufshcd_resume(struct ufs_hba *hba);
 extern int ufshcd_runtime_suspend(struct ufs_hba *hba);
 extern int ufshcd_runtime_resume(struct ufs_hba *hba);
 extern int ufshcd_runtime_idle(struct ufs_hba *hba);
+extern int ufshcd_system_suspend(struct ufs_hba *hba);
+extern int ufshcd_system_resume(struct ufs_hba *hba);
+extern int ufshcd_shutdown(struct ufs_hba *hba);
 extern int ufshcd_dme_set_attr(struct ufs_hba *hba, u32 attr_sel,
 			       u8 attr_set, u32 mib_val, u8 peer);
 extern int ufshcd_dme_get_attr(struct ufs_hba *hba, u32 attr_sel,

commit 0ce147d48a3e3352859f0c185e98e8392bee7a25
Author: Subhash Jadavani <subhashj@codeaurora.org>
Date:   Thu Sep 25 15:32:29 2014 +0300

    ufs: introduce well known logical unit in ufs
    
    UFS device may have standard LUs and LUN id could be from 0x00 to 0x7F.
    UFS device specification use "Peripheral Device Addressing Format"
    (SCSI SAM-5) for standard LUs.
    
    UFS device may also have the Well Known LUs (also referred as W-LU) which
    again could be from 0x00 to 0x7F. For W-LUs, UFS device specification only
    allows the "Extended Addressing Format" (SCSI SAM-5) which means the W-LUNs
    would start from 0xC100 onwards.
    
    This means max. LUN number reported from UFS device could be 0xC17F hence
    this patch advertise the "max_lun" as 0xC17F which will allow SCSI mid
    layer to detect the W-LUs as well.
    
    But once the W-LUs are detected, UFSHCD driver may get the commands with
    SCSI LUN id upto 0xC17F but UPIU LUN id field is only 8-bit wide so it
    requires the mapping of SCSI LUN id to UPIU LUN id. This patch also add
    support for this mapping.
    
    Signed-off-by: Subhash Jadavani <subhashj@codeaurora.org>
    Signed-off-by: Dolev Raviv <draviv@codeaurora.org>
    Signed-off-by: Sujit Reddy Thumma <sthumma@codeaurora.org>
    Signed-off-by: Christoph Hellwig <hch@lst.de>

diff --git a/drivers/scsi/ufs/ufshcd.h b/drivers/scsi/ufs/ufshcd.h
index 25065ea565e2..5c25337bfcc8 100644
--- a/drivers/scsi/ufs/ufshcd.h
+++ b/drivers/scsi/ufs/ufshcd.h
@@ -124,7 +124,7 @@ struct ufshcd_lrb {
 
 	int command_type;
 	int task_tag;
-	unsigned int lun;
+	u8 lun; /* UPIU LUN id field is only 8-bit wide */
 	bool intr_cmd;
 };
 

commit 2a8fa600445c45222632810a4811ce820279d106
Author: Subhash Jadavani <subhashj@codeaurora.org>
Date:   Thu Sep 25 15:32:28 2014 +0300

    ufs: manually add well known logical units
    
    UFS device specification requires the UFS devices to support 4 well known
    logical units:
            "REPORT_LUNS" (address: 01h)
            "UFS Device" (address: 50h)
            "RPMB" (address: 44h)
            "BOOT" (address: 30h)
    
    UFS device's power management needs to be controlled by "POWER CONDITION"
    field of SSU (START STOP UNIT) command. But this "power condition" field
    will take effect only when its sent to "UFS device" well known logical unit
    hence we require the scsi_device instance to represent this logical unit in
    order for the UFS host driver to send the SSU command for power management.
    
    We also require the scsi_device instance for "RPMB" (Replay Protected
    Memory Block) LU so user space process can control this LU. User space may
    also want to have access to BOOT LU.
    
    This patch adds the scsi device instances for each of all well known LUs
    (except "REPORT LUNS" LU).
    
    Signed-off-by: Subhash Jadavani <subhashj@codeaurora.org>
    Signed-off-by: Dolev Raviv <draviv@codeaurora.org>
    Signed-off-by: Christoph Hellwig <hch@lst.de>

diff --git a/drivers/scsi/ufs/ufshcd.h b/drivers/scsi/ufs/ufshcd.h
index 8365ad437aa6..25065ea565e2 100644
--- a/drivers/scsi/ufs/ufshcd.h
+++ b/drivers/scsi/ufs/ufshcd.h
@@ -266,6 +266,13 @@ struct ufs_hba {
 
 	struct Scsi_Host *host;
 	struct device *dev;
+	/*
+	 * This field is to keep a reference to "scsi_device" corresponding to
+	 * "UFS device" W-LU.
+	 */
+	struct scsi_device *sdev_ufs_device;
+	struct scsi_device *sdev_rpmb;
+	struct scsi_device *sdev_boot;
 
 	struct ufshcd_lrb *lrb;
 	unsigned long lrb_in_use;

commit 3a4bf06d1f6d7de17528b962bc91fcbb2e568b4e
Author: Yaniv Gardi <ygardi@codeaurora.org>
Date:   Thu Sep 25 15:32:27 2014 +0300

    ufs: Active Power Mode - configuring bActiveICCLevel
    
    The maximum power consumption in active is determined by bActiveICCLevel.
    The configuration is done by reading max current supported by the
    regulators connected to VCC, VCCQ and VCCQ2 rails on the boards, and
    reading the current consumption levels from the device for each rails
    (vcc/vccq/vccq2) using power descriptor.
    We configure the bActiveICCLevel attribute, with the max value that
    correspond to the minimum-of(VCC-current-level,VCCQ-current-level,
    VCCQ2-current-level).
    In order to minimize resume latency, pre-fetch icc levels and reference
    clock during initialization and avoid reading them each link startup
    during resume.
    
    Signed-off-by: Raviv Shvili <rshvili@codeaurora.org>
    Signed-off-by: Yaniv Gardi <ygardi@codeaurora.org>
    Signed-off-by: Dolev Raviv <draviv@codeaurora.org>
    Signed-off-by: Christoph Hellwig <hch@lst.de>

diff --git a/drivers/scsi/ufs/ufshcd.h b/drivers/scsi/ufs/ufshcd.h
index eddb3f3b4139..8365ad437aa6 100644
--- a/drivers/scsi/ufs/ufshcd.h
+++ b/drivers/scsi/ufs/ufshcd.h
@@ -195,6 +195,15 @@ struct ufs_hba_variant_ops {
 	int     (*link_startup_notify)(struct ufs_hba *, bool);
 };
 
+/**
+ * struct ufs_init_prefetch - contains data that is pre-fetched once during
+ * initialization
+ * @icc_level: icc level which was read during initialization
+ */
+struct ufs_init_prefetch {
+	u32 icc_level;
+};
+
 /**
  * struct ufs_hba - per adapter private structure
  * @mmio_base: UFSHCI base register address
@@ -229,6 +238,8 @@ struct ufs_hba_variant_ops {
  * @intr_mask: Interrupt Mask Bits
  * @ee_ctrl_mask: Exception event control mask
  * @is_powered: flag to check if HBA is powered
+ * @is_init_prefetch: flag to check if data was pre-fetched in initialization
+ * @init_prefetch_data: data pre-fetched during initialization
  * @eh_work: Worker to handle UFS errors that require s/w attention
  * @eeh_work: Worker to handle exception events
  * @errors: HBA errors
@@ -285,6 +296,8 @@ struct ufs_hba {
 	u32 intr_mask;
 	u16 ee_ctrl_mask;
 	bool is_powered;
+	bool is_init_prefetch;
+	struct ufs_init_prefetch init_prefetch_data;
 
 	/* Work Queues */
 	struct work_struct eh_work;

commit 1d337ec2f35e69a046dab0cc77e64e68d1cdcd8b
Author: Sujit Reddy Thumma <sthumma@codeaurora.org>
Date:   Thu Sep 25 15:32:26 2014 +0300

    ufs: improve init sequence
    
    In ->hce_enable_notify() callback the vendor specific initialization
    may carry out additional DME configuration using UIC commands and
    hence the UIC command completion interrupt enable bit should be set
    before the post reset notification.
    Add retries if the link-startup fails. This is required since due to
    hardware timing issues, the Uni-Pro link-startup might fail. The UFS
    HCI recovery procedure contradicts the Uni-Pro sequence. The UFS HCI
    specifies to resend DME_LINKSTARTUP command after IS.ULLS (link-lost
    interrupt) is received. The Uni-Pro specifies that if link-startup
    fails the link is in "down" state. The link-lost is indicated to the
    DME user only when the link is up. Hence, the UFS HCI recovery procedure
    of waiting for IS.ULLS and retrying link-startup may not work properly.
    
    At the end, if detection fails, power off (disable clocks, regulators,
    phy) if the UFS device detection fails. This saves power while UFS device
    is not embedded into the system.
    
    Signed-off-by: Sujit Reddy Thumma <sthumma@codeaurora.org>
    Signed-off-by: Dolev Raviv <draviv@codeaurora.org>
    Signed-off-by: Christoph Hellwig <hch@lst.de>

diff --git a/drivers/scsi/ufs/ufshcd.h b/drivers/scsi/ufs/ufshcd.h
index bc0f7ed02605..eddb3f3b4139 100644
--- a/drivers/scsi/ufs/ufshcd.h
+++ b/drivers/scsi/ufs/ufshcd.h
@@ -228,6 +228,7 @@ struct ufs_hba_variant_ops {
  * @eh_flags: Error handling flags
  * @intr_mask: Interrupt Mask Bits
  * @ee_ctrl_mask: Exception event control mask
+ * @is_powered: flag to check if HBA is powered
  * @eh_work: Worker to handle UFS errors that require s/w attention
  * @eeh_work: Worker to handle exception events
  * @errors: HBA errors
@@ -283,6 +284,7 @@ struct ufs_hba {
 	u32 eh_flags;
 	u32 intr_mask;
 	u16 ee_ctrl_mask;
+	bool is_powered;
 
 	/* Work Queues */
 	struct work_struct eh_work;

commit c6e79dacd86fd7ddd452fa52b3f4ca996db31e49
Author: Sujit Reddy Thumma <sthumma@codeaurora.org>
Date:   Thu Sep 25 15:32:23 2014 +0300

    ufs: Add clock initialization support
    
    Add generic clock initialization support for UFSHCD platform
    driver. The clock info is read from device tree using standard
    clock bindings. A generic max-clock-frequency-hz property is
    defined to save information on maximum operating clock frequency
    the h/w supports.
    
    Signed-off-by: Sujit Reddy Thumma <sthumma@codeaurora.org>
    Signed-off-by: Dolev Raviv <draviv@codeaurora.org>
    Signed-off-by: Christoph Hellwig <hch@lst.de>

diff --git a/drivers/scsi/ufs/ufshcd.h b/drivers/scsi/ufs/ufshcd.h
index c0232f95f5b5..bc0f7ed02605 100644
--- a/drivers/scsi/ufs/ufshcd.h
+++ b/drivers/scsi/ufs/ufshcd.h
@@ -155,6 +155,22 @@ struct ufs_dev_cmd {
 	struct ufs_query query;
 };
 
+/**
+ * struct ufs_clk_info - UFS clock related info
+ * @list: list headed by hba->clk_list_head
+ * @clk: clock node
+ * @name: clock name
+ * @max_freq: maximum frequency supported by the clock
+ * @enabled: variable to check against multiple enable/disable
+ */
+struct ufs_clk_info {
+	struct list_head list;
+	struct clk *clk;
+	const char *name;
+	u32 max_freq;
+	bool enabled;
+};
+
 #define PRE_CHANGE      0
 #define POST_CHANGE     1
 /**
@@ -221,6 +237,7 @@ struct ufs_hba_variant_ops {
  * @dev_cmd: ufs device management command information
  * @auto_bkops_enabled: to track whether bkops is enabled in device
  * @vreg_info: UFS device voltage regulator information
+ * @clk_list_head: UFS host controller clocks list node head
  */
 struct ufs_hba {
 	void __iomem *mmio_base;
@@ -282,6 +299,7 @@ struct ufs_hba {
 
 	bool auto_bkops_enabled;
 	struct ufs_vreg_info vreg_info;
+	struct list_head clk_list_head;
 };
 
 #define ufshcd_writel(hba, val, reg)	\

commit aa497613093412ee26ef4bfa4ffec8391553dfca
Author: Sujit Reddy Thumma <sthumma@codeaurora.org>
Date:   Thu Sep 25 15:32:22 2014 +0300

    ufs: Add regulator enable support
    
    UFS devices are powered by at most three external power supplies -
    - VCC - The flash memory core power supply, 2.7V to 3.6V or 1.70V to 1.95V
    - VCCQ - The controller and I/O power supply, 1.1V to 1.3V
    - VCCQ2 - Secondary controller and/or I/O power supply, 1.65V to 1.95V
    
    For some devices VCCQ or VCCQ2 are optional as they can be
    generated using internal LDO inside the UFS device.
    
    Add DT bindings for voltage regulators that can be controlled
    from host driver.
    
    Signed-off-by: Sujit Reddy Thumma <sthumma@codeaurora.org>
    Signed-off-by: Dolev Raviv <draviv@codeaurora.org>
    Signed-off-by: Christoph Hellwig <hch@lst.de>

diff --git a/drivers/scsi/ufs/ufshcd.h b/drivers/scsi/ufs/ufshcd.h
index 8c6bec05283e..c0232f95f5b5 100644
--- a/drivers/scsi/ufs/ufshcd.h
+++ b/drivers/scsi/ufs/ufshcd.h
@@ -52,6 +52,7 @@
 #include <linux/pm_runtime.h>
 #include <linux/clk.h>
 #include <linux/completion.h>
+#include <linux/regulator/consumer.h>
 
 #include <asm/irq.h>
 #include <asm/byteorder.h>
@@ -219,6 +220,7 @@ struct ufs_hba_variant_ops {
  * @saved_uic_err: sticky UIC error mask
  * @dev_cmd: ufs device management command information
  * @auto_bkops_enabled: to track whether bkops is enabled in device
+ * @vreg_info: UFS device voltage regulator information
  */
 struct ufs_hba {
 	void __iomem *mmio_base;
@@ -279,6 +281,7 @@ struct ufs_hba {
 	struct ufs_dev_cmd dev_cmd;
 
 	bool auto_bkops_enabled;
+	struct ufs_vreg_info vreg_info;
 };
 
 #define ufshcd_writel(hba, val, reg)	\

commit 5c0c28a84af9f9b6061bb4855a30e13d289b4ae1
Author: Sujit Reddy Thumma <sthumma@codeaurora.org>
Date:   Thu Sep 25 15:32:21 2014 +0300

    ufs: Allow vendor specific initialization
    
    Some vendor specific controller versions might need to configure
    vendor specific - registers, clocks, voltage regulators etc. to
    initialize the host controller UTP layer and Uni-Pro stack.
    Provide some common initialization operations that can be used
    to configure vendor specifics. The methods can be extended in
    future, for example, for power mode transitions.
    
    The operations are vendor/board specific and hence determined with
    the help of compatible property in device tree.
    
    Signed-off-by: Sujit Reddy Thumma <sthumma@codeaurora.org>
    Signed-off-by: Dolev Raviv <draviv@codeaurora.org>
    Signed-off-by: Christoph Hellwig <hch@lst.de>

diff --git a/drivers/scsi/ufs/ufshcd.h b/drivers/scsi/ufs/ufshcd.h
index acf318e338ed..8c6bec05283e 100644
--- a/drivers/scsi/ufs/ufshcd.h
+++ b/drivers/scsi/ufs/ufshcd.h
@@ -68,6 +68,8 @@
 #define UFSHCD "ufshcd"
 #define UFSHCD_DRIVER_VERSION "0.2"
 
+struct ufs_hba;
+
 enum dev_cmd_type {
 	DEV_CMD_TYPE_NOP		= 0x0,
 	DEV_CMD_TYPE_QUERY		= 0x1,
@@ -152,6 +154,30 @@ struct ufs_dev_cmd {
 	struct ufs_query query;
 };
 
+#define PRE_CHANGE      0
+#define POST_CHANGE     1
+/**
+ * struct ufs_hba_variant_ops - variant specific callbacks
+ * @name: variant name
+ * @init: called when the driver is initialized
+ * @exit: called to cleanup everything done in init
+ * @setup_clocks: called before touching any of the controller registers
+ * @setup_regulators: called before accessing the host controller
+ * @hce_enable_notify: called before and after HCE enable bit is set to allow
+ *                     variant specific Uni-Pro initialization.
+ * @link_startup_notify: called before and after Link startup is carried out
+ *                       to allow variant specific Uni-Pro initialization.
+ */
+struct ufs_hba_variant_ops {
+	const char *name;
+	int	(*init)(struct ufs_hba *);
+	void    (*exit)(struct ufs_hba *);
+	int     (*setup_clocks)(struct ufs_hba *, bool);
+	int     (*setup_regulators)(struct ufs_hba *, bool);
+	int     (*hce_enable_notify)(struct ufs_hba *, bool);
+	int     (*link_startup_notify)(struct ufs_hba *, bool);
+};
+
 /**
  * struct ufs_hba - per adapter private structure
  * @mmio_base: UFSHCI base register address
@@ -171,6 +197,8 @@ struct ufs_dev_cmd {
  * @nutrs: Transfer Request Queue depth supported by controller
  * @nutmrs: Task Management Queue depth supported by controller
  * @ufs_version: UFS Version to which controller complies
+ * @vops: pointer to variant specific operations
+ * @priv: pointer to variant specific private data
  * @irq: Irq number of the controller
  * @active_uic_cmd: handle of active UIC command
  * @uic_cmd_mutex: mutex for uic command
@@ -218,6 +246,8 @@ struct ufs_hba {
 	int nutrs;
 	int nutmrs;
 	u32 ufs_version;
+	struct ufs_hba_variant_ops *vops;
+	void *priv;
 	unsigned int irq;
 
 	struct uic_command *active_uic_cmd;
@@ -256,8 +286,8 @@ struct ufs_hba {
 #define ufshcd_readl(hba, reg)	\
 	readl((hba)->mmio_base + (reg))
 
-int ufshcd_init(struct device *, struct ufs_hba ** , void __iomem * ,
-			unsigned int);
+int ufshcd_alloc_host(struct device *, struct ufs_hba **);
+int ufshcd_init(struct ufs_hba * , void __iomem * , unsigned int);
 void ufshcd_remove(struct ufs_hba *);
 
 /**

commit e8e7f27139d5ba5b9f05fdee3f6224116ce8427c
Author: Sujit Reddy Thumma <sthumma@codeaurora.org>
Date:   Mon May 26 10:59:15 2014 +0530

    scsi: ufs: Improve UFS fatal error handling
    
    Error handling in UFS driver is broken and resets the host controller
    for fatal errors without re-initialization. Correct the fatal error
    handling sequence according to UFS Host Controller Interface (HCI)
    v1.1 specification.
    
    o Processed requests which are completed w/wo error are reported to
      SCSI layer and any pending commands that are not started are aborted
      in the controller and re-queued into scsi mid-layer queue.
    
    o Upon determining fatal error condition the host controller may hang
      forever until a reset is applied. Block SCSI layer for sending new
      requests and apply reset in a separate error handling work.
    
    o SCSI is informed about the expected Unit-Attention exception from the
      device for the immediate command after a reset so that the SCSI layer
      take necessary steps to establish communication with the device.
    
    Signed-off-by: Sujit Reddy Thumma <sthumma@codeaurora.org>
    Reviewed-by: Yaniv Gardi <ygardi@codeaurora.org>
    Tested-by: Dolev Raviv <draviv@codeaurora.org>
    Acked-by: Vinayak Holikatti <vinholikatti@gmail.com>
    Signed-off-by: Christoph Hellwig <hch@lst.de>

diff --git a/drivers/scsi/ufs/ufshcd.h b/drivers/scsi/ufs/ufshcd.h
index 48c7d9b587f7..acf318e338ed 100644
--- a/drivers/scsi/ufs/ufshcd.h
+++ b/drivers/scsi/ufs/ufshcd.h
@@ -183,9 +183,12 @@ struct ufs_dev_cmd {
  * @eh_flags: Error handling flags
  * @intr_mask: Interrupt Mask Bits
  * @ee_ctrl_mask: Exception event control mask
- * @feh_workq: Work queue for fatal controller error handling
+ * @eh_work: Worker to handle UFS errors that require s/w attention
  * @eeh_work: Worker to handle exception events
  * @errors: HBA errors
+ * @uic_error: UFS interconnect layer error status
+ * @saved_err: sticky error mask
+ * @saved_uic_err: sticky UIC error mask
  * @dev_cmd: ufs device management command information
  * @auto_bkops_enabled: to track whether bkops is enabled in device
  */
@@ -233,11 +236,14 @@ struct ufs_hba {
 	u16 ee_ctrl_mask;
 
 	/* Work Queues */
-	struct work_struct feh_workq;
+	struct work_struct eh_work;
 	struct work_struct eeh_work;
 
 	/* HBA Errors */
 	u32 errors;
+	u32 uic_error;
+	u32 saved_err;
+	u32 saved_uic_err;
 
 	/* Device management request data */
 	struct ufs_dev_cmd dev_cmd;

commit 3441da7ddbdedf91bfd5cc8609c571ffc24942dd
Author: Sujit Reddy Thumma <sthumma@codeaurora.org>
Date:   Mon May 26 10:59:14 2014 +0530

    scsi: ufs: Fix device and host reset methods
    
    As of now SCSI initiated error handling is broken because,
    the reset APIs don't try to bring back the device initialized and
    ready for further transfers.
    
    In case of timeouts, the scsi error handler takes care of handling aborts
    and resets. Improve the error handling in such scenario by resetting the
    device and host and re-initializing them in proper manner.
    
    Signed-off-by: Sujit Reddy Thumma <sthumma@codeaurora.org>
    Reviewed-by: Yaniv Gardi <ygardi@codeaurora.org>
    Tested-by: Dolev Raviv <draviv@codeaurora.org>
    Acked-by: Vinayak Holikatti <vinholikatti@gmail.com>
    Signed-off-by: Christoph Hellwig <hch@lst.de>

diff --git a/drivers/scsi/ufs/ufshcd.h b/drivers/scsi/ufs/ufshcd.h
index 84d09d1ae881..48c7d9b587f7 100644
--- a/drivers/scsi/ufs/ufshcd.h
+++ b/drivers/scsi/ufs/ufshcd.h
@@ -180,6 +180,7 @@ struct ufs_dev_cmd {
  * @pwr_done: completion for power mode change
  * @tm_condition: condition variable for task management
  * @ufshcd_state: UFSHCD states
+ * @eh_flags: Error handling flags
  * @intr_mask: Interrupt Mask Bits
  * @ee_ctrl_mask: Exception event control mask
  * @feh_workq: Work queue for fatal controller error handling
@@ -227,6 +228,7 @@ struct ufs_hba {
 	struct completion *pwr_done;
 
 	u32 ufshcd_state;
+	u32 eh_flags;
 	u32 intr_mask;
 	u16 ee_ctrl_mask;
 

commit e293313262d3c780632f7888878c982fa0a9bf7e
Author: Sujit Reddy Thumma <sthumma@codeaurora.org>
Date:   Mon May 26 10:59:12 2014 +0530

    scsi: ufs: Fix broken task management command implementation
    
    Currently, sending Task Management (TM) command to the card might
    be broken in some scenarios as listed below:
    
    Problem: If there are more than 8 TM commands the implementation
             returns error to the caller.
    Fix:     Wait for one of the slots to be emptied and send the command.
    
    Problem: Sometimes it is necessary for the caller to know the TM service
             response code to determine the task status.
    Fix:     Propogate the service response to the caller.
    
    Problem: If the TM command times out no proper error recovery is
             implemented.
    Fix:     Clear the command in the controller door-bell register, so that
             further commands for the same slot don't fail.
    
    Problem: While preparing the TM command descriptor, the task tag used
             should be unique across SCSI/NOP/QUERY/TM commands and not the
             task tag of the command which the TM command is trying to manage.
    Fix:     Use a unique task tag instead of task tag of SCSI command.
    
    Problem: Since the TM command involves H/W communication, abruptly ending
             the request on kill interrupt signal might cause h/w malfunction.
    Fix:     Wait for hardware completion interrupt with TASK_UNINTERRUPTIBLE
             set.
    
    Signed-off-by: Sujit Reddy Thumma <sthumma@codeaurora.org>
    Reviewed-by: Yaniv Gardi <ygardi@codeaurora.org>
    Tested-by: Dolev Raviv <draviv@codeaurora.org>
    Acked-by: Vinayak Holikatti <vinholikatti@gmail.com>
    Signed-off-by: Christoph Hellwig <hch@lst.de>

diff --git a/drivers/scsi/ufs/ufshcd.h b/drivers/scsi/ufs/ufshcd.h
index 767ee9ebfaf1..84d09d1ae881 100644
--- a/drivers/scsi/ufs/ufshcd.h
+++ b/drivers/scsi/ufs/ufshcd.h
@@ -174,7 +174,9 @@ struct ufs_dev_cmd {
  * @irq: Irq number of the controller
  * @active_uic_cmd: handle of active UIC command
  * @uic_cmd_mutex: mutex for uic command
- * @ufshcd_tm_wait_queue: wait queue for task management
+ * @tm_wq: wait queue for task management
+ * @tm_tag_wq: wait queue for free task management slots
+ * @tm_slots_in_use: bit map of task management request slots in use
  * @pwr_done: completion for power mode change
  * @tm_condition: condition variable for task management
  * @ufshcd_state: UFSHCD states
@@ -217,8 +219,10 @@ struct ufs_hba {
 	struct uic_command *active_uic_cmd;
 	struct mutex uic_cmd_mutex;
 
-	wait_queue_head_t ufshcd_tm_wait_queue;
+	wait_queue_head_t tm_wq;
+	wait_queue_head_t tm_tag_wq;
 	unsigned long tm_condition;
+	unsigned long tm_slots_in_use;
 
 	struct completion *pwr_done;
 

commit bdbe5d2fe67031bf51777afbfa91585efcf9dbf5
Author: Sujit Reddy Thumma <sthumma@codeaurora.org>
Date:   Mon May 26 10:59:11 2014 +0530

    scsi: ufs: make undeclared functions static
    
    Make undeclared functions static and declare exported symbols
    to suppress warnings from sparse tool.
    
    Signed-off-by: Sujit Reddy Thumma <sthumma@codeaurora.org>
    Acked-by: Vinayak Holikatti <vinholikatti@gmail.com>
    Signed-off-by: Christoph Hellwig <hch@lst.de>

diff --git a/drivers/scsi/ufs/ufshcd.h b/drivers/scsi/ufs/ufshcd.h
index 577679a2d189..767ee9ebfaf1 100644
--- a/drivers/scsi/ufs/ufshcd.h
+++ b/drivers/scsi/ufs/ufshcd.h
@@ -263,6 +263,8 @@ static inline void check_upiu_size(void)
 		GENERAL_UPIU_REQUEST_SIZE + QUERY_DESC_MAX_SIZE);
 }
 
+extern int ufshcd_suspend(struct ufs_hba *hba, pm_message_t state);
+extern int ufshcd_resume(struct ufs_hba *hba);
 extern int ufshcd_runtime_suspend(struct ufs_hba *hba);
 extern int ufshcd_runtime_resume(struct ufs_hba *hba);
 extern int ufshcd_runtime_idle(struct ufs_hba *hba);

commit 53b3d9c3fdda94d14392dd221c67e24700b1fed6
Author: Seungwon Jeon <tgih.jun@samsung.com>
Date:   Sat Aug 31 21:40:22 2013 +0530

    [SCSI] ufs: add operation for the uic power mode change
    
    Setting PA_PWRMode using DME_SET triggers the power mode
    change. And then the result will be given by the HCS.UPMCRS.
    This operation should be done atomically.
    
    Signed-off-by: Seungwon Jeon <tgih.jun@samsung.com>
    Reviewed-by: Subhash Jadavani <subhashj@codeaurora.org>
    Tested-by: Yaniv Gardi <ygardi@codeaurora.org>
    Signed-off-by: Santosh Y <santoshsy@gmail.com>
    Signed-off-by: James Bottomley <JBottomley@Parallels.com>

diff --git a/drivers/scsi/ufs/ufshcd.h b/drivers/scsi/ufs/ufshcd.h
index 648ab16d379c..577679a2d189 100644
--- a/drivers/scsi/ufs/ufshcd.h
+++ b/drivers/scsi/ufs/ufshcd.h
@@ -175,6 +175,7 @@ struct ufs_dev_cmd {
  * @active_uic_cmd: handle of active UIC command
  * @uic_cmd_mutex: mutex for uic command
  * @ufshcd_tm_wait_queue: wait queue for task management
+ * @pwr_done: completion for power mode change
  * @tm_condition: condition variable for task management
  * @ufshcd_state: UFSHCD states
  * @intr_mask: Interrupt Mask Bits
@@ -219,6 +220,8 @@ struct ufs_hba {
 	wait_queue_head_t ufshcd_tm_wait_queue;
 	unsigned long tm_condition;
 
+	struct completion *pwr_done;
+
 	u32 ufshcd_state;
 	u32 intr_mask;
 	u16 ee_ctrl_mask;

commit 12b4fdb4f6bccb5459a2f75fbe0eab253bfceab4
Author: Seungwon Jeon <tgih.jun@samsung.com>
Date:   Sat Aug 31 21:40:21 2013 +0530

    [SCSI] ufs: add dme configuration primitives
    
    Implements to support GET and SET operations of the DME.
    These operations are used to configure the behavior of
    the UNIPRO. Along with basic operation, {Peer/AttrSetType}
    can be mixed.
    
    Signed-off-by: Seungwon Jeon <tgih.jun@samsung.com>
    Reviewed-by: Subhash Jadavani <subhashj@codeaurora.org>
    Tested-by: Yaniv Gardi <ygardi@codeaurora.org>
    Signed-off-by: Santosh Y <santoshsy@gmail.com>
    Signed-off-by: James Bottomley <JBottomley@Parallels.com>

diff --git a/drivers/scsi/ufs/ufshcd.h b/drivers/scsi/ufs/ufshcd.h
index 59c9c4848be1..648ab16d379c 100644
--- a/drivers/scsi/ufs/ufshcd.h
+++ b/drivers/scsi/ufs/ufshcd.h
@@ -263,4 +263,55 @@ static inline void check_upiu_size(void)
 extern int ufshcd_runtime_suspend(struct ufs_hba *hba);
 extern int ufshcd_runtime_resume(struct ufs_hba *hba);
 extern int ufshcd_runtime_idle(struct ufs_hba *hba);
+extern int ufshcd_dme_set_attr(struct ufs_hba *hba, u32 attr_sel,
+			       u8 attr_set, u32 mib_val, u8 peer);
+extern int ufshcd_dme_get_attr(struct ufs_hba *hba, u32 attr_sel,
+			       u32 *mib_val, u8 peer);
+
+/* UIC command interfaces for DME primitives */
+#define DME_LOCAL	0
+#define DME_PEER	1
+#define ATTR_SET_NOR	0	/* NORMAL */
+#define ATTR_SET_ST	1	/* STATIC */
+
+static inline int ufshcd_dme_set(struct ufs_hba *hba, u32 attr_sel,
+				 u32 mib_val)
+{
+	return ufshcd_dme_set_attr(hba, attr_sel, ATTR_SET_NOR,
+				   mib_val, DME_LOCAL);
+}
+
+static inline int ufshcd_dme_st_set(struct ufs_hba *hba, u32 attr_sel,
+				    u32 mib_val)
+{
+	return ufshcd_dme_set_attr(hba, attr_sel, ATTR_SET_ST,
+				   mib_val, DME_LOCAL);
+}
+
+static inline int ufshcd_dme_peer_set(struct ufs_hba *hba, u32 attr_sel,
+				      u32 mib_val)
+{
+	return ufshcd_dme_set_attr(hba, attr_sel, ATTR_SET_NOR,
+				   mib_val, DME_PEER);
+}
+
+static inline int ufshcd_dme_peer_st_set(struct ufs_hba *hba, u32 attr_sel,
+					 u32 mib_val)
+{
+	return ufshcd_dme_set_attr(hba, attr_sel, ATTR_SET_ST,
+				   mib_val, DME_PEER);
+}
+
+static inline int ufshcd_dme_get(struct ufs_hba *hba,
+				 u32 attr_sel, u32 *mib_val)
+{
+	return ufshcd_dme_get_attr(hba, attr_sel, mib_val, DME_LOCAL);
+}
+
+static inline int ufshcd_dme_peer_get(struct ufs_hba *hba,
+				      u32 attr_sel, u32 *mib_val)
+{
+	return ufshcd_dme_get_attr(hba, attr_sel, mib_val, DME_PEER);
+}
+
 #endif /* End of Header */

commit 66ec6d59407baf7c7a1f99c79d632403c1064266
Author: Sujit Reddy Thumma <sthumma@codeaurora.org>
Date:   Tue Jul 30 00:35:59 2013 +0530

    [SCSI] ufs: Add support for host assisted background operations
    
    Background operations in the UFS device can be disabled by
    the host to reduce the response latency of transfer requests.
    Add support for enabling/disabling the background operations
    during runtime suspend/resume of the device.
    
    If the device is in critical need of BKOPS it will raise an
    URGENT_BKOPS exception which should be handled by the host to
    make sure the device performs as expected.
    
    During bootup, the BKOPS is enabled in the device by default.
    The disable of BKOPS is supported only when the driver supports
    runtime suspend/resume operations as the runtime PM framework
    provides a way to determine the device idleness and hence BKOPS
    can be managed effectively. During runtime resume the BKOPS is
    disabled to reduce latency and during runtime suspend the BKOPS
    is enabled to allow device to carry out idle time BKOPS.
    
    In some cases where the BKOPS is disabled during runtime resume
    and due to continuous data transfers the runtime suspend is not
    triggered, the BKOPS is enabled when the device raises a level-2
    exception (outstanding operations - performance impact).
    
    Signed-off-by: Sujit Reddy Thumma <sthumma@codeaurora.org>
    Signed-off-by: Santosh Y <santoshsy@gmail.com>
    Signed-off-by: James Bottomley <JBottomley@Parallels.com>

diff --git a/drivers/scsi/ufs/ufshcd.h b/drivers/scsi/ufs/ufshcd.h
index 6d6fdeb81af8..59c9c4848be1 100644
--- a/drivers/scsi/ufs/ufshcd.h
+++ b/drivers/scsi/ufs/ufshcd.h
@@ -178,9 +178,12 @@ struct ufs_dev_cmd {
  * @tm_condition: condition variable for task management
  * @ufshcd_state: UFSHCD states
  * @intr_mask: Interrupt Mask Bits
+ * @ee_ctrl_mask: Exception event control mask
  * @feh_workq: Work queue for fatal controller error handling
+ * @eeh_work: Worker to handle exception events
  * @errors: HBA errors
  * @dev_cmd: ufs device management command information
+ * @auto_bkops_enabled: to track whether bkops is enabled in device
  */
 struct ufs_hba {
 	void __iomem *mmio_base;
@@ -218,15 +221,19 @@ struct ufs_hba {
 
 	u32 ufshcd_state;
 	u32 intr_mask;
+	u16 ee_ctrl_mask;
 
 	/* Work Queues */
 	struct work_struct feh_workq;
+	struct work_struct eeh_work;
 
 	/* HBA Errors */
 	u32 errors;
 
 	/* Device management request data */
 	struct ufs_dev_cmd dev_cmd;
+
+	bool auto_bkops_enabled;
 };
 
 #define ufshcd_writel(hba, val, reg)	\
@@ -253,4 +260,7 @@ static inline void check_upiu_size(void)
 		GENERAL_UPIU_REQUEST_SIZE + QUERY_DESC_MAX_SIZE);
 }
 
+extern int ufshcd_runtime_suspend(struct ufs_hba *hba);
+extern int ufshcd_runtime_resume(struct ufs_hba *hba);
+extern int ufshcd_runtime_idle(struct ufs_hba *hba);
 #endif /* End of Header */

commit 68078d5cc1a59b2ddfc6982c67308f20f991426a
Author: Dolev Raviv <draviv@codeaurora.org>
Date:   Tue Jul 30 00:35:58 2013 +0530

    [SCSI] ufs: Set fDeviceInit flag to initiate device initialization
    
    Allow UFS device to complete its initialization and accept
    SCSI commands by setting fDeviceInit flag. The device may take
    time for this operation and hence the host should poll until
    fDeviceInit flag is toggled to zero. This step is mandated by
    UFS device specification for device initialization completion.
    
    Signed-off-by: Dolev Raviv <draviv@codeaurora.org>
    Signed-off-by: Sujit Reddy Thumma <sthumma@codeaurora.org>
    Signed-off-by: Santosh Y <santoshsy@gmail.com>
    Signed-off-by: James Bottomley <JBottomley@Parallels.com>

diff --git a/drivers/scsi/ufs/ufshcd.h b/drivers/scsi/ufs/ufshcd.h
index c750a90eb9da..6d6fdeb81af8 100644
--- a/drivers/scsi/ufs/ufshcd.h
+++ b/drivers/scsi/ufs/ufshcd.h
@@ -70,6 +70,7 @@
 
 enum dev_cmd_type {
 	DEV_CMD_TYPE_NOP		= 0x0,
+	DEV_CMD_TYPE_QUERY		= 0x1,
 };
 
 /**
@@ -124,6 +125,18 @@ struct ufshcd_lrb {
 	bool intr_cmd;
 };
 
+/**
+ * struct ufs_query - holds relevent data structures for query request
+ * @request: request upiu and function
+ * @descriptor: buffer for sending/receiving descriptor
+ * @response: response upiu and response
+ */
+struct ufs_query {
+	struct ufs_query_req request;
+	u8 *descriptor;
+	struct ufs_query_res response;
+};
+
 /**
  * struct ufs_dev_cmd - all assosiated fields with device management commands
  * @type: device management command type - Query, NOP OUT
@@ -136,6 +149,7 @@ struct ufs_dev_cmd {
 	struct mutex lock;
 	struct completion *complete;
 	wait_queue_head_t tag_wq;
+	struct ufs_query query;
 };
 
 /**
@@ -233,4 +247,10 @@ static inline void ufshcd_hba_stop(struct ufs_hba *hba)
 	ufshcd_writel(hba, CONTROLLER_DISABLE,  REG_CONTROLLER_ENABLE);
 }
 
+static inline void check_upiu_size(void)
+{
+	BUILD_BUG_ON(ALIGNED_UPIU_SIZE <
+		GENERAL_UPIU_REQUEST_SIZE + QUERY_DESC_MAX_SIZE);
+}
+
 #endif /* End of Header */

commit 5a0b0cb9bee767ef10ff9ce2fb4141af06416288
Author: Sujit Reddy Thumma <sthumma@codeaurora.org>
Date:   Tue Jul 30 00:35:57 2013 +0530

    [SCSI] ufs: Add support for sending NOP OUT UPIU
    
    As part of device initialization sequence, sending NOP OUT UPIU and
    waiting for NOP IN UPIU response is mandatory. This confirms that the
    device UFS Transport (UTP) layer is functional and the host can configure
    the device with further commands. Add support for sending NOP OUT UPIU to
    check the device connection path and test whether the UTP layer on the
    device side is functional during initialization.
    
    A tag is acquired from the SCSI tag map space in order to send the device
    management command. When the tag is acquired by internal command the scsi
    command is rejected with host busy flag in order to requeue the request.
    To avoid frequent collisions between internal commands and scsi commands
    the device management command tag is allocated in the opposite direction
    w.r.t block layer tag allocation.
    
    Signed-off-by: Sujit Reddy Thumma <sthumma@codeaurora.org>
    Signed-off-by: Dolev Raviv <draviv@codeaurora.org>
    Signed-off-by: Santosh Y <santoshsy@gmail.com>
    Signed-off-by: James Bottomley <JBottomley@Parallels.com>

diff --git a/drivers/scsi/ufs/ufshcd.h b/drivers/scsi/ufs/ufshcd.h
index 49590ee07acc..c750a90eb9da 100644
--- a/drivers/scsi/ufs/ufshcd.h
+++ b/drivers/scsi/ufs/ufshcd.h
@@ -68,6 +68,10 @@
 #define UFSHCD "ufshcd"
 #define UFSHCD_DRIVER_VERSION "0.2"
 
+enum dev_cmd_type {
+	DEV_CMD_TYPE_NOP		= 0x0,
+};
+
 /**
  * struct uic_command - UIC command structure
  * @command: UIC command
@@ -91,7 +95,7 @@ struct uic_command {
 /**
  * struct ufshcd_lrb - local reference block
  * @utr_descriptor_ptr: UTRD address of the command
- * @ucd_cmd_ptr: UCD address of the command
+ * @ucd_req_ptr: UCD address of the command
  * @ucd_rsp_ptr: Response UPIU address for this command
  * @ucd_prdt_ptr: PRDT address of the command
  * @cmd: pointer to SCSI command
@@ -101,10 +105,11 @@ struct uic_command {
  * @command_type: SCSI, UFS, Query.
  * @task_tag: Task tag of the command
  * @lun: LUN of the command
+ * @intr_cmd: Interrupt command (doesn't participate in interrupt aggregation)
  */
 struct ufshcd_lrb {
 	struct utp_transfer_req_desc *utr_descriptor_ptr;
-	struct utp_upiu_cmd *ucd_cmd_ptr;
+	struct utp_upiu_req *ucd_req_ptr;
 	struct utp_upiu_rsp *ucd_rsp_ptr;
 	struct ufshcd_sg_entry *ucd_prdt_ptr;
 
@@ -116,8 +121,22 @@ struct ufshcd_lrb {
 	int command_type;
 	int task_tag;
 	unsigned int lun;
+	bool intr_cmd;
 };
 
+/**
+ * struct ufs_dev_cmd - all assosiated fields with device management commands
+ * @type: device management command type - Query, NOP OUT
+ * @lock: lock to allow one command at a time
+ * @complete: internal commands completion
+ * @tag_wq: wait queue until free command slot is available
+ */
+struct ufs_dev_cmd {
+	enum dev_cmd_type type;
+	struct mutex lock;
+	struct completion *complete;
+	wait_queue_head_t tag_wq;
+};
 
 /**
  * struct ufs_hba - per adapter private structure
@@ -131,6 +150,7 @@ struct ufshcd_lrb {
  * @host: Scsi_Host instance of the driver
  * @dev: device handle
  * @lrb: local reference block
+ * @lrb_in_use: lrb in use
  * @outstanding_tasks: Bits representing outstanding task requests
  * @outstanding_reqs: Bits representing outstanding transfer requests
  * @capabilities: UFS Controller Capabilities
@@ -146,6 +166,7 @@ struct ufshcd_lrb {
  * @intr_mask: Interrupt Mask Bits
  * @feh_workq: Work queue for fatal controller error handling
  * @errors: HBA errors
+ * @dev_cmd: ufs device management command information
  */
 struct ufs_hba {
 	void __iomem *mmio_base;
@@ -164,6 +185,7 @@ struct ufs_hba {
 	struct device *dev;
 
 	struct ufshcd_lrb *lrb;
+	unsigned long lrb_in_use;
 
 	unsigned long outstanding_tasks;
 	unsigned long outstanding_reqs;
@@ -188,6 +210,9 @@ struct ufs_hba {
 
 	/* HBA Errors */
 	u32 errors;
+
+	/* Device management request data */
+	struct ufs_dev_cmd dev_cmd;
 };
 
 #define ufshcd_writel(hba, val, reg)	\

commit 6ccf44fe4cd7c45a33f571788890a299d8bca448
Author: Seungwon Jeon <tgih.jun@samsung.com>
Date:   Wed Jun 26 22:39:29 2013 +0530

    [SCSI] ufs: rework link start-up process
    
    Link start-up requires long time with multiphase handshakes
    between UFS host and device. This affects driver's probe time.
    This patch let link start-up run asynchronously. Link start-up
    will be executed at the end of prove separately.
    Along with this change, the following is worked.
    
    Defined completion time of uic command to avoid a permanent wait.
    Added mutex to guarantee of uic command at a time.
    Adapted some sequence of controller initialization after link statup
    according to HCI standard.
    
    Signed-off-by: Seungwon Jeon <tgih.jun@samsung.com>
    Signed-off-by: Sujit Reddy Thumma <sthumma@codeaurora.org>
    Tested-by: Maya Erez <merez@codeaurora.org>
    Signed-off-by: Santosh Y <santoshsy@gmail.com>
    Signed-off-by: James Bottomley <JBottomley@Parallels.com>

diff --git a/drivers/scsi/ufs/ufshcd.h b/drivers/scsi/ufs/ufshcd.h
index 4213600b89d6..49590ee07acc 100644
--- a/drivers/scsi/ufs/ufshcd.h
+++ b/drivers/scsi/ufs/ufshcd.h
@@ -51,6 +51,7 @@
 #include <linux/bitops.h>
 #include <linux/pm_runtime.h>
 #include <linux/clk.h>
+#include <linux/completion.h>
 
 #include <asm/irq.h>
 #include <asm/byteorder.h>
@@ -75,6 +76,7 @@
  * @argument3: UIC command argument 3
  * @cmd_active: Indicate if UIC command is outstanding
  * @result: UIC command result
+ * @done: UIC command completion
  */
 struct uic_command {
 	u32 command;
@@ -83,6 +85,7 @@ struct uic_command {
 	u32 argument3;
 	int cmd_active;
 	int result;
+	struct completion done;
 };
 
 /**
@@ -136,11 +139,11 @@ struct ufshcd_lrb {
  * @ufs_version: UFS Version to which controller complies
  * @irq: Irq number of the controller
  * @active_uic_cmd: handle of active UIC command
+ * @uic_cmd_mutex: mutex for uic command
  * @ufshcd_tm_wait_queue: wait queue for task management
  * @tm_condition: condition variable for task management
  * @ufshcd_state: UFSHCD states
  * @intr_mask: Interrupt Mask Bits
- * @uic_workq: Work queue for UIC completion handling
  * @feh_workq: Work queue for fatal controller error handling
  * @errors: HBA errors
  */
@@ -171,7 +174,9 @@ struct ufs_hba {
 	u32 ufs_version;
 	unsigned int irq;
 
-	struct uic_command active_uic_cmd;
+	struct uic_command *active_uic_cmd;
+	struct mutex uic_cmd_mutex;
+
 	wait_queue_head_t ufshcd_tm_wait_queue;
 	unsigned long tm_condition;
 
@@ -179,7 +184,6 @@ struct ufs_hba {
 	u32 intr_mask;
 
 	/* Work Queues */
-	struct work_struct uic_workq;
 	struct work_struct feh_workq;
 
 	/* HBA Errors */

commit 2fbd009b40967fc54b7eb3580372736862291a06
Author: Seungwon Jeon <tgih.jun@samsung.com>
Date:   Wed Jun 26 22:39:27 2013 +0530

    [SCSI] ufs: amend interrupt configuration
    
    It makes interrupt setting more flexible especially
    for disabling. And wrong bit mask is fixed for ver 1.0.
    [17:16] is added for mask.
    
    Signed-off-by: Seungwon Jeon <tgih.jun@samsung.com>
    Tested-by: Maya Erez <merez@codeaurora.org>
    Signed-off-by: Santosh Y <santoshsy@gmail.com>
    Signed-off-by: James Bottomley <JBottomley@Parallels.com>

diff --git a/drivers/scsi/ufs/ufshcd.h b/drivers/scsi/ufs/ufshcd.h
index 807dd2d740d4..4213600b89d6 100644
--- a/drivers/scsi/ufs/ufshcd.h
+++ b/drivers/scsi/ufs/ufshcd.h
@@ -139,7 +139,7 @@ struct ufshcd_lrb {
  * @ufshcd_tm_wait_queue: wait queue for task management
  * @tm_condition: condition variable for task management
  * @ufshcd_state: UFSHCD states
- * @int_enable_mask: Interrupt Mask Bits
+ * @intr_mask: Interrupt Mask Bits
  * @uic_workq: Work queue for UIC completion handling
  * @feh_workq: Work queue for fatal controller error handling
  * @errors: HBA errors
@@ -176,7 +176,7 @@ struct ufs_hba {
 	unsigned long tm_condition;
 
 	u32 ufshcd_state;
-	u32 int_enable_mask;
+	u32 intr_mask;
 
 	/* Work Queues */
 	struct work_struct uic_workq;

commit b873a27538dff59e77c15eaf23bdf7e6be7d36e9
Author: Seungwon Jeon <tgih.jun@samsung.com>
Date:   Wed Jun 26 22:39:26 2013 +0530

    [SCSI] ufs: wrap the i/o access operations
    
    Simplify operations with hiding mmio_base.
    
    Signed-off-by: Seungwon Jeon <tgih.jun@samsung.com>
    Tested-by: Maya Erez <merez@codeaurora.org>
    Signed-off-by: Santosh Y <santoshsy@gmail.com>
    Signed-off-by: James Bottomley <JBottomley@Parallels.com>

diff --git a/drivers/scsi/ufs/ufshcd.h b/drivers/scsi/ufs/ufshcd.h
index 6b99a42f5819..807dd2d740d4 100644
--- a/drivers/scsi/ufs/ufshcd.h
+++ b/drivers/scsi/ufs/ufshcd.h
@@ -186,6 +186,11 @@ struct ufs_hba {
 	u32 errors;
 };
 
+#define ufshcd_writel(hba, val, reg)	\
+	writel((val), (hba)->mmio_base + (reg))
+#define ufshcd_readl(hba, reg)	\
+	readl((hba)->mmio_base + (reg))
+
 int ufshcd_init(struct device *, struct ufs_hba ** , void __iomem * ,
 			unsigned int);
 void ufshcd_remove(struct ufs_hba *);
@@ -196,7 +201,7 @@ void ufshcd_remove(struct ufs_hba *);
  */
 static inline void ufshcd_hba_stop(struct ufs_hba *hba)
 {
-	writel(CONTROLLER_DISABLE, (hba->mmio_base + REG_CONTROLLER_ENABLE));
+	ufshcd_writel(hba, CONTROLLER_DISABLE,  REG_CONTROLLER_ENABLE);
 }
 
 #endif /* End of Header */

commit e0eca63e342124cff4307eafb43908cab5b3cf88
Author: Vinayak Holikatti <vinholikatti@gmail.com>
Date:   Mon Feb 25 21:44:33 2013 +0530

    [SCSI] ufs: Separate PCI code into glue driver
    
    This patch separates PCI code from ufshcd.c and makes it as a
    core driver module and adds a new file ufshcd-pci.c as PCI glue
    driver.
    
    [jejb: strip __devinit and devexit_p()]
    Reviewed-by: Arnd Bergmann <arnd@arndb.de>
    Reviewed-by: Namjae Jeon <linkinjeon@gmail.com>
    Reviewed-by: Subhash Jadavani <subhashj@codeaurora.org>
    Tested-by: Maya Erez <merez@codeaurora.org>
    Signed-off-by: Vinayak Holikatti <vinholikatti@gmail.com>
    Signed-off-by: Santosh Yaraganavi <santoshsy@gmail.com>
    Signed-off-by: James Bottomley <JBottomley@Parallels.com>

diff --git a/drivers/scsi/ufs/ufshcd.h b/drivers/scsi/ufs/ufshcd.h
new file mode 100644
index 000000000000..6b99a42f5819
--- /dev/null
+++ b/drivers/scsi/ufs/ufshcd.h
@@ -0,0 +1,202 @@
+/*
+ * Universal Flash Storage Host controller driver
+ *
+ * This code is based on drivers/scsi/ufs/ufshcd.h
+ * Copyright (C) 2011-2013 Samsung India Software Operations
+ *
+ * Authors:
+ *	Santosh Yaraganavi <santosh.sy@samsung.com>
+ *	Vinayak Holikatti <h.vinayak@samsung.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ * See the COPYING file in the top-level directory or visit
+ * <http://www.gnu.org/licenses/gpl-2.0.html>
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * This program is provided "AS IS" and "WITH ALL FAULTS" and
+ * without warranty of any kind. You are solely responsible for
+ * determining the appropriateness of using and distributing
+ * the program and assume all risks associated with your exercise
+ * of rights with respect to the program, including but not limited
+ * to infringement of third party rights, the risks and costs of
+ * program errors, damage to or loss of data, programs or equipment,
+ * and unavailability or interruption of operations. Under no
+ * circumstances will the contributor of this Program be liable for
+ * any damages of any kind arising from your use or distribution of
+ * this program.
+ */
+
+#ifndef _UFSHCD_H
+#define _UFSHCD_H
+
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/interrupt.h>
+#include <linux/io.h>
+#include <linux/delay.h>
+#include <linux/slab.h>
+#include <linux/spinlock.h>
+#include <linux/workqueue.h>
+#include <linux/errno.h>
+#include <linux/types.h>
+#include <linux/wait.h>
+#include <linux/bitops.h>
+#include <linux/pm_runtime.h>
+#include <linux/clk.h>
+
+#include <asm/irq.h>
+#include <asm/byteorder.h>
+#include <scsi/scsi.h>
+#include <scsi/scsi_cmnd.h>
+#include <scsi/scsi_host.h>
+#include <scsi/scsi_tcq.h>
+#include <scsi/scsi_dbg.h>
+#include <scsi/scsi_eh.h>
+
+#include "ufs.h"
+#include "ufshci.h"
+
+#define UFSHCD "ufshcd"
+#define UFSHCD_DRIVER_VERSION "0.2"
+
+/**
+ * struct uic_command - UIC command structure
+ * @command: UIC command
+ * @argument1: UIC command argument 1
+ * @argument2: UIC command argument 2
+ * @argument3: UIC command argument 3
+ * @cmd_active: Indicate if UIC command is outstanding
+ * @result: UIC command result
+ */
+struct uic_command {
+	u32 command;
+	u32 argument1;
+	u32 argument2;
+	u32 argument3;
+	int cmd_active;
+	int result;
+};
+
+/**
+ * struct ufshcd_lrb - local reference block
+ * @utr_descriptor_ptr: UTRD address of the command
+ * @ucd_cmd_ptr: UCD address of the command
+ * @ucd_rsp_ptr: Response UPIU address for this command
+ * @ucd_prdt_ptr: PRDT address of the command
+ * @cmd: pointer to SCSI command
+ * @sense_buffer: pointer to sense buffer address of the SCSI command
+ * @sense_bufflen: Length of the sense buffer
+ * @scsi_status: SCSI status of the command
+ * @command_type: SCSI, UFS, Query.
+ * @task_tag: Task tag of the command
+ * @lun: LUN of the command
+ */
+struct ufshcd_lrb {
+	struct utp_transfer_req_desc *utr_descriptor_ptr;
+	struct utp_upiu_cmd *ucd_cmd_ptr;
+	struct utp_upiu_rsp *ucd_rsp_ptr;
+	struct ufshcd_sg_entry *ucd_prdt_ptr;
+
+	struct scsi_cmnd *cmd;
+	u8 *sense_buffer;
+	unsigned int sense_bufflen;
+	int scsi_status;
+
+	int command_type;
+	int task_tag;
+	unsigned int lun;
+};
+
+
+/**
+ * struct ufs_hba - per adapter private structure
+ * @mmio_base: UFSHCI base register address
+ * @ucdl_base_addr: UFS Command Descriptor base address
+ * @utrdl_base_addr: UTP Transfer Request Descriptor base address
+ * @utmrdl_base_addr: UTP Task Management Descriptor base address
+ * @ucdl_dma_addr: UFS Command Descriptor DMA address
+ * @utrdl_dma_addr: UTRDL DMA address
+ * @utmrdl_dma_addr: UTMRDL DMA address
+ * @host: Scsi_Host instance of the driver
+ * @dev: device handle
+ * @lrb: local reference block
+ * @outstanding_tasks: Bits representing outstanding task requests
+ * @outstanding_reqs: Bits representing outstanding transfer requests
+ * @capabilities: UFS Controller Capabilities
+ * @nutrs: Transfer Request Queue depth supported by controller
+ * @nutmrs: Task Management Queue depth supported by controller
+ * @ufs_version: UFS Version to which controller complies
+ * @irq: Irq number of the controller
+ * @active_uic_cmd: handle of active UIC command
+ * @ufshcd_tm_wait_queue: wait queue for task management
+ * @tm_condition: condition variable for task management
+ * @ufshcd_state: UFSHCD states
+ * @int_enable_mask: Interrupt Mask Bits
+ * @uic_workq: Work queue for UIC completion handling
+ * @feh_workq: Work queue for fatal controller error handling
+ * @errors: HBA errors
+ */
+struct ufs_hba {
+	void __iomem *mmio_base;
+
+	/* Virtual memory reference */
+	struct utp_transfer_cmd_desc *ucdl_base_addr;
+	struct utp_transfer_req_desc *utrdl_base_addr;
+	struct utp_task_req_desc *utmrdl_base_addr;
+
+	/* DMA memory reference */
+	dma_addr_t ucdl_dma_addr;
+	dma_addr_t utrdl_dma_addr;
+	dma_addr_t utmrdl_dma_addr;
+
+	struct Scsi_Host *host;
+	struct device *dev;
+
+	struct ufshcd_lrb *lrb;
+
+	unsigned long outstanding_tasks;
+	unsigned long outstanding_reqs;
+
+	u32 capabilities;
+	int nutrs;
+	int nutmrs;
+	u32 ufs_version;
+	unsigned int irq;
+
+	struct uic_command active_uic_cmd;
+	wait_queue_head_t ufshcd_tm_wait_queue;
+	unsigned long tm_condition;
+
+	u32 ufshcd_state;
+	u32 int_enable_mask;
+
+	/* Work Queues */
+	struct work_struct uic_workq;
+	struct work_struct feh_workq;
+
+	/* HBA Errors */
+	u32 errors;
+};
+
+int ufshcd_init(struct device *, struct ufs_hba ** , void __iomem * ,
+			unsigned int);
+void ufshcd_remove(struct ufs_hba *);
+
+/**
+ * ufshcd_hba_stop - Send controller to reset state
+ * @hba: per adapter instance
+ */
+static inline void ufshcd_hba_stop(struct ufs_hba *hba)
+{
+	writel(CONTROLLER_DISABLE, (hba->mmio_base + REG_CONTROLLER_ENABLE));
+}
+
+#endif /* End of Header */
