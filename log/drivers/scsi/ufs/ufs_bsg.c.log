commit a1e17eb03e69bb61bd1b1a14610436b7b9be12d9
Author: Dinghao Liu <dinghao.liu@zju.edu.cn>
Date:   Fri May 22 12:59:29 2020 +0800

    scsi: ufs-bsg: Fix runtime PM imbalance on error
    
    When ufs_bsg_alloc_desc_buffer() returns an error code, a pairing runtime
    PM usage counter decrement is needed to keep the counter balanced.
    
    Link: https://lore.kernel.org/r/20200522045932.31795-1-dinghao.liu@zju.edu.cn
    Fixes: 74e5e468b664 (scsi: ufs-bsg: Wake the device before sending raw upiu commands)
    Reviewed-by: Avri Altman <avri.altman@wdc.com>
    Signed-off-by: Dinghao Liu <dinghao.liu@zju.edu.cn>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/ufs/ufs_bsg.c b/drivers/scsi/ufs/ufs_bsg.c
index 53dd87628cbe..516a7f573942 100644
--- a/drivers/scsi/ufs/ufs_bsg.c
+++ b/drivers/scsi/ufs/ufs_bsg.c
@@ -106,8 +106,10 @@ static int ufs_bsg_request(struct bsg_job *job)
 		desc_op = bsg_request->upiu_req.qr.opcode;
 		ret = ufs_bsg_alloc_desc_buffer(hba, job, &desc_buff,
 						&desc_len, desc_op);
-		if (ret)
+		if (ret) {
+			pm_runtime_put_sync(hba->dev);
 			goto out;
+		}
 
 		/* fall through */
 	case UPIU_TRANSACTION_NOP_OUT:

commit 8c850a0296004409e7bcb9464712fb2807da656a
Author: Can Guo <cang@codeaurora.org>
Date:   Tue Dec 3 06:58:40 2019 +0000

    scsi: ufs: Give an unique ID to each ufs-bsg
    
    Considering there can be multiple UFS hosts in SoC, give each ufs-bsg an
    unique ID by appending the scsi host number to its device name.
    
    Link: https://lore.kernel.org/r/0101016eca8dc9d7-d24468d3-04d2-4ef3-a906-abe8b8cbcd3d-000000@us-west-2.amazonses.com
    Fixes: df032bf27a41 ("scsi: ufs: Add a bsg endpoint that supports UPIUs")
    Signed-off-by: Can Guo <cang@codeaurora.org>
    Reviewed-by: Avri Altman <avri.altman@wdc.com>
    Reviewed-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/ufs/ufs_bsg.c b/drivers/scsi/ufs/ufs_bsg.c
index baeecee35d1e..53dd87628cbe 100644
--- a/drivers/scsi/ufs/ufs_bsg.c
+++ b/drivers/scsi/ufs/ufs_bsg.c
@@ -203,7 +203,7 @@ int ufs_bsg_probe(struct ufs_hba *hba)
 	bsg_dev->parent = get_device(parent);
 	bsg_dev->release = ufs_bsg_node_release;
 
-	dev_set_name(bsg_dev, "ufs-bsg");
+	dev_set_name(bsg_dev, "ufs-bsg%u", shost->host_no);
 
 	ret = device_add(bsg_dev);
 	if (ret)

commit ef2cc88e2a205b8a11a19e78db63a70d3728cdf5
Merge: 937d6eefc716 65309ef6b258
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Mon Dec 2 13:37:02 2019 -0800

    Merge tag 'scsi-misc' of git://git.kernel.org/pub/scm/linux/kernel/git/jejb/scsi
    
    Pull SCSI updates from James Bottomley:
     "This is mostly update of the usual drivers: aacraid, ufs, zfcp,
      NCR5380, lpfc, qla2xxx, smartpqi, hisi_sas, target, mpt3sas, pm80xx
      plus a whole load of minor updates and fixes.
    
      The major core changes are Al Viro's reworking of sg's handling of
      copy to/from user, Ming Lei's removal of the host busy counter to
      avoid contention in the multiqueue case and Damien Le Moal's fixing of
      residual tracking across error handling"
    
    * tag 'scsi-misc' of git://git.kernel.org/pub/scm/linux/kernel/git/jejb/scsi: (251 commits)
      scsi: bnx2fc: timeout calculation invalid for bnx2fc_eh_abort()
      scsi: target: core: Fix a pr_debug() argument
      scsi: iscsi: Don't send data to unbound connection
      scsi: target: iscsi: Wait for all commands to finish before freeing a session
      scsi: target: core: Release SPC-2 reservations when closing a session
      scsi: target: core: Document target_cmd_size_check()
      scsi: bnx2i: fix potential use after free
      Revert "scsi: qla2xxx: Fix memory leak when sending I/O fails"
      scsi: NCR5380: Add disconnect_mask module parameter
      scsi: NCR5380: Unconditionally clear ICR after do_abort()
      scsi: NCR5380: Call scsi_set_resid() on command completion
      scsi: scsi_debug: num_tgts must be >= 0
      scsi: lpfc: use hdwq assigned cpu for allocation
      scsi: arcmsr: fix indentation issues
      scsi: qla4xxx: fix double free bug
      scsi: pm80xx: Modified the logic to collect fatal dump
      scsi: pm80xx: Tie the interrupt name to the module instance
      scsi: pm80xx: Controller fatal error through sysfs
      scsi: pm80xx: Do not request 12G sas speeds
      scsi: pm80xx: Cleanup command when a reset times out
      ...

commit d0e9760de338635450c4e8ebb07bdbcfb1b56e64
Author: Bart Van Assche <bvanassche@acm.org>
Date:   Tue Oct 29 16:07:08 2019 -0700

    scsi: ufs: Fix kernel-doc warnings
    
    Fix the following three kernel-doc warnings:
    
    drivers/scsi/ufs/ufs_bsg.c:165: warning: Function parameter or member 'hba' not described in 'ufs_bsg_remove'
    drivers/scsi/ufs/ufshcd.c:5789: warning: Function parameter or member 'cmd_type' not described in 'ufshcd_issue_devman_upiu_cmd'
    drivers/scsi/ufs/ufshcd.c:5789: warning: Excess function parameter 'msgcode' description in 'ufshcd_issue_devman_upiu_cmd'
    
    Cc: Yaniv Gardi <ygardi@codeaurora.org>
    Cc: Subhash Jadavani <subhashj@codeaurora.org>
    Cc: Stanley Chu <stanley.chu@mediatek.com>
    Cc: Avri Altman <avri.altman@wdc.com>
    Cc: Tomas Winkler <tomas.winkler@intel.com>
    Link: https://lore.kernel.org/r/20191029230710.211926-2-bvanassche@acm.org
    Signed-off-by: Bart Van Assche <bvanassche@acm.org>
    Reviewed-by: Avri Altman <avri.altman@wdc.com>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/ufs/ufs_bsg.c b/drivers/scsi/ufs/ufs_bsg.c
index a9344eb4e047..3a2e68f1ad42 100644
--- a/drivers/scsi/ufs/ufs_bsg.c
+++ b/drivers/scsi/ufs/ufs_bsg.c
@@ -158,6 +158,7 @@ static int ufs_bsg_request(struct bsg_job *job)
 
 /**
  * ufs_bsg_remove - detach and remove the added ufs-bsg node
+ * @hba: per adapter object
  *
  * Should be called when unloading the driver.
  */

commit 74e5e468b664d3739b2872d54764af97ac38e795
Author: Avri Altman <avri.altman@wdc.com>
Date:   Thu Oct 10 11:31:07 2019 +0300

    scsi: ufs-bsg: Wake the device before sending raw upiu commands
    
    The scsi async probe process is calling blk_pm_runtime_init for each lun,
    and then those request queues are monitored by the block layer pm
    engine (blk-pm.c).  This is however, not the case for scsi-passthrough
    queues, created by bsg_setup_queue().
    
    So the ufs-bsg driver might send various commands, disregarding the pm
    status of the device. This is wrong, regardless if its request queue is
    pm-aware or not.
    
    Fixes: df032bf27a41 (scsi: ufs: Add a bsg endpoint that supports UPIUs)
    Link: https://lore.kernel.org/r/1570696267-8487-1-git-send-email-avri.altman@wdc.com
    Reported-by: Yuliy Izrailov <yuliy.izrailov@wdc.com>
    Signed-off-by: Avri Altman <avri.altman@wdc.com>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/ufs/ufs_bsg.c b/drivers/scsi/ufs/ufs_bsg.c
index a9344eb4e047..dc2f6d2b46ed 100644
--- a/drivers/scsi/ufs/ufs_bsg.c
+++ b/drivers/scsi/ufs/ufs_bsg.c
@@ -98,6 +98,8 @@ static int ufs_bsg_request(struct bsg_job *job)
 
 	bsg_reply->reply_payload_rcv_len = 0;
 
+	pm_runtime_get_sync(hba->dev);
+
 	msgcode = bsg_request->msgcode;
 	switch (msgcode) {
 	case UPIU_TRANSACTION_QUERY_REQ:
@@ -135,6 +137,8 @@ static int ufs_bsg_request(struct bsg_job *job)
 		break;
 	}
 
+	pm_runtime_put_sync(hba->dev);
+
 	if (!desc_buff)
 		goto out;
 

commit b13a3539eb2affcb8833c189d68d6a4b99c41f6e
Author: Bean Huo <beanhuo@micron.com>
Date:   Sun Jun 23 17:38:56 2019 +0000

    scsi: ufs-bsg: complete ufs-bsg job only if no error
    
    In the case of UPIU/DME request execution failed in UFS device,
    ufs_bsg_request() will complete the failed bsg job by calling
    bsg_job_done(). Meanwhile, it returns this error status to blk-mq layer,
    then triggers blk-mq completing this request again, this will cause the
    following panic.
    
    Call trace:
    ll_sc___cmpxchg_case_acq_32+0x4/0x20
    complete+0x28/0x70
    blk_end_sync_rq+0x24/0x30
    blk_mq_end_request+0xb8/0x118
    bsg_job_put+0x4c/0x58
    bsg_complete+0x20/0x30
    blk_done_softirq+0xb4/0xe8
    do_softirq+0x154/0x3f0
    run_ksoftirqd+0x4c/0x68
    smpboot_thread_fn+0x22c/0x268
    kthread+0x130/0x138
    ret_from_fork+0x10/0x1c
    Code: f84107fe d65f03c0 d503201f f9800011 (885ffc10)
    ---[ end trace d92825bff6326e66 ]---
    Kernel panic - not syncing: Fatal exception in interrupt
    
    This patch is to fix this issue. The solution is to complete the ufs-bsg
    job only if no error happened.
    
    [mkp: commit description tweak]
    
    Fixes: df032bf27a41 (scsi: ufs: Add a bsg endpoint that supports UPIUs)
    Signed-off-by: Bean Huo <beanhuo@micron.com>
    Reviewed-by: Avri Altman <Avri.Altman@wdc.com>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/ufs/ufs_bsg.c b/drivers/scsi/ufs/ufs_bsg.c
index f420d6f8d84c..a9344eb4e047 100644
--- a/drivers/scsi/ufs/ufs_bsg.c
+++ b/drivers/scsi/ufs/ufs_bsg.c
@@ -149,7 +149,9 @@ static int ufs_bsg_request(struct bsg_job *job)
 out:
 	bsg_reply->result = ret;
 	job->reply_len = sizeof(struct ufs_bsg_reply);
-	bsg_job_done(job, ret, bsg_reply->reply_payload_rcv_len);
+	/* complete the job here only if no error */
+	if (ret == 0)
+		bsg_job_done(job, ret, bsg_reply->reply_payload_rcv_len);
 
 	return ret;
 }

commit c870d65fe3084193113ec622049b6906b899366c
Author: Bean Huo <beanhuo@micron.com>
Date:   Sun Jun 23 17:38:39 2019 +0000

    scsi: ufs-bsg: fix typo in ufs_bsg_request
    
    Correct dev_dbg to dev_err, so as to print out the error information in
    case of DME command failed.
    
    Signed-off-by: Bean Huo <beanhuo@micron.com>
    Reviewed-by: Avri Altman <Avri.Altman@wdc.com>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/ufs/ufs_bsg.c b/drivers/scsi/ufs/ufs_bsg.c
index 869e71f861d6..f420d6f8d84c 100644
--- a/drivers/scsi/ufs/ufs_bsg.c
+++ b/drivers/scsi/ufs/ufs_bsg.c
@@ -122,7 +122,7 @@ static int ufs_bsg_request(struct bsg_job *job)
 		memcpy(&uc, &bsg_request->upiu_req.uc, UIC_CMD_SIZE);
 		ret = ufshcd_send_uic_cmd(hba, &uc);
 		if (ret)
-			dev_dbg(hba->dev,
+			dev_err(hba->dev,
 				"send uic cmd: error code %d\n", ret);
 
 		memcpy(&bsg_reply->upiu_rsp.uc, &uc, UIC_CMD_SIZE);

commit 5c17f87abb1a86eb4d2a108477e56389622cf195
Author: Avri Altman <avri.altman@wdc.com>
Date:   Wed Feb 20 09:11:14 2019 +0200

    scsi: ufs-bsg: Allow reading descriptors
    
    Add this functionality, placing the descriptor being read in the actual
    data buffer in the bio.
    
    That is, for both read and write descriptors query upiu, we are using the
    job's request_payload.  This in turn, is mapped back in user land to the
    applicable sg_io_v4 xferp: dout_xferp for write descriptor, and din_xferp
    for read descriptor.
    
    Signed-off-by: Avri Altman <avri.altman@wdc.com>
    Reviewed-by: Evan Green <evgreen@chromium.org>
    Reviewed-by: Bean Huo <beanhuo@micron.com>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/ufs/ufs_bsg.c b/drivers/scsi/ufs/ufs_bsg.c
index 2fd0769efafe..869e71f861d6 100644
--- a/drivers/scsi/ufs/ufs_bsg.c
+++ b/drivers/scsi/ufs/ufs_bsg.c
@@ -48,12 +48,8 @@ static int ufs_bsg_alloc_desc_buffer(struct ufs_hba *hba, struct bsg_job *job,
 	struct utp_upiu_query *qr;
 	u8 *descp;
 
-	if (desc_op == UPIU_QUERY_OPCODE_READ_DESC) {
-		dev_err(hba->dev, "unsupported opcode %d\n", desc_op);
-		return -ENOTSUPP;
-	}
-
-	if (desc_op != UPIU_QUERY_OPCODE_WRITE_DESC)
+	if (desc_op != UPIU_QUERY_OPCODE_WRITE_DESC &&
+	    desc_op != UPIU_QUERY_OPCODE_READ_DESC)
 		goto out;
 
 	qr = &bsg_request->upiu_req.qr;
@@ -71,8 +67,10 @@ static int ufs_bsg_alloc_desc_buffer(struct ufs_hba *hba, struct bsg_job *job,
 	if (!descp)
 		return -ENOMEM;
 
-	sg_copy_to_buffer(job->request_payload.sg_list,
-			  job->request_payload.sg_cnt, descp, *desc_len);
+	if (desc_op == UPIU_QUERY_OPCODE_WRITE_DESC)
+		sg_copy_to_buffer(job->request_payload.sg_list,
+				  job->request_payload.sg_cnt, descp,
+				  *desc_len);
 
 	*desc_buff = descp;
 
@@ -140,6 +138,12 @@ static int ufs_bsg_request(struct bsg_job *job)
 	if (!desc_buff)
 		goto out;
 
+	if (desc_op == UPIU_QUERY_OPCODE_READ_DESC && desc_len)
+		bsg_reply->reply_payload_rcv_len =
+			sg_copy_from_buffer(job->request_payload.sg_list,
+					    job->request_payload.sg_cnt,
+					    desc_buff, desc_len);
+
 	kfree(desc_buff);
 
 out:

commit 4eaa329e331343dd64996297583f2eee7d215e2a
Author: Avri Altman <avri.altman@wdc.com>
Date:   Wed Feb 20 09:11:12 2019 +0200

    scsi: ufs-bsg: Change the calling convention for write descriptor
    
    When we had a write descriptor query upiu, we appended the descriptor right
    after the bsg request.  This was fine as the bsg driver allows to allocate
    whatever buffer we needed in its job request.
    
    Still, the proper way to deliver payload, however small (we only write
    config descriptors of 144 bytes), is by using the job request payload data
    buffer.
    
    So change this ABI now, while ufs-bsg is still new, and nobody is actually
    using it.
    
    Signed-off-by: Avri Altman <avri.altman@wdc.com>
    Reviewed-by: Evan Green <evgreen@chromium.org>
    Reviewed-by: Bean Huo <beanhuo@micron.com>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/ufs/ufs_bsg.c b/drivers/scsi/ufs/ufs_bsg.c
index 775bb4e5e36e..2fd0769efafe 100644
--- a/drivers/scsi/ufs/ufs_bsg.c
+++ b/drivers/scsi/ufs/ufs_bsg.c
@@ -27,15 +27,11 @@ static int ufs_bsg_get_query_desc_size(struct ufs_hba *hba, int *desc_len,
 
 static int ufs_bsg_verify_query_size(struct ufs_hba *hba,
 				     unsigned int request_len,
-				     unsigned int reply_len,
-				     int desc_len, enum query_opcode desc_op)
+				     unsigned int reply_len)
 {
 	int min_req_len = sizeof(struct ufs_bsg_request);
 	int min_rsp_len = sizeof(struct ufs_bsg_reply);
 
-	if (desc_op == UPIU_QUERY_OPCODE_WRITE_DESC)
-		min_req_len += desc_len;
-
 	if (min_req_len > request_len || min_rsp_len > reply_len) {
 		dev_err(hba->dev, "not enough space assigned\n");
 		return -EINVAL;
@@ -44,14 +40,13 @@ static int ufs_bsg_verify_query_size(struct ufs_hba *hba,
 	return 0;
 }
 
-static int ufs_bsg_verify_query_params(struct ufs_hba *hba,
-				       struct ufs_bsg_request *bsg_request,
-				       unsigned int request_len,
-				       unsigned int reply_len,
-				       uint8_t *desc_buff, int *desc_len,
-				       enum query_opcode desc_op)
+static int ufs_bsg_alloc_desc_buffer(struct ufs_hba *hba, struct bsg_job *job,
+				     uint8_t **desc_buff, int *desc_len,
+				     enum query_opcode desc_op)
 {
+	struct ufs_bsg_request *bsg_request = job->request;
 	struct utp_upiu_query *qr;
+	u8 *descp;
 
 	if (desc_op == UPIU_QUERY_OPCODE_READ_DESC) {
 		dev_err(hba->dev, "unsupported opcode %d\n", desc_op);
@@ -67,11 +62,19 @@ static int ufs_bsg_verify_query_params(struct ufs_hba *hba,
 		return -EINVAL;
 	}
 
-	if (ufs_bsg_verify_query_size(hba, request_len, reply_len, *desc_len,
-				      desc_op))
+	if (*desc_len > job->request_payload.payload_len) {
+		dev_err(hba->dev, "Illegal desc size\n");
 		return -EINVAL;
+	}
+
+	descp = kzalloc(*desc_len, GFP_KERNEL);
+	if (!descp)
+		return -ENOMEM;
 
-	desc_buff = (uint8_t *)(bsg_request + 1);
+	sg_copy_to_buffer(job->request_payload.sg_list,
+			  job->request_payload.sg_cnt, descp, *desc_len);
+
+	*desc_buff = descp;
 
 out:
 	return 0;
@@ -91,7 +94,7 @@ static int ufs_bsg_request(struct bsg_job *job)
 	enum query_opcode desc_op = UPIU_QUERY_OPCODE_NOP;
 	int ret;
 
-	ret = ufs_bsg_verify_query_size(hba, req_len, reply_len, 0, desc_op);
+	ret = ufs_bsg_verify_query_size(hba, req_len, reply_len);
 	if (ret)
 		goto out;
 
@@ -101,9 +104,8 @@ static int ufs_bsg_request(struct bsg_job *job)
 	switch (msgcode) {
 	case UPIU_TRANSACTION_QUERY_REQ:
 		desc_op = bsg_request->upiu_req.qr.opcode;
-		ret = ufs_bsg_verify_query_params(hba, bsg_request, req_len,
-						  reply_len, desc_buff,
-						  &desc_len, desc_op);
+		ret = ufs_bsg_alloc_desc_buffer(hba, job, &desc_buff,
+						&desc_len, desc_op);
 		if (ret)
 			goto out;
 
@@ -135,11 +137,14 @@ static int ufs_bsg_request(struct bsg_job *job)
 		break;
 	}
 
+	if (!desc_buff)
+		goto out;
+
+	kfree(desc_buff);
+
 out:
 	bsg_reply->result = ret;
-	job->reply_len = sizeof(struct ufs_bsg_reply) +
-			 bsg_reply->reply_payload_rcv_len;
-
+	job->reply_len = sizeof(struct ufs_bsg_reply);
 	bsg_job_done(job, ret, bsg_reply->reply_payload_rcv_len);
 
 	return ret;

commit 5e28b8d8a1b03ce86f33d38a64a4983d2b5c7679
Author: Jens Axboe <axboe@kernel.dk>
Date:   Fri Oct 26 11:27:02 2018 -0600

    bsg: provide bsg_remove_queue() helper
    
    All drivers do unregister + cleanup, provide a helper for that.
    
    Cc: linux-scsi@vger.kernel.org
    Reviewed-by: Hannes Reinecke <hare@suse.com>
    Reviewed-by: Johannes Thumshirn <jthumshirn@suse.de>
    Reviewed-by: Christoph Hellwig <hch@lst.de>
    Tested-by: Benjamin Block <bblock@linux.vnet.ibm.com>
    Tested-by: Ming Lei <ming.lei@redhat.com>
    Reviewed-by: Omar Sandoval <osandov@fb.com>
    Signed-off-by: Jens Axboe <axboe@kernel.dk>

diff --git a/drivers/scsi/ufs/ufs_bsg.c b/drivers/scsi/ufs/ufs_bsg.c
index dd0e9700a74c..775bb4e5e36e 100644
--- a/drivers/scsi/ufs/ufs_bsg.c
+++ b/drivers/scsi/ufs/ufs_bsg.c
@@ -157,7 +157,7 @@ void ufs_bsg_remove(struct ufs_hba *hba)
 	if (!hba->bsg_queue)
 		return;
 
-	bsg_unregister_queue(hba->bsg_queue);
+	bsg_remove_queue(hba->bsg_queue);
 
 	device_del(bsg_dev);
 	put_device(bsg_dev);

commit aae3b069d5ce865ca5ef2902c2a22cef7ab4f3a2
Author: Jens Axboe <axboe@kernel.dk>
Date:   Fri Oct 26 11:26:25 2018 -0600

    bsg: pass in desired timeout handler
    
    This will ease in the conversion to blk-mq, where we can't set
    a timeout handler after queue init.
    
    Cc: Johannes Thumshirn <jthumshirn@suse.de>
    Cc: linux-scsi@vger.kernel.org
    Reviewed-by: Hannes Reinecke <hare@suse.com>
    Tested-by: Benjamin Block <bblock@linux.vnet.ibm.com>
    Tested-by: Ming Lei <ming.lei@redhat.com>
    Reviewed-by: Omar Sandoval <osandov@fb.com>
    Signed-off-by: Jens Axboe <axboe@kernel.dk>

diff --git a/drivers/scsi/ufs/ufs_bsg.c b/drivers/scsi/ufs/ufs_bsg.c
index e5f8e54bf644..dd0e9700a74c 100644
--- a/drivers/scsi/ufs/ufs_bsg.c
+++ b/drivers/scsi/ufs/ufs_bsg.c
@@ -193,7 +193,7 @@ int ufs_bsg_probe(struct ufs_hba *hba)
 	if (ret)
 		goto out;
 
-	q = bsg_setup_queue(bsg_dev, dev_name(bsg_dev), ufs_bsg_request, 0);
+	q = bsg_setup_queue(bsg_dev, dev_name(bsg_dev), ufs_bsg_request, NULL, 0);
 	if (IS_ERR(q)) {
 		ret = PTR_ERR(q);
 		goto out;

commit e77044c5a8422e4e139f0a2ac5d49f4075779594
Author: Avri Altman <avri.altman@wdc.com>
Date:   Sun Oct 7 17:30:39 2018 +0300

    scsi: ufs-bsg: Add support for uic commands in ufs_bsg_request()
    
    Make ufshcd_send_uic_cmd() public for that.
    
    Signed-off-by: Avri Altman <avri.altman@wdc.com>
    Reviewed-by: Christoph Hellwig <hch@lst.de>
    Reviewed-by: Bart Van Assche <Bart.VanAssche@wdc.com>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/ufs/ufs_bsg.c b/drivers/scsi/ufs/ufs_bsg.c
index 306e5f11a818..e5f8e54bf644 100644
--- a/drivers/scsi/ufs/ufs_bsg.c
+++ b/drivers/scsi/ufs/ufs_bsg.c
@@ -84,6 +84,7 @@ static int ufs_bsg_request(struct bsg_job *job)
 	struct ufs_hba *hba = shost_priv(dev_to_shost(job->dev->parent));
 	unsigned int req_len = job->request_len;
 	unsigned int reply_len = job->reply_len;
+	struct uic_command uc = {};
 	int msgcode;
 	uint8_t *desc_buff = NULL;
 	int desc_len = 0;
@@ -116,6 +117,16 @@ static int ufs_bsg_request(struct bsg_job *job)
 			dev_err(hba->dev,
 				"exe raw upiu: error code %d\n", ret);
 
+		break;
+	case UPIU_TRANSACTION_UIC_CMD:
+		memcpy(&uc, &bsg_request->upiu_req.uc, UIC_CMD_SIZE);
+		ret = ufshcd_send_uic_cmd(hba, &uc);
+		if (ret)
+			dev_dbg(hba->dev,
+				"send uic cmd: error code %d\n", ret);
+
+		memcpy(&bsg_reply->upiu_rsp.uc, &uc, UIC_CMD_SIZE);
+
 		break;
 	default:
 		ret = -ENOTSUPP;

commit 95e34bf930eaee51dab23495342b148cd0ee2ba1
Author: Avri Altman <avri.altman@wdc.com>
Date:   Sun Oct 7 17:30:38 2018 +0300

    scsi: ufs-bsg: Add support for raw upiu in ufs_bsg_request()
    
    Do that for the currently supported UPIUs: query, nop out, and task
    management.
    
    We do not support UPIU of type scsi command yet, while we are using the
    job's request and reply pointers to hold the payload.  We will look into
    it in later patches. We might need to elaborate the raw upiu api for
    that.
    
    We also still not supporting uic commands: For first phase, we plan to
    use the existing api, and send only uic commands that are already
    supported. Anyway, all that will come in the next patch.
    
    Signed-off-by: Avri Altman <avri.altman@wdc.com>
    Reviewed-by: Christoph Hellwig <hch@lst.de>
    Reviewed-by: Bart Van Assche <Bart.VanAssche@wdc.com>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/ufs/ufs_bsg.c b/drivers/scsi/ufs/ufs_bsg.c
index 1036c520d349..306e5f11a818 100644
--- a/drivers/scsi/ufs/ufs_bsg.c
+++ b/drivers/scsi/ufs/ufs_bsg.c
@@ -6,19 +6,125 @@
  */
 #include "ufs_bsg.h"
 
+static int ufs_bsg_get_query_desc_size(struct ufs_hba *hba, int *desc_len,
+				       struct utp_upiu_query *qr)
+{
+	int desc_size = be16_to_cpu(qr->length);
+	int desc_id = qr->idn;
+	int ret;
+
+	if (desc_size <= 0)
+		return -EINVAL;
+
+	ret = ufshcd_map_desc_id_to_length(hba, desc_id, desc_len);
+	if (ret || !*desc_len)
+		return -EINVAL;
+
+	*desc_len = min_t(int, *desc_len, desc_size);
+
+	return 0;
+}
+
+static int ufs_bsg_verify_query_size(struct ufs_hba *hba,
+				     unsigned int request_len,
+				     unsigned int reply_len,
+				     int desc_len, enum query_opcode desc_op)
+{
+	int min_req_len = sizeof(struct ufs_bsg_request);
+	int min_rsp_len = sizeof(struct ufs_bsg_reply);
+
+	if (desc_op == UPIU_QUERY_OPCODE_WRITE_DESC)
+		min_req_len += desc_len;
+
+	if (min_req_len > request_len || min_rsp_len > reply_len) {
+		dev_err(hba->dev, "not enough space assigned\n");
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static int ufs_bsg_verify_query_params(struct ufs_hba *hba,
+				       struct ufs_bsg_request *bsg_request,
+				       unsigned int request_len,
+				       unsigned int reply_len,
+				       uint8_t *desc_buff, int *desc_len,
+				       enum query_opcode desc_op)
+{
+	struct utp_upiu_query *qr;
+
+	if (desc_op == UPIU_QUERY_OPCODE_READ_DESC) {
+		dev_err(hba->dev, "unsupported opcode %d\n", desc_op);
+		return -ENOTSUPP;
+	}
+
+	if (desc_op != UPIU_QUERY_OPCODE_WRITE_DESC)
+		goto out;
+
+	qr = &bsg_request->upiu_req.qr;
+	if (ufs_bsg_get_query_desc_size(hba, desc_len, qr)) {
+		dev_err(hba->dev, "Illegal desc size\n");
+		return -EINVAL;
+	}
+
+	if (ufs_bsg_verify_query_size(hba, request_len, reply_len, *desc_len,
+				      desc_op))
+		return -EINVAL;
+
+	desc_buff = (uint8_t *)(bsg_request + 1);
+
+out:
+	return 0;
+}
 
 static int ufs_bsg_request(struct bsg_job *job)
 {
 	struct ufs_bsg_request *bsg_request = job->request;
 	struct ufs_bsg_reply *bsg_reply = job->reply;
-	int ret = -ENOTSUPP;
+	struct ufs_hba *hba = shost_priv(dev_to_shost(job->dev->parent));
+	unsigned int req_len = job->request_len;
+	unsigned int reply_len = job->reply_len;
+	int msgcode;
+	uint8_t *desc_buff = NULL;
+	int desc_len = 0;
+	enum query_opcode desc_op = UPIU_QUERY_OPCODE_NOP;
+	int ret;
+
+	ret = ufs_bsg_verify_query_size(hba, req_len, reply_len, 0, desc_op);
+	if (ret)
+		goto out;
 
 	bsg_reply->reply_payload_rcv_len = 0;
 
-	/* Do Nothing for now */
-	dev_err(job->dev, "unsupported message_code 0x%x\n",
-		bsg_request->msgcode);
+	msgcode = bsg_request->msgcode;
+	switch (msgcode) {
+	case UPIU_TRANSACTION_QUERY_REQ:
+		desc_op = bsg_request->upiu_req.qr.opcode;
+		ret = ufs_bsg_verify_query_params(hba, bsg_request, req_len,
+						  reply_len, desc_buff,
+						  &desc_len, desc_op);
+		if (ret)
+			goto out;
+
+		/* fall through */
+	case UPIU_TRANSACTION_NOP_OUT:
+	case UPIU_TRANSACTION_TASK_REQ:
+		ret = ufshcd_exec_raw_upiu_cmd(hba, &bsg_request->upiu_req,
+					       &bsg_reply->upiu_rsp, msgcode,
+					       desc_buff, &desc_len, desc_op);
+		if (ret)
+			dev_err(hba->dev,
+				"exe raw upiu: error code %d\n", ret);
+
+		break;
+	default:
+		ret = -ENOTSUPP;
+		dev_err(hba->dev, "unsupported msgcode 0x%x\n", msgcode);
+
+		break;
+	}
 
+out:
 	bsg_reply->result = ret;
 	job->reply_len = sizeof(struct ufs_bsg_reply) +
 			 bsg_reply->reply_payload_rcv_len;

commit df032bf27a414acf61c957ec2fad22a57d903b39
Author: Avri Altman <avri.altman@wdc.com>
Date:   Sun Oct 7 17:30:35 2018 +0300

    scsi: ufs: Add a bsg endpoint that supports UPIUs
    
    For now, just provide an API to allocate and remove ufs-bsg node. We
    will use this framework to manage ufs devices by sending UPIU
    transactions.
    
    For the time being, implements an empty bsg_request() - will add some
    more functionality in coming patches.
    
    Nonetheless, we reveal here the protocol we are planning to use: UFS
    Transport Protocol Transactions. UFS transactions consist of packets
    called UFS Protocol Information Units (UPIU).
    
    There are UPIUâ€™s defined for UFS SCSI commands, responses, data in and
    data out, task management, utility functions, vendor functions,
    transaction synchronization and control, and more.
    
    By using UPIUs, we get access to the most fine-grained internals of this
    protocol, and able to communicate with the device in ways, that are
    sometimes beyond the capacity of the ufs driver.
    
    Moreover and as a result, our core structure - ufs_bsg_node has a pretty
    lean structure: using upiu transactions that contains the outmost
    detailed info, so we don't really need complex constructs to support it.
    
    Signed-off-by: Avri Altman <avri.altman@wdc.com>
    Reviewed-by: Christoph Hellwig <hch@lst.de>
    Reviewed-by: Bart Van Assche <Bart.VanAssche@wdc.com>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/ufs/ufs_bsg.c b/drivers/scsi/ufs/ufs_bsg.c
new file mode 100644
index 000000000000..1036c520d349
--- /dev/null
+++ b/drivers/scsi/ufs/ufs_bsg.c
@@ -0,0 +1,93 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * bsg endpoint that supports UPIUs
+ *
+ * Copyright (C) 2018 Western Digital Corporation
+ */
+#include "ufs_bsg.h"
+
+
+static int ufs_bsg_request(struct bsg_job *job)
+{
+	struct ufs_bsg_request *bsg_request = job->request;
+	struct ufs_bsg_reply *bsg_reply = job->reply;
+	int ret = -ENOTSUPP;
+
+	bsg_reply->reply_payload_rcv_len = 0;
+
+	/* Do Nothing for now */
+	dev_err(job->dev, "unsupported message_code 0x%x\n",
+		bsg_request->msgcode);
+
+	bsg_reply->result = ret;
+	job->reply_len = sizeof(struct ufs_bsg_reply) +
+			 bsg_reply->reply_payload_rcv_len;
+
+	bsg_job_done(job, ret, bsg_reply->reply_payload_rcv_len);
+
+	return ret;
+}
+
+/**
+ * ufs_bsg_remove - detach and remove the added ufs-bsg node
+ *
+ * Should be called when unloading the driver.
+ */
+void ufs_bsg_remove(struct ufs_hba *hba)
+{
+	struct device *bsg_dev = &hba->bsg_dev;
+
+	if (!hba->bsg_queue)
+		return;
+
+	bsg_unregister_queue(hba->bsg_queue);
+
+	device_del(bsg_dev);
+	put_device(bsg_dev);
+}
+
+static inline void ufs_bsg_node_release(struct device *dev)
+{
+	put_device(dev->parent);
+}
+
+/**
+ * ufs_bsg_probe - Add ufs bsg device node
+ * @hba: per adapter object
+ *
+ * Called during initial loading of the driver, and before scsi_scan_host.
+ */
+int ufs_bsg_probe(struct ufs_hba *hba)
+{
+	struct device *bsg_dev = &hba->bsg_dev;
+	struct Scsi_Host *shost = hba->host;
+	struct device *parent = &shost->shost_gendev;
+	struct request_queue *q;
+	int ret;
+
+	device_initialize(bsg_dev);
+
+	bsg_dev->parent = get_device(parent);
+	bsg_dev->release = ufs_bsg_node_release;
+
+	dev_set_name(bsg_dev, "ufs-bsg");
+
+	ret = device_add(bsg_dev);
+	if (ret)
+		goto out;
+
+	q = bsg_setup_queue(bsg_dev, dev_name(bsg_dev), ufs_bsg_request, 0);
+	if (IS_ERR(q)) {
+		ret = PTR_ERR(q);
+		goto out;
+	}
+
+	hba->bsg_queue = q;
+
+	return 0;
+
+out:
+	dev_err(bsg_dev, "fail to initialize a bsg dev %d\n", shost->host_no);
+	put_device(bsg_dev);
+	return ret;
+}
