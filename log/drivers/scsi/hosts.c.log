commit dcece99e86b1191d2789fb5b5caa4c5b7fc2bfef
Author: Hannes Reinecke <hare@suse.de>
Date:   Fri Feb 28 08:53:15 2020 +0100

    scsi: core: add scsi_host_busy_iter()
    
    Add an iterator scsi_host_busy_iter() to traverse all busy commands.  If
    locking against concurrent command completions is required, it has to be
    provided by the caller.
    
    Link: https://lore.kernel.org/r/20200228075318.91255-11-hare@suse.de
    Signed-off-by: Hannes Reinecke <hare@suse.de>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/hosts.c b/drivers/scsi/hosts.c
index 00ae9d43ce9f..7ec91c3a66ca 100644
--- a/drivers/scsi/hosts.c
+++ b/drivers/scsi/hosts.c
@@ -678,3 +678,40 @@ void scsi_host_complete_all_commands(struct Scsi_Host *shost, int status)
 				&status);
 }
 EXPORT_SYMBOL_GPL(scsi_host_complete_all_commands);
+
+struct scsi_host_busy_iter_data {
+	bool (*fn)(struct scsi_cmnd *, void *, bool);
+	void *priv;
+};
+
+static bool __scsi_host_busy_iter_fn(struct request *req, void *priv,
+				   bool reserved)
+{
+	struct scsi_host_busy_iter_data *iter_data = priv;
+	struct scsi_cmnd *sc = blk_mq_rq_to_pdu(req);
+
+	return iter_data->fn(sc, iter_data->priv, reserved);
+}
+
+/**
+ * scsi_host_busy_iter - Iterate over all busy commands
+ * @shost:	Pointer to Scsi_Host.
+ * @fn:		Function to call on each busy command
+ * @priv:	Data pointer passed to @fn
+ *
+ * If locking against concurrent command completions is required
+ * ithas to be provided by the caller
+ **/
+void scsi_host_busy_iter(struct Scsi_Host *shost,
+			 bool (*fn)(struct scsi_cmnd *, void *, bool),
+			 void *priv)
+{
+	struct scsi_host_busy_iter_data iter_data = {
+		.fn = fn,
+		.priv = priv,
+	};
+
+	blk_mq_tagset_busy_iter(&shost->tag_set, __scsi_host_busy_iter_fn,
+				&iter_data);
+}
+EXPORT_SYMBOL_GPL(scsi_host_busy_iter);

commit 466552b9f3730f06fee75776a208f5fa9c06c6a3
Author: Hannes Reinecke <hare@suse.de>
Date:   Fri Feb 28 08:53:07 2020 +0100

    scsi: core: add scsi_host_complete_all_commands() helper
    
    Add a helper scsi_host_complete_all_commands() to terminate all outstanding
    commands on a SCSI host.
    
    Link: https://lore.kernel.org/r/20200228075318.91255-3-hare@suse.de
    Signed-off-by: Hannes Reinecke <hare@suse.de>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/hosts.c b/drivers/scsi/hosts.c
index 1d669e47b692..00ae9d43ce9f 100644
--- a/drivers/scsi/hosts.c
+++ b/drivers/scsi/hosts.c
@@ -650,3 +650,31 @@ void scsi_flush_work(struct Scsi_Host *shost)
 	flush_workqueue(shost->work_q);
 }
 EXPORT_SYMBOL_GPL(scsi_flush_work);
+
+static bool complete_all_cmds_iter(struct request *rq, void *data, bool rsvd)
+{
+	struct scsi_cmnd *scmd = blk_mq_rq_to_pdu(rq);
+	int status = *(int *)data;
+
+	scsi_dma_unmap(scmd);
+	scmd->result = status << 16;
+	scmd->scsi_done(scmd);
+	return true;
+}
+
+/**
+ * scsi_host_complete_all_commands - Terminate all running commands
+ * @shost:	Scsi Host on which commands should be terminated
+ * @status:	Status to be set for the terminated commands
+ *
+ * There is no protection against modification of the number
+ * of outstanding commands. It is the responsibility of the
+ * caller to ensure that concurrent I/O submission and/or
+ * completion is stopped when calling this function.
+ */
+void scsi_host_complete_all_commands(struct Scsi_Host *shost, int status)
+{
+	blk_mq_tagset_busy_iter(&shost->tag_set, complete_all_cmds_iter,
+				&status);
+}
+EXPORT_SYMBOL_GPL(scsi_host_complete_all_commands);

commit 6eb045e092efefafc6687409a6fa6d1dabf0fb69
Author: Ming Lei <ming.lei@redhat.com>
Date:   Fri Oct 25 14:58:55 2019 +0800

    scsi: core: avoid host-wide host_busy counter for scsi_mq
    
    It isn't necessary to check the host depth in scsi_queue_rq() any more
    since it has been respected by blk-mq before calling scsi_queue_rq() via
    getting driver tag.
    
    Lots of LUNs may attach to same host and per-host IOPS may reach millions,
    so we should avoid expensive atomic operations on the host-wide counter in
    the IO path.
    
    This patch implements scsi_host_busy() via blk_mq_tagset_busy_iter() with
    one scsi command state for reading the count of busy IOs for scsi_mq.
    
    It is observed that IOPS is increased by 15% in IO test on scsi_debug (32
    LUNs, 32 submit queues, 1024 can_queue, libaio/dio) in a dual-socket
    system.
    
    Cc: Jens Axboe <axboe@kernel.dk>
    Cc: Ewan D. Milne <emilne@redhat.com>
    Cc: Omar Sandoval <osandov@fb.com>,
    Cc: "Martin K. Petersen" <martin.petersen@oracle.com>,
    Cc: James Bottomley <james.bottomley@hansenpartnership.com>,
    Cc: Christoph Hellwig <hch@lst.de>,
    Cc: Kashyap Desai <kashyap.desai@broadcom.com>
    Cc: Hannes Reinecke <hare@suse.de>
    Cc: Laurence Oberman <loberman@redhat.com>
    Cc: Bart Van Assche <bvanassche@acm.org>
    Link: https://lore.kernel.org/r/20191025065855.6309-1-ming.lei@redhat.com
    Signed-off-by: Ming Lei <ming.lei@redhat.com>
    Reviewed-by: Jens Axboe <axboe@kernel.dk>
    Reviewed-by: Bart Van Assche <bvanassche@acm.org>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/hosts.c b/drivers/scsi/hosts.c
index 55522b7162d3..1d669e47b692 100644
--- a/drivers/scsi/hosts.c
+++ b/drivers/scsi/hosts.c
@@ -38,6 +38,7 @@
 #include <scsi/scsi_device.h>
 #include <scsi/scsi_host.h>
 #include <scsi/scsi_transport.h>
+#include <scsi/scsi_cmnd.h>
 
 #include "scsi_priv.h"
 #include "scsi_logging.h"
@@ -554,13 +555,29 @@ struct Scsi_Host *scsi_host_get(struct Scsi_Host *shost)
 }
 EXPORT_SYMBOL(scsi_host_get);
 
+static bool scsi_host_check_in_flight(struct request *rq, void *data,
+				      bool reserved)
+{
+	int *count = data;
+	struct scsi_cmnd *cmd = blk_mq_rq_to_pdu(rq);
+
+	if (test_bit(SCMD_STATE_INFLIGHT, &cmd->state))
+		(*count)++;
+
+	return true;
+}
+
 /**
  * scsi_host_busy - Return the host busy counter
  * @shost:	Pointer to Scsi_Host to inc.
  **/
 int scsi_host_busy(struct Scsi_Host *shost)
 {
-	return atomic_read(&shost->host_busy);
+	int cnt = 0;
+
+	blk_mq_tagset_busy_iter(&shost->tag_set,
+				scsi_host_check_in_flight, &cnt);
+	return cnt;
 }
 EXPORT_SYMBOL(scsi_host_busy);
 

commit f65420df914a85e33b2c8b1cab310858b2abb7c0
Merge: 168c79971b4a 07d9aa143464
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sat Jul 20 10:04:58 2019 -0700

    Merge tag 'scsi-fixes' of git://git.kernel.org/pub/scm/linux/kernel/git/jejb/scsi
    
    Pull SCSI fixes from James Bottomley:
     "This is the final round of mostly small fixes in our initial submit.
    
      It's mostly minor fixes and driver updates. The only change of note is
      adding a virt_boundary_mask to the SCSI host and host template to
      parametrise this for NVMe devices instead of having them do a call in
      slave_alloc. It's a fairly straightforward conversion except in the
      two NVMe handling drivers that didn't set it who now have a virtual
      infinity parameter added"
    
    * tag 'scsi-fixes' of git://git.kernel.org/pub/scm/linux/kernel/git/jejb/scsi: (24 commits)
      scsi: megaraid_sas: set an unlimited max_segment_size
      scsi: mpt3sas: set an unlimited max_segment_size for SAS 3.0 HBAs
      scsi: IB/srp: set virt_boundary_mask in the scsi host
      scsi: IB/iser: set virt_boundary_mask in the scsi host
      scsi: storvsc: set virt_boundary_mask in the scsi host template
      scsi: ufshcd: set max_segment_size in the scsi host template
      scsi: core: take the DMA max mapping size into account
      scsi: core: add a host / host template field for the virt boundary
      scsi: core: Fix race on creating sense cache
      scsi: sd_zbc: Fix compilation warning
      scsi: libfc: fix null pointer dereference on a null lport
      scsi: zfcp: fix GCC compiler warning emitted with -Wmaybe-uninitialized
      scsi: zfcp: fix request object use-after-free in send path causing wrong traces
      scsi: zfcp: fix request object use-after-free in send path causing seqno errors
      scsi: megaraid_sas: Update driver version to 07.710.50.00
      scsi: megaraid_sas: Add module parameter for FW Async event logging
      scsi: megaraid_sas: Enable msix_load_balance for Invader and later controllers
      scsi: megaraid_sas: Fix calculation of target ID
      scsi: lpfc: reduce stack size with CONFIG_GCC_PLUGIN_STRUCTLEAK_VERBOSE
      scsi: devinfo: BLIST_TRY_VPD_PAGES for SanDisk Cruzer Blade
      ...

commit 7ad388d8e4c703980b7018b938cdeec58832d78d
Author: Christoph Hellwig <hch@lst.de>
Date:   Mon Jun 17 14:19:53 2019 +0200

    scsi: core: add a host / host template field for the virt boundary
    
    This allows drivers setting it up easily instead of branching out to block
    layer calls in slave_alloc, and ensures the upgraded max_segment_size
    setting gets picked up by the DMA layer.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Acked-by: Kashyap Desai < kashyap.desai@broadcom.com>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/hosts.c b/drivers/scsi/hosts.c
index 96ed24841c33..f98509d717a0 100644
--- a/drivers/scsi/hosts.c
+++ b/drivers/scsi/hosts.c
@@ -462,6 +462,9 @@ struct Scsi_Host *scsi_host_alloc(struct scsi_host_template *sht, int privsize)
 	else
 		shost->dma_boundary = 0xffffffff;
 
+	if (sht->virt_boundary_mask)
+		shost->virt_boundary_mask = sht->virt_boundary_mask;
+
 	device_initialize(&shost->shost_gendev);
 	dev_set_name(&shost->shost_gendev, "host%d", shost->host_no);
 	shost->shost_gendev.bus = &scsi_bus_type;

commit 026104bfa591709689e12434c1bb3b485bf5bfa0
Author: Christoph Hellwig <hch@lst.de>
Date:   Wed May 1 12:13:54 2019 -0400

    scsi: core: add SPDX tags to scsi midlayer files missing licensing information
    
    Add the default kernel GPLv2 annotation to SCSI midlayer files missing any
    licensing information.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Reviewed-by: Hannes Reinecke <hare@suse.com>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/hosts.c b/drivers/scsi/hosts.c
index eaf329db3973..96ed24841c33 100644
--- a/drivers/scsi/hosts.c
+++ b/drivers/scsi/hosts.c
@@ -1,3 +1,4 @@
+// SPDX-License-Identifier: GPL-2.0
 /*
  *  hosts.c Copyright (C) 1992 Drew Eckhardt
  *          Copyright (C) 1993, 1994, 1995 Eric Youngdale

commit 457c89965399115e5cd8bf38f9c597293405703d
Author: Thomas Gleixner <tglx@linutronix.de>
Date:   Sun May 19 13:08:55 2019 +0100

    treewide: Add SPDX license identifier for missed files
    
    Add SPDX license identifiers to all files which:
    
     - Have no license information of any form
    
     - Have EXPORT_.*_SYMBOL_GPL inside which was used in the
       initial scan/conversion to ignore the file
    
    These files fall under the project license, GPL v2 only. The resulting SPDX
    license identifier is:
    
      GPL-2.0-only
    
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/scsi/hosts.c b/drivers/scsi/hosts.c
index eaf329db3973..ff0d8c6a8d0c 100644
--- a/drivers/scsi/hosts.c
+++ b/drivers/scsi/hosts.c
@@ -1,3 +1,4 @@
+// SPDX-License-Identifier: GPL-2.0-only
 /*
  *  hosts.c Copyright (C) 1992 Drew Eckhardt
  *          Copyright (C) 1993, 1994, 1995 Eric Youngdale

commit 938edb8a31b976c9a92eb0cd4ff481e93f76c1f1
Merge: af7ddd8a627c da7903092b88
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Fri Dec 28 14:48:06 2018 -0800

    Merge tag 'scsi-misc' of git://git.kernel.org/pub/scm/linux/kernel/git/jejb/scsi
    
    Pull SCSI updates from James Bottomley:
     "This is mostly update of the usual drivers: smarpqi, lpfc, qedi,
      megaraid_sas, libsas, zfcp, mpt3sas, hisi_sas.
    
      Additionally, we have a pile of annotation, unused variable and minor
      updates.
    
      The big API change is the updates for Christoph's DMA rework which
      include removing the DISABLE_CLUSTERING flag.
    
      And finally there are a couple of target tree updates"
    
    * tag 'scsi-misc' of git://git.kernel.org/pub/scm/linux/kernel/git/jejb/scsi: (259 commits)
      scsi: isci: request: mark expected switch fall-through
      scsi: isci: remote_node_context: mark expected switch fall-throughs
      scsi: isci: remote_device: Mark expected switch fall-throughs
      scsi: isci: phy: Mark expected switch fall-through
      scsi: iscsi: Capture iscsi debug messages using tracepoints
      scsi: myrb: Mark expected switch fall-throughs
      scsi: megaraid: fix out-of-bound array accesses
      scsi: mpt3sas: mpt3sas_scsih: Mark expected switch fall-through
      scsi: fcoe: remove set but not used variable 'port'
      scsi: smartpqi: call pqi_free_interrupts() in pqi_shutdown()
      scsi: smartpqi: fix build warnings
      scsi: smartpqi: update driver version
      scsi: smartpqi: add ofa support
      scsi: smartpqi: increase fw status register read timeout
      scsi: smartpqi: bump driver version
      scsi: smartpqi: add smp_utils support
      scsi: smartpqi: correct lun reset issues
      scsi: smartpqi: correct volume status
      scsi: smartpqi: do not offline disks for transient did no connect conditions
      scsi: smartpqi: allow for larger raid maps
      ...

commit 4af14d113bcf95c12d1462ba623b7e7117bd3fb3
Author: Christoph Hellwig <hch@lst.de>
Date:   Thu Dec 13 16:17:09 2018 +0100

    scsi: remove the use_clustering flag
    
    The same effects can be achieved by setting the dma_boundary to
    PAGE_SIZE - 1 and the max_segment_size to PAGE_SIZE, so shift those
    settings into the drivers.  Note that in many cases the setting might
    be bogus, but this keeps the status quo.
    
    [mkp: fix myrs and myrb]
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/hosts.c b/drivers/scsi/hosts.c
index e8148ba414a3..fce0b5d7119e 100644
--- a/drivers/scsi/hosts.c
+++ b/drivers/scsi/hosts.c
@@ -431,7 +431,6 @@ struct Scsi_Host *scsi_host_alloc(struct scsi_host_template *sht, int privsize)
 	shost->sg_prot_tablesize = sht->sg_prot_tablesize;
 	shost->cmd_per_lun = sht->cmd_per_lun;
 	shost->unchecked_isa_dma = sht->unchecked_isa_dma;
-	shost->use_clustering = sht->use_clustering;
 	shost->no_write_same = sht->no_write_same;
 
 	if (shost_eh_deadline == -1 || !sht->eh_host_reset_handler)

commit 50c2e9107f176a82e14567b39c5d0f2a208cc82c
Author: Christoph Hellwig <hch@lst.de>
Date:   Thu Dec 13 16:17:03 2018 +0100

    scsi: introduce a max_segment_size host_template parameters
    
    This allows the host driver to indicate the maximum supported
    segment size in a nice an easy way, so that the driver doesn't
    have to worry about DMA-layer imposed limitations.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Reviewed-by: Bart Van Assche <bvanassche@acm.org>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/hosts.c b/drivers/scsi/hosts.c
index ea4b0bb0c1cd..e8148ba414a3 100644
--- a/drivers/scsi/hosts.c
+++ b/drivers/scsi/hosts.c
@@ -464,6 +464,11 @@ struct Scsi_Host *scsi_host_alloc(struct scsi_host_template *sht, int privsize)
 	else
 		shost->max_sectors = SCSI_DEFAULT_MAX_SECTORS;
 
+	if (sht->max_segment_size)
+		shost->max_segment_size = sht->max_segment_size;
+	else
+		shost->max_segment_size = BLK_MAX_SEGMENT_SIZE;
+
 	/*
 	 * assume a 4GB boundary, if not set
 	 */

commit f664a3cc17b7d0a2bc3b3ab96181e1029b0ec0e6
Author: Jens Axboe <axboe@kernel.dk>
Date:   Thu Nov 1 16:36:27 2018 -0600

    scsi: kill off the legacy IO path
    
    This removes the legacy (non-mq) IO path for SCSI.
    
    Cc: linux-scsi@vger.kernel.org
    Acked-by: Himanshu Madhani <himanshu.madhani@cavium.com>
    Reviewed-by: Hannes Reinecke <hare@suse.com>
    Tested-by: Ming Lei <ming.lei@redhat.com>
    Reviewed-by: Omar Sandoval <osandov@fb.com>
    Acked-by: Martin K. Petersen <martin.petersen@oracle.com>
    Signed-off-by: Jens Axboe <axboe@kernel.dk>

diff --git a/drivers/scsi/hosts.c b/drivers/scsi/hosts.c
index ea4b0bb0c1cd..cc71136ba300 100644
--- a/drivers/scsi/hosts.c
+++ b/drivers/scsi/hosts.c
@@ -222,18 +222,9 @@ int scsi_add_host_with_dma(struct Scsi_Host *shost, struct device *dev,
 	if (error)
 		goto fail;
 
-	if (shost_use_blk_mq(shost)) {
-		error = scsi_mq_setup_tags(shost);
-		if (error)
-			goto fail;
-	} else {
-		shost->bqt = blk_init_tags(shost->can_queue,
-				shost->hostt->tag_alloc_policy);
-		if (!shost->bqt) {
-			error = -ENOMEM;
-			goto fail;
-		}
-	}
+	error = scsi_mq_setup_tags(shost);
+	if (error)
+		goto fail;
 
 	if (!shost->shost_gendev.parent)
 		shost->shost_gendev.parent = dev ? dev : &platform_bus;
@@ -309,8 +300,7 @@ int scsi_add_host_with_dma(struct Scsi_Host *shost, struct device *dev,
 	pm_runtime_disable(&shost->shost_gendev);
 	pm_runtime_set_suspended(&shost->shost_gendev);
 	pm_runtime_put_noidle(&shost->shost_gendev);
-	if (shost_use_blk_mq(shost))
-		scsi_mq_destroy_tags(shost);
+	scsi_mq_destroy_tags(shost);
  fail:
 	return error;
 }
@@ -344,13 +334,8 @@ static void scsi_host_dev_release(struct device *dev)
 		kfree(dev_name(&shost->shost_dev));
 	}
 
-	if (shost_use_blk_mq(shost)) {
-		if (shost->tag_set.tags)
-			scsi_mq_destroy_tags(shost);
-	} else {
-		if (shost->bqt)
-			blk_free_tags(shost->bqt);
-	}
+	if (shost->tag_set.tags)
+		scsi_mq_destroy_tags(shost);
 
 	kfree(shost->shost_data);
 
@@ -472,8 +457,6 @@ struct Scsi_Host *scsi_host_alloc(struct scsi_host_template *sht, int privsize)
 	else
 		shost->dma_boundary = 0xffffffff;
 
-	shost->use_blk_mq = scsi_use_blk_mq || shost->hostt->force_blk_mq;
-
 	device_initialize(&shost->shost_gendev);
 	dev_set_name(&shost->shost_gendev, "host%d", shost->host_no);
 	shost->shost_gendev.bus = &scsi_bus_type;

commit d772a65d8a6c45c376a8200a38f7f82fb480af6a
Author: Ming Lei <ming.lei@redhat.com>
Date:   Mon Aug 27 15:24:43 2018 +0800

    Revert "scsi: core: avoid host-wide host_busy counter for scsi_mq"
    
    This reverts commit 328728630d9f2bf14b82ca30b5e47489beefe361.
    
    There is fundamental issue in commit 328728630d9f2bf1 (scsi: core: avoid
    host-wide host_busy counter for scsi_mq) because SCSI's host busy counter
    may not be same with counter of blk-mq's inflight tags, especially in case
    of none io scheduler.
    
    We may switch to other approach for addressing this scsi_mq's performance
    issue, such as percpu counter or kind of ways, so revert this commit first
    for fixing this kind of issue in EH path, as reported by Jens.
    
    Cc: Omar Sandoval <osandov@fb.com>,
    Cc: "Martin K. Petersen" <martin.petersen@oracle.com>,
    Cc: James Bottomley <james.bottomley@hansenpartnership.com>,
    Cc: Christoph Hellwig <hch@lst.de>,
    Cc: Don Brace <don.brace@microsemi.com>
    Cc: Kashyap Desai <kashyap.desai@broadcom.com>
    Cc: Mike Snitzer <snitzer@redhat.com>
    Cc: Hannes Reinecke <hare@suse.de>
    Cc: Laurence Oberman <loberman@redhat.com>
    Cc: Bart Van Assche <bart.vanassche@wdc.com>
    Cc: Jens Axboe <axboe@kernel.dk>
    Reported-by: Jens Axboe <axboe@kernel.dk>
    Signed-off-by: Ming Lei <ming.lei@redhat.com>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/hosts.c b/drivers/scsi/hosts.c
index f02dcc875a09..ea4b0bb0c1cd 100644
--- a/drivers/scsi/hosts.c
+++ b/drivers/scsi/hosts.c
@@ -563,35 +563,13 @@ struct Scsi_Host *scsi_host_get(struct Scsi_Host *shost)
 }
 EXPORT_SYMBOL(scsi_host_get);
 
-struct scsi_host_mq_in_flight {
-	int cnt;
-};
-
-static void scsi_host_check_in_flight(struct request *rq, void *data,
-		bool reserved)
-{
-	struct scsi_host_mq_in_flight *in_flight = data;
-
-	if (blk_mq_request_started(rq))
-		in_flight->cnt++;
-}
-
 /**
  * scsi_host_busy - Return the host busy counter
  * @shost:	Pointer to Scsi_Host to inc.
  **/
 int scsi_host_busy(struct Scsi_Host *shost)
 {
-	struct scsi_host_mq_in_flight in_flight = {
-		.cnt = 0,
-	};
-
-	if (!shost->use_blk_mq)
-		return atomic_read(&shost->host_busy);
-
-	blk_mq_tagset_busy_iter(&shost->tag_set, scsi_host_check_in_flight,
-			&in_flight);
-	return in_flight.cnt;
+	return atomic_read(&shost->host_busy);
 }
 EXPORT_SYMBOL(scsi_host_busy);
 

commit 328728630d9f2bf14b82ca30b5e47489beefe361
Author: Ming Lei <ming.lei@redhat.com>
Date:   Sun Jun 24 22:03:27 2018 +0800

    scsi: core: avoid host-wide host_busy counter for scsi_mq
    
    It isn't necessary to check the host depth in scsi_queue_rq() any more
    since it has been respected by blk-mq before calling scsi_queue_rq() via
    getting driver tag.
    
    Lots of LUNs may attach to same host and per-host IOPS may reach millions,
    so we should avoid expensive atomic operations on the host-wide counter in
    the IO path.
    
    This patch implements scsi_host_busy() via blk_mq_tagset_busy_iter() for
    reading the count of busy IOs for scsi_mq.
    
    It is observed that IOPS is increased by 15% in IO test on scsi_debug (32
    LUNs, 32 submit queues, 1024 can_queue, libaio/dio) in a dual-socket
    system.
    
    [mkp: clarified commit message]
    
    Cc: Omar Sandoval <osandov@fb.com>,
    Cc: "Martin K. Petersen" <martin.petersen@oracle.com>,
    Cc: James Bottomley <james.bottomley@hansenpartnership.com>,
    Cc: Christoph Hellwig <hch@lst.de>,
    Cc: Don Brace <don.brace@microsemi.com>
    Cc: Kashyap Desai <kashyap.desai@broadcom.com>
    Cc: Mike Snitzer <snitzer@redhat.com>
    Cc: Hannes Reinecke <hare@suse.de>
    Cc: Laurence Oberman <loberman@redhat.com>
    Cc: Bart Van Assche <bart.vanassche@wdc.com>
    Signed-off-by: Ming Lei <ming.lei@redhat.com>
    Reviewed-by: Bart Van Assche <bart.vanassche@wdc.com>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/hosts.c b/drivers/scsi/hosts.c
index ea4b0bb0c1cd..f02dcc875a09 100644
--- a/drivers/scsi/hosts.c
+++ b/drivers/scsi/hosts.c
@@ -563,13 +563,35 @@ struct Scsi_Host *scsi_host_get(struct Scsi_Host *shost)
 }
 EXPORT_SYMBOL(scsi_host_get);
 
+struct scsi_host_mq_in_flight {
+	int cnt;
+};
+
+static void scsi_host_check_in_flight(struct request *rq, void *data,
+		bool reserved)
+{
+	struct scsi_host_mq_in_flight *in_flight = data;
+
+	if (blk_mq_request_started(rq))
+		in_flight->cnt++;
+}
+
 /**
  * scsi_host_busy - Return the host busy counter
  * @shost:	Pointer to Scsi_Host to inc.
  **/
 int scsi_host_busy(struct Scsi_Host *shost)
 {
-	return atomic_read(&shost->host_busy);
+	struct scsi_host_mq_in_flight in_flight = {
+		.cnt = 0,
+	};
+
+	if (!shost->use_blk_mq)
+		return atomic_read(&shost->host_busy);
+
+	blk_mq_tagset_busy_iter(&shost->tag_set, scsi_host_check_in_flight,
+			&in_flight);
+	return in_flight.cnt;
 }
 EXPORT_SYMBOL(scsi_host_busy);
 

commit c84b023a4c1461498abf0eda54f60e2fd64a1ca2
Author: Ming Lei <ming.lei@redhat.com>
Date:   Sun Jun 24 22:03:26 2018 +0800

    scsi: read host_busy via scsi_host_busy()
    
    No functional change.
    
    Just introduce scsi_host_busy() and replace the direct read of
    scsi_host->host_busy with this new API.
    
    Cc: Omar Sandoval <osandov@fb.com>,
    Cc: "Martin K. Petersen" <martin.petersen@oracle.com>,
    Cc: James Bottomley <james.bottomley@hansenpartnership.com>,
    Cc: Christoph Hellwig <hch@lst.de>,
    Cc: Don Brace <don.brace@microsemi.com>
    Cc: Kashyap Desai <kashyap.desai@broadcom.com>
    Cc: Mike Snitzer <snitzer@redhat.com>
    Cc: Hannes Reinecke <hare@suse.de>
    Cc: Laurence Oberman <loberman@redhat.com>
    Cc: Bart Van Assche <bart.vanassche@wdc.com>
    
    Signed-off-by: Ming Lei <ming.lei@redhat.com>
    Reviewed-by: Bart Van Assche <bart.vanassche@wdc.com>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/hosts.c b/drivers/scsi/hosts.c
index 3771e59a9fae..ea4b0bb0c1cd 100644
--- a/drivers/scsi/hosts.c
+++ b/drivers/scsi/hosts.c
@@ -563,6 +563,16 @@ struct Scsi_Host *scsi_host_get(struct Scsi_Host *shost)
 }
 EXPORT_SYMBOL(scsi_host_get);
 
+/**
+ * scsi_host_busy - Return the host busy counter
+ * @shost:	Pointer to Scsi_Host to inc.
+ **/
+int scsi_host_busy(struct Scsi_Host *shost)
+{
+	return atomic_read(&shost->host_busy);
+}
+EXPORT_SYMBOL(scsi_host_busy);
+
 /**
  * scsi_host_put - dec a Scsi_Host ref count
  * @shost:	Pointer to Scsi_Host to dec.

commit cbee67c2d7f97aaa1a85501d621002b4dc1e24b8
Author: Colin Ian King <colin.king@canonical.com>
Date:   Wed Mar 28 17:41:42 2018 +0100

    scsi: core: remove redundant assignment to shost->use_blk_mq
    
    The first assignment to shost->use_blk_mq is redundant as it is
    overwritten by the following statement. Remove this redundant code.
    
    Detected by CoverityScan, CID#1466993 ("Unused value")
    
    Signed-off-by: Colin Ian King <colin.king@canonical.com>
    Reviewed-by: Bart Van Assche <bart.vanassche@wdc.com>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/hosts.c b/drivers/scsi/hosts.c
index 7649d63a1b8d..3771e59a9fae 100644
--- a/drivers/scsi/hosts.c
+++ b/drivers/scsi/hosts.c
@@ -472,7 +472,6 @@ struct Scsi_Host *scsi_host_alloc(struct scsi_host_template *sht, int privsize)
 	else
 		shost->dma_boundary = 0xffffffff;
 
-	shost->use_blk_mq = scsi_use_blk_mq;
 	shost->use_blk_mq = scsi_use_blk_mq || shost->hostt->force_blk_mq;
 
 	device_initialize(&shost->shost_gendev);

commit 2e1f44f6ad8008be353c7c99286f7a747b4b3cf4
Merge: ad448378825f 3f6c9be27ae1
Author: James Bottomley <James.Bottomley@HansenPartnership.com>
Date:   Tue Mar 27 12:27:34 2018 -0400

    Merge branch 'fixes' into misc
    
    Somewhat nasty merge due to conflicts between "33b28357dd00 scsi:
    qla2xxx: Fix Async GPN_FT for FCP and FC-NVMe scan" and "2b5b96473efc
    scsi: qla2xxx: Fix FC-NVMe LUN discovery"
    
    Merge is non-trivial and has been verified by Qlogic (Cavium)
    
    Signed-off-by: James E.J. Bottomley <jejb@linux.vnet.ibm.com>

commit 83c9f08e6c6a6dc668384882de4dcf5ef4ae0ba7
Author: Christoph Hellwig <hch@lst.de>
Date:   Mon Mar 19 08:37:53 2018 +0100

    scsi: remove the old scsi_module.c initialization model
    
    After more than 15 years all users of this legacy interface are finally
    gone.  Rest in peace!
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/hosts.c b/drivers/scsi/hosts.c
index 0a5362822ed6..ffd1030b6c91 100644
--- a/drivers/scsi/hosts.c
+++ b/drivers/scsi/hosts.c
@@ -518,29 +518,6 @@ struct Scsi_Host *scsi_host_alloc(struct scsi_host_template *sht, int privsize)
 }
 EXPORT_SYMBOL(scsi_host_alloc);
 
-struct Scsi_Host *scsi_register(struct scsi_host_template *sht, int privsize)
-{
-	struct Scsi_Host *shost = scsi_host_alloc(sht, privsize);
-
-	if (!sht->detect) {
-		printk(KERN_WARNING "scsi_register() called on new-style "
-				    "template for driver %s\n", sht->name);
-		dump_stack();
-	}
-
-	if (shost)
-		list_add_tail(&shost->sht_legacy_list, &sht->legacy_hosts);
-	return shost;
-}
-EXPORT_SYMBOL(scsi_register);
-
-void scsi_unregister(struct Scsi_Host *shost)
-{
-	list_del(&shost->sht_legacy_list);
-	scsi_host_put(shost);
-}
-EXPORT_SYMBOL(scsi_unregister);
-
 static int __scsi_host_match(struct device *dev, const void *data)
 {
 	struct Scsi_Host *p;

commit fa1467fb0076143ea678ae1837b5b3bb27153329
Author: Christoph Hellwig <hch@lst.de>
Date:   Mon Mar 19 08:34:58 2018 +0100

    scsi: core: unexport scsi_host_set_state
    
    This function is only used inside the SCSI midlayer, so remove the
    export for it.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Reviewed-by: Johannes Thumshirn <jthumshirn@suse.de>
    Reviewed-by: Bart Van Assche <bart.vanassche@wdc.com>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/hosts.c b/drivers/scsi/hosts.c
index a0a7e4ff255c..0a5362822ed6 100644
--- a/drivers/scsi/hosts.c
+++ b/drivers/scsi/hosts.c
@@ -154,7 +154,6 @@ int scsi_host_set_state(struct Scsi_Host *shost, enum scsi_host_state state)
 					     scsi_host_state_name(state)));
 	return -EINVAL;
 }
-EXPORT_SYMBOL(scsi_host_set_state);
 
 /**
  * scsi_remove_host - remove a scsi host

commit 2f31115e940c4afd49b99c33123534e2ac924ffb
Author: Ming Lei <ming.lei@redhat.com>
Date:   Tue Mar 13 17:42:41 2018 +0800

    scsi: core: introduce force_blk_mq
    
    This patch introduces 'force_blk_mq' to the scsi_host_template so that
    drivers that have no desire to support the legacy I/O path can signal
    blk-mq only support.
    
    [mkp: commit desc]
    
    Cc: Omar Sandoval <osandov@fb.com>,
    Cc: "Martin K. Petersen" <martin.petersen@oracle.com>,
    Cc: James Bottomley <james.bottomley@hansenpartnership.com>,
    Cc: Christoph Hellwig <hch@lst.de>,
    Cc: Don Brace <don.brace@microsemi.com>
    Cc: Kashyap Desai <kashyap.desai@broadcom.com>
    Cc: Mike Snitzer <snitzer@redhat.com>
    Cc: Laurence Oberman <loberman@redhat.com>
    Signed-off-by: Ming Lei <ming.lei@redhat.com>
    Reviewed-by: Hannes Reinecke <hare@suse.de>
    Reviewed-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/hosts.c b/drivers/scsi/hosts.c
index dd9464920456..ef22b275d050 100644
--- a/drivers/scsi/hosts.c
+++ b/drivers/scsi/hosts.c
@@ -474,6 +474,7 @@ struct Scsi_Host *scsi_host_alloc(struct scsi_host_template *sht, int privsize)
 		shost->dma_boundary = 0xffffffff;
 
 	shost->use_blk_mq = scsi_use_blk_mq;
+	shost->use_blk_mq = scsi_use_blk_mq || shost->hostt->force_blk_mq;
 
 	device_initialize(&shost->shost_gendev);
 	dev_set_name(&shost->shost_gendev, "host%d", shost->host_no);

commit 3be8828fc507cdafe7040a3dcf361a2bcd8e305b
Author: Bart Van Assche <bart.vanassche@wdc.com>
Date:   Thu Feb 22 11:30:20 2018 -0800

    scsi: core: Avoid that ATA error handling can trigger a kernel hang or oops
    
    Avoid that the recently introduced call_rcu() call in the SCSI core
    triggers a double call_rcu() call.
    
    Reported-by: Natanael Copa <ncopa@alpinelinux.org>
    Reported-by: Damien Le Moal <damien.lemoal@wdc.com>
    References: https://bugzilla.kernel.org/show_bug.cgi?id=198861
    Fixes: 3bd6f43f5cb3 ("scsi: core: Ensure that the SCSI error handler gets woken up")
    Signed-off-by: Bart Van Assche <bart.vanassche@wdc.com>
    Reviewed-by: Damien Le Moal <damien.lemoal@wdc.com>
    Tested-by: Damien Le Moal <damien.lemoal@wdc.com>
    Cc: Natanael Copa <ncopa@alpinelinux.org>
    Cc: Damien Le Moal <damien.lemoal@wdc.com>
    Cc: Alexandre Oliva <oliva@gnu.org>
    Cc: Pavel Tikhomirov <ptikhomirov@virtuozzo.com>
    Cc: Hannes Reinecke <hare@suse.com>
    Cc: Johannes Thumshirn <jthumshirn@suse.de>
    Cc: <stable@vger.kernel.org>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/hosts.c b/drivers/scsi/hosts.c
index 57bf43e34863..dd9464920456 100644
--- a/drivers/scsi/hosts.c
+++ b/drivers/scsi/hosts.c
@@ -328,8 +328,6 @@ static void scsi_host_dev_release(struct device *dev)
 	if (shost->work_q)
 		destroy_workqueue(shost->work_q);
 
-	destroy_rcu_head(&shost->rcu);
-
 	if (shost->shost_state == SHOST_CREATED) {
 		/*
 		 * Free the shost_dev device name here if scsi_host_alloc()
@@ -404,7 +402,6 @@ struct Scsi_Host *scsi_host_alloc(struct scsi_host_template *sht, int privsize)
 	INIT_LIST_HEAD(&shost->starved_list);
 	init_waitqueue_head(&shost->host_wait);
 	mutex_init(&shost->scan_mutex);
-	init_rcu_head(&shost->rcu);
 
 	index = ida_simple_get(&host_index_ida, 0, 0, GFP_KERNEL);
 	if (index < 0)

commit 9866306795c207b52d49ac5f8dc7cdec9363b67f
Author: Bart Van Assche <bart.vanassche@wdc.com>
Date:   Mon Feb 12 10:41:29 2018 -0800

    scsi: core: Move the eh_deadline module parameter definition
    
    The eh_deadline definition occurs in the middle of the code for
    releasing a host. Avoid splitting the host release code by moving the
    definition of the eh_deadline parameter to the top of the hosts.c source
    file.
    
    Signed-off-by: Bart Van Assche <bart.vanassche@sandisk.com>
    Reviewed-by: Hannes Reinecke <hare@suse.com>
    Reviewed-by: Johannes Thumshirn <jthumshirn@suse.de>
    Cc: Christoph Hellwig <hch@lst.de>
    Cc: Hannes Reinecke <hare@suse.com>
    Cc: Johannes Thumshirn <jthumshirn@suse.de>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/hosts.c b/drivers/scsi/hosts.c
index 57bf43e34863..a0a7e4ff255c 100644
--- a/drivers/scsi/hosts.c
+++ b/drivers/scsi/hosts.c
@@ -42,6 +42,12 @@
 #include "scsi_logging.h"
 
 
+static int shost_eh_deadline = -1;
+
+module_param_named(eh_deadline, shost_eh_deadline, int, S_IRUGO|S_IWUSR);
+MODULE_PARM_DESC(eh_deadline,
+		 "SCSI EH timeout in seconds (should be between 0 and 2^31-1)");
+
 static DEFINE_IDA(host_index_ida);
 
 
@@ -358,12 +364,6 @@ static void scsi_host_dev_release(struct device *dev)
 	kfree(shost);
 }
 
-static int shost_eh_deadline = -1;
-
-module_param_named(eh_deadline, shost_eh_deadline, int, S_IRUGO|S_IWUSR);
-MODULE_PARM_DESC(eh_deadline,
-		 "SCSI EH timeout in seconds (should be between 0 and 2^31-1)");
-
 static struct device_type scsi_host_type = {
 	.name =		"scsi_host",
 	.release =	scsi_host_dev_release,

commit 3bd6f43f5cb3714f70c591514f344389df593501
Author: Bart Van Assche <bart.vanassche@wdc.com>
Date:   Mon Dec 4 10:06:23 2017 -0800

    scsi: core: Ensure that the SCSI error handler gets woken up
    
    If scsi_eh_scmd_add() is called concurrently with
    scsi_host_queue_ready() while shost->host_blocked > 0 then it can
    happen that neither function wakes up the SCSI error handler. Fix
    this by making every function that decreases the host_busy counter
    wake up the error handler if necessary and by protecting the
    host_failed checks with the SCSI host lock.
    
    Reported-by: Pavel Tikhomirov <ptikhomirov@virtuozzo.com>
    References: https://marc.info/?l=linux-kernel&m=150461610630736
    Fixes: commit 746650160866 ("scsi: convert host_busy to atomic_t")
    Signed-off-by: Bart Van Assche <bart.vanassche@wdc.com>
    Reviewed-by: Pavel Tikhomirov <ptikhomirov@virtuozzo.com>
    Tested-by: Stuart Hayes <stuart.w.hayes@gmail.com>
    Cc: Konstantin Khorenko <khorenko@virtuozzo.com>
    Cc: Stuart Hayes <stuart.w.hayes@gmail.com>
    Cc: Pavel Tikhomirov <ptikhomirov@virtuozzo.com>
    Cc: Christoph Hellwig <hch@lst.de>
    Cc: Hannes Reinecke <hare@suse.com>
    Cc: Johannes Thumshirn <jthumshirn@suse.de>
    Cc: <stable@vger.kernel.org>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/hosts.c b/drivers/scsi/hosts.c
index fe3a0da3ec97..57bf43e34863 100644
--- a/drivers/scsi/hosts.c
+++ b/drivers/scsi/hosts.c
@@ -318,6 +318,9 @@ static void scsi_host_dev_release(struct device *dev)
 
 	scsi_proc_hostdir_rm(shost->hostt);
 
+	/* Wait for functions invoked through call_rcu(&shost->rcu, ...) */
+	rcu_barrier();
+
 	if (shost->tmf_work_q)
 		destroy_workqueue(shost->tmf_work_q);
 	if (shost->ehandler)
@@ -325,6 +328,8 @@ static void scsi_host_dev_release(struct device *dev)
 	if (shost->work_q)
 		destroy_workqueue(shost->work_q);
 
+	destroy_rcu_head(&shost->rcu);
+
 	if (shost->shost_state == SHOST_CREATED) {
 		/*
 		 * Free the shost_dev device name here if scsi_host_alloc()
@@ -399,6 +404,7 @@ struct Scsi_Host *scsi_host_alloc(struct scsi_host_template *sht, int privsize)
 	INIT_LIST_HEAD(&shost->starved_list);
 	init_waitqueue_head(&shost->host_wait);
 	mutex_init(&shost->scan_mutex);
+	init_rcu_head(&shost->rcu);
 
 	index = ida_simple_get(&host_index_ida, 0, 0, GFP_KERNEL);
 	if (index < 0)

commit 7760e223507b5218d0674b5e2e8dc29fea079a89
Author: Bart Van Assche <bart.vanassche@wdc.com>
Date:   Thu Aug 31 16:59:06 2017 -0700

    scsi: Remove Scsi_Host.uspace_req_q
    
    A patch I wrote myself several years ago removed SCSI target support
    from the code under drivers/scsi. That patch removed the code that sets
    uspace_req_q to a non-NULL value. Hence also remove the code that
    depends on uspace_req_q != NULL.
    
    References: commit 066465251303 ("tgt: removal")
    Signed-off-by: Bart Van Assche <bart.vanassche@wdc.com>
    Cc: Christoph Hellwig <hch@lst.de>
    Cc: Hannes Reinecke <hare@suse.de>
    Cc: Johannes Thumshirn <jthumshirn@suse.de>
    Reviewed-by: Johannes Thumshirn <jthumshirn@suse.de>
    Reviewed-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/hosts.c b/drivers/scsi/hosts.c
index 831a1c8b9f89..fe3a0da3ec97 100644
--- a/drivers/scsi/hosts.c
+++ b/drivers/scsi/hosts.c
@@ -315,8 +315,6 @@ static void scsi_host_dev_release(struct device *dev)
 {
 	struct Scsi_Host *shost = dev_to_shost(dev);
 	struct device *parent = dev->parent;
-	struct request_queue *q;
-	void *queuedata;
 
 	scsi_proc_hostdir_rm(shost->hostt);
 
@@ -326,12 +324,6 @@ static void scsi_host_dev_release(struct device *dev)
 		kthread_stop(shost->ehandler);
 	if (shost->work_q)
 		destroy_workqueue(shost->work_q);
-	q = shost->uspace_req_q;
-	if (q) {
-		queuedata = q->queuedata;
-		blk_cleanup_queue(q);
-		kfree(queuedata);
-	}
 
 	if (shost->shost_state == SHOST_CREATED) {
 		/*

commit e9c787e65c0c36529745be47d490d998b4b6e589
Author: Christoph Hellwig <hch@lst.de>
Date:   Mon Jan 2 21:55:26 2017 +0300

    scsi: allocate scsi_cmnd structures as part of struct request
    
    Rely on the new block layer functionality to allocate additional driver
    specific data behind struct request instead of implementing it in SCSI
    it—ïelf.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Acked-by: Martin K. Petersen <martin.petersen@oracle.com>
    Reviewed-by: Hannes Reinecke <hare@suse.com>
    Signed-off-by: Jens Axboe <axboe@fb.com>

diff --git a/drivers/scsi/hosts.c b/drivers/scsi/hosts.c
index 6d29c4ad9b15..831a1c8b9f89 100644
--- a/drivers/scsi/hosts.c
+++ b/drivers/scsi/hosts.c
@@ -230,19 +230,6 @@ int scsi_add_host_with_dma(struct Scsi_Host *shost, struct device *dev,
 		}
 	}
 
-	/*
-	 * Note that we allocate the freelist even for the MQ case for now,
-	 * as we need a command set aside for scsi_reset_provider.  Having
-	 * the full host freelist and one command available for that is a
-	 * little heavy-handed, but avoids introducing a special allocator
-	 * just for this.  Eventually the structure of scsi_reset_provider
-	 * will need a major overhaul.
-	 */
-	error = scsi_setup_command_freelist(shost);
-	if (error)
-		goto out_destroy_tags;
-
-
 	if (!shost->shost_gendev.parent)
 		shost->shost_gendev.parent = dev ? dev : &platform_bus;
 	if (!dma_dev)
@@ -262,7 +249,7 @@ int scsi_add_host_with_dma(struct Scsi_Host *shost, struct device *dev,
 
 	error = device_add(&shost->shost_gendev);
 	if (error)
-		goto out_destroy_freelist;
+		goto out_disable_runtime_pm;
 
 	scsi_host_set_state(shost, SHOST_RUNNING);
 	get_device(shost->shost_gendev.parent);
@@ -312,13 +299,11 @@ int scsi_add_host_with_dma(struct Scsi_Host *shost, struct device *dev,
 	device_del(&shost->shost_dev);
  out_del_gendev:
 	device_del(&shost->shost_gendev);
- out_destroy_freelist:
+ out_disable_runtime_pm:
 	device_disable_async_suspend(&shost->shost_gendev);
 	pm_runtime_disable(&shost->shost_gendev);
 	pm_runtime_set_suspended(&shost->shost_gendev);
 	pm_runtime_put_noidle(&shost->shost_gendev);
-	scsi_destroy_command_freelist(shost);
- out_destroy_tags:
 	if (shost_use_blk_mq(shost))
 		scsi_mq_destroy_tags(shost);
  fail:
@@ -359,7 +344,6 @@ static void scsi_host_dev_release(struct device *dev)
 		kfree(dev_name(&shost->shost_dev));
 	}
 
-	scsi_destroy_command_freelist(shost);
 	if (shost_use_blk_mq(shost)) {
 		if (shost->tag_set.tags)
 			scsi_mq_destroy_tags(shost);

commit 0a6ac4ee7c21098cb0e41cc4053b9d9ddc9e70a1
Author: Christoph Hellwig <hch@lst.de>
Date:   Tue Jan 3 08:28:41 2017 +0300

    scsi: respect unchecked_isa_dma for blk-mq
    
    Currently blk-mq always allocates the sense buffer using normal GFP_KERNEL
    allocation.  Refactor the cmd pool code to split the cmd and sense allocation
    and share the code to allocate the sense buffers as well as the sense buffer
    slab caches between the legacy and blk-mq path.
    
    Note that this switches to lazy allocation of the sense slab caches - the
    slab caches (not the actual allocations) won't be destroy until the scsi
    module is unloaded instead of keeping track of hosts using them.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Reviewed-by: Hannes Reinecke <hare@suse.com>
    Acked-by: Martin K. Petersen <martin.petersen@oracle.com>
    Signed-off-by: Jens Axboe <axboe@fb.com>

diff --git a/drivers/scsi/hosts.c b/drivers/scsi/hosts.c
index 258a3f9a2519..6d29c4ad9b15 100644
--- a/drivers/scsi/hosts.c
+++ b/drivers/scsi/hosts.c
@@ -213,6 +213,10 @@ int scsi_add_host_with_dma(struct Scsi_Host *shost, struct device *dev,
 		goto fail;
 	}
 
+	error = scsi_init_sense_cache(shost);
+	if (error)
+		goto fail;
+
 	if (shost_use_blk_mq(shost)) {
 		error = scsi_mq_setup_tags(shost);
 		if (error)

commit 4dfddf503670d8def0fddb497e628130fc4522a8
Merge: d4e65476bc68 14bf41dcef65
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Fri Oct 7 09:28:53 2016 -0700

    Merge tag 'scsi-misc' of git://git.kernel.org/pub/scm/linux/kernel/git/jejb/scsi
    
    Pull SCSI updates from James Bottomley:
     "This update includes the usual round of major driver updates (hpsa,
      be2iscsi, hisi_sas, zfcp, cxlflash). There's a new incarnation of hpsa
      called smartpqi for which a driver is added, there's some cleanup work
      of the ibm vscsi target and updates to libfc, plus a whole host of
      minor fixes and updates and finally the removal of several ISA drivers
      which seem not to have been used for years"
    
    * tag 'scsi-misc' of git://git.kernel.org/pub/scm/linux/kernel/git/jejb/scsi: (173 commits)
      scsi: mvsas: Mark symbols static where possible
      scsi: pm8001: Mark symbols static where possible
      scsi: arcmsr: Simplify user_len checking
      scsi: fcoe: fix off by one in eth2fc_speed()
      scsi: dtc: remove from tree
      scsi: t128: remove from tree
      scsi: pas16: remove from tree
      scsi: u14-34f: remove from tree
      scsi: ultrastor: remove from tree
      scsi: in2000: remove from tree
      scsi: wd7000: remove from tree
      scsi: scsi_dh_alua: Fix memory leak in alua_rtpg()
      scsi: lpfc: Mark symbols static where possible
      scsi: hpsa: correct call to hpsa_do_reset
      scsi: ufs: Get a TM service response from the correct offset
      scsi: ibmvfc: Fix I/O hang when port is not mapped
      scsi: megaraid_sas: clean function declarations in megaraid_sas_base.c up
      scsi: ipr: Remove redundant messages at adapter init time
      scsi: ipr: Don't log unnecessary 9084 error details
      scsi: smartpqi: raid bypass lba calculation fix
      ...

commit 8d58881b995904bf8b150dae69be0829f832e7be
Author: Bart Van Assche <bart.vanassche@sandisk.com>
Date:   Thu Sep 22 14:20:54 2016 -0700

    scsi: Avoid that toggling use_blk_mq triggers a memory leak
    
    This patch avoids that the following memory leak is triggered if
    use_blk_mq is disabled after a SCSI host has been allocated by the
    ib_srp driver and before the same SCSI host is freed:
    
    unreferenced object 0xffff8803a168c568 (size 256):
      backtrace:
        [<ffffffff81620c95>] kmemleak_alloc+0x45/0xa0
        [<ffffffff811bb104>] __kmalloc_node+0x1e4/0x400
        [<ffffffff81309fe4>] blk_mq_alloc_tag_set+0xb4/0x230
        [<ffffffff814731b7>] scsi_mq_setup_tags+0xc7/0xd0
        [<ffffffff81469c26>] scsi_add_host_with_dma+0x216/0x2d0
        [<ffffffffa064bef5>] srp_create_target+0xe55/0x13d0 [ib_srp]
        [<ffffffff8143ce23>] dev_attr_store+0x13/0x20
        [<ffffffff8125f030>] sysfs_kf_write+0x40/0x50
        [<ffffffff8125e397>] kernfs_fop_write+0x137/0x1c0
        [<ffffffff811d8c13>] __vfs_write+0x23/0x140
        [<ffffffff811d92e0>] vfs_write+0xb0/0x190
        [<ffffffff811da5b4>] SyS_write+0x44/0xa0
        [<ffffffff8162c8a5>] entry_SYSCALL_64_fastpath+0x18/0xa8
    
    Fixes: 9aa9cc4221f5 ("scsi: remove the disable_blk_mq host flag")
    Signed-off-by: Bart Van Assche <bart.vanassche@sandisk.com>
    Cc: Christoph Hellwig <hch@lst.de>
    Cc: Martin K. Petersen <martin.petersen@oracle.com>
    Cc: <stable@vger.kernel.org>
    Reviewed-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/hosts.c b/drivers/scsi/hosts.c
index ba9af4a2bd2a..ec6381e57eb7 100644
--- a/drivers/scsi/hosts.c
+++ b/drivers/scsi/hosts.c
@@ -486,6 +486,8 @@ struct Scsi_Host *scsi_host_alloc(struct scsi_host_template *sht, int privsize)
 	else
 		shost->dma_boundary = 0xffffffff;
 
+	shost->use_blk_mq = scsi_use_blk_mq;
+
 	device_initialize(&shost->shost_gendev);
 	dev_set_name(&shost->shost_gendev, "host%d", shost->host_no);
 	shost->shost_gendev.bus = &scsi_bus_type;

commit 0d5644b7d8daa3c1d91acb4367731f568c9c9469
Author: Heiner Kallweit <hkallweit1@gmail.com>
Date:   Wed Aug 3 21:49:03 2016 +0200

    scsi: configure runtime pm before calling device_add in scsi_add_host_with_dma
    
    Runtime PM should be configured already once we call device_add. See
    also the description in this mail thread
    https://lists.linuxfoundation.org/pipermail/linux-pm/2009-November/023198.html
    or the order of calls e.g. in usb_new_device.
    
    The changed order also helps to avoid scenarios where runtime pm for
    &shost->shost_gendev is activated whilst the parent is suspended,
    resulting in error message "runtime PM trying to activate child device
    hostx but parent yyy is not active".
    
    In addition properly reverse the runtime pm calls in the error path.
    
    Signed-off-by: Heiner Kallweit <hkallweit1@gmail.com>
    Acked-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/hosts.c b/drivers/scsi/hosts.c
index ba9af4a2bd2a..9ab94adbddb7 100644
--- a/drivers/scsi/hosts.c
+++ b/drivers/scsi/hosts.c
@@ -246,10 +246,6 @@ int scsi_add_host_with_dma(struct Scsi_Host *shost, struct device *dev,
 
 	shost->dma_dev = dma_dev;
 
-	error = device_add(&shost->shost_gendev);
-	if (error)
-		goto out_destroy_freelist;
-
 	/*
 	 * Increase usage count temporarily here so that calling
 	 * scsi_autopm_put_host() will trigger runtime idle if there is
@@ -260,6 +256,10 @@ int scsi_add_host_with_dma(struct Scsi_Host *shost, struct device *dev,
 	pm_runtime_enable(&shost->shost_gendev);
 	device_enable_async_suspend(&shost->shost_gendev);
 
+	error = device_add(&shost->shost_gendev);
+	if (error)
+		goto out_destroy_freelist;
+
 	scsi_host_set_state(shost, SHOST_RUNNING);
 	get_device(shost->shost_gendev.parent);
 
@@ -309,6 +309,10 @@ int scsi_add_host_with_dma(struct Scsi_Host *shost, struct device *dev,
  out_del_gendev:
 	device_del(&shost->shost_gendev);
  out_destroy_freelist:
+	device_disable_async_suspend(&shost->shost_gendev);
+	pm_runtime_disable(&shost->shost_gendev);
+	pm_runtime_set_suspended(&shost->shost_gendev);
+	pm_runtime_put_noidle(&shost->shost_gendev);
 	scsi_destroy_command_freelist(shost);
  out_destroy_tags:
 	if (shost_use_blk_mq(shost))

commit 9aa9cc4221f5154ed93e999662ccfef7b6a82e3e
Author: Christoph Hellwig <hch@lst.de>
Date:   Wed Jul 13 13:19:05 2016 +0900

    scsi: remove the disable_blk_mq host flag
    
    We've had scsi-mq for 2.5 years now, so we can remove the unused flag to
    disable the code on a per-host basis that was put in for unexpected
    emergencies during bringup.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Reviewed-by: Bart Van Assche <bart.vanassche@sandisk.com>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/hosts.c b/drivers/scsi/hosts.c
index 1547bd93c70b..ba9af4a2bd2a 100644
--- a/drivers/scsi/hosts.c
+++ b/drivers/scsi/hosts.c
@@ -486,8 +486,6 @@ struct Scsi_Host *scsi_host_alloc(struct scsi_host_template *sht, int privsize)
 	else
 		shost->dma_boundary = 0xffffffff;
 
-	shost->use_blk_mq = scsi_use_blk_mq && !shost->hostt->disable_blk_mq;
-
 	device_initialize(&shost->shost_gendev);
 	dev_set_name(&shost->shost_gendev, "host%d", shost->host_no);
 	shost->shost_gendev.bus = &scsi_bus_type;

commit fcab86add71623e3963d7565c0d61bb9d99aea7c
Merge: ef504fa591aa 8134233e8d34
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Fri Mar 18 20:06:46 2016 -0700

    Merge branch 'for-4.6' of git://git.kernel.org/pub/scm/linux/kernel/git/tj/libata
    
    Pull libata updates from Tejun Heo:
    
     - ahci grew runtime power management support so that the controller can
       be turned off if no devices are attached.
    
     - sata_via isn't dead yet.  It got hotplug support and more refined
       workaround for certain WD drives.
    
     - Misc cleanups.  There's a merge from for-4.5-fixes to avoid confusing
       conflicts in ahci PCI ID table.
    
    * 'for-4.6' of git://git.kernel.org/pub/scm/linux/kernel/git/tj/libata:
      ata: ahci_xgene: dereferencing uninitialized pointer in probe
      AHCI: Remove obsolete Intel Lewisburg SATA RAID device IDs
      ata: sata_rcar: Use ARCH_RENESAS
      sata_via: Implement hotplug for VT6421
      sata_via: Apply WD workaround only when needed on VT6421
      ahci: Add runtime PM support for the host controller
      ahci: Add functions to manage runtime PM of AHCI ports
      ahci: Convert driver to use modern PM hooks
      ahci: Cache host controller version
      scsi: Drop runtime PM usage count after host is added
      scsi: Set request queue runtime PM status back to active on resume
      block: Add blk_set_runtime_active()
      ata: ahci_mvebu: add support for Armada 3700 variant
      libata: fix unbalanced spin_lock_irqsave/spin_unlock_irq() in ata_scsi_park_show()
      libata: support AHCI on OCTEON platform

commit 126a4fe010fd86cf3eaac9a481f0698e39dc3c0d
Author: Lee Duncan <lduncan@suse.com>
Date:   Wed Jan 20 11:48:00 2016 -0800

    scsi: Use ida for host number management
    
    Update the SCSI hosts module to use ida to manage its host_no index
    instead of an atomic integer. This means that the SCSI host number will
    now be reclaimable.
    
    Use the ida "simple" mechanism, since there should be no need for a
    separate spin lock current usage. Ida was chosen over idr because the
    hosts module already has its own instance and locking mechanisms that
    aren't easily changed.
    
    Reviewed-by: Hannes Reinecke <hare@suse.de>
    Reviewed-by: Johannes Thumshirn <jthumshirn@suse.de>
    Signed-off-by: Lee Duncan <lduncan@suse.com>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/hosts.c b/drivers/scsi/hosts.c
index 82ac1cd818ac..94025c5cf797 100644
--- a/drivers/scsi/hosts.c
+++ b/drivers/scsi/hosts.c
@@ -33,7 +33,7 @@
 #include <linux/transport_class.h>
 #include <linux/platform_device.h>
 #include <linux/pm_runtime.h>
-
+#include <linux/idr.h>
 #include <scsi/scsi_device.h>
 #include <scsi/scsi_host.h>
 #include <scsi/scsi_transport.h>
@@ -42,7 +42,7 @@
 #include "scsi_logging.h"
 
 
-static atomic_t scsi_host_next_hn = ATOMIC_INIT(0);	/* host_no for next new host */
+static DEFINE_IDA(host_index_ida);
 
 
 static void scsi_host_cls_release(struct device *dev)
@@ -355,6 +355,8 @@ static void scsi_host_dev_release(struct device *dev)
 
 	kfree(shost->shost_data);
 
+	ida_simple_remove(&host_index_ida, shost->host_no);
+
 	if (parent)
 		put_device(parent);
 	kfree(shost);
@@ -388,6 +390,7 @@ struct Scsi_Host *scsi_host_alloc(struct scsi_host_template *sht, int privsize)
 {
 	struct Scsi_Host *shost;
 	gfp_t gfp_mask = GFP_KERNEL;
+	int index;
 
 	if (sht->unchecked_isa_dma && privsize)
 		gfp_mask |= __GFP_DMA;
@@ -406,11 +409,11 @@ struct Scsi_Host *scsi_host_alloc(struct scsi_host_template *sht, int privsize)
 	init_waitqueue_head(&shost->host_wait);
 	mutex_init(&shost->scan_mutex);
 
-	/*
-	 * subtract one because we increment first then return, but we need to
-	 * know what the next host number was before increment
-	 */
-	shost->host_no = atomic_inc_return(&scsi_host_next_hn) - 1;
+	index = ida_simple_get(&host_index_ida, 0, 0, GFP_KERNEL);
+	if (index < 0)
+		goto fail_kfree;
+	shost->host_no = index;
+
 	shost->dma_channel = 0xff;
 
 	/* These three are default values which can be overridden */
@@ -495,7 +498,7 @@ struct Scsi_Host *scsi_host_alloc(struct scsi_host_template *sht, int privsize)
 		shost_printk(KERN_WARNING, shost,
 			"error handler thread failed to spawn, error = %ld\n",
 			PTR_ERR(shost->ehandler));
-		goto fail_kfree;
+		goto fail_index_remove;
 	}
 
 	shost->tmf_work_q = alloc_workqueue("scsi_tmf_%d",
@@ -511,6 +514,8 @@ struct Scsi_Host *scsi_host_alloc(struct scsi_host_template *sht, int privsize)
 
  fail_kthread:
 	kthread_stop(shost->ehandler);
+ fail_index_remove:
+	ida_simple_remove(&host_index_ida, shost->host_no);
  fail_kfree:
 	kfree(shost);
 	return NULL;
@@ -606,6 +611,7 @@ int scsi_init_hosts(void)
 void scsi_exit_hosts(void)
 {
 	class_unregister(&shost_class);
+	ida_destroy(&host_index_ida);
 }
 
 int scsi_is_host_device(const struct device *dev)

commit 5c6fab9d558470b4e53c6d113f7dbcb31049ffc5
Author: Mika Westerberg <mika.westerberg@linux.intel.com>
Date:   Thu Feb 18 10:54:13 2016 +0200

    scsi: Drop runtime PM usage count after host is added
    
    Runtime PM of the SCSI host is already handled by calls to
    scsi_autopm_get_host() and scsi_autopm_put_host() from appropriate places
    whenever the host needs to be powered on. This works fine when there is
    device connected to the host as once it runtime suspends the host will too.
    
    However, if there is no device connected the host is never runtime
    suspended (the usage counter is always 0).
    
    Allow runtime suspend of host even if it has no devices connected by
    calling scsi_autopm_put_host() at the end of scsi_add_host_with_dma(). We
    temporarily increase runtime PM usage counter first so call to
    scsi_autopm_put_host() will result idle request to be scheduled for the
    device.
    
    Signed-off-by: Mika Westerberg <mika.westerberg@linux.intel.com>
    Signed-off-by: Tejun Heo <tj@kernel.org>

diff --git a/drivers/scsi/hosts.c b/drivers/scsi/hosts.c
index 82ac1cd818ac..e46bf4d152a0 100644
--- a/drivers/scsi/hosts.c
+++ b/drivers/scsi/hosts.c
@@ -250,6 +250,12 @@ int scsi_add_host_with_dma(struct Scsi_Host *shost, struct device *dev,
 	if (error)
 		goto out_destroy_freelist;
 
+	/*
+	 * Increase usage count temporarily here so that calling
+	 * scsi_autopm_put_host() will trigger runtime idle if there is
+	 * nothing else preventing suspending the device.
+	 */
+	pm_runtime_get_noresume(&shost->shost_gendev);
 	pm_runtime_set_active(&shost->shost_gendev);
 	pm_runtime_enable(&shost->shost_gendev);
 	device_enable_async_suspend(&shost->shost_gendev);
@@ -290,6 +296,7 @@ int scsi_add_host_with_dma(struct Scsi_Host *shost, struct device *dev,
 		goto out_destroy_host;
 
 	scsi_proc_host_add(shost);
+	scsi_autopm_put_host(shost);
 	return error;
 
  out_destroy_host:

commit be9e2f775f5a3147205c552534c3abf0f9374a13
Merge: e619e6cbecb7 3ddda3e4c82d
Author: James Bottomley <James.Bottomley@HansenPartnership.com>
Date:   Thu Dec 3 09:32:33 2015 -0800

    Merge branch 'mkp-fixes' into fixes

commit b49493f99690c8eaacfbc635bafaad629ea2c036
Author: Bart Van Assche <bart.vanassche@sandisk.com>
Date:   Wed Nov 18 14:56:36 2015 -0800

    Fix a memory leak in scsi_host_dev_release()
    
    Avoid that kmemleak reports the following memory leak if a
    SCSI LLD calls scsi_host_alloc() and scsi_host_put() but neither
    scsi_host_add() nor scsi_host_remove(). The following shell
    command triggers that scenario:
    
    for ((i=0; i<2; i++)); do
      srp_daemon -oac |
      while read line; do
        echo $line >/sys/class/infiniband_srp/srp-mlx4_0-1/add_target
      done
    done
    
    unreferenced object 0xffff88021b24a220 (size 8):
      comm "srp_daemon", pid 56421, jiffies 4295006762 (age 4240.750s)
      hex dump (first 8 bytes):
        68 6f 73 74 35 38 00 a5                          host58..
      backtrace:
        [<ffffffff8151014a>] kmemleak_alloc+0x7a/0xc0
        [<ffffffff81165c1e>] __kmalloc_track_caller+0xfe/0x160
        [<ffffffff81260d2b>] kvasprintf+0x5b/0x90
        [<ffffffff81260e2d>] kvasprintf_const+0x8d/0xb0
        [<ffffffff81254b0c>] kobject_set_name_vargs+0x3c/0xa0
        [<ffffffff81337e3c>] dev_set_name+0x3c/0x40
        [<ffffffff81355757>] scsi_host_alloc+0x327/0x4b0
        [<ffffffffa03edc8e>] srp_create_target+0x4e/0x8a0 [ib_srp]
        [<ffffffff8133778b>] dev_attr_store+0x1b/0x20
        [<ffffffff811f27fa>] sysfs_kf_write+0x4a/0x60
        [<ffffffff811f1e8e>] kernfs_fop_write+0x14e/0x180
        [<ffffffff81176eef>] __vfs_write+0x2f/0xf0
        [<ffffffff811771e4>] vfs_write+0xa4/0x100
        [<ffffffff81177c64>] SyS_write+0x54/0xc0
        [<ffffffff8151b257>] entry_SYSCALL_64_fastpath+0x12/0x6f
    
    Signed-off-by: Bart Van Assche <bart.vanassche@sandisk.com>
    Reviewed-by: Christoph Hellwig <hch@lst.de>
    Reviewed-by: Johannes Thumshirn <jthumshirn@suse.de>
    Reviewed-by: Sagi Grimberg <sagig@mellanox.com>
    Reviewed-by: Lee Duncan <lduncan@suse.com>
    Cc: Christoph Hellwig <hch@lst.de>
    Cc: Hannes Reinecke <hare@suse.de>
    Cc: stable <stable@vger.kernel.org>
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>

diff --git a/drivers/scsi/hosts.c b/drivers/scsi/hosts.c
index 8bb173e01084..7d647a32f85e 100644
--- a/drivers/scsi/hosts.c
+++ b/drivers/scsi/hosts.c
@@ -326,6 +326,17 @@ static void scsi_host_dev_release(struct device *dev)
 		kfree(queuedata);
 	}
 
+	if (shost->shost_state == SHOST_CREATED) {
+		/*
+		 * Free the shost_dev device name here if scsi_host_alloc()
+		 * and scsi_host_put() have been called but neither
+		 * scsi_host_add() nor scsi_host_remove() has been called.
+		 * This avoids that the memory allocated for the shost_dev
+		 * name is leaked.
+		 */
+		kfree(dev_name(&shost->shost_dev));
+	}
+
 	scsi_destroy_command_freelist(shost);
 	if (shost_use_blk_mq(shost)) {
 		if (shost->tag_set.tags)

commit 64d513ac31bd02a3c9b69ef04444f36c196f9a9d
Author: Christoph Hellwig <hch@lst.de>
Date:   Thu Oct 8 09:28:04 2015 +0100

    scsi: use host wide tags by default
    
    This patch changes the !blk-mq path to the same defaults as the blk-mq
    I/O path by always enabling block tagging, and always using host wide
    tags.  We've had blk-mq available for a few releases so bugs with
    this mode should have been ironed out, and this ensures we get better
    coverage of over tagging setup over different configs.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Acked-by: Jens Axboe <axboe@kernel.dk>
    Reviewed-by: Hannes Reinecke <hare@suse.de>
    Signed-off-by: James Bottomley <JBottomley@Odin.com>

diff --git a/drivers/scsi/hosts.c b/drivers/scsi/hosts.c
index 8bb173e01084..323982fd00c3 100644
--- a/drivers/scsi/hosts.c
+++ b/drivers/scsi/hosts.c
@@ -217,6 +217,13 @@ int scsi_add_host_with_dma(struct Scsi_Host *shost, struct device *dev,
 		error = scsi_mq_setup_tags(shost);
 		if (error)
 			goto fail;
+	} else {
+		shost->bqt = blk_init_tags(shost->can_queue,
+				shost->hostt->tag_alloc_policy);
+		if (!shost->bqt) {
+			error = -ENOMEM;
+			goto fail;
+		}
 	}
 
 	/*

commit abd0c533e37789ef56a73562d6d06d39897bd801
Author: Christoph Hellwig <hch@lst.de>
Date:   Mon Nov 3 14:47:07 2014 +0100

    scsi: remove ordered_tag host template field
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Reviewed-by: Bart Van Assche <bvanassche@acm.org>
    Reviewed-by: Mike Christie <michaelc@cs.wisc.edu>
    Reviewed-by: Martin K. Petersen <martin.petersen@oracle.com>
    Reviewed-by: Hannes Reinecke <hare@suse.de>

diff --git a/drivers/scsi/hosts.c b/drivers/scsi/hosts.c
index 06030e1ad696..8bb173e01084 100644
--- a/drivers/scsi/hosts.c
+++ b/drivers/scsi/hosts.c
@@ -418,7 +418,6 @@ struct Scsi_Host *scsi_host_alloc(struct scsi_host_template *sht, int privsize)
 	shost->cmd_per_lun = sht->cmd_per_lun;
 	shost->unchecked_isa_dma = sht->unchecked_isa_dma;
 	shost->use_clustering = sht->use_clustering;
-	shost->ordered_tag = sht->ordered_tag;
 	shost->no_write_same = sht->no_write_same;
 
 	if (shost_eh_deadline == -1 || !sht->eh_host_reset_handler)

commit a222b1e2fe4299a01c86ea8ccafbf0a05aeaa5a1
Author: Hannes Reinecke <hare@suse.de>
Date:   Fri Oct 24 14:27:02 2014 +0200

    scsi: fixup logging messages in scsi_error.c
    
    Use the matching scope for logging messages to allow for
    better command tracing.
    
    Signed-off-by: Hannes Reinecke <hare@suse.de>
    Suggested-by: Robert Elliott <elliott@hp.com>
    Reviewed-by: Robert Elliott <elliott@hp.com>
    Signed-off-by: Christoph Hellwig <hch@lst.de>

diff --git a/drivers/scsi/hosts.c b/drivers/scsi/hosts.c
index 6de80e352871..06030e1ad696 100644
--- a/drivers/scsi/hosts.c
+++ b/drivers/scsi/hosts.c
@@ -485,8 +485,8 @@ struct Scsi_Host *scsi_host_alloc(struct scsi_host_template *sht, int privsize)
 					    WQ_UNBOUND | WQ_MEM_RECLAIM,
 					   1, shost->host_no);
 	if (!shost->tmf_work_q) {
-		printk(KERN_WARNING "scsi%d: failed to create tmf workq\n",
-		       shost->host_no);
+		shost_printk(KERN_WARNING, shost,
+			     "failed to create tmf workq\n");
 		goto fail_kthread;
 	}
 	scsi_proc_hostdir_add(shost->hostt);

commit d285203cf647d7c97db3a1c33794315c9008593f
Author: Christoph Hellwig <hch@lst.de>
Date:   Fri Jan 17 12:06:53 2014 +0100

    scsi: add support for a blk-mq based I/O path.
    
    This patch adds support for an alternate I/O path in the scsi midlayer
    which uses the blk-mq infrastructure instead of the legacy request code.
    
    Use of blk-mq is fully transparent to drivers, although for now a host
    template field is provided to opt out of blk-mq usage in case any unforseen
    incompatibilities arise.
    
    In general replacing the legacy request code with blk-mq is a simple and
    mostly mechanical transformation.  The biggest exception is the new code
    that deals with the fact the I/O submissions in blk-mq must happen from
    process context, which slightly complicates the I/O completion handler.
    The second biggest differences is that blk-mq is build around the concept
    of preallocated requests that also include driver specific data, which
    in SCSI context means the scsi_cmnd structure.  This completely avoids
    dynamic memory allocations for the fast path through I/O submission.
    
    Due the preallocated requests the MQ code path exclusively uses the
    host-wide shared tag allocator instead of a per-LUN one.  This only
    affects drivers actually using the block layer provided tag allocator
    instead of their own.  Unlike the old path blk-mq always provides a tag,
    although drivers don't have to use it.
    
    For now the blk-mq path is disable by defauly and must be enabled using
    the "use_blk_mq" module parameter.  Once the remaining work in the block
    layer to make blk-mq more suitable for slow devices is complete I hope
    to make it the default and eventually even remove the old code path.
    
    Based on the earlier scsi-mq prototype by Nicholas Bellinger.
    
    Thanks to Bart Van Assche and Robert Elliot for testing, benchmarking and
    various sugestions and code contributions.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Reviewed-by: Martin K. Petersen <martin.petersen@oracle.com>
    Reviewed-by: Hannes Reinecke <hare@suse.de>
    Reviewed-by: Webb Scales <webbnh@hp.com>
    Acked-by: Jens Axboe <axboe@kernel.dk>
    Tested-by: Bart Van Assche <bvanassche@acm.org>
    Tested-by: Robert Elliott <elliott@hp.com>

diff --git a/drivers/scsi/hosts.c b/drivers/scsi/hosts.c
index 0632eee82620..6de80e352871 100644
--- a/drivers/scsi/hosts.c
+++ b/drivers/scsi/hosts.c
@@ -213,9 +213,24 @@ int scsi_add_host_with_dma(struct Scsi_Host *shost, struct device *dev,
 		goto fail;
 	}
 
+	if (shost_use_blk_mq(shost)) {
+		error = scsi_mq_setup_tags(shost);
+		if (error)
+			goto fail;
+	}
+
+	/*
+	 * Note that we allocate the freelist even for the MQ case for now,
+	 * as we need a command set aside for scsi_reset_provider.  Having
+	 * the full host freelist and one command available for that is a
+	 * little heavy-handed, but avoids introducing a special allocator
+	 * just for this.  Eventually the structure of scsi_reset_provider
+	 * will need a major overhaul.
+	 */
 	error = scsi_setup_command_freelist(shost);
 	if (error)
-		goto fail;
+		goto out_destroy_tags;
+
 
 	if (!shost->shost_gendev.parent)
 		shost->shost_gendev.parent = dev ? dev : &platform_bus;
@@ -226,7 +241,7 @@ int scsi_add_host_with_dma(struct Scsi_Host *shost, struct device *dev,
 
 	error = device_add(&shost->shost_gendev);
 	if (error)
-		goto out;
+		goto out_destroy_freelist;
 
 	pm_runtime_set_active(&shost->shost_gendev);
 	pm_runtime_enable(&shost->shost_gendev);
@@ -279,8 +294,11 @@ int scsi_add_host_with_dma(struct Scsi_Host *shost, struct device *dev,
 	device_del(&shost->shost_dev);
  out_del_gendev:
 	device_del(&shost->shost_gendev);
- out:
+ out_destroy_freelist:
 	scsi_destroy_command_freelist(shost);
+ out_destroy_tags:
+	if (shost_use_blk_mq(shost))
+		scsi_mq_destroy_tags(shost);
  fail:
 	return error;
 }
@@ -309,8 +327,13 @@ static void scsi_host_dev_release(struct device *dev)
 	}
 
 	scsi_destroy_command_freelist(shost);
-	if (shost->bqt)
-		blk_free_tags(shost->bqt);
+	if (shost_use_blk_mq(shost)) {
+		if (shost->tag_set.tags)
+			scsi_mq_destroy_tags(shost);
+	} else {
+		if (shost->bqt)
+			blk_free_tags(shost->bqt);
+	}
 
 	kfree(shost->shost_data);
 
@@ -436,6 +459,8 @@ struct Scsi_Host *scsi_host_alloc(struct scsi_host_template *sht, int privsize)
 	else
 		shost->dma_boundary = 0xffffffff;
 
+	shost->use_blk_mq = scsi_use_blk_mq && !shost->hostt->disable_blk_mq;
+
 	device_initialize(&shost->shost_gendev);
 	dev_set_name(&shost->shost_gendev, "host%d", shost->host_no);
 	shost->shost_gendev.bus = &scsi_bus_type;

commit 91921e016a2199e7afe5933c94bd9f723d946598
Author: Hannes Reinecke <hare@suse.de>
Date:   Wed Jun 25 16:39:59 2014 +0200

    scsi: use dev_printk variants where possible
    
    Using dev_printk variants prefixes the logging message with
    the originating device, which makes debugging easier.
    
    Signed-off-by: Hannes Reinecke <hare@suse.de>
    Reviewed-by: Martin K. Petersen <martin.petersen@oracle.com>
    Reviewed-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Christoph Hellwig <hch@lst.de>

diff --git a/drivers/scsi/hosts.c b/drivers/scsi/hosts.c
index 3cbb57a8b846..0632eee82620 100644
--- a/drivers/scsi/hosts.c
+++ b/drivers/scsi/hosts.c
@@ -204,12 +204,12 @@ int scsi_add_host_with_dma(struct Scsi_Host *shost, struct device *dev,
 	struct scsi_host_template *sht = shost->hostt;
 	int error = -EINVAL;
 
-	printk(KERN_INFO "scsi%d : %s\n", shost->host_no,
+	shost_printk(KERN_INFO, shost, "%s\n",
 			sht->info ? sht->info(shost) : sht->name);
 
 	if (!shost->can_queue) {
-		printk(KERN_ERR "%s: can_queue = 0 no longer supported\n",
-				sht->name);
+		shost_printk(KERN_ERR, shost,
+			     "can_queue = 0 no longer supported\n");
 		goto fail;
 	}
 
@@ -450,8 +450,9 @@ struct Scsi_Host *scsi_host_alloc(struct scsi_host_template *sht, int privsize)
 	shost->ehandler = kthread_run(scsi_error_handler, shost,
 			"scsi_eh_%d", shost->host_no);
 	if (IS_ERR(shost->ehandler)) {
-		printk(KERN_WARNING "scsi%d: error handler thread failed to spawn, error = %ld\n",
-			shost->host_no, PTR_ERR(shost->ehandler));
+		shost_printk(KERN_WARNING, shost,
+			"error handler thread failed to spawn, error = %ld\n",
+			PTR_ERR(shost->ehandler));
 		goto fail_kfree;
 	}
 
@@ -584,7 +585,7 @@ EXPORT_SYMBOL(scsi_is_host_device);
 int scsi_queue_work(struct Scsi_Host *shost, struct work_struct *work)
 {
 	if (unlikely(!shost->work_q)) {
-		printk(KERN_ERR
+		shost_printk(KERN_ERR, shost,
 			"ERROR: Scsi host '%s' attempted to queue scsi-work, "
 			"when no workqueue created.\n", shost->hostt->name);
 		dump_stack();
@@ -603,7 +604,7 @@ EXPORT_SYMBOL_GPL(scsi_queue_work);
 void scsi_flush_work(struct Scsi_Host *shost)
 {
 	if (!shost->work_q) {
-		printk(KERN_ERR
+		shost_printk(KERN_ERR, shost,
 			"ERROR: Scsi host '%s' attempted to flush scsi-work, "
 			"when no workqueue created.\n", shost->hostt->name);
 		dump_stack();

commit ad469a57643b322dc7a3bfc482e265e1e88f735a
Author: Hannes Reinecke <hare@suse.de>
Date:   Fri Jan 17 16:05:38 2014 +0100

    [SCSI] scsi_error: disable eh_deadline if no host_reset_handler is set
    
    When the host template doesn't declare an eh_host_reset_handler
    the eh_deadline mechanism is pointless and will set the
    device to offline. So disable eh_deadline if no
    eh_host_reset_handler is present.
    
    Signed-off-by: Hannes Reinecke <hare@suse.de>
    Signed-off-by: James Bottomley <JBottomley@Parallels.com>

diff --git a/drivers/scsi/hosts.c b/drivers/scsi/hosts.c
index f28ea070d3df..3cbb57a8b846 100644
--- a/drivers/scsi/hosts.c
+++ b/drivers/scsi/hosts.c
@@ -398,7 +398,7 @@ struct Scsi_Host *scsi_host_alloc(struct scsi_host_template *sht, int privsize)
 	shost->ordered_tag = sht->ordered_tag;
 	shost->no_write_same = sht->no_write_same;
 
-	if (shost_eh_deadline == -1)
+	if (shost_eh_deadline == -1 || !sht->eh_host_reset_handler)
 		shost->eh_deadline = -1;
 	else if ((ulong) shost_eh_deadline * HZ > INT_MAX) {
 		shost_printk(KERN_WARNING, shost,

commit bb3b621a33d60fc2baddf31597ade01243e00a2c
Author: Ren Mingxin <renmx@cn.fujitsu.com>
Date:   Mon Nov 11 13:44:56 2013 +0100

    [SCSI] Set the minimum valid value of 'eh_deadline' as 0
    
    The former minimum valid value of 'eh_deadline' is 1s, which means
    the earliest occasion to shorten EH is 1 second later since a
    command is failed or timed out. But if we want to skip EH steps
    ASAP, we have to wait until the first EH step is finished. If the
    duration of the first EH step is long, this waiting time is
    excruciating. So, it is necessary to accept 0 as the minimum valid
    value for 'eh_deadline'.
    
    According to my test, with Hannes' patchset 'New EH command timeout
    handler' as well, the minimum IO time is improved from 73s
    (eh_deadline = 1) to 43s(eh_deadline = 0) when commands are timed
    out by disabling RSCN and target port.
    
    Signed-off-by: Ren Mingxin <renmx@cn.fujitsu.com>
    Signed-off-by: Hannes Reinecke <hare@suse.de>
    Signed-off-by: James Bottomley <JBottomley@Parallels.com>

diff --git a/drivers/scsi/hosts.c b/drivers/scsi/hosts.c
index c3ab093dd8a7..f28ea070d3df 100644
--- a/drivers/scsi/hosts.c
+++ b/drivers/scsi/hosts.c
@@ -319,11 +319,11 @@ static void scsi_host_dev_release(struct device *dev)
 	kfree(shost);
 }
 
-static unsigned int shost_eh_deadline;
+static int shost_eh_deadline = -1;
 
-module_param_named(eh_deadline, shost_eh_deadline, uint, S_IRUGO|S_IWUSR);
+module_param_named(eh_deadline, shost_eh_deadline, int, S_IRUGO|S_IWUSR);
 MODULE_PARM_DESC(eh_deadline,
-		 "SCSI EH timeout in seconds (should be between 1 and 2^32-1)");
+		 "SCSI EH timeout in seconds (should be between 0 and 2^31-1)");
 
 static struct device_type scsi_host_type = {
 	.name =		"scsi_host",
@@ -396,9 +396,18 @@ struct Scsi_Host *scsi_host_alloc(struct scsi_host_template *sht, int privsize)
 	shost->unchecked_isa_dma = sht->unchecked_isa_dma;
 	shost->use_clustering = sht->use_clustering;
 	shost->ordered_tag = sht->ordered_tag;
-	shost->eh_deadline = shost_eh_deadline * HZ;
 	shost->no_write_same = sht->no_write_same;
 
+	if (shost_eh_deadline == -1)
+		shost->eh_deadline = -1;
+	else if ((ulong) shost_eh_deadline * HZ > INT_MAX) {
+		shost_printk(KERN_WARNING, shost,
+			     "eh_deadline %u too large, setting to %u\n",
+			     shost_eh_deadline, INT_MAX / HZ);
+		shost->eh_deadline = INT_MAX;
+	} else
+		shost->eh_deadline = shost_eh_deadline * HZ;
+
 	if (sht->supported_mode == MODE_UNKNOWN)
 		/* means we didn't set it ... default to INITIATOR */
 		shost->active_mode = MODE_INITIATOR;

commit e494f6a728394ab0df194342549ee20e6f0752df
Author: Hannes Reinecke <hare@suse.de>
Date:   Mon Nov 11 13:44:54 2013 +0100

    [SCSI] improved eh timeout handler
    
    When a command runs into a timeout we need to send an 'ABORT TASK'
    TMF. This is typically done by the 'eh_abort_handler' LLDD callback.
    
    Conceptually, however, this function is a normal SCSI command, so
    there is no need to enter the error handler.
    
    This patch implements a new scsi_abort_command() function which
    invokes an asynchronous function scsi_eh_abort_handler() to
    abort the commands via the usual 'eh_abort_handler'.
    
    If abort succeeds the command is either retried or terminated,
    depending on the number of allowed retries. However, 'eh_eflags'
    records the abort, so if the retry would fail again the
    command is pushed onto the error handler without trying to
    abort it (again); it'll be cleared up from SCSI EH.
    
    [hare: smatch detected stray switch fixed]
    Signed-off-by: Hannes Reinecke <hare@suse.de>
    Signed-off-by: James Bottomley <JBottomley@Parallels.com>

diff --git a/drivers/scsi/hosts.c b/drivers/scsi/hosts.c
index f2c5005f312a..c3ab093dd8a7 100644
--- a/drivers/scsi/hosts.c
+++ b/drivers/scsi/hosts.c
@@ -169,6 +169,7 @@ void scsi_remove_host(struct Scsi_Host *shost)
 	spin_unlock_irqrestore(shost->host_lock, flags);
 
 	scsi_autopm_get_host(shost);
+	flush_workqueue(shost->tmf_work_q);
 	scsi_forget_host(shost);
 	mutex_unlock(&shost->scan_mutex);
 	scsi_proc_host_rm(shost);
@@ -294,6 +295,8 @@ static void scsi_host_dev_release(struct device *dev)
 
 	scsi_proc_hostdir_rm(shost->hostt);
 
+	if (shost->tmf_work_q)
+		destroy_workqueue(shost->tmf_work_q);
 	if (shost->ehandler)
 		kthread_stop(shost->ehandler);
 	if (shost->work_q)
@@ -360,7 +363,6 @@ struct Scsi_Host *scsi_host_alloc(struct scsi_host_template *sht, int privsize)
 	INIT_LIST_HEAD(&shost->eh_cmd_q);
 	INIT_LIST_HEAD(&shost->starved_list);
 	init_waitqueue_head(&shost->host_wait);
-
 	mutex_init(&shost->scan_mutex);
 
 	/*
@@ -444,9 +446,19 @@ struct Scsi_Host *scsi_host_alloc(struct scsi_host_template *sht, int privsize)
 		goto fail_kfree;
 	}
 
+	shost->tmf_work_q = alloc_workqueue("scsi_tmf_%d",
+					    WQ_UNBOUND | WQ_MEM_RECLAIM,
+					   1, shost->host_no);
+	if (!shost->tmf_work_q) {
+		printk(KERN_WARNING "scsi%d: failed to create tmf workq\n",
+		       shost->host_no);
+		goto fail_kthread;
+	}
 	scsi_proc_hostdir_add(shost->hostt);
 	return shost;
 
+ fail_kthread:
+	kthread_stop(shost->ehandler);
  fail_kfree:
 	kfree(shost);
 	return NULL;

commit 54b2b50c20a61b51199bedb6e5d2f8ec2568fb43
Author: Martin K. Petersen <martin.petersen@oracle.com>
Date:   Wed Oct 23 06:25:40 2013 -0400

    [SCSI] Disable WRITE SAME for RAID and virtual host adapter drivers
    
    Some host adapters do not pass commands through to the target disk
    directly. Instead they provide an emulated target which may or may not
    accurately report its capabilities. In some cases the physical device
    characteristics are reported even when the host adapter is processing
    commands on the device's behalf. This can lead to adapter firmware hangs
    or excessive I/O errors.
    
    This patch disables WRITE SAME for devices connected to host adapters
    that provide an emulated target. Driver writers can disable WRITE SAME
    by setting the no_write_same flag in the host adapter template.
    
    [jejb: fix up rejections due to eh_deadline patch]
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>
    Cc: stable@kernel.org
    Signed-off-by: James Bottomley <JBottomley@Parallels.com>

diff --git a/drivers/scsi/hosts.c b/drivers/scsi/hosts.c
index f334859024c0..f2c5005f312a 100644
--- a/drivers/scsi/hosts.c
+++ b/drivers/scsi/hosts.c
@@ -395,6 +395,7 @@ struct Scsi_Host *scsi_host_alloc(struct scsi_host_template *sht, int privsize)
 	shost->use_clustering = sht->use_clustering;
 	shost->ordered_tag = sht->ordered_tag;
 	shost->eh_deadline = shost_eh_deadline * HZ;
+	shost->no_write_same = sht->no_write_same;
 
 	if (sht->supported_mode == MODE_UNKNOWN)
 		/* means we didn't set it ... default to INITIATOR */

commit b45620229dd67ff1daffa8adce57f37b37860f78
Author: Hannes Reinecke <hare@suse.de>
Date:   Wed Oct 23 10:51:21 2013 +0200

    [SCSI] Add 'eh_deadline' to limit SCSI EH runtime
    
    This patchs adds an 'eh_deadline' sysfs attribute to the scsi
    host which limits the overall runtime of the SCSI EH.
    The 'eh_deadline' value is stored in the now obsolete field
    'resetting'.
    When a command is failed the start time of the EH is stored
    in 'last_reset'. If the overall runtime of the SCSI EH is longer
    than last_reset + eh_deadline, the EH is short-circuited and
    falls through to issue a host reset only.
    
    [jejb: add comments in Scsi_Host about new fields]
    Signed-off-by: Hannes Reinecke <hare@suse.de>
    Signed-off-by: James Bottomley <JBottomley@Parallels.com>

diff --git a/drivers/scsi/hosts.c b/drivers/scsi/hosts.c
index df0c3c71ea43..f334859024c0 100644
--- a/drivers/scsi/hosts.c
+++ b/drivers/scsi/hosts.c
@@ -316,6 +316,12 @@ static void scsi_host_dev_release(struct device *dev)
 	kfree(shost);
 }
 
+static unsigned int shost_eh_deadline;
+
+module_param_named(eh_deadline, shost_eh_deadline, uint, S_IRUGO|S_IWUSR);
+MODULE_PARM_DESC(eh_deadline,
+		 "SCSI EH timeout in seconds (should be between 1 and 2^32-1)");
+
 static struct device_type scsi_host_type = {
 	.name =		"scsi_host",
 	.release =	scsi_host_dev_release,
@@ -388,6 +394,7 @@ struct Scsi_Host *scsi_host_alloc(struct scsi_host_template *sht, int privsize)
 	shost->unchecked_isa_dma = sht->unchecked_isa_dma;
 	shost->use_clustering = sht->use_clustering;
 	shost->ordered_tag = sht->ordered_tag;
+	shost->eh_deadline = shost_eh_deadline * HZ;
 
 	if (sht->supported_mode == MODE_UNKNOWN)
 		/* means we didn't set it ... default to INITIATOR */

commit 9f3b795a626ee79574595e06d1437fe0c7d51d29
Author: Micha≈Ç Miros≈Çaw <mirq-linux@rere.qmqm.pl>
Date:   Fri Feb 1 20:40:17 2013 +0100

    driver-core: constify data for class_find_device()
    
    All in-kernel users of class_find_device() don't really need mutable
    data for match callback.
    
    In two places (kernel/power/suspend_test.c, drivers/scsi/osd/osd_uld.c)
    this patch changes match callbacks to use const search data.
    
    The const is propagated to rtc_class_open() and power_supply_get_by_name()
    parameters.
    
    Note that there's a dev reference leak in suspend_test.c that's not
    touched in this patch.
    
    Signed-off-by: Micha≈Ç Miros≈Çaw <mirq-linux@rere.qmqm.pl>
    Acked-by: Grant Likely <grant.likely@secretlab.ca>
    Signed-off-by: Greg Kroah-Hartman <gregkh@linuxfoundation.org>

diff --git a/drivers/scsi/hosts.c b/drivers/scsi/hosts.c
index 593085a52275..df0c3c71ea43 100644
--- a/drivers/scsi/hosts.c
+++ b/drivers/scsi/hosts.c
@@ -468,10 +468,10 @@ void scsi_unregister(struct Scsi_Host *shost)
 }
 EXPORT_SYMBOL(scsi_unregister);
 
-static int __scsi_host_match(struct device *dev, void *data)
+static int __scsi_host_match(struct device *dev, const void *data)
 {
 	struct Scsi_Host *p;
-	unsigned short *hostnum = (unsigned short *)data;
+	const unsigned short *hostnum = data;
 
 	p = class_to_shost(dev);
 	return p->host_no == *hostnum;

commit 67bd94130015c507011af37858989b199c52e1de
Author: Bart Van Assche <bvanassche@acm.org>
Date:   Fri Jun 29 15:33:22 2012 +0000

    [SCSI] Fix device removal NULL pointer dereference
    
    Use blk_queue_dead() to test whether the queue is dead instead
    of !sdev. Since scsi_prep_fn() may be invoked concurrently with
    __scsi_remove_device(), keep the queuedata (sdev) pointer in
    __scsi_remove_device(). This patch fixes a kernel oops that
    can be triggered by USB device removal. See also
    http://www.spinics.net/lists/linux-scsi/msg56254.html.
    
    Other changes included in this patch:
    - Swap the blk_cleanup_queue() and kfree() calls in
      scsi_host_dev_release() to make that code easier to grasp.
    - Remove the queue dead check from scsi_run_queue() since the
      queue state can change anyway at any point in that function
      where the queue lock is not held.
    - Remove the queue dead check from the start of scsi_request_fn()
      since it is redundant with the scsi_device_online() check.
    
    Reported-by: Jun'ichi Nomura <j-nomura@ce.jp.nec.com>
    Signed-off-by: Bart Van Assche <bvanassche@acm.org>
    Reviewed-by: Mike Christie <michaelc@cs.wisc.edu>
    Reviewed-by: Tejun Heo <tj@kernel.org>
    Cc: <stable@kernel.org>
    Signed-off-by: James Bottomley <JBottomley@Parallels.com>

diff --git a/drivers/scsi/hosts.c b/drivers/scsi/hosts.c
index 2b6a03de5787..593085a52275 100644
--- a/drivers/scsi/hosts.c
+++ b/drivers/scsi/hosts.c
@@ -290,6 +290,7 @@ static void scsi_host_dev_release(struct device *dev)
 	struct Scsi_Host *shost = dev_to_shost(dev);
 	struct device *parent = dev->parent;
 	struct request_queue *q;
+	void *queuedata;
 
 	scsi_proc_hostdir_rm(shost->hostt);
 
@@ -299,9 +300,9 @@ static void scsi_host_dev_release(struct device *dev)
 		destroy_workqueue(shost->work_q);
 	q = shost->uspace_req_q;
 	if (q) {
-		kfree(q->queuedata);
-		q->queuedata = NULL;
-		scsi_free_queue(q);
+		queuedata = q->queuedata;
+		blk_cleanup_queue(q);
+		kfree(queuedata);
 	}
 
 	scsi_destroy_command_freelist(shost);

commit 9e1a15376bce2fc7746145eb8ee78a3674658bc8
Author: Josh Hunt <johunt@akamai.com>
Date:   Sat Jun 9 07:03:39 2012 -0700

    [SCSI] properly initialize atomic_t
    
    Initialize atomic_t scsi_host_next_hn and ioerr_cntas per the guidelines
    defined in Documentation/atomic_ops.txt
    
    Signed-off-by: Josh Hunt <johunt@akamai.com>
    Signed-off-by: James Bottomley <JBottomley@Parallels.com>

diff --git a/drivers/scsi/hosts.c b/drivers/scsi/hosts.c
index a3a056a9db67..2b6a03de5787 100644
--- a/drivers/scsi/hosts.c
+++ b/drivers/scsi/hosts.c
@@ -42,7 +42,7 @@
 #include "scsi_logging.h"
 
 
-static atomic_t scsi_host_next_hn;	/* host_no for next new host */
+static atomic_t scsi_host_next_hn = ATOMIC_INIT(0);	/* host_no for next new host */
 
 
 static void scsi_host_cls_release(struct device *dev)

commit 3c8d9a957d0ae62c2815393a781ab7ff4d5205e7
Author: James Bottomley <jbottomley@parallels.com>
Date:   Fri May 4 09:40:04 2012 +0000

    [SCSI] fix oops in all legacy host adapters caused by 6f381fa
    
    Commit 6f381fa344911d5a234b13574433cf23036f9467
    Author: Lin Ming <ming.m.lin@intel.com>
    
    [SCSI] scsi_lib: use correct DMA device in __scsi_alloc_queue
    
    Caused a regression where we oops in every legacy mode SCSI host driver
    because they supply a NULL pointer to scsi_add_host().  Fix this by checking
    for the NULL in scsi_add_host_with_dma() and changing the DMA device to being
    the platform_bus in that case (which replicates the original behaviour).
    
    Reported-by: Al Viro <viro@zeniv.linux.org.uk>
    Signed-off-by: James Bottomley <JBottomley@Parallels.com>

diff --git a/drivers/scsi/hosts.c b/drivers/scsi/hosts.c
index 351dc0b86fab..a3a056a9db67 100644
--- a/drivers/scsi/hosts.c
+++ b/drivers/scsi/hosts.c
@@ -218,6 +218,9 @@ int scsi_add_host_with_dma(struct Scsi_Host *shost, struct device *dev,
 
 	if (!shost->shost_gendev.parent)
 		shost->shost_gendev.parent = dev ? dev : &platform_bus;
+	if (!dma_dev)
+		dma_dev = shost->shost_gendev.parent;
+
 	shost->dma_dev = dma_dev;
 
 	error = device_add(&shost->shost_gendev);

commit 3308511c93e6ad0d3c58984ecd6e5e57f96b12c8
Author: Bart Van Assche <bvanassche@acm.org>
Date:   Fri Sep 23 19:48:18 2011 +0200

    [SCSI] Make scsi_free_queue() kill pending SCSI commands
    
    Make sure that SCSI device removal via scsi_remove_host() does finish
    all pending SCSI commands. Currently that's not the case and hence
    removal of a SCSI host during I/O can cause a deadlock. See also
    "blkdev_issue_discard() hangs forever if underlying storage device is
    removed" (http://bugzilla.kernel.org/show_bug.cgi?id=40472). See also
    http://lkml.org/lkml/2011/8/27/6.
    
    Signed-off-by: Bart Van Assche <bvanassche@acm.org>
    Cc: <stable@kernel.org>
    Signed-off-by: James Bottomley <JBottomley@Parallels.com>

diff --git a/drivers/scsi/hosts.c b/drivers/scsi/hosts.c
index 4f7a5829ea4c..351dc0b86fab 100644
--- a/drivers/scsi/hosts.c
+++ b/drivers/scsi/hosts.c
@@ -286,6 +286,7 @@ static void scsi_host_dev_release(struct device *dev)
 {
 	struct Scsi_Host *shost = dev_to_shost(dev);
 	struct device *parent = dev->parent;
+	struct request_queue *q;
 
 	scsi_proc_hostdir_rm(shost->hostt);
 
@@ -293,9 +294,11 @@ static void scsi_host_dev_release(struct device *dev)
 		kthread_stop(shost->ehandler);
 	if (shost->work_q)
 		destroy_workqueue(shost->work_q);
-	if (shost->uspace_req_q) {
-		kfree(shost->uspace_req_q->queuedata);
-		scsi_free_queue(shost->uspace_req_q);
+	q = shost->uspace_req_q;
+	if (q) {
+		kfree(q->queuedata);
+		q->queuedata = NULL;
+		scsi_free_queue(q);
 	}
 
 	scsi_destroy_command_freelist(shost);

commit b9da0571050c09863e59f94d0b8594a290d61b88
Merge: f8cae0f03f75 5abd935661e0
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Fri Oct 22 19:36:42 2010 -0700

    Merge git://git.kernel.org/pub/scm/linux/kernel/git/gregkh/driver-core-2.6
    
    * git://git.kernel.org/pub/scm/linux/kernel/git/gregkh/driver-core-2.6: (31 commits)
      driver core: Display error codes when class suspend fails
      Driver core: Add section count to memory_block struct
      Driver core: Add mutex for adding/removing memory blocks
      Driver core: Move find_memory_block routine
      hpilo: Despecificate driver from iLO generation
      driver core: Convert link_mem_sections to use find_memory_block_hinted.
      driver core: Introduce find_memory_block_hinted which utilizes kset_find_obj_hinted.
      kobject: Introduce kset_find_obj_hinted.
      driver core: fix build for CONFIG_BLOCK not enabled
      driver-core: base: change to new flag variable
      sysfs: only access bin file vm_ops with the active lock
      sysfs: Fail bin file mmap if vma close is implemented.
      FW_LOADER: fix kconfig dependency warning on HOTPLUG
      uio: Statically allocate uio_class and use class .dev_attrs.
      uio: Support 2^MINOR_BITS minors
      uio: Cleanup irq handling.
      uio: Don't clear driver data
      uio: Fix lack of locking in init_uio_class
      SYSFS: Allow boot time switching between deprecated and modern sysfs layout
      driver core: remove CONFIG_SYSFS_DEPRECATED_V2 but keep it for block devices
      ...

commit 39aba963d937edb20db7d9d93e6dda5d2adfdcdd
Author: Kay Sievers <kay.sievers@vrfy.org>
Date:   Sat Sep 4 22:33:14 2010 -0700

    driver core: remove CONFIG_SYSFS_DEPRECATED_V2 but keep it for block devices
    
    This patch removes the old CONFIG_SYSFS_DEPRECATED_V2 config option,
    but it keeps the logic around to handle block devices in the old manner
    as some people like to run new kernel versions on old (pre 2007/2008)
    distros.
    
    Signed-off-by: Kay Sievers <kay.sievers@vrfy.org>
    Cc: Jens Axboe <axboe@kernel.dk>
    Cc: Stephen Hemminger <shemminger@vyatta.com>
    Cc: "Eric W. Biederman" <ebiederm@xmission.com>
    Cc: Alan Stern <stern@rowland.harvard.edu>
    Cc: "James E.J. Bottomley" <James.Bottomley@suse.de>
    Cc: Andrew Morton <akpm@linux-foundation.org>
    Cc: Alexey Kuznetsov <kuznet@ms2.inr.ac.ru>
    Cc: Randy Dunlap <randy.dunlap@oracle.com>
    Cc: Tejun Heo <tj@kernel.org>
    Cc: "David S. Miller" <davem@davemloft.net>
    Cc: Jaroslav Kysela <perex@perex.cz>
    Cc: Takashi Iwai <tiwai@suse.de>
    Cc: Ingo Molnar <mingo@elte.hu>
    Cc: Peter Zijlstra <a.p.zijlstra@chello.nl>
    Cc: David Howells <dhowells@redhat.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/scsi/hosts.c b/drivers/scsi/hosts.c
index 8a8f803439e1..ba7f87acc00d 100644
--- a/drivers/scsi/hosts.c
+++ b/drivers/scsi/hosts.c
@@ -411,9 +411,7 @@ struct Scsi_Host *scsi_host_alloc(struct scsi_host_template *sht, int privsize)
 
 	device_initialize(&shost->shost_gendev);
 	dev_set_name(&shost->shost_gendev, "host%d", shost->host_no);
-#ifndef CONFIG_SYSFS_DEPRECATED
 	shost->shost_gendev.bus = &scsi_bus_type;
-#endif
 	shost->shost_gendev.type = &scsi_host_type;
 
 	device_initialize(&shost->shost_dev);

commit 13f05c8d8e98bbdce89158bfdb2e380940695a88
Author: Martin K. Petersen <martin.petersen@oracle.com>
Date:   Fri Sep 10 20:50:10 2010 +0200

    block/scsi: Provide a limit on the number of integrity segments
    
    Some controllers have a hardware limit on the number of protection
    information scatter-gather list segments they can handle.
    
    Introduce a max_integrity_segments limit in the block layer and provide
    a new scsi_host_template setting that allows HBA drivers to provide a
    value suitable for the hardware.
    
    Add support for honoring the integrity segment limit when merging both
    bios and requests.
    
    Signed-off-by: Martin K. Petersen <martin.petersen@oracle.com>
    Signed-off-by: Jens Axboe <axboe@carl.home.kernel.dk>

diff --git a/drivers/scsi/hosts.c b/drivers/scsi/hosts.c
index 8a8f803439e1..10478153641b 100644
--- a/drivers/scsi/hosts.c
+++ b/drivers/scsi/hosts.c
@@ -376,6 +376,7 @@ struct Scsi_Host *scsi_host_alloc(struct scsi_host_template *sht, int privsize)
 	shost->this_id = sht->this_id;
 	shost->can_queue = sht->can_queue;
 	shost->sg_tablesize = sht->sg_tablesize;
+	shost->sg_prot_tablesize = sht->sg_prot_tablesize;
 	shost->cmd_per_lun = sht->cmd_per_lun;
 	shost->unchecked_isa_dma = sht->unchecked_isa_dma;
 	shost->use_clustering = sht->use_clustering;

commit bc4f24014de58f045f169742701a6598884d93db
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Thu Jun 17 10:41:42 2010 -0400

    [SCSI] implement runtime Power Management
    
    This patch (as1398b) adds runtime PM support to the SCSI layer.  Only
    the machanism is provided; use of it is up to the various high-level
    drivers, and the patch doesn't change any of them.  Except for sg --
    the patch expicitly prevents a device from being runtime-suspended
    while its sg device file is open.
    
    The implementation is simplistic.  In general, hosts and targets are
    automatically suspended when all their children are asleep, but for
    them the runtime-suspend code doesn't actually do anything.  (A host's
    runtime PM status is propagated up the device tree, though, so a
    runtime-PM-aware lower-level driver could power down the host adapter
    hardware at the appropriate times.)  There are comments indicating
    where a transport class might be notified or some other hooks added.
    
    LUNs are runtime-suspended by calling the drivers' existing suspend
    handlers (and likewise for runtime-resume).  Somewhat arbitrarily, the
    implementation delays for 100 ms before suspending an eligible LUN.
    This is because there typically are occasions during bootup when the
    same device file is opened and closed several times in quick
    succession.
    
    The way this all works is that the SCSI core increments a device's
    PM-usage count when it is registered.  If a high-level driver does
    nothing then the device will not be eligible for runtime-suspend
    because of the elevated usage count.  If a high-level driver wants to
    use runtime PM then it can call scsi_autopm_put_device() in its probe
    routine to decrement the usage count and scsi_autopm_get_device() in
    its remove routine to restore the original count.
    
    Hosts, targets, and LUNs are not suspended while they are being probed
    or removed, or while the error handler is running.  In fact, a fairly
    large part of the patch consists of code to make sure that things
    aren't suspended at such times.
    
    [jejb: fix up compile issues in PM config variations]
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: James Bottomley <James.Bottomley@suse.de>

diff --git a/drivers/scsi/hosts.c b/drivers/scsi/hosts.c
index a2b1414da288..8a8f803439e1 100644
--- a/drivers/scsi/hosts.c
+++ b/drivers/scsi/hosts.c
@@ -32,6 +32,7 @@
 #include <linux/completion.h>
 #include <linux/transport_class.h>
 #include <linux/platform_device.h>
+#include <linux/pm_runtime.h>
 
 #include <scsi/scsi_device.h>
 #include <scsi/scsi_host.h>
@@ -156,6 +157,7 @@ EXPORT_SYMBOL(scsi_host_set_state);
 void scsi_remove_host(struct Scsi_Host *shost)
 {
 	unsigned long flags;
+
 	mutex_lock(&shost->scan_mutex);
 	spin_lock_irqsave(shost->host_lock, flags);
 	if (scsi_host_set_state(shost, SHOST_CANCEL))
@@ -165,6 +167,8 @@ void scsi_remove_host(struct Scsi_Host *shost)
 			return;
 		}
 	spin_unlock_irqrestore(shost->host_lock, flags);
+
+	scsi_autopm_get_host(shost);
 	scsi_forget_host(shost);
 	mutex_unlock(&shost->scan_mutex);
 	scsi_proc_host_rm(shost);
@@ -216,12 +220,14 @@ int scsi_add_host_with_dma(struct Scsi_Host *shost, struct device *dev,
 		shost->shost_gendev.parent = dev ? dev : &platform_bus;
 	shost->dma_dev = dma_dev;
 
-	device_enable_async_suspend(&shost->shost_gendev);
-
 	error = device_add(&shost->shost_gendev);
 	if (error)
 		goto out;
 
+	pm_runtime_set_active(&shost->shost_gendev);
+	pm_runtime_enable(&shost->shost_gendev);
+	device_enable_async_suspend(&shost->shost_gendev);
+
 	scsi_host_set_state(shost, SHOST_RUNNING);
 	get_device(shost->shost_gendev.parent);
 

commit e4bf25fbcc64a87d7dc1d3318ca56c28382757e2
Author: Justin P. Mattock <justinmattock@gmail.com>
Date:   Fri Jun 18 13:16:07 2010 -0700

    [SCSI] scsi:hosts.c Fix warning: variable 'rval' set but not used
    
    The below patch fixes a warning message generated by gcc 4.6.0
      CC      drivers/scsi/hosts.o
    drivers/scsi/hosts.c: In function 'scsi_host_alloc':
    drivers/scsi/hosts.c:328:6: warning: variable 'rval' set but not used
    
    Fix this by removing the rval but placing a printk warning where it
    would have been set.
    
    Signed-off-by: Justin P. Mattock <justinmattock@gmail.com>
    Signed-off-by: James Bottomley <James.Bottomley@suse.de>

diff --git a/drivers/scsi/hosts.c b/drivers/scsi/hosts.c
index 6660fa92ffa1..a2b1414da288 100644
--- a/drivers/scsi/hosts.c
+++ b/drivers/scsi/hosts.c
@@ -325,7 +325,6 @@ struct Scsi_Host *scsi_host_alloc(struct scsi_host_template *sht, int privsize)
 {
 	struct Scsi_Host *shost;
 	gfp_t gfp_mask = GFP_KERNEL;
-	int rval;
 
 	if (sht->unchecked_isa_dma && privsize)
 		gfp_mask |= __GFP_DMA;
@@ -420,7 +419,8 @@ struct Scsi_Host *scsi_host_alloc(struct scsi_host_template *sht, int privsize)
 	shost->ehandler = kthread_run(scsi_error_handler, shost,
 			"scsi_eh_%d", shost->host_no);
 	if (IS_ERR(shost->ehandler)) {
-		rval = PTR_ERR(shost->ehandler);
+		printk(KERN_WARNING "scsi%d: error handler thread failed to spawn, error = %ld\n",
+			shost->host_no, PTR_ERR(shost->ehandler));
 		goto fail_kfree;
 	}
 

commit 5a0e3ad6af8660be21ca98a971cd00f331318c05
Author: Tejun Heo <tj@kernel.org>
Date:   Wed Mar 24 17:04:11 2010 +0900

    include cleanup: Update gfp.h and slab.h includes to prepare for breaking implicit slab.h inclusion from percpu.h
    
    percpu.h is included by sched.h and module.h and thus ends up being
    included when building most .c files.  percpu.h includes slab.h which
    in turn includes gfp.h making everything defined by the two files
    universally available and complicating inclusion dependencies.
    
    percpu.h -> slab.h dependency is about to be removed.  Prepare for
    this change by updating users of gfp and slab facilities include those
    headers directly instead of assuming availability.  As this conversion
    needs to touch large number of source files, the following script is
    used as the basis of conversion.
    
      http://userweb.kernel.org/~tj/misc/slabh-sweep.py
    
    The script does the followings.
    
    * Scan files for gfp and slab usages and update includes such that
      only the necessary includes are there.  ie. if only gfp is used,
      gfp.h, if slab is used, slab.h.
    
    * When the script inserts a new include, it looks at the include
      blocks and try to put the new include such that its order conforms
      to its surrounding.  It's put in the include block which contains
      core kernel includes, in the same order that the rest are ordered -
      alphabetical, Christmas tree, rev-Xmas-tree or at the end if there
      doesn't seem to be any matching order.
    
    * If the script can't find a place to put a new include (mostly
      because the file doesn't have fitting include block), it prints out
      an error message indicating which .h file needs to be added to the
      file.
    
    The conversion was done in the following steps.
    
    1. The initial automatic conversion of all .c files updated slightly
       over 4000 files, deleting around 700 includes and adding ~480 gfp.h
       and ~3000 slab.h inclusions.  The script emitted errors for ~400
       files.
    
    2. Each error was manually checked.  Some didn't need the inclusion,
       some needed manual addition while adding it to implementation .h or
       embedding .c file was more appropriate for others.  This step added
       inclusions to around 150 files.
    
    3. The script was run again and the output was compared to the edits
       from #2 to make sure no file was left behind.
    
    4. Several build tests were done and a couple of problems were fixed.
       e.g. lib/decompress_*.c used malloc/free() wrappers around slab
       APIs requiring slab.h to be added manually.
    
    5. The script was run on all .h files but without automatically
       editing them as sprinkling gfp.h and slab.h inclusions around .h
       files could easily lead to inclusion dependency hell.  Most gfp.h
       inclusion directives were ignored as stuff from gfp.h was usually
       wildly available and often used in preprocessor macros.  Each
       slab.h inclusion directive was examined and added manually as
       necessary.
    
    6. percpu.h was updated not to include slab.h.
    
    7. Build test were done on the following configurations and failures
       were fixed.  CONFIG_GCOV_KERNEL was turned off for all tests (as my
       distributed build env didn't work with gcov compiles) and a few
       more options had to be turned off depending on archs to make things
       build (like ipr on powerpc/64 which failed due to missing writeq).
    
       * x86 and x86_64 UP and SMP allmodconfig and a custom test config.
       * powerpc and powerpc64 SMP allmodconfig
       * sparc and sparc64 SMP allmodconfig
       * ia64 SMP allmodconfig
       * s390 SMP allmodconfig
       * alpha SMP allmodconfig
       * um on x86_64 SMP allmodconfig
    
    8. percpu.h modifications were reverted so that it could be applied as
       a separate patch and serve as bisection point.
    
    Given the fact that I had only a couple of failures from tests on step
    6, I'm fairly confident about the coverage of this conversion patch.
    If there is a breakage, it's likely to be something in one of the arch
    headers which should be easily discoverable easily on most builds of
    the specific arch.
    
    Signed-off-by: Tejun Heo <tj@kernel.org>
    Guess-its-ok-by: Christoph Lameter <cl@linux-foundation.org>
    Cc: Ingo Molnar <mingo@redhat.com>
    Cc: Lee Schermerhorn <Lee.Schermerhorn@hp.com>

diff --git a/drivers/scsi/hosts.c b/drivers/scsi/hosts.c
index 09dbcb847b73..6660fa92ffa1 100644
--- a/drivers/scsi/hosts.c
+++ b/drivers/scsi/hosts.c
@@ -24,6 +24,7 @@
 #include <linux/module.h>
 #include <linux/blkdev.h>
 #include <linux/kernel.h>
+#include <linux/slab.h>
 #include <linux/kthread.h>
 #include <linux/string.h>
 #include <linux/mm.h>

commit 4cb077d93a57fb8bb64c277ec4ce637823cd76f4
Author: Rafael J. Wysocki <rjw@sisk.pl>
Date:   Mon Feb 8 19:18:26 2010 +0100

    PM: Allow SCSI devices to suspend/resume asynchronously
    
    Set power.async_suspend for all SCSI devices, targets and hosts, so
    that they can be suspended and resumed in parallel with the main
    suspend/resume thread and possibly with other devices they don't
    depend on in a known way (i.e. devices which are not their parents or
    children).
    
    The power.async_suspend flag is also set for devices that don't have
    suspend or resume callbacks, because otherwise they would make the
    main suspend/resume thread wait for their "asynchronous" children
    (during suspend) or parents (during resume), effectively negating the
    possible gains from executing these devices' suspend and resume
    callbacks asynchronously.
    
    Signed-off-by: Rafael J. Wysocki <rjw@sisk.pl>

diff --git a/drivers/scsi/hosts.c b/drivers/scsi/hosts.c
index 554626e18062..09dbcb847b73 100644
--- a/drivers/scsi/hosts.c
+++ b/drivers/scsi/hosts.c
@@ -215,6 +215,8 @@ int scsi_add_host_with_dma(struct Scsi_Host *shost, struct device *dev,
 		shost->shost_gendev.parent = dev ? dev : &platform_bus;
 	shost->dma_dev = dma_dev;
 
+	device_enable_async_suspend(&shost->shost_gendev);
+
 	error = device_add(&shost->shost_gendev);
 	if (error)
 		goto out;
@@ -222,6 +224,8 @@ int scsi_add_host_with_dma(struct Scsi_Host *shost, struct device *dev,
 	scsi_host_set_state(shost, SHOST_RUNNING);
 	get_device(shost->shost_gendev.parent);
 
+	device_enable_async_suspend(&shost->shost_dev);
+
 	error = device_add(&shost->shost_dev);
 	if (error)
 		goto out_del_gendev;

commit 382f51fe2f2276344d8a21447656778cdf6583b6
Merge: 701791cc3c8f 54987386ee37
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Wed Dec 9 19:42:25 2009 -0800

    Merge git://git.kernel.org/pub/scm/linux/kernel/git/jejb/scsi-misc-2.6
    
    * git://git.kernel.org/pub/scm/linux/kernel/git/jejb/scsi-misc-2.6: (222 commits)
      [SCSI] zfcp: Remove flag ZFCP_STATUS_FSFREQ_TMFUNCNOTSUPP
      [SCSI] zfcp: Activate fc4s attributes for zfcp in FC transport class
      [SCSI] zfcp: Block scsi_eh thread for rport state BLOCKED
      [SCSI] zfcp: Update FSF error reporting
      [SCSI] zfcp: Improve ELS ADISC handling
      [SCSI] zfcp: Simplify handling of ct and els requests
      [SCSI] zfcp: Remove ZFCP_DID_MASK
      [SCSI] zfcp: Move WKA port to zfcp FC code
      [SCSI] zfcp: Use common code definitions for FC CT structs
      [SCSI] zfcp: Use common code definitions for FC ELS structs
      [SCSI] zfcp: Update FCP protocol related code
      [SCSI] zfcp: Dont fail SCSI commands when transitioning to blocked fc_rport
      [SCSI] zfcp: Assign scheduled work to driver queue
      [SCSI] zfcp: Remove STATUS_COMMON_REMOVE flag as it is not required anymore
      [SCSI] zfcp: Implement module unloading
      [SCSI] zfcp: Merge trace code for fsf requests in one function
      [SCSI] zfcp: Access ports and units with container_of in sysfs code
      [SCSI] zfcp: Remove suspend callback
      [SCSI] zfcp: Remove global config_mutex
      [SCSI] zfcp: Replace local reference counting with common kref
      ...

commit d139b9bd0e52dda14fd13412e7096e68b56d0076
Author: James Bottomley <James.Bottomley@suse.de>
Date:   Thu Nov 5 13:33:12 2009 -0600

    [SCSI] scsi_lib_dma: fix bug with dma maps on nested scsi objects
    
    Some of our virtual SCSI hosts don't have a proper bus parent at the
    top, which can be a problem for doing DMA on them
    
    This patch makes the host device cache a pointer to the physical bus
    device and provides an extra API for setting it (the normal API picks
    it up from the parent).  This patch also modifies the qla2xxx and lpfc
    vport logic to use the new DMA host setting API.
    
    Acked-By: James Smart  <james.smart@emulex.com>
    Cc: Stable Tree <stable@kernel.org>
    Signed-off-by: James Bottomley <James.Bottomley@suse.de>

diff --git a/drivers/scsi/hosts.c b/drivers/scsi/hosts.c
index 5fd2da494d08..28a753d796f3 100644
--- a/drivers/scsi/hosts.c
+++ b/drivers/scsi/hosts.c
@@ -180,14 +180,20 @@ void scsi_remove_host(struct Scsi_Host *shost)
 EXPORT_SYMBOL(scsi_remove_host);
 
 /**
- * scsi_add_host - add a scsi host
+ * scsi_add_host_with_dma - add a scsi host with dma device
  * @shost:	scsi host pointer to add
  * @dev:	a struct device of type scsi class
+ * @dma_dev:	dma device for the host
+ *
+ * Note: You rarely need to worry about this unless you're in a
+ * virtualised host environments, so use the simpler scsi_add_host()
+ * function instead.
  *
  * Return value: 
  * 	0 on success / != 0 for error
  **/
-int scsi_add_host(struct Scsi_Host *shost, struct device *dev)
+int scsi_add_host_with_dma(struct Scsi_Host *shost, struct device *dev,
+			   struct device *dma_dev)
 {
 	struct scsi_host_template *sht = shost->hostt;
 	int error = -EINVAL;
@@ -207,6 +213,7 @@ int scsi_add_host(struct Scsi_Host *shost, struct device *dev)
 
 	if (!shost->shost_gendev.parent)
 		shost->shost_gendev.parent = dev ? dev : &platform_bus;
+	shost->dma_dev = dma_dev;
 
 	error = device_add(&shost->shost_gendev);
 	if (error)
@@ -262,7 +269,7 @@ int scsi_add_host(struct Scsi_Host *shost, struct device *dev)
  fail:
 	return error;
 }
-EXPORT_SYMBOL(scsi_add_host);
+EXPORT_SYMBOL(scsi_add_host_with_dma);
 
 static void scsi_host_dev_release(struct device *dev)
 {

commit 4e46bf89972b9d98a9f282a9fed2359756a5e34e
Author: Alexey Kuznetsov <kuznet@ms2.inr.ac.ru>
Date:   Tue Nov 17 14:10:11 2009 -0800

    [SCSI] fix crash when disconnecting usb storage
    
    __scsi_remove_device() in scsi_forget_host() is executed out of scan_mutex
    and races with scsi_destroy_sdev() <- scsi_sysfs_add_devices() <-
    scsi_finish_async_scan().  The result is use after free and/or double
    free, oops.
    
    The fix is simple, move scsi_forget_host() under scan_mutex.
    
    scsi_forget_host() is just sequence of __scsi_remove_device().  All
    another calls of __scsi_remove_device() are made under scan_mutex.  So
    that it is safe.
    
    Signed-off-by: Alexey Kuznetsov <kuznet@ms2.inr.ac.ru>
    Signed-off-by: Denis V. Lunev <den@openvz.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: James Bottomley <James.Bottomley@suse.de>

diff --git a/drivers/scsi/hosts.c b/drivers/scsi/hosts.c
index 5fd2da494d08..c968cc31cd86 100644
--- a/drivers/scsi/hosts.c
+++ b/drivers/scsi/hosts.c
@@ -164,8 +164,8 @@ void scsi_remove_host(struct Scsi_Host *shost)
 			return;
 		}
 	spin_unlock_irqrestore(shost->host_lock, flags);
-	mutex_unlock(&shost->scan_mutex);
 	scsi_forget_host(shost);
+	mutex_unlock(&shost->scan_mutex);
 	scsi_proc_host_rm(shost);
 
 	spin_lock_irqsave(shost->host_lock, flags);

commit 30c9afa6cc477f6f21f8a0b36f3b81080941a0c9
Author: Joe Eykholt <jeykholt@cisco.com>
Date:   Mon Jun 15 23:22:14 2009 -0700

    fix race that can give duplicate host number
    
    Just once, two fcoe instances got the same host number
    from scsi_add_host().
    
    Use atomic_t and atomic_inc_return() to get next host number.
    Subtract 1, so that scsi_host still starts with 0.
    
    [jejb: added comment about unusual subtraction]
    Signed-off-by: Joe Eykholt <jeykholt@cisco.com>
    Signed-off-by: James Bottomley <James.Bottomley@HansenPartnership.com>

diff --git a/drivers/scsi/hosts.c b/drivers/scsi/hosts.c
index 89d41a424b33..5fd2da494d08 100644
--- a/drivers/scsi/hosts.c
+++ b/drivers/scsi/hosts.c
@@ -40,7 +40,7 @@
 #include "scsi_logging.h"
 
 
-static int scsi_host_next_hn;		/* host_no for next new host */
+static atomic_t scsi_host_next_hn;	/* host_no for next new host */
 
 
 static void scsi_host_cls_release(struct device *dev)
@@ -333,7 +333,11 @@ struct Scsi_Host *scsi_host_alloc(struct scsi_host_template *sht, int privsize)
 
 	mutex_init(&shost->scan_mutex);
 
-	shost->host_no = scsi_host_next_hn++; /* XXX(hch): still racy */
+	/*
+	 * subtract one because we increment first then return, but we need to
+	 * know what the next host number was before increment
+	 */
+	shost->host_no = atomic_inc_return(&scsi_host_next_hn) - 1;
 	shost->dma_channel = 0xff;
 
 	/* These three are default values which can be overridden */

commit 77c019768f0607c36e25bec11ce3e1eabef09277
Author: Alan Stern <stern@rowland.harvard.edu>
Date:   Fri Feb 27 16:51:42 2009 -0500

    [SCSI] fix /proc memory leak in the SCSI core
    
    The SCSI core calls scsi_proc_hostdir_add() from within
    scsi_host_alloc(), but the corresponding scsi_proc_hostdir_rm()
    routine is called from within scsi_remove_host().  As a result, if a
    host is allocated and then deallocated without ever being registered,
    the host's directory in /proc is leaked.
    
    This patch (as1181b) fixes this bug in the SCSI core by moving
    scsi_proc_hostdir_rm() into scsi_host_dev_release().
    
    Signed-off-by: Alan Stern <stern@rowland.harvard.edu>
    Signed-off-by: James Bottomley <James.Bottomley@HansenPartnership.com>

diff --git a/drivers/scsi/hosts.c b/drivers/scsi/hosts.c
index aa670a1d1513..89d41a424b33 100644
--- a/drivers/scsi/hosts.c
+++ b/drivers/scsi/hosts.c
@@ -176,7 +176,6 @@ void scsi_remove_host(struct Scsi_Host *shost)
 	transport_unregister_device(&shost->shost_gendev);
 	device_unregister(&shost->shost_dev);
 	device_del(&shost->shost_gendev);
-	scsi_proc_hostdir_rm(shost->hostt);
 }
 EXPORT_SYMBOL(scsi_remove_host);
 
@@ -270,6 +269,8 @@ static void scsi_host_dev_release(struct device *dev)
 	struct Scsi_Host *shost = dev_to_shost(dev);
 	struct device *parent = dev->parent;
 
+	scsi_proc_hostdir_rm(shost->hostt);
+
 	if (shost->ehandler)
 		kthread_stop(shost->ehandler);
 	if (shost->work_q)

commit 71610f55fa4db63dbf5385929a47c9fb2451f332
Author: Kay Sievers <kay.sievers@vrfy.org>
Date:   Wed Dec 3 22:41:36 2008 +0100

    [SCSI] struct device - replace bus_id with dev_name(), dev_set_name()
    
    [jejb: limit ioctl to returning 20 characters to avoid overrun
           on long device names and add a few more conversions]
    Signed-off-by: Kay Sievers <kay.sievers@vrfy.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>
    Signed-off-by: James Bottomley <James.Bottomley@HansenPartnership.com>

diff --git a/drivers/scsi/hosts.c b/drivers/scsi/hosts.c
index 3fdbb13e80a8..aa670a1d1513 100644
--- a/drivers/scsi/hosts.c
+++ b/drivers/scsi/hosts.c
@@ -388,8 +388,7 @@ struct Scsi_Host *scsi_host_alloc(struct scsi_host_template *sht, int privsize)
 		shost->dma_boundary = 0xffffffff;
 
 	device_initialize(&shost->shost_gendev);
-	snprintf(shost->shost_gendev.bus_id, BUS_ID_SIZE, "host%d",
-		shost->host_no);
+	dev_set_name(&shost->shost_gendev, "host%d", shost->host_no);
 #ifndef CONFIG_SYSFS_DEPRECATED
 	shost->shost_gendev.bus = &scsi_bus_type;
 #endif
@@ -398,8 +397,7 @@ struct Scsi_Host *scsi_host_alloc(struct scsi_host_template *sht, int privsize)
 	device_initialize(&shost->shost_dev);
 	shost->shost_dev.parent = &shost->shost_gendev;
 	shost->shost_dev.class = &shost_class;
-	snprintf(shost->shost_dev.bus_id, BUS_ID_SIZE, "host%d",
-		 shost->host_no);
+	dev_set_name(&shost->shost_dev, "host%d", shost->host_no);
 	shost->shost_dev.groups = scsi_sysfs_shost_attr_groups;
 
 	shost->ehandler = kthread_run(scsi_error_handler, shost,

commit 315cb0ad124575e75da2d0e0a95990587fc23485
Author: James Smart <James.Smart@Emulex.Com>
Date:   Thu Aug 7 20:49:30 2008 -0400

    [SCSI] scsi_host_lookup: error returns and NULL pointers
    
    This patch cleans up the behavior of scsi_host_lookup().
    
    The original implementation attempted to use the dual role of
    either returning a pointer value, or a negative error code.
    User's needed to use IS_ERR() to check the result. Additionally,
    the IS_ERR() macro never checks for when a NULL pointer was
    returned, so a NULL pointer actually passes with a success case.
    Note: scsi_host_get(), used by scsi_host_lookup(), can return
    a NULL pointer.
    
    Talk about a mudhole for the unitiated to step into....
    
    This patch converts scsi_host_lookup() to return either NULL
    or a valid pointer. The consumers were updated for the change.
    
    Signed-off-by: James Smart <james.smart@emulex.com>
    Signed-off-by: James Bottomley <James.Bottomley@HansenPartnership.com>

diff --git a/drivers/scsi/hosts.c b/drivers/scsi/hosts.c
index fed0b02ebc1d..3fdbb13e80a8 100644
--- a/drivers/scsi/hosts.c
+++ b/drivers/scsi/hosts.c
@@ -464,7 +464,7 @@ static int __scsi_host_match(struct device *dev, void *data)
 struct Scsi_Host *scsi_host_lookup(unsigned short hostnum)
 {
 	struct device *cdev;
-	struct Scsi_Host *shost = ERR_PTR(-ENXIO);
+	struct Scsi_Host *shost = NULL;
 
 	cdev = class_find_device(&shost_class, NULL, &hostnum,
 				 __scsi_host_match);

commit aab0de245150c09e61c30962feb16aacde508dc3
Author: Kay Sievers <kay.sievers@vrfy.org>
Date:   Fri May 2 06:02:41 2008 +0200

    driver core: remove KOBJ_NAME_LEN define
    
    Kobjects do not have a limit in name size since a while, so stop
    pretending that they do.
    
    Signed-off-by: Kay Sievers <kay.sievers@vrfy.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/scsi/hosts.c b/drivers/scsi/hosts.c
index 78dad28b70d5..fed0b02ebc1d 100644
--- a/drivers/scsi/hosts.c
+++ b/drivers/scsi/hosts.c
@@ -232,8 +232,8 @@ int scsi_add_host(struct Scsi_Host *shost, struct device *dev)
 	}
 
 	if (shost->transportt->create_work_queue) {
-		snprintf(shost->work_q_name, KOBJ_NAME_LEN, "scsi_wq_%d",
-			shost->host_no);
+		snprintf(shost->work_q_name, sizeof(shost->work_q_name),
+			 "scsi_wq_%d", shost->host_no);
 		shost->work_q = create_singlethread_workqueue(
 					shost->work_q_name);
 		if (!shost->work_q) {

commit 695794ae0c5bdd9bd06e35b118801e2e9be04f9e
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Thu May 22 17:21:08 2008 -0400

    Driver Core: add ability for class_find_device to start in middle of list
    
    This mirrors the functionality that driver_find_device has as well.
    
    We add a start variable, and all callers of the function are fixed up at
    the same time.
    
    The block layer will be using this new functionality in a follow-on
    patch.
    
    
    Cc: Kay Sievers <kay.sievers@vrfy.org>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/scsi/hosts.c b/drivers/scsi/hosts.c
index 35cd892dce04..78dad28b70d5 100644
--- a/drivers/scsi/hosts.c
+++ b/drivers/scsi/hosts.c
@@ -466,7 +466,8 @@ struct Scsi_Host *scsi_host_lookup(unsigned short hostnum)
 	struct device *cdev;
 	struct Scsi_Host *shost = ERR_PTR(-ENXIO);
 
-	cdev = class_find_device(&shost_class, &hostnum, __scsi_host_match);
+	cdev = class_find_device(&shost_class, NULL, &hostnum,
+				 __scsi_host_match);
 	if (cdev) {
 		shost = scsi_host_get(class_to_shost(cdev));
 		put_device(cdev);

commit 89a93f2f4834f8c126e8d9dd6b368d0b9e21ec3d
Merge: 260eddf4391f fe9233fb6914
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Tue Jul 15 18:58:04 2008 -0700

    Merge git://git.kernel.org/pub/scm/linux/kernel/git/jejb/scsi-misc-2.6
    
    * git://git.kernel.org/pub/scm/linux/kernel/git/jejb/scsi-misc-2.6: (102 commits)
      [SCSI] scsi_dh: fix kconfig related build errors
      [SCSI] sym53c8xx: Fix bogus sym_que_entry re-implementation of container_of
      [SCSI] scsi_cmnd.h: remove double inclusion of linux/blkdev.h
      [SCSI] make struct scsi_{host,target}_type static
      [SCSI] fix locking in host use of blk_plug_device()
      [SCSI] zfcp: Cleanup external header file
      [SCSI] zfcp: Cleanup code in zfcp_erp.c
      [SCSI] zfcp: zfcp_fsf cleanup.
      [SCSI] zfcp: consolidate sysfs things into one file.
      [SCSI] zfcp: Cleanup of code in zfcp_aux.c
      [SCSI] zfcp: Cleanup of code in zfcp_scsi.c
      [SCSI] zfcp: Move status accessors from zfcp to SCSI include file.
      [SCSI] zfcp: Small QDIO cleanups
      [SCSI] zfcp: Adapter reopen for large number of unsolicited status
      [SCSI] zfcp: Fix error checking for ELS ADISC requests
      [SCSI] zfcp: wait until adapter is finished with ERP during auto-port
      [SCSI] ibmvfc: IBM Power Virtual Fibre Channel Adapter Client Driver
      [SCSI] sg: Add target reset support
      [SCSI] lib: Add support for the T10 (SCSI) Data Integrity Field CRC
      [SCSI] sd: Move scsi_disk() accessor function to sd.h
      ...

commit 453cd0f3ff3bf25d86c96e62d271ba238f06d5ff
Author: Adrian Bunk <bunk@kernel.org>
Date:   Thu Jul 3 23:47:33 2008 -0700

    [SCSI] make struct scsi_{host,target}_type static
    
    Make the needlessly global struct scsi_{host,target}_type static.
    
    Signed-off-by: Adrian Bunk <bunk@kernel.org>
    Signed-off-by: Andrew Morton <akpm@linux-foundation.org>
    Signed-off-by: James Bottomley <James.Bottomley@HansenPartnership.com>

diff --git a/drivers/scsi/hosts.c b/drivers/scsi/hosts.c
index 3690360d7a79..497ca68d1ffc 100644
--- a/drivers/scsi/hosts.c
+++ b/drivers/scsi/hosts.c
@@ -290,7 +290,7 @@ static void scsi_host_dev_release(struct device *dev)
 	kfree(shost);
 }
 
-struct device_type scsi_host_type = {
+static struct device_type scsi_host_type = {
 	.name =		"scsi_host",
 	.release =	scsi_host_dev_release,
 };

commit 3ed7897242b7efe977f3a8d06d4e5a4ebe28b10e
Author: Mike Christie <michaelc@cs.wisc.edu>
Date:   Wed Jun 11 19:21:00 2008 -0500

    [SCSI] scsi_host regression: fix scsi host leak
    
    commit 9c7701088a61cc0cf8a6e1c68d1e74e3cc2ee0b7
    Author: Dave Young <hidave.darkstar@gmail.com>
    Date:   Tue Jan 22 14:01:34 2008 +0800
    
        scsi: use class iteration api
    
    Isn't a correct replacement for the original hand rolled host
    lookup. The problem is that class_find_child would get a reference to
    the host's class device which is never released.  Since the host class
    device holds a reference to the host gendev, the host can never be
    freed.
    
    In 2.6.26 we started using class_find_device, and this function also
    gets a reference to the device, so we end up with an extra ref
    and the host will not get released.
    
    This patch adds a put_device to balance the class_find_device() get. I
    kept the scsi_host_get in scsi_host_lookup, because the target layer
    is using scsi_host_lookup and it looks like it needs the SHOST_DEL
    check.
    
    Signed-off-by: Mike Christie <michaelc@cs.wisc.edu>
    Signed-off-by: James Bottomley <James.Bottomley@HansenPartnership.com>

diff --git a/drivers/scsi/hosts.c b/drivers/scsi/hosts.c
index 3690360d7a79..c6457bfc8a49 100644
--- a/drivers/scsi/hosts.c
+++ b/drivers/scsi/hosts.c
@@ -456,6 +456,10 @@ static int __scsi_host_match(struct device *dev, void *data)
  *
  * Return value:
  *	A pointer to located Scsi_Host or NULL.
+ *
+ *	The caller must do a scsi_host_put() to drop the reference
+ *	that scsi_host_get() took. The put_device() below dropped
+ *	the reference from class_find_device().
  **/
 struct Scsi_Host *scsi_host_lookup(unsigned short hostnum)
 {
@@ -463,9 +467,10 @@ struct Scsi_Host *scsi_host_lookup(unsigned short hostnum)
 	struct Scsi_Host *shost = ERR_PTR(-ENXIO);
 
 	cdev = class_find_device(&shost_class, &hostnum, __scsi_host_match);
-	if (cdev)
+	if (cdev) {
 		shost = scsi_host_get(class_to_shost(cdev));
-
+		put_device(cdev);
+	}
 	return shost;
 }
 EXPORT_SYMBOL(scsi_host_lookup);

commit 542bd1377a963070bc4a03ff7d2690ddf3920596
Author: James Bottomley <James.Bottomley@HansenPartnership.com>
Date:   Mon Apr 21 10:57:20 2008 -0500

    [SCSI] fix SLUB WARN_ON
    
    We're getting a WARN_ON from SLUB indicating that we're trying to free
    caches with in-use objects.  The root cause is a new dependency in the
    command/sense free on unchecked_isa_dma.  The WARN_ON is caused by
    drivers which change this in their setup after the command/sense cache
    is allocated.
    
    The fix is to move the allocation of this cache into scsi_add_host()
    so things like gdth have an opportunity to modify it between alloc and
    add (but *not* after).
    
    The true fix would be to move unchecked_isa_dma into the template and
    out of the host, so it because a truly read only variable.
    
    Signed-off-by: James Bottomley <James.Bottomley@HansenPartnership.com>

diff --git a/drivers/scsi/hosts.c b/drivers/scsi/hosts.c
index 4e811ca3270e..3690360d7a79 100644
--- a/drivers/scsi/hosts.c
+++ b/drivers/scsi/hosts.c
@@ -199,9 +199,13 @@ int scsi_add_host(struct Scsi_Host *shost, struct device *dev)
 	if (!shost->can_queue) {
 		printk(KERN_ERR "%s: can_queue = 0 no longer supported\n",
 				sht->name);
-		goto out;
+		goto fail;
 	}
 
+	error = scsi_setup_command_freelist(shost);
+	if (error)
+		goto fail;
+
 	if (!shost->shost_gendev.parent)
 		shost->shost_gendev.parent = dev ? dev : &platform_bus;
 
@@ -255,6 +259,8 @@ int scsi_add_host(struct Scsi_Host *shost, struct device *dev)
  out_del_gendev:
 	device_del(&shost->shost_gendev);
  out:
+	scsi_destroy_command_freelist(shost);
+ fail:
 	return error;
 }
 EXPORT_SYMBOL(scsi_add_host);
@@ -381,10 +387,6 @@ struct Scsi_Host *scsi_host_alloc(struct scsi_host_template *sht, int privsize)
 	else
 		shost->dma_boundary = 0xffffffff;
 
-	rval = scsi_setup_command_freelist(shost);
-	if (rval)
-		goto fail_kfree;
-
 	device_initialize(&shost->shost_gendev);
 	snprintf(shost->shost_gendev.bus_id, BUS_ID_SIZE, "host%d",
 		shost->host_no);
@@ -404,14 +406,12 @@ struct Scsi_Host *scsi_host_alloc(struct scsi_host_template *sht, int privsize)
 			"scsi_eh_%d", shost->host_no);
 	if (IS_ERR(shost->ehandler)) {
 		rval = PTR_ERR(shost->ehandler);
-		goto fail_destroy_freelist;
+		goto fail_kfree;
 	}
 
 	scsi_proc_hostdir_add(shost->hostt);
 	return shost;
 
- fail_destroy_freelist:
-	scsi_destroy_command_freelist(shost);
  fail_kfree:
 	kfree(shost);
 	return NULL;

commit f7120a4f75168df3c02efacd10403a4ba0bcb29d
Author: Hannes Reinecke <hare@suse.de>
Date:   Tue Mar 18 14:32:28 2008 +0100

    [SCSI] use default attributes for scsi_host
    
    This patch removes the unused sysfs attibute overwriting logic for
    the scsi host attibutes, and plugs them into the driver core default
    attribute creation.
    
    Signed-off-by: Hannes Reinecke <hare@suse.de>
    Signed-off-by: Kay Sievers <kay.sievers@vrfy.org>
    Signed-off-by: James Bottomley <James.Bottomley@HansenPartnership.com>

diff --git a/drivers/scsi/hosts.c b/drivers/scsi/hosts.c
index 63bed62f270e..4e811ca3270e 100644
--- a/drivers/scsi/hosts.c
+++ b/drivers/scsi/hosts.c
@@ -398,6 +398,7 @@ struct Scsi_Host *scsi_host_alloc(struct scsi_host_template *sht, int privsize)
 	shost->shost_dev.class = &shost_class;
 	snprintf(shost->shost_dev.bus_id, BUS_ID_SIZE, "host%d",
 		 shost->host_no);
+	shost->shost_dev.groups = scsi_sysfs_shost_attr_groups;
 
 	shost->ehandler = kthread_run(scsi_error_handler, shost,
 			"scsi_eh_%d", shost->host_no);

commit b0ed43360fdca227048d88a08290365cb681c1a8
Author: Hannes Reinecke <hare@suse.de>
Date:   Tue Mar 18 14:32:28 2008 +0100

    [SCSI] add scsi_host and scsi_target to scsi_bus
    
    This patch implements scsi_host and scsi_target device types
    and adds both to the scsi_bus.
    
    Signed-off-by: Hannes Reinecke <hare@suse.de>
    Signed-off-by: Kay Sievers <kay.sievers@vrfy.org>
    Signed-off-by: James Bottomley <James.Bottomley@HansenPartnership.com>

diff --git a/drivers/scsi/hosts.c b/drivers/scsi/hosts.c
index c264a8c5f01e..63bed62f270e 100644
--- a/drivers/scsi/hosts.c
+++ b/drivers/scsi/hosts.c
@@ -284,6 +284,11 @@ static void scsi_host_dev_release(struct device *dev)
 	kfree(shost);
 }
 
+struct device_type scsi_host_type = {
+	.name =		"scsi_host",
+	.release =	scsi_host_dev_release,
+};
+
 /**
  * scsi_host_alloc - register a scsi host adapter instance.
  * @sht:	pointer to scsi host template
@@ -383,7 +388,10 @@ struct Scsi_Host *scsi_host_alloc(struct scsi_host_template *sht, int privsize)
 	device_initialize(&shost->shost_gendev);
 	snprintf(shost->shost_gendev.bus_id, BUS_ID_SIZE, "host%d",
 		shost->host_no);
-	shost->shost_gendev.release = scsi_host_dev_release;
+#ifndef CONFIG_SYSFS_DEPRECATED
+	shost->shost_gendev.bus = &scsi_bus_type;
+#endif
+	shost->shost_gendev.type = &scsi_host_type;
 
 	device_initialize(&shost->shost_dev);
 	shost->shost_dev.parent = &shost->shost_gendev;
@@ -496,7 +504,7 @@ void scsi_exit_hosts(void)
 
 int scsi_is_host_device(const struct device *dev)
 {
-	return dev->release == scsi_host_dev_release;
+	return dev->type == &scsi_host_type;
 }
 EXPORT_SYMBOL(scsi_is_host_device);
 

commit ee959b00c335d7780136c5abda37809191fe52c3
Author: Tony Jones <tonyj@suse.de>
Date:   Fri Feb 22 00:13:36 2008 +0100

    SCSI: convert struct class_device to struct device
    
    It's big, but there doesn't seem to be a way to split it up smaller...
    
    Signed-off-by: Tony Jones <tonyj@suse.de>
    Signed-off-by: Kay Sievers <kay.sievers@vrfy.org>
    Cc: Roland Dreier <rolandd@cisco.com>
    Cc: Sean Hefty <sean.hefty@intel.com>
    Cc: Hal Rosenstock <hal.rosenstock@gmail.com>
    Cc: James Bottomley <James.Bottomley@HansenPartnership.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/scsi/hosts.c b/drivers/scsi/hosts.c
index 1592640a87b5..c264a8c5f01e 100644
--- a/drivers/scsi/hosts.c
+++ b/drivers/scsi/hosts.c
@@ -43,14 +43,14 @@
 static int scsi_host_next_hn;		/* host_no for next new host */
 
 
-static void scsi_host_cls_release(struct class_device *class_dev)
+static void scsi_host_cls_release(struct device *dev)
 {
-	put_device(&class_to_shost(class_dev)->shost_gendev);
+	put_device(&class_to_shost(dev)->shost_gendev);
 }
 
 static struct class shost_class = {
 	.name		= "scsi_host",
-	.release	= scsi_host_cls_release,
+	.dev_release	= scsi_host_cls_release,
 };
 
 /**
@@ -174,7 +174,7 @@ void scsi_remove_host(struct Scsi_Host *shost)
 	spin_unlock_irqrestore(shost->host_lock, flags);
 
 	transport_unregister_device(&shost->shost_gendev);
-	class_device_unregister(&shost->shost_classdev);
+	device_unregister(&shost->shost_dev);
 	device_del(&shost->shost_gendev);
 	scsi_proc_hostdir_rm(shost->hostt);
 }
@@ -212,7 +212,7 @@ int scsi_add_host(struct Scsi_Host *shost, struct device *dev)
 	scsi_host_set_state(shost, SHOST_RUNNING);
 	get_device(shost->shost_gendev.parent);
 
-	error = class_device_add(&shost->shost_classdev);
+	error = device_add(&shost->shost_dev);
 	if (error)
 		goto out_del_gendev;
 
@@ -223,7 +223,7 @@ int scsi_add_host(struct Scsi_Host *shost, struct device *dev)
 					 GFP_KERNEL);
 		if (shost->shost_data == NULL) {
 			error = -ENOMEM;
-			goto out_del_classdev;
+			goto out_del_dev;
 		}
 	}
 
@@ -250,8 +250,8 @@ int scsi_add_host(struct Scsi_Host *shost, struct device *dev)
 		destroy_workqueue(shost->work_q);
  out_free_shost_data:
 	kfree(shost->shost_data);
- out_del_classdev:
-	class_device_del(&shost->shost_classdev);
+ out_del_dev:
+	device_del(&shost->shost_dev);
  out_del_gendev:
 	device_del(&shost->shost_gendev);
  out:
@@ -385,11 +385,11 @@ struct Scsi_Host *scsi_host_alloc(struct scsi_host_template *sht, int privsize)
 		shost->host_no);
 	shost->shost_gendev.release = scsi_host_dev_release;
 
-	class_device_initialize(&shost->shost_classdev);
-	shost->shost_classdev.dev = &shost->shost_gendev;
-	shost->shost_classdev.class = &shost_class;
-	snprintf(shost->shost_classdev.class_id, BUS_ID_SIZE, "host%d",
-		  shost->host_no);
+	device_initialize(&shost->shost_dev);
+	shost->shost_dev.parent = &shost->shost_gendev;
+	shost->shost_dev.class = &shost_class;
+	snprintf(shost->shost_dev.bus_id, BUS_ID_SIZE, "host%d",
+		 shost->host_no);
 
 	shost->ehandler = kthread_run(scsi_error_handler, shost,
 			"scsi_eh_%d", shost->host_no);
@@ -432,12 +432,12 @@ void scsi_unregister(struct Scsi_Host *shost)
 }
 EXPORT_SYMBOL(scsi_unregister);
 
-static int __scsi_host_match(struct class_device *cdev, void *data)
+static int __scsi_host_match(struct device *dev, void *data)
 {
 	struct Scsi_Host *p;
 	unsigned short *hostnum = (unsigned short *)data;
 
-	p = class_to_shost(cdev);
+	p = class_to_shost(dev);
 	return p->host_no == *hostnum;
 }
 
@@ -450,10 +450,10 @@ static int __scsi_host_match(struct class_device *cdev, void *data)
  **/
 struct Scsi_Host *scsi_host_lookup(unsigned short hostnum)
 {
-	struct class_device *cdev;
+	struct device *cdev;
 	struct Scsi_Host *shost = ERR_PTR(-ENXIO);
 
-	cdev = class_find_child(&shost_class, &hostnum, __scsi_host_match);
+	cdev = class_find_device(&shost_class, &hostnum, __scsi_host_match);
 	if (cdev)
 		shost = scsi_host_get(class_to_shost(cdev));
 

commit 540d9b40faa8fcf094cb1fbf9224406bb13e3307
Author: Denis Cheng <crquan@gmail.com>
Date:   Thu Mar 20 03:10:20 2008 +0800

    [SCSI] hosts.c: removed one unneeded shost->active_mode assignment
    
    In the following if/else statement, shost->active_mode will always be set,
    so this assignment is unneeded.
    
    Signed-off-by: Denis Cheng <crquan@gmail.com>
    Signed-off-by: James Bottomley <James.Bottomley@HansenPartnership.com>

diff --git a/drivers/scsi/hosts.c b/drivers/scsi/hosts.c
index ed7e0a1fc34d..1592640a87b5 100644
--- a/drivers/scsi/hosts.c
+++ b/drivers/scsi/hosts.c
@@ -347,7 +347,6 @@ struct Scsi_Host *scsi_host_alloc(struct scsi_host_template *sht, int privsize)
 	shost->unchecked_isa_dma = sht->unchecked_isa_dma;
 	shost->use_clustering = sht->use_clustering;
 	shost->ordered_tag = sht->ordered_tag;
-	shost->active_mode = sht->supported_mode;
 
 	if (sht->supported_mode == MODE_UNKNOWN)
 		/* means we didn't set it ... default to INITIATOR */

commit 77cca462c69d827fabee0ef3fdab86109c2fe8d8
Author: James Smart <James.Smart@Emulex.Com>
Date:   Fri Mar 21 17:18:23 2008 -0400

    [SCSI] hosts.c: fixes for "no error" reported after error scenarios
    
    This patch corrects some cases in scsi_add_host() that fail, but the "error"
    return code was not reset after a prior use which set it to a non-error value.
    
    Patch cut against scsi-rc-fixes-2.6
    
    Signed-off-by: James Smart <james.smart@emulex.com>
    Signed-off-by: James Bottomley <James.Bottomley@HansenPartnership.com>

diff --git a/drivers/scsi/hosts.c b/drivers/scsi/hosts.c
index 880c78bff0e1..ed7e0a1fc34d 100644
--- a/drivers/scsi/hosts.c
+++ b/drivers/scsi/hosts.c
@@ -218,18 +218,24 @@ int scsi_add_host(struct Scsi_Host *shost, struct device *dev)
 
 	get_device(&shost->shost_gendev);
 
-	if (shost->transportt->host_size &&
-	    (shost->shost_data = kzalloc(shost->transportt->host_size,
-					 GFP_KERNEL)) == NULL)
-		goto out_del_classdev;
+	if (shost->transportt->host_size) {
+		shost->shost_data = kzalloc(shost->transportt->host_size,
+					 GFP_KERNEL);
+		if (shost->shost_data == NULL) {
+			error = -ENOMEM;
+			goto out_del_classdev;
+		}
+	}
 
 	if (shost->transportt->create_work_queue) {
 		snprintf(shost->work_q_name, KOBJ_NAME_LEN, "scsi_wq_%d",
 			shost->host_no);
 		shost->work_q = create_singlethread_workqueue(
 					shost->work_q_name);
-		if (!shost->work_q)
+		if (!shost->work_q) {
+			error = -EINVAL;
 			goto out_free_shost_data;
+		}
 	}
 
 	error = scsi_sysfs_add_host(shost);

commit d3f46f39b7092594b498abc12f0c73b0b9913bde
Author: James Bottomley <James.Bottomley@HansenPartnership.com>
Date:   Tue Jan 15 11:11:46 2008 -0600

    [SCSI] remove use_sg_chaining
    
    With the sg table code, every SCSI driver is now either chain capable
    or broken (or has sg_tablesize set so chaining is never activated), so
    there's no need to have a check in the host template.
    
    Also tidy up the code by moving the scatterlist size defines into the
    SCSI includes and permit the last entry of the scatterlist pools not
    to be a power of two.
    Signed-off-by: James Bottomley <James.Bottomley@HansenPartnership.com>

diff --git a/drivers/scsi/hosts.c b/drivers/scsi/hosts.c
index 5ea1f986220c..880c78bff0e1 100644
--- a/drivers/scsi/hosts.c
+++ b/drivers/scsi/hosts.c
@@ -342,7 +342,6 @@ struct Scsi_Host *scsi_host_alloc(struct scsi_host_template *sht, int privsize)
 	shost->use_clustering = sht->use_clustering;
 	shost->ordered_tag = sht->ordered_tag;
 	shost->active_mode = sht->supported_mode;
-	shost->use_sg_chaining = sht->use_sg_chaining;
 
 	if (sht->supported_mode == MODE_UNKNOWN)
 		/* means we didn't set it ... default to INITIATOR */

commit 9b73e76f3cf63379dcf45fcd4f112f5812418d0a
Merge: 50d9a126240f 23c3e290fb9c
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Fri Jan 25 17:19:08 2008 -0800

    Merge git://git.kernel.org/pub/scm/linux/kernel/git/jejb/scsi-misc-2.6
    
    * git://git.kernel.org/pub/scm/linux/kernel/git/jejb/scsi-misc-2.6: (200 commits)
      [SCSI] usbstorage: use last_sector_bug flag universally
      [SCSI] libsas: abstract STP task status into a function
      [SCSI] ultrastor: clean up inline asm warnings
      [SCSI] aic7xxx: fix firmware build
      [SCSI] aacraid: fib context lock for management ioctls
      [SCSI] ch: remove forward declarations
      [SCSI] ch: fix device minor number management bug
      [SCSI] ch: handle class_device_create failure properly
      [SCSI] NCR5380: fix section mismatch
      [SCSI] sg: fix /proc/scsi/sg/devices when no SCSI devices
      [SCSI] IB/iSER: add logical unit reset support
      [SCSI] don't use __GFP_DMA for sense buffers if not required
      [SCSI] use dynamically allocated sense buffer
      [SCSI] scsi.h: add macro for enclosure bit of inquiry data
      [SCSI] sd: add fix for devices with last sector access problems
      [SCSI] fix pcmcia compile problem
      [SCSI] aacraid: add Voodoo Lite class of cards.
      [SCSI] aacraid: add new driver features flags
      [SCSI] qla2xxx: Update version number to 8.02.00-k7.
      [SCSI] qla2xxx: Issue correct MBC_INITIALIZE_FIRMWARE command.
      ...

commit 9c7701088a61cc0cf8a6e1c68d1e74e3cc2ee0b7
Author: Dave Young <hidave.darkstar@gmail.com>
Date:   Tue Jan 22 14:01:34 2008 +0800

    scsi: use class iteration api
    
    Convert to use the class iteration api.
    
    Signed-off-by: Dave Young <hidave.darkstar@gmail.com>
    Cc: James Bottomley <James.Bottomley@hansenpartnership.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/scsi/hosts.c b/drivers/scsi/hosts.c
index 24271a871b8c..6325115e5b3d 100644
--- a/drivers/scsi/hosts.c
+++ b/drivers/scsi/hosts.c
@@ -429,6 +429,15 @@ void scsi_unregister(struct Scsi_Host *shost)
 }
 EXPORT_SYMBOL(scsi_unregister);
 
+static int __scsi_host_match(struct class_device *cdev, void *data)
+{
+	struct Scsi_Host *p;
+	unsigned short *hostnum = (unsigned short *)data;
+
+	p = class_to_shost(cdev);
+	return p->host_no == *hostnum;
+}
+
 /**
  * scsi_host_lookup - get a reference to a Scsi_Host by host no
  *
@@ -439,19 +448,12 @@ EXPORT_SYMBOL(scsi_unregister);
  **/
 struct Scsi_Host *scsi_host_lookup(unsigned short hostnum)
 {
-	struct class *class = &shost_class;
 	struct class_device *cdev;
-	struct Scsi_Host *shost = ERR_PTR(-ENXIO), *p;
+	struct Scsi_Host *shost = ERR_PTR(-ENXIO);
 
-	down(&class->sem);
-	list_for_each_entry(cdev, &class->children, node) {
-		p = class_to_shost(cdev);
-		if (p->host_no == hostnum) {
-			shost = scsi_host_get(p);
-			break;
-		}
-	}
-	up(&class->sem);
+	cdev = class_find_child(&shost_class, &hostnum, __scsi_host_match);
+	if (cdev)
+		shost = scsi_host_get(class_to_shost(cdev));
 
 	return shost;
 }

commit 5b7f16804ad90e7f7a10c05b6a2e782598d9745a
Author: James Bottomley <James.Bottomley@HansenPartnership.com>
Date:   Sun Jan 20 09:28:24 2008 -0600

    [SCSI] don't use __GFP_DMA for sense buffers if not required
    
    Only hosts which actually have ISA DMA requirements need sense buffers
    coming out of ZONE_DMA, so only use the __GFP_DMA flag for that case
    to avoid allocating this scarce resource if it's not necessary.
    
    [tomo: fixed slab leak in failure case]
    Acked-by: FUJITA Tomonori <fujita.tomonori@lab.ntt.co.jp>
    Signed-off-by: James Bottomley <James.Bottomley@HansenPartnership.com>

diff --git a/drivers/scsi/hosts.c b/drivers/scsi/hosts.c
index f5d3fbb55717..9a10b4335e76 100644
--- a/drivers/scsi/hosts.c
+++ b/drivers/scsi/hosts.c
@@ -268,7 +268,6 @@ static void scsi_host_dev_release(struct device *dev)
 	}
 
 	scsi_destroy_command_freelist(shost);
-	scsi_destroy_command_sense_buffer(shost);
 	if (shost->bqt)
 		blk_free_tags(shost->bqt);
 
@@ -373,13 +372,9 @@ struct Scsi_Host *scsi_host_alloc(struct scsi_host_template *sht, int privsize)
 	else
 		shost->dma_boundary = 0xffffffff;
 
-	rval = scsi_setup_command_sense_buffer(shost);
-	if (rval)
-		goto fail_kfree;
-
 	rval = scsi_setup_command_freelist(shost);
 	if (rval)
-		goto fail_destroy_sense;
+		goto fail_kfree;
 
 	device_initialize(&shost->shost_gendev);
 	snprintf(shost->shost_gendev.bus_id, BUS_ID_SIZE, "host%d",
@@ -404,8 +399,6 @@ struct Scsi_Host *scsi_host_alloc(struct scsi_host_template *sht, int privsize)
 
  fail_destroy_freelist:
 	scsi_destroy_command_freelist(shost);
- fail_destroy_sense:
-	scsi_destroy_command_sense_buffer(shost);
  fail_kfree:
 	kfree(shost);
 	return NULL;

commit de25deb18016f66dcdede165d07654559bb332bc
Author: FUJITA Tomonori <fujita.tomonori@lab.ntt.co.jp>
Date:   Wed Jan 16 13:32:17 2008 +0900

    [SCSI] use dynamically allocated sense buffer
    
    This removes static array sense_buffer in scsi_cmnd and uses
    dynamically allocated sense_buffer (with GFP_DMA).
    
    The reason for doing this is that some architectures need cacheline
    aligned buffer for DMA:
    
    http://lkml.org/lkml/2007/11/19/2
    
    The problems are that scsi_eh_prep_cmnd puts scsi_cmnd::sense_buffer
    to sglist and some LLDs directly DMA to scsi_cmnd::sense_buffer. It's
    necessary to DMA to scsi_cmnd::sense_buffer safely. This patch solves
    these issues.
    
    __scsi_get_command allocates sense_buffer via kmem_cache_alloc and
    attaches it to a scsi_cmnd so everything just work as before.
    
    Signed-off-by: FUJITA Tomonori <fujita.tomonori@lab.ntt.co.jp>
    Signed-off-by: James Bottomley <James.Bottomley@HansenPartnership.com>

diff --git a/drivers/scsi/hosts.c b/drivers/scsi/hosts.c
index 9a10b4335e76..f5d3fbb55717 100644
--- a/drivers/scsi/hosts.c
+++ b/drivers/scsi/hosts.c
@@ -268,6 +268,7 @@ static void scsi_host_dev_release(struct device *dev)
 	}
 
 	scsi_destroy_command_freelist(shost);
+	scsi_destroy_command_sense_buffer(shost);
 	if (shost->bqt)
 		blk_free_tags(shost->bqt);
 
@@ -372,10 +373,14 @@ struct Scsi_Host *scsi_host_alloc(struct scsi_host_template *sht, int privsize)
 	else
 		shost->dma_boundary = 0xffffffff;
 
-	rval = scsi_setup_command_freelist(shost);
+	rval = scsi_setup_command_sense_buffer(shost);
 	if (rval)
 		goto fail_kfree;
 
+	rval = scsi_setup_command_freelist(shost);
+	if (rval)
+		goto fail_destroy_sense;
+
 	device_initialize(&shost->shost_gendev);
 	snprintf(shost->shost_gendev.bus_id, BUS_ID_SIZE, "host%d",
 		shost->host_no);
@@ -399,6 +404,8 @@ struct Scsi_Host *scsi_host_alloc(struct scsi_host_template *sht, int privsize)
 
  fail_destroy_freelist:
 	scsi_destroy_command_freelist(shost);
+ fail_destroy_sense:
+	scsi_destroy_command_sense_buffer(shost);
  fail_kfree:
 	kfree(shost);
 	return NULL;

commit eb44820c28bc9a042e1157b41c677018a8fdfc74
Author: Rob Landley <rob@landley.net>
Date:   Sat Nov 3 13:30:39 2007 -0500

    [SCSI] Add Documentation and integrate into docbook build
    
    Add Documentation/DocBook/scsi_midlayer.tmpl, add to Makefile, and update
    lots of kerneldoc comments in drivers/scsi/*.
    
    Updated with comments from Stefan Richter, Stephen M. Cameron,
     James Bottomley and Randy Dunlap.
    
    Signed-off-by: Rob Landley <rob@landley.net>
    Signed-off-by: James Bottomley <James.Bottomley@HansenPartnership.com>

diff --git a/drivers/scsi/hosts.c b/drivers/scsi/hosts.c
index 24271a871b8c..9a10b4335e76 100644
--- a/drivers/scsi/hosts.c
+++ b/drivers/scsi/hosts.c
@@ -54,8 +54,7 @@ static struct class shost_class = {
 };
 
 /**
- *	scsi_host_set_state - Take the given host through the host
- *		state model.
+ *	scsi_host_set_state - Take the given host through the host state model.
  *	@shost:	scsi host to change the state of.
  *	@state:	state to change to.
  *
@@ -431,7 +430,6 @@ EXPORT_SYMBOL(scsi_unregister);
 
 /**
  * scsi_host_lookup - get a reference to a Scsi_Host by host no
- *
  * @hostnum:	host number to locate
  *
  * Return value:

commit 7a39ac3f25bef018862a991d754aff681c019127
Author: James Bottomley <James.Bottomley@steeleye.com>
Date:   Tue Sep 25 22:45:53 2007 -0500

    [SCSI] make supported_mode default to initiator.
    
    if shost->supported mode is zero (i.e. MODE_UNKNOWN) show it as
    initiator (it's obviously an unconverted driver that won't do target).
    
    Acked-by: FUJITA Tomonori <tomof@acm.org>
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>

diff --git a/drivers/scsi/hosts.c b/drivers/scsi/hosts.c
index 112ab6abe62b..24271a871b8c 100644
--- a/drivers/scsi/hosts.c
+++ b/drivers/scsi/hosts.c
@@ -345,6 +345,12 @@ struct Scsi_Host *scsi_host_alloc(struct scsi_host_template *sht, int privsize)
 	shost->active_mode = sht->supported_mode;
 	shost->use_sg_chaining = sht->use_sg_chaining;
 
+	if (sht->supported_mode == MODE_UNKNOWN)
+		/* means we didn't set it ... default to INITIATOR */
+		shost->active_mode = MODE_INITIATOR;
+	else
+		shost->active_mode = sht->supported_mode;
+
 	if (sht->max_host_blocked)
 		shost->max_host_blocked = sht->max_host_blocked;
 	else

commit 9cb83c7529d929c00f37d821daed1942a1b20602
Author: FUJITA Tomonori <tomof@acm.org>
Date:   Tue Oct 16 11:24:32 2007 +0200

    [SCSI] add use_sg_chaining option to scsi_host_template
    
    This option is true if a low-level driver can support sg
    chaining. This will be removed eventually when all the drivers are
    converted to support sg chaining. q->max_phys_segments is set to
    SCSI_MAX_SG_SEGMENTS if false.
    
    Signed-off-by: FUJITA Tomonori <fujita.tomonori@lab.ntt.co.jp>
    Signed-off-by: Jens Axboe <jens.axboe@oracle.com>

diff --git a/drivers/scsi/hosts.c b/drivers/scsi/hosts.c
index adc9559cb6f4..112ab6abe62b 100644
--- a/drivers/scsi/hosts.c
+++ b/drivers/scsi/hosts.c
@@ -343,6 +343,7 @@ struct Scsi_Host *scsi_host_alloc(struct scsi_host_template *sht, int privsize)
 	shost->use_clustering = sht->use_clustering;
 	shost->ordered_tag = sht->ordered_tag;
 	shost->active_mode = sht->supported_mode;
+	shost->use_sg_chaining = sht->use_sg_chaining;
 
 	if (sht->max_host_blocked)
 		shost->max_host_blocked = sht->max_host_blocked;

commit 5dc2b89e124251662f580f4ba3c9f6195d1eaff6
Author: FUJITA Tomonori <tomof@acm.org>
Date:   Sat Sep 1 02:02:20 2007 +0900

    [SCSI] add supported_mode and active_mode attributes to the host
    
    This adds supported_mode and active_mode attributes to
    /sys/class/sys_host/hostX/ for specifying the mode that a lld supports
    and the currently activated mode. The output format is similar to fc
    rport roles:
    
    luce:/sys/class/scsi_host/host0$ cat supported_mode
    Initiator
    luce:/sys/class/scsi_host/host0$ cat active_mode
    Initiator
    
    The mode values uses bitmap since we would support dual-mode llds in
    the future like this:
    
    luce:/sys/class/scsi_host/host0$ cat supported_mode
    Initiator, Target
    
    The supported_mode attribute looks at a scsi_host_template and the
    active_mode attribute looks at a scsi_host. We would add a hook to a
    scsi_host_template to change the active_mode attribute
    dynamically. But now there is no hook since no lld supports that
    feature.
    
    Signed-off-by: FUJITA Tomonori <fujita.tomonori@lab.ntt.co.jp>
    Signed-off-by: Mike Christie <michaelc@cs.wisc.edu>
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>

diff --git a/drivers/scsi/hosts.c b/drivers/scsi/hosts.c
index 96bc31266c98..adc9559cb6f4 100644
--- a/drivers/scsi/hosts.c
+++ b/drivers/scsi/hosts.c
@@ -342,6 +342,7 @@ struct Scsi_Host *scsi_host_alloc(struct scsi_host_template *sht, int privsize)
 	shost->unchecked_isa_dma = sht->unchecked_isa_dma;
 	shost->use_clustering = sht->use_clustering;
 	shost->ordered_tag = sht->ordered_tag;
+	shost->active_mode = sht->supported_mode;
 
 	if (sht->max_host_blocked)
 		shost->max_host_blocked = sht->max_host_blocked;

commit c000c43cf12090972fad0fbb621d78c2100d0373
Author: FUJITA Tomonori <fujita.tomonori@lab.ntt.co.jp>
Date:   Wed Aug 1 08:40:27 2007 +0900

    [SCSI] initialize shost_data to zero
    
    It's better to initialize host->shost_data to zero like
    target->starget_data and device->sdev_data.
    
    Signed-off-by: FUJITA Tomonori <fujita.tomonori@lab.ntt.co.jp>
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>

diff --git a/drivers/scsi/hosts.c b/drivers/scsi/hosts.c
index bd8e7f323c69..96bc31266c98 100644
--- a/drivers/scsi/hosts.c
+++ b/drivers/scsi/hosts.c
@@ -220,7 +220,7 @@ int scsi_add_host(struct Scsi_Host *shost, struct device *dev)
 	get_device(&shost->shost_gendev);
 
 	if (shost->transportt->host_size &&
-	    (shost->shost_data = kmalloc(shost->transportt->host_size,
+	    (shost->shost_data = kzalloc(shost->transportt->host_size,
 					 GFP_KERNEL)) == NULL)
 		goto out_del_classdev;
 

commit b7bb125dc3d0ca3f72c9116525ce0f018a9844e1
Author: Greg Kroah-Hartman <gregkh@suse.de>
Date:   Mon Apr 9 11:52:31 2007 -0400

    SCSI: use the proper semaphore to protect the class lists
    
    SCSI was using the incorrect lock to protect walking the list of all
    devices in the class.  This patch fixes this.
    
    Cc: James Bottomley <James.Bottomley@SteelEye.com>
    Signed-off-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/scsi/hosts.c b/drivers/scsi/hosts.c
index 38c3a291efac..bd8e7f323c69 100644
--- a/drivers/scsi/hosts.c
+++ b/drivers/scsi/hosts.c
@@ -435,7 +435,7 @@ struct Scsi_Host *scsi_host_lookup(unsigned short hostnum)
 	struct class_device *cdev;
 	struct Scsi_Host *shost = ERR_PTR(-ENXIO), *p;
 
-	down_read(&class->subsys.rwsem);
+	down(&class->sem);
 	list_for_each_entry(cdev, &class->children, node) {
 		p = class_to_shost(cdev);
 		if (p->host_no == hostnum) {
@@ -443,7 +443,7 @@ struct Scsi_Host *scsi_host_lookup(unsigned short hostnum)
 			break;
 		}
 	}
-	up_read(&class->subsys.rwsem);
+	up(&class->sem);
 
 	return shost;
 }

commit b58d91547fb17c65ad621f3f98b1f2c228c812a5
Author: FUJITA Tomonori <fujita.tomonori@lab.ntt.co.jp>
Date:   Thu Nov 16 19:24:10 2006 +0900

    [SCSI] export scsi-ml functions needed by tgt_scsi_lib and its LLDs
    
    This patch contains the needed changes to the scsi-ml for the target
    mode support.
    
    Note, per the last review we moved almost all the fields we added
    to the scsi_cmnd to our internal data structure which we are going
    to try and kill off when we can replace it with support from other
    parts of the kernel.
    
    The one field we left on was the offset variable. This is needed to handle
    the case where the target gets request that is so large that it cannot
    execute it in one dma operation. So max_secotors or a segment limit may
    limit the size of the transfer. In this case our tgt core code will
    break up the command into managable transfers and send them to the
    LLD one at a time. The offset is then used to tell the LLD where in
    the command we are at. Is there another field on the scsi_cmd for
    that?
    
    Signed-off-by: Mike Christie <michaelc@cs.wisc.edu>
    Signed-off-by: FUJITA Tomonori <fujita.tomonori@lab.ntt.co.jp>
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>

diff --git a/drivers/scsi/hosts.c b/drivers/scsi/hosts.c
index 2ffdc9e0532d..38c3a291efac 100644
--- a/drivers/scsi/hosts.c
+++ b/drivers/scsi/hosts.c
@@ -263,6 +263,10 @@ static void scsi_host_dev_release(struct device *dev)
 		kthread_stop(shost->ehandler);
 	if (shost->work_q)
 		destroy_workqueue(shost->work_q);
+	if (shost->uspace_req_q) {
+		kfree(shost->uspace_req_q->queuedata);
+		scsi_free_queue(shost->uspace_req_q);
+	}
 
 	scsi_destroy_command_freelist(shost);
 	if (shost->bqt)

commit 4f777ed26086452737ea52597cf8de26137090d5
Author: Christoph Hellwig <hch@lst.de>
Date:   Sat Nov 4 20:11:36 2006 +0100

    [SCSI] kill scsi_assign_lock
    
    scsi_assign_lock has been unused for a long time and is a bad idea
    in general, so kill it.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>

diff --git a/drivers/scsi/hosts.c b/drivers/scsi/hosts.c
index 68ef1636678d..2ffdc9e0532d 100644
--- a/drivers/scsi/hosts.c
+++ b/drivers/scsi/hosts.c
@@ -301,8 +301,8 @@ struct Scsi_Host *scsi_host_alloc(struct scsi_host_template *sht, int privsize)
 	if (!shost)
 		return NULL;
 
-	spin_lock_init(&shost->default_lock);
-	scsi_assign_lock(shost, &shost->default_lock);
+	shost->host_lock = &shost->default_lock;
+	spin_lock_init(shost->host_lock);
 	shost->shost_state = SHOST_CREATED;
 	INIT_LIST_HEAD(&shost->__devices);
 	INIT_LIST_HEAD(&shost->__targets);

commit 86e33a296c2c9ed6eece0bfff4ac776f42040504
Author: James Bottomley <James.Bottomley@steeleye.com>
Date:   Wed Aug 30 09:45:51 2006 -0400

    [SCSI] add shared tag map helpers
    
    This patch adds support for sharing tag maps at the host level
    (i.e. either every queue [LUN] has its own tag map or there's a single
    one for the entire host).  This formulation is primarily intended to
    help single issue queue hardware, like the aic7xxx
    
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>

diff --git a/drivers/scsi/hosts.c b/drivers/scsi/hosts.c
index f244d4f6597a..68ef1636678d 100644
--- a/drivers/scsi/hosts.c
+++ b/drivers/scsi/hosts.c
@@ -265,6 +265,9 @@ static void scsi_host_dev_release(struct device *dev)
 		destroy_workqueue(shost->work_q);
 
 	scsi_destroy_command_freelist(shost);
+	if (shost->bqt)
+		blk_free_tags(shost->bqt);
+
 	kfree(shost->shost_data);
 
 	if (parent)

commit dd7e2f2266acf66ec882baa6fbd79f853b5fe966
Author: Michael Reed <mdr@sgi.com>
Date:   Fri Aug 4 12:09:24 2006 -0500

    [SCSI] scsi_queue_work() documented return value is incorrect
    
    If you examine the queue_work() routine you'll see that it returns
    1 on success, 0 if the work is already queued.
    
    This patch corrects the source code documentation for the
    scsi_queue_work function.
    
    Signed-off-by: Michael Reed <mdr@sgi.com>
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>

diff --git a/drivers/scsi/hosts.c b/drivers/scsi/hosts.c
index dfcb96f3e60c..f244d4f6597a 100644
--- a/drivers/scsi/hosts.c
+++ b/drivers/scsi/hosts.c
@@ -487,7 +487,9 @@ EXPORT_SYMBOL(scsi_is_host_device);
  * @work:	Work to queue for execution.
  *
  * Return value:
- * 	0 on success / != 0 for error
+ * 	1 - work queued for execution
+ *	0 - work is already queued
+ *	-EINVAL - work queue doesn't exist
  **/
 int scsi_queue_work(struct Scsi_Host *shost, struct work_struct *work)
 {

commit 9227c33de80ac01f269ed33624990ce84358e419
Author: Christoph Hellwig <hch@lst.de>
Date:   Sat Apr 1 19:21:04 2006 +0200

    [PATCH] move ->eh_strategy_handler to the transport class
    
    Overriding the whole EH code is a per-transport, not per-host thing.
    Move ->eh_strategy_handler to the transport class, same as
    ->eh_timed_out.
    
    Downside is that scsi_host_alloc can't check for the total lack of EH
    anymore, but the transition period from old EH where we needed it is
    long gone already.
    
    Signed-off-by: Christoph Hellwig <hch@lst.de>
    Signed-off-by: Jeff Garzik <jeff@garzik.org>

diff --git a/drivers/scsi/hosts.c b/drivers/scsi/hosts.c
index ef57f253031c..dfcb96f3e60c 100644
--- a/drivers/scsi/hosts.c
+++ b/drivers/scsi/hosts.c
@@ -294,18 +294,6 @@ struct Scsi_Host *scsi_host_alloc(struct scsi_host_template *sht, int privsize)
 	if (sht->unchecked_isa_dma && privsize)
 		gfp_mask |= __GFP_DMA;
 
-        /* Check to see if this host has any error handling facilities */
-        if (!sht->eh_strategy_handler && !sht->eh_abort_handler &&
-	    !sht->eh_device_reset_handler && !sht->eh_bus_reset_handler &&
-            !sht->eh_host_reset_handler) {
-		printk(KERN_ERR "ERROR: SCSI host `%s' has no error handling\n"
-				"ERROR: This is not a safe way to run your "
-				        "SCSI host\n"
-				"ERROR: The error handling must be added to "
-				"this driver\n", sht->proc_name);
-		dump_stack();
-        }
-
 	shost = kzalloc(sizeof(struct Scsi_Host) + privsize, gfp_mask);
 	if (!shost)
 		return NULL;

commit 24669f75a3231fa37444977c92d1f4838bec1233
Author: Jes Sorensen <jes@sgi.com>
Date:   Mon Jan 16 10:31:18 2006 -0500

    [SCSI] SCSI core kmalloc2kzalloc
    
    Change the core SCSI code to use kzalloc rather than kmalloc+memset
    where possible.
    
    Signed-off-by: Jes Sorensen <jes@sgi.com>
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>

diff --git a/drivers/scsi/hosts.c b/drivers/scsi/hosts.c
index 588107923499..ef57f253031c 100644
--- a/drivers/scsi/hosts.c
+++ b/drivers/scsi/hosts.c
@@ -306,10 +306,9 @@ struct Scsi_Host *scsi_host_alloc(struct scsi_host_template *sht, int privsize)
 		dump_stack();
         }
 
-	shost = kmalloc(sizeof(struct Scsi_Host) + privsize, gfp_mask);
+	shost = kzalloc(sizeof(struct Scsi_Host) + privsize, gfp_mask);
 	if (!shost)
 		return NULL;
-	memset(shost, 0, sizeof(struct Scsi_Host) + privsize);
 
 	spin_lock_init(&shost->default_lock);
 	scsi_assign_lock(shost, &shost->default_lock);

commit 0b9506723826c68b50fa33e345700ddcac1bed36
Author: Arjan van de Ven <arjan@infradead.org>
Date:   Wed Jan 11 13:16:10 2006 +0100

    [SCSI] turn most scsi semaphores into mutexes
    
    the scsi layer is using semaphores in a mutex way, this patch converts
    these into using mutexes instead
    
    Signed-off-by: Arjan van de Ven <arjan@infradead.org>
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>

diff --git a/drivers/scsi/hosts.c b/drivers/scsi/hosts.c
index 66783c860a19..588107923499 100644
--- a/drivers/scsi/hosts.c
+++ b/drivers/scsi/hosts.c
@@ -156,16 +156,16 @@ EXPORT_SYMBOL(scsi_host_set_state);
 void scsi_remove_host(struct Scsi_Host *shost)
 {
 	unsigned long flags;
-	down(&shost->scan_mutex);
+	mutex_lock(&shost->scan_mutex);
 	spin_lock_irqsave(shost->host_lock, flags);
 	if (scsi_host_set_state(shost, SHOST_CANCEL))
 		if (scsi_host_set_state(shost, SHOST_CANCEL_RECOVERY)) {
 			spin_unlock_irqrestore(shost->host_lock, flags);
-			up(&shost->scan_mutex);
+			mutex_unlock(&shost->scan_mutex);
 			return;
 		}
 	spin_unlock_irqrestore(shost->host_lock, flags);
-	up(&shost->scan_mutex);
+	mutex_unlock(&shost->scan_mutex);
 	scsi_forget_host(shost);
 	scsi_proc_host_rm(shost);
 
@@ -320,7 +320,7 @@ struct Scsi_Host *scsi_host_alloc(struct scsi_host_template *sht, int privsize)
 	INIT_LIST_HEAD(&shost->starved_list);
 	init_waitqueue_head(&shost->host_wait);
 
-	init_MUTEX(&shost->scan_mutex);
+	mutex_init(&shost->scan_mutex);
 
 	shost->host_no = scsi_host_next_hn++; /* XXX(hch): still racy */
 	shost->dma_channel = 0xff;

commit 461d4e90c8cd049718884cd17c955e231140d3be
Author: Tejun Heo <htejun@gmail.com>
Date:   Fri Jan 6 09:52:55 2006 +0100

    [BLOCK] update SCSI to use new blk_ordered for barriers
    
    All ordered request related stuff delegated to HLD.  Midlayer
    now doens't deal with ordered setting or prepare_flush
    callback.  sd.c updated to deal with blk_queue_ordered
    setting.  Currently, ordered tag isn't used as SCSI midlayer
    cannot guarantee request ordering.
    
    Signed-off-by: Tejun Heo <htejun@gmail.com>
    Signed-off-by: Jens Axboe <axboe@suse.de>

diff --git a/drivers/scsi/hosts.c b/drivers/scsi/hosts.c
index 5b9c2c5a7f0e..66783c860a19 100644
--- a/drivers/scsi/hosts.c
+++ b/drivers/scsi/hosts.c
@@ -347,17 +347,8 @@ struct Scsi_Host *scsi_host_alloc(struct scsi_host_template *sht, int privsize)
 	shost->cmd_per_lun = sht->cmd_per_lun;
 	shost->unchecked_isa_dma = sht->unchecked_isa_dma;
 	shost->use_clustering = sht->use_clustering;
-	shost->ordered_flush = sht->ordered_flush;
 	shost->ordered_tag = sht->ordered_tag;
 
-	/*
-	 * hosts/devices that do queueing must support ordered tags
-	 */
-	if (shost->can_queue > 1 && shost->ordered_flush) {
-		printk(KERN_ERR "scsi: ordered flushes don't support queueing\n");
-		shost->ordered_flush = 0;
-	}
-
 	if (sht->max_host_blocked)
 		shost->max_host_blocked = sht->max_host_blocked;
 	else

commit 849a8924a6740ecbf9711e015beca69425f0c429
Merge: 7015faa7df82 ee807c2d43b5
Author: James Bottomley <jejb@titanic.(none)>
Date:   Fri Nov 4 22:29:52 2005 -0600

    Merge by Hand
    
    Conflicts in dec_esp.c (Thanks Bacchus), scsi_transport_iscsi.c and
    scsi_transport_fc.h
    
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>

commit d052d1beff706920e82c5d55006b08e256b5df09
Author: Russell King <rmk@dyn-67.arm.linux.org.uk>
Date:   Sat Oct 29 19:07:23 2005 +0100

    Create platform_device.h to contain all the platform device details.
    Convert everyone who uses platform_bus_type to include
    linux/platform_device.h.
    
    Signed-off-by: Russell King <rmk+kernel@arm.linux.org.uk>
    Acked-by: Greg Kroah-Hartman <gregkh@suse.de>

diff --git a/drivers/scsi/hosts.c b/drivers/scsi/hosts.c
index f24d84538fd5..71dd1ebbe58f 100644
--- a/drivers/scsi/hosts.c
+++ b/drivers/scsi/hosts.c
@@ -30,6 +30,7 @@
 #include <linux/init.h>
 #include <linux/completion.h>
 #include <linux/transport_class.h>
+#include <linux/platform_device.h>
 
 #include <scsi/scsi_device.h>
 #include <scsi/scsi_host.h>

commit 9ccfc756a70d454dfa82f48897e2883560c01a0e
Author: James Bottomley <James.Bottomley@steeleye.com>
Date:   Sun Oct 2 11:45:08 2005 -0500

    [SCSI] move the mid-layer printk's over to shost/starget/sdev_printk
    
    This should eliminate (at least in the mid layer) to make numeric
    assumptions about any of the enumeration variables.  As a side effect,
    it will also make all the messages consistent and line us up nicely for
    the error logging strategy (if it ever shows itself again).
    
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>

diff --git a/drivers/scsi/hosts.c b/drivers/scsi/hosts.c
index f24d84538fd5..0d48c9ceebd3 100644
--- a/drivers/scsi/hosts.c
+++ b/drivers/scsi/hosts.c
@@ -139,11 +139,11 @@ int scsi_host_set_state(struct Scsi_Host *shost, enum scsi_host_state state)
 
  illegal:
 	SCSI_LOG_ERROR_RECOVERY(1,
-				dev_printk(KERN_ERR, &shost->shost_gendev,
-					   "Illegal host state transition"
-					   "%s->%s\n",
-					   scsi_host_state_name(oldstate),
-					   scsi_host_state_name(state)));
+				shost_printk(KERN_ERR, shost,
+					     "Illegal host state transition"
+					     "%s->%s\n",
+					     scsi_host_state_name(oldstate),
+					     scsi_host_state_name(state)));
 	return -EINVAL;
 }
 EXPORT_SYMBOL(scsi_host_set_state);

commit c53033f6b0bd7cc133b7f433083f0394cf29ac70
Author: Al Viro <viro@zeniv.linux.org.uk>
Date:   Fri Oct 21 03:22:08 2005 -0400

    [PATCH] gfp_t: drivers/scsi
    
    Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/drivers/scsi/hosts.c b/drivers/scsi/hosts.c
index 02fe371b0ab8..f24d84538fd5 100644
--- a/drivers/scsi/hosts.c
+++ b/drivers/scsi/hosts.c
@@ -287,7 +287,8 @@ static void scsi_host_dev_release(struct device *dev)
 struct Scsi_Host *scsi_host_alloc(struct scsi_host_template *sht, int privsize)
 {
 	struct Scsi_Host *shost;
-	int gfp_mask = GFP_KERNEL, rval;
+	gfp_t gfp_mask = GFP_KERNEL;
+	int rval;
 
 	if (sht->unchecked_isa_dma && privsize)
 		gfp_mask |= __GFP_DMA;

commit 9e70592fcd87c90e9e98090d66cb79f39d740d4a
Author: James Bottomley <James.Bottomley@steeleye.com>
Date:   Sun Oct 2 12:59:49 2005 -0500

    [SCSI] fix potential panic with proc on module removal
    
    There's a problem in our host release in that it calls
    scsi_proc_hostdir_rm(). However, if you hold a reference to the host as
    you remove the module, the host template (which proc uses) will be freed
    and the system will panic when the host device is finally released.
    
    Fix this by moving scsi_proc_hostdir_rm() to where it should be: in
    scsi_remove_host().
    
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>

diff --git a/drivers/scsi/hosts.c b/drivers/scsi/hosts.c
index f2a72d33132c..02fe371b0ab8 100644
--- a/drivers/scsi/hosts.c
+++ b/drivers/scsi/hosts.c
@@ -176,6 +176,7 @@ void scsi_remove_host(struct Scsi_Host *shost)
 	transport_unregister_device(&shost->shost_gendev);
 	class_device_unregister(&shost->shost_classdev);
 	device_del(&shost->shost_gendev);
+	scsi_proc_hostdir_rm(shost->hostt);
 }
 EXPORT_SYMBOL(scsi_remove_host);
 
@@ -262,7 +263,6 @@ static void scsi_host_dev_release(struct device *dev)
 	if (shost->work_q)
 		destroy_workqueue(shost->work_q);
 
-	scsi_proc_hostdir_rm(shost->hostt);
 	scsi_destroy_command_freelist(shost);
 	kfree(shost->shost_data);
 

commit 939647ee308e0ad924e776657704c7bedd498664
Author: James Bottomley <James.Bottomley@steeleye.com>
Date:   Sun Sep 18 15:05:20 2005 -0500

    [SCSI] fix oops on usb storage device disconnect
    
    We fix the oops by enforcing the host state model.  There have also
    been two extra states added: SHOST_CANCEL_RECOVERY and
    SHOST_DEL_RECOVERY so we can take the model through host removal while
    the recovery thread is active.
    
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>

diff --git a/drivers/scsi/hosts.c b/drivers/scsi/hosts.c
index 85503fad789a..f2a72d33132c 100644
--- a/drivers/scsi/hosts.c
+++ b/drivers/scsi/hosts.c
@@ -98,6 +98,7 @@ int scsi_host_set_state(struct Scsi_Host *shost, enum scsi_host_state state)
 		switch (oldstate) {
 		case SHOST_CREATED:
 		case SHOST_RUNNING:
+		case SHOST_CANCEL_RECOVERY:
 			break;
 		default:
 			goto illegal;
@@ -107,12 +108,31 @@ int scsi_host_set_state(struct Scsi_Host *shost, enum scsi_host_state state)
 	case SHOST_DEL:
 		switch (oldstate) {
 		case SHOST_CANCEL:
+		case SHOST_DEL_RECOVERY:
 			break;
 		default:
 			goto illegal;
 		}
 		break;
 
+	case SHOST_CANCEL_RECOVERY:
+		switch (oldstate) {
+		case SHOST_CANCEL:
+		case SHOST_RECOVERY:
+			break;
+		default:
+			goto illegal;
+		}
+		break;
+
+	case SHOST_DEL_RECOVERY:
+		switch (oldstate) {
+		case SHOST_CANCEL_RECOVERY:
+			break;
+		default:
+			goto illegal;
+		}
+		break;
 	}
 	shost->shost_state = state;
 	return 0;
@@ -134,13 +154,24 @@ EXPORT_SYMBOL(scsi_host_set_state);
  **/
 void scsi_remove_host(struct Scsi_Host *shost)
 {
+	unsigned long flags;
 	down(&shost->scan_mutex);
-	scsi_host_set_state(shost, SHOST_CANCEL);
+	spin_lock_irqsave(shost->host_lock, flags);
+	if (scsi_host_set_state(shost, SHOST_CANCEL))
+		if (scsi_host_set_state(shost, SHOST_CANCEL_RECOVERY)) {
+			spin_unlock_irqrestore(shost->host_lock, flags);
+			up(&shost->scan_mutex);
+			return;
+		}
+	spin_unlock_irqrestore(shost->host_lock, flags);
 	up(&shost->scan_mutex);
 	scsi_forget_host(shost);
 	scsi_proc_host_rm(shost);
 
-	scsi_host_set_state(shost, SHOST_DEL);
+	spin_lock_irqsave(shost->host_lock, flags);
+	if (scsi_host_set_state(shost, SHOST_DEL))
+		BUG_ON(scsi_host_set_state(shost, SHOST_DEL_RECOVERY));
+	spin_unlock_irqrestore(shost->host_lock, flags);
 
 	transport_unregister_device(&shost->shost_gendev);
 	class_device_unregister(&shost->shost_classdev);

commit c5478def7a3a2dba9ceda452c2aa3539514d30a9
Author: Christoph Hellwig <hch@lst.de>
Date:   Tue Sep 6 14:04:26 2005 +0200

    [SCSI] switch EH thread startup to the kthread API
    
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>

diff --git a/drivers/scsi/hosts.c b/drivers/scsi/hosts.c
index 8640ad1c17e2..85503fad789a 100644
--- a/drivers/scsi/hosts.c
+++ b/drivers/scsi/hosts.c
@@ -24,6 +24,7 @@
 #include <linux/module.h>
 #include <linux/blkdev.h>
 #include <linux/kernel.h>
+#include <linux/kthread.h>
 #include <linux/string.h>
 #include <linux/mm.h>
 #include <linux/init.h>
@@ -225,15 +226,8 @@ static void scsi_host_dev_release(struct device *dev)
 	struct Scsi_Host *shost = dev_to_shost(dev);
 	struct device *parent = dev->parent;
 
-	if (shost->ehandler) {
-		DECLARE_COMPLETION(sem);
-		shost->eh_notify = &sem;
-		shost->eh_kill = 1;
-		up(shost->eh_wait);
-		wait_for_completion(&sem);
-		shost->eh_notify = NULL;
-	}
-
+	if (shost->ehandler)
+		kthread_stop(shost->ehandler);
 	if (shost->work_q)
 		destroy_workqueue(shost->work_q);
 
@@ -263,7 +257,6 @@ struct Scsi_Host *scsi_host_alloc(struct scsi_host_template *sht, int privsize)
 {
 	struct Scsi_Host *shost;
 	int gfp_mask = GFP_KERNEL, rval;
-	DECLARE_COMPLETION(complete);
 
 	if (sht->unchecked_isa_dma && privsize)
 		gfp_mask |= __GFP_DMA;
@@ -369,12 +362,12 @@ struct Scsi_Host *scsi_host_alloc(struct scsi_host_template *sht, int privsize)
 	snprintf(shost->shost_classdev.class_id, BUS_ID_SIZE, "host%d",
 		  shost->host_no);
 
-	shost->eh_notify = &complete;
-	rval = kernel_thread(scsi_error_handler, shost, 0);
-	if (rval < 0)
+	shost->ehandler = kthread_run(scsi_error_handler, shost,
+			"scsi_eh_%d", shost->host_no);
+	if (IS_ERR(shost->ehandler)) {
+		rval = PTR_ERR(shost->ehandler);
 		goto fail_destroy_freelist;
-	wait_for_completion(&complete);
-	shost->eh_notify = NULL;
+	}
 
 	scsi_proc_hostdir_add(shost->hostt);
 	return shost;

commit 82f29467a025f6a2192d281e97fca0be46e905cc
Author: Mike Anderson <andmike@us.ibm.com>
Date:   Thu Jun 16 11:14:33 2005 -0700

    [SCSI] host state model update: mediate host add/remove race
    
    Add support to not allow additions to a host when it is being removed.
    
    Signed-off-by: Mike Anderson <andmike@us.ibm.com>
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>

diff --git a/drivers/scsi/hosts.c b/drivers/scsi/hosts.c
index 67c4c0c3aa5e..8640ad1c17e2 100644
--- a/drivers/scsi/hosts.c
+++ b/drivers/scsi/hosts.c
@@ -133,7 +133,9 @@ EXPORT_SYMBOL(scsi_host_set_state);
  **/
 void scsi_remove_host(struct Scsi_Host *shost)
 {
+	down(&shost->scan_mutex);
 	scsi_host_set_state(shost, SHOST_CANCEL);
+	up(&shost->scan_mutex);
 	scsi_forget_host(shost);
 	scsi_proc_host_rm(shost);
 

commit d2c9d9eafa03dbd08a8a439e6c5addb8b1f03b9b
Author: Mike Anderson <andmike@us.ibm.com>
Date:   Thu Jun 16 11:13:42 2005 -0700

    [SCSI] host state model update: reimplement scsi_host_cancel
    
    Remove the old scsi_host_cancel function as it has not been working for
    sometime do to the device list possibly being empty when it is called and
    possible race issues. Add setting of SHOST_CANCEL at the state of beginning
    of scsi_remove_host.
    
    Signed-off-by: Mike Anderson <andmike@us.ibm.com>
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>

diff --git a/drivers/scsi/hosts.c b/drivers/scsi/hosts.c
index 6828ca305c2a..67c4c0c3aa5e 100644
--- a/drivers/scsi/hosts.c
+++ b/drivers/scsi/hosts.c
@@ -127,30 +127,14 @@ int scsi_host_set_state(struct Scsi_Host *shost, enum scsi_host_state state)
 }
 EXPORT_SYMBOL(scsi_host_set_state);
 
-/**
- * scsi_host_cancel - cancel outstanding IO to this host
- * @shost:	pointer to struct Scsi_Host
- * recovery:	recovery requested to run.
- **/
-static void scsi_host_cancel(struct Scsi_Host *shost, int recovery)
-{
-	struct scsi_device *sdev;
-
-	scsi_host_set_state(shost, SHOST_CANCEL);
-	shost_for_each_device(sdev, shost) {
-		scsi_device_cancel(sdev, recovery);
-	}
-	wait_event(shost->host_wait, (shost->shost_state != SHOST_RECOVERY));
-}
-
 /**
  * scsi_remove_host - remove a scsi host
  * @shost:	a pointer to a scsi host to remove
  **/
 void scsi_remove_host(struct Scsi_Host *shost)
 {
+	scsi_host_set_state(shost, SHOST_CANCEL);
 	scsi_forget_host(shost);
-	scsi_host_cancel(shost, 0);
 	scsi_proc_host_rm(shost);
 
 	scsi_host_set_state(shost, SHOST_DEL);

commit d3301874083874f8a0ac88aa1bb7da6b62df34d2
Author: Mike Anderson <andmike@us.ibm.com>
Date:   Thu Jun 16 11:12:38 2005 -0700

    [SCSI] host state model update: replace old host bitmap state
    
    Migrate the current SCSI host state model to a model like SCSI
    device is using.
    
    Signed-off-by: Mike Anderson <andmike@us.ibm.com>
    
    Rejections fixed up and
    
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>

diff --git a/drivers/scsi/hosts.c b/drivers/scsi/hosts.c
index 5feb886c3392..6828ca305c2a 100644
--- a/drivers/scsi/hosts.c
+++ b/drivers/scsi/hosts.c
@@ -51,6 +51,82 @@ static struct class shost_class = {
 	.release	= scsi_host_cls_release,
 };
 
+/**
+ *	scsi_host_set_state - Take the given host through the host
+ *		state model.
+ *	@shost:	scsi host to change the state of.
+ *	@state:	state to change to.
+ *
+ *	Returns zero if unsuccessful or an error if the requested
+ *	transition is illegal.
+ **/
+int scsi_host_set_state(struct Scsi_Host *shost, enum scsi_host_state state)
+{
+	enum scsi_host_state oldstate = shost->shost_state;
+
+	if (state == oldstate)
+		return 0;
+
+	switch (state) {
+	case SHOST_CREATED:
+		/* There are no legal states that come back to
+		 * created.  This is the manually initialised start
+		 * state */
+		goto illegal;
+
+	case SHOST_RUNNING:
+		switch (oldstate) {
+		case SHOST_CREATED:
+		case SHOST_RECOVERY:
+			break;
+		default:
+			goto illegal;
+		}
+		break;
+
+	case SHOST_RECOVERY:
+		switch (oldstate) {
+		case SHOST_RUNNING:
+			break;
+		default:
+			goto illegal;
+		}
+		break;
+
+	case SHOST_CANCEL:
+		switch (oldstate) {
+		case SHOST_CREATED:
+		case SHOST_RUNNING:
+			break;
+		default:
+			goto illegal;
+		}
+		break;
+
+	case SHOST_DEL:
+		switch (oldstate) {
+		case SHOST_CANCEL:
+			break;
+		default:
+			goto illegal;
+		}
+		break;
+
+	}
+	shost->shost_state = state;
+	return 0;
+
+ illegal:
+	SCSI_LOG_ERROR_RECOVERY(1,
+				dev_printk(KERN_ERR, &shost->shost_gendev,
+					   "Illegal host state transition"
+					   "%s->%s\n",
+					   scsi_host_state_name(oldstate),
+					   scsi_host_state_name(state)));
+	return -EINVAL;
+}
+EXPORT_SYMBOL(scsi_host_set_state);
+
 /**
  * scsi_host_cancel - cancel outstanding IO to this host
  * @shost:	pointer to struct Scsi_Host
@@ -60,12 +136,11 @@ static void scsi_host_cancel(struct Scsi_Host *shost, int recovery)
 {
 	struct scsi_device *sdev;
 
-	set_bit(SHOST_CANCEL, &shost->shost_state);
+	scsi_host_set_state(shost, SHOST_CANCEL);
 	shost_for_each_device(sdev, shost) {
 		scsi_device_cancel(sdev, recovery);
 	}
-	wait_event(shost->host_wait, (!test_bit(SHOST_RECOVERY,
-						&shost->shost_state)));
+	wait_event(shost->host_wait, (shost->shost_state != SHOST_RECOVERY));
 }
 
 /**
@@ -78,7 +153,7 @@ void scsi_remove_host(struct Scsi_Host *shost)
 	scsi_host_cancel(shost, 0);
 	scsi_proc_host_rm(shost);
 
-	set_bit(SHOST_DEL, &shost->shost_state);
+	scsi_host_set_state(shost, SHOST_DEL);
 
 	transport_unregister_device(&shost->shost_gendev);
 	class_device_unregister(&shost->shost_classdev);
@@ -115,7 +190,7 @@ int scsi_add_host(struct Scsi_Host *shost, struct device *dev)
 	if (error)
 		goto out;
 
-	set_bit(SHOST_ADD, &shost->shost_state);
+	scsi_host_set_state(shost, SHOST_RUNNING);
 	get_device(shost->shost_gendev.parent);
 
 	error = class_device_add(&shost->shost_classdev);
@@ -226,6 +301,7 @@ struct Scsi_Host *scsi_host_alloc(struct scsi_host_template *sht, int privsize)
 
 	spin_lock_init(&shost->default_lock);
 	scsi_assign_lock(shost, &shost->default_lock);
+	shost->shost_state = SHOST_CREATED;
 	INIT_LIST_HEAD(&shost->__devices);
 	INIT_LIST_HEAD(&shost->__targets);
 	INIT_LIST_HEAD(&shost->eh_cmd_q);
@@ -382,7 +458,7 @@ EXPORT_SYMBOL(scsi_host_lookup);
  **/
 struct Scsi_Host *scsi_host_get(struct Scsi_Host *shost)
 {
-	if (test_bit(SHOST_DEL, &shost->shost_state) ||
+	if ((shost->shost_state == SHOST_DEL) ||
 		!get_device(&shost->shost_gendev))
 		return NULL;
 	return shost;

commit 12413197eef2a29e0b9fb0fa541f5cbaeb1d3f3f
Author: Christoph Hellwig <hch@lst.de>
Date:   Sat Jun 11 01:05:01 2005 +0200

    [SCSI] remove scsi_set_device
    
    scsi_add_host is the proper place to set the device, but people copy
    the scsi_set_device usage from older drivers again and again.
    
    note that this leaves some legacy drivers like qlogicisp/qlogicfc
    without pci association in sysfs, but they're scheduled to go away soon
    anyway.
    
    Signed-off-by: James Bottomley <James.Bottomley@SteelEye.com>

diff --git a/drivers/scsi/hosts.c b/drivers/scsi/hosts.c
index d7a38b6713f9..5feb886c3392 100644
--- a/drivers/scsi/hosts.c
+++ b/drivers/scsi/hosts.c
@@ -180,11 +180,6 @@ static void scsi_host_dev_release(struct device *dev)
 	scsi_destroy_command_freelist(shost);
 	kfree(shost->shost_data);
 
-	/*
-	 * Some drivers (eg aha1542) do scsi_register()/scsi_unregister()
-	 * during probing without performing a scsi_set_device() in between.
-	 * In this case dev->parent is NULL.
-	 */
 	if (parent)
 		put_device(parent);
 	kfree(shost);

commit 52c1da39534fb382c061de58b65f678ad74b59f5
Author: Adrian Bunk <bunk@stusta.de>
Date:   Thu Jun 23 22:05:33 2005 -0700

    [PATCH] make various thing static
    
    Another rollup of patches which give various symbols static scope
    
    Signed-off-by: Adrian Bunk <bunk@stusta.de>
    Signed-off-by: Andrew Morton <akpm@osdl.org>
    Signed-off-by: Linus Torvalds <torvalds@osdl.org>

diff --git a/drivers/scsi/hosts.c b/drivers/scsi/hosts.c
index ba347576d99b..d7a38b6713f9 100644
--- a/drivers/scsi/hosts.c
+++ b/drivers/scsi/hosts.c
@@ -56,7 +56,7 @@ static struct class shost_class = {
  * @shost:	pointer to struct Scsi_Host
  * recovery:	recovery requested to run.
  **/
-void scsi_host_cancel(struct Scsi_Host *shost, int recovery)
+static void scsi_host_cancel(struct Scsi_Host *shost, int recovery)
 {
 	struct scsi_device *sdev;
 

commit 1da177e4c3f41524e886b7f1b8a0c1fc7321cac2
Author: Linus Torvalds <torvalds@ppc970.osdl.org>
Date:   Sat Apr 16 15:20:36 2005 -0700

    Linux-2.6.12-rc2
    
    Initial git repository build. I'm not bothering with the full history,
    even though we have it. We can create a separate "historical" git
    archive of that later if we want to, and in the meantime it's about
    3.2GB when imported into git - space that would just make the early
    git days unnecessarily complicated, when we don't have a lot of good
    infrastructure for it.
    
    Let it rip!

diff --git a/drivers/scsi/hosts.c b/drivers/scsi/hosts.c
new file mode 100644
index 000000000000..ba347576d99b
--- /dev/null
+++ b/drivers/scsi/hosts.c
@@ -0,0 +1,462 @@
+/*
+ *  hosts.c Copyright (C) 1992 Drew Eckhardt
+ *          Copyright (C) 1993, 1994, 1995 Eric Youngdale
+ *          Copyright (C) 2002-2003 Christoph Hellwig
+ *
+ *  mid to lowlevel SCSI driver interface
+ *      Initial versions: Drew Eckhardt
+ *      Subsequent revisions: Eric Youngdale
+ *
+ *  <drew@colorado.edu>
+ *
+ *  Jiffies wrap fixes (host->resetting), 3 Dec 1998 Andrea Arcangeli
+ *  Added QLOGIC QLA1280 SCSI controller kernel host support. 
+ *     August 4, 1999 Fred Lewis, Intel DuPont
+ *
+ *  Updated to reflect the new initialization scheme for the higher 
+ *  level of scsi drivers (sd/sr/st)
+ *  September 17, 2000 Torben Mathiasen <tmm@image.dk>
+ *
+ *  Restructured scsi_host lists and associated functions.
+ *  September 04, 2002 Mike Anderson (andmike@us.ibm.com)
+ */
+
+#include <linux/module.h>
+#include <linux/blkdev.h>
+#include <linux/kernel.h>
+#include <linux/string.h>
+#include <linux/mm.h>
+#include <linux/init.h>
+#include <linux/completion.h>
+#include <linux/transport_class.h>
+
+#include <scsi/scsi_device.h>
+#include <scsi/scsi_host.h>
+#include <scsi/scsi_transport.h>
+
+#include "scsi_priv.h"
+#include "scsi_logging.h"
+
+
+static int scsi_host_next_hn;		/* host_no for next new host */
+
+
+static void scsi_host_cls_release(struct class_device *class_dev)
+{
+	put_device(&class_to_shost(class_dev)->shost_gendev);
+}
+
+static struct class shost_class = {
+	.name		= "scsi_host",
+	.release	= scsi_host_cls_release,
+};
+
+/**
+ * scsi_host_cancel - cancel outstanding IO to this host
+ * @shost:	pointer to struct Scsi_Host
+ * recovery:	recovery requested to run.
+ **/
+void scsi_host_cancel(struct Scsi_Host *shost, int recovery)
+{
+	struct scsi_device *sdev;
+
+	set_bit(SHOST_CANCEL, &shost->shost_state);
+	shost_for_each_device(sdev, shost) {
+		scsi_device_cancel(sdev, recovery);
+	}
+	wait_event(shost->host_wait, (!test_bit(SHOST_RECOVERY,
+						&shost->shost_state)));
+}
+
+/**
+ * scsi_remove_host - remove a scsi host
+ * @shost:	a pointer to a scsi host to remove
+ **/
+void scsi_remove_host(struct Scsi_Host *shost)
+{
+	scsi_forget_host(shost);
+	scsi_host_cancel(shost, 0);
+	scsi_proc_host_rm(shost);
+
+	set_bit(SHOST_DEL, &shost->shost_state);
+
+	transport_unregister_device(&shost->shost_gendev);
+	class_device_unregister(&shost->shost_classdev);
+	device_del(&shost->shost_gendev);
+}
+EXPORT_SYMBOL(scsi_remove_host);
+
+/**
+ * scsi_add_host - add a scsi host
+ * @shost:	scsi host pointer to add
+ * @dev:	a struct device of type scsi class
+ *
+ * Return value: 
+ * 	0 on success / != 0 for error
+ **/
+int scsi_add_host(struct Scsi_Host *shost, struct device *dev)
+{
+	struct scsi_host_template *sht = shost->hostt;
+	int error = -EINVAL;
+
+	printk(KERN_INFO "scsi%d : %s\n", shost->host_no,
+			sht->info ? sht->info(shost) : sht->name);
+
+	if (!shost->can_queue) {
+		printk(KERN_ERR "%s: can_queue = 0 no longer supported\n",
+				sht->name);
+		goto out;
+	}
+
+	if (!shost->shost_gendev.parent)
+		shost->shost_gendev.parent = dev ? dev : &platform_bus;
+
+	error = device_add(&shost->shost_gendev);
+	if (error)
+		goto out;
+
+	set_bit(SHOST_ADD, &shost->shost_state);
+	get_device(shost->shost_gendev.parent);
+
+	error = class_device_add(&shost->shost_classdev);
+	if (error)
+		goto out_del_gendev;
+
+	get_device(&shost->shost_gendev);
+
+	if (shost->transportt->host_size &&
+	    (shost->shost_data = kmalloc(shost->transportt->host_size,
+					 GFP_KERNEL)) == NULL)
+		goto out_del_classdev;
+
+	if (shost->transportt->create_work_queue) {
+		snprintf(shost->work_q_name, KOBJ_NAME_LEN, "scsi_wq_%d",
+			shost->host_no);
+		shost->work_q = create_singlethread_workqueue(
+					shost->work_q_name);
+		if (!shost->work_q)
+			goto out_free_shost_data;
+	}
+
+	error = scsi_sysfs_add_host(shost);
+	if (error)
+		goto out_destroy_host;
+
+	scsi_proc_host_add(shost);
+	return error;
+
+ out_destroy_host:
+	if (shost->work_q)
+		destroy_workqueue(shost->work_q);
+ out_free_shost_data:
+	kfree(shost->shost_data);
+ out_del_classdev:
+	class_device_del(&shost->shost_classdev);
+ out_del_gendev:
+	device_del(&shost->shost_gendev);
+ out:
+	return error;
+}
+EXPORT_SYMBOL(scsi_add_host);
+
+static void scsi_host_dev_release(struct device *dev)
+{
+	struct Scsi_Host *shost = dev_to_shost(dev);
+	struct device *parent = dev->parent;
+
+	if (shost->ehandler) {
+		DECLARE_COMPLETION(sem);
+		shost->eh_notify = &sem;
+		shost->eh_kill = 1;
+		up(shost->eh_wait);
+		wait_for_completion(&sem);
+		shost->eh_notify = NULL;
+	}
+
+	if (shost->work_q)
+		destroy_workqueue(shost->work_q);
+
+	scsi_proc_hostdir_rm(shost->hostt);
+	scsi_destroy_command_freelist(shost);
+	kfree(shost->shost_data);
+
+	/*
+	 * Some drivers (eg aha1542) do scsi_register()/scsi_unregister()
+	 * during probing without performing a scsi_set_device() in between.
+	 * In this case dev->parent is NULL.
+	 */
+	if (parent)
+		put_device(parent);
+	kfree(shost);
+}
+
+/**
+ * scsi_host_alloc - register a scsi host adapter instance.
+ * @sht:	pointer to scsi host template
+ * @privsize:	extra bytes to allocate for driver
+ *
+ * Note:
+ * 	Allocate a new Scsi_Host and perform basic initialization.
+ * 	The host is not published to the scsi midlayer until scsi_add_host
+ * 	is called.
+ *
+ * Return value:
+ * 	Pointer to a new Scsi_Host
+ **/
+struct Scsi_Host *scsi_host_alloc(struct scsi_host_template *sht, int privsize)
+{
+	struct Scsi_Host *shost;
+	int gfp_mask = GFP_KERNEL, rval;
+	DECLARE_COMPLETION(complete);
+
+	if (sht->unchecked_isa_dma && privsize)
+		gfp_mask |= __GFP_DMA;
+
+        /* Check to see if this host has any error handling facilities */
+        if (!sht->eh_strategy_handler && !sht->eh_abort_handler &&
+	    !sht->eh_device_reset_handler && !sht->eh_bus_reset_handler &&
+            !sht->eh_host_reset_handler) {
+		printk(KERN_ERR "ERROR: SCSI host `%s' has no error handling\n"
+				"ERROR: This is not a safe way to run your "
+				        "SCSI host\n"
+				"ERROR: The error handling must be added to "
+				"this driver\n", sht->proc_name);
+		dump_stack();
+        }
+
+	shost = kmalloc(sizeof(struct Scsi_Host) + privsize, gfp_mask);
+	if (!shost)
+		return NULL;
+	memset(shost, 0, sizeof(struct Scsi_Host) + privsize);
+
+	spin_lock_init(&shost->default_lock);
+	scsi_assign_lock(shost, &shost->default_lock);
+	INIT_LIST_HEAD(&shost->__devices);
+	INIT_LIST_HEAD(&shost->__targets);
+	INIT_LIST_HEAD(&shost->eh_cmd_q);
+	INIT_LIST_HEAD(&shost->starved_list);
+	init_waitqueue_head(&shost->host_wait);
+
+	init_MUTEX(&shost->scan_mutex);
+
+	shost->host_no = scsi_host_next_hn++; /* XXX(hch): still racy */
+	shost->dma_channel = 0xff;
+
+	/* These three are default values which can be overridden */
+	shost->max_channel = 0;
+	shost->max_id = 8;
+	shost->max_lun = 8;
+
+	/* Give each shost a default transportt */
+	shost->transportt = &blank_transport_template;
+
+	/*
+	 * All drivers right now should be able to handle 12 byte
+	 * commands.  Every so often there are requests for 16 byte
+	 * commands, but individual low-level drivers need to certify that
+	 * they actually do something sensible with such commands.
+	 */
+	shost->max_cmd_len = 12;
+	shost->hostt = sht;
+	shost->this_id = sht->this_id;
+	shost->can_queue = sht->can_queue;
+	shost->sg_tablesize = sht->sg_tablesize;
+	shost->cmd_per_lun = sht->cmd_per_lun;
+	shost->unchecked_isa_dma = sht->unchecked_isa_dma;
+	shost->use_clustering = sht->use_clustering;
+	shost->ordered_flush = sht->ordered_flush;
+	shost->ordered_tag = sht->ordered_tag;
+
+	/*
+	 * hosts/devices that do queueing must support ordered tags
+	 */
+	if (shost->can_queue > 1 && shost->ordered_flush) {
+		printk(KERN_ERR "scsi: ordered flushes don't support queueing\n");
+		shost->ordered_flush = 0;
+	}
+
+	if (sht->max_host_blocked)
+		shost->max_host_blocked = sht->max_host_blocked;
+	else
+		shost->max_host_blocked = SCSI_DEFAULT_HOST_BLOCKED;
+
+	/*
+	 * If the driver imposes no hard sector transfer limit, start at
+	 * machine infinity initially.
+	 */
+	if (sht->max_sectors)
+		shost->max_sectors = sht->max_sectors;
+	else
+		shost->max_sectors = SCSI_DEFAULT_MAX_SECTORS;
+
+	/*
+	 * assume a 4GB boundary, if not set
+	 */
+	if (sht->dma_boundary)
+		shost->dma_boundary = sht->dma_boundary;
+	else
+		shost->dma_boundary = 0xffffffff;
+
+	rval = scsi_setup_command_freelist(shost);
+	if (rval)
+		goto fail_kfree;
+
+	device_initialize(&shost->shost_gendev);
+	snprintf(shost->shost_gendev.bus_id, BUS_ID_SIZE, "host%d",
+		shost->host_no);
+	shost->shost_gendev.release = scsi_host_dev_release;
+
+	class_device_initialize(&shost->shost_classdev);
+	shost->shost_classdev.dev = &shost->shost_gendev;
+	shost->shost_classdev.class = &shost_class;
+	snprintf(shost->shost_classdev.class_id, BUS_ID_SIZE, "host%d",
+		  shost->host_no);
+
+	shost->eh_notify = &complete;
+	rval = kernel_thread(scsi_error_handler, shost, 0);
+	if (rval < 0)
+		goto fail_destroy_freelist;
+	wait_for_completion(&complete);
+	shost->eh_notify = NULL;
+
+	scsi_proc_hostdir_add(shost->hostt);
+	return shost;
+
+ fail_destroy_freelist:
+	scsi_destroy_command_freelist(shost);
+ fail_kfree:
+	kfree(shost);
+	return NULL;
+}
+EXPORT_SYMBOL(scsi_host_alloc);
+
+struct Scsi_Host *scsi_register(struct scsi_host_template *sht, int privsize)
+{
+	struct Scsi_Host *shost = scsi_host_alloc(sht, privsize);
+
+	if (!sht->detect) {
+		printk(KERN_WARNING "scsi_register() called on new-style "
+				    "template for driver %s\n", sht->name);
+		dump_stack();
+	}
+
+	if (shost)
+		list_add_tail(&shost->sht_legacy_list, &sht->legacy_hosts);
+	return shost;
+}
+EXPORT_SYMBOL(scsi_register);
+
+void scsi_unregister(struct Scsi_Host *shost)
+{
+	list_del(&shost->sht_legacy_list);
+	scsi_host_put(shost);
+}
+EXPORT_SYMBOL(scsi_unregister);
+
+/**
+ * scsi_host_lookup - get a reference to a Scsi_Host by host no
+ *
+ * @hostnum:	host number to locate
+ *
+ * Return value:
+ *	A pointer to located Scsi_Host or NULL.
+ **/
+struct Scsi_Host *scsi_host_lookup(unsigned short hostnum)
+{
+	struct class *class = &shost_class;
+	struct class_device *cdev;
+	struct Scsi_Host *shost = ERR_PTR(-ENXIO), *p;
+
+	down_read(&class->subsys.rwsem);
+	list_for_each_entry(cdev, &class->children, node) {
+		p = class_to_shost(cdev);
+		if (p->host_no == hostnum) {
+			shost = scsi_host_get(p);
+			break;
+		}
+	}
+	up_read(&class->subsys.rwsem);
+
+	return shost;
+}
+EXPORT_SYMBOL(scsi_host_lookup);
+
+/**
+ * scsi_host_get - inc a Scsi_Host ref count
+ * @shost:	Pointer to Scsi_Host to inc.
+ **/
+struct Scsi_Host *scsi_host_get(struct Scsi_Host *shost)
+{
+	if (test_bit(SHOST_DEL, &shost->shost_state) ||
+		!get_device(&shost->shost_gendev))
+		return NULL;
+	return shost;
+}
+EXPORT_SYMBOL(scsi_host_get);
+
+/**
+ * scsi_host_put - dec a Scsi_Host ref count
+ * @shost:	Pointer to Scsi_Host to dec.
+ **/
+void scsi_host_put(struct Scsi_Host *shost)
+{
+	put_device(&shost->shost_gendev);
+}
+EXPORT_SYMBOL(scsi_host_put);
+
+int scsi_init_hosts(void)
+{
+	return class_register(&shost_class);
+}
+
+void scsi_exit_hosts(void)
+{
+	class_unregister(&shost_class);
+}
+
+int scsi_is_host_device(const struct device *dev)
+{
+	return dev->release == scsi_host_dev_release;
+}
+EXPORT_SYMBOL(scsi_is_host_device);
+
+/**
+ * scsi_queue_work - Queue work to the Scsi_Host workqueue.
+ * @shost:	Pointer to Scsi_Host.
+ * @work:	Work to queue for execution.
+ *
+ * Return value:
+ * 	0 on success / != 0 for error
+ **/
+int scsi_queue_work(struct Scsi_Host *shost, struct work_struct *work)
+{
+	if (unlikely(!shost->work_q)) {
+		printk(KERN_ERR
+			"ERROR: Scsi host '%s' attempted to queue scsi-work, "
+			"when no workqueue created.\n", shost->hostt->name);
+		dump_stack();
+
+		return -EINVAL;
+	}
+
+	return queue_work(shost->work_q, work);
+}
+EXPORT_SYMBOL_GPL(scsi_queue_work);
+
+/**
+ * scsi_flush_work - Flush a Scsi_Host's workqueue.
+ * @shost:	Pointer to Scsi_Host.
+ **/
+void scsi_flush_work(struct Scsi_Host *shost)
+{
+	if (!shost->work_q) {
+		printk(KERN_ERR
+			"ERROR: Scsi host '%s' attempted to flush scsi-work, "
+			"when no workqueue created.\n", shost->hostt->name);
+		dump_stack();
+		return;
+	}
+
+	flush_workqueue(shost->work_q);
+}
+EXPORT_SYMBOL_GPL(scsi_flush_work);
